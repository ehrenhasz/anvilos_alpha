{
  "module_name": "text-patching.h",
  "hash_id": "e0925a3446bfaff4a43b5f6b40f9c6d755ab26852544f0825b9e786863363f21",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/text-patching.h",
  "human_readable_source": " \n#ifndef _ASM_X86_TEXT_PATCHING_H\n#define _ASM_X86_TEXT_PATCHING_H\n\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <asm/ptrace.h>\n\nstruct paravirt_patch_site;\n#ifdef CONFIG_PARAVIRT\nvoid apply_paravirt(struct paravirt_patch_site *start,\n\t\t    struct paravirt_patch_site *end);\n#else\nstatic inline void apply_paravirt(struct paravirt_patch_site *start,\n\t\t\t\t  struct paravirt_patch_site *end)\n{}\n#define __parainstructions\tNULL\n#define __parainstructions_end\tNULL\n#endif\n\n \n#define POKE_MAX_OPCODE_SIZE\t5\n\nextern void text_poke_early(void *addr, const void *opcode, size_t len);\n\n \nextern void *text_poke(void *addr, const void *opcode, size_t len);\nextern void text_poke_sync(void);\nextern void *text_poke_kgdb(void *addr, const void *opcode, size_t len);\nextern void *text_poke_copy(void *addr, const void *opcode, size_t len);\nextern void *text_poke_copy_locked(void *addr, const void *opcode, size_t len, bool core_ok);\nextern void *text_poke_set(void *addr, int c, size_t len);\nextern int poke_int3_handler(struct pt_regs *regs);\nextern void text_poke_bp(void *addr, const void *opcode, size_t len, const void *emulate);\n\nextern void text_poke_queue(void *addr, const void *opcode, size_t len, const void *emulate);\nextern void text_poke_finish(void);\n\n#define INT3_INSN_SIZE\t\t1\n#define INT3_INSN_OPCODE\t0xCC\n\n#define RET_INSN_SIZE\t\t1\n#define RET_INSN_OPCODE\t\t0xC3\n\n#define CALL_INSN_SIZE\t\t5\n#define CALL_INSN_OPCODE\t0xE8\n\n#define JMP32_INSN_SIZE\t\t5\n#define JMP32_INSN_OPCODE\t0xE9\n\n#define JMP8_INSN_SIZE\t\t2\n#define JMP8_INSN_OPCODE\t0xEB\n\n#define DISP32_SIZE\t\t4\n\nstatic __always_inline int text_opcode_size(u8 opcode)\n{\n\tint size = 0;\n\n#define __CASE(insn)\t\\\n\tcase insn##_INSN_OPCODE: size = insn##_INSN_SIZE; break\n\n\tswitch(opcode) {\n\t__CASE(INT3);\n\t__CASE(RET);\n\t__CASE(CALL);\n\t__CASE(JMP32);\n\t__CASE(JMP8);\n\t}\n\n#undef __CASE\n\n\treturn size;\n}\n\nunion text_poke_insn {\n\tu8 text[POKE_MAX_OPCODE_SIZE];\n\tstruct {\n\t\tu8 opcode;\n\t\ts32 disp;\n\t} __attribute__((packed));\n};\n\nstatic __always_inline\nvoid __text_gen_insn(void *buf, u8 opcode, const void *addr, const void *dest, int size)\n{\n\tunion text_poke_insn *insn = buf;\n\n\tBUG_ON(size < text_opcode_size(opcode));\n\n\t \n\tOPTIMIZER_HIDE_VAR(insn);\n\tOPTIMIZER_HIDE_VAR(addr);\n\tOPTIMIZER_HIDE_VAR(dest);\n\n\tinsn->opcode = opcode;\n\n\tif (size > 1) {\n\t\tinsn->disp = (long)dest - (long)(addr + size);\n\t\tif (size == 2) {\n\t\t\t \n\t\t\tBUG_ON((insn->disp >> 31) != (insn->disp >> 7));\n\t\t}\n\t}\n}\n\nstatic __always_inline\nvoid *text_gen_insn(u8 opcode, const void *addr, const void *dest)\n{\n\tstatic union text_poke_insn insn;  \n\t__text_gen_insn(&insn, opcode, addr, dest, text_opcode_size(opcode));\n\treturn &insn.text;\n}\n\nextern int after_bootmem;\nextern __ro_after_init struct mm_struct *poking_mm;\nextern __ro_after_init unsigned long poking_addr;\n\n#ifndef CONFIG_UML_X86\nstatic __always_inline\nvoid int3_emulate_jmp(struct pt_regs *regs, unsigned long ip)\n{\n\tregs->ip = ip;\n}\n\nstatic __always_inline\nvoid int3_emulate_push(struct pt_regs *regs, unsigned long val)\n{\n\t \n\tregs->sp -= sizeof(unsigned long);\n\t*(unsigned long *)regs->sp = val;\n}\n\nstatic __always_inline\nunsigned long int3_emulate_pop(struct pt_regs *regs)\n{\n\tunsigned long val = *(unsigned long *)regs->sp;\n\tregs->sp += sizeof(unsigned long);\n\treturn val;\n}\n\nstatic __always_inline\nvoid int3_emulate_call(struct pt_regs *regs, unsigned long func)\n{\n\tint3_emulate_push(regs, regs->ip - INT3_INSN_SIZE + CALL_INSN_SIZE);\n\tint3_emulate_jmp(regs, func);\n}\n\nstatic __always_inline\nvoid int3_emulate_ret(struct pt_regs *regs)\n{\n\tunsigned long ip = int3_emulate_pop(regs);\n\tint3_emulate_jmp(regs, ip);\n}\n\nstatic __always_inline\nvoid int3_emulate_jcc(struct pt_regs *regs, u8 cc, unsigned long ip, unsigned long disp)\n{\n\tstatic const unsigned long jcc_mask[6] = {\n\t\t[0] = X86_EFLAGS_OF,\n\t\t[1] = X86_EFLAGS_CF,\n\t\t[2] = X86_EFLAGS_ZF,\n\t\t[3] = X86_EFLAGS_CF | X86_EFLAGS_ZF,\n\t\t[4] = X86_EFLAGS_SF,\n\t\t[5] = X86_EFLAGS_PF,\n\t};\n\n\tbool invert = cc & 1;\n\tbool match;\n\n\tif (cc < 0xc) {\n\t\tmatch = regs->flags & jcc_mask[cc >> 1];\n\t} else {\n\t\tmatch = ((regs->flags & X86_EFLAGS_SF) >> X86_EFLAGS_SF_BIT) ^\n\t\t\t((regs->flags & X86_EFLAGS_OF) >> X86_EFLAGS_OF_BIT);\n\t\tif (cc >= 0xe)\n\t\t\tmatch = match || (regs->flags & X86_EFLAGS_ZF);\n\t}\n\n\tif ((match && !invert) || (!match && invert))\n\t\tip += disp;\n\n\tint3_emulate_jmp(regs, ip);\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}