{
  "module_name": "efi.h",
  "hash_id": "ecfdb3c90bc9a339b73cfc66f6bee0a370e38b8743d921c9a688988c93559d3a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/efi.h",
  "human_readable_source": " \n#ifndef _ASM_X86_EFI_H\n#define _ASM_X86_EFI_H\n\n#include <asm/fpu/api.h>\n#include <asm/processor-flags.h>\n#include <asm/tlb.h>\n#include <asm/nospec-branch.h>\n#include <asm/mmu_context.h>\n#include <asm/ibt.h>\n#include <linux/build_bug.h>\n#include <linux/kernel.h>\n#include <linux/pgtable.h>\n\nextern unsigned long efi_fw_vendor, efi_config_table;\nextern unsigned long efi_mixed_mode_stack_pa;\n\n \n\n#define EFI32_LOADER_SIGNATURE\t\"EL32\"\n#define EFI64_LOADER_SIGNATURE\t\"EL64\"\n\n#define ARCH_EFI_IRQ_FLAGS_MASK\tX86_EFLAGS_IF\n\n#define EFI_UNACCEPTED_UNIT_SIZE PMD_SIZE\n\n \n\n#define __efi_nargs(...) __efi_nargs_(__VA_ARGS__)\n#define __efi_nargs_(...) __efi_nargs__(0, ##__VA_ARGS__,\t\\\n\t__efi_arg_sentinel(9), __efi_arg_sentinel(8),\t\t\\\n\t__efi_arg_sentinel(7), __efi_arg_sentinel(6),\t\t\\\n\t__efi_arg_sentinel(5), __efi_arg_sentinel(4),\t\t\\\n\t__efi_arg_sentinel(3), __efi_arg_sentinel(2),\t\t\\\n\t__efi_arg_sentinel(1), __efi_arg_sentinel(0))\n#define __efi_nargs__(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, n, ...)\t\\\n\t__take_second_arg(n,\t\t\t\t\t\\\n\t\t({ BUILD_BUG_ON_MSG(1, \"__efi_nargs limit exceeded\"); 10; }))\n#define __efi_arg_sentinel(n) , n\n\n \n\n#define __efi_nargs_check(f, n, ...)\t\t\t\t\t\\\n\t__efi_nargs_check_(f, __efi_nargs(__VA_ARGS__), n)\n#define __efi_nargs_check_(f, p, n) __efi_nargs_check__(f, p, n)\n#define __efi_nargs_check__(f, p, n) ({\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(\t\t\t\t\t\t\\\n\t\t(p) > (n),\t\t\t\t\t\t\\\n\t\t#f \" called with too many arguments (\" #p \">\" #n \")\");\t\\\n})\n\nstatic inline void efi_fpu_begin(void)\n{\n\t \n\tkernel_fpu_begin_mask(KFPU_387 | KFPU_MXCSR);\n}\n\nstatic inline void efi_fpu_end(void)\n{\n\tkernel_fpu_end();\n}\n\n#ifdef CONFIG_X86_32\n#define EFI_X86_KERNEL_ALLOC_LIMIT\t\t(SZ_512M - 1)\n#else  \n#define EFI_X86_KERNEL_ALLOC_LIMIT\t\tEFI_ALLOC_LIMIT\n\nextern asmlinkage u64 __efi_call(void *fp, ...);\n\nextern bool efi_disable_ibt_for_runtime;\n\n#define efi_call(...) ({\t\t\t\t\t\t\\\n\t__efi_nargs_check(efi_call, 7, __VA_ARGS__);\t\t\t\\\n\t__efi_call(__VA_ARGS__);\t\t\t\t\t\\\n})\n\n#undef arch_efi_call_virt\n#define arch_efi_call_virt(p, f, args...) ({\t\t\t\t\\\n\tu64 ret, ibt = ibt_save(efi_disable_ibt_for_runtime);\t\t\\\n\tret = efi_call((void *)p->f, args);\t\t\t\t\\\n\tibt_restore(ibt);\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_KASAN\n \n#undef memcpy\n#undef memset\n#undef memmove\n#endif\n\n#endif  \n\nextern int __init efi_memblock_x86_reserve_range(void);\nextern void __init efi_print_memmap(void);\nextern void __init efi_map_region(efi_memory_desc_t *md);\nextern void __init efi_map_region_fixed(efi_memory_desc_t *md);\nextern void efi_sync_low_kernel_mappings(void);\nextern int __init efi_alloc_page_tables(void);\nextern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);\nextern void __init efi_runtime_update_mappings(void);\nextern void __init efi_dump_pagetable(void);\nextern void __init efi_apply_memmap_quirks(void);\nextern int __init efi_reuse_config(u64 tables, int nr_tables);\nextern void efi_delete_dummy_variable(void);\nextern void efi_crash_gracefully_on_page_fault(unsigned long phys_addr);\nextern void efi_free_boot_services(void);\n\nvoid arch_efi_call_virt_setup(void);\nvoid arch_efi_call_virt_teardown(void);\n\n \nstruct efi_setup_data {\n\tu64 fw_vendor;\n\tu64 __unused;\n\tu64 tables;\n\tu64 smbios;\n\tu64 reserved[8];\n};\n\nextern u64 efi_setup;\n\n#ifdef CONFIG_EFI\nextern u64 __efi64_thunk(u32, ...);\n\n#define efi64_thunk(...) ({\t\t\t\t\t\t\\\n\tu64 __pad[3];  \t\\\n\t__efi_nargs_check(efi64_thunk, 9, __VA_ARGS__);\t\t\t\\\n\t__efi64_thunk(__VA_ARGS__, __pad);\t\t\t\t\\\n})\n\nstatic inline bool efi_is_mixed(void)\n{\n\tif (!IS_ENABLED(CONFIG_EFI_MIXED))\n\t\treturn false;\n\treturn IS_ENABLED(CONFIG_X86_64) && !efi_enabled(EFI_64BIT);\n}\n\nstatic inline bool efi_runtime_supported(void)\n{\n\tif (IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT))\n\t\treturn true;\n\n\treturn IS_ENABLED(CONFIG_EFI_MIXED);\n}\n\nextern void parse_efi_setup(u64 phys_addr, u32 data_len);\n\nextern void efi_thunk_runtime_setup(void);\nefi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,\n\t\t\t\t\t unsigned long descriptor_size,\n\t\t\t\t\t u32 descriptor_version,\n\t\t\t\t\t efi_memory_desc_t *virtual_map,\n\t\t\t\t\t unsigned long systab_phys);\n\n \n\n#ifdef CONFIG_EFI_MIXED\n\n#define EFI_ALLOC_LIMIT\t\t(efi_is_64bit() ? ULONG_MAX : U32_MAX)\n\n#define ARCH_HAS_EFISTUB_WRAPPERS\n\nstatic inline bool efi_is_64bit(void)\n{\n\textern const bool efi_is64;\n\n\treturn efi_is64;\n}\n\nstatic inline bool efi_is_native(void)\n{\n\treturn efi_is_64bit();\n}\n\n#define efi_table_attr(inst, attr)\t\t\t\t\t\\\n\t(efi_is_native() ? (inst)->attr\t\t\t\t\t\\\n\t\t\t : efi_mixed_table_attr((inst), attr))\n\n#define efi_mixed_table_attr(inst, attr)\t\t\t\t\\\n\t(__typeof__(inst->attr))\t\t\t\t\t\\\n\t\t_Generic(inst->mixed_mode.attr,\t\t\t\t\\\n\t\tu32:\t\t(unsigned long)(inst->mixed_mode.attr),\t\\\n\t\tdefault:\t(inst->mixed_mode.attr))\n\n \n\nstatic inline void *efi64_zero_upper(void *p)\n{\n\t((u32 *)p)[1] = 0;\n\treturn p;\n}\n\nstatic inline u32 efi64_convert_status(efi_status_t status)\n{\n\treturn (u32)(status | (u64)status >> 32);\n}\n\n#define __efi64_split(val)\t\t(val) & U32_MAX, (u64)(val) >> 32\n\n#define __efi64_argmap_free_pages(addr, size)\t\t\t\t\\\n\t((addr), 0, (size))\n\n#define __efi64_argmap_get_memory_map(mm_size, mm, key, size, ver)\t\\\n\t((mm_size), (mm), efi64_zero_upper(key), efi64_zero_upper(size), (ver))\n\n#define __efi64_argmap_allocate_pool(type, size, buffer)\t\t\\\n\t((type), (size), efi64_zero_upper(buffer))\n\n#define __efi64_argmap_create_event(type, tpl, f, c, event)\t\t\\\n\t((type), (tpl), (f), (c), efi64_zero_upper(event))\n\n#define __efi64_argmap_set_timer(event, type, time)\t\t\t\\\n\t((event), (type), lower_32_bits(time), upper_32_bits(time))\n\n#define __efi64_argmap_wait_for_event(num, event, index)\t\t\\\n\t((num), (event), efi64_zero_upper(index))\n\n#define __efi64_argmap_handle_protocol(handle, protocol, interface)\t\\\n\t((handle), (protocol), efi64_zero_upper(interface))\n\n#define __efi64_argmap_locate_protocol(protocol, reg, interface)\t\\\n\t((protocol), (reg), efi64_zero_upper(interface))\n\n#define __efi64_argmap_locate_device_path(protocol, path, handle)\t\\\n\t((protocol), (path), efi64_zero_upper(handle))\n\n#define __efi64_argmap_exit(handle, status, size, data)\t\t\t\\\n\t((handle), efi64_convert_status(status), (size), (data))\n\n \n#define __efi64_argmap_get_location(protocol, seg, bus, dev, func)\t\\\n\t((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),\t\\\n\t efi64_zero_upper(dev), efi64_zero_upper(func))\n\n \n#define __efi64_argmap_load_file(protocol, path, policy, bufsize, buf)\t\\\n\t((protocol), (path), (policy), efi64_zero_upper(bufsize), (buf))\n\n \n#define __efi64_argmap_query_mode(gop, mode, size, info)\t\t\\\n\t((gop), (mode), efi64_zero_upper(size), efi64_zero_upper(info))\n\n \n#define __efi64_argmap_hash_log_extend_event(prot, fl, addr, size, ev)\t\\\n\t((prot), (fl), 0ULL, (u64)(addr), 0ULL, (u64)(size), 0ULL, ev)\n\n \n#define __efi64_argmap_get_memory_space_descriptor(phys, desc) \\\n\t(__efi64_split(phys), (desc))\n\n#define __efi64_argmap_set_memory_space_attributes(phys, size, flags) \\\n\t(__efi64_split(phys), __efi64_split(size), __efi64_split(flags))\n\n \n#define __efi64_argmap_open(prot, newh, fname, mode, attr) \\\n\t((prot), efi64_zero_upper(newh), (fname), __efi64_split(mode), \\\n\t __efi64_split(attr))\n\n#define __efi64_argmap_set_position(pos) (__efi64_split(pos))\n\n \n#define __efi64_argmap_open_volume(prot, file) \\\n\t((prot), efi64_zero_upper(file))\n\n \n#define __efi64_argmap_get_memory_attributes(protocol, phys, size, flags) \\\n\t((protocol), __efi64_split(phys), __efi64_split(size), (flags))\n\n#define __efi64_argmap_set_memory_attributes(protocol, phys, size, flags) \\\n\t((protocol), __efi64_split(phys), __efi64_split(size), __efi64_split(flags))\n\n#define __efi64_argmap_clear_memory_attributes(protocol, phys, size, flags) \\\n\t((protocol), __efi64_split(phys), __efi64_split(size), __efi64_split(flags))\n\n \n\n#define __efi64_thunk_map(inst, func, ...)\t\t\t\t\\\n\tefi64_thunk(inst->mixed_mode.func,\t\t\t\t\\\n\t\t__efi64_argmap(__efi64_argmap_ ## func(__VA_ARGS__),\t\\\n\t\t\t       (__VA_ARGS__)))\n\n#define __efi64_argmap(mapped, args)\t\t\t\t\t\\\n\t__PASTE(__efi64_argmap__, __efi_nargs(__efi_eat mapped))(mapped, args)\n#define __efi64_argmap__0(mapped, args) __efi_eval mapped\n#define __efi64_argmap__1(mapped, args) __efi_eval args\n\n#define __efi_eat(...)\n#define __efi_eval(...) __VA_ARGS__\n\nstatic inline efi_status_t __efi64_widen_efi_status(u64 status)\n{\n\t \n\treturn ror64(rol32(status, 1), 1);\n}\n\n \n\n#define efi_fn_call(inst, func, ...)\t\t\t\t\t\\\n\t(efi_is_native() ? (inst)->func(__VA_ARGS__)\t\t\t\\\n\t\t\t : efi_mixed_call((inst), func, ##__VA_ARGS__))\n\n#define efi_mixed_call(inst, func, ...)\t\t\t\t\t\\\n\t_Generic(inst->func(__VA_ARGS__),\t\t\t\t\\\n\tefi_status_t:\t\t\t\t\t\t\t\\\n\t\t__efi64_widen_efi_status(\t\t\t\t\\\n\t\t\t__efi64_thunk_map(inst, func, ##__VA_ARGS__)),\t\\\n\tu64: ({ BUILD_BUG(); ULONG_MAX; }),\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t(__typeof__(inst->func(__VA_ARGS__)))\t\t\t\\\n\t\t\t__efi64_thunk_map(inst, func, ##__VA_ARGS__))\n\n#else  \n\nstatic inline bool efi_is_64bit(void)\n{\n\treturn IS_ENABLED(CONFIG_X86_64);\n}\n\n#endif  \n\nextern bool efi_reboot_required(void);\nextern bool efi_is_table_address(unsigned long phys_addr);\n\nextern void efi_reserve_boot_services(void);\n#else\nstatic inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}\nstatic inline bool efi_reboot_required(void)\n{\n\treturn false;\n}\nstatic inline  bool efi_is_table_address(unsigned long phys_addr)\n{\n\treturn false;\n}\nstatic inline void efi_reserve_boot_services(void)\n{\n}\n#endif  \n\n#ifdef CONFIG_EFI_FAKE_MEMMAP\nextern void __init efi_fake_memmap_early(void);\nextern void __init efi_fake_memmap(void);\n#else\nstatic inline void efi_fake_memmap_early(void)\n{\n}\n\nstatic inline void efi_fake_memmap(void)\n{\n}\n#endif\n\nextern int __init efi_memmap_alloc(unsigned int num_entries,\n\t\t\t\t   struct efi_memory_map_data *data);\nextern void __efi_memmap_free(u64 phys, unsigned long size,\n\t\t\t      unsigned long flags);\n#define __efi_memmap_free __efi_memmap_free\n\nextern int __init efi_memmap_install(struct efi_memory_map_data *data);\nextern int __init efi_memmap_split_count(efi_memory_desc_t *md,\n\t\t\t\t\t struct range *range);\nextern void __init efi_memmap_insert(struct efi_memory_map *old_memmap,\n\t\t\t\t     void *buf, struct efi_mem_range *mem);\n\n#define arch_ima_efi_boot_mode\t\\\n\t({ extern struct boot_params boot_params; boot_params.secure_boot; })\n\n#ifdef CONFIG_EFI_RUNTIME_MAP\nint efi_get_runtime_map_size(void);\nint efi_get_runtime_map_desc_size(void);\nint efi_runtime_map_copy(void *buf, size_t bufsz);\n#else\nstatic inline int efi_get_runtime_map_size(void)\n{\n\treturn 0;\n}\n\nstatic inline int efi_get_runtime_map_desc_size(void)\n{\n\treturn 0;\n}\n\nstatic inline int efi_runtime_map_copy(void *buf, size_t bufsz)\n{\n\treturn 0;\n}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}