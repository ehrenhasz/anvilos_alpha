{
  "module_name": "string_32.h",
  "hash_id": "73e7daf7e326f1a984fac6ff7879218f1e442a938377f84ae4c171feab5227b7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/string_32.h",
  "human_readable_source": " \n#ifndef _ASM_X86_STRING_32_H\n#define _ASM_X86_STRING_32_H\n\n#ifdef __KERNEL__\n\n \n\n#define __HAVE_ARCH_STRCPY\nextern char *strcpy(char *dest, const char *src);\n\n#define __HAVE_ARCH_STRNCPY\nextern char *strncpy(char *dest, const char *src, size_t count);\n\n#define __HAVE_ARCH_STRCAT\nextern char *strcat(char *dest, const char *src);\n\n#define __HAVE_ARCH_STRNCAT\nextern char *strncat(char *dest, const char *src, size_t count);\n\n#define __HAVE_ARCH_STRCMP\nextern int strcmp(const char *cs, const char *ct);\n\n#define __HAVE_ARCH_STRNCMP\nextern int strncmp(const char *cs, const char *ct, size_t count);\n\n#define __HAVE_ARCH_STRCHR\nextern char *strchr(const char *s, int c);\n\n#define __HAVE_ARCH_STRLEN\nextern size_t strlen(const char *s);\n\nstatic __always_inline void *__memcpy(void *to, const void *from, size_t n)\n{\n\tint d0, d1, d2;\n\tasm volatile(\"rep ; movsl\\n\\t\"\n\t\t     \"movl %4,%%ecx\\n\\t\"\n\t\t     \"andl $3,%%ecx\\n\\t\"\n\t\t     \"jz 1f\\n\\t\"\n\t\t     \"rep ; movsb\\n\\t\"\n\t\t     \"1:\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t     : \"0\" (n / 4), \"g\" (n), \"1\" ((long)to), \"2\" ((long)from)\n\t\t     : \"memory\");\n\treturn to;\n}\n\n \nstatic __always_inline void *__constant_memcpy(void *to, const void *from,\n\t\t\t\t\t       size_t n)\n{\n\tlong esi, edi;\n\tif (!n)\n\t\treturn to;\n\n\tswitch (n) {\n\tcase 1:\n\t\t*(char *)to = *(char *)from;\n\t\treturn to;\n\tcase 2:\n\t\t*(short *)to = *(short *)from;\n\t\treturn to;\n\tcase 4:\n\t\t*(int *)to = *(int *)from;\n\t\treturn to;\n\tcase 3:\n\t\t*(short *)to = *(short *)from;\n\t\t*((char *)to + 2) = *((char *)from + 2);\n\t\treturn to;\n\tcase 5:\n\t\t*(int *)to = *(int *)from;\n\t\t*((char *)to + 4) = *((char *)from + 4);\n\t\treturn to;\n\tcase 6:\n\t\t*(int *)to = *(int *)from;\n\t\t*((short *)to + 2) = *((short *)from + 2);\n\t\treturn to;\n\tcase 8:\n\t\t*(int *)to = *(int *)from;\n\t\t*((int *)to + 1) = *((int *)from + 1);\n\t\treturn to;\n\t}\n\n\tesi = (long)from;\n\tedi = (long)to;\n\tif (n >= 5 * 4) {\n\t\t \n\t\tint ecx;\n\t\tasm volatile(\"rep ; movsl\"\n\t\t\t     : \"=&c\" (ecx), \"=&D\" (edi), \"=&S\" (esi)\n\t\t\t     : \"0\" (n / 4), \"1\" (edi), \"2\" (esi)\n\t\t\t     : \"memory\"\n\t\t);\n\t} else {\n\t\t \n\t\tif (n >= 4 * 4)\n\t\t\tasm volatile(\"movsl\"\n\t\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t\t     : \"memory\");\n\t\tif (n >= 3 * 4)\n\t\t\tasm volatile(\"movsl\"\n\t\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t\t     : \"memory\");\n\t\tif (n >= 2 * 4)\n\t\t\tasm volatile(\"movsl\"\n\t\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t\t     : \"memory\");\n\t\tif (n >= 1 * 4)\n\t\t\tasm volatile(\"movsl\"\n\t\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t\t     : \"memory\");\n\t}\n\tswitch (n % 4) {\n\t\t \n\tcase 0:\n\t\treturn to;\n\tcase 1:\n\t\tasm volatile(\"movsb\"\n\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t     : \"memory\");\n\t\treturn to;\n\tcase 2:\n\t\tasm volatile(\"movsw\"\n\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t     : \"memory\");\n\t\treturn to;\n\tdefault:\n\t\tasm volatile(\"movsw\\n\\tmovsb\"\n\t\t\t     : \"=&D\"(edi), \"=&S\"(esi)\n\t\t\t     : \"0\"(edi), \"1\"(esi)\n\t\t\t     : \"memory\");\n\t\treturn to;\n\t}\n}\n\n#define __HAVE_ARCH_MEMCPY\nextern void *memcpy(void *, const void *, size_t);\n\n#ifndef CONFIG_FORTIFY_SOURCE\n\n#define memcpy(t, f, n) __builtin_memcpy(t, f, n)\n\n#endif  \n\n#define __HAVE_ARCH_MEMMOVE\nvoid *memmove(void *dest, const void *src, size_t n);\n\nextern int memcmp(const void *, const void *, size_t);\n#ifndef CONFIG_FORTIFY_SOURCE\n#define memcmp __builtin_memcmp\n#endif\n\n#define __HAVE_ARCH_MEMCHR\nextern void *memchr(const void *cs, int c, size_t count);\n\nstatic inline void *__memset_generic(void *s, char c, size_t count)\n{\n\tint d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosb\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (c), \"1\" (s), \"0\" (count)\n\t\t     : \"memory\");\n\treturn s;\n}\n\n \n#define __constant_count_memset(s, c, count) __memset_generic((s), (c), (count))\n\n \n#define __HAVE_ARCH_STRNLEN\nextern size_t strnlen(const char *s, size_t count);\n \n\n#define __HAVE_ARCH_STRSTR\nextern char *strstr(const char *cs, const char *ct);\n\n#define __memset(s, c, count)\t\t\t\t\\\n\t(__builtin_constant_p(count)\t\t\t\\\n\t ? __constant_count_memset((s), (c), (count))\t\\\n\t : __memset_generic((s), (c), (count)))\n\n#define __HAVE_ARCH_MEMSET\nextern void *memset(void *, int, size_t);\n#ifndef CONFIG_FORTIFY_SOURCE\n#define memset(s, c, count) __builtin_memset(s, c, count)\n#endif  \n\n#define __HAVE_ARCH_MEMSET16\nstatic inline void *memset16(uint16_t *s, uint16_t v, size_t n)\n{\n\tint d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosw\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (v), \"1\" (s), \"0\" (n)\n\t\t     : \"memory\");\n\treturn s;\n}\n\n#define __HAVE_ARCH_MEMSET32\nstatic inline void *memset32(uint32_t *s, uint32_t v, size_t n)\n{\n\tint d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosl\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (v), \"1\" (s), \"0\" (n)\n\t\t     : \"memory\");\n\treturn s;\n}\n\n \n#define __HAVE_ARCH_MEMSCAN\nextern void *memscan(void *addr, int c, size_t size);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}