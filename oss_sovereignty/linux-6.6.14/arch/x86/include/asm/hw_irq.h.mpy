{
  "module_name": "hw_irq.h",
  "hash_id": "a9eda34c45f46214c6432818c24563a97953d75a339e762fc374584790a36976",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/hw_irq.h",
  "human_readable_source": " \n#ifndef _ASM_X86_HW_IRQ_H\n#define _ASM_X86_HW_IRQ_H\n\n \n\n#include <asm/irq_vectors.h>\n\n#define IRQ_MATRIX_BITS\t\tNR_VECTORS\n\n#ifndef __ASSEMBLY__\n\n#include <linux/percpu.h>\n#include <linux/profile.h>\n#include <linux/smp.h>\n\n#include <linux/atomic.h>\n#include <asm/irq.h>\n#include <asm/sections.h>\n\n#ifdef\tCONFIG_X86_LOCAL_APIC\nstruct irq_data;\nstruct pci_dev;\nstruct msi_desc;\n\nenum irq_alloc_type {\n\tX86_IRQ_ALLOC_TYPE_IOAPIC = 1,\n\tX86_IRQ_ALLOC_TYPE_HPET,\n\tX86_IRQ_ALLOC_TYPE_PCI_MSI,\n\tX86_IRQ_ALLOC_TYPE_PCI_MSIX,\n\tX86_IRQ_ALLOC_TYPE_DMAR,\n\tX86_IRQ_ALLOC_TYPE_AMDVI,\n\tX86_IRQ_ALLOC_TYPE_UV,\n};\n\nstruct ioapic_alloc_info {\n\tint\t\tpin;\n\tint\t\tnode;\n\tu32\t\tis_level\t: 1;\n\tu32\t\tactive_low\t: 1;\n\tu32\t\tvalid\t\t: 1;\n};\n\nstruct uv_alloc_info {\n\tint\t\tlimit;\n\tint\t\tblade;\n\tunsigned long\toffset;\n\tchar\t\t*name;\n\n};\n\n \nstruct irq_alloc_info {\n\tenum irq_alloc_type\ttype;\n\tu32\t\t\tflags;\n\tu32\t\t\tdevid;\n\tirq_hw_number_t\t\thwirq;\n\tconst struct cpumask\t*mask;\n\tstruct msi_desc\t\t*desc;\n\tvoid\t\t\t*data;\n\n\tunion {\n\t\tstruct ioapic_alloc_info\tioapic;\n\t\tstruct uv_alloc_info\t\tuv;\n\t};\n};\n\nstruct irq_cfg {\n\tunsigned int\t\tdest_apicid;\n\tunsigned int\t\tvector;\n};\n\nextern struct irq_cfg *irq_cfg(unsigned int irq);\nextern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);\nextern void lock_vector_lock(void);\nextern void unlock_vector_lock(void);\n#ifdef CONFIG_SMP\nextern void vector_schedule_cleanup(struct irq_cfg *);\nextern void irq_complete_move(struct irq_cfg *cfg);\n#else\nstatic inline void vector_schedule_cleanup(struct irq_cfg *c) { }\nstatic inline void irq_complete_move(struct irq_cfg *c) { }\n#endif\n\nextern void apic_ack_edge(struct irq_data *data);\n#else\t \nstatic inline void lock_vector_lock(void) {}\nstatic inline void unlock_vector_lock(void) {}\n#endif\t \n\n \nextern atomic_t irq_err_count;\nextern atomic_t irq_mis_count;\n\nextern void elcr_set_level_irq(unsigned int irq);\n\nextern char irq_entries_start[];\n#ifdef CONFIG_TRACING\n#define trace_irq_entries_start irq_entries_start\n#endif\n\nextern char spurious_entries_start[];\n\n#define VECTOR_UNUSED\t\tNULL\n#define VECTOR_SHUTDOWN\t\t((void *)-1L)\n#define VECTOR_RETRIGGERED\t((void *)-2L)\n\ntypedef struct irq_desc* vector_irq_t[NR_VECTORS];\nDECLARE_PER_CPU(vector_irq_t, vector_irq);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}