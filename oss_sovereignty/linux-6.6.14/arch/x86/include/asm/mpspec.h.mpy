{
  "module_name": "mpspec.h",
  "hash_id": "e33c8b880f67e5552e13dfb39d5175b0257326335c1af9e6f4a29588dd502397",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/mpspec.h",
  "human_readable_source": " \n#ifndef _ASM_X86_MPSPEC_H\n#define _ASM_X86_MPSPEC_H\n\n\n#include <asm/mpspec_def.h>\n#include <asm/x86_init.h>\n#include <asm/apicdef.h>\n\nextern int pic_mode;\n\n#ifdef CONFIG_X86_32\n\n \n#if CONFIG_BASE_SMALL == 0\n# define MAX_MP_BUSSES\t\t260\n#else\n# define MAX_MP_BUSSES\t\t32\n#endif\n\n#define MAX_IRQ_SOURCES\t\t256\n\n#else  \n\n#define MAX_MP_BUSSES\t\t256\n \n#define MAX_IRQ_SOURCES\t\t(MAX_MP_BUSSES * 4)\n\n#endif  \n\n#ifdef CONFIG_EISA\nextern int mp_bus_id_to_type[MAX_MP_BUSSES];\n#endif\n\nextern DECLARE_BITMAP(mp_bus_not_pci, MAX_MP_BUSSES);\n\nextern unsigned int boot_cpu_physical_apicid;\nextern u8 boot_cpu_apic_version;\n\n#ifdef CONFIG_X86_LOCAL_APIC\nextern int smp_found_config;\n#else\n# define smp_found_config 0\n#endif\n\nstatic inline void get_smp_config(void)\n{\n\tx86_init.mpparse.get_smp_config(0);\n}\n\nstatic inline void early_get_smp_config(void)\n{\n\tx86_init.mpparse.get_smp_config(1);\n}\n\nstatic inline void find_smp_config(void)\n{\n\tx86_init.mpparse.find_smp_config();\n}\n\n#ifdef CONFIG_X86_MPPARSE\nextern void e820__memblock_alloc_reserved_mpc_new(void);\nextern int enable_update_mptable;\nextern void default_find_smp_config(void);\nextern void default_get_smp_config(unsigned int early);\n#else\nstatic inline void e820__memblock_alloc_reserved_mpc_new(void) { }\n#define enable_update_mptable 0\n#define default_find_smp_config x86_init_noop\n#define default_get_smp_config x86_init_uint_noop\n#endif\n\nint generic_processor_info(int apicid);\n\n#define PHYSID_ARRAY_SIZE\tBITS_TO_LONGS(MAX_LOCAL_APIC)\n\nstruct physid_mask {\n\tunsigned long mask[PHYSID_ARRAY_SIZE];\n};\n\ntypedef struct physid_mask physid_mask_t;\n\n#define physid_set(physid, map)\t\t\tset_bit(physid, (map).mask)\n#define physid_isset(physid, map)\t\ttest_bit(physid, (map).mask)\n\n#define physids_or(dst, src1, src2)\t\t\t\t\t\\\n\tbitmap_or((dst).mask, (src1).mask, (src2).mask, MAX_LOCAL_APIC)\n\n#define physids_clear(map)\t\t\t\t\t\\\n\tbitmap_zero((map).mask, MAX_LOCAL_APIC)\n\n#define physids_empty(map)\t\t\t\t\t\\\n\tbitmap_empty((map).mask, MAX_LOCAL_APIC)\n\nstatic inline void physids_promote(unsigned long physids, physid_mask_t *map)\n{\n\tphysids_clear(*map);\n\tmap->mask[0] = physids;\n}\n\nstatic inline void physid_set_mask_of_physid(int physid, physid_mask_t *map)\n{\n\tphysids_clear(*map);\n\tphysid_set(physid, *map);\n}\n\n#define PHYSID_MASK_ALL\t\t{ {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }\n#define PHYSID_MASK_NONE\t{ {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }\n\nextern physid_mask_t phys_cpu_present_map;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}