{
  "module_name": "sev.h",
  "hash_id": "3a622900034ac722d630b9e09fc9c7874fdbf2e887b32a709c3bcd88b40d0ec1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/sev.h",
  "human_readable_source": " \n \n\n#ifndef __ASM_ENCRYPTED_STATE_H\n#define __ASM_ENCRYPTED_STATE_H\n\n#include <linux/types.h>\n#include <linux/sev-guest.h>\n\n#include <asm/insn.h>\n#include <asm/sev-common.h>\n#include <asm/bootparam.h>\n#include <asm/coco.h>\n\n#define GHCB_PROTOCOL_MIN\t1ULL\n#define GHCB_PROTOCOL_MAX\t2ULL\n#define GHCB_DEFAULT_USAGE\t0ULL\n\n#define\tVMGEXIT()\t\t\t{ asm volatile(\"rep; vmmcall\\n\\r\"); }\n\nenum es_result {\n\tES_OK,\t\t\t \n\tES_UNSUPPORTED,\t\t \n\tES_VMM_ERROR,\t\t \n\tES_DECODE_FAILED,\t \n\tES_EXCEPTION,\t\t \n\tES_RETRY,\t\t \n};\n\nstruct es_fault_info {\n\tunsigned long vector;\n\tunsigned long error_code;\n\tunsigned long cr2;\n};\n\nstruct pt_regs;\n\n \nstruct es_em_ctxt {\n\tstruct pt_regs *regs;\n\tstruct insn insn;\n\tstruct es_fault_info fi;\n};\n\n \n#define CC_BLOB_SEV_HDR_MAGIC\t0x45444d41\nstruct cc_blob_sev_info {\n\tu32 magic;\n\tu16 version;\n\tu16 reserved;\n\tu64 secrets_phys;\n\tu32 secrets_len;\n\tu32 rsvd1;\n\tu64 cpuid_phys;\n\tu32 cpuid_len;\n\tu32 rsvd2;\n} __packed;\n\nvoid do_vc_no_ghcb(struct pt_regs *regs, unsigned long exit_code);\n\nstatic inline u64 lower_bits(u64 val, unsigned int bits)\n{\n\tu64 mask = (1ULL << bits) - 1;\n\n\treturn (val & mask);\n}\n\nstruct real_mode_header;\nenum stack_type;\n\n \nextern void vc_no_ghcb(void);\nextern void vc_boot_ghcb(void);\nextern bool handle_vc_boot_ghcb(struct pt_regs *regs);\n\n \n#define PVALIDATE_FAIL_SIZEMISMATCH\t6\n\n \n#define PVALIDATE_FAIL_NOUPDATE\t\t255\n\n \n#define RMP_PG_SIZE_4K\t\t\t0\n#define RMP_PG_SIZE_2M\t\t\t1\n\n#define RMPADJUST_VMSA_PAGE_BIT\t\tBIT(16)\n\n \nstruct snp_req_data {\n\tunsigned long req_gpa;\n\tunsigned long resp_gpa;\n\tunsigned long data_gpa;\n\tunsigned int data_npages;\n};\n\nstruct sev_guest_platform_data {\n\tu64 secrets_gpa;\n};\n\n \nstruct secrets_os_area {\n\tu32 msg_seqno_0;\n\tu32 msg_seqno_1;\n\tu32 msg_seqno_2;\n\tu32 msg_seqno_3;\n\tu64 ap_jump_table_pa;\n\tu8 rsvd[40];\n\tu8 guest_usage[32];\n} __packed;\n\n#define VMPCK_KEY_LEN\t\t32\n\n \nstruct snp_secrets_page_layout {\n\tu32 version;\n\tu32 imien\t: 1,\n\t    rsvd1\t: 31;\n\tu32 fms;\n\tu32 rsvd2;\n\tu8 gosvw[16];\n\tu8 vmpck0[VMPCK_KEY_LEN];\n\tu8 vmpck1[VMPCK_KEY_LEN];\n\tu8 vmpck2[VMPCK_KEY_LEN];\n\tu8 vmpck3[VMPCK_KEY_LEN];\n\tstruct secrets_os_area os_area;\n\tu8 rsvd3[3840];\n} __packed;\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nextern void __sev_es_ist_enter(struct pt_regs *regs);\nextern void __sev_es_ist_exit(void);\nstatic __always_inline void sev_es_ist_enter(struct pt_regs *regs)\n{\n\tif (cc_vendor == CC_VENDOR_AMD &&\n\t    cc_platform_has(CC_ATTR_GUEST_STATE_ENCRYPT))\n\t\t__sev_es_ist_enter(regs);\n}\nstatic __always_inline void sev_es_ist_exit(void)\n{\n\tif (cc_vendor == CC_VENDOR_AMD &&\n\t    cc_platform_has(CC_ATTR_GUEST_STATE_ENCRYPT))\n\t\t__sev_es_ist_exit();\n}\nextern int sev_es_setup_ap_jump_table(struct real_mode_header *rmh);\nextern void __sev_es_nmi_complete(void);\nstatic __always_inline void sev_es_nmi_complete(void)\n{\n\tif (cc_vendor == CC_VENDOR_AMD &&\n\t    cc_platform_has(CC_ATTR_GUEST_STATE_ENCRYPT))\n\t\t__sev_es_nmi_complete();\n}\nextern int __init sev_es_efi_map_ghcbs(pgd_t *pgd);\nextern void sev_enable(struct boot_params *bp);\n\nstatic inline int rmpadjust(unsigned long vaddr, bool rmp_psize, unsigned long attrs)\n{\n\tint rc;\n\n\t \n\tasm volatile(\".byte 0xF3,0x0F,0x01,0xFE\\n\\t\"\n\t\t     : \"=a\"(rc)\n\t\t     : \"a\"(vaddr), \"c\"(rmp_psize), \"d\"(attrs)\n\t\t     : \"memory\", \"cc\");\n\n\treturn rc;\n}\nstatic inline int pvalidate(unsigned long vaddr, bool rmp_psize, bool validate)\n{\n\tbool no_rmpupdate;\n\tint rc;\n\n\t \n\tasm volatile(\".byte 0xF2, 0x0F, 0x01, 0xFF\\n\\t\"\n\t\t     CC_SET(c)\n\t\t     : CC_OUT(c) (no_rmpupdate), \"=a\"(rc)\n\t\t     : \"a\"(vaddr), \"c\"(rmp_psize), \"d\"(validate)\n\t\t     : \"memory\", \"cc\");\n\n\tif (no_rmpupdate)\n\t\treturn PVALIDATE_FAIL_NOUPDATE;\n\n\treturn rc;\n}\n\nstruct snp_guest_request_ioctl;\n\nvoid setup_ghcb(void);\nvoid __init early_snp_set_memory_private(unsigned long vaddr, unsigned long paddr,\n\t\t\t\t\t unsigned long npages);\nvoid __init early_snp_set_memory_shared(unsigned long vaddr, unsigned long paddr,\n\t\t\t\t\tunsigned long npages);\nvoid __init snp_prep_memory(unsigned long paddr, unsigned int sz, enum psc_op op);\nvoid snp_set_memory_shared(unsigned long vaddr, unsigned long npages);\nvoid snp_set_memory_private(unsigned long vaddr, unsigned long npages);\nvoid snp_set_wakeup_secondary_cpu(void);\nbool snp_init(struct boot_params *bp);\nvoid __init __noreturn snp_abort(void);\nint snp_issue_guest_request(u64 exit_code, struct snp_req_data *input, struct snp_guest_request_ioctl *rio);\nvoid snp_accept_memory(phys_addr_t start, phys_addr_t end);\nu64 snp_get_unsupported_features(u64 status);\nu64 sev_get_status(void);\n#else\nstatic inline void sev_es_ist_enter(struct pt_regs *regs) { }\nstatic inline void sev_es_ist_exit(void) { }\nstatic inline int sev_es_setup_ap_jump_table(struct real_mode_header *rmh) { return 0; }\nstatic inline void sev_es_nmi_complete(void) { }\nstatic inline int sev_es_efi_map_ghcbs(pgd_t *pgd) { return 0; }\nstatic inline void sev_enable(struct boot_params *bp) { }\nstatic inline int pvalidate(unsigned long vaddr, bool rmp_psize, bool validate) { return 0; }\nstatic inline int rmpadjust(unsigned long vaddr, bool rmp_psize, unsigned long attrs) { return 0; }\nstatic inline void setup_ghcb(void) { }\nstatic inline void __init\nearly_snp_set_memory_private(unsigned long vaddr, unsigned long paddr, unsigned long npages) { }\nstatic inline void __init\nearly_snp_set_memory_shared(unsigned long vaddr, unsigned long paddr, unsigned long npages) { }\nstatic inline void __init snp_prep_memory(unsigned long paddr, unsigned int sz, enum psc_op op) { }\nstatic inline void snp_set_memory_shared(unsigned long vaddr, unsigned long npages) { }\nstatic inline void snp_set_memory_private(unsigned long vaddr, unsigned long npages) { }\nstatic inline void snp_set_wakeup_secondary_cpu(void) { }\nstatic inline bool snp_init(struct boot_params *bp) { return false; }\nstatic inline void snp_abort(void) { }\nstatic inline int snp_issue_guest_request(u64 exit_code, struct snp_req_data *input, struct snp_guest_request_ioctl *rio)\n{\n\treturn -ENOTTY;\n}\n\nstatic inline void snp_accept_memory(phys_addr_t start, phys_addr_t end) { }\nstatic inline u64 snp_get_unsupported_features(u64 status) { return 0; }\nstatic inline u64 sev_get_status(void) { return 0; }\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}