{
  "module_name": "floppy.h",
  "hash_id": "fffd089fd2f7805bce05d47901211d638a927ab4f74b22bffae399132316888e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/floppy.h",
  "human_readable_source": " \n#ifndef _ASM_X86_FLOPPY_H\n#define _ASM_X86_FLOPPY_H\n\n#include <linux/vmalloc.h>\n\n \n#define _CROSS_64KB(a, s, vdma)\t\t\t\t\t\t\\\n\t(!(vdma) &&\t\t\t\t\t\t\t\\\n\t ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))\n\n#define CROSS_64KB(a, s) _CROSS_64KB(a, s, use_virtual_dma & 1)\n\n\n#define SW fd_routine[use_virtual_dma & 1]\n#define CSW fd_routine[can_use_virtual_dma & 1]\n\n\n#define fd_inb(base, reg)\t\tinb_p((base) + (reg))\n#define fd_outb(value, base, reg)\toutb_p(value, (base) + (reg))\n\n#define fd_request_dma()\tCSW._request_dma(FLOPPY_DMA, \"floppy\")\n#define fd_free_dma()\t\tCSW._free_dma(FLOPPY_DMA)\n#define fd_enable_irq()\t\tenable_irq(FLOPPY_IRQ)\n#define fd_disable_irq()\tdisable_irq(FLOPPY_IRQ)\n#define fd_free_irq()\t\tfree_irq(FLOPPY_IRQ, NULL)\n#define fd_get_dma_residue()\tSW._get_dma_residue(FLOPPY_DMA)\n#define fd_dma_mem_alloc(size)\tSW._dma_mem_alloc(size)\n#define fd_dma_setup(addr, size, mode, io) SW._dma_setup(addr, size, mode, io)\n\n#define FLOPPY_CAN_FALLBACK_ON_NODMA\n\nstatic int virtual_dma_count;\nstatic int virtual_dma_residue;\nstatic char *virtual_dma_addr;\nstatic int virtual_dma_mode;\nstatic int doing_pdma;\n\nstatic irqreturn_t floppy_hardint(int irq, void *dev_id)\n{\n\tunsigned char st;\n\n#undef TRACE_FLPY_INT\n\n#ifdef TRACE_FLPY_INT\n\tstatic int calls;\n\tstatic int bytes;\n\tstatic int dma_wait;\n#endif\n\tif (!doing_pdma)\n\t\treturn floppy_interrupt(irq, dev_id);\n\n#ifdef TRACE_FLPY_INT\n\tif (!calls)\n\t\tbytes = virtual_dma_count;\n#endif\n\n\t{\n\t\tint lcount;\n\t\tchar *lptr;\n\n\t\tfor (lcount = virtual_dma_count, lptr = virtual_dma_addr;\n\t\t     lcount; lcount--, lptr++) {\n\t\t\tst = inb(virtual_dma_port + FD_STATUS);\n\t\t\tst &= STATUS_DMA | STATUS_READY;\n\t\t\tif (st != (STATUS_DMA | STATUS_READY))\n\t\t\t\tbreak;\n\t\t\tif (virtual_dma_mode)\n\t\t\t\toutb_p(*lptr, virtual_dma_port + FD_DATA);\n\t\t\telse\n\t\t\t\t*lptr = inb_p(virtual_dma_port + FD_DATA);\n\t\t}\n\t\tvirtual_dma_count = lcount;\n\t\tvirtual_dma_addr = lptr;\n\t\tst = inb(virtual_dma_port + FD_STATUS);\n\t}\n\n#ifdef TRACE_FLPY_INT\n\tcalls++;\n#endif\n\tif (st == STATUS_DMA)\n\t\treturn IRQ_HANDLED;\n\tif (!(st & STATUS_DMA)) {\n\t\tvirtual_dma_residue += virtual_dma_count;\n\t\tvirtual_dma_count = 0;\n#ifdef TRACE_FLPY_INT\n\t\tprintk(KERN_DEBUG \"count=%x, residue=%x calls=%d bytes=%d dma_wait=%d\\n\",\n\t\t       virtual_dma_count, virtual_dma_residue, calls, bytes,\n\t\t       dma_wait);\n\t\tcalls = 0;\n\t\tdma_wait = 0;\n#endif\n\t\tdoing_pdma = 0;\n\t\tfloppy_interrupt(irq, dev_id);\n\t\treturn IRQ_HANDLED;\n\t}\n#ifdef TRACE_FLPY_INT\n\tif (!virtual_dma_count)\n\t\tdma_wait++;\n#endif\n\treturn IRQ_HANDLED;\n}\n\nstatic void fd_disable_dma(void)\n{\n\tif (!(can_use_virtual_dma & 1))\n\t\tdisable_dma(FLOPPY_DMA);\n\tdoing_pdma = 0;\n\tvirtual_dma_residue += virtual_dma_count;\n\tvirtual_dma_count = 0;\n}\n\nstatic int vdma_request_dma(unsigned int dmanr, const char *device_id)\n{\n\treturn 0;\n}\n\nstatic void vdma_nop(unsigned int dummy)\n{\n}\n\n\nstatic int vdma_get_dma_residue(unsigned int dummy)\n{\n\treturn virtual_dma_count + virtual_dma_residue;\n}\n\n\nstatic int fd_request_irq(void)\n{\n\tif (can_use_virtual_dma)\n\t\treturn request_irq(FLOPPY_IRQ, floppy_hardint,\n\t\t\t\t   0, \"floppy\", NULL);\n\telse\n\t\treturn request_irq(FLOPPY_IRQ, floppy_interrupt,\n\t\t\t\t   0, \"floppy\", NULL);\n}\n\nstatic unsigned long dma_mem_alloc(unsigned long size)\n{\n\treturn __get_dma_pages(GFP_KERNEL|__GFP_NORETRY, get_order(size));\n}\n\n\nstatic unsigned long vdma_mem_alloc(unsigned long size)\n{\n\treturn (unsigned long)vmalloc(size);\n\n}\n\n#define nodma_mem_alloc(size) vdma_mem_alloc(size)\n\nstatic void _fd_dma_mem_free(unsigned long addr, unsigned long size)\n{\n\tif ((unsigned long)addr >= (unsigned long)high_memory)\n\t\tvfree((void *)addr);\n\telse\n\t\tfree_pages(addr, get_order(size));\n}\n\n#define fd_dma_mem_free(addr, size)  _fd_dma_mem_free(addr, size)\n\nstatic void _fd_chose_dma_mode(char *addr, unsigned long size)\n{\n\tif (can_use_virtual_dma == 2) {\n\t\tif ((unsigned long)addr >= (unsigned long)high_memory ||\n\t\t    isa_virt_to_bus(addr) >= 0x1000000 ||\n\t\t    _CROSS_64KB(addr, size, 0))\n\t\t\tuse_virtual_dma = 1;\n\t\telse\n\t\t\tuse_virtual_dma = 0;\n\t} else {\n\t\tuse_virtual_dma = can_use_virtual_dma & 1;\n\t}\n}\n\n#define fd_chose_dma_mode(addr, size) _fd_chose_dma_mode(addr, size)\n\n\nstatic int vdma_dma_setup(char *addr, unsigned long size, int mode, int io)\n{\n\tdoing_pdma = 1;\n\tvirtual_dma_port = io;\n\tvirtual_dma_mode = (mode == DMA_MODE_WRITE);\n\tvirtual_dma_addr = addr;\n\tvirtual_dma_count = size;\n\tvirtual_dma_residue = 0;\n\treturn 0;\n}\n\nstatic int hard_dma_setup(char *addr, unsigned long size, int mode, int io)\n{\n#ifdef FLOPPY_SANITY_CHECK\n\tif (CROSS_64KB(addr, size)) {\n\t\tprintk(\"DMA crossing 64-K boundary %p-%p\\n\", addr, addr+size);\n\t\treturn -1;\n\t}\n#endif\n\t \n\tdoing_pdma = 0;\n\tclear_dma_ff(FLOPPY_DMA);\n\tset_dma_mode(FLOPPY_DMA, mode);\n\tset_dma_addr(FLOPPY_DMA, isa_virt_to_bus(addr));\n\tset_dma_count(FLOPPY_DMA, size);\n\tenable_dma(FLOPPY_DMA);\n\treturn 0;\n}\n\nstatic struct fd_routine_l {\n\tint (*_request_dma)(unsigned int dmanr, const char *device_id);\n\tvoid (*_free_dma)(unsigned int dmanr);\n\tint (*_get_dma_residue)(unsigned int dummy);\n\tunsigned long (*_dma_mem_alloc)(unsigned long size);\n\tint (*_dma_setup)(char *addr, unsigned long size, int mode, int io);\n} fd_routine[] = {\n\t{\n\t\t._request_dma\t\t= request_dma,\n\t\t._free_dma\t\t= free_dma,\n\t\t._get_dma_residue\t= get_dma_residue,\n\t\t._dma_mem_alloc\t\t= dma_mem_alloc,\n\t\t._dma_setup\t\t= hard_dma_setup\n\t},\n\t{\n\t\t._request_dma\t\t= vdma_request_dma,\n\t\t._free_dma\t\t= vdma_nop,\n\t\t._get_dma_residue\t= vdma_get_dma_residue,\n\t\t._dma_mem_alloc\t\t= vdma_mem_alloc,\n\t\t._dma_setup\t\t= vdma_dma_setup\n\t}\n};\n\n\nstatic int FDC1 = 0x3f0;\nstatic int FDC2 = -1;\n\n \n#define FLOPPY0_TYPE\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\\\n\tunsigned char val;\t\t\t\t\\\n\tspin_lock_irqsave(&rtc_lock, flags);\t\t\\\n\tval = (CMOS_READ(0x10) >> 4) & 15;\t\t\\\n\tspin_unlock_irqrestore(&rtc_lock, flags);\t\\\n\tval;\t\t\t\t\t\t\\\n})\n\n#define FLOPPY1_TYPE\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\\\n\tunsigned char val;\t\t\t\t\\\n\tspin_lock_irqsave(&rtc_lock, flags);\t\t\\\n\tval = CMOS_READ(0x10) & 15;\t\t\t\\\n\tspin_unlock_irqrestore(&rtc_lock, flags);\t\\\n\tval;\t\t\t\t\t\t\\\n})\n\n#define N_FDC 2\n#define N_DRIVE 8\n\n#define EXTRA_FLOPPY_PARAMS\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}