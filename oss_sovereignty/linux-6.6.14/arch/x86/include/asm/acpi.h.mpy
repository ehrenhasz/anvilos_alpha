{
  "module_name": "acpi.h",
  "hash_id": "84e30e94329f38c46d3fa9554ae5602d3f9cd6ddafe075fa2581d30fe23d9437",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/acpi.h",
  "human_readable_source": " \n#ifndef _ASM_X86_ACPI_H\n#define _ASM_X86_ACPI_H\n\n \n#include <acpi/proc_cap_intel.h>\n\n#include <asm/numa.h>\n#include <asm/fixmap.h>\n#include <asm/processor.h>\n#include <asm/mmu.h>\n#include <asm/mpspec.h>\n#include <asm/x86_init.h>\n#include <asm/cpufeature.h>\n#include <asm/irq_vectors.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n\n#ifdef CONFIG_ACPI_APEI\n# include <asm/pgtable_types.h>\n#endif\n\n#ifdef CONFIG_ACPI\nextern int acpi_lapic;\nextern int acpi_ioapic;\nextern int acpi_noirq;\nextern int acpi_strict;\nextern int acpi_disabled;\nextern int acpi_pci_disabled;\nextern int acpi_skip_timer_override;\nextern int acpi_use_timer_override;\nextern int acpi_fix_pin2_polarity;\nextern int acpi_disable_cmcff;\nextern bool acpi_int_src_ovr[NR_IRQS_LEGACY];\n\nextern u8 acpi_sci_flags;\nextern u32 acpi_sci_override_gsi;\nvoid acpi_pic_sci_set_trigger(unsigned int, u16);\n\nstruct device;\n\nextern int (*__acpi_register_gsi)(struct device *dev, u32 gsi,\n\t\t\t\t  int trigger, int polarity);\nextern void (*__acpi_unregister_gsi)(u32 gsi);\n\nstatic inline void disable_acpi(void)\n{\n\tacpi_disabled = 1;\n\tacpi_pci_disabled = 1;\n\tacpi_noirq = 1;\n}\n\nextern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);\n\nstatic inline void acpi_noirq_set(void) { acpi_noirq = 1; }\nstatic inline void acpi_disable_pci(void)\n{\n\tacpi_pci_disabled = 1;\n\tacpi_noirq_set();\n}\n\n \nextern int (*acpi_suspend_lowlevel)(void);\n\n \nunsigned long acpi_get_wakeup_address(void);\n\nstatic inline bool acpi_skip_set_wakeup_address(void)\n{\n\treturn cpu_feature_enabled(X86_FEATURE_XENPV);\n}\n\n#define acpi_skip_set_wakeup_address acpi_skip_set_wakeup_address\n\n \nstatic inline unsigned int acpi_processor_cstate_check(unsigned int max_cstate)\n{\n\t \n\tif (boot_cpu_data.x86 == 0x0F &&\n\t    boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86_model <= 0x05 &&\n\t    boot_cpu_data.x86_stepping < 0x0A)\n\t\treturn 1;\n\telse if (boot_cpu_has(X86_BUG_AMD_APIC_C1E))\n\t\treturn 1;\n\telse\n\t\treturn max_cstate;\n}\n\nstatic inline bool arch_has_acpi_pdc(void)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\treturn (c->x86_vendor == X86_VENDOR_INTEL ||\n\t\tc->x86_vendor == X86_VENDOR_CENTAUR);\n}\n\nstatic inline void arch_acpi_set_proc_cap_bits(u32 *cap)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\n\t*cap |= ACPI_PROC_CAP_C_CAPABILITY_SMP;\n\n\t \n\t*cap |= ACPI_PROC_CAP_SMP_T_SWCOORD;\n\n\tif (cpu_has(c, X86_FEATURE_EST))\n\t\t*cap |= ACPI_PROC_CAP_EST_CAPABILITY_SWSMP;\n\n\tif (cpu_has(c, X86_FEATURE_ACPI))\n\t\t*cap |= ACPI_PROC_CAP_T_FFH;\n\n\tif (cpu_has(c, X86_FEATURE_HWP))\n\t\t*cap |= ACPI_PROC_CAP_COLLAB_PROC_PERF;\n\n\t \n\tif (!cpu_has(c, X86_FEATURE_MWAIT) ||\n\t    boot_option_idle_override == IDLE_NOMWAIT)\n\t\t*cap &= ~(ACPI_PROC_CAP_C_C1_FFH | ACPI_PROC_CAP_C_C2C3_FFH);\n\n\tif (xen_initial_domain()) {\n\t\t \n\t\txen_sanitize_proc_cap_bits(cap);\n\t}\n}\n\nstatic inline bool acpi_has_cpu_in_madt(void)\n{\n\treturn !!acpi_lapic;\n}\n\n#define ACPI_HAVE_ARCH_SET_ROOT_POINTER\nstatic inline void acpi_arch_set_root_pointer(u64 addr)\n{\n\tx86_init.acpi.set_root_pointer(addr);\n}\n\n#define ACPI_HAVE_ARCH_GET_ROOT_POINTER\nstatic inline u64 acpi_arch_get_root_pointer(void)\n{\n\treturn x86_init.acpi.get_root_pointer();\n}\n\nvoid acpi_generic_reduced_hw_init(void);\n\nvoid x86_default_set_root_pointer(u64 addr);\nu64 x86_default_get_root_pointer(void);\n\n#else  \n\n#define acpi_lapic 0\n#define acpi_ioapic 0\n#define acpi_disable_cmcff 0\nstatic inline void acpi_noirq_set(void) { }\nstatic inline void acpi_disable_pci(void) { }\nstatic inline void disable_acpi(void) { }\n\nstatic inline void acpi_generic_reduced_hw_init(void) { }\n\nstatic inline void x86_default_set_root_pointer(u64 addr) { }\n\nstatic inline u64 x86_default_get_root_pointer(void)\n{\n\treturn 0;\n}\n\n#endif  \n\n#define ARCH_HAS_POWER_INIT\t1\n\n#ifdef CONFIG_ACPI_NUMA\nextern int x86_acpi_numa_init(void);\n#endif  \n\nstruct cper_ia_proc_ctx;\n\n#ifdef CONFIG_ACPI_APEI\nstatic inline pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)\n{\n\t \n\treturn PAGE_KERNEL_NOENC;\n}\n\nint arch_apei_report_x86_error(struct cper_ia_proc_ctx *ctx_info,\n\t\t\t       u64 lapic_id);\n#else\nstatic inline int arch_apei_report_x86_error(struct cper_ia_proc_ctx *ctx_info,\n\t\t\t\t\t     u64 lapic_id)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#define ACPI_TABLE_UPGRADE_MAX_PHYS (max_low_pfn_mapped << PAGE_SHIFT)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}