{
  "module_name": "checksum_64.h",
  "hash_id": "8c3c1a36e59fc6a636bf3f2cf48c94487610e876c65049eb364e5cbe62798274",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/checksum_64.h",
  "human_readable_source": " \n#ifndef _ASM_X86_CHECKSUM_64_H\n#define _ASM_X86_CHECKSUM_64_H\n\n \n\n#include <linux/compiler.h>\n#include <asm/byteorder.h>\n\n \nstatic inline __sum16 csum_fold(__wsum sum)\n{\n\tasm(\"  addl %1,%0\\n\"\n\t    \"  adcl $0xffff,%0\"\n\t    : \"=r\" (sum)\n\t    : \"r\" ((__force u32)sum << 16),\n\t      \"0\" ((__force u32)sum & 0xffff0000));\n\treturn (__force __sum16)(~(__force u32)sum >> 16);\n}\n\n \n\n \nstatic inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)\n{\n\tunsigned int sum;\n\n\tasm(\"  movl (%1), %0\\n\"\n\t    \"  subl $4, %2\\n\"\n\t    \"  jbe 2f\\n\"\n\t    \"  addl 4(%1), %0\\n\"\n\t    \"  adcl 8(%1), %0\\n\"\n\t    \"  adcl 12(%1), %0\\n\"\n\t    \"1: adcl 16(%1), %0\\n\"\n\t    \"  lea 4(%1), %1\\n\"\n\t    \"  decl %2\\n\"\n\t    \"  jne\t1b\\n\"\n\t    \"  adcl $0, %0\\n\"\n\t    \"  movl %0, %2\\n\"\n\t    \"  shrl $16, %0\\n\"\n\t    \"  addw %w2, %w0\\n\"\n\t    \"  adcl $0, %0\\n\"\n\t    \"  notl %0\\n\"\n\t    \"2:\"\n\t \n\t    : \"=r\" (sum), \"=r\" (iph), \"=r\" (ihl)\n\t    : \"1\" (iph), \"2\" (ihl)\n\t    : \"memory\");\n\treturn (__force __sum16)sum;\n}\n\n \nstatic inline __wsum\ncsum_tcpudp_nofold(__be32 saddr, __be32 daddr, __u32 len,\n\t\t   __u8 proto, __wsum sum)\n{\n\tasm(\"  addl %1, %0\\n\"\n\t    \"  adcl %2, %0\\n\"\n\t    \"  adcl %3, %0\\n\"\n\t    \"  adcl $0, %0\\n\"\n\t    : \"=r\" (sum)\n\t    : \"g\" (daddr), \"g\" (saddr),\n\t      \"g\" ((len + proto)<<8), \"0\" (sum));\n\treturn sum;\n}\n\n\n \nstatic inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,\n\t\t\t\t\t__u32 len, __u8 proto,\n\t\t\t\t\t__wsum sum)\n{\n\treturn csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));\n}\n\n \nextern __wsum csum_partial(const void *buff, int len, __wsum sum);\n\n \nextern __visible __wsum csum_partial_copy_generic(const void *src, void *dst, int len);\n\nextern __wsum csum_and_copy_from_user(const void __user *src, void *dst, int len);\nextern __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len);\nextern __wsum csum_partial_copy_nocheck(const void *src, void *dst, int len);\n\n \nextern __sum16 ip_compute_csum(const void *buff, int len);\n\n \n\nstruct in6_addr;\n\n#define _HAVE_ARCH_IPV6_CSUM 1\nextern __sum16\ncsum_ipv6_magic(const struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\t__u32 len, __u8 proto, __wsum sum);\n\nstatic inline unsigned add32_with_carry(unsigned a, unsigned b)\n{\n\tasm(\"addl %2,%0\\n\\t\"\n\t    \"adcl $0,%0\"\n\t    : \"=r\" (a)\n\t    : \"0\" (a), \"rm\" (b));\n\treturn a;\n}\n\n#define HAVE_ARCH_CSUM_ADD\nstatic inline __wsum csum_add(__wsum csum, __wsum addend)\n{\n\treturn (__force __wsum)add32_with_carry((__force unsigned)csum,\n\t\t\t\t\t\t(__force unsigned)addend);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}