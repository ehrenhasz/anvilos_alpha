{
  "module_name": "pci_x86.h",
  "hash_id": "57f759a8cc5e88177feae88e29ecae5c353de86c066a463614b07b81764ac28b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/pci_x86.h",
  "human_readable_source": " \n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(fmt, ...) printk(fmt, ##__VA_ARGS__)\n#else\n#define DBG(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\\\n} while (0)\n#endif\n\n#define PCI_PROBE_BIOS\t\t0x0001\n#define PCI_PROBE_CONF1\t\t0x0002\n#define PCI_PROBE_CONF2\t\t0x0004\n#define PCI_PROBE_MMCONF\t0x0008\n#define PCI_PROBE_MASK\t\t0x000f\n#define PCI_PROBE_NOEARLY\t0x0010\n\n#define PCI_NO_CHECKS\t\t0x0400\n#define PCI_USE_PIRQ_MASK\t0x0800\n#define PCI_ASSIGN_ROMS\t\t0x1000\n#define PCI_BIOS_IRQ_SCAN\t0x2000\n#define PCI_ASSIGN_ALL_BUSSES\t0x4000\n#define PCI_CAN_SKIP_ISA_ALIGN\t0x8000\n#define PCI_USE__CRS\t\t0x10000\n#define PCI_CHECK_ENABLE_AMD_MMCONF\t0x20000\n#define PCI_HAS_IO_ECS\t\t0x40000\n#define PCI_NOASSIGN_ROMS\t0x80000\n#define PCI_ROOT_NO_CRS\t\t0x100000\n#define PCI_NOASSIGN_BARS\t0x200000\n#define PCI_BIG_ROOT_WINDOW\t0x400000\n#define PCI_USE_E820\t\t0x800000\n#define PCI_NO_E820\t\t0x1000000\n\nextern unsigned int pci_probe;\nextern unsigned long pirq_table_addr;\n\nenum pci_bf_sort_state {\n\tpci_bf_sort_default,\n\tpci_force_nobf,\n\tpci_force_bf,\n\tpci_dmi_bf,\n};\n\n \n\nvoid pcibios_resource_survey(void);\nvoid pcibios_set_cache_line_size(void);\n\n \n\nextern int pcibios_last_bus;\nextern struct pci_ops pci_root_ops;\n\nvoid pcibios_scan_specific_bus(int busn);\n\n \n\nstruct pci_dev;\n\nstruct irq_info {\n\tu8 bus, devfn;\t\t\t \n\tstruct {\n\t\tu8 link;\t\t \n\t\tu16 bitmap;\t\t \n\t} __attribute__((packed)) irq[4];\n\tu8 slot;\t\t\t \n\tu8 rfu;\n} __attribute__((packed));\n\nstruct irq_routing_table {\n\tu32 signature;\t\t\t \n\tu16 version;\t\t\t \n\tu16 size;\t\t\t \n\tu8 rtr_bus, rtr_devfn;\t\t \n\tu16 exclusive_irqs;\t\t \n\tu16 rtr_vendor, rtr_device;\t \n\tu32 miniport_data;\t\t \n\tu8 rfu[11];\n\tu8 checksum;\t\t\t \n\tstruct irq_info slots[];\n} __attribute__((packed));\n\nstruct irt_routing_table {\n\tu32 signature;\t\t\t \n\tu8 size;\t\t\t \n\tu8 used;\t\t\t \n\tu16 exclusive_irqs;\t\t \n\tstruct irq_info slots[];\n} __attribute__((packed));\n\nextern unsigned int pcibios_irq_mask;\n\nextern raw_spinlock_t pci_config_lock;\n\nextern int (*pcibios_enable_irq)(struct pci_dev *dev);\nextern void (*pcibios_disable_irq)(struct pci_dev *dev);\n\nextern bool mp_should_keep_irq(struct device *dev);\n\nstruct pci_raw_ops {\n\tint (*read)(unsigned int domain, unsigned int bus, unsigned int devfn,\n\t\t\t\t\t\tint reg, int len, u32 *val);\n\tint (*write)(unsigned int domain, unsigned int bus, unsigned int devfn,\n\t\t\t\t\t\tint reg, int len, u32 val);\n};\n\nextern const struct pci_raw_ops *raw_pci_ops;\nextern const struct pci_raw_ops *raw_pci_ext_ops;\n\nextern const struct pci_raw_ops pci_mmcfg;\nextern const struct pci_raw_ops pci_direct_conf1;\nextern bool port_cf9_safe;\n\n \n#ifdef CONFIG_PCI_DIRECT\nextern int pci_direct_probe(void);\nextern void pci_direct_init(int type);\n#else\nstatic inline int pci_direct_probe(void) { return -1; }\nstatic inline  void pci_direct_init(int type) { }\n#endif\n\n#ifdef CONFIG_PCI_BIOS\nextern void pci_pcbios_init(void);\n#else\nstatic inline void pci_pcbios_init(void) { }\n#endif\n\nextern void __init dmi_check_pciprobe(void);\nextern void __init dmi_check_skip_isa_align(void);\n\n \n#ifdef CONFIG_PCI\nextern int __init pci_acpi_init(void);\n#else\nstatic inline int  __init pci_acpi_init(void)\n{\n\treturn -EINVAL;\n}\n#endif\nextern void __init pcibios_irq_init(void);\nextern int __init pcibios_init(void);\nextern int pci_legacy_init(void);\nextern void pcibios_fixup_irqs(void);\n\n \n\n \n#define PCI_MMCFG_RESOURCE_NAME_LEN (22 + 4 + 2 + 2)\n\nstruct pci_mmcfg_region {\n\tstruct list_head list;\n\tstruct resource res;\n\tu64 address;\n\tchar __iomem *virt;\n\tu16 segment;\n\tu8 start_bus;\n\tu8 end_bus;\n\tchar name[PCI_MMCFG_RESOURCE_NAME_LEN];\n};\n\nextern int __init pci_mmcfg_arch_init(void);\nextern void __init pci_mmcfg_arch_free(void);\nextern int pci_mmcfg_arch_map(struct pci_mmcfg_region *cfg);\nextern void pci_mmcfg_arch_unmap(struct pci_mmcfg_region *cfg);\nextern int pci_mmconfig_insert(struct device *dev, u16 seg, u8 start, u8 end,\n\t\t\t       phys_addr_t addr);\nextern int pci_mmconfig_delete(u16 seg, u8 start, u8 end);\nextern struct pci_mmcfg_region *pci_mmconfig_lookup(int segment, int bus);\nextern struct pci_mmcfg_region *__init pci_mmconfig_add(int segment, int start,\n\t\t\t\t\t\t\tint end, u64 addr);\n\nextern struct list_head pci_mmcfg_list;\n\n#define PCI_MMCFG_BUS_OFFSET(bus)      ((bus) << 20)\n\n \nstatic inline unsigned char mmio_config_readb(void __iomem *pos)\n{\n\tu8 val;\n\tasm volatile(\"movb (%1),%%al\" : \"=a\" (val) : \"r\" (pos));\n\treturn val;\n}\n\nstatic inline unsigned short mmio_config_readw(void __iomem *pos)\n{\n\tu16 val;\n\tasm volatile(\"movw (%1),%%ax\" : \"=a\" (val) : \"r\" (pos));\n\treturn val;\n}\n\nstatic inline unsigned int mmio_config_readl(void __iomem *pos)\n{\n\tu32 val;\n\tasm volatile(\"movl (%1),%%eax\" : \"=a\" (val) : \"r\" (pos));\n\treturn val;\n}\n\nstatic inline void mmio_config_writeb(void __iomem *pos, u8 val)\n{\n\tasm volatile(\"movb %%al,(%1)\" : : \"a\" (val), \"r\" (pos) : \"memory\");\n}\n\nstatic inline void mmio_config_writew(void __iomem *pos, u16 val)\n{\n\tasm volatile(\"movw %%ax,(%1)\" : : \"a\" (val), \"r\" (pos) : \"memory\");\n}\n\nstatic inline void mmio_config_writel(void __iomem *pos, u32 val)\n{\n\tasm volatile(\"movl %%eax,(%1)\" : : \"a\" (val), \"r\" (pos) : \"memory\");\n}\n\n#ifdef CONFIG_PCI\n# ifdef CONFIG_ACPI\n#  define x86_default_pci_init\t\tpci_acpi_init\n# else\n#  define x86_default_pci_init\t\tpci_legacy_init\n# endif\n# define x86_default_pci_init_irq\tpcibios_irq_init\n# define x86_default_pci_fixup_irqs\tpcibios_fixup_irqs\n#else\n# define x86_default_pci_init\t\tNULL\n# define x86_default_pci_init_irq\tNULL\n# define x86_default_pci_fixup_irqs\tNULL\n#endif\n\n#if defined(CONFIG_PCI) && defined(CONFIG_ACPI)\nextern bool pci_use_e820;\n#else\n#define pci_use_e820 false\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}