{
  "module_name": "resctrl.h",
  "hash_id": "d4e00da150641d8c4b88f69a44e7d359dc74c0086d74602af21a68afb2548c41",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/resctrl.h",
  "human_readable_source": " \n#ifndef _ASM_X86_RESCTRL_H\n#define _ASM_X86_RESCTRL_H\n\n#ifdef CONFIG_X86_CPU_RESCTRL\n\n#include <linux/sched.h>\n#include <linux/jump_label.h>\n\n \nstruct resctrl_pqr_state {\n\tu32\t\t\tcur_rmid;\n\tu32\t\t\tcur_closid;\n\tu32\t\t\tdefault_rmid;\n\tu32\t\t\tdefault_closid;\n};\n\nDECLARE_PER_CPU(struct resctrl_pqr_state, pqr_state);\n\nDECLARE_STATIC_KEY_FALSE(rdt_enable_key);\nDECLARE_STATIC_KEY_FALSE(rdt_alloc_enable_key);\nDECLARE_STATIC_KEY_FALSE(rdt_mon_enable_key);\n\n \nstatic inline void __resctrl_sched_in(struct task_struct *tsk)\n{\n\tstruct resctrl_pqr_state *state = this_cpu_ptr(&pqr_state);\n\tu32 closid = state->default_closid;\n\tu32 rmid = state->default_rmid;\n\tu32 tmp;\n\n\t \n\tif (static_branch_likely(&rdt_alloc_enable_key)) {\n\t\ttmp = READ_ONCE(tsk->closid);\n\t\tif (tmp)\n\t\t\tclosid = tmp;\n\t}\n\n\tif (static_branch_likely(&rdt_mon_enable_key)) {\n\t\ttmp = READ_ONCE(tsk->rmid);\n\t\tif (tmp)\n\t\t\trmid = tmp;\n\t}\n\n\tif (closid != state->cur_closid || rmid != state->cur_rmid) {\n\t\tstate->cur_closid = closid;\n\t\tstate->cur_rmid = rmid;\n\t\twrmsr(MSR_IA32_PQR_ASSOC, rmid, closid);\n\t}\n}\n\nstatic inline unsigned int resctrl_arch_round_mon_val(unsigned int val)\n{\n\tunsigned int scale = boot_cpu_data.x86_cache_occ_scale;\n\n\t \n\tval /= scale;\n\treturn val * scale;\n}\n\nstatic inline void resctrl_sched_in(struct task_struct *tsk)\n{\n\tif (static_branch_likely(&rdt_enable_key))\n\t\t__resctrl_sched_in(tsk);\n}\n\nvoid resctrl_cpu_detect(struct cpuinfo_x86 *c);\n\n#else\n\nstatic inline void resctrl_sched_in(struct task_struct *tsk) {}\nstatic inline void resctrl_cpu_detect(struct cpuinfo_x86 *c) {}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}