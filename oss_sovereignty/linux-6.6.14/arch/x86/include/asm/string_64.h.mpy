{
  "module_name": "string_64.h",
  "hash_id": "67ad4beea1fd7036b755cd27e16d32961c9777174534d7287505d714c798a61b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/string_64.h",
  "human_readable_source": " \n#ifndef _ASM_X86_STRING_64_H\n#define _ASM_X86_STRING_64_H\n\n#ifdef __KERNEL__\n#include <linux/jump_label.h>\n\n \n\n \n\n#if defined(__SANITIZE_MEMORY__) && defined(__NO_FORTIFY)\n#include <linux/kmsan_string.h>\n#endif\n\n#define __HAVE_ARCH_MEMCPY 1\nextern void *memcpy(void *to, const void *from, size_t len);\nextern void *__memcpy(void *to, const void *from, size_t len);\n\n#define __HAVE_ARCH_MEMSET\nvoid *memset(void *s, int c, size_t n);\nvoid *__memset(void *s, int c, size_t n);\n\n \n#if !defined(CONFIG_KMSAN)\n#define __HAVE_ARCH_MEMSET16\nstatic inline void *memset16(uint16_t *s, uint16_t v, size_t n)\n{\n\tlong d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosw\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (v), \"1\" (s), \"0\" (n)\n\t\t     : \"memory\");\n\treturn s;\n}\n\n#define __HAVE_ARCH_MEMSET32\nstatic inline void *memset32(uint32_t *s, uint32_t v, size_t n)\n{\n\tlong d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosl\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (v), \"1\" (s), \"0\" (n)\n\t\t     : \"memory\");\n\treturn s;\n}\n\n#define __HAVE_ARCH_MEMSET64\nstatic inline void *memset64(uint64_t *s, uint64_t v, size_t n)\n{\n\tlong d0, d1;\n\tasm volatile(\"rep\\n\\t\"\n\t\t     \"stosq\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1)\n\t\t     : \"a\" (v), \"1\" (s), \"0\" (n)\n\t\t     : \"memory\");\n\treturn s;\n}\n#endif\n\n#define __HAVE_ARCH_MEMMOVE\nvoid *memmove(void *dest, const void *src, size_t count);\nvoid *__memmove(void *dest, const void *src, size_t count);\n\nint memcmp(const void *cs, const void *ct, size_t count);\nsize_t strlen(const char *s);\nchar *strcpy(char *dest, const char *src);\nchar *strcat(char *dest, const char *src);\nint strcmp(const char *cs, const char *ct);\n\n#ifdef CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE\n#define __HAVE_ARCH_MEMCPY_FLUSHCACHE 1\nvoid __memcpy_flushcache(void *dst, const void *src, size_t cnt);\nstatic __always_inline void memcpy_flushcache(void *dst, const void *src, size_t cnt)\n{\n\tif (__builtin_constant_p(cnt)) {\n\t\tswitch (cnt) {\n\t\t\tcase 4:\n\t\t\t\tasm (\"movntil %1, %0\" : \"=m\"(*(u32 *)dst) : \"r\"(*(u32 *)src));\n\t\t\t\treturn;\n\t\t\tcase 8:\n\t\t\t\tasm (\"movntiq %1, %0\" : \"=m\"(*(u64 *)dst) : \"r\"(*(u64 *)src));\n\t\t\t\treturn;\n\t\t\tcase 16:\n\t\t\t\tasm (\"movntiq %1, %0\" : \"=m\"(*(u64 *)dst) : \"r\"(*(u64 *)src));\n\t\t\t\tasm (\"movntiq %1, %0\" : \"=m\"(*(u64 *)(dst + 8)) : \"r\"(*(u64 *)(src + 8)));\n\t\t\t\treturn;\n\t\t}\n\t}\n\t__memcpy_flushcache(dst, src, cnt);\n}\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}