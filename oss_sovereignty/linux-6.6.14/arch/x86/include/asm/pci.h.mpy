{
  "module_name": "pci.h",
  "hash_id": "48bf9c34cc1eb66772d846b83e7d70146d759db480ab4fe6f137c2219b1af9ff",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/pci.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PCI_H\n#define _ASM_X86_PCI_H\n\n#include <linux/mm.h>  \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/scatterlist.h>\n#include <linux/numa.h>\n#include <asm/io.h>\n#include <asm/memtype.h>\n#include <asm/x86_init.h>\n\nstruct pci_sysdata {\n\tint\t\tdomain;\t\t \n\tint\t\tnode;\t\t \n#ifdef CONFIG_ACPI\n\tstruct acpi_device *companion;\t \n#endif\n#ifdef CONFIG_X86_64\n\tvoid\t\t*iommu;\t\t \n#endif\n#ifdef CONFIG_PCI_MSI\n\tvoid\t\t*fwnode;\t \n#endif\n#if IS_ENABLED(CONFIG_VMD)\n\tstruct pci_dev\t*vmd_dev;\t \n#endif\n};\n\nextern int pci_routeirq;\nextern int noioapicquirk;\nextern int noioapicreroute;\n\nstatic inline struct pci_sysdata *to_pci_sysdata(const struct pci_bus *bus)\n{\n\treturn bus->sysdata;\n}\n\n#ifdef CONFIG_PCI\n\n#ifdef CONFIG_PCI_DOMAINS\nstatic inline int pci_domain_nr(struct pci_bus *bus)\n{\n\treturn to_pci_sysdata(bus)->domain;\n}\n\nstatic inline int pci_proc_domain(struct pci_bus *bus)\n{\n\treturn pci_domain_nr(bus);\n}\n#endif\n\n#ifdef CONFIG_PCI_MSI\nstatic inline void *_pci_root_bus_fwnode(struct pci_bus *bus)\n{\n\treturn to_pci_sysdata(bus)->fwnode;\n}\n\n#define pci_root_bus_fwnode\t_pci_root_bus_fwnode\n#endif\n\n#if IS_ENABLED(CONFIG_VMD)\nstatic inline bool is_vmd(struct pci_bus *bus)\n{\n\treturn to_pci_sysdata(bus)->vmd_dev != NULL;\n}\n#else\n#define is_vmd(bus)\t\tfalse\n#endif  \n\n \n\nextern unsigned int pcibios_assign_all_busses(void);\nextern int pci_legacy_init(void);\n#else\nstatic inline int pcibios_assign_all_busses(void) { return 0; }\n#endif\n\nextern unsigned long pci_mem_start;\n#define PCIBIOS_MIN_IO\t\t0x1000\n#define PCIBIOS_MIN_MEM\t\t(pci_mem_start)\n\n#define PCIBIOS_MIN_CARDBUS_IO\t0x4000\n\nextern int pcibios_enabled;\nvoid pcibios_scan_root(int bus);\n\nstruct irq_routing_table *pcibios_get_irq_routing_table(void);\nint pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);\n\nbool pci_dev_has_default_msi_parent_domain(struct pci_dev *dev);\n\n#define HAVE_PCI_MMAP\n#define arch_can_pci_mmap_wc()\tpat_enabled()\n#define ARCH_GENERIC_PCI_MMAP_RESOURCE\n\n#ifdef CONFIG_PCI\nextern void early_quirks(void);\n#else\nstatic inline void early_quirks(void) { }\n#endif\n\nextern void pci_iommu_alloc(void);\n\n#ifdef CONFIG_NUMA\n \nstatic inline int __pcibus_to_node(const struct pci_bus *bus)\n{\n\treturn to_pci_sysdata(bus)->node;\n}\n\nstatic inline const struct cpumask *\ncpumask_of_pcibus(const struct pci_bus *bus)\n{\n\tint node;\n\n\tnode = __pcibus_to_node(bus);\n\treturn (node == NUMA_NO_NODE) ? cpu_online_mask :\n\t\t\t      cpumask_of_node(node);\n}\n#endif\n\nstruct pci_setup_rom {\n\tstruct setup_data data;\n\tuint16_t vendor;\n\tuint16_t devid;\n\tuint64_t pcilen;\n\tunsigned long segment;\n\tunsigned long bus;\n\tunsigned long device;\n\tunsigned long function;\n\tuint8_t romdata[];\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}