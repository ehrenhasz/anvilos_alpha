{
  "module_name": "checksum_32.h",
  "hash_id": "57e4f6ef7cb7ba824223a54978233193796924dcb0eab7dc169c668ec3171433",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/checksum_32.h",
  "human_readable_source": " \n#ifndef _ASM_X86_CHECKSUM_32_H\n#define _ASM_X86_CHECKSUM_32_H\n\n#include <linux/in6.h>\n#include <linux/uaccess.h>\n\n \nasmlinkage __wsum csum_partial(const void *buff, int len, __wsum sum);\n\n \n\nasmlinkage __wsum csum_partial_copy_generic(const void *src, void *dst, int len);\n\n \nstatic inline __wsum csum_partial_copy_nocheck(const void *src, void *dst, int len)\n{\n\treturn csum_partial_copy_generic(src, dst, len);\n}\n\nstatic inline __wsum csum_and_copy_from_user(const void __user *src,\n\t\t\t\t\t     void *dst, int len)\n{\n\t__wsum ret;\n\n\tmight_sleep();\n\tif (!user_access_begin(src, len))\n\t\treturn 0;\n\tret = csum_partial_copy_generic((__force void *)src, dst, len);\n\tuser_access_end();\n\n\treturn ret;\n}\n\n \nstatic inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)\n{\n\tunsigned int sum;\n\n\tasm volatile(\"movl (%1), %0\t;\\n\"\n\t\t     \"subl $4, %2\t;\\n\"\n\t\t     \"jbe 2f\t\t;\\n\"\n\t\t     \"addl 4(%1), %0\t;\\n\"\n\t\t     \"adcl 8(%1), %0\t;\\n\"\n\t\t     \"adcl 12(%1), %0;\\n\"\n\t\t     \"1:\tadcl 16(%1), %0\t;\\n\"\n\t\t     \"lea 4(%1), %1\t;\\n\"\n\t\t     \"decl %2\t;\\n\"\n\t\t     \"jne 1b\t\t;\\n\"\n\t\t     \"adcl $0, %0\t;\\n\"\n\t\t     \"movl %0, %2\t;\\n\"\n\t\t     \"shrl $16, %0\t;\\n\"\n\t\t     \"addw %w2, %w0\t;\\n\"\n\t\t     \"adcl $0, %0\t;\\n\"\n\t\t     \"notl %0\t;\\n\"\n\t\t     \"2:\t\t;\\n\"\n\t \n\t\t     : \"=r\" (sum), \"=r\" (iph), \"=r\" (ihl)\n\t\t     : \"1\" (iph), \"2\" (ihl)\n\t\t     : \"memory\");\n\treturn (__force __sum16)sum;\n}\n\n \n\nstatic inline __sum16 csum_fold(__wsum sum)\n{\n\tasm(\"addl %1, %0\t\t;\\n\"\n\t    \"adcl $0xffff, %0\t;\\n\"\n\t    : \"=r\" (sum)\n\t    : \"r\" ((__force u32)sum << 16),\n\t      \"0\" ((__force u32)sum & 0xffff0000));\n\treturn (__force __sum16)(~(__force u32)sum >> 16);\n}\n\nstatic inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,\n\t\t\t\t\t__u32 len, __u8 proto,\n\t\t\t\t\t__wsum sum)\n{\n\tasm(\"addl %1, %0\t;\\n\"\n\t    \"adcl %2, %0\t;\\n\"\n\t    \"adcl %3, %0\t;\\n\"\n\t    \"adcl $0, %0\t;\\n\"\n\t    : \"=r\" (sum)\n\t    : \"g\" (daddr), \"g\"(saddr),\n\t      \"g\" ((len + proto) << 8), \"0\" (sum));\n\treturn sum;\n}\n\n \nstatic inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,\n\t\t\t\t\t__u32 len, __u8 proto,\n\t\t\t\t\t__wsum sum)\n{\n\treturn csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));\n}\n\n \n\nstatic inline __sum16 ip_compute_csum(const void *buff, int len)\n{\n    return csum_fold(csum_partial(buff, len, 0));\n}\n\n#define _HAVE_ARCH_IPV6_CSUM\nstatic inline __sum16 csum_ipv6_magic(const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr,\n\t\t\t\t      __u32 len, __u8 proto, __wsum sum)\n{\n\tasm(\"addl 0(%1), %0\t;\\n\"\n\t    \"adcl 4(%1), %0\t;\\n\"\n\t    \"adcl 8(%1), %0\t;\\n\"\n\t    \"adcl 12(%1), %0\t;\\n\"\n\t    \"adcl 0(%2), %0\t;\\n\"\n\t    \"adcl 4(%2), %0\t;\\n\"\n\t    \"adcl 8(%2), %0\t;\\n\"\n\t    \"adcl 12(%2), %0\t;\\n\"\n\t    \"adcl %3, %0\t;\\n\"\n\t    \"adcl %4, %0\t;\\n\"\n\t    \"adcl $0, %0\t;\\n\"\n\t    : \"=&r\" (sum)\n\t    : \"r\" (saddr), \"r\" (daddr),\n\t      \"r\" (htonl(len)), \"r\" (htonl(proto)), \"0\" (sum)\n\t    : \"memory\");\n\n\treturn csum_fold(sum);\n}\n\n \nstatic inline __wsum csum_and_copy_to_user(const void *src,\n\t\t\t\t\t   void __user *dst,\n\t\t\t\t\t   int len)\n{\n\t__wsum ret;\n\n\tmight_sleep();\n\tif (!user_access_begin(dst, len))\n\t\treturn 0;\n\n\tret = csum_partial_copy_generic(src, (__force void *)dst, len);\n\tuser_access_end();\n\treturn ret;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}