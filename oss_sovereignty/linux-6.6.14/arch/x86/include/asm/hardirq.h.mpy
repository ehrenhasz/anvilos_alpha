{
  "module_name": "hardirq.h",
  "hash_id": "53080bdcec42c2a503f1e80dc0193c2d27b39d28bbfe21dea8a8f1d14f7fc442",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/hardirq.h",
  "human_readable_source": " \n#ifndef _ASM_X86_HARDIRQ_H\n#define _ASM_X86_HARDIRQ_H\n\n#include <linux/threads.h>\n#include <asm/current.h>\n\ntypedef struct {\n#if IS_ENABLED(CONFIG_KVM_INTEL)\n\tu8\t     kvm_cpu_l1tf_flush_l1d;\n#endif\n\tunsigned int __nmi_count;\t \n#ifdef CONFIG_X86_LOCAL_APIC\n\tunsigned int apic_timer_irqs;\t \n\tunsigned int irq_spurious_count;\n\tunsigned int icr_read_retry_count;\n#endif\n#ifdef CONFIG_HAVE_KVM\n\tunsigned int kvm_posted_intr_ipis;\n\tunsigned int kvm_posted_intr_wakeup_ipis;\n\tunsigned int kvm_posted_intr_nested_ipis;\n#endif\n\tunsigned int x86_platform_ipis;\t \n\tunsigned int apic_perf_irqs;\n\tunsigned int apic_irq_work_irqs;\n#ifdef CONFIG_SMP\n\tunsigned int irq_resched_count;\n\tunsigned int irq_call_count;\n#endif\n\tunsigned int irq_tlb_count;\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tunsigned int irq_thermal_count;\n#endif\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tunsigned int irq_threshold_count;\n#endif\n#ifdef CONFIG_X86_MCE_AMD\n\tunsigned int irq_deferred_error_count;\n#endif\n#ifdef CONFIG_X86_HV_CALLBACK_VECTOR\n\tunsigned int irq_hv_callback_count;\n#endif\n#if IS_ENABLED(CONFIG_HYPERV)\n\tunsigned int irq_hv_reenlightenment_count;\n\tunsigned int hyperv_stimer0_count;\n#endif\n} ____cacheline_aligned irq_cpustat_t;\n\nDECLARE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);\n\n#define __ARCH_IRQ_STAT\n\n#define inc_irq_stat(member)\tthis_cpu_inc(irq_stat.member)\n\nextern void ack_bad_irq(unsigned int irq);\n\nextern u64 arch_irq_stat_cpu(unsigned int cpu);\n#define arch_irq_stat_cpu\tarch_irq_stat_cpu\n\nextern u64 arch_irq_stat(void);\n#define arch_irq_stat\t\tarch_irq_stat\n\n#define local_softirq_pending_ref       pcpu_hot.softirq_pending\n\n#if IS_ENABLED(CONFIG_KVM_INTEL)\nstatic inline void kvm_set_cpu_l1tf_flush_l1d(void)\n{\n\t__this_cpu_write(irq_stat.kvm_cpu_l1tf_flush_l1d, 1);\n}\n\nstatic __always_inline void kvm_clear_cpu_l1tf_flush_l1d(void)\n{\n\t__this_cpu_write(irq_stat.kvm_cpu_l1tf_flush_l1d, 0);\n}\n\nstatic __always_inline bool kvm_get_cpu_l1tf_flush_l1d(void)\n{\n\treturn __this_cpu_read(irq_stat.kvm_cpu_l1tf_flush_l1d);\n}\n#else  \nstatic inline void kvm_set_cpu_l1tf_flush_l1d(void) { }\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}