{
  "module_name": "unwind.h",
  "hash_id": "0ce64c4cdbeb572ea030e8bfb2a65e7a22085beb553c62eb12a5258c9ea66335",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/unwind.h",
  "human_readable_source": " \n#ifndef _ASM_X86_UNWIND_H\n#define _ASM_X86_UNWIND_H\n\n#include <linux/sched.h>\n#include <linux/ftrace.h>\n#include <linux/rethook.h>\n#include <asm/ptrace.h>\n#include <asm/stacktrace.h>\n\n#define IRET_FRAME_OFFSET (offsetof(struct pt_regs, ip))\n#define IRET_FRAME_SIZE   (sizeof(struct pt_regs) - IRET_FRAME_OFFSET)\n\nstruct unwind_state {\n\tstruct stack_info stack_info;\n\tunsigned long stack_mask;\n\tstruct task_struct *task;\n\tint graph_idx;\n#if defined(CONFIG_RETHOOK)\n\tstruct llist_node *kr_cur;\n#endif\n\tbool error;\n#if defined(CONFIG_UNWINDER_ORC)\n\tbool signal, full_regs;\n\tunsigned long sp, bp, ip;\n\tstruct pt_regs *regs, *prev_regs;\n#elif defined(CONFIG_UNWINDER_FRAME_POINTER)\n\tbool got_irq;\n\tunsigned long *bp, *orig_sp, ip;\n\t \n\tunsigned long *next_bp;\n\tstruct pt_regs *regs;\n#else\n\tunsigned long *sp;\n#endif\n};\n\nvoid __unwind_start(struct unwind_state *state, struct task_struct *task,\n\t\t    struct pt_regs *regs, unsigned long *first_frame);\nbool unwind_next_frame(struct unwind_state *state);\nunsigned long unwind_get_return_address(struct unwind_state *state);\nunsigned long *unwind_get_return_address_ptr(struct unwind_state *state);\n\nstatic inline bool unwind_done(struct unwind_state *state)\n{\n\treturn state->stack_info.type == STACK_TYPE_UNKNOWN;\n}\n\nstatic inline bool unwind_error(struct unwind_state *state)\n{\n\treturn state->error;\n}\n\nstatic inline\nvoid unwind_start(struct unwind_state *state, struct task_struct *task,\n\t\t  struct pt_regs *regs, unsigned long *first_frame)\n{\n\tfirst_frame = first_frame ? : get_stack_pointer(task, regs);\n\n\t__unwind_start(state, task, regs, first_frame);\n}\n\n#if defined(CONFIG_UNWINDER_ORC) || defined(CONFIG_UNWINDER_FRAME_POINTER)\n \nstatic inline struct pt_regs *unwind_get_entry_regs(struct unwind_state *state,\n\t\t\t\t\t\t    bool *partial)\n{\n\tif (unwind_done(state))\n\t\treturn NULL;\n\n\tif (partial) {\n#ifdef CONFIG_UNWINDER_ORC\n\t\t*partial = !state->full_regs;\n#else\n\t\t*partial = false;\n#endif\n\t}\n\n\treturn state->regs;\n}\n#else\nstatic inline struct pt_regs *unwind_get_entry_regs(struct unwind_state *state,\n\t\t\t\t\t\t    bool *partial)\n{\n\treturn NULL;\n}\n#endif\n\n#ifdef CONFIG_UNWINDER_ORC\nvoid unwind_init(void);\nvoid unwind_module_init(struct module *mod, void *orc_ip, size_t orc_ip_size,\n\t\t\tvoid *orc, size_t orc_size);\n#else\nstatic inline void unwind_init(void) {}\nstatic inline\nvoid unwind_module_init(struct module *mod, void *orc_ip, size_t orc_ip_size,\n\t\t\tvoid *orc, size_t orc_size) {}\n#endif\n\nstatic inline\nunsigned long unwind_recover_rethook(struct unwind_state *state,\n\t\t\t\t     unsigned long addr, unsigned long *addr_p)\n{\n#ifdef CONFIG_RETHOOK\n\tif (is_rethook_trampoline(addr))\n\t\treturn rethook_find_ret_addr(state->task, (unsigned long)addr_p,\n\t\t\t\t\t     &state->kr_cur);\n#endif\n\treturn addr;\n}\n\n \nstatic inline\nunsigned long unwind_recover_ret_addr(struct unwind_state *state,\n\t\t\t\t     unsigned long addr, unsigned long *addr_p)\n{\n\tunsigned long ret;\n\n\tret = ftrace_graph_ret_addr(state->task, &state->graph_idx,\n\t\t\t\t    addr, addr_p);\n\treturn unwind_recover_rethook(state, ret, addr_p);\n}\n\n \n#define READ_ONCE_TASK_STACK(task, x)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\\\n\tif (task == current)\t\t\t\t\\\n\t\tval = READ_ONCE(x);\t\t\t\\\n\telse\t\t\t\t\t\t\\\n\t\tval = READ_ONCE_NOCHECK(x);\t\t\\\n\tval;\t\t\t\t\t\t\\\n})\n\nstatic inline bool task_on_another_cpu(struct task_struct *task)\n{\n#ifdef CONFIG_SMP\n\treturn task != current && task->on_cpu;\n#else\n\treturn false;\n#endif\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}