{
  "module_name": "uv_hub.h",
  "hash_id": "34c49afaf7074699f4d49be9fe522e298ba90ba384d8b365a3cfcbe991b8cb28",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/uv/uv_hub.h",
  "human_readable_source": " \n\n#ifndef _ASM_X86_UV_UV_HUB_H\n#define _ASM_X86_UV_UV_HUB_H\n\n#ifdef CONFIG_X86_64\n#include <linux/numa.h>\n#include <linux/percpu.h>\n#include <linux/timer.h>\n#include <linux/io.h>\n#include <linux/topology.h>\n#include <asm/types.h>\n#include <asm/percpu.h>\n#include <asm/uv/uv.h>\n#include <asm/uv/uv_mmrs.h>\n#include <asm/uv/bios.h>\n#include <asm/irq_vectors.h>\n#include <asm/io_apic.h>\n\n\n \n\n \n#define UV_MAX_NUMALINK_BLADES\t16384\n\n \n#define UV_MAX_SSI_BLADES\t256\n\n \n#define UV_MAX_NASID_VALUE\t(UV_MAX_NUMALINK_BLADES * 2)\n\n \nstruct uv_gam_range_s {\n\tu32\tlimit;\t\t \n\tu16\tnasid;\t\t \n\ts8\tbase;\t\t \n\tu8\treserved;\n};\n\n \nstruct uv_hub_info_s {\n\tunsigned int\t\thub_type;\n\tunsigned char\t\thub_revision;\n\tunsigned long\t\tglobal_mmr_base;\n\tunsigned long\t\tglobal_mmr_shift;\n\tunsigned long\t\tgpa_mask;\n\tunsigned short\t\t*socket_to_node;\n\tunsigned short\t\t*socket_to_pnode;\n\tunsigned short\t\t*pnode_to_socket;\n\tstruct uv_gam_range_s\t*gr_table;\n\tunsigned short\t\tmin_socket;\n\tunsigned short\t\tmin_pnode;\n\tunsigned char\t\tm_val;\n\tunsigned char\t\tn_val;\n\tunsigned char\t\tgr_table_len;\n\tunsigned char\t\tapic_pnode_shift;\n\tunsigned char\t\tgpa_shift;\n\tunsigned char\t\tnasid_shift;\n\tunsigned char\t\tm_shift;\n\tunsigned char\t\tn_lshift;\n\tunsigned int\t\tgnode_extra;\n\tunsigned long\t\tgnode_upper;\n\tunsigned long\t\tlowmem_remap_top;\n\tunsigned long\t\tlowmem_remap_base;\n\tunsigned long\t\tglobal_gru_base;\n\tunsigned long\t\tglobal_gru_shift;\n\tunsigned short\t\tpnode;\n\tunsigned short\t\tpnode_mask;\n\tunsigned short\t\tcoherency_domain_number;\n\tunsigned short\t\tnuma_blade_id;\n\tunsigned short\t\tnr_possible_cpus;\n\tunsigned short\t\tnr_online_cpus;\n\tshort\t\t\tmemory_nid;\n\tunsigned short\t\t*node_to_socket;\n};\n\n \nstruct uv_cpu_info_s {\n\tvoid\t\t\t*p_uv_hub_info;\n\tunsigned char\t\tblade_cpu_id;\n\tvoid\t\t\t*reserved;\n};\nDECLARE_PER_CPU(struct uv_cpu_info_s, __uv_cpu_info);\n\n#define uv_cpu_info\t\tthis_cpu_ptr(&__uv_cpu_info)\n#define uv_cpu_info_per(cpu)\t(&per_cpu(__uv_cpu_info, cpu))\n\n \nextern void **__uv_hub_info_list;\nstatic inline struct uv_hub_info_s *uv_hub_info_list(int node)\n{\n\treturn (struct uv_hub_info_s *)__uv_hub_info_list[node];\n}\n\nstatic inline struct uv_hub_info_s *_uv_hub_info(void)\n{\n\treturn (struct uv_hub_info_s *)uv_cpu_info->p_uv_hub_info;\n}\n#define\tuv_hub_info\t_uv_hub_info()\n\nstatic inline struct uv_hub_info_s *uv_cpu_hub_info(int cpu)\n{\n\treturn (struct uv_hub_info_s *)uv_cpu_info_per(cpu)->p_uv_hub_info;\n}\n\nstatic inline int uv_hub_type(void)\n{\n\treturn uv_hub_info->hub_type;\n}\n\nstatic inline __init void uv_hub_type_set(int uvmask)\n{\n\tuv_hub_info->hub_type = uvmask;\n}\n\n\n \n#define UV2_HUB_REVISION_BASE\t\t3\n#define UV3_HUB_REVISION_BASE\t\t5\n#define UV4_HUB_REVISION_BASE\t\t7\n#define UV4A_HUB_REVISION_BASE\t\t8\t \n#define UV5_HUB_REVISION_BASE\t\t9\n\nstatic inline int is_uv(int uvmask) { return uv_hub_type() & uvmask; }\nstatic inline int is_uv1_hub(void) { return 0; }\nstatic inline int is_uv2_hub(void) { return is_uv(UV2); }\nstatic inline int is_uv3_hub(void) { return is_uv(UV3); }\nstatic inline int is_uv4a_hub(void) { return is_uv(UV4A); }\nstatic inline int is_uv4_hub(void) { return is_uv(UV4); }\nstatic inline int is_uv5_hub(void) { return is_uv(UV5); }\n\n \n\n \nstatic inline int is_uvx_hub(void) { return is_uv(UVX); }\n\n \nstatic inline int is_uvy_hub(void) { return is_uv(UVY); }\n\n \nstatic inline int is_uv_hub(void) { return is_uv(UV_ANY); }\n\nunion uvh_apicid {\n    unsigned long       v;\n    struct uvh_apicid_s {\n        unsigned long   local_apic_mask  : 24;\n        unsigned long   local_apic_shift :  5;\n        unsigned long   unused1          :  3;\n        unsigned long   pnode_mask       : 24;\n        unsigned long   pnode_shift      :  5;\n        unsigned long   unused2          :  3;\n    } s;\n};\n\n \n#define UV_NASID_TO_PNODE(n)\t\t\\\n\t\t(((n) >> uv_hub_info->nasid_shift) & uv_hub_info->pnode_mask)\n#define UV_PNODE_TO_GNODE(p)\t\t((p) |uv_hub_info->gnode_extra)\n#define UV_PNODE_TO_NASID(p)\t\t\\\n\t\t(UV_PNODE_TO_GNODE(p) << uv_hub_info->nasid_shift)\n\n#define UV2_LOCAL_MMR_BASE\t\t0xfa000000UL\n#define UV2_GLOBAL_MMR32_BASE\t\t0xfc000000UL\n#define UV2_LOCAL_MMR_SIZE\t\t(32UL * 1024 * 1024)\n#define UV2_GLOBAL_MMR32_SIZE\t\t(32UL * 1024 * 1024)\n\n#define UV3_LOCAL_MMR_BASE\t\t0xfa000000UL\n#define UV3_GLOBAL_MMR32_BASE\t\t0xfc000000UL\n#define UV3_LOCAL_MMR_SIZE\t\t(32UL * 1024 * 1024)\n#define UV3_GLOBAL_MMR32_SIZE\t\t(32UL * 1024 * 1024)\n\n#define UV4_LOCAL_MMR_BASE\t\t0xfa000000UL\n#define UV4_GLOBAL_MMR32_BASE\t\t0\n#define UV4_LOCAL_MMR_SIZE\t\t(32UL * 1024 * 1024)\n#define UV4_GLOBAL_MMR32_SIZE\t\t0\n\n#define UV5_LOCAL_MMR_BASE\t\t0xfa000000UL\n#define UV5_GLOBAL_MMR32_BASE\t\t0\n#define UV5_LOCAL_MMR_SIZE\t\t(32UL * 1024 * 1024)\n#define UV5_GLOBAL_MMR32_SIZE\t\t0\n\n#define UV_LOCAL_MMR_BASE\t\t(\t\t\t\t\\\n\t\t\t\t\tis_uv(UV2) ? UV2_LOCAL_MMR_BASE : \\\n\t\t\t\t\tis_uv(UV3) ? UV3_LOCAL_MMR_BASE : \\\n\t\t\t\t\tis_uv(UV4) ? UV4_LOCAL_MMR_BASE : \\\n\t\t\t\t\tis_uv(UV5) ? UV5_LOCAL_MMR_BASE : \\\n\t\t\t\t\t0)\n\n#define UV_GLOBAL_MMR32_BASE\t\t(\t\t\t\t\\\n\t\t\t\t\tis_uv(UV2) ? UV2_GLOBAL_MMR32_BASE : \\\n\t\t\t\t\tis_uv(UV3) ? UV3_GLOBAL_MMR32_BASE : \\\n\t\t\t\t\tis_uv(UV4) ? UV4_GLOBAL_MMR32_BASE : \\\n\t\t\t\t\tis_uv(UV5) ? UV5_GLOBAL_MMR32_BASE : \\\n\t\t\t\t\t0)\n\n#define UV_LOCAL_MMR_SIZE\t\t(\t\t\t\t\\\n\t\t\t\t\tis_uv(UV2) ? UV2_LOCAL_MMR_SIZE : \\\n\t\t\t\t\tis_uv(UV3) ? UV3_LOCAL_MMR_SIZE : \\\n\t\t\t\t\tis_uv(UV4) ? UV4_LOCAL_MMR_SIZE : \\\n\t\t\t\t\tis_uv(UV5) ? UV5_LOCAL_MMR_SIZE : \\\n\t\t\t\t\t0)\n\n#define UV_GLOBAL_MMR32_SIZE\t\t(\t\t\t\t\\\n\t\t\t\t\tis_uv(UV2) ? UV2_GLOBAL_MMR32_SIZE : \\\n\t\t\t\t\tis_uv(UV3) ? UV3_GLOBAL_MMR32_SIZE : \\\n\t\t\t\t\tis_uv(UV4) ? UV4_GLOBAL_MMR32_SIZE : \\\n\t\t\t\t\tis_uv(UV5) ? UV5_GLOBAL_MMR32_SIZE : \\\n\t\t\t\t\t0)\n\n#define UV_GLOBAL_MMR64_BASE\t\t(uv_hub_info->global_mmr_base)\n\n#define UV_GLOBAL_GRU_MMR_BASE\t\t0x4000000\n\n#define UV_GLOBAL_MMR32_PNODE_SHIFT\t15\n#define _UV_GLOBAL_MMR64_PNODE_SHIFT\t26\n#define UV_GLOBAL_MMR64_PNODE_SHIFT\t(uv_hub_info->global_mmr_shift)\n\n#define UV_GLOBAL_MMR32_PNODE_BITS(p)\t((p) << (UV_GLOBAL_MMR32_PNODE_SHIFT))\n\n#define UV_GLOBAL_MMR64_PNODE_BITS(p)\t\t\t\t\t\\\n\t(((unsigned long)(p)) << UV_GLOBAL_MMR64_PNODE_SHIFT)\n\n#define UVH_APICID\t\t0x002D0E00L\n#define UV_APIC_PNODE_SHIFT\t6\n\n \n#define LOCAL_BUS_BASE\t\t0x1c00000\n#define LOCAL_BUS_SIZE\t\t(4 * 1024 * 1024)\n\n \n#define SCIR_WINDOW_COUNT\t64\n#define SCIR_LOCAL_MMR_BASE\t(LOCAL_BUS_BASE + \\\n\t\t\t\t LOCAL_BUS_SIZE - \\\n\t\t\t\t SCIR_WINDOW_COUNT)\n\n#define SCIR_CPU_HEARTBEAT\t0x01\t \n#define SCIR_CPU_ACTIVITY\t0x02\t \n#define SCIR_CPU_HB_INTERVAL\t(HZ)\t \n\n \n#define for_each_possible_blade(bid)\t\t\\\n\tfor ((bid) = 0; (bid) < uv_num_possible_blades(); (bid)++)\n\n \n\n \nstatic inline unsigned int uv_gpa_shift(void)\n{\n\treturn uv_hub_info->gpa_shift;\n}\n#define\t_uv_gpa_shift\n\n \nstatic inline struct uv_gam_range_s *uv_gam_range(unsigned long pa)\n{\n\tstruct uv_gam_range_s *gr = uv_hub_info->gr_table;\n\tunsigned long pal = (pa & uv_hub_info->gpa_mask) >> UV_GAM_RANGE_SHFT;\n\tint i, num = uv_hub_info->gr_table_len;\n\n\tif (gr) {\n\t\tfor (i = 0; i < num; i++, gr++) {\n\t\t\tif (pal < gr->limit)\n\t\t\t\treturn gr;\n\t\t}\n\t}\n\tpr_crit(\"UV: GAM Range for 0x%lx not found at %p!\\n\", pa, gr);\n\tBUG();\n}\n\n \nstatic inline unsigned long uv_gam_range_base(unsigned long pa)\n{\n\tstruct uv_gam_range_s *gr = uv_gam_range(pa);\n\tint base = gr->base;\n\n\tif (base < 0)\n\t\treturn 0UL;\n\n\treturn uv_hub_info->gr_table[base].limit;\n}\n\n \nstatic inline unsigned long uv_soc_phys_ram_to_nasid(unsigned long paddr)\n{\n\treturn uv_gam_range(paddr)->nasid;\n}\n#define\t_uv_soc_phys_ram_to_nasid\n\n \nstatic inline unsigned long uv_gpa_nasid(void *v)\n{\n\treturn uv_soc_phys_ram_to_nasid(__pa(v));\n}\n\n \nstatic inline unsigned long uv_soc_phys_ram_to_gpa(unsigned long paddr)\n{\n\tunsigned int m_val = uv_hub_info->m_val;\n\n\tif (paddr < uv_hub_info->lowmem_remap_top)\n\t\tpaddr |= uv_hub_info->lowmem_remap_base;\n\n\tif (m_val) {\n\t\tpaddr |= uv_hub_info->gnode_upper;\n\t\tpaddr = ((paddr << uv_hub_info->m_shift)\n\t\t\t\t\t\t>> uv_hub_info->m_shift) |\n\t\t\t((paddr >> uv_hub_info->m_val)\n\t\t\t\t\t\t<< uv_hub_info->n_lshift);\n\t} else {\n\t\tpaddr |= uv_soc_phys_ram_to_nasid(paddr)\n\t\t\t\t\t\t<< uv_hub_info->gpa_shift;\n\t}\n\treturn paddr;\n}\n\n \nstatic inline unsigned long uv_gpa(void *v)\n{\n\treturn uv_soc_phys_ram_to_gpa(__pa(v));\n}\n\n \nstatic inline int\nuv_gpa_in_mmr_space(unsigned long gpa)\n{\n\treturn (gpa >> 62) == 0x3UL;\n}\n\n \nstatic inline unsigned long uv_gpa_to_soc_phys_ram(unsigned long gpa)\n{\n\tunsigned long paddr;\n\tunsigned long remap_base = uv_hub_info->lowmem_remap_base;\n\tunsigned long remap_top =  uv_hub_info->lowmem_remap_top;\n\tunsigned int m_val = uv_hub_info->m_val;\n\n\tif (m_val)\n\t\tgpa = ((gpa << uv_hub_info->m_shift) >> uv_hub_info->m_shift) |\n\t\t\t((gpa >> uv_hub_info->n_lshift) << uv_hub_info->m_val);\n\n\tpaddr = gpa & uv_hub_info->gpa_mask;\n\tif (paddr >= remap_base && paddr < remap_base + remap_top)\n\t\tpaddr -= remap_base;\n\treturn paddr;\n}\n\n \nstatic inline unsigned long uv_gpa_to_gnode(unsigned long gpa)\n{\n\tunsigned int n_lshift = uv_hub_info->n_lshift;\n\n\tif (n_lshift)\n\t\treturn gpa >> n_lshift;\n\n\treturn uv_gam_range(gpa)->nasid >> 1;\n}\n\n \nstatic inline int uv_gpa_to_pnode(unsigned long gpa)\n{\n\treturn uv_gpa_to_gnode(gpa) & uv_hub_info->pnode_mask;\n}\n\n \nstatic inline unsigned long uv_gpa_to_offset(unsigned long gpa)\n{\n\tunsigned int m_shift = uv_hub_info->m_shift;\n\n\tif (m_shift)\n\t\treturn (gpa << m_shift) >> m_shift;\n\n\treturn (gpa & uv_hub_info->gpa_mask) - uv_gam_range_base(gpa);\n}\n\n \nstatic inline int _uv_socket_to_node(int socket, unsigned short *s2nid)\n{\n\treturn s2nid ? s2nid[socket - uv_hub_info->min_socket] : socket;\n}\n\nstatic inline int uv_socket_to_node(int socket)\n{\n\treturn _uv_socket_to_node(socket, uv_hub_info->socket_to_node);\n}\n\nstatic inline int uv_pnode_to_socket(int pnode)\n{\n\tunsigned short *p2s = uv_hub_info->pnode_to_socket;\n\n\treturn p2s ? p2s[pnode - uv_hub_info->min_pnode] : pnode;\n}\n\n \nstatic inline void *uv_pnode_offset_to_vaddr(int pnode, unsigned long offset)\n{\n\tunsigned int m_val = uv_hub_info->m_val;\n\tunsigned long base;\n\tunsigned short sockid;\n\n\tif (m_val)\n\t\treturn __va(((unsigned long)pnode << m_val) | offset);\n\n\tsockid = uv_pnode_to_socket(pnode);\n\n\t \n\tif (sockid == 0)\n\t\treturn __va((unsigned long)offset);\n\n\tbase = (unsigned long)(uv_hub_info->gr_table[sockid - 1].limit);\n\treturn __va(base << UV_GAM_RANGE_SHFT | offset);\n}\n\n \nstatic inline int uv_apicid_to_pnode(int apicid)\n{\n\tint pnode = apicid >> uv_hub_info->apic_pnode_shift;\n\tunsigned short *s2pn = uv_hub_info->socket_to_pnode;\n\n\treturn s2pn ? s2pn[pnode - uv_hub_info->min_socket] : pnode;\n}\n\n \nstatic inline unsigned long *uv_global_mmr32_address(int pnode, unsigned long offset)\n{\n\treturn __va(UV_GLOBAL_MMR32_BASE |\n\t\t       UV_GLOBAL_MMR32_PNODE_BITS(pnode) | offset);\n}\n\nstatic inline void uv_write_global_mmr32(int pnode, unsigned long offset, unsigned long val)\n{\n\twriteq(val, uv_global_mmr32_address(pnode, offset));\n}\n\nstatic inline unsigned long uv_read_global_mmr32(int pnode, unsigned long offset)\n{\n\treturn readq(uv_global_mmr32_address(pnode, offset));\n}\n\n \nstatic inline volatile void __iomem *uv_global_mmr64_address(int pnode, unsigned long offset)\n{\n\treturn __va(UV_GLOBAL_MMR64_BASE |\n\t\t    UV_GLOBAL_MMR64_PNODE_BITS(pnode) | offset);\n}\n\nstatic inline void uv_write_global_mmr64(int pnode, unsigned long offset, unsigned long val)\n{\n\twriteq(val, uv_global_mmr64_address(pnode, offset));\n}\n\nstatic inline unsigned long uv_read_global_mmr64(int pnode, unsigned long offset)\n{\n\treturn readq(uv_global_mmr64_address(pnode, offset));\n}\n\nstatic inline void uv_write_global_mmr8(int pnode, unsigned long offset, unsigned char val)\n{\n\twriteb(val, uv_global_mmr64_address(pnode, offset));\n}\n\nstatic inline unsigned char uv_read_global_mmr8(int pnode, unsigned long offset)\n{\n\treturn readb(uv_global_mmr64_address(pnode, offset));\n}\n\n \nstatic inline unsigned long *uv_local_mmr_address(unsigned long offset)\n{\n\treturn __va(UV_LOCAL_MMR_BASE | offset);\n}\n\nstatic inline unsigned long uv_read_local_mmr(unsigned long offset)\n{\n\treturn readq(uv_local_mmr_address(offset));\n}\n\nstatic inline void uv_write_local_mmr(unsigned long offset, unsigned long val)\n{\n\twriteq(val, uv_local_mmr_address(offset));\n}\n\nstatic inline unsigned char uv_read_local_mmr8(unsigned long offset)\n{\n\treturn readb(uv_local_mmr_address(offset));\n}\n\nstatic inline void uv_write_local_mmr8(unsigned long offset, unsigned char val)\n{\n\twriteb(val, uv_local_mmr_address(offset));\n}\n\n \nstatic inline int uv_blade_processor_id(void)\n{\n\treturn uv_cpu_info->blade_cpu_id;\n}\n\n \nstatic inline int uv_cpu_blade_processor_id(int cpu)\n{\n\treturn uv_cpu_info_per(cpu)->blade_cpu_id;\n}\n\n \nstatic inline int uv_blade_to_node(int blade)\n{\n\treturn uv_socket_to_node(blade);\n}\n\n \nstatic inline int uv_numa_blade_id(void)\n{\n\treturn uv_hub_info->numa_blade_id;\n}\n\n \nstatic inline int uv_node_to_blade_id(int nid)\n{\n\tunsigned short *n2s = uv_hub_info->node_to_socket;\n\n\treturn n2s ? n2s[nid] : nid;\n}\n\n \nstatic inline int uv_cpu_to_blade_id(int cpu)\n{\n\treturn uv_cpu_hub_info(cpu)->numa_blade_id;\n}\n\n \nstatic inline int uv_blade_to_pnode(int bid)\n{\n\tunsigned short *s2p = uv_hub_info->socket_to_pnode;\n\n\treturn s2p ? s2p[bid] : bid;\n}\n\n \nstatic inline int uv_blade_to_memory_nid(int bid)\n{\n\treturn uv_hub_info_list(uv_blade_to_node(bid))->memory_nid;\n}\n\n \nstatic inline int uv_blade_nr_possible_cpus(int bid)\n{\n\treturn uv_hub_info_list(uv_blade_to_node(bid))->nr_possible_cpus;\n}\n\n \nstatic inline int uv_blade_nr_online_cpus(int bid)\n{\n\treturn uv_hub_info_list(uv_blade_to_node(bid))->nr_online_cpus;\n}\n\n \nstatic inline int uv_cpu_to_pnode(int cpu)\n{\n\treturn uv_cpu_hub_info(cpu)->pnode;\n}\n\n \nstatic inline int uv_node_to_pnode(int nid)\n{\n\treturn uv_hub_info_list(nid)->pnode;\n}\n\n \nextern short uv_possible_blades;\nstatic inline int uv_num_possible_blades(void)\n{\n\treturn uv_possible_blades;\n}\n\n \nextern void uv_nmi_setup(void);\nextern void uv_nmi_setup_hubless(void);\n\n \n#define UVH_BIOS_KERNEL_MMR\t\tUVH_SCRATCH5\n#define UVH_BIOS_KERNEL_MMR_ALIAS\tUVH_SCRATCH5_ALIAS\n#define UVH_BIOS_KERNEL_MMR_ALIAS_2\tUVH_SCRATCH5_ALIAS_2\n\n \n#define UVH_TSC_SYNC_MMR\tUVH_BIOS_KERNEL_MMR\n#define UVH_TSC_SYNC_SHIFT\t10\n#define UVH_TSC_SYNC_SHIFT_UV2K\t16\t \n#define UVH_TSC_SYNC_MASK\t3\t \n#define UVH_TSC_SYNC_VALID\t3\t \n#define UVH_TSC_SYNC_UNKNOWN\t0\t \n\n \n#define UVH_NMI_MMR\t\tUVH_BIOS_KERNEL_MMR\n#define UVH_NMI_MMR_CLEAR\tUVH_BIOS_KERNEL_MMR_ALIAS\n#define UVH_NMI_MMR_SHIFT\t63\n#define UVH_NMI_MMR_TYPE\t\"SCRATCH5\"\n\nstruct uv_hub_nmi_s {\n\traw_spinlock_t\tnmi_lock;\n\tatomic_t\tin_nmi;\t\t \n\tatomic_t\tcpu_owner;\t \n\tatomic_t\tread_mmr_count;\t \n\tatomic_t\tnmi_count;\t \n\tunsigned long\tnmi_value;\t \n\tbool\t\thub_present;\t \n\tbool\t\tpch_owner;\t \n};\n\nstruct uv_cpu_nmi_s {\n\tstruct uv_hub_nmi_s\t*hub;\n\tint\t\t\tstate;\n\tint\t\t\tpinging;\n\tint\t\t\tqueries;\n\tint\t\t\tpings;\n};\n\nDECLARE_PER_CPU(struct uv_cpu_nmi_s, uv_cpu_nmi);\n\n#define uv_hub_nmi\t\t\tthis_cpu_read(uv_cpu_nmi.hub)\n#define uv_cpu_nmi_per(cpu)\t\t(per_cpu(uv_cpu_nmi, cpu))\n#define uv_hub_nmi_per(cpu)\t\t(uv_cpu_nmi_per(cpu).hub)\n\n \n#define\tUV_NMI_STATE_OUT\t\t0\n#define\tUV_NMI_STATE_IN\t\t\t1\n#define\tUV_NMI_STATE_DUMP\t\t2\n#define\tUV_NMI_STATE_DUMP_DONE\t\t3\n\n \nstatic inline int uv_get_min_hub_revision_id(void)\n{\n\treturn uv_hub_info->hub_revision;\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}