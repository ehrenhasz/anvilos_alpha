{
  "module_name": "irq_stack.h",
  "hash_id": "b4e11022cda1ef1886ee9889926865d431a9b5676a4e5b260d8cdb7b0397f8d0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/irq_stack.h",
  "human_readable_source": " \n#ifndef _ASM_X86_IRQ_STACK_H\n#define _ASM_X86_IRQ_STACK_H\n\n#include <linux/ptrace.h>\n#include <linux/objtool.h>\n\n#include <asm/processor.h>\n\n#ifdef CONFIG_X86_64\n\n \n#define call_on_stack(stack, func, asm_call, argconstr...)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tregister void *tos asm(\"r11\");\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttos = ((void *)(stack));\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tasm_inline volatile(\t\t\t\t\t\t\\\n\t\"movq\t%%rsp, (%[tos])\t\t\t\t\\n\"\t\t\\\n\t\"movq\t%[tos], %%rsp\t\t\t\t\\n\"\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tasm_call\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\"popq\t%%rsp\t\t\t\t\t\\n\"\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t: \"+r\" (tos), ASM_CALL_CONSTRAINT\t\t\t\t\\\n\t: [__func] \"i\" (func), [tos] \"r\" (tos) argconstr\t\t\\\n\t: \"cc\", \"rax\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\", \"r10\",\t\\\n\t  \"memory\"\t\t\t\t\t\t\t\\\n\t);\t\t\t\t\t\t\t\t\\\n}\n\n#define ASM_CALL_ARG0\t\t\t\t\t\t\t\\\n\t\"call %P[__func]\t\t\t\t\\n\"\t\t\\\n\tASM_REACHABLE\n\n#define ASM_CALL_ARG1\t\t\t\t\t\t\t\\\n\t\"movq\t%[arg1], %%rdi\t\t\t\t\\n\"\t\t\\\n\tASM_CALL_ARG0\n\n#define ASM_CALL_ARG2\t\t\t\t\t\t\t\\\n\t\"movq\t%[arg2], %%rsi\t\t\t\t\\n\"\t\t\\\n\tASM_CALL_ARG1\n\n#define ASM_CALL_ARG3\t\t\t\t\t\t\t\\\n\t\"movq\t%[arg3], %%rdx\t\t\t\t\\n\"\t\t\\\n\tASM_CALL_ARG2\n\n#define call_on_irqstack(func, asm_call, argconstr...)\t\t\t\\\n\tcall_on_stack(__this_cpu_read(pcpu_hot.hardirq_stack_ptr),\t\\\n\t\t      func, asm_call, argconstr)\n\n \n#define assert_function_type(func, proto)\t\t\t\t\\\n\tstatic_assert(__builtin_types_compatible_p(typeof(&func), proto))\n\n#define assert_arg_type(arg, proto)\t\t\t\t\t\\\n\tstatic_assert(__builtin_types_compatible_p(typeof(arg), proto))\n\n \n#define call_on_irqstack_cond(func, regs, asm_call, constr, c_args...)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tif (user_mode(regs) || __this_cpu_read(pcpu_hot.hardirq_stack_inuse)) { \\\n\t\tirq_enter_rcu();\t\t\t\t\t\\\n\t\tfunc(c_args);\t\t\t\t\t\t\\\n\t\tirq_exit_rcu();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\t__this_cpu_write(pcpu_hot.hardirq_stack_inuse, true);\t\\\n\t\tcall_on_irqstack(func, asm_call, constr);\t\t\\\n\t\t__this_cpu_write(pcpu_hot.hardirq_stack_inuse, false);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n \n#define ASM_CALL_SYSVEC\t\t\t\t\t\t\t\\\n\t\"call irq_enter_rcu\t\t\t\t\\n\"\t\t\\\n\tASM_CALL_ARG1\t\t\t\t\t\t\t\\\n\t\"call irq_exit_rcu\t\t\t\t\\n\"\n\n#define SYSVEC_CONSTRAINTS\t, [arg1] \"r\" (regs)\n\n#define run_sysvec_on_irqstack_cond(func, regs)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tassert_function_type(func, void (*)(struct pt_regs *));\t\t\\\n\tassert_arg_type(regs, struct pt_regs *);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcall_on_irqstack_cond(func, regs, ASM_CALL_SYSVEC,\t\t\\\n\t\t\t      SYSVEC_CONSTRAINTS, regs);\t\t\\\n}\n\n \n#define ASM_CALL_IRQ\t\t\t\t\t\t\t\\\n\t\"call irq_enter_rcu\t\t\t\t\\n\"\t\t\\\n\tASM_CALL_ARG2\t\t\t\t\t\t\t\\\n\t\"call irq_exit_rcu\t\t\t\t\\n\"\n\n#define IRQ_CONSTRAINTS\t, [arg1] \"r\" (regs), [arg2] \"r\" ((unsigned long)vector)\n\n#define run_irq_on_irqstack_cond(func, regs, vector)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tassert_function_type(func, void (*)(struct pt_regs *, u32));\t\\\n\tassert_arg_type(regs, struct pt_regs *);\t\t\t\\\n\tassert_arg_type(vector, u32);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcall_on_irqstack_cond(func, regs, ASM_CALL_IRQ,\t\t\t\\\n\t\t\t      IRQ_CONSTRAINTS, regs, vector);\t\t\\\n}\n\n#ifdef CONFIG_SOFTIRQ_ON_OWN_STACK\n \n#define do_softirq_own_stack()\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_write(pcpu_hot.hardirq_stack_inuse, true);\t\t\\\n\tcall_on_irqstack(__do_softirq, ASM_CALL_ARG0);\t\t\t\\\n\t__this_cpu_write(pcpu_hot.hardirq_stack_inuse, false);\t\t\\\n}\n\n#endif\n\n#else  \n \n#define run_sysvec_on_irqstack_cond(func, regs)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tirq_enter_rcu();\t\t\t\t\t\t\\\n\tfunc(regs);\t\t\t\t\t\t\t\\\n\tirq_exit_rcu();\t\t\t\t\t\t\t\\\n}\n\n \n#define run_irq_on_irqstack_cond(func, regs, vector)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tirq_enter_rcu();\t\t\t\t\t\t\\\n\tfunc(regs, vector);\t\t\t\t\t\t\\\n\tirq_exit_rcu();\t\t\t\t\t\t\t\\\n}\n\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}