{
  "module_name": "ptrace.h",
  "hash_id": "65256744bb097d161d42d85805d1a3e31b4abe5abeef6a051f3c1fc5af419c3a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/ptrace.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PTRACE_H\n#define _ASM_X86_PTRACE_H\n\n#include <asm/segment.h>\n#include <asm/page_types.h>\n#include <uapi/asm/ptrace.h>\n\n#ifndef __ASSEMBLY__\n#ifdef __i386__\n\nstruct pt_regs {\n\t \n\tunsigned long bx;\n\tunsigned long cx;\n\tunsigned long dx;\n\tunsigned long si;\n\tunsigned long di;\n\tunsigned long bp;\n\tunsigned long ax;\n\tunsigned short ds;\n\tunsigned short __dsh;\n\tunsigned short es;\n\tunsigned short __esh;\n\tunsigned short fs;\n\tunsigned short __fsh;\n\t \n\tunsigned short gs;\n\tunsigned short __gsh;\n\t \n\tunsigned long orig_ax;\n\tunsigned long ip;\n\tunsigned short cs;\n\tunsigned short __csh;\n\tunsigned long flags;\n\tunsigned long sp;\n\tunsigned short ss;\n\tunsigned short __ssh;\n};\n\n#else  \n\nstruct pt_regs {\n \n\tunsigned long r15;\n\tunsigned long r14;\n\tunsigned long r13;\n\tunsigned long r12;\n\tunsigned long bp;\n\tunsigned long bx;\n \n\tunsigned long r11;\n\tunsigned long r10;\n\tunsigned long r9;\n\tunsigned long r8;\n\tunsigned long ax;\n\tunsigned long cx;\n\tunsigned long dx;\n\tunsigned long si;\n\tunsigned long di;\n \n\tunsigned long orig_ax;\n \n\tunsigned long ip;\n\tunsigned long cs;\n\tunsigned long flags;\n\tunsigned long sp;\n\tunsigned long ss;\n \n};\n\n#endif  \n\n#ifdef CONFIG_PARAVIRT\n#include <asm/paravirt_types.h>\n#endif\n\n#include <asm/proto.h>\n\nstruct cpuinfo_x86;\nstruct task_struct;\n\nextern unsigned long profile_pc(struct pt_regs *regs);\n\nextern unsigned long\nconvert_ip_to_linear(struct task_struct *child, struct pt_regs *regs);\nextern void send_sigtrap(struct pt_regs *regs, int error_code, int si_code);\n\n\nstatic inline unsigned long regs_return_value(struct pt_regs *regs)\n{\n\treturn regs->ax;\n}\n\nstatic inline void regs_set_return_value(struct pt_regs *regs, unsigned long rc)\n{\n\tregs->ax = rc;\n}\n\n \nstatic __always_inline int user_mode(struct pt_regs *regs)\n{\n#ifdef CONFIG_X86_32\n\treturn ((regs->cs & SEGMENT_RPL_MASK) | (regs->flags & X86_VM_MASK)) >= USER_RPL;\n#else\n\treturn !!(regs->cs & 3);\n#endif\n}\n\nstatic __always_inline int v8086_mode(struct pt_regs *regs)\n{\n#ifdef CONFIG_X86_32\n\treturn (regs->flags & X86_VM_MASK);\n#else\n\treturn 0;\t \n#endif\n}\n\nstatic inline bool user_64bit_mode(struct pt_regs *regs)\n{\n#ifdef CONFIG_X86_64\n#ifndef CONFIG_PARAVIRT_XXL\n\t \n\treturn regs->cs == __USER_CS;\n#else\n\t \n\treturn regs->cs == __USER_CS || regs->cs == pv_info.extra_user_64bit_cs;\n#endif\n#else  \n\treturn false;\n#endif\n}\n\n \nstatic inline bool any_64bit_mode(struct pt_regs *regs)\n{\n#ifdef CONFIG_X86_64\n\treturn !user_mode(regs) || user_64bit_mode(regs);\n#else\n\treturn false;\n#endif\n}\n\n#ifdef CONFIG_X86_64\n#define current_user_stack_pointer()\tcurrent_pt_regs()->sp\n#define compat_user_stack_pointer()\tcurrent_pt_regs()->sp\n\nstatic __always_inline bool ip_within_syscall_gap(struct pt_regs *regs)\n{\n\tbool ret = (regs->ip >= (unsigned long)entry_SYSCALL_64 &&\n\t\t    regs->ip <  (unsigned long)entry_SYSCALL_64_safe_stack);\n\n\tret = ret || (regs->ip >= (unsigned long)entry_SYSRETQ_unsafe_stack &&\n\t\t      regs->ip <  (unsigned long)entry_SYSRETQ_end);\n#ifdef CONFIG_IA32_EMULATION\n\tret = ret || (regs->ip >= (unsigned long)entry_SYSCALL_compat &&\n\t\t      regs->ip <  (unsigned long)entry_SYSCALL_compat_safe_stack);\n\tret = ret || (regs->ip >= (unsigned long)entry_SYSRETL_compat_unsafe_stack &&\n\t\t      regs->ip <  (unsigned long)entry_SYSRETL_compat_end);\n#endif\n\n\treturn ret;\n}\n#endif\n\nstatic inline unsigned long kernel_stack_pointer(struct pt_regs *regs)\n{\n\treturn regs->sp;\n}\n\nstatic inline unsigned long instruction_pointer(struct pt_regs *regs)\n{\n\treturn regs->ip;\n}\n\nstatic inline void instruction_pointer_set(struct pt_regs *regs,\n\t\tunsigned long val)\n{\n\tregs->ip = val;\n}\n\nstatic inline unsigned long frame_pointer(struct pt_regs *regs)\n{\n\treturn regs->bp;\n}\n\nstatic inline unsigned long user_stack_pointer(struct pt_regs *regs)\n{\n\treturn regs->sp;\n}\n\nstatic inline void user_stack_pointer_set(struct pt_regs *regs,\n\t\tunsigned long val)\n{\n\tregs->sp = val;\n}\n\nstatic __always_inline bool regs_irqs_disabled(struct pt_regs *regs)\n{\n\treturn !(regs->flags & X86_EFLAGS_IF);\n}\n\n \nextern int regs_query_register_offset(const char *name);\nextern const char *regs_query_register_name(unsigned int offset);\n#define MAX_REG_OFFSET (offsetof(struct pt_regs, ss))\n\n \nstatic inline unsigned long regs_get_register(struct pt_regs *regs,\n\t\t\t\t\t      unsigned int offset)\n{\n\tif (unlikely(offset > MAX_REG_OFFSET))\n\t\treturn 0;\n#ifdef CONFIG_X86_32\n\t \n\tif (offset == offsetof(struct pt_regs, cs) ||\n\t    offset == offsetof(struct pt_regs, ss) ||\n\t    offset == offsetof(struct pt_regs, ds) ||\n\t    offset == offsetof(struct pt_regs, es) ||\n\t    offset == offsetof(struct pt_regs, fs) ||\n\t    offset == offsetof(struct pt_regs, gs)) {\n\t\treturn *(u16 *)((unsigned long)regs + offset);\n\n\t}\n#endif\n\treturn *(unsigned long *)((unsigned long)regs + offset);\n}\n\n \nstatic inline int regs_within_kernel_stack(struct pt_regs *regs,\n\t\t\t\t\t   unsigned long addr)\n{\n\treturn ((addr & ~(THREAD_SIZE - 1)) == (regs->sp & ~(THREAD_SIZE - 1)));\n}\n\n \nstatic inline unsigned long *regs_get_kernel_stack_nth_addr(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long *addr = (unsigned long *)regs->sp;\n\n\taddr += n;\n\tif (regs_within_kernel_stack(regs, (unsigned long)addr))\n\t\treturn addr;\n\telse\n\t\treturn NULL;\n}\n\n \nextern long copy_from_kernel_nofault(void *dst, const void *src, size_t size);\n\n \nstatic inline unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,\n\t\t\t\t\t\t      unsigned int n)\n{\n\tunsigned long *addr;\n\tunsigned long val;\n\tlong ret;\n\n\taddr = regs_get_kernel_stack_nth_addr(regs, n);\n\tif (addr) {\n\t\tret = copy_from_kernel_nofault(&val, addr, sizeof(val));\n\t\tif (!ret)\n\t\t\treturn val;\n\t}\n\treturn 0;\n}\n\n \nstatic inline unsigned long regs_get_kernel_argument(struct pt_regs *regs,\n\t\t\t\t\t\t     unsigned int n)\n{\n\tstatic const unsigned int argument_offs[] = {\n#ifdef __i386__\n\t\toffsetof(struct pt_regs, ax),\n\t\toffsetof(struct pt_regs, dx),\n\t\toffsetof(struct pt_regs, cx),\n#define NR_REG_ARGUMENTS 3\n#else\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, dx),\n\t\toffsetof(struct pt_regs, cx),\n\t\toffsetof(struct pt_regs, r8),\n\t\toffsetof(struct pt_regs, r9),\n#define NR_REG_ARGUMENTS 6\n#endif\n\t};\n\n\tif (n >= NR_REG_ARGUMENTS) {\n\t\tn -= NR_REG_ARGUMENTS - 1;\n\t\treturn regs_get_kernel_stack_nth(regs, n);\n\t} else\n\t\treturn regs_get_register(regs, argument_offs[n]);\n}\n\n#define arch_has_single_step()\t(1)\n#ifdef CONFIG_X86_DEBUGCTLMSR\n#define arch_has_block_step()\t(1)\n#else\n#define arch_has_block_step()\t(boot_cpu_data.x86 >= 6)\n#endif\n\n#define ARCH_HAS_USER_SINGLE_STEP_REPORT\n\nstruct user_desc;\nextern int do_get_thread_area(struct task_struct *p, int idx,\n\t\t\t      struct user_desc __user *info);\nextern int do_set_thread_area(struct task_struct *p, int idx,\n\t\t\t      struct user_desc __user *info, int can_allocate);\n\n#ifdef CONFIG_X86_64\n# define do_set_thread_area_64(p, s, t)\tdo_arch_prctl_64(p, s, t)\n#else\n# define do_set_thread_area_64(p, s, t)\t(0)\n#endif\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}