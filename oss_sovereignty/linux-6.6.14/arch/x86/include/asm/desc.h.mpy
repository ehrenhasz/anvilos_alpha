{
  "module_name": "desc.h",
  "hash_id": "45d1ba77813fdfb1efcb8fb6b83910ee9ca93d29bf3c3d5888357ed80b9cf484",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/desc.h",
  "human_readable_source": " \n#ifndef _ASM_X86_DESC_H\n#define _ASM_X86_DESC_H\n\n#include <asm/desc_defs.h>\n#include <asm/ldt.h>\n#include <asm/mmu.h>\n#include <asm/fixmap.h>\n#include <asm/irq_vectors.h>\n#include <asm/cpu_entry_area.h>\n\n#include <linux/debug_locks.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n\nstatic inline void fill_ldt(struct desc_struct *desc, const struct user_desc *info)\n{\n\tdesc->limit0\t\t= info->limit & 0x0ffff;\n\n\tdesc->base0\t\t= (info->base_addr & 0x0000ffff);\n\tdesc->base1\t\t= (info->base_addr & 0x00ff0000) >> 16;\n\n\tdesc->type\t\t= (info->read_exec_only ^ 1) << 1;\n\tdesc->type\t       |= info->contents << 2;\n\t \n\tdesc->type\t       |= 1;\n\n\tdesc->s\t\t\t= 1;\n\tdesc->dpl\t\t= 0x3;\n\tdesc->p\t\t\t= info->seg_not_present ^ 1;\n\tdesc->limit1\t\t= (info->limit & 0xf0000) >> 16;\n\tdesc->avl\t\t= info->useable;\n\tdesc->d\t\t\t= info->seg_32bit;\n\tdesc->g\t\t\t= info->limit_in_pages;\n\n\tdesc->base2\t\t= (info->base_addr & 0xff000000) >> 24;\n\t \n\tdesc->l\t\t\t= 0;\n}\n\nstruct gdt_page {\n\tstruct desc_struct gdt[GDT_ENTRIES];\n} __attribute__((aligned(PAGE_SIZE)));\n\nDECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);\n\n \nstatic inline struct desc_struct *get_cpu_gdt_rw(unsigned int cpu)\n{\n\treturn per_cpu(gdt_page, cpu).gdt;\n}\n\n \nstatic inline struct desc_struct *get_current_gdt_rw(void)\n{\n\treturn this_cpu_ptr(&gdt_page)->gdt;\n}\n\n \nstatic inline struct desc_struct *get_cpu_gdt_ro(int cpu)\n{\n\treturn (struct desc_struct *)&get_cpu_entry_area(cpu)->gdt;\n}\n\n \nstatic inline struct desc_struct *get_current_gdt_ro(void)\n{\n\treturn get_cpu_gdt_ro(smp_processor_id());\n}\n\n \nstatic inline phys_addr_t get_cpu_gdt_paddr(unsigned int cpu)\n{\n\treturn per_cpu_ptr_to_phys(get_cpu_gdt_rw(cpu));\n}\n\nstatic inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,\n\t\t\t     unsigned dpl, unsigned ist, unsigned seg)\n{\n\tgate->offset_low\t= (u16) func;\n\tgate->bits.p\t\t= 1;\n\tgate->bits.dpl\t\t= dpl;\n\tgate->bits.zero\t\t= 0;\n\tgate->bits.type\t\t= type;\n\tgate->offset_middle\t= (u16) (func >> 16);\n#ifdef CONFIG_X86_64\n\tgate->segment\t\t= __KERNEL_CS;\n\tgate->bits.ist\t\t= ist;\n\tgate->reserved\t\t= 0;\n\tgate->offset_high\t= (u32) (func >> 32);\n#else\n\tgate->segment\t\t= seg;\n\tgate->bits.ist\t\t= 0;\n#endif\n}\n\nstatic inline int desc_empty(const void *ptr)\n{\n\tconst u32 *desc = ptr;\n\n\treturn !(desc[0] | desc[1]);\n}\n\n#ifdef CONFIG_PARAVIRT_XXL\n#include <asm/paravirt.h>\n#else\n#define load_TR_desc()\t\t\t\tnative_load_tr_desc()\n#define load_gdt(dtr)\t\t\t\tnative_load_gdt(dtr)\n#define load_idt(dtr)\t\t\t\tnative_load_idt(dtr)\n#define load_tr(tr)\t\t\t\tasm volatile(\"ltr %0\"::\"m\" (tr))\n#define load_ldt(ldt)\t\t\t\tasm volatile(\"lldt %0\"::\"m\" (ldt))\n\n#define store_gdt(dtr)\t\t\t\tnative_store_gdt(dtr)\n#define store_tr(tr)\t\t\t\t(tr = native_store_tr())\n\n#define load_TLS(t, cpu)\t\t\tnative_load_tls(t, cpu)\n#define set_ldt\t\t\t\t\tnative_set_ldt\n\n#define write_ldt_entry(dt, entry, desc)\tnative_write_ldt_entry(dt, entry, desc)\n#define write_gdt_entry(dt, entry, desc, type)\tnative_write_gdt_entry(dt, entry, desc, type)\n#define write_idt_entry(dt, entry, g)\t\tnative_write_idt_entry(dt, entry, g)\n\nstatic inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)\n{\n}\n\nstatic inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)\n{\n}\n#endif\t \n\n#define store_ldt(ldt) asm(\"sldt %0\" : \"=m\"(ldt))\n\nstatic inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)\n{\n\tmemcpy(&idt[entry], gate, sizeof(*gate));\n}\n\nstatic inline void native_write_ldt_entry(struct desc_struct *ldt, int entry, const void *desc)\n{\n\tmemcpy(&ldt[entry], desc, 8);\n}\n\nstatic inline void\nnative_write_gdt_entry(struct desc_struct *gdt, int entry, const void *desc, int type)\n{\n\tunsigned int size;\n\n\tswitch (type) {\n\tcase DESC_TSS:\tsize = sizeof(tss_desc);\tbreak;\n\tcase DESC_LDT:\tsize = sizeof(ldt_desc);\tbreak;\n\tdefault:\tsize = sizeof(*gdt);\t\tbreak;\n\t}\n\n\tmemcpy(&gdt[entry], desc, size);\n}\n\nstatic inline void set_tssldt_descriptor(void *d, unsigned long addr,\n\t\t\t\t\t unsigned type, unsigned size)\n{\n\tstruct ldttss_desc *desc = d;\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->limit0\t\t= (u16) size;\n\tdesc->base0\t\t= (u16) addr;\n\tdesc->base1\t\t= (addr >> 16) & 0xFF;\n\tdesc->type\t\t= type;\n\tdesc->p\t\t\t= 1;\n\tdesc->limit1\t\t= (size >> 16) & 0xF;\n\tdesc->base2\t\t= (addr >> 24) & 0xFF;\n#ifdef CONFIG_X86_64\n\tdesc->base3\t\t= (u32) (addr >> 32);\n#endif\n}\n\nstatic inline void __set_tss_desc(unsigned cpu, unsigned int entry, struct x86_hw_tss *addr)\n{\n\tstruct desc_struct *d = get_cpu_gdt_rw(cpu);\n\ttss_desc tss;\n\n\tset_tssldt_descriptor(&tss, (unsigned long)addr, DESC_TSS,\n\t\t\t      __KERNEL_TSS_LIMIT);\n\twrite_gdt_entry(d, entry, &tss, DESC_TSS);\n}\n\n#define set_tss_desc(cpu, addr) __set_tss_desc(cpu, GDT_ENTRY_TSS, addr)\n\nstatic inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr, DESC_LDT,\n\t\t\t\t      entries * LDT_ENTRY_SIZE - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_rw(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}\n\nstatic inline void native_load_gdt(const struct desc_ptr *dtr)\n{\n\tasm volatile(\"lgdt %0\"::\"m\" (*dtr));\n}\n\nstatic __always_inline void native_load_idt(const struct desc_ptr *dtr)\n{\n\tasm volatile(\"lidt %0\"::\"m\" (*dtr));\n}\n\nstatic inline void native_store_gdt(struct desc_ptr *dtr)\n{\n\tasm volatile(\"sgdt %0\":\"=m\" (*dtr));\n}\n\nstatic inline void store_idt(struct desc_ptr *dtr)\n{\n\tasm volatile(\"sidt %0\":\"=m\" (*dtr));\n}\n\nstatic inline void native_gdt_invalidate(void)\n{\n\tconst struct desc_ptr invalid_gdt = {\n\t\t.address = 0,\n\t\t.size = 0\n\t};\n\n\tnative_load_gdt(&invalid_gdt);\n}\n\nstatic inline void native_idt_invalidate(void)\n{\n\tconst struct desc_ptr invalid_idt = {\n\t\t.address = 0,\n\t\t.size = 0\n\t};\n\n\tnative_load_idt(&invalid_idt);\n}\n\n \n#ifdef CONFIG_X86_64\nstatic inline void native_load_tr_desc(void)\n{\n\tstruct desc_ptr gdt;\n\tint cpu = raw_smp_processor_id();\n\tbool restore = 0;\n\tstruct desc_struct *fixmap_gdt;\n\n\tnative_store_gdt(&gdt);\n\tfixmap_gdt = get_cpu_gdt_ro(cpu);\n\n\t \n\tif (gdt.address == (unsigned long)fixmap_gdt) {\n\t\tload_direct_gdt(cpu);\n\t\trestore = 1;\n\t}\n\tasm volatile(\"ltr %w0\"::\"q\" (GDT_ENTRY_TSS*8));\n\tif (restore)\n\t\tload_fixmap_gdt(cpu);\n}\n#else\nstatic inline void native_load_tr_desc(void)\n{\n\tasm volatile(\"ltr %w0\"::\"q\" (GDT_ENTRY_TSS*8));\n}\n#endif\n\nstatic inline unsigned long native_store_tr(void)\n{\n\tunsigned long tr;\n\n\tasm volatile(\"str %0\":\"=r\" (tr));\n\n\treturn tr;\n}\n\nstatic inline void native_load_tls(struct thread_struct *t, unsigned int cpu)\n{\n\tstruct desc_struct *gdt = get_cpu_gdt_rw(cpu);\n\tunsigned int i;\n\n\tfor (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++)\n\t\tgdt[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i];\n}\n\nDECLARE_PER_CPU(bool, __tss_limit_invalid);\n\nstatic inline void force_reload_TR(void)\n{\n\tstruct desc_struct *d = get_current_gdt_rw();\n\ttss_desc tss;\n\n\tmemcpy(&tss, &d[GDT_ENTRY_TSS], sizeof(tss_desc));\n\n\t \n\ttss.type = DESC_TSS;\n\twrite_gdt_entry(d, GDT_ENTRY_TSS, &tss, DESC_TSS);\n\n\tload_TR_desc();\n\tthis_cpu_write(__tss_limit_invalid, false);\n}\n\n \nstatic inline void refresh_tss_limit(void)\n{\n\tDEBUG_LOCKS_WARN_ON(preemptible());\n\n\tif (unlikely(this_cpu_read(__tss_limit_invalid)))\n\t\tforce_reload_TR();\n}\n\n \nstatic inline void invalidate_tss_limit(void)\n{\n\tDEBUG_LOCKS_WARN_ON(preemptible());\n\n\tif (unlikely(test_thread_flag(TIF_IO_BITMAP)))\n\t\tforce_reload_TR();\n\telse\n\t\tthis_cpu_write(__tss_limit_invalid, true);\n}\n\n \n#define LDT_empty(info)\t\t\t\t\t\\\n\t((info)->base_addr\t\t== 0\t&&\t\\\n\t (info)->limit\t\t\t== 0\t&&\t\\\n\t (info)->contents\t\t== 0\t&&\t\\\n\t (info)->read_exec_only\t\t== 1\t&&\t\\\n\t (info)->seg_32bit\t\t== 0\t&&\t\\\n\t (info)->limit_in_pages\t\t== 0\t&&\t\\\n\t (info)->seg_not_present\t== 1\t&&\t\\\n\t (info)->useable\t\t== 0)\n\n \nstatic inline bool LDT_zero(const struct user_desc *info)\n{\n\treturn (info->base_addr\t\t== 0 &&\n\t\tinfo->limit\t\t== 0 &&\n\t\tinfo->contents\t\t== 0 &&\n\t\tinfo->read_exec_only\t== 0 &&\n\t\tinfo->seg_32bit\t\t== 0 &&\n\t\tinfo->limit_in_pages\t== 0 &&\n\t\tinfo->seg_not_present\t== 0 &&\n\t\tinfo->useable\t\t== 0);\n}\n\nstatic inline void clear_LDT(void)\n{\n\tset_ldt(NULL, 0);\n}\n\nstatic inline unsigned long get_desc_base(const struct desc_struct *desc)\n{\n\treturn (unsigned)(desc->base0 | ((desc->base1) << 16) | ((desc->base2) << 24));\n}\n\nstatic inline void set_desc_base(struct desc_struct *desc, unsigned long base)\n{\n\tdesc->base0 = base & 0xffff;\n\tdesc->base1 = (base >> 16) & 0xff;\n\tdesc->base2 = (base >> 24) & 0xff;\n}\n\nstatic inline unsigned long get_desc_limit(const struct desc_struct *desc)\n{\n\treturn desc->limit0 | (desc->limit1 << 16);\n}\n\nstatic inline void set_desc_limit(struct desc_struct *desc, unsigned long limit)\n{\n\tdesc->limit0 = limit & 0xffff;\n\tdesc->limit1 = (limit >> 16) & 0xf;\n}\n\nvoid alloc_intr_gate(unsigned int n, const void *addr);\n\nstatic inline void init_idt_data(struct idt_data *data, unsigned int n,\n\t\t\t\t const void *addr)\n{\n\tBUG_ON(n > 0xFF);\n\n\tmemset(data, 0, sizeof(*data));\n\tdata->vector\t= n;\n\tdata->addr\t= addr;\n\tdata->segment\t= __KERNEL_CS;\n\tdata->bits.type\t= GATE_INTERRUPT;\n\tdata->bits.p\t= 1;\n}\n\nstatic inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)\n{\n\tunsigned long addr = (unsigned long) d->addr;\n\n\tgate->offset_low\t= (u16) addr;\n\tgate->segment\t\t= (u16) d->segment;\n\tgate->bits\t\t= d->bits;\n\tgate->offset_middle\t= (u16) (addr >> 16);\n#ifdef CONFIG_X86_64\n\tgate->offset_high\t= (u32) (addr >> 32);\n\tgate->reserved\t\t= 0;\n#endif\n}\n\nextern unsigned long system_vectors[];\n\nextern void load_current_idt(void);\nextern void idt_setup_early_handler(void);\nextern void idt_setup_early_traps(void);\nextern void idt_setup_traps(void);\nextern void idt_setup_apic_and_irq_gates(void);\nextern bool idt_is_f00f_address(unsigned long address);\n\n#ifdef CONFIG_X86_64\nextern void idt_setup_early_pf(void);\n#else\nstatic inline void idt_setup_early_pf(void) { }\n#endif\n\nextern void idt_invalidate(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}