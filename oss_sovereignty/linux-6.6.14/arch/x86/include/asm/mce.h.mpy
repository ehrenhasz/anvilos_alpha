{
  "module_name": "mce.h",
  "hash_id": "1b965095a8dc92d8056e4fc70f822d1b4e51cfe66541f67e8392611cae48fa30",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/mce.h",
  "human_readable_source": " \n#ifndef _ASM_X86_MCE_H\n#define _ASM_X86_MCE_H\n\n#include <uapi/asm/mce.h>\n\n \n\n \n#define MCG_BANKCNT_MASK\t0xff          \n#define MCG_CTL_P\t\tBIT_ULL(8)    \n#define MCG_EXT_P\t\tBIT_ULL(9)    \n#define MCG_CMCI_P\t\tBIT_ULL(10)   \n#define MCG_EXT_CNT_MASK\t0xff0000      \n#define MCG_EXT_CNT_SHIFT\t16\n#define MCG_EXT_CNT(c)\t\t(((c) & MCG_EXT_CNT_MASK) >> MCG_EXT_CNT_SHIFT)\n#define MCG_SER_P\t\tBIT_ULL(24)   \n#define MCG_ELOG_P\t\tBIT_ULL(26)   \n#define MCG_LMCE_P\t\tBIT_ULL(27)   \n\n \n#define MCG_STATUS_RIPV\t\tBIT_ULL(0)    \n#define MCG_STATUS_EIPV\t\tBIT_ULL(1)    \n#define MCG_STATUS_MCIP\t\tBIT_ULL(2)    \n#define MCG_STATUS_LMCES\tBIT_ULL(3)    \n\n \n#define MCG_EXT_CTL_LMCE_EN\tBIT_ULL(0)  \n\n \n#define MCI_STATUS_VAL\t\tBIT_ULL(63)   \n#define MCI_STATUS_OVER\t\tBIT_ULL(62)   \n#define MCI_STATUS_UC\t\tBIT_ULL(61)   \n#define MCI_STATUS_EN\t\tBIT_ULL(60)   \n#define MCI_STATUS_MISCV\tBIT_ULL(59)   \n#define MCI_STATUS_ADDRV\tBIT_ULL(58)   \n#define MCI_STATUS_PCC\t\tBIT_ULL(57)   \n#define MCI_STATUS_S\t\tBIT_ULL(56)   \n#define MCI_STATUS_AR\t\tBIT_ULL(55)   \n#define MCI_STATUS_CEC_SHIFT\t38            \n#define MCI_STATUS_CEC_MASK\tGENMASK_ULL(52,38)\n#define MCI_STATUS_CEC(c)\t(((c) & MCI_STATUS_CEC_MASK) >> MCI_STATUS_CEC_SHIFT)\n#define MCI_STATUS_MSCOD(m)\t(((m) >> 16) & 0xffff)\n\n \n#define MCI_STATUS_TCC\t\tBIT_ULL(55)   \n#define MCI_STATUS_SYNDV\tBIT_ULL(53)   \n#define MCI_STATUS_DEFERRED\tBIT_ULL(44)   \n#define MCI_STATUS_POISON\tBIT_ULL(43)   \n#define MCI_STATUS_SCRUB\tBIT_ULL(40)   \n\n \n#define MCI_CONFIG_MCAX\t\t0x1\n#define MCI_IPID_MCATYPE\t0xFFFF0000\n#define MCI_IPID_HWID\t\t0xFFF\n\n \n#define MCACOD\t\t  0xefff      \n\n \n#define MCACOD_SCRUB\t0x00C0\t \n#define MCACOD_SCRUBMSK\t0xeff0\t \n#define MCACOD_L3WB\t0x017A\t \n#define MCACOD_DATA\t0x0134\t \n#define MCACOD_INSTR\t0x0150\t \n\n \n#define MCI_MISC_ADDR_LSB(m)\t((m) & 0x3f)\n#define MCI_MISC_ADDR_MODE(m)\t(((m) >> 6) & 7)\n#define  MCI_MISC_ADDR_SEGOFF\t0\t \n#define  MCI_MISC_ADDR_LINEAR\t1\t \n#define  MCI_MISC_ADDR_PHYS\t2\t \n#define  MCI_MISC_ADDR_MEM\t3\t \n#define  MCI_MISC_ADDR_GENERIC\t7\t \n\n \n#define MCI_ADDR_PHYSADDR\tGENMASK_ULL(boot_cpu_data.x86_phys_bits - 1, 0)\n\n \n#define MCI_CTL2_CMCI_EN\t\tBIT_ULL(30)\n#define MCI_CTL2_CMCI_THRESHOLD_MASK\t0x7fffULL\n\n#define MCJ_CTX_MASK\t\t3\n#define MCJ_CTX(flags)\t\t((flags) & MCJ_CTX_MASK)\n#define MCJ_CTX_RANDOM\t\t0     \n#define MCJ_CTX_PROCESS\t\t0x1   \n#define MCJ_CTX_IRQ\t\t0x2   \n#define MCJ_NMI_BROADCAST\t0x4   \n#define MCJ_EXCEPTION\t\t0x8   \n#define MCJ_IRQ_BROADCAST\t0x10  \n\n#define MCE_OVERFLOW 0\t\t \n\n#define MCE_LOG_MIN_LEN 32U\n#define MCE_LOG_SIGNATURE\t\"MACHINECHECK\"\n\n \n#define MSR_AMD64_SMCA_MC0_CTL\t\t0xc0002000\n#define MSR_AMD64_SMCA_MC0_STATUS\t0xc0002001\n#define MSR_AMD64_SMCA_MC0_ADDR\t\t0xc0002002\n#define MSR_AMD64_SMCA_MC0_MISC0\t0xc0002003\n#define MSR_AMD64_SMCA_MC0_CONFIG\t0xc0002004\n#define MSR_AMD64_SMCA_MC0_IPID\t\t0xc0002005\n#define MSR_AMD64_SMCA_MC0_SYND\t\t0xc0002006\n#define MSR_AMD64_SMCA_MC0_DESTAT\t0xc0002008\n#define MSR_AMD64_SMCA_MC0_DEADDR\t0xc0002009\n#define MSR_AMD64_SMCA_MC0_MISC1\t0xc000200a\n#define MSR_AMD64_SMCA_MCx_CTL(x)\t(MSR_AMD64_SMCA_MC0_CTL + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_STATUS(x)\t(MSR_AMD64_SMCA_MC0_STATUS + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_ADDR(x)\t(MSR_AMD64_SMCA_MC0_ADDR + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_MISC(x)\t(MSR_AMD64_SMCA_MC0_MISC0 + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_CONFIG(x)\t(MSR_AMD64_SMCA_MC0_CONFIG + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_IPID(x)\t(MSR_AMD64_SMCA_MC0_IPID + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_SYND(x)\t(MSR_AMD64_SMCA_MC0_SYND + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_DESTAT(x)\t(MSR_AMD64_SMCA_MC0_DESTAT + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_DEADDR(x)\t(MSR_AMD64_SMCA_MC0_DEADDR + 0x10*(x))\n#define MSR_AMD64_SMCA_MCx_MISCy(x, y)\t((MSR_AMD64_SMCA_MC0_MISC1 + y) + (0x10*(x)))\n\n#define XEC(x, mask)\t\t\t(((x) >> 16) & mask)\n\n \n#define\tMCE_HANDLED_CEC\t\tBIT_ULL(0)\n#define\tMCE_HANDLED_UC\t\tBIT_ULL(1)\n#define\tMCE_HANDLED_EXTLOG\tBIT_ULL(2)\n#define\tMCE_HANDLED_NFIT\tBIT_ULL(3)\n#define\tMCE_HANDLED_EDAC\tBIT_ULL(4)\n#define\tMCE_HANDLED_MCELOG\tBIT_ULL(5)\n\n \n#define MCE_IN_KERNEL_RECOV\tBIT_ULL(6)\n\n \n#define MCE_IN_KERNEL_COPYIN\tBIT_ULL(7)\n\n \nstruct mce_log_buffer {\n\tchar signature[12];  \n\tunsigned len;\t     \n\tunsigned next;\n\tunsigned flags;\n\tunsigned recordlen;\t \n\tstruct mce entry[];\n};\n\n \nenum mce_notifier_prios {\n\tMCE_PRIO_LOWEST,\n\tMCE_PRIO_MCELOG,\n\tMCE_PRIO_EDAC,\n\tMCE_PRIO_NFIT,\n\tMCE_PRIO_EXTLOG,\n\tMCE_PRIO_UC,\n\tMCE_PRIO_EARLY,\n\tMCE_PRIO_CEC,\n\tMCE_PRIO_HIGHEST = MCE_PRIO_CEC\n};\n\nstruct notifier_block;\nextern void mce_register_decode_chain(struct notifier_block *nb);\nextern void mce_unregister_decode_chain(struct notifier_block *nb);\n\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nextern int mce_p5_enabled;\n\n#ifdef CONFIG_ARCH_HAS_COPY_MC\nextern void enable_copy_mc_fragile(void);\nunsigned long __must_check copy_mc_fragile(void *dst, const void *src, unsigned cnt);\n#else\nstatic inline void enable_copy_mc_fragile(void)\n{\n}\n#endif\n\nstruct cper_ia_proc_ctx;\n\n#ifdef CONFIG_X86_MCE\nint mcheck_init(void);\nvoid mcheck_cpu_init(struct cpuinfo_x86 *c);\nvoid mcheck_cpu_clear(struct cpuinfo_x86 *c);\nint apei_smca_report_x86_error(struct cper_ia_proc_ctx *ctx_info,\n\t\t\t       u64 lapic_id);\n#else\nstatic inline int mcheck_init(void) { return 0; }\nstatic inline void mcheck_cpu_init(struct cpuinfo_x86 *c) {}\nstatic inline void mcheck_cpu_clear(struct cpuinfo_x86 *c) {}\nstatic inline int apei_smca_report_x86_error(struct cper_ia_proc_ctx *ctx_info,\n\t\t\t\t\t     u64 lapic_id) { return -EINVAL; }\n#endif\n\nvoid mce_setup(struct mce *m);\nvoid mce_log(struct mce *m);\nDECLARE_PER_CPU(struct device *, mce_device);\n\n \n#define MAX_NR_BANKS 64\n\n#ifdef CONFIG_X86_MCE_INTEL\nvoid mce_intel_feature_init(struct cpuinfo_x86 *c);\nvoid mce_intel_feature_clear(struct cpuinfo_x86 *c);\nvoid cmci_clear(void);\nvoid cmci_reenable(void);\nvoid cmci_rediscover(void);\nvoid cmci_recheck(void);\n#else\nstatic inline void mce_intel_feature_init(struct cpuinfo_x86 *c) { }\nstatic inline void mce_intel_feature_clear(struct cpuinfo_x86 *c) { }\nstatic inline void cmci_clear(void) {}\nstatic inline void cmci_reenable(void) {}\nstatic inline void cmci_rediscover(void) {}\nstatic inline void cmci_recheck(void) {}\n#endif\n\nint mce_available(struct cpuinfo_x86 *c);\nbool mce_is_memory_error(struct mce *m);\nbool mce_is_correctable(struct mce *m);\nint mce_usable_address(struct mce *m);\n\nDECLARE_PER_CPU(unsigned, mce_exception_count);\nDECLARE_PER_CPU(unsigned, mce_poll_count);\n\ntypedef DECLARE_BITMAP(mce_banks_t, MAX_NR_BANKS);\nDECLARE_PER_CPU(mce_banks_t, mce_poll_banks);\n\nenum mcp_flags {\n\tMCP_TIMESTAMP\t= BIT(0),\t \n\tMCP_UC\t\t= BIT(1),\t \n\tMCP_DONTLOG\t= BIT(2),\t \n\tMCP_QUEUE_LOG\t= BIT(3),\t \n};\nbool machine_check_poll(enum mcp_flags flags, mce_banks_t *b);\n\nint mce_notify_irq(void);\n\nDECLARE_PER_CPU(struct mce, injectm);\n\n \nextern void mce_disable_bank(int bank);\n\n \nvoid do_machine_check(struct pt_regs *pt_regs);\n\n \nextern void (*mce_threshold_vector)(void);\n\n \nextern void (*deferred_error_int_vector)(void);\n\n \n\nstruct cper_sec_mem_err;\nextern void apei_mce_report_mem_error(int corrected,\n\t\t\t\t      struct cper_sec_mem_err *mem_err);\n\n \n#ifdef CONFIG_X86_MCE_AMD\n\n \nenum smca_bank_types {\n\tSMCA_LS = 0,\t \n\tSMCA_LS_V2,\n\tSMCA_IF,\t \n\tSMCA_L2_CACHE,\t \n\tSMCA_DE,\t \n\tSMCA_RESERVED,\t \n\tSMCA_EX,\t \n\tSMCA_FP,\t \n\tSMCA_L3_CACHE,\t \n\tSMCA_CS,\t \n\tSMCA_CS_V2,\n\tSMCA_PIE,\t \n\tSMCA_UMC,\t \n\tSMCA_UMC_V2,\n\tSMCA_PB,\t \n\tSMCA_PSP,\t \n\tSMCA_PSP_V2,\n\tSMCA_SMU,\t \n\tSMCA_SMU_V2,\n\tSMCA_MP5,\t \n\tSMCA_MPDMA,\t \n\tSMCA_NBIO,\t \n\tSMCA_PCIE,\t \n\tSMCA_PCIE_V2,\n\tSMCA_XGMI_PCS,\t \n\tSMCA_NBIF,\t \n\tSMCA_SHUB,\t \n\tSMCA_SATA,\t \n\tSMCA_USB,\t \n\tSMCA_GMI_PCS,\t \n\tSMCA_XGMI_PHY,\t \n\tSMCA_WAFL_PHY,\t \n\tSMCA_GMI_PHY,\t \n\tN_SMCA_BANK_TYPES\n};\n\nextern const char *smca_get_long_name(enum smca_bank_types t);\nextern bool amd_mce_is_memory_error(struct mce *m);\n\nextern int mce_threshold_create_device(unsigned int cpu);\nextern int mce_threshold_remove_device(unsigned int cpu);\n\nvoid mce_amd_feature_init(struct cpuinfo_x86 *c);\nenum smca_bank_types smca_get_bank_type(unsigned int cpu, unsigned int bank);\n#else\n\nstatic inline int mce_threshold_create_device(unsigned int cpu)\t\t{ return 0; };\nstatic inline int mce_threshold_remove_device(unsigned int cpu)\t\t{ return 0; };\nstatic inline bool amd_mce_is_memory_error(struct mce *m)\t\t{ return false; };\nstatic inline void mce_amd_feature_init(struct cpuinfo_x86 *c)\t\t{ }\n#endif\n\nstatic inline void mce_hygon_feature_init(struct cpuinfo_x86 *c)\t{ return mce_amd_feature_init(c); }\n\nunsigned long copy_mc_fragile_handle_tail(char *to, char *from, unsigned len);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}