{
  "module_name": "gettimeofday.h",
  "hash_id": "d5e1a83548568b90501c431141f462da8ff2080f69583a78e7f634002ded262a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/vdso/gettimeofday.h",
  "human_readable_source": " \n \n#ifndef __ASM_VDSO_GETTIMEOFDAY_H\n#define __ASM_VDSO_GETTIMEOFDAY_H\n\n#ifndef __ASSEMBLY__\n\n#include <uapi/linux/time.h>\n#include <asm/vgtod.h>\n#include <asm/vvar.h>\n#include <asm/unistd.h>\n#include <asm/msr.h>\n#include <asm/pvclock.h>\n#include <clocksource/hyperv_timer.h>\n\n#define __vdso_data (VVAR(_vdso_data))\n#define __timens_vdso_data (TIMENS(_vdso_data))\n\n#define VDSO_HAS_TIME 1\n\n#define VDSO_HAS_CLOCK_GETRES 1\n\n \n\n#ifdef CONFIG_PARAVIRT_CLOCK\n \nextern struct pvclock_vsyscall_time_info pvclock_page\n\t__attribute__((visibility(\"hidden\")));\n#endif\n\n#ifdef CONFIG_HYPERV_TIMER\nextern struct ms_hyperv_tsc_page hvclock_page\n\t__attribute__((visibility(\"hidden\")));\n#endif\n\n#ifdef CONFIG_TIME_NS\nstatic __always_inline\nconst struct vdso_data *__arch_get_timens_vdso_data(const struct vdso_data *vd)\n{\n\treturn __timens_vdso_data;\n}\n#endif\n\n#ifndef BUILD_VDSO32\n\nstatic __always_inline\nlong clock_gettime_fallback(clockid_t _clkid, struct __kernel_timespec *_ts)\n{\n\tlong ret;\n\n\tasm (\"syscall\" : \"=a\" (ret), \"=m\" (*_ts) :\n\t     \"0\" (__NR_clock_gettime), \"D\" (_clkid), \"S\" (_ts) :\n\t     \"rcx\", \"r11\");\n\n\treturn ret;\n}\n\nstatic __always_inline\nlong gettimeofday_fallback(struct __kernel_old_timeval *_tv,\n\t\t\t   struct timezone *_tz)\n{\n\tlong ret;\n\n\tasm(\"syscall\" : \"=a\" (ret) :\n\t    \"0\" (__NR_gettimeofday), \"D\" (_tv), \"S\" (_tz) : \"memory\");\n\n\treturn ret;\n}\n\nstatic __always_inline\nlong clock_getres_fallback(clockid_t _clkid, struct __kernel_timespec *_ts)\n{\n\tlong ret;\n\n\tasm (\"syscall\" : \"=a\" (ret), \"=m\" (*_ts) :\n\t     \"0\" (__NR_clock_getres), \"D\" (_clkid), \"S\" (_ts) :\n\t     \"rcx\", \"r11\");\n\n\treturn ret;\n}\n\n#else\n\nstatic __always_inline\nlong clock_gettime_fallback(clockid_t _clkid, struct __kernel_timespec *_ts)\n{\n\tlong ret;\n\n\tasm (\n\t\t\"mov %%ebx, %%edx \\n\"\n\t\t\"mov %[clock], %%ebx \\n\"\n\t\t\"call __kernel_vsyscall \\n\"\n\t\t\"mov %%edx, %%ebx \\n\"\n\t\t: \"=a\" (ret), \"=m\" (*_ts)\n\t\t: \"0\" (__NR_clock_gettime64), [clock] \"g\" (_clkid), \"c\" (_ts)\n\t\t: \"edx\");\n\n\treturn ret;\n}\n\nstatic __always_inline\nlong clock_gettime32_fallback(clockid_t _clkid, struct old_timespec32 *_ts)\n{\n\tlong ret;\n\n\tasm (\n\t\t\"mov %%ebx, %%edx \\n\"\n\t\t\"mov %[clock], %%ebx \\n\"\n\t\t\"call __kernel_vsyscall \\n\"\n\t\t\"mov %%edx, %%ebx \\n\"\n\t\t: \"=a\" (ret), \"=m\" (*_ts)\n\t\t: \"0\" (__NR_clock_gettime), [clock] \"g\" (_clkid), \"c\" (_ts)\n\t\t: \"edx\");\n\n\treturn ret;\n}\n\nstatic __always_inline\nlong gettimeofday_fallback(struct __kernel_old_timeval *_tv,\n\t\t\t   struct timezone *_tz)\n{\n\tlong ret;\n\n\tasm(\n\t\t\"mov %%ebx, %%edx \\n\"\n\t\t\"mov %2, %%ebx \\n\"\n\t\t\"call __kernel_vsyscall \\n\"\n\t\t\"mov %%edx, %%ebx \\n\"\n\t\t: \"=a\" (ret)\n\t\t: \"0\" (__NR_gettimeofday), \"g\" (_tv), \"c\" (_tz)\n\t\t: \"memory\", \"edx\");\n\n\treturn ret;\n}\n\nstatic __always_inline long\nclock_getres_fallback(clockid_t _clkid, struct __kernel_timespec *_ts)\n{\n\tlong ret;\n\n\tasm (\n\t\t\"mov %%ebx, %%edx \\n\"\n\t\t\"mov %[clock], %%ebx \\n\"\n\t\t\"call __kernel_vsyscall \\n\"\n\t\t\"mov %%edx, %%ebx \\n\"\n\t\t: \"=a\" (ret), \"=m\" (*_ts)\n\t\t: \"0\" (__NR_clock_getres_time64), [clock] \"g\" (_clkid), \"c\" (_ts)\n\t\t: \"edx\");\n\n\treturn ret;\n}\n\nstatic __always_inline\nlong clock_getres32_fallback(clockid_t _clkid, struct old_timespec32 *_ts)\n{\n\tlong ret;\n\n\tasm (\n\t\t\"mov %%ebx, %%edx \\n\"\n\t\t\"mov %[clock], %%ebx \\n\"\n\t\t\"call __kernel_vsyscall \\n\"\n\t\t\"mov %%edx, %%ebx \\n\"\n\t\t: \"=a\" (ret), \"=m\" (*_ts)\n\t\t: \"0\" (__NR_clock_getres), [clock] \"g\" (_clkid), \"c\" (_ts)\n\t\t: \"edx\");\n\n\treturn ret;\n}\n\n#endif\n\n#ifdef CONFIG_PARAVIRT_CLOCK\nstatic u64 vread_pvclock(void)\n{\n\tconst struct pvclock_vcpu_time_info *pvti = &pvclock_page.pvti;\n\tu32 version;\n\tu64 ret;\n\n\t \n\n\tdo {\n\t\tversion = pvclock_read_begin(pvti);\n\n\t\tif (unlikely(!(pvti->flags & PVCLOCK_TSC_STABLE_BIT)))\n\t\t\treturn U64_MAX;\n\n\t\tret = __pvclock_read_cycles(pvti, rdtsc_ordered());\n\t} while (pvclock_read_retry(pvti, version));\n\n\treturn ret & S64_MAX;\n}\n#endif\n\n#ifdef CONFIG_HYPERV_TIMER\nstatic u64 vread_hvclock(void)\n{\n\tu64 tsc, time;\n\n\tif (hv_read_tsc_page_tsc(&hvclock_page, &tsc, &time))\n\t\treturn time & S64_MAX;\n\n\treturn U64_MAX;\n}\n#endif\n\nstatic inline u64 __arch_get_hw_counter(s32 clock_mode,\n\t\t\t\t\tconst struct vdso_data *vd)\n{\n\tif (likely(clock_mode == VDSO_CLOCKMODE_TSC))\n\t\treturn (u64)rdtsc_ordered() & S64_MAX;\n\t \n#ifdef CONFIG_PARAVIRT_CLOCK\n\tif (clock_mode == VDSO_CLOCKMODE_PVCLOCK) {\n\t\tbarrier();\n\t\treturn vread_pvclock();\n\t}\n#endif\n#ifdef CONFIG_HYPERV_TIMER\n\tif (clock_mode == VDSO_CLOCKMODE_HVCLOCK) {\n\t\tbarrier();\n\t\treturn vread_hvclock();\n\t}\n#endif\n\treturn U64_MAX;\n}\n\nstatic __always_inline const struct vdso_data *__arch_get_vdso_data(void)\n{\n\treturn __vdso_data;\n}\n\nstatic inline bool arch_vdso_clocksource_ok(const struct vdso_data *vd)\n{\n\treturn true;\n}\n#define vdso_clocksource_ok arch_vdso_clocksource_ok\n\n \nstatic inline bool arch_vdso_cycles_ok(u64 cycles)\n{\n\treturn (s64)cycles >= 0;\n}\n#define vdso_cycles_ok arch_vdso_cycles_ok\n\n \nstatic __always_inline\nu64 vdso_calc_delta(u64 cycles, u64 last, u64 mask, u32 mult)\n{\n\t \n\tu64 delta = (cycles - last) & S64_MAX;\n\n\t \n\tif (unlikely(delta & (1ULL << 62)))\n\t\treturn 0;\n\n\treturn delta * mult;\n}\n#define vdso_calc_delta vdso_calc_delta\n\nint __vdso_clock_gettime64(clockid_t clock, struct __kernel_timespec *ts);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}