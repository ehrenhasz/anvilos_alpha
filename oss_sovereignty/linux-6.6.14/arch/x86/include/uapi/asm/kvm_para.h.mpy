{
  "module_name": "kvm_para.h",
  "hash_id": "3f427583868c3437516b4b1e23ab92cd85475d272b00d8d3163b125d739cc3bf",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/uapi/asm/kvm_para.h",
  "human_readable_source": " \n#ifndef _UAPI_ASM_X86_KVM_PARA_H\n#define _UAPI_ASM_X86_KVM_PARA_H\n\n#include <linux/types.h>\n\n \n#define KVM_CPUID_SIGNATURE\t0x40000000\n#define KVM_SIGNATURE \"KVMKVMKVM\\0\\0\\0\"\n\n \n#define KVM_CPUID_FEATURES\t0x40000001\n#define KVM_FEATURE_CLOCKSOURCE\t\t0\n#define KVM_FEATURE_NOP_IO_DELAY\t1\n#define KVM_FEATURE_MMU_OP\t\t2\n \n#define KVM_FEATURE_CLOCKSOURCE2        3\n#define KVM_FEATURE_ASYNC_PF\t\t4\n#define KVM_FEATURE_STEAL_TIME\t\t5\n#define KVM_FEATURE_PV_EOI\t\t6\n#define KVM_FEATURE_PV_UNHALT\t\t7\n#define KVM_FEATURE_PV_TLB_FLUSH\t9\n#define KVM_FEATURE_ASYNC_PF_VMEXIT\t10\n#define KVM_FEATURE_PV_SEND_IPI\t11\n#define KVM_FEATURE_POLL_CONTROL\t12\n#define KVM_FEATURE_PV_SCHED_YIELD\t13\n#define KVM_FEATURE_ASYNC_PF_INT\t14\n#define KVM_FEATURE_MSI_EXT_DEST_ID\t15\n#define KVM_FEATURE_HC_MAP_GPA_RANGE\t16\n#define KVM_FEATURE_MIGRATION_CONTROL\t17\n\n#define KVM_HINTS_REALTIME      0\n\n \n#define KVM_FEATURE_CLOCKSOURCE_STABLE_BIT\t24\n\n#define MSR_KVM_WALL_CLOCK  0x11\n#define MSR_KVM_SYSTEM_TIME 0x12\n\n#define KVM_MSR_ENABLED 1\n \n#define MSR_KVM_WALL_CLOCK_NEW  0x4b564d00\n#define MSR_KVM_SYSTEM_TIME_NEW 0x4b564d01\n#define MSR_KVM_ASYNC_PF_EN 0x4b564d02\n#define MSR_KVM_STEAL_TIME  0x4b564d03\n#define MSR_KVM_PV_EOI_EN      0x4b564d04\n#define MSR_KVM_POLL_CONTROL\t0x4b564d05\n#define MSR_KVM_ASYNC_PF_INT\t0x4b564d06\n#define MSR_KVM_ASYNC_PF_ACK\t0x4b564d07\n#define MSR_KVM_MIGRATION_CONTROL\t0x4b564d08\n\nstruct kvm_steal_time {\n\t__u64 steal;\n\t__u32 version;\n\t__u32 flags;\n\t__u8  preempted;\n\t__u8  u8_pad[3];\n\t__u32 pad[11];\n};\n\n#define KVM_VCPU_PREEMPTED          (1 << 0)\n#define KVM_VCPU_FLUSH_TLB          (1 << 1)\n\n#define KVM_CLOCK_PAIRING_WALLCLOCK 0\nstruct kvm_clock_pairing {\n\t__s64 sec;\n\t__s64 nsec;\n\t__u64 tsc;\n\t__u32 flags;\n\t__u32 pad[9];\n};\n\n#define KVM_STEAL_ALIGNMENT_BITS 5\n#define KVM_STEAL_VALID_BITS ((-1ULL << (KVM_STEAL_ALIGNMENT_BITS + 1)))\n#define KVM_STEAL_RESERVED_MASK (((1 << KVM_STEAL_ALIGNMENT_BITS) - 1 ) << 1)\n\n#define KVM_MAX_MMU_OP_BATCH           32\n\n#define KVM_ASYNC_PF_ENABLED\t\t\t(1 << 0)\n#define KVM_ASYNC_PF_SEND_ALWAYS\t\t(1 << 1)\n#define KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT\t(1 << 2)\n#define KVM_ASYNC_PF_DELIVERY_AS_INT\t\t(1 << 3)\n\n \n#define KVM_ASYNC_PF_VEC_MASK\t\t\tGENMASK(7, 0)\n\n \n#define KVM_MIGRATION_READY\t\t(1 << 0)\n\n \n#define KVM_MAP_GPA_RANGE_PAGE_SZ_4K\t0\n#define KVM_MAP_GPA_RANGE_PAGE_SZ_2M\t(1 << 0)\n#define KVM_MAP_GPA_RANGE_PAGE_SZ_1G\t(1 << 1)\n#define KVM_MAP_GPA_RANGE_ENC_STAT(n)\t(n << 4)\n#define KVM_MAP_GPA_RANGE_ENCRYPTED\tKVM_MAP_GPA_RANGE_ENC_STAT(1)\n#define KVM_MAP_GPA_RANGE_DECRYPTED\tKVM_MAP_GPA_RANGE_ENC_STAT(0)\n\n \n#define KVM_MMU_OP_WRITE_PTE            1\n#define KVM_MMU_OP_FLUSH_TLB\t        2\n#define KVM_MMU_OP_RELEASE_PT\t        3\n\n \nstruct kvm_mmu_op_header {\n\t__u32 op;\n\t__u32 pad;\n};\n\nstruct kvm_mmu_op_write_pte {\n\tstruct kvm_mmu_op_header header;\n\t__u64 pte_phys;\n\t__u64 pte_val;\n};\n\nstruct kvm_mmu_op_flush_tlb {\n\tstruct kvm_mmu_op_header header;\n};\n\nstruct kvm_mmu_op_release_pt {\n\tstruct kvm_mmu_op_header header;\n\t__u64 pt_phys;\n};\n\n#define KVM_PV_REASON_PAGE_NOT_PRESENT 1\n#define KVM_PV_REASON_PAGE_READY 2\n\nstruct kvm_vcpu_pv_apf_data {\n\t \n\t__u32 flags;\n\n\t \n\t__u32 token;\n\n\t__u8 pad[56];\n\t__u32 enabled;\n};\n\n#define KVM_PV_EOI_BIT 0\n#define KVM_PV_EOI_MASK (0x1 << KVM_PV_EOI_BIT)\n#define KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK\n#define KVM_PV_EOI_DISABLED 0x0\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}