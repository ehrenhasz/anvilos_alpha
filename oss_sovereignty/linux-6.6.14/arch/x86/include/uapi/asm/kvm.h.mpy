{
  "module_name": "kvm.h",
  "hash_id": "723fe7c0043dbfadb8bfc7a554d91679c05e9d1ff54bff3ae5c67657c1e71244",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/uapi/asm/kvm.h",
  "human_readable_source": " \n#ifndef _ASM_X86_KVM_H\n#define _ASM_X86_KVM_H\n\n \n\n#include <linux/types.h>\n#include <linux/ioctl.h>\n#include <linux/stddef.h>\n\n#define KVM_PIO_PAGE_OFFSET 1\n#define KVM_COALESCED_MMIO_PAGE_OFFSET 2\n#define KVM_DIRTY_LOG_PAGE_OFFSET 64\n\n#define DE_VECTOR 0\n#define DB_VECTOR 1\n#define BP_VECTOR 3\n#define OF_VECTOR 4\n#define BR_VECTOR 5\n#define UD_VECTOR 6\n#define NM_VECTOR 7\n#define DF_VECTOR 8\n#define TS_VECTOR 10\n#define NP_VECTOR 11\n#define SS_VECTOR 12\n#define GP_VECTOR 13\n#define PF_VECTOR 14\n#define MF_VECTOR 16\n#define AC_VECTOR 17\n#define MC_VECTOR 18\n#define XM_VECTOR 19\n#define VE_VECTOR 20\n\n \n#define __KVM_HAVE_PIT\n#define __KVM_HAVE_IOAPIC\n#define __KVM_HAVE_IRQ_LINE\n#define __KVM_HAVE_MSI\n#define __KVM_HAVE_USER_NMI\n#define __KVM_HAVE_GUEST_DEBUG\n#define __KVM_HAVE_MSIX\n#define __KVM_HAVE_MCE\n#define __KVM_HAVE_PIT_STATE2\n#define __KVM_HAVE_XEN_HVM\n#define __KVM_HAVE_VCPU_EVENTS\n#define __KVM_HAVE_DEBUGREGS\n#define __KVM_HAVE_XSAVE\n#define __KVM_HAVE_XCRS\n#define __KVM_HAVE_READONLY_MEM\n\n \n#define KVM_NR_INTERRUPTS 256\n\n \nstruct kvm_pic_state {\n\t__u8 last_irr;\t \n\t__u8 irr;\t\t \n\t__u8 imr;\t\t \n\t__u8 isr;\t\t \n\t__u8 priority_add;\t \n\t__u8 irq_base;\n\t__u8 read_reg_select;\n\t__u8 poll;\n\t__u8 special_mask;\n\t__u8 init_state;\n\t__u8 auto_eoi;\n\t__u8 rotate_on_auto_eoi;\n\t__u8 special_fully_nested_mode;\n\t__u8 init4;\t\t \n\t__u8 elcr;\t\t \n\t__u8 elcr_mask;\n};\n\n#define KVM_IOAPIC_NUM_PINS  24\nstruct kvm_ioapic_state {\n\t__u64 base_address;\n\t__u32 ioregsel;\n\t__u32 id;\n\t__u32 irr;\n\t__u32 pad;\n\tunion {\n\t\t__u64 bits;\n\t\tstruct {\n\t\t\t__u8 vector;\n\t\t\t__u8 delivery_mode:3;\n\t\t\t__u8 dest_mode:1;\n\t\t\t__u8 delivery_status:1;\n\t\t\t__u8 polarity:1;\n\t\t\t__u8 remote_irr:1;\n\t\t\t__u8 trig_mode:1;\n\t\t\t__u8 mask:1;\n\t\t\t__u8 reserve:7;\n\t\t\t__u8 reserved[4];\n\t\t\t__u8 dest_id;\n\t\t} fields;\n\t} redirtbl[KVM_IOAPIC_NUM_PINS];\n};\n\n#define KVM_IRQCHIP_PIC_MASTER   0\n#define KVM_IRQCHIP_PIC_SLAVE    1\n#define KVM_IRQCHIP_IOAPIC       2\n#define KVM_NR_IRQCHIPS          3\n\n#define KVM_RUN_X86_SMM\t\t (1 << 0)\n#define KVM_RUN_X86_BUS_LOCK     (1 << 1)\n\n \nstruct kvm_regs {\n\t \n\t__u64 rax, rbx, rcx, rdx;\n\t__u64 rsi, rdi, rsp, rbp;\n\t__u64 r8,  r9,  r10, r11;\n\t__u64 r12, r13, r14, r15;\n\t__u64 rip, rflags;\n};\n\n \n#define KVM_APIC_REG_SIZE 0x400\nstruct kvm_lapic_state {\n\tchar regs[KVM_APIC_REG_SIZE];\n};\n\nstruct kvm_segment {\n\t__u64 base;\n\t__u32 limit;\n\t__u16 selector;\n\t__u8  type;\n\t__u8  present, dpl, db, s, l, g, avl;\n\t__u8  unusable;\n\t__u8  padding;\n};\n\nstruct kvm_dtable {\n\t__u64 base;\n\t__u16 limit;\n\t__u16 padding[3];\n};\n\n\n \nstruct kvm_sregs {\n\t \n\tstruct kvm_segment cs, ds, es, fs, gs, ss;\n\tstruct kvm_segment tr, ldt;\n\tstruct kvm_dtable gdt, idt;\n\t__u64 cr0, cr2, cr3, cr4, cr8;\n\t__u64 efer;\n\t__u64 apic_base;\n\t__u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];\n};\n\nstruct kvm_sregs2 {\n\t \n\tstruct kvm_segment cs, ds, es, fs, gs, ss;\n\tstruct kvm_segment tr, ldt;\n\tstruct kvm_dtable gdt, idt;\n\t__u64 cr0, cr2, cr3, cr4, cr8;\n\t__u64 efer;\n\t__u64 apic_base;\n\t__u64 flags;\n\t__u64 pdptrs[4];\n};\n#define KVM_SREGS2_FLAGS_PDPTRS_VALID 1\n\n \nstruct kvm_fpu {\n\t__u8  fpr[8][16];\n\t__u16 fcw;\n\t__u16 fsw;\n\t__u8  ftwx;   \n\t__u8  pad1;\n\t__u16 last_opcode;\n\t__u64 last_ip;\n\t__u64 last_dp;\n\t__u8  xmm[16][16];\n\t__u32 mxcsr;\n\t__u32 pad2;\n};\n\nstruct kvm_msr_entry {\n\t__u32 index;\n\t__u32 reserved;\n\t__u64 data;\n};\n\n \nstruct kvm_msrs {\n\t__u32 nmsrs;  \n\t__u32 pad;\n\n\tstruct kvm_msr_entry entries[];\n};\n\n \nstruct kvm_msr_list {\n\t__u32 nmsrs;  \n\t__u32 indices[];\n};\n\n \n#define KVM_MSR_FILTER_MAX_BITMAP_SIZE 0x600\n\n \nstruct kvm_msr_filter_range {\n#define KVM_MSR_FILTER_READ  (1 << 0)\n#define KVM_MSR_FILTER_WRITE (1 << 1)\n#define KVM_MSR_FILTER_RANGE_VALID_MASK (KVM_MSR_FILTER_READ | \\\n\t\t\t\t\t KVM_MSR_FILTER_WRITE)\n\t__u32 flags;\n\t__u32 nmsrs;  \n\t__u32 base;   \n\t__u8 *bitmap;  \n};\n\n#define KVM_MSR_FILTER_MAX_RANGES 16\nstruct kvm_msr_filter {\n#ifndef __KERNEL__\n#define KVM_MSR_FILTER_DEFAULT_ALLOW (0 << 0)\n#endif\n#define KVM_MSR_FILTER_DEFAULT_DENY  (1 << 0)\n#define KVM_MSR_FILTER_VALID_MASK (KVM_MSR_FILTER_DEFAULT_DENY)\n\t__u32 flags;\n\tstruct kvm_msr_filter_range ranges[KVM_MSR_FILTER_MAX_RANGES];\n};\n\nstruct kvm_cpuid_entry {\n\t__u32 function;\n\t__u32 eax;\n\t__u32 ebx;\n\t__u32 ecx;\n\t__u32 edx;\n\t__u32 padding;\n};\n\n \nstruct kvm_cpuid {\n\t__u32 nent;\n\t__u32 padding;\n\tstruct kvm_cpuid_entry entries[];\n};\n\nstruct kvm_cpuid_entry2 {\n\t__u32 function;\n\t__u32 index;\n\t__u32 flags;\n\t__u32 eax;\n\t__u32 ebx;\n\t__u32 ecx;\n\t__u32 edx;\n\t__u32 padding[3];\n};\n\n#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX\t\t(1 << 0)\n#define KVM_CPUID_FLAG_STATEFUL_FUNC\t\t(1 << 1)\n#define KVM_CPUID_FLAG_STATE_READ_NEXT\t\t(1 << 2)\n\n \nstruct kvm_cpuid2 {\n\t__u32 nent;\n\t__u32 padding;\n\tstruct kvm_cpuid_entry2 entries[];\n};\n\n \nstruct kvm_pit_channel_state {\n\t__u32 count;  \n\t__u16 latched_count;\n\t__u8 count_latched;\n\t__u8 status_latched;\n\t__u8 status;\n\t__u8 read_state;\n\t__u8 write_state;\n\t__u8 write_latch;\n\t__u8 rw_mode;\n\t__u8 mode;\n\t__u8 bcd;\n\t__u8 gate;\n\t__s64 count_load_time;\n};\n\nstruct kvm_debug_exit_arch {\n\t__u32 exception;\n\t__u32 pad;\n\t__u64 pc;\n\t__u64 dr6;\n\t__u64 dr7;\n};\n\n#define KVM_GUESTDBG_USE_SW_BP\t\t0x00010000\n#define KVM_GUESTDBG_USE_HW_BP\t\t0x00020000\n#define KVM_GUESTDBG_INJECT_DB\t\t0x00040000\n#define KVM_GUESTDBG_INJECT_BP\t\t0x00080000\n#define KVM_GUESTDBG_BLOCKIRQ\t\t0x00100000\n\n \nstruct kvm_guest_debug_arch {\n\t__u64 debugreg[8];\n};\n\nstruct kvm_pit_state {\n\tstruct kvm_pit_channel_state channels[3];\n};\n\n#define KVM_PIT_FLAGS_HPET_LEGACY     0x00000001\n#define KVM_PIT_FLAGS_SPEAKER_DATA_ON 0x00000002\n\nstruct kvm_pit_state2 {\n\tstruct kvm_pit_channel_state channels[3];\n\t__u32 flags;\n\t__u32 reserved[9];\n};\n\nstruct kvm_reinject_control {\n\t__u8 pit_reinject;\n\t__u8 reserved[31];\n};\n\n \n#define KVM_VCPUEVENT_VALID_NMI_PENDING\t0x00000001\n#define KVM_VCPUEVENT_VALID_SIPI_VECTOR\t0x00000002\n#define KVM_VCPUEVENT_VALID_SHADOW\t0x00000004\n#define KVM_VCPUEVENT_VALID_SMM\t\t0x00000008\n#define KVM_VCPUEVENT_VALID_PAYLOAD\t0x00000010\n#define KVM_VCPUEVENT_VALID_TRIPLE_FAULT\t0x00000020\n\n \n#define KVM_X86_SHADOW_INT_MOV_SS\t0x01\n#define KVM_X86_SHADOW_INT_STI\t\t0x02\n\n \nstruct kvm_vcpu_events {\n\tstruct {\n\t\t__u8 injected;\n\t\t__u8 nr;\n\t\t__u8 has_error_code;\n\t\t__u8 pending;\n\t\t__u32 error_code;\n\t} exception;\n\tstruct {\n\t\t__u8 injected;\n\t\t__u8 nr;\n\t\t__u8 soft;\n\t\t__u8 shadow;\n\t} interrupt;\n\tstruct {\n\t\t__u8 injected;\n\t\t__u8 pending;\n\t\t__u8 masked;\n\t\t__u8 pad;\n\t} nmi;\n\t__u32 sipi_vector;\n\t__u32 flags;\n\tstruct {\n\t\t__u8 smm;\n\t\t__u8 pending;\n\t\t__u8 smm_inside_nmi;\n\t\t__u8 latched_init;\n\t} smi;\n\tstruct {\n\t\t__u8 pending;\n\t} triple_fault;\n\t__u8 reserved[26];\n\t__u8 exception_has_payload;\n\t__u64 exception_payload;\n};\n\n \nstruct kvm_debugregs {\n\t__u64 db[4];\n\t__u64 dr6;\n\t__u64 dr7;\n\t__u64 flags;\n\t__u64 reserved[9];\n};\n\n \nstruct kvm_xsave {\n\t \n\t__u32 region[1024];\n\t__u32 extra[];\n};\n\n#define KVM_MAX_XCRS\t16\n\nstruct kvm_xcr {\n\t__u32 xcr;\n\t__u32 reserved;\n\t__u64 value;\n};\n\nstruct kvm_xcrs {\n\t__u32 nr_xcrs;\n\t__u32 flags;\n\tstruct kvm_xcr xcrs[KVM_MAX_XCRS];\n\t__u64 padding[16];\n};\n\n#define KVM_SYNC_X86_REGS      (1UL << 0)\n#define KVM_SYNC_X86_SREGS     (1UL << 1)\n#define KVM_SYNC_X86_EVENTS    (1UL << 2)\n\n#define KVM_SYNC_X86_VALID_FIELDS \\\n\t(KVM_SYNC_X86_REGS| \\\n\t KVM_SYNC_X86_SREGS| \\\n\t KVM_SYNC_X86_EVENTS)\n\n \nstruct kvm_sync_regs {\n\t \n\tstruct kvm_regs regs;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_vcpu_events events;\n};\n\n#define KVM_X86_QUIRK_LINT0_REENABLED\t\t(1 << 0)\n#define KVM_X86_QUIRK_CD_NW_CLEARED\t\t(1 << 1)\n#define KVM_X86_QUIRK_LAPIC_MMIO_HOLE\t\t(1 << 2)\n#define KVM_X86_QUIRK_OUT_7E_INC_RIP\t\t(1 << 3)\n#define KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT\t(1 << 4)\n#define KVM_X86_QUIRK_FIX_HYPERCALL_INSN\t(1 << 5)\n#define KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS\t(1 << 6)\n\n#define KVM_STATE_NESTED_FORMAT_VMX\t0\n#define KVM_STATE_NESTED_FORMAT_SVM\t1\n\n#define KVM_STATE_NESTED_GUEST_MODE\t0x00000001\n#define KVM_STATE_NESTED_RUN_PENDING\t0x00000002\n#define KVM_STATE_NESTED_EVMCS\t\t0x00000004\n#define KVM_STATE_NESTED_MTF_PENDING\t0x00000008\n#define KVM_STATE_NESTED_GIF_SET\t0x00000100\n\n#define KVM_STATE_NESTED_SMM_GUEST_MODE\t0x00000001\n#define KVM_STATE_NESTED_SMM_VMXON\t0x00000002\n\n#define KVM_STATE_NESTED_VMX_VMCS_SIZE\t0x1000\n\n#define KVM_STATE_NESTED_SVM_VMCB_SIZE\t0x1000\n\n#define KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE\t0x00000001\n\n \n#define KVM_X86_XCOMP_GUEST_SUPP\t0\n\nstruct kvm_vmx_nested_state_data {\n\t__u8 vmcs12[KVM_STATE_NESTED_VMX_VMCS_SIZE];\n\t__u8 shadow_vmcs12[KVM_STATE_NESTED_VMX_VMCS_SIZE];\n};\n\nstruct kvm_vmx_nested_state_hdr {\n\t__u64 vmxon_pa;\n\t__u64 vmcs12_pa;\n\n\tstruct {\n\t\t__u16 flags;\n\t} smm;\n\n\t__u16 pad;\n\n\t__u32 flags;\n\t__u64 preemption_timer_deadline;\n};\n\nstruct kvm_svm_nested_state_data {\n\t \n\t__u8 vmcb12[KVM_STATE_NESTED_SVM_VMCB_SIZE];\n};\n\nstruct kvm_svm_nested_state_hdr {\n\t__u64 vmcb_pa;\n};\n\n \nstruct kvm_nested_state {\n\t__u16 flags;\n\t__u16 format;\n\t__u32 size;\n\n\tunion {\n\t\tstruct kvm_vmx_nested_state_hdr vmx;\n\t\tstruct kvm_svm_nested_state_hdr svm;\n\n\t\t \n\t\t__u8 pad[120];\n\t} hdr;\n\n\t \n\tunion {\n\t\t__DECLARE_FLEX_ARRAY(struct kvm_vmx_nested_state_data, vmx);\n\t\t__DECLARE_FLEX_ARRAY(struct kvm_svm_nested_state_data, svm);\n\t} data;\n};\n\n \nstruct kvm_pmu_event_filter {\n\t__u32 action;\n\t__u32 nevents;\n\t__u32 fixed_counter_bitmap;\n\t__u32 flags;\n\t__u32 pad[4];\n\t__u64 events[];\n};\n\n#define KVM_PMU_EVENT_ALLOW 0\n#define KVM_PMU_EVENT_DENY 1\n\n#define KVM_PMU_EVENT_FLAG_MASKED_EVENTS BIT(0)\n#define KVM_PMU_EVENT_FLAGS_VALID_MASK (KVM_PMU_EVENT_FLAG_MASKED_EVENTS)\n\n \n\n#define KVM_PMU_ENCODE_MASKED_ENTRY(event_select, mask, match, exclude) \\\n\t(((event_select) & 0xFFULL) | (((event_select) & 0XF00ULL) << 24) | \\\n\t(((mask) & 0xFFULL) << 56) | \\\n\t(((match) & 0xFFULL) << 8) | \\\n\t((__u64)(!!(exclude)) << 55))\n\n#define KVM_PMU_MASKED_ENTRY_EVENT_SELECT \\\n\t(GENMASK_ULL(7, 0) | GENMASK_ULL(35, 32))\n#define KVM_PMU_MASKED_ENTRY_UMASK_MASK\t\t(GENMASK_ULL(63, 56))\n#define KVM_PMU_MASKED_ENTRY_UMASK_MATCH\t(GENMASK_ULL(15, 8))\n#define KVM_PMU_MASKED_ENTRY_EXCLUDE\t\t(BIT_ULL(55))\n#define KVM_PMU_MASKED_ENTRY_UMASK_MASK_SHIFT\t(56)\n\n \n#define KVM_VCPU_TSC_CTRL 0  \n#define   KVM_VCPU_TSC_OFFSET 0  \n\n \n#define KVM_EXIT_HYPERCALL_LONG_MODE\tBIT(0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}