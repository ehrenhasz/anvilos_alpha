{
  "module_name": "vsyscall_64.c",
  "hash_id": "8634e3c2d7215a72f8d490b08f220b730944993dcb36483d5fdcbd932da3626c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/entry/vsyscall/vsyscall_64.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_types.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n\n#include <asm/vsyscall.h>\n#include <asm/unistd.h>\n#include <asm/fixmap.h>\n#include <asm/traps.h>\n#include <asm/paravirt.h>\n\n#define CREATE_TRACE_POINTS\n#include \"vsyscall_trace.h\"\n\nstatic enum { EMULATE, XONLY, NONE } vsyscall_mode __ro_after_init =\n#ifdef CONFIG_LEGACY_VSYSCALL_NONE\n\tNONE;\n#elif defined(CONFIG_LEGACY_VSYSCALL_XONLY)\n\tXONLY;\n#else\n\t#error VSYSCALL config is broken\n#endif\n\nstatic int __init vsyscall_setup(char *str)\n{\n\tif (str) {\n\t\tif (!strcmp(\"emulate\", str))\n\t\t\tvsyscall_mode = EMULATE;\n\t\telse if (!strcmp(\"xonly\", str))\n\t\t\tvsyscall_mode = XONLY;\n\t\telse if (!strcmp(\"none\", str))\n\t\t\tvsyscall_mode = NONE;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\nearly_param(\"vsyscall\", vsyscall_setup);\n\nstatic void warn_bad_vsyscall(const char *level, struct pt_regs *regs,\n\t\t\t      const char *message)\n{\n\tif (!show_unhandled_signals)\n\t\treturn;\n\n\tprintk_ratelimited(\"%s%s[%d] %s ip:%lx cs:%lx sp:%lx ax:%lx si:%lx di:%lx\\n\",\n\t\t\t   level, current->comm, task_pid_nr(current),\n\t\t\t   message, regs->ip, regs->cs,\n\t\t\t   regs->sp, regs->ax, regs->si, regs->di);\n}\n\nstatic int addr_to_vsyscall_nr(unsigned long addr)\n{\n\tint nr;\n\n\tif ((addr & ~0xC00UL) != VSYSCALL_ADDR)\n\t\treturn -EINVAL;\n\n\tnr = (addr & 0xC00UL) >> 10;\n\tif (nr >= 3)\n\t\treturn -EINVAL;\n\n\treturn nr;\n}\n\nstatic bool write_ok_or_segv(unsigned long ptr, size_t size)\n{\n\t \n\n\tif (!access_ok((void __user *)ptr, size)) {\n\t\tstruct thread_struct *thread = &current->thread;\n\n\t\tthread->error_code\t= X86_PF_USER | X86_PF_WRITE;\n\t\tthread->cr2\t\t= ptr;\n\t\tthread->trap_nr\t\t= X86_TRAP_PF;\n\n\t\tforce_sig_fault(SIGSEGV, SEGV_MAPERR, (void __user *)ptr);\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nbool emulate_vsyscall(unsigned long error_code,\n\t\t      struct pt_regs *regs, unsigned long address)\n{\n\tstruct task_struct *tsk;\n\tunsigned long caller;\n\tint vsyscall_nr, syscall_nr, tmp;\n\tint prev_sig_on_uaccess_err;\n\tlong ret;\n\tunsigned long orig_dx;\n\n\t \n\tif ((error_code & (X86_PF_WRITE | X86_PF_USER)) != X86_PF_USER)\n\t\treturn false;\n\n\tif (!(error_code & X86_PF_INSTR)) {\n\t\t \n\t\tif (vsyscall_mode == EMULATE)\n\t\t\treturn false;\n\n\t\t \n\t\twarn_bad_vsyscall(KERN_INFO, regs, \"vsyscall read attempt denied -- look up the vsyscall kernel parameter if you need a workaround\");\n\t\treturn false;\n\t}\n\n\t \n\n\tWARN_ON_ONCE(address != regs->ip);\n\n\tif (vsyscall_mode == NONE) {\n\t\twarn_bad_vsyscall(KERN_INFO, regs,\n\t\t\t\t  \"vsyscall attempted with vsyscall=none\");\n\t\treturn false;\n\t}\n\n\tvsyscall_nr = addr_to_vsyscall_nr(address);\n\n\ttrace_emulate_vsyscall(vsyscall_nr);\n\n\tif (vsyscall_nr < 0) {\n\t\twarn_bad_vsyscall(KERN_WARNING, regs,\n\t\t\t\t  \"misaligned vsyscall (exploit attempt or buggy program) -- look up the vsyscall kernel parameter if you need a workaround\");\n\t\tgoto sigsegv;\n\t}\n\n\tif (get_user(caller, (unsigned long __user *)regs->sp) != 0) {\n\t\twarn_bad_vsyscall(KERN_WARNING, regs,\n\t\t\t\t  \"vsyscall with bad stack (exploit attempt?)\");\n\t\tgoto sigsegv;\n\t}\n\n\ttsk = current;\n\n\t \n\tswitch (vsyscall_nr) {\n\tcase 0:\n\t\tif (!write_ok_or_segv(regs->di, sizeof(struct __kernel_old_timeval)) ||\n\t\t    !write_ok_or_segv(regs->si, sizeof(struct timezone))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto check_fault;\n\t\t}\n\n\t\tsyscall_nr = __NR_gettimeofday;\n\t\tbreak;\n\n\tcase 1:\n\t\tif (!write_ok_or_segv(regs->di, sizeof(__kernel_old_time_t))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto check_fault;\n\t\t}\n\n\t\tsyscall_nr = __NR_time;\n\t\tbreak;\n\n\tcase 2:\n\t\tif (!write_ok_or_segv(regs->di, sizeof(unsigned)) ||\n\t\t    !write_ok_or_segv(regs->si, sizeof(unsigned))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto check_fault;\n\t\t}\n\n\t\tsyscall_nr = __NR_getcpu;\n\t\tbreak;\n\t}\n\n\t \n\tregs->orig_ax = syscall_nr;\n\tregs->ax = -ENOSYS;\n\ttmp = secure_computing();\n\tif ((!tmp && regs->orig_ax != syscall_nr) || regs->ip != address) {\n\t\twarn_bad_vsyscall(KERN_DEBUG, regs,\n\t\t\t\t  \"seccomp tried to change syscall nr or ip\");\n\t\tforce_exit_sig(SIGSYS);\n\t\treturn true;\n\t}\n\tregs->orig_ax = -1;\n\tif (tmp)\n\t\tgoto do_ret;   \n\n\t \n\tprev_sig_on_uaccess_err = current->thread.sig_on_uaccess_err;\n\tcurrent->thread.sig_on_uaccess_err = 1;\n\n\tret = -EFAULT;\n\tswitch (vsyscall_nr) {\n\tcase 0:\n\t\t \n\t\tret = __x64_sys_gettimeofday(regs);\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tret = __x64_sys_time(regs);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\torig_dx = regs->dx;\n\t\tregs->dx = 0;\n\t\t \n\t\tret = __x64_sys_getcpu(regs);\n\t\tregs->dx = orig_dx;\n\t\tbreak;\n\t}\n\n\tcurrent->thread.sig_on_uaccess_err = prev_sig_on_uaccess_err;\n\ncheck_fault:\n\tif (ret == -EFAULT) {\n\t\t \n\t\twarn_bad_vsyscall(KERN_INFO, regs,\n\t\t\t\t  \"vsyscall fault (exploit attempt?)\");\n\n\t\t \n\t\tif (WARN_ON_ONCE(!sigismember(&tsk->pending.signal, SIGBUS) &&\n\t\t\t\t !sigismember(&tsk->pending.signal, SIGSEGV)))\n\t\t\tgoto sigsegv;\n\n\t\treturn true;   \n\t}\n\n\tregs->ax = ret;\n\ndo_ret:\n\t \n\tregs->ip = caller;\n\tregs->sp += 8;\n\treturn true;\n\nsigsegv:\n\tforce_sig(SIGSEGV);\n\treturn true;\n}\n\n \nstatic const char *gate_vma_name(struct vm_area_struct *vma)\n{\n\treturn \"[vsyscall]\";\n}\nstatic const struct vm_operations_struct gate_vma_ops = {\n\t.name = gate_vma_name,\n};\nstatic struct vm_area_struct gate_vma __ro_after_init = {\n\t.vm_start\t= VSYSCALL_ADDR,\n\t.vm_end\t\t= VSYSCALL_ADDR + PAGE_SIZE,\n\t.vm_page_prot\t= PAGE_READONLY_EXEC,\n\t.vm_flags\t= VM_READ | VM_EXEC,\n\t.vm_ops\t\t= &gate_vma_ops,\n};\n\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\n{\n#ifdef CONFIG_COMPAT\n\tif (!mm || !test_bit(MM_CONTEXT_HAS_VSYSCALL, &mm->context.flags))\n\t\treturn NULL;\n#endif\n\tif (vsyscall_mode == NONE)\n\t\treturn NULL;\n\treturn &gate_vma;\n}\n\nint in_gate_area(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma = get_gate_vma(mm);\n\n\tif (!vma)\n\t\treturn 0;\n\n\treturn (addr >= vma->vm_start) && (addr < vma->vm_end);\n}\n\n \nint in_gate_area_no_mm(unsigned long addr)\n{\n\treturn vsyscall_mode != NONE && (addr & PAGE_MASK) == VSYSCALL_ADDR;\n}\n\n \nvoid __init set_vsyscall_pgtable_user_bits(pgd_t *root)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset_pgd(root, VSYSCALL_ADDR);\n\tset_pgd(pgd, __pgd(pgd_val(*pgd) | _PAGE_USER));\n\tp4d = p4d_offset(pgd, VSYSCALL_ADDR);\n#if CONFIG_PGTABLE_LEVELS >= 5\n\tset_p4d(p4d, __p4d(p4d_val(*p4d) | _PAGE_USER));\n#endif\n\tpud = pud_offset(p4d, VSYSCALL_ADDR);\n\tset_pud(pud, __pud(pud_val(*pud) | _PAGE_USER));\n\tpmd = pmd_offset(pud, VSYSCALL_ADDR);\n\tset_pmd(pmd, __pmd(pmd_val(*pmd) | _PAGE_USER));\n}\n\nvoid __init map_vsyscall(void)\n{\n\textern char __vsyscall_page;\n\tunsigned long physaddr_vsyscall = __pa_symbol(&__vsyscall_page);\n\n\t \n\tif (vsyscall_mode == EMULATE) {\n\t\t__set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,\n\t\t\t     PAGE_KERNEL_VVAR);\n\t\tset_vsyscall_pgtable_user_bits(swapper_pg_dir);\n\t}\n\n\tif (vsyscall_mode == XONLY)\n\t\tvm_flags_init(&gate_vma, VM_EXEC);\n\n\tBUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=\n\t\t     (unsigned long)VSYSCALL_ADDR);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}