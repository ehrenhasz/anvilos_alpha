{
  "module_name": "vdso2c.c",
  "hash_id": "77948f05ccd130c39954c06235907e6d451d3ddbad70b89d06ee774dcbe7d5ce",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/entry/vdso/vdso2c.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <err.h>\n\n#include <sys/mman.h>\n#include <sys/types.h>\n\n#include <tools/le_byteshift.h>\n\n#include <linux/elf.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nconst char *outfilename;\n\n \nenum {\n\tsym_vvar_start,\n\tsym_vvar_page,\n\tsym_pvclock_page,\n\tsym_hvclock_page,\n\tsym_timens_page,\n};\n\nconst int special_pages[] = {\n\tsym_vvar_page,\n\tsym_pvclock_page,\n\tsym_hvclock_page,\n\tsym_timens_page,\n};\n\nstruct vdso_sym {\n\tconst char *name;\n\tbool export;\n};\n\nstruct vdso_sym required_syms[] = {\n\t[sym_vvar_start] = {\"vvar_start\", true},\n\t[sym_vvar_page] = {\"vvar_page\", true},\n\t[sym_pvclock_page] = {\"pvclock_page\", true},\n\t[sym_hvclock_page] = {\"hvclock_page\", true},\n\t[sym_timens_page] = {\"timens_page\", true},\n\t{\"VDSO32_NOTE_MASK\", true},\n\t{\"__kernel_vsyscall\", true},\n\t{\"__kernel_sigreturn\", true},\n\t{\"__kernel_rt_sigreturn\", true},\n\t{\"int80_landing_pad\", true},\n\t{\"vdso32_rt_sigreturn_landing_pad\", true},\n\t{\"vdso32_sigreturn_landing_pad\", true},\n};\n\n__attribute__((format(printf, 1, 2))) __attribute__((noreturn))\nstatic void fail(const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tfprintf(stderr, \"Error: \");\n\tvfprintf(stderr, format, ap);\n\tif (outfilename)\n\t\tunlink(outfilename);\n\texit(1);\n\tva_end(ap);\n}\n\n \n#define GLE(x, bits, ifnot)\t\t\t\t\t\t\\\n\t__builtin_choose_expr(\t\t\t\t\t\t\\\n\t\t(sizeof(*(x)) == bits/8),\t\t\t\t\\\n\t\t(__typeof__(*(x)))get_unaligned_le##bits(x), ifnot)\n\nextern void bad_get_le(void);\n#define LAST_GLE(x)\t\t\t\t\t\t\t\\\n\t__builtin_choose_expr(sizeof(*(x)) == 1, *(x), bad_get_le())\n\n#define GET_LE(x)\t\t\t\t\t\t\t\\\n\tGLE(x, 64, GLE(x, 32, GLE(x, 16, LAST_GLE(x))))\n\n#define PLE(x, val, bits, ifnot)\t\t\t\t\t\\\n\t__builtin_choose_expr(\t\t\t\t\t\t\\\n\t\t(sizeof(*(x)) == bits/8),\t\t\t\t\\\n\t\tput_unaligned_le##bits((val), (x)), ifnot)\n\nextern void bad_put_le(void);\n#define LAST_PLE(x, val)\t\t\t\t\t\t\\\n\t__builtin_choose_expr(sizeof(*(x)) == 1, *(x) = (val), bad_put_le())\n\n#define PUT_LE(x, val)\t\t\t\t\t\\\n\tPLE(x, val, 64, PLE(x, val, 32, PLE(x, val, 16, LAST_PLE(x, val))))\n\n\n#define NSYMS ARRAY_SIZE(required_syms)\n\n#define BITSFUNC3(name, bits, suffix) name##bits##suffix\n#define BITSFUNC2(name, bits, suffix) BITSFUNC3(name, bits, suffix)\n#define BITSFUNC(name) BITSFUNC2(name, ELF_BITS, )\n\n#define INT_BITS BITSFUNC2(int, ELF_BITS, _t)\n\n#define ELF_BITS_XFORM2(bits, x) Elf##bits##_##x\n#define ELF_BITS_XFORM(bits, x) ELF_BITS_XFORM2(bits, x)\n#define ELF(x) ELF_BITS_XFORM(ELF_BITS, x)\n\n#define ELF_BITS 64\n#include \"vdso2c.h\"\n#undef ELF_BITS\n\n#define ELF_BITS 32\n#include \"vdso2c.h\"\n#undef ELF_BITS\n\nstatic void go(void *raw_addr, size_t raw_len,\n\t       void *stripped_addr, size_t stripped_len,\n\t       FILE *outfile, const char *name)\n{\n\tElf64_Ehdr *hdr = (Elf64_Ehdr *)raw_addr;\n\n\tif (hdr->e_ident[EI_CLASS] == ELFCLASS64) {\n\t\tgo64(raw_addr, raw_len, stripped_addr, stripped_len,\n\t\t     outfile, name);\n\t} else if (hdr->e_ident[EI_CLASS] == ELFCLASS32) {\n\t\tgo32(raw_addr, raw_len, stripped_addr, stripped_len,\n\t\t     outfile, name);\n\t} else {\n\t\tfail(\"unknown ELF class\\n\");\n\t}\n}\n\nstatic void map_input(const char *name, void **addr, size_t *len, int prot)\n{\n\toff_t tmp_len;\n\n\tint fd = open(name, O_RDONLY);\n\tif (fd == -1)\n\t\terr(1, \"open(%s)\", name);\n\n\ttmp_len = lseek(fd, 0, SEEK_END);\n\tif (tmp_len == (off_t)-1)\n\t\terr(1, \"lseek\");\n\t*len = (size_t)tmp_len;\n\n\t*addr = mmap(NULL, tmp_len, prot, MAP_PRIVATE, fd, 0);\n\tif (*addr == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\tclose(fd);\n}\n\nint main(int argc, char **argv)\n{\n\tsize_t raw_len, stripped_len;\n\tvoid *raw_addr, *stripped_addr;\n\tFILE *outfile;\n\tchar *name, *tmp;\n\tint namelen;\n\n\tif (argc != 4) {\n\t\tprintf(\"Usage: vdso2c RAW_INPUT STRIPPED_INPUT OUTPUT\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tname = strdup(argv[3]);\n\tnamelen = strlen(name);\n\tif (namelen >= 3 && !strcmp(name + namelen - 3, \".so\")) {\n\t\tname = NULL;\n\t} else {\n\t\ttmp = strrchr(name, '/');\n\t\tif (tmp)\n\t\t\tname = tmp + 1;\n\t\ttmp = strchr(name, '.');\n\t\tif (tmp)\n\t\t\t*tmp = '\\0';\n\t\tfor (tmp = name; *tmp; tmp++)\n\t\t\tif (*tmp == '-')\n\t\t\t\t*tmp = '_';\n\t}\n\n\tmap_input(argv[1], &raw_addr, &raw_len, PROT_READ);\n\tmap_input(argv[2], &stripped_addr, &stripped_len, PROT_READ);\n\n\toutfilename = argv[3];\n\toutfile = fopen(outfilename, \"w\");\n\tif (!outfile)\n\t\terr(1, \"fopen(%s)\", outfilename);\n\n\tgo(raw_addr, raw_len, stripped_addr, stripped_len, outfile, name);\n\n\tmunmap(raw_addr, raw_len);\n\tmunmap(stripped_addr, stripped_len);\n\tfclose(outfile);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}