{
  "module_name": "Makefile",
  "hash_id": "0129bb9d88684986608a1f5d4bb987e5272b6c0aa96d96d1d2845e7845778735",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/entry/vdso/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Building vDSO images for x86.\n#\n\n# Include the generic Makefile to check the built vdso.\ninclude $(srctree)/lib/vdso/Makefile\n\n# Sanitizer runtimes are unavailable and cannot be linked here.\nKASAN_SANITIZE\t\t\t:= n\nKMSAN_SANITIZE_vclock_gettime.o := n\nKMSAN_SANITIZE_vgetcpu.o\t:= n\n\nUBSAN_SANITIZE\t\t\t:= n\nKCSAN_SANITIZE\t\t\t:= n\nOBJECT_FILES_NON_STANDARD\t:= y\n\n# Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.\nKCOV_INSTRUMENT\t\t:= n\n\nVDSO64-$(CONFIG_X86_64)\t\t:= y\nVDSOX32-$(CONFIG_X86_X32_ABI)\t:= y\nVDSO32-$(CONFIG_X86_32)\t\t:= y\nVDSO32-$(CONFIG_IA32_EMULATION)\t:= y\n\n# files to link into the vdso\nvobjs-y := vdso-note.o vclock_gettime.o vgetcpu.o\nvobjs32-y := vdso32/note.o vdso32/system_call.o vdso32/sigreturn.o\nvobjs32-y += vdso32/vclock_gettime.o vdso32/vgetcpu.o\nvobjs-$(CONFIG_X86_SGX)\t+= vsgx.o\n\n# files to link into kernel\nobj-y\t\t\t\t\t+= vma.o extable.o\nKASAN_SANITIZE_vma.o\t\t\t:= y\nUBSAN_SANITIZE_vma.o\t\t\t:= y\nKCSAN_SANITIZE_vma.o\t\t\t:= y\nOBJECT_FILES_NON_STANDARD_vma.o\t\t:= n\nOBJECT_FILES_NON_STANDARD_extable.o\t:= n\n\n# vDSO images to build\nvdso_img-$(VDSO64-y)\t\t+= 64\nvdso_img-$(VDSOX32-y)\t\t+= x32\nvdso_img-$(VDSO32-y)\t\t+= 32\n\nobj-$(VDSO32-y)\t\t\t+= vdso32-setup.o\n\nvobjs := $(foreach F,$(vobjs-y),$(obj)/$F)\nvobjs32 := $(foreach F,$(vobjs32-y),$(obj)/$F)\n\n$(obj)/vdso.o: $(obj)/vdso.so\n\ntargets += vdso.lds $(vobjs-y)\ntargets += vdso32/vdso32.lds $(vobjs32-y)\n\n# Build the vDSO image C files and link them in.\nvdso_img_objs := $(vdso_img-y:%=vdso-image-%.o)\nvdso_img_cfiles := $(vdso_img-y:%=vdso-image-%.c)\nvdso_img_sodbg := $(vdso_img-y:%=vdso%.so.dbg)\nobj-y += $(vdso_img_objs)\ntargets += $(vdso_img_cfiles)\ntargets += $(vdso_img_sodbg) $(vdso_img-y:%=vdso%.so)\n\nCPPFLAGS_vdso.lds += -P -C\n\nVDSO_LDFLAGS_vdso.lds = -m elf_x86_64 -soname linux-vdso.so.1 --no-undefined \\\n\t\t\t-z max-page-size=4096\n\n$(obj)/vdso64.so.dbg: $(obj)/vdso.lds $(vobjs) FORCE\n\t$(call if_changed,vdso_and_check)\n\nHOST_EXTRACFLAGS += -I$(srctree)/tools/include -I$(srctree)/include/uapi -I$(srctree)/arch/$(SUBARCH)/include/uapi\nhostprogs += vdso2c\n\nquiet_cmd_vdso2c = VDSO2C  $@\n      cmd_vdso2c = $(obj)/vdso2c $< $(<:%.dbg=%) $@\n\n$(obj)/vdso-image-%.c: $(obj)/vdso%.so.dbg $(obj)/vdso%.so $(obj)/vdso2c FORCE\n\t$(call if_changed,vdso2c)\n\n#\n# Don't omit frame pointers for ease of userspace debugging, but do\n# optimize sibling calls.\n#\nCFL := $(PROFILING) -mcmodel=small -fPIC -O2 -fasynchronous-unwind-tables -m64 \\\n       $(filter -g%,$(KBUILD_CFLAGS)) -fno-stack-protector \\\n       -fno-omit-frame-pointer -foptimize-sibling-calls \\\n       -DDISABLE_BRANCH_PROFILING -DBUILD_VDSO\n\nifdef CONFIG_RETPOLINE\nifneq ($(RETPOLINE_VDSO_CFLAGS),)\n  CFL += $(RETPOLINE_VDSO_CFLAGS)\nendif\nendif\n\n$(vobjs): KBUILD_CFLAGS := $(filter-out $(PADDING_CFLAGS) $(CC_FLAGS_LTO) $(CC_FLAGS_CFI) $(RANDSTRUCT_CFLAGS) $(GCC_PLUGINS_CFLAGS) $(RETPOLINE_CFLAGS),$(KBUILD_CFLAGS)) $(CFL)\n$(vobjs): KBUILD_AFLAGS += -DBUILD_VDSO\n\n#\n# vDSO code runs in userspace and -pg doesn't help with profiling anyway.\n#\nCFLAGS_REMOVE_vclock_gettime.o = -pg\nCFLAGS_REMOVE_vdso32/vclock_gettime.o = -pg\nCFLAGS_REMOVE_vgetcpu.o = -pg\nCFLAGS_REMOVE_vdso32/vgetcpu.o = -pg\nCFLAGS_REMOVE_vsgx.o = -pg\n\n#\n# X32 processes use x32 vDSO to access 64bit kernel data.\n#\n# Build x32 vDSO image:\n# 1. Compile x32 vDSO as 64bit.\n# 2. Convert object files to x32.\n# 3. Build x32 VDSO image with x32 objects, which contains 64bit codes\n# so that it can reach 64bit address space with 64bit pointers.\n#\n\nCPPFLAGS_vdsox32.lds = $(CPPFLAGS_vdso.lds)\nVDSO_LDFLAGS_vdsox32.lds = -m elf32_x86_64 -soname linux-vdso.so.1 \\\n\t\t\t   -z max-page-size=4096\n\n# x32-rebranded versions\nvobjx32s-y := $(vobjs-y:.o=-x32.o)\n\n# same thing, but in the output directory\nvobjx32s := $(foreach F,$(vobjx32s-y),$(obj)/$F)\n\n# Convert 64bit object file to x32 for x32 vDSO.\nquiet_cmd_x32 = X32     $@\n      cmd_x32 = $(OBJCOPY) -O elf32-x86-64 $< $@\n\n$(obj)/%-x32.o: $(obj)/%.o FORCE\n\t$(call if_changed,x32)\n\ntargets += vdsox32.lds $(vobjx32s-y)\n\n$(obj)/%.so: OBJCOPYFLAGS := -S --remove-section __ex_table\n$(obj)/%.so: $(obj)/%.so.dbg FORCE\n\t$(call if_changed,objcopy)\n\n$(obj)/vdsox32.so.dbg: $(obj)/vdsox32.lds $(vobjx32s) FORCE\n\t$(call if_changed,vdso_and_check)\n\nCPPFLAGS_vdso32/vdso32.lds = $(CPPFLAGS_vdso.lds)\nVDSO_LDFLAGS_vdso32.lds = -m elf_i386 -soname linux-gate.so.1\n\nKBUILD_AFLAGS_32 := $(filter-out -m64,$(KBUILD_AFLAGS)) -DBUILD_VDSO\n$(obj)/vdso32.so.dbg: KBUILD_AFLAGS = $(KBUILD_AFLAGS_32)\n$(obj)/vdso32.so.dbg: asflags-$(CONFIG_X86_64) += -m32\n\nKBUILD_CFLAGS_32 := $(filter-out -m64,$(KBUILD_CFLAGS))\nKBUILD_CFLAGS_32 := $(filter-out -mcmodel=kernel,$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out -fno-pic,$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out -mfentry,$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(RANDSTRUCT_CFLAGS),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(GCC_PLUGINS_CFLAGS),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(RETPOLINE_CFLAGS),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(CC_FLAGS_LTO),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(CC_FLAGS_CFI),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 := $(filter-out $(PADDING_CFLAGS),$(KBUILD_CFLAGS_32))\nKBUILD_CFLAGS_32 += -m32 -msoft-float -mregparm=0 -fpic\nKBUILD_CFLAGS_32 += -fno-stack-protector\nKBUILD_CFLAGS_32 += $(call cc-option, -foptimize-sibling-calls)\nKBUILD_CFLAGS_32 += -fno-omit-frame-pointer\nKBUILD_CFLAGS_32 += -DDISABLE_BRANCH_PROFILING\n\nifdef CONFIG_RETPOLINE\nifneq ($(RETPOLINE_VDSO_CFLAGS),)\n  KBUILD_CFLAGS_32 += $(RETPOLINE_VDSO_CFLAGS)\nendif\nendif\n\n$(obj)/vdso32.so.dbg: KBUILD_CFLAGS = $(KBUILD_CFLAGS_32)\n\n$(obj)/vdso32.so.dbg: $(obj)/vdso32/vdso32.lds $(vobjs32) FORCE\n\t$(call if_changed,vdso_and_check)\n\n#\n# The DSO images are built using a special linker script.\n#\nquiet_cmd_vdso = VDSO    $@\n      cmd_vdso = $(LD) -o $@ \\\n\t\t       $(VDSO_LDFLAGS) $(VDSO_LDFLAGS_$(filter %.lds,$(^F))) \\\n\t\t       -T $(filter %.lds,$^) $(filter %.o,$^) && \\\n\t\t sh $(srctree)/$(src)/checkundef.sh '$(NM)' '$@'\n\nVDSO_LDFLAGS = -shared --hash-style=both --build-id=sha1 \\\n\t$(call ld-option, --eh-frame-hdr) -Bsymbolic -z noexecstack\nGCOV_PROFILE := n\n\nquiet_cmd_vdso_and_check = VDSO    $@\n      cmd_vdso_and_check = $(cmd_vdso); $(cmd_vdso_check)\n\n#\n# Install the unstripped copies of vdso*.so.  If our toolchain supports\n# build-id, install .build-id links as well.\n#\nquiet_cmd_vdso_install = INSTALL $(@:install_%=%)\ndefine cmd_vdso_install\n\tcp $< \"$(MODLIB)/vdso/$(@:install_%=%)\"; \\\n\tif readelf -n $< |grep -q 'Build ID'; then \\\n\t  buildid=`readelf -n $< |grep 'Build ID' |sed -e 's/^.*Build ID: \\(.*\\)$$/\\1/'`; \\\n\t  first=`echo $$buildid | cut -b-2`; \\\n\t  last=`echo $$buildid | cut -b3-`; \\\n\t  mkdir -p \"$(MODLIB)/vdso/.build-id/$$first\"; \\\n\t  ln -sf \"../../$(@:install_%=%)\" \"$(MODLIB)/vdso/.build-id/$$first/$$last.debug\"; \\\n\tfi\nendef\n\nvdso_img_insttargets := $(vdso_img_sodbg:%.dbg=install_%)\n\n$(MODLIB)/vdso: FORCE\n\t@mkdir -p $(MODLIB)/vdso\n\n$(vdso_img_insttargets): install_%: $(obj)/%.dbg $(MODLIB)/vdso\n\t$(call cmd,vdso_install)\n\nPHONY += vdso_install $(vdso_img_insttargets)\nvdso_install: $(vdso_img_insttargets)\n\nclean-files := vdso32.so vdso32.so.dbg vdso64* vdso-image-*.c vdsox32.so*\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}