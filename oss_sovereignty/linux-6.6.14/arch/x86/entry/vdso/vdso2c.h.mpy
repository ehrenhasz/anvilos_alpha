{
  "module_name": "vdso2c.h",
  "hash_id": "aff0f1cdbc2eae4437a1cf99324eec9c09eef84c62a9259fae05abcd026bcc2f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/entry/vdso/vdso2c.h",
  "human_readable_source": " \n \n\nstatic void BITSFUNC(copy)(FILE *outfile, const unsigned char *data, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (i % 10 == 0)\n\t\t\tfprintf(outfile, \"\\n\\t\");\n\t\tfprintf(outfile, \"0x%02X, \", (int)(data)[i]);\n\t}\n}\n\n\n \nstatic void BITSFUNC(extract)(const unsigned char *data, size_t data_len,\n\t\t\t      FILE *outfile, ELF(Shdr) *sec, const char *name)\n{\n\tunsigned long offset;\n\tsize_t len;\n\n\toffset = (unsigned long)GET_LE(&sec->sh_offset);\n\tlen = (size_t)GET_LE(&sec->sh_size);\n\n\tif (offset + len > data_len)\n\t\tfail(\"section to extract overruns input data\");\n\n\tfprintf(outfile, \"static const unsigned char %s[%zu] = {\", name, len);\n\tBITSFUNC(copy)(outfile, data + offset, len);\n\tfprintf(outfile, \"\\n};\\n\\n\");\n}\n\nstatic void BITSFUNC(go)(void *raw_addr, size_t raw_len,\n\t\t\t void *stripped_addr, size_t stripped_len,\n\t\t\t FILE *outfile, const char *image_name)\n{\n\tint found_load = 0;\n\tunsigned long load_size = -1;   \n\tunsigned long mapping_size;\n\tELF(Ehdr) *hdr = (ELF(Ehdr) *)raw_addr;\n\tunsigned long i, syms_nr;\n\tELF(Shdr) *symtab_hdr = NULL, *strtab_hdr, *secstrings_hdr,\n\t\t*alt_sec = NULL, *extable_sec = NULL;\n\tELF(Dyn) *dyn = 0, *dyn_end = 0;\n\tconst char *secstrings;\n\tINT_BITS syms[NSYMS] = {};\n\n\tELF(Phdr) *pt = (ELF(Phdr) *)(raw_addr + GET_LE(&hdr->e_phoff));\n\n\tif (GET_LE(&hdr->e_type) != ET_DYN)\n\t\tfail(\"input is not a shared object\\n\");\n\n\t \n\tfor (i = 0; i < GET_LE(&hdr->e_phnum); i++) {\n\t\tif (GET_LE(&pt[i].p_type) == PT_LOAD) {\n\t\t\tif (found_load)\n\t\t\t\tfail(\"multiple PT_LOAD segs\\n\");\n\n\t\t\tif (GET_LE(&pt[i].p_offset) != 0 ||\n\t\t\t    GET_LE(&pt[i].p_vaddr) != 0)\n\t\t\t\tfail(\"PT_LOAD in wrong place\\n\");\n\n\t\t\tif (GET_LE(&pt[i].p_memsz) != GET_LE(&pt[i].p_filesz))\n\t\t\t\tfail(\"cannot handle memsz != filesz\\n\");\n\n\t\t\tload_size = GET_LE(&pt[i].p_memsz);\n\t\t\tfound_load = 1;\n\t\t} else if (GET_LE(&pt[i].p_type) == PT_DYNAMIC) {\n\t\t\tdyn = raw_addr + GET_LE(&pt[i].p_offset);\n\t\t\tdyn_end = raw_addr + GET_LE(&pt[i].p_offset) +\n\t\t\t\tGET_LE(&pt[i].p_memsz);\n\t\t}\n\t}\n\tif (!found_load)\n\t\tfail(\"no PT_LOAD seg\\n\");\n\n\tif (stripped_len < load_size)\n\t\tfail(\"stripped input is too short\\n\");\n\n\tif (!dyn)\n\t\tfail(\"input has no PT_DYNAMIC section -- your toolchain is buggy\\n\");\n\n\t \n\tfor (i = 0; dyn + i < dyn_end &&\n\t\t     GET_LE(&dyn[i].d_tag) != DT_NULL; i++) {\n\t\ttypeof(dyn[i].d_tag) tag = GET_LE(&dyn[i].d_tag);\n\t\tif (tag == DT_REL || tag == DT_RELSZ || tag == DT_RELA ||\n\t\t    tag == DT_RELENT || tag == DT_TEXTREL)\n\t\t\tfail(\"vdso image contains dynamic relocations\\n\");\n\t}\n\n\t \n\tsecstrings_hdr = raw_addr + GET_LE(&hdr->e_shoff) +\n\t\tGET_LE(&hdr->e_shentsize)*GET_LE(&hdr->e_shstrndx);\n\tsecstrings = raw_addr + GET_LE(&secstrings_hdr->sh_offset);\n\tfor (i = 0; i < GET_LE(&hdr->e_shnum); i++) {\n\t\tELF(Shdr) *sh = raw_addr + GET_LE(&hdr->e_shoff) +\n\t\t\tGET_LE(&hdr->e_shentsize) * i;\n\t\tif (GET_LE(&sh->sh_type) == SHT_SYMTAB)\n\t\t\tsymtab_hdr = sh;\n\n\t\tif (!strcmp(secstrings + GET_LE(&sh->sh_name),\n\t\t\t    \".altinstructions\"))\n\t\t\talt_sec = sh;\n\t\tif (!strcmp(secstrings + GET_LE(&sh->sh_name), \"__ex_table\"))\n\t\t\textable_sec = sh;\n\t}\n\n\tif (!symtab_hdr)\n\t\tfail(\"no symbol table\\n\");\n\n\tstrtab_hdr = raw_addr + GET_LE(&hdr->e_shoff) +\n\t\tGET_LE(&hdr->e_shentsize) * GET_LE(&symtab_hdr->sh_link);\n\n\tsyms_nr = GET_LE(&symtab_hdr->sh_size) / GET_LE(&symtab_hdr->sh_entsize);\n\t \n\tfor (i = 0; i < syms_nr; i++) {\n\t\tunsigned int k;\n\t\tELF(Sym) *sym = raw_addr + GET_LE(&symtab_hdr->sh_offset) +\n\t\t\tGET_LE(&symtab_hdr->sh_entsize) * i;\n\t\tconst char *sym_name = raw_addr +\n\t\t\t\t       GET_LE(&strtab_hdr->sh_offset) +\n\t\t\t\t       GET_LE(&sym->st_name);\n\n\t\tfor (k = 0; k < NSYMS; k++) {\n\t\t\tif (!strcmp(sym_name, required_syms[k].name)) {\n\t\t\t\tif (syms[k]) {\n\t\t\t\t\tfail(\"duplicate symbol %s\\n\",\n\t\t\t\t\t     required_syms[k].name);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsyms[k] = GET_LE(&sym->st_value);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(special_pages) / sizeof(special_pages[0]); i++) {\n\t\tINT_BITS symval = syms[special_pages[i]];\n\n\t\tif (!symval)\n\t\t\tcontinue;   \n\n\t\tif (symval % 4096)\n\t\t\tfail(\"%s must be a multiple of 4096\\n\",\n\t\t\t     required_syms[i].name);\n\t\tif (symval + 4096 < syms[sym_vvar_start])\n\t\t\tfail(\"%s underruns vvar_start\\n\",\n\t\t\t     required_syms[i].name);\n\t\tif (symval + 4096 > 0)\n\t\t\tfail(\"%s is on the wrong side of the vdso text\\n\",\n\t\t\t     required_syms[i].name);\n\t}\n\tif (syms[sym_vvar_start] % 4096)\n\t\tfail(\"vvar_begin must be a multiple of 4096\\n\");\n\n\tif (!image_name) {\n\t\tfwrite(stripped_addr, stripped_len, 1, outfile);\n\t\treturn;\n\t}\n\n\tmapping_size = (stripped_len + 4095) / 4096 * 4096;\n\n\tfprintf(outfile, \"/* AUTOMATICALLY GENERATED -- DO NOT EDIT */\\n\\n\");\n\tfprintf(outfile, \"#include <linux/linkage.h>\\n\");\n\tfprintf(outfile, \"#include <linux/init.h>\\n\");\n\tfprintf(outfile, \"#include <asm/page_types.h>\\n\");\n\tfprintf(outfile, \"#include <asm/vdso.h>\\n\");\n\tfprintf(outfile, \"\\n\");\n\tfprintf(outfile,\n\t\t\"static unsigned char raw_data[%lu] __ro_after_init __aligned(PAGE_SIZE) = {\",\n\t\tmapping_size);\n\tfor (i = 0; i < stripped_len; i++) {\n\t\tif (i % 10 == 0)\n\t\t\tfprintf(outfile, \"\\n\\t\");\n\t\tfprintf(outfile, \"0x%02X, \",\n\t\t\t(int)((unsigned char *)stripped_addr)[i]);\n\t}\n\tfprintf(outfile, \"\\n};\\n\\n\");\n\tif (extable_sec)\n\t\tBITSFUNC(extract)(raw_addr, raw_len, outfile,\n\t\t\t\t  extable_sec, \"extable\");\n\n\tfprintf(outfile, \"const struct vdso_image %s = {\\n\", image_name);\n\tfprintf(outfile, \"\\t.data = raw_data,\\n\");\n\tfprintf(outfile, \"\\t.size = %lu,\\n\", mapping_size);\n\tif (alt_sec) {\n\t\tfprintf(outfile, \"\\t.alt = %lu,\\n\",\n\t\t\t(unsigned long)GET_LE(&alt_sec->sh_offset));\n\t\tfprintf(outfile, \"\\t.alt_len = %lu,\\n\",\n\t\t\t(unsigned long)GET_LE(&alt_sec->sh_size));\n\t}\n\tif (extable_sec) {\n\t\tfprintf(outfile, \"\\t.extable_base = %lu,\\n\",\n\t\t\t(unsigned long)GET_LE(&extable_sec->sh_offset));\n\t\tfprintf(outfile, \"\\t.extable_len = %lu,\\n\",\n\t\t\t(unsigned long)GET_LE(&extable_sec->sh_size));\n\t\tfprintf(outfile, \"\\t.extable = extable,\\n\");\n\t}\n\n\tfor (i = 0; i < NSYMS; i++) {\n\t\tif (required_syms[i].export && syms[i])\n\t\t\tfprintf(outfile, \"\\t.sym_%s = %\" PRIi64 \",\\n\",\n\t\t\t\trequired_syms[i].name, (int64_t)syms[i]);\n\t}\n\tfprintf(outfile, \"};\\n\\n\");\n\tfprintf(outfile, \"static __init int init_%s(void) {\\n\", image_name);\n\tfprintf(outfile, \"\\treturn init_vdso_image(&%s);\\n\", image_name);\n\tfprintf(outfile, \"};\\n\");\n\tfprintf(outfile, \"subsys_initcall(init_%s);\\n\", image_name);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}