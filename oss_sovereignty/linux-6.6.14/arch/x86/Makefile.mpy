{
  "module_name": "Makefile",
  "hash_id": "6e5cdee662477fdd0653b82996561b69bc52e21516f83710e5559412aaf2ba0e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# Unified Makefile for i386 and x86_64\n\n# select defconfig based on actual architecture\nifeq ($(ARCH),x86)\n  ifeq ($(shell uname -m | sed -e 's/i.86/i386/'),i386)\n        KBUILD_DEFCONFIG := i386_defconfig\n  else\n        KBUILD_DEFCONFIG := x86_64_defconfig\n  endif\nelse\n        KBUILD_DEFCONFIG := $(ARCH)_defconfig\nendif\n\nifdef CONFIG_CC_IS_GCC\nRETPOLINE_CFLAGS\t:= $(call cc-option,-mindirect-branch=thunk-extern -mindirect-branch-register)\nRETPOLINE_VDSO_CFLAGS\t:= $(call cc-option,-mindirect-branch=thunk-inline -mindirect-branch-register)\nendif\nifdef CONFIG_CC_IS_CLANG\nRETPOLINE_CFLAGS\t:= -mretpoline-external-thunk\nRETPOLINE_VDSO_CFLAGS\t:= -mretpoline\nendif\nRETPOLINE_CFLAGS\t+= $(call cc-option,-mindirect-branch-cs-prefix)\n\nifdef CONFIG_RETHUNK\nRETHUNK_CFLAGS\t\t:= -mfunction-return=thunk-extern\nRETPOLINE_CFLAGS\t+= $(RETHUNK_CFLAGS)\nendif\n\nexport RETHUNK_CFLAGS\nexport RETPOLINE_CFLAGS\nexport RETPOLINE_VDSO_CFLAGS\n\n# For gcc stack alignment is specified with -mpreferred-stack-boundary,\n# clang has the option -mstack-alignment for that purpose.\nifneq ($(call cc-option, -mpreferred-stack-boundary=4),)\n      cc_stack_align4 := -mpreferred-stack-boundary=2\n      cc_stack_align8 := -mpreferred-stack-boundary=3\nelse ifneq ($(call cc-option, -mstack-alignment=16),)\n      cc_stack_align4 := -mstack-alignment=4\n      cc_stack_align8 := -mstack-alignment=8\nendif\n\n# How to compile the 16-bit code.  Note we always compile for -march=i386;\n# that way we can complain to the user if the CPU is insufficient.\nREALMODE_CFLAGS\t:= -m16 -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS \\\n\t\t   -Wall -Wstrict-prototypes -march=i386 -mregparm=3 \\\n\t\t   -fno-strict-aliasing -fomit-frame-pointer -fno-pic \\\n\t\t   -mno-mmx -mno-sse $(call cc-option,-fcf-protection=none)\n\nREALMODE_CFLAGS += -ffreestanding\nREALMODE_CFLAGS += -fno-stack-protector\nREALMODE_CFLAGS += -Wno-address-of-packed-member\nREALMODE_CFLAGS += $(cc_stack_align4)\nREALMODE_CFLAGS += $(CLANG_FLAGS)\nexport REALMODE_CFLAGS\n\n# BITS is used as extension for files which are available in a 32 bit\n# and a 64 bit version to simplify shared Makefiles.\n# e.g.: obj-y += foo_$(BITS).o\nexport BITS\n\n#\n# Prevent GCC from generating any FP code by mistake.\n#\n# This must happen before we try the -mpreferred-stack-boundary, see:\n#\n#    https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53383\n#\nKBUILD_CFLAGS += -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx\nKBUILD_RUSTFLAGS += -Ctarget-feature=-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-avx,-avx2\n\nifeq ($(CONFIG_X86_KERNEL_IBT),y)\n#\n# Kernel IBT has S_CET.NOTRACK_EN=0, as such the compilers must not generate\n# NOTRACK prefixes. Current generation compilers unconditionally employ NOTRACK\n# for jump-tables, as such, disable jump-tables for now.\n#\n# (jump-tables are implicitly disabled by RETPOLINE)\n#\n#   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104816\n#\nKBUILD_CFLAGS += $(call cc-option,-fcf-protection=branch -fno-jump-tables)\nelse\nKBUILD_CFLAGS += $(call cc-option,-fcf-protection=none)\nendif\n\nifeq ($(CONFIG_X86_32),y)\n        BITS := 32\n        UTS_MACHINE := i386\n        CHECKFLAGS += -D__i386__\n\n        KBUILD_AFLAGS += -m32\n        KBUILD_CFLAGS += -m32\n\n        KBUILD_CFLAGS += -msoft-float -mregparm=3 -freg-struct-return\n\n        # Never want PIC in a 32-bit kernel, prevent breakage with GCC built\n        # with nonstandard options\n        KBUILD_CFLAGS += -fno-pic\n\n        # Align the stack to the register width instead of using the default\n        # alignment of 16 bytes. This reduces stack usage and the number of\n        # alignment instructions.\n        KBUILD_CFLAGS += $(cc_stack_align4)\n\n        # CPU-specific tuning. Anything which can be shared with UML should go here.\n        include $(srctree)/arch/x86/Makefile_32.cpu\n        KBUILD_CFLAGS += $(cflags-y)\n\n        # temporary until string.h is fixed\n        KBUILD_CFLAGS += -ffreestanding\n\n\tifeq ($(CONFIG_STACKPROTECTOR),y)\n\t\tifeq ($(CONFIG_SMP),y)\n\t\t\tKBUILD_CFLAGS += -mstack-protector-guard-reg=fs -mstack-protector-guard-symbol=__stack_chk_guard\n\t\telse\n\t\t\tKBUILD_CFLAGS += -mstack-protector-guard=global\n\t\tendif\n\tendif\nelse\n        BITS := 64\n        UTS_MACHINE := x86_64\n        CHECKFLAGS += -D__x86_64__\n\n        KBUILD_AFLAGS += -m64\n        KBUILD_CFLAGS += -m64\n\n        # Align jump targets to 1 byte, not the default 16 bytes:\n        KBUILD_CFLAGS += $(call cc-option,-falign-jumps=1)\n\n        # Pack loops tightly as well:\n        KBUILD_CFLAGS += $(call cc-option,-falign-loops=1)\n\n        # Don't autogenerate traditional x87 instructions\n        KBUILD_CFLAGS += -mno-80387\n        KBUILD_CFLAGS += $(call cc-option,-mno-fp-ret-in-387)\n\n        # By default gcc and clang use a stack alignment of 16 bytes for x86.\n        # However the standard kernel entry on x86-64 leaves the stack on an\n        # 8-byte boundary. If the compiler isn't informed about the actual\n        # alignment it will generate extra alignment instructions for the\n        # default alignment which keep the stack *mis*aligned.\n        # Furthermore an alignment to the register width reduces stack usage\n        # and the number of alignment instructions.\n        KBUILD_CFLAGS += $(cc_stack_align8)\n\n\t# Use -mskip-rax-setup if supported.\n\tKBUILD_CFLAGS += $(call cc-option,-mskip-rax-setup)\n\n        # FIXME - should be integrated in Makefile.cpu (Makefile_32.cpu)\n        cflags-$(CONFIG_MK8)\t\t+= -march=k8\n        cflags-$(CONFIG_MPSC)\t\t+= -march=nocona\n        cflags-$(CONFIG_MCORE2)\t\t+= -march=core2\n        cflags-$(CONFIG_MATOM)\t\t+= -march=atom\n        cflags-$(CONFIG_GENERIC_CPU)\t+= -mtune=generic\n        KBUILD_CFLAGS += $(cflags-y)\n\n        rustflags-$(CONFIG_MK8)\t\t+= -Ctarget-cpu=k8\n        rustflags-$(CONFIG_MPSC)\t+= -Ctarget-cpu=nocona\n        rustflags-$(CONFIG_MCORE2)\t+= -Ctarget-cpu=core2\n        rustflags-$(CONFIG_MATOM)\t+= -Ctarget-cpu=atom\n        rustflags-$(CONFIG_GENERIC_CPU)\t+= -Ztune-cpu=generic\n        KBUILD_RUSTFLAGS += $(rustflags-y)\n\n        KBUILD_CFLAGS += -mno-red-zone\n        KBUILD_CFLAGS += -mcmodel=kernel\n        KBUILD_RUSTFLAGS += -Cno-redzone=y\n        KBUILD_RUSTFLAGS += -Ccode-model=kernel\nendif\n\n#\n# If the function graph tracer is used with mcount instead of fentry,\n# '-maccumulate-outgoing-args' is needed to prevent a GCC bug\n# (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=42109)\n#\nifdef CONFIG_FUNCTION_GRAPH_TRACER\n  ifndef CONFIG_HAVE_FENTRY\n\tACCUMULATE_OUTGOING_ARGS := 1\n  endif\nendif\n\nifeq ($(ACCUMULATE_OUTGOING_ARGS), 1)\n\t# This compiler flag is not supported by Clang:\n\tKBUILD_CFLAGS += $(call cc-option,-maccumulate-outgoing-args,)\nendif\n\n# Workaround for a gcc prelease that unfortunately was shipped in a suse release\nKBUILD_CFLAGS += -Wno-sign-compare\n#\nKBUILD_CFLAGS += -fno-asynchronous-unwind-tables\n\n# Avoid indirect branches in kernel to deal with Spectre\nifdef CONFIG_RETPOLINE\n  KBUILD_CFLAGS += $(RETPOLINE_CFLAGS)\n  # Additionally, avoid generating expensive indirect jumps which\n  # are subject to retpolines for small number of switch cases.\n  # clang turns off jump table generation by default when under\n  # retpoline builds, however, gcc does not for x86. This has\n  # only been fixed starting from gcc stable version 8.4.0 and\n  # onwards, but not for older ones. See gcc bug #86952.\n  ifndef CONFIG_CC_IS_CLANG\n    KBUILD_CFLAGS += -fno-jump-tables\n  endif\nendif\n\nifdef CONFIG_SLS\n  KBUILD_CFLAGS += -mharden-sls=all\nendif\n\nifdef CONFIG_CALL_PADDING\nPADDING_CFLAGS := -fpatchable-function-entry=$(CONFIG_FUNCTION_PADDING_BYTES),$(CONFIG_FUNCTION_PADDING_BYTES)\nKBUILD_CFLAGS += $(PADDING_CFLAGS)\nexport PADDING_CFLAGS\nendif\n\nKBUILD_LDFLAGS += -m elf_$(UTS_MACHINE)\n\nifdef CONFIG_LTO_CLANG\nifeq ($(call test-lt, $(CONFIG_LLD_VERSION), 130000),y)\nKBUILD_LDFLAGS\t+= -plugin-opt=-stack-alignment=$(if $(CONFIG_X86_32),4,8)\nendif\nendif\n\nifdef CONFIG_X86_NEED_RELOCS\nLDFLAGS_vmlinux := --emit-relocs --discard-none\nelse\nLDFLAGS_vmlinux :=\nendif\n\n#\n# The 64-bit kernel must be aligned to 2MB.  Pass -z max-page-size=0x200000 to\n# the linker to force 2MB page size regardless of the default page size used\n# by the linker.\n#\nifdef CONFIG_X86_64\nLDFLAGS_vmlinux += -z max-page-size=0x200000\nendif\n\n\narchscripts: scripts_basic\n\t$(Q)$(MAKE) $(build)=arch/x86/tools relocs\n\n###\n# Syscall table generation\n\narchheaders:\n\t$(Q)$(MAKE) $(build)=arch/x86/entry/syscalls all\n\n###\n# Kernel objects\n\nlibs-y  += arch/x86/lib/\n\n# drivers-y are linked after core-y\ndrivers-$(CONFIG_MATH_EMULATION) += arch/x86/math-emu/\ndrivers-$(CONFIG_PCI)            += arch/x86/pci/\n\n# suspend and hibernation support\ndrivers-$(CONFIG_PM) += arch/x86/power/\n\ndrivers-$(CONFIG_FB_CORE) += arch/x86/video/\n\n####\n# boot loader support. Several targets are kept for legacy purposes\n\nboot := arch/x86/boot\n\nBOOT_TARGETS = bzdisk fdimage fdimage144 fdimage288 hdimage isoimage\n\nPHONY += bzImage $(BOOT_TARGETS)\n\n# Default kernel to build\nall: bzImage\n\n# KBUILD_IMAGE specify target image being built\nKBUILD_IMAGE := $(boot)/bzImage\n\nbzImage: vmlinux\nifeq ($(CONFIG_X86_DECODER_SELFTEST),y)\n\t$(Q)$(MAKE) $(build)=arch/x86/tools posttest\nendif\n\t$(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)\n\t$(Q)mkdir -p $(objtree)/arch/$(UTS_MACHINE)/boot\n\t$(Q)ln -fsn ../../x86/boot/bzImage $(objtree)/arch/$(UTS_MACHINE)/boot/$@\n\n$(BOOT_TARGETS): vmlinux\n\t$(Q)$(MAKE) $(build)=$(boot) $@\n\nPHONY += install\ninstall:\n\t$(call cmd,install)\n\nPHONY += vdso_install\nvdso_install:\n\t$(Q)$(MAKE) $(build)=arch/x86/entry/vdso $@\n\narchprepare: checkbin\ncheckbin:\nifdef CONFIG_RETPOLINE\nifeq ($(RETPOLINE_CFLAGS),)\n\t@echo \"You are building kernel with non-retpoline compiler.\" >&2\n\t@echo \"Please update your compiler.\" >&2\n\t@false\nendif\nendif\n\nifdef CONFIG_UNWINDER_ORC\norc_hash_h := arch/$(SRCARCH)/include/generated/asm/orc_hash.h\norc_hash_sh := $(srctree)/scripts/orc_hash.sh\ntargets += $(orc_hash_h)\nquiet_cmd_orc_hash = GEN     $@\n      cmd_orc_hash = mkdir -p $(dir $@); \\\n\t\t     $(CONFIG_SHELL) $(orc_hash_sh) < $< > $@\n$(orc_hash_h): $(srctree)/arch/x86/include/asm/orc_types.h $(orc_hash_sh) FORCE\n\t$(call if_changed,orc_hash)\narchprepare: $(orc_hash_h)\nendif\n\narchclean:\n\t$(Q)rm -rf $(objtree)/arch/i386\n\t$(Q)rm -rf $(objtree)/arch/x86_64\n\ndefine archhelp\n  echo  '* bzImage\t\t- Compressed kernel image (arch/x86/boot/bzImage)'\n  echo  '  install\t\t- Install kernel using (your) ~/bin/$(INSTALLKERNEL) or'\n  echo  '\t\t\t  (distribution) /sbin/$(INSTALLKERNEL) or install to '\n  echo  '\t\t\t  $$(INSTALL_PATH) and run lilo'\n  echo  ''\n  echo  '  fdimage\t\t- Create 1.4MB boot floppy image (arch/x86/boot/fdimage)'\n  echo  '  fdimage144\t\t- Create 1.4MB boot floppy image (arch/x86/boot/fdimage)'\n  echo  '  fdimage288\t\t- Create 2.8MB boot floppy image (arch/x86/boot/fdimage)'\n  echo  '  hdimage\t\t- Create a BIOS/EFI hard disk image (arch/x86/boot/hdimage)'\n  echo  '  isoimage\t\t- Create a boot CD-ROM image (arch/x86/boot/image.iso)'\n  echo  '\t\t\t  bzdisk/fdimage*/hdimage/isoimage also accept:'\n  echo  '\t\t\t  FDARGS=\"...\"  arguments for the booted kernel'\n  echo  '\t\t\t  FDINITRD=file initrd for the booted kernel'\n\nendef\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}