{
  "module_name": "insn-eval.c",
  "hash_id": "040468cf0e10818ed8c521e36c84b99edf0dec99e58ae4c13eb420df69d8a1a8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/insn-eval.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/mmu_context.h>\n#include <asm/desc_defs.h>\n#include <asm/desc.h>\n#include <asm/inat.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <asm/ldt.h>\n#include <asm/vm86.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"insn: \" fmt\n\nenum reg_type {\n\tREG_TYPE_RM = 0,\n\tREG_TYPE_REG,\n\tREG_TYPE_INDEX,\n\tREG_TYPE_BASE,\n};\n\n \nstatic bool is_string_insn(struct insn *insn)\n{\n\t \n\tif (insn->opcode.nbytes != 1)\n\t\treturn false;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c ... 0x6f:\t \n\tcase 0xa4 ... 0xa7:\t \n\tcase 0xaa ... 0xaf:\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nbool insn_has_rep_prefix(struct insn *insn)\n{\n\tinsn_byte_t p;\n\tint i;\n\n\tinsn_get_prefixes(insn);\n\n\tfor_each_insn_prefix(insn, i, p) {\n\t\tif (p == 0xf2 || p == 0xf3)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int get_seg_reg_override_idx(struct insn *insn)\n{\n\tint idx = INAT_SEG_REG_DEFAULT;\n\tint num_overrides = 0, i;\n\tinsn_byte_t p;\n\n\tinsn_get_prefixes(insn);\n\n\t \n\tfor_each_insn_prefix(insn, i, p) {\n\t\tinsn_attr_t attr;\n\n\t\tattr = inat_get_opcode_attribute(p);\n\t\tswitch (attr) {\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_CS):\n\t\t\tidx = INAT_SEG_REG_CS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_SS):\n\t\t\tidx = INAT_SEG_REG_SS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_DS):\n\t\t\tidx = INAT_SEG_REG_DS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_ES):\n\t\t\tidx = INAT_SEG_REG_ES;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_FS):\n\t\t\tidx = INAT_SEG_REG_FS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_GS):\n\t\t\tidx = INAT_SEG_REG_GS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\t \n\t\t}\n\t}\n\n\t \n\tif (num_overrides > 1)\n\t\treturn -EINVAL;\n\n\treturn idx;\n}\n\n \nstatic bool check_seg_overrides(struct insn *insn, int regoff)\n{\n\tif (regoff == offsetof(struct pt_regs, di) && is_string_insn(insn))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int resolve_default_seg(struct insn *insn, struct pt_regs *regs, int off)\n{\n\tif (any_64bit_mode(regs))\n\t\treturn INAT_SEG_REG_IGNORE;\n\t \n\n\tswitch (off) {\n\tcase offsetof(struct pt_regs, ax):\n\tcase offsetof(struct pt_regs, cx):\n\tcase offsetof(struct pt_regs, dx):\n\t\t \n\t\tif (insn->addr_bytes == 2)\n\t\t\treturn -EINVAL;\n\n\t\tfallthrough;\n\n\tcase -EDOM:\n\tcase offsetof(struct pt_regs, bx):\n\tcase offsetof(struct pt_regs, si):\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, di):\n\t\tif (is_string_insn(insn))\n\t\t\treturn INAT_SEG_REG_ES;\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, bp):\n\tcase offsetof(struct pt_regs, sp):\n\t\treturn INAT_SEG_REG_SS;\n\n\tcase offsetof(struct pt_regs, ip):\n\t\treturn INAT_SEG_REG_CS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int resolve_seg_reg(struct insn *insn, struct pt_regs *regs, int regoff)\n{\n\tint idx;\n\n\t \n\tif (regoff == offsetof(struct pt_regs, ip)) {\n\t\tif (any_64bit_mode(regs))\n\t\t\treturn INAT_SEG_REG_IGNORE;\n\t\telse\n\t\t\treturn INAT_SEG_REG_CS;\n\t}\n\n\tif (!insn)\n\t\treturn -EINVAL;\n\n\tif (!check_seg_overrides(insn, regoff))\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\tidx = get_seg_reg_override_idx(insn);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tif (idx == INAT_SEG_REG_DEFAULT)\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\t \n\tif (any_64bit_mode(regs)) {\n\t\tif (idx != INAT_SEG_REG_FS &&\n\t\t    idx != INAT_SEG_REG_GS)\n\t\t\tidx = INAT_SEG_REG_IGNORE;\n\t}\n\n\treturn idx;\n}\n\n \nstatic short get_segment_selector(struct pt_regs *regs, int seg_reg_idx)\n{\n\tunsigned short sel;\n\n#ifdef CONFIG_X86_64\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_IGNORE:\n\t\treturn 0;\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\tsavesegment(ds, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_ES:\n\t\tsavesegment(es, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_FS:\n\t\tsavesegment(fs, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_GS:\n\t\tsavesegment(gs, sel);\n\t\treturn sel;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#else  \n\tstruct kernel_vm86_regs *vm86regs = (struct kernel_vm86_regs *)regs;\n\n\tif (v8086_mode(regs)) {\n\t\tswitch (seg_reg_idx) {\n\t\tcase INAT_SEG_REG_CS:\n\t\t\treturn (unsigned short)(regs->cs & 0xffff);\n\t\tcase INAT_SEG_REG_SS:\n\t\t\treturn (unsigned short)(regs->ss & 0xffff);\n\t\tcase INAT_SEG_REG_DS:\n\t\t\treturn vm86regs->ds;\n\t\tcase INAT_SEG_REG_ES:\n\t\t\treturn vm86regs->es;\n\t\tcase INAT_SEG_REG_FS:\n\t\t\treturn vm86regs->fs;\n\t\tcase INAT_SEG_REG_GS:\n\t\t\treturn vm86regs->gs;\n\t\tcase INAT_SEG_REG_IGNORE:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\treturn (unsigned short)(regs->ds & 0xffff);\n\tcase INAT_SEG_REG_ES:\n\t\treturn (unsigned short)(regs->es & 0xffff);\n\tcase INAT_SEG_REG_FS:\n\t\treturn (unsigned short)(regs->fs & 0xffff);\n\tcase INAT_SEG_REG_GS:\n\t\tsavesegment(gs, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_IGNORE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#endif  \n}\n\nstatic const int pt_regoff[] = {\n\toffsetof(struct pt_regs, ax),\n\toffsetof(struct pt_regs, cx),\n\toffsetof(struct pt_regs, dx),\n\toffsetof(struct pt_regs, bx),\n\toffsetof(struct pt_regs, sp),\n\toffsetof(struct pt_regs, bp),\n\toffsetof(struct pt_regs, si),\n\toffsetof(struct pt_regs, di),\n#ifdef CONFIG_X86_64\n\toffsetof(struct pt_regs, r8),\n\toffsetof(struct pt_regs, r9),\n\toffsetof(struct pt_regs, r10),\n\toffsetof(struct pt_regs, r11),\n\toffsetof(struct pt_regs, r12),\n\toffsetof(struct pt_regs, r13),\n\toffsetof(struct pt_regs, r14),\n\toffsetof(struct pt_regs, r15),\n#else\n\toffsetof(struct pt_regs, ds),\n\toffsetof(struct pt_regs, es),\n\toffsetof(struct pt_regs, fs),\n\toffsetof(struct pt_regs, gs),\n#endif\n};\n\nint pt_regs_offset(struct pt_regs *regs, int regno)\n{\n\tif ((unsigned)regno < ARRAY_SIZE(pt_regoff))\n\t\treturn pt_regoff[regno];\n\treturn -EDOM;\n}\n\nstatic int get_regno(struct insn *insn, enum reg_type type)\n{\n\tint nr_registers = ARRAY_SIZE(pt_regoff);\n\tint regno = 0;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_64) && !insn->x86_64)\n\t\tnr_registers -= 8;\n\n\tswitch (type) {\n\tcase REG_TYPE_RM:\n\t\tregno = X86_MODRM_RM(insn->modrm.value);\n\n\t\t \n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tcase REG_TYPE_REG:\n\t\tregno = X86_MODRM_REG(insn->modrm.value);\n\n\t\tif (X86_REX_R(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tcase REG_TYPE_INDEX:\n\t\tregno = X86_SIB_INDEX(insn->sib.value);\n\t\tif (X86_REX_X(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\n\t\t \n\t\tif (X86_MODRM_MOD(insn->modrm.value) != 3 && regno == 4)\n\t\t\treturn -EDOM;\n\t\tbreak;\n\n\tcase REG_TYPE_BASE:\n\t\tregno = X86_SIB_BASE(insn->sib.value);\n\t\t \n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err_ratelimited(\"invalid register type: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (regno >= nr_registers) {\n\t\tWARN_ONCE(1, \"decoded an instruction with an invalid register\");\n\t\treturn -EINVAL;\n\t}\n\treturn regno;\n}\n\nstatic int get_reg_offset(struct insn *insn, struct pt_regs *regs,\n\t\t\t  enum reg_type type)\n{\n\tint regno = get_regno(insn, type);\n\n\tif (regno < 0)\n\t\treturn regno;\n\n\treturn pt_regs_offset(regs, regno);\n}\n\n \nstatic int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t     int *offs1, int *offs2)\n{\n\t \n\tstatic const int regoff1[] = {\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bx),\n\t};\n\n\tstatic const int regoff2[] = {\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t};\n\n\tif (!offs1 || !offs2)\n\t\treturn -EINVAL;\n\n\t \n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\t*offs1 = insn_get_modrm_rm_off(insn, regs);\n\t\t*offs2 = -EDOM;\n\t\treturn 0;\n\t}\n\n\t*offs1 = regoff1[X86_MODRM_RM(insn->modrm.value)];\n\t*offs2 = regoff2[X86_MODRM_RM(insn->modrm.value)];\n\n\t \n\tif ((X86_MODRM_MOD(insn->modrm.value) == 0) &&\n\t    (X86_MODRM_RM(insn->modrm.value) == 6))\n\t\t*offs1 = -EDOM;\n\n\treturn 0;\n}\n\n \nstatic bool get_desc(struct desc_struct *out, unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tbool success = false;\n\t\tstruct ldt_struct *ldt;\n\n\t\t \n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries) {\n\t\t\t*out = ldt->entries[sel];\n\t\t\tsuccess = true;\n\t\t}\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn success;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\t \n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn false;\n\n\t*out = *(struct desc_struct *)(gdt_desc.address + desc_base);\n\treturn true;\n}\n\n \nunsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t \n\t\treturn (unsigned long)(sel << 4);\n\n\tif (any_64bit_mode(regs)) {\n\t\t \n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS) {\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\t} else if (seg_reg_idx == INAT_SEG_REG_GS) {\n\t\t\t \n\t\t\tif (user_mode(regs))\n\t\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\t\telse\n\t\t\t\trdmsrl(MSR_GS_BASE, base);\n\t\t} else {\n\t\t\tbase = 0;\n\t\t}\n\t\treturn base;\n\t}\n\n\t \n\tif (!sel)\n\t\treturn -1L;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -1L;\n\n\treturn get_desc_base(&desc);\n}\n\n \nstatic unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (any_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn 0;\n\n\t \n\tlimit = get_desc_limit(&desc);\n\tif (desc.g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}\n\n \nint insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(desc.type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc.l << 1) | desc.d) {\n\tcase 0:  \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1:  \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2:  \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3:  \n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint insn_get_modrm_rm_off(struct insn *insn, struct pt_regs *regs)\n{\n\treturn get_reg_offset(insn, regs, REG_TYPE_RM);\n}\n\n \nint insn_get_modrm_reg_off(struct insn *insn, struct pt_regs *regs)\n{\n\treturn get_reg_offset(insn, regs, REG_TYPE_REG);\n}\n\n \nunsigned long *insn_get_modrm_reg_ptr(struct insn *insn, struct pt_regs *regs)\n{\n\tint offset;\n\n\toffset = insn_get_modrm_reg_off(insn, regs);\n\tif (offset < 0)\n\t\treturn NULL;\n\treturn (void *)regs + offset;\n}\n\n \nstatic int get_seg_base_limit(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int regoff, unsigned long *base,\n\t\t\t      unsigned long *limit)\n{\n\tint seg_reg_idx;\n\n\tif (!base)\n\t\treturn -EINVAL;\n\n\tseg_reg_idx = resolve_seg_reg(insn, regs, regoff);\n\tif (seg_reg_idx < 0)\n\t\treturn seg_reg_idx;\n\n\t*base = insn_get_seg_base(regs, seg_reg_idx);\n\tif (*base == -1L)\n\t\treturn -EINVAL;\n\n\tif (!limit)\n\t\treturn 0;\n\n\t*limit = get_seg_limit(regs, seg_reg_idx);\n\tif (!(*limit))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int get_eff_addr_reg(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *regoff, long *eff_addr)\n{\n\tint ret;\n\n\tret = insn_get_modrm(insn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) != 3)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\tif (*regoff < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (insn->addr_bytes == 2)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffff;\n\telse if (insn->addr_bytes == 4)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffffffff;\n\telse  \n\t\t*eff_addr = regs_get_register(regs, *regoff);\n\n\treturn 0;\n}\n\n \nstatic int get_eff_addr_modrm(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int *regoff, long *eff_addr)\n{\n\tlong tmp;\n\tint ret;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tret = insn_get_modrm(insn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\n\t \n\tif (*regoff == -EDOM) {\n\t\tif (any_64bit_mode(regs))\n\t\t\ttmp = regs->ip + insn->length;\n\t\telse\n\t\t\ttmp = 0;\n\t} else if (*regoff < 0) {\n\t\treturn -EINVAL;\n\t} else {\n\t\ttmp = regs_get_register(regs, *regoff);\n\t}\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32 = (int)(tmp & 0xffffffff) + insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = tmp + insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_eff_addr_modrm_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t\t int *regoff, short *eff_addr)\n{\n\tint addr_offset1, addr_offset2, ret;\n\tshort addr1 = 0, addr2 = 0, displacement;\n\n\tif (insn->addr_bytes != 2)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tret = get_reg_offset_16(insn, regs, &addr_offset1, &addr_offset2);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (addr_offset1 != -EDOM)\n\t\taddr1 = regs_get_register(regs, addr_offset1) & 0xffff;\n\n\tif (addr_offset2 != -EDOM)\n\t\taddr2 = regs_get_register(regs, addr_offset2) & 0xffff;\n\n\tdisplacement = insn->displacement.value & 0xffff;\n\t*eff_addr = addr1 + addr2 + displacement;\n\n\t \n\t*regoff = addr_offset1;\n\n\treturn 0;\n}\n\n \nstatic int get_eff_addr_sib(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *base_offset, long *eff_addr)\n{\n\tlong base, indx;\n\tint indx_offset;\n\tint ret;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tret = insn_get_modrm(insn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tret = insn_get_sib(insn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!insn->sib.nbytes)\n\t\treturn -EINVAL;\n\n\t*base_offset = get_reg_offset(insn, regs, REG_TYPE_BASE);\n\tindx_offset = get_reg_offset(insn, regs, REG_TYPE_INDEX);\n\n\t \n\tif (*base_offset == -EDOM)\n\t\tbase = 0;\n\telse if (*base_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tbase = regs_get_register(regs, *base_offset);\n\n\tif (indx_offset == -EDOM)\n\t\tindx = 0;\n\telse if (indx_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tindx = regs_get_register(regs, indx_offset);\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32, base32, idx32;\n\n\t\tbase32 = base & 0xffffffff;\n\t\tidx32 = indx & 0xffffffff;\n\n\t\taddr32 = base32 + idx32 * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\taddr32 += insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = base + indx * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\t*eff_addr += insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __user *get_addr_ref_16(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint ret, regoff;\n\tshort eff_addr;\n\tlong tmp;\n\n\tif (insn_get_displacement(insn))\n\t\tgoto out;\n\n\tif (insn->addr_bytes != 2)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\t} else {\n\t\tret = get_eff_addr_modrm_16(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif ((unsigned long)(eff_addr & 0xffff) > seg_limit)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)(eff_addr & 0xffff) + seg_base;\n\n\t \n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n \nstatic void __user *get_addr_ref_32(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint eff_addr, regoff;\n\tlong tmp;\n\tint ret;\n\n\tif (insn->addr_bytes != 4)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t}\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (!any_64bit_mode(regs) && ((unsigned int)eff_addr > seg_limit))\n\t\tgoto out;\n\n\t \n\tif (v8086_mode(regs) && (eff_addr & ~0xffff))\n\t\tgoto out;\n\n\t \n\tlinear_addr = (unsigned long)(eff_addr & 0xffffffff) + seg_base;\n\n\t \n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n \n#ifndef CONFIG_X86_64\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\treturn (void __user *)-1L;\n}\n#else\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base;\n\tint regoff, ret;\n\tlong eff_addr;\n\n\tif (insn->addr_bytes != 8)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)eff_addr + seg_base;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n#endif  \n\n \nvoid __user *insn_get_addr_ref(struct insn *insn, struct pt_regs *regs)\n{\n\tif (!insn || !regs)\n\t\treturn (void __user *)-1L;\n\n\tif (insn_get_opcode(insn))\n\t\treturn (void __user *)-1L;\n\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\treturn get_addr_ref_16(insn, regs);\n\tcase 4:\n\t\treturn get_addr_ref_32(insn, regs);\n\tcase 8:\n\t\treturn get_addr_ref_64(insn, regs);\n\tdefault:\n\t\treturn (void __user *)-1L;\n\t}\n}\n\nint insn_get_effective_ip(struct pt_regs *regs, unsigned long *ip)\n{\n\tunsigned long seg_base = 0;\n\n\t \n\tif (!user_64bit_mode(regs)) {\n\t\tseg_base = insn_get_seg_base(regs, INAT_SEG_REG_CS);\n\t\tif (seg_base == -1L)\n\t\t\treturn -EINVAL;\n\t}\n\n\t*ip = seg_base + regs->ip;\n\n\treturn 0;\n}\n\n \nint insn_fetch_from_user(struct pt_regs *regs, unsigned char buf[MAX_INSN_SIZE])\n{\n\tunsigned long ip;\n\tint not_copied;\n\n\tif (insn_get_effective_ip(regs, &ip))\n\t\treturn -EINVAL;\n\n\tnot_copied = copy_from_user(buf, (void __user *)ip, MAX_INSN_SIZE);\n\n\treturn MAX_INSN_SIZE - not_copied;\n}\n\n \nint insn_fetch_from_user_inatomic(struct pt_regs *regs, unsigned char buf[MAX_INSN_SIZE])\n{\n\tunsigned long ip;\n\tint not_copied;\n\n\tif (insn_get_effective_ip(regs, &ip))\n\t\treturn -EINVAL;\n\n\tnot_copied = __copy_from_user_inatomic(buf, (void __user *)ip, MAX_INSN_SIZE);\n\n\treturn MAX_INSN_SIZE - not_copied;\n}\n\n \nbool insn_decode_from_regs(struct insn *insn, struct pt_regs *regs,\n\t\t\t   unsigned char buf[MAX_INSN_SIZE], int buf_size)\n{\n\tint seg_defs;\n\n\tinsn_init(insn, buf, buf_size, user_64bit_mode(regs));\n\n\t \n\tseg_defs = insn_get_code_seg_params(regs);\n\tif (seg_defs == -EINVAL)\n\t\treturn false;\n\n\tinsn->addr_bytes = INSN_CODE_SEG_ADDR_SZ(seg_defs);\n\tinsn->opnd_bytes = INSN_CODE_SEG_OPND_SZ(seg_defs);\n\n\tif (insn_get_length(insn))\n\t\treturn false;\n\n\tif (buf_size < insn->length)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nenum insn_mmio_type insn_decode_mmio(struct insn *insn, int *bytes)\n{\n\tenum insn_mmio_type type = INSN_MMIO_DECODE_FAILED;\n\n\t*bytes = 0;\n\n\tif (insn_get_opcode(insn))\n\t\treturn INSN_MMIO_DECODE_FAILED;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x88:  \n\t\t*bytes = 1;\n\t\tfallthrough;\n\tcase 0x89:  \n\t\tif (!*bytes)\n\t\t\t*bytes = insn->opnd_bytes;\n\t\ttype = INSN_MMIO_WRITE;\n\t\tbreak;\n\n\tcase 0xc6:  \n\t\t*bytes = 1;\n\t\tfallthrough;\n\tcase 0xc7:  \n\t\tif (!*bytes)\n\t\t\t*bytes = insn->opnd_bytes;\n\t\ttype = INSN_MMIO_WRITE_IMM;\n\t\tbreak;\n\n\tcase 0x8a:  \n\t\t*bytes = 1;\n\t\tfallthrough;\n\tcase 0x8b:  \n\t\tif (!*bytes)\n\t\t\t*bytes = insn->opnd_bytes;\n\t\ttype = INSN_MMIO_READ;\n\t\tbreak;\n\n\tcase 0xa4:  \n\t\t*bytes = 1;\n\t\tfallthrough;\n\tcase 0xa5:  \n\t\tif (!*bytes)\n\t\t\t*bytes = insn->opnd_bytes;\n\t\ttype = INSN_MMIO_MOVS;\n\t\tbreak;\n\n\tcase 0x0f:  \n\t\tswitch (insn->opcode.bytes[1]) {\n\t\tcase 0xb6:  \n\t\t\t*bytes = 1;\n\t\t\tfallthrough;\n\t\tcase 0xb7:  \n\t\t\tif (!*bytes)\n\t\t\t\t*bytes = 2;\n\t\t\ttype = INSN_MMIO_READ_ZERO_EXTEND;\n\t\t\tbreak;\n\n\t\tcase 0xbe:  \n\t\t\t*bytes = 1;\n\t\t\tfallthrough;\n\t\tcase 0xbf:  \n\t\t\tif (!*bytes)\n\t\t\t\t*bytes = 2;\n\t\t\ttype = INSN_MMIO_READ_SIGN_EXTEND;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn type;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}