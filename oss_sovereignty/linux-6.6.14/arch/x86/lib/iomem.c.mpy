{
  "module_name": "iomem.c",
  "hash_id": "2776146cfc7dfc7f38c52222287b116764a43817bb5390699d89b2ac6c77f794",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/iomem.c",
  "human_readable_source": "#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/kmsan-checks.h>\n\n#define movs(type,to,from) \\\n\tasm volatile(\"movs\" type:\"=&D\" (to), \"=&S\" (from):\"0\" (to), \"1\" (from):\"memory\")\n\n \nstatic __always_inline void rep_movs(void *to, const void *from, size_t n)\n{\n\tunsigned long d0, d1, d2;\n\tasm volatile(\"rep ; movsl\\n\\t\"\n\t\t     \"testb $2,%b4\\n\\t\"\n\t\t     \"je 1f\\n\\t\"\n\t\t     \"movsw\\n\"\n\t\t     \"1:\\ttestb $1,%b4\\n\\t\"\n\t\t     \"je 2f\\n\\t\"\n\t\t     \"movsb\\n\"\n\t\t     \"2:\"\n\t\t     : \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t     : \"0\" (n / 4), \"q\" (n), \"1\" ((long)to), \"2\" ((long)from)\n\t\t     : \"memory\");\n}\n\nstatic void string_memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)\n{\n\tif (unlikely(!n))\n\t\treturn;\n\n\t \n\tif (unlikely(1 & (unsigned long)from)) {\n\t\tmovs(\"b\", to, from);\n\t\tn--;\n\t}\n\tif (n > 1 && unlikely(2 & (unsigned long)from)) {\n\t\tmovs(\"w\", to, from);\n\t\tn-=2;\n\t}\n\trep_movs(to, (const void *)from, n);\n\t \n\tkmsan_unpoison_memory(to, n);\n}\n\nstatic void string_memcpy_toio(volatile void __iomem *to, const void *from, size_t n)\n{\n\tif (unlikely(!n))\n\t\treturn;\n\n\t \n\tkmsan_check_memory(from, n);\n\t \n\tif (unlikely(1 & (unsigned long)to)) {\n\t\tmovs(\"b\", to, from);\n\t\tn--;\n\t}\n\tif (n > 1 && unlikely(2 & (unsigned long)to)) {\n\t\tmovs(\"w\", to, from);\n\t\tn-=2;\n\t}\n\trep_movs((void *)to, (const void *) from, n);\n}\n\nstatic void unrolled_memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)\n{\n\tconst volatile char __iomem *in = from;\n\tchar *out = to;\n\tint i;\n\n\tfor (i = 0; i < n; ++i)\n\t\tout[i] = readb(&in[i]);\n}\n\nstatic void unrolled_memcpy_toio(volatile void __iomem *to, const void *from, size_t n)\n{\n\tvolatile char __iomem *out = to;\n\tconst char *in = from;\n\tint i;\n\n\tfor (i = 0; i < n; ++i)\n\t\twriteb(in[i], &out[i]);\n}\n\nstatic void unrolled_memset_io(volatile void __iomem *a, int b, size_t c)\n{\n\tvolatile char __iomem *mem = a;\n\tint i;\n\n\tfor (i = 0; i < c; ++i)\n\t\twriteb(b, &mem[i]);\n}\n\nvoid memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)\n{\n\tif (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO))\n\t\tunrolled_memcpy_fromio(to, from, n);\n\telse\n\t\tstring_memcpy_fromio(to, from, n);\n}\nEXPORT_SYMBOL(memcpy_fromio);\n\nvoid memcpy_toio(volatile void __iomem *to, const void *from, size_t n)\n{\n\tif (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO))\n\t\tunrolled_memcpy_toio(to, from, n);\n\telse\n\t\tstring_memcpy_toio(to, from, n);\n}\nEXPORT_SYMBOL(memcpy_toio);\n\nvoid memset_io(volatile void __iomem *a, int b, size_t c)\n{\n\tif (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO)) {\n\t\tunrolled_memset_io(a, b, c);\n\t} else {\n\t\t \n\t\tmemset((void *)a, b, c);\n\t}\n}\nEXPORT_SYMBOL(memset_io);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}