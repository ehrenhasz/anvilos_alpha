{
  "module_name": "usercopy_64.c",
  "hash_id": "7fa033430f8ced89f43321bbec4a6890a27f7f4fb31809c5eeab314303517b0d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/usercopy_64.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/libnvdimm.h>\n\n \n\n#ifdef CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE\n \nstatic void clean_cache_range(void *addr, size_t size)\n{\n\tu16 x86_clflush_size = boot_cpu_data.x86_clflush_size;\n\tunsigned long clflush_mask = x86_clflush_size - 1;\n\tvoid *vend = addr + size;\n\tvoid *p;\n\n\tfor (p = (void *)((unsigned long)addr & ~clflush_mask);\n\t     p < vend; p += x86_clflush_size)\n\t\tclwb(p);\n}\n\nvoid arch_wb_cache_pmem(void *addr, size_t size)\n{\n\tclean_cache_range(addr, size);\n}\nEXPORT_SYMBOL_GPL(arch_wb_cache_pmem);\n\nlong __copy_user_flushcache(void *dst, const void __user *src, unsigned size)\n{\n\tunsigned long flushed, dest = (unsigned long) dst;\n\tlong rc;\n\n\tstac();\n\trc = __copy_user_nocache(dst, src, size);\n\tclac();\n\n\t \n\tif (size < 8) {\n\t\tif (!IS_ALIGNED(dest, 4) || size != 4)\n\t\t\tclean_cache_range(dst, size);\n\t} else {\n\t\tif (!IS_ALIGNED(dest, 8)) {\n\t\t\tdest = ALIGN(dest, boot_cpu_data.x86_clflush_size);\n\t\t\tclean_cache_range(dst, 1);\n\t\t}\n\n\t\tflushed = dest - (unsigned long) dst;\n\t\tif (size > flushed && !IS_ALIGNED(size - flushed, 8))\n\t\t\tclean_cache_range(dst + size - 1, 1);\n\t}\n\n\treturn rc;\n}\n\nvoid __memcpy_flushcache(void *_dst, const void *_src, size_t size)\n{\n\tunsigned long dest = (unsigned long) _dst;\n\tunsigned long source = (unsigned long) _src;\n\n\t \n\tif (!IS_ALIGNED(dest, 8)) {\n\t\tsize_t len = min_t(size_t, size, ALIGN(dest, 8) - dest);\n\n\t\tmemcpy((void *) dest, (void *) source, len);\n\t\tclean_cache_range((void *) dest, len);\n\t\tdest += len;\n\t\tsource += len;\n\t\tsize -= len;\n\t\tif (!size)\n\t\t\treturn;\n\t}\n\n\t \n\twhile (size >= 32) {\n\t\tasm(\"movq    (%0), %%r8\\n\"\n\t\t    \"movq   8(%0), %%r9\\n\"\n\t\t    \"movq  16(%0), %%r10\\n\"\n\t\t    \"movq  24(%0), %%r11\\n\"\n\t\t    \"movnti  %%r8,   (%1)\\n\"\n\t\t    \"movnti  %%r9,  8(%1)\\n\"\n\t\t    \"movnti %%r10, 16(%1)\\n\"\n\t\t    \"movnti %%r11, 24(%1)\\n\"\n\t\t    :: \"r\" (source), \"r\" (dest)\n\t\t    : \"memory\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t\tdest += 32;\n\t\tsource += 32;\n\t\tsize -= 32;\n\t}\n\n\t \n\twhile (size >= 8) {\n\t\tasm(\"movq    (%0), %%r8\\n\"\n\t\t    \"movnti  %%r8,   (%1)\\n\"\n\t\t    :: \"r\" (source), \"r\" (dest)\n\t\t    : \"memory\", \"r8\");\n\t\tdest += 8;\n\t\tsource += 8;\n\t\tsize -= 8;\n\t}\n\n\t \n\twhile (size >= 4) {\n\t\tasm(\"movl    (%0), %%r8d\\n\"\n\t\t    \"movnti  %%r8d,   (%1)\\n\"\n\t\t    :: \"r\" (source), \"r\" (dest)\n\t\t    : \"memory\", \"r8\");\n\t\tdest += 4;\n\t\tsource += 4;\n\t\tsize -= 4;\n\t}\n\n\t \n\tif (size) {\n\t\tmemcpy((void *) dest, (void *) source, size);\n\t\tclean_cache_range((void *) dest, size);\n\t}\n}\nEXPORT_SYMBOL_GPL(__memcpy_flushcache);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}