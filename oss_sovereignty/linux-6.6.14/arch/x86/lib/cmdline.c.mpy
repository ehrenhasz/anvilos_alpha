{
  "module_name": "cmdline.c",
  "hash_id": "8e5515972e3e6dcc7d74781eb74f01eaac469e0fedefb4f9bf4c5a5b58dc1ce0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/cmdline.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <asm/setup.h>\n#include <asm/cmdline.h>\n\nstatic inline int myisspace(u8 c)\n{\n\treturn c <= ' ';\t \n}\n\n \nstatic int\n__cmdline_find_option_bool(const char *cmdline, int max_cmdline_size,\n\t\t\t   const char *option)\n{\n\tchar c;\n\tint pos = 0, wstart = 0;\n\tconst char *opptr = NULL;\n\tenum {\n\t\tst_wordstart = 0,\t \n\t\tst_wordcmp,\t \n\t\tst_wordskip,\t \n\t} state = st_wordstart;\n\n\tif (!cmdline)\n\t\treturn -1;       \n\n\t \n\twhile (pos < max_cmdline_size) {\n\t\tc = *(char *)cmdline++;\n\t\tpos++;\n\n\t\tswitch (state) {\n\t\tcase st_wordstart:\n\t\t\tif (!c)\n\t\t\t\treturn 0;\n\t\t\telse if (myisspace(c))\n\t\t\t\tbreak;\n\n\t\t\tstate = st_wordcmp;\n\t\t\topptr = option;\n\t\t\twstart = pos;\n\t\t\tfallthrough;\n\n\t\tcase st_wordcmp:\n\t\t\tif (!*opptr) {\n\t\t\t\t \n\t\t\t\tif (!c || myisspace(c))\n\t\t\t\t\treturn wstart;\n\t\t\t\t \n\t\t\t} else if (!c) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t} else if (c == *opptr++) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = st_wordskip;\n\t\t\tfallthrough;\n\n\t\tcase st_wordskip:\n\t\t\tif (!c)\n\t\t\t\treturn 0;\n\t\t\telse if (myisspace(c))\n\t\t\t\tstate = st_wordstart;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\t \n}\n\n \nstatic int\n__cmdline_find_option(const char *cmdline, int max_cmdline_size,\n\t\t      const char *option, char *buffer, int bufsize)\n{\n\tchar c;\n\tint pos = 0, len = -1;\n\tconst char *opptr = NULL;\n\tchar *bufptr = buffer;\n\tenum {\n\t\tst_wordstart = 0,\t \n\t\tst_wordcmp,\t \n\t\tst_wordskip,\t \n\t\tst_bufcpy,\t \n\t} state = st_wordstart;\n\n\tif (!cmdline)\n\t\treturn -1;       \n\n\t \n\twhile (pos++ < max_cmdline_size) {\n\t\tc = *(char *)cmdline++;\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tswitch (state) {\n\t\tcase st_wordstart:\n\t\t\tif (myisspace(c))\n\t\t\t\tbreak;\n\n\t\t\tstate = st_wordcmp;\n\t\t\topptr = option;\n\t\t\tfallthrough;\n\n\t\tcase st_wordcmp:\n\t\t\tif ((c == '=') && !*opptr) {\n\t\t\t\t \n\t\t\t\tlen = 0;\n\t\t\t\tbufptr = buffer;\n\t\t\t\tstate = st_bufcpy;\n\t\t\t\tbreak;\n\t\t\t} else if (c == *opptr++) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = st_wordskip;\n\t\t\tfallthrough;\n\n\t\tcase st_wordskip:\n\t\t\tif (myisspace(c))\n\t\t\t\tstate = st_wordstart;\n\t\t\tbreak;\n\n\t\tcase st_bufcpy:\n\t\t\tif (myisspace(c)) {\n\t\t\t\tstate = st_wordstart;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (++len < bufsize)\n\t\t\t\t\t*bufptr++ = c;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bufsize)\n\t\t*bufptr = '\\0';\n\n\treturn len;\n}\n\nint cmdline_find_option_bool(const char *cmdline, const char *option)\n{\n\treturn __cmdline_find_option_bool(cmdline, COMMAND_LINE_SIZE, option);\n}\n\nint cmdline_find_option(const char *cmdline, const char *option, char *buffer,\n\t\t\tint bufsize)\n{\n\treturn __cmdline_find_option(cmdline, COMMAND_LINE_SIZE, option,\n\t\t\t\t     buffer, bufsize);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}