{
  "module_name": "delay.c",
  "hash_id": "b302fa68f6fc32897cb434faeee436d94ef139cb8daac712de7ee6203ad805b9",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/delay.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/timex.h>\n#include <linux/preempt.h>\n#include <linux/delay.h>\n\n#include <asm/processor.h>\n#include <asm/delay.h>\n#include <asm/timer.h>\n#include <asm/mwait.h>\n\n#ifdef CONFIG_SMP\n# include <asm/smp.h>\n#endif\n\nstatic void delay_loop(u64 __loops);\n\n \nstatic void (*delay_fn)(u64) __ro_after_init = delay_loop;\nstatic void (*delay_halt_fn)(u64 start, u64 cycles) __ro_after_init;\n\n \nstatic void delay_loop(u64 __loops)\n{\n\tunsigned long loops = (unsigned long)__loops;\n\n\tasm volatile(\n\t\t\"\ttest %0,%0\t\\n\"\n\t\t\"\tjz 3f\t\t\\n\"\n\t\t\"\tjmp 1f\t\t\\n\"\n\n\t\t\".align 16\t\t\\n\"\n\t\t\"1:\tjmp 2f\t\t\\n\"\n\n\t\t\".align 16\t\t\\n\"\n\t\t\"2:\tdec %0\t\t\\n\"\n\t\t\"\tjnz 2b\t\t\\n\"\n\t\t\"3:\tdec %0\t\t\\n\"\n\n\t\t: \"+a\" (loops)\n\t\t:\n\t);\n}\n\n \nstatic void delay_tsc(u64 cycles)\n{\n\tu64 bclock, now;\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\tbclock = rdtsc_ordered();\n\tfor (;;) {\n\t\tnow = rdtsc_ordered();\n\t\tif ((now - bclock) >= cycles)\n\t\t\tbreak;\n\n\t\t \n\t\tpreempt_enable();\n\t\trep_nop();\n\t\tpreempt_disable();\n\n\t\t \n\t\tif (unlikely(cpu != smp_processor_id())) {\n\t\t\tcycles -= (now - bclock);\n\t\t\tcpu = smp_processor_id();\n\t\t\tbclock = rdtsc_ordered();\n\t\t}\n\t}\n\tpreempt_enable();\n}\n\n \nstatic void delay_halt_tpause(u64 start, u64 cycles)\n{\n\tu64 until = start + cycles;\n\tu32 eax, edx;\n\n\teax = lower_32_bits(until);\n\tedx = upper_32_bits(until);\n\n\t \n\t__tpause(TPAUSE_C02_STATE, edx, eax);\n}\n\n \nstatic void delay_halt_mwaitx(u64 unused, u64 cycles)\n{\n\tu64 delay;\n\n\tdelay = min_t(u64, MWAITX_MAX_WAIT_CYCLES, cycles);\n\t \n\t __monitorx(raw_cpu_ptr(&cpu_tss_rw), 0, 0);\n\n\t \n\t__mwaitx(MWAITX_DISABLE_CSTATES, delay, MWAITX_ECX_TIMER_ENABLE);\n}\n\n \nstatic void delay_halt(u64 __cycles)\n{\n\tu64 start, end, cycles = __cycles;\n\n\t \n\tif (!cycles)\n\t\treturn;\n\n\tstart = rdtsc_ordered();\n\n\tfor (;;) {\n\t\tdelay_halt_fn(start, cycles);\n\t\tend = rdtsc_ordered();\n\n\t\tif (cycles <= end - start)\n\t\t\tbreak;\n\n\t\tcycles -= end - start;\n\t\tstart = end;\n\t}\n}\n\nvoid __init use_tsc_delay(void)\n{\n\tif (delay_fn == delay_loop)\n\t\tdelay_fn = delay_tsc;\n}\n\nvoid __init use_tpause_delay(void)\n{\n\tdelay_halt_fn = delay_halt_tpause;\n\tdelay_fn = delay_halt;\n}\n\nvoid use_mwaitx_delay(void)\n{\n\tdelay_halt_fn = delay_halt_mwaitx;\n\tdelay_fn = delay_halt;\n}\n\nint read_current_timer(unsigned long *timer_val)\n{\n\tif (delay_fn == delay_tsc) {\n\t\t*timer_val = rdtsc();\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nvoid __delay(unsigned long loops)\n{\n\tdelay_fn(loops);\n}\nEXPORT_SYMBOL(__delay);\n\nnoinline void __const_udelay(unsigned long xloops)\n{\n\tunsigned long lpj = this_cpu_read(cpu_info.loops_per_jiffy) ? : loops_per_jiffy;\n\tint d0;\n\n\txloops *= 4;\n\tasm(\"mull %%edx\"\n\t\t:\"=d\" (xloops), \"=&a\" (d0)\n\t\t:\"1\" (xloops), \"0\" (lpj * (HZ / 4)));\n\n\t__delay(++xloops);\n}\nEXPORT_SYMBOL(__const_udelay);\n\nvoid __udelay(unsigned long usecs)\n{\n\t__const_udelay(usecs * 0x000010c7);  \n}\nEXPORT_SYMBOL(__udelay);\n\nvoid __ndelay(unsigned long nsecs)\n{\n\t__const_udelay(nsecs * 0x00005);  \n}\nEXPORT_SYMBOL(__ndelay);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}