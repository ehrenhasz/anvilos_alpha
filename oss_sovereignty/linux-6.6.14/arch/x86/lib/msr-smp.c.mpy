{
  "module_name": "msr-smp.c",
  "hash_id": "ce0ac8348392996e302cfc629f986f1b9679eceedbd9884c5f6b5acc1fbe3f54",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/msr-smp.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/preempt.h>\n#include <linux/smp.h>\n#include <linux/completion.h>\n#include <asm/msr.h>\n\nstatic void __rdmsr_on_cpu(void *info)\n{\n\tstruct msr_info *rv = info;\n\tstruct msr *reg;\n\tint this_cpu = raw_smp_processor_id();\n\n\tif (rv->msrs)\n\t\treg = per_cpu_ptr(rv->msrs, this_cpu);\n\telse\n\t\treg = &rv->reg;\n\n\trdmsr(rv->msr_no, reg->l, reg->h);\n}\n\nstatic void __wrmsr_on_cpu(void *info)\n{\n\tstruct msr_info *rv = info;\n\tstruct msr *reg;\n\tint this_cpu = raw_smp_processor_id();\n\n\tif (rv->msrs)\n\t\treg = per_cpu_ptr(rv->msrs, this_cpu);\n\telse\n\t\treg = &rv->reg;\n\n\twrmsr(rv->msr_no, reg->l, reg->h);\n}\n\nint rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\terr = smp_call_function_single(cpu, __rdmsr_on_cpu, &rv, 1);\n\t*l = rv.reg.l;\n\t*h = rv.reg.h;\n\n\treturn err;\n}\nEXPORT_SYMBOL(rdmsr_on_cpu);\n\nint rdmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 *q)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\terr = smp_call_function_single(cpu, __rdmsr_on_cpu, &rv, 1);\n\t*q = rv.reg.q;\n\n\treturn err;\n}\nEXPORT_SYMBOL(rdmsrl_on_cpu);\n\nint wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\trv.reg.l = l;\n\trv.reg.h = h;\n\terr = smp_call_function_single(cpu, __wrmsr_on_cpu, &rv, 1);\n\n\treturn err;\n}\nEXPORT_SYMBOL(wrmsr_on_cpu);\n\nint wrmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 q)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\trv.reg.q = q;\n\n\terr = smp_call_function_single(cpu, __wrmsr_on_cpu, &rv, 1);\n\n\treturn err;\n}\nEXPORT_SYMBOL(wrmsrl_on_cpu);\n\nstatic void __rwmsr_on_cpus(const struct cpumask *mask, u32 msr_no,\n\t\t\t    struct msr *msrs,\n\t\t\t    void (*msr_func) (void *info))\n{\n\tstruct msr_info rv;\n\tint this_cpu;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msrs\t  = msrs;\n\trv.msr_no = msr_no;\n\n\tthis_cpu = get_cpu();\n\n\tif (cpumask_test_cpu(this_cpu, mask))\n\t\tmsr_func(&rv);\n\n\tsmp_call_function_many(mask, msr_func, &rv, 1);\n\tput_cpu();\n}\n\n \nvoid rdmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs)\n{\n\t__rwmsr_on_cpus(mask, msr_no, msrs, __rdmsr_on_cpu);\n}\nEXPORT_SYMBOL(rdmsr_on_cpus);\n\n \nvoid wrmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs)\n{\n\t__rwmsr_on_cpus(mask, msr_no, msrs, __wrmsr_on_cpu);\n}\nEXPORT_SYMBOL(wrmsr_on_cpus);\n\nstruct msr_info_completion {\n\tstruct msr_info\t\tmsr;\n\tstruct completion\tdone;\n};\n\n \nstatic void __rdmsr_safe_on_cpu(void *info)\n{\n\tstruct msr_info_completion *rv = info;\n\n\trv->msr.err = rdmsr_safe(rv->msr.msr_no, &rv->msr.reg.l, &rv->msr.reg.h);\n\tcomplete(&rv->done);\n}\n\nstatic void __wrmsr_safe_on_cpu(void *info)\n{\n\tstruct msr_info *rv = info;\n\n\trv->err = wrmsr_safe(rv->msr_no, rv->reg.l, rv->reg.h);\n}\n\nint rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)\n{\n\tstruct msr_info_completion rv;\n\tcall_single_data_t csd;\n\tint err;\n\n\tINIT_CSD(&csd, __rdmsr_safe_on_cpu, &rv);\n\n\tmemset(&rv, 0, sizeof(rv));\n\tinit_completion(&rv.done);\n\trv.msr.msr_no = msr_no;\n\n\terr = smp_call_function_single_async(cpu, &csd);\n\tif (!err) {\n\t\twait_for_completion(&rv.done);\n\t\terr = rv.msr.err;\n\t}\n\t*l = rv.msr.reg.l;\n\t*h = rv.msr.reg.h;\n\n\treturn err;\n}\nEXPORT_SYMBOL(rdmsr_safe_on_cpu);\n\nint wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\trv.reg.l = l;\n\trv.reg.h = h;\n\terr = smp_call_function_single(cpu, __wrmsr_safe_on_cpu, &rv, 1);\n\n\treturn err ? err : rv.err;\n}\nEXPORT_SYMBOL(wrmsr_safe_on_cpu);\n\nint wrmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 q)\n{\n\tint err;\n\tstruct msr_info rv;\n\n\tmemset(&rv, 0, sizeof(rv));\n\n\trv.msr_no = msr_no;\n\trv.reg.q = q;\n\n\terr = smp_call_function_single(cpu, __wrmsr_safe_on_cpu, &rv, 1);\n\n\treturn err ? err : rv.err;\n}\nEXPORT_SYMBOL(wrmsrl_safe_on_cpu);\n\nint rdmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 *q)\n{\n\tu32 low, high;\n\tint err;\n\n\terr = rdmsr_safe_on_cpu(cpu, msr_no, &low, &high);\n\t*q = (u64)high << 32 | low;\n\n\treturn err;\n}\nEXPORT_SYMBOL(rdmsrl_safe_on_cpu);\n\n \nstatic void __rdmsr_safe_regs_on_cpu(void *info)\n{\n\tstruct msr_regs_info *rv = info;\n\n\trv->err = rdmsr_safe_regs(rv->regs);\n}\n\nstatic void __wrmsr_safe_regs_on_cpu(void *info)\n{\n\tstruct msr_regs_info *rv = info;\n\n\trv->err = wrmsr_safe_regs(rv->regs);\n}\n\nint rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8])\n{\n\tint err;\n\tstruct msr_regs_info rv;\n\n\trv.regs   = regs;\n\trv.err    = -EIO;\n\terr = smp_call_function_single(cpu, __rdmsr_safe_regs_on_cpu, &rv, 1);\n\n\treturn err ? err : rv.err;\n}\nEXPORT_SYMBOL(rdmsr_safe_regs_on_cpu);\n\nint wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8])\n{\n\tint err;\n\tstruct msr_regs_info rv;\n\n\trv.regs = regs;\n\trv.err  = -EIO;\n\terr = smp_call_function_single(cpu, __wrmsr_safe_regs_on_cpu, &rv, 1);\n\n\treturn err ? err : rv.err;\n}\nEXPORT_SYMBOL(wrmsr_safe_regs_on_cpu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}