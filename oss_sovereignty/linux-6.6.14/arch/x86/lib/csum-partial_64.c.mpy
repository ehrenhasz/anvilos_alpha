{
  "module_name": "csum-partial_64.c",
  "hash_id": "501b8317c9fb87acd1355df11592c50e353a862c569033ae1ddc626d10958344",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/csum-partial_64.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/export.h>\n#include <asm/checksum.h>\n#include <asm/word-at-a-time.h>\n\nstatic inline __wsum csum_finalize_sum(u64 temp64)\n{\n\treturn (__force __wsum)((temp64 + ror64(temp64, 32)) >> 32);\n}\n\nstatic inline unsigned long update_csum_40b(unsigned long sum, const unsigned long m[5])\n{\n\tasm(\"addq %1,%0\\n\\t\"\n\t     \"adcq %2,%0\\n\\t\"\n\t     \"adcq %3,%0\\n\\t\"\n\t     \"adcq %4,%0\\n\\t\"\n\t     \"adcq %5,%0\\n\\t\"\n\t     \"adcq $0,%0\"\n\t\t:\"+r\" (sum)\n\t\t:\"m\" (m[0]), \"m\" (m[1]), \"m\" (m[2]),\n\t\t \"m\" (m[3]), \"m\" (m[4]));\n\treturn sum;\n}\n\n \n__wsum csum_partial(const void *buff, int len, __wsum sum)\n{\n\tu64 temp64 = (__force u64)sum;\n\n\t \n\tif (likely(len >= 80)) {\n\t\tu64 temp64_2 = 0;\n\t\tdo {\n\t\t\ttemp64 = update_csum_40b(temp64, buff);\n\t\t\ttemp64_2 = update_csum_40b(temp64_2, buff + 40);\n\t\t\tbuff += 80;\n\t\t\tlen -= 80;\n\t\t} while (len >= 80);\n\n\t\tasm(\"addq %1,%0\\n\\t\"\n\t\t    \"adcq $0,%0\"\n\t\t    :\"+r\" (temp64): \"r\" (temp64_2));\n\t}\n\n\t \n\tif (len >= 40) {\n\t\ttemp64 = update_csum_40b(temp64, buff);\n\t\tlen -= 40;\n\t\tif (!len)\n\t\t\treturn csum_finalize_sum(temp64);\n\t\tbuff += 40;\n\t}\n\n\tif (len & 32) {\n\t\tasm(\"addq 0*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq 1*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq 2*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq 3*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq $0,%[res]\"\n\t\t    : [res] \"+r\"(temp64)\n\t\t    : [src] \"r\"(buff), \"m\"(*(const char(*)[32])buff));\n\t\tbuff += 32;\n\t}\n\tif (len & 16) {\n\t\tasm(\"addq 0*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq 1*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq $0,%[res]\"\n\t\t    : [res] \"+r\"(temp64)\n\t\t    : [src] \"r\"(buff), \"m\"(*(const char(*)[16])buff));\n\t\tbuff += 16;\n\t}\n\tif (len & 8) {\n\t\tasm(\"addq 0*8(%[src]),%[res]\\n\\t\"\n\t\t    \"adcq $0,%[res]\"\n\t\t    : [res] \"+r\"(temp64)\n\t\t    : [src] \"r\"(buff), \"m\"(*(const char(*)[8])buff));\n\t\tbuff += 8;\n\t}\n\tif (len & 7) {\n\t\tunsigned int shift = (-len << 3) & 63;\n\t\tunsigned long trail;\n\n\t\ttrail = (load_unaligned_zeropad(buff) << shift) >> shift;\n\n\t\tasm(\"addq %[trail],%[res]\\n\\t\"\n\t\t    \"adcq $0,%[res]\"\n\t\t    : [res] \"+r\"(temp64)\n\t\t    : [trail] \"r\"(trail));\n\t}\n\treturn csum_finalize_sum(temp64);\n}\nEXPORT_SYMBOL(csum_partial);\n\n \n__sum16 ip_compute_csum(const void *buff, int len)\n{\n\treturn csum_fold(csum_partial(buff, len, 0));\n}\nEXPORT_SYMBOL(ip_compute_csum);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}