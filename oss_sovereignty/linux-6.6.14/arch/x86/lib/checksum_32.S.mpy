{
  "module_name": "checksum_32.S",
  "hash_id": "22bce9edec2a59cec4df824266dc69db88945a58ffef140cde7b1ce1472315fa",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/lib/checksum_32.S",
  "human_readable_source": " \n \n\n#include <linux/linkage.h>\n#include <asm/errno.h>\n#include <asm/asm.h>\n#include <asm/export.h>\n#include <asm/nospec-branch.h>\n\n \n\n \n\t\t\n.text\n\t\t\n#ifndef CONFIG_X86_USE_PPRO_CHECKSUM\n\n\t   \t\t\nSYM_FUNC_START(csum_partial)\n\tpushl %esi\n\tpushl %ebx\n\tmovl 20(%esp),%eax\t# Function arg: unsigned int sum\n\tmovl 16(%esp),%ecx\t# Function arg: int len\n\tmovl 12(%esp),%esi\t# Function arg: unsigned char *buff\n\ttestl $3, %esi\t\t# Check alignment.\n\tjz 2f\t\t\t# Jump if alignment is ok.\n\ttestl $1, %esi\t\t# Check alignment.\n\tjz 10f\t\t\t# Jump if alignment is boundary of 2 bytes.\n\n\t# buf is odd\n\tdec %ecx\n\tjl 8f\n\tmovzbl (%esi), %ebx\n\tadcl %ebx, %eax\n\troll $8, %eax\n\tinc %esi\n\ttestl $2, %esi\n\tjz 2f\n10:\n\tsubl $2, %ecx\t\t# Alignment uses up two bytes.\n\tjae 1f\t\t\t# Jump if we had at least two bytes.\n\taddl $2, %ecx\t\t# ecx was < 2.  Deal with it.\n\tjmp 4f\n1:\tmovw (%esi), %bx\n\taddl $2, %esi\n\taddw %bx, %ax\n\tadcl $0, %eax\n2:\n\tmovl %ecx, %edx\n\tshrl $5, %ecx\n\tjz 2f\n\ttestl %esi, %esi\n1:\tmovl (%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 4(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 8(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 12(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 16(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 20(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 24(%esi), %ebx\n\tadcl %ebx, %eax\n\tmovl 28(%esi), %ebx\n\tadcl %ebx, %eax\n\tlea 32(%esi), %esi\n\tdec %ecx\n\tjne 1b\n\tadcl $0, %eax\n2:\tmovl %edx, %ecx\n\tandl $0x1c, %edx\n\tje 4f\n\tshrl $2, %edx\t\t# This clears CF\n3:\tadcl (%esi), %eax\n\tlea 4(%esi), %esi\n\tdec %edx\n\tjne 3b\n\tadcl $0, %eax\n4:\tandl $3, %ecx\n\tjz 7f\n\tcmpl $2, %ecx\n\tjb 5f\n\tmovw (%esi),%cx\n\tleal 2(%esi),%esi\n\tje 6f\n\tshll $16,%ecx\n5:\tmovb (%esi),%cl\n6:\taddl %ecx,%eax\n\tadcl $0, %eax \n7:\t\n\ttestb $1, 12(%esp)\n\tjz 8f\n\troll $8, %eax\n8:\n\tpopl %ebx\n\tpopl %esi\n\tRET\nSYM_FUNC_END(csum_partial)\n\n#else\n\n \n\nSYM_FUNC_START(csum_partial)\n\tpushl %esi\n\tpushl %ebx\n\tmovl 20(%esp),%eax\t# Function arg: unsigned int sum\n\tmovl 16(%esp),%ecx\t# Function arg: int len\n\tmovl 12(%esp),%esi\t# Function arg:\tconst unsigned char *buf\n\n\ttestl $3, %esi         \n\tjnz 25f                 \n10:\n\tmovl %ecx, %edx\n\tmovl %ecx, %ebx\n\tandl $0x7c, %ebx\n\tshrl $7, %ecx\n\taddl %ebx,%esi\n\tshrl $2, %ebx  \n\tnegl %ebx\n\tlea 45f(%ebx,%ebx,2), %ebx\n\ttestl %esi, %esi\n\tJMP_NOSPEC ebx\n\n\t# Handle 2-byte-aligned regions\n20:\taddw (%esi), %ax\n\tlea 2(%esi), %esi\n\tadcl $0, %eax\n\tjmp 10b\n25:\n\ttestl $1, %esi         \n\tjz 30f                 \n\t# buf is odd\n\tdec %ecx\n\tjl 90f\n\tmovzbl (%esi), %ebx\n\taddl %ebx, %eax\n\tadcl $0, %eax\n\troll $8, %eax\n\tinc %esi\n\ttestl $2, %esi\n\tjz 10b\n\n30:\tsubl $2, %ecx          \n\tja 20b                 \n\tje 32f\n\taddl $2, %ecx\n\tjz 80f\n\tmovzbl (%esi),%ebx\t# csumming 1 byte, 2-aligned\n\taddl %ebx, %eax\n\tadcl $0, %eax\n\tjmp 80f\n32:\n\taddw (%esi), %ax\t# csumming 2 bytes, 2-aligned\n\tadcl $0, %eax\n\tjmp 80f\n\n40: \n\taddl -128(%esi), %eax\n\tadcl -124(%esi), %eax\n\tadcl -120(%esi), %eax\n\tadcl -116(%esi), %eax   \n\tadcl -112(%esi), %eax   \n\tadcl -108(%esi), %eax\n\tadcl -104(%esi), %eax\n\tadcl -100(%esi), %eax\n\tadcl -96(%esi), %eax\n\tadcl -92(%esi), %eax\n\tadcl -88(%esi), %eax\n\tadcl -84(%esi), %eax\n\tadcl -80(%esi), %eax\n\tadcl -76(%esi), %eax\n\tadcl -72(%esi), %eax\n\tadcl -68(%esi), %eax\n\tadcl -64(%esi), %eax     \n\tadcl -60(%esi), %eax     \n\tadcl -56(%esi), %eax     \n\tadcl -52(%esi), %eax   \n\tadcl -48(%esi), %eax   \n\tadcl -44(%esi), %eax\n\tadcl -40(%esi), %eax\n\tadcl -36(%esi), %eax\n\tadcl -32(%esi), %eax\n\tadcl -28(%esi), %eax\n\tadcl -24(%esi), %eax\n\tadcl -20(%esi), %eax\n\tadcl -16(%esi), %eax\n\tadcl -12(%esi), %eax\n\tadcl -8(%esi), %eax\n\tadcl -4(%esi), %eax\n45:\n\tlea 128(%esi), %esi\n\tadcl $0, %eax\n\tdec %ecx\n\tjge 40b\n\tmovl %edx, %ecx\n50:\tandl $3, %ecx\n\tjz 80f\n\n\t# Handle the last 1-3 bytes without jumping\n\tnotl %ecx\t\t# 1->2, 2->1, 3->0, higher bits are masked\n\tmovl $0xffffff,%ebx\t# by the shll and shrl instructions\n\tshll $3,%ecx\n\tshrl %cl,%ebx\n\tandl -128(%esi),%ebx\t# esi is 4-aligned so should be ok\n\taddl %ebx,%eax\n\tadcl $0,%eax\n80: \n\ttestb $1, 12(%esp)\n\tjz 90f\n\troll $8, %eax\n90: \n\tpopl %ebx\n\tpopl %esi\n\tRET\nSYM_FUNC_END(csum_partial)\n\t\t\t\t\n#endif\nEXPORT_SYMBOL(csum_partial)\n\n  \n\n \n\n#define EXC(y...)\t\t\t\t\t\t\\\n\t9999: y;\t\t\t\t\t\t\\\n\t_ASM_EXTABLE_TYPE(9999b, 7f, EX_TYPE_UACCESS | EX_FLAG_CLEAR_AX)\n\n#ifndef CONFIG_X86_USE_PPRO_CHECKSUM\n\n#define ARGBASE 16\t\t\n#define FP\t\t12\n\t\t\nSYM_FUNC_START(csum_partial_copy_generic)\n\tsubl  $4,%esp\t\n\tpushl %edi\n\tpushl %esi\n\tpushl %ebx\n\tmovl ARGBASE+12(%esp),%ecx\t# len\n\tmovl ARGBASE+4(%esp),%esi\t# src\n\tmovl ARGBASE+8(%esp),%edi\t# dst\n\n\tmovl $-1, %eax\t\t\t# sum\n\ttestl $2, %edi\t\t\t# Check alignment. \n\tjz 2f\t\t\t\t# Jump if alignment is ok.\n\tsubl $2, %ecx\t\t\t# Alignment uses up two bytes.\n\tjae 1f\t\t\t\t# Jump if we had at least two bytes.\n\taddl $2, %ecx\t\t\t# ecx was < 2.  Deal with it.\n\tjmp 4f\nEXC(1:\tmovw (%esi), %bx\t)\n\taddl $2, %esi\nEXC(\tmovw %bx, (%edi)\t)\n\taddl $2, %edi\n\taddw %bx, %ax\t\n\tadcl $0, %eax\n2:\n\tmovl %ecx, FP(%esp)\n\tshrl $5, %ecx\n\tjz 2f\n\ttestl %esi, %esi\t\t# what's wrong with clc?\nEXC(1:\tmovl (%esi), %ebx\t)\nEXC(\tmovl 4(%esi), %edx\t)\n\tadcl %ebx, %eax\nEXC(\tmovl %ebx, (%edi)\t)\n\tadcl %edx, %eax\nEXC(\tmovl %edx, 4(%edi)\t)\n\nEXC(\tmovl 8(%esi), %ebx\t)\nEXC(\tmovl 12(%esi), %edx\t)\n\tadcl %ebx, %eax\nEXC(\tmovl %ebx, 8(%edi)\t)\n\tadcl %edx, %eax\nEXC(\tmovl %edx, 12(%edi)\t)\n\nEXC(\tmovl 16(%esi), %ebx \t)\nEXC(\tmovl 20(%esi), %edx\t)\n\tadcl %ebx, %eax\nEXC(\tmovl %ebx, 16(%edi)\t)\n\tadcl %edx, %eax\nEXC(\tmovl %edx, 20(%edi)\t)\n\nEXC(\tmovl 24(%esi), %ebx\t)\nEXC(\tmovl 28(%esi), %edx\t)\n\tadcl %ebx, %eax\nEXC(\tmovl %ebx, 24(%edi)\t)\n\tadcl %edx, %eax\nEXC(\tmovl %edx, 28(%edi)\t)\n\n\tlea 32(%esi), %esi\n\tlea 32(%edi), %edi\n\tdec %ecx\n\tjne 1b\n\tadcl $0, %eax\n2:\tmovl FP(%esp), %edx\n\tmovl %edx, %ecx\n\tandl $0x1c, %edx\n\tje 4f\n\tshrl $2, %edx\t\t\t# This clears CF\nEXC(3:\tmovl (%esi), %ebx\t)\n\tadcl %ebx, %eax\nEXC(\tmovl %ebx, (%edi)\t)\n\tlea 4(%esi), %esi\n\tlea 4(%edi), %edi\n\tdec %edx\n\tjne 3b\n\tadcl $0, %eax\n4:\tandl $3, %ecx\n\tjz 7f\n\tcmpl $2, %ecx\n\tjb 5f\nEXC(\tmovw (%esi), %cx\t)\n\tleal 2(%esi), %esi\nEXC(\tmovw %cx, (%edi)\t)\n\tleal 2(%edi), %edi\n\tje 6f\n\tshll $16,%ecx\nEXC(5:\tmovb (%esi), %cl\t)\nEXC(\tmovb %cl, (%edi)\t)\n6:\taddl %ecx, %eax\n\tadcl $0, %eax\n7:\n\n\tpopl %ebx\n\tpopl %esi\n\tpopl %edi\n\tpopl %ecx\t\t\t# equivalent to addl $4,%esp\n\tRET\nSYM_FUNC_END(csum_partial_copy_generic)\n\n#else\n\n \n\n#define ROUND1(x) \\\n\tEXC(movl x(%esi), %ebx\t)\t;\t\\\n\taddl %ebx, %eax\t\t\t;\t\\\n\tEXC(movl %ebx, x(%edi)\t)\t;\n\n#define ROUND(x) \\\n\tEXC(movl x(%esi), %ebx\t)\t;\t\\\n\tadcl %ebx, %eax\t\t\t;\t\\\n\tEXC(movl %ebx, x(%edi)\t)\t;\n\n#define ARGBASE 12\n\t\t\nSYM_FUNC_START(csum_partial_copy_generic)\n\tpushl %ebx\n\tpushl %edi\n\tpushl %esi\n\tmovl ARGBASE+4(%esp),%esi\t#src\n\tmovl ARGBASE+8(%esp),%edi\t#dst\t\n\tmovl ARGBASE+12(%esp),%ecx\t#len\n\tmovl $-1, %eax\t\t\t#sum\n#\tmovl %ecx, %edx  \n\tmovl %ecx, %ebx  \n\tmovl %esi, %edx\n\tshrl $6, %ecx     \n\tandl $0x3c, %ebx  \n\tnegl %ebx\n\tsubl %ebx, %esi  \n\tsubl %ebx, %edi  \n\tlea  -1(%esi),%edx\n\tandl $-32,%edx\n\tlea 3f(%ebx,%ebx), %ebx\n\ttestl %esi, %esi \n\tJMP_NOSPEC ebx\n1:\taddl $64,%esi\n\taddl $64,%edi \n\tEXC(movb -32(%edx),%bl)\t; EXC(movb (%edx),%bl)\n\tROUND1(-64) ROUND(-60) ROUND(-56) ROUND(-52)\t\n\tROUND (-48) ROUND(-44) ROUND(-40) ROUND(-36)\t\n\tROUND (-32) ROUND(-28) ROUND(-24) ROUND(-20)\t\n\tROUND (-16) ROUND(-12) ROUND(-8)  ROUND(-4)\t\n3:\tadcl $0,%eax\n\taddl $64, %edx\n\tdec %ecx\n\tjge 1b\n4:\tmovl ARGBASE+12(%esp),%edx\t#len\n\tandl $3, %edx\n\tjz 7f\n\tcmpl $2, %edx\n\tjb 5f\nEXC(\tmovw (%esi), %dx         )\n\tleal 2(%esi), %esi\nEXC(\tmovw %dx, (%edi)         )\n\tleal 2(%edi), %edi\n\tje 6f\n\tshll $16,%edx\n5:\nEXC(\tmovb (%esi), %dl         )\nEXC(\tmovb %dl, (%edi)         )\n6:\taddl %edx, %eax\n\tadcl $0, %eax\n7:\n\n\tpopl %esi\n\tpopl %edi\n\tpopl %ebx\n\tRET\nSYM_FUNC_END(csum_partial_copy_generic)\n\t\t\t\t\n#undef ROUND\n#undef ROUND1\t\t\n\t\t\n#endif\nEXPORT_SYMBOL(csum_partial_copy_generic)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}