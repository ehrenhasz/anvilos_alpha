{
  "module_name": "fpu_system.h",
  "hash_id": "6c141b48cebd49cf3e5d59715819ae250540cb3e627076255bd42595b84e5adb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/fpu_system.h",
  "human_readable_source": " \n \n\n#ifndef _FPU_SYSTEM_H\n#define _FPU_SYSTEM_H\n\n \n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n\n#include <asm/desc.h>\n#include <asm/mmu_context.h>\n\nstatic inline struct desc_struct FPU_get_ldt_descriptor(unsigned seg)\n{\n\tstatic struct desc_struct zero_desc;\n\tstruct desc_struct ret = zero_desc;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tseg >>= 3;\n\tmutex_lock(&current->mm->context.lock);\n\tif (current->mm->context.ldt && seg < current->mm->context.ldt->nr_entries)\n\t\tret = current->mm->context.ldt->entries[seg];\n\tmutex_unlock(&current->mm->context.lock);\n#endif\n\treturn ret;\n}\n\n#define SEG_TYPE_WRITABLE\t(1U << 1)\n#define SEG_TYPE_EXPANDS_DOWN\t(1U << 2)\n#define SEG_TYPE_EXECUTE\t(1U << 3)\n#define SEG_TYPE_EXPAND_MASK\t(SEG_TYPE_EXPANDS_DOWN | SEG_TYPE_EXECUTE)\n#define SEG_TYPE_EXECUTE_MASK\t(SEG_TYPE_WRITABLE | SEG_TYPE_EXECUTE)\n\nstatic inline unsigned long seg_get_base(struct desc_struct *d)\n{\n\tunsigned long base = (unsigned long)d->base2 << 24;\n\n\treturn base | ((unsigned long)d->base1 << 16) | d->base0;\n}\n\nstatic inline unsigned long seg_get_limit(struct desc_struct *d)\n{\n\treturn ((unsigned long)d->limit1 << 16) | d->limit0;\n}\n\nstatic inline unsigned long seg_get_granularity(struct desc_struct *d)\n{\n\treturn d->g ? 4096 : 1;\n}\n\nstatic inline bool seg_expands_down(struct desc_struct *d)\n{\n\treturn (d->type & SEG_TYPE_EXPAND_MASK) == SEG_TYPE_EXPANDS_DOWN;\n}\n\nstatic inline bool seg_execute_only(struct desc_struct *d)\n{\n\treturn (d->type & SEG_TYPE_EXECUTE_MASK) == SEG_TYPE_EXECUTE;\n}\n\nstatic inline bool seg_writable(struct desc_struct *d)\n{\n\treturn (d->type & SEG_TYPE_EXECUTE_MASK) == SEG_TYPE_WRITABLE;\n}\n\n#define I387\t\t\t(&current->thread.fpu.fpstate->regs)\n#define FPU_info\t\t(I387->soft.info)\n\n#define FPU_CS\t\t\t(*(unsigned short *) &(FPU_info->regs->cs))\n#define FPU_SS\t\t\t(*(unsigned short *) &(FPU_info->regs->ss))\n#define FPU_DS\t\t\t(*(unsigned short *) &(FPU_info->regs->ds))\n#define FPU_EAX\t\t\t(FPU_info->regs->ax)\n#define FPU_EFLAGS\t\t(FPU_info->regs->flags)\n#define FPU_EIP\t\t\t(FPU_info->regs->ip)\n#define FPU_ORIG_EIP\t\t(FPU_info->___orig_eip)\n\n#define FPU_lookahead           (I387->soft.lookahead)\n\n \n#define no_ip_update\t\t(*(u_char *)&(I387->soft.no_update))\n#define FPU_rm\t\t\t(*(u_char *)&(I387->soft.rm))\n\n \n#define access_limit\t\t(*(u_char *)&(I387->soft.alimit))\n\n#define partial_status\t\t(I387->soft.swd)\n#define control_word\t\t(I387->soft.cwd)\n#define fpu_tag_word\t\t(I387->soft.twd)\n#define registers\t\t(I387->soft.st_space)\n#define top\t\t\t(I387->soft.ftop)\n\n#define instruction_address\t(*(struct address *)&I387->soft.fip)\n#define operand_address\t\t(*(struct address *)&I387->soft.foo)\n\n#define FPU_access_ok(y,z)\tif ( !access_ok(y,z) ) \\\n\t\t\t\tmath_abort(FPU_info,SIGSEGV)\n#define FPU_abort\t\tmath_abort(FPU_info, SIGSEGV)\n#define FPU_copy_from_user(to, from, n)\t\\\n\t\tdo { if (copy_from_user(to, from, n)) FPU_abort; } while (0)\n\n#undef FPU_IGNORE_CODE_SEGV\n#ifdef FPU_IGNORE_CODE_SEGV\n \n#define\tFPU_code_access_ok(z)\n#else\n \n#define\tFPU_code_access_ok(z) FPU_access_ok((void __user *)FPU_EIP,z)\n#endif\n\n#define FPU_get_user(x,y) do { if (get_user((x),(y))) FPU_abort; } while (0)\n#define FPU_put_user(x,y) do { if (put_user((x),(y))) FPU_abort; } while (0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}