{
  "module_name": "fpu_trig.c",
  "hash_id": "1452df456060b5108b18431da6cd66644b97c14192843a6b1112f3d1171d7275",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/fpu_trig.c",
  "human_readable_source": "\n \n\n#include \"fpu_system.h\"\n#include \"exception.h\"\n#include \"fpu_emu.h\"\n#include \"status_w.h\"\n#include \"control_w.h\"\n#include \"reg_constant.h\"\n\nstatic void rem_kernel(unsigned long long st0, unsigned long long *y,\n\t\t       unsigned long long st1, unsigned long long q, int n);\n\n#define BETTER_THAN_486\n\n#define FCOS  4\n\n \n \n \nstatic int trig_arg(FPU_REG *st0_ptr, int even)\n{\n\tFPU_REG tmp;\n\tu_char tmptag;\n\tunsigned long long q;\n\tint old_cw = control_word, saved_status = partial_status;\n\tint tag, st0_tag = TAG_Valid;\n\n\tif (exponent(st0_ptr) >= 63) {\n\t\tpartial_status |= SW_C2;\t \n\t\treturn -1;\n\t}\n\n\tcontrol_word &= ~CW_RC;\n\tcontrol_word |= RC_CHOP;\n\n\tsetpositive(st0_ptr);\n\ttag = FPU_u_div(st0_ptr, &CONST_PI2, &tmp, PR_64_BITS | RC_CHOP | 0x3f,\n\t\t\tSIGN_POS);\n\n\tFPU_round_to_int(&tmp, tag);\t \n\tq = significand(&tmp);\n\tif (q) {\n\t\trem_kernel(significand(st0_ptr),\n\t\t\t   &significand(&tmp),\n\t\t\t   significand(&CONST_PI2),\n\t\t\t   q, exponent(st0_ptr) - exponent(&CONST_PI2));\n\t\tsetexponent16(&tmp, exponent(&CONST_PI2));\n\t\tst0_tag = FPU_normalize(&tmp);\n\t\tFPU_copy_to_reg0(&tmp, st0_tag);\n\t}\n\n\tif ((even && !(q & 1)) || (!even && (q & 1))) {\n\t\tst0_tag =\n\t\t    FPU_sub(REV | LOADED | TAG_Valid, (int)&CONST_PI2,\n\t\t\t    FULL_PRECISION);\n\n#ifdef BETTER_THAN_486\n\t\t \n\t\tif ((exponent(st0_ptr) <= exponent(&CONST_PI2extra) + 64)\n\t\t    || (q > 1)) {\n\t\t\t \n\n\t\t\tsignificand(&tmp) = q + 1;\n\t\t\tsetexponent16(&tmp, 63);\n\t\t\tFPU_normalize(&tmp);\n\t\t\ttmptag =\n\t\t\t    FPU_u_mul(&CONST_PI2extra, &tmp, &tmp,\n\t\t\t\t      FULL_PRECISION, SIGN_POS,\n\t\t\t\t      exponent(&CONST_PI2extra) +\n\t\t\t\t      exponent(&tmp));\n\t\t\tsetsign(&tmp, getsign(&CONST_PI2extra));\n\t\t\tst0_tag = FPU_add(&tmp, tmptag, 0, FULL_PRECISION);\n\t\t\tif (signnegative(st0_ptr)) {\n\t\t\t\t \n\t\t\t\tsetpositive(st0_ptr);\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n#endif  \n\t}\n#ifdef BETTER_THAN_486\n\telse {\n\t\t \n\t\tif (((q > 0)\n\t\t     && (exponent(st0_ptr) <= exponent(&CONST_PI2extra) + 64))\n\t\t    || (q > 1)) {\n\t\t\t \n\n\t\t\tsignificand(&tmp) = q;\n\t\t\tsetexponent16(&tmp, 63);\n\t\t\tFPU_normalize(&tmp);\t \n\t\t\ttmptag =\n\t\t\t    FPU_u_mul(&CONST_PI2extra, &tmp, &tmp,\n\t\t\t\t      FULL_PRECISION, SIGN_POS,\n\t\t\t\t      exponent(&CONST_PI2extra) +\n\t\t\t\t      exponent(&tmp));\n\t\t\tsetsign(&tmp, getsign(&CONST_PI2extra));\n\t\t\tst0_tag = FPU_sub(LOADED | (tmptag & 0x0f), (int)&tmp,\n\t\t\t\t\t  FULL_PRECISION);\n\t\t\tif ((exponent(st0_ptr) == exponent(&CONST_PI2)) &&\n\t\t\t    ((st0_ptr->sigh > CONST_PI2.sigh)\n\t\t\t     || ((st0_ptr->sigh == CONST_PI2.sigh)\n\t\t\t\t && (st0_ptr->sigl > CONST_PI2.sigl)))) {\n\t\t\t\t \n\t\t\t\tst0_tag =\n\t\t\t\t    FPU_sub(REV | LOADED | TAG_Valid,\n\t\t\t\t\t    (int)&CONST_PI2, FULL_PRECISION);\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\tFPU_settag0(st0_tag);\n\tcontrol_word = old_cw;\n\tpartial_status = saved_status & ~SW_C2;\t \n\n\treturn (q & 3) | even;\n}\n\n \nstatic void convert_l2reg(long const *arg, int deststnr)\n{\n\tint tag;\n\tlong num = *arg;\n\tu_char sign;\n\tFPU_REG *dest = &st(deststnr);\n\n\tif (num == 0) {\n\t\tFPU_copy_to_regi(&CONST_Z, TAG_Zero, deststnr);\n\t\treturn;\n\t}\n\n\tif (num > 0) {\n\t\tsign = SIGN_POS;\n\t} else {\n\t\tnum = -num;\n\t\tsign = SIGN_NEG;\n\t}\n\n\tdest->sigh = num;\n\tdest->sigl = 0;\n\tsetexponent16(dest, 31);\n\ttag = FPU_normalize(dest);\n\tFPU_settagi(deststnr, tag);\n\tsetsign(dest, sign);\n\treturn;\n}\n\nstatic void single_arg_error(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tif (st0_tag == TAG_Empty)\n\t\tFPU_stack_underflow();\t \n\telse if (st0_tag == TW_NaN)\n\t\treal_1op_NaN(st0_ptr);\t \n#ifdef PARANOID\n\telse\n\t\tEXCEPTION(EX_INTERNAL | 0x0112);\n#endif  \n}\n\nstatic void single_arg_2_error(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tint isNaN;\n\n\tswitch (st0_tag) {\n\tcase TW_NaN:\n\t\tisNaN = (exponent(st0_ptr) == EXP_OVER)\n\t\t    && (st0_ptr->sigh & 0x80000000);\n\t\tif (isNaN && !(st0_ptr->sigh & 0x40000000)) {\t \n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tif (control_word & CW_Invalid) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tst0_ptr->sigh |= 0x40000000;\n\t\t\t\tpush();\n\t\t\t\tFPU_copy_to_reg0(st0_ptr, TAG_Special);\n\t\t\t}\n\t\t} else if (isNaN) {\n\t\t\t \n\t\t\tpush();\n\t\t\tFPU_copy_to_reg0(st0_ptr, TAG_Special);\n\t\t} else {\n\t\t\t \n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tif (control_word & CW_Invalid) {\n\t\t\t\t \n\t\t\t\tFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\n\t\t\t\tpush();\n\t\t\t\tFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\n\t\t\t}\n\t\t}\n\t\tbreak;\t\t \n#ifdef PARANOID\n\tdefault:\n\t\tEXCEPTION(EX_INTERNAL | 0x0112);\n#endif  \n\t}\n}\n\n \n\nstatic void f2xm1(FPU_REG *st0_ptr, u_char tag)\n{\n\tFPU_REG a;\n\n\tclear_C1();\n\n\tif (tag == TAG_Valid) {\n\t\t \n\t\tif (exponent(st0_ptr) < 0) {\n\t\t      denormal_arg:\n\n\t\t\tFPU_to_exp16(st0_ptr, &a);\n\n\t\t\t \n\t\t\tpoly_2xm1(getsign(st0_ptr), &a, st0_ptr);\n\t\t}\n\t\tset_precision_flag_up();\t \n\t\treturn;\n\t}\n\n\tif (tag == TAG_Zero)\n\t\treturn;\n\n\tif (tag == TAG_Special)\n\t\ttag = FPU_Special(st0_ptr);\n\n\tswitch (tag) {\n\tcase TW_Denormal:\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\t\tgoto denormal_arg;\n\tcase TW_Infinity:\n\t\tif (signnegative(st0_ptr)) {\n\t\t\t \n\t\t\tFPU_copy_to_reg0(&CONST_1, TAG_Valid);\n\t\t\tsetnegative(st0_ptr);\n\t\t}\n\t\treturn;\n\tdefault:\n\t\tsingle_arg_error(st0_ptr, tag);\n\t}\n}\n\nstatic void fptan(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st_new_ptr;\n\tint q;\n\tu_char arg_sign = getsign(st0_ptr);\n\n\t \n\tif (st0_tag == TAG_Empty) {\n\t\tFPU_stack_underflow();\t \n\t\tif (control_word & CW_Invalid) {\n\t\t\tst_new_ptr = &st(-1);\n\t\t\tpush();\n\t\t\tFPU_stack_underflow();\t \n\t\t}\n\t\treturn;\n\t}\n\n\tif (STACK_OVERFLOW) {\n\t\tFPU_stack_overflow();\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Valid) {\n\t\tif (exponent(st0_ptr) > -40) {\n\t\t\tif ((q = trig_arg(st0_ptr, 0)) == -1) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpoly_tan(st0_ptr);\n\t\t\tsetsign(st0_ptr, (q & 1) ^ (arg_sign != 0));\n\t\t\tset_precision_flag_up();\t \n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t      denormal_arg:\n\n\t\t\tFPU_to_exp16(st0_ptr, st0_ptr);\n\n\t\t\tst0_tag =\n\t\t\t    FPU_round(st0_ptr, 1, 0, FULL_PRECISION, arg_sign);\n\t\t\tFPU_settag0(st0_tag);\n\t\t}\n\t\tpush();\n\t\tFPU_copy_to_reg0(&CONST_1, TAG_Valid);\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Zero) {\n\t\tpush();\n\t\tFPU_copy_to_reg0(&CONST_1, TAG_Valid);\n\t\tsetcc(0);\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\n\tif (st0_tag == TW_Denormal) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\n\t\tgoto denormal_arg;\n\t}\n\n\tif (st0_tag == TW_Infinity) {\n\t\t \n\t\tif (arith_invalid(0) >= 0) {\n\t\t\tst_new_ptr = &st(-1);\n\t\t\tpush();\n\t\t\tarith_invalid(0);\n\t\t}\n\t\treturn;\n\t}\n\n\tsingle_arg_2_error(st0_ptr, st0_tag);\n}\n\nstatic void fxtract(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st_new_ptr;\n\tu_char sign;\n\tregister FPU_REG *st1_ptr = st0_ptr;\t \n\n\tif (STACK_OVERFLOW) {\n\t\tFPU_stack_overflow();\n\t\treturn;\n\t}\n\n\tclear_C1();\n\n\tif (st0_tag == TAG_Valid) {\n\t\tlong e;\n\n\t\tpush();\n\t\tsign = getsign(st1_ptr);\n\t\treg_copy(st1_ptr, st_new_ptr);\n\t\tsetexponent16(st_new_ptr, exponent(st_new_ptr));\n\n\t      denormal_arg:\n\n\t\te = exponent16(st_new_ptr);\n\t\tconvert_l2reg(&e, 1);\n\t\tsetexponentpos(st_new_ptr, 0);\n\t\tsetsign(st_new_ptr, sign);\n\t\tFPU_settag0(TAG_Valid);\t \n\t\treturn;\n\t} else if (st0_tag == TAG_Zero) {\n\t\tsign = getsign(st0_ptr);\n\n\t\tif (FPU_divide_by_zero(0, SIGN_NEG) < 0)\n\t\t\treturn;\n\n\t\tpush();\n\t\tFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\n\t\tsetsign(st_new_ptr, sign);\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\n\tif (st0_tag == TW_Denormal) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\n\t\tpush();\n\t\tsign = getsign(st1_ptr);\n\t\tFPU_to_exp16(st1_ptr, st_new_ptr);\n\t\tgoto denormal_arg;\n\t} else if (st0_tag == TW_Infinity) {\n\t\tsign = getsign(st0_ptr);\n\t\tsetpositive(st0_ptr);\n\t\tpush();\n\t\tFPU_copy_to_reg0(&CONST_INF, TAG_Special);\n\t\tsetsign(st_new_ptr, sign);\n\t\treturn;\n\t} else if (st0_tag == TW_NaN) {\n\t\tif (real_1op_NaN(st0_ptr) < 0)\n\t\t\treturn;\n\n\t\tpush();\n\t\tFPU_copy_to_reg0(st0_ptr, TAG_Special);\n\t\treturn;\n\t} else if (st0_tag == TAG_Empty) {\n\t\t \n\t\tif (control_word & EX_Invalid) {\n\t\t\tFPU_stack_underflow();\n\t\t\tpush();\n\t\t\tFPU_stack_underflow();\n\t\t} else\n\t\t\tEXCEPTION(EX_StackUnder);\n\t}\n#ifdef PARANOID\n\telse\n\t\tEXCEPTION(EX_INTERNAL | 0x119);\n#endif  \n}\n\nstatic void fdecstp(void)\n{\n\tclear_C1();\n\ttop--;\n}\n\nstatic void fincstp(void)\n{\n\tclear_C1();\n\ttop++;\n}\n\nstatic void fsqrt_(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tint expon;\n\n\tclear_C1();\n\n\tif (st0_tag == TAG_Valid) {\n\t\tu_char tag;\n\n\t\tif (signnegative(st0_ptr)) {\n\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\texpon = exponent(st0_ptr);\n\n\t      denormal_arg:\n\n\t\tsetexponent16(st0_ptr, (expon & 1));\n\n\t\t \n\t\ttag = wm_sqrt(st0_ptr, 0, 0, control_word, SIGN_POS);\n\t\taddexponent(st0_ptr, expon >> 1);\n\t\tFPU_settag0(tag);\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Zero)\n\t\treturn;\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\n\tif (st0_tag == TW_Infinity) {\n\t\tif (signnegative(st0_ptr))\n\t\t\tarith_invalid(0);\t \n\t\treturn;\n\t} else if (st0_tag == TW_Denormal) {\n\t\tif (signnegative(st0_ptr)) {\n\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\n\t\tFPU_to_exp16(st0_ptr, st0_ptr);\n\n\t\texpon = exponent16(st0_ptr);\n\n\t\tgoto denormal_arg;\n\t}\n\n\tsingle_arg_error(st0_ptr, st0_tag);\n\n}\n\nstatic void frndint_(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tint flags, tag;\n\n\tif (st0_tag == TAG_Valid) {\n\t\tu_char sign;\n\n\t      denormal_arg:\n\n\t\tsign = getsign(st0_ptr);\n\n\t\tif (exponent(st0_ptr) > 63)\n\t\t\treturn;\n\n\t\tif (st0_tag == TW_Denormal) {\n\t\t\tif (denormal_operand() < 0)\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif ((flags = FPU_round_to_int(st0_ptr, st0_tag)))\n\t\t\tset_precision_flag(flags);\n\n\t\tsetexponent16(st0_ptr, 63);\n\t\ttag = FPU_normalize(st0_ptr);\n\t\tsetsign(st0_ptr, sign);\n\t\tFPU_settag0(tag);\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Zero)\n\t\treturn;\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\n\tif (st0_tag == TW_Denormal)\n\t\tgoto denormal_arg;\n\telse if (st0_tag == TW_Infinity)\n\t\treturn;\n\telse\n\t\tsingle_arg_error(st0_ptr, st0_tag);\n}\n\nstatic int f_sin(FPU_REG *st0_ptr, u_char tag)\n{\n\tu_char arg_sign = getsign(st0_ptr);\n\n\tif (tag == TAG_Valid) {\n\t\tint q;\n\n\t\tif (exponent(st0_ptr) > -40) {\n\t\t\tif ((q = trig_arg(st0_ptr, 0)) == -1) {\n\t\t\t\t \n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tpoly_sine(st0_ptr);\n\n\t\t\tif (q & 2)\n\t\t\t\tchangesign(st0_ptr);\n\n\t\t\tsetsign(st0_ptr, getsign(st0_ptr) ^ arg_sign);\n\n\t\t\t \n\t\t\tset_precision_flag_up();\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tset_precision_flag_up();\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tag == TAG_Zero) {\n\t\tsetcc(0);\n\t\treturn 0;\n\t}\n\n\tif (tag == TAG_Special)\n\t\ttag = FPU_Special(st0_ptr);\n\n\tif (tag == TW_Denormal) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn 1;\n\n\t\t \n\t\t \n\t\tFPU_to_exp16(st0_ptr, st0_ptr);\n\n\t\ttag = FPU_round(st0_ptr, 1, 0, FULL_PRECISION, arg_sign);\n\n\t\tFPU_settag0(tag);\n\n\t\treturn 0;\n\t} else if (tag == TW_Infinity) {\n\t\t \n\t\tarith_invalid(0);\n\t\treturn 1;\n\t} else {\n\t\tsingle_arg_error(st0_ptr, tag);\n\t\treturn 1;\n\t}\n}\n\nstatic void fsin(FPU_REG *st0_ptr, u_char tag)\n{\n\tf_sin(st0_ptr, tag);\n}\n\nstatic int f_cos(FPU_REG *st0_ptr, u_char tag)\n{\n\tu_char st0_sign;\n\n\tst0_sign = getsign(st0_ptr);\n\n\tif (tag == TAG_Valid) {\n\t\tint q;\n\n\t\tif (exponent(st0_ptr) > -40) {\n\t\t\tif ((exponent(st0_ptr) < 0)\n\t\t\t    || ((exponent(st0_ptr) == 0)\n\t\t\t\t&& (significand(st0_ptr) <=\n\t\t\t\t    0xc90fdaa22168c234LL))) {\n\t\t\t\tpoly_cos(st0_ptr);\n\n\t\t\t\t \n\t\t\t\tset_precision_flag_down();\n\n\t\t\t\treturn 0;\n\t\t\t} else if ((q = trig_arg(st0_ptr, FCOS)) != -1) {\n\t\t\t\tpoly_sine(st0_ptr);\n\n\t\t\t\tif ((q + 1) & 2)\n\t\t\t\t\tchangesign(st0_ptr);\n\n\t\t\t\t \n\t\t\t\tset_precision_flag_down();\n\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t      denormal_arg:\n\n\t\t\tsetcc(0);\n\t\t\tFPU_copy_to_reg0(&CONST_1, TAG_Valid);\n#ifdef PECULIAR_486\n\t\t\tset_precision_flag_down();\t \n#else\n\t\t\tset_precision_flag_up();\t \n#endif  \n\t\t\treturn 0;\n\t\t}\n\t} else if (tag == TAG_Zero) {\n\t\tFPU_copy_to_reg0(&CONST_1, TAG_Valid);\n\t\tsetcc(0);\n\t\treturn 0;\n\t}\n\n\tif (tag == TAG_Special)\n\t\ttag = FPU_Special(st0_ptr);\n\n\tif (tag == TW_Denormal) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn 1;\n\n\t\tgoto denormal_arg;\n\t} else if (tag == TW_Infinity) {\n\t\t \n\t\tarith_invalid(0);\n\t\treturn 1;\n\t} else {\n\t\tsingle_arg_error(st0_ptr, tag);\t \n\t\treturn 1;\n\t}\n}\n\nstatic void fcos(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tf_cos(st0_ptr, st0_tag);\n}\n\nstatic void fsincos(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st_new_ptr;\n\tFPU_REG arg;\n\tu_char tag;\n\n\t \n\tif (st0_tag == TAG_Empty) {\n\t\tFPU_stack_underflow();\t \n\t\tif (control_word & CW_Invalid) {\n\t\t\tst_new_ptr = &st(-1);\n\t\t\tpush();\n\t\t\tFPU_stack_underflow();\t \n\t\t}\n\t\treturn;\n\t}\n\n\tif (STACK_OVERFLOW) {\n\t\tFPU_stack_overflow();\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\ttag = FPU_Special(st0_ptr);\n\telse\n\t\ttag = st0_tag;\n\n\tif (tag == TW_NaN) {\n\t\tsingle_arg_2_error(st0_ptr, TW_NaN);\n\t\treturn;\n\t} else if (tag == TW_Infinity) {\n\t\t \n\t\tif (arith_invalid(0) >= 0) {\n\t\t\t \n\t\t\tpush();\n\t\t\tarith_invalid(0);\n\t\t}\n\t\treturn;\n\t}\n\n\treg_copy(st0_ptr, &arg);\n\tif (!f_sin(st0_ptr, st0_tag)) {\n\t\tpush();\n\t\tFPU_copy_to_reg0(&arg, st0_tag);\n\t\tf_cos(&st(0), st0_tag);\n\t} else {\n\t\t \n\t\tFPU_copy_to_reg0(&arg, st0_tag);\n\t}\n}\n\n \n \n\n \nstatic void rem_kernel(unsigned long long st0, unsigned long long *y,\n\t\t       unsigned long long st1, unsigned long long q, int n)\n{\n\tint dummy;\n\tunsigned long long x;\n\n\tx = st0 << n;\n\n\t \n\n\t \n\tasm volatile (\"mull %4; subl %%eax,%0; sbbl %%edx,%1\":\"=m\"\n\t\t      (((unsigned *)&x)[0]), \"=m\"(((unsigned *)&x)[1]),\n\t\t      \"=a\"(dummy)\n\t\t      :\"2\"(((unsigned *)&st1)[0]), \"m\"(((unsigned *)&q)[0])\n\t\t      :\"%dx\");\n\t \n\tasm volatile (\"mull %3; subl %%eax,%0\":\"=m\" (((unsigned *)&x)[1]),\n\t\t      \"=a\"(dummy)\n\t\t      :\"1\"(((unsigned *)&st1)[1]), \"m\"(((unsigned *)&q)[0])\n\t\t      :\"%dx\");\n\t \n\tasm volatile (\"mull %3; subl %%eax,%0\":\"=m\" (((unsigned *)&x)[1]),\n\t\t      \"=a\"(dummy)\n\t\t      :\"1\"(((unsigned *)&st1)[0]), \"m\"(((unsigned *)&q)[1])\n\t\t      :\"%dx\");\n\n\t*y = x;\n}\n\n \n \nstatic void do_fprem(FPU_REG *st0_ptr, u_char st0_tag, int round)\n{\n\tFPU_REG *st1_ptr = &st(1);\n\tu_char st1_tag = FPU_gettagi(1);\n\n\tif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\n\t\tFPU_REG tmp, st0, st1;\n\t\tu_char st0_sign, st1_sign;\n\t\tu_char tmptag;\n\t\tint tag;\n\t\tint old_cw;\n\t\tint expdif;\n\t\tlong long q;\n\t\tunsigned short saved_status;\n\t\tint cc;\n\n\t      fprem_valid:\n\t\t \n\t\tst0_sign = FPU_to_exp16(st0_ptr, &st0);\n\t\tst1_sign = FPU_to_exp16(st1_ptr, &st1);\n\t\texpdif = exponent16(&st0) - exponent16(&st1);\n\n\t\told_cw = control_word;\n\t\tcc = 0;\n\n\t\t \n\t\tsaved_status = partial_status;\n\t\tcontrol_word &= ~CW_RC;\n\t\tcontrol_word |= RC_CHOP;\n\n\t\tif (expdif < 64) {\n\t\t\t \n\n\t\t\tif (expdif > -2) {\n\t\t\t\tu_char sign = st0_sign ^ st1_sign;\n\t\t\t\ttag = FPU_u_div(&st0, &st1, &tmp,\n\t\t\t\t\t\tPR_64_BITS | RC_CHOP | 0x3f,\n\t\t\t\t\t\tsign);\n\t\t\t\tsetsign(&tmp, sign);\n\n\t\t\t\tif (exponent(&tmp) >= 0) {\n\t\t\t\t\tFPU_round_to_int(&tmp, tag);\t \n\t\t\t\t\tq = significand(&tmp);\n\n\t\t\t\t\trem_kernel(significand(&st0),\n\t\t\t\t\t\t   &significand(&tmp),\n\t\t\t\t\t\t   significand(&st1),\n\t\t\t\t\t\t   q, expdif);\n\n\t\t\t\t\tsetexponent16(&tmp, exponent16(&st1));\n\t\t\t\t} else {\n\t\t\t\t\treg_copy(&st0, &tmp);\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\n\t\t\t\tif ((round == RC_RND)\n\t\t\t\t    && (tmp.sigh & 0xc0000000)) {\n\t\t\t\t\t \n\t\t\t\t\tunsigned long long x;\n\t\t\t\t\texpdif =\n\t\t\t\t\t    exponent16(&st1) - exponent16(&tmp);\n\t\t\t\t\tif (expdif <= 1) {\n\t\t\t\t\t\tif (expdif == 0)\n\t\t\t\t\t\t\tx = significand(&st1) -\n\t\t\t\t\t\t\t    significand(&tmp);\n\t\t\t\t\t\telse\t \n\t\t\t\t\t\t\tx = (significand(&st1)\n\t\t\t\t\t\t\t     << 1) -\n\t\t\t\t\t\t\t    significand(&tmp);\n\t\t\t\t\t\tif ((x < significand(&tmp)) ||\n\t\t\t\t\t\t     \n\t\t\t\t\t\t    ((x == significand(&tmp))\n\t\t\t\t\t\t     && (q & 1))) {\n\t\t\t\t\t\t\tst0_sign = !st0_sign;\n\t\t\t\t\t\t\tsignificand(&tmp) = x;\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (q & 4)\n\t\t\t\t\tcc |= SW_C0;\n\t\t\t\tif (q & 2)\n\t\t\t\t\tcc |= SW_C3;\n\t\t\t\tif (q & 1)\n\t\t\t\t\tcc |= SW_C1;\n\t\t\t} else {\n\t\t\t\tcontrol_word = old_cw;\n\t\t\t\tsetcc(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tint exp_1, N;\n\t\t\tu_char sign;\n\n\t\t\t \n\t\t\t \n\t\t\treg_copy(&st0, &tmp);\n\t\t\ttmptag = st0_tag;\n\t\t\tN = (expdif & 0x0000001f) + 32;\t \n\t\t\tsetexponent16(&tmp, N);\n\t\t\texp_1 = exponent16(&st1);\n\t\t\tsetexponent16(&st1, 0);\n\t\t\texpdif -= N;\n\n\t\t\tsign = getsign(&tmp) ^ st1_sign;\n\t\t\ttag =\n\t\t\t    FPU_u_div(&tmp, &st1, &tmp,\n\t\t\t\t      PR_64_BITS | RC_CHOP | 0x3f, sign);\n\t\t\tsetsign(&tmp, sign);\n\n\t\t\tFPU_round_to_int(&tmp, tag);\t \n\n\t\t\trem_kernel(significand(&st0),\n\t\t\t\t   &significand(&tmp),\n\t\t\t\t   significand(&st1),\n\t\t\t\t   significand(&tmp), exponent(&tmp)\n\t\t\t    );\n\t\t\tsetexponent16(&tmp, exp_1 + expdif);\n\n\t\t\t \n\t\t\tif (!(tmp.sigh | tmp.sigl)) {\n\t\t\t\t \n\t\t\t\tcontrol_word = old_cw;\n\t\t\t\tpartial_status = saved_status;\n\t\t\t\tFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\n\t\t\t\tsetsign(&st0, st0_sign);\n#ifdef PECULIAR_486\n\t\t\t\tsetcc(SW_C2);\n#else\n\t\t\t\tsetcc(0);\n#endif  \n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcc = SW_C2;\n\t\t}\n\n\t\tcontrol_word = old_cw;\n\t\tpartial_status = saved_status;\n\t\ttag = FPU_normalize_nuo(&tmp);\n\t\treg_copy(&tmp, st0_ptr);\n\n\t\t \n\t\tif ((exponent16(&tmp) <= EXP_UNDER) && (tag != TAG_Zero)\n\t\t    && !(control_word & CW_Underflow)) {\n\t\t\tsetcc(cc);\n\t\t\ttag = arith_underflow(st0_ptr);\n\t\t\tsetsign(st0_ptr, st0_sign);\n\t\t\tFPU_settag0(tag);\n\t\t\treturn;\n\t\t} else if ((exponent16(&tmp) > EXP_UNDER) || (tag == TAG_Zero)) {\n\t\t\tstdexp(st0_ptr);\n\t\t\tsetsign(st0_ptr, st0_sign);\n\t\t} else {\n\t\t\ttag =\n\t\t\t    FPU_round(st0_ptr, 0, 0, FULL_PRECISION, st0_sign);\n\t\t}\n\t\tFPU_settag0(tag);\n\t\tsetcc(cc);\n\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\tif (st1_tag == TAG_Special)\n\t\tst1_tag = FPU_Special(st1_ptr);\n\n\tif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\t\tgoto fprem_valid;\n\t} else if ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\n\t\tFPU_stack_underflow();\n\t\treturn;\n\t} else if (st0_tag == TAG_Zero) {\n\t\tif (st1_tag == TAG_Valid) {\n\t\t\tsetcc(0);\n\t\t\treturn;\n\t\t} else if (st1_tag == TW_Denormal) {\n\t\t\tif (denormal_operand() < 0)\n\t\t\t\treturn;\n\t\t\tsetcc(0);\n\t\t\treturn;\n\t\t} else if (st1_tag == TAG_Zero) {\n\t\t\tarith_invalid(0);\n\t\t\treturn;\n\t\t}  \n\t\telse if (st1_tag == TW_Infinity) {\n\t\t\tsetcc(0);\n\t\t\treturn;\n\t\t}\n\t} else if ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\n\t\tif (st1_tag == TAG_Zero) {\n\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\t\t} else if (st1_tag != TW_NaN) {\n\t\t\tif (((st0_tag == TW_Denormal)\n\t\t\t     || (st1_tag == TW_Denormal))\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tif (st1_tag == TW_Infinity) {\n\t\t\t\t \n\t\t\t\tsetcc(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else if (st0_tag == TW_Infinity) {\n\t\tif (st1_tag != TW_NaN) {\n\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n#ifdef PARANOID\n\tif ((st0_tag != TW_NaN) && (st1_tag != TW_NaN))\n\t\tEXCEPTION(EX_INTERNAL | 0x118);\n#endif  \n\n\treal_2op_NaN(st1_ptr, st1_tag, 0, st1_ptr);\n\n}\n\n \nstatic void fyl2x(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st1_ptr = &st(1), exponent;\n\tu_char st1_tag = FPU_gettagi(1);\n\tu_char sign;\n\tint e, tag;\n\n\tclear_C1();\n\n\tif ((st0_tag == TAG_Valid) && (st1_tag == TAG_Valid)) {\n\t      both_valid:\n\t\t \n\t\tif (signpositive(st0_ptr)) {\n\t\t\tif (st0_tag == TW_Denormal)\n\t\t\t\tFPU_to_exp16(st0_ptr, st0_ptr);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tsetexponent16(st0_ptr, exponent(st0_ptr));\n\n\t\t\tif ((st0_ptr->sigh == 0x80000000)\n\t\t\t    && (st0_ptr->sigl == 0)) {\n\t\t\t\t \n\t\t\t\tu_char esign;\n\t\t\t\te = exponent16(st0_ptr);\n\t\t\t\tif (e >= 0) {\n\t\t\t\t\texponent.sigh = e;\n\t\t\t\t\tesign = SIGN_POS;\n\t\t\t\t} else {\n\t\t\t\t\texponent.sigh = -e;\n\t\t\t\t\tesign = SIGN_NEG;\n\t\t\t\t}\n\t\t\t\texponent.sigl = 0;\n\t\t\t\tsetexponent16(&exponent, 31);\n\t\t\t\ttag = FPU_normalize_nuo(&exponent);\n\t\t\t\tstdexp(&exponent);\n\t\t\t\tsetsign(&exponent, esign);\n\t\t\t\ttag =\n\t\t\t\t    FPU_mul(&exponent, tag, 1, FULL_PRECISION);\n\t\t\t\tif (tag >= 0)\n\t\t\t\t\tFPU_settagi(1, tag);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsign = getsign(st1_ptr);\n\t\t\t\tif (st1_tag == TW_Denormal)\n\t\t\t\t\tFPU_to_exp16(st1_ptr, st1_ptr);\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tsetexponent16(st1_ptr,\n\t\t\t\t\t\t      exponent(st1_ptr));\n\t\t\t\tpoly_l2(st0_ptr, st1_ptr, sign);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\treturn;\n\t\t}\n\n\t\tFPU_pop();\n\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\tif (st1_tag == TAG_Special)\n\t\tst1_tag = FPU_Special(st1_ptr);\n\n\tif ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\n\t\tFPU_stack_underflow_pop(1);\n\t\treturn;\n\t} else if ((st0_tag <= TW_Denormal) && (st1_tag <= TW_Denormal)) {\n\t\tif (st0_tag == TAG_Zero) {\n\t\t\tif (st1_tag == TAG_Zero) {\n\t\t\t\t \n\t\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tu_char sign;\n\t\t\t\tsign = getsign(st1_ptr) ^ SIGN_NEG;\n\t\t\t\tif (FPU_divide_by_zero(1, sign) < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tsetsign(st1_ptr, sign);\n\t\t\t}\n\t\t} else if (st1_tag == TAG_Zero) {\n\t\t\t \n\t\t\t \n\t\t\tsign = getsign(st1_ptr);\n\n\t\t\tif (signnegative(st0_ptr)) {\n\t\t\t\t \n\t\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\t\treturn;\n\t\t\t} else if ((st0_tag == TW_Denormal)\n\t\t\t\t   && (denormal_operand() < 0))\n\t\t\t\treturn;\n\t\t\telse {\n\t\t\t\tif (exponent(st0_ptr) < 0)\n\t\t\t\t\tsign ^= SIGN_NEG;\n\n\t\t\t\tFPU_copy_to_reg1(&CONST_Z, TAG_Zero);\n\t\t\t\tsetsign(st1_ptr, sign);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (denormal_operand() < 0)\n\t\t\t\treturn;\n\t\t\tgoto both_valid;\n\t\t}\n\t} else if ((st0_tag == TW_NaN) || (st1_tag == TW_NaN)) {\n\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\n\t\t\treturn;\n\t}\n\t \n\telse if (st0_tag == TW_Infinity) {\n\t\tif ((signnegative(st0_ptr)) || (st1_tag == TAG_Zero)) {\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tu_char sign = getsign(st1_ptr);\n\n\t\t\tif ((st1_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tFPU_copy_to_reg1(&CONST_INF, TAG_Special);\n\t\t\tsetsign(st1_ptr, sign);\n\t\t}\n\t}\n\t \n\telse if (((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal))\n\t\t && (signpositive(st0_ptr))) {\n\t\tif (exponent(st0_ptr) >= 0) {\n\t\t\tif ((exponent(st0_ptr) == 0) &&\n\t\t\t    (st0_ptr->sigh == 0x80000000) &&\n\t\t\t    (st0_ptr->sigl == 0)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\t \n\n\t\t\tif ((st0_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tchangesign(st1_ptr);\n\t\t}\n\t} else {\n\t\t \n\t\tif (st0_tag == TAG_Zero) {\n\t\t\t \n\n#ifndef PECULIAR_486\n\t\t\tsign = getsign(st1_ptr);\n\t\t\tif (FPU_divide_by_zero(1, sign) < 0)\n\t\t\t\treturn;\n#endif  \n\n\t\t\tchangesign(st1_ptr);\n\t\t} else if (arith_invalid(1) < 0)\t \n\t\t\treturn;\n\t}\n\n\tFPU_pop();\n}\n\nstatic void fpatan(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st1_ptr = &st(1);\n\tu_char st1_tag = FPU_gettagi(1);\n\tint tag;\n\n\tclear_C1();\n\tif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\n\t      valid_atan:\n\n\t\tpoly_atan(st0_ptr, st0_tag, st1_ptr, st1_tag);\n\n\t\tFPU_pop();\n\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\tif (st1_tag == TAG_Special)\n\t\tst1_tag = FPU_Special(st1_ptr);\n\n\tif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\n\t\tgoto valid_atan;\n\t} else if ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\n\t\tFPU_stack_underflow_pop(1);\n\t\treturn;\n\t} else if ((st0_tag == TW_NaN) || (st1_tag == TW_NaN)) {\n\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) >= 0)\n\t\t\tFPU_pop();\n\t\treturn;\n\t} else if ((st0_tag == TW_Infinity) || (st1_tag == TW_Infinity)) {\n\t\tu_char sign = getsign(st1_ptr);\n\t\tif (st0_tag == TW_Infinity) {\n\t\t\tif (st1_tag == TW_Infinity) {\n\t\t\t\tif (signpositive(st0_ptr)) {\n\t\t\t\t\tFPU_copy_to_reg1(&CONST_PI4, TAG_Valid);\n\t\t\t\t} else {\n\t\t\t\t\tsetpositive(st1_ptr);\n\t\t\t\t\ttag =\n\t\t\t\t\t    FPU_u_add(&CONST_PI4, &CONST_PI2,\n\t\t\t\t\t\t      st1_ptr, FULL_PRECISION,\n\t\t\t\t\t\t      SIGN_POS,\n\t\t\t\t\t\t      exponent(&CONST_PI4),\n\t\t\t\t\t\t      exponent(&CONST_PI2));\n\t\t\t\t\tif (tag >= 0)\n\t\t\t\t\t\tFPU_settagi(1, tag);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((st1_tag == TW_Denormal)\n\t\t\t\t    && (denormal_operand() < 0))\n\t\t\t\t\treturn;\n\n\t\t\t\tif (signpositive(st0_ptr)) {\n\t\t\t\t\tFPU_copy_to_reg1(&CONST_Z, TAG_Zero);\n\t\t\t\t\tsetsign(st1_ptr, sign);\t \n\t\t\t\t\tFPU_pop();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tFPU_copy_to_reg1(&CONST_PI, TAG_Valid);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((st0_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tFPU_copy_to_reg1(&CONST_PI2, TAG_Valid);\n\t\t}\n\t\tsetsign(st1_ptr, sign);\n\t} else if (st1_tag == TAG_Zero) {\n\t\t \n\t\tu_char sign = getsign(st1_ptr);\n\n\t\tif ((st0_tag == TW_Denormal) && (denormal_operand() < 0))\n\t\t\treturn;\n\n\t\tif (signpositive(st0_ptr)) {\n\t\t\t \n\t\t\tFPU_pop();\n\t\t\treturn;\n\t\t}\n\n\t\tFPU_copy_to_reg1(&CONST_PI, TAG_Valid);\n\t\tsetsign(st1_ptr, sign);\n\t} else if (st0_tag == TAG_Zero) {\n\t\t \n\t\tu_char sign = getsign(st1_ptr);\n\n\t\tif ((st1_tag == TW_Denormal) && (denormal_operand() < 0))\n\t\t\treturn;\n\n\t\tFPU_copy_to_reg1(&CONST_PI2, TAG_Valid);\n\t\tsetsign(st1_ptr, sign);\n\t}\n#ifdef PARANOID\n\telse\n\t\tEXCEPTION(EX_INTERNAL | 0x125);\n#endif  \n\n\tFPU_pop();\n\tset_precision_flag_up();\t \n}\n\nstatic void fprem(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tdo_fprem(st0_ptr, st0_tag, RC_CHOP);\n}\n\nstatic void fprem1(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tdo_fprem(st0_ptr, st0_tag, RC_RND);\n}\n\nstatic void fyl2xp1(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tu_char sign, sign1;\n\tFPU_REG *st1_ptr = &st(1), a, b;\n\tu_char st1_tag = FPU_gettagi(1);\n\n\tclear_C1();\n\tif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\n\t      valid_yl2xp1:\n\n\t\tsign = getsign(st0_ptr);\n\t\tsign1 = getsign(st1_ptr);\n\n\t\tFPU_to_exp16(st0_ptr, &a);\n\t\tFPU_to_exp16(st1_ptr, &b);\n\n\t\tif (poly_l2p1(sign, sign1, &a, &b, st1_ptr))\n\t\t\treturn;\n\n\t\tFPU_pop();\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\tif (st1_tag == TAG_Special)\n\t\tst1_tag = FPU_Special(st1_ptr);\n\n\tif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\n\t    || ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\n\t\tif (denormal_operand() < 0)\n\t\t\treturn;\n\n\t\tgoto valid_yl2xp1;\n\t} else if ((st0_tag == TAG_Empty) | (st1_tag == TAG_Empty)) {\n\t\tFPU_stack_underflow_pop(1);\n\t\treturn;\n\t} else if (st0_tag == TAG_Zero) {\n\t\tswitch (st1_tag) {\n\t\tcase TW_Denormal:\n\t\t\tif (denormal_operand() < 0)\n\t\t\t\treturn;\n\t\t\tfallthrough;\n\t\tcase TAG_Zero:\n\t\tcase TAG_Valid:\n\t\t\tsetsign(st0_ptr, getsign(st0_ptr) ^ getsign(st1_ptr));\n\t\t\tFPU_copy_to_reg1(st0_ptr, st0_tag);\n\t\t\tbreak;\n\n\t\tcase TW_Infinity:\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\treturn;\n\t\t\tbreak;\n\n\t\tcase TW_NaN:\n\t\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\n\t\t\t\treturn;\n\t\t\tbreak;\n\n\t\tdefault:\n#ifdef PARANOID\n\t\t\tEXCEPTION(EX_INTERNAL | 0x116);\n\t\t\treturn;\n#endif  \n\t\t\tbreak;\n\t\t}\n\t} else if ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\n\t\tswitch (st1_tag) {\n\t\tcase TAG_Zero:\n\t\t\tif (signnegative(st0_ptr)) {\n\t\t\t\tif (exponent(st0_ptr) >= 0) {\n\t\t\t\t\t \n#ifdef PECULIAR_486\t\t \n\t\t\t\t\tchangesign(st1_ptr);\n#else\n\t\t\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\t\t\treturn;\n#endif  \n\t\t\t\t} else if ((st0_tag == TW_Denormal)\n\t\t\t\t\t   && (denormal_operand() < 0))\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tchangesign(st1_ptr);\n\t\t\t} else if ((st0_tag == TW_Denormal)\n\t\t\t\t   && (denormal_operand() < 0))\n\t\t\t\treturn;\n\t\t\tbreak;\n\n\t\tcase TW_Infinity:\n\t\t\tif (signnegative(st0_ptr)) {\n\t\t\t\tif ((exponent(st0_ptr) >= 0) &&\n\t\t\t\t    !((st0_ptr->sigh == 0x80000000) &&\n\t\t\t\t      (st0_ptr->sigl == 0))) {\n\t\t\t\t\t \n#ifdef PECULIAR_486\t\t \n\t\t\t\t\tchangesign(st1_ptr);\n#else\n\t\t\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\t\t\treturn;\n#endif  \n\t\t\t\t} else if ((st0_tag == TW_Denormal)\n\t\t\t\t\t   && (denormal_operand() < 0))\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tchangesign(st1_ptr);\n\t\t\t} else if ((st0_tag == TW_Denormal)\n\t\t\t\t   && (denormal_operand() < 0))\n\t\t\t\treturn;\n\t\t\tbreak;\n\n\t\tcase TW_NaN:\n\t\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\n\t\t\t\treturn;\n\t\t}\n\n\t} else if (st0_tag == TW_NaN) {\n\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\n\t\t\treturn;\n\t} else if (st0_tag == TW_Infinity) {\n\t\tif (st1_tag == TW_NaN) {\n\t\t\tif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\n\t\t\t\treturn;\n\t\t} else if (signnegative(st0_ptr)) {\n#ifndef PECULIAR_486\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\t \n\t\t\t\treturn;\n#endif  \n\t\t\tif ((st1_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n#ifdef PECULIAR_486\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\t \n\t\t\t\treturn;\n#endif  \n\t\t} else if (st1_tag == TAG_Zero) {\n\t\t\t \n\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\telse if ((st1_tag == TW_Denormal) && (denormal_operand() < 0))\n\t\t\treturn;\n\n\t\t \n\t\telse {\n\t\t\tu_char sign = getsign(st1_ptr);\n\t\t\tFPU_copy_to_reg1(&CONST_INF, TAG_Special);\n\t\t\tsetsign(st1_ptr, sign);\n\t\t}\n\t}\n#ifdef PARANOID\n\telse {\n\t\tEXCEPTION(EX_INTERNAL | 0x117);\n\t\treturn;\n\t}\n#endif  \n\n\tFPU_pop();\n\treturn;\n\n}\n\nstatic void fscale(FPU_REG *st0_ptr, u_char st0_tag)\n{\n\tFPU_REG *st1_ptr = &st(1);\n\tu_char st1_tag = FPU_gettagi(1);\n\tint old_cw = control_word;\n\tu_char sign = getsign(st0_ptr);\n\n\tclear_C1();\n\tif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\n\t\tlong scale;\n\t\tFPU_REG tmp;\n\n\t\t \n\t\tsetexponent16(st0_ptr, exponent(st0_ptr));\n\n\t      valid_scale:\n\n\t\tif (exponent(st1_ptr) > 30) {\n\t\t\t \n\n\t\t\tif (signpositive(st1_ptr)) {\n\t\t\t\tEXCEPTION(EX_Overflow);\n\t\t\t\tFPU_copy_to_reg0(&CONST_INF, TAG_Special);\n\t\t\t} else {\n\t\t\t\tEXCEPTION(EX_Underflow);\n\t\t\t\tFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\n\t\t\t}\n\t\t\tsetsign(st0_ptr, sign);\n\t\t\treturn;\n\t\t}\n\n\t\tcontrol_word &= ~CW_RC;\n\t\tcontrol_word |= RC_CHOP;\n\t\treg_copy(st1_ptr, &tmp);\n\t\tFPU_round_to_int(&tmp, st1_tag);\t \n\t\tcontrol_word = old_cw;\n\t\tscale = signnegative(st1_ptr) ? -tmp.sigl : tmp.sigl;\n\t\tscale += exponent16(st0_ptr);\n\n\t\tsetexponent16(st0_ptr, scale);\n\n\t\t \n\t\tFPU_round(st0_ptr, 0, 0, control_word, sign);\n\n\t\treturn;\n\t}\n\n\tif (st0_tag == TAG_Special)\n\t\tst0_tag = FPU_Special(st0_ptr);\n\tif (st1_tag == TAG_Special)\n\t\tst1_tag = FPU_Special(st1_ptr);\n\n\tif ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\n\t\tswitch (st1_tag) {\n\t\tcase TAG_Valid:\n\t\t\t \n\t\t\tif ((st0_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tFPU_to_exp16(st0_ptr, st0_ptr);\t \n\t\t\tgoto valid_scale;\n\n\t\tcase TAG_Zero:\n\t\t\tif (st0_tag == TW_Denormal)\n\t\t\t\tdenormal_operand();\n\t\t\treturn;\n\n\t\tcase TW_Denormal:\n\t\t\tdenormal_operand();\n\t\t\treturn;\n\n\t\tcase TW_Infinity:\n\t\t\tif ((st0_tag == TW_Denormal)\n\t\t\t    && (denormal_operand() < 0))\n\t\t\t\treturn;\n\n\t\t\tif (signpositive(st1_ptr))\n\t\t\t\tFPU_copy_to_reg0(&CONST_INF, TAG_Special);\n\t\t\telse\n\t\t\t\tFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\n\t\t\tsetsign(st0_ptr, sign);\n\t\t\treturn;\n\n\t\tcase TW_NaN:\n\t\t\treal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\n\t\t\treturn;\n\t\t}\n\t} else if (st0_tag == TAG_Zero) {\n\t\tswitch (st1_tag) {\n\t\tcase TAG_Valid:\n\t\tcase TAG_Zero:\n\t\t\treturn;\n\n\t\tcase TW_Denormal:\n\t\t\tdenormal_operand();\n\t\t\treturn;\n\n\t\tcase TW_Infinity:\n\t\t\tif (signpositive(st1_ptr))\n\t\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\n\t\tcase TW_NaN:\n\t\t\treal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\n\t\t\treturn;\n\t\t}\n\t} else if (st0_tag == TW_Infinity) {\n\t\tswitch (st1_tag) {\n\t\tcase TAG_Valid:\n\t\tcase TAG_Zero:\n\t\t\treturn;\n\n\t\tcase TW_Denormal:\n\t\t\tdenormal_operand();\n\t\t\treturn;\n\n\t\tcase TW_Infinity:\n\t\t\tif (signnegative(st1_ptr))\n\t\t\t\tarith_invalid(0);\t \n\t\t\treturn;\n\n\t\tcase TW_NaN:\n\t\t\treal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\n\t\t\treturn;\n\t\t}\n\t} else if (st0_tag == TW_NaN) {\n\t\tif (st1_tag != TAG_Empty) {\n\t\t\treal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\n\t\t\treturn;\n\t\t}\n\t}\n#ifdef PARANOID\n\tif (!((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty))) {\n\t\tEXCEPTION(EX_INTERNAL | 0x115);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tFPU_stack_underflow();\n\n}\n\n \n\nstatic FUNC_ST0 const trig_table_a[] = {\n\tf2xm1, fyl2x, fptan, fpatan,\n\tfxtract, fprem1, (FUNC_ST0) fdecstp, (FUNC_ST0) fincstp\n};\n\nvoid FPU_triga(void)\n{\n\t(trig_table_a[FPU_rm]) (&st(0), FPU_gettag0());\n}\n\nstatic FUNC_ST0 const trig_table_b[] = {\n\tfprem, fyl2xp1, fsqrt_, fsincos, frndint_, fscale, fsin, fcos\n};\n\nvoid FPU_trigb(void)\n{\n\t(trig_table_b[FPU_rm]) (&st(0), FPU_gettag0());\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}