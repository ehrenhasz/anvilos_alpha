{
  "module_name": "poly_2xm1.c",
  "hash_id": "2a8038e41ea93cb3c24f7edb8c1aa15fdc14804a6798698c83e44fe05574b1bd",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/poly_2xm1.c",
  "human_readable_source": "\n \n\n#include \"exception.h\"\n#include \"reg_constant.h\"\n#include \"fpu_emu.h\"\n#include \"fpu_system.h\"\n#include \"control_w.h\"\n#include \"poly.h\"\n\n#define\tHIPOWER\t11\nstatic const unsigned long long lterms[HIPOWER] = {\n\t0x0000000000000000LL,\t \n\t0xf5fdeffc162c7543LL,\n\t0x1c6b08d704a0bfa6LL,\n\t0x0276556df749cc21LL,\n\t0x002bb0ffcf14f6b8LL,\n\t0x0002861225ef751cLL,\n\t0x00001ffcbfcd5422LL,\n\t0x00000162c005d5f1LL,\n\t0x0000000da96ccb1bLL,\n\t0x0000000078d1b897LL,\n\t0x000000000422b029LL\n};\n\nstatic const Xsig hiterm = MK_XSIG(0xb17217f7, 0xd1cf79ab, 0xc8a39194);\n\n \nstatic const Xsig shiftterm0 = MK_XSIG(0, 0, 0);\nstatic const Xsig shiftterm1 = MK_XSIG(0x9837f051, 0x8db8a96f, 0x46ad2318);\nstatic const Xsig shiftterm2 = MK_XSIG(0xb504f333, 0xf9de6484, 0x597d89b3);\nstatic const Xsig shiftterm3 = MK_XSIG(0xd744fcca, 0xd69d6af4, 0x39a68bb9);\n\nstatic const Xsig *shiftterm[] = { &shiftterm0, &shiftterm1,\n\t&shiftterm2, &shiftterm3\n};\n\n \nint poly_2xm1(u_char sign, FPU_REG *arg, FPU_REG *result)\n{\n\tlong int exponent, shift;\n\tunsigned long long Xll;\n\tXsig accumulator, Denom, argSignif;\n\tu_char tag;\n\n\texponent = exponent16(arg);\n\n#ifdef PARANOID\n\tif (exponent >= 0) {\t \n\t\t \n\t\tEXCEPTION(EX_INTERNAL | 0x127);\n\t\treturn 1;\n\t}\n#endif  \n\n\targSignif.lsw = 0;\n\tXSIG_LL(argSignif) = Xll = significand(arg);\n\n\tif (exponent == -1) {\n\t\tshift = (argSignif.msw & 0x40000000) ? 3 : 2;\n\t\t \n\t\texponent -= 2;\n\t\tXSIG_LL(argSignif) <<= 2;\n\t\tXll <<= 2;\n\t} else if (exponent == -2) {\n\t\tshift = 1;\n\t\t \n\t\texponent--;\n\t\tXSIG_LL(argSignif) <<= 1;\n\t\tXll <<= 1;\n\t} else\n\t\tshift = 0;\n\n\tif (exponent < -2) {\n\t\t \n\t\tif (FPU_shrx(&Xll, -2 - exponent) >= 0x80000000U)\n\t\t\tXll++;\t \n\t}\n\n\taccumulator.lsw = accumulator.midw = accumulator.msw = 0;\n\tpolynomial_Xsig(&accumulator, &Xll, lterms, HIPOWER - 1);\n\tmul_Xsig_Xsig(&accumulator, &argSignif);\n\tshr_Xsig(&accumulator, 3);\n\n\tmul_Xsig_Xsig(&argSignif, &hiterm);\t \n\tadd_two_Xsig(&accumulator, &argSignif, &exponent);\n\n\tif (shift) {\n\t\t \n\t\tshr_Xsig(&accumulator, -exponent);\n\t\taccumulator.msw |= 0x80000000;\t \n\t\tmul_Xsig_Xsig(&accumulator, shiftterm[shift]);\n\t\taccumulator.msw &= 0x3fffffff;\t \n\t\texponent = 1;\n\t}\n\n\tif (sign != SIGN_POS) {\n\t\t \n\t\tDenom.lsw = accumulator.lsw;\n\t\tXSIG_LL(Denom) = XSIG_LL(accumulator);\n\t\tif (exponent < 0)\n\t\t\tshr_Xsig(&Denom, -exponent);\n\t\telse if (exponent > 0) {\n\t\t\t \n\t\t\tXSIG_LL(Denom) <<= 1;\n\t\t\tif (Denom.lsw & 0x80000000)\n\t\t\t\tXSIG_LL(Denom) |= 1;\n\t\t\t(Denom.lsw) <<= 1;\n\t\t}\n\t\tDenom.msw |= 0x80000000;\t \n\t\tdiv_Xsig(&accumulator, &Denom, &accumulator);\n\t}\n\n\t \n\texponent += round_Xsig(&accumulator);\n\n\tresult = &st(0);\n\tsignificand(result) = XSIG_LL(accumulator);\n\tsetexponent16(result, exponent);\n\n\ttag = FPU_round(result, 1, 0, FULL_PRECISION, sign);\n\n\tsetsign(result, sign);\n\tFPU_settag0(tag);\n\n\treturn 0;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}