{
  "module_name": "poly_atan.c",
  "hash_id": "5483d9952086621b29d1195453cb753fd8a32416acc0a79fc57b8fd2bb010136",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/poly_atan.c",
  "human_readable_source": "\n \n\n#include \"exception.h\"\n#include \"reg_constant.h\"\n#include \"fpu_emu.h\"\n#include \"fpu_system.h\"\n#include \"status_w.h\"\n#include \"control_w.h\"\n#include \"poly.h\"\n\n#define\tHIPOWERon\t6\t \nstatic const unsigned long long oddnegterms[HIPOWERon] = {\n\t0x0000000000000000LL,\t \n\t0x015328437f756467LL,\n\t0x0005dda27b73dec6LL,\n\t0x0000226bf2bfb91aLL,\n\t0x000000ccc439c5f7LL,\n\t0x0000000355438407LL\n};\n\n#define\tHIPOWERop\t6\t \nstatic const unsigned long long oddplterms[HIPOWERop] = {\n \n\t0x0db55a71875c9ac2LL,\n\t0x0029fce2d67880b0LL,\n\t0x0000dfd3908b4596LL,\n\t0x00000550fd61dab4LL,\n\t0x0000001c9422b3f9LL,\n\t0x000000003e3301e1LL\n};\n\nstatic const unsigned long long denomterm = 0xebd9b842c5c53a0eLL;\n\nstatic const Xsig fixedpterm = MK_XSIG(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa);\n\nstatic const Xsig pi_signif = MK_XSIG(0xc90fdaa2, 0x2168c234, 0xc4c6628b);\n\n \nvoid poly_atan(FPU_REG *st0_ptr, u_char st0_tag,\n\t       FPU_REG *st1_ptr, u_char st1_tag)\n{\n\tu_char transformed, inverted, sign1, sign2;\n\tint exponent;\n\tlong int dummy_exp;\n\tXsig accumulator, Numer, Denom, accumulatore, argSignif, argSq, argSqSq;\n\tu_char tag;\n\n\tsign1 = getsign(st0_ptr);\n\tsign2 = getsign(st1_ptr);\n\tif (st0_tag == TAG_Valid) {\n\t\texponent = exponent(st0_ptr);\n\t} else {\n\t\t \n\t\tFPU_to_exp16(st0_ptr, st0_ptr);\n\t\texponent = exponent16(st0_ptr);\n\t}\n\tif (st1_tag == TAG_Valid) {\n\t\texponent -= exponent(st1_ptr);\n\t} else {\n\t\t \n\t\tFPU_to_exp16(st1_ptr, st1_ptr);\n\t\texponent -= exponent16(st1_ptr);\n\t}\n\n\tif ((exponent < 0) || ((exponent == 0) &&\n\t\t\t       ((st0_ptr->sigh < st1_ptr->sigh) ||\n\t\t\t\t((st0_ptr->sigh == st1_ptr->sigh) &&\n\t\t\t\t (st0_ptr->sigl < st1_ptr->sigl))))) {\n\t\tinverted = 1;\n\t\tNumer.lsw = Denom.lsw = 0;\n\t\tXSIG_LL(Numer) = significand(st0_ptr);\n\t\tXSIG_LL(Denom) = significand(st1_ptr);\n\t} else {\n\t\tinverted = 0;\n\t\texponent = -exponent;\n\t\tNumer.lsw = Denom.lsw = 0;\n\t\tXSIG_LL(Numer) = significand(st1_ptr);\n\t\tXSIG_LL(Denom) = significand(st0_ptr);\n\t}\n\tdiv_Xsig(&Numer, &Denom, &argSignif);\n\texponent += norm_Xsig(&argSignif);\n\n\tif ((exponent >= -1)\n\t    || ((exponent == -2) && (argSignif.msw > 0xd413ccd0))) {\n\t\t \n\t\t \n\t\ttransformed = 1;\n\n\t\tif (exponent >= 0) {\n#ifdef PARANOID\n\t\t\tif (!((exponent == 0) &&\n\t\t\t      (argSignif.lsw == 0) && (argSignif.midw == 0) &&\n\t\t\t      (argSignif.msw == 0x80000000))) {\n\t\t\t\tEXCEPTION(EX_INTERNAL | 0x104);\t \n\t\t\t\treturn;\n\t\t\t}\n#endif  \n\t\t\targSignif.msw = 0;\t \n\t\t} else {\n\t\t\tNumer.lsw = Denom.lsw = argSignif.lsw;\n\t\t\tXSIG_LL(Numer) = XSIG_LL(Denom) = XSIG_LL(argSignif);\n\n\t\t\tif (exponent < -1)\n\t\t\t\tshr_Xsig(&Numer, -1 - exponent);\n\t\t\tnegate_Xsig(&Numer);\n\n\t\t\tshr_Xsig(&Denom, -exponent);\n\t\t\tDenom.msw |= 0x80000000;\n\n\t\t\tdiv_Xsig(&Numer, &Denom, &argSignif);\n\n\t\t\texponent = -1 + norm_Xsig(&argSignif);\n\t\t}\n\t} else {\n\t\ttransformed = 0;\n\t}\n\n\targSq.lsw = argSignif.lsw;\n\targSq.midw = argSignif.midw;\n\targSq.msw = argSignif.msw;\n\tmul_Xsig_Xsig(&argSq, &argSq);\n\n\targSqSq.lsw = argSq.lsw;\n\targSqSq.midw = argSq.midw;\n\targSqSq.msw = argSq.msw;\n\tmul_Xsig_Xsig(&argSqSq, &argSqSq);\n\n\taccumulatore.lsw = argSq.lsw;\n\tXSIG_LL(accumulatore) = XSIG_LL(argSq);\n\n\tshr_Xsig(&argSq, 2 * (-1 - exponent - 1));\n\tshr_Xsig(&argSqSq, 4 * (-1 - exponent - 1));\n\n\t \n\n\t \n\taccumulator.msw = accumulator.midw = accumulator.lsw = 0;\n\tpolynomial_Xsig(&accumulator, &XSIG_LL(argSqSq),\n\t\t\toddplterms, HIPOWERop - 1);\n\tmul64_Xsig(&accumulator, &XSIG_LL(argSq));\n\tnegate_Xsig(&accumulator);\n\tpolynomial_Xsig(&accumulator, &XSIG_LL(argSqSq), oddnegterms,\n\t\t\tHIPOWERon - 1);\n\tnegate_Xsig(&accumulator);\n\tadd_two_Xsig(&accumulator, &fixedpterm, &dummy_exp);\n\n\tmul64_Xsig(&accumulatore, &denomterm);\n\tshr_Xsig(&accumulatore, 1 + 2 * (-1 - exponent));\n\taccumulatore.msw |= 0x80000000;\n\n\tdiv_Xsig(&accumulator, &accumulatore, &accumulator);\n\n\tmul_Xsig_Xsig(&accumulator, &argSignif);\n\tmul_Xsig_Xsig(&accumulator, &argSq);\n\n\tshr_Xsig(&accumulator, 3);\n\tnegate_Xsig(&accumulator);\n\tadd_Xsig_Xsig(&accumulator, &argSignif);\n\n\tif (transformed) {\n\t\t \n\t\tshr_Xsig(&accumulator, -1 - exponent);\n\t\tnegate_Xsig(&accumulator);\n\t\tadd_Xsig_Xsig(&accumulator, &pi_signif);\n\t\texponent = -1;\n\t}\n\n\tif (inverted) {\n\t\t \n\t\tshr_Xsig(&accumulator, -exponent);\n\t\tnegate_Xsig(&accumulator);\n\t\tadd_Xsig_Xsig(&accumulator, &pi_signif);\n\t\texponent = 0;\n\t}\n\n\tif (sign1) {\n\t\t \n\t\tshr_Xsig(&accumulator, 1 - exponent);\n\t\tnegate_Xsig(&accumulator);\n\t\tadd_Xsig_Xsig(&accumulator, &pi_signif);\n\t\texponent = 1;\n\t}\n\n\texponent += round_Xsig(&accumulator);\n\n\tsignificand(st1_ptr) = XSIG_LL(accumulator);\n\tsetexponent16(st1_ptr, exponent);\n\n\ttag = FPU_round(st1_ptr, 1, 0, FULL_PRECISION, sign2);\n\tFPU_settagi(1, tag);\n\n\tset_precision_flag_up();\t \n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}