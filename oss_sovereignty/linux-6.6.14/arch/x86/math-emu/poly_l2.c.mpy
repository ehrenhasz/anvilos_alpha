{
  "module_name": "poly_l2.c",
  "hash_id": "b8aee280493fa8d8845a6964ef235951307ee32123d9d5e4ee673f4ad42f9e36",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/poly_l2.c",
  "human_readable_source": "\n \n\n#include \"exception.h\"\n#include \"reg_constant.h\"\n#include \"fpu_emu.h\"\n#include \"fpu_system.h\"\n#include \"control_w.h\"\n#include \"poly.h\"\n\nstatic void log2_kernel(FPU_REG const *arg, u_char argsign,\n\t\t\tXsig * accum_result, long int *expon);\n\n \nvoid poly_l2(FPU_REG *st0_ptr, FPU_REG *st1_ptr, u_char st1_sign)\n{\n\tlong int exponent, expon, expon_expon;\n\tXsig accumulator, expon_accum, yaccum;\n\tu_char sign, argsign;\n\tFPU_REG x;\n\tint tag;\n\n\texponent = exponent16(st0_ptr);\n\n\t \n\tif (st0_ptr->sigh > (unsigned)0xb504f334) {\n\t\t \n\t\tsignificand(&x) = -significand(st0_ptr);\n\t\tsetexponent16(&x, -1);\n\t\texponent++;\n\t\targsign = SIGN_NEG;\n\t} else {\n\t\t \n\t\tx.sigh = st0_ptr->sigh - 0x80000000;\n\t\tx.sigl = st0_ptr->sigl;\n\t\tsetexponent16(&x, 0);\n\t\targsign = SIGN_POS;\n\t}\n\ttag = FPU_normalize_nuo(&x);\n\n\tif (tag == TAG_Zero) {\n\t\texpon = 0;\n\t\taccumulator.msw = accumulator.midw = accumulator.lsw = 0;\n\t} else {\n\t\tlog2_kernel(&x, argsign, &accumulator, &expon);\n\t}\n\n\tif (exponent < 0) {\n\t\tsign = SIGN_NEG;\n\t\texponent = -exponent;\n\t} else\n\t\tsign = SIGN_POS;\n\texpon_accum.msw = exponent;\n\texpon_accum.midw = expon_accum.lsw = 0;\n\tif (exponent) {\n\t\texpon_expon = 31 + norm_Xsig(&expon_accum);\n\t\tshr_Xsig(&accumulator, expon_expon - expon);\n\n\t\tif (sign ^ argsign)\n\t\t\tnegate_Xsig(&accumulator);\n\t\tadd_Xsig_Xsig(&accumulator, &expon_accum);\n\t} else {\n\t\texpon_expon = expon;\n\t\tsign = argsign;\n\t}\n\n\tyaccum.lsw = 0;\n\tXSIG_LL(yaccum) = significand(st1_ptr);\n\tmul_Xsig_Xsig(&accumulator, &yaccum);\n\n\texpon_expon += round_Xsig(&accumulator);\n\n\tif (accumulator.msw == 0) {\n\t\tFPU_copy_to_reg1(&CONST_Z, TAG_Zero);\n\t\treturn;\n\t}\n\n\tsignificand(st1_ptr) = XSIG_LL(accumulator);\n\tsetexponent16(st1_ptr, expon_expon + exponent16(st1_ptr) + 1);\n\n\ttag = FPU_round(st1_ptr, 1, 0, FULL_PRECISION, sign ^ st1_sign);\n\tFPU_settagi(1, tag);\n\n\tset_precision_flag_up();\t \n\n\treturn;\n\n}\n\n \nint poly_l2p1(u_char sign0, u_char sign1,\n\t      FPU_REG * st0_ptr, FPU_REG * st1_ptr, FPU_REG * dest)\n{\n\tu_char tag;\n\tlong int exponent;\n\tXsig accumulator, yaccum;\n\n\tif (exponent16(st0_ptr) < 0) {\n\t\tlog2_kernel(st0_ptr, sign0, &accumulator, &exponent);\n\n\t\tyaccum.lsw = 0;\n\t\tXSIG_LL(yaccum) = significand(st1_ptr);\n\t\tmul_Xsig_Xsig(&accumulator, &yaccum);\n\n\t\texponent += round_Xsig(&accumulator);\n\n\t\texponent += exponent16(st1_ptr) + 1;\n\t\tif (exponent < EXP_WAY_UNDER)\n\t\t\texponent = EXP_WAY_UNDER;\n\n\t\tsignificand(dest) = XSIG_LL(accumulator);\n\t\tsetexponent16(dest, exponent);\n\n\t\ttag = FPU_round(dest, 1, 0, FULL_PRECISION, sign0 ^ sign1);\n\t\tFPU_settagi(1, tag);\n\n\t\tif (tag == TAG_Valid)\n\t\t\tset_precision_flag_up();\t \n\t} else {\n\t\t \n\n\t\tif (sign0 != SIGN_POS) {\n\t\t\t \n#ifdef PECULIAR_486\t\t \n\t\t\tchangesign(st1_ptr);\n#else\n\t\t\tif (arith_invalid(1) < 0)\n\t\t\t\treturn 1;\n#endif  \n\t\t}\n\n\t\t \n\t\tif (sign0 == SIGN_NEG)\n\t\t\tset_precision_flag_down();\n\t\telse\n\t\t\tset_precision_flag_up();\n\t}\n\n\tif (exponent(dest) <= EXP_UNDER)\n\t\tEXCEPTION(EX_Underflow);\n\n\treturn 0;\n\n}\n\n#undef HIPOWER\n#define\tHIPOWER\t10\nstatic const unsigned long long logterms[HIPOWER] = {\n\t0x2a8eca5705fc2ef0LL,\n\t0xf6384ee1d01febceLL,\n\t0x093bb62877cdf642LL,\n\t0x006985d8a9ec439bLL,\n\t0x0005212c4f55a9c8LL,\n\t0x00004326a16927f0LL,\n\t0x0000038d1d80a0e7LL,\n\t0x0000003141cc80c6LL,\n\t0x00000002b1668c9fLL,\n\t0x000000002c7a46aaLL\n};\n\nstatic const unsigned long leadterm = 0xb8000000;\n\n \nstatic void log2_kernel(FPU_REG const *arg, u_char argsign, Xsig *accum_result,\n\t\t\tlong int *expon)\n{\n\tlong int exponent, adj;\n\tunsigned long long Xsq;\n\tXsig accumulator, Numer, Denom, argSignif, arg_signif;\n\n\texponent = exponent16(arg);\n\tNumer.lsw = Denom.lsw = 0;\n\tXSIG_LL(Numer) = XSIG_LL(Denom) = significand(arg);\n\tif (argsign == SIGN_POS) {\n\t\tshr_Xsig(&Denom, 2 - (1 + exponent));\n\t\tDenom.msw |= 0x80000000;\n\t\tdiv_Xsig(&Numer, &Denom, &argSignif);\n\t} else {\n\t\tshr_Xsig(&Denom, 1 - (1 + exponent));\n\t\tnegate_Xsig(&Denom);\n\t\tif (Denom.msw & 0x80000000) {\n\t\t\tdiv_Xsig(&Numer, &Denom, &argSignif);\n\t\t\texponent++;\n\t\t} else {\n\t\t\t \n\t\t\targSignif.lsw = Numer.lsw;\n\t\t\targSignif.midw = Numer.midw;\n\t\t\targSignif.msw = Numer.msw;\n\t\t}\n\t}\n\n#ifndef PECULIAR_486\n\t \n\tif (exponent >= -2) {\n\t\tif ((exponent > -2) || (argSignif.msw > (unsigned)0xafb0ccc0)) {\n\t\t\t \n\t\t}\n\t}\n#endif  \n\n\targ_signif.lsw = argSignif.lsw;\n\tXSIG_LL(arg_signif) = XSIG_LL(argSignif);\n\tadj = norm_Xsig(&argSignif);\n\taccumulator.lsw = argSignif.lsw;\n\tXSIG_LL(accumulator) = XSIG_LL(argSignif);\n\tmul_Xsig_Xsig(&accumulator, &accumulator);\n\tshr_Xsig(&accumulator, 2 * (-1 - (1 + exponent + adj)));\n\tXsq = XSIG_LL(accumulator);\n\tif (accumulator.lsw & 0x80000000)\n\t\tXsq++;\n\n\taccumulator.msw = accumulator.midw = accumulator.lsw = 0;\n\t \n\tpolynomial_Xsig(&accumulator, &Xsq, logterms, HIPOWER - 1);\n\n\tmul_Xsig_Xsig(&accumulator, &argSignif);\n\tshr_Xsig(&accumulator, 6 - adj);\n\n\tmul32_Xsig(&arg_signif, leadterm);\n\tadd_two_Xsig(&accumulator, &arg_signif, &exponent);\n\n\t*expon = exponent + 1;\n\taccum_result->lsw = accumulator.lsw;\n\taccum_result->midw = accumulator.midw;\n\taccum_result->msw = accumulator.msw;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}