{
  "module_name": "get_address.c",
  "hash_id": "13c13a3d292be531920a8374b366e5c83132db3046b59dae672747d10dbf00e3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/get_address.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/stddef.h>\n\n#include <linux/uaccess.h>\n#include <asm/vm86.h>\n\n#include \"fpu_system.h\"\n#include \"exception.h\"\n#include \"fpu_emu.h\"\n\n#define FPU_WRITE_BIT 0x10\n\nstatic int reg_offset[] = {\n\toffsetof(struct pt_regs, ax),\n\toffsetof(struct pt_regs, cx),\n\toffsetof(struct pt_regs, dx),\n\toffsetof(struct pt_regs, bx),\n\toffsetof(struct pt_regs, sp),\n\toffsetof(struct pt_regs, bp),\n\toffsetof(struct pt_regs, si),\n\toffsetof(struct pt_regs, di)\n};\n\n#define REG_(x) (*(long *)(reg_offset[(x)] + (u_char *)FPU_info->regs))\n\nstatic int reg_offset_vm86[] = {\n\toffsetof(struct pt_regs, cs),\n\toffsetof(struct kernel_vm86_regs, ds),\n\toffsetof(struct kernel_vm86_regs, es),\n\toffsetof(struct kernel_vm86_regs, fs),\n\toffsetof(struct kernel_vm86_regs, gs),\n\toffsetof(struct pt_regs, ss),\n\toffsetof(struct kernel_vm86_regs, ds)\n};\n\n#define VM86_REG_(x) (*(unsigned short *) \\\n\t\t(reg_offset_vm86[((unsigned)x)] + (u_char *)FPU_info->regs))\n\nstatic int reg_offset_pm[] = {\n\toffsetof(struct pt_regs, cs),\n\toffsetof(struct pt_regs, ds),\n\toffsetof(struct pt_regs, es),\n\toffsetof(struct pt_regs, fs),\n\toffsetof(struct pt_regs, ds),\t \n\toffsetof(struct pt_regs, ss),\n\toffsetof(struct pt_regs, ds)\n};\n\n#define PM_REG_(x) (*(unsigned short *) \\\n\t\t(reg_offset_pm[((unsigned)x)] + (u_char *)FPU_info->regs))\n\n \nstatic int sib(int mod, unsigned long *fpu_eip)\n{\n\tu_char ss, index, base;\n\tlong offset;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_code_access_ok(1);\n\tFPU_get_user(base, (u_char __user *) (*fpu_eip));\t \n\tRE_ENTRANT_CHECK_ON;\n\t(*fpu_eip)++;\n\tss = base >> 6;\n\tindex = (base >> 3) & 7;\n\tbase &= 7;\n\n\tif ((mod == 0) && (base == 5))\n\t\toffset = 0;\t \n\telse\n\t\toffset = REG_(base);\n\n\tif (index == 4) {\n\t\t \n\t\t \n\t\tif (ss)\n\t\t\tEXCEPTION(EX_Invalid);\n\t} else {\n\t\toffset += (REG_(index)) << ss;\n\t}\n\n\tif (mod == 1) {\n\t\t \n\t\tlong displacement;\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_code_access_ok(1);\n\t\tFPU_get_user(displacement, (signed char __user *)(*fpu_eip));\n\t\toffset += displacement;\n\t\tRE_ENTRANT_CHECK_ON;\n\t\t(*fpu_eip)++;\n\t} else if (mod == 2 || base == 5) {\t \n\t\t \n\t\tlong displacement;\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_code_access_ok(4);\n\t\tFPU_get_user(displacement, (long __user *)(*fpu_eip));\n\t\toffset += displacement;\n\t\tRE_ENTRANT_CHECK_ON;\n\t\t(*fpu_eip) += 4;\n\t}\n\n\treturn offset;\n}\n\nstatic unsigned long vm86_segment(u_char segment, struct address *addr)\n{\n\tsegment--;\n#ifdef PARANOID\n\tif (segment > PREFIX_SS_) {\n\t\tEXCEPTION(EX_INTERNAL | 0x130);\n\t\tmath_abort(FPU_info, SIGSEGV);\n\t}\n#endif  \n\taddr->selector = VM86_REG_(segment);\n\treturn (unsigned long)VM86_REG_(segment) << 4;\n}\n\n \nstatic long pm_address(u_char FPU_modrm, u_char segment,\n\t\t       struct address *addr, long offset)\n{\n\tstruct desc_struct descriptor;\n\tunsigned long base_address, limit, address, seg_top;\n\n\tsegment--;\n\n#ifdef PARANOID\n\t \n\tif (segment > PREFIX_SS_) {\n\t\tEXCEPTION(EX_INTERNAL | 0x132);\n\t\tmath_abort(FPU_info, SIGSEGV);\n\t}\n#endif  \n\n\tswitch (segment) {\n\tcase PREFIX_GS_ - 1:\n\t\t \n\t\tsavesegment(gs, addr->selector);\n\t\tbreak;\n\tdefault:\n\t\taddr->selector = PM_REG_(segment);\n\t}\n\n\tdescriptor = FPU_get_ldt_descriptor(addr->selector);\n\tbase_address = seg_get_base(&descriptor);\n\taddress = base_address + offset;\n\tlimit = seg_get_limit(&descriptor) + 1;\n\tlimit *= seg_get_granularity(&descriptor);\n\tlimit += base_address - 1;\n\tif (limit < base_address)\n\t\tlimit = 0xffffffff;\n\n\tif (seg_expands_down(&descriptor)) {\n\t\tif (descriptor.g) {\n\t\t\tseg_top = 0xffffffff;\n\t\t} else {\n\t\t\tseg_top = base_address + (1 << 20);\n\t\t\tif (seg_top < base_address)\n\t\t\t\tseg_top = 0xffffffff;\n\t\t}\n\t\taccess_limit =\n\t\t    (address <= limit) || (address >= seg_top) ? 0 :\n\t\t    ((seg_top - address) >= 255 ? 255 : seg_top - address);\n\t} else {\n\t\taccess_limit =\n\t\t    (address > limit) || (address < base_address) ? 0 :\n\t\t    ((limit - address) >= 254 ? 255 : limit - address + 1);\n\t}\n\tif (seg_execute_only(&descriptor) ||\n\t    (!seg_writable(&descriptor) && (FPU_modrm & FPU_WRITE_BIT))) {\n\t\taccess_limit = 0;\n\t}\n\treturn address;\n}\n\n \n\nvoid __user *FPU_get_address(u_char FPU_modrm, unsigned long *fpu_eip,\n\t\t\t     struct address *addr, fpu_addr_modes addr_modes)\n{\n\tu_char mod;\n\tunsigned rm = FPU_modrm & 7;\n\tlong *cpu_reg_ptr;\n\tint address = 0;\t \n\n\t \n\tif (!addr_modes.default_mode && (FPU_modrm & FPU_WRITE_BIT)\n\t    && (addr_modes.override.segment == PREFIX_CS_)) {\n\t\tmath_abort(FPU_info, SIGSEGV);\n\t}\n\n\taddr->selector = FPU_DS;\t \n\n\tmod = (FPU_modrm >> 6) & 3;\n\n\tif (rm == 4 && mod != 3) {\n\t\taddress = sib(mod, fpu_eip);\n\t} else {\n\t\tcpu_reg_ptr = &REG_(rm);\n\t\tswitch (mod) {\n\t\tcase 0:\n\t\t\tif (rm == 5) {\n\t\t\t\t \n\t\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\t\tFPU_code_access_ok(4);\n\t\t\t\tFPU_get_user(address,\n\t\t\t\t\t     (unsigned long __user\n\t\t\t\t\t      *)(*fpu_eip));\n\t\t\t\t(*fpu_eip) += 4;\n\t\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\t\taddr->offset = address;\n\t\t\t\treturn (void __user *)address;\n\t\t\t} else {\n\t\t\t\taddress = *cpu_reg_ptr;\t \n\t\t\t\taddr->offset = address;\n\t\t\t\treturn (void __user *)address;\n\t\t\t}\n\t\tcase 1:\n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_code_access_ok(1);\n\t\t\tFPU_get_user(address, (signed char __user *)(*fpu_eip));\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\t(*fpu_eip)++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_code_access_ok(4);\n\t\t\tFPU_get_user(address, (long __user *)(*fpu_eip));\n\t\t\t(*fpu_eip) += 4;\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tEXCEPTION(EX_Invalid);\n\t\t}\n\t\taddress += *cpu_reg_ptr;\n\t}\n\n\taddr->offset = address;\n\n\tswitch (addr_modes.default_mode) {\n\tcase 0:\n\t\tbreak;\n\tcase VM86:\n\t\taddress += vm86_segment(addr_modes.override.segment, addr);\n\t\tbreak;\n\tcase PM16:\n\tcase SEG32:\n\t\taddress = pm_address(FPU_modrm, addr_modes.override.segment,\n\t\t\t\t     addr, address);\n\t\tbreak;\n\tdefault:\n\t\tEXCEPTION(EX_INTERNAL | 0x133);\n\t}\n\n\treturn (void __user *)address;\n}\n\nvoid __user *FPU_get_address_16(u_char FPU_modrm, unsigned long *fpu_eip,\n\t\t\t\tstruct address *addr, fpu_addr_modes addr_modes)\n{\n\tu_char mod;\n\tunsigned rm = FPU_modrm & 7;\n\tint address = 0;\t \n\n\t \n\tif (!addr_modes.default_mode && (FPU_modrm & FPU_WRITE_BIT)\n\t    && (addr_modes.override.segment == PREFIX_CS_)) {\n\t\tmath_abort(FPU_info, SIGSEGV);\n\t}\n\n\taddr->selector = FPU_DS;\t \n\n\tmod = (FPU_modrm >> 6) & 3;\n\n\tswitch (mod) {\n\tcase 0:\n\t\tif (rm == 6) {\n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_code_access_ok(2);\n\t\t\tFPU_get_user(address,\n\t\t\t\t     (unsigned short __user *)(*fpu_eip));\n\t\t\t(*fpu_eip) += 2;\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\tgoto add_segment;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_code_access_ok(1);\n\t\tFPU_get_user(address, (signed char __user *)(*fpu_eip));\n\t\tRE_ENTRANT_CHECK_ON;\n\t\t(*fpu_eip)++;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_code_access_ok(2);\n\t\tFPU_get_user(address, (unsigned short __user *)(*fpu_eip));\n\t\t(*fpu_eip) += 2;\n\t\tRE_ENTRANT_CHECK_ON;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tEXCEPTION(EX_Invalid);\n\t\tbreak;\n\t}\n\tswitch (rm) {\n\tcase 0:\n\t\taddress += FPU_info->regs->bx + FPU_info->regs->si;\n\t\tbreak;\n\tcase 1:\n\t\taddress += FPU_info->regs->bx + FPU_info->regs->di;\n\t\tbreak;\n\tcase 2:\n\t\taddress += FPU_info->regs->bp + FPU_info->regs->si;\n\t\tif (addr_modes.override.segment == PREFIX_DEFAULT)\n\t\t\taddr_modes.override.segment = PREFIX_SS_;\n\t\tbreak;\n\tcase 3:\n\t\taddress += FPU_info->regs->bp + FPU_info->regs->di;\n\t\tif (addr_modes.override.segment == PREFIX_DEFAULT)\n\t\t\taddr_modes.override.segment = PREFIX_SS_;\n\t\tbreak;\n\tcase 4:\n\t\taddress += FPU_info->regs->si;\n\t\tbreak;\n\tcase 5:\n\t\taddress += FPU_info->regs->di;\n\t\tbreak;\n\tcase 6:\n\t\taddress += FPU_info->regs->bp;\n\t\tif (addr_modes.override.segment == PREFIX_DEFAULT)\n\t\t\taddr_modes.override.segment = PREFIX_SS_;\n\t\tbreak;\n\tcase 7:\n\t\taddress += FPU_info->regs->bx;\n\t\tbreak;\n\t}\n\n      add_segment:\n\taddress &= 0xffff;\n\n\taddr->offset = address;\n\n\tswitch (addr_modes.default_mode) {\n\tcase 0:\n\t\tbreak;\n\tcase VM86:\n\t\taddress += vm86_segment(addr_modes.override.segment, addr);\n\t\tbreak;\n\tcase PM16:\n\tcase SEG32:\n\t\taddress = pm_address(FPU_modrm, addr_modes.override.segment,\n\t\t\t\t     addr, address);\n\t\tbreak;\n\tdefault:\n\t\tEXCEPTION(EX_INTERNAL | 0x131);\n\t}\n\n\treturn (void __user *)address;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}