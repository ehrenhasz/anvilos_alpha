{
  "module_name": "reg_ld_str.c",
  "hash_id": "0634f138712dbbf6ff284cc858141dc157530a895e608533fd9ce2e94201b250",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/reg_ld_str.c",
  "human_readable_source": "\n \n\n \n\n#include \"fpu_emu.h\"\n\n#include <linux/uaccess.h>\n\n#include \"fpu_system.h\"\n#include \"exception.h\"\n#include \"reg_constant.h\"\n#include \"control_w.h\"\n#include \"status_w.h\"\n\n#define DOUBLE_Emax 1023\t \n#define DOUBLE_Ebias 1023\n#define DOUBLE_Emin (-1022)\t \n\n#define SINGLE_Emax 127\t\t \n#define SINGLE_Ebias 127\n#define SINGLE_Emin (-126)\t \n\nstatic u_char normalize_no_excep(FPU_REG *r, int exp, int sign)\n{\n\tu_char tag;\n\n\tsetexponent16(r, exp);\n\n\ttag = FPU_normalize_nuo(r);\n\tstdexp(r);\n\tif (sign)\n\t\tsetnegative(r);\n\n\treturn tag;\n}\n\nint FPU_tagof(FPU_REG *ptr)\n{\n\tint exp;\n\n\texp = exponent16(ptr) & 0x7fff;\n\tif (exp == 0) {\n\t\tif (!(ptr->sigh | ptr->sigl)) {\n\t\t\treturn TAG_Zero;\n\t\t}\n\t\t \n\t\treturn TAG_Special;\n\t}\n\n\tif (exp == 0x7fff) {\n\t\t \n\t\treturn TAG_Special;\n\t}\n\n\tif (!(ptr->sigh & 0x80000000)) {\n\t\t \n\t\t \n\t\t \n\t\treturn TAG_Special;\n\t}\n\n\treturn TAG_Valid;\n}\n\n \nint FPU_load_extended(long double __user *s, int stnr)\n{\n\tFPU_REG *sti_ptr = &st(stnr);\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(s, 10);\n\tFPU_copy_from_user(sti_ptr, s, 10);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn FPU_tagof(sti_ptr);\n}\n\n \nint FPU_load_double(double __user *dfloat, FPU_REG *loaded_data)\n{\n\tint exp, tag, negative;\n\tunsigned m64, l64;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(dfloat, 8);\n\tFPU_get_user(m64, 1 + (unsigned long __user *)dfloat);\n\tFPU_get_user(l64, (unsigned long __user *)dfloat);\n\tRE_ENTRANT_CHECK_ON;\n\n\tnegative = (m64 & 0x80000000) ? SIGN_Negative : SIGN_Positive;\n\texp = ((m64 & 0x7ff00000) >> 20) - DOUBLE_Ebias + EXTENDED_Ebias;\n\tm64 &= 0xfffff;\n\tif (exp > DOUBLE_Emax + EXTENDED_Ebias) {\n\t\t \n\t\tif ((m64 == 0) && (l64 == 0)) {\n\t\t\t \n\t\t\tloaded_data->sigh = 0x80000000;\n\t\t\tloaded_data->sigl = 0x00000000;\n\t\t\texp = EXP_Infinity + EXTENDED_Ebias;\n\t\t\ttag = TAG_Special;\n\t\t} else {\n\t\t\t \n\t\t\texp = EXP_NaN + EXTENDED_Ebias;\n\t\t\tloaded_data->sigh = (m64 << 11) | 0x80000000;\n\t\t\tloaded_data->sigh |= l64 >> 21;\n\t\t\tloaded_data->sigl = l64 << 11;\n\t\t\ttag = TAG_Special;\t \n\t\t}\n\t} else if (exp < DOUBLE_Emin + EXTENDED_Ebias) {\n\t\t \n\t\tif ((m64 == 0) && (l64 == 0)) {\n\t\t\t \n\t\t\treg_copy(&CONST_Z, loaded_data);\n\t\t\texp = 0;\n\t\t\ttag = TAG_Zero;\n\t\t} else {\n\t\t\t \n\t\t\tloaded_data->sigh = m64 << 11;\n\t\t\tloaded_data->sigh |= l64 >> 21;\n\t\t\tloaded_data->sigl = l64 << 11;\n\n\t\t\treturn normalize_no_excep(loaded_data, DOUBLE_Emin,\n\t\t\t\t\t\t  negative)\n\t\t\t    | (denormal_operand() < 0 ? FPU_Exception : 0);\n\t\t}\n\t} else {\n\t\tloaded_data->sigh = (m64 << 11) | 0x80000000;\n\t\tloaded_data->sigh |= l64 >> 21;\n\t\tloaded_data->sigl = l64 << 11;\n\n\t\ttag = TAG_Valid;\n\t}\n\n\tsetexponent16(loaded_data, exp | negative);\n\n\treturn tag;\n}\n\n \nint FPU_load_single(float __user *single, FPU_REG *loaded_data)\n{\n\tunsigned m32;\n\tint exp, tag, negative;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(single, 4);\n\tFPU_get_user(m32, (unsigned long __user *)single);\n\tRE_ENTRANT_CHECK_ON;\n\n\tnegative = (m32 & 0x80000000) ? SIGN_Negative : SIGN_Positive;\n\n\tif (!(m32 & 0x7fffffff)) {\n\t\t \n\t\treg_copy(&CONST_Z, loaded_data);\n\t\taddexponent(loaded_data, negative);\n\t\treturn TAG_Zero;\n\t}\n\texp = ((m32 & 0x7f800000) >> 23) - SINGLE_Ebias + EXTENDED_Ebias;\n\tm32 = (m32 & 0x7fffff) << 8;\n\tif (exp < SINGLE_Emin + EXTENDED_Ebias) {\n\t\t \n\t\tloaded_data->sigh = m32;\n\t\tloaded_data->sigl = 0;\n\n\t\treturn normalize_no_excep(loaded_data, SINGLE_Emin, negative)\n\t\t    | (denormal_operand() < 0 ? FPU_Exception : 0);\n\t} else if (exp > SINGLE_Emax + EXTENDED_Ebias) {\n\t\t \n\t\tif (m32 == 0) {\n\t\t\t \n\t\t\tloaded_data->sigh = 0x80000000;\n\t\t\tloaded_data->sigl = 0x00000000;\n\t\t\texp = EXP_Infinity + EXTENDED_Ebias;\n\t\t\ttag = TAG_Special;\n\t\t} else {\n\t\t\t \n\t\t\texp = EXP_NaN + EXTENDED_Ebias;\n\t\t\tloaded_data->sigh = m32 | 0x80000000;\n\t\t\tloaded_data->sigl = 0;\n\t\t\ttag = TAG_Special;\t \n\t\t}\n\t} else {\n\t\tloaded_data->sigh = m32 | 0x80000000;\n\t\tloaded_data->sigl = 0;\n\t\ttag = TAG_Valid;\n\t}\n\n\tsetexponent16(loaded_data, exp | negative);\t \n\n\treturn tag;\n}\n\n \nint FPU_load_int64(long long __user *_s)\n{\n\tlong long s;\n\tint sign;\n\tFPU_REG *st0_ptr = &st(0);\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(_s, 8);\n\tif (copy_from_user(&s, _s, 8))\n\t\tFPU_abort;\n\tRE_ENTRANT_CHECK_ON;\n\n\tif (s == 0) {\n\t\treg_copy(&CONST_Z, st0_ptr);\n\t\treturn TAG_Zero;\n\t}\n\n\tif (s > 0)\n\t\tsign = SIGN_Positive;\n\telse {\n\t\ts = -s;\n\t\tsign = SIGN_Negative;\n\t}\n\n\tsignificand(st0_ptr) = s;\n\n\treturn normalize_no_excep(st0_ptr, 63, sign);\n}\n\n \nint FPU_load_int32(long __user *_s, FPU_REG *loaded_data)\n{\n\tlong s;\n\tint negative;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(_s, 4);\n\tFPU_get_user(s, _s);\n\tRE_ENTRANT_CHECK_ON;\n\n\tif (s == 0) {\n\t\treg_copy(&CONST_Z, loaded_data);\n\t\treturn TAG_Zero;\n\t}\n\n\tif (s > 0)\n\t\tnegative = SIGN_Positive;\n\telse {\n\t\ts = -s;\n\t\tnegative = SIGN_Negative;\n\t}\n\n\tloaded_data->sigh = s;\n\tloaded_data->sigl = 0;\n\n\treturn normalize_no_excep(loaded_data, 31, negative);\n}\n\n \nint FPU_load_int16(short __user *_s, FPU_REG *loaded_data)\n{\n\tint s, negative;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(_s, 2);\n\t \n\tFPU_get_user(s, _s);\n\tRE_ENTRANT_CHECK_ON;\n\n\tif (s == 0) {\n\t\treg_copy(&CONST_Z, loaded_data);\n\t\treturn TAG_Zero;\n\t}\n\n\tif (s > 0)\n\t\tnegative = SIGN_Positive;\n\telse {\n\t\ts = -s;\n\t\tnegative = SIGN_Negative;\n\t}\n\n\tloaded_data->sigh = s << 16;\n\tloaded_data->sigl = 0;\n\n\treturn normalize_no_excep(loaded_data, 15, negative);\n}\n\n \nint FPU_load_bcd(u_char __user *s)\n{\n\tFPU_REG *st0_ptr = &st(0);\n\tint pos;\n\tu_char bcd;\n\tlong long l = 0;\n\tint sign;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(s, 10);\n\tRE_ENTRANT_CHECK_ON;\n\tfor (pos = 8; pos >= 0; pos--) {\n\t\tl *= 10;\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_get_user(bcd, s + pos);\n\t\tRE_ENTRANT_CHECK_ON;\n\t\tl += bcd >> 4;\n\t\tl *= 10;\n\t\tl += bcd & 0x0f;\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_get_user(sign, s + 9);\n\tsign = sign & 0x80 ? SIGN_Negative : SIGN_Positive;\n\tRE_ENTRANT_CHECK_ON;\n\n\tif (l == 0) {\n\t\treg_copy(&CONST_Z, st0_ptr);\n\t\taddexponent(st0_ptr, sign);\t \n\t\treturn TAG_Zero;\n\t} else {\n\t\tsignificand(st0_ptr) = l;\n\t\treturn normalize_no_excep(st0_ptr, 63, sign);\n\t}\n}\n\n \n\n \nint FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag,\n\t\t       long double __user * d)\n{\n\t \n\n\tif (st0_tag != TAG_Empty) {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(d, 10);\n\n\t\tFPU_put_user(st0_ptr->sigl, (unsigned long __user *)d);\n\t\tFPU_put_user(st0_ptr->sigh,\n\t\t\t     (unsigned long __user *)((u_char __user *) d + 4));\n\t\tFPU_put_user(exponent16(st0_ptr),\n\t\t\t     (unsigned short __user *)((u_char __user *) d +\n\t\t\t\t\t\t       8));\n\t\tRE_ENTRANT_CHECK_ON;\n\n\t\treturn 1;\n\t}\n\n\t \n\tEXCEPTION(EX_StackUnder);\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\t \n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(d, 10);\n\t\tFPU_put_user(0, (unsigned long __user *)d);\n\t\tFPU_put_user(0xc0000000, 1 + (unsigned long __user *)d);\n\t\tFPU_put_user(0xffff, 4 + (short __user *)d);\n\t\tRE_ENTRANT_CHECK_ON;\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n\n}\n\n \nint FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double __user *dfloat)\n{\n\tunsigned long l[2];\n\tunsigned long increment = 0;\t \n\tint precision_loss;\n\tint exp;\n\tFPU_REG tmp;\n\n\tl[0] = 0;\n\tl[1] = 0;\n\tif (st0_tag == TAG_Valid) {\n\t\treg_copy(st0_ptr, &tmp);\n\t\texp = exponent(&tmp);\n\n\t\tif (exp < DOUBLE_Emin) {\t \n\t\t\taddexponent(&tmp, -DOUBLE_Emin + 52);\t \ndenormal_arg:\n\t\t\tif ((precision_loss = FPU_round_to_int(&tmp, st0_tag))) {\n#ifdef PECULIAR_486\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (!\n\t\t\t\t    ((tmp.sigh == 0x00100000) && (tmp.sigl == 0)\n\t\t\t\t     && (st0_ptr->sigl & 0x000007ff)))\n#endif  \n\t\t\t\t{\n\t\t\t\t\tEXCEPTION(EX_Underflow);\n\t\t\t\t\t \n\t\t\t\t\tif (!(control_word & CW_Underflow))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tEXCEPTION(precision_loss);\n\t\t\t\tif (!(control_word & CW_Precision))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl[0] = tmp.sigl;\n\t\t\tl[1] = tmp.sigh;\n\t\t} else {\n\t\t\tif (tmp.sigl & 0x000007ff) {\n\t\t\t\tprecision_loss = 1;\n\t\t\t\tswitch (control_word & CW_RC) {\n\t\t\t\tcase RC_RND:\n\t\t\t\t\t \n\t\t\t\t\tincrement = ((tmp.sigl & 0x7ff) > 0x400) |\t \n\t\t\t\t\t    ((tmp.sigl & 0xc00) == 0xc00);\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_DOWN:\t \n\t\t\t\t\tincrement =\n\t\t\t\t\t    signpositive(&tmp) ? 0 : tmp.\n\t\t\t\t\t    sigl & 0x7ff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_UP:\t \n\t\t\t\t\tincrement =\n\t\t\t\t\t    signpositive(&tmp) ? tmp.\n\t\t\t\t\t    sigl & 0x7ff : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_CHOP:\n\t\t\t\t\tincrement = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\ttmp.sigl &= 0xfffff800;\n\n\t\t\t\tif (increment) {\n\t\t\t\t\tif (tmp.sigl >= 0xfffff800) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (tmp.sigh == 0xffffffff) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttmp.sigh = 0x80000000;\n\t\t\t\t\t\t\texp++;\n\t\t\t\t\t\t\tif (exp >= EXP_OVER)\n\t\t\t\t\t\t\t\tgoto overflow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp.sigh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.sigl = 0x00000000;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttmp.sigl += 0x00000800;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tprecision_loss = 0;\n\n\t\t\tl[0] = (tmp.sigl >> 11) | (tmp.sigh << 21);\n\t\t\tl[1] = ((tmp.sigh >> 11) & 0xfffff);\n\n\t\t\tif (exp > DOUBLE_Emax) {\n\t\t\t      overflow:\n\t\t\t\tEXCEPTION(EX_Overflow);\n\t\t\t\tif (!(control_word & CW_Overflow))\n\t\t\t\t\treturn 0;\n\t\t\t\tset_precision_flag_up();\n\t\t\t\tif (!(control_word & CW_Precision))\n\t\t\t\t\treturn 0;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tl[1] = 0x7ff00000;\t \n\t\t\t} else {\n\t\t\t\tif (precision_loss) {\n\t\t\t\t\tif (increment)\n\t\t\t\t\t\tset_precision_flag_up();\n\t\t\t\t\telse\n\t\t\t\t\t\tset_precision_flag_down();\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tl[1] |= (((exp + DOUBLE_Ebias) & 0x7ff) << 20);\n\t\t\t}\n\t\t}\n\t} else if (st0_tag == TAG_Zero) {\n\t\t \n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif (st0_tag == TW_Denormal) {\n\t\t\t \n#ifndef PECULIAR_486\n\t\t\t \n\t\t\t \n\t\t\tif (control_word & CW_Underflow)\n\t\t\t\tdenormal_operand();\n#endif  \n\t\t\treg_copy(st0_ptr, &tmp);\n\t\t\tgoto denormal_arg;\n\t\t} else if (st0_tag == TW_Infinity) {\n\t\t\tl[1] = 0x7ff00000;\n\t\t} else if (st0_tag == TW_NaN) {\n\t\t\t \n\t\t\tif ((exponent(st0_ptr) == EXP_OVER)\n\t\t\t    && (st0_ptr->sigh & 0x80000000)) {\n\t\t\t\t \n\t\t\t\tl[0] =\n\t\t\t\t    (st0_ptr->sigl >> 11) | (st0_ptr->\n\t\t\t\t\t\t\t     sigh << 21);\n\t\t\t\tl[1] = ((st0_ptr->sigh >> 11) & 0xfffff);\n\t\t\t\tif (!(st0_ptr->sigh & 0x40000000)) {\n\t\t\t\t\t \n\t\t\t\t\tEXCEPTION(EX_Invalid);\n\t\t\t\t\tif (!(control_word & CW_Invalid))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tl[1] |= (0x40000000 >> 11);\n\t\t\t\t}\n\t\t\t\tl[1] |= 0x7ff00000;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tEXCEPTION(EX_Invalid);\n\t\t\t\tif (!(control_word & CW_Invalid))\n\t\t\t\t\treturn 0;\n\t\t\t\tl[1] = 0xfff80000;\n\t\t\t}\n\t\t}\n\t} else if (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_access_ok(dfloat, 8);\n\t\t\tFPU_put_user(0, (unsigned long __user *)dfloat);\n\t\t\tFPU_put_user(0xfff80000,\n\t\t\t\t     1 + (unsigned long __user *)dfloat);\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tif (getsign(st0_ptr))\n\t\tl[1] |= 0x80000000;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(dfloat, 8);\n\tFPU_put_user(l[0], (unsigned long __user *)dfloat);\n\tFPU_put_user(l[1], 1 + (unsigned long __user *)dfloat);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \nint FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float __user *single)\n{\n\tlong templ = 0;\n\tunsigned long increment = 0;\t \n\tint precision_loss;\n\tint exp;\n\tFPU_REG tmp;\n\n\tif (st0_tag == TAG_Valid) {\n\n\t\treg_copy(st0_ptr, &tmp);\n\t\texp = exponent(&tmp);\n\n\t\tif (exp < SINGLE_Emin) {\n\t\t\taddexponent(&tmp, -SINGLE_Emin + 23);\t \n\n\t\t      denormal_arg:\n\n\t\t\tif ((precision_loss = FPU_round_to_int(&tmp, st0_tag))) {\n#ifdef PECULIAR_486\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (!((tmp.sigl == 0x00800000) &&\n\t\t\t\t      ((st0_ptr->sigh & 0x000000ff)\n\t\t\t\t       || st0_ptr->sigl)))\n#endif  \n\t\t\t\t{\n\t\t\t\t\tEXCEPTION(EX_Underflow);\n\t\t\t\t\t \n\t\t\t\t\tif (!(control_word & CW_Underflow))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tEXCEPTION(precision_loss);\n\t\t\t\tif (!(control_word & CW_Precision))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttempl = tmp.sigl;\n\t\t} else {\n\t\t\tif (tmp.sigl | (tmp.sigh & 0x000000ff)) {\n\t\t\t\tunsigned long sigh = tmp.sigh;\n\t\t\t\tunsigned long sigl = tmp.sigl;\n\n\t\t\t\tprecision_loss = 1;\n\t\t\t\tswitch (control_word & CW_RC) {\n\t\t\t\tcase RC_RND:\n\t\t\t\t\tincrement = ((sigh & 0xff) > 0x80)\t \n\t\t\t\t\t    ||(((sigh & 0xff) == 0x80) && sigl)\t \n\t\t\t\t\t    ||((sigh & 0x180) == 0x180);\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_DOWN:\t \n\t\t\t\t\tincrement = signpositive(&tmp)\n\t\t\t\t\t    ? 0 : (sigl | (sigh & 0xff));\n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_UP:\t \n\t\t\t\t\tincrement = signpositive(&tmp)\n\t\t\t\t\t    ? (sigl | (sigh & 0xff)) : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RC_CHOP:\n\t\t\t\t\tincrement = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\ttmp.sigl = 0;\n\n\t\t\t\tif (increment) {\n\t\t\t\t\tif (sigh >= 0xffffff00) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttmp.sigh = 0x80000000;\n\t\t\t\t\t\texp++;\n\t\t\t\t\t\tif (exp >= EXP_OVER)\n\t\t\t\t\t\t\tgoto overflow;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.sigh &= 0xffffff00;\n\t\t\t\t\t\ttmp.sigh += 0x100;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttmp.sigh &= 0xffffff00;\t \n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tprecision_loss = 0;\n\n\t\t\ttempl = (tmp.sigh >> 8) & 0x007fffff;\n\n\t\t\tif (exp > SINGLE_Emax) {\n\t\t\t      overflow:\n\t\t\t\tEXCEPTION(EX_Overflow);\n\t\t\t\tif (!(control_word & CW_Overflow))\n\t\t\t\t\treturn 0;\n\t\t\t\tset_precision_flag_up();\n\t\t\t\tif (!(control_word & CW_Precision))\n\t\t\t\t\treturn 0;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\ttempl = 0x7f800000;\n\t\t\t} else {\n\t\t\t\tif (precision_loss) {\n\t\t\t\t\tif (increment)\n\t\t\t\t\t\tset_precision_flag_up();\n\t\t\t\t\telse\n\t\t\t\t\t\tset_precision_flag_down();\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ttempl |= ((exp + SINGLE_Ebias) & 0xff) << 23;\n\t\t\t}\n\t\t}\n\t} else if (st0_tag == TAG_Zero) {\n\t\ttempl = 0;\n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif (st0_tag == TW_Denormal) {\n\t\t\treg_copy(st0_ptr, &tmp);\n\n\t\t\t \n#ifndef PECULIAR_486\n\t\t\t \n\t\t\t \n\t\t\tif (control_word & CW_Underflow)\n\t\t\t\tdenormal_operand();\n#endif  \n\t\t\tgoto denormal_arg;\n\t\t} else if (st0_tag == TW_Infinity) {\n\t\t\ttempl = 0x7f800000;\n\t\t} else if (st0_tag == TW_NaN) {\n\t\t\t \n\t\t\tif ((exponent(st0_ptr) == EXP_OVER)\n\t\t\t    && (st0_ptr->sigh & 0x80000000)) {\n\t\t\t\t \n\t\t\t\ttempl = st0_ptr->sigh >> 8;\n\t\t\t\tif (!(st0_ptr->sigh & 0x40000000)) {\n\t\t\t\t\t \n\t\t\t\t\tEXCEPTION(EX_Invalid);\n\t\t\t\t\tif (!(control_word & CW_Invalid))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\ttempl |= (0x40000000 >> 8);\n\t\t\t\t}\n\t\t\t\ttempl |= 0x7f800000;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tEXCEPTION(EX_Invalid);\n\t\t\t\tif (!(control_word & CW_Invalid))\n\t\t\t\t\treturn 0;\n\t\t\t\ttempl = 0xffc00000;\n\t\t\t}\n\t\t}\n#ifdef PARANOID\n\t\telse {\n\t\t\tEXCEPTION(EX_INTERNAL | 0x164);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t} else if (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tif (control_word & EX_Invalid) {\n\t\t\t \n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_access_ok(single, 4);\n\t\t\tFPU_put_user(0xffc00000,\n\t\t\t\t     (unsigned long __user *)single);\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n#ifdef PARANOID\n\telse {\n\t\tEXCEPTION(EX_INTERNAL | 0x163);\n\t\treturn 0;\n\t}\n#endif\n\tif (getsign(st0_ptr))\n\t\ttempl |= 0x80000000;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(single, 4);\n\tFPU_put_user(templ, (unsigned long __user *)single);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \nint FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, long long __user *d)\n{\n\tFPU_REG t;\n\tlong long tll;\n\tint precision_loss;\n\n\tif (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tgoto invalid_operand;\n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tgoto invalid_operand;\n\t\t}\n\t}\n\n\treg_copy(st0_ptr, &t);\n\tprecision_loss = FPU_round_to_int(&t, st0_tag);\n\t((long *)&tll)[0] = t.sigl;\n\t((long *)&tll)[1] = t.sigh;\n\tif ((precision_loss == 1) ||\n\t    ((t.sigh & 0x80000000) &&\n\t     !((t.sigh == 0x80000000) && (t.sigl == 0) && signnegative(&t)))) {\n\t\tEXCEPTION(EX_Invalid);\n\t\t \n\t      invalid_operand:\n\t\tif (control_word & EX_Invalid) {\n\t\t\t \n\t\t\ttll = 0x8000000000000000LL;\n\t\t} else\n\t\t\treturn 0;\n\t} else {\n\t\tif (precision_loss)\n\t\t\tset_precision_flag(precision_loss);\n\t\tif (signnegative(&t))\n\t\t\ttll = -tll;\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(d, 8);\n\tif (copy_to_user(d, &tll, 8))\n\t\tFPU_abort;\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \nint FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, long __user *d)\n{\n\tFPU_REG t;\n\tint precision_loss;\n\n\tif (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tgoto invalid_operand;\n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tgoto invalid_operand;\n\t\t}\n\t}\n\n\treg_copy(st0_ptr, &t);\n\tprecision_loss = FPU_round_to_int(&t, st0_tag);\n\tif (t.sigh ||\n\t    ((t.sigl & 0x80000000) &&\n\t     !((t.sigl == 0x80000000) && signnegative(&t)))) {\n\t\tEXCEPTION(EX_Invalid);\n\t\t \n\t      invalid_operand:\n\t\tif (control_word & EX_Invalid) {\n\t\t\t \n\t\t\tt.sigl = 0x80000000;\n\t\t} else\n\t\t\treturn 0;\n\t} else {\n\t\tif (precision_loss)\n\t\t\tset_precision_flag(precision_loss);\n\t\tif (signnegative(&t))\n\t\t\tt.sigl = -(long)t.sigl;\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(d, 4);\n\tFPU_put_user(t.sigl, (unsigned long __user *)d);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \nint FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, short __user *d)\n{\n\tFPU_REG t;\n\tint precision_loss;\n\n\tif (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tgoto invalid_operand;\n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tgoto invalid_operand;\n\t\t}\n\t}\n\n\treg_copy(st0_ptr, &t);\n\tprecision_loss = FPU_round_to_int(&t, st0_tag);\n\tif (t.sigh ||\n\t    ((t.sigl & 0xffff8000) &&\n\t     !((t.sigl == 0x8000) && signnegative(&t)))) {\n\t\tEXCEPTION(EX_Invalid);\n\t\t \n\t      invalid_operand:\n\t\tif (control_word & EX_Invalid) {\n\t\t\t \n\t\t\tt.sigl = 0x8000;\n\t\t} else\n\t\t\treturn 0;\n\t} else {\n\t\tif (precision_loss)\n\t\t\tset_precision_flag(precision_loss);\n\t\tif (signnegative(&t))\n\t\t\tt.sigl = -t.sigl;\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(d, 2);\n\tFPU_put_user((short)t.sigl, d);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \nint FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char __user *d)\n{\n\tFPU_REG t;\n\tunsigned long long ll;\n\tu_char b;\n\tint i, precision_loss;\n\tu_char sign = (getsign(st0_ptr) == SIGN_NEG) ? 0x80 : 0;\n\n\tif (st0_tag == TAG_Empty) {\n\t\t \n\t\tEXCEPTION(EX_StackUnder);\n\t\tgoto invalid_operand;\n\t} else if (st0_tag == TAG_Special) {\n\t\tst0_tag = FPU_Special(st0_ptr);\n\t\tif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\tgoto invalid_operand;\n\t\t}\n\t}\n\n\treg_copy(st0_ptr, &t);\n\tprecision_loss = FPU_round_to_int(&t, st0_tag);\n\tll = significand(&t);\n\n\t \n\tif ((t.sigh > 0x0de0b6b3) ||\n\t    ((t.sigh == 0x0de0b6b3) && (t.sigl > 0xa763ffff))) {\n\t\tEXCEPTION(EX_Invalid);\n\t\t \n\t      invalid_operand:\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_access_ok(d, 10);\n\t\t\tfor (i = 0; i < 7; i++)\n\t\t\t\tFPU_put_user(0, d + i);\t \n\t\t\tFPU_put_user(0xc0, d + 7);\t \n\t\t\tFPU_put_user(0xff, d + 8);\n\t\t\tFPU_put_user(0xff, d + 9);\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t} else if (precision_loss) {\n\t\t \n\t\tset_precision_flag(precision_loss);\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(d, 10);\n\tRE_ENTRANT_CHECK_ON;\n\tfor (i = 0; i < 9; i++) {\n\t\tb = FPU_div_small(&ll, 10);\n\t\tb |= (FPU_div_small(&ll, 10)) << 4;\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_put_user(b, d + i);\n\t\tRE_ENTRANT_CHECK_ON;\n\t}\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_put_user(sign, d + 9);\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 1;\n}\n\n \n\n \n \n \nint FPU_round_to_int(FPU_REG *r, u_char tag)\n{\n\tu_char very_big;\n\tunsigned eax;\n\n\tif (tag == TAG_Zero) {\n\t\t \n\t\tsignificand(r) = 0;\n\t\treturn 0;\t \n\t}\n\n\tif (exponent(r) > 63) {\n\t\tr->sigl = r->sigh = ~0;\t \n\t\treturn 1;\t \n\t}\n\n\teax = FPU_shrxs(&r->sigl, 63 - exponent(r));\n\tvery_big = !(~(r->sigh) | ~(r->sigl));\t \n#define\thalf_or_more\t(eax & 0x80000000)\n#define\tfrac_part\t(eax)\n#define more_than_half  ((eax & 0x80000001) == 0x80000001)\n\tswitch (control_word & CW_RC) {\n\tcase RC_RND:\n\t\tif (more_than_half\t \n\t\t    || (half_or_more && (r->sigl & 1))) {\t \n\t\t\tif (very_big)\n\t\t\t\treturn 1;\t \n\t\t\tsignificand(r)++;\n\t\t\treturn PRECISION_LOST_UP;\n\t\t}\n\t\tbreak;\n\tcase RC_DOWN:\n\t\tif (frac_part && getsign(r)) {\n\t\t\tif (very_big)\n\t\t\t\treturn 1;\t \n\t\t\tsignificand(r)++;\n\t\t\treturn PRECISION_LOST_UP;\n\t\t}\n\t\tbreak;\n\tcase RC_UP:\n\t\tif (frac_part && !getsign(r)) {\n\t\t\tif (very_big)\n\t\t\t\treturn 1;\t \n\t\t\tsignificand(r)++;\n\t\t\treturn PRECISION_LOST_UP;\n\t\t}\n\t\tbreak;\n\tcase RC_CHOP:\n\t\tbreak;\n\t}\n\n\treturn eax ? PRECISION_LOST_DOWN : 0;\n\n}\n\n \n\nu_char __user *fldenv(fpu_addr_modes addr_modes, u_char __user *s)\n{\n\tunsigned short tag_word = 0;\n\tu_char tag;\n\tint i;\n\n\tif ((addr_modes.default_mode == VM86) ||\n\t    ((addr_modes.default_mode == PM16)\n\t     ^ (addr_modes.override.operand_size == OP_SIZE_PREFIX))) {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(s, 0x0e);\n\t\tFPU_get_user(control_word, (unsigned short __user *)s);\n\t\tFPU_get_user(partial_status, (unsigned short __user *)(s + 2));\n\t\tFPU_get_user(tag_word, (unsigned short __user *)(s + 4));\n\t\tFPU_get_user(instruction_address.offset,\n\t\t\t     (unsigned short __user *)(s + 6));\n\t\tFPU_get_user(instruction_address.selector,\n\t\t\t     (unsigned short __user *)(s + 8));\n\t\tFPU_get_user(operand_address.offset,\n\t\t\t     (unsigned short __user *)(s + 0x0a));\n\t\tFPU_get_user(operand_address.selector,\n\t\t\t     (unsigned short __user *)(s + 0x0c));\n\t\tRE_ENTRANT_CHECK_ON;\n\t\ts += 0x0e;\n\t\tif (addr_modes.default_mode == VM86) {\n\t\t\tinstruction_address.offset\n\t\t\t    += (instruction_address.selector & 0xf000) << 4;\n\t\t\toperand_address.offset +=\n\t\t\t    (operand_address.selector & 0xf000) << 4;\n\t\t}\n\t} else {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(s, 0x1c);\n\t\tFPU_get_user(control_word, (unsigned short __user *)s);\n\t\tFPU_get_user(partial_status, (unsigned short __user *)(s + 4));\n\t\tFPU_get_user(tag_word, (unsigned short __user *)(s + 8));\n\t\tFPU_get_user(instruction_address.offset,\n\t\t\t     (unsigned long __user *)(s + 0x0c));\n\t\tFPU_get_user(instruction_address.selector,\n\t\t\t     (unsigned short __user *)(s + 0x10));\n\t\tFPU_get_user(instruction_address.opcode,\n\t\t\t     (unsigned short __user *)(s + 0x12));\n\t\tFPU_get_user(operand_address.offset,\n\t\t\t     (unsigned long __user *)(s + 0x14));\n\t\tFPU_get_user(operand_address.selector,\n\t\t\t     (unsigned long __user *)(s + 0x18));\n\t\tRE_ENTRANT_CHECK_ON;\n\t\ts += 0x1c;\n\t}\n\n#ifdef PECULIAR_486\n\tcontrol_word &= ~0xe080;\n#endif  \n\n\ttop = (partial_status >> SW_Top_Shift) & 7;\n\n\tif (partial_status & ~control_word & CW_Exceptions)\n\t\tpartial_status |= (SW_Summary | SW_Backward);\n\telse\n\t\tpartial_status &= ~(SW_Summary | SW_Backward);\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttag = tag_word & 3;\n\t\ttag_word >>= 2;\n\n\t\tif (tag == TAG_Empty)\n\t\t\t \n\t\t\tFPU_settag(i, TAG_Empty);\n\t\telse if (FPU_gettag(i) == TAG_Empty) {\n\t\t\t \n\t\t\tif (exponent(&fpu_register(i)) == -EXTENDED_Ebias) {\n\t\t\t\tif (!\n\t\t\t\t    (fpu_register(i).sigl | fpu_register(i).\n\t\t\t\t     sigh))\n\t\t\t\t\tFPU_settag(i, TAG_Zero);\n\t\t\t\telse\n\t\t\t\t\tFPU_settag(i, TAG_Special);\n\t\t\t} else if (exponent(&fpu_register(i)) ==\n\t\t\t\t   0x7fff - EXTENDED_Ebias) {\n\t\t\t\tFPU_settag(i, TAG_Special);\n\t\t\t} else if (fpu_register(i).sigh & 0x80000000)\n\t\t\t\tFPU_settag(i, TAG_Valid);\n\t\t\telse\n\t\t\t\tFPU_settag(i, TAG_Special);\t \n\t\t}\n\t\t \n\t}\n\n\treturn s;\n}\n\nvoid FPU_frstor(fpu_addr_modes addr_modes, u_char __user *data_address)\n{\n\tint i, regnr;\n\tu_char __user *s = fldenv(addr_modes, data_address);\n\tint offset = (top & 7) * 10, other = 80 - offset;\n\n\t \n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(s, 80);\n\tFPU_copy_from_user(register_base + offset, s, other);\n\tif (offset)\n\t\tFPU_copy_from_user(register_base, s + other, offset);\n\tRE_ENTRANT_CHECK_ON;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tregnr = (i + top) & 7;\n\t\tif (FPU_gettag(regnr) != TAG_Empty)\n\t\t\t \n\t\t\tFPU_settag(regnr, FPU_tagof(&st(i)));\n\t}\n\n}\n\nu_char __user *fstenv(fpu_addr_modes addr_modes, u_char __user *d)\n{\n\tif ((addr_modes.default_mode == VM86) ||\n\t    ((addr_modes.default_mode == PM16)\n\t     ^ (addr_modes.override.operand_size == OP_SIZE_PREFIX))) {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(d, 14);\n#ifdef PECULIAR_486\n\t\tFPU_put_user(control_word & ~0xe080, (unsigned long __user *)d);\n#else\n\t\tFPU_put_user(control_word, (unsigned short __user *)d);\n#endif  \n\t\tFPU_put_user(status_word(), (unsigned short __user *)(d + 2));\n\t\tFPU_put_user(fpu_tag_word, (unsigned short __user *)(d + 4));\n\t\tFPU_put_user(instruction_address.offset,\n\t\t\t     (unsigned short __user *)(d + 6));\n\t\tFPU_put_user(operand_address.offset,\n\t\t\t     (unsigned short __user *)(d + 0x0a));\n\t\tif (addr_modes.default_mode == VM86) {\n\t\t\tFPU_put_user((instruction_address.\n\t\t\t\t      offset & 0xf0000) >> 4,\n\t\t\t\t     (unsigned short __user *)(d + 8));\n\t\t\tFPU_put_user((operand_address.offset & 0xf0000) >> 4,\n\t\t\t\t     (unsigned short __user *)(d + 0x0c));\n\t\t} else {\n\t\t\tFPU_put_user(instruction_address.selector,\n\t\t\t\t     (unsigned short __user *)(d + 8));\n\t\t\tFPU_put_user(operand_address.selector,\n\t\t\t\t     (unsigned short __user *)(d + 0x0c));\n\t\t}\n\t\tRE_ENTRANT_CHECK_ON;\n\t\td += 0x0e;\n\t} else {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tFPU_access_ok(d, 7 * 4);\n#ifdef PECULIAR_486\n\t\tcontrol_word &= ~0xe080;\n\t\t \n\t\tcontrol_word |= 0xffff0040;\n\t\tpartial_status = status_word() | 0xffff0000;\n\t\tfpu_tag_word |= 0xffff0000;\n\t\tI387->soft.fcs &= ~0xf8000000;\n\t\tI387->soft.fos |= 0xffff0000;\n#endif  \n\t\tif (__copy_to_user(d, &control_word, 7 * 4))\n\t\t\tFPU_abort;\n\t\tRE_ENTRANT_CHECK_ON;\n\t\td += 0x1c;\n\t}\n\n\tcontrol_word |= CW_Exceptions;\n\tpartial_status &= ~(SW_Summary | SW_Backward);\n\n\treturn d;\n}\n\nvoid fsave(fpu_addr_modes addr_modes, u_char __user *data_address)\n{\n\tu_char __user *d;\n\tint offset = (top & 7) * 10, other = 80 - offset;\n\n\td = fstenv(addr_modes, data_address);\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_access_ok(d, 80);\n\n\t \n\tif (__copy_to_user(d, register_base + offset, other))\n\t\tFPU_abort;\n\tif (offset)\n\t\tif (__copy_to_user(d + other, register_base, offset))\n\t\t\tFPU_abort;\n\tRE_ENTRANT_CHECK_ON;\n\n\tfinit();\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}