{
  "module_name": "fpu_emu.h",
  "hash_id": "652ee8dfcb0051ec70f649fce2fc3c69b0d7d93f218979790e768ecdc4c1ad3f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/fpu_emu.h",
  "human_readable_source": " \n \n\n#ifndef _FPU_EMU_H_\n#define _FPU_EMU_H_\n\n \n#define PECULIAR_486\n\n#ifdef __ASSEMBLY__\n#include \"fpu_asm.h\"\n#define\tConst(x)\t$##x\n#else\n#define\tConst(x)\tx\n#endif\n\n#define EXP_BIAS\tConst(0)\n#define EXP_OVER\tConst(0x4000)\t \n#define\tEXP_UNDER\tConst(-0x3fff)\t \n#define EXP_WAY_UNDER   Const(-0x6000)\t \n#define EXP_Infinity    EXP_OVER\n#define EXP_NaN         EXP_OVER\n\n#define EXTENDED_Ebias Const(0x3fff)\n#define EXTENDED_Emin (-0x3ffe)\t \n\n#define SIGN_POS\tConst(0)\n#define SIGN_NEG\tConst(0x80)\n\n#define SIGN_Positive\tConst(0)\n#define SIGN_Negative\tConst(0x8000)\n\n \n \n#define TW_Denormal     Const(4)\t \n#define TW_Infinity\tConst(5)\t \n#define\tTW_NaN\t\tConst(6)\t \n#define\tTW_Unsupported\tConst(7)\t \n\n#define TAG_Valid\tConst(0)\t \n#define TAG_Zero\tConst(1)\t \n#define TAG_Special\tConst(2)\t \n#define TAG_Empty\tConst(3)\t \n#define TAG_Error\tConst(0x80)\t \n\n#define LOADED_DATA\tConst(10101)\t \n\n \n#define REV             0x10\n#define DEST_RM         0x20\n#define LOADED          0x40\n\n#define FPU_Exception   Const(0x80000000)\t \n\n#ifndef __ASSEMBLY__\n\n#include \"fpu_system.h\"\n\n#include <uapi/asm/sigcontext.h>\t \n#include <asm/math_emu.h>\n#include <linux/linkage.h>\n\n \n\n#ifdef RE_ENTRANT_CHECKING\nextern u_char emulating;\n#  define RE_ENTRANT_CHECK_OFF emulating = 0\n#  define RE_ENTRANT_CHECK_ON emulating = 1\n#else\n#  define RE_ENTRANT_CHECK_OFF\n#  define RE_ENTRANT_CHECK_ON\n#endif  \n\n#define FWAIT_OPCODE 0x9b\n#define OP_SIZE_PREFIX 0x66\n#define ADDR_SIZE_PREFIX 0x67\n#define PREFIX_CS 0x2e\n#define PREFIX_DS 0x3e\n#define PREFIX_ES 0x26\n#define PREFIX_SS 0x36\n#define PREFIX_FS 0x64\n#define PREFIX_GS 0x65\n#define PREFIX_REPE 0xf3\n#define PREFIX_REPNE 0xf2\n#define PREFIX_LOCK 0xf0\n#define PREFIX_CS_ 1\n#define PREFIX_DS_ 2\n#define PREFIX_ES_ 3\n#define PREFIX_FS_ 4\n#define PREFIX_GS_ 5\n#define PREFIX_SS_ 6\n#define PREFIX_DEFAULT 7\n\nstruct address {\n\tunsigned int offset;\n\tunsigned int selector:16;\n\tunsigned int opcode:11;\n\tunsigned int empty:5;\n};\nstruct fpu__reg {\n\tunsigned sigl;\n\tunsigned sigh;\n\tshort exp;\n};\n\ntypedef void (*FUNC) (void);\ntypedef struct fpu__reg FPU_REG;\ntypedef void (*FUNC_ST0) (FPU_REG *st0_ptr, u_char st0_tag);\ntypedef struct {\n\tu_char address_size, operand_size, segment;\n} overrides;\n \ntypedef struct {\n\toverrides override;\n\tu_char default_mode;\n} fpu_addr_modes;\n \n#define PROTECTED 4\n#define SIXTEEN   1\t\t \n#define VM86      SIXTEEN\n#define PM16      (SIXTEEN | PROTECTED)\n#define SEG32     PROTECTED\nextern u_char const data_sizes_16[32];\n\n#define register_base ((u_char *) registers )\n#define fpu_register(x)  ( * ((FPU_REG *)( register_base + 10 * (x & 7) )) )\n#define\tst(x)      ( * ((FPU_REG *)( register_base + 10 * ((top+x) & 7) )) )\n\n#define\tSTACK_OVERFLOW\t(FPU_stackoverflow(&st_new_ptr))\n#define\tNOT_EMPTY(i)\t(!FPU_empty_i(i))\n\n#define\tNOT_EMPTY_ST0\t(st0_tag ^ TAG_Empty)\n\n#define poppop() { FPU_pop(); FPU_pop(); }\n\n \n#define push()\t{ top--; }\n\n#define signbyte(a) (((u_char *)(a))[9])\n#define getsign(a) (signbyte(a) & 0x80)\n#define setsign(a,b) { if ((b) != 0) signbyte(a) |= 0x80; else signbyte(a) &= 0x7f; }\n#define copysign(a,b) { if (getsign(a)) signbyte(b) |= 0x80; \\\n                        else signbyte(b) &= 0x7f; }\n#define changesign(a) { signbyte(a) ^= 0x80; }\n#define setpositive(a) { signbyte(a) &= 0x7f; }\n#define setnegative(a) { signbyte(a) |= 0x80; }\n#define signpositive(a) ( (signbyte(a) & 0x80) == 0 )\n#define signnegative(a) (signbyte(a) & 0x80)\n\nstatic inline void reg_copy(FPU_REG const *x, FPU_REG *y)\n{\n\t*(short *)&(y->exp) = *(const short *)&(x->exp);\n\t*(long long *)&(y->sigl) = *(const long long *)&(x->sigl);\n}\n\n#define exponent(x)  (((*(short *)&((x)->exp)) & 0x7fff) - EXTENDED_Ebias)\n#define setexponentpos(x,y) { (*(short *)&((x)->exp)) = \\\n  ((y) + EXTENDED_Ebias) & 0x7fff; }\n#define exponent16(x)         (*(short *)&((x)->exp))\n#define setexponent16(x,y)  { (*(short *)&((x)->exp)) = (u16)(y); }\n#define addexponent(x,y)    { (*(short *)&((x)->exp)) += (y); }\n#define stdexp(x)           { (*(short *)&((x)->exp)) += EXTENDED_Ebias; }\n\n#define isdenormal(ptr)   (exponent(ptr) == EXP_BIAS+EXP_UNDER)\n\n#define significand(x) ( ((unsigned long long *)&((x)->sigl))[0] )\n\n \n \n\nasmlinkage int FPU_normalize(FPU_REG *x);\nasmlinkage int FPU_normalize_nuo(FPU_REG *x);\nasmlinkage int FPU_u_sub(FPU_REG const *arg1, FPU_REG const *arg2,\n\t\t\t FPU_REG * answ, unsigned int control_w, u_char sign,\n\t\t\t int expa, int expb);\nasmlinkage int FPU_u_mul(FPU_REG const *arg1, FPU_REG const *arg2,\n\t\t\t FPU_REG * answ, unsigned int control_w, u_char sign,\n\t\t\t int expon);\nasmlinkage int FPU_u_div(FPU_REG const *arg1, FPU_REG const *arg2,\n\t\t\t FPU_REG * answ, unsigned int control_w, u_char sign);\nasmlinkage int FPU_u_add(FPU_REG const *arg1, FPU_REG const *arg2,\n\t\t\t FPU_REG * answ, unsigned int control_w, u_char sign,\n\t\t\t int expa, int expb);\nasmlinkage int wm_sqrt(FPU_REG *n, int dummy1, int dummy2,\n\t\t       unsigned int control_w, u_char sign);\nasmlinkage unsigned FPU_shrx(void *l, unsigned x);\nasmlinkage unsigned FPU_shrxs(void *v, unsigned x);\nasmlinkage unsigned long FPU_div_small(unsigned long long *x, unsigned long y);\nasmlinkage int FPU_round(FPU_REG *arg, unsigned int extent, int dummy,\n\t\t\t unsigned int control_w, u_char sign);\n\n#ifndef MAKING_PROTO\n#include \"fpu_proto.h\"\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}