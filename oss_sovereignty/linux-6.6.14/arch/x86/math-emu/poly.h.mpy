{
  "module_name": "poly.h",
  "hash_id": "ba1376a5b36c88ab27e52a58d5af74556a5f5c66d3f5669737231df0c3740217",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/poly.h",
  "human_readable_source": " \n \n\n#ifndef _POLY_H\n#define _POLY_H\n\n \ntypedef struct {\n\tunsigned long lsw;\n\tunsigned long midw;\n\tunsigned long msw;\n} Xsig;\n\nasmlinkage void mul64(unsigned long long const *a, unsigned long long const *b,\n\t\t      unsigned long long *result);\nasmlinkage void polynomial_Xsig(Xsig *, const unsigned long long *x,\n\t\t\t\tconst unsigned long long terms[], const int n);\n\nasmlinkage void mul32_Xsig(Xsig *, const unsigned long mult);\nasmlinkage void mul64_Xsig(Xsig *, const unsigned long long *mult);\nasmlinkage void mul_Xsig_Xsig(Xsig *dest, const Xsig *mult);\n\nasmlinkage void shr_Xsig(Xsig *, const int n);\nasmlinkage int round_Xsig(Xsig *);\nasmlinkage int norm_Xsig(Xsig *);\nasmlinkage void div_Xsig(Xsig *x1, const Xsig *x2, const Xsig *dest);\n\n \n#define LL_MSW(x)     (((unsigned long *)&x)[1])\n\n \n#define MK_XSIG(a,b,c)     { c, b, a }\n\n \n#define XSIG_LL(x)         (*(unsigned long long *)&x.midw)\n\n \n\n \n \nstatic inline unsigned long mul_32_32(const unsigned long arg1,\n\t\t\t\t      const unsigned long arg2)\n{\n\tint retval;\n\tasm volatile (\"mull %2; movl %%edx,%%eax\":\"=a\" (retval)\n\t\t      :\"0\"(arg1), \"g\"(arg2)\n\t\t      :\"dx\");\n\treturn retval;\n}\n\n \nstatic inline void add_Xsig_Xsig(Xsig *dest, const Xsig *x2)\n{\n\tasm volatile (\"movl %1,%%edi; movl %2,%%esi;\\n\"\n\t\t      \"movl (%%esi),%%eax; addl %%eax,(%%edi);\\n\"\n\t\t      \"movl 4(%%esi),%%eax; adcl %%eax,4(%%edi);\\n\"\n\t\t      \"movl 8(%%esi),%%eax; adcl %%eax,8(%%edi);\\n\":\"=g\"\n\t\t      (*dest):\"g\"(dest), \"g\"(x2)\n\t\t      :\"ax\", \"si\", \"di\");\n}\n\n \n \nstatic inline void add_two_Xsig(Xsig *dest, const Xsig *x2, long int *exp)\n{\n\tasm volatile (\"movl %2,%%ecx; movl %3,%%esi;\\n\"\n\t\t      \"movl (%%esi),%%eax; addl %%eax,(%%ecx);\\n\"\n\t\t      \"movl 4(%%esi),%%eax; adcl %%eax,4(%%ecx);\\n\"\n\t\t      \"movl 8(%%esi),%%eax; adcl %%eax,8(%%ecx);\\n\"\n\t\t      \"jnc 0f;\\n\"\n\t\t      \"rcrl 8(%%ecx); rcrl 4(%%ecx); rcrl (%%ecx)\\n\"\n\t\t      \"movl %4,%%ecx; incl (%%ecx)\\n\"\n\t\t      \"movl $1,%%eax; jmp 1f;\\n\"\n\t\t      \"0: xorl %%eax,%%eax;\\n\" \"1:\\n\":\"=g\" (*exp), \"=g\"(*dest)\n\t\t      :\"g\"(dest), \"g\"(x2), \"g\"(exp)\n\t\t      :\"cx\", \"si\", \"ax\");\n}\n\n \n \nstatic inline void negate_Xsig(Xsig *x)\n{\n\tasm volatile (\"movl %1,%%esi;\\n\"\n\t\t      \"xorl %%ecx,%%ecx;\\n\"\n\t\t      \"movl %%ecx,%%eax; subl (%%esi),%%eax; movl %%eax,(%%esi);\\n\"\n\t\t      \"movl %%ecx,%%eax; sbbl 4(%%esi),%%eax; movl %%eax,4(%%esi);\\n\"\n\t\t      \"movl %%ecx,%%eax; sbbl 8(%%esi),%%eax; movl %%eax,8(%%esi);\\n\":\"=g\"\n\t\t      (*x):\"g\"(x):\"si\", \"ax\", \"cx\");\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}