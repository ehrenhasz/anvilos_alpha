{
  "module_name": "fpu_entry.c",
  "hash_id": "3a7b5f5d6ed330d0128f8dcf7f36bc743edb506862f4aa2d79c72d3e11f79dcb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/fpu_entry.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/signal.h>\n#include <linux/regset.h>\n\n#include <linux/uaccess.h>\n#include <asm/traps.h>\n#include <asm/user.h>\n#include <asm/fpu/api.h>\n#include <asm/fpu/regset.h>\n\n#include \"fpu_system.h\"\n#include \"fpu_emu.h\"\n#include \"exception.h\"\n#include \"control_w.h\"\n#include \"status_w.h\"\n\n#define __BAD__ FPU_illegal\t \n\n \n\n \n\nstatic FUNC const st_instr_table[64] = {\n \n \n \tfadd__,\t\tfld_i_,\t\tfcmovb,\t\tfcmovnb,\n \tfadd_i,\t\tffree_,\t\tfaddp_,\t\tffreep, \n \tfmul__,\t\tfxch_i,\t\tfcmove,\t\tfcmovne,\n \tfmul_i,\t\tfxch_i, \tfmulp_,\t\tfxch_i, \n \tfcom_st,\tfp_nop,\t\tfcmovbe,\tfcmovnbe,\n \tfcom_st, \tfst_i_,\t\tfcompst, \tfstp_i, \n \tfcompst,\tfstp_i, \tfcmovu,\t\tfcmovnu,\n \tfcompst, \tfstp_i,\t\tfcompp,\t\tfstp_i, \n \tfsub__,\t\tFPU_etc,\t__BAD__,\tfinit_,\n \tfsubri,\t\tfucom_,\t\tfsubrp,\t\tfstsw_,\n \tfsubr_,\t\tfconst,\t\tfucompp,\tfucomi_,\n \tfsub_i,\t\tfucomp,\t\tfsubp_,\t\tfucomip,\n \tfdiv__,\t\tFPU_triga,\t__BAD__,\tfcomi_,\n \tfdivri,\t\t__BAD__,\tfdivrp,\t\tfcomip,\n \tfdivr_,\t\tFPU_trigb,\t__BAD__,\t__BAD__,\n \tfdiv_i,\t\t__BAD__,\tfdivp_,\t\t__BAD__,\n};\n\n#define _NONE_ 0\t\t \n#define _REG0_ 1\t\t \n#define _REGI_ 2\t\t \n#define _REGi_ 0\t\t \n#define _PUSH_ 3\t\t \n#define _null_ 4\t\t \n#define _REGIi 5\t\t \n#define _REGIp 6\t\t \n#define _REGIc 0\t\t \n#define _REGIn 0\t\t \n\nstatic u_char const type_table[64] = {\n \n \t_REGI_, _NONE_, _REGIn, _REGIn, _REGIi, _REGi_, _REGIp, _REGi_,\n \t_REGI_, _REGIn, _REGIn, _REGIn, _REGIi, _REGI_, _REGIp, _REGI_,\n \t_REGIc, _NONE_, _REGIn, _REGIn, _REGIc, _REG0_, _REGIc, _REG0_,\n \t_REGIc, _REG0_, _REGIn, _REGIn, _REGIc, _REG0_, _REGIc, _REG0_,\n \t_REGI_, _NONE_, _null_, _NONE_, _REGIi, _REGIc, _REGIp, _NONE_,\n \t_REGI_, _NONE_, _REGIc, _REGIc, _REGIi, _REGIc, _REGIp, _REGIc,\n \t_REGI_, _NONE_, _null_, _REGIc, _REGIi, _null_, _REGIp, _REGIc,\n \t_REGI_, _NONE_, _null_, _null_, _REGIi, _null_, _REGIp, _null_,\n};\n\n#ifdef RE_ENTRANT_CHECKING\nu_char emulating = 0;\n#endif  \n\nstatic int valid_prefix(u_char *Byte, u_char __user ** fpu_eip,\n\t\t\toverrides * override);\n\nvoid math_emulate(struct math_emu_info *info)\n{\n\tu_char FPU_modrm, byte1;\n\tunsigned short code;\n\tfpu_addr_modes addr_modes;\n\tint unmasked;\n\tFPU_REG loaded_data;\n\tFPU_REG *st0_ptr;\n\tu_char loaded_tag, st0_tag;\n\tvoid __user *data_address;\n\tstruct address data_sel_off;\n\tstruct address entry_sel_off;\n\tunsigned long code_base = 0;\n\tunsigned long code_limit = 0;\t \n\tstruct desc_struct code_descriptor;\n\n#ifdef RE_ENTRANT_CHECKING\n\tif (emulating) {\n\t\tprintk(\"ERROR: wm-FPU-emu is not RE-ENTRANT!\\n\");\n\t}\n\tRE_ENTRANT_CHECK_ON;\n#endif  \n\n\tFPU_info = info;\n\n\tFPU_ORIG_EIP = FPU_EIP;\n\n\tif ((FPU_EFLAGS & 0x00020000) != 0) {\n\t\t \n\t\taddr_modes.default_mode = VM86;\n\t\tFPU_EIP += code_base = FPU_CS << 4;\n\t\tcode_limit = code_base + 0xffff;\t \n\t} else if (FPU_CS == __USER_CS && FPU_DS == __USER_DS) {\n\t\taddr_modes.default_mode = 0;\n\t} else if (FPU_CS == __KERNEL_CS) {\n\t\tprintk(\"math_emulate: %04x:%08lx\\n\", FPU_CS, FPU_EIP);\n\t\tpanic(\"Math emulation needed in kernel\");\n\t} else {\n\n\t\tif ((FPU_CS & 4) != 4) {\t \n\t\t\t \n\t\t\tprintk(\"FPU emulator: Unsupported addressing mode\\n\");\n\t\t\tmath_abort(FPU_info, SIGILL);\n\t\t}\n\n\t\tcode_descriptor = FPU_get_ldt_descriptor(FPU_CS);\n\t\tif (code_descriptor.d) {\n\t\t\t \n\t\t\t \n\t\t\taddr_modes.default_mode = SEG32;\n\t\t} else {\n\t\t\t \n\t\t\taddr_modes.default_mode = PM16;\n\t\t}\n\t\tFPU_EIP += code_base = seg_get_base(&code_descriptor);\n\t\tcode_limit = seg_get_limit(&code_descriptor) + 1;\n\t\tcode_limit *= seg_get_granularity(&code_descriptor);\n\t\tcode_limit += code_base - 1;\n\t\tif (code_limit < code_base)\n\t\t\tcode_limit = 0xffffffff;\n\t}\n\n\tFPU_lookahead = !(FPU_EFLAGS & X86_EFLAGS_TF);\n\n\tif (!valid_prefix(&byte1, (u_char __user **) & FPU_EIP,\n\t\t\t  &addr_modes.override)) {\n\t\tRE_ENTRANT_CHECK_OFF;\n\t\tprintk\n\t\t    (\"FPU emulator: Unknown prefix byte 0x%02x, probably due to\\n\"\n\t\t     \"FPU emulator: self-modifying code! (emulation impossible)\\n\",\n\t\t     byte1);\n\t\tRE_ENTRANT_CHECK_ON;\n\t\tEXCEPTION(EX_INTERNAL | 0x126);\n\t\tmath_abort(FPU_info, SIGILL);\n\t}\n\n      do_another_FPU_instruction:\n\n\tno_ip_update = 0;\n\n\tFPU_EIP++;\t\t \n\n\tif (addr_modes.default_mode) {\n\t\t \n\t\tif (FPU_EIP > code_limit)\n\t\t\tmath_abort(FPU_info, SIGSEGV);\n\t}\n\n\tif ((byte1 & 0xf8) != 0xd8) {\n\t\tif (byte1 == FWAIT_OPCODE) {\n\t\t\tif (partial_status & SW_Summary)\n\t\t\t\tgoto do_the_FPU_interrupt;\n\t\t\telse\n\t\t\t\tgoto FPU_fwait_done;\n\t\t}\n#ifdef PARANOID\n\t\tEXCEPTION(EX_INTERNAL | 0x128);\n\t\tmath_abort(FPU_info, SIGILL);\n#endif  \n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_code_access_ok(1);\n\tFPU_get_user(FPU_modrm, (u_char __user *) FPU_EIP);\n\tRE_ENTRANT_CHECK_ON;\n\tFPU_EIP++;\n\n\tif (partial_status & SW_Summary) {\n\t\t \n\t\t \n\t\tcode = (FPU_modrm << 8) | byte1;\n\t\tif (!((((code & 0xf803) == 0xe003) ||\t \n\t\t       (((code & 0x3003) == 0x3001) &&\t \n\t\t\t((code & 0xc000) != 0xc000))))) {\n\t\t\t \n\t\t      do_the_FPU_interrupt:\n\n\t\t\tFPU_EIP = FPU_ORIG_EIP;\t \n\n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tcurrent->thread.trap_nr = X86_TRAP_MF;\n\t\t\tcurrent->thread.error_code = 0;\n\t\t\tsend_sig(SIGFPE, current, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tentry_sel_off.offset = FPU_ORIG_EIP;\n\tentry_sel_off.selector = FPU_CS;\n\tentry_sel_off.opcode = (byte1 << 8) | FPU_modrm;\n\tentry_sel_off.empty = 0;\n\n\tFPU_rm = FPU_modrm & 7;\n\n\tif (FPU_modrm < 0300) {\n\t\t \n\n\t\tif ((addr_modes.default_mode & SIXTEEN)\n\t\t    ^ (addr_modes.override.address_size == ADDR_SIZE_PREFIX))\n\t\t\tdata_address =\n\t\t\t    FPU_get_address_16(FPU_modrm, &FPU_EIP,\n\t\t\t\t\t       &data_sel_off, addr_modes);\n\t\telse\n\t\t\tdata_address =\n\t\t\t    FPU_get_address(FPU_modrm, &FPU_EIP, &data_sel_off,\n\t\t\t\t\t    addr_modes);\n\n\t\tif (addr_modes.default_mode) {\n\t\t\tif (FPU_EIP - 1 > code_limit)\n\t\t\t\tmath_abort(FPU_info, SIGSEGV);\n\t\t}\n\n\t\tif (!(byte1 & 1)) {\n\t\t\tunsigned short status1 = partial_status;\n\n\t\t\tst0_ptr = &st(0);\n\t\t\tst0_tag = FPU_gettag0();\n\n\t\t\t \n\t\t\tif (NOT_EMPTY_ST0) {\n\t\t\t\tif (addr_modes.default_mode & PROTECTED) {\n\t\t\t\t\t \n\t\t\t\t\tif (access_limit <\n\t\t\t\t\t    data_sizes_16[(byte1 >> 1) & 3])\n\t\t\t\t\t\tmath_abort(FPU_info, SIGSEGV);\n\t\t\t\t}\n\n\t\t\t\tunmasked = 0;\t \n\t\t\t\tswitch ((byte1 >> 1) & 3) {\n\t\t\t\tcase 0:\n\t\t\t\t\tunmasked =\n\t\t\t\t\t    FPU_load_single((float __user *)\n\t\t\t\t\t\t\t    data_address,\n\t\t\t\t\t\t\t    &loaded_data);\n\t\t\t\t\tloaded_tag = unmasked & 0xff;\n\t\t\t\t\tunmasked &= ~0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tloaded_tag =\n\t\t\t\t\t    FPU_load_int32((long __user *)\n\t\t\t\t\t\t\t   data_address,\n\t\t\t\t\t\t\t   &loaded_data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tunmasked =\n\t\t\t\t\t    FPU_load_double((double __user *)\n\t\t\t\t\t\t\t    data_address,\n\t\t\t\t\t\t\t    &loaded_data);\n\t\t\t\t\tloaded_tag = unmasked & 0xff;\n\t\t\t\t\tunmasked &= ~0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\tdefault:\t \n\t\t\t\t\tloaded_tag =\n\t\t\t\t\t    FPU_load_int16((short __user *)\n\t\t\t\t\t\t\t   data_address,\n\t\t\t\t\t\t\t   &loaded_data);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (((st0_tag == TAG_Special) && isNaN(st0_ptr))\n\t\t\t\t    || ((loaded_tag == TAG_Special)\n\t\t\t\t\t&& isNaN(&loaded_data))) {\n\t\t\t\t\t \n\t\t\t\t\tpartial_status = status1;\n\t\t\t\t\tif ((FPU_modrm & 0x30) == 0x10) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tEXCEPTION(EX_Invalid);\n\t\t\t\t\t\tsetcc(SW_C3 | SW_C2 | SW_C0);\n\t\t\t\t\t\tif ((FPU_modrm & 0x08)\n\t\t\t\t\t\t    && (control_word &\n\t\t\t\t\t\t\tCW_Invalid))\n\t\t\t\t\t\t\tFPU_pop();\t \n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (loaded_tag == TAG_Special)\n\t\t\t\t\t\t\tloaded_tag =\n\t\t\t\t\t\t\t    FPU_Special\n\t\t\t\t\t\t\t    (&loaded_data);\n#ifdef PECULIAR_486\n\t\t\t\t\t\t \n\t\t\t\t\t\tif ((FPU_modrm & 0x28) == 0x20)\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\treal_2op_NaN\n\t\t\t\t\t\t\t    (&loaded_data,\n\t\t\t\t\t\t\t     loaded_tag, 0,\n\t\t\t\t\t\t\t     &loaded_data);\n\t\t\t\t\t\telse\n#endif  \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\treal_2op_NaN\n\t\t\t\t\t\t\t    (&loaded_data,\n\t\t\t\t\t\t\t     loaded_tag, 0,\n\t\t\t\t\t\t\t     st0_ptr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto reg_mem_instr_done;\n\t\t\t\t}\n\n\t\t\t\tif (unmasked && !((FPU_modrm & 0x30) == 0x10)) {\n\t\t\t\t\t \n\t\t\t\t\tif ((FPU_modrm & 0x38) == 0x38) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif ((st0_tag == TAG_Zero) &&\n\t\t\t\t\t\t    ((loaded_tag == TAG_Valid)\n\t\t\t\t\t\t     || (loaded_tag ==\n\t\t\t\t\t\t\t TAG_Special\n\t\t\t\t\t\t\t &&\n\t\t\t\t\t\t\t isdenormal\n\t\t\t\t\t\t\t (&loaded_data)))) {\n\t\t\t\t\t\t\tif (FPU_divide_by_zero\n\t\t\t\t\t\t\t    (0,\n\t\t\t\t\t\t\t     getsign\n\t\t\t\t\t\t\t     (&loaded_data))\n\t\t\t\t\t\t\t    < 0) {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tpartial_status\n\t\t\t\t\t\t\t\t    &=\n\t\t\t\t\t\t\t\t    ~SW_Denorm_Op;\n\t\t\t\t\t\t\t\tpartial_status\n\t\t\t\t\t\t\t\t    |=\n\t\t\t\t\t\t\t\t    status1 &\n\t\t\t\t\t\t\t\t    SW_Denorm_Op;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tsetsign(st0_ptr,\n\t\t\t\t\t\t\t\t\tgetsign\n\t\t\t\t\t\t\t\t\t(&loaded_data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgoto reg_mem_instr_done;\n\t\t\t\t}\n\n\t\t\t\tswitch ((FPU_modrm >> 3) & 7) {\n\t\t\t\tcase 0:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tFPU_add(&loaded_data, loaded_tag, 0,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tFPU_mul(&loaded_data, loaded_tag, 0,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t \n\t\t\t\t\tFPU_compare_st_data(&loaded_data,\n\t\t\t\t\t\t\t    loaded_tag);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t \n\t\t\t\t\tif (!FPU_compare_st_data\n\t\t\t\t\t    (&loaded_data, loaded_tag)\n\t\t\t\t\t    && !unmasked)\n\t\t\t\t\t\tFPU_pop();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tFPU_sub(LOADED | loaded_tag,\n\t\t\t\t\t\t(int)&loaded_data,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tFPU_sub(REV | LOADED | loaded_tag,\n\t\t\t\t\t\t(int)&loaded_data,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tFPU_div(LOADED | loaded_tag,\n\t\t\t\t\t\t(int)&loaded_data,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\t \n\t\t\t\t\tclear_C1();\n\t\t\t\t\tif (st0_tag == TAG_Zero)\n\t\t\t\t\t\tpartial_status = status1;\t \n\t\t\t\t\tFPU_div(REV | LOADED | loaded_tag,\n\t\t\t\t\t\t(int)&loaded_data,\n\t\t\t\t\t\tcontrol_word);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((FPU_modrm & 0x30) == 0x10) {\n\t\t\t\t\t \n\t\t\t\t\tEXCEPTION(EX_StackUnder);\n\t\t\t\t\tsetcc(SW_C3 | SW_C2 | SW_C0);\n\t\t\t\t\tif ((FPU_modrm & 0x08)\n\t\t\t\t\t    && (control_word & CW_Invalid))\n\t\t\t\t\t\tFPU_pop();\t \n\t\t\t\t} else\n\t\t\t\t\tFPU_stack_underflow();\n\t\t\t}\n\t\t      reg_mem_instr_done:\n\t\t\toperand_address = data_sel_off;\n\t\t} else {\n\t\t\tif (!(no_ip_update =\n\t\t\t      FPU_load_store(((FPU_modrm & 0x38) | (byte1 & 6))\n\t\t\t\t\t     >> 1, addr_modes, data_address))) {\n\t\t\t\toperand_address = data_sel_off;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t \n\t\tu_char instr_index = (FPU_modrm & 0x38) | (byte1 & 7);\n\n#ifdef PECULIAR_486\n\t\t \n\t\toperand_address.offset = 0;\n\t\toperand_address.selector = FPU_DS;\n#endif  \n\n\t\tst0_ptr = &st(0);\n\t\tst0_tag = FPU_gettag0();\n\t\tswitch (type_table[(int)instr_index]) {\n\t\tcase _NONE_:\t \n\t\t\tbreak;\n\t\tcase _REG0_:\n\t\t\tif (!NOT_EMPTY_ST0) {\n\t\t\t\tFPU_stack_underflow();\n\t\t\t\tgoto FPU_instruction_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _REGIi:\n\t\t\tif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\n\t\t\t\tFPU_stack_underflow_i(FPU_rm);\n\t\t\t\tgoto FPU_instruction_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _REGIp:\n\t\t\tif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\n\t\t\t\tFPU_stack_underflow_pop(FPU_rm);\n\t\t\t\tgoto FPU_instruction_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _REGI_:\n\t\t\tif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\n\t\t\t\tFPU_stack_underflow();\n\t\t\t\tgoto FPU_instruction_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _PUSH_:\t \n\t\t\tbreak;\n\t\tcase _null_:\n\t\t\tFPU_illegal();\n\t\t\tgoto FPU_instruction_done;\n\t\tdefault:\n\t\t\tEXCEPTION(EX_INTERNAL | 0x111);\n\t\t\tgoto FPU_instruction_done;\n\t\t}\n\t\t(*st_instr_table[(int)instr_index]) ();\n\n\t      FPU_instruction_done:\n\t\t;\n\t}\n\n\tif (!no_ip_update)\n\t\tinstruction_address = entry_sel_off;\n\n      FPU_fwait_done:\n\n#ifdef DEBUG\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_printall();\n\tRE_ENTRANT_CHECK_ON;\n#endif  \n\n\tif (FPU_lookahead && !need_resched()) {\n\t\tFPU_ORIG_EIP = FPU_EIP - code_base;\n\t\tif (valid_prefix(&byte1, (u_char __user **) & FPU_EIP,\n\t\t\t\t &addr_modes.override))\n\t\t\tgoto do_another_FPU_instruction;\n\t}\n\n\tif (addr_modes.default_mode)\n\t\tFPU_EIP -= code_base;\n\n\tRE_ENTRANT_CHECK_OFF;\n}\n\n \nstatic int valid_prefix(u_char *Byte, u_char __user **fpu_eip,\n\t\t\toverrides * override)\n{\n\tu_char byte;\n\tu_char __user *ip = *fpu_eip;\n\n\t*override = (overrides) {\n\t0, 0, PREFIX_DEFAULT};\t \n\n\tRE_ENTRANT_CHECK_OFF;\n\tFPU_code_access_ok(1);\n\tFPU_get_user(byte, ip);\n\tRE_ENTRANT_CHECK_ON;\n\n\twhile (1) {\n\t\tswitch (byte) {\n\t\tcase ADDR_SIZE_PREFIX:\n\t\t\toverride->address_size = ADDR_SIZE_PREFIX;\n\t\t\tgoto do_next_byte;\n\n\t\tcase OP_SIZE_PREFIX:\n\t\t\toverride->operand_size = OP_SIZE_PREFIX;\n\t\t\tgoto do_next_byte;\n\n\t\tcase PREFIX_CS:\n\t\t\toverride->segment = PREFIX_CS_;\n\t\t\tgoto do_next_byte;\n\t\tcase PREFIX_ES:\n\t\t\toverride->segment = PREFIX_ES_;\n\t\t\tgoto do_next_byte;\n\t\tcase PREFIX_SS:\n\t\t\toverride->segment = PREFIX_SS_;\n\t\t\tgoto do_next_byte;\n\t\tcase PREFIX_FS:\n\t\t\toverride->segment = PREFIX_FS_;\n\t\t\tgoto do_next_byte;\n\t\tcase PREFIX_GS:\n\t\t\toverride->segment = PREFIX_GS_;\n\t\t\tgoto do_next_byte;\n\t\tcase PREFIX_DS:\n\t\t\toverride->segment = PREFIX_DS_;\n\t\t\tgoto do_next_byte;\n\n \n \n\n\t\t\t \n\t\tcase PREFIX_REPE:\n\t\tcase PREFIX_REPNE:\n\n\t\t      do_next_byte:\n\t\t\tip++;\n\t\t\tRE_ENTRANT_CHECK_OFF;\n\t\t\tFPU_code_access_ok(1);\n\t\t\tFPU_get_user(byte, ip);\n\t\t\tRE_ENTRANT_CHECK_ON;\n\t\t\tbreak;\n\t\tcase FWAIT_OPCODE:\n\t\t\t*Byte = byte;\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tif ((byte & 0xf8) == 0xd8) {\n\t\t\t\t*Byte = byte;\n\t\t\t\t*fpu_eip = ip;\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*Byte = byte;\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid math_abort(struct math_emu_info *info, unsigned int signal)\n{\n\tFPU_EIP = FPU_ORIG_EIP;\n\tcurrent->thread.trap_nr = X86_TRAP_MF;\n\tcurrent->thread.error_code = 0;\n\tsend_sig(signal, current, 1);\n\tRE_ENTRANT_CHECK_OFF;\n      __asm__(\"movl %0,%%esp ; ret\": :\"g\"(((long)info) - 4));\n#ifdef PARANOID\n\tprintk(\"ERROR: wm-FPU-emu math_abort failed!\\n\");\n#endif  \n}\n\n#define S387 ((struct swregs_state *)s387)\n#define sstatus_word() \\\n  ((S387->swd & ~SW_Top & 0xffff) | ((S387->ftop << SW_Top_Shift) & SW_Top))\n\nint fpregs_soft_set(struct task_struct *target,\n\t\t    const struct user_regset *regset,\n\t\t    unsigned int pos, unsigned int count,\n\t\t    const void *kbuf, const void __user *ubuf)\n{\n\tstruct swregs_state *s387 = &target->thread.fpu.fpstate->regs.soft;\n\tvoid *space = s387->st_space;\n\tint ret;\n\tint offset, other, i, tags, regnr, tag, newtop;\n\n\tRE_ENTRANT_CHECK_OFF;\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, s387, 0,\n\t\t\t\t offsetof(struct swregs_state, st_space));\n\tRE_ENTRANT_CHECK_ON;\n\n\tif (ret)\n\t\treturn ret;\n\n\tS387->ftop = (S387->swd >> SW_Top_Shift) & 7;\n\toffset = (S387->ftop & 7) * 10;\n\tother = 80 - offset;\n\n\tRE_ENTRANT_CHECK_OFF;\n\n\t \n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t space + offset, 0, other);\n\tif (!ret && offset)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t space, 0, offset);\n\n\tRE_ENTRANT_CHECK_ON;\n\n\t \n\ttags = S387->twd;\n\tnewtop = S387->ftop;\n\tfor (i = 0; i < 8; i++) {\n\t\tregnr = (i + newtop) & 7;\n\t\tif (((tags >> ((regnr & 7) * 2)) & 3) != TAG_Empty) {\n\t\t\t \n\t\t\ttag =\n\t\t\t    FPU_tagof((FPU_REG *) ((u_char *) S387->st_space +\n\t\t\t\t\t\t   10 * regnr));\n\t\t\ttags &= ~(3 << (regnr * 2));\n\t\t\ttags |= (tag & 3) << (regnr * 2);\n\t\t}\n\t}\n\tS387->twd = tags;\n\n\treturn ret;\n}\n\nint fpregs_soft_get(struct task_struct *target,\n\t\t    const struct user_regset *regset,\n\t\t    struct membuf to)\n{\n\tstruct swregs_state *s387 = &target->thread.fpu.fpstate->regs.soft;\n\tconst void *space = s387->st_space;\n\tint offset = (S387->ftop & 7) * 10, other = 80 - offset;\n\n\tRE_ENTRANT_CHECK_OFF;\n\n#ifdef PECULIAR_486\n\tS387->cwd &= ~0xe080;\n\t \n\tS387->cwd |= 0xffff0040;\n\tS387->swd = sstatus_word() | 0xffff0000;\n\tS387->twd |= 0xffff0000;\n\tS387->fcs &= ~0xf8000000;\n\tS387->fos |= 0xffff0000;\n#endif  \n\n\tmembuf_write(&to, s387, offsetof(struct swregs_state, st_space));\n\tmembuf_write(&to, space + offset, other);\n\tmembuf_write(&to, space, offset);\n\n\tRE_ENTRANT_CHECK_ON;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}