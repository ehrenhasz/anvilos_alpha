{
  "module_name": "errors.c",
  "hash_id": "3956c34b2af802ab00b9dfc5551214bb4796110002238fd0bb1f5a6cd1996b72",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/errors.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/signal.h>\n\n#include <linux/uaccess.h>\n\n#include \"fpu_emu.h\"\n#include \"fpu_system.h\"\n#include \"exception.h\"\n#include \"status_w.h\"\n#include \"control_w.h\"\n#include \"reg_constant.h\"\n#include \"version.h\"\n\n \n#undef PRINT_MESSAGES\n \n\n#if 0\nvoid Un_impl(void)\n{\n\tu_char byte1, FPU_modrm;\n\tunsigned long address = FPU_ORIG_EIP;\n\n\tRE_ENTRANT_CHECK_OFF;\n\t \n\tprintk(\"Unimplemented FPU Opcode at eip=%p : \", (void __user *)address);\n\tif (FPU_CS == __USER_CS) {\n\t\twhile (1) {\n\t\t\tFPU_get_user(byte1, (u_char __user *) address);\n\t\t\tif ((byte1 & 0xf8) == 0xd8)\n\t\t\t\tbreak;\n\t\t\tprintk(\"[%02x]\", byte1);\n\t\t\taddress++;\n\t\t}\n\t\tprintk(\"%02x \", byte1);\n\t\tFPU_get_user(FPU_modrm, 1 + (u_char __user *) address);\n\n\t\tif (FPU_modrm >= 0300)\n\t\t\tprintk(\"%02x (%02x+%d)\\n\", FPU_modrm, FPU_modrm & 0xf8,\n\t\t\t       FPU_modrm & 7);\n\t\telse\n\t\t\tprintk(\"/%d\\n\", (FPU_modrm >> 3) & 7);\n\t} else {\n\t\tprintk(\"cs selector = %04x\\n\", FPU_CS);\n\t}\n\n\tRE_ENTRANT_CHECK_ON;\n\n\tEXCEPTION(EX_Invalid);\n\n}\n#endif  \n\n \nvoid FPU_illegal(void)\n{\n\tmath_abort(FPU_info, SIGILL);\n}\n\nvoid FPU_printall(void)\n{\n\tint i;\n\tstatic const char *tag_desc[] = { \"Valid\", \"Zero\", \"ERROR\", \"Empty\",\n\t\t\"DeNorm\", \"Inf\", \"NaN\"\n\t};\n\tu_char byte1, FPU_modrm;\n\tunsigned long address = FPU_ORIG_EIP;\n\n\tRE_ENTRANT_CHECK_OFF;\n\t \n\tprintk(\"At %p:\", (void *)address);\n\tif (FPU_CS == __USER_CS) {\n#define MAX_PRINTED_BYTES 20\n\t\tfor (i = 0; i < MAX_PRINTED_BYTES; i++) {\n\t\t\tFPU_get_user(byte1, (u_char __user *) address);\n\t\t\tif ((byte1 & 0xf8) == 0xd8) {\n\t\t\t\tprintk(\" %02x\", byte1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(\" [%02x]\", byte1);\n\t\t\taddress++;\n\t\t}\n\t\tif (i == MAX_PRINTED_BYTES)\n\t\t\tprintk(\" [more..]\\n\");\n\t\telse {\n\t\t\tFPU_get_user(FPU_modrm, 1 + (u_char __user *) address);\n\n\t\t\tif (FPU_modrm >= 0300)\n\t\t\t\tprintk(\" %02x (%02x+%d)\\n\", FPU_modrm,\n\t\t\t\t       FPU_modrm & 0xf8, FPU_modrm & 7);\n\t\t\telse\n\t\t\t\tprintk(\" /%d, mod=%d rm=%d\\n\",\n\t\t\t\t       (FPU_modrm >> 3) & 7,\n\t\t\t\t       (FPU_modrm >> 6) & 3, FPU_modrm & 7);\n\t\t}\n\t} else {\n\t\tprintk(\"%04x\\n\", FPU_CS);\n\t}\n\n\tpartial_status = status_word();\n\n#ifdef DEBUGGING\n\tif (partial_status & SW_Backward)\n\t\tprintk(\"SW: backward compatibility\\n\");\n\tif (partial_status & SW_C3)\n\t\tprintk(\"SW: condition bit 3\\n\");\n\tif (partial_status & SW_C2)\n\t\tprintk(\"SW: condition bit 2\\n\");\n\tif (partial_status & SW_C1)\n\t\tprintk(\"SW: condition bit 1\\n\");\n\tif (partial_status & SW_C0)\n\t\tprintk(\"SW: condition bit 0\\n\");\n\tif (partial_status & SW_Summary)\n\t\tprintk(\"SW: exception summary\\n\");\n\tif (partial_status & SW_Stack_Fault)\n\t\tprintk(\"SW: stack fault\\n\");\n\tif (partial_status & SW_Precision)\n\t\tprintk(\"SW: loss of precision\\n\");\n\tif (partial_status & SW_Underflow)\n\t\tprintk(\"SW: underflow\\n\");\n\tif (partial_status & SW_Overflow)\n\t\tprintk(\"SW: overflow\\n\");\n\tif (partial_status & SW_Zero_Div)\n\t\tprintk(\"SW: divide by zero\\n\");\n\tif (partial_status & SW_Denorm_Op)\n\t\tprintk(\"SW: denormalized operand\\n\");\n\tif (partial_status & SW_Invalid)\n\t\tprintk(\"SW: invalid operation\\n\");\n#endif  \n\n\tprintk(\" SW: b=%d st=%d es=%d sf=%d cc=%d%d%d%d ef=%d%d%d%d%d%d\\n\", partial_status & 0x8000 ? 1 : 0,\t \n\t       (partial_status & 0x3800) >> 11,\t \n\t       partial_status & 0x80 ? 1 : 0,\t \n\t       partial_status & 0x40 ? 1 : 0,\t \n\t       partial_status & SW_C3 ? 1 : 0, partial_status & SW_C2 ? 1 : 0,\t \n\t       partial_status & SW_C1 ? 1 : 0, partial_status & SW_C0 ? 1 : 0,\t \n\t       partial_status & SW_Precision ? 1 : 0,\n\t       partial_status & SW_Underflow ? 1 : 0,\n\t       partial_status & SW_Overflow ? 1 : 0,\n\t       partial_status & SW_Zero_Div ? 1 : 0,\n\t       partial_status & SW_Denorm_Op ? 1 : 0,\n\t       partial_status & SW_Invalid ? 1 : 0);\n\n\tprintk(\" CW: ic=%d rc=%d%d pc=%d%d iem=%d     ef=%d%d%d%d%d%d\\n\",\n\t       control_word & 0x1000 ? 1 : 0,\n\t       (control_word & 0x800) >> 11, (control_word & 0x400) >> 10,\n\t       (control_word & 0x200) >> 9, (control_word & 0x100) >> 8,\n\t       control_word & 0x80 ? 1 : 0,\n\t       control_word & SW_Precision ? 1 : 0,\n\t       control_word & SW_Underflow ? 1 : 0,\n\t       control_word & SW_Overflow ? 1 : 0,\n\t       control_word & SW_Zero_Div ? 1 : 0,\n\t       control_word & SW_Denorm_Op ? 1 : 0,\n\t       control_word & SW_Invalid ? 1 : 0);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tFPU_REG *r = &st(i);\n\t\tu_char tagi = FPU_gettagi(i);\n\n\t\tswitch (tagi) {\n\t\tcase TAG_Empty:\n\t\t\tcontinue;\n\t\tcase TAG_Zero:\n\t\tcase TAG_Special:\n\t\t\t \n\t\t\ttagi = FPU_Special(r);\n\t\t\tfallthrough;\n\t\tcase TAG_Valid:\n\t\t\tprintk(\"st(%d)  %c .%04lx %04lx %04lx %04lx e%+-6d \", i,\n\t\t\t       getsign(r) ? '-' : '+',\n\t\t\t       (long)(r->sigh >> 16),\n\t\t\t       (long)(r->sigh & 0xFFFF),\n\t\t\t       (long)(r->sigl >> 16),\n\t\t\t       (long)(r->sigl & 0xFFFF),\n\t\t\t       exponent(r) - EXP_BIAS + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Whoops! Error in errors.c: tag%d is %d \", i,\n\t\t\t       tagi);\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(\"%s\\n\", tag_desc[(int)(unsigned)tagi]);\n\t}\n\n\tRE_ENTRANT_CHECK_ON;\n\n}\n\nstatic struct {\n\tint type;\n\tconst char *name;\n} exception_names[] = {\n\t{\n\tEX_StackOver, \"stack overflow\"}, {\n\tEX_StackUnder, \"stack underflow\"}, {\n\tEX_Precision, \"loss of precision\"}, {\n\tEX_Underflow, \"underflow\"}, {\n\tEX_Overflow, \"overflow\"}, {\n\tEX_ZeroDiv, \"divide by zero\"}, {\n\tEX_Denormal, \"denormalized operand\"}, {\n\tEX_Invalid, \"invalid operation\"}, {\n\tEX_INTERNAL, \"INTERNAL BUG in \" FPU_VERSION}, {\n\t0, NULL}\n};\n\n \n\nasmlinkage __visible void FPU_exception(int n)\n{\n\tint i, int_type;\n\n\tint_type = 0;\t\t \n\tif (n & EX_INTERNAL) {\n\t\tint_type = n - EX_INTERNAL;\n\t\tn = EX_INTERNAL;\n\t\t \n\t\tpartial_status |= (SW_Exc_Mask | SW_Summary | SW_Backward);\n\t} else {\n\t\t \n\t\tn &= (SW_Exc_Mask);\n\t\t \n\t\tpartial_status |= n;\n\t\t \n\t\tif (partial_status & ~control_word & CW_Exceptions)\n\t\t\tpartial_status |= (SW_Summary | SW_Backward);\n\t\tif (n & (SW_Stack_Fault | EX_Precision)) {\n\t\t\tif (!(n & SW_C1))\n\t\t\t\t \n\t\t\t\tpartial_status &= ~SW_C1;\n\t\t}\n\t}\n\n\tRE_ENTRANT_CHECK_OFF;\n\tif ((~control_word & n & CW_Exceptions) || (n == EX_INTERNAL)) {\n\t\t \n\t\tfor (i = 0; exception_names[i].type; i++)\n\t\t\tif ((exception_names[i].type & n) ==\n\t\t\t    exception_names[i].type)\n\t\t\t\tbreak;\n\n\t\tif (exception_names[i].type) {\n#ifdef PRINT_MESSAGES\n\t\t\tprintk(\"FP Exception: %s!\\n\", exception_names[i].name);\n#endif  \n\t\t} else\n\t\t\tprintk(\"FPU emulator: Unknown Exception: 0x%04x!\\n\", n);\n\n\t\tif (n == EX_INTERNAL) {\n\t\t\tprintk(\"FPU emulator: Internal error type 0x%04x\\n\",\n\t\t\t       int_type);\n\t\t\tFPU_printall();\n\t\t}\n#ifdef PRINT_MESSAGES\n\t\telse\n\t\t\tFPU_printall();\n#endif  \n\n\t\t \n\t}\n\tRE_ENTRANT_CHECK_ON;\n\n#ifdef __DEBUG__\n\tmath_abort(FPU_info, SIGFPE);\n#endif  \n\n}\n\n \n \nint real_1op_NaN(FPU_REG *a)\n{\n\tint signalling, isNaN;\n\n\tisNaN = (exponent(a) == EXP_OVER) && (a->sigh & 0x80000000);\n\n\t \n\tsignalling = isNaN && !(a->sigh & 0x40000000);\n\n\tif (!signalling) {\n\t\tif (!isNaN) {\t \n\t\t\tif (control_word & CW_Invalid) {\n\t\t\t\t \n\t\t\t\treg_copy(&CONST_QNaN, a);\n\t\t\t}\n\t\t\tEXCEPTION(EX_Invalid);\n\t\t\treturn (!(control_word & CW_Invalid) ? FPU_Exception :\n\t\t\t\t0) | TAG_Special;\n\t\t}\n\t\treturn TAG_Special;\n\t}\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\tif (!(a->sigh & 0x80000000)) {\t \n\t\t\treg_copy(&CONST_QNaN, a);\n\t\t}\n\t\t \n\t\ta->sigh |= 0x40000000;\n\t}\n\n\tEXCEPTION(EX_Invalid);\n\n\treturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Special;\n}\n\n \n \nint real_2op_NaN(FPU_REG const *b, u_char tagb,\n\t\t int deststnr, FPU_REG const *defaultNaN)\n{\n\tFPU_REG *dest = &st(deststnr);\n\tFPU_REG const *a = dest;\n\tu_char taga = FPU_gettagi(deststnr);\n\tFPU_REG const *x;\n\tint signalling, unsupported;\n\n\tif (taga == TAG_Special)\n\t\ttaga = FPU_Special(a);\n\tif (tagb == TAG_Special)\n\t\ttagb = FPU_Special(b);\n\n\t \n\tunsupported = ((taga == TW_NaN)\n\t\t       && !((exponent(a) == EXP_OVER)\n\t\t\t    && (a->sigh & 0x80000000)))\n\t    || ((tagb == TW_NaN)\n\t\t&& !((exponent(b) == EXP_OVER) && (b->sigh & 0x80000000)));\n\tif (unsupported) {\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\tFPU_copy_to_regi(&CONST_QNaN, TAG_Special, deststnr);\n\t\t}\n\t\tEXCEPTION(EX_Invalid);\n\t\treturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) |\n\t\t    TAG_Special;\n\t}\n\n\tif (taga == TW_NaN) {\n\t\tx = a;\n\t\tif (tagb == TW_NaN) {\n\t\t\tsignalling = !(a->sigh & b->sigh & 0x40000000);\n\t\t\tif (significand(b) > significand(a))\n\t\t\t\tx = b;\n\t\t\telse if (significand(b) == significand(a)) {\n\t\t\t\t \n\t\t\t\tx = defaultNaN;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tsignalling = !(a->sigh & 0x40000000);\n\t\t}\n\t} else\n#ifdef PARANOID\n\tif (tagb == TW_NaN)\n#endif  \n\t{\n\t\tsignalling = !(b->sigh & 0x40000000);\n\t\tx = b;\n\t}\n#ifdef PARANOID\n\telse {\n\t\tsignalling = 0;\n\t\tEXCEPTION(EX_INTERNAL | 0x113);\n\t\tx = &CONST_QNaN;\n\t}\n#endif  \n\n\tif ((!signalling) || (control_word & CW_Invalid)) {\n\t\tif (!x)\n\t\t\tx = b;\n\n\t\tif (!(x->sigh & 0x80000000))\t \n\t\t\tx = &CONST_QNaN;\n\n\t\tFPU_copy_to_regi(x, TAG_Special, deststnr);\n\n\t\tif (!signalling)\n\t\t\treturn TAG_Special;\n\n\t\t \n\t\tdest->sigh |= 0x40000000;\n\t}\n\n\tEXCEPTION(EX_Invalid);\n\n\treturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Special;\n}\n\n \n \nasmlinkage __visible int arith_invalid(int deststnr)\n{\n\n\tEXCEPTION(EX_Invalid);\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\tFPU_copy_to_regi(&CONST_QNaN, TAG_Special, deststnr);\n\t}\n\n\treturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Valid;\n\n}\n\n \nasmlinkage __visible int FPU_divide_by_zero(int deststnr, u_char sign)\n{\n\tFPU_REG *dest = &st(deststnr);\n\tint tag = TAG_Valid;\n\n\tif (control_word & CW_ZeroDiv) {\n\t\t \n\t\tFPU_copy_to_regi(&CONST_INF, TAG_Special, deststnr);\n\t\tsetsign(dest, sign);\n\t\ttag = TAG_Special;\n\t}\n\n\tEXCEPTION(EX_ZeroDiv);\n\n\treturn (!(control_word & CW_ZeroDiv) ? FPU_Exception : 0) | tag;\n\n}\n\n \nint set_precision_flag(int flags)\n{\n\tif (control_word & CW_Precision) {\n\t\tpartial_status &= ~(SW_C1 & flags);\n\t\tpartial_status |= flags;\t \n\t\treturn 0;\n\t} else {\n\t\tEXCEPTION(flags);\n\t\treturn 1;\n\t}\n}\n\n \nasmlinkage __visible void set_precision_flag_up(void)\n{\n\tif (control_word & CW_Precision)\n\t\tpartial_status |= (SW_Precision | SW_C1);\t \n\telse\n\t\tEXCEPTION(EX_Precision | SW_C1);\n}\n\n \nasmlinkage __visible void set_precision_flag_down(void)\n{\n\tif (control_word & CW_Precision) {\t \n\t\tpartial_status &= ~SW_C1;\n\t\tpartial_status |= SW_Precision;\n\t} else\n\t\tEXCEPTION(EX_Precision);\n}\n\nasmlinkage __visible int denormal_operand(void)\n{\n\tif (control_word & CW_Denormal) {\t \n\t\tpartial_status |= SW_Denorm_Op;\n\t\treturn TAG_Special;\n\t} else {\n\t\tEXCEPTION(EX_Denormal);\n\t\treturn TAG_Special | FPU_Exception;\n\t}\n}\n\nasmlinkage __visible int arith_overflow(FPU_REG *dest)\n{\n\tint tag = TAG_Valid;\n\n\tif (control_word & CW_Overflow) {\n\t\t \n \n\t\treg_copy(&CONST_INF, dest);\n\t\ttag = TAG_Special;\n\t} else {\n\t\t \n\t\taddexponent(dest, (-3 * (1 << 13)));\n\t}\n\n\tEXCEPTION(EX_Overflow);\n\tif (control_word & CW_Overflow) {\n\t\t \n\t\t \n\t\tEXCEPTION(EX_Precision | SW_C1);\n\t\treturn tag;\n\t}\n\n\treturn tag;\n\n}\n\nasmlinkage __visible int arith_underflow(FPU_REG *dest)\n{\n\tint tag = TAG_Valid;\n\n\tif (control_word & CW_Underflow) {\n\t\t \n\t\tif (exponent16(dest) <= EXP_UNDER - 63) {\n\t\t\treg_copy(&CONST_Z, dest);\n\t\t\tpartial_status &= ~SW_C1;\t \n\t\t\ttag = TAG_Zero;\n\t\t} else {\n\t\t\tstdexp(dest);\n\t\t}\n\t} else {\n\t\t \n\t\taddexponent(dest, (3 * (1 << 13)) + EXTENDED_Ebias);\n\t}\n\n\tEXCEPTION(EX_Underflow);\n\tif (control_word & CW_Underflow) {\n\t\t \n\t\tEXCEPTION(EX_Precision);\n\t\treturn tag;\n\t}\n\n\treturn tag;\n\n}\n\nvoid FPU_stack_overflow(void)\n{\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\ttop--;\n\t\tFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\n\t}\n\n\tEXCEPTION(EX_StackOver);\n\n\treturn;\n\n}\n\nvoid FPU_stack_underflow(void)\n{\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\tFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\n\t}\n\n\tEXCEPTION(EX_StackUnder);\n\n\treturn;\n\n}\n\nvoid FPU_stack_underflow_i(int i)\n{\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\tFPU_copy_to_regi(&CONST_QNaN, TAG_Special, i);\n\t}\n\n\tEXCEPTION(EX_StackUnder);\n\n\treturn;\n\n}\n\nvoid FPU_stack_underflow_pop(int i)\n{\n\n\tif (control_word & CW_Invalid) {\n\t\t \n\t\tFPU_copy_to_regi(&CONST_QNaN, TAG_Special, i);\n\t\tFPU_pop();\n\t}\n\n\tEXCEPTION(EX_StackUnder);\n\n\treturn;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}