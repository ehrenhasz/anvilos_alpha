{
  "module_name": "fpu_aux.c",
  "hash_id": "ea9ab5b1863b8c62e0da131ea6e364f3291d12e29dd7e525c539ed24a8dfa68f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/fpu_aux.c",
  "human_readable_source": "\n \n\n#include \"fpu_system.h\"\n#include \"exception.h\"\n#include \"fpu_emu.h\"\n#include \"status_w.h\"\n#include \"control_w.h\"\n\nstatic void fnop(void)\n{\n}\n\nstatic void fclex(void)\n{\n\tpartial_status &=\n\t    ~(SW_Backward | SW_Summary | SW_Stack_Fault | SW_Precision |\n\t      SW_Underflow | SW_Overflow | SW_Zero_Div | SW_Denorm_Op |\n\t      SW_Invalid);\n\tno_ip_update = 1;\n}\n\n \nvoid fpstate_init_soft(struct swregs_state *soft)\n{\n\tstruct address *oaddr, *iaddr;\n\tmemset(soft, 0, sizeof(*soft));\n\tsoft->cwd = 0x037f;\n\tsoft->swd = 0;\n\tsoft->ftop = 0;\t \n\tsoft->twd = 0xffff;\n\t \n\toaddr = (struct address *)&soft->foo;\n\toaddr->offset = 0;\n\toaddr->selector = 0;\n\tiaddr = (struct address *)&soft->fip;\n\tiaddr->offset = 0;\n\tiaddr->selector = 0;\n\tiaddr->opcode = 0;\n\tsoft->no_update = 1;\n}\n\nvoid finit(void)\n{\n\tfpstate_init_soft(&current->thread.fpu.fpstate->regs.soft);\n}\n\n \n#define feni fnop\n#define fdisi fnop\n#define fsetpm fnop\n\nstatic FUNC const finit_table[] = {\n\tfeni, fdisi, fclex, finit,\n\tfsetpm, FPU_illegal, FPU_illegal, FPU_illegal\n};\n\nvoid finit_(void)\n{\n\t(finit_table[FPU_rm]) ();\n}\n\nstatic void fstsw_ax(void)\n{\n\t*(short *)&FPU_EAX = status_word();\n\tno_ip_update = 1;\n}\n\nstatic FUNC const fstsw_table[] = {\n\tfstsw_ax, FPU_illegal, FPU_illegal, FPU_illegal,\n\tFPU_illegal, FPU_illegal, FPU_illegal, FPU_illegal\n};\n\nvoid fstsw_(void)\n{\n\t(fstsw_table[FPU_rm]) ();\n}\n\nstatic FUNC const fp_nop_table[] = {\n\tfnop, FPU_illegal, FPU_illegal, FPU_illegal,\n\tFPU_illegal, FPU_illegal, FPU_illegal, FPU_illegal\n};\n\nvoid fp_nop(void)\n{\n\t(fp_nop_table[FPU_rm]) ();\n}\n\nvoid fld_i_(void)\n{\n\tFPU_REG *st_new_ptr;\n\tint i;\n\tu_char tag;\n\n\tif (STACK_OVERFLOW) {\n\t\tFPU_stack_overflow();\n\t\treturn;\n\t}\n\n\t \n\ti = FPU_rm;\n\tif (NOT_EMPTY(i)) {\n\t\treg_copy(&st(i), st_new_ptr);\n\t\ttag = FPU_gettagi(i);\n\t\tpush();\n\t\tFPU_settag0(tag);\n\t} else {\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\tFPU_stack_underflow();\n\t\t} else\n\t\t\tEXCEPTION(EX_StackUnder);\n\t}\n\n}\n\nvoid fxch_i(void)\n{\n\t \n\tFPU_REG t;\n\tint i = FPU_rm;\n\tFPU_REG *st0_ptr = &st(0), *sti_ptr = &st(i);\n\tlong tag_word = fpu_tag_word;\n\tint regnr = top & 7, regnri = ((regnr + i) & 7);\n\tu_char st0_tag = (tag_word >> (regnr * 2)) & 3;\n\tu_char sti_tag = (tag_word >> (regnri * 2)) & 3;\n\n\tif (st0_tag == TAG_Empty) {\n\t\tif (sti_tag == TAG_Empty) {\n\t\t\tFPU_stack_underflow();\n\t\t\tFPU_stack_underflow_i(i);\n\t\t\treturn;\n\t\t}\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\tFPU_copy_to_reg0(sti_ptr, sti_tag);\n\t\t}\n\t\tFPU_stack_underflow_i(i);\n\t\treturn;\n\t}\n\tif (sti_tag == TAG_Empty) {\n\t\tif (control_word & CW_Invalid) {\n\t\t\t \n\t\t\tFPU_copy_to_regi(st0_ptr, st0_tag, i);\n\t\t}\n\t\tFPU_stack_underflow();\n\t\treturn;\n\t}\n\tclear_C1();\n\n\treg_copy(st0_ptr, &t);\n\treg_copy(sti_ptr, st0_ptr);\n\treg_copy(&t, sti_ptr);\n\n\ttag_word &= ~(3 << (regnr * 2)) & ~(3 << (regnri * 2));\n\ttag_word |= (sti_tag << (regnr * 2)) | (st0_tag << (regnri * 2));\n\tfpu_tag_word = tag_word;\n}\n\nstatic void fcmovCC(void)\n{\n\t \n\tint i = FPU_rm;\n\tFPU_REG *st0_ptr = &st(0);\n\tFPU_REG *sti_ptr = &st(i);\n\tlong tag_word = fpu_tag_word;\n\tint regnr = top & 7;\n\tint regnri = (top + i) & 7;\n\tu_char sti_tag = (tag_word >> (regnri * 2)) & 3;\n\n\tif (sti_tag == TAG_Empty) {\n\t\tFPU_stack_underflow();\n\t\tclear_C1();\n\t\treturn;\n\t}\n\treg_copy(sti_ptr, st0_ptr);\n\ttag_word &= ~(3 << (regnr * 2));\n\ttag_word |= (sti_tag << (regnr * 2));\n\tfpu_tag_word = tag_word;\n}\n\nvoid fcmovb(void)\n{\n\tif (FPU_EFLAGS & X86_EFLAGS_CF)\n\t\tfcmovCC();\n}\n\nvoid fcmove(void)\n{\n\tif (FPU_EFLAGS & X86_EFLAGS_ZF)\n\t\tfcmovCC();\n}\n\nvoid fcmovbe(void)\n{\n\tif (FPU_EFLAGS & (X86_EFLAGS_CF|X86_EFLAGS_ZF))\n\t\tfcmovCC();\n}\n\nvoid fcmovu(void)\n{\n\tif (FPU_EFLAGS & X86_EFLAGS_PF)\n\t\tfcmovCC();\n}\n\nvoid fcmovnb(void)\n{\n\tif (!(FPU_EFLAGS & X86_EFLAGS_CF))\n\t\tfcmovCC();\n}\n\nvoid fcmovne(void)\n{\n\tif (!(FPU_EFLAGS & X86_EFLAGS_ZF))\n\t\tfcmovCC();\n}\n\nvoid fcmovnbe(void)\n{\n\tif (!(FPU_EFLAGS & (X86_EFLAGS_CF|X86_EFLAGS_ZF)))\n\t\tfcmovCC();\n}\n\nvoid fcmovnu(void)\n{\n\tif (!(FPU_EFLAGS & X86_EFLAGS_PF))\n\t\tfcmovCC();\n}\n\nvoid ffree_(void)\n{\n\t \n\tFPU_settagi(FPU_rm, TAG_Empty);\n}\n\nvoid ffreep(void)\n{\n\t \n\tFPU_settagi(FPU_rm, TAG_Empty);\n\tFPU_pop();\n}\n\nvoid fst_i_(void)\n{\n\t \n\tFPU_copy_to_regi(&st(0), FPU_gettag0(), FPU_rm);\n}\n\nvoid fstp_i(void)\n{\n\t \n\tFPU_copy_to_regi(&st(0), FPU_gettag0(), FPU_rm);\n\tFPU_pop();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}