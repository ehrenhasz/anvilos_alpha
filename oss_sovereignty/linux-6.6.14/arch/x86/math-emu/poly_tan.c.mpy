{
  "module_name": "poly_tan.c",
  "hash_id": "058d560127f47d999022404f383cc161f30f985a4252ba0fe570b10ed2863077",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/math-emu/poly_tan.c",
  "human_readable_source": "\n \n\n#include \"exception.h\"\n#include \"reg_constant.h\"\n#include \"fpu_emu.h\"\n#include \"fpu_system.h\"\n#include \"control_w.h\"\n#include \"poly.h\"\n\n#define\tHiPOWERop\t3\t \nstatic const unsigned long long oddplterm[HiPOWERop] = {\n\t0x0000000000000000LL,\n\t0x0051a1cf08fca228LL,\n\t0x0000000071284ff7LL\n};\n\n#define\tHiPOWERon\t2\t \nstatic const unsigned long long oddnegterm[HiPOWERon] = {\n\t0x1291a9a184244e80LL,\n\t0x0000583245819c21LL\n};\n\n#define\tHiPOWERep\t2\t \nstatic const unsigned long long evenplterm[HiPOWERep] = {\n\t0x0e848884b539e888LL,\n\t0x00003c7f18b887daLL\n};\n\n#define\tHiPOWERen\t2\t \nstatic const unsigned long long evennegterm[HiPOWERen] = {\n\t0xf1f0200fd51569ccLL,\n\t0x003afb46105c4432LL\n};\n\nstatic const unsigned long long twothirds = 0xaaaaaaaaaaaaaaabLL;\n\n \nvoid poly_tan(FPU_REG *st0_ptr)\n{\n\tlong int exponent;\n\tint invert;\n\tXsig argSq, argSqSq, accumulatoro, accumulatore, accum,\n\t    argSignif, fix_up;\n\tunsigned long adj;\n\n\texponent = exponent(st0_ptr);\n\n#ifdef PARANOID\n\tif (signnegative(st0_ptr)) {\t \n\t\tarith_invalid(0);\n\t\treturn;\n\t}\t\t\t \n#endif  \n\n\t \n\tif ((exponent == 0)\n\t    || ((exponent == -1) && (st0_ptr->sigh > 0xc90fdaa2))) {\n\t\t \n\t\tinvert = 1;\n\t\taccum.lsw = 0;\n\t\tXSIG_LL(accum) = significand(st0_ptr);\n\n\t\tif (exponent == 0) {\n\t\t\t \n\t\t\t \n\t\t\tXSIG_LL(accum) <<= 1;\n\t\t}\n\t\t \n\t\tXSIG_LL(accum) = 0x921fb54442d18469LL - XSIG_LL(accum);\n\t\t \n\t\tif (XSIG_LL(accum) == 0xffffffffffffffffLL) {\n\t\t\tFPU_settag0(TAG_Valid);\n\t\t\tsignificand(st0_ptr) = 0x8a51e04daabda360LL;\n\t\t\tsetexponent16(st0_ptr,\n\t\t\t\t      (0x41 + EXTENDED_Ebias) | SIGN_Negative);\n\t\t\treturn;\n\t\t}\n\n\t\targSignif.lsw = accum.lsw;\n\t\tXSIG_LL(argSignif) = XSIG_LL(accum);\n\t\texponent = -1 + norm_Xsig(&argSignif);\n\t} else {\n\t\tinvert = 0;\n\t\targSignif.lsw = 0;\n\t\tXSIG_LL(accum) = XSIG_LL(argSignif) = significand(st0_ptr);\n\n\t\tif (exponent < -1) {\n\t\t\t \n\t\t\tif (FPU_shrx(&XSIG_LL(accum), -1 - exponent) >=\n\t\t\t    0x80000000U)\n\t\t\t\tXSIG_LL(accum)++;\t \n\t\t}\n\t}\n\n\tXSIG_LL(argSq) = XSIG_LL(accum);\n\targSq.lsw = accum.lsw;\n\tmul_Xsig_Xsig(&argSq, &argSq);\n\tXSIG_LL(argSqSq) = XSIG_LL(argSq);\n\targSqSq.lsw = argSq.lsw;\n\tmul_Xsig_Xsig(&argSqSq, &argSqSq);\n\n\t \n\taccumulatoro.msw = accumulatoro.midw = accumulatoro.lsw = 0;\n\tpolynomial_Xsig(&accumulatoro, &XSIG_LL(argSqSq), oddnegterm,\n\t\t\tHiPOWERon - 1);\n\tmul_Xsig_Xsig(&accumulatoro, &argSq);\n\tnegate_Xsig(&accumulatoro);\n\t \n\tpolynomial_Xsig(&accumulatoro, &XSIG_LL(argSqSq), oddplterm,\n\t\t\tHiPOWERop - 1);\n\n\t \n\taccumulatore.msw = accumulatore.midw = accumulatore.lsw = 0;\n\tpolynomial_Xsig(&accumulatore, &XSIG_LL(argSqSq), evenplterm,\n\t\t\tHiPOWERep - 1);\n\tmul_Xsig_Xsig(&accumulatore, &argSq);\n\tnegate_Xsig(&accumulatore);\n\t \n\tpolynomial_Xsig(&accumulatore, &XSIG_LL(argSqSq), evennegterm,\n\t\t\tHiPOWERen - 1);\n\t \n\tmul64_Xsig(&accumulatore, &XSIG_LL(argSignif));\n\tmul64_Xsig(&accumulatore, &XSIG_LL(argSignif));\n\t \n\tshr_Xsig(&accumulatore, -2 * (1 + exponent) + 1);\n\tnegate_Xsig(&accumulatore);\t \n\n\t \n\tif (accumulatore.msw == 0) {\n\t\t \n\t\tXSIG_LL(accum) = 0x8000000000000000LL;\n\t\taccum.lsw = 0;\n\t} else {\n\t\tdiv_Xsig(&accumulatoro, &accumulatore, &accum);\n\t}\n\n\t \n\tmul64_Xsig(&accum, &XSIG_LL(argSignif));\n\tmul64_Xsig(&accum, &XSIG_LL(argSignif));\n\tmul64_Xsig(&accum, &XSIG_LL(argSignif));\n\tmul64_Xsig(&accum, &twothirds);\n\tshr_Xsig(&accum, -2 * (exponent + 1));\n\n\t \n\tadd_two_Xsig(&accum, &argSignif, &exponent);\n\n\tif (invert) {\n\t\t \n\t\t \n\n\t\t \n\t\tXSIG_LL(fix_up) = 0x898cc51701b839a2LL;\n\t\tfix_up.lsw = 0;\n\n\t\tif (exponent == 0)\n\t\t\tadj = 0xffffffff;\t \n\t\telse if (exponent > -30) {\n\t\t\tadj = accum.msw >> -(exponent + 1);\t \n\t\t\tadj = mul_32_32(adj, adj);\t \n\t\t} else\n\t\t\tadj = 0;\n\t\tadj = mul_32_32(0x898cc517, adj);\t \n\n\t\tfix_up.msw += adj;\n\t\tif (!(fix_up.msw & 0x80000000)) {\t \n\t\t\t \n\t\t\tshr_Xsig(&fix_up, 1);\n\t\t\tfix_up.msw |= 0x80000000;\n\t\t\tshr_Xsig(&fix_up, 64 + exponent);\n\t\t} else\n\t\t\tshr_Xsig(&fix_up, 65 + exponent);\n\n\t\tadd_two_Xsig(&accum, &fix_up, &exponent);\n\n\t\t \n\t\taccumulatoro.lsw = accumulatoro.midw = 0;\n\t\taccumulatoro.msw = 0x80000000;\n\t\tdiv_Xsig(&accumulatoro, &accum, &accum);\n\t\texponent = -exponent - 1;\n\t}\n\n\t \n\tround_Xsig(&accum);\n\tFPU_settag0(TAG_Valid);\n\tsignificand(st0_ptr) = XSIG_LL(accum);\n\tsetexponent16(st0_ptr, exponent + EXTENDED_Ebias);\t \n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}