{
  "module_name": "vsmp_64.c",
  "hash_id": "dcc5ac6f4492e5c8a3fcd37095adaa5c2ca616f65fe917e6fee098e764990a4d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/vsmp_64.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci_ids.h>\n#include <linux/pci_regs.h>\n#include <linux/smp.h>\n#include <linux/irq.h>\n\n#include <asm/apic.h>\n#include <asm/pci-direct.h>\n#include <asm/io.h>\n#include <asm/paravirt.h>\n#include <asm/setup.h>\n\n#define TOPOLOGY_REGISTER_OFFSET 0x10\n\n#ifdef CONFIG_PCI\nstatic void __init set_vsmp_ctl(void)\n{\n\tvoid __iomem *address;\n\tunsigned int cap, ctl, cfg;\n\n\t \n\tcfg = read_pci_config(0, 0x1f, 0, PCI_BASE_ADDRESS_0);\n\taddress = early_ioremap(cfg, 8);\n\tcap = readl(address);\n\tctl = readl(address + 4);\n\tprintk(KERN_INFO \"vSMP CTL: capabilities:0x%08x  control:0x%08x\\n\",\n\t       cap, ctl);\n\n\t \n#ifdef CONFIG_SMP\n\tif (cap & ctl & BIT(8)) {\n\t\tctl &= ~BIT(8);\n\n#ifdef CONFIG_PROC_FS\n\t\t \n\t\tno_irq_affinity = 1;\n#endif\n\t}\n#endif\n\n\twritel(ctl, address + 4);\n\tctl = readl(address + 4);\n\tpr_info(\"vSMP CTL: control set to:0x%08x\\n\", ctl);\n\n\tearly_iounmap(address, 8);\n}\nstatic int is_vsmp = -1;\n\nstatic void __init detect_vsmp_box(void)\n{\n\tis_vsmp = 0;\n\n\tif (!early_pci_allowed())\n\t\treturn;\n\n\t \n\tif (read_pci_config(0, 0x1f, 0, PCI_VENDOR_ID) ==\n\t     (PCI_VENDOR_ID_SCALEMP | (PCI_DEVICE_ID_SCALEMP_VSMP_CTL << 16)))\n\t\tis_vsmp = 1;\n}\n\nstatic int is_vsmp_box(void)\n{\n\tif (is_vsmp != -1)\n\t\treturn is_vsmp;\n\telse {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\n#else\nstatic void __init detect_vsmp_box(void)\n{\n}\nstatic int is_vsmp_box(void)\n{\n\treturn 0;\n}\nstatic void __init set_vsmp_ctl(void)\n{\n}\n#endif\n\nstatic void __init vsmp_cap_cpus(void)\n{\n#if !defined(CONFIG_X86_VSMP) && defined(CONFIG_SMP) && defined(CONFIG_PCI)\n\tvoid __iomem *address;\n\tunsigned int cfg, topology, node_shift, maxcpus;\n\n\t \n\tif (setup_max_cpus != NR_CPUS)\n\t\treturn;\n\n\t \n\tcfg = read_pci_config(0, 0x1f, 0, PCI_BASE_ADDRESS_0);\n\taddress = early_ioremap(cfg + TOPOLOGY_REGISTER_OFFSET, 4);\n\tif (WARN_ON(!address))\n\t\treturn;\n\n\ttopology = readl(address);\n\tnode_shift = (topology >> 16) & 0x7;\n\tif (!node_shift)\n\t\t \n\t\tnode_shift = 8;\n\tmaxcpus = (topology & ((1 << node_shift) - 1)) + 1;\n\n\tpr_info(\"vSMP CTL: Capping CPUs to %d (CONFIG_X86_VSMP is unset)\\n\",\n\t\tmaxcpus);\n\tsetup_max_cpus = maxcpus;\n\tearly_iounmap(address, 4);\n#endif\n}\n\nstatic int apicid_phys_pkg_id(int initial_apic_id, int index_msb)\n{\n\treturn read_apic_id() >> index_msb;\n}\n\nstatic void vsmp_apic_post_init(void)\n{\n\t \n\tapic->phys_pkg_id = apicid_phys_pkg_id;\n}\n\nvoid __init vsmp_init(void)\n{\n\tdetect_vsmp_box();\n\tif (!is_vsmp_box())\n\t\treturn;\n\n\tx86_platform.apic_post_init = vsmp_apic_post_init;\n\n\tvsmp_cap_cpus();\n\n\tset_vsmp_ctl();\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}