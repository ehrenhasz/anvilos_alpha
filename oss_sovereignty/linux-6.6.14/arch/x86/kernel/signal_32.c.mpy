{
  "module_name": "signal_32.c",
  "hash_id": "7e6414ca73b47361ca1fa237b5591817abe2a2316e8868630212e61feecdb69b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/signal_32.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/wait.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/personality.h>\n#include <linux/compat.h>\n#include <linux/binfmts.h>\n#include <linux/syscalls.h>\n#include <asm/ucontext.h>\n#include <linux/uaccess.h>\n#include <asm/fpu/signal.h>\n#include <asm/ptrace.h>\n#include <asm/user32.h>\n#include <uapi/asm/sigcontext.h>\n#include <asm/proto.h>\n#include <asm/vdso.h>\n#include <asm/sigframe.h>\n#include <asm/sighandling.h>\n#include <asm/smap.h>\n#include <asm/gsseg.h>\n\n#ifdef CONFIG_IA32_EMULATION\n#include <asm/ia32_unistd.h>\n\nstatic inline void reload_segments(struct sigcontext_32 *sc)\n{\n\tunsigned int cur;\n\n\tsavesegment(gs, cur);\n\tif ((sc->gs | 0x03) != cur)\n\t\tload_gs_index(sc->gs | 0x03);\n\tsavesegment(fs, cur);\n\tif ((sc->fs | 0x03) != cur)\n\t\tloadsegment(fs, sc->fs | 0x03);\n\tsavesegment(ds, cur);\n\tif ((sc->ds | 0x03) != cur)\n\t\tloadsegment(ds, sc->ds | 0x03);\n\tsavesegment(es, cur);\n\tif ((sc->es | 0x03) != cur)\n\t\tloadsegment(es, sc->es | 0x03);\n}\n\n#define sigset32_t\t\t\tcompat_sigset_t\n#define siginfo32_t\t\t\tcompat_siginfo_t\n#define restore_altstack32\t\tcompat_restore_altstack\n#define unsafe_save_altstack32\t\tunsafe_compat_save_altstack\n\n#else\n\n#define sigset32_t\t\t\tsigset_t\n#define siginfo32_t\t\t\tsiginfo_t\n#define __NR_ia32_sigreturn\t\t__NR_sigreturn\n#define __NR_ia32_rt_sigreturn\t\t__NR_rt_sigreturn\n#define restore_altstack32\t\trestore_altstack\n#define unsafe_save_altstack32\t\tunsafe_save_altstack\n#define __copy_siginfo_to_user32\tcopy_siginfo_to_user\n\n#endif\n\n \nstatic bool ia32_restore_sigcontext(struct pt_regs *regs,\n\t\t\t\t    struct sigcontext_32 __user *usc)\n{\n\tstruct sigcontext_32 sc;\n\n\t \n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (unlikely(copy_from_user(&sc, usc, sizeof(sc))))\n\t\treturn false;\n\n\t \n\tregs->bx = sc.bx;\n\tregs->cx = sc.cx;\n\tregs->dx = sc.dx;\n\tregs->si = sc.si;\n\tregs->di = sc.di;\n\tregs->bp = sc.bp;\n\tregs->ax = sc.ax;\n\tregs->sp = sc.sp;\n\tregs->ip = sc.ip;\n\n\t \n\tregs->cs = sc.cs | 0x03;\n\tregs->ss = sc.ss | 0x03;\n\n\tregs->flags = (regs->flags & ~FIX_EFLAGS) | (sc.flags & FIX_EFLAGS);\n\t \n\tregs->orig_ax = -1;\n\n#ifdef CONFIG_IA32_EMULATION\n\t \n\treload_segments(&sc);\n#else\n\tloadsegment(gs, sc.gs);\n\tregs->fs = sc.fs;\n\tregs->es = sc.es;\n\tregs->ds = sc.ds;\n#endif\n\n\treturn fpu__restore_sig(compat_ptr(sc.fpstate), 1);\n}\n\nSYSCALL32_DEFINE0(sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sigframe_ia32 __user *frame = (struct sigframe_ia32 __user *)(regs->sp-8);\n\tsigset_t set;\n\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\tgoto badframe;\n\tif (__get_user(set.sig[0], &frame->sc.oldmask)\n\t    || __get_user(((__u32 *)&set)[1], &frame->extramask[0]))\n\t\tgoto badframe;\n\n\tset_current_blocked(&set);\n\n\tif (!ia32_restore_sigcontext(regs, &frame->sc))\n\t\tgoto badframe;\n\treturn regs->ax;\n\nbadframe:\n\tsignal_fault(regs, frame, \"32bit sigreturn\");\n\treturn 0;\n}\n\nSYSCALL32_DEFINE0(rt_sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct rt_sigframe_ia32 __user *frame;\n\tsigset_t set;\n\n\tframe = (struct rt_sigframe_ia32 __user *)(regs->sp - 4);\n\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\tgoto badframe;\n\tif (__get_user(*(__u64 *)&set, (__u64 __user *)&frame->uc.uc_sigmask))\n\t\tgoto badframe;\n\n\tset_current_blocked(&set);\n\n\tif (!ia32_restore_sigcontext(regs, &frame->uc.uc_mcontext))\n\t\tgoto badframe;\n\n\tif (restore_altstack32(&frame->uc.uc_stack))\n\t\tgoto badframe;\n\n\treturn regs->ax;\n\nbadframe:\n\tsignal_fault(regs, frame, \"32bit rt sigreturn\");\n\treturn 0;\n}\n\n \n\n#define get_user_seg(seg)\t({ unsigned int v; savesegment(seg, v); v; })\n\nstatic __always_inline int\n__unsafe_setup_sigcontext32(struct sigcontext_32 __user *sc,\n\t\t\t    void __user *fpstate,\n\t\t\t    struct pt_regs *regs, unsigned int mask)\n{\n\tunsafe_put_user(get_user_seg(gs), (unsigned int __user *)&sc->gs, Efault);\n#ifdef CONFIG_IA32_EMULATION\n\tunsafe_put_user(get_user_seg(fs), (unsigned int __user *)&sc->fs, Efault);\n\tunsafe_put_user(get_user_seg(ds), (unsigned int __user *)&sc->ds, Efault);\n\tunsafe_put_user(get_user_seg(es), (unsigned int __user *)&sc->es, Efault);\n#else\n\tunsafe_put_user(regs->fs, (unsigned int __user *)&sc->fs, Efault);\n\tunsafe_put_user(regs->es, (unsigned int __user *)&sc->es, Efault);\n\tunsafe_put_user(regs->ds, (unsigned int __user *)&sc->ds, Efault);\n#endif\n\n\tunsafe_put_user(regs->di, &sc->di, Efault);\n\tunsafe_put_user(regs->si, &sc->si, Efault);\n\tunsafe_put_user(regs->bp, &sc->bp, Efault);\n\tunsafe_put_user(regs->sp, &sc->sp, Efault);\n\tunsafe_put_user(regs->bx, &sc->bx, Efault);\n\tunsafe_put_user(regs->dx, &sc->dx, Efault);\n\tunsafe_put_user(regs->cx, &sc->cx, Efault);\n\tunsafe_put_user(regs->ax, &sc->ax, Efault);\n\tunsafe_put_user(current->thread.trap_nr, &sc->trapno, Efault);\n\tunsafe_put_user(current->thread.error_code, &sc->err, Efault);\n\tunsafe_put_user(regs->ip, &sc->ip, Efault);\n\tunsafe_put_user(regs->cs, (unsigned int __user *)&sc->cs, Efault);\n\tunsafe_put_user(regs->flags, &sc->flags, Efault);\n\tunsafe_put_user(regs->sp, &sc->sp_at_signal, Efault);\n\tunsafe_put_user(regs->ss, (unsigned int __user *)&sc->ss, Efault);\n\n\tunsafe_put_user(ptr_to_compat(fpstate), &sc->fpstate, Efault);\n\n\t \n\tunsafe_put_user(mask, &sc->oldmask, Efault);\n\tunsafe_put_user(current->thread.cr2, &sc->cr2, Efault);\n\treturn 0;\n\nEfault:\n\treturn -EFAULT;\n}\n\n#define unsafe_put_sigcontext32(sc, fp, regs, set, label)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__unsafe_setup_sigcontext32(sc, fp, regs, set->sig[0]))\t\\\n\t\tgoto label;\t\t\t\t\t\t\\\n} while(0)\n\nint ia32_setup_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tsigset32_t *set = (sigset32_t *) sigmask_to_save();\n\tstruct sigframe_ia32 __user *frame;\n\tvoid __user *restorer;\n\tvoid __user *fp = NULL;\n\n\t \n\tstatic const struct {\n\t\tu16 poplmovl;\n\t\tu32 val;\n\t\tu16 int80;\n\t} __attribute__((packed)) code = {\n\t\t0xb858,\t\t  \n\t\t__NR_ia32_sigreturn,\n\t\t0x80cd,\t\t \n\t};\n\n\tframe = get_sigframe(ksig, regs, sizeof(*frame), &fp);\n\n\tif (ksig->ka.sa.sa_flags & SA_RESTORER) {\n\t\trestorer = ksig->ka.sa.sa_restorer;\n\t} else {\n\t\t \n\t\tif (current->mm->context.vdso)\n\t\t\trestorer = current->mm->context.vdso +\n\t\t\t\tvdso_image_32.sym___kernel_sigreturn;\n\t\telse\n\t\t\trestorer = &frame->retcode;\n\t}\n\n\tif (!user_access_begin(frame, sizeof(*frame)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(ksig->sig, &frame->sig, Efault);\n\tunsafe_put_sigcontext32(&frame->sc, fp, regs, set, Efault);\n\tunsafe_put_user(set->sig[1], &frame->extramask[0], Efault);\n\tunsafe_put_user(ptr_to_compat(restorer), &frame->pretcode, Efault);\n\t \n\tunsafe_put_user(*((u64 *)&code), (u64 __user *)frame->retcode, Efault);\n\tuser_access_end();\n\n\t \n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\n\n\t \n\tregs->ax = ksig->sig;\n\tregs->dx = 0;\n\tregs->cx = 0;\n\n#ifdef CONFIG_IA32_EMULATION\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#else\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n#endif\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER_DS;\n\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nint ia32_setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tsigset32_t *set = (sigset32_t *) sigmask_to_save();\n\tstruct rt_sigframe_ia32 __user *frame;\n\tvoid __user *restorer;\n\tvoid __user *fp = NULL;\n\n\t \n\tstatic const struct {\n\t\tu8 movl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu8  pad;\n\t} __attribute__((packed)) code = {\n\t\t0xb8,\n\t\t__NR_ia32_rt_sigreturn,\n\t\t0x80cd,\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ksig, regs, sizeof(*frame), &fp);\n\n\tif (!user_access_begin(frame, sizeof(*frame)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(ksig->sig, &frame->sig, Efault);\n\tunsafe_put_user(ptr_to_compat(&frame->info), &frame->pinfo, Efault);\n\tunsafe_put_user(ptr_to_compat(&frame->uc), &frame->puc, Efault);\n\n\t \n\tif (static_cpu_has(X86_FEATURE_XSAVE))\n\t\tunsafe_put_user(UC_FP_XSTATE, &frame->uc.uc_flags, Efault);\n\telse\n\t\tunsafe_put_user(0, &frame->uc.uc_flags, Efault);\n\tunsafe_put_user(0, &frame->uc.uc_link, Efault);\n\tunsafe_save_altstack32(&frame->uc.uc_stack, regs->sp, Efault);\n\n\tif (ksig->ka.sa.sa_flags & SA_RESTORER)\n\t\trestorer = ksig->ka.sa.sa_restorer;\n\telse\n\t\trestorer = current->mm->context.vdso +\n\t\t\tvdso_image_32.sym___kernel_rt_sigreturn;\n\tunsafe_put_user(ptr_to_compat(restorer), &frame->pretcode, Efault);\n\n\t \n\tunsafe_put_user(*((u64 *)&code), (u64 __user *)frame->retcode, Efault);\n\tunsafe_put_sigcontext32(&frame->uc.uc_mcontext, fp, regs, set, Efault);\n\tunsafe_put_user(*(__u64 *)set, (__u64 __user *)&frame->uc.uc_sigmask, Efault);\n\tuser_access_end();\n\n\tif (__copy_siginfo_to_user32(&frame->info, &ksig->info))\n\t\treturn -EFAULT;\n\n\t \n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\n\n\t \n\tregs->ax = ksig->sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n#ifdef CONFIG_IA32_EMULATION\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#else\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n#endif\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER_DS;\n\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\n \n\n \nstatic_assert(NSIGILL  == 11);\nstatic_assert(NSIGFPE  == 15);\nstatic_assert(NSIGSEGV == 10);\nstatic_assert(NSIGBUS  == 5);\nstatic_assert(NSIGTRAP == 6);\nstatic_assert(NSIGCHLD == 6);\nstatic_assert(NSIGSYS  == 2);\n\n \nstatic_assert(sizeof(siginfo32_t) == 128);\n\n \nstatic_assert(__alignof__(siginfo32_t) == 4);\n\n \nstatic_assert(offsetof(siginfo32_t, _sifields) == 3 * sizeof(int));\n\nstatic_assert(offsetof(siginfo32_t, si_signo) == 0);\nstatic_assert(offsetof(siginfo32_t, si_errno) == 4);\nstatic_assert(offsetof(siginfo32_t, si_code)  == 8);\n\n \n\n#define CHECK_SI_OFFSET(name)\t\t\t\t\t\t\\\n\tstatic_assert(offsetof(siginfo32_t, _sifields) ==\t\t\\\n\t\t      offsetof(siginfo32_t, _sifields.name))\n\n#define CHECK_SI_SIZE(name, size)\t\t\t\t\t\\\n\tstatic_assert(sizeof_field(siginfo32_t, _sifields.name) == size)\n\nCHECK_SI_OFFSET(_kill);\nCHECK_SI_SIZE  (_kill, 2*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_pid) == 0xC);\nstatic_assert(offsetof(siginfo32_t, si_uid) == 0x10);\n\nCHECK_SI_OFFSET(_timer);\n#ifdef CONFIG_COMPAT\n \nCHECK_SI_SIZE  (_timer, 3*sizeof(int));\n#else\nCHECK_SI_SIZE  (_timer, 4*sizeof(int));\n#endif\nstatic_assert(offsetof(siginfo32_t, si_tid)     == 0x0C);\nstatic_assert(offsetof(siginfo32_t, si_overrun) == 0x10);\nstatic_assert(offsetof(siginfo32_t, si_value)   == 0x14);\n\nCHECK_SI_OFFSET(_rt);\nCHECK_SI_SIZE  (_rt, 3*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_pid)   == 0x0C);\nstatic_assert(offsetof(siginfo32_t, si_uid)   == 0x10);\nstatic_assert(offsetof(siginfo32_t, si_value) == 0x14);\n\nCHECK_SI_OFFSET(_sigchld);\nCHECK_SI_SIZE  (_sigchld, 5*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_pid)    == 0x0C);\nstatic_assert(offsetof(siginfo32_t, si_uid)    == 0x10);\nstatic_assert(offsetof(siginfo32_t, si_status) == 0x14);\nstatic_assert(offsetof(siginfo32_t, si_utime)  == 0x18);\nstatic_assert(offsetof(siginfo32_t, si_stime)  == 0x1C);\n\nCHECK_SI_OFFSET(_sigfault);\nCHECK_SI_SIZE  (_sigfault, 4*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_addr) == 0x0C);\n\nstatic_assert(offsetof(siginfo32_t, si_trapno) == 0x10);\n\nstatic_assert(offsetof(siginfo32_t, si_addr_lsb) == 0x10);\n\nstatic_assert(offsetof(siginfo32_t, si_lower) == 0x14);\nstatic_assert(offsetof(siginfo32_t, si_upper) == 0x18);\n\nstatic_assert(offsetof(siginfo32_t, si_pkey) == 0x14);\n\nstatic_assert(offsetof(siginfo32_t, si_perf_data) == 0x10);\nstatic_assert(offsetof(siginfo32_t, si_perf_type) == 0x14);\nstatic_assert(offsetof(siginfo32_t, si_perf_flags) == 0x18);\n\nCHECK_SI_OFFSET(_sigpoll);\nCHECK_SI_SIZE  (_sigpoll, 2*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_band) == 0x0C);\nstatic_assert(offsetof(siginfo32_t, si_fd)   == 0x10);\n\nCHECK_SI_OFFSET(_sigsys);\nCHECK_SI_SIZE  (_sigsys, 3*sizeof(int));\nstatic_assert(offsetof(siginfo32_t, si_call_addr) == 0x0C);\nstatic_assert(offsetof(siginfo32_t, si_syscall)   == 0x10);\nstatic_assert(offsetof(siginfo32_t, si_arch)      == 0x14);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}