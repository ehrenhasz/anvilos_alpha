{
  "module_name": "sys_x86_64.c",
  "hash_id": "d9bacf3c4697999ad2700cba9179146b5f5e7403d0da75998179f82ee0928cae",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/sys_x86_64.c",
  "human_readable_source": "\n#include <linux/compat.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/syscalls.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/sem.h>\n#include <linux/msg.h>\n#include <linux/shm.h>\n#include <linux/stat.h>\n#include <linux/mman.h>\n#include <linux/file.h>\n#include <linux/utsname.h>\n#include <linux/personality.h>\n#include <linux/random.h>\n#include <linux/uaccess.h>\n#include <linux/elf.h>\n\n#include <asm/elf.h>\n#include <asm/ia32.h>\n\n \nstatic unsigned long get_align_mask(void)\n{\n\t \n\tif (va_align.flags < 0 || !(va_align.flags & (2 - mmap_is_ia32())))\n\t\treturn 0;\n\n\tif (!(current->flags & PF_RANDOMIZE))\n\t\treturn 0;\n\n\treturn va_align.mask;\n}\n\n \nstatic unsigned long get_align_bits(void)\n{\n\treturn va_align.bits & get_align_mask();\n}\n\nunsigned long align_vdso_addr(unsigned long addr)\n{\n\tunsigned long align_mask = get_align_mask();\n\taddr = (addr + align_mask) & ~align_mask;\n\treturn addr | get_align_bits();\n}\n\nstatic int __init control_va_addr_alignment(char *str)\n{\n\t \n\tif (va_align.flags < 0)\n\t\treturn 1;\n\n\tif (*str == 0)\n\t\treturn 1;\n\n\tif (!strcmp(str, \"32\"))\n\t\tva_align.flags = ALIGN_VA_32;\n\telse if (!strcmp(str, \"64\"))\n\t\tva_align.flags = ALIGN_VA_64;\n\telse if (!strcmp(str, \"off\"))\n\t\tva_align.flags = 0;\n\telse if (!strcmp(str, \"on\"))\n\t\tva_align.flags = ALIGN_VA_32 | ALIGN_VA_64;\n\telse\n\t\tpr_warn(\"invalid option value: 'align_va_addr=%s'\\n\", str);\n\n\treturn 1;\n}\n__setup(\"align_va_addr=\", control_va_addr_alignment);\n\nSYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags,\n\t\tunsigned long, fd, unsigned long, off)\n{\n\tif (off & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\treturn ksys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n}\n\nstatic void find_start_end(unsigned long addr, unsigned long flags,\n\t\tunsigned long *begin, unsigned long *end)\n{\n\tif (!in_32bit_syscall() && (flags & MAP_32BIT)) {\n\t\t \n\t\t*begin = 0x40000000;\n\t\t*end = 0x80000000;\n\t\tif (current->flags & PF_RANDOMIZE) {\n\t\t\t*begin = randomize_page(*begin, 0x02000000);\n\t\t}\n\t\treturn;\n\t}\n\n\t*begin\t= get_mmap_base(1);\n\tif (in_32bit_syscall())\n\t\t*end = task_size_32bit();\n\telse\n\t\t*end = task_size_64bit(addr > DEFAULT_MAP_WINDOW);\n}\n\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tstruct vm_unmapped_area_info info;\n\tunsigned long begin, end;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\tfind_start_end(addr, flags, &begin, &end);\n\n\tif (len > end)\n\t\treturn -ENOMEM;\n\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma(mm, addr);\n\t\tif (end - len >= addr &&\n\t\t    (!vma || addr + len <= vm_start_gap(vma)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = begin;\n\tinfo.high_limit = end;\n\tinfo.align_mask = 0;\n\tinfo.align_offset = pgoff << PAGE_SHIFT;\n\tif (filp) {\n\t\tinfo.align_mask = get_align_mask();\n\t\tinfo.align_offset += get_align_bits();\n\t}\n\treturn vm_unmapped_area(&info);\n}\n\nunsigned long\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\n\t\t\t  const unsigned long len, const unsigned long pgoff,\n\t\t\t  const unsigned long flags)\n{\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\n\t \n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t \n\tif (!in_32bit_syscall() && (flags & MAP_32BIT))\n\t\tgoto bottomup;\n\n\t \n\tif (addr) {\n\t\taddr &= PAGE_MASK;\n\t\tif (!mmap_address_hint_valid(addr, len))\n\t\t\tgoto get_unmapped_area;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr + len <= vm_start_gap(vma))\n\t\t\treturn addr;\n\t}\nget_unmapped_area:\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tif (!in_32bit_syscall() && (flags & MAP_ABOVE4G))\n\t\tinfo.low_limit = SZ_4G;\n\telse\n\t\tinfo.low_limit = PAGE_SIZE;\n\n\tinfo.high_limit = get_mmap_base(0);\n\n\t \n\tif (addr > DEFAULT_MAP_WINDOW && !in_32bit_syscall())\n\t\tinfo.high_limit += TASK_SIZE_MAX - DEFAULT_MAP_WINDOW;\n\n\tinfo.align_mask = 0;\n\tinfo.align_offset = pgoff << PAGE_SHIFT;\n\tif (filp) {\n\t\tinfo.align_mask = get_align_mask();\n\t\tinfo.align_offset += get_align_bits();\n\t}\n\taddr = vm_unmapped_area(&info);\n\tif (!(addr & ~PAGE_MASK))\n\t\treturn addr;\n\tVM_BUG_ON(addr != -ENOMEM);\n\nbottomup:\n\t \n\treturn arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}