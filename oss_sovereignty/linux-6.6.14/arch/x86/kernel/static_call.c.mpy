{
  "module_name": "static_call.c",
  "hash_id": "3eabffdf333d840f5f00abadcb7fb1d638db73edf1198ed0d7df7910958df3c5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/static_call.c",
  "human_readable_source": "\n#include <linux/static_call.h>\n#include <linux/memory.h>\n#include <linux/bug.h>\n#include <asm/text-patching.h>\n\nenum insn_type {\n\tCALL = 0,  \n\tNOP = 1,   \n\tJMP = 2,   \n\tRET = 3,   \n\tJCC = 4,\n};\n\n \nstatic const u8 tramp_ud[] = { 0x0f, 0xb9, 0xcc };\n\n \nstatic const u8 xor5rax[] = { 0x2e, 0x2e, 0x2e, 0x31, 0xc0 };\n\nstatic const u8 retinsn[] = { RET_INSN_OPCODE, 0xcc, 0xcc, 0xcc, 0xcc };\n\nstatic u8 __is_Jcc(u8 *insn)  \n{\n\tu8 ret = 0;\n\n\tif (insn[0] == 0x0f) {\n\t\tu8 tmp = insn[1];\n\t\tif ((tmp & 0xf0) == 0x80)\n\t\t\tret = tmp;\n\t}\n\n\treturn ret;\n}\n\nextern void __static_call_return(void);\n\nasm (\".global __static_call_return\\n\\t\"\n     \".type __static_call_return, @function\\n\\t\"\n     ASM_FUNC_ALIGN \"\\n\\t\"\n     \"__static_call_return:\\n\\t\"\n     ANNOTATE_NOENDBR\n     ANNOTATE_RETPOLINE_SAFE\n     \"ret; int3\\n\\t\"\n     \".size __static_call_return, . - __static_call_return \\n\\t\");\n\nstatic void __ref __static_call_transform(void *insn, enum insn_type type,\n\t\t\t\t\t  void *func, bool modinit)\n{\n\tconst void *emulate = NULL;\n\tint size = CALL_INSN_SIZE;\n\tconst void *code;\n\tu8 op, buf[6];\n\n\tif ((type == JMP || type == RET) && (op = __is_Jcc(insn)))\n\t\ttype = JCC;\n\n\tswitch (type) {\n\tcase CALL:\n\t\tfunc = callthunks_translate_call_dest(func);\n\t\tcode = text_gen_insn(CALL_INSN_OPCODE, insn, func);\n\t\tif (func == &__static_call_return0) {\n\t\t\temulate = code;\n\t\t\tcode = &xor5rax;\n\t\t}\n\n\t\tbreak;\n\n\tcase NOP:\n\t\tcode = x86_nops[5];\n\t\tbreak;\n\n\tcase JMP:\n\t\tcode = text_gen_insn(JMP32_INSN_OPCODE, insn, func);\n\t\tbreak;\n\n\tcase RET:\n\t\tif (cpu_feature_enabled(X86_FEATURE_RETHUNK))\n\t\t\tcode = text_gen_insn(JMP32_INSN_OPCODE, insn, x86_return_thunk);\n\t\telse\n\t\t\tcode = &retinsn;\n\t\tbreak;\n\n\tcase JCC:\n\t\tif (!func) {\n\t\t\tfunc = __static_call_return;\n\t\t\tif (cpu_feature_enabled(X86_FEATURE_RETHUNK))\n\t\t\t\tfunc = x86_return_thunk;\n\t\t}\n\n\t\tbuf[0] = 0x0f;\n\t\t__text_gen_insn(buf+1, op, insn+1, func, 5);\n\t\tcode = buf;\n\t\tsize = 6;\n\n\t\tbreak;\n\t}\n\n\tif (memcmp(insn, code, size) == 0)\n\t\treturn;\n\n\tif (system_state == SYSTEM_BOOTING || modinit)\n\t\treturn text_poke_early(insn, code, size);\n\n\ttext_poke_bp(insn, code, size, emulate);\n}\n\nstatic void __static_call_validate(u8 *insn, bool tail, bool tramp)\n{\n\tu8 opcode = insn[0];\n\n\tif (tramp && memcmp(insn+5, tramp_ud, 3)) {\n\t\tpr_err(\"trampoline signature fail\");\n\t\tBUG();\n\t}\n\n\tif (tail) {\n\t\tif (opcode == JMP32_INSN_OPCODE ||\n\t\t    opcode == RET_INSN_OPCODE ||\n\t\t    __is_Jcc(insn))\n\t\t\treturn;\n\t} else {\n\t\tif (opcode == CALL_INSN_OPCODE ||\n\t\t    !memcmp(insn, x86_nops[5], 5) ||\n\t\t    !memcmp(insn, xor5rax, 5))\n\t\t\treturn;\n\t}\n\n\t \n\tpr_err(\"unexpected static_call insn opcode 0x%x at %pS\\n\", opcode, insn);\n\tBUG();\n}\n\nstatic inline enum insn_type __sc_insn(bool null, bool tail)\n{\n\t \n\treturn 2*tail + null;\n}\n\nvoid arch_static_call_transform(void *site, void *tramp, void *func, bool tail)\n{\n\tmutex_lock(&text_mutex);\n\n\tif (tramp) {\n\t\t__static_call_validate(tramp, true, true);\n\t\t__static_call_transform(tramp, __sc_insn(!func, true), func, false);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HAVE_STATIC_CALL_INLINE) && site) {\n\t\t__static_call_validate(site, tail, false);\n\t\t__static_call_transform(site, __sc_insn(!func, tail), func, false);\n\t}\n\n\tmutex_unlock(&text_mutex);\n}\nEXPORT_SYMBOL_GPL(arch_static_call_transform);\n\n#ifdef CONFIG_RETHUNK\n \nbool __static_call_fixup(void *tramp, u8 op, void *dest)\n{\n\tunsigned long addr = (unsigned long)tramp;\n\t \n\tif (((addr >> PAGE_SHIFT) != ((addr + 7) >> PAGE_SHIFT)) &&\n\t    !kernel_text_address(addr + 7))\n\t\treturn false;\n\n\tif (memcmp(tramp+5, tramp_ud, 3)) {\n\t\t \n\t\treturn false;\n\t}\n\n\tmutex_lock(&text_mutex);\n\tif (op == RET_INSN_OPCODE || dest == &__x86_return_thunk)\n\t\t__static_call_transform(tramp, RET, NULL, true);\n\tmutex_unlock(&text_mutex);\n\n\treturn true;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}