{
  "module_name": "internal.h",
  "hash_id": "78c1c861f1236869315752805115c5f9ccd5ffb78061832c87257723a7f19ee1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/resctrl/internal.h",
  "human_readable_source": " \n#ifndef _ASM_X86_RESCTRL_INTERNAL_H\n#define _ASM_X86_RESCTRL_INTERNAL_H\n\n#include <linux/resctrl.h>\n#include <linux/sched.h>\n#include <linux/kernfs.h>\n#include <linux/fs_context.h>\n#include <linux/jump_label.h>\n\n#define L3_QOS_CDP_ENABLE\t\t0x01ULL\n\n#define L2_QOS_CDP_ENABLE\t\t0x01ULL\n\n#define CQM_LIMBOCHECK_INTERVAL\t1000\n\n#define MBM_CNTR_WIDTH_BASE\t\t24\n#define MBM_OVERFLOW_INTERVAL\t\t1000\n#define MAX_MBA_BW\t\t\t100u\n#define MBA_IS_LINEAR\t\t\t0x4\n#define MAX_MBA_BW_AMD\t\t\t0x800\n#define MBM_CNTR_WIDTH_OFFSET_AMD\t20\n\n#define RMID_VAL_ERROR\t\t\tBIT_ULL(63)\n#define RMID_VAL_UNAVAIL\t\tBIT_ULL(62)\n \n#define MBM_CNTR_WIDTH_OFFSET_MAX (62 - MBM_CNTR_WIDTH_BASE)\n\n \n#define READS_TO_LOCAL_MEM\t\tBIT(0)\n\n \n#define READS_TO_REMOTE_MEM\t\tBIT(1)\n\n \n#define NON_TEMP_WRITE_TO_LOCAL_MEM\tBIT(2)\n\n \n#define NON_TEMP_WRITE_TO_REMOTE_MEM\tBIT(3)\n\n \n#define READS_TO_LOCAL_S_MEM\t\tBIT(4)\n\n \n#define READS_TO_REMOTE_S_MEM\t\tBIT(5)\n\n \n#define DIRTY_VICTIMS_TO_ALL_MEM\tBIT(6)\n\n \n#define MAX_EVT_CONFIG_BITS\t\tGENMASK(6, 0)\n\nstruct rdt_fs_context {\n\tstruct kernfs_fs_context\tkfc;\n\tbool\t\t\t\tenable_cdpl2;\n\tbool\t\t\t\tenable_cdpl3;\n\tbool\t\t\t\tenable_mba_mbps;\n};\n\nstatic inline struct rdt_fs_context *rdt_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct rdt_fs_context, kfc);\n}\n\nDECLARE_STATIC_KEY_FALSE(rdt_enable_key);\nDECLARE_STATIC_KEY_FALSE(rdt_mon_enable_key);\n\n \nstruct mon_evt {\n\tenum resctrl_event_id\tevtid;\n\tchar\t\t\t*name;\n\tbool\t\t\tconfigurable;\n\tstruct list_head\tlist;\n};\n\n \nunion mon_data_bits {\n\tvoid *priv;\n\tstruct {\n\t\tunsigned int rid\t\t: 10;\n\t\tenum resctrl_event_id evtid\t: 8;\n\t\tunsigned int domid\t\t: 14;\n\t} u;\n};\n\nstruct rmid_read {\n\tstruct rdtgroup\t\t*rgrp;\n\tstruct rdt_resource\t*r;\n\tstruct rdt_domain\t*d;\n\tenum resctrl_event_id\tevtid;\n\tbool\t\t\tfirst;\n\tint\t\t\terr;\n\tu64\t\t\tval;\n};\n\nextern bool rdt_alloc_capable;\nextern bool rdt_mon_capable;\nextern unsigned int rdt_mon_features;\nextern struct list_head resctrl_schema_all;\n\nenum rdt_group_type {\n\tRDTCTRL_GROUP = 0,\n\tRDTMON_GROUP,\n\tRDT_NUM_GROUP,\n};\n\n \nenum rdtgrp_mode {\n\tRDT_MODE_SHAREABLE = 0,\n\tRDT_MODE_EXCLUSIVE,\n\tRDT_MODE_PSEUDO_LOCKSETUP,\n\tRDT_MODE_PSEUDO_LOCKED,\n\n\t \n\tRDT_NUM_MODES,\n};\n\n \nstruct mongroup {\n\tstruct kernfs_node\t*mon_data_kn;\n\tstruct rdtgroup\t\t*parent;\n\tstruct list_head\tcrdtgrp_list;\n\tu32\t\t\trmid;\n};\n\n \nstruct pseudo_lock_region {\n\tstruct resctrl_schema\t*s;\n\tstruct rdt_domain\t*d;\n\tu32\t\t\tcbm;\n\twait_queue_head_t\tlock_thread_wq;\n\tint\t\t\tthread_done;\n\tint\t\t\tcpu;\n\tunsigned int\t\tline_size;\n\tunsigned int\t\tsize;\n\tvoid\t\t\t*kmem;\n\tunsigned int\t\tminor;\n\tstruct dentry\t\t*debugfs_dir;\n\tstruct list_head\tpm_reqs;\n};\n\n \nstruct rdtgroup {\n\tstruct kernfs_node\t\t*kn;\n\tstruct list_head\t\trdtgroup_list;\n\tu32\t\t\t\tclosid;\n\tstruct cpumask\t\t\tcpu_mask;\n\tint\t\t\t\tflags;\n\tatomic_t\t\t\twaitcount;\n\tenum rdt_group_type\t\ttype;\n\tstruct mongroup\t\t\tmon;\n\tenum rdtgrp_mode\t\tmode;\n\tstruct pseudo_lock_region\t*plr;\n};\n\n \n#define\tRDT_DELETED\t\t1\n\n \n#define RFTYPE_FLAGS_CPUS_LIST\t1\n\n \n#define RFTYPE_INFO\t\t\tBIT(0)\n#define RFTYPE_BASE\t\t\tBIT(1)\n#define RF_CTRLSHIFT\t\t\t4\n#define RF_MONSHIFT\t\t\t5\n#define RF_TOPSHIFT\t\t\t6\n#define RFTYPE_CTRL\t\t\tBIT(RF_CTRLSHIFT)\n#define RFTYPE_MON\t\t\tBIT(RF_MONSHIFT)\n#define RFTYPE_TOP\t\t\tBIT(RF_TOPSHIFT)\n#define RFTYPE_RES_CACHE\t\tBIT(8)\n#define RFTYPE_RES_MB\t\t\tBIT(9)\n#define RF_CTRL_INFO\t\t\t(RFTYPE_INFO | RFTYPE_CTRL)\n#define RF_MON_INFO\t\t\t(RFTYPE_INFO | RFTYPE_MON)\n#define RF_TOP_INFO\t\t\t(RFTYPE_INFO | RFTYPE_TOP)\n#define RF_CTRL_BASE\t\t\t(RFTYPE_BASE | RFTYPE_CTRL)\n\n \nextern struct list_head rdt_all_groups;\n\nextern int max_name_width, max_data_width;\n\nint __init rdtgroup_init(void);\nvoid __exit rdtgroup_exit(void);\n\n \nstruct rftype {\n\tchar\t\t\t*name;\n\tumode_t\t\t\tmode;\n\tconst struct kernfs_ops\t*kf_ops;\n\tunsigned long\t\tflags;\n\tunsigned long\t\tfflags;\n\n\tint (*seq_show)(struct kernfs_open_file *of,\n\t\t\tstruct seq_file *sf, void *v);\n\t \n\tssize_t (*write)(struct kernfs_open_file *of,\n\t\t\t char *buf, size_t nbytes, loff_t off);\n};\n\n \nstruct mbm_state {\n\tu64\tprev_bw_bytes;\n\tu32\tprev_bw;\n\tu32\tdelta_bw;\n\tbool\tdelta_comp;\n};\n\n \nstruct arch_mbm_state {\n\tu64\tchunks;\n\tu64\tprev_msr;\n};\n\n \nstruct rdt_hw_domain {\n\tstruct rdt_domain\t\td_resctrl;\n\tu32\t\t\t\t*ctrl_val;\n\tstruct arch_mbm_state\t\t*arch_mbm_total;\n\tstruct arch_mbm_state\t\t*arch_mbm_local;\n};\n\nstatic inline struct rdt_hw_domain *resctrl_to_arch_dom(struct rdt_domain *r)\n{\n\treturn container_of(r, struct rdt_hw_domain, d_resctrl);\n}\n\n \nstruct msr_param {\n\tstruct rdt_resource\t*res;\n\tu32\t\t\tlow;\n\tu32\t\t\thigh;\n};\n\nstatic inline bool is_llc_occupancy_enabled(void)\n{\n\treturn (rdt_mon_features & (1 << QOS_L3_OCCUP_EVENT_ID));\n}\n\nstatic inline bool is_mbm_total_enabled(void)\n{\n\treturn (rdt_mon_features & (1 << QOS_L3_MBM_TOTAL_EVENT_ID));\n}\n\nstatic inline bool is_mbm_local_enabled(void)\n{\n\treturn (rdt_mon_features & (1 << QOS_L3_MBM_LOCAL_EVENT_ID));\n}\n\nstatic inline bool is_mbm_enabled(void)\n{\n\treturn (is_mbm_total_enabled() || is_mbm_local_enabled());\n}\n\nstatic inline bool is_mbm_event(int e)\n{\n\treturn (e >= QOS_L3_MBM_TOTAL_EVENT_ID &&\n\t\te <= QOS_L3_MBM_LOCAL_EVENT_ID);\n}\n\nstruct rdt_parse_data {\n\tstruct rdtgroup\t\t*rdtgrp;\n\tchar\t\t\t*buf;\n};\n\n \nstruct rdt_hw_resource {\n\tstruct rdt_resource\tr_resctrl;\n\tu32\t\t\tnum_closid;\n\tunsigned int\t\tmsr_base;\n\tvoid (*msr_update)\t(struct rdt_domain *d, struct msr_param *m,\n\t\t\t\t struct rdt_resource *r);\n\tunsigned int\t\tmon_scale;\n\tunsigned int\t\tmbm_width;\n\tbool\t\t\tcdp_enabled;\n};\n\nstatic inline struct rdt_hw_resource *resctrl_to_arch_res(struct rdt_resource *r)\n{\n\treturn container_of(r, struct rdt_hw_resource, r_resctrl);\n}\n\nint parse_cbm(struct rdt_parse_data *data, struct resctrl_schema *s,\n\t      struct rdt_domain *d);\nint parse_bw(struct rdt_parse_data *data, struct resctrl_schema *s,\n\t     struct rdt_domain *d);\n\nextern struct mutex rdtgroup_mutex;\n\nextern struct rdt_hw_resource rdt_resources_all[];\nextern struct rdtgroup rdtgroup_default;\nDECLARE_STATIC_KEY_FALSE(rdt_alloc_enable_key);\n\nextern struct dentry *debugfs_resctrl;\n\nenum resctrl_res_level {\n\tRDT_RESOURCE_L3,\n\tRDT_RESOURCE_L2,\n\tRDT_RESOURCE_MBA,\n\tRDT_RESOURCE_SMBA,\n\n\t \n\tRDT_NUM_RESOURCES,\n};\n\nstatic inline struct rdt_resource *resctrl_inc(struct rdt_resource *res)\n{\n\tstruct rdt_hw_resource *hw_res = resctrl_to_arch_res(res);\n\n\thw_res++;\n\treturn &hw_res->r_resctrl;\n}\n\nstatic inline bool resctrl_arch_get_cdp_enabled(enum resctrl_res_level l)\n{\n\treturn rdt_resources_all[l].cdp_enabled;\n}\n\nint resctrl_arch_set_cdp_enabled(enum resctrl_res_level l, bool enable);\n\n \n#define for_each_rdt_resource(r)\t\t\t\t\t      \\\n\tfor (r = &rdt_resources_all[0].r_resctrl;\t\t\t      \\\n\t     r <= &rdt_resources_all[RDT_NUM_RESOURCES - 1].r_resctrl;\t      \\\n\t     r = resctrl_inc(r))\n\n#define for_each_capable_rdt_resource(r)\t\t\t\t      \\\n\tfor_each_rdt_resource(r)\t\t\t\t\t      \\\n\t\tif (r->alloc_capable || r->mon_capable)\n\n#define for_each_alloc_capable_rdt_resource(r)\t\t\t\t      \\\n\tfor_each_rdt_resource(r)\t\t\t\t\t      \\\n\t\tif (r->alloc_capable)\n\n#define for_each_mon_capable_rdt_resource(r)\t\t\t\t      \\\n\tfor_each_rdt_resource(r)\t\t\t\t\t      \\\n\t\tif (r->mon_capable)\n\n \nunion cpuid_0x10_1_eax {\n\tstruct {\n\t\tunsigned int cbm_len:5;\n\t} split;\n\tunsigned int full;\n};\n\n \nunion cpuid_0x10_3_eax {\n\tstruct {\n\t\tunsigned int max_delay:12;\n\t} split;\n\tunsigned int full;\n};\n\n \nunion cpuid_0x10_x_edx {\n\tstruct {\n\t\tunsigned int cos_max:16;\n\t} split;\n\tunsigned int full;\n};\n\nvoid rdt_last_cmd_clear(void);\nvoid rdt_last_cmd_puts(const char *s);\n__printf(1, 2)\nvoid rdt_last_cmd_printf(const char *fmt, ...);\n\nvoid rdt_ctrl_update(void *arg);\nstruct rdtgroup *rdtgroup_kn_lock_live(struct kernfs_node *kn);\nvoid rdtgroup_kn_unlock(struct kernfs_node *kn);\nint rdtgroup_kn_mode_restrict(struct rdtgroup *r, const char *name);\nint rdtgroup_kn_mode_restore(struct rdtgroup *r, const char *name,\n\t\t\t     umode_t mask);\nstruct rdt_domain *rdt_find_domain(struct rdt_resource *r, int id,\n\t\t\t\t   struct list_head **pos);\nssize_t rdtgroup_schemata_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off);\nint rdtgroup_schemata_show(struct kernfs_open_file *of,\n\t\t\t   struct seq_file *s, void *v);\nbool rdtgroup_cbm_overlaps(struct resctrl_schema *s, struct rdt_domain *d,\n\t\t\t   unsigned long cbm, int closid, bool exclusive);\nunsigned int rdtgroup_cbm_to_size(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t\t  unsigned long cbm);\nenum rdtgrp_mode rdtgroup_mode_by_closid(int closid);\nint rdtgroup_tasks_assigned(struct rdtgroup *r);\nint rdtgroup_locksetup_enter(struct rdtgroup *rdtgrp);\nint rdtgroup_locksetup_exit(struct rdtgroup *rdtgrp);\nbool rdtgroup_cbm_overlaps_pseudo_locked(struct rdt_domain *d, unsigned long cbm);\nbool rdtgroup_pseudo_locked_in_hierarchy(struct rdt_domain *d);\nint rdt_pseudo_lock_init(void);\nvoid rdt_pseudo_lock_release(void);\nint rdtgroup_pseudo_lock_create(struct rdtgroup *rdtgrp);\nvoid rdtgroup_pseudo_lock_remove(struct rdtgroup *rdtgrp);\nstruct rdt_domain *get_domain_from_cpu(int cpu, struct rdt_resource *r);\nint closids_supported(void);\nvoid closid_free(int closid);\nint alloc_rmid(void);\nvoid free_rmid(u32 rmid);\nint rdt_get_mon_l3_config(struct rdt_resource *r);\nbool __init rdt_cpu_has(int flag);\nvoid mon_event_count(void *info);\nint rdtgroup_mondata_show(struct seq_file *m, void *arg);\nvoid mon_event_read(struct rmid_read *rr, struct rdt_resource *r,\n\t\t    struct rdt_domain *d, struct rdtgroup *rdtgrp,\n\t\t    int evtid, int first);\nvoid mbm_setup_overflow_handler(struct rdt_domain *dom,\n\t\t\t\tunsigned long delay_ms);\nvoid mbm_handle_overflow(struct work_struct *work);\nvoid __init intel_rdt_mbm_apply_quirk(void);\nbool is_mba_sc(struct rdt_resource *r);\nvoid cqm_setup_limbo_handler(struct rdt_domain *dom, unsigned long delay_ms);\nvoid cqm_handle_limbo(struct work_struct *work);\nbool has_busy_rmid(struct rdt_resource *r, struct rdt_domain *d);\nvoid __check_limbo(struct rdt_domain *d, bool force_free);\nvoid rdt_domain_reconfigure_cdp(struct rdt_resource *r);\nvoid __init thread_throttle_mode_init(void);\nvoid __init mbm_config_rftype_init(const char *config);\nvoid rdt_staged_configs_clear(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}