{
  "module_name": "ctrlmondata.c",
  "hash_id": "e1a5d4f235b407d62cc73062aec11d11ff5a445495c0f6c761e3b34f27acce5b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/resctrl/ctrlmondata.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/kernfs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n \nstatic bool bw_validate(char *buf, unsigned long *data, struct rdt_resource *r)\n{\n\tunsigned long bw;\n\tint ret;\n\n\t \n\tif (!r->membw.delay_linear && r->membw.arch_needs_linear) {\n\t\trdt_last_cmd_puts(\"No support for non-linear MB domains\\n\");\n\t\treturn false;\n\t}\n\n\tret = kstrtoul(buf, 10, &bw);\n\tif (ret) {\n\t\trdt_last_cmd_printf(\"Non-decimal digit in MB value %s\\n\", buf);\n\t\treturn false;\n\t}\n\n\tif ((bw < r->membw.min_bw || bw > r->default_ctrl) &&\n\t    !is_mba_sc(r)) {\n\t\trdt_last_cmd_printf(\"MB value %ld out of range [%d,%d]\\n\", bw,\n\t\t\t\t    r->membw.min_bw, r->default_ctrl);\n\t\treturn false;\n\t}\n\n\t*data = roundup(bw, (unsigned long)r->membw.bw_gran);\n\treturn true;\n}\n\nint parse_bw(struct rdt_parse_data *data, struct resctrl_schema *s,\n\t     struct rdt_domain *d)\n{\n\tstruct resctrl_staged_config *cfg;\n\tu32 closid = data->rdtgrp->closid;\n\tstruct rdt_resource *r = s->res;\n\tunsigned long bw_val;\n\n\tcfg = &d->staged_config[s->conf_type];\n\tif (cfg->have_new_ctrl) {\n\t\trdt_last_cmd_printf(\"Duplicate domain %d\\n\", d->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bw_validate(data->buf, &bw_val, r))\n\t\treturn -EINVAL;\n\n\tif (is_mba_sc(r)) {\n\t\td->mbps_val[closid] = bw_val;\n\t\treturn 0;\n\t}\n\n\tcfg->new_ctrl = bw_val;\n\tcfg->have_new_ctrl = true;\n\n\treturn 0;\n}\n\n \nstatic bool cbm_validate(char *buf, u32 *data, struct rdt_resource *r)\n{\n\tunsigned long first_bit, zero_bit, val;\n\tunsigned int cbm_len = r->cache.cbm_len;\n\tint ret;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret) {\n\t\trdt_last_cmd_printf(\"Non-hex character in the mask %s\\n\", buf);\n\t\treturn false;\n\t}\n\n\tif ((r->cache.min_cbm_bits > 0 && val == 0) || val > r->default_ctrl) {\n\t\trdt_last_cmd_puts(\"Mask out of range\\n\");\n\t\treturn false;\n\t}\n\n\tfirst_bit = find_first_bit(&val, cbm_len);\n\tzero_bit = find_next_zero_bit(&val, cbm_len, first_bit);\n\n\t \n\tif (!r->cache.arch_has_sparse_bitmaps &&\n\t    (find_next_bit(&val, cbm_len, zero_bit) < cbm_len)) {\n\t\trdt_last_cmd_printf(\"The mask %lx has non-consecutive 1-bits\\n\", val);\n\t\treturn false;\n\t}\n\n\tif ((zero_bit - first_bit) < r->cache.min_cbm_bits) {\n\t\trdt_last_cmd_printf(\"Need at least %d bits in the mask\\n\",\n\t\t\t\t    r->cache.min_cbm_bits);\n\t\treturn false;\n\t}\n\n\t*data = val;\n\treturn true;\n}\n\n \nint parse_cbm(struct rdt_parse_data *data, struct resctrl_schema *s,\n\t      struct rdt_domain *d)\n{\n\tstruct rdtgroup *rdtgrp = data->rdtgrp;\n\tstruct resctrl_staged_config *cfg;\n\tstruct rdt_resource *r = s->res;\n\tu32 cbm_val;\n\n\tcfg = &d->staged_config[s->conf_type];\n\tif (cfg->have_new_ctrl) {\n\t\trdt_last_cmd_printf(\"Duplicate domain %d\\n\", d->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKSETUP &&\n\t    rdtgroup_pseudo_locked_in_hierarchy(d)) {\n\t\trdt_last_cmd_puts(\"Pseudo-locked region in hierarchy\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cbm_validate(data->buf, &cbm_val, r))\n\t\treturn -EINVAL;\n\n\tif ((rdtgrp->mode == RDT_MODE_EXCLUSIVE ||\n\t     rdtgrp->mode == RDT_MODE_SHAREABLE) &&\n\t    rdtgroup_cbm_overlaps_pseudo_locked(d, cbm_val)) {\n\t\trdt_last_cmd_puts(\"CBM overlaps with pseudo-locked region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rdtgroup_cbm_overlaps(s, d, cbm_val, rdtgrp->closid, true)) {\n\t\trdt_last_cmd_puts(\"Overlaps with exclusive group\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rdtgroup_cbm_overlaps(s, d, cbm_val, rdtgrp->closid, false)) {\n\t\tif (rdtgrp->mode == RDT_MODE_EXCLUSIVE ||\n\t\t    rdtgrp->mode == RDT_MODE_PSEUDO_LOCKSETUP) {\n\t\t\trdt_last_cmd_puts(\"Overlaps with other group\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcfg->new_ctrl = cbm_val;\n\tcfg->have_new_ctrl = true;\n\n\treturn 0;\n}\n\n \nstatic int parse_line(char *line, struct resctrl_schema *s,\n\t\t      struct rdtgroup *rdtgrp)\n{\n\tenum resctrl_conf_type t = s->conf_type;\n\tstruct resctrl_staged_config *cfg;\n\tstruct rdt_resource *r = s->res;\n\tstruct rdt_parse_data data;\n\tchar *dom = NULL, *id;\n\tstruct rdt_domain *d;\n\tunsigned long dom_id;\n\n\tif (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKSETUP &&\n\t    (r->rid == RDT_RESOURCE_MBA || r->rid == RDT_RESOURCE_SMBA)) {\n\t\trdt_last_cmd_puts(\"Cannot pseudo-lock MBA resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\nnext:\n\tif (!line || line[0] == '\\0')\n\t\treturn 0;\n\tdom = strsep(&line, \";\");\n\tid = strsep(&dom, \"=\");\n\tif (!dom || kstrtoul(id, 10, &dom_id)) {\n\t\trdt_last_cmd_puts(\"Missing '=' or non-numeric domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdom = strim(dom);\n\tlist_for_each_entry(d, &r->domains, list) {\n\t\tif (d->id == dom_id) {\n\t\t\tdata.buf = dom;\n\t\t\tdata.rdtgrp = rdtgrp;\n\t\t\tif (r->parse_ctrlval(&data, s, d))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (rdtgrp->mode ==  RDT_MODE_PSEUDO_LOCKSETUP) {\n\t\t\t\tcfg = &d->staged_config[t];\n\t\t\t\t \n\t\t\t\trdtgrp->plr->s = s;\n\t\t\t\trdtgrp->plr->d = d;\n\t\t\t\trdtgrp->plr->cbm = cfg->new_ctrl;\n\t\t\t\td->plr = rdtgrp->plr;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic u32 get_config_index(u32 closid, enum resctrl_conf_type type)\n{\n\tswitch (type) {\n\tdefault:\n\tcase CDP_NONE:\n\t\treturn closid;\n\tcase CDP_CODE:\n\t\treturn closid * 2 + 1;\n\tcase CDP_DATA:\n\t\treturn closid * 2;\n\t}\n}\n\nstatic bool apply_config(struct rdt_hw_domain *hw_dom,\n\t\t\t struct resctrl_staged_config *cfg, u32 idx,\n\t\t\t cpumask_var_t cpu_mask)\n{\n\tstruct rdt_domain *dom = &hw_dom->d_resctrl;\n\n\tif (cfg->new_ctrl != hw_dom->ctrl_val[idx]) {\n\t\tcpumask_set_cpu(cpumask_any(&dom->cpu_mask), cpu_mask);\n\t\thw_dom->ctrl_val[idx] = cfg->new_ctrl;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint resctrl_arch_update_one(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t    u32 closid, enum resctrl_conf_type t, u32 cfg_val)\n{\n\tstruct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);\n\tstruct rdt_hw_domain *hw_dom = resctrl_to_arch_dom(d);\n\tu32 idx = get_config_index(closid, t);\n\tstruct msr_param msr_param;\n\n\tif (!cpumask_test_cpu(smp_processor_id(), &d->cpu_mask))\n\t\treturn -EINVAL;\n\n\thw_dom->ctrl_val[idx] = cfg_val;\n\n\tmsr_param.res = r;\n\tmsr_param.low = idx;\n\tmsr_param.high = idx + 1;\n\thw_res->msr_update(d, &msr_param, r);\n\n\treturn 0;\n}\n\nint resctrl_arch_update_domains(struct rdt_resource *r, u32 closid)\n{\n\tstruct resctrl_staged_config *cfg;\n\tstruct rdt_hw_domain *hw_dom;\n\tstruct msr_param msr_param;\n\tenum resctrl_conf_type t;\n\tcpumask_var_t cpu_mask;\n\tstruct rdt_domain *d;\n\tu32 idx;\n\n\tif (!zalloc_cpumask_var(&cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tmsr_param.res = NULL;\n\tlist_for_each_entry(d, &r->domains, list) {\n\t\thw_dom = resctrl_to_arch_dom(d);\n\t\tfor (t = 0; t < CDP_NUM_TYPES; t++) {\n\t\t\tcfg = &hw_dom->d_resctrl.staged_config[t];\n\t\t\tif (!cfg->have_new_ctrl)\n\t\t\t\tcontinue;\n\n\t\t\tidx = get_config_index(closid, t);\n\t\t\tif (!apply_config(hw_dom, cfg, idx, cpu_mask))\n\t\t\t\tcontinue;\n\n\t\t\tif (!msr_param.res) {\n\t\t\t\tmsr_param.low = idx;\n\t\t\t\tmsr_param.high = msr_param.low + 1;\n\t\t\t\tmsr_param.res = r;\n\t\t\t} else {\n\t\t\t\tmsr_param.low = min(msr_param.low, idx);\n\t\t\t\tmsr_param.high = max(msr_param.high, idx + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cpumask_empty(cpu_mask))\n\t\tgoto done;\n\n\t \n\ton_each_cpu_mask(cpu_mask, rdt_ctrl_update, &msr_param, 1);\n\ndone:\n\tfree_cpumask_var(cpu_mask);\n\n\treturn 0;\n}\n\nstatic int rdtgroup_parse_resource(char *resname, char *tok,\n\t\t\t\t   struct rdtgroup *rdtgrp)\n{\n\tstruct resctrl_schema *s;\n\n\tlist_for_each_entry(s, &resctrl_schema_all, list) {\n\t\tif (!strcmp(resname, s->name) && rdtgrp->closid < s->num_closid)\n\t\t\treturn parse_line(tok, s, rdtgrp);\n\t}\n\trdt_last_cmd_printf(\"Unknown or unsupported resource name '%s'\\n\", resname);\n\treturn -EINVAL;\n}\n\nssize_t rdtgroup_schemata_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct resctrl_schema *s;\n\tstruct rdtgroup *rdtgrp;\n\tstruct rdt_resource *r;\n\tchar *tok, *resname;\n\tint ret = 0;\n\n\t \n\tif (nbytes == 0 || buf[nbytes - 1] != '\\n')\n\t\treturn -EINVAL;\n\tbuf[nbytes - 1] = '\\0';\n\n\tcpus_read_lock();\n\trdtgrp = rdtgroup_kn_lock_live(of->kn);\n\tif (!rdtgrp) {\n\t\trdtgroup_kn_unlock(of->kn);\n\t\tcpus_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\trdt_last_cmd_clear();\n\n\t \n\tif (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKED) {\n\t\tret = -EINVAL;\n\t\trdt_last_cmd_puts(\"Resource group is pseudo-locked\\n\");\n\t\tgoto out;\n\t}\n\n\trdt_staged_configs_clear();\n\n\twhile ((tok = strsep(&buf, \"\\n\")) != NULL) {\n\t\tresname = strim(strsep(&tok, \":\"));\n\t\tif (!tok) {\n\t\t\trdt_last_cmd_puts(\"Missing ':'\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (tok[0] == '\\0') {\n\t\t\trdt_last_cmd_printf(\"Missing '%s' value\\n\", resname);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rdtgroup_parse_resource(resname, tok, rdtgrp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(s, &resctrl_schema_all, list) {\n\t\tr = s->res;\n\n\t\t \n\t\tif (is_mba_sc(r))\n\t\t\tcontinue;\n\n\t\tret = resctrl_arch_update_domains(r, rdtgrp->closid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKSETUP) {\n\t\t \n\t\tret = rdtgroup_pseudo_lock_create(rdtgrp);\n\t}\n\nout:\n\trdt_staged_configs_clear();\n\trdtgroup_kn_unlock(of->kn);\n\tcpus_read_unlock();\n\treturn ret ?: nbytes;\n}\n\nu32 resctrl_arch_get_config(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t    u32 closid, enum resctrl_conf_type type)\n{\n\tstruct rdt_hw_domain *hw_dom = resctrl_to_arch_dom(d);\n\tu32 idx = get_config_index(closid, type);\n\n\treturn hw_dom->ctrl_val[idx];\n}\n\nstatic void show_doms(struct seq_file *s, struct resctrl_schema *schema, int closid)\n{\n\tstruct rdt_resource *r = schema->res;\n\tstruct rdt_domain *dom;\n\tbool sep = false;\n\tu32 ctrl_val;\n\n\tseq_printf(s, \"%*s:\", max_name_width, schema->name);\n\tlist_for_each_entry(dom, &r->domains, list) {\n\t\tif (sep)\n\t\t\tseq_puts(s, \";\");\n\n\t\tif (is_mba_sc(r))\n\t\t\tctrl_val = dom->mbps_val[closid];\n\t\telse\n\t\t\tctrl_val = resctrl_arch_get_config(r, dom, closid,\n\t\t\t\t\t\t\t   schema->conf_type);\n\n\t\tseq_printf(s, r->format_str, dom->id, max_data_width,\n\t\t\t   ctrl_val);\n\t\tsep = true;\n\t}\n\tseq_puts(s, \"\\n\");\n}\n\nint rdtgroup_schemata_show(struct kernfs_open_file *of,\n\t\t\t   struct seq_file *s, void *v)\n{\n\tstruct resctrl_schema *schema;\n\tstruct rdtgroup *rdtgrp;\n\tint ret = 0;\n\tu32 closid;\n\n\trdtgrp = rdtgroup_kn_lock_live(of->kn);\n\tif (rdtgrp) {\n\t\tif (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKSETUP) {\n\t\t\tlist_for_each_entry(schema, &resctrl_schema_all, list) {\n\t\t\t\tseq_printf(s, \"%s:uninitialized\\n\", schema->name);\n\t\t\t}\n\t\t} else if (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKED) {\n\t\t\tif (!rdtgrp->plr->d) {\n\t\t\t\trdt_last_cmd_clear();\n\t\t\t\trdt_last_cmd_puts(\"Cache domain offline\\n\");\n\t\t\t\tret = -ENODEV;\n\t\t\t} else {\n\t\t\t\tseq_printf(s, \"%s:%d=%x\\n\",\n\t\t\t\t\t   rdtgrp->plr->s->res->name,\n\t\t\t\t\t   rdtgrp->plr->d->id,\n\t\t\t\t\t   rdtgrp->plr->cbm);\n\t\t\t}\n\t\t} else {\n\t\t\tclosid = rdtgrp->closid;\n\t\t\tlist_for_each_entry(schema, &resctrl_schema_all, list) {\n\t\t\t\tif (closid < schema->num_closid)\n\t\t\t\t\tshow_doms(s, schema, closid);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\trdtgroup_kn_unlock(of->kn);\n\treturn ret;\n}\n\nvoid mon_event_read(struct rmid_read *rr, struct rdt_resource *r,\n\t\t    struct rdt_domain *d, struct rdtgroup *rdtgrp,\n\t\t    int evtid, int first)\n{\n\t \n\trr->rgrp = rdtgrp;\n\trr->evtid = evtid;\n\trr->r = r;\n\trr->d = d;\n\trr->val = 0;\n\trr->first = first;\n\n\tsmp_call_function_any(&d->cpu_mask, mon_event_count, rr, 1);\n}\n\nint rdtgroup_mondata_show(struct seq_file *m, void *arg)\n{\n\tstruct kernfs_open_file *of = m->private;\n\tu32 resid, evtid, domid;\n\tstruct rdtgroup *rdtgrp;\n\tstruct rdt_resource *r;\n\tunion mon_data_bits md;\n\tstruct rdt_domain *d;\n\tstruct rmid_read rr;\n\tint ret = 0;\n\n\trdtgrp = rdtgroup_kn_lock_live(of->kn);\n\tif (!rdtgrp) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmd.priv = of->kn->priv;\n\tresid = md.u.rid;\n\tdomid = md.u.domid;\n\tevtid = md.u.evtid;\n\n\tr = &rdt_resources_all[resid].r_resctrl;\n\td = rdt_find_domain(r, domid, NULL);\n\tif (IS_ERR_OR_NULL(d)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmon_event_read(&rr, r, d, rdtgrp, evtid, false);\n\n\tif (rr.err == -EIO)\n\t\tseq_puts(m, \"Error\\n\");\n\telse if (rr.err == -EINVAL)\n\t\tseq_puts(m, \"Unavailable\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", rr.val);\n\nout:\n\trdtgroup_kn_unlock(of->kn);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}