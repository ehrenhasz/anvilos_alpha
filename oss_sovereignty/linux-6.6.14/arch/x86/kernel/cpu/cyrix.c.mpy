{
  "module_name": "cyrix.c",
  "hash_id": "73fa25072937436bbe4f299fe92b8b362e20c064855b156acefad2570488f539",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/cyrix.c",
  "human_readable_source": "\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/isa-dma.h>\n#include <linux/pci.h>\n#include <asm/dma.h>\n#include <linux/io.h>\n#include <asm/processor-cyrix.h>\n#include <asm/processor-flags.h>\n#include <linux/timer.h>\n#include <asm/pci-direct.h>\n#include <asm/tsc.h>\n#include <asm/cpufeature.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n\n#include \"cpu.h\"\n\n \nstatic void __do_cyrix_devid(unsigned char *dir0, unsigned char *dir1)\n{\n\tunsigned char ccr2, ccr3;\n\n\t \n\tccr3 = getCx86(CX86_CCR3);\n\tsetCx86(CX86_CCR3, ccr3 ^ 0x80);\n\tgetCx86(0xc0);    \n\n\tif (getCx86(CX86_CCR3) == ccr3) {        \n\t\tccr2 = getCx86(CX86_CCR2);\n\t\tsetCx86(CX86_CCR2, ccr2 ^ 0x04);\n\t\tgetCx86(0xc0);   \n\n\t\tif (getCx86(CX86_CCR2) == ccr2)  \n\t\t\t*dir0 = 0xfd;\n\t\telse {                           \n\t\t\tsetCx86(CX86_CCR2, ccr2);\n\t\t\t*dir0 = 0xfe;\n\t\t}\n\t} else {\n\t\tsetCx86(CX86_CCR3, ccr3);   \n\n\t\t \n\t\t*dir0 = getCx86(CX86_DIR0);\n\t\t*dir1 = getCx86(CX86_DIR1);\n\t}\n}\n\nstatic void do_cyrix_devid(unsigned char *dir0, unsigned char *dir1)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__do_cyrix_devid(dir0, dir1);\n\tlocal_irq_restore(flags);\n}\n \nstatic unsigned char Cx86_dir0_msb = 0;\n\nstatic const char Cx86_model[][9] = {\n\t\"Cx486\", \"Cx486\", \"5x86 \", \"6x86\", \"MediaGX \", \"6x86MX \",\n\t\"M II \", \"Unknown\"\n};\nstatic const char Cx486_name[][5] = {\n\t\"SLC\", \"DLC\", \"SLC2\", \"DLC2\", \"SRx\", \"DRx\",\n\t\"SRx2\", \"DRx2\"\n};\nstatic const char Cx486S_name[][4] = {\n\t\"S\", \"S2\", \"Se\", \"S2e\"\n};\nstatic const char Cx486D_name[][4] = {\n\t\"DX\", \"DX2\", \"?\", \"?\", \"?\", \"DX4\"\n};\nstatic char Cx86_cb[] = \"?.5x Core/Bus Clock\";\nstatic const char cyrix_model_mult1[] = \"12??43\";\nstatic const char cyrix_model_mult2[] = \"12233445\";\n\n \n\nstatic void check_cx686_slop(struct cpuinfo_x86 *c)\n{\n\tunsigned long flags;\n\n\tif (Cx86_dir0_msb == 3) {\n\t\tunsigned char ccr3, ccr5;\n\n\t\tlocal_irq_save(flags);\n\t\tccr3 = getCx86(CX86_CCR3);\n\t\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);  \n\t\tccr5 = getCx86(CX86_CCR5);\n\t\tif (ccr5 & 2)\n\t\t\tsetCx86(CX86_CCR5, ccr5 & 0xfd);   \n\t\tsetCx86(CX86_CCR3, ccr3);                  \n\t\tlocal_irq_restore(flags);\n\n\t\tif (ccr5 & 2) {  \n\t\t\tpr_info(\"Recalibrating delay loop with SLOP bit reset\\n\");\n\t\t\tcalibrate_delay();\n\t\t\tc->loops_per_jiffy = loops_per_jiffy;\n\t\t}\n\t}\n}\n\n\nstatic void set_cx86_reorder(void)\n{\n\tu8 ccr3;\n\n\tpr_info(\"Enable Memory access reorder on Cyrix/NSC processor.\\n\");\n\tccr3 = getCx86(CX86_CCR3);\n\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);  \n\n\t \n\tsetCx86(CX86_PCR0, getCx86(CX86_PCR0) & ~0x80);\n\t \n\tccr3 |= 0xe0;\n\tsetCx86(CX86_CCR3, ccr3);\n}\n\nstatic void set_cx86_memwb(void)\n{\n\tpr_info(\"Enable Memory-Write-back mode on Cyrix/NSC processor.\\n\");\n\n\t \n\tsetCx86(CX86_CCR2, getCx86(CX86_CCR2) & ~0x04);\n\t \n\twrite_cr0(read_cr0() | X86_CR0_NW);\n\t \n\tsetCx86(CX86_CCR2, getCx86(CX86_CCR2) | 0x14);\n}\n\n \n\nstatic void geode_configure(void)\n{\n\tunsigned long flags;\n\tu8 ccr3;\n\tlocal_irq_save(flags);\n\n\t \n\tsetCx86(CX86_CCR2, getCx86(CX86_CCR2) | 0x88);\n\n\tccr3 = getCx86(CX86_CCR3);\n\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\t \n\n\n\t \n\tsetCx86(CX86_CCR4, getCx86(CX86_CCR4) | 0x38);\n\tsetCx86(CX86_CCR3, ccr3);\t\t\t \n\n\tset_cx86_memwb();\n\tset_cx86_reorder();\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void early_init_cyrix(struct cpuinfo_x86 *c)\n{\n\tunsigned char dir0, dir0_msn, dir1 = 0;\n\n\t__do_cyrix_devid(&dir0, &dir1);\n\tdir0_msn = dir0 >> 4;  \n\n\tswitch (dir0_msn) {\n\tcase 3:  \n\t\t \n\t\tset_cpu_cap(c, X86_FEATURE_CYRIX_ARR);\n\t\tbreak;\n\tcase 5:  \n\t\t \n\t\tset_cpu_cap(c, X86_FEATURE_CYRIX_ARR);\n\t\tbreak;\n\t}\n}\n\nstatic void init_cyrix(struct cpuinfo_x86 *c)\n{\n\tunsigned char dir0, dir0_msn, dir0_lsn, dir1 = 0;\n\tchar *buf = c->x86_model_id;\n\tconst char *p = NULL;\n\n\t \n\tclear_cpu_cap(c, 0*32+31);\n\n\t \n\tif (test_cpu_cap(c, 1*32+24)) {\n\t\tclear_cpu_cap(c, 1*32+24);\n\t\tset_cpu_cap(c, X86_FEATURE_CXMMX);\n\t}\n\n\tdo_cyrix_devid(&dir0, &dir1);\n\n\tcheck_cx686_slop(c);\n\n\tCx86_dir0_msb = dir0_msn = dir0 >> 4;  \n\tdir0_lsn = dir0 & 0xf;                 \n\n\t \n\tc->x86_model = (dir1 >> 4) + 1;\n\tc->x86_stepping = dir1 & 0xf;\n\n\t \n\n\tswitch (dir0_msn) {\n\t\tunsigned char tmp;\n\n\tcase 0:  \n\t\tp = Cx486_name[dir0_lsn & 7];\n\t\tbreak;\n\n\tcase 1:  \n\t\tp = (dir0_lsn & 8) ? Cx486D_name[dir0_lsn & 5]\n\t\t\t: Cx486S_name[dir0_lsn & 3];\n\t\tbreak;\n\n\tcase 2:  \n\t\tCx86_cb[2] = cyrix_model_mult1[dir0_lsn & 5];\n\t\tp = Cx86_cb+2;\n\t\tbreak;\n\n\tcase 3:  \n\t\tCx86_cb[1] = ' ';\n\t\tCx86_cb[2] = cyrix_model_mult1[dir0_lsn & 5];\n\t\tif (dir1 > 0x21) {  \n\t\t\tCx86_cb[0] = 'L';\n\t\t\tp = Cx86_cb;\n\t\t\t(c->x86_model)++;\n\t\t} else              \n\t\t\tp = Cx86_cb+1;\n\t\t \n\t\tset_cpu_cap(c, X86_FEATURE_CYRIX_ARR);\n\t\t \n\t\tset_cpu_bug(c, X86_BUG_COMA);\n\t\tbreak;\n\n\tcase 4:  \n\tcase 11:  \n#ifdef CONFIG_PCI\n\t{\n\t\tu32 vendor, device;\n\t\t \n\n\t\tpr_info(\"Working around Cyrix MediaGX virtual DMA bugs.\\n\");\n\t\tisa_dma_bridge_buggy = 2;\n\n\t\t \n\t\tvendor = read_pci_config_16(0, 0, 0x12, PCI_VENDOR_ID);\n\t\tdevice = read_pci_config_16(0, 0, 0x12, PCI_DEVICE_ID);\n\n\t\t \n\t\tif (vendor == PCI_VENDOR_ID_CYRIX &&\n\t\t\t(device == PCI_DEVICE_ID_CYRIX_5510 ||\n\t\t\t\t\tdevice == PCI_DEVICE_ID_CYRIX_5520))\n\t\t\tmark_tsc_unstable(\"cyrix 5510/5520 detected\");\n\t}\n#endif\n\t\tc->x86_cache_size = 16;\t \n\n\t\t \n\t\tif (c->cpuid_level == 2) {\n\t\t\t \n\t\t\tsetCx86(CX86_CCR7, getCx86(CX86_CCR7) | 1);\n\n\t\t\t \n\t\t\tif ((0x30 <= dir1 && dir1 <= 0x6f) ||\n\t\t\t\t\t(0x80 <= dir1 && dir1 <= 0x8f))\n\t\t\t\tgeode_configure();\n\t\t\treturn;\n\t\t} else {  \n\t\t\tCx86_cb[2] = (dir0_lsn & 1) ? '3' : '4';\n\t\t\tp = Cx86_cb+2;\n\t\t\tc->x86_model = (dir1 & 0x20) ? 1 : 2;\n\t\t}\n\t\tbreak;\n\n\tcase 5:  \n\t\tif (dir1 > 7) {\n\t\t\tdir0_msn++;   \n\t\t\t \n\t\t\tsetCx86(CX86_CCR7, getCx86(CX86_CCR7)|1);\n\t\t} else {\n\t\t\t \n\t\t\tset_cpu_bug(c, X86_BUG_COMA);\n\t\t}\n\t\ttmp = (!(dir0_lsn & 7) || dir0_lsn & 1) ? 2 : 0;\n\t\tCx86_cb[tmp] = cyrix_model_mult2[dir0_lsn & 7];\n\t\tp = Cx86_cb+tmp;\n\t\tif (((dir1 & 0x0f) > 4) || ((dir1 & 0xf0) == 0x20))\n\t\t\t(c->x86_model)++;\n\t\t \n\t\tset_cpu_cap(c, X86_FEATURE_CYRIX_ARR);\n\t\tbreak;\n\n\tcase 0xf:   \n\t\tswitch (dir0_lsn) {\n\t\tcase 0xd:   \n\t\t\tdir0_msn = 0;\n\t\t\tp = Cx486_name[!!boot_cpu_has(X86_FEATURE_FPU)];\n\t\t\tbreak;\n\n\t\tcase 0xe:   \n\t\t\tdir0_msn = 0;\n\t\t\tp = Cx486S_name[0];\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:   \n\t\tdir0_msn = 7;\n\t\tbreak;\n\t}\n\tstrcpy(buf, Cx86_model[dir0_msn & 7]);\n\tif (p)\n\t\tstrcat(buf, p);\n\treturn;\n}\n\n \nstatic void init_nsc(struct cpuinfo_x86 *c)\n{\n\t \n\n\t \n\n\tif (c->x86 == 5 && c->x86_model == 5)\n\t\tcpu_detect_cache_sizes(c);\n\telse\n\t\tinit_cyrix(c);\n}\n\n \n\n \nstatic inline int test_cyrix_52div(void)\n{\n\tunsigned int test;\n\n\t__asm__ __volatile__(\n\t     \"sahf\\n\\t\"\t\t \n\t     \"div %b2\\n\\t\"\t \n\t     \"lahf\"\t\t \n\t     : \"=a\" (test)\n\t     : \"0\" (5), \"q\" (2)\n\t     : \"cc\");\n\n\t \n\treturn (unsigned char) (test >> 8) == 0x02;\n}\n\nstatic void cyrix_identify(struct cpuinfo_x86 *c)\n{\n\t \n\tif (c->x86 == 4 && test_cyrix_52div()) {\n\t\tunsigned char dir0, dir1;\n\n\t\tstrcpy(c->x86_vendor_id, \"CyrixInstead\");\n\t\tc->x86_vendor = X86_VENDOR_CYRIX;\n\n\t\t \n\n\t\t \n\n\t\tdo_cyrix_devid(&dir0, &dir1);\n\n\t\tdir0 >>= 4;\n\n\t\t \n\n\t\tif (dir0 == 5 || dir0 == 3) {\n\t\t\tunsigned char ccr3;\n\t\t\tunsigned long flags;\n\t\t\tpr_info(\"Enabling CPUID on Cyrix processor.\\n\");\n\t\t\tlocal_irq_save(flags);\n\t\t\tccr3 = getCx86(CX86_CCR3);\n\t\t\t \n\t\t\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\n\t\t\t \n\t\t\tsetCx86(CX86_CCR4, getCx86(CX86_CCR4) | 0x80);\n\t\t\t \n\t\t\tsetCx86(CX86_CCR3, ccr3);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n}\n\nstatic const struct cpu_dev cyrix_cpu_dev = {\n\t.c_vendor\t= \"Cyrix\",\n\t.c_ident\t= { \"CyrixInstead\" },\n\t.c_early_init\t= early_init_cyrix,\n\t.c_init\t\t= init_cyrix,\n\t.c_identify\t= cyrix_identify,\n\t.c_x86_vendor\t= X86_VENDOR_CYRIX,\n};\n\ncpu_dev_register(cyrix_cpu_dev);\n\nstatic const struct cpu_dev nsc_cpu_dev = {\n\t.c_vendor\t= \"NSC\",\n\t.c_ident\t= { \"Geode by NSC\" },\n\t.c_init\t\t= init_nsc,\n\t.c_x86_vendor\t= X86_VENDOR_NSC,\n};\n\ncpu_dev_register(nsc_cpu_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}