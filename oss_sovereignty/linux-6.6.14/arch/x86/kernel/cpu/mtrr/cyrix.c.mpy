{
  "module_name": "cyrix.c",
  "hash_id": "e89c0ee56d4ebf02b42d81204b426291d90fddc4a847021faa05876bc8f90569",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/cyrix.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n\n#include <asm/processor-cyrix.h>\n#include <asm/processor-flags.h>\n#include <asm/mtrr.h>\n#include <asm/msr.h>\n\n#include \"mtrr.h\"\n\nstatic void\ncyrix_get_arr(unsigned int reg, unsigned long *base,\n\t      unsigned long *size, mtrr_type * type)\n{\n\tunsigned char arr, ccr3, rcr, shift;\n\tunsigned long flags;\n\n\tarr = CX86_ARR_BASE + (reg << 1) + reg;\t \n\n\tlocal_irq_save(flags);\n\n\tccr3 = getCx86(CX86_CCR3);\n\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\t \n\t((unsigned char *)base)[3] = getCx86(arr);\n\t((unsigned char *)base)[2] = getCx86(arr + 1);\n\t((unsigned char *)base)[1] = getCx86(arr + 2);\n\trcr = getCx86(CX86_RCR_BASE + reg);\n\tsetCx86(CX86_CCR3, ccr3);\t\t\t \n\n\tlocal_irq_restore(flags);\n\n\tshift = ((unsigned char *) base)[1] & 0x0f;\n\t*base >>= PAGE_SHIFT;\n\n\t \n\tif (shift)\n\t\t*size = (reg < 7 ? 0x1UL : 0x40UL) << (shift - 1);\n\telse\n\t\t*size = 0;\n\n\t \n\tif (reg < 7) {\n\t\tswitch (rcr) {\n\t\tcase 1:\n\t\t\t*type = MTRR_TYPE_UNCACHABLE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t*type = MTRR_TYPE_WRBACK;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\t*type = MTRR_TYPE_WRCOMB;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tdefault:\n\t\t\t*type = MTRR_TYPE_WRTHROUGH;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (rcr) {\n\t\tcase 0:\n\t\t\t*type = MTRR_TYPE_UNCACHABLE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t*type = MTRR_TYPE_WRCOMB;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\t*type = MTRR_TYPE_WRBACK;\n\t\t\tbreak;\n\t\tcase 25:\n\t\tdefault:\n\t\t\t*type = MTRR_TYPE_WRTHROUGH;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int\ncyrix_get_free_region(unsigned long base, unsigned long size, int replace_reg)\n{\n\tunsigned long lbase, lsize;\n\tmtrr_type ltype;\n\tint i;\n\n\tswitch (replace_reg) {\n\tcase 7:\n\t\tif (size < 0x40)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 6:\n\tcase 5:\n\tcase 4:\n\t\treturn replace_reg;\n\tcase 3:\n\tcase 2:\n\tcase 1:\n\tcase 0:\n\t\treturn replace_reg;\n\t}\n\t \n\tif (size > 0x2000) {\n\t\tcyrix_get_arr(7, &lbase, &lsize, &ltype);\n\t\tif (lsize == 0)\n\t\t\treturn 7;\n\t\t \n\t} else {\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tcyrix_get_arr(i, &lbase, &lsize, &ltype);\n\t\t\tif (lsize == 0)\n\t\t\t\treturn i;\n\t\t}\n\t\t \n\t\tcyrix_get_arr(i, &lbase, &lsize, &ltype);\n\t\tif ((lsize == 0) && (size >= 0x40))\n\t\t\treturn i;\n\t}\n\treturn -ENOSPC;\n}\n\nstatic u32 cr4, ccr3;\n\nstatic void prepare_set(void)\n{\n\tu32 cr0;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_PGE)) {\n\t\tcr4 = __read_cr4();\n\t\t__write_cr4(cr4 & ~X86_CR4_PGE);\n\t}\n\n\t \n\tcr0 = read_cr0() | X86_CR0_CD;\n\twbinvd();\n\twrite_cr0(cr0);\n\twbinvd();\n\n\t \n\tccr3 = getCx86(CX86_CCR3);\n\n\t \n\tsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\n}\n\nstatic void post_set(void)\n{\n\t \n\twbinvd();\n\n\t \n\tsetCx86(CX86_CCR3, ccr3);\n\n\t \n\twrite_cr0(read_cr0() & ~X86_CR0_CD);\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_PGE))\n\t\t__write_cr4(cr4);\n}\n\nstatic void cyrix_set_arr(unsigned int reg, unsigned long base,\n\t\t\t  unsigned long size, mtrr_type type)\n{\n\tunsigned char arr, arr_type, arr_size;\n\n\tarr = CX86_ARR_BASE + (reg << 1) + reg;\t \n\n\t \n\tif (reg >= 7)\n\t\tsize >>= 6;\n\n\tsize &= 0x7fff;\t\t \n\tfor (arr_size = 0; size; arr_size++, size >>= 1)\n\t\t;\n\n\tif (reg < 7) {\n\t\tswitch (type) {\n\t\tcase MTRR_TYPE_UNCACHABLE:\n\t\t\tarr_type = 1;\n\t\t\tbreak;\n\t\tcase MTRR_TYPE_WRCOMB:\n\t\t\tarr_type = 9;\n\t\t\tbreak;\n\t\tcase MTRR_TYPE_WRTHROUGH:\n\t\t\tarr_type = 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarr_type = 8;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\tcase MTRR_TYPE_UNCACHABLE:\n\t\t\tarr_type = 0;\n\t\t\tbreak;\n\t\tcase MTRR_TYPE_WRCOMB:\n\t\t\tarr_type = 8;\n\t\t\tbreak;\n\t\tcase MTRR_TYPE_WRTHROUGH:\n\t\t\tarr_type = 25;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarr_type = 9;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprepare_set();\n\n\tbase <<= PAGE_SHIFT;\n\tsetCx86(arr + 0,  ((unsigned char *)&base)[3]);\n\tsetCx86(arr + 1,  ((unsigned char *)&base)[2]);\n\tsetCx86(arr + 2, (((unsigned char *)&base)[1]) | arr_size);\n\tsetCx86(CX86_RCR_BASE + reg, arr_type);\n\n\tpost_set();\n}\n\nconst struct mtrr_ops cyrix_mtrr_ops = {\n\t.var_regs          = 8,\n\t.set               = cyrix_set_arr,\n\t.get               = cyrix_get_arr,\n\t.get_free_region   = cyrix_get_free_region,\n\t.validate_add_page = generic_validate_add_page,\n\t.have_wrcomb       = positive_have_wrcomb,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}