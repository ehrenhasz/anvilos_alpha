{
  "module_name": "mtrr.c",
  "hash_id": "81f20c4dc3420ec423c2d5aa1e1bfb619fb85993ce5706bb566106f206b79114",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/mtrr.c",
  "human_readable_source": " \n\n#include <linux/types.h>  \n\n#include <linux/stop_machine.h>\n#include <linux/kvm_para.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/cpu.h>\n#include <linux/pci.h>\n#include <linux/smp.h>\n#include <linux/syscore_ops.h>\n#include <linux/rcupdate.h>\n\n#include <asm/cacheinfo.h>\n#include <asm/cpufeature.h>\n#include <asm/e820/api.h>\n#include <asm/mtrr.h>\n#include <asm/msr.h>\n#include <asm/memtype.h>\n\n#include \"mtrr.h\"\n\n \n#define MTRR_TO_PHYS_WC_OFFSET 1000\n\nu32 num_var_ranges;\n\nunsigned int mtrr_usage_table[MTRR_MAX_VAR_RANGES];\nDEFINE_MUTEX(mtrr_mutex);\n\nconst struct mtrr_ops *mtrr_if;\n\n \nstatic int have_wrcomb(void)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_get_class(PCI_CLASS_BRIDGE_HOST << 8, NULL);\n\tif (dev != NULL) {\n\t\t \n\t\tif (dev->vendor == PCI_VENDOR_ID_SERVERWORKS &&\n\t\t    dev->device == PCI_DEVICE_ID_SERVERWORKS_LE &&\n\t\t    dev->revision <= 5) {\n\t\t\tpr_info(\"Serverworks LE rev < 6 detected. Write-combining disabled.\\n\");\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (dev->vendor == PCI_VENDOR_ID_INTEL &&\n\t\t    dev->device == PCI_DEVICE_ID_INTEL_82451NX) {\n\t\t\tpr_info(\"Intel 450NX MMC detected. Write-combining disabled.\\n\");\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\t\tpci_dev_put(dev);\n\t}\n\treturn mtrr_if->have_wrcomb ? mtrr_if->have_wrcomb() : 0;\n}\n\nstatic void __init init_table(void)\n{\n\tint i, max;\n\n\tmax = num_var_ranges;\n\tfor (i = 0; i < max; i++)\n\t\tmtrr_usage_table[i] = 1;\n}\n\nstruct set_mtrr_data {\n\tunsigned long\tsmp_base;\n\tunsigned long\tsmp_size;\n\tunsigned int\tsmp_reg;\n\tmtrr_type\tsmp_type;\n};\n\n \nstatic int mtrr_rendezvous_handler(void *info)\n{\n\tstruct set_mtrr_data *data = info;\n\n\tmtrr_if->set(data->smp_reg, data->smp_base,\n\t\t     data->smp_size, data->smp_type);\n\treturn 0;\n}\n\nstatic inline int types_compatible(mtrr_type type1, mtrr_type type2)\n{\n\treturn type1 == MTRR_TYPE_UNCACHABLE ||\n\t       type2 == MTRR_TYPE_UNCACHABLE ||\n\t       (type1 == MTRR_TYPE_WRTHROUGH && type2 == MTRR_TYPE_WRBACK) ||\n\t       (type1 == MTRR_TYPE_WRBACK && type2 == MTRR_TYPE_WRTHROUGH);\n}\n\n \nstatic void set_mtrr(unsigned int reg, unsigned long base, unsigned long size,\n\t\t     mtrr_type type)\n{\n\tstruct set_mtrr_data data = { .smp_reg = reg,\n\t\t\t\t      .smp_base = base,\n\t\t\t\t      .smp_size = size,\n\t\t\t\t      .smp_type = type\n\t\t\t\t    };\n\n\tstop_machine_cpuslocked(mtrr_rendezvous_handler, &data, cpu_online_mask);\n\n\tgeneric_rebuild_map();\n}\n\n \nint mtrr_add_page(unsigned long base, unsigned long size,\n\t\t  unsigned int type, bool increment)\n{\n\tunsigned long lbase, lsize;\n\tint i, replace, error;\n\tmtrr_type ltype;\n\n\tif (!mtrr_enabled())\n\t\treturn -ENXIO;\n\n\terror = mtrr_if->validate_add_page(base, size, type);\n\tif (error)\n\t\treturn error;\n\n\tif (type >= MTRR_NUM_TYPES) {\n\t\tpr_warn(\"type: %u invalid\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((type == MTRR_TYPE_WRCOMB) && !have_wrcomb()) {\n\t\tpr_warn(\"your processor doesn't support write-combining\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (!size) {\n\t\tpr_warn(\"zero sized request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((base | (base + size - 1)) >>\n\t    (boot_cpu_data.x86_phys_bits - PAGE_SHIFT)) {\n\t\tpr_warn(\"base or size exceeds the MTRR width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = -EINVAL;\n\treplace = -1;\n\n\t \n\tcpus_read_lock();\n\n\t \n\tmutex_lock(&mtrr_mutex);\n\tfor (i = 0; i < num_var_ranges; ++i) {\n\t\tmtrr_if->get(i, &lbase, &lsize, &ltype);\n\t\tif (!lsize || base > lbase + lsize - 1 ||\n\t\t    base + size - 1 < lbase)\n\t\t\tcontinue;\n\t\t \n\t\tif (base < lbase || base + size - 1 > lbase + lsize - 1) {\n\t\t\tif (base <= lbase &&\n\t\t\t    base + size - 1 >= lbase + lsize - 1) {\n\t\t\t\t \n\t\t\t\tif (type == ltype) {\n\t\t\t\t\treplace = replace == -1 ? i : -2;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (types_compatible(type, ltype))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_warn(\"0x%lx000,0x%lx000 overlaps existing 0x%lx000,0x%lx000\\n\", base, size, lbase,\n\t\t\t\tlsize);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (ltype != type) {\n\t\t\tif (types_compatible(type, ltype))\n\t\t\t\tcontinue;\n\t\t\tpr_warn(\"type mismatch for %lx000,%lx000 old: %s new: %s\\n\",\n\t\t\t\tbase, size, mtrr_attrib_to_str(ltype),\n\t\t\t\tmtrr_attrib_to_str(type));\n\t\t\tgoto out;\n\t\t}\n\t\tif (increment)\n\t\t\t++mtrr_usage_table[i];\n\t\terror = i;\n\t\tgoto out;\n\t}\n\t \n\ti = mtrr_if->get_free_region(base, size, replace);\n\tif (i >= 0) {\n\t\tset_mtrr(i, base, size, type);\n\t\tif (likely(replace < 0)) {\n\t\t\tmtrr_usage_table[i] = 1;\n\t\t} else {\n\t\t\tmtrr_usage_table[i] = mtrr_usage_table[replace];\n\t\t\tif (increment)\n\t\t\t\tmtrr_usage_table[i]++;\n\t\t\tif (unlikely(replace != i)) {\n\t\t\t\tset_mtrr(replace, 0, 0, 0);\n\t\t\t\tmtrr_usage_table[replace] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpr_info(\"no more MTRRs available\\n\");\n\t}\n\terror = i;\n out:\n\tmutex_unlock(&mtrr_mutex);\n\tcpus_read_unlock();\n\treturn error;\n}\n\nstatic int mtrr_check(unsigned long base, unsigned long size)\n{\n\tif ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1))) {\n\t\tpr_warn(\"size and base must be multiples of 4 kiB\\n\");\n\t\tDprintk(\"size: 0x%lx  base: 0x%lx\\n\", size, base);\n\t\tdump_stack();\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint mtrr_add(unsigned long base, unsigned long size, unsigned int type,\n\t     bool increment)\n{\n\tif (!mtrr_enabled())\n\t\treturn -ENODEV;\n\tif (mtrr_check(base, size))\n\t\treturn -EINVAL;\n\treturn mtrr_add_page(base >> PAGE_SHIFT, size >> PAGE_SHIFT, type,\n\t\t\t     increment);\n}\n\n \nint mtrr_del_page(int reg, unsigned long base, unsigned long size)\n{\n\tint i, max;\n\tmtrr_type ltype;\n\tunsigned long lbase, lsize;\n\tint error = -EINVAL;\n\n\tif (!mtrr_enabled())\n\t\treturn -ENODEV;\n\n\tmax = num_var_ranges;\n\t \n\tcpus_read_lock();\n\tmutex_lock(&mtrr_mutex);\n\tif (reg < 0) {\n\t\t \n\t\tfor (i = 0; i < max; ++i) {\n\t\t\tmtrr_if->get(i, &lbase, &lsize, &ltype);\n\t\t\tif (lbase == base && lsize == size) {\n\t\t\t\treg = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reg < 0) {\n\t\t\tDprintk(\"no MTRR for %lx000,%lx000 found\\n\", base, size);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (reg >= max) {\n\t\tpr_warn(\"register: %d too big\\n\", reg);\n\t\tgoto out;\n\t}\n\tmtrr_if->get(reg, &lbase, &lsize, &ltype);\n\tif (lsize < 1) {\n\t\tpr_warn(\"MTRR %d not used\\n\", reg);\n\t\tgoto out;\n\t}\n\tif (mtrr_usage_table[reg] < 1) {\n\t\tpr_warn(\"reg: %d has count=0\\n\", reg);\n\t\tgoto out;\n\t}\n\tif (--mtrr_usage_table[reg] < 1)\n\t\tset_mtrr(reg, 0, 0, 0);\n\terror = reg;\n out:\n\tmutex_unlock(&mtrr_mutex);\n\tcpus_read_unlock();\n\treturn error;\n}\n\n \nint mtrr_del(int reg, unsigned long base, unsigned long size)\n{\n\tif (!mtrr_enabled())\n\t\treturn -ENODEV;\n\tif (mtrr_check(base, size))\n\t\treturn -EINVAL;\n\treturn mtrr_del_page(reg, base >> PAGE_SHIFT, size >> PAGE_SHIFT);\n}\n\n \nint arch_phys_wc_add(unsigned long base, unsigned long size)\n{\n\tint ret;\n\n\tif (pat_enabled() || !mtrr_enabled())\n\t\treturn 0;   \n\n\tret = mtrr_add(base, size, MTRR_TYPE_WRCOMB, true);\n\tif (ret < 0) {\n\t\tpr_warn(\"Failed to add WC MTRR for [%p-%p]; performance may suffer.\",\n\t\t\t(void *)base, (void *)(base + size - 1));\n\t\treturn ret;\n\t}\n\treturn ret + MTRR_TO_PHYS_WC_OFFSET;\n}\nEXPORT_SYMBOL(arch_phys_wc_add);\n\n \nvoid arch_phys_wc_del(int handle)\n{\n\tif (handle >= 1) {\n\t\tWARN_ON(handle < MTRR_TO_PHYS_WC_OFFSET);\n\t\tmtrr_del(handle - MTRR_TO_PHYS_WC_OFFSET, 0, 0);\n\t}\n}\nEXPORT_SYMBOL(arch_phys_wc_del);\n\n \nint arch_phys_wc_index(int handle)\n{\n\tif (handle < MTRR_TO_PHYS_WC_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn handle - MTRR_TO_PHYS_WC_OFFSET;\n}\nEXPORT_SYMBOL_GPL(arch_phys_wc_index);\n\nint __initdata changed_by_mtrr_cleanup;\n\n \nvoid __init mtrr_bp_init(void)\n{\n\tbool generic_mtrrs = cpu_feature_enabled(X86_FEATURE_MTRR);\n\tconst char *why = \"(not available)\";\n\tunsigned long config, dummy;\n\n\tphys_hi_rsvd = GENMASK(31, boot_cpu_data.x86_phys_bits - 32);\n\n\tif (!generic_mtrrs && mtrr_state.enabled) {\n\t\t \n\t\tinit_table();\n\t\tmtrr_build_map();\n\t\tpr_info(\"MTRRs set to read-only\\n\");\n\n\t\treturn;\n\t}\n\n\tif (generic_mtrrs)\n\t\tmtrr_if = &generic_mtrr_ops;\n\telse\n\t\tmtrr_set_if();\n\n\tif (mtrr_enabled()) {\n\t\t \n\t\tif (mtrr_if == &generic_mtrr_ops)\n\t\t\trdmsr(MSR_MTRRcap, config, dummy);\n\t\telse\n\t\t\tconfig = mtrr_if->var_regs;\n\t\tnum_var_ranges = config & MTRR_CAP_VCNT;\n\n\t\tinit_table();\n\t\tif (mtrr_if == &generic_mtrr_ops) {\n\t\t\t \n\t\t\tif (get_mtrr_state()) {\n\t\t\t\tmemory_caching_control |= CACHE_MTRR;\n\t\t\t\tchanged_by_mtrr_cleanup = mtrr_cleanup();\n\t\t\t\tmtrr_build_map();\n\t\t\t} else {\n\t\t\t\tmtrr_if = NULL;\n\t\t\t\twhy = \"by BIOS\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mtrr_enabled())\n\t\tpr_info(\"MTRRs disabled %s\\n\", why);\n}\n\n \nvoid mtrr_save_state(void)\n{\n\tint first_cpu;\n\n\tif (!mtrr_enabled())\n\t\treturn;\n\n\tfirst_cpu = cpumask_first(cpu_online_mask);\n\tsmp_call_function_single(first_cpu, mtrr_save_fixed_ranges, NULL, 1);\n}\n\nstatic int __init mtrr_init_finalize(void)\n{\n\t \n\tmtrr_copy_map();\n\n\tif (!mtrr_enabled())\n\t\treturn 0;\n\n\tif (memory_caching_control & CACHE_MTRR) {\n\t\tif (!changed_by_mtrr_cleanup)\n\t\t\tmtrr_state_warn();\n\t\treturn 0;\n\t}\n\n\tmtrr_register_syscore();\n\n\treturn 0;\n}\nsubsys_initcall(mtrr_init_finalize);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}