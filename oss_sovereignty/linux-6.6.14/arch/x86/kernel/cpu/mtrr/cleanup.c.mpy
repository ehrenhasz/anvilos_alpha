{
  "module_name": "cleanup.c",
  "hash_id": "387ed956918be67ffca225234d205bee30b32249414275c1102ba3a6d5b2eb11",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/cleanup.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/kvm_para.h>\n#include <linux/range.h>\n\n#include <asm/processor.h>\n#include <asm/e820/api.h>\n#include <asm/mtrr.h>\n#include <asm/msr.h>\n\n#include \"mtrr.h\"\n\nstruct var_mtrr_range_state {\n\tunsigned long\tbase_pfn;\n\tunsigned long\tsize_pfn;\n\tmtrr_type\ttype;\n};\n\nstruct var_mtrr_state {\n\tunsigned long\trange_startk;\n\tunsigned long\trange_sizek;\n\tunsigned long\tchunk_sizek;\n\tunsigned long\tgran_sizek;\n\tunsigned int\treg;\n};\n\n \n#define RANGE_NUM\t\t\t\t256\n\nstatic struct range __initdata\t\trange[RANGE_NUM];\nstatic int __initdata\t\t\t\tnr_range;\n\nstatic struct var_mtrr_range_state __initdata\trange_state[RANGE_NUM];\n\n#define BIOS_BUG_MSG \\\n\t\"WARNING: BIOS bug: VAR MTRR %d contains strange UC entry under 1M, check with your system vendor!\\n\"\n\nstatic int __init\nx86_get_mtrr_mem_range(struct range *range, int nr_range,\n\t\t       unsigned long extra_remove_base,\n\t\t       unsigned long extra_remove_size)\n{\n\tunsigned long base, size;\n\tmtrr_type type;\n\tint i;\n\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tif (type != MTRR_TYPE_WRBACK)\n\t\t\tcontinue;\n\t\tbase = range_state[i].base_pfn;\n\t\tsize = range_state[i].size_pfn;\n\t\tnr_range = add_range_with_merge(range, RANGE_NUM, nr_range,\n\t\t\t\t\t\tbase, base + size);\n\t}\n\n\tDprintk(\"After WB checking\\n\");\n\tfor (i = 0; i < nr_range; i++)\n\t\tDprintk(\"MTRR MAP PFN: %016llx - %016llx\\n\",\n\t\t\t range[i].start, range[i].end);\n\n\t \n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tif (type != MTRR_TYPE_UNCACHABLE &&\n\t\t    type != MTRR_TYPE_WRPROT)\n\t\t\tcontinue;\n\t\tsize = range_state[i].size_pfn;\n\t\tif (!size)\n\t\t\tcontinue;\n\t\tbase = range_state[i].base_pfn;\n\t\tif (base < (1<<(20-PAGE_SHIFT)) && mtrr_state.have_fixed &&\n\t\t    (mtrr_state.enabled & MTRR_STATE_MTRR_ENABLED) &&\n\t\t    (mtrr_state.enabled & MTRR_STATE_MTRR_FIXED_ENABLED)) {\n\t\t\t \n\t\t\tpr_warn(BIOS_BUG_MSG, i);\n\t\t\tif (base + size <= (1<<(20-PAGE_SHIFT)))\n\t\t\t\tcontinue;\n\t\t\tsize -= (1<<(20-PAGE_SHIFT)) - base;\n\t\t\tbase = 1<<(20-PAGE_SHIFT);\n\t\t}\n\t\tsubtract_range(range, RANGE_NUM, base, base + size);\n\t}\n\tif (extra_remove_size)\n\t\tsubtract_range(range, RANGE_NUM, extra_remove_base,\n\t\t\t\t extra_remove_base + extra_remove_size);\n\n\tDprintk(\"After UC checking\\n\");\n\tfor (i = 0; i < RANGE_NUM; i++) {\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tDprintk(\"MTRR MAP PFN: %016llx - %016llx\\n\",\n\t\t\t range[i].start, range[i].end);\n\t}\n\n\t \n\tnr_range = clean_sort_range(range, RANGE_NUM);\n\n\tDprintk(\"After sorting\\n\");\n\tfor (i = 0; i < nr_range; i++)\n\t\tDprintk(\"MTRR MAP PFN: %016llx - %016llx\\n\",\n\t\t\trange[i].start, range[i].end);\n\n\treturn nr_range;\n}\n\n#ifdef CONFIG_MTRR_SANITIZER\n\nstatic unsigned long __init sum_ranges(struct range *range, int nr_range)\n{\n\tunsigned long sum = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_range; i++)\n\t\tsum += range[i].end - range[i].start;\n\n\treturn sum;\n}\n\nstatic int enable_mtrr_cleanup __initdata =\n\tCONFIG_MTRR_SANITIZER_ENABLE_DEFAULT;\n\nstatic int __init disable_mtrr_cleanup_setup(char *str)\n{\n\tenable_mtrr_cleanup = 0;\n\treturn 0;\n}\nearly_param(\"disable_mtrr_cleanup\", disable_mtrr_cleanup_setup);\n\nstatic int __init enable_mtrr_cleanup_setup(char *str)\n{\n\tenable_mtrr_cleanup = 1;\n\treturn 0;\n}\nearly_param(\"enable_mtrr_cleanup\", enable_mtrr_cleanup_setup);\n\nstatic void __init\nset_var_mtrr(unsigned int reg, unsigned long basek, unsigned long sizek,\n\t     unsigned char type)\n{\n\tu32 base_lo, base_hi, mask_lo, mask_hi;\n\tu64 base, mask;\n\n\tif (!sizek) {\n\t\tfill_mtrr_var_range(reg, 0, 0, 0, 0);\n\t\treturn;\n\t}\n\n\tmask = (1ULL << boot_cpu_data.x86_phys_bits) - 1;\n\tmask &= ~((((u64)sizek) << 10) - 1);\n\n\tbase = ((u64)basek) << 10;\n\n\tbase |= type;\n\tmask |= 0x800;\n\n\tbase_lo = base & ((1ULL<<32) - 1);\n\tbase_hi = base >> 32;\n\n\tmask_lo = mask & ((1ULL<<32) - 1);\n\tmask_hi = mask >> 32;\n\n\tfill_mtrr_var_range(reg, base_lo, base_hi, mask_lo, mask_hi);\n}\n\nstatic void __init\nsave_var_mtrr(unsigned int reg, unsigned long basek, unsigned long sizek,\n\t      unsigned char type)\n{\n\trange_state[reg].base_pfn = basek >> (PAGE_SHIFT - 10);\n\trange_state[reg].size_pfn = sizek >> (PAGE_SHIFT - 10);\n\trange_state[reg].type = type;\n}\n\nstatic void __init set_var_mtrr_all(void)\n{\n\tunsigned long basek, sizek;\n\tunsigned char type;\n\tunsigned int reg;\n\n\tfor (reg = 0; reg < num_var_ranges; reg++) {\n\t\tbasek = range_state[reg].base_pfn << (PAGE_SHIFT - 10);\n\t\tsizek = range_state[reg].size_pfn << (PAGE_SHIFT - 10);\n\t\ttype = range_state[reg].type;\n\n\t\tset_var_mtrr(reg, basek, sizek, type);\n\t}\n}\n\nstatic unsigned long to_size_factor(unsigned long sizek, char *factorp)\n{\n\tunsigned long base = sizek;\n\tchar factor;\n\n\tif (base & ((1<<10) - 1)) {\n\t\t \n\t\tfactor = 'K';\n\t} else if (base & ((1<<20) - 1)) {\n\t\tfactor = 'M';\n\t\tbase >>= 10;\n\t} else {\n\t\tfactor = 'G';\n\t\tbase >>= 20;\n\t}\n\n\t*factorp = factor;\n\n\treturn base;\n}\n\nstatic unsigned int __init\nrange_to_mtrr(unsigned int reg, unsigned long range_startk,\n\t      unsigned long range_sizek, unsigned char type)\n{\n\tif (!range_sizek || (reg >= num_var_ranges))\n\t\treturn reg;\n\n\twhile (range_sizek) {\n\t\tunsigned long max_align, align;\n\t\tunsigned long sizek;\n\n\t\t \n\t\tif (range_startk)\n\t\t\tmax_align = __ffs(range_startk);\n\t\telse\n\t\t\tmax_align = BITS_PER_LONG - 1;\n\n\t\talign = __fls(range_sizek);\n\t\tif (align > max_align)\n\t\t\talign = max_align;\n\n\t\tsizek = 1UL << align;\n\t\tif (mtrr_debug) {\n\t\t\tchar start_factor = 'K', size_factor = 'K';\n\t\t\tunsigned long start_base, size_base;\n\n\t\t\tstart_base = to_size_factor(range_startk, &start_factor);\n\t\t\tsize_base = to_size_factor(sizek, &size_factor);\n\n\t\t\tDprintk(\"Setting variable MTRR %d, \"\n\t\t\t\t\"base: %ld%cB, range: %ld%cB, type %s\\n\",\n\t\t\t\treg, start_base, start_factor,\n\t\t\t\tsize_base, size_factor,\n\t\t\t\t(type == MTRR_TYPE_UNCACHABLE) ? \"UC\" :\n\t\t\t\t   ((type == MTRR_TYPE_WRBACK) ? \"WB\" : \"Other\")\n\t\t\t\t);\n\t\t}\n\t\tsave_var_mtrr(reg++, range_startk, sizek, type);\n\t\trange_startk += sizek;\n\t\trange_sizek -= sizek;\n\t\tif (reg >= num_var_ranges)\n\t\t\tbreak;\n\t}\n\treturn reg;\n}\n\nstatic unsigned __init\nrange_to_mtrr_with_hole(struct var_mtrr_state *state, unsigned long basek,\n\t\t\tunsigned long sizek)\n{\n\tunsigned long hole_basek, hole_sizek;\n\tunsigned long second_sizek;\n\tunsigned long range0_basek, range0_sizek;\n\tunsigned long range_basek, range_sizek;\n\tunsigned long chunk_sizek;\n\tunsigned long gran_sizek;\n\n\thole_basek = 0;\n\thole_sizek = 0;\n\tsecond_sizek = 0;\n\tchunk_sizek = state->chunk_sizek;\n\tgran_sizek = state->gran_sizek;\n\n\t \n\trange_basek = ALIGN(state->range_startk, gran_sizek);\n\tif ((range_basek > basek) && basek)\n\t\treturn second_sizek;\n\n\tstate->range_sizek -= (range_basek - state->range_startk);\n\trange_sizek = ALIGN(state->range_sizek, gran_sizek);\n\n\twhile (range_sizek > state->range_sizek) {\n\t\trange_sizek -= gran_sizek;\n\t\tif (!range_sizek)\n\t\t\treturn 0;\n\t}\n\tstate->range_sizek = range_sizek;\n\n\t \n\trange0_basek = state->range_startk;\n\trange0_sizek = ALIGN(state->range_sizek, chunk_sizek);\n\n\t \n\tif (range0_sizek == state->range_sizek) {\n\t\tDprintk(\"rangeX: %016lx - %016lx\\n\",\n\t\t\trange0_basek<<10,\n\t\t\t(range0_basek + state->range_sizek)<<10);\n\t\tstate->reg = range_to_mtrr(state->reg, range0_basek,\n\t\t\t\tstate->range_sizek, MTRR_TYPE_WRBACK);\n\t\treturn 0;\n\t}\n\n\t \n\tif (sizek) {\n\t\twhile (range0_basek + range0_sizek > (basek + sizek)) {\n\t\t\tif (range0_sizek >= chunk_sizek)\n\t\t\t\trange0_sizek -= chunk_sizek;\n\t\t\telse\n\t\t\t\trange0_sizek = 0;\n\n\t\t\tif (!range0_sizek)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nsecond_try:\n\trange_basek = range0_basek + range0_sizek;\n\n\t \n\tif (range_basek > basek && range_basek <= (basek + sizek))\n\t\tsecond_sizek = range_basek - basek;\n\n\tif (range0_sizek > state->range_sizek) {\n\n\t\t \n\t\thole_sizek = range0_sizek - state->range_sizek - second_sizek;\n\n\t\t \n\t\tif (hole_sizek >= (range0_sizek >> 1) &&\n\t\t    range0_sizek >= chunk_sizek) {\n\t\t\trange0_sizek -= chunk_sizek;\n\t\t\tsecond_sizek = 0;\n\t\t\thole_sizek = 0;\n\n\t\t\tgoto second_try;\n\t\t}\n\t}\n\n\tif (range0_sizek) {\n\t\tDprintk(\"range0: %016lx - %016lx\\n\",\n\t\t\trange0_basek<<10,\n\t\t\t(range0_basek + range0_sizek)<<10);\n\t\tstate->reg = range_to_mtrr(state->reg, range0_basek,\n\t\t\t\trange0_sizek, MTRR_TYPE_WRBACK);\n\t}\n\n\tif (range0_sizek < state->range_sizek) {\n\t\t \n\t\trange_sizek = state->range_sizek - range0_sizek;\n\n\t\tDprintk(\"range: %016lx - %016lx\\n\",\n\t\t\t range_basek<<10,\n\t\t\t (range_basek + range_sizek)<<10);\n\n\t\tstate->reg = range_to_mtrr(state->reg, range_basek,\n\t\t\t\t range_sizek, MTRR_TYPE_WRBACK);\n\t}\n\n\tif (hole_sizek) {\n\t\thole_basek = range_basek - hole_sizek - second_sizek;\n\t\tDprintk(\"hole: %016lx - %016lx\\n\",\n\t\t\t hole_basek<<10,\n\t\t\t (hole_basek + hole_sizek)<<10);\n\t\tstate->reg = range_to_mtrr(state->reg, hole_basek,\n\t\t\t\t hole_sizek, MTRR_TYPE_UNCACHABLE);\n\t}\n\n\treturn second_sizek;\n}\n\nstatic void __init\nset_var_mtrr_range(struct var_mtrr_state *state, unsigned long base_pfn,\n\t\t   unsigned long size_pfn)\n{\n\tunsigned long basek, sizek;\n\tunsigned long second_sizek = 0;\n\n\tif (state->reg >= num_var_ranges)\n\t\treturn;\n\n\tbasek = base_pfn << (PAGE_SHIFT - 10);\n\tsizek = size_pfn << (PAGE_SHIFT - 10);\n\n\t \n\tif ((basek <= 1024) ||\n\t    (state->range_startk + state->range_sizek == basek)) {\n\t\tunsigned long endk = basek + sizek;\n\t\tstate->range_sizek = endk - state->range_startk;\n\t\treturn;\n\t}\n\t \n\tif (state->range_sizek != 0)\n\t\tsecond_sizek = range_to_mtrr_with_hole(state, basek, sizek);\n\n\t \n\tstate->range_startk = basek + second_sizek;\n\tstate->range_sizek  = sizek - second_sizek;\n}\n\n \nstatic u64 mtrr_chunk_size __initdata = (256ULL<<20);\n\nstatic int __init parse_mtrr_chunk_size_opt(char *p)\n{\n\tif (!p)\n\t\treturn -EINVAL;\n\tmtrr_chunk_size = memparse(p, &p);\n\treturn 0;\n}\nearly_param(\"mtrr_chunk_size\", parse_mtrr_chunk_size_opt);\n\n \nstatic u64 mtrr_gran_size __initdata;\n\nstatic int __init parse_mtrr_gran_size_opt(char *p)\n{\n\tif (!p)\n\t\treturn -EINVAL;\n\tmtrr_gran_size = memparse(p, &p);\n\treturn 0;\n}\nearly_param(\"mtrr_gran_size\", parse_mtrr_gran_size_opt);\n\nstatic unsigned long nr_mtrr_spare_reg __initdata =\n\t\t\t\t CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT;\n\nstatic int __init parse_mtrr_spare_reg(char *arg)\n{\n\tif (arg)\n\t\tnr_mtrr_spare_reg = simple_strtoul(arg, NULL, 0);\n\treturn 0;\n}\nearly_param(\"mtrr_spare_reg_nr\", parse_mtrr_spare_reg);\n\nstatic int __init\nx86_setup_var_mtrrs(struct range *range, int nr_range,\n\t\t    u64 chunk_size, u64 gran_size)\n{\n\tstruct var_mtrr_state var_state;\n\tint num_reg;\n\tint i;\n\n\tvar_state.range_startk\t= 0;\n\tvar_state.range_sizek\t= 0;\n\tvar_state.reg\t\t= 0;\n\tvar_state.chunk_sizek\t= chunk_size >> 10;\n\tvar_state.gran_sizek\t= gran_size >> 10;\n\n\tmemset(range_state, 0, sizeof(range_state));\n\n\t \n\tfor (i = 0; i < nr_range; i++) {\n\t\tset_var_mtrr_range(&var_state, range[i].start,\n\t\t\t\t   range[i].end - range[i].start);\n\t}\n\n\t \n\tif (var_state.range_sizek != 0)\n\t\trange_to_mtrr_with_hole(&var_state, 0, 0);\n\n\tnum_reg = var_state.reg;\n\t \n\twhile (var_state.reg < num_var_ranges) {\n\t\tsave_var_mtrr(var_state.reg, 0, 0, 0);\n\t\tvar_state.reg++;\n\t}\n\n\treturn num_reg;\n}\n\nstruct mtrr_cleanup_result {\n\tunsigned long\tgran_sizek;\n\tunsigned long\tchunk_sizek;\n\tunsigned long\tlose_cover_sizek;\n\tunsigned int\tnum_reg;\n\tint\t\tbad;\n};\n\n \n#define NUM_RESULT\t136\n#define PSHIFT\t\t(PAGE_SHIFT - 10)\n\nstatic struct mtrr_cleanup_result __initdata result[NUM_RESULT];\nstatic unsigned long __initdata min_loss_pfn[RANGE_NUM];\n\nstatic void __init print_out_mtrr_range_state(void)\n{\n\tchar start_factor = 'K', size_factor = 'K';\n\tunsigned long start_base, size_base;\n\tmtrr_type type;\n\tint i;\n\n\tfor (i = 0; i < num_var_ranges; i++) {\n\n\t\tsize_base = range_state[i].size_pfn << (PAGE_SHIFT - 10);\n\t\tif (!size_base)\n\t\t\tcontinue;\n\n\t\tsize_base = to_size_factor(size_base, &size_factor);\n\t\tstart_base = range_state[i].base_pfn << (PAGE_SHIFT - 10);\n\t\tstart_base = to_size_factor(start_base, &start_factor);\n\t\ttype = range_state[i].type;\n\n\t\tDprintk(\"reg %d, base: %ld%cB, range: %ld%cB, type %s\\n\",\n\t\t\ti, start_base, start_factor,\n\t\t\tsize_base, size_factor,\n\t\t\t(type == MTRR_TYPE_UNCACHABLE) ? \"UC\" :\n\t\t\t    ((type == MTRR_TYPE_WRPROT) ? \"WP\" :\n\t\t\t     ((type == MTRR_TYPE_WRBACK) ? \"WB\" : \"Other\"))\n\t\t\t);\n\t}\n}\n\nstatic int __init mtrr_need_cleanup(void)\n{\n\tint i;\n\tmtrr_type type;\n\tunsigned long size;\n\t \n\tint num[MTRR_NUM_TYPES + 1];\n\n\t \n\tmemset(num, 0, sizeof(num));\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tsize = range_state[i].size_pfn;\n\t\tif (type >= MTRR_NUM_TYPES)\n\t\t\tcontinue;\n\t\tif (!size)\n\t\t\ttype = MTRR_NUM_TYPES;\n\t\tnum[type]++;\n\t}\n\n\t \n\tif (!num[MTRR_TYPE_UNCACHABLE])\n\t\treturn 0;\n\n\t \n\tif (num[MTRR_TYPE_WRBACK] + num[MTRR_TYPE_UNCACHABLE] !=\n\t    num_var_ranges - num[MTRR_NUM_TYPES])\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic unsigned long __initdata range_sums;\n\nstatic void __init\nmtrr_calc_range_state(u64 chunk_size, u64 gran_size,\n\t\t      unsigned long x_remove_base,\n\t\t      unsigned long x_remove_size, int i)\n{\n\t \n\tstatic struct range range_new[RANGE_NUM] __initdata;\n\tunsigned long range_sums_new;\n\tint nr_range_new;\n\tint num_reg;\n\n\t \n\tnum_reg = x86_setup_var_mtrrs(range, nr_range, chunk_size, gran_size);\n\n\t \n\tmemset(range_new, 0, sizeof(range_new));\n\tnr_range_new = x86_get_mtrr_mem_range(range_new, 0,\n\t\t\t\tx_remove_base, x_remove_size);\n\trange_sums_new = sum_ranges(range_new, nr_range_new);\n\n\tresult[i].chunk_sizek = chunk_size >> 10;\n\tresult[i].gran_sizek = gran_size >> 10;\n\tresult[i].num_reg = num_reg;\n\n\tif (range_sums < range_sums_new) {\n\t\tresult[i].lose_cover_sizek = (range_sums_new - range_sums) << PSHIFT;\n\t\tresult[i].bad = 1;\n\t} else {\n\t\tresult[i].lose_cover_sizek = (range_sums - range_sums_new) << PSHIFT;\n\t}\n\n\t \n\tif (!result[i].bad && !result[i].lose_cover_sizek) {\n\t\tif (nr_range_new != nr_range || memcmp(range, range_new, sizeof(range)))\n\t\t\tresult[i].bad = 1;\n\t}\n\n\tif (!result[i].bad && (range_sums - range_sums_new < min_loss_pfn[num_reg]))\n\t\tmin_loss_pfn[num_reg] = range_sums - range_sums_new;\n}\n\nstatic void __init mtrr_print_out_one_result(int i)\n{\n\tunsigned long gran_base, chunk_base, lose_base;\n\tchar gran_factor, chunk_factor, lose_factor;\n\n\tgran_base = to_size_factor(result[i].gran_sizek, &gran_factor);\n\tchunk_base = to_size_factor(result[i].chunk_sizek, &chunk_factor);\n\tlose_base = to_size_factor(result[i].lose_cover_sizek, &lose_factor);\n\n\tpr_info(\"%sgran_size: %ld%c \\tchunk_size: %ld%c \\t\",\n\t\tresult[i].bad ? \"*BAD*\" : \" \",\n\t\tgran_base, gran_factor, chunk_base, chunk_factor);\n\tpr_cont(\"num_reg: %d  \\tlose cover RAM: %s%ld%c\\n\",\n\t\tresult[i].num_reg, result[i].bad ? \"-\" : \"\",\n\t\tlose_base, lose_factor);\n}\n\nstatic int __init mtrr_search_optimal_index(void)\n{\n\tint num_reg_good;\n\tint index_good;\n\tint i;\n\n\tif (nr_mtrr_spare_reg >= num_var_ranges)\n\t\tnr_mtrr_spare_reg = num_var_ranges - 1;\n\n\tnum_reg_good = -1;\n\tfor (i = num_var_ranges - nr_mtrr_spare_reg; i > 0; i--) {\n\t\tif (!min_loss_pfn[i])\n\t\t\tnum_reg_good = i;\n\t}\n\n\tindex_good = -1;\n\tif (num_reg_good != -1) {\n\t\tfor (i = 0; i < NUM_RESULT; i++) {\n\t\t\tif (!result[i].bad &&\n\t\t\t    result[i].num_reg == num_reg_good &&\n\t\t\t    !result[i].lose_cover_sizek) {\n\t\t\t\tindex_good = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn index_good;\n}\n\nint __init mtrr_cleanup(void)\n{\n\tunsigned long x_remove_base, x_remove_size;\n\tunsigned long base, size, def, dummy;\n\tu64 chunk_size, gran_size;\n\tmtrr_type type;\n\tint index_good;\n\tint i;\n\n\tif (!mtrr_enabled())\n\t\treturn 0;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_MTRR) || enable_mtrr_cleanup < 1)\n\t\treturn 0;\n\n\trdmsr(MSR_MTRRdefType, def, dummy);\n\tdef &= 0xff;\n\tif (def != MTRR_TYPE_UNCACHABLE)\n\t\treturn 0;\n\n\t \n\tmemset(range_state, 0, sizeof(range_state));\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\tmtrr_if->get(i, &base, &size, &type);\n\t\trange_state[i].base_pfn = base;\n\t\trange_state[i].size_pfn = size;\n\t\trange_state[i].type = type;\n\t}\n\n\t \n\tif (!mtrr_need_cleanup())\n\t\treturn 0;\n\n\t \n\tDprintk(\"original variable MTRRs\\n\");\n\tprint_out_mtrr_range_state();\n\n\tmemset(range, 0, sizeof(range));\n\tx_remove_size = 0;\n\tx_remove_base = 1 << (32 - PAGE_SHIFT);\n\tif (mtrr_tom2)\n\t\tx_remove_size = (mtrr_tom2 >> PAGE_SHIFT) - x_remove_base;\n\n\t \n\tnr_range = add_range_with_merge(range, RANGE_NUM, 0, 0,\n\t\t\t\t\t1ULL<<(20 - PAGE_SHIFT));\n\t \n\tnr_range = x86_get_mtrr_mem_range(range, nr_range,\n\t\t\t\t\t  x_remove_base, x_remove_size);\n\n\trange_sums = sum_ranges(range, nr_range);\n\tpr_info(\"total RAM covered: %ldM\\n\",\n\t       range_sums >> (20 - PAGE_SHIFT));\n\n\tif (mtrr_chunk_size && mtrr_gran_size) {\n\t\ti = 0;\n\t\tmtrr_calc_range_state(mtrr_chunk_size, mtrr_gran_size,\n\t\t\t\t      x_remove_base, x_remove_size, i);\n\n\t\tmtrr_print_out_one_result(i);\n\n\t\tif (!result[i].bad) {\n\t\t\tset_var_mtrr_all();\n\t\t\tDprintk(\"New variable MTRRs\\n\");\n\t\t\tprint_out_mtrr_range_state();\n\t\t\treturn 1;\n\t\t}\n\t\tpr_info(\"invalid mtrr_gran_size or mtrr_chunk_size, will find optimal one\\n\");\n\t}\n\n\ti = 0;\n\tmemset(min_loss_pfn, 0xff, sizeof(min_loss_pfn));\n\tmemset(result, 0, sizeof(result));\n\tfor (gran_size = (1ULL<<16); gran_size < (1ULL<<32); gran_size <<= 1) {\n\n\t\tfor (chunk_size = gran_size; chunk_size < (1ULL<<32);\n\t\t     chunk_size <<= 1) {\n\n\t\t\tif (i >= NUM_RESULT)\n\t\t\t\tcontinue;\n\n\t\t\tmtrr_calc_range_state(chunk_size, gran_size,\n\t\t\t\t      x_remove_base, x_remove_size, i);\n\t\t\tif (mtrr_debug) {\n\t\t\t\tmtrr_print_out_one_result(i);\n\t\t\t\tpr_info(\"\\n\");\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tindex_good = mtrr_search_optimal_index();\n\n\tif (index_good != -1) {\n\t\tpr_info(\"Found optimal setting for mtrr clean up\\n\");\n\t\ti = index_good;\n\t\tmtrr_print_out_one_result(i);\n\n\t\t \n\t\tchunk_size = result[i].chunk_sizek;\n\t\tchunk_size <<= 10;\n\t\tgran_size = result[i].gran_sizek;\n\t\tgran_size <<= 10;\n\t\tx86_setup_var_mtrrs(range, nr_range, chunk_size, gran_size);\n\t\tset_var_mtrr_all();\n\t\tDprintk(\"New variable MTRRs\\n\");\n\t\tprint_out_mtrr_range_state();\n\t\treturn 1;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < NUM_RESULT; i++)\n\t\t\tmtrr_print_out_one_result(i);\n\t}\n\n\tpr_info(\"mtrr_cleanup: can not find optimal value\\n\");\n\tpr_info(\"please specify mtrr_gran_size/mtrr_chunk_size\\n\");\n\n\treturn 0;\n}\n#else\nint __init mtrr_cleanup(void)\n{\n\treturn 0;\n}\n#endif\n\nstatic int disable_mtrr_trim;\n\nstatic int __init disable_mtrr_trim_setup(char *str)\n{\n\tdisable_mtrr_trim = 1;\n\treturn 0;\n}\nearly_param(\"disable_mtrr_trim\", disable_mtrr_trim_setup);\n\n \n#define Tom2Enabled\t\t(1U << 21)\n#define Tom2ForceMemTypeWB\t(1U << 22)\n\nint __init amd_special_default_mtrr(void)\n{\n\tu32 l, h;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON)\n\t\treturn 0;\n\tif (boot_cpu_data.x86 < 0xf)\n\t\treturn 0;\n\t \n\tif (rdmsr_safe(MSR_AMD64_SYSCFG, &l, &h) < 0)\n\t\treturn 0;\n\t \n\tif ((l & (Tom2Enabled | Tom2ForceMemTypeWB)) ==\n\t\t (Tom2Enabled | Tom2ForceMemTypeWB))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic u64 __init\nreal_trim_memory(unsigned long start_pfn, unsigned long limit_pfn)\n{\n\tu64 trim_start, trim_size;\n\n\ttrim_start = start_pfn;\n\ttrim_start <<= PAGE_SHIFT;\n\n\ttrim_size = limit_pfn;\n\ttrim_size <<= PAGE_SHIFT;\n\ttrim_size -= trim_start;\n\n\treturn e820__range_update(trim_start, trim_size, E820_TYPE_RAM, E820_TYPE_RESERVED);\n}\n\n \nint __init mtrr_trim_uncached_memory(unsigned long end_pfn)\n{\n\tunsigned long i, base, size, highest_pfn = 0, def, dummy;\n\tmtrr_type type;\n\tu64 total_trim_size;\n\t \n\tint num[MTRR_NUM_TYPES + 1];\n\n\tif (!mtrr_enabled())\n\t\treturn 0;\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_MTRR) || disable_mtrr_trim)\n\t\treturn 0;\n\n\trdmsr(MSR_MTRRdefType, def, dummy);\n\tdef &= MTRR_DEF_TYPE_TYPE;\n\tif (def != MTRR_TYPE_UNCACHABLE)\n\t\treturn 0;\n\n\t \n\tmemset(range_state, 0, sizeof(range_state));\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\tmtrr_if->get(i, &base, &size, &type);\n\t\trange_state[i].base_pfn = base;\n\t\trange_state[i].size_pfn = size;\n\t\trange_state[i].type = type;\n\t}\n\n\t \n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tif (type != MTRR_TYPE_WRBACK)\n\t\t\tcontinue;\n\t\tbase = range_state[i].base_pfn;\n\t\tsize = range_state[i].size_pfn;\n\t\tif (highest_pfn < base + size)\n\t\t\thighest_pfn = base + size;\n\t}\n\n\t \n\tif (!highest_pfn) {\n\t\tpr_info(\"CPU MTRRs all blank - virtualized system.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmemset(num, 0, sizeof(num));\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tif (type >= MTRR_NUM_TYPES)\n\t\t\tcontinue;\n\t\tsize = range_state[i].size_pfn;\n\t\tif (!size)\n\t\t\ttype = MTRR_NUM_TYPES;\n\t\tnum[type]++;\n\t}\n\n\t \n\tif (!num[MTRR_TYPE_WRBACK])\n\t\treturn 0;\n\n\t \n\tif (num[MTRR_TYPE_WRBACK] + num[MTRR_TYPE_UNCACHABLE] !=\n\t\tnum_var_ranges - num[MTRR_NUM_TYPES])\n\t\treturn 0;\n\n\tmemset(range, 0, sizeof(range));\n\tnr_range = 0;\n\tif (mtrr_tom2) {\n\t\trange[nr_range].start = (1ULL<<(32 - PAGE_SHIFT));\n\t\trange[nr_range].end = mtrr_tom2 >> PAGE_SHIFT;\n\t\tif (highest_pfn < range[nr_range].end)\n\t\t\thighest_pfn = range[nr_range].end;\n\t\tnr_range++;\n\t}\n\tnr_range = x86_get_mtrr_mem_range(range, nr_range, 0, 0);\n\n\t \n\ttotal_trim_size = 0;\n\tif (range[0].start)\n\t\ttotal_trim_size += real_trim_memory(0, range[0].start);\n\n\t \n\tfor (i = 0; i < nr_range - 1; i++) {\n\t\tif (range[i].end < range[i+1].start)\n\t\t\ttotal_trim_size += real_trim_memory(range[i].end,\n\t\t\t\t\t\t\t    range[i+1].start);\n\t}\n\n\t \n\ti = nr_range - 1;\n\tif (range[i].end < end_pfn)\n\t\ttotal_trim_size += real_trim_memory(range[i].end,\n\t\t\t\t\t\t\t end_pfn);\n\n\tif (total_trim_size) {\n\t\tpr_warn(\"WARNING: BIOS bug: CPU MTRRs don't cover all of memory, losing %lluMB of RAM.\\n\",\n\t\t\ttotal_trim_size >> 20);\n\n\t\tif (!changed_by_mtrr_cleanup)\n\t\t\tWARN_ON(1);\n\n\t\tpr_info(\"update e820 for mtrr\\n\");\n\t\te820__update_table_print();\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}