{
  "module_name": "generic.c",
  "hash_id": "e25867c84f0d280d8a1c22abbf36bf931d6323d46b09b26745e4e696af4a3a01",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/generic.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/cc_platform.h>\n#include <asm/processor-flags.h>\n#include <asm/cacheinfo.h>\n#include <asm/cpufeature.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/tlbflush.h>\n#include <asm/mtrr.h>\n#include <asm/msr.h>\n#include <asm/memtype.h>\n\n#include \"mtrr.h\"\n\nstruct fixed_range_block {\n\tint base_msr;\t\t \n\tint ranges;\t\t \n};\n\nstatic struct fixed_range_block fixed_range_blocks[] = {\n\t{ MSR_MTRRfix64K_00000, 1 },  \n\t{ MSR_MTRRfix16K_80000, 2 },  \n\t{ MSR_MTRRfix4K_C0000,  8 },  \n\t{}\n};\n\nstruct cache_map {\n\tu64 start;\n\tu64 end;\n\tu64 flags;\n\tu64 type:8;\n\tu64 fixed:1;\n};\n\nbool mtrr_debug;\n\nstatic int __init mtrr_param_setup(char *str)\n{\n\tint rc = 0;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (!strcmp(str, \"debug\"))\n\t\tmtrr_debug = true;\n\telse\n\t\trc = -EINVAL;\n\n\treturn rc;\n}\nearly_param(\"mtrr\", mtrr_param_setup);\n\n \n#define CACHE_MAP_MAX\t(MTRR_NUM_FIXED_RANGES + MTRR_MAX_VAR_RANGES * 2)\n\nstatic struct cache_map init_cache_map[CACHE_MAP_MAX] __initdata;\nstatic struct cache_map *cache_map __refdata = init_cache_map;\nstatic unsigned int cache_map_size = CACHE_MAP_MAX;\nstatic unsigned int cache_map_n;\nstatic unsigned int cache_map_fixed;\n\nstatic unsigned long smp_changes_mask;\nstatic int mtrr_state_set;\nu64 mtrr_tom2;\n\nstruct mtrr_state_type mtrr_state;\nEXPORT_SYMBOL_GPL(mtrr_state);\n\n \nu32 phys_hi_rsvd;\n\n \nstatic inline void k8_check_syscfg_dram_mod_en(void)\n{\n\tu32 lo, hi;\n\n\tif (!((boot_cpu_data.x86_vendor == X86_VENDOR_AMD) &&\n\t      (boot_cpu_data.x86 >= 0x0f)))\n\t\treturn;\n\n\trdmsr(MSR_AMD64_SYSCFG, lo, hi);\n\tif (lo & K8_MTRRFIXRANGE_DRAM_MODIFY) {\n\t\tpr_err(FW_WARN \"MTRR: CPU %u: SYSCFG[MtrrFixDramModEn]\"\n\t\t       \" not cleared by BIOS, clearing this bit\\n\",\n\t\t       smp_processor_id());\n\t\tlo &= ~K8_MTRRFIXRANGE_DRAM_MODIFY;\n\t\tmtrr_wrmsr(MSR_AMD64_SYSCFG, lo, hi);\n\t}\n}\n\n \nstatic u64 get_mtrr_size(u64 mask)\n{\n\tu64 size;\n\n\tmask |= (u64)phys_hi_rsvd << 32;\n\tsize = -mask;\n\n\treturn size;\n}\n\nstatic u8 get_var_mtrr_state(unsigned int reg, u64 *start, u64 *size)\n{\n\tstruct mtrr_var_range *mtrr = mtrr_state.var_ranges + reg;\n\n\tif (!(mtrr->mask_lo & MTRR_PHYSMASK_V))\n\t\treturn MTRR_TYPE_INVALID;\n\n\t*start = (((u64)mtrr->base_hi) << 32) + (mtrr->base_lo & PAGE_MASK);\n\t*size = get_mtrr_size((((u64)mtrr->mask_hi) << 32) +\n\t\t\t      (mtrr->mask_lo & PAGE_MASK));\n\n\treturn mtrr->base_lo & MTRR_PHYSBASE_TYPE;\n}\n\nstatic u8 get_effective_type(u8 type1, u8 type2)\n{\n\tif (type1 == MTRR_TYPE_UNCACHABLE || type2 == MTRR_TYPE_UNCACHABLE)\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\tif ((type1 == MTRR_TYPE_WRBACK && type2 == MTRR_TYPE_WRTHROUGH) ||\n\t    (type1 == MTRR_TYPE_WRTHROUGH && type2 == MTRR_TYPE_WRBACK))\n\t\treturn MTRR_TYPE_WRTHROUGH;\n\n\tif (type1 != type2)\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\treturn type1;\n}\n\nstatic void rm_map_entry_at(int idx)\n{\n\tcache_map_n--;\n\tif (cache_map_n > idx) {\n\t\tmemmove(cache_map + idx, cache_map + idx + 1,\n\t\t\tsizeof(*cache_map) * (cache_map_n - idx));\n\t}\n}\n\n \nstatic int add_map_entry_at(u64 start, u64 end, u8 type, int idx)\n{\n\tbool merge_prev = false, merge_next = false;\n\n\tif (start >= end)\n\t\treturn 0;\n\n\tif (idx > 0) {\n\t\tstruct cache_map *prev = cache_map + idx - 1;\n\n\t\tif (!prev->fixed && start == prev->end && type == prev->type)\n\t\t\tmerge_prev = true;\n\t}\n\n\tif (idx < cache_map_n) {\n\t\tstruct cache_map *next = cache_map + idx;\n\n\t\tif (!next->fixed && end == next->start && type == next->type)\n\t\t\tmerge_next = true;\n\t}\n\n\tif (merge_prev && merge_next) {\n\t\tcache_map[idx - 1].end = cache_map[idx].end;\n\t\trm_map_entry_at(idx);\n\t\treturn 2;\n\t}\n\tif (merge_prev) {\n\t\tcache_map[idx - 1].end = end;\n\t\treturn 1;\n\t}\n\tif (merge_next) {\n\t\tcache_map[idx].start = start;\n\t\treturn 1;\n\t}\n\n\t \n\tif (cache_map_n == cache_map_size) {\n\t\tWARN(1, \"MTRR cache mode memory map exhausted!\\n\");\n\t\tcache_map_n = cache_map_fixed;\n\t\treturn 0;\n\t}\n\n\tif (cache_map_n > idx) {\n\t\tmemmove(cache_map + idx + 1, cache_map + idx,\n\t\t\tsizeof(*cache_map) * (cache_map_n - idx));\n\t}\n\n\tcache_map[idx].start = start;\n\tcache_map[idx].end = end;\n\tcache_map[idx].type = type;\n\tcache_map[idx].fixed = 0;\n\tcache_map_n++;\n\n\treturn 0;\n}\n\n \nstatic int clr_map_range_at(u64 start, u64 end, int idx)\n{\n\tint ret = start != cache_map[idx].start;\n\tu64 tmp;\n\n\tif (start == cache_map[idx].start && end == cache_map[idx].end) {\n\t\trm_map_entry_at(idx);\n\t} else if (start == cache_map[idx].start) {\n\t\tcache_map[idx].start = end;\n\t} else if (end == cache_map[idx].end) {\n\t\tcache_map[idx].end = start;\n\t} else {\n\t\ttmp = cache_map[idx].end;\n\t\tcache_map[idx].end = start;\n\t\tadd_map_entry_at(end, tmp, cache_map[idx].type, idx + 1);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void add_map_entry(u64 start, u64 end, u8 type)\n{\n\tu8 new_type, old_type;\n\tu64 tmp;\n\tint i;\n\n\tfor (i = 0; i < cache_map_n && start < end; i++) {\n\t\tif (start >= cache_map[i].end)\n\t\t\tcontinue;\n\n\t\tif (start < cache_map[i].start) {\n\t\t\t \n\t\t\ttmp = min(end, cache_map[i].start);\n\t\t\ti -= add_map_entry_at(start, tmp,  type, i);\n\t\t\tstart = tmp;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_type = get_effective_type(type, cache_map[i].type);\n\t\told_type = cache_map[i].type;\n\n\t\tif (cache_map[i].fixed || new_type == old_type) {\n\t\t\t \n\t\t\tstart = cache_map[i].end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttmp = min(end, cache_map[i].end);\n\t\ti += clr_map_range_at(start, tmp, i);\n\t\ti -= add_map_entry_at(start, tmp, new_type, i);\n\t\tstart = tmp;\n\t}\n\n\t \n\tadd_map_entry_at(start, end, type, i);\n}\n\n \nstatic void map_add_var(void)\n{\n\tu64 start, size;\n\tunsigned int i;\n\tu8 type;\n\n\t \n\tif (mtrr_tom2) {\n\t\tadd_map_entry(BIT_ULL(32), mtrr_tom2, MTRR_TYPE_WRBACK);\n\t\tcache_map[cache_map_n - 1].fixed = 1;\n\t}\n\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = get_var_mtrr_state(i, &start, &size);\n\t\tif (type != MTRR_TYPE_INVALID)\n\t\t\tadd_map_entry(start, start + size, type);\n\t}\n}\n\n \nvoid generic_rebuild_map(void)\n{\n\tif (mtrr_if != &generic_mtrr_ops)\n\t\treturn;\n\n\tcache_map_n = cache_map_fixed;\n\n\tmap_add_var();\n}\n\nstatic unsigned int __init get_cache_map_size(void)\n{\n\treturn cache_map_fixed + 2 * num_var_ranges + (mtrr_tom2 != 0);\n}\n\n \nvoid __init mtrr_build_map(void)\n{\n\tu64 start, end, size;\n\tunsigned int i;\n\tu8 type;\n\n\t \n\tif (mtrr_state.enabled & MTRR_STATE_MTRR_FIXED_ENABLED) {\n\t\t \n\t\tstart = 0;\n\t\tend = size = 0x10000;\n\t\ttype = mtrr_state.fixed_ranges[0];\n\n\t\tfor (i = 1; i < MTRR_NUM_FIXED_RANGES; i++) {\n\t\t\t \n\t\t\tif (i == 8 || i == 24)\n\t\t\t\tsize >>= 2;\n\n\t\t\tif (mtrr_state.fixed_ranges[i] != type) {\n\t\t\t\tadd_map_entry(start, end, type);\n\t\t\t\tstart = end;\n\t\t\t\ttype = mtrr_state.fixed_ranges[i];\n\t\t\t}\n\t\t\tend += size;\n\t\t}\n\t\tadd_map_entry(start, end, type);\n\t}\n\n\t \n\tfor (i = 0; i < cache_map_n; i++)\n\t\tcache_map[i].fixed = 1;\n\tcache_map_fixed = cache_map_n;\n\n\tmap_add_var();\n\n\tpr_info(\"MTRR map: %u entries (%u fixed + %u variable; max %u), built from %u variable MTRRs\\n\",\n\t\tcache_map_n, cache_map_fixed, cache_map_n - cache_map_fixed,\n\t\tget_cache_map_size(), num_var_ranges + (mtrr_tom2 != 0));\n\n\tif (mtrr_debug) {\n\t\tfor (i = 0; i < cache_map_n; i++) {\n\t\t\tpr_info(\"%3u: %016llx-%016llx %s\\n\", i,\n\t\t\t\tcache_map[i].start, cache_map[i].end - 1,\n\t\t\t\tmtrr_attrib_to_str(cache_map[i].type));\n\t\t}\n\t}\n}\n\n \nvoid __init mtrr_copy_map(void)\n{\n\tunsigned int new_size = get_cache_map_size();\n\n\tif (!mtrr_state.enabled || !new_size) {\n\t\tcache_map = NULL;\n\t\treturn;\n\t}\n\n\tmutex_lock(&mtrr_mutex);\n\n\tcache_map = kcalloc(new_size, sizeof(*cache_map), GFP_KERNEL);\n\tif (cache_map) {\n\t\tmemmove(cache_map, init_cache_map,\n\t\t\tcache_map_n * sizeof(*cache_map));\n\t\tcache_map_size = new_size;\n\t} else {\n\t\tmtrr_state.enabled = 0;\n\t\tpr_err(\"MTRRs disabled due to allocation failure for lookup map.\\n\");\n\t}\n\n\tmutex_unlock(&mtrr_mutex);\n}\n\n \nvoid mtrr_overwrite_state(struct mtrr_var_range *var, unsigned int num_var,\n\t\t\t  mtrr_type def_type)\n{\n\tunsigned int i;\n\n\t \n\tif (WARN_ON_ONCE(mtrr_state_set))\n\t\treturn;\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_HYPERVISOR))\n\t\treturn;\n\n\t \n\tif (!cc_platform_has(CC_ATTR_GUEST_SEV_SNP) &&\n\t    !hv_is_isolation_supported() &&\n\t    !cpu_feature_enabled(X86_FEATURE_XENPV) &&\n\t    !cpu_feature_enabled(X86_FEATURE_TDX_GUEST))\n\t\treturn;\n\n\t \n\tsetup_clear_cpu_cap(X86_FEATURE_MTRR);\n\n\tif (var) {\n\t\tif (num_var > MTRR_MAX_VAR_RANGES) {\n\t\t\tpr_warn(\"Trying to overwrite MTRR state with %u variable entries\\n\",\n\t\t\t\tnum_var);\n\t\t\tnum_var = MTRR_MAX_VAR_RANGES;\n\t\t}\n\t\tfor (i = 0; i < num_var; i++)\n\t\t\tmtrr_state.var_ranges[i] = var[i];\n\t\tnum_var_ranges = num_var;\n\t}\n\n\tmtrr_state.def_type = def_type;\n\tmtrr_state.enabled |= MTRR_STATE_MTRR_ENABLED;\n\n\tmtrr_state_set = 1;\n}\n\nstatic u8 type_merge(u8 type, u8 new_type, u8 *uniform)\n{\n\tu8 effective_type;\n\n\tif (type == MTRR_TYPE_INVALID)\n\t\treturn new_type;\n\n\teffective_type = get_effective_type(type, new_type);\n\tif (type != effective_type)\n\t\t*uniform = 0;\n\n\treturn effective_type;\n}\n\n \nu8 mtrr_type_lookup(u64 start, u64 end, u8 *uniform)\n{\n\tu8 type = MTRR_TYPE_INVALID;\n\tunsigned int i;\n\n\tif (!mtrr_state_set) {\n\t\t \n\t\t*uniform = 0;\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\t}\n\n\t*uniform = 1;\n\n\tif (!(mtrr_state.enabled & MTRR_STATE_MTRR_ENABLED))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\tfor (i = 0; i < cache_map_n && start < end; i++) {\n\t\t \n\t\tif (start >= cache_map[i].end)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (start < cache_map[i].start) {\n\t\t\t \n\t\t\ttype = type_merge(type, mtrr_state.def_type, uniform);\n\t\t\t \n\t\t\tif (end <= cache_map[i].start)\n\t\t\t\treturn type;\n\t\t}\n\n\t\t \n\t\ttype = type_merge(type, cache_map[i].type, uniform);\n\n\t\tstart = cache_map[i].end;\n\t}\n\n\t \n\tif (start < end)\n\t\ttype = type_merge(type, mtrr_state.def_type, uniform);\n\n\treturn type;\n}\n\n \nstatic void\nget_mtrr_var_range(unsigned int index, struct mtrr_var_range *vr)\n{\n\trdmsr(MTRRphysBase_MSR(index), vr->base_lo, vr->base_hi);\n\trdmsr(MTRRphysMask_MSR(index), vr->mask_lo, vr->mask_hi);\n}\n\n \nvoid fill_mtrr_var_range(unsigned int index,\n\t\tu32 base_lo, u32 base_hi, u32 mask_lo, u32 mask_hi)\n{\n\tstruct mtrr_var_range *vr;\n\n\tvr = mtrr_state.var_ranges;\n\n\tvr[index].base_lo = base_lo;\n\tvr[index].base_hi = base_hi;\n\tvr[index].mask_lo = mask_lo;\n\tvr[index].mask_hi = mask_hi;\n}\n\nstatic void get_fixed_ranges(mtrr_type *frs)\n{\n\tunsigned int *p = (unsigned int *)frs;\n\tint i;\n\n\tk8_check_syscfg_dram_mod_en();\n\n\trdmsr(MSR_MTRRfix64K_00000, p[0], p[1]);\n\n\tfor (i = 0; i < 2; i++)\n\t\trdmsr(MSR_MTRRfix16K_80000 + i, p[2 + i * 2], p[3 + i * 2]);\n\tfor (i = 0; i < 8; i++)\n\t\trdmsr(MSR_MTRRfix4K_C0000 + i, p[6 + i * 2], p[7 + i * 2]);\n}\n\nvoid mtrr_save_fixed_ranges(void *info)\n{\n\tif (boot_cpu_has(X86_FEATURE_MTRR))\n\t\tget_fixed_ranges(mtrr_state.fixed_ranges);\n}\n\nstatic unsigned __initdata last_fixed_start;\nstatic unsigned __initdata last_fixed_end;\nstatic mtrr_type __initdata last_fixed_type;\n\nstatic void __init print_fixed_last(void)\n{\n\tif (!last_fixed_end)\n\t\treturn;\n\n\tpr_info(\"  %05X-%05X %s\\n\", last_fixed_start,\n\t\tlast_fixed_end - 1, mtrr_attrib_to_str(last_fixed_type));\n\n\tlast_fixed_end = 0;\n}\n\nstatic void __init update_fixed_last(unsigned base, unsigned end,\n\t\t\t\t     mtrr_type type)\n{\n\tlast_fixed_start = base;\n\tlast_fixed_end = end;\n\tlast_fixed_type = type;\n}\n\nstatic void __init\nprint_fixed(unsigned base, unsigned step, const mtrr_type *types)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < 8; ++i, ++types, base += step) {\n\t\tif (last_fixed_end == 0) {\n\t\t\tupdate_fixed_last(base, base + step, *types);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_fixed_end == base && last_fixed_type == *types) {\n\t\t\tlast_fixed_end = base + step;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tprint_fixed_last();\n\t\tupdate_fixed_last(base, base + step, *types);\n\t}\n}\n\nstatic void __init print_mtrr_state(void)\n{\n\tunsigned int i;\n\tint high_width;\n\n\tpr_info(\"MTRR default type: %s\\n\",\n\t\tmtrr_attrib_to_str(mtrr_state.def_type));\n\tif (mtrr_state.have_fixed) {\n\t\tpr_info(\"MTRR fixed ranges %sabled:\\n\",\n\t\t\t((mtrr_state.enabled & MTRR_STATE_MTRR_ENABLED) &&\n\t\t\t (mtrr_state.enabled & MTRR_STATE_MTRR_FIXED_ENABLED)) ?\n\t\t\t \"en\" : \"dis\");\n\t\tprint_fixed(0x00000, 0x10000, mtrr_state.fixed_ranges + 0);\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\tprint_fixed(0x80000 + i * 0x20000, 0x04000,\n\t\t\t\t    mtrr_state.fixed_ranges + (i + 1) * 8);\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tprint_fixed(0xC0000 + i * 0x08000, 0x01000,\n\t\t\t\t    mtrr_state.fixed_ranges + (i + 3) * 8);\n\n\t\t \n\t\tprint_fixed_last();\n\t}\n\tpr_info(\"MTRR variable ranges %sabled:\\n\",\n\t\tmtrr_state.enabled & MTRR_STATE_MTRR_ENABLED ? \"en\" : \"dis\");\n\thigh_width = (boot_cpu_data.x86_phys_bits - (32 - PAGE_SHIFT) + 3) / 4;\n\n\tfor (i = 0; i < num_var_ranges; ++i) {\n\t\tif (mtrr_state.var_ranges[i].mask_lo & MTRR_PHYSMASK_V)\n\t\t\tpr_info(\"  %u base %0*X%05X000 mask %0*X%05X000 %s\\n\",\n\t\t\t\ti,\n\t\t\t\thigh_width,\n\t\t\t\tmtrr_state.var_ranges[i].base_hi,\n\t\t\t\tmtrr_state.var_ranges[i].base_lo >> 12,\n\t\t\t\thigh_width,\n\t\t\t\tmtrr_state.var_ranges[i].mask_hi,\n\t\t\t\tmtrr_state.var_ranges[i].mask_lo >> 12,\n\t\t\t\tmtrr_attrib_to_str(mtrr_state.var_ranges[i].base_lo &\n\t\t\t\t\t\t    MTRR_PHYSBASE_TYPE));\n\t\telse\n\t\t\tpr_info(\"  %u disabled\\n\", i);\n\t}\n\tif (mtrr_tom2)\n\t\tpr_info(\"TOM2: %016llx aka %lldM\\n\", mtrr_tom2, mtrr_tom2>>20);\n}\n\n \nbool __init get_mtrr_state(void)\n{\n\tstruct mtrr_var_range *vrs;\n\tunsigned lo, dummy;\n\tunsigned int i;\n\n\tvrs = mtrr_state.var_ranges;\n\n\trdmsr(MSR_MTRRcap, lo, dummy);\n\tmtrr_state.have_fixed = lo & MTRR_CAP_FIX;\n\n\tfor (i = 0; i < num_var_ranges; i++)\n\t\tget_mtrr_var_range(i, &vrs[i]);\n\tif (mtrr_state.have_fixed)\n\t\tget_fixed_ranges(mtrr_state.fixed_ranges);\n\n\trdmsr(MSR_MTRRdefType, lo, dummy);\n\tmtrr_state.def_type = lo & MTRR_DEF_TYPE_TYPE;\n\tmtrr_state.enabled = (lo & MTRR_DEF_TYPE_ENABLE) >> MTRR_STATE_SHIFT;\n\n\tif (amd_special_default_mtrr()) {\n\t\tunsigned low, high;\n\n\t\t \n\t\trdmsr(MSR_K8_TOP_MEM2, low, high);\n\t\tmtrr_tom2 = high;\n\t\tmtrr_tom2 <<= 32;\n\t\tmtrr_tom2 |= low;\n\t\tmtrr_tom2 &= 0xffffff800000ULL;\n\t}\n\n\tif (mtrr_debug)\n\t\tprint_mtrr_state();\n\n\tmtrr_state_set = 1;\n\n\treturn !!(mtrr_state.enabled & MTRR_STATE_MTRR_ENABLED);\n}\n\n \nvoid __init mtrr_state_warn(void)\n{\n\tunsigned long mask = smp_changes_mask;\n\n\tif (!mask)\n\t\treturn;\n\tif (mask & MTRR_CHANGE_MASK_FIXED)\n\t\tpr_warn(\"mtrr: your CPUs had inconsistent fixed MTRR settings\\n\");\n\tif (mask & MTRR_CHANGE_MASK_VARIABLE)\n\t\tpr_warn(\"mtrr: your CPUs had inconsistent variable MTRR settings\\n\");\n\tif (mask & MTRR_CHANGE_MASK_DEFTYPE)\n\t\tpr_warn(\"mtrr: your CPUs had inconsistent MTRRdefType settings\\n\");\n\n\tpr_info(\"mtrr: probably your BIOS does not setup all CPUs.\\n\");\n\tpr_info(\"mtrr: corrected configuration.\\n\");\n}\n\n \nvoid mtrr_wrmsr(unsigned msr, unsigned a, unsigned b)\n{\n\tif (wrmsr_safe(msr, a, b) < 0) {\n\t\tpr_err(\"MTRR: CPU %u: Writing MSR %x to %x:%x failed\\n\",\n\t\t\tsmp_processor_id(), msr, a, b);\n\t}\n}\n\n \nstatic void set_fixed_range(int msr, bool *changed, unsigned int *msrwords)\n{\n\tunsigned lo, hi;\n\n\trdmsr(msr, lo, hi);\n\n\tif (lo != msrwords[0] || hi != msrwords[1]) {\n\t\tmtrr_wrmsr(msr, msrwords[0], msrwords[1]);\n\t\t*changed = true;\n\t}\n}\n\n \nint\ngeneric_get_free_region(unsigned long base, unsigned long size, int replace_reg)\n{\n\tunsigned long lbase, lsize;\n\tmtrr_type ltype;\n\tint i, max;\n\n\tmax = num_var_ranges;\n\tif (replace_reg >= 0 && replace_reg < max)\n\t\treturn replace_reg;\n\n\tfor (i = 0; i < max; ++i) {\n\t\tmtrr_if->get(i, &lbase, &lsize, &ltype);\n\t\tif (lsize == 0)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic void generic_get_mtrr(unsigned int reg, unsigned long *base,\n\t\t\t     unsigned long *size, mtrr_type *type)\n{\n\tu32 mask_lo, mask_hi, base_lo, base_hi;\n\tunsigned int hi;\n\tu64 tmp, mask;\n\n\t \n\tget_cpu();\n\n\trdmsr(MTRRphysMask_MSR(reg), mask_lo, mask_hi);\n\n\tif (!(mask_lo & MTRR_PHYSMASK_V)) {\n\t\t \n\t\t*base = 0;\n\t\t*size = 0;\n\t\t*type = 0;\n\t\tgoto out_put_cpu;\n\t}\n\n\trdmsr(MTRRphysBase_MSR(reg), base_lo, base_hi);\n\n\t \n\ttmp = (u64)mask_hi << 32 | (mask_lo & PAGE_MASK);\n\tmask = (u64)phys_hi_rsvd << 32 | tmp;\n\n\t \n\thi = fls64(tmp);\n\tif (hi > 0) {\n\t\ttmp |= ~((1ULL<<(hi - 1)) - 1);\n\n\t\tif (tmp != mask) {\n\t\t\tpr_warn(\"mtrr: your BIOS has configured an incorrect mask, fixing it.\\n\");\n\t\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\t\tmask = tmp;\n\t\t}\n\t}\n\n\t \n\t*size = -mask >> PAGE_SHIFT;\n\t*base = (u64)base_hi << (32 - PAGE_SHIFT) | base_lo >> PAGE_SHIFT;\n\t*type = base_lo & MTRR_PHYSBASE_TYPE;\n\nout_put_cpu:\n\tput_cpu();\n}\n\n \nstatic int set_fixed_ranges(mtrr_type *frs)\n{\n\tunsigned long long *saved = (unsigned long long *)frs;\n\tbool changed = false;\n\tint block = -1, range;\n\n\tk8_check_syscfg_dram_mod_en();\n\n\twhile (fixed_range_blocks[++block].ranges) {\n\t\tfor (range = 0; range < fixed_range_blocks[block].ranges; range++)\n\t\t\tset_fixed_range(fixed_range_blocks[block].base_msr + range,\n\t\t\t\t\t&changed, (unsigned int *)saved++);\n\t}\n\n\treturn changed;\n}\n\n \nstatic bool set_mtrr_var_ranges(unsigned int index, struct mtrr_var_range *vr)\n{\n\tunsigned int lo, hi;\n\tbool changed = false;\n\n\trdmsr(MTRRphysBase_MSR(index), lo, hi);\n\tif ((vr->base_lo & ~MTRR_PHYSBASE_RSVD) != (lo & ~MTRR_PHYSBASE_RSVD)\n\t    || (vr->base_hi & ~phys_hi_rsvd) != (hi & ~phys_hi_rsvd)) {\n\n\t\tmtrr_wrmsr(MTRRphysBase_MSR(index), vr->base_lo, vr->base_hi);\n\t\tchanged = true;\n\t}\n\n\trdmsr(MTRRphysMask_MSR(index), lo, hi);\n\n\tif ((vr->mask_lo & ~MTRR_PHYSMASK_RSVD) != (lo & ~MTRR_PHYSMASK_RSVD)\n\t    || (vr->mask_hi & ~phys_hi_rsvd) != (hi & ~phys_hi_rsvd)) {\n\t\tmtrr_wrmsr(MTRRphysMask_MSR(index), vr->mask_lo, vr->mask_hi);\n\t\tchanged = true;\n\t}\n\treturn changed;\n}\n\nstatic u32 deftype_lo, deftype_hi;\n\n \nstatic unsigned long set_mtrr_state(void)\n{\n\tunsigned long change_mask = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\tif (set_mtrr_var_ranges(i, &mtrr_state.var_ranges[i]))\n\t\t\tchange_mask |= MTRR_CHANGE_MASK_VARIABLE;\n\t}\n\n\tif (mtrr_state.have_fixed && set_fixed_ranges(mtrr_state.fixed_ranges))\n\t\tchange_mask |= MTRR_CHANGE_MASK_FIXED;\n\n\t \n\tif ((deftype_lo & MTRR_DEF_TYPE_TYPE) != mtrr_state.def_type ||\n\t    ((deftype_lo & MTRR_DEF_TYPE_ENABLE) >> MTRR_STATE_SHIFT) != mtrr_state.enabled) {\n\n\t\tdeftype_lo = (deftype_lo & MTRR_DEF_TYPE_DISABLE) |\n\t\t\t     mtrr_state.def_type |\n\t\t\t     (mtrr_state.enabled << MTRR_STATE_SHIFT);\n\t\tchange_mask |= MTRR_CHANGE_MASK_DEFTYPE;\n\t}\n\n\treturn change_mask;\n}\n\nvoid mtrr_disable(void)\n{\n\t \n\trdmsr(MSR_MTRRdefType, deftype_lo, deftype_hi);\n\n\t \n\tmtrr_wrmsr(MSR_MTRRdefType, deftype_lo & MTRR_DEF_TYPE_DISABLE, deftype_hi);\n}\n\nvoid mtrr_enable(void)\n{\n\t \n\tmtrr_wrmsr(MSR_MTRRdefType, deftype_lo, deftype_hi);\n}\n\nvoid mtrr_generic_set_state(void)\n{\n\tunsigned long mask, count;\n\n\t \n\tmask = set_mtrr_state();\n\n\t \n\tfor (count = 0; count < sizeof(mask) * 8; ++count) {\n\t\tif (mask & 0x01)\n\t\t\tset_bit(count, &smp_changes_mask);\n\t\tmask >>= 1;\n\t}\n}\n\n \nstatic void generic_set_mtrr(unsigned int reg, unsigned long base,\n\t\t\t     unsigned long size, mtrr_type type)\n{\n\tunsigned long flags;\n\tstruct mtrr_var_range *vr;\n\n\tvr = &mtrr_state.var_ranges[reg];\n\n\tlocal_irq_save(flags);\n\tcache_disable();\n\n\tif (size == 0) {\n\t\t \n\t\tmtrr_wrmsr(MTRRphysMask_MSR(reg), 0, 0);\n\t\tmemset(vr, 0, sizeof(struct mtrr_var_range));\n\t} else {\n\t\tvr->base_lo = base << PAGE_SHIFT | type;\n\t\tvr->base_hi = (base >> (32 - PAGE_SHIFT)) & ~phys_hi_rsvd;\n\t\tvr->mask_lo = -size << PAGE_SHIFT | MTRR_PHYSMASK_V;\n\t\tvr->mask_hi = (-size >> (32 - PAGE_SHIFT)) & ~phys_hi_rsvd;\n\n\t\tmtrr_wrmsr(MTRRphysBase_MSR(reg), vr->base_lo, vr->base_hi);\n\t\tmtrr_wrmsr(MTRRphysMask_MSR(reg), vr->mask_lo, vr->mask_hi);\n\t}\n\n\tcache_enable();\n\tlocal_irq_restore(flags);\n}\n\nint generic_validate_add_page(unsigned long base, unsigned long size,\n\t\t\t      unsigned int type)\n{\n\tunsigned long lbase, last;\n\n\t \n\tif (mtrr_if == &generic_mtrr_ops && boot_cpu_data.x86 == 6 &&\n\t    boot_cpu_data.x86_model == 1 &&\n\t    boot_cpu_data.x86_stepping <= 7) {\n\t\tif (base & ((1 << (22 - PAGE_SHIFT)) - 1)) {\n\t\t\tpr_warn(\"mtrr: base(0x%lx000) is not 4 MiB aligned\\n\", base);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(base + size < 0x70000 || base > 0x7003F) &&\n\t\t    (type == MTRR_TYPE_WRCOMB\n\t\t     || type == MTRR_TYPE_WRBACK)) {\n\t\t\tpr_warn(\"mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tlast = base + size - 1;\n\tfor (lbase = base; !(lbase & 1) && (last & 1);\n\t     lbase = lbase >> 1, last = last >> 1)\n\t\t;\n\tif (lbase != last) {\n\t\tpr_warn(\"mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary\\n\", base, size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int generic_have_wrcomb(void)\n{\n\tunsigned long config, dummy;\n\trdmsr(MSR_MTRRcap, config, dummy);\n\treturn config & MTRR_CAP_WC;\n}\n\nint positive_have_wrcomb(void)\n{\n\treturn 1;\n}\n\n \nconst struct mtrr_ops generic_mtrr_ops = {\n\t.get\t\t\t= generic_get_mtrr,\n\t.get_free_region\t= generic_get_free_region,\n\t.set\t\t\t= generic_set_mtrr,\n\t.validate_add_page\t= generic_validate_add_page,\n\t.have_wrcomb\t\t= generic_have_wrcomb,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}