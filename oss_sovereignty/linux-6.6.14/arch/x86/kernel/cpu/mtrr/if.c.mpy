{
  "module_name": "if.c",
  "hash_id": "5bbf98cc04328887599153e80d6c98be8f2720a0424b611b91aec9d8ddaca647",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/if.c",
  "human_readable_source": "\n#include <linux/capability.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\n#define LINE_SIZE 80\n\n#include <asm/mtrr.h>\n\n#include \"mtrr.h\"\n\n#define FILE_FCOUNT(f) (((struct seq_file *)((f)->private_data))->private)\n\nstatic const char *const mtrr_strings[MTRR_NUM_TYPES] =\n{\n\t\"uncachable\",\t\t \n\t\"write-combining\",\t \n\t\"?\",\t\t\t \n\t\"?\",\t\t\t \n\t\"write-through\",\t \n\t\"write-protect\",\t \n\t\"write-back\",\t\t \n};\n\nconst char *mtrr_attrib_to_str(int x)\n{\n\treturn (x <= 6) ? mtrr_strings[x] : \"?\";\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic int\nmtrr_file_add(unsigned long base, unsigned long size,\n\t      unsigned int type, bool increment, struct file *file, int page)\n{\n\tunsigned int *fcount = FILE_FCOUNT(file);\n\tint reg, max;\n\n\tmax = num_var_ranges;\n\tif (fcount == NULL) {\n\t\tfcount = kcalloc(max, sizeof(*fcount), GFP_KERNEL);\n\t\tif (!fcount)\n\t\t\treturn -ENOMEM;\n\t\tFILE_FCOUNT(file) = fcount;\n\t}\n\tif (!page) {\n\t\tif ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1)))\n\t\t\treturn -EINVAL;\n\t\tbase >>= PAGE_SHIFT;\n\t\tsize >>= PAGE_SHIFT;\n\t}\n\treg = mtrr_add_page(base, size, type, true);\n\tif (reg >= 0)\n\t\t++fcount[reg];\n\treturn reg;\n}\n\nstatic int\nmtrr_file_del(unsigned long base, unsigned long size,\n\t      struct file *file, int page)\n{\n\tunsigned int *fcount = FILE_FCOUNT(file);\n\tint reg;\n\n\tif (!page) {\n\t\tif ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1)))\n\t\t\treturn -EINVAL;\n\t\tbase >>= PAGE_SHIFT;\n\t\tsize >>= PAGE_SHIFT;\n\t}\n\treg = mtrr_del_page(-1, base, size);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (fcount == NULL)\n\t\treturn reg;\n\tif (fcount[reg] < 1)\n\t\treturn -EINVAL;\n\t--fcount[reg];\n\treturn reg;\n}\n\n \nstatic ssize_t\nmtrr_write(struct file *file, const char __user *buf, size_t len, loff_t * ppos)\n{\n\tint i, err;\n\tunsigned long reg;\n\tunsigned long long base, size;\n\tchar *ptr;\n\tchar line[LINE_SIZE];\n\tint length;\n\tsize_t linelen;\n\n\tmemset(line, 0, LINE_SIZE);\n\n\tlen = min_t(size_t, len, LINE_SIZE - 1);\n\tlength = strncpy_from_user(line, buf, len);\n\tif (length < 0)\n\t\treturn length;\n\n\tlinelen = strlen(line);\n\tptr = line + linelen - 1;\n\tif (linelen && *ptr == '\\n')\n\t\t*ptr = '\\0';\n\n\tif (!strncmp(line, \"disable=\", 8)) {\n\t\treg = simple_strtoul(line + 8, &ptr, 0);\n\t\terr = mtrr_del_page(reg, 0, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\treturn len;\n\t}\n\n\tif (strncmp(line, \"base=\", 5))\n\t\treturn -EINVAL;\n\n\tbase = simple_strtoull(line + 5, &ptr, 0);\n\tptr = skip_spaces(ptr);\n\n\tif (strncmp(ptr, \"size=\", 5))\n\t\treturn -EINVAL;\n\n\tsize = simple_strtoull(ptr + 5, &ptr, 0);\n\tif ((base & 0xfff) || (size & 0xfff))\n\t\treturn -EINVAL;\n\tptr = skip_spaces(ptr);\n\n\tif (strncmp(ptr, \"type=\", 5))\n\t\treturn -EINVAL;\n\tptr = skip_spaces(ptr + 5);\n\n\ti = match_string(mtrr_strings, MTRR_NUM_TYPES, ptr);\n\tif (i < 0)\n\t\treturn i;\n\n\tbase >>= PAGE_SHIFT;\n\tsize >>= PAGE_SHIFT;\n\terr = mtrr_add_page((unsigned long)base, (unsigned long)size, i, true);\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n}\n\nstatic long\nmtrr_ioctl(struct file *file, unsigned int cmd, unsigned long __arg)\n{\n\tint err = 0;\n\tmtrr_type type;\n\tunsigned long base;\n\tunsigned long size;\n\tstruct mtrr_sentry sentry;\n\tstruct mtrr_gentry gentry;\n\tvoid __user *arg = (void __user *) __arg;\n\n\tmemset(&gentry, 0, sizeof(gentry));\n\n\tswitch (cmd) {\n\tcase MTRRIOC_ADD_ENTRY:\n\tcase MTRRIOC_SET_ENTRY:\n\tcase MTRRIOC_DEL_ENTRY:\n\tcase MTRRIOC_KILL_ENTRY:\n\tcase MTRRIOC_ADD_PAGE_ENTRY:\n\tcase MTRRIOC_SET_PAGE_ENTRY:\n\tcase MTRRIOC_DEL_PAGE_ENTRY:\n\tcase MTRRIOC_KILL_PAGE_ENTRY:\n\t\tif (copy_from_user(&sentry, arg, sizeof(sentry)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase MTRRIOC_GET_ENTRY:\n\tcase MTRRIOC_GET_PAGE_ENTRY:\n\t\tif (copy_from_user(&gentry, arg, sizeof(gentry)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_ADD_ENTRY:\n\tcase MTRRIOC32_SET_ENTRY:\n\tcase MTRRIOC32_DEL_ENTRY:\n\tcase MTRRIOC32_KILL_ENTRY:\n\tcase MTRRIOC32_ADD_PAGE_ENTRY:\n\tcase MTRRIOC32_SET_PAGE_ENTRY:\n\tcase MTRRIOC32_DEL_PAGE_ENTRY:\n\tcase MTRRIOC32_KILL_PAGE_ENTRY: {\n\t\tstruct mtrr_sentry32 __user *s32;\n\n\t\ts32 = (struct mtrr_sentry32 __user *)__arg;\n\t\terr = get_user(sentry.base, &s32->base);\n\t\terr |= get_user(sentry.size, &s32->size);\n\t\terr |= get_user(sentry.type, &s32->type);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tcase MTRRIOC32_GET_ENTRY:\n\tcase MTRRIOC32_GET_PAGE_ENTRY: {\n\t\tstruct mtrr_gentry32 __user *g32;\n\n\t\tg32 = (struct mtrr_gentry32 __user *)__arg;\n\t\terr = get_user(gentry.regnum, &g32->regnum);\n\t\terr |= get_user(gentry.base, &g32->base);\n\t\terr |= get_user(gentry.size, &g32->size);\n\t\terr |= get_user(gentry.type, &g32->type);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n#endif\n\t}\n\n\tswitch (cmd) {\n\tdefault:\n\t\treturn -ENOTTY;\n\tcase MTRRIOC_ADD_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_ADD_ENTRY:\n#endif\n\t\terr =\n\t\t    mtrr_file_add(sentry.base, sentry.size, sentry.type, true,\n\t\t\t\t  file, 0);\n\t\tbreak;\n\tcase MTRRIOC_SET_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_SET_ENTRY:\n#endif\n\t\terr = mtrr_add(sentry.base, sentry.size, sentry.type, false);\n\t\tbreak;\n\tcase MTRRIOC_DEL_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_DEL_ENTRY:\n#endif\n\t\terr = mtrr_file_del(sentry.base, sentry.size, file, 0);\n\t\tbreak;\n\tcase MTRRIOC_KILL_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_KILL_ENTRY:\n#endif\n\t\terr = mtrr_del(-1, sentry.base, sentry.size);\n\t\tbreak;\n\tcase MTRRIOC_GET_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_GET_ENTRY:\n#endif\n\t\tif (gentry.regnum >= num_var_ranges)\n\t\t\treturn -EINVAL;\n\t\tmtrr_if->get(gentry.regnum, &base, &size, &type);\n\n\t\t \n\t\tif (base + size - 1 >= (1UL << (8 * sizeof(gentry.size) - PAGE_SHIFT))\n\t\t    || size >= (1UL << (8 * sizeof(gentry.size) - PAGE_SHIFT)))\n\t\t\tgentry.base = gentry.size = gentry.type = 0;\n\t\telse {\n\t\t\tgentry.base = base << PAGE_SHIFT;\n\t\t\tgentry.size = size << PAGE_SHIFT;\n\t\t\tgentry.type = type;\n\t\t}\n\n\t\tbreak;\n\tcase MTRRIOC_ADD_PAGE_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_ADD_PAGE_ENTRY:\n#endif\n\t\terr =\n\t\t    mtrr_file_add(sentry.base, sentry.size, sentry.type, true,\n\t\t\t\t  file, 1);\n\t\tbreak;\n\tcase MTRRIOC_SET_PAGE_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_SET_PAGE_ENTRY:\n#endif\n\t\terr =\n\t\t    mtrr_add_page(sentry.base, sentry.size, sentry.type, false);\n\t\tbreak;\n\tcase MTRRIOC_DEL_PAGE_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_DEL_PAGE_ENTRY:\n#endif\n\t\terr = mtrr_file_del(sentry.base, sentry.size, file, 1);\n\t\tbreak;\n\tcase MTRRIOC_KILL_PAGE_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_KILL_PAGE_ENTRY:\n#endif\n\t\terr = mtrr_del_page(-1, sentry.base, sentry.size);\n\t\tbreak;\n\tcase MTRRIOC_GET_PAGE_ENTRY:\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_GET_PAGE_ENTRY:\n#endif\n\t\tif (gentry.regnum >= num_var_ranges)\n\t\t\treturn -EINVAL;\n\t\tmtrr_if->get(gentry.regnum, &base, &size, &type);\n\t\t \n\t\tif (size != (__typeof__(gentry.size))size)\n\t\t\tgentry.base = gentry.size = gentry.type = 0;\n\t\telse {\n\t\t\tgentry.base = base;\n\t\t\tgentry.size = size;\n\t\t\tgentry.type = type;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase MTRRIOC_GET_ENTRY:\n\tcase MTRRIOC_GET_PAGE_ENTRY:\n\t\tif (copy_to_user(arg, &gentry, sizeof(gentry)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n#ifdef CONFIG_COMPAT\n\tcase MTRRIOC32_GET_ENTRY:\n\tcase MTRRIOC32_GET_PAGE_ENTRY: {\n\t\tstruct mtrr_gentry32 __user *g32;\n\n\t\tg32 = (struct mtrr_gentry32 __user *)__arg;\n\t\terr = put_user(gentry.base, &g32->base);\n\t\terr |= put_user(gentry.size, &g32->size);\n\t\terr |= put_user(gentry.regnum, &g32->regnum);\n\t\terr |= put_user(gentry.type, &g32->type);\n\t\tbreak;\n\t}\n#endif\n\t}\n\treturn err;\n}\n\nstatic int mtrr_close(struct inode *ino, struct file *file)\n{\n\tunsigned int *fcount = FILE_FCOUNT(file);\n\tint i, max;\n\n\tif (fcount != NULL) {\n\t\tmax = num_var_ranges;\n\t\tfor (i = 0; i < max; ++i) {\n\t\t\twhile (fcount[i] > 0) {\n\t\t\t\tmtrr_del(i, 0, 0);\n\t\t\t\t--fcount[i];\n\t\t\t}\n\t\t}\n\t\tkfree(fcount);\n\t\tFILE_FCOUNT(file) = NULL;\n\t}\n\treturn single_release(ino, file);\n}\n\nstatic int mtrr_seq_show(struct seq_file *seq, void *offset)\n{\n\tchar factor;\n\tint i, max;\n\tmtrr_type type;\n\tunsigned long base, size;\n\n\tmax = num_var_ranges;\n\tfor (i = 0; i < max; i++) {\n\t\tmtrr_if->get(i, &base, &size, &type);\n\t\tif (size == 0) {\n\t\t\tmtrr_usage_table[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (size < (0x100000 >> PAGE_SHIFT)) {\n\t\t\t \n\t\t\tfactor = 'K';\n\t\t\tsize <<= PAGE_SHIFT - 10;\n\t\t} else {\n\t\t\tfactor = 'M';\n\t\t\tsize >>= 20 - PAGE_SHIFT;\n\t\t}\n\t\t \n\t\tseq_printf(seq, \"reg%02i: base=0x%06lx000 (%5luMB), size=%5lu%cB, count=%d: %s\\n\",\n\t\t\t   i, base, base >> (20 - PAGE_SHIFT),\n\t\t\t   size, factor,\n\t\t\t   mtrr_usage_table[i], mtrr_attrib_to_str(type));\n\t}\n\treturn 0;\n}\n\nstatic int mtrr_open(struct inode *inode, struct file *file)\n{\n\tif (!mtrr_if)\n\t\treturn -EIO;\n\tif (!mtrr_if->get)\n\t\treturn -ENXIO;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn single_open(file, mtrr_seq_show, NULL);\n}\n\nstatic const struct proc_ops mtrr_proc_ops = {\n\t.proc_open\t\t= mtrr_open,\n\t.proc_read\t\t= seq_read,\n\t.proc_lseek\t\t= seq_lseek,\n\t.proc_write\t\t= mtrr_write,\n\t.proc_ioctl\t\t= mtrr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.proc_compat_ioctl\t= mtrr_ioctl,\n#endif\n\t.proc_release\t\t= mtrr_close,\n};\n\nstatic int __init mtrr_if_init(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\tif ((!cpu_has(c, X86_FEATURE_MTRR)) &&\n\t    (!cpu_has(c, X86_FEATURE_K6_MTRR)) &&\n\t    (!cpu_has(c, X86_FEATURE_CYRIX_ARR)) &&\n\t    (!cpu_has(c, X86_FEATURE_CENTAUR_MCR)))\n\t\treturn -ENODEV;\n\n\tproc_create(\"mtrr\", S_IWUSR | S_IRUGO, NULL, &mtrr_proc_ops);\n\treturn 0;\n}\narch_initcall(mtrr_if_init);\n#endif\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}