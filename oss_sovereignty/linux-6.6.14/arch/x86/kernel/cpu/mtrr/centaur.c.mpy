{
  "module_name": "centaur.c",
  "hash_id": "396e60bdb5d7e62325a7c19ef6a7b2de4fdd48ffcd305ddd5e0a1ba708fadfda",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mtrr/centaur.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/mm.h>\n\n#include <asm/mtrr.h>\n#include <asm/msr.h>\n\n#include \"mtrr.h\"\n\nstatic struct {\n\tunsigned long high;\n\tunsigned long low;\n} centaur_mcr[8];\n\nstatic u8 centaur_mcr_reserved;\nstatic u8 centaur_mcr_type;\t \n\n \nstatic int\ncentaur_get_free_region(unsigned long base, unsigned long size, int replace_reg)\n{\n\tunsigned long lbase, lsize;\n\tmtrr_type ltype;\n\tint i, max;\n\n\tmax = num_var_ranges;\n\tif (replace_reg >= 0 && replace_reg < max)\n\t\treturn replace_reg;\n\n\tfor (i = 0; i < max; ++i) {\n\t\tif (centaur_mcr_reserved & (1 << i))\n\t\t\tcontinue;\n\t\tmtrr_if->get(i, &lbase, &lsize, &ltype);\n\t\tif (lsize == 0)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic void\ncentaur_get_mcr(unsigned int reg, unsigned long *base,\n\t\tunsigned long *size, mtrr_type * type)\n{\n\t*base = centaur_mcr[reg].high >> PAGE_SHIFT;\n\t*size = -(centaur_mcr[reg].low & 0xfffff000) >> PAGE_SHIFT;\n\t*type = MTRR_TYPE_WRCOMB;\t\t \n\n\tif (centaur_mcr_type == 1 && ((centaur_mcr[reg].low & 31) & 2))\n\t\t*type = MTRR_TYPE_UNCACHABLE;\n\tif (centaur_mcr_type == 1 && (centaur_mcr[reg].low & 31) == 25)\n\t\t*type = MTRR_TYPE_WRBACK;\n\tif (centaur_mcr_type == 0 && (centaur_mcr[reg].low & 31) == 31)\n\t\t*type = MTRR_TYPE_WRBACK;\n}\n\nstatic void\ncentaur_set_mcr(unsigned int reg, unsigned long base,\n\t\tunsigned long size, mtrr_type type)\n{\n\tunsigned long low, high;\n\n\tif (size == 0) {\n\t\t \n\t\thigh = low = 0;\n\t} else {\n\t\thigh = base << PAGE_SHIFT;\n\t\tif (centaur_mcr_type == 0) {\n\t\t\t \n\t\t\tlow = -size << PAGE_SHIFT | 0x1f;\n\t\t} else {\n\t\t\tif (type == MTRR_TYPE_UNCACHABLE)\n\t\t\t\tlow = -size << PAGE_SHIFT | 0x02;  \n\t\t\telse\n\t\t\t\tlow = -size << PAGE_SHIFT | 0x09;  \n\t\t}\n\t}\n\tcentaur_mcr[reg].high = high;\n\tcentaur_mcr[reg].low = low;\n\twrmsr(MSR_IDT_MCR0 + reg, low, high);\n}\n\nstatic int\ncentaur_validate_add_page(unsigned long base, unsigned long size, unsigned int type)\n{\n\t \n\tif (type != MTRR_TYPE_WRCOMB &&\n\t    (centaur_mcr_type == 0 || type != MTRR_TYPE_UNCACHABLE)) {\n\t\tpr_warn(\"mtrr: only write-combining%s supported\\n\",\n\t\t\t   centaur_mcr_type ? \" and uncacheable are\" : \" is\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nconst struct mtrr_ops centaur_mtrr_ops = {\n\t.var_regs          = 8,\n\t.set               = centaur_set_mcr,\n\t.get               = centaur_get_mcr,\n\t.get_free_region   = centaur_get_free_region,\n\t.validate_add_page = centaur_validate_add_page,\n\t.have_wrcomb       = positive_have_wrcomb,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}