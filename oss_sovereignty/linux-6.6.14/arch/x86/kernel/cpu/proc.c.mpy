{
  "module_name": "proc.c",
  "hash_id": "5ac225e965c42c0d0e0ac12040454eb054f5d22f431ef85074226d1eb9de40eb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/proc.c",
  "human_readable_source": "\n#include <linux/smp.h>\n#include <linux/timex.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/cpufreq.h>\n#include <asm/prctl.h>\n#include <linux/proc_fs.h>\n\n#include \"cpu.h\"\n\n#ifdef CONFIG_X86_VMX_FEATURE_NAMES\nextern const char * const x86_vmx_flags[NVMXINTS*32];\n#endif\n\n \nstatic void show_cpuinfo_core(struct seq_file *m, struct cpuinfo_x86 *c,\n\t\t\t      unsigned int cpu)\n{\n#ifdef CONFIG_SMP\n\tseq_printf(m, \"physical id\\t: %d\\n\", c->phys_proc_id);\n\tseq_printf(m, \"siblings\\t: %d\\n\",\n\t\t   cpumask_weight(topology_core_cpumask(cpu)));\n\tseq_printf(m, \"core id\\t\\t: %d\\n\", c->cpu_core_id);\n\tseq_printf(m, \"cpu cores\\t: %d\\n\", c->booted_cores);\n\tseq_printf(m, \"apicid\\t\\t: %d\\n\", c->apicid);\n\tseq_printf(m, \"initial apicid\\t: %d\\n\", c->initial_apicid);\n#endif\n}\n\n#ifdef CONFIG_X86_32\nstatic void show_cpuinfo_misc(struct seq_file *m, struct cpuinfo_x86 *c)\n{\n\tseq_printf(m,\n\t\t   \"fdiv_bug\\t: %s\\n\"\n\t\t   \"f00f_bug\\t: %s\\n\"\n\t\t   \"coma_bug\\t: %s\\n\"\n\t\t   \"fpu\\t\\t: %s\\n\"\n\t\t   \"fpu_exception\\t: %s\\n\"\n\t\t   \"cpuid level\\t: %d\\n\"\n\t\t   \"wp\\t\\t: yes\\n\",\n\t\t   boot_cpu_has_bug(X86_BUG_FDIV) ? \"yes\" : \"no\",\n\t\t   boot_cpu_has_bug(X86_BUG_F00F) ? \"yes\" : \"no\",\n\t\t   boot_cpu_has_bug(X86_BUG_COMA) ? \"yes\" : \"no\",\n\t\t   boot_cpu_has(X86_FEATURE_FPU) ? \"yes\" : \"no\",\n\t\t   boot_cpu_has(X86_FEATURE_FPU) ? \"yes\" : \"no\",\n\t\t   c->cpuid_level);\n}\n#else\nstatic void show_cpuinfo_misc(struct seq_file *m, struct cpuinfo_x86 *c)\n{\n\tseq_printf(m,\n\t\t   \"fpu\\t\\t: yes\\n\"\n\t\t   \"fpu_exception\\t: yes\\n\"\n\t\t   \"cpuid level\\t: %d\\n\"\n\t\t   \"wp\\t\\t: yes\\n\",\n\t\t   c->cpuid_level);\n}\n#endif\n\nstatic int show_cpuinfo(struct seq_file *m, void *v)\n{\n\tstruct cpuinfo_x86 *c = v;\n\tunsigned int cpu;\n\tint i;\n\n\tcpu = c->cpu_index;\n\tseq_printf(m, \"processor\\t: %u\\n\"\n\t\t   \"vendor_id\\t: %s\\n\"\n\t\t   \"cpu family\\t: %d\\n\"\n\t\t   \"model\\t\\t: %u\\n\"\n\t\t   \"model name\\t: %s\\n\",\n\t\t   cpu,\n\t\t   c->x86_vendor_id[0] ? c->x86_vendor_id : \"unknown\",\n\t\t   c->x86,\n\t\t   c->x86_model,\n\t\t   c->x86_model_id[0] ? c->x86_model_id : \"unknown\");\n\n\tif (c->x86_stepping || c->cpuid_level >= 0)\n\t\tseq_printf(m, \"stepping\\t: %d\\n\", c->x86_stepping);\n\telse\n\t\tseq_puts(m, \"stepping\\t: unknown\\n\");\n\tif (c->microcode)\n\t\tseq_printf(m, \"microcode\\t: 0x%x\\n\", c->microcode);\n\n\tif (cpu_has(c, X86_FEATURE_TSC)) {\n\t\tunsigned int freq = arch_freq_get_on_cpu(cpu);\n\n\t\tseq_printf(m, \"cpu MHz\\t\\t: %u.%03u\\n\", freq / 1000, (freq % 1000));\n\t}\n\n\t \n\tif (c->x86_cache_size)\n\t\tseq_printf(m, \"cache size\\t: %u KB\\n\", c->x86_cache_size);\n\n\tshow_cpuinfo_core(m, c, cpu);\n\tshow_cpuinfo_misc(m, c);\n\n\tseq_puts(m, \"flags\\t\\t:\");\n\tfor (i = 0; i < 32*NCAPINTS; i++)\n\t\tif (cpu_has(c, i) && x86_cap_flags[i] != NULL)\n\t\t\tseq_printf(m, \" %s\", x86_cap_flags[i]);\n\n#ifdef CONFIG_X86_VMX_FEATURE_NAMES\n\tif (cpu_has(c, X86_FEATURE_VMX) && c->vmx_capability[0]) {\n\t\tseq_puts(m, \"\\nvmx flags\\t:\");\n\t\tfor (i = 0; i < 32*NVMXINTS; i++) {\n\t\t\tif (test_bit(i, (unsigned long *)c->vmx_capability) &&\n\t\t\t    x86_vmx_flags[i] != NULL)\n\t\t\t\tseq_printf(m, \" %s\", x86_vmx_flags[i]);\n\t\t}\n\t}\n#endif\n\n\tseq_puts(m, \"\\nbugs\\t\\t:\");\n\tfor (i = 0; i < 32*NBUGINTS; i++) {\n\t\tunsigned int bug_bit = 32*NCAPINTS + i;\n\n\t\tif (cpu_has_bug(c, bug_bit) && x86_bug_flags[i])\n\t\t\tseq_printf(m, \" %s\", x86_bug_flags[i]);\n\t}\n\n\tseq_printf(m, \"\\nbogomips\\t: %lu.%02lu\\n\",\n\t\t   c->loops_per_jiffy/(500000/HZ),\n\t\t   (c->loops_per_jiffy/(5000/HZ)) % 100);\n\n#ifdef CONFIG_X86_64\n\tif (c->x86_tlbsize > 0)\n\t\tseq_printf(m, \"TLB size\\t: %d 4K pages\\n\", c->x86_tlbsize);\n#endif\n\tseq_printf(m, \"clflush size\\t: %u\\n\", c->x86_clflush_size);\n\tseq_printf(m, \"cache_alignment\\t: %d\\n\", c->x86_cache_alignment);\n\tseq_printf(m, \"address sizes\\t: %u bits physical, %u bits virtual\\n\",\n\t\t   c->x86_phys_bits, c->x86_virt_bits);\n\n\tseq_puts(m, \"power management:\");\n\tfor (i = 0; i < 32; i++) {\n\t\tif (c->x86_power & (1 << i)) {\n\t\t\tif (i < ARRAY_SIZE(x86_power_flags) &&\n\t\t\t    x86_power_flags[i])\n\t\t\t\tseq_printf(m, \"%s%s\",\n\t\t\t\t\t   x86_power_flags[i][0] ? \" \" : \"\",\n\t\t\t\t\t   x86_power_flags[i]);\n\t\t\telse\n\t\t\t\tseq_printf(m, \" [%d]\", i);\n\t\t}\n\t}\n\n\tseq_puts(m, \"\\n\\n\");\n\n\treturn 0;\n}\n\nstatic void *c_start(struct seq_file *m, loff_t *pos)\n{\n\t*pos = cpumask_next(*pos - 1, cpu_online_mask);\n\tif ((*pos) < nr_cpu_ids)\n\t\treturn &cpu_data(*pos);\n\treturn NULL;\n}\n\nstatic void *c_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn c_start(m, pos);\n}\n\nstatic void c_stop(struct seq_file *m, void *v)\n{\n}\n\nconst struct seq_operations cpuinfo_op = {\n\t.start\t= c_start,\n\t.next\t= c_next,\n\t.stop\t= c_stop,\n\t.show\t= show_cpuinfo,\n};\n\n#ifdef CONFIG_X86_USER_SHADOW_STACK\nstatic void dump_x86_features(struct seq_file *m, unsigned long features)\n{\n\tif (features & ARCH_SHSTK_SHSTK)\n\t\tseq_puts(m, \"shstk \");\n\tif (features & ARCH_SHSTK_WRSS)\n\t\tseq_puts(m, \"wrss \");\n}\n\nvoid arch_proc_pid_thread_features(struct seq_file *m, struct task_struct *task)\n{\n\tseq_puts(m, \"x86_Thread_features:\\t\");\n\tdump_x86_features(m, task->thread.features);\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"x86_Thread_features_locked:\\t\");\n\tdump_x86_features(m, task->thread.features_locked);\n\tseq_putc(m, '\\n');\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}