{
  "module_name": "topology.c",
  "hash_id": "30c9918e3ecbf7b8f89632a2f87db1fefd0f4ec517edabee2683728539ddd383",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/topology.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <asm/apic.h>\n#include <asm/memtype.h>\n#include <asm/processor.h>\n\n#include \"cpu.h\"\n\n \n#define SMT_LEVEL\t0\n\n \n#define INVALID_TYPE\t0\n#define SMT_TYPE\t1\n#define CORE_TYPE\t2\n#define DIE_TYPE\t5\n\n#define LEAFB_SUBTYPE(ecx)\t\t(((ecx) >> 8) & 0xff)\n#define BITS_SHIFT_NEXT_LEVEL(eax)\t((eax) & 0x1f)\n#define LEVEL_MAX_SIBLINGS(ebx)\t\t((ebx) & 0xffff)\n\nunsigned int __max_die_per_package __read_mostly = 1;\nEXPORT_SYMBOL(__max_die_per_package);\n\n#ifdef CONFIG_SMP\n \nstatic int check_extended_topology_leaf(int leaf)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tcpuid_count(leaf, SMT_LEVEL, &eax, &ebx, &ecx, &edx);\n\n\tif (ebx == 0 || (LEAFB_SUBTYPE(ecx) != SMT_TYPE))\n\t\treturn -1;\n\n\treturn 0;\n}\n \nstatic int detect_extended_topology_leaf(struct cpuinfo_x86 *c)\n{\n\tif (c->cpuid_level >= 0x1f) {\n\t\tif (check_extended_topology_leaf(0x1f) == 0)\n\t\t\treturn 0x1f;\n\t}\n\n\tif (c->cpuid_level >= 0xb) {\n\t\tif (check_extended_topology_leaf(0xb) == 0)\n\t\t\treturn 0xb;\n\t}\n\n\treturn -1;\n}\n#endif\n\nint detect_extended_topology_early(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tunsigned int eax, ebx, ecx, edx;\n\tint leaf;\n\n\tleaf = detect_extended_topology_leaf(c);\n\tif (leaf < 0)\n\t\treturn -1;\n\n\tset_cpu_cap(c, X86_FEATURE_XTOPOLOGY);\n\n\tcpuid_count(leaf, SMT_LEVEL, &eax, &ebx, &ecx, &edx);\n\t \n\tc->initial_apicid = edx;\n\tsmp_num_siblings = max_t(int, smp_num_siblings, LEVEL_MAX_SIBLINGS(ebx));\n#endif\n\treturn 0;\n}\n\n \nint detect_extended_topology(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tunsigned int eax, ebx, ecx, edx, sub_index;\n\tunsigned int ht_mask_width, core_plus_mask_width, die_plus_mask_width;\n\tunsigned int core_select_mask, core_level_siblings;\n\tunsigned int die_select_mask, die_level_siblings;\n\tunsigned int pkg_mask_width;\n\tbool die_level_present = false;\n\tint leaf;\n\n\tleaf = detect_extended_topology_leaf(c);\n\tif (leaf < 0)\n\t\treturn -1;\n\n\t \n\tcpuid_count(leaf, SMT_LEVEL, &eax, &ebx, &ecx, &edx);\n\tc->initial_apicid = edx;\n\tcore_level_siblings = LEVEL_MAX_SIBLINGS(ebx);\n\tsmp_num_siblings = max_t(int, smp_num_siblings, LEVEL_MAX_SIBLINGS(ebx));\n\tcore_plus_mask_width = ht_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\tdie_level_siblings = LEVEL_MAX_SIBLINGS(ebx);\n\tpkg_mask_width = die_plus_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\n\tsub_index = 1;\n\twhile (true) {\n\t\tcpuid_count(leaf, sub_index, &eax, &ebx, &ecx, &edx);\n\n\t\t \n\t\tif (LEAFB_SUBTYPE(ecx) == CORE_TYPE) {\n\t\t\tcore_level_siblings = LEVEL_MAX_SIBLINGS(ebx);\n\t\t\tcore_plus_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\t\t\tdie_level_siblings = core_level_siblings;\n\t\t\tdie_plus_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\t\t}\n\t\tif (LEAFB_SUBTYPE(ecx) == DIE_TYPE) {\n\t\t\tdie_level_present = true;\n\t\t\tdie_level_siblings = LEVEL_MAX_SIBLINGS(ebx);\n\t\t\tdie_plus_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\t\t}\n\n\t\tif (LEAFB_SUBTYPE(ecx) != INVALID_TYPE)\n\t\t\tpkg_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);\n\t\telse\n\t\t\tbreak;\n\n\t\tsub_index++;\n\t}\n\n\tcore_select_mask = (~(-1 << pkg_mask_width)) >> ht_mask_width;\n\tdie_select_mask = (~(-1 << die_plus_mask_width)) >>\n\t\t\t\tcore_plus_mask_width;\n\n\tc->cpu_core_id = apic->phys_pkg_id(c->initial_apicid,\n\t\t\t\tht_mask_width) & core_select_mask;\n\n\tif (die_level_present) {\n\t\tc->cpu_die_id = apic->phys_pkg_id(c->initial_apicid,\n\t\t\t\t\tcore_plus_mask_width) & die_select_mask;\n\t}\n\n\tc->phys_proc_id = apic->phys_pkg_id(c->initial_apicid,\n\t\t\t\tpkg_mask_width);\n\t \n\tc->apicid = apic->phys_pkg_id(c->initial_apicid, 0);\n\n\tc->x86_max_cores = (core_level_siblings / smp_num_siblings);\n\t__max_die_per_package = (die_level_siblings / core_level_siblings);\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}