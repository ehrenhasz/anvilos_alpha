{
  "module_name": "tsx.c",
  "hash_id": "9be06f33f88c289633acf0cf006dbc5c3b2a3f0c89abcd0f947ecfc08fa0e169",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/tsx.c",
  "human_readable_source": "\n \n\n#include <linux/cpufeature.h>\n\n#include <asm/cmdline.h>\n#include <asm/cpu.h>\n\n#include \"cpu.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"tsx: \" fmt\n\nenum tsx_ctrl_states tsx_ctrl_state __ro_after_init = TSX_CTRL_NOT_SUPPORTED;\n\nstatic void tsx_disable(void)\n{\n\tu64 tsx;\n\n\trdmsrl(MSR_IA32_TSX_CTRL, tsx);\n\n\t \n\ttsx |= TSX_CTRL_RTM_DISABLE;\n\n\t \n\ttsx |= TSX_CTRL_CPUID_CLEAR;\n\n\twrmsrl(MSR_IA32_TSX_CTRL, tsx);\n}\n\nstatic void tsx_enable(void)\n{\n\tu64 tsx;\n\n\trdmsrl(MSR_IA32_TSX_CTRL, tsx);\n\n\t \n\ttsx &= ~TSX_CTRL_RTM_DISABLE;\n\n\t \n\ttsx &= ~TSX_CTRL_CPUID_CLEAR;\n\n\twrmsrl(MSR_IA32_TSX_CTRL, tsx);\n}\n\nstatic enum tsx_ctrl_states x86_get_tsx_auto_mode(void)\n{\n\tif (boot_cpu_has_bug(X86_BUG_TAA))\n\t\treturn TSX_CTRL_DISABLE;\n\n\treturn TSX_CTRL_ENABLE;\n}\n\n \nstatic void tsx_clear_cpuid(void)\n{\n\tu64 msr;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_RTM_ALWAYS_ABORT) &&\n\t    boot_cpu_has(X86_FEATURE_TSX_FORCE_ABORT)) {\n\t\trdmsrl(MSR_TSX_FORCE_ABORT, msr);\n\t\tmsr |= MSR_TFA_TSX_CPUID_CLEAR;\n\t\twrmsrl(MSR_TSX_FORCE_ABORT, msr);\n\t} else if (cpu_feature_enabled(X86_FEATURE_MSR_TSX_CTRL)) {\n\t\trdmsrl(MSR_IA32_TSX_CTRL, msr);\n\t\tmsr |= TSX_CTRL_CPUID_CLEAR;\n\t\twrmsrl(MSR_IA32_TSX_CTRL, msr);\n\t}\n}\n\n \nstatic void tsx_dev_mode_disable(void)\n{\n\tu64 mcu_opt_ctrl;\n\n\t \n\tif (!boot_cpu_has_bug(X86_BUG_TAA) ||\n\t    !cpu_feature_enabled(X86_FEATURE_MSR_TSX_CTRL) ||\n\t    !cpu_feature_enabled(X86_FEATURE_SRBDS_CTRL))\n\t\treturn;\n\n\trdmsrl(MSR_IA32_MCU_OPT_CTRL, mcu_opt_ctrl);\n\n\tif (mcu_opt_ctrl & RTM_ALLOW) {\n\t\tmcu_opt_ctrl &= ~RTM_ALLOW;\n\t\twrmsrl(MSR_IA32_MCU_OPT_CTRL, mcu_opt_ctrl);\n\t\tsetup_force_cpu_cap(X86_FEATURE_RTM_ALWAYS_ABORT);\n\t}\n}\n\nvoid __init tsx_init(void)\n{\n\tchar arg[5] = {};\n\tint ret;\n\n\ttsx_dev_mode_disable();\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_RTM_ALWAYS_ABORT)) {\n\t\ttsx_ctrl_state = TSX_CTRL_RTM_ALWAYS_ABORT;\n\t\ttsx_clear_cpuid();\n\t\tsetup_clear_cpu_cap(X86_FEATURE_RTM);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_HLE);\n\t\treturn;\n\t}\n\n\t \n\tif (x86_read_arch_cap_msr() & ARCH_CAP_TSX_CTRL_MSR) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_MSR_TSX_CTRL);\n\t} else {\n\t\ttsx_ctrl_state = TSX_CTRL_NOT_SUPPORTED;\n\t\treturn;\n\t}\n\n\tret = cmdline_find_option(boot_command_line, \"tsx\", arg, sizeof(arg));\n\tif (ret >= 0) {\n\t\tif (!strcmp(arg, \"on\")) {\n\t\t\ttsx_ctrl_state = TSX_CTRL_ENABLE;\n\t\t} else if (!strcmp(arg, \"off\")) {\n\t\t\ttsx_ctrl_state = TSX_CTRL_DISABLE;\n\t\t} else if (!strcmp(arg, \"auto\")) {\n\t\t\ttsx_ctrl_state = x86_get_tsx_auto_mode();\n\t\t} else {\n\t\t\ttsx_ctrl_state = TSX_CTRL_DISABLE;\n\t\t\tpr_err(\"invalid option, defaulting to off\\n\");\n\t\t}\n\t} else {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_X86_INTEL_TSX_MODE_AUTO))\n\t\t\ttsx_ctrl_state = x86_get_tsx_auto_mode();\n\t\telse if (IS_ENABLED(CONFIG_X86_INTEL_TSX_MODE_OFF))\n\t\t\ttsx_ctrl_state = TSX_CTRL_DISABLE;\n\t\telse\n\t\t\ttsx_ctrl_state = TSX_CTRL_ENABLE;\n\t}\n\n\tif (tsx_ctrl_state == TSX_CTRL_DISABLE) {\n\t\ttsx_disable();\n\n\t\t \n\t\tsetup_clear_cpu_cap(X86_FEATURE_RTM);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_HLE);\n\t} else if (tsx_ctrl_state == TSX_CTRL_ENABLE) {\n\n\t\t \n\t\ttsx_enable();\n\n\t\t \n\t\tsetup_force_cpu_cap(X86_FEATURE_RTM);\n\t\tsetup_force_cpu_cap(X86_FEATURE_HLE);\n\t}\n}\n\nvoid tsx_ap_init(void)\n{\n\ttsx_dev_mode_disable();\n\n\tif (tsx_ctrl_state == TSX_CTRL_ENABLE)\n\t\ttsx_enable();\n\telse if (tsx_ctrl_state == TSX_CTRL_DISABLE)\n\t\ttsx_disable();\n\telse if (tsx_ctrl_state == TSX_CTRL_RTM_ALWAYS_ABORT)\n\t\t \n\t\ttsx_clear_cpuid();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}