{
  "module_name": "feat_ctl.c",
  "hash_id": "cb95a071c810b811f092e0d2e2cfd9531267ef109e27c0031c21b1d20e9be581",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/feat_ctl.c",
  "human_readable_source": "\n#include <linux/tboot.h>\n\n#include <asm/cpu.h>\n#include <asm/cpufeature.h>\n#include <asm/msr-index.h>\n#include <asm/processor.h>\n#include <asm/vmx.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt)\t\"x86/cpu: \" fmt\n\n#ifdef CONFIG_X86_VMX_FEATURE_NAMES\nenum vmx_feature_leafs {\n\tMISC_FEATURES = 0,\n\tPRIMARY_CTLS,\n\tSECONDARY_CTLS,\n\tTERTIARY_CTLS_LOW,\n\tTERTIARY_CTLS_HIGH,\n\tNR_VMX_FEATURE_WORDS,\n};\n\n#define VMX_F(x) BIT(VMX_FEATURE_##x & 0x1f)\n\nstatic void init_vmx_capabilities(struct cpuinfo_x86 *c)\n{\n\tu32 supported, funcs, ept, vpid, ign, low, high;\n\n\tBUILD_BUG_ON(NVMXINTS != NR_VMX_FEATURE_WORDS);\n\n\t \n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS, ign, supported);\n\tc->vmx_capability[PRIMARY_CTLS] = supported;\n\n\trdmsr_safe(MSR_IA32_VMX_PROCBASED_CTLS2, &ign, &supported);\n\tc->vmx_capability[SECONDARY_CTLS] = supported;\n\n\t \n\trdmsr_safe(MSR_IA32_VMX_PROCBASED_CTLS3, &low, &high);\n\tc->vmx_capability[TERTIARY_CTLS_LOW] = low;\n\tc->vmx_capability[TERTIARY_CTLS_HIGH] = high;\n\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS, ign, supported);\n\trdmsr_safe(MSR_IA32_VMX_VMFUNC, &ign, &funcs);\n\n\t \n\trdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP, &ept, &vpid);\n\n\t \n\tWARN_ON_ONCE(supported >> 16);\n\tWARN_ON_ONCE(funcs >> 4);\n\tc->vmx_capability[MISC_FEATURES] = (supported & 0xffff) |\n\t\t\t\t\t   ((vpid & 0x1) << 16) |\n\t\t\t\t\t   ((funcs & 0xf) << 28);\n\n\t \n\tif (ept & VMX_EPT_EXECUTE_ONLY_BIT)\n\t\tc->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_EXECUTE_ONLY);\n\tif (ept & VMX_EPT_AD_BIT)\n\t\tc->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_AD);\n\tif (ept & VMX_EPT_1GB_PAGE_BIT)\n\t\tc->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_1GB);\n\n\t \n\tif ((c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR)) &&\n\t    (c->vmx_capability[SECONDARY_CTLS] & VMX_F(VIRT_APIC_ACCESSES)))\n\t\tc->vmx_capability[MISC_FEATURES] |= VMX_F(FLEXPRIORITY);\n\n\tif ((c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR)) &&\n\t    (c->vmx_capability[SECONDARY_CTLS] & VMX_F(APIC_REGISTER_VIRT)) &&\n\t    (c->vmx_capability[SECONDARY_CTLS] & VMX_F(VIRT_INTR_DELIVERY)) &&\n\t    (c->vmx_capability[MISC_FEATURES] & VMX_F(POSTED_INTR)))\n\t\tc->vmx_capability[MISC_FEATURES] |= VMX_F(APICV);\n\n\t \n\tif (c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR))\n\t\tset_cpu_cap(c, X86_FEATURE_TPR_SHADOW);\n\tif (c->vmx_capability[MISC_FEATURES] & VMX_F(FLEXPRIORITY))\n\t\tset_cpu_cap(c, X86_FEATURE_FLEXPRIORITY);\n\tif (c->vmx_capability[MISC_FEATURES] & VMX_F(VIRTUAL_NMIS))\n\t\tset_cpu_cap(c, X86_FEATURE_VNMI);\n\tif (c->vmx_capability[SECONDARY_CTLS] & VMX_F(EPT))\n\t\tset_cpu_cap(c, X86_FEATURE_EPT);\n\tif (c->vmx_capability[MISC_FEATURES] & VMX_F(EPT_AD))\n\t\tset_cpu_cap(c, X86_FEATURE_EPT_AD);\n\tif (c->vmx_capability[MISC_FEATURES] & VMX_F(VPID))\n\t\tset_cpu_cap(c, X86_FEATURE_VPID);\n}\n#endif  \n\nstatic int __init nosgx(char *str)\n{\n\tsetup_clear_cpu_cap(X86_FEATURE_SGX);\n\n\treturn 0;\n}\n\nearly_param(\"nosgx\", nosgx);\n\nvoid init_ia32_feat_ctl(struct cpuinfo_x86 *c)\n{\n\tbool enable_sgx_kvm = false, enable_sgx_driver = false;\n\tbool tboot = tboot_enabled();\n\tbool enable_vmx;\n\tu64 msr;\n\n\tif (rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr)) {\n\t\tclear_cpu_cap(c, X86_FEATURE_VMX);\n\t\tclear_cpu_cap(c, X86_FEATURE_SGX);\n\t\treturn;\n\t}\n\n\tenable_vmx = cpu_has(c, X86_FEATURE_VMX) &&\n\t\t     IS_ENABLED(CONFIG_KVM_INTEL);\n\n\tif (cpu_has(c, X86_FEATURE_SGX) && IS_ENABLED(CONFIG_X86_SGX)) {\n\t\t \n\t\tenable_sgx_driver = cpu_has(c, X86_FEATURE_SGX_LC);\n\t\tenable_sgx_kvm = enable_vmx && IS_ENABLED(CONFIG_X86_SGX_KVM);\n\t}\n\n\tif (msr & FEAT_CTL_LOCKED)\n\t\tgoto update_caps;\n\n\t \n\tmsr = FEAT_CTL_LOCKED;\n\n\t \n\tif (enable_vmx) {\n\t\tmsr |= FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;\n\n\t\tif (tboot)\n\t\t\tmsr |= FEAT_CTL_VMX_ENABLED_INSIDE_SMX;\n\t}\n\n\tif (enable_sgx_kvm || enable_sgx_driver) {\n\t\tmsr |= FEAT_CTL_SGX_ENABLED;\n\t\tif (enable_sgx_driver)\n\t\t\tmsr |= FEAT_CTL_SGX_LC_ENABLED;\n\t}\n\n\twrmsrl(MSR_IA32_FEAT_CTL, msr);\n\nupdate_caps:\n\tset_cpu_cap(c, X86_FEATURE_MSR_IA32_FEAT_CTL);\n\n\tif (!cpu_has(c, X86_FEATURE_VMX))\n\t\tgoto update_sgx;\n\n\tif ( (tboot && !(msr & FEAT_CTL_VMX_ENABLED_INSIDE_SMX)) ||\n\t    (!tboot && !(msr & FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX))) {\n\t\tif (IS_ENABLED(CONFIG_KVM_INTEL))\n\t\t\tpr_err_once(\"VMX (%s TXT) disabled by BIOS\\n\",\n\t\t\t\t    tboot ? \"inside\" : \"outside\");\n\t\tclear_cpu_cap(c, X86_FEATURE_VMX);\n\t} else {\n#ifdef CONFIG_X86_VMX_FEATURE_NAMES\n\t\tinit_vmx_capabilities(c);\n#endif\n\t}\n\nupdate_sgx:\n\tif (!(msr & FEAT_CTL_SGX_ENABLED)) {\n\t\tif (enable_sgx_kvm || enable_sgx_driver)\n\t\t\tpr_err_once(\"SGX disabled by BIOS.\\n\");\n\t\tclear_cpu_cap(c, X86_FEATURE_SGX);\n\t\treturn;\n\t}\n\n\t \n\tif (!cpu_has(c, X86_FEATURE_VMX) && enable_sgx_kvm) {\n\t\tpr_err_once(\"SGX virtualization disabled due to lack of VMX.\\n\");\n\t\tenable_sgx_kvm = 0;\n\t}\n\n\tif (!(msr & FEAT_CTL_SGX_LC_ENABLED) && enable_sgx_driver) {\n\t\tif (!enable_sgx_kvm) {\n\t\t\tpr_err_once(\"SGX Launch Control is locked. Disable SGX.\\n\");\n\t\t\tclear_cpu_cap(c, X86_FEATURE_SGX);\n\t\t} else {\n\t\t\tpr_err_once(\"SGX Launch Control is locked. Support SGX virtualization only.\\n\");\n\t\t\tclear_cpu_cap(c, X86_FEATURE_SGX_LC);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}