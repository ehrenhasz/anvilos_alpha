{
  "module_name": "mshyperv.c",
  "hash_id": "99ac3c644bbfc06130f22408d649da3f2d9918216648e42b78fbd24c552778cb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mshyperv.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/efi.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/i8253.h>\n#include <linux/random.h>\n#include <asm/processor.h>\n#include <asm/hypervisor.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/mshyperv.h>\n#include <asm/desc.h>\n#include <asm/idtentry.h>\n#include <asm/irq_regs.h>\n#include <asm/i8259.h>\n#include <asm/apic.h>\n#include <asm/timer.h>\n#include <asm/reboot.h>\n#include <asm/nmi.h>\n#include <clocksource/hyperv_timer.h>\n#include <asm/numa.h>\n#include <asm/svm.h>\n\n \nbool hv_root_partition;\n \nbool hv_nested;\nstruct ms_hyperv_info ms_hyperv;\n\n \nbool hyperv_paravisor_present __ro_after_init;\nEXPORT_SYMBOL_GPL(hyperv_paravisor_present);\n\n#if IS_ENABLED(CONFIG_HYPERV)\nstatic inline unsigned int hv_get_nested_reg(unsigned int reg)\n{\n\tif (hv_is_sint_reg(reg))\n\t\treturn reg - HV_REGISTER_SINT0 + HV_REGISTER_NESTED_SINT0;\n\n\tswitch (reg) {\n\tcase HV_REGISTER_SIMP:\n\t\treturn HV_REGISTER_NESTED_SIMP;\n\tcase HV_REGISTER_SIEFP:\n\t\treturn HV_REGISTER_NESTED_SIEFP;\n\tcase HV_REGISTER_SVERSION:\n\t\treturn HV_REGISTER_NESTED_SVERSION;\n\tcase HV_REGISTER_SCONTROL:\n\t\treturn HV_REGISTER_NESTED_SCONTROL;\n\tcase HV_REGISTER_EOM:\n\t\treturn HV_REGISTER_NESTED_EOM;\n\tdefault:\n\t\treturn reg;\n\t}\n}\n\nu64 hv_get_non_nested_register(unsigned int reg)\n{\n\tu64 value;\n\n\tif (hv_is_synic_reg(reg) && ms_hyperv.paravisor_present)\n\t\thv_ivm_msr_read(reg, &value);\n\telse\n\t\trdmsrl(reg, value);\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(hv_get_non_nested_register);\n\nvoid hv_set_non_nested_register(unsigned int reg, u64 value)\n{\n\tif (hv_is_synic_reg(reg) && ms_hyperv.paravisor_present) {\n\t\thv_ivm_msr_write(reg, value);\n\n\t\t \n\t\tif (hv_is_sint_reg(reg))\n\t\t\twrmsrl(reg, value | 1 << 20);\n\t} else {\n\t\twrmsrl(reg, value);\n\t}\n}\nEXPORT_SYMBOL_GPL(hv_set_non_nested_register);\n\nu64 hv_get_register(unsigned int reg)\n{\n\tif (hv_nested)\n\t\treg = hv_get_nested_reg(reg);\n\n\treturn hv_get_non_nested_register(reg);\n}\nEXPORT_SYMBOL_GPL(hv_get_register);\n\nvoid hv_set_register(unsigned int reg, u64 value)\n{\n\tif (hv_nested)\n\t\treg = hv_get_nested_reg(reg);\n\n\thv_set_non_nested_register(reg, value);\n}\nEXPORT_SYMBOL_GPL(hv_set_register);\n\nstatic void (*vmbus_handler)(void);\nstatic void (*hv_stimer0_handler)(void);\nstatic void (*hv_kexec_handler)(void);\nstatic void (*hv_crash_handler)(struct pt_regs *regs);\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_hyperv_callback)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tinc_irq_stat(irq_hv_callback_count);\n\tif (vmbus_handler)\n\t\tvmbus_handler();\n\n\tif (ms_hyperv.hints & HV_DEPRECATING_AEOI_RECOMMENDED)\n\t\tapic_eoi();\n\n\tset_irq_regs(old_regs);\n}\n\nvoid hv_setup_vmbus_handler(void (*handler)(void))\n{\n\tvmbus_handler = handler;\n}\n\nvoid hv_remove_vmbus_handler(void)\n{\n\t \n\tvmbus_handler = NULL;\n}\n\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_hyperv_stimer0)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tinc_irq_stat(hyperv_stimer0_count);\n\tif (hv_stimer0_handler)\n\t\thv_stimer0_handler();\n\tadd_interrupt_randomness(HYPERV_STIMER0_VECTOR);\n\tapic_eoi();\n\n\tset_irq_regs(old_regs);\n}\n\n \nvoid hv_setup_stimer0_handler(void (*handler)(void))\n{\n\thv_stimer0_handler = handler;\n}\n\nvoid hv_remove_stimer0_handler(void)\n{\n\t \n\thv_stimer0_handler = NULL;\n}\n\nvoid hv_setup_kexec_handler(void (*handler)(void))\n{\n\thv_kexec_handler = handler;\n}\n\nvoid hv_remove_kexec_handler(void)\n{\n\thv_kexec_handler = NULL;\n}\n\nvoid hv_setup_crash_handler(void (*handler)(struct pt_regs *regs))\n{\n\thv_crash_handler = handler;\n}\n\nvoid hv_remove_crash_handler(void)\n{\n\thv_crash_handler = NULL;\n}\n\n#ifdef CONFIG_KEXEC_CORE\nstatic void hv_machine_shutdown(void)\n{\n\tif (kexec_in_progress && hv_kexec_handler)\n\t\thv_kexec_handler();\n\n\t \n\tif (kexec_in_progress && hyperv_init_cpuhp > 0)\n\t\tcpuhp_remove_state(hyperv_init_cpuhp);\n\n\t \n\tnative_machine_shutdown();\n\n\t \n\tif (kexec_in_progress)\n\t\thyperv_cleanup();\n}\n\nstatic void hv_machine_crash_shutdown(struct pt_regs *regs)\n{\n\tif (hv_crash_handler)\n\t\thv_crash_handler(regs);\n\n\t \n\tnative_machine_crash_shutdown(regs);\n\n\t \n\thyperv_cleanup();\n}\n#endif  \n#endif  \n\nstatic uint32_t  __init ms_hyperv_platform(void)\n{\n\tu32 eax;\n\tu32 hyp_signature[3];\n\n\tif (!boot_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\treturn 0;\n\n\tcpuid(HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS,\n\t      &eax, &hyp_signature[0], &hyp_signature[1], &hyp_signature[2]);\n\n\tif (eax < HYPERV_CPUID_MIN || eax > HYPERV_CPUID_MAX ||\n\t    memcmp(\"Microsoft Hv\", hyp_signature, 12))\n\t\treturn 0;\n\n\t \n\teax = cpuid_eax(HYPERV_CPUID_FEATURES);\n\tif (!(eax & HV_MSR_HYPERCALL_AVAILABLE)) {\n\t\tpr_warn(\"x86/hyperv: HYPERCALL MSR not available.\\n\");\n\t\treturn 0;\n\t}\n\tif (!(eax & HV_MSR_VP_INDEX_AVAILABLE)) {\n\t\tpr_warn(\"x86/hyperv: VP_INDEX MSR not available.\\n\");\n\t\treturn 0;\n\t}\n\n\treturn HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS;\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\n \nstatic int hv_nmi_unknown(unsigned int val, struct pt_regs *regs)\n{\n\tstatic atomic_t nmi_cpu = ATOMIC_INIT(-1);\n\n\tif (!unknown_nmi_panic)\n\t\treturn NMI_DONE;\n\n\tif (atomic_cmpxchg(&nmi_cpu, -1, raw_smp_processor_id()) != -1)\n\t\treturn NMI_HANDLED;\n\n\treturn NMI_DONE;\n}\n#endif\n\nstatic unsigned long hv_get_tsc_khz(void)\n{\n\tunsigned long freq;\n\n\trdmsrl(HV_X64_MSR_TSC_FREQUENCY, freq);\n\n\treturn freq / 1000;\n}\n\n#if defined(CONFIG_SMP) && IS_ENABLED(CONFIG_HYPERV)\nstatic void __init hv_smp_prepare_boot_cpu(void)\n{\n\tnative_smp_prepare_boot_cpu();\n#if defined(CONFIG_X86_64) && defined(CONFIG_PARAVIRT_SPINLOCKS)\n\thv_init_spinlocks();\n#endif\n}\n\nstatic void __init hv_smp_prepare_cpus(unsigned int max_cpus)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tint ret;\n#endif\n\n\tnative_smp_prepare_cpus(max_cpus);\n\n\t \n\tif (!ms_hyperv.paravisor_present && hv_isolation_type_snp()) {\n\t\tapic->wakeup_secondary_cpu_64 = hv_snp_boot_ap;\n\t\treturn;\n\t}\n\n#ifdef CONFIG_X86_64\n\tfor_each_present_cpu(i) {\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tret = hv_call_add_logical_proc(numa_cpu_node(i), i, cpu_physical_id(i));\n\t\tBUG_ON(ret);\n\t}\n\n\tfor_each_present_cpu(i) {\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tret = hv_call_create_vp(numa_cpu_node(i), hv_current_partition_id, i, i);\n\t\tBUG_ON(ret);\n\t}\n#endif\n}\n#endif\n\n \nstatic void __init reduced_hw_init(void)\n{\n\tx86_init.timers.timer_init\t= x86_init_noop;\n\tx86_init.irqs.pre_vector_init\t= x86_init_noop;\n}\n\nstatic void __init ms_hyperv_init_platform(void)\n{\n\tint hv_max_functions_eax;\n\tint hv_host_info_eax;\n\tint hv_host_info_ebx;\n\tint hv_host_info_ecx;\n\tint hv_host_info_edx;\n\n#ifdef CONFIG_PARAVIRT\n\tpv_info.name = \"Hyper-V\";\n#endif\n\n\t \n\tms_hyperv.features = cpuid_eax(HYPERV_CPUID_FEATURES);\n\tms_hyperv.priv_high = cpuid_ebx(HYPERV_CPUID_FEATURES);\n\tms_hyperv.misc_features = cpuid_edx(HYPERV_CPUID_FEATURES);\n\tms_hyperv.hints    = cpuid_eax(HYPERV_CPUID_ENLIGHTMENT_INFO);\n\n\thv_max_functions_eax = cpuid_eax(HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS);\n\n\tpr_info(\"Hyper-V: privilege flags low 0x%x, high 0x%x, hints 0x%x, misc 0x%x\\n\",\n\t\tms_hyperv.features, ms_hyperv.priv_high, ms_hyperv.hints,\n\t\tms_hyperv.misc_features);\n\n\tms_hyperv.max_vp_index = cpuid_eax(HYPERV_CPUID_IMPLEMENT_LIMITS);\n\tms_hyperv.max_lp_index = cpuid_ebx(HYPERV_CPUID_IMPLEMENT_LIMITS);\n\n\tpr_debug(\"Hyper-V: max %u virtual processors, %u logical processors\\n\",\n\t\t ms_hyperv.max_vp_index, ms_hyperv.max_lp_index);\n\n\t \n\tif ((ms_hyperv.priv_high & HV_CPU_MANAGEMENT) &&\n\t    !(ms_hyperv.priv_high & HV_ISOLATION)) {\n\t\thv_root_partition = true;\n\t\tpr_info(\"Hyper-V: running as root partition\\n\");\n\t}\n\n\tif (ms_hyperv.hints & HV_X64_HYPERV_NESTED) {\n\t\thv_nested = true;\n\t\tpr_info(\"Hyper-V: running on a nested hypervisor\\n\");\n\t}\n\n\t \n\tif (hv_max_functions_eax >= HYPERV_CPUID_VERSION) {\n\t\thv_host_info_eax = cpuid_eax(HYPERV_CPUID_VERSION);\n\t\thv_host_info_ebx = cpuid_ebx(HYPERV_CPUID_VERSION);\n\t\thv_host_info_ecx = cpuid_ecx(HYPERV_CPUID_VERSION);\n\t\thv_host_info_edx = cpuid_edx(HYPERV_CPUID_VERSION);\n\n\t\tpr_info(\"Hyper-V: Host Build %d.%d.%d.%d-%d-%d\\n\",\n\t\t\thv_host_info_ebx >> 16, hv_host_info_ebx & 0xFFFF,\n\t\t\thv_host_info_eax, hv_host_info_edx & 0xFFFFFF,\n\t\t\thv_host_info_ecx, hv_host_info_edx >> 24);\n\t}\n\n\tif (ms_hyperv.features & HV_ACCESS_FREQUENCY_MSRS &&\n\t    ms_hyperv.misc_features & HV_FEATURE_FREQUENCY_MSRS_AVAILABLE) {\n\t\tx86_platform.calibrate_tsc = hv_get_tsc_khz;\n\t\tx86_platform.calibrate_cpu = hv_get_tsc_khz;\n\t}\n\n\tif (ms_hyperv.priv_high & HV_ISOLATION) {\n\t\tms_hyperv.isolation_config_a = cpuid_eax(HYPERV_CPUID_ISOLATION_CONFIG);\n\t\tms_hyperv.isolation_config_b = cpuid_ebx(HYPERV_CPUID_ISOLATION_CONFIG);\n\n\t\tif (ms_hyperv.shared_gpa_boundary_active)\n\t\t\tms_hyperv.shared_gpa_boundary =\n\t\t\t\tBIT_ULL(ms_hyperv.shared_gpa_boundary_bits);\n\n\t\thyperv_paravisor_present = !!ms_hyperv.paravisor_present;\n\n\t\tpr_info(\"Hyper-V: Isolation Config: Group A 0x%x, Group B 0x%x\\n\",\n\t\t\tms_hyperv.isolation_config_a, ms_hyperv.isolation_config_b);\n\n\n\t\tif (hv_get_isolation_type() == HV_ISOLATION_TYPE_SNP) {\n\t\t\tstatic_branch_enable(&isolation_type_snp);\n\t\t} else if (hv_get_isolation_type() == HV_ISOLATION_TYPE_TDX) {\n\t\t\tstatic_branch_enable(&isolation_type_tdx);\n\n\t\t\t \n\t\t\tms_hyperv.hints &= ~HV_X64_APIC_ACCESS_RECOMMENDED;\n\n\t\t\tif (!ms_hyperv.paravisor_present) {\n\t\t\t\t \n\t\t\t\tms_hyperv.features &= ~HV_MSR_REFERENCE_TSC_AVAILABLE;\n\n\t\t\t\t \n\t\t\t\tms_hyperv.misc_features &= ~HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;\n\n\t\t\t\t \n\t\t\t\tms_hyperv.hints &= ~HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;\n\n\t\t\t\tx86_init.acpi.reduced_hw_early_init = reduced_hw_init;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hv_max_functions_eax >= HYPERV_CPUID_NESTED_FEATURES) {\n\t\tms_hyperv.nested_features =\n\t\t\tcpuid_eax(HYPERV_CPUID_NESTED_FEATURES);\n\t\tpr_info(\"Hyper-V: Nested features: 0x%x\\n\",\n\t\t\tms_hyperv.nested_features);\n\t}\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tif (ms_hyperv.features & HV_ACCESS_FREQUENCY_MSRS &&\n\t    ms_hyperv.misc_features & HV_FEATURE_FREQUENCY_MSRS_AVAILABLE) {\n\t\t \n\t\tu64\thv_lapic_frequency;\n\n\t\trdmsrl(HV_X64_MSR_APIC_FREQUENCY, hv_lapic_frequency);\n\t\thv_lapic_frequency = div_u64(hv_lapic_frequency, HZ);\n\t\tlapic_timer_period = hv_lapic_frequency;\n\t\tpr_info(\"Hyper-V: LAPIC Timer Frequency: %#x\\n\",\n\t\t\tlapic_timer_period);\n\t}\n\n\tregister_nmi_handler(NMI_UNKNOWN, hv_nmi_unknown, NMI_FLAG_FIRST,\n\t\t\t     \"hv_nmi_unknown\");\n#endif\n\n#ifdef CONFIG_X86_IO_APIC\n\tno_timer_check = 1;\n#endif\n\n#if IS_ENABLED(CONFIG_HYPERV) && defined(CONFIG_KEXEC_CORE)\n\tmachine_ops.shutdown = hv_machine_shutdown;\n\tmachine_ops.crash_shutdown = hv_machine_crash_shutdown;\n#endif\n\tif (ms_hyperv.features & HV_ACCESS_TSC_INVARIANT) {\n\t\t \n\t\twrmsrl(HV_X64_MSR_TSC_INVARIANT_CONTROL, HV_EXPOSE_INVARIANT_TSC);\n\t\tsetup_force_cpu_cap(X86_FEATURE_TSC_RELIABLE);\n\t}\n\n\t \n\tif (efi_enabled(EFI_BOOT))\n\t\tx86_platform.get_nmi_reason = hv_get_nmi_reason;\n\n\t \n\ti8253_clear_counter_on_shutdown = false;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif ((hv_get_isolation_type() == HV_ISOLATION_TYPE_VBS) ||\n\t    ms_hyperv.paravisor_present)\n\t\thv_vtom_init();\n\t \n\tx86_platform.apic_post_init = hyperv_init;\n\thyperv_setup_mmu_ops();\n\t \n\talloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, asm_sysvec_hyperv_callback);\n\n\t \n\tif (ms_hyperv.features & HV_ACCESS_REENLIGHTENMENT) {\n\t\talloc_intr_gate(HYPERV_REENLIGHTENMENT_VECTOR,\n\t\t\t\tasm_sysvec_hyperv_reenlightenment);\n\t}\n\n\t \n\tif (ms_hyperv.misc_features & HV_STIMER_DIRECT_MODE_AVAILABLE) {\n\t\talloc_intr_gate(HYPERV_STIMER0_VECTOR,\n\t\t\t\tasm_sysvec_hyperv_stimer0);\n\t}\n\n# ifdef CONFIG_SMP\n\tsmp_ops.smp_prepare_boot_cpu = hv_smp_prepare_boot_cpu;\n\tif (hv_root_partition ||\n\t    (!ms_hyperv.paravisor_present && hv_isolation_type_snp()))\n\t\tsmp_ops.smp_prepare_cpus = hv_smp_prepare_cpus;\n# endif\n\n\t \n# ifdef CONFIG_X86_X2APIC\n\tif (x2apic_supported())\n\t\tx2apic_phys = 1;\n# endif\n\n\t \n\thv_init_clocksource();\n\thv_vtl_init_platform();\n#endif\n\t \n\tif (!(ms_hyperv.features & HV_ACCESS_TSC_INVARIANT))\n\t\tmark_tsc_unstable(\"running on Hyper-V\");\n\n\thardlockup_detector_disable();\n}\n\nstatic bool __init ms_hyperv_x2apic_available(void)\n{\n\treturn x2apic_supported();\n}\n\n \nstatic bool __init ms_hyperv_msi_ext_dest_id(void)\n{\n\tu32 eax;\n\n\teax = cpuid_eax(HYPERV_CPUID_VIRT_STACK_INTERFACE);\n\tif (eax != HYPERV_VS_INTERFACE_EAX_SIGNATURE)\n\t\treturn false;\n\n\teax = cpuid_eax(HYPERV_CPUID_VIRT_STACK_PROPERTIES);\n\treturn eax & HYPERV_VS_PROPERTIES_EAX_EXTENDED_IOAPIC_RTE;\n}\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nstatic void hv_sev_es_hcall_prepare(struct ghcb *ghcb, struct pt_regs *regs)\n{\n\t \n\tghcb_set_rcx(ghcb, regs->cx);\n\tghcb_set_rdx(ghcb, regs->dx);\n\tghcb_set_r8(ghcb, regs->r8);\n}\n\nstatic bool hv_sev_es_hcall_finish(struct ghcb *ghcb, struct pt_regs *regs)\n{\n\t \n\treturn true;\n}\n#endif\n\nconst __initconst struct hypervisor_x86 x86_hyper_ms_hyperv = {\n\t.name\t\t\t= \"Microsoft Hyper-V\",\n\t.detect\t\t\t= ms_hyperv_platform,\n\t.type\t\t\t= X86_HYPER_MS_HYPERV,\n\t.init.x2apic_available\t= ms_hyperv_x2apic_available,\n\t.init.msi_ext_dest_id\t= ms_hyperv_msi_ext_dest_id,\n\t.init.init_platform\t= ms_hyperv_init_platform,\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n\t.runtime.sev_es_hcall_prepare = hv_sev_es_hcall_prepare,\n\t.runtime.sev_es_hcall_finish = hv_sev_es_hcall_finish,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}