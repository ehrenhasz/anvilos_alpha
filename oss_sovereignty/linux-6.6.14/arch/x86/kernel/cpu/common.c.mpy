{
  "module_name": "common.c",
  "hash_id": "492f964d84adaf6b85a5fed1f602fb0983d352fed76777970146d0ac4e2ecf38",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/common.c",
  "human_readable_source": "\n \n#define USE_EARLY_PGTABLE_L5\n\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/task.h>\n#include <linux/sched/smt.h>\n#include <linux/init.h>\n#include <linux/kprobes.h>\n#include <linux/kgdb.h>\n#include <linux/mem_encrypt.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/io.h>\n#include <linux/syscore_ops.h>\n#include <linux/pgtable.h>\n#include <linux/stackprotector.h>\n#include <linux/utsname.h>\n\n#include <asm/alternative.h>\n#include <asm/cmdline.h>\n#include <asm/perf_event.h>\n#include <asm/mmu_context.h>\n#include <asm/doublefault.h>\n#include <asm/archrandom.h>\n#include <asm/hypervisor.h>\n#include <asm/processor.h>\n#include <asm/tlbflush.h>\n#include <asm/debugreg.h>\n#include <asm/sections.h>\n#include <asm/vsyscall.h>\n#include <linux/topology.h>\n#include <linux/cpumask.h>\n#include <linux/atomic.h>\n#include <asm/proto.h>\n#include <asm/setup.h>\n#include <asm/apic.h>\n#include <asm/desc.h>\n#include <asm/fpu/api.h>\n#include <asm/mtrr.h>\n#include <asm/hwcap2.h>\n#include <linux/numa.h>\n#include <asm/numa.h>\n#include <asm/asm.h>\n#include <asm/bugs.h>\n#include <asm/cpu.h>\n#include <asm/mce.h>\n#include <asm/msr.h>\n#include <asm/cacheinfo.h>\n#include <asm/memtype.h>\n#include <asm/microcode.h>\n#include <asm/intel-family.h>\n#include <asm/cpu_device_id.h>\n#include <asm/uv/uv.h>\n#include <asm/set_memory.h>\n#include <asm/traps.h>\n#include <asm/sev.h>\n\n#include \"cpu.h\"\n\nu32 elf_hwcap2 __read_mostly;\n\n \nint smp_num_siblings = 1;\nEXPORT_SYMBOL(smp_num_siblings);\n\n \nDEFINE_PER_CPU_READ_MOSTLY(u16, cpu_llc_id) = BAD_APICID;\n\nu16 get_llc_id(unsigned int cpu)\n{\n\treturn per_cpu(cpu_llc_id, cpu);\n}\nEXPORT_SYMBOL_GPL(get_llc_id);\n\n \nDEFINE_PER_CPU_READ_MOSTLY(u16, cpu_l2c_id) = BAD_APICID;\n\nstatic struct ppin_info {\n\tint\tfeature;\n\tint\tmsr_ppin_ctl;\n\tint\tmsr_ppin;\n} ppin_info[] = {\n\t[X86_VENDOR_INTEL] = {\n\t\t.feature = X86_FEATURE_INTEL_PPIN,\n\t\t.msr_ppin_ctl = MSR_PPIN_CTL,\n\t\t.msr_ppin = MSR_PPIN\n\t},\n\t[X86_VENDOR_AMD] = {\n\t\t.feature = X86_FEATURE_AMD_PPIN,\n\t\t.msr_ppin_ctl = MSR_AMD_PPIN_CTL,\n\t\t.msr_ppin = MSR_AMD_PPIN\n\t},\n};\n\nstatic const struct x86_cpu_id ppin_cpuids[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_AMD_PPIN, &ppin_info[X86_VENDOR_AMD]),\n\tX86_MATCH_FEATURE(X86_FEATURE_INTEL_PPIN, &ppin_info[X86_VENDOR_INTEL]),\n\n\t \n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL, &ppin_info[X86_VENDOR_INTEL]),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM, &ppin_info[X86_VENDOR_INTEL]),\n\n\t{}\n};\n\nstatic void ppin_init(struct cpuinfo_x86 *c)\n{\n\tconst struct x86_cpu_id *id;\n\tunsigned long long val;\n\tstruct ppin_info *info;\n\n\tid = x86_match_cpu(ppin_cpuids);\n\tif (!id)\n\t\treturn;\n\n\t \n\tinfo = (struct ppin_info *)id->driver_data;\n\n\tif (rdmsrl_safe(info->msr_ppin_ctl, &val))\n\t\tgoto clear_ppin;\n\n\tif ((val & 3UL) == 1UL) {\n\t\t \n\t\tgoto clear_ppin;\n\t}\n\n\t \n\tif (!(val & 2UL)) {\n\t\twrmsrl_safe(info->msr_ppin_ctl,  val | 2UL);\n\t\trdmsrl_safe(info->msr_ppin_ctl, &val);\n\t}\n\n\t \n\tif (val & 2UL) {\n\t\tc->ppin = __rdmsr(info->msr_ppin);\n\t\tset_cpu_cap(c, info->feature);\n\t\treturn;\n\t}\n\nclear_ppin:\n\tclear_cpu_cap(c, info->feature);\n}\n\nstatic void default_init(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_X86_64\n\tcpu_detect_cache_sizes(c);\n#else\n\t \n\t \n\tif (c->cpuid_level == -1) {\n\t\t \n\t\tif (c->x86 == 4)\n\t\t\tstrcpy(c->x86_model_id, \"486\");\n\t\telse if (c->x86 == 3)\n\t\t\tstrcpy(c->x86_model_id, \"386\");\n\t}\n#endif\n}\n\nstatic const struct cpu_dev default_cpu = {\n\t.c_init\t\t= default_init,\n\t.c_vendor\t= \"Unknown\",\n\t.c_x86_vendor\t= X86_VENDOR_UNKNOWN,\n};\n\nstatic const struct cpu_dev *this_cpu = &default_cpu;\n\nDEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {\n#ifdef CONFIG_X86_64\n\t \n\t[GDT_ENTRY_KERNEL32_CS]\t\t= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),\n\t[GDT_ENTRY_KERNEL_CS]\t\t= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),\n\t[GDT_ENTRY_KERNEL_DS]\t\t= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),\n\t[GDT_ENTRY_DEFAULT_USER32_CS]\t= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),\n\t[GDT_ENTRY_DEFAULT_USER_DS]\t= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),\n\t[GDT_ENTRY_DEFAULT_USER_CS]\t= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),\n#else\n\t[GDT_ENTRY_KERNEL_CS]\t\t= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),\n\t[GDT_ENTRY_KERNEL_DS]\t\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),\n\t[GDT_ENTRY_DEFAULT_USER_CS]\t= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),\n\t[GDT_ENTRY_DEFAULT_USER_DS]\t= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),\n\t \n\t \n\t[GDT_ENTRY_PNPBIOS_CS32]\t= GDT_ENTRY_INIT(0x409a, 0, 0xffff),\n\t \n\t[GDT_ENTRY_PNPBIOS_CS16]\t= GDT_ENTRY_INIT(0x009a, 0, 0xffff),\n\t \n\t[GDT_ENTRY_PNPBIOS_DS]\t\t= GDT_ENTRY_INIT(0x0092, 0, 0xffff),\n\t \n\t[GDT_ENTRY_PNPBIOS_TS1]\t\t= GDT_ENTRY_INIT(0x0092, 0, 0),\n\t \n\t[GDT_ENTRY_PNPBIOS_TS2]\t\t= GDT_ENTRY_INIT(0x0092, 0, 0),\n\t \n\t \n\t[GDT_ENTRY_APMBIOS_BASE]\t= GDT_ENTRY_INIT(0x409a, 0, 0xffff),\n\t \n\t[GDT_ENTRY_APMBIOS_BASE+1]\t= GDT_ENTRY_INIT(0x009a, 0, 0xffff),\n\t \n\t[GDT_ENTRY_APMBIOS_BASE+2]\t= GDT_ENTRY_INIT(0x4092, 0, 0xffff),\n\n\t[GDT_ENTRY_ESPFIX_SS]\t\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),\n\t[GDT_ENTRY_PERCPU]\t\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),\n#endif\n} };\nEXPORT_PER_CPU_SYMBOL_GPL(gdt_page);\n\n#ifdef CONFIG_X86_64\nstatic int __init x86_nopcid_setup(char *s)\n{\n\t \n\tif (s)\n\t\treturn -EINVAL;\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_PCID))\n\t\treturn 0;\n\n\tsetup_clear_cpu_cap(X86_FEATURE_PCID);\n\tpr_info(\"nopcid: PCID feature disabled\\n\");\n\treturn 0;\n}\nearly_param(\"nopcid\", x86_nopcid_setup);\n#endif\n\nstatic int __init x86_noinvpcid_setup(char *s)\n{\n\t \n\tif (s)\n\t\treturn -EINVAL;\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_INVPCID))\n\t\treturn 0;\n\n\tsetup_clear_cpu_cap(X86_FEATURE_INVPCID);\n\tpr_info(\"noinvpcid: INVPCID feature disabled\\n\");\n\treturn 0;\n}\nearly_param(\"noinvpcid\", x86_noinvpcid_setup);\n\n#ifdef CONFIG_X86_32\nstatic int cachesize_override = -1;\nstatic int disable_x86_serial_nr = 1;\n\nstatic int __init cachesize_setup(char *str)\n{\n\tget_option(&str, &cachesize_override);\n\treturn 1;\n}\n__setup(\"cachesize=\", cachesize_setup);\n\n \nstatic inline int flag_is_changeable_p(u32 flag)\n{\n\tu32 f1, f2;\n\n\t \n\tasm volatile (\"pushfl\t\t\\n\\t\"\n\t\t      \"pushfl\t\t\\n\\t\"\n\t\t      \"popl %0\t\t\\n\\t\"\n\t\t      \"movl %0, %1\t\\n\\t\"\n\t\t      \"xorl %2, %0\t\\n\\t\"\n\t\t      \"pushl %0\t\t\\n\\t\"\n\t\t      \"popfl\t\t\\n\\t\"\n\t\t      \"pushfl\t\t\\n\\t\"\n\t\t      \"popl %0\t\t\\n\\t\"\n\t\t      \"popfl\t\t\\n\\t\"\n\n\t\t      : \"=&r\" (f1), \"=&r\" (f2)\n\t\t      : \"ir\" (flag));\n\n\treturn ((f1^f2) & flag) != 0;\n}\n\n \nint have_cpuid_p(void)\n{\n\treturn flag_is_changeable_p(X86_EFLAGS_ID);\n}\n\nstatic void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)\n{\n\tunsigned long lo, hi;\n\n\tif (!cpu_has(c, X86_FEATURE_PN) || !disable_x86_serial_nr)\n\t\treturn;\n\n\t \n\n\trdmsr(MSR_IA32_BBL_CR_CTL, lo, hi);\n\tlo |= 0x200000;\n\twrmsr(MSR_IA32_BBL_CR_CTL, lo, hi);\n\n\tpr_notice(\"CPU serial number disabled.\\n\");\n\tclear_cpu_cap(c, X86_FEATURE_PN);\n\n\t \n\tc->cpuid_level = cpuid_eax(0);\n}\n\nstatic int __init x86_serial_nr_setup(char *s)\n{\n\tdisable_x86_serial_nr = 0;\n\treturn 1;\n}\n__setup(\"serialnumber\", x86_serial_nr_setup);\n#else\nstatic inline int flag_is_changeable_p(u32 flag)\n{\n\treturn 1;\n}\nstatic inline void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)\n{\n}\n#endif\n\nstatic __always_inline void setup_smep(struct cpuinfo_x86 *c)\n{\n\tif (cpu_has(c, X86_FEATURE_SMEP))\n\t\tcr4_set_bits(X86_CR4_SMEP);\n}\n\nstatic __always_inline void setup_smap(struct cpuinfo_x86 *c)\n{\n\tunsigned long eflags = native_save_fl();\n\n\t \n\tBUG_ON(eflags & X86_EFLAGS_AC);\n\n\tif (cpu_has(c, X86_FEATURE_SMAP))\n\t\tcr4_set_bits(X86_CR4_SMAP);\n}\n\nstatic __always_inline void setup_umip(struct cpuinfo_x86 *c)\n{\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_UMIP))\n\t\tgoto out;\n\n\t \n\tif (!cpu_has(c, X86_FEATURE_UMIP))\n\t\tgoto out;\n\n\tcr4_set_bits(X86_CR4_UMIP);\n\n\tpr_info_once(\"x86/cpu: User Mode Instruction Prevention (UMIP) activated\\n\");\n\n\treturn;\n\nout:\n\t \n\tcr4_clear_bits(X86_CR4_UMIP);\n}\n\n \nstatic const unsigned long cr4_pinned_mask =\n\tX86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_UMIP |\n\tX86_CR4_FSGSBASE | X86_CR4_CET;\nstatic DEFINE_STATIC_KEY_FALSE_RO(cr_pinning);\nstatic unsigned long cr4_pinned_bits __ro_after_init;\n\nvoid native_write_cr0(unsigned long val)\n{\n\tunsigned long bits_missing = 0;\n\nset_register:\n\tasm volatile(\"mov %0,%%cr0\": \"+r\" (val) : : \"memory\");\n\n\tif (static_branch_likely(&cr_pinning)) {\n\t\tif (unlikely((val & X86_CR0_WP) != X86_CR0_WP)) {\n\t\t\tbits_missing = X86_CR0_WP;\n\t\t\tval |= bits_missing;\n\t\t\tgoto set_register;\n\t\t}\n\t\t \n\t\tWARN_ONCE(bits_missing, \"CR0 WP bit went missing!?\\n\");\n\t}\n}\nEXPORT_SYMBOL(native_write_cr0);\n\nvoid __no_profile native_write_cr4(unsigned long val)\n{\n\tunsigned long bits_changed = 0;\n\nset_register:\n\tasm volatile(\"mov %0,%%cr4\": \"+r\" (val) : : \"memory\");\n\n\tif (static_branch_likely(&cr_pinning)) {\n\t\tif (unlikely((val & cr4_pinned_mask) != cr4_pinned_bits)) {\n\t\t\tbits_changed = (val & cr4_pinned_mask) ^ cr4_pinned_bits;\n\t\t\tval = (val & ~cr4_pinned_mask) | cr4_pinned_bits;\n\t\t\tgoto set_register;\n\t\t}\n\t\t \n\t\tWARN_ONCE(bits_changed, \"pinned CR4 bits changed: 0x%lx!?\\n\",\n\t\t\t  bits_changed);\n\t}\n}\n#if IS_MODULE(CONFIG_LKDTM)\nEXPORT_SYMBOL_GPL(native_write_cr4);\n#endif\n\nvoid cr4_update_irqsoff(unsigned long set, unsigned long clear)\n{\n\tunsigned long newval, cr4 = this_cpu_read(cpu_tlbstate.cr4);\n\n\tlockdep_assert_irqs_disabled();\n\n\tnewval = (cr4 & ~clear) | set;\n\tif (newval != cr4) {\n\t\tthis_cpu_write(cpu_tlbstate.cr4, newval);\n\t\t__write_cr4(newval);\n\t}\n}\nEXPORT_SYMBOL(cr4_update_irqsoff);\n\n \nunsigned long cr4_read_shadow(void)\n{\n\treturn this_cpu_read(cpu_tlbstate.cr4);\n}\nEXPORT_SYMBOL_GPL(cr4_read_shadow);\n\nvoid cr4_init(void)\n{\n\tunsigned long cr4 = __read_cr4();\n\n\tif (boot_cpu_has(X86_FEATURE_PCID))\n\t\tcr4 |= X86_CR4_PCIDE;\n\tif (static_branch_likely(&cr_pinning))\n\t\tcr4 = (cr4 & ~cr4_pinned_mask) | cr4_pinned_bits;\n\n\t__write_cr4(cr4);\n\n\t \n\tthis_cpu_write(cpu_tlbstate.cr4, cr4);\n}\n\n \nstatic void __init setup_cr_pinning(void)\n{\n\tcr4_pinned_bits = this_cpu_read(cpu_tlbstate.cr4) & cr4_pinned_mask;\n\tstatic_key_enable(&cr_pinning.key);\n}\n\nstatic __init int x86_nofsgsbase_setup(char *arg)\n{\n\t \n\tif (strlen(arg))\n\t\treturn 0;\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_FSGSBASE))\n\t\treturn 1;\n\n\tsetup_clear_cpu_cap(X86_FEATURE_FSGSBASE);\n\tpr_info(\"FSGSBASE disabled via kernel command line\\n\");\n\treturn 1;\n}\n__setup(\"nofsgsbase\", x86_nofsgsbase_setup);\n\n \nstatic bool pku_disabled;\n\nstatic __always_inline void setup_pku(struct cpuinfo_x86 *c)\n{\n\tif (c == &boot_cpu_data) {\n\t\tif (pku_disabled || !cpu_feature_enabled(X86_FEATURE_PKU))\n\t\t\treturn;\n\t\t \n\t\tsetup_force_cpu_cap(X86_FEATURE_OSPKE);\n\n\t} else if (!cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\treturn;\n\t}\n\n\tcr4_set_bits(X86_CR4_PKE);\n\t \n\tpkru_write_default();\n}\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\nstatic __init int setup_disable_pku(char *arg)\n{\n\t \n\tpr_info(\"x86: 'nopku' specified, disabling Memory Protection Keys\\n\");\n\tpku_disabled = true;\n\treturn 1;\n}\n__setup(\"nopku\", setup_disable_pku);\n#endif\n\n#ifdef CONFIG_X86_KERNEL_IBT\n\n__noendbr u64 ibt_save(bool disable)\n{\n\tu64 msr = 0;\n\n\tif (cpu_feature_enabled(X86_FEATURE_IBT)) {\n\t\trdmsrl(MSR_IA32_S_CET, msr);\n\t\tif (disable)\n\t\t\twrmsrl(MSR_IA32_S_CET, msr & ~CET_ENDBR_EN);\n\t}\n\n\treturn msr;\n}\n\n__noendbr void ibt_restore(u64 save)\n{\n\tu64 msr;\n\n\tif (cpu_feature_enabled(X86_FEATURE_IBT)) {\n\t\trdmsrl(MSR_IA32_S_CET, msr);\n\t\tmsr &= ~CET_ENDBR_EN;\n\t\tmsr |= (save & CET_ENDBR_EN);\n\t\twrmsrl(MSR_IA32_S_CET, msr);\n\t}\n}\n\n#endif\n\nstatic __always_inline void setup_cet(struct cpuinfo_x86 *c)\n{\n\tbool user_shstk, kernel_ibt;\n\n\tif (!IS_ENABLED(CONFIG_X86_CET))\n\t\treturn;\n\n\tkernel_ibt = HAS_KERNEL_IBT && cpu_feature_enabled(X86_FEATURE_IBT);\n\tuser_shstk = cpu_feature_enabled(X86_FEATURE_SHSTK) &&\n\t\t     IS_ENABLED(CONFIG_X86_USER_SHADOW_STACK);\n\n\tif (!kernel_ibt && !user_shstk)\n\t\treturn;\n\n\tif (user_shstk)\n\t\tset_cpu_cap(c, X86_FEATURE_USER_SHSTK);\n\n\tif (kernel_ibt)\n\t\twrmsrl(MSR_IA32_S_CET, CET_ENDBR_EN);\n\telse\n\t\twrmsrl(MSR_IA32_S_CET, 0);\n\n\tcr4_set_bits(X86_CR4_CET);\n\n\tif (kernel_ibt && ibt_selftest()) {\n\t\tpr_err(\"IBT selftest: Failed!\\n\");\n\t\twrmsrl(MSR_IA32_S_CET, 0);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_IBT);\n\t}\n}\n\n__noendbr void cet_disable(void)\n{\n\tif (!(cpu_feature_enabled(X86_FEATURE_IBT) ||\n\t      cpu_feature_enabled(X86_FEATURE_SHSTK)))\n\t\treturn;\n\n\twrmsrl(MSR_IA32_S_CET, 0);\n\twrmsrl(MSR_IA32_U_CET, 0);\n}\n\n \nstruct cpuid_dependent_feature {\n\tu32 feature;\n\tu32 level;\n};\n\nstatic const struct cpuid_dependent_feature\ncpuid_dependent_features[] = {\n\t{ X86_FEATURE_MWAIT,\t\t0x00000005 },\n\t{ X86_FEATURE_DCA,\t\t0x00000009 },\n\t{ X86_FEATURE_XSAVE,\t\t0x0000000d },\n\t{ 0, 0 }\n};\n\nstatic void filter_cpuid_features(struct cpuinfo_x86 *c, bool warn)\n{\n\tconst struct cpuid_dependent_feature *df;\n\n\tfor (df = cpuid_dependent_features; df->feature; df++) {\n\n\t\tif (!cpu_has(c, df->feature))\n\t\t\tcontinue;\n\t\t \n\t\tif (!((s32)df->level < 0 ?\n\t\t     (u32)df->level > (u32)c->extended_cpuid_level :\n\t\t     (s32)df->level > (s32)c->cpuid_level))\n\t\t\tcontinue;\n\n\t\tclear_cpu_cap(c, df->feature);\n\t\tif (!warn)\n\t\t\tcontinue;\n\n\t\tpr_warn(\"CPU: CPU feature \" X86_CAP_FMT \" disabled, no CPUID level 0x%x\\n\",\n\t\t\tx86_cap_flag(df->feature), df->level);\n\t}\n}\n\n \n\n \nstatic const char *table_lookup_model(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_X86_32\n\tconst struct legacy_cpu_model_info *info;\n\n\tif (c->x86_model >= 16)\n\t\treturn NULL;\t \n\n\tif (!this_cpu)\n\t\treturn NULL;\n\n\tinfo = this_cpu->legacy_models;\n\n\twhile (info->family) {\n\t\tif (info->family == c->x86)\n\t\t\treturn info->model_names[c->x86_model];\n\t\tinfo++;\n\t}\n#endif\n\treturn NULL;\t\t \n}\n\n \n__u32 cpu_caps_cleared[NCAPINTS + NBUGINTS] __aligned(sizeof(unsigned long));\n__u32 cpu_caps_set[NCAPINTS + NBUGINTS] __aligned(sizeof(unsigned long));\n\n#ifdef CONFIG_X86_32\n \nDEFINE_PER_CPU(struct cpu_entry_area *, cpu_entry_area);\n#endif\n\n \nvoid load_direct_gdt(int cpu)\n{\n\tstruct desc_ptr gdt_descr;\n\n\tgdt_descr.address = (long)get_cpu_gdt_rw(cpu);\n\tgdt_descr.size = GDT_SIZE - 1;\n\tload_gdt(&gdt_descr);\n}\nEXPORT_SYMBOL_GPL(load_direct_gdt);\n\n \nvoid load_fixmap_gdt(int cpu)\n{\n\tstruct desc_ptr gdt_descr;\n\n\tgdt_descr.address = (long)get_cpu_gdt_ro(cpu);\n\tgdt_descr.size = GDT_SIZE - 1;\n\tload_gdt(&gdt_descr);\n}\nEXPORT_SYMBOL_GPL(load_fixmap_gdt);\n\n \nvoid __init switch_gdt_and_percpu_base(int cpu)\n{\n\tload_direct_gdt(cpu);\n\n#ifdef CONFIG_X86_64\n\t \n\twrmsrl(MSR_GS_BASE, cpu_kernelmode_gs_base(cpu));\n#else\n\t \n\tloadsegment(fs, __KERNEL_PERCPU);\n#endif\n}\n\nstatic const struct cpu_dev *cpu_devs[X86_VENDOR_NUM] = {};\n\nstatic void get_model_name(struct cpuinfo_x86 *c)\n{\n\tunsigned int *v;\n\tchar *p, *q, *s;\n\n\tif (c->extended_cpuid_level < 0x80000004)\n\t\treturn;\n\n\tv = (unsigned int *)c->x86_model_id;\n\tcpuid(0x80000002, &v[0], &v[1], &v[2], &v[3]);\n\tcpuid(0x80000003, &v[4], &v[5], &v[6], &v[7]);\n\tcpuid(0x80000004, &v[8], &v[9], &v[10], &v[11]);\n\tc->x86_model_id[48] = 0;\n\n\t \n\tp = q = s = &c->x86_model_id[0];\n\n\twhile (*p == ' ')\n\t\tp++;\n\n\twhile (*p) {\n\t\t \n\t\tif (!isspace(*p))\n\t\t\ts = q;\n\n\t\t*q++ = *p++;\n\t}\n\n\t*(s + 1) = '\\0';\n}\n\nvoid detect_num_cpu_cores(struct cpuinfo_x86 *c)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tc->x86_max_cores = 1;\n\tif (!IS_ENABLED(CONFIG_SMP) || c->cpuid_level < 4)\n\t\treturn;\n\n\tcpuid_count(4, 0, &eax, &ebx, &ecx, &edx);\n\tif (eax & 0x1f)\n\t\tc->x86_max_cores = (eax >> 26) + 1;\n}\n\nvoid cpu_detect_cache_sizes(struct cpuinfo_x86 *c)\n{\n\tunsigned int n, dummy, ebx, ecx, edx, l2size;\n\n\tn = c->extended_cpuid_level;\n\n\tif (n >= 0x80000005) {\n\t\tcpuid(0x80000005, &dummy, &ebx, &ecx, &edx);\n\t\tc->x86_cache_size = (ecx>>24) + (edx>>24);\n#ifdef CONFIG_X86_64\n\t\t \n\t\tc->x86_tlbsize = 0;\n#endif\n\t}\n\n\tif (n < 0x80000006)\t \n\t\treturn;\n\n\tcpuid(0x80000006, &dummy, &ebx, &ecx, &edx);\n\tl2size = ecx >> 16;\n\n#ifdef CONFIG_X86_64\n\tc->x86_tlbsize += ((ebx >> 16) & 0xfff) + (ebx & 0xfff);\n#else\n\t \n\tif (this_cpu->legacy_cache_size)\n\t\tl2size = this_cpu->legacy_cache_size(c, l2size);\n\n\t \n\tif (cachesize_override != -1)\n\t\tl2size = cachesize_override;\n\n\tif (l2size == 0)\n\t\treturn;\t\t \n#endif\n\n\tc->x86_cache_size = l2size;\n}\n\nu16 __read_mostly tlb_lli_4k[NR_INFO];\nu16 __read_mostly tlb_lli_2m[NR_INFO];\nu16 __read_mostly tlb_lli_4m[NR_INFO];\nu16 __read_mostly tlb_lld_4k[NR_INFO];\nu16 __read_mostly tlb_lld_2m[NR_INFO];\nu16 __read_mostly tlb_lld_4m[NR_INFO];\nu16 __read_mostly tlb_lld_1g[NR_INFO];\n\nstatic void cpu_detect_tlb(struct cpuinfo_x86 *c)\n{\n\tif (this_cpu->c_detect_tlb)\n\t\tthis_cpu->c_detect_tlb(c);\n\n\tpr_info(\"Last level iTLB entries: 4KB %d, 2MB %d, 4MB %d\\n\",\n\t\ttlb_lli_4k[ENTRIES], tlb_lli_2m[ENTRIES],\n\t\ttlb_lli_4m[ENTRIES]);\n\n\tpr_info(\"Last level dTLB entries: 4KB %d, 2MB %d, 4MB %d, 1GB %d\\n\",\n\t\ttlb_lld_4k[ENTRIES], tlb_lld_2m[ENTRIES],\n\t\ttlb_lld_4m[ENTRIES], tlb_lld_1g[ENTRIES]);\n}\n\nint detect_ht_early(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tu32 eax, ebx, ecx, edx;\n\n\tif (!cpu_has(c, X86_FEATURE_HT))\n\t\treturn -1;\n\n\tif (cpu_has(c, X86_FEATURE_CMP_LEGACY))\n\t\treturn -1;\n\n\tif (cpu_has(c, X86_FEATURE_XTOPOLOGY))\n\t\treturn -1;\n\n\tcpuid(1, &eax, &ebx, &ecx, &edx);\n\n\tsmp_num_siblings = (ebx & 0xff0000) >> 16;\n\tif (smp_num_siblings == 1)\n\t\tpr_info_once(\"CPU0: Hyper-Threading is disabled\\n\");\n#endif\n\treturn 0;\n}\n\nvoid detect_ht(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tint index_msb, core_bits;\n\n\tif (detect_ht_early(c) < 0)\n\t\treturn;\n\n\tindex_msb = get_count_order(smp_num_siblings);\n\tc->phys_proc_id = apic->phys_pkg_id(c->initial_apicid, index_msb);\n\n\tsmp_num_siblings = smp_num_siblings / c->x86_max_cores;\n\n\tindex_msb = get_count_order(smp_num_siblings);\n\n\tcore_bits = get_count_order(c->x86_max_cores);\n\n\tc->cpu_core_id = apic->phys_pkg_id(c->initial_apicid, index_msb) &\n\t\t\t\t       ((1 << core_bits) - 1);\n#endif\n}\n\nstatic void get_cpu_vendor(struct cpuinfo_x86 *c)\n{\n\tchar *v = c->x86_vendor_id;\n\tint i;\n\n\tfor (i = 0; i < X86_VENDOR_NUM; i++) {\n\t\tif (!cpu_devs[i])\n\t\t\tbreak;\n\n\t\tif (!strcmp(v, cpu_devs[i]->c_ident[0]) ||\n\t\t    (cpu_devs[i]->c_ident[1] &&\n\t\t     !strcmp(v, cpu_devs[i]->c_ident[1]))) {\n\n\t\t\tthis_cpu = cpu_devs[i];\n\t\t\tc->x86_vendor = this_cpu->c_x86_vendor;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpr_err_once(\"CPU: vendor_id '%s' unknown, using generic init.\\n\" \\\n\t\t    \"CPU: Your system may be unstable.\\n\", v);\n\n\tc->x86_vendor = X86_VENDOR_UNKNOWN;\n\tthis_cpu = &default_cpu;\n}\n\nvoid cpu_detect(struct cpuinfo_x86 *c)\n{\n\t \n\tcpuid(0x00000000, (unsigned int *)&c->cpuid_level,\n\t      (unsigned int *)&c->x86_vendor_id[0],\n\t      (unsigned int *)&c->x86_vendor_id[8],\n\t      (unsigned int *)&c->x86_vendor_id[4]);\n\n\tc->x86 = 4;\n\t \n\tif (c->cpuid_level >= 0x00000001) {\n\t\tu32 junk, tfms, cap0, misc;\n\n\t\tcpuid(0x00000001, &tfms, &misc, &junk, &cap0);\n\t\tc->x86\t\t= x86_family(tfms);\n\t\tc->x86_model\t= x86_model(tfms);\n\t\tc->x86_stepping\t= x86_stepping(tfms);\n\n\t\tif (cap0 & (1<<19)) {\n\t\t\tc->x86_clflush_size = ((misc >> 8) & 0xff) * 8;\n\t\t\tc->x86_cache_alignment = c->x86_clflush_size;\n\t\t}\n\t}\n}\n\nstatic void apply_forced_caps(struct cpuinfo_x86 *c)\n{\n\tint i;\n\n\tfor (i = 0; i < NCAPINTS + NBUGINTS; i++) {\n\t\tc->x86_capability[i] &= ~cpu_caps_cleared[i];\n\t\tc->x86_capability[i] |= cpu_caps_set[i];\n\t}\n}\n\nstatic void init_speculation_control(struct cpuinfo_x86 *c)\n{\n\t \n\tif (cpu_has(c, X86_FEATURE_SPEC_CTRL)) {\n\t\tset_cpu_cap(c, X86_FEATURE_IBRS);\n\t\tset_cpu_cap(c, X86_FEATURE_IBPB);\n\t\tset_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_INTEL_STIBP))\n\t\tset_cpu_cap(c, X86_FEATURE_STIBP);\n\n\tif (cpu_has(c, X86_FEATURE_SPEC_CTRL_SSBD) ||\n\t    cpu_has(c, X86_FEATURE_VIRT_SSBD))\n\t\tset_cpu_cap(c, X86_FEATURE_SSBD);\n\n\tif (cpu_has(c, X86_FEATURE_AMD_IBRS)) {\n\t\tset_cpu_cap(c, X86_FEATURE_IBRS);\n\t\tset_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_AMD_IBPB))\n\t\tset_cpu_cap(c, X86_FEATURE_IBPB);\n\n\tif (cpu_has(c, X86_FEATURE_AMD_STIBP)) {\n\t\tset_cpu_cap(c, X86_FEATURE_STIBP);\n\t\tset_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_AMD_SSBD)) {\n\t\tset_cpu_cap(c, X86_FEATURE_SSBD);\n\t\tset_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);\n\t\tclear_cpu_cap(c, X86_FEATURE_VIRT_SSBD);\n\t}\n}\n\nvoid get_cpu_cap(struct cpuinfo_x86 *c)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\t \n\tif (c->cpuid_level >= 0x00000001) {\n\t\tcpuid(0x00000001, &eax, &ebx, &ecx, &edx);\n\n\t\tc->x86_capability[CPUID_1_ECX] = ecx;\n\t\tc->x86_capability[CPUID_1_EDX] = edx;\n\t}\n\n\t \n\tif (c->cpuid_level >= 0x00000006)\n\t\tc->x86_capability[CPUID_6_EAX] = cpuid_eax(0x00000006);\n\n\t \n\tif (c->cpuid_level >= 0x00000007) {\n\t\tcpuid_count(0x00000007, 0, &eax, &ebx, &ecx, &edx);\n\t\tc->x86_capability[CPUID_7_0_EBX] = ebx;\n\t\tc->x86_capability[CPUID_7_ECX] = ecx;\n\t\tc->x86_capability[CPUID_7_EDX] = edx;\n\n\t\t \n\t\tif (eax >= 1) {\n\t\t\tcpuid_count(0x00000007, 1, &eax, &ebx, &ecx, &edx);\n\t\t\tc->x86_capability[CPUID_7_1_EAX] = eax;\n\t\t}\n\t}\n\n\t \n\tif (c->cpuid_level >= 0x0000000d) {\n\t\tcpuid_count(0x0000000d, 1, &eax, &ebx, &ecx, &edx);\n\n\t\tc->x86_capability[CPUID_D_1_EAX] = eax;\n\t}\n\n\t \n\teax = cpuid_eax(0x80000000);\n\tc->extended_cpuid_level = eax;\n\n\tif ((eax & 0xffff0000) == 0x80000000) {\n\t\tif (eax >= 0x80000001) {\n\t\t\tcpuid(0x80000001, &eax, &ebx, &ecx, &edx);\n\n\t\t\tc->x86_capability[CPUID_8000_0001_ECX] = ecx;\n\t\t\tc->x86_capability[CPUID_8000_0001_EDX] = edx;\n\t\t}\n\t}\n\n\tif (c->extended_cpuid_level >= 0x80000007) {\n\t\tcpuid(0x80000007, &eax, &ebx, &ecx, &edx);\n\n\t\tc->x86_capability[CPUID_8000_0007_EBX] = ebx;\n\t\tc->x86_power = edx;\n\t}\n\n\tif (c->extended_cpuid_level >= 0x80000008) {\n\t\tcpuid(0x80000008, &eax, &ebx, &ecx, &edx);\n\t\tc->x86_capability[CPUID_8000_0008_EBX] = ebx;\n\t}\n\n\tif (c->extended_cpuid_level >= 0x8000000a)\n\t\tc->x86_capability[CPUID_8000_000A_EDX] = cpuid_edx(0x8000000a);\n\n\tif (c->extended_cpuid_level >= 0x8000001f)\n\t\tc->x86_capability[CPUID_8000_001F_EAX] = cpuid_eax(0x8000001f);\n\n\tif (c->extended_cpuid_level >= 0x80000021)\n\t\tc->x86_capability[CPUID_8000_0021_EAX] = cpuid_eax(0x80000021);\n\n\tinit_scattered_cpuid_features(c);\n\tinit_speculation_control(c);\n\n\t \n\tapply_forced_caps(c);\n}\n\nvoid get_cpu_address_sizes(struct cpuinfo_x86 *c)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\tif (c->extended_cpuid_level >= 0x80000008) {\n\t\tcpuid(0x80000008, &eax, &ebx, &ecx, &edx);\n\n\t\tc->x86_virt_bits = (eax >> 8) & 0xff;\n\t\tc->x86_phys_bits = eax & 0xff;\n\t}\n#ifdef CONFIG_X86_32\n\telse if (cpu_has(c, X86_FEATURE_PAE) || cpu_has(c, X86_FEATURE_PSE36))\n\t\tc->x86_phys_bits = 36;\n#endif\n\tc->x86_cache_bits = c->x86_phys_bits;\n}\n\nstatic void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_X86_32\n\tint i;\n\n\t \n\tif (flag_is_changeable_p(X86_EFLAGS_AC))\n\t\tc->x86 = 4;\n\telse\n\t\tc->x86 = 3;\n\n\tfor (i = 0; i < X86_VENDOR_NUM; i++)\n\t\tif (cpu_devs[i] && cpu_devs[i]->c_identify) {\n\t\t\tc->x86_vendor_id[0] = 0;\n\t\t\tcpu_devs[i]->c_identify(c);\n\t\t\tif (c->x86_vendor_id[0]) {\n\t\t\t\tget_cpu_vendor(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n}\n\n#define NO_SPECULATION\t\tBIT(0)\n#define NO_MELTDOWN\t\tBIT(1)\n#define NO_SSB\t\t\tBIT(2)\n#define NO_L1TF\t\t\tBIT(3)\n#define NO_MDS\t\t\tBIT(4)\n#define MSBDS_ONLY\t\tBIT(5)\n#define NO_SWAPGS\t\tBIT(6)\n#define NO_ITLB_MULTIHIT\tBIT(7)\n#define NO_SPECTRE_V2\t\tBIT(8)\n#define NO_MMIO\t\t\tBIT(9)\n#define NO_EIBRS_PBRSB\t\tBIT(10)\n\n#define VULNWL(vendor, family, model, whitelist)\t\\\n\tX86_MATCH_VENDOR_FAM_MODEL(vendor, family, model, whitelist)\n\n#define VULNWL_INTEL(model, whitelist)\t\t\\\n\tVULNWL(INTEL, 6, INTEL_FAM6_##model, whitelist)\n\n#define VULNWL_AMD(family, whitelist)\t\t\\\n\tVULNWL(AMD, family, X86_MODEL_ANY, whitelist)\n\n#define VULNWL_HYGON(family, whitelist)\t\t\\\n\tVULNWL(HYGON, family, X86_MODEL_ANY, whitelist)\n\nstatic const __initconst struct x86_cpu_id cpu_vuln_whitelist[] = {\n\tVULNWL(ANY,\t4, X86_MODEL_ANY,\tNO_SPECULATION),\n\tVULNWL(CENTAUR,\t5, X86_MODEL_ANY,\tNO_SPECULATION),\n\tVULNWL(INTEL,\t5, X86_MODEL_ANY,\tNO_SPECULATION),\n\tVULNWL(NSC,\t5, X86_MODEL_ANY,\tNO_SPECULATION),\n\tVULNWL(VORTEX,\t5, X86_MODEL_ANY,\tNO_SPECULATION),\n\tVULNWL(VORTEX,\t6, X86_MODEL_ANY,\tNO_SPECULATION),\n\n\t \n\tVULNWL_INTEL(TIGERLAKE,\t\t\tNO_MMIO),\n\tVULNWL_INTEL(TIGERLAKE_L,\t\tNO_MMIO),\n\tVULNWL_INTEL(ALDERLAKE,\t\t\tNO_MMIO),\n\tVULNWL_INTEL(ALDERLAKE_L,\t\tNO_MMIO),\n\n\tVULNWL_INTEL(ATOM_SALTWELL,\t\tNO_SPECULATION | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_SALTWELL_TABLET,\tNO_SPECULATION | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_SALTWELL_MID,\t\tNO_SPECULATION | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_BONNELL,\t\tNO_SPECULATION | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_BONNELL_MID,\t\tNO_SPECULATION | NO_ITLB_MULTIHIT),\n\n\tVULNWL_INTEL(ATOM_SILVERMONT,\t\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_SILVERMONT_D,\t\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_SILVERMONT_MID,\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_AIRMONT,\t\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(XEON_PHI_KNL,\t\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(XEON_PHI_KNM,\t\tNO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\n\tVULNWL_INTEL(CORE_YONAH,\t\tNO_SSB),\n\n\tVULNWL_INTEL(ATOM_AIRMONT_MID,\t\tNO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\tVULNWL_INTEL(ATOM_AIRMONT_NP,\t\tNO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT),\n\n\tVULNWL_INTEL(ATOM_GOLDMONT,\t\tNO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\tVULNWL_INTEL(ATOM_GOLDMONT_D,\t\tNO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\tVULNWL_INTEL(ATOM_GOLDMONT_PLUS,\tNO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO | NO_EIBRS_PBRSB),\n\n\t \n\n\tVULNWL_INTEL(ATOM_TREMONT,\t\tNO_EIBRS_PBRSB),\n\tVULNWL_INTEL(ATOM_TREMONT_L,\t\tNO_EIBRS_PBRSB),\n\tVULNWL_INTEL(ATOM_TREMONT_D,\t\tNO_ITLB_MULTIHIT | NO_EIBRS_PBRSB),\n\n\t \n\tVULNWL_AMD(0x0f,\tNO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\tVULNWL_AMD(0x10,\tNO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\tVULNWL_AMD(0x11,\tNO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\tVULNWL_AMD(0x12,\tNO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO),\n\n\t \n\tVULNWL_AMD(X86_FAMILY_ANY,\tNO_MELTDOWN | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO | NO_EIBRS_PBRSB),\n\tVULNWL_HYGON(X86_FAMILY_ANY,\tNO_MELTDOWN | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT | NO_MMIO | NO_EIBRS_PBRSB),\n\n\t \n\tVULNWL(CENTAUR,\t7, X86_MODEL_ANY,\tNO_SPECTRE_V2 | NO_SWAPGS | NO_MMIO),\n\tVULNWL(ZHAOXIN,\t7, X86_MODEL_ANY,\tNO_SPECTRE_V2 | NO_SWAPGS | NO_MMIO),\n\t{}\n};\n\n#define VULNBL(vendor, family, model, blacklist)\t\\\n\tX86_MATCH_VENDOR_FAM_MODEL(vendor, family, model, blacklist)\n\n#define VULNBL_INTEL_STEPPINGS(model, steppings, issues)\t\t   \\\n\tX86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE(INTEL, 6,\t\t   \\\n\t\t\t\t\t    INTEL_FAM6_##model, steppings, \\\n\t\t\t\t\t    X86_FEATURE_ANY, issues)\n\n#define VULNBL_AMD(family, blacklist)\t\t\\\n\tVULNBL(AMD, family, X86_MODEL_ANY, blacklist)\n\n#define VULNBL_HYGON(family, blacklist)\t\t\\\n\tVULNBL(HYGON, family, X86_MODEL_ANY, blacklist)\n\n#define SRBDS\t\tBIT(0)\n \n#define MMIO\t\tBIT(1)\n \n#define MMIO_SBDS\tBIT(2)\n \n#define RETBLEED\tBIT(3)\n \n#define SMT_RSB\t\tBIT(4)\n \n#define SRSO\t\tBIT(5)\n \n#define GDS\t\tBIT(6)\n\nstatic const struct x86_cpu_id cpu_vuln_blacklist[] __initconst = {\n\tVULNBL_INTEL_STEPPINGS(IVYBRIDGE,\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(HASWELL,\t\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(HASWELL_L,\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(HASWELL_G,\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(HASWELL_X,\tX86_STEPPING_ANY,\t\tMMIO),\n\tVULNBL_INTEL_STEPPINGS(BROADWELL_D,\tX86_STEPPING_ANY,\t\tMMIO),\n\tVULNBL_INTEL_STEPPINGS(BROADWELL_G,\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(BROADWELL_X,\tX86_STEPPING_ANY,\t\tMMIO),\n\tVULNBL_INTEL_STEPPINGS(BROADWELL,\tX86_STEPPING_ANY,\t\tSRBDS),\n\tVULNBL_INTEL_STEPPINGS(SKYLAKE_X,\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS),\n\tVULNBL_INTEL_STEPPINGS(SKYLAKE_L,\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS | SRBDS),\n\tVULNBL_INTEL_STEPPINGS(SKYLAKE,\t\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS | SRBDS),\n\tVULNBL_INTEL_STEPPINGS(KABYLAKE_L,\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS | SRBDS),\n\tVULNBL_INTEL_STEPPINGS(KABYLAKE,\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS | SRBDS),\n\tVULNBL_INTEL_STEPPINGS(CANNONLAKE_L,\tX86_STEPPING_ANY,\t\tRETBLEED),\n\tVULNBL_INTEL_STEPPINGS(ICELAKE_L,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS | RETBLEED | GDS),\n\tVULNBL_INTEL_STEPPINGS(ICELAKE_D,\tX86_STEPPING_ANY,\t\tMMIO | GDS),\n\tVULNBL_INTEL_STEPPINGS(ICELAKE_X,\tX86_STEPPING_ANY,\t\tMMIO | GDS),\n\tVULNBL_INTEL_STEPPINGS(COMETLAKE,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS | RETBLEED | GDS),\n\tVULNBL_INTEL_STEPPINGS(COMETLAKE_L,\tX86_STEPPINGS(0x0, 0x0),\tMMIO | RETBLEED),\n\tVULNBL_INTEL_STEPPINGS(COMETLAKE_L,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS | RETBLEED | GDS),\n\tVULNBL_INTEL_STEPPINGS(TIGERLAKE_L,\tX86_STEPPING_ANY,\t\tGDS),\n\tVULNBL_INTEL_STEPPINGS(TIGERLAKE,\tX86_STEPPING_ANY,\t\tGDS),\n\tVULNBL_INTEL_STEPPINGS(LAKEFIELD,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS | RETBLEED),\n\tVULNBL_INTEL_STEPPINGS(ROCKETLAKE,\tX86_STEPPING_ANY,\t\tMMIO | RETBLEED | GDS),\n\tVULNBL_INTEL_STEPPINGS(ATOM_TREMONT,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS),\n\tVULNBL_INTEL_STEPPINGS(ATOM_TREMONT_D,\tX86_STEPPING_ANY,\t\tMMIO),\n\tVULNBL_INTEL_STEPPINGS(ATOM_TREMONT_L,\tX86_STEPPING_ANY,\t\tMMIO | MMIO_SBDS),\n\n\tVULNBL_AMD(0x15, RETBLEED),\n\tVULNBL_AMD(0x16, RETBLEED),\n\tVULNBL_AMD(0x17, RETBLEED | SMT_RSB | SRSO),\n\tVULNBL_HYGON(0x18, RETBLEED | SMT_RSB | SRSO),\n\tVULNBL_AMD(0x19, SRSO),\n\t{}\n};\n\nstatic bool __init cpu_matches(const struct x86_cpu_id *table, unsigned long which)\n{\n\tconst struct x86_cpu_id *m = x86_match_cpu(table);\n\n\treturn m && !!(m->driver_data & which);\n}\n\nu64 x86_read_arch_cap_msr(void)\n{\n\tu64 ia32_cap = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, ia32_cap);\n\n\treturn ia32_cap;\n}\n\nstatic bool arch_cap_mmio_immune(u64 ia32_cap)\n{\n\treturn (ia32_cap & ARCH_CAP_FBSDP_NO &&\n\t\tia32_cap & ARCH_CAP_PSDP_NO &&\n\t\tia32_cap & ARCH_CAP_SBDR_SSDP_NO);\n}\n\nstatic void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)\n{\n\tu64 ia32_cap = x86_read_arch_cap_msr();\n\n\t \n\tif (!cpu_matches(cpu_vuln_whitelist, NO_ITLB_MULTIHIT) &&\n\t    !(ia32_cap & ARCH_CAP_PSCHANGE_MC_NO))\n\t\tsetup_force_cpu_bug(X86_BUG_ITLB_MULTIHIT);\n\n\tif (cpu_matches(cpu_vuln_whitelist, NO_SPECULATION))\n\t\treturn;\n\n\tsetup_force_cpu_bug(X86_BUG_SPECTRE_V1);\n\n\tif (!cpu_matches(cpu_vuln_whitelist, NO_SPECTRE_V2))\n\t\tsetup_force_cpu_bug(X86_BUG_SPECTRE_V2);\n\n\tif (!cpu_matches(cpu_vuln_whitelist, NO_SSB) &&\n\t    !(ia32_cap & ARCH_CAP_SSB_NO) &&\n\t   !cpu_has(c, X86_FEATURE_AMD_SSB_NO))\n\t\tsetup_force_cpu_bug(X86_BUG_SPEC_STORE_BYPASS);\n\n\t \n\tif ((ia32_cap & ARCH_CAP_IBRS_ALL) || cpu_has(c, X86_FEATURE_AUTOIBRS)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_IBRS_ENHANCED);\n\t\tif (!cpu_matches(cpu_vuln_whitelist, NO_EIBRS_PBRSB) &&\n\t\t    !(ia32_cap & ARCH_CAP_PBRSB_NO))\n\t\t\tsetup_force_cpu_bug(X86_BUG_EIBRS_PBRSB);\n\t}\n\n\tif (!cpu_matches(cpu_vuln_whitelist, NO_MDS) &&\n\t    !(ia32_cap & ARCH_CAP_MDS_NO)) {\n\t\tsetup_force_cpu_bug(X86_BUG_MDS);\n\t\tif (cpu_matches(cpu_vuln_whitelist, MSBDS_ONLY))\n\t\t\tsetup_force_cpu_bug(X86_BUG_MSBDS_ONLY);\n\t}\n\n\tif (!cpu_matches(cpu_vuln_whitelist, NO_SWAPGS))\n\t\tsetup_force_cpu_bug(X86_BUG_SWAPGS);\n\n\t \n\tif (!(ia32_cap & ARCH_CAP_TAA_NO) &&\n\t    (cpu_has(c, X86_FEATURE_RTM) ||\n\t     (ia32_cap & ARCH_CAP_TSX_CTRL_MSR)))\n\t\tsetup_force_cpu_bug(X86_BUG_TAA);\n\n\t \n\tif ((cpu_has(c, X86_FEATURE_RDRAND) ||\n\t     cpu_has(c, X86_FEATURE_RDSEED)) &&\n\t    cpu_matches(cpu_vuln_blacklist, SRBDS | MMIO_SBDS))\n\t\t    setup_force_cpu_bug(X86_BUG_SRBDS);\n\n\t \n\tif (!arch_cap_mmio_immune(ia32_cap)) {\n\t\tif (cpu_matches(cpu_vuln_blacklist, MMIO))\n\t\t\tsetup_force_cpu_bug(X86_BUG_MMIO_STALE_DATA);\n\t\telse if (!cpu_matches(cpu_vuln_whitelist, NO_MMIO))\n\t\t\tsetup_force_cpu_bug(X86_BUG_MMIO_UNKNOWN);\n\t}\n\n\tif (!cpu_has(c, X86_FEATURE_BTC_NO)) {\n\t\tif (cpu_matches(cpu_vuln_blacklist, RETBLEED) || (ia32_cap & ARCH_CAP_RSBA))\n\t\t\tsetup_force_cpu_bug(X86_BUG_RETBLEED);\n\t}\n\n\tif (cpu_matches(cpu_vuln_blacklist, SMT_RSB))\n\t\tsetup_force_cpu_bug(X86_BUG_SMT_RSB);\n\n\tif (!cpu_has(c, X86_FEATURE_SRSO_NO)) {\n\t\tif (cpu_matches(cpu_vuln_blacklist, SRSO))\n\t\t\tsetup_force_cpu_bug(X86_BUG_SRSO);\n\t}\n\n\t \n\tif (cpu_matches(cpu_vuln_blacklist, GDS) && !(ia32_cap & ARCH_CAP_GDS_NO) &&\n\t    boot_cpu_has(X86_FEATURE_AVX))\n\t\tsetup_force_cpu_bug(X86_BUG_GDS);\n\n\tif (cpu_matches(cpu_vuln_whitelist, NO_MELTDOWN))\n\t\treturn;\n\n\t \n\tif (ia32_cap & ARCH_CAP_RDCL_NO)\n\t\treturn;\n\n\tsetup_force_cpu_bug(X86_BUG_CPU_MELTDOWN);\n\n\tif (cpu_matches(cpu_vuln_whitelist, NO_L1TF))\n\t\treturn;\n\n\tsetup_force_cpu_bug(X86_BUG_L1TF);\n}\n\n \nstatic void detect_nopl(void)\n{\n#ifdef CONFIG_X86_32\n\tsetup_clear_cpu_cap(X86_FEATURE_NOPL);\n#else\n\tsetup_force_cpu_cap(X86_FEATURE_NOPL);\n#endif\n}\n\n \nstatic void __init cpu_parse_early_param(void)\n{\n\tchar arg[128];\n\tchar *argptr = arg, *opt;\n\tint arglen, taint = 0;\n\n#ifdef CONFIG_X86_32\n\tif (cmdline_find_option_bool(boot_command_line, \"no387\"))\n#ifdef CONFIG_MATH_EMULATION\n\t\tsetup_clear_cpu_cap(X86_FEATURE_FPU);\n#else\n\t\tpr_err(\"Option 'no387' required CONFIG_MATH_EMULATION enabled.\\n\");\n#endif\n\n\tif (cmdline_find_option_bool(boot_command_line, \"nofxsr\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_FXSR);\n#endif\n\n\tif (cmdline_find_option_bool(boot_command_line, \"noxsave\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_XSAVE);\n\n\tif (cmdline_find_option_bool(boot_command_line, \"noxsaveopt\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_XSAVEOPT);\n\n\tif (cmdline_find_option_bool(boot_command_line, \"noxsaves\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_XSAVES);\n\n\tif (cmdline_find_option_bool(boot_command_line, \"nousershstk\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_USER_SHSTK);\n\n\targlen = cmdline_find_option(boot_command_line, \"clearcpuid\", arg, sizeof(arg));\n\tif (arglen <= 0)\n\t\treturn;\n\n\tpr_info(\"Clearing CPUID bits:\");\n\n\twhile (argptr) {\n\t\tbool found __maybe_unused = false;\n\t\tunsigned int bit;\n\n\t\topt = strsep(&argptr, \",\");\n\n\t\t \n\t\tif (!kstrtouint(opt, 10, &bit)) {\n\t\t\tif (bit < NCAPINTS * 32) {\n\n\t\t\t\t \n\t\t\t\tif (!x86_cap_flags[bit])\n\t\t\t\t\tpr_cont(\" \" X86_CAP_FMT_NUM, x86_cap_flag_num(bit));\n\t\t\t\telse\n\t\t\t\t\tpr_cont(\" \" X86_CAP_FMT, x86_cap_flag(bit));\n\n\t\t\t\tsetup_clear_cpu_cap(bit);\n\t\t\t\ttaint++;\n\t\t\t}\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (bit = 0; bit < 32 * NCAPINTS; bit++) {\n\t\t\tif (!x86_cap_flag(bit))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(x86_cap_flag(bit), opt))\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\" %s\", opt);\n\t\t\tsetup_clear_cpu_cap(bit);\n\t\t\ttaint++;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found)\n\t\t\tpr_cont(\" (unknown: %s)\", opt);\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (taint)\n\t\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n}\n\n \nstatic void __init early_identify_cpu(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_X86_64\n\tc->x86_clflush_size = 64;\n\tc->x86_phys_bits = 36;\n\tc->x86_virt_bits = 48;\n#else\n\tc->x86_clflush_size = 32;\n\tc->x86_phys_bits = 32;\n\tc->x86_virt_bits = 32;\n#endif\n\tc->x86_cache_alignment = c->x86_clflush_size;\n\n\tmemset(&c->x86_capability, 0, sizeof(c->x86_capability));\n\tc->extended_cpuid_level = 0;\n\n\tif (!have_cpuid_p())\n\t\tidentify_cpu_without_cpuid(c);\n\n\t \n\tif (have_cpuid_p()) {\n\t\tcpu_detect(c);\n\t\tget_cpu_vendor(c);\n\t\tget_cpu_cap(c);\n\t\tget_cpu_address_sizes(c);\n\t\tsetup_force_cpu_cap(X86_FEATURE_CPUID);\n\t\tcpu_parse_early_param();\n\n\t\tif (this_cpu->c_early_init)\n\t\t\tthis_cpu->c_early_init(c);\n\n\t\tc->cpu_index = 0;\n\t\tfilter_cpuid_features(c, false);\n\n\t\tif (this_cpu->c_bsp_init)\n\t\t\tthis_cpu->c_bsp_init(c);\n\t} else {\n\t\tsetup_clear_cpu_cap(X86_FEATURE_CPUID);\n\t}\n\n\tsetup_force_cpu_cap(X86_FEATURE_ALWAYS);\n\n\tcpu_set_bug_bits(c);\n\n\tsld_setup(c);\n\n#ifdef CONFIG_X86_32\n\t \n\tsetup_clear_cpu_cap(X86_FEATURE_PCID);\n#endif\n\n\t \n\tif (!pgtable_l5_enabled())\n\t\tsetup_clear_cpu_cap(X86_FEATURE_LA57);\n\n\tdetect_nopl();\n}\n\nvoid __init early_cpu_init(void)\n{\n\tconst struct cpu_dev *const *cdev;\n\tint count = 0;\n\n#ifdef CONFIG_PROCESSOR_SELECT\n\tpr_info(\"KERNEL supported cpus:\\n\");\n#endif\n\n\tfor (cdev = __x86_cpu_dev_start; cdev < __x86_cpu_dev_end; cdev++) {\n\t\tconst struct cpu_dev *cpudev = *cdev;\n\n\t\tif (count >= X86_VENDOR_NUM)\n\t\t\tbreak;\n\t\tcpu_devs[count] = cpudev;\n\t\tcount++;\n\n#ifdef CONFIG_PROCESSOR_SELECT\n\t\t{\n\t\t\tunsigned int j;\n\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (!cpudev->c_ident[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_info(\"  %s %s\\n\", cpudev->c_vendor,\n\t\t\t\t\tcpudev->c_ident[j]);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tearly_identify_cpu(&boot_cpu_data);\n}\n\nstatic bool detect_null_seg_behavior(void)\n{\n\t \n\n\tunsigned long old_base, tmp;\n\trdmsrl(MSR_FS_BASE, old_base);\n\twrmsrl(MSR_FS_BASE, 1);\n\tloadsegment(fs, 0);\n\trdmsrl(MSR_FS_BASE, tmp);\n\twrmsrl(MSR_FS_BASE, old_base);\n\treturn tmp == 0;\n}\n\nvoid check_null_seg_clears_base(struct cpuinfo_x86 *c)\n{\n\t \n\tif (!IS_ENABLED(CONFIG_X86_64))\n\t\treturn;\n\n\tif (cpu_has(c, X86_FEATURE_NULL_SEL_CLR_BASE))\n\t\treturn;\n\n\t \n\tif (cpu_has(c, X86_FEATURE_HYPERVISOR)) {\n\t\tset_cpu_bug(c, X86_BUG_NULL_SEG);\n\t\treturn;\n\t}\n\n\t \n\tif ((c->x86 == 0x17 || c->x86 == 0x18) &&\n\t    detect_null_seg_behavior())\n\t\treturn;\n\n\t \n\tset_cpu_bug(c, X86_BUG_NULL_SEG);\n}\n\nstatic void generic_identify(struct cpuinfo_x86 *c)\n{\n\tc->extended_cpuid_level = 0;\n\n\tif (!have_cpuid_p())\n\t\tidentify_cpu_without_cpuid(c);\n\n\t \n\tif (!have_cpuid_p())\n\t\treturn;\n\n\tcpu_detect(c);\n\n\tget_cpu_vendor(c);\n\n\tget_cpu_cap(c);\n\n\tget_cpu_address_sizes(c);\n\n\tif (c->cpuid_level >= 0x00000001) {\n\t\tc->initial_apicid = (cpuid_ebx(1) >> 24) & 0xFF;\n#ifdef CONFIG_X86_32\n# ifdef CONFIG_SMP\n\t\tc->apicid = apic->phys_pkg_id(c->initial_apicid, 0);\n# else\n\t\tc->apicid = c->initial_apicid;\n# endif\n#endif\n\t\tc->phys_proc_id = c->initial_apicid;\n\t}\n\n\tget_model_name(c);  \n\n\t \n#ifdef CONFIG_X86_32\n\tset_cpu_bug(c, X86_BUG_ESPFIX);\n#endif\n}\n\n \nstatic void validate_apic_and_package_id(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tunsigned int apicid, cpu = smp_processor_id();\n\n\tapicid = apic->cpu_present_to_apicid(cpu);\n\n\tif (apicid != c->apicid) {\n\t\tpr_err(FW_BUG \"CPU%u: APIC id mismatch. Firmware: %x APIC: %x\\n\",\n\t\t       cpu, apicid, c->initial_apicid);\n\t}\n\tBUG_ON(topology_update_package_map(c->phys_proc_id, cpu));\n\tBUG_ON(topology_update_die_map(c->cpu_die_id, cpu));\n#else\n\tc->logical_proc_id = 0;\n#endif\n}\n\n \nstatic void identify_cpu(struct cpuinfo_x86 *c)\n{\n\tint i;\n\n\tc->loops_per_jiffy = loops_per_jiffy;\n\tc->x86_cache_size = 0;\n\tc->x86_vendor = X86_VENDOR_UNKNOWN;\n\tc->x86_model = c->x86_stepping = 0;\t \n\tc->x86_vendor_id[0] = '\\0';  \n\tc->x86_model_id[0] = '\\0';   \n\tc->x86_max_cores = 1;\n\tc->x86_coreid_bits = 0;\n\tc->cu_id = 0xff;\n#ifdef CONFIG_X86_64\n\tc->x86_clflush_size = 64;\n\tc->x86_phys_bits = 36;\n\tc->x86_virt_bits = 48;\n#else\n\tc->cpuid_level = -1;\t \n\tc->x86_clflush_size = 32;\n\tc->x86_phys_bits = 32;\n\tc->x86_virt_bits = 32;\n#endif\n\tc->x86_cache_alignment = c->x86_clflush_size;\n\tmemset(&c->x86_capability, 0, sizeof(c->x86_capability));\n#ifdef CONFIG_X86_VMX_FEATURE_NAMES\n\tmemset(&c->vmx_capability, 0, sizeof(c->vmx_capability));\n#endif\n\n\tgeneric_identify(c);\n\n\tif (this_cpu->c_identify)\n\t\tthis_cpu->c_identify(c);\n\n\t \n\tapply_forced_caps(c);\n\n#ifdef CONFIG_X86_64\n\tc->apicid = apic->phys_pkg_id(c->initial_apicid, 0);\n#endif\n\n\t \n\tif (this_cpu->c_init)\n\t\tthis_cpu->c_init(c);\n\n\t \n\tsquash_the_stupid_serial_number(c);\n\n\t \n\tsetup_smep(c);\n\tsetup_smap(c);\n\tsetup_umip(c);\n\n\t \n\tif (cpu_has(c, X86_FEATURE_FSGSBASE)) {\n\t\tcr4_set_bits(X86_CR4_FSGSBASE);\n\t\telf_hwcap2 |= HWCAP2_FSGSBASE;\n\t}\n\n\t \n\n\t \n\tfilter_cpuid_features(c, true);\n\n\t \n\tif (!c->x86_model_id[0]) {\n\t\tconst char *p;\n\t\tp = table_lookup_model(c);\n\t\tif (p)\n\t\t\tstrcpy(c->x86_model_id, p);\n\t\telse\n\t\t\t \n\t\t\tsprintf(c->x86_model_id, \"%02x/%02x\",\n\t\t\t\tc->x86, c->x86_model);\n\t}\n\n#ifdef CONFIG_X86_64\n\tdetect_ht(c);\n#endif\n\n\tx86_init_rdrand(c);\n\tsetup_pku(c);\n\tsetup_cet(c);\n\n\t \n\tapply_forced_caps(c);\n\n\t \n\tif (c != &boot_cpu_data) {\n\t\t \n\t\tfor (i = 0; i < NCAPINTS; i++)\n\t\t\tboot_cpu_data.x86_capability[i] &= c->x86_capability[i];\n\n\t\t \n\t\tfor (i = NCAPINTS; i < NCAPINTS + NBUGINTS; i++)\n\t\t\tc->x86_capability[i] |= boot_cpu_data.x86_capability[i];\n\t}\n\n\tppin_init(c);\n\n\t \n\tmcheck_cpu_init(c);\n\n\tselect_idle_routine(c);\n\n#ifdef CONFIG_NUMA\n\tnuma_add_cpu(smp_processor_id());\n#endif\n}\n\n \n#ifdef CONFIG_X86_32\nvoid enable_sep_cpu(void)\n{\n\tstruct tss_struct *tss;\n\tint cpu;\n\n\tif (!boot_cpu_has(X86_FEATURE_SEP))\n\t\treturn;\n\n\tcpu = get_cpu();\n\ttss = &per_cpu(cpu_tss_rw, cpu);\n\n\t \n\n\ttss->x86_tss.ss1 = __KERNEL_CS;\n\twrmsr(MSR_IA32_SYSENTER_CS, tss->x86_tss.ss1, 0);\n\twrmsr(MSR_IA32_SYSENTER_ESP, (unsigned long)(cpu_entry_stack(cpu) + 1), 0);\n\twrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long)entry_SYSENTER_32, 0);\n\n\tput_cpu();\n}\n#endif\n\nstatic __init void identify_boot_cpu(void)\n{\n\tidentify_cpu(&boot_cpu_data);\n\tif (HAS_KERNEL_IBT && cpu_feature_enabled(X86_FEATURE_IBT))\n\t\tpr_info(\"CET detected: Indirect Branch Tracking enabled\\n\");\n#ifdef CONFIG_X86_32\n\tenable_sep_cpu();\n#endif\n\tcpu_detect_tlb(&boot_cpu_data);\n\tsetup_cr_pinning();\n\n\ttsx_init();\n\tlkgs_init();\n}\n\nvoid identify_secondary_cpu(struct cpuinfo_x86 *c)\n{\n\tBUG_ON(c == &boot_cpu_data);\n\tidentify_cpu(c);\n#ifdef CONFIG_X86_32\n\tenable_sep_cpu();\n#endif\n\tvalidate_apic_and_package_id(c);\n\tx86_spec_ctrl_setup_ap();\n\tupdate_srbds_msr();\n\tif (boot_cpu_has_bug(X86_BUG_GDS))\n\t\tupdate_gds_msr();\n\n\ttsx_ap_init();\n}\n\nvoid print_cpu_info(struct cpuinfo_x86 *c)\n{\n\tconst char *vendor = NULL;\n\n\tif (c->x86_vendor < X86_VENDOR_NUM) {\n\t\tvendor = this_cpu->c_vendor;\n\t} else {\n\t\tif (c->cpuid_level >= 0)\n\t\t\tvendor = c->x86_vendor_id;\n\t}\n\n\tif (vendor && !strstr(c->x86_model_id, vendor))\n\t\tpr_cont(\"%s \", vendor);\n\n\tif (c->x86_model_id[0])\n\t\tpr_cont(\"%s\", c->x86_model_id);\n\telse\n\t\tpr_cont(\"%d86\", c->x86);\n\n\tpr_cont(\" (family: 0x%x, model: 0x%x\", c->x86, c->x86_model);\n\n\tif (c->x86_stepping || c->cpuid_level >= 0)\n\t\tpr_cont(\", stepping: 0x%x)\\n\", c->x86_stepping);\n\telse\n\t\tpr_cont(\")\\n\");\n}\n\n \nstatic __init int setup_clearcpuid(char *arg)\n{\n\treturn 1;\n}\n__setup(\"clearcpuid=\", setup_clearcpuid);\n\nDEFINE_PER_CPU_ALIGNED(struct pcpu_hot, pcpu_hot) = {\n\t.current_task\t= &init_task,\n\t.preempt_count\t= INIT_PREEMPT_COUNT,\n\t.top_of_stack\t= TOP_OF_INIT_STACK,\n};\nEXPORT_PER_CPU_SYMBOL(pcpu_hot);\n\n#ifdef CONFIG_X86_64\nDEFINE_PER_CPU_FIRST(struct fixed_percpu_data,\n\t\t     fixed_percpu_data) __aligned(PAGE_SIZE) __visible;\nEXPORT_PER_CPU_SYMBOL_GPL(fixed_percpu_data);\n\nstatic void wrmsrl_cstar(unsigned long val)\n{\n\t \n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\twrmsrl(MSR_CSTAR, val);\n}\n\n \nvoid syscall_init(void)\n{\n\twrmsr(MSR_STAR, 0, (__USER32_CS << 16) | __KERNEL_CS);\n\twrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64);\n\n#ifdef CONFIG_IA32_EMULATION\n\twrmsrl_cstar((unsigned long)entry_SYSCALL_compat);\n\t \n\twrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)__KERNEL_CS);\n\twrmsrl_safe(MSR_IA32_SYSENTER_ESP,\n\t\t    (unsigned long)(cpu_entry_stack(smp_processor_id()) + 1));\n\twrmsrl_safe(MSR_IA32_SYSENTER_EIP, (u64)entry_SYSENTER_compat);\n#else\n\twrmsrl_cstar((unsigned long)ignore_sysret);\n\twrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)GDT_ENTRY_INVALID_SEG);\n\twrmsrl_safe(MSR_IA32_SYSENTER_ESP, 0ULL);\n\twrmsrl_safe(MSR_IA32_SYSENTER_EIP, 0ULL);\n#endif\n\n\t \n\twrmsrl(MSR_SYSCALL_MASK,\n\t       X86_EFLAGS_CF|X86_EFLAGS_PF|X86_EFLAGS_AF|\n\t       X86_EFLAGS_ZF|X86_EFLAGS_SF|X86_EFLAGS_TF|\n\t       X86_EFLAGS_IF|X86_EFLAGS_DF|X86_EFLAGS_OF|\n\t       X86_EFLAGS_IOPL|X86_EFLAGS_NT|X86_EFLAGS_RF|\n\t       X86_EFLAGS_AC|X86_EFLAGS_ID);\n}\n\n#else\t \n\n#ifdef CONFIG_STACKPROTECTOR\nDEFINE_PER_CPU(unsigned long, __stack_chk_guard);\nEXPORT_PER_CPU_SYMBOL(__stack_chk_guard);\n#endif\n\n#endif\t \n\n \nstatic void clear_all_debug_regs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tif ((i == 4) || (i == 5))\n\t\t\tcontinue;\n\n\t\tset_debugreg(0, i);\n\t}\n}\n\n#ifdef CONFIG_KGDB\n \nstatic void dbg_restore_debug_regs(void)\n{\n\tif (unlikely(kgdb_connected && arch_kgdb_ops.correct_hw_break))\n\t\tarch_kgdb_ops.correct_hw_break();\n}\n#else  \n#define dbg_restore_debug_regs()\n#endif  \n\nstatic inline void setup_getcpu(int cpu)\n{\n\tunsigned long cpudata = vdso_encode_cpunode(cpu, early_cpu_to_node(cpu));\n\tstruct desc_struct d = { };\n\n\tif (boot_cpu_has(X86_FEATURE_RDTSCP) || boot_cpu_has(X86_FEATURE_RDPID))\n\t\twrmsr(MSR_TSC_AUX, cpudata, 0);\n\n\t \n\td.limit0 = cpudata;\n\td.limit1 = cpudata >> 16;\n\n\td.type = 5;\t\t \n\td.dpl = 3;\t\t \n\td.s = 1;\t\t \n\td.p = 1;\t\t \n\td.d = 1;\t\t \n\n\twrite_gdt_entry(get_cpu_gdt_rw(cpu), GDT_ENTRY_CPUNODE, &d, DESCTYPE_S);\n}\n\n#ifdef CONFIG_X86_64\nstatic inline void ucode_cpu_init(int cpu) { }\n\nstatic inline void tss_setup_ist(struct tss_struct *tss)\n{\n\t \n\ttss->x86_tss.ist[IST_INDEX_DF] = __this_cpu_ist_top_va(DF);\n\ttss->x86_tss.ist[IST_INDEX_NMI] = __this_cpu_ist_top_va(NMI);\n\ttss->x86_tss.ist[IST_INDEX_DB] = __this_cpu_ist_top_va(DB);\n\ttss->x86_tss.ist[IST_INDEX_MCE] = __this_cpu_ist_top_va(MCE);\n\t \n\ttss->x86_tss.ist[IST_INDEX_VC] = __this_cpu_ist_top_va(VC);\n}\n\n#else  \n\nstatic inline void ucode_cpu_init(int cpu)\n{\n\tshow_ucode_info_early();\n}\n\nstatic inline void tss_setup_ist(struct tss_struct *tss) { }\n\n#endif  \n\nstatic inline void tss_setup_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n\n#ifdef CONFIG_X86_IOPL_IOPERM\n\ttss->io_bitmap.prev_max = 0;\n\ttss->io_bitmap.prev_sequence = 0;\n\tmemset(tss->io_bitmap.bitmap, 0xff, sizeof(tss->io_bitmap.bitmap));\n\t \n\ttss->io_bitmap.mapall[IO_BITMAP_LONGS] = ~0UL;\n#endif\n}\n\n \nvoid cpu_init_exception_handling(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tint cpu = raw_smp_processor_id();\n\n\t \n\tsetup_getcpu(cpu);\n\n\t \n\ttss_setup_ist(tss);\n\ttss_setup_io_bitmap(tss);\n\tset_tss_desc(cpu, &get_cpu_entry_area(cpu)->tss.x86_tss);\n\n\tload_TR_desc();\n\n\t \n\tsetup_ghcb();\n\n\t \n\tload_current_idt();\n}\n\n \nvoid cpu_init(void)\n{\n\tstruct task_struct *cur = current;\n\tint cpu = raw_smp_processor_id();\n\n\tucode_cpu_init(cpu);\n\n#ifdef CONFIG_NUMA\n\tif (this_cpu_read(numa_node) == 0 &&\n\t    early_cpu_to_node(cpu) != NUMA_NO_NODE)\n\t\tset_numa_node(early_cpu_to_node(cpu));\n#endif\n\tpr_debug(\"Initializing CPU#%d\\n\", cpu);\n\n\tif (IS_ENABLED(CONFIG_X86_64) || cpu_feature_enabled(X86_FEATURE_VME) ||\n\t    boot_cpu_has(X86_FEATURE_TSC) || boot_cpu_has(X86_FEATURE_DE))\n\t\tcr4_clear_bits(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);\n\n\tif (IS_ENABLED(CONFIG_X86_64)) {\n\t\tloadsegment(fs, 0);\n\t\tmemset(cur->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);\n\t\tsyscall_init();\n\n\t\twrmsrl(MSR_FS_BASE, 0);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, 0);\n\t\tbarrier();\n\n\t\tx2apic_setup();\n\t}\n\n\tmmgrab(&init_mm);\n\tcur->active_mm = &init_mm;\n\tBUG_ON(cur->mm);\n\tinitialize_tlbstate_and_flush();\n\tenter_lazy_tlb(&init_mm, cur);\n\n\t \n\tload_sp0((unsigned long)(cpu_entry_stack(cpu) + 1));\n\n\tload_mm_ldt(&init_mm);\n\n\tclear_all_debug_regs();\n\tdbg_restore_debug_regs();\n\n\tdoublefault_init_cpu_tss();\n\n\tif (is_uv_system())\n\t\tuv_cpu_init();\n\n\tload_fixmap_gdt(cpu);\n}\n\n#ifdef CONFIG_MICROCODE_LATE_LOADING\n \nvoid store_cpu_caps(struct cpuinfo_x86 *curr_info)\n{\n\t \n\tcurr_info->cpuid_level = cpuid_eax(0);\n\n\t \n\tmemcpy(&curr_info->x86_capability, &boot_cpu_data.x86_capability,\n\t       sizeof(curr_info->x86_capability));\n\n\t \n\tget_cpu_cap(curr_info);\n}\n\n \nvoid microcode_check(struct cpuinfo_x86 *prev_info)\n{\n\tstruct cpuinfo_x86 curr_info;\n\n\tperf_check_microcode();\n\n\tamd_check_microcode();\n\n\tstore_cpu_caps(&curr_info);\n\n\tif (!memcmp(&prev_info->x86_capability, &curr_info.x86_capability,\n\t\t    sizeof(prev_info->x86_capability)))\n\t\treturn;\n\n\tpr_warn(\"x86/CPU: CPU features have changed after loading microcode, but might not take effect.\\n\");\n\tpr_warn(\"x86/CPU: Please consider either early loading through initrd/built-in or a potential BIOS update.\\n\");\n}\n#endif\n\n \nvoid arch_smt_update(void)\n{\n\t \n\tcpu_bugs_smt_update();\n\t \n\tapic_smt_update();\n}\n\nvoid __init arch_cpu_finalize_init(void)\n{\n\tidentify_boot_cpu();\n\n\t \n\tcpu_smt_set_num_threads(smp_num_siblings, smp_num_siblings);\n\n\tif (!IS_ENABLED(CONFIG_SMP)) {\n\t\tpr_info(\"CPU: \");\n\t\tprint_cpu_info(&boot_cpu_data);\n\t}\n\n\tcpu_select_mitigations();\n\n\tarch_smt_update();\n\n\tif (IS_ENABLED(CONFIG_X86_32)) {\n\t\t \n\t\tif (boot_cpu_data.x86 < 4)\n\t\t\tpanic(\"Kernel requires i486+ for 'invlpg' and other features\");\n\n\t\tinit_utsname()->machine[1] =\n\t\t\t'0' + (boot_cpu_data.x86 > 6 ? 6 : boot_cpu_data.x86);\n\t}\n\n\t \n\tfpu__init_system();\n\tfpu__init_cpu();\n\n\talternative_instructions();\n\n\tif (IS_ENABLED(CONFIG_X86_64)) {\n\t\t \n\t\tif (!direct_gbpages)\n\t\t\tset_memory_4k((unsigned long)__va(0), 1);\n\t} else {\n\t\tfpu__init_check_bugs();\n\t}\n\n\t \n\tmem_encrypt_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}