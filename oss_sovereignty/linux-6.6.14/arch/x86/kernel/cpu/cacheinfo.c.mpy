{
  "module_name": "cacheinfo.c",
  "hash_id": "8a428e02cb2df9f5d59b8530545035873b28e50333705ca1f20141af9f7ce6f0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/cacheinfo.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/cacheinfo.h>\n#include <linux/cpu.h>\n#include <linux/cpuhotplug.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/sysfs.h>\n#include <linux/pci.h>\n#include <linux/stop_machine.h>\n\n#include <asm/cpufeature.h>\n#include <asm/cacheinfo.h>\n#include <asm/amd_nb.h>\n#include <asm/smp.h>\n#include <asm/mtrr.h>\n#include <asm/tlbflush.h>\n\n#include \"cpu.h\"\n\n#define LVL_1_INST\t1\n#define LVL_1_DATA\t2\n#define LVL_2\t\t3\n#define LVL_3\t\t4\n#define LVL_TRACE\t5\n\n \nDEFINE_PER_CPU_READ_MOSTLY(cpumask_var_t, cpu_llc_shared_map);\n\n \nDEFINE_PER_CPU_READ_MOSTLY(cpumask_var_t, cpu_l2c_shared_map);\n\nstatic cpumask_var_t cpu_cacheinfo_mask;\n\n \nunsigned int memory_caching_control __ro_after_init;\n\nstruct _cache_table {\n\tunsigned char descriptor;\n\tchar cache_type;\n\tshort size;\n};\n\n#define MB(x)\t((x) * 1024)\n\n \n\nstatic const struct _cache_table cache_table[] =\n{\n\t{ 0x06, LVL_1_INST, 8 },\t \n\t{ 0x08, LVL_1_INST, 16 },\t \n\t{ 0x09, LVL_1_INST, 32 },\t \n\t{ 0x0a, LVL_1_DATA, 8 },\t \n\t{ 0x0c, LVL_1_DATA, 16 },\t \n\t{ 0x0d, LVL_1_DATA, 16 },\t \n\t{ 0x0e, LVL_1_DATA, 24 },\t \n\t{ 0x21, LVL_2,      256 },\t \n\t{ 0x22, LVL_3,      512 },\t \n\t{ 0x23, LVL_3,      MB(1) },\t \n\t{ 0x25, LVL_3,      MB(2) },\t \n\t{ 0x29, LVL_3,      MB(4) },\t \n\t{ 0x2c, LVL_1_DATA, 32 },\t \n\t{ 0x30, LVL_1_INST, 32 },\t \n\t{ 0x39, LVL_2,      128 },\t \n\t{ 0x3a, LVL_2,      192 },\t \n\t{ 0x3b, LVL_2,      128 },\t \n\t{ 0x3c, LVL_2,      256 },\t \n\t{ 0x3d, LVL_2,      384 },\t \n\t{ 0x3e, LVL_2,      512 },\t \n\t{ 0x3f, LVL_2,      256 },\t \n\t{ 0x41, LVL_2,      128 },\t \n\t{ 0x42, LVL_2,      256 },\t \n\t{ 0x43, LVL_2,      512 },\t \n\t{ 0x44, LVL_2,      MB(1) },\t \n\t{ 0x45, LVL_2,      MB(2) },\t \n\t{ 0x46, LVL_3,      MB(4) },\t \n\t{ 0x47, LVL_3,      MB(8) },\t \n\t{ 0x48, LVL_2,      MB(3) },\t \n\t{ 0x49, LVL_3,      MB(4) },\t \n\t{ 0x4a, LVL_3,      MB(6) },\t \n\t{ 0x4b, LVL_3,      MB(8) },\t \n\t{ 0x4c, LVL_3,      MB(12) },\t \n\t{ 0x4d, LVL_3,      MB(16) },\t \n\t{ 0x4e, LVL_2,      MB(6) },\t \n\t{ 0x60, LVL_1_DATA, 16 },\t \n\t{ 0x66, LVL_1_DATA, 8 },\t \n\t{ 0x67, LVL_1_DATA, 16 },\t \n\t{ 0x68, LVL_1_DATA, 32 },\t \n\t{ 0x70, LVL_TRACE,  12 },\t \n\t{ 0x71, LVL_TRACE,  16 },\t \n\t{ 0x72, LVL_TRACE,  32 },\t \n\t{ 0x73, LVL_TRACE,  64 },\t \n\t{ 0x78, LVL_2,      MB(1) },\t \n\t{ 0x79, LVL_2,      128 },\t \n\t{ 0x7a, LVL_2,      256 },\t \n\t{ 0x7b, LVL_2,      512 },\t \n\t{ 0x7c, LVL_2,      MB(1) },\t \n\t{ 0x7d, LVL_2,      MB(2) },\t \n\t{ 0x7f, LVL_2,      512 },\t \n\t{ 0x80, LVL_2,      512 },\t \n\t{ 0x82, LVL_2,      256 },\t \n\t{ 0x83, LVL_2,      512 },\t \n\t{ 0x84, LVL_2,      MB(1) },\t \n\t{ 0x85, LVL_2,      MB(2) },\t \n\t{ 0x86, LVL_2,      512 },\t \n\t{ 0x87, LVL_2,      MB(1) },\t \n\t{ 0xd0, LVL_3,      512 },\t \n\t{ 0xd1, LVL_3,      MB(1) },\t \n\t{ 0xd2, LVL_3,      MB(2) },\t \n\t{ 0xd6, LVL_3,      MB(1) },\t \n\t{ 0xd7, LVL_3,      MB(2) },\t \n\t{ 0xd8, LVL_3,      MB(4) },\t \n\t{ 0xdc, LVL_3,      MB(2) },\t \n\t{ 0xdd, LVL_3,      MB(4) },\t \n\t{ 0xde, LVL_3,      MB(8) },\t \n\t{ 0xe2, LVL_3,      MB(2) },\t \n\t{ 0xe3, LVL_3,      MB(4) },\t \n\t{ 0xe4, LVL_3,      MB(8) },\t \n\t{ 0xea, LVL_3,      MB(12) },\t \n\t{ 0xeb, LVL_3,      MB(18) },\t \n\t{ 0xec, LVL_3,      MB(24) },\t \n\t{ 0x00, 0, 0}\n};\n\n\nenum _cache_type {\n\tCTYPE_NULL = 0,\n\tCTYPE_DATA = 1,\n\tCTYPE_INST = 2,\n\tCTYPE_UNIFIED = 3\n};\n\nunion _cpuid4_leaf_eax {\n\tstruct {\n\t\tenum _cache_type\ttype:5;\n\t\tunsigned int\t\tlevel:3;\n\t\tunsigned int\t\tis_self_initializing:1;\n\t\tunsigned int\t\tis_fully_associative:1;\n\t\tunsigned int\t\treserved:4;\n\t\tunsigned int\t\tnum_threads_sharing:12;\n\t\tunsigned int\t\tnum_cores_on_die:6;\n\t} split;\n\tu32 full;\n};\n\nunion _cpuid4_leaf_ebx {\n\tstruct {\n\t\tunsigned int\t\tcoherency_line_size:12;\n\t\tunsigned int\t\tphysical_line_partition:10;\n\t\tunsigned int\t\tways_of_associativity:10;\n\t} split;\n\tu32 full;\n};\n\nunion _cpuid4_leaf_ecx {\n\tstruct {\n\t\tunsigned int\t\tnumber_of_sets:32;\n\t} split;\n\tu32 full;\n};\n\nstruct _cpuid4_info_regs {\n\tunion _cpuid4_leaf_eax eax;\n\tunion _cpuid4_leaf_ebx ebx;\n\tunion _cpuid4_leaf_ecx ecx;\n\tunsigned int id;\n\tunsigned long size;\n\tstruct amd_northbridge *nb;\n};\n\nstatic unsigned short num_cache_leaves;\n\n \nunion l1_cache {\n\tstruct {\n\t\tunsigned line_size:8;\n\t\tunsigned lines_per_tag:8;\n\t\tunsigned assoc:8;\n\t\tunsigned size_in_kb:8;\n\t};\n\tunsigned val;\n};\n\nunion l2_cache {\n\tstruct {\n\t\tunsigned line_size:8;\n\t\tunsigned lines_per_tag:4;\n\t\tunsigned assoc:4;\n\t\tunsigned size_in_kb:16;\n\t};\n\tunsigned val;\n};\n\nunion l3_cache {\n\tstruct {\n\t\tunsigned line_size:8;\n\t\tunsigned lines_per_tag:4;\n\t\tunsigned assoc:4;\n\t\tunsigned res:2;\n\t\tunsigned size_encoded:14;\n\t};\n\tunsigned val;\n};\n\nstatic const unsigned short assocs[] = {\n\t[1] = 1,\n\t[2] = 2,\n\t[4] = 4,\n\t[6] = 8,\n\t[8] = 16,\n\t[0xa] = 32,\n\t[0xb] = 48,\n\t[0xc] = 64,\n\t[0xd] = 96,\n\t[0xe] = 128,\n\t[0xf] = 0xffff  \n};\n\nstatic const unsigned char levels[] = { 1, 1, 2, 3 };\nstatic const unsigned char types[] = { 1, 2, 3, 3 };\n\nstatic const enum cache_type cache_type_map[] = {\n\t[CTYPE_NULL] = CACHE_TYPE_NOCACHE,\n\t[CTYPE_DATA] = CACHE_TYPE_DATA,\n\t[CTYPE_INST] = CACHE_TYPE_INST,\n\t[CTYPE_UNIFIED] = CACHE_TYPE_UNIFIED,\n};\n\nstatic void\namd_cpuid4(int leaf, union _cpuid4_leaf_eax *eax,\n\t\t     union _cpuid4_leaf_ebx *ebx,\n\t\t     union _cpuid4_leaf_ecx *ecx)\n{\n\tunsigned dummy;\n\tunsigned line_size, lines_per_tag, assoc, size_in_kb;\n\tunion l1_cache l1i, l1d;\n\tunion l2_cache l2;\n\tunion l3_cache l3;\n\tunion l1_cache *l1 = &l1d;\n\n\teax->full = 0;\n\tebx->full = 0;\n\tecx->full = 0;\n\n\tcpuid(0x80000005, &dummy, &dummy, &l1d.val, &l1i.val);\n\tcpuid(0x80000006, &dummy, &dummy, &l2.val, &l3.val);\n\n\tswitch (leaf) {\n\tcase 1:\n\t\tl1 = &l1i;\n\t\tfallthrough;\n\tcase 0:\n\t\tif (!l1->val)\n\t\t\treturn;\n\t\tassoc = assocs[l1->assoc];\n\t\tline_size = l1->line_size;\n\t\tlines_per_tag = l1->lines_per_tag;\n\t\tsize_in_kb = l1->size_in_kb;\n\t\tbreak;\n\tcase 2:\n\t\tif (!l2.val)\n\t\t\treturn;\n\t\tassoc = assocs[l2.assoc];\n\t\tline_size = l2.line_size;\n\t\tlines_per_tag = l2.lines_per_tag;\n\t\t \n\t\tsize_in_kb = __this_cpu_read(cpu_info.x86_cache_size);\n\t\tbreak;\n\tcase 3:\n\t\tif (!l3.val)\n\t\t\treturn;\n\t\tassoc = assocs[l3.assoc];\n\t\tline_size = l3.line_size;\n\t\tlines_per_tag = l3.lines_per_tag;\n\t\tsize_in_kb = l3.size_encoded * 512;\n\t\tif (boot_cpu_has(X86_FEATURE_AMD_DCM)) {\n\t\t\tsize_in_kb = size_in_kb >> 1;\n\t\t\tassoc = assoc >> 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\teax->split.is_self_initializing = 1;\n\teax->split.type = types[leaf];\n\teax->split.level = levels[leaf];\n\teax->split.num_threads_sharing = 0;\n\teax->split.num_cores_on_die = __this_cpu_read(cpu_info.x86_max_cores) - 1;\n\n\n\tif (assoc == 0xffff)\n\t\teax->split.is_fully_associative = 1;\n\tebx->split.coherency_line_size = line_size - 1;\n\tebx->split.ways_of_associativity = assoc - 1;\n\tebx->split.physical_line_partition = lines_per_tag - 1;\n\tecx->split.number_of_sets = (size_in_kb * 1024) / line_size /\n\t\t(ebx->split.ways_of_associativity + 1) - 1;\n}\n\n#if defined(CONFIG_AMD_NB) && defined(CONFIG_SYSFS)\n\n \nstatic void amd_calc_l3_indices(struct amd_northbridge *nb)\n{\n\tstruct amd_l3_cache *l3 = &nb->l3_cache;\n\tunsigned int sc0, sc1, sc2, sc3;\n\tu32 val = 0;\n\n\tpci_read_config_dword(nb->misc, 0x1C4, &val);\n\n\t \n\tl3->subcaches[0] = sc0 = !(val & BIT(0));\n\tl3->subcaches[1] = sc1 = !(val & BIT(4));\n\n\tif (boot_cpu_data.x86 == 0x15) {\n\t\tl3->subcaches[0] = sc0 += !(val & BIT(1));\n\t\tl3->subcaches[1] = sc1 += !(val & BIT(5));\n\t}\n\n\tl3->subcaches[2] = sc2 = !(val & BIT(8))  + !(val & BIT(9));\n\tl3->subcaches[3] = sc3 = !(val & BIT(12)) + !(val & BIT(13));\n\n\tl3->indices = (max(max3(sc0, sc1, sc2), sc3) << 10) - 1;\n}\n\n \nstatic int amd_get_l3_disable_slot(struct amd_northbridge *nb, unsigned slot)\n{\n\tunsigned int reg = 0;\n\n\tpci_read_config_dword(nb->misc, 0x1BC + slot * 4, &reg);\n\n\t \n\tif (reg & (3UL << 30))\n\t\treturn reg & 0xfff;\n\n\treturn -1;\n}\n\nstatic ssize_t show_cache_disable(struct cacheinfo *this_leaf, char *buf,\n\t\t\t\t  unsigned int slot)\n{\n\tint index;\n\tstruct amd_northbridge *nb = this_leaf->priv;\n\n\tindex = amd_get_l3_disable_slot(nb, slot);\n\tif (index >= 0)\n\t\treturn sprintf(buf, \"%d\\n\", index);\n\n\treturn sprintf(buf, \"FREE\\n\");\n}\n\n#define SHOW_CACHE_DISABLE(slot)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\ncache_disable_##slot##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\t\t\\\n\treturn show_cache_disable(this_leaf, buf, slot);\t\t\\\n}\nSHOW_CACHE_DISABLE(0)\nSHOW_CACHE_DISABLE(1)\n\nstatic void amd_l3_disable_index(struct amd_northbridge *nb, int cpu,\n\t\t\t\t unsigned slot, unsigned long idx)\n{\n\tint i;\n\n\tidx |= BIT(30);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tu32 reg = idx | (i << 20);\n\n\t\tif (!nb->l3_cache.subcaches[i])\n\t\t\tcontinue;\n\n\t\tpci_write_config_dword(nb->misc, 0x1BC + slot * 4, reg);\n\n\t\t \n\t\twbinvd_on_cpu(cpu);\n\n\t\treg |= BIT(31);\n\t\tpci_write_config_dword(nb->misc, 0x1BC + slot * 4, reg);\n\t}\n}\n\n \nstatic int amd_set_l3_disable_slot(struct amd_northbridge *nb, int cpu,\n\t\t\t    unsigned slot, unsigned long index)\n{\n\tint ret = 0;\n\n\t \n\tret = amd_get_l3_disable_slot(nb, slot);\n\tif (ret >= 0)\n\t\treturn -EEXIST;\n\n\tif (index > nb->l3_cache.indices)\n\t\treturn -EINVAL;\n\n\t \n\tif (index == amd_get_l3_disable_slot(nb, !slot))\n\t\treturn -EEXIST;\n\n\tamd_l3_disable_index(nb, cpu, slot, index);\n\n\treturn 0;\n}\n\nstatic ssize_t store_cache_disable(struct cacheinfo *this_leaf,\n\t\t\t\t   const char *buf, size_t count,\n\t\t\t\t   unsigned int slot)\n{\n\tunsigned long val = 0;\n\tint cpu, err = 0;\n\tstruct amd_northbridge *nb = this_leaf->priv;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcpu = cpumask_first(&this_leaf->shared_cpu_map);\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = amd_set_l3_disable_slot(nb, cpu, slot, val);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\tpr_warn(\"L3 slot %d in use/index already disabled!\\n\",\n\t\t\t\t   slot);\n\t\treturn err;\n\t}\n\treturn count;\n}\n\n#define STORE_CACHE_DISABLE(slot)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\ncache_disable_##slot##_store(struct device *dev,\t\t\t\\\n\t\t\t     struct device_attribute *attr,\t\t\\\n\t\t\t     const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\t\t\\\n\treturn store_cache_disable(this_leaf, buf, count, slot);\t\\\n}\nSTORE_CACHE_DISABLE(0)\nSTORE_CACHE_DISABLE(1)\n\nstatic ssize_t subcaches_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tint cpu = cpumask_first(&this_leaf->shared_cpu_map);\n\n\treturn sprintf(buf, \"%x\\n\", amd_get_subcaches(cpu));\n}\n\nstatic ssize_t subcaches_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tint cpu = cpumask_first(&this_leaf->shared_cpu_map);\n\tunsigned long val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kstrtoul(buf, 16, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (amd_set_subcaches(cpu, val))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(cache_disable_0);\nstatic DEVICE_ATTR_RW(cache_disable_1);\nstatic DEVICE_ATTR_RW(subcaches);\n\nstatic umode_t\ncache_private_attrs_is_visible(struct kobject *kobj,\n\t\t\t       struct attribute *attr, int unused)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (!this_leaf->priv)\n\t\treturn 0;\n\n\tif ((attr == &dev_attr_subcaches.attr) &&\n\t    amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\n\t\treturn mode;\n\n\tif ((attr == &dev_attr_cache_disable_0.attr ||\n\t     attr == &dev_attr_cache_disable_1.attr) &&\n\t    amd_nb_has_feature(AMD_NB_L3_INDEX_DISABLE))\n\t\treturn mode;\n\n\treturn 0;\n}\n\nstatic struct attribute_group cache_private_group = {\n\t.is_visible = cache_private_attrs_is_visible,\n};\n\nstatic void init_amd_l3_attrs(void)\n{\n\tint n = 1;\n\tstatic struct attribute **amd_l3_attrs;\n\n\tif (amd_l3_attrs)  \n\t\treturn;\n\n\tif (amd_nb_has_feature(AMD_NB_L3_INDEX_DISABLE))\n\t\tn += 2;\n\tif (amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\n\t\tn += 1;\n\n\tamd_l3_attrs = kcalloc(n, sizeof(*amd_l3_attrs), GFP_KERNEL);\n\tif (!amd_l3_attrs)\n\t\treturn;\n\n\tn = 0;\n\tif (amd_nb_has_feature(AMD_NB_L3_INDEX_DISABLE)) {\n\t\tamd_l3_attrs[n++] = &dev_attr_cache_disable_0.attr;\n\t\tamd_l3_attrs[n++] = &dev_attr_cache_disable_1.attr;\n\t}\n\tif (amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\n\t\tamd_l3_attrs[n++] = &dev_attr_subcaches.attr;\n\n\tcache_private_group.attrs = amd_l3_attrs;\n}\n\nconst struct attribute_group *\ncache_get_priv_group(struct cacheinfo *this_leaf)\n{\n\tstruct amd_northbridge *nb = this_leaf->priv;\n\n\tif (this_leaf->level < 3 || !nb)\n\t\treturn NULL;\n\n\tif (nb && nb->l3_cache.indices)\n\t\tinit_amd_l3_attrs();\n\n\treturn &cache_private_group;\n}\n\nstatic void amd_init_l3_cache(struct _cpuid4_info_regs *this_leaf, int index)\n{\n\tint node;\n\n\t \n\tif (index < 3)\n\t\treturn;\n\n\tnode = topology_die_id(smp_processor_id());\n\tthis_leaf->nb = node_to_amd_nb(node);\n\tif (this_leaf->nb && !this_leaf->nb->l3_cache.indices)\n\t\tamd_calc_l3_indices(this_leaf->nb);\n}\n#else\n#define amd_init_l3_cache(x, y)\n#endif   \n\nstatic int\ncpuid4_cache_lookup_regs(int index, struct _cpuid4_info_regs *this_leaf)\n{\n\tunion _cpuid4_leaf_eax\teax;\n\tunion _cpuid4_leaf_ebx\tebx;\n\tunion _cpuid4_leaf_ecx\tecx;\n\tunsigned\t\tedx;\n\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {\n\t\tif (boot_cpu_has(X86_FEATURE_TOPOEXT))\n\t\t\tcpuid_count(0x8000001d, index, &eax.full,\n\t\t\t\t    &ebx.full, &ecx.full, &edx);\n\t\telse\n\t\t\tamd_cpuid4(index, &eax, &ebx, &ecx);\n\t\tamd_init_l3_cache(this_leaf, index);\n\t} else if (boot_cpu_data.x86_vendor == X86_VENDOR_HYGON) {\n\t\tcpuid_count(0x8000001d, index, &eax.full,\n\t\t\t    &ebx.full, &ecx.full, &edx);\n\t\tamd_init_l3_cache(this_leaf, index);\n\t} else {\n\t\tcpuid_count(4, index, &eax.full, &ebx.full, &ecx.full, &edx);\n\t}\n\n\tif (eax.split.type == CTYPE_NULL)\n\t\treturn -EIO;  \n\n\tthis_leaf->eax = eax;\n\tthis_leaf->ebx = ebx;\n\tthis_leaf->ecx = ecx;\n\tthis_leaf->size = (ecx.split.number_of_sets          + 1) *\n\t\t\t  (ebx.split.coherency_line_size     + 1) *\n\t\t\t  (ebx.split.physical_line_partition + 1) *\n\t\t\t  (ebx.split.ways_of_associativity   + 1);\n\treturn 0;\n}\n\nstatic int find_num_cache_leaves(struct cpuinfo_x86 *c)\n{\n\tunsigned int\t\teax, ebx, ecx, edx, op;\n\tunion _cpuid4_leaf_eax\tcache_eax;\n\tint \t\t\ti = -1;\n\n\tif (c->x86_vendor == X86_VENDOR_AMD ||\n\t    c->x86_vendor == X86_VENDOR_HYGON)\n\t\top = 0x8000001d;\n\telse\n\t\top = 4;\n\n\tdo {\n\t\t++i;\n\t\t \n\t\tcpuid_count(op, i, &eax, &ebx, &ecx, &edx);\n\t\tcache_eax.full = eax;\n\t} while (cache_eax.split.type != CTYPE_NULL);\n\treturn i;\n}\n\nvoid cacheinfo_amd_init_llc_id(struct cpuinfo_x86 *c, int cpu)\n{\n\t \n\tif (!cpuid_edx(0x80000006))\n\t\treturn;\n\n\tif (c->x86 < 0x17) {\n\t\t \n\t\tper_cpu(cpu_llc_id, cpu) = c->cpu_die_id;\n\t} else if (c->x86 == 0x17 && c->x86_model <= 0x1F) {\n\t\t \n\t\tper_cpu(cpu_llc_id, cpu) = c->apicid >> 3;\n\t} else {\n\t\t \n\t\tu32 eax, ebx, ecx, edx, num_sharing_cache = 0;\n\t\tu32 llc_index = find_num_cache_leaves(c) - 1;\n\n\t\tcpuid_count(0x8000001d, llc_index, &eax, &ebx, &ecx, &edx);\n\t\tif (eax)\n\t\t\tnum_sharing_cache = ((eax >> 14) & 0xfff) + 1;\n\n\t\tif (num_sharing_cache) {\n\t\t\tint bits = get_count_order(num_sharing_cache);\n\n\t\t\tper_cpu(cpu_llc_id, cpu) = c->apicid >> bits;\n\t\t}\n\t}\n}\n\nvoid cacheinfo_hygon_init_llc_id(struct cpuinfo_x86 *c, int cpu)\n{\n\t \n\tif (!cpuid_edx(0x80000006))\n\t\treturn;\n\n\t \n\tper_cpu(cpu_llc_id, cpu) = c->apicid >> 3;\n}\n\nvoid init_amd_cacheinfo(struct cpuinfo_x86 *c)\n{\n\n\tif (boot_cpu_has(X86_FEATURE_TOPOEXT)) {\n\t\tnum_cache_leaves = find_num_cache_leaves(c);\n\t} else if (c->extended_cpuid_level >= 0x80000006) {\n\t\tif (cpuid_edx(0x80000006) & 0xf000)\n\t\t\tnum_cache_leaves = 4;\n\t\telse\n\t\t\tnum_cache_leaves = 3;\n\t}\n}\n\nvoid init_hygon_cacheinfo(struct cpuinfo_x86 *c)\n{\n\tnum_cache_leaves = find_num_cache_leaves(c);\n}\n\nvoid init_intel_cacheinfo(struct cpuinfo_x86 *c)\n{\n\t \n\tunsigned int l1i = 0, l1d = 0, l2 = 0, l3 = 0;\n\tunsigned int new_l1d = 0, new_l1i = 0;  \n\tunsigned int new_l2 = 0, new_l3 = 0, i;  \n\tunsigned int l2_id = 0, l3_id = 0, num_threads_sharing, index_msb;\n#ifdef CONFIG_SMP\n\tunsigned int cpu = c->cpu_index;\n#endif\n\n\tif (c->cpuid_level > 3) {\n\t\tstatic int is_initialized;\n\n\t\tif (is_initialized == 0) {\n\t\t\t \n\t\t\tnum_cache_leaves = find_num_cache_leaves(c);\n\t\t\tis_initialized++;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < num_cache_leaves; i++) {\n\t\t\tstruct _cpuid4_info_regs this_leaf = {};\n\t\t\tint retval;\n\n\t\t\tretval = cpuid4_cache_lookup_regs(i, &this_leaf);\n\t\t\tif (retval < 0)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (this_leaf.eax.split.level) {\n\t\t\tcase 1:\n\t\t\t\tif (this_leaf.eax.split.type == CTYPE_DATA)\n\t\t\t\t\tnew_l1d = this_leaf.size/1024;\n\t\t\t\telse if (this_leaf.eax.split.type == CTYPE_INST)\n\t\t\t\t\tnew_l1i = this_leaf.size/1024;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnew_l2 = this_leaf.size/1024;\n\t\t\t\tnum_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;\n\t\t\t\tindex_msb = get_count_order(num_threads_sharing);\n\t\t\t\tl2_id = c->apicid & ~((1 << index_msb) - 1);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnew_l3 = this_leaf.size/1024;\n\t\t\t\tnum_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;\n\t\t\t\tindex_msb = get_count_order(num_threads_sharing);\n\t\t\t\tl3_id = c->apicid & ~((1 << index_msb) - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif ((num_cache_leaves == 0 || c->x86 == 15) && c->cpuid_level > 1) {\n\t\t \n\t\tint j, n;\n\t\tunsigned int regs[4];\n\t\tunsigned char *dp = (unsigned char *)regs;\n\t\tint only_trace = 0;\n\n\t\tif (num_cache_leaves != 0 && c->x86 == 15)\n\t\t\tonly_trace = 1;\n\n\t\t \n\t\tn = cpuid_eax(2) & 0xFF;\n\n\t\tfor (i = 0 ; i < n ; i++) {\n\t\t\tcpuid(2, &regs[0], &regs[1], &regs[2], &regs[3]);\n\n\t\t\t \n\t\t\tfor (j = 0 ; j < 3 ; j++)\n\t\t\t\tif (regs[j] & (1 << 31))\n\t\t\t\t\tregs[j] = 0;\n\n\t\t\t \n\t\t\tfor (j = 1 ; j < 16 ; j++) {\n\t\t\t\tunsigned char des = dp[j];\n\t\t\t\tunsigned char k = 0;\n\n\t\t\t\t \n\t\t\t\twhile (cache_table[k].descriptor != 0) {\n\t\t\t\t\tif (cache_table[k].descriptor == des) {\n\t\t\t\t\t\tif (only_trace && cache_table[k].cache_type != LVL_TRACE)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tswitch (cache_table[k].cache_type) {\n\t\t\t\t\t\tcase LVL_1_INST:\n\t\t\t\t\t\t\tl1i += cache_table[k].size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LVL_1_DATA:\n\t\t\t\t\t\t\tl1d += cache_table[k].size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LVL_2:\n\t\t\t\t\t\t\tl2 += cache_table[k].size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LVL_3:\n\t\t\t\t\t\t\tl3 += cache_table[k].size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (new_l1d)\n\t\tl1d = new_l1d;\n\n\tif (new_l1i)\n\t\tl1i = new_l1i;\n\n\tif (new_l2) {\n\t\tl2 = new_l2;\n#ifdef CONFIG_SMP\n\t\tper_cpu(cpu_llc_id, cpu) = l2_id;\n\t\tper_cpu(cpu_l2c_id, cpu) = l2_id;\n#endif\n\t}\n\n\tif (new_l3) {\n\t\tl3 = new_l3;\n#ifdef CONFIG_SMP\n\t\tper_cpu(cpu_llc_id, cpu) = l3_id;\n#endif\n\t}\n\n#ifdef CONFIG_SMP\n\t \n\tif (per_cpu(cpu_llc_id, cpu) == BAD_APICID)\n\t\tper_cpu(cpu_llc_id, cpu) = c->phys_proc_id;\n#endif\n\n\tc->x86_cache_size = l3 ? l3 : (l2 ? l2 : (l1i+l1d));\n\n\tif (!l2)\n\t\tcpu_detect_cache_sizes(c);\n}\n\nstatic int __cache_amd_cpumap_setup(unsigned int cpu, int index,\n\t\t\t\t    struct _cpuid4_info_regs *base)\n{\n\tstruct cpu_cacheinfo *this_cpu_ci;\n\tstruct cacheinfo *this_leaf;\n\tint i, sibling;\n\n\t \n\tif (index == 3) {\n\t\tfor_each_cpu(i, cpu_llc_shared_mask(cpu)) {\n\t\t\tthis_cpu_ci = get_cpu_cacheinfo(i);\n\t\t\tif (!this_cpu_ci->info_list)\n\t\t\t\tcontinue;\n\t\t\tthis_leaf = this_cpu_ci->info_list + index;\n\t\t\tfor_each_cpu(sibling, cpu_llc_shared_mask(cpu)) {\n\t\t\t\tif (!cpu_online(sibling))\n\t\t\t\t\tcontinue;\n\t\t\t\tcpumask_set_cpu(sibling,\n\t\t\t\t\t\t&this_leaf->shared_cpu_map);\n\t\t\t}\n\t\t}\n\t} else if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {\n\t\tunsigned int apicid, nshared, first, last;\n\n\t\tnshared = base->eax.split.num_threads_sharing + 1;\n\t\tapicid = cpu_data(cpu).apicid;\n\t\tfirst = apicid - (apicid % nshared);\n\t\tlast = first + nshared - 1;\n\n\t\tfor_each_online_cpu(i) {\n\t\t\tthis_cpu_ci = get_cpu_cacheinfo(i);\n\t\t\tif (!this_cpu_ci->info_list)\n\t\t\t\tcontinue;\n\n\t\t\tapicid = cpu_data(i).apicid;\n\t\t\tif ((apicid < first) || (apicid > last))\n\t\t\t\tcontinue;\n\n\t\t\tthis_leaf = this_cpu_ci->info_list + index;\n\n\t\t\tfor_each_online_cpu(sibling) {\n\t\t\t\tapicid = cpu_data(sibling).apicid;\n\t\t\t\tif ((apicid < first) || (apicid > last))\n\t\t\t\t\tcontinue;\n\t\t\t\tcpumask_set_cpu(sibling,\n\t\t\t\t\t\t&this_leaf->shared_cpu_map);\n\t\t\t}\n\t\t}\n\t} else\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void __cache_cpumap_setup(unsigned int cpu, int index,\n\t\t\t\t struct _cpuid4_info_regs *base)\n{\n\tstruct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);\n\tstruct cacheinfo *this_leaf, *sibling_leaf;\n\tunsigned long num_threads_sharing;\n\tint index_msb, i;\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\tif (c->x86_vendor == X86_VENDOR_AMD ||\n\t    c->x86_vendor == X86_VENDOR_HYGON) {\n\t\tif (__cache_amd_cpumap_setup(cpu, index, base))\n\t\t\treturn;\n\t}\n\n\tthis_leaf = this_cpu_ci->info_list + index;\n\tnum_threads_sharing = 1 + base->eax.split.num_threads_sharing;\n\n\tcpumask_set_cpu(cpu, &this_leaf->shared_cpu_map);\n\tif (num_threads_sharing == 1)\n\t\treturn;\n\n\tindex_msb = get_count_order(num_threads_sharing);\n\n\tfor_each_online_cpu(i)\n\t\tif (cpu_data(i).apicid >> index_msb == c->apicid >> index_msb) {\n\t\t\tstruct cpu_cacheinfo *sib_cpu_ci = get_cpu_cacheinfo(i);\n\n\t\t\tif (i == cpu || !sib_cpu_ci->info_list)\n\t\t\t\tcontinue; \n\t\t\tsibling_leaf = sib_cpu_ci->info_list + index;\n\t\t\tcpumask_set_cpu(i, &this_leaf->shared_cpu_map);\n\t\t\tcpumask_set_cpu(cpu, &sibling_leaf->shared_cpu_map);\n\t\t}\n}\n\nstatic void ci_leaf_init(struct cacheinfo *this_leaf,\n\t\t\t struct _cpuid4_info_regs *base)\n{\n\tthis_leaf->id = base->id;\n\tthis_leaf->attributes = CACHE_ID;\n\tthis_leaf->level = base->eax.split.level;\n\tthis_leaf->type = cache_type_map[base->eax.split.type];\n\tthis_leaf->coherency_line_size =\n\t\t\t\tbase->ebx.split.coherency_line_size + 1;\n\tthis_leaf->ways_of_associativity =\n\t\t\t\tbase->ebx.split.ways_of_associativity + 1;\n\tthis_leaf->size = base->size;\n\tthis_leaf->number_of_sets = base->ecx.split.number_of_sets + 1;\n\tthis_leaf->physical_line_partition =\n\t\t\t\tbase->ebx.split.physical_line_partition + 1;\n\tthis_leaf->priv = base->nb;\n}\n\nint init_cache_level(unsigned int cpu)\n{\n\tstruct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);\n\n\tif (!num_cache_leaves)\n\t\treturn -ENOENT;\n\tif (!this_cpu_ci)\n\t\treturn -EINVAL;\n\tthis_cpu_ci->num_levels = 3;\n\tthis_cpu_ci->num_leaves = num_cache_leaves;\n\treturn 0;\n}\n\n \nstatic void get_cache_id(int cpu, struct _cpuid4_info_regs *id4_regs)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tunsigned long num_threads_sharing;\n\tint index_msb;\n\n\tnum_threads_sharing = 1 + id4_regs->eax.split.num_threads_sharing;\n\tindex_msb = get_count_order(num_threads_sharing);\n\tid4_regs->id = c->apicid >> index_msb;\n}\n\nint populate_cache_leaves(unsigned int cpu)\n{\n\tunsigned int idx, ret;\n\tstruct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);\n\tstruct cacheinfo *this_leaf = this_cpu_ci->info_list;\n\tstruct _cpuid4_info_regs id4_regs = {};\n\n\tfor (idx = 0; idx < this_cpu_ci->num_leaves; idx++) {\n\t\tret = cpuid4_cache_lookup_regs(idx, &id4_regs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tget_cache_id(cpu, &id4_regs);\n\t\tci_leaf_init(this_leaf++, &id4_regs);\n\t\t__cache_cpumap_setup(cpu, idx, &id4_regs);\n\t}\n\tthis_cpu_ci->cpu_map_populated = true;\n\n\treturn 0;\n}\n\n \nstatic unsigned long saved_cr4;\nstatic DEFINE_RAW_SPINLOCK(cache_disable_lock);\n\nvoid cache_disable(void) __acquires(cache_disable_lock)\n{\n\tunsigned long cr0;\n\n\t \n\n\traw_spin_lock(&cache_disable_lock);\n\n\t \n\tcr0 = read_cr0() | X86_CR0_CD;\n\twrite_cr0(cr0);\n\n\t \n\tif (!static_cpu_has(X86_FEATURE_SELFSNOOP))\n\t\twbinvd();\n\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_PGE)) {\n\t\tsaved_cr4 = __read_cr4();\n\t\t__write_cr4(saved_cr4 & ~X86_CR4_PGE);\n\t}\n\n\t \n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tflush_tlb_local();\n\n\tif (cpu_feature_enabled(X86_FEATURE_MTRR))\n\t\tmtrr_disable();\n\n\t \n\tif (!static_cpu_has(X86_FEATURE_SELFSNOOP))\n\t\twbinvd();\n}\n\nvoid cache_enable(void) __releases(cache_disable_lock)\n{\n\t \n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tflush_tlb_local();\n\n\tif (cpu_feature_enabled(X86_FEATURE_MTRR))\n\t\tmtrr_enable();\n\n\t \n\twrite_cr0(read_cr0() & ~X86_CR0_CD);\n\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_PGE))\n\t\t__write_cr4(saved_cr4);\n\n\traw_spin_unlock(&cache_disable_lock);\n}\n\nstatic void cache_cpu_init(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcache_disable();\n\n\tif (memory_caching_control & CACHE_MTRR)\n\t\tmtrr_generic_set_state();\n\n\tif (memory_caching_control & CACHE_PAT)\n\t\tpat_cpu_init();\n\n\tcache_enable();\n\tlocal_irq_restore(flags);\n}\n\nstatic bool cache_aps_delayed_init = true;\n\nvoid set_cache_aps_delayed_init(bool val)\n{\n\tcache_aps_delayed_init = val;\n}\n\nbool get_cache_aps_delayed_init(void)\n{\n\treturn cache_aps_delayed_init;\n}\n\nstatic int cache_rendezvous_handler(void *unused)\n{\n\tif (get_cache_aps_delayed_init() || !cpu_online(smp_processor_id()))\n\t\tcache_cpu_init();\n\n\treturn 0;\n}\n\nvoid __init cache_bp_init(void)\n{\n\tmtrr_bp_init();\n\tpat_bp_init();\n\n\tif (memory_caching_control)\n\t\tcache_cpu_init();\n}\n\nvoid cache_bp_restore(void)\n{\n\tif (memory_caching_control)\n\t\tcache_cpu_init();\n}\n\nstatic int cache_ap_online(unsigned int cpu)\n{\n\tcpumask_set_cpu(cpu, cpu_cacheinfo_mask);\n\n\tif (!memory_caching_control || get_cache_aps_delayed_init())\n\t\treturn 0;\n\n\t \n\tstop_machine_from_inactive_cpu(cache_rendezvous_handler, NULL,\n\t\t\t\t       cpu_cacheinfo_mask);\n\n\treturn 0;\n}\n\nstatic int cache_ap_offline(unsigned int cpu)\n{\n\tcpumask_clear_cpu(cpu, cpu_cacheinfo_mask);\n\treturn 0;\n}\n\n \nvoid cache_aps_init(void)\n{\n\tif (!memory_caching_control || !get_cache_aps_delayed_init())\n\t\treturn;\n\n\tstop_machine(cache_rendezvous_handler, NULL, cpu_online_mask);\n\tset_cache_aps_delayed_init(false);\n}\n\nstatic int __init cache_ap_register(void)\n{\n\tzalloc_cpumask_var(&cpu_cacheinfo_mask, GFP_KERNEL);\n\tcpumask_set_cpu(smp_processor_id(), cpu_cacheinfo_mask);\n\n\tcpuhp_setup_state_nocalls(CPUHP_AP_CACHECTRL_STARTING,\n\t\t\t\t  \"x86/cachectrl:starting\",\n\t\t\t\t  cache_ap_online, cache_ap_offline);\n\treturn 0;\n}\nearly_initcall(cache_ap_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}