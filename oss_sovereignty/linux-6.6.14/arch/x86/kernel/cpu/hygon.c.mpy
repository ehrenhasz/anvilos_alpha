{
  "module_name": "hygon.c",
  "hash_id": "fcc39cebcb90f6d1bddc1dbfbea6a50aa720f3290b2cc29e2770046a9bf33041",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/hygon.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n\n#include <asm/apic.h>\n#include <asm/cpu.h>\n#include <asm/smp.h>\n#include <asm/numa.h>\n#include <asm/cacheinfo.h>\n#include <asm/spec-ctrl.h>\n#include <asm/delay.h>\n\n#include \"cpu.h\"\n\n#define APICID_SOCKET_ID_BIT 6\n\n \nstatic u32 nodes_per_socket = 1;\n\n#ifdef CONFIG_NUMA\n \nstatic int nearby_node(int apicid)\n{\n\tint i, node;\n\n\tfor (i = apicid - 1; i >= 0; i--) {\n\t\tnode = __apicid_to_node[i];\n\t\tif (node != NUMA_NO_NODE && node_online(node))\n\t\t\treturn node;\n\t}\n\tfor (i = apicid + 1; i < MAX_LOCAL_APIC; i++) {\n\t\tnode = __apicid_to_node[i];\n\t\tif (node != NUMA_NO_NODE && node_online(node))\n\t\t\treturn node;\n\t}\n\treturn first_node(node_online_map);  \n}\n#endif\n\nstatic void hygon_get_topology_early(struct cpuinfo_x86 *c)\n{\n\tif (cpu_has(c, X86_FEATURE_TOPOEXT))\n\t\tsmp_num_siblings = ((cpuid_ebx(0x8000001e) >> 8) & 0xff) + 1;\n}\n\n \nstatic void hygon_get_topology(struct cpuinfo_x86 *c)\n{\n\tint cpu = smp_processor_id();\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_TOPOEXT)) {\n\t\tint err;\n\t\tu32 eax, ebx, ecx, edx;\n\n\t\tcpuid(0x8000001e, &eax, &ebx, &ecx, &edx);\n\n\t\tc->cpu_die_id  = ecx & 0xff;\n\n\t\tc->cpu_core_id = ebx & 0xff;\n\n\t\tif (smp_num_siblings > 1)\n\t\t\tc->x86_max_cores /= smp_num_siblings;\n\n\t\t \n\t\terr = detect_extended_topology(c);\n\t\tif (!err)\n\t\t\tc->x86_coreid_bits = get_count_order(c->x86_max_cores);\n\n\t\t \n\t\tif (!boot_cpu_has(X86_FEATURE_HYPERVISOR) && c->x86_model <= 0x3)\n\t\t\tc->phys_proc_id = c->apicid >> APICID_SOCKET_ID_BIT;\n\n\t\tcacheinfo_hygon_init_llc_id(c, cpu);\n\t} else if (cpu_has(c, X86_FEATURE_NODEID_MSR)) {\n\t\tu64 value;\n\n\t\trdmsrl(MSR_FAM10H_NODE_ID, value);\n\t\tc->cpu_die_id = value & 7;\n\n\t\tper_cpu(cpu_llc_id, cpu) = c->cpu_die_id;\n\t} else\n\t\treturn;\n\n\tif (nodes_per_socket > 1)\n\t\tset_cpu_cap(c, X86_FEATURE_AMD_DCM);\n}\n\n \nstatic void hygon_detect_cmp(struct cpuinfo_x86 *c)\n{\n\tunsigned int bits;\n\tint cpu = smp_processor_id();\n\n\tbits = c->x86_coreid_bits;\n\t \n\tc->cpu_core_id = c->initial_apicid & ((1 << bits)-1);\n\t \n\tc->phys_proc_id = c->initial_apicid >> bits;\n\t \n\tper_cpu(cpu_llc_id, cpu) = c->cpu_die_id = c->phys_proc_id;\n}\n\nstatic void srat_detect_node(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_NUMA\n\tint cpu = smp_processor_id();\n\tint node;\n\tunsigned int apicid = c->apicid;\n\n\tnode = numa_cpu_node(cpu);\n\tif (node == NUMA_NO_NODE)\n\t\tnode = per_cpu(cpu_llc_id, cpu);\n\n\t \n\tif (x86_cpuinit.fixup_cpu_id)\n\t\tx86_cpuinit.fixup_cpu_id(c, node);\n\n\tif (!node_online(node)) {\n\t\t \n\t\tint ht_nodeid = c->initial_apicid;\n\n\t\tif (__apicid_to_node[ht_nodeid] != NUMA_NO_NODE)\n\t\t\tnode = __apicid_to_node[ht_nodeid];\n\t\t \n\t\tif (!node_online(node))\n\t\t\tnode = nearby_node(apicid);\n\t}\n\tnuma_set_node(cpu, node);\n#endif\n}\n\nstatic void early_init_hygon_mc(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_SMP\n\tunsigned int bits, ecx;\n\n\t \n\tif (c->extended_cpuid_level < 0x80000008)\n\t\treturn;\n\n\tecx = cpuid_ecx(0x80000008);\n\n\tc->x86_max_cores = (ecx & 0xff) + 1;\n\n\t \n\tbits = (ecx >> 12) & 0xF;\n\n\t \n\tif (bits == 0) {\n\t\twhile ((1 << bits) < c->x86_max_cores)\n\t\t\tbits++;\n\t}\n\n\tc->x86_coreid_bits = bits;\n#endif\n}\n\nstatic void bsp_init_hygon(struct cpuinfo_x86 *c)\n{\n\tif (cpu_has(c, X86_FEATURE_CONSTANT_TSC)) {\n\t\tu64 val;\n\n\t\trdmsrl(MSR_K7_HWCR, val);\n\t\tif (!(val & BIT(24)))\n\t\t\tpr_warn(FW_BUG \"TSC doesn't count with P0 frequency!\\n\");\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_MWAITX))\n\t\tuse_mwaitx_delay();\n\n\tif (boot_cpu_has(X86_FEATURE_TOPOEXT)) {\n\t\tu32 ecx;\n\n\t\tecx = cpuid_ecx(0x8000001e);\n\t\t__max_die_per_package = nodes_per_socket = ((ecx >> 8) & 7) + 1;\n\t} else if (boot_cpu_has(X86_FEATURE_NODEID_MSR)) {\n\t\tu64 value;\n\n\t\trdmsrl(MSR_FAM10H_NODE_ID, value);\n\t\t__max_die_per_package = nodes_per_socket = ((value >> 3) & 7) + 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_AMD_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n\t\t \n\t\tif (!rdmsrl_safe(MSR_AMD64_LS_CFG, &x86_amd_ls_cfg_base)) {\n\t\t\tsetup_force_cpu_cap(X86_FEATURE_LS_CFG_SSBD);\n\t\t\tsetup_force_cpu_cap(X86_FEATURE_SSBD);\n\t\t\tx86_amd_ls_cfg_ssbd_mask = 1ULL << 10;\n\t\t}\n\t}\n}\n\nstatic void early_init_hygon(struct cpuinfo_x86 *c)\n{\n\tu32 dummy;\n\n\tearly_init_hygon_mc(c);\n\n\tset_cpu_cap(c, X86_FEATURE_K8);\n\n\trdmsr_safe(MSR_AMD64_PATCH_LEVEL, &c->microcode, &dummy);\n\n\t \n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t}\n\n\t \n\tif (c->x86_power & BIT(12))\n\t\tset_cpu_cap(c, X86_FEATURE_ACC_POWER);\n\n\t \n\tif (c->x86_power & BIT(14))\n\t\tset_cpu_cap(c, X86_FEATURE_RAPL);\n\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#endif\n\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\t \n\tif (boot_cpu_has(X86_FEATURE_APIC))\n\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n#endif\n\n\t \n\tset_cpu_cap(c, X86_FEATURE_VMMCALL);\n\n\thygon_get_topology_early(c);\n}\n\nstatic void init_hygon(struct cpuinfo_x86 *c)\n{\n\tearly_init_hygon(c);\n\n\t \n\tclear_cpu_cap(c, 0*32+31);\n\n\tset_cpu_cap(c, X86_FEATURE_REP_GOOD);\n\n\t \n\tc->apicid = read_apic_id();\n\n\t \n\n\tset_cpu_cap(c, X86_FEATURE_ZEN);\n\tset_cpu_cap(c, X86_FEATURE_CPB);\n\n\tcpu_detect_cache_sizes(c);\n\n\thygon_detect_cmp(c);\n\thygon_get_topology(c);\n\tsrat_detect_node(c);\n\n\tinit_hygon_cacheinfo(c);\n\n\tif (cpu_has(c, X86_FEATURE_XMM2)) {\n\t\t \n\t\tmsr_set_bit(MSR_AMD64_DE_CFG,\n\t\t\t    MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT);\n\n\t\t \n\t\tset_cpu_cap(c, X86_FEATURE_LFENCE_RDTSC);\n\t}\n\n\t \n\tset_cpu_cap(c, X86_FEATURE_ARAT);\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_XENPV))\n\t\tset_cpu_bug(c, X86_BUG_SYSRET_SS_ATTRS);\n\n\tcheck_null_seg_clears_base(c);\n}\n\nstatic void cpu_detect_tlb_hygon(struct cpuinfo_x86 *c)\n{\n\tu32 ebx, eax, ecx, edx;\n\tu16 mask = 0xfff;\n\n\tif (c->extended_cpuid_level < 0x80000006)\n\t\treturn;\n\n\tcpuid(0x80000006, &eax, &ebx, &ecx, &edx);\n\n\ttlb_lld_4k[ENTRIES] = (ebx >> 16) & mask;\n\ttlb_lli_4k[ENTRIES] = ebx & mask;\n\n\t \n\tif (!((eax >> 16) & mask))\n\t\ttlb_lld_2m[ENTRIES] = (cpuid_eax(0x80000005) >> 16) & 0xff;\n\telse\n\t\ttlb_lld_2m[ENTRIES] = (eax >> 16) & mask;\n\n\t \n\ttlb_lld_4m[ENTRIES] = tlb_lld_2m[ENTRIES] >> 1;\n\n\t \n\tif (!(eax & mask)) {\n\t\tcpuid(0x80000005, &eax, &ebx, &ecx, &edx);\n\t\ttlb_lli_2m[ENTRIES] = eax & 0xff;\n\t} else\n\t\ttlb_lli_2m[ENTRIES] = eax & mask;\n\n\ttlb_lli_4m[ENTRIES] = tlb_lli_2m[ENTRIES] >> 1;\n}\n\nstatic const struct cpu_dev hygon_cpu_dev = {\n\t.c_vendor\t= \"Hygon\",\n\t.c_ident\t= { \"HygonGenuine\" },\n\t.c_early_init   = early_init_hygon,\n\t.c_detect_tlb\t= cpu_detect_tlb_hygon,\n\t.c_bsp_init\t= bsp_init_hygon,\n\t.c_init\t\t= init_hygon,\n\t.c_x86_vendor\t= X86_VENDOR_HYGON,\n};\n\ncpu_dev_register(hygon_cpu_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}