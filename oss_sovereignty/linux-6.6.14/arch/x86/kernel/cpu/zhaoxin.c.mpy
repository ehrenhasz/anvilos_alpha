{
  "module_name": "zhaoxin.c",
  "hash_id": "e7d75a9eca8cd116c3d1450ee3f1e150e4fbfcb87ad62baf2414a8ab757dc10b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/zhaoxin.c",
  "human_readable_source": "\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n\n#include <asm/cpu.h>\n#include <asm/cpufeature.h>\n\n#include \"cpu.h\"\n\n#define MSR_ZHAOXIN_FCR57 0x00001257\n\n#define ACE_PRESENT\t(1 << 6)\n#define ACE_ENABLED\t(1 << 7)\n#define ACE_FCR\t\t(1 << 7)\t \n\n#define RNG_PRESENT\t(1 << 2)\n#define RNG_ENABLED\t(1 << 3)\n#define RNG_ENABLE\t(1 << 8)\t \n\nstatic void init_zhaoxin_cap(struct cpuinfo_x86 *c)\n{\n\tu32  lo, hi;\n\n\t \n\tif (cpuid_eax(0xC0000000) >= 0xC0000001) {\n\t\tu32 tmp = cpuid_edx(0xC0000001);\n\n\t\t \n\t\tif ((tmp & (ACE_PRESENT | ACE_ENABLED)) == ACE_PRESENT) {\n\t\t\trdmsr(MSR_ZHAOXIN_FCR57, lo, hi);\n\t\t\t \n\t\t\tlo |= ACE_FCR;\n\t\t\twrmsr(MSR_ZHAOXIN_FCR57, lo, hi);\n\t\t\tpr_info(\"CPU: Enabled ACE h/w crypto\\n\");\n\t\t}\n\n\t\t \n\t\tif ((tmp & (RNG_PRESENT | RNG_ENABLED)) == RNG_PRESENT) {\n\t\t\trdmsr(MSR_ZHAOXIN_FCR57, lo, hi);\n\t\t\t \n\t\t\tlo |= RNG_ENABLE;\n\t\t\twrmsr(MSR_ZHAOXIN_FCR57, lo, hi);\n\t\t\tpr_info(\"CPU: Enabled h/w RNG\\n\");\n\t\t}\n\n\t\t \n\t\tc->x86_capability[CPUID_C000_0001_EDX] = cpuid_edx(0xC0000001);\n\t}\n\n\tif (c->x86 >= 0x6)\n\t\tset_cpu_cap(c, X86_FEATURE_REP_GOOD);\n}\n\nstatic void early_init_zhaoxin(struct cpuinfo_x86 *c)\n{\n\tif (c->x86 >= 0x6)\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSENTER32);\n#endif\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t}\n\n\tif (c->cpuid_level >= 0x00000001) {\n\t\tu32 eax, ebx, ecx, edx;\n\n\t\tcpuid(0x00000001, &eax, &ebx, &ecx, &edx);\n\t\t \n\t\tif (edx & (1U << 28))\n\t\t\tc->x86_coreid_bits = get_count_order((ebx >> 16) & 0xff);\n\t}\n\n}\n\nstatic void init_zhaoxin(struct cpuinfo_x86 *c)\n{\n\tearly_init_zhaoxin(c);\n\tinit_intel_cacheinfo(c);\n\tdetect_num_cpu_cores(c);\n#ifdef CONFIG_X86_32\n\tdetect_ht(c);\n#endif\n\n\tif (c->cpuid_level > 9) {\n\t\tunsigned int eax = cpuid_eax(10);\n\n\t\t \n\t\tif ((eax & 0xff) && (((eax >> 8) & 0xff) > 1))\n\t\t\tset_cpu_cap(c, X86_FEATURE_ARCH_PERFMON);\n\t}\n\n\tif (c->x86 >= 0x6)\n\t\tinit_zhaoxin_cap(c);\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_LFENCE_RDTSC);\n#endif\n\n\tinit_ia32_feat_ctl(c);\n}\n\n#ifdef CONFIG_X86_32\nstatic unsigned int\nzhaoxin_size_cache(struct cpuinfo_x86 *c, unsigned int size)\n{\n\treturn size;\n}\n#endif\n\nstatic const struct cpu_dev zhaoxin_cpu_dev = {\n\t.c_vendor\t= \"zhaoxin\",\n\t.c_ident\t= { \"  Shanghai  \" },\n\t.c_early_init\t= early_init_zhaoxin,\n\t.c_init\t\t= init_zhaoxin,\n#ifdef CONFIG_X86_32\n\t.legacy_cache_size = zhaoxin_size_cache,\n#endif\n\t.c_x86_vendor\t= X86_VENDOR_ZHAOXIN,\n};\n\ncpu_dev_register(zhaoxin_cpu_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}