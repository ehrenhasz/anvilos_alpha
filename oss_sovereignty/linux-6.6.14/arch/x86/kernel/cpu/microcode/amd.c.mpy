{
  "module_name": "amd.c",
  "hash_id": "6baddd24f498a0f71188c92e76515b8c71a9e3423f20a8a4c72fc6b9ca4ca16d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/microcode/amd.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"microcode: \" fmt\n\n#include <linux/earlycpio.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/initrd.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n\n#include <asm/microcode.h>\n#include <asm/processor.h>\n#include <asm/setup.h>\n#include <asm/cpu.h>\n#include <asm/msr.h>\n\n#include \"internal.h\"\n\n#define UCODE_MAGIC\t\t\t0x00414d44\n#define UCODE_EQUIV_CPU_TABLE_TYPE\t0x00000000\n#define UCODE_UCODE_TYPE\t\t0x00000001\n\n#define SECTION_HDR_SIZE\t\t8\n#define CONTAINER_HDR_SZ\t\t12\n\nstruct equiv_cpu_entry {\n\tu32\tinstalled_cpu;\n\tu32\tfixed_errata_mask;\n\tu32\tfixed_errata_compare;\n\tu16\tequiv_cpu;\n\tu16\tres;\n} __packed;\n\nstruct microcode_header_amd {\n\tu32\tdata_code;\n\tu32\tpatch_id;\n\tu16\tmc_patch_data_id;\n\tu8\tmc_patch_data_len;\n\tu8\tinit_flag;\n\tu32\tmc_patch_data_checksum;\n\tu32\tnb_dev_id;\n\tu32\tsb_dev_id;\n\tu16\tprocessor_rev_id;\n\tu8\tnb_rev_id;\n\tu8\tsb_rev_id;\n\tu8\tbios_api_rev;\n\tu8\treserved1[3];\n\tu32\tmatch_reg[8];\n} __packed;\n\nstruct microcode_amd {\n\tstruct microcode_header_amd\thdr;\n\tunsigned int\t\t\tmpb[];\n};\n\n#define PATCH_MAX_SIZE (3 * PAGE_SIZE)\n\nstatic struct equiv_cpu_table {\n\tunsigned int num_entries;\n\tstruct equiv_cpu_entry *entry;\n} equiv_table;\n\n \nstruct cont_desc {\n\tstruct microcode_amd *mc;\n\tu32\t\t     cpuid_1_eax;\n\tu32\t\t     psize;\n\tu8\t\t     *data;\n\tsize_t\t\t     size;\n};\n\nstatic u32 ucode_new_rev;\n\n \nstatic const char\nucode_path[] __maybe_unused = \"kernel/x86/microcode/AuthenticAMD.bin\";\n\nstatic u16 find_equiv_id(struct equiv_cpu_table *et, u32 sig)\n{\n\tunsigned int i;\n\n\tif (!et || !et->num_entries)\n\t\treturn 0;\n\n\tfor (i = 0; i < et->num_entries; i++) {\n\t\tstruct equiv_cpu_entry *e = &et->entry[i];\n\n\t\tif (sig == e->installed_cpu)\n\t\t\treturn e->equiv_cpu;\n\t}\n\treturn 0;\n}\n\n \nstatic bool verify_container(const u8 *buf, size_t buf_size, bool early)\n{\n\tu32 cont_magic;\n\n\tif (buf_size <= CONTAINER_HDR_SZ) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Truncated microcode container header.\\n\");\n\n\t\treturn false;\n\t}\n\n\tcont_magic = *(const u32 *)buf;\n\tif (cont_magic != UCODE_MAGIC) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Invalid magic value (0x%08x).\\n\", cont_magic);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool verify_equivalence_table(const u8 *buf, size_t buf_size, bool early)\n{\n\tconst u32 *hdr = (const u32 *)buf;\n\tu32 cont_type, equiv_tbl_len;\n\n\tif (!verify_container(buf, buf_size, early))\n\t\treturn false;\n\n\tcont_type = hdr[1];\n\tif (cont_type != UCODE_EQUIV_CPU_TABLE_TYPE) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Wrong microcode container equivalence table type: %u.\\n\",\n\t\t\t       cont_type);\n\n\t\treturn false;\n\t}\n\n\tbuf_size -= CONTAINER_HDR_SZ;\n\n\tequiv_tbl_len = hdr[2];\n\tif (equiv_tbl_len < sizeof(struct equiv_cpu_entry) ||\n\t    buf_size < equiv_tbl_len) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Truncated equivalence table.\\n\");\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool\n__verify_patch_section(const u8 *buf, size_t buf_size, u32 *sh_psize, bool early)\n{\n\tu32 p_type, p_size;\n\tconst u32 *hdr;\n\n\tif (buf_size < SECTION_HDR_SIZE) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Truncated patch section.\\n\");\n\n\t\treturn false;\n\t}\n\n\thdr = (const u32 *)buf;\n\tp_type = hdr[0];\n\tp_size = hdr[1];\n\n\tif (p_type != UCODE_UCODE_TYPE) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Invalid type field (0x%x) in container file section header.\\n\",\n\t\t\t\tp_type);\n\n\t\treturn false;\n\t}\n\n\tif (p_size < sizeof(struct microcode_header_amd)) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Patch of size %u too short.\\n\", p_size);\n\n\t\treturn false;\n\t}\n\n\t*sh_psize = p_size;\n\n\treturn true;\n}\n\n \nstatic unsigned int __verify_patch_size(u8 family, u32 sh_psize, size_t buf_size)\n{\n\tu32 max_size;\n\n\tif (family >= 0x15)\n\t\treturn min_t(u32, sh_psize, buf_size);\n\n#define F1XH_MPB_MAX_SIZE 2048\n#define F14H_MPB_MAX_SIZE 1824\n\n\tswitch (family) {\n\tcase 0x10 ... 0x12:\n\t\tmax_size = F1XH_MPB_MAX_SIZE;\n\t\tbreak;\n\tcase 0x14:\n\t\tmax_size = F14H_MPB_MAX_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"%s: WTF family: 0x%x\\n\", __func__, family);\n\t\treturn 0;\n\t}\n\n\tif (sh_psize > min_t(u32, buf_size, max_size))\n\t\treturn 0;\n\n\treturn sh_psize;\n}\n\n \nstatic int\nverify_patch(u8 family, const u8 *buf, size_t buf_size, u32 *patch_size, bool early)\n{\n\tstruct microcode_header_amd *mc_hdr;\n\tunsigned int ret;\n\tu32 sh_psize;\n\tu16 proc_id;\n\tu8 patch_fam;\n\n\tif (!__verify_patch_section(buf, buf_size, &sh_psize, early))\n\t\treturn -1;\n\n\t \n\tbuf_size -= SECTION_HDR_SIZE;\n\n\t \n\tif (buf_size < sh_psize) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Patch of size %u truncated.\\n\", sh_psize);\n\n\t\treturn -1;\n\t}\n\n\tret = __verify_patch_size(family, sh_psize, buf_size);\n\tif (!ret) {\n\t\tif (!early)\n\t\t\tpr_debug(\"Per-family patch size mismatch.\\n\");\n\t\treturn -1;\n\t}\n\n\t*patch_size = sh_psize;\n\n\tmc_hdr\t= (struct microcode_header_amd *)(buf + SECTION_HDR_SIZE);\n\tif (mc_hdr->nb_dev_id || mc_hdr->sb_dev_id) {\n\t\tif (!early)\n\t\t\tpr_err(\"Patch-ID 0x%08x: chipset-specific code unsupported.\\n\", mc_hdr->patch_id);\n\t\treturn -1;\n\t}\n\n\tproc_id\t= mc_hdr->processor_rev_id;\n\tpatch_fam = 0xf + (proc_id >> 12);\n\tif (patch_fam != family)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic size_t parse_container(u8 *ucode, size_t size, struct cont_desc *desc)\n{\n\tstruct equiv_cpu_table table;\n\tsize_t orig_size = size;\n\tu32 *hdr = (u32 *)ucode;\n\tu16 eq_id;\n\tu8 *buf;\n\n\tif (!verify_equivalence_table(ucode, size, true))\n\t\treturn 0;\n\n\tbuf = ucode;\n\n\ttable.entry = (struct equiv_cpu_entry *)(buf + CONTAINER_HDR_SZ);\n\ttable.num_entries = hdr[2] / sizeof(struct equiv_cpu_entry);\n\n\t \n\teq_id = find_equiv_id(&table, desc->cpuid_1_eax);\n\n\tbuf  += hdr[2] + CONTAINER_HDR_SZ;\n\tsize -= hdr[2] + CONTAINER_HDR_SZ;\n\n\t \n\twhile (size > 0) {\n\t\tstruct microcode_amd *mc;\n\t\tu32 patch_size;\n\t\tint ret;\n\n\t\tret = verify_patch(x86_family(desc->cpuid_1_eax), buf, size, &patch_size, true);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tgoto out;\n\t\t} else if (ret > 0) {\n\t\t\tgoto skip;\n\t\t}\n\n\t\tmc = (struct microcode_amd *)(buf + SECTION_HDR_SIZE);\n\t\tif (eq_id == mc->hdr.processor_rev_id) {\n\t\t\tdesc->psize = patch_size;\n\t\t\tdesc->mc = mc;\n\t\t}\n\nskip:\n\t\t \n\t\tbuf  += patch_size + SECTION_HDR_SIZE;\n\t\tsize -= patch_size + SECTION_HDR_SIZE;\n\t}\n\nout:\n\t \n\tif (desc->mc) {\n\t\tdesc->data = ucode;\n\t\tdesc->size = orig_size - size;\n\n\t\treturn 0;\n\t}\n\n\treturn orig_size - size;\n}\n\n \nstatic void scan_containers(u8 *ucode, size_t size, struct cont_desc *desc)\n{\n\twhile (size) {\n\t\tsize_t s = parse_container(ucode, size, desc);\n\t\tif (!s)\n\t\t\treturn;\n\n\t\t \n\t\tif (size >= s) {\n\t\t\tucode += s;\n\t\t\tsize  -= s;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int __apply_microcode_amd(struct microcode_amd *mc)\n{\n\tu32 rev, dummy;\n\n\tnative_wrmsrl(MSR_AMD64_PATCH_LOADER, (u64)(long)&mc->hdr.data_code);\n\n\t \n\tnative_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\n\tif (rev != mc->hdr.patch_id)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic bool early_apply_microcode(u32 cpuid_1_eax, void *ucode, size_t size)\n{\n\tstruct cont_desc desc = { 0 };\n\tstruct microcode_amd *mc;\n\tu32 rev, dummy, *new_rev;\n\tbool ret = false;\n\n#ifdef CONFIG_X86_32\n\tnew_rev = (u32 *)__pa_nodebug(&ucode_new_rev);\n#else\n\tnew_rev = &ucode_new_rev;\n#endif\n\n\tdesc.cpuid_1_eax = cpuid_1_eax;\n\n\tscan_containers(ucode, size, &desc);\n\n\tmc = desc.mc;\n\tif (!mc)\n\t\treturn ret;\n\n\tnative_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\n\n\t \n\tif (rev > mc->hdr.patch_id)\n\t\treturn ret;\n\n\tif (!__apply_microcode_amd(mc)) {\n\t\t*new_rev = mc->hdr.patch_id;\n\t\tret      = true;\n\t}\n\n\treturn ret;\n}\n\nstatic bool get_builtin_microcode(struct cpio_data *cp, unsigned int family)\n{\n\tchar fw_name[36] = \"amd-ucode/microcode_amd.bin\";\n\tstruct firmware fw;\n\n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\treturn false;\n\n\tif (family >= 0x15)\n\t\tsnprintf(fw_name, sizeof(fw_name),\n\t\t\t \"amd-ucode/microcode_amd_fam%.2xh.bin\", family);\n\n\tif (firmware_request_builtin(&fw, fw_name)) {\n\t\tcp->size = fw.size;\n\t\tcp->data = (void *)fw.data;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void find_blobs_in_containers(unsigned int cpuid_1_eax, struct cpio_data *ret)\n{\n\tstruct ucode_cpu_info *uci;\n\tstruct cpio_data cp;\n\tconst char *path;\n\tbool use_pa;\n\n\tif (IS_ENABLED(CONFIG_X86_32)) {\n\t\tuci\t= (struct ucode_cpu_info *)__pa_nodebug(ucode_cpu_info);\n\t\tpath\t= (const char *)__pa_nodebug(ucode_path);\n\t\tuse_pa\t= true;\n\t} else {\n\t\tuci     = ucode_cpu_info;\n\t\tpath\t= ucode_path;\n\t\tuse_pa\t= false;\n\t}\n\n\tif (!get_builtin_microcode(&cp, x86_family(cpuid_1_eax)))\n\t\tcp = find_microcode_in_initrd(path, use_pa);\n\n\t \n\tuci->cpu_sig.sig = cpuid_1_eax;\n\n\t*ret = cp;\n}\n\nstatic void apply_ucode_from_containers(unsigned int cpuid_1_eax)\n{\n\tstruct cpio_data cp = { };\n\n\tfind_blobs_in_containers(cpuid_1_eax, &cp);\n\tif (!(cp.data && cp.size))\n\t\treturn;\n\n\tearly_apply_microcode(cpuid_1_eax, cp.data, cp.size);\n}\n\nvoid load_ucode_amd_early(unsigned int cpuid_1_eax)\n{\n\treturn apply_ucode_from_containers(cpuid_1_eax);\n}\n\nstatic enum ucode_state load_microcode_amd(u8 family, const u8 *data, size_t size);\n\nint __init save_microcode_in_initrd_amd(unsigned int cpuid_1_eax)\n{\n\tstruct cont_desc desc = { 0 };\n\tenum ucode_state ret;\n\tstruct cpio_data cp;\n\n\tcp = find_microcode_in_initrd(ucode_path, false);\n\tif (!(cp.data && cp.size))\n\t\treturn -EINVAL;\n\n\tdesc.cpuid_1_eax = cpuid_1_eax;\n\n\tscan_containers(cp.data, cp.size, &desc);\n\tif (!desc.mc)\n\t\treturn -EINVAL;\n\n\tret = load_microcode_amd(x86_family(cpuid_1_eax), desc.data, desc.size);\n\tif (ret > UCODE_UPDATED)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic struct ucode_patch *cache_find_patch(u16 equiv_cpu)\n{\n\tstruct ucode_patch *p;\n\n\tlist_for_each_entry(p, &microcode_cache, plist)\n\t\tif (p->equiv_cpu == equiv_cpu)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstatic void update_cache(struct ucode_patch *new_patch)\n{\n\tstruct ucode_patch *p;\n\n\tlist_for_each_entry(p, &microcode_cache, plist) {\n\t\tif (p->equiv_cpu == new_patch->equiv_cpu) {\n\t\t\tif (p->patch_id >= new_patch->patch_id) {\n\t\t\t\t \n\t\t\t\tkfree(new_patch->data);\n\t\t\t\tkfree(new_patch);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlist_replace(&p->plist, &new_patch->plist);\n\t\t\tkfree(p->data);\n\t\t\tkfree(p);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tlist_add_tail(&new_patch->plist, &microcode_cache);\n}\n\nstatic void free_cache(void)\n{\n\tstruct ucode_patch *p, *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, &microcode_cache, plist) {\n\t\t__list_del(p->plist.prev, p->plist.next);\n\t\tkfree(p->data);\n\t\tkfree(p);\n\t}\n}\n\nstatic struct ucode_patch *find_patch(unsigned int cpu)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\tu16 equiv_id;\n\n\n\tequiv_id = find_equiv_id(&equiv_table, uci->cpu_sig.sig);\n\tif (!equiv_id)\n\t\treturn NULL;\n\n\treturn cache_find_patch(equiv_id);\n}\n\nvoid reload_ucode_amd(unsigned int cpu)\n{\n\tu32 rev, dummy __always_unused;\n\tstruct microcode_amd *mc;\n\tstruct ucode_patch *p;\n\n\tp = find_patch(cpu);\n\tif (!p)\n\t\treturn;\n\n\tmc = p->data;\n\n\trdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\n\n\tif (rev < mc->hdr.patch_id) {\n\t\tif (!__apply_microcode_amd(mc)) {\n\t\t\tucode_new_rev = mc->hdr.patch_id;\n\t\t\tpr_info(\"reload patch_level=0x%08x\\n\", ucode_new_rev);\n\t\t}\n\t}\n}\n\nstatic int collect_cpu_info_amd(int cpu, struct cpu_signature *csig)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\tstruct ucode_patch *p;\n\n\tcsig->sig = cpuid_eax(0x00000001);\n\tcsig->rev = c->microcode;\n\n\t \n\tp = find_patch(cpu);\n\tif (p && (p->patch_id == csig->rev))\n\t\tuci->mc = p->data;\n\n\tpr_info(\"CPU%d: patch_level=0x%08x\\n\", cpu, csig->rev);\n\n\treturn 0;\n}\n\nstatic enum ucode_state apply_microcode_amd(int cpu)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tstruct microcode_amd *mc_amd;\n\tstruct ucode_cpu_info *uci;\n\tstruct ucode_patch *p;\n\tenum ucode_state ret;\n\tu32 rev, dummy __always_unused;\n\n\tBUG_ON(raw_smp_processor_id() != cpu);\n\n\tuci = ucode_cpu_info + cpu;\n\n\tp = find_patch(cpu);\n\tif (!p)\n\t\treturn UCODE_NFOUND;\n\n\tmc_amd  = p->data;\n\tuci->mc = p->data;\n\n\trdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\n\n\t \n\tif (rev > mc_amd->hdr.patch_id) {\n\t\tret = UCODE_OK;\n\t\tgoto out;\n\t}\n\n\tif (__apply_microcode_amd(mc_amd)) {\n\t\tpr_err(\"CPU%d: update failed for patch_level=0x%08x\\n\",\n\t\t\tcpu, mc_amd->hdr.patch_id);\n\t\treturn UCODE_ERROR;\n\t}\n\n\trev = mc_amd->hdr.patch_id;\n\tret = UCODE_UPDATED;\n\n\tpr_info(\"CPU%d: new patch_level=0x%08x\\n\", cpu, rev);\n\nout:\n\tuci->cpu_sig.rev = rev;\n\tc->microcode\t = rev;\n\n\t \n\tif (c->cpu_index == boot_cpu_data.cpu_index)\n\t\tboot_cpu_data.microcode = rev;\n\n\treturn ret;\n}\n\nstatic size_t install_equiv_cpu_table(const u8 *buf, size_t buf_size)\n{\n\tu32 equiv_tbl_len;\n\tconst u32 *hdr;\n\n\tif (!verify_equivalence_table(buf, buf_size, false))\n\t\treturn 0;\n\n\thdr = (const u32 *)buf;\n\tequiv_tbl_len = hdr[2];\n\n\tequiv_table.entry = vmalloc(equiv_tbl_len);\n\tif (!equiv_table.entry) {\n\t\tpr_err(\"failed to allocate equivalent CPU table\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(equiv_table.entry, buf + CONTAINER_HDR_SZ, equiv_tbl_len);\n\tequiv_table.num_entries = equiv_tbl_len / sizeof(struct equiv_cpu_entry);\n\n\t \n\treturn equiv_tbl_len + CONTAINER_HDR_SZ;\n}\n\nstatic void free_equiv_cpu_table(void)\n{\n\tvfree(equiv_table.entry);\n\tmemset(&equiv_table, 0, sizeof(equiv_table));\n}\n\nstatic void cleanup(void)\n{\n\tfree_equiv_cpu_table();\n\tfree_cache();\n}\n\n \nstatic int verify_and_add_patch(u8 family, u8 *fw, unsigned int leftover,\n\t\t\t\tunsigned int *patch_size)\n{\n\tstruct microcode_header_amd *mc_hdr;\n\tstruct ucode_patch *patch;\n\tu16 proc_id;\n\tint ret;\n\n\tret = verify_patch(family, fw, leftover, patch_size, false);\n\tif (ret)\n\t\treturn ret;\n\n\tpatch = kzalloc(sizeof(*patch), GFP_KERNEL);\n\tif (!patch) {\n\t\tpr_err(\"Patch allocation failure.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpatch->data = kmemdup(fw + SECTION_HDR_SIZE, *patch_size, GFP_KERNEL);\n\tif (!patch->data) {\n\t\tpr_err(\"Patch data allocation failure.\\n\");\n\t\tkfree(patch);\n\t\treturn -EINVAL;\n\t}\n\tpatch->size = *patch_size;\n\n\tmc_hdr      = (struct microcode_header_amd *)(fw + SECTION_HDR_SIZE);\n\tproc_id     = mc_hdr->processor_rev_id;\n\n\tINIT_LIST_HEAD(&patch->plist);\n\tpatch->patch_id  = mc_hdr->patch_id;\n\tpatch->equiv_cpu = proc_id;\n\n\tpr_debug(\"%s: Added patch_id: 0x%08x, proc_id: 0x%04x\\n\",\n\t\t __func__, patch->patch_id, proc_id);\n\n\t \n\tupdate_cache(patch);\n\n\treturn 0;\n}\n\n \nstatic enum ucode_state __load_microcode_amd(u8 family, const u8 *data,\n\t\t\t\t\t     size_t size)\n{\n\tu8 *fw = (u8 *)data;\n\tsize_t offset;\n\n\toffset = install_equiv_cpu_table(data, size);\n\tif (!offset)\n\t\treturn UCODE_ERROR;\n\n\tfw   += offset;\n\tsize -= offset;\n\n\tif (*(u32 *)fw != UCODE_UCODE_TYPE) {\n\t\tpr_err(\"invalid type field in container file section header\\n\");\n\t\tfree_equiv_cpu_table();\n\t\treturn UCODE_ERROR;\n\t}\n\n\twhile (size > 0) {\n\t\tunsigned int crnt_size = 0;\n\t\tint ret;\n\n\t\tret = verify_and_add_patch(family, fw, size, &crnt_size);\n\t\tif (ret < 0)\n\t\t\treturn UCODE_ERROR;\n\n\t\tfw   +=  crnt_size + SECTION_HDR_SIZE;\n\t\tsize -= (crnt_size + SECTION_HDR_SIZE);\n\t}\n\n\treturn UCODE_OK;\n}\n\nstatic enum ucode_state load_microcode_amd(u8 family, const u8 *data, size_t size)\n{\n\tstruct cpuinfo_x86 *c;\n\tunsigned int nid, cpu;\n\tstruct ucode_patch *p;\n\tenum ucode_state ret;\n\n\t \n\tfree_equiv_cpu_table();\n\n\tret = __load_microcode_amd(family, data, size);\n\tif (ret != UCODE_OK) {\n\t\tcleanup();\n\t\treturn ret;\n\t}\n\n\tfor_each_node(nid) {\n\t\tcpu = cpumask_first(cpumask_of_node(nid));\n\t\tc = &cpu_data(cpu);\n\n\t\tp = find_patch(cpu);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tif (c->microcode >= p->patch_id)\n\t\t\tcontinue;\n\n\t\tret = UCODE_NEW;\n\t}\n\n\treturn ret;\n}\n\n \nstatic enum ucode_state request_microcode_amd(int cpu, struct device *device)\n{\n\tchar fw_name[36] = \"amd-ucode/microcode_amd.bin\";\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tenum ucode_state ret = UCODE_NFOUND;\n\tconst struct firmware *fw;\n\n\tif (c->x86 >= 0x15)\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amd-ucode/microcode_amd_fam%.2xh.bin\", c->x86);\n\n\tif (request_firmware_direct(&fw, (const char *)fw_name, device)) {\n\t\tpr_debug(\"failed to load file %s\\n\", fw_name);\n\t\tgoto out;\n\t}\n\n\tret = UCODE_ERROR;\n\tif (!verify_container(fw->data, fw->size, false))\n\t\tgoto fw_release;\n\n\tret = load_microcode_amd(c->x86, fw->data, fw->size);\n\n fw_release:\n\trelease_firmware(fw);\n\n out:\n\treturn ret;\n}\n\nstatic void microcode_fini_cpu_amd(int cpu)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\n\tuci->mc = NULL;\n}\n\nstatic struct microcode_ops microcode_amd_ops = {\n\t.request_microcode_fw             = request_microcode_amd,\n\t.collect_cpu_info                 = collect_cpu_info_amd,\n\t.apply_microcode                  = apply_microcode_amd,\n\t.microcode_fini_cpu               = microcode_fini_cpu_amd,\n};\n\nstruct microcode_ops * __init init_amd_microcode(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\tif (c->x86_vendor != X86_VENDOR_AMD || c->x86 < 0x10) {\n\t\tpr_warn(\"AMD CPU family 0x%x not supported\\n\", c->x86);\n\t\treturn NULL;\n\t}\n\n\tif (ucode_new_rev)\n\t\tpr_info_once(\"microcode updated early to new patch_level=0x%08x\\n\",\n\t\t\t     ucode_new_rev);\n\n\treturn &microcode_amd_ops;\n}\n\nvoid __exit exit_amd_microcode(void)\n{\n\tcleanup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}