{
  "module_name": "core.c",
  "hash_id": "f38c39d1bda9121d816e8248fa97402a0713abb629f5da370280e9c7df0f9f86",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/microcode/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"microcode: \" fmt\n\n#include <linux/platform_device.h>\n#include <linux/stop_machine.h>\n#include <linux/syscore_ops.h>\n#include <linux/miscdevice.h>\n#include <linux/capability.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/nmi.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/perf_event.h>\n#include <asm/processor.h>\n#include <asm/cmdline.h>\n#include <asm/setup.h>\n\n#include \"internal.h\"\n\n#define DRIVER_VERSION\t\"2.2\"\n\nstatic struct microcode_ops\t*microcode_ops;\nstatic bool dis_ucode_ldr = true;\n\nbool initrd_gone;\n\nLIST_HEAD(microcode_cache);\n\n \nstruct ucode_cpu_info\t\tucode_cpu_info[NR_CPUS];\n\nstruct cpu_info_ctx {\n\tstruct cpu_signature\t*cpu_sig;\n\tint\t\t\terr;\n};\n\n \nstatic u32 final_levels[] = {\n\t0x01000098,\n\t0x0100009f,\n\t0x010000af,\n\t0,  \n};\n\n \nstatic bool amd_check_current_patch_level(void)\n{\n\tu32 lvl, dummy, i;\n\tu32 *levels;\n\n\tnative_rdmsr(MSR_AMD64_PATCH_LEVEL, lvl, dummy);\n\n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\tlevels = (u32 *)__pa_nodebug(&final_levels);\n\telse\n\t\tlevels = final_levels;\n\n\tfor (i = 0; levels[i]; i++) {\n\t\tif (lvl == levels[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool __init check_loader_disabled_bsp(void)\n{\n\tstatic const char *__dis_opt_str = \"dis_ucode_ldr\";\n\n#ifdef CONFIG_X86_32\n\tconst char *cmdline = (const char *)__pa_nodebug(boot_command_line);\n\tconst char *option  = (const char *)__pa_nodebug(__dis_opt_str);\n\tbool *res = (bool *)__pa_nodebug(&dis_ucode_ldr);\n\n#else  \n\tconst char *cmdline = boot_command_line;\n\tconst char *option  = __dis_opt_str;\n\tbool *res = &dis_ucode_ldr;\n#endif\n\n\t \n\tif (native_cpuid_ecx(1) & BIT(31))\n\t\treturn *res;\n\n\tif (x86_cpuid_vendor() == X86_VENDOR_AMD) {\n\t\tif (amd_check_current_patch_level())\n\t\t\treturn *res;\n\t}\n\n\tif (cmdline_find_option_bool(cmdline, option) <= 0)\n\t\t*res = false;\n\n\treturn *res;\n}\n\nvoid __init load_ucode_bsp(void)\n{\n\tunsigned int cpuid_1_eax;\n\tbool intel = true;\n\n\tif (!have_cpuid_p())\n\t\treturn;\n\n\tcpuid_1_eax = native_cpuid_eax(1);\n\n\tswitch (x86_cpuid_vendor()) {\n\tcase X86_VENDOR_INTEL:\n\t\tif (x86_family(cpuid_1_eax) < 6)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase X86_VENDOR_AMD:\n\t\tif (x86_family(cpuid_1_eax) < 0x10)\n\t\t\treturn;\n\t\tintel = false;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (check_loader_disabled_bsp())\n\t\treturn;\n\n\tif (intel)\n\t\tload_ucode_intel_bsp();\n\telse\n\t\tload_ucode_amd_early(cpuid_1_eax);\n}\n\nstatic bool check_loader_disabled_ap(void)\n{\n#ifdef CONFIG_X86_32\n\treturn *((bool *)__pa_nodebug(&dis_ucode_ldr));\n#else\n\treturn dis_ucode_ldr;\n#endif\n}\n\nvoid load_ucode_ap(void)\n{\n\tunsigned int cpuid_1_eax;\n\n\tif (check_loader_disabled_ap())\n\t\treturn;\n\n\tcpuid_1_eax = native_cpuid_eax(1);\n\n\tswitch (x86_cpuid_vendor()) {\n\tcase X86_VENDOR_INTEL:\n\t\tif (x86_family(cpuid_1_eax) >= 6)\n\t\t\tload_ucode_intel_ap();\n\t\tbreak;\n\tcase X86_VENDOR_AMD:\n\t\tif (x86_family(cpuid_1_eax) >= 0x10)\n\t\t\tload_ucode_amd_early(cpuid_1_eax);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int __init save_microcode_in_initrd(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\tint ret = -EINVAL;\n\n\tif (dis_ucode_ldr) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tif (c->x86 >= 6)\n\t\t\tret = save_microcode_in_initrd_intel();\n\t\tbreak;\n\tcase X86_VENDOR_AMD:\n\t\tif (c->x86 >= 0x10)\n\t\t\tret = save_microcode_in_initrd_amd(cpuid_eax(1));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tinitrd_gone = true;\n\n\treturn ret;\n}\n\nstruct cpio_data find_microcode_in_initrd(const char *path, bool use_pa)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tunsigned long start = 0;\n\tsize_t size;\n\n#ifdef CONFIG_X86_32\n\tstruct boot_params *params;\n\n\tif (use_pa)\n\t\tparams = (struct boot_params *)__pa_nodebug(&boot_params);\n\telse\n\t\tparams = &boot_params;\n\n\tsize = params->hdr.ramdisk_size;\n\n\t \n\tif (size)\n\t\tstart = params->hdr.ramdisk_image;\n\n# else  \n\tsize  = (unsigned long)boot_params.ext_ramdisk_size << 32;\n\tsize |= boot_params.hdr.ramdisk_size;\n\n\tif (size) {\n\t\tstart  = (unsigned long)boot_params.ext_ramdisk_image << 32;\n\t\tstart |= boot_params.hdr.ramdisk_image;\n\n\t\tstart += PAGE_OFFSET;\n\t}\n# endif\n\n\t \n\tif (!use_pa) {\n\t\tif (initrd_gone)\n\t\t\treturn (struct cpio_data){ NULL, 0, \"\" };\n\t\tif (initrd_start)\n\t\t\tstart = initrd_start;\n\t} else {\n\t\t \n\t\tu64 *rr = (u64 *)__pa_nodebug(&relocated_ramdisk);\n\t\tif (*rr)\n\t\t\tstart = *rr;\n\t}\n\n\treturn find_cpio_data(path, (void *)start, size, NULL);\n#else  \n\treturn (struct cpio_data){ NULL, 0, \"\" };\n#endif\n}\n\nstatic void reload_early_microcode(unsigned int cpu)\n{\n\tint vendor, family;\n\n\tvendor = x86_cpuid_vendor();\n\tfamily = x86_cpuid_family();\n\n\tswitch (vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tif (family >= 6)\n\t\t\treload_ucode_intel();\n\t\tbreak;\n\tcase X86_VENDOR_AMD:\n\t\tif (family >= 0x10)\n\t\t\treload_ucode_amd(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic struct platform_device\t*microcode_pdev;\n\n#ifdef CONFIG_MICROCODE_LATE_LOADING\n \n#define SPINUNIT 100  \n\nstatic int check_online_cpus(void)\n{\n\tunsigned int cpu;\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu) && !cpu_online(cpu)) {\n\t\t\tpr_err(\"Not all CPUs online, aborting microcode update.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic atomic_t late_cpus_in;\nstatic atomic_t late_cpus_out;\n\nstatic int __wait_for_cpus(atomic_t *t, long long timeout)\n{\n\tint all_cpus = num_online_cpus();\n\n\tatomic_inc(t);\n\n\twhile (atomic_read(t) < all_cpus) {\n\t\tif (timeout < SPINUNIT) {\n\t\t\tpr_err(\"Timeout while waiting for CPUs rendezvous, remaining: %d\\n\",\n\t\t\t\tall_cpus - atomic_read(t));\n\t\t\treturn 1;\n\t\t}\n\n\t\tndelay(SPINUNIT);\n\t\ttimeout -= SPINUNIT;\n\n\t\ttouch_nmi_watchdog();\n\t}\n\treturn 0;\n}\n\n \nstatic int __reload_late(void *info)\n{\n\tint cpu = smp_processor_id();\n\tenum ucode_state err;\n\tint ret = 0;\n\n\t \n\tif (__wait_for_cpus(&late_cpus_in, NSEC_PER_SEC))\n\t\treturn -1;\n\n\t \n\tif (cpumask_first(topology_sibling_cpumask(cpu)) == cpu)\n\t\terr = microcode_ops->apply_microcode(cpu);\n\telse\n\t\tgoto wait_for_siblings;\n\n\tif (err >= UCODE_NFOUND) {\n\t\tif (err == UCODE_ERROR) {\n\t\t\tpr_warn(\"Error reloading microcode on CPU %d\\n\", cpu);\n\t\t\tret = -1;\n\t\t}\n\t}\n\nwait_for_siblings:\n\tif (__wait_for_cpus(&late_cpus_out, NSEC_PER_SEC))\n\t\tpanic(\"Timeout during microcode update!\\n\");\n\n\t \n\tif (cpumask_first(topology_sibling_cpumask(cpu)) != cpu)\n\t\terr = microcode_ops->apply_microcode(cpu);\n\n\treturn ret;\n}\n\n \nstatic int microcode_reload_late(void)\n{\n\tint old = boot_cpu_data.microcode, ret;\n\tstruct cpuinfo_x86 prev_info;\n\n\tpr_err(\"Attempting late microcode loading - it is dangerous and taints the kernel.\\n\");\n\tpr_err(\"You should switch to early loading, if possible.\\n\");\n\n\tatomic_set(&late_cpus_in,  0);\n\tatomic_set(&late_cpus_out, 0);\n\n\t \n\tstore_cpu_caps(&prev_info);\n\n\tret = stop_machine_cpuslocked(__reload_late, NULL, cpu_online_mask);\n\tif (!ret) {\n\t\tpr_info(\"Reload succeeded, microcode revision: 0x%x -> 0x%x\\n\",\n\t\t\told, boot_cpu_data.microcode);\n\t\tmicrocode_check(&prev_info);\n\t} else {\n\t\tpr_info(\"Reload failed, current microcode revision: 0x%x\\n\",\n\t\t\tboot_cpu_data.microcode);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t reload_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tenum ucode_state tmp_ret = UCODE_OK;\n\tint bsp = boot_cpu_data.cpu_index;\n\tunsigned long val;\n\tssize_t ret = 0;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret || val != 1)\n\t\treturn -EINVAL;\n\n\tcpus_read_lock();\n\n\tret = check_online_cpus();\n\tif (ret)\n\t\tgoto put;\n\n\ttmp_ret = microcode_ops->request_microcode_fw(bsp, &microcode_pdev->dev);\n\tif (tmp_ret != UCODE_NEW)\n\t\tgoto put;\n\n\tret = microcode_reload_late();\nput:\n\tcpus_read_unlock();\n\n\tif (ret == 0)\n\t\tret = size;\n\n\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_WO(reload);\n#endif\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\n\n\treturn sprintf(buf, \"0x%x\\n\", uci->cpu_sig.rev);\n}\n\nstatic ssize_t processor_flags_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\n\n\treturn sprintf(buf, \"0x%x\\n\", uci->cpu_sig.pf);\n}\n\nstatic DEVICE_ATTR_RO(version);\nstatic DEVICE_ATTR_RO(processor_flags);\n\nstatic struct attribute *mc_default_attrs[] = {\n\t&dev_attr_version.attr,\n\t&dev_attr_processor_flags.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mc_attr_group = {\n\t.attrs\t\t\t= mc_default_attrs,\n\t.name\t\t\t= \"microcode\",\n};\n\nstatic void microcode_fini_cpu(int cpu)\n{\n\tif (microcode_ops->microcode_fini_cpu)\n\t\tmicrocode_ops->microcode_fini_cpu(cpu);\n}\n\nstatic enum ucode_state microcode_init_cpu(int cpu)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\n\tmemset(uci, 0, sizeof(*uci));\n\n\tmicrocode_ops->collect_cpu_info(cpu, &uci->cpu_sig);\n\n\treturn microcode_ops->apply_microcode(cpu);\n}\n\n \nvoid microcode_bsp_resume(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\n\tif (uci->mc)\n\t\tmicrocode_ops->apply_microcode(cpu);\n\telse\n\t\treload_early_microcode(cpu);\n}\n\nstatic struct syscore_ops mc_syscore_ops = {\n\t.resume\t= microcode_bsp_resume,\n};\n\nstatic int mc_cpu_starting(unsigned int cpu)\n{\n\tenum ucode_state err = microcode_ops->apply_microcode(cpu);\n\n\tpr_debug(\"%s: CPU%d, err: %d\\n\", __func__, cpu, err);\n\n\treturn err == UCODE_ERROR;\n}\n\nstatic int mc_cpu_online(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tif (sysfs_create_group(&dev->kobj, &mc_attr_group))\n\t\tpr_err(\"Failed to create group for CPU%d\\n\", cpu);\n\treturn 0;\n}\n\nstatic int mc_cpu_down_prep(unsigned int cpu)\n{\n\tstruct device *dev;\n\n\tdev = get_cpu_device(cpu);\n\n\tmicrocode_fini_cpu(cpu);\n\n\t \n\tsysfs_remove_group(&dev->kobj, &mc_attr_group);\n\tpr_debug(\"%s: CPU%d\\n\", __func__, cpu);\n\n\treturn 0;\n}\n\nstatic void setup_online_cpu(struct work_struct *work)\n{\n\tint cpu = smp_processor_id();\n\tenum ucode_state err;\n\n\terr = microcode_init_cpu(cpu);\n\tif (err == UCODE_ERROR) {\n\t\tpr_err(\"Error applying microcode on CPU%d\\n\", cpu);\n\t\treturn;\n\t}\n\n\tmc_cpu_online(cpu);\n}\n\nstatic struct attribute *cpu_root_microcode_attrs[] = {\n#ifdef CONFIG_MICROCODE_LATE_LOADING\n\t&dev_attr_reload.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group cpu_root_microcode_group = {\n\t.name  = \"microcode\",\n\t.attrs = cpu_root_microcode_attrs,\n};\n\nstatic int __init microcode_init(void)\n{\n\tstruct device *dev_root;\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\tint error;\n\n\tif (dis_ucode_ldr)\n\t\treturn -EINVAL;\n\n\tif (c->x86_vendor == X86_VENDOR_INTEL)\n\t\tmicrocode_ops = init_intel_microcode();\n\telse if (c->x86_vendor == X86_VENDOR_AMD)\n\t\tmicrocode_ops = init_amd_microcode();\n\telse\n\t\tpr_err(\"no support for this CPU vendor\\n\");\n\n\tif (!microcode_ops)\n\t\treturn -ENODEV;\n\n\tmicrocode_pdev = platform_device_register_simple(\"microcode\", -1, NULL, 0);\n\tif (IS_ERR(microcode_pdev))\n\t\treturn PTR_ERR(microcode_pdev);\n\n\tdev_root = bus_get_dev_root(&cpu_subsys);\n\tif (dev_root) {\n\t\terror = sysfs_create_group(&dev_root->kobj, &cpu_root_microcode_group);\n\t\tput_device(dev_root);\n\t\tif (error) {\n\t\t\tpr_err(\"Error creating microcode group!\\n\");\n\t\t\tgoto out_pdev;\n\t\t}\n\t}\n\n\t \n\tschedule_on_each_cpu(setup_online_cpu);\n\n\tregister_syscore_ops(&mc_syscore_ops);\n\tcpuhp_setup_state_nocalls(CPUHP_AP_MICROCODE_LOADER, \"x86/microcode:starting\",\n\t\t\t\t  mc_cpu_starting, NULL);\n\tcpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"x86/microcode:online\",\n\t\t\t\t  mc_cpu_online, mc_cpu_down_prep);\n\n\tpr_info(\"Microcode Update Driver: v%s.\", DRIVER_VERSION);\n\n\treturn 0;\n\n out_pdev:\n\tplatform_device_unregister(microcode_pdev);\n\treturn error;\n\n}\nfs_initcall(save_microcode_in_initrd);\nlate_initcall(microcode_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}