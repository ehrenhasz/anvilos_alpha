{
  "module_name": "intel.c",
  "hash_id": "de08bfcbbae21a2b5f7edd2d426be3cdd6fd35539a3a2defb905c987867d336f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/microcode/intel.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"microcode: \" fmt\n#include <linux/earlycpio.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/initrd.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/cpu.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#include <asm/intel-family.h>\n#include <asm/processor.h>\n#include <asm/tlbflush.h>\n#include <asm/setup.h>\n#include <asm/msr.h>\n\n#include \"internal.h\"\n\nstatic const char ucode_path[] = \"kernel/x86/microcode/GenuineIntel.bin\";\n\n \nstatic struct microcode_intel *intel_ucode_patch;\n\n \nstatic int llc_size_per_core;\n\n \nstruct extended_signature {\n\tunsigned int\tsig;\n\tunsigned int\tpf;\n\tunsigned int\tcksum;\n};\n\nstruct extended_sigtable {\n\tunsigned int\t\t\tcount;\n\tunsigned int\t\t\tcksum;\n\tunsigned int\t\t\treserved[3];\n\tstruct extended_signature\tsigs[];\n};\n\n#define DEFAULT_UCODE_TOTALSIZE (DEFAULT_UCODE_DATASIZE + MC_HEADER_SIZE)\n#define EXT_HEADER_SIZE\t\t(sizeof(struct extended_sigtable))\n#define EXT_SIGNATURE_SIZE\t(sizeof(struct extended_signature))\n\nstatic inline unsigned int get_totalsize(struct microcode_header_intel *hdr)\n{\n\treturn hdr->datasize ? hdr->totalsize : DEFAULT_UCODE_TOTALSIZE;\n}\n\nstatic inline unsigned int exttable_size(struct extended_sigtable *et)\n{\n\treturn et->count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE;\n}\n\nint intel_cpu_collect_info(struct ucode_cpu_info *uci)\n{\n\tunsigned int val[2];\n\tunsigned int family, model;\n\tstruct cpu_signature csig = { 0 };\n\tunsigned int eax, ebx, ecx, edx;\n\n\tmemset(uci, 0, sizeof(*uci));\n\n\teax = 0x00000001;\n\tecx = 0;\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\tcsig.sig = eax;\n\n\tfamily = x86_family(eax);\n\tmodel  = x86_model(eax);\n\n\tif (model >= 5 || family > 6) {\n\t\t \n\t\tnative_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);\n\t\tcsig.pf = 1 << ((val[1] >> 18) & 7);\n\t}\n\n\tcsig.rev = intel_get_microcode_revision();\n\n\tuci->cpu_sig = csig;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_cpu_collect_info);\n\n \nint intel_find_matching_signature(void *mc, unsigned int csig, int cpf)\n{\n\tstruct microcode_header_intel *mc_hdr = mc;\n\tstruct extended_sigtable *ext_hdr;\n\tstruct extended_signature *ext_sig;\n\tint i;\n\n\tif (intel_cpu_signatures_match(csig, cpf, mc_hdr->sig, mc_hdr->pf))\n\t\treturn 1;\n\n\t \n\tif (get_totalsize(mc_hdr) <= intel_microcode_get_datasize(mc_hdr) + MC_HEADER_SIZE)\n\t\treturn 0;\n\n\text_hdr = mc + intel_microcode_get_datasize(mc_hdr) + MC_HEADER_SIZE;\n\text_sig = (void *)ext_hdr + EXT_HEADER_SIZE;\n\n\tfor (i = 0; i < ext_hdr->count; i++) {\n\t\tif (intel_cpu_signatures_match(csig, cpf, ext_sig->sig, ext_sig->pf))\n\t\t\treturn 1;\n\t\text_sig++;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_find_matching_signature);\n\n \nint intel_microcode_sanity_check(void *mc, bool print_err, int hdr_type)\n{\n\tunsigned long total_size, data_size, ext_table_size;\n\tstruct microcode_header_intel *mc_header = mc;\n\tstruct extended_sigtable *ext_header = NULL;\n\tu32 sum, orig_sum, ext_sigcount = 0, i;\n\tstruct extended_signature *ext_sig;\n\n\ttotal_size = get_totalsize(mc_header);\n\tdata_size = intel_microcode_get_datasize(mc_header);\n\n\tif (data_size + MC_HEADER_SIZE > total_size) {\n\t\tif (print_err)\n\t\t\tpr_err(\"Error: bad microcode data file size.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mc_header->ldrver != 1 || mc_header->hdrver != hdr_type) {\n\t\tif (print_err)\n\t\t\tpr_err(\"Error: invalid/unknown microcode update format. Header type %d\\n\",\n\t\t\t       mc_header->hdrver);\n\t\treturn -EINVAL;\n\t}\n\n\text_table_size = total_size - (MC_HEADER_SIZE + data_size);\n\tif (ext_table_size) {\n\t\tu32 ext_table_sum = 0;\n\t\tu32 *ext_tablep;\n\n\t\tif (ext_table_size < EXT_HEADER_SIZE ||\n\t\t    ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {\n\t\t\tif (print_err)\n\t\t\t\tpr_err(\"Error: truncated extended signature table.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\text_header = mc + MC_HEADER_SIZE + data_size;\n\t\tif (ext_table_size != exttable_size(ext_header)) {\n\t\t\tif (print_err)\n\t\t\t\tpr_err(\"Error: extended signature table size mismatch.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\text_sigcount = ext_header->count;\n\n\t\t \n\t\text_tablep = (u32 *)ext_header;\n\n\t\ti = ext_table_size / sizeof(u32);\n\t\twhile (i--)\n\t\t\text_table_sum += ext_tablep[i];\n\n\t\tif (ext_table_sum) {\n\t\t\tif (print_err)\n\t\t\t\tpr_warn(\"Bad extended signature table checksum, aborting.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\torig_sum = 0;\n\ti = (MC_HEADER_SIZE + data_size) / sizeof(u32);\n\twhile (i--)\n\t\torig_sum += ((u32 *)mc)[i];\n\n\tif (orig_sum) {\n\t\tif (print_err)\n\t\t\tpr_err(\"Bad microcode data checksum, aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ext_table_size)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ext_sigcount; i++) {\n\t\text_sig = (void *)ext_header + EXT_HEADER_SIZE +\n\t\t\t  EXT_SIGNATURE_SIZE * i;\n\n\t\tsum = (mc_header->sig + mc_header->pf + mc_header->cksum) -\n\t\t      (ext_sig->sig + ext_sig->pf + ext_sig->cksum);\n\t\tif (sum) {\n\t\t\tif (print_err)\n\t\t\t\tpr_err(\"Bad extended signature checksum, aborting.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_microcode_sanity_check);\n\n \nstatic int has_newer_microcode(void *mc, unsigned int csig, int cpf, int new_rev)\n{\n\tstruct microcode_header_intel *mc_hdr = mc;\n\n\tif (mc_hdr->rev <= new_rev)\n\t\treturn 0;\n\n\treturn intel_find_matching_signature(mc, csig, cpf);\n}\n\nstatic struct ucode_patch *memdup_patch(void *data, unsigned int size)\n{\n\tstruct ucode_patch *p;\n\n\tp = kzalloc(sizeof(struct ucode_patch), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tp->data = kmemdup(data, size, GFP_KERNEL);\n\tif (!p->data) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\nstatic void save_microcode_patch(struct ucode_cpu_info *uci, void *data, unsigned int size)\n{\n\tstruct microcode_header_intel *mc_hdr, *mc_saved_hdr;\n\tstruct ucode_patch *iter, *tmp, *p = NULL;\n\tbool prev_found = false;\n\tunsigned int sig, pf;\n\n\tmc_hdr = (struct microcode_header_intel *)data;\n\n\tlist_for_each_entry_safe(iter, tmp, &microcode_cache, plist) {\n\t\tmc_saved_hdr = (struct microcode_header_intel *)iter->data;\n\t\tsig\t     = mc_saved_hdr->sig;\n\t\tpf\t     = mc_saved_hdr->pf;\n\n\t\tif (intel_find_matching_signature(data, sig, pf)) {\n\t\t\tprev_found = true;\n\n\t\t\tif (mc_hdr->rev <= mc_saved_hdr->rev)\n\t\t\t\tcontinue;\n\n\t\t\tp = memdup_patch(data, size);\n\t\t\tif (!p)\n\t\t\t\tpr_err(\"Error allocating buffer %p\\n\", data);\n\t\t\telse {\n\t\t\t\tlist_replace(&iter->plist, &p->plist);\n\t\t\t\tkfree(iter->data);\n\t\t\t\tkfree(iter);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!prev_found) {\n\t\tp = memdup_patch(data, size);\n\t\tif (!p)\n\t\t\tpr_err(\"Error allocating buffer for %p\\n\", data);\n\t\telse\n\t\t\tlist_add_tail(&p->plist, &microcode_cache);\n\t}\n\n\tif (!p)\n\t\treturn;\n\n\tif (!intel_find_matching_signature(p->data, uci->cpu_sig.sig, uci->cpu_sig.pf))\n\t\treturn;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\tintel_ucode_patch = (struct microcode_intel *)__pa_nodebug(p->data);\n\telse\n\t\tintel_ucode_patch = p->data;\n}\n\n \nstatic struct microcode_intel *\nscan_microcode(void *data, size_t size, struct ucode_cpu_info *uci, bool save)\n{\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *patch = NULL;\n\tunsigned int mc_size;\n\n\twhile (size) {\n\t\tif (size < sizeof(struct microcode_header_intel))\n\t\t\tbreak;\n\n\t\tmc_header = (struct microcode_header_intel *)data;\n\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size ||\n\t\t    mc_size > size ||\n\t\t    intel_microcode_sanity_check(data, false, MC_HEADER_TYPE_MICROCODE) < 0)\n\t\t\tbreak;\n\n\t\tsize -= mc_size;\n\n\t\tif (!intel_find_matching_signature(data, uci->cpu_sig.sig,\n\t\t\t\t\t\t   uci->cpu_sig.pf)) {\n\t\t\tdata += mc_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (save) {\n\t\t\tsave_microcode_patch(uci, data, mc_size);\n\t\t\tgoto next;\n\t\t}\n\n\n\t\tif (!patch) {\n\t\t\tif (!has_newer_microcode(data,\n\t\t\t\t\t\t uci->cpu_sig.sig,\n\t\t\t\t\t\t uci->cpu_sig.pf,\n\t\t\t\t\t\t uci->cpu_sig.rev))\n\t\t\t\tgoto next;\n\n\t\t} else {\n\t\t\tstruct microcode_header_intel *phdr = &patch->hdr;\n\n\t\t\tif (!has_newer_microcode(data,\n\t\t\t\t\t\t phdr->sig,\n\t\t\t\t\t\t phdr->pf,\n\t\t\t\t\t\t phdr->rev))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tpatch = data;\n\nnext:\n\t\tdata += mc_size;\n\t}\n\n\tif (size)\n\t\treturn NULL;\n\n\treturn patch;\n}\n\nstatic bool load_builtin_intel_microcode(struct cpio_data *cp)\n{\n\tunsigned int eax = 1, ebx, ecx = 0, edx;\n\tstruct firmware fw;\n\tchar name[30];\n\n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\treturn false;\n\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\n\tsprintf(name, \"intel-ucode/%02x-%02x-%02x\",\n\t\t      x86_family(eax), x86_model(eax), x86_stepping(eax));\n\n\tif (firmware_request_builtin(&fw, name)) {\n\t\tcp->size = fw.size;\n\t\tcp->data = (void *)fw.data;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void print_ucode_info(int old_rev, int new_rev, unsigned int date)\n{\n\tpr_info_once(\"updated early: 0x%x -> 0x%x, date = %04x-%02x-%02x\\n\",\n\t\t     old_rev,\n\t\t     new_rev,\n\t\t     date & 0xffff,\n\t\t     date >> 24,\n\t\t     (date >> 16) & 0xff);\n}\n\n#ifdef CONFIG_X86_32\n\nstatic int delay_ucode_info;\nstatic int current_mc_date;\nstatic int early_old_rev;\n\n \nvoid show_ucode_info_early(void)\n{\n\tstruct ucode_cpu_info uci;\n\n\tif (delay_ucode_info) {\n\t\tintel_cpu_collect_info(&uci);\n\t\tprint_ucode_info(early_old_rev, uci.cpu_sig.rev, current_mc_date);\n\t\tdelay_ucode_info = 0;\n\t}\n}\n\n \nstatic void print_ucode(int old_rev, int new_rev, int date)\n{\n\tint *delay_ucode_info_p;\n\tint *current_mc_date_p;\n\tint *early_old_rev_p;\n\n\tdelay_ucode_info_p = (int *)__pa_nodebug(&delay_ucode_info);\n\tcurrent_mc_date_p = (int *)__pa_nodebug(&current_mc_date);\n\tearly_old_rev_p = (int *)__pa_nodebug(&early_old_rev);\n\n\t*delay_ucode_info_p = 1;\n\t*current_mc_date_p = date;\n\t*early_old_rev_p = old_rev;\n}\n#else\n\nstatic inline void print_ucode(int old_rev, int new_rev, int date)\n{\n\tprint_ucode_info(old_rev, new_rev, date);\n}\n#endif\n\nstatic int apply_microcode_early(struct ucode_cpu_info *uci, bool early)\n{\n\tstruct microcode_intel *mc;\n\tu32 rev, old_rev;\n\n\tmc = uci->mc;\n\tif (!mc)\n\t\treturn 0;\n\n\t \n\trev = intel_get_microcode_revision();\n\tif (rev >= mc->hdr.rev) {\n\t\tuci->cpu_sig.rev = rev;\n\t\treturn UCODE_OK;\n\t}\n\n\told_rev = rev;\n\n\t \n\tnative_wbinvd();\n\n\t \n\tnative_wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);\n\n\trev = intel_get_microcode_revision();\n\tif (rev != mc->hdr.rev)\n\t\treturn -1;\n\n\tuci->cpu_sig.rev = rev;\n\n\tif (early)\n\t\tprint_ucode(old_rev, uci->cpu_sig.rev, mc->hdr.date);\n\telse\n\t\tprint_ucode_info(old_rev, uci->cpu_sig.rev, mc->hdr.date);\n\n\treturn 0;\n}\n\nint __init save_microcode_in_initrd_intel(void)\n{\n\tstruct ucode_cpu_info uci;\n\tstruct cpio_data cp;\n\n\t \n\tintel_ucode_patch = NULL;\n\n\tif (!load_builtin_intel_microcode(&cp))\n\t\tcp = find_microcode_in_initrd(ucode_path, false);\n\n\tif (!(cp.data && cp.size))\n\t\treturn 0;\n\n\tintel_cpu_collect_info(&uci);\n\n\tscan_microcode(cp.data, cp.size, &uci, true);\n\treturn 0;\n}\n\n \nstatic struct microcode_intel *__load_ucode_intel(struct ucode_cpu_info *uci)\n{\n\tstatic const char *path;\n\tstruct cpio_data cp;\n\tbool use_pa;\n\n\tif (IS_ENABLED(CONFIG_X86_32)) {\n\t\tpath\t  = (const char *)__pa_nodebug(ucode_path);\n\t\tuse_pa\t  = true;\n\t} else {\n\t\tpath\t  = ucode_path;\n\t\tuse_pa\t  = false;\n\t}\n\n\t \n\tif (!load_builtin_intel_microcode(&cp))\n\t\tcp = find_microcode_in_initrd(path, use_pa);\n\n\tif (!(cp.data && cp.size))\n\t\treturn NULL;\n\n\tintel_cpu_collect_info(uci);\n\n\treturn scan_microcode(cp.data, cp.size, uci, false);\n}\n\nvoid __init load_ucode_intel_bsp(void)\n{\n\tstruct microcode_intel *patch;\n\tstruct ucode_cpu_info uci;\n\n\tpatch = __load_ucode_intel(&uci);\n\tif (!patch)\n\t\treturn;\n\n\tuci.mc = patch;\n\n\tapply_microcode_early(&uci, true);\n}\n\nvoid load_ucode_intel_ap(void)\n{\n\tstruct microcode_intel *patch, **iup;\n\tstruct ucode_cpu_info uci;\n\n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\tiup = (struct microcode_intel **) __pa_nodebug(&intel_ucode_patch);\n\telse\n\t\tiup = &intel_ucode_patch;\n\n\tif (!*iup) {\n\t\tpatch = __load_ucode_intel(&uci);\n\t\tif (!patch)\n\t\t\treturn;\n\n\t\t*iup = patch;\n\t}\n\n\tuci.mc = *iup;\n\n\tapply_microcode_early(&uci, true);\n}\n\nstatic struct microcode_intel *find_patch(struct ucode_cpu_info *uci)\n{\n\tstruct microcode_header_intel *phdr;\n\tstruct ucode_patch *iter, *tmp;\n\n\tlist_for_each_entry_safe(iter, tmp, &microcode_cache, plist) {\n\n\t\tphdr = (struct microcode_header_intel *)iter->data;\n\n\t\tif (phdr->rev <= uci->cpu_sig.rev)\n\t\t\tcontinue;\n\n\t\tif (!intel_find_matching_signature(phdr,\n\t\t\t\t\t\t   uci->cpu_sig.sig,\n\t\t\t\t\t\t   uci->cpu_sig.pf))\n\t\t\tcontinue;\n\n\t\treturn iter->data;\n\t}\n\treturn NULL;\n}\n\nvoid reload_ucode_intel(void)\n{\n\tstruct microcode_intel *p;\n\tstruct ucode_cpu_info uci;\n\n\tintel_cpu_collect_info(&uci);\n\n\tp = find_patch(&uci);\n\tif (!p)\n\t\treturn;\n\n\tuci.mc = p;\n\n\tapply_microcode_early(&uci, false);\n}\n\nstatic int collect_cpu_info(int cpu_num, struct cpu_signature *csig)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu_num);\n\tunsigned int val[2];\n\n\tmemset(csig, 0, sizeof(*csig));\n\n\tcsig->sig = cpuid_eax(0x00000001);\n\n\tif ((c->x86_model >= 5) || (c->x86 > 6)) {\n\t\t \n\t\trdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);\n\t\tcsig->pf = 1 << ((val[1] >> 18) & 7);\n\t}\n\n\tcsig->rev = c->microcode;\n\n\treturn 0;\n}\n\nstatic enum ucode_state apply_microcode_intel(int cpu)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tbool bsp = c->cpu_index == boot_cpu_data.cpu_index;\n\tstruct microcode_intel *mc;\n\tenum ucode_state ret;\n\tstatic int prev_rev;\n\tu32 rev;\n\n\t \n\tif (WARN_ON(raw_smp_processor_id() != cpu))\n\t\treturn UCODE_ERROR;\n\n\t \n\tmc = find_patch(uci);\n\tif (!mc) {\n\t\tmc = uci->mc;\n\t\tif (!mc)\n\t\t\treturn UCODE_NFOUND;\n\t}\n\n\t \n\trev = intel_get_microcode_revision();\n\tif (rev >= mc->hdr.rev) {\n\t\tret = UCODE_OK;\n\t\tgoto out;\n\t}\n\n\t \n\tnative_wbinvd();\n\n\t \n\twrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);\n\n\trev = intel_get_microcode_revision();\n\n\tif (rev != mc->hdr.rev) {\n\t\tpr_err(\"CPU%d update to revision 0x%x failed\\n\",\n\t\t       cpu, mc->hdr.rev);\n\t\treturn UCODE_ERROR;\n\t}\n\n\tif (bsp && rev != prev_rev) {\n\t\tpr_info(\"updated to revision 0x%x, date = %04x-%02x-%02x\\n\",\n\t\t\trev,\n\t\t\tmc->hdr.date & 0xffff,\n\t\t\tmc->hdr.date >> 24,\n\t\t\t(mc->hdr.date >> 16) & 0xff);\n\t\tprev_rev = rev;\n\t}\n\n\tret = UCODE_UPDATED;\n\nout:\n\tuci->cpu_sig.rev = rev;\n\tc->microcode\t = rev;\n\n\t \n\tif (bsp)\n\t\tboot_cpu_data.microcode = rev;\n\n\treturn ret;\n}\n\nstatic enum ucode_state generic_load_microcode(int cpu, struct iov_iter *iter)\n{\n\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\tunsigned int curr_mc_size = 0, new_mc_size = 0;\n\tenum ucode_state ret = UCODE_OK;\n\tint new_rev = uci->cpu_sig.rev;\n\tu8 *new_mc = NULL, *mc = NULL;\n\tunsigned int csig, cpf;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct microcode_header_intel mc_header;\n\t\tunsigned int mc_size, data_size;\n\t\tu8 *data;\n\n\t\tif (!copy_from_iter_full(&mc_header, sizeof(mc_header), iter)) {\n\t\t\tpr_err(\"error! Truncated or inaccessible header in microcode data file\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmc_size = get_totalsize(&mc_header);\n\t\tif (mc_size < sizeof(mc_header)) {\n\t\t\tpr_err(\"error! Bad data in microcode data file (totalsize too small)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdata_size = mc_size - sizeof(mc_header);\n\t\tif (data_size > iov_iter_count(iter)) {\n\t\t\tpr_err(\"error! Bad data in microcode data file (truncated file?)\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!mc || mc_size > curr_mc_size) {\n\t\t\tvfree(mc);\n\t\t\tmc = vmalloc(mc_size);\n\t\t\tif (!mc)\n\t\t\t\tbreak;\n\t\t\tcurr_mc_size = mc_size;\n\t\t}\n\n\t\tmemcpy(mc, &mc_header, sizeof(mc_header));\n\t\tdata = mc + sizeof(mc_header);\n\t\tif (!copy_from_iter_full(data, data_size, iter) ||\n\t\t    intel_microcode_sanity_check(mc, true, MC_HEADER_TYPE_MICROCODE) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcsig = uci->cpu_sig.sig;\n\t\tcpf = uci->cpu_sig.pf;\n\t\tif (has_newer_microcode(mc, csig, cpf, new_rev)) {\n\t\t\tvfree(new_mc);\n\t\t\tnew_rev = mc_header.rev;\n\t\t\tnew_mc  = mc;\n\t\t\tnew_mc_size = mc_size;\n\t\t\tmc = NULL;\t \n\t\t\tret = UCODE_NEW;\n\t\t}\n\t}\n\n\tvfree(mc);\n\n\tif (iov_iter_count(iter)) {\n\t\tvfree(new_mc);\n\t\treturn UCODE_ERROR;\n\t}\n\n\tif (!new_mc)\n\t\treturn UCODE_NFOUND;\n\n\tvfree(uci->mc);\n\tuci->mc = (struct microcode_intel *)new_mc;\n\n\t \n\tsave_microcode_patch(uci, new_mc, new_mc_size);\n\n\tpr_debug(\"CPU%d found a matching microcode update with version 0x%x (current=0x%x)\\n\",\n\t\t cpu, new_rev, uci->cpu_sig.rev);\n\n\treturn ret;\n}\n\nstatic bool is_blacklisted(unsigned int cpu)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\t \n\tif (c->x86 == 6 &&\n\t    c->x86_model == INTEL_FAM6_BROADWELL_X &&\n\t    c->x86_stepping == 0x01 &&\n\t    llc_size_per_core > 2621440 &&\n\t    c->microcode < 0x0b000021) {\n\t\tpr_err_once(\"Erratum BDF90: late loading with revision < 0x0b000021 (0x%x) disabled.\\n\", c->microcode);\n\t\tpr_err_once(\"Please consider either early loading through initrd/built-in or a potential BIOS update.\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic enum ucode_state request_microcode_fw(int cpu, struct device *device)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tconst struct firmware *firmware;\n\tstruct iov_iter iter;\n\tenum ucode_state ret;\n\tstruct kvec kvec;\n\tchar name[30];\n\n\tif (is_blacklisted(cpu))\n\t\treturn UCODE_NFOUND;\n\n\tsprintf(name, \"intel-ucode/%02x-%02x-%02x\",\n\t\tc->x86, c->x86_model, c->x86_stepping);\n\n\tif (request_firmware_direct(&firmware, name, device)) {\n\t\tpr_debug(\"data file %s load failed\\n\", name);\n\t\treturn UCODE_NFOUND;\n\t}\n\n\tkvec.iov_base = (void *)firmware->data;\n\tkvec.iov_len = firmware->size;\n\tiov_iter_kvec(&iter, ITER_SOURCE, &kvec, 1, firmware->size);\n\tret = generic_load_microcode(cpu, &iter);\n\n\trelease_firmware(firmware);\n\n\treturn ret;\n}\n\nstatic struct microcode_ops microcode_intel_ops = {\n\t.request_microcode_fw             = request_microcode_fw,\n\t.collect_cpu_info                 = collect_cpu_info,\n\t.apply_microcode                  = apply_microcode_intel,\n};\n\nstatic int __init calc_llc_size_per_core(struct cpuinfo_x86 *c)\n{\n\tu64 llc_size = c->x86_cache_size * 1024ULL;\n\n\tdo_div(llc_size, c->x86_max_cores);\n\n\treturn (int)llc_size;\n}\n\nstruct microcode_ops * __init init_intel_microcode(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\tif (c->x86_vendor != X86_VENDOR_INTEL || c->x86 < 6 ||\n\t    cpu_has(c, X86_FEATURE_IA64)) {\n\t\tpr_err(\"Intel CPU family 0x%x not supported\\n\", c->x86);\n\t\treturn NULL;\n\t}\n\n\tllc_size_per_core = calc_llc_size_per_core(c);\n\n\treturn &microcode_intel_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}