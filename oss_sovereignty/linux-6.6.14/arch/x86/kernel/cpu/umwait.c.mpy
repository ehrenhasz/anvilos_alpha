{
  "module_name": "umwait.c",
  "hash_id": "421e148b066693618fc0d05fb53246d9377e0e2fd9876bd9d129fd9dcb362e33",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/umwait.c",
  "human_readable_source": "\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/cpu.h>\n\n#include <asm/msr.h>\n#include <asm/mwait.h>\n\n#define UMWAIT_C02_ENABLE\t0\n\n#define UMWAIT_CTRL_VAL(max_time, c02_disable)\t\t\t\t\\\n\t(((max_time) & MSR_IA32_UMWAIT_CONTROL_TIME_MASK) |\t\t\\\n\t((c02_disable) & MSR_IA32_UMWAIT_CONTROL_C02_DISABLE))\n\n \nstatic u32 umwait_control_cached = UMWAIT_CTRL_VAL(100000, UMWAIT_C02_ENABLE);\n\n \nstatic u32 orig_umwait_control_cached __ro_after_init;\n\n \nstatic DEFINE_MUTEX(umwait_lock);\n\nstatic void umwait_update_control_msr(void * unused)\n{\n\tlockdep_assert_irqs_disabled();\n\twrmsr(MSR_IA32_UMWAIT_CONTROL, READ_ONCE(umwait_control_cached), 0);\n}\n\n \nstatic int umwait_cpu_online(unsigned int cpu)\n{\n\tlocal_irq_disable();\n\tumwait_update_control_msr(NULL);\n\tlocal_irq_enable();\n\treturn 0;\n}\n\n \nstatic int umwait_cpu_offline(unsigned int cpu)\n{\n\t \n\twrmsr(MSR_IA32_UMWAIT_CONTROL, orig_umwait_control_cached, 0);\n\n\treturn 0;\n}\n\n \nstatic void umwait_syscore_resume(void)\n{\n\tumwait_update_control_msr(NULL);\n}\n\nstatic struct syscore_ops umwait_syscore_ops = {\n\t.resume\t= umwait_syscore_resume,\n};\n\n \n\n \nstatic inline bool umwait_ctrl_c02_enabled(u32 ctrl)\n{\n\treturn !(ctrl & MSR_IA32_UMWAIT_CONTROL_C02_DISABLE);\n}\n\nstatic inline u32 umwait_ctrl_max_time(u32 ctrl)\n{\n\treturn ctrl & MSR_IA32_UMWAIT_CONTROL_TIME_MASK;\n}\n\nstatic inline void umwait_update_control(u32 maxtime, bool c02_enable)\n{\n\tu32 ctrl = maxtime & MSR_IA32_UMWAIT_CONTROL_TIME_MASK;\n\n\tif (!c02_enable)\n\t\tctrl |= MSR_IA32_UMWAIT_CONTROL_C02_DISABLE;\n\n\tWRITE_ONCE(umwait_control_cached, ctrl);\n\t \n\ton_each_cpu(umwait_update_control_msr, NULL, 1);\n}\n\nstatic ssize_t\nenable_c02_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tu32 ctrl = READ_ONCE(umwait_control_cached);\n\n\treturn sprintf(buf, \"%d\\n\", umwait_ctrl_c02_enabled(ctrl));\n}\n\nstatic ssize_t enable_c02_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tbool c02_enable;\n\tu32 ctrl;\n\tint ret;\n\n\tret = kstrtobool(buf, &c02_enable);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&umwait_lock);\n\n\tctrl = READ_ONCE(umwait_control_cached);\n\tif (c02_enable != umwait_ctrl_c02_enabled(ctrl))\n\t\tumwait_update_control(ctrl, c02_enable);\n\n\tmutex_unlock(&umwait_lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(enable_c02);\n\nstatic ssize_t\nmax_time_show(struct device *kobj, struct device_attribute *attr, char *buf)\n{\n\tu32 ctrl = READ_ONCE(umwait_control_cached);\n\n\treturn sprintf(buf, \"%u\\n\", umwait_ctrl_max_time(ctrl));\n}\n\nstatic ssize_t max_time_store(struct device *kobj,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tu32 max_time, ctrl;\n\tint ret;\n\n\tret = kstrtou32(buf, 0, &max_time);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (max_time & ~MSR_IA32_UMWAIT_CONTROL_TIME_MASK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&umwait_lock);\n\n\tctrl = READ_ONCE(umwait_control_cached);\n\tif (max_time != umwait_ctrl_max_time(ctrl))\n\t\tumwait_update_control(max_time, umwait_ctrl_c02_enabled(ctrl));\n\n\tmutex_unlock(&umwait_lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(max_time);\n\nstatic struct attribute *umwait_attrs[] = {\n\t&dev_attr_enable_c02.attr,\n\t&dev_attr_max_time.attr,\n\tNULL\n};\n\nstatic struct attribute_group umwait_attr_group = {\n\t.attrs = umwait_attrs,\n\t.name = \"umwait_control\",\n};\n\nstatic int __init umwait_init(void)\n{\n\tstruct device *dev;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_WAITPKG))\n\t\treturn -ENODEV;\n\n\t \n\trdmsrl(MSR_IA32_UMWAIT_CONTROL, orig_umwait_control_cached);\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"umwait:online\",\n\t\t\t\tumwait_cpu_online, umwait_cpu_offline);\n\tif (ret < 0) {\n\t\t \n\t\treturn ret;\n\t}\n\n\tregister_syscore_ops(&umwait_syscore_ops);\n\n\t \n\tdev = bus_get_dev_root(&cpu_subsys);\n\tif (dev) {\n\t\tret = sysfs_create_group(&dev->kobj, &umwait_attr_group);\n\t\tput_device(dev);\n\t}\n\treturn ret;\n}\ndevice_initcall(umwait_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}