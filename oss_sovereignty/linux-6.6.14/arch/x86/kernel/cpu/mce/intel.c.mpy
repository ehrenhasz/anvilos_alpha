{
  "module_name": "intel.c",
  "hash_id": "d2f1ec0dc3db549789d193ff03aeac076dd164a876ab47d2d10c72a534e2822a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/intel.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/cpumask.h>\n#include <asm/apic.h>\n#include <asm/cpufeature.h>\n#include <asm/intel-family.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/mce.h>\n\n#include \"internal.h\"\n\n \n\n \nstatic DEFINE_PER_CPU(mce_banks_t, mce_banks_owned);\n\n \nstatic DEFINE_PER_CPU(int, cmci_backoff_cnt);\n\n \nstatic DEFINE_RAW_SPINLOCK(cmci_discover_lock);\n\n \nstatic DEFINE_SPINLOCK(cmci_poll_lock);\n\n#define CMCI_THRESHOLD\t\t1\n#define CMCI_POLL_INTERVAL\t(30 * HZ)\n#define CMCI_STORM_INTERVAL\t(HZ)\n#define CMCI_STORM_THRESHOLD\t15\n\nstatic DEFINE_PER_CPU(unsigned long, cmci_time_stamp);\nstatic DEFINE_PER_CPU(unsigned int, cmci_storm_cnt);\nstatic DEFINE_PER_CPU(unsigned int, cmci_storm_state);\n\nenum {\n\tCMCI_STORM_NONE,\n\tCMCI_STORM_ACTIVE,\n\tCMCI_STORM_SUBSIDED,\n};\n\nstatic atomic_t cmci_storm_on_cpus;\n\nstatic int cmci_supported(int *banks)\n{\n\tu64 cap;\n\n\tif (mca_cfg.cmci_disabled || mca_cfg.ignore_ce)\n\t\treturn 0;\n\n\t \n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86_vendor != X86_VENDOR_ZHAOXIN)\n\t\treturn 0;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC) || lapic_get_maxlvt() < 6)\n\t\treturn 0;\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\t*banks = min_t(unsigned, MAX_NR_BANKS, cap & 0xff);\n\treturn !!(cap & MCG_CMCI_P);\n}\n\nstatic bool lmce_supported(void)\n{\n\tu64 tmp;\n\n\tif (mca_cfg.lmce_disabled)\n\t\treturn false;\n\n\trdmsrl(MSR_IA32_MCG_CAP, tmp);\n\n\t \n\tif ((tmp & (MCG_SER_P | MCG_LMCE_P)) !=\n\t\t   (MCG_SER_P | MCG_LMCE_P))\n\t\treturn false;\n\n\t \n\trdmsrl(MSR_IA32_FEAT_CTL, tmp);\n\tif (WARN_ON_ONCE(!(tmp & FEAT_CTL_LOCKED)))\n\t\treturn false;\n\n\treturn tmp & FEAT_CTL_LMCE_ENABLED;\n}\n\nbool mce_intel_cmci_poll(void)\n{\n\tif (__this_cpu_read(cmci_storm_state) == CMCI_STORM_NONE)\n\t\treturn false;\n\n\t \n\tif (machine_check_poll(0, this_cpu_ptr(&mce_banks_owned)))\n\t\tthis_cpu_write(cmci_backoff_cnt, INITIAL_CHECK_INTERVAL);\n\telse\n\t\tthis_cpu_dec(cmci_backoff_cnt);\n\n\treturn true;\n}\n\nvoid mce_intel_hcpu_update(unsigned long cpu)\n{\n\tif (per_cpu(cmci_storm_state, cpu) == CMCI_STORM_ACTIVE)\n\t\tatomic_dec(&cmci_storm_on_cpus);\n\n\tper_cpu(cmci_storm_state, cpu) = CMCI_STORM_NONE;\n}\n\nstatic void cmci_toggle_interrupt_mode(bool on)\n{\n\tunsigned long flags, *owned;\n\tint bank;\n\tu64 val;\n\n\traw_spin_lock_irqsave(&cmci_discover_lock, flags);\n\towned = this_cpu_ptr(mce_banks_owned);\n\tfor_each_set_bit(bank, owned, MAX_NR_BANKS) {\n\t\trdmsrl(MSR_IA32_MCx_CTL2(bank), val);\n\n\t\tif (on)\n\t\t\tval |= MCI_CTL2_CMCI_EN;\n\t\telse\n\t\t\tval &= ~MCI_CTL2_CMCI_EN;\n\n\t\twrmsrl(MSR_IA32_MCx_CTL2(bank), val);\n\t}\n\traw_spin_unlock_irqrestore(&cmci_discover_lock, flags);\n}\n\nunsigned long cmci_intel_adjust_timer(unsigned long interval)\n{\n\tif ((this_cpu_read(cmci_backoff_cnt) > 0) &&\n\t    (__this_cpu_read(cmci_storm_state) == CMCI_STORM_ACTIVE)) {\n\t\tmce_notify_irq();\n\t\treturn CMCI_STORM_INTERVAL;\n\t}\n\n\tswitch (__this_cpu_read(cmci_storm_state)) {\n\tcase CMCI_STORM_ACTIVE:\n\n\t\t \n\t\t__this_cpu_write(cmci_storm_state, CMCI_STORM_SUBSIDED);\n\t\tif (!atomic_sub_return(1, &cmci_storm_on_cpus))\n\t\t\tpr_notice(\"CMCI storm subsided: switching to interrupt mode\\n\");\n\n\t\tfallthrough;\n\n\tcase CMCI_STORM_SUBSIDED:\n\t\t \n\t\tif (!atomic_read(&cmci_storm_on_cpus)) {\n\t\t\t__this_cpu_write(cmci_storm_state, CMCI_STORM_NONE);\n\t\t\tcmci_toggle_interrupt_mode(true);\n\t\t\tcmci_recheck();\n\t\t}\n\t\treturn CMCI_POLL_INTERVAL;\n\tdefault:\n\n\t\t \n\t\treturn interval;\n\t}\n}\n\nstatic bool cmci_storm_detect(void)\n{\n\tunsigned int cnt = __this_cpu_read(cmci_storm_cnt);\n\tunsigned long ts = __this_cpu_read(cmci_time_stamp);\n\tunsigned long now = jiffies;\n\tint r;\n\n\tif (__this_cpu_read(cmci_storm_state) != CMCI_STORM_NONE)\n\t\treturn true;\n\n\tif (time_before_eq(now, ts + CMCI_STORM_INTERVAL)) {\n\t\tcnt++;\n\t} else {\n\t\tcnt = 1;\n\t\t__this_cpu_write(cmci_time_stamp, now);\n\t}\n\t__this_cpu_write(cmci_storm_cnt, cnt);\n\n\tif (cnt <= CMCI_STORM_THRESHOLD)\n\t\treturn false;\n\n\tcmci_toggle_interrupt_mode(false);\n\t__this_cpu_write(cmci_storm_state, CMCI_STORM_ACTIVE);\n\tr = atomic_add_return(1, &cmci_storm_on_cpus);\n\tmce_timer_kick(CMCI_STORM_INTERVAL);\n\tthis_cpu_write(cmci_backoff_cnt, INITIAL_CHECK_INTERVAL);\n\n\tif (r == 1)\n\t\tpr_notice(\"CMCI storm detected: switching to poll mode\\n\");\n\treturn true;\n}\n\n \nstatic void intel_threshold_interrupt(void)\n{\n\tif (cmci_storm_detect())\n\t\treturn;\n\n\tmachine_check_poll(MCP_TIMESTAMP, this_cpu_ptr(&mce_banks_owned));\n}\n\n \nstatic void cmci_discover(int banks)\n{\n\tunsigned long *owned = (void *)this_cpu_ptr(&mce_banks_owned);\n\tunsigned long flags;\n\tint i;\n\tint bios_wrong_thresh = 0;\n\n\traw_spin_lock_irqsave(&cmci_discover_lock, flags);\n\tfor (i = 0; i < banks; i++) {\n\t\tu64 val;\n\t\tint bios_zero_thresh = 0;\n\n\t\tif (test_bit(i, owned))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(i, mce_banks_ce_disabled))\n\t\t\tcontinue;\n\n\t\trdmsrl(MSR_IA32_MCx_CTL2(i), val);\n\n\t\t \n\t\tif (val & MCI_CTL2_CMCI_EN) {\n\t\t\tclear_bit(i, owned);\n\t\t\t__clear_bit(i, this_cpu_ptr(mce_poll_banks));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mca_cfg.bios_cmci_threshold) {\n\t\t\tval &= ~MCI_CTL2_CMCI_THRESHOLD_MASK;\n\t\t\tval |= CMCI_THRESHOLD;\n\t\t} else if (!(val & MCI_CTL2_CMCI_THRESHOLD_MASK)) {\n\t\t\t \n\t\t\tbios_zero_thresh = 1;\n\t\t\tval |= CMCI_THRESHOLD;\n\t\t}\n\n\t\tval |= MCI_CTL2_CMCI_EN;\n\t\twrmsrl(MSR_IA32_MCx_CTL2(i), val);\n\t\trdmsrl(MSR_IA32_MCx_CTL2(i), val);\n\n\t\t \n\t\tif (val & MCI_CTL2_CMCI_EN) {\n\t\t\tset_bit(i, owned);\n\t\t\t__clear_bit(i, this_cpu_ptr(mce_poll_banks));\n\t\t\t \n\t\t\tif (mca_cfg.bios_cmci_threshold && bios_zero_thresh &&\n\t\t\t\t\t(val & MCI_CTL2_CMCI_THRESHOLD_MASK))\n\t\t\t\tbios_wrong_thresh = 1;\n\t\t} else {\n\t\t\tWARN_ON(!test_bit(i, this_cpu_ptr(mce_poll_banks)));\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&cmci_discover_lock, flags);\n\tif (mca_cfg.bios_cmci_threshold && bios_wrong_thresh) {\n\t\tpr_info_once(\n\t\t\t\"bios_cmci_threshold: Some banks do not have valid thresholds set\\n\");\n\t\tpr_info_once(\n\t\t\t\"bios_cmci_threshold: Make sure your BIOS supports this boot option\\n\");\n\t}\n}\n\n \nvoid cmci_recheck(void)\n{\n\tunsigned long flags;\n\tint banks;\n\n\tif (!mce_available(raw_cpu_ptr(&cpu_info)) || !cmci_supported(&banks))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tmachine_check_poll(0, this_cpu_ptr(&mce_banks_owned));\n\tlocal_irq_restore(flags);\n}\n\n \nstatic void __cmci_disable_bank(int bank)\n{\n\tu64 val;\n\n\tif (!test_bit(bank, this_cpu_ptr(mce_banks_owned)))\n\t\treturn;\n\trdmsrl(MSR_IA32_MCx_CTL2(bank), val);\n\tval &= ~MCI_CTL2_CMCI_EN;\n\twrmsrl(MSR_IA32_MCx_CTL2(bank), val);\n\t__clear_bit(bank, this_cpu_ptr(mce_banks_owned));\n}\n\n \nvoid cmci_clear(void)\n{\n\tunsigned long flags;\n\tint i;\n\tint banks;\n\n\tif (!cmci_supported(&banks))\n\t\treturn;\n\traw_spin_lock_irqsave(&cmci_discover_lock, flags);\n\tfor (i = 0; i < banks; i++)\n\t\t__cmci_disable_bank(i);\n\traw_spin_unlock_irqrestore(&cmci_discover_lock, flags);\n}\n\nstatic void cmci_rediscover_work_func(void *arg)\n{\n\tint banks;\n\n\t \n\tif (cmci_supported(&banks))\n\t\tcmci_discover(banks);\n}\n\n \nvoid cmci_rediscover(void)\n{\n\tint banks;\n\n\tif (!cmci_supported(&banks))\n\t\treturn;\n\n\ton_each_cpu(cmci_rediscover_work_func, NULL, 1);\n}\n\n \nvoid cmci_reenable(void)\n{\n\tint banks;\n\tif (cmci_supported(&banks))\n\t\tcmci_discover(banks);\n}\n\nvoid cmci_disable_bank(int bank)\n{\n\tint banks;\n\tunsigned long flags;\n\n\tif (!cmci_supported(&banks))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&cmci_discover_lock, flags);\n\t__cmci_disable_bank(bank);\n\traw_spin_unlock_irqrestore(&cmci_discover_lock, flags);\n}\n\n \nstatic void cmci_mc_poll_banks(void)\n{\n\tspin_lock(&cmci_poll_lock);\n\tmachine_check_poll(0, this_cpu_ptr(&mce_poll_banks));\n\tspin_unlock(&cmci_poll_lock);\n}\n\nvoid intel_init_cmci(void)\n{\n\tint banks;\n\n\tif (!cmci_supported(&banks)) {\n\t\tmc_poll_banks = cmci_mc_poll_banks;\n\t\treturn;\n\t}\n\n\tmce_threshold_vector = intel_threshold_interrupt;\n\tcmci_discover(banks);\n\t \n\tapic_write(APIC_LVTCMCI, THRESHOLD_APIC_VECTOR|APIC_DM_FIXED);\n\tcmci_recheck();\n}\n\nvoid intel_init_lmce(void)\n{\n\tu64 val;\n\n\tif (!lmce_supported())\n\t\treturn;\n\n\trdmsrl(MSR_IA32_MCG_EXT_CTL, val);\n\n\tif (!(val & MCG_EXT_CTL_LMCE_EN))\n\t\twrmsrl(MSR_IA32_MCG_EXT_CTL, val | MCG_EXT_CTL_LMCE_EN);\n}\n\nvoid intel_clear_lmce(void)\n{\n\tu64 val;\n\n\tif (!lmce_supported())\n\t\treturn;\n\n\trdmsrl(MSR_IA32_MCG_EXT_CTL, val);\n\tval &= ~MCG_EXT_CTL_LMCE_EN;\n\twrmsrl(MSR_IA32_MCG_EXT_CTL, val);\n}\n\n \nstatic void intel_imc_init(struct cpuinfo_x86 *c)\n{\n\tu64 error_control;\n\n\tswitch (c->x86_model) {\n\tcase INTEL_FAM6_SANDYBRIDGE_X:\n\tcase INTEL_FAM6_IVYBRIDGE_X:\n\tcase INTEL_FAM6_HASWELL_X:\n\t\tif (rdmsrl_safe(MSR_ERROR_CONTROL, &error_control))\n\t\t\treturn;\n\t\terror_control |= 2;\n\t\twrmsrl_safe(MSR_ERROR_CONTROL, error_control);\n\t\tbreak;\n\t}\n}\n\nvoid mce_intel_feature_init(struct cpuinfo_x86 *c)\n{\n\tintel_init_cmci();\n\tintel_init_lmce();\n\tintel_imc_init(c);\n}\n\nvoid mce_intel_feature_clear(struct cpuinfo_x86 *c)\n{\n\tintel_clear_lmce();\n}\n\nbool intel_filter_mce(struct mce *m)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\t \n\tif ((c->x86 == 6) &&\n\t    ((c->x86_model == INTEL_FAM6_HASWELL) ||\n\t     (c->x86_model == INTEL_FAM6_HASWELL_L) ||\n\t     (c->x86_model == INTEL_FAM6_BROADWELL) ||\n\t     (c->x86_model == INTEL_FAM6_HASWELL_G) ||\n\t     (c->x86_model == INTEL_FAM6_SKYLAKE_X)) &&\n\t    (m->bank == 0) &&\n\t    ((m->status & 0xa0000000ffffffff) == 0x80000000000f0005))\n\t\treturn true;\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}