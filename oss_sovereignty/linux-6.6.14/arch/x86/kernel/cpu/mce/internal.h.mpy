{
  "module_name": "internal.h",
  "hash_id": "baa0c6e1ca77fde91f15adc82624f2a1b5e14b965ab62a7ce043c9b98a75bb7c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/internal.h",
  "human_readable_source": " \n#ifndef __X86_MCE_INTERNAL_H__\n#define __X86_MCE_INTERNAL_H__\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"mce: \" fmt\n\n#include <linux/device.h>\n#include <asm/mce.h>\n\nenum severity_level {\n\tMCE_NO_SEVERITY,\n\tMCE_DEFERRED_SEVERITY,\n\tMCE_UCNA_SEVERITY = MCE_DEFERRED_SEVERITY,\n\tMCE_KEEP_SEVERITY,\n\tMCE_SOME_SEVERITY,\n\tMCE_AO_SEVERITY,\n\tMCE_UC_SEVERITY,\n\tMCE_AR_SEVERITY,\n\tMCE_PANIC_SEVERITY,\n};\n\nextern struct blocking_notifier_head x86_mce_decoder_chain;\n\n#define INITIAL_CHECK_INTERVAL\t5 * 60  \n\nstruct mce_evt_llist {\n\tstruct llist_node llnode;\n\tstruct mce mce;\n};\n\nvoid mce_gen_pool_process(struct work_struct *__unused);\nbool mce_gen_pool_empty(void);\nint mce_gen_pool_add(struct mce *mce);\nint mce_gen_pool_init(void);\nstruct llist_node *mce_gen_pool_prepare_records(void);\n\nint mce_severity(struct mce *a, struct pt_regs *regs, char **msg, bool is_excp);\nstruct dentry *mce_get_debugfs_dir(void);\n\nextern mce_banks_t mce_banks_ce_disabled;\n\n#ifdef CONFIG_X86_MCE_INTEL\nunsigned long cmci_intel_adjust_timer(unsigned long interval);\nbool mce_intel_cmci_poll(void);\nvoid mce_intel_hcpu_update(unsigned long cpu);\nvoid cmci_disable_bank(int bank);\nvoid intel_init_cmci(void);\nvoid intel_init_lmce(void);\nvoid intel_clear_lmce(void);\nbool intel_filter_mce(struct mce *m);\n#else\n# define cmci_intel_adjust_timer mce_adjust_timer_default\nstatic inline bool mce_intel_cmci_poll(void) { return false; }\nstatic inline void mce_intel_hcpu_update(unsigned long cpu) { }\nstatic inline void cmci_disable_bank(int bank) { }\nstatic inline void intel_init_cmci(void) { }\nstatic inline void intel_init_lmce(void) { }\nstatic inline void intel_clear_lmce(void) { }\nstatic inline bool intel_filter_mce(struct mce *m) { return false; }\n#endif\n\nvoid mce_timer_kick(unsigned long interval);\n\n#ifdef CONFIG_ACPI_APEI\nint apei_write_mce(struct mce *m);\nssize_t apei_read_mce(struct mce *m, u64 *record_id);\nint apei_check_mce(void);\nint apei_clear_mce(u64 record_id);\n#else\nstatic inline int apei_write_mce(struct mce *m)\n{\n\treturn -EINVAL;\n}\nstatic inline ssize_t apei_read_mce(struct mce *m, u64 *record_id)\n{\n\treturn 0;\n}\nstatic inline int apei_check_mce(void)\n{\n\treturn 0;\n}\nstatic inline int apei_clear_mce(u64 record_id)\n{\n\treturn -EINVAL;\n}\n#endif\n\n \nstatic inline bool mce_cmp(struct mce *m1, struct mce *m2)\n{\n\treturn m1->bank != m2->bank ||\n\t\tm1->status != m2->status ||\n\t\tm1->addr != m2->addr ||\n\t\tm1->misc != m2->misc;\n}\n\nextern struct device_attribute dev_attr_trigger;\n\n#ifdef CONFIG_X86_MCELOG_LEGACY\nvoid mce_work_trigger(void);\nvoid mce_register_injector_chain(struct notifier_block *nb);\nvoid mce_unregister_injector_chain(struct notifier_block *nb);\n#else\nstatic inline void mce_work_trigger(void)\t{ }\nstatic inline void mce_register_injector_chain(struct notifier_block *nb)\t{ }\nstatic inline void mce_unregister_injector_chain(struct notifier_block *nb)\t{ }\n#endif\n\nstruct mca_config {\n\t__u64 lmce_disabled\t\t: 1,\n\t      disabled\t\t\t: 1,\n\t      ser\t\t\t: 1,\n\t      recovery\t\t\t: 1,\n\t      bios_cmci_threshold\t: 1,\n\t       \n\t      initialized\t\t: 1,\n\t      __reserved\t\t: 58;\n\n\tbool dont_log_ce;\n\tbool cmci_disabled;\n\tbool ignore_ce;\n\tbool print_all;\n\n\tint monarch_timeout;\n\tint panic_timeout;\n\tu32 rip_msr;\n\ts8 bootlog;\n};\n\nextern struct mca_config mca_cfg;\nDECLARE_PER_CPU_READ_MOSTLY(unsigned int, mce_num_banks);\n\nstruct mce_vendor_flags {\n\t \n\t__u64 overflow_recov\t: 1,\n\n\t \n\tsuccor\t\t\t: 1,\n\n\t \n\tsmca\t\t\t: 1,\n\n\t \n\tzen_ifu_quirk\t\t: 1,\n\n\t \n\tamd_threshold\t\t: 1,\n\n\t \n\tp5\t\t\t: 1,\n\n\t \n\twinchip\t\t\t: 1,\n\n\t \n\tsnb_ifu_quirk\t\t: 1,\n\n\t \n\tskx_repmov_quirk\t: 1,\n\n\t__reserved_0\t\t: 55;\n};\n\nextern struct mce_vendor_flags mce_flags;\n\nstruct mce_bank {\n\t \n\tu64\t\t\tctl;\n\n\t \n\t__u64 init\t\t: 1,\n\n\t \n\tlsb_in_status\t\t: 1,\n\n\t__reserved_1\t\t: 62;\n};\n\nDECLARE_PER_CPU_READ_MOSTLY(struct mce_bank[MAX_NR_BANKS], mce_banks_array);\n\nenum mca_msr {\n\tMCA_CTL,\n\tMCA_STATUS,\n\tMCA_ADDR,\n\tMCA_MISC,\n};\n\n \nextern bool filter_mce(struct mce *m);\n\n#ifdef CONFIG_X86_MCE_AMD\nextern bool amd_filter_mce(struct mce *m);\n\n \nstatic __always_inline void smca_extract_err_addr(struct mce *m)\n{\n\tu8 lsb;\n\n\tif (!mce_flags.smca)\n\t\treturn;\n\n\tif (this_cpu_ptr(mce_banks_array)[m->bank].lsb_in_status) {\n\t\tlsb = (m->status >> 24) & 0x3f;\n\n\t\tm->addr &= GENMASK_ULL(56, lsb);\n\n\t\treturn;\n\t}\n\n\tlsb = (m->addr >> 56) & 0x3f;\n\n\tm->addr &= GENMASK_ULL(55, lsb);\n}\n\n#else\nstatic inline bool amd_filter_mce(struct mce *m) { return false; }\nstatic inline void smca_extract_err_addr(struct mce *m) { }\n#endif\n\n#ifdef CONFIG_X86_ANCIENT_MCE\nvoid intel_p5_mcheck_init(struct cpuinfo_x86 *c);\nvoid winchip_mcheck_init(struct cpuinfo_x86 *c);\nnoinstr void pentium_machine_check(struct pt_regs *regs);\nnoinstr void winchip_machine_check(struct pt_regs *regs);\nstatic inline void enable_p5_mce(void) { mce_p5_enabled = 1; }\n#else\nstatic __always_inline void intel_p5_mcheck_init(struct cpuinfo_x86 *c) {}\nstatic __always_inline void winchip_mcheck_init(struct cpuinfo_x86 *c) {}\nstatic __always_inline void enable_p5_mce(void) {}\nstatic __always_inline void pentium_machine_check(struct pt_regs *regs) {}\nstatic __always_inline void winchip_machine_check(struct pt_regs *regs) {}\n#endif\n\nnoinstr u64 mce_rdmsrl(u32 msr);\n\nstatic __always_inline u32 mca_msr_reg(int bank, enum mca_msr reg)\n{\n\tif (cpu_feature_enabled(X86_FEATURE_SMCA)) {\n\t\tswitch (reg) {\n\t\tcase MCA_CTL:\t return MSR_AMD64_SMCA_MCx_CTL(bank);\n\t\tcase MCA_ADDR:\t return MSR_AMD64_SMCA_MCx_ADDR(bank);\n\t\tcase MCA_MISC:\t return MSR_AMD64_SMCA_MCx_MISC(bank);\n\t\tcase MCA_STATUS: return MSR_AMD64_SMCA_MCx_STATUS(bank);\n\t\t}\n\t}\n\n\tswitch (reg) {\n\tcase MCA_CTL:\t return MSR_IA32_MCx_CTL(bank);\n\tcase MCA_ADDR:\t return MSR_IA32_MCx_ADDR(bank);\n\tcase MCA_MISC:\t return MSR_IA32_MCx_MISC(bank);\n\tcase MCA_STATUS: return MSR_IA32_MCx_STATUS(bank);\n\t}\n\n\treturn 0;\n}\n\nextern void (*mc_poll_banks)(void);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}