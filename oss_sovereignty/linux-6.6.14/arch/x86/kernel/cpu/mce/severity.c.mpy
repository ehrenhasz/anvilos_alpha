{
  "module_name": "severity.c",
  "hash_id": "4849d950c74ba186005c264ed6628be922809615ba24ef3f367e8e6b3f429c83",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/severity.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n\n#include <asm/mce.h>\n#include <asm/intel-family.h>\n#include <asm/traps.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n\n#include \"internal.h\"\n\n \n\nenum context { IN_KERNEL = 1, IN_USER = 2, IN_KERNEL_RECOV = 3 };\nenum ser { SER_REQUIRED = 1, NO_SER = 2 };\nenum exception { EXCP_CONTEXT = 1, NO_EXCP = 2 };\n\nstatic struct severity {\n\tu64 mask;\n\tu64 result;\n\tunsigned char sev;\n\tunsigned char mcgmask;\n\tunsigned char mcgres;\n\tunsigned char ser;\n\tunsigned char context;\n\tunsigned char excp;\n\tunsigned char covered;\n\tunsigned char cpu_model;\n\tunsigned char cpu_minstepping;\n\tunsigned char bank_lo, bank_hi;\n\tchar *msg;\n} severities[] = {\n#define MCESEV(s, m, c...) { .sev = MCE_ ## s ## _SEVERITY, .msg = m, ## c }\n#define BANK_RANGE(l, h) .bank_lo = l, .bank_hi = h\n#define MODEL_STEPPING(m, s) .cpu_model = m, .cpu_minstepping = s\n#define  KERNEL\t\t.context = IN_KERNEL\n#define  USER\t\t.context = IN_USER\n#define  KERNEL_RECOV\t.context = IN_KERNEL_RECOV\n#define  SER\t\t.ser = SER_REQUIRED\n#define  NOSER\t\t.ser = NO_SER\n#define  EXCP\t\t.excp = EXCP_CONTEXT\n#define  NOEXCP\t\t.excp = NO_EXCP\n#define  BITCLR(x)\t.mask = x, .result = 0\n#define  BITSET(x)\t.mask = x, .result = x\n#define  MCGMASK(x, y)\t.mcgmask = x, .mcgres = y\n#define  MASK(x, y)\t.mask = x, .result = y\n#define MCI_UC_S (MCI_STATUS_UC|MCI_STATUS_S)\n#define MCI_UC_AR (MCI_STATUS_UC|MCI_STATUS_AR)\n#define MCI_UC_SAR (MCI_STATUS_UC|MCI_STATUS_S|MCI_STATUS_AR)\n#define\tMCI_ADDR (MCI_STATUS_ADDRV|MCI_STATUS_MISCV)\n\n\tMCESEV(\n\t\tNO, \"Invalid\",\n\t\tBITCLR(MCI_STATUS_VAL)\n\t\t),\n\tMCESEV(\n\t\tNO, \"Not enabled\",\n\t\tEXCP, BITCLR(MCI_STATUS_EN)\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"Processor context corrupt\",\n\t\tBITSET(MCI_STATUS_PCC)\n\t\t),\n\t \n\tMCESEV(\n\t\tPANIC, \"MCIP not set in MCA handler\",\n\t\tEXCP, MCGMASK(MCG_STATUS_MCIP, 0)\n\t\t),\n\t \n\tMCESEV(\n\t\tPANIC, \"Neither restart nor error IP\",\n\t\tEXCP, MCGMASK(MCG_STATUS_RIPV|MCG_STATUS_EIPV, 0)\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"In kernel and no restart IP\",\n\t\tEXCP, KERNEL, MCGMASK(MCG_STATUS_RIPV, 0)\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"In kernel and no restart IP\",\n\t\tEXCP, KERNEL_RECOV, MCGMASK(MCG_STATUS_RIPV, 0)\n\t\t),\n\tMCESEV(\n\t\tKEEP, \"Corrected error\",\n\t\tNOSER, BITCLR(MCI_STATUS_UC)\n\t\t),\n\t \n\tMCESEV(\n\t\tAO, \"Action optional: memory scrubbing error\",\n\t\tSER, MASK(MCI_UC_AR|MCACOD_SCRUBMSK, MCI_STATUS_UC|MCACOD_SCRUB)\n\t\t),\n\tMCESEV(\n\t\tAO, \"Action optional: last level cache writeback error\",\n\t\tSER, MASK(MCI_UC_AR|MCACOD, MCI_STATUS_UC|MCACOD_L3WB)\n\t\t),\n\t \n\tMCESEV(\n\t\tAO, \"Uncorrected Patrol Scrub Error\",\n\t\tSER, MASK(MCI_STATUS_UC|MCI_ADDR|0xffffeff0, MCI_ADDR|0x001000c0),\n\t\tMODEL_STEPPING(INTEL_FAM6_SKYLAKE_X, 4), BANK_RANGE(13, 18)\n\t),\n\n\t \n\tMCESEV(\n\t\tUCNA, \"Uncorrected no action required\",\n\t\tSER, MASK(MCI_UC_SAR, MCI_STATUS_UC)\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"Illegal combination (UCNA with AR=1)\",\n\t\tSER,\n\t\tMASK(MCI_STATUS_OVER|MCI_UC_SAR, MCI_STATUS_UC|MCI_STATUS_AR)\n\t\t),\n\tMCESEV(\n\t\tKEEP, \"Non signaled machine check\",\n\t\tSER, BITCLR(MCI_STATUS_S)\n\t\t),\n\n\tMCESEV(\n\t\tPANIC, \"Action required with lost events\",\n\t\tSER, BITSET(MCI_STATUS_OVER|MCI_UC_SAR)\n\t\t),\n\n\t \n#ifdef\tCONFIG_MEMORY_FAILURE\n\tMCESEV(\n\t\tKEEP, \"Action required but unaffected thread is continuable\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR, MCI_UC_SAR|MCI_ADDR),\n\t\tMCGMASK(MCG_STATUS_RIPV|MCG_STATUS_EIPV, MCG_STATUS_RIPV)\n\t\t),\n\tMCESEV(\n\t\tAR, \"Action required: data load in error recoverable area of kernel\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR|MCACOD, MCI_UC_SAR|MCI_ADDR|MCACOD_DATA),\n\t\tKERNEL_RECOV\n\t\t),\n\tMCESEV(\n\t\tAR, \"Action required: data load error in a user process\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR|MCACOD, MCI_UC_SAR|MCI_ADDR|MCACOD_DATA),\n\t\tUSER\n\t\t),\n\tMCESEV(\n\t\tAR, \"Action required: instruction fetch error in a user process\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR|MCACOD, MCI_UC_SAR|MCI_ADDR|MCACOD_INSTR),\n\t\tUSER\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"Data load in unrecoverable area of kernel\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR|MCACOD, MCI_UC_SAR|MCI_ADDR|MCACOD_DATA),\n\t\tKERNEL\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"Instruction fetch error in kernel\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR|MCI_ADDR|MCACOD, MCI_UC_SAR|MCI_ADDR|MCACOD_INSTR),\n\t\tKERNEL\n\t\t),\n#endif\n\tMCESEV(\n\t\tPANIC, \"Action required: unknown MCACOD\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR, MCI_UC_SAR)\n\t\t),\n\n\tMCESEV(\n\t\tSOME, \"Action optional: unknown MCACOD\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR, MCI_UC_S)\n\t\t),\n\tMCESEV(\n\t\tSOME, \"Action optional with lost events\",\n\t\tSER, MASK(MCI_STATUS_OVER|MCI_UC_SAR, MCI_STATUS_OVER|MCI_UC_S)\n\t\t),\n\n\tMCESEV(\n\t\tPANIC, \"Overflowed uncorrected\",\n\t\tBITSET(MCI_STATUS_OVER|MCI_STATUS_UC)\n\t\t),\n\tMCESEV(\n\t\tPANIC, \"Uncorrected in kernel\",\n\t\tBITSET(MCI_STATUS_UC),\n\t\tKERNEL\n\t\t),\n\tMCESEV(\n\t\tUC, \"Uncorrected\",\n\t\tBITSET(MCI_STATUS_UC)\n\t\t),\n\tMCESEV(\n\t\tSOME, \"No match\",\n\t\tBITSET(0)\n\t\t)\t \n};\n\n#define mc_recoverable(mcg) (((mcg) & (MCG_STATUS_RIPV|MCG_STATUS_EIPV)) == \\\n\t\t\t\t(MCG_STATUS_RIPV|MCG_STATUS_EIPV))\n\nstatic bool is_copy_from_user(struct pt_regs *regs)\n{\n\tu8 insn_buf[MAX_INSN_SIZE];\n\tunsigned long addr;\n\tstruct insn insn;\n\tint ret;\n\n\tif (!regs)\n\t\treturn false;\n\n\tif (copy_from_kernel_nofault(insn_buf, (void *)regs->ip, MAX_INSN_SIZE))\n\t\treturn false;\n\n\tret = insn_decode_kernel(&insn, insn_buf);\n\tif (ret < 0)\n\t\treturn false;\n\n\tswitch (insn.opcode.value) {\n\t \n\tcase 0x8A: case 0x8B:\n\t \n\tcase 0xB60F: case 0xB70F:\n\t\taddr = (unsigned long)insn_get_addr_ref(&insn, regs);\n\t\tbreak;\n\t \n\tcase 0xA4: case 0xA5:\n\t\taddr = regs->si;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (fault_in_kernel_space(addr))\n\t\treturn false;\n\n\tcurrent->mce_vaddr = (void __user *)addr;\n\n\treturn true;\n}\n\n \nstatic noinstr int error_context(struct mce *m, struct pt_regs *regs)\n{\n\tint fixup_type;\n\tbool copy_user;\n\n\tif ((m->cs & 3) == 3)\n\t\treturn IN_USER;\n\n\tif (!mc_recoverable(m->mcgstatus))\n\t\treturn IN_KERNEL;\n\n\t \n\tinstrumentation_begin();\n\tfixup_type = ex_get_fixup_type(m->ip);\n\tcopy_user  = is_copy_from_user(regs);\n\tinstrumentation_end();\n\n\tswitch (fixup_type) {\n\tcase EX_TYPE_UACCESS:\n\tcase EX_TYPE_COPY:\n\t\tif (!copy_user)\n\t\t\treturn IN_KERNEL;\n\t\tm->kflags |= MCE_IN_KERNEL_COPYIN;\n\t\tfallthrough;\n\n\tcase EX_TYPE_FAULT_MCE_SAFE:\n\tcase EX_TYPE_DEFAULT_MCE_SAFE:\n\t\tm->kflags |= MCE_IN_KERNEL_RECOV;\n\t\treturn IN_KERNEL_RECOV;\n\n\tdefault:\n\t\treturn IN_KERNEL;\n\t}\n}\n\n \nstatic noinstr int mce_severity_amd(struct mce *m, struct pt_regs *regs, char **msg, bool is_excp)\n{\n\tchar *panic_msg = NULL;\n\tint ret;\n\n\t \n\tret = MCE_AR_SEVERITY;\n\n\t \n\tif (m->status & MCI_STATUS_PCC) {\n\t\tpanic_msg = \"Processor Context Corrupt\";\n\t\tret = MCE_PANIC_SEVERITY;\n\t\tgoto out;\n\t}\n\n\tif (m->status & MCI_STATUS_DEFERRED) {\n\t\tret = MCE_DEFERRED_SEVERITY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(m->status & MCI_STATUS_UC)) {\n\t\tret = MCE_KEEP_SEVERITY;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((m->status & MCI_STATUS_OVER) && !mce_flags.overflow_recov) {\n\t\tpanic_msg = \"Overflowed uncorrected error without MCA Overflow Recovery\";\n\t\tret = MCE_PANIC_SEVERITY;\n\t\tgoto out;\n\t}\n\n\tif (!mce_flags.succor) {\n\t\tpanic_msg = \"Uncorrected error without MCA Recovery\";\n\t\tret = MCE_PANIC_SEVERITY;\n\t\tgoto out;\n\t}\n\n\tif (error_context(m, regs) == IN_KERNEL) {\n\t\tpanic_msg = \"Uncorrected unrecoverable error in kernel context\";\n\t\tret = MCE_PANIC_SEVERITY;\n\t}\n\nout:\n\tif (msg && panic_msg)\n\t\t*msg = panic_msg;\n\n\treturn ret;\n}\n\nstatic noinstr int mce_severity_intel(struct mce *m, struct pt_regs *regs, char **msg, bool is_excp)\n{\n\tenum exception excp = (is_excp ? EXCP_CONTEXT : NO_EXCP);\n\tenum context ctx = error_context(m, regs);\n\tstruct severity *s;\n\n\tfor (s = severities;; s++) {\n\t\tif ((m->status & s->mask) != s->result)\n\t\t\tcontinue;\n\t\tif ((m->mcgstatus & s->mcgmask) != s->mcgres)\n\t\t\tcontinue;\n\t\tif (s->ser == SER_REQUIRED && !mca_cfg.ser)\n\t\t\tcontinue;\n\t\tif (s->ser == NO_SER && mca_cfg.ser)\n\t\t\tcontinue;\n\t\tif (s->context && ctx != s->context)\n\t\t\tcontinue;\n\t\tif (s->excp && excp != s->excp)\n\t\t\tcontinue;\n\t\tif (s->cpu_model && boot_cpu_data.x86_model != s->cpu_model)\n\t\t\tcontinue;\n\t\tif (s->cpu_minstepping && boot_cpu_data.x86_stepping < s->cpu_minstepping)\n\t\t\tcontinue;\n\t\tif (s->bank_lo && (m->bank < s->bank_lo || m->bank > s->bank_hi))\n\t\t\tcontinue;\n\t\tif (msg)\n\t\t\t*msg = s->msg;\n\t\ts->covered = 1;\n\n\t\treturn s->sev;\n\t}\n}\n\nint noinstr mce_severity(struct mce *m, struct pt_regs *regs, char **msg, bool is_excp)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD ||\n\t    boot_cpu_data.x86_vendor == X86_VENDOR_HYGON)\n\t\treturn mce_severity_amd(m, regs, msg, is_excp);\n\telse\n\t\treturn mce_severity_intel(m, regs, msg, is_excp);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void *s_start(struct seq_file *f, loff_t *pos)\n{\n\tif (*pos >= ARRAY_SIZE(severities))\n\t\treturn NULL;\n\treturn &severities[*pos];\n}\n\nstatic void *s_next(struct seq_file *f, void *data, loff_t *pos)\n{\n\tif (++(*pos) >= ARRAY_SIZE(severities))\n\t\treturn NULL;\n\treturn &severities[*pos];\n}\n\nstatic void s_stop(struct seq_file *f, void *data)\n{\n}\n\nstatic int s_show(struct seq_file *f, void *data)\n{\n\tstruct severity *ser = data;\n\tseq_printf(f, \"%d\\t%s\\n\", ser->covered, ser->msg);\n\treturn 0;\n}\n\nstatic const struct seq_operations severities_seq_ops = {\n\t.start\t= s_start,\n\t.next\t= s_next,\n\t.stop\t= s_stop,\n\t.show\t= s_show,\n};\n\nstatic int severities_coverage_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &severities_seq_ops);\n}\n\nstatic ssize_t severities_coverage_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(severities); i++)\n\t\tseverities[i].covered = 0;\n\treturn count;\n}\n\nstatic const struct file_operations severities_coverage_fops = {\n\t.open\t\t= severities_coverage_open,\n\t.release\t= seq_release,\n\t.read\t\t= seq_read,\n\t.write\t\t= severities_coverage_write,\n\t.llseek\t\t= seq_lseek,\n};\n\nstatic int __init severities_debugfs_init(void)\n{\n\tstruct dentry *dmce;\n\n\tdmce = mce_get_debugfs_dir();\n\n\tdebugfs_create_file(\"severities-coverage\", 0444, dmce, NULL,\n\t\t\t    &severities_coverage_fops);\n\treturn 0;\n}\nlate_initcall(severities_debugfs_init);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}