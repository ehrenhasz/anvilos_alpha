{
  "module_name": "dev-mcelog.c",
  "hash_id": "f8abb723bd7f87c9a40e93a353d1e8822db2ab594ec3e65cf19880754b73a636",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/dev-mcelog.c",
  "human_readable_source": "\n \n\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/poll.h>\n\n#include \"internal.h\"\n\nstatic BLOCKING_NOTIFIER_HEAD(mce_injector_chain);\n\nstatic DEFINE_MUTEX(mce_chrdev_read_mutex);\n\nstatic char mce_helper[128];\nstatic char *mce_helper_argv[2] = { mce_helper, NULL };\n\n \n\nstatic struct mce_log_buffer *mcelog;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mce_chrdev_wait);\n\nstatic int dev_mce_log(struct notifier_block *nb, unsigned long val,\n\t\t\t\tvoid *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tunsigned int entry;\n\n\tif (mce->kflags & MCE_HANDLED_CEC)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&mce_chrdev_read_mutex);\n\n\tentry = mcelog->next;\n\n\t \n\tif (entry >= mcelog->len) {\n\t\tset_bit(MCE_OVERFLOW, (unsigned long *)&mcelog->flags);\n\t\tgoto unlock;\n\t}\n\n\tmcelog->next = entry + 1;\n\n\tmemcpy(mcelog->entry + entry, mce, sizeof(struct mce));\n\tmcelog->entry[entry].finished = 1;\n\tmcelog->entry[entry].kflags = 0;\n\n\t \n\twake_up_interruptible(&mce_chrdev_wait);\n\nunlock:\n\tmutex_unlock(&mce_chrdev_read_mutex);\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\n\t\tmce->kflags |= MCE_HANDLED_MCELOG;\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block dev_mcelog_nb = {\n\t.notifier_call\t= dev_mce_log,\n\t.priority\t= MCE_PRIO_MCELOG,\n};\n\nstatic void mce_do_trigger(struct work_struct *work)\n{\n\tcall_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);\n}\n\nstatic DECLARE_WORK(mce_trigger_work, mce_do_trigger);\n\n\nvoid mce_work_trigger(void)\n{\n\tif (mce_helper[0])\n\t\tschedule_work(&mce_trigger_work);\n}\n\nstatic ssize_t\nshow_trigger(struct device *s, struct device_attribute *attr, char *buf)\n{\n\tstrcpy(buf, mce_helper);\n\tstrcat(buf, \"\\n\");\n\treturn strlen(mce_helper) + 1;\n}\n\nstatic ssize_t set_trigger(struct device *s, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t siz)\n{\n\tchar *p;\n\n\tstrscpy(mce_helper, buf, sizeof(mce_helper));\n\tp = strchr(mce_helper, '\\n');\n\n\tif (p)\n\t\t*p = 0;\n\n\treturn strlen(mce_helper) + !!p;\n}\n\nDEVICE_ATTR(trigger, 0644, show_trigger, set_trigger);\n\n \n\nstatic DEFINE_SPINLOCK(mce_chrdev_state_lock);\nstatic int mce_chrdev_open_count;\t \nstatic int mce_chrdev_open_exclu;\t \n\nstatic int mce_chrdev_open(struct inode *inode, struct file *file)\n{\n\tspin_lock(&mce_chrdev_state_lock);\n\n\tif (mce_chrdev_open_exclu ||\n\t    (mce_chrdev_open_count && (file->f_flags & O_EXCL))) {\n\t\tspin_unlock(&mce_chrdev_state_lock);\n\n\t\treturn -EBUSY;\n\t}\n\n\tif (file->f_flags & O_EXCL)\n\t\tmce_chrdev_open_exclu = 1;\n\tmce_chrdev_open_count++;\n\n\tspin_unlock(&mce_chrdev_state_lock);\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int mce_chrdev_release(struct inode *inode, struct file *file)\n{\n\tspin_lock(&mce_chrdev_state_lock);\n\n\tmce_chrdev_open_count--;\n\tmce_chrdev_open_exclu = 0;\n\n\tspin_unlock(&mce_chrdev_state_lock);\n\n\treturn 0;\n}\n\nstatic int mce_apei_read_done;\n\n \nstatic int __mce_read_apei(char __user **ubuf, size_t usize)\n{\n\tint rc;\n\tu64 record_id;\n\tstruct mce m;\n\n\tif (usize < sizeof(struct mce))\n\t\treturn -EINVAL;\n\n\trc = apei_read_mce(&m, &record_id);\n\t \n\tif (rc <= 0) {\n\t\tmce_apei_read_done = 1;\n\t\t \n\t\tif (rc == -ENODEV)\n\t\t\treturn 0;\n\t\treturn rc;\n\t}\n\trc = -EFAULT;\n\tif (copy_to_user(*ubuf, &m, sizeof(struct mce)))\n\t\treturn rc;\n\t \n\trc = apei_clear_mce(record_id);\n\tif (rc) {\n\t\tmce_apei_read_done = 1;\n\t\treturn rc;\n\t}\n\t*ubuf += sizeof(struct mce);\n\n\treturn 0;\n}\n\nstatic ssize_t mce_chrdev_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t usize, loff_t *off)\n{\n\tchar __user *buf = ubuf;\n\tunsigned next;\n\tint i, err;\n\n\tmutex_lock(&mce_chrdev_read_mutex);\n\n\tif (!mce_apei_read_done) {\n\t\terr = __mce_read_apei(&buf, usize);\n\t\tif (err || buf != ubuf)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = -EINVAL;\n\tif (*off != 0 || usize < mcelog->len * sizeof(struct mce))\n\t\tgoto out;\n\n\tnext = mcelog->next;\n\terr = 0;\n\n\tfor (i = 0; i < next; i++) {\n\t\tstruct mce *m = &mcelog->entry[i];\n\n\t\terr |= copy_to_user(buf, m, sizeof(*m));\n\t\tbuf += sizeof(*m);\n\t}\n\n\tmemset(mcelog->entry, 0, next * sizeof(struct mce));\n\tmcelog->next = 0;\n\n\tif (err)\n\t\terr = -EFAULT;\n\nout:\n\tmutex_unlock(&mce_chrdev_read_mutex);\n\n\treturn err ? err : buf - ubuf;\n}\n\nstatic __poll_t mce_chrdev_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &mce_chrdev_wait, wait);\n\tif (READ_ONCE(mcelog->next))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\tif (!mce_apei_read_done && apei_check_mce())\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic long mce_chrdev_ioctl(struct file *f, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tint __user *p = (int __user *)arg;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase MCE_GET_RECORD_LEN:\n\t\treturn put_user(sizeof(struct mce), p);\n\tcase MCE_GET_LOG_LEN:\n\t\treturn put_user(mcelog->len, p);\n\tcase MCE_GETCLEAR_FLAGS: {\n\t\tunsigned flags;\n\n\t\tdo {\n\t\t\tflags = mcelog->flags;\n\t\t} while (cmpxchg(&mcelog->flags, flags, 0) != flags);\n\n\t\treturn put_user(flags, p);\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nvoid mce_register_injector_chain(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_register(&mce_injector_chain, nb);\n}\nEXPORT_SYMBOL_GPL(mce_register_injector_chain);\n\nvoid mce_unregister_injector_chain(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&mce_injector_chain, nb);\n}\nEXPORT_SYMBOL_GPL(mce_unregister_injector_chain);\n\nstatic ssize_t mce_chrdev_write(struct file *filp, const char __user *ubuf,\n\t\t\t\tsize_t usize, loff_t *off)\n{\n\tstruct mce m;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t \n\tif (!boot_cpu_has(X86_FEATURE_MCE) || !boot_cpu_has(X86_FEATURE_MCA))\n\t\treturn -EIO;\n\n\tif ((unsigned long)usize > sizeof(struct mce))\n\t\tusize = sizeof(struct mce);\n\tif (copy_from_user(&m, ubuf, usize))\n\t\treturn -EFAULT;\n\n\tif (m.extcpu >= num_possible_cpus() || !cpu_online(m.extcpu))\n\t\treturn -EINVAL;\n\n\t \n\tschedule_timeout(2);\n\n\tblocking_notifier_call_chain(&mce_injector_chain, 0, &m);\n\n\treturn usize;\n}\n\nstatic const struct file_operations mce_chrdev_ops = {\n\t.open\t\t\t= mce_chrdev_open,\n\t.release\t\t= mce_chrdev_release,\n\t.read\t\t\t= mce_chrdev_read,\n\t.write\t\t\t= mce_chrdev_write,\n\t.poll\t\t\t= mce_chrdev_poll,\n\t.unlocked_ioctl\t\t= mce_chrdev_ioctl,\n\t.compat_ioctl\t\t= compat_ptr_ioctl,\n\t.llseek\t\t\t= no_llseek,\n};\n\nstatic struct miscdevice mce_chrdev_device = {\n\tMISC_MCELOG_MINOR,\n\t\"mcelog\",\n\t&mce_chrdev_ops,\n};\n\nstatic __init int dev_mcelog_init_device(void)\n{\n\tint mce_log_len;\n\tint err;\n\n\tmce_log_len = max(MCE_LOG_MIN_LEN, num_online_cpus());\n\tmcelog = kzalloc(struct_size(mcelog, entry, mce_log_len), GFP_KERNEL);\n\tif (!mcelog)\n\t\treturn -ENOMEM;\n\n\tmemcpy(mcelog->signature, MCE_LOG_SIGNATURE, sizeof(mcelog->signature));\n\tmcelog->len = mce_log_len;\n\tmcelog->recordlen = sizeof(struct mce);\n\n\t \n\terr = misc_register(&mce_chrdev_device);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\t \n\t\t\tpr_info(\"Unable to init device /dev/mcelog, already registered\");\n\t\telse\n\t\t\tpr_err(\"Unable to init device /dev/mcelog (rc: %d)\\n\", err);\n\n\t\tkfree(mcelog);\n\t\treturn err;\n\t}\n\n\tmce_register_decode_chain(&dev_mcelog_nb);\n\treturn 0;\n}\ndevice_initcall_sync(dev_mcelog_init_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}