{
  "module_name": "inject.c",
  "hash_id": "ccdeae9db04939a3ab9312ebb3f488a6200e0562bc655b1cf777e250560b1d62",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/inject.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include <asm/amd_nb.h>\n#include <asm/apic.h>\n#include <asm/irq_vectors.h>\n#include <asm/mce.h>\n#include <asm/nmi.h>\n#include <asm/smp.h>\n\n#include \"internal.h\"\n\nstatic bool hw_injection_possible = true;\n\n \nstatic struct mce i_mce;\nstatic struct dentry *dfs_inj;\n\n#define MAX_FLAG_OPT_SIZE\t4\n#define NBCFG\t\t\t0x44\n\nenum injection_type {\n\tSW_INJ = 0,\t \n\tHW_INJ,\t\t \n\tDFR_INT_INJ,     \n\tTHR_INT_INJ,     \n\tN_INJ_TYPES,\n};\n\nstatic const char * const flags_options[] = {\n\t[SW_INJ] = \"sw\",\n\t[HW_INJ] = \"hw\",\n\t[DFR_INT_INJ] = \"df\",\n\t[THR_INT_INJ] = \"th\",\n\tNULL\n};\n\n \nstatic enum injection_type inj_type = SW_INJ;\n\n#define MCE_INJECT_SET(reg)\t\t\t\t\t\t\\\nstatic int inj_##reg##_set(void *data, u64 val)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mce *m = (struct mce *)data;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tm->reg = val;\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nMCE_INJECT_SET(status);\nMCE_INJECT_SET(misc);\nMCE_INJECT_SET(addr);\nMCE_INJECT_SET(synd);\n\n#define MCE_INJECT_GET(reg)\t\t\t\t\t\t\\\nstatic int inj_##reg##_get(void *data, u64 *val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mce *m = (struct mce *)data;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t*val = m->reg;\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nMCE_INJECT_GET(status);\nMCE_INJECT_GET(misc);\nMCE_INJECT_GET(addr);\nMCE_INJECT_GET(synd);\nMCE_INJECT_GET(ipid);\n\nDEFINE_SIMPLE_ATTRIBUTE(status_fops, inj_status_get, inj_status_set, \"%llx\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(misc_fops, inj_misc_get, inj_misc_set, \"%llx\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(addr_fops, inj_addr_get, inj_addr_set, \"%llx\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(synd_fops, inj_synd_get, inj_synd_set, \"%llx\\n\");\n\n \nstatic int inj_ipid_set(void *data, u64 val)\n{\n\tstruct mce *m = (struct mce *)data;\n\n\tif (cpu_feature_enabled(X86_FEATURE_SMCA)) {\n\t\tif (inj_type == SW_INJ)\n\t\t\tm->ipid = val;\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(ipid_fops, inj_ipid_get, inj_ipid_set, \"%llx\\n\");\n\nstatic void setup_inj_struct(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->time\t     = ktime_get_real_seconds();\n\tm->cpuid     = cpuid_eax(1);\n\tm->microcode = boot_cpu_data.microcode;\n}\n\n \nstatic void inject_mce(struct mce *m)\n{\n\tstruct mce *i = &per_cpu(injectm, m->extcpu);\n\n\t \n\ti->finished = 0;\n\tmb();\n\tm->finished = 0;\n\t \n\ti->extcpu = m->extcpu;\n\tmb();\n\t \n\tmemcpy(i, m, sizeof(struct mce));\n\t \n\tmb();\n\ti->finished = 1;\n}\n\nstatic void raise_poll(struct mce *m)\n{\n\tunsigned long flags;\n\tmce_banks_t b;\n\n\tmemset(&b, 0xff, sizeof(mce_banks_t));\n\tlocal_irq_save(flags);\n\tmachine_check_poll(0, &b);\n\tlocal_irq_restore(flags);\n\tm->finished = 0;\n}\n\nstatic void raise_exception(struct mce *m, struct pt_regs *pregs)\n{\n\tstruct pt_regs regs;\n\tunsigned long flags;\n\n\tif (!pregs) {\n\t\tmemset(&regs, 0, sizeof(struct pt_regs));\n\t\tregs.ip = m->ip;\n\t\tregs.cs = m->cs;\n\t\tpregs = &regs;\n\t}\n\t \n\tlocal_irq_save(flags);\n\tdo_machine_check(pregs);\n\tlocal_irq_restore(flags);\n\tm->finished = 0;\n}\n\nstatic cpumask_var_t mce_inject_cpumask;\nstatic DEFINE_MUTEX(mce_inject_mutex);\n\nstatic int mce_raise_notify(unsigned int cmd, struct pt_regs *regs)\n{\n\tint cpu = smp_processor_id();\n\tstruct mce *m = this_cpu_ptr(&injectm);\n\tif (!cpumask_test_cpu(cpu, mce_inject_cpumask))\n\t\treturn NMI_DONE;\n\tcpumask_clear_cpu(cpu, mce_inject_cpumask);\n\tif (m->inject_flags & MCJ_EXCEPTION)\n\t\traise_exception(m, regs);\n\telse if (m->status)\n\t\traise_poll(m);\n\treturn NMI_HANDLED;\n}\n\nstatic void mce_irq_ipi(void *info)\n{\n\tint cpu = smp_processor_id();\n\tstruct mce *m = this_cpu_ptr(&injectm);\n\n\tif (cpumask_test_cpu(cpu, mce_inject_cpumask) &&\n\t\t\tm->inject_flags & MCJ_EXCEPTION) {\n\t\tcpumask_clear_cpu(cpu, mce_inject_cpumask);\n\t\traise_exception(m, NULL);\n\t}\n}\n\n \nstatic int raise_local(void)\n{\n\tstruct mce *m = this_cpu_ptr(&injectm);\n\tint context = MCJ_CTX(m->inject_flags);\n\tint ret = 0;\n\tint cpu = m->extcpu;\n\n\tif (m->inject_flags & MCJ_EXCEPTION) {\n\t\tpr_info(\"Triggering MCE exception on CPU %d\\n\", cpu);\n\t\tswitch (context) {\n\t\tcase MCJ_CTX_IRQ:\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase MCJ_CTX_PROCESS:\n\t\t\traise_exception(m, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Invalid MCE context\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tpr_info(\"MCE exception done on CPU %d\\n\", cpu);\n\t} else if (m->status) {\n\t\tpr_info(\"Starting machine check poll CPU %d\\n\", cpu);\n\t\traise_poll(m);\n\t\tmce_notify_irq();\n\t\tpr_info(\"Machine check poll done on CPU %d\\n\", cpu);\n\t} else\n\t\tm->finished = 0;\n\n\treturn ret;\n}\n\nstatic void __maybe_unused raise_mce(struct mce *m)\n{\n\tint context = MCJ_CTX(m->inject_flags);\n\n\tinject_mce(m);\n\n\tif (context == MCJ_CTX_RANDOM)\n\t\treturn;\n\n\tif (m->inject_flags & (MCJ_IRQ_BROADCAST | MCJ_NMI_BROADCAST)) {\n\t\tunsigned long start;\n\t\tint cpu;\n\n\t\tcpus_read_lock();\n\t\tcpumask_copy(mce_inject_cpumask, cpu_online_mask);\n\t\tcpumask_clear_cpu(get_cpu(), mce_inject_cpumask);\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tstruct mce *mcpu = &per_cpu(injectm, cpu);\n\t\t\tif (!mcpu->finished ||\n\t\t\t    MCJ_CTX(mcpu->inject_flags) != MCJ_CTX_RANDOM)\n\t\t\t\tcpumask_clear_cpu(cpu, mce_inject_cpumask);\n\t\t}\n\t\tif (!cpumask_empty(mce_inject_cpumask)) {\n\t\t\tif (m->inject_flags & MCJ_IRQ_BROADCAST) {\n\t\t\t\t \n\t\t\t\tpreempt_disable();\n\t\t\t\tsmp_call_function_many(mce_inject_cpumask,\n\t\t\t\t\tmce_irq_ipi, NULL, 0);\n\t\t\t\tpreempt_enable();\n\t\t\t} else if (m->inject_flags & MCJ_NMI_BROADCAST)\n\t\t\t\t__apic_send_IPI_mask(mce_inject_cpumask, NMI_VECTOR);\n\t\t}\n\t\tstart = jiffies;\n\t\twhile (!cpumask_empty(mce_inject_cpumask)) {\n\t\t\tif (!time_before(jiffies, start + 2*HZ)) {\n\t\t\t\tpr_err(\"Timeout waiting for mce inject %lx\\n\",\n\t\t\t\t\t*cpumask_bits(mce_inject_cpumask));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\t\traise_local();\n\t\tput_cpu();\n\t\tcpus_read_unlock();\n\t} else {\n\t\tpreempt_disable();\n\t\traise_local();\n\t\tpreempt_enable();\n\t}\n}\n\nstatic int mce_inject_raise(struct notifier_block *nb, unsigned long val,\n\t\t\t    void *data)\n{\n\tstruct mce *m = (struct mce *)data;\n\n\tif (!m)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&mce_inject_mutex);\n\traise_mce(m);\n\tmutex_unlock(&mce_inject_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block inject_nb = {\n\t.notifier_call  = mce_inject_raise,\n};\n\n \nstatic int toggle_hw_mce_inject(unsigned int cpu, bool enable)\n{\n\tu32 l, h;\n\tint err;\n\n\terr = rdmsr_on_cpu(cpu, MSR_K7_HWCR, &l, &h);\n\tif (err) {\n\t\tpr_err(\"%s: error reading HWCR\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tenable ? (l |= BIT(18)) : (l &= ~BIT(18));\n\n\terr = wrmsr_on_cpu(cpu, MSR_K7_HWCR, l, h);\n\tif (err)\n\t\tpr_err(\"%s: error writing HWCR\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int __set_inj(const char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < N_INJ_TYPES; i++) {\n\t\tif (!strncmp(flags_options[i], buf, strlen(flags_options[i]))) {\n\t\t\tif (i > SW_INJ && !hw_injection_possible)\n\t\t\t\tcontinue;\n\t\t\tinj_type = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t flags_read(struct file *filp, char __user *ubuf,\n\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tchar buf[MAX_FLAG_OPT_SIZE];\n\tint n;\n\n\tn = sprintf(buf, \"%s\\n\", flags_options[inj_type]);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\n}\n\nstatic ssize_t flags_write(struct file *filp, const char __user *ubuf,\n\t\t\t   size_t cnt, loff_t *ppos)\n{\n\tchar buf[MAX_FLAG_OPT_SIZE], *__buf;\n\tint err;\n\n\tif (!cnt || cnt > MAX_FLAG_OPT_SIZE)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt - 1] = 0;\n\n\t \n\t__buf = strstrip(buf);\n\n\terr = __set_inj(__buf);\n\tif (err) {\n\t\tpr_err(\"%s: Invalid flags value: %s\\n\", __func__, __buf);\n\t\treturn err;\n\t}\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations flags_fops = {\n\t.read           = flags_read,\n\t.write          = flags_write,\n\t.llseek         = generic_file_llseek,\n};\n\n \nMCE_INJECT_GET(extcpu);\n\nstatic int inj_extcpu_set(void *data, u64 val)\n{\n\tstruct mce *m = (struct mce *)data;\n\n\tif (val >= nr_cpu_ids || !cpu_online(val)) {\n\t\tpr_err(\"%s: Invalid CPU: %llu\\n\", __func__, val);\n\t\treturn -EINVAL;\n\t}\n\tm->extcpu = val;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(extcpu_fops, inj_extcpu_get, inj_extcpu_set, \"%llu\\n\");\n\nstatic void trigger_mce(void *info)\n{\n\tasm volatile(\"int $18\");\n}\n\nstatic void trigger_dfr_int(void *info)\n{\n\tasm volatile(\"int %0\" :: \"i\" (DEFERRED_ERROR_VECTOR));\n}\n\nstatic void trigger_thr_int(void *info)\n{\n\tasm volatile(\"int %0\" :: \"i\" (THRESHOLD_APIC_VECTOR));\n}\n\nstatic u32 get_nbc_for_node(int node_id)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\tu32 cores_per_node;\n\n\tcores_per_node = (c->x86_max_cores * smp_num_siblings) / amd_get_nodes_per_socket();\n\n\treturn cores_per_node * node_id;\n}\n\nstatic void toggle_nb_mca_mst_cpu(u16 nid)\n{\n\tstruct amd_northbridge *nb;\n\tstruct pci_dev *F3;\n\tu32 val;\n\tint err;\n\n\tnb = node_to_amd_nb(nid);\n\tif (!nb)\n\t\treturn;\n\n\tF3 = nb->misc;\n\tif (!F3)\n\t\treturn;\n\n\terr = pci_read_config_dword(F3, NBCFG, &val);\n\tif (err) {\n\t\tpr_err(\"%s: Error reading F%dx%03x.\\n\",\n\t\t       __func__, PCI_FUNC(F3->devfn), NBCFG);\n\t\treturn;\n\t}\n\n\tif (val & BIT(27))\n\t\treturn;\n\n\tpr_err(\"%s: Set D18F3x44[NbMcaToMstCpuEn] which BIOS hasn't done.\\n\",\n\t       __func__);\n\n\tval |= BIT(27);\n\terr = pci_write_config_dword(F3, NBCFG, val);\n\tif (err)\n\t\tpr_err(\"%s: Error writing F%dx%03x.\\n\",\n\t\t       __func__, PCI_FUNC(F3->devfn), NBCFG);\n}\n\nstatic void prepare_msrs(void *info)\n{\n\tstruct mce m = *(struct mce *)info;\n\tu8 b = m.bank;\n\n\twrmsrl(MSR_IA32_MCG_STATUS, m.mcgstatus);\n\n\tif (boot_cpu_has(X86_FEATURE_SMCA)) {\n\t\tif (m.inject_flags == DFR_INT_INJ) {\n\t\t\twrmsrl(MSR_AMD64_SMCA_MCx_DESTAT(b), m.status);\n\t\t\twrmsrl(MSR_AMD64_SMCA_MCx_DEADDR(b), m.addr);\n\t\t} else {\n\t\t\twrmsrl(MSR_AMD64_SMCA_MCx_STATUS(b), m.status);\n\t\t\twrmsrl(MSR_AMD64_SMCA_MCx_ADDR(b), m.addr);\n\t\t}\n\n\t\twrmsrl(MSR_AMD64_SMCA_MCx_MISC(b), m.misc);\n\t\twrmsrl(MSR_AMD64_SMCA_MCx_SYND(b), m.synd);\n\t} else {\n\t\twrmsrl(MSR_IA32_MCx_STATUS(b), m.status);\n\t\twrmsrl(MSR_IA32_MCx_ADDR(b), m.addr);\n\t\twrmsrl(MSR_IA32_MCx_MISC(b), m.misc);\n\t}\n}\n\nstatic void do_inject(void)\n{\n\tu64 mcg_status = 0;\n\tunsigned int cpu = i_mce.extcpu;\n\tu8 b = i_mce.bank;\n\n\ti_mce.tsc = rdtsc_ordered();\n\n\ti_mce.status |= MCI_STATUS_VAL;\n\n\tif (i_mce.misc)\n\t\ti_mce.status |= MCI_STATUS_MISCV;\n\n\tif (i_mce.synd)\n\t\ti_mce.status |= MCI_STATUS_SYNDV;\n\n\tif (inj_type == SW_INJ) {\n\t\tmce_log(&i_mce);\n\t\treturn;\n\t}\n\n\t \n\tmcg_status = MCG_STATUS_MCIP | MCG_STATUS_EIPV;\n\n\tif (!(i_mce.status & MCI_STATUS_PCC))\n\t\tmcg_status |= MCG_STATUS_RIPV;\n\n\t \n\tif (inj_type == DFR_INT_INJ) {\n\t\ti_mce.status |= MCI_STATUS_DEFERRED;\n\t\ti_mce.status &= ~MCI_STATUS_UC;\n\t}\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_AMD_DCM) &&\n\t    b == 4 &&\n\t    boot_cpu_data.x86 < 0x17) {\n\t\ttoggle_nb_mca_mst_cpu(topology_die_id(cpu));\n\t\tcpu = get_nbc_for_node(topology_die_id(cpu));\n\t}\n\n\tcpus_read_lock();\n\tif (!cpu_online(cpu))\n\t\tgoto err;\n\n\ttoggle_hw_mce_inject(cpu, true);\n\n\ti_mce.mcgstatus = mcg_status;\n\ti_mce.inject_flags = inj_type;\n\tsmp_call_function_single(cpu, prepare_msrs, &i_mce, 0);\n\n\ttoggle_hw_mce_inject(cpu, false);\n\n\tswitch (inj_type) {\n\tcase DFR_INT_INJ:\n\t\tsmp_call_function_single(cpu, trigger_dfr_int, NULL, 0);\n\t\tbreak;\n\tcase THR_INT_INJ:\n\t\tsmp_call_function_single(cpu, trigger_thr_int, NULL, 0);\n\t\tbreak;\n\tdefault:\n\t\tsmp_call_function_single(cpu, trigger_mce, NULL, 0);\n\t}\n\nerr:\n\tcpus_read_unlock();\n\n}\n\n \nstatic int inj_bank_set(void *data, u64 val)\n{\n\tstruct mce *m = (struct mce *)data;\n\tu8 n_banks;\n\tu64 cap;\n\n\t \n\trdmsrl_on_cpu(m->extcpu, MSR_IA32_MCG_CAP, &cap);\n\tn_banks = cap & MCG_BANKCNT_MASK;\n\n\tif (val >= n_banks) {\n\t\tpr_err(\"MCA bank %llu non-existent on CPU%d\\n\", val, m->extcpu);\n\t\treturn -EINVAL;\n\t}\n\n\tm->bank = val;\n\n\t \n\tif (inj_type == SW_INJ)\n\t\tgoto inject;\n\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_SMCA)) {\n\t\tu64 ipid;\n\n\t\tif (rdmsrl_on_cpu(m->extcpu, MSR_AMD64_SMCA_MCx_IPID(val), &ipid)) {\n\t\t\tpr_err(\"Error reading IPID on CPU%d\\n\", m->extcpu);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ipid) {\n\t\t\tpr_err(\"Cannot inject into unpopulated bank %llu\\n\", val);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\ninject:\n\tdo_inject();\n\n\t \n\tsetup_inj_struct(&i_mce);\n\n\treturn 0;\n}\n\nMCE_INJECT_GET(bank);\n\nDEFINE_SIMPLE_ATTRIBUTE(bank_fops, inj_bank_get, inj_bank_set, \"%llu\\n\");\n\nstatic const char readme_msg[] =\n\"Description of the files and their usages:\\n\"\n\"\\n\"\n\"Note1: i refers to the bank number below.\\n\"\n\"Note2: See respective BKDGs for the exact bit definitions of the files below\\n\"\n\"as they mirror the hardware registers.\\n\"\n\"\\n\"\n\"status:\\t Set MCi_STATUS: the bits in that MSR control the error type and\\n\"\n\"\\t attributes of the error which caused the MCE.\\n\"\n\"\\n\"\n\"misc:\\t Set MCi_MISC: provide auxiliary info about the error. It is mostly\\n\"\n\"\\t used for error thresholding purposes and its validity is indicated by\\n\"\n\"\\t MCi_STATUS[MiscV].\\n\"\n\"\\n\"\n\"synd:\\t Set MCi_SYND: provide syndrome info about the error. Only valid on\\n\"\n\"\\t Scalable MCA systems, and its validity is indicated by MCi_STATUS[SyndV].\\n\"\n\"\\n\"\n\"addr:\\t Error address value to be written to MCi_ADDR. Log address information\\n\"\n\"\\t associated with the error.\\n\"\n\"\\n\"\n\"cpu:\\t The CPU to inject the error on.\\n\"\n\"\\n\"\n\"bank:\\t Specify the bank you want to inject the error into: the number of\\n\"\n\"\\t banks in a processor varies and is family/model-specific, therefore, the\\n\"\n\"\\t supplied value is sanity-checked. Setting the bank value also triggers the\\n\"\n\"\\t injection.\\n\"\n\"\\n\"\n\"flags:\\t Injection type to be performed. Writing to this file will trigger a\\n\"\n\"\\t real machine check, an APIC interrupt or invoke the error decoder routines\\n\"\n\"\\t for AMD processors.\\n\"\n\"\\n\"\n\"\\t Allowed error injection types:\\n\"\n\"\\t  - \\\"sw\\\": Software error injection. Decode error to a human-readable \\n\"\n\"\\t    format only. Safe to use.\\n\"\n\"\\t  - \\\"hw\\\": Hardware error injection. Causes the #MC exception handler to \\n\"\n\"\\t    handle the error. Be warned: might cause system panic if MCi_STATUS[PCC] \\n\"\n\"\\t    is set. Therefore, consider setting (debugfs_mountpoint)/mce/fake_panic \\n\"\n\"\\t    before injecting.\\n\"\n\"\\t  - \\\"df\\\": Trigger APIC interrupt for Deferred error. Causes deferred \\n\"\n\"\\t    error APIC interrupt handler to handle the error if the feature is \\n\"\n\"\\t    is present in hardware. \\n\"\n\"\\t  - \\\"th\\\": Trigger APIC interrupt for Threshold errors. Causes threshold \\n\"\n\"\\t    APIC interrupt handler to handle the error. \\n\"\n\"\\n\"\n\"ipid:\\t IPID (AMD-specific)\\n\"\n\"\\n\";\n\nstatic ssize_t\ninj_readme_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\treadme_msg, strlen(readme_msg));\n}\n\nstatic const struct file_operations readme_fops = {\n\t.read\t\t= inj_readme_read,\n};\n\nstatic struct dfs_node {\n\tchar *name;\n\tconst struct file_operations *fops;\n\tumode_t perm;\n} dfs_fls[] = {\n\t{ .name = \"status\",\t.fops = &status_fops, .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"misc\",\t.fops = &misc_fops,   .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"addr\",\t.fops = &addr_fops,   .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"synd\",\t.fops = &synd_fops,   .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"ipid\",\t.fops = &ipid_fops,   .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"bank\",\t.fops = &bank_fops,   .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"flags\",\t.fops = &flags_fops,  .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"cpu\",\t.fops = &extcpu_fops, .perm = S_IRUSR | S_IWUSR },\n\t{ .name = \"README\",\t.fops = &readme_fops, .perm = S_IRUSR | S_IRGRP | S_IROTH },\n};\n\nstatic void __init debugfs_init(void)\n{\n\tunsigned int i;\n\n\tdfs_inj = debugfs_create_dir(\"mce-inject\", NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++)\n\t\tdebugfs_create_file(dfs_fls[i].name, dfs_fls[i].perm, dfs_inj,\n\t\t\t\t    &i_mce, dfs_fls[i].fops);\n}\n\nstatic void check_hw_inj_possible(void)\n{\n\tint cpu;\n\tu8 bank;\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_SMCA))\n\t\treturn;\n\n\tcpu = get_cpu();\n\n\tfor (bank = 0; bank < MAX_NR_BANKS; ++bank) {\n\t\tu64 status = MCI_STATUS_VAL, ipid;\n\n\t\t \n\t\trdmsrl(MSR_AMD64_SMCA_MCx_IPID(bank), ipid);\n\t\tif (!ipid)\n\t\t\tcontinue;\n\n\t\ttoggle_hw_mce_inject(cpu, true);\n\n\t\twrmsrl_safe(mca_msr_reg(bank, MCA_STATUS), status);\n\t\trdmsrl_safe(mca_msr_reg(bank, MCA_STATUS), &status);\n\t\twrmsrl_safe(mca_msr_reg(bank, MCA_STATUS), 0);\n\n\t\tif (!status) {\n\t\t\thw_injection_possible = false;\n\t\t\tpr_warn(\"Platform does not allow *hardware* error injection.\"\n\t\t\t\t\"Try using APEI EINJ instead.\\n\");\n\t\t}\n\n\t\ttoggle_hw_mce_inject(cpu, false);\n\n\t\tbreak;\n\t}\n\n\tput_cpu();\n}\n\nstatic int __init inject_init(void)\n{\n\tif (!alloc_cpumask_var(&mce_inject_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcheck_hw_inj_possible();\n\n\tdebugfs_init();\n\n\tregister_nmi_handler(NMI_LOCAL, mce_raise_notify, 0, \"mce_notify\");\n\tmce_register_injector_chain(&inject_nb);\n\n\tsetup_inj_struct(&i_mce);\n\n\tpr_info(\"Machine check injector initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit inject_exit(void)\n{\n\n\tmce_unregister_injector_chain(&inject_nb);\n\tunregister_nmi_handler(NMI_LOCAL, \"mce_notify\");\n\n\tdebugfs_remove_recursive(dfs_inj);\n\tdfs_inj = NULL;\n\n\tmemset(&dfs_fls, 0, sizeof(dfs_fls));\n\n\tfree_cpumask_var(mce_inject_cpumask);\n}\n\nmodule_init(inject_init);\nmodule_exit(inject_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}