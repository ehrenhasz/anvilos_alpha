{
  "module_name": "apei.c",
  "hash_id": "d71f9497e7b282cce424ccd323e7c4c8e2e54521a72b70bb581445fc8b4602f9",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/mce/apei.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/cper.h>\n#include <acpi/apei.h>\n#include <acpi/ghes.h>\n#include <asm/mce.h>\n\n#include \"internal.h\"\n\nvoid apei_mce_report_mem_error(int severity, struct cper_sec_mem_err *mem_err)\n{\n\tstruct mce m;\n\tint lsb;\n\n\tif (!(mem_err->validation_bits & CPER_MEM_VALID_PA))\n\t\treturn;\n\n\t \n\tif (mem_err->validation_bits & CPER_MEM_VALID_PA_MASK)\n\t\tlsb = find_first_bit((void *)&mem_err->physical_addr_mask, PAGE_SHIFT);\n\telse\n\t\tlsb = PAGE_SHIFT;\n\n\tmce_setup(&m);\n\tm.bank = -1;\n\t \n\tm.status = MCI_STATUS_VAL | MCI_STATUS_EN | MCI_STATUS_ADDRV | MCI_STATUS_MISCV | 0x9f;\n\tm.misc = (MCI_MISC_ADDR_PHYS << 6) | lsb;\n\n\tif (severity >= GHES_SEV_RECOVERABLE)\n\t\tm.status |= MCI_STATUS_UC;\n\n\tif (severity >= GHES_SEV_PANIC) {\n\t\tm.status |= MCI_STATUS_PCC;\n\t\tm.tsc = rdtsc();\n\t}\n\n\tm.addr = mem_err->physical_addr;\n\tmce_log(&m);\n}\nEXPORT_SYMBOL_GPL(apei_mce_report_mem_error);\n\nint apei_smca_report_x86_error(struct cper_ia_proc_ctx *ctx_info, u64 lapic_id)\n{\n\tconst u64 *i_mce = ((const u64 *) (ctx_info + 1));\n\tunsigned int cpu;\n\tstruct mce m;\n\n\tif (!boot_cpu_has(X86_FEATURE_SMCA))\n\t\treturn -EINVAL;\n\n\t \n\tif ((ctx_info->msr_addr & MSR_AMD64_SMCA_MC0_STATUS) !=\n\t\t\t\t  MSR_AMD64_SMCA_MC0_STATUS)\n\t\treturn -EINVAL;\n\n\t \n\tif (ctx_info->reg_arr_size < 48)\n\t\treturn -EINVAL;\n\n\tmce_setup(&m);\n\n\tm.extcpu = -1;\n\tm.socketid = -1;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu_data(cpu).initial_apicid == lapic_id) {\n\t\t\tm.extcpu = cpu;\n\t\t\tm.socketid = cpu_data(m.extcpu).phys_proc_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tm.apicid = lapic_id;\n\tm.bank = (ctx_info->msr_addr >> 4) & 0xFF;\n\tm.status = *i_mce;\n\tm.addr = *(i_mce + 1);\n\tm.misc = *(i_mce + 2);\n\t \n\tm.ipid = *(i_mce + 4);\n\tm.synd = *(i_mce + 5);\n\n\tmce_log(&m);\n\n\treturn 0;\n}\n\n#define CPER_CREATOR_MCE\t\t\t\t\t\t\\\n\tGUID_INIT(0x75a574e3, 0x5052, 0x4b29, 0x8a, 0x8e, 0xbe, 0x2c,\t\\\n\t\t  0x64, 0x90, 0xb8, 0x9d)\n#define CPER_SECTION_TYPE_MCE\t\t\t\t\t\t\\\n\tGUID_INIT(0xfe08ffbe, 0x95e4, 0x4be7, 0xbc, 0x73, 0x40, 0x96,\t\\\n\t\t  0x04, 0x4a, 0x38, 0xfc)\n\n \nstruct cper_mce_record {\n\tstruct cper_record_header hdr;\n\tstruct cper_section_descriptor sec_hdr;\n\tstruct mce mce;\n} __packed;\n\nint apei_write_mce(struct mce *m)\n{\n\tstruct cper_mce_record rcd;\n\n\tmemset(&rcd, 0, sizeof(rcd));\n\tmemcpy(rcd.hdr.signature, CPER_SIG_RECORD, CPER_SIG_SIZE);\n\trcd.hdr.revision = CPER_RECORD_REV;\n\trcd.hdr.signature_end = CPER_SIG_END;\n\trcd.hdr.section_count = 1;\n\trcd.hdr.error_severity = CPER_SEV_FATAL;\n\t \n\trcd.hdr.validation_bits = 0;\n\trcd.hdr.record_length = sizeof(rcd);\n\trcd.hdr.creator_id = CPER_CREATOR_MCE;\n\trcd.hdr.notification_type = CPER_NOTIFY_MCE;\n\trcd.hdr.record_id = cper_next_record_id();\n\trcd.hdr.flags = CPER_HW_ERROR_FLAGS_PREVERR;\n\n\trcd.sec_hdr.section_offset = (void *)&rcd.mce - (void *)&rcd;\n\trcd.sec_hdr.section_length = sizeof(rcd.mce);\n\trcd.sec_hdr.revision = CPER_SEC_REV;\n\t \n\trcd.sec_hdr.validation_bits = 0;\n\trcd.sec_hdr.flags = CPER_SEC_PRIMARY;\n\trcd.sec_hdr.section_type = CPER_SECTION_TYPE_MCE;\n\trcd.sec_hdr.section_severity = CPER_SEV_FATAL;\n\n\tmemcpy(&rcd.mce, m, sizeof(*m));\n\n\treturn erst_write(&rcd.hdr);\n}\n\nssize_t apei_read_mce(struct mce *m, u64 *record_id)\n{\n\tstruct cper_mce_record rcd;\n\tint rc, pos;\n\n\trc = erst_get_record_id_begin(&pos);\n\tif (rc)\n\t\treturn rc;\nretry:\n\trc = erst_get_record_id_next(&pos, record_id);\n\tif (rc)\n\t\tgoto out;\n\t \n\tif (*record_id == APEI_ERST_INVALID_RECORD_ID)\n\t\tgoto out;\n\trc = erst_read_record(*record_id, &rcd.hdr, sizeof(rcd), sizeof(rcd),\n\t\t\t&CPER_CREATOR_MCE);\n\t \n\tif (rc == -ENOENT)\n\t\tgoto retry;\n\telse if (rc < 0)\n\t\tgoto out;\n\n\tmemcpy(m, &rcd.mce, sizeof(*m));\n\trc = sizeof(*m);\nout:\n\terst_get_record_id_end();\n\n\treturn rc;\n}\n\n \nint apei_check_mce(void)\n{\n\treturn erst_get_record_count();\n}\n\nint apei_clear_mce(u64 record_id)\n{\n\treturn erst_clear(record_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}