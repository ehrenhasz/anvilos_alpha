{
  "module_name": "intel.c",
  "hash_id": "e9ad5d87dca6c08e87c82f62dfddcd04f7524ef6e87d85007cc97a9c2252a974",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/intel.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/pgtable.h>\n\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/semaphore.h>\n#include <linux/thread_info.h>\n#include <linux/init.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/cpuhotplug.h>\n\n#include <asm/cpufeature.h>\n#include <asm/msr.h>\n#include <asm/bugs.h>\n#include <asm/cpu.h>\n#include <asm/intel-family.h>\n#include <asm/microcode.h>\n#include <asm/hwcap2.h>\n#include <asm/elf.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cmdline.h>\n#include <asm/traps.h>\n#include <asm/resctrl.h>\n#include <asm/numa.h>\n#include <asm/thermal.h>\n\n#ifdef CONFIG_X86_64\n#include <linux/topology.h>\n#endif\n\n#include \"cpu.h\"\n\n#ifdef CONFIG_X86_LOCAL_APIC\n#include <asm/mpspec.h>\n#include <asm/apic.h>\n#endif\n\nenum split_lock_detect_state {\n\tsld_off = 0,\n\tsld_warn,\n\tsld_fatal,\n\tsld_ratelimit,\n};\n\n \nstatic enum split_lock_detect_state sld_state __ro_after_init = sld_off;\nstatic u64 msr_test_ctrl_cache __ro_after_init;\n\n \nstatic bool cpu_model_supports_sld __ro_after_init;\n\n \nstatic void check_memory_type_self_snoop_errata(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_model) {\n\tcase INTEL_FAM6_CORE_YONAH:\n\tcase INTEL_FAM6_CORE2_MEROM:\n\tcase INTEL_FAM6_CORE2_MEROM_L:\n\tcase INTEL_FAM6_CORE2_PENRYN:\n\tcase INTEL_FAM6_CORE2_DUNNINGTON:\n\tcase INTEL_FAM6_NEHALEM:\n\tcase INTEL_FAM6_NEHALEM_G:\n\tcase INTEL_FAM6_NEHALEM_EP:\n\tcase INTEL_FAM6_NEHALEM_EX:\n\tcase INTEL_FAM6_WESTMERE:\n\tcase INTEL_FAM6_WESTMERE_EP:\n\tcase INTEL_FAM6_SANDYBRIDGE:\n\t\tsetup_clear_cpu_cap(X86_FEATURE_SELFSNOOP);\n\t}\n}\n\nstatic bool ring3mwait_disabled __read_mostly;\n\nstatic int __init ring3mwait_disable(char *__unused)\n{\n\tring3mwait_disabled = true;\n\treturn 1;\n}\n__setup(\"ring3mwait=disable\", ring3mwait_disable);\n\nstatic void probe_xeon_phi_r3mwait(struct cpuinfo_x86 *c)\n{\n\t \n\tif (c->x86 != 6)\n\t\treturn;\n\tswitch (c->x86_model) {\n\tcase INTEL_FAM6_XEON_PHI_KNL:\n\tcase INTEL_FAM6_XEON_PHI_KNM:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (ring3mwait_disabled)\n\t\treturn;\n\n\tset_cpu_cap(c, X86_FEATURE_RING3MWAIT);\n\tthis_cpu_or(msr_misc_features_shadow,\n\t\t    1UL << MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT);\n\n\tif (c == &boot_cpu_data)\n\t\tELF_HWCAP2 |= HWCAP2_RING3MWAIT;\n}\n\n \nstruct sku_microcode {\n\tu8 model;\n\tu8 stepping;\n\tu32 microcode;\n};\nstatic const struct sku_microcode spectre_bad_microcodes[] = {\n\t{ INTEL_FAM6_KABYLAKE,\t\t0x0B,\t0x80 },\n\t{ INTEL_FAM6_KABYLAKE,\t\t0x0A,\t0x80 },\n\t{ INTEL_FAM6_KABYLAKE,\t\t0x09,\t0x80 },\n\t{ INTEL_FAM6_KABYLAKE_L,\t0x0A,\t0x80 },\n\t{ INTEL_FAM6_KABYLAKE_L,\t0x09,\t0x80 },\n\t{ INTEL_FAM6_SKYLAKE_X,\t\t0x03,\t0x0100013e },\n\t{ INTEL_FAM6_SKYLAKE_X,\t\t0x04,\t0x0200003c },\n\t{ INTEL_FAM6_BROADWELL,\t\t0x04,\t0x28 },\n\t{ INTEL_FAM6_BROADWELL_G,\t0x01,\t0x1b },\n\t{ INTEL_FAM6_BROADWELL_D,\t0x02,\t0x14 },\n\t{ INTEL_FAM6_BROADWELL_D,\t0x03,\t0x07000011 },\n\t{ INTEL_FAM6_BROADWELL_X,\t0x01,\t0x0b000025 },\n\t{ INTEL_FAM6_HASWELL_L,\t\t0x01,\t0x21 },\n\t{ INTEL_FAM6_HASWELL_G,\t\t0x01,\t0x18 },\n\t{ INTEL_FAM6_HASWELL,\t\t0x03,\t0x23 },\n\t{ INTEL_FAM6_HASWELL_X,\t\t0x02,\t0x3b },\n\t{ INTEL_FAM6_HASWELL_X,\t\t0x04,\t0x10 },\n\t{ INTEL_FAM6_IVYBRIDGE_X,\t0x04,\t0x42a },\n\t \n\t{ INTEL_FAM6_SANDYBRIDGE_X,\t0x06,\t0x61b },\n\t{ INTEL_FAM6_SANDYBRIDGE_X,\t0x07,\t0x712 },\n};\n\nstatic bool bad_spectre_microcode(struct cpuinfo_x86 *c)\n{\n\tint i;\n\n\t \n\tif (cpu_has(c, X86_FEATURE_HYPERVISOR))\n\t\treturn false;\n\n\tif (c->x86 != 6)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(spectre_bad_microcodes); i++) {\n\t\tif (c->x86_model == spectre_bad_microcodes[i].model &&\n\t\t    c->x86_stepping == spectre_bad_microcodes[i].stepping)\n\t\t\treturn (c->microcode <= spectre_bad_microcodes[i].microcode);\n\t}\n\treturn false;\n}\n\nstatic void early_init_intel(struct cpuinfo_x86 *c)\n{\n\tu64 misc_enable;\n\n\t \n\tif (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {\n\t\tif (msr_clear_bit(MSR_IA32_MISC_ENABLE,\n\t\t\t\t  MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT) > 0) {\n\t\t\tc->cpuid_level = cpuid_eax(0);\n\t\t\tget_cpu_cap(c);\n\t\t}\n\t}\n\n\tif ((c->x86 == 0xf && c->x86_model >= 0x03) ||\n\t\t(c->x86 == 0x6 && c->x86_model >= 0x0e))\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\n\tif (c->x86 >= 6 && !cpu_has(c, X86_FEATURE_IA64))\n\t\tc->microcode = intel_get_microcode_revision();\n\n\t \n\tif ((cpu_has(c, X86_FEATURE_SPEC_CTRL) ||\n\t     cpu_has(c, X86_FEATURE_INTEL_STIBP) ||\n\t     cpu_has(c, X86_FEATURE_IBRS) || cpu_has(c, X86_FEATURE_IBPB) ||\n\t     cpu_has(c, X86_FEATURE_STIBP)) && bad_spectre_microcode(c)) {\n\t\tpr_warn(\"Intel Spectre v2 broken microcode detected; disabling Speculation Control\\n\");\n\t\tsetup_clear_cpu_cap(X86_FEATURE_IBRS);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_IBPB);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_STIBP);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_SPEC_CTRL);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_MSR_SPEC_CTRL);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_INTEL_STIBP);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_SSBD);\n\t\tsetup_clear_cpu_cap(X86_FEATURE_SPEC_CTRL_SSBD);\n\t}\n\n\t \n\tif (c->x86 == 6 && c->x86_model == 0x1c && c->x86_stepping <= 2 &&\n\t    c->microcode < 0x20e) {\n\t\tpr_warn(\"Atom PSE erratum detected, BIOS microcode update recommended\\n\");\n\t\tclear_cpu_cap(c, X86_FEATURE_PSE);\n\t}\n\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSENTER32);\n#else\n\t \n\tif (c->x86 == 15 && c->x86_cache_alignment == 64)\n\t\tc->x86_cache_alignment = 128;\n#endif\n\n\t \n\tif (c->x86 == 0xF && c->x86_model == 0x3\n\t    && (c->x86_stepping == 0x3 || c->x86_stepping == 0x4))\n\t\tc->x86_phys_bits = 36;\n\n\t \n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t}\n\n\t \n\tif (c->x86 == 6) {\n\t\tswitch (c->x86_model) {\n\t\tcase INTEL_FAM6_ATOM_SALTWELL_MID:\n\t\tcase INTEL_FAM6_ATOM_SALTWELL_TABLET:\n\t\tcase INTEL_FAM6_ATOM_SILVERMONT_MID:\n\t\tcase INTEL_FAM6_ATOM_AIRMONT_NP:\n\t\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC_S3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (c->x86 == 6 && c->x86_model < 15)\n\t\tclear_cpu_cap(c, X86_FEATURE_PAT);\n\n\t \n\tif (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {\n\t\trdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);\n\t\tif (!(misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)) {\n\t\t\tpr_info(\"Disabled fast string operations\\n\");\n\t\t\tsetup_clear_cpu_cap(X86_FEATURE_REP_GOOD);\n\t\t\tsetup_clear_cpu_cap(X86_FEATURE_ERMS);\n\t\t}\n\t}\n\n\t \n\tif (c->x86 == 5 && c->x86_model == 9) {\n\t\tpr_info(\"Disabling PGE capability bit\\n\");\n\t\tsetup_clear_cpu_cap(X86_FEATURE_PGE);\n\t}\n\n\tif (c->cpuid_level >= 0x00000001) {\n\t\tu32 eax, ebx, ecx, edx;\n\n\t\tcpuid(0x00000001, &eax, &ebx, &ecx, &edx);\n\t\t \n\t\tif (edx & (1U << 28))\n\t\t\tc->x86_coreid_bits = get_count_order((ebx >> 16) & 0xff);\n\t}\n\n\tcheck_memory_type_self_snoop_errata(c);\n\n\t \n\tif (detect_extended_topology_early(c) < 0)\n\t\tdetect_ht_early(c);\n}\n\nstatic void bsp_init_intel(struct cpuinfo_x86 *c)\n{\n\tresctrl_cpu_detect(c);\n}\n\n#ifdef CONFIG_X86_32\n \n\nint ppro_with_ram_bug(void)\n{\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6 &&\n\t    boot_cpu_data.x86_model == 1 &&\n\t    boot_cpu_data.x86_stepping < 8) {\n\t\tpr_info(\"Pentium Pro with Errata#50 detected. Taking evasive action.\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void intel_smp_check(struct cpuinfo_x86 *c)\n{\n\t \n\tif (!c->cpu_index)\n\t\treturn;\n\n\t \n\tif (c->x86 == 5 &&\n\t    c->x86_stepping >= 1 && c->x86_stepping <= 4 &&\n\t    c->x86_model <= 3) {\n\t\t \n\t\tWARN_ONCE(1, \"WARNING: SMP operation may be unreliable\"\n\t\t\t\t    \"with B stepping processors.\\n\");\n\t}\n}\n\nstatic int forcepae;\nstatic int __init forcepae_setup(char *__unused)\n{\n\tforcepae = 1;\n\treturn 1;\n}\n__setup(\"forcepae\", forcepae_setup);\n\nstatic void intel_workarounds(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_X86_F00F_BUG\n\t \n\tclear_cpu_bug(c, X86_BUG_F00F);\n\tif (c->x86 == 5 && c->x86_model < 9) {\n\t\tstatic int f00f_workaround_enabled;\n\n\t\tset_cpu_bug(c, X86_BUG_F00F);\n\t\tif (!f00f_workaround_enabled) {\n\t\t\tpr_notice(\"Intel Pentium with F0 0F bug - workaround enabled.\\n\");\n\t\t\tf00f_workaround_enabled = 1;\n\t\t}\n\t}\n#endif\n\n\t \n\tif ((c->x86<<8 | c->x86_model<<4 | c->x86_stepping) < 0x633)\n\t\tclear_cpu_cap(c, X86_FEATURE_SEP);\n\n\t \n\tif (forcepae) {\n\t\tpr_warn(\"PAE forced!\\n\");\n\t\tset_cpu_cap(c, X86_FEATURE_PAE);\n\t\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_NOW_UNRELIABLE);\n\t}\n\n\t \n\tif ((c->x86 == 15) && (c->x86_model == 1) && (c->x86_stepping == 1)) {\n\t\tif (msr_set_bit(MSR_IA32_MISC_ENABLE,\n\t\t\t\tMSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT) > 0) {\n\t\t\tpr_info(\"CPU: C0 stepping P4 Xeon detected.\\n\");\n\t\t\tpr_info(\"CPU: Disabling hardware prefetching (Erratum 037)\\n\");\n\t\t}\n\t}\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_APIC) && (c->x86<<8 | c->x86_model<<4) == 0x520 &&\n\t    (c->x86_stepping < 0x6 || c->x86_stepping == 0xb))\n\t\tset_cpu_bug(c, X86_BUG_11AP);\n\n\n#ifdef CONFIG_X86_INTEL_USERCOPY\n\t \n\tswitch (c->x86) {\n\tcase 4:\t\t \n\t\tbreak;\n\tcase 5:\t\t \n\t\tbreak;\n\tcase 6:\t\t \n\t\tmovsl_mask.mask = 7;\n\t\tbreak;\n\tcase 15:\t \n\t\tmovsl_mask.mask = 7;\n\t\tbreak;\n\t}\n#endif\n\n\tintel_smp_check(c);\n}\n#else\nstatic void intel_workarounds(struct cpuinfo_x86 *c)\n{\n}\n#endif\n\nstatic void srat_detect_node(struct cpuinfo_x86 *c)\n{\n#ifdef CONFIG_NUMA\n\tunsigned node;\n\tint cpu = smp_processor_id();\n\n\t \n\tnode = numa_cpu_node(cpu);\n\tif (node == NUMA_NO_NODE || !node_online(node)) {\n\t\t \n\t\tnode = cpu_to_node(cpu);\n\t}\n\tnuma_set_node(cpu, node);\n#endif\n}\n\n#define MSR_IA32_TME_ACTIVATE\t\t0x982\n\n \n#define TME_ACTIVATE_LOCKED(x)\t\t(x & 0x1)\n#define TME_ACTIVATE_ENABLED(x)\t\t(x & 0x2)\n\n#define TME_ACTIVATE_POLICY(x)\t\t((x >> 4) & 0xf)\t \n#define TME_ACTIVATE_POLICY_AES_XTS_128\t0\n\n#define TME_ACTIVATE_KEYID_BITS(x)\t((x >> 32) & 0xf)\t \n\n#define TME_ACTIVATE_CRYPTO_ALGS(x)\t((x >> 48) & 0xffff)\t \n#define TME_ACTIVATE_CRYPTO_AES_XTS_128\t1\n\n \n#define MKTME_ENABLED\t\t\t0\n#define MKTME_DISABLED\t\t\t1\n#define MKTME_UNINITIALIZED\t\t2\nstatic int mktme_status = MKTME_UNINITIALIZED;\n\nstatic void detect_tme(struct cpuinfo_x86 *c)\n{\n\tu64 tme_activate, tme_policy, tme_crypto_algs;\n\tint keyid_bits = 0, nr_keyids = 0;\n\tstatic u64 tme_activate_cpu0 = 0;\n\n\trdmsrl(MSR_IA32_TME_ACTIVATE, tme_activate);\n\n\tif (mktme_status != MKTME_UNINITIALIZED) {\n\t\tif (tme_activate != tme_activate_cpu0) {\n\t\t\t \n\t\t\tpr_err_once(\"x86/tme: configuration is inconsistent between CPUs\\n\");\n\t\t\tpr_err_once(\"x86/tme: MKTME is not usable\\n\");\n\t\t\tmktme_status = MKTME_DISABLED;\n\n\t\t\t \n\t\t}\n\t} else {\n\t\ttme_activate_cpu0 = tme_activate;\n\t}\n\n\tif (!TME_ACTIVATE_LOCKED(tme_activate) || !TME_ACTIVATE_ENABLED(tme_activate)) {\n\t\tpr_info_once(\"x86/tme: not enabled by BIOS\\n\");\n\t\tmktme_status = MKTME_DISABLED;\n\t\treturn;\n\t}\n\n\tif (mktme_status != MKTME_UNINITIALIZED)\n\t\tgoto detect_keyid_bits;\n\n\tpr_info(\"x86/tme: enabled by BIOS\\n\");\n\n\ttme_policy = TME_ACTIVATE_POLICY(tme_activate);\n\tif (tme_policy != TME_ACTIVATE_POLICY_AES_XTS_128)\n\t\tpr_warn(\"x86/tme: Unknown policy is active: %#llx\\n\", tme_policy);\n\n\ttme_crypto_algs = TME_ACTIVATE_CRYPTO_ALGS(tme_activate);\n\tif (!(tme_crypto_algs & TME_ACTIVATE_CRYPTO_AES_XTS_128)) {\n\t\tpr_err(\"x86/mktme: No known encryption algorithm is supported: %#llx\\n\",\n\t\t\t\ttme_crypto_algs);\n\t\tmktme_status = MKTME_DISABLED;\n\t}\ndetect_keyid_bits:\n\tkeyid_bits = TME_ACTIVATE_KEYID_BITS(tme_activate);\n\tnr_keyids = (1UL << keyid_bits) - 1;\n\tif (nr_keyids) {\n\t\tpr_info_once(\"x86/mktme: enabled by BIOS\\n\");\n\t\tpr_info_once(\"x86/mktme: %d KeyIDs available\\n\", nr_keyids);\n\t} else {\n\t\tpr_info_once(\"x86/mktme: disabled by BIOS\\n\");\n\t}\n\n\tif (mktme_status == MKTME_UNINITIALIZED) {\n\t\t \n\t\tmktme_status = MKTME_ENABLED;\n\t}\n\n\t \n\tc->x86_phys_bits -= keyid_bits;\n}\n\nstatic void init_cpuid_fault(struct cpuinfo_x86 *c)\n{\n\tu64 msr;\n\n\tif (!rdmsrl_safe(MSR_PLATFORM_INFO, &msr)) {\n\t\tif (msr & MSR_PLATFORM_INFO_CPUID_FAULT)\n\t\t\tset_cpu_cap(c, X86_FEATURE_CPUID_FAULT);\n\t}\n}\n\nstatic void init_intel_misc_features(struct cpuinfo_x86 *c)\n{\n\tu64 msr;\n\n\tif (rdmsrl_safe(MSR_MISC_FEATURES_ENABLES, &msr))\n\t\treturn;\n\n\t \n\tthis_cpu_write(msr_misc_features_shadow, 0);\n\n\t \n\tinit_cpuid_fault(c);\n\tprobe_xeon_phi_r3mwait(c);\n\n\tmsr = this_cpu_read(msr_misc_features_shadow);\n\twrmsrl(MSR_MISC_FEATURES_ENABLES, msr);\n}\n\nstatic void split_lock_init(void);\nstatic void bus_lock_init(void);\n\nstatic void init_intel(struct cpuinfo_x86 *c)\n{\n\tearly_init_intel(c);\n\n\tintel_workarounds(c);\n\n\t \n\tdetect_extended_topology(c);\n\n\tif (!cpu_has(c, X86_FEATURE_XTOPOLOGY)) {\n\t\t \n\t\tdetect_num_cpu_cores(c);\n#ifdef CONFIG_X86_32\n\t\tdetect_ht(c);\n#endif\n\t}\n\n\tinit_intel_cacheinfo(c);\n\n\tif (c->cpuid_level > 9) {\n\t\tunsigned eax = cpuid_eax(10);\n\t\t \n\t\tif ((eax & 0xff) && (((eax>>8) & 0xff) > 1))\n\t\t\tset_cpu_cap(c, X86_FEATURE_ARCH_PERFMON);\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_XMM2))\n\t\tset_cpu_cap(c, X86_FEATURE_LFENCE_RDTSC);\n\n\tif (boot_cpu_has(X86_FEATURE_DS)) {\n\t\tunsigned int l1, l2;\n\n\t\trdmsr(MSR_IA32_MISC_ENABLE, l1, l2);\n\t\tif (!(l1 & MSR_IA32_MISC_ENABLE_BTS_UNAVAIL))\n\t\t\tset_cpu_cap(c, X86_FEATURE_BTS);\n\t\tif (!(l1 & MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL))\n\t\t\tset_cpu_cap(c, X86_FEATURE_PEBS);\n\t}\n\n\tif (c->x86 == 6 && boot_cpu_has(X86_FEATURE_CLFLUSH) &&\n\t    (c->x86_model == 29 || c->x86_model == 46 || c->x86_model == 47))\n\t\tset_cpu_bug(c, X86_BUG_CLFLUSH_MONITOR);\n\n\tif (c->x86 == 6 && boot_cpu_has(X86_FEATURE_MWAIT) &&\n\t\t((c->x86_model == INTEL_FAM6_ATOM_GOLDMONT)))\n\t\tset_cpu_bug(c, X86_BUG_MONITOR);\n\n#ifdef CONFIG_X86_64\n\tif (c->x86 == 15)\n\t\tc->x86_cache_alignment = c->x86_clflush_size * 2;\n\tif (c->x86 == 6)\n\t\tset_cpu_cap(c, X86_FEATURE_REP_GOOD);\n#else\n\t \n\tif (c->x86 == 6) {\n\t\tunsigned int l2 = c->x86_cache_size;\n\t\tchar *p = NULL;\n\n\t\tswitch (c->x86_model) {\n\t\tcase 5:\n\t\t\tif (l2 == 0)\n\t\t\t\tp = \"Celeron (Covington)\";\n\t\t\telse if (l2 == 256)\n\t\t\t\tp = \"Mobile Pentium II (Dixon)\";\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tif (l2 == 128)\n\t\t\t\tp = \"Celeron (Mendocino)\";\n\t\t\telse if (c->x86_stepping == 0 || c->x86_stepping == 5)\n\t\t\t\tp = \"Celeron-A\";\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tif (l2 == 128)\n\t\t\t\tp = \"Celeron (Coppermine)\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (p)\n\t\t\tstrcpy(c->x86_model_id, p);\n\t}\n\n\tif (c->x86 == 15)\n\t\tset_cpu_cap(c, X86_FEATURE_P4);\n\tif (c->x86 == 6)\n\t\tset_cpu_cap(c, X86_FEATURE_P3);\n#endif\n\n\t \n\tsrat_detect_node(c);\n\n\tinit_ia32_feat_ctl(c);\n\n\tif (cpu_has(c, X86_FEATURE_TME))\n\t\tdetect_tme(c);\n\n\tinit_intel_misc_features(c);\n\n\tsplit_lock_init();\n\tbus_lock_init();\n\n\tintel_init_thermal(c);\n}\n\n#ifdef CONFIG_X86_32\nstatic unsigned int intel_size_cache(struct cpuinfo_x86 *c, unsigned int size)\n{\n\t \n\tif ((c->x86 == 6) && (c->x86_model == 11) && (size == 0))\n\t\tsize = 256;\n\n\t \n\tif ((c->x86 == 5) && (c->x86_model == 9))\n\t\tsize = 16;\n\treturn size;\n}\n#endif\n\n#define TLB_INST_4K\t0x01\n#define TLB_INST_4M\t0x02\n#define TLB_INST_2M_4M\t0x03\n\n#define TLB_INST_ALL\t0x05\n#define TLB_INST_1G\t0x06\n\n#define TLB_DATA_4K\t0x11\n#define TLB_DATA_4M\t0x12\n#define TLB_DATA_2M_4M\t0x13\n#define TLB_DATA_4K_4M\t0x14\n\n#define TLB_DATA_1G\t0x16\n\n#define TLB_DATA0_4K\t0x21\n#define TLB_DATA0_4M\t0x22\n#define TLB_DATA0_2M_4M\t0x23\n\n#define STLB_4K\t\t0x41\n#define STLB_4K_2M\t0x42\n\nstatic const struct _tlb_table intel_tlb_table[] = {\n\t{ 0x01, TLB_INST_4K,\t\t32,\t\" TLB_INST 4 KByte pages, 4-way set associative\" },\n\t{ 0x02, TLB_INST_4M,\t\t2,\t\" TLB_INST 4 MByte pages, full associative\" },\n\t{ 0x03, TLB_DATA_4K,\t\t64,\t\" TLB_DATA 4 KByte pages, 4-way set associative\" },\n\t{ 0x04, TLB_DATA_4M,\t\t8,\t\" TLB_DATA 4 MByte pages, 4-way set associative\" },\n\t{ 0x05, TLB_DATA_4M,\t\t32,\t\" TLB_DATA 4 MByte pages, 4-way set associative\" },\n\t{ 0x0b, TLB_INST_4M,\t\t4,\t\" TLB_INST 4 MByte pages, 4-way set associative\" },\n\t{ 0x4f, TLB_INST_4K,\t\t32,\t\" TLB_INST 4 KByte pages\" },\n\t{ 0x50, TLB_INST_ALL,\t\t64,\t\" TLB_INST 4 KByte and 2-MByte or 4-MByte pages\" },\n\t{ 0x51, TLB_INST_ALL,\t\t128,\t\" TLB_INST 4 KByte and 2-MByte or 4-MByte pages\" },\n\t{ 0x52, TLB_INST_ALL,\t\t256,\t\" TLB_INST 4 KByte and 2-MByte or 4-MByte pages\" },\n\t{ 0x55, TLB_INST_2M_4M,\t\t7,\t\" TLB_INST 2-MByte or 4-MByte pages, fully associative\" },\n\t{ 0x56, TLB_DATA0_4M,\t\t16,\t\" TLB_DATA0 4 MByte pages, 4-way set associative\" },\n\t{ 0x57, TLB_DATA0_4K,\t\t16,\t\" TLB_DATA0 4 KByte pages, 4-way associative\" },\n\t{ 0x59, TLB_DATA0_4K,\t\t16,\t\" TLB_DATA0 4 KByte pages, fully associative\" },\n\t{ 0x5a, TLB_DATA0_2M_4M,\t32,\t\" TLB_DATA0 2-MByte or 4 MByte pages, 4-way set associative\" },\n\t{ 0x5b, TLB_DATA_4K_4M,\t\t64,\t\" TLB_DATA 4 KByte and 4 MByte pages\" },\n\t{ 0x5c, TLB_DATA_4K_4M,\t\t128,\t\" TLB_DATA 4 KByte and 4 MByte pages\" },\n\t{ 0x5d, TLB_DATA_4K_4M,\t\t256,\t\" TLB_DATA 4 KByte and 4 MByte pages\" },\n\t{ 0x61, TLB_INST_4K,\t\t48,\t\" TLB_INST 4 KByte pages, full associative\" },\n\t{ 0x63, TLB_DATA_1G,\t\t4,\t\" TLB_DATA 1 GByte pages, 4-way set associative\" },\n\t{ 0x6b, TLB_DATA_4K,\t\t256,\t\" TLB_DATA 4 KByte pages, 8-way associative\" },\n\t{ 0x6c, TLB_DATA_2M_4M,\t\t128,\t\" TLB_DATA 2 MByte or 4 MByte pages, 8-way associative\" },\n\t{ 0x6d, TLB_DATA_1G,\t\t16,\t\" TLB_DATA 1 GByte pages, fully associative\" },\n\t{ 0x76, TLB_INST_2M_4M,\t\t8,\t\" TLB_INST 2-MByte or 4-MByte pages, fully associative\" },\n\t{ 0xb0, TLB_INST_4K,\t\t128,\t\" TLB_INST 4 KByte pages, 4-way set associative\" },\n\t{ 0xb1, TLB_INST_2M_4M,\t\t4,\t\" TLB_INST 2M pages, 4-way, 8 entries or 4M pages, 4-way entries\" },\n\t{ 0xb2, TLB_INST_4K,\t\t64,\t\" TLB_INST 4KByte pages, 4-way set associative\" },\n\t{ 0xb3, TLB_DATA_4K,\t\t128,\t\" TLB_DATA 4 KByte pages, 4-way set associative\" },\n\t{ 0xb4, TLB_DATA_4K,\t\t256,\t\" TLB_DATA 4 KByte pages, 4-way associative\" },\n\t{ 0xb5, TLB_INST_4K,\t\t64,\t\" TLB_INST 4 KByte pages, 8-way set associative\" },\n\t{ 0xb6, TLB_INST_4K,\t\t128,\t\" TLB_INST 4 KByte pages, 8-way set associative\" },\n\t{ 0xba, TLB_DATA_4K,\t\t64,\t\" TLB_DATA 4 KByte pages, 4-way associative\" },\n\t{ 0xc0, TLB_DATA_4K_4M,\t\t8,\t\" TLB_DATA 4 KByte and 4 MByte pages, 4-way associative\" },\n\t{ 0xc1, STLB_4K_2M,\t\t1024,\t\" STLB 4 KByte and 2 MByte pages, 8-way associative\" },\n\t{ 0xc2, TLB_DATA_2M_4M,\t\t16,\t\" TLB_DATA 2 MByte/4MByte pages, 4-way associative\" },\n\t{ 0xca, STLB_4K,\t\t512,\t\" STLB 4 KByte pages, 4-way associative\" },\n\t{ 0x00, 0, 0 }\n};\n\nstatic void intel_tlb_lookup(const unsigned char desc)\n{\n\tunsigned char k;\n\tif (desc == 0)\n\t\treturn;\n\n\t \n\tfor (k = 0; intel_tlb_table[k].descriptor != desc &&\n\t     intel_tlb_table[k].descriptor != 0; k++)\n\t\t;\n\n\tif (intel_tlb_table[k].tlb_type == 0)\n\t\treturn;\n\n\tswitch (intel_tlb_table[k].tlb_type) {\n\tcase STLB_4K:\n\t\tif (tlb_lli_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase STLB_4K_2M:\n\t\tif (tlb_lli_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lli_2m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_2m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_2m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_2m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lli_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_INST_ALL:\n\t\tif (tlb_lli_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lli_2m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_2m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lli_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_INST_4K:\n\t\tif (tlb_lli_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_INST_4M:\n\t\tif (tlb_lli_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_INST_2M_4M:\n\t\tif (tlb_lli_2m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_2m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lli_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lli_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_DATA_4K:\n\tcase TLB_DATA0_4K:\n\t\tif (tlb_lld_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_DATA_4M:\n\tcase TLB_DATA0_4M:\n\t\tif (tlb_lld_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_DATA_2M_4M:\n\tcase TLB_DATA0_2M_4M:\n\t\tif (tlb_lld_2m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_2m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_DATA_4K_4M:\n\t\tif (tlb_lld_4k[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4k[ENTRIES] = intel_tlb_table[k].entries;\n\t\tif (tlb_lld_4m[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_4m[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\tcase TLB_DATA_1G:\n\t\tif (tlb_lld_1g[ENTRIES] < intel_tlb_table[k].entries)\n\t\t\ttlb_lld_1g[ENTRIES] = intel_tlb_table[k].entries;\n\t\tbreak;\n\t}\n}\n\nstatic void intel_detect_tlb(struct cpuinfo_x86 *c)\n{\n\tint i, j, n;\n\tunsigned int regs[4];\n\tunsigned char *desc = (unsigned char *)regs;\n\n\tif (c->cpuid_level < 2)\n\t\treturn;\n\n\t \n\tn = cpuid_eax(2) & 0xFF;\n\n\tfor (i = 0 ; i < n ; i++) {\n\t\tcpuid(2, &regs[0], &regs[1], &regs[2], &regs[3]);\n\n\t\t \n\t\tfor (j = 0 ; j < 3 ; j++)\n\t\t\tif (regs[j] & (1 << 31))\n\t\t\t\tregs[j] = 0;\n\n\t\t \n\t\tfor (j = 1 ; j < 16 ; j++)\n\t\t\tintel_tlb_lookup(desc[j]);\n\t}\n}\n\nstatic const struct cpu_dev intel_cpu_dev = {\n\t.c_vendor\t= \"Intel\",\n\t.c_ident\t= { \"GenuineIntel\" },\n#ifdef CONFIG_X86_32\n\t.legacy_models = {\n\t\t{ .family = 4, .model_names =\n\t\t  {\n\t\t\t  [0] = \"486 DX-25/33\",\n\t\t\t  [1] = \"486 DX-50\",\n\t\t\t  [2] = \"486 SX\",\n\t\t\t  [3] = \"486 DX/2\",\n\t\t\t  [4] = \"486 SL\",\n\t\t\t  [5] = \"486 SX/2\",\n\t\t\t  [7] = \"486 DX/2-WB\",\n\t\t\t  [8] = \"486 DX/4\",\n\t\t\t  [9] = \"486 DX/4-WB\"\n\t\t  }\n\t\t},\n\t\t{ .family = 5, .model_names =\n\t\t  {\n\t\t\t  [0] = \"Pentium 60/66 A-step\",\n\t\t\t  [1] = \"Pentium 60/66\",\n\t\t\t  [2] = \"Pentium 75 - 200\",\n\t\t\t  [3] = \"OverDrive PODP5V83\",\n\t\t\t  [4] = \"Pentium MMX\",\n\t\t\t  [7] = \"Mobile Pentium 75 - 200\",\n\t\t\t  [8] = \"Mobile Pentium MMX\",\n\t\t\t  [9] = \"Quark SoC X1000\",\n\t\t  }\n\t\t},\n\t\t{ .family = 6, .model_names =\n\t\t  {\n\t\t\t  [0] = \"Pentium Pro A-step\",\n\t\t\t  [1] = \"Pentium Pro\",\n\t\t\t  [3] = \"Pentium II (Klamath)\",\n\t\t\t  [4] = \"Pentium II (Deschutes)\",\n\t\t\t  [5] = \"Pentium II (Deschutes)\",\n\t\t\t  [6] = \"Mobile Pentium II\",\n\t\t\t  [7] = \"Pentium III (Katmai)\",\n\t\t\t  [8] = \"Pentium III (Coppermine)\",\n\t\t\t  [10] = \"Pentium III (Cascades)\",\n\t\t\t  [11] = \"Pentium III (Tualatin)\",\n\t\t  }\n\t\t},\n\t\t{ .family = 15, .model_names =\n\t\t  {\n\t\t\t  [0] = \"Pentium 4 (Unknown)\",\n\t\t\t  [1] = \"Pentium 4 (Willamette)\",\n\t\t\t  [2] = \"Pentium 4 (Northwood)\",\n\t\t\t  [4] = \"Pentium 4 (Foster)\",\n\t\t\t  [5] = \"Pentium 4 (Foster)\",\n\t\t  }\n\t\t},\n\t},\n\t.legacy_cache_size = intel_size_cache,\n#endif\n\t.c_detect_tlb\t= intel_detect_tlb,\n\t.c_early_init   = early_init_intel,\n\t.c_bsp_init\t= bsp_init_intel,\n\t.c_init\t\t= init_intel,\n\t.c_x86_vendor\t= X86_VENDOR_INTEL,\n};\n\ncpu_dev_register(intel_cpu_dev);\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"x86/split lock detection: \" fmt\n\nstatic const struct {\n\tconst char\t\t\t*option;\n\tenum split_lock_detect_state\tstate;\n} sld_options[] __initconst = {\n\t{ \"off\",\tsld_off   },\n\t{ \"warn\",\tsld_warn  },\n\t{ \"fatal\",\tsld_fatal },\n\t{ \"ratelimit:\", sld_ratelimit },\n};\n\nstatic struct ratelimit_state bld_ratelimit;\n\nstatic unsigned int sysctl_sld_mitigate = 1;\nstatic DEFINE_SEMAPHORE(buslock_sem, 1);\n\n#ifdef CONFIG_PROC_SYSCTL\nstatic struct ctl_table sld_sysctls[] = {\n\t{\n\t\t.procname       = \"split_lock_mitigate\",\n\t\t.data           = &sysctl_sld_mitigate,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{}\n};\n\nstatic int __init sld_mitigate_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", sld_sysctls);\n\treturn 0;\n}\n\nlate_initcall(sld_mitigate_sysctl_init);\n#endif\n\nstatic inline bool match_option(const char *arg, int arglen, const char *opt)\n{\n\tint len = strlen(opt), ratelimit;\n\n\tif (strncmp(arg, opt, len))\n\t\treturn false;\n\n\t \n\tif (sscanf(arg, \"ratelimit:%d\", &ratelimit) == 1 &&\n\t    ratelimit > 0 && ratelimit <= 1000) {\n\t\tratelimit_state_init(&bld_ratelimit, HZ, ratelimit);\n\t\tratelimit_set_flags(&bld_ratelimit, RATELIMIT_MSG_ON_RELEASE);\n\t\treturn true;\n\t}\n\n\treturn len == arglen;\n}\n\nstatic bool split_lock_verify_msr(bool on)\n{\n\tu64 ctrl, tmp;\n\n\tif (rdmsrl_safe(MSR_TEST_CTRL, &ctrl))\n\t\treturn false;\n\tif (on)\n\t\tctrl |= MSR_TEST_CTRL_SPLIT_LOCK_DETECT;\n\telse\n\t\tctrl &= ~MSR_TEST_CTRL_SPLIT_LOCK_DETECT;\n\tif (wrmsrl_safe(MSR_TEST_CTRL, ctrl))\n\t\treturn false;\n\trdmsrl(MSR_TEST_CTRL, tmp);\n\treturn ctrl == tmp;\n}\n\nstatic void __init sld_state_setup(void)\n{\n\tenum split_lock_detect_state state = sld_warn;\n\tchar arg[20];\n\tint i, ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT) &&\n\t    !boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT))\n\t\treturn;\n\n\tret = cmdline_find_option(boot_command_line, \"split_lock_detect\",\n\t\t\t\t  arg, sizeof(arg));\n\tif (ret >= 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(sld_options); i++) {\n\t\t\tif (match_option(arg, ret, sld_options[i].option)) {\n\t\t\t\tstate = sld_options[i].state;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsld_state = state;\n}\n\nstatic void __init __split_lock_setup(void)\n{\n\tif (!split_lock_verify_msr(false)) {\n\t\tpr_info(\"MSR access failed: Disabled\\n\");\n\t\treturn;\n\t}\n\n\trdmsrl(MSR_TEST_CTRL, msr_test_ctrl_cache);\n\n\tif (!split_lock_verify_msr(true)) {\n\t\tpr_info(\"MSR access failed: Disabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\twrmsrl(MSR_TEST_CTRL, msr_test_ctrl_cache);\n\n\tsetup_force_cpu_cap(X86_FEATURE_SPLIT_LOCK_DETECT);\n}\n\n \nstatic void sld_update_msr(bool on)\n{\n\tu64 test_ctrl_val = msr_test_ctrl_cache;\n\n\tif (on)\n\t\ttest_ctrl_val |= MSR_TEST_CTRL_SPLIT_LOCK_DETECT;\n\n\twrmsrl(MSR_TEST_CTRL, test_ctrl_val);\n}\n\nstatic void split_lock_init(void)\n{\n\t \n\tif (sld_state == sld_ratelimit) {\n\t\tsplit_lock_verify_msr(false);\n\t\treturn;\n\t}\n\n\tif (cpu_model_supports_sld)\n\t\tsplit_lock_verify_msr(sld_state != sld_off);\n}\n\nstatic void __split_lock_reenable_unlock(struct work_struct *work)\n{\n\tsld_update_msr(true);\n\tup(&buslock_sem);\n}\n\nstatic DECLARE_DELAYED_WORK(sl_reenable_unlock, __split_lock_reenable_unlock);\n\nstatic void __split_lock_reenable(struct work_struct *work)\n{\n\tsld_update_msr(true);\n}\nstatic DECLARE_DELAYED_WORK(sl_reenable, __split_lock_reenable);\n\n \nstatic int splitlock_cpu_offline(unsigned int cpu)\n{\n\tsld_update_msr(true);\n\n\treturn 0;\n}\n\nstatic void split_lock_warn(unsigned long ip)\n{\n\tstruct delayed_work *work;\n\tint cpu;\n\n\tif (!current->reported_split_lock)\n\t\tpr_warn_ratelimited(\"#AC: %s/%d took a split_lock trap at address: 0x%lx\\n\",\n\t\t\t\t    current->comm, current->pid, ip);\n\tcurrent->reported_split_lock = 1;\n\n\tif (sysctl_sld_mitigate) {\n\t\t \n\t\tif (msleep_interruptible(10) > 0)\n\t\t\treturn;\n\t\t \n\t\tif (down_interruptible(&buslock_sem) == -EINTR)\n\t\t\treturn;\n\t\twork = &sl_reenable_unlock;\n\t} else {\n\t\twork = &sl_reenable;\n\t}\n\n\tcpu = get_cpu();\n\tschedule_delayed_work_on(cpu, work, 2);\n\n\t \n\tsld_update_msr(false);\n\tput_cpu();\n}\n\nbool handle_guest_split_lock(unsigned long ip)\n{\n\tif (sld_state == sld_warn) {\n\t\tsplit_lock_warn(ip);\n\t\treturn true;\n\t}\n\n\tpr_warn_once(\"#AC: %s/%d %s split_lock trap at address: 0x%lx\\n\",\n\t\t     current->comm, current->pid,\n\t\t     sld_state == sld_fatal ? \"fatal\" : \"bogus\", ip);\n\n\tcurrent->thread.error_code = 0;\n\tcurrent->thread.trap_nr = X86_TRAP_AC;\n\tforce_sig_fault(SIGBUS, BUS_ADRALN, NULL);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(handle_guest_split_lock);\n\nstatic void bus_lock_init(void)\n{\n\tu64 val;\n\n\tif (!boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT))\n\t\treturn;\n\n\trdmsrl(MSR_IA32_DEBUGCTLMSR, val);\n\n\tif ((boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT) &&\n\t    (sld_state == sld_warn || sld_state == sld_fatal)) ||\n\t    sld_state == sld_off) {\n\t\t \n\t\tval &= ~DEBUGCTLMSR_BUS_LOCK_DETECT;\n\t} else {\n\t\tval |= DEBUGCTLMSR_BUS_LOCK_DETECT;\n\t}\n\n\twrmsrl(MSR_IA32_DEBUGCTLMSR, val);\n}\n\nbool handle_user_split_lock(struct pt_regs *regs, long error_code)\n{\n\tif ((regs->flags & X86_EFLAGS_AC) || sld_state == sld_fatal)\n\t\treturn false;\n\tsplit_lock_warn(regs->ip);\n\treturn true;\n}\n\nvoid handle_bus_lock(struct pt_regs *regs)\n{\n\tswitch (sld_state) {\n\tcase sld_off:\n\t\tbreak;\n\tcase sld_ratelimit:\n\t\t \n\t\twhile (!__ratelimit(&bld_ratelimit))\n\t\t\tmsleep(20);\n\t\t \n\t\tfallthrough;\n\tcase sld_warn:\n\t\tpr_warn_ratelimited(\"#DB: %s/%d took a bus_lock trap at address: 0x%lx\\n\",\n\t\t\t\t    current->comm, current->pid, regs->ip);\n\t\tbreak;\n\tcase sld_fatal:\n\t\tforce_sig_fault(SIGBUS, BUS_ADRALN, NULL);\n\t\tbreak;\n\t}\n}\n\n \nstatic const struct x86_cpu_id split_lock_cpu_ids[] __initconst = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,\t0),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,\t0),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,\t0),\n\t{}\n};\n\nstatic void __init split_lock_setup(struct cpuinfo_x86 *c)\n{\n\tconst struct x86_cpu_id *m;\n\tu64 ia32_core_caps;\n\n\tif (boot_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\treturn;\n\n\t \n\tm = x86_match_cpu(split_lock_cpu_ids);\n\tif (m)\n\t\tgoto supported;\n\n\tif (!cpu_has(c, X86_FEATURE_CORE_CAPABILITIES))\n\t\treturn;\n\n\t \n\trdmsrl(MSR_IA32_CORE_CAPS, ia32_core_caps);\n\tif (ia32_core_caps & MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT)\n\t\tgoto supported;\n\n\t \n\treturn;\n\nsupported:\n\tcpu_model_supports_sld = true;\n\t__split_lock_setup();\n}\n\nstatic void sld_state_show(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT) &&\n\t    !boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))\n\t\treturn;\n\n\tswitch (sld_state) {\n\tcase sld_off:\n\t\tpr_info(\"disabled\\n\");\n\t\tbreak;\n\tcase sld_warn:\n\t\tif (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT)) {\n\t\t\tpr_info(\"#AC: crashing the kernel on kernel split_locks and warning on user-space split_locks\\n\");\n\t\t\tif (cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t      \"x86/splitlock\", NULL, splitlock_cpu_offline) < 0)\n\t\t\t\tpr_warn(\"No splitlock CPU offline handler\\n\");\n\t\t} else if (boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT)) {\n\t\t\tpr_info(\"#DB: warning on user-space bus_locks\\n\");\n\t\t}\n\t\tbreak;\n\tcase sld_fatal:\n\t\tif (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT)) {\n\t\t\tpr_info(\"#AC: crashing the kernel on kernel split_locks and sending SIGBUS on user-space split_locks\\n\");\n\t\t} else if (boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT)) {\n\t\t\tpr_info(\"#DB: sending SIGBUS on user-space bus_locks%s\\n\",\n\t\t\t\tboot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT) ?\n\t\t\t\t\" from non-WB\" : \"\");\n\t\t}\n\t\tbreak;\n\tcase sld_ratelimit:\n\t\tif (boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT))\n\t\t\tpr_info(\"#DB: setting system wide bus lock rate limit to %u/sec\\n\", bld_ratelimit.burst);\n\t\tbreak;\n\t}\n}\n\nvoid __init sld_setup(struct cpuinfo_x86 *c)\n{\n\tsplit_lock_setup(c);\n\tsld_state_setup();\n\tsld_state_show();\n}\n\n#define X86_HYBRID_CPU_TYPE_ID_SHIFT\t24\n\n \nu8 get_this_hybrid_cpu_type(void)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_HYBRID_CPU))\n\t\treturn 0;\n\n\treturn cpuid_eax(0x0000001a) >> X86_HYBRID_CPU_TYPE_ID_SHIFT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}