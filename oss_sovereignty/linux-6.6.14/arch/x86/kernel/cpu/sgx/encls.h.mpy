{
  "module_name": "encls.h",
  "hash_id": "ff6f51172e6a17a7a668a725ff5fb9d4e52210a2e380ee3a3ec6e83f96a19f4e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/sgx/encls.h",
  "human_readable_source": " \n#ifndef _X86_ENCLS_H\n#define _X86_ENCLS_H\n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/rwsem.h>\n#include <linux/types.h>\n#include <asm/asm.h>\n#include <asm/traps.h>\n#include \"sgx.h\"\n\n \n#define ENCLS_TRAPNR(r) ((r) & ~SGX_ENCLS_FAULT_FLAG)\n\n \n#define ENCLS_WARN(r, name) {\t\t\t\t\t\t  \\\n\tdo {\t\t\t\t\t\t\t\t  \\\n\t\tint _r = (r);\t\t\t\t\t\t  \\\n\t\tWARN_ONCE(_r, \"%s returned %d (0x%x)\\n\", (name), _r, _r); \\\n\t} while (0);\t\t\t\t\t\t\t  \\\n}\n\n \nstatic inline bool encls_faulted(int ret)\n{\n\treturn ret & SGX_ENCLS_FAULT_FLAG;\n}\n\n \nstatic inline bool encls_failed(int ret)\n{\n\tif (encls_faulted(ret))\n\t\treturn ENCLS_TRAPNR(ret) != X86_TRAP_PF;\n\n\treturn !!ret;\n}\n\n \n#define __encls_ret_N(rax, inputs...)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\\\n\tasm volatile(\t\t\t\t\t\t\\\n\t\"1: .byte 0x0f, 0x01, 0xcf;\\n\\t\"\t\t\t\\\n\t\"2:\\n\"\t\t\t\t\t\t\t\\\n\t_ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_FAULT_SGX)\t\t\\\n\t: \"=a\"(ret)\t\t\t\t\t\t\\\n\t: \"a\"(rax), inputs\t\t\t\t\t\\\n\t: \"memory\", \"cc\");\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\\\n\t})\n\n#define __encls_ret_1(rax, rcx)\t\t\\\n\t({\t\t\t\t\\\n\t__encls_ret_N(rax, \"c\"(rcx));\t\\\n\t})\n\n#define __encls_ret_2(rax, rbx, rcx)\t\t\\\n\t({\t\t\t\t\t\\\n\t__encls_ret_N(rax, \"b\"(rbx), \"c\"(rcx));\t\\\n\t})\n\n#define __encls_ret_3(rax, rbx, rcx, rdx)\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\t__encls_ret_N(rax, \"b\"(rbx), \"c\"(rcx), \"d\"(rdx));\t\\\n\t})\n\n \n#define __encls_N(rax, rbx_out, inputs...)\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\\\n\tasm volatile(\t\t\t\t\t\t\\\n\t\"1: .byte 0x0f, 0x01, 0xcf;\\n\\t\"\t\t\t\\\n\t\"   xor %%eax,%%eax;\\n\"\t\t\t\t\t\\\n\t\"2:\\n\"\t\t\t\t\t\t\t\\\n\t_ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_FAULT_SGX)\t\t\\\n\t: \"=a\"(ret), \"=b\"(rbx_out)\t\t\t\t\\\n\t: \"a\"(rax), inputs\t\t\t\t\t\\\n\t: \"memory\");\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\\\n\t})\n\n#define __encls_2(rax, rbx, rcx)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\tunsigned long ign_rbx_out;\t\t\t\t\\\n\t__encls_N(rax, ign_rbx_out, \"b\"(rbx), \"c\"(rcx));\t\\\n\t})\n\n#define __encls_1_1(rax, data, rcx)\t\t\t\\\n\t({\t\t\t\t\t\t\\\n\tunsigned long rbx_out;\t\t\t\t\\\n\tint ret = __encls_N(rax, rbx_out, \"c\"(rcx));\t\\\n\tif (!ret)\t\t\t\t\t\\\n\t\tdata = rbx_out;\t\t\t\t\\\n\tret;\t\t\t\t\t\t\\\n\t})\n\n \nstatic inline int __ecreate(struct sgx_pageinfo *pginfo, void *secs)\n{\n\treturn __encls_2(ECREATE, pginfo, secs);\n}\n\n \nstatic inline int __eextend(void *secs, void *addr)\n{\n\treturn __encls_2(EEXTEND, secs, addr);\n}\n\n \nstatic inline int __eadd(struct sgx_pageinfo *pginfo, void *addr)\n{\n\treturn __encls_2(EADD, pginfo, addr);\n}\n\n \nstatic inline int __einit(void *sigstruct, void *token, void *secs)\n{\n\treturn __encls_ret_3(EINIT, sigstruct, secs, token);\n}\n\n \nstatic inline int __eremove(void *addr)\n{\n\treturn __encls_ret_1(EREMOVE, addr);\n}\n\n \nstatic inline int __edbgwr(void *addr, unsigned long *data)\n{\n\treturn __encls_2(EDGBWR, *data, addr);\n}\n\n \nstatic inline int __edbgrd(void *addr, unsigned long *data)\n{\n\treturn __encls_1_1(EDGBRD, *data, addr);\n}\n\n \nstatic inline int __etrack(void *addr)\n{\n\treturn __encls_ret_1(ETRACK, addr);\n}\n\n \nstatic inline int __eldu(struct sgx_pageinfo *pginfo, void *addr,\n\t\t\t void *va)\n{\n\treturn __encls_ret_3(ELDU, pginfo, addr, va);\n}\n\n \nstatic inline int __eblock(void *addr)\n{\n\treturn __encls_ret_1(EBLOCK, addr);\n}\n\n \nstatic inline int __epa(void *addr)\n{\n\tunsigned long rbx = SGX_PAGE_TYPE_VA;\n\n\treturn __encls_2(EPA, rbx, addr);\n}\n\n \nstatic inline int __ewb(struct sgx_pageinfo *pginfo, void *addr,\n\t\t\tvoid *va)\n{\n\treturn __encls_ret_3(EWB, pginfo, addr, va);\n}\n\n \nstatic inline int __emodpr(struct sgx_secinfo *secinfo, void *addr)\n{\n\treturn __encls_ret_2(EMODPR, secinfo, addr);\n}\n\n \nstatic inline int __emodt(struct sgx_secinfo *secinfo, void *addr)\n{\n\treturn __encls_ret_2(EMODT, secinfo, addr);\n}\n\n \nstatic inline int __eaug(struct sgx_pageinfo *pginfo, void *addr)\n{\n\treturn __encls_2(EAUG, pginfo, addr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}