{
  "module_name": "driver.c",
  "hash_id": "f04359b74ba82cea4a3a093eba8d04a601dbb81648f06e7dd565992b416a13b3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/sgx/driver.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/miscdevice.h>\n#include <linux/mman.h>\n#include <linux/security.h>\n#include <linux/suspend.h>\n#include <asm/traps.h>\n#include \"driver.h\"\n#include \"encl.h\"\n\nu64 sgx_attributes_reserved_mask;\nu64 sgx_xfrm_reserved_mask = ~0x3;\nu32 sgx_misc_reserved_mask;\n\nstatic int sgx_open(struct inode *inode, struct file *file)\n{\n\tstruct sgx_encl *encl;\n\tint ret;\n\n\tencl = kzalloc(sizeof(*encl), GFP_KERNEL);\n\tif (!encl)\n\t\treturn -ENOMEM;\n\n\tkref_init(&encl->refcount);\n\txa_init(&encl->page_array);\n\tmutex_init(&encl->lock);\n\tINIT_LIST_HEAD(&encl->va_pages);\n\tINIT_LIST_HEAD(&encl->mm_list);\n\tspin_lock_init(&encl->mm_lock);\n\n\tret = init_srcu_struct(&encl->srcu);\n\tif (ret) {\n\t\tkfree(encl);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = encl;\n\n\treturn 0;\n}\n\nstatic int sgx_release(struct inode *inode, struct file *file)\n{\n\tstruct sgx_encl *encl = file->private_data;\n\tstruct sgx_encl_mm *encl_mm;\n\n\t \n\tfor ( ; ; )  {\n\t\tspin_lock(&encl->mm_lock);\n\n\t\tif (list_empty(&encl->mm_list)) {\n\t\t\tencl_mm = NULL;\n\t\t} else {\n\t\t\tencl_mm = list_first_entry(&encl->mm_list,\n\t\t\t\t\t\t   struct sgx_encl_mm, list);\n\t\t\tlist_del_rcu(&encl_mm->list);\n\t\t}\n\n\t\tspin_unlock(&encl->mm_lock);\n\n\t\t \n\t\tif (!encl_mm)\n\t\t\tbreak;\n\n\t\tsynchronize_srcu(&encl->srcu);\n\t\tmmu_notifier_unregister(&encl_mm->mmu_notifier, encl_mm->mm);\n\t\tkfree(encl_mm);\n\n\t\t \n\t\tkref_put(&encl->refcount, sgx_encl_release);\n\t}\n\n\tkref_put(&encl->refcount, sgx_encl_release);\n\treturn 0;\n}\n\nstatic int sgx_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct sgx_encl *encl = file->private_data;\n\tint ret;\n\n\tret = sgx_encl_may_map(encl, vma->vm_start, vma->vm_end, vma->vm_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sgx_encl_mm_add(encl, vma->vm_mm);\n\tif (ret)\n\t\treturn ret;\n\n\tvma->vm_ops = &sgx_vm_ops;\n\tvm_flags_set(vma, VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP | VM_IO);\n\tvma->vm_private_data = encl;\n\n\treturn 0;\n}\n\nstatic unsigned long sgx_get_unmapped_area(struct file *file,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   unsigned long len,\n\t\t\t\t\t   unsigned long pgoff,\n\t\t\t\t\t   unsigned long flags)\n{\n\tif ((flags & MAP_TYPE) == MAP_PRIVATE)\n\t\treturn -EINVAL;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\treturn current->mm->get_unmapped_area(file, addr, len, pgoff, flags);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long sgx_compat_ioctl(struct file *filep, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn sgx_ioctl(filep, cmd, arg);\n}\n#endif\n\nstatic const struct file_operations sgx_encl_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= sgx_open,\n\t.release\t\t= sgx_release,\n\t.unlocked_ioctl\t\t= sgx_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sgx_compat_ioctl,\n#endif\n\t.mmap\t\t\t= sgx_mmap,\n\t.get_unmapped_area\t= sgx_get_unmapped_area,\n};\n\nstatic struct miscdevice sgx_dev_enclave = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"sgx_enclave\",\n\t.nodename = \"sgx_enclave\",\n\t.fops = &sgx_encl_fops,\n};\n\nint __init sgx_drv_init(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tu64 attr_mask;\n\tu64 xfrm_mask;\n\tint ret;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_SGX_LC))\n\t\treturn -ENODEV;\n\n\tcpuid_count(SGX_CPUID, 0, &eax, &ebx, &ecx, &edx);\n\n\tif (!(eax & 1))  {\n\t\tpr_err(\"SGX disabled: SGX1 instruction support not available.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsgx_misc_reserved_mask = ~ebx | SGX_MISC_RESERVED_MASK;\n\n\tcpuid_count(SGX_CPUID, 1, &eax, &ebx, &ecx, &edx);\n\n\tattr_mask = (((u64)ebx) << 32) + (u64)eax;\n\tsgx_attributes_reserved_mask = ~attr_mask | SGX_ATTR_RESERVED_MASK;\n\n\tif (cpu_feature_enabled(X86_FEATURE_OSXSAVE)) {\n\t\txfrm_mask = (((u64)edx) << 32) + (u64)ecx;\n\t\tsgx_xfrm_reserved_mask = ~xfrm_mask;\n\t}\n\n\tret = misc_register(&sgx_dev_enclave);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}