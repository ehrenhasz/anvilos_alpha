{
  "module_name": "encl.h",
  "hash_id": "8b1c6356cd308633762abb01dc20a39c9fea92f125d940bd542c8fdd9819a68c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/sgx/encl.h",
  "human_readable_source": " \n \n#ifndef _X86_ENCL_H\n#define _X86_ENCL_H\n\n#include <linux/cpumask.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/mm_types.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/srcu.h>\n#include <linux/workqueue.h>\n#include <linux/xarray.h>\n#include \"sgx.h\"\n\n \n#define SGX_ENCL_PAGE_VA_OFFSET_MASK\tGENMASK_ULL(11, 3)\n\n \n#define SGX_ENCL_PAGE_BEING_RECLAIMED\tBIT(3)\n\nstruct sgx_encl_page {\n\tunsigned long desc;\n\tunsigned long vm_max_prot_bits:8;\n\tenum sgx_page_type type:16;\n\tstruct sgx_epc_page *epc_page;\n\tstruct sgx_encl *encl;\n\tstruct sgx_va_page *va_page;\n};\n\nenum sgx_encl_flags {\n\tSGX_ENCL_IOCTL\t\t= BIT(0),\n\tSGX_ENCL_DEBUG\t\t= BIT(1),\n\tSGX_ENCL_CREATED\t= BIT(2),\n\tSGX_ENCL_INITIALIZED\t= BIT(3),\n};\n\nstruct sgx_encl_mm {\n\tstruct sgx_encl *encl;\n\tstruct mm_struct *mm;\n\tstruct list_head list;\n\tstruct mmu_notifier mmu_notifier;\n};\n\nstruct sgx_encl {\n\tunsigned long base;\n\tunsigned long size;\n\tunsigned long flags;\n\tunsigned int page_cnt;\n\tunsigned int secs_child_cnt;\n\tstruct mutex lock;\n\tstruct xarray page_array;\n\tstruct sgx_encl_page secs;\n\tunsigned long attributes;\n\tunsigned long attributes_mask;\n\n\tcpumask_t cpumask;\n\tstruct file *backing;\n\tstruct kref refcount;\n\tstruct list_head va_pages;\n\tunsigned long mm_list_version;\n\tstruct list_head mm_list;\n\tspinlock_t mm_lock;\n\tstruct srcu_struct srcu;\n};\n\n#define SGX_VA_SLOT_COUNT 512\n\nstruct sgx_va_page {\n\tstruct sgx_epc_page *epc_page;\n\tDECLARE_BITMAP(slots, SGX_VA_SLOT_COUNT);\n\tstruct list_head list;\n};\n\nstruct sgx_backing {\n\tstruct page *contents;\n\tstruct page *pcmd;\n\tunsigned long pcmd_offset;\n};\n\nextern const struct vm_operations_struct sgx_vm_ops;\n\nstatic inline int sgx_encl_find(struct mm_struct *mm, unsigned long addr,\n\t\t\t\tstruct vm_area_struct **vma)\n{\n\tstruct vm_area_struct *result;\n\n\tresult = vma_lookup(mm, addr);\n\tif (!result || result->vm_ops != &sgx_vm_ops)\n\t\treturn -EINVAL;\n\n\t*vma = result;\n\n\treturn 0;\n}\n\nint sgx_encl_may_map(struct sgx_encl *encl, unsigned long start,\n\t\t     unsigned long end, unsigned long vm_flags);\n\nbool current_is_ksgxd(void);\nvoid sgx_encl_release(struct kref *ref);\nint sgx_encl_mm_add(struct sgx_encl *encl, struct mm_struct *mm);\nconst cpumask_t *sgx_encl_cpumask(struct sgx_encl *encl);\nint sgx_encl_alloc_backing(struct sgx_encl *encl, unsigned long page_index,\n\t\t\t   struct sgx_backing *backing);\nvoid sgx_encl_put_backing(struct sgx_backing *backing);\nint sgx_encl_test_and_clear_young(struct mm_struct *mm,\n\t\t\t\t  struct sgx_encl_page *page);\nstruct sgx_encl_page *sgx_encl_page_alloc(struct sgx_encl *encl,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  u64 secinfo_flags);\nvoid sgx_zap_enclave_ptes(struct sgx_encl *encl, unsigned long addr);\nstruct sgx_epc_page *sgx_alloc_va_page(bool reclaim);\nunsigned int sgx_alloc_va_slot(struct sgx_va_page *va_page);\nvoid sgx_free_va_slot(struct sgx_va_page *va_page, unsigned int offset);\nbool sgx_va_page_full(struct sgx_va_page *va_page);\nvoid sgx_encl_free_epc_page(struct sgx_epc_page *page);\nstruct sgx_encl_page *sgx_encl_load_page(struct sgx_encl *encl,\n\t\t\t\t\t unsigned long addr);\nstruct sgx_va_page *sgx_encl_grow(struct sgx_encl *encl, bool reclaim);\nvoid sgx_encl_shrink(struct sgx_encl *encl, struct sgx_va_page *va_page);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}