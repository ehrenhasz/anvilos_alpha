{
  "module_name": "ioctl.c",
  "hash_id": "4bca9ca48016dc6a35820ea98ba3e5e7561b9f5d7a649e20fb0d473885821624",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/sgx/ioctl.c",
  "human_readable_source": "\n \n\n#include <asm/mman.h>\n#include <asm/sgx.h>\n#include <linux/mman.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/hashtable.h>\n#include <linux/highmem.h>\n#include <linux/ratelimit.h>\n#include <linux/sched/signal.h>\n#include <linux/shmem_fs.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include \"driver.h\"\n#include \"encl.h\"\n#include \"encls.h\"\n\nstruct sgx_va_page *sgx_encl_grow(struct sgx_encl *encl, bool reclaim)\n{\n\tstruct sgx_va_page *va_page = NULL;\n\tvoid *err;\n\n\tBUILD_BUG_ON(SGX_VA_SLOT_COUNT !=\n\t\t(SGX_ENCL_PAGE_VA_OFFSET_MASK >> 3) + 1);\n\n\tif (!(encl->page_cnt % SGX_VA_SLOT_COUNT)) {\n\t\tva_page = kzalloc(sizeof(*va_page), GFP_KERNEL);\n\t\tif (!va_page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tva_page->epc_page = sgx_alloc_va_page(reclaim);\n\t\tif (IS_ERR(va_page->epc_page)) {\n\t\t\terr = ERR_CAST(va_page->epc_page);\n\t\t\tkfree(va_page);\n\t\t\treturn err;\n\t\t}\n\n\t\tWARN_ON_ONCE(encl->page_cnt % SGX_VA_SLOT_COUNT);\n\t}\n\tencl->page_cnt++;\n\treturn va_page;\n}\n\nvoid sgx_encl_shrink(struct sgx_encl *encl, struct sgx_va_page *va_page)\n{\n\tencl->page_cnt--;\n\n\tif (va_page) {\n\t\tsgx_encl_free_epc_page(va_page->epc_page);\n\t\tlist_del(&va_page->list);\n\t\tkfree(va_page);\n\t}\n}\n\nstatic int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)\n{\n\tstruct sgx_epc_page *secs_epc;\n\tstruct sgx_va_page *va_page;\n\tstruct sgx_pageinfo pginfo;\n\tstruct sgx_secinfo secinfo;\n\tunsigned long encl_size;\n\tstruct file *backing;\n\tlong ret;\n\n\tva_page = sgx_encl_grow(encl, true);\n\tif (IS_ERR(va_page))\n\t\treturn PTR_ERR(va_page);\n\telse if (va_page)\n\t\tlist_add(&va_page->list, &encl->va_pages);\n\t \n\n\t \n\tencl_size = secs->size + PAGE_SIZE;\n\n\tbacking = shmem_file_setup(\"SGX backing\", encl_size + (encl_size >> 5),\n\t\t\t\t   VM_NORESERVE);\n\tif (IS_ERR(backing)) {\n\t\tret = PTR_ERR(backing);\n\t\tgoto err_out_shrink;\n\t}\n\n\tencl->backing = backing;\n\n\tsecs_epc = sgx_alloc_epc_page(&encl->secs, true);\n\tif (IS_ERR(secs_epc)) {\n\t\tret = PTR_ERR(secs_epc);\n\t\tgoto err_out_backing;\n\t}\n\n\tencl->secs.epc_page = secs_epc;\n\n\tpginfo.addr = 0;\n\tpginfo.contents = (unsigned long)secs;\n\tpginfo.metadata = (unsigned long)&secinfo;\n\tpginfo.secs = 0;\n\tmemset(&secinfo, 0, sizeof(secinfo));\n\n\tret = __ecreate((void *)&pginfo, sgx_get_epc_virt_addr(secs_epc));\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (secs->attributes & SGX_ATTR_DEBUG)\n\t\tset_bit(SGX_ENCL_DEBUG, &encl->flags);\n\n\tencl->secs.encl = encl;\n\tencl->secs.type = SGX_PAGE_TYPE_SECS;\n\tencl->base = secs->base;\n\tencl->size = secs->size;\n\tencl->attributes = secs->attributes;\n\tencl->attributes_mask = SGX_ATTR_UNPRIV_MASK;\n\n\t \n\tset_bit(SGX_ENCL_CREATED, &encl->flags);\n\n\treturn 0;\n\nerr_out:\n\tsgx_encl_free_epc_page(encl->secs.epc_page);\n\tencl->secs.epc_page = NULL;\n\nerr_out_backing:\n\tfput(encl->backing);\n\tencl->backing = NULL;\n\nerr_out_shrink:\n\tsgx_encl_shrink(encl, va_page);\n\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_create(struct sgx_encl *encl, void __user *arg)\n{\n\tstruct sgx_enclave_create create_arg;\n\tvoid *secs;\n\tint ret;\n\n\tif (test_bit(SGX_ENCL_CREATED, &encl->flags))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&create_arg, arg, sizeof(create_arg)))\n\t\treturn -EFAULT;\n\n\tsecs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!secs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(secs, (void __user *)create_arg.src, PAGE_SIZE))\n\t\tret = -EFAULT;\n\telse\n\t\tret = sgx_encl_create(encl, secs);\n\n\tkfree(secs);\n\treturn ret;\n}\n\nstatic int sgx_validate_secinfo(struct sgx_secinfo *secinfo)\n{\n\tu64 perm = secinfo->flags & SGX_SECINFO_PERMISSION_MASK;\n\tu64 pt   = secinfo->flags & SGX_SECINFO_PAGE_TYPE_MASK;\n\n\tif (pt != SGX_SECINFO_REG && pt != SGX_SECINFO_TCS)\n\t\treturn -EINVAL;\n\n\tif ((perm & SGX_SECINFO_W) && !(perm & SGX_SECINFO_R))\n\t\treturn -EINVAL;\n\n\t \n\tif (pt == SGX_SECINFO_TCS && perm)\n\t\treturn -EINVAL;\n\n\tif (secinfo->flags & SGX_SECINFO_RESERVED_MASK)\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(secinfo->reserved, 0, sizeof(secinfo->reserved)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __sgx_encl_add_page(struct sgx_encl *encl,\n\t\t\t       struct sgx_encl_page *encl_page,\n\t\t\t       struct sgx_epc_page *epc_page,\n\t\t\t       struct sgx_secinfo *secinfo, unsigned long src)\n{\n\tstruct sgx_pageinfo pginfo;\n\tstruct vm_area_struct *vma;\n\tstruct page *src_page;\n\tint ret;\n\n\t \n\tvma = find_vma(current->mm, src);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\tif (!(vma->vm_flags & VM_MAYEXEC))\n\t\treturn -EACCES;\n\n\tret = get_user_pages(src, 1, 0, &src_page);\n\tif (ret < 1)\n\t\treturn -EFAULT;\n\n\tpginfo.secs = (unsigned long)sgx_get_epc_virt_addr(encl->secs.epc_page);\n\tpginfo.addr = encl_page->desc & PAGE_MASK;\n\tpginfo.metadata = (unsigned long)secinfo;\n\tpginfo.contents = (unsigned long)kmap_local_page(src_page);\n\n\tret = __eadd(&pginfo, sgx_get_epc_virt_addr(epc_page));\n\n\tkunmap_local((void *)pginfo.contents);\n\tput_page(src_page);\n\n\treturn ret ? -EIO : 0;\n}\n\n \nstatic int __sgx_encl_extend(struct sgx_encl *encl,\n\t\t\t     struct sgx_epc_page *epc_page)\n{\n\tunsigned long offset;\n\tint ret;\n\n\tfor (offset = 0; offset < PAGE_SIZE; offset += SGX_EEXTEND_BLOCK_SIZE) {\n\t\tret = __eextend(sgx_get_epc_virt_addr(encl->secs.epc_page),\n\t\t\t\tsgx_get_epc_virt_addr(epc_page) + offset);\n\t\tif (ret) {\n\t\t\tif (encls_failed(ret))\n\t\t\t\tENCLS_WARN(ret, \"EEXTEND\");\n\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sgx_encl_add_page(struct sgx_encl *encl, unsigned long src,\n\t\t\t     unsigned long offset, struct sgx_secinfo *secinfo,\n\t\t\t     unsigned long flags)\n{\n\tstruct sgx_encl_page *encl_page;\n\tstruct sgx_epc_page *epc_page;\n\tstruct sgx_va_page *va_page;\n\tint ret;\n\n\tencl_page = sgx_encl_page_alloc(encl, offset, secinfo->flags);\n\tif (IS_ERR(encl_page))\n\t\treturn PTR_ERR(encl_page);\n\n\tepc_page = sgx_alloc_epc_page(encl_page, true);\n\tif (IS_ERR(epc_page)) {\n\t\tkfree(encl_page);\n\t\treturn PTR_ERR(epc_page);\n\t}\n\n\tva_page = sgx_encl_grow(encl, true);\n\tif (IS_ERR(va_page)) {\n\t\tret = PTR_ERR(va_page);\n\t\tgoto err_out_free;\n\t}\n\n\tmmap_read_lock(current->mm);\n\tmutex_lock(&encl->lock);\n\n\t \n\tif (va_page)\n\t\tlist_add(&va_page->list, &encl->va_pages);\n\n\t \n\tret = xa_insert(&encl->page_array, PFN_DOWN(encl_page->desc),\n\t\t\tencl_page, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_out_unlock;\n\n\tret = __sgx_encl_add_page(encl, encl_page, epc_page, secinfo,\n\t\t\t\t  src);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tencl_page->encl = encl;\n\tencl_page->epc_page = epc_page;\n\tencl_page->type = (secinfo->flags & SGX_SECINFO_PAGE_TYPE_MASK) >> 8;\n\tencl->secs_child_cnt++;\n\n\tif (flags & SGX_PAGE_MEASURE) {\n\t\tret = __sgx_encl_extend(encl, epc_page);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t}\n\n\tsgx_mark_page_reclaimable(encl_page->epc_page);\n\tmutex_unlock(&encl->lock);\n\tmmap_read_unlock(current->mm);\n\treturn ret;\n\nerr_out:\n\txa_erase(&encl->page_array, PFN_DOWN(encl_page->desc));\n\nerr_out_unlock:\n\tsgx_encl_shrink(encl, va_page);\n\tmutex_unlock(&encl->lock);\n\tmmap_read_unlock(current->mm);\n\nerr_out_free:\n\tsgx_encl_free_epc_page(epc_page);\n\tkfree(encl_page);\n\n\treturn ret;\n}\n\n \nstatic int sgx_validate_offset_length(struct sgx_encl *encl,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      unsigned long length)\n{\n\tif (!IS_ALIGNED(offset, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (!length || !IS_ALIGNED(length, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (offset + length < offset)\n\t\treturn -EINVAL;\n\n\tif (offset + length - PAGE_SIZE >= encl->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic long sgx_ioc_enclave_add_pages(struct sgx_encl *encl, void __user *arg)\n{\n\tstruct sgx_enclave_add_pages add_arg;\n\tstruct sgx_secinfo secinfo;\n\tunsigned long c;\n\tint ret;\n\n\tif (!test_bit(SGX_ENCL_CREATED, &encl->flags) ||\n\t    test_bit(SGX_ENCL_INITIALIZED, &encl->flags))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&add_arg, arg, sizeof(add_arg)))\n\t\treturn -EFAULT;\n\n\tif (!IS_ALIGNED(add_arg.src, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (sgx_validate_offset_length(encl, add_arg.offset, add_arg.length))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&secinfo, (void __user *)add_arg.secinfo,\n\t\t\t   sizeof(secinfo)))\n\t\treturn -EFAULT;\n\n\tif (sgx_validate_secinfo(&secinfo))\n\t\treturn -EINVAL;\n\n\tfor (c = 0 ; c < add_arg.length; c += PAGE_SIZE) {\n\t\tif (signal_pending(current)) {\n\t\t\tif (!c)\n\t\t\t\tret = -ERESTARTSYS;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tret = sgx_encl_add_page(encl, add_arg.src + c, add_arg.offset + c,\n\t\t\t\t\t&secinfo, add_arg.flags);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tadd_arg.count = c;\n\n\tif (copy_to_user(arg, &add_arg, sizeof(add_arg)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic int __sgx_get_key_hash(struct crypto_shash *tfm, const void *modulus,\n\t\t\t      void *hash)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\n\treturn crypto_shash_digest(shash, modulus, SGX_MODULUS_SIZE, hash);\n}\n\nstatic int sgx_get_key_hash(const void *modulus, void *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tret = __sgx_get_key_hash(tfm, modulus, hash);\n\n\tcrypto_free_shash(tfm);\n\treturn ret;\n}\n\nstatic int sgx_encl_init(struct sgx_encl *encl, struct sgx_sigstruct *sigstruct,\n\t\t\t void *token)\n{\n\tu64 mrsigner[4];\n\tint i, j;\n\tvoid *addr;\n\tint ret;\n\n\t \n\tif (encl->attributes & ~encl->attributes_mask)\n\t\treturn -EACCES;\n\n\t \n\tif (sigstruct->body.attributes & sigstruct->body.attributes_mask &\n\t    sgx_attributes_reserved_mask)\n\t\treturn -EINVAL;\n\n\tif (sigstruct->body.miscselect & sigstruct->body.misc_mask &\n\t    sgx_misc_reserved_mask)\n\t\treturn -EINVAL;\n\n\tif (sigstruct->body.xfrm & sigstruct->body.xfrm_mask &\n\t    sgx_xfrm_reserved_mask)\n\t\treturn -EINVAL;\n\n\tret = sgx_get_key_hash(sigstruct->modulus, mrsigner);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&encl->lock);\n\n\t \n\tfor (i = 0; i < SGX_EINIT_SLEEP_COUNT; i++) {\n\t\tfor (j = 0; j < SGX_EINIT_SPIN_COUNT; j++) {\n\t\t\taddr = sgx_get_epc_virt_addr(encl->secs.epc_page);\n\n\t\t\tpreempt_disable();\n\n\t\t\tsgx_update_lepubkeyhash(mrsigner);\n\n\t\t\tret = __einit(sigstruct, token, addr);\n\n\t\t\tpreempt_enable();\n\n\t\t\tif (ret == SGX_UNMASKED_EVENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (ret != SGX_UNMASKED_EVENT)\n\t\t\tbreak;\n\n\t\tmsleep_interruptible(SGX_EINIT_SLEEP_TIME);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (encls_faulted(ret)) {\n\t\tif (encls_failed(ret))\n\t\t\tENCLS_WARN(ret, \"EINIT\");\n\n\t\tret = -EIO;\n\t} else if (ret) {\n\t\tpr_debug(\"EINIT returned %d\\n\", ret);\n\t\tret = -EPERM;\n\t} else {\n\t\tset_bit(SGX_ENCL_INITIALIZED, &encl->flags);\n\t}\n\nerr_out:\n\tmutex_unlock(&encl->lock);\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_init(struct sgx_encl *encl, void __user *arg)\n{\n\tstruct sgx_sigstruct *sigstruct;\n\tstruct sgx_enclave_init init_arg;\n\tvoid *token;\n\tint ret;\n\n\tif (!test_bit(SGX_ENCL_CREATED, &encl->flags) ||\n\t    test_bit(SGX_ENCL_INITIALIZED, &encl->flags))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&init_arg, arg, sizeof(init_arg)))\n\t\treturn -EFAULT;\n\n\t \n\tsigstruct = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!sigstruct)\n\t\treturn -ENOMEM;\n\n\ttoken = (void *)((unsigned long)sigstruct + PAGE_SIZE / 2);\n\tmemset(token, 0, SGX_LAUNCH_TOKEN_SIZE);\n\n\tif (copy_from_user(sigstruct, (void __user *)init_arg.sigstruct,\n\t\t\t   sizeof(*sigstruct))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sigstruct->header.vendor != 0x0000 &&\n\t    sigstruct->header.vendor != 0x8086) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sgx_encl_init(encl, sigstruct, token);\n\nout:\n\tkfree(sigstruct);\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_provision(struct sgx_encl *encl, void __user *arg)\n{\n\tstruct sgx_enclave_provision params;\n\n\tif (copy_from_user(&params, arg, sizeof(params)))\n\t\treturn -EFAULT;\n\n\treturn sgx_set_attribute(&encl->attributes_mask, params.fd);\n}\n\n \nstatic int sgx_ioc_sgx2_ready(struct sgx_encl *encl)\n{\n\tif (!(cpu_feature_enabled(X86_FEATURE_SGX2)))\n\t\treturn -ENODEV;\n\n\tif (!test_bit(SGX_ENCL_INITIALIZED, &encl->flags))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int sgx_enclave_etrack(struct sgx_encl *encl)\n{\n\tvoid *epc_virt;\n\tint ret;\n\n\tepc_virt = sgx_get_epc_virt_addr(encl->secs.epc_page);\n\tret = __etrack(epc_virt);\n\tif (ret) {\n\t\t \n\t\tpr_err_once(\"ETRACK returned %d (0x%x)\", ret, ret);\n\t\t \n\t\ton_each_cpu_mask(sgx_encl_cpumask(encl), sgx_ipi_cb, NULL, 1);\n\t\tret = __etrack(epc_virt);\n\t\tif (ret) {\n\t\t\tpr_err_once(\"ETRACK repeat returned %d (0x%x)\",\n\t\t\t\t    ret, ret);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\ton_each_cpu_mask(sgx_encl_cpumask(encl), sgx_ipi_cb, NULL, 1);\n\n\treturn 0;\n}\n\n \nstatic long\nsgx_enclave_restrict_permissions(struct sgx_encl *encl,\n\t\t\t\t struct sgx_enclave_restrict_permissions *modp)\n{\n\tstruct sgx_encl_page *entry;\n\tstruct sgx_secinfo secinfo;\n\tunsigned long addr;\n\tunsigned long c;\n\tvoid *epc_virt;\n\tint ret;\n\n\tmemset(&secinfo, 0, sizeof(secinfo));\n\tsecinfo.flags = modp->permissions & SGX_SECINFO_PERMISSION_MASK;\n\n\tfor (c = 0 ; c < modp->length; c += PAGE_SIZE) {\n\t\taddr = encl->base + modp->offset + c;\n\n\t\tsgx_reclaim_direct();\n\n\t\tmutex_lock(&encl->lock);\n\n\t\tentry = sgx_encl_load_page(encl, addr);\n\t\tif (IS_ERR(entry)) {\n\t\t\tret = PTR_ERR(entry) == -EBUSY ? -EAGAIN : -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (entry->type != SGX_PAGE_TYPE_REG) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tepc_virt = sgx_get_epc_virt_addr(entry->epc_page);\n\t\tret = __emodpr(&secinfo, epc_virt);\n\t\tif (encls_faulted(ret)) {\n\t\t\t \n\t\t\tpr_err_once(\"EMODPR encountered exception %d\\n\",\n\t\t\t\t    ENCLS_TRAPNR(ret));\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (encls_failed(ret)) {\n\t\t\tmodp->result = ret;\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tret = sgx_enclave_etrack(encl);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmutex_unlock(&encl->lock);\n\t}\n\n\tret = 0;\n\tgoto out;\n\nout_unlock:\n\tmutex_unlock(&encl->lock);\nout:\n\tmodp->count = c;\n\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_restrict_permissions(struct sgx_encl *encl,\n\t\t\t\t\t\t void __user *arg)\n{\n\tstruct sgx_enclave_restrict_permissions params;\n\tlong ret;\n\n\tret = sgx_ioc_sgx2_ready(encl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&params, arg, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tif (sgx_validate_offset_length(encl, params.offset, params.length))\n\t\treturn -EINVAL;\n\n\tif (params.permissions & ~SGX_SECINFO_PERMISSION_MASK)\n\t\treturn -EINVAL;\n\n\t \n\tif ((params.permissions & SGX_SECINFO_W) &&\n\t    !(params.permissions & SGX_SECINFO_R))\n\t\treturn -EINVAL;\n\n\tif (params.result || params.count)\n\t\treturn -EINVAL;\n\n\tret = sgx_enclave_restrict_permissions(encl, &params);\n\n\tif (copy_to_user(arg, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\n \nstatic long sgx_enclave_modify_types(struct sgx_encl *encl,\n\t\t\t\t     struct sgx_enclave_modify_types *modt)\n{\n\tunsigned long max_prot_restore;\n\tenum sgx_page_type page_type;\n\tstruct sgx_encl_page *entry;\n\tstruct sgx_secinfo secinfo;\n\tunsigned long prot;\n\tunsigned long addr;\n\tunsigned long c;\n\tvoid *epc_virt;\n\tint ret;\n\n\tpage_type = modt->page_type & SGX_PAGE_TYPE_MASK;\n\n\t \n\tif (page_type != SGX_PAGE_TYPE_TCS && page_type != SGX_PAGE_TYPE_TRIM)\n\t\treturn -EINVAL;\n\n\tmemset(&secinfo, 0, sizeof(secinfo));\n\n\tsecinfo.flags = page_type << 8;\n\n\tfor (c = 0 ; c < modt->length; c += PAGE_SIZE) {\n\t\taddr = encl->base + modt->offset + c;\n\n\t\tsgx_reclaim_direct();\n\n\t\tmutex_lock(&encl->lock);\n\n\t\tentry = sgx_encl_load_page(encl, addr);\n\t\tif (IS_ERR(entry)) {\n\t\t\tret = PTR_ERR(entry) == -EBUSY ? -EAGAIN : -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (!(entry->type == SGX_PAGE_TYPE_REG ||\n\t\t      (entry->type == SGX_PAGE_TYPE_TCS &&\n\t\t       page_type == SGX_PAGE_TYPE_TRIM))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmax_prot_restore = entry->vm_max_prot_bits;\n\n\t\t \n\t\tif (entry->type == SGX_PAGE_TYPE_REG &&\n\t\t    page_type == SGX_PAGE_TYPE_TCS) {\n\t\t\tif (~entry->vm_max_prot_bits & (VM_READ | VM_WRITE)) {\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tprot = PROT_READ | PROT_WRITE;\n\t\t\tentry->vm_max_prot_bits = calc_vm_prot_bits(prot, 0);\n\n\t\t\t \n\t\t\tif (sgx_unmark_page_reclaimable(entry->epc_page)) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out_entry_changed;\n\t\t\t}\n\n\t\t\t \n\t\t\tmutex_unlock(&encl->lock);\n\n\t\t\tsgx_zap_enclave_ptes(encl, addr);\n\n\t\t\tmutex_lock(&encl->lock);\n\n\t\t\tsgx_mark_page_reclaimable(entry->epc_page);\n\t\t}\n\n\t\t \n\t\tepc_virt = sgx_get_epc_virt_addr(entry->epc_page);\n\t\tret = __emodt(&secinfo, epc_virt);\n\t\tif (encls_faulted(ret)) {\n\t\t\t \n\t\t\tpr_err_once(\"EMODT encountered exception %d\\n\",\n\t\t\t\t    ENCLS_TRAPNR(ret));\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_entry_changed;\n\t\t}\n\t\tif (encls_failed(ret)) {\n\t\t\tmodt->result = ret;\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_entry_changed;\n\t\t}\n\n\t\tret = sgx_enclave_etrack(encl);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tentry->type = page_type;\n\n\t\tmutex_unlock(&encl->lock);\n\t}\n\n\tret = 0;\n\tgoto out;\n\nout_entry_changed:\n\tentry->vm_max_prot_bits = max_prot_restore;\nout_unlock:\n\tmutex_unlock(&encl->lock);\nout:\n\tmodt->count = c;\n\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_modify_types(struct sgx_encl *encl,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct sgx_enclave_modify_types params;\n\tlong ret;\n\n\tret = sgx_ioc_sgx2_ready(encl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&params, arg, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tif (sgx_validate_offset_length(encl, params.offset, params.length))\n\t\treturn -EINVAL;\n\n\tif (params.page_type & ~SGX_PAGE_TYPE_MASK)\n\t\treturn -EINVAL;\n\n\tif (params.result || params.count)\n\t\treturn -EINVAL;\n\n\tret = sgx_enclave_modify_types(encl, &params);\n\n\tif (copy_to_user(arg, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\n \nstatic long sgx_encl_remove_pages(struct sgx_encl *encl,\n\t\t\t\t  struct sgx_enclave_remove_pages *params)\n{\n\tstruct sgx_encl_page *entry;\n\tstruct sgx_secinfo secinfo;\n\tunsigned long addr;\n\tunsigned long c;\n\tvoid *epc_virt;\n\tint ret;\n\n\tmemset(&secinfo, 0, sizeof(secinfo));\n\tsecinfo.flags = SGX_SECINFO_R | SGX_SECINFO_W | SGX_SECINFO_X;\n\n\tfor (c = 0 ; c < params->length; c += PAGE_SIZE) {\n\t\taddr = encl->base + params->offset + c;\n\n\t\tsgx_reclaim_direct();\n\n\t\tmutex_lock(&encl->lock);\n\n\t\tentry = sgx_encl_load_page(encl, addr);\n\t\tif (IS_ERR(entry)) {\n\t\t\tret = PTR_ERR(entry) == -EBUSY ? -EAGAIN : -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (entry->type != SGX_PAGE_TYPE_TRIM) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tepc_virt = sgx_get_epc_virt_addr(entry->epc_page);\n\t\tret = __emodpr(&secinfo, epc_virt);\n\t\tif (!encls_faulted(ret) || ENCLS_TRAPNR(ret) != X86_TRAP_PF) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (sgx_unmark_page_reclaimable(entry->epc_page)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&encl->lock);\n\n\t\tsgx_zap_enclave_ptes(encl, addr);\n\n\t\tmutex_lock(&encl->lock);\n\n\t\tsgx_encl_free_epc_page(entry->epc_page);\n\t\tencl->secs_child_cnt--;\n\t\tentry->epc_page = NULL;\n\t\txa_erase(&encl->page_array, PFN_DOWN(entry->desc));\n\t\tsgx_encl_shrink(encl, NULL);\n\t\tkfree(entry);\n\n\t\tmutex_unlock(&encl->lock);\n\t}\n\n\tret = 0;\n\tgoto out;\n\nout_unlock:\n\tmutex_unlock(&encl->lock);\nout:\n\tparams->count = c;\n\n\treturn ret;\n}\n\n \nstatic long sgx_ioc_enclave_remove_pages(struct sgx_encl *encl,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct sgx_enclave_remove_pages params;\n\tlong ret;\n\n\tret = sgx_ioc_sgx2_ready(encl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&params, arg, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tif (sgx_validate_offset_length(encl, params.offset, params.length))\n\t\treturn -EINVAL;\n\n\tif (params.count)\n\t\treturn -EINVAL;\n\n\tret = sgx_encl_remove_pages(encl, &params);\n\n\tif (copy_to_user(arg, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nlong sgx_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct sgx_encl *encl = filep->private_data;\n\tint ret;\n\n\tif (test_and_set_bit(SGX_ENCL_IOCTL, &encl->flags))\n\t\treturn -EBUSY;\n\n\tswitch (cmd) {\n\tcase SGX_IOC_ENCLAVE_CREATE:\n\t\tret = sgx_ioc_enclave_create(encl, (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_ADD_PAGES:\n\t\tret = sgx_ioc_enclave_add_pages(encl, (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_INIT:\n\t\tret = sgx_ioc_enclave_init(encl, (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_PROVISION:\n\t\tret = sgx_ioc_enclave_provision(encl, (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS:\n\t\tret = sgx_ioc_enclave_restrict_permissions(encl,\n\t\t\t\t\t\t\t   (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_MODIFY_TYPES:\n\t\tret = sgx_ioc_enclave_modify_types(encl, (void __user *)arg);\n\t\tbreak;\n\tcase SGX_IOC_ENCLAVE_REMOVE_PAGES:\n\t\tret = sgx_ioc_enclave_remove_pages(encl, (void __user *)arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\n\tclear_bit(SGX_ENCL_IOCTL, &encl->flags);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}