{
  "module_name": "sgx.h",
  "hash_id": "bb05b98314bec12d67136dbe88608b9a7cd05846ef86a034a7310abaf5e63f9c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cpu/sgx/sgx.h",
  "human_readable_source": " \n#ifndef _X86_SGX_H\n#define _X86_SGX_H\n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/rwsem.h>\n#include <linux/types.h>\n#include <asm/asm.h>\n#include <asm/sgx.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"sgx: \" fmt\n\n#define EREMOVE_ERROR_MESSAGE \\\n\t\"EREMOVE returned %d (0x%x) and an EPC page was leaked. SGX may become unusable. \" \\\n\t\"Refer to Documentation/arch/x86/sgx.rst for more information.\"\n\n#define SGX_MAX_EPC_SECTIONS\t\t8\n#define SGX_EEXTEND_BLOCK_SIZE\t\t256\n#define SGX_NR_TO_SCAN\t\t\t16\n#define SGX_NR_LOW_PAGES\t\t32\n#define SGX_NR_HIGH_PAGES\t\t64\n\n \n#define SGX_EPC_PAGE_RECLAIMER_TRACKED\tBIT(0)\n\n \n#define SGX_EPC_PAGE_IS_FREE\t\tBIT(1)\n\nstruct sgx_epc_page {\n\tunsigned int section;\n\tu16 flags;\n\tu16 poison;\n\tstruct sgx_encl_page *owner;\n\tstruct list_head list;\n};\n\n \nstruct sgx_numa_node {\n\tstruct list_head free_page_list;\n\tstruct list_head sgx_poison_page_list;\n\tunsigned long size;\n\tspinlock_t lock;\n};\n\n \nstruct sgx_epc_section {\n\tunsigned long phys_addr;\n\tvoid *virt_addr;\n\tstruct sgx_epc_page *pages;\n\tstruct sgx_numa_node *node;\n};\n\nextern struct sgx_epc_section sgx_epc_sections[SGX_MAX_EPC_SECTIONS];\n\nstatic inline unsigned long sgx_get_epc_phys_addr(struct sgx_epc_page *page)\n{\n\tstruct sgx_epc_section *section = &sgx_epc_sections[page->section];\n\tunsigned long index;\n\n\tindex = ((unsigned long)page - (unsigned long)section->pages) / sizeof(*page);\n\n\treturn section->phys_addr + index * PAGE_SIZE;\n}\n\nstatic inline void *sgx_get_epc_virt_addr(struct sgx_epc_page *page)\n{\n\tstruct sgx_epc_section *section = &sgx_epc_sections[page->section];\n\tunsigned long index;\n\n\tindex = ((unsigned long)page - (unsigned long)section->pages) / sizeof(*page);\n\n\treturn section->virt_addr + index * PAGE_SIZE;\n}\n\nstruct sgx_epc_page *__sgx_alloc_epc_page(void);\nvoid sgx_free_epc_page(struct sgx_epc_page *page);\n\nvoid sgx_reclaim_direct(void);\nvoid sgx_mark_page_reclaimable(struct sgx_epc_page *page);\nint sgx_unmark_page_reclaimable(struct sgx_epc_page *page);\nstruct sgx_epc_page *sgx_alloc_epc_page(void *owner, bool reclaim);\n\nvoid sgx_ipi_cb(void *info);\n\n#ifdef CONFIG_X86_SGX_KVM\nint __init sgx_vepc_init(void);\n#else\nstatic inline int __init sgx_vepc_init(void)\n{\n\treturn -ENODEV;\n}\n#endif\n\nvoid sgx_update_lepubkeyhash(u64 *lepubkeyhash);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}