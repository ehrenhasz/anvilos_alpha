{
  "module_name": "ksysfs.c",
  "hash_id": "71a6ba6a5677c604493a04c29dbc97fd786ca8dd020a4150966994f62e1bdade",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/ksysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n\n#include <asm/setup.h>\n\nstatic ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"0x%04x\\n\", boot_params.hdr.version);\n}\n\nstatic struct kobj_attribute boot_params_version_attr = __ATTR_RO(version);\n\nstatic ssize_t boot_params_data_read(struct file *fp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *bin_attr,\n\t\t\t\t     char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, (void *)&boot_params + off, count);\n\treturn count;\n}\n\nstatic struct bin_attribute boot_params_data_attr = {\n\t.attr = {\n\t\t.name = \"data\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.read = boot_params_data_read,\n\t.size = sizeof(boot_params),\n};\n\nstatic struct attribute *boot_params_version_attrs[] = {\n\t&boot_params_version_attr.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *boot_params_data_attrs[] = {\n\t&boot_params_data_attr,\n\tNULL,\n};\n\nstatic const struct attribute_group boot_params_attr_group = {\n\t.attrs = boot_params_version_attrs,\n\t.bin_attrs = boot_params_data_attrs,\n};\n\nstatic int kobj_to_setup_data_nr(struct kobject *kobj, int *nr)\n{\n\tconst char *name;\n\n\tname = kobject_name(kobj);\n\treturn kstrtoint(name, 10, nr);\n}\n\nstatic int get_setup_data_paddr(int nr, u64 *paddr)\n{\n\tint i = 0;\n\tstruct setup_data *data;\n\tu64 pa_data = boot_params.hdr.setup_data;\n\n\twhile (pa_data) {\n\t\tif (nr == i) {\n\t\t\t*paddr = pa_data;\n\t\t\treturn 0;\n\t\t}\n\t\tdata = memremap(pa_data, sizeof(*data), MEMREMAP_WB);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tpa_data = data->next;\n\t\tmemunmap(data);\n\t\ti++;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int __init get_setup_data_size(int nr, size_t *size)\n{\n\tu64 pa_data = boot_params.hdr.setup_data, pa_next;\n\tstruct setup_indirect *indirect;\n\tstruct setup_data *data;\n\tint i = 0;\n\tu32 len;\n\n\twhile (pa_data) {\n\t\tdata = memremap(pa_data, sizeof(*data), MEMREMAP_WB);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tpa_next = data->next;\n\n\t\tif (nr == i) {\n\t\t\tif (data->type == SETUP_INDIRECT) {\n\t\t\t\tlen = sizeof(*data) + data->len;\n\t\t\t\tmemunmap(data);\n\t\t\t\tdata = memremap(pa_data, len, MEMREMAP_WB);\n\t\t\t\tif (!data)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\t\t\tif (indirect->type != SETUP_INDIRECT)\n\t\t\t\t\t*size = indirect->len;\n\t\t\t\telse\n\t\t\t\t\t*size = data->len;\n\t\t\t} else {\n\t\t\t\t*size = data->len;\n\t\t\t}\n\n\t\t\tmemunmap(data);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpa_data = pa_next;\n\t\tmemunmap(data);\n\t\ti++;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t type_show(struct kobject *kobj,\n\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\tstruct setup_indirect *indirect;\n\tstruct setup_data *data;\n\tint nr, ret;\n\tu64 paddr;\n\tu32 len;\n\n\tret = kobj_to_setup_data_nr(kobj, &nr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_setup_data_paddr(nr, &paddr);\n\tif (ret)\n\t\treturn ret;\n\tdata = memremap(paddr, sizeof(*data), MEMREMAP_WB);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (data->type == SETUP_INDIRECT) {\n\t\tlen = sizeof(*data) + data->len;\n\t\tmemunmap(data);\n\t\tdata = memremap(paddr, len, MEMREMAP_WB);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\tret = sprintf(buf, \"0x%x\\n\", indirect->type);\n\t} else {\n\t\tret = sprintf(buf, \"0x%x\\n\", data->type);\n\t}\n\n\tmemunmap(data);\n\treturn ret;\n}\n\nstatic ssize_t setup_data_data_read(struct file *fp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t\t    char *buf,\n\t\t\t\t    loff_t off, size_t count)\n{\n\tstruct setup_indirect *indirect;\n\tstruct setup_data *data;\n\tint nr, ret = 0;\n\tu64 paddr, len;\n\tvoid *p;\n\n\tret = kobj_to_setup_data_nr(kobj, &nr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_setup_data_paddr(nr, &paddr);\n\tif (ret)\n\t\treturn ret;\n\tdata = memremap(paddr, sizeof(*data), MEMREMAP_WB);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (data->type == SETUP_INDIRECT) {\n\t\tlen = sizeof(*data) + data->len;\n\t\tmemunmap(data);\n\t\tdata = memremap(paddr, len, MEMREMAP_WB);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\tif (indirect->type != SETUP_INDIRECT) {\n\t\t\tpaddr = indirect->addr;\n\t\t\tlen = indirect->len;\n\t\t} else {\n\t\t\t \n\t\t\tpaddr += sizeof(*data);\n\t\t\tlen = data->len;\n\t\t}\n\t} else {\n\t\tpaddr += sizeof(*data);\n\t\tlen = data->len;\n\t}\n\n\tif (off > len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (count > len - off)\n\t\tcount = len - off;\n\n\tif (!count)\n\t\tgoto out;\n\n\tret = count;\n\tp = memremap(paddr, len, MEMREMAP_WB);\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(buf, p + off, count);\n\tmemunmap(p);\nout:\n\tmemunmap(data);\n\treturn ret;\n}\n\nstatic struct kobj_attribute type_attr = __ATTR_RO(type);\n\nstatic struct bin_attribute data_attr __ro_after_init = {\n\t.attr = {\n\t\t.name = \"data\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.read = setup_data_data_read,\n};\n\nstatic struct attribute *setup_data_type_attrs[] = {\n\t&type_attr.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *setup_data_data_attrs[] = {\n\t&data_attr,\n\tNULL,\n};\n\nstatic const struct attribute_group setup_data_attr_group = {\n\t.attrs = setup_data_type_attrs,\n\t.bin_attrs = setup_data_data_attrs,\n};\n\nstatic int __init create_setup_data_node(struct kobject *parent,\n\t\t\t\t\t struct kobject **kobjp, int nr)\n{\n\tint ret = 0;\n\tsize_t size;\n\tstruct kobject *kobj;\n\tchar name[16];  \n\tsnprintf(name, 16, \"%d\", nr);\n\n\tkobj = kobject_create_and_add(name, parent);\n\tif (!kobj)\n\t\treturn -ENOMEM;\n\n\tret = get_setup_data_size(nr, &size);\n\tif (ret)\n\t\tgoto out_kobj;\n\n\tdata_attr.size = size;\n\tret = sysfs_create_group(kobj, &setup_data_attr_group);\n\tif (ret)\n\t\tgoto out_kobj;\n\t*kobjp = kobj;\n\n\treturn 0;\nout_kobj:\n\tkobject_put(kobj);\n\treturn ret;\n}\n\nstatic void __init cleanup_setup_data_node(struct kobject *kobj)\n{\n\tsysfs_remove_group(kobj, &setup_data_attr_group);\n\tkobject_put(kobj);\n}\n\nstatic int __init get_setup_data_total_num(u64 pa_data, int *nr)\n{\n\tint ret = 0;\n\tstruct setup_data *data;\n\n\t*nr = 0;\n\twhile (pa_data) {\n\t\t*nr += 1;\n\t\tdata = memremap(pa_data, sizeof(*data), MEMREMAP_WB);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpa_data = data->next;\n\t\tmemunmap(data);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __init create_setup_data_nodes(struct kobject *parent)\n{\n\tstruct kobject *setup_data_kobj, **kobjp;\n\tu64 pa_data;\n\tint i, j, nr, ret = 0;\n\n\tpa_data = boot_params.hdr.setup_data;\n\tif (!pa_data)\n\t\treturn 0;\n\n\tsetup_data_kobj = kobject_create_and_add(\"setup_data\", parent);\n\tif (!setup_data_kobj) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = get_setup_data_total_num(pa_data, &nr);\n\tif (ret)\n\t\tgoto out_setup_data_kobj;\n\n\tkobjp = kmalloc_array(nr, sizeof(*kobjp), GFP_KERNEL);\n\tif (!kobjp) {\n\t\tret = -ENOMEM;\n\t\tgoto out_setup_data_kobj;\n\t}\n\n\tfor (i = 0; i < nr; i++) {\n\t\tret = create_setup_data_node(setup_data_kobj, kobjp + i, i);\n\t\tif (ret)\n\t\t\tgoto out_clean_nodes;\n\t}\n\n\tkfree(kobjp);\n\treturn 0;\n\nout_clean_nodes:\n\tfor (j = i - 1; j >= 0; j--)\n\t\tcleanup_setup_data_node(*(kobjp + j));\n\tkfree(kobjp);\nout_setup_data_kobj:\n\tkobject_put(setup_data_kobj);\nout:\n\treturn ret;\n}\n\nstatic int __init boot_params_ksysfs_init(void)\n{\n\tint ret;\n\tstruct kobject *boot_params_kobj;\n\n\tboot_params_kobj = kobject_create_and_add(\"boot_params\",\n\t\t\t\t\t\t  kernel_kobj);\n\tif (!boot_params_kobj) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = sysfs_create_group(boot_params_kobj, &boot_params_attr_group);\n\tif (ret)\n\t\tgoto out_boot_params_kobj;\n\n\tret = create_setup_data_nodes(boot_params_kobj);\n\tif (ret)\n\t\tgoto out_create_group;\n\n\treturn 0;\nout_create_group:\n\tsysfs_remove_group(boot_params_kobj, &boot_params_attr_group);\nout_boot_params_kobj:\n\tkobject_put(boot_params_kobj);\nout:\n\treturn ret;\n}\n\narch_initcall(boot_params_ksysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}