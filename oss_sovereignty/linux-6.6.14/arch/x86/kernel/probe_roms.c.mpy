{
  "module_name": "probe_roms.c",
  "hash_id": "aff8fd69d3b619a6fdbaf9acba87b0b0c21c43ebb9af086b28a9789ad28118ea",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/probe_roms.c",
  "human_readable_source": "\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/mmzone.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/edd.h>\n#include <linux/dmi.h>\n#include <linux/pfn.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n\n#include <asm/probe_roms.h>\n#include <asm/pci-direct.h>\n#include <asm/e820/api.h>\n#include <asm/mmzone.h>\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <asm/io.h>\n#include <asm/setup_arch.h>\n#include <asm/sev.h>\n\nstatic struct resource system_rom_resource = {\n\t.name\t= \"System ROM\",\n\t.start\t= 0xf0000,\n\t.end\t= 0xfffff,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n};\n\nstatic struct resource extension_rom_resource = {\n\t.name\t= \"Extension ROM\",\n\t.start\t= 0xe0000,\n\t.end\t= 0xeffff,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n};\n\nstatic struct resource adapter_rom_resources[] = { {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0xc8000,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n}, {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n}, {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n}, {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n}, {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n}, {\n\t.name \t= \"Adapter ROM\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n} };\n\nstatic struct resource video_rom_resource = {\n\t.name \t= \"Video ROM\",\n\t.start\t= 0xc0000,\n\t.end\t= 0xc7fff,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_READONLY | IORESOURCE_MEM\n};\n\n \nstatic bool match_id(struct pci_dev *pdev, unsigned short vendor, unsigned short device)\n{\n\tstruct pci_driver *drv = to_pci_driver(pdev->dev.driver);\n\tconst struct pci_device_id *id;\n\n\tif (pdev->vendor == vendor && pdev->device == device)\n\t\treturn true;\n\n\tfor (id = drv ? drv->id_table : NULL; id && id->vendor; id++)\n\t\tif (id->vendor == vendor && id->device == device)\n\t\t\tbreak;\n\n\treturn id && id->vendor;\n}\n\nstatic bool probe_list(struct pci_dev *pdev, unsigned short vendor,\n\t\t       const void *rom_list)\n{\n\tunsigned short device;\n\n\tdo {\n\t\tif (get_kernel_nofault(device, rom_list) != 0)\n\t\t\tdevice = 0;\n\n\t\tif (device && match_id(pdev, vendor, device))\n\t\t\tbreak;\n\n\t\trom_list += 2;\n\t} while (device);\n\n\treturn !!device;\n}\n\nstatic struct resource *find_oprom(struct pci_dev *pdev)\n{\n\tstruct resource *oprom = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adapter_rom_resources); i++) {\n\t\tstruct resource *res = &adapter_rom_resources[i];\n\t\tunsigned short offset, vendor, device, list, rev;\n\t\tconst void *rom;\n\n\t\tif (res->end == 0)\n\t\t\tbreak;\n\n\t\trom = isa_bus_to_virt(res->start);\n\t\tif (get_kernel_nofault(offset, rom + 0x18) != 0)\n\t\t\tcontinue;\n\n\t\tif (get_kernel_nofault(vendor, rom + offset + 0x4) != 0)\n\t\t\tcontinue;\n\n\t\tif (get_kernel_nofault(device, rom + offset + 0x6) != 0)\n\t\t\tcontinue;\n\n\t\tif (match_id(pdev, vendor, device)) {\n\t\t\toprom = res;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_kernel_nofault(list, rom + offset + 0x8) == 0 &&\n\t\t    get_kernel_nofault(rev, rom + offset + 0xc) == 0 &&\n\t\t    rev >= 3 && list &&\n\t\t    probe_list(pdev, vendor, rom + offset + list)) {\n\t\t\toprom = res;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn oprom;\n}\n\nvoid __iomem *pci_map_biosrom(struct pci_dev *pdev)\n{\n\tstruct resource *oprom = find_oprom(pdev);\n\n\tif (!oprom)\n\t\treturn NULL;\n\n\treturn ioremap(oprom->start, resource_size(oprom));\n}\nEXPORT_SYMBOL(pci_map_biosrom);\n\nvoid pci_unmap_biosrom(void __iomem *image)\n{\n\tiounmap(image);\n}\nEXPORT_SYMBOL(pci_unmap_biosrom);\n\nsize_t pci_biosrom_size(struct pci_dev *pdev)\n{\n\tstruct resource *oprom = find_oprom(pdev);\n\n\treturn oprom ? resource_size(oprom) : 0;\n}\nEXPORT_SYMBOL(pci_biosrom_size);\n\n#define ROMSIGNATURE 0xaa55\n\nstatic int __init romsignature(const unsigned char *rom)\n{\n\tconst unsigned short * const ptr = (const unsigned short *)rom;\n\tunsigned short sig;\n\n\treturn get_kernel_nofault(sig, ptr) == 0 && sig == ROMSIGNATURE;\n}\n\nstatic int __init romchecksum(const unsigned char *rom, unsigned long length)\n{\n\tunsigned char sum, c;\n\n\tfor (sum = 0; length && get_kernel_nofault(c, rom++) == 0; length--)\n\t\tsum += c;\n\treturn !length && !sum;\n}\n\nvoid __init probe_roms(void)\n{\n\tunsigned long start, length, upper;\n\tconst unsigned char *rom;\n\tunsigned char c;\n\tint i;\n\n\t \n\tsnp_prep_memory(video_rom_resource.start,\n\t\t\t((system_rom_resource.end + 1) - video_rom_resource.start),\n\t\t\tSNP_PAGE_STATE_PRIVATE);\n\n\t \n\tupper = adapter_rom_resources[0].start;\n\tfor (start = video_rom_resource.start; start < upper; start += 2048) {\n\t\trom = isa_bus_to_virt(start);\n\t\tif (!romsignature(rom))\n\t\t\tcontinue;\n\n\t\tvideo_rom_resource.start = start;\n\n\t\tif (get_kernel_nofault(c, rom + 2) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tlength = c * 512;\n\n\t\t \n\t\tif (length && romchecksum(rom, length))\n\t\t\tvideo_rom_resource.end = start + length - 1;\n\n\t\trequest_resource(&iomem_resource, &video_rom_resource);\n\t\tbreak;\n\t}\n\n\tstart = (video_rom_resource.end + 1 + 2047) & ~2047UL;\n\tif (start < upper)\n\t\tstart = upper;\n\n\t \n\trequest_resource(&iomem_resource, &system_rom_resource);\n\tupper = system_rom_resource.start;\n\n\t \n\trom = isa_bus_to_virt(extension_rom_resource.start);\n\tif (romsignature(rom)) {\n\t\tlength = resource_size(&extension_rom_resource);\n\t\tif (romchecksum(rom, length)) {\n\t\t\trequest_resource(&iomem_resource, &extension_rom_resource);\n\t\t\tupper = extension_rom_resource.start;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(adapter_rom_resources) && start < upper; start += 2048) {\n\t\trom = isa_bus_to_virt(start);\n\t\tif (!romsignature(rom))\n\t\t\tcontinue;\n\n\t\tif (get_kernel_nofault(c, rom + 2) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tlength = c * 512;\n\n\t\t \n\t\tif (!length || start + length > upper || !romchecksum(rom, length))\n\t\t\tcontinue;\n\n\t\tadapter_rom_resources[i].start = start;\n\t\tadapter_rom_resources[i].end = start + length - 1;\n\t\trequest_resource(&iomem_resource, &adapter_rom_resources[i]);\n\n\t\tstart = adapter_rom_resources[i++].end & ~2047UL;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}