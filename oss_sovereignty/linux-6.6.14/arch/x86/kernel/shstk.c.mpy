{
  "module_name": "shstk.c",
  "hash_id": "3f747e79c6b0bb88732617e62a4a358f5891ee16bdee86f12c92ea1ec86b5cbe",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/shstk.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/sizes.h>\n#include <linux/user.h>\n#include <linux/syscalls.h>\n#include <asm/msr.h>\n#include <asm/fpu/xstate.h>\n#include <asm/fpu/types.h>\n#include <asm/shstk.h>\n#include <asm/special_insns.h>\n#include <asm/fpu/api.h>\n#include <asm/prctl.h>\n\n#define SS_FRAME_SIZE 8\n\nstatic bool features_enabled(unsigned long features)\n{\n\treturn current->thread.features & features;\n}\n\nstatic void features_set(unsigned long features)\n{\n\tcurrent->thread.features |= features;\n}\n\nstatic void features_clr(unsigned long features)\n{\n\tcurrent->thread.features &= ~features;\n}\n\n \nstatic int create_rstor_token(unsigned long ssp, unsigned long *token_addr)\n{\n\tunsigned long addr;\n\n\t \n\tif (!IS_ALIGNED(ssp, 8))\n\t\treturn -EINVAL;\n\n\taddr = ssp - SS_FRAME_SIZE;\n\n\t \n\tssp |= BIT(0);\n\n\tif (write_user_shstk_64((u64 __user *)addr, (u64)ssp))\n\t\treturn -EFAULT;\n\n\tif (token_addr)\n\t\t*token_addr = addr;\n\n\treturn 0;\n}\n\n \nstatic unsigned long alloc_shstk(unsigned long addr, unsigned long size,\n\t\t\t\t unsigned long token_offset, bool set_res_tok)\n{\n\tint flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_ABOVE4G;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long mapped_addr, unused;\n\n\tif (addr)\n\t\tflags |= MAP_FIXED_NOREPLACE;\n\n\tmmap_write_lock(mm);\n\tmapped_addr = do_mmap(NULL, addr, size, PROT_READ, flags,\n\t\t\t      VM_SHADOW_STACK | VM_WRITE, 0, &unused, NULL);\n\tmmap_write_unlock(mm);\n\n\tif (!set_res_tok || IS_ERR_VALUE(mapped_addr))\n\t\tgoto out;\n\n\tif (create_rstor_token(mapped_addr + token_offset, NULL)) {\n\t\tvm_munmap(mapped_addr, size);\n\t\treturn -EINVAL;\n\t}\n\nout:\n\treturn mapped_addr;\n}\n\nstatic unsigned long adjust_shstk_size(unsigned long size)\n{\n\tif (size)\n\t\treturn PAGE_ALIGN(size);\n\n\treturn PAGE_ALIGN(min_t(unsigned long long, rlimit(RLIMIT_STACK), SZ_4G));\n}\n\nstatic void unmap_shadow_stack(u64 base, u64 size)\n{\n\tint r;\n\n\tr = vm_munmap(base, size);\n\n\t \n\tif (r == -EINTR)\n\t\treturn;\n\n\t \n\tWARN_ON_ONCE(r);\n}\n\nstatic int shstk_setup(void)\n{\n\tstruct thread_shstk *shstk = &current->thread.shstk;\n\tunsigned long addr, size;\n\n\t \n\tif (features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn 0;\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) || in_32bit_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\tsize = adjust_shstk_size(0);\n\taddr = alloc_shstk(0, size, 0, false);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn PTR_ERR((void *)addr);\n\n\tfpregs_lock_and_load();\n\twrmsrl(MSR_IA32_PL3_SSP, addr + size);\n\twrmsrl(MSR_IA32_U_CET, CET_SHSTK_EN);\n\tfpregs_unlock();\n\n\tshstk->base = addr;\n\tshstk->size = size;\n\tfeatures_set(ARCH_SHSTK_SHSTK);\n\n\treturn 0;\n}\n\nvoid reset_thread_features(void)\n{\n\tmemset(&current->thread.shstk, 0, sizeof(struct thread_shstk));\n\tcurrent->thread.features = 0;\n\tcurrent->thread.features_locked = 0;\n}\n\nunsigned long shstk_alloc_thread_stack(struct task_struct *tsk, unsigned long clone_flags,\n\t\t\t\t       unsigned long stack_size)\n{\n\tstruct thread_shstk *shstk = &tsk->thread.shstk;\n\tunsigned long addr, size;\n\n\t \n\tif (!features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn 0;\n\n\t \n\tif (clone_flags & CLONE_VFORK) {\n\t\tshstk->base = 0;\n\t\tshstk->size = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(clone_flags & CLONE_VM))\n\t\treturn 0;\n\n\tsize = adjust_shstk_size(stack_size);\n\taddr = alloc_shstk(0, size, 0, false);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tshstk->base = addr;\n\tshstk->size = size;\n\n\treturn addr + size;\n}\n\nstatic unsigned long get_user_shstk_addr(void)\n{\n\tunsigned long long ssp;\n\n\tfpregs_lock_and_load();\n\n\trdmsrl(MSR_IA32_PL3_SSP, ssp);\n\n\tfpregs_unlock();\n\n\treturn ssp;\n}\n\n#define SHSTK_DATA_BIT BIT(63)\n\nstatic int put_shstk_data(u64 __user *addr, u64 data)\n{\n\tif (WARN_ON_ONCE(data & SHSTK_DATA_BIT))\n\t\treturn -EINVAL;\n\n\t \n\tif (write_user_shstk_64(addr, data | SHSTK_DATA_BIT))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int get_shstk_data(unsigned long *data, unsigned long __user *addr)\n{\n\tunsigned long ldata;\n\n\tif (unlikely(get_user(ldata, addr)))\n\t\treturn -EFAULT;\n\n\tif (!(ldata & SHSTK_DATA_BIT))\n\t\treturn -EINVAL;\n\n\t*data = ldata & ~SHSTK_DATA_BIT;\n\n\treturn 0;\n}\n\nstatic int shstk_push_sigframe(unsigned long *ssp)\n{\n\tunsigned long target_ssp = *ssp;\n\n\t \n\tif (!IS_ALIGNED(target_ssp, 8))\n\t\treturn -EINVAL;\n\n\t*ssp -= SS_FRAME_SIZE;\n\tif (put_shstk_data((void __user *)*ssp, target_ssp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int shstk_pop_sigframe(unsigned long *ssp)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long token_addr;\n\tbool need_to_check_vma;\n\tint err = 1;\n\n\t \n\tif (!IS_ALIGNED(*ssp, 8))\n\t\treturn -EINVAL;\n\n\tneed_to_check_vma = PAGE_ALIGN(*ssp) == *ssp;\n\n\tif (need_to_check_vma)\n\t\tmmap_read_lock_killable(current->mm);\n\n\terr = get_shstk_data(&token_addr, (unsigned long __user *)*ssp);\n\tif (unlikely(err))\n\t\tgoto out_err;\n\n\tif (need_to_check_vma) {\n\t\tvma = find_vma(current->mm, *ssp);\n\t\tif (!vma || !(vma->vm_flags & VM_SHADOW_STACK)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tmmap_read_unlock(current->mm);\n\t}\n\n\t \n\tif (unlikely(!IS_ALIGNED(token_addr, 8)))\n\t\treturn -EINVAL;\n\n\t \n\tif (unlikely(token_addr >= TASK_SIZE_MAX))\n\t\treturn -EINVAL;\n\n\t*ssp = token_addr;\n\n\treturn 0;\nout_err:\n\tif (need_to_check_vma)\n\t\tmmap_read_unlock(current->mm);\n\treturn err;\n}\n\nint setup_signal_shadow_stack(struct ksignal *ksig)\n{\n\tvoid __user *restorer = ksig->ka.sa.sa_restorer;\n\tunsigned long ssp;\n\tint err;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n\t    !features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn 0;\n\n\tif (!restorer)\n\t\treturn -EINVAL;\n\n\tssp = get_user_shstk_addr();\n\tif (unlikely(!ssp))\n\t\treturn -EINVAL;\n\n\terr = shstk_push_sigframe(&ssp);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t \n\tssp -= SS_FRAME_SIZE;\n\terr = write_user_shstk_64((u64 __user *)ssp, (u64)restorer);\n\tif (unlikely(err))\n\t\treturn -EFAULT;\n\n\tfpregs_lock_and_load();\n\twrmsrl(MSR_IA32_PL3_SSP, ssp);\n\tfpregs_unlock();\n\n\treturn 0;\n}\n\nint restore_signal_shadow_stack(void)\n{\n\tunsigned long ssp;\n\tint err;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n\t    !features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn 0;\n\n\tssp = get_user_shstk_addr();\n\tif (unlikely(!ssp))\n\t\treturn -EINVAL;\n\n\terr = shstk_pop_sigframe(&ssp);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tfpregs_lock_and_load();\n\twrmsrl(MSR_IA32_PL3_SSP, ssp);\n\tfpregs_unlock();\n\n\treturn 0;\n}\n\nvoid shstk_free(struct task_struct *tsk)\n{\n\tstruct thread_shstk *shstk = &tsk->thread.shstk;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n\t    !features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn;\n\n\t \n\tif (!tsk->mm || tsk->mm != current->mm)\n\t\treturn;\n\n\t \n\tif (!shstk->base)\n\t\treturn;\n\n\t \n\tif (WARN_ON(!shstk->size))\n\t\treturn;\n\n\tunmap_shadow_stack(shstk->base, shstk->size);\n\n\tshstk->size = 0;\n}\n\nstatic int wrss_control(bool enable)\n{\n\tu64 msrval;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn -EPERM;\n\n\t \n\tif (features_enabled(ARCH_SHSTK_WRSS) == enable)\n\t\treturn 0;\n\n\tfpregs_lock_and_load();\n\trdmsrl(MSR_IA32_U_CET, msrval);\n\n\tif (enable) {\n\t\tfeatures_set(ARCH_SHSTK_WRSS);\n\t\tmsrval |= CET_WRSS_EN;\n\t} else {\n\t\tfeatures_clr(ARCH_SHSTK_WRSS);\n\t\tif (!(msrval & CET_WRSS_EN))\n\t\t\tgoto unlock;\n\n\t\tmsrval &= ~CET_WRSS_EN;\n\t}\n\n\twrmsrl(MSR_IA32_U_CET, msrval);\n\nunlock:\n\tfpregs_unlock();\n\n\treturn 0;\n}\n\nstatic int shstk_disable(void)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!features_enabled(ARCH_SHSTK_SHSTK))\n\t\treturn 0;\n\n\tfpregs_lock_and_load();\n\t \n\twrmsrl(MSR_IA32_U_CET, 0);\n\twrmsrl(MSR_IA32_PL3_SSP, 0);\n\tfpregs_unlock();\n\n\tshstk_free(current);\n\tfeatures_clr(ARCH_SHSTK_SHSTK | ARCH_SHSTK_WRSS);\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(map_shadow_stack, unsigned long, addr, unsigned long, size, unsigned int, flags)\n{\n\tbool set_tok = flags & SHADOW_STACK_SET_TOKEN;\n\tunsigned long aligned_size;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~SHADOW_STACK_SET_TOKEN)\n\t\treturn -EINVAL;\n\n\t \n\tif (set_tok && size < 8)\n\t\treturn -ENOSPC;\n\n\tif (addr && addr < SZ_4G)\n\t\treturn -ERANGE;\n\n\t \n\taligned_size = PAGE_ALIGN(size);\n\tif (aligned_size < size)\n\t\treturn -EOVERFLOW;\n\n\treturn alloc_shstk(addr, aligned_size, size, set_tok);\n}\n\nlong shstk_prctl(struct task_struct *task, int option, unsigned long arg2)\n{\n\tunsigned long features = arg2;\n\n\tif (option == ARCH_SHSTK_STATUS) {\n\t\treturn put_user(task->thread.features, (unsigned long __user *)arg2);\n\t}\n\n\tif (option == ARCH_SHSTK_LOCK) {\n\t\ttask->thread.features_locked |= features;\n\t\treturn 0;\n\t}\n\n\t \n\tif (task != current) {\n\t\tif (option == ARCH_SHSTK_UNLOCK && IS_ENABLED(CONFIG_CHECKPOINT_RESTORE)) {\n\t\t\ttask->thread.features_locked &= ~features;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (features & task->thread.features_locked)\n\t\treturn -EPERM;\n\n\t \n\tif (hweight_long(features) > 1)\n\t\treturn -EINVAL;\n\n\tif (option == ARCH_SHSTK_DISABLE) {\n\t\tif (features & ARCH_SHSTK_WRSS)\n\t\t\treturn wrss_control(false);\n\t\tif (features & ARCH_SHSTK_SHSTK)\n\t\t\treturn shstk_disable();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (features & ARCH_SHSTK_SHSTK)\n\t\treturn shstk_setup();\n\tif (features & ARCH_SHSTK_WRSS)\n\t\treturn wrss_control(true);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}