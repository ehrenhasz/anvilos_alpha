{
  "module_name": "early_printk.c",
  "hash_id": "40db66cb89b6569369db16744242ffd331e031a4969a8aaa47681c4b27d350f0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/early_printk.c",
  "human_readable_source": "\n#include <linux/console.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/screen_info.h>\n#include <linux/usb/ch9.h>\n#include <linux/pci_regs.h>\n#include <linux/pci_ids.h>\n#include <linux/errno.h>\n#include <linux/pgtable.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/fcntl.h>\n#include <asm/setup.h>\n#include <xen/hvc-console.h>\n#include <asm/pci-direct.h>\n#include <asm/fixmap.h>\n#include <linux/usb/ehci_def.h>\n#include <linux/usb/xhci-dbgp.h>\n#include <asm/pci_x86.h>\n\n \n#define VGABASE\t\t(__ISA_IO_base + 0xb8000)\n\nstatic int max_ypos = 25, max_xpos = 80;\nstatic int current_ypos = 25, current_xpos;\n\nstatic void early_vga_write(struct console *con, const char *str, unsigned n)\n{\n\tchar c;\n\tint  i, k, j;\n\n\twhile ((c = *str++) != '\\0' && n-- > 0) {\n\t\tif (current_ypos >= max_ypos) {\n\t\t\t \n\t\t\tfor (k = 1, j = 0; k < max_ypos; k++, j++) {\n\t\t\t\tfor (i = 0; i < max_xpos; i++) {\n\t\t\t\t\twritew(readw(VGABASE+2*(max_xpos*k+i)),\n\t\t\t\t\t       VGABASE + 2*(max_xpos*j + i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < max_xpos; i++)\n\t\t\t\twritew(0x720, VGABASE + 2*(max_xpos*j + i));\n\t\t\tcurrent_ypos = max_ypos-1;\n\t\t}\n#ifdef CONFIG_KGDB_KDB\n\t\tif (c == '\\b') {\n\t\t\tif (current_xpos > 0)\n\t\t\t\tcurrent_xpos--;\n\t\t} else if (c == '\\r') {\n\t\t\tcurrent_xpos = 0;\n\t\t} else\n#endif\n\t\tif (c == '\\n') {\n\t\t\tcurrent_xpos = 0;\n\t\t\tcurrent_ypos++;\n\t\t} else if (c != '\\r')  {\n\t\t\twritew(((0x7 << 8) | (unsigned short) c),\n\t\t\t       VGABASE + 2*(max_xpos*current_ypos +\n\t\t\t\t\t\tcurrent_xpos++));\n\t\t\tif (current_xpos >= max_xpos) {\n\t\t\t\tcurrent_xpos = 0;\n\t\t\t\tcurrent_ypos++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct console early_vga_console = {\n\t.name =\t\t\"earlyvga\",\n\t.write =\tearly_vga_write,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n};\n\n \n\nstatic unsigned long early_serial_base = 0x3f8;   \n\n#define XMTRDY          0x20\n\n#define DLAB\t\t0x80\n\n#define TXR             0        \n#define RXR             0        \n#define IER             1        \n#define IIR             2        \n#define FCR             2        \n#define LCR             3        \n#define MCR             4        \n#define LSR             5        \n#define MSR             6        \n#define DLL             0        \n#define DLH             1        \n\nstatic unsigned int io_serial_in(unsigned long addr, int offset)\n{\n\treturn inb(addr + offset);\n}\n\nstatic void io_serial_out(unsigned long addr, int offset, int value)\n{\n\toutb(value, addr + offset);\n}\n\nstatic unsigned int (*serial_in)(unsigned long addr, int offset) = io_serial_in;\nstatic void (*serial_out)(unsigned long addr, int offset, int value) = io_serial_out;\n\nstatic int early_serial_putc(unsigned char ch)\n{\n\tunsigned timeout = 0xffff;\n\n\twhile ((serial_in(early_serial_base, LSR) & XMTRDY) == 0 && --timeout)\n\t\tcpu_relax();\n\tserial_out(early_serial_base, TXR, ch);\n\treturn timeout ? 0 : -1;\n}\n\nstatic void early_serial_write(struct console *con, const char *s, unsigned n)\n{\n\twhile (*s && n-- > 0) {\n\t\tif (*s == '\\n')\n\t\t\tearly_serial_putc('\\r');\n\t\tearly_serial_putc(*s);\n\t\ts++;\n\t}\n}\n\nstatic __init void early_serial_hw_init(unsigned divisor)\n{\n\tunsigned char c;\n\n\tserial_out(early_serial_base, LCR, 0x3);\t \n\tserial_out(early_serial_base, IER, 0);\t \n\tserial_out(early_serial_base, FCR, 0);\t \n\tserial_out(early_serial_base, MCR, 0x3);\t \n\n\tc = serial_in(early_serial_base, LCR);\n\tserial_out(early_serial_base, LCR, c | DLAB);\n\tserial_out(early_serial_base, DLL, divisor & 0xff);\n\tserial_out(early_serial_base, DLH, (divisor >> 8) & 0xff);\n\tserial_out(early_serial_base, LCR, c & ~DLAB);\n}\n\n#define DEFAULT_BAUD 9600\n\nstatic __init void early_serial_init(char *s)\n{\n\tunsigned divisor;\n\tunsigned long baud = DEFAULT_BAUD;\n\tchar *e;\n\n\tif (*s == ',')\n\t\t++s;\n\n\tif (*s) {\n\t\tunsigned port;\n\t\tif (!strncmp(s, \"0x\", 2)) {\n\t\t\tearly_serial_base = simple_strtoul(s, &e, 16);\n\t\t} else {\n\t\t\tstatic const int __initconst bases[] = { 0x3f8, 0x2f8 };\n\n\t\t\tif (!strncmp(s, \"ttyS\", 4))\n\t\t\t\ts += 4;\n\t\t\tport = simple_strtoul(s, &e, 10);\n\t\t\tif (port > 1 || s == e)\n\t\t\t\tport = 0;\n\t\t\tearly_serial_base = bases[port];\n\t\t}\n\t\ts += strcspn(s, \",\");\n\t\tif (*s == ',')\n\t\t\ts++;\n\t}\n\n\tif (*s) {\n\t\tbaud = simple_strtoull(s, &e, 0);\n\n\t\tif (baud == 0 || s == e)\n\t\t\tbaud = DEFAULT_BAUD;\n\t}\n\n\t \n\tdivisor = 115200 / baud;\n\n\t \n\tserial_in = io_serial_in;\n\tserial_out = io_serial_out;\n\n\t \n\tearly_serial_hw_init(divisor);\n}\n\n#ifdef CONFIG_PCI\nstatic void mem32_serial_out(unsigned long addr, int offset, int value)\n{\n\tu32 __iomem *vaddr = (u32 __iomem *)addr;\n\t \n\twritel(value, vaddr + offset);\n}\n\nstatic unsigned int mem32_serial_in(unsigned long addr, int offset)\n{\n\tu32 __iomem *vaddr = (u32 __iomem *)addr;\n\t \n\treturn readl(vaddr + offset);\n}\n\n \nstatic __init void early_pci_serial_init(char *s)\n{\n\tunsigned divisor;\n\tunsigned long baud = DEFAULT_BAUD;\n\tu8 bus, slot, func;\n\tu32 classcode, bar0;\n\tu16 cmdreg;\n\tchar *e;\n\tint force = 0;\n\n\tif (*s == ',')\n\t\t++s;\n\n\tif (*s == 0)\n\t\treturn;\n\n\t \n\tif (!strncmp(s, \"force,\", 6)) {\n\t\tforce = 1;\n\t\ts += 6;\n\t}\n\n\t \n\tbus = (u8)simple_strtoul(s, &e, 16);\n\ts = e;\n\tif (*s != ':')\n\t\treturn;\n\t++s;\n\tslot = (u8)simple_strtoul(s, &e, 16);\n\ts = e;\n\tif (*s != '.')\n\t\treturn;\n\t++s;\n\tfunc = (u8)simple_strtoul(s, &e, 16);\n\ts = e;\n\n\t \n\tif (*s == ',')\n\t\ts++;\n\n\t \n\tcmdreg = read_pci_config(bus, slot, func, PCI_COMMAND);\n\tclasscode = read_pci_config(bus, slot, func, PCI_CLASS_REVISION);\n\tbar0 = read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);\n\n\t \n\tif (((classcode >> 16 != PCI_CLASS_COMMUNICATION_MODEM) &&\n\t     (classcode >> 16 != PCI_CLASS_COMMUNICATION_SERIAL)) ||\n\t    (((classcode >> 8) & 0xff) != PCI_SERIAL_16550_COMPATIBLE)) {\n\t\tif (!force)\n\t\t\treturn;\n\t}\n\n\t \n\tif ((bar0 & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t \n\t\tserial_in = io_serial_in;\n\t\tserial_out = io_serial_out;\n\t\tearly_serial_base = bar0 & PCI_BASE_ADDRESS_IO_MASK;\n\t\twrite_pci_config(bus, slot, func, PCI_COMMAND,\n\t\t\t\t cmdreg|PCI_COMMAND_IO);\n\t} else {\n\t\t \n\t\tserial_in = mem32_serial_in;\n\t\tserial_out = mem32_serial_out;\n\t\t \n\t\tearly_serial_base =\n\t\t\t(unsigned long)early_ioremap(bar0 & PCI_BASE_ADDRESS_MEM_MASK, 0x10);\n\t\twrite_pci_config(bus, slot, func, PCI_COMMAND,\n\t\t\t\t cmdreg|PCI_COMMAND_MEMORY);\n\t}\n\n\t \n\tif (*s) {\n\t\tif (strcmp(s, \"nocfg\") == 0)\n\t\t\t \n\t\t\treturn;\n\t\tif (kstrtoul(s, 0, &baud) < 0 || baud == 0)\n\t\t\tbaud = DEFAULT_BAUD;\n\t}\n\n\t \n\tdivisor = 115200 / baud;\n\n\t \n\tearly_serial_hw_init(divisor);\n}\n#endif\n\nstatic struct console early_serial_console = {\n\t.name =\t\t\"earlyser\",\n\t.write =\tearly_serial_write,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n};\n\nstatic void early_console_register(struct console *con, int keep_early)\n{\n\tif (con->index != -1) {\n\t\tprintk(KERN_CRIT \"ERROR: earlyprintk= %s already used\\n\",\n\t\t       con->name);\n\t\treturn;\n\t}\n\tearly_console = con;\n\tif (keep_early)\n\t\tearly_console->flags &= ~CON_BOOT;\n\telse\n\t\tearly_console->flags |= CON_BOOT;\n\tregister_console(early_console);\n}\n\nstatic int __init setup_early_printk(char *buf)\n{\n\tint keep;\n\n\tif (!buf)\n\t\treturn 0;\n\n\tif (early_console)\n\t\treturn 0;\n\n\tkeep = (strstr(buf, \"keep\") != NULL);\n\n\twhile (*buf != '\\0') {\n\t\tif (!strncmp(buf, \"serial\", 6)) {\n\t\t\tbuf += 6;\n\t\t\tearly_serial_init(buf);\n\t\t\tearly_console_register(&early_serial_console, keep);\n\t\t\tif (!strncmp(buf, \",ttyS\", 5))\n\t\t\t\tbuf += 5;\n\t\t}\n\t\tif (!strncmp(buf, \"ttyS\", 4)) {\n\t\t\tearly_serial_init(buf + 4);\n\t\t\tearly_console_register(&early_serial_console, keep);\n\t\t}\n#ifdef CONFIG_PCI\n\t\tif (!strncmp(buf, \"pciserial\", 9)) {\n\t\t\tearly_pci_serial_init(buf + 9);\n\t\t\tearly_console_register(&early_serial_console, keep);\n\t\t\tbuf += 9;  \n\t\t}\n#endif\n\t\tif (!strncmp(buf, \"vga\", 3) &&\n\t\t    boot_params.screen_info.orig_video_isVGA == 1) {\n\t\t\tmax_xpos = boot_params.screen_info.orig_video_cols;\n\t\t\tmax_ypos = boot_params.screen_info.orig_video_lines;\n\t\t\tcurrent_ypos = boot_params.screen_info.orig_y;\n\t\t\tearly_console_register(&early_vga_console, keep);\n\t\t}\n#ifdef CONFIG_EARLY_PRINTK_DBGP\n\t\tif (!strncmp(buf, \"dbgp\", 4) && !early_dbgp_init(buf + 4))\n\t\t\tearly_console_register(&early_dbgp_console, keep);\n#endif\n#ifdef CONFIG_HVC_XEN\n\t\tif (!strncmp(buf, \"xen\", 3))\n\t\t\tearly_console_register(&xenboot_console, keep);\n#endif\n#ifdef CONFIG_EARLY_PRINTK_USB_XDBC\n\t\tif (!strncmp(buf, \"xdbc\", 4))\n\t\t\tearly_xdbc_parse_parameter(buf + 4, keep);\n#endif\n\n\t\tbuf++;\n\t}\n\treturn 0;\n}\n\nearly_param(\"earlyprintk\", setup_early_printk);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}