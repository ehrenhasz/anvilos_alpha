{
  "module_name": "cet.c",
  "hash_id": "b42a28ec26a22be79f6e0d6be578ffe031ff6083be2c467cfd1737f1ff6b2b27",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/cet.c",
  "human_readable_source": "\n\n#include <linux/ptrace.h>\n#include <asm/bugs.h>\n#include <asm/traps.h>\n\nenum cp_error_code {\n\tCP_EC        = (1 << 15) - 1,\n\n\tCP_RET       = 1,\n\tCP_IRET      = 2,\n\tCP_ENDBR     = 3,\n\tCP_RSTRORSSP = 4,\n\tCP_SETSSBSY  = 5,\n\n\tCP_ENCL\t     = 1 << 15,\n};\n\nstatic const char cp_err[][10] = {\n\t[0] = \"unknown\",\n\t[1] = \"near ret\",\n\t[2] = \"far/iret\",\n\t[3] = \"endbranch\",\n\t[4] = \"rstorssp\",\n\t[5] = \"setssbsy\",\n};\n\nstatic const char *cp_err_string(unsigned long error_code)\n{\n\tunsigned int cpec = error_code & CP_EC;\n\n\tif (cpec >= ARRAY_SIZE(cp_err))\n\t\tcpec = 0;\n\treturn cp_err[cpec];\n}\n\nstatic void do_unexpected_cp(struct pt_regs *regs, unsigned long error_code)\n{\n\tWARN_ONCE(1, \"Unexpected %s #CP, error_code: %s\\n\",\n\t\t  user_mode(regs) ? \"user mode\" : \"kernel mode\",\n\t\t  cp_err_string(error_code));\n}\n\nstatic DEFINE_RATELIMIT_STATE(cpf_rate, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t      DEFAULT_RATELIMIT_BURST);\n\nstatic void do_user_cp_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct task_struct *tsk;\n\tunsigned long ssp;\n\n\t \n\trdmsrl(MSR_IA32_PL3_SSP, ssp);\n\n\tcond_local_irq_enable(regs);\n\n\ttsk = current;\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_CP;\n\n\t \n\tif (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&\n\t    __ratelimit(&cpf_rate)) {\n\t\tpr_emerg(\"%s[%d] control protection ip:%lx sp:%lx ssp:%lx error:%lx(%s)%s\",\n\t\t\t tsk->comm, task_pid_nr(tsk),\n\t\t\t regs->ip, regs->sp, ssp, error_code,\n\t\t\t cp_err_string(error_code),\n\t\t\t error_code & CP_ENCL ? \" in enclave\" : \"\");\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig_fault(SIGSEGV, SEGV_CPERR, (void __user *)0);\n\tcond_local_irq_disable(regs);\n}\n\nstatic __ro_after_init bool ibt_fatal = true;\n\nstatic void do_kernel_cp_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tif ((error_code & CP_EC) != CP_ENDBR) {\n\t\tdo_unexpected_cp(regs, error_code);\n\t\treturn;\n\t}\n\n\tif (unlikely(regs->ip == (unsigned long)&ibt_selftest_noendbr)) {\n\t\tregs->ax = 0;\n\t\treturn;\n\t}\n\n\tpr_err(\"Missing ENDBR: %pS\\n\", (void *)instruction_pointer(regs));\n\tif (!ibt_fatal) {\n\t\tprintk(KERN_DEFAULT CUT_HERE);\n\t\t__warn(__FILE__, __LINE__, (void *)regs->ip, TAINT_WARN, regs, NULL);\n\t\treturn;\n\t}\n\tBUG();\n}\n\nstatic int __init ibt_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_IBT);\n\n\tif (!strcmp(str, \"warn\"))\n\t\tibt_fatal = false;\n\n\treturn 1;\n}\n\n__setup(\"ibt=\", ibt_setup);\n\nDEFINE_IDTENTRY_ERRORCODE(exc_control_protection)\n{\n\tif (user_mode(regs)) {\n\t\tif (cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n\t\t\tdo_user_cp_fault(regs, error_code);\n\t\telse\n\t\t\tdo_unexpected_cp(regs, error_code);\n\t} else {\n\t\tif (cpu_feature_enabled(X86_FEATURE_IBT))\n\t\t\tdo_kernel_cp_fault(regs, error_code);\n\t\telse\n\t\t\tdo_unexpected_cp(regs, error_code);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}