{
  "module_name": "aperture_64.c",
  "hash_id": "e965e6be0f8b4ad8177a18a40c8159d953a7f80619bf811947e55e196e3e0d61",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/aperture_64.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"AGP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/kcore.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/pci_ids.h>\n#include <linux/pci.h>\n#include <linux/bitops.h>\n#include <linux/suspend.h>\n#include <asm/e820/api.h>\n#include <asm/io.h>\n#include <asm/iommu.h>\n#include <asm/gart.h>\n#include <asm/pci-direct.h>\n#include <asm/dma.h>\n#include <asm/amd_nb.h>\n#include <asm/x86_init.h>\n#include <linux/crash_dump.h>\n\n \n#define GART_MIN_ADDR\t(512ULL << 20)\n#define GART_MAX_ADDR\t(1ULL   << 32)\n\nint gart_iommu_aperture;\nint gart_iommu_aperture_disabled __initdata;\nint gart_iommu_aperture_allowed __initdata;\n\nint fallback_aper_order __initdata = 1;  \nint fallback_aper_force __initdata;\n\nint fix_aperture __initdata = 1;\n\n#if defined(CONFIG_PROC_VMCORE) || defined(CONFIG_PROC_KCORE)\n \nstatic unsigned long aperture_pfn_start, aperture_page_count;\n\nstatic int gart_mem_pfn_is_ram(unsigned long pfn)\n{\n\treturn likely((pfn < aperture_pfn_start) ||\n\t\t      (pfn >= aperture_pfn_start + aperture_page_count));\n}\n\n#ifdef CONFIG_PROC_VMCORE\nstatic bool gart_oldmem_pfn_is_ram(struct vmcore_cb *cb, unsigned long pfn)\n{\n\treturn !!gart_mem_pfn_is_ram(pfn);\n}\n\nstatic struct vmcore_cb gart_vmcore_cb = {\n\t.pfn_is_ram = gart_oldmem_pfn_is_ram,\n};\n#endif\n\nstatic void __init exclude_from_core(u64 aper_base, u32 aper_order)\n{\n\taperture_pfn_start = aper_base >> PAGE_SHIFT;\n\taperture_page_count = (32 * 1024 * 1024) << aper_order >> PAGE_SHIFT;\n#ifdef CONFIG_PROC_VMCORE\n\tregister_vmcore_cb(&gart_vmcore_cb);\n#endif\n#ifdef CONFIG_PROC_KCORE\n\tWARN_ON(register_mem_pfn_is_ram(&gart_mem_pfn_is_ram));\n#endif\n}\n#else\nstatic void exclude_from_core(u64 aper_base, u32 aper_order)\n{\n}\n#endif\n\n \n\nstatic u32 __init allocate_aperture(void)\n{\n\tu32 aper_size;\n\tunsigned long addr;\n\n\t \n\tif (fallback_aper_order > 5)\n\t\tfallback_aper_order = 5;\n\taper_size = (32 * 1024 * 1024) << fallback_aper_order;\n\n\t \n\taddr = memblock_phys_alloc_range(aper_size, aper_size,\n\t\t\t\t\t GART_MIN_ADDR, GART_MAX_ADDR);\n\tif (!addr) {\n\t\tpr_err(\"Cannot allocate aperture memory hole [mem %#010lx-%#010lx] (%uKB)\\n\",\n\t\t       addr, addr + aper_size - 1, aper_size >> 10);\n\t\treturn 0;\n\t}\n\tpr_info(\"Mapping aperture over RAM [mem %#010lx-%#010lx] (%uKB)\\n\",\n\t\taddr, addr + aper_size - 1, aper_size >> 10);\n\tregister_nosave_region(addr >> PAGE_SHIFT,\n\t\t\t       (addr+aper_size) >> PAGE_SHIFT);\n\n\treturn (u32)addr;\n}\n\n\n \nstatic u32 __init find_cap(int bus, int slot, int func, int cap)\n{\n\tint bytes;\n\tu8 pos;\n\n\tif (!(read_pci_config_16(bus, slot, func, PCI_STATUS) &\n\t\t\t\t\t\tPCI_STATUS_CAP_LIST))\n\t\treturn 0;\n\n\tpos = read_pci_config_byte(bus, slot, func, PCI_CAPABILITY_LIST);\n\tfor (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {\n\t\tu8 id;\n\n\t\tpos &= ~3;\n\t\tid = read_pci_config_byte(bus, slot, func, pos+PCI_CAP_LIST_ID);\n\t\tif (id == 0xff)\n\t\t\tbreak;\n\t\tif (id == cap)\n\t\t\treturn pos;\n\t\tpos = read_pci_config_byte(bus, slot, func,\n\t\t\t\t\t\tpos+PCI_CAP_LIST_NEXT);\n\t}\n\treturn 0;\n}\n\n \nstatic u32 __init read_agp(int bus, int slot, int func, int cap, u32 *order)\n{\n\tu32 apsize;\n\tu32 apsizereg;\n\tint nbits;\n\tu32 aper_low, aper_hi;\n\tu64 aper;\n\tu32 old_order;\n\n\tpr_info(\"pci 0000:%02x:%02x:%02x: AGP bridge\\n\", bus, slot, func);\n\tapsizereg = read_pci_config_16(bus, slot, func, cap + 0x14);\n\tif (apsizereg == 0xffffffff) {\n\t\tpr_err(\"pci 0000:%02x:%02x.%d: APSIZE unreadable\\n\",\n\t\t       bus, slot, func);\n\t\treturn 0;\n\t}\n\n\t \n\told_order = *order;\n\n\tapsize = apsizereg & 0xfff;\n\t \n\tif (apsize & 0xff)\n\t\tapsize |= 0xf00;\n\tnbits = hweight16(apsize);\n\t*order = 7 - nbits;\n\tif ((int)*order < 0)  \n\t\t*order = 0;\n\n\taper_low = read_pci_config(bus, slot, func, 0x10);\n\taper_hi = read_pci_config(bus, slot, func, 0x14);\n\taper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32);\n\n\t \n\tpr_info(\"pci 0000:%02x:%02x.%d: AGP aperture [bus addr %#010Lx-%#010Lx] (old size %uMB)\\n\",\n\t\tbus, slot, func, aper, aper + (32ULL << (old_order + 20)) - 1,\n\t\t32 << old_order);\n\tif (aper + (32ULL<<(20 + *order)) > 0x100000000ULL) {\n\t\tpr_info(\"pci 0000:%02x:%02x.%d: AGP aperture size %uMB (APSIZE %#x) is not right, using settings from NB\\n\",\n\t\t\tbus, slot, func, 32 << *order, apsizereg);\n\t\t*order = old_order;\n\t}\n\n\tpr_info(\"pci 0000:%02x:%02x.%d: AGP aperture [bus addr %#010Lx-%#010Lx] (%uMB, APSIZE %#x)\\n\",\n\t\tbus, slot, func, aper, aper + (32ULL << (*order + 20)) - 1,\n\t\t32 << *order, apsizereg);\n\n\tif (!aperture_valid(aper, (32*1024*1024) << *order, 32<<20))\n\t\treturn 0;\n\treturn (u32)aper;\n}\n\n \nstatic u32 __init search_agp_bridge(u32 *order, int *valid_agp)\n{\n\tint bus, slot, func;\n\n\t \n\tfor (bus = 0; bus < 256; bus++) {\n\t\tfor (slot = 0; slot < 32; slot++) {\n\t\t\tfor (func = 0; func < 8; func++) {\n\t\t\t\tu32 class, cap;\n\t\t\t\tu8 type;\n\t\t\t\tclass = read_pci_config(bus, slot, func,\n\t\t\t\t\t\t\tPCI_CLASS_REVISION);\n\t\t\t\tif (class == 0xffffffff)\n\t\t\t\t\tbreak;\n\n\t\t\t\tswitch (class >> 16) {\n\t\t\t\tcase PCI_CLASS_BRIDGE_HOST:\n\t\t\t\tcase PCI_CLASS_BRIDGE_OTHER:  \n\t\t\t\t\t \n\t\t\t\t\tcap = find_cap(bus, slot, func,\n\t\t\t\t\t\t\tPCI_CAP_ID_AGP);\n\t\t\t\t\tif (!cap)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*valid_agp = 1;\n\t\t\t\t\treturn read_agp(bus, slot, func, cap,\n\t\t\t\t\t\t\torder);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\ttype = read_pci_config_byte(bus, slot, func,\n\t\t\t\t\t\t\t       PCI_HEADER_TYPE);\n\t\t\t\tif (!(type & 0x80))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpr_info(\"No AGP bridge found\\n\");\n\n\treturn 0;\n}\n\nstatic bool gart_fix_e820 __initdata = true;\n\nstatic int __init parse_gart_mem(char *p)\n{\n\treturn kstrtobool(p, &gart_fix_e820);\n}\nearly_param(\"gart_fix_e820\", parse_gart_mem);\n\n \nvoid __init early_gart_iommu_check(void)\n{\n\tu32 agp_aper_order = 0;\n\tint i, fix, slot, valid_agp = 0;\n\tu32 ctl;\n\tu32 aper_size = 0, aper_order = 0, last_aper_order = 0;\n\tu64 aper_base = 0, last_aper_base = 0;\n\tint aper_enabled = 0, last_aper_enabled = 0, last_valid = 0;\n\n\tif (!amd_gart_present())\n\t\treturn;\n\n\tif (!early_pci_allowed())\n\t\treturn;\n\n\t \n\tsearch_agp_bridge(&agp_aper_order, &valid_agp);\n\n\tfix = 0;\n\tfor (i = 0; amd_nb_bus_dev_ranges[i].dev_limit; i++) {\n\t\tint bus;\n\t\tint dev_base, dev_limit;\n\n\t\tbus = amd_nb_bus_dev_ranges[i].bus;\n\t\tdev_base = amd_nb_bus_dev_ranges[i].dev_base;\n\t\tdev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\n\n\t\tfor (slot = dev_base; slot < dev_limit; slot++) {\n\t\t\tif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\n\t\t\t\tcontinue;\n\n\t\t\tctl = read_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL);\n\t\t\taper_enabled = ctl & GARTEN;\n\t\t\taper_order = (ctl >> 1) & 7;\n\t\t\taper_size = (32 * 1024 * 1024) << aper_order;\n\t\t\taper_base = read_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;\n\t\t\taper_base <<= 25;\n\n\t\t\tif (last_valid) {\n\t\t\t\tif ((aper_order != last_aper_order) ||\n\t\t\t\t    (aper_base != last_aper_base) ||\n\t\t\t\t    (aper_enabled != last_aper_enabled)) {\n\t\t\t\t\tfix = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlast_aper_order = aper_order;\n\t\t\tlast_aper_base = aper_base;\n\t\t\tlast_aper_enabled = aper_enabled;\n\t\t\tlast_valid = 1;\n\t\t}\n\t}\n\n\tif (!fix && !aper_enabled)\n\t\treturn;\n\n\tif (!aper_base || !aper_size || aper_base + aper_size > 0x100000000UL)\n\t\tfix = 1;\n\n\tif (gart_fix_e820 && !fix && aper_enabled) {\n\t\tif (e820__mapped_any(aper_base, aper_base + aper_size,\n\t\t\t\t    E820_TYPE_RAM)) {\n\t\t\t \n\t\t\tpr_info(\"e820: reserve [mem %#010Lx-%#010Lx] for GART\\n\",\n\t\t\t\taper_base, aper_base + aper_size - 1);\n\t\t\te820__range_add(aper_base, aper_size, E820_TYPE_RESERVED);\n\t\t\te820__update_table_print();\n\t\t}\n\t}\n\n\tif (valid_agp)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\n\t\tint bus;\n\t\tint dev_base, dev_limit;\n\n\t\tbus = amd_nb_bus_dev_ranges[i].bus;\n\t\tdev_base = amd_nb_bus_dev_ranges[i].dev_base;\n\t\tdev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\n\n\t\tfor (slot = dev_base; slot < dev_limit; slot++) {\n\t\t\tif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\n\t\t\t\tcontinue;\n\n\t\t\tctl = read_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL);\n\t\t\tctl &= ~GARTEN;\n\t\t\twrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\n\t\t}\n\t}\n\n}\n\nstatic int __initdata printed_gart_size_msg;\n\nvoid __init gart_iommu_hole_init(void)\n{\n\tu32 agp_aper_base = 0, agp_aper_order = 0;\n\tu32 aper_size, aper_alloc = 0, aper_order = 0, last_aper_order = 0;\n\tu64 aper_base, last_aper_base = 0;\n\tint fix, slot, valid_agp = 0;\n\tint i, node;\n\n\tif (!amd_gart_present())\n\t\treturn;\n\n\tif (gart_iommu_aperture_disabled || !fix_aperture ||\n\t    !early_pci_allowed())\n\t\treturn;\n\n\tpr_info(\"Checking aperture...\\n\");\n\n\tif (!fallback_aper_force)\n\t\tagp_aper_base = search_agp_bridge(&agp_aper_order, &valid_agp);\n\n\tfix = 0;\n\tnode = 0;\n\tfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\n\t\tint bus;\n\t\tint dev_base, dev_limit;\n\t\tu32 ctl;\n\n\t\tbus = amd_nb_bus_dev_ranges[i].bus;\n\t\tdev_base = amd_nb_bus_dev_ranges[i].dev_base;\n\t\tdev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\n\n\t\tfor (slot = dev_base; slot < dev_limit; slot++) {\n\t\t\tif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\n\t\t\t\tcontinue;\n\n\t\t\tiommu_detected = 1;\n\t\t\tgart_iommu_aperture = 1;\n\t\t\tx86_init.iommu.iommu_init = gart_iommu_init;\n\n\t\t\tctl = read_pci_config(bus, slot, 3,\n\t\t\t\t\t      AMD64_GARTAPERTURECTL);\n\n\t\t\t \n\t\t\tctl &= ~GARTEN;\n\t\t\twrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\n\n\t\t\taper_order = (ctl >> 1) & 7;\n\t\t\taper_size = (32 * 1024 * 1024) << aper_order;\n\t\t\taper_base = read_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;\n\t\t\taper_base <<= 25;\n\n\t\t\tpr_info(\"Node %d: aperture [bus addr %#010Lx-%#010Lx] (%uMB)\\n\",\n\t\t\t\tnode, aper_base, aper_base + aper_size - 1,\n\t\t\t\taper_size >> 20);\n\t\t\tnode++;\n\n\t\t\tif (!aperture_valid(aper_base, aper_size, 64<<20)) {\n\t\t\t\tif (valid_agp && agp_aper_base &&\n\t\t\t\t    agp_aper_base == aper_base &&\n\t\t\t\t    agp_aper_order == aper_order) {\n\t\t\t\t\t \n\t\t\t\t\tif (!no_iommu &&\n\t\t\t\t\t    max_pfn > MAX_DMA32_PFN &&\n\t\t\t\t\t    !printed_gart_size_msg) {\n\t\t\t\t\t\tpr_err(\"you are using iommu with agp, but GART size is less than 64MB\\n\");\n\t\t\t\t\t\tpr_err(\"please increase GART size in your BIOS setup\\n\");\n\t\t\t\t\t\tpr_err(\"if BIOS doesn't have that option, contact your HW vendor!\\n\");\n\t\t\t\t\t\tprinted_gart_size_msg = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfix = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((last_aper_order && aper_order != last_aper_order) ||\n\t\t\t    (last_aper_base && aper_base != last_aper_base)) {\n\t\t\t\tfix = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlast_aper_order = aper_order;\n\t\t\tlast_aper_base = aper_base;\n\t\t}\n\t}\n\nout:\n\tif (!fix && !fallback_aper_force) {\n\t\tif (last_aper_base) {\n\t\t\t \n\t\t\texclude_from_core(last_aper_base, last_aper_order);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!fallback_aper_force) {\n\t\taper_alloc = agp_aper_base;\n\t\taper_order = agp_aper_order;\n\t}\n\n\tif (aper_alloc) {\n\t\t \n\t} else if ((!no_iommu && max_pfn > MAX_DMA32_PFN) ||\n\t\t   force_iommu ||\n\t\t   valid_agp ||\n\t\t   fallback_aper_force) {\n\t\tpr_info(\"Your BIOS doesn't leave an aperture memory hole\\n\");\n\t\tpr_info(\"Please enable the IOMMU option in the BIOS setup\\n\");\n\t\tpr_info(\"This costs you %dMB of RAM\\n\",\n\t\t\t32 << fallback_aper_order);\n\n\t\taper_order = fallback_aper_order;\n\t\taper_alloc = allocate_aperture();\n\t\tif (!aper_alloc) {\n\t\t\t \n\t\t\tpanic(\"Not enough memory for aperture\");\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\texclude_from_core(aper_alloc, aper_order);\n\n\t \n\tfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\n\t\tint bus, dev_base, dev_limit;\n\n\t\t \n\t\tu32 ctl = aper_order << 1;\n\n\t\tbus = amd_nb_bus_dev_ranges[i].bus;\n\t\tdev_base = amd_nb_bus_dev_ranges[i].dev_base;\n\t\tdev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\n\t\tfor (slot = dev_base; slot < dev_limit; slot++) {\n\t\t\tif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\n\t\t\t\tcontinue;\n\n\t\t\twrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\n\t\t\twrite_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE, aper_alloc >> 25);\n\t\t}\n\t}\n\n\tset_up_gart_resume(aper_order, aper_alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}