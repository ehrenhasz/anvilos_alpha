{
  "module_name": "jailhouse.c",
  "hash_id": "71f442d6a31ba05b2b05e064739762a42f7b44e946f21af8e824288108875711",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/jailhouse.c",
  "human_readable_source": "\n \n\n#include <linux/acpi_pmtmr.h>\n#include <linux/kernel.h>\n#include <linux/reboot.h>\n#include <linux/serial_8250.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/acpi.h>\n#include <asm/cpu.h>\n#include <asm/hypervisor.h>\n#include <asm/i8259.h>\n#include <asm/irqdomain.h>\n#include <asm/pci_x86.h>\n#include <asm/reboot.h>\n#include <asm/setup.h>\n#include <asm/jailhouse_para.h>\n\nstatic struct jailhouse_setup_data setup_data;\n#define SETUP_DATA_V1_LEN\t(sizeof(setup_data.hdr) + sizeof(setup_data.v1))\n#define SETUP_DATA_V2_LEN\t(SETUP_DATA_V1_LEN + sizeof(setup_data.v2))\n\nstatic unsigned int precalibrated_tsc_khz;\n\nstatic void jailhouse_setup_irq(unsigned int irq)\n{\n\tstruct mpc_intsrc mp_irq = {\n\t\t.type\t\t= MP_INTSRC,\n\t\t.irqtype\t= mp_INT,\n\t\t.irqflag\t= MP_IRQPOL_ACTIVE_HIGH | MP_IRQTRIG_EDGE,\n\t\t.srcbusirq\t= irq,\n\t\t.dstirq\t\t= irq,\n\t};\n\tmp_save_irq(&mp_irq);\n}\n\nstatic uint32_t jailhouse_cpuid_base(void)\n{\n\tif (boot_cpu_data.cpuid_level < 0 ||\n\t    !boot_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\treturn 0;\n\n\treturn hypervisor_cpuid_base(\"Jailhouse\\0\\0\\0\", 0);\n}\n\nstatic uint32_t __init jailhouse_detect(void)\n{\n\treturn jailhouse_cpuid_base();\n}\n\nstatic void jailhouse_get_wallclock(struct timespec64 *now)\n{\n\tmemset(now, 0, sizeof(*now));\n}\n\nstatic void __init jailhouse_timer_init(void)\n{\n\tlapic_timer_period = setup_data.v1.apic_khz * (1000 / HZ);\n}\n\nstatic unsigned long jailhouse_get_tsc(void)\n{\n\treturn precalibrated_tsc_khz;\n}\n\nstatic void __init jailhouse_x2apic_init(void)\n{\n#ifdef CONFIG_X86_X2APIC\n\tif (!x2apic_enabled())\n\t\treturn;\n\t \n\tx2apic_phys = 1;\n\t \n\tdefault_acpi_madt_oem_check(\"\", \"\");\n#endif\n}\n\nstatic void __init jailhouse_get_smp_config(unsigned int early)\n{\n\tstruct ioapic_domain_cfg ioapic_cfg = {\n\t\t.type = IOAPIC_DOMAIN_STRICT,\n\t\t.ops = &mp_ioapic_irqdomain_ops,\n\t};\n\tunsigned int cpu;\n\n\tjailhouse_x2apic_init();\n\n\tregister_lapic_address(0xfee00000);\n\n\tfor (cpu = 0; cpu < setup_data.v1.num_cpus; cpu++)\n\t\tgeneric_processor_info(setup_data.v1.cpu_ids[cpu]);\n\n\tsmp_found_config = 1;\n\n\tif (setup_data.v1.standard_ioapic) {\n\t\tmp_register_ioapic(0, 0xfec00000, gsi_top, &ioapic_cfg);\n\n\t\tif (IS_ENABLED(CONFIG_SERIAL_8250) &&\n\t\t    setup_data.hdr.version < 2) {\n\t\t\t \n\t\t\tjailhouse_setup_irq(3);\n\t\t\tjailhouse_setup_irq(4);\n\t\t}\n\t}\n}\n\nstatic void jailhouse_no_restart(void)\n{\n\tpr_notice(\"Jailhouse: Restart not supported, halting\\n\");\n\tmachine_halt();\n}\n\nstatic int __init jailhouse_pci_arch_init(void)\n{\n\tpci_direct_init(1);\n\n\t \n\tif (pcibios_last_bus < 0)\n\t\tpcibios_last_bus = 0xff;\n\n#ifdef CONFIG_PCI_MMCONFIG\n\tif (setup_data.v1.pci_mmconfig_base) {\n\t\tpci_mmconfig_add(0, 0, pcibios_last_bus,\n\t\t\t\t setup_data.v1.pci_mmconfig_base);\n\t\tpci_mmcfg_arch_init();\n\t}\n#endif\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_8250\nstatic inline bool jailhouse_uart_enabled(unsigned int uart_nr)\n{\n\treturn setup_data.v2.flags & BIT(uart_nr);\n}\n\nstatic void jailhouse_serial_fixup(int port, struct uart_port *up,\n\t\t\t\t   u32 *capabilities)\n{\n\tstatic const u16 pcuart_base[] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};\n\tunsigned int n;\n\n\tfor (n = 0; n < ARRAY_SIZE(pcuart_base); n++) {\n\t\tif (pcuart_base[n] != up->iobase)\n\t\t\tcontinue;\n\n\t\tif (jailhouse_uart_enabled(n)) {\n\t\t\tpr_info(\"Enabling UART%u (port 0x%lx)\\n\", n,\n\t\t\t\tup->iobase);\n\t\t\tjailhouse_setup_irq(up->irq);\n\t\t} else {\n\t\t\t \n\t\t\tup->iobase = 0;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void __init jailhouse_serial_workaround(void)\n{\n\t \n\tif (setup_data.hdr.version > 1)\n\t\tserial8250_set_isa_configurator(jailhouse_serial_fixup);\n}\n#else  \nstatic inline void jailhouse_serial_workaround(void)\n{\n}\n#endif  \n\nstatic void __init jailhouse_init_platform(void)\n{\n\tu64 pa_data = boot_params.hdr.setup_data;\n\tunsigned long setup_data_len;\n\tstruct setup_data header;\n\tvoid *mapping;\n\n\tx86_init.irqs.pre_vector_init\t= x86_init_noop;\n\tx86_init.timers.timer_init\t= jailhouse_timer_init;\n\tx86_init.mpparse.get_smp_config\t= jailhouse_get_smp_config;\n\tx86_init.pci.arch_init\t\t= jailhouse_pci_arch_init;\n\n\tx86_platform.calibrate_cpu\t= jailhouse_get_tsc;\n\tx86_platform.calibrate_tsc\t= jailhouse_get_tsc;\n\tx86_platform.get_wallclock\t= jailhouse_get_wallclock;\n\tx86_platform.legacy.rtc\t\t= 0;\n\tx86_platform.legacy.warm_reset\t= 0;\n\tx86_platform.legacy.i8042\t= X86_LEGACY_I8042_PLATFORM_ABSENT;\n\n\tlegacy_pic\t\t\t= &null_legacy_pic;\n\n\tmachine_ops.emergency_restart\t= jailhouse_no_restart;\n\n\twhile (pa_data) {\n\t\tmapping = early_memremap(pa_data, sizeof(header));\n\t\tmemcpy(&header, mapping, sizeof(header));\n\t\tearly_memunmap(mapping, sizeof(header));\n\n\t\tif (header.type == SETUP_JAILHOUSE)\n\t\t\tbreak;\n\n\t\tpa_data = header.next;\n\t}\n\n\tif (!pa_data)\n\t\tpanic(\"Jailhouse: No valid setup data found\");\n\n\t \n\tif (header.len < sizeof(setup_data.hdr))\n\t\tgoto unsupported;\n\n\tpa_data += offsetof(struct setup_data, data);\n\tsetup_data_len = min_t(unsigned long, sizeof(setup_data),\n\t\t\t       (unsigned long)header.len);\n\tmapping = early_memremap(pa_data, setup_data_len);\n\tmemcpy(&setup_data, mapping, setup_data_len);\n\tearly_memunmap(mapping, setup_data_len);\n\n\tif (setup_data.hdr.version == 0 ||\n\t    setup_data.hdr.compatible_version !=\n\t\tJAILHOUSE_SETUP_REQUIRED_VERSION ||\n\t    (setup_data.hdr.version == 1 && header.len < SETUP_DATA_V1_LEN) ||\n\t    (setup_data.hdr.version >= 2 && header.len < SETUP_DATA_V2_LEN))\n\t\tgoto unsupported;\n\n\tpmtmr_ioport = setup_data.v1.pm_timer_address;\n\tpr_debug(\"Jailhouse: PM-Timer IO Port: %#x\\n\", pmtmr_ioport);\n\n\tprecalibrated_tsc_khz = setup_data.v1.tsc_khz;\n\tsetup_force_cpu_cap(X86_FEATURE_TSC_KNOWN_FREQ);\n\n\tpci_probe = 0;\n\n\t \n\tdisable_acpi();\n\n\tjailhouse_serial_workaround();\n\treturn;\n\nunsupported:\n\tpanic(\"Jailhouse: Unsupported setup data structure\");\n}\n\nbool jailhouse_paravirt(void)\n{\n\treturn jailhouse_cpuid_base() != 0;\n}\n\nstatic bool __init jailhouse_x2apic_available(void)\n{\n\t \n\treturn x2apic_enabled();\n}\n\nconst struct hypervisor_x86 x86_hyper_jailhouse __refconst = {\n\t.name\t\t\t= \"Jailhouse\",\n\t.detect\t\t\t= jailhouse_detect,\n\t.init.init_platform\t= jailhouse_init_platform,\n\t.init.x2apic_available\t= jailhouse_x2apic_available,\n\t.ignore_nopv\t\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}