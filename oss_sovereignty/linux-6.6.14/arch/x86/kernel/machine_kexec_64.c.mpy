{
  "module_name": "machine_kexec_64.c",
  "hash_id": "8148ca5ad3cb75c35132b6b8829a40f38c116abd06f2b2ae32f0092791e67e3a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/machine_kexec_64.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"kexec: \" fmt\n\n#include <linux/mm.h>\n#include <linux/kexec.h>\n#include <linux/string.h>\n#include <linux/gfp.h>\n#include <linux/reboot.h>\n#include <linux/numa.h>\n#include <linux/ftrace.h>\n#include <linux/io.h>\n#include <linux/suspend.h>\n#include <linux/vmalloc.h>\n#include <linux/efi.h>\n#include <linux/cc_platform.h>\n\n#include <asm/init.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/io_apic.h>\n#include <asm/debugreg.h>\n#include <asm/kexec-bzimage64.h>\n#include <asm/setup.h>\n#include <asm/set_memory.h>\n#include <asm/cpu.h>\n\n#ifdef CONFIG_ACPI\n \nstruct init_pgtable_data {\n\tstruct x86_mapping_info *info;\n\tpgd_t *level4p;\n};\n\nstatic int mem_region_callback(struct resource *res, void *arg)\n{\n\tstruct init_pgtable_data *data = arg;\n\tunsigned long mstart, mend;\n\n\tmstart = res->start;\n\tmend = mstart + resource_size(res) - 1;\n\n\treturn kernel_ident_mapping_init(data->info, data->level4p, mstart, mend);\n}\n\nstatic int\nmap_acpi_tables(struct x86_mapping_info *info, pgd_t *level4p)\n{\n\tstruct init_pgtable_data data;\n\tunsigned long flags;\n\tint ret;\n\n\tdata.info = info;\n\tdata.level4p = level4p;\n\tflags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\tret = walk_iomem_res_desc(IORES_DESC_ACPI_TABLES, flags, 0, -1,\n\t\t\t\t  &data, mem_region_callback);\n\tif (ret && ret != -EINVAL)\n\t\treturn ret;\n\n\t \n\tret = walk_iomem_res_desc(IORES_DESC_ACPI_NV_STORAGE, flags, 0, -1,\n\t\t\t\t  &data, mem_region_callback);\n\tif (ret && ret != -EINVAL)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\nstatic int map_acpi_tables(struct x86_mapping_info *info, pgd_t *level4p) { return 0; }\n#endif\n\n#ifdef CONFIG_KEXEC_FILE\nconst struct kexec_file_ops * const kexec_file_loaders[] = {\n\t\t&kexec_bzImage64_ops,\n\t\tNULL\n};\n#endif\n\nstatic int\nmap_efi_systab(struct x86_mapping_info *info, pgd_t *level4p)\n{\n#ifdef CONFIG_EFI\n\tunsigned long mstart, mend;\n\n\tif (!efi_enabled(EFI_BOOT))\n\t\treturn 0;\n\n\tmstart = (boot_params.efi_info.efi_systab |\n\t\t\t((u64)boot_params.efi_info.efi_systab_hi<<32));\n\n\tif (efi_enabled(EFI_64BIT))\n\t\tmend = mstart + sizeof(efi_system_table_64_t);\n\telse\n\t\tmend = mstart + sizeof(efi_system_table_32_t);\n\n\tif (!mstart)\n\t\treturn 0;\n\n\treturn kernel_ident_mapping_init(info, level4p, mstart, mend);\n#endif\n\treturn 0;\n}\n\nstatic void free_transition_pgtable(struct kimage *image)\n{\n\tfree_page((unsigned long)image->arch.p4d);\n\timage->arch.p4d = NULL;\n\tfree_page((unsigned long)image->arch.pud);\n\timage->arch.pud = NULL;\n\tfree_page((unsigned long)image->arch.pmd);\n\timage->arch.pmd = NULL;\n\tfree_page((unsigned long)image->arch.pte);\n\timage->arch.pte = NULL;\n}\n\nstatic int init_transition_pgtable(struct kimage *image, pgd_t *pgd)\n{\n\tpgprot_t prot = PAGE_KERNEL_EXEC_NOENC;\n\tunsigned long vaddr, paddr;\n\tint result = -ENOMEM;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tvaddr = (unsigned long)relocate_kernel;\n\tpaddr = __pa(page_address(image->control_code_page)+PAGE_SIZE);\n\tpgd += pgd_index(vaddr);\n\tif (!pgd_present(*pgd)) {\n\t\tp4d = (p4d_t *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!p4d)\n\t\t\tgoto err;\n\t\timage->arch.p4d = p4d;\n\t\tset_pgd(pgd, __pgd(__pa(p4d) | _KERNPG_TABLE));\n\t}\n\tp4d = p4d_offset(pgd, vaddr);\n\tif (!p4d_present(*p4d)) {\n\t\tpud = (pud_t *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pud)\n\t\t\tgoto err;\n\t\timage->arch.pud = pud;\n\t\tset_p4d(p4d, __p4d(__pa(pud) | _KERNPG_TABLE));\n\t}\n\tpud = pud_offset(p4d, vaddr);\n\tif (!pud_present(*pud)) {\n\t\tpmd = (pmd_t *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pmd)\n\t\t\tgoto err;\n\t\timage->arch.pmd = pmd;\n\t\tset_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE));\n\t}\n\tpmd = pmd_offset(pud, vaddr);\n\tif (!pmd_present(*pmd)) {\n\t\tpte = (pte_t *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pte)\n\t\t\tgoto err;\n\t\timage->arch.pte = pte;\n\t\tset_pmd(pmd, __pmd(__pa(pte) | _KERNPG_TABLE));\n\t}\n\tpte = pte_offset_kernel(pmd, vaddr);\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT))\n\t\tprot = PAGE_KERNEL_EXEC;\n\n\tset_pte(pte, pfn_pte(paddr >> PAGE_SHIFT, prot));\n\treturn 0;\nerr:\n\treturn result;\n}\n\nstatic void *alloc_pgt_page(void *data)\n{\n\tstruct kimage *image = (struct kimage *)data;\n\tstruct page *page;\n\tvoid *p = NULL;\n\n\tpage = kimage_alloc_control_pages(image, 0);\n\tif (page) {\n\t\tp = page_address(page);\n\t\tclear_page(p);\n\t}\n\n\treturn p;\n}\n\nstatic int init_pgtable(struct kimage *image, unsigned long start_pgtable)\n{\n\tstruct x86_mapping_info info = {\n\t\t.alloc_pgt_page\t= alloc_pgt_page,\n\t\t.context\t= image,\n\t\t.page_flag\t= __PAGE_KERNEL_LARGE_EXEC,\n\t\t.kernpg_flag\t= _KERNPG_TABLE_NOENC,\n\t};\n\tunsigned long mstart, mend;\n\tpgd_t *level4p;\n\tint result;\n\tint i;\n\n\tlevel4p = (pgd_t *)__va(start_pgtable);\n\tclear_page(level4p);\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tinfo.page_flag   |= _PAGE_ENC;\n\t\tinfo.kernpg_flag |= _PAGE_ENC;\n\t}\n\n\tif (direct_gbpages)\n\t\tinfo.direct_gbpages = true;\n\n\tfor (i = 0; i < nr_pfn_mapped; i++) {\n\t\tmstart = pfn_mapped[i].start << PAGE_SHIFT;\n\t\tmend   = pfn_mapped[i].end << PAGE_SHIFT;\n\n\t\tresult = kernel_ident_mapping_init(&info,\n\t\t\t\t\t\t level4p, mstart, mend);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\t \n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\n\t\tresult = kernel_ident_mapping_init(&info,\n\t\t\t\t\t\t level4p, mstart, mend);\n\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\t \n\tresult = map_efi_systab(&info, level4p);\n\tif (result)\n\t\treturn result;\n\n\tresult = map_acpi_tables(&info, level4p);\n\tif (result)\n\t\treturn result;\n\n\treturn init_transition_pgtable(image, level4p);\n}\n\nstatic void load_segments(void)\n{\n\t__asm__ __volatile__ (\n\t\t\"\\tmovl %0,%%ds\\n\"\n\t\t\"\\tmovl %0,%%es\\n\"\n\t\t\"\\tmovl %0,%%ss\\n\"\n\t\t\"\\tmovl %0,%%fs\\n\"\n\t\t\"\\tmovl %0,%%gs\\n\"\n\t\t: : \"a\" (__KERNEL_DS) : \"memory\"\n\t\t);\n}\n\nint machine_kexec_prepare(struct kimage *image)\n{\n\tunsigned long start_pgtable;\n\tint result;\n\n\t \n\tstart_pgtable = page_to_pfn(image->control_code_page) << PAGE_SHIFT;\n\n\t \n\tresult = init_pgtable(image, start_pgtable);\n\tif (result)\n\t\treturn result;\n\n\treturn 0;\n}\n\nvoid machine_kexec_cleanup(struct kimage *image)\n{\n\tfree_transition_pgtable(image);\n}\n\n \nvoid machine_kexec(struct kimage *image)\n{\n\tunsigned long page_list[PAGES_NR];\n\tvoid *control_page;\n\tint save_ftrace_enabled;\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (image->preserve_context)\n\t\tsave_processor_state();\n#endif\n\n\tsave_ftrace_enabled = __ftrace_enabled_save();\n\n\t \n\tlocal_irq_disable();\n\thw_breakpoint_disable();\n\tcet_disable();\n\n\tif (image->preserve_context) {\n#ifdef CONFIG_X86_IO_APIC\n\t\t \n\t\tclear_IO_APIC();\n\t\trestore_boot_irq_mode();\n#endif\n\t}\n\n\tcontrol_page = page_address(image->control_code_page) + PAGE_SIZE;\n\t__memcpy(control_page, relocate_kernel, KEXEC_CONTROL_CODE_MAX_SIZE);\n\n\tpage_list[PA_CONTROL_PAGE] = virt_to_phys(control_page);\n\tpage_list[VA_CONTROL_PAGE] = (unsigned long)control_page;\n\tpage_list[PA_TABLE_PAGE] =\n\t  (unsigned long)__pa(page_address(image->control_code_page));\n\n\tif (image->type == KEXEC_TYPE_DEFAULT)\n\t\tpage_list[PA_SWAP_PAGE] = (page_to_pfn(image->swap_page)\n\t\t\t\t\t\t<< PAGE_SHIFT);\n\n\t \n\tload_segments();\n\t \n\tnative_idt_invalidate();\n\tnative_gdt_invalidate();\n\n\t \n\timage->start = relocate_kernel((unsigned long)image->head,\n\t\t\t\t       (unsigned long)page_list,\n\t\t\t\t       image->start,\n\t\t\t\t       image->preserve_context,\n\t\t\t\t       cc_platform_has(CC_ATTR_HOST_MEM_ENCRYPT));\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (image->preserve_context)\n\t\trestore_processor_state();\n#endif\n\n\t__ftrace_enabled_restore(save_ftrace_enabled);\n}\n\n \n\n#ifdef CONFIG_KEXEC_FILE\n \nint arch_kexec_apply_relocations_add(struct purgatory_info *pi,\n\t\t\t\t     Elf_Shdr *section, const Elf_Shdr *relsec,\n\t\t\t\t     const Elf_Shdr *symtabsec)\n{\n\tunsigned int i;\n\tElf64_Rela *rel;\n\tElf64_Sym *sym;\n\tvoid *location;\n\tunsigned long address, sec_base, value;\n\tconst char *strtab, *name, *shstrtab;\n\tconst Elf_Shdr *sechdrs;\n\n\t \n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tstrtab = (char *)pi->ehdr + sechdrs[symtabsec->sh_link].sh_offset;\n\tshstrtab = (char *)pi->ehdr + sechdrs[pi->ehdr->e_shstrndx].sh_offset;\n\n\trel = (void *)pi->ehdr + relsec->sh_offset;\n\n\tpr_debug(\"Applying relocate section %s to %u\\n\",\n\t\t shstrtab + relsec->sh_name, relsec->sh_info);\n\n\tfor (i = 0; i < relsec->sh_size / sizeof(*rel); i++) {\n\n\t\t \n\t\tlocation = pi->purgatory_buf;\n\t\tlocation += section->sh_offset;\n\t\tlocation += rel[i].r_offset;\n\n\t\t \n\t\taddress = section->sh_addr + rel[i].r_offset;\n\n\t\t \n\t\tsym = (void *)pi->ehdr + symtabsec->sh_offset;\n\t\tsym += ELF64_R_SYM(rel[i].r_info);\n\n\t\tif (sym->st_name)\n\t\t\tname = strtab + sym->st_name;\n\t\telse\n\t\t\tname = shstrtab + sechdrs[sym->st_shndx].sh_name;\n\n\t\tpr_debug(\"Symbol: %s info: %02x shndx: %02x value=%llx size: %llx\\n\",\n\t\t\t name, sym->st_info, sym->st_shndx, sym->st_value,\n\t\t\t sym->st_size);\n\n\t\tif (sym->st_shndx == SHN_UNDEF) {\n\t\t\tpr_err(\"Undefined symbol: %s\\n\", name);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tif (sym->st_shndx == SHN_COMMON) {\n\t\t\tpr_err(\"symbol '%s' in common section\\n\", name);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tif (sym->st_shndx == SHN_ABS)\n\t\t\tsec_base = 0;\n\t\telse if (sym->st_shndx >= pi->ehdr->e_shnum) {\n\t\t\tpr_err(\"Invalid section %d for symbol %s\\n\",\n\t\t\t       sym->st_shndx, name);\n\t\t\treturn -ENOEXEC;\n\t\t} else\n\t\t\tsec_base = pi->sechdrs[sym->st_shndx].sh_addr;\n\n\t\tvalue = sym->st_value;\n\t\tvalue += sec_base;\n\t\tvalue += rel[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rel[i].r_info)) {\n\t\tcase R_X86_64_NONE:\n\t\t\tbreak;\n\t\tcase R_X86_64_64:\n\t\t\t*(u64 *)location = value;\n\t\t\tbreak;\n\t\tcase R_X86_64_32:\n\t\t\t*(u32 *)location = value;\n\t\t\tif (value != *(u32 *)location)\n\t\t\t\tgoto overflow;\n\t\t\tbreak;\n\t\tcase R_X86_64_32S:\n\t\t\t*(s32 *)location = value;\n\t\t\tif ((s64)value != *(s32 *)location)\n\t\t\t\tgoto overflow;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC32:\n\t\tcase R_X86_64_PLT32:\n\t\t\tvalue -= (u64)address;\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown rela relocation: %llu\\n\",\n\t\t\t       ELF64_R_TYPE(rel[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\treturn 0;\n\noverflow:\n\tpr_err(\"Overflow in relocation type %d value 0x%lx\\n\",\n\t       (int)ELF64_R_TYPE(rel[i].r_info), value);\n\treturn -ENOEXEC;\n}\n\nint arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tvfree(image->elf_headers);\n\timage->elf_headers = NULL;\n\timage->elf_headers_sz = 0;\n\n\treturn kexec_image_post_load_cleanup_default(image);\n}\n#endif  \n\nstatic int\nkexec_mark_range(unsigned long start, unsigned long end, bool protect)\n{\n\tstruct page *page;\n\tunsigned int nr_pages;\n\n\t \n\tif (!end || start > end)\n\t\treturn 0;\n\n\tpage = pfn_to_page(start >> PAGE_SHIFT);\n\tnr_pages = (end >> PAGE_SHIFT) - (start >> PAGE_SHIFT) + 1;\n\tif (protect)\n\t\treturn set_pages_ro(page, nr_pages);\n\telse\n\t\treturn set_pages_rw(page, nr_pages);\n}\n\nstatic void kexec_mark_crashkres(bool protect)\n{\n\tunsigned long control;\n\n\tkexec_mark_range(crashk_low_res.start, crashk_low_res.end, protect);\n\n\t \n\tcontrol = PFN_PHYS(page_to_pfn(kexec_crash_image->control_code_page));\n\t \n\tkexec_mark_range(crashk_res.start, control + PAGE_SIZE - 1, protect);\n\tcontrol += KEXEC_CONTROL_PAGE_SIZE;\n\tkexec_mark_range(control, crashk_res.end, protect);\n}\n\nvoid arch_kexec_protect_crashkres(void)\n{\n\tkexec_mark_crashkres(true);\n}\n\nvoid arch_kexec_unprotect_crashkres(void)\n{\n\tkexec_mark_crashkres(false);\n}\n\n \nint arch_kexec_post_alloc_pages(void *vaddr, unsigned int pages, gfp_t gfp)\n{\n\tif (!cc_platform_has(CC_ATTR_HOST_MEM_ENCRYPT))\n\t\treturn 0;\n\n\t \n\treturn set_memory_decrypted((unsigned long)vaddr, pages);\n}\n\nvoid arch_kexec_pre_free_pages(void *vaddr, unsigned int pages)\n{\n\tif (!cc_platform_has(CC_ATTR_HOST_MEM_ENCRYPT))\n\t\treturn;\n\n\t \n\tset_memory_encrypted((unsigned long)vaddr, pages);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}