{
  "module_name": "tls.c",
  "hash_id": "5f138f5c01193bc93ab029a814771940e7b005e090cd1d53f4253a2440467b61",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/tls.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/user.h>\n#include <linux/regset.h>\n#include <linux/syscalls.h>\n#include <linux/nospec.h>\n\n#include <linux/uaccess.h>\n#include <asm/desc.h>\n#include <asm/ldt.h>\n#include <asm/processor.h>\n#include <asm/proto.h>\n#include <asm/gsseg.h>\n\n#include \"tls.h\"\n\n \nstatic int get_free_idx(void)\n{\n\tstruct thread_struct *t = &current->thread;\n\tint idx;\n\n\tfor (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)\n\t\tif (desc_empty(&t->tls_array[idx]))\n\t\t\treturn idx + GDT_ENTRY_TLS_MIN;\n\treturn -ESRCH;\n}\n\nstatic bool tls_desc_okay(const struct user_desc *info)\n{\n\t \n\tif (LDT_empty(info) || LDT_zero(info))\n\t\treturn true;\n\n\t \n\tif (!info->seg_32bit)\n\t\treturn false;\n\n\t \n\tif (info->contents > 1)\n\t\treturn false;\n\n\t \n\tif (info->seg_not_present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void set_tls_desc(struct task_struct *p, int idx,\n\t\t\t const struct user_desc *info, int n)\n{\n\tstruct thread_struct *t = &p->thread;\n\tstruct desc_struct *desc = &t->tls_array[idx - GDT_ENTRY_TLS_MIN];\n\tint cpu;\n\n\t \n\tcpu = get_cpu();\n\n\twhile (n-- > 0) {\n\t\tif (LDT_empty(info) || LDT_zero(info))\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\telse\n\t\t\tfill_ldt(desc, info);\n\t\t++info;\n\t\t++desc;\n\t}\n\n\tif (t == &current->thread)\n\t\tload_TLS(t, cpu);\n\n\tput_cpu();\n}\n\n \nint do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\tunsigned short __maybe_unused sel, modified_sel;\n\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\n\t \n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tset_tls_desc(p, idx, &info, 1);\n\n\t \n\tmodified_sel = (idx << 3) | 3;\n\n\tif (p == current) {\n#ifdef CONFIG_X86_64\n\t\tsavesegment(ds, sel);\n\t\tif (sel == modified_sel)\n\t\t\tloadsegment(ds, sel);\n\n\t\tsavesegment(es, sel);\n\t\tif (sel == modified_sel)\n\t\t\tloadsegment(es, sel);\n\n\t\tsavesegment(fs, sel);\n\t\tif (sel == modified_sel)\n\t\t\tloadsegment(fs, sel);\n#endif\n\n\t\tsavesegment(gs, sel);\n\t\tif (sel == modified_sel)\n\t\t\tload_gs_index(sel);\n\t} else {\n#ifdef CONFIG_X86_64\n\t\tif (p->thread.fsindex == modified_sel)\n\t\t\tp->thread.fsbase = info.base_addr;\n\n\t\tif (p->thread.gsindex == modified_sel)\n\t\t\tp->thread.gsbase = info.base_addr;\n#endif\n\t}\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(set_thread_area, struct user_desc __user *, u_info)\n{\n\treturn do_set_thread_area(current, -1, u_info, 1);\n}\n\n\n \n\nstatic void fill_user_desc(struct user_desc *info, int idx,\n\t\t\t   const struct desc_struct *desc)\n\n{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->entry_number = idx;\n\tinfo->base_addr = get_desc_base(desc);\n\tinfo->limit = get_desc_limit(desc);\n\tinfo->seg_32bit = desc->d;\n\tinfo->contents = desc->type >> 2;\n\tinfo->read_exec_only = !(desc->type & 2);\n\tinfo->limit_in_pages = desc->g;\n\tinfo->seg_not_present = !desc->p;\n\tinfo->useable = desc->avl;\n#ifdef CONFIG_X86_64\n\tinfo->lm = desc->l;\n#endif\n}\n\nint do_get_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info)\n{\n\tstruct user_desc info;\n\tint index;\n\n\tif (idx == -1 && get_user(idx, &u_info->entry_number))\n\t\treturn -EFAULT;\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tindex = idx - GDT_ENTRY_TLS_MIN;\n\tindex = array_index_nospec(index,\n\t\t\tGDT_ENTRY_TLS_MAX - GDT_ENTRY_TLS_MIN + 1);\n\n\tfill_user_desc(&info, idx, &p->thread.tls_array[index]);\n\n\tif (copy_to_user(u_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(get_thread_area, struct user_desc __user *, u_info)\n{\n\treturn do_get_thread_area(current, -1, u_info);\n}\n\nint regset_tls_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tstruct thread_struct *t = &target->thread;\n\tint n = GDT_ENTRY_TLS_ENTRIES;\n\twhile (n > 0 && desc_empty(&t->tls_array[n - 1]))\n\t\t--n;\n\treturn n;\n}\n\nint regset_tls_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\tconst struct desc_struct *tls;\n\tstruct user_desc v;\n\tint pos;\n\n\tfor (pos = 0, tls = target->thread.tls_array; to.left; pos++, tls++) {\n\t\tfill_user_desc(&v, GDT_ENTRY_TLS_MIN + pos, tls);\n\t\tmembuf_write(&to, &v, sizeof(v));\n\t}\n\treturn 0;\n}\n\nint regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}