{
  "module_name": "stacktrace.c",
  "hash_id": "3ce48dbe0e241099defb67c5b60a969f1aa8e7e8682eaa8eca1567f04061d98e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/stacktrace.c",
  "human_readable_source": " \n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n#include <linux/stacktrace.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <asm/stacktrace.h>\n#include <asm/unwind.h>\n\nvoid arch_stack_walk(stack_trace_consume_fn consume_entry, void *cookie,\n\t\t     struct task_struct *task, struct pt_regs *regs)\n{\n\tstruct unwind_state state;\n\tunsigned long addr;\n\n\tif (regs && !consume_entry(cookie, regs->ip))\n\t\treturn;\n\n\tfor (unwind_start(&state, task, regs, NULL); !unwind_done(&state);\n\t     unwind_next_frame(&state)) {\n\t\taddr = unwind_get_return_address(&state);\n\t\tif (!addr || !consume_entry(cookie, addr))\n\t\t\tbreak;\n\t}\n}\n\nint arch_stack_walk_reliable(stack_trace_consume_fn consume_entry,\n\t\t\t     void *cookie, struct task_struct *task)\n{\n\tstruct unwind_state state;\n\tstruct pt_regs *regs;\n\tunsigned long addr;\n\n\tfor (unwind_start(&state, task, NULL, NULL);\n\t     !unwind_done(&state) && !unwind_error(&state);\n\t     unwind_next_frame(&state)) {\n\n\t\tregs = unwind_get_entry_regs(&state, NULL);\n\t\tif (regs) {\n\t\t\t \n\t\t\tif (user_mode(regs))\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif (IS_ENABLED(CONFIG_FRAME_POINTER))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddr = unwind_get_return_address(&state);\n\n\t\t \n\t\tif (!addr)\n\t\t\treturn -EINVAL;\n\n\t\tif (!consume_entry(cookie, addr))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unwind_error(&state))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\nstruct stack_frame_user {\n\tconst void __user\t*next_fp;\n\tunsigned long\t\tret_addr;\n};\n\nstatic int\ncopy_stack_frame(const struct stack_frame_user __user *fp,\n\t\t struct stack_frame_user *frame)\n{\n\tint ret;\n\n\tif (!__access_ok(fp, sizeof(*frame)))\n\t\treturn 0;\n\n\tret = 1;\n\tpagefault_disable();\n\tif (__get_user(frame->next_fp, &fp->next_fp) ||\n\t    __get_user(frame->ret_addr, &fp->ret_addr))\n\t\tret = 0;\n\tpagefault_enable();\n\n\treturn ret;\n}\n\nvoid arch_stack_walk_user(stack_trace_consume_fn consume_entry, void *cookie,\n\t\t\t  const struct pt_regs *regs)\n{\n\tconst void __user *fp = (const void __user *)regs->bp;\n\n\tif (!consume_entry(cookie, regs->ip))\n\t\treturn;\n\n\twhile (1) {\n\t\tstruct stack_frame_user frame;\n\n\t\tframe.next_fp = NULL;\n\t\tframe.ret_addr = 0;\n\t\tif (!copy_stack_frame(fp, &frame))\n\t\t\tbreak;\n\t\tif ((unsigned long)fp < regs->sp)\n\t\t\tbreak;\n\t\tif (!frame.ret_addr)\n\t\t\tbreak;\n\t\tif (!consume_entry(cookie, frame.ret_addr))\n\t\t\tbreak;\n\t\tfp = frame.next_fp;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}