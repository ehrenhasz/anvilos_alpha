{
  "module_name": "step.c",
  "hash_id": "b752b3c348caa97b49decc35869bafb98f63cf5c76386831bd2978f36be6f5ae",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/step.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mm.h>\n#include <linux/ptrace.h>\n#include <asm/desc.h>\n#include <asm/mmu_context.h>\n\nunsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->ip;\n\tseg = regs->cs;\n\tif (v8086_mode(regs)) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t \n\tif ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc;\n\t\tunsigned long base;\n\n\t\tseg >>= 3;\n\n\t\tmutex_lock(&child->mm->context.lock);\n\t\tif (unlikely(!child->mm->context.ldt ||\n\t\t\t     seg >= child->mm->context.ldt->nr_entries))\n\t\t\taddr = -1L;  \n\t\telse {\n\t\t\tdesc = &child->mm->context.ldt->entries[seg];\n\t\t\tbase = get_desc_base(desc);\n\n\t\t\t \n\t\t\tif (!desc->d)\n\t\t\t\taddr &= 0xffff;\n\t\t\taddr += base;\n\t\t}\n\t\tmutex_unlock(&child->mm->context.lock);\n\t}\n#endif\n\n\treturn addr;\n}\n\nstatic int is_setting_trap_flag(struct task_struct *child, struct pt_regs *regs)\n{\n\tint i, copied;\n\tunsigned char opcode[15];\n\tunsigned long addr = convert_ip_to_linear(child, regs);\n\n\tcopied = access_process_vm(child, addr, opcode, sizeof(opcode),\n\t\t\tFOLL_FORCE);\n\tfor (i = 0; i < copied; i++) {\n\t\tswitch (opcode[i]) {\n\t\t \n\t\tcase 0x9d: case 0xcf:\n\t\t\treturn 1;\n\n\t\t\t \n\n\t\t \n\t\tcase 0x66: case 0x67:\n\t\t\tcontinue;\n\t\t \n\t\tcase 0x26: case 0x2e:\n\t\tcase 0x36: case 0x3e:\n\t\tcase 0x64: case 0x65:\n\t\tcase 0xf0: case 0xf2: case 0xf3:\n\t\t\tcontinue;\n\n#ifdef CONFIG_X86_64\n\t\tcase 0x40 ... 0x4f:\n\t\t\tif (!user_64bit_mode(regs))\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tcontinue;\n#endif\n\n\t\t\t \n\n\t\t \n\t\tcase 0x9c:\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int enable_single_step(struct task_struct *child)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tunsigned long oflags;\n\n\t \n\tif (unlikely(test_tsk_thread_flag(child, TIF_SINGLESTEP)))\n\t\tregs->flags |= X86_EFLAGS_TF;\n\n\t \n\tset_tsk_thread_flag(child, TIF_SINGLESTEP);\n\n\t \n\tset_task_syscall_work(child, SYSCALL_EXIT_TRAP);\n\n\toflags = regs->flags;\n\n\t \n\tregs->flags |= X86_EFLAGS_TF;\n\n\t \n\tif (is_setting_trap_flag(child, regs)) {\n\t\tclear_tsk_thread_flag(child, TIF_FORCED_TF);\n\t\treturn 0;\n\t}\n\n\t \n\tif (oflags & X86_EFLAGS_TF)\n\t\treturn test_tsk_thread_flag(child, TIF_FORCED_TF);\n\n\tset_tsk_thread_flag(child, TIF_FORCED_TF);\n\n\treturn 1;\n}\n\nvoid set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t \n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}\n\n \nstatic void enable_step(struct task_struct *child, bool block)\n{\n\t \n\tif (enable_single_step(child) && block)\n\t\tset_task_blockstep(child, true);\n\telse if (test_tsk_thread_flag(child, TIF_BLOCKSTEP))\n\t\tset_task_blockstep(child, false);\n}\n\nvoid user_enable_single_step(struct task_struct *child)\n{\n\tenable_step(child, 0);\n}\n\nvoid user_enable_block_step(struct task_struct *child)\n{\n\tenable_step(child, 1);\n}\n\nvoid user_disable_single_step(struct task_struct *child)\n{\n\t \n\tif (test_tsk_thread_flag(child, TIF_BLOCKSTEP))\n\t\tset_task_blockstep(child, false);\n\n\t \n\tclear_tsk_thread_flag(child, TIF_SINGLESTEP);\n\tclear_task_syscall_work(child, SYSCALL_EXIT_TRAP);\n\n\t \n\tif (test_and_clear_tsk_thread_flag(child, TIF_FORCED_TF))\n\t\ttask_pt_regs(child)->flags &= ~X86_EFLAGS_TF;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}