{
  "module_name": "unwind_guess.c",
  "hash_id": "c241f0ed2ad36905bccfc983a72704d9eec31e21ae70daf6dd4e86957a551ae0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/unwind_guess.c",
  "human_readable_source": "\n#include <linux/sched.h>\n#include <linux/ftrace.h>\n#include <asm/ptrace.h>\n#include <asm/bitops.h>\n#include <asm/stacktrace.h>\n#include <asm/unwind.h>\n\nunsigned long unwind_get_return_address(struct unwind_state *state)\n{\n\tunsigned long addr;\n\n\tif (unwind_done(state))\n\t\treturn 0;\n\n\taddr = READ_ONCE_NOCHECK(*state->sp);\n\n\treturn unwind_recover_ret_addr(state, addr, state->sp);\n}\nEXPORT_SYMBOL_GPL(unwind_get_return_address);\n\nunsigned long *unwind_get_return_address_ptr(struct unwind_state *state)\n{\n\treturn NULL;\n}\n\nbool unwind_next_frame(struct unwind_state *state)\n{\n\tstruct stack_info *info = &state->stack_info;\n\n\tif (unwind_done(state))\n\t\treturn false;\n\n\tdo {\n\t\tfor (state->sp++; state->sp < info->end; state->sp++) {\n\t\t\tunsigned long addr = READ_ONCE_NOCHECK(*state->sp);\n\n\t\t\tif (__kernel_text_address(addr))\n\t\t\t\treturn true;\n\t\t}\n\n\t\tstate->sp = PTR_ALIGN(info->next_sp, sizeof(long));\n\n\t} while (!get_stack_info(state->sp, state->task, info,\n\t\t\t\t &state->stack_mask));\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(unwind_next_frame);\n\nvoid __unwind_start(struct unwind_state *state, struct task_struct *task,\n\t\t    struct pt_regs *regs, unsigned long *first_frame)\n{\n\tmemset(state, 0, sizeof(*state));\n\n\tstate->task = task;\n\tstate->sp   = PTR_ALIGN(first_frame, sizeof(long));\n\n\tget_stack_info(first_frame, state->task, &state->stack_info,\n\t\t       &state->stack_mask);\n\n\t \n\tif (!unwind_done(state) &&\n\t    (!on_stack(&state->stack_info, first_frame, sizeof(long)) ||\n\t    !__kernel_text_address(*first_frame)))\n\t\tunwind_next_frame(state);\n}\nEXPORT_SYMBOL_GPL(__unwind_start);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}