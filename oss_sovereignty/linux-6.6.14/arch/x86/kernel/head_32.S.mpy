{
  "module_name": "head_32.S",
  "hash_id": "1209a2dfbf6616b5fc9891a86f0c64653ad87d5ca101e3fe8d68bac4bf6af7c1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/head_32.S",
  "human_readable_source": " \n \n\n.text\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/linkage.h>\n#include <asm/segment.h>\n#include <asm/page_types.h>\n#include <asm/pgtable_types.h>\n#include <asm/cache.h>\n#include <asm/thread_info.h>\n#include <asm/asm-offsets.h>\n#include <asm/setup.h>\n#include <asm/processor-flags.h>\n#include <asm/msr-index.h>\n#include <asm/cpufeatures.h>\n#include <asm/percpu.h>\n#include <asm/nops.h>\n#include <asm/nospec-branch.h>\n#include <asm/bootparam.h>\n#include <asm/export.h>\n#include <asm/pgtable_32.h>\n\n \n#define pa(X) ((X) - __PAGE_OFFSET)\n\n \n\n#define X86\t\tnew_cpu_data+CPUINFO_x86\n#define X86_VENDOR\tnew_cpu_data+CPUINFO_x86_vendor\n#define X86_MODEL\tnew_cpu_data+CPUINFO_x86_model\n#define X86_STEPPING\tnew_cpu_data+CPUINFO_x86_stepping\n#define X86_HARD_MATH\tnew_cpu_data+CPUINFO_hard_math\n#define X86_CPUID\tnew_cpu_data+CPUINFO_cpuid_level\n#define X86_CAPABILITY\tnew_cpu_data+CPUINFO_x86_capability\n#define X86_VENDOR_ID\tnew_cpu_data+CPUINFO_x86_vendor_id\n\n\n#define SIZEOF_PTREGS 17*4\n\n \nKERNEL_PAGES = LOWMEM_PAGES\n\nINIT_MAP_SIZE = PAGE_TABLE_SIZE(KERNEL_PAGES) * PAGE_SIZE\nRESERVE_BRK(pagetables, INIT_MAP_SIZE)\n\n \n__HEAD\nSYM_CODE_START(startup_32)\n\tmovl pa(initial_stack),%ecx\n\t\n \n\tlgdt pa(boot_gdt_descr)\n\tmovl $(__BOOT_DS),%eax\n\tmovl %eax,%ds\n\tmovl %eax,%es\n\tmovl %eax,%fs\n\tmovl %eax,%gs\n\tmovl %eax,%ss\n\tleal -__PAGE_OFFSET(%ecx),%esp\n\n \n\tcld\n\txorl %eax,%eax\n\tmovl $pa(__bss_start),%edi\n\tmovl $pa(__bss_stop),%ecx\n\tsubl %edi,%ecx\n\tshrl $2,%ecx\n\trep ; stosl\n \n\tmovl $pa(boot_params),%edi\n\tmovl $(PARAM_SIZE/4),%ecx\n\tcld\n\trep\n\tmovsl\n\tmovl pa(boot_params) + NEW_CL_POINTER,%esi\n\tandl %esi,%esi\n\tjz 1f\t\t\t# No command line\n\tmovl $pa(boot_command_line),%edi\n\tmovl $(COMMAND_LINE_SIZE/4),%ecx\n\trep\n\tmovsl\n1:\n\n#ifdef CONFIG_OLPC\n\t \n\tmovl %cr3, %eax\n\tmovl %eax, pa(olpc_ofw_pgd)\n#endif\n\n#ifdef CONFIG_MICROCODE\n\t \n\tcall load_ucode_bsp\n#endif\n\n\t \n\tcall  mk_early_pgtbl_32\n\n\t \n\tmovl $pa(initial_pg_fixmap)+PDE_IDENT_ATTR,%eax\n#ifdef  CONFIG_X86_PAE\n#define KPMDS (((-__PAGE_OFFSET) >> 30) & 3)  \n\tmovl %eax,pa(initial_pg_pmd+0x1000*KPMDS-8)\n#else\n\tmovl %eax,pa(initial_page_table+0xffc)\n#endif\n\n\tjmp .Ldefault_entry\nSYM_CODE_END(startup_32)\n\n \nSYM_FUNC_START(startup_32_smp)\n\tcld\n\tmovl $(__BOOT_DS),%eax\n\tmovl %eax,%ds\n\tmovl %eax,%es\n\tmovl %eax,%fs\n\tmovl %eax,%gs\n\tmovl pa(initial_stack),%ecx\n\tmovl %eax,%ss\n\tleal -__PAGE_OFFSET(%ecx),%esp\n\n#ifdef CONFIG_MICROCODE\n\t \n\tcall load_ucode_ap\n#endif\n\n.Ldefault_entry:\n\tmovl $(CR0_STATE & ~X86_CR0_PG),%eax\n\tmovl %eax,%cr0\n\n \n\tpushl $0\n\tpopfl\n\n \n\tmovl $-1,pa(X86_CPUID)\t\t# preset CPUID level\n\tmovl $X86_EFLAGS_ID,%ecx\n\tpushl %ecx\n\tpopfl\t\t\t\t# set EFLAGS=ID\n\tpushfl\n\tpopl %eax\t\t\t# get EFLAGS\n\ttestl $X86_EFLAGS_ID,%eax\t# did EFLAGS.ID remained set?\n\tjz .Lenable_paging\t\t# hw disallowed setting of ID bit\n\t\t\t\t\t# which means no CPUID and no CR4\n\n\txorl %eax,%eax\n\tcpuid\n\tmovl %eax,pa(X86_CPUID)\t\t# save largest std CPUID function\n\n\tmovl $1,%eax\n\tcpuid\n\tandl $~1,%edx\t\t\t# Ignore CPUID.FPU\n\tjz .Lenable_paging\t\t# No flags or only CPUID.FPU = no CR4\n\n\tmovl pa(mmu_cr4_features),%eax\n\tmovl %eax,%cr4\n\n\ttestb $X86_CR4_PAE, %al\t\t# check if PAE is enabled\n\tjz .Lenable_paging\n\n\t \n\tmovl $0x80000000, %eax\n\tcpuid\n\t \n\tsubl $0x80000001, %eax\n\tcmpl $(0x8000ffff-0x80000001), %eax\n\tja .Lenable_paging\n\n\t \n\tcall verify_cpu\n\n\tmov $0x80000001, %eax\n\tcpuid\n\t \n\tbtl $(X86_FEATURE_NX & 31), %edx\n\tjnc .Lenable_paging\n\n\t \n\tmovl $MSR_EFER, %ecx\n\trdmsr\n\n\tbtsl $_EFER_NX, %eax\n\t \n\twrmsr\n\n.Lenable_paging:\n\n \n\tmovl $pa(initial_page_table), %eax\n\tmovl %eax,%cr3\t\t \n\tmovl $CR0_STATE,%eax\n\tmovl %eax,%cr0\t\t \n\tljmp $__BOOT_CS,$1f\t \n1:\n\t \n\taddl $__PAGE_OFFSET, %esp\n\n \n\tmovb $4,X86\t\t\t# at least 486\n\tcmpl $-1,X86_CPUID\n\tje .Lis486\n\n\t \n\txorl %eax,%eax\t\t\t# call CPUID with 0 -> return vendor ID\n\tcpuid\n\tmovl %eax,X86_CPUID\t\t# save CPUID level\n\tmovl %ebx,X86_VENDOR_ID\t\t# lo 4 chars\n\tmovl %edx,X86_VENDOR_ID+4\t# next 4 chars\n\tmovl %ecx,X86_VENDOR_ID+8\t# last 4 chars\n\n\torl %eax,%eax\t\t\t# do we have processor info as well?\n\tje .Lis486\n\n\tmovl $1,%eax\t\t# Use the CPUID instruction to get CPU type\n\tcpuid\n\tmovb %al,%cl\t\t# save reg for future use\n\tandb $0x0f,%ah\t\t# mask processor family\n\tmovb %ah,X86\n\tandb $0xf0,%al\t\t# mask model\n\tshrb $4,%al\n\tmovb %al,X86_MODEL\n\tandb $0x0f,%cl\t\t# mask mask revision\n\tmovb %cl,X86_STEPPING\n\tmovl %edx,X86_CAPABILITY\n\n.Lis486:\n\tmovl $0x50022,%ecx\t# set AM, WP, NE and MP\n\tmovl %cr0,%eax\n\tandl $0x80000011,%eax\t# Save PG,PE,ET\n\torl %ecx,%eax\n\tmovl %eax,%cr0\n\n\tlgdt early_gdt_descr\n\tljmp $(__KERNEL_CS),$1f\n1:\tmovl $(__KERNEL_DS),%eax\t# reload all the segment registers\n\tmovl %eax,%ss\t\t\t# after changing gdt.\n\n\tmovl $(__USER_DS),%eax\t\t# DS/ES contains default USER segment\n\tmovl %eax,%ds\n\tmovl %eax,%es\n\n\tmovl $(__KERNEL_PERCPU), %eax\n\tmovl %eax,%fs\t\t\t# set this cpu's percpu\n\n\txorl %eax,%eax\n\tmovl %eax,%gs\t\t\t# clear possible garbage in %gs\n\n\txorl %eax,%eax\t\t\t# Clear LDT\n\tlldt %ax\n\n\tcall *(initial_code)\n1:\tjmp 1b\nSYM_FUNC_END(startup_32_smp)\n\n#include \"verify_cpu.S\"\n\n__INIT\nSYM_FUNC_START(early_idt_handler_array)\n\t# 36(%esp) %eflags\n\t# 32(%esp) %cs\n\t# 28(%esp) %eip\n\t# 24(%rsp) error code\n\ti = 0\n\t.rept NUM_EXCEPTION_VECTORS\n\t.if ((EXCEPTION_ERRCODE_MASK >> i) & 1) == 0\n\tpushl $0\t\t# Dummy error code, to make stack frame uniform\n\t.endif\n\tpushl $i\t\t# 20(%esp) Vector number\n\tjmp early_idt_handler_common\n\ti = i + 1\n\t.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc\n\t.endr\nSYM_FUNC_END(early_idt_handler_array)\n\t\nSYM_CODE_START_LOCAL(early_idt_handler_common)\n\t/*\n\t * The stack is the hardware frame, an error code or zero, and the\n\t * vector number.\n\t */\n\tcld\n\n\tincl %ss:early_recursion_flag\n\n\t/* The vector number is in pt_regs->gs */\n\n\tcld\n\tpushl\t%fs\t\t/* pt_regs->fs (__fsh varies by model) */\n\tpushl\t%es\t\t/* pt_regs->es (__esh varies by model) */\n\tpushl\t%ds\t\t/* pt_regs->ds (__dsh varies by model) */\n\tpushl\t%eax\t\t/* pt_regs->ax */\n\tpushl\t%ebp\t\t/* pt_regs->bp */\n\tpushl\t%edi\t\t/* pt_regs->di */\n\tpushl\t%esi\t\t/* pt_regs->si */\n\tpushl\t%edx\t\t/* pt_regs->dx */\n\tpushl\t%ecx\t\t/* pt_regs->cx */\n\tpushl\t%ebx\t\t/* pt_regs->bx */\n\n\t/* Fix up DS and ES */\n\tmovl\t$(__KERNEL_DS), %ecx\n\tmovl\t%ecx, %ds\n\tmovl\t%ecx, %es\n\n\t/* Load the vector number into EDX */\n\tmovl\tPT_GS(%esp), %edx\n\n\t/* Load GS into pt_regs->gs (and maybe clobber __gsh) */\n\tmovw\t%gs, PT_GS(%esp)\n\n\tmovl\t%esp, %eax\t/* args are pt_regs (EAX), trapnr (EDX) */\n\tcall\tearly_fixup_exception\n\n\tpopl\t%ebx\t\t/* pt_regs->bx */\n\tpopl\t%ecx\t\t/* pt_regs->cx */\n\tpopl\t%edx\t\t/* pt_regs->dx */\n\tpopl\t%esi\t\t/* pt_regs->si */\n\tpopl\t%edi\t\t/* pt_regs->di */\n\tpopl\t%ebp\t\t/* pt_regs->bp */\n\tpopl\t%eax\t\t/* pt_regs->ax */\n\tpopl\t%ds\t\t/* pt_regs->ds (always ignores __dsh) */\n\tpopl\t%es\t\t/* pt_regs->es (always ignores __esh) */\n\tpopl\t%fs\t\t/* pt_regs->fs (always ignores __fsh) */\n\tpopl\t%gs\t\t/* pt_regs->gs (always ignores __gsh) */\n\tdecl\t%ss:early_recursion_flag\n\taddl\t$4, %esp\t/* pop pt_regs->orig_ax */\n\tiret\nSYM_CODE_END(early_idt_handler_common)\n\n/* This is the default interrupt \"handler\" :-) */\nSYM_FUNC_START(early_ignore_irq)\n\tcld\n#ifdef CONFIG_PRINTK\n\tpushl %eax\n\tpushl %ecx\n\tpushl %edx\n\tpushl %es\n\tpushl %ds\n\tmovl $(__KERNEL_DS),%eax\n\tmovl %eax,%ds\n\tmovl %eax,%es\n\tcmpl $2,early_recursion_flag\n\tje hlt_loop\n\tincl early_recursion_flag\n\tpushl 16(%esp)\n\tpushl 24(%esp)\n\tpushl 32(%esp)\n\tpushl 40(%esp)\n\tpushl $int_msg\n\tcall _printk\n\n\tcall dump_stack\n\n\taddl $(5*4),%esp\n\tpopl %ds\n\tpopl %es\n\tpopl %edx\n\tpopl %ecx\n\tpopl %eax\n#endif\n\tiret\n\nhlt_loop:\n\thlt\n\tjmp hlt_loop\nSYM_FUNC_END(early_ignore_irq)\n\n__INITDATA\n\t.align 4\nSYM_DATA(early_recursion_flag, .long 0)\n\n__REFDATA\n\t.align 4\nSYM_DATA(initial_code,\t\t.long i386_start_kernel)\n\n#ifdef CONFIG_PAGE_TABLE_ISOLATION\n#define\tPGD_ALIGN\t(2 * PAGE_SIZE)\n#define PTI_USER_PGD_FILL\t1024\n#else\n#define\tPGD_ALIGN\t(PAGE_SIZE)\n#define PTI_USER_PGD_FILL\t0\n#endif\n/*\n * BSS section\n */\n__PAGE_ALIGNED_BSS\n\t.align PGD_ALIGN\n#ifdef CONFIG_X86_PAE\n.globl initial_pg_pmd\ninitial_pg_pmd:\n\t.fill 1024*KPMDS,4,0\n#else\n.globl initial_page_table\ninitial_page_table:\n\t.fill 1024,4,0\n#endif\n\t.align PGD_ALIGN\ninitial_pg_fixmap:\n\t.fill 1024,4,0\n.globl swapper_pg_dir\n\t.align PGD_ALIGN\nswapper_pg_dir:\n\t.fill 1024,4,0\n\t.fill PTI_USER_PGD_FILL,4,0\n.globl empty_zero_page\nempty_zero_page:\n\t.fill 4096,1,0\nEXPORT_SYMBOL(empty_zero_page)\n\n/*\n * This starts the data section.\n */\n#ifdef CONFIG_X86_PAE\n__PAGE_ALIGNED_DATA\n\t/* Page-aligned for the benefit of paravirt? */\n\t.align PGD_ALIGN\nSYM_DATA_START(initial_page_table)\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR),0\t/* low identity map */\n# if KPMDS == 3\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR),0\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR+0x1000),0\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR+0x2000),0\n# elif KPMDS == 2\n\t.long\t0,0\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR),0\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR+0x1000),0\n# elif KPMDS == 1\n\t.long\t0,0\n\t.long\t0,0\n\t.long\tpa(initial_pg_pmd+PGD_IDENT_ATTR),0\n# else\n#  error \"Kernel PMDs should be 1, 2 or 3\"\n# endif\n\t.align PAGE_SIZE\t\t/* needs to be page-sized too */\n\n#ifdef CONFIG_PAGE_TABLE_ISOLATION\n\t/*\n\t * PTI needs another page so sync_initial_pagetable() works correctly\n\t * and does not scribble over the data which is placed behind the\n\t * actual initial_page_table. See clone_pgd_range().\n\t */\n\t.fill 1024, 4, 0\n#endif\n\nSYM_DATA_END(initial_page_table)\n#endif\n\n.data\n.balign 4\n/*\n * The SIZEOF_PTREGS gap is a convention which helps the in-kernel unwinder\n * reliably detect the end of the stack.\n */\nSYM_DATA(initial_stack,\n\t\t.long init_thread_union + THREAD_SIZE -\n\t\tSIZEOF_PTREGS - TOP_OF_KERNEL_STACK_PADDING)\n\n__INITRODATA\nint_msg:\n\t.asciz \"Unknown interrupt or fault at: %p %p %p\\n\"\n\n#include \"../../x86/xen/xen-head.S\"\n\n/*\n * The IDT and GDT 'descriptors' are a strange 48-bit object\n * only used by the lidt and lgdt instructions. They are not\n * like usual segment descriptors - they consist of a 16-bit\n * segment size, and 32-bit linear address value:\n */\n\n\t.data\n\tALIGN\n# early boot GDT descriptor (must use 1:1 address mapping)\n\t.word 0\t\t\t\t# 32 bit align gdt_desc.address\nSYM_DATA_START_LOCAL(boot_gdt_descr)\n\t.word __BOOT_DS+7\n\t.long boot_gdt - __PAGE_OFFSET\nSYM_DATA_END(boot_gdt_descr)\n\n# boot GDT descriptor (later on used by CPU#0):\n\t.word 0\t\t\t\t# 32 bit align gdt_desc.address\nSYM_DATA_START(early_gdt_descr)\n\t.word GDT_ENTRIES*8-1\n\t.long gdt_page\t\t\t \nSYM_DATA_END(early_gdt_descr)\n\n \n\t.align L1_CACHE_BYTES\nSYM_DATA_START(boot_gdt)\n\t.fill GDT_ENTRY_BOOT_CS,8,0\n\t.quad 0x00cf9a000000ffff\t \n\t.quad 0x00cf92000000ffff\t \nSYM_DATA_END(boot_gdt)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}