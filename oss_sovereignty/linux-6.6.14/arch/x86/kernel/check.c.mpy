{
  "module_name": "check.c",
  "hash_id": "b70de0ad5e9d86ff5aaa7c9403221b473f4d6935291a5b09cf08fc25a5bf4117",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/check.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/memblock.h>\n\n#include <asm/proto.h>\n#include <asm/setup.h>\n\n \n#define MAX_SCAN_AREAS\t8\n\nstatic int __read_mostly memory_corruption_check = -1;\n\nstatic unsigned __read_mostly corruption_check_size = 64*1024;\nstatic unsigned __read_mostly corruption_check_period = 60;  \n\nstatic struct scan_area {\n\tu64 addr;\n\tu64 size;\n} scan_areas[MAX_SCAN_AREAS];\nstatic int num_scan_areas;\n\nstatic __init int set_corruption_check(char *arg)\n{\n\tssize_t ret;\n\tunsigned long val;\n\n\tif (!arg) {\n\t\tpr_err(\"memory_corruption_check config string not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtoul(arg, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmemory_corruption_check = val;\n\n\treturn 0;\n}\nearly_param(\"memory_corruption_check\", set_corruption_check);\n\nstatic __init int set_corruption_check_period(char *arg)\n{\n\tssize_t ret;\n\tunsigned long val;\n\n\tif (!arg) {\n\t\tpr_err(\"memory_corruption_check_period config string not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtoul(arg, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tcorruption_check_period = val;\n\treturn 0;\n}\nearly_param(\"memory_corruption_check_period\", set_corruption_check_period);\n\nstatic __init int set_corruption_check_size(char *arg)\n{\n\tchar *end;\n\tunsigned size;\n\n\tif (!arg) {\n\t\tpr_err(\"memory_corruption_check_size config string not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = memparse(arg, &end);\n\n\tif (*end == '\\0')\n\t\tcorruption_check_size = size;\n\n\treturn (size == corruption_check_size) ? 0 : -EINVAL;\n}\nearly_param(\"memory_corruption_check_size\", set_corruption_check_size);\n\n\nvoid __init setup_bios_corruption_check(void)\n{\n\tphys_addr_t start, end;\n\tu64 i;\n\n\tif (memory_corruption_check == -1) {\n\t\tmemory_corruption_check =\n#ifdef CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK\n\t\t\t1\n#else\n\t\t\t0\n#endif\n\t\t\t;\n\t}\n\n\tif (corruption_check_size == 0)\n\t\tmemory_corruption_check = 0;\n\n\tif (!memory_corruption_check)\n\t\treturn;\n\n\tcorruption_check_size = round_up(corruption_check_size, PAGE_SIZE);\n\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\n\t\t\t\tNULL) {\n\t\tstart = clamp_t(phys_addr_t, round_up(start, PAGE_SIZE),\n\t\t\t\tPAGE_SIZE, corruption_check_size);\n\t\tend = clamp_t(phys_addr_t, round_down(end, PAGE_SIZE),\n\t\t\t      PAGE_SIZE, corruption_check_size);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\tmemblock_reserve(start, end - start);\n\t\tscan_areas[num_scan_areas].addr = start;\n\t\tscan_areas[num_scan_areas].size = end - start;\n\n\t\t \n\t\tmemset(__va(start), 0, end - start);\n\n\t\tif (++num_scan_areas >= MAX_SCAN_AREAS)\n\t\t\tbreak;\n\t}\n\n\tif (num_scan_areas)\n\t\tpr_info(\"Scanning %d areas for low memory corruption\\n\", num_scan_areas);\n}\n\n\nstatic void check_for_bios_corruption(void)\n{\n\tint i;\n\tint corruption = 0;\n\n\tif (!memory_corruption_check)\n\t\treturn;\n\n\tfor (i = 0; i < num_scan_areas; i++) {\n\t\tunsigned long *addr = __va(scan_areas[i].addr);\n\t\tunsigned long size = scan_areas[i].size;\n\n\t\tfor (; size; addr++, size -= sizeof(unsigned long)) {\n\t\t\tif (!*addr)\n\t\t\t\tcontinue;\n\t\t\tpr_err(\"Corrupted low memory at %p (%lx phys) = %08lx\\n\", addr, __pa(addr), *addr);\n\t\t\tcorruption = 1;\n\t\t\t*addr = 0;\n\t\t}\n\t}\n\n\tWARN_ONCE(corruption, KERN_ERR \"Memory corruption detected in low memory\\n\");\n}\n\nstatic void check_corruption(struct work_struct *dummy);\nstatic DECLARE_DELAYED_WORK(bios_check_work, check_corruption);\n\nstatic void check_corruption(struct work_struct *dummy)\n{\n\tcheck_for_bios_corruption();\n\tschedule_delayed_work(&bios_check_work,\n\t\tround_jiffies_relative(corruption_check_period*HZ));\n}\n\nstatic int start_periodic_check_for_corruption(void)\n{\n\tif (!num_scan_areas || !memory_corruption_check || corruption_check_period == 0)\n\t\treturn 0;\n\n\tpr_info(\"Scanning for low memory corruption every %d seconds\\n\", corruption_check_period);\n\n\t \n\tschedule_delayed_work(&bios_check_work, 0);\n\n\treturn 0;\n}\ndevice_initcall(start_periodic_check_for_corruption);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}