{
  "module_name": "kexec-bzimage64.c",
  "hash_id": "f550531c50e993d1a3b6e42088e825ef64645bc61369d9a73468dc61dd2c722a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/kexec-bzimage64.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"kexec-bzImage64: \" fmt\n\n#include <linux/string.h>\n#include <linux/printk.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kexec.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/efi.h>\n#include <linux/random.h>\n\n#include <asm/bootparam.h>\n#include <asm/setup.h>\n#include <asm/crash.h>\n#include <asm/efi.h>\n#include <asm/e820/api.h>\n#include <asm/kexec-bzimage64.h>\n\n#define MAX_ELFCOREHDR_STR_LEN\t30\t \n\n \n#define MIN_PURGATORY_ADDR\t0x3000\n#define MIN_BOOTPARAM_ADDR\t0x3000\n#define MIN_KERNEL_LOAD_ADDR\t0x100000\n#define MIN_INITRD_LOAD_ADDR\t0x1000000\n\n \nstruct bzimage64_data {\n\t \n\tvoid *bootparams_buf;\n};\n\nstatic int setup_initrd(struct boot_params *params,\n\t\tunsigned long initrd_load_addr, unsigned long initrd_len)\n{\n\tparams->hdr.ramdisk_image = initrd_load_addr & 0xffffffffUL;\n\tparams->hdr.ramdisk_size = initrd_len & 0xffffffffUL;\n\n\tparams->ext_ramdisk_image = initrd_load_addr >> 32;\n\tparams->ext_ramdisk_size = initrd_len >> 32;\n\n\treturn 0;\n}\n\nstatic int setup_cmdline(struct kimage *image, struct boot_params *params,\n\t\t\t unsigned long bootparams_load_addr,\n\t\t\t unsigned long cmdline_offset, char *cmdline,\n\t\t\t unsigned long cmdline_len)\n{\n\tchar *cmdline_ptr = ((char *)params) + cmdline_offset;\n\tunsigned long cmdline_ptr_phys, len = 0;\n\tuint32_t cmdline_low_32, cmdline_ext_32;\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tlen = sprintf(cmdline_ptr,\n\t\t\t\"elfcorehdr=0x%lx \", image->elf_load_addr);\n\t}\n\tmemcpy(cmdline_ptr + len, cmdline, cmdline_len);\n\tcmdline_len += len;\n\n\tcmdline_ptr[cmdline_len - 1] = '\\0';\n\n\tpr_debug(\"Final command line is: %s\\n\", cmdline_ptr);\n\tcmdline_ptr_phys = bootparams_load_addr + cmdline_offset;\n\tcmdline_low_32 = cmdline_ptr_phys & 0xffffffffUL;\n\tcmdline_ext_32 = cmdline_ptr_phys >> 32;\n\n\tparams->hdr.cmd_line_ptr = cmdline_low_32;\n\tif (cmdline_ext_32)\n\t\tparams->ext_cmd_line_ptr = cmdline_ext_32;\n\n\treturn 0;\n}\n\nstatic int setup_e820_entries(struct boot_params *params)\n{\n\tunsigned int nr_e820_entries;\n\n\tnr_e820_entries = e820_table_kexec->nr_entries;\n\n\t \n\tif (nr_e820_entries > E820_MAX_ENTRIES_ZEROPAGE)\n\t\tnr_e820_entries = E820_MAX_ENTRIES_ZEROPAGE;\n\n\tparams->e820_entries = nr_e820_entries;\n\tmemcpy(&params->e820_table, &e820_table_kexec->entries, nr_e820_entries*sizeof(struct e820_entry));\n\n\treturn 0;\n}\n\nenum { RNG_SEED_LENGTH = 32 };\n\nstatic void\nsetup_rng_seed(struct boot_params *params, unsigned long params_load_addr,\n\t       unsigned int rng_seed_setup_data_offset)\n{\n\tstruct setup_data *sd = (void *)params + rng_seed_setup_data_offset;\n\tunsigned long setup_data_phys;\n\n\tif (!rng_is_initialized())\n\t\treturn;\n\n\tsd->type = SETUP_RNG_SEED;\n\tsd->len = RNG_SEED_LENGTH;\n\tget_random_bytes(sd->data, RNG_SEED_LENGTH);\n\tsetup_data_phys = params_load_addr + rng_seed_setup_data_offset;\n\tsd->next = params->hdr.setup_data;\n\tparams->hdr.setup_data = setup_data_phys;\n}\n\n#ifdef CONFIG_EFI\nstatic int setup_efi_info_memmap(struct boot_params *params,\n\t\t\t\t  unsigned long params_load_addr,\n\t\t\t\t  unsigned int efi_map_offset,\n\t\t\t\t  unsigned int efi_map_sz)\n{\n\tvoid *efi_map = (void *)params + efi_map_offset;\n\tunsigned long efi_map_phys_addr = params_load_addr + efi_map_offset;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!efi_map_sz)\n\t\treturn 0;\n\n\tefi_runtime_map_copy(efi_map, efi_map_sz);\n\n\tei->efi_memmap = efi_map_phys_addr & 0xffffffff;\n\tei->efi_memmap_hi = efi_map_phys_addr >> 32;\n\tei->efi_memmap_size = efi_map_sz;\n\n\treturn 0;\n}\n\nstatic int\nprepare_add_efi_setup_data(struct boot_params *params,\n\t\t       unsigned long params_load_addr,\n\t\t       unsigned int efi_setup_data_offset)\n{\n\tunsigned long setup_data_phys;\n\tstruct setup_data *sd = (void *)params + efi_setup_data_offset;\n\tstruct efi_setup_data *esd = (void *)sd + sizeof(struct setup_data);\n\n\tesd->fw_vendor = efi_fw_vendor;\n\tesd->tables = efi_config_table;\n\tesd->smbios = efi.smbios;\n\n\tsd->type = SETUP_EFI;\n\tsd->len = sizeof(struct efi_setup_data);\n\n\t \n\tsetup_data_phys = params_load_addr + efi_setup_data_offset;\n\tsd->next = params->hdr.setup_data;\n\tparams->hdr.setup_data = setup_data_phys;\n\n\treturn 0;\n}\n\nstatic int\nsetup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn 0;\n\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}\n#endif  \n\nstatic void\nsetup_ima_state(const struct kimage *image, struct boot_params *params,\n\t\tunsigned long params_load_addr,\n\t\tunsigned int ima_setup_data_offset)\n{\n#ifdef CONFIG_IMA_KEXEC\n\tstruct setup_data *sd = (void *)params + ima_setup_data_offset;\n\tunsigned long setup_data_phys;\n\tstruct ima_setup_data *ima;\n\n\tif (!image->ima_buffer_size)\n\t\treturn;\n\n\tsd->type = SETUP_IMA;\n\tsd->len = sizeof(*ima);\n\n\tima = (void *)sd + sizeof(struct setup_data);\n\tima->addr = image->ima_buffer_addr;\n\tima->size = image->ima_buffer_size;\n\n\t \n\tsetup_data_phys = params_load_addr + ima_setup_data_offset;\n\tsd->next = params->hdr.setup_data;\n\tparams->hdr.setup_data = setup_data_phys;\n#endif  \n}\n\nstatic int\nsetup_boot_parameters(struct kimage *image, struct boot_params *params,\n\t\t      unsigned long params_load_addr,\n\t\t      unsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\t      unsigned int setup_data_offset)\n{\n\tunsigned int nr_e820_entries;\n\tunsigned long long mem_k, start, end;\n\tint i, ret = 0;\n\n\t \n\tparams->hdr.hardware_subarch = boot_params.hdr.hardware_subarch;\n\n\t \n\tmemcpy(&params->screen_info, &screen_info, sizeof(struct screen_info));\n\n\t \n\tparams->screen_info.ext_mem_k = 0;\n\tparams->alt_mem_k = 0;\n\n\t \n\tparams->acpi_rsdp_addr = boot_params.acpi_rsdp_addr;\n\n\t \n\tmemset(&params->apm_bios_info, 0, sizeof(params->apm_bios_info));\n\n\t \n\tmemset(&params->hd0_info, 0, sizeof(params->hd0_info));\n\tmemset(&params->hd1_info, 0, sizeof(params->hd1_info));\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tret = crash_setup_memmap_entries(image, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\tsetup_e820_entries(params);\n\n\tnr_e820_entries = params->e820_entries;\n\n\tfor (i = 0; i < nr_e820_entries; i++) {\n\t\tif (params->e820_table[i].type != E820_TYPE_RAM)\n\t\t\tcontinue;\n\t\tstart = params->e820_table[i].addr;\n\t\tend = params->e820_table[i].addr + params->e820_table[i].size - 1;\n\n\t\tif ((start <= 0x100000) && end > 0x100000) {\n\t\t\tmem_k = (end >> 10) - (0x100000 >> 10);\n\t\t\tparams->screen_info.ext_mem_k = mem_k;\n\t\t\tparams->alt_mem_k = mem_k;\n\t\t\tif (mem_k > 0xfc00)\n\t\t\t\tparams->screen_info.ext_mem_k = 0xfc00;  \n\t\t\tif (mem_k > 0xffffffff)\n\t\t\t\tparams->alt_mem_k = 0xffffffff;\n\t\t}\n\t}\n\n#ifdef CONFIG_EFI\n\t \n\tsetup_efi_state(params, params_load_addr, efi_map_offset, efi_map_sz,\n\t\t\tsetup_data_offset);\n\tsetup_data_offset += sizeof(struct setup_data) +\n\t\t\tsizeof(struct efi_setup_data);\n#endif\n\n\tif (IS_ENABLED(CONFIG_IMA_KEXEC)) {\n\t\t \n\t\tsetup_ima_state(image, params, params_load_addr,\n\t\t\t\tsetup_data_offset);\n\t\tsetup_data_offset += sizeof(struct setup_data) +\n\t\t\t\t     sizeof(struct ima_setup_data);\n\t}\n\n\t \n\tsetup_rng_seed(params, params_load_addr, setup_data_offset);\n\n\t \n\tmemcpy(params->eddbuf, boot_params.eddbuf,\n\t\t\t\tEDDMAXNR * sizeof(struct edd_info));\n\tparams->eddbuf_entries = boot_params.eddbuf_entries;\n\n\tmemcpy(params->edd_mbr_sig_buffer, boot_params.edd_mbr_sig_buffer,\n\t       EDD_MBR_SIG_MAX * sizeof(unsigned int));\n\n\treturn ret;\n}\n\nstatic int bzImage64_probe(const char *buf, unsigned long len)\n{\n\tint ret = -ENOEXEC;\n\tstruct setup_header *header;\n\n\t \n\tif (len < 2 * 512) {\n\t\tpr_err(\"File is too short to be a bzImage\\n\");\n\t\treturn ret;\n\t}\n\n\theader = (struct setup_header *)(buf + offsetof(struct boot_params, hdr));\n\tif (memcmp((char *)&header->header, \"HdrS\", 4) != 0) {\n\t\tpr_err(\"Not a bzImage\\n\");\n\t\treturn ret;\n\t}\n\n\tif (header->boot_flag != 0xAA55) {\n\t\tpr_err(\"No x86 boot sector present\\n\");\n\t\treturn ret;\n\t}\n\n\tif (header->version < 0x020C) {\n\t\tpr_err(\"Must be at least protocol version 2.12\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(header->loadflags & LOADED_HIGH)) {\n\t\tpr_err(\"zImage not a bzImage\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(header->xloadflags & XLF_KERNEL_64)) {\n\t\tpr_err(\"Not a bzImage64. XLF_KERNEL_64 is not set.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(header->xloadflags & XLF_CAN_BE_LOADED_ABOVE_4G)) {\n\t\tpr_err(\"XLF_CAN_BE_LOADED_ABOVE_4G is not set.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (efi_enabled(EFI_RUNTIME_SERVICES) && !efi_enabled(EFI_64BIT)) {\n\t\tpr_debug(\"EFI is 32 bit. Can't load kernel above 4G.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(header->xloadflags & XLF_5LEVEL) && pgtable_l5_enabled()) {\n\t\tpr_err(\"bzImage cannot handle 5-level paging mode.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpr_debug(\"It's a relocatable bzImage64\\n\");\n\tret = 0;\n\n\treturn ret;\n}\n\nstatic void *bzImage64_load(struct kimage *image, char *kernel,\n\t\t\t    unsigned long kernel_len, char *initrd,\n\t\t\t    unsigned long initrd_len, char *cmdline,\n\t\t\t    unsigned long cmdline_len)\n{\n\n\tstruct setup_header *header;\n\tint setup_sects, kern16_size, ret = 0;\n\tunsigned long setup_header_size, params_cmdline_sz;\n\tstruct boot_params *params;\n\tunsigned long bootparam_load_addr, kernel_load_addr, initrd_load_addr;\n\tstruct bzimage64_data *ldata;\n\tstruct kexec_entry64_regs regs64;\n\tvoid *stack;\n\tunsigned int setup_hdr_offset = offsetof(struct boot_params, hdr);\n\tunsigned int efi_map_offset, efi_map_sz, efi_setup_data_offset;\n\tstruct kexec_buf kbuf = { .image = image, .buf_max = ULONG_MAX,\n\t\t\t\t  .top_down = true };\n\tstruct kexec_buf pbuf = { .image = image, .buf_min = MIN_PURGATORY_ADDR,\n\t\t\t\t  .buf_max = ULONG_MAX, .top_down = true };\n\n\theader = (struct setup_header *)(kernel + setup_hdr_offset);\n\tsetup_sects = header->setup_sects;\n\tif (setup_sects == 0)\n\t\tsetup_sects = 4;\n\n\tkern16_size = (setup_sects + 1) * 512;\n\tif (kernel_len < kern16_size) {\n\t\tpr_err(\"bzImage truncated\\n\");\n\t\treturn ERR_PTR(-ENOEXEC);\n\t}\n\n\tif (cmdline_len > header->cmdline_size) {\n\t\tpr_err(\"Kernel command line too long\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (cmdline_len + MAX_ELFCOREHDR_STR_LEN > header->cmdline_size) {\n\t\tpr_debug(\"Appending elfcorehdr=<addr> to command line exceeds maximum allowed length\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tret = crash_load_segments(image);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tret = kexec_load_purgatory(image, &pbuf);\n\tif (ret) {\n\t\tpr_err(\"Loading purgatory failed\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tpr_debug(\"Loaded purgatory at 0x%lx\\n\", pbuf.mem);\n\n\n\t \n\tefi_map_sz = efi_get_runtime_map_size();\n\tparams_cmdline_sz = sizeof(struct boot_params) + cmdline_len +\n\t\t\t\tMAX_ELFCOREHDR_STR_LEN;\n\tparams_cmdline_sz = ALIGN(params_cmdline_sz, 16);\n\tkbuf.bufsz = params_cmdline_sz + ALIGN(efi_map_sz, 16) +\n\t\t\t\tsizeof(struct setup_data) +\n\t\t\t\tsizeof(struct efi_setup_data) +\n\t\t\t\tsizeof(struct setup_data) +\n\t\t\t\tRNG_SEED_LENGTH;\n\n\tif (IS_ENABLED(CONFIG_IMA_KEXEC))\n\t\tkbuf.bufsz += sizeof(struct setup_data) +\n\t\t\t      sizeof(struct ima_setup_data);\n\n\tparams = kzalloc(kbuf.bufsz, GFP_KERNEL);\n\tif (!params)\n\t\treturn ERR_PTR(-ENOMEM);\n\tefi_map_offset = params_cmdline_sz;\n\tefi_setup_data_offset = efi_map_offset + ALIGN(efi_map_sz, 16);\n\n\t \n\tsetup_header_size = 0x0202 + kernel[0x0201] - setup_hdr_offset;\n\n\t \n\tmemcpy(&params->hdr, (kernel + setup_hdr_offset), setup_header_size);\n\n\tkbuf.buffer = params;\n\tkbuf.memsz = kbuf.bufsz;\n\tkbuf.buf_align = 16;\n\tkbuf.buf_min = MIN_BOOTPARAM_ADDR;\n\tret = kexec_add_buffer(&kbuf);\n\tif (ret)\n\t\tgoto out_free_params;\n\tbootparam_load_addr = kbuf.mem;\n\tpr_debug(\"Loaded boot_param, command line and misc at 0x%lx bufsz=0x%lx memsz=0x%lx\\n\",\n\t\t bootparam_load_addr, kbuf.bufsz, kbuf.bufsz);\n\n\t \n\tkbuf.buffer = kernel + kern16_size;\n\tkbuf.bufsz =  kernel_len - kern16_size;\n\tkbuf.memsz = PAGE_ALIGN(header->init_size);\n\tkbuf.buf_align = header->kernel_alignment;\n\tkbuf.buf_min = MIN_KERNEL_LOAD_ADDR;\n\tkbuf.mem = KEXEC_BUF_MEM_UNKNOWN;\n\tret = kexec_add_buffer(&kbuf);\n\tif (ret)\n\t\tgoto out_free_params;\n\tkernel_load_addr = kbuf.mem;\n\n\tpr_debug(\"Loaded 64bit kernel at 0x%lx bufsz=0x%lx memsz=0x%lx\\n\",\n\t\t kernel_load_addr, kbuf.bufsz, kbuf.memsz);\n\n\t \n\tif (initrd) {\n\t\tkbuf.buffer = initrd;\n\t\tkbuf.bufsz = kbuf.memsz = initrd_len;\n\t\tkbuf.buf_align = PAGE_SIZE;\n\t\tkbuf.buf_min = MIN_INITRD_LOAD_ADDR;\n\t\tkbuf.mem = KEXEC_BUF_MEM_UNKNOWN;\n\t\tret = kexec_add_buffer(&kbuf);\n\t\tif (ret)\n\t\t\tgoto out_free_params;\n\t\tinitrd_load_addr = kbuf.mem;\n\n\t\tpr_debug(\"Loaded initrd at 0x%lx bufsz=0x%lx memsz=0x%lx\\n\",\n\t\t\t\tinitrd_load_addr, initrd_len, initrd_len);\n\n\t\tsetup_initrd(params, initrd_load_addr, initrd_len);\n\t}\n\n\tsetup_cmdline(image, params, bootparam_load_addr,\n\t\t      sizeof(struct boot_params), cmdline, cmdline_len);\n\n\t \n\tparams->hdr.type_of_loader = 0x0D << 4;\n\tparams->hdr.loadflags = 0;\n\n\t \n\tret = kexec_purgatory_get_set_symbol(image, \"entry64_regs\", &regs64,\n\t\t\t\t\t     sizeof(regs64), 1);\n\tif (ret)\n\t\tgoto out_free_params;\n\n\tregs64.rbx = 0;  \n\tregs64.rsi = bootparam_load_addr;\n\tregs64.rip = kernel_load_addr + 0x200;\n\tstack = kexec_purgatory_get_symbol_addr(image, \"stack_end\");\n\tif (IS_ERR(stack)) {\n\t\tpr_err(\"Could not find address of symbol stack_end\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_params;\n\t}\n\n\tregs64.rsp = (unsigned long)stack;\n\tret = kexec_purgatory_get_set_symbol(image, \"entry64_regs\", &regs64,\n\t\t\t\t\t     sizeof(regs64), 0);\n\tif (ret)\n\t\tgoto out_free_params;\n\n\tret = setup_boot_parameters(image, params, bootparam_load_addr,\n\t\t\t\t    efi_map_offset, efi_map_sz,\n\t\t\t\t    efi_setup_data_offset);\n\tif (ret)\n\t\tgoto out_free_params;\n\n\t \n\tldata = kzalloc(sizeof(struct bzimage64_data), GFP_KERNEL);\n\tif (!ldata) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_params;\n\t}\n\n\t \n\tldata->bootparams_buf = params;\n\treturn ldata;\n\nout_free_params:\n\tkfree(params);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int bzImage64_cleanup(void *loader_data)\n{\n\tstruct bzimage64_data *ldata = loader_data;\n\n\tif (!ldata)\n\t\treturn 0;\n\n\tkfree(ldata->bootparams_buf);\n\tldata->bootparams_buf = NULL;\n\n\treturn 0;\n}\n\nconst struct kexec_file_ops kexec_bzImage64_ops = {\n\t.probe = bzImage64_probe,\n\t.load = bzImage64_load,\n\t.cleanup = bzImage64_cleanup,\n#ifdef CONFIG_KEXEC_BZIMAGE_VERIFY_SIG\n\t.verify_sig = kexec_kernel_verify_pe_sig,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}