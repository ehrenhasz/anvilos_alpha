{
  "module_name": "bootflag.c",
  "hash_id": "4b9cc2f4daa47bee535fa6f40b0ce9784d60b79f77582fbb5aca48eb8ddfa265",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/bootflag.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/acpi.h>\n#include <asm/io.h>\n\n#include <linux/mc146818rtc.h>\n\n#define SBF_RESERVED (0x78)\n#define SBF_PNPOS    (1<<0)\n#define SBF_BOOTING  (1<<1)\n#define SBF_DIAG     (1<<2)\n#define SBF_PARITY   (1<<7)\n\nint sbf_port __initdata = -1;\t \n\nstatic int __init parity(u8 v)\n{\n\tint x = 0;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tx ^= (v & 1);\n\t\tv >>= 1;\n\t}\n\n\treturn x;\n}\n\nstatic void __init sbf_write(u8 v)\n{\n\tunsigned long flags;\n\n\tif (sbf_port != -1) {\n\t\tv &= ~SBF_PARITY;\n\t\tif (!parity(v))\n\t\t\tv |= SBF_PARITY;\n\n\t\tprintk(KERN_INFO \"Simple Boot Flag at 0x%x set to 0x%x\\n\",\n\t\t\tsbf_port, v);\n\n\t\tspin_lock_irqsave(&rtc_lock, flags);\n\t\tCMOS_WRITE(v, sbf_port);\n\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t}\n}\n\nstatic u8 __init sbf_read(void)\n{\n\tunsigned long flags;\n\tu8 v;\n\n\tif (sbf_port == -1)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\tv = CMOS_READ(sbf_port);\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n\n\treturn v;\n}\n\nstatic int __init sbf_value_valid(u8 v)\n{\n\tif (v & SBF_RESERVED)\t\t \n\t\treturn 0;\n\tif (!parity(v))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int __init sbf_init(void)\n{\n\tu8 v;\n\n\tif (sbf_port == -1)\n\t\treturn 0;\n\n\tv = sbf_read();\n\tif (!sbf_value_valid(v)) {\n\t\tprintk(KERN_WARNING \"Simple Boot Flag value 0x%x read from \"\n\t\t\t\"CMOS RAM was invalid\\n\", v);\n\t}\n\n\tv &= ~SBF_RESERVED;\n\tv &= ~SBF_BOOTING;\n\tv &= ~SBF_DIAG;\n#if defined(CONFIG_ISAPNP)\n\tv |= SBF_PNPOS;\n#endif\n\tsbf_write(v);\n\n\treturn 0;\n}\narch_initcall(sbf_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}