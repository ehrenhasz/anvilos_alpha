{
  "module_name": "module.c",
  "hash_id": "ce44b1ea4c4b97c9b6198860b1eea4332cbb8918dfb3ac87bf94d1ab27e10228",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/module.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/bug.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/jump_label.h>\n#include <linux/random.h>\n#include <linux/memory.h>\n\n#include <asm/text-patching.h>\n#include <asm/page.h>\n#include <asm/setup.h>\n#include <asm/unwind.h>\n\n#if 0\n#define DEBUGP(fmt, ...)\t\t\t\t\\\n\tprintk(KERN_DEBUG fmt, ##__VA_ARGS__)\n#else\n#define DEBUGP(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG fmt, ##__VA_ARGS__);\t\\\n} while (0)\n#endif\n\n#ifdef CONFIG_RANDOMIZE_BASE\nstatic unsigned long module_load_offset;\n\n \nstatic DEFINE_MUTEX(module_kaslr_mutex);\n\nstatic unsigned long int get_module_load_offset(void)\n{\n\tif (kaslr_enabled()) {\n\t\tmutex_lock(&module_kaslr_mutex);\n\t\t \n\t\tif (module_load_offset == 0)\n\t\t\tmodule_load_offset =\n\t\t\t\tget_random_u32_inclusive(1, 1024) * PAGE_SIZE;\n\t\tmutex_unlock(&module_kaslr_mutex);\n\t}\n\treturn module_load_offset;\n}\n#else\nstatic unsigned long int get_module_load_offset(void)\n{\n\treturn 0;\n}\n#endif\n\nvoid *module_alloc(unsigned long size)\n{\n\tgfp_t gfp_mask = GFP_KERNEL;\n\tvoid *p;\n\n\tif (PAGE_ALIGN(size) > MODULES_LEN)\n\t\treturn NULL;\n\n\tp = __vmalloc_node_range(size, MODULE_ALIGN,\n\t\t\t\t MODULES_VADDR + get_module_load_offset(),\n\t\t\t\t MODULES_END, gfp_mask, PAGE_KERNEL,\n\t\t\t\t VM_FLUSH_RESET_PERMS | VM_DEFER_KMEMLEAK,\n\t\t\t\t NUMA_NO_NODE, __builtin_return_address(0));\n\n\tif (p && (kasan_alloc_module_shadow(p, size, gfp_mask) < 0)) {\n\t\tvfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\n#ifdef CONFIG_X86_32\nint apply_relocate(Elf32_Shdr *sechdrs,\n\t\t   const char *strtab,\n\t\t   unsigned int symindex,\n\t\t   unsigned int relsec,\n\t\t   struct module *me)\n{\n\tunsigned int i;\n\tElf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;\n\tElf32_Sym *sym;\n\tuint32_t *location;\n\n\tDEBUGP(\"Applying relocate section %u to %u\\n\",\n\t       relsec, sechdrs[relsec].sh_info);\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\n\t\t \n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rel[i].r_offset;\n\t\t \n\t\tsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF32_R_SYM(rel[i].r_info);\n\n\t\tswitch (ELF32_R_TYPE(rel[i].r_info)) {\n\t\tcase R_386_32:\n\t\t\t \n\t\t\t*location += sym->st_value;\n\t\t\tbreak;\n\t\tcase R_386_PC32:\n\t\tcase R_386_PLT32:\n\t\t\t \n\t\t\t*location += sym->st_value - (uint32_t)location;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown relocation: %u\\n\",\n\t\t\t       me->name, ELF32_R_TYPE(rel[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\treturn 0;\n}\n#else  \nstatic int __write_relocate_add(Elf64_Shdr *sechdrs,\n\t\t   const char *strtab,\n\t\t   unsigned int symindex,\n\t\t   unsigned int relsec,\n\t\t   struct module *me,\n\t\t   void *(*write)(void *dest, const void *src, size_t len),\n\t\t   bool apply)\n{\n\tunsigned int i;\n\tElf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;\n\tElf64_Sym *sym;\n\tvoid *loc;\n\tu64 val;\n\tu64 zero = 0ULL;\n\n\tDEBUGP(\"%s relocate section %u to %u\\n\",\n\t       apply ? \"Applying\" : \"Clearing\",\n\t       relsec, sechdrs[relsec].sh_info);\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\n\t\tsize_t size;\n\n\t\t \n\t\tloc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rel[i].r_offset;\n\n\t\t \n\t\tsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF64_R_SYM(rel[i].r_info);\n\n\t\tDEBUGP(\"type %d st_value %Lx r_addend %Lx loc %Lx\\n\",\n\t\t       (int)ELF64_R_TYPE(rel[i].r_info),\n\t\t       sym->st_value, rel[i].r_addend, (u64)loc);\n\n\t\tval = sym->st_value + rel[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rel[i].r_info)) {\n\t\tcase R_X86_64_NONE:\n\t\t\tcontinue;   \n\t\tcase R_X86_64_64:\n\t\t\tsize = 8;\n\t\t\tbreak;\n\t\tcase R_X86_64_32:\n\t\t\tif (val != *(u32 *)&val)\n\t\t\t\tgoto overflow;\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tcase R_X86_64_32S:\n\t\t\tif ((s64)val != *(s32 *)&val)\n\t\t\t\tgoto overflow;\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC32:\n\t\tcase R_X86_64_PLT32:\n\t\t\tval -= (u64)loc;\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC64:\n\t\t\tval -= (u64)loc;\n\t\t\tsize = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown rela relocation: %llu\\n\",\n\t\t\t       me->name, ELF64_R_TYPE(rel[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tif (apply) {\n\t\t\tif (memcmp(loc, &zero, size)) {\n\t\t\t\tpr_err(\"x86/modules: Invalid relocation target, existing value is nonzero for type %d, loc %p, val %Lx\\n\",\n\t\t\t\t       (int)ELF64_R_TYPE(rel[i].r_info), loc, val);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\twrite(loc, &val, size);\n\t\t} else {\n\t\t\tif (memcmp(loc, &val, size)) {\n\t\t\t\tpr_warn(\"x86/modules: Invalid relocation target, existing value does not match expected value for type %d, loc %p, val %Lx\\n\",\n\t\t\t\t\t(int)ELF64_R_TYPE(rel[i].r_info), loc, val);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\twrite(loc, &zero, size);\n\t\t}\n\t}\n\treturn 0;\n\noverflow:\n\tpr_err(\"overflow in relocation type %d val %Lx\\n\",\n\t       (int)ELF64_R_TYPE(rel[i].r_info), val);\n\tpr_err(\"`%s' likely not compiled with -mcmodel=kernel\\n\",\n\t       me->name);\n\treturn -ENOEXEC;\n}\n\nstatic int write_relocate_add(Elf64_Shdr *sechdrs,\n\t\t\t      const char *strtab,\n\t\t\t      unsigned int symindex,\n\t\t\t      unsigned int relsec,\n\t\t\t      struct module *me,\n\t\t\t      bool apply)\n{\n\tint ret;\n\tbool early = me->state == MODULE_STATE_UNFORMED;\n\tvoid *(*write)(void *, const void *, size_t) = memcpy;\n\n\tif (!early) {\n\t\twrite = text_poke;\n\t\tmutex_lock(&text_mutex);\n\t}\n\n\tret = __write_relocate_add(sechdrs, strtab, symindex, relsec, me,\n\t\t\t\t   write, apply);\n\n\tif (!early) {\n\t\ttext_poke_sync();\n\t\tmutex_unlock(&text_mutex);\n\t}\n\n\treturn ret;\n}\n\nint apply_relocate_add(Elf64_Shdr *sechdrs,\n\t\t   const char *strtab,\n\t\t   unsigned int symindex,\n\t\t   unsigned int relsec,\n\t\t   struct module *me)\n{\n\treturn write_relocate_add(sechdrs, strtab, symindex, relsec, me, true);\n}\n\n#ifdef CONFIG_LIVEPATCH\nvoid clear_relocate_add(Elf64_Shdr *sechdrs,\n\t\t\tconst char *strtab,\n\t\t\tunsigned int symindex,\n\t\t\tunsigned int relsec,\n\t\t\tstruct module *me)\n{\n\twrite_relocate_add(sechdrs, strtab, symindex, relsec, me, false);\n}\n#endif\n\n#endif\n\nint module_finalize(const Elf_Ehdr *hdr,\n\t\t    const Elf_Shdr *sechdrs,\n\t\t    struct module *me)\n{\n\tconst Elf_Shdr *s, *alt = NULL, *locks = NULL,\n\t\t*para = NULL, *orc = NULL, *orc_ip = NULL,\n\t\t*retpolines = NULL, *returns = NULL, *ibt_endbr = NULL,\n\t\t*calls = NULL, *cfi = NULL;\n\tchar *secstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\n\n\tfor (s = sechdrs; s < sechdrs + hdr->e_shnum; s++) {\n\t\tif (!strcmp(\".altinstructions\", secstrings + s->sh_name))\n\t\t\talt = s;\n\t\tif (!strcmp(\".smp_locks\", secstrings + s->sh_name))\n\t\t\tlocks = s;\n\t\tif (!strcmp(\".parainstructions\", secstrings + s->sh_name))\n\t\t\tpara = s;\n\t\tif (!strcmp(\".orc_unwind\", secstrings + s->sh_name))\n\t\t\torc = s;\n\t\tif (!strcmp(\".orc_unwind_ip\", secstrings + s->sh_name))\n\t\t\torc_ip = s;\n\t\tif (!strcmp(\".retpoline_sites\", secstrings + s->sh_name))\n\t\t\tretpolines = s;\n\t\tif (!strcmp(\".return_sites\", secstrings + s->sh_name))\n\t\t\treturns = s;\n\t\tif (!strcmp(\".call_sites\", secstrings + s->sh_name))\n\t\t\tcalls = s;\n\t\tif (!strcmp(\".cfi_sites\", secstrings + s->sh_name))\n\t\t\tcfi = s;\n\t\tif (!strcmp(\".ibt_endbr_seal\", secstrings + s->sh_name))\n\t\t\tibt_endbr = s;\n\t}\n\n\t \n\tif (para) {\n\t\tvoid *pseg = (void *)para->sh_addr;\n\t\tapply_paravirt(pseg, pseg + para->sh_size);\n\t}\n\tif (retpolines || cfi) {\n\t\tvoid *rseg = NULL, *cseg = NULL;\n\t\tunsigned int rsize = 0, csize = 0;\n\n\t\tif (retpolines) {\n\t\t\trseg = (void *)retpolines->sh_addr;\n\t\t\trsize = retpolines->sh_size;\n\t\t}\n\n\t\tif (cfi) {\n\t\t\tcseg = (void *)cfi->sh_addr;\n\t\t\tcsize = cfi->sh_size;\n\t\t}\n\n\t\tapply_fineibt(rseg, rseg + rsize, cseg, cseg + csize);\n\t}\n\tif (retpolines) {\n\t\tvoid *rseg = (void *)retpolines->sh_addr;\n\t\tapply_retpolines(rseg, rseg + retpolines->sh_size);\n\t}\n\tif (returns) {\n\t\tvoid *rseg = (void *)returns->sh_addr;\n\t\tapply_returns(rseg, rseg + returns->sh_size);\n\t}\n\tif (alt) {\n\t\t \n\t\tvoid *aseg = (void *)alt->sh_addr;\n\t\tapply_alternatives(aseg, aseg + alt->sh_size);\n\t}\n\tif (calls || para) {\n\t\tstruct callthunk_sites cs = {};\n\n\t\tif (calls) {\n\t\t\tcs.call_start = (void *)calls->sh_addr;\n\t\t\tcs.call_end = (void *)calls->sh_addr + calls->sh_size;\n\t\t}\n\n\t\tif (para) {\n\t\t\tcs.pv_start = (void *)para->sh_addr;\n\t\t\tcs.pv_end = (void *)para->sh_addr + para->sh_size;\n\t\t}\n\n\t\tcallthunks_patch_module_calls(&cs, me);\n\t}\n\tif (ibt_endbr) {\n\t\tvoid *iseg = (void *)ibt_endbr->sh_addr;\n\t\tapply_seal_endbr(iseg, iseg + ibt_endbr->sh_size);\n\t}\n\tif (locks) {\n\t\tvoid *lseg = (void *)locks->sh_addr;\n\t\tvoid *text = me->mem[MOD_TEXT].base;\n\t\tvoid *text_end = text + me->mem[MOD_TEXT].size;\n\t\talternatives_smp_module_add(me, me->name,\n\t\t\t\t\t    lseg, lseg + locks->sh_size,\n\t\t\t\t\t    text, text_end);\n\t}\n\n\tif (orc && orc_ip)\n\t\tunwind_module_init(me, (void *)orc_ip->sh_addr, orc_ip->sh_size,\n\t\t\t\t   (void *)orc->sh_addr, orc->sh_size);\n\n\treturn 0;\n}\n\nvoid module_arch_cleanup(struct module *mod)\n{\n\talternatives_smp_module_del(mod);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}