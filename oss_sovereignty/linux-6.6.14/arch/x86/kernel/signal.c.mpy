{
  "module_name": "signal.c",
  "hash_id": "49d4389716b6840deeab90b7f67946c545adc9d899c48a855cf0022c5eb5c843",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/signal.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/errno.h>\n#include <linux/wait.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/personality.h>\n#include <linux/uaccess.h>\n#include <linux/user-return-notifier.h>\n#include <linux/uprobes.h>\n#include <linux/context_tracking.h>\n#include <linux/entry-common.h>\n#include <linux/syscalls.h>\n\n#include <asm/processor.h>\n#include <asm/ucontext.h>\n#include <asm/fpu/signal.h>\n#include <asm/fpu/xstate.h>\n#include <asm/vdso.h>\n#include <asm/mce.h>\n#include <asm/sighandling.h>\n#include <asm/vm86.h>\n\n#include <asm/syscall.h>\n#include <asm/sigframe.h>\n#include <asm/signal.h>\n#include <asm/shstk.h>\n\nstatic inline int is_ia32_compat_frame(struct ksignal *ksig)\n{\n\treturn IS_ENABLED(CONFIG_IA32_EMULATION) &&\n\t\tksig->ka.sa.sa_flags & SA_IA32_ABI;\n}\n\nstatic inline int is_ia32_frame(struct ksignal *ksig)\n{\n\treturn IS_ENABLED(CONFIG_X86_32) || is_ia32_compat_frame(ksig);\n}\n\nstatic inline int is_x32_frame(struct ksignal *ksig)\n{\n\treturn IS_ENABLED(CONFIG_X86_X32_ABI) &&\n\t\tksig->ka.sa.sa_flags & SA_X32_ABI;\n}\n\n \n\n \n#define FRAME_ALIGNMENT\t16UL\n\n#define MAX_FRAME_PADDING\t(FRAME_ALIGNMENT - 1)\n\n \nvoid __user *\nget_sigframe(struct ksignal *ksig, struct pt_regs *regs, size_t frame_size,\n\t     void __user **fpstate)\n{\n\tstruct k_sigaction *ka = &ksig->ka;\n\tint ia32_frame = is_ia32_frame(ksig);\n\t \n\tbool nested_altstack = on_sig_stack(regs->sp);\n\tbool entering_altstack = false;\n\tunsigned long math_size = 0;\n\tunsigned long sp = regs->sp;\n\tunsigned long buf_fx = 0;\n\n\t \n\tif (!ia32_frame)\n\t\tsp -= 128;\n\n\t \n\tif (ka->sa.sa_flags & SA_ONSTACK) {\n\t\t \n\t\tif (sas_ss_flags(sp) == 0) {\n\t\t\tsp = current->sas_ss_sp + current->sas_ss_size;\n\t\t\tentering_altstack = true;\n\t\t}\n\t} else if (ia32_frame &&\n\t\t   !nested_altstack &&\n\t\t   regs->ss != __USER_DS &&\n\t\t   !(ka->sa.sa_flags & SA_RESTORER) &&\n\t\t   ka->sa.sa_restorer) {\n\t\t \n\t\tsp = (unsigned long) ka->sa.sa_restorer;\n\t\tentering_altstack = true;\n\t}\n\n\tsp = fpu__alloc_mathframe(sp, ia32_frame, &buf_fx, &math_size);\n\t*fpstate = (void __user *)sp;\n\n\tsp -= frame_size;\n\n\tif (ia32_frame)\n\t\t \n\t\tsp = ((sp + 4) & -FRAME_ALIGNMENT) - 4;\n\telse\n\t\tsp = round_down(sp, FRAME_ALIGNMENT) - 8;\n\n\t \n\tif (unlikely((nested_altstack || entering_altstack) &&\n\t\t     !__on_sig_stack(sp))) {\n\n\t\tif (show_unhandled_signals && printk_ratelimit())\n\t\t\tpr_info(\"%s[%d] overflowed sigaltstack\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current));\n\n\t\treturn (void __user *)-1L;\n\t}\n\n\t \n\tif (!copy_fpstate_to_sigframe(*fpstate, (void __user *)buf_fx, math_size))\n\t\treturn (void __user *)-1L;\n\n\treturn (void __user *)sp;\n}\n\n \n#if defined(CONFIG_X86_32) || defined(CONFIG_IA32_EMULATION)\n# define MAX_FRAME_SIGINFO_UCTXT_SIZE\tsizeof(struct sigframe_ia32)\n#else\n# define MAX_FRAME_SIGINFO_UCTXT_SIZE\tsizeof(struct rt_sigframe)\n#endif\n\n \n#define MAX_XSAVE_PADDING\t63UL\n\n \n\n \nstatic unsigned long __ro_after_init max_frame_size;\nstatic unsigned int __ro_after_init fpu_default_state_size;\n\nstatic int __init init_sigframe_size(void)\n{\n\tfpu_default_state_size = fpu__get_fpstate_size();\n\n\tmax_frame_size = MAX_FRAME_SIGINFO_UCTXT_SIZE + MAX_FRAME_PADDING;\n\n\tmax_frame_size += fpu_default_state_size + MAX_XSAVE_PADDING;\n\n\t \n\tmax_frame_size = round_up(max_frame_size, FRAME_ALIGNMENT);\n\n\tpr_info(\"max sigframe size: %lu\\n\", max_frame_size);\n\treturn 0;\n}\nearly_initcall(init_sigframe_size);\n\nunsigned long get_sigframe_size(void)\n{\n\treturn max_frame_size;\n}\n\nstatic int\nsetup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n\t \n\trseq_signal_deliver(ksig, regs);\n\n\t \n\tif (is_ia32_frame(ksig)) {\n\t\tif (ksig->ka.sa.sa_flags & SA_SIGINFO)\n\t\t\treturn ia32_setup_rt_frame(ksig, regs);\n\t\telse\n\t\t\treturn ia32_setup_frame(ksig, regs);\n\t} else if (is_x32_frame(ksig)) {\n\t\treturn x32_setup_rt_frame(ksig, regs);\n\t} else {\n\t\treturn x64_setup_rt_frame(ksig, regs);\n\t}\n}\n\nstatic void\nhandle_signal(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tbool stepping, failed;\n\tstruct fpu *fpu = &current->thread.fpu;\n\n\tif (v8086_mode(regs))\n\t\tsave_v86_state((struct kernel_vm86_regs *) regs, VM86_SIGNAL);\n\n\t \n\tif (syscall_get_nr(current, regs) != -1) {\n\t\t \n\t\tswitch (syscall_get_error(current, regs)) {\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\tcase -ERESTARTNOHAND:\n\t\t\tregs->ax = -EINTR;\n\t\t\tbreak;\n\n\t\tcase -ERESTARTSYS:\n\t\t\tif (!(ksig->ka.sa.sa_flags & SA_RESTART)) {\n\t\t\t\tregs->ax = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -ERESTARTNOINTR:\n\t\t\tregs->ax = regs->orig_ax;\n\t\t\tregs->ip -= 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tstepping = test_thread_flag(TIF_SINGLESTEP);\n\tif (stepping)\n\t\tuser_disable_single_step(current);\n\n\tfailed = (setup_rt_frame(ksig, regs) < 0);\n\tif (!failed) {\n\t\t \n\t\tregs->flags &= ~(X86_EFLAGS_DF|X86_EFLAGS_RF|X86_EFLAGS_TF);\n\t\t \n\t\tfpu__clear_user_states(fpu);\n\t}\n\tsignal_setup_done(failed, ksig, stepping);\n}\n\nstatic inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)\n{\n#ifdef CONFIG_IA32_EMULATION\n\tif (current->restart_block.arch_data & TS_COMPAT)\n\t\treturn __NR_ia32_restart_syscall;\n#endif\n#ifdef CONFIG_X86_X32_ABI\n\treturn __NR_restart_syscall | (regs->orig_ax & __X32_SYSCALL_BIT);\n#else\n\treturn __NR_restart_syscall;\n#endif\n}\n\n \nvoid arch_do_signal_or_restart(struct pt_regs *regs)\n{\n\tstruct ksignal ksig;\n\n\tif (get_signal(&ksig)) {\n\t\t \n\t\thandle_signal(&ksig, regs);\n\t\treturn;\n\t}\n\n\t \n\tif (syscall_get_nr(current, regs) != -1) {\n\t\t \n\t\tswitch (syscall_get_error(current, regs)) {\n\t\tcase -ERESTARTNOHAND:\n\t\tcase -ERESTARTSYS:\n\t\tcase -ERESTARTNOINTR:\n\t\t\tregs->ax = regs->orig_ax;\n\t\t\tregs->ip -= 2;\n\t\t\tbreak;\n\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\t\tregs->ax = get_nr_restart_syscall(regs);\n\t\t\tregs->ip -= 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\trestore_saved_sigmask();\n}\n\nvoid signal_fault(struct pt_regs *regs, void __user *frame, char *where)\n{\n\tstruct task_struct *me = current;\n\n\tif (show_unhandled_signals && printk_ratelimit()) {\n\t\tprintk(\"%s\"\n\t\t       \"%s[%d] bad frame in %s frame:%p ip:%lx sp:%lx orax:%lx\",\n\t\t       task_pid_nr(current) > 1 ? KERN_INFO : KERN_EMERG,\n\t\t       me->comm, me->pid, where, frame,\n\t\t       regs->ip, regs->sp, regs->orig_ax);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig(SIGSEGV);\n}\n\n#ifdef CONFIG_DYNAMIC_SIGFRAME\n#ifdef CONFIG_STRICT_SIGALTSTACK_SIZE\nstatic bool strict_sigaltstack_size __ro_after_init = true;\n#else\nstatic bool strict_sigaltstack_size __ro_after_init = false;\n#endif\n\nstatic int __init strict_sas_size(char *arg)\n{\n\treturn kstrtobool(arg, &strict_sigaltstack_size) == 0;\n}\n__setup(\"strict_sas_size\", strict_sas_size);\n\n \nbool sigaltstack_size_valid(size_t ss_size)\n{\n\tunsigned long fsize = max_frame_size - fpu_default_state_size;\n\tu64 mask;\n\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!fpu_state_size_dynamic() && !strict_sigaltstack_size)\n\t\treturn true;\n\n\tfsize += current->group_leader->thread.fpu.perm.__user_state_size;\n\tif (likely(ss_size > fsize))\n\t\treturn true;\n\n\tif (strict_sigaltstack_size)\n\t\treturn ss_size > fsize;\n\n\tmask = current->group_leader->thread.fpu.perm.__state_perm;\n\tif (mask & XFEATURE_MASK_USER_DYNAMIC)\n\t\treturn ss_size > fsize;\n\n\treturn true;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}