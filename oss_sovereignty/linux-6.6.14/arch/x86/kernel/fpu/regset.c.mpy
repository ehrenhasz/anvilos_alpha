{
  "module_name": "regset.c",
  "hash_id": "34a32aa7c8124f1d06f5f7db874db561834113c12a15f4cce9c9ca6a60d82b32",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/fpu/regset.c",
  "human_readable_source": "\n \n#include <linux/sched/task_stack.h>\n#include <linux/vmalloc.h>\n\n#include <asm/fpu/api.h>\n#include <asm/fpu/signal.h>\n#include <asm/fpu/regset.h>\n#include <asm/prctl.h>\n\n#include \"context.h\"\n#include \"internal.h\"\n#include \"legacy.h\"\n#include \"xstate.h\"\n\n \nint regset_fpregs_active(struct task_struct *target, const struct user_regset *regset)\n{\n\treturn regset->n;\n}\n\nint regset_xregset_fpregs_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (boot_cpu_has(X86_FEATURE_FXSR))\n\t\treturn regset->n;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void sync_fpstate(struct fpu *fpu)\n{\n\tif (fpu == &current->thread.fpu)\n\t\tfpu_sync_fpstate(fpu);\n}\n\n \nstatic void fpu_force_restore(struct fpu *fpu)\n{\n\t \n\tWARN_ON_FPU(fpu == &current->thread.fpu);\n\n\t__fpu_invalidate_fpregs_state(fpu);\n}\n\nint xfpregs_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_FXSR))\n\t\treturn -ENODEV;\n\n\tsync_fpstate(fpu);\n\n\tif (!use_xsave()) {\n\t\treturn membuf_write(&to, &fpu->fpstate->regs.fxsave,\n\t\t\t\t    sizeof(fpu->fpstate->regs.fxsave));\n\t}\n\n\tcopy_xstate_to_uabi_buf(to, target, XSTATE_COPY_FX);\n\treturn 0;\n}\n\nint xfpregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct fxregs_state newstate;\n\tint ret;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_FXSR))\n\t\treturn -ENODEV;\n\n\t \n\tif (pos != 0 || count != sizeof(newstate))\n\t\treturn -EINVAL;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &newstate, 0, -1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (newstate.mxcsr & ~mxcsr_feature_mask)\n\t\treturn -EINVAL;\n\n\tfpu_force_restore(fpu);\n\n\t \n\tmemcpy(&fpu->fpstate->regs.fxsave, &newstate, sizeof(newstate));\n\n\t \n\tBUILD_BUG_ON(sizeof(fpu->__fpstate.regs.fxsave.xmm_space) != 16 * 16);\n\tif (in_ia32_syscall())\n\t\tmemset(&fpu->fpstate->regs.fxsave.xmm_space[8*4], 0, 8 * 16);\n\n\t \n\tif (use_xsave())\n\t\tfpu->fpstate->regs.xsave.header.xfeatures |= XFEATURE_MASK_FPSSE;\n\n\treturn 0;\n}\n\nint xstateregs_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\tsync_fpstate(&target->thread.fpu);\n\n\tcopy_xstate_to_uabi_buf(to, target, XSTATE_COPY_XSAVE);\n\treturn 0;\n}\n\nint xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *tmpbuf = NULL;\n\tint ret;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\t \n\tif (pos != 0 || count != fpu_user_cfg.max_size)\n\t\treturn -EFAULT;\n\n\tif (!kbuf) {\n\t\ttmpbuf = vmalloc(count);\n\t\tif (!tmpbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(tmpbuf, ubuf, count)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfpu_force_restore(fpu);\n\tret = copy_uabi_from_kernel_to_xstate(fpu->fpstate, kbuf ?: tmpbuf, &target->thread.pkru);\n\nout:\n\tvfree(tmpbuf);\n\treturn ret;\n}\n\n#ifdef CONFIG_X86_USER_SHADOW_STACK\nint ssp_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (target->thread.features & ARCH_SHSTK_SHSTK)\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nint ssp_get(struct task_struct *target, const struct user_regset *regset,\n\t    struct membuf to)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct cet_user_state *cetregs;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n\t\treturn -ENODEV;\n\n\tsync_fpstate(fpu);\n\tcetregs = get_xsave_addr(&fpu->fpstate->regs.xsave, XFEATURE_CET_USER);\n\tif (WARN_ON(!cetregs)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\treturn membuf_write(&to, (unsigned long *)&cetregs->user_ssp,\n\t\t\t    sizeof(cetregs->user_ssp));\n}\n\nint ssp_set(struct task_struct *target, const struct user_regset *regset,\n\t    unsigned int pos, unsigned int count,\n\t    const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave = &fpu->fpstate->regs.xsave;\n\tstruct cet_user_state *cetregs;\n\tunsigned long user_ssp;\n\tint r;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n\t    !ssp_active(target, regset))\n\t\treturn -ENODEV;\n\n\tif (pos != 0 || count != sizeof(user_ssp))\n\t\treturn -EINVAL;\n\n\tr = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &user_ssp, 0, -1);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (user_ssp >= TASK_SIZE_MAX || !IS_ALIGNED(user_ssp, 8))\n\t\treturn -EINVAL;\n\n\tfpu_force_restore(fpu);\n\n\tcetregs = get_xsave_addr(xsave, XFEATURE_CET_USER);\n\tif (WARN_ON(!cetregs)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tcetregs->user_ssp = user_ssp;\n\treturn 0;\n}\n#endif  \n\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\n \n\nstatic inline unsigned short twd_i387_to_fxsr(unsigned short twd)\n{\n\tunsigned int tmp;  \n\n\t \n\ttmp = ~twd;\n\ttmp = (tmp | (tmp>>1)) & 0x5555;  \n\t \n\ttmp = (tmp | (tmp >> 1)) & 0x3333;  \n\ttmp = (tmp | (tmp >> 2)) & 0x0f0f;  \n\ttmp = (tmp | (tmp >> 4)) & 0x00ff;  \n\n\treturn tmp;\n}\n\n#define FPREG_ADDR(f, n)\t((void *)&(f)->st_space + (n) * 16)\n#define FP_EXP_TAG_VALID\t0\n#define FP_EXP_TAG_ZERO\t\t1\n#define FP_EXP_TAG_SPECIAL\t2\n#define FP_EXP_TAG_EMPTY\t3\n\nstatic inline u32 twd_fxsr_to_i387(struct fxregs_state *fxsave)\n{\n\tstruct _fpxreg *st;\n\tu32 tos = (fxsave->swd >> 11) & 7;\n\tu32 twd = (unsigned long) fxsave->twd;\n\tu32 tag;\n\tu32 ret = 0xffff0000u;\n\tint i;\n\n\tfor (i = 0; i < 8; i++, twd >>= 1) {\n\t\tif (twd & 0x1) {\n\t\t\tst = FPREG_ADDR(fxsave, (i - tos) & 7);\n\n\t\t\tswitch (st->exponent & 0x7fff) {\n\t\t\tcase 0x7fff:\n\t\t\t\ttag = FP_EXP_TAG_SPECIAL;\n\t\t\t\tbreak;\n\t\t\tcase 0x0000:\n\t\t\t\tif (!st->significand[0] &&\n\t\t\t\t    !st->significand[1] &&\n\t\t\t\t    !st->significand[2] &&\n\t\t\t\t    !st->significand[3])\n\t\t\t\t\ttag = FP_EXP_TAG_ZERO;\n\t\t\t\telse\n\t\t\t\t\ttag = FP_EXP_TAG_SPECIAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (st->significand[3] & 0x8000)\n\t\t\t\t\ttag = FP_EXP_TAG_VALID;\n\t\t\t\telse\n\t\t\t\t\ttag = FP_EXP_TAG_SPECIAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ttag = FP_EXP_TAG_EMPTY;\n\t\t}\n\t\tret |= tag << (2 * i);\n\t}\n\treturn ret;\n}\n\n \n\nstatic void __convert_from_fxsr(struct user_i387_ia32_struct *env,\n\t\t\t\tstruct task_struct *tsk,\n\t\t\t\tstruct fxregs_state *fxsave)\n{\n\tstruct _fpreg *to = (struct _fpreg *) &env->st_space[0];\n\tstruct _fpxreg *from = (struct _fpxreg *) &fxsave->st_space[0];\n\tint i;\n\n\tenv->cwd = fxsave->cwd | 0xffff0000u;\n\tenv->swd = fxsave->swd | 0xffff0000u;\n\tenv->twd = twd_fxsr_to_i387(fxsave);\n\n#ifdef CONFIG_X86_64\n\tenv->fip = fxsave->rip;\n\tenv->foo = fxsave->rdp;\n\t \n\tenv->fcs = task_pt_regs(tsk)->cs;\n\tif (tsk == current) {\n\t\tsavesegment(ds, env->fos);\n\t} else {\n\t\tenv->fos = tsk->thread.ds;\n\t}\n\tenv->fos |= 0xffff0000;\n#else\n\tenv->fip = fxsave->fip;\n\tenv->fcs = (u16) fxsave->fcs | ((u32) fxsave->fop << 16);\n\tenv->foo = fxsave->foo;\n\tenv->fos = fxsave->fos;\n#endif\n\n\tfor (i = 0; i < 8; ++i)\n\t\tmemcpy(&to[i], &from[i], sizeof(to[0]));\n}\n\nvoid\nconvert_from_fxsr(struct user_i387_ia32_struct *env, struct task_struct *tsk)\n{\n\t__convert_from_fxsr(env, tsk, &tsk->thread.fpu.fpstate->regs.fxsave);\n}\n\nvoid convert_to_fxsr(struct fxregs_state *fxsave,\n\t\t     const struct user_i387_ia32_struct *env)\n\n{\n\tstruct _fpreg *from = (struct _fpreg *) &env->st_space[0];\n\tstruct _fpxreg *to = (struct _fpxreg *) &fxsave->st_space[0];\n\tint i;\n\n\tfxsave->cwd = env->cwd;\n\tfxsave->swd = env->swd;\n\tfxsave->twd = twd_i387_to_fxsr(env->twd);\n\tfxsave->fop = (u16) ((u32) env->fcs >> 16);\n#ifdef CONFIG_X86_64\n\tfxsave->rip = env->fip;\n\tfxsave->rdp = env->foo;\n\t \n#else\n\tfxsave->fip = env->fip;\n\tfxsave->fcs = (env->fcs & 0xffff);\n\tfxsave->foo = env->foo;\n\tfxsave->fos = env->fos;\n#endif\n\n\tfor (i = 0; i < 8; ++i)\n\t\tmemcpy(&to[i], &from[i], sizeof(from[0]));\n}\n\nint fpregs_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct user_i387_ia32_struct env;\n\tstruct fxregs_state fxsave, *fx;\n\n\tsync_fpstate(fpu);\n\n\tif (!cpu_feature_enabled(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_get(target, regset, to);\n\n\tif (!cpu_feature_enabled(X86_FEATURE_FXSR)) {\n\t\treturn membuf_write(&to, &fpu->fpstate->regs.fsave,\n\t\t\t\t    sizeof(struct fregs_state));\n\t}\n\n\tif (use_xsave()) {\n\t\tstruct membuf mb = { .p = &fxsave, .left = sizeof(fxsave) };\n\n\t\t \n\t\tcopy_xstate_to_uabi_buf(mb, target, XSTATE_COPY_FP);\n\t\tfx = &fxsave;\n\t} else {\n\t\tfx = &fpu->fpstate->regs.fxsave;\n\t}\n\n\t__convert_from_fxsr(&env, target, fx);\n\treturn membuf_write(&to, &env, sizeof(env));\n}\n\nint fpregs_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct user_i387_ia32_struct env;\n\tint ret;\n\n\t \n\tif (pos != 0 || count != sizeof(struct user_i387_ia32_struct))\n\t\treturn -EINVAL;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_set(target, regset, pos, count, kbuf, ubuf);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &env, 0, -1);\n\tif (ret)\n\t\treturn ret;\n\n\tfpu_force_restore(fpu);\n\n\tif (cpu_feature_enabled(X86_FEATURE_FXSR))\n\t\tconvert_to_fxsr(&fpu->fpstate->regs.fxsave, &env);\n\telse\n\t\tmemcpy(&fpu->fpstate->regs.fsave, &env, sizeof(env));\n\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_XSAVE))\n\t\tfpu->fpstate->regs.xsave.header.xfeatures |= XFEATURE_MASK_FP;\n\n\treturn 0;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}