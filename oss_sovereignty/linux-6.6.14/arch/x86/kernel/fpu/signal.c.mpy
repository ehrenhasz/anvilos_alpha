{
  "module_name": "signal.c",
  "hash_id": "e91a0aeb30f678a2b2d19bae75e62825bc24bc48e67e5c34d9d57506d1c85d74",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/fpu/signal.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/cpu.h>\n#include <linux/pagemap.h>\n\n#include <asm/fpu/signal.h>\n#include <asm/fpu/regset.h>\n#include <asm/fpu/xstate.h>\n\n#include <asm/sigframe.h>\n#include <asm/trapnr.h>\n#include <asm/trace/fpu.h>\n\n#include \"context.h\"\n#include \"internal.h\"\n#include \"legacy.h\"\n#include \"xstate.h\"\n\n \nstatic inline bool check_xstate_in_sigframe(struct fxregs_state __user *fxbuf,\n\t\t\t\t\t    struct _fpx_sw_bytes *fx_sw)\n{\n\tint min_xstate_size = sizeof(struct fxregs_state) +\n\t\t\t      sizeof(struct xstate_header);\n\tvoid __user *fpstate = fxbuf;\n\tunsigned int magic2;\n\n\tif (__copy_from_user(fx_sw, &fxbuf->sw_reserved[0], sizeof(*fx_sw)))\n\t\treturn false;\n\n\t \n\tif (fx_sw->magic1 != FP_XSTATE_MAGIC1 ||\n\t    fx_sw->xstate_size < min_xstate_size ||\n\t    fx_sw->xstate_size > current->thread.fpu.fpstate->user_size ||\n\t    fx_sw->xstate_size > fx_sw->extended_size)\n\t\tgoto setfx;\n\n\t \n\tif (__get_user(magic2, (__u32 __user *)(fpstate + fx_sw->xstate_size)))\n\t\treturn false;\n\n\tif (likely(magic2 == FP_XSTATE_MAGIC2))\n\t\treturn true;\nsetfx:\n\ttrace_x86_fpu_xstate_check_failed(&current->thread.fpu);\n\n\t \n\tfx_sw->magic1 = 0;\n\tfx_sw->xstate_size = sizeof(struct fxregs_state);\n\tfx_sw->xfeatures = XFEATURE_MASK_FPSSE;\n\treturn true;\n}\n\n \nstatic inline bool save_fsave_header(struct task_struct *tsk, void __user *buf)\n{\n\tif (use_fxsr()) {\n\t\tstruct xregs_state *xsave = &tsk->thread.fpu.fpstate->regs.xsave;\n\t\tstruct user_i387_ia32_struct env;\n\t\tstruct _fpstate_32 __user *fp = buf;\n\n\t\tfpregs_lock();\n\t\tif (!test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\t\tfxsave(&tsk->thread.fpu.fpstate->regs.fxsave);\n\t\tfpregs_unlock();\n\n\t\tconvert_from_fxsr(&env, tsk);\n\n\t\tif (__copy_to_user(buf, &env, sizeof(env)) ||\n\t\t    __put_user(xsave->i387.swd, &fp->status) ||\n\t\t    __put_user(X86_FXSR_MAGIC, &fp->magic))\n\t\t\treturn false;\n\t} else {\n\t\tstruct fregs_state __user *fp = buf;\n\t\tu32 swd;\n\n\t\tif (__get_user(swd, &fp->swd) || __put_user(swd, &fp->status))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic inline void save_sw_bytes(struct _fpx_sw_bytes *sw_bytes, bool ia32_frame,\n\t\t\t\t struct fpstate *fpstate)\n{\n\tsw_bytes->magic1 = FP_XSTATE_MAGIC1;\n\tsw_bytes->extended_size = fpstate->user_size + FP_XSTATE_MAGIC2_SIZE;\n\tsw_bytes->xfeatures = fpstate->user_xfeatures;\n\tsw_bytes->xstate_size = fpstate->user_size;\n\n\tif (ia32_frame)\n\t\tsw_bytes->extended_size += sizeof(struct fregs_state);\n}\n\nstatic inline bool save_xstate_epilog(void __user *buf, int ia32_frame,\n\t\t\t\t      struct fpstate *fpstate)\n{\n\tstruct xregs_state __user *x = buf;\n\tstruct _fpx_sw_bytes sw_bytes = {};\n\tu32 xfeatures;\n\tint err;\n\n\t \n\tsave_sw_bytes(&sw_bytes, ia32_frame, fpstate);\n\terr = __copy_to_user(&x->i387.sw_reserved, &sw_bytes, sizeof(sw_bytes));\n\n\tif (!use_xsave())\n\t\treturn !err;\n\n\terr |= __put_user(FP_XSTATE_MAGIC2,\n\t\t\t  (__u32 __user *)(buf + fpstate->user_size));\n\n\t \n\terr |= __get_user(xfeatures, (__u32 __user *)&x->header.xfeatures);\n\n\t \n\txfeatures |= XFEATURE_MASK_FPSSE;\n\n\terr |= __put_user(xfeatures, (__u32 __user *)&x->header.xfeatures);\n\n\treturn !err;\n}\n\nstatic inline int copy_fpregs_to_sigframe(struct xregs_state __user *buf)\n{\n\tif (use_xsave())\n\t\treturn xsave_to_user_sigframe(buf);\n\tif (use_fxsr())\n\t\treturn fxsave_to_user_sigframe((struct fxregs_state __user *) buf);\n\telse\n\t\treturn fnsave_to_user_sigframe((struct fregs_state __user *) buf);\n}\n\n \nbool copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)\n{\n\tstruct task_struct *tsk = current;\n\tstruct fpstate *fpstate = tsk->thread.fpu.fpstate;\n\tbool ia32_fxstate = (buf != buf_fx);\n\tint ret;\n\n\tia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t\t IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\tif (!static_cpu_has(X86_FEATURE_FPU)) {\n\t\tstruct user_i387_ia32_struct fp;\n\n\t\tfpregs_soft_get(current, NULL, (struct membuf){.p = &fp,\n\t\t\t\t\t\t.left = sizeof(fp)});\n\t\treturn !copy_to_user(buf, &fp, sizeof(fp));\n\t}\n\n\tif (!access_ok(buf, size))\n\t\treturn false;\n\n\tif (use_xsave()) {\n\t\tstruct xregs_state __user *xbuf = buf_fx;\n\n\t\t \n\t\tif (__clear_user(&xbuf->header, sizeof(xbuf->header)))\n\t\t\treturn false;\n\t}\nretry:\n\t \n\tfpregs_lock();\n\tif (test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\tfpregs_restore_userregs();\n\n\tpagefault_disable();\n\tret = copy_fpregs_to_sigframe(buf_fx);\n\tpagefault_enable();\n\tfpregs_unlock();\n\n\tif (ret) {\n\t\tif (!__clear_user(buf_fx, fpstate->user_size))\n\t\t\tgoto retry;\n\t\treturn false;\n\t}\n\n\t \n\tif ((ia32_fxstate || !use_fxsr()) && !save_fsave_header(tsk, buf))\n\t\treturn false;\n\n\tif (use_fxsr() && !save_xstate_epilog(buf_fx, ia32_fxstate, fpstate))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int __restore_fpregs_from_user(void __user *buf, u64 ufeatures,\n\t\t\t\t      u64 xrestore, bool fx_only)\n{\n\tif (use_xsave()) {\n\t\tu64 init_bv = ufeatures & ~xrestore;\n\t\tint ret;\n\n\t\tif (likely(!fx_only))\n\t\t\tret = xrstor_from_user_sigframe(buf, xrestore);\n\t\telse\n\t\t\tret = fxrstor_from_user_sigframe(buf);\n\n\t\tif (!ret && unlikely(init_bv))\n\t\t\tos_xrstor(&init_fpstate, init_bv);\n\t\treturn ret;\n\t} else if (use_fxsr()) {\n\t\treturn fxrstor_from_user_sigframe(buf);\n\t} else {\n\t\treturn frstor_from_user_sigframe(buf);\n\t}\n}\n\n \nstatic bool restore_fpregs_from_user(void __user *buf, u64 xrestore,\n\t\t\t\t     bool fx_only, unsigned int size)\n{\n\tstruct fpu *fpu = &current->thread.fpu;\n\tint ret;\n\nretry:\n\tfpregs_lock();\n\t \n\txfd_update_state(fpu->fpstate);\n\tpagefault_disable();\n\tret = __restore_fpregs_from_user(buf, fpu->fpstate->user_xfeatures,\n\t\t\t\t\t xrestore, fx_only);\n\tpagefault_enable();\n\n\tif (unlikely(ret)) {\n\t\t \n\t\tif (test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\t\t__cpu_invalidate_fpregs_state();\n\t\tfpregs_unlock();\n\n\t\t \n\t\tif (ret != X86_TRAP_PF)\n\t\t\treturn false;\n\n\t\tif (!fault_in_readable(buf, size))\n\t\t\tgoto retry;\n\t\treturn false;\n\t}\n\n\t \n\tif (test_thread_flag(TIF_NEED_FPU_LOAD) && xfeatures_mask_supervisor())\n\t\tos_xrstor_supervisor(fpu->fpstate);\n\n\tfpregs_mark_activate();\n\tfpregs_unlock();\n\treturn true;\n}\n\nstatic bool __fpu_restore_sig(void __user *buf, void __user *buf_fx,\n\t\t\t      bool ia32_fxstate)\n{\n\tstruct task_struct *tsk = current;\n\tstruct fpu *fpu = &tsk->thread.fpu;\n\tstruct user_i387_ia32_struct env;\n\tbool success, fx_only = false;\n\tunion fpregs_state *fpregs;\n\tunsigned int state_size;\n\tu64 user_xfeatures = 0;\n\n\tif (use_xsave()) {\n\t\tstruct _fpx_sw_bytes fx_sw_user;\n\n\t\tif (!check_xstate_in_sigframe(buf_fx, &fx_sw_user))\n\t\t\treturn false;\n\n\t\tfx_only = !fx_sw_user.magic1;\n\t\tstate_size = fx_sw_user.xstate_size;\n\t\tuser_xfeatures = fx_sw_user.xfeatures;\n\t} else {\n\t\tuser_xfeatures = XFEATURE_MASK_FPSSE;\n\t\tstate_size = fpu->fpstate->user_size;\n\t}\n\n\tif (likely(!ia32_fxstate)) {\n\t\t \n\t\treturn restore_fpregs_from_user(buf_fx, user_xfeatures, fx_only,\n\t\t\t\t\t\tstate_size);\n\t}\n\n\t \n\tif (__copy_from_user(&env, buf, sizeof(env)))\n\t\treturn false;\n\n\t \n\tfpregs_lock();\n\tif (!test_thread_flag(TIF_NEED_FPU_LOAD)) {\n\t\t \n\t\tif (xfeatures_mask_supervisor())\n\t\t\tos_xsave(fpu->fpstate);\n\t\tset_thread_flag(TIF_NEED_FPU_LOAD);\n\t}\n\t__fpu_invalidate_fpregs_state(fpu);\n\t__cpu_invalidate_fpregs_state();\n\tfpregs_unlock();\n\n\tfpregs = &fpu->fpstate->regs;\n\tif (use_xsave() && !fx_only) {\n\t\tif (copy_sigframe_from_user_to_xstate(tsk, buf_fx))\n\t\t\treturn false;\n\t} else {\n\t\tif (__copy_from_user(&fpregs->fxsave, buf_fx,\n\t\t\t\t     sizeof(fpregs->fxsave)))\n\t\t\treturn false;\n\n\t\tif (IS_ENABLED(CONFIG_X86_64)) {\n\t\t\t \n\t\t\tif (fpregs->fxsave.mxcsr & ~mxcsr_feature_mask)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t \n\t\t\tfpregs->fxsave.mxcsr &= mxcsr_feature_mask;\n\t\t}\n\n\t\t \n\t\tif (use_xsave())\n\t\t\tfpregs->xsave.header.xfeatures |= XFEATURE_MASK_FPSSE;\n\t}\n\n\t \n\tconvert_to_fxsr(&fpregs->fxsave, &env);\n\n\tfpregs_lock();\n\tif (use_xsave()) {\n\t\t \n\t\tu64 mask = user_xfeatures | xfeatures_mask_supervisor();\n\n\t\tfpregs->xsave.header.xfeatures &= mask;\n\t\tsuccess = !os_xrstor_safe(fpu->fpstate,\n\t\t\t\t\t  fpu_kernel_cfg.max_features);\n\t} else {\n\t\tsuccess = !fxrstor_safe(&fpregs->fxsave);\n\t}\n\n\tif (likely(success))\n\t\tfpregs_mark_activate();\n\n\tfpregs_unlock();\n\treturn success;\n}\n\nstatic inline unsigned int xstate_sigframe_size(struct fpstate *fpstate)\n{\n\tunsigned int size = fpstate->user_size;\n\n\treturn use_xsave() ? size + FP_XSTATE_MAGIC2_SIZE : size;\n}\n\n \nbool fpu__restore_sig(void __user *buf, int ia32_frame)\n{\n\tstruct fpu *fpu = &current->thread.fpu;\n\tvoid __user *buf_fx = buf;\n\tbool ia32_fxstate = false;\n\tbool success = false;\n\tunsigned int size;\n\n\tif (unlikely(!buf)) {\n\t\tfpu__clear_user_states(fpu);\n\t\treturn true;\n\t}\n\n\tsize = xstate_sigframe_size(fpu->fpstate);\n\n\tia32_frame &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t       IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\t \n\tif (ia32_frame && use_fxsr()) {\n\t\tbuf_fx = buf + sizeof(struct fregs_state);\n\t\tsize += sizeof(struct fregs_state);\n\t\tia32_fxstate = true;\n\t}\n\n\tif (!access_ok(buf, size))\n\t\tgoto out;\n\n\tif (!IS_ENABLED(CONFIG_X86_64) && !cpu_feature_enabled(X86_FEATURE_FPU)) {\n\t\tsuccess = !fpregs_soft_set(current, NULL, 0,\n\t\t\t\t\t   sizeof(struct user_i387_ia32_struct),\n\t\t\t\t\t   NULL, buf);\n\t} else {\n\t\tsuccess = __fpu_restore_sig(buf, buf_fx, ia32_fxstate);\n\t}\n\nout:\n\tif (unlikely(!success))\n\t\tfpu__clear_user_states(fpu);\n\treturn success;\n}\n\nunsigned long\nfpu__alloc_mathframe(unsigned long sp, int ia32_frame,\n\t\t     unsigned long *buf_fx, unsigned long *size)\n{\n\tunsigned long frame_size = xstate_sigframe_size(current->thread.fpu.fpstate);\n\n\t*buf_fx = sp = round_down(sp - frame_size, 64);\n\tif (ia32_frame && use_fxsr()) {\n\t\tframe_size += sizeof(struct fregs_state);\n\t\tsp -= sizeof(struct fregs_state);\n\t}\n\n\t*size = frame_size;\n\n\treturn sp;\n}\n\nunsigned long __init fpu__get_fpstate_size(void)\n{\n\tunsigned long ret = fpu_user_cfg.max_size;\n\n\tif (use_xsave())\n\t\tret += FP_XSTATE_MAGIC2_SIZE;\n\n\t \n\tif ((IS_ENABLED(CONFIG_IA32_EMULATION) ||\n\t     IS_ENABLED(CONFIG_X86_32)) && use_fxsr())\n\t\tret += sizeof(struct fregs_state);\n\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}