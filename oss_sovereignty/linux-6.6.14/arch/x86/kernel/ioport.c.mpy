{
  "module_name": "ioport.c",
  "hash_id": "baa326b7d16fbd37cbb65887624c13de671a8517fe4b26170683dbc12b43853f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/ioport.c",
  "human_readable_source": "\n \n#include <linux/capability.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/bitmap.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <asm/io_bitmap.h>\n#include <asm/desc.h>\n#include <asm/syscalls.h>\n\n#ifdef CONFIG_X86_IOPL_IOPERM\n\nstatic atomic64_t io_bitmap_sequence;\n\nvoid io_bitmap_share(struct task_struct *tsk)\n{\n\t \n\tif (current->thread.io_bitmap) {\n\t\t \n\t\trefcount_inc(&current->thread.io_bitmap->refcnt);\n\t\ttsk->thread.io_bitmap = current->thread.io_bitmap;\n\t}\n\tset_tsk_thread_flag(tsk, TIF_IO_BITMAP);\n}\n\nstatic void task_update_io_bitmap(struct task_struct *tsk)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\n\tif (t->iopl_emul == 3 || t->io_bitmap) {\n\t\t \n\t\tset_tsk_thread_flag(tsk, TIF_IO_BITMAP);\n\t} else {\n\t\tclear_tsk_thread_flag(tsk, TIF_IO_BITMAP);\n\t\t \n\t\tpreempt_disable();\n\t\ttss_update_io_bitmap();\n\t\tpreempt_enable();\n\t}\n}\n\nvoid io_bitmap_exit(struct task_struct *tsk)\n{\n\tstruct io_bitmap *iobm = tsk->thread.io_bitmap;\n\n\ttsk->thread.io_bitmap = NULL;\n\ttask_update_io_bitmap(tsk);\n\tif (iobm && refcount_dec_and_test(&iobm->refcnt))\n\t\tkfree(iobm);\n}\n\n \nlong ksys_ioperm(unsigned long from, unsigned long num, int turn_on)\n{\n\tstruct thread_struct *t = &current->thread;\n\tunsigned int i, max_long;\n\tstruct io_bitmap *iobm;\n\n\tif ((from + num <= from) || (from + num > IO_BITMAP_BITS))\n\t\treturn -EINVAL;\n\tif (turn_on && (!capable(CAP_SYS_RAWIO) ||\n\t\t\tsecurity_locked_down(LOCKDOWN_IOPORT)))\n\t\treturn -EPERM;\n\n\t \n\tiobm = t->io_bitmap;\n\tif (!iobm) {\n\t\t \n\t\tif (!turn_on)\n\t\t\treturn 0;\n\t\tiobm = kmalloc(sizeof(*iobm), GFP_KERNEL);\n\t\tif (!iobm)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(iobm->bitmap, 0xff, sizeof(iobm->bitmap));\n\t\trefcount_set(&iobm->refcnt, 1);\n\t}\n\n\t \n\tif (refcount_read(&iobm->refcnt) > 1) {\n\t\tiobm = kmemdup(iobm, sizeof(*iobm), GFP_KERNEL);\n\t\tif (!iobm)\n\t\t\treturn -ENOMEM;\n\t\trefcount_set(&iobm->refcnt, 1);\n\t\tio_bitmap_exit(current);\n\t}\n\n\t \n\tt->io_bitmap = iobm;\n\t \n\tset_thread_flag(TIF_IO_BITMAP);\n\n\t \n\tif (turn_on)\n\t\tbitmap_clear(iobm->bitmap, from, num);\n\telse\n\t\tbitmap_set(iobm->bitmap, from, num);\n\n\t \n\tmax_long = UINT_MAX;\n\tfor (i = 0; i < IO_BITMAP_LONGS; i++) {\n\t\tif (iobm->bitmap[i] != ~0UL)\n\t\t\tmax_long = i;\n\t}\n\t \n\tif (max_long == UINT_MAX) {\n\t\tio_bitmap_exit(current);\n\t\treturn 0;\n\t}\n\n\tiobm->max = (max_long + 1) * sizeof(unsigned long);\n\n\t \n\tiobm->sequence = atomic64_add_return(1, &io_bitmap_sequence);\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(ioperm, unsigned long, from, unsigned long, num, int, turn_on)\n{\n\treturn ksys_ioperm(from, num, turn_on);\n}\n\n \nSYSCALL_DEFINE1(iopl, unsigned int, level)\n{\n\tstruct thread_struct *t = &current->thread;\n\tunsigned int old;\n\n\tif (level > 3)\n\t\treturn -EINVAL;\n\n\told = t->iopl_emul;\n\n\t \n\tif (level == old)\n\t\treturn 0;\n\n\t \n\tif (level > old) {\n\t\tif (!capable(CAP_SYS_RAWIO) ||\n\t\t    security_locked_down(LOCKDOWN_IOPORT))\n\t\t\treturn -EPERM;\n\t}\n\n\tt->iopl_emul = level;\n\ttask_update_io_bitmap(current);\n\n\treturn 0;\n}\n\n#else  \n\nlong ksys_ioperm(unsigned long from, unsigned long num, int turn_on)\n{\n\treturn -ENOSYS;\n}\nSYSCALL_DEFINE3(ioperm, unsigned long, from, unsigned long, num, int, turn_on)\n{\n\treturn -ENOSYS;\n}\n\nSYSCALL_DEFINE1(iopl, unsigned int, level)\n{\n\treturn -ENOSYS;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}