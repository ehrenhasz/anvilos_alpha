{
  "module_name": "x86_init.c",
  "hash_id": "6309155ca01b2126fc5ba979af24841b843b30054d9c378d37149029880ac941",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/x86_init.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#include <asm/acpi.h>\n#include <asm/bios_ebda.h>\n#include <asm/paravirt.h>\n#include <asm/pci_x86.h>\n#include <asm/mpspec.h>\n#include <asm/setup.h>\n#include <asm/apic.h>\n#include <asm/e820/api.h>\n#include <asm/time.h>\n#include <asm/irq.h>\n#include <asm/io_apic.h>\n#include <asm/hpet.h>\n#include <asm/memtype.h>\n#include <asm/tsc.h>\n#include <asm/iommu.h>\n#include <asm/mach_traps.h>\n#include <asm/irqdomain.h>\n#include <asm/realmode.h>\n\nvoid x86_init_noop(void) { }\nvoid __init x86_init_uint_noop(unsigned int unused) { }\nstatic int __init iommu_init_noop(void) { return 0; }\nstatic void iommu_shutdown_noop(void) { }\nbool __init bool_x86_init_noop(void) { return false; }\nvoid x86_op_int_noop(int cpu) { }\nint set_rtc_noop(const struct timespec64 *now) { return -EINVAL; }\nvoid get_rtc_noop(struct timespec64 *now) { }\n\nstatic __initconst const struct of_device_id of_cmos_match[] = {\n\t{ .compatible = \"motorola,mc146818\" },\n\t{}\n};\n\n \nstatic __init void x86_wallclock_init(void)\n{\n\tstruct device_node *node = of_find_matching_node(NULL, of_cmos_match);\n\n\tif (node && !of_device_is_available(node)) {\n\t\tx86_platform.get_wallclock = get_rtc_noop;\n\t\tx86_platform.set_wallclock = set_rtc_noop;\n\t}\n}\n\n \nstruct x86_init_ops x86_init __initdata = {\n\n\t.resources = {\n\t\t.probe_roms\t\t= probe_roms,\n\t\t.reserve_resources\t= reserve_standard_io_resources,\n\t\t.memory_setup\t\t= e820__memory_setup_default,\n\t},\n\n\t.mpparse = {\n\t\t.setup_ioapic_ids\t= x86_init_noop,\n\t\t.find_smp_config\t= default_find_smp_config,\n\t\t.get_smp_config\t\t= default_get_smp_config,\n\t},\n\n\t.irqs = {\n\t\t.pre_vector_init\t= init_ISA_irqs,\n\t\t.intr_init\t\t= native_init_IRQ,\n\t\t.intr_mode_select\t= apic_intr_mode_select,\n\t\t.intr_mode_init\t\t= apic_intr_mode_init,\n\t\t.create_pci_msi_domain\t= native_create_pci_msi_domain,\n\t},\n\n\t.oem = {\n\t\t.arch_setup\t\t= x86_init_noop,\n\t\t.banner\t\t\t= default_banner,\n\t},\n\n\t.paging = {\n\t\t.pagetable_init\t\t= native_pagetable_init,\n\t},\n\n\t.timers = {\n\t\t.setup_percpu_clockev\t= setup_boot_APIC_clock,\n\t\t.timer_init\t\t= hpet_time_init,\n\t\t.wallclock_init\t\t= x86_wallclock_init,\n\t},\n\n\t.iommu = {\n\t\t.iommu_init\t\t= iommu_init_noop,\n\t},\n\n\t.pci = {\n\t\t.init\t\t\t= x86_default_pci_init,\n\t\t.init_irq\t\t= x86_default_pci_init_irq,\n\t\t.fixup_irqs\t\t= x86_default_pci_fixup_irqs,\n\t},\n\n\t.hyper = {\n\t\t.init_platform\t\t= x86_init_noop,\n\t\t.guest_late_init\t= x86_init_noop,\n\t\t.x2apic_available\t= bool_x86_init_noop,\n\t\t.msi_ext_dest_id\t= bool_x86_init_noop,\n\t\t.init_mem_mapping\t= x86_init_noop,\n\t\t.init_after_bootmem\t= x86_init_noop,\n\t},\n\n\t.acpi = {\n\t\t.set_root_pointer\t= x86_default_set_root_pointer,\n\t\t.get_root_pointer\t= x86_default_get_root_pointer,\n\t\t.reduced_hw_early_init\t= acpi_generic_reduced_hw_init,\n\t},\n};\n\nstruct x86_cpuinit_ops x86_cpuinit = {\n\t.early_percpu_clock_init\t= x86_init_noop,\n\t.setup_percpu_clockev\t\t= setup_secondary_APIC_clock,\n\t.parallel_bringup\t\t= true,\n};\n\nstatic void default_nmi_init(void) { };\n\nstatic bool enc_status_change_prepare_noop(unsigned long vaddr, int npages, bool enc) { return true; }\nstatic bool enc_status_change_finish_noop(unsigned long vaddr, int npages, bool enc) { return true; }\nstatic bool enc_tlb_flush_required_noop(bool enc) { return false; }\nstatic bool enc_cache_flush_required_noop(void) { return false; }\nstatic bool is_private_mmio_noop(u64 addr) {return false; }\n\nstruct x86_platform_ops x86_platform __ro_after_init = {\n\t.calibrate_cpu\t\t\t= native_calibrate_cpu_early,\n\t.calibrate_tsc\t\t\t= native_calibrate_tsc,\n\t.get_wallclock\t\t\t= mach_get_cmos_time,\n\t.set_wallclock\t\t\t= mach_set_cmos_time,\n\t.iommu_shutdown\t\t\t= iommu_shutdown_noop,\n\t.is_untracked_pat_range\t\t= is_ISA_range,\n\t.nmi_init\t\t\t= default_nmi_init,\n\t.get_nmi_reason\t\t\t= default_get_nmi_reason,\n\t.save_sched_clock_state\t\t= tsc_save_sched_clock_state,\n\t.restore_sched_clock_state\t= tsc_restore_sched_clock_state,\n\t.realmode_reserve\t\t= reserve_real_mode,\n\t.realmode_init\t\t\t= init_real_mode,\n\t.hyper.pin_vcpu\t\t\t= x86_op_int_noop,\n\t.hyper.is_private_mmio\t\t= is_private_mmio_noop,\n\n\t.guest = {\n\t\t.enc_status_change_prepare = enc_status_change_prepare_noop,\n\t\t.enc_status_change_finish  = enc_status_change_finish_noop,\n\t\t.enc_tlb_flush_required\t   = enc_tlb_flush_required_noop,\n\t\t.enc_cache_flush_required  = enc_cache_flush_required_noop,\n\t},\n};\n\nEXPORT_SYMBOL_GPL(x86_platform);\n\nstruct x86_apic_ops x86_apic_ops __ro_after_init = {\n\t.io_apic_read\t= native_io_apic_read,\n\t.restore\t= native_restore_boot_irq_mode,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}