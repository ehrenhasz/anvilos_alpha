{
  "module_name": "msr.c",
  "hash_id": "72baf285b4502099d1f6ccc9ac3d85c0b74b837cac9e325d924505b835073bee",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/msr.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/smp.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n\n#include <asm/cpufeature.h>\n#include <asm/msr.h>\n\nstatic enum cpuhp_state cpuhp_msr_state;\n\nenum allow_write_msrs {\n\tMSR_WRITES_ON,\n\tMSR_WRITES_OFF,\n\tMSR_WRITES_DEFAULT,\n};\n\nstatic enum allow_write_msrs allow_writes = MSR_WRITES_DEFAULT;\n\nstatic ssize_t msr_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tu32 __user *tmp = (u32 __user *) buf;\n\tu32 data[2];\n\tu32 reg = *ppos;\n\tint cpu = iminor(file_inode(file));\n\tint err = 0;\n\tssize_t bytes = 0;\n\n\tif (count % 8)\n\t\treturn -EINVAL;\t \n\n\tfor (; count; count -= 8) {\n\t\terr = rdmsr_safe_on_cpu(cpu, reg, &data[0], &data[1]);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (copy_to_user(tmp, &data, 8)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttmp += 2;\n\t\tbytes += 8;\n\t}\n\n\treturn bytes ? bytes : err;\n}\n\nstatic int filter_write(u32 reg)\n{\n\t \n\tstatic DEFINE_RATELIMIT_STATE(fw_rs, 30 * HZ, 1);\n\n\tswitch (allow_writes) {\n\tcase MSR_WRITES_ON:  return 0;\n\tcase MSR_WRITES_OFF: return -EPERM;\n\tdefault: break;\n\t}\n\n\tif (!__ratelimit(&fw_rs))\n\t\treturn 0;\n\n\tpr_warn(\"Write to unrecognized MSR 0x%x by %s (pid: %d).\\n\",\n\t        reg, current->comm, current->pid);\n\tpr_warn(\"See https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/about for details.\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t msr_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tconst u32 __user *tmp = (const u32 __user *)buf;\n\tu32 data[2];\n\tu32 reg = *ppos;\n\tint cpu = iminor(file_inode(file));\n\tint err = 0;\n\tssize_t bytes = 0;\n\n\terr = security_locked_down(LOCKDOWN_MSR);\n\tif (err)\n\t\treturn err;\n\n\terr = filter_write(reg);\n\tif (err)\n\t\treturn err;\n\n\tif (count % 8)\n\t\treturn -EINVAL;\t \n\n\tfor (; count; count -= 8) {\n\t\tif (copy_from_user(&data, tmp, 8)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n\n\t\terr = wrmsr_safe_on_cpu(cpu, reg, data[0], data[1]);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\ttmp += 2;\n\t\tbytes += 8;\n\t}\n\n\treturn bytes ? bytes : err;\n}\n\nstatic long msr_ioctl(struct file *file, unsigned int ioc, unsigned long arg)\n{\n\tu32 __user *uregs = (u32 __user *)arg;\n\tu32 regs[8];\n\tint cpu = iminor(file_inode(file));\n\tint err;\n\n\tswitch (ioc) {\n\tcase X86_IOC_RDMSR_REGS:\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\terr = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&regs, uregs, sizeof(regs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = rdmsr_safe_regs_on_cpu(cpu, regs);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (copy_to_user(uregs, &regs, sizeof(regs)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase X86_IOC_WRMSR_REGS:\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&regs, uregs, sizeof(regs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = security_locked_down(LOCKDOWN_MSR);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = filter_write(regs[1]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n\n\t\terr = wrmsr_safe_regs_on_cpu(cpu, regs);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (copy_to_user(uregs, &regs, sizeof(regs)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu = iminor(file_inode(file));\n\tstruct cpuinfo_x86 *c;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t \n\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t \n\n\treturn 0;\n}\n\n \nstatic const struct file_operations msr_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_seek_end_llseek,\n\t.read = msr_read,\n\t.write = msr_write,\n\t.open = msr_open,\n\t.unlocked_ioctl = msr_ioctl,\n\t.compat_ioctl = msr_ioctl,\n};\n\nstatic char *msr_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"cpu/%u/msr\", MINOR(dev->devt));\n}\n\nstatic const struct class msr_class = {\n\t.name\t\t= \"msr\",\n\t.devnode\t= msr_devnode,\n};\n\nstatic int msr_device_create(unsigned int cpu)\n{\n\tstruct device *dev;\n\n\tdev = device_create(&msr_class, NULL, MKDEV(MSR_MAJOR, cpu), NULL,\n\t\t\t    \"msr%d\", cpu);\n\treturn PTR_ERR_OR_ZERO(dev);\n}\n\nstatic int msr_device_destroy(unsigned int cpu)\n{\n\tdevice_destroy(&msr_class, MKDEV(MSR_MAJOR, cpu));\n\treturn 0;\n}\n\nstatic int __init msr_init(void)\n{\n\tint err;\n\n\tif (__register_chrdev(MSR_MAJOR, 0, NR_CPUS, \"cpu/msr\", &msr_fops)) {\n\t\tpr_err(\"unable to get major %d for msr\\n\", MSR_MAJOR);\n\t\treturn -EBUSY;\n\t}\n\terr = class_register(&msr_class);\n\tif (err)\n\t\tgoto out_chrdev;\n\n\terr  = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"x86/msr:online\",\n\t\t\t\t msr_device_create, msr_device_destroy);\n\tif (err < 0)\n\t\tgoto out_class;\n\tcpuhp_msr_state = err;\n\treturn 0;\n\nout_class:\n\tclass_unregister(&msr_class);\nout_chrdev:\n\t__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, \"cpu/msr\");\n\treturn err;\n}\nmodule_init(msr_init);\n\nstatic void __exit msr_exit(void)\n{\n\tcpuhp_remove_state(cpuhp_msr_state);\n\tclass_unregister(&msr_class);\n\t__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, \"cpu/msr\");\n}\nmodule_exit(msr_exit)\n\nstatic int set_allow_writes(const char *val, const struct kernel_param *cp)\n{\n\t \n\tchar *s = strstrip((char *)val);\n\n\tif (!strcmp(s, \"on\"))\n\t\tallow_writes = MSR_WRITES_ON;\n\telse if (!strcmp(s, \"off\"))\n\t\tallow_writes = MSR_WRITES_OFF;\n\telse\n\t\tallow_writes = MSR_WRITES_DEFAULT;\n\n\treturn 0;\n}\n\nstatic int get_allow_writes(char *buf, const struct kernel_param *kp)\n{\n\tconst char *res;\n\n\tswitch (allow_writes) {\n\tcase MSR_WRITES_ON:  res = \"on\"; break;\n\tcase MSR_WRITES_OFF: res = \"off\"; break;\n\tdefault: res = \"default\"; break;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", res);\n}\n\nstatic const struct kernel_param_ops allow_writes_ops = {\n\t.set = set_allow_writes,\n\t.get = get_allow_writes\n};\n\nmodule_param_cb(allow_writes, &allow_writes_ops, NULL, 0600);\n\nMODULE_AUTHOR(\"H. Peter Anvin <hpa@zytor.com>\");\nMODULE_DESCRIPTION(\"x86 generic MSR driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}