{
  "module_name": "tboot.c",
  "hash_id": "e4d55c621d334811f13a40a261e1235d89fde8b08e89c757f3bf15b233cac826",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/tboot.c",
  "human_readable_source": "\n \n\n#include <linux/init_task.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/dmar.h>\n#include <linux/cpu.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/tboot.h>\n#include <linux/debugfs.h>\n\n#include <asm/realmode.h>\n#include <asm/processor.h>\n#include <asm/bootparam.h>\n#include <asm/pgalloc.h>\n#include <asm/fixmap.h>\n#include <asm/proto.h>\n#include <asm/setup.h>\n#include <asm/e820/api.h>\n#include <asm/io.h>\n\n#include \"../realmode/rm/wakeup.h\"\n\n \nstatic struct tboot *tboot __read_mostly;\n\n \n#define AP_WAIT_TIMEOUT\t\t1\n\n#undef pr_fmt\n#define pr_fmt(fmt)\t\"tboot: \" fmt\n\nstatic u8 tboot_uuid[16] __initdata = TBOOT_UUID;\n\nbool tboot_enabled(void)\n{\n\treturn tboot != NULL;\n}\n\n \nstatic noinline __init bool check_tboot_version(void)\n{\n\tif (memcmp(&tboot_uuid, &tboot->uuid, sizeof(tboot->uuid))) {\n\t\tpr_warn(\"tboot at 0x%llx is invalid\\n\", boot_params.tboot_addr);\n\t\treturn false;\n\t}\n\n\tif (tboot->version < 5) {\n\t\tpr_warn(\"tboot version is invalid: %u\\n\", tboot->version);\n\t\treturn false;\n\t}\n\n\tpr_info(\"found shared page at phys addr 0x%llx:\\n\",\n\t\tboot_params.tboot_addr);\n\tpr_debug(\"version: %d\\n\", tboot->version);\n\tpr_debug(\"log_addr: 0x%08x\\n\", tboot->log_addr);\n\tpr_debug(\"shutdown_entry: 0x%x\\n\", tboot->shutdown_entry);\n\tpr_debug(\"tboot_base: 0x%08x\\n\", tboot->tboot_base);\n\tpr_debug(\"tboot_size: 0x%x\\n\", tboot->tboot_size);\n\n\treturn true;\n}\n\nvoid __init tboot_probe(void)\n{\n\t \n\tif (!boot_params.tboot_addr)\n\t\treturn;\n\t \n\tif (!e820__mapped_any(boot_params.tboot_addr,\n\t\t\t     boot_params.tboot_addr, E820_TYPE_RESERVED)) {\n\t\tpr_warn(\"non-0 tboot_addr but it is not of type E820_TYPE_RESERVED\\n\");\n\t\treturn;\n\t}\n\n\t \n\tset_fixmap(FIX_TBOOT_BASE, boot_params.tboot_addr);\n\ttboot = (void *)fix_to_virt(FIX_TBOOT_BASE);\n\tif (!check_tboot_version())\n\t\ttboot = NULL;\n}\n\nstatic pgd_t *tboot_pg_dir;\nstatic struct mm_struct tboot_mm = {\n\t.mm_mt          = MTREE_INIT_EXT(mm_mt, MM_MT_FLAGS, tboot_mm.mmap_lock),\n\t.pgd            = swapper_pg_dir,\n\t.mm_users       = ATOMIC_INIT(2),\n\t.mm_count       = ATOMIC_INIT(1),\n\t.write_protect_seq = SEQCNT_ZERO(tboot_mm.write_protect_seq),\n\tMMAP_LOCK_INITIALIZER(init_mm)\n\t.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),\n\t.mmlist         = LIST_HEAD_INIT(init_mm.mmlist),\n};\n\nstatic inline void switch_to_tboot_pt(void)\n{\n\twrite_cr3(virt_to_phys(tboot_pg_dir));\n}\n\nstatic int map_tboot_page(unsigned long vaddr, unsigned long pfn,\n\t\t\t  pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_offset(&tboot_mm, vaddr);\n\tp4d = p4d_alloc(&tboot_mm, pgd, vaddr);\n\tif (!p4d)\n\t\treturn -1;\n\tpud = pud_alloc(&tboot_mm, p4d, vaddr);\n\tif (!pud)\n\t\treturn -1;\n\tpmd = pmd_alloc(&tboot_mm, pud, vaddr);\n\tif (!pmd)\n\t\treturn -1;\n\tpte = pte_alloc_map(&tboot_mm, pmd, vaddr);\n\tif (!pte)\n\t\treturn -1;\n\tset_pte_at(&tboot_mm, vaddr, pte, pfn_pte(pfn, prot));\n\tpte_unmap(pte);\n\n\t \n\tpgd->pgd &= ~_PAGE_NX;\n\n\treturn 0;\n}\n\nstatic int map_tboot_pages(unsigned long vaddr, unsigned long start_pfn,\n\t\t\t   unsigned long nr)\n{\n\t \n\ttboot_pg_dir = pgd_alloc(&tboot_mm);\n\tif (!tboot_pg_dir)\n\t\treturn -1;\n\n\tfor (; nr > 0; nr--, vaddr += PAGE_SIZE, start_pfn++) {\n\t\tif (map_tboot_page(vaddr, start_pfn, PAGE_KERNEL_EXEC))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void tboot_create_trampoline(void)\n{\n\tu32 map_base, map_size;\n\n\t \n\tmap_base = PFN_DOWN(tboot->tboot_base);\n\tmap_size = PFN_UP(tboot->tboot_size);\n\tif (map_tboot_pages(map_base << PAGE_SHIFT, map_base, map_size))\n\t\tpanic(\"tboot: Error mapping tboot pages (mfns) @ 0x%x, 0x%x\\n\",\n\t\t      map_base, map_size);\n}\n\n#ifdef CONFIG_ACPI_SLEEP\n\nstatic void add_mac_region(phys_addr_t start, unsigned long size)\n{\n\tstruct tboot_mac_region *mr;\n\tphys_addr_t end = start + size;\n\n\tif (tboot->num_mac_regions >= MAX_TB_MAC_REGIONS)\n\t\tpanic(\"tboot: Too many MAC regions\\n\");\n\n\tif (start && size) {\n\t\tmr = &tboot->mac_regions[tboot->num_mac_regions++];\n\t\tmr->start = round_down(start, PAGE_SIZE);\n\t\tmr->size  = round_up(end, PAGE_SIZE) - mr->start;\n\t}\n}\n\nstatic int tboot_setup_sleep(void)\n{\n\tint i;\n\n\ttboot->num_mac_regions = 0;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tif ((e820_table->entries[i].type != E820_TYPE_RAM)\n\t\t && (e820_table->entries[i].type != E820_TYPE_RESERVED_KERN))\n\t\t\tcontinue;\n\n\t\tadd_mac_region(e820_table->entries[i].addr, e820_table->entries[i].size);\n\t}\n\n\ttboot->acpi_sinfo.kernel_s3_resume_vector =\n\t\treal_mode_header->wakeup_start;\n\n\treturn 0;\n}\n\n#else  \n\nstatic int tboot_setup_sleep(void)\n{\n\t \n\tBUG();\n\treturn -1;\n}\n\n#endif\n\nvoid tboot_shutdown(u32 shutdown_type)\n{\n\tvoid (*shutdown)(void);\n\n\tif (!tboot_enabled())\n\t\treturn;\n\n\t \n\tif (!tboot_pg_dir)\n\t\treturn;\n\n\t \n\tif (shutdown_type == TB_SHUTDOWN_S3)\n\t\tif (tboot_setup_sleep())\n\t\t\treturn;\n\n\ttboot->shutdown_type = shutdown_type;\n\n\tswitch_to_tboot_pt();\n\n\tshutdown = (void(*)(void))(unsigned long)tboot->shutdown_entry;\n\tshutdown();\n\n\t \n\twhile (1)\n\t\thalt();\n}\n\nstatic void tboot_copy_fadt(const struct acpi_table_fadt *fadt)\n{\n#define TB_COPY_GAS(tbg, g)\t\t\t\\\n\ttbg.space_id     = g.space_id;\t\t\\\n\ttbg.bit_width    = g.bit_width;\t\t\\\n\ttbg.bit_offset   = g.bit_offset;\t\\\n\ttbg.access_width = g.access_width;\t\\\n\ttbg.address      = g.address;\n\n\tTB_COPY_GAS(tboot->acpi_sinfo.pm1a_cnt_blk, fadt->xpm1a_control_block);\n\tTB_COPY_GAS(tboot->acpi_sinfo.pm1b_cnt_blk, fadt->xpm1b_control_block);\n\tTB_COPY_GAS(tboot->acpi_sinfo.pm1a_evt_blk, fadt->xpm1a_event_block);\n\tTB_COPY_GAS(tboot->acpi_sinfo.pm1b_evt_blk, fadt->xpm1b_event_block);\n\n\t \n\ttboot->acpi_sinfo.wakeup_vector = fadt->facs +\n\t\toffsetof(struct acpi_table_facs, firmware_waking_vector);\n}\n\nstatic int tboot_sleep(u8 sleep_state, u32 pm1a_control, u32 pm1b_control)\n{\n\tstatic u32 acpi_shutdown_map[ACPI_S_STATE_COUNT] = {\n\t\t  -1, -1, -1,\n\t\t  TB_SHUTDOWN_S3,\n\t\t  TB_SHUTDOWN_S4,\n\t\t  TB_SHUTDOWN_S5 };\n\n\tif (!tboot_enabled())\n\t\treturn 0;\n\n\ttboot_copy_fadt(&acpi_gbl_FADT);\n\ttboot->acpi_sinfo.pm1a_cnt_val = pm1a_control;\n\ttboot->acpi_sinfo.pm1b_cnt_val = pm1b_control;\n\t \n\ttboot->acpi_sinfo.vector_width = 32;\n\n\tif (sleep_state >= ACPI_S_STATE_COUNT ||\n\t    acpi_shutdown_map[sleep_state] == -1) {\n\t\tpr_warn(\"unsupported sleep state 0x%x\\n\", sleep_state);\n\t\treturn -1;\n\t}\n\n\ttboot_shutdown(acpi_shutdown_map[sleep_state]);\n\treturn 0;\n}\n\nstatic int tboot_extended_sleep(u8 sleep_state, u32 val_a, u32 val_b)\n{\n\tif (!tboot_enabled())\n\t\treturn 0;\n\n\tpr_warn(\"tboot is not able to suspend on platforms with reduced hardware sleep (ACPIv5)\");\n\treturn -ENODEV;\n}\n\nstatic atomic_t ap_wfs_count;\n\nstatic int tboot_wait_for_aps(int num_aps)\n{\n\tunsigned long timeout;\n\n\ttimeout = AP_WAIT_TIMEOUT*HZ;\n\twhile (atomic_read((atomic_t *)&tboot->num_in_wfs) != num_aps &&\n\t       timeout) {\n\t\tmdelay(1);\n\t\ttimeout--;\n\t}\n\n\tif (timeout)\n\t\tpr_warn(\"tboot wait for APs timeout\\n\");\n\n\treturn !(atomic_read((atomic_t *)&tboot->num_in_wfs) == num_aps);\n}\n\nstatic int tboot_dying_cpu(unsigned int cpu)\n{\n\tatomic_inc(&ap_wfs_count);\n\tif (num_online_cpus() == 1) {\n\t\tif (tboot_wait_for_aps(atomic_read(&ap_wfs_count)))\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n#define TBOOT_LOG_UUID\t{ 0x26, 0x25, 0x19, 0xc0, 0x30, 0x6b, 0xb4, 0x4d, \\\n\t\t\t  0x4c, 0x84, 0xa3, 0xe9, 0x53, 0xb8, 0x81, 0x74 }\n\n#define TBOOT_SERIAL_LOG_ADDR\t0x60000\n#define TBOOT_SERIAL_LOG_SIZE\t0x08000\n#define LOG_MAX_SIZE_OFF\t16\n#define LOG_BUF_OFF\t\t24\n\nstatic uint8_t tboot_log_uuid[16] = TBOOT_LOG_UUID;\n\nstatic ssize_t tboot_log_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tvoid __iomem *log_base;\n\tu8 log_uuid[16];\n\tu32 max_size;\n\tvoid *kbuf;\n\tint ret = -EFAULT;\n\n\tlog_base = ioremap(TBOOT_SERIAL_LOG_ADDR, TBOOT_SERIAL_LOG_SIZE);\n\tif (!log_base)\n\t\treturn ret;\n\n\tmemcpy_fromio(log_uuid, log_base, sizeof(log_uuid));\n\tif (memcmp(&tboot_log_uuid, log_uuid, sizeof(log_uuid)))\n\t\tgoto err_iounmap;\n\n\tmax_size = readl(log_base + LOG_MAX_SIZE_OFF);\n\tif (*ppos >= max_size) {\n\t\tret = 0;\n\t\tgoto err_iounmap;\n\t}\n\n\tif (*ppos + count > max_size)\n\t\tcount = max_size - *ppos;\n\n\tkbuf = kmalloc(count, GFP_KERNEL);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\tmemcpy_fromio(kbuf, log_base + LOG_BUF_OFF + *ppos, count);\n\tif (copy_to_user(user_buf, kbuf, count))\n\t\tgoto err_kfree;\n\n\t*ppos += count;\n\n\tret = count;\n\nerr_kfree:\n\tkfree(kbuf);\n\nerr_iounmap:\n\tiounmap(log_base);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tboot_log_fops = {\n\t.read\t= tboot_log_read,\n\t.llseek\t= default_llseek,\n};\n\n#endif  \n\nstatic __init int tboot_late_init(void)\n{\n\tif (!tboot_enabled())\n\t\treturn 0;\n\n\ttboot_create_trampoline();\n\n\tatomic_set(&ap_wfs_count, 0);\n\tcpuhp_setup_state(CPUHP_AP_X86_TBOOT_DYING, \"x86/tboot:dying\", NULL,\n\t\t\t  tboot_dying_cpu);\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_create_file(\"tboot_log\", S_IRUSR,\n\t\t\tarch_debugfs_dir, NULL, &tboot_log_fops);\n#endif\n\n\tacpi_os_set_prepare_sleep(&tboot_sleep);\n\tacpi_os_set_prepare_extended_sleep(&tboot_extended_sleep);\n\treturn 0;\n}\n\nlate_initcall(tboot_late_init);\n\n \n\n#define TXT_PUB_CONFIG_REGS_BASE       0xfed30000\n#define TXT_PRIV_CONFIG_REGS_BASE      0xfed20000\n\n \n#define NR_TXT_CONFIG_PAGES     ((TXT_PUB_CONFIG_REGS_BASE -                \\\n\t\t\t\t  TXT_PRIV_CONFIG_REGS_BASE) >> PAGE_SHIFT)\n\n \n#define TXTCR_HEAP_BASE             0x0300\n#define TXTCR_HEAP_SIZE             0x0308\n\n#define SHA1_SIZE      20\n\nstruct sha1_hash {\n\tu8 hash[SHA1_SIZE];\n};\n\nstruct sinit_mle_data {\n\tu32               version;              \n\tstruct sha1_hash  bios_acm_id;\n\tu32               edx_senter_flags;\n\tu64               mseg_valid;\n\tstruct sha1_hash  sinit_hash;\n\tstruct sha1_hash  mle_hash;\n\tstruct sha1_hash  stm_hash;\n\tstruct sha1_hash  lcp_policy_hash;\n\tu32               lcp_policy_control;\n\tu32               rlp_wakeup_addr;\n\tu32               reserved;\n\tu32               num_mdrs;\n\tu32               mdrs_off;\n\tu32               num_vtd_dmars;\n\tu32               vtd_dmars_off;\n} __packed;\n\nstruct acpi_table_header *tboot_get_dmar_table(struct acpi_table_header *dmar_tbl)\n{\n\tvoid *heap_base, *heap_ptr, *config;\n\n\tif (!tboot_enabled())\n\t\treturn dmar_tbl;\n\n\t \n\n\t \n\tconfig = ioremap(TXT_PUB_CONFIG_REGS_BASE, NR_TXT_CONFIG_PAGES *\n\t\t\t PAGE_SIZE);\n\tif (!config)\n\t\treturn NULL;\n\n\t \n\theap_base = ioremap(*(u64 *)(config + TXTCR_HEAP_BASE),\n\t\t\t    *(u64 *)(config + TXTCR_HEAP_SIZE));\n\tiounmap(config);\n\tif (!heap_base)\n\t\treturn NULL;\n\n\t \n\t \n\theap_ptr = heap_base + *(u64 *)heap_base;\n\t \n\theap_ptr += *(u64 *)heap_ptr;\n\t \n\theap_ptr += *(u64 *)heap_ptr;\n\t \n\theap_ptr += sizeof(u64);\n\t \n\tdmar_tbl = (struct acpi_table_header *)(heap_ptr +\n\t\t   ((struct sinit_mle_data *)heap_ptr)->vtd_dmars_off -\n\t\t   sizeof(u64));\n\n\t \n\n\treturn dmar_tbl;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}