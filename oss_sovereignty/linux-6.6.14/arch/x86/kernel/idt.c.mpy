{
  "module_name": "idt.c",
  "hash_id": "335a41c9e305c5c508002c51419b7ff5f79700c935cc7cd5a7a016d3ffa054b3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/idt.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n\n#include <asm/cpu_entry_area.h>\n#include <asm/set_memory.h>\n#include <asm/traps.h>\n#include <asm/proto.h>\n#include <asm/desc.h>\n#include <asm/hw_irq.h>\n#include <asm/idtentry.h>\n\n#define DPL0\t\t0x0\n#define DPL3\t\t0x3\n\n#define DEFAULT_STACK\t0\n\n#define G(_vector, _addr, _ist, _type, _dpl, _segment)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.vector\t\t= _vector,\t\t\\\n\t\t.bits.ist\t= _ist,\t\t\t\\\n\t\t.bits.type\t= _type,\t\t\\\n\t\t.bits.dpl\t= _dpl,\t\t\t\\\n\t\t.bits.p\t\t= 1,\t\t\t\\\n\t\t.addr\t\t= _addr,\t\t\\\n\t\t.segment\t= _segment,\t\t\\\n\t}\n\n \n#define INTG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n\n \n#define SYSG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL3, __KERNEL_CS)\n\n#ifdef CONFIG_X86_64\n \n#define ISTG(_vector, _addr, _ist)\t\t\t\\\n\tG(_vector, _addr, _ist + 1, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n#else\n#define ISTG(_vector, _addr, _ist)\tINTG(_vector, _addr)\n#endif\n\n \n#define TSKG(_vector, _gdt)\t\t\t\t\\\n\tG(_vector, NULL, DEFAULT_STACK, GATE_TASK, DPL0, _gdt << 3)\n\n#define IDT_TABLE_SIZE\t\t(IDT_ENTRIES * sizeof(gate_desc))\n\nstatic bool idt_setup_done __initdata;\n\n \nstatic const __initconst struct idt_data early_idts[] = {\n\tINTG(X86_TRAP_DB,\t\tasm_exc_debug),\n\tSYSG(X86_TRAP_BP,\t\tasm_exc_int3),\n\n#ifdef CONFIG_X86_32\n\t \n\tINTG(X86_TRAP_PF,\t\tasm_exc_page_fault),\n#endif\n#ifdef CONFIG_INTEL_TDX_GUEST\n\tINTG(X86_TRAP_VE,\t\tasm_exc_virtualization_exception),\n#endif\n};\n\n \nstatic const __initconst struct idt_data def_idts[] = {\n\tINTG(X86_TRAP_DE,\t\tasm_exc_divide_error),\n\tISTG(X86_TRAP_NMI,\t\tasm_exc_nmi, IST_INDEX_NMI),\n\tINTG(X86_TRAP_BR,\t\tasm_exc_bounds),\n\tINTG(X86_TRAP_UD,\t\tasm_exc_invalid_op),\n\tINTG(X86_TRAP_NM,\t\tasm_exc_device_not_available),\n\tINTG(X86_TRAP_OLD_MF,\t\tasm_exc_coproc_segment_overrun),\n\tINTG(X86_TRAP_TS,\t\tasm_exc_invalid_tss),\n\tINTG(X86_TRAP_NP,\t\tasm_exc_segment_not_present),\n\tINTG(X86_TRAP_SS,\t\tasm_exc_stack_segment),\n\tINTG(X86_TRAP_GP,\t\tasm_exc_general_protection),\n\tINTG(X86_TRAP_SPURIOUS,\t\tasm_exc_spurious_interrupt_bug),\n\tINTG(X86_TRAP_MF,\t\tasm_exc_coprocessor_error),\n\tINTG(X86_TRAP_AC,\t\tasm_exc_alignment_check),\n\tINTG(X86_TRAP_XF,\t\tasm_exc_simd_coprocessor_error),\n\n#ifdef CONFIG_X86_32\n\tTSKG(X86_TRAP_DF,\t\tGDT_ENTRY_DOUBLEFAULT_TSS),\n#else\n\tISTG(X86_TRAP_DF,\t\tasm_exc_double_fault, IST_INDEX_DF),\n#endif\n\tISTG(X86_TRAP_DB,\t\tasm_exc_debug, IST_INDEX_DB),\n\n#ifdef CONFIG_X86_MCE\n\tISTG(X86_TRAP_MC,\t\tasm_exc_machine_check, IST_INDEX_MCE),\n#endif\n\n#ifdef CONFIG_X86_CET\n\tINTG(X86_TRAP_CP,\t\tasm_exc_control_protection),\n#endif\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n\tISTG(X86_TRAP_VC,\t\tasm_exc_vmm_communication, IST_INDEX_VC),\n#endif\n\n\tSYSG(X86_TRAP_OF,\t\tasm_exc_overflow),\n#if defined(CONFIG_IA32_EMULATION)\n\tSYSG(IA32_SYSCALL_VECTOR,\tasm_int80_emulation),\n#elif defined(CONFIG_X86_32)\n\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_32),\n#endif\n};\n\n \nstatic const __initconst struct idt_data apic_idts[] = {\n#ifdef CONFIG_SMP\n\tINTG(RESCHEDULE_VECTOR,\t\t\tasm_sysvec_reschedule_ipi),\n\tINTG(CALL_FUNCTION_VECTOR,\t\tasm_sysvec_call_function),\n\tINTG(CALL_FUNCTION_SINGLE_VECTOR,\tasm_sysvec_call_function_single),\n\tINTG(REBOOT_VECTOR,\t\t\tasm_sysvec_reboot),\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tINTG(THERMAL_APIC_VECTOR,\t\tasm_sysvec_thermal),\n#endif\n\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tINTG(THRESHOLD_APIC_VECTOR,\t\tasm_sysvec_threshold),\n#endif\n\n#ifdef CONFIG_X86_MCE_AMD\n\tINTG(DEFERRED_ERROR_VECTOR,\t\tasm_sysvec_deferred_error),\n#endif\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tINTG(LOCAL_TIMER_VECTOR,\t\tasm_sysvec_apic_timer_interrupt),\n\tINTG(X86_PLATFORM_IPI_VECTOR,\t\tasm_sysvec_x86_platform_ipi),\n# ifdef CONFIG_HAVE_KVM\n\tINTG(POSTED_INTR_VECTOR,\t\tasm_sysvec_kvm_posted_intr_ipi),\n\tINTG(POSTED_INTR_WAKEUP_VECTOR,\t\tasm_sysvec_kvm_posted_intr_wakeup_ipi),\n\tINTG(POSTED_INTR_NESTED_VECTOR,\t\tasm_sysvec_kvm_posted_intr_nested_ipi),\n# endif\n# ifdef CONFIG_IRQ_WORK\n\tINTG(IRQ_WORK_VECTOR,\t\t\tasm_sysvec_irq_work),\n# endif\n\tINTG(SPURIOUS_APIC_VECTOR,\t\tasm_sysvec_spurious_apic_interrupt),\n\tINTG(ERROR_APIC_VECTOR,\t\t\tasm_sysvec_error_interrupt),\n#endif\n};\n\n \nstatic gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;\n\nstatic struct desc_ptr idt_descr __ro_after_init = {\n\t.size\t\t= IDT_TABLE_SIZE - 1,\n\t.address\t= (unsigned long) idt_table,\n};\n\nvoid load_current_idt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tload_idt(&idt_descr);\n}\n\n#ifdef CONFIG_X86_F00F_BUG\nbool idt_is_f00f_address(unsigned long address)\n{\n\treturn ((address - idt_descr.address) >> 3) == 6;\n}\n#endif\n\nstatic __init void\nidt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)\n{\n\tgate_desc desc;\n\n\tfor (; size > 0; t++, size--) {\n\t\tidt_init_desc(&desc, t);\n\t\twrite_idt_entry(idt, t->vector, &desc);\n\t\tif (sys)\n\t\t\tset_bit(t->vector, system_vectors);\n\t}\n}\n\nstatic __init void set_intr_gate(unsigned int n, const void *addr)\n{\n\tstruct idt_data data;\n\n\tinit_idt_data(&data, n, addr);\n\n\tidt_setup_from_table(idt_table, &data, 1, false);\n}\n\n \nvoid __init idt_setup_early_traps(void)\n{\n\tidt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),\n\t\t\t     true);\n\tload_idt(&idt_descr);\n}\n\n \nvoid __init idt_setup_traps(void)\n{\n\tidt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);\n}\n\n#ifdef CONFIG_X86_64\n \nstatic const __initconst struct idt_data early_pf_idts[] = {\n\tINTG(X86_TRAP_PF,\t\tasm_exc_page_fault),\n};\n\n \nvoid __init idt_setup_early_pf(void)\n{\n\tidt_setup_from_table(idt_table, early_pf_idts,\n\t\t\t     ARRAY_SIZE(early_pf_idts), true);\n}\n#endif\n\nstatic void __init idt_map_in_cea(void)\n{\n\t \n\tcea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),\n\t\t    PAGE_KERNEL_RO);\n\tidt_descr.address = CPU_ENTRY_AREA_RO_IDT;\n}\n\n \nvoid __init idt_setup_apic_and_irq_gates(void)\n{\n\tint i = FIRST_EXTERNAL_VECTOR;\n\tvoid *entry;\n\n\tidt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), true);\n\n\tfor_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {\n\t\tentry = irq_entries_start + IDT_ALIGN * (i - FIRST_EXTERNAL_VECTOR);\n\t\tset_intr_gate(i, entry);\n\t}\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tfor_each_clear_bit_from(i, system_vectors, NR_VECTORS) {\n\t\t \n\t\tentry = spurious_entries_start + IDT_ALIGN * (i - FIRST_SYSTEM_VECTOR);\n\t\tset_intr_gate(i, entry);\n\t}\n#endif\n\t \n\tidt_map_in_cea();\n\tload_idt(&idt_descr);\n\n\t \n\tset_memory_ro((unsigned long)&idt_table, 1);\n\n\tidt_setup_done = true;\n}\n\n \nvoid __init idt_setup_early_handler(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_EXCEPTION_VECTORS; i++)\n\t\tset_intr_gate(i, early_idt_handler_array[i]);\n#ifdef CONFIG_X86_32\n\tfor ( ; i < NR_VECTORS; i++)\n\t\tset_intr_gate(i, early_ignore_irq);\n#endif\n\tload_idt(&idt_descr);\n}\n\n \nvoid idt_invalidate(void)\n{\n\tstatic const struct desc_ptr idt = { .address = 0, .size = 0 };\n\n\tload_idt(&idt);\n}\n\nvoid __init alloc_intr_gate(unsigned int n, const void *addr)\n{\n\tif (WARN_ON(n < FIRST_SYSTEM_VECTOR))\n\t\treturn;\n\n\tif (WARN_ON(idt_setup_done))\n\t\treturn;\n\n\tif (!WARN_ON(test_and_set_bit(n, system_vectors)))\n\t\tset_intr_gate(n, addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}