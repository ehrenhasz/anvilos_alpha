{
  "module_name": "hw_breakpoint.c",
  "hash_id": "f2e01a265b654e055618cadbf1b21465e1b0550d57379807465f9556a2db6560",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/hw_breakpoint.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/percpu.h>\n#include <linux/kdebug.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n\n#include <asm/hw_breakpoint.h>\n#include <asm/processor.h>\n#include <asm/debugreg.h>\n#include <asm/user.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n\n \nDEFINE_PER_CPU(unsigned long, cpu_dr7);\nEXPORT_PER_CPU_SYMBOL(cpu_dr7);\n\n \nstatic DEFINE_PER_CPU(unsigned long, cpu_debugreg[HBP_NUM]);\n\n \nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM]);\n\n\nstatic inline unsigned long\n__encode_dr7(int drnum, unsigned int len, unsigned int type)\n{\n\tunsigned long bp_info;\n\n\tbp_info = (len | type) & 0xf;\n\tbp_info <<= (DR_CONTROL_SHIFT + drnum * DR_CONTROL_SIZE);\n\tbp_info |= (DR_GLOBAL_ENABLE << (drnum * DR_ENABLE_SIZE));\n\n\treturn bp_info;\n}\n\n \nunsigned long encode_dr7(int drnum, unsigned int len, unsigned int type)\n{\n\treturn __encode_dr7(drnum, len, type) | DR_GLOBAL_SLOWDOWN;\n}\n\n \nint decode_dr7(unsigned long dr7, int bpnum, unsigned *len, unsigned *type)\n{\n\tint bp_info = dr7 >> (DR_CONTROL_SHIFT + bpnum * DR_CONTROL_SIZE);\n\n\t*len = (bp_info & 0xc) | 0x40;\n\t*type = (bp_info & 0x3) | 0x80;\n\n\treturn (dr7 >> (bpnum * DR_ENABLE_SIZE)) & 0x3;\n}\n\n \nint arch_install_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tunsigned long *dr7;\n\tint i;\n\n\tlockdep_assert_irqs_disabled();\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg[i]);\n\n\t\tif (!*slot) {\n\t\t\t*slot = bp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == HBP_NUM, \"Can't find any breakpoint slot\"))\n\t\treturn -EBUSY;\n\n\tset_debugreg(info->address, i);\n\t__this_cpu_write(cpu_debugreg[i], info->address);\n\n\tdr7 = this_cpu_ptr(&cpu_dr7);\n\t*dr7 |= encode_dr7(i, info->len, info->type);\n\n\t \n\tbarrier();\n\n\tset_debugreg(*dr7, 7);\n\tif (info->mask)\n\t\tamd_set_dr_addr_mask(info->mask, i);\n\n\treturn 0;\n}\n\n \nvoid arch_uninstall_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tunsigned long dr7;\n\tint i;\n\n\tlockdep_assert_irqs_disabled();\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg[i]);\n\n\t\tif (*slot == bp) {\n\t\t\t*slot = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == HBP_NUM, \"Can't find any breakpoint slot\"))\n\t\treturn;\n\n\tdr7 = this_cpu_read(cpu_dr7);\n\tdr7 &= ~__encode_dr7(i, info->len, info->type);\n\n\tset_debugreg(dr7, 7);\n\tif (info->mask)\n\t\tamd_set_dr_addr_mask(0, i);\n\n\t \n\tbarrier();\n\n\tthis_cpu_write(cpu_dr7, dr7);\n}\n\nstatic int arch_bp_generic_len(int x86_len)\n{\n\tswitch (x86_len) {\n\tcase X86_BREAKPOINT_LEN_1:\n\t\treturn HW_BREAKPOINT_LEN_1;\n\tcase X86_BREAKPOINT_LEN_2:\n\t\treturn HW_BREAKPOINT_LEN_2;\n\tcase X86_BREAKPOINT_LEN_4:\n\t\treturn HW_BREAKPOINT_LEN_4;\n#ifdef CONFIG_X86_64\n\tcase X86_BREAKPOINT_LEN_8:\n\t\treturn HW_BREAKPOINT_LEN_8;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint arch_bp_generic_fields(int x86_len, int x86_type,\n\t\t\t   int *gen_len, int *gen_type)\n{\n\tint len;\n\n\t \n\tswitch (x86_type) {\n\tcase X86_BREAKPOINT_EXECUTE:\n\t\tif (x86_len != X86_BREAKPOINT_LEN_X)\n\t\t\treturn -EINVAL;\n\n\t\t*gen_type = HW_BREAKPOINT_X;\n\t\t*gen_len = sizeof(long);\n\t\treturn 0;\n\tcase X86_BREAKPOINT_WRITE:\n\t\t*gen_type = HW_BREAKPOINT_W;\n\t\tbreak;\n\tcase X86_BREAKPOINT_RW:\n\t\t*gen_type = HW_BREAKPOINT_W | HW_BREAKPOINT_R;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlen = arch_bp_generic_len(x86_len);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\t*gen_len = len;\n\n\treturn 0;\n}\n\n \nint arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw)\n{\n\tunsigned long va;\n\tint len;\n\n\tva = hw->address;\n\tlen = arch_bp_generic_len(hw->len);\n\tWARN_ON_ONCE(len < 0);\n\n\t \n\treturn (va >= TASK_SIZE_MAX) || ((va + len - 1) >= TASK_SIZE_MAX);\n}\n\n \nstatic inline bool within_area(unsigned long addr, unsigned long end,\n\t\t\t       unsigned long base, unsigned long size)\n{\n\treturn end >= base && addr < (base + size);\n}\n\n \nstatic inline bool within_cpu_entry(unsigned long addr, unsigned long end)\n{\n\tint cpu;\n\n\t \n\tif (within_area(addr, end, CPU_ENTRY_AREA_BASE,\n\t\t\tCPU_ENTRY_AREA_MAP_SIZE))\n\t\treturn true;\n\n\t \n#ifdef CONFIG_SMP\n\tif (within_area(addr, end, (unsigned long)__per_cpu_offset,\n\t\t\tsizeof(unsigned long) * nr_cpu_ids))\n\t\treturn true;\n#else\n\tif (within_area(addr, end, (unsigned long)&pcpu_unit_offsets,\n\t\t\tsizeof(pcpu_unit_offsets)))\n\t\treturn true;\n#endif\n\n\tfor_each_possible_cpu(cpu) {\n\t\t \n\t\tif (within_area(addr, end, (unsigned long)get_cpu_gdt_rw(cpu),\n\t\t\t\tGDT_SIZE))\n\t\t\treturn true;\n\n\t\t \n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tss_rw, cpu),\n\t\t\t\tsizeof(struct tss_struct)))\n\t\t\treturn true;\n\n\t\t \n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tlbstate, cpu),\n\t\t\t\tsizeof(struct tlb_state)))\n\t\t\treturn true;\n\n\t\t \n\t\tif (within_area(addr, end, (unsigned long)&per_cpu(cpu_dr7, cpu),\n\t\t\t\tsizeof(cpu_dr7)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int arch_build_bp_info(struct perf_event *bp,\n\t\t\t      const struct perf_event_attr *attr,\n\t\t\t      struct arch_hw_breakpoint *hw)\n{\n\tunsigned long bp_end;\n\n\tbp_end = attr->bp_addr + attr->bp_len - 1;\n\tif (bp_end < attr->bp_addr)\n\t\treturn -EINVAL;\n\n\t \n\tif (within_cpu_entry(attr->bp_addr, bp_end))\n\t\treturn -EINVAL;\n\n\thw->address = attr->bp_addr;\n\thw->mask = 0;\n\n\t \n\tswitch (attr->bp_type) {\n\tcase HW_BREAKPOINT_W:\n\t\thw->type = X86_BREAKPOINT_WRITE;\n\t\tbreak;\n\tcase HW_BREAKPOINT_W | HW_BREAKPOINT_R:\n\t\thw->type = X86_BREAKPOINT_RW;\n\t\tbreak;\n\tcase HW_BREAKPOINT_X:\n\t\t \n\t\tif (attr->bp_addr >= TASK_SIZE_MAX) {\n\t\t\tif (within_kprobe_blacklist(attr->bp_addr))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thw->type = X86_BREAKPOINT_EXECUTE;\n\t\t \n\t\tif (attr->bp_len == sizeof(long)) {\n\t\t\thw->len = X86_BREAKPOINT_LEN_X;\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (attr->bp_len) {\n\tcase HW_BREAKPOINT_LEN_1:\n\t\thw->len = X86_BREAKPOINT_LEN_1;\n\t\tbreak;\n\tcase HW_BREAKPOINT_LEN_2:\n\t\thw->len = X86_BREAKPOINT_LEN_2;\n\t\tbreak;\n\tcase HW_BREAKPOINT_LEN_4:\n\t\thw->len = X86_BREAKPOINT_LEN_4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase HW_BREAKPOINT_LEN_8:\n\t\thw->len = X86_BREAKPOINT_LEN_8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\tif (!is_power_of_2(attr->bp_len))\n\t\t\treturn -EINVAL;\n\t\tif (attr->bp_addr & (attr->bp_len - 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (!boot_cpu_has(X86_FEATURE_BPEXT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\thw->mask = attr->bp_len - 1;\n\t\thw->len = X86_BREAKPOINT_LEN_1;\n\t}\n\n\treturn 0;\n}\n\n \nint hw_breakpoint_arch_parse(struct perf_event *bp,\n\t\t\t     const struct perf_event_attr *attr,\n\t\t\t     struct arch_hw_breakpoint *hw)\n{\n\tunsigned int align;\n\tint ret;\n\n\n\tret = arch_build_bp_info(bp, attr, hw);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (hw->len) {\n\tcase X86_BREAKPOINT_LEN_1:\n\t\talign = 0;\n\t\tif (hw->mask)\n\t\t\talign = hw->mask;\n\t\tbreak;\n\tcase X86_BREAKPOINT_LEN_2:\n\t\talign = 1;\n\t\tbreak;\n\tcase X86_BREAKPOINT_LEN_4:\n\t\talign = 3;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86_BREAKPOINT_LEN_8:\n\t\talign = 7;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (hw->address & align)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tint i;\n\tstruct thread_struct *t = &tsk->thread;\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tunregister_hw_breakpoint(t->ptrace_bps[i]);\n\t\tt->ptrace_bps[i] = NULL;\n\t}\n\n\tt->virtual_dr6 = 0;\n\tt->ptrace_dr7 = 0;\n}\n\nvoid hw_breakpoint_restore(void)\n{\n\tset_debugreg(__this_cpu_read(cpu_debugreg[0]), 0);\n\tset_debugreg(__this_cpu_read(cpu_debugreg[1]), 1);\n\tset_debugreg(__this_cpu_read(cpu_debugreg[2]), 2);\n\tset_debugreg(__this_cpu_read(cpu_debugreg[3]), 3);\n\tset_debugreg(DR6_RESERVED, 6);\n\tset_debugreg(__this_cpu_read(cpu_dr7), 7);\n}\nEXPORT_SYMBOL_GPL(hw_breakpoint_restore);\n\n \nstatic int hw_breakpoint_handler(struct die_args *args)\n{\n\tint i, rc = NOTIFY_STOP;\n\tstruct perf_event *bp;\n\tunsigned long *dr6_p;\n\tunsigned long dr6;\n\tbool bpx;\n\n\t \n\tdr6_p = (unsigned long *)ERR_PTR(args->err);\n\tdr6 = *dr6_p;\n\n\t \n\tif ((dr6 & DR_TRAP_BITS) == 0)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tfor (i = 0; i < HBP_NUM; ++i) {\n\t\tif (likely(!(dr6 & (DR_TRAP0 << i))))\n\t\t\tcontinue;\n\n\t\tbp = this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tbpx = bp->hw.info.type == X86_BREAKPOINT_EXECUTE;\n\n\t\t \n\t\tif (bpx && (dr6 & DR_STEP))\n\t\t\tcontinue;\n\n\t\t \n\t\t(*dr6_p) &= ~(DR_TRAP0 << i);\n\n\t\tperf_bp_event(bp, args->regs);\n\n\t\t \n\t\tif (bpx)\n\t\t\targs->regs->flags |= X86_EFLAGS_RF;\n\t}\n\n\t \n\tif ((current->thread.virtual_dr6 & DR_TRAP_BITS) ||\n\t    (dr6 & (~DR_TRAP_BITS)))\n\t\trc = NOTIFY_DONE;\n\n\treturn rc;\n}\n\n \nint hw_breakpoint_exceptions_notify(\n\t\tstruct notifier_block *unused, unsigned long val, void *data)\n{\n\tif (val != DIE_DEBUG)\n\t\treturn NOTIFY_DONE;\n\n\treturn hw_breakpoint_handler(data);\n}\n\nvoid hw_breakpoint_pmu_read(struct perf_event *bp)\n{\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}