{
  "module_name": "ftrace.c",
  "hash_id": "0035f87a0904d7dba2da08ebfbabc89e1942e34ea94999e04af03eb4ab2e2f30",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/ftrace.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/ftrace.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/memory.h>\n#include <linux/vmalloc.h>\n#include <linux/set_memory.h>\n\n#include <trace/syscall.h>\n\n#include <asm/kprobes.h>\n#include <asm/ftrace.h>\n#include <asm/nops.h>\n#include <asm/text-patching.h>\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\nstatic int ftrace_poke_late = 0;\n\nvoid ftrace_arch_code_modify_prepare(void)\n    __acquires(&text_mutex)\n{\n\t \n\tmutex_lock(&text_mutex);\n\tftrace_poke_late = 1;\n}\n\nvoid ftrace_arch_code_modify_post_process(void)\n    __releases(&text_mutex)\n{\n\t \n\ttext_poke_finish();\n\tftrace_poke_late = 0;\n\tmutex_unlock(&text_mutex);\n}\n\nstatic const char *ftrace_nop_replace(void)\n{\n\treturn x86_nops[5];\n}\n\nstatic const char *ftrace_call_replace(unsigned long ip, unsigned long addr)\n{\n\t \n\treturn text_gen_insn(CALL_INSN_OPCODE, (void *)ip, (void *)addr);\n}\n\nstatic int ftrace_verify_code(unsigned long ip, const char *old_code)\n{\n\tchar cur_code[MCOUNT_INSN_SIZE];\n\n\t \n\t \n\tif (copy_from_kernel_nofault(cur_code, (void *)ip, MCOUNT_INSN_SIZE)) {\n\t\tWARN_ON(1);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (memcmp(cur_code, old_code, MCOUNT_INSN_SIZE) != 0) {\n\t\tftrace_expected = old_code;\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __ref\nftrace_modify_code_direct(unsigned long ip, const char *old_code,\n\t\t\t  const char *new_code)\n{\n\tint ret = ftrace_verify_code(ip, old_code);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ftrace_poke_late)\n\t\ttext_poke_queue((void *)ip, new_code, MCOUNT_INSN_SIZE, NULL);\n\telse\n\t\ttext_poke_early((void *)ip, new_code, MCOUNT_INSN_SIZE);\n\treturn 0;\n}\n\nint ftrace_make_nop(struct module *mod, struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tconst char *new, *old;\n\n\told = ftrace_call_replace(ip, addr);\n\tnew = ftrace_nop_replace();\n\n\t \n\tif (addr == MCOUNT_ADDR)\n\t\treturn ftrace_modify_code_direct(ip, old, new);\n\n\t \n\tWARN_ONCE(1, \"invalid use of ftrace_make_nop\");\n\treturn -EINVAL;\n}\n\nint ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tconst char *new, *old;\n\n\told = ftrace_nop_replace();\n\tnew = ftrace_call_replace(ip, addr);\n\n\t \n\treturn ftrace_modify_code_direct(rec->ip, old, new);\n}\n\n \nint ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\t\t unsigned long addr)\n{\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nint ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip;\n\tconst char *new;\n\n\tip = (unsigned long)(&ftrace_call);\n\tnew = ftrace_call_replace(ip, (unsigned long)func);\n\ttext_poke_bp((void *)ip, new, MCOUNT_INSN_SIZE, NULL);\n\n\tip = (unsigned long)(&ftrace_regs_call);\n\tnew = ftrace_call_replace(ip, (unsigned long)func);\n\ttext_poke_bp((void *)ip, new, MCOUNT_INSN_SIZE, NULL);\n\n\treturn 0;\n}\n\nvoid ftrace_replace_code(int enable)\n{\n\tstruct ftrace_rec_iter *iter;\n\tstruct dyn_ftrace *rec;\n\tconst char *new, *old;\n\tint ret;\n\n\tfor_ftrace_rec_iter(iter) {\n\t\trec = ftrace_rec_iter_record(iter);\n\n\t\tswitch (ftrace_test_record(rec, enable)) {\n\t\tcase FTRACE_UPDATE_IGNORE:\n\t\tdefault:\n\t\t\tcontinue;\n\n\t\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\t\told = ftrace_nop_replace();\n\t\t\tbreak;\n\n\t\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\t\told = ftrace_call_replace(rec->ip, ftrace_get_addr_curr(rec));\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ftrace_verify_code(rec->ip, old);\n\t\tif (ret) {\n\t\t\tftrace_expected = old;\n\t\t\tftrace_bug(ret, rec);\n\t\t\tftrace_expected = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor_ftrace_rec_iter(iter) {\n\t\trec = ftrace_rec_iter_record(iter);\n\n\t\tswitch (ftrace_test_record(rec, enable)) {\n\t\tcase FTRACE_UPDATE_IGNORE:\n\t\tdefault:\n\t\t\tcontinue;\n\n\t\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\t\tnew = ftrace_call_replace(rec->ip, ftrace_get_addr_new(rec));\n\t\t\tbreak;\n\n\t\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\t\tnew = ftrace_nop_replace();\n\t\t\tbreak;\n\t\t}\n\n\t\ttext_poke_queue((void *)rec->ip, new, MCOUNT_INSN_SIZE, NULL);\n\t\tftrace_update_record(rec, enable);\n\t}\n\ttext_poke_finish();\n}\n\nvoid arch_ftrace_update_code(int command)\n{\n\tftrace_modify_all_code(command);\n}\n\n \n#ifdef CONFIG_X86_64\n\n#ifdef CONFIG_MODULES\n#include <linux/moduleloader.h>\n \nstatic inline void *alloc_tramp(unsigned long size)\n{\n\treturn module_alloc(size);\n}\nstatic inline void tramp_free(void *tramp)\n{\n\tmodule_memfree(tramp);\n}\n#else\n \nstatic inline void *alloc_tramp(unsigned long size)\n{\n\treturn NULL;\n}\nstatic inline void tramp_free(void *tramp) { }\n#endif\n\n \nextern void ftrace_regs_caller_end(void);\nextern void ftrace_caller_end(void);\nextern void ftrace_caller_op_ptr(void);\nextern void ftrace_regs_caller_op_ptr(void);\nextern void ftrace_regs_caller_jmp(void);\n\n \n \n#define OP_REF_SIZE\t7\n\n \nunion ftrace_op_code_union {\n\tchar code[OP_REF_SIZE];\n\tstruct {\n\t\tchar op[3];\n\t\tint offset;\n\t} __attribute__((packed));\n};\n\n#define RET_SIZE\t\t(IS_ENABLED(CONFIG_RETPOLINE) ? 5 : 1 + IS_ENABLED(CONFIG_SLS))\n\nstatic unsigned long\ncreate_trampoline(struct ftrace_ops *ops, unsigned int *tramp_size)\n{\n\tunsigned long start_offset;\n\tunsigned long end_offset;\n\tunsigned long op_offset;\n\tunsigned long call_offset;\n\tunsigned long jmp_offset;\n\tunsigned long offset;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long *ptr;\n\tvoid *trampoline;\n\tvoid *ip, *dest;\n\t \n\tunsigned const char op_ref[] = { 0x48, 0x8b, 0x15 };\n\tunsigned const char retq[] = { RET_INSN_OPCODE, INT3_INSN_OPCODE };\n\tunion ftrace_op_code_union op_ptr;\n\tint ret;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\tstart_offset = (unsigned long)ftrace_regs_caller;\n\t\tend_offset = (unsigned long)ftrace_regs_caller_end;\n\t\top_offset = (unsigned long)ftrace_regs_caller_op_ptr;\n\t\tcall_offset = (unsigned long)ftrace_regs_call;\n\t\tjmp_offset = (unsigned long)ftrace_regs_caller_jmp;\n\t} else {\n\t\tstart_offset = (unsigned long)ftrace_caller;\n\t\tend_offset = (unsigned long)ftrace_caller_end;\n\t\top_offset = (unsigned long)ftrace_caller_op_ptr;\n\t\tcall_offset = (unsigned long)ftrace_call;\n\t\tjmp_offset = 0;\n\t}\n\n\tsize = end_offset - start_offset;\n\n\t \n\ttrampoline = alloc_tramp(size + RET_SIZE + sizeof(void *));\n\tif (!trampoline)\n\t\treturn 0;\n\n\t*tramp_size = size + RET_SIZE + sizeof(void *);\n\tnpages = DIV_ROUND_UP(*tramp_size, PAGE_SIZE);\n\n\t \n\tret = copy_from_kernel_nofault(trampoline, (void *)start_offset, size);\n\tif (WARN_ON(ret < 0))\n\t\tgoto fail;\n\n\tip = trampoline + size;\n\tif (cpu_feature_enabled(X86_FEATURE_RETHUNK))\n\t\t__text_gen_insn(ip, JMP32_INSN_OPCODE, ip, x86_return_thunk, JMP32_INSN_SIZE);\n\telse\n\t\tmemcpy(ip, retq, sizeof(retq));\n\n\t \n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t \n\t\tip = trampoline + (jmp_offset - start_offset);\n\t\tif (WARN_ON(*(char *)ip != 0x75))\n\t\t\tgoto fail;\n\t\tret = copy_from_kernel_nofault(ip, x86_nops[2], 2);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\n\tptr = (unsigned long *)(trampoline + size + RET_SIZE);\n\t*ptr = (unsigned long)ops;\n\n\top_offset -= start_offset;\n\tmemcpy(&op_ptr, trampoline + op_offset, OP_REF_SIZE);\n\n\t \n\tif (WARN_ON(memcmp(op_ptr.op, op_ref, 3) != 0))\n\t\tgoto fail;\n\n\t \n\toffset = (unsigned long)ptr;\n\toffset -= (unsigned long)trampoline + op_offset + OP_REF_SIZE;\n\n\top_ptr.offset = offset;\n\n\t \n\tmemcpy(trampoline + op_offset, &op_ptr, OP_REF_SIZE);\n\n\t \n\tmutex_lock(&text_mutex);\n\tcall_offset -= start_offset;\n\t \n\tdest = ftrace_ops_get_func(ops);\n\tmemcpy(trampoline + call_offset,\n\t       text_gen_insn(CALL_INSN_OPCODE, trampoline + call_offset, dest),\n\t       CALL_INSN_SIZE);\n\tmutex_unlock(&text_mutex);\n\n\t \n\tops->flags |= FTRACE_OPS_FL_ALLOC_TRAMP;\n\n\tset_memory_rox((unsigned long)trampoline, npages);\n\treturn (unsigned long)trampoline;\nfail:\n\ttramp_free(trampoline);\n\treturn 0;\n}\n\nvoid set_ftrace_ops_ro(void)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long start_offset;\n\tunsigned long end_offset;\n\tunsigned long npages;\n\tunsigned long size;\n\n\tdo_for_each_ftrace_op(ops, ftrace_ops_list) {\n\t\tif (!(ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP))\n\t\t\tcontinue;\n\n\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\tstart_offset = (unsigned long)ftrace_regs_caller;\n\t\t\tend_offset = (unsigned long)ftrace_regs_caller_end;\n\t\t} else {\n\t\t\tstart_offset = (unsigned long)ftrace_caller;\n\t\t\tend_offset = (unsigned long)ftrace_caller_end;\n\t\t}\n\t\tsize = end_offset - start_offset;\n\t\tsize = size + RET_SIZE + sizeof(void *);\n\t\tnpages = DIV_ROUND_UP(size, PAGE_SIZE);\n\t\tset_memory_ro((unsigned long)ops->trampoline, npages);\n\t} while_for_each_ftrace_op(ops);\n}\n\nstatic unsigned long calc_trampoline_call_offset(bool save_regs)\n{\n\tunsigned long start_offset;\n\tunsigned long call_offset;\n\n\tif (save_regs) {\n\t\tstart_offset = (unsigned long)ftrace_regs_caller;\n\t\tcall_offset = (unsigned long)ftrace_regs_call;\n\t} else {\n\t\tstart_offset = (unsigned long)ftrace_caller;\n\t\tcall_offset = (unsigned long)ftrace_call;\n\t}\n\n\treturn call_offset - start_offset;\n}\n\nvoid arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n\tftrace_func_t func;\n\tunsigned long offset;\n\tunsigned long ip;\n\tunsigned int size;\n\tconst char *new;\n\n\tif (!ops->trampoline) {\n\t\tops->trampoline = create_trampoline(ops, &size);\n\t\tif (!ops->trampoline)\n\t\t\treturn;\n\t\tops->trampoline_size = size;\n\t\treturn;\n\t}\n\n\t \n\tif (!(ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP))\n\t\treturn;\n\n\toffset = calc_trampoline_call_offset(ops->flags & FTRACE_OPS_FL_SAVE_REGS);\n\tip = ops->trampoline + offset;\n\tfunc = ftrace_ops_get_func(ops);\n\n\tmutex_lock(&text_mutex);\n\t \n\tnew = ftrace_call_replace(ip, (unsigned long)func);\n\ttext_poke_bp((void *)ip, new, MCOUNT_INSN_SIZE, NULL);\n\tmutex_unlock(&text_mutex);\n}\n\n \nstatic void *addr_from_call(void *ptr)\n{\n\tunion text_poke_insn call;\n\tint ret;\n\n\tret = copy_from_kernel_nofault(&call, ptr, CALL_INSN_SIZE);\n\tif (WARN_ON_ONCE(ret < 0))\n\t\treturn NULL;\n\n\t \n\tif (WARN_ON_ONCE(call.opcode != CALL_INSN_OPCODE)) {\n\t\tpr_warn(\"Expected E8, got %x\\n\", call.opcode);\n\t\treturn NULL;\n\t}\n\n\treturn ptr + CALL_INSN_SIZE + call.disp;\n}\n\n \nstatic void *static_tramp_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\tunsigned long offset;\n\tbool save_regs = rec->flags & FTRACE_FL_REGS_EN;\n\tvoid *ptr;\n\n\tif (ops && ops->trampoline) {\n#if !defined(CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS) && \\\n\tdefined(CONFIG_FUNCTION_GRAPH_TRACER)\n\t\t \n\t\tif (ops->trampoline == FTRACE_GRAPH_ADDR)\n\t\t\treturn (void *)prepare_ftrace_return;\n#endif\n\t\treturn NULL;\n\t}\n\n\toffset = calc_trampoline_call_offset(save_regs);\n\n\tif (save_regs)\n\t\tptr = (void *)FTRACE_REGS_ADDR + offset;\n\telse\n\t\tptr = (void *)FTRACE_ADDR + offset;\n\n\treturn addr_from_call(ptr);\n}\n\nvoid *arch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\tunsigned long offset;\n\n\t \n\tif (!ops || !(ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP))\n\t\treturn static_tramp_func(ops, rec);\n\n\toffset = calc_trampoline_call_offset(ops->flags & FTRACE_OPS_FL_SAVE_REGS);\n\treturn addr_from_call((void *)ops->trampoline + offset);\n}\n\nvoid arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (!ops || !(ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP))\n\t\treturn;\n\n\ttramp_free((void *)ops->trampoline);\n\tops->trampoline = 0;\n}\n\n#endif  \n#endif  \n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\n#if defined(CONFIG_DYNAMIC_FTRACE) && !defined(CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS)\nextern void ftrace_graph_call(void);\nstatic const char *ftrace_jmp_replace(unsigned long ip, unsigned long addr)\n{\n\treturn text_gen_insn(JMP32_INSN_OPCODE, (void *)ip, (void *)addr);\n}\n\nstatic int ftrace_mod_jmp(unsigned long ip, void *func)\n{\n\tconst char *new;\n\n\tnew = ftrace_jmp_replace(ip, (unsigned long)func);\n\ttext_poke_bp((void *)ip, new, MCOUNT_INSN_SIZE, NULL);\n\treturn 0;\n}\n\nint ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\n\treturn ftrace_mod_jmp(ip, &ftrace_graph_caller);\n}\n\nint ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\n\treturn ftrace_mod_jmp(ip, &ftrace_stub);\n}\n#endif  \n\n \nvoid prepare_ftrace_return(unsigned long ip, unsigned long *parent,\n\t\t\t   unsigned long frame_pointer)\n{\n\tunsigned long return_hooker = (unsigned long)&return_to_handler;\n\tint bit;\n\n\t \n\tif (unlikely((long)__builtin_frame_address(0) >= 0))\n\t\treturn;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\treturn;\n\n\tif (unlikely(atomic_read(&current->tracing_graph_pause)))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, *parent);\n\tif (bit < 0)\n\t\treturn;\n\n\tif (!function_graph_enter(*parent, ip, frame_pointer, parent))\n\t\t*parent = return_hooker;\n\n\tftrace_test_recursion_unlock(bit);\n}\n\n#ifdef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\nvoid ftrace_graph_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = &fregs->regs;\n\tunsigned long *stack = (unsigned long *)kernel_stack_pointer(regs);\n\n\tprepare_ftrace_return(ip, (unsigned long *)stack, 0);\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}