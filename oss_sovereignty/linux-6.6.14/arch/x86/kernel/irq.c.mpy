{
  "module_name": "irq.c",
  "hash_id": "d061c97f0f70d84218ebdf5a29f7da4c805feb844ec670c553a025f665e98faf",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/irq.c",
  "human_readable_source": "\n \n#include <linux/cpu.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/of.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/irq.h>\n\n#include <asm/irq_stack.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/irq.h>\n#include <asm/mce.h>\n#include <asm/hw_irq.h>\n#include <asm/desc.h>\n#include <asm/traps.h>\n#include <asm/thermal.h>\n\n#define CREATE_TRACE_POINTS\n#include <asm/trace/irq_vectors.h>\n\nDEFINE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);\nEXPORT_PER_CPU_SYMBOL(irq_stat);\n\natomic_t irq_err_count;\n\n \nvoid ack_bad_irq(unsigned int irq)\n{\n\tif (printk_ratelimit())\n\t\tpr_err(\"unexpected IRQ trap at vector %02x\\n\", irq);\n\n\t \n\tapic_eoi();\n}\n\n#define irq_stats(x)\t\t(&per_cpu(irq_stat, x))\n \nint arch_show_interrupts(struct seq_file *p, int prec)\n{\n\tint j;\n\n\tseq_printf(p, \"%*s: \", prec, \"NMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->__nmi_count);\n\tseq_puts(p, \"  Non-maskable interrupts\\n\");\n#ifdef CONFIG_X86_LOCAL_APIC\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->apic_timer_irqs);\n\tseq_puts(p, \"  Local timer interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"SPU\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_spurious_count);\n\tseq_puts(p, \"  Spurious interrupts\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"PMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->apic_perf_irqs);\n\tseq_puts(p, \"  Performance monitoring interrupts\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"IWI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->apic_irq_work_irqs);\n\tseq_puts(p, \"  IRQ work interrupts\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"RTR\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->icr_read_retry_count);\n\tseq_puts(p, \"  APIC ICR read retries\\n\");\n\tif (x86_platform_ipi_callback) {\n\t\tseq_printf(p, \"%*s: \", prec, \"PLT\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", irq_stats(j)->x86_platform_ipis);\n\t\tseq_puts(p, \"  Platform interrupts\\n\");\n\t}\n#endif\n#ifdef CONFIG_SMP\n\tseq_printf(p, \"%*s: \", prec, \"RES\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_resched_count);\n\tseq_puts(p, \"  Rescheduling interrupts\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"CAL\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_call_count);\n\tseq_puts(p, \"  Function call interrupts\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"TLB\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_tlb_count);\n\tseq_puts(p, \"  TLB shootdowns\\n\");\n#endif\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tseq_printf(p, \"%*s: \", prec, \"TRM\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_thermal_count);\n\tseq_puts(p, \"  Thermal event interrupts\\n\");\n#endif\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tseq_printf(p, \"%*s: \", prec, \"THR\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_threshold_count);\n\tseq_puts(p, \"  Threshold APIC interrupts\\n\");\n#endif\n#ifdef CONFIG_X86_MCE_AMD\n\tseq_printf(p, \"%*s: \", prec, \"DFR\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->irq_deferred_error_count);\n\tseq_puts(p, \"  Deferred Error APIC interrupts\\n\");\n#endif\n#ifdef CONFIG_X86_MCE\n\tseq_printf(p, \"%*s: \", prec, \"MCE\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(mce_exception_count, j));\n\tseq_puts(p, \"  Machine check exceptions\\n\");\n\tseq_printf(p, \"%*s: \", prec, \"MCP\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(mce_poll_count, j));\n\tseq_puts(p, \"  Machine check polls\\n\");\n#endif\n#ifdef CONFIG_X86_HV_CALLBACK_VECTOR\n\tif (test_bit(HYPERVISOR_CALLBACK_VECTOR, system_vectors)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HYP\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \",\n\t\t\t\t   irq_stats(j)->irq_hv_callback_count);\n\t\tseq_puts(p, \"  Hypervisor callback interrupts\\n\");\n\t}\n#endif\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (test_bit(HYPERV_REENLIGHTENMENT_VECTOR, system_vectors)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HRE\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \",\n\t\t\t\t   irq_stats(j)->irq_hv_reenlightenment_count);\n\t\tseq_puts(p, \"  Hyper-V reenlightenment interrupts\\n\");\n\t}\n\tif (test_bit(HYPERV_STIMER0_VECTOR, system_vectors)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HVS\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \",\n\t\t\t\t   irq_stats(j)->hyperv_stimer0_count);\n\t\tseq_puts(p, \"  Hyper-V stimer0 interrupts\\n\");\n\t}\n#endif\n\tseq_printf(p, \"%*s: %10u\\n\", prec, \"ERR\", atomic_read(&irq_err_count));\n#if defined(CONFIG_X86_IO_APIC)\n\tseq_printf(p, \"%*s: %10u\\n\", prec, \"MIS\", atomic_read(&irq_mis_count));\n#endif\n#ifdef CONFIG_HAVE_KVM\n\tseq_printf(p, \"%*s: \", prec, \"PIN\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", irq_stats(j)->kvm_posted_intr_ipis);\n\tseq_puts(p, \"  Posted-interrupt notification event\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"NPI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \",\n\t\t\t   irq_stats(j)->kvm_posted_intr_nested_ipis);\n\tseq_puts(p, \"  Nested posted-interrupt event\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"PIW\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \",\n\t\t\t   irq_stats(j)->kvm_posted_intr_wakeup_ipis);\n\tseq_puts(p, \"  Posted-interrupt wakeup event\\n\");\n#endif\n\treturn 0;\n}\n\n \nu64 arch_irq_stat_cpu(unsigned int cpu)\n{\n\tu64 sum = irq_stats(cpu)->__nmi_count;\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tsum += irq_stats(cpu)->apic_timer_irqs;\n\tsum += irq_stats(cpu)->irq_spurious_count;\n\tsum += irq_stats(cpu)->apic_perf_irqs;\n\tsum += irq_stats(cpu)->apic_irq_work_irqs;\n\tsum += irq_stats(cpu)->icr_read_retry_count;\n\tif (x86_platform_ipi_callback)\n\t\tsum += irq_stats(cpu)->x86_platform_ipis;\n#endif\n#ifdef CONFIG_SMP\n\tsum += irq_stats(cpu)->irq_resched_count;\n\tsum += irq_stats(cpu)->irq_call_count;\n#endif\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tsum += irq_stats(cpu)->irq_thermal_count;\n#endif\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tsum += irq_stats(cpu)->irq_threshold_count;\n#endif\n#ifdef CONFIG_X86_HV_CALLBACK_VECTOR\n\tsum += irq_stats(cpu)->irq_hv_callback_count;\n#endif\n#if IS_ENABLED(CONFIG_HYPERV)\n\tsum += irq_stats(cpu)->irq_hv_reenlightenment_count;\n\tsum += irq_stats(cpu)->hyperv_stimer0_count;\n#endif\n#ifdef CONFIG_X86_MCE\n\tsum += per_cpu(mce_exception_count, cpu);\n\tsum += per_cpu(mce_poll_count, cpu);\n#endif\n\treturn sum;\n}\n\nu64 arch_irq_stat(void)\n{\n\tu64 sum = atomic_read(&irq_err_count);\n\treturn sum;\n}\n\nstatic __always_inline void handle_irq(struct irq_desc *desc,\n\t\t\t\t       struct pt_regs *regs)\n{\n\tif (IS_ENABLED(CONFIG_X86_64))\n\t\tgeneric_handle_irq_desc(desc);\n\telse\n\t\t__handle_irq(desc, regs);\n}\n\n \nDEFINE_IDTENTRY_IRQ(common_interrupt)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tstruct irq_desc *desc;\n\n\t \n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"IRQ failed to wake up RCU\");\n\n\tdesc = __this_cpu_read(vector_irq[vector]);\n\tif (likely(!IS_ERR_OR_NULL(desc))) {\n\t\thandle_irq(desc, regs);\n\t} else {\n\t\tapic_eoi();\n\n\t\tif (desc == VECTOR_UNUSED) {\n\t\t\tpr_emerg_ratelimited(\"%s: %d.%u No irq handler for vector\\n\",\n\t\t\t\t\t     __func__, smp_processor_id(),\n\t\t\t\t\t     vector);\n\t\t} else {\n\t\t\t__this_cpu_write(vector_irq[vector], VECTOR_UNUSED);\n\t\t}\n\t}\n\n\tset_irq_regs(old_regs);\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\n \nvoid (*x86_platform_ipi_callback)(void) = NULL;\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_x86_platform_ipi)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tapic_eoi();\n\ttrace_x86_platform_ipi_entry(X86_PLATFORM_IPI_VECTOR);\n\tinc_irq_stat(x86_platform_ipis);\n\tif (x86_platform_ipi_callback)\n\t\tx86_platform_ipi_callback();\n\ttrace_x86_platform_ipi_exit(X86_PLATFORM_IPI_VECTOR);\n\tset_irq_regs(old_regs);\n}\n#endif\n\n#ifdef CONFIG_HAVE_KVM\nstatic void dummy_handler(void) {}\nstatic void (*kvm_posted_intr_wakeup_handler)(void) = dummy_handler;\n\nvoid kvm_set_posted_intr_wakeup_handler(void (*handler)(void))\n{\n\tif (handler)\n\t\tkvm_posted_intr_wakeup_handler = handler;\n\telse {\n\t\tkvm_posted_intr_wakeup_handler = dummy_handler;\n\t\tsynchronize_rcu();\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_set_posted_intr_wakeup_handler);\n\n \nDEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_kvm_posted_intr_ipi)\n{\n\tapic_eoi();\n\tinc_irq_stat(kvm_posted_intr_ipis);\n}\n\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_kvm_posted_intr_wakeup_ipi)\n{\n\tapic_eoi();\n\tinc_irq_stat(kvm_posted_intr_wakeup_ipis);\n\tkvm_posted_intr_wakeup_handler();\n}\n\n \nDEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_kvm_posted_intr_nested_ipi)\n{\n\tapic_eoi();\n\tinc_irq_stat(kvm_posted_intr_nested_ipis);\n}\n#endif\n\n\n#ifdef CONFIG_HOTPLUG_CPU\n \nvoid fixup_irqs(void)\n{\n\tunsigned int irr, vector;\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\n\tirq_migrate_all_off_this_cpu();\n\n\t \n\tmdelay(1);\n\n\t \n\tfor (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS; vector++) {\n\t\tif (IS_ERR_OR_NULL(__this_cpu_read(vector_irq[vector])))\n\t\t\tcontinue;\n\n\t\tirr = apic_read(APIC_IRR + (vector / 32 * 0x10));\n\t\tif (irr  & (1 << (vector % 32))) {\n\t\t\tdesc = __this_cpu_read(vector_irq[vector]);\n\n\t\t\traw_spin_lock(&desc->lock);\n\t\t\tdata = irq_desc_get_irq_data(desc);\n\t\t\tchip = irq_data_get_irq_chip(data);\n\t\t\tif (chip->irq_retrigger) {\n\t\t\t\tchip->irq_retrigger(data);\n\t\t\t\t__this_cpu_write(vector_irq[vector], VECTOR_RETRIGGERED);\n\t\t\t}\n\t\t\traw_spin_unlock(&desc->lock);\n\t\t}\n\t\tif (__this_cpu_read(vector_irq[vector]) != VECTOR_RETRIGGERED)\n\t\t\t__this_cpu_write(vector_irq[vector], VECTOR_UNUSED);\n\t}\n}\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\nstatic void smp_thermal_vector(void)\n{\n\tif (x86_thermal_enabled())\n\t\tintel_thermal_interrupt();\n\telse\n\t\tpr_err(\"CPU%d: Unexpected LVT thermal interrupt!\\n\",\n\t\t       smp_processor_id());\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_thermal)\n{\n\ttrace_thermal_apic_entry(THERMAL_APIC_VECTOR);\n\tinc_irq_stat(irq_thermal_count);\n\tsmp_thermal_vector();\n\ttrace_thermal_apic_exit(THERMAL_APIC_VECTOR);\n\tapic_eoi();\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}