{
  "module_name": "kvmclock.c",
  "hash_id": "18285cdeda9d2628b98eb22c8a9c3e5c5e33a91c885b021c0e946d95710f0008",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/kvmclock.c",
  "human_readable_source": "\n \n\n#include <linux/clocksource.h>\n#include <linux/kvm_para.h>\n#include <asm/pvclock.h>\n#include <asm/msr.h>\n#include <asm/apic.h>\n#include <linux/percpu.h>\n#include <linux/hardirq.h>\n#include <linux/cpuhotplug.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n\n#include <asm/hypervisor.h>\n#include <asm/x86_init.h>\n#include <asm/kvmclock.h>\n\nstatic int kvmclock __initdata = 1;\nstatic int kvmclock_vsyscall __initdata = 1;\nstatic int msr_kvm_system_time __ro_after_init;\nstatic int msr_kvm_wall_clock __ro_after_init;\nstatic u64 kvm_sched_clock_offset __ro_after_init;\n\nstatic int __init parse_no_kvmclock(char *arg)\n{\n\tkvmclock = 0;\n\treturn 0;\n}\nearly_param(\"no-kvmclock\", parse_no_kvmclock);\n\nstatic int __init parse_no_kvmclock_vsyscall(char *arg)\n{\n\tkvmclock_vsyscall = 0;\n\treturn 0;\n}\nearly_param(\"no-kvmclock-vsyscall\", parse_no_kvmclock_vsyscall);\n\n \n#define HVC_BOOT_ARRAY_SIZE \\\n\t(PAGE_SIZE / sizeof(struct pvclock_vsyscall_time_info))\n\nstatic struct pvclock_vsyscall_time_info\n\t\t\thv_clock_boot[HVC_BOOT_ARRAY_SIZE] __bss_decrypted __aligned(PAGE_SIZE);\nstatic struct pvclock_wall_clock wall_clock __bss_decrypted;\nstatic struct pvclock_vsyscall_time_info *hvclock_mem;\nDEFINE_PER_CPU(struct pvclock_vsyscall_time_info *, hv_clock_per_cpu);\nEXPORT_PER_CPU_SYMBOL_GPL(hv_clock_per_cpu);\n\n \nstatic void kvm_get_wallclock(struct timespec64 *now)\n{\n\twrmsrl(msr_kvm_wall_clock, slow_virt_to_phys(&wall_clock));\n\tpreempt_disable();\n\tpvclock_read_wallclock(&wall_clock, this_cpu_pvti(), now);\n\tpreempt_enable();\n}\n\nstatic int kvm_set_wallclock(const struct timespec64 *now)\n{\n\treturn -ENODEV;\n}\n\nstatic u64 kvm_clock_read(void)\n{\n\tu64 ret;\n\n\tpreempt_disable_notrace();\n\tret = pvclock_clocksource_read_nowd(this_cpu_pvti());\n\tpreempt_enable_notrace();\n\treturn ret;\n}\n\nstatic u64 kvm_clock_get_cycles(struct clocksource *cs)\n{\n\treturn kvm_clock_read();\n}\n\nstatic noinstr u64 kvm_sched_clock_read(void)\n{\n\treturn pvclock_clocksource_read_nowd(this_cpu_pvti()) - kvm_sched_clock_offset;\n}\n\nstatic inline void kvm_sched_clock_init(bool stable)\n{\n\tif (!stable)\n\t\tclear_sched_clock_stable();\n\tkvm_sched_clock_offset = kvm_clock_read();\n\tparavirt_set_sched_clock(kvm_sched_clock_read);\n\n\tpr_info(\"kvm-clock: using sched offset of %llu cycles\",\n\t\tkvm_sched_clock_offset);\n\n\tBUILD_BUG_ON(sizeof(kvm_sched_clock_offset) >\n\t\tsizeof(((struct pvclock_vcpu_time_info *)NULL)->system_time));\n}\n\n \nstatic unsigned long kvm_get_tsc_khz(void)\n{\n\tsetup_force_cpu_cap(X86_FEATURE_TSC_KNOWN_FREQ);\n\treturn pvclock_tsc_khz(this_cpu_pvti());\n}\n\nstatic void __init kvm_get_preset_lpj(void)\n{\n\tunsigned long khz;\n\tu64 lpj;\n\n\tkhz = kvm_get_tsc_khz();\n\n\tlpj = ((u64)khz * 1000);\n\tdo_div(lpj, HZ);\n\tpreset_lpj = lpj;\n}\n\nbool kvm_check_and_clear_guest_paused(void)\n{\n\tstruct pvclock_vsyscall_time_info *src = this_cpu_hvclock();\n\tbool ret = false;\n\n\tif (!src)\n\t\treturn ret;\n\n\tif ((src->pvti.flags & PVCLOCK_GUEST_STOPPED) != 0) {\n\t\tsrc->pvti.flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nstatic int kvm_cs_enable(struct clocksource *cs)\n{\n\tvclocks_set_used(VDSO_CLOCKMODE_PVCLOCK);\n\treturn 0;\n}\n\nstruct clocksource kvm_clock = {\n\t.name\t= \"kvm-clock\",\n\t.read\t= kvm_clock_get_cycles,\n\t.rating\t= 400,\n\t.mask\t= CLOCKSOURCE_MASK(64),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.enable\t= kvm_cs_enable,\n};\nEXPORT_SYMBOL_GPL(kvm_clock);\n\nstatic void kvm_register_clock(char *txt)\n{\n\tstruct pvclock_vsyscall_time_info *src = this_cpu_hvclock();\n\tu64 pa;\n\n\tif (!src)\n\t\treturn;\n\n\tpa = slow_virt_to_phys(&src->pvti) | 0x01ULL;\n\twrmsrl(msr_kvm_system_time, pa);\n\tpr_debug(\"kvm-clock: cpu %d, msr %llx, %s\", smp_processor_id(), pa, txt);\n}\n\nstatic void kvm_save_sched_clock_state(void)\n{\n}\n\nstatic void kvm_restore_sched_clock_state(void)\n{\n\tkvm_register_clock(\"primary cpu clock, resume\");\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\nstatic void kvm_setup_secondary_clock(void)\n{\n\tkvm_register_clock(\"secondary cpu clock\");\n}\n#endif\n\nvoid kvmclock_disable(void)\n{\n\tif (msr_kvm_system_time)\n\t\tnative_write_msr(msr_kvm_system_time, 0, 0);\n}\n\nstatic void __init kvmclock_init_mem(void)\n{\n\tunsigned long ncpus;\n\tunsigned int order;\n\tstruct page *p;\n\tint r;\n\n\tif (HVC_BOOT_ARRAY_SIZE >= num_possible_cpus())\n\t\treturn;\n\n\tncpus = num_possible_cpus() - HVC_BOOT_ARRAY_SIZE;\n\torder = get_order(ncpus * sizeof(*hvclock_mem));\n\n\tp = alloc_pages(GFP_KERNEL, order);\n\tif (!p) {\n\t\tpr_warn(\"%s: failed to alloc %d pages\", __func__, (1U << order));\n\t\treturn;\n\t}\n\n\thvclock_mem = page_address(p);\n\n\t \n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tr = set_memory_decrypted((unsigned long) hvclock_mem,\n\t\t\t\t\t 1UL << order);\n\t\tif (r) {\n\t\t\t__free_pages(p, order);\n\t\t\thvclock_mem = NULL;\n\t\t\tpr_warn(\"kvmclock: set_memory_decrypted() failed. Disabling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmemset(hvclock_mem, 0, PAGE_SIZE << order);\n}\n\nstatic int __init kvm_setup_vsyscall_timeinfo(void)\n{\n\tif (!kvm_para_available() || !kvmclock || nopv)\n\t\treturn 0;\n\n\tkvmclock_init_mem();\n\n#ifdef CONFIG_X86_64\n\tif (per_cpu(hv_clock_per_cpu, 0) && kvmclock_vsyscall) {\n\t\tu8 flags;\n\n\t\tflags = pvclock_read_flags(&hv_clock_boot[0].pvti);\n\t\tif (!(flags & PVCLOCK_TSC_STABLE_BIT))\n\t\t\treturn 0;\n\n\t\tkvm_clock.vdso_clock_mode = VDSO_CLOCKMODE_PVCLOCK;\n\t}\n#endif\n\n\treturn 0;\n}\nearly_initcall(kvm_setup_vsyscall_timeinfo);\n\nstatic int kvmclock_setup_percpu(unsigned int cpu)\n{\n\tstruct pvclock_vsyscall_time_info *p = per_cpu(hv_clock_per_cpu, cpu);\n\n\t \n\tif (!cpu || (p && p != per_cpu(hv_clock_per_cpu, 0)))\n\t\treturn 0;\n\n\t \n\tif (cpu < HVC_BOOT_ARRAY_SIZE)\n\t\tp = &hv_clock_boot[cpu];\n\telse if (hvclock_mem)\n\t\tp = hvclock_mem + cpu - HVC_BOOT_ARRAY_SIZE;\n\telse\n\t\treturn -ENOMEM;\n\n\tper_cpu(hv_clock_per_cpu, cpu) = p;\n\treturn p ? 0 : -ENOMEM;\n}\n\nvoid __init kvmclock_init(void)\n{\n\tu8 flags;\n\n\tif (!kvm_para_available() || !kvmclock)\n\t\treturn;\n\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\n\t} else if (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"kvmclock:setup_percpu\",\n\t\t\t      kvmclock_setup_percpu, NULL) < 0) {\n\t\treturn;\n\t}\n\n\tpr_info(\"kvm-clock: Using msrs %x and %x\",\n\t\tmsr_kvm_system_time, msr_kvm_wall_clock);\n\n\tthis_cpu_write(hv_clock_per_cpu, &hv_clock_boot[0]);\n\tkvm_register_clock(\"primary cpu clock\");\n\tpvclock_set_pvti_cpu0_va(hv_clock_boot);\n\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n\n\tflags = pvclock_read_flags(&hv_clock_boot[0].pvti);\n\tkvm_sched_clock_init(flags & PVCLOCK_TSC_STABLE_BIT);\n\n\tx86_platform.calibrate_tsc = kvm_get_tsc_khz;\n\tx86_platform.calibrate_cpu = kvm_get_tsc_khz;\n\tx86_platform.get_wallclock = kvm_get_wallclock;\n\tx86_platform.set_wallclock = kvm_set_wallclock;\n#ifdef CONFIG_X86_LOCAL_APIC\n\tx86_cpuinit.early_percpu_clock_init = kvm_setup_secondary_clock;\n#endif\n\tx86_platform.save_sched_clock_state = kvm_save_sched_clock_state;\n\tx86_platform.restore_sched_clock_state = kvm_restore_sched_clock_state;\n\tkvm_get_preset_lpj();\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_CONSTANT_TSC) &&\n\t    boot_cpu_has(X86_FEATURE_NONSTOP_TSC) &&\n\t    !check_tsc_unstable())\n\t\tkvm_clock.rating = 299;\n\n\tclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\n\tpv_info.name = \"KVM\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}