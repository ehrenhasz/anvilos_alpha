{
  "module_name": "hpet.c",
  "hash_id": "93bdbb1b276d361ea2be223557b06d531fe68767e2f5f3bbeca16255e46bd9c6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/hpet.c",
  "human_readable_source": "\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/hpet.h>\n#include <linux/cpu.h>\n#include <linux/irq.h>\n\n#include <asm/irq_remapping.h>\n#include <asm/hpet.h>\n#include <asm/time.h>\n#include <asm/mwait.h>\n\n#undef  pr_fmt\n#define pr_fmt(fmt) \"hpet: \" fmt\n\nenum hpet_mode {\n\tHPET_MODE_UNUSED,\n\tHPET_MODE_LEGACY,\n\tHPET_MODE_CLOCKEVT,\n\tHPET_MODE_DEVICE,\n};\n\nstruct hpet_channel {\n\tstruct clock_event_device\tevt;\n\tunsigned int\t\t\tnum;\n\tunsigned int\t\t\tcpu;\n\tunsigned int\t\t\tirq;\n\tunsigned int\t\t\tin_use;\n\tenum hpet_mode\t\t\tmode;\n\tunsigned int\t\t\tboot_cfg;\n\tchar\t\t\t\tname[10];\n};\n\nstruct hpet_base {\n\tunsigned int\t\t\tnr_channels;\n\tunsigned int\t\t\tnr_clockevents;\n\tunsigned int\t\t\tboot_cfg;\n\tstruct hpet_channel\t\t*channels;\n};\n\n#define HPET_MASK\t\t\tCLOCKSOURCE_MASK(32)\n\n#define HPET_MIN_CYCLES\t\t\t128\n#define HPET_MIN_PROG_DELTA\t\t(HPET_MIN_CYCLES + (HPET_MIN_CYCLES >> 1))\n\n \nunsigned long\t\t\t\thpet_address;\nu8\t\t\t\t\thpet_blockid;  \nbool\t\t\t\t\thpet_msi_disable;\n\n#ifdef CONFIG_GENERIC_MSI_IRQ\nstatic DEFINE_PER_CPU(struct hpet_channel *, cpu_hpet_channel);\nstatic struct irq_domain\t\t*hpet_domain;\n#endif\n\nstatic void __iomem\t\t\t*hpet_virt_address;\n\nstatic struct hpet_base\t\t\thpet_base;\n\nstatic bool\t\t\t\thpet_legacy_int_enabled;\nstatic unsigned long\t\t\thpet_freq;\n\nbool\t\t\t\t\tboot_hpet_disable;\nbool\t\t\t\t\thpet_force_user;\nstatic bool\t\t\t\thpet_verbose;\n\nstatic inline\nstruct hpet_channel *clockevent_to_channel(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct hpet_channel, evt);\n}\n\ninline unsigned int hpet_readl(unsigned int a)\n{\n\treturn readl(hpet_virt_address + a);\n}\n\nstatic inline void hpet_writel(unsigned int d, unsigned int a)\n{\n\twritel(d, hpet_virt_address + a);\n}\n\nstatic inline void hpet_set_mapping(void)\n{\n\thpet_virt_address = ioremap(hpet_address, HPET_MMAP_SIZE);\n}\n\nstatic inline void hpet_clear_mapping(void)\n{\n\tiounmap(hpet_virt_address);\n\thpet_virt_address = NULL;\n}\n\n \nstatic int __init hpet_setup(char *str)\n{\n\twhile (str) {\n\t\tchar *next = strchr(str, ',');\n\n\t\tif (next)\n\t\t\t*next++ = 0;\n\t\tif (!strncmp(\"disable\", str, 7))\n\t\t\tboot_hpet_disable = true;\n\t\tif (!strncmp(\"force\", str, 5))\n\t\t\thpet_force_user = true;\n\t\tif (!strncmp(\"verbose\", str, 7))\n\t\t\thpet_verbose = true;\n\t\tstr = next;\n\t}\n\treturn 1;\n}\n__setup(\"hpet=\", hpet_setup);\n\nstatic int __init disable_hpet(char *str)\n{\n\tboot_hpet_disable = true;\n\treturn 1;\n}\n__setup(\"nohpet\", disable_hpet);\n\nstatic inline int is_hpet_capable(void)\n{\n\treturn !boot_hpet_disable && hpet_address;\n}\n\n \nint is_hpet_enabled(void)\n{\n\treturn is_hpet_capable() && hpet_legacy_int_enabled;\n}\nEXPORT_SYMBOL_GPL(is_hpet_enabled);\n\nstatic void _hpet_print_config(const char *function, int line)\n{\n\tu32 i, id, period, cfg, status, channels, l, h;\n\n\tpr_info(\"%s(%d):\\n\", function, line);\n\n\tid = hpet_readl(HPET_ID);\n\tperiod = hpet_readl(HPET_PERIOD);\n\tpr_info(\"ID: 0x%x, PERIOD: 0x%x\\n\", id, period);\n\n\tcfg = hpet_readl(HPET_CFG);\n\tstatus = hpet_readl(HPET_STATUS);\n\tpr_info(\"CFG: 0x%x, STATUS: 0x%x\\n\", cfg, status);\n\n\tl = hpet_readl(HPET_COUNTER);\n\th = hpet_readl(HPET_COUNTER+4);\n\tpr_info(\"COUNTER_l: 0x%x, COUNTER_h: 0x%x\\n\", l, h);\n\n\tchannels = ((id & HPET_ID_NUMBER) >> HPET_ID_NUMBER_SHIFT) + 1;\n\n\tfor (i = 0; i < channels; i++) {\n\t\tl = hpet_readl(HPET_Tn_CFG(i));\n\t\th = hpet_readl(HPET_Tn_CFG(i)+4);\n\t\tpr_info(\"T%d: CFG_l: 0x%x, CFG_h: 0x%x\\n\", i, l, h);\n\n\t\tl = hpet_readl(HPET_Tn_CMP(i));\n\t\th = hpet_readl(HPET_Tn_CMP(i)+4);\n\t\tpr_info(\"T%d: CMP_l: 0x%x, CMP_h: 0x%x\\n\", i, l, h);\n\n\t\tl = hpet_readl(HPET_Tn_ROUTE(i));\n\t\th = hpet_readl(HPET_Tn_ROUTE(i)+4);\n\t\tpr_info(\"T%d ROUTE_l: 0x%x, ROUTE_h: 0x%x\\n\", i, l, h);\n\t}\n}\n\n#define hpet_print_config()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (hpet_verbose)\t\t\t\t\t\\\n\t\t_hpet_print_config(__func__, __LINE__);\t\\\n} while (0)\n\n \n#ifdef CONFIG_HPET\n\nstatic void __init hpet_reserve_platform_timers(void)\n{\n\tstruct hpet_data hd;\n\tunsigned int i;\n\n\tmemset(&hd, 0, sizeof(hd));\n\thd.hd_phys_address\t= hpet_address;\n\thd.hd_address\t\t= hpet_virt_address;\n\thd.hd_nirqs\t\t= hpet_base.nr_channels;\n\n\t \n\thd.hd_irq[0] = HPET_LEGACY_8254;\n\thd.hd_irq[1] = HPET_LEGACY_RTC;\n\n\tfor (i = 0; i < hpet_base.nr_channels; i++) {\n\t\tstruct hpet_channel *hc = hpet_base.channels + i;\n\n\t\tif (i >= 2)\n\t\t\thd.hd_irq[i] = hc->irq;\n\n\t\tswitch (hc->mode) {\n\t\tcase HPET_MODE_UNUSED:\n\t\tcase HPET_MODE_DEVICE:\n\t\t\thc->mode = HPET_MODE_DEVICE;\n\t\t\tbreak;\n\t\tcase HPET_MODE_CLOCKEVT:\n\t\tcase HPET_MODE_LEGACY:\n\t\t\thpet_reserve_timer(&hd, hc->num);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thpet_alloc(&hd);\n}\n\nstatic void __init hpet_select_device_channel(void)\n{\n\tint i;\n\n\tfor (i = 0; i < hpet_base.nr_channels; i++) {\n\t\tstruct hpet_channel *hc = hpet_base.channels + i;\n\n\t\t \n\t\tif (hc->mode == HPET_MODE_UNUSED) {\n\t\t\thc->mode = HPET_MODE_DEVICE;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#else\nstatic inline void hpet_reserve_platform_timers(void) { }\nstatic inline void hpet_select_device_channel(void) {}\n#endif\n\n \nstatic void hpet_stop_counter(void)\n{\n\tu32 cfg = hpet_readl(HPET_CFG);\n\n\tcfg &= ~HPET_CFG_ENABLE;\n\thpet_writel(cfg, HPET_CFG);\n}\n\nstatic void hpet_reset_counter(void)\n{\n\thpet_writel(0, HPET_COUNTER);\n\thpet_writel(0, HPET_COUNTER + 4);\n}\n\nstatic void hpet_start_counter(void)\n{\n\tunsigned int cfg = hpet_readl(HPET_CFG);\n\n\tcfg |= HPET_CFG_ENABLE;\n\thpet_writel(cfg, HPET_CFG);\n}\n\nstatic void hpet_restart_counter(void)\n{\n\thpet_stop_counter();\n\thpet_reset_counter();\n\thpet_start_counter();\n}\n\nstatic void hpet_resume_device(void)\n{\n\tforce_hpet_resume();\n}\n\nstatic void hpet_resume_counter(struct clocksource *cs)\n{\n\thpet_resume_device();\n\thpet_restart_counter();\n}\n\nstatic void hpet_enable_legacy_int(void)\n{\n\tunsigned int cfg = hpet_readl(HPET_CFG);\n\n\tcfg |= HPET_CFG_LEGACY;\n\thpet_writel(cfg, HPET_CFG);\n\thpet_legacy_int_enabled = true;\n}\n\nstatic int hpet_clkevt_set_state_periodic(struct clock_event_device *evt)\n{\n\tunsigned int channel = clockevent_to_channel(evt)->num;\n\tunsigned int cfg, cmp, now;\n\tuint64_t delta;\n\n\thpet_stop_counter();\n\tdelta = ((uint64_t)(NSEC_PER_SEC / HZ)) * evt->mult;\n\tdelta >>= evt->shift;\n\tnow = hpet_readl(HPET_COUNTER);\n\tcmp = now + (unsigned int)delta;\n\tcfg = hpet_readl(HPET_Tn_CFG(channel));\n\tcfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL |\n\t       HPET_TN_32BIT;\n\thpet_writel(cfg, HPET_Tn_CFG(channel));\n\thpet_writel(cmp, HPET_Tn_CMP(channel));\n\tudelay(1);\n\t \n\thpet_writel((unsigned int)delta, HPET_Tn_CMP(channel));\n\thpet_start_counter();\n\thpet_print_config();\n\n\treturn 0;\n}\n\nstatic int hpet_clkevt_set_state_oneshot(struct clock_event_device *evt)\n{\n\tunsigned int channel = clockevent_to_channel(evt)->num;\n\tunsigned int cfg;\n\n\tcfg = hpet_readl(HPET_Tn_CFG(channel));\n\tcfg &= ~HPET_TN_PERIODIC;\n\tcfg |= HPET_TN_ENABLE | HPET_TN_32BIT;\n\thpet_writel(cfg, HPET_Tn_CFG(channel));\n\n\treturn 0;\n}\n\nstatic int hpet_clkevt_set_state_shutdown(struct clock_event_device *evt)\n{\n\tunsigned int channel = clockevent_to_channel(evt)->num;\n\tunsigned int cfg;\n\n\tcfg = hpet_readl(HPET_Tn_CFG(channel));\n\tcfg &= ~HPET_TN_ENABLE;\n\thpet_writel(cfg, HPET_Tn_CFG(channel));\n\n\treturn 0;\n}\n\nstatic int hpet_clkevt_legacy_resume(struct clock_event_device *evt)\n{\n\thpet_enable_legacy_int();\n\thpet_print_config();\n\treturn 0;\n}\n\nstatic int\nhpet_clkevt_set_next_event(unsigned long delta, struct clock_event_device *evt)\n{\n\tunsigned int channel = clockevent_to_channel(evt)->num;\n\tu32 cnt;\n\ts32 res;\n\n\tcnt = hpet_readl(HPET_COUNTER);\n\tcnt += (u32) delta;\n\thpet_writel(cnt, HPET_Tn_CMP(channel));\n\n\t \n\tres = (s32)(cnt - hpet_readl(HPET_COUNTER));\n\n\treturn res < HPET_MIN_CYCLES ? -ETIME : 0;\n}\n\nstatic void hpet_init_clockevent(struct hpet_channel *hc, unsigned int rating)\n{\n\tstruct clock_event_device *evt = &hc->evt;\n\n\tevt->rating\t\t= rating;\n\tevt->irq\t\t= hc->irq;\n\tevt->name\t\t= hc->name;\n\tevt->cpumask\t\t= cpumask_of(hc->cpu);\n\tevt->set_state_oneshot\t= hpet_clkevt_set_state_oneshot;\n\tevt->set_next_event\t= hpet_clkevt_set_next_event;\n\tevt->set_state_shutdown\t= hpet_clkevt_set_state_shutdown;\n\n\tevt->features = CLOCK_EVT_FEAT_ONESHOT;\n\tif (hc->boot_cfg & HPET_TN_PERIODIC) {\n\t\tevt->features\t\t|= CLOCK_EVT_FEAT_PERIODIC;\n\t\tevt->set_state_periodic\t= hpet_clkevt_set_state_periodic;\n\t}\n}\n\nstatic void __init hpet_legacy_clockevent_register(struct hpet_channel *hc)\n{\n\t \n\thc->cpu = boot_cpu_data.cpu_index;\n\tstrscpy(hc->name, \"hpet\", sizeof(hc->name));\n\thpet_init_clockevent(hc, 50);\n\n\thc->evt.tick_resume\t= hpet_clkevt_legacy_resume;\n\n\t \n\thc->evt.features\t\t|= CLOCK_EVT_FEAT_PERIODIC;\n\thc->evt.set_state_periodic\t= hpet_clkevt_set_state_periodic;\n\n\t \n\thpet_enable_legacy_int();\n\n\tclockevents_config_and_register(&hc->evt, hpet_freq,\n\t\t\t\t\tHPET_MIN_PROG_DELTA, 0x7FFFFFFF);\n\tglobal_clock_event = &hc->evt;\n\tpr_debug(\"Clockevent registered\\n\");\n}\n\n \n#ifdef CONFIG_GENERIC_MSI_IRQ\nstatic void hpet_msi_unmask(struct irq_data *data)\n{\n\tstruct hpet_channel *hc = irq_data_get_irq_handler_data(data);\n\tunsigned int cfg;\n\n\tcfg = hpet_readl(HPET_Tn_CFG(hc->num));\n\tcfg |= HPET_TN_ENABLE | HPET_TN_FSB;\n\thpet_writel(cfg, HPET_Tn_CFG(hc->num));\n}\n\nstatic void hpet_msi_mask(struct irq_data *data)\n{\n\tstruct hpet_channel *hc = irq_data_get_irq_handler_data(data);\n\tunsigned int cfg;\n\n\tcfg = hpet_readl(HPET_Tn_CFG(hc->num));\n\tcfg &= ~(HPET_TN_ENABLE | HPET_TN_FSB);\n\thpet_writel(cfg, HPET_Tn_CFG(hc->num));\n}\n\nstatic void hpet_msi_write(struct hpet_channel *hc, struct msi_msg *msg)\n{\n\thpet_writel(msg->data, HPET_Tn_ROUTE(hc->num));\n\thpet_writel(msg->address_lo, HPET_Tn_ROUTE(hc->num) + 4);\n}\n\nstatic void hpet_msi_write_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\thpet_msi_write(irq_data_get_irq_handler_data(data), msg);\n}\n\nstatic struct irq_chip hpet_msi_controller __ro_after_init = {\n\t.name = \"HPET-MSI\",\n\t.irq_unmask = hpet_msi_unmask,\n\t.irq_mask = hpet_msi_mask,\n\t.irq_ack = irq_chip_ack_parent,\n\t.irq_set_affinity = msi_domain_set_affinity,\n\t.irq_retrigger = irq_chip_retrigger_hierarchy,\n\t.irq_write_msi_msg = hpet_msi_write_msg,\n\t.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_AFFINITY_PRE_STARTUP,\n};\n\nstatic int hpet_msi_init(struct irq_domain *domain,\n\t\t\t struct msi_domain_info *info, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, msi_alloc_info_t *arg)\n{\n\tirq_set_status_flags(virq, IRQ_MOVE_PCNTXT);\n\tirq_domain_set_info(domain, virq, arg->hwirq, info->chip, NULL,\n\t\t\t    handle_edge_irq, arg->data, \"edge\");\n\n\treturn 0;\n}\n\nstatic void hpet_msi_free(struct irq_domain *domain,\n\t\t\t  struct msi_domain_info *info, unsigned int virq)\n{\n\tirq_clear_status_flags(virq, IRQ_MOVE_PCNTXT);\n}\n\nstatic struct msi_domain_ops hpet_msi_domain_ops = {\n\t.msi_init\t= hpet_msi_init,\n\t.msi_free\t= hpet_msi_free,\n};\n\nstatic struct msi_domain_info hpet_msi_domain_info = {\n\t.ops\t\t= &hpet_msi_domain_ops,\n\t.chip\t\t= &hpet_msi_controller,\n\t.flags\t\t= MSI_FLAG_USE_DEF_DOM_OPS,\n};\n\nstatic struct irq_domain *hpet_create_irq_domain(int hpet_id)\n{\n\tstruct msi_domain_info *domain_info;\n\tstruct irq_domain *parent, *d;\n\tstruct fwnode_handle *fn;\n\tstruct irq_fwspec fwspec;\n\n\tif (x86_vector_domain == NULL)\n\t\treturn NULL;\n\n\tdomain_info = kzalloc(sizeof(*domain_info), GFP_KERNEL);\n\tif (!domain_info)\n\t\treturn NULL;\n\n\t*domain_info = hpet_msi_domain_info;\n\tdomain_info->data = (void *)(long)hpet_id;\n\n\tfn = irq_domain_alloc_named_id_fwnode(hpet_msi_controller.name,\n\t\t\t\t\t      hpet_id);\n\tif (!fn) {\n\t\tkfree(domain_info);\n\t\treturn NULL;\n\t}\n\n\tfwspec.fwnode = fn;\n\tfwspec.param_count = 1;\n\tfwspec.param[0] = hpet_id;\n\n\tparent = irq_find_matching_fwspec(&fwspec, DOMAIN_BUS_ANY);\n\tif (!parent) {\n\t\tirq_domain_free_fwnode(fn);\n\t\tkfree(domain_info);\n\t\treturn NULL;\n\t}\n\tif (parent != x86_vector_domain)\n\t\thpet_msi_controller.name = \"IR-HPET-MSI\";\n\n\td = msi_create_irq_domain(fn, domain_info, parent);\n\tif (!d) {\n\t\tirq_domain_free_fwnode(fn);\n\t\tkfree(domain_info);\n\t}\n\treturn d;\n}\n\nstatic inline int hpet_dev_id(struct irq_domain *domain)\n{\n\tstruct msi_domain_info *info = msi_get_domain_info(domain);\n\n\treturn (int)(long)info->data;\n}\n\nstatic int hpet_assign_irq(struct irq_domain *domain, struct hpet_channel *hc,\n\t\t\t   int dev_num)\n{\n\tstruct irq_alloc_info info;\n\n\tinit_irq_alloc_info(&info, NULL);\n\tinfo.type = X86_IRQ_ALLOC_TYPE_HPET;\n\tinfo.data = hc;\n\tinfo.devid = hpet_dev_id(domain);\n\tinfo.hwirq = dev_num;\n\n\treturn irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, &info);\n}\n\nstatic int hpet_clkevt_msi_resume(struct clock_event_device *evt)\n{\n\tstruct hpet_channel *hc = clockevent_to_channel(evt);\n\tstruct irq_data *data = irq_get_irq_data(hc->irq);\n\tstruct msi_msg msg;\n\n\t \n\tirq_chip_compose_msi_msg(data, &msg);\n\thpet_msi_write(hc, &msg);\n\thpet_msi_unmask(data);\n\treturn 0;\n}\n\nstatic irqreturn_t hpet_msi_interrupt_handler(int irq, void *data)\n{\n\tstruct hpet_channel *hc = data;\n\tstruct clock_event_device *evt = &hc->evt;\n\n\tif (!evt->event_handler) {\n\t\tpr_info(\"Spurious interrupt HPET channel %d\\n\", hc->num);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hpet_setup_msi_irq(struct hpet_channel *hc)\n{\n\tif (request_irq(hc->irq, hpet_msi_interrupt_handler,\n\t\t\tIRQF_TIMER | IRQF_NOBALANCING,\n\t\t\thc->name, hc))\n\t\treturn -1;\n\n\tdisable_irq(hc->irq);\n\tirq_set_affinity(hc->irq, cpumask_of(hc->cpu));\n\tenable_irq(hc->irq);\n\n\tpr_debug(\"%s irq %u for MSI\\n\", hc->name, hc->irq);\n\n\treturn 0;\n}\n\n \nstatic void init_one_hpet_msi_clockevent(struct hpet_channel *hc, int cpu)\n{\n\tstruct clock_event_device *evt = &hc->evt;\n\n\thc->cpu = cpu;\n\tper_cpu(cpu_hpet_channel, cpu) = hc;\n\thpet_setup_msi_irq(hc);\n\n\thpet_init_clockevent(hc, 110);\n\tevt->tick_resume = hpet_clkevt_msi_resume;\n\n\tclockevents_config_and_register(evt, hpet_freq, HPET_MIN_PROG_DELTA,\n\t\t\t\t\t0x7FFFFFFF);\n}\n\nstatic struct hpet_channel *hpet_get_unused_clockevent(void)\n{\n\tint i;\n\n\tfor (i = 0; i < hpet_base.nr_channels; i++) {\n\t\tstruct hpet_channel *hc = hpet_base.channels + i;\n\n\t\tif (hc->mode != HPET_MODE_CLOCKEVT || hc->in_use)\n\t\t\tcontinue;\n\t\thc->in_use = 1;\n\t\treturn hc;\n\t}\n\treturn NULL;\n}\n\nstatic int hpet_cpuhp_online(unsigned int cpu)\n{\n\tstruct hpet_channel *hc = hpet_get_unused_clockevent();\n\n\tif (hc)\n\t\tinit_one_hpet_msi_clockevent(hc, cpu);\n\treturn 0;\n}\n\nstatic int hpet_cpuhp_dead(unsigned int cpu)\n{\n\tstruct hpet_channel *hc = per_cpu(cpu_hpet_channel, cpu);\n\n\tif (!hc)\n\t\treturn 0;\n\tfree_irq(hc->irq, hc);\n\thc->in_use = 0;\n\tper_cpu(cpu_hpet_channel, cpu) = NULL;\n\treturn 0;\n}\n\nstatic void __init hpet_select_clockevents(void)\n{\n\tunsigned int i;\n\n\thpet_base.nr_clockevents = 0;\n\n\t \n\tif (hpet_msi_disable || boot_cpu_has(X86_FEATURE_ARAT))\n\t\treturn;\n\n\thpet_print_config();\n\n\thpet_domain = hpet_create_irq_domain(hpet_blockid);\n\tif (!hpet_domain)\n\t\treturn;\n\n\tfor (i = 0; i < hpet_base.nr_channels; i++) {\n\t\tstruct hpet_channel *hc = hpet_base.channels + i;\n\t\tint irq;\n\n\t\tif (hc->mode != HPET_MODE_UNUSED)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(hc->boot_cfg & HPET_TN_FSB_CAP))\n\t\t\tcontinue;\n\n\t\tsprintf(hc->name, \"hpet%d\", i);\n\n\t\tirq = hpet_assign_irq(hpet_domain, hc, hc->num);\n\t\tif (irq <= 0)\n\t\t\tcontinue;\n\n\t\thc->irq = irq;\n\t\thc->mode = HPET_MODE_CLOCKEVT;\n\n\t\tif (++hpet_base.nr_clockevents == num_possible_cpus())\n\t\t\tbreak;\n\t}\n\n\tpr_info(\"%d channels of %d reserved for per-cpu timers\\n\",\n\t\thpet_base.nr_channels, hpet_base.nr_clockevents);\n}\n\n#else\n\nstatic inline void hpet_select_clockevents(void) { }\n\n#define hpet_cpuhp_online\tNULL\n#define hpet_cpuhp_dead\t\tNULL\n\n#endif\n\n \n#if defined(CONFIG_SMP) && defined(CONFIG_64BIT)\n \nunion hpet_lock {\n\tstruct {\n\t\tarch_spinlock_t lock;\n\t\tu32 value;\n\t};\n\tu64 lockval;\n};\n\nstatic union hpet_lock hpet __cacheline_aligned = {\n\t{ .lock = __ARCH_SPIN_LOCK_UNLOCKED, },\n};\n\nstatic u64 read_hpet(struct clocksource *cs)\n{\n\tunsigned long flags;\n\tunion hpet_lock old, new;\n\n\tBUILD_BUG_ON(sizeof(union hpet_lock) != 8);\n\n\t \n\tif (in_nmi())\n\t\treturn (u64)hpet_readl(HPET_COUNTER);\n\n\t \n\told.lockval = READ_ONCE(hpet.lockval);\n\n\tif (arch_spin_is_locked(&old.lock))\n\t\tgoto contended;\n\n\tlocal_irq_save(flags);\n\tif (arch_spin_trylock(&hpet.lock)) {\n\t\tnew.value = hpet_readl(HPET_COUNTER);\n\t\t \n\t\tWRITE_ONCE(hpet.value, new.value);\n\t\tarch_spin_unlock(&hpet.lock);\n\t\tlocal_irq_restore(flags);\n\t\treturn (u64)new.value;\n\t}\n\tlocal_irq_restore(flags);\n\ncontended:\n\t \n\tdo {\n\t\tcpu_relax();\n\t\tnew.lockval = READ_ONCE(hpet.lockval);\n\t} while ((new.value == old.value) && arch_spin_is_locked(&new.lock));\n\n\treturn (u64)new.value;\n}\n#else\n \nstatic u64 read_hpet(struct clocksource *cs)\n{\n\treturn (u64)hpet_readl(HPET_COUNTER);\n}\n#endif\n\nstatic struct clocksource clocksource_hpet = {\n\t.name\t\t= \"hpet\",\n\t.rating\t\t= 250,\n\t.read\t\t= read_hpet,\n\t.mask\t\t= HPET_MASK,\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.resume\t\t= hpet_resume_counter,\n};\n\n \nstatic bool __init hpet_cfg_working(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (hpet_readl(HPET_CFG) != 0xFFFFFFFF)\n\t\t\treturn true;\n\t}\n\n\tpr_warn(\"Config register invalid. Disabling HPET\\n\");\n\treturn false;\n}\n\nstatic bool __init hpet_counting(void)\n{\n\tu64 start, now, t1;\n\n\thpet_restart_counter();\n\n\tt1 = hpet_readl(HPET_COUNTER);\n\tstart = rdtsc();\n\n\t \n\tdo {\n\t\tif (t1 != hpet_readl(HPET_COUNTER))\n\t\t\treturn true;\n\t\tnow = rdtsc();\n\t} while ((now - start) < 200000UL);\n\n\tpr_warn(\"Counter not counting. HPET disabled\\n\");\n\treturn false;\n}\n\nstatic bool __init mwait_pc10_supported(void)\n{\n\tunsigned int eax, ebx, ecx, mwait_substates;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn false;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_MWAIT))\n\t\treturn false;\n\n\tif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\n\t\treturn false;\n\n\tcpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);\n\n\treturn (ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) &&\n\t       (ecx & CPUID5_ECX_INTERRUPT_BREAK) &&\n\t       (mwait_substates & (0xF << 28));\n}\n\n \nstatic bool __init hpet_is_pc10_damaged(void)\n{\n\tunsigned long long pcfg;\n\n\t \n\tif (!mwait_pc10_supported())\n\t\treturn false;\n\n\t \n\trdmsrl(MSR_PKG_CST_CONFIG_CONTROL, pcfg);\n\tif ((pcfg & 0xF) < 8)\n\t\treturn false;\n\n\tif (hpet_force_user) {\n\t\tpr_warn(\"HPET force enabled via command line, but dysfunctional in PC10.\\n\");\n\t\treturn false;\n\t}\n\n\tpr_info(\"HPET dysfunctional in PC10. Force disabled.\\n\");\n\tboot_hpet_disable = true;\n\treturn true;\n}\n\n \nint __init hpet_enable(void)\n{\n\tu32 hpet_period, cfg, id, irq;\n\tunsigned int i, channels;\n\tstruct hpet_channel *hc;\n\tu64 freq;\n\n\tif (!is_hpet_capable())\n\t\treturn 0;\n\n\tif (hpet_is_pc10_damaged())\n\t\treturn 0;\n\n\thpet_set_mapping();\n\tif (!hpet_virt_address)\n\t\treturn 0;\n\n\t \n\tif (!hpet_cfg_working())\n\t\tgoto out_nohpet;\n\n\t \n\thpet_period = hpet_readl(HPET_PERIOD);\n\tif (hpet_period < HPET_MIN_PERIOD || hpet_period > HPET_MAX_PERIOD)\n\t\tgoto out_nohpet;\n\n\t \n\tfreq = FSEC_PER_SEC;\n\tdo_div(freq, hpet_period);\n\thpet_freq = freq;\n\n\t \n\tid = hpet_readl(HPET_ID);\n\thpet_print_config();\n\n\t \n\tchannels = ((id & HPET_ID_NUMBER) >> HPET_ID_NUMBER_SHIFT) + 1;\n\n\t \n\tif (IS_ENABLED(CONFIG_HPET_EMULATE_RTC) && channels < 2)\n\t\tgoto out_nohpet;\n\n\thc = kcalloc(channels, sizeof(*hc), GFP_KERNEL);\n\tif (!hc) {\n\t\tpr_warn(\"Disabling HPET.\\n\");\n\t\tgoto out_nohpet;\n\t}\n\thpet_base.channels = hc;\n\thpet_base.nr_channels = channels;\n\n\t \n\tcfg = hpet_readl(HPET_CFG);\n\thpet_base.boot_cfg = cfg;\n\tcfg &= ~(HPET_CFG_ENABLE | HPET_CFG_LEGACY);\n\thpet_writel(cfg, HPET_CFG);\n\tif (cfg)\n\t\tpr_warn(\"Global config: Unknown bits %#x\\n\", cfg);\n\n\t \n\tfor (i = 0; i < channels; i++, hc++) {\n\t\thc->num = i;\n\n\t\tcfg = hpet_readl(HPET_Tn_CFG(i));\n\t\thc->boot_cfg = cfg;\n\t\tirq = (cfg & Tn_INT_ROUTE_CNF_MASK) >> Tn_INT_ROUTE_CNF_SHIFT;\n\t\thc->irq = irq;\n\n\t\tcfg &= ~(HPET_TN_ENABLE | HPET_TN_LEVEL | HPET_TN_FSB);\n\t\thpet_writel(cfg, HPET_Tn_CFG(i));\n\n\t\tcfg &= ~(HPET_TN_PERIODIC | HPET_TN_PERIODIC_CAP\n\t\t\t | HPET_TN_64BIT_CAP | HPET_TN_32BIT | HPET_TN_ROUTE\n\t\t\t | HPET_TN_FSB | HPET_TN_FSB_CAP);\n\t\tif (cfg)\n\t\t\tpr_warn(\"Channel #%u config: Unknown bits %#x\\n\", i, cfg);\n\t}\n\thpet_print_config();\n\n\t \n\tif (!hpet_counting())\n\t\tgoto out_nohpet;\n\n\tif (tsc_clocksource_watchdog_disabled())\n\t\tclocksource_hpet.flags |= CLOCK_SOURCE_MUST_VERIFY;\n\tclocksource_register_hz(&clocksource_hpet, (u32)hpet_freq);\n\n\tif (id & HPET_ID_LEGSUP) {\n\t\thpet_legacy_clockevent_register(&hpet_base.channels[0]);\n\t\thpet_base.channels[0].mode = HPET_MODE_LEGACY;\n\t\tif (IS_ENABLED(CONFIG_HPET_EMULATE_RTC))\n\t\t\thpet_base.channels[1].mode = HPET_MODE_LEGACY;\n\t\treturn 1;\n\t}\n\treturn 0;\n\nout_nohpet:\n\tkfree(hpet_base.channels);\n\thpet_base.channels = NULL;\n\thpet_base.nr_channels = 0;\n\thpet_clear_mapping();\n\thpet_address = 0;\n\treturn 0;\n}\n\n \nstatic __init int hpet_late_init(void)\n{\n\tint ret;\n\n\tif (!hpet_address) {\n\t\tif (!force_hpet_address)\n\t\t\treturn -ENODEV;\n\n\t\thpet_address = force_hpet_address;\n\t\thpet_enable();\n\t}\n\n\tif (!hpet_virt_address)\n\t\treturn -ENODEV;\n\n\thpet_select_device_channel();\n\thpet_select_clockevents();\n\thpet_reserve_platform_timers();\n\thpet_print_config();\n\n\tif (!hpet_base.nr_clockevents)\n\t\treturn 0;\n\n\tret = cpuhp_setup_state(CPUHP_AP_X86_HPET_ONLINE, \"x86/hpet:online\",\n\t\t\t\thpet_cpuhp_online, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = cpuhp_setup_state(CPUHP_X86_HPET_DEAD, \"x86/hpet:dead\", NULL,\n\t\t\t\thpet_cpuhp_dead);\n\tif (ret)\n\t\tgoto err_cpuhp;\n\treturn 0;\n\nerr_cpuhp:\n\tcpuhp_remove_state(CPUHP_AP_X86_HPET_ONLINE);\n\treturn ret;\n}\nfs_initcall(hpet_late_init);\n\nvoid hpet_disable(void)\n{\n\tunsigned int i;\n\tu32 cfg;\n\n\tif (!is_hpet_capable() || !hpet_virt_address)\n\t\treturn;\n\n\t \n\tcfg = hpet_base.boot_cfg;\n\tcfg &= ~HPET_CFG_ENABLE;\n\thpet_writel(cfg, HPET_CFG);\n\n\t \n\tfor (i = 0; i < hpet_base.nr_channels; i++)\n\t\thpet_writel(hpet_base.channels[i].boot_cfg, HPET_Tn_CFG(i));\n\n\t \n\tif (hpet_base.boot_cfg & HPET_CFG_ENABLE)\n\t\thpet_writel(hpet_base.boot_cfg, HPET_CFG);\n}\n\n#ifdef CONFIG_HPET_EMULATE_RTC\n\n \n#include <linux/mc146818rtc.h>\n#include <linux/rtc.h>\n\n#define DEFAULT_RTC_INT_FREQ\t64\n#define DEFAULT_RTC_SHIFT\t6\n#define RTC_NUM_INTS\t\t1\n\nstatic unsigned long hpet_rtc_flags;\nstatic int hpet_prev_update_sec;\nstatic struct rtc_time hpet_alarm_time;\nstatic unsigned long hpet_pie_count;\nstatic u32 hpet_t1_cmp;\nstatic u32 hpet_default_delta;\nstatic u32 hpet_pie_delta;\nstatic unsigned long hpet_pie_limit;\n\nstatic rtc_irq_handler irq_handler;\n\n \nstatic inline int hpet_cnt_ahead(u32 c1, u32 c2)\n{\n\treturn (s32)(c2 - c1) < 0;\n}\n\n \nint hpet_register_irq_handler(rtc_irq_handler handler)\n{\n\tif (!is_hpet_enabled())\n\t\treturn -ENODEV;\n\tif (irq_handler)\n\t\treturn -EBUSY;\n\n\tirq_handler = handler;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hpet_register_irq_handler);\n\n \nvoid hpet_unregister_irq_handler(rtc_irq_handler handler)\n{\n\tif (!is_hpet_enabled())\n\t\treturn;\n\n\tirq_handler = NULL;\n\thpet_rtc_flags = 0;\n}\nEXPORT_SYMBOL_GPL(hpet_unregister_irq_handler);\n\n \nint hpet_rtc_timer_init(void)\n{\n\tunsigned int cfg, cnt, delta;\n\tunsigned long flags;\n\n\tif (!is_hpet_enabled())\n\t\treturn 0;\n\n\tif (!hpet_default_delta) {\n\t\tstruct clock_event_device *evt = &hpet_base.channels[0].evt;\n\t\tuint64_t clc;\n\n\t\tclc = (uint64_t) evt->mult * NSEC_PER_SEC;\n\t\tclc >>= evt->shift + DEFAULT_RTC_SHIFT;\n\t\thpet_default_delta = clc;\n\t}\n\n\tif (!(hpet_rtc_flags & RTC_PIE) || hpet_pie_limit)\n\t\tdelta = hpet_default_delta;\n\telse\n\t\tdelta = hpet_pie_delta;\n\n\tlocal_irq_save(flags);\n\n\tcnt = delta + hpet_readl(HPET_COUNTER);\n\thpet_writel(cnt, HPET_T1_CMP);\n\thpet_t1_cmp = cnt;\n\n\tcfg = hpet_readl(HPET_T1_CFG);\n\tcfg &= ~HPET_TN_PERIODIC;\n\tcfg |= HPET_TN_ENABLE | HPET_TN_32BIT;\n\thpet_writel(cfg, HPET_T1_CFG);\n\n\tlocal_irq_restore(flags);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hpet_rtc_timer_init);\n\nstatic void hpet_disable_rtc_channel(void)\n{\n\tu32 cfg = hpet_readl(HPET_T1_CFG);\n\n\tcfg &= ~HPET_TN_ENABLE;\n\thpet_writel(cfg, HPET_T1_CFG);\n}\n\n \nint hpet_mask_rtc_irq_bit(unsigned long bit_mask)\n{\n\tif (!is_hpet_enabled())\n\t\treturn 0;\n\n\thpet_rtc_flags &= ~bit_mask;\n\tif (unlikely(!hpet_rtc_flags))\n\t\thpet_disable_rtc_channel();\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hpet_mask_rtc_irq_bit);\n\nint hpet_set_rtc_irq_bit(unsigned long bit_mask)\n{\n\tunsigned long oldbits = hpet_rtc_flags;\n\n\tif (!is_hpet_enabled())\n\t\treturn 0;\n\n\thpet_rtc_flags |= bit_mask;\n\n\tif ((bit_mask & RTC_UIE) && !(oldbits & RTC_UIE))\n\t\thpet_prev_update_sec = -1;\n\n\tif (!oldbits)\n\t\thpet_rtc_timer_init();\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hpet_set_rtc_irq_bit);\n\nint hpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec)\n{\n\tif (!is_hpet_enabled())\n\t\treturn 0;\n\n\thpet_alarm_time.tm_hour = hrs;\n\thpet_alarm_time.tm_min = min;\n\thpet_alarm_time.tm_sec = sec;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hpet_set_alarm_time);\n\nint hpet_set_periodic_freq(unsigned long freq)\n{\n\tuint64_t clc;\n\n\tif (!is_hpet_enabled())\n\t\treturn 0;\n\n\tif (freq <= DEFAULT_RTC_INT_FREQ) {\n\t\thpet_pie_limit = DEFAULT_RTC_INT_FREQ / freq;\n\t} else {\n\t\tstruct clock_event_device *evt = &hpet_base.channels[0].evt;\n\n\t\tclc = (uint64_t) evt->mult * NSEC_PER_SEC;\n\t\tdo_div(clc, freq);\n\t\tclc >>= evt->shift;\n\t\thpet_pie_delta = clc;\n\t\thpet_pie_limit = 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hpet_set_periodic_freq);\n\nint hpet_rtc_dropped_irq(void)\n{\n\treturn is_hpet_enabled();\n}\nEXPORT_SYMBOL_GPL(hpet_rtc_dropped_irq);\n\nstatic void hpet_rtc_timer_reinit(void)\n{\n\tunsigned int delta;\n\tint lost_ints = -1;\n\n\tif (unlikely(!hpet_rtc_flags))\n\t\thpet_disable_rtc_channel();\n\n\tif (!(hpet_rtc_flags & RTC_PIE) || hpet_pie_limit)\n\t\tdelta = hpet_default_delta;\n\telse\n\t\tdelta = hpet_pie_delta;\n\n\t \n\tdo {\n\t\thpet_t1_cmp += delta;\n\t\thpet_writel(hpet_t1_cmp, HPET_T1_CMP);\n\t\tlost_ints++;\n\t} while (!hpet_cnt_ahead(hpet_t1_cmp, hpet_readl(HPET_COUNTER)));\n\n\tif (lost_ints) {\n\t\tif (hpet_rtc_flags & RTC_PIE)\n\t\t\thpet_pie_count += lost_ints;\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"Lost %d RTC interrupts\\n\", lost_ints);\n\t}\n}\n\nirqreturn_t hpet_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct rtc_time curr_time;\n\tunsigned long rtc_int_flag = 0;\n\n\thpet_rtc_timer_reinit();\n\tmemset(&curr_time, 0, sizeof(struct rtc_time));\n\n\tif (hpet_rtc_flags & (RTC_UIE | RTC_AIE)) {\n\t\tif (unlikely(mc146818_get_time(&curr_time) < 0)) {\n\t\t\tpr_err_ratelimited(\"unable to read current time from RTC\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (hpet_rtc_flags & RTC_UIE &&\n\t    curr_time.tm_sec != hpet_prev_update_sec) {\n\t\tif (hpet_prev_update_sec >= 0)\n\t\t\trtc_int_flag = RTC_UF;\n\t\thpet_prev_update_sec = curr_time.tm_sec;\n\t}\n\n\tif (hpet_rtc_flags & RTC_PIE && ++hpet_pie_count >= hpet_pie_limit) {\n\t\trtc_int_flag |= RTC_PF;\n\t\thpet_pie_count = 0;\n\t}\n\n\tif (hpet_rtc_flags & RTC_AIE &&\n\t    (curr_time.tm_sec == hpet_alarm_time.tm_sec) &&\n\t    (curr_time.tm_min == hpet_alarm_time.tm_min) &&\n\t    (curr_time.tm_hour == hpet_alarm_time.tm_hour))\n\t\trtc_int_flag |= RTC_AF;\n\n\tif (rtc_int_flag) {\n\t\trtc_int_flag |= (RTC_IRQF | (RTC_NUM_INTS << 8));\n\t\tif (irq_handler)\n\t\t\tirq_handler(rtc_int_flag, dev_id);\n\t}\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(hpet_rtc_interrupt);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}