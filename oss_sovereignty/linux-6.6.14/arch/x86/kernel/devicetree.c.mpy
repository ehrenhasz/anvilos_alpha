{
  "module_name": "devicetree.c",
  "hash_id": "c97ddfd89fa987042a21cac78949fc5815c3b21e351aad12763f30049cefe6d1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/devicetree.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/libfdt.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/of_pci.h>\n#include <linux/initrd.h>\n\n#include <asm/irqdomain.h>\n#include <asm/hpet.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/pci_x86.h>\n#include <asm/setup.h>\n#include <asm/i8259.h>\n#include <asm/prom.h>\n\n__initdata u64 initial_dtb;\nchar __initdata cmd_line[COMMAND_LINE_SIZE];\n\nint __initdata of_ioapic;\n\nvoid __init add_dtb(u64 data)\n{\n\tinitial_dtb = data + offsetof(struct setup_data, data);\n}\n\n \nstatic struct of_device_id __initdata ce4100_ids[] = {\n\t{ .compatible = \"intel,ce4100-cp\", },\n\t{ .compatible = \"isa\", },\n\t{ .compatible = \"pci\", },\n\t{},\n};\n\nstatic int __init add_bus_probe(void)\n{\n\tif (!of_have_populated_dt())\n\t\treturn 0;\n\n\treturn of_platform_bus_probe(NULL, ce4100_ids, NULL);\n}\ndevice_initcall(add_bus_probe);\n\n#ifdef CONFIG_PCI\nstruct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)\n{\n\tstruct device_node *np;\n\n\tfor_each_node_by_type(np, \"pci\") {\n\t\tconst void *prop;\n\t\tunsigned int bus_min;\n\n\t\tprop = of_get_property(np, \"bus-range\", NULL);\n\t\tif (!prop)\n\t\t\tcontinue;\n\t\tbus_min = be32_to_cpup(prop);\n\t\tif (bus->number == bus_min)\n\t\t\treturn np;\n\t}\n\treturn NULL;\n}\n\nstatic int x86_of_pci_irq_enable(struct pci_dev *dev)\n{\n\tu32 virq;\n\tint ret;\n\tu8 pin;\n\n\tret = pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n\tif (ret)\n\t\treturn ret;\n\tif (!pin)\n\t\treturn 0;\n\n\tvirq = of_irq_parse_and_map_pci(dev, 0, 0);\n\tif (virq == 0)\n\t\treturn -EINVAL;\n\tdev->irq = virq;\n\treturn 0;\n}\n\nstatic void x86_of_pci_irq_disable(struct pci_dev *dev)\n{\n}\n\nvoid x86_of_pci_init(void)\n{\n\tpcibios_enable_irq = x86_of_pci_irq_enable;\n\tpcibios_disable_irq = x86_of_pci_irq_disable;\n}\n#endif\n\nstatic void __init dtb_setup_hpet(void)\n{\n#ifdef CONFIG_HPET_TIMER\n\tstruct device_node *dn;\n\tstruct resource r;\n\tint ret;\n\n\tdn = of_find_compatible_node(NULL, NULL, \"intel,ce4100-hpet\");\n\tif (!dn)\n\t\treturn;\n\tret = of_address_to_resource(dn, 0, &r);\n\tif (ret) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thpet_address = r.start;\n#endif\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\nstatic void __init dtb_cpu_setup(void)\n{\n\tstruct device_node *dn;\n\tu32 apic_id;\n\n\tfor_each_of_cpu_node(dn) {\n\t\tapic_id = of_get_cpu_hwid(dn, 0);\n\t\tif (apic_id == ~0U) {\n\t\t\tpr_warn(\"%pOF: missing local APIC ID\\n\", dn);\n\t\t\tcontinue;\n\t\t}\n\t\tgeneric_processor_info(apic_id);\n\t}\n}\n\nstatic void __init dtb_lapic_setup(void)\n{\n\tstruct device_node *dn;\n\tstruct resource r;\n\tunsigned long lapic_addr = APIC_DEFAULT_PHYS_BASE;\n\tint ret;\n\n\tdn = of_find_compatible_node(NULL, NULL, \"intel,ce4100-lapic\");\n\tif (dn) {\n\t\tret = of_address_to_resource(dn, 0, &r);\n\t\tif (WARN_ON(ret))\n\t\t\treturn;\n\t\tlapic_addr = r.start;\n\t}\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_APIC)) {\n\t\t \n\t\tif (!apic_force_enable(lapic_addr))\n\t\t\treturn;\n\t} else {\n\t\tregister_lapic_address(lapic_addr);\n\t}\n\tsmp_found_config = 1;\n\tpic_mode = !of_property_read_bool(dn, \"intel,virtual-wire-mode\");\n\tpr_info(\"%s compatibility mode.\\n\", pic_mode ? \"IMCR and PIC\" : \"Virtual Wire\");\n}\n\n#endif  \n\n#ifdef CONFIG_X86_IO_APIC\nstatic unsigned int ioapic_id;\n\nstruct of_ioapic_type {\n\tu32 out_type;\n\tu32 is_level;\n\tu32 active_low;\n};\n\nstatic struct of_ioapic_type of_ioapic_type[] =\n{\n\t{\n\t\t.out_type\t= IRQ_TYPE_EDGE_FALLING,\n\t\t.is_level\t= 0,\n\t\t.active_low\t= 1,\n\t},\n\t{\n\t\t.out_type\t= IRQ_TYPE_LEVEL_HIGH,\n\t\t.is_level\t= 1,\n\t\t.active_low\t= 0,\n\t},\n\t{\n\t\t.out_type\t= IRQ_TYPE_LEVEL_LOW,\n\t\t.is_level\t= 1,\n\t\t.active_low\t= 1,\n\t},\n\t{\n\t\t.out_type\t= IRQ_TYPE_EDGE_RISING,\n\t\t.is_level\t= 0,\n\t\t.active_low\t= 0,\n\t},\n};\n\nstatic int dt_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_fwspec *fwspec = (struct irq_fwspec *)arg;\n\tstruct of_ioapic_type *it;\n\tstruct irq_alloc_info tmp;\n\tint type_index;\n\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\n\ttype_index = fwspec->param[1];\n\tif (type_index >= ARRAY_SIZE(of_ioapic_type))\n\t\treturn -EINVAL;\n\n\tit = &of_ioapic_type[type_index];\n\tioapic_set_alloc_attr(&tmp, NUMA_NO_NODE, it->is_level, it->active_low);\n\ttmp.devid = mpc_ioapic_id(mp_irqdomain_ioapic_idx(domain));\n\ttmp.ioapic.pin = fwspec->param[0];\n\n\treturn mp_irqdomain_alloc(domain, virq, nr_irqs, &tmp);\n}\n\nstatic const struct irq_domain_ops ioapic_irq_domain_ops = {\n\t.alloc\t\t= dt_irqdomain_alloc,\n\t.free\t\t= mp_irqdomain_free,\n\t.activate\t= mp_irqdomain_activate,\n\t.deactivate\t= mp_irqdomain_deactivate,\n};\n\nstatic void __init dtb_add_ioapic(struct device_node *dn)\n{\n\tstruct resource r;\n\tint ret;\n\tstruct ioapic_domain_cfg cfg = {\n\t\t.type = IOAPIC_DOMAIN_DYNAMIC,\n\t\t.ops = &ioapic_irq_domain_ops,\n\t\t.dev = dn,\n\t};\n\n\tret = of_address_to_resource(dn, 0, &r);\n\tif (ret) {\n\t\tpr_err(\"Can't obtain address from device node %pOF.\\n\", dn);\n\t\treturn;\n\t}\n\tmp_register_ioapic(++ioapic_id, r.start, gsi_top, &cfg);\n}\n\nstatic void __init dtb_ioapic_setup(void)\n{\n\tstruct device_node *dn;\n\n\tfor_each_compatible_node(dn, NULL, \"intel,ce4100-ioapic\")\n\t\tdtb_add_ioapic(dn);\n\n\tif (nr_ioapics) {\n\t\tof_ioapic = 1;\n\t\treturn;\n\t}\n\tpr_err(\"Error: No information about IO-APIC in OF.\\n\");\n}\n#else\nstatic void __init dtb_ioapic_setup(void) {}\n#endif\n\nstatic void __init dtb_apic_setup(void)\n{\n#ifdef CONFIG_X86_LOCAL_APIC\n\tdtb_lapic_setup();\n\tdtb_cpu_setup();\n#endif\n\tdtb_ioapic_setup();\n}\n\n#ifdef CONFIG_OF_EARLY_FLATTREE\nstatic void __init x86_flattree_get_config(void)\n{\n\tu32 size, map_len;\n\tvoid *dt;\n\n\tif (!initial_dtb)\n\t\treturn;\n\n\tmap_len = max(PAGE_SIZE - (initial_dtb & ~PAGE_MASK), (u64)128);\n\n\tdt = early_memremap(initial_dtb, map_len);\n\tsize = fdt_totalsize(dt);\n\tif (map_len < size) {\n\t\tearly_memunmap(dt, map_len);\n\t\tdt = early_memremap(initial_dtb, size);\n\t\tmap_len = size;\n\t}\n\n\tearly_init_dt_verify(dt);\n\tunflatten_and_copy_device_tree();\n\tearly_memunmap(dt, map_len);\n}\n#else\nstatic inline void x86_flattree_get_config(void) { }\n#endif\n\nvoid __init x86_dtb_init(void)\n{\n\tx86_flattree_get_config();\n\n\tif (!of_have_populated_dt())\n\t\treturn;\n\n\tdtb_setup_hpet();\n\tdtb_apic_setup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}