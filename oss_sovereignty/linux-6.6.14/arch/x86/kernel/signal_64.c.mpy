{
  "module_name": "signal_64.c",
  "hash_id": "d1aca8f89b3500a7facea470791f357ba728814a632e01b1f4c5aefa9d2b8f47",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/signal_64.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n\n#include <asm/ucontext.h>\n#include <asm/fpu/signal.h>\n#include <asm/sighandling.h>\n\n#include <asm/syscall.h>\n#include <asm/sigframe.h>\n#include <asm/signal.h>\n\n \nstatic void force_valid_ss(struct pt_regs *regs)\n{\n\tu32 ar;\n\tasm volatile (\"lar %[old_ss], %[ar]\\n\\t\"\n\t\t      \"jz 1f\\n\\t\"\t\t \n\t\t      \"xorl %[ar], %[ar]\\n\\t\"\t \n\t\t      \"1:\"\n\t\t      : [ar] \"=r\" (ar)\n\t\t      : [old_ss] \"rm\" ((u16)regs->ss));\n\n\t \n\tar &= AR_DPL_MASK | AR_S | AR_P | AR_TYPE_MASK;\n\tif (ar != (AR_DPL3 | AR_S | AR_P | AR_TYPE_RWDATA) &&\n\t    ar != (AR_DPL3 | AR_S | AR_P | AR_TYPE_RWDATA_EXPDOWN))\n\t\tregs->ss = __USER_DS;\n}\n\nstatic bool restore_sigcontext(struct pt_regs *regs,\n\t\t\t       struct sigcontext __user *usc,\n\t\t\t       unsigned long uc_flags)\n{\n\tstruct sigcontext sc;\n\n\t \n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (copy_from_user(&sc, usc, offsetof(struct sigcontext, reserved1)))\n\t\treturn false;\n\n\tregs->bx = sc.bx;\n\tregs->cx = sc.cx;\n\tregs->dx = sc.dx;\n\tregs->si = sc.si;\n\tregs->di = sc.di;\n\tregs->bp = sc.bp;\n\tregs->ax = sc.ax;\n\tregs->sp = sc.sp;\n\tregs->ip = sc.ip;\n\tregs->r8 = sc.r8;\n\tregs->r9 = sc.r9;\n\tregs->r10 = sc.r10;\n\tregs->r11 = sc.r11;\n\tregs->r12 = sc.r12;\n\tregs->r13 = sc.r13;\n\tregs->r14 = sc.r14;\n\tregs->r15 = sc.r15;\n\n\t \n\tregs->cs = sc.cs | 0x03;\n\tregs->ss = sc.ss | 0x03;\n\n\tregs->flags = (regs->flags & ~FIX_EFLAGS) | (sc.flags & FIX_EFLAGS);\n\t \n\tregs->orig_ax = -1;\n\n\t \n\tif (unlikely(!(uc_flags & UC_STRICT_RESTORE_SS) && user_64bit_mode(regs)))\n\t\tforce_valid_ss(regs);\n\n\treturn fpu__restore_sig((void __user *)sc.fpstate, 0);\n}\n\nstatic __always_inline int\n__unsafe_setup_sigcontext(struct sigcontext __user *sc, void __user *fpstate,\n\t\t     struct pt_regs *regs, unsigned long mask)\n{\n\tunsafe_put_user(regs->di, &sc->di, Efault);\n\tunsafe_put_user(regs->si, &sc->si, Efault);\n\tunsafe_put_user(regs->bp, &sc->bp, Efault);\n\tunsafe_put_user(regs->sp, &sc->sp, Efault);\n\tunsafe_put_user(regs->bx, &sc->bx, Efault);\n\tunsafe_put_user(regs->dx, &sc->dx, Efault);\n\tunsafe_put_user(regs->cx, &sc->cx, Efault);\n\tunsafe_put_user(regs->ax, &sc->ax, Efault);\n\tunsafe_put_user(regs->r8, &sc->r8, Efault);\n\tunsafe_put_user(regs->r9, &sc->r9, Efault);\n\tunsafe_put_user(regs->r10, &sc->r10, Efault);\n\tunsafe_put_user(regs->r11, &sc->r11, Efault);\n\tunsafe_put_user(regs->r12, &sc->r12, Efault);\n\tunsafe_put_user(regs->r13, &sc->r13, Efault);\n\tunsafe_put_user(regs->r14, &sc->r14, Efault);\n\tunsafe_put_user(regs->r15, &sc->r15, Efault);\n\n\tunsafe_put_user(current->thread.trap_nr, &sc->trapno, Efault);\n\tunsafe_put_user(current->thread.error_code, &sc->err, Efault);\n\tunsafe_put_user(regs->ip, &sc->ip, Efault);\n\tunsafe_put_user(regs->flags, &sc->flags, Efault);\n\tunsafe_put_user(regs->cs, &sc->cs, Efault);\n\tunsafe_put_user(0, &sc->gs, Efault);\n\tunsafe_put_user(0, &sc->fs, Efault);\n\tunsafe_put_user(regs->ss, &sc->ss, Efault);\n\n\tunsafe_put_user(fpstate, (unsigned long __user *)&sc->fpstate, Efault);\n\n\t \n\tunsafe_put_user(mask, &sc->oldmask, Efault);\n\tunsafe_put_user(current->thread.cr2, &sc->cr2, Efault);\n\treturn 0;\nEfault:\n\treturn -EFAULT;\n}\n\n#define unsafe_put_sigcontext(sc, fp, regs, set, label)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__unsafe_setup_sigcontext(sc, fp, regs, set->sig[0]))\t\\\n\t\tgoto label;\t\t\t\t\t\t\\\n} while(0);\n\n#define unsafe_put_sigmask(set, frame, label) \\\n\tunsafe_put_user(*(__u64 *)(set), \\\n\t\t\t(__u64 __user *)&(frame)->uc.uc_sigmask, \\\n\t\t\tlabel)\n\nstatic unsigned long frame_uc_flags(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVE))\n\t\tflags = UC_FP_XSTATE | UC_SIGCONTEXT_SS;\n\telse\n\t\tflags = UC_SIGCONTEXT_SS;\n\n\tif (likely(user_64bit_mode(regs)))\n\t\tflags |= UC_STRICT_RESTORE_SS;\n\n\treturn flags;\n}\n\nint x64_setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tsigset_t *set = sigmask_to_save();\n\tstruct rt_sigframe __user *frame;\n\tvoid __user *fp = NULL;\n\tunsigned long uc_flags;\n\n\t \n\tif (!(ksig->ka.sa.sa_flags & SA_RESTORER))\n\t\treturn -EFAULT;\n\n\tframe = get_sigframe(ksig, regs, sizeof(struct rt_sigframe), &fp);\n\tuc_flags = frame_uc_flags(regs);\n\n\tif (!user_access_begin(frame, sizeof(*frame)))\n\t\treturn -EFAULT;\n\n\t \n\tunsafe_put_user(uc_flags, &frame->uc.uc_flags, Efault);\n\tunsafe_put_user(0, &frame->uc.uc_link, Efault);\n\tunsafe_save_altstack(&frame->uc.uc_stack, regs->sp, Efault);\n\n\t \n\tunsafe_put_user(ksig->ka.sa.sa_restorer, &frame->pretcode, Efault);\n\tunsafe_put_sigcontext(&frame->uc.uc_mcontext, fp, regs, set, Efault);\n\tunsafe_put_sigmask(set, frame, Efault);\n\tuser_access_end();\n\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\tif (copy_siginfo_to_user(&frame->info, &ksig->info))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (setup_signal_shadow_stack(ksig))\n\t\treturn -EFAULT;\n\n\t \n\tregs->di = ksig->sig;\n\t \n\tregs->ax = 0;\n\n\t \n\tregs->si = (unsigned long)&frame->info;\n\tregs->dx = (unsigned long)&frame->uc;\n\tregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\n\n\tregs->sp = (unsigned long)frame;\n\n\t \n\tregs->cs = __USER_CS;\n\n\tif (unlikely(regs->ss != __USER_DS))\n\t\tforce_valid_ss(regs);\n\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\n \nSYSCALL_DEFINE0(rt_sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct rt_sigframe __user *frame;\n\tsigset_t set;\n\tunsigned long uc_flags;\n\n\tframe = (struct rt_sigframe __user *)(regs->sp - sizeof(long));\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\tgoto badframe;\n\tif (__get_user(*(__u64 *)&set, (__u64 __user *)&frame->uc.uc_sigmask))\n\t\tgoto badframe;\n\tif (__get_user(uc_flags, &frame->uc.uc_flags))\n\t\tgoto badframe;\n\n\tset_current_blocked(&set);\n\n\tif (!restore_sigcontext(regs, &frame->uc.uc_mcontext, uc_flags))\n\t\tgoto badframe;\n\n\tif (restore_signal_shadow_stack())\n\t\tgoto badframe;\n\n\tif (restore_altstack(&frame->uc.uc_stack))\n\t\tgoto badframe;\n\n\treturn regs->ax;\n\nbadframe:\n\tsignal_fault(regs, frame, \"rt_sigreturn\");\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_X32_ABI\nstatic int x32_copy_siginfo_to_user(struct compat_siginfo __user *to,\n\t\tconst struct kernel_siginfo *from)\n{\n\tstruct compat_siginfo new;\n\n\tcopy_siginfo_to_external32(&new, from);\n\tif (from->si_signo == SIGCHLD) {\n\t\tnew._sifields._sigchld_x32._utime = from->si_utime;\n\t\tnew._sifields._sigchld_x32._stime = from->si_stime;\n\t}\n\tif (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint copy_siginfo_to_user32(struct compat_siginfo __user *to,\n\t\t\t   const struct kernel_siginfo *from)\n{\n\tif (in_x32_syscall())\n\t\treturn x32_copy_siginfo_to_user(to, from);\n\treturn __copy_siginfo_to_user32(to, from);\n}\n\nint x32_setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tcompat_sigset_t *set = (compat_sigset_t *) sigmask_to_save();\n\tstruct rt_sigframe_x32 __user *frame;\n\tunsigned long uc_flags;\n\tvoid __user *restorer;\n\tvoid __user *fp = NULL;\n\n\tif (!(ksig->ka.sa.sa_flags & SA_RESTORER))\n\t\treturn -EFAULT;\n\n\tframe = get_sigframe(ksig, regs, sizeof(*frame), &fp);\n\n\tuc_flags = frame_uc_flags(regs);\n\n\tif (!user_access_begin(frame, sizeof(*frame)))\n\t\treturn -EFAULT;\n\n\t \n\tunsafe_put_user(uc_flags, &frame->uc.uc_flags, Efault);\n\tunsafe_put_user(0, &frame->uc.uc_link, Efault);\n\tunsafe_compat_save_altstack(&frame->uc.uc_stack, regs->sp, Efault);\n\tunsafe_put_user(0, &frame->uc.uc__pad0, Efault);\n\trestorer = ksig->ka.sa.sa_restorer;\n\tunsafe_put_user(restorer, (unsigned long __user *)&frame->pretcode, Efault);\n\tunsafe_put_sigcontext(&frame->uc.uc_mcontext, fp, regs, set, Efault);\n\tunsafe_put_sigmask(set, frame, Efault);\n\tuser_access_end();\n\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\tif (x32_copy_siginfo_to_user(&frame->info, &ksig->info))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\n\n\t \n\tregs->di = ksig->sig;\n\tregs->si = (unsigned long) &frame->info;\n\tregs->dx = (unsigned long) &frame->uc;\n\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n\n\tregs->cs = __USER_CS;\n\tregs->ss = __USER_DS;\n\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nCOMPAT_SYSCALL_DEFINE0(x32_rt_sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct rt_sigframe_x32 __user *frame;\n\tsigset_t set;\n\tunsigned long uc_flags;\n\n\tframe = (struct rt_sigframe_x32 __user *)(regs->sp - 8);\n\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\tgoto badframe;\n\tif (__get_user(set.sig[0], (__u64 __user *)&frame->uc.uc_sigmask))\n\t\tgoto badframe;\n\tif (__get_user(uc_flags, &frame->uc.uc_flags))\n\t\tgoto badframe;\n\n\tset_current_blocked(&set);\n\n\tif (!restore_sigcontext(regs, &frame->uc.uc_mcontext, uc_flags))\n\t\tgoto badframe;\n\n\tif (compat_restore_altstack(&frame->uc.uc_stack))\n\t\tgoto badframe;\n\n\treturn regs->ax;\n\nbadframe:\n\tsignal_fault(regs, frame, \"x32 rt_sigreturn\");\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_COMPAT\nvoid sigaction_compat_abi(struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tif (!act)\n\t\treturn;\n\n\tif (in_ia32_syscall())\n\t\tact->sa.sa_flags |= SA_IA32_ABI;\n\tif (in_x32_syscall())\n\t\tact->sa.sa_flags |= SA_X32_ABI;\n}\n#endif  \n\n \nstatic_assert(NSIGILL  == 11);\nstatic_assert(NSIGFPE  == 15);\nstatic_assert(NSIGSEGV == 10);\nstatic_assert(NSIGBUS  == 5);\nstatic_assert(NSIGTRAP == 6);\nstatic_assert(NSIGCHLD == 6);\nstatic_assert(NSIGSYS  == 2);\n\n \nstatic_assert(sizeof(siginfo_t) == 128);\n\n \nstatic_assert(__alignof__(siginfo_t) == 8);\n\n \nstatic_assert(offsetof(siginfo_t, si_signo) == 0);\nstatic_assert(offsetof(siginfo_t, si_errno) == 4);\nstatic_assert(offsetof(siginfo_t, si_code)  == 8);\n\n \n\n#define CHECK_SI_OFFSET(name)\t\t\t\t\t\t\\\n\tstatic_assert(offsetof(siginfo_t, _sifields) == \t\t\\\n\t\t      offsetof(siginfo_t, _sifields.name))\n#define CHECK_SI_SIZE(name, size)\t\t\t\t\t\\\n\tstatic_assert(sizeof_field(siginfo_t, _sifields.name) == size)\n\nCHECK_SI_OFFSET(_kill);\nCHECK_SI_SIZE  (_kill, 2*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_pid) == 0x10);\nstatic_assert(offsetof(siginfo_t, si_uid) == 0x14);\n\nCHECK_SI_OFFSET(_timer);\nCHECK_SI_SIZE  (_timer, 6*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_tid)     == 0x10);\nstatic_assert(offsetof(siginfo_t, si_overrun) == 0x14);\nstatic_assert(offsetof(siginfo_t, si_value)   == 0x18);\n\nCHECK_SI_OFFSET(_rt);\nCHECK_SI_SIZE  (_rt, 4*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_pid)   == 0x10);\nstatic_assert(offsetof(siginfo_t, si_uid)   == 0x14);\nstatic_assert(offsetof(siginfo_t, si_value) == 0x18);\n\nCHECK_SI_OFFSET(_sigchld);\nCHECK_SI_SIZE  (_sigchld, 8*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_pid)    == 0x10);\nstatic_assert(offsetof(siginfo_t, si_uid)    == 0x14);\nstatic_assert(offsetof(siginfo_t, si_status) == 0x18);\nstatic_assert(offsetof(siginfo_t, si_utime)  == 0x20);\nstatic_assert(offsetof(siginfo_t, si_stime)  == 0x28);\n\n#ifdef CONFIG_X86_X32_ABI\n \nstatic_assert(sizeof_field(compat_siginfo_t, _sifields._sigchld_x32) ==\n\t      7*sizeof(int));\nstatic_assert(offsetof(compat_siginfo_t, _sifields) ==\n\t      offsetof(compat_siginfo_t, _sifields._sigchld_x32));\nstatic_assert(offsetof(compat_siginfo_t, _sifields._sigchld_x32._utime)  == 0x18);\nstatic_assert(offsetof(compat_siginfo_t, _sifields._sigchld_x32._stime)  == 0x20);\n#endif\n\nCHECK_SI_OFFSET(_sigfault);\nCHECK_SI_SIZE  (_sigfault, 8*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_addr)\t== 0x10);\n\nstatic_assert(offsetof(siginfo_t, si_trapno)\t== 0x18);\n\nstatic_assert(offsetof(siginfo_t, si_addr_lsb)\t== 0x18);\n\nstatic_assert(offsetof(siginfo_t, si_lower)\t== 0x20);\nstatic_assert(offsetof(siginfo_t, si_upper)\t== 0x28);\n\nstatic_assert(offsetof(siginfo_t, si_pkey)\t== 0x20);\n\nstatic_assert(offsetof(siginfo_t, si_perf_data)\t == 0x18);\nstatic_assert(offsetof(siginfo_t, si_perf_type)\t == 0x20);\nstatic_assert(offsetof(siginfo_t, si_perf_flags) == 0x24);\n\nCHECK_SI_OFFSET(_sigpoll);\nCHECK_SI_SIZE  (_sigpoll, 4*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_band) == 0x10);\nstatic_assert(offsetof(siginfo_t, si_fd)   == 0x18);\n\nCHECK_SI_OFFSET(_sigsys);\nCHECK_SI_SIZE  (_sigsys, 4*sizeof(int));\nstatic_assert(offsetof(siginfo_t, si_call_addr) == 0x10);\nstatic_assert(offsetof(siginfo_t, si_syscall)   == 0x18);\nstatic_assert(offsetof(siginfo_t, si_arch)      == 0x1C);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}