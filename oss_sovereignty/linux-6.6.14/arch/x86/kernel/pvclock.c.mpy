{
  "module_name": "pvclock.c",
  "hash_id": "5d07c351b2af1a2006dc4c64f629735c979dcfe4553b99baa7629ed9f8149160",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/pvclock.c",
  "human_readable_source": "\n \n\n#include <linux/clocksource.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/memblock.h>\n#include <linux/nmi.h>\n\n#include <asm/fixmap.h>\n#include <asm/pvclock.h>\n#include <asm/vgtod.h>\n\nstatic u8 valid_flags __read_mostly = 0;\nstatic struct pvclock_vsyscall_time_info *pvti_cpu0_va __read_mostly;\n\nvoid pvclock_set_flags(u8 flags)\n{\n\tvalid_flags = flags;\n}\n\nunsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src)\n{\n\tu64 pv_tsc_khz = 1000000ULL << 32;\n\n\tdo_div(pv_tsc_khz, src->tsc_to_system_mul);\n\tif (src->tsc_shift < 0)\n\t\tpv_tsc_khz <<= -src->tsc_shift;\n\telse\n\t\tpv_tsc_khz >>= src->tsc_shift;\n\treturn pv_tsc_khz;\n}\n\nvoid pvclock_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n\treset_hung_task_detector();\n}\n\nstatic atomic64_t last_value = ATOMIC64_INIT(0);\n\nvoid pvclock_resume(void)\n{\n\tatomic64_set(&last_value, 0);\n}\n\nu8 pvclock_read_flags(struct pvclock_vcpu_time_info *src)\n{\n\tunsigned version;\n\tu8 flags;\n\n\tdo {\n\t\tversion = pvclock_read_begin(src);\n\t\tflags = src->flags;\n\t} while (pvclock_read_retry(src, version));\n\n\treturn flags & valid_flags;\n}\n\nstatic __always_inline\nu64 __pvclock_clocksource_read(struct pvclock_vcpu_time_info *src, bool dowd)\n{\n\tunsigned version;\n\tu64 ret;\n\tu64 last;\n\tu8 flags;\n\n\tdo {\n\t\tversion = pvclock_read_begin(src);\n\t\tret = __pvclock_read_cycles(src, rdtsc_ordered());\n\t\tflags = src->flags;\n\t} while (pvclock_read_retry(src, version));\n\n\tif (dowd && unlikely((flags & PVCLOCK_GUEST_STOPPED) != 0)) {\n\t\tsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t}\n\n\tif ((valid_flags & PVCLOCK_TSC_STABLE_BIT) &&\n\t\t(flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn ret;\n\n\t \n\tlast = raw_atomic64_read(&last_value);\n\tdo {\n\t\tif (ret <= last)\n\t\t\treturn last;\n\t} while (!raw_atomic64_try_cmpxchg(&last_value, &last, ret));\n\n\treturn ret;\n}\n\nu64 pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)\n{\n\treturn __pvclock_clocksource_read(src, true);\n}\n\nnoinstr u64 pvclock_clocksource_read_nowd(struct pvclock_vcpu_time_info *src)\n{\n\treturn __pvclock_clocksource_read(src, false);\n}\n\nvoid pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,\n\t\t\t    struct pvclock_vcpu_time_info *vcpu_time,\n\t\t\t    struct timespec64 *ts)\n{\n\tu32 version;\n\tu64 delta;\n\tstruct timespec64 now;\n\n\t \n\tdo {\n\t\tversion = wall_clock->version;\n\t\trmb();\t\t \n\t\t \n\t\tnow.tv_sec  = wall_clock->sec;\n\t\tnow.tv_nsec = wall_clock->nsec;\n\t\trmb();\t\t \n\t} while ((wall_clock->version & 1) || (version != wall_clock->version));\n\n\tdelta = pvclock_clocksource_read(vcpu_time);\t \n\tdelta += now.tv_sec * NSEC_PER_SEC + now.tv_nsec;\n\n\tnow.tv_nsec = do_div(delta, NSEC_PER_SEC);\n\tnow.tv_sec = delta;\n\n\tset_normalized_timespec64(ts, now.tv_sec, now.tv_nsec);\n}\n\nvoid pvclock_set_pvti_cpu0_va(struct pvclock_vsyscall_time_info *pvti)\n{\n\tWARN_ON(vclock_was_used(VDSO_CLOCKMODE_PVCLOCK));\n\tpvti_cpu0_va = pvti;\n}\n\nstruct pvclock_vsyscall_time_info *pvclock_get_pvti_cpu0_va(void)\n{\n\treturn pvti_cpu0_va;\n}\nEXPORT_SYMBOL_GPL(pvclock_get_pvti_cpu0_va);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}