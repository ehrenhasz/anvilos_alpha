{
  "module_name": "itmt.c",
  "hash_id": "08294c39408e7a4b8d8e0d9e9e0ddff48c0efc44d2f58990fb7a52ecb61651dc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/itmt.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/cpumask.h>\n#include <linux/cpuset.h>\n#include <linux/mutex.h>\n#include <linux/sysctl.h>\n#include <linux/nodemask.h>\n\nstatic DEFINE_MUTEX(itmt_update_mutex);\nDEFINE_PER_CPU_READ_MOSTLY(int, sched_core_priority);\n\n \nstatic bool __read_mostly sched_itmt_capable;\n\n \nunsigned int __read_mostly sysctl_sched_itmt_enabled;\n\nstatic int sched_itmt_update_handler(struct ctl_table *table, int write,\n\t\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tunsigned int old_sysctl;\n\tint ret;\n\n\tmutex_lock(&itmt_update_mutex);\n\n\tif (!sched_itmt_capable) {\n\t\tmutex_unlock(&itmt_update_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\told_sysctl = sysctl_sched_itmt_enabled;\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!ret && write && old_sysctl != sysctl_sched_itmt_enabled) {\n\t\tx86_topology_update = true;\n\t\trebuild_sched_domains();\n\t}\n\n\tmutex_unlock(&itmt_update_mutex);\n\n\treturn ret;\n}\n\nstatic struct ctl_table itmt_kern_table[] = {\n\t{\n\t\t.procname\t= \"sched_itmt_enabled\",\n\t\t.data\t\t= &sysctl_sched_itmt_enabled,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_itmt_update_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{}\n};\n\nstatic struct ctl_table_header *itmt_sysctl_header;\n\n \nint sched_set_itmt_support(void)\n{\n\tmutex_lock(&itmt_update_mutex);\n\n\tif (sched_itmt_capable) {\n\t\tmutex_unlock(&itmt_update_mutex);\n\t\treturn 0;\n\t}\n\n\titmt_sysctl_header = register_sysctl(\"kernel\", itmt_kern_table);\n\tif (!itmt_sysctl_header) {\n\t\tmutex_unlock(&itmt_update_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tsched_itmt_capable = true;\n\n\tsysctl_sched_itmt_enabled = 1;\n\n\tx86_topology_update = true;\n\trebuild_sched_domains();\n\n\tmutex_unlock(&itmt_update_mutex);\n\n\treturn 0;\n}\n\n \nvoid sched_clear_itmt_support(void)\n{\n\tmutex_lock(&itmt_update_mutex);\n\n\tif (!sched_itmt_capable) {\n\t\tmutex_unlock(&itmt_update_mutex);\n\t\treturn;\n\t}\n\tsched_itmt_capable = false;\n\n\tif (itmt_sysctl_header) {\n\t\tunregister_sysctl_table(itmt_sysctl_header);\n\t\titmt_sysctl_header = NULL;\n\t}\n\n\tif (sysctl_sched_itmt_enabled) {\n\t\t \n\t\tsysctl_sched_itmt_enabled = 0;\n\t\tx86_topology_update = true;\n\t\trebuild_sched_domains();\n\t}\n\n\tmutex_unlock(&itmt_update_mutex);\n}\n\nint arch_asym_cpu_priority(int cpu)\n{\n\treturn per_cpu(sched_core_priority, cpu);\n}\n\n \nvoid sched_set_itmt_core_prio(int prio, int cpu)\n{\n\tper_cpu(sched_core_priority, cpu) = prio;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}