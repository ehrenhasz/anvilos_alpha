{
  "module_name": "io_apic.c",
  "hash_id": "1d2b3438938459055ca8668f3922e74fd9e5df027017d13dcfcc64116af079b1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/io_apic.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/pci.h>\n#include <linux/mc146818rtc.h>\n#include <linux/compiler.h>\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/syscore_ops.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/jiffies.h>\t \n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/msi.h>\n\n#include <asm/irqdomain.h>\n#include <asm/io.h>\n#include <asm/smp.h>\n#include <asm/cpu.h>\n#include <asm/desc.h>\n#include <asm/proto.h>\n#include <asm/acpi.h>\n#include <asm/dma.h>\n#include <asm/timer.h>\n#include <asm/time.h>\n#include <asm/i8259.h>\n#include <asm/setup.h>\n#include <asm/irq_remapping.h>\n#include <asm/hw_irq.h>\n#include <asm/apic.h>\n#include <asm/pgtable.h>\n#include <asm/x86_init.h>\n\n#define\tfor_each_ioapic(idx)\t\t\\\n\tfor ((idx) = 0; (idx) < nr_ioapics; (idx)++)\n#define\tfor_each_ioapic_reverse(idx)\t\\\n\tfor ((idx) = nr_ioapics - 1; (idx) >= 0; (idx)--)\n#define\tfor_each_pin(idx, pin)\t\t\\\n\tfor ((pin) = 0; (pin) < ioapics[(idx)].nr_registers; (pin)++)\n#define\tfor_each_ioapic_pin(idx, pin)\t\\\n\tfor_each_ioapic((idx))\t\t\\\n\t\tfor_each_pin((idx), (pin))\n#define for_each_irq_pin(entry, head) \\\n\tlist_for_each_entry(entry, &head, list)\n\nstatic DEFINE_RAW_SPINLOCK(ioapic_lock);\nstatic DEFINE_MUTEX(ioapic_mutex);\nstatic unsigned int ioapic_dynirq_base;\nstatic int ioapic_initialized;\n\nstruct irq_pin_list {\n\tstruct list_head list;\n\tint apic, pin;\n};\n\nstruct mp_chip_data {\n\tstruct list_head\t\tirq_2_pin;\n\tstruct IO_APIC_route_entry\tentry;\n\tbool\t\t\t\tis_level;\n\tbool\t\t\t\tactive_low;\n\tbool\t\t\t\tisa_irq;\n\tu32 count;\n};\n\nstruct mp_ioapic_gsi {\n\tu32 gsi_base;\n\tu32 gsi_end;\n};\n\nstatic struct ioapic {\n\t \n\tint nr_registers;\n\t \n\tstruct IO_APIC_route_entry *saved_registers;\n\t \n\tstruct mpc_ioapic mp_config;\n\t \n\tstruct mp_ioapic_gsi  gsi_config;\n\tstruct ioapic_domain_cfg irqdomain_cfg;\n\tstruct irq_domain *irqdomain;\n\tstruct resource *iomem_res;\n} ioapics[MAX_IO_APICS];\n\n#define mpc_ioapic_ver(ioapic_idx)\tioapics[ioapic_idx].mp_config.apicver\n\nint mpc_ioapic_id(int ioapic_idx)\n{\n\treturn ioapics[ioapic_idx].mp_config.apicid;\n}\n\nunsigned int mpc_ioapic_addr(int ioapic_idx)\n{\n\treturn ioapics[ioapic_idx].mp_config.apicaddr;\n}\n\nstatic inline struct mp_ioapic_gsi *mp_ioapic_gsi_routing(int ioapic_idx)\n{\n\treturn &ioapics[ioapic_idx].gsi_config;\n}\n\nstatic inline int mp_ioapic_pin_count(int ioapic)\n{\n\tstruct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(ioapic);\n\n\treturn gsi_cfg->gsi_end - gsi_cfg->gsi_base + 1;\n}\n\nstatic inline u32 mp_pin_to_gsi(int ioapic, int pin)\n{\n\treturn mp_ioapic_gsi_routing(ioapic)->gsi_base + pin;\n}\n\nstatic inline bool mp_is_legacy_irq(int irq)\n{\n\treturn irq >= 0 && irq < nr_legacy_irqs();\n}\n\nstatic inline struct irq_domain *mp_ioapic_irqdomain(int ioapic)\n{\n\treturn ioapics[ioapic].irqdomain;\n}\n\nint nr_ioapics;\n\n \nu32 gsi_top;\n\n \nstruct mpc_intsrc mp_irqs[MAX_IRQ_SOURCES];\n\n \nint mp_irq_entries;\n\n#ifdef CONFIG_EISA\nint mp_bus_id_to_type[MAX_MP_BUSSES];\n#endif\n\nDECLARE_BITMAP(mp_bus_not_pci, MAX_MP_BUSSES);\n\nbool ioapic_is_disabled __ro_after_init;\n\n \nvoid disable_ioapic_support(void)\n{\n#ifdef CONFIG_PCI\n\tnoioapicquirk = 1;\n\tnoioapicreroute = -1;\n#endif\n\tioapic_is_disabled = true;\n}\n\nstatic int __init parse_noapic(char *str)\n{\n\t \n\tdisable_ioapic_support();\n\treturn 0;\n}\nearly_param(\"noapic\", parse_noapic);\n\n \nvoid mp_save_irq(struct mpc_intsrc *m)\n{\n\tint i;\n\n\tapic_printk(APIC_VERBOSE, \"Int: type %d, pol %d, trig %d, bus %02x,\"\n\t\t\" IRQ %02x, APIC ID %x, APIC INT %02x\\n\",\n\t\tm->irqtype, m->irqflag & 3, (m->irqflag >> 2) & 3, m->srcbus,\n\t\tm->srcbusirq, m->dstapic, m->dstirq);\n\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tif (!memcmp(&mp_irqs[i], m, sizeof(*m)))\n\t\t\treturn;\n\t}\n\n\tmemcpy(&mp_irqs[mp_irq_entries], m, sizeof(*m));\n\tif (++mp_irq_entries == MAX_IRQ_SOURCES)\n\t\tpanic(\"Max # of irq sources exceeded!!\\n\");\n}\n\nstatic void alloc_ioapic_saved_registers(int idx)\n{\n\tsize_t size;\n\n\tif (ioapics[idx].saved_registers)\n\t\treturn;\n\n\tsize = sizeof(struct IO_APIC_route_entry) * ioapics[idx].nr_registers;\n\tioapics[idx].saved_registers = kzalloc(size, GFP_KERNEL);\n\tif (!ioapics[idx].saved_registers)\n\t\tpr_err(\"IOAPIC %d: suspend/resume impossible!\\n\", idx);\n}\n\nstatic void free_ioapic_saved_registers(int idx)\n{\n\tkfree(ioapics[idx].saved_registers);\n\tioapics[idx].saved_registers = NULL;\n}\n\nint __init arch_early_ioapic_init(void)\n{\n\tint i;\n\n\tif (!nr_legacy_irqs())\n\t\tio_apic_irqs = ~0UL;\n\n\tfor_each_ioapic(i)\n\t\talloc_ioapic_saved_registers(i);\n\n\treturn 0;\n}\n\nstruct io_apic {\n\tunsigned int index;\n\tunsigned int unused[3];\n\tunsigned int data;\n\tunsigned int unused2[11];\n\tunsigned int eoi;\n};\n\nstatic __attribute_const__ struct io_apic __iomem *io_apic_base(int idx)\n{\n\treturn (void __iomem *) __fix_to_virt(FIX_IO_APIC_BASE_0 + idx)\n\t\t+ (mpc_ioapic_addr(idx) & ~PAGE_MASK);\n}\n\nstatic inline void io_apic_eoi(unsigned int apic, unsigned int vector)\n{\n\tstruct io_apic __iomem *io_apic = io_apic_base(apic);\n\twritel(vector, &io_apic->eoi);\n}\n\nunsigned int native_io_apic_read(unsigned int apic, unsigned int reg)\n{\n\tstruct io_apic __iomem *io_apic = io_apic_base(apic);\n\twritel(reg, &io_apic->index);\n\treturn readl(&io_apic->data);\n}\n\nstatic void io_apic_write(unsigned int apic, unsigned int reg,\n\t\t\t  unsigned int value)\n{\n\tstruct io_apic __iomem *io_apic = io_apic_base(apic);\n\n\twritel(reg, &io_apic->index);\n\twritel(value, &io_apic->data);\n}\n\nstatic struct IO_APIC_route_entry __ioapic_read_entry(int apic, int pin)\n{\n\tstruct IO_APIC_route_entry entry;\n\n\tentry.w1 = io_apic_read(apic, 0x10 + 2 * pin);\n\tentry.w2 = io_apic_read(apic, 0x11 + 2 * pin);\n\n\treturn entry;\n}\n\nstatic struct IO_APIC_route_entry ioapic_read_entry(int apic, int pin)\n{\n\tstruct IO_APIC_route_entry entry;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tentry = __ioapic_read_entry(apic, pin);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\treturn entry;\n}\n\n \nstatic void __ioapic_write_entry(int apic, int pin, struct IO_APIC_route_entry e)\n{\n\tio_apic_write(apic, 0x11 + 2*pin, e.w2);\n\tio_apic_write(apic, 0x10 + 2*pin, e.w1);\n}\n\nstatic void ioapic_write_entry(int apic, int pin, struct IO_APIC_route_entry e)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t__ioapic_write_entry(apic, pin, e);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\n \nstatic void ioapic_mask_entry(int apic, int pin)\n{\n\tstruct IO_APIC_route_entry e = { .masked = true };\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tio_apic_write(apic, 0x10 + 2*pin, e.w1);\n\tio_apic_write(apic, 0x11 + 2*pin, e.w2);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\n \nstatic int __add_pin_to_irq_node(struct mp_chip_data *data,\n\t\t\t\t int node, int apic, int pin)\n{\n\tstruct irq_pin_list *entry;\n\n\t \n\tfor_each_irq_pin(entry, data->irq_2_pin)\n\t\tif (entry->apic == apic && entry->pin == pin)\n\t\t\treturn 0;\n\n\tentry = kzalloc_node(sizeof(struct irq_pin_list), GFP_ATOMIC, node);\n\tif (!entry) {\n\t\tpr_err(\"can not alloc irq_pin_list (%d,%d,%d)\\n\",\n\t\t       node, apic, pin);\n\t\treturn -ENOMEM;\n\t}\n\tentry->apic = apic;\n\tentry->pin = pin;\n\tlist_add_tail(&entry->list, &data->irq_2_pin);\n\n\treturn 0;\n}\n\nstatic void __remove_pin_from_irq(struct mp_chip_data *data, int apic, int pin)\n{\n\tstruct irq_pin_list *tmp, *entry;\n\n\tlist_for_each_entry_safe(entry, tmp, &data->irq_2_pin, list)\n\t\tif (entry->apic == apic && entry->pin == pin) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t\treturn;\n\t\t}\n}\n\nstatic void add_pin_to_irq_node(struct mp_chip_data *data,\n\t\t\t\tint node, int apic, int pin)\n{\n\tif (__add_pin_to_irq_node(data, node, apic, pin))\n\t\tpanic(\"IO-APIC: failed to add irq-pin. Can not proceed\\n\");\n}\n\n \nstatic void __init replace_pin_at_irq_node(struct mp_chip_data *data, int node,\n\t\t\t\t\t   int oldapic, int oldpin,\n\t\t\t\t\t   int newapic, int newpin)\n{\n\tstruct irq_pin_list *entry;\n\n\tfor_each_irq_pin(entry, data->irq_2_pin) {\n\t\tif (entry->apic == oldapic && entry->pin == oldpin) {\n\t\t\tentry->apic = newapic;\n\t\t\tentry->pin = newpin;\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tadd_pin_to_irq_node(data, node, newapic, newpin);\n}\n\nstatic void io_apic_modify_irq(struct mp_chip_data *data, bool masked,\n\t\t\t       void (*final)(struct irq_pin_list *entry))\n{\n\tstruct irq_pin_list *entry;\n\n\tdata->entry.masked = masked;\n\n\tfor_each_irq_pin(entry, data->irq_2_pin) {\n\t\tio_apic_write(entry->apic, 0x10 + 2 * entry->pin, data->entry.w1);\n\t\tif (final)\n\t\t\tfinal(entry);\n\t}\n}\n\nstatic void io_apic_sync(struct irq_pin_list *entry)\n{\n\t \n\tstruct io_apic __iomem *io_apic;\n\n\tio_apic = io_apic_base(entry->apic);\n\treadl(&io_apic->data);\n}\n\nstatic void mask_ioapic_irq(struct irq_data *irq_data)\n{\n\tstruct mp_chip_data *data = irq_data->chip_data;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tio_apic_modify_irq(data, true, &io_apic_sync);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\nstatic void __unmask_ioapic(struct mp_chip_data *data)\n{\n\tio_apic_modify_irq(data, false, NULL);\n}\n\nstatic void unmask_ioapic_irq(struct irq_data *irq_data)\n{\n\tstruct mp_chip_data *data = irq_data->chip_data;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t__unmask_ioapic(data);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\n \nstatic void __eoi_ioapic_pin(int apic, int pin, int vector)\n{\n\tif (mpc_ioapic_ver(apic) >= 0x20) {\n\t\tio_apic_eoi(apic, vector);\n\t} else {\n\t\tstruct IO_APIC_route_entry entry, entry1;\n\n\t\tentry = entry1 = __ioapic_read_entry(apic, pin);\n\n\t\t \n\t\tentry1.masked = true;\n\t\tentry1.is_level = false;\n\n\t\t__ioapic_write_entry(apic, pin, entry1);\n\n\t\t \n\t\t__ioapic_write_entry(apic, pin, entry);\n\t}\n}\n\nstatic void eoi_ioapic_pin(int vector, struct mp_chip_data *data)\n{\n\tunsigned long flags;\n\tstruct irq_pin_list *entry;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tfor_each_irq_pin(entry, data->irq_2_pin)\n\t\t__eoi_ioapic_pin(entry->apic, entry->pin, vector);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\nstatic void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)\n{\n\tstruct IO_APIC_route_entry entry;\n\n\t \n\tentry = ioapic_read_entry(apic, pin);\n\tif (entry.delivery_mode == APIC_DELIVERY_MODE_SMI)\n\t\treturn;\n\n\t \n\tif (!entry.masked) {\n\t\tentry.masked = true;\n\t\tioapic_write_entry(apic, pin, entry);\n\t\tentry = ioapic_read_entry(apic, pin);\n\t}\n\n\tif (entry.irr) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tif (!entry.is_level) {\n\t\t\tentry.is_level = true;\n\t\t\tioapic_write_entry(apic, pin, entry);\n\t\t}\n\t\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t\t__eoi_ioapic_pin(apic, pin, entry.vector);\n\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\t}\n\n\t \n\tioapic_mask_entry(apic, pin);\n\tentry = ioapic_read_entry(apic, pin);\n\tif (entry.irr)\n\t\tpr_err(\"Unable to reset IRR for apic: %d, pin :%d\\n\",\n\t\t       mpc_ioapic_id(apic), pin);\n}\n\nvoid clear_IO_APIC (void)\n{\n\tint apic, pin;\n\n\tfor_each_ioapic_pin(apic, pin)\n\t\tclear_IO_APIC_pin(apic, pin);\n}\n\n#ifdef CONFIG_X86_32\n \n\n#define MAX_PIRQS 8\nstatic int pirq_entries[MAX_PIRQS] = {\n\t[0 ... MAX_PIRQS - 1] = -1\n};\n\nstatic int __init ioapic_pirq_setup(char *str)\n{\n\tint i, max;\n\tint ints[MAX_PIRQS+1];\n\n\tget_options(str, ARRAY_SIZE(ints), ints);\n\n\tapic_printk(APIC_VERBOSE, KERN_INFO\n\t\t\t\"PIRQ redirection, working around broken MP-BIOS.\\n\");\n\tmax = MAX_PIRQS;\n\tif (ints[0] < MAX_PIRQS)\n\t\tmax = ints[0];\n\n\tfor (i = 0; i < max; i++) {\n\t\tapic_printk(APIC_VERBOSE, KERN_DEBUG\n\t\t\t\t\"... PIRQ%d -> IRQ %d\\n\", i, ints[i+1]);\n\t\t \n\t\tpirq_entries[MAX_PIRQS-i-1] = ints[i+1];\n\t}\n\treturn 1;\n}\n\n__setup(\"pirq=\", ioapic_pirq_setup);\n#endif  \n\n \nint save_ioapic_entries(void)\n{\n\tint apic, pin;\n\tint err = 0;\n\n\tfor_each_ioapic(apic) {\n\t\tif (!ioapics[apic].saved_registers) {\n\t\t\terr = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_pin(apic, pin)\n\t\t\tioapics[apic].saved_registers[pin] =\n\t\t\t\tioapic_read_entry(apic, pin);\n\t}\n\n\treturn err;\n}\n\n \nvoid mask_ioapic_entries(void)\n{\n\tint apic, pin;\n\n\tfor_each_ioapic(apic) {\n\t\tif (!ioapics[apic].saved_registers)\n\t\t\tcontinue;\n\n\t\tfor_each_pin(apic, pin) {\n\t\t\tstruct IO_APIC_route_entry entry;\n\n\t\t\tentry = ioapics[apic].saved_registers[pin];\n\t\t\tif (!entry.masked) {\n\t\t\t\tentry.masked = true;\n\t\t\t\tioapic_write_entry(apic, pin, entry);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint restore_ioapic_entries(void)\n{\n\tint apic, pin;\n\n\tfor_each_ioapic(apic) {\n\t\tif (!ioapics[apic].saved_registers)\n\t\t\tcontinue;\n\n\t\tfor_each_pin(apic, pin)\n\t\t\tioapic_write_entry(apic, pin,\n\t\t\t\t\t   ioapics[apic].saved_registers[pin]);\n\t}\n\treturn 0;\n}\n\n \nstatic int find_irq_entry(int ioapic_idx, int pin, int type)\n{\n\tint i;\n\n\tfor (i = 0; i < mp_irq_entries; i++)\n\t\tif (mp_irqs[i].irqtype == type &&\n\t\t    (mp_irqs[i].dstapic == mpc_ioapic_id(ioapic_idx) ||\n\t\t     mp_irqs[i].dstapic == MP_APIC_ALL) &&\n\t\t    mp_irqs[i].dstirq == pin)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\n \nstatic int __init find_isa_irq_pin(int irq, int type)\n{\n\tint i;\n\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tint lbus = mp_irqs[i].srcbus;\n\n\t\tif (test_bit(lbus, mp_bus_not_pci) &&\n\t\t    (mp_irqs[i].irqtype == type) &&\n\t\t    (mp_irqs[i].srcbusirq == irq))\n\n\t\t\treturn mp_irqs[i].dstirq;\n\t}\n\treturn -1;\n}\n\nstatic int __init find_isa_irq_apic(int irq, int type)\n{\n\tint i;\n\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tint lbus = mp_irqs[i].srcbus;\n\n\t\tif (test_bit(lbus, mp_bus_not_pci) &&\n\t\t    (mp_irqs[i].irqtype == type) &&\n\t\t    (mp_irqs[i].srcbusirq == irq))\n\t\t\tbreak;\n\t}\n\n\tif (i < mp_irq_entries) {\n\t\tint ioapic_idx;\n\n\t\tfor_each_ioapic(ioapic_idx)\n\t\t\tif (mpc_ioapic_id(ioapic_idx) == mp_irqs[i].dstapic)\n\t\t\t\treturn ioapic_idx;\n\t}\n\n\treturn -1;\n}\n\nstatic bool irq_active_low(int idx)\n{\n\tint bus = mp_irqs[idx].srcbus;\n\n\t \n\tswitch (mp_irqs[idx].irqflag & MP_IRQPOL_MASK) {\n\tcase MP_IRQPOL_DEFAULT:\n\t\t \n\t\treturn !test_bit(bus, mp_bus_not_pci);\n\tcase MP_IRQPOL_ACTIVE_HIGH:\n\t\treturn false;\n\tcase MP_IRQPOL_RESERVED:\n\t\tpr_warn(\"IOAPIC: Invalid polarity: 2, defaulting to low\\n\");\n\t\tfallthrough;\n\tcase MP_IRQPOL_ACTIVE_LOW:\n\tdefault:  \n\t\treturn true;\n\t}\n}\n\n#ifdef CONFIG_EISA\n \nstatic bool EISA_ELCR(unsigned int irq)\n{\n\tif (irq < nr_legacy_irqs()) {\n\t\tunsigned int port = PIC_ELCR1 + (irq >> 3);\n\t\treturn (inb(port) >> (irq & 7)) & 1;\n\t}\n\tapic_printk(APIC_VERBOSE, KERN_INFO\n\t\t\t\"Broken MPtable reports ISA irq %d\\n\", irq);\n\treturn false;\n}\n\n \nstatic bool eisa_irq_is_level(int idx, int bus, bool level)\n{\n\tswitch (mp_bus_id_to_type[bus]) {\n\tcase MP_BUS_PCI:\n\tcase MP_BUS_ISA:\n\t\treturn level;\n\tcase MP_BUS_EISA:\n\t\treturn EISA_ELCR(mp_irqs[idx].srcbusirq);\n\t}\n\tpr_warn(\"IOAPIC: Invalid srcbus: %d defaulting to level\\n\", bus);\n\treturn true;\n}\n#else\nstatic inline int eisa_irq_is_level(int idx, int bus, bool level)\n{\n\treturn level;\n}\n#endif\n\nstatic bool irq_is_level(int idx)\n{\n\tint bus = mp_irqs[idx].srcbus;\n\tbool level;\n\n\t \n\tswitch (mp_irqs[idx].irqflag & MP_IRQTRIG_MASK) {\n\tcase MP_IRQTRIG_DEFAULT:\n\t\t \n\t\tlevel = !test_bit(bus, mp_bus_not_pci);\n\t\t \n\t\treturn eisa_irq_is_level(idx, bus, level);\n\tcase MP_IRQTRIG_EDGE:\n\t\treturn false;\n\tcase MP_IRQTRIG_RESERVED:\n\t\tpr_warn(\"IOAPIC: Invalid trigger mode 2 defaulting to level\\n\");\n\t\tfallthrough;\n\tcase MP_IRQTRIG_LEVEL:\n\tdefault:  \n\t\treturn true;\n\t}\n}\n\nstatic int __acpi_get_override_irq(u32 gsi, bool *trigger, bool *polarity)\n{\n\tint ioapic, pin, idx;\n\n\tif (ioapic_is_disabled)\n\t\treturn -1;\n\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn -1;\n\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif (pin < 0)\n\t\treturn -1;\n\n\tidx = find_irq_entry(ioapic, pin, mp_INT);\n\tif (idx < 0)\n\t\treturn -1;\n\n\t*trigger = irq_is_level(idx);\n\t*polarity = irq_active_low(idx);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nint acpi_get_override_irq(u32 gsi, int *is_level, int *active_low)\n{\n\t*is_level = *active_low = 0;\n\treturn __acpi_get_override_irq(gsi, (bool *)is_level,\n\t\t\t\t       (bool *)active_low);\n}\n#endif\n\nvoid ioapic_set_alloc_attr(struct irq_alloc_info *info, int node,\n\t\t\t   int trigger, int polarity)\n{\n\tinit_irq_alloc_info(info, NULL);\n\tinfo->type = X86_IRQ_ALLOC_TYPE_IOAPIC;\n\tinfo->ioapic.node = node;\n\tinfo->ioapic.is_level = trigger;\n\tinfo->ioapic.active_low = polarity;\n\tinfo->ioapic.valid = 1;\n}\n\nstatic void ioapic_copy_alloc_attr(struct irq_alloc_info *dst,\n\t\t\t\t   struct irq_alloc_info *src,\n\t\t\t\t   u32 gsi, int ioapic_idx, int pin)\n{\n\tbool level, pol_low;\n\n\tcopy_irq_alloc_info(dst, src);\n\tdst->type = X86_IRQ_ALLOC_TYPE_IOAPIC;\n\tdst->devid = mpc_ioapic_id(ioapic_idx);\n\tdst->ioapic.pin = pin;\n\tdst->ioapic.valid = 1;\n\tif (src && src->ioapic.valid) {\n\t\tdst->ioapic.node = src->ioapic.node;\n\t\tdst->ioapic.is_level = src->ioapic.is_level;\n\t\tdst->ioapic.active_low = src->ioapic.active_low;\n\t} else {\n\t\tdst->ioapic.node = NUMA_NO_NODE;\n\t\tif (__acpi_get_override_irq(gsi, &level, &pol_low) >= 0) {\n\t\t\tdst->ioapic.is_level = level;\n\t\t\tdst->ioapic.active_low = pol_low;\n\t\t} else {\n\t\t\t \n\t\t\tdst->ioapic.is_level = true;\n\t\t\tdst->ioapic.active_low = true;\n\t\t}\n\t}\n}\n\nstatic int ioapic_alloc_attr_node(struct irq_alloc_info *info)\n{\n\treturn (info && info->ioapic.valid) ? info->ioapic.node : NUMA_NO_NODE;\n}\n\nstatic void mp_register_handler(unsigned int irq, bool level)\n{\n\tirq_flow_handler_t hdl;\n\tbool fasteoi;\n\n\tif (level) {\n\t\tirq_set_status_flags(irq, IRQ_LEVEL);\n\t\tfasteoi = true;\n\t} else {\n\t\tirq_clear_status_flags(irq, IRQ_LEVEL);\n\t\tfasteoi = false;\n\t}\n\n\thdl = fasteoi ? handle_fasteoi_irq : handle_edge_irq;\n\t__irq_set_handler(irq, hdl, 0, fasteoi ? \"fasteoi\" : \"edge\");\n}\n\nstatic bool mp_check_pin_attr(int irq, struct irq_alloc_info *info)\n{\n\tstruct mp_chip_data *data = irq_get_chip_data(irq);\n\n\t \n\tif (irq < nr_legacy_irqs() && data->count == 1) {\n\t\tif (info->ioapic.is_level != data->is_level)\n\t\t\tmp_register_handler(irq, info->ioapic.is_level);\n\t\tdata->entry.is_level = data->is_level = info->ioapic.is_level;\n\t\tdata->entry.active_low = data->active_low = info->ioapic.active_low;\n\t}\n\n\treturn data->is_level == info->ioapic.is_level &&\n\t       data->active_low == info->ioapic.active_low;\n}\n\nstatic int alloc_irq_from_domain(struct irq_domain *domain, int ioapic, u32 gsi,\n\t\t\t\t struct irq_alloc_info *info)\n{\n\tbool legacy = false;\n\tint irq = -1;\n\tint type = ioapics[ioapic].irqdomain_cfg.type;\n\n\tswitch (type) {\n\tcase IOAPIC_DOMAIN_LEGACY:\n\t\t \n\t\tif (!ioapic_initialized || gsi >= nr_legacy_irqs())\n\t\t\tirq = gsi;\n\t\tlegacy = mp_is_legacy_irq(irq);\n\t\tbreak;\n\tcase IOAPIC_DOMAIN_STRICT:\n\t\tirq = gsi;\n\t\tbreak;\n\tcase IOAPIC_DOMAIN_DYNAMIC:\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"ioapic: unknown irqdomain type %d\\n\", type);\n\t\treturn -1;\n\t}\n\n\treturn __irq_domain_alloc_irqs(domain, irq, 1,\n\t\t\t\t       ioapic_alloc_attr_node(info),\n\t\t\t\t       info, legacy, NULL);\n}\n\n \nstatic int alloc_isa_irq_from_domain(struct irq_domain *domain,\n\t\t\t\t     int irq, int ioapic, int pin,\n\t\t\t\t     struct irq_alloc_info *info)\n{\n\tstruct mp_chip_data *data;\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tint node = ioapic_alloc_attr_node(info);\n\n\t \n\tif (irq_data && irq_data->parent_data) {\n\t\tif (!mp_check_pin_attr(irq, info))\n\t\t\treturn -EBUSY;\n\t\tif (__add_pin_to_irq_node(irq_data->chip_data, node, ioapic,\n\t\t\t\t\t  info->ioapic.pin))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tinfo->flags |= X86_IRQ_ALLOC_LEGACY;\n\t\tirq = __irq_domain_alloc_irqs(domain, irq, 1, node, info, true,\n\t\t\t\t\t      NULL);\n\t\tif (irq >= 0) {\n\t\t\tirq_data = irq_domain_get_irq_data(domain, irq);\n\t\t\tdata = irq_data->chip_data;\n\t\t\tdata->isa_irq = true;\n\t\t}\n\t}\n\n\treturn irq;\n}\n\nstatic int mp_map_pin_to_irq(u32 gsi, int idx, int ioapic, int pin,\n\t\t\t     unsigned int flags, struct irq_alloc_info *info)\n{\n\tint irq;\n\tbool legacy = false;\n\tstruct irq_alloc_info tmp;\n\tstruct mp_chip_data *data;\n\tstruct irq_domain *domain = mp_ioapic_irqdomain(ioapic);\n\n\tif (!domain)\n\t\treturn -ENOSYS;\n\n\tif (idx >= 0 && test_bit(mp_irqs[idx].srcbus, mp_bus_not_pci)) {\n\t\tirq = mp_irqs[idx].srcbusirq;\n\t\tlegacy = mp_is_legacy_irq(irq);\n\t\t \n\t\tif (legacy && irq == PIC_CASCADE_IR)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ioapic_mutex);\n\tif (!(flags & IOAPIC_MAP_ALLOC)) {\n\t\tif (!legacy) {\n\t\t\tirq = irq_find_mapping(domain, pin);\n\t\t\tif (irq == 0)\n\t\t\t\tirq = -ENOENT;\n\t\t}\n\t} else {\n\t\tioapic_copy_alloc_attr(&tmp, info, gsi, ioapic, pin);\n\t\tif (legacy)\n\t\t\tirq = alloc_isa_irq_from_domain(domain, irq,\n\t\t\t\t\t\t\tioapic, pin, &tmp);\n\t\telse if ((irq = irq_find_mapping(domain, pin)) == 0)\n\t\t\tirq = alloc_irq_from_domain(domain, ioapic, gsi, &tmp);\n\t\telse if (!mp_check_pin_attr(irq, &tmp))\n\t\t\tirq = -EBUSY;\n\t\tif (irq >= 0) {\n\t\t\tdata = irq_get_chip_data(irq);\n\t\t\tdata->count++;\n\t\t}\n\t}\n\tmutex_unlock(&ioapic_mutex);\n\n\treturn irq;\n}\n\nstatic int pin_2_irq(int idx, int ioapic, int pin, unsigned int flags)\n{\n\tu32 gsi = mp_pin_to_gsi(ioapic, pin);\n\n\t \n\tif (mp_irqs[idx].dstirq != pin)\n\t\tpr_err(\"broken BIOS or MPTABLE parser, ayiee!!\\n\");\n\n#ifdef CONFIG_X86_32\n\t \n\tif ((pin >= 16) && (pin <= 23)) {\n\t\tif (pirq_entries[pin-16] != -1) {\n\t\t\tif (!pirq_entries[pin-16]) {\n\t\t\t\tapic_printk(APIC_VERBOSE, KERN_DEBUG\n\t\t\t\t\t\t\"disabling PIRQ%d\\n\", pin-16);\n\t\t\t} else {\n\t\t\t\tint irq = pirq_entries[pin-16];\n\t\t\t\tapic_printk(APIC_VERBOSE, KERN_DEBUG\n\t\t\t\t\t\t\"using PIRQ%d -> IRQ %d\\n\",\n\t\t\t\t\t\tpin-16, irq);\n\t\t\t\treturn irq;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\treturn  mp_map_pin_to_irq(gsi, idx, ioapic, pin, flags, NULL);\n}\n\nint mp_map_gsi_to_irq(u32 gsi, unsigned int flags, struct irq_alloc_info *info)\n{\n\tint ioapic, pin, idx;\n\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn -ENODEV;\n\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tidx = find_irq_entry(ioapic, pin, mp_INT);\n\tif ((flags & IOAPIC_MAP_CHECK) && idx < 0)\n\t\treturn -ENODEV;\n\n\treturn mp_map_pin_to_irq(gsi, idx, ioapic, pin, flags, info);\n}\n\nvoid mp_unmap_irq(int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tstruct mp_chip_data *data;\n\n\tif (!irq_data || !irq_data->domain)\n\t\treturn;\n\n\tdata = irq_data->chip_data;\n\tif (!data || data->isa_irq)\n\t\treturn;\n\n\tmutex_lock(&ioapic_mutex);\n\tif (--data->count == 0)\n\t\tirq_domain_free_irqs(irq, 1);\n\tmutex_unlock(&ioapic_mutex);\n}\n\n \nint IO_APIC_get_PCI_irq_vector(int bus, int slot, int pin)\n{\n\tint irq, i, best_ioapic = -1, best_idx = -1;\n\n\tapic_printk(APIC_DEBUG,\n\t\t    \"querying PCI -> IRQ mapping bus:%d, slot:%d, pin:%d.\\n\",\n\t\t    bus, slot, pin);\n\tif (test_bit(bus, mp_bus_not_pci)) {\n\t\tapic_printk(APIC_VERBOSE,\n\t\t\t    \"PCI BIOS passed nonexistent PCI bus %d!\\n\", bus);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tint lbus = mp_irqs[i].srcbus;\n\t\tint ioapic_idx, found = 0;\n\n\t\tif (bus != lbus || mp_irqs[i].irqtype != mp_INT ||\n\t\t    slot != ((mp_irqs[i].srcbusirq >> 2) & 0x1f))\n\t\t\tcontinue;\n\n\t\tfor_each_ioapic(ioapic_idx)\n\t\t\tif (mpc_ioapic_id(ioapic_idx) == mp_irqs[i].dstapic ||\n\t\t\t    mp_irqs[i].dstapic == MP_APIC_ALL) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\t \n\t\tirq = pin_2_irq(i, ioapic_idx, mp_irqs[i].dstirq, 0);\n\t\tif (irq > 0 && !IO_APIC_IRQ(irq))\n\t\t\tcontinue;\n\n\t\tif (pin == (mp_irqs[i].srcbusirq & 3)) {\n\t\t\tbest_idx = i;\n\t\t\tbest_ioapic = ioapic_idx;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (best_idx < 0) {\n\t\t\tbest_idx = i;\n\t\t\tbest_ioapic = ioapic_idx;\n\t\t}\n\t}\n\tif (best_idx < 0)\n\t\treturn -1;\n\nout:\n\treturn pin_2_irq(best_idx, best_ioapic, mp_irqs[best_idx].dstirq,\n\t\t\t IOAPIC_MAP_ALLOC);\n}\nEXPORT_SYMBOL(IO_APIC_get_PCI_irq_vector);\n\nstatic struct irq_chip ioapic_chip, ioapic_ir_chip;\n\nstatic void __init setup_IO_APIC_irqs(void)\n{\n\tunsigned int ioapic, pin;\n\tint idx;\n\n\tapic_printk(APIC_VERBOSE, KERN_DEBUG \"init IO_APIC IRQs\\n\");\n\n\tfor_each_ioapic_pin(ioapic, pin) {\n\t\tidx = find_irq_entry(ioapic, pin, mp_INT);\n\t\tif (idx < 0)\n\t\t\tapic_printk(APIC_VERBOSE,\n\t\t\t\t    KERN_DEBUG \" apic %d pin %d not connected\\n\",\n\t\t\t\t    mpc_ioapic_id(ioapic), pin);\n\t\telse\n\t\t\tpin_2_irq(idx, ioapic, pin,\n\t\t\t\t  ioapic ? 0 : IOAPIC_MAP_ALLOC);\n\t}\n}\n\nvoid ioapic_zap_locks(void)\n{\n\traw_spin_lock_init(&ioapic_lock);\n}\n\nstatic void io_apic_print_entries(unsigned int apic, unsigned int nr_entries)\n{\n\tstruct IO_APIC_route_entry entry;\n\tchar buf[256];\n\tint i;\n\n\tprintk(KERN_DEBUG \"IOAPIC %d:\\n\", apic);\n\tfor (i = 0; i <= nr_entries; i++) {\n\t\tentry = ioapic_read_entry(apic, i);\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \" pin%02x, %s, %s, %s, V(%02X), IRR(%1d), S(%1d)\",\n\t\t\t i,\n\t\t\t entry.masked ? \"disabled\" : \"enabled \",\n\t\t\t entry.is_level ? \"level\" : \"edge \",\n\t\t\t entry.active_low ? \"low \" : \"high\",\n\t\t\t entry.vector, entry.irr, entry.delivery_status);\n\t\tif (entry.ir_format) {\n\t\t\tprintk(KERN_DEBUG \"%s, remapped, I(%04X),  Z(%X)\\n\",\n\t\t\t       buf,\n\t\t\t       (entry.ir_index_15 << 15) | entry.ir_index_0_14,\n\t\t\t\tentry.ir_zero);\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"%s, %s, D(%02X%02X), M(%1d)\\n\", buf,\n\t\t\t       entry.dest_mode_logical ? \"logical \" : \"physical\",\n\t\t\t       entry.virt_destid_8_14, entry.destid_0_7,\n\t\t\t       entry.delivery_mode);\n\t\t}\n\t}\n}\n\nstatic void __init print_IO_APIC(int ioapic_idx)\n{\n\tunion IO_APIC_reg_00 reg_00;\n\tunion IO_APIC_reg_01 reg_01;\n\tunion IO_APIC_reg_02 reg_02;\n\tunion IO_APIC_reg_03 reg_03;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_00.raw = io_apic_read(ioapic_idx, 0);\n\treg_01.raw = io_apic_read(ioapic_idx, 1);\n\tif (reg_01.bits.version >= 0x10)\n\t\treg_02.raw = io_apic_read(ioapic_idx, 2);\n\tif (reg_01.bits.version >= 0x20)\n\t\treg_03.raw = io_apic_read(ioapic_idx, 3);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\tprintk(KERN_DEBUG \"IO APIC #%d......\\n\", mpc_ioapic_id(ioapic_idx));\n\tprintk(KERN_DEBUG \".... register #00: %08X\\n\", reg_00.raw);\n\tprintk(KERN_DEBUG \".......    : physical APIC id: %02X\\n\", reg_00.bits.ID);\n\tprintk(KERN_DEBUG \".......    : Delivery Type: %X\\n\", reg_00.bits.delivery_type);\n\tprintk(KERN_DEBUG \".......    : LTS          : %X\\n\", reg_00.bits.LTS);\n\n\tprintk(KERN_DEBUG \".... register #01: %08X\\n\", *(int *)&reg_01);\n\tprintk(KERN_DEBUG \".......     : max redirection entries: %02X\\n\",\n\t\treg_01.bits.entries);\n\n\tprintk(KERN_DEBUG \".......     : PRQ implemented: %X\\n\", reg_01.bits.PRQ);\n\tprintk(KERN_DEBUG \".......     : IO APIC version: %02X\\n\",\n\t\treg_01.bits.version);\n\n\t \n\tif (reg_01.bits.version >= 0x10 && reg_02.raw != reg_01.raw) {\n\t\tprintk(KERN_DEBUG \".... register #02: %08X\\n\", reg_02.raw);\n\t\tprintk(KERN_DEBUG \".......     : arbitration: %02X\\n\", reg_02.bits.arbitration);\n\t}\n\n\t \n\tif (reg_01.bits.version >= 0x20 && reg_03.raw != reg_02.raw &&\n\t    reg_03.raw != reg_01.raw) {\n\t\tprintk(KERN_DEBUG \".... register #03: %08X\\n\", reg_03.raw);\n\t\tprintk(KERN_DEBUG \".......     : Boot DT    : %X\\n\", reg_03.bits.boot_DT);\n\t}\n\n\tprintk(KERN_DEBUG \".... IRQ redirection table:\\n\");\n\tio_apic_print_entries(ioapic_idx, reg_01.bits.entries);\n}\n\nvoid __init print_IO_APICs(void)\n{\n\tint ioapic_idx;\n\tunsigned int irq;\n\n\tprintk(KERN_DEBUG \"number of MP IRQ sources: %d.\\n\", mp_irq_entries);\n\tfor_each_ioapic(ioapic_idx)\n\t\tprintk(KERN_DEBUG \"number of IO-APIC #%d registers: %d.\\n\",\n\t\t       mpc_ioapic_id(ioapic_idx),\n\t\t       ioapics[ioapic_idx].nr_registers);\n\n\t \n\tprintk(KERN_INFO \"testing the IO APIC.......................\\n\");\n\n\tfor_each_ioapic(ioapic_idx)\n\t\tprint_IO_APIC(ioapic_idx);\n\n\tprintk(KERN_DEBUG \"IRQ to pin mappings:\\n\");\n\tfor_each_active_irq(irq) {\n\t\tstruct irq_pin_list *entry;\n\t\tstruct irq_chip *chip;\n\t\tstruct mp_chip_data *data;\n\n\t\tchip = irq_get_chip(irq);\n\t\tif (chip != &ioapic_chip && chip != &ioapic_ir_chip)\n\t\t\tcontinue;\n\t\tdata = irq_get_chip_data(irq);\n\t\tif (!data)\n\t\t\tcontinue;\n\t\tif (list_empty(&data->irq_2_pin))\n\t\t\tcontinue;\n\n\t\tprintk(KERN_DEBUG \"IRQ%d \", irq);\n\t\tfor_each_irq_pin(entry, data->irq_2_pin)\n\t\t\tpr_cont(\"-> %d:%d\", entry->apic, entry->pin);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tprintk(KERN_INFO \".................................... done.\\n\");\n}\n\n \nstatic struct { int pin, apic; } ioapic_i8259 = { -1, -1 };\n\nvoid __init enable_IO_APIC(void)\n{\n\tint i8259_apic, i8259_pin;\n\tint apic, pin;\n\n\tif (ioapic_is_disabled)\n\t\tnr_ioapics = 0;\n\n\tif (!nr_legacy_irqs() || !nr_ioapics)\n\t\treturn;\n\n\tfor_each_ioapic_pin(apic, pin) {\n\t\t \n\t\tstruct IO_APIC_route_entry entry = ioapic_read_entry(apic, pin);\n\n\t\t \n\t\tif (!entry.masked &&\n\t\t    entry.delivery_mode == APIC_DELIVERY_MODE_EXTINT) {\n\t\t\tioapic_i8259.apic = apic;\n\t\t\tioapic_i8259.pin  = pin;\n\t\t\tgoto found_i8259;\n\t\t}\n\t}\n found_i8259:\n\t \n\t \n\ti8259_pin  = find_isa_irq_pin(0, mp_ExtINT);\n\ti8259_apic = find_isa_irq_apic(0, mp_ExtINT);\n\t \n\tif ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {\n\t\tprintk(KERN_WARNING \"ExtINT not setup in hardware but reported by MP table\\n\");\n\t\tioapic_i8259.pin  = i8259_pin;\n\t\tioapic_i8259.apic = i8259_apic;\n\t}\n\t \n\tif (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&\n\t\t(i8259_pin >= 0) && (ioapic_i8259.pin >= 0))\n\t{\n\t\tprintk(KERN_WARNING \"ExtINT in hardware and MP table differ\\n\");\n\t}\n\n\t \n\tclear_IO_APIC();\n}\n\nvoid native_restore_boot_irq_mode(void)\n{\n\t \n\tif (ioapic_i8259.pin != -1) {\n\t\tstruct IO_APIC_route_entry entry;\n\t\tu32 apic_id = read_apic_id();\n\n\t\tmemset(&entry, 0, sizeof(entry));\n\t\tentry.masked\t\t= false;\n\t\tentry.is_level\t\t= false;\n\t\tentry.active_low\t= false;\n\t\tentry.dest_mode_logical\t= false;\n\t\tentry.delivery_mode\t= APIC_DELIVERY_MODE_EXTINT;\n\t\tentry.destid_0_7\t= apic_id & 0xFF;\n\t\tentry.virt_destid_8_14\t= apic_id >> 8;\n\n\t\t \n\t\tioapic_write_entry(ioapic_i8259.apic, ioapic_i8259.pin, entry);\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_APIC) || apic_from_smp_config())\n\t\tdisconnect_bsp_APIC(ioapic_i8259.pin != -1);\n}\n\nvoid restore_boot_irq_mode(void)\n{\n\tif (!nr_legacy_irqs())\n\t\treturn;\n\n\tx86_apic_ops.restore();\n}\n\n#ifdef CONFIG_X86_32\n \nvoid __init setup_ioapic_ids_from_mpc_nocheck(void)\n{\n\tunion IO_APIC_reg_00 reg_00;\n\tphysid_mask_t phys_id_present_map;\n\tint ioapic_idx;\n\tint i;\n\tunsigned char old_id;\n\tunsigned long flags;\n\n\t \n\tapic->ioapic_phys_id_map(&phys_cpu_present_map, &phys_id_present_map);\n\n\t \n\tfor_each_ioapic(ioapic_idx) {\n\t\t \n\t\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t\treg_00.raw = io_apic_read(ioapic_idx, 0);\n\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\t\told_id = mpc_ioapic_id(ioapic_idx);\n\n\t\tif (mpc_ioapic_id(ioapic_idx) >= get_physical_broadcast()) {\n\t\t\tprintk(KERN_ERR \"BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\\n\",\n\t\t\t\tioapic_idx, mpc_ioapic_id(ioapic_idx));\n\t\t\tprintk(KERN_ERR \"... fixing up to %d. (tell your hw vendor)\\n\",\n\t\t\t\treg_00.bits.ID);\n\t\t\tioapics[ioapic_idx].mp_config.apicid = reg_00.bits.ID;\n\t\t}\n\n\t\t \n\t\tif (apic->check_apicid_used(&phys_id_present_map,\n\t\t\t\t\t    mpc_ioapic_id(ioapic_idx))) {\n\t\t\tprintk(KERN_ERR \"BIOS bug, IO-APIC#%d ID %d is already used!...\\n\",\n\t\t\t\tioapic_idx, mpc_ioapic_id(ioapic_idx));\n\t\t\tfor (i = 0; i < get_physical_broadcast(); i++)\n\t\t\t\tif (!physid_isset(i, phys_id_present_map))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= get_physical_broadcast())\n\t\t\t\tpanic(\"Max APIC ID exceeded!\\n\");\n\t\t\tprintk(KERN_ERR \"... fixing up to %d. (tell your hw vendor)\\n\",\n\t\t\t\ti);\n\t\t\tphysid_set(i, phys_id_present_map);\n\t\t\tioapics[ioapic_idx].mp_config.apicid = i;\n\t\t} else {\n\t\t\tapic_printk(APIC_VERBOSE, \"Setting %d in the phys_id_present_map\\n\",\n\t\t\t\t    mpc_ioapic_id(ioapic_idx));\n\t\t\tphysid_set(mpc_ioapic_id(ioapic_idx), phys_id_present_map);\n\t\t}\n\n\t\t \n\t\tif (old_id != mpc_ioapic_id(ioapic_idx))\n\t\t\tfor (i = 0; i < mp_irq_entries; i++)\n\t\t\t\tif (mp_irqs[i].dstapic == old_id)\n\t\t\t\t\tmp_irqs[i].dstapic\n\t\t\t\t\t\t= mpc_ioapic_id(ioapic_idx);\n\n\t\t \n\t\tif (mpc_ioapic_id(ioapic_idx) == reg_00.bits.ID)\n\t\t\tcontinue;\n\n\t\tapic_printk(APIC_VERBOSE, KERN_INFO\n\t\t\t\"...changing IO-APIC physical APIC ID to %d ...\",\n\t\t\tmpc_ioapic_id(ioapic_idx));\n\n\t\treg_00.bits.ID = mpc_ioapic_id(ioapic_idx);\n\t\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t\tio_apic_write(ioapic_idx, 0, reg_00.raw);\n\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\t\t \n\t\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t\treg_00.raw = io_apic_read(ioapic_idx, 0);\n\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\t\tif (reg_00.bits.ID != mpc_ioapic_id(ioapic_idx))\n\t\t\tpr_cont(\"could not set ID!\\n\");\n\t\telse\n\t\t\tapic_printk(APIC_VERBOSE, \" ok.\\n\");\n\t}\n}\n\nvoid __init setup_ioapic_ids_from_mpc(void)\n{\n\n\tif (acpi_ioapic)\n\t\treturn;\n\t \n\tif (!(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)\n\t\t|| APIC_XAPIC(boot_cpu_apic_version))\n\t\treturn;\n\tsetup_ioapic_ids_from_mpc_nocheck();\n}\n#endif\n\nint no_timer_check __initdata;\n\nstatic int __init notimercheck(char *s)\n{\n\tno_timer_check = 1;\n\treturn 1;\n}\n__setup(\"no_timer_check\", notimercheck);\n\nstatic void __init delay_with_tsc(void)\n{\n\tunsigned long long start, now;\n\tunsigned long end = jiffies + 4;\n\n\tstart = rdtsc();\n\n\t \n\tdo {\n\t\trep_nop();\n\t\tnow = rdtsc();\n\t} while ((now - start) < 40000000000ULL / HZ &&\n\t\ttime_before_eq(jiffies, end));\n}\n\nstatic void __init delay_without_tsc(void)\n{\n\tunsigned long end = jiffies + 4;\n\tint band = 1;\n\n\t \n\tdo {\n\t\t__delay(((1U << band++) * 10000000UL) / HZ);\n\t} while (band < 12 && time_before_eq(jiffies, end));\n}\n\n \nstatic int __init timer_irq_works(void)\n{\n\tunsigned long t1 = jiffies;\n\n\tif (no_timer_check)\n\t\treturn 1;\n\n\tlocal_irq_enable();\n\tif (boot_cpu_has(X86_FEATURE_TSC))\n\t\tdelay_with_tsc();\n\telse\n\t\tdelay_without_tsc();\n\n\t \n\n\tlocal_irq_disable();\n\n\t \n\treturn time_after(jiffies, t1 + 4);\n}\n\n \n \n\n \nstatic unsigned int startup_ioapic_irq(struct irq_data *data)\n{\n\tint was_pending = 0, irq = data->irq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tif (irq < nr_legacy_irqs()) {\n\t\tlegacy_pic->mask(irq);\n\t\tif (legacy_pic->irq_pending(irq))\n\t\t\twas_pending = 1;\n\t}\n\t__unmask_ioapic(data->chip_data);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\treturn was_pending;\n}\n\natomic_t irq_mis_count;\n\n#ifdef CONFIG_GENERIC_PENDING_IRQ\nstatic bool io_apic_level_ack_pending(struct mp_chip_data *data)\n{\n\tstruct irq_pin_list *entry;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tfor_each_irq_pin(entry, data->irq_2_pin) {\n\t\tstruct IO_APIC_route_entry e;\n\t\tint pin;\n\n\t\tpin = entry->pin;\n\t\te.w1 = io_apic_read(entry->apic, 0x10 + pin*2);\n\t\t \n\t\tif (e.irr) {\n\t\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\t\t\treturn true;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\treturn false;\n}\n\nstatic inline bool ioapic_prepare_move(struct irq_data *data)\n{\n\t \n\tif (unlikely(irqd_is_setaffinity_pending(data))) {\n\t\tif (!irqd_irq_masked(data))\n\t\t\tmask_ioapic_irq(data);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void ioapic_finish_move(struct irq_data *data, bool moveit)\n{\n\tif (unlikely(moveit)) {\n\t\t \n\t\tif (!io_apic_level_ack_pending(data->chip_data))\n\t\t\tirq_move_masked_irq(data);\n\t\t \n\t\tif (!irqd_irq_masked(data))\n\t\t\tunmask_ioapic_irq(data);\n\t}\n}\n#else\nstatic inline bool ioapic_prepare_move(struct irq_data *data)\n{\n\treturn false;\n}\nstatic inline void ioapic_finish_move(struct irq_data *data, bool moveit)\n{\n}\n#endif\n\nstatic void ioapic_ack_level(struct irq_data *irq_data)\n{\n\tstruct irq_cfg *cfg = irqd_cfg(irq_data);\n\tunsigned long v;\n\tbool moveit;\n\tint i;\n\n\tirq_complete_move(cfg);\n\tmoveit = ioapic_prepare_move(irq_data);\n\n\t \n\ti = cfg->vector;\n\tv = apic_read(APIC_TMR + ((i & ~0x1f) >> 1));\n\n\t \n\tapic_eoi();\n\n\t \n\tif (!(v & (1 << (i & 0x1f)))) {\n\t\tatomic_inc(&irq_mis_count);\n\t\teoi_ioapic_pin(cfg->vector, irq_data->chip_data);\n\t}\n\n\tioapic_finish_move(irq_data, moveit);\n}\n\nstatic void ioapic_ir_ack_level(struct irq_data *irq_data)\n{\n\tstruct mp_chip_data *data = irq_data->chip_data;\n\n\t \n\tapic_ack_irq(irq_data);\n\teoi_ioapic_pin(data->entry.vector, data);\n}\n\n \nstatic void ioapic_setup_msg_from_msi(struct irq_data *irq_data,\n\t\t\t\t      struct IO_APIC_route_entry *entry)\n{\n\tstruct msi_msg msg;\n\n\t \n\tirq_chip_compose_msi_msg(irq_data, &msg);\n\n\t \n\tentry->vector\t\t\t= msg.arch_data.vector;\n\t \n\tentry->delivery_mode\t\t= msg.arch_data.delivery_mode;\n\t \n\tentry->dest_mode_logical\t= msg.arch_addr_lo.dest_mode_logical;\n\t \n\tentry->ir_format\t\t= msg.arch_addr_lo.dmar_format;\n\t \n\tentry->ir_index_0_14\t\t= msg.arch_addr_lo.dmar_index_0_14;\n}\n\nstatic void ioapic_configure_entry(struct irq_data *irqd)\n{\n\tstruct mp_chip_data *mpd = irqd->chip_data;\n\tstruct irq_pin_list *entry;\n\n\tioapic_setup_msg_from_msi(irqd, &mpd->entry);\n\n\tfor_each_irq_pin(entry, mpd->irq_2_pin)\n\t\t__ioapic_write_entry(entry->apic, entry->pin, mpd->entry);\n}\n\nstatic int ioapic_set_affinity(struct irq_data *irq_data,\n\t\t\t       const struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = irq_data->parent_data;\n\tunsigned long flags;\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tif (ret >= 0 && ret != IRQ_SET_MASK_OK_DONE)\n\t\tioapic_configure_entry(irq_data);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int ioapic_irq_get_chip_state(struct irq_data *irqd,\n\t\t\t\t   enum irqchip_irq_state which,\n\t\t\t\t   bool *state)\n{\n\tstruct mp_chip_data *mcd = irqd->chip_data;\n\tstruct IO_APIC_route_entry rentry;\n\tstruct irq_pin_list *p;\n\n\tif (which != IRQCHIP_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\t*state = false;\n\traw_spin_lock(&ioapic_lock);\n\tfor_each_irq_pin(p, mcd->irq_2_pin) {\n\t\trentry = __ioapic_read_entry(p->apic, p->pin);\n\t\t \n\t\tif (rentry.irr && rentry.is_level) {\n\t\t\t*state = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock(&ioapic_lock);\n\treturn 0;\n}\n\nstatic struct irq_chip ioapic_chip __read_mostly = {\n\t.name\t\t\t= \"IO-APIC\",\n\t.irq_startup\t\t= startup_ioapic_irq,\n\t.irq_mask\t\t= mask_ioapic_irq,\n\t.irq_unmask\t\t= unmask_ioapic_irq,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_eoi\t\t= ioapic_ack_level,\n\t.irq_set_affinity\t= ioapic_set_affinity,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_get_irqchip_state\t= ioapic_irq_get_chip_state,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_AFFINITY_PRE_STARTUP,\n};\n\nstatic struct irq_chip ioapic_ir_chip __read_mostly = {\n\t.name\t\t\t= \"IR-IO-APIC\",\n\t.irq_startup\t\t= startup_ioapic_irq,\n\t.irq_mask\t\t= mask_ioapic_irq,\n\t.irq_unmask\t\t= unmask_ioapic_irq,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_eoi\t\t= ioapic_ir_ack_level,\n\t.irq_set_affinity\t= ioapic_set_affinity,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_get_irqchip_state\t= ioapic_irq_get_chip_state,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_AFFINITY_PRE_STARTUP,\n};\n\nstatic inline void init_IO_APIC_traps(void)\n{\n\tstruct irq_cfg *cfg;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tcfg = irq_cfg(irq);\n\t\tif (IO_APIC_IRQ(irq) && cfg && !cfg->vector) {\n\t\t\t \n\t\t\tif (irq < nr_legacy_irqs())\n\t\t\t\tlegacy_pic->make_irq(irq);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tirq_set_chip(irq, &no_irq_chip);\n\t\t}\n\t}\n}\n\n \n\nstatic void mask_lapic_irq(struct irq_data *data)\n{\n\tunsigned long v;\n\n\tv = apic_read(APIC_LVT0);\n\tapic_write(APIC_LVT0, v | APIC_LVT_MASKED);\n}\n\nstatic void unmask_lapic_irq(struct irq_data *data)\n{\n\tunsigned long v;\n\n\tv = apic_read(APIC_LVT0);\n\tapic_write(APIC_LVT0, v & ~APIC_LVT_MASKED);\n}\n\nstatic void ack_lapic_irq(struct irq_data *data)\n{\n\tapic_eoi();\n}\n\nstatic struct irq_chip lapic_chip __read_mostly = {\n\t.name\t\t= \"local-APIC\",\n\t.irq_mask\t= mask_lapic_irq,\n\t.irq_unmask\t= unmask_lapic_irq,\n\t.irq_ack\t= ack_lapic_irq,\n};\n\nstatic void lapic_register_intr(int irq)\n{\n\tirq_clear_status_flags(irq, IRQ_LEVEL);\n\tirq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,\n\t\t\t\t      \"edge\");\n}\n\n \nstatic inline void __init unlock_ExtINT_logic(void)\n{\n\tint apic, pin, i;\n\tstruct IO_APIC_route_entry entry0, entry1;\n\tunsigned char save_control, save_freq_select;\n\tu32 apic_id;\n\n\tpin  = find_isa_irq_pin(8, mp_INT);\n\tif (pin == -1) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\tapic = find_isa_irq_apic(8, mp_INT);\n\tif (apic == -1) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tentry0 = ioapic_read_entry(apic, pin);\n\tclear_IO_APIC_pin(apic, pin);\n\n\tapic_id = read_apic_id();\n\tmemset(&entry1, 0, sizeof(entry1));\n\n\tentry1.dest_mode_logical\t= true;\n\tentry1.masked\t\t\t= false;\n\tentry1.destid_0_7\t\t= apic_id & 0xFF;\n\tentry1.virt_destid_8_14\t\t= apic_id >> 8;\n\tentry1.delivery_mode\t\t= APIC_DELIVERY_MODE_EXTINT;\n\tentry1.active_low\t\t= entry0.active_low;\n\tentry1.is_level\t\t\t= false;\n\tentry1.vector = 0;\n\n\tioapic_write_entry(apic, pin, entry1);\n\n\tsave_control = CMOS_READ(RTC_CONTROL);\n\tsave_freq_select = CMOS_READ(RTC_FREQ_SELECT);\n\tCMOS_WRITE((save_freq_select & ~RTC_RATE_SELECT) | 0x6,\n\t\t   RTC_FREQ_SELECT);\n\tCMOS_WRITE(save_control | RTC_PIE, RTC_CONTROL);\n\n\ti = 100;\n\twhile (i-- > 0) {\n\t\tmdelay(10);\n\t\tif ((CMOS_READ(RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)\n\t\t\ti -= 10;\n\t}\n\n\tCMOS_WRITE(save_control, RTC_CONTROL);\n\tCMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);\n\tclear_IO_APIC_pin(apic, pin);\n\n\tioapic_write_entry(apic, pin, entry0);\n}\n\nstatic int disable_timer_pin_1 __initdata;\n \nstatic int __init disable_timer_pin_setup(char *arg)\n{\n\tdisable_timer_pin_1 = 1;\n\treturn 0;\n}\nearly_param(\"disable_timer_pin_1\", disable_timer_pin_setup);\n\nstatic int mp_alloc_timer_irq(int ioapic, int pin)\n{\n\tint irq = -1;\n\tstruct irq_domain *domain = mp_ioapic_irqdomain(ioapic);\n\n\tif (domain) {\n\t\tstruct irq_alloc_info info;\n\n\t\tioapic_set_alloc_attr(&info, NUMA_NO_NODE, 0, 0);\n\t\tinfo.devid = mpc_ioapic_id(ioapic);\n\t\tinfo.ioapic.pin = pin;\n\t\tmutex_lock(&ioapic_mutex);\n\t\tirq = alloc_isa_irq_from_domain(domain, 0, ioapic, pin, &info);\n\t\tmutex_unlock(&ioapic_mutex);\n\t}\n\n\treturn irq;\n}\n\n \nstatic inline void __init check_timer(void)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(0);\n\tstruct mp_chip_data *data = irq_data->chip_data;\n\tstruct irq_cfg *cfg = irqd_cfg(irq_data);\n\tint node = cpu_to_node(0);\n\tint apic1, pin1, apic2, pin2;\n\tint no_pin1 = 0;\n\n\tif (!global_clock_event)\n\t\treturn;\n\n\tlocal_irq_disable();\n\n\t \n\tlegacy_pic->mask(0);\n\n\t \n\tapic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);\n\tlegacy_pic->init(1);\n\n\tpin1  = find_isa_irq_pin(0, mp_INT);\n\tapic1 = find_isa_irq_apic(0, mp_INT);\n\tpin2  = ioapic_i8259.pin;\n\tapic2 = ioapic_i8259.apic;\n\n\tapic_printk(APIC_QUIET, KERN_INFO \"..TIMER: vector=0x%02X \"\n\t\t    \"apic1=%d pin1=%d apic2=%d pin2=%d\\n\",\n\t\t    cfg->vector, apic1, pin1, apic2, pin2);\n\n\t \n\tif (pin1 == -1) {\n\t\tpanic_if_irq_remap(\"BIOS bug: timer not connected to IO-APIC\");\n\t\tpin1 = pin2;\n\t\tapic1 = apic2;\n\t\tno_pin1 = 1;\n\t} else if (pin2 == -1) {\n\t\tpin2 = pin1;\n\t\tapic2 = apic1;\n\t}\n\n\tif (pin1 != -1) {\n\t\t \n\t\tif (no_pin1) {\n\t\t\tmp_alloc_timer_irq(apic1, pin1);\n\t\t} else {\n\t\t\t \n\t\t\tint idx = find_irq_entry(apic1, pin1, mp_INT);\n\n\t\t\tif (idx != -1 && irq_is_level(idx))\n\t\t\t\tunmask_ioapic_irq(irq_get_irq_data(0));\n\t\t}\n\t\tirq_domain_deactivate_irq(irq_data);\n\t\tirq_domain_activate_irq(irq_data, false);\n\t\tif (timer_irq_works()) {\n\t\t\tif (disable_timer_pin_1 > 0)\n\t\t\t\tclear_IO_APIC_pin(0, pin1);\n\t\t\tgoto out;\n\t\t}\n\t\tpanic_if_irq_remap(\"timer doesn't work through Interrupt-remapped IO-APIC\");\n\t\tclear_IO_APIC_pin(apic1, pin1);\n\t\tif (!no_pin1)\n\t\t\tapic_printk(APIC_QUIET, KERN_ERR \"..MP-BIOS bug: \"\n\t\t\t\t    \"8254 timer not connected to IO-APIC\\n\");\n\n\t\tapic_printk(APIC_QUIET, KERN_INFO \"...trying to set up timer \"\n\t\t\t    \"(IRQ0) through the 8259A ...\\n\");\n\t\tapic_printk(APIC_QUIET, KERN_INFO\n\t\t\t    \"..... (found apic %d pin %d) ...\\n\", apic2, pin2);\n\t\t \n\t\treplace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);\n\t\tirq_domain_deactivate_irq(irq_data);\n\t\tirq_domain_activate_irq(irq_data, false);\n\t\tlegacy_pic->unmask(0);\n\t\tif (timer_irq_works()) {\n\t\t\tapic_printk(APIC_QUIET, KERN_INFO \"....... works.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlegacy_pic->mask(0);\n\t\tclear_IO_APIC_pin(apic2, pin2);\n\t\tapic_printk(APIC_QUIET, KERN_INFO \"....... failed.\\n\");\n\t}\n\n\tapic_printk(APIC_QUIET, KERN_INFO\n\t\t    \"...trying to set up timer as Virtual Wire IRQ...\\n\");\n\n\tlapic_register_intr(0);\n\tapic_write(APIC_LVT0, APIC_DM_FIXED | cfg->vector);\t \n\tlegacy_pic->unmask(0);\n\n\tif (timer_irq_works()) {\n\t\tapic_printk(APIC_QUIET, KERN_INFO \"..... works.\\n\");\n\t\tgoto out;\n\t}\n\tlegacy_pic->mask(0);\n\tapic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | cfg->vector);\n\tapic_printk(APIC_QUIET, KERN_INFO \"..... failed.\\n\");\n\n\tapic_printk(APIC_QUIET, KERN_INFO\n\t\t    \"...trying to set up timer as ExtINT IRQ...\\n\");\n\n\tlegacy_pic->init(0);\n\tlegacy_pic->make_irq(0);\n\tapic_write(APIC_LVT0, APIC_DM_EXTINT);\n\tlegacy_pic->unmask(0);\n\n\tunlock_ExtINT_logic();\n\n\tif (timer_irq_works()) {\n\t\tapic_printk(APIC_QUIET, KERN_INFO \"..... works.\\n\");\n\t\tgoto out;\n\t}\n\tapic_printk(APIC_QUIET, KERN_INFO \"..... failed :(.\\n\");\n\tif (apic_is_x2apic_enabled())\n\t\tapic_printk(APIC_QUIET, KERN_INFO\n\t\t\t    \"Perhaps problem with the pre-enabled x2apic mode\\n\"\n\t\t\t    \"Try booting with x2apic and interrupt-remapping disabled in the bios.\\n\");\n\tpanic(\"IO-APIC + timer doesn't work!  Boot with apic=debug and send a \"\n\t\t\"report.  Then try booting with the 'noapic' option.\\n\");\nout:\n\tlocal_irq_enable();\n}\n\n \n#define PIC_IRQS\t(1UL << PIC_CASCADE_IR)\n\nstatic int mp_irqdomain_create(int ioapic)\n{\n\tstruct irq_domain *parent;\n\tint hwirqs = mp_ioapic_pin_count(ioapic);\n\tstruct ioapic *ip = &ioapics[ioapic];\n\tstruct ioapic_domain_cfg *cfg = &ip->irqdomain_cfg;\n\tstruct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(ioapic);\n\tstruct fwnode_handle *fn;\n\tstruct irq_fwspec fwspec;\n\n\tif (cfg->type == IOAPIC_DOMAIN_INVALID)\n\t\treturn 0;\n\n\t \n\tif (cfg->dev) {\n\t\tfn = of_node_to_fwnode(cfg->dev);\n\t} else {\n\t\tfn = irq_domain_alloc_named_id_fwnode(\"IO-APIC\", mpc_ioapic_id(ioapic));\n\t\tif (!fn)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfwspec.fwnode = fn;\n\tfwspec.param_count = 1;\n\tfwspec.param[0] = mpc_ioapic_id(ioapic);\n\n\tparent = irq_find_matching_fwspec(&fwspec, DOMAIN_BUS_ANY);\n\tif (!parent) {\n\t\tif (!cfg->dev)\n\t\t\tirq_domain_free_fwnode(fn);\n\t\treturn -ENODEV;\n\t}\n\n\tip->irqdomain = irq_domain_create_hierarchy(parent, 0, hwirqs, fn, cfg->ops,\n\t\t\t\t\t\t    (void *)(long)ioapic);\n\tif (!ip->irqdomain) {\n\t\t \n\t\tif (!cfg->dev)\n\t\t\tirq_domain_free_fwnode(fn);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cfg->type == IOAPIC_DOMAIN_LEGACY ||\n\t    cfg->type == IOAPIC_DOMAIN_STRICT)\n\t\tioapic_dynirq_base = max(ioapic_dynirq_base,\n\t\t\t\t\t gsi_cfg->gsi_end + 1);\n\n\treturn 0;\n}\n\nstatic void ioapic_destroy_irqdomain(int idx)\n{\n\tstruct ioapic_domain_cfg *cfg = &ioapics[idx].irqdomain_cfg;\n\tstruct fwnode_handle *fn = ioapics[idx].irqdomain->fwnode;\n\n\tif (ioapics[idx].irqdomain) {\n\t\tirq_domain_remove(ioapics[idx].irqdomain);\n\t\tif (!cfg->dev)\n\t\t\tirq_domain_free_fwnode(fn);\n\t\tioapics[idx].irqdomain = NULL;\n\t}\n}\n\nvoid __init setup_IO_APIC(void)\n{\n\tint ioapic;\n\n\tif (ioapic_is_disabled || !nr_ioapics)\n\t\treturn;\n\n\tio_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;\n\n\tapic_printk(APIC_VERBOSE, \"ENABLING IO-APIC IRQs\\n\");\n\tfor_each_ioapic(ioapic)\n\t\tBUG_ON(mp_irqdomain_create(ioapic));\n\n\t \n\tx86_init.mpparse.setup_ioapic_ids();\n\n\tsync_Arb_IDs();\n\tsetup_IO_APIC_irqs();\n\tinit_IO_APIC_traps();\n\tif (nr_legacy_irqs())\n\t\tcheck_timer();\n\n\tioapic_initialized = 1;\n}\n\nstatic void resume_ioapic_id(int ioapic_idx)\n{\n\tunsigned long flags;\n\tunion IO_APIC_reg_00 reg_00;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_00.raw = io_apic_read(ioapic_idx, 0);\n\tif (reg_00.bits.ID != mpc_ioapic_id(ioapic_idx)) {\n\t\treg_00.bits.ID = mpc_ioapic_id(ioapic_idx);\n\t\tio_apic_write(ioapic_idx, 0, reg_00.raw);\n\t}\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n}\n\nstatic void ioapic_resume(void)\n{\n\tint ioapic_idx;\n\n\tfor_each_ioapic_reverse(ioapic_idx)\n\t\tresume_ioapic_id(ioapic_idx);\n\n\trestore_ioapic_entries();\n}\n\nstatic struct syscore_ops ioapic_syscore_ops = {\n\t.suspend = save_ioapic_entries,\n\t.resume = ioapic_resume,\n};\n\nstatic int __init ioapic_init_ops(void)\n{\n\tregister_syscore_ops(&ioapic_syscore_ops);\n\n\treturn 0;\n}\n\ndevice_initcall(ioapic_init_ops);\n\nstatic int io_apic_get_redir_entries(int ioapic)\n{\n\tunion IO_APIC_reg_01\treg_01;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_01.raw = io_apic_read(ioapic, 1);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\t \n\treturn reg_01.bits.entries + 1;\n}\n\nunsigned int arch_dynirq_lower_bound(unsigned int from)\n{\n\tunsigned int ret;\n\n\t \n\tret = ioapic_dynirq_base ? : gsi_top;\n\n\t \n\treturn ret ? : from;\n}\n\n#ifdef CONFIG_X86_32\nstatic int io_apic_get_unique_id(int ioapic, int apic_id)\n{\n\tunion IO_APIC_reg_00 reg_00;\n\tstatic physid_mask_t apic_id_map = PHYSID_MASK_NONE;\n\tphysid_mask_t tmp;\n\tunsigned long flags;\n\tint i = 0;\n\n\t \n\n\tif (physids_empty(apic_id_map))\n\t\tapic->ioapic_phys_id_map(&phys_cpu_present_map, &apic_id_map);\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_00.raw = io_apic_read(ioapic, 0);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\tif (apic_id >= get_physical_broadcast()) {\n\t\tprintk(KERN_WARNING \"IOAPIC[%d]: Invalid apic_id %d, trying \"\n\t\t\t\"%d\\n\", ioapic, apic_id, reg_00.bits.ID);\n\t\tapic_id = reg_00.bits.ID;\n\t}\n\n\t \n\tif (apic->check_apicid_used(&apic_id_map, apic_id)) {\n\n\t\tfor (i = 0; i < get_physical_broadcast(); i++) {\n\t\t\tif (!apic->check_apicid_used(&apic_id_map, i))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == get_physical_broadcast())\n\t\t\tpanic(\"Max apic_id exceeded!\\n\");\n\n\t\tprintk(KERN_WARNING \"IOAPIC[%d]: apic_id %d already used, \"\n\t\t\t\"trying %d\\n\", ioapic, apic_id, i);\n\n\t\tapic_id = i;\n\t}\n\n\tphysid_set_mask_of_physid(apic_id, &tmp);\n\tphysids_or(apic_id_map, apic_id_map, tmp);\n\n\tif (reg_00.bits.ID != apic_id) {\n\t\treg_00.bits.ID = apic_id;\n\n\t\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\t\tio_apic_write(ioapic, 0, reg_00.raw);\n\t\treg_00.raw = io_apic_read(ioapic, 0);\n\t\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\t\t \n\t\tif (reg_00.bits.ID != apic_id) {\n\t\t\tpr_err(\"IOAPIC[%d]: Unable to change apic_id!\\n\",\n\t\t\t       ioapic);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tapic_printk(APIC_VERBOSE, KERN_INFO\n\t\t\t\"IOAPIC[%d]: Assigned apic_id %d\\n\", ioapic, apic_id);\n\n\treturn apic_id;\n}\n\nstatic u8 io_apic_unique_id(int idx, u8 id)\n{\n\tif ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &&\n\t    !APIC_XAPIC(boot_cpu_apic_version))\n\t\treturn io_apic_get_unique_id(idx, id);\n\telse\n\t\treturn id;\n}\n#else\nstatic u8 io_apic_unique_id(int idx, u8 id)\n{\n\tunion IO_APIC_reg_00 reg_00;\n\tDECLARE_BITMAP(used, 256);\n\tunsigned long flags;\n\tu8 new_id;\n\tint i;\n\n\tbitmap_zero(used, 256);\n\tfor_each_ioapic(i)\n\t\t__set_bit(mpc_ioapic_id(i), used);\n\n\t \n\tif (!test_bit(id, used))\n\t\treturn id;\n\n\t \n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_00.raw = io_apic_read(idx, 0);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\tnew_id = reg_00.bits.ID;\n\tif (!test_bit(new_id, used)) {\n\t\tapic_printk(APIC_VERBOSE, KERN_INFO\n\t\t\t\"IOAPIC[%d]: Using reg apic_id %d instead of %d\\n\",\n\t\t\t idx, new_id, id);\n\t\treturn new_id;\n\t}\n\n\t \n\tnew_id = find_first_zero_bit(used, 256);\n\treg_00.bits.ID = new_id;\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tio_apic_write(idx, 0, reg_00.raw);\n\treg_00.raw = io_apic_read(idx, 0);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\t \n\tBUG_ON(reg_00.bits.ID != new_id);\n\n\treturn new_id;\n}\n#endif\n\nstatic int io_apic_get_version(int ioapic)\n{\n\tunion IO_APIC_reg_01\treg_01;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\treg_01.raw = io_apic_read(ioapic, 1);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\n\treturn reg_01.bits.version;\n}\n\n \n#define IOAPIC_RESOURCE_NAME_SIZE 11\n\nstatic struct resource *ioapic_resources;\n\nstatic struct resource * __init ioapic_setup_resources(void)\n{\n\tunsigned long n;\n\tstruct resource *res;\n\tchar *mem;\n\tint i;\n\n\tif (nr_ioapics == 0)\n\t\treturn NULL;\n\n\tn = IOAPIC_RESOURCE_NAME_SIZE + sizeof(struct resource);\n\tn *= nr_ioapics;\n\n\tmem = memblock_alloc(n, SMP_CACHE_BYTES);\n\tif (!mem)\n\t\tpanic(\"%s: Failed to allocate %lu bytes\\n\", __func__, n);\n\tres = (void *)mem;\n\n\tmem += sizeof(struct resource) * nr_ioapics;\n\n\tfor_each_ioapic(i) {\n\t\tres[i].name = mem;\n\t\tres[i].flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\t\tsnprintf(mem, IOAPIC_RESOURCE_NAME_SIZE, \"IOAPIC %u\", i);\n\t\tmem += IOAPIC_RESOURCE_NAME_SIZE;\n\t\tioapics[i].iomem_res = &res[i];\n\t}\n\n\tioapic_resources = res;\n\n\treturn res;\n}\n\nstatic void io_apic_set_fixmap(enum fixed_addresses idx, phys_addr_t phys)\n{\n\tpgprot_t flags = FIXMAP_PAGE_NOCACHE;\n\n\t \n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tif (x86_platform.hyper.is_private_mmio(phys))\n\t\t\tflags = pgprot_encrypted(flags);\n\t\telse\n\t\t\tflags = pgprot_decrypted(flags);\n\t}\n\n\t__set_fixmap(idx, phys, flags);\n}\n\nvoid __init io_apic_init_mappings(void)\n{\n\tunsigned long ioapic_phys, idx = FIX_IO_APIC_BASE_0;\n\tstruct resource *ioapic_res;\n\tint i;\n\n\tioapic_res = ioapic_setup_resources();\n\tfor_each_ioapic(i) {\n\t\tif (smp_found_config) {\n\t\t\tioapic_phys = mpc_ioapic_addr(i);\n#ifdef CONFIG_X86_32\n\t\t\tif (!ioapic_phys) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"WARNING: bogus zero IO-APIC \"\n\t\t\t\t       \"address found in MPTABLE, \"\n\t\t\t\t       \"disabling IO/APIC support!\\n\");\n\t\t\t\tsmp_found_config = 0;\n\t\t\t\tioapic_is_disabled = true;\n\t\t\t\tgoto fake_ioapic_page;\n\t\t\t}\n#endif\n\t\t} else {\n#ifdef CONFIG_X86_32\nfake_ioapic_page:\n#endif\n\t\t\tioapic_phys = (unsigned long)memblock_alloc(PAGE_SIZE,\n\t\t\t\t\t\t\t\t    PAGE_SIZE);\n\t\t\tif (!ioapic_phys)\n\t\t\t\tpanic(\"%s: Failed to allocate %lu bytes align=0x%lx\\n\",\n\t\t\t\t      __func__, PAGE_SIZE, PAGE_SIZE);\n\t\t\tioapic_phys = __pa(ioapic_phys);\n\t\t}\n\t\tio_apic_set_fixmap(idx, ioapic_phys);\n\t\tapic_printk(APIC_VERBOSE, \"mapped IOAPIC to %08lx (%08lx)\\n\",\n\t\t\t__fix_to_virt(idx) + (ioapic_phys & ~PAGE_MASK),\n\t\t\tioapic_phys);\n\t\tidx++;\n\n\t\tioapic_res->start = ioapic_phys;\n\t\tioapic_res->end = ioapic_phys + IO_APIC_SLOT_SIZE - 1;\n\t\tioapic_res++;\n\t}\n}\n\nvoid __init ioapic_insert_resources(void)\n{\n\tint i;\n\tstruct resource *r = ioapic_resources;\n\n\tif (!r) {\n\t\tif (nr_ioapics > 0)\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"IO APIC resources couldn't be allocated.\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_ioapic(i) {\n\t\tinsert_resource(&iomem_resource, r);\n\t\tr++;\n\t}\n}\n\nint mp_find_ioapic(u32 gsi)\n{\n\tint i;\n\n\tif (nr_ioapics == 0)\n\t\treturn -1;\n\n\t \n\tfor_each_ioapic(i) {\n\t\tstruct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(i);\n\t\tif (gsi >= gsi_cfg->gsi_base && gsi <= gsi_cfg->gsi_end)\n\t\t\treturn i;\n\t}\n\n\tprintk(KERN_ERR \"ERROR: Unable to locate IOAPIC for GSI %d\\n\", gsi);\n\treturn -1;\n}\n\nint mp_find_ioapic_pin(int ioapic, u32 gsi)\n{\n\tstruct mp_ioapic_gsi *gsi_cfg;\n\n\tif (WARN_ON(ioapic < 0))\n\t\treturn -1;\n\n\tgsi_cfg = mp_ioapic_gsi_routing(ioapic);\n\tif (WARN_ON(gsi > gsi_cfg->gsi_end))\n\t\treturn -1;\n\n\treturn gsi - gsi_cfg->gsi_base;\n}\n\nstatic int bad_ioapic_register(int idx)\n{\n\tunion IO_APIC_reg_00 reg_00;\n\tunion IO_APIC_reg_01 reg_01;\n\tunion IO_APIC_reg_02 reg_02;\n\n\treg_00.raw = io_apic_read(idx, 0);\n\treg_01.raw = io_apic_read(idx, 1);\n\treg_02.raw = io_apic_read(idx, 2);\n\n\tif (reg_00.raw == -1 && reg_01.raw == -1 && reg_02.raw == -1) {\n\t\tpr_warn(\"I/O APIC 0x%x registers return all ones, skipping!\\n\",\n\t\t\tmpc_ioapic_addr(idx));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int find_free_ioapic_entry(void)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < MAX_IO_APICS; idx++)\n\t\tif (ioapics[idx].nr_registers == 0)\n\t\t\treturn idx;\n\n\treturn MAX_IO_APICS;\n}\n\n \nint mp_register_ioapic(int id, u32 address, u32 gsi_base,\n\t\t       struct ioapic_domain_cfg *cfg)\n{\n\tbool hotplug = !!ioapic_initialized;\n\tstruct mp_ioapic_gsi *gsi_cfg;\n\tint idx, ioapic, entries;\n\tu32 gsi_end;\n\n\tif (!address) {\n\t\tpr_warn(\"Bogus (zero) I/O APIC address found, skipping!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor_each_ioapic(ioapic)\n\t\tif (ioapics[ioapic].mp_config.apicaddr == address) {\n\t\t\tpr_warn(\"address 0x%x conflicts with IOAPIC%d\\n\",\n\t\t\t\taddress, ioapic);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\tidx = find_free_ioapic_entry();\n\tif (idx >= MAX_IO_APICS) {\n\t\tpr_warn(\"Max # of I/O APICs (%d) exceeded (found %d), skipping\\n\",\n\t\t\tMAX_IO_APICS, idx);\n\t\treturn -ENOSPC;\n\t}\n\n\tioapics[idx].mp_config.type = MP_IOAPIC;\n\tioapics[idx].mp_config.flags = MPC_APIC_USABLE;\n\tioapics[idx].mp_config.apicaddr = address;\n\n\tio_apic_set_fixmap(FIX_IO_APIC_BASE_0 + idx, address);\n\tif (bad_ioapic_register(idx)) {\n\t\tclear_fixmap(FIX_IO_APIC_BASE_0 + idx);\n\t\treturn -ENODEV;\n\t}\n\n\tioapics[idx].mp_config.apicid = io_apic_unique_id(idx, id);\n\tioapics[idx].mp_config.apicver = io_apic_get_version(idx);\n\n\t \n\tentries = io_apic_get_redir_entries(idx);\n\tgsi_end = gsi_base + entries - 1;\n\tfor_each_ioapic(ioapic) {\n\t\tgsi_cfg = mp_ioapic_gsi_routing(ioapic);\n\t\tif ((gsi_base >= gsi_cfg->gsi_base &&\n\t\t     gsi_base <= gsi_cfg->gsi_end) ||\n\t\t    (gsi_end >= gsi_cfg->gsi_base &&\n\t\t     gsi_end <= gsi_cfg->gsi_end)) {\n\t\t\tpr_warn(\"GSI range [%u-%u] for new IOAPIC conflicts with GSI[%u-%u]\\n\",\n\t\t\t\tgsi_base, gsi_end,\n\t\t\t\tgsi_cfg->gsi_base, gsi_cfg->gsi_end);\n\t\t\tclear_fixmap(FIX_IO_APIC_BASE_0 + idx);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tgsi_cfg = mp_ioapic_gsi_routing(idx);\n\tgsi_cfg->gsi_base = gsi_base;\n\tgsi_cfg->gsi_end = gsi_end;\n\n\tioapics[idx].irqdomain = NULL;\n\tioapics[idx].irqdomain_cfg = *cfg;\n\n\t \n\tif (hotplug) {\n\t\tif (mp_irqdomain_create(idx)) {\n\t\t\tclear_fixmap(FIX_IO_APIC_BASE_0 + idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\talloc_ioapic_saved_registers(idx);\n\t}\n\n\tif (gsi_cfg->gsi_end >= gsi_top)\n\t\tgsi_top = gsi_cfg->gsi_end + 1;\n\tif (nr_ioapics <= idx)\n\t\tnr_ioapics = idx + 1;\n\n\t \n\tioapics[idx].nr_registers = entries;\n\n\tpr_info(\"IOAPIC[%d]: apic_id %d, version %d, address 0x%x, GSI %d-%d\\n\",\n\t\tidx, mpc_ioapic_id(idx),\n\t\tmpc_ioapic_ver(idx), mpc_ioapic_addr(idx),\n\t\tgsi_cfg->gsi_base, gsi_cfg->gsi_end);\n\n\treturn 0;\n}\n\nint mp_unregister_ioapic(u32 gsi_base)\n{\n\tint ioapic, pin;\n\tint found = 0;\n\n\tfor_each_ioapic(ioapic)\n\t\tif (ioapics[ioapic].gsi_config.gsi_base == gsi_base) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\tif (!found) {\n\t\tpr_warn(\"can't find IOAPIC for GSI %d\\n\", gsi_base);\n\t\treturn -ENODEV;\n\t}\n\n\tfor_each_pin(ioapic, pin) {\n\t\tu32 gsi = mp_pin_to_gsi(ioapic, pin);\n\t\tint irq = mp_map_gsi_to_irq(gsi, 0, NULL);\n\t\tstruct mp_chip_data *data;\n\n\t\tif (irq >= 0) {\n\t\t\tdata = irq_get_chip_data(irq);\n\t\t\tif (data && data->count) {\n\t\t\t\tpr_warn(\"pin%d on IOAPIC%d is still in use.\\n\",\n\t\t\t\t\tpin, ioapic);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tioapics[ioapic].nr_registers  = 0;\n\tioapic_destroy_irqdomain(ioapic);\n\tfree_ioapic_saved_registers(ioapic);\n\tif (ioapics[ioapic].iomem_res)\n\t\trelease_resource(ioapics[ioapic].iomem_res);\n\tclear_fixmap(FIX_IO_APIC_BASE_0 + ioapic);\n\tmemset(&ioapics[ioapic], 0, sizeof(ioapics[ioapic]));\n\n\treturn 0;\n}\n\nint mp_ioapic_registered(u32 gsi_base)\n{\n\tint ioapic;\n\n\tfor_each_ioapic(ioapic)\n\t\tif (ioapics[ioapic].gsi_config.gsi_base == gsi_base)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void mp_irqdomain_get_attr(u32 gsi, struct mp_chip_data *data,\n\t\t\t\t  struct irq_alloc_info *info)\n{\n\tif (info && info->ioapic.valid) {\n\t\tdata->is_level = info->ioapic.is_level;\n\t\tdata->active_low = info->ioapic.active_low;\n\t} else if (__acpi_get_override_irq(gsi, &data->is_level,\n\t\t\t\t\t   &data->active_low) < 0) {\n\t\t \n\t\tdata->is_level = true;\n\t\tdata->active_low = true;\n\t}\n}\n\n \nstatic void mp_preconfigure_entry(struct mp_chip_data *data)\n{\n\tstruct IO_APIC_route_entry *entry = &data->entry;\n\n\tmemset(entry, 0, sizeof(*entry));\n\tentry->is_level\t\t = data->is_level;\n\tentry->active_low\t = data->active_low;\n\t \n\tentry->masked\t\t= data->is_level;\n}\n\nint mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t       unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct mp_chip_data *data;\n\tstruct irq_data *irq_data;\n\tint ret, ioapic, pin;\n\tunsigned long flags;\n\n\tif (!info || nr_irqs > 1)\n\t\treturn -EINVAL;\n\tirq_data = irq_domain_get_irq_data(domain, virq);\n\tif (!irq_data)\n\t\treturn -EINVAL;\n\n\tioapic = mp_irqdomain_ioapic_idx(domain);\n\tpin = info->ioapic.pin;\n\tif (irq_find_mapping(domain, (irq_hw_number_t)pin) > 0)\n\t\treturn -EEXIST;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, info);\n\tif (ret < 0) {\n\t\tkfree(data);\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&data->irq_2_pin);\n\tirq_data->hwirq = info->ioapic.pin;\n\tirq_data->chip = (domain->parent == x86_vector_domain) ?\n\t\t\t  &ioapic_chip : &ioapic_ir_chip;\n\tirq_data->chip_data = data;\n\tmp_irqdomain_get_attr(mp_pin_to_gsi(ioapic, pin), data, info);\n\n\tadd_pin_to_irq_node(data, ioapic_alloc_attr_node(info), ioapic, pin);\n\n\tmp_preconfigure_entry(data);\n\tmp_register_handler(virq, data->is_level);\n\n\tlocal_irq_save(flags);\n\tif (virq < nr_legacy_irqs())\n\t\tlegacy_pic->mask(virq);\n\tlocal_irq_restore(flags);\n\n\tapic_printk(APIC_VERBOSE, KERN_DEBUG\n\t\t    \"IOAPIC[%d]: Preconfigured routing entry (%d-%d -> IRQ %d Level:%i ActiveLow:%i)\\n\",\n\t\t    ioapic, mpc_ioapic_id(ioapic), pin, virq,\n\t\t    data->is_level, data->active_low);\n\treturn 0;\n}\n\nvoid mp_irqdomain_free(struct irq_domain *domain, unsigned int virq,\n\t\t       unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct mp_chip_data *data;\n\n\tBUG_ON(nr_irqs != 1);\n\tirq_data = irq_domain_get_irq_data(domain, virq);\n\tif (irq_data && irq_data->chip_data) {\n\t\tdata = irq_data->chip_data;\n\t\t__remove_pin_from_irq(data, mp_irqdomain_ioapic_idx(domain),\n\t\t\t\t      (int)irq_data->hwirq);\n\t\tWARN_ON(!list_empty(&data->irq_2_pin));\n\t\tkfree(irq_data->chip_data);\n\t}\n\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n}\n\nint mp_irqdomain_activate(struct irq_domain *domain,\n\t\t\t  struct irq_data *irq_data, bool reserve)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ioapic_lock, flags);\n\tioapic_configure_entry(irq_data);\n\traw_spin_unlock_irqrestore(&ioapic_lock, flags);\n\treturn 0;\n}\n\nvoid mp_irqdomain_deactivate(struct irq_domain *domain,\n\t\t\t     struct irq_data *irq_data)\n{\n\t \n\tioapic_mask_entry(mp_irqdomain_ioapic_idx(domain),\n\t\t\t  (int)irq_data->hwirq);\n}\n\nint mp_irqdomain_ioapic_idx(struct irq_domain *domain)\n{\n\treturn (int)(long)domain->host_data;\n}\n\nconst struct irq_domain_ops mp_ioapic_irqdomain_ops = {\n\t.alloc\t\t= mp_irqdomain_alloc,\n\t.free\t\t= mp_irqdomain_free,\n\t.activate\t= mp_irqdomain_activate,\n\t.deactivate\t= mp_irqdomain_deactivate,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}