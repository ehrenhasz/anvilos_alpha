{
  "module_name": "apic.c",
  "hash_id": "27a5ff2f7f9899728a5a9fe9a9b6aee101de4720783a7c4cfcde9b591415b6d7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/apic.c",
  "human_readable_source": "\n \n\n#include <linux/perf_event.h>\n#include <linux/kernel_stat.h>\n#include <linux/mc146818rtc.h>\n#include <linux/acpi_pmtmr.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/memblock.h>\n#include <linux/ftrace.h>\n#include <linux/ioport.h>\n#include <linux/export.h>\n#include <linux/syscore_ops.h>\n#include <linux/delay.h>\n#include <linux/timex.h>\n#include <linux/i8253.h>\n#include <linux/dmar.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/dmi.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n\n#include <xen/xen.h>\n\n#include <asm/trace/irq_vectors.h>\n#include <asm/irq_remapping.h>\n#include <asm/pc-conf-reg.h>\n#include <asm/perf_event.h>\n#include <asm/x86_init.h>\n#include <linux/atomic.h>\n#include <asm/barrier.h>\n#include <asm/mpspec.h>\n#include <asm/i8259.h>\n#include <asm/proto.h>\n#include <asm/traps.h>\n#include <asm/apic.h>\n#include <asm/acpi.h>\n#include <asm/io_apic.h>\n#include <asm/desc.h>\n#include <asm/hpet.h>\n#include <asm/mtrr.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/mce.h>\n#include <asm/tsc.h>\n#include <asm/hypervisor.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/irq_regs.h>\n#include <asm/cpu.h>\n\n#include \"local.h\"\n\nunsigned int num_processors;\n\nunsigned disabled_cpus;\n\n \nunsigned int boot_cpu_physical_apicid __ro_after_init = -1U;\nEXPORT_SYMBOL_GPL(boot_cpu_physical_apicid);\n\nu8 boot_cpu_apic_version __ro_after_init;\n\n \nphysid_mask_t phys_cpu_present_map;\n\n \nstatic unsigned int disabled_cpu_apicid __ro_after_init = BAD_APICID;\n\n \nstatic int apic_extnmi __ro_after_init = APIC_EXTNMI_BSP;\n\n \nstatic bool virt_ext_dest_id __ro_after_init;\n\n \nunsigned long apic_mmio_base __ro_after_init;\n\nstatic inline bool apic_accessible(void)\n{\n\treturn x2apic_mode || apic_mmio_base;\n}\n\n \nDEFINE_EARLY_PER_CPU_READ_MOSTLY(u16, x86_cpu_to_apicid, BAD_APICID);\nDEFINE_EARLY_PER_CPU_READ_MOSTLY(u32, x86_cpu_to_acpiid, U32_MAX);\nEXPORT_EARLY_PER_CPU_SYMBOL(x86_cpu_to_apicid);\nEXPORT_EARLY_PER_CPU_SYMBOL(x86_cpu_to_acpiid);\n\n#ifdef CONFIG_X86_32\n \nstatic int enabled_via_apicbase __ro_after_init;\n\n \nstatic inline void imcr_pic_to_apic(void)\n{\n\t \n\tpc_conf_set(PC_CONF_MPS_IMCR, 0x01);\n}\n\nstatic inline void imcr_apic_to_pic(void)\n{\n\t \n\tpc_conf_set(PC_CONF_MPS_IMCR, 0x00);\n}\n#endif\n\n \nstatic int force_enable_local_apic __initdata;\n\n \nstatic int __init parse_lapic(char *arg)\n{\n\tif (IS_ENABLED(CONFIG_X86_32) && !arg)\n\t\tforce_enable_local_apic = 1;\n\telse if (arg && !strncmp(arg, \"notscdeadline\", 13))\n\t\tsetup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);\n\treturn 0;\n}\nearly_param(\"lapic\", parse_lapic);\n\n#ifdef CONFIG_X86_64\nstatic int apic_calibrate_pmtmr __initdata;\nstatic __init int setup_apicpmtimer(char *s)\n{\n\tapic_calibrate_pmtmr = 1;\n\tnotsc_setup(NULL);\n\treturn 1;\n}\n__setup(\"apicpmtimer\", setup_apicpmtimer);\n#endif\n\nstatic unsigned long mp_lapic_addr __ro_after_init;\nbool apic_is_disabled __ro_after_init;\n \nstatic int disable_apic_timer __initdata;\n \nint local_apic_timer_c2_ok __ro_after_init;\nEXPORT_SYMBOL_GPL(local_apic_timer_c2_ok);\n\n \nint apic_verbosity __ro_after_init;\n\nint pic_mode __ro_after_init;\n\n \nint smp_found_config __ro_after_init;\n\nstatic struct resource lapic_resource = {\n\t.name = \"Local APIC\",\n\t.flags = IORESOURCE_MEM | IORESOURCE_BUSY,\n};\n\nunsigned int lapic_timer_period = 0;\n\nstatic void apic_pm_activate(void);\n\n \nstatic inline int lapic_get_version(void)\n{\n\treturn GET_APIC_VERSION(apic_read(APIC_LVR));\n}\n\n \nstatic inline int lapic_is_integrated(void)\n{\n\treturn APIC_INTEGRATED(lapic_get_version());\n}\n\n \nstatic int modern_apic(void)\n{\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86 >= 0xf)\n\t\treturn 1;\n\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_HYGON)\n\t\treturn 1;\n\n\treturn lapic_get_version() >= 0x14;\n}\n\n \nstatic void __init apic_disable(void)\n{\n\tapic_install_driver(&apic_noop);\n}\n\nvoid native_apic_icr_write(u32 low, u32 id)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tapic_write(APIC_ICR2, SET_XAPIC_DEST_FIELD(id));\n\tapic_write(APIC_ICR, low);\n\tlocal_irq_restore(flags);\n}\n\nu64 native_apic_icr_read(void)\n{\n\tu32 icr1, icr2;\n\n\ticr2 = apic_read(APIC_ICR2);\n\ticr1 = apic_read(APIC_ICR);\n\n\treturn icr1 | ((u64)icr2 << 32);\n}\n\n#ifdef CONFIG_X86_32\n \nint get_physical_broadcast(void)\n{\n\treturn modern_apic() ? 0xff : 0xf;\n}\n#endif\n\n \nint lapic_get_maxlvt(void)\n{\n\t \n\treturn lapic_is_integrated() ? GET_APIC_MAXLVT(apic_read(APIC_LVR)) : 2;\n}\n\n \n\n \n#define APIC_DIVISOR 16\n#define TSC_DIVISOR  8\n\n \n#define\t\tI82489DX_BASE_DIVIDER\t\t(((0x2) << 18))\n\n \nstatic void __setup_APIC_LVTT(unsigned int clocks, int oneshot, int irqen)\n{\n\tunsigned int lvtt_value, tmp_value;\n\n\tlvtt_value = LOCAL_TIMER_VECTOR;\n\tif (!oneshot)\n\t\tlvtt_value |= APIC_LVT_TIMER_PERIODIC;\n\telse if (boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\tlvtt_value |= APIC_LVT_TIMER_TSCDEADLINE;\n\n\t \n\tif (!lapic_is_integrated())\n\t\tlvtt_value |= I82489DX_BASE_DIVIDER;\n\n\tif (!irqen)\n\t\tlvtt_value |= APIC_LVT_MASKED;\n\n\tapic_write(APIC_LVTT, lvtt_value);\n\n\tif (lvtt_value & APIC_LVT_TIMER_TSCDEADLINE) {\n\t\t \n\t\tasm volatile(\"mfence\" : : : \"memory\");\n\t\treturn;\n\t}\n\n\t \n\ttmp_value = apic_read(APIC_TDCR);\n\tapic_write(APIC_TDCR,\n\t\t(tmp_value & ~(APIC_TDR_DIV_1 | APIC_TDR_DIV_TMBASE)) |\n\t\tAPIC_TDR_DIV_16);\n\n\tif (!oneshot)\n\t\tapic_write(APIC_TMICT, clocks / APIC_DIVISOR);\n}\n\n \n\nstatic atomic_t eilvt_offsets[APIC_EILVT_NR_MAX];\n\nstatic inline int eilvt_entry_is_changeable(unsigned int old, unsigned int new)\n{\n\treturn (old & APIC_EILVT_MASKED)\n\t\t|| (new == APIC_EILVT_MASKED)\n\t\t|| ((new & ~APIC_EILVT_MASKED) == old);\n}\n\nstatic unsigned int reserve_eilvt_offset(int offset, unsigned int new)\n{\n\tunsigned int rsvd, vector;\n\n\tif (offset >= APIC_EILVT_NR_MAX)\n\t\treturn ~0;\n\n\trsvd = atomic_read(&eilvt_offsets[offset]);\n\tdo {\n\t\tvector = rsvd & ~APIC_EILVT_MASKED;\t \n\t\tif (vector && !eilvt_entry_is_changeable(vector, new))\n\t\t\t \n\t\t\treturn rsvd;\n\t} while (!atomic_try_cmpxchg(&eilvt_offsets[offset], &rsvd, new));\n\n\trsvd = new & ~APIC_EILVT_MASKED;\n\tif (rsvd && rsvd != vector)\n\t\tpr_info(\"LVT offset %d assigned for vector 0x%02x\\n\",\n\t\t\toffset, rsvd);\n\n\treturn new;\n}\n\n \n\nint setup_APIC_eilvt(u8 offset, u8 vector, u8 msg_type, u8 mask)\n{\n\tunsigned long reg = APIC_EILVTn(offset);\n\tunsigned int new, old, reserved;\n\n\tnew = (mask << 16) | (msg_type << 8) | vector;\n\told = apic_read(reg);\n\treserved = reserve_eilvt_offset(offset, new);\n\n\tif (reserved != new) {\n\t\tpr_err(FW_BUG \"cpu %d, try to use APIC%lX (LVT offset %d) for \"\n\t\t       \"vector 0x%x, but the register is already in use for \"\n\t\t       \"vector 0x%x on another cpu\\n\",\n\t\t       smp_processor_id(), reg, offset, new, reserved);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!eilvt_entry_is_changeable(old, new)) {\n\t\tpr_err(FW_BUG \"cpu %d, try to use APIC%lX (LVT offset %d) for \"\n\t\t       \"vector 0x%x, but the register is already in use for \"\n\t\t       \"vector 0x%x on this cpu\\n\",\n\t\t       smp_processor_id(), reg, offset, new, old);\n\t\treturn -EBUSY;\n\t}\n\n\tapic_write(reg, new);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(setup_APIC_eilvt);\n\n \nstatic int lapic_next_event(unsigned long delta,\n\t\t\t    struct clock_event_device *evt)\n{\n\tapic_write(APIC_TMICT, delta);\n\treturn 0;\n}\n\nstatic int lapic_next_deadline(unsigned long delta,\n\t\t\t       struct clock_event_device *evt)\n{\n\tu64 tsc;\n\n\t \n\tweak_wrmsr_fence();\n\n\ttsc = rdtsc();\n\twrmsrl(MSR_IA32_TSC_DEADLINE, tsc + (((u64) delta) * TSC_DIVISOR));\n\treturn 0;\n}\n\nstatic int lapic_timer_shutdown(struct clock_event_device *evt)\n{\n\tunsigned int v;\n\n\t \n\tif (evt->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\tv = apic_read(APIC_LVTT);\n\tv |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);\n\tapic_write(APIC_LVTT, v);\n\tapic_write(APIC_TMICT, 0);\n\treturn 0;\n}\n\nstatic inline int\nlapic_timer_set_periodic_oneshot(struct clock_event_device *evt, bool oneshot)\n{\n\t \n\tif (evt->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t__setup_APIC_LVTT(lapic_timer_period, oneshot, 1);\n\treturn 0;\n}\n\nstatic int lapic_timer_set_periodic(struct clock_event_device *evt)\n{\n\treturn lapic_timer_set_periodic_oneshot(evt, false);\n}\n\nstatic int lapic_timer_set_oneshot(struct clock_event_device *evt)\n{\n\treturn lapic_timer_set_periodic_oneshot(evt, true);\n}\n\n \nstatic void lapic_timer_broadcast(const struct cpumask *mask)\n{\n#ifdef CONFIG_SMP\n\t__apic_send_IPI_mask(mask, LOCAL_TIMER_VECTOR);\n#endif\n}\n\n\n \nstatic struct clock_event_device lapic_clockevent = {\n\t.name\t\t\t\t= \"lapic\",\n\t.features\t\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_C3STOP\n\t\t\t\t\t  | CLOCK_EVT_FEAT_DUMMY,\n\t.shift\t\t\t\t= 32,\n\t.set_state_shutdown\t\t= lapic_timer_shutdown,\n\t.set_state_periodic\t\t= lapic_timer_set_periodic,\n\t.set_state_oneshot\t\t= lapic_timer_set_oneshot,\n\t.set_state_oneshot_stopped\t= lapic_timer_shutdown,\n\t.set_next_event\t\t\t= lapic_next_event,\n\t.broadcast\t\t\t= lapic_timer_broadcast,\n\t.rating\t\t\t\t= 100,\n\t.irq\t\t\t\t= -1,\n};\nstatic DEFINE_PER_CPU(struct clock_event_device, lapic_events);\n\nstatic const struct x86_cpu_id deadline_match[] __initconst = {\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(HASWELL_X, X86_STEPPINGS(0x2, 0x2), 0x3a),  \n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(HASWELL_X, X86_STEPPINGS(0x4, 0x4), 0x0f),  \n\n\tX86_MATCH_INTEL_FAM6_MODEL( BROADWELL_X,\t0x0b000020),\n\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(BROADWELL_D, X86_STEPPINGS(0x2, 0x2), 0x00000011),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(BROADWELL_D, X86_STEPPINGS(0x3, 0x3), 0x0700000e),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(BROADWELL_D, X86_STEPPINGS(0x4, 0x4), 0x0f00000c),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(BROADWELL_D, X86_STEPPINGS(0x5, 0x5), 0x0e000003),\n\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(SKYLAKE_X, X86_STEPPINGS(0x3, 0x3), 0x01000136),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(SKYLAKE_X, X86_STEPPINGS(0x4, 0x4), 0x02000014),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(SKYLAKE_X, X86_STEPPINGS(0x5, 0xf), 0),\n\n\tX86_MATCH_INTEL_FAM6_MODEL( HASWELL,\t\t0x22),\n\tX86_MATCH_INTEL_FAM6_MODEL( HASWELL_L,\t\t0x20),\n\tX86_MATCH_INTEL_FAM6_MODEL( HASWELL_G,\t\t0x17),\n\n\tX86_MATCH_INTEL_FAM6_MODEL( BROADWELL,\t\t0x25),\n\tX86_MATCH_INTEL_FAM6_MODEL( BROADWELL_G,\t0x17),\n\n\tX86_MATCH_INTEL_FAM6_MODEL( SKYLAKE_L,\t\t0xb2),\n\tX86_MATCH_INTEL_FAM6_MODEL( SKYLAKE,\t\t0xb2),\n\n\tX86_MATCH_INTEL_FAM6_MODEL( KABYLAKE_L,\t\t0x52),\n\tX86_MATCH_INTEL_FAM6_MODEL( KABYLAKE,\t\t0x52),\n\n\t{},\n};\n\nstatic __init bool apic_validate_deadline_timer(void)\n{\n\tconst struct x86_cpu_id *m;\n\tu32 rev;\n\n\tif (!boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\treturn false;\n\tif (boot_cpu_has(X86_FEATURE_HYPERVISOR))\n\t\treturn true;\n\n\tm = x86_match_cpu(deadline_match);\n\tif (!m)\n\t\treturn true;\n\n\trev = (u32)m->driver_data;\n\n\tif (boot_cpu_data.microcode >= rev)\n\t\treturn true;\n\n\tsetup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);\n\tpr_err(FW_BUG \"TSC_DEADLINE disabled due to Errata; \"\n\t       \"please update microcode to version: 0x%x (or later)\\n\", rev);\n\treturn false;\n}\n\n \nstatic void setup_APIC_timer(void)\n{\n\tstruct clock_event_device *levt = this_cpu_ptr(&lapic_events);\n\n\tif (this_cpu_has(X86_FEATURE_ARAT)) {\n\t\tlapic_clockevent.features &= ~CLOCK_EVT_FEAT_C3STOP;\n\t\t \n\t\tlapic_clockevent.rating = 150;\n\t}\n\n\tmemcpy(levt, &lapic_clockevent, sizeof(*levt));\n\tlevt->cpumask = cpumask_of(smp_processor_id());\n\n\tif (this_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER)) {\n\t\tlevt->name = \"lapic-deadline\";\n\t\tlevt->features &= ~(CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t    CLOCK_EVT_FEAT_DUMMY);\n\t\tlevt->set_next_event = lapic_next_deadline;\n\t\tclockevents_config_and_register(levt,\n\t\t\t\t\t\ttsc_khz * (1000 / TSC_DIVISOR),\n\t\t\t\t\t\t0xF, ~0UL);\n\t} else\n\t\tclockevents_register_device(levt);\n}\n\n \nstatic void __lapic_update_tsc_freq(void *info)\n{\n\tstruct clock_event_device *levt = this_cpu_ptr(&lapic_events);\n\n\tif (!this_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\treturn;\n\n\tclockevents_update_freq(levt, tsc_khz * (1000 / TSC_DIVISOR));\n}\n\nvoid lapic_update_tsc_freq(void)\n{\n\t \n\ton_each_cpu(__lapic_update_tsc_freq, NULL, 0);\n}\n\n \n\n#define LAPIC_CAL_LOOPS\t\t(HZ/10)\n\nstatic __initdata int lapic_cal_loops = -1;\nstatic __initdata long lapic_cal_t1, lapic_cal_t2;\nstatic __initdata unsigned long long lapic_cal_tsc1, lapic_cal_tsc2;\nstatic __initdata unsigned long lapic_cal_pm1, lapic_cal_pm2;\nstatic __initdata unsigned long lapic_cal_j1, lapic_cal_j2;\n\n \nstatic void __init lapic_cal_handler(struct clock_event_device *dev)\n{\n\tunsigned long long tsc = 0;\n\tlong tapic = apic_read(APIC_TMCCT);\n\tunsigned long pm = acpi_pm_read_early();\n\n\tif (boot_cpu_has(X86_FEATURE_TSC))\n\t\ttsc = rdtsc();\n\n\tswitch (lapic_cal_loops++) {\n\tcase 0:\n\t\tlapic_cal_t1 = tapic;\n\t\tlapic_cal_tsc1 = tsc;\n\t\tlapic_cal_pm1 = pm;\n\t\tlapic_cal_j1 = jiffies;\n\t\tbreak;\n\n\tcase LAPIC_CAL_LOOPS:\n\t\tlapic_cal_t2 = tapic;\n\t\tlapic_cal_tsc2 = tsc;\n\t\tif (pm < lapic_cal_pm1)\n\t\t\tpm += ACPI_PM_OVRRUN;\n\t\tlapic_cal_pm2 = pm;\n\t\tlapic_cal_j2 = jiffies;\n\t\tbreak;\n\t}\n}\n\nstatic int __init\ncalibrate_by_pmtimer(long deltapm, long *delta, long *deltatsc)\n{\n\tconst long pm_100ms = PMTMR_TICKS_PER_SEC / 10;\n\tconst long pm_thresh = pm_100ms / 100;\n\tunsigned long mult;\n\tu64 res;\n\n#ifndef CONFIG_X86_PM_TIMER\n\treturn -1;\n#endif\n\n\tapic_printk(APIC_VERBOSE, \"... PM-Timer delta = %ld\\n\", deltapm);\n\n\t \n\tif (!deltapm)\n\t\treturn -1;\n\n\tmult = clocksource_hz2mult(PMTMR_TICKS_PER_SEC, 22);\n\n\tif (deltapm > (pm_100ms - pm_thresh) &&\n\t    deltapm < (pm_100ms + pm_thresh)) {\n\t\tapic_printk(APIC_VERBOSE, \"... PM-Timer result ok\\n\");\n\t\treturn 0;\n\t}\n\n\tres = (((u64)deltapm) *  mult) >> 22;\n\tdo_div(res, 1000000);\n\tpr_warn(\"APIC calibration not consistent \"\n\t\t\"with PM-Timer: %ldms instead of 100ms\\n\", (long)res);\n\n\t \n\tres = (((u64)(*delta)) * pm_100ms);\n\tdo_div(res, deltapm);\n\tpr_info(\"APIC delta adjusted to PM-Timer: \"\n\t\t\"%lu (%ld)\\n\", (unsigned long)res, *delta);\n\t*delta = (long)res;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_TSC)) {\n\t\tres = (((u64)(*deltatsc)) * pm_100ms);\n\t\tdo_div(res, deltapm);\n\t\tapic_printk(APIC_VERBOSE, \"TSC delta adjusted to \"\n\t\t\t\t\t  \"PM-Timer: %lu (%ld)\\n\",\n\t\t\t\t\t(unsigned long)res, *deltatsc);\n\t\t*deltatsc = (long)res;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init lapic_init_clockevent(void)\n{\n\tif (!lapic_timer_period)\n\t\treturn -1;\n\n\t \n\tlapic_clockevent.mult = div_sc(lapic_timer_period/APIC_DIVISOR,\n\t\t\t\t\tTICK_NSEC, lapic_clockevent.shift);\n\tlapic_clockevent.max_delta_ns =\n\t\tclockevent_delta2ns(0x7FFFFFFF, &lapic_clockevent);\n\tlapic_clockevent.max_delta_ticks = 0x7FFFFFFF;\n\tlapic_clockevent.min_delta_ns =\n\t\tclockevent_delta2ns(0xF, &lapic_clockevent);\n\tlapic_clockevent.min_delta_ticks = 0xF;\n\n\treturn 0;\n}\n\nbool __init apic_needs_pit(void)\n{\n\t \n\tif (!tsc_khz || !cpu_khz)\n\t\treturn true;\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_APIC) || apic_is_disabled)\n\t\treturn true;\n\n\t \n\tif (apic_intr_mode == APIC_PIC ||\n\t    apic_intr_mode == APIC_VIRTUAL_WIRE_NO_CONFIG)\n\t\treturn true;\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_ARAT))\n\t\treturn true;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\treturn false;\n\n\t \n\tif (disable_apic_timer)\n\t\treturn true;\n\t \n\treturn lapic_timer_period == 0;\n}\n\nstatic int __init calibrate_APIC_clock(void)\n{\n\tstruct clock_event_device *levt = this_cpu_ptr(&lapic_events);\n\tu64 tsc_perj = 0, tsc_start = 0;\n\tunsigned long jif_start;\n\tunsigned long deltaj;\n\tlong delta, deltatsc;\n\tint pm_referenced = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\treturn 0;\n\n\t \n\tif (!lapic_init_clockevent()) {\n\t\tapic_printk(APIC_VERBOSE, \"lapic timer already calibrated %d\\n\",\n\t\t\t    lapic_timer_period);\n\t\t \n\t\tlapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;\n\t\treturn 0;\n\t}\n\n\tapic_printk(APIC_VERBOSE, \"Using local APIC timer interrupts.\\n\"\n\t\t    \"calibrating APIC timer ...\\n\");\n\n\t \n\tlocal_irq_disable();\n\n\t \n\t__setup_APIC_LVTT(0xffffffff, 0, 0);\n\n\t \n\tjif_start = READ_ONCE(jiffies);\n\n\tif (tsc_khz) {\n\t\ttsc_start = rdtsc();\n\t\ttsc_perj = div_u64((u64)tsc_khz * 1000, HZ);\n\t}\n\n\t \n\tlocal_irq_enable();\n\n\twhile (lapic_cal_loops <= LAPIC_CAL_LOOPS) {\n\t\t \n\t\twhile (1) {\n\t\t\tif (tsc_khz) {\n\t\t\t\tu64 tsc_now = rdtsc();\n\t\t\t\tif ((tsc_now - tsc_start) >= tsc_perj) {\n\t\t\t\t\ttsc_start += tsc_perj;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned long jif_now = READ_ONCE(jiffies);\n\n\t\t\t\tif (time_after(jif_now, jif_start)) {\n\t\t\t\t\tjif_start = jif_now;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t \n\t\tlocal_irq_disable();\n\t\tlapic_cal_handler(NULL);\n\t\tlocal_irq_enable();\n\t}\n\n\tlocal_irq_disable();\n\n\t \n\tdelta = lapic_cal_t1 - lapic_cal_t2;\n\tapic_printk(APIC_VERBOSE, \"... lapic delta = %ld\\n\", delta);\n\n\tdeltatsc = (long)(lapic_cal_tsc2 - lapic_cal_tsc1);\n\n\t \n\tpm_referenced = !calibrate_by_pmtimer(lapic_cal_pm2 - lapic_cal_pm1,\n\t\t\t\t\t&delta, &deltatsc);\n\n\tlapic_timer_period = (delta * APIC_DIVISOR) / LAPIC_CAL_LOOPS;\n\tlapic_init_clockevent();\n\n\tapic_printk(APIC_VERBOSE, \"..... delta %ld\\n\", delta);\n\tapic_printk(APIC_VERBOSE, \"..... mult: %u\\n\", lapic_clockevent.mult);\n\tapic_printk(APIC_VERBOSE, \"..... calibration result: %u\\n\",\n\t\t    lapic_timer_period);\n\n\tif (boot_cpu_has(X86_FEATURE_TSC)) {\n\t\tapic_printk(APIC_VERBOSE, \"..... CPU clock speed is \"\n\t\t\t    \"%ld.%04ld MHz.\\n\",\n\t\t\t    (deltatsc / LAPIC_CAL_LOOPS) / (1000000 / HZ),\n\t\t\t    (deltatsc / LAPIC_CAL_LOOPS) % (1000000 / HZ));\n\t}\n\n\tapic_printk(APIC_VERBOSE, \"..... host bus clock speed is \"\n\t\t    \"%u.%04u MHz.\\n\",\n\t\t    lapic_timer_period / (1000000 / HZ),\n\t\t    lapic_timer_period % (1000000 / HZ));\n\n\t \n\tif (lapic_timer_period < (1000000 / HZ)) {\n\t\tlocal_irq_enable();\n\t\tpr_warn(\"APIC frequency too slow, disabling apic timer\\n\");\n\t\treturn -1;\n\t}\n\n\tlevt->features &= ~CLOCK_EVT_FEAT_DUMMY;\n\n\t \n\tif (!pm_referenced && global_clock_event) {\n\t\tapic_printk(APIC_VERBOSE, \"... verify APIC timer\\n\");\n\n\t\t \n\t\tlevt->event_handler = lapic_cal_handler;\n\t\tlapic_timer_set_periodic(levt);\n\t\tlapic_cal_loops = -1;\n\n\t\t \n\t\tlocal_irq_enable();\n\n\t\twhile (lapic_cal_loops <= LAPIC_CAL_LOOPS)\n\t\t\tcpu_relax();\n\n\t\t \n\t\tlocal_irq_disable();\n\t\tlapic_timer_shutdown(levt);\n\n\t\t \n\t\tdeltaj = lapic_cal_j2 - lapic_cal_j1;\n\t\tapic_printk(APIC_VERBOSE, \"... jiffies delta = %lu\\n\", deltaj);\n\n\t\t \n\t\tif (deltaj >= LAPIC_CAL_LOOPS-2 && deltaj <= LAPIC_CAL_LOOPS+2)\n\t\t\tapic_printk(APIC_VERBOSE, \"... jiffies result ok\\n\");\n\t\telse\n\t\t\tlevt->features |= CLOCK_EVT_FEAT_DUMMY;\n\t}\n\tlocal_irq_enable();\n\n\tif (levt->features & CLOCK_EVT_FEAT_DUMMY) {\n\t\tpr_warn(\"APIC timer disabled due to verification failure\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid __init setup_boot_APIC_clock(void)\n{\n\t \n\tif (disable_apic_timer) {\n\t\tpr_info(\"Disabling APIC timer\\n\");\n\t\t \n\t\tif (num_possible_cpus() > 1) {\n\t\t\tlapic_clockevent.mult = 1;\n\t\t\tsetup_APIC_timer();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (calibrate_APIC_clock()) {\n\t\t \n\t\tif (num_possible_cpus() > 1)\n\t\t\tsetup_APIC_timer();\n\t\treturn;\n\t}\n\n\t \n\tlapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;\n\n\t \n\tsetup_APIC_timer();\n\tamd_e400_c1e_apic_setup();\n}\n\nvoid setup_secondary_APIC_clock(void)\n{\n\tsetup_APIC_timer();\n\tamd_e400_c1e_apic_setup();\n}\n\n \nstatic void local_apic_timer_interrupt(void)\n{\n\tstruct clock_event_device *evt = this_cpu_ptr(&lapic_events);\n\n\t \n\tif (!evt->event_handler) {\n\t\tpr_warn(\"Spurious LAPIC timer interrupt on cpu %d\\n\",\n\t\t\tsmp_processor_id());\n\t\t \n\t\tlapic_timer_shutdown(evt);\n\t\treturn;\n\t}\n\n\t \n\tinc_irq_stat(apic_timer_irqs);\n\n\tevt->event_handler(evt);\n}\n\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_apic_timer_interrupt)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tapic_eoi();\n\ttrace_local_timer_entry(LOCAL_TIMER_VECTOR);\n\tlocal_apic_timer_interrupt();\n\ttrace_local_timer_exit(LOCAL_TIMER_VECTOR);\n\n\tset_irq_regs(old_regs);\n}\n\n \n\n \nvoid clear_local_APIC(void)\n{\n\tint maxlvt;\n\tu32 v;\n\n\tif (!apic_accessible())\n\t\treturn;\n\n\tmaxlvt = lapic_get_maxlvt();\n\t \n\tif (maxlvt >= 3) {\n\t\tv = ERROR_APIC_VECTOR;  \n\t\tapic_write(APIC_LVTERR, v | APIC_LVT_MASKED);\n\t}\n\t \n\tv = apic_read(APIC_LVTT);\n\tapic_write(APIC_LVTT, v | APIC_LVT_MASKED);\n\tv = apic_read(APIC_LVT0);\n\tapic_write(APIC_LVT0, v | APIC_LVT_MASKED);\n\tv = apic_read(APIC_LVT1);\n\tapic_write(APIC_LVT1, v | APIC_LVT_MASKED);\n\tif (maxlvt >= 4) {\n\t\tv = apic_read(APIC_LVTPC);\n\t\tapic_write(APIC_LVTPC, v | APIC_LVT_MASKED);\n\t}\n\n\t \n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tif (maxlvt >= 5) {\n\t\tv = apic_read(APIC_LVTTHMR);\n\t\tapic_write(APIC_LVTTHMR, v | APIC_LVT_MASKED);\n\t}\n#endif\n#ifdef CONFIG_X86_MCE_INTEL\n\tif (maxlvt >= 6) {\n\t\tv = apic_read(APIC_LVTCMCI);\n\t\tif (!(v & APIC_LVT_MASKED))\n\t\t\tapic_write(APIC_LVTCMCI, v | APIC_LVT_MASKED);\n\t}\n#endif\n\n\t \n\tapic_write(APIC_LVTT, APIC_LVT_MASKED);\n\tapic_write(APIC_LVT0, APIC_LVT_MASKED);\n\tapic_write(APIC_LVT1, APIC_LVT_MASKED);\n\tif (maxlvt >= 3)\n\t\tapic_write(APIC_LVTERR, APIC_LVT_MASKED);\n\tif (maxlvt >= 4)\n\t\tapic_write(APIC_LVTPC, APIC_LVT_MASKED);\n\n\t \n\tif (lapic_is_integrated()) {\n\t\tif (maxlvt > 3)\n\t\t\t \n\t\t\tapic_write(APIC_ESR, 0);\n\t\tapic_read(APIC_ESR);\n\t}\n}\n\n \nvoid apic_soft_disable(void)\n{\n\tu32 value;\n\n\tclear_local_APIC();\n\n\t \n\tvalue = apic_read(APIC_SPIV);\n\tvalue &= ~APIC_SPIV_APIC_ENABLED;\n\tapic_write(APIC_SPIV, value);\n}\n\n \nvoid disable_local_APIC(void)\n{\n\tif (!apic_accessible())\n\t\treturn;\n\n\tapic_soft_disable();\n\n#ifdef CONFIG_X86_32\n\t \n\tif (enabled_via_apicbase) {\n\t\tunsigned int l, h;\n\n\t\trdmsr(MSR_IA32_APICBASE, l, h);\n\t\tl &= ~MSR_IA32_APICBASE_ENABLE;\n\t\twrmsr(MSR_IA32_APICBASE, l, h);\n\t}\n#endif\n}\n\n \nvoid lapic_shutdown(void)\n{\n\tunsigned long flags;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC) && !apic_from_smp_config())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n#ifdef CONFIG_X86_32\n\tif (!enabled_via_apicbase)\n\t\tclear_local_APIC();\n\telse\n#endif\n\t\tdisable_local_APIC();\n\n\n\tlocal_irq_restore(flags);\n}\n\n \nvoid __init sync_Arb_IDs(void)\n{\n\t \n\tif (modern_apic() || boot_cpu_data.x86_vendor == X86_VENDOR_AMD)\n\t\treturn;\n\n\t \n\tapic_wait_icr_idle();\n\n\tapic_printk(APIC_DEBUG, \"Synchronizing Arb IDs.\\n\");\n\tapic_write(APIC_ICR, APIC_DEST_ALLINC |\n\t\t\tAPIC_INT_LEVELTRIG | APIC_DM_INIT);\n}\n\nenum apic_intr_mode_id apic_intr_mode __ro_after_init;\n\nstatic int __init __apic_intr_mode_select(void)\n{\n\t \n\tif (apic_is_disabled) {\n\t\tpr_info(\"APIC disabled via kernel command line\\n\");\n\t\treturn APIC_PIC;\n\t}\n\n\t \n#ifdef CONFIG_X86_64\n\t \n\tif (!boot_cpu_has(X86_FEATURE_APIC)) {\n\t\tapic_is_disabled = true;\n\t\tpr_info(\"APIC disabled by BIOS\\n\");\n\t\treturn APIC_PIC;\n\t}\n#else\n\t \n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_APIC) && !smp_found_config) {\n\t\tapic_is_disabled = true;\n\t\treturn APIC_PIC;\n\t}\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_APIC) &&\n\t\tAPIC_INTEGRATED(boot_cpu_apic_version)) {\n\t\tapic_is_disabled = true;\n\t\tpr_err(FW_BUG \"Local APIC not detected, force emulation\\n\");\n\t\treturn APIC_PIC;\n\t}\n#endif\n\n\t \n\tif (!smp_found_config) {\n\t\tdisable_ioapic_support();\n\t\tif (!acpi_lapic) {\n\t\t\tpr_info(\"APIC: ACPI MADT or MP tables are not detected\\n\");\n\t\t\treturn APIC_VIRTUAL_WIRE_NO_CONFIG;\n\t\t}\n\t\treturn APIC_VIRTUAL_WIRE;\n\t}\n\n#ifdef CONFIG_SMP\n\t \n\tif (!setup_max_cpus) {\n\t\tpr_info(\"APIC: SMP mode deactivated\\n\");\n\t\treturn APIC_SYMMETRIC_IO_NO_ROUTING;\n\t}\n#endif\n\n\treturn APIC_SYMMETRIC_IO;\n}\n\n \nvoid __init apic_intr_mode_select(void)\n{\n\tapic_intr_mode = __apic_intr_mode_select();\n}\n\n \nvoid __init init_bsp_APIC(void)\n{\n\tunsigned int value;\n\n\t \n\tif (smp_found_config || !boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn;\n\n\t \n\tclear_local_APIC();\n\n\t \n\tvalue = apic_read(APIC_SPIV);\n\tvalue &= ~APIC_VECTOR_MASK;\n\tvalue |= APIC_SPIV_APIC_ENABLED;\n\n#ifdef CONFIG_X86_32\n\t \n\tif ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &&\n\t    (boot_cpu_data.x86 == 15))\n\t\tvalue &= ~APIC_SPIV_FOCUS_DISABLED;\n\telse\n#endif\n\t\tvalue |= APIC_SPIV_FOCUS_DISABLED;\n\tvalue |= SPURIOUS_APIC_VECTOR;\n\tapic_write(APIC_SPIV, value);\n\n\t \n\tapic_write(APIC_LVT0, APIC_DM_EXTINT);\n\tvalue = APIC_DM_NMI;\n\tif (!lapic_is_integrated())\t\t \n\t\tvalue |= APIC_LVT_LEVEL_TRIGGER;\n\tif (apic_extnmi == APIC_EXTNMI_NONE)\n\t\tvalue |= APIC_LVT_MASKED;\n\tapic_write(APIC_LVT1, value);\n}\n\nstatic void __init apic_bsp_setup(bool upmode);\n\n \nvoid __init apic_intr_mode_init(void)\n{\n\tbool upmode = IS_ENABLED(CONFIG_UP_LATE_INIT);\n\n\tswitch (apic_intr_mode) {\n\tcase APIC_PIC:\n\t\tpr_info(\"APIC: Keep in PIC mode(8259)\\n\");\n\t\treturn;\n\tcase APIC_VIRTUAL_WIRE:\n\t\tpr_info(\"APIC: Switch to virtual wire mode setup\\n\");\n\t\tbreak;\n\tcase APIC_VIRTUAL_WIRE_NO_CONFIG:\n\t\tpr_info(\"APIC: Switch to virtual wire mode setup with no configuration\\n\");\n\t\tupmode = true;\n\t\tbreak;\n\tcase APIC_SYMMETRIC_IO:\n\t\tpr_info(\"APIC: Switch to symmetric I/O mode setup\\n\");\n\t\tbreak;\n\tcase APIC_SYMMETRIC_IO_NO_ROUTING:\n\t\tpr_info(\"APIC: Switch to symmetric I/O mode setup in no SMP routine\\n\");\n\t\tbreak;\n\t}\n\n\tx86_64_probe_apic();\n\n\tx86_32_install_bigsmp();\n\n\tif (x86_platform.apic_post_init)\n\t\tx86_platform.apic_post_init();\n\n\tapic_bsp_setup(upmode);\n}\n\nstatic void lapic_setup_esr(void)\n{\n\tunsigned int oldvalue, value, maxlvt;\n\n\tif (!lapic_is_integrated()) {\n\t\tpr_info(\"No ESR for 82489DX.\\n\");\n\t\treturn;\n\t}\n\n\tif (apic->disable_esr) {\n\t\t \n\t\tpr_info(\"Leaving ESR disabled.\\n\");\n\t\treturn;\n\t}\n\n\tmaxlvt = lapic_get_maxlvt();\n\tif (maxlvt > 3)\t\t \n\t\tapic_write(APIC_ESR, 0);\n\toldvalue = apic_read(APIC_ESR);\n\n\t \n\tvalue = ERROR_APIC_VECTOR;\n\tapic_write(APIC_LVTERR, value);\n\n\t \n\tif (maxlvt > 3)\n\t\tapic_write(APIC_ESR, 0);\n\tvalue = apic_read(APIC_ESR);\n\tif (value != oldvalue)\n\t\tapic_printk(APIC_VERBOSE, \"ESR value before enabling \"\n\t\t\t\"vector: 0x%08x  after: 0x%08x\\n\",\n\t\t\toldvalue, value);\n}\n\n#define APIC_IR_REGS\t\tAPIC_ISR_NR\n#define APIC_IR_BITS\t\t(APIC_IR_REGS * 32)\n#define APIC_IR_MAPSIZE\t\t(APIC_IR_BITS / BITS_PER_LONG)\n\nunion apic_ir {\n\tunsigned long\tmap[APIC_IR_MAPSIZE];\n\tu32\t\tregs[APIC_IR_REGS];\n};\n\nstatic bool apic_check_and_ack(union apic_ir *irr, union apic_ir *isr)\n{\n\tint i, bit;\n\n\t \n\tfor (i = 0; i < APIC_IR_REGS; i++)\n\t\tirr->regs[i] = apic_read(APIC_IRR + i * 0x10);\n\n\t \n\tfor (i = 0; i < APIC_IR_REGS; i++)\n\t\tisr->regs[i] = apic_read(APIC_ISR + i * 0x10);\n\n\t \n\tif (!bitmap_empty(isr->map, APIC_IR_BITS)) {\n\t\t \n\t\tfor_each_set_bit(bit, isr->map, APIC_IR_BITS)\n\t\t\tapic_eoi();\n\t\treturn true;\n\t}\n\n\treturn !bitmap_empty(irr->map, APIC_IR_BITS);\n}\n\n \nstatic void apic_pending_intr_clear(void)\n{\n\tunion apic_ir irr, isr;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < 512; i++) {\n\t\tif (!apic_check_and_ack(&irr, &isr))\n\t\t\treturn;\n\t}\n\t \n\tpr_warn(\"APIC: Stale IRR: %256pb ISR: %256pb\\n\", irr.map, isr.map);\n}\n\n \nstatic void setup_local_APIC(void)\n{\n\tint cpu = smp_processor_id();\n\tunsigned int value;\n\n\tif (apic_is_disabled) {\n\t\tdisable_ioapic_support();\n\t\treturn;\n\t}\n\n\t \n\tvalue = apic_read(APIC_SPIV);\n\tvalue &= ~APIC_SPIV_APIC_ENABLED;\n\tapic_write(APIC_SPIV, value);\n\n#ifdef CONFIG_X86_32\n\t \n\tif (lapic_is_integrated() && apic->disable_esr) {\n\t\tapic_write(APIC_ESR, 0);\n\t\tapic_write(APIC_ESR, 0);\n\t\tapic_write(APIC_ESR, 0);\n\t\tapic_write(APIC_ESR, 0);\n\t}\n#endif\n\t \n\tBUG_ON(apic->apic_id_registered && !apic->apic_id_registered());\n\n\t \n\tif (apic->init_apic_ldr)\n\t\tapic->init_apic_ldr();\n\n\t \n\tvalue = apic_read(APIC_TASKPRI);\n\tvalue &= ~APIC_TPRI_MASK;\n\tvalue |= 0x10;\n\tapic_write(APIC_TASKPRI, value);\n\n\t \n\tapic_pending_intr_clear();\n\n\t \n\tvalue = apic_read(APIC_SPIV);\n\tvalue &= ~APIC_VECTOR_MASK;\n\t \n\tvalue |= APIC_SPIV_APIC_ENABLED;\n\n#ifdef CONFIG_X86_32\n\t \n\t \n\n\t \n\tvalue &= ~APIC_SPIV_FOCUS_DISABLED;\n#endif\n\n\t \n\tvalue |= SPURIOUS_APIC_VECTOR;\n\tapic_write(APIC_SPIV, value);\n\n\tperf_events_lapic_init();\n\n\t \n\t \n\tvalue = apic_read(APIC_LVT0) & APIC_LVT_MASKED;\n\tif (!cpu && (pic_mode || !value || ioapic_is_disabled)) {\n\t\tvalue = APIC_DM_EXTINT;\n\t\tapic_printk(APIC_VERBOSE, \"enabled ExtINT on CPU#%d\\n\", cpu);\n\t} else {\n\t\tvalue = APIC_DM_EXTINT | APIC_LVT_MASKED;\n\t\tapic_printk(APIC_VERBOSE, \"masked ExtINT on CPU#%d\\n\", cpu);\n\t}\n\tapic_write(APIC_LVT0, value);\n\n\t \n\tif ((!cpu && apic_extnmi != APIC_EXTNMI_NONE) ||\n\t    apic_extnmi == APIC_EXTNMI_ALL)\n\t\tvalue = APIC_DM_NMI;\n\telse\n\t\tvalue = APIC_DM_NMI | APIC_LVT_MASKED;\n\n\t \n\tif (!lapic_is_integrated())\n\t\tvalue |= APIC_LVT_LEVEL_TRIGGER;\n\tapic_write(APIC_LVT1, value);\n\n#ifdef CONFIG_X86_MCE_INTEL\n\t \n\tif (!cpu)\n\t\tcmci_recheck();\n#endif\n}\n\nstatic void end_local_APIC_setup(void)\n{\n\tlapic_setup_esr();\n\n#ifdef CONFIG_X86_32\n\t{\n\t\tunsigned int value;\n\t\t \n\t\tvalue = apic_read(APIC_LVTT);\n\t\tvalue |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);\n\t\tapic_write(APIC_LVTT, value);\n\t}\n#endif\n\n\tapic_pm_activate();\n}\n\n \nvoid apic_ap_setup(void)\n{\n\tsetup_local_APIC();\n\tend_local_APIC_setup();\n}\n\nstatic __init void cpu_set_boot_apic(void);\n\nstatic __init void apic_read_boot_cpu_id(bool x2apic)\n{\n\t \n\tif (x2apic) {\n\t\tboot_cpu_physical_apicid = native_apic_msr_read(APIC_ID);\n\t\tboot_cpu_apic_version = GET_APIC_VERSION(native_apic_msr_read(APIC_LVR));\n\t} else {\n\t\tboot_cpu_physical_apicid = read_apic_id();\n\t\tboot_cpu_apic_version = GET_APIC_VERSION(apic_read(APIC_LVR));\n\t}\n\tcpu_set_boot_apic();\n}\n\n#ifdef CONFIG_X86_X2APIC\nint x2apic_mode;\nEXPORT_SYMBOL_GPL(x2apic_mode);\n\nenum {\n\tX2APIC_OFF,\n\tX2APIC_DISABLED,\n\t \n\tX2APIC_ON,\n\tX2APIC_ON_LOCKED\n};\nstatic int x2apic_state;\n\nstatic bool x2apic_hw_locked(void)\n{\n\tu64 ia32_cap;\n\tu64 msr;\n\n\tia32_cap = x86_read_arch_cap_msr();\n\tif (ia32_cap & ARCH_CAP_XAPIC_DISABLE) {\n\t\trdmsrl(MSR_IA32_XAPIC_DISABLE_STATUS, msr);\n\t\treturn (msr & LEGACY_XAPIC_DISABLED);\n\t}\n\treturn false;\n}\n\nstatic void __x2apic_disable(void)\n{\n\tu64 msr;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn;\n\n\trdmsrl(MSR_IA32_APICBASE, msr);\n\tif (!(msr & X2APIC_ENABLE))\n\t\treturn;\n\t \n\twrmsrl(MSR_IA32_APICBASE, msr & ~(X2APIC_ENABLE | XAPIC_ENABLE));\n\twrmsrl(MSR_IA32_APICBASE, msr & ~X2APIC_ENABLE);\n\tprintk_once(KERN_INFO \"x2apic disabled\\n\");\n}\n\nstatic void __x2apic_enable(void)\n{\n\tu64 msr;\n\n\trdmsrl(MSR_IA32_APICBASE, msr);\n\tif (msr & X2APIC_ENABLE)\n\t\treturn;\n\twrmsrl(MSR_IA32_APICBASE, msr | X2APIC_ENABLE);\n\tprintk_once(KERN_INFO \"x2apic enabled\\n\");\n}\n\nstatic int __init setup_nox2apic(char *str)\n{\n\tif (x2apic_enabled()) {\n\t\tint apicid = native_apic_msr_read(APIC_ID);\n\n\t\tif (apicid >= 255) {\n\t\t\tpr_warn(\"Apicid: %08x, cannot enforce nox2apic\\n\",\n\t\t\t\tapicid);\n\t\t\treturn 0;\n\t\t}\n\t\tif (x2apic_hw_locked()) {\n\t\t\tpr_warn(\"APIC locked in x2apic mode, can't disable\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn(\"x2apic already enabled.\\n\");\n\t\t__x2apic_disable();\n\t}\n\tsetup_clear_cpu_cap(X86_FEATURE_X2APIC);\n\tx2apic_state = X2APIC_DISABLED;\n\tx2apic_mode = 0;\n\treturn 0;\n}\nearly_param(\"nox2apic\", setup_nox2apic);\n\n \nvoid x2apic_setup(void)\n{\n\t \n\tif (x2apic_state != X2APIC_ON_LOCKED && x2apic_hw_locked())\n\t\tpr_warn(\"x2apic lock mismatch between BSP and AP.\\n\");\n\t \n\tif (x2apic_state < X2APIC_ON) {\n\t\t__x2apic_disable();\n\t\treturn;\n\t}\n\t__x2apic_enable();\n}\n\nstatic __init void apic_set_fixmap(void);\n\nstatic __init void x2apic_disable(void)\n{\n\tu32 x2apic_id, state = x2apic_state;\n\n\tx2apic_mode = 0;\n\tx2apic_state = X2APIC_DISABLED;\n\n\tif (state != X2APIC_ON)\n\t\treturn;\n\n\tx2apic_id = read_apic_id();\n\tif (x2apic_id >= 255)\n\t\tpanic(\"Cannot disable x2apic, id: %08x\\n\", x2apic_id);\n\n\tif (x2apic_hw_locked()) {\n\t\tpr_warn(\"Cannot disable locked x2apic, id: %08x\\n\", x2apic_id);\n\t\treturn;\n\t}\n\n\t__x2apic_disable();\n\tapic_set_fixmap();\n}\n\nstatic __init void x2apic_enable(void)\n{\n\tif (x2apic_state != X2APIC_OFF)\n\t\treturn;\n\n\tx2apic_mode = 1;\n\tx2apic_state = X2APIC_ON;\n\t__x2apic_enable();\n}\n\nstatic __init void try_to_enable_x2apic(int remap_mode)\n{\n\tif (x2apic_state == X2APIC_DISABLED)\n\t\treturn;\n\n\tif (remap_mode != IRQ_REMAP_X2APIC_MODE) {\n\t\tu32 apic_limit = 255;\n\n\t\t \n\t\tif (!x86_init.hyper.x2apic_available()) {\n\t\t\tpr_info(\"x2apic: IRQ remapping doesn't support X2APIC mode\\n\");\n\t\t\tx2apic_disable();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (x86_init.hyper.msi_ext_dest_id()) {\n\t\t\tvirt_ext_dest_id = 1;\n\t\t\tapic_limit = 32767;\n\t\t}\n\n\t\t \n\t\tx2apic_set_max_apicid(apic_limit);\n\t\tx2apic_phys = 1;\n\t}\n\tx2apic_enable();\n}\n\nvoid __init check_x2apic(void)\n{\n\tif (x2apic_enabled()) {\n\t\tpr_info(\"x2apic: enabled by BIOS, switching to x2apic ops\\n\");\n\t\tx2apic_mode = 1;\n\t\tif (x2apic_hw_locked())\n\t\t\tx2apic_state = X2APIC_ON_LOCKED;\n\t\telse\n\t\t\tx2apic_state = X2APIC_ON;\n\t\tapic_read_boot_cpu_id(true);\n\t} else if (!boot_cpu_has(X86_FEATURE_X2APIC)) {\n\t\tx2apic_state = X2APIC_DISABLED;\n\t}\n}\n#else  \nvoid __init check_x2apic(void)\n{\n\tif (!apic_is_x2apic_enabled())\n\t\treturn;\n\t \n\tpr_err(\"Kernel does not support x2APIC, please recompile with CONFIG_X86_X2APIC.\\n\");\n\tpr_err(\"Disabling APIC, expect reduced performance and functionality.\\n\");\n\n\tapic_is_disabled = true;\n\tsetup_clear_cpu_cap(X86_FEATURE_APIC);\n}\n\nstatic inline void try_to_enable_x2apic(int remap_mode) { }\nstatic inline void __x2apic_enable(void) { }\n#endif  \n\nvoid __init enable_IR_x2apic(void)\n{\n\tunsigned long flags;\n\tint ret, ir_stat;\n\n\tif (ioapic_is_disabled) {\n\t\tpr_info(\"Not enabling interrupt remapping due to skipped IO-APIC setup\\n\");\n\t\treturn;\n\t}\n\n\tir_stat = irq_remapping_prepare();\n\tif (ir_stat < 0 && !x2apic_supported())\n\t\treturn;\n\n\tret = save_ioapic_entries();\n\tif (ret) {\n\t\tpr_info(\"Saving IO-APIC state failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tlegacy_pic->mask_all();\n\tmask_ioapic_entries();\n\n\t \n\tif (ir_stat >= 0)\n\t\tir_stat = irq_remapping_enable();\n\t \n\ttry_to_enable_x2apic(ir_stat);\n\n\tif (ir_stat < 0)\n\t\trestore_ioapic_entries();\n\tlegacy_pic->restore_mask();\n\tlocal_irq_restore(flags);\n}\n\n#ifdef CONFIG_X86_64\n \nstatic bool __init detect_init_APIC(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_APIC)) {\n\t\tpr_info(\"No local APIC present\\n\");\n\t\treturn false;\n\t}\n\n\tregister_lapic_address(APIC_DEFAULT_PHYS_BASE);\n\treturn true;\n}\n#else\n\nstatic bool __init apic_verify(unsigned long addr)\n{\n\tu32 features, h, l;\n\n\t \n\tfeatures = cpuid_edx(1);\n\tif (!(features & (1 << X86_FEATURE_APIC))) {\n\t\tpr_warn(\"Could not enable APIC!\\n\");\n\t\treturn false;\n\t}\n\tset_cpu_cap(&boot_cpu_data, X86_FEATURE_APIC);\n\n\t \n\tif (boot_cpu_data.x86 >= 6) {\n\t\trdmsr(MSR_IA32_APICBASE, l, h);\n\t\tif (l & MSR_IA32_APICBASE_ENABLE)\n\t\t\taddr = l & MSR_IA32_APICBASE_BASE;\n\t}\n\n\tregister_lapic_address(addr);\n\tpr_info(\"Found and enabled local APIC!\\n\");\n\treturn true;\n}\n\nbool __init apic_force_enable(unsigned long addr)\n{\n\tu32 h, l;\n\n\tif (apic_is_disabled)\n\t\treturn false;\n\n\t \n\tif (boot_cpu_data.x86 >= 6) {\n\t\trdmsr(MSR_IA32_APICBASE, l, h);\n\t\tif (!(l & MSR_IA32_APICBASE_ENABLE)) {\n\t\t\tpr_info(\"Local APIC disabled by BIOS -- reenabling.\\n\");\n\t\t\tl &= ~MSR_IA32_APICBASE_BASE;\n\t\t\tl |= MSR_IA32_APICBASE_ENABLE | addr;\n\t\t\twrmsr(MSR_IA32_APICBASE, l, h);\n\t\t\tenabled_via_apicbase = 1;\n\t\t}\n\t}\n\treturn apic_verify(addr);\n}\n\n \nstatic bool __init detect_init_APIC(void)\n{\n\t \n\tif (apic_is_disabled)\n\t\treturn false;\n\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_AMD:\n\t\tif ((boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model > 1) ||\n\t\t    (boot_cpu_data.x86 >= 15))\n\t\t\tbreak;\n\t\tgoto no_apic;\n\tcase X86_VENDOR_HYGON:\n\t\tbreak;\n\tcase X86_VENDOR_INTEL:\n\t\tif (boot_cpu_data.x86 == 6 || boot_cpu_data.x86 == 15 ||\n\t\t    (boot_cpu_data.x86 == 5 && boot_cpu_has(X86_FEATURE_APIC)))\n\t\t\tbreak;\n\t\tgoto no_apic;\n\tdefault:\n\t\tgoto no_apic;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC)) {\n\t\t \n\t\tif (!force_enable_local_apic) {\n\t\t\tpr_info(\"Local APIC disabled by BIOS -- \"\n\t\t\t\t\"you can enable it with \\\"lapic\\\"\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!apic_force_enable(APIC_DEFAULT_PHYS_BASE))\n\t\t\treturn false;\n\t} else {\n\t\tif (!apic_verify(APIC_DEFAULT_PHYS_BASE))\n\t\t\treturn false;\n\t}\n\n\tapic_pm_activate();\n\n\treturn true;\n\nno_apic:\n\tpr_info(\"No local APIC present or hardware disabled\\n\");\n\treturn false;\n}\n#endif\n\n \nvoid __init init_apic_mappings(void)\n{\n\tif (apic_validate_deadline_timer())\n\t\tpr_info(\"TSC deadline timer available\\n\");\n\n\tif (x2apic_mode)\n\t\treturn;\n\n\tif (!smp_found_config) {\n\t\tif (!detect_init_APIC()) {\n\t\t\tpr_info(\"APIC: disable apic facility\\n\");\n\t\t\tapic_disable();\n\t\t}\n\t\tnum_processors = 1;\n\t}\n}\n\nstatic __init void apic_set_fixmap(void)\n{\n\tset_fixmap_nocache(FIX_APIC_BASE, mp_lapic_addr);\n\tapic_mmio_base = APIC_BASE;\n\tapic_printk(APIC_VERBOSE, \"mapped APIC to %16lx (%16lx)\\n\",\n\t\t    apic_mmio_base, mp_lapic_addr);\n\tapic_read_boot_cpu_id(false);\n}\n\nvoid __init register_lapic_address(unsigned long address)\n{\n\t \n\tWARN_ON_ONCE(mp_lapic_addr);\n\tmp_lapic_addr = address;\n\n\tif (!x2apic_mode)\n\t\tapic_set_fixmap();\n}\n\n \n\n \nstatic noinline void handle_spurious_interrupt(u8 vector)\n{\n\tu32 v;\n\n\ttrace_spurious_apic_entry(vector);\n\n\tinc_irq_stat(irq_spurious_count);\n\n\t \n\tif (vector == SPURIOUS_APIC_VECTOR) {\n\t\t \n\t\tpr_info(\"Spurious APIC interrupt (vector 0xFF) on CPU#%d, should never happen.\\n\",\n\t\t\tsmp_processor_id());\n\t\tgoto out;\n\t}\n\n\t \n\tv = apic_read(APIC_ISR + ((vector & ~0x1f) >> 1));\n\tif (v & (1 << (vector & 0x1f))) {\n\t\tpr_info(\"Spurious interrupt (vector 0x%02x) on CPU#%d. Acked\\n\",\n\t\t\tvector, smp_processor_id());\n\t\tapic_eoi();\n\t} else {\n\t\tpr_info(\"Spurious interrupt (vector 0x%02x) on CPU#%d. Not pending!\\n\",\n\t\t\tvector, smp_processor_id());\n\t}\nout:\n\ttrace_spurious_apic_exit(vector);\n}\n\n \nDEFINE_IDTENTRY_IRQ(spurious_interrupt)\n{\n\thandle_spurious_interrupt(vector);\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_spurious_apic_interrupt)\n{\n\thandle_spurious_interrupt(SPURIOUS_APIC_VECTOR);\n}\n\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_error_interrupt)\n{\n\tstatic const char * const error_interrupt_reason[] = {\n\t\t\"Send CS error\",\t\t \n\t\t\"Receive CS error\",\t\t \n\t\t\"Send accept error\",\t\t \n\t\t\"Receive accept error\",\t\t \n\t\t\"Redirectable IPI\",\t\t \n\t\t\"Send illegal vector\",\t\t \n\t\t\"Received illegal vector\",\t \n\t\t\"Illegal register address\",\t \n\t};\n\tu32 v, i = 0;\n\n\ttrace_error_apic_entry(ERROR_APIC_VECTOR);\n\n\t \n\tif (lapic_get_maxlvt() > 3)\t \n\t\tapic_write(APIC_ESR, 0);\n\tv = apic_read(APIC_ESR);\n\tapic_eoi();\n\tatomic_inc(&irq_err_count);\n\n\tapic_printk(APIC_DEBUG, KERN_DEBUG \"APIC error on CPU%d: %02x\",\n\t\t    smp_processor_id(), v);\n\n\tv &= 0xff;\n\twhile (v) {\n\t\tif (v & 0x1)\n\t\t\tapic_printk(APIC_DEBUG, KERN_CONT \" : %s\", error_interrupt_reason[i]);\n\t\ti++;\n\t\tv >>= 1;\n\t}\n\n\tapic_printk(APIC_DEBUG, KERN_CONT \"\\n\");\n\n\ttrace_error_apic_exit(ERROR_APIC_VECTOR);\n}\n\n \nstatic void __init connect_bsp_APIC(void)\n{\n#ifdef CONFIG_X86_32\n\tif (pic_mode) {\n\t\t \n\t\tclear_local_APIC();\n\t\t \n\t\tapic_printk(APIC_VERBOSE, \"leaving PIC mode, \"\n\t\t\t\t\"enabling APIC mode.\\n\");\n\t\timcr_pic_to_apic();\n\t}\n#endif\n}\n\n \nvoid disconnect_bsp_APIC(int virt_wire_setup)\n{\n\tunsigned int value;\n\n#ifdef CONFIG_X86_32\n\tif (pic_mode) {\n\t\t \n\t\tapic_printk(APIC_VERBOSE, \"disabling APIC mode, \"\n\t\t\t\t\"entering PIC mode.\\n\");\n\t\timcr_apic_to_pic();\n\t\treturn;\n\t}\n#endif\n\n\t \n\n\t \n\tvalue = apic_read(APIC_SPIV);\n\tvalue &= ~APIC_VECTOR_MASK;\n\tvalue |= APIC_SPIV_APIC_ENABLED;\n\tvalue |= 0xf;\n\tapic_write(APIC_SPIV, value);\n\n\tif (!virt_wire_setup) {\n\t\t \n\t\tvalue = apic_read(APIC_LVT0);\n\t\tvalue &= ~(APIC_MODE_MASK | APIC_SEND_PENDING |\n\t\t\tAPIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR |\n\t\t\tAPIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);\n\t\tvalue |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;\n\t\tvalue = SET_APIC_DELIVERY_MODE(value, APIC_MODE_EXTINT);\n\t\tapic_write(APIC_LVT0, value);\n\t} else {\n\t\t \n\t\tapic_write(APIC_LVT0, APIC_LVT_MASKED);\n\t}\n\n\t \n\tvalue = apic_read(APIC_LVT1);\n\tvalue &= ~(APIC_MODE_MASK | APIC_SEND_PENDING |\n\t\t\tAPIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR |\n\t\t\tAPIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);\n\tvalue |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;\n\tvalue = SET_APIC_DELIVERY_MODE(value, APIC_MODE_NMI);\n\tapic_write(APIC_LVT1, value);\n}\n\n \nstatic int nr_logical_cpuids = 1;\n\n \nint cpuid_to_apicid[] = {\n\t[0 ... NR_CPUS - 1] = -1,\n};\n\nbool arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n\treturn phys_id == cpuid_to_apicid[cpu];\n}\n\n#ifdef CONFIG_SMP\nstatic void cpu_mark_primary_thread(unsigned int cpu, unsigned int apicid)\n{\n\t \n\tu32 mask = (1U << (fls(smp_num_siblings) - 1)) - 1;\n\n\tif (smp_num_siblings == 1 || !(apicid & mask))\n\t\tcpumask_set_cpu(cpu, &__cpu_primary_thread_mask);\n}\n\n \nstatic int __init smp_init_primary_thread_mask(void)\n{\n\tunsigned int cpu;\n\n\t \n\tif (xen_pv_domain()) {\n\t\tcpumask_copy(&__cpu_primary_thread_mask, cpu_possible_mask);\n\t\treturn 0;\n\t}\n\n\tfor (cpu = 0; cpu < nr_logical_cpuids; cpu++)\n\t\tcpu_mark_primary_thread(cpu, cpuid_to_apicid[cpu]);\n\treturn 0;\n}\nearly_initcall(smp_init_primary_thread_mask);\n#else\nstatic inline void cpu_mark_primary_thread(unsigned int cpu, unsigned int apicid) { }\n#endif\n\n \nstatic int allocate_logical_cpuid(int apicid)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nr_logical_cpuids; i++) {\n\t\tif (cpuid_to_apicid[i] == apicid)\n\t\t\treturn i;\n\t}\n\n\t \n\tif (nr_logical_cpuids >= nr_cpu_ids) {\n\t\tWARN_ONCE(1, \"APIC: NR_CPUS/possible_cpus limit of %u reached. \"\n\t\t\t     \"Processor %d/0x%x and the rest are ignored.\\n\",\n\t\t\t     nr_cpu_ids, nr_logical_cpuids, apicid);\n\t\treturn -EINVAL;\n\t}\n\n\tcpuid_to_apicid[nr_logical_cpuids] = apicid;\n\treturn nr_logical_cpuids++;\n}\n\nstatic void cpu_update_apic(int cpu, int apicid)\n{\n#if defined(CONFIG_SMP) || defined(CONFIG_X86_64)\n\tearly_per_cpu(x86_cpu_to_apicid, cpu) = apicid;\n#endif\n\tset_cpu_possible(cpu, true);\n\tphysid_set(apicid, phys_cpu_present_map);\n\tset_cpu_present(cpu, true);\n\tnum_processors++;\n\n\tif (system_state != SYSTEM_BOOTING)\n\t\tcpu_mark_primary_thread(cpu, apicid);\n}\n\nstatic __init void cpu_set_boot_apic(void)\n{\n\tcpuid_to_apicid[0] = boot_cpu_physical_apicid;\n\tcpu_update_apic(0, boot_cpu_physical_apicid);\n\tx86_32_probe_bigsmp_early();\n}\n\nint generic_processor_info(int apicid)\n{\n\tint cpu, max = nr_cpu_ids;\n\n\t \n\tif (cpuid_to_apicid[0] == BAD_APICID)\n\t\tpanic(\"Boot CPU APIC not registered yet\\n\");\n\n\tif (apicid == boot_cpu_physical_apicid)\n\t\treturn 0;\n\n\tif (disabled_cpu_apicid == apicid) {\n\t\tint thiscpu = num_processors + disabled_cpus;\n\n\t\tpr_warn(\"APIC: Disabling requested cpu. Processor %d/0x%x ignored.\\n\",\n\t\t\tthiscpu, apicid);\n\n\t\tdisabled_cpus++;\n\t\treturn -ENODEV;\n\t}\n\n\tif (num_processors >= nr_cpu_ids) {\n\t\tint thiscpu = max + disabled_cpus;\n\n\t\tpr_warn(\"APIC: NR_CPUS/possible_cpus limit of %i reached. \"\n\t\t\t\"Processor %d/0x%x ignored.\\n\", max, thiscpu, apicid);\n\n\t\tdisabled_cpus++;\n\t\treturn -EINVAL;\n\t}\n\n\tcpu = allocate_logical_cpuid(apicid);\n\tif (cpu < 0) {\n\t\tdisabled_cpus++;\n\t\treturn -EINVAL;\n\t}\n\n\tcpu_update_apic(cpu, apicid);\n\treturn cpu;\n}\n\n\nvoid __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,\n\t\t\t   bool dmar)\n{\n\tmemset(msg, 0, sizeof(*msg));\n\n\tmsg->arch_addr_lo.base_address = X86_MSI_BASE_ADDRESS_LOW;\n\tmsg->arch_addr_lo.dest_mode_logical = apic->dest_mode_logical;\n\tmsg->arch_addr_lo.destid_0_7 = cfg->dest_apicid & 0xFF;\n\n\tmsg->arch_data.delivery_mode = APIC_DELIVERY_MODE_FIXED;\n\tmsg->arch_data.vector = cfg->vector;\n\n\tmsg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;\n\t \n\tif (dmar)\n\t\tmsg->arch_addr_hi.destid_8_31 = cfg->dest_apicid >> 8;\n\telse if (virt_ext_dest_id && cfg->dest_apicid < 0x8000)\n\t\tmsg->arch_addr_lo.virt_destid_8_14 = cfg->dest_apicid >> 8;\n\telse\n\t\tWARN_ON_ONCE(cfg->dest_apicid > 0xFF);\n}\n\nu32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid)\n{\n\tu32 dest = msg->arch_addr_lo.destid_0_7;\n\n\tif (extid)\n\t\tdest |= msg->arch_addr_hi.destid_8_31 << 8;\n\treturn dest;\n}\nEXPORT_SYMBOL_GPL(x86_msi_msg_get_destid);\n\nstatic void __init apic_bsp_up_setup(void)\n{\n#ifdef CONFIG_X86_64\n\tapic_write(APIC_ID, apic->set_apic_id(boot_cpu_physical_apicid));\n#endif\n\tphysid_set_mask_of_physid(boot_cpu_physical_apicid, &phys_cpu_present_map);\n}\n\n \nstatic void __init apic_bsp_setup(bool upmode)\n{\n\tconnect_bsp_APIC();\n\tif (upmode)\n\t\tapic_bsp_up_setup();\n\tsetup_local_APIC();\n\n\tenable_IO_APIC();\n\tend_local_APIC_setup();\n\tirq_remap_enable_fault_handling();\n\tsetup_IO_APIC();\n\tlapic_update_legacy_vectors();\n}\n\n#ifdef CONFIG_UP_LATE_INIT\nvoid __init up_late_init(void)\n{\n\tif (apic_intr_mode == APIC_PIC)\n\t\treturn;\n\n\t \n\tx86_init.timers.setup_percpu_clockev();\n}\n#endif\n\n \n#ifdef CONFIG_PM\n\nstatic struct {\n\t \n\tint active;\n\t \n\tunsigned int apic_id;\n\tunsigned int apic_taskpri;\n\tunsigned int apic_ldr;\n\tunsigned int apic_dfr;\n\tunsigned int apic_spiv;\n\tunsigned int apic_lvtt;\n\tunsigned int apic_lvtpc;\n\tunsigned int apic_lvt0;\n\tunsigned int apic_lvt1;\n\tunsigned int apic_lvterr;\n\tunsigned int apic_tmict;\n\tunsigned int apic_tdcr;\n\tunsigned int apic_thmr;\n\tunsigned int apic_cmci;\n} apic_pm_state;\n\nstatic int lapic_suspend(void)\n{\n\tunsigned long flags;\n\tint maxlvt;\n\n\tif (!apic_pm_state.active)\n\t\treturn 0;\n\n\tmaxlvt = lapic_get_maxlvt();\n\n\tapic_pm_state.apic_id = apic_read(APIC_ID);\n\tapic_pm_state.apic_taskpri = apic_read(APIC_TASKPRI);\n\tapic_pm_state.apic_ldr = apic_read(APIC_LDR);\n\tapic_pm_state.apic_dfr = apic_read(APIC_DFR);\n\tapic_pm_state.apic_spiv = apic_read(APIC_SPIV);\n\tapic_pm_state.apic_lvtt = apic_read(APIC_LVTT);\n\tif (maxlvt >= 4)\n\t\tapic_pm_state.apic_lvtpc = apic_read(APIC_LVTPC);\n\tapic_pm_state.apic_lvt0 = apic_read(APIC_LVT0);\n\tapic_pm_state.apic_lvt1 = apic_read(APIC_LVT1);\n\tapic_pm_state.apic_lvterr = apic_read(APIC_LVTERR);\n\tapic_pm_state.apic_tmict = apic_read(APIC_TMICT);\n\tapic_pm_state.apic_tdcr = apic_read(APIC_TDCR);\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tif (maxlvt >= 5)\n\t\tapic_pm_state.apic_thmr = apic_read(APIC_LVTTHMR);\n#endif\n#ifdef CONFIG_X86_MCE_INTEL\n\tif (maxlvt >= 6)\n\t\tapic_pm_state.apic_cmci = apic_read(APIC_LVTCMCI);\n#endif\n\n\tlocal_irq_save(flags);\n\n\t \n\tmask_ioapic_entries();\n\n\tdisable_local_APIC();\n\n\tirq_remapping_disable();\n\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\nstatic void lapic_resume(void)\n{\n\tunsigned int l, h;\n\tunsigned long flags;\n\tint maxlvt;\n\n\tif (!apic_pm_state.active)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\t \n\tmask_ioapic_entries();\n\tlegacy_pic->mask_all();\n\n\tif (x2apic_mode) {\n\t\t__x2apic_enable();\n\t} else {\n\t\t \n\t\tif (boot_cpu_data.x86 >= 6) {\n\t\t\trdmsr(MSR_IA32_APICBASE, l, h);\n\t\t\tl &= ~MSR_IA32_APICBASE_BASE;\n\t\t\tl |= MSR_IA32_APICBASE_ENABLE | mp_lapic_addr;\n\t\t\twrmsr(MSR_IA32_APICBASE, l, h);\n\t\t}\n\t}\n\n\tmaxlvt = lapic_get_maxlvt();\n\tapic_write(APIC_LVTERR, ERROR_APIC_VECTOR | APIC_LVT_MASKED);\n\tapic_write(APIC_ID, apic_pm_state.apic_id);\n\tapic_write(APIC_DFR, apic_pm_state.apic_dfr);\n\tapic_write(APIC_LDR, apic_pm_state.apic_ldr);\n\tapic_write(APIC_TASKPRI, apic_pm_state.apic_taskpri);\n\tapic_write(APIC_SPIV, apic_pm_state.apic_spiv);\n\tapic_write(APIC_LVT0, apic_pm_state.apic_lvt0);\n\tapic_write(APIC_LVT1, apic_pm_state.apic_lvt1);\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tif (maxlvt >= 5)\n\t\tapic_write(APIC_LVTTHMR, apic_pm_state.apic_thmr);\n#endif\n#ifdef CONFIG_X86_MCE_INTEL\n\tif (maxlvt >= 6)\n\t\tapic_write(APIC_LVTCMCI, apic_pm_state.apic_cmci);\n#endif\n\tif (maxlvt >= 4)\n\t\tapic_write(APIC_LVTPC, apic_pm_state.apic_lvtpc);\n\tapic_write(APIC_LVTT, apic_pm_state.apic_lvtt);\n\tapic_write(APIC_TDCR, apic_pm_state.apic_tdcr);\n\tapic_write(APIC_TMICT, apic_pm_state.apic_tmict);\n\tapic_write(APIC_ESR, 0);\n\tapic_read(APIC_ESR);\n\tapic_write(APIC_LVTERR, apic_pm_state.apic_lvterr);\n\tapic_write(APIC_ESR, 0);\n\tapic_read(APIC_ESR);\n\n\tirq_remapping_reenable(x2apic_mode);\n\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic struct syscore_ops lapic_syscore_ops = {\n\t.resume\t\t= lapic_resume,\n\t.suspend\t= lapic_suspend,\n};\n\nstatic void apic_pm_activate(void)\n{\n\tapic_pm_state.active = 1;\n}\n\nstatic int __init init_lapic_sysfs(void)\n{\n\t \n\tif (boot_cpu_has(X86_FEATURE_APIC))\n\t\tregister_syscore_ops(&lapic_syscore_ops);\n\n\treturn 0;\n}\n\n \ncore_initcall(init_lapic_sysfs);\n\n#else\t \n\nstatic void apic_pm_activate(void) { }\n\n#endif\t \n\n#ifdef CONFIG_X86_64\n\nstatic int multi_checked;\nstatic int multi;\n\nstatic int set_multi(const struct dmi_system_id *d)\n{\n\tif (multi)\n\t\treturn 0;\n\tpr_info(\"APIC: %s detected, Multi Chassis\\n\", d->ident);\n\tmulti = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id multi_dmi_table[] = {\n\t{\n\t\t.callback = set_multi,\n\t\t.ident = \"IBM System Summit2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Summit2\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic void dmi_check_multi(void)\n{\n\tif (multi_checked)\n\t\treturn;\n\n\tdmi_check_system(multi_dmi_table);\n\tmulti_checked = 1;\n}\n\n \nint apic_is_clustered_box(void)\n{\n\tdmi_check_multi();\n\treturn multi;\n}\n#endif\n\n \nstatic int __init setup_disableapic(char *arg)\n{\n\tapic_is_disabled = true;\n\tsetup_clear_cpu_cap(X86_FEATURE_APIC);\n\treturn 0;\n}\nearly_param(\"disableapic\", setup_disableapic);\n\n \nstatic int __init setup_nolapic(char *arg)\n{\n\treturn setup_disableapic(arg);\n}\nearly_param(\"nolapic\", setup_nolapic);\n\nstatic int __init parse_lapic_timer_c2_ok(char *arg)\n{\n\tlocal_apic_timer_c2_ok = 1;\n\treturn 0;\n}\nearly_param(\"lapic_timer_c2_ok\", parse_lapic_timer_c2_ok);\n\nstatic int __init parse_disable_apic_timer(char *arg)\n{\n\tdisable_apic_timer = 1;\n\treturn 0;\n}\nearly_param(\"noapictimer\", parse_disable_apic_timer);\n\nstatic int __init parse_nolapic_timer(char *arg)\n{\n\tdisable_apic_timer = 1;\n\treturn 0;\n}\nearly_param(\"nolapic_timer\", parse_nolapic_timer);\n\nstatic int __init apic_set_verbosity(char *arg)\n{\n\tif (!arg)  {\n\t\tif (IS_ENABLED(CONFIG_X86_32))\n\t\t\treturn -EINVAL;\n\n\t\tioapic_is_disabled = false;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(\"debug\", arg) == 0)\n\t\tapic_verbosity = APIC_DEBUG;\n\telse if (strcmp(\"verbose\", arg) == 0)\n\t\tapic_verbosity = APIC_VERBOSE;\n#ifdef CONFIG_X86_64\n\telse {\n\t\tpr_warn(\"APIC Verbosity level %s not recognised\"\n\t\t\t\" use apic=verbose or apic=debug\\n\", arg);\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\treturn 0;\n}\nearly_param(\"apic\", apic_set_verbosity);\n\nstatic int __init lapic_insert_resource(void)\n{\n\tif (!apic_mmio_base)\n\t\treturn -1;\n\n\t \n\tlapic_resource.start = apic_mmio_base;\n\tlapic_resource.end = lapic_resource.start + PAGE_SIZE - 1;\n\tinsert_resource(&iomem_resource, &lapic_resource);\n\n\treturn 0;\n}\n\n \nlate_initcall(lapic_insert_resource);\n\nstatic int __init apic_set_disabled_cpu_apicid(char *arg)\n{\n\tif (!arg || !get_option(&arg, &disabled_cpu_apicid))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"disable_cpu_apicid\", apic_set_disabled_cpu_apicid);\n\nstatic int __init apic_set_extnmi(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(\"all\", arg, 3))\n\t\tapic_extnmi = APIC_EXTNMI_ALL;\n\telse if (!strncmp(\"none\", arg, 4))\n\t\tapic_extnmi = APIC_EXTNMI_NONE;\n\telse if (!strncmp(\"bsp\", arg, 3))\n\t\tapic_extnmi = APIC_EXTNMI_BSP;\n\telse {\n\t\tpr_warn(\"Unknown external NMI delivery mode `%s' ignored\\n\", arg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nearly_param(\"apic_extnmi\", apic_set_extnmi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}