{
  "module_name": "x2apic_uv_x.c",
  "hash_id": "3b123cedf70457fa34d8d0479565477af34b17a0986aeada38a346d374862961",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/x2apic_uv_x.c",
  "human_readable_source": " \n#include <linux/crash_dump.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/proc_fs.h>\n#include <linux/memory.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/efi.h>\n\n#include <asm/e820/api.h>\n#include <asm/uv/uv_mmrs.h>\n#include <asm/uv/uv_hub.h>\n#include <asm/uv/bios.h>\n#include <asm/uv/uv.h>\n#include <asm/apic.h>\n\n#include \"local.h\"\n\nstatic enum uv_system_type\tuv_system_type;\nstatic int\t\t\tuv_hubbed_system;\nstatic int\t\t\tuv_hubless_system;\nstatic u64\t\t\tgru_start_paddr, gru_end_paddr;\nstatic union uvh_apicid\t\tuvh_apicid;\nstatic int\t\t\tuv_node_id;\n\n \nstatic u8 uv_archtype[UV_AT_SIZE + 1];\nstatic u8 oem_id[ACPI_OEM_ID_SIZE + 1];\nstatic u8 oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];\n\n \nstatic struct {\n\tunsigned int apicid_shift;\n\tunsigned int apicid_mask;\n\tunsigned int socketid_shift;\t \n\tunsigned int pnode_mask;\n\tunsigned int nasid_shift;\n\tunsigned int gpa_shift;\n\tunsigned int gnode_shift;\n\tunsigned int m_skt;\n\tunsigned int n_skt;\n} uv_cpuid;\n\nstatic int uv_min_hub_revision_id;\n\nstatic struct apic apic_x2apic_uv_x;\nstatic struct uv_hub_info_s uv_hub_info_node0;\n\n \nstatic int disable_uv_undefined_panic = 1;\n\nunsigned long uv_undefined(char *str)\n{\n\tif (likely(!disable_uv_undefined_panic))\n\t\tpanic(\"UV: error: undefined MMR: %s\\n\", str);\n\telse\n\t\tpr_crit(\"UV: error: undefined MMR: %s\\n\", str);\n\n\t \n\treturn ~0ul;\n}\nEXPORT_SYMBOL(uv_undefined);\n\nstatic unsigned long __init uv_early_read_mmr(unsigned long addr)\n{\n\tunsigned long val, *mmr;\n\n\tmmr = early_ioremap(UV_LOCAL_MMR_BASE | addr, sizeof(*mmr));\n\tval = *mmr;\n\tearly_iounmap(mmr, sizeof(*mmr));\n\n\treturn val;\n}\n\nstatic inline bool is_GRU_range(u64 start, u64 end)\n{\n\tif (!gru_start_paddr)\n\t\treturn false;\n\n\treturn start >= gru_start_paddr && end <= gru_end_paddr;\n}\n\nstatic bool uv_is_untracked_pat_range(u64 start, u64 end)\n{\n\treturn is_ISA_range(start, end) || is_GRU_range(start, end);\n}\n\nstatic void __init early_get_pnodeid(void)\n{\n\tint pnode;\n\n\tuv_cpuid.m_skt = 0;\n\tif (UVH_RH10_GAM_ADDR_MAP_CONFIG) {\n\t\tunion uvh_rh10_gam_addr_map_config_u  m_n_config;\n\n\t\tm_n_config.v = uv_early_read_mmr(UVH_RH10_GAM_ADDR_MAP_CONFIG);\n\t\tuv_cpuid.n_skt = m_n_config.s.n_skt;\n\t\tuv_cpuid.nasid_shift = 0;\n\t} else if (UVH_RH_GAM_ADDR_MAP_CONFIG) {\n\t\tunion uvh_rh_gam_addr_map_config_u  m_n_config;\n\n\tm_n_config.v = uv_early_read_mmr(UVH_RH_GAM_ADDR_MAP_CONFIG);\n\t\tuv_cpuid.n_skt = m_n_config.s.n_skt;\n\t\tif (is_uv(UV3))\n\t\t\tuv_cpuid.m_skt = m_n_config.s3.m_skt;\n\t\tif (is_uv(UV2))\n\t\t\tuv_cpuid.m_skt = m_n_config.s2.m_skt;\n\t\tuv_cpuid.nasid_shift = 1;\n\t} else {\n\t\tunsigned long GAM_ADDR_MAP_CONFIG = 0;\n\n\t\tWARN(GAM_ADDR_MAP_CONFIG == 0,\n\t\t\t\"UV: WARN: GAM_ADDR_MAP_CONFIG is not available\\n\");\n\t\tuv_cpuid.n_skt = 0;\n\t\tuv_cpuid.nasid_shift = 0;\n\t}\n\n\tif (is_uv(UV4|UVY))\n\t\tuv_cpuid.gnode_shift = 2;  \n\n\tuv_cpuid.pnode_mask = (1 << uv_cpuid.n_skt) - 1;\n\tpnode = (uv_node_id >> uv_cpuid.nasid_shift) & uv_cpuid.pnode_mask;\n\tuv_cpuid.gpa_shift = 46;\t \n\n\tpr_info(\"UV: n_skt:%d pnmsk:%x pn:%x\\n\",\n\t\tuv_cpuid.n_skt, uv_cpuid.pnode_mask, pnode);\n}\n\n \nstatic int __init early_set_hub_type(void)\n{\n\tunion uvh_node_id_u node_id;\n\n\t \n\tnode_id.v = uv_early_read_mmr(UVH_NODE_ID);\n\tuv_node_id = node_id.sx.node_id;\n\n\tswitch (node_id.s.part_number) {\n\n\tcase UV5_HUB_PART_NUMBER:\n\t\tuv_min_hub_revision_id = node_id.s.revision\n\t\t\t\t\t + UV5_HUB_REVISION_BASE;\n\t\tuv_hub_type_set(UV5);\n\t\tbreak;\n\n\t \n\tcase UV4_HUB_PART_NUMBER:\n\t\tuv_min_hub_revision_id = node_id.s.revision\n\t\t\t\t\t + UV4_HUB_REVISION_BASE - 1;\n\t\tuv_hub_type_set(UV4);\n\t\tif (uv_min_hub_revision_id == UV4A_HUB_REVISION_BASE)\n\t\t\tuv_hub_type_set(UV4|UV4A);\n\t\tbreak;\n\n\tcase UV3_HUB_PART_NUMBER:\n\tcase UV3_HUB_PART_NUMBER_X:\n\t\tuv_min_hub_revision_id = node_id.s.revision\n\t\t\t\t\t + UV3_HUB_REVISION_BASE;\n\t\tuv_hub_type_set(UV3);\n\t\tbreak;\n\n\tcase UV2_HUB_PART_NUMBER:\n\tcase UV2_HUB_PART_NUMBER_X:\n\t\tuv_min_hub_revision_id = node_id.s.revision\n\t\t\t\t\t + UV2_HUB_REVISION_BASE - 1;\n\t\tuv_hub_type_set(UV2);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpr_info(\"UV: part#:%x rev:%d rev_id:%d UVtype:0x%x\\n\",\n\t\tnode_id.s.part_number, node_id.s.revision,\n\t\tuv_min_hub_revision_id, is_uv(~0));\n\n\treturn 1;\n}\n\nstatic void __init uv_tsc_check_sync(void)\n{\n\tu64 mmr;\n\tint sync_state;\n\tint mmr_shift;\n\tchar *state;\n\n\t \n\tif (!is_uv(UV2|UV3|UV4)) {\n\t\tmark_tsc_async_resets(\"UV5+\");\n\t\treturn;\n\t}\n\n\t \n\tmmr = uv_early_read_mmr(UVH_TSC_SYNC_MMR);\n\tmmr_shift =\n\t\tis_uv2_hub() ? UVH_TSC_SYNC_SHIFT_UV2K : UVH_TSC_SYNC_SHIFT;\n\tsync_state = (mmr >> mmr_shift) & UVH_TSC_SYNC_MASK;\n\n\t \n\tswitch (sync_state) {\n\tcase UVH_TSC_SYNC_VALID:\n\t\tstate = \"in sync\";\n\t\tmark_tsc_async_resets(\"UV BIOS\");\n\t\tbreak;\n\n\t \n\tcase UVH_TSC_SYNC_UNKNOWN:\n\t\tstate = \"unknown\";\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tstate = \"unstable\";\n\t\tmark_tsc_unstable(\"UV BIOS\");\n\t\tbreak;\n\t}\n\tpr_info(\"UV: TSC sync state from BIOS:0%d(%s)\\n\", sync_state, state);\n}\n\n \n#define uvxy_field(sname, field, undef) (\t\\\n\tis_uv(UV4A) ? sname.s4a.field :\t\t\\\n\tis_uv(UV4) ? sname.s4.field :\t\t\\\n\tis_uv(UV3) ? sname.s3.field :\t\t\\\n\tundef)\n\n \n\n#define SMT_LEVEL\t\t\t0\t \n#define INVALID_TYPE\t\t\t0\t \n#define SMT_TYPE\t\t\t1\n#define CORE_TYPE\t\t\t2\n#define LEAFB_SUBTYPE(ecx)\t\t(((ecx) >> 8) & 0xff)\n#define BITS_SHIFT_NEXT_LEVEL(eax)\t((eax) & 0x1f)\n\nstatic void set_x2apic_bits(void)\n{\n\tunsigned int eax, ebx, ecx, edx, sub_index;\n\tunsigned int sid_shift;\n\n\tcpuid(0, &eax, &ebx, &ecx, &edx);\n\tif (eax < 0xb) {\n\t\tpr_info(\"UV: CPU does not have CPUID.11\\n\");\n\t\treturn;\n\t}\n\n\tcpuid_count(0xb, SMT_LEVEL, &eax, &ebx, &ecx, &edx);\n\tif (ebx == 0 || (LEAFB_SUBTYPE(ecx) != SMT_TYPE)) {\n\t\tpr_info(\"UV: CPUID.11 not implemented\\n\");\n\t\treturn;\n\t}\n\n\tsid_shift = BITS_SHIFT_NEXT_LEVEL(eax);\n\tsub_index = 1;\n\tdo {\n\t\tcpuid_count(0xb, sub_index, &eax, &ebx, &ecx, &edx);\n\t\tif (LEAFB_SUBTYPE(ecx) == CORE_TYPE) {\n\t\t\tsid_shift = BITS_SHIFT_NEXT_LEVEL(eax);\n\t\t\tbreak;\n\t\t}\n\t\tsub_index++;\n\t} while (LEAFB_SUBTYPE(ecx) != INVALID_TYPE);\n\n\tuv_cpuid.apicid_shift\t= 0;\n\tuv_cpuid.apicid_mask\t= (~(-1 << sid_shift));\n\tuv_cpuid.socketid_shift = sid_shift;\n}\n\nstatic void __init early_get_apic_socketid_shift(void)\n{\n\tif (is_uv2_hub() || is_uv3_hub())\n\t\tuvh_apicid.v = uv_early_read_mmr(UVH_APICID);\n\n\tset_x2apic_bits();\n\n\tpr_info(\"UV: apicid_shift:%d apicid_mask:0x%x\\n\", uv_cpuid.apicid_shift, uv_cpuid.apicid_mask);\n\tpr_info(\"UV: socketid_shift:%d pnode_mask:0x%x\\n\", uv_cpuid.socketid_shift, uv_cpuid.pnode_mask);\n}\n\nstatic void __init uv_stringify(int len, char *to, char *from)\n{\n\tstrscpy(to, from, len);\n\n\t \n\t(void)strim(to);\n}\n\n \nstatic unsigned long __init early_find_archtype(struct uv_systab *st)\n{\n\tint i;\n\n\tfor (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {\n\t\tunsigned long ptr = st->entry[i].offset;\n\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tptr += (unsigned long)st;\n\t\tif (st->entry[i].type == UV_SYSTAB_TYPE_ARCH_TYPE)\n\t\t\treturn ptr;\n\t}\n\treturn 0;\n}\n\n \nstatic int __init decode_arch_type(unsigned long ptr)\n{\n\tstruct uv_arch_type_entry *uv_ate = (struct uv_arch_type_entry *)ptr;\n\tint n = strlen(uv_ate->archtype);\n\n\tif (n > 0 && n < sizeof(uv_ate->archtype)) {\n\t\tpr_info(\"UV: UVarchtype received from BIOS\\n\");\n\t\tuv_stringify(sizeof(uv_archtype), uv_archtype, uv_ate->archtype);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int __init early_get_arch_type(void)\n{\n\tunsigned long uvst_physaddr, uvst_size, ptr;\n\tstruct uv_systab *st;\n\tu32 rev;\n\tint ret;\n\n\tuvst_physaddr = get_uv_systab_phys(0);\n\tif (!uvst_physaddr)\n\t\treturn 0;\n\n\tst = early_memremap_ro(uvst_physaddr, sizeof(struct uv_systab));\n\tif (!st) {\n\t\tpr_err(\"UV: Cannot access UVsystab, remap failed\\n\");\n\t\treturn 0;\n\t}\n\n\trev = st->revision;\n\tif (rev < UV_SYSTAB_VERSION_UV5) {\n\t\tearly_memunmap(st, sizeof(struct uv_systab));\n\t\treturn 0;\n\t}\n\n\tuvst_size = st->size;\n\tearly_memunmap(st, sizeof(struct uv_systab));\n\tst = early_memremap_ro(uvst_physaddr, uvst_size);\n\tif (!st) {\n\t\tpr_err(\"UV: Cannot access UVarchtype, remap failed\\n\");\n\t\treturn 0;\n\t}\n\n\tptr = early_find_archtype(st);\n\tif (!ptr) {\n\t\tearly_memunmap(st, uvst_size);\n\t\treturn 0;\n\t}\n\n\tret = decode_arch_type(ptr);\n\tearly_memunmap(st, uvst_size);\n\treturn ret;\n}\n\n \nstatic void __init early_set_apic_mode(void)\n{\n\tif (x2apic_enabled())\n\t\tuv_system_type = UV_X2APIC;\n\telse\n\t\tuv_system_type = UV_LEGACY_APIC;\n}\n\nstatic int __init uv_set_system_type(char *_oem_id, char *_oem_table_id)\n{\n\t \n\tuv_stringify(sizeof(oem_id), oem_id, _oem_id);\n\n\t \n\tif (!early_get_arch_type())\n\n\t\t \n\t\tuv_stringify(sizeof(uv_archtype), uv_archtype, oem_id);\n\n\t \n\tif (strncmp(uv_archtype, \"SGI\", 3) != 0) {\n\n\t\t \n\t\tif (strncmp(uv_archtype, \"NSGI\", 4) != 0)\n\n\t\t\t \n\t\t\treturn 0;\n\n\t\t \n\t\tuv_hubless_system = 0x01;\n\n\t\t \n\t\tif (strncmp(uv_archtype, \"NSGI5\", 5) == 0)\n\t\t\tuv_hubless_system |= 0x20;\n\n\t\t \n\t\telse if (strncmp(uv_archtype, \"NSGI4\", 5) == 0)\n\t\t\tuv_hubless_system |= 0x10;\n\n\t\t \n\t\telse\n\t\t\tuv_hubless_system |= 0x8;\n\n\t\t \n\t\tuv_stringify(sizeof(oem_table_id), oem_table_id, _oem_table_id);\n\n\t\tpr_info(\"UV: OEM IDs %s/%s, SystemType %d, HUBLESS ID %x\\n\",\n\t\t\toem_id, oem_table_id, uv_system_type, uv_hubless_system);\n\n\t\treturn 0;\n\t}\n\n\tif (numa_off) {\n\t\tpr_err(\"UV: NUMA is off, disabling UV support\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tuv_hub_info->hub_revision =\n\t\t!strncmp(uv_archtype, \"SGI5\", 4) ? UV5_HUB_REVISION_BASE :\n\t\t!strncmp(uv_archtype, \"SGI4\", 4) ? UV4_HUB_REVISION_BASE :\n\t\t!strncmp(uv_archtype, \"SGI3\", 4) ? UV3_HUB_REVISION_BASE :\n\t\t!strcmp(uv_archtype, \"SGI2\") ? UV2_HUB_REVISION_BASE : 0;\n\n\tswitch (uv_hub_info->hub_revision) {\n\tcase UV5_HUB_REVISION_BASE:\n\t\tuv_hubbed_system = 0x21;\n\t\tuv_hub_type_set(UV5);\n\t\tbreak;\n\n\tcase UV4_HUB_REVISION_BASE:\n\t\tuv_hubbed_system = 0x11;\n\t\tuv_hub_type_set(UV4);\n\t\tbreak;\n\n\tcase UV3_HUB_REVISION_BASE:\n\t\tuv_hubbed_system = 0x9;\n\t\tuv_hub_type_set(UV3);\n\t\tbreak;\n\n\tcase UV2_HUB_REVISION_BASE:\n\t\tuv_hubbed_system = 0x5;\n\t\tuv_hub_type_set(UV2);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tearly_set_hub_type();\n\n\t \n\tearly_set_apic_mode();\n\tearly_get_pnodeid();\n\tearly_get_apic_socketid_shift();\n\tx86_platform.is_untracked_pat_range = uv_is_untracked_pat_range;\n\tx86_platform.nmi_init = uv_nmi_init;\n\tuv_tsc_check_sync();\n\n\treturn 1;\n}\n\n \nstatic int __init uv_acpi_madt_oem_check(char *_oem_id, char *_oem_table_id)\n{\n\t \n\tuv_cpu_info->p_uv_hub_info = &uv_hub_info_node0;\n\n\t \n\tif (uv_set_system_type(_oem_id, _oem_table_id) == 0)\n\t\treturn 0;\n\n\t \n\tuv_stringify(sizeof(oem_table_id), oem_table_id, _oem_table_id);\n\n\tpr_info(\"UV: OEM IDs %s/%s, System/UVType %d/0x%x, HUB RevID %d\\n\",\n\t\toem_id, oem_table_id, uv_system_type, is_uv(UV_ANY),\n\t\tuv_min_hub_revision_id);\n\n\treturn 0;\n}\n\nenum uv_system_type get_uv_system_type(void)\n{\n\treturn uv_system_type;\n}\n\nint uv_get_hubless_system(void)\n{\n\treturn uv_hubless_system;\n}\nEXPORT_SYMBOL_GPL(uv_get_hubless_system);\n\nssize_t uv_get_archtype(char *buf, int len)\n{\n\treturn scnprintf(buf, len, \"%s/%s\", uv_archtype, oem_table_id);\n}\nEXPORT_SYMBOL_GPL(uv_get_archtype);\n\nint is_uv_system(void)\n{\n\treturn uv_system_type != UV_NONE;\n}\nEXPORT_SYMBOL_GPL(is_uv_system);\n\nint is_uv_hubbed(int uvtype)\n{\n\treturn (uv_hubbed_system & uvtype);\n}\nEXPORT_SYMBOL_GPL(is_uv_hubbed);\n\nstatic int is_uv_hubless(int uvtype)\n{\n\treturn (uv_hubless_system & uvtype);\n}\n\nvoid **__uv_hub_info_list;\nEXPORT_SYMBOL_GPL(__uv_hub_info_list);\n\nDEFINE_PER_CPU(struct uv_cpu_info_s, __uv_cpu_info);\nEXPORT_PER_CPU_SYMBOL_GPL(__uv_cpu_info);\n\nshort uv_possible_blades;\nEXPORT_SYMBOL_GPL(uv_possible_blades);\n\nunsigned long sn_rtc_cycles_per_second;\nEXPORT_SYMBOL(sn_rtc_cycles_per_second);\n\n \nstatic __initdata unsigned short\t\t_min_socket, _max_socket;\nstatic __initdata unsigned short\t\t_min_pnode, _max_pnode, _gr_table_len;\nstatic __initdata struct uv_gam_range_entry\t*uv_gre_table;\nstatic __initdata struct uv_gam_parameters\t*uv_gp_table;\nstatic __initdata unsigned short\t\t*_socket_to_node;\nstatic __initdata unsigned short\t\t*_socket_to_pnode;\nstatic __initdata unsigned short\t\t*_pnode_to_socket;\nstatic __initdata unsigned short\t\t*_node_to_socket;\n\nstatic __initdata struct uv_gam_range_s\t\t*_gr_table;\n\n#define\tSOCK_EMPTY\t((unsigned short)~0)\n\n \nstatic unsigned long mem_block_size __initdata = (2UL << 30);\n\n \nstatic int __init parse_mem_block_size(char *ptr)\n{\n\tunsigned long size = memparse(ptr, NULL);\n\n\t \n\tmem_block_size = size;\n\treturn 0;\n}\nearly_param(\"uv_memblksize\", parse_mem_block_size);\n\nstatic __init int adj_blksize(u32 lgre)\n{\n\tunsigned long base = (unsigned long)lgre << UV_GAM_RANGE_SHFT;\n\tunsigned long size;\n\n\tfor (size = mem_block_size; size > MIN_MEMORY_BLOCK_SIZE; size >>= 1)\n\t\tif (IS_ALIGNED(base, size))\n\t\t\tbreak;\n\n\tif (size >= mem_block_size)\n\t\treturn 0;\n\n\tmem_block_size = size;\n\treturn 1;\n}\n\nstatic __init void set_block_size(void)\n{\n\tunsigned int order = ffs(mem_block_size);\n\n\tif (order) {\n\t\t \n\t\tset_memory_block_size_order(order - 1);\n\t\tpr_info(\"UV: mem_block_size set to 0x%lx\\n\", mem_block_size);\n\t} else {\n\t\t \n\t\tpr_err(\"UV: mem_block_size error with 0x%lx\\n\", mem_block_size);\n\t\tset_memory_block_size_order(31);\n\t}\n}\n\n \nstatic __init void build_uv_gr_table(void)\n{\n\tstruct uv_gam_range_entry *gre = uv_gre_table;\n\tstruct uv_gam_range_s *grt;\n\tunsigned long last_limit = 0, ram_limit = 0;\n\tint bytes, i, sid, lsid = -1, indx = 0, lindx = -1;\n\n\tif (!gre)\n\t\treturn;\n\n\tbytes = _gr_table_len * sizeof(struct uv_gam_range_s);\n\tgrt = kzalloc(bytes, GFP_KERNEL);\n\tif (WARN_ON_ONCE(!grt))\n\t\treturn;\n\t_gr_table = grt;\n\n\tfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\n\t\tif (gre->type == UV_GAM_RANGE_TYPE_HOLE) {\n\t\t\tif (!ram_limit) {\n\t\t\t\t \n\t\t\t\tram_limit = last_limit;\n\t\t\t\tlast_limit = gre->limit;\n\t\t\t\tlsid++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlast_limit = gre->limit;\n\t\t\tpr_info(\"UV: extra hole in GAM RE table @%d\\n\", (int)(gre - uv_gre_table));\n\t\t\tcontinue;\n\t\t}\n\t\tif (_max_socket < gre->sockid) {\n\t\t\tpr_err(\"UV: GAM table sockid(%d) too large(>%d) @%d\\n\", gre->sockid, _max_socket, (int)(gre - uv_gre_table));\n\t\t\tcontinue;\n\t\t}\n\t\tsid = gre->sockid - _min_socket;\n\t\tif (lsid < sid) {\n\t\t\t \n\t\t\tgrt = &_gr_table[indx];\n\t\t\tgrt->base = lindx;\n\t\t\tgrt->nasid = gre->nasid;\n\t\t\tgrt->limit = last_limit = gre->limit;\n\t\t\tlsid = sid;\n\t\t\tlindx = indx++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (lsid == sid && !ram_limit) {\n\t\t\t \n\t\t\tif (grt->limit == last_limit) {\n\t\t\t\tgrt->limit = last_limit = gre->limit;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!ram_limit) {\n\t\t\tgrt++;\n\t\t\tgrt->base = lindx;\n\t\t\tgrt->nasid = gre->nasid;\n\t\t\tgrt->limit = last_limit = gre->limit;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tgrt++;\n\t\t \n\t\tgrt->base = grt - _gr_table;\n\t\tgrt->nasid = gre->nasid;\n\t\tgrt->limit = last_limit = gre->limit;\n\t\tlsid++;\n\t}\n\n\t \n\tgrt++;\n\ti = grt - _gr_table;\n\tif (i < _gr_table_len) {\n\t\tvoid *ret;\n\n\t\tbytes = i * sizeof(struct uv_gam_range_s);\n\t\tret = krealloc(_gr_table, bytes, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\t_gr_table = ret;\n\t\t\t_gr_table_len = i;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, grt = _gr_table; i < _gr_table_len; i++, grt++) {\n\t\tunsigned long start, end;\n\t\tint gb = grt->base;\n\n\t\tstart = gb < 0 ?  0 : (unsigned long)_gr_table[gb].limit << UV_GAM_RANGE_SHFT;\n\t\tend = (unsigned long)grt->limit << UV_GAM_RANGE_SHFT;\n\n\t\tpr_info(\"UV: GAM Range %2d %04x 0x%013lx-0x%013lx (%d)\\n\", i, grt->nasid, start, end, gb);\n\t}\n}\n\nstatic int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)\n{\n\tunsigned long val;\n\tint pnode;\n\n\tpnode = uv_apicid_to_pnode(phys_apicid);\n\n\tval = (1UL << UVH_IPI_INT_SEND_SHFT) |\n\t    (phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) |\n\t    ((start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) |\n\t    APIC_DM_INIT;\n\n\tuv_write_global_mmr64(pnode, UVH_IPI_INT, val);\n\n\tval = (1UL << UVH_IPI_INT_SEND_SHFT) |\n\t    (phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) |\n\t    ((start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) |\n\t    APIC_DM_STARTUP;\n\n\tuv_write_global_mmr64(pnode, UVH_IPI_INT, val);\n\n\treturn 0;\n}\n\nstatic void uv_send_IPI_one(int cpu, int vector)\n{\n\tunsigned long apicid = per_cpu(x86_cpu_to_apicid, cpu);\n\tint pnode = uv_apicid_to_pnode(apicid);\n\tunsigned long dmode, val;\n\n\tif (vector == NMI_VECTOR)\n\t\tdmode = APIC_DELIVERY_MODE_NMI;\n\telse\n\t\tdmode = APIC_DELIVERY_MODE_FIXED;\n\n\tval = (1UL << UVH_IPI_INT_SEND_SHFT) |\n\t\t(apicid << UVH_IPI_INT_APIC_ID_SHFT) |\n\t\t(dmode << UVH_IPI_INT_DELIVERY_MODE_SHFT) |\n\t\t(vector << UVH_IPI_INT_VECTOR_SHFT);\n\n\tuv_write_global_mmr64(pnode, UVH_IPI_INT, val);\n}\n\nstatic void uv_send_IPI_mask(const struct cpumask *mask, int vector)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask)\n\t\tuv_send_IPI_one(cpu, vector);\n}\n\nstatic void uv_send_IPI_mask_allbutself(const struct cpumask *mask, int vector)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tif (cpu != this_cpu)\n\t\t\tuv_send_IPI_one(cpu, vector);\n\t}\n}\n\nstatic void uv_send_IPI_allbutself(int vector)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tunsigned int cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu != this_cpu)\n\t\t\tuv_send_IPI_one(cpu, vector);\n\t}\n}\n\nstatic void uv_send_IPI_all(int vector)\n{\n\tuv_send_IPI_mask(cpu_online_mask, vector);\n}\n\nstatic u32 set_apic_id(unsigned int id)\n{\n\treturn id;\n}\n\nstatic unsigned int uv_read_apic_id(void)\n{\n\treturn x2apic_get_apic_id(apic_read(APIC_ID));\n}\n\nstatic int uv_phys_pkg_id(int initial_apicid, int index_msb)\n{\n\treturn uv_read_apic_id() >> index_msb;\n}\n\nstatic int uv_probe(void)\n{\n\treturn apic == &apic_x2apic_uv_x;\n}\n\nstatic struct apic apic_x2apic_uv_x __ro_after_init = {\n\n\t.name\t\t\t\t= \"UV large system\",\n\t.probe\t\t\t\t= uv_probe,\n\t.acpi_madt_oem_check\t\t= uv_acpi_madt_oem_check,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= false,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= uv_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= UINT_MAX,\n\t.get_apic_id\t\t\t= x2apic_get_apic_id,\n\t.set_apic_id\t\t\t= set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_default_calc_apicid,\n\n\t.send_IPI\t\t\t= uv_send_IPI_one,\n\t.send_IPI_mask\t\t\t= uv_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= uv_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= uv_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= uv_send_IPI_all,\n\t.send_IPI_self\t\t\t= x2apic_send_IPI_self,\n\n\t.wakeup_secondary_cpu\t\t= uv_wakeup_secondary,\n\n\t.read\t\t\t\t= native_apic_msr_read,\n\t.write\t\t\t\t= native_apic_msr_write,\n\t.eoi\t\t\t\t= native_apic_msr_eoi,\n\t.icr_read\t\t\t= native_x2apic_icr_read,\n\t.icr_write\t\t\t= native_x2apic_icr_write,\n};\n\n#define\tUVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_LENGTH\t3\n#define DEST_SHIFT UVXH_RH_GAM_ALIAS_0_REDIRECT_CONFIG_DEST_BASE_SHFT\n\nstatic __init void get_lowmem_redirect(unsigned long *base, unsigned long *size)\n{\n\tunion uvh_rh_gam_alias_2_overlay_config_u alias;\n\tunion uvh_rh_gam_alias_2_redirect_config_u redirect;\n\tunsigned long m_redirect;\n\tunsigned long m_overlay;\n\tint i;\n\n\tfor (i = 0; i < UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_LENGTH; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tm_redirect = UVH_RH_GAM_ALIAS_0_REDIRECT_CONFIG;\n\t\t\tm_overlay  = UVH_RH_GAM_ALIAS_0_OVERLAY_CONFIG;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tm_redirect = UVH_RH_GAM_ALIAS_1_REDIRECT_CONFIG;\n\t\t\tm_overlay  = UVH_RH_GAM_ALIAS_1_OVERLAY_CONFIG;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tm_redirect = UVH_RH_GAM_ALIAS_2_REDIRECT_CONFIG;\n\t\t\tm_overlay  = UVH_RH_GAM_ALIAS_2_OVERLAY_CONFIG;\n\t\t\tbreak;\n\t\t}\n\t\talias.v = uv_read_local_mmr(m_overlay);\n\t\tif (alias.s.enable && alias.s.base == 0) {\n\t\t\t*size = (1UL << alias.s.m_alias);\n\t\t\tredirect.v = uv_read_local_mmr(m_redirect);\n\t\t\t*base = (unsigned long)redirect.s.dest_base << DEST_SHIFT;\n\t\t\treturn;\n\t\t}\n\t}\n\t*base = *size = 0;\n}\n\nenum map_type {map_wb, map_uc};\nstatic const char * const mt[] = { \"WB\", \"UC\" };\n\nstatic __init void map_high(char *id, unsigned long base, int pshift, int bshift, int max_pnode, enum map_type map_type)\n{\n\tunsigned long bytes, paddr;\n\n\tpaddr = base << pshift;\n\tbytes = (1UL << bshift) * (max_pnode + 1);\n\tif (!paddr) {\n\t\tpr_info(\"UV: Map %s_HI base address NULL\\n\", id);\n\t\treturn;\n\t}\n\tif (map_type == map_uc)\n\t\tinit_extra_mapping_uc(paddr, bytes);\n\telse\n\t\tinit_extra_mapping_wb(paddr, bytes);\n\n\tpr_info(\"UV: Map %s_HI 0x%lx - 0x%lx %s (%d segments)\\n\",\n\t\tid, paddr, paddr + bytes, mt[map_type], max_pnode + 1);\n}\n\nstatic __init void map_gru_high(int max_pnode)\n{\n\tunion uvh_rh_gam_gru_overlay_config_u gru;\n\tunsigned long mask, base;\n\tint shift;\n\n\tif (UVH_RH_GAM_GRU_OVERLAY_CONFIG) {\n\t\tgru.v = uv_read_local_mmr(UVH_RH_GAM_GRU_OVERLAY_CONFIG);\n\t\tshift = UVH_RH_GAM_GRU_OVERLAY_CONFIG_BASE_SHFT;\n\t\tmask = UVH_RH_GAM_GRU_OVERLAY_CONFIG_BASE_MASK;\n\t} else if (UVH_RH10_GAM_GRU_OVERLAY_CONFIG) {\n\t\tgru.v = uv_read_local_mmr(UVH_RH10_GAM_GRU_OVERLAY_CONFIG);\n\t\tshift = UVH_RH10_GAM_GRU_OVERLAY_CONFIG_BASE_SHFT;\n\t\tmask = UVH_RH10_GAM_GRU_OVERLAY_CONFIG_BASE_MASK;\n\t} else {\n\t\tpr_err(\"UV: GRU unavailable (no MMR)\\n\");\n\t\treturn;\n\t}\n\n\tif (!gru.s.enable) {\n\t\tpr_info(\"UV: GRU disabled (by BIOS)\\n\");\n\t\treturn;\n\t}\n\n\tbase = (gru.v & mask) >> shift;\n\tmap_high(\"GRU\", base, shift, shift, max_pnode, map_wb);\n\tgru_start_paddr = ((u64)base << shift);\n\tgru_end_paddr = gru_start_paddr + (1UL << shift) * (max_pnode + 1);\n}\n\nstatic __init void map_mmr_high(int max_pnode)\n{\n\tunsigned long base;\n\tint shift;\n\tbool enable;\n\n\tif (UVH_RH10_GAM_MMR_OVERLAY_CONFIG) {\n\t\tunion uvh_rh10_gam_mmr_overlay_config_u mmr;\n\n\t\tmmr.v = uv_read_local_mmr(UVH_RH10_GAM_MMR_OVERLAY_CONFIG);\n\t\tenable = mmr.s.enable;\n\t\tbase = mmr.s.base;\n\t\tshift = UVH_RH10_GAM_MMR_OVERLAY_CONFIG_BASE_SHFT;\n\t} else if (UVH_RH_GAM_MMR_OVERLAY_CONFIG) {\n\t\tunion uvh_rh_gam_mmr_overlay_config_u mmr;\n\n\t\tmmr.v = uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG);\n\t\tenable = mmr.s.enable;\n\t\tbase = mmr.s.base;\n\t\tshift = UVH_RH_GAM_MMR_OVERLAY_CONFIG_BASE_SHFT;\n\t} else {\n\t\tpr_err(\"UV:%s:RH_GAM_MMR_OVERLAY_CONFIG MMR undefined?\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tmap_high(\"MMR\", base, shift, shift, max_pnode, map_uc);\n\telse\n\t\tpr_info(\"UV: MMR disabled\\n\");\n}\n\n \nenum mmioh_arch {\n\tUV2_MMIOH = -1,\n\tUVY_MMIOH0, UVY_MMIOH1,\n\tUVX_MMIOH0, UVX_MMIOH1,\n};\n\n \nstatic void __init calc_mmioh_map(enum mmioh_arch index,\n\tint min_pnode, int max_pnode,\n\tint shift, unsigned long base, int m_io, int n_io)\n{\n\tunsigned long mmr, nasid_mask;\n\tint nasid, min_nasid, max_nasid, lnasid, mapped;\n\tint i, fi, li, n, max_io;\n\tchar id[8];\n\n\t \n\tif (index == UV2_MMIOH) {\n\t\tstrscpy(id, \"MMIOH\", sizeof(id));\n\t\tmax_io = max_pnode;\n\t\tmapped = 0;\n\t\tgoto map_exit;\n\t}\n\n\t \n\tswitch (index) {\n\tcase UVY_MMIOH0:\n\t\tmmr = UVH_RH10_GAM_MMIOH_REDIRECT_CONFIG0;\n\t\tnasid_mask = UVYH_RH10_GAM_MMIOH_REDIRECT_CONFIG0_NASID_MASK;\n\t\tn = UVH_RH10_GAM_MMIOH_REDIRECT_CONFIG0_DEPTH;\n\t\tmin_nasid = min_pnode;\n\t\tmax_nasid = max_pnode;\n\t\tmapped = 1;\n\t\tbreak;\n\tcase UVY_MMIOH1:\n\t\tmmr = UVH_RH10_GAM_MMIOH_REDIRECT_CONFIG1;\n\t\tnasid_mask = UVYH_RH10_GAM_MMIOH_REDIRECT_CONFIG1_NASID_MASK;\n\t\tn = UVH_RH10_GAM_MMIOH_REDIRECT_CONFIG1_DEPTH;\n\t\tmin_nasid = min_pnode;\n\t\tmax_nasid = max_pnode;\n\t\tmapped = 1;\n\t\tbreak;\n\tcase UVX_MMIOH0:\n\t\tmmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0;\n\t\tnasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_NASID_MASK;\n\t\tn = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_DEPTH;\n\t\tmin_nasid = min_pnode * 2;\n\t\tmax_nasid = max_pnode * 2;\n\t\tmapped = 1;\n\t\tbreak;\n\tcase UVX_MMIOH1:\n\t\tmmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1;\n\t\tnasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_NASID_MASK;\n\t\tn = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_DEPTH;\n\t\tmin_nasid = min_pnode * 2;\n\t\tmax_nasid = max_pnode * 2;\n\t\tmapped = 1;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"UV:%s:Invalid mapping type:%d\\n\", __func__, index);\n\t\treturn;\n\t}\n\n\t \n\tsnprintf(id, sizeof(id), \"MMIOH%d\", index%2);\n\n\tmax_io = lnasid = fi = li = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long m_redirect = mmr + i * 8;\n\t\tunsigned long redirect = uv_read_local_mmr(m_redirect);\n\n\t\tnasid = redirect & nasid_mask;\n\t\tif (i == 0)\n\t\t\tpr_info(\"UV: %s redirect base 0x%lx(@0x%lx) 0x%04x\\n\",\n\t\t\t\tid, redirect, m_redirect, nasid);\n\n\t\t \n\t\tif (nasid < min_nasid || max_nasid < nasid) {\n\t\t\t \n\t\t\tpr_debug(\"UV:%s:Invalid NASID(%x):%x (range:%x..%x)\\n\",\n\t\t\t       __func__, index, nasid, min_nasid, max_nasid);\n\t\t\tnasid = -1;\n\t\t}\n\n\t\tif (nasid == lnasid) {\n\t\t\tli = i;\n\t\t\t \n\t\t\tif (i != n-1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (lnasid != -1 || (i == n-1 && nasid != -1))  {\n\t\t\tunsigned long addr1, addr2;\n\t\t\tint f, l;\n\n\t\t\tif (lnasid == -1) {\n\t\t\t\tf = l = i;\n\t\t\t\tlnasid = nasid;\n\t\t\t} else {\n\t\t\t\tf = fi;\n\t\t\t\tl = li;\n\t\t\t}\n\t\t\taddr1 = (base << shift) + f * (1ULL << m_io);\n\t\t\taddr2 = (base << shift) + (l + 1) * (1ULL << m_io);\n\t\t\tpr_info(\"UV: %s[%03d..%03d] NASID 0x%04x ADDR 0x%016lx - 0x%016lx\\n\",\n\t\t\t\tid, fi, li, lnasid, addr1, addr2);\n\t\t\tif (max_io < l)\n\t\t\t\tmax_io = l;\n\t\t}\n\t\tfi = li = i;\n\t\tlnasid = nasid;\n\t}\n\nmap_exit:\n\tpr_info(\"UV: %s base:0x%lx shift:%d m_io:%d max_io:%d max_pnode:0x%x\\n\",\n\t\tid, base, shift, m_io, max_io, max_pnode);\n\n\tif (max_io >= 0 && !mapped)\n\t\tmap_high(id, base, shift, m_io, max_io, map_uc);\n}\n\nstatic __init void map_mmioh_high(int min_pnode, int max_pnode)\n{\n\t \n\tif (UVH_RH10_GAM_MMIOH_OVERLAY_CONFIG0) {\n\t\tunion uvh_rh10_gam_mmioh_overlay_config0_u mmioh0;\n\t\tunion uvh_rh10_gam_mmioh_overlay_config1_u mmioh1;\n\n\t\tmmioh0.v = uv_read_local_mmr(UVH_RH10_GAM_MMIOH_OVERLAY_CONFIG0);\n\t\tif (unlikely(mmioh0.s.enable == 0))\n\t\t\tpr_info(\"UV: MMIOH0 disabled\\n\");\n\t\telse\n\t\t\tcalc_mmioh_map(UVY_MMIOH0, min_pnode, max_pnode,\n\t\t\t\tUVH_RH10_GAM_MMIOH_OVERLAY_CONFIG0_BASE_SHFT,\n\t\t\t\tmmioh0.s.base, mmioh0.s.m_io, mmioh0.s.n_io);\n\n\t\tmmioh1.v = uv_read_local_mmr(UVH_RH10_GAM_MMIOH_OVERLAY_CONFIG1);\n\t\tif (unlikely(mmioh1.s.enable == 0))\n\t\t\tpr_info(\"UV: MMIOH1 disabled\\n\");\n\t\telse\n\t\t\tcalc_mmioh_map(UVY_MMIOH1, min_pnode, max_pnode,\n\t\t\t\tUVH_RH10_GAM_MMIOH_OVERLAY_CONFIG1_BASE_SHFT,\n\t\t\t\tmmioh1.s.base, mmioh1.s.m_io, mmioh1.s.n_io);\n\t\treturn;\n\t}\n\t \n\tif (UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0) {\n\t\tunion uvh_rh_gam_mmioh_overlay_config0_u mmioh0;\n\t\tunion uvh_rh_gam_mmioh_overlay_config1_u mmioh1;\n\n\t\tmmioh0.v = uv_read_local_mmr(UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0);\n\t\tif (unlikely(mmioh0.s.enable == 0))\n\t\t\tpr_info(\"UV: MMIOH0 disabled\\n\");\n\t\telse {\n\t\t\tunsigned long base = uvxy_field(mmioh0, base, 0);\n\t\t\tint m_io = uvxy_field(mmioh0, m_io, 0);\n\t\t\tint n_io = uvxy_field(mmioh0, n_io, 0);\n\n\t\t\tcalc_mmioh_map(UVX_MMIOH0, min_pnode, max_pnode,\n\t\t\t\tUVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_BASE_SHFT,\n\t\t\t\tbase, m_io, n_io);\n\t\t}\n\n\t\tmmioh1.v = uv_read_local_mmr(UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1);\n\t\tif (unlikely(mmioh1.s.enable == 0))\n\t\t\tpr_info(\"UV: MMIOH1 disabled\\n\");\n\t\telse {\n\t\t\tunsigned long base = uvxy_field(mmioh1, base, 0);\n\t\t\tint m_io = uvxy_field(mmioh1, m_io, 0);\n\t\t\tint n_io = uvxy_field(mmioh1, n_io, 0);\n\n\t\t\tcalc_mmioh_map(UVX_MMIOH1, min_pnode, max_pnode,\n\t\t\t\tUVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_BASE_SHFT,\n\t\t\t\tbase, m_io, n_io);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (UVH_RH_GAM_MMIOH_OVERLAY_CONFIG) {\n\t\tunion uvh_rh_gam_mmioh_overlay_config_u mmioh;\n\n\t\tmmioh.v\t= uv_read_local_mmr(UVH_RH_GAM_MMIOH_OVERLAY_CONFIG);\n\t\tif (unlikely(mmioh.s2.enable == 0))\n\t\t\tpr_info(\"UV: MMIOH disabled\\n\");\n\t\telse\n\t\t\tcalc_mmioh_map(UV2_MMIOH, min_pnode, max_pnode,\n\t\t\t\tUV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_BASE_SHFT,\n\t\t\t\tmmioh.s2.base, mmioh.s2.m_io, mmioh.s2.n_io);\n\t\treturn;\n\t}\n}\n\nstatic __init void map_low_mmrs(void)\n{\n\tif (UV_GLOBAL_MMR32_BASE)\n\t\tinit_extra_mapping_uc(UV_GLOBAL_MMR32_BASE, UV_GLOBAL_MMR32_SIZE);\n\n\tif (UV_LOCAL_MMR_BASE)\n\t\tinit_extra_mapping_uc(UV_LOCAL_MMR_BASE, UV_LOCAL_MMR_SIZE);\n}\n\nstatic __init void uv_rtc_init(void)\n{\n\tlong status;\n\tu64 ticks_per_sec;\n\n\tstatus = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK, &ticks_per_sec);\n\n\tif (status != BIOS_STATUS_SUCCESS || ticks_per_sec < 100000) {\n\t\tpr_warn(\"UV: unable to determine platform RTC clock frequency, guessing.\\n\");\n\n\t\t \n\t\tsn_rtc_cycles_per_second = 1000000000000UL / 30000UL;\n\t} else {\n\t\tsn_rtc_cycles_per_second = ticks_per_sec;\n\t}\n}\n\n \nstatic int uv_set_vga_state(struct pci_dev *pdev, bool decode, unsigned int command_bits, u32 flags)\n{\n\tint domain, bus, rc;\n\n\tif (!(flags & PCI_VGA_STATE_CHANGE_BRIDGE))\n\t\treturn 0;\n\n\tif ((command_bits & PCI_COMMAND_IO) == 0)\n\t\treturn 0;\n\n\tdomain = pci_domain_nr(pdev->bus);\n\tbus = pdev->bus->number;\n\n\trc = uv_bios_set_legacy_vga_target(decode, domain, bus);\n\n\treturn rc;\n}\n\n \nvoid uv_cpu_init(void)\n{\n\t \n\tif (smp_processor_id() == 0)\n\t\treturn;\n\n\tuv_hub_info->nr_online_cpus++;\n}\n\nstruct mn {\n\tunsigned char\tm_val;\n\tunsigned char\tn_val;\n\tunsigned char\tm_shift;\n\tunsigned char\tn_lshift;\n};\n\n \nstatic void get_mn(struct mn *mnp)\n{\n\tmemset(mnp, 0, sizeof(*mnp));\n\tmnp->n_val\t= uv_cpuid.n_skt;\n\tif (is_uv(UV4|UVY)) {\n\t\tmnp->m_val\t= 0;\n\t\tmnp->n_lshift\t= 0;\n\t} else if (is_uv3_hub()) {\n\t\tunion uvyh_gr0_gam_gr_config_u m_gr_config;\n\n\t\tmnp->m_val\t= uv_cpuid.m_skt;\n\t\tm_gr_config.v\t= uv_read_local_mmr(UVH_GR0_GAM_GR_CONFIG);\n\t\tmnp->n_lshift\t= m_gr_config.s3.m_skt;\n\t} else if (is_uv2_hub()) {\n\t\tmnp->m_val\t= uv_cpuid.m_skt;\n\t\tmnp->n_lshift\t= mnp->m_val == 40 ? 40 : 39;\n\t}\n\tmnp->m_shift = mnp->m_val ? 64 - mnp->m_val : 0;\n}\n\nstatic void __init uv_init_hub_info(struct uv_hub_info_s *hi)\n{\n\tstruct mn mn;\n\n\tget_mn(&mn);\n\thi->gpa_mask = mn.m_val ?\n\t\t(1UL << (mn.m_val + mn.n_val)) - 1 :\n\t\t(1UL << uv_cpuid.gpa_shift) - 1;\n\n\thi->m_val\t\t= mn.m_val;\n\thi->n_val\t\t= mn.n_val;\n\thi->m_shift\t\t= mn.m_shift;\n\thi->n_lshift\t\t= mn.n_lshift ? mn.n_lshift : 0;\n\thi->hub_revision\t= uv_hub_info->hub_revision;\n\thi->hub_type\t\t= uv_hub_info->hub_type;\n\thi->pnode_mask\t\t= uv_cpuid.pnode_mask;\n\thi->nasid_shift\t\t= uv_cpuid.nasid_shift;\n\thi->min_pnode\t\t= _min_pnode;\n\thi->min_socket\t\t= _min_socket;\n\thi->node_to_socket\t= _node_to_socket;\n\thi->pnode_to_socket\t= _pnode_to_socket;\n\thi->socket_to_node\t= _socket_to_node;\n\thi->socket_to_pnode\t= _socket_to_pnode;\n\thi->gr_table_len\t= _gr_table_len;\n\thi->gr_table\t\t= _gr_table;\n\n\tuv_cpuid.gnode_shift\t= max_t(unsigned int, uv_cpuid.gnode_shift, mn.n_val);\n\thi->gnode_extra\t\t= (uv_node_id & ~((1 << uv_cpuid.gnode_shift) - 1)) >> 1;\n\tif (mn.m_val)\n\t\thi->gnode_upper\t= (u64)hi->gnode_extra << mn.m_val;\n\n\tif (uv_gp_table) {\n\t\thi->global_mmr_base\t= uv_gp_table->mmr_base;\n\t\thi->global_mmr_shift\t= uv_gp_table->mmr_shift;\n\t\thi->global_gru_base\t= uv_gp_table->gru_base;\n\t\thi->global_gru_shift\t= uv_gp_table->gru_shift;\n\t\thi->gpa_shift\t\t= uv_gp_table->gpa_shift;\n\t\thi->gpa_mask\t\t= (1UL << hi->gpa_shift) - 1;\n\t} else {\n\t\thi->global_mmr_base\t=\n\t\t\tuv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG) &\n\t\t\t~UV_MMR_ENABLE;\n\t\thi->global_mmr_shift\t= _UV_GLOBAL_MMR64_PNODE_SHIFT;\n\t}\n\n\tget_lowmem_redirect(&hi->lowmem_remap_base, &hi->lowmem_remap_top);\n\n\thi->apic_pnode_shift = uv_cpuid.socketid_shift;\n\n\t \n\tpr_info(\"UV: N:%d M:%d m_shift:%d n_lshift:%d\\n\", hi->n_val, hi->m_val, hi->m_shift, hi->n_lshift);\n\tpr_info(\"UV: gpa_mask/shift:0x%lx/%d pnode_mask:0x%x apic_pns:%d\\n\", hi->gpa_mask, hi->gpa_shift, hi->pnode_mask, hi->apic_pnode_shift);\n\tpr_info(\"UV: mmr_base/shift:0x%lx/%ld\\n\", hi->global_mmr_base, hi->global_mmr_shift);\n\tif (hi->global_gru_base)\n\t\tpr_info(\"UV: gru_base/shift:0x%lx/%ld\\n\",\n\t\t\thi->global_gru_base, hi->global_gru_shift);\n\n\tpr_info(\"UV: gnode_upper:0x%lx gnode_extra:0x%x\\n\", hi->gnode_upper, hi->gnode_extra);\n}\n\nstatic void __init decode_gam_params(unsigned long ptr)\n{\n\tuv_gp_table = (struct uv_gam_parameters *)ptr;\n\n\tpr_info(\"UV: GAM Params...\\n\");\n\tpr_info(\"UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\\n\",\n\t\tuv_gp_table->mmr_base, uv_gp_table->mmr_shift,\n\t\tuv_gp_table->gru_base, uv_gp_table->gru_shift,\n\t\tuv_gp_table->gpa_shift);\n}\n\nstatic void __init decode_gam_rng_tbl(unsigned long ptr)\n{\n\tstruct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;\n\tunsigned long lgre = 0, gend = 0;\n\tint index = 0;\n\tint sock_min = INT_MAX, pnode_min = INT_MAX;\n\tint sock_max = -1, pnode_max = -1;\n\n\tuv_gre_table = gre;\n\tfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\n\t\tunsigned long size = ((unsigned long)(gre->limit - lgre)\n\t\t\t\t\t<< UV_GAM_RANGE_SHFT);\n\t\tint order = 0;\n\t\tchar suffix[] = \" KMGTPE\";\n\t\tint flag = ' ';\n\n\t\twhile (size > 9999 && order < sizeof(suffix)) {\n\t\t\tsize /= 1024;\n\t\t\torder++;\n\t\t}\n\n\t\t \n\t\tif (gre->type == 1 || gre->type == 2)\n\t\t\tif (adj_blksize(lgre))\n\t\t\t\tflag = '*';\n\n\t\tif (!index) {\n\t\t\tpr_info(\"UV: GAM Range Table...\\n\");\n\t\t\tpr_info(\"UV:  # %20s %14s %6s %4s %5s %3s %2s\\n\", \"Range\", \"\", \"Size\", \"Type\", \"NASID\", \"SID\", \"PN\");\n\t\t}\n\t\tpr_info(\"UV: %2d: 0x%014lx-0x%014lx%c %5lu%c %3d   %04x  %02x %02x\\n\",\n\t\t\tindex++,\n\t\t\t(unsigned long)lgre << UV_GAM_RANGE_SHFT,\n\t\t\t(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,\n\t\t\tflag, size, suffix[order],\n\t\t\tgre->type, gre->nasid, gre->sockid, gre->pnode);\n\n\t\tif (gre->type == UV_GAM_RANGE_TYPE_HOLE)\n\t\t\tgend = (unsigned long)gre->limit << UV_GAM_RANGE_SHFT;\n\n\t\t \n\t\tlgre = gre->limit;\n\t\tif (sock_min > gre->sockid)\n\t\t\tsock_min = gre->sockid;\n\t\tif (sock_max < gre->sockid)\n\t\t\tsock_max = gre->sockid;\n\t\tif (pnode_min > gre->pnode)\n\t\t\tpnode_min = gre->pnode;\n\t\tif (pnode_max < gre->pnode)\n\t\t\tpnode_max = gre->pnode;\n\t}\n\t_min_socket\t= sock_min;\n\t_max_socket\t= sock_max;\n\t_min_pnode\t= pnode_min;\n\t_max_pnode\t= pnode_max;\n\t_gr_table_len\t= index;\n\n\tpr_info(\"UV: GRT: %d entries, sockets(min:%x,max:%x), pnodes(min:%x,max:%x), gap_end(%d)\\n\",\n\t  index, _min_socket, _max_socket, _min_pnode, _max_pnode, fls64(gend));\n}\n\n \nstatic int __init decode_uv_systab(void)\n{\n\tstruct uv_systab *st;\n\tint i;\n\n\t \n\tst = uv_systab;\n\n\t \n\tif (st && st->revision == UV_SYSTAB_VERSION_1)\n\t\treturn 0;\n\n\tif ((!st) || (st->revision < UV_SYSTAB_VERSION_UV4_LATEST)) {\n\t\tint rev = st ? st->revision : 0;\n\n\t\tpr_err(\"UV: BIOS UVsystab mismatch, (%x < %x)\\n\",\n\t\t\trev, UV_SYSTAB_VERSION_UV4_LATEST);\n\t\tpr_err(\"UV: Does not support UV, switch to non-UV x86_64\\n\");\n\t\tuv_system_type = UV_NONE;\n\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {\n\t\tunsigned long ptr = st->entry[i].offset;\n\n\t\tif (!ptr)\n\t\t\tcontinue;\n\n\t\t \n\t\tptr += (unsigned long)st;\n\n\t\tswitch (st->entry[i].type) {\n\t\tcase UV_SYSTAB_TYPE_GAM_PARAMS:\n\t\t\tdecode_gam_params(ptr);\n\t\t\tbreak;\n\n\t\tcase UV_SYSTAB_TYPE_GAM_RNG_TBL:\n\t\t\tdecode_gam_rng_tbl(ptr);\n\t\t\tbreak;\n\n\t\tcase UV_SYSTAB_TYPE_ARCH_TYPE:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"UV:%s:Unrecognized UV_SYSTAB_TYPE:%d, skipped\\n\",\n\t\t\t\t__func__, st->entry[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic inline void blade_update_min_max(unsigned long bits, int base, int mask, int *min, int *max)\n{\n\tint first, last;\n\n\tif (!bits)\n\t\treturn;\n\tfirst = (base + __ffs(bits)) & mask;\n\tlast =  (base + __fls(bits)) & mask;\n\n\tif (*min > first)\n\t\t*min = first;\n\tif (*max < last)\n\t\t*max = last;\n}\n\n \nstatic __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)\n{\n\tunsigned long np;\n\tint i, uv_pb = 0;\n\tint sock_min = INT_MAX, sock_max = -1, s_mask;\n\n\ts_mask = (1 << uv_cpuid.n_skt) - 1;\n\n\tif (UVH_NODE_PRESENT_TABLE) {\n\t\tpr_info(\"UV: NODE_PRESENT_DEPTH = %d\\n\",\n\t\t\tUVH_NODE_PRESENT_TABLE_DEPTH);\n\t\tfor (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {\n\t\t\tnp = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);\n\t\t\tpr_info(\"UV: NODE_PRESENT(%d) = 0x%016lx\\n\", i, np);\n\t\t\tblade_update_min_max(np, i * 64, s_mask, &sock_min, &sock_max);\n\t\t}\n\t}\n\tif (UVH_NODE_PRESENT_0) {\n\t\tnp = uv_read_local_mmr(UVH_NODE_PRESENT_0);\n\t\tpr_info(\"UV: NODE_PRESENT_0 = 0x%016lx\\n\", np);\n\t\tblade_update_min_max(np, 0, s_mask, &sock_min, &sock_max);\n\t}\n\tif (UVH_NODE_PRESENT_1) {\n\t\tnp = uv_read_local_mmr(UVH_NODE_PRESENT_1);\n\t\tpr_info(\"UV: NODE_PRESENT_1 = 0x%016lx\\n\", np);\n\t\tblade_update_min_max(np, 64, s_mask, &sock_min, &sock_max);\n\t}\n\n\t \n\tif (sock_max >= sock_min) {\n\t\t_min_socket = sock_min;\n\t\t_max_socket = sock_max;\n\t\tuv_pb = sock_max - sock_min + 1;\n\t}\n\tif (uv_possible_blades != uv_pb)\n\t\tuv_possible_blades = uv_pb;\n\n\tpr_info(\"UV: number nodes/possible blades %d (%d - %d)\\n\",\n\t\tuv_pb, sock_min, sock_max);\n}\n\nstatic int __init alloc_conv_table(int num_elem, unsigned short **table)\n{\n\tint i;\n\tsize_t bytes;\n\n\tbytes = num_elem * sizeof(*table[0]);\n\t*table = kmalloc(bytes, GFP_KERNEL);\n\tif (WARN_ON_ONCE(!*table))\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < num_elem; i++)\n\t\t((unsigned short *)*table)[i] = SOCK_EMPTY;\n\treturn 0;\n}\n\n \n#define FREE_1_TO_1_TABLE(tbl, min, max, max2) free_1_to_1_table(&tbl, #tbl, min, max, max2)\n\nstatic void __init free_1_to_1_table(unsigned short **tp, char *tname, int min, int max, int max2)\n{\n\tint i;\n\tunsigned short *table = *tp;\n\n\tif (table == NULL)\n\t\treturn;\n\tif (max != max2)\n\t\treturn;\n\tfor (i = 0; i < max; i++) {\n\t\tif (i != table[i])\n\t\t\treturn;\n\t}\n\tkfree(table);\n\t*tp = NULL;\n\tpr_info(\"UV: %s is 1:1, conversion table removed\\n\", tname);\n}\n\n \nstatic void __init build_socket_tables(void)\n{\n\tstruct uv_gam_range_entry *gre = uv_gre_table;\n\tint nums, numn, nump;\n\tint i, lnid, apicid;\n\tint minsock = _min_socket;\n\tint maxsock = _max_socket;\n\tint minpnode = _min_pnode;\n\tint maxpnode = _max_pnode;\n\n\tif (!gre) {\n\t\tif (is_uv2_hub() || is_uv3_hub()) {\n\t\t\tpr_info(\"UV: No UVsystab socket table, ignoring\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpr_err(\"UV: Error: UVsystab address translations not available!\\n\");\n\t\tWARN_ON_ONCE(!gre);\n\t\treturn;\n\t}\n\n\tnumn = num_possible_nodes();\n\tnump = maxpnode - minpnode + 1;\n\tnums = maxsock - minsock + 1;\n\n\t \n\tif ((alloc_conv_table(nump, &_pnode_to_socket) < 0)\n\t    || (alloc_conv_table(nums, &_socket_to_pnode) < 0)\n\t    || (alloc_conv_table(numn, &_node_to_socket) < 0)\n\t    || (alloc_conv_table(nums, &_socket_to_node) < 0)) {\n\t\tkfree(_pnode_to_socket);\n\t\tkfree(_socket_to_pnode);\n\t\tkfree(_node_to_socket);\n\t\treturn;\n\t}\n\n\t \n\tfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\n\t\tif (gre->type == UV_GAM_RANGE_TYPE_HOLE)\n\t\t\tcontinue;\n\t\ti = gre->sockid - minsock;\n\t\tif (_socket_to_pnode[i] == SOCK_EMPTY)\n\t\t\t_socket_to_pnode[i] = gre->pnode;\n\n\t\ti = gre->pnode - minpnode;\n\t\tif (_pnode_to_socket[i] == SOCK_EMPTY)\n\t\t\t_pnode_to_socket[i] = gre->sockid;\n\n\t\tpr_info(\"UV: sid:%02x type:%d nasid:%04x pn:%02x pn2s:%2x\\n\",\n\t\t\tgre->sockid, gre->type, gre->nasid,\n\t\t\t_socket_to_pnode[gre->sockid - minsock],\n\t\t\t_pnode_to_socket[gre->pnode - minpnode]);\n\t}\n\n\t \n\tlnid = NUMA_NO_NODE;\n\tfor (apicid = 0; apicid < ARRAY_SIZE(__apicid_to_node); apicid++) {\n\t\tint nid = __apicid_to_node[apicid];\n\t\tint sockid;\n\n\t\tif ((nid == NUMA_NO_NODE) || (lnid == nid))\n\t\t\tcontinue;\n\t\tlnid = nid;\n\n\t\tsockid = apicid >> uv_cpuid.socketid_shift;\n\n\t\tif (_socket_to_node[sockid - minsock] == SOCK_EMPTY)\n\t\t\t_socket_to_node[sockid - minsock] = nid;\n\n\t\tif (_node_to_socket[nid] == SOCK_EMPTY)\n\t\t\t_node_to_socket[nid] = sockid;\n\n\t\tpr_info(\"UV: sid:%02x: apicid:%04x socket:%02d node:%03x s2n:%03x\\n\",\n\t\t\tsockid,\n\t\t\tapicid,\n\t\t\t_node_to_socket[nid],\n\t\t\tnid,\n\t\t\t_socket_to_node[sockid - minsock]);\n\t}\n\n\t \n\tFREE_1_TO_1_TABLE(_socket_to_node, _min_socket, nums, numn);\n\tFREE_1_TO_1_TABLE(_node_to_socket, _min_socket, nums, numn);\n\tFREE_1_TO_1_TABLE(_socket_to_pnode, _min_pnode, nums, nump);\n\tFREE_1_TO_1_TABLE(_pnode_to_socket, _min_pnode, nums, nump);\n}\n\n \nstatic void check_efi_reboot(void)\n{\n\t \n\tif (!efi_enabled(EFI_BOOT))\n\t\treboot_type = BOOT_ACPI;\n}\n\n \nstatic int __maybe_unused proc_hubbed_show(struct seq_file *file, void *data)\n{\n\tpr_notice_once(\"%s: using deprecated /proc/sgi_uv/hubbed, use /sys/firmware/sgi_uv/hub_type\\n\",\n\t\t       current->comm);\n\tseq_printf(file, \"0x%x\\n\", uv_hubbed_system);\n\treturn 0;\n}\n\nstatic int __maybe_unused proc_hubless_show(struct seq_file *file, void *data)\n{\n\tpr_notice_once(\"%s: using deprecated /proc/sgi_uv/hubless, use /sys/firmware/sgi_uv/hubless\\n\",\n\t\t       current->comm);\n\tseq_printf(file, \"0x%x\\n\", uv_hubless_system);\n\treturn 0;\n}\n\nstatic int __maybe_unused proc_archtype_show(struct seq_file *file, void *data)\n{\n\tpr_notice_once(\"%s: using deprecated /proc/sgi_uv/archtype, use /sys/firmware/sgi_uv/archtype\\n\",\n\t\t       current->comm);\n\tseq_printf(file, \"%s/%s\\n\", uv_archtype, oem_table_id);\n\treturn 0;\n}\n\nstatic __init void uv_setup_proc_files(int hubless)\n{\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_mkdir(UV_PROC_NODE, NULL);\n\tproc_create_single(\"archtype\", 0, pde, proc_archtype_show);\n\tif (hubless)\n\t\tproc_create_single(\"hubless\", 0, pde, proc_hubless_show);\n\telse\n\t\tproc_create_single(\"hubbed\", 0, pde, proc_hubbed_show);\n}\n\n \nstatic __init int uv_system_init_hubless(void)\n{\n\tint rc;\n\n\t \n\tuv_nmi_setup_hubless();\n\n\t \n\trc = uv_bios_init();\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = decode_uv_systab();\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tset_block_size();\n\n\t \n\tif (rc >= 0)\n\t\tuv_setup_proc_files(1);\n\n\tcheck_efi_reboot();\n\n\treturn rc;\n}\n\nstatic void __init uv_system_init_hub(void)\n{\n\tstruct uv_hub_info_s hub_info = {0};\n\tint bytes, cpu, nodeid, bid;\n\tunsigned short min_pnode = USHRT_MAX, max_pnode = 0;\n\tchar *hub = is_uv5_hub() ? \"UV500\" :\n\t\t    is_uv4_hub() ? \"UV400\" :\n\t\t    is_uv3_hub() ? \"UV300\" :\n\t\t    is_uv2_hub() ? \"UV2000/3000\" : NULL;\n\tstruct uv_hub_info_s **uv_hub_info_list_blade;\n\n\tif (!hub) {\n\t\tpr_err(\"UV: Unknown/unsupported UV hub\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"UV: Found %s hub\\n\", hub);\n\n\tmap_low_mmrs();\n\n\t \n\tuv_bios_init();\n\n\t \n\tif (decode_uv_systab() < 0) {\n\t\tpr_err(\"UV: Mangled UVsystab format\\n\");\n\t\treturn;\n\t}\n\n\tbuild_socket_tables();\n\tbuild_uv_gr_table();\n\tset_block_size();\n\tuv_init_hub_info(&hub_info);\n\t \n\tif (is_uv(UV2|UV3) && !uv_gre_table)\n\t\tboot_init_possible_blades(&hub_info);\n\telse\n\t\t \n\t\tuv_possible_blades = (_max_socket - _min_socket) + 1;\n\n\t \n\tpr_info(\"UV: Found %d hubs, %d nodes, %d CPUs\\n\", uv_num_possible_blades(), num_possible_nodes(), num_possible_cpus());\n\n\tuv_bios_get_sn_info(0, &uv_type, &sn_partition_id, &sn_coherency_id, &sn_region_size, &system_serial_number);\n\thub_info.coherency_domain_number = sn_coherency_id;\n\tuv_rtc_init();\n\n\t \n\n\tbytes = sizeof(void *) * uv_num_possible_blades();\n\tuv_hub_info_list_blade = kzalloc(bytes, GFP_KERNEL);\n\tif (WARN_ON_ONCE(!uv_hub_info_list_blade))\n\t\treturn;\n\n\tbytes = sizeof(struct uv_hub_info_s);\n\tfor_each_possible_blade(bid) {\n\t\tstruct uv_hub_info_s *new_hub;\n\n\t\t \n\t\tnew_hub = (bid == 0) ?  &uv_hub_info_node0\n\t\t\t: kzalloc_node(bytes, GFP_KERNEL, uv_blade_to_node(bid));\n\t\tif (WARN_ON_ONCE(!new_hub)) {\n\t\t\t \n\t\t\twhile (--bid > 0)\n\t\t\t\tkfree(uv_hub_info_list_blade[bid]);\n\t\t\tkfree(uv_hub_info_list_blade);\n\t\t\treturn;\n\t\t}\n\n\t\tuv_hub_info_list_blade[bid] = new_hub;\n\t\t*new_hub = hub_info;\n\n\t\t \n\t\tif (uv_gre_table)\n\t\t\tnew_hub->pnode = uv_blade_to_pnode(bid);\n\t\telse  \n\t\t\tnew_hub->pnode = 0xffff;\n\n\t\tnew_hub->numa_blade_id = bid;\n\t\tnew_hub->memory_nid = NUMA_NO_NODE;\n\t\tnew_hub->nr_possible_cpus = 0;\n\t\tnew_hub->nr_online_cpus = 0;\n\t}\n\n\t \n\n\tbytes = sizeof(void *) * num_possible_nodes();\n\t__uv_hub_info_list = kzalloc(bytes, GFP_KERNEL);\n\tif (WARN_ON_ONCE(!__uv_hub_info_list)) {\n\t\tfor_each_possible_blade(bid)\n\t\t\t \n\t\t\tif (bid != 0)\n\t\t\t\tkfree(uv_hub_info_list_blade[bid]);\n\t\tkfree(uv_hub_info_list_blade);\n\t\treturn;\n\t}\n\n\tfor_each_node(nodeid)\n\t\t__uv_hub_info_list[nodeid] = uv_hub_info_list_blade[uv_node_to_blade_id(nodeid)];\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tint apicid = per_cpu(x86_cpu_to_apicid, cpu);\n\t\tunsigned short bid;\n\t\tunsigned short pnode;\n\n\t\tpnode = uv_apicid_to_pnode(apicid);\n\t\tbid = uv_pnode_to_socket(pnode) - _min_socket;\n\n\t\tuv_cpu_info_per(cpu)->p_uv_hub_info = uv_hub_info_list_blade[bid];\n\t\tuv_cpu_info_per(cpu)->blade_cpu_id = uv_cpu_hub_info(cpu)->nr_possible_cpus++;\n\t\tif (uv_cpu_hub_info(cpu)->memory_nid == NUMA_NO_NODE)\n\t\t\tuv_cpu_hub_info(cpu)->memory_nid = cpu_to_node(cpu);\n\n\t\tif (uv_cpu_hub_info(cpu)->pnode == 0xffff)\n\t\t\tuv_cpu_hub_info(cpu)->pnode = pnode;\n\t}\n\n\tfor_each_possible_blade(bid) {\n\t\tunsigned short pnode = uv_hub_info_list_blade[bid]->pnode;\n\n\t\tif (pnode == 0xffff)\n\t\t\tcontinue;\n\n\t\tmin_pnode = min(pnode, min_pnode);\n\t\tmax_pnode = max(pnode, max_pnode);\n\t\tpr_info(\"UV: HUB:%2d pn:%02x nrcpus:%d\\n\",\n\t\t\tbid,\n\t\t\tuv_hub_info_list_blade[bid]->pnode,\n\t\t\tuv_hub_info_list_blade[bid]->nr_possible_cpus);\n\t}\n\n\tpr_info(\"UV: min_pnode:%02x max_pnode:%02x\\n\", min_pnode, max_pnode);\n\tmap_gru_high(max_pnode);\n\tmap_mmr_high(max_pnode);\n\tmap_mmioh_high(min_pnode, max_pnode);\n\n\tkfree(uv_hub_info_list_blade);\n\tuv_hub_info_list_blade = NULL;\n\n\tuv_nmi_setup();\n\tuv_cpu_init();\n\tuv_setup_proc_files(0);\n\n\t \n\tpci_register_set_vga_state(uv_set_vga_state);\n\n\tcheck_efi_reboot();\n}\n\n \nvoid __init uv_system_init(void)\n{\n\tif (likely(!is_uv_system() && !is_uv_hubless(1)))\n\t\treturn;\n\n\tif (is_uv_system())\n\t\tuv_system_init_hub();\n\telse\n\t\tuv_system_init_hubless();\n}\n\napic_driver(apic_x2apic_uv_x);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}