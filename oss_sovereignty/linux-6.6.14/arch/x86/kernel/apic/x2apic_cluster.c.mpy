{
  "module_name": "x2apic_cluster.c",
  "hash_id": "cd1156ebc27d0c6e25452af047d520df6b95a254f4f20ebc430c3ca7564d0e60",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/x2apic_cluster.c",
  "human_readable_source": "\n\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#include <asm/apic.h>\n\n#include \"local.h\"\n\n#define apic_cluster(apicid) ((apicid) >> 4)\n\n \nstatic u32 *x86_cpu_to_logical_apicid __read_mostly;\n\nstatic DEFINE_PER_CPU(cpumask_var_t, ipi_mask);\nstatic DEFINE_PER_CPU_READ_MOSTLY(struct cpumask *, cluster_masks);\n\nstatic int x2apic_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n\treturn x2apic_enabled();\n}\n\nstatic void x2apic_send_IPI(int cpu, int vector)\n{\n\tu32 dest = x86_cpu_to_logical_apicid[cpu];\n\n\t \n\tweak_wrmsr_fence();\n\t__x2apic_send_IPI_dest(dest, vector, APIC_DEST_LOGICAL);\n}\n\nstatic void\n__x2apic_send_IPI_mask(const struct cpumask *mask, int vector, int apic_dest)\n{\n\tunsigned int cpu, clustercpu;\n\tstruct cpumask *tmpmsk;\n\tunsigned long flags;\n\tu32 dest;\n\n\t \n\tweak_wrmsr_fence();\n\tlocal_irq_save(flags);\n\n\ttmpmsk = this_cpu_cpumask_var_ptr(ipi_mask);\n\tcpumask_copy(tmpmsk, mask);\n\t \n\tif (apic_dest != APIC_DEST_ALLINC)\n\t\t__cpumask_clear_cpu(smp_processor_id(), tmpmsk);\n\n\t \n\tfor_each_cpu(cpu, tmpmsk) {\n\t\tstruct cpumask *cmsk = per_cpu(cluster_masks, cpu);\n\n\t\tdest = 0;\n\t\tfor_each_cpu_and(clustercpu, tmpmsk, cmsk)\n\t\t\tdest |= x86_cpu_to_logical_apicid[clustercpu];\n\n\t\tif (!dest)\n\t\t\tcontinue;\n\n\t\t__x2apic_send_IPI_dest(dest, vector, APIC_DEST_LOGICAL);\n\t\t \n\t\tcpumask_andnot(tmpmsk, tmpmsk, cmsk);\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void x2apic_send_IPI_mask(const struct cpumask *mask, int vector)\n{\n\t__x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLINC);\n}\n\nstatic void\nx2apic_send_IPI_mask_allbutself(const struct cpumask *mask, int vector)\n{\n\t__x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLBUT);\n}\n\nstatic u32 x2apic_calc_apicid(unsigned int cpu)\n{\n\treturn x86_cpu_to_logical_apicid[cpu];\n}\n\nstatic void init_x2apic_ldr(void)\n{\n\tstruct cpumask *cmsk = this_cpu_read(cluster_masks);\n\n\tBUG_ON(!cmsk);\n\n\tcpumask_set_cpu(smp_processor_id(), cmsk);\n}\n\n \nstatic void prefill_clustermask(struct cpumask *cmsk, unsigned int cpu, u32 cluster)\n{\n\tint cpu_i;\n\n\tfor_each_present_cpu(cpu_i) {\n\t\tstruct cpumask **cpu_cmsk = &per_cpu(cluster_masks, cpu_i);\n\t\tu32 apicid = apic->cpu_present_to_apicid(cpu_i);\n\n\t\tif (apicid == BAD_APICID || cpu_i == cpu || apic_cluster(apicid) != cluster)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON_ONCE(*cpu_cmsk == cmsk))\n\t\t\tcontinue;\n\n\t\tBUG_ON(*cpu_cmsk);\n\t\t*cpu_cmsk = cmsk;\n\t}\n}\n\nstatic int alloc_clustermask(unsigned int cpu, u32 cluster, int node)\n{\n\tstruct cpumask *cmsk = NULL;\n\tunsigned int cpu_i;\n\n\t \n\tif (per_cpu(cluster_masks, cpu))\n\t\treturn 0;\n\n\tif (system_state < SYSTEM_RUNNING)\n\t\tgoto alloc;\n\n\t \n\tfor_each_possible_cpu(cpu_i) {\n\t\tu32 apicid = apic->cpu_present_to_apicid(cpu_i);\n\n\t\tif (apicid != BAD_APICID && apic_cluster(apicid) == cluster) {\n\t\t\tcmsk = per_cpu(cluster_masks, cpu_i);\n\t\t\t \n\t\t\tif (cmsk) {\n\t\t\t\tper_cpu(cluster_masks, cpu) = cmsk;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t \nalloc:\n\tcmsk = kzalloc_node(sizeof(*cmsk), GFP_KERNEL, node);\n\tif (!cmsk)\n\t\treturn -ENOMEM;\n\tper_cpu(cluster_masks, cpu) = cmsk;\n\tprefill_clustermask(cmsk, cpu, cluster);\n\n\treturn 0;\n}\n\nstatic int x2apic_prepare_cpu(unsigned int cpu)\n{\n\tu32 phys_apicid = apic->cpu_present_to_apicid(cpu);\n\tu32 cluster = apic_cluster(phys_apicid);\n\tu32 logical_apicid = (cluster << 16) | (1 << (phys_apicid & 0xf));\n\n\tx86_cpu_to_logical_apicid[cpu] = logical_apicid;\n\n\tif (alloc_clustermask(cpu, cluster, cpu_to_node(cpu)) < 0)\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var(&per_cpu(ipi_mask, cpu), GFP_KERNEL))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int x2apic_dead_cpu(unsigned int dead_cpu)\n{\n\tstruct cpumask *cmsk = per_cpu(cluster_masks, dead_cpu);\n\n\tif (cmsk)\n\t\tcpumask_clear_cpu(dead_cpu, cmsk);\n\tfree_cpumask_var(per_cpu(ipi_mask, dead_cpu));\n\treturn 0;\n}\n\nstatic int x2apic_cluster_probe(void)\n{\n\tu32 slots;\n\n\tif (!x2apic_mode)\n\t\treturn 0;\n\n\tslots = max_t(u32, L1_CACHE_BYTES/sizeof(u32), nr_cpu_ids);\n\tx86_cpu_to_logical_apicid = kcalloc(slots, sizeof(u32), GFP_KERNEL);\n\tif (!x86_cpu_to_logical_apicid)\n\t\treturn 0;\n\n\tif (cpuhp_setup_state(CPUHP_X2APIC_PREPARE, \"x86/x2apic:prepare\",\n\t\t\t      x2apic_prepare_cpu, x2apic_dead_cpu) < 0) {\n\t\tpr_err(\"Failed to register X2APIC_PREPARE\\n\");\n\t\tkfree(x86_cpu_to_logical_apicid);\n\t\tx86_cpu_to_logical_apicid = NULL;\n\t\treturn 0;\n\t}\n\tinit_x2apic_ldr();\n\treturn 1;\n}\n\nstatic struct apic apic_x2apic_cluster __ro_after_init = {\n\n\t.name\t\t\t\t= \"cluster x2apic\",\n\t.probe\t\t\t\t= x2apic_cluster_probe,\n\t.acpi_madt_oem_check\t\t= x2apic_acpi_madt_oem_check,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= true,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.check_apicid_used\t\t= NULL,\n\t.init_apic_ldr\t\t\t= init_x2apic_ldr,\n\t.ioapic_phys_id_map\t\t= NULL,\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= x2apic_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= UINT_MAX,\n\t.x2apic_set_max_apicid\t\t= true,\n\t.get_apic_id\t\t\t= x2apic_get_apic_id,\n\t.set_apic_id\t\t\t= x2apic_set_apic_id,\n\n\t.calc_dest_apicid\t\t= x2apic_calc_apicid,\n\n\t.send_IPI\t\t\t= x2apic_send_IPI,\n\t.send_IPI_mask\t\t\t= x2apic_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= x2apic_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= x2apic_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= x2apic_send_IPI_all,\n\t.send_IPI_self\t\t\t= x2apic_send_IPI_self,\n\n\t.read\t\t\t\t= native_apic_msr_read,\n\t.write\t\t\t\t= native_apic_msr_write,\n\t.eoi\t\t\t\t= native_apic_msr_eoi,\n\t.icr_read\t\t\t= native_x2apic_icr_read,\n\t.icr_write\t\t\t= native_x2apic_icr_write,\n};\n\napic_driver(apic_x2apic_cluster);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}