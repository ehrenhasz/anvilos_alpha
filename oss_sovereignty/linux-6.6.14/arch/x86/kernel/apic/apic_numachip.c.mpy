{
  "module_name": "apic_numachip.c",
  "hash_id": "e10ea49f72f0769727781f09c05c237c51447edfe54af9f872ee50961019a3a4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/apic_numachip.c",
  "human_readable_source": " \n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/pgtable.h>\n\n#include <asm/numachip/numachip.h>\n#include <asm/numachip/numachip_csr.h>\n\n\n#include \"local.h\"\n\nu8 numachip_system __read_mostly;\nstatic const struct apic apic_numachip1;\nstatic const struct apic apic_numachip2;\nstatic void (*numachip_apic_icr_write)(int apicid, unsigned int val) __read_mostly;\n\nstatic unsigned int numachip1_get_apic_id(unsigned long x)\n{\n\tunsigned long value;\n\tunsigned int id = (x >> 24) & 0xff;\n\n\tif (static_cpu_has(X86_FEATURE_NODEID_MSR)) {\n\t\trdmsrl(MSR_FAM10H_NODE_ID, value);\n\t\tid |= (value << 2) & 0xff00;\n\t}\n\n\treturn id;\n}\n\nstatic u32 numachip1_set_apic_id(unsigned int id)\n{\n\treturn (id & 0xff) << 24;\n}\n\nstatic unsigned int numachip2_get_apic_id(unsigned long x)\n{\n\tu64 mcfg;\n\n\trdmsrl(MSR_FAM10H_MMIO_CONF_BASE, mcfg);\n\treturn ((mcfg >> (28 - 8)) & 0xfff00) | (x >> 24);\n}\n\nstatic u32 numachip2_set_apic_id(unsigned int id)\n{\n\treturn id << 24;\n}\n\nstatic int numachip_phys_pkg_id(int initial_apic_id, int index_msb)\n{\n\treturn initial_apic_id >> index_msb;\n}\n\nstatic void numachip1_apic_icr_write(int apicid, unsigned int val)\n{\n\twrite_lcsr(CSR_G3_EXT_IRQ_GEN, (apicid << 16) | val);\n}\n\nstatic void numachip2_apic_icr_write(int apicid, unsigned int val)\n{\n\tnumachip2_write32_lcsr(NUMACHIP2_APIC_ICR, (apicid << 12) | val);\n}\n\nstatic int numachip_wakeup_secondary(int phys_apicid, unsigned long start_rip)\n{\n\tnumachip_apic_icr_write(phys_apicid, APIC_DM_INIT);\n\tnumachip_apic_icr_write(phys_apicid, APIC_DM_STARTUP |\n\t\t(start_rip >> 12));\n\n\treturn 0;\n}\n\nstatic void numachip_send_IPI_one(int cpu, int vector)\n{\n\tint local_apicid, apicid = per_cpu(x86_cpu_to_apicid, cpu);\n\tunsigned int dmode;\n\n\tpreempt_disable();\n\tlocal_apicid = __this_cpu_read(x86_cpu_to_apicid);\n\n\t \n\tif (!((apicid ^ local_apicid) >> NUMACHIP_LAPIC_BITS)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\t__default_send_IPI_dest_field(apicid, vector,\n\t\t\tAPIC_DEST_PHYSICAL);\n\t\tlocal_irq_restore(flags);\n\t\tpreempt_enable();\n\t\treturn;\n\t}\n\tpreempt_enable();\n\n\tdmode = (vector == NMI_VECTOR) ? APIC_DM_NMI : APIC_DM_FIXED;\n\tnumachip_apic_icr_write(apicid, dmode | vector);\n}\n\nstatic void numachip_send_IPI_mask(const struct cpumask *mask, int vector)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask)\n\t\tnumachip_send_IPI_one(cpu, vector);\n}\n\nstatic void numachip_send_IPI_mask_allbutself(const struct cpumask *mask,\n\t\t\t\t\t\tint vector)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tif (cpu != this_cpu)\n\t\t\tnumachip_send_IPI_one(cpu, vector);\n\t}\n}\n\nstatic void numachip_send_IPI_allbutself(int vector)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tunsigned int cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu != this_cpu)\n\t\t\tnumachip_send_IPI_one(cpu, vector);\n\t}\n}\n\nstatic void numachip_send_IPI_all(int vector)\n{\n\tnumachip_send_IPI_mask(cpu_online_mask, vector);\n}\n\nstatic void numachip_send_IPI_self(int vector)\n{\n\tapic_write(APIC_SELF_IPI, vector);\n}\n\nstatic int __init numachip1_probe(void)\n{\n\treturn apic == &apic_numachip1;\n}\n\nstatic int __init numachip2_probe(void)\n{\n\treturn apic == &apic_numachip2;\n}\n\nstatic void fixup_cpu_id(struct cpuinfo_x86 *c, int node)\n{\n\tu64 val;\n\tu32 nodes = 1;\n\n\tthis_cpu_write(cpu_llc_id, node);\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_NODEID_MSR)) {\n\t\trdmsrl(MSR_FAM10H_NODE_ID, val);\n\t\tnodes = ((val >> 3) & 7) + 1;\n\t}\n\n\tc->phys_proc_id = node / nodes;\n}\n\nstatic int __init numachip_system_init(void)\n{\n\t \n\tswitch (numachip_system) {\n\tcase 1:\n\t\tinit_extra_mapping_uc(NUMACHIP_LCSR_BASE, NUMACHIP_LCSR_SIZE);\n\t\tnumachip_apic_icr_write = numachip1_apic_icr_write;\n\t\tbreak;\n\tcase 2:\n\t\tinit_extra_mapping_uc(NUMACHIP2_LCSR_BASE, NUMACHIP2_LCSR_SIZE);\n\t\tnumachip_apic_icr_write = numachip2_apic_icr_write;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tx86_cpuinit.fixup_cpu_id = fixup_cpu_id;\n\tx86_init.pci.arch_init = pci_numachip_init;\n\n\treturn 0;\n}\nearly_initcall(numachip_system_init);\n\nstatic int numachip1_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n\tif ((strncmp(oem_id, \"NUMASC\", 6) != 0) ||\n\t    (strncmp(oem_table_id, \"NCONNECT\", 8) != 0))\n\t\treturn 0;\n\n\tnumachip_system = 1;\n\n\treturn 1;\n}\n\nstatic int numachip2_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n\tif ((strncmp(oem_id, \"NUMASC\", 6) != 0) ||\n\t    (strncmp(oem_table_id, \"NCONECT2\", 8) != 0))\n\t\treturn 0;\n\n\tnumachip_system = 2;\n\n\treturn 1;\n}\n\nstatic const struct apic apic_numachip1 __refconst = {\n\t.name\t\t\t\t= \"NumaConnect system\",\n\t.probe\t\t\t\t= numachip1_probe,\n\t.acpi_madt_oem_check\t\t= numachip1_acpi_madt_oem_check,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= false,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= numachip_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= UINT_MAX,\n\t.get_apic_id\t\t\t= numachip1_get_apic_id,\n\t.set_apic_id\t\t\t= numachip1_set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_default_calc_apicid,\n\n\t.send_IPI\t\t\t= numachip_send_IPI_one,\n\t.send_IPI_mask\t\t\t= numachip_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= numachip_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= numachip_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= numachip_send_IPI_all,\n\t.send_IPI_self\t\t\t= numachip_send_IPI_self,\n\n\t.wakeup_secondary_cpu\t\t= numachip_wakeup_secondary,\n\n\t.read\t\t\t\t= native_apic_mem_read,\n\t.write\t\t\t\t= native_apic_mem_write,\n\t.eoi\t\t\t\t= native_apic_mem_eoi,\n\t.icr_read\t\t\t= native_apic_icr_read,\n\t.icr_write\t\t\t= native_apic_icr_write,\n};\n\napic_driver(apic_numachip1);\n\nstatic const struct apic apic_numachip2 __refconst = {\n\t.name\t\t\t\t= \"NumaConnect2 system\",\n\t.probe\t\t\t\t= numachip2_probe,\n\t.acpi_madt_oem_check\t\t= numachip2_acpi_madt_oem_check,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= false,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= numachip_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= UINT_MAX,\n\t.get_apic_id\t\t\t= numachip2_get_apic_id,\n\t.set_apic_id\t\t\t= numachip2_set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_default_calc_apicid,\n\n\t.send_IPI\t\t\t= numachip_send_IPI_one,\n\t.send_IPI_mask\t\t\t= numachip_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= numachip_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= numachip_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= numachip_send_IPI_all,\n\t.send_IPI_self\t\t\t= numachip_send_IPI_self,\n\n\t.wakeup_secondary_cpu\t\t= numachip_wakeup_secondary,\n\n\t.read\t\t\t\t= native_apic_mem_read,\n\t.write\t\t\t\t= native_apic_mem_write,\n\t.eoi\t\t\t\t= native_apic_mem_eoi,\n\t.icr_read\t\t\t= native_apic_icr_read,\n\t.icr_write\t\t\t= native_apic_icr_write,\n};\n\napic_driver(apic_numachip2);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}