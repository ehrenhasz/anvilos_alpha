{
  "module_name": "apic_flat_64.c",
  "hash_id": "b1bb089df8bcf6a39e5129c9d9beb1a23c6dc4bb1ae0223058fed3b07474d8d1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/apic_flat_64.c",
  "human_readable_source": "\n \n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/acpi.h>\n\n#include <asm/jailhouse_para.h>\n#include <asm/apic.h>\n\n#include \"local.h\"\n\nstatic struct apic apic_physflat;\nstatic struct apic apic_flat;\n\nstruct apic *apic __ro_after_init = &apic_flat;\nEXPORT_SYMBOL_GPL(apic);\n\nstatic int flat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n\treturn 1;\n}\n\nstatic void _flat_send_IPI_mask(unsigned long mask, int vector)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__default_send_IPI_dest_field(mask, vector, APIC_DEST_LOGICAL);\n\tlocal_irq_restore(flags);\n}\n\nstatic void flat_send_IPI_mask(const struct cpumask *cpumask, int vector)\n{\n\tunsigned long mask = cpumask_bits(cpumask)[0];\n\n\t_flat_send_IPI_mask(mask, vector);\n}\n\nstatic void\nflat_send_IPI_mask_allbutself(const struct cpumask *cpumask, int vector)\n{\n\tunsigned long mask = cpumask_bits(cpumask)[0];\n\tint cpu = smp_processor_id();\n\n\tif (cpu < BITS_PER_LONG)\n\t\t__clear_bit(cpu, &mask);\n\n\t_flat_send_IPI_mask(mask, vector);\n}\n\nstatic unsigned int flat_get_apic_id(unsigned long x)\n{\n\treturn (x >> 24) & 0xFF;\n}\n\nstatic u32 set_apic_id(unsigned int id)\n{\n\treturn (id & 0xFF) << 24;\n}\n\nstatic int flat_phys_pkg_id(int initial_apic_id, int index_msb)\n{\n\treturn initial_apic_id >> index_msb;\n}\n\nstatic int flat_probe(void)\n{\n\treturn 1;\n}\n\nstatic struct apic apic_flat __ro_after_init = {\n\t.name\t\t\t\t= \"flat\",\n\t.probe\t\t\t\t= flat_probe,\n\t.acpi_madt_oem_check\t\t= flat_acpi_madt_oem_check,\n\t.apic_id_registered\t\t= default_apic_id_registered,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= true,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.init_apic_ldr\t\t\t= default_init_apic_ldr,\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= flat_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= 0xFE,\n\t.get_apic_id\t\t\t= flat_get_apic_id,\n\t.set_apic_id\t\t\t= set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_flat_calc_apicid,\n\n\t.send_IPI\t\t\t= default_send_IPI_single,\n\t.send_IPI_mask\t\t\t= flat_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= flat_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= default_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= default_send_IPI_all,\n\t.send_IPI_self\t\t\t= default_send_IPI_self,\n\n\t.read\t\t\t\t= native_apic_mem_read,\n\t.write\t\t\t\t= native_apic_mem_write,\n\t.eoi\t\t\t\t= native_apic_mem_eoi,\n\t.icr_read\t\t\t= native_apic_icr_read,\n\t.icr_write\t\t\t= native_apic_icr_write,\n\t.wait_icr_idle\t\t\t= apic_mem_wait_icr_idle,\n\t.safe_wait_icr_idle\t\t= apic_mem_wait_icr_idle_timeout,\n};\n\n \nstatic int physflat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n#ifdef CONFIG_ACPI\n\t \n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&\n\t\t(acpi_gbl_FADT.flags & ACPI_FADT_APIC_PHYSICAL)) {\n\t\tprintk(KERN_DEBUG \"system APIC only can use physical flat\");\n\t\treturn 1;\n\t}\n\n\tif (!strncmp(oem_id, \"IBM\", 3) && !strncmp(oem_table_id, \"EXA\", 3)) {\n\t\tprintk(KERN_DEBUG \"IBM Summit detected, will use apic physical\");\n\t\treturn 1;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int physflat_probe(void)\n{\n\treturn apic == &apic_physflat || num_possible_cpus() > 8 || jailhouse_paravirt();\n}\n\nstatic struct apic apic_physflat __ro_after_init = {\n\n\t.name\t\t\t\t= \"physical flat\",\n\t.probe\t\t\t\t= physflat_probe,\n\t.acpi_madt_oem_check\t\t= physflat_acpi_madt_oem_check,\n\t.apic_id_registered\t\t= default_apic_id_registered,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= false,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.check_apicid_used\t\t= NULL,\n\t.ioapic_phys_id_map\t\t= NULL,\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= flat_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= 0xFE,\n\t.get_apic_id\t\t\t= flat_get_apic_id,\n\t.set_apic_id\t\t\t= set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_default_calc_apicid,\n\n\t.send_IPI\t\t\t= default_send_IPI_single_phys,\n\t.send_IPI_mask\t\t\t= default_send_IPI_mask_sequence_phys,\n\t.send_IPI_mask_allbutself\t= default_send_IPI_mask_allbutself_phys,\n\t.send_IPI_allbutself\t\t= default_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= default_send_IPI_all,\n\t.send_IPI_self\t\t\t= default_send_IPI_self,\n\n\t.read\t\t\t\t= native_apic_mem_read,\n\t.write\t\t\t\t= native_apic_mem_write,\n\t.eoi\t\t\t\t= native_apic_mem_eoi,\n\t.icr_read\t\t\t= native_apic_icr_read,\n\t.icr_write\t\t\t= native_apic_icr_write,\n\t.wait_icr_idle\t\t\t= apic_mem_wait_icr_idle,\n\t.safe_wait_icr_idle\t\t= apic_mem_wait_icr_idle_timeout,\n};\n\n \napic_drivers(apic_physflat, apic_flat);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}