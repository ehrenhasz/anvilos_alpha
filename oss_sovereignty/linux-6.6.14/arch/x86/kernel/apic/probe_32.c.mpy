{
  "module_name": "probe_32.c",
  "hash_id": "898c0f6821075be0dddf9f4a00946f813cdd872dc45ab3eed17a74c76ce78ad0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/probe_32.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n\n#include <xen/xen.h>\n\n#include <asm/io_apic.h>\n#include <asm/apic.h>\n#include <asm/acpi.h>\n\n#include \"local.h\"\n\nstatic int default_phys_pkg_id(int cpuid_apic, int index_msb)\n{\n\treturn cpuid_apic >> index_msb;\n}\n\n \nstatic int probe_default(void)\n{\n\treturn 1;\n}\n\nstatic struct apic apic_default __ro_after_init = {\n\n\t.name\t\t\t\t= \"default\",\n\t.probe\t\t\t\t= probe_default,\n\t.apic_id_registered\t\t= default_apic_id_registered,\n\n\t.delivery_mode\t\t\t= APIC_DELIVERY_MODE_FIXED,\n\t.dest_mode_logical\t\t= true,\n\n\t.disable_esr\t\t\t= 0,\n\n\t.check_apicid_used\t\t= default_check_apicid_used,\n\t.init_apic_ldr\t\t\t= default_init_apic_ldr,\n\t.ioapic_phys_id_map\t\t= default_ioapic_phys_id_map,\n\t.cpu_present_to_apicid\t\t= default_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= default_phys_pkg_id,\n\n\t.max_apic_id\t\t\t= 0xFE,\n\t.get_apic_id\t\t\t= default_get_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_flat_calc_apicid,\n\n\t.send_IPI\t\t\t= default_send_IPI_single,\n\t.send_IPI_mask\t\t\t= default_send_IPI_mask_logical,\n\t.send_IPI_mask_allbutself\t= default_send_IPI_mask_allbutself_logical,\n\t.send_IPI_allbutself\t\t= default_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= default_send_IPI_all,\n\t.send_IPI_self\t\t\t= default_send_IPI_self,\n\n\t.read\t\t\t\t= native_apic_mem_read,\n\t.write\t\t\t\t= native_apic_mem_write,\n\t.eoi\t\t\t\t= native_apic_mem_eoi,\n\t.icr_read\t\t\t= native_apic_icr_read,\n\t.icr_write\t\t\t= native_apic_icr_write,\n\t.wait_icr_idle\t\t\t= apic_mem_wait_icr_idle,\n\t.safe_wait_icr_idle\t\t= apic_mem_wait_icr_idle_timeout,\n};\n\napic_driver(apic_default);\n\nstruct apic *apic __ro_after_init = &apic_default;\nEXPORT_SYMBOL_GPL(apic);\n\nstatic int cmdline_apic __initdata;\nstatic int __init parse_apic(char *arg)\n{\n\tstruct apic **drv;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\n\t\tif (!strcmp((*drv)->name, arg)) {\n\t\t\tapic_install_driver(*drv);\n\t\t\tcmdline_apic = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\nearly_param(\"apic\", parse_apic);\n\nvoid __init x86_32_probe_bigsmp_early(void)\n{\n\tif (nr_cpu_ids <= 8 || xen_pv_domain())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_X86_BIGSMP)) {\n\t\tswitch (boot_cpu_data.x86_vendor) {\n\t\tcase X86_VENDOR_INTEL:\n\t\t\tif (!APIC_XAPIC(boot_cpu_apic_version))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase X86_VENDOR_HYGON:\n\t\tcase X86_VENDOR_AMD:\n\t\t\tif (apic_bigsmp_possible(cmdline_apic))\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpr_info(\"Limiting to 8 possible CPUs\\n\");\n\tset_nr_cpu_ids(8);\n}\n\nvoid __init x86_32_install_bigsmp(void)\n{\n\tif (nr_cpu_ids > 8 && !xen_pv_domain())\n\t\tapic_bigsmp_force();\n}\n\nvoid __init x86_32_probe_apic(void)\n{\n\tif (!cmdline_apic) {\n\t\tstruct apic **drv;\n\n\t\tfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\n\t\t\tif ((*drv)->probe()) {\n\t\t\t\tapic_install_driver(*drv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (drv == __apicdrivers_end)\n\t\t\tpanic(\"Didn't find an APIC driver\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}