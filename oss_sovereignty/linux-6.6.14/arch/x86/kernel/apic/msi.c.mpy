{
  "module_name": "msi.c",
  "hash_id": "a6fa0a767c9d325b0e5d213cd6620f1d57ddad0e84daf66d287e18d17b65b289",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apic/msi.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/pci.h>\n#include <linux/dmar.h>\n#include <linux/hpet.h>\n#include <linux/msi.h>\n#include <asm/irqdomain.h>\n#include <asm/hpet.h>\n#include <asm/hw_irq.h>\n#include <asm/apic.h>\n#include <asm/irq_remapping.h>\n#include <asm/xen/hypervisor.h>\n\nstruct irq_domain *x86_pci_msi_default_domain __ro_after_init;\n\nstatic void irq_msi_update_msg(struct irq_data *irqd, struct irq_cfg *cfg)\n{\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\n\t__irq_msi_compose_msg(cfg, msg, false);\n\tirq_data_get_irq_chip(irqd)->irq_write_msi_msg(irqd, msg);\n}\n\nstatic int\nmsi_set_affinity(struct irq_data *irqd, const struct cpumask *mask, bool force)\n{\n\tstruct irq_cfg old_cfg, *cfg = irqd_cfg(irqd);\n\tstruct irq_data *parent = irqd->parent_data;\n\tunsigned int cpu;\n\tint ret;\n\n\t \n\tcpu = cpumask_first(irq_data_get_effective_affinity_mask(irqd));\n\told_cfg = *cfg;\n\n\t \n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)\n\t\treturn ret;\n\n\t \n\tif (!irqd_can_reserve(irqd) ||\n\t    cfg->vector == old_cfg.vector ||\n\t    old_cfg.vector == MANAGED_IRQ_SHUTDOWN_VECTOR ||\n\t    !irqd_is_started(irqd) ||\n\t    cfg->dest_apicid == old_cfg.dest_apicid) {\n\t\tirq_msi_update_msg(irqd, cfg);\n\t\treturn ret;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(cpu != smp_processor_id())) {\n\t\tirq_msi_update_msg(irqd, cfg);\n\t\treturn ret;\n\t}\n\n\t \n\tlock_vector_lock();\n\n\t \n\tif (IS_ERR_OR_NULL(this_cpu_read(vector_irq[cfg->vector])))\n\t\tthis_cpu_write(vector_irq[cfg->vector], VECTOR_RETRIGGERED);\n\n\t \n\told_cfg.vector = cfg->vector;\n\tirq_msi_update_msg(irqd, &old_cfg);\n\n\t \n\tirq_msi_update_msg(irqd, cfg);\n\n\t \n\tunlock_vector_lock();\n\n\t \n\tif (lapic_vector_set_in_irr(cfg->vector))\n\t\tirq_data_get_irq_chip(irqd)->irq_retrigger(irqd);\n\n\treturn ret;\n}\n\n \nbool pci_dev_has_default_msi_parent_domain(struct pci_dev *dev)\n{\n\tstruct irq_domain *domain = dev_get_msi_domain(&dev->dev);\n\n\tif (!domain)\n\t\tdomain = dev_get_msi_domain(&dev->bus->dev);\n\tif (!domain)\n\t\treturn false;\n\n\treturn domain == x86_vector_domain;\n}\n\n \nstatic int x86_msi_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t   int nvec, msi_alloc_info_t *alloc)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\tinit_irq_alloc_info(alloc, NULL);\n\n\tswitch (info->bus_token) {\n\tcase DOMAIN_BUS_PCI_DEVICE_MSI:\n\t\talloc->type = X86_IRQ_ALLOC_TYPE_PCI_MSI;\n\t\treturn 0;\n\tcase DOMAIN_BUS_PCI_DEVICE_MSIX:\n\tcase DOMAIN_BUS_PCI_DEVICE_IMS:\n\t\talloc->type = X86_IRQ_ALLOC_TYPE_PCI_MSIX;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic bool x86_init_dev_msi_info(struct device *dev, struct irq_domain *domain,\n\t\t\t\t  struct irq_domain *real_parent, struct msi_domain_info *info)\n{\n\tconst struct msi_parent_ops *pops = real_parent->msi_parent_ops;\n\n\t \n\tswitch (real_parent->bus_token) {\n\tcase DOMAIN_BUS_ANY:\n\t\t \n\t\tif (WARN_ON_ONCE(domain != real_parent))\n\t\t\treturn false;\n\t\tinfo->chip->irq_set_affinity = msi_set_affinity;\n\t\tbreak;\n\tcase DOMAIN_BUS_DMAR:\n\tcase DOMAIN_BUS_AMDVI:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\t \n\tswitch(info->bus_token) {\n\tcase DOMAIN_BUS_PCI_DEVICE_MSI:\n\tcase DOMAIN_BUS_PCI_DEVICE_MSIX:\n\t\tbreak;\n\tcase DOMAIN_BUS_PCI_DEVICE_IMS:\n\t\tif (!(pops->supported_flags & MSI_FLAG_PCI_IMS))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\t \n\tinfo->flags\t\t\t&= pops->supported_flags;\n\t \n\tinfo->flags\t\t\t|= X86_VECTOR_MSI_FLAGS_REQUIRED;\n\n\t \n\tinfo->ops->msi_prepare\t\t= x86_msi_prepare;\n\n\tinfo->chip->irq_ack\t\t= irq_chip_ack_parent;\n\tinfo->chip->irq_retrigger\t= irq_chip_retrigger_hierarchy;\n\tinfo->chip->flags\t\t|= IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t\t   IRQCHIP_AFFINITY_PRE_STARTUP;\n\n\tinfo->handler\t\t\t= handle_edge_irq;\n\tinfo->handler_name\t\t= \"edge\";\n\n\treturn true;\n}\n\nstatic const struct msi_parent_ops x86_vector_msi_parent_ops = {\n\t.supported_flags\t= X86_VECTOR_MSI_FLAGS_SUPPORTED,\n\t.init_dev_msi_info\t= x86_init_dev_msi_info,\n};\n\nstruct irq_domain * __init native_create_pci_msi_domain(void)\n{\n\tif (apic_is_disabled)\n\t\treturn NULL;\n\n\tx86_vector_domain->flags |= IRQ_DOMAIN_FLAG_MSI_PARENT;\n\tx86_vector_domain->msi_parent_ops = &x86_vector_msi_parent_ops;\n\treturn x86_vector_domain;\n}\n\nvoid __init x86_create_pci_msi_domain(void)\n{\n\tx86_pci_msi_default_domain = x86_init.irqs.create_pci_msi_domain();\n}\n\n \nint pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,\n\t\t    msi_alloc_info_t *arg)\n{\n\tinit_irq_alloc_info(arg, NULL);\n\n\tif (to_pci_dev(dev)->msix_enabled)\n\t\targ->type = X86_IRQ_ALLOC_TYPE_PCI_MSIX;\n\telse\n\t\targ->type = X86_IRQ_ALLOC_TYPE_PCI_MSI;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_msi_prepare);\n\n#ifdef CONFIG_DMAR_TABLE\n \nstatic void dmar_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\t__irq_msi_compose_msg(irqd_cfg(data), msg, true);\n}\n\nstatic void dmar_msi_write_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tdmar_msi_write(data->irq, msg);\n}\n\nstatic struct irq_chip dmar_msi_controller = {\n\t.name\t\t\t= \"DMAR-MSI\",\n\t.irq_unmask\t\t= dmar_msi_unmask,\n\t.irq_mask\t\t= dmar_msi_mask,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_set_affinity\t= msi_domain_set_affinity,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_compose_msi_msg\t= dmar_msi_compose_msg,\n\t.irq_write_msi_msg\t= dmar_msi_write_msg,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_AFFINITY_PRE_STARTUP,\n};\n\nstatic int dmar_msi_init(struct irq_domain *domain,\n\t\t\t struct msi_domain_info *info, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, msi_alloc_info_t *arg)\n{\n\tirq_domain_set_info(domain, virq, arg->devid, info->chip, NULL,\n\t\t\t    handle_edge_irq, arg->data, \"edge\");\n\n\treturn 0;\n}\n\nstatic struct msi_domain_ops dmar_msi_domain_ops = {\n\t.msi_init\t= dmar_msi_init,\n};\n\nstatic struct msi_domain_info dmar_msi_domain_info = {\n\t.ops\t\t= &dmar_msi_domain_ops,\n\t.chip\t\t= &dmar_msi_controller,\n\t.flags\t\t= MSI_FLAG_USE_DEF_DOM_OPS,\n};\n\nstatic struct irq_domain *dmar_get_irq_domain(void)\n{\n\tstatic struct irq_domain *dmar_domain;\n\tstatic DEFINE_MUTEX(dmar_lock);\n\tstruct fwnode_handle *fn;\n\n\tmutex_lock(&dmar_lock);\n\tif (dmar_domain)\n\t\tgoto out;\n\n\tfn = irq_domain_alloc_named_fwnode(\"DMAR-MSI\");\n\tif (fn) {\n\t\tdmar_domain = msi_create_irq_domain(fn, &dmar_msi_domain_info,\n\t\t\t\t\t\t    x86_vector_domain);\n\t\tif (!dmar_domain)\n\t\t\tirq_domain_free_fwnode(fn);\n\t}\nout:\n\tmutex_unlock(&dmar_lock);\n\treturn dmar_domain;\n}\n\nint dmar_alloc_hwirq(int id, int node, void *arg)\n{\n\tstruct irq_domain *domain = dmar_get_irq_domain();\n\tstruct irq_alloc_info info;\n\n\tif (!domain)\n\t\treturn -1;\n\n\tinit_irq_alloc_info(&info, NULL);\n\tinfo.type = X86_IRQ_ALLOC_TYPE_DMAR;\n\tinfo.devid = id;\n\tinfo.hwirq = id;\n\tinfo.data = arg;\n\n\treturn irq_domain_alloc_irqs(domain, 1, node, &info);\n}\n\nvoid dmar_free_hwirq(int irq)\n{\n\tirq_domain_free_irqs(irq, 1);\n}\n#endif\n\nbool arch_restore_msi_irqs(struct pci_dev *dev)\n{\n\treturn xen_initdom_restore_msi(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}