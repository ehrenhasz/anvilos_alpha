{
  "module_name": "process_64.c",
  "hash_id": "f7d0a494612e193524993597a4480d99209a6b638cb0a8fcccd62f3b4f2d4e19",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/process_64.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/cpu.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/elfcore.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/notifier.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n#include <linux/prctl.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/ftrace.h>\n#include <linux/syscalls.h>\n#include <linux/iommu.h>\n\n#include <asm/processor.h>\n#include <asm/pkru.h>\n#include <asm/fpu/sched.h>\n#include <asm/mmu_context.h>\n#include <asm/prctl.h>\n#include <asm/desc.h>\n#include <asm/proto.h>\n#include <asm/ia32.h>\n#include <asm/debugreg.h>\n#include <asm/switch_to.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/vdso.h>\n#include <asm/resctrl.h>\n#include <asm/unistd.h>\n#include <asm/fsgsbase.h>\n#ifdef CONFIG_IA32_EMULATION\n \n#include <asm/unistd_32_ia32.h>\n#endif\n\n#include \"process.h\"\n\n \nvoid __show_regs(struct pt_regs *regs, enum show_regs_mode mode,\n\t\t const char *log_lvl)\n{\n\tunsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;\n\tunsigned long d0, d1, d2, d3, d6, d7;\n\tunsigned int fsindex, gsindex;\n\tunsigned int ds, es;\n\n\tshow_iret_regs(regs, log_lvl);\n\n\tif (regs->orig_ax != -1)\n\t\tpr_cont(\" ORIG_RAX: %016lx\\n\", regs->orig_ax);\n\telse\n\t\tpr_cont(\"\\n\");\n\n\tprintk(\"%sRAX: %016lx RBX: %016lx RCX: %016lx\\n\",\n\t       log_lvl, regs->ax, regs->bx, regs->cx);\n\tprintk(\"%sRDX: %016lx RSI: %016lx RDI: %016lx\\n\",\n\t       log_lvl, regs->dx, regs->si, regs->di);\n\tprintk(\"%sRBP: %016lx R08: %016lx R09: %016lx\\n\",\n\t       log_lvl, regs->bp, regs->r8, regs->r9);\n\tprintk(\"%sR10: %016lx R11: %016lx R12: %016lx\\n\",\n\t       log_lvl, regs->r10, regs->r11, regs->r12);\n\tprintk(\"%sR13: %016lx R14: %016lx R15: %016lx\\n\",\n\t       log_lvl, regs->r13, regs->r14, regs->r15);\n\n\tif (mode == SHOW_REGS_SHORT)\n\t\treturn;\n\n\tif (mode == SHOW_REGS_USER) {\n\t\trdmsrl(MSR_FS_BASE, fs);\n\t\trdmsrl(MSR_KERNEL_GS_BASE, shadowgs);\n\t\tprintk(\"%sFS:  %016lx GS:  %016lx\\n\",\n\t\t       log_lvl, fs, shadowgs);\n\t\treturn;\n\t}\n\n\tasm(\"movl %%ds,%0\" : \"=r\" (ds));\n\tasm(\"movl %%es,%0\" : \"=r\" (es));\n\tasm(\"movl %%fs,%0\" : \"=r\" (fsindex));\n\tasm(\"movl %%gs,%0\" : \"=r\" (gsindex));\n\n\trdmsrl(MSR_FS_BASE, fs);\n\trdmsrl(MSR_GS_BASE, gs);\n\trdmsrl(MSR_KERNEL_GS_BASE, shadowgs);\n\n\tcr0 = read_cr0();\n\tcr2 = read_cr2();\n\tcr3 = __read_cr3();\n\tcr4 = __read_cr4();\n\n\tprintk(\"%sFS:  %016lx(%04x) GS:%016lx(%04x) knlGS:%016lx\\n\",\n\t       log_lvl, fs, fsindex, gs, gsindex, shadowgs);\n\tprintk(\"%sCS:  %04lx DS: %04x ES: %04x CR0: %016lx\\n\",\n\t\tlog_lvl, regs->cs, ds, es, cr0);\n\tprintk(\"%sCR2: %016lx CR3: %016lx CR4: %016lx\\n\",\n\t\tlog_lvl, cr2, cr3, cr4);\n\n\tget_debugreg(d0, 0);\n\tget_debugreg(d1, 1);\n\tget_debugreg(d2, 2);\n\tget_debugreg(d3, 3);\n\tget_debugreg(d6, 6);\n\tget_debugreg(d7, 7);\n\n\t \n\tif (!((d0 == 0) && (d1 == 0) && (d2 == 0) && (d3 == 0) &&\n\t    (d6 == DR6_RESERVED) && (d7 == 0x400))) {\n\t\tprintk(\"%sDR0: %016lx DR1: %016lx DR2: %016lx\\n\",\n\t\t       log_lvl, d0, d1, d2);\n\t\tprintk(\"%sDR3: %016lx DR6: %016lx DR7: %016lx\\n\",\n\t\t       log_lvl, d3, d6, d7);\n\t}\n\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE))\n\t\tprintk(\"%sPKRU: %08x\\n\", log_lvl, read_pkru());\n}\n\nvoid release_thread(struct task_struct *dead_task)\n{\n\tWARN_ON(dead_task->mm);\n}\n\nenum which_selector {\n\tFS,\n\tGS\n};\n\n \nstatic noinstr unsigned long __rdgsbase_inactive(void)\n{\n\tunsigned long gsbase;\n\n\tlockdep_assert_irqs_disabled();\n\n\tif (!cpu_feature_enabled(X86_FEATURE_XENPV)) {\n\t\tnative_swapgs();\n\t\tgsbase = rdgsbase();\n\t\tnative_swapgs();\n\t} else {\n\t\tinstrumentation_begin();\n\t\trdmsrl(MSR_KERNEL_GS_BASE, gsbase);\n\t\tinstrumentation_end();\n\t}\n\n\treturn gsbase;\n}\n\n \nstatic noinstr void __wrgsbase_inactive(unsigned long gsbase)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (!cpu_feature_enabled(X86_FEATURE_XENPV)) {\n\t\tnative_swapgs();\n\t\twrgsbase(gsbase);\n\t\tnative_swapgs();\n\t} else {\n\t\tinstrumentation_begin();\n\t\twrmsrl(MSR_KERNEL_GS_BASE, gsbase);\n\t\tinstrumentation_end();\n\t}\n}\n\n \nstatic __always_inline void save_base_legacy(struct task_struct *prev_p,\n\t\t\t\t\t     unsigned short selector,\n\t\t\t\t\t     enum which_selector which)\n{\n\tif (likely(selector == 0)) {\n\t\t \n\t} else {\n\t\t \n\t\tif (which == FS)\n\t\t\tprev_p->thread.fsbase = 0;\n\t\telse\n\t\t\tprev_p->thread.gsbase = 0;\n\t}\n}\n\nstatic __always_inline void save_fsgs(struct task_struct *task)\n{\n\tsavesegment(fs, task->thread.fsindex);\n\tsavesegment(gs, task->thread.gsindex);\n\tif (static_cpu_has(X86_FEATURE_FSGSBASE)) {\n\t\t \n\t\ttask->thread.fsbase = rdfsbase();\n\t\ttask->thread.gsbase = __rdgsbase_inactive();\n\t} else {\n\t\tsave_base_legacy(task, task->thread.fsindex, FS);\n\t\tsave_base_legacy(task, task->thread.gsindex, GS);\n\t}\n}\n\n \nvoid current_save_fsgs(void)\n{\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tsave_fsgs(current);\n\tlocal_irq_restore(flags);\n}\n#if IS_ENABLED(CONFIG_KVM)\nEXPORT_SYMBOL_GPL(current_save_fsgs);\n#endif\n\nstatic __always_inline void loadseg(enum which_selector which,\n\t\t\t\t    unsigned short sel)\n{\n\tif (which == FS)\n\t\tloadsegment(fs, sel);\n\telse\n\t\tload_gs_index(sel);\n}\n\nstatic __always_inline void load_seg_legacy(unsigned short prev_index,\n\t\t\t\t\t    unsigned long prev_base,\n\t\t\t\t\t    unsigned short next_index,\n\t\t\t\t\t    unsigned long next_base,\n\t\t\t\t\t    enum which_selector which)\n{\n\tif (likely(next_index <= 3)) {\n\t\t \n\t\tif (next_base == 0) {\n\t\t\t \n\t\t\tif (static_cpu_has_bug(X86_BUG_NULL_SEG)) {\n\t\t\t\tloadseg(which, __USER_DS);\n\t\t\t\tloadseg(which, next_index);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (likely(prev_index | next_index | prev_base))\n\t\t\t\t\tloadseg(which, next_index);\n\t\t\t}\n\t\t} else {\n\t\t\tif (prev_index != next_index)\n\t\t\t\tloadseg(which, next_index);\n\t\t\twrmsrl(which == FS ? MSR_FS_BASE : MSR_KERNEL_GS_BASE,\n\t\t\t       next_base);\n\t\t}\n\t} else {\n\t\t \n\t\tloadseg(which, next_index);\n\t}\n}\n\n \nstatic __always_inline void x86_pkru_load(struct thread_struct *prev,\n\t\t\t\t\t  struct thread_struct *next)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_OSPKE))\n\t\treturn;\n\n\t \n\tprev->pkru = rdpkru();\n\n\t \n\tif (prev->pkru != next->pkru)\n\t\twrpkru(next->pkru);\n}\n\nstatic __always_inline void x86_fsgsbase_load(struct thread_struct *prev,\n\t\t\t\t\t      struct thread_struct *next)\n{\n\tif (static_cpu_has(X86_FEATURE_FSGSBASE)) {\n\t\t \n\t\tif (unlikely(prev->fsindex || next->fsindex))\n\t\t\tloadseg(FS, next->fsindex);\n\t\tif (unlikely(prev->gsindex || next->gsindex))\n\t\t\tloadseg(GS, next->gsindex);\n\n\t\t \n\t\twrfsbase(next->fsbase);\n\t\t__wrgsbase_inactive(next->gsbase);\n\t} else {\n\t\tload_seg_legacy(prev->fsindex, prev->fsbase,\n\t\t\t\tnext->fsindex, next->fsbase, FS);\n\t\tload_seg_legacy(prev->gsindex, prev->gsbase,\n\t\t\t\tnext->gsindex, next->gsbase, GS);\n\t}\n}\n\nunsigned long x86_fsgsbase_read_task(struct task_struct *task,\n\t\t\t\t     unsigned short selector)\n{\n\tunsigned short idx = selector >> 3;\n\tunsigned long base;\n\n\tif (likely((selector & SEGMENT_TI_MASK) == 0)) {\n\t\tif (unlikely(idx >= GDT_ENTRIES))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\t\treturn 0;\n\n\t\tidx -= GDT_ENTRY_TLS_MIN;\n\t\tbase = get_desc_base(&task->thread.tls_array[idx]);\n\t} else {\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tstruct ldt_struct *ldt;\n\n\t\t \n\t\tmutex_lock(&task->mm->context.lock);\n\t\tldt = task->mm->context.ldt;\n\t\tif (unlikely(!ldt || idx >= ldt->nr_entries))\n\t\t\tbase = 0;\n\t\telse\n\t\t\tbase = get_desc_base(ldt->entries + idx);\n\t\tmutex_unlock(&task->mm->context.lock);\n#else\n\t\tbase = 0;\n#endif\n\t}\n\n\treturn base;\n}\n\nunsigned long x86_gsbase_read_cpu_inactive(void)\n{\n\tunsigned long gsbase;\n\n\tif (boot_cpu_has(X86_FEATURE_FSGSBASE)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tgsbase = __rdgsbase_inactive();\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, gsbase);\n\t}\n\n\treturn gsbase;\n}\n\nvoid x86_gsbase_write_cpu_inactive(unsigned long gsbase)\n{\n\tif (boot_cpu_has(X86_FEATURE_FSGSBASE)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\t__wrgsbase_inactive(gsbase);\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\twrmsrl(MSR_KERNEL_GS_BASE, gsbase);\n\t}\n}\n\nunsigned long x86_fsbase_read_task(struct task_struct *task)\n{\n\tunsigned long fsbase;\n\n\tif (task == current)\n\t\tfsbase = x86_fsbase_read_cpu();\n\telse if (boot_cpu_has(X86_FEATURE_FSGSBASE) ||\n\t\t (task->thread.fsindex == 0))\n\t\tfsbase = task->thread.fsbase;\n\telse\n\t\tfsbase = x86_fsgsbase_read_task(task, task->thread.fsindex);\n\n\treturn fsbase;\n}\n\nunsigned long x86_gsbase_read_task(struct task_struct *task)\n{\n\tunsigned long gsbase;\n\n\tif (task == current)\n\t\tgsbase = x86_gsbase_read_cpu_inactive();\n\telse if (boot_cpu_has(X86_FEATURE_FSGSBASE) ||\n\t\t (task->thread.gsindex == 0))\n\t\tgsbase = task->thread.gsbase;\n\telse\n\t\tgsbase = x86_fsgsbase_read_task(task, task->thread.gsindex);\n\n\treturn gsbase;\n}\n\nvoid x86_fsbase_write_task(struct task_struct *task, unsigned long fsbase)\n{\n\tWARN_ON_ONCE(task == current);\n\n\ttask->thread.fsbase = fsbase;\n}\n\nvoid x86_gsbase_write_task(struct task_struct *task, unsigned long gsbase)\n{\n\tWARN_ON_ONCE(task == current);\n\n\ttask->thread.gsbase = gsbase;\n}\n\nstatic void\nstart_thread_common(struct pt_regs *regs, unsigned long new_ip,\n\t\t    unsigned long new_sp,\n\t\t    unsigned int _cs, unsigned int _ss, unsigned int _ds)\n{\n\tWARN_ON_ONCE(regs != current_pt_regs());\n\n\tif (static_cpu_has(X86_BUG_NULL_SEG)) {\n\t\t \n\t\tloadsegment(fs, __USER_DS);\n\t\tload_gs_index(__USER_DS);\n\t}\n\n\treset_thread_features();\n\n\tloadsegment(fs, 0);\n\tloadsegment(es, _ds);\n\tloadsegment(ds, _ds);\n\tload_gs_index(0);\n\n\tregs->ip\t\t= new_ip;\n\tregs->sp\t\t= new_sp;\n\tregs->cs\t\t= _cs;\n\tregs->ss\t\t= _ss;\n\tregs->flags\t\t= X86_EFLAGS_IF;\n}\n\nvoid\nstart_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)\n{\n\tstart_thread_common(regs, new_ip, new_sp,\n\t\t\t    __USER_CS, __USER_DS, 0);\n}\nEXPORT_SYMBOL_GPL(start_thread);\n\n#ifdef CONFIG_COMPAT\nvoid compat_start_thread(struct pt_regs *regs, u32 new_ip, u32 new_sp, bool x32)\n{\n\tstart_thread_common(regs, new_ip, new_sp,\n\t\t\t    x32 ? __USER_CS : __USER32_CS,\n\t\t\t    __USER_DS, __USER_DS);\n}\n#endif\n\n \n__no_kmsan_checks\n__visible __notrace_funcgraph struct task_struct *\n__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tstruct fpu *prev_fpu = &prev->fpu;\n\tint cpu = smp_processor_id();\n\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_DEBUG_ENTRY) &&\n\t\t     this_cpu_read(pcpu_hot.hardirq_stack_inuse));\n\n\tif (!test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\tswitch_fpu_prepare(prev_fpu, cpu);\n\n\t \n\tsave_fsgs(prev_p);\n\n\t \n\tload_TLS(next, cpu);\n\n\t \n\tarch_end_context_switch(next_p);\n\n\t \n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\tx86_fsgsbase_load(prev, next);\n\n\tx86_pkru_load(prev, next);\n\n\t \n\traw_cpu_write(pcpu_hot.current_task, next_p);\n\traw_cpu_write(pcpu_hot.top_of_stack, task_top_of_stack(next_p));\n\n\tswitch_fpu_finish();\n\n\t \n\tupdate_task_stack(next_p);\n\n\tswitch_to_extra(prev_p, next_p);\n\n\tif (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) {\n\t\t \n\t\tunsigned short ss_sel;\n\t\tsavesegment(ss, ss_sel);\n\t\tif (ss_sel != __KERNEL_DS)\n\t\t\tloadsegment(ss, __KERNEL_DS);\n\t}\n\n\t \n\tresctrl_sched_in(next_p);\n\n\treturn prev_p;\n}\n\nvoid set_personality_64bit(void)\n{\n\t \n\n\t \n\tclear_thread_flag(TIF_ADDR32);\n\t \n\ttask_pt_regs(current)->orig_ax = __NR_execve;\n\tcurrent_thread_info()->status &= ~TS_COMPAT;\n\tif (current->mm)\n\t\t__set_bit(MM_CONTEXT_HAS_VSYSCALL, &current->mm->context.flags);\n\n\t \n\tcurrent->personality &= ~READ_IMPLIES_EXEC;\n}\n\nstatic void __set_personality_x32(void)\n{\n#ifdef CONFIG_X86_X32_ABI\n\tif (current->mm)\n\t\tcurrent->mm->context.flags = 0;\n\n\tcurrent->personality &= ~READ_IMPLIES_EXEC;\n\t \n\ttask_pt_regs(current)->orig_ax = __NR_x32_execve | __X32_SYSCALL_BIT;\n\tcurrent_thread_info()->status &= ~TS_COMPAT;\n#endif\n}\n\nstatic void __set_personality_ia32(void)\n{\n#ifdef CONFIG_IA32_EMULATION\n\tif (current->mm) {\n\t\t \n\t\t__set_bit(MM_CONTEXT_UPROBE_IA32, &current->mm->context.flags);\n\t}\n\n\tcurrent->personality |= force_personality32;\n\t \n\ttask_pt_regs(current)->orig_ax = __NR_ia32_execve;\n\tcurrent_thread_info()->status |= TS_COMPAT;\n#endif\n}\n\nvoid set_personality_ia32(bool x32)\n{\n\t \n\tset_thread_flag(TIF_ADDR32);\n\n\tif (x32)\n\t\t__set_personality_x32();\n\telse\n\t\t__set_personality_ia32();\n}\nEXPORT_SYMBOL_GPL(set_personality_ia32);\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic long prctl_map_vdso(const struct vdso_image *image, unsigned long addr)\n{\n\tint ret;\n\n\tret = map_vdso_once(image, addr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (long)image->size;\n}\n#endif\n\n#ifdef CONFIG_ADDRESS_MASKING\n\n#define LAM_U57_BITS 6\n\nstatic int prctl_enable_tagged_addr(struct mm_struct *mm, unsigned long nr_bits)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_LAM))\n\t\treturn -ENODEV;\n\n\t \n\tif (current->mm != mm)\n\t\treturn -EINVAL;\n\n\tif (mm_valid_pasid(mm) &&\n\t    !test_bit(MM_CONTEXT_FORCE_TAGGED_SVA, &mm->context.flags))\n\t\treturn -EINVAL;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tif (test_bit(MM_CONTEXT_LOCK_LAM, &mm->context.flags)) {\n\t\tmmap_write_unlock(mm);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!nr_bits) {\n\t\tmmap_write_unlock(mm);\n\t\treturn -EINVAL;\n\t} else if (nr_bits <= LAM_U57_BITS) {\n\t\tmm->context.lam_cr3_mask = X86_CR3_LAM_U57;\n\t\tmm->context.untag_mask =  ~GENMASK(62, 57);\n\t} else {\n\t\tmmap_write_unlock(mm);\n\t\treturn -EINVAL;\n\t}\n\n\twrite_cr3(__read_cr3() | mm->context.lam_cr3_mask);\n\tset_tlbstate_lam_mode(mm);\n\tset_bit(MM_CONTEXT_LOCK_LAM, &mm->context.flags);\n\n\tmmap_write_unlock(mm);\n\n\treturn 0;\n}\n#endif\n\nlong do_arch_prctl_64(struct task_struct *task, int option, unsigned long arg2)\n{\n\tint ret = 0;\n\n\tswitch (option) {\n\tcase ARCH_SET_GS: {\n\t\tif (unlikely(arg2 >= TASK_SIZE_MAX))\n\t\t\treturn -EPERM;\n\n\t\tpreempt_disable();\n\t\t \n\t\tif (task == current) {\n\t\t\tloadseg(GS, 0);\n\t\t\tx86_gsbase_write_cpu_inactive(arg2);\n\n\t\t\t \n\t\t\ttask->thread.gsbase = arg2;\n\n\t\t} else {\n\t\t\ttask->thread.gsindex = 0;\n\t\t\tx86_gsbase_write_task(task, arg2);\n\t\t}\n\t\tpreempt_enable();\n\t\tbreak;\n\t}\n\tcase ARCH_SET_FS: {\n\t\t \n\t\tif (unlikely(arg2 >= TASK_SIZE_MAX))\n\t\t\treturn -EPERM;\n\n\t\tpreempt_disable();\n\t\t \n\t\tif (task == current) {\n\t\t\tloadseg(FS, 0);\n\t\t\tx86_fsbase_write_cpu(arg2);\n\n\t\t\t \n\t\t\ttask->thread.fsbase = arg2;\n\t\t} else {\n\t\t\ttask->thread.fsindex = 0;\n\t\t\tx86_fsbase_write_task(task, arg2);\n\t\t}\n\t\tpreempt_enable();\n\t\tbreak;\n\t}\n\tcase ARCH_GET_FS: {\n\t\tunsigned long base = x86_fsbase_read_task(task);\n\n\t\tret = put_user(base, (unsigned long __user *)arg2);\n\t\tbreak;\n\t}\n\tcase ARCH_GET_GS: {\n\t\tunsigned long base = x86_gsbase_read_task(task);\n\n\t\tret = put_user(base, (unsigned long __user *)arg2);\n\t\tbreak;\n\t}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n# ifdef CONFIG_X86_X32_ABI\n\tcase ARCH_MAP_VDSO_X32:\n\t\treturn prctl_map_vdso(&vdso_image_x32, arg2);\n# endif\n# if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\tcase ARCH_MAP_VDSO_32:\n\t\treturn prctl_map_vdso(&vdso_image_32, arg2);\n# endif\n\tcase ARCH_MAP_VDSO_64:\n\t\treturn prctl_map_vdso(&vdso_image_64, arg2);\n#endif\n#ifdef CONFIG_ADDRESS_MASKING\n\tcase ARCH_GET_UNTAG_MASK:\n\t\treturn put_user(task->mm->context.untag_mask,\n\t\t\t\t(unsigned long __user *)arg2);\n\tcase ARCH_ENABLE_TAGGED_ADDR:\n\t\treturn prctl_enable_tagged_addr(task->mm, arg2);\n\tcase ARCH_FORCE_TAGGED_SVA:\n\t\tif (current != task)\n\t\t\treturn -EINVAL;\n\t\tset_bit(MM_CONTEXT_FORCE_TAGGED_SVA, &task->mm->context.flags);\n\t\treturn 0;\n\tcase ARCH_GET_MAX_TAG_BITS:\n\t\tif (!cpu_feature_enabled(X86_FEATURE_LAM))\n\t\t\treturn put_user(0, (unsigned long __user *)arg2);\n\t\telse\n\t\t\treturn put_user(LAM_U57_BITS, (unsigned long __user *)arg2);\n#endif\n\tcase ARCH_SHSTK_ENABLE:\n\tcase ARCH_SHSTK_DISABLE:\n\tcase ARCH_SHSTK_LOCK:\n\tcase ARCH_SHSTK_UNLOCK:\n\tcase ARCH_SHSTK_STATUS:\n\t\treturn shstk_prctl(task, option, arg2);\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(arch_prctl, int, option, unsigned long, arg2)\n{\n\tlong ret;\n\n\tret = do_arch_prctl_64(current, option, arg2);\n\tif (ret == -EINVAL)\n\t\tret = do_arch_prctl_common(option, arg2);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_IA32_EMULATION\nCOMPAT_SYSCALL_DEFINE2(arch_prctl, int, option, unsigned long, arg2)\n{\n\treturn do_arch_prctl_common(option, arg2);\n}\n#endif\n\nunsigned long KSTK_ESP(struct task_struct *task)\n{\n\treturn task_pt_regs(task)->sp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}