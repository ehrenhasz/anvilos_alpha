{
  "module_name": "doublefault_32.c",
  "hash_id": "0c85f1e3f55262fd9c3041c42c5f47f65ab9c6c2d7910061dd9d1848df4d6d2f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/doublefault_32.c",
  "human_readable_source": "\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/init_task.h>\n#include <linux/fs.h>\n\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <asm/desc.h>\n#include <asm/traps.h>\n#include <asm/doublefault.h>\n\n#define ptr_ok(x) ((x) > PAGE_OFFSET && (x) < PAGE_OFFSET + MAXMEM)\n\n#define TSS(x) this_cpu_read(cpu_tss_rw.x86_tss.x)\n\nstatic void set_df_gdt_entry(unsigned int cpu);\n\n \nasmlinkage noinstr void __noreturn doublefault_shim(void)\n{\n\tunsigned long cr2;\n\tstruct pt_regs regs;\n\n\tBUILD_BUG_ON(sizeof(struct doublefault_stack) != PAGE_SIZE);\n\n\tcr2 = native_read_cr2();\n\n\t \n\tforce_reload_TR();\n\tset_df_gdt_entry(smp_processor_id());\n\n\ttrace_hardirqs_off();\n\n\t \n\tregs.ss\t\t= TSS(ss);\n\tregs.__ssh\t= 0;\n\tregs.sp\t\t= TSS(sp);\n\tregs.flags\t= TSS(flags);\n\tregs.cs\t\t= TSS(cs);\n\t \n\tregs.__csh\t= 0;\n\tregs.ip\t\t= TSS(ip);\n\tregs.orig_ax\t= 0;\n\tregs.gs\t\t= TSS(gs);\n\tregs.__gsh\t= 0;\n\tregs.fs\t\t= TSS(fs);\n\tregs.__fsh\t= 0;\n\tregs.es\t\t= TSS(es);\n\tregs.__esh\t= 0;\n\tregs.ds\t\t= TSS(ds);\n\tregs.__dsh\t= 0;\n\tregs.ax\t\t= TSS(ax);\n\tregs.bp\t\t= TSS(bp);\n\tregs.di\t\t= TSS(di);\n\tregs.si\t\t= TSS(si);\n\tregs.dx\t\t= TSS(dx);\n\tregs.cx\t\t= TSS(cx);\n\tregs.bx\t\t= TSS(bx);\n\n\texc_double_fault(&regs, 0, cr2);\n\n\t \n\tpanic(\"cannot return from double fault\\n\");\n}\n\nDEFINE_PER_CPU_PAGE_ALIGNED(struct doublefault_stack, doublefault_stack) = {\n\t.tss = {\n                 \n\t\t.ldt\t\t= 0,\n\t.io_bitmap_base\t= IO_BITMAP_OFFSET_INVALID,\n\n\t\t.ip\t\t= (unsigned long) asm_exc_double_fault,\n\t\t.flags\t\t= X86_EFLAGS_FIXED,\n\t\t.es\t\t= __USER_DS,\n\t\t.cs\t\t= __KERNEL_CS,\n\t\t.ss\t\t= __KERNEL_DS,\n\t\t.ds\t\t= __USER_DS,\n\t\t.fs\t\t= __KERNEL_PERCPU,\n\t\t.gs\t\t= 0,\n\n\t\t.__cr3\t\t= __pa_nodebug(swapper_pg_dir),\n\t},\n};\n\nstatic void set_df_gdt_entry(unsigned int cpu)\n{\n\t \n\t__set_tss_desc(cpu, GDT_ENTRY_DOUBLEFAULT_TSS,\n\t\t       &get_cpu_entry_area(cpu)->doublefault_stack.tss);\n\n}\n\nvoid doublefault_init_cpu_tss(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct cpu_entry_area *cea = get_cpu_entry_area(cpu);\n\n\t \n        this_cpu_write(doublefault_stack.tss.sp,\n                       (unsigned long)&cea->doublefault_stack.stack +\n                       sizeof(doublefault_stack.stack));\n\n\tset_df_gdt_entry(cpu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}