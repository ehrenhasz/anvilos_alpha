{
  "module_name": "early-quirks.c",
  "hash_id": "5368f323315c3392d79eb320032d9809d4100585701df6ac18258df03dba55ce",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/early-quirks.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/pci_ids.h>\n#include <linux/bcma/bcma.h>\n#include <linux/bcma/bcma_regs.h>\n#include <linux/platform_data/x86/apple.h>\n#include <drm/i915_drm.h>\n#include <drm/i915_pciids.h>\n#include <asm/pci-direct.h>\n#include <asm/dma.h>\n#include <asm/io_apic.h>\n#include <asm/apic.h>\n#include <asm/hpet.h>\n#include <asm/iommu.h>\n#include <asm/gart.h>\n#include <asm/irq_remapping.h>\n#include <asm/early_ioremap.h>\n\nstatic void __init fix_hypertransport_config(int num, int slot, int func)\n{\n\tu32 htcfg;\n\t \n\thtcfg = read_pci_config(num, slot, func, 0x68);\n\tif (htcfg & (1 << 18)) {\n\t\tprintk(KERN_INFO \"Detected use of extended apic ids \"\n\t\t\t\t \"on hypertransport bus\\n\");\n\t\tif ((htcfg & (1 << 17)) == 0) {\n\t\t\tprintk(KERN_INFO \"Enabling hypertransport extended \"\n\t\t\t\t\t \"apic interrupt broadcast\\n\");\n\t\t\tprintk(KERN_INFO \"Note this is a bios bug, \"\n\t\t\t\t\t \"please contact your hw vendor\\n\");\n\t\t\thtcfg |= (1 << 17);\n\t\t\twrite_pci_config(num, slot, func, 0x68, htcfg);\n\t\t}\n\t}\n\n\n}\n\nstatic void __init via_bugs(int  num, int slot, int func)\n{\n#ifdef CONFIG_GART_IOMMU\n\tif ((max_pfn > MAX_DMA32_PFN ||  force_iommu) &&\n\t    !gart_iommu_aperture_allowed) {\n\t\tprintk(KERN_INFO\n\t\t       \"Looks like a VIA chipset. Disabling IOMMU.\"\n\t\t       \" Override with iommu=allowed\\n\");\n\t\tgart_iommu_aperture_disabled = 1;\n\t}\n#endif\n}\n\n#ifdef CONFIG_ACPI\n#ifdef CONFIG_X86_IO_APIC\n\nstatic int __init nvidia_hpet_check(struct acpi_table_header *header)\n{\n\treturn 0;\n}\n#endif  \n#endif  \n\nstatic void __init nvidia_bugs(int num, int slot, int func)\n{\n#ifdef CONFIG_ACPI\n#ifdef CONFIG_X86_IO_APIC\n\t \n\tif (num)\n\t\treturn;\n\n\t \n\tif (acpi_use_timer_override)\n\t\treturn;\n\n\tif (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {\n\t\tacpi_skip_timer_override = 1;\n\t\tprintk(KERN_INFO \"Nvidia board \"\n\t\t       \"detected. Ignoring ACPI \"\n\t\t       \"timer override.\\n\");\n\t\tprintk(KERN_INFO \"If you got timer trouble \"\n\t\t\t\"try acpi_use_timer_override\\n\");\n\t}\n#endif\n#endif\n\t \n\n}\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)\nstatic u32 __init ati_ixp4x0_rev(int num, int slot, int func)\n{\n\tu32 d;\n\tu8  b;\n\n\tb = read_pci_config_byte(num, slot, func, 0xac);\n\tb &= ~(1<<5);\n\twrite_pci_config_byte(num, slot, func, 0xac, b);\n\n\td = read_pci_config(num, slot, func, 0x70);\n\td |= 1<<8;\n\twrite_pci_config(num, slot, func, 0x70, d);\n\n\td = read_pci_config(num, slot, func, 0x8);\n\td &= 0xff;\n\treturn d;\n}\n\nstatic void __init ati_bugs(int num, int slot, int func)\n{\n\tu32 d;\n\tu8  b;\n\n\tif (acpi_use_timer_override)\n\t\treturn;\n\n\td = ati_ixp4x0_rev(num, slot, func);\n\tif (d  < 0x82)\n\t\tacpi_skip_timer_override = 1;\n\telse {\n\t\t \n\t\toutb(0x72, 0xcd6); b = inb(0xcd7);\n\t\tif (!(b & 0x2))\n\t\t\tacpi_skip_timer_override = 1;\n\t}\n\n\tif (acpi_skip_timer_override) {\n\t\tprintk(KERN_INFO \"SB4X0 revision 0x%x\\n\", d);\n\t\tprintk(KERN_INFO \"Ignoring ACPI timer override.\\n\");\n\t\tprintk(KERN_INFO \"If you got timer trouble \"\n\t\t       \"try acpi_use_timer_override\\n\");\n\t}\n}\n\nstatic u32 __init ati_sbx00_rev(int num, int slot, int func)\n{\n\tu32 d;\n\n\td = read_pci_config(num, slot, func, 0x8);\n\td &= 0xff;\n\n\treturn d;\n}\n\nstatic void __init ati_bugs_contd(int num, int slot, int func)\n{\n\tu32 d, rev;\n\n\trev = ati_sbx00_rev(num, slot, func);\n\tif (rev >= 0x40)\n\t\tacpi_fix_pin2_polarity = 1;\n\n\t \n\tif (rev >= 0x39)\n\t\treturn;\n\n\tif (acpi_use_timer_override)\n\t\treturn;\n\n\t \n\td = read_pci_config(num, slot, func, 0x64);\n\tif (!(d & (1<<14)))\n\t\tacpi_skip_timer_override = 1;\n\n\tif (acpi_skip_timer_override) {\n\t\tprintk(KERN_INFO \"SB600 revision 0x%x\\n\", rev);\n\t\tprintk(KERN_INFO \"Ignoring ACPI timer override.\\n\");\n\t\tprintk(KERN_INFO \"If you got timer trouble \"\n\t\t       \"try acpi_use_timer_override\\n\");\n\t}\n}\n#else\nstatic void __init ati_bugs(int num, int slot, int func)\n{\n}\n\nstatic void __init ati_bugs_contd(int num, int slot, int func)\n{\n}\n#endif\n\nstatic void __init intel_remapping_check(int num, int slot, int func)\n{\n\tu8 revision;\n\tu16 device;\n\n\tdevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\n\trevision = read_pci_config_byte(num, slot, func, PCI_REVISION_ID);\n\n\t \n\tif (revision <= 0x13)\n\t\tset_irq_remapping_broken();\n\telse if (device == 0x3405 && revision == 0x22)\n\t\tset_irq_remapping_broken();\n}\n\n \n\n#define KB(x)\t((x) * 1024UL)\n#define MB(x)\t(KB (KB (x)))\n\nstatic resource_size_t __init i830_tseg_size(void)\n{\n\tu8 esmramc = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);\n\n\tif (!(esmramc & TSEG_ENABLE))\n\t\treturn 0;\n\n\tif (esmramc & I830_TSEG_SIZE_1M)\n\t\treturn MB(1);\n\telse\n\t\treturn KB(512);\n}\n\nstatic resource_size_t __init i845_tseg_size(void)\n{\n\tu8 esmramc = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);\n\tu8 tseg_size = esmramc & I845_TSEG_SIZE_MASK;\n\n\tif (!(esmramc & TSEG_ENABLE))\n\t\treturn 0;\n\n\tswitch (tseg_size) {\n\tcase I845_TSEG_SIZE_512K:\treturn KB(512);\n\tcase I845_TSEG_SIZE_1M:\t\treturn MB(1);\n\tdefault:\n\t\tWARN(1, \"Unknown ESMRAMC value: %x!\\n\", esmramc);\n\t}\n\treturn 0;\n}\n\nstatic resource_size_t __init i85x_tseg_size(void)\n{\n\tu8 esmramc = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);\n\n\tif (!(esmramc & TSEG_ENABLE))\n\t\treturn 0;\n\n\treturn MB(1);\n}\n\nstatic resource_size_t __init i830_mem_size(void)\n{\n\treturn read_pci_config_byte(0, 0, 0, I830_DRB3) * MB(32);\n}\n\nstatic resource_size_t __init i85x_mem_size(void)\n{\n\treturn read_pci_config_byte(0, 0, 1, I85X_DRB3) * MB(32);\n}\n\n \nstatic resource_size_t __init i830_stolen_base(int num, int slot, int func,\n\t\t\t\t\t       resource_size_t stolen_size)\n{\n\treturn i830_mem_size() - i830_tseg_size() - stolen_size;\n}\n\nstatic resource_size_t __init i845_stolen_base(int num, int slot, int func,\n\t\t\t\t\t       resource_size_t stolen_size)\n{\n\treturn i830_mem_size() - i845_tseg_size() - stolen_size;\n}\n\nstatic resource_size_t __init i85x_stolen_base(int num, int slot, int func,\n\t\t\t\t\t       resource_size_t stolen_size)\n{\n\treturn i85x_mem_size() - i85x_tseg_size() - stolen_size;\n}\n\nstatic resource_size_t __init i865_stolen_base(int num, int slot, int func,\n\t\t\t\t\t       resource_size_t stolen_size)\n{\n\tu16 toud = 0;\n\n\ttoud = read_pci_config_16(0, 0, 0, I865_TOUD);\n\n\treturn toud * KB(64) + i845_tseg_size();\n}\n\nstatic resource_size_t __init gen3_stolen_base(int num, int slot, int func,\n\t\t\t\t\t       resource_size_t stolen_size)\n{\n\tu32 bsm;\n\n\t \n\tbsm = read_pci_config(num, slot, func, INTEL_BSM);\n\n\treturn bsm & INTEL_BSM_MASK;\n}\n\nstatic resource_size_t __init gen11_stolen_base(int num, int slot, int func,\n\t\t\t\t\t\tresource_size_t stolen_size)\n{\n\tu64 bsm;\n\n\tbsm = read_pci_config(num, slot, func, INTEL_GEN11_BSM_DW0);\n\tbsm &= INTEL_BSM_MASK;\n\tbsm |= (u64)read_pci_config(num, slot, func, INTEL_GEN11_BSM_DW1) << 32;\n\n\treturn bsm;\n}\n\nstatic resource_size_t __init i830_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);\n\tgms = gmch_ctrl & I830_GMCH_GMS_MASK;\n\n\tswitch (gms) {\n\tcase I830_GMCH_GMS_STOLEN_512:\treturn KB(512);\n\tcase I830_GMCH_GMS_STOLEN_1024:\treturn MB(1);\n\tcase I830_GMCH_GMS_STOLEN_8192:\treturn MB(8);\n\t \n\tcase I830_GMCH_GMS_LOCAL:\treturn 0;\n\tdefault:\n\t\tWARN(1, \"Unknown GMCH_CTRL value: %x!\\n\", gmch_ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic resource_size_t __init gen3_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);\n\tgms = gmch_ctrl & I855_GMCH_GMS_MASK;\n\n\tswitch (gms) {\n\tcase I855_GMCH_GMS_STOLEN_1M:\treturn MB(1);\n\tcase I855_GMCH_GMS_STOLEN_4M:\treturn MB(4);\n\tcase I855_GMCH_GMS_STOLEN_8M:\treturn MB(8);\n\tcase I855_GMCH_GMS_STOLEN_16M:\treturn MB(16);\n\tcase I855_GMCH_GMS_STOLEN_32M:\treturn MB(32);\n\tcase I915_GMCH_GMS_STOLEN_48M:\treturn MB(48);\n\tcase I915_GMCH_GMS_STOLEN_64M:\treturn MB(64);\n\tcase G33_GMCH_GMS_STOLEN_128M:\treturn MB(128);\n\tcase G33_GMCH_GMS_STOLEN_256M:\treturn MB(256);\n\tcase INTEL_GMCH_GMS_STOLEN_96M:\treturn MB(96);\n\tcase INTEL_GMCH_GMS_STOLEN_160M:return MB(160);\n\tcase INTEL_GMCH_GMS_STOLEN_224M:return MB(224);\n\tcase INTEL_GMCH_GMS_STOLEN_352M:return MB(352);\n\tdefault:\n\t\tWARN(1, \"Unknown GMCH_CTRL value: %x!\\n\", gmch_ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic resource_size_t __init gen6_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\n\tgms = (gmch_ctrl >> SNB_GMCH_GMS_SHIFT) & SNB_GMCH_GMS_MASK;\n\n\treturn gms * MB(32);\n}\n\nstatic resource_size_t __init gen8_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\n\tgms = (gmch_ctrl >> BDW_GMCH_GMS_SHIFT) & BDW_GMCH_GMS_MASK;\n\n\treturn gms * MB(32);\n}\n\nstatic resource_size_t __init chv_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\n\tgms = (gmch_ctrl >> SNB_GMCH_GMS_SHIFT) & SNB_GMCH_GMS_MASK;\n\n\t \n\tif (gms < 0x11)\n\t\treturn gms * MB(32);\n\telse if (gms < 0x17)\n\t\treturn (gms - 0x11) * MB(4) + MB(8);\n\telse\n\t\treturn (gms - 0x17) * MB(4) + MB(36);\n}\n\nstatic resource_size_t __init gen9_stolen_size(int num, int slot, int func)\n{\n\tu16 gmch_ctrl;\n\tu16 gms;\n\n\tgmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\n\tgms = (gmch_ctrl >> BDW_GMCH_GMS_SHIFT) & BDW_GMCH_GMS_MASK;\n\n\t \n\t \n\tif (gms < 0xf0)\n\t\treturn gms * MB(32);\n\telse\n\t\treturn (gms - 0xf0) * MB(4) + MB(4);\n}\n\nstruct intel_early_ops {\n\tresource_size_t (*stolen_size)(int num, int slot, int func);\n\tresource_size_t (*stolen_base)(int num, int slot, int func,\n\t\t\t\t       resource_size_t size);\n};\n\nstatic const struct intel_early_ops i830_early_ops __initconst = {\n\t.stolen_base = i830_stolen_base,\n\t.stolen_size = i830_stolen_size,\n};\n\nstatic const struct intel_early_ops i845_early_ops __initconst = {\n\t.stolen_base = i845_stolen_base,\n\t.stolen_size = i830_stolen_size,\n};\n\nstatic const struct intel_early_ops i85x_early_ops __initconst = {\n\t.stolen_base = i85x_stolen_base,\n\t.stolen_size = gen3_stolen_size,\n};\n\nstatic const struct intel_early_ops i865_early_ops __initconst = {\n\t.stolen_base = i865_stolen_base,\n\t.stolen_size = gen3_stolen_size,\n};\n\nstatic const struct intel_early_ops gen3_early_ops __initconst = {\n\t.stolen_base = gen3_stolen_base,\n\t.stolen_size = gen3_stolen_size,\n};\n\nstatic const struct intel_early_ops gen6_early_ops __initconst = {\n\t.stolen_base = gen3_stolen_base,\n\t.stolen_size = gen6_stolen_size,\n};\n\nstatic const struct intel_early_ops gen8_early_ops __initconst = {\n\t.stolen_base = gen3_stolen_base,\n\t.stolen_size = gen8_stolen_size,\n};\n\nstatic const struct intel_early_ops gen9_early_ops __initconst = {\n\t.stolen_base = gen3_stolen_base,\n\t.stolen_size = gen9_stolen_size,\n};\n\nstatic const struct intel_early_ops chv_early_ops __initconst = {\n\t.stolen_base = gen3_stolen_base,\n\t.stolen_size = chv_stolen_size,\n};\n\nstatic const struct intel_early_ops gen11_early_ops __initconst = {\n\t.stolen_base = gen11_stolen_base,\n\t.stolen_size = gen9_stolen_size,\n};\n\n \nstatic const struct pci_device_id intel_early_ids[] __initconst = {\n\tINTEL_I830_IDS(&i830_early_ops),\n\tINTEL_I845G_IDS(&i845_early_ops),\n\tINTEL_I85X_IDS(&i85x_early_ops),\n\tINTEL_I865G_IDS(&i865_early_ops),\n\tINTEL_I915G_IDS(&gen3_early_ops),\n\tINTEL_I915GM_IDS(&gen3_early_ops),\n\tINTEL_I945G_IDS(&gen3_early_ops),\n\tINTEL_I945GM_IDS(&gen3_early_ops),\n\tINTEL_VLV_IDS(&gen6_early_ops),\n\tINTEL_PINEVIEW_G_IDS(&gen3_early_ops),\n\tINTEL_PINEVIEW_M_IDS(&gen3_early_ops),\n\tINTEL_I965G_IDS(&gen3_early_ops),\n\tINTEL_G33_IDS(&gen3_early_ops),\n\tINTEL_I965GM_IDS(&gen3_early_ops),\n\tINTEL_GM45_IDS(&gen3_early_ops),\n\tINTEL_G45_IDS(&gen3_early_ops),\n\tINTEL_IRONLAKE_D_IDS(&gen3_early_ops),\n\tINTEL_IRONLAKE_M_IDS(&gen3_early_ops),\n\tINTEL_SNB_D_IDS(&gen6_early_ops),\n\tINTEL_SNB_M_IDS(&gen6_early_ops),\n\tINTEL_IVB_M_IDS(&gen6_early_ops),\n\tINTEL_IVB_D_IDS(&gen6_early_ops),\n\tINTEL_HSW_IDS(&gen6_early_ops),\n\tINTEL_BDW_IDS(&gen8_early_ops),\n\tINTEL_CHV_IDS(&chv_early_ops),\n\tINTEL_SKL_IDS(&gen9_early_ops),\n\tINTEL_BXT_IDS(&gen9_early_ops),\n\tINTEL_KBL_IDS(&gen9_early_ops),\n\tINTEL_CFL_IDS(&gen9_early_ops),\n\tINTEL_GLK_IDS(&gen9_early_ops),\n\tINTEL_CNL_IDS(&gen9_early_ops),\n\tINTEL_ICL_11_IDS(&gen11_early_ops),\n\tINTEL_EHL_IDS(&gen11_early_ops),\n\tINTEL_JSL_IDS(&gen11_early_ops),\n\tINTEL_TGL_12_IDS(&gen11_early_ops),\n\tINTEL_RKL_IDS(&gen11_early_ops),\n\tINTEL_ADLS_IDS(&gen11_early_ops),\n\tINTEL_ADLP_IDS(&gen11_early_ops),\n\tINTEL_ADLN_IDS(&gen11_early_ops),\n\tINTEL_RPLS_IDS(&gen11_early_ops),\n\tINTEL_RPLP_IDS(&gen11_early_ops),\n};\n\nstruct resource intel_graphics_stolen_res __ro_after_init = DEFINE_RES_MEM(0, 0);\nEXPORT_SYMBOL(intel_graphics_stolen_res);\n\nstatic void __init\nintel_graphics_stolen(int num, int slot, int func,\n\t\t      const struct intel_early_ops *early_ops)\n{\n\tresource_size_t base, size;\n\tresource_size_t end;\n\n\tsize = early_ops->stolen_size(num, slot, func);\n\tbase = early_ops->stolen_base(num, slot, func, size);\n\n\tif (!size || !base)\n\t\treturn;\n\n\tend = base + size - 1;\n\n\tintel_graphics_stolen_res.start = base;\n\tintel_graphics_stolen_res.end = end;\n\n\tprintk(KERN_INFO \"Reserving Intel graphics memory at %pR\\n\",\n\t       &intel_graphics_stolen_res);\n\n\t \n\te820__range_add(base, size, E820_TYPE_RESERVED);\n\te820__update_table(e820_table);\n}\n\nstatic void __init intel_graphics_quirks(int num, int slot, int func)\n{\n\tconst struct intel_early_ops *early_ops;\n\tu16 device;\n\tint i;\n\n\t \n\tif (resource_size(&intel_graphics_stolen_res))\n\t\treturn;\n\n\tdevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_early_ids); i++) {\n\t\tkernel_ulong_t driver_data = intel_early_ids[i].driver_data;\n\n\t\tif (intel_early_ids[i].device != device)\n\t\t\tcontinue;\n\n\t\tearly_ops = (typeof(early_ops))driver_data;\n\n\t\tintel_graphics_stolen(num, slot, func, early_ops);\n\n\t\treturn;\n\t}\n}\n\nstatic void __init force_disable_hpet(int num, int slot, int func)\n{\n#ifdef CONFIG_HPET_TIMER\n\tboot_hpet_disable = true;\n\tpr_info(\"x86/hpet: Will disable the HPET for this platform because it's not reliable\\n\");\n#endif\n}\n\n#define BCM4331_MMIO_SIZE\t16384\n#define BCM4331_PM_CAP\t\t0x40\n#define bcma_aread32(reg)\tioread32(mmio + 1 * BCMA_CORE_SIZE + reg)\n#define bcma_awrite32(reg, val)\tiowrite32(val, mmio + 1 * BCMA_CORE_SIZE + reg)\n\nstatic void __init apple_airport_reset(int bus, int slot, int func)\n{\n\tvoid __iomem *mmio;\n\tu16 pmcsr;\n\tu64 addr;\n\tint i;\n\n\tif (!x86_apple_machine)\n\t\treturn;\n\n\t \n\tpmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);\n\n\tif ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0) {\n\t\tpmcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\t\twrite_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL, pmcsr);\n\t\tmdelay(10);\n\n\t\tpmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);\n\t\tif ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0) {\n\t\t\tpr_err(\"pci 0000:%02x:%02x.%d: Cannot power up Apple AirPort card\\n\",\n\t\t\t       bus, slot, func);\n\t\t\treturn;\n\t\t}\n\t}\n\n\taddr  =      read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);\n\taddr |= (u64)read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_1) << 32;\n\taddr &= PCI_BASE_ADDRESS_MEM_MASK;\n\n\tmmio = early_ioremap(addr, BCM4331_MMIO_SIZE);\n\tif (!mmio) {\n\t\tpr_err(\"pci 0000:%02x:%02x.%d: Cannot iomap Apple AirPort card\\n\",\n\t\t       bus, slot, func);\n\t\treturn;\n\t}\n\n\tpr_info(\"Resetting Apple AirPort card (left enabled by EFI)\\n\");\n\n\tfor (i = 0; bcma_aread32(BCMA_RESET_ST) && i < 30; i++)\n\t\tudelay(10);\n\n\tbcma_awrite32(BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);\n\tbcma_aread32(BCMA_RESET_CTL);\n\tudelay(1);\n\n\tbcma_awrite32(BCMA_RESET_CTL, 0);\n\tbcma_aread32(BCMA_RESET_CTL);\n\tudelay(10);\n\n\tearly_iounmap(mmio, BCM4331_MMIO_SIZE);\n}\n\n#define QFLAG_APPLY_ONCE \t0x1\n#define QFLAG_APPLIED\t\t0x2\n#define QFLAG_DONE\t\t(QFLAG_APPLY_ONCE|QFLAG_APPLIED)\nstruct chipset {\n\tu32 vendor;\n\tu32 device;\n\tu32 class;\n\tu32 class_mask;\n\tu32 flags;\n\tvoid (*f)(int num, int slot, int func);\n};\n\nstatic struct chipset early_qrk[] __initdata = {\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },\n\t{ PCI_VENDOR_ID_VIA, PCI_ANY_ID,\n\t  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, via_bugs },\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,\n\t  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_SMBUS,\n\t  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,\n\t  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },\n\t{ PCI_VENDOR_ID_INTEL, 0x3403, PCI_CLASS_BRIDGE_HOST,\n\t  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },\n\t{ PCI_VENDOR_ID_INTEL, 0x3405, PCI_CLASS_BRIDGE_HOST,\n\t  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },\n\t{ PCI_VENDOR_ID_INTEL, 0x3406, PCI_CLASS_BRIDGE_HOST,\n\t  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },\n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA, PCI_ANY_ID,\n\t  0, intel_graphics_quirks },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x0f00,\n\t\tPCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},\n\t{ PCI_VENDOR_ID_BROADCOM, 0x4331,\n\t  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},\n\t{}\n};\n\nstatic void __init early_pci_scan_bus(int bus);\n\n \nstatic int __init check_dev_quirk(int num, int slot, int func)\n{\n\tu16 class;\n\tu16 vendor;\n\tu16 device;\n\tu8 type;\n\tu8 sec;\n\tint i;\n\n\tclass = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);\n\n\tif (class == 0xffff)\n\t\treturn -1;  \n\n\tvendor = read_pci_config_16(num, slot, func, PCI_VENDOR_ID);\n\n\tdevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\n\n\tfor (i = 0; early_qrk[i].f != NULL; i++) {\n\t\tif (((early_qrk[i].vendor == PCI_ANY_ID) ||\n\t\t\t(early_qrk[i].vendor == vendor)) &&\n\t\t\t((early_qrk[i].device == PCI_ANY_ID) ||\n\t\t\t(early_qrk[i].device == device)) &&\n\t\t\t(!((early_qrk[i].class ^ class) &\n\t\t\t    early_qrk[i].class_mask))) {\n\t\t\t\tif ((early_qrk[i].flags &\n\t\t\t\t     QFLAG_DONE) != QFLAG_DONE)\n\t\t\t\t\tearly_qrk[i].f(num, slot, func);\n\t\t\t\tearly_qrk[i].flags |= QFLAG_APPLIED;\n\t\t\t}\n\t}\n\n\ttype = read_pci_config_byte(num, slot, func,\n\t\t\t\t    PCI_HEADER_TYPE);\n\n\tif ((type & 0x7f) == PCI_HEADER_TYPE_BRIDGE) {\n\t\tsec = read_pci_config_byte(num, slot, func, PCI_SECONDARY_BUS);\n\t\tif (sec > num)\n\t\t\tearly_pci_scan_bus(sec);\n\t}\n\n\tif (!(type & 0x80))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void __init early_pci_scan_bus(int bus)\n{\n\tint slot, func;\n\n\t \n\tfor (slot = 0; slot < 32; slot++)\n\t\tfor (func = 0; func < 8; func++) {\n\t\t\t \n\t\t\tif (check_dev_quirk(bus, slot, func))\n\t\t\t\tbreak;\n\t\t}\n}\n\nvoid __init early_quirks(void)\n{\n\tif (!early_pci_allowed())\n\t\treturn;\n\n\tearly_pci_scan_bus(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}