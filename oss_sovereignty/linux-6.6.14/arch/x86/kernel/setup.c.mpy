{
  "module_name": "setup.c",
  "hash_id": "76b48b3484ec6142f164bacd2122c90502653f7065e794035973d090b03e599c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/setup.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/console.h>\n#include <linux/crash_dump.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/ima.h>\n#include <linux/init_ohci1394_dma.h>\n#include <linux/initrd.h>\n#include <linux/iscsi_ibft.h>\n#include <linux/memblock.h>\n#include <linux/panic_notifier.h>\n#include <linux/pci.h>\n#include <linux/root_dev.h>\n#include <linux/hugetlb.h>\n#include <linux/tboot.h>\n#include <linux/usb/xhci-dbgp.h>\n#include <linux/static_call.h>\n#include <linux/swiotlb.h>\n#include <linux/random.h>\n\n#include <uapi/linux/mount.h>\n\n#include <xen/xen.h>\n\n#include <asm/apic.h>\n#include <asm/efi.h>\n#include <asm/numa.h>\n#include <asm/bios_ebda.h>\n#include <asm/bugs.h>\n#include <asm/cacheinfo.h>\n#include <asm/cpu.h>\n#include <asm/efi.h>\n#include <asm/gart.h>\n#include <asm/hypervisor.h>\n#include <asm/io_apic.h>\n#include <asm/kasan.h>\n#include <asm/kaslr.h>\n#include <asm/mce.h>\n#include <asm/memtype.h>\n#include <asm/mtrr.h>\n#include <asm/realmode.h>\n#include <asm/olpc_ofw.h>\n#include <asm/pci-direct.h>\n#include <asm/prom.h>\n#include <asm/proto.h>\n#include <asm/thermal.h>\n#include <asm/unwind.h>\n#include <asm/vsyscall.h>\n#include <linux/vmalloc.h>\n\n \nunsigned long max_low_pfn_mapped;\nunsigned long max_pfn_mapped;\n\n#ifdef CONFIG_DMI\nRESERVE_BRK(dmi_alloc, 65536);\n#endif\n\n\nunsigned long _brk_start = (unsigned long)__brk_base;\nunsigned long _brk_end   = (unsigned long)__brk_base;\n\nstruct boot_params boot_params;\n\n \n\nstatic struct resource rodata_resource = {\n\t.name\t= \"Kernel rodata\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM\n};\n\nstatic struct resource data_resource = {\n\t.name\t= \"Kernel data\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM\n};\n\nstatic struct resource code_resource = {\n\t.name\t= \"Kernel code\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM\n};\n\nstatic struct resource bss_resource = {\n\t.name\t= \"Kernel bss\",\n\t.start\t= 0,\n\t.end\t= 0,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM\n};\n\n\n#ifdef CONFIG_X86_32\n \nstruct cpuinfo_x86 new_cpu_data;\n\nstruct apm_info apm_info;\nEXPORT_SYMBOL(apm_info);\n\n#if defined(CONFIG_X86_SPEEDSTEP_SMI) || \\\n\tdefined(CONFIG_X86_SPEEDSTEP_SMI_MODULE)\nstruct ist_info ist_info;\nEXPORT_SYMBOL(ist_info);\n#else\nstruct ist_info ist_info;\n#endif\n\n#endif\n\nstruct cpuinfo_x86 boot_cpu_data __read_mostly;\nEXPORT_SYMBOL(boot_cpu_data);\n\n#if !defined(CONFIG_X86_PAE) || defined(CONFIG_X86_64)\n__visible unsigned long mmu_cr4_features __ro_after_init;\n#else\n__visible unsigned long mmu_cr4_features __ro_after_init = X86_CR4_PAE;\n#endif\n\n#ifdef CONFIG_IMA\nstatic phys_addr_t ima_kexec_buffer_phys;\nstatic size_t ima_kexec_buffer_size;\n#endif\n\n \nint bootloader_type, bootloader_version;\n\n \nstruct screen_info screen_info;\nEXPORT_SYMBOL(screen_info);\nstruct edid_info edid_info;\nEXPORT_SYMBOL_GPL(edid_info);\n\nextern int root_mountflags;\n\nunsigned long saved_video_mode;\n\n#define RAMDISK_IMAGE_START_MASK\t0x07FF\n#define RAMDISK_PROMPT_FLAG\t\t0x8000\n#define RAMDISK_LOAD_FLAG\t\t0x4000\n\nstatic char __initdata command_line[COMMAND_LINE_SIZE];\n#ifdef CONFIG_CMDLINE_BOOL\nstatic char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;\n#endif\n\n#if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)\nstruct edd edd;\n#ifdef CONFIG_EDD_MODULE\nEXPORT_SYMBOL(edd);\n#endif\n \nstatic inline void __init copy_edd(void)\n{\n     memcpy(edd.mbr_signature, boot_params.edd_mbr_sig_buffer,\n\t    sizeof(edd.mbr_signature));\n     memcpy(edd.edd_info, boot_params.eddbuf, sizeof(edd.edd_info));\n     edd.mbr_signature_nr = boot_params.edd_mbr_sig_buf_entries;\n     edd.edd_info_nr = boot_params.eddbuf_entries;\n}\n#else\nstatic inline void __init copy_edd(void)\n{\n}\n#endif\n\nvoid * __init extend_brk(size_t size, size_t align)\n{\n\tsize_t mask = align - 1;\n\tvoid *ret;\n\n\tBUG_ON(_brk_start == 0);\n\tBUG_ON(align & mask);\n\n\t_brk_end = (_brk_end + mask) & ~mask;\n\tBUG_ON((char *)(_brk_end + size) > __brk_limit);\n\n\tret = (void *)_brk_end;\n\t_brk_end += size;\n\n\tmemset(ret, 0, size);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_X86_32\nstatic void __init cleanup_highmap(void)\n{\n}\n#endif\n\nstatic void __init reserve_brk(void)\n{\n\tif (_brk_end > _brk_start)\n\t\tmemblock_reserve(__pa_symbol(_brk_start),\n\t\t\t\t _brk_end - _brk_start);\n\n\t \n\t_brk_start = 0;\n}\n\nu64 relocated_ramdisk;\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\nstatic u64 __init get_ramdisk_image(void)\n{\n\tu64 ramdisk_image = boot_params.hdr.ramdisk_image;\n\n\tramdisk_image |= (u64)boot_params.ext_ramdisk_image << 32;\n\n\tif (ramdisk_image == 0)\n\t\tramdisk_image = phys_initrd_start;\n\n\treturn ramdisk_image;\n}\nstatic u64 __init get_ramdisk_size(void)\n{\n\tu64 ramdisk_size = boot_params.hdr.ramdisk_size;\n\n\tramdisk_size |= (u64)boot_params.ext_ramdisk_size << 32;\n\n\tif (ramdisk_size == 0)\n\t\tramdisk_size = phys_initrd_size;\n\n\treturn ramdisk_size;\n}\n\nstatic void __init relocate_initrd(void)\n{\n\t \n\tu64 ramdisk_image = get_ramdisk_image();\n\tu64 ramdisk_size  = get_ramdisk_size();\n\tu64 area_size     = PAGE_ALIGN(ramdisk_size);\n\n\t \n\trelocated_ramdisk = memblock_phys_alloc_range(area_size, PAGE_SIZE, 0,\n\t\t\t\t\t\t      PFN_PHYS(max_pfn_mapped));\n\tif (!relocated_ramdisk)\n\t\tpanic(\"Cannot find place for new RAMDISK of size %lld\\n\",\n\t\t      ramdisk_size);\n\n\tinitrd_start = relocated_ramdisk + PAGE_OFFSET;\n\tinitrd_end   = initrd_start + ramdisk_size;\n\tprintk(KERN_INFO \"Allocated new RAMDISK: [mem %#010llx-%#010llx]\\n\",\n\t       relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);\n\n\tcopy_from_early_mem((void *)initrd_start, ramdisk_image, ramdisk_size);\n\n\tprintk(KERN_INFO \"Move RAMDISK from [mem %#010llx-%#010llx] to\"\n\t\t\" [mem %#010llx-%#010llx]\\n\",\n\t\tramdisk_image, ramdisk_image + ramdisk_size - 1,\n\t\trelocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);\n}\n\nstatic void __init early_reserve_initrd(void)\n{\n\t \n\tu64 ramdisk_image = get_ramdisk_image();\n\tu64 ramdisk_size  = get_ramdisk_size();\n\tu64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);\n\n\tif (!boot_params.hdr.type_of_loader ||\n\t    !ramdisk_image || !ramdisk_size)\n\t\treturn;\t\t \n\n\tmemblock_reserve(ramdisk_image, ramdisk_end - ramdisk_image);\n}\n\nstatic void __init reserve_initrd(void)\n{\n\t \n\tu64 ramdisk_image = get_ramdisk_image();\n\tu64 ramdisk_size  = get_ramdisk_size();\n\tu64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);\n\n\tif (!boot_params.hdr.type_of_loader ||\n\t    !ramdisk_image || !ramdisk_size)\n\t\treturn;\t\t \n\n\tinitrd_start = 0;\n\n\tprintk(KERN_INFO \"RAMDISK: [mem %#010llx-%#010llx]\\n\", ramdisk_image,\n\t\t\tramdisk_end - 1);\n\n\tif (pfn_range_is_mapped(PFN_DOWN(ramdisk_image),\n\t\t\t\tPFN_DOWN(ramdisk_end))) {\n\t\t \n\t\tinitrd_start = ramdisk_image + PAGE_OFFSET;\n\t\tinitrd_end = initrd_start + ramdisk_size;\n\t\treturn;\n\t}\n\n\trelocate_initrd();\n\n\tmemblock_phys_free(ramdisk_image, ramdisk_end - ramdisk_image);\n}\n\n#else\nstatic void __init early_reserve_initrd(void)\n{\n}\nstatic void __init reserve_initrd(void)\n{\n}\n#endif  \n\nstatic void __init add_early_ima_buffer(u64 phys_addr)\n{\n#ifdef CONFIG_IMA\n\tstruct ima_setup_data *data;\n\n\tdata = early_memremap(phys_addr + sizeof(struct setup_data), sizeof(*data));\n\tif (!data) {\n\t\tpr_warn(\"setup: failed to memremap ima_setup_data entry\\n\");\n\t\treturn;\n\t}\n\n\tif (data->size) {\n\t\tmemblock_reserve(data->addr, data->size);\n\t\tima_kexec_buffer_phys = data->addr;\n\t\tima_kexec_buffer_size = data->size;\n\t}\n\n\tearly_memunmap(data, sizeof(*data));\n#else\n\tpr_warn(\"Passed IMA kexec data, but CONFIG_IMA not set. Ignoring.\\n\");\n#endif\n}\n\n#if defined(CONFIG_HAVE_IMA_KEXEC) && !defined(CONFIG_OF_FLATTREE)\nint __init ima_free_kexec_buffer(void)\n{\n\tif (!ima_kexec_buffer_size)\n\t\treturn -ENOENT;\n\n\tmemblock_free_late(ima_kexec_buffer_phys,\n\t\t\t   ima_kexec_buffer_size);\n\n\tima_kexec_buffer_phys = 0;\n\tima_kexec_buffer_size = 0;\n\n\treturn 0;\n}\n\nint __init ima_get_kexec_buffer(void **addr, size_t *size)\n{\n\tif (!ima_kexec_buffer_size)\n\t\treturn -ENOENT;\n\n\t*addr = __va(ima_kexec_buffer_phys);\n\t*size = ima_kexec_buffer_size;\n\n\treturn 0;\n}\n#endif\n\nstatic void __init parse_setup_data(void)\n{\n\tstruct setup_data *data;\n\tu64 pa_data, pa_next;\n\n\tpa_data = boot_params.hdr.setup_data;\n\twhile (pa_data) {\n\t\tu32 data_len, data_type;\n\n\t\tdata = early_memremap(pa_data, sizeof(*data));\n\t\tdata_len = data->len + sizeof(struct setup_data);\n\t\tdata_type = data->type;\n\t\tpa_next = data->next;\n\t\tearly_memunmap(data, sizeof(*data));\n\n\t\tswitch (data_type) {\n\t\tcase SETUP_E820_EXT:\n\t\t\te820__memory_setup_extended(pa_data, data_len);\n\t\t\tbreak;\n\t\tcase SETUP_DTB:\n\t\t\tadd_dtb(pa_data);\n\t\t\tbreak;\n\t\tcase SETUP_EFI:\n\t\t\tparse_efi_setup(pa_data, data_len);\n\t\t\tbreak;\n\t\tcase SETUP_IMA:\n\t\t\tadd_early_ima_buffer(pa_data);\n\t\t\tbreak;\n\t\tcase SETUP_RNG_SEED:\n\t\t\tdata = early_memremap(pa_data, data_len);\n\t\t\tadd_bootloader_randomness(data->data, data->len);\n\t\t\t \n\t\t\tmemzero_explicit(data->data, data->len);\n\t\t\t \n\t\t\tmemzero_explicit(&data->len, sizeof(data->len));\n\t\t\tearly_memunmap(data, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tpa_data = pa_next;\n\t}\n}\n\nstatic void __init memblock_x86_reserve_range_setup_data(void)\n{\n\tstruct setup_indirect *indirect;\n\tstruct setup_data *data;\n\tu64 pa_data, pa_next;\n\tu32 len;\n\n\tpa_data = boot_params.hdr.setup_data;\n\twhile (pa_data) {\n\t\tdata = early_memremap(pa_data, sizeof(*data));\n\t\tif (!data) {\n\t\t\tpr_warn(\"setup: failed to memremap setup_data entry\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen = sizeof(*data);\n\t\tpa_next = data->next;\n\n\t\tmemblock_reserve(pa_data, sizeof(*data) + data->len);\n\n\t\tif (data->type == SETUP_INDIRECT) {\n\t\t\tlen += data->len;\n\t\t\tearly_memunmap(data, sizeof(*data));\n\t\t\tdata = early_memremap(pa_data, len);\n\t\t\tif (!data) {\n\t\t\t\tpr_warn(\"setup: failed to memremap indirect setup_data\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\t\tif (indirect->type != SETUP_INDIRECT)\n\t\t\t\tmemblock_reserve(indirect->addr, indirect->len);\n\t\t}\n\n\t\tpa_data = pa_next;\n\t\tearly_memunmap(data, len);\n\t}\n}\n\n \n\n \n#define CRASH_ALIGN\t\tSZ_16M\n\n \n#ifdef CONFIG_X86_32\n# define CRASH_ADDR_LOW_MAX\tSZ_512M\n# define CRASH_ADDR_HIGH_MAX\tSZ_512M\n#else\n# define CRASH_ADDR_LOW_MAX\tSZ_4G\n# define CRASH_ADDR_HIGH_MAX\tSZ_64T\n#endif\n\nstatic int __init reserve_crashkernel_low(void)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long long base, low_base = 0, low_size = 0;\n\tunsigned long low_mem_limit;\n\tint ret;\n\n\tlow_mem_limit = min(memblock_phys_mem_size(), CRASH_ADDR_LOW_MAX);\n\n\t \n\tret = parse_crashkernel_low(boot_command_line, low_mem_limit, &low_size, &base);\n\tif (ret) {\n\t\t \n\t\tlow_size = max(swiotlb_size_or_default() + (8UL << 20), 256UL << 20);\n\t} else {\n\t\t \n\t\tif (!low_size)\n\t\t\treturn 0;\n\t}\n\n\tlow_base = memblock_phys_alloc_range(low_size, CRASH_ALIGN, 0, CRASH_ADDR_LOW_MAX);\n\tif (!low_base) {\n\t\tpr_err(\"Cannot reserve %ldMB crashkernel low memory, please try smaller size.\\n\",\n\t\t       (unsigned long)(low_size >> 20));\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_info(\"Reserving %ldMB of low memory at %ldMB for crashkernel (low RAM limit: %ldMB)\\n\",\n\t\t(unsigned long)(low_size >> 20),\n\t\t(unsigned long)(low_base >> 20),\n\t\t(unsigned long)(low_mem_limit >> 20));\n\n\tcrashk_low_res.start = low_base;\n\tcrashk_low_res.end   = low_base + low_size - 1;\n\tinsert_resource(&iomem_resource, &crashk_low_res);\n#endif\n\treturn 0;\n}\n\nstatic void __init reserve_crashkernel(void)\n{\n\tunsigned long long crash_size, crash_base, total_mem;\n\tbool high = false;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_KEXEC_CORE))\n\t\treturn;\n\n\ttotal_mem = memblock_phys_mem_size();\n\n\t \n\tret = parse_crashkernel(boot_command_line, total_mem, &crash_size, &crash_base);\n\tif (ret != 0 || crash_size <= 0) {\n\t\t \n\t\tret = parse_crashkernel_high(boot_command_line, total_mem,\n\t\t\t\t\t     &crash_size, &crash_base);\n\t\tif (ret != 0 || crash_size <= 0)\n\t\t\treturn;\n\t\thigh = true;\n\t}\n\n\tif (xen_pv_domain()) {\n\t\tpr_info(\"Ignoring crashkernel for a Xen PV domain\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!crash_base) {\n\t\t \n\t\tif (!high)\n\t\t\tcrash_base = memblock_phys_alloc_range(crash_size,\n\t\t\t\t\t\tCRASH_ALIGN, CRASH_ALIGN,\n\t\t\t\t\t\tCRASH_ADDR_LOW_MAX);\n\t\tif (!crash_base)\n\t\t\tcrash_base = memblock_phys_alloc_range(crash_size,\n\t\t\t\t\t\tCRASH_ALIGN, CRASH_ALIGN,\n\t\t\t\t\t\tCRASH_ADDR_HIGH_MAX);\n\t\tif (!crash_base) {\n\t\t\tpr_info(\"crashkernel reservation failed - No suitable area found.\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tunsigned long long start;\n\n\t\tstart = memblock_phys_alloc_range(crash_size, SZ_1M, crash_base,\n\t\t\t\t\t\t  crash_base + crash_size);\n\t\tif (start != crash_base) {\n\t\t\tpr_info(\"crashkernel reservation failed - memory is in use.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (crash_base >= (1ULL << 32) && reserve_crashkernel_low()) {\n\t\tmemblock_phys_free(crash_base, crash_size);\n\t\treturn;\n\t}\n\n\tpr_info(\"Reserving %ldMB of memory at %ldMB for crashkernel (System RAM: %ldMB)\\n\",\n\t\t(unsigned long)(crash_size >> 20),\n\t\t(unsigned long)(crash_base >> 20),\n\t\t(unsigned long)(total_mem >> 20));\n\n\tcrashk_res.start = crash_base;\n\tcrashk_res.end   = crash_base + crash_size - 1;\n\tinsert_resource(&iomem_resource, &crashk_res);\n}\n\nstatic struct resource standard_io_resources[] = {\n\t{ .name = \"dma1\", .start = 0x00, .end = 0x1f,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"pic1\", .start = 0x20, .end = 0x21,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"timer0\", .start = 0x40, .end = 0x43,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"timer1\", .start = 0x50, .end = 0x53,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"keyboard\", .start = 0x60, .end = 0x60,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"keyboard\", .start = 0x64, .end = 0x64,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"dma page reg\", .start = 0x80, .end = 0x8f,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"pic2\", .start = 0xa0, .end = 0xa1,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"dma2\", .start = 0xc0, .end = 0xdf,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO },\n\t{ .name = \"fpu\", .start = 0xf0, .end = 0xff,\n\t\t.flags = IORESOURCE_BUSY | IORESOURCE_IO }\n};\n\nvoid __init reserve_standard_io_resources(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(standard_io_resources); i++)\n\t\trequest_resource(&ioport_resource, &standard_io_resources[i]);\n\n}\n\nstatic bool __init snb_gfx_workaround_needed(void)\n{\n#ifdef CONFIG_PCI\n\tint i;\n\tu16 vendor, devid;\n\tstatic const __initconst u16 snb_ids[] = {\n\t\t0x0102,\n\t\t0x0112,\n\t\t0x0122,\n\t\t0x0106,\n\t\t0x0116,\n\t\t0x0126,\n\t\t0x010a,\n\t};\n\n\t \n\tif (!early_pci_allowed())\n\t\treturn false;\n\n\tvendor = read_pci_config_16(0, 2, 0, PCI_VENDOR_ID);\n\tif (vendor != 0x8086)\n\t\treturn false;\n\n\tdevid = read_pci_config_16(0, 2, 0, PCI_DEVICE_ID);\n\tfor (i = 0; i < ARRAY_SIZE(snb_ids); i++)\n\t\tif (devid == snb_ids[i])\n\t\t\treturn true;\n#endif\n\n\treturn false;\n}\n\n \nstatic void __init trim_snb_memory(void)\n{\n\tstatic const __initconst unsigned long bad_pages[] = {\n\t\t0x20050000,\n\t\t0x20110000,\n\t\t0x20130000,\n\t\t0x20138000,\n\t\t0x40004000,\n\t};\n\tint i;\n\n\tif (!snb_gfx_workaround_needed())\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"reserving inaccessible SNB gfx pages\\n\");\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(bad_pages); i++) {\n\t\tif (memblock_reserve(bad_pages[i], PAGE_SIZE))\n\t\t\tprintk(KERN_WARNING \"failed to reserve 0x%08lx\\n\",\n\t\t\t       bad_pages[i]);\n\t}\n}\n\nstatic void __init trim_bios_range(void)\n{\n\t \n\te820__range_update(0, PAGE_SIZE, E820_TYPE_RAM, E820_TYPE_RESERVED);\n\n\t \n\te820__range_remove(BIOS_BEGIN, BIOS_END - BIOS_BEGIN, E820_TYPE_RAM, 1);\n\n\te820__update_table(e820_table);\n}\n\n \nstatic void __init e820_add_kernel_range(void)\n{\n\tu64 start = __pa_symbol(_text);\n\tu64 size = __pa_symbol(_end) - start;\n\n\t \n\tif (e820__mapped_all(start, start + size, E820_TYPE_RAM))\n\t\treturn;\n\n\tpr_warn(\".text .data .bss are not marked as E820_TYPE_RAM!\\n\");\n\te820__range_remove(start, size, E820_TYPE_RAM, 0);\n\te820__range_add(start, size, E820_TYPE_RAM);\n}\n\nstatic void __init early_reserve_memory(void)\n{\n\t \n\tmemblock_reserve(__pa_symbol(_text),\n\t\t\t (unsigned long)__end_of_kernel_reserve - (unsigned long)_text);\n\n\t \n\tmemblock_reserve(0, SZ_64K);\n\n\tearly_reserve_initrd();\n\n\tmemblock_x86_reserve_range_setup_data();\n\n\treserve_bios_regions();\n\ttrim_snb_memory();\n}\n\n \nstatic int\ndump_kernel_offset(struct notifier_block *self, unsigned long v, void *p)\n{\n\tif (kaslr_enabled()) {\n\t\tpr_emerg(\"Kernel Offset: 0x%lx from 0x%lx (relocation range: 0x%lx-0x%lx)\\n\",\n\t\t\t kaslr_offset(),\n\t\t\t __START_KERNEL,\n\t\t\t __START_KERNEL_map,\n\t\t\t MODULES_VADDR-1);\n\t} else {\n\t\tpr_emerg(\"Kernel Offset: disabled\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid x86_configure_nx(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\t__supported_pte_mask |= _PAGE_NX;\n\telse\n\t\t__supported_pte_mask &= ~_PAGE_NX;\n}\n\nstatic void __init x86_report_nx(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_NX)) {\n\t\tprintk(KERN_NOTICE \"Notice: NX (Execute Disable) protection \"\n\t\t       \"missing in CPU!\\n\");\n\t} else {\n#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)\n\t\tprintk(KERN_INFO \"NX (Execute Disable) protection: active\\n\");\n#else\n\t\t \n\t\tprintk(KERN_NOTICE \"Notice: NX (Execute Disable) protection \"\n\t\t       \"cannot be enabled: non-PAE kernel!\\n\");\n#endif\n\t}\n}\n\n \n \n\nvoid __init setup_arch(char **cmdline_p)\n{\n#ifdef CONFIG_X86_32\n\tmemcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));\n\n\t \n\tclone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,\n\t\t\tinitial_page_table + KERNEL_PGD_BOUNDARY,\n\t\t\tKERNEL_PGD_PTRS);\n\n\tload_cr3(swapper_pg_dir);\n\t \n\t__flush_tlb_all();\n#else\n\tprintk(KERN_INFO \"Command line: %s\\n\", boot_command_line);\n\tboot_cpu_data.x86_phys_bits = MAX_PHYSMEM_BITS;\n#endif\n\n\t \n\tolpc_ofw_detect();\n\n\tidt_setup_early_traps();\n\tearly_cpu_init();\n\tjump_label_init();\n\tstatic_call_init();\n\tearly_ioremap_init();\n\n\tsetup_olpc_ofw_pgd();\n\n\tROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);\n\tscreen_info = boot_params.screen_info;\n\tedid_info = boot_params.edid_info;\n#ifdef CONFIG_X86_32\n\tapm_info.bios = boot_params.apm_bios_info;\n\tist_info = boot_params.ist_info;\n#endif\n\tsaved_video_mode = boot_params.hdr.vid_mode;\n\tbootloader_type = boot_params.hdr.type_of_loader;\n\tif ((bootloader_type >> 4) == 0xe) {\n\t\tbootloader_type &= 0xf;\n\t\tbootloader_type |= (boot_params.hdr.ext_loader_type+0x10) << 4;\n\t}\n\tbootloader_version  = bootloader_type & 0xf;\n\tbootloader_version |= boot_params.hdr.ext_loader_ver << 4;\n\n#ifdef CONFIG_BLK_DEV_RAM\n\trd_image_start = boot_params.hdr.ram_size & RAMDISK_IMAGE_START_MASK;\n#endif\n#ifdef CONFIG_EFI\n\tif (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,\n\t\t     EFI32_LOADER_SIGNATURE, 4)) {\n\t\tset_bit(EFI_BOOT, &efi.flags);\n\t} else if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,\n\t\t     EFI64_LOADER_SIGNATURE, 4)) {\n\t\tset_bit(EFI_BOOT, &efi.flags);\n\t\tset_bit(EFI_64BIT, &efi.flags);\n\t}\n#endif\n\n\tx86_init.oem.arch_setup();\n\n\t \n\tearly_reserve_memory();\n\n\tiomem_resource.end = (1ULL << boot_cpu_data.x86_phys_bits) - 1;\n\te820__memory_setup();\n\tparse_setup_data();\n\n\tcopy_edd();\n\n\tif (!boot_params.hdr.root_flags)\n\t\troot_mountflags &= ~MS_RDONLY;\n\tsetup_initial_init_mm(_text, _etext, _edata, (void *)_brk_end);\n\n\tcode_resource.start = __pa_symbol(_text);\n\tcode_resource.end = __pa_symbol(_etext)-1;\n\trodata_resource.start = __pa_symbol(__start_rodata);\n\trodata_resource.end = __pa_symbol(__end_rodata)-1;\n\tdata_resource.start = __pa_symbol(_sdata);\n\tdata_resource.end = __pa_symbol(_edata)-1;\n\tbss_resource.start = __pa_symbol(__bss_start);\n\tbss_resource.end = __pa_symbol(__bss_stop)-1;\n\n#ifdef CONFIG_CMDLINE_BOOL\n#ifdef CONFIG_CMDLINE_OVERRIDE\n\tstrscpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);\n#else\n\tif (builtin_cmdline[0]) {\n\t\t \n\t\tstrlcat(builtin_cmdline, \" \", COMMAND_LINE_SIZE);\n\t\tstrlcat(builtin_cmdline, boot_command_line, COMMAND_LINE_SIZE);\n\t\tstrscpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);\n\t}\n#endif\n#endif\n\n\tstrscpy(command_line, boot_command_line, COMMAND_LINE_SIZE);\n\t*cmdline_p = command_line;\n\n\t \n\tx86_configure_nx();\n\n\tparse_early_param();\n\n\tif (efi_enabled(EFI_BOOT))\n\t\tefi_memblock_x86_reserve_range();\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n\t \n\tif (movable_node_is_enabled())\n\t\tmemblock_set_bottom_up(true);\n#endif\n\n\tx86_report_nx();\n\n\tapic_setup_apic_calls();\n\n\tif (acpi_mps_check()) {\n#ifdef CONFIG_X86_LOCAL_APIC\n\t\tapic_is_disabled = true;\n#endif\n\t\tsetup_clear_cpu_cap(X86_FEATURE_APIC);\n\t}\n\n\te820__reserve_setup_data();\n\te820__finish_early_params();\n\n\tif (efi_enabled(EFI_BOOT))\n\t\tefi_init();\n\n\treserve_ibft_region();\n\tdmi_setup();\n\n\t \n\tinit_hypervisor_platform();\n\n\ttsc_early_init();\n\tx86_init.resources.probe_roms();\n\n\t \n\tinsert_resource(&iomem_resource, &code_resource);\n\tinsert_resource(&iomem_resource, &rodata_resource);\n\tinsert_resource(&iomem_resource, &data_resource);\n\tinsert_resource(&iomem_resource, &bss_resource);\n\n\te820_add_kernel_range();\n\ttrim_bios_range();\n#ifdef CONFIG_X86_32\n\tif (ppro_with_ram_bug()) {\n\t\te820__range_update(0x70000000ULL, 0x40000ULL, E820_TYPE_RAM,\n\t\t\t\t  E820_TYPE_RESERVED);\n\t\te820__update_table(e820_table);\n\t\tprintk(KERN_INFO \"fixed physical RAM map:\\n\");\n\t\te820__print_table(\"bad_ppro\");\n\t}\n#else\n\tearly_gart_iommu_check();\n#endif\n\n\t \n\tmax_pfn = e820__end_of_ram_pfn();\n\n\t \n\tcache_bp_init();\n\tif (mtrr_trim_uncached_memory(max_pfn))\n\t\tmax_pfn = e820__end_of_ram_pfn();\n\n\tmax_possible_pfn = max_pfn;\n\n\t \n\tkernel_randomize_memory();\n\n#ifdef CONFIG_X86_32\n\t \n\tfind_low_pfn_range();\n#else\n\tcheck_x2apic();\n\n\t \n\t \n\tif (max_pfn > (1UL<<(32 - PAGE_SHIFT)))\n\t\tmax_low_pfn = e820__end_of_low_ram_pfn();\n\telse\n\t\tmax_low_pfn = max_pfn;\n\n\thigh_memory = (void *)__va(max_pfn * PAGE_SIZE - 1) + 1;\n#endif\n\n\t \n\tfind_smp_config();\n\n\tearly_alloc_pgt_buf();\n\n\t \n\treserve_brk();\n\n\tcleanup_highmap();\n\n\tmemblock_set_current_limit(ISA_END_ADDRESS);\n\te820__memblock_setup();\n\n\t \n\tsev_setup_arch();\n\n\tefi_fake_memmap();\n\tefi_find_mirror();\n\tefi_esrt_init();\n\tefi_mokvar_table_init();\n\n\t \n\tefi_reserve_boot_services();\n\n\t \n\te820__memblock_alloc_reserved_mpc_new();\n\n#ifdef CONFIG_X86_CHECK_BIOS_CORRUPTION\n\tsetup_bios_corruption_check();\n#endif\n\n#ifdef CONFIG_X86_32\n\tprintk(KERN_DEBUG \"initial memory mapped: [mem 0x00000000-%#010lx]\\n\",\n\t\t\t(max_pfn_mapped<<PAGE_SHIFT) - 1);\n#endif\n\n\t \n\tx86_platform.realmode_reserve();\n\n\tinit_mem_mapping();\n\n\tidt_setup_early_pf();\n\n\t \n\tmmu_cr4_features = __read_cr4() & ~X86_CR4_PCIDE;\n\n\tmemblock_set_current_limit(get_max_mapped());\n\n\t \n\n#ifdef CONFIG_PROVIDE_OHCI1394_DMA_INIT\n\tif (init_ohci1394_dma_early)\n\t\tinit_ohci1394_dma_on_all_controllers();\n#endif\n\t \n\tsetup_log_buf(1);\n\n\tif (efi_enabled(EFI_BOOT)) {\n\t\tswitch (boot_params.secure_boot) {\n\t\tcase efi_secureboot_mode_disabled:\n\t\t\tpr_info(\"Secure boot disabled\\n\");\n\t\t\tbreak;\n\t\tcase efi_secureboot_mode_enabled:\n\t\t\tpr_info(\"Secure boot enabled\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Secure boot could not be determined\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treserve_initrd();\n\n\tacpi_table_upgrade();\n\t \n\tacpi_boot_table_init();\n\n\tvsmp_init();\n\n\tio_delay_init();\n\n\tearly_platform_quirks();\n\n\tearly_acpi_boot_init();\n\n\tinitmem_init();\n\tdma_contiguous_reserve(max_pfn_mapped << PAGE_SHIFT);\n\n\tif (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\thugetlb_cma_reserve(PUD_SHIFT - PAGE_SHIFT);\n\n\t \n\treserve_crashkernel();\n\n\tmemblock_find_dma_reserve();\n\n\tif (!early_xdbc_setup_hardware())\n\t\tearly_xdbc_register_console();\n\n\tx86_init.paging.pagetable_init();\n\n\tkasan_init();\n\n\t \n\tsync_initial_page_table();\n\n\ttboot_probe();\n\n\tmap_vsyscall();\n\n\tx86_32_probe_apic();\n\n\tearly_quirks();\n\n\t \n\tacpi_boot_init();\n\tx86_dtb_init();\n\n\t \n\tget_smp_config();\n\n\t \n\tinit_apic_mappings();\n\n\tprefill_possible_map();\n\n\tinit_cpu_to_node();\n\tinit_gi_nodes();\n\n\tio_apic_init_mappings();\n\n\tx86_init.hyper.guest_late_init();\n\n\te820__reserve_resources();\n\te820__register_nosave_regions(max_pfn);\n\n\tx86_init.resources.reserve_resources();\n\n\te820__setup_pci_gap();\n\n#ifdef CONFIG_VT\n#if defined(CONFIG_VGA_CONSOLE)\n\tif (!efi_enabled(EFI_BOOT) || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))\n\t\tconswitchp = &vga_con;\n#endif\n#endif\n\tx86_init.oem.banner();\n\n\tx86_init.timers.wallclock_init();\n\n\t \n\ttherm_lvt_init();\n\n\tmcheck_init();\n\n\tregister_refined_jiffies(CLOCK_TICK_RATE);\n\n#ifdef CONFIG_EFI\n\tif (efi_enabled(EFI_BOOT))\n\t\tefi_apply_memmap_quirks();\n#endif\n\n\tunwind_init();\n}\n\n#ifdef CONFIG_X86_32\n\nstatic struct resource video_ram_resource = {\n\t.name\t= \"Video RAM area\",\n\t.start\t= 0xa0000,\n\t.end\t= 0xbffff,\n\t.flags\t= IORESOURCE_BUSY | IORESOURCE_MEM\n};\n\nvoid __init i386_reserve_resources(void)\n{\n\trequest_resource(&iomem_resource, &video_ram_resource);\n\treserve_standard_io_resources();\n}\n\n#endif  \n\nstatic struct notifier_block kernel_offset_notifier = {\n\t.notifier_call = dump_kernel_offset\n};\n\nstatic int __init register_kernel_offset_dumper(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t&kernel_offset_notifier);\n\treturn 0;\n}\n__initcall(register_kernel_offset_dumper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}