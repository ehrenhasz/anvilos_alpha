{
  "module_name": "jump_label.c",
  "hash_id": "a3030c0541b3c108da0d29525b82dd1cf6a4f56687050fe6e17f636b2624266c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/jump_label.c",
  "human_readable_source": "\n \n#include <linux/jump_label.h>\n#include <linux/memory.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/cpu.h>\n#include <asm/kprobes.h>\n#include <asm/alternative.h>\n#include <asm/text-patching.h>\n#include <asm/insn.h>\n\nint arch_jump_entry_size(struct jump_entry *entry)\n{\n\tstruct insn insn = {};\n\n\tinsn_decode_kernel(&insn, (void *)jump_entry_code(entry));\n\tBUG_ON(insn.length != 2 && insn.length != 5);\n\n\treturn insn.length;\n}\n\nstruct jump_label_patch {\n\tconst void *code;\n\tint size;\n};\n\nstatic struct jump_label_patch\n__jump_label_patch(struct jump_entry *entry, enum jump_label_type type)\n{\n\tconst void *expect, *code, *nop;\n\tconst void *addr, *dest;\n\tint size;\n\n\taddr = (void *)jump_entry_code(entry);\n\tdest = (void *)jump_entry_target(entry);\n\n\tsize = arch_jump_entry_size(entry);\n\tswitch (size) {\n\tcase JMP8_INSN_SIZE:\n\t\tcode = text_gen_insn(JMP8_INSN_OPCODE, addr, dest);\n\t\tnop = x86_nops[size];\n\t\tbreak;\n\n\tcase JMP32_INSN_SIZE:\n\t\tcode = text_gen_insn(JMP32_INSN_OPCODE, addr, dest);\n\t\tnop = x86_nops[size];\n\t\tbreak;\n\n\tdefault: BUG();\n\t}\n\n\tif (type == JUMP_LABEL_JMP)\n\t\texpect = nop;\n\telse\n\t\texpect = code;\n\n\tif (memcmp(addr, expect, size)) {\n\t\t \n\t\tpr_crit(\"jump_label: Fatal kernel bug, unexpected op at %pS [%p] (%5ph != %5ph)) size:%d type:%d\\n\",\n\t\t\t\taddr, addr, addr, expect, size, type);\n\t\tBUG();\n\t}\n\n\tif (type == JUMP_LABEL_NOP)\n\t\tcode = nop;\n\n\treturn (struct jump_label_patch){.code = code, .size = size};\n}\n\nstatic __always_inline void\n__jump_label_transform(struct jump_entry *entry,\n\t\t       enum jump_label_type type,\n\t\t       int init)\n{\n\tconst struct jump_label_patch jlp = __jump_label_patch(entry, type);\n\n\t \n\tif (init || system_state == SYSTEM_BOOTING) {\n\t\ttext_poke_early((void *)jump_entry_code(entry), jlp.code, jlp.size);\n\t\treturn;\n\t}\n\n\ttext_poke_bp((void *)jump_entry_code(entry), jlp.code, jlp.size, NULL);\n}\n\nstatic void __ref jump_label_transform(struct jump_entry *entry,\n\t\t\t\t       enum jump_label_type type,\n\t\t\t\t       int init)\n{\n\tmutex_lock(&text_mutex);\n\t__jump_label_transform(entry, type, init);\n\tmutex_unlock(&text_mutex);\n}\n\nvoid arch_jump_label_transform(struct jump_entry *entry,\n\t\t\t       enum jump_label_type type)\n{\n\tjump_label_transform(entry, type, 0);\n}\n\nbool arch_jump_label_transform_queue(struct jump_entry *entry,\n\t\t\t\t     enum jump_label_type type)\n{\n\tstruct jump_label_patch jlp;\n\n\tif (system_state == SYSTEM_BOOTING) {\n\t\t \n\t\tarch_jump_label_transform(entry, type);\n\t\treturn true;\n\t}\n\n\tmutex_lock(&text_mutex);\n\tjlp = __jump_label_patch(entry, type);\n\ttext_poke_queue((void *)jump_entry_code(entry), jlp.code, jlp.size, NULL);\n\tmutex_unlock(&text_mutex);\n\treturn true;\n}\n\nvoid arch_jump_label_transform_apply(void)\n{\n\tmutex_lock(&text_mutex);\n\ttext_poke_finish();\n\tmutex_unlock(&text_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}