{
  "module_name": "amd_nb.c",
  "hash_id": "a20fcf5c1c4d1393e1eca15c58701b4ddd42273bc1135f5a1aabbe8c89df29ca",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/amd_nb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/pci_ids.h>\n#include <asm/amd_nb.h>\n\n#define PCI_DEVICE_ID_AMD_17H_ROOT\t\t0x1450\n#define PCI_DEVICE_ID_AMD_17H_M10H_ROOT\t\t0x15d0\n#define PCI_DEVICE_ID_AMD_17H_M30H_ROOT\t\t0x1480\n#define PCI_DEVICE_ID_AMD_17H_M60H_ROOT\t\t0x1630\n#define PCI_DEVICE_ID_AMD_17H_MA0H_ROOT\t\t0x14b5\n#define PCI_DEVICE_ID_AMD_19H_M10H_ROOT\t\t0x14a4\n#define PCI_DEVICE_ID_AMD_19H_M40H_ROOT\t\t0x14b5\n#define PCI_DEVICE_ID_AMD_19H_M60H_ROOT\t\t0x14d8\n#define PCI_DEVICE_ID_AMD_19H_M70H_ROOT\t\t0x14e8\n#define PCI_DEVICE_ID_AMD_1AH_M00H_ROOT\t\t0x153a\n#define PCI_DEVICE_ID_AMD_1AH_M20H_ROOT\t\t0x1507\n#define PCI_DEVICE_ID_AMD_MI200_ROOT\t\t0x14bb\n\n#define PCI_DEVICE_ID_AMD_17H_DF_F4\t\t0x1464\n#define PCI_DEVICE_ID_AMD_17H_M10H_DF_F4\t0x15ec\n#define PCI_DEVICE_ID_AMD_17H_M30H_DF_F4\t0x1494\n#define PCI_DEVICE_ID_AMD_17H_M60H_DF_F4\t0x144c\n#define PCI_DEVICE_ID_AMD_17H_M70H_DF_F4\t0x1444\n#define PCI_DEVICE_ID_AMD_17H_MA0H_DF_F4\t0x1728\n#define PCI_DEVICE_ID_AMD_19H_DF_F4\t\t0x1654\n#define PCI_DEVICE_ID_AMD_19H_M10H_DF_F4\t0x14b1\n#define PCI_DEVICE_ID_AMD_19H_M40H_DF_F4\t0x167d\n#define PCI_DEVICE_ID_AMD_19H_M50H_DF_F4\t0x166e\n#define PCI_DEVICE_ID_AMD_19H_M60H_DF_F4\t0x14e4\n#define PCI_DEVICE_ID_AMD_19H_M70H_DF_F4\t0x14f4\n#define PCI_DEVICE_ID_AMD_19H_M78H_DF_F4\t0x12fc\n#define PCI_DEVICE_ID_AMD_1AH_M00H_DF_F4\t0x12c4\n#define PCI_DEVICE_ID_AMD_MI200_DF_F4\t\t0x14d4\n\n \nstatic DEFINE_MUTEX(smn_mutex);\n\nstatic u32 *flush_words;\n\nstatic const struct pci_device_id amd_root_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M60H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_MA0H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M10H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M40H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M60H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M70H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M00H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M20H_ROOT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_MI200_ROOT) },\n\t{}\n};\n\n#define PCI_DEVICE_ID_AMD_CNB17H_F4     0x1704\n\nstatic const struct pci_device_id amd_nb_misc_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_10H_NB_MISC) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_NB_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M10H_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M60H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_MA0H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CNB17H_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M70H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M10H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M40H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M50H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M60H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M70H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M78H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M00H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M20H_DF_F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_MI200_DF_F3) },\n\t{}\n};\n\nstatic const struct pci_device_id amd_nb_link_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_NB_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M60H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M70H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_MA0H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M10H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M40H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M50H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M60H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M70H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_19H_M78H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CNB17H_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M00H_DF_F4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_MI200_DF_F4) },\n\t{}\n};\n\nstatic const struct pci_device_id hygon_root_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HYGON, PCI_DEVICE_ID_AMD_17H_ROOT) },\n\t{}\n};\n\nstatic const struct pci_device_id hygon_nb_misc_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HYGON, PCI_DEVICE_ID_AMD_17H_DF_F3) },\n\t{}\n};\n\nstatic const struct pci_device_id hygon_nb_link_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HYGON, PCI_DEVICE_ID_AMD_17H_DF_F4) },\n\t{}\n};\n\nconst struct amd_nb_bus_dev_range amd_nb_bus_dev_ranges[] __initconst = {\n\t{ 0x00, 0x18, 0x20 },\n\t{ 0xff, 0x00, 0x20 },\n\t{ 0xfe, 0x00, 0x20 },\n\t{ }\n};\n\nstatic struct amd_northbridge_info amd_northbridges;\n\nu16 amd_nb_num(void)\n{\n\treturn amd_northbridges.num;\n}\nEXPORT_SYMBOL_GPL(amd_nb_num);\n\nbool amd_nb_has_feature(unsigned int feature)\n{\n\treturn ((amd_northbridges.flags & feature) == feature);\n}\nEXPORT_SYMBOL_GPL(amd_nb_has_feature);\n\nstruct amd_northbridge *node_to_amd_nb(int node)\n{\n\treturn (node < amd_northbridges.num) ? &amd_northbridges.nb[node] : NULL;\n}\nEXPORT_SYMBOL_GPL(node_to_amd_nb);\n\nstatic struct pci_dev *next_northbridge(struct pci_dev *dev,\n\t\t\t\t\tconst struct pci_device_id *ids)\n{\n\tdo {\n\t\tdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev);\n\t\tif (!dev)\n\t\t\tbreak;\n\t} while (!pci_match_id(ids, dev));\n\treturn dev;\n}\n\nstatic int __amd_smn_rw(u16 node, u32 address, u32 *value, bool write)\n{\n\tstruct pci_dev *root;\n\tint err = -ENODEV;\n\n\tif (node >= amd_northbridges.num)\n\t\tgoto out;\n\n\troot = node_to_amd_nb(node)->root;\n\tif (!root)\n\t\tgoto out;\n\n\tmutex_lock(&smn_mutex);\n\n\terr = pci_write_config_dword(root, 0x60, address);\n\tif (err) {\n\t\tpr_warn(\"Error programming SMN address 0x%x.\\n\", address);\n\t\tgoto out_unlock;\n\t}\n\n\terr = (write ? pci_write_config_dword(root, 0x64, *value)\n\t\t     : pci_read_config_dword(root, 0x64, value));\n\tif (err)\n\t\tpr_warn(\"Error %s SMN address 0x%x.\\n\",\n\t\t\t(write ? \"writing to\" : \"reading from\"), address);\n\nout_unlock:\n\tmutex_unlock(&smn_mutex);\n\nout:\n\treturn err;\n}\n\nint amd_smn_read(u16 node, u32 address, u32 *value)\n{\n\treturn __amd_smn_rw(node, address, value, false);\n}\nEXPORT_SYMBOL_GPL(amd_smn_read);\n\nint amd_smn_write(u16 node, u32 address, u32 value)\n{\n\treturn __amd_smn_rw(node, address, &value, true);\n}\nEXPORT_SYMBOL_GPL(amd_smn_write);\n\n\nstatic int amd_cache_northbridges(void)\n{\n\tconst struct pci_device_id *misc_ids = amd_nb_misc_ids;\n\tconst struct pci_device_id *link_ids = amd_nb_link_ids;\n\tconst struct pci_device_id *root_ids = amd_root_ids;\n\tstruct pci_dev *root, *misc, *link;\n\tstruct amd_northbridge *nb;\n\tu16 roots_per_misc = 0;\n\tu16 misc_count = 0;\n\tu16 root_count = 0;\n\tu16 i, j;\n\n\tif (amd_northbridges.num)\n\t\treturn 0;\n\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_HYGON) {\n\t\troot_ids = hygon_root_ids;\n\t\tmisc_ids = hygon_nb_misc_ids;\n\t\tlink_ids = hygon_nb_link_ids;\n\t}\n\n\tmisc = NULL;\n\twhile ((misc = next_northbridge(misc, misc_ids)))\n\t\tmisc_count++;\n\n\tif (!misc_count)\n\t\treturn -ENODEV;\n\n\troot = NULL;\n\twhile ((root = next_northbridge(root, root_ids)))\n\t\troot_count++;\n\n\tif (root_count) {\n\t\troots_per_misc = root_count / misc_count;\n\n\t\t \n\t\tif (!roots_per_misc || (root_count % roots_per_misc)) {\n\t\t\tpr_info(\"Unsupported AMD DF/PCI configuration found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tnb = kcalloc(misc_count, sizeof(struct amd_northbridge), GFP_KERNEL);\n\tif (!nb)\n\t\treturn -ENOMEM;\n\n\tamd_northbridges.nb = nb;\n\tamd_northbridges.num = misc_count;\n\n\tlink = misc = root = NULL;\n\tfor (i = 0; i < amd_northbridges.num; i++) {\n\t\tnode_to_amd_nb(i)->root = root =\n\t\t\tnext_northbridge(root, root_ids);\n\t\tnode_to_amd_nb(i)->misc = misc =\n\t\t\tnext_northbridge(misc, misc_ids);\n\t\tnode_to_amd_nb(i)->link = link =\n\t\t\tnext_northbridge(link, link_ids);\n\n\t\t \n\t\tfor (j = 1; j < roots_per_misc; j++)\n\t\t\troot = next_northbridge(root, root_ids);\n\t}\n\n\tif (amd_gart_present())\n\t\tamd_northbridges.flags |= AMD_NB_GART;\n\n\t \n\tif (!cpuid_edx(0x80000006))\n\t\treturn 0;\n\n\t \n\tif (boot_cpu_data.x86 == 0x10 &&\n\t    boot_cpu_data.x86_model >= 0x8 &&\n\t    (boot_cpu_data.x86_model > 0x9 ||\n\t     boot_cpu_data.x86_stepping >= 0x1))\n\t\tamd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\n\n\tif (boot_cpu_data.x86 == 0x15)\n\t\tamd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\n\n\t \n\tif (boot_cpu_data.x86 == 0x15)\n\t\tamd_northbridges.flags |= AMD_NB_L3_PARTITIONING;\n\n\treturn 0;\n}\n\n \nbool __init early_is_amd_nb(u32 device)\n{\n\tconst struct pci_device_id *misc_ids = amd_nb_misc_ids;\n\tconst struct pci_device_id *id;\n\tu32 vendor = device & 0xffff;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON)\n\t\treturn false;\n\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_HYGON)\n\t\tmisc_ids = hygon_nb_misc_ids;\n\n\tdevice >>= 16;\n\tfor (id = misc_ids; id->vendor; id++)\n\t\tif (vendor == id->vendor && device == id->device)\n\t\t\treturn true;\n\treturn false;\n}\n\nstruct resource *amd_get_mmconfig_range(struct resource *res)\n{\n\tu32 address;\n\tu64 base, msr;\n\tunsigned int segn_busn_bits;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON)\n\t\treturn NULL;\n\n\t \n\tif (boot_cpu_data.x86 < 0x10)\n\t\treturn NULL;\n\n\taddress = MSR_FAM10H_MMIO_CONF_BASE;\n\trdmsrl(address, msr);\n\n\t \n\tif (!(msr & FAM10H_MMIO_CONF_ENABLE))\n\t\treturn NULL;\n\n\tbase = msr & (FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT);\n\n\tsegn_busn_bits = (msr >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\n\t\t\t FAM10H_MMIO_CONF_BUSRANGE_MASK;\n\n\tres->flags = IORESOURCE_MEM;\n\tres->start = base;\n\tres->end = base + (1ULL<<(segn_busn_bits + 20)) - 1;\n\treturn res;\n}\n\nint amd_get_subcaches(int cpu)\n{\n\tstruct pci_dev *link = node_to_amd_nb(topology_die_id(cpu))->link;\n\tunsigned int mask;\n\n\tif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\n\t\treturn 0;\n\n\tpci_read_config_dword(link, 0x1d4, &mask);\n\n\treturn (mask >> (4 * cpu_data(cpu).cpu_core_id)) & 0xf;\n}\n\nint amd_set_subcaches(int cpu, unsigned long mask)\n{\n\tstatic unsigned int reset, ban;\n\tstruct amd_northbridge *nb = node_to_amd_nb(topology_die_id(cpu));\n\tunsigned int reg;\n\tint cuid;\n\n\tif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING) || mask > 0xf)\n\t\treturn -EINVAL;\n\n\t \n\tif (reset == 0) {\n\t\tpci_read_config_dword(nb->link, 0x1d4, &reset);\n\t\tpci_read_config_dword(nb->misc, 0x1b8, &ban);\n\t\tban &= 0x180000;\n\t}\n\n\t \n\tif (mask != 0xf) {\n\t\tpci_read_config_dword(nb->misc, 0x1b8, &reg);\n\t\tpci_write_config_dword(nb->misc, 0x1b8, reg & ~0x180000);\n\t}\n\n\tcuid = cpu_data(cpu).cpu_core_id;\n\tmask <<= 4 * cuid;\n\tmask |= (0xf ^ (1 << cuid)) << 26;\n\n\tpci_write_config_dword(nb->link, 0x1d4, mask);\n\n\t \n\tpci_read_config_dword(nb->link, 0x1d4, &reg);\n\tif (reg == reset) {\n\t\tpci_read_config_dword(nb->misc, 0x1b8, &reg);\n\t\treg &= ~0x180000;\n\t\tpci_write_config_dword(nb->misc, 0x1b8, reg | ban);\n\t}\n\n\treturn 0;\n}\n\nstatic void amd_cache_gart(void)\n{\n\tu16 i;\n\n\tif (!amd_nb_has_feature(AMD_NB_GART))\n\t\treturn;\n\n\tflush_words = kmalloc_array(amd_northbridges.num, sizeof(u32), GFP_KERNEL);\n\tif (!flush_words) {\n\t\tamd_northbridges.flags &= ~AMD_NB_GART;\n\t\tpr_notice(\"Cannot initialize GART flush words, GART support disabled\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i != amd_northbridges.num; i++)\n\t\tpci_read_config_dword(node_to_amd_nb(i)->misc, 0x9c, &flush_words[i]);\n}\n\nvoid amd_flush_garts(void)\n{\n\tint flushed, i;\n\tunsigned long flags;\n\tstatic DEFINE_SPINLOCK(gart_lock);\n\n\tif (!amd_nb_has_feature(AMD_NB_GART))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&gart_lock, flags);\n\tflushed = 0;\n\tfor (i = 0; i < amd_northbridges.num; i++) {\n\t\tpci_write_config_dword(node_to_amd_nb(i)->misc, 0x9c,\n\t\t\t\t       flush_words[i] | 1);\n\t\tflushed++;\n\t}\n\tfor (i = 0; i < amd_northbridges.num; i++) {\n\t\tu32 w;\n\t\t \n\t\tfor (;;) {\n\t\t\tpci_read_config_dword(node_to_amd_nb(i)->misc,\n\t\t\t\t\t      0x9c, &w);\n\t\t\tif (!(w & 1))\n\t\t\t\tbreak;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&gart_lock, flags);\n\tif (!flushed)\n\t\tpr_notice(\"nothing to flush?\\n\");\n}\nEXPORT_SYMBOL_GPL(amd_flush_garts);\n\nstatic void __fix_erratum_688(void *info)\n{\n#define MSR_AMD64_IC_CFG 0xC0011021\n\n\tmsr_set_bit(MSR_AMD64_IC_CFG, 3);\n\tmsr_set_bit(MSR_AMD64_IC_CFG, 14);\n}\n\n \nstatic __init void fix_erratum_688(void)\n{\n\tstruct pci_dev *F4;\n\tu32 val;\n\n\tif (boot_cpu_data.x86 != 0x14)\n\t\treturn;\n\n\tif (!amd_northbridges.num)\n\t\treturn;\n\n\tF4 = node_to_amd_nb(0)->link;\n\tif (!F4)\n\t\treturn;\n\n\tif (pci_read_config_dword(F4, 0x164, &val))\n\t\treturn;\n\n\tif (val & BIT(2))\n\t\treturn;\n\n\ton_each_cpu(__fix_erratum_688, NULL, 0);\n\n\tpr_info(\"x86/cpu/AMD: CPU erratum 688 worked around\\n\");\n}\n\nstatic __init int init_amd_nbs(void)\n{\n\tamd_cache_northbridges();\n\tamd_cache_gart();\n\n\tfix_erratum_688();\n\n\treturn 0;\n}\n\n \nfs_initcall(init_amd_nbs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}