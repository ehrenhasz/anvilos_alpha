{
  "module_name": "smp.c",
  "hash_id": "b87e0b2e7db34cbf35f3e279a6537e7e7ef484b2e4e59f1c63348c1916df09fe",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/smp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n#include <linux/mc146818rtc.h>\n#include <linux/cache.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n#include <linux/gfp.h>\n#include <linux/kexec.h>\n\n#include <asm/mtrr.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/proto.h>\n#include <asm/apic.h>\n#include <asm/cpu.h>\n#include <asm/idtentry.h>\n#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/trace/irq_vectors.h>\n#include <asm/kexec.h>\n#include <asm/reboot.h>\n\n \n\nstatic atomic_t stopping_cpu = ATOMIC_INIT(-1);\nstatic bool smp_no_nmi_ipi = false;\n\nstatic int smp_stop_nmi_callback(unsigned int val, struct pt_regs *regs)\n{\n\t \n\tif (raw_smp_processor_id() == atomic_read(&stopping_cpu))\n\t\treturn NMI_HANDLED;\n\n\tcpu_emergency_disable_virtualization();\n\tstop_this_cpu(NULL);\n\n\treturn NMI_HANDLED;\n}\n\n \nDEFINE_IDTENTRY_SYSVEC(sysvec_reboot)\n{\n\tapic_eoi();\n\tcpu_emergency_disable_virtualization();\n\tstop_this_cpu(NULL);\n}\n\nstatic int register_stop_handler(void)\n{\n\treturn register_nmi_handler(NMI_LOCAL, smp_stop_nmi_callback,\n\t\t\t\t    NMI_FLAG_FIRST, \"smp_stop\");\n}\n\nstatic void native_stop_other_cpus(int wait)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags, timeout;\n\n\tif (reboot_force)\n\t\treturn;\n\n\t \n\tif (atomic_cmpxchg(&stopping_cpu, -1, cpu) != -1)\n\t\treturn;\n\n\t \n\tif (kexec_in_progress)\n\t\tsmp_kick_mwait_play_dead();\n\n\t \n\tcpumask_copy(&cpus_stop_mask, cpu_online_mask);\n\tcpumask_clear_cpu(cpu, &cpus_stop_mask);\n\n\tif (!cpumask_empty(&cpus_stop_mask)) {\n\t\tapic_send_IPI_allbutself(REBOOT_VECTOR);\n\n\t\t \n\t\ttimeout = USEC_PER_SEC;\n\t\twhile (!cpumask_empty(&cpus_stop_mask) && timeout--)\n\t\t\tudelay(1);\n\t}\n\n\t \n\tif (!cpumask_empty(&cpus_stop_mask)) {\n\t\t \n\t\tif (!smp_no_nmi_ipi && !register_stop_handler()) {\n\t\t\tpr_emerg(\"Shutting down cpus with NMI\\n\");\n\n\t\t\tfor_each_cpu(cpu, &cpus_stop_mask)\n\t\t\t\t__apic_send_IPI(cpu, NMI_VECTOR);\n\t\t}\n\t\t \n\t\ttimeout = USEC_PER_MSEC * 10;\n\t\twhile (!cpumask_empty(&cpus_stop_mask) && (wait || timeout--))\n\t\t\tudelay(1);\n\t}\n\n\tlocal_irq_save(flags);\n\tdisable_local_APIC();\n\tmcheck_cpu_clear(this_cpu_ptr(&cpu_info));\n\tlocal_irq_restore(flags);\n\n\t \n\tcpumask_clear(&cpus_stop_mask);\n}\n\n \nDEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_reschedule_ipi)\n{\n\tapic_eoi();\n\ttrace_reschedule_entry(RESCHEDULE_VECTOR);\n\tinc_irq_stat(irq_resched_count);\n\tscheduler_ipi();\n\ttrace_reschedule_exit(RESCHEDULE_VECTOR);\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_call_function)\n{\n\tapic_eoi();\n\ttrace_call_function_entry(CALL_FUNCTION_VECTOR);\n\tinc_irq_stat(irq_call_count);\n\tgeneric_smp_call_function_interrupt();\n\ttrace_call_function_exit(CALL_FUNCTION_VECTOR);\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_call_function_single)\n{\n\tapic_eoi();\n\ttrace_call_function_single_entry(CALL_FUNCTION_SINGLE_VECTOR);\n\tinc_irq_stat(irq_call_count);\n\tgeneric_smp_call_function_single_interrupt();\n\ttrace_call_function_single_exit(CALL_FUNCTION_SINGLE_VECTOR);\n}\n\nstatic int __init nonmi_ipi_setup(char *str)\n{\n\tsmp_no_nmi_ipi = true;\n\treturn 1;\n}\n\n__setup(\"nonmi_ipi\", nonmi_ipi_setup);\n\nstruct smp_ops smp_ops = {\n\t.smp_prepare_boot_cpu\t= native_smp_prepare_boot_cpu,\n\t.smp_prepare_cpus\t= native_smp_prepare_cpus,\n\t.smp_cpus_done\t\t= native_smp_cpus_done,\n\n\t.stop_other_cpus\t= native_stop_other_cpus,\n#if defined(CONFIG_KEXEC_CORE)\n\t.crash_stop_other_cpus\t= kdump_nmi_shootdown_cpus,\n#endif\n\t.smp_send_reschedule\t= native_smp_send_reschedule,\n\n\t.kick_ap_alive\t\t= native_kick_ap,\n\t.cpu_disable\t\t= native_cpu_disable,\n\t.play_dead\t\t= native_play_dead,\n\n\t.send_call_func_ipi\t= native_send_call_func_ipi,\n\t.send_call_func_single_ipi = native_send_call_func_single_ipi,\n};\nEXPORT_SYMBOL_GPL(smp_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}