{
  "module_name": "irq_32.c",
  "hash_id": "2d86ee5bf8c4fb842e25cedbc83203f1b9a2d8cc5fbe38f224265cdf339dae25",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/irq_32.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel_stat.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n\n#include <asm/apic.h>\n#include <asm/nospec-branch.h>\n#include <asm/softirq_stack.h>\n\n#ifdef CONFIG_DEBUG_STACKOVERFLOW\n\nint sysctl_panic_on_stackoverflow __read_mostly;\n\n \nstatic int check_stack_overflow(void)\n{\n\tlong sp;\n\n\t__asm__ __volatile__(\"andl %%esp,%0\" :\n\t\t\t     \"=r\" (sp) : \"0\" (THREAD_SIZE - 1));\n\n\treturn sp < (sizeof(struct thread_info) + STACK_WARN);\n}\n\nstatic void print_stack_overflow(void)\n{\n\tprintk(KERN_WARNING \"low stack detected by irq handler\\n\");\n\tdump_stack();\n\tif (sysctl_panic_on_stackoverflow)\n\t\tpanic(\"low stack detected by irq handler - check messages\\n\");\n}\n\n#else\nstatic inline int check_stack_overflow(void) { return 0; }\nstatic inline void print_stack_overflow(void) { }\n#endif\n\nstatic void call_on_stack(void *func, void *stack)\n{\n\tasm volatile(\"xchgl\t%%ebx,%%esp\t\\n\"\n\t\t     CALL_NOSPEC\n\t\t     \"movl\t%%ebx,%%esp\t\\n\"\n\t\t     : \"=b\" (stack)\n\t\t     : \"0\" (stack),\n\t\t       [thunk_target] \"D\"(func)\n\t\t     : \"memory\", \"cc\", \"edx\", \"ecx\", \"eax\");\n}\n\nstatic inline void *current_stack(void)\n{\n\treturn (void *)(current_stack_pointer & ~(THREAD_SIZE - 1));\n}\n\nstatic inline int execute_on_irq_stack(int overflow, struct irq_desc *desc)\n{\n\tstruct irq_stack *curstk, *irqstk;\n\tu32 *isp, *prev_esp, arg1;\n\n\tcurstk = (struct irq_stack *) current_stack();\n\tirqstk = __this_cpu_read(pcpu_hot.hardirq_stack_ptr);\n\n\t \n\tif (unlikely(curstk == irqstk))\n\t\treturn 0;\n\n\tisp = (u32 *) ((char *)irqstk + sizeof(*irqstk));\n\n\t \n\tprev_esp = (u32 *)irqstk;\n\t*prev_esp = current_stack_pointer;\n\n\tif (unlikely(overflow))\n\t\tcall_on_stack(print_stack_overflow, isp);\n\n\tasm volatile(\"xchgl\t%%ebx,%%esp\t\\n\"\n\t\t     CALL_NOSPEC\n\t\t     \"movl\t%%ebx,%%esp\t\\n\"\n\t\t     : \"=a\" (arg1), \"=b\" (isp)\n\t\t     :  \"0\" (desc),   \"1\" (isp),\n\t\t\t[thunk_target] \"D\" (desc->handle_irq)\n\t\t     : \"memory\", \"cc\", \"ecx\");\n\treturn 1;\n}\n\n \nint irq_init_percpu_irqstack(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *ph, *ps;\n\n\tif (per_cpu(pcpu_hot.hardirq_stack_ptr, cpu))\n\t\treturn 0;\n\n\tph = alloc_pages_node(node, THREADINFO_GFP, THREAD_SIZE_ORDER);\n\tif (!ph)\n\t\treturn -ENOMEM;\n\tps = alloc_pages_node(node, THREADINFO_GFP, THREAD_SIZE_ORDER);\n\tif (!ps) {\n\t\t__free_pages(ph, THREAD_SIZE_ORDER);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(pcpu_hot.hardirq_stack_ptr, cpu) = page_address(ph);\n\tper_cpu(pcpu_hot.softirq_stack_ptr, cpu) = page_address(ps);\n\treturn 0;\n}\n\n#ifdef CONFIG_SOFTIRQ_ON_OWN_STACK\nvoid do_softirq_own_stack(void)\n{\n\tstruct irq_stack *irqstk;\n\tu32 *isp, *prev_esp;\n\n\tirqstk = __this_cpu_read(pcpu_hot.softirq_stack_ptr);\n\n\t \n\tisp = (u32 *) ((char *)irqstk + sizeof(*irqstk));\n\n\t \n\tprev_esp = (u32 *)irqstk;\n\t*prev_esp = current_stack_pointer;\n\n\tcall_on_stack(__do_softirq, isp);\n}\n#endif\n\nvoid __handle_irq(struct irq_desc *desc, struct pt_regs *regs)\n{\n\tint overflow = check_stack_overflow();\n\n\tif (user_mode(regs) || !execute_on_irq_stack(overflow, desc)) {\n\t\tif (unlikely(overflow))\n\t\t\tprint_stack_overflow();\n\t\tgeneric_handle_irq_desc(desc);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}