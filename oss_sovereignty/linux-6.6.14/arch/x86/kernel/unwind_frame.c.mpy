{
  "module_name": "unwind_frame.c",
  "hash_id": "f9ac84a44aed7b3e0b4f94f4533e77c386e4eaa1844083fe71133bc5e52239c2",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/unwind_frame.c",
  "human_readable_source": "\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/interrupt.h>\n#include <asm/sections.h>\n#include <asm/ptrace.h>\n#include <asm/bitops.h>\n#include <asm/stacktrace.h>\n#include <asm/unwind.h>\n\n#define FRAME_HEADER_SIZE (sizeof(long) * 2)\n\nunsigned long unwind_get_return_address(struct unwind_state *state)\n{\n\tif (unwind_done(state))\n\t\treturn 0;\n\n\treturn __kernel_text_address(state->ip) ? state->ip : 0;\n}\nEXPORT_SYMBOL_GPL(unwind_get_return_address);\n\nunsigned long *unwind_get_return_address_ptr(struct unwind_state *state)\n{\n\tif (unwind_done(state))\n\t\treturn NULL;\n\n\treturn state->regs ? &state->regs->ip : state->bp + 1;\n}\n\nstatic void unwind_dump(struct unwind_state *state)\n{\n\tstatic bool dumped_before = false;\n\tbool prev_zero, zero = false;\n\tunsigned long word, *sp;\n\tstruct stack_info stack_info = {0};\n\tunsigned long visit_mask = 0;\n\n\tif (dumped_before)\n\t\treturn;\n\n\tdumped_before = true;\n\n\tprintk_deferred(\"unwind stack type:%d next_sp:%p mask:0x%lx graph_idx:%d\\n\",\n\t\t\tstate->stack_info.type, state->stack_info.next_sp,\n\t\t\tstate->stack_mask, state->graph_idx);\n\n\tfor (sp = PTR_ALIGN(state->orig_sp, sizeof(long)); sp;\n\t     sp = PTR_ALIGN(stack_info.next_sp, sizeof(long))) {\n\t\tif (get_stack_info(sp, state->task, &stack_info, &visit_mask))\n\t\t\tbreak;\n\n\t\tfor (; sp < stack_info.end; sp++) {\n\n\t\t\tword = READ_ONCE_NOCHECK(*sp);\n\n\t\t\tprev_zero = zero;\n\t\t\tzero = word == 0;\n\n\t\t\tif (zero) {\n\t\t\t\tif (!prev_zero)\n\t\t\t\t\tprintk_deferred(\"%p: %0*x ...\\n\",\n\t\t\t\t\t\t\tsp, BITS_PER_LONG/4, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk_deferred(\"%p: %0*lx (%pB)\\n\",\n\t\t\t\t\tsp, BITS_PER_LONG/4, word, (void *)word);\n\t\t}\n\t}\n}\n\nstatic bool in_entry_code(unsigned long ip)\n{\n\tchar *addr = (char *)ip;\n\n\treturn addr >= __entry_text_start && addr < __entry_text_end;\n}\n\nstatic inline unsigned long *last_frame(struct unwind_state *state)\n{\n\treturn (unsigned long *)task_pt_regs(state->task) - 2;\n}\n\nstatic bool is_last_frame(struct unwind_state *state)\n{\n\treturn state->bp == last_frame(state);\n}\n\n#ifdef CONFIG_X86_32\n#define GCC_REALIGN_WORDS 3\n#else\n#define GCC_REALIGN_WORDS 1\n#endif\n\nstatic inline unsigned long *last_aligned_frame(struct unwind_state *state)\n{\n\treturn last_frame(state) - GCC_REALIGN_WORDS;\n}\n\nstatic bool is_last_aligned_frame(struct unwind_state *state)\n{\n\tunsigned long *last_bp = last_frame(state);\n\tunsigned long *aligned_bp = last_aligned_frame(state);\n\n\t \n\treturn (state->bp == aligned_bp && *(aligned_bp + 1) == *(last_bp + 1));\n}\n\nstatic bool is_last_ftrace_frame(struct unwind_state *state)\n{\n\tunsigned long *last_bp = last_frame(state);\n\tunsigned long *last_ftrace_bp = last_bp - 3;\n\n\t \n\treturn (state->bp == last_ftrace_bp &&\n\t\t*state->bp == *(state->bp + 2) &&\n\t\t*(state->bp + 1) == *(state->bp + 4));\n}\n\nstatic bool is_last_task_frame(struct unwind_state *state)\n{\n\treturn is_last_frame(state) || is_last_aligned_frame(state) ||\n\t       is_last_ftrace_frame(state);\n}\n\n \n#ifdef CONFIG_X86_64\nstatic struct pt_regs *decode_frame_pointer(unsigned long *bp)\n{\n\tunsigned long regs = (unsigned long)bp;\n\n\tif (!(regs & 0x1))\n\t\treturn NULL;\n\n\treturn (struct pt_regs *)(regs & ~0x1);\n}\n#else\nstatic struct pt_regs *decode_frame_pointer(unsigned long *bp)\n{\n\tunsigned long regs = (unsigned long)bp;\n\n\tif (regs & 0x80000000)\n\t\treturn NULL;\n\n\treturn (struct pt_regs *)(regs | 0x80000000);\n}\n#endif\n\n \n__no_kmsan_checks\nstatic bool update_stack_state(struct unwind_state *state,\n\t\t\t       unsigned long *next_bp)\n{\n\tstruct stack_info *info = &state->stack_info;\n\tenum stack_type prev_type = info->type;\n\tstruct pt_regs *regs;\n\tunsigned long *frame, *prev_frame_end, *addr_p, addr;\n\tsize_t len;\n\n\tif (state->regs)\n\t\tprev_frame_end = (void *)state->regs + sizeof(*state->regs);\n\telse\n\t\tprev_frame_end = (void *)state->bp + FRAME_HEADER_SIZE;\n\n\t \n\tregs = decode_frame_pointer(next_bp);\n\tif (regs) {\n\t\tframe = (unsigned long *)regs;\n\t\tlen = sizeof(*regs);\n\t\tstate->got_irq = true;\n\t} else {\n\t\tframe = next_bp;\n\t\tlen = FRAME_HEADER_SIZE;\n\t}\n\n\t \n\twhile (!on_stack(info, frame, len))\n\t\tif (get_stack_info(info->next_sp, state->task, info,\n\t\t\t\t   &state->stack_mask))\n\t\t\treturn false;\n\n\t \n\tif (state->orig_sp && state->stack_info.type == prev_type &&\n\t    frame < prev_frame_end)\n\t\treturn false;\n\n\t \n\tif (regs) {\n\t\tstate->regs = regs;\n\t\tstate->bp = NULL;\n\t} else {\n\t\tstate->bp = next_bp;\n\t\tstate->regs = NULL;\n\t}\n\n\t \n\tif (state->regs && user_mode(state->regs))\n\t\tstate->ip = 0;\n\telse {\n\t\taddr_p = unwind_get_return_address_ptr(state);\n\t\taddr = READ_ONCE_TASK_STACK(state->task, *addr_p);\n\t\tstate->ip = unwind_recover_ret_addr(state, addr, addr_p);\n\t}\n\n\t \n\tif (!state->orig_sp)\n\t\tstate->orig_sp = frame;\n\n\treturn true;\n}\n\n__no_kmsan_checks\nbool unwind_next_frame(struct unwind_state *state)\n{\n\tstruct pt_regs *regs;\n\tunsigned long *next_bp;\n\n\tif (unwind_done(state))\n\t\treturn false;\n\n\t \n\tif (state->regs && user_mode(state->regs))\n\t\tgoto the_end;\n\n\tif (is_last_task_frame(state)) {\n\t\tregs = task_pt_regs(state->task);\n\n\t\t \n\t\tif (!user_mode(regs))\n\t\t\tgoto the_end;\n\n\t\t \n\t\tstate->regs = regs;\n\t\tstate->bp = NULL;\n\t\tstate->ip = 0;\n\t\treturn true;\n\t}\n\n\t \n\tif (state->next_bp) {\n\t\tnext_bp = state->next_bp;\n\t\tstate->next_bp = NULL;\n\t} else if (state->regs) {\n\t\tnext_bp = (unsigned long *)state->regs->bp;\n\t} else {\n\t\tnext_bp = (unsigned long *)READ_ONCE_TASK_STACK(state->task, *state->bp);\n\t}\n\n\t \n\tif (!update_stack_state(state, next_bp))\n\t\tgoto bad_address;\n\n\treturn true;\n\nbad_address:\n\tstate->error = true;\n\n\t \n\tif (state->task != current)\n\t\tgoto the_end;\n\n\t \n\tif (state->got_irq && in_entry_code(state->ip))\n\t\tgoto the_end;\n\tif (state->regs &&\n\t    state->regs->sp >= (unsigned long)last_aligned_frame(state) &&\n\t    state->regs->sp < (unsigned long)task_pt_regs(state->task))\n\t\tgoto the_end;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\tgoto the_end;\n\n\tif (state->task != current)\n\t\tgoto the_end;\n\n\tif (state->regs) {\n\t\tprintk_deferred_once(KERN_WARNING\n\t\t\t\"WARNING: kernel stack regs at %p in %s:%d has bad 'bp' value %p\\n\",\n\t\t\tstate->regs, state->task->comm,\n\t\t\tstate->task->pid, next_bp);\n\t\tunwind_dump(state);\n\t} else {\n\t\tprintk_deferred_once(KERN_WARNING\n\t\t\t\"WARNING: kernel stack frame pointer at %p in %s:%d has bad value %p\\n\",\n\t\t\tstate->bp, state->task->comm,\n\t\t\tstate->task->pid, next_bp);\n\t\tunwind_dump(state);\n\t}\nthe_end:\n\tstate->stack_info.type = STACK_TYPE_UNKNOWN;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(unwind_next_frame);\n\nvoid __unwind_start(struct unwind_state *state, struct task_struct *task,\n\t\t    struct pt_regs *regs, unsigned long *first_frame)\n{\n\tunsigned long *bp;\n\n\tmemset(state, 0, sizeof(*state));\n\tstate->task = task;\n\tstate->got_irq = (regs);\n\n\t \n\tif (regs && user_mode(regs)) {\n\t\tstate->stack_info.type = STACK_TYPE_UNKNOWN;\n\t\treturn;\n\t}\n\n\tbp = get_frame_pointer(task, regs);\n\n\t \n\tif (regs && regs->ip == 0 && (unsigned long *)regs->sp >= first_frame) {\n\t\tstate->next_bp = bp;\n\t\tbp = ((unsigned long *)regs->sp) - 1;\n\t}\n\n\t \n\tget_stack_info(bp, state->task, &state->stack_info,\n\t\t       &state->stack_mask);\n\tupdate_stack_state(state, bp);\n\n\t \n\twhile (!unwind_done(state) &&\n\t       (!on_stack(&state->stack_info, first_frame, sizeof(long)) ||\n\t\t\t(state->next_bp == NULL && state->bp < first_frame)))\n\t\tunwind_next_frame(state);\n}\nEXPORT_SYMBOL_GPL(__unwind_start);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}