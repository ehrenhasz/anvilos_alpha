{
  "module_name": "boot.c",
  "hash_id": "6a964918cdd4583cc1388481fe6dcc0d4425b485e8582cde597ad6013e39a3d4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/acpi/boot.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/acpi_pmtmr.h>\n#include <linux/efi.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/dmi.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/efi-bgrt.h>\n#include <linux/serial_core.h>\n#include <linux/pgtable.h>\n\n#include <asm/e820/api.h>\n#include <asm/irqdomain.h>\n#include <asm/pci_x86.h>\n#include <asm/io_apic.h>\n#include <asm/apic.h>\n#include <asm/io.h>\n#include <asm/mpspec.h>\n#include <asm/smp.h>\n#include <asm/i8259.h>\n#include <asm/setup.h>\n\n#include \"sleep.h\"  \nstatic int __initdata acpi_force = 0;\nint acpi_disabled;\nEXPORT_SYMBOL(acpi_disabled);\n\n#ifdef\tCONFIG_X86_64\n# include <asm/proto.h>\n#endif\t\t\t\t \n\nint acpi_noirq;\t\t\t\t \nstatic int acpi_nobgrt;\t\t\t \nint acpi_pci_disabled;\t\t \nEXPORT_SYMBOL(acpi_pci_disabled);\n\nint acpi_lapic;\nint acpi_ioapic;\nint acpi_strict;\nint acpi_disable_cmcff;\nbool acpi_int_src_ovr[NR_IRQS_LEGACY];\n\n \nu8 acpi_sci_flags __initdata;\nu32 acpi_sci_override_gsi __initdata = INVALID_ACPI_IRQ;\nint acpi_skip_timer_override __initdata;\nint acpi_use_timer_override __initdata;\nint acpi_fix_pin2_polarity __initdata;\n\n#ifdef CONFIG_X86_LOCAL_APIC\nstatic u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;\nstatic bool acpi_support_online_capable;\n#endif\n\n#ifdef CONFIG_X86_64\n \nstatic u64 acpi_mp_wake_mailbox_paddr;\n \nstatic struct acpi_madt_multiproc_wakeup_mailbox *acpi_mp_wake_mailbox;\n#endif\n\n#ifdef CONFIG_X86_IO_APIC\n \nstatic DEFINE_MUTEX(acpi_ioapic_lock);\n#endif\n\n \n\n \nenum acpi_irq_model_id acpi_irq_model = ACPI_IRQ_MODEL_PIC;\n\n\n \nstatic u32 isa_irq_to_gsi[NR_IRQS_LEGACY] __read_mostly = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n};\n\n \nvoid __init __iomem *__acpi_map_table(unsigned long phys, unsigned long size)\n{\n\n\tif (!phys || !size)\n\t\treturn NULL;\n\n\treturn early_memremap(phys, size);\n}\n\nvoid __init __acpi_unmap_table(void __iomem *map, unsigned long size)\n{\n\tif (!map || !size)\n\t\treturn;\n\n\tearly_memunmap(map, size);\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\nstatic int __init acpi_parse_madt(struct acpi_table_header *table)\n{\n\tstruct acpi_table_madt *madt = NULL;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn -EINVAL;\n\n\tmadt = (struct acpi_table_madt *)table;\n\tif (!madt) {\n\t\tpr_warn(\"Unable to map MADT\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (madt->address) {\n\t\tacpi_lapic_addr = (u64) madt->address;\n\n\t\tpr_debug(\"Local APIC address 0x%08x\\n\", madt->address);\n\t}\n\n\tif (madt->flags & ACPI_MADT_PCAT_COMPAT)\n\t\tlegacy_pic_pcat_compat();\n\n\t \n\tif (acpi_gbl_FADT.header.revision > 6 ||\n\t    (acpi_gbl_FADT.header.revision == 6 &&\n\t     acpi_gbl_FADT.minor_revision >= 3))\n\t\tacpi_support_online_capable = true;\n\n\tdefault_acpi_madt_oem_check(madt->header.oem_id,\n\t\t\t\t    madt->header.oem_table_id);\n\n\treturn 0;\n}\n\n \nstatic int acpi_register_lapic(int id, u32 acpiid, u8 enabled)\n{\n\tint cpu;\n\n\tif (id >= MAX_LOCAL_APIC) {\n\t\tpr_info(\"skipped apicid that is too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!enabled) {\n\t\t++disabled_cpus;\n\t\treturn -EINVAL;\n\t}\n\n\tcpu = generic_processor_info(id);\n\tif (cpu >= 0)\n\t\tearly_per_cpu(x86_cpu_to_acpiid, cpu) = acpiid;\n\n\treturn cpu;\n}\n\nstatic bool __init acpi_is_processor_usable(u32 lapic_flags)\n{\n\tif (lapic_flags & ACPI_MADT_ENABLED)\n\t\treturn true;\n\n\tif (!acpi_support_online_capable ||\n\t    (lapic_flags & ACPI_MADT_ONLINE_CAPABLE))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __init\nacpi_parse_x2apic(union acpi_subtable_headers *header, const unsigned long end)\n{\n\tstruct acpi_madt_local_x2apic *processor = NULL;\n#ifdef CONFIG_X86_X2APIC\n\tu32 apic_id;\n\tu8 enabled;\n#endif\n\n\tprocessor = (struct acpi_madt_local_x2apic *)header;\n\n\tif (BAD_MADT_ENTRY(processor, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n#ifdef CONFIG_X86_X2APIC\n\tapic_id = processor->local_apic_id;\n\tenabled = processor->lapic_flags & ACPI_MADT_ENABLED;\n\n\t \n\tif (apic_id == 0xffffffff)\n\t\treturn 0;\n\n\t \n\tif (!acpi_is_processor_usable(processor->lapic_flags))\n\t\treturn 0;\n\n\t \n\tif (!apic_id_valid(apic_id)) {\n\t\tif (enabled)\n\t\t\tpr_warn(\"x2apic entry ignored\\n\");\n\t\treturn 0;\n\t}\n\n\tacpi_register_lapic(apic_id, processor->uid, enabled);\n#else\n\tpr_warn(\"x2apic entry ignored\\n\");\n#endif\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_lapic(union acpi_subtable_headers * header, const unsigned long end)\n{\n\tstruct acpi_madt_local_apic *processor = NULL;\n\n\tprocessor = (struct acpi_madt_local_apic *)header;\n\n\tif (BAD_MADT_ENTRY(processor, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\t \n\tif (processor->id == 0xff)\n\t\treturn 0;\n\n\t \n\tif (!acpi_is_processor_usable(processor->lapic_flags))\n\t\treturn 0;\n\n\t \n\tacpi_register_lapic(processor->id,\t \n\t\t\t    processor->processor_id,  \n\t\t\t    processor->lapic_flags & ACPI_MADT_ENABLED);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_sapic(union acpi_subtable_headers *header, const unsigned long end)\n{\n\tstruct acpi_madt_local_sapic *processor = NULL;\n\n\tprocessor = (struct acpi_madt_local_sapic *)header;\n\n\tif (BAD_MADT_ENTRY(processor, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tacpi_register_lapic((processor->id << 8) | processor->eid, \n\t\t\t    processor->processor_id,  \n\t\t\t    processor->lapic_flags & ACPI_MADT_ENABLED);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_lapic_addr_ovr(union acpi_subtable_headers * header,\n\t\t\t  const unsigned long end)\n{\n\tstruct acpi_madt_local_apic_override *lapic_addr_ovr = NULL;\n\n\tlapic_addr_ovr = (struct acpi_madt_local_apic_override *)header;\n\n\tif (BAD_MADT_ENTRY(lapic_addr_ovr, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tacpi_lapic_addr = lapic_addr_ovr->address;\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_x2apic_nmi(union acpi_subtable_headers *header,\n\t\t      const unsigned long end)\n{\n\tstruct acpi_madt_local_x2apic_nmi *x2apic_nmi = NULL;\n\n\tx2apic_nmi = (struct acpi_madt_local_x2apic_nmi *)header;\n\n\tif (BAD_MADT_ENTRY(x2apic_nmi, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tif (x2apic_nmi->lint != 1)\n\t\tpr_warn(\"NMI not connected to LINT 1!\\n\");\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_lapic_nmi(union acpi_subtable_headers * header, const unsigned long end)\n{\n\tstruct acpi_madt_local_apic_nmi *lapic_nmi = NULL;\n\n\tlapic_nmi = (struct acpi_madt_local_apic_nmi *)header;\n\n\tif (BAD_MADT_ENTRY(lapic_nmi, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tif (lapic_nmi->lint != 1)\n\t\tpr_warn(\"NMI not connected to LINT 1!\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\nstatic int acpi_wakeup_cpu(int apicid, unsigned long start_ip)\n{\n\t \n\tif (!acpi_mp_wake_mailbox) {\n\t\tacpi_mp_wake_mailbox = memremap(acpi_mp_wake_mailbox_paddr,\n\t\t\t\t\t\tsizeof(*acpi_mp_wake_mailbox),\n\t\t\t\t\t\tMEMREMAP_WB);\n\t}\n\n\t \n\tacpi_mp_wake_mailbox->apic_id\t    = apicid;\n\tacpi_mp_wake_mailbox->wakeup_vector = start_ip;\n\tsmp_store_release(&acpi_mp_wake_mailbox->command,\n\t\t\t  ACPI_MP_WAKE_COMMAND_WAKEUP);\n\n\t \n\twhile (READ_ONCE(acpi_mp_wake_mailbox->command))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n#endif  \n#endif  \n\n#ifdef CONFIG_X86_IO_APIC\n#define MP_ISA_BUS\t\t0\n\nstatic int __init mp_register_ioapic_irq(u8 bus_irq, u8 polarity,\n\t\t\t\t\t\tu8 trigger, u32 gsi);\n\nstatic void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\t \n\tif (bus_irq >= NR_IRQS_LEGACY) {\n\t\tpr_warn(\"Invalid bus_irq %u for legacy override\\n\", bus_irq);\n\t\treturn;\n\t}\n\n\t \n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\n\tif (mp_register_ioapic_irq(bus_irq, polarity, trigger, gsi) < 0)\n\t\treturn;\n\t \n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = INVALID_ACPI_IRQ;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}\n\nstatic void mp_config_acpi_gsi(struct device *dev, u32 gsi, int trigger,\n\t\t\tint polarity)\n{\n#ifdef CONFIG_X86_MPPARSE\n\tstruct mpc_intsrc mp_irq;\n\tstruct pci_dev *pdev;\n\tunsigned char number;\n\tunsigned int devfn;\n\tint ioapic;\n\tu8 pin;\n\n\tif (!acpi_ioapic)\n\t\treturn;\n\tif (!dev || !dev_is_pci(dev))\n\t\treturn;\n\n\tpdev = to_pci_dev(dev);\n\tnumber = pdev->bus->number;\n\tdevfn = pdev->devfn;\n\tpin = pdev->pin;\n\t \n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger == ACPI_EDGE_SENSITIVE ? 4 : 0x0c) |\n\t\t\t\t(polarity == ACPI_ACTIVE_HIGH ? 1 : 3);\n\tmp_irq.srcbus = number;\n\tmp_irq.srcbusirq = (((devfn >> 3) & 0x1f) << 2) | ((pin - 1) & 3);\n\tioapic = mp_find_ioapic(gsi);\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic);\n\tmp_irq.dstirq = mp_find_ioapic_pin(ioapic, gsi);\n\n\tmp_save_irq(&mp_irq);\n#endif\n}\n\nstatic int __init mp_register_ioapic_irq(u8 bus_irq, u8 polarity,\n\t\t\t\t\t\tu8 trigger, u32 gsi)\n{\n\tstruct mpc_intsrc mp_irq;\n\tint ioapic, pin;\n\n\t \n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0) {\n\t\tpr_warn(\"Failed to find ioapic for gsi : %u\\n\", gsi);\n\t\treturn ioapic;\n\t}\n\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic);\n\tmp_irq.dstirq = pin;\n\n\tmp_save_irq(&mp_irq);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_ioapic(union acpi_subtable_headers * header, const unsigned long end)\n{\n\tstruct acpi_madt_io_apic *ioapic = NULL;\n\tstruct ioapic_domain_cfg cfg = {\n\t\t.type = IOAPIC_DOMAIN_DYNAMIC,\n\t\t.ops = &mp_ioapic_irqdomain_ops,\n\t};\n\n\tioapic = (struct acpi_madt_io_apic *)header;\n\n\tif (BAD_MADT_ENTRY(ioapic, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\t \n\tif (ioapic->global_irq_base < nr_legacy_irqs())\n\t\tcfg.type = IOAPIC_DOMAIN_LEGACY;\n\n\tmp_register_ioapic(ioapic->id, ioapic->address, ioapic->global_irq_base,\n\t\t\t   &cfg);\n\n\treturn 0;\n}\n\n \nstatic void __init acpi_sci_ioapic_setup(u8 bus_irq, u16 polarity, u16 trigger, u32 gsi)\n{\n\tif (trigger == 0)\t \n\t\ttrigger = 3;\n\n\tif (polarity == 0)\t \n\t\tpolarity = 3;\n\n\t \n\tif (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK)\n\t\ttrigger = (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK) >> 2;\n\n\tif (acpi_sci_flags & ACPI_MADT_POLARITY_MASK)\n\t\tpolarity = acpi_sci_flags & ACPI_MADT_POLARITY_MASK;\n\n\tif (bus_irq < NR_IRQS_LEGACY)\n\t\tmp_override_legacy_irq(bus_irq, polarity, trigger, gsi);\n\telse\n\t\tmp_register_ioapic_irq(bus_irq, polarity, trigger, gsi);\n\n\tacpi_penalize_sci_irq(bus_irq, trigger, polarity);\n\n\t \n\tacpi_sci_override_gsi = gsi;\n\treturn;\n}\n\nstatic int __init\nacpi_parse_int_src_ovr(union acpi_subtable_headers * header,\n\t\t       const unsigned long end)\n{\n\tstruct acpi_madt_interrupt_override *intsrc = NULL;\n\n\tintsrc = (struct acpi_madt_interrupt_override *)header;\n\n\tif (BAD_MADT_ENTRY(intsrc, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tif (intsrc->source_irq < NR_IRQS_LEGACY)\n\t\tacpi_int_src_ovr[intsrc->source_irq] = true;\n\n\tif (intsrc->source_irq == acpi_gbl_FADT.sci_interrupt) {\n\t\tacpi_sci_ioapic_setup(intsrc->source_irq,\n\t\t\t\t      intsrc->inti_flags & ACPI_MADT_POLARITY_MASK,\n\t\t\t\t      (intsrc->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2,\n\t\t\t\t      intsrc->global_irq);\n\t\treturn 0;\n\t}\n\n\tif (intsrc->source_irq == 0) {\n\t\tif (acpi_skip_timer_override) {\n\t\t\tpr_warn(\"BIOS IRQ0 override ignored.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((intsrc->global_irq == 2) && acpi_fix_pin2_polarity\n\t\t\t&& (intsrc->inti_flags & ACPI_MADT_POLARITY_MASK)) {\n\t\t\tintsrc->inti_flags &= ~ACPI_MADT_POLARITY_MASK;\n\t\t\tpr_warn(\"BIOS IRQ0 pin2 override: forcing polarity to high active.\\n\");\n\t\t}\n\t}\n\n\tmp_override_legacy_irq(intsrc->source_irq,\n\t\t\t\tintsrc->inti_flags & ACPI_MADT_POLARITY_MASK,\n\t\t\t\t(intsrc->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2,\n\t\t\t\tintsrc->global_irq);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_nmi_src(union acpi_subtable_headers * header, const unsigned long end)\n{\n\tstruct acpi_madt_nmi_source *nmi_src = NULL;\n\n\tnmi_src = (struct acpi_madt_nmi_source *)header;\n\n\tif (BAD_MADT_ENTRY(nmi_src, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\t \n\n\treturn 0;\n}\n\n#endif\t\t\t\t \n\n \n\nvoid __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger)\n{\n\tunsigned int mask = 1 << irq;\n\tunsigned int old, new;\n\n\t \n\told = inb(PIC_ELCR1) | (inb(PIC_ELCR2) << 8);\n\n\t \n\tnew = acpi_noirq ? old : 0;\n\n\t \n\tswitch (trigger) {\n\tcase 1:\t\t \n\t\tnew &= ~mask;\n\t\tbreak;\n\tcase 3:\t\t \n\t\tnew |= mask;\n\t\tbreak;\n\t}\n\n\tif (old == new)\n\t\treturn;\n\n\tpr_warn(\"setting ELCR to %04x (from %04x)\\n\", new, old);\n\toutb(new, PIC_ELCR1);\n\toutb(new >> 8, PIC_ELCR2);\n}\n\nint acpi_gsi_to_irq(u32 gsi, unsigned int *irqp)\n{\n\tint rc, irq, trigger, polarity;\n\n\tif (acpi_irq_model == ACPI_IRQ_MODEL_PIC) {\n\t\t*irqp = gsi;\n\t\treturn 0;\n\t}\n\n\trc = acpi_get_override_irq(gsi, &trigger, &polarity);\n\tif (rc)\n\t\treturn rc;\n\n\ttrigger = trigger ? ACPI_LEVEL_SENSITIVE : ACPI_EDGE_SENSITIVE;\n\tpolarity = polarity ? ACPI_ACTIVE_LOW : ACPI_ACTIVE_HIGH;\n\tirq = acpi_register_gsi(NULL, gsi, trigger, polarity);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t*irqp = irq;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_gsi_to_irq);\n\nint acpi_isa_irq_to_gsi(unsigned isa_irq, u32 *gsi)\n{\n\tif (isa_irq < nr_legacy_irqs() &&\n\t    isa_irq_to_gsi[isa_irq] != INVALID_ACPI_IRQ) {\n\t\t*gsi = isa_irq_to_gsi[isa_irq];\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int acpi_register_gsi_pic(struct device *dev, u32 gsi,\n\t\t\t\t int trigger, int polarity)\n{\n#ifdef CONFIG_PCI\n\t \n\tif (trigger == ACPI_LEVEL_SENSITIVE)\n\t\telcr_set_level_irq(gsi);\n#endif\n\n\treturn gsi;\n}\n\n#ifdef CONFIG_X86_LOCAL_APIC\nstatic int acpi_register_gsi_ioapic(struct device *dev, u32 gsi,\n\t\t\t\t    int trigger, int polarity)\n{\n\tint irq = gsi;\n#ifdef CONFIG_X86_IO_APIC\n\tint node;\n\tstruct irq_alloc_info info;\n\n\tnode = dev ? dev_to_node(dev) : NUMA_NO_NODE;\n\ttrigger = trigger == ACPI_EDGE_SENSITIVE ? 0 : 1;\n\tpolarity = polarity == ACPI_ACTIVE_HIGH ? 0 : 1;\n\tioapic_set_alloc_attr(&info, node, trigger, polarity);\n\n\tmutex_lock(&acpi_ioapic_lock);\n\tirq = mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &info);\n\t \n\tif (irq >= 0 && enable_update_mptable && gsi != acpi_gbl_FADT.sci_interrupt)\n\t\tmp_config_acpi_gsi(dev, gsi, trigger, polarity);\n\tmutex_unlock(&acpi_ioapic_lock);\n#endif\n\n\treturn irq;\n}\n\nstatic void acpi_unregister_gsi_ioapic(u32 gsi)\n{\n#ifdef CONFIG_X86_IO_APIC\n\tint irq;\n\n\tmutex_lock(&acpi_ioapic_lock);\n\tirq = mp_map_gsi_to_irq(gsi, 0, NULL);\n\tif (irq > 0)\n\t\tmp_unmap_irq(irq);\n\tmutex_unlock(&acpi_ioapic_lock);\n#endif\n}\n#endif\n\nint (*__acpi_register_gsi)(struct device *dev, u32 gsi,\n\t\t\t   int trigger, int polarity) = acpi_register_gsi_pic;\nvoid (*__acpi_unregister_gsi)(u32 gsi) = NULL;\n\n#ifdef CONFIG_ACPI_SLEEP\nint (*acpi_suspend_lowlevel)(void) = x86_acpi_suspend_lowlevel;\n#else\nint (*acpi_suspend_lowlevel)(void);\n#endif\n\n \nint acpi_register_gsi(struct device *dev, u32 gsi, int trigger, int polarity)\n{\n\treturn __acpi_register_gsi(dev, gsi, trigger, polarity);\n}\nEXPORT_SYMBOL_GPL(acpi_register_gsi);\n\nvoid acpi_unregister_gsi(u32 gsi)\n{\n\tif (__acpi_unregister_gsi)\n\t\t__acpi_unregister_gsi(gsi);\n}\nEXPORT_SYMBOL_GPL(acpi_unregister_gsi);\n\n#ifdef CONFIG_X86_LOCAL_APIC\nstatic void __init acpi_set_irq_model_ioapic(void)\n{\n\tacpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;\n\t__acpi_register_gsi = acpi_register_gsi_ioapic;\n\t__acpi_unregister_gsi = acpi_unregister_gsi_ioapic;\n\tacpi_ioapic = 1;\n}\n#endif\n\n \n#ifdef CONFIG_ACPI_HOTPLUG_CPU\n#include <acpi/processor.h>\n\nstatic int acpi_map_cpu2node(acpi_handle handle, int cpu, int physid)\n{\n#ifdef CONFIG_ACPI_NUMA\n\tint nid;\n\n\tnid = acpi_get_node(handle);\n\tif (nid != NUMA_NO_NODE) {\n\t\tset_apicid_to_node(physid, nid);\n\t\tnuma_set_node(cpu, nid);\n\t}\n#endif\n\treturn 0;\n}\n\nint acpi_map_cpu(acpi_handle handle, phys_cpuid_t physid, u32 acpi_id,\n\t\t int *pcpu)\n{\n\tint cpu;\n\n\tcpu = acpi_register_lapic(physid, acpi_id, ACPI_MADT_ENABLED);\n\tif (cpu < 0) {\n\t\tpr_info(\"Unable to map lapic to logical cpu number\\n\");\n\t\treturn cpu;\n\t}\n\n\tacpi_processor_set_pdc(handle);\n\tacpi_map_cpu2node(handle, cpu, physid);\n\n\t*pcpu = cpu;\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_map_cpu);\n\nint acpi_unmap_cpu(int cpu)\n{\n#ifdef CONFIG_ACPI_NUMA\n\tset_apicid_to_node(per_cpu(x86_cpu_to_apicid, cpu), NUMA_NO_NODE);\n#endif\n\n\tper_cpu(x86_cpu_to_apicid, cpu) = -1;\n\tset_cpu_present(cpu, false);\n\tnum_processors--;\n\n\treturn (0);\n}\nEXPORT_SYMBOL(acpi_unmap_cpu);\n#endif\t\t\t\t \n\nint acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)\n{\n\tint ret = -ENOSYS;\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\n\tint ioapic_id;\n\tu64 addr;\n\tstruct ioapic_domain_cfg cfg = {\n\t\t.type = IOAPIC_DOMAIN_DYNAMIC,\n\t\t.ops = &mp_ioapic_irqdomain_ops,\n\t};\n\n\tioapic_id = acpi_get_ioapic_id(handle, gsi_base, &addr);\n\tif (ioapic_id < 0) {\n\t\tunsigned long long uid;\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__UID,\n\t\t\t\t\t       NULL, &uid);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_warn(handle, \"failed to get IOAPIC ID.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tioapic_id = (int)uid;\n\t}\n\n\tmutex_lock(&acpi_ioapic_lock);\n\tret  = mp_register_ioapic(ioapic_id, phys_addr, gsi_base, &cfg);\n\tmutex_unlock(&acpi_ioapic_lock);\n#endif\n\n\treturn ret;\n}\nEXPORT_SYMBOL(acpi_register_ioapic);\n\nint acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base)\n{\n\tint ret = -ENOSYS;\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\n\tmutex_lock(&acpi_ioapic_lock);\n\tret  = mp_unregister_ioapic(gsi_base);\n\tmutex_unlock(&acpi_ioapic_lock);\n#endif\n\n\treturn ret;\n}\nEXPORT_SYMBOL(acpi_unregister_ioapic);\n\n \nint acpi_ioapic_registered(acpi_handle handle, u32 gsi_base)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\n\tmutex_lock(&acpi_ioapic_lock);\n\tret  = mp_ioapic_registered(gsi_base);\n\tmutex_unlock(&acpi_ioapic_lock);\n#endif\n\n\treturn ret;\n}\n\nstatic int __init acpi_parse_sbf(struct acpi_table_header *table)\n{\n\tstruct acpi_table_boot *sb = (struct acpi_table_boot *)table;\n\n\tsbf_port = sb->cmos_index;\t \n\n\treturn 0;\n}\n\n#ifdef CONFIG_HPET_TIMER\n#include <asm/hpet.h>\n\nstatic struct resource *hpet_res __initdata;\n\nstatic int __init acpi_parse_hpet(struct acpi_table_header *table)\n{\n\tstruct acpi_table_hpet *hpet_tbl = (struct acpi_table_hpet *)table;\n\n\tif (hpet_tbl->address.space_id != ACPI_SPACE_MEM) {\n\t\tpr_warn(\"HPET timers must be located in memory.\\n\");\n\t\treturn -1;\n\t}\n\n\thpet_address = hpet_tbl->address.address;\n\thpet_blockid = hpet_tbl->sequence;\n\n\t \n\tif (!hpet_address) {\n\t\tpr_warn(\"HPET id: %#x base: %#lx is invalid\\n\", hpet_tbl->id, hpet_address);\n\t\treturn 0;\n\t}\n#ifdef CONFIG_X86_64\n\t \n\tif (hpet_address == 0xfed0000000000000UL) {\n\t\tif (!hpet_force_user) {\n\t\t\tpr_warn(\"HPET id: %#x base: 0xfed0000000000000 is bogus, try hpet=force on the kernel command line to fix it up to 0xfed00000.\\n\",\n\t\t\t\thpet_tbl->id);\n\t\t\thpet_address = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn(\"HPET id: %#x base: 0xfed0000000000000 fixed up to 0xfed00000.\\n\",\n\t\t\thpet_tbl->id);\n\t\thpet_address >>= 32;\n\t}\n#endif\n\tpr_info(\"HPET id: %#x base: %#lx\\n\", hpet_tbl->id, hpet_address);\n\n\t \n#define HPET_RESOURCE_NAME_SIZE 9\n\thpet_res = memblock_alloc(sizeof(*hpet_res) + HPET_RESOURCE_NAME_SIZE,\n\t\t\t\t  SMP_CACHE_BYTES);\n\tif (!hpet_res)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(*hpet_res) + HPET_RESOURCE_NAME_SIZE);\n\n\thpet_res->name = (void *)&hpet_res[1];\n\thpet_res->flags = IORESOURCE_MEM;\n\tsnprintf((char *)hpet_res->name, HPET_RESOURCE_NAME_SIZE, \"HPET %u\",\n\t\t hpet_tbl->sequence);\n\n\thpet_res->start = hpet_address;\n\thpet_res->end = hpet_address + (1 * 1024) - 1;\n\n\treturn 0;\n}\n\n \nstatic __init int hpet_insert_resource(void)\n{\n\tif (!hpet_res)\n\t\treturn 1;\n\n\treturn insert_resource(&iomem_resource, hpet_res);\n}\n\nlate_initcall(hpet_insert_resource);\n\n#else\n#define\tacpi_parse_hpet\tNULL\n#endif\n\nstatic int __init acpi_parse_fadt(struct acpi_table_header *table)\n{\n\tif (!(acpi_gbl_FADT.boot_flags & ACPI_FADT_LEGACY_DEVICES)) {\n\t\tpr_debug(\"no legacy devices present\\n\");\n\t\tx86_platform.legacy.devices.pnpbios = 0;\n\t}\n\n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&\n\t    !(acpi_gbl_FADT.boot_flags & ACPI_FADT_8042) &&\n\t    x86_platform.legacy.i8042 != X86_LEGACY_I8042_PLATFORM_ABSENT) {\n\t\tpr_debug(\"i8042 controller is absent\\n\");\n\t\tx86_platform.legacy.i8042 = X86_LEGACY_I8042_FIRMWARE_ABSENT;\n\t}\n\n\tif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_CMOS_RTC) {\n\t\tpr_debug(\"not registering RTC platform device\\n\");\n\t\tx86_platform.legacy.rtc = 0;\n\t}\n\n\tif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_VGA) {\n\t\tpr_debug(\"probing for VGA not safe\\n\");\n\t\tx86_platform.legacy.no_vga = 1;\n\t}\n\n#ifdef CONFIG_X86_PM_TIMER\n\t \n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID) {\n\t\t \n\t\tif (acpi_gbl_FADT.xpm_timer_block.space_id !=\n\t\t    ACPI_ADR_SPACE_SYSTEM_IO)\n\t\t\treturn 0;\n\n\t\tpmtmr_ioport = acpi_gbl_FADT.xpm_timer_block.address;\n\t\t \n\t\tif (!pmtmr_ioport)\n\t\t\tpmtmr_ioport = acpi_gbl_FADT.pm_timer_block;\n\t} else {\n\t\t \n\t\tpmtmr_ioport = acpi_gbl_FADT.pm_timer_block;\n\t}\n\tif (pmtmr_ioport)\n\t\tpr_info(\"PM-Timer IO Port: %#x\\n\", pmtmr_ioport);\n#endif\n\treturn 0;\n}\n\n#ifdef\tCONFIG_X86_LOCAL_APIC\n \n\nstatic int __init early_acpi_parse_madt_lapic_addr_ovr(void)\n{\n\tint count;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn -ENODEV;\n\n\t \n\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE,\n\t\t\t\t      acpi_parse_lapic_addr_ovr, 0);\n\tif (count < 0) {\n\t\tpr_err(\"Error parsing LAPIC address override entry\\n\");\n\t\treturn count;\n\t}\n\n\tregister_lapic_address(acpi_lapic_addr);\n\n\treturn count;\n}\n\nstatic int __init acpi_parse_madt_lapic_entries(void)\n{\n\tint count;\n\tint x2count = 0;\n\tint ret;\n\tstruct acpi_subtable_proc madt_proc[2];\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn -ENODEV;\n\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_SAPIC,\n\t\t\t\t      acpi_parse_sapic, MAX_LOCAL_APIC);\n\n\tif (!count) {\n\t\tmemset(madt_proc, 0, sizeof(madt_proc));\n\t\tmadt_proc[0].id = ACPI_MADT_TYPE_LOCAL_APIC;\n\t\tmadt_proc[0].handler = acpi_parse_lapic;\n\t\tmadt_proc[1].id = ACPI_MADT_TYPE_LOCAL_X2APIC;\n\t\tmadt_proc[1].handler = acpi_parse_x2apic;\n\t\tret = acpi_table_parse_entries_array(ACPI_SIG_MADT,\n\t\t\t\tsizeof(struct acpi_table_madt),\n\t\t\t\tmadt_proc, ARRAY_SIZE(madt_proc), MAX_LOCAL_APIC);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Error parsing LAPIC/X2APIC entries\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tcount = madt_proc[0].count;\n\t\tx2count = madt_proc[1].count;\n\t}\n\tif (!count && !x2count) {\n\t\tpr_err(\"No LAPIC entries present\\n\");\n\t\t \n\t\treturn -ENODEV;\n\t} else if (count < 0 || x2count < 0) {\n\t\tpr_err(\"Error parsing LAPIC entry\\n\");\n\t\t \n\t\treturn count;\n\t}\n\n\tx2count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_X2APIC_NMI,\n\t\t\t\t\tacpi_parse_x2apic_nmi, 0);\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_NMI,\n\t\t\t\t      acpi_parse_lapic_nmi, 0);\n\tif (count < 0 || x2count < 0) {\n\t\tpr_err(\"Error parsing LAPIC NMI entry\\n\");\n\t\t \n\t\treturn count;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\nstatic int __init acpi_parse_mp_wake(union acpi_subtable_headers *header,\n\t\t\t\t     const unsigned long end)\n{\n\tstruct acpi_madt_multiproc_wakeup *mp_wake;\n\n\tif (!IS_ENABLED(CONFIG_SMP))\n\t\treturn -ENODEV;\n\n\tmp_wake = (struct acpi_madt_multiproc_wakeup *)header;\n\tif (BAD_MADT_ENTRY(mp_wake, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(&header->common);\n\n\tacpi_mp_wake_mailbox_paddr = mp_wake->base_address;\n\n\tapic_update_callback(wakeup_secondary_cpu_64, acpi_wakeup_cpu);\n\n\treturn 0;\n}\n#endif\t\t\t\t \n#endif\t\t\t\t \n\n#ifdef\tCONFIG_X86_IO_APIC\nstatic void __init mp_config_acpi_legacy_irqs(void)\n{\n\tint i;\n\tstruct mpc_intsrc mp_irq;\n\n#ifdef CONFIG_EISA\n\t \n\tmp_bus_id_to_type[MP_ISA_BUS] = MP_BUS_ISA;\n#endif\n\tset_bit(MP_ISA_BUS, mp_bus_not_pci);\n\tpr_debug(\"Bus #%d is ISA (nIRQs: %d)\\n\", MP_ISA_BUS, nr_legacy_irqs());\n\n\t \n\tfor (i = 0; i < nr_legacy_irqs(); i++) {\n\t\tint ioapic, pin;\n\t\tunsigned int dstapic;\n\t\tint idx;\n\t\tu32 gsi;\n\n\t\t \n\t\tif (acpi_isa_irq_to_gsi(i, &gsi))\n\t\t\tcontinue;\n\n\t\t \n\t\tioapic = mp_find_ioapic(gsi);\n\t\tif (ioapic < 0)\n\t\t\tcontinue;\n\t\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\t\tdstapic = mpc_ioapic_id(ioapic);\n\n\t\tfor (idx = 0; idx < mp_irq_entries; idx++) {\n\t\t\tstruct mpc_intsrc *irq = mp_irqs + idx;\n\n\t\t\t \n\t\t\tif (irq->srcbus == MP_ISA_BUS && irq->srcbusirq == i)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (irq->dstapic == dstapic && irq->dstirq == pin)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (idx != mp_irq_entries) {\n\t\t\tpr_debug(\"ACPI: IRQ%d used by override.\\n\", i);\n\t\t\tcontinue;\t \n\t\t}\n\n\t\tmp_irq.type = MP_INTSRC;\n\t\tmp_irq.irqflag = 0;\t \n\t\tmp_irq.srcbus = MP_ISA_BUS;\n\t\tmp_irq.dstapic = dstapic;\n\t\tmp_irq.irqtype = mp_INT;\n\t\tmp_irq.srcbusirq = i;  \n\t\tmp_irq.dstirq = pin;\n\n\t\tmp_save_irq(&mp_irq);\n\t}\n}\n\n \nstatic int __init acpi_parse_madt_ioapic_entries(void)\n{\n\tint count;\n\n\t \n\tif (acpi_disabled || acpi_noirq)\n\t\treturn -ENODEV;\n\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn -ENODEV;\n\n\t \n\tif (ioapic_is_disabled) {\n\t\tpr_info(\"Skipping IOAPIC probe due to 'noapic' option.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_IO_APIC, acpi_parse_ioapic,\n\t\t\t\t      MAX_IO_APICS);\n\tif (!count) {\n\t\tpr_err(\"No IOAPIC entries present\\n\");\n\t\treturn -ENODEV;\n\t} else if (count < 0) {\n\t\tpr_err(\"Error parsing IOAPIC entry\\n\");\n\t\treturn count;\n\t}\n\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_INTERRUPT_OVERRIDE,\n\t\t\t\t      acpi_parse_int_src_ovr, nr_irqs);\n\tif (count < 0) {\n\t\tpr_err(\"Error parsing interrupt source overrides entry\\n\");\n\t\t \n\t\treturn count;\n\t}\n\n\t \n\tif (acpi_sci_override_gsi == INVALID_ACPI_IRQ && !acpi_gbl_reduced_hardware)\n\t\tacpi_sci_ioapic_setup(acpi_gbl_FADT.sci_interrupt, 0, 0,\n\t\t\t\t      acpi_gbl_FADT.sci_interrupt);\n\n\t \n\tmp_config_acpi_legacy_irqs();\n\n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_NMI_SOURCE,\n\t\t\t\t      acpi_parse_nmi_src, nr_irqs);\n\tif (count < 0) {\n\t\tpr_err(\"Error parsing NMI SRC entry\\n\");\n\t\t \n\t\treturn count;\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int acpi_parse_madt_ioapic_entries(void)\n{\n\treturn -1;\n}\n#endif\t \n\nstatic void __init early_acpi_process_madt(void)\n{\n#ifdef CONFIG_X86_LOCAL_APIC\n\tint error;\n\n\tif (!acpi_table_parse(ACPI_SIG_MADT, acpi_parse_madt)) {\n\n\t\t \n\t\terror = early_acpi_parse_madt_lapic_addr_ovr();\n\t\tif (!error) {\n\t\t\tacpi_lapic = 1;\n\t\t\tsmp_found_config = 1;\n\t\t}\n\t\tif (error == -EINVAL) {\n\t\t\t \n\t\t\tpr_err(\"Invalid BIOS MADT, disabling ACPI\\n\");\n\t\t\tdisable_acpi();\n\t\t}\n\t}\n#endif\n}\n\nstatic void __init acpi_process_madt(void)\n{\n#ifdef CONFIG_X86_LOCAL_APIC\n\tint error;\n\n\tif (!acpi_table_parse(ACPI_SIG_MADT, acpi_parse_madt)) {\n\n\t\t \n\t\terror = acpi_parse_madt_lapic_entries();\n\t\tif (!error) {\n\t\t\tacpi_lapic = 1;\n\n\t\t\t \n\t\t\tmutex_lock(&acpi_ioapic_lock);\n\t\t\terror = acpi_parse_madt_ioapic_entries();\n\t\t\tmutex_unlock(&acpi_ioapic_lock);\n\t\t\tif (!error) {\n\t\t\t\tacpi_set_irq_model_ioapic();\n\n\t\t\t\tsmp_found_config = 1;\n\t\t\t}\n\n#ifdef CONFIG_X86_64\n\t\t\t \n\t\t\tacpi_table_parse_madt(ACPI_MADT_TYPE_MULTIPROC_WAKEUP,\n\t\t\t\t\t      acpi_parse_mp_wake, 1);\n#endif\n\t\t}\n\t\tif (error == -EINVAL) {\n\t\t\t \n\t\t\tpr_err(\"Invalid BIOS MADT, disabling ACPI\\n\");\n\t\t\tdisable_acpi();\n\t\t}\n\t} else {\n\t\t \n\t\tif (smp_found_config) {\n\t\t\tpr_warn(\"No APIC-table, disabling MPS\\n\");\n\t\t\tsmp_found_config = 0;\n\t\t}\n\t}\n\n\t \n\tif (acpi_lapic && acpi_ioapic)\n\t\tpr_info(\"Using ACPI (MADT) for SMP configuration information\\n\");\n\telse if (acpi_lapic)\n\t\tpr_info(\"Using ACPI for processor (LAPIC) configuration information\\n\");\n#endif\n\treturn;\n}\n\nstatic int __init disable_acpi_irq(const struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tpr_notice(\"%s detected: force use of acpi=noirq\\n\", d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}\n\nstatic int __init disable_acpi_pci(const struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tpr_notice(\"%s detected: force use of pci=noacpi\\n\", d->ident);\n\t\tacpi_disable_pci();\n\t}\n\treturn 0;\n}\n\nstatic int __init disable_acpi_xsdt(const struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tpr_notice(\"%s detected: force use of acpi=rsdt\\n\", d->ident);\n\t\tacpi_gbl_do_not_use_xsdt = TRUE;\n\t} else {\n\t\tpr_notice(\"Warning: DMI blacklist says broken, but acpi XSDT forced\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int __init dmi_disable_acpi(const struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tpr_notice(\"%s detected: acpi off\\n\", d->ident);\n\t\tdisable_acpi();\n\t} else {\n\t\tpr_notice(\"Warning: DMI blacklist says broken, but acpi forced\\n\");\n\t}\n\treturn 0;\n}\n\n \nstatic int __init dmi_ignore_irq0_timer_override(const struct dmi_system_id *d)\n{\n\tif (!acpi_skip_timer_override) {\n\t\tpr_notice(\"%s detected: Ignoring BIOS IRQ0 override\\n\",\n\t\t\td->ident);\n\t\tacpi_skip_timer_override = 1;\n\t}\n\treturn 0;\n}\n\n \nvoid __init acpi_generic_reduced_hw_init(void)\n{\n\t \n\tx86_init.timers.timer_init\t= x86_init_noop;\n\tx86_init.irqs.pre_vector_init\t= x86_init_noop;\n\tlegacy_pic\t\t\t= &null_legacy_pic;\n}\n\nstatic void __init acpi_reduced_hw_init(void)\n{\n\tif (acpi_gbl_reduced_hardware)\n\t\tx86_init.acpi.reduced_hw_early_init();\n}\n\n \nstatic const struct dmi_system_id acpi_dmi_table[] __initconst = {\n\t \n\t{\n\t .callback = dmi_disable_acpi,\n\t .ident = \"IBM Thinkpad\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"IBM\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"2629H1G\"),\n\t\t     },\n\t },\n\n\t \n\t{\n\t .callback = disable_acpi_irq,\n\t .ident = \"ASUS A7V\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"<A7V>\"),\n\t\t      \n\t\t     DMI_MATCH(DMI_BIOS_VERSION,\n\t\t\t       \"ASUS A7V ACPI BIOS Revision 1007\"),\n\t\t     },\n\t },\n\t{\n\t\t \n\t .callback = disable_acpi_irq,\n\t .ident = \"IBM Thinkpad 600 Series 2645\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"IBM\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"2645\"),\n\t\t     },\n\t },\n\t{\n\t .callback = disable_acpi_irq,\n\t .ident = \"IBM Thinkpad 600 Series 2646\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"IBM\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"2646\"),\n\t\t     },\n\t },\n\t \n\t{\t\t\t \n\t .callback = disable_acpi_pci,\n\t .ident = \"ASUS PR-DLS\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"PR-DLS\"),\n\t\t     DMI_MATCH(DMI_BIOS_VERSION,\n\t\t\t       \"ASUS PR-DLS ACPI BIOS Revision 1010\"),\n\t\t     DMI_MATCH(DMI_BIOS_DATE, \"03/21/2003\")\n\t\t     },\n\t },\n\t{\n\t .callback = disable_acpi_pci,\n\t .ident = \"Acer TravelMate 36x Laptop\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 360\"),\n\t\t     },\n\t },\n\t \n\t{\n\t .callback = disable_acpi_xsdt,\n\t .ident = \"Advantech DAC-BJ01\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"NEC\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"Bearlake CRB Board\"),\n\t\t     DMI_MATCH(DMI_BIOS_VERSION, \"V1.12\"),\n\t\t     DMI_MATCH(DMI_BIOS_DATE, \"02/01/2011\"),\n\t\t     },\n\t },\n\t{}\n};\n\n \nstatic const struct dmi_system_id acpi_dmi_table_late[] __initconst = {\n\t \n\t{\n\t .callback = dmi_ignore_irq0_timer_override,\n\t .ident = \"HP nx6115 laptop\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nx6115\"),\n\t\t     },\n\t },\n\t{\n\t .callback = dmi_ignore_irq0_timer_override,\n\t .ident = \"HP NX6125 laptop\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nx6125\"),\n\t\t     },\n\t },\n\t{\n\t .callback = dmi_ignore_irq0_timer_override,\n\t .ident = \"HP NX6325 laptop\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nx6325\"),\n\t\t     },\n\t },\n\t{\n\t .callback = dmi_ignore_irq0_timer_override,\n\t .ident = \"HP 6715b laptop\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq 6715b\"),\n\t\t     },\n\t },\n\t{\n\t .callback = dmi_ignore_irq0_timer_override,\n\t .ident = \"FUJITSU SIEMENS\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"AMILO PRO V2030\"),\n\t\t     },\n\t },\n\t{}\n};\n\n \n\nvoid __init acpi_boot_table_init(void)\n{\n\tdmi_check_system(acpi_dmi_table);\n\n\t \n\tif (acpi_disabled)\n\t\treturn;\n\n\t \n\tif (acpi_locate_initial_tables())\n\t\tdisable_acpi();\n\telse\n\t\tacpi_reserve_initial_tables();\n}\n\nint __init early_acpi_boot_init(void)\n{\n\tif (acpi_disabled)\n\t\treturn 1;\n\n\tacpi_table_init_complete();\n\n\tacpi_table_parse(ACPI_SIG_BOOT, acpi_parse_sbf);\n\n\t \n\tif (acpi_blacklisted()) {\n\t\tif (acpi_force) {\n\t\t\tpr_warn(\"acpi=force override\\n\");\n\t\t} else {\n\t\t\tpr_warn(\"Disabling ACPI support\\n\");\n\t\t\tdisable_acpi();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tearly_acpi_process_madt();\n\n\t \n\tacpi_reduced_hw_init();\n\n\treturn 0;\n}\n\nint __init acpi_boot_init(void)\n{\n\t \n\tdmi_check_system(acpi_dmi_table_late);\n\n\t \n\tif (acpi_disabled)\n\t\treturn 1;\n\n\tacpi_table_parse(ACPI_SIG_BOOT, acpi_parse_sbf);\n\n\t \n\tacpi_table_parse(ACPI_SIG_FADT, acpi_parse_fadt);\n\n\t \n\tacpi_process_madt();\n\n\tacpi_table_parse(ACPI_SIG_HPET, acpi_parse_hpet);\n\tif (IS_ENABLED(CONFIG_ACPI_BGRT) && !acpi_nobgrt)\n\t\tacpi_table_parse(ACPI_SIG_BGRT, acpi_parse_bgrt);\n\n\tif (!acpi_noirq)\n\t\tx86_init.pci.init = pci_acpi_init;\n\n\t \n\tacpi_parse_spcr(earlycon_acpi_spcr_enable, false);\n\treturn 0;\n}\n\nstatic int __init parse_acpi(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\t \n\tif (strcmp(arg, \"off\") == 0) {\n\t\tdisable_acpi();\n\t}\n\t \n\telse if (strcmp(arg, \"force\") == 0) {\n\t\tacpi_force = 1;\n\t\tacpi_disabled = 0;\n\t}\n\t \n\telse if (strcmp(arg, \"strict\") == 0) {\n\t\tacpi_strict = 1;\n\t}\n\t \n\telse if (strcmp(arg, \"rsdt\") == 0) {\n\t\tacpi_gbl_do_not_use_xsdt = TRUE;\n\t}\n\t \n\telse if (strcmp(arg, \"noirq\") == 0) {\n\t\tacpi_noirq_set();\n\t}\n\t \n\telse if (strcmp(arg, \"copy_dsdt\") == 0) {\n\t\tacpi_gbl_copy_dsdt_locally = 1;\n\t}\n\t \n\telse if (strcmp(arg, \"nocmcff\") == 0) {\n\t\tacpi_disable_cmcff = 1;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nearly_param(\"acpi\", parse_acpi);\n\nstatic int __init parse_acpi_bgrt(char *arg)\n{\n\tacpi_nobgrt = true;\n\treturn 0;\n}\nearly_param(\"bgrt_disable\", parse_acpi_bgrt);\n\n \nstatic int __init parse_pci(char *arg)\n{\n\tif (arg && strcmp(arg, \"noacpi\") == 0)\n\t\tacpi_disable_pci();\n\treturn 0;\n}\nearly_param(\"pci\", parse_pci);\n\nint __init acpi_mps_check(void)\n{\n#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_X86_MPPARSE)\n \n\tif (acpi_disabled || acpi_noirq) {\n\t\tpr_warn(\"MPS support code is not built-in, using acpi=off or acpi=noirq or pci=noacpi may have problem\\n\");\n\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_IO_APIC\nstatic int __init parse_acpi_skip_timer_override(char *arg)\n{\n\tacpi_skip_timer_override = 1;\n\treturn 0;\n}\nearly_param(\"acpi_skip_timer_override\", parse_acpi_skip_timer_override);\n\nstatic int __init parse_acpi_use_timer_override(char *arg)\n{\n\tacpi_use_timer_override = 1;\n\treturn 0;\n}\nearly_param(\"acpi_use_timer_override\", parse_acpi_use_timer_override);\n#endif  \n\nstatic int __init setup_acpi_sci(char *s)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!strcmp(s, \"edge\"))\n\t\tacpi_sci_flags =  ACPI_MADT_TRIGGER_EDGE |\n\t\t\t(acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);\n\telse if (!strcmp(s, \"level\"))\n\t\tacpi_sci_flags = ACPI_MADT_TRIGGER_LEVEL |\n\t\t\t(acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);\n\telse if (!strcmp(s, \"high\"))\n\t\tacpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_HIGH |\n\t\t\t(acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);\n\telse if (!strcmp(s, \"low\"))\n\t\tacpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_LOW |\n\t\t\t(acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\nearly_param(\"acpi_sci\", setup_acpi_sci);\n\nint __acpi_acquire_global_lock(unsigned int *lock)\n{\n\tunsigned int old, new, val;\n\n\told = READ_ONCE(*lock);\n\tdo {\n\t\tval = (old >> 1) & 0x1;\n\t\tnew = (old & ~0x3) + 2 + val;\n\t} while (!try_cmpxchg(lock, &old, new));\n\n\tif (val)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nint __acpi_release_global_lock(unsigned int *lock)\n{\n\tunsigned int old, new;\n\n\told = READ_ONCE(*lock);\n\tdo {\n\t\tnew = old & ~0x3;\n\t} while (!try_cmpxchg(lock, &old, new));\n\treturn old & 0x1;\n}\n\nvoid __init arch_reserve_mem_area(acpi_physical_address addr, size_t size)\n{\n\te820__range_add(addr, size, E820_TYPE_NVS);\n\te820__update_table_print();\n}\n\nvoid x86_default_set_root_pointer(u64 addr)\n{\n\tboot_params.acpi_rsdp_addr = addr;\n}\n\nu64 x86_default_get_root_pointer(void)\n{\n\treturn boot_params.acpi_rsdp_addr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}