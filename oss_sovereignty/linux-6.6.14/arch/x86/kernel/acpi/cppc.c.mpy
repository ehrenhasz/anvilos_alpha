{
  "module_name": "cppc.c",
  "hash_id": "81856a6c492fb3b28333e333531bcfd129718ed6ed92c3c505e891873c1d3b10",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/acpi/cppc.c",
  "human_readable_source": "\n \n\n#include <acpi/cppc_acpi.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <asm/topology.h>\n\n \n\nbool cpc_supported_by_cpu(void)\n{\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_AMD:\n\tcase X86_VENDOR_HYGON:\n\t\tif (boot_cpu_data.x86 == 0x19 && ((boot_cpu_data.x86_model <= 0x0f) ||\n\t\t    (boot_cpu_data.x86_model >= 0x20 && boot_cpu_data.x86_model <= 0x2f)))\n\t\t\treturn true;\n\t\telse if (boot_cpu_data.x86 == 0x17 &&\n\t\t\t boot_cpu_data.x86_model >= 0x70 && boot_cpu_data.x86_model <= 0x7f)\n\t\t\treturn true;\n\t\treturn boot_cpu_has(X86_FEATURE_CPPC);\n\t}\n\treturn false;\n}\n\nbool cpc_ffh_supported(void)\n{\n\treturn true;\n}\n\nint cpc_read_ffh(int cpunum, struct cpc_reg *reg, u64 *val)\n{\n\tint err;\n\n\terr = rdmsrl_safe_on_cpu(cpunum, reg->address, val);\n\tif (!err) {\n\t\tu64 mask = GENMASK_ULL(reg->bit_offset + reg->bit_width - 1,\n\t\t\t\t       reg->bit_offset);\n\n\t\t*val &= mask;\n\t\t*val >>= reg->bit_offset;\n\t}\n\treturn err;\n}\n\nint cpc_write_ffh(int cpunum, struct cpc_reg *reg, u64 val)\n{\n\tu64 rd_val;\n\tint err;\n\n\terr = rdmsrl_safe_on_cpu(cpunum, reg->address, &rd_val);\n\tif (!err) {\n\t\tu64 mask = GENMASK_ULL(reg->bit_offset + reg->bit_width - 1,\n\t\t\t\t       reg->bit_offset);\n\n\t\tval <<= reg->bit_offset;\n\t\tval &= mask;\n\t\trd_val &= ~mask;\n\t\trd_val |= val;\n\t\terr = wrmsrl_safe_on_cpu(cpunum, reg->address, rd_val);\n\t}\n\treturn err;\n}\n\nstatic void amd_set_max_freq_ratio(void)\n{\n\tstruct cppc_perf_caps perf_caps;\n\tu64 highest_perf, nominal_perf;\n\tu64 perf_ratio;\n\tint rc;\n\n\trc = cppc_get_perf_caps(0, &perf_caps);\n\tif (rc) {\n\t\tpr_debug(\"Could not retrieve perf counters (%d)\\n\", rc);\n\t\treturn;\n\t}\n\n\thighest_perf = amd_get_highest_perf();\n\tnominal_perf = perf_caps.nominal_perf;\n\n\tif (!highest_perf || !nominal_perf) {\n\t\tpr_debug(\"Could not retrieve highest or nominal performance\\n\");\n\t\treturn;\n\t}\n\n\tperf_ratio = div_u64(highest_perf * SCHED_CAPACITY_SCALE, nominal_perf);\n\t \n\tperf_ratio = (perf_ratio + SCHED_CAPACITY_SCALE) >> 1;\n\tif (!perf_ratio) {\n\t\tpr_debug(\"Non-zero highest/nominal perf values led to a 0 ratio\\n\");\n\t\treturn;\n\t}\n\n\tfreq_invariance_set_perf_ratio(perf_ratio, false);\n}\n\nstatic DEFINE_MUTEX(freq_invariance_lock);\n\nvoid init_freq_invariance_cppc(void)\n{\n\tstatic bool init_done;\n\n\tif (!cpu_feature_enabled(X86_FEATURE_APERFMPERF))\n\t\treturn;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\n\t\treturn;\n\n\tmutex_lock(&freq_invariance_lock);\n\tif (!init_done)\n\t\tamd_set_max_freq_ratio();\n\tinit_done = true;\n\tmutex_unlock(&freq_invariance_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}