{
  "module_name": "cstate.c",
  "hash_id": "ec57d82c5025acd4fb4b9c179b8803f0aa783cbdbd37297af93654559ff4a906",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/acpi/cstate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/cpu.h>\n#include <linux/sched.h>\n\n#include <acpi/processor.h>\n#include <asm/mwait.h>\n#include <asm/special_insns.h>\n\n \nvoid acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags,\n\t\t\t\t\tunsigned int cpu)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\tflags->bm_check = 0;\n\tif (num_online_cpus() == 1)\n\t\tflags->bm_check = 1;\n\telse if (c->x86_vendor == X86_VENDOR_INTEL) {\n\t\t \n\t\tflags->bm_check = 1;\n\t}\n\n\t \n\tif (c->x86_vendor == X86_VENDOR_INTEL &&\n\t    (c->x86 > 0xf || (c->x86 == 6 && c->x86_model >= 0x0f)))\n\t\t\tflags->bm_control = 0;\n\n\tif (c->x86_vendor == X86_VENDOR_CENTAUR) {\n\t\tif (c->x86 > 6 || (c->x86 == 6 && c->x86_model == 0x0f &&\n\t\t    c->x86_stepping >= 0x0e)) {\n\t\t\t \n\t\t\tflags->bm_check = 1;\n\t\t\t \n\t\t\tflags->bm_control = 0;\n\t\t}\n\t}\n\n\tif (c->x86_vendor == X86_VENDOR_ZHAOXIN) {\n\t\t \n\t\tflags->bm_check = 1;\n\t\t \n\t\tflags->bm_control = 0;\n\t}\n\tif (c->x86_vendor == X86_VENDOR_AMD && c->x86 >= 0x17) {\n\t\t \n\t\tflags->bm_check = 1;\n\t\t \n\t\tflags->bm_control = 0;\n\t}\n}\nEXPORT_SYMBOL(acpi_processor_power_init_bm_check);\n\n \n\nstruct cstate_entry {\n\tstruct {\n\t\tunsigned int eax;\n\t\tunsigned int ecx;\n\t} states[ACPI_PROCESSOR_MAX_POWER];\n};\nstatic struct cstate_entry __percpu *cpu_cstate_entry;\t \n\nstatic short mwait_supported[ACPI_PROCESSOR_MAX_POWER];\n\n#define NATIVE_CSTATE_BEYOND_HALT\t(2)\n\nstatic long acpi_processor_ffh_cstate_probe_cpu(void *_cx)\n{\n\tstruct acpi_processor_cx *cx = _cx;\n\tlong retval;\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int edx_part;\n\tunsigned int cstate_type;  \n\tunsigned int num_cstate_subtype;\n\n\tcpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\n\n\t \n\tcstate_type = ((cx->address >> MWAIT_SUBSTATE_SIZE) &\n\t\t\tMWAIT_CSTATE_MASK) + 1;\n\tedx_part = edx >> (cstate_type * MWAIT_SUBSTATE_SIZE);\n\tnum_cstate_subtype = edx_part & MWAIT_SUBSTATE_MASK;\n\n\tretval = 0;\n\t \n\tif (num_cstate_subtype == 0) {\n\t\tpr_warn(FW_BUG \"ACPI MWAIT C-state 0x%x not supported by HW (0x%x)\\n\",\n\t\t\t\tcx->address, edx_part);\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\n\t    !(ecx & CPUID5_ECX_INTERRUPT_BREAK)) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\n\tif (!mwait_supported[cstate_type]) {\n\t\tmwait_supported[cstate_type] = 1;\n\t\tprintk(KERN_DEBUG\n\t\t\t\"Monitor-Mwait will be used to enter C-%d state\\n\",\n\t\t\tcx->type);\n\t}\n\tsnprintf(cx->desc,\n\t\t\tACPI_CX_DESC_LEN, \"ACPI FFH MWAIT 0x%x\",\n\t\t\tcx->address);\nout:\n\treturn retval;\n}\n\nint acpi_processor_ffh_cstate_probe(unsigned int cpu,\n\t\tstruct acpi_processor_cx *cx, struct acpi_power_register *reg)\n{\n\tstruct cstate_entry *percpu_entry;\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tlong retval;\n\n\tif (!cpu_cstate_entry || c->cpuid_level < CPUID_MWAIT_LEAF)\n\t\treturn -1;\n\n\tif (reg->bit_offset != NATIVE_CSTATE_BEYOND_HALT)\n\t\treturn -1;\n\n\tpercpu_entry = per_cpu_ptr(cpu_cstate_entry, cpu);\n\tpercpu_entry->states[cx->index].eax = 0;\n\tpercpu_entry->states[cx->index].ecx = 0;\n\n\t \n\n\tretval = call_on_cpu(cpu, acpi_processor_ffh_cstate_probe_cpu, cx,\n\t\t\t     false);\n\tif (retval == 0) {\n\t\t \n\t\tpercpu_entry->states[cx->index].eax = cx->address;\n\t\tpercpu_entry->states[cx->index].ecx = MWAIT_ECX_INTERRUPT_BREAK;\n\t}\n\n\t \n\tif ((c->x86_vendor == X86_VENDOR_INTEL) && !(reg->access_size & 0x2))\n\t\tcx->bm_sts_skip = 1;\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(acpi_processor_ffh_cstate_probe);\n\nvoid __cpuidle acpi_processor_ffh_cstate_enter(struct acpi_processor_cx *cx)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct cstate_entry *percpu_entry;\n\n\tpercpu_entry = per_cpu_ptr(cpu_cstate_entry, cpu);\n\tmwait_idle_with_hints(percpu_entry->states[cx->index].eax,\n\t                      percpu_entry->states[cx->index].ecx);\n}\nEXPORT_SYMBOL_GPL(acpi_processor_ffh_cstate_enter);\n\nstatic int __init ffh_cstate_init(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\tif (c->x86_vendor != X86_VENDOR_INTEL &&\n\t    c->x86_vendor != X86_VENDOR_AMD &&\n\t    c->x86_vendor != X86_VENDOR_HYGON)\n\t\treturn -1;\n\n\tcpu_cstate_entry = alloc_percpu(struct cstate_entry);\n\treturn 0;\n}\n\nstatic void __exit ffh_cstate_exit(void)\n{\n\tfree_percpu(cpu_cstate_entry);\n\tcpu_cstate_entry = NULL;\n}\n\narch_initcall(ffh_cstate_init);\n__exitcall(ffh_cstate_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}