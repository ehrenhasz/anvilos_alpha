{
  "module_name": "reboot.c",
  "hash_id": "8995a7d7637f6d7748affe9ff7464eb26be7ecebc0dcfa92a32d69d9b2d97cd5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/reboot.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/pm.h>\n#include <linux/efi.h>\n#include <linux/dmi.h>\n#include <linux/sched.h>\n#include <linux/tboot.h>\n#include <linux/delay.h>\n#include <linux/objtool.h>\n#include <linux/pgtable.h>\n#include <acpi/reboot.h>\n#include <asm/io.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/desc.h>\n#include <asm/hpet.h>\n#include <asm/proto.h>\n#include <asm/reboot_fixups.h>\n#include <asm/reboot.h>\n#include <asm/pci_x86.h>\n#include <asm/cpu.h>\n#include <asm/nmi.h>\n#include <asm/smp.h>\n\n#include <linux/ctype.h>\n#include <linux/mc146818rtc.h>\n#include <asm/realmode.h>\n#include <asm/x86_init.h>\n#include <asm/efi.h>\n\n \nvoid (*pm_power_off)(void);\nEXPORT_SYMBOL(pm_power_off);\n\n \nstatic int reboot_emergency;\n\n \nbool port_cf9_safe = false;\n\n \n\n \nstatic int __init set_acpi_reboot(const struct dmi_system_id *d)\n{\n\tif (reboot_type != BOOT_ACPI) {\n\t\treboot_type = BOOT_ACPI;\n\t\tpr_info(\"%s series board detected. Selecting %s-method for reboots.\\n\",\n\t\t\td->ident, \"ACPI\");\n\t}\n\treturn 0;\n}\n\n \nstatic int __init set_bios_reboot(const struct dmi_system_id *d)\n{\n\tif (reboot_type != BOOT_BIOS) {\n\t\treboot_type = BOOT_BIOS;\n\t\tpr_info(\"%s series board detected. Selecting %s-method for reboots.\\n\",\n\t\t\td->ident, \"BIOS\");\n\t}\n\treturn 0;\n}\n\n \nstatic int __init set_efi_reboot(const struct dmi_system_id *d)\n{\n\tif (reboot_type != BOOT_EFI && !efi_runtime_disabled()) {\n\t\treboot_type = BOOT_EFI;\n\t\tpr_info(\"%s series board detected. Selecting EFI-method for reboot.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\nvoid __noreturn machine_real_restart(unsigned int type)\n{\n\tlocal_irq_disable();\n\n\t \n\tspin_lock(&rtc_lock);\n\tCMOS_WRITE(0x00, 0x8f);\n\tspin_unlock(&rtc_lock);\n\n\t \n\tload_trampoline_pgtable();\n\n\t \n#ifdef CONFIG_X86_32\n\tasm volatile(\"jmpl *%0\" : :\n\t\t     \"rm\" (real_mode_header->machine_real_restart_asm),\n\t\t     \"a\" (type));\n#else\n\tasm volatile(\"ljmpl *%0\" : :\n\t\t     \"m\" (real_mode_header->machine_real_restart_asm),\n\t\t     \"D\" (type));\n#endif\n\tunreachable();\n}\n#ifdef CONFIG_APM_MODULE\nEXPORT_SYMBOL(machine_real_restart);\n#endif\nSTACK_FRAME_NON_STANDARD(machine_real_restart);\n\n \nstatic int __init set_pci_reboot(const struct dmi_system_id *d)\n{\n\tif (reboot_type != BOOT_CF9_FORCE) {\n\t\treboot_type = BOOT_CF9_FORCE;\n\t\tpr_info(\"%s series board detected. Selecting %s-method for reboots.\\n\",\n\t\t\td->ident, \"PCI\");\n\t}\n\treturn 0;\n}\n\nstatic int __init set_kbd_reboot(const struct dmi_system_id *d)\n{\n\tif (reboot_type != BOOT_KBD) {\n\t\treboot_type = BOOT_KBD;\n\t\tpr_info(\"%s series board detected. Selecting %s-method for reboot.\\n\",\n\t\t\td->ident, \"KBD\");\n\t}\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id reboot_dmi_table[] __initconst = {\n\n\t \n\t{\t \n\t\t.callback = set_kbd_reboot,\n\t\t.ident = \"Acer Aspire One A110\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AOA110\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_efi_reboot,\n\t\t.ident = \"Acer TravelMate X514-51T\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate X514-51T\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple MacBook5\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBook5\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple MacBook6,1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBook6,1\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple MacBookPro5\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro5\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple Macmini3,1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Macmini3,1\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple iMac9,1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"iMac9,1\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Apple iMac10,1\",\n\t\t.matches = {\n\t\t    DMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t    DMI_MATCH(DMI_PRODUCT_NAME, \"iMac10,1\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"ASRock Q1900DC-ITX\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASRock\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Q1900DC-ITX\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"ASUS P4S800\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"P4S800\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_acpi_reboot,\n\t\t.ident = \"ASUS EeeBook X205TA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"X205TA\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_acpi_reboot,\n\t\t.ident = \"ASUS EeeBook X205TAW\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"X205TAW\"),\n\t\t},\n\t},\n\n\t \n\t{        \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Certec BPC600\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Certec\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"BPC600\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell DXP061\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Dell DXP061\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell E520\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Dell DM061\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell Latitude E5410\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude E5410\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell Latitude E5420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude E5420\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell Latitude E6320\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude E6320\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell Latitude E6420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude E6420\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 330\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 330\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"0KP561\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 360\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 360\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"0T656F\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 745\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 745\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 745\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 745\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"0MM599\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 745\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 745\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"0KW626\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell OptiPlex 760\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 760\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"0G919G\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell OptiPlex 990 BIOS A0x\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 990\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A0\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell PowerEdge 300\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 300/\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell PowerEdge 1300\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 1300/\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell PowerEdge 2400\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 2400\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell PowerEdge C6100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"C6100\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Dell Precision M6600\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Precision M6600\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell Precision T5400\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Precision WorkStation T5400\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell Precision T7400\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Precision WorkStation T7400\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Dell XPS710\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Dell XPS710\"),\n\t\t},\n\t},\n\t{\t \n\t\t.callback = set_acpi_reboot,\n\t\t.ident = \"Dell OptiPlex 7450 AIO\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 7450 AIO\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"HP Compaq Laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq\"),\n\t\t},\n\t},\n\n\t{\t \n\t\t.callback = set_pci_reboot,\n\t\t.ident = \"Zotac ZBOX CI327 nano\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"NA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZBOX-CI327NANO-GS-01\"),\n\t\t},\n\t},\n\n\t \n\t{\t \n\t\t.callback = set_bios_reboot,\n\t\t.ident = \"Sony VGN-Z540N\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-Z540N\"),\n\t\t},\n\t},\n\n\t{ }\n};\n\nstatic int __init reboot_init(void)\n{\n\tint rv;\n\n\t \n\tif (!reboot_default)\n\t\treturn 0;\n\n\t \n\trv = dmi_check_system(reboot_dmi_table);\n\n\tif (!rv && efi_reboot_required() && !efi_runtime_disabled())\n\t\treboot_type = BOOT_EFI;\n\n\treturn 0;\n}\ncore_initcall(reboot_init);\n\nstatic inline void kb_wait(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 0x10000; i++) {\n\t\tif ((inb(0x64) & 0x02) == 0)\n\t\t\tbreak;\n\t\tudelay(2);\n\t}\n}\n\nstatic inline void nmi_shootdown_cpus_on_restart(void);\n\n#if IS_ENABLED(CONFIG_KVM_INTEL) || IS_ENABLED(CONFIG_KVM_AMD)\n \nstatic cpu_emergency_virt_cb __rcu *cpu_emergency_virt_callback;\n\nvoid cpu_emergency_register_virt_callback(cpu_emergency_virt_cb *callback)\n{\n\tif (WARN_ON_ONCE(rcu_access_pointer(cpu_emergency_virt_callback)))\n\t\treturn;\n\n\trcu_assign_pointer(cpu_emergency_virt_callback, callback);\n}\nEXPORT_SYMBOL_GPL(cpu_emergency_register_virt_callback);\n\nvoid cpu_emergency_unregister_virt_callback(cpu_emergency_virt_cb *callback)\n{\n\tif (WARN_ON_ONCE(rcu_access_pointer(cpu_emergency_virt_callback) != callback))\n\t\treturn;\n\n\trcu_assign_pointer(cpu_emergency_virt_callback, NULL);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(cpu_emergency_unregister_virt_callback);\n\n \nvoid cpu_emergency_disable_virtualization(void)\n{\n\tcpu_emergency_virt_cb *callback;\n\n\t \n\tlockdep_assert_irqs_disabled();\n\n\trcu_read_lock();\n\tcallback = rcu_dereference(cpu_emergency_virt_callback);\n\tif (callback)\n\t\tcallback();\n\trcu_read_unlock();\n}\n\nstatic void emergency_reboot_disable_virtualization(void)\n{\n\tlocal_irq_disable();\n\n\t \n\tif (rcu_access_pointer(cpu_emergency_virt_callback)) {\n\t\t \n\t\tcpu_emergency_disable_virtualization();\n\n\t\t \n\t\tnmi_shootdown_cpus_on_restart();\n\t}\n}\n#else\nstatic void emergency_reboot_disable_virtualization(void) { }\n#endif  \n\nvoid __attribute__((weak)) mach_reboot_fixups(void)\n{\n}\n\n \nstatic void native_machine_emergency_restart(void)\n{\n\tint i;\n\tint attempt = 0;\n\tint orig_reboot_type = reboot_type;\n\tunsigned short mode;\n\n\tif (reboot_emergency)\n\t\temergency_reboot_disable_virtualization();\n\n\ttboot_shutdown(TB_SHUTDOWN_REBOOT);\n\n\t \n\tmode = reboot_mode == REBOOT_WARM ? 0x1234 : 0;\n\t*((unsigned short *)__va(0x472)) = mode;\n\n\t \n\tif (efi_capsule_pending(NULL)) {\n\t\tpr_info(\"EFI capsule is pending, forcing EFI reboot.\\n\");\n\t\treboot_type = BOOT_EFI;\n\t}\n\n\tfor (;;) {\n\t\t \n\t\tswitch (reboot_type) {\n\t\tcase BOOT_ACPI:\n\t\t\tacpi_reboot();\n\t\t\treboot_type = BOOT_KBD;\n\t\t\tbreak;\n\n\t\tcase BOOT_KBD:\n\t\t\tmach_reboot_fixups();  \n\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\tkb_wait();\n\t\t\t\tudelay(50);\n\t\t\t\toutb(0xfe, 0x64);  \n\t\t\t\tudelay(50);\n\t\t\t}\n\t\t\tif (attempt == 0 && orig_reboot_type == BOOT_ACPI) {\n\t\t\t\tattempt = 1;\n\t\t\t\treboot_type = BOOT_ACPI;\n\t\t\t} else {\n\t\t\t\treboot_type = BOOT_EFI;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BOOT_EFI:\n\t\t\tefi_reboot(reboot_mode, NULL);\n\t\t\treboot_type = BOOT_BIOS;\n\t\t\tbreak;\n\n\t\tcase BOOT_BIOS:\n\t\t\tmachine_real_restart(MRR_BIOS);\n\n\t\t\t \n\t\t\treboot_type = BOOT_CF9_SAFE;\n\t\t\tbreak;\n\n\t\tcase BOOT_CF9_FORCE:\n\t\t\tport_cf9_safe = true;\n\t\t\tfallthrough;\n\n\t\tcase BOOT_CF9_SAFE:\n\t\t\tif (port_cf9_safe) {\n\t\t\t\tu8 reboot_code = reboot_mode == REBOOT_WARM ?  0x06 : 0x0E;\n\t\t\t\tu8 cf9 = inb(0xcf9) & ~reboot_code;\n\t\t\t\toutb(cf9|2, 0xcf9);  \n\t\t\t\tudelay(50);\n\t\t\t\t \n\t\t\t\toutb(cf9|reboot_code, 0xcf9);\n\t\t\t\tudelay(50);\n\t\t\t}\n\t\t\treboot_type = BOOT_TRIPLE;\n\t\t\tbreak;\n\n\t\tcase BOOT_TRIPLE:\n\t\t\tidt_invalidate();\n\t\t\t__asm__ __volatile__(\"int3\");\n\n\t\t\t \n\t\t\treboot_type = BOOT_KBD;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid native_machine_shutdown(void)\n{\n\t \n#ifdef CONFIG_X86_IO_APIC\n\t \n\tclear_IO_APIC();\n#endif\n\n#ifdef CONFIG_SMP\n\t \n\tlocal_irq_disable();\n\tstop_other_cpus();\n#endif\n\n\tlapic_shutdown();\n\trestore_boot_irq_mode();\n\n#ifdef CONFIG_HPET_TIMER\n\thpet_disable();\n#endif\n\n#ifdef CONFIG_X86_64\n\tx86_platform.iommu_shutdown();\n#endif\n}\n\nstatic void __machine_emergency_restart(int emergency)\n{\n\treboot_emergency = emergency;\n\tmachine_ops.emergency_restart();\n}\n\nstatic void native_machine_restart(char *__unused)\n{\n\tpr_notice(\"machine restart\\n\");\n\n\tif (!reboot_force)\n\t\tmachine_shutdown();\n\t__machine_emergency_restart(0);\n}\n\nstatic void native_machine_halt(void)\n{\n\t \n\tmachine_shutdown();\n\n\ttboot_shutdown(TB_SHUTDOWN_HALT);\n\n\tstop_this_cpu(NULL);\n}\n\nstatic void native_machine_power_off(void)\n{\n\tif (kernel_can_power_off()) {\n\t\tif (!reboot_force)\n\t\t\tmachine_shutdown();\n\t\tdo_kernel_power_off();\n\t}\n\t \n\ttboot_shutdown(TB_SHUTDOWN_HALT);\n}\n\nstruct machine_ops machine_ops __ro_after_init = {\n\t.power_off = native_machine_power_off,\n\t.shutdown = native_machine_shutdown,\n\t.emergency_restart = native_machine_emergency_restart,\n\t.restart = native_machine_restart,\n\t.halt = native_machine_halt,\n#ifdef CONFIG_KEXEC_CORE\n\t.crash_shutdown = native_machine_crash_shutdown,\n#endif\n};\n\nvoid machine_power_off(void)\n{\n\tmachine_ops.power_off();\n}\n\nvoid machine_shutdown(void)\n{\n\tmachine_ops.shutdown();\n}\n\nvoid machine_emergency_restart(void)\n{\n\t__machine_emergency_restart(1);\n}\n\nvoid machine_restart(char *cmd)\n{\n\tmachine_ops.restart(cmd);\n}\n\nvoid machine_halt(void)\n{\n\tmachine_ops.halt();\n}\n\n#ifdef CONFIG_KEXEC_CORE\nvoid machine_crash_shutdown(struct pt_regs *regs)\n{\n\tmachine_ops.crash_shutdown(regs);\n}\n#endif\n\n \nint crashing_cpu = -1;\n\n#if defined(CONFIG_SMP)\n\nstatic nmi_shootdown_cb shootdown_callback;\n\nstatic atomic_t waiting_for_crash_ipi;\nstatic int crash_ipi_issued;\n\nstatic int crash_nmi_callback(unsigned int val, struct pt_regs *regs)\n{\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\n\t \n\tif (cpu == crashing_cpu)\n\t\treturn NMI_HANDLED;\n\tlocal_irq_disable();\n\n\tif (shootdown_callback)\n\t\tshootdown_callback(cpu, regs);\n\n\t \n\tcpu_emergency_disable_virtualization();\n\n\tatomic_dec(&waiting_for_crash_ipi);\n\t \n\thalt();\n\tfor (;;)\n\t\tcpu_relax();\n\n\treturn NMI_HANDLED;\n}\n\n \nvoid nmi_shootdown_cpus(nmi_shootdown_cb callback)\n{\n\tunsigned long msecs;\n\n\tlocal_irq_disable();\n\n\t \n\tif (WARN_ON_ONCE(crash_ipi_issued))\n\t\treturn;\n\n\t \n\tcrashing_cpu = safe_smp_processor_id();\n\n\tshootdown_callback = callback;\n\n\tatomic_set(&waiting_for_crash_ipi, num_online_cpus() - 1);\n\t \n\tif (register_nmi_handler(NMI_LOCAL, crash_nmi_callback,\n\t\t\t\t NMI_FLAG_FIRST, \"crash\"))\n\t\treturn;\t\t \n\t \n\twmb();\n\n\tapic_send_IPI_allbutself(NMI_VECTOR);\n\n\t \n\tWRITE_ONCE(crash_ipi_issued, 1);\n\n\tmsecs = 1000;  \n\twhile ((atomic_read(&waiting_for_crash_ipi) > 0) && msecs) {\n\t\tmdelay(1);\n\t\tmsecs--;\n\t}\n\n\t \n}\n\nstatic inline void nmi_shootdown_cpus_on_restart(void)\n{\n\tif (!crash_ipi_issued)\n\t\tnmi_shootdown_cpus(NULL);\n}\n\n \nvoid run_crash_ipi_callback(struct pt_regs *regs)\n{\n\tif (crash_ipi_issued)\n\t\tcrash_nmi_callback(0, regs);\n}\n\n \nvoid __noreturn nmi_panic_self_stop(struct pt_regs *regs)\n{\n\twhile (1) {\n\t\t \n\t\trun_crash_ipi_callback(regs);\n\t\tcpu_relax();\n\t}\n}\n\n#else  \nvoid nmi_shootdown_cpus(nmi_shootdown_cb callback)\n{\n\t \n}\n\nstatic inline void nmi_shootdown_cpus_on_restart(void) { }\n\nvoid run_crash_ipi_callback(struct pt_regs *regs)\n{\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}