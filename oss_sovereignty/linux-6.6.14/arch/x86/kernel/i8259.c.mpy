{
  "module_name": "i8259.c",
  "hash_id": "a5fa49c9f852abdc411c73a49a141a2e2fdbe6e94acfd4a52ba0b09bf56cb2d9",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/i8259.c",
  "human_readable_source": "\n#include <linux/linkage.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/timex.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/kernel_stat.h>\n#include <linux/syscore_ops.h>\n#include <linux/bitops.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/pgtable.h>\n\n#include <linux/atomic.h>\n#include <asm/timer.h>\n#include <asm/hw_irq.h>\n#include <asm/desc.h>\n#include <asm/apic.h>\n#include <asm/i8259.h>\n\n \nstatic void init_8259A(int auto_eoi);\n\nstatic bool pcat_compat __ro_after_init;\nstatic int i8259A_auto_eoi;\nDEFINE_RAW_SPINLOCK(i8259A_lock);\n\n \n\n \nunsigned int cached_irq_mask = 0xffff;\n\n \nunsigned long io_apic_irqs;\n\nstatic void mask_8259A_irq(unsigned int irq)\n{\n\tunsigned int mask = 1 << irq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\tcached_irq_mask |= mask;\n\tif (irq & 8)\n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\telse\n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic void disable_8259A_irq(struct irq_data *data)\n{\n\tmask_8259A_irq(data->irq);\n}\n\nstatic void unmask_8259A_irq(unsigned int irq)\n{\n\tunsigned int mask = ~(1 << irq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\tcached_irq_mask &= mask;\n\tif (irq & 8)\n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\telse\n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic void enable_8259A_irq(struct irq_data *data)\n{\n\tunmask_8259A_irq(data->irq);\n}\n\nstatic int i8259A_irq_pending(unsigned int irq)\n{\n\tunsigned int mask = 1<<irq;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\tif (irq < 8)\n\t\tret = inb(PIC_MASTER_CMD) & mask;\n\telse\n\t\tret = inb(PIC_SLAVE_CMD) & (mask >> 8);\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n\n\treturn ret;\n}\n\nstatic void make_8259A_irq(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n\tio_apic_irqs &= ~(1<<irq);\n\tirq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);\n\tirq_set_status_flags(irq, IRQ_LEVEL);\n\tenable_irq(irq);\n\tlapic_assign_legacy_vector(irq, true);\n}\n\n \nstatic inline int i8259A_irq_real(unsigned int irq)\n{\n\tint value;\n\tint irqmask = 1<<irq;\n\n\tif (irq < 8) {\n\t\toutb(0x0B, PIC_MASTER_CMD);\t \n\t\tvalue = inb(PIC_MASTER_CMD) & irqmask;\n\t\toutb(0x0A, PIC_MASTER_CMD);\t \n\t\treturn value;\n\t}\n\toutb(0x0B, PIC_SLAVE_CMD);\t \n\tvalue = inb(PIC_SLAVE_CMD) & (irqmask >> 8);\n\toutb(0x0A, PIC_SLAVE_CMD);\t \n\treturn value;\n}\n\n \nstatic void mask_and_ack_8259A(struct irq_data *data)\n{\n\tunsigned int irq = data->irq;\n\tunsigned int irqmask = 1 << irq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\t \n\tif (cached_irq_mask & irqmask)\n\t\tgoto spurious_8259A_irq;\n\tcached_irq_mask |= irqmask;\n\nhandle_real_irq:\n\tif (irq & 8) {\n\t\tinb(PIC_SLAVE_IMR);\t \n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\t\t \n\t\toutb(0x60+(irq&7), PIC_SLAVE_CMD);\n\t\t  \n\t\toutb(0x60+PIC_CASCADE_IR, PIC_MASTER_CMD);\n\t} else {\n\t\tinb(PIC_MASTER_IMR);\t \n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\t\toutb(0x60+irq, PIC_MASTER_CMD);\t \n\t}\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n\treturn;\n\nspurious_8259A_irq:\n\t \n\tif (i8259A_irq_real(irq))\n\t\t \n\t\tgoto handle_real_irq;\n\n\t{\n\t\tstatic int spurious_irq_mask;\n\t\t \n\t\tif (!(spurious_irq_mask & irqmask)) {\n\t\t\tprintk_deferred(KERN_DEBUG\n\t\t\t       \"spurious 8259A interrupt: IRQ%d.\\n\", irq);\n\t\t\tspurious_irq_mask |= irqmask;\n\t\t}\n\t\tatomic_inc(&irq_err_count);\n\t\t \n\t\tgoto handle_real_irq;\n\t}\n}\n\nstruct irq_chip i8259A_chip = {\n\t.name\t\t= \"XT-PIC\",\n\t.irq_mask\t= disable_8259A_irq,\n\t.irq_disable\t= disable_8259A_irq,\n\t.irq_unmask\t= enable_8259A_irq,\n\t.irq_mask_ack\t= mask_and_ack_8259A,\n};\n\nstatic char irq_trigger[2];\n \nstatic void restore_ELCR(char *trigger)\n{\n\toutb(trigger[0], PIC_ELCR1);\n\toutb(trigger[1], PIC_ELCR2);\n}\n\nstatic void save_ELCR(char *trigger)\n{\n\t \n\ttrigger[0] = inb(PIC_ELCR1) & 0xF8;\n\ttrigger[1] = inb(PIC_ELCR2) & 0xDE;\n}\n\nstatic void i8259A_resume(void)\n{\n\tinit_8259A(i8259A_auto_eoi);\n\trestore_ELCR(irq_trigger);\n}\n\nstatic int i8259A_suspend(void)\n{\n\tsave_ELCR(irq_trigger);\n\treturn 0;\n}\n\nstatic void i8259A_shutdown(void)\n{\n\t \n\toutb(0xff, PIC_MASTER_IMR);\t \n\toutb(0xff, PIC_SLAVE_IMR);\t \n}\n\nstatic struct syscore_ops i8259_syscore_ops = {\n\t.suspend = i8259A_suspend,\n\t.resume = i8259A_resume,\n\t.shutdown = i8259A_shutdown,\n};\n\nstatic void mask_8259A(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\n\toutb(0xff, PIC_MASTER_IMR);\t \n\toutb(0xff, PIC_SLAVE_IMR);\t \n\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic void unmask_8259A(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\n\toutb(cached_master_mask, PIC_MASTER_IMR);  \n\toutb(cached_slave_mask, PIC_SLAVE_IMR);\t   \n\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic int probe_8259A(void)\n{\n\tunsigned char new_val, probe_val = ~(1 << PIC_CASCADE_IR);\n\tunsigned long flags;\n\n\t \n\tif (pcat_compat)\n\t\treturn nr_legacy_irqs();\n\n\t \n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\n\toutb(0xff, PIC_SLAVE_IMR);\t \n\toutb(probe_val, PIC_MASTER_IMR);\n\tnew_val = inb(PIC_MASTER_IMR);\n\tif (new_val != probe_val) {\n\t\tprintk(KERN_INFO \"Using NULL legacy PIC\\n\");\n\t\tlegacy_pic = &null_legacy_pic;\n\t}\n\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n\treturn nr_legacy_irqs();\n}\n\nstatic void init_8259A(int auto_eoi)\n{\n\tunsigned long flags;\n\n\ti8259A_auto_eoi = auto_eoi;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\n\toutb(0xff, PIC_MASTER_IMR);\t \n\n\t \n\toutb_pic(0x11, PIC_MASTER_CMD);\t \n\n\t \n\toutb_pic(ISA_IRQ_VECTOR(0), PIC_MASTER_IMR);\n\n\t \n\toutb_pic(1U << PIC_CASCADE_IR, PIC_MASTER_IMR);\n\n\tif (auto_eoi)\t \n\t\toutb_pic(MASTER_ICW4_DEFAULT | PIC_ICW4_AEOI, PIC_MASTER_IMR);\n\telse\t\t \n\t\toutb_pic(MASTER_ICW4_DEFAULT, PIC_MASTER_IMR);\n\n\toutb_pic(0x11, PIC_SLAVE_CMD);\t \n\n\t \n\toutb_pic(ISA_IRQ_VECTOR(8), PIC_SLAVE_IMR);\n\t \n\toutb_pic(PIC_CASCADE_IR, PIC_SLAVE_IMR);\n\t \n\toutb_pic(SLAVE_ICW4_DEFAULT, PIC_SLAVE_IMR);\n\n\tif (auto_eoi)\n\t\t \n\t\ti8259A_chip.irq_mask_ack = disable_8259A_irq;\n\telse\n\t\ti8259A_chip.irq_mask_ack = mask_and_ack_8259A;\n\n\tudelay(100);\t\t \n\n\toutb(cached_master_mask, PIC_MASTER_IMR);  \n\toutb(cached_slave_mask, PIC_SLAVE_IMR);\t   \n\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\n \n\nstatic void legacy_pic_noop(void) { };\nstatic void legacy_pic_uint_noop(unsigned int unused) { };\nstatic void legacy_pic_int_noop(int unused) { };\nstatic int legacy_pic_irq_pending_noop(unsigned int irq)\n{\n\treturn 0;\n}\nstatic int legacy_pic_probe(void)\n{\n\treturn 0;\n}\n\nstruct legacy_pic null_legacy_pic = {\n\t.nr_legacy_irqs = 0,\n\t.chip = &dummy_irq_chip,\n\t.mask = legacy_pic_uint_noop,\n\t.unmask = legacy_pic_uint_noop,\n\t.mask_all = legacy_pic_noop,\n\t.restore_mask = legacy_pic_noop,\n\t.init = legacy_pic_int_noop,\n\t.probe = legacy_pic_probe,\n\t.irq_pending = legacy_pic_irq_pending_noop,\n\t.make_irq = legacy_pic_uint_noop,\n};\n\nstatic struct legacy_pic default_legacy_pic = {\n\t.nr_legacy_irqs = NR_IRQS_LEGACY,\n\t.chip  = &i8259A_chip,\n\t.mask = mask_8259A_irq,\n\t.unmask = unmask_8259A_irq,\n\t.mask_all = mask_8259A,\n\t.restore_mask = unmask_8259A,\n\t.init = init_8259A,\n\t.probe = probe_8259A,\n\t.irq_pending = i8259A_irq_pending,\n\t.make_irq = make_8259A_irq,\n};\n\nstruct legacy_pic *legacy_pic = &default_legacy_pic;\nEXPORT_SYMBOL(legacy_pic);\n\nstatic int __init i8259A_init_ops(void)\n{\n\tif (legacy_pic == &default_legacy_pic)\n\t\tregister_syscore_ops(&i8259_syscore_ops);\n\n\treturn 0;\n}\ndevice_initcall(i8259A_init_ops);\n\nvoid __init legacy_pic_pcat_compat(void)\n{\n\tpcat_compat = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}