{
  "module_name": "rtc.c",
  "hash_id": "2cb6b36c55b3296815e04b063d76ef16d59937db508f304d88aab92860ff8beb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/rtc.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/mc146818rtc.h>\n#include <linux/export.h>\n#include <linux/pnp.h>\n\n#include <asm/vsyscall.h>\n#include <asm/x86_init.h>\n#include <asm/time.h>\n#include <asm/intel-mid.h>\n#include <asm/setup.h>\n\n#ifdef CONFIG_X86_32\n \nvolatile unsigned long cmos_lock;\nEXPORT_SYMBOL(cmos_lock);\n#endif  \n\nDEFINE_SPINLOCK(rtc_lock);\nEXPORT_SYMBOL(rtc_lock);\n\n \nint mach_set_cmos_time(const struct timespec64 *now)\n{\n\tunsigned long long nowtime = now->tv_sec;\n\tstruct rtc_time tm;\n\tint retval = 0;\n\n\trtc_time64_to_tm(nowtime, &tm);\n\tif (!rtc_valid_tm(&tm)) {\n\t\tretval = mc146818_set_time(&tm);\n\t\tif (retval)\n\t\t\tprintk(KERN_ERR \"%s: RTC write failed with error %d\\n\",\n\t\t\t       __func__, retval);\n\t} else {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Invalid RTC value: write of %llx to RTC failed\\n\",\n\t\t\t__func__, nowtime);\n\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\n\nvoid mach_get_cmos_time(struct timespec64 *now)\n{\n\tstruct rtc_time tm;\n\n\t \n\tif (!pm_trace_rtc_valid()) {\n\t\tnow->tv_sec = now->tv_nsec = 0;\n\t\treturn;\n\t}\n\n\tif (mc146818_get_time(&tm)) {\n\t\tpr_err(\"Unable to read current time from RTC\\n\");\n\t\tnow->tv_sec = now->tv_nsec = 0;\n\t\treturn;\n\t}\n\n\tnow->tv_sec = rtc_tm_to_time64(&tm);\n\tnow->tv_nsec = 0;\n}\n\n \nunsigned char rtc_cmos_read(unsigned char addr)\n{\n\tunsigned char val;\n\n\tlock_cmos_prefix(addr);\n\toutb(addr, RTC_PORT(0));\n\tval = inb(RTC_PORT(1));\n\tlock_cmos_suffix(addr);\n\n\treturn val;\n}\nEXPORT_SYMBOL(rtc_cmos_read);\n\nvoid rtc_cmos_write(unsigned char val, unsigned char addr)\n{\n\tlock_cmos_prefix(addr);\n\toutb(addr, RTC_PORT(0));\n\toutb(val, RTC_PORT(1));\n\tlock_cmos_suffix(addr);\n}\nEXPORT_SYMBOL(rtc_cmos_write);\n\nint update_persistent_clock64(struct timespec64 now)\n{\n\treturn x86_platform.set_wallclock(&now);\n}\n\n \nvoid read_persistent_clock64(struct timespec64 *ts)\n{\n\tx86_platform.get_wallclock(ts);\n}\n\n\nstatic struct resource rtc_resources[] = {\n\t[0] = {\n\t\t.start\t= RTC_PORT(0),\n\t\t.end\t= RTC_PORT(1),\n\t\t.flags\t= IORESOURCE_IO,\n\t},\n\t[1] = {\n\t\t.start\t= RTC_IRQ,\n\t\t.end\t= RTC_IRQ,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t}\n};\n\nstatic struct platform_device rtc_device = {\n\t.name\t\t= \"rtc_cmos\",\n\t.id\t\t= -1,\n\t.resource\t= rtc_resources,\n\t.num_resources\t= ARRAY_SIZE(rtc_resources),\n};\n\nstatic __init int add_rtc_cmos(void)\n{\n#ifdef CONFIG_PNP\n\tstatic const char * const ids[] __initconst =\n\t    { \"PNP0b00\", \"PNP0b01\", \"PNP0b02\", };\n\tstruct pnp_dev *dev;\n\tint i;\n\n\tpnp_for_each_dev(dev) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ids); i++) {\n\t\t\tif (compare_pnp_id(dev->id, ids[i]) != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (!x86_platform.legacy.rtc)\n\t\treturn -ENODEV;\n\n\tplatform_device_register(&rtc_device);\n\tdev_info(&rtc_device.dev,\n\t\t \"registered platform RTC device (no PNP device found)\\n\");\n\n\treturn 0;\n}\ndevice_initcall(add_rtc_cmos);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}