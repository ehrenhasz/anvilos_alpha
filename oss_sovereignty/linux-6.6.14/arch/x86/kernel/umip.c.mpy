{
  "module_name": "umip.c",
  "hash_id": "afd0a55468c2d267264311e9fb4bb35845e4559c2051741849da76cec5594d81",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/umip.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n#include <asm/umip.h>\n#include <asm/traps.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <linux/ratelimit.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"umip: \" fmt\n\n \n\n#define UMIP_DUMMY_GDT_BASE 0xfffffffffffe0000ULL\n#define UMIP_DUMMY_IDT_BASE 0xffffffffffff0000ULL\n\n \n#define UMIP_GDT_IDT_BASE_SIZE_64BIT 8\n#define UMIP_GDT_IDT_BASE_SIZE_32BIT 4\n#define UMIP_GDT_IDT_LIMIT_SIZE 2\n\n#define\tUMIP_INST_SGDT\t0\t \n#define\tUMIP_INST_SIDT\t1\t \n#define\tUMIP_INST_SMSW\t2\t \n#define\tUMIP_INST_SLDT  3        \n#define\tUMIP_INST_STR   4        \n\nstatic const char * const umip_insns[5] = {\n\t[UMIP_INST_SGDT] = \"SGDT\",\n\t[UMIP_INST_SIDT] = \"SIDT\",\n\t[UMIP_INST_SMSW] = \"SMSW\",\n\t[UMIP_INST_SLDT] = \"SLDT\",\n\t[UMIP_INST_STR] = \"STR\",\n};\n\n#define umip_pr_err(regs, fmt, ...) \\\n\tumip_printk(regs, KERN_ERR, fmt, ##__VA_ARGS__)\n#define umip_pr_debug(regs, fmt, ...) \\\n\tumip_printk(regs, KERN_DEBUG, fmt,  ##__VA_ARGS__)\n\n \nstatic __printf(3, 4)\nvoid umip_printk(const struct pt_regs *regs, const char *log_level,\n\t\t const char *fmt, ...)\n{\n\t \n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 2 * 60 * HZ, 5);\n\tstruct task_struct *tsk = current;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!__ratelimit(&ratelimit))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%s\" pr_fmt(\"%s[%d] ip:%lx sp:%lx: %pV\"), log_level, tsk->comm,\n\t       task_pid_nr(tsk), regs->ip, regs->sp, &vaf);\n\tva_end(args);\n}\n\n \nstatic int identify_insn(struct insn *insn)\n{\n\t \n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\t \n\tif (insn->opcode.bytes[0] != 0xf)\n\t\treturn -EINVAL;\n\n\tif (insn->opcode.bytes[1] == 0x1) {\n\t\tswitch (X86_MODRM_REG(insn->modrm.value)) {\n\t\tcase 0:\n\t\t\treturn UMIP_INST_SGDT;\n\t\tcase 1:\n\t\t\treturn UMIP_INST_SIDT;\n\t\tcase 4:\n\t\t\treturn UMIP_INST_SMSW;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (insn->opcode.bytes[1] == 0x0) {\n\t\tif (X86_MODRM_REG(insn->modrm.value) == 0)\n\t\t\treturn UMIP_INST_SLDT;\n\t\telse if (X86_MODRM_REG(insn->modrm.value) == 1)\n\t\t\treturn UMIP_INST_STR;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int emulate_umip_insn(struct insn *insn, int umip_inst,\n\t\t\t     unsigned char *data, int *data_size, bool x86_64)\n{\n\tif (!data || !data_size || !insn)\n\t\treturn -EINVAL;\n\t \n\tif (umip_inst == UMIP_INST_SGDT || umip_inst == UMIP_INST_SIDT) {\n\t\tu64 dummy_base_addr;\n\t\tu16 dummy_limit = 0;\n\n\t\t \n\t\tif (X86_MODRM_MOD(insn->modrm.value) == 3)\n\t\t\treturn -EINVAL;\n\n\t\tif (umip_inst == UMIP_INST_SGDT)\n\t\t\tdummy_base_addr = UMIP_DUMMY_GDT_BASE;\n\t\telse\n\t\t\tdummy_base_addr = UMIP_DUMMY_IDT_BASE;\n\n\t\t \n\t\tif (x86_64)\n\t\t\t*data_size = UMIP_GDT_IDT_BASE_SIZE_64BIT;\n\t\telse\n\t\t\t*data_size = UMIP_GDT_IDT_BASE_SIZE_32BIT;\n\n\t\tmemcpy(data + 2, &dummy_base_addr, *data_size);\n\n\t\t*data_size += UMIP_GDT_IDT_LIMIT_SIZE;\n\t\tmemcpy(data, &dummy_limit, UMIP_GDT_IDT_LIMIT_SIZE);\n\n\t} else if (umip_inst == UMIP_INST_SMSW || umip_inst == UMIP_INST_SLDT ||\n\t\t   umip_inst == UMIP_INST_STR) {\n\t\tunsigned long dummy_value;\n\n\t\tif (umip_inst == UMIP_INST_SMSW) {\n\t\t\tdummy_value = CR0_STATE;\n\t\t} else if (umip_inst == UMIP_INST_STR) {\n\t\t\tdummy_value = GDT_ENTRY_TSS * 8;\n\t\t} else if (umip_inst == UMIP_INST_SLDT) {\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\t\tdown_read(&current->mm->context.ldt_usr_sem);\n\t\t\tif (current->mm->context.ldt)\n\t\t\t\tdummy_value = GDT_ENTRY_LDT * 8;\n\t\t\telse\n\t\t\t\tdummy_value = 0;\n\t\t\tup_read(&current->mm->context.ldt_usr_sem);\n#else\n\t\t\tdummy_value = 0;\n#endif\n\t\t}\n\n\t\t \n\t\tif (X86_MODRM_MOD(insn->modrm.value) == 3)\n\t\t\t*data_size = insn->opnd_bytes;\n\t\telse\n\t\t\t*data_size = 2;\n\n\t\tmemcpy(data, &dummy_value, *data_size);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void force_sig_info_umip_fault(void __user *addr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\n\ttsk->thread.cr2\t\t= (unsigned long)addr;\n\ttsk->thread.error_code\t= X86_PF_USER | X86_PF_WRITE;\n\ttsk->thread.trap_nr\t= X86_TRAP_PF;\n\n\tforce_sig_fault(SIGSEGV, SEGV_MAPERR, addr);\n\n\tif (!(show_unhandled_signals && unhandled_signal(tsk, SIGSEGV)))\n\t\treturn;\n\n\tumip_pr_err(regs, \"segfault in emulation. error%x\\n\",\n\t\t    X86_PF_USER | X86_PF_WRITE);\n}\n\n \nbool fixup_umip_exception(struct pt_regs *regs)\n{\n\tint nr_copied, reg_offset, dummy_data_size, umip_inst;\n\t \n\tunsigned char dummy_data[10] = { 0 };\n\tunsigned char buf[MAX_INSN_SIZE];\n\tunsigned long *reg_addr;\n\tvoid __user *uaddr;\n\tstruct insn insn;\n\n\tif (!regs)\n\t\treturn false;\n\n\t \n\tnr_copied = insn_fetch_from_user(regs, buf);\n\tif (nr_copied <= 0)\n\t\treturn false;\n\n\tif (!insn_decode_from_regs(&insn, regs, buf, nr_copied))\n\t\treturn false;\n\n\tumip_inst = identify_insn(&insn);\n\tif (umip_inst < 0)\n\t\treturn false;\n\n\tumip_pr_debug(regs, \"%s instruction cannot be used by applications.\\n\",\n\t\t\tumip_insns[umip_inst]);\n\n\tumip_pr_debug(regs, \"For now, expensive software emulation returns the result.\\n\");\n\n\tif (emulate_umip_insn(&insn, umip_inst, dummy_data, &dummy_data_size,\n\t\t\t      user_64bit_mode(regs)))\n\t\treturn false;\n\n\t \n\tif (X86_MODRM_MOD(insn.modrm.value) == 3) {\n\t\treg_offset = insn_get_modrm_rm_off(&insn, regs);\n\n\t\t \n\t\tif (reg_offset < 0)\n\t\t\treturn false;\n\n\t\treg_addr = (unsigned long *)((unsigned long)regs + reg_offset);\n\t\tmemcpy(reg_addr, dummy_data, dummy_data_size);\n\t} else {\n\t\tuaddr = insn_get_addr_ref(&insn, regs);\n\t\tif ((unsigned long)uaddr == -1L)\n\t\t\treturn false;\n\n\t\tnr_copied = copy_to_user(uaddr, dummy_data, dummy_data_size);\n\t\tif (nr_copied  > 0) {\n\t\t\t \n\t\t\tforce_sig_info_umip_fault(uaddr, regs);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tregs->ip += insn.length;\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}