{
  "module_name": "tsc_msr.c",
  "hash_id": "de67ad3663c8339f83c0253dccba7fb173cad241b48f50702a139226b3408a6b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/tsc_msr.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/thread_info.h>\n\n#include <asm/apic.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/msr.h>\n#include <asm/param.h>\n#include <asm/tsc.h>\n\n#define MAX_NUM_FREQS\t16  \n\n \n#define TSC_REFERENCE_KHZ 100000\n\nstruct muldiv {\n\tu32 multiplier;\n\tu32 divider;\n};\n\n \nstruct freq_desc {\n\tbool use_msr_plat;\n\tstruct muldiv muldiv[MAX_NUM_FREQS];\n\t \n\tu32 freqs[MAX_NUM_FREQS];\n\tu32 mask;\n};\n\n \nstatic const struct freq_desc freq_desc_pnw = {\n\t.use_msr_plat = false,\n\t.freqs = { 0, 0, 0, 0, 0, 99840, 0, 83200 },\n\t.mask = 0x07,\n};\n\nstatic const struct freq_desc freq_desc_clv = {\n\t.use_msr_plat = false,\n\t.freqs = { 0, 133200, 0, 0, 0, 99840, 0, 83200 },\n\t.mask = 0x07,\n};\n\n \nstatic const struct freq_desc freq_desc_byt = {\n\t.use_msr_plat = true,\n\t.muldiv = { { 5, 6 }, { 1, 1 }, { 4, 3 }, { 7, 6 },\n\t\t    { 4, 5 } },\n\t.mask = 0x07,\n};\n\n \nstatic const struct freq_desc freq_desc_cht = {\n\t.use_msr_plat = true,\n\t.muldiv = { { 5, 6 }, {  1,  1 }, { 4,  3 }, { 7, 6 },\n\t\t    { 4, 5 }, { 14, 15 }, { 9, 10 }, { 8, 9 },\n\t\t    { 7, 8 } },\n\t.mask = 0x0f,\n};\n\n \nstatic const struct freq_desc freq_desc_tng = {\n\t.use_msr_plat = true,\n\t.muldiv = { { 0, 0 }, { 1, 1 }, { 4, 3 } },\n\t.mask = 0x07,\n};\n\n \nstatic const struct freq_desc freq_desc_ann = {\n\t.use_msr_plat = true,\n\t.muldiv = { { 5, 6 }, { 1, 1 }, { 4, 3 }, { 1, 1 } },\n\t.mask = 0x0f,\n};\n\n \nstatic const struct freq_desc freq_desc_lgm = {\n\t.use_msr_plat = true,\n\t.freqs = { 78000, 78000, 78000, 78000, 78000, 78000, 78000, 78000,\n\t\t   78000, 78000, 78000, 78000, 78000, 78000, 78000, 78000 },\n\t.mask = 0x0f,\n};\n\nstatic const struct x86_cpu_id tsc_msr_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_MID,\t&freq_desc_pnw),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_TABLET,&freq_desc_clv),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,\t&freq_desc_byt),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID,\t&freq_desc_tng),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,\t&freq_desc_cht),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_MID,\t&freq_desc_ann),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_NP,\t&freq_desc_lgm),\n\t{}\n};\n\n \nunsigned long cpu_khz_from_msr(void)\n{\n\tu32 lo, hi, ratio, freq, tscref;\n\tconst struct freq_desc *freq_desc;\n\tconst struct x86_cpu_id *id;\n\tconst struct muldiv *md;\n\tunsigned long res;\n\tint index;\n\n\tid = x86_match_cpu(tsc_msr_cpu_ids);\n\tif (!id)\n\t\treturn 0;\n\n\tfreq_desc = (struct freq_desc *)id->driver_data;\n\tif (freq_desc->use_msr_plat) {\n\t\trdmsr(MSR_PLATFORM_INFO, lo, hi);\n\t\tratio = (lo >> 8) & 0xff;\n\t} else {\n\t\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\t\tratio = (hi >> 8) & 0x1f;\n\t}\n\n\t \n\trdmsr(MSR_FSB_FREQ, lo, hi);\n\tindex = lo & freq_desc->mask;\n\tmd = &freq_desc->muldiv[index];\n\n\t \n\tif (md->divider) {\n\t\ttscref = TSC_REFERENCE_KHZ * md->multiplier;\n\t\tfreq = DIV_ROUND_CLOSEST(tscref, md->divider);\n\t\t \n\t\tres = DIV_ROUND_CLOSEST(tscref * ratio, md->divider);\n\t} else {\n\t\tfreq = freq_desc->freqs[index];\n\t\tres = freq * ratio;\n\t}\n\n\tif (freq == 0)\n\t\tpr_err(\"Error MSR_FSB_FREQ index %d is unknown\\n\", index);\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tlapic_timer_period = (freq * 1000) / HZ;\n#endif\n\n\t \n\tsetup_force_cpu_cap(X86_FEATURE_TSC_KNOWN_FREQ);\n\n\t \n\tsetup_force_cpu_cap(X86_FEATURE_TSC_RELIABLE);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}