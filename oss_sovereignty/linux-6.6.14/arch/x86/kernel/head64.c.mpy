{
  "module_name": "head64.c",
  "hash_id": "d22b7c58d198e11f54ba7cb906d675b374c6546601a2dc7d1d5eca1bbe7ac64b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/head64.c",
  "human_readable_source": "\n \n\n#define DISABLE_BRANCH_PROFILING\n\n \n#define USE_EARLY_PGTABLE_L5\n\n#include <linux/init.h>\n#include <linux/linkage.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/percpu.h>\n#include <linux/start_kernel.h>\n#include <linux/io.h>\n#include <linux/memblock.h>\n#include <linux/cc_platform.h>\n#include <linux/pgtable.h>\n\n#include <asm/processor.h>\n#include <asm/proto.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/kdebug.h>\n#include <asm/e820/api.h>\n#include <asm/bios_ebda.h>\n#include <asm/bootparam_utils.h>\n#include <asm/microcode.h>\n#include <asm/kasan.h>\n#include <asm/fixmap.h>\n#include <asm/realmode.h>\n#include <asm/extable.h>\n#include <asm/trapnr.h>\n#include <asm/sev.h>\n#include <asm/tdx.h>\n\n \nextern pmd_t early_dynamic_pgts[EARLY_DYNAMIC_PAGE_TABLES][PTRS_PER_PMD];\nstatic unsigned int __initdata next_early_pgt;\npmdval_t early_pmd_flags = __PAGE_KERNEL_LARGE & ~(_PAGE_GLOBAL | _PAGE_NX);\n\n#ifdef CONFIG_X86_5LEVEL\nunsigned int __pgtable_l5_enabled __ro_after_init;\nunsigned int pgdir_shift __ro_after_init = 39;\nEXPORT_SYMBOL(pgdir_shift);\nunsigned int ptrs_per_p4d __ro_after_init = 1;\nEXPORT_SYMBOL(ptrs_per_p4d);\n#endif\n\n#ifdef CONFIG_DYNAMIC_MEMORY_LAYOUT\nunsigned long page_offset_base __ro_after_init = __PAGE_OFFSET_BASE_L4;\nEXPORT_SYMBOL(page_offset_base);\nunsigned long vmalloc_base __ro_after_init = __VMALLOC_BASE_L4;\nEXPORT_SYMBOL(vmalloc_base);\nunsigned long vmemmap_base __ro_after_init = __VMEMMAP_BASE_L4;\nEXPORT_SYMBOL(vmemmap_base);\n#endif\n\n \nstatic struct desc_struct startup_gdt[GDT_ENTRIES] = {\n\t[GDT_ENTRY_KERNEL32_CS]         = GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),\n\t[GDT_ENTRY_KERNEL_CS]           = GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),\n\t[GDT_ENTRY_KERNEL_DS]           = GDT_ENTRY_INIT(0xc093, 0, 0xfffff),\n};\n\n \nstatic struct desc_ptr startup_gdt_descr = {\n\t.size = sizeof(startup_gdt)-1,\n\t.address = 0,\n};\n\n#define __head\t__section(\".head.text\")\n\nstatic void __head *fixup_pointer(void *ptr, unsigned long physaddr)\n{\n\treturn ptr - (void *)_text + (void *)physaddr;\n}\n\nstatic unsigned long __head *fixup_long(void *ptr, unsigned long physaddr)\n{\n\treturn fixup_pointer(ptr, physaddr);\n}\n\n#ifdef CONFIG_X86_5LEVEL\nstatic unsigned int __head *fixup_int(void *ptr, unsigned long physaddr)\n{\n\treturn fixup_pointer(ptr, physaddr);\n}\n\nstatic bool __head check_la57_support(unsigned long physaddr)\n{\n\t \n\tif (!(native_read_cr4() & X86_CR4_LA57))\n\t\treturn false;\n\n\t*fixup_int(&__pgtable_l5_enabled, physaddr) = 1;\n\t*fixup_int(&pgdir_shift, physaddr) = 48;\n\t*fixup_int(&ptrs_per_p4d, physaddr) = 512;\n\t*fixup_long(&page_offset_base, physaddr) = __PAGE_OFFSET_BASE_L5;\n\t*fixup_long(&vmalloc_base, physaddr) = __VMALLOC_BASE_L5;\n\t*fixup_long(&vmemmap_base, physaddr) = __VMEMMAP_BASE_L5;\n\n\treturn true;\n}\n#else\nstatic bool __head check_la57_support(unsigned long physaddr)\n{\n\treturn false;\n}\n#endif\n\nstatic unsigned long __head sme_postprocess_startup(struct boot_params *bp, pmdval_t *pmd)\n{\n\tunsigned long vaddr, vaddr_end;\n\tint i;\n\n\t \n\tsme_encrypt_kernel(bp);\n\n\t \n\tif (sme_get_me_mask()) {\n\t\tvaddr = (unsigned long)__start_bss_decrypted;\n\t\tvaddr_end = (unsigned long)__end_bss_decrypted;\n\n\t\tfor (; vaddr < vaddr_end; vaddr += PMD_SIZE) {\n\t\t\t \n\t\t\tearly_snp_set_memory_shared(__pa(vaddr), __pa(vaddr), PTRS_PER_PMD);\n\n\t\t\ti = pmd_index(vaddr);\n\t\t\tpmd[i] -= sme_get_me_mask();\n\t\t}\n\t}\n\n\t \n\treturn sme_get_me_mask();\n}\n\n \nunsigned long __head __startup_64(unsigned long physaddr,\n\t\t\t\t  struct boot_params *bp)\n{\n\tunsigned long load_delta, *p;\n\tunsigned long pgtable_flags;\n\tpgdval_t *pgd;\n\tp4dval_t *p4d;\n\tpudval_t *pud;\n\tpmdval_t *pmd, pmd_entry;\n\tpteval_t *mask_ptr;\n\tbool la57;\n\tint i;\n\tunsigned int *next_pgt_ptr;\n\n\tla57 = check_la57_support(physaddr);\n\n\t \n\tif (physaddr >> MAX_PHYSMEM_BITS)\n\t\tfor (;;);\n\n\t \n\tload_delta = physaddr - (unsigned long)(_text - __START_KERNEL_map);\n\n\t \n\tif (load_delta & ~PMD_MASK)\n\t\tfor (;;);\n\n\t \n\tload_delta += sme_get_me_mask();\n\n\t \n\n\tpgd = fixup_pointer(&early_top_pgt, physaddr);\n\tp = pgd + pgd_index(__START_KERNEL_map);\n\tif (la57)\n\t\t*p = (unsigned long)level4_kernel_pgt;\n\telse\n\t\t*p = (unsigned long)level3_kernel_pgt;\n\t*p += _PAGE_TABLE_NOENC - __START_KERNEL_map + load_delta;\n\n\tif (la57) {\n\t\tp4d = fixup_pointer(&level4_kernel_pgt, physaddr);\n\t\tp4d[511] += load_delta;\n\t}\n\n\tpud = fixup_pointer(&level3_kernel_pgt, physaddr);\n\tpud[510] += load_delta;\n\tpud[511] += load_delta;\n\n\tpmd = fixup_pointer(level2_fixmap_pgt, physaddr);\n\tfor (i = FIXMAP_PMD_TOP; i > FIXMAP_PMD_TOP - FIXMAP_PMD_NUM; i--)\n\t\tpmd[i] += load_delta;\n\n\t \n\n\tnext_pgt_ptr = fixup_pointer(&next_early_pgt, physaddr);\n\tpud = fixup_pointer(early_dynamic_pgts[(*next_pgt_ptr)++], physaddr);\n\tpmd = fixup_pointer(early_dynamic_pgts[(*next_pgt_ptr)++], physaddr);\n\n\tpgtable_flags = _KERNPG_TABLE_NOENC + sme_get_me_mask();\n\n\tif (la57) {\n\t\tp4d = fixup_pointer(early_dynamic_pgts[(*next_pgt_ptr)++],\n\t\t\t\t    physaddr);\n\n\t\ti = (physaddr >> PGDIR_SHIFT) % PTRS_PER_PGD;\n\t\tpgd[i + 0] = (pgdval_t)p4d + pgtable_flags;\n\t\tpgd[i + 1] = (pgdval_t)p4d + pgtable_flags;\n\n\t\ti = physaddr >> P4D_SHIFT;\n\t\tp4d[(i + 0) % PTRS_PER_P4D] = (pgdval_t)pud + pgtable_flags;\n\t\tp4d[(i + 1) % PTRS_PER_P4D] = (pgdval_t)pud + pgtable_flags;\n\t} else {\n\t\ti = (physaddr >> PGDIR_SHIFT) % PTRS_PER_PGD;\n\t\tpgd[i + 0] = (pgdval_t)pud + pgtable_flags;\n\t\tpgd[i + 1] = (pgdval_t)pud + pgtable_flags;\n\t}\n\n\ti = physaddr >> PUD_SHIFT;\n\tpud[(i + 0) % PTRS_PER_PUD] = (pudval_t)pmd + pgtable_flags;\n\tpud[(i + 1) % PTRS_PER_PUD] = (pudval_t)pmd + pgtable_flags;\n\n\tpmd_entry = __PAGE_KERNEL_LARGE_EXEC & ~_PAGE_GLOBAL;\n\t \n\tmask_ptr = fixup_pointer(&__supported_pte_mask, physaddr);\n\tpmd_entry &= *mask_ptr;\n\tpmd_entry += sme_get_me_mask();\n\tpmd_entry +=  physaddr;\n\n\tfor (i = 0; i < DIV_ROUND_UP(_end - _text, PMD_SIZE); i++) {\n\t\tint idx = i + (physaddr >> PMD_SHIFT);\n\n\t\tpmd[idx % PTRS_PER_PMD] = pmd_entry + i * PMD_SIZE;\n\t}\n\n\t \n\n\tpmd = fixup_pointer(level2_kernel_pgt, physaddr);\n\n\t \n\tfor (i = 0; i < pmd_index((unsigned long)_text); i++)\n\t\tpmd[i] &= ~_PAGE_PRESENT;\n\n\t \n\tfor (; i <= pmd_index((unsigned long)_end); i++)\n\t\tif (pmd[i] & _PAGE_PRESENT)\n\t\t\tpmd[i] += load_delta;\n\n\t \n\tfor (; i < PTRS_PER_PMD; i++)\n\t\tpmd[i] &= ~_PAGE_PRESENT;\n\n\t \n\t*fixup_long(&phys_base, physaddr) += load_delta - sme_get_me_mask();\n\n\treturn sme_postprocess_startup(bp, pmd);\n}\n\n \nstatic void __init reset_early_page_tables(void)\n{\n\tmemset(early_top_pgt, 0, sizeof(pgd_t)*(PTRS_PER_PGD-1));\n\tnext_early_pgt = 0;\n\twrite_cr3(__sme_pa_nodebug(early_top_pgt));\n}\n\n \nbool __init __early_make_pgtable(unsigned long address, pmdval_t pmd)\n{\n\tunsigned long physaddr = address - __PAGE_OFFSET;\n\tpgdval_t pgd, *pgd_p;\n\tp4dval_t p4d, *p4d_p;\n\tpudval_t pud, *pud_p;\n\tpmdval_t *pmd_p;\n\n\t \n\tif (physaddr >= MAXMEM || read_cr3_pa() != __pa_nodebug(early_top_pgt))\n\t\treturn false;\n\nagain:\n\tpgd_p = &early_top_pgt[pgd_index(address)].pgd;\n\tpgd = *pgd_p;\n\n\t \n\tif (!pgtable_l5_enabled())\n\t\tp4d_p = pgd_p;\n\telse if (pgd)\n\t\tp4d_p = (p4dval_t *)((pgd & PTE_PFN_MASK) + __START_KERNEL_map - phys_base);\n\telse {\n\t\tif (next_early_pgt >= EARLY_DYNAMIC_PAGE_TABLES) {\n\t\t\treset_early_page_tables();\n\t\t\tgoto again;\n\t\t}\n\n\t\tp4d_p = (p4dval_t *)early_dynamic_pgts[next_early_pgt++];\n\t\tmemset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);\n\t\t*pgd_p = (pgdval_t)p4d_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;\n\t}\n\tp4d_p += p4d_index(address);\n\tp4d = *p4d_p;\n\n\tif (p4d)\n\t\tpud_p = (pudval_t *)((p4d & PTE_PFN_MASK) + __START_KERNEL_map - phys_base);\n\telse {\n\t\tif (next_early_pgt >= EARLY_DYNAMIC_PAGE_TABLES) {\n\t\t\treset_early_page_tables();\n\t\t\tgoto again;\n\t\t}\n\n\t\tpud_p = (pudval_t *)early_dynamic_pgts[next_early_pgt++];\n\t\tmemset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);\n\t\t*p4d_p = (p4dval_t)pud_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;\n\t}\n\tpud_p += pud_index(address);\n\tpud = *pud_p;\n\n\tif (pud)\n\t\tpmd_p = (pmdval_t *)((pud & PTE_PFN_MASK) + __START_KERNEL_map - phys_base);\n\telse {\n\t\tif (next_early_pgt >= EARLY_DYNAMIC_PAGE_TABLES) {\n\t\t\treset_early_page_tables();\n\t\t\tgoto again;\n\t\t}\n\n\t\tpmd_p = (pmdval_t *)early_dynamic_pgts[next_early_pgt++];\n\t\tmemset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);\n\t\t*pud_p = (pudval_t)pmd_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;\n\t}\n\tpmd_p[pmd_index(address)] = pmd;\n\n\treturn true;\n}\n\nstatic bool __init early_make_pgtable(unsigned long address)\n{\n\tunsigned long physaddr = address - __PAGE_OFFSET;\n\tpmdval_t pmd;\n\n\tpmd = (physaddr & PMD_MASK) + early_pmd_flags;\n\n\treturn __early_make_pgtable(address, pmd);\n}\n\nvoid __init do_early_exception(struct pt_regs *regs, int trapnr)\n{\n\tif (trapnr == X86_TRAP_PF &&\n\t    early_make_pgtable(native_read_cr2()))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT) &&\n\t    trapnr == X86_TRAP_VC && handle_vc_boot_ghcb(regs))\n\t\treturn;\n\n\tif (trapnr == X86_TRAP_VE && tdx_early_handle_ve(regs))\n\t\treturn;\n\n\tearly_fixup_exception(regs, trapnr);\n}\n\n \nvoid __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n\tmemset(__brk_base, 0,\n\t       (unsigned long) __brk_limit - (unsigned long) __brk_base);\n}\n\nstatic unsigned long get_cmd_line_ptr(void)\n{\n\tunsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;\n\n\tcmd_line_ptr |= (u64)boot_params.ext_cmd_line_ptr << 32;\n\n\treturn cmd_line_ptr;\n}\n\nstatic void __init copy_bootdata(char *real_mode_data)\n{\n\tchar * command_line;\n\tunsigned long cmd_line_ptr;\n\n\t \n\tsme_map_bootdata(real_mode_data);\n\n\tmemcpy(&boot_params, real_mode_data, sizeof(boot_params));\n\tsanitize_boot_params(&boot_params);\n\tcmd_line_ptr = get_cmd_line_ptr();\n\tif (cmd_line_ptr) {\n\t\tcommand_line = __va(cmd_line_ptr);\n\t\tmemcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);\n\t}\n\n\t \n\tsme_unmap_bootdata(real_mode_data);\n}\n\nasmlinkage __visible void __init __noreturn x86_64_start_kernel(char * real_mode_data)\n{\n\t \n\tBUILD_BUG_ON(MODULES_VADDR < __START_KERNEL_map);\n\tBUILD_BUG_ON(MODULES_VADDR - __START_KERNEL_map < KERNEL_IMAGE_SIZE);\n\tBUILD_BUG_ON(MODULES_LEN + KERNEL_IMAGE_SIZE > 2*PUD_SIZE);\n\tBUILD_BUG_ON((__START_KERNEL_map & ~PMD_MASK) != 0);\n\tBUILD_BUG_ON((MODULES_VADDR & ~PMD_MASK) != 0);\n\tBUILD_BUG_ON(!(MODULES_VADDR > __START_KERNEL));\n\tMAYBE_BUILD_BUG_ON(!(((MODULES_END - 1) & PGDIR_MASK) ==\n\t\t\t\t(__START_KERNEL & PGDIR_MASK)));\n\tBUILD_BUG_ON(__fix_to_virt(__end_of_fixed_addresses) <= MODULES_END);\n\n\tcr4_init_shadow();\n\n\t \n\treset_early_page_tables();\n\n\tclear_bss();\n\n\t \n\tclear_page(init_top_pgt);\n\n\t \n\tsme_early_init();\n\n\tkasan_early_init();\n\n\t \n\t__native_tlb_flush_global(this_cpu_read(cpu_tlbstate.cr4));\n\n\tidt_setup_early_handler();\n\n\t \n\ttdx_early_init();\n\n\tcopy_bootdata(__va(real_mode_data));\n\n\t \n\tload_ucode_bsp();\n\n\t \n\tinit_top_pgt[511] = early_top_pgt[511];\n\n\tx86_64_start_reservations(real_mode_data);\n}\n\nvoid __init __noreturn x86_64_start_reservations(char *real_mode_data)\n{\n\t \n\tif (!boot_params.hdr.version)\n\t\tcopy_bootdata(__va(real_mode_data));\n\n\tx86_early_init_platform_quirks();\n\n\tswitch (boot_params.hdr.hardware_subarch) {\n\tcase X86_SUBARCH_INTEL_MID:\n\t\tx86_intel_mid_early_setup();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tstart_kernel();\n}\n\n \nstatic gate_desc bringup_idt_table[NUM_EXCEPTION_VECTORS] __page_aligned_data;\n\nstatic struct desc_ptr bringup_idt_descr = {\n\t.size\t\t= (NUM_EXCEPTION_VECTORS * sizeof(gate_desc)) - 1,\n\t.address\t= 0,  \n};\n\nstatic void set_bringup_idt_handler(gate_desc *idt, int n, void *handler)\n{\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n\tstruct idt_data data;\n\tgate_desc desc;\n\n\tinit_idt_data(&data, n, handler);\n\tidt_init_desc(&desc, &data);\n\tnative_write_idt_entry(idt, n, &desc);\n#endif\n}\n\n \nstatic void startup_64_load_idt(unsigned long physbase)\n{\n\tstruct desc_ptr *desc = fixup_pointer(&bringup_idt_descr, physbase);\n\tgate_desc *idt = fixup_pointer(bringup_idt_table, physbase);\n\n\n\tif (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {\n\t\tvoid *handler;\n\n\t\t \n\t\thandler = fixup_pointer(vc_no_ghcb, physbase);\n\t\tset_bringup_idt_handler(idt, X86_TRAP_VC, handler);\n\t}\n\n\tdesc->address = (unsigned long)idt;\n\tnative_load_idt(desc);\n}\n\n \nvoid early_setup_idt(void)\n{\n\t \n\tif (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {\n\t\tsetup_ghcb();\n\t\tset_bringup_idt_handler(bringup_idt_table, X86_TRAP_VC, vc_boot_ghcb);\n\t}\n\n\tbringup_idt_descr.address = (unsigned long)bringup_idt_table;\n\tnative_load_idt(&bringup_idt_descr);\n}\n\n \nvoid __head startup_64_setup_env(unsigned long physbase)\n{\n\t \n\tstartup_gdt_descr.address = (unsigned long)fixup_pointer(startup_gdt, physbase);\n\tnative_load_gdt(&startup_gdt_descr);\n\n\t \n\tasm volatile(\"movl %%eax, %%ds\\n\"\n\t\t     \"movl %%eax, %%ss\\n\"\n\t\t     \"movl %%eax, %%es\\n\" : : \"a\"(__KERNEL_DS) : \"memory\");\n\n\tstartup_64_load_idt(physbase);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}