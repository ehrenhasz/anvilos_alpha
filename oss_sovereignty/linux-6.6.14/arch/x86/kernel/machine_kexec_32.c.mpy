{
  "module_name": "machine_kexec_32.c",
  "hash_id": "6bc6070610d2a01d0ab820a6ff46425cc324d071522d40447a5da8f177765a6c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/machine_kexec_32.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/numa.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n\n#include <asm/pgalloc.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/cpufeature.h>\n#include <asm/desc.h>\n#include <asm/set_memory.h>\n#include <asm/debugreg.h>\n\nstatic void load_segments(void)\n{\n#define __STR(X) #X\n#define STR(X) __STR(X)\n\n\t__asm__ __volatile__ (\n\t\t\"\\tljmp $\"STR(__KERNEL_CS)\",$1f\\n\"\n\t\t\"\\t1:\\n\"\n\t\t\"\\tmovl $\"STR(__KERNEL_DS)\",%%eax\\n\"\n\t\t\"\\tmovl %%eax,%%ds\\n\"\n\t\t\"\\tmovl %%eax,%%es\\n\"\n\t\t\"\\tmovl %%eax,%%ss\\n\"\n\t\t: : : \"eax\", \"memory\");\n#undef STR\n#undef __STR\n}\n\nstatic void machine_kexec_free_page_tables(struct kimage *image)\n{\n\tfree_pages((unsigned long)image->arch.pgd, PGD_ALLOCATION_ORDER);\n\timage->arch.pgd = NULL;\n#ifdef CONFIG_X86_PAE\n\tfree_page((unsigned long)image->arch.pmd0);\n\timage->arch.pmd0 = NULL;\n\tfree_page((unsigned long)image->arch.pmd1);\n\timage->arch.pmd1 = NULL;\n#endif\n\tfree_page((unsigned long)image->arch.pte0);\n\timage->arch.pte0 = NULL;\n\tfree_page((unsigned long)image->arch.pte1);\n\timage->arch.pte1 = NULL;\n}\n\nstatic int machine_kexec_alloc_page_tables(struct kimage *image)\n{\n\timage->arch.pgd = (pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t\t    PGD_ALLOCATION_ORDER);\n#ifdef CONFIG_X86_PAE\n\timage->arch.pmd0 = (pmd_t *)get_zeroed_page(GFP_KERNEL);\n\timage->arch.pmd1 = (pmd_t *)get_zeroed_page(GFP_KERNEL);\n#endif\n\timage->arch.pte0 = (pte_t *)get_zeroed_page(GFP_KERNEL);\n\timage->arch.pte1 = (pte_t *)get_zeroed_page(GFP_KERNEL);\n\tif (!image->arch.pgd ||\n#ifdef CONFIG_X86_PAE\n\t    !image->arch.pmd0 || !image->arch.pmd1 ||\n#endif\n\t    !image->arch.pte0 || !image->arch.pte1) {\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void machine_kexec_page_table_set_one(\n\tpgd_t *pgd, pmd_t *pmd, pte_t *pte,\n\tunsigned long vaddr, unsigned long paddr)\n{\n\tp4d_t *p4d;\n\tpud_t *pud;\n\n\tpgd += pgd_index(vaddr);\n#ifdef CONFIG_X86_PAE\n\tif (!(pgd_val(*pgd) & _PAGE_PRESENT))\n\t\tset_pgd(pgd, __pgd(__pa(pmd) | _PAGE_PRESENT));\n#endif\n\tp4d = p4d_offset(pgd, vaddr);\n\tpud = pud_offset(p4d, vaddr);\n\tpmd = pmd_offset(pud, vaddr);\n\tif (!(pmd_val(*pmd) & _PAGE_PRESENT))\n\t\tset_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));\n\tpte = pte_offset_kernel(pmd, vaddr);\n\tset_pte(pte, pfn_pte(paddr >> PAGE_SHIFT, PAGE_KERNEL_EXEC));\n}\n\nstatic void machine_kexec_prepare_page_tables(struct kimage *image)\n{\n\tvoid *control_page;\n\tpmd_t *pmd = NULL;\n\n\tcontrol_page = page_address(image->control_code_page);\n#ifdef CONFIG_X86_PAE\n\tpmd = image->arch.pmd0;\n#endif\n\tmachine_kexec_page_table_set_one(\n\t\timage->arch.pgd, pmd, image->arch.pte0,\n\t\t(unsigned long)control_page, __pa(control_page));\n#ifdef CONFIG_X86_PAE\n\tpmd = image->arch.pmd1;\n#endif\n\tmachine_kexec_page_table_set_one(\n\t\timage->arch.pgd, pmd, image->arch.pte1,\n\t\t__pa(control_page), __pa(control_page));\n}\n\n \nint machine_kexec_prepare(struct kimage *image)\n{\n\tint error;\n\n\tset_memory_x((unsigned long)page_address(image->control_code_page), 1);\n\terror = machine_kexec_alloc_page_tables(image);\n\tif (error)\n\t\treturn error;\n\tmachine_kexec_prepare_page_tables(image);\n\treturn 0;\n}\n\n \nvoid machine_kexec_cleanup(struct kimage *image)\n{\n\tset_memory_nx((unsigned long)page_address(image->control_code_page), 1);\n\tmachine_kexec_free_page_tables(image);\n}\n\n \nvoid machine_kexec(struct kimage *image)\n{\n\tunsigned long page_list[PAGES_NR];\n\tvoid *control_page;\n\tint save_ftrace_enabled;\n\tasmlinkage unsigned long\n\t\t(*relocate_kernel_ptr)(unsigned long indirection_page,\n\t\t\t\t       unsigned long control_page,\n\t\t\t\t       unsigned long start_address,\n\t\t\t\t       unsigned int has_pae,\n\t\t\t\t       unsigned int preserve_context);\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (image->preserve_context)\n\t\tsave_processor_state();\n#endif\n\n\tsave_ftrace_enabled = __ftrace_enabled_save();\n\n\t \n\tlocal_irq_disable();\n\thw_breakpoint_disable();\n\n\tif (image->preserve_context) {\n#ifdef CONFIG_X86_IO_APIC\n\t\t \n\t\tclear_IO_APIC();\n\t\trestore_boot_irq_mode();\n#endif\n\t}\n\n\tcontrol_page = page_address(image->control_code_page);\n\tmemcpy(control_page, relocate_kernel, KEXEC_CONTROL_CODE_MAX_SIZE);\n\n\trelocate_kernel_ptr = control_page;\n\tpage_list[PA_CONTROL_PAGE] = __pa(control_page);\n\tpage_list[VA_CONTROL_PAGE] = (unsigned long)control_page;\n\tpage_list[PA_PGD] = __pa(image->arch.pgd);\n\n\tif (image->type == KEXEC_TYPE_DEFAULT)\n\t\tpage_list[PA_SWAP_PAGE] = (page_to_pfn(image->swap_page)\n\t\t\t\t\t\t<< PAGE_SHIFT);\n\n\t \n\tload_segments();\n\t \n\tnative_idt_invalidate();\n\tnative_gdt_invalidate();\n\n\t \n\timage->start = relocate_kernel_ptr((unsigned long)image->head,\n\t\t\t\t\t   (unsigned long)page_list,\n\t\t\t\t\t   image->start,\n\t\t\t\t\t   boot_cpu_has(X86_FEATURE_PAE),\n\t\t\t\t\t   image->preserve_context);\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (image->preserve_context)\n\t\trestore_processor_state();\n#endif\n\n\t__ftrace_enabled_restore(save_ftrace_enabled);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}