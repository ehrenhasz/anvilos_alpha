{
  "module_name": "dumpstack.c",
  "hash_id": "f1fcace29c36d66acf8b6eacd6c2056d325482686de9bd8470639266654fe754",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/dumpstack.c",
  "human_readable_source": " \n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n#include <linux/ftrace.h>\n#include <linux/kexec.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n#include <linux/sysfs.h>\n#include <linux/kasan.h>\n\n#include <asm/cpu_entry_area.h>\n#include <asm/stacktrace.h>\n#include <asm/unwind.h>\n\nint panic_on_unrecovered_nmi;\nint panic_on_io_nmi;\nstatic int die_counter;\n\nstatic struct pt_regs exec_summary_regs;\n\nbool noinstr in_task_stack(unsigned long *stack, struct task_struct *task,\n\t\t\t   struct stack_info *info)\n{\n\tunsigned long *begin = task_stack_page(task);\n\tunsigned long *end   = task_stack_page(task) + THREAD_SIZE;\n\n\tif (stack < begin || stack >= end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_TASK;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\tinfo->next_sp\t= NULL;\n\n\treturn true;\n}\n\n \nbool noinstr in_entry_stack(unsigned long *stack, struct stack_info *info)\n{\n\tstruct entry_stack *ss = cpu_entry_stack(smp_processor_id());\n\n\tvoid *begin = ss;\n\tvoid *end = ss + 1;\n\n\tif ((void *)stack < begin || (void *)stack >= end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_ENTRY;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\tinfo->next_sp\t= NULL;\n\n\treturn true;\n}\n\nstatic void printk_stack_address(unsigned long address, int reliable,\n\t\t\t\t const char *log_lvl)\n{\n\ttouch_nmi_watchdog();\n\tprintk(\"%s %s%pBb\\n\", log_lvl, reliable ? \"\" : \"? \", (void *)address);\n}\n\nstatic int copy_code(struct pt_regs *regs, u8 *buf, unsigned long src,\n\t\t     unsigned int nbytes)\n{\n\tif (!user_mode(regs))\n\t\treturn copy_from_kernel_nofault(buf, (u8 *)src, nbytes);\n\n\t \n\tif (regs != task_pt_regs(current))\n\t\treturn -EPERM;\n\n\t \n\treturn copy_from_user_nmi(buf, (void __user *)src, nbytes);\n}\n\n \nvoid show_opcodes(struct pt_regs *regs, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tunsigned long prologue = regs->ip - PROLOGUE_SIZE;\n\n\tswitch (copy_code(regs, opcodes, prologue, sizeof(opcodes))) {\n\tcase 0:\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t\tbreak;\n\tcase -EPERM:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%sCode: Unable to access opcode bytes at 0x%lx.\\n\",\n\t\t       loglvl, prologue);\n\t\tbreak;\n\t}\n}\n\nvoid show_ip(struct pt_regs *regs, const char *loglvl)\n{\n#ifdef CONFIG_X86_32\n\tprintk(\"%sEIP: %pS\\n\", loglvl, (void *)regs->ip);\n#else\n\tprintk(\"%sRIP: %04x:%pS\\n\", loglvl, (int)regs->cs, (void *)regs->ip);\n#endif\n\tshow_opcodes(regs, loglvl);\n}\n\nvoid show_iret_regs(struct pt_regs *regs, const char *log_lvl)\n{\n\tshow_ip(regs, log_lvl);\n\tprintk(\"%sRSP: %04x:%016lx EFLAGS: %08lx\", log_lvl, (int)regs->ss,\n\t\tregs->sp, regs->flags);\n}\n\nstatic void show_regs_if_on_stack(struct stack_info *info, struct pt_regs *regs,\n\t\t\t\t  bool partial, const char *log_lvl)\n{\n\t \n\tif (!partial && on_stack(info, regs, sizeof(*regs))) {\n\t\t__show_regs(regs, SHOW_REGS_SHORT, log_lvl);\n\n\t} else if (partial && on_stack(info, (void *)regs + IRET_FRAME_OFFSET,\n\t\t\t\t       IRET_FRAME_SIZE)) {\n\t\t \n\t\tshow_iret_regs(regs, log_lvl);\n\t}\n}\n\n \n__no_kmsan_checks\nstatic void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,\n\t\t\tunsigned long *stack, const char *log_lvl)\n{\n\tstruct unwind_state state;\n\tstruct stack_info stack_info = {0};\n\tunsigned long visit_mask = 0;\n\tint graph_idx = 0;\n\tbool partial = false;\n\n\tprintk(\"%sCall Trace:\\n\", log_lvl);\n\n\tunwind_start(&state, task, regs, stack);\n\tregs = unwind_get_entry_regs(&state, &partial);\n\n\t \n\tfor (stack = stack ?: get_stack_pointer(task, regs);\n\t     stack;\n\t     stack = stack_info.next_sp) {\n\t\tconst char *stack_name;\n\n\t\tstack = PTR_ALIGN(stack, sizeof(long));\n\n\t\tif (get_stack_info(stack, task, &stack_info, &visit_mask)) {\n\t\t\t \n\t\t\tstack = (unsigned long *)PAGE_ALIGN((unsigned long)stack);\n\t\t\tif (get_stack_info(stack, task, &stack_info, &visit_mask))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstack_name = stack_type_name(stack_info.type);\n\t\tif (stack_name)\n\t\t\tprintk(\"%s <%s>\\n\", log_lvl, stack_name);\n\n\t\tif (regs)\n\t\t\tshow_regs_if_on_stack(&stack_info, regs, partial, log_lvl);\n\n\t\t \n\t\tfor (; stack < stack_info.end; stack++) {\n\t\t\tunsigned long real_addr;\n\t\t\tint reliable = 0;\n\t\t\tunsigned long addr = READ_ONCE_NOCHECK(*stack);\n\t\t\tunsigned long *ret_addr_p =\n\t\t\t\tunwind_get_return_address_ptr(&state);\n\n\t\t\tif (!__kernel_text_address(addr))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (regs && stack == &regs->ip)\n\t\t\t\tgoto next;\n\n\t\t\tif (stack == ret_addr_p)\n\t\t\t\treliable = 1;\n\n\t\t\t \n\t\t\treal_addr = ftrace_graph_ret_addr(task, &graph_idx,\n\t\t\t\t\t\t\t  addr, stack);\n\t\t\tif (real_addr != addr)\n\t\t\t\tprintk_stack_address(addr, 0, log_lvl);\n\t\t\tprintk_stack_address(real_addr, reliable, log_lvl);\n\n\t\t\tif (!reliable)\n\t\t\t\tcontinue;\n\nnext:\n\t\t\t \n\t\t\tunwind_next_frame(&state);\n\n\t\t\t \n\t\t\tregs = unwind_get_entry_regs(&state, &partial);\n\t\t\tif (regs)\n\t\t\t\tshow_regs_if_on_stack(&stack_info, regs, partial, log_lvl);\n\t\t}\n\n\t\tif (stack_name)\n\t\t\tprintk(\"%s </%s>\\n\", log_lvl, stack_name);\n\t}\n}\n\nvoid show_stack(struct task_struct *task, unsigned long *sp,\n\t\t       const char *loglvl)\n{\n\ttask = task ? : current;\n\n\t \n\tif (!sp && task == current)\n\t\tsp = get_stack_pointer(current, NULL);\n\n\tshow_trace_log_lvl(task, NULL, sp, loglvl);\n}\n\nvoid show_stack_regs(struct pt_regs *regs)\n{\n\tshow_trace_log_lvl(current, regs, NULL, KERN_DEFAULT);\n}\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nunsigned long oops_begin(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\toops_enter();\n\n\t \n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t ;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\treturn flags;\n}\nNOKPROBE_SYMBOL(oops_begin);\n\nvoid __noreturn rewind_stack_and_make_dead(int signr);\n\nvoid oops_end(unsigned long flags, struct pt_regs *regs, int signr)\n{\n\tif (regs && kexec_should_crash(current))\n\t\tcrash_kexec(regs);\n\n\tbust_spinlocks(0);\n\tdie_owner = -1;\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\tif (!die_nest_count)\n\t\t \n\t\tarch_spin_unlock(&die_lock);\n\traw_local_irq_restore(flags);\n\toops_exit();\n\n\t \n\t__show_regs(&exec_summary_regs, SHOW_REGS_ALL, KERN_DEFAULT);\n\n\tif (!signr)\n\t\treturn;\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\n\t \n\tkasan_unpoison_task_stack(current);\n\trewind_stack_and_make_dead(signr);\n}\nNOKPROBE_SYMBOL(oops_end);\n\nstatic void __die_header(const char *str, struct pt_regs *regs, long err)\n{\n\tconst char *pr = \"\";\n\n\t \n\tif (!die_counter)\n\t\texec_summary_regs = *regs;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\tpr = IS_ENABLED(CONFIG_PREEMPT_RT) ? \" PREEMPT_RT\" : \" PREEMPT\";\n\n\tprintk(KERN_DEFAULT\n\t       \"%s: %04lx [#%d]%s%s%s%s%s\\n\", str, err & 0xffff, ++die_counter,\n\t       pr,\n\t       IS_ENABLED(CONFIG_SMP)     ? \" SMP\"             : \"\",\n\t       debug_pagealloc_enabled()  ? \" DEBUG_PAGEALLOC\" : \"\",\n\t       IS_ENABLED(CONFIG_KASAN)   ? \" KASAN\"           : \"\",\n\t       IS_ENABLED(CONFIG_PAGE_TABLE_ISOLATION) ?\n\t       (boot_cpu_has(X86_FEATURE_PTI) ? \" PTI\" : \" NOPTI\") : \"\");\n}\nNOKPROBE_SYMBOL(__die_header);\n\nstatic int __die_body(const char *str, struct pt_regs *regs, long err)\n{\n\tshow_regs(regs);\n\tprint_modules();\n\n\tif (notify_die(DIE_OOPS, str, regs, err,\n\t\t\tcurrent->thread.trap_nr, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\treturn 0;\n}\nNOKPROBE_SYMBOL(__die_body);\n\nint __die(const char *str, struct pt_regs *regs, long err)\n{\n\t__die_header(str, regs, err);\n\treturn __die_body(str, regs, err);\n}\nNOKPROBE_SYMBOL(__die);\n\n \nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin();\n\tint sig = SIGSEGV;\n\n\tif (__die(str, regs, err))\n\t\tsig = 0;\n\toops_end(flags, regs, sig);\n}\n\nvoid die_addr(const char *str, struct pt_regs *regs, long err, long gp_addr)\n{\n\tunsigned long flags = oops_begin();\n\tint sig = SIGSEGV;\n\n\t__die_header(str, regs, err);\n\tif (gp_addr)\n\t\tkasan_non_canonical_hook(gp_addr);\n\tif (__die_body(str, regs, err))\n\t\tsig = 0;\n\toops_end(flags, regs, sig);\n}\n\nvoid show_regs(struct pt_regs *regs)\n{\n\tenum show_regs_mode print_kernel_regs;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprint_kernel_regs = user_mode(regs) ? SHOW_REGS_USER : SHOW_REGS_ALL;\n\t__show_regs(regs, print_kernel_regs, KERN_DEFAULT);\n\n\t \n\tif (!user_mode(regs))\n\t\tshow_trace_log_lvl(current, regs, NULL, KERN_DEFAULT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}