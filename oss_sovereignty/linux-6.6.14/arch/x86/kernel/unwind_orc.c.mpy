{
  "module_name": "unwind_orc.c",
  "hash_id": "7a045a23251a006c7c2fb87a3239e108c972805a13b894b1f359eca38ca42512",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/unwind_orc.c",
  "human_readable_source": "\n#include <linux/objtool.h>\n#include <linux/module.h>\n#include <linux/sort.h>\n#include <asm/ptrace.h>\n#include <asm/stacktrace.h>\n#include <asm/unwind.h>\n#include <asm/orc_types.h>\n#include <asm/orc_lookup.h>\n#include <asm/orc_header.h>\n\nORC_HEADER;\n\n#define orc_warn(fmt, ...) \\\n\tprintk_deferred_once(KERN_WARNING \"WARNING: \" fmt, ##__VA_ARGS__)\n\n#define orc_warn_current(args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstatic bool dumped_before;\t\t\t\t\t\\\n\tif (state->task == current && !state->error) {\t\t\t\\\n\t\torc_warn(args);\t\t\t\t\t\t\\\n\t\tif (unwind_debug && !dumped_before) {\t\t\t\\\n\t\t\tdumped_before = true;\t\t\t\t\\\n\t\t\tunwind_dump(state);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n})\n\nextern int __start_orc_unwind_ip[];\nextern int __stop_orc_unwind_ip[];\nextern struct orc_entry __start_orc_unwind[];\nextern struct orc_entry __stop_orc_unwind[];\n\nstatic bool orc_init __ro_after_init;\nstatic bool unwind_debug __ro_after_init;\nstatic unsigned int lookup_num_blocks __ro_after_init;\n\nstatic int __init unwind_debug_cmdline(char *str)\n{\n\tunwind_debug = true;\n\n\treturn 0;\n}\nearly_param(\"unwind_debug\", unwind_debug_cmdline);\n\nstatic void unwind_dump(struct unwind_state *state)\n{\n\tstatic bool dumped_before;\n\tunsigned long word, *sp;\n\tstruct stack_info stack_info = {0};\n\tunsigned long visit_mask = 0;\n\n\tif (dumped_before)\n\t\treturn;\n\n\tdumped_before = true;\n\n\tprintk_deferred(\"unwind stack type:%d next_sp:%p mask:0x%lx graph_idx:%d\\n\",\n\t\t\tstate->stack_info.type, state->stack_info.next_sp,\n\t\t\tstate->stack_mask, state->graph_idx);\n\n\tfor (sp = __builtin_frame_address(0); sp;\n\t     sp = PTR_ALIGN(stack_info.next_sp, sizeof(long))) {\n\t\tif (get_stack_info(sp, state->task, &stack_info, &visit_mask))\n\t\t\tbreak;\n\n\t\tfor (; sp < stack_info.end; sp++) {\n\n\t\t\tword = READ_ONCE_NOCHECK(*sp);\n\n\t\t\tprintk_deferred(\"%0*lx: %0*lx (%pB)\\n\", BITS_PER_LONG/4,\n\t\t\t\t\t(unsigned long)sp, BITS_PER_LONG/4,\n\t\t\t\t\tword, (void *)word);\n\t\t}\n\t}\n}\n\nstatic inline unsigned long orc_ip(const int *ip)\n{\n\treturn (unsigned long)ip + *ip;\n}\n\nstatic struct orc_entry *__orc_find(int *ip_table, struct orc_entry *u_table,\n\t\t\t\t    unsigned int num_entries, unsigned long ip)\n{\n\tint *first = ip_table;\n\tint *last = ip_table + num_entries - 1;\n\tint *mid = first, *found = first;\n\n\tif (!num_entries)\n\t\treturn NULL;\n\n\t \n\twhile (first <= last) {\n\t\tmid = first + ((last - first) / 2);\n\n\t\tif (orc_ip(mid) <= ip) {\n\t\t\tfound = mid;\n\t\t\tfirst = mid + 1;\n\t\t} else\n\t\t\tlast = mid - 1;\n\t}\n\n\treturn u_table + (found - ip_table);\n}\n\n#ifdef CONFIG_MODULES\nstatic struct orc_entry *orc_module_find(unsigned long ip)\n{\n\tstruct module *mod;\n\n\tmod = __module_address(ip);\n\tif (!mod || !mod->arch.orc_unwind || !mod->arch.orc_unwind_ip)\n\t\treturn NULL;\n\treturn __orc_find(mod->arch.orc_unwind_ip, mod->arch.orc_unwind,\n\t\t\t  mod->arch.num_orcs, ip);\n}\n#else\nstatic struct orc_entry *orc_module_find(unsigned long ip)\n{\n\treturn NULL;\n}\n#endif\n\n#ifdef CONFIG_DYNAMIC_FTRACE\nstatic struct orc_entry *orc_find(unsigned long ip);\n\n \nstatic struct orc_entry *orc_ftrace_find(unsigned long ip)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long tramp_addr, offset;\n\n\tops = ftrace_ops_trampoline(ip);\n\tif (!ops)\n\t\treturn NULL;\n\n\t \n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\ttramp_addr = (unsigned long)ftrace_regs_caller;\n\telse\n\t\ttramp_addr = (unsigned long)ftrace_caller;\n\n\t \n\toffset = ip - ops->trampoline;\n\ttramp_addr += offset;\n\n\t \n\tif (ip == tramp_addr)\n\t\treturn NULL;\n\n\treturn orc_find(tramp_addr);\n}\n#else\nstatic struct orc_entry *orc_ftrace_find(unsigned long ip)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic struct orc_entry null_orc_entry = {\n\t.sp_offset = sizeof(long),\n\t.sp_reg = ORC_REG_SP,\n\t.bp_reg = ORC_REG_UNDEFINED,\n\t.type = ORC_TYPE_CALL\n};\n\n \nstatic struct orc_entry orc_fp_entry = {\n\t.type\t\t= ORC_TYPE_CALL,\n\t.sp_reg\t\t= ORC_REG_BP,\n\t.sp_offset\t= 16,\n\t.bp_reg\t\t= ORC_REG_PREV_SP,\n\t.bp_offset\t= -16,\n};\n\nstatic struct orc_entry *orc_find(unsigned long ip)\n{\n\tstatic struct orc_entry *orc;\n\n\tif (ip == 0)\n\t\treturn &null_orc_entry;\n\n\t \n\tif (ip >= LOOKUP_START_IP && ip < LOOKUP_STOP_IP) {\n\t\tunsigned int idx, start, stop;\n\n\t\tidx = (ip - LOOKUP_START_IP) / LOOKUP_BLOCK_SIZE;\n\n\t\tif (unlikely((idx >= lookup_num_blocks-1))) {\n\t\t\torc_warn(\"WARNING: bad lookup idx: idx=%u num=%u ip=%pB\\n\",\n\t\t\t\t idx, lookup_num_blocks, (void *)ip);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstart = orc_lookup[idx];\n\t\tstop = orc_lookup[idx + 1] + 1;\n\n\t\tif (unlikely((__start_orc_unwind + start >= __stop_orc_unwind) ||\n\t\t\t     (__start_orc_unwind + stop > __stop_orc_unwind))) {\n\t\t\torc_warn(\"WARNING: bad lookup value: idx=%u num=%u start=%u stop=%u ip=%pB\\n\",\n\t\t\t\t idx, lookup_num_blocks, start, stop, (void *)ip);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn __orc_find(__start_orc_unwind_ip + start,\n\t\t\t\t  __start_orc_unwind + start, stop - start, ip);\n\t}\n\n\t \n\tif (is_kernel_inittext(ip))\n\t\treturn __orc_find(__start_orc_unwind_ip, __start_orc_unwind,\n\t\t\t\t  __stop_orc_unwind_ip - __start_orc_unwind_ip, ip);\n\n\t \n\torc = orc_module_find(ip);\n\tif (orc)\n\t\treturn orc;\n\n\treturn orc_ftrace_find(ip);\n}\n\n#ifdef CONFIG_MODULES\n\nstatic DEFINE_MUTEX(sort_mutex);\nstatic int *cur_orc_ip_table = __start_orc_unwind_ip;\nstatic struct orc_entry *cur_orc_table = __start_orc_unwind;\n\nstatic void orc_sort_swap(void *_a, void *_b, int size)\n{\n\tstruct orc_entry *orc_a, *orc_b;\n\tint *a = _a, *b = _b, tmp;\n\tint delta = _b - _a;\n\n\t \n\ttmp = *a;\n\t*a = *b + delta;\n\t*b = tmp - delta;\n\n\t \n\torc_a = cur_orc_table + (a - cur_orc_ip_table);\n\torc_b = cur_orc_table + (b - cur_orc_ip_table);\n\tswap(*orc_a, *orc_b);\n}\n\nstatic int orc_sort_cmp(const void *_a, const void *_b)\n{\n\tstruct orc_entry *orc_a;\n\tconst int *a = _a, *b = _b;\n\tunsigned long a_val = orc_ip(a);\n\tunsigned long b_val = orc_ip(b);\n\n\tif (a_val > b_val)\n\t\treturn 1;\n\tif (a_val < b_val)\n\t\treturn -1;\n\n\t \n\torc_a = cur_orc_table + (a - cur_orc_ip_table);\n\treturn orc_a->type == ORC_TYPE_UNDEFINED ? -1 : 1;\n}\n\nvoid unwind_module_init(struct module *mod, void *_orc_ip, size_t orc_ip_size,\n\t\t\tvoid *_orc, size_t orc_size)\n{\n\tint *orc_ip = _orc_ip;\n\tstruct orc_entry *orc = _orc;\n\tunsigned int num_entries = orc_ip_size / sizeof(int);\n\n\tWARN_ON_ONCE(orc_ip_size % sizeof(int) != 0 ||\n\t\t     orc_size % sizeof(*orc) != 0 ||\n\t\t     num_entries != orc_size / sizeof(*orc));\n\n\t \n\tmutex_lock(&sort_mutex);\n\tcur_orc_ip_table = orc_ip;\n\tcur_orc_table = orc;\n\tsort(orc_ip, num_entries, sizeof(int), orc_sort_cmp, orc_sort_swap);\n\tmutex_unlock(&sort_mutex);\n\n\tmod->arch.orc_unwind_ip = orc_ip;\n\tmod->arch.orc_unwind = orc;\n\tmod->arch.num_orcs = num_entries;\n}\n#endif\n\nvoid __init unwind_init(void)\n{\n\tsize_t orc_ip_size = (void *)__stop_orc_unwind_ip - (void *)__start_orc_unwind_ip;\n\tsize_t orc_size = (void *)__stop_orc_unwind - (void *)__start_orc_unwind;\n\tsize_t num_entries = orc_ip_size / sizeof(int);\n\tstruct orc_entry *orc;\n\tint i;\n\n\tif (!num_entries || orc_ip_size % sizeof(int) != 0 ||\n\t    orc_size % sizeof(struct orc_entry) != 0 ||\n\t    num_entries != orc_size / sizeof(struct orc_entry)) {\n\t\torc_warn(\"WARNING: Bad or missing .orc_unwind table.  Disabling unwinder.\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tlookup_num_blocks = orc_lookup_end - orc_lookup;\n\tfor (i = 0; i < lookup_num_blocks-1; i++) {\n\t\torc = __orc_find(__start_orc_unwind_ip, __start_orc_unwind,\n\t\t\t\t num_entries,\n\t\t\t\t LOOKUP_START_IP + (LOOKUP_BLOCK_SIZE * i));\n\t\tif (!orc) {\n\t\t\torc_warn(\"WARNING: Corrupt .orc_unwind table.  Disabling unwinder.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\torc_lookup[i] = orc - __start_orc_unwind;\n\t}\n\n\t \n\torc = __orc_find(__start_orc_unwind_ip, __start_orc_unwind, num_entries,\n\t\t\t LOOKUP_STOP_IP);\n\tif (!orc) {\n\t\torc_warn(\"WARNING: Corrupt .orc_unwind table.  Disabling unwinder.\\n\");\n\t\treturn;\n\t}\n\torc_lookup[lookup_num_blocks-1] = orc - __start_orc_unwind;\n\n\torc_init = true;\n}\n\nunsigned long unwind_get_return_address(struct unwind_state *state)\n{\n\tif (unwind_done(state))\n\t\treturn 0;\n\n\treturn __kernel_text_address(state->ip) ? state->ip : 0;\n}\nEXPORT_SYMBOL_GPL(unwind_get_return_address);\n\nunsigned long *unwind_get_return_address_ptr(struct unwind_state *state)\n{\n\tif (unwind_done(state))\n\t\treturn NULL;\n\n\tif (state->regs)\n\t\treturn &state->regs->ip;\n\n\tif (state->sp)\n\t\treturn (unsigned long *)state->sp - 1;\n\n\treturn NULL;\n}\n\nstatic bool stack_access_ok(struct unwind_state *state, unsigned long _addr,\n\t\t\t    size_t len)\n{\n\tstruct stack_info *info = &state->stack_info;\n\tvoid *addr = (void *)_addr;\n\n\tif (on_stack(info, addr, len))\n\t\treturn true;\n\n\treturn !get_stack_info(addr, state->task, info, &state->stack_mask) &&\n\t\ton_stack(info, addr, len);\n}\n\nstatic bool deref_stack_reg(struct unwind_state *state, unsigned long addr,\n\t\t\t    unsigned long *val)\n{\n\tif (!stack_access_ok(state, addr, sizeof(long)))\n\t\treturn false;\n\n\t*val = READ_ONCE_NOCHECK(*(unsigned long *)addr);\n\treturn true;\n}\n\nstatic bool deref_stack_regs(struct unwind_state *state, unsigned long addr,\n\t\t\t     unsigned long *ip, unsigned long *sp)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)addr;\n\n\t \n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_X86_32));\n\n\tif (!stack_access_ok(state, addr, sizeof(struct pt_regs)))\n\t\treturn false;\n\n\t*ip = READ_ONCE_NOCHECK(regs->ip);\n\t*sp = READ_ONCE_NOCHECK(regs->sp);\n\treturn true;\n}\n\nstatic bool deref_stack_iret_regs(struct unwind_state *state, unsigned long addr,\n\t\t\t\t  unsigned long *ip, unsigned long *sp)\n{\n\tstruct pt_regs *regs = (void *)addr - IRET_FRAME_OFFSET;\n\n\tif (!stack_access_ok(state, addr, IRET_FRAME_SIZE))\n\t\treturn false;\n\n\t*ip = READ_ONCE_NOCHECK(regs->ip);\n\t*sp = READ_ONCE_NOCHECK(regs->sp);\n\treturn true;\n}\n\n \nstatic bool get_reg(struct unwind_state *state, unsigned int reg_off,\n\t\t    unsigned long *val)\n{\n\tunsigned int reg = reg_off/8;\n\n\tif (!state->regs)\n\t\treturn false;\n\n\tif (state->full_regs) {\n\t\t*val = READ_ONCE_NOCHECK(((unsigned long *)state->regs)[reg]);\n\t\treturn true;\n\t}\n\n\tif (state->prev_regs) {\n\t\t*val = READ_ONCE_NOCHECK(((unsigned long *)state->prev_regs)[reg]);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool unwind_next_frame(struct unwind_state *state)\n{\n\tunsigned long ip_p, sp, tmp, orig_ip = state->ip, prev_sp = state->sp;\n\tenum stack_type prev_type = state->stack_info.type;\n\tstruct orc_entry *orc;\n\tbool indirect = false;\n\n\tif (unwind_done(state))\n\t\treturn false;\n\n\t \n\tpreempt_disable();\n\n\t \n\tif (state->regs && user_mode(state->regs))\n\t\tgoto the_end;\n\n\t \n\torc = orc_find(state->signal ? state->ip : state->ip - 1);\n\tif (!orc) {\n\t\t \n\t\torc = &orc_fp_entry;\n\t\tstate->error = true;\n\t} else {\n\t\tif (orc->type == ORC_TYPE_UNDEFINED)\n\t\t\tgoto err;\n\n\t\tif (orc->type == ORC_TYPE_END_OF_STACK)\n\t\t\tgoto the_end;\n\t}\n\n\tstate->signal = orc->signal;\n\n\t \n\tswitch (orc->sp_reg) {\n\tcase ORC_REG_SP:\n\t\tsp = state->sp + orc->sp_offset;\n\t\tbreak;\n\n\tcase ORC_REG_BP:\n\t\tsp = state->bp + orc->sp_offset;\n\t\tbreak;\n\n\tcase ORC_REG_SP_INDIRECT:\n\t\tsp = state->sp;\n\t\tindirect = true;\n\t\tbreak;\n\n\tcase ORC_REG_BP_INDIRECT:\n\t\tsp = state->bp + orc->sp_offset;\n\t\tindirect = true;\n\t\tbreak;\n\n\tcase ORC_REG_R10:\n\t\tif (!get_reg(state, offsetof(struct pt_regs, r10), &sp)) {\n\t\t\torc_warn_current(\"missing R10 value at %pB\\n\",\n\t\t\t\t\t (void *)state->ip);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tcase ORC_REG_R13:\n\t\tif (!get_reg(state, offsetof(struct pt_regs, r13), &sp)) {\n\t\t\torc_warn_current(\"missing R13 value at %pB\\n\",\n\t\t\t\t\t (void *)state->ip);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tcase ORC_REG_DI:\n\t\tif (!get_reg(state, offsetof(struct pt_regs, di), &sp)) {\n\t\t\torc_warn_current(\"missing RDI value at %pB\\n\",\n\t\t\t\t\t (void *)state->ip);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tcase ORC_REG_DX:\n\t\tif (!get_reg(state, offsetof(struct pt_regs, dx), &sp)) {\n\t\t\torc_warn_current(\"missing DX value at %pB\\n\",\n\t\t\t\t\t (void *)state->ip);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\torc_warn(\"unknown SP base reg %d at %pB\\n\",\n\t\t\t orc->sp_reg, (void *)state->ip);\n\t\tgoto err;\n\t}\n\n\tif (indirect) {\n\t\tif (!deref_stack_reg(state, sp, &sp))\n\t\t\tgoto err;\n\n\t\tif (orc->sp_reg == ORC_REG_SP_INDIRECT)\n\t\t\tsp += orc->sp_offset;\n\t}\n\n\t \n\tswitch (orc->type) {\n\tcase ORC_TYPE_CALL:\n\t\tip_p = sp - sizeof(long);\n\n\t\tif (!deref_stack_reg(state, ip_p, &state->ip))\n\t\t\tgoto err;\n\n\t\tstate->ip = unwind_recover_ret_addr(state, state->ip,\n\t\t\t\t\t\t    (unsigned long *)ip_p);\n\t\tstate->sp = sp;\n\t\tstate->regs = NULL;\n\t\tstate->prev_regs = NULL;\n\t\tbreak;\n\n\tcase ORC_TYPE_REGS:\n\t\tif (!deref_stack_regs(state, sp, &state->ip, &state->sp)) {\n\t\t\torc_warn_current(\"can't access registers at %pB\\n\",\n\t\t\t\t\t (void *)orig_ip);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tstate->ip = unwind_recover_rethook(state, state->ip,\n\t\t\t\t(unsigned long *)(state->sp - sizeof(long)));\n\t\tstate->regs = (struct pt_regs *)sp;\n\t\tstate->prev_regs = NULL;\n\t\tstate->full_regs = true;\n\t\tbreak;\n\n\tcase ORC_TYPE_REGS_PARTIAL:\n\t\tif (!deref_stack_iret_regs(state, sp, &state->ip, &state->sp)) {\n\t\t\torc_warn_current(\"can't access iret registers at %pB\\n\",\n\t\t\t\t\t (void *)orig_ip);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tstate->ip = unwind_recover_rethook(state, state->ip,\n\t\t\t\t(unsigned long *)(state->sp - sizeof(long)));\n\n\t\tif (state->full_regs)\n\t\t\tstate->prev_regs = state->regs;\n\t\tstate->regs = (void *)sp - IRET_FRAME_OFFSET;\n\t\tstate->full_regs = false;\n\t\tbreak;\n\n\tdefault:\n\t\torc_warn(\"unknown .orc_unwind entry type %d at %pB\\n\",\n\t\t\t orc->type, (void *)orig_ip);\n\t\tgoto err;\n\t}\n\n\t \n\tswitch (orc->bp_reg) {\n\tcase ORC_REG_UNDEFINED:\n\t\tif (get_reg(state, offsetof(struct pt_regs, bp), &tmp))\n\t\t\tstate->bp = tmp;\n\t\tbreak;\n\n\tcase ORC_REG_PREV_SP:\n\t\tif (!deref_stack_reg(state, sp + orc->bp_offset, &state->bp))\n\t\t\tgoto err;\n\t\tbreak;\n\n\tcase ORC_REG_BP:\n\t\tif (!deref_stack_reg(state, state->bp + orc->bp_offset, &state->bp))\n\t\t\tgoto err;\n\t\tbreak;\n\n\tdefault:\n\t\torc_warn(\"unknown BP base reg %d for ip %pB\\n\",\n\t\t\t orc->bp_reg, (void *)orig_ip);\n\t\tgoto err;\n\t}\n\n\t \n\tif (state->stack_info.type == prev_type &&\n\t    on_stack(&state->stack_info, (void *)state->sp, sizeof(long)) &&\n\t    state->sp <= prev_sp) {\n\t\torc_warn_current(\"stack going in the wrong direction? at %pB\\n\",\n\t\t\t\t (void *)orig_ip);\n\t\tgoto err;\n\t}\n\n\tpreempt_enable();\n\treturn true;\n\nerr:\n\tstate->error = true;\n\nthe_end:\n\tpreempt_enable();\n\tstate->stack_info.type = STACK_TYPE_UNKNOWN;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(unwind_next_frame);\n\nvoid __unwind_start(struct unwind_state *state, struct task_struct *task,\n\t\t    struct pt_regs *regs, unsigned long *first_frame)\n{\n\tmemset(state, 0, sizeof(*state));\n\tstate->task = task;\n\n\tif (!orc_init)\n\t\tgoto err;\n\n\t \n\tif (task_on_another_cpu(task))\n\t\tgoto err;\n\n\tif (regs) {\n\t\tif (user_mode(regs))\n\t\t\tgoto the_end;\n\n\t\tstate->ip = regs->ip;\n\t\tstate->sp = regs->sp;\n\t\tstate->bp = regs->bp;\n\t\tstate->regs = regs;\n\t\tstate->full_regs = true;\n\t\tstate->signal = true;\n\n\t} else if (task == current) {\n\t\tasm volatile(\"lea (%%rip), %0\\n\\t\"\n\t\t\t     \"mov %%rsp, %1\\n\\t\"\n\t\t\t     \"mov %%rbp, %2\\n\\t\"\n\t\t\t     : \"=r\" (state->ip), \"=r\" (state->sp),\n\t\t\t       \"=r\" (state->bp));\n\n\t} else {\n\t\tstruct inactive_task_frame *frame = (void *)task->thread.sp;\n\n\t\tstate->sp = task->thread.sp + sizeof(*frame);\n\t\tstate->bp = READ_ONCE_NOCHECK(frame->bp);\n\t\tstate->ip = READ_ONCE_NOCHECK(frame->ret_addr);\n\t\tstate->signal = (void *)state->ip == ret_from_fork;\n\t}\n\n\tif (get_stack_info((unsigned long *)state->sp, state->task,\n\t\t\t   &state->stack_info, &state->stack_mask)) {\n\t\t \n\t\tvoid *next_page = (void *)PAGE_ALIGN((unsigned long)state->sp);\n\t\tstate->error = true;\n\t\tif (get_stack_info(next_page, state->task, &state->stack_info,\n\t\t\t\t   &state->stack_mask))\n\t\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (regs) {\n\t\tunwind_next_frame(state);\n\t\treturn;\n\t}\n\n\t \n\twhile (!unwind_done(state) &&\n\t       (!on_stack(&state->stack_info, first_frame, sizeof(long)) ||\n\t\t\tstate->sp <= (unsigned long)first_frame))\n\t\tunwind_next_frame(state);\n\n\treturn;\n\nerr:\n\tstate->error = true;\nthe_end:\n\tstate->stack_info.type = STACK_TYPE_UNKNOWN;\n}\nEXPORT_SYMBOL_GPL(__unwind_start);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}