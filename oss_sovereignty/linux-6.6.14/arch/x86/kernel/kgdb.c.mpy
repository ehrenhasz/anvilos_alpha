{
  "module_name": "kgdb.c",
  "hash_id": "26711136ec3b33f6f629e475bcde63afc62f217e68e9ff915dc15863e8a02602",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/kgdb.c",
  "human_readable_source": "\n \n\n \n \n#include <linux/spinlock.h>\n#include <linux/kdebug.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/kgdb.h>\n#include <linux/smp.h>\n#include <linux/nmi.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\n#include <asm/text-patching.h>\n#include <asm/debugreg.h>\n#include <asm/apicdef.h>\n#include <asm/apic.h>\n#include <asm/nmi.h>\n#include <asm/switch_to.h>\n\nstruct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =\n{\n#ifdef CONFIG_X86_32\n\t{ \"ax\", 4, offsetof(struct pt_regs, ax) },\n\t{ \"cx\", 4, offsetof(struct pt_regs, cx) },\n\t{ \"dx\", 4, offsetof(struct pt_regs, dx) },\n\t{ \"bx\", 4, offsetof(struct pt_regs, bx) },\n\t{ \"sp\", 4, offsetof(struct pt_regs, sp) },\n\t{ \"bp\", 4, offsetof(struct pt_regs, bp) },\n\t{ \"si\", 4, offsetof(struct pt_regs, si) },\n\t{ \"di\", 4, offsetof(struct pt_regs, di) },\n\t{ \"ip\", 4, offsetof(struct pt_regs, ip) },\n\t{ \"flags\", 4, offsetof(struct pt_regs, flags) },\n\t{ \"cs\", 4, offsetof(struct pt_regs, cs) },\n\t{ \"ss\", 4, offsetof(struct pt_regs, ss) },\n\t{ \"ds\", 4, offsetof(struct pt_regs, ds) },\n\t{ \"es\", 4, offsetof(struct pt_regs, es) },\n#else\n\t{ \"ax\", 8, offsetof(struct pt_regs, ax) },\n\t{ \"bx\", 8, offsetof(struct pt_regs, bx) },\n\t{ \"cx\", 8, offsetof(struct pt_regs, cx) },\n\t{ \"dx\", 8, offsetof(struct pt_regs, dx) },\n\t{ \"si\", 8, offsetof(struct pt_regs, si) },\n\t{ \"di\", 8, offsetof(struct pt_regs, di) },\n\t{ \"bp\", 8, offsetof(struct pt_regs, bp) },\n\t{ \"sp\", 8, offsetof(struct pt_regs, sp) },\n\t{ \"r8\", 8, offsetof(struct pt_regs, r8) },\n\t{ \"r9\", 8, offsetof(struct pt_regs, r9) },\n\t{ \"r10\", 8, offsetof(struct pt_regs, r10) },\n\t{ \"r11\", 8, offsetof(struct pt_regs, r11) },\n\t{ \"r12\", 8, offsetof(struct pt_regs, r12) },\n\t{ \"r13\", 8, offsetof(struct pt_regs, r13) },\n\t{ \"r14\", 8, offsetof(struct pt_regs, r14) },\n\t{ \"r15\", 8, offsetof(struct pt_regs, r15) },\n\t{ \"ip\", 8, offsetof(struct pt_regs, ip) },\n\t{ \"flags\", 4, offsetof(struct pt_regs, flags) },\n\t{ \"cs\", 4, offsetof(struct pt_regs, cs) },\n\t{ \"ss\", 4, offsetof(struct pt_regs, ss) },\n\t{ \"ds\", 4, -1 },\n\t{ \"es\", 4, -1 },\n#endif\n\t{ \"fs\", 4, -1 },\n\t{ \"gs\", 4, -1 },\n};\n\nint dbg_set_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (\n#ifdef CONFIG_X86_32\n\t    regno == GDB_SS || regno == GDB_FS || regno == GDB_GS ||\n#endif\n\t    regno == GDB_SP || regno == GDB_ORIG_AX)\n\t\treturn 0;\n\n\tif (dbg_reg_def[regno].offset != -1)\n\t\tmemcpy((void *)regs + dbg_reg_def[regno].offset, mem,\n\t\t       dbg_reg_def[regno].size);\n\treturn 0;\n}\n\nchar *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno == GDB_ORIG_AX) {\n\t\tmemcpy(mem, &regs->orig_ax, sizeof(regs->orig_ax));\n\t\treturn \"orig_ax\";\n\t}\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn NULL;\n\n\tif (dbg_reg_def[regno].offset != -1)\n\t\tmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\n\t\t       dbg_reg_def[regno].size);\n\n#ifdef CONFIG_X86_32\n\tswitch (regno) {\n\tcase GDB_GS:\n\tcase GDB_FS:\n\t\t*(unsigned long *)mem = 0xFFFF;\n\t\tbreak;\n\t}\n#endif\n\treturn dbg_reg_def[regno].name;\n}\n\n \nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\n{\n#ifndef CONFIG_X86_32\n\tu32 *gdb_regs32 = (u32 *)gdb_regs;\n#endif\n\tgdb_regs[GDB_AX]\t= 0;\n\tgdb_regs[GDB_BX]\t= 0;\n\tgdb_regs[GDB_CX]\t= 0;\n\tgdb_regs[GDB_DX]\t= 0;\n\tgdb_regs[GDB_SI]\t= 0;\n\tgdb_regs[GDB_DI]\t= 0;\n\tgdb_regs[GDB_BP]\t= ((struct inactive_task_frame *)p->thread.sp)->bp;\n#ifdef CONFIG_X86_32\n\tgdb_regs[GDB_DS]\t= __KERNEL_DS;\n\tgdb_regs[GDB_ES]\t= __KERNEL_DS;\n\tgdb_regs[GDB_PS]\t= 0;\n\tgdb_regs[GDB_CS]\t= __KERNEL_CS;\n\tgdb_regs[GDB_SS]\t= __KERNEL_DS;\n\tgdb_regs[GDB_FS]\t= 0xFFFF;\n\tgdb_regs[GDB_GS]\t= 0xFFFF;\n#else\n\tgdb_regs32[GDB_PS]\t= 0;\n\tgdb_regs32[GDB_CS]\t= __KERNEL_CS;\n\tgdb_regs32[GDB_SS]\t= __KERNEL_DS;\n\tgdb_regs[GDB_R8]\t= 0;\n\tgdb_regs[GDB_R9]\t= 0;\n\tgdb_regs[GDB_R10]\t= 0;\n\tgdb_regs[GDB_R11]\t= 0;\n\tgdb_regs[GDB_R12]\t= 0;\n\tgdb_regs[GDB_R13]\t= 0;\n\tgdb_regs[GDB_R14]\t= 0;\n\tgdb_regs[GDB_R15]\t= 0;\n#endif\n\tgdb_regs[GDB_PC]\t= 0;\n\tgdb_regs[GDB_SP]\t= p->thread.sp;\n}\n\nstatic struct hw_breakpoint {\n\tunsigned\t\tenabled;\n\tunsigned long\t\taddr;\n\tint\t\t\tlen;\n\tint\t\t\ttype;\n\tstruct perf_event\t* __percpu *pev;\n} breakinfo[HBP_NUM];\n\nstatic unsigned long early_dr7;\n\nstatic void kgdb_correct_hw_break(void)\n{\n\tint breakno;\n\n\tfor (breakno = 0; breakno < HBP_NUM; breakno++) {\n\t\tstruct perf_event *bp;\n\t\tstruct arch_hw_breakpoint *info;\n\t\tint val;\n\t\tint cpu = raw_smp_processor_id();\n\t\tif (!breakinfo[breakno].enabled)\n\t\t\tcontinue;\n\t\tif (dbg_is_early) {\n\t\t\tset_debugreg(breakinfo[breakno].addr, breakno);\n\t\t\tearly_dr7 |= encode_dr7(breakno,\n\t\t\t\t\t\tbreakinfo[breakno].len,\n\t\t\t\t\t\tbreakinfo[breakno].type);\n\t\t\tset_debugreg(early_dr7, 7);\n\t\t\tcontinue;\n\t\t}\n\t\tbp = *per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tinfo = counter_arch_bp(bp);\n\t\tif (bp->attr.disabled != 1)\n\t\t\tcontinue;\n\t\tbp->attr.bp_addr = breakinfo[breakno].addr;\n\t\tbp->attr.bp_len = breakinfo[breakno].len;\n\t\tbp->attr.bp_type = breakinfo[breakno].type;\n\t\tinfo->address = breakinfo[breakno].addr;\n\t\tinfo->len = breakinfo[breakno].len;\n\t\tinfo->type = breakinfo[breakno].type;\n\t\tval = arch_install_hw_breakpoint(bp);\n\t\tif (!val)\n\t\t\tbp->attr.disabled = 0;\n\t}\n\tif (!dbg_is_early)\n\t\thw_breakpoint_restore();\n}\n\nstatic int hw_break_reserve_slot(int breakno)\n{\n\tint cpu;\n\tint cnt = 0;\n\tstruct perf_event **pevent;\n\n\tif (dbg_is_early)\n\t\treturn 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tcnt++;\n\t\tpevent = per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tif (dbg_reserve_bp_slot(*pevent))\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tfor_each_online_cpu(cpu) {\n\t\tcnt--;\n\t\tif (!cnt)\n\t\t\tbreak;\n\t\tpevent = per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tdbg_release_bp_slot(*pevent);\n\t}\n\treturn -1;\n}\n\nstatic int hw_break_release_slot(int breakno)\n{\n\tstruct perf_event **pevent;\n\tint cpu;\n\n\tif (dbg_is_early)\n\t\treturn 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tpevent = per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tif (dbg_release_bp_slot(*pevent))\n\t\t\t \n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nkgdb_remove_hw_break(unsigned long addr, int len, enum kgdb_bptype bptype)\n{\n\tint i;\n\n\tfor (i = 0; i < HBP_NUM; i++)\n\t\tif (breakinfo[i].addr == addr && breakinfo[i].enabled)\n\t\t\tbreak;\n\tif (i == HBP_NUM)\n\t\treturn -1;\n\n\tif (hw_break_release_slot(i)) {\n\t\tprintk(KERN_ERR \"Cannot remove hw breakpoint at %lx\\n\", addr);\n\t\treturn -1;\n\t}\n\tbreakinfo[i].enabled = 0;\n\n\treturn 0;\n}\n\nstatic void kgdb_remove_all_hw_break(void)\n{\n\tint i;\n\tint cpu = raw_smp_processor_id();\n\tstruct perf_event *bp;\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (!breakinfo[i].enabled)\n\t\t\tcontinue;\n\t\tbp = *per_cpu_ptr(breakinfo[i].pev, cpu);\n\t\tif (!bp->attr.disabled) {\n\t\t\tarch_uninstall_hw_breakpoint(bp);\n\t\t\tbp->attr.disabled = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dbg_is_early)\n\t\t\tearly_dr7 &= ~encode_dr7(i, breakinfo[i].len,\n\t\t\t\t\t\t breakinfo[i].type);\n\t\telse if (hw_break_release_slot(i))\n\t\t\tprintk(KERN_ERR \"KGDB: hw bpt remove failed %lx\\n\",\n\t\t\t       breakinfo[i].addr);\n\t\tbreakinfo[i].enabled = 0;\n\t}\n}\n\nstatic int\nkgdb_set_hw_break(unsigned long addr, int len, enum kgdb_bptype bptype)\n{\n\tint i;\n\n\tfor (i = 0; i < HBP_NUM; i++)\n\t\tif (!breakinfo[i].enabled)\n\t\t\tbreak;\n\tif (i == HBP_NUM)\n\t\treturn -1;\n\n\tswitch (bptype) {\n\tcase BP_HARDWARE_BREAKPOINT:\n\t\tlen = 1;\n\t\tbreakinfo[i].type = X86_BREAKPOINT_EXECUTE;\n\t\tbreak;\n\tcase BP_WRITE_WATCHPOINT:\n\t\tbreakinfo[i].type = X86_BREAKPOINT_WRITE;\n\t\tbreak;\n\tcase BP_ACCESS_WATCHPOINT:\n\t\tbreakinfo[i].type = X86_BREAKPOINT_RW;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tbreakinfo[i].len = X86_BREAKPOINT_LEN_1;\n\t\tbreak;\n\tcase 2:\n\t\tbreakinfo[i].len = X86_BREAKPOINT_LEN_2;\n\t\tbreak;\n\tcase 4:\n\t\tbreakinfo[i].len = X86_BREAKPOINT_LEN_4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase 8:\n\t\tbreakinfo[i].len = X86_BREAKPOINT_LEN_8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -1;\n\t}\n\tbreakinfo[i].addr = addr;\n\tif (hw_break_reserve_slot(i)) {\n\t\tbreakinfo[i].addr = 0;\n\t\treturn -1;\n\t}\n\tbreakinfo[i].enabled = 1;\n\n\treturn 0;\n}\n\n \nstatic void kgdb_disable_hw_debug(struct pt_regs *regs)\n{\n\tint i;\n\tint cpu = raw_smp_processor_id();\n\tstruct perf_event *bp;\n\n\t \n\tset_debugreg(0UL, 7);\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (!breakinfo[i].enabled)\n\t\t\tcontinue;\n\t\tif (dbg_is_early) {\n\t\t\tearly_dr7 &= ~encode_dr7(i, breakinfo[i].len,\n\t\t\t\t\t\t breakinfo[i].type);\n\t\t\tcontinue;\n\t\t}\n\t\tbp = *per_cpu_ptr(breakinfo[i].pev, cpu);\n\t\tif (bp->attr.disabled == 1)\n\t\t\tcontinue;\n\t\tarch_uninstall_hw_breakpoint(bp);\n\t\tbp->attr.disabled = 1;\n\t}\n}\n\n#ifdef CONFIG_SMP\n \nvoid kgdb_roundup_cpus(void)\n{\n\tapic_send_IPI_allbutself(NMI_VECTOR);\n}\n#endif\n\n \nint kgdb_arch_handle_exception(int e_vector, int signo, int err_code,\n\t\t\t       char *remcomInBuffer, char *remcomOutBuffer,\n\t\t\t       struct pt_regs *linux_regs)\n{\n\tunsigned long addr;\n\tchar *ptr;\n\n\tswitch (remcomInBuffer[0]) {\n\tcase 'c':\n\tcase 's':\n\t\t \n\t\tptr = &remcomInBuffer[1];\n\t\tif (kgdb_hex2long(&ptr, &addr))\n\t\t\tlinux_regs->ip = addr;\n\t\tfallthrough;\n\tcase 'D':\n\tcase 'k':\n\t\t \n\t\tlinux_regs->flags &= ~X86_EFLAGS_TF;\n\t\tatomic_set(&kgdb_cpu_doing_single_step, -1);\n\n\t\t \n\t\tif (remcomInBuffer[0] == 's') {\n\t\t\tlinux_regs->flags |= X86_EFLAGS_TF;\n\t\t\tatomic_set(&kgdb_cpu_doing_single_step,\n\t\t\t\t   raw_smp_processor_id());\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic inline int\nsingle_step_cont(struct pt_regs *regs, struct die_args *args)\n{\n\t \n\tprintk(KERN_ERR \"KGDB: trap/step from kernel to user space, \"\n\t\t\t\"resuming...\\n\");\n\tkgdb_arch_handle_exception(args->trapnr, args->signr,\n\t\t\t\t   args->err, \"c\", \"\", regs);\n\t \n\t(*(unsigned long *)ERR_PTR(args->err)) &= ~DR_STEP;\n\n\treturn NOTIFY_STOP;\n}\n\nstatic DECLARE_BITMAP(was_in_debug_nmi, NR_CPUS);\n\nstatic int kgdb_nmi_handler(unsigned int cmd, struct pt_regs *regs)\n{\n\tint cpu;\n\n\tswitch (cmd) {\n\tcase NMI_LOCAL:\n\t\tif (atomic_read(&kgdb_active) != -1) {\n\t\t\t \n\t\t\tcpu = raw_smp_processor_id();\n\t\t\tkgdb_nmicallback(cpu, regs);\n\t\t\tset_bit(cpu, was_in_debug_nmi);\n\t\t\ttouch_nmi_watchdog();\n\n\t\t\treturn NMI_HANDLED;\n\t\t}\n\t\tbreak;\n\n\tcase NMI_UNKNOWN:\n\t\tcpu = raw_smp_processor_id();\n\n\t\tif (__test_and_clear_bit(cpu, was_in_debug_nmi))\n\t\t\treturn NMI_HANDLED;\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn NMI_DONE;\n}\n\nstatic int __kgdb_notify(struct die_args *args, unsigned long cmd)\n{\n\tstruct pt_regs *regs = args->regs;\n\n\tswitch (cmd) {\n\tcase DIE_DEBUG:\n\t\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\t\tif (user_mode(regs))\n\t\t\t\treturn single_step_cont(regs, args);\n\t\t\tbreak;\n\t\t} else if (test_thread_flag(TIF_SINGLESTEP))\n\t\t\t \n\t\t\treturn NOTIFY_DONE;\n\t\tfallthrough;\n\tdefault:\n\t\tif (user_mode(regs))\n\t\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (kgdb_handle_exception(args->trapnr, args->signr, cmd, regs))\n\t\treturn NOTIFY_DONE;\n\n\t \n\ttouch_nmi_watchdog();\n\treturn NOTIFY_STOP;\n}\n\nint kgdb_ll_trap(int cmd, const char *str,\n\t\t struct pt_regs *regs, long err, int trap, int sig)\n{\n\tstruct die_args args = {\n\t\t.regs\t= regs,\n\t\t.str\t= str,\n\t\t.err\t= err,\n\t\t.trapnr\t= trap,\n\t\t.signr\t= sig,\n\n\t};\n\n\tif (!kgdb_io_module_registered)\n\t\treturn NOTIFY_DONE;\n\n\treturn __kgdb_notify(&args, cmd);\n}\n\nstatic int\nkgdb_notify(struct notifier_block *self, unsigned long cmd, void *ptr)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __kgdb_notify(ptr, cmd);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\nstatic struct notifier_block kgdb_notifier = {\n\t.notifier_call\t= kgdb_notify,\n};\n\n \nint kgdb_arch_init(void)\n{\n\tint retval;\n\n\tretval = register_die_notifier(&kgdb_notifier);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = register_nmi_handler(NMI_LOCAL, kgdb_nmi_handler,\n\t\t\t\t\t0, \"kgdb\");\n\tif (retval)\n\t\tgoto out1;\n\n\tretval = register_nmi_handler(NMI_UNKNOWN, kgdb_nmi_handler,\n\t\t\t\t\t0, \"kgdb\");\n\n\tif (retval)\n\t\tgoto out2;\n\n\treturn retval;\n\nout2:\n\tunregister_nmi_handler(NMI_LOCAL, \"kgdb\");\nout1:\n\tunregister_die_notifier(&kgdb_notifier);\nout:\n\treturn retval;\n}\n\nstatic void kgdb_hw_overflow_handler(struct perf_event *event,\n\t\tstruct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.virtual_dr6 |= (DR_TRAP0 << i);\n\t}\n}\n\nvoid kgdb_arch_late(void)\n{\n\tint i, cpu;\n\tstruct perf_event_attr attr;\n\tstruct perf_event **pevent;\n\n\t \n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)kgdb_arch_init;\n\tattr.bp_len = HW_BREAKPOINT_LEN_1;\n\tattr.bp_type = HW_BREAKPOINT_W;\n\tattr.disabled = 1;\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (breakinfo[i].pev)\n\t\t\tcontinue;\n\t\tbreakinfo[i].pev = register_wide_hw_breakpoint(&attr, NULL, NULL);\n\t\tif (IS_ERR((void * __force)breakinfo[i].pev)) {\n\t\t\tprintk(KERN_ERR \"kgdb: Could not allocate hw\"\n\t\t\t       \"breakpoints\\nDisabling the kernel debugger\\n\");\n\t\t\tbreakinfo[i].pev = NULL;\n\t\t\tkgdb_arch_exit();\n\t\t\treturn;\n\t\t}\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tpevent = per_cpu_ptr(breakinfo[i].pev, cpu);\n\t\t\tpevent[0]->hw.sample_period = 1;\n\t\t\tpevent[0]->overflow_handler = kgdb_hw_overflow_handler;\n\t\t\tif (pevent[0]->destroy != NULL) {\n\t\t\t\tpevent[0]->destroy = NULL;\n\t\t\t\trelease_bp_slot(*pevent);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid kgdb_arch_exit(void)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (breakinfo[i].pev) {\n\t\t\tunregister_wide_hw_breakpoint(breakinfo[i].pev);\n\t\t\tbreakinfo[i].pev = NULL;\n\t\t}\n\t}\n\tunregister_nmi_handler(NMI_UNKNOWN, \"kgdb\");\n\tunregister_nmi_handler(NMI_LOCAL, \"kgdb\");\n\tunregister_die_notifier(&kgdb_notifier);\n}\n\n \nint kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\tif (exception == 3 && kgdb_isremovedbreak(regs->ip - 1)) {\n\t\tregs->ip -= 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nunsigned long kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\tif (exception == 3)\n\t\treturn instruction_pointer(regs) - 1;\n\treturn instruction_pointer(regs);\n}\n\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long ip)\n{\n\tregs->ip = ip;\n}\n\nint kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\tbpt->type = BP_BREAKPOINT;\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\tif (!err)\n\t\treturn err;\n\t \n\tif (mutex_is_locked(&text_mutex))\n\t\treturn -EBUSY;\n\ttext_poke_kgdb((void *)bpt->bpt_addr, arch_kgdb_ops.gdb_bpt_instr,\n\t\t       BREAK_INSTR_SIZE);\n\tbpt->type = BP_POKE_BREAKPOINT;\n\n\treturn 0;\n}\n\nint kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tif (bpt->type != BP_POKE_BREAKPOINT)\n\t\tgoto knl_write;\n\t \n\tif (mutex_is_locked(&text_mutex))\n\t\tgoto knl_write;\n\ttext_poke_kgdb((void *)bpt->bpt_addr, bpt->saved_instr,\n\t\t       BREAK_INSTR_SIZE);\n\treturn 0;\n\nknl_write:\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}\n\nconst struct kgdb_arch arch_kgdb_ops = {\n\t \n\t.gdb_bpt_instr\t\t= { 0xcc },\n\t.flags\t\t\t= KGDB_HW_BREAKPOINT,\n\t.set_hw_breakpoint\t= kgdb_set_hw_break,\n\t.remove_hw_breakpoint\t= kgdb_remove_hw_break,\n\t.disable_hw_break\t= kgdb_disable_hw_debug,\n\t.remove_all_hw_break\t= kgdb_remove_all_hw_break,\n\t.correct_hw_break\t= kgdb_correct_hw_break,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}