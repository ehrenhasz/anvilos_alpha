{
  "module_name": "dumpstack_32.c",
  "hash_id": "62fa884fc183973114c31a87920aa0f1b29ce4fc2b2ff1ad5dc7b720b79a7aa5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/dumpstack_32.c",
  "human_readable_source": "\n \n#include <linux/sched/debug.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kdebug.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/kexec.h>\n#include <linux/sysfs.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n\n#include <asm/stacktrace.h>\n\nconst char *stack_type_name(enum stack_type type)\n{\n\tif (type == STACK_TYPE_IRQ)\n\t\treturn \"IRQ\";\n\n\tif (type == STACK_TYPE_SOFTIRQ)\n\t\treturn \"SOFTIRQ\";\n\n\tif (type == STACK_TYPE_ENTRY)\n\t\treturn \"ENTRY_TRAMPOLINE\";\n\n\tif (type == STACK_TYPE_EXCEPTION)\n\t\treturn \"#DF\";\n\n\treturn NULL;\n}\n\nstatic bool in_hardirq_stack(unsigned long *stack, struct stack_info *info)\n{\n\tunsigned long *begin = (unsigned long *)this_cpu_read(pcpu_hot.hardirq_stack_ptr);\n\tunsigned long *end   = begin + (THREAD_SIZE / sizeof(long));\n\n\t \n\tif (stack < begin || stack > end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_IRQ;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\n\t \n\tinfo->next_sp\t= (unsigned long *)*begin;\n\n\treturn true;\n}\n\nstatic bool in_softirq_stack(unsigned long *stack, struct stack_info *info)\n{\n\tunsigned long *begin = (unsigned long *)this_cpu_read(pcpu_hot.softirq_stack_ptr);\n\tunsigned long *end   = begin + (THREAD_SIZE / sizeof(long));\n\n\t \n\tif (stack < begin || stack > end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_SOFTIRQ;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\n\t \n\tinfo->next_sp\t= (unsigned long *)*begin;\n\n\treturn true;\n}\n\nstatic bool in_doublefault_stack(unsigned long *stack, struct stack_info *info)\n{\n\tstruct cpu_entry_area *cea = get_cpu_entry_area(raw_smp_processor_id());\n\tstruct doublefault_stack *ss = &cea->doublefault_stack;\n\n\tvoid *begin = ss->stack;\n\tvoid *end = begin + sizeof(ss->stack);\n\n\tif ((void *)stack < begin || (void *)stack >= end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_EXCEPTION;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\tinfo->next_sp\t= (unsigned long *)this_cpu_read(cpu_tss_rw.x86_tss.sp);\n\n\treturn true;\n}\n\n\nint get_stack_info(unsigned long *stack, struct task_struct *task,\n\t\t   struct stack_info *info, unsigned long *visit_mask)\n{\n\tif (!stack)\n\t\tgoto unknown;\n\n\ttask = task ? : current;\n\n\tif (in_task_stack(stack, task, info))\n\t\tgoto recursion_check;\n\n\tif (task != current)\n\t\tgoto unknown;\n\n\tif (in_entry_stack(stack, info))\n\t\tgoto recursion_check;\n\n\tif (in_hardirq_stack(stack, info))\n\t\tgoto recursion_check;\n\n\tif (in_softirq_stack(stack, info))\n\t\tgoto recursion_check;\n\n\tif (in_doublefault_stack(stack, info))\n\t\tgoto recursion_check;\n\n\tgoto unknown;\n\nrecursion_check:\n\t \n\tif (visit_mask) {\n\t\tif (*visit_mask & (1UL << info->type)) {\n\t\t\tprintk_deferred_once(KERN_WARNING \"WARNING: stack recursion on stack type %d\\n\", info->type);\n\t\t\tgoto unknown;\n\t\t}\n\t\t*visit_mask |= 1UL << info->type;\n\t}\n\n\treturn 0;\n\nunknown:\n\tinfo->type = STACK_TYPE_UNKNOWN;\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}