{
  "module_name": "e820.c",
  "hash_id": "e348f8defbfdaad27ca3497299545e8689464d39f665a44d5621a19d98b1b154",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/e820.c",
  "human_readable_source": "\n \n#include <linux/crash_dump.h>\n#include <linux/memblock.h>\n#include <linux/suspend.h>\n#include <linux/acpi.h>\n#include <linux/firmware-map.h>\n#include <linux/sort.h>\n#include <linux/memory_hotplug.h>\n\n#include <asm/e820/api.h>\n#include <asm/setup.h>\n\n \nstatic struct e820_table e820_table_init\t\t__initdata;\nstatic struct e820_table e820_table_kexec_init\t\t__initdata;\nstatic struct e820_table e820_table_firmware_init\t__initdata;\n\nstruct e820_table *e820_table __refdata\t\t\t= &e820_table_init;\nstruct e820_table *e820_table_kexec __refdata\t\t= &e820_table_kexec_init;\nstruct e820_table *e820_table_firmware __refdata\t= &e820_table_firmware_init;\n\n \nunsigned long pci_mem_start = 0xaeedbabe;\n#ifdef CONFIG_PCI\nEXPORT_SYMBOL(pci_mem_start);\n#endif\n\n \nstatic bool _e820__mapped_any(struct e820_table *table,\n\t\t\t      u64 start, u64 end, enum e820_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &table->entries[i];\n\n\t\tif (type && entry->type != type)\n\t\t\tcontinue;\n\t\tif (entry->addr >= end || entry->addr + entry->size <= start)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool e820__mapped_raw_any(u64 start, u64 end, enum e820_type type)\n{\n\treturn _e820__mapped_any(e820_table_firmware, start, end, type);\n}\nEXPORT_SYMBOL_GPL(e820__mapped_raw_any);\n\nbool e820__mapped_any(u64 start, u64 end, enum e820_type type)\n{\n\treturn _e820__mapped_any(e820_table, start, end, type);\n}\nEXPORT_SYMBOL_GPL(e820__mapped_any);\n\n \nstatic struct e820_entry *__e820__mapped_all(u64 start, u64 end,\n\t\t\t\t\t     enum e820_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\n\t\tif (type && entry->type != type)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (entry->addr >= end || entry->addr + entry->size <= start)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (entry->addr <= start)\n\t\t\tstart = entry->addr + entry->size;\n\n\t\t \n\t\tif (start >= end)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nbool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)\n{\n\treturn __e820__mapped_all(start, end, type);\n}\n\n \nint e820__get_entry_type(u64 start, u64 end)\n{\n\tstruct e820_entry *entry = __e820__mapped_all(start, end, 0);\n\n\treturn entry ? entry->type : -EINVAL;\n}\n\n \nstatic void __init __e820__range_add(struct e820_table *table, u64 start, u64 size, enum e820_type type)\n{\n\tint x = table->nr_entries;\n\n\tif (x >= ARRAY_SIZE(table->entries)) {\n\t\tpr_err(\"too many entries; ignoring [mem %#010llx-%#010llx]\\n\",\n\t\t       start, start + size - 1);\n\t\treturn;\n\t}\n\n\ttable->entries[x].addr = start;\n\ttable->entries[x].size = size;\n\ttable->entries[x].type = type;\n\ttable->nr_entries++;\n}\n\nvoid __init e820__range_add(u64 start, u64 size, enum e820_type type)\n{\n\t__e820__range_add(e820_table, start, size, type);\n}\n\nstatic void __init e820_print_type(enum e820_type type)\n{\n\tswitch (type) {\n\tcase E820_TYPE_RAM:\t\t \n\tcase E820_TYPE_RESERVED_KERN:\tpr_cont(\"usable\");\t\t\tbreak;\n\tcase E820_TYPE_RESERVED:\tpr_cont(\"reserved\");\t\t\tbreak;\n\tcase E820_TYPE_SOFT_RESERVED:\tpr_cont(\"soft reserved\");\t\tbreak;\n\tcase E820_TYPE_ACPI:\t\tpr_cont(\"ACPI data\");\t\t\tbreak;\n\tcase E820_TYPE_NVS:\t\tpr_cont(\"ACPI NVS\");\t\t\tbreak;\n\tcase E820_TYPE_UNUSABLE:\tpr_cont(\"unusable\");\t\t\tbreak;\n\tcase E820_TYPE_PMEM:\t\t \n\tcase E820_TYPE_PRAM:\t\tpr_cont(\"persistent (type %u)\", type);\tbreak;\n\tdefault:\t\t\tpr_cont(\"type %u\", type);\t\tbreak;\n\t}\n}\n\nvoid __init e820__print_table(char *who)\n{\n\tint i;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tpr_info(\"%s: [mem %#018Lx-%#018Lx] \",\n\t\t\twho,\n\t\t\te820_table->entries[i].addr,\n\t\t\te820_table->entries[i].addr + e820_table->entries[i].size - 1);\n\n\t\te820_print_type(e820_table->entries[i].type);\n\t\tpr_cont(\"\\n\");\n\t}\n}\n\n \nstruct change_member {\n\t \n\tstruct e820_entry\t*entry;\n\t \n\tunsigned long long\taddr;\n};\n\nstatic struct change_member\tchange_point_list[2*E820_MAX_ENTRIES]\t__initdata;\nstatic struct change_member\t*change_point[2*E820_MAX_ENTRIES]\t__initdata;\nstatic struct e820_entry\t*overlap_list[E820_MAX_ENTRIES]\t\t__initdata;\nstatic struct e820_entry\tnew_entries[E820_MAX_ENTRIES]\t\t__initdata;\n\nstatic int __init cpcompare(const void *a, const void *b)\n{\n\tstruct change_member * const *app = a, * const *bpp = b;\n\tconst struct change_member *ap = *app, *bp = *bpp;\n\n\t \n\tif (ap->addr != bp->addr)\n\t\treturn ap->addr > bp->addr ? 1 : -1;\n\n\treturn (ap->addr != ap->entry->addr) - (bp->addr != bp->entry->addr);\n}\n\nstatic bool e820_nomerge(enum e820_type type)\n{\n\t \n\tif (type == E820_TYPE_PRAM)\n\t\treturn true;\n\tif (type == E820_TYPE_SOFT_RESERVED)\n\t\treturn true;\n\treturn false;\n}\n\nint __init e820__update_table(struct e820_table *table)\n{\n\tstruct e820_entry *entries = table->entries;\n\tu32 max_nr_entries = ARRAY_SIZE(table->entries);\n\tenum e820_type current_type, last_type;\n\tunsigned long long last_addr;\n\tu32 new_nr_entries, overlap_entries;\n\tu32 i, chg_idx, chg_nr;\n\n\t \n\tif (table->nr_entries < 2)\n\t\treturn -1;\n\n\tBUG_ON(table->nr_entries > max_nr_entries);\n\n\t \n\tfor (i = 0; i < table->nr_entries; i++) {\n\t\tif (entries[i].addr + entries[i].size < entries[i].addr)\n\t\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < 2 * table->nr_entries; i++)\n\t\tchange_point[i] = &change_point_list[i];\n\n\t \n\tchg_idx = 0;\n\tfor (i = 0; i < table->nr_entries; i++)\t{\n\t\tif (entries[i].size != 0) {\n\t\t\tchange_point[chg_idx]->addr\t= entries[i].addr;\n\t\t\tchange_point[chg_idx++]->entry\t= &entries[i];\n\t\t\tchange_point[chg_idx]->addr\t= entries[i].addr + entries[i].size;\n\t\t\tchange_point[chg_idx++]->entry\t= &entries[i];\n\t\t}\n\t}\n\tchg_nr = chg_idx;\n\n\t \n\tsort(change_point, chg_nr, sizeof(*change_point), cpcompare, NULL);\n\n\t \n\toverlap_entries = 0;\t  \n\tnew_nr_entries = 0;\t  \n\tlast_type = 0;\t\t  \n\tlast_addr = 0;\t\t  \n\n\t \n\tfor (chg_idx = 0; chg_idx < chg_nr; chg_idx++) {\n\t\t \n\t\tif (change_point[chg_idx]->addr == change_point[chg_idx]->entry->addr) {\n\t\t\t \n\t\t\toverlap_list[overlap_entries++] = change_point[chg_idx]->entry;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < overlap_entries; i++) {\n\t\t\t\tif (overlap_list[i] == change_point[chg_idx]->entry)\n\t\t\t\t\toverlap_list[i] = overlap_list[overlap_entries-1];\n\t\t\t}\n\t\t\toverlap_entries--;\n\t\t}\n\t\t \n\t\tcurrent_type = 0;\n\t\tfor (i = 0; i < overlap_entries; i++) {\n\t\t\tif (overlap_list[i]->type > current_type)\n\t\t\t\tcurrent_type = overlap_list[i]->type;\n\t\t}\n\n\t\t \n\t\tif (current_type != last_type || e820_nomerge(current_type)) {\n\t\t\tif (last_type) {\n\t\t\t\tnew_entries[new_nr_entries].size = change_point[chg_idx]->addr - last_addr;\n\t\t\t\t \n\t\t\t\tif (new_entries[new_nr_entries].size != 0)\n\t\t\t\t\t \n\t\t\t\t\tif (++new_nr_entries >= max_nr_entries)\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (current_type) {\n\t\t\t\tnew_entries[new_nr_entries].addr = change_point[chg_idx]->addr;\n\t\t\t\tnew_entries[new_nr_entries].type = current_type;\n\t\t\t\tlast_addr = change_point[chg_idx]->addr;\n\t\t\t}\n\t\t\tlast_type = current_type;\n\t\t}\n\t}\n\n\t \n\tmemcpy(entries, new_entries, new_nr_entries*sizeof(*entries));\n\ttable->nr_entries = new_nr_entries;\n\n\treturn 0;\n}\n\nstatic int __init __append_e820_table(struct boot_e820_entry *entries, u32 nr_entries)\n{\n\tstruct boot_e820_entry *entry = entries;\n\n\twhile (nr_entries) {\n\t\tu64 start = entry->addr;\n\t\tu64 size = entry->size;\n\t\tu64 end = start + size - 1;\n\t\tu32 type = entry->type;\n\n\t\t \n\t\tif (start > end && likely(size))\n\t\t\treturn -1;\n\n\t\te820__range_add(start, size, type);\n\n\t\tentry++;\n\t\tnr_entries--;\n\t}\n\treturn 0;\n}\n\n \nstatic int __init append_e820_table(struct boot_e820_entry *entries, u32 nr_entries)\n{\n\t \n\tif (nr_entries < 2)\n\t\treturn -1;\n\n\treturn __append_e820_table(entries, nr_entries);\n}\n\nstatic u64 __init\n__e820__range_update(struct e820_table *table, u64 start, u64 size, enum e820_type old_type, enum e820_type new_type)\n{\n\tu64 end;\n\tunsigned int i;\n\tu64 real_updated_size = 0;\n\n\tBUG_ON(old_type == new_type);\n\n\tif (size > (ULLONG_MAX - start))\n\t\tsize = ULLONG_MAX - start;\n\n\tend = start + size;\n\tprintk(KERN_DEBUG \"e820: update [mem %#010Lx-%#010Lx] \", start, end - 1);\n\te820_print_type(old_type);\n\tpr_cont(\" ==> \");\n\te820_print_type(new_type);\n\tpr_cont(\"\\n\");\n\n\tfor (i = 0; i < table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &table->entries[i];\n\t\tu64 final_start, final_end;\n\t\tu64 entry_end;\n\n\t\tif (entry->type != old_type)\n\t\t\tcontinue;\n\n\t\tentry_end = entry->addr + entry->size;\n\n\t\t \n\t\tif (entry->addr >= start && entry_end <= end) {\n\t\t\tentry->type = new_type;\n\t\t\treal_updated_size += entry->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (entry->addr < start && entry_end > end) {\n\t\t\t__e820__range_add(table, start, size, new_type);\n\t\t\t__e820__range_add(table, end, entry_end - end, entry->type);\n\t\t\tentry->size = start - entry->addr;\n\t\t\treal_updated_size += size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfinal_start = max(start, entry->addr);\n\t\tfinal_end = min(end, entry_end);\n\t\tif (final_start >= final_end)\n\t\t\tcontinue;\n\n\t\t__e820__range_add(table, final_start, final_end - final_start, new_type);\n\n\t\treal_updated_size += final_end - final_start;\n\n\t\t \n\t\tentry->size -= final_end - final_start;\n\t\tif (entry->addr < final_start)\n\t\t\tcontinue;\n\n\t\tentry->addr = final_end;\n\t}\n\treturn real_updated_size;\n}\n\nu64 __init e820__range_update(u64 start, u64 size, enum e820_type old_type, enum e820_type new_type)\n{\n\treturn __e820__range_update(e820_table, start, size, old_type, new_type);\n}\n\nstatic u64 __init e820__range_update_kexec(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)\n{\n\treturn __e820__range_update(e820_table_kexec, start, size, old_type, new_type);\n}\n\n \nu64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, bool check_type)\n{\n\tint i;\n\tu64 end;\n\tu64 real_removed_size = 0;\n\n\tif (size > (ULLONG_MAX - start))\n\t\tsize = ULLONG_MAX - start;\n\n\tend = start + size;\n\tprintk(KERN_DEBUG \"e820: remove [mem %#010Lx-%#010Lx] \", start, end - 1);\n\tif (check_type)\n\t\te820_print_type(old_type);\n\tpr_cont(\"\\n\");\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\t\tu64 final_start, final_end;\n\t\tu64 entry_end;\n\n\t\tif (check_type && entry->type != old_type)\n\t\t\tcontinue;\n\n\t\tentry_end = entry->addr + entry->size;\n\n\t\t \n\t\tif (entry->addr >= start && entry_end <= end) {\n\t\t\treal_removed_size += entry->size;\n\t\t\tmemset(entry, 0, sizeof(*entry));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (entry->addr < start && entry_end > end) {\n\t\t\te820__range_add(end, entry_end - end, entry->type);\n\t\t\tentry->size = start - entry->addr;\n\t\t\treal_removed_size += size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfinal_start = max(start, entry->addr);\n\t\tfinal_end = min(end, entry_end);\n\t\tif (final_start >= final_end)\n\t\t\tcontinue;\n\n\t\treal_removed_size += final_end - final_start;\n\n\t\t \n\t\tentry->size -= final_end - final_start;\n\t\tif (entry->addr < final_start)\n\t\t\tcontinue;\n\n\t\tentry->addr = final_end;\n\t}\n\treturn real_removed_size;\n}\n\nvoid __init e820__update_table_print(void)\n{\n\tif (e820__update_table(e820_table))\n\t\treturn;\n\n\tpr_info(\"modified physical RAM map:\\n\");\n\te820__print_table(\"modified\");\n}\n\nstatic void __init e820__update_table_kexec(void)\n{\n\te820__update_table(e820_table_kexec);\n}\n\n#define MAX_GAP_END 0x100000000ull\n\n \nstatic int __init e820_search_gap(unsigned long *gapstart, unsigned long *gapsize)\n{\n\tunsigned long long last = MAX_GAP_END;\n\tint i = e820_table->nr_entries;\n\tint found = 0;\n\n\twhile (--i >= 0) {\n\t\tunsigned long long start = e820_table->entries[i].addr;\n\t\tunsigned long long end = start + e820_table->entries[i].size;\n\n\t\t \n\t\tif (last > end) {\n\t\t\tunsigned long gap = last - end;\n\n\t\t\tif (gap >= *gapsize) {\n\t\t\t\t*gapsize = gap;\n\t\t\t\t*gapstart = end;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (start < last)\n\t\t\tlast = start;\n\t}\n\treturn found;\n}\n\n \n__init void e820__setup_pci_gap(void)\n{\n\tunsigned long gapstart, gapsize;\n\tint found;\n\n\tgapsize = 0x400000;\n\tfound  = e820_search_gap(&gapstart, &gapsize);\n\n\tif (!found) {\n#ifdef CONFIG_X86_64\n\t\tgapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;\n\t\tpr_err(\"Cannot find an available gap in the 32-bit address range\\n\");\n\t\tpr_err(\"PCI devices with unassigned 32-bit BARs may not work!\\n\");\n#else\n\t\tgapstart = 0x10000000;\n#endif\n\t}\n\n\t \n\tpci_mem_start = gapstart;\n\n\tpr_info(\"[mem %#010lx-%#010lx] available for PCI devices\\n\",\n\t\tgapstart, gapstart + gapsize - 1);\n}\n\n \n__init void e820__reallocate_tables(void)\n{\n\tstruct e820_table *n;\n\tint size;\n\n\tsize = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table->nr_entries;\n\tn = kmemdup(e820_table, size, GFP_KERNEL);\n\tBUG_ON(!n);\n\te820_table = n;\n\n\tsize = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_kexec->nr_entries;\n\tn = kmemdup(e820_table_kexec, size, GFP_KERNEL);\n\tBUG_ON(!n);\n\te820_table_kexec = n;\n\n\tsize = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;\n\tn = kmemdup(e820_table_firmware, size, GFP_KERNEL);\n\tBUG_ON(!n);\n\te820_table_firmware = n;\n}\n\n \nvoid __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)\n{\n\tint entries;\n\tstruct boot_e820_entry *extmap;\n\tstruct setup_data *sdata;\n\n\tsdata = early_memremap(phys_addr, data_len);\n\tentries = sdata->len / sizeof(*extmap);\n\textmap = (struct boot_e820_entry *)(sdata->data);\n\n\t__append_e820_table(extmap, entries);\n\te820__update_table(e820_table);\n\n\tmemcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));\n\tmemcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));\n\n\tearly_memunmap(sdata, data_len);\n\tpr_info(\"extended physical RAM map:\\n\");\n\te820__print_table(\"extended\");\n}\n\n \nvoid __init e820__register_nosave_regions(unsigned long limit_pfn)\n{\n\tint i;\n\tunsigned long pfn = 0;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\n\t\tif (pfn < PFN_UP(entry->addr))\n\t\t\tregister_nosave_region(pfn, PFN_UP(entry->addr));\n\n\t\tpfn = PFN_DOWN(entry->addr + entry->size);\n\n\t\tif (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)\n\t\t\tregister_nosave_region(PFN_UP(entry->addr), pfn);\n\n\t\tif (pfn >= limit_pfn)\n\t\t\tbreak;\n\t}\n}\n\n#ifdef CONFIG_ACPI\n \nstatic int __init e820__register_nvs_regions(void)\n{\n\tint i;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\n\t\tif (entry->type == E820_TYPE_NVS)\n\t\t\tacpi_nvs_register(entry->addr, entry->size);\n\t}\n\n\treturn 0;\n}\ncore_initcall(e820__register_nvs_regions);\n#endif\n\n \nu64 __init e820__memblock_alloc_reserved(u64 size, u64 align)\n{\n\tu64 addr;\n\n\taddr = memblock_phys_alloc(size, align);\n\tif (addr) {\n\t\te820__range_update_kexec(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);\n\t\tpr_info(\"update e820_table_kexec for e820__memblock_alloc_reserved()\\n\");\n\t\te820__update_table_kexec();\n\t}\n\n\treturn addr;\n}\n\n#ifdef CONFIG_X86_32\n# ifdef CONFIG_X86_PAE\n#  define MAX_ARCH_PFN\t\t(1ULL<<(36-PAGE_SHIFT))\n# else\n#  define MAX_ARCH_PFN\t\t(1ULL<<(32-PAGE_SHIFT))\n# endif\n#else  \n# define MAX_ARCH_PFN MAXMEM>>PAGE_SHIFT\n#endif\n\n \nstatic unsigned long __init e820_end_pfn(unsigned long limit_pfn, enum e820_type type)\n{\n\tint i;\n\tunsigned long last_pfn = 0;\n\tunsigned long max_arch_pfn = MAX_ARCH_PFN;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\t\tunsigned long start_pfn;\n\t\tunsigned long end_pfn;\n\n\t\tif (entry->type != type)\n\t\t\tcontinue;\n\n\t\tstart_pfn = entry->addr >> PAGE_SHIFT;\n\t\tend_pfn = (entry->addr + entry->size) >> PAGE_SHIFT;\n\n\t\tif (start_pfn >= limit_pfn)\n\t\t\tcontinue;\n\t\tif (end_pfn > limit_pfn) {\n\t\t\tlast_pfn = limit_pfn;\n\t\t\tbreak;\n\t\t}\n\t\tif (end_pfn > last_pfn)\n\t\t\tlast_pfn = end_pfn;\n\t}\n\n\tif (last_pfn > max_arch_pfn)\n\t\tlast_pfn = max_arch_pfn;\n\n\tpr_info(\"last_pfn = %#lx max_arch_pfn = %#lx\\n\",\n\t\tlast_pfn, max_arch_pfn);\n\treturn last_pfn;\n}\n\nunsigned long __init e820__end_of_ram_pfn(void)\n{\n\treturn e820_end_pfn(MAX_ARCH_PFN, E820_TYPE_RAM);\n}\n\nunsigned long __init e820__end_of_low_ram_pfn(void)\n{\n\treturn e820_end_pfn(1UL << (32 - PAGE_SHIFT), E820_TYPE_RAM);\n}\n\nstatic void __init early_panic(char *msg)\n{\n\tearly_printk(msg);\n\tpanic(msg);\n}\n\nstatic int userdef __initdata;\n\n \nstatic int __init parse_memopt(char *p)\n{\n\tu64 mem_size;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(p, \"nopentium\")) {\n#ifdef CONFIG_X86_32\n\t\tsetup_clear_cpu_cap(X86_FEATURE_PSE);\n\t\treturn 0;\n#else\n\t\tpr_warn(\"mem=nopentium ignored! (only supported on x86_32)\\n\");\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tuserdef = 1;\n\tmem_size = memparse(p, &p);\n\n\t \n\tif (mem_size == 0)\n\t\treturn -EINVAL;\n\n\te820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n\tmax_mem_size = mem_size;\n#endif\n\n\treturn 0;\n}\nearly_param(\"mem\", parse_memopt);\n\nstatic int __init parse_memmap_one(char *p)\n{\n\tchar *oldp;\n\tu64 start_at, mem_size;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(p, \"exactmap\", 8)) {\n\t\te820_table->nr_entries = 0;\n\t\tuserdef = 1;\n\t\treturn 0;\n\t}\n\n\toldp = p;\n\tmem_size = memparse(p, &p);\n\tif (p == oldp)\n\t\treturn -EINVAL;\n\n\tuserdef = 1;\n\tif (*p == '@') {\n\t\tstart_at = memparse(p+1, &p);\n\t\te820__range_add(start_at, mem_size, E820_TYPE_RAM);\n\t} else if (*p == '#') {\n\t\tstart_at = memparse(p+1, &p);\n\t\te820__range_add(start_at, mem_size, E820_TYPE_ACPI);\n\t} else if (*p == '$') {\n\t\tstart_at = memparse(p+1, &p);\n\t\te820__range_add(start_at, mem_size, E820_TYPE_RESERVED);\n\t} else if (*p == '!') {\n\t\tstart_at = memparse(p+1, &p);\n\t\te820__range_add(start_at, mem_size, E820_TYPE_PRAM);\n\t} else if (*p == '%') {\n\t\tenum e820_type from = 0, to = 0;\n\n\t\tstart_at = memparse(p + 1, &p);\n\t\tif (*p == '-')\n\t\t\tfrom = simple_strtoull(p + 1, &p, 0);\n\t\tif (*p == '+')\n\t\t\tto = simple_strtoull(p + 1, &p, 0);\n\t\tif (*p != '\\0')\n\t\t\treturn -EINVAL;\n\t\tif (from && to)\n\t\t\te820__range_update(start_at, mem_size, from, to);\n\t\telse if (to)\n\t\t\te820__range_add(start_at, mem_size, to);\n\t\telse if (from)\n\t\t\te820__range_remove(start_at, mem_size, from, 1);\n\t\telse\n\t\t\te820__range_remove(start_at, mem_size, 0, 0);\n\t} else {\n\t\te820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);\n\t}\n\n\treturn *p == '\\0' ? 0 : -EINVAL;\n}\n\nstatic int __init parse_memmap_opt(char *str)\n{\n\twhile (str) {\n\t\tchar *k = strchr(str, ',');\n\n\t\tif (k)\n\t\t\t*k++ = 0;\n\n\t\tparse_memmap_one(str);\n\t\tstr = k;\n\t}\n\n\treturn 0;\n}\nearly_param(\"memmap\", parse_memmap_opt);\n\n \nvoid __init e820__reserve_setup_data(void)\n{\n\tstruct setup_indirect *indirect;\n\tstruct setup_data *data;\n\tu64 pa_data, pa_next;\n\tu32 len;\n\n\tpa_data = boot_params.hdr.setup_data;\n\tif (!pa_data)\n\t\treturn;\n\n\twhile (pa_data) {\n\t\tdata = early_memremap(pa_data, sizeof(*data));\n\t\tif (!data) {\n\t\t\tpr_warn(\"e820: failed to memremap setup_data entry\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen = sizeof(*data);\n\t\tpa_next = data->next;\n\n\t\te820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);\n\n\t\t \n\t\tif (data->type != SETUP_EFI && data->type != SETUP_IMA)\n\t\t\te820__range_update_kexec(pa_data,\n\t\t\t\t\t\t sizeof(*data) + data->len,\n\t\t\t\t\t\t E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);\n\n\t\tif (data->type == SETUP_INDIRECT) {\n\t\t\tlen += data->len;\n\t\t\tearly_memunmap(data, sizeof(*data));\n\t\t\tdata = early_memremap(pa_data, len);\n\t\t\tif (!data) {\n\t\t\t\tpr_warn(\"e820: failed to memremap indirect setup_data\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\t\tif (indirect->type != SETUP_INDIRECT) {\n\t\t\t\te820__range_update(indirect->addr, indirect->len,\n\t\t\t\t\t\t   E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);\n\t\t\t\te820__range_update_kexec(indirect->addr, indirect->len,\n\t\t\t\t\t\t\t E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);\n\t\t\t}\n\t\t}\n\n\t\tpa_data = pa_next;\n\t\tearly_memunmap(data, len);\n\t}\n\n\te820__update_table(e820_table);\n\te820__update_table(e820_table_kexec);\n\n\tpr_info(\"extended physical RAM map:\\n\");\n\te820__print_table(\"reserve setup_data\");\n}\n\n \nvoid __init e820__finish_early_params(void)\n{\n\tif (userdef) {\n\t\tif (e820__update_table(e820_table) < 0)\n\t\t\tearly_panic(\"Invalid user supplied memory map\");\n\n\t\tpr_info(\"user-defined physical RAM map:\\n\");\n\t\te820__print_table(\"user\");\n\t}\n}\n\nstatic const char *__init e820_type_to_string(struct e820_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase E820_TYPE_RESERVED_KERN:\t \n\tcase E820_TYPE_RAM:\t\treturn \"System RAM\";\n\tcase E820_TYPE_ACPI:\t\treturn \"ACPI Tables\";\n\tcase E820_TYPE_NVS:\t\treturn \"ACPI Non-volatile Storage\";\n\tcase E820_TYPE_UNUSABLE:\treturn \"Unusable memory\";\n\tcase E820_TYPE_PRAM:\t\treturn \"Persistent Memory (legacy)\";\n\tcase E820_TYPE_PMEM:\t\treturn \"Persistent Memory\";\n\tcase E820_TYPE_RESERVED:\treturn \"Reserved\";\n\tcase E820_TYPE_SOFT_RESERVED:\treturn \"Soft Reserved\";\n\tdefault:\t\t\treturn \"Unknown E820 type\";\n\t}\n}\n\nstatic unsigned long __init e820_type_to_iomem_type(struct e820_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase E820_TYPE_RESERVED_KERN:\t \n\tcase E820_TYPE_RAM:\t\treturn IORESOURCE_SYSTEM_RAM;\n\tcase E820_TYPE_ACPI:\t\t \n\tcase E820_TYPE_NVS:\t\t \n\tcase E820_TYPE_UNUSABLE:\t \n\tcase E820_TYPE_PRAM:\t\t \n\tcase E820_TYPE_PMEM:\t\t \n\tcase E820_TYPE_RESERVED:\t \n\tcase E820_TYPE_SOFT_RESERVED:\t \n\tdefault:\t\t\treturn IORESOURCE_MEM;\n\t}\n}\n\nstatic unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase E820_TYPE_ACPI:\t\treturn IORES_DESC_ACPI_TABLES;\n\tcase E820_TYPE_NVS:\t\treturn IORES_DESC_ACPI_NV_STORAGE;\n\tcase E820_TYPE_PMEM:\t\treturn IORES_DESC_PERSISTENT_MEMORY;\n\tcase E820_TYPE_PRAM:\t\treturn IORES_DESC_PERSISTENT_MEMORY_LEGACY;\n\tcase E820_TYPE_RESERVED:\treturn IORES_DESC_RESERVED;\n\tcase E820_TYPE_SOFT_RESERVED:\treturn IORES_DESC_SOFT_RESERVED;\n\tcase E820_TYPE_RESERVED_KERN:\t \n\tcase E820_TYPE_RAM:\t\t \n\tcase E820_TYPE_UNUSABLE:\t \n\tdefault:\t\t\treturn IORES_DESC_NONE;\n\t}\n}\n\nstatic bool __init do_mark_busy(enum e820_type type, struct resource *res)\n{\n\t \n\tif (res->start < (1ULL<<20))\n\t\treturn true;\n\n\t \n\tswitch (type) {\n\tcase E820_TYPE_RESERVED:\n\tcase E820_TYPE_SOFT_RESERVED:\n\tcase E820_TYPE_PRAM:\n\tcase E820_TYPE_PMEM:\n\t\treturn false;\n\tcase E820_TYPE_RESERVED_KERN:\n\tcase E820_TYPE_RAM:\n\tcase E820_TYPE_ACPI:\n\tcase E820_TYPE_NVS:\n\tcase E820_TYPE_UNUSABLE:\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n \n\nstatic struct resource __initdata *e820_res;\n\nvoid __init e820__reserve_resources(void)\n{\n\tint i;\n\tstruct resource *res;\n\tu64 end;\n\n\tres = memblock_alloc(sizeof(*res) * e820_table->nr_entries,\n\t\t\t     SMP_CACHE_BYTES);\n\tif (!res)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(*res) * e820_table->nr_entries);\n\te820_res = res;\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = e820_table->entries + i;\n\n\t\tend = entry->addr + entry->size - 1;\n\t\tif (end != (resource_size_t)end) {\n\t\t\tres++;\n\t\t\tcontinue;\n\t\t}\n\t\tres->start = entry->addr;\n\t\tres->end   = end;\n\t\tres->name  = e820_type_to_string(entry);\n\t\tres->flags = e820_type_to_iomem_type(entry);\n\t\tres->desc  = e820_type_to_iores_desc(entry);\n\n\t\t \n\t\tif (do_mark_busy(entry->type, res)) {\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tinsert_resource(&iomem_resource, res);\n\t\t}\n\t\tres++;\n\t}\n\n\t \n\tfor (i = 0; i < e820_table_firmware->nr_entries; i++) {\n\t\tstruct e820_entry *entry = e820_table_firmware->entries + i;\n\n\t\tfirmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry));\n\t}\n}\n\n \nstatic unsigned long __init ram_alignment(resource_size_t pos)\n{\n\tunsigned long mb = pos >> 20;\n\n\t \n\tif (!mb)\n\t\treturn 64*1024;\n\n\t \n\tif (mb < 16)\n\t\treturn 1024*1024;\n\n\t \n\treturn 64*1024*1024;\n}\n\n#define MAX_RESOURCE_SIZE ((resource_size_t)-1)\n\nvoid __init e820__reserve_resources_late(void)\n{\n\tint i;\n\tstruct resource *res;\n\n\tres = e820_res;\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tif (!res->parent && res->end)\n\t\t\tinsert_resource_expand_to_fit(&iomem_resource, res);\n\t\tres++;\n\t}\n\n\t \n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\t\tu64 start, end;\n\n\t\tif (entry->type != E820_TYPE_RAM)\n\t\t\tcontinue;\n\n\t\tstart = entry->addr + entry->size;\n\t\tend = round_up(start, ram_alignment(start)) - 1;\n\t\tif (end > MAX_RESOURCE_SIZE)\n\t\t\tend = MAX_RESOURCE_SIZE;\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_DEBUG \"e820: reserve RAM buffer [mem %#010llx-%#010llx]\\n\", start, end);\n\t\treserve_region_with_split(&iomem_resource, start, end, \"RAM buffer\");\n\t}\n}\n\n \nchar *__init e820__memory_setup_default(void)\n{\n\tchar *who = \"BIOS-e820\";\n\n\t \n\tif (append_e820_table(boot_params.e820_table, boot_params.e820_entries) < 0) {\n\t\tu64 mem_size;\n\n\t\t \n\t\tif (boot_params.alt_mem_k < boot_params.screen_info.ext_mem_k) {\n\t\t\tmem_size = boot_params.screen_info.ext_mem_k;\n\t\t\twho = \"BIOS-88\";\n\t\t} else {\n\t\t\tmem_size = boot_params.alt_mem_k;\n\t\t\twho = \"BIOS-e801\";\n\t\t}\n\n\t\te820_table->nr_entries = 0;\n\t\te820__range_add(0, LOWMEMSIZE(), E820_TYPE_RAM);\n\t\te820__range_add(HIGH_MEMORY, mem_size << 10, E820_TYPE_RAM);\n\t}\n\n\t \n\te820__update_table(e820_table);\n\n\treturn who;\n}\n\n \nvoid __init e820__memory_setup(void)\n{\n\tchar *who;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct boot_e820_entry) != 20);\n\n\twho = x86_init.resources.memory_setup();\n\n\tmemcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));\n\tmemcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));\n\n\tpr_info(\"BIOS-provided physical RAM map:\\n\");\n\te820__print_table(who);\n}\n\nvoid __init e820__memblock_setup(void)\n{\n\tint i;\n\tu64 end;\n\n\t \n\tmemblock_allow_resize();\n\n\tfor (i = 0; i < e820_table->nr_entries; i++) {\n\t\tstruct e820_entry *entry = &e820_table->entries[i];\n\n\t\tend = entry->addr + entry->size;\n\t\tif (end != (resource_size_t)end)\n\t\t\tcontinue;\n\n\t\tif (entry->type == E820_TYPE_SOFT_RESERVED)\n\t\t\tmemblock_reserve(entry->addr, entry->size);\n\n\t\tif (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)\n\t\t\tcontinue;\n\n\t\tmemblock_add(entry->addr, entry->size);\n\t}\n\n\t \n\tmemblock_trim_memory(PAGE_SIZE);\n\n\tmemblock_dump_all();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}