{
  "module_name": "mmconf-fam10h_64.c",
  "hash_id": "c494d90e2429e4f82b5b19c8dbd59755d58cc7338d7be0213e83b1b860890d59",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/mmconf-fam10h_64.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/dmi.h>\n#include <linux/range.h>\n\n#include <asm/pci-direct.h>\n#include <linux/sort.h>\n#include <asm/io.h>\n#include <asm/msr.h>\n#include <asm/acpi.h>\n#include <asm/mmconfig.h>\n#include <asm/pci_x86.h>\n\nstruct pci_hostbridge_probe {\n\tu32 bus;\n\tu32 slot;\n\tu32 vendor;\n\tu32 device;\n};\n\nstatic u64 fam10h_pci_mmconf_base;\n\nstatic struct pci_hostbridge_probe pci_probes[] = {\n\t{ 0, 0x18, PCI_VENDOR_ID_AMD, 0x1200 },\n\t{ 0xff, 0, PCI_VENDOR_ID_AMD, 0x1200 },\n};\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\tint start1, start2;\n\n\tstart1 = r1->start >> 32;\n\tstart2 = r2->start >> 32;\n\n\treturn start1 - start2;\n}\n\n#define MMCONF_UNIT (1ULL << FAM10H_MMIO_CONF_BASE_SHIFT)\n#define MMCONF_MASK (~(MMCONF_UNIT - 1))\n#define MMCONF_SIZE (MMCONF_UNIT << 8)\n \n#define FAM10H_PCI_MMCONF_BASE (0xfcULL<<32)\n#define BASE_VALID(b) ((b) + MMCONF_SIZE <= (0xfdULL<<32) || (b) >= (1ULL<<40))\nstatic void get_fam10h_pci_mmconf_base(void)\n{\n\tint i;\n\tunsigned bus;\n\tunsigned slot;\n\tint found;\n\n\tu64 val;\n\tu32 address;\n\tu64 tom2;\n\tu64 base = FAM10H_PCI_MMCONF_BASE;\n\n\tint hi_mmio_num;\n\tstruct range range[8];\n\n\t \n\tif (fam10h_pci_mmconf_base)\n\t\treturn;\n\n\tif (!early_pci_allowed())\n\t\treturn;\n\n\tfound = 0;\n\tfor (i = 0; i < ARRAY_SIZE(pci_probes); i++) {\n\t\tu32 id;\n\t\tu16 device;\n\t\tu16 vendor;\n\n\t\tbus = pci_probes[i].bus;\n\t\tslot = pci_probes[i].slot;\n\t\tid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\n\n\t\tvendor = id & 0xffff;\n\t\tdevice = (id>>16) & 0xffff;\n\t\tif (pci_probes[i].vendor == vendor &&\n\t\t    pci_probes[i].device == device) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t \n\taddress = MSR_AMD64_SYSCFG;\n\trdmsrl(address, val);\n\n\t \n\tif (!(val & (1<<21))) {\n\t\ttom2 = 1ULL << 32;\n\t} else {\n\t\t \n\t\taddress = MSR_K8_TOP_MEM2;\n\t\trdmsrl(address, val);\n\t\ttom2 = max(val & 0xffffff800000ULL, 1ULL << 32);\n\t}\n\n\tif (base <= tom2)\n\t\tbase = (tom2 + 2 * MMCONF_UNIT - 1) & MMCONF_MASK;\n\n\t \n\thi_mmio_num = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tu32 reg;\n\t\tu64 start;\n\t\tu64 end;\n\t\treg = read_pci_config(bus, slot, 1, 0x80 + (i << 3));\n\t\tif (!(reg & 3))\n\t\t\tcontinue;\n\n\t\tstart = (u64)(reg & 0xffffff00) << 8;  \n\t\treg = read_pci_config(bus, slot, 1, 0x84 + (i << 3));\n\t\tend = ((u64)(reg & 0xffffff00) << 8) | 0xffff;  \n\n\t\tif (end < tom2)\n\t\t\tcontinue;\n\n\t\trange[hi_mmio_num].start = start;\n\t\trange[hi_mmio_num].end = end;\n\t\thi_mmio_num++;\n\t}\n\n\tif (!hi_mmio_num)\n\t\tgoto out;\n\n\t \n\tsort(range, hi_mmio_num, sizeof(struct range), cmp_range, NULL);\n\n\tif (range[hi_mmio_num - 1].end < base)\n\t\tgoto out;\n\tif (range[0].start > base + MMCONF_SIZE)\n\t\tgoto out;\n\n\t \n\tbase = (range[0].start & MMCONF_MASK) - MMCONF_UNIT;\n\tif ((base > tom2) && BASE_VALID(base))\n\t\tgoto out;\n\tbase = (range[hi_mmio_num - 1].end + MMCONF_UNIT) & MMCONF_MASK;\n\tif (BASE_VALID(base))\n\t\tgoto out;\n\t \n\tfor (i = 1; i < hi_mmio_num; i++) {\n\t\tbase = (range[i - 1].end + MMCONF_UNIT) & MMCONF_MASK;\n\t\tval = range[i].start & MMCONF_MASK;\n\t\tif (val >= base + MMCONF_SIZE && BASE_VALID(base))\n\t\t\tgoto out;\n\t}\n\treturn;\n\nout:\n\tfam10h_pci_mmconf_base = base;\n}\n\nvoid fam10h_check_enable_mmcfg(void)\n{\n\tu64 val;\n\tu32 address;\n\n\tif (!(pci_probe & PCI_CHECK_ENABLE_AMD_MMCONF))\n\t\treturn;\n\n\taddress = MSR_FAM10H_MMIO_CONF_BASE;\n\trdmsrl(address, val);\n\n\t \n\tif (val & FAM10H_MMIO_CONF_ENABLE) {\n\t\tunsigned busnbits;\n\t\tbusnbits = (val >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\n\t\t\tFAM10H_MMIO_CONF_BUSRANGE_MASK;\n\n\t\t \n\t\tif (!acpi_pci_disabled || busnbits >= 8) {\n\t\t\tu64 base = val & MMCONF_MASK;\n\n\t\t\tif (!fam10h_pci_mmconf_base) {\n\t\t\t\tfam10h_pci_mmconf_base = base;\n\t\t\t\treturn;\n\t\t\t} else if (fam10h_pci_mmconf_base ==  base)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tget_fam10h_pci_mmconf_base();\n\tif (!fam10h_pci_mmconf_base) {\n\t\tpci_probe &= ~PCI_CHECK_ENABLE_AMD_MMCONF;\n\t\treturn;\n\t}\n\n\tprintk(KERN_INFO \"Enable MMCONFIG on AMD Family 10h\\n\");\n\tval &= ~((FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT) |\n\t     (FAM10H_MMIO_CONF_BUSRANGE_MASK<<FAM10H_MMIO_CONF_BUSRANGE_SHIFT));\n\tval |= fam10h_pci_mmconf_base | (8 << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n\t       FAM10H_MMIO_CONF_ENABLE;\n\twrmsrl(address, val);\n}\n\nstatic int __init set_check_enable_amd_mmconf(const struct dmi_system_id *d)\n{\n        pci_probe |= PCI_CHECK_ENABLE_AMD_MMCONF;\n        return 0;\n}\n\nstatic const struct dmi_system_id __initconst mmconf_dmi_table[] = {\n        {\n                .callback = set_check_enable_amd_mmconf,\n                .ident = \"Sun Microsystems Machine\",\n                .matches = {\n                        DMI_MATCH(DMI_SYS_VENDOR, \"Sun Microsystems\"),\n                },\n        },\n\t{}\n};\n\n \nvoid __ref check_enable_amd_mmconf_dmi(void)\n{\n\tdmi_check_system(mmconf_dmi_table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}