{
  "module_name": "ptrace.c",
  "hash_id": "dd57e9cc049331599b09f116161ff4084701a9246c3609aa206b79aaeda4b11e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/ptrace.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/context_tracking.h>\n#include <linux/nospec.h>\n\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <asm/fpu/signal.h>\n#include <asm/fpu/regset.h>\n#include <asm/fpu/xstate.h>\n#include <asm/debugreg.h>\n#include <asm/ldt.h>\n#include <asm/desc.h>\n#include <asm/prctl.h>\n#include <asm/proto.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/traps.h>\n#include <asm/syscall.h>\n#include <asm/fsgsbase.h>\n#include <asm/io_bitmap.h>\n\n#include \"tls.h\"\n\nenum x86_regset_32 {\n\tREGSET32_GENERAL,\n\tREGSET32_FP,\n\tREGSET32_XFP,\n\tREGSET32_XSTATE,\n\tREGSET32_TLS,\n\tREGSET32_IOPERM,\n};\n\nenum x86_regset_64 {\n\tREGSET64_GENERAL,\n\tREGSET64_FP,\n\tREGSET64_IOPERM,\n\tREGSET64_XSTATE,\n\tREGSET64_SSP,\n};\n\n#define REGSET_GENERAL \\\n({ \\\n\tBUILD_BUG_ON((int)REGSET32_GENERAL != (int)REGSET64_GENERAL); \\\n\tREGSET32_GENERAL; \\\n})\n\n#define REGSET_FP \\\n({ \\\n\tBUILD_BUG_ON((int)REGSET32_FP != (int)REGSET64_FP); \\\n\tREGSET32_FP; \\\n})\n\n\nstruct pt_regs_offset {\n\tconst char *name;\n\tint offset;\n};\n\n#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}\n#define REG_OFFSET_END {.name = NULL, .offset = 0}\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n#ifdef CONFIG_X86_64\n\tREG_OFFSET_NAME(r15),\n\tREG_OFFSET_NAME(r14),\n\tREG_OFFSET_NAME(r13),\n\tREG_OFFSET_NAME(r12),\n\tREG_OFFSET_NAME(r11),\n\tREG_OFFSET_NAME(r10),\n\tREG_OFFSET_NAME(r9),\n\tREG_OFFSET_NAME(r8),\n#endif\n\tREG_OFFSET_NAME(bx),\n\tREG_OFFSET_NAME(cx),\n\tREG_OFFSET_NAME(dx),\n\tREG_OFFSET_NAME(si),\n\tREG_OFFSET_NAME(di),\n\tREG_OFFSET_NAME(bp),\n\tREG_OFFSET_NAME(ax),\n#ifdef CONFIG_X86_32\n\tREG_OFFSET_NAME(ds),\n\tREG_OFFSET_NAME(es),\n\tREG_OFFSET_NAME(fs),\n\tREG_OFFSET_NAME(gs),\n#endif\n\tREG_OFFSET_NAME(orig_ax),\n\tREG_OFFSET_NAME(ip),\n\tREG_OFFSET_NAME(cs),\n\tREG_OFFSET_NAME(flags),\n\tREG_OFFSET_NAME(sp),\n\tREG_OFFSET_NAME(ss),\n\tREG_OFFSET_END,\n};\n\n \nint regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}\n\n \nconst char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}\n\n \n\n \n#define FLAG_MASK_32\t\t((unsigned long)\t\t\t\\\n\t\t\t\t (X86_EFLAGS_CF | X86_EFLAGS_PF |\t\\\n\t\t\t\t  X86_EFLAGS_AF | X86_EFLAGS_ZF |\t\\\n\t\t\t\t  X86_EFLAGS_SF | X86_EFLAGS_TF |\t\\\n\t\t\t\t  X86_EFLAGS_DF | X86_EFLAGS_OF |\t\\\n\t\t\t\t  X86_EFLAGS_RF | X86_EFLAGS_AC))\n\n \nstatic inline bool invalid_selector(u16 value)\n{\n\treturn unlikely(value != 0 && (value & SEGMENT_RPL_MASK) != USER_RPL);\n}\n\n#ifdef CONFIG_X86_32\n\n#define FLAG_MASK\t\tFLAG_MASK_32\n\nstatic unsigned long *pt_regs_access(struct pt_regs *regs, unsigned long regno)\n{\n\tBUILD_BUG_ON(offsetof(struct pt_regs, bx) != 0);\n\treturn &regs->bx + (regno >> 2);\n}\n\nstatic u16 get_segment_reg(struct task_struct *task, unsigned long offset)\n{\n\t \n\tunsigned int retval;\n\tif (offset != offsetof(struct user_regs_struct, gs))\n\t\tretval = *pt_regs_access(task_pt_regs(task), offset);\n\telse {\n\t\tif (task == current)\n\t\t\tsavesegment(gs, retval);\n\t\telse\n\t\t\tretval = task->thread.gs;\n\t}\n\treturn retval;\n}\n\nstatic int set_segment_reg(struct task_struct *task,\n\t\t\t   unsigned long offset, u16 value)\n{\n\tif (WARN_ON_ONCE(task == current))\n\t\treturn -EIO;\n\n\t \n\tif (invalid_selector(value))\n\t\treturn -EIO;\n\n\t \n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct, cs):\n\tcase offsetof(struct user_regs_struct, ss):\n\t\tif (unlikely(value == 0))\n\t\t\treturn -EIO;\n\t\tfallthrough;\n\n\tdefault:\n\t\t*pt_regs_access(task_pt_regs(task), offset) = value;\n\t\tbreak;\n\n\tcase offsetof(struct user_regs_struct, gs):\n\t\ttask->thread.gs = value;\n\t}\n\n\treturn 0;\n}\n\n#else   \n\n#define FLAG_MASK\t\t(FLAG_MASK_32 | X86_EFLAGS_NT)\n\nstatic unsigned long *pt_regs_access(struct pt_regs *regs, unsigned long offset)\n{\n\tBUILD_BUG_ON(offsetof(struct pt_regs, r15) != 0);\n\treturn &regs->r15 + (offset / sizeof(regs->r15));\n}\n\nstatic u16 get_segment_reg(struct task_struct *task, unsigned long offset)\n{\n\t \n\tunsigned int seg;\n\n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct, fs):\n\t\tif (task == current) {\n\t\t\t \n\t\t\tasm(\"movl %%fs,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.fsindex;\n\tcase offsetof(struct user_regs_struct, gs):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%gs,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.gsindex;\n\tcase offsetof(struct user_regs_struct, ds):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%ds,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.ds;\n\tcase offsetof(struct user_regs_struct, es):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%es,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.es;\n\n\tcase offsetof(struct user_regs_struct, cs):\n\tcase offsetof(struct user_regs_struct, ss):\n\t\tbreak;\n\t}\n\treturn *pt_regs_access(task_pt_regs(task), offset);\n}\n\nstatic int set_segment_reg(struct task_struct *task,\n\t\t\t   unsigned long offset, u16 value)\n{\n\tif (WARN_ON_ONCE(task == current))\n\t\treturn -EIO;\n\n\t \n\tif (invalid_selector(value))\n\t\treturn -EIO;\n\n\t \n\n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct,fs):\n\t\ttask->thread.fsindex = value;\n\t\tbreak;\n\tcase offsetof(struct user_regs_struct,gs):\n\t\ttask->thread.gsindex = value;\n\t\tbreak;\n\tcase offsetof(struct user_regs_struct,ds):\n\t\ttask->thread.ds = value;\n\t\tbreak;\n\tcase offsetof(struct user_regs_struct,es):\n\t\ttask->thread.es = value;\n\t\tbreak;\n\n\t\t \n\tcase offsetof(struct user_regs_struct,cs):\n\t\tif (unlikely(value == 0))\n\t\t\treturn -EIO;\n\t\ttask_pt_regs(task)->cs = value;\n\t\tbreak;\n\tcase offsetof(struct user_regs_struct,ss):\n\t\tif (unlikely(value == 0))\n\t\t\treturn -EIO;\n\t\ttask_pt_regs(task)->ss = value;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#endif\t \n\nstatic unsigned long get_flags(struct task_struct *task)\n{\n\tunsigned long retval = task_pt_regs(task)->flags;\n\n\t \n\tif (test_tsk_thread_flag(task, TIF_FORCED_TF))\n\t\tretval &= ~X86_EFLAGS_TF;\n\n\treturn retval;\n}\n\nstatic int set_flags(struct task_struct *task, unsigned long value)\n{\n\tstruct pt_regs *regs = task_pt_regs(task);\n\n\t \n\tif (value & X86_EFLAGS_TF)\n\t\tclear_tsk_thread_flag(task, TIF_FORCED_TF);\n\telse if (test_tsk_thread_flag(task, TIF_FORCED_TF))\n\t\tvalue |= X86_EFLAGS_TF;\n\n\tregs->flags = (regs->flags & ~FLAG_MASK) | (value & FLAG_MASK);\n\n\treturn 0;\n}\n\nstatic int putreg(struct task_struct *child,\n\t\t  unsigned long offset, unsigned long value)\n{\n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct, cs):\n\tcase offsetof(struct user_regs_struct, ds):\n\tcase offsetof(struct user_regs_struct, es):\n\tcase offsetof(struct user_regs_struct, fs):\n\tcase offsetof(struct user_regs_struct, gs):\n\tcase offsetof(struct user_regs_struct, ss):\n\t\treturn set_segment_reg(child, offset, value);\n\n\tcase offsetof(struct user_regs_struct, flags):\n\t\treturn set_flags(child, value);\n\n#ifdef CONFIG_X86_64\n\tcase offsetof(struct user_regs_struct,fs_base):\n\t\tif (value >= TASK_SIZE_MAX)\n\t\t\treturn -EIO;\n\t\tx86_fsbase_write_task(child, value);\n\t\treturn 0;\n\tcase offsetof(struct user_regs_struct,gs_base):\n\t\tif (value >= TASK_SIZE_MAX)\n\t\t\treturn -EIO;\n\t\tx86_gsbase_write_task(child, value);\n\t\treturn 0;\n#endif\n\t}\n\n\t*pt_regs_access(task_pt_regs(child), offset) = value;\n\treturn 0;\n}\n\nstatic unsigned long getreg(struct task_struct *task, unsigned long offset)\n{\n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct, cs):\n\tcase offsetof(struct user_regs_struct, ds):\n\tcase offsetof(struct user_regs_struct, es):\n\tcase offsetof(struct user_regs_struct, fs):\n\tcase offsetof(struct user_regs_struct, gs):\n\tcase offsetof(struct user_regs_struct, ss):\n\t\treturn get_segment_reg(task, offset);\n\n\tcase offsetof(struct user_regs_struct, flags):\n\t\treturn get_flags(task);\n\n#ifdef CONFIG_X86_64\n\tcase offsetof(struct user_regs_struct, fs_base):\n\t\treturn x86_fsbase_read_task(task);\n\tcase offsetof(struct user_regs_struct, gs_base):\n\t\treturn x86_gsbase_read_task(task);\n#endif\n\t}\n\n\treturn *pt_regs_access(task_pt_regs(task), offset);\n}\n\nstatic int genregs_get(struct task_struct *target,\n\t\t       const struct user_regset *regset,\n\t\t       struct membuf to)\n{\n\tint reg;\n\n\tfor (reg = 0; to.left; reg++)\n\t\tmembuf_store(&to, getreg(target, reg * sizeof(unsigned long)));\n\treturn 0;\n}\n\nstatic int genregs_set(struct task_struct *target,\n\t\t       const struct user_regset *regset,\n\t\t       unsigned int pos, unsigned int count,\n\t\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\tif (kbuf) {\n\t\tconst unsigned long *k = kbuf;\n\t\twhile (count >= sizeof(*k) && !ret) {\n\t\t\tret = putreg(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst unsigned long  __user *u = ubuf;\n\t\twhile (count >= sizeof(*u) && !ret) {\n\t\t\tunsigned long word;\n\t\t\tret = __get_user(word, u++);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = putreg(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void ptrace_triggered(struct perf_event *bp,\n\t\t\t     struct perf_sample_data *data,\n\t\t\t     struct pt_regs *regs)\n{\n\tint i;\n\tstruct thread_struct *thread = &(current->thread);\n\n\t \n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (thread->ptrace_bps[i] == bp)\n\t\t\tbreak;\n\t}\n\n\tthread->virtual_dr6 |= (DR_TRAP0 << i);\n}\n\n \nstatic unsigned long ptrace_get_dr7(struct perf_event *bp[])\n{\n\tint i;\n\tint dr7 = 0;\n\tstruct arch_hw_breakpoint *info;\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (bp[i] && !bp[i]->attr.disabled) {\n\t\t\tinfo = counter_arch_bp(bp[i]);\n\t\t\tdr7 |= encode_dr7(i, info->len, info->type);\n\t\t}\n\t}\n\n\treturn dr7;\n}\n\nstatic int ptrace_fill_bp_fields(struct perf_event_attr *attr,\n\t\t\t\t\tint len, int type, bool disabled)\n{\n\tint err, bp_len, bp_type;\n\n\terr = arch_bp_generic_fields(len, type, &bp_len, &bp_type);\n\tif (!err) {\n\t\tattr->bp_len = bp_len;\n\t\tattr->bp_type = bp_type;\n\t\tattr->disabled = disabled;\n\t}\n\n\treturn err;\n}\n\nstatic struct perf_event *\nptrace_register_breakpoint(struct task_struct *tsk, int len, int type,\n\t\t\t\tunsigned long addr, bool disabled)\n{\n\tstruct perf_event_attr attr;\n\tint err;\n\n\tptrace_breakpoint_init(&attr);\n\tattr.bp_addr = addr;\n\n\terr = ptrace_fill_bp_fields(&attr, len, type, disabled);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn register_user_hw_breakpoint(&attr, ptrace_triggered,\n\t\t\t\t\t\t NULL, tsk);\n}\n\nstatic int ptrace_modify_breakpoint(struct perf_event *bp, int len, int type,\n\t\t\t\t\tint disabled)\n{\n\tstruct perf_event_attr attr = bp->attr;\n\tint err;\n\n\terr = ptrace_fill_bp_fields(&attr, len, type, disabled);\n\tif (err)\n\t\treturn err;\n\n\treturn modify_user_hw_breakpoint(bp, &attr);\n}\n\n \nstatic int ptrace_write_dr7(struct task_struct *tsk, unsigned long data)\n{\n\tstruct thread_struct *thread = &tsk->thread;\n\tunsigned long old_dr7;\n\tbool second_pass = false;\n\tint i, rc, ret = 0;\n\n\tdata &= ~DR_CONTROL_RESERVED;\n\told_dr7 = ptrace_get_dr7(thread->ptrace_bps);\n\nrestore:\n\trc = 0;\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tunsigned len, type;\n\t\tbool disabled = !decode_dr7(data, i, &len, &type);\n\t\tstruct perf_event *bp = thread->ptrace_bps[i];\n\n\t\tif (!bp) {\n\t\t\tif (disabled)\n\t\t\t\tcontinue;\n\n\t\t\tbp = ptrace_register_breakpoint(tsk,\n\t\t\t\t\tlen, type, 0, disabled);\n\t\t\tif (IS_ERR(bp)) {\n\t\t\t\trc = PTR_ERR(bp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthread->ptrace_bps[i] = bp;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = ptrace_modify_breakpoint(bp, len, type, disabled);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (rc && !WARN_ON(second_pass)) {\n\t\tret = rc;\n\t\tdata = old_dr7;\n\t\tsecond_pass = true;\n\t\tgoto restore;\n\t}\n\n\treturn ret;\n}\n\n \nstatic unsigned long ptrace_get_debugreg(struct task_struct *tsk, int n)\n{\n\tstruct thread_struct *thread = &tsk->thread;\n\tunsigned long val = 0;\n\n\tif (n < HBP_NUM) {\n\t\tint index = array_index_nospec(n, HBP_NUM);\n\t\tstruct perf_event *bp = thread->ptrace_bps[index];\n\n\t\tif (bp)\n\t\t\tval = bp->hw.info.address;\n\t} else if (n == 6) {\n\t\tval = thread->virtual_dr6 ^ DR6_RESERVED;  \n\t} else if (n == 7) {\n\t\tval = thread->ptrace_dr7;\n\t}\n\treturn val;\n}\n\nstatic int ptrace_set_breakpoint_addr(struct task_struct *tsk, int nr,\n\t\t\t\t      unsigned long addr)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\tstruct perf_event *bp = t->ptrace_bps[nr];\n\tint err = 0;\n\n\tif (!bp) {\n\t\t \n\t\tbp = ptrace_register_breakpoint(tsk,\n\t\t\t\tX86_BREAKPOINT_LEN_1, X86_BREAKPOINT_WRITE,\n\t\t\t\taddr, true);\n\t\tif (IS_ERR(bp))\n\t\t\terr = PTR_ERR(bp);\n\t\telse\n\t\t\tt->ptrace_bps[nr] = bp;\n\t} else {\n\t\tstruct perf_event_attr attr = bp->attr;\n\n\t\tattr.bp_addr = addr;\n\t\terr = modify_user_hw_breakpoint(bp, &attr);\n\t}\n\n\treturn err;\n}\n\n \nstatic int ptrace_set_debugreg(struct task_struct *tsk, int n,\n\t\t\t       unsigned long val)\n{\n\tstruct thread_struct *thread = &tsk->thread;\n\t \n\tint rc = -EIO;\n\n\tif (n < HBP_NUM) {\n\t\trc = ptrace_set_breakpoint_addr(tsk, n, val);\n\t} else if (n == 6) {\n\t\tthread->virtual_dr6 = val ^ DR6_RESERVED;  \n\t\trc = 0;\n\t} else if (n == 7) {\n\t\trc = ptrace_write_dr7(tsk, val);\n\t\tif (!rc)\n\t\t\tthread->ptrace_dr7 = val;\n\t}\n\treturn rc;\n}\n\n \nstatic int ioperm_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tstruct io_bitmap *iobm = target->thread.io_bitmap;\n\n\treturn iobm ? DIV_ROUND_UP(iobm->max, regset->size) : 0;\n}\n\nstatic int ioperm_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      struct membuf to)\n{\n\tstruct io_bitmap *iobm = target->thread.io_bitmap;\n\n\tif (!iobm)\n\t\treturn -ENXIO;\n\n\treturn membuf_write(&to, iobm->bitmap, IO_BITMAP_BYTES);\n}\n\n \nvoid ptrace_disable(struct task_struct *child)\n{\n\tuser_disable_single_step(child);\n}\n\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\nstatic const struct user_regset_view user_x86_32_view;  \n#endif\n#ifdef CONFIG_X86_64\nstatic const struct user_regset_view user_x86_64_view;  \n#endif\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret;\n\tunsigned long __user *datap = (unsigned long __user *)data;\n\n#ifdef CONFIG_X86_64\n\t \n\tconst struct user_regset_view *regset_view = &user_x86_64_view;\n#else\n\t \n\tconst struct user_regset_view *regset_view = &user_x86_32_view;\n#endif\n\n\tswitch (request) {\n\t \n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long tmp;\n\n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user))\n\t\t\tbreak;\n\n\t\ttmp = 0;   \n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\ttmp = getreg(child, addr);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\ttmp = ptrace_get_debugreg(child, addr / sizeof(data));\n\t\t}\n\t\tret = put_user(tmp, datap);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_POKEUSR:  \n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user))\n\t\t\tbreak;\n\n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\tret = putreg(child, addr, data);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\tret = ptrace_set_debugreg(child,\n\t\t\t\t\t\t  addr / sizeof(data), data);\n\t\t}\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\t \n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   regset_view,\n\t\t\t\t\t   REGSET_GENERAL,\n\t\t\t\t\t   0, sizeof(struct user_regs_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETREGS:\t \n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     regset_view,\n\t\t\t\t\t     REGSET_GENERAL,\n\t\t\t\t\t     0, sizeof(struct user_regs_struct),\n\t\t\t\t\t     datap);\n\n\tcase PTRACE_GETFPREGS:\t \n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   regset_view,\n\t\t\t\t\t   REGSET_FP,\n\t\t\t\t\t   0, sizeof(struct user_i387_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETFPREGS:\t \n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     regset_view,\n\t\t\t\t\t     REGSET_FP,\n\t\t\t\t\t     0, sizeof(struct user_i387_struct),\n\t\t\t\t\t     datap);\n\n#ifdef CONFIG_X86_32\n\tcase PTRACE_GETFPXREGS:\t \n\t\treturn copy_regset_to_user(child, &user_x86_32_view,\n\t\t\t\t\t   REGSET32_XFP,\n\t\t\t\t\t   0, sizeof(struct user_fxsr_struct),\n\t\t\t\t\t   datap) ? -EIO : 0;\n\n\tcase PTRACE_SETFPXREGS:\t \n\t\treturn copy_regset_from_user(child, &user_x86_32_view,\n\t\t\t\t\t     REGSET32_XFP,\n\t\t\t\t\t     0, sizeof(struct user_fxsr_struct),\n\t\t\t\t\t     datap) ? -EIO : 0;\n#endif\n\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\tcase PTRACE_GET_THREAD_AREA:\n\t\tif ((int) addr < 0)\n\t\t\treturn -EIO;\n\t\tret = do_get_thread_area(child, addr,\n\t\t\t\t\t(struct user_desc __user *)data);\n\t\tbreak;\n\n\tcase PTRACE_SET_THREAD_AREA:\n\t\tif ((int) addr < 0)\n\t\t\treturn -EIO;\n\t\tret = do_set_thread_area(child, addr,\n\t\t\t\t\t(struct user_desc __user *)data, 0);\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_X86_64\n\t\t \n\tcase PTRACE_ARCH_PRCTL:\n\t\tret = do_arch_prctl_64(child, data, addr);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_IA32_EMULATION\n\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <asm/ia32.h>\n#include <asm/user32.h>\n\n#define R32(l,q)\t\t\t\t\t\t\t\\\n\tcase offsetof(struct user32, regs.l):\t\t\t\t\\\n\t\tregs->q = value; break\n\n#define SEG32(rs)\t\t\t\t\t\t\t\\\n\tcase offsetof(struct user32, regs.rs):\t\t\t\t\\\n\t\treturn set_segment_reg(child,\t\t\t\t\\\n\t\t\t\t       offsetof(struct user_regs_struct, rs), \\\n\t\t\t\t       value);\t\t\t\t\\\n\t\tbreak\n\nstatic int putreg32(struct task_struct *child, unsigned regno, u32 value)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tint ret;\n\n\tswitch (regno) {\n\n\tSEG32(cs);\n\tSEG32(ds);\n\tSEG32(es);\n\n\t \n\n\tcase offsetof(struct user32, regs.fs):\n\t\tret = set_segment_reg(child,\n\t\t\t\t      offsetof(struct user_regs_struct, fs),\n\t\t\t\t      value);\n\t\tif (ret == 0)\n\t\t\tchild->thread.fsbase =\n\t\t\t\tx86_fsgsbase_read_task(child, value);\n\t\treturn ret;\n\n\tcase offsetof(struct user32, regs.gs):\n\t\tret = set_segment_reg(child,\n\t\t\t\t      offsetof(struct user_regs_struct, gs),\n\t\t\t\t      value);\n\t\tif (ret == 0)\n\t\t\tchild->thread.gsbase =\n\t\t\t\tx86_fsgsbase_read_task(child, value);\n\t\treturn ret;\n\n\tSEG32(ss);\n\n\tR32(ebx, bx);\n\tR32(ecx, cx);\n\tR32(edx, dx);\n\tR32(edi, di);\n\tR32(esi, si);\n\tR32(ebp, bp);\n\tR32(eax, ax);\n\tR32(eip, ip);\n\tR32(esp, sp);\n\n\tcase offsetof(struct user32, regs.orig_eax):\n\t\t \n\t\tregs->orig_ax = value;\n\t\tif (syscall_get_nr(child, regs) != -1)\n\t\t\tchild->thread_info.status |= TS_I386_REGS_POKED;\n\t\tbreak;\n\n\tcase offsetof(struct user32, regs.eflags):\n\t\treturn set_flags(child, value);\n\n\tcase offsetof(struct user32, u_debugreg[0]) ...\n\t\toffsetof(struct user32, u_debugreg[7]):\n\t\tregno -= offsetof(struct user32, u_debugreg[0]);\n\t\treturn ptrace_set_debugreg(child, regno / 4, value);\n\n\tdefault:\n\t\tif (regno > sizeof(struct user32) || (regno & 3))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#undef R32\n#undef SEG32\n\n#define R32(l,q)\t\t\t\t\t\t\t\\\n\tcase offsetof(struct user32, regs.l):\t\t\t\t\\\n\t\t*val = regs->q; break\n\n#define SEG32(rs)\t\t\t\t\t\t\t\\\n\tcase offsetof(struct user32, regs.rs):\t\t\t\t\\\n\t\t*val = get_segment_reg(child,\t\t\t\t\\\n\t\t\t\t       offsetof(struct user_regs_struct, rs)); \\\n\t\tbreak\n\nstatic int getreg32(struct task_struct *child, unsigned regno, u32 *val)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\n\tswitch (regno) {\n\n\tSEG32(ds);\n\tSEG32(es);\n\tSEG32(fs);\n\tSEG32(gs);\n\n\tR32(cs, cs);\n\tR32(ss, ss);\n\tR32(ebx, bx);\n\tR32(ecx, cx);\n\tR32(edx, dx);\n\tR32(edi, di);\n\tR32(esi, si);\n\tR32(ebp, bp);\n\tR32(eax, ax);\n\tR32(orig_eax, orig_ax);\n\tR32(eip, ip);\n\tR32(esp, sp);\n\n\tcase offsetof(struct user32, regs.eflags):\n\t\t*val = get_flags(child);\n\t\tbreak;\n\n\tcase offsetof(struct user32, u_debugreg[0]) ...\n\t\toffsetof(struct user32, u_debugreg[7]):\n\t\tregno -= offsetof(struct user32, u_debugreg[0]);\n\t\t*val = ptrace_get_debugreg(child, regno / 4);\n\t\tbreak;\n\n\tdefault:\n\t\tif (regno > sizeof(struct user32) || (regno & 3))\n\t\t\treturn -EIO;\n\n\t\t \n\t\t*val = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#undef R32\n#undef SEG32\n\nstatic int genregs32_get(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t struct membuf to)\n{\n\tint reg;\n\n\tfor (reg = 0; to.left; reg++) {\n\t\tu32 val;\n\t\tgetreg32(target, reg * 4, &val);\n\t\tmembuf_store(&to, val);\n\t}\n\treturn 0;\n}\n\nstatic int genregs32_set(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\tif (kbuf) {\n\t\tconst compat_ulong_t *k = kbuf;\n\t\twhile (count >= sizeof(*k) && !ret) {\n\t\t\tret = putreg32(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst compat_ulong_t __user *u = ubuf;\n\t\twhile (count >= sizeof(*u) && !ret) {\n\t\t\tcompat_ulong_t word;\n\t\t\tret = __get_user(word, u++);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = putreg32(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic long ia32_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\t     compat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tvoid __user *datap = compat_ptr(data);\n\tint ret;\n\t__u32 val;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKUSR:\n\t\tret = getreg32(child, addr, &val);\n\t\tif (ret == 0)\n\t\t\tret = put_user(val, (__u32 __user *)datap);\n\t\tbreak;\n\n\tcase PTRACE_POKEUSR:\n\t\tret = putreg32(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\t \n\t\treturn copy_regset_to_user(child, &user_x86_32_view,\n\t\t\t\t\t   REGSET_GENERAL,\n\t\t\t\t\t   0, sizeof(struct user_regs_struct32),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETREGS:\t \n\t\treturn copy_regset_from_user(child, &user_x86_32_view,\n\t\t\t\t\t     REGSET_GENERAL, 0,\n\t\t\t\t\t     sizeof(struct user_regs_struct32),\n\t\t\t\t\t     datap);\n\n\tcase PTRACE_GETFPREGS:\t \n\t\treturn copy_regset_to_user(child, &user_x86_32_view,\n\t\t\t\t\t   REGSET_FP, 0,\n\t\t\t\t\t   sizeof(struct user_i387_ia32_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETFPREGS:\t \n\t\treturn copy_regset_from_user(\n\t\t\tchild, &user_x86_32_view, REGSET_FP,\n\t\t\t0, sizeof(struct user_i387_ia32_struct), datap);\n\n\tcase PTRACE_GETFPXREGS:\t \n\t\treturn copy_regset_to_user(child, &user_x86_32_view,\n\t\t\t\t\t   REGSET32_XFP, 0,\n\t\t\t\t\t   sizeof(struct user32_fxsr_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETFPXREGS:\t \n\t\treturn copy_regset_from_user(child, &user_x86_32_view,\n\t\t\t\t\t     REGSET32_XFP, 0,\n\t\t\t\t\t     sizeof(struct user32_fxsr_struct),\n\t\t\t\t\t     datap);\n\n\tcase PTRACE_GET_THREAD_AREA:\n\tcase PTRACE_SET_THREAD_AREA:\n\t\treturn arch_ptrace(child, request, addr, data);\n\n\tdefault:\n\t\treturn compat_ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_X86_X32_ABI\nstatic long x32_arch_ptrace(struct task_struct *child,\n\t\t\t    compat_long_t request, compat_ulong_t caddr,\n\t\t\t    compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tvoid __user *datap = compat_ptr(data);\n\tint ret;\n\n\tswitch (request) {\n\t \n\tcase PTRACE_PEEKUSR: {\n\t\tu32 tmp;\n\n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user) ||\n\t\t    addr < offsetof(struct user_regs_struct, cs))\n\t\t\tbreak;\n\n\t\ttmp = 0;   \n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\ttmp = getreg(child, addr);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\ttmp = ptrace_get_debugreg(child, addr / sizeof(data));\n\t\t}\n\t\tret = put_user(tmp, (__u32 __user *)datap);\n\t\tbreak;\n\t}\n\n\t \n\tcase PTRACE_POKEUSR:\n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user) ||\n\t\t    addr < offsetof(struct user_regs_struct, cs))\n\t\t\tbreak;\n\n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\tret = putreg(child, addr, data);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\tret = ptrace_set_debugreg(child,\n\t\t\t\t\t\t  addr / sizeof(data), data);\n\t\t}\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\t \n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   &user_x86_64_view,\n\t\t\t\t\t   REGSET_GENERAL,\n\t\t\t\t\t   0, sizeof(struct user_regs_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETREGS:\t \n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     &user_x86_64_view,\n\t\t\t\t\t     REGSET_GENERAL,\n\t\t\t\t\t     0, sizeof(struct user_regs_struct),\n\t\t\t\t\t     datap);\n\n\tcase PTRACE_GETFPREGS:\t \n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   &user_x86_64_view,\n\t\t\t\t\t   REGSET_FP,\n\t\t\t\t\t   0, sizeof(struct user_i387_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETFPREGS:\t \n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     &user_x86_64_view,\n\t\t\t\t\t     REGSET_FP,\n\t\t\t\t\t     0, sizeof(struct user_i387_struct),\n\t\t\t\t\t     datap);\n\n\tdefault:\n\t\treturn compat_ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_COMPAT\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n#ifdef CONFIG_X86_X32_ABI\n\tif (!in_ia32_syscall())\n\t\treturn x32_arch_ptrace(child, request, caddr, cdata);\n#endif\n#ifdef CONFIG_IA32_EMULATION\n\treturn ia32_arch_ptrace(child, request, caddr, cdata);\n#else\n\treturn 0;\n#endif\n}\n#endif\t \n\n#ifdef CONFIG_X86_64\n\nstatic struct user_regset x86_64_regsets[] __ro_after_init = {\n\t[REGSET64_GENERAL] = {\n\t\t.core_note_type\t= NT_PRSTATUS,\n\t\t.n\t\t= sizeof(struct user_regs_struct) / sizeof(long),\n\t\t.size\t\t= sizeof(long),\n\t\t.align\t\t= sizeof(long),\n\t\t.regset_get\t= genregs_get,\n\t\t.set\t\t= genregs_set\n\t},\n\t[REGSET64_FP] = {\n\t\t.core_note_type\t= NT_PRFPREG,\n\t\t.n\t\t= sizeof(struct fxregs_state) / sizeof(long),\n\t\t.size\t\t= sizeof(long),\n\t\t.align\t\t= sizeof(long),\n\t\t.active\t\t= regset_xregset_fpregs_active,\n\t\t.regset_get\t= xfpregs_get,\n\t\t.set\t\t= xfpregs_set\n\t},\n\t[REGSET64_XSTATE] = {\n\t\t.core_note_type\t= NT_X86_XSTATE,\n\t\t.size\t\t= sizeof(u64),\n\t\t.align\t\t= sizeof(u64),\n\t\t.active\t\t= xstateregs_active,\n\t\t.regset_get\t= xstateregs_get,\n\t\t.set\t\t= xstateregs_set\n\t},\n\t[REGSET64_IOPERM] = {\n\t\t.core_note_type\t= NT_386_IOPERM,\n\t\t.n\t\t= IO_BITMAP_LONGS,\n\t\t.size\t\t= sizeof(long),\n\t\t.align\t\t= sizeof(long),\n\t\t.active\t\t= ioperm_active,\n\t\t.regset_get\t= ioperm_get\n\t},\n#ifdef CONFIG_X86_USER_SHADOW_STACK\n\t[REGSET64_SSP] = {\n\t\t.core_note_type\t= NT_X86_SHSTK,\n\t\t.n\t\t= 1,\n\t\t.size\t\t= sizeof(u64),\n\t\t.align\t\t= sizeof(u64),\n\t\t.active\t\t= ssp_active,\n\t\t.regset_get\t= ssp_get,\n\t\t.set\t\t= ssp_set\n\t},\n#endif\n};\n\nstatic const struct user_regset_view user_x86_64_view = {\n\t.name = \"x86_64\", .e_machine = EM_X86_64,\n\t.regsets = x86_64_regsets, .n = ARRAY_SIZE(x86_64_regsets)\n};\n\n#else   \n\n#define user_regs_struct32\tuser_regs_struct\n#define genregs32_get\t\tgenregs_get\n#define genregs32_set\t\tgenregs_set\n\n#endif\t \n\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\nstatic struct user_regset x86_32_regsets[] __ro_after_init = {\n\t[REGSET32_GENERAL] = {\n\t\t.core_note_type\t= NT_PRSTATUS,\n\t\t.n\t\t= sizeof(struct user_regs_struct32) / sizeof(u32),\n\t\t.size\t\t= sizeof(u32),\n\t\t.align\t\t= sizeof(u32),\n\t\t.regset_get\t= genregs32_get,\n\t\t.set\t\t= genregs32_set\n\t},\n\t[REGSET32_FP] = {\n\t\t.core_note_type\t= NT_PRFPREG,\n\t\t.n\t\t= sizeof(struct user_i387_ia32_struct) / sizeof(u32),\n\t\t.size\t\t= sizeof(u32),\n\t\t.align\t\t= sizeof(u32),\n\t\t.active\t\t= regset_fpregs_active,\n\t\t.regset_get\t= fpregs_get,\n\t\t.set\t\t= fpregs_set\n\t},\n\t[REGSET32_XFP] = {\n\t\t.core_note_type\t= NT_PRXFPREG,\n\t\t.n\t\t= sizeof(struct fxregs_state) / sizeof(u32),\n\t\t.size\t\t= sizeof(u32),\n\t\t.align\t\t= sizeof(u32),\n\t\t.active\t\t= regset_xregset_fpregs_active,\n\t\t.regset_get\t= xfpregs_get,\n\t\t.set\t\t= xfpregs_set\n\t},\n\t[REGSET32_XSTATE] = {\n\t\t.core_note_type\t= NT_X86_XSTATE,\n\t\t.size\t\t= sizeof(u64),\n\t\t.align\t\t= sizeof(u64),\n\t\t.active\t\t= xstateregs_active,\n\t\t.regset_get\t= xstateregs_get,\n\t\t.set\t\t= xstateregs_set\n\t},\n\t[REGSET32_TLS] = {\n\t\t.core_note_type\t= NT_386_TLS,\n\t\t.n\t\t= GDT_ENTRY_TLS_ENTRIES,\n\t\t.bias\t\t= GDT_ENTRY_TLS_MIN,\n\t\t.size\t\t= sizeof(struct user_desc),\n\t\t.align\t\t= sizeof(struct user_desc),\n\t\t.active\t\t= regset_tls_active,\n\t\t.regset_get\t= regset_tls_get,\n\t\t.set\t\t= regset_tls_set\n\t},\n\t[REGSET32_IOPERM] = {\n\t\t.core_note_type\t= NT_386_IOPERM,\n\t\t.n\t\t= IO_BITMAP_BYTES / sizeof(u32),\n\t\t.size\t\t= sizeof(u32),\n\t\t.align\t\t= sizeof(u32),\n\t\t.active\t\t= ioperm_active,\n\t\t.regset_get\t= ioperm_get\n\t},\n};\n\nstatic const struct user_regset_view user_x86_32_view = {\n\t.name = \"i386\", .e_machine = EM_386,\n\t.regsets = x86_32_regsets, .n = ARRAY_SIZE(x86_32_regsets)\n};\n#endif\n\n \nu64 xstate_fx_sw_bytes[USER_XSTATE_FX_SW_WORDS];\n\nvoid __init update_regset_xstate_info(unsigned int size, u64 xstate_mask)\n{\n#ifdef CONFIG_X86_64\n\tx86_64_regsets[REGSET64_XSTATE].n = size / sizeof(u64);\n#endif\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\tx86_32_regsets[REGSET32_XSTATE].n = size / sizeof(u64);\n#endif\n\txstate_fx_sw_bytes[USER_XSTATE_XCR0_WORD] = xstate_mask;\n}\n\n \nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_IA32_EMULATION\n\tif (!user_64bit_mode(task_pt_regs(task)))\n#endif\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\t\treturn &user_x86_32_view;\n#endif\n#ifdef CONFIG_X86_64\n\treturn &user_x86_64_view;\n#endif\n}\n\nvoid send_sigtrap(struct pt_regs *regs, int error_code, int si_code)\n{\n\tstruct task_struct *tsk = current;\n\n\ttsk->thread.trap_nr = X86_TRAP_DB;\n\ttsk->thread.error_code = error_code;\n\n\t \n\tforce_sig_fault(SIGTRAP, si_code,\n\t\t\tuser_mode(regs) ? (void __user *)regs->ip : NULL);\n}\n\nvoid user_single_step_report(struct pt_regs *regs)\n{\n\tsend_sigtrap(regs, 0, TRAP_BRKPT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}