{
  "module_name": "mpparse.c",
  "hash_id": "8a073f2ee05bda6adb435889006224529baac443ada58adba78db0b6d468121d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/mpparse.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/kernel_stat.h>\n#include <linux/mc146818rtc.h>\n#include <linux/bitops.h>\n#include <linux/acpi.h>\n#include <linux/smp.h>\n#include <linux/pci.h>\n\n#include <asm/i8259.h>\n#include <asm/io_apic.h>\n#include <asm/acpi.h>\n#include <asm/irqdomain.h>\n#include <asm/mtrr.h>\n#include <asm/mpspec.h>\n#include <asm/proto.h>\n#include <asm/bios_ebda.h>\n#include <asm/e820/api.h>\n#include <asm/setup.h>\n#include <asm/smp.h>\n\n#include <asm/apic.h>\n \n\nstatic int __init mpf_checksum(unsigned char *mp, int len)\n{\n\tint sum = 0;\n\n\twhile (len--)\n\t\tsum += *mp++;\n\n\treturn sum & 0xFF;\n}\n\nstatic void __init MP_processor_info(struct mpc_cpu *m)\n{\n\tchar *bootup_cpu = \"\";\n\n\tif (!(m->cpuflag & CPU_ENABLED)) {\n\t\tdisabled_cpus++;\n\t\treturn;\n\t}\n\n\tif (m->cpuflag & CPU_BOOTPROCESSOR)\n\t\tbootup_cpu = \" (Bootup-CPU)\";\n\n\tpr_info(\"Processor #%d%s\\n\", m->apicid, bootup_cpu);\n\tgeneric_processor_info(m->apicid);\n}\n\n#ifdef CONFIG_X86_IO_APIC\nstatic void __init mpc_oem_bus_info(struct mpc_bus *m, char *str)\n{\n\tmemcpy(str, m->bustype, 6);\n\tstr[6] = 0;\n\tapic_printk(APIC_VERBOSE, \"Bus #%d is %s\\n\", m->busid, str);\n}\n\nstatic void __init MP_bus_info(struct mpc_bus *m)\n{\n\tchar str[7];\n\n\tmpc_oem_bus_info(m, str);\n\n#if MAX_MP_BUSSES < 256\n\tif (m->busid >= MAX_MP_BUSSES) {\n\t\tpr_warn(\"MP table busid value (%d) for bustype %s is too large, max. supported is %d\\n\",\n\t\t\tm->busid, str, MAX_MP_BUSSES - 1);\n\t\treturn;\n\t}\n#endif\n\n\tset_bit(m->busid, mp_bus_not_pci);\n\tif (strncmp(str, BUSTYPE_ISA, sizeof(BUSTYPE_ISA) - 1) == 0) {\n#ifdef CONFIG_EISA\n\t\tmp_bus_id_to_type[m->busid] = MP_BUS_ISA;\n#endif\n\t} else if (strncmp(str, BUSTYPE_PCI, sizeof(BUSTYPE_PCI) - 1) == 0) {\n\t\tclear_bit(m->busid, mp_bus_not_pci);\n#ifdef CONFIG_EISA\n\t\tmp_bus_id_to_type[m->busid] = MP_BUS_PCI;\n\t} else if (strncmp(str, BUSTYPE_EISA, sizeof(BUSTYPE_EISA) - 1) == 0) {\n\t\tmp_bus_id_to_type[m->busid] = MP_BUS_EISA;\n#endif\n\t} else\n\t\tpr_warn(\"Unknown bustype %s - ignoring\\n\", str);\n}\n\nstatic void __init MP_ioapic_info(struct mpc_ioapic *m)\n{\n\tstruct ioapic_domain_cfg cfg = {\n\t\t.type = IOAPIC_DOMAIN_LEGACY,\n\t\t.ops = &mp_ioapic_irqdomain_ops,\n\t};\n\n\tif (m->flags & MPC_APIC_USABLE)\n\t\tmp_register_ioapic(m->apicid, m->apicaddr, gsi_top, &cfg);\n}\n\nstatic void __init print_mp_irq_info(struct mpc_intsrc *mp_irq)\n{\n\tapic_printk(APIC_VERBOSE,\n\t\t\"Int: type %d, pol %d, trig %d, bus %02x, IRQ %02x, APIC ID %x, APIC INT %02x\\n\",\n\t\tmp_irq->irqtype, mp_irq->irqflag & 3,\n\t\t(mp_irq->irqflag >> 2) & 3, mp_irq->srcbus,\n\t\tmp_irq->srcbusirq, mp_irq->dstapic, mp_irq->dstirq);\n}\n\n#else  \nstatic inline void __init MP_bus_info(struct mpc_bus *m) {}\nstatic inline void __init MP_ioapic_info(struct mpc_ioapic *m) {}\n#endif  \n\nstatic void __init MP_lintsrc_info(struct mpc_lintsrc *m)\n{\n\tapic_printk(APIC_VERBOSE,\n\t\t\"Lint: type %d, pol %d, trig %d, bus %02x, IRQ %02x, APIC ID %x, APIC LINT %02x\\n\",\n\t\tm->irqtype, m->irqflag & 3, (m->irqflag >> 2) & 3, m->srcbusid,\n\t\tm->srcbusirq, m->destapic, m->destapiclint);\n}\n\n \nstatic int __init smp_check_mpc(struct mpc_table *mpc, char *oem, char *str)\n{\n\n\tif (memcmp(mpc->signature, MPC_SIGNATURE, 4)) {\n\t\tpr_err(\"MPTABLE: bad signature [%c%c%c%c]!\\n\",\n\t\t       mpc->signature[0], mpc->signature[1],\n\t\t       mpc->signature[2], mpc->signature[3]);\n\t\treturn 0;\n\t}\n\tif (mpf_checksum((unsigned char *)mpc, mpc->length)) {\n\t\tpr_err(\"MPTABLE: checksum error!\\n\");\n\t\treturn 0;\n\t}\n\tif (mpc->spec != 0x01 && mpc->spec != 0x04) {\n\t\tpr_err(\"MPTABLE: bad table version (%d)!!\\n\", mpc->spec);\n\t\treturn 0;\n\t}\n\tif (!mpc->lapic) {\n\t\tpr_err(\"MPTABLE: null local APIC address!\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(oem, mpc->oem, 8);\n\toem[8] = 0;\n\tpr_info(\"MPTABLE: OEM ID: %s\\n\", oem);\n\n\tmemcpy(str, mpc->productid, 12);\n\tstr[12] = 0;\n\n\tpr_info(\"MPTABLE: Product ID: %s\\n\", str);\n\n\tpr_info(\"MPTABLE: APIC at: 0x%X\\n\", mpc->lapic);\n\n\treturn 1;\n}\n\nstatic void skip_entry(unsigned char **ptr, int *count, int size)\n{\n\t*ptr += size;\n\t*count += size;\n}\n\nstatic void __init smp_dump_mptable(struct mpc_table *mpc, unsigned char *mpt)\n{\n\tpr_err(\"Your mptable is wrong, contact your HW vendor!\\n\");\n\tpr_cont(\"type %x\\n\", *mpt);\n\tprint_hex_dump(KERN_ERR, \"  \", DUMP_PREFIX_ADDRESS, 16,\n\t\t\t1, mpc, mpc->length, 1);\n}\n\nstatic int __init smp_read_mpc(struct mpc_table *mpc, unsigned early)\n{\n\tchar str[16];\n\tchar oem[10];\n\n\tint count = sizeof(*mpc);\n\tunsigned char *mpt = ((unsigned char *)mpc) + count;\n\n\tif (!smp_check_mpc(mpc, oem, str))\n\t\treturn 0;\n\n\t \n\tif (!acpi_lapic)\n\t\tregister_lapic_address(mpc->lapic);\n\n\tif (early)\n\t\treturn 1;\n\n\t \n\twhile (count < mpc->length) {\n\t\tswitch (*mpt) {\n\t\tcase MP_PROCESSOR:\n\t\t\t \n\t\t\tif (!acpi_lapic)\n\t\t\t\tMP_processor_info((struct mpc_cpu *)mpt);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_cpu));\n\t\t\tbreak;\n\t\tcase MP_BUS:\n\t\t\tMP_bus_info((struct mpc_bus *)mpt);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_bus));\n\t\t\tbreak;\n\t\tcase MP_IOAPIC:\n\t\t\tMP_ioapic_info((struct mpc_ioapic *)mpt);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_ioapic));\n\t\t\tbreak;\n\t\tcase MP_INTSRC:\n\t\t\tmp_save_irq((struct mpc_intsrc *)mpt);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_intsrc));\n\t\t\tbreak;\n\t\tcase MP_LINTSRC:\n\t\t\tMP_lintsrc_info((struct mpc_lintsrc *)mpt);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_lintsrc));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsmp_dump_mptable(mpc, mpt);\n\t\t\tcount = mpc->length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!num_processors)\n\t\tpr_err(\"MPTABLE: no processors registered!\\n\");\n\treturn num_processors;\n}\n\n#ifdef CONFIG_X86_IO_APIC\n\nstatic int __init ELCR_trigger(unsigned int irq)\n{\n\tunsigned int port;\n\n\tport = PIC_ELCR1 + (irq >> 3);\n\treturn (inb(port) >> (irq & 7)) & 1;\n}\n\nstatic void __init construct_default_ioirq_mptable(int mpc_default_type)\n{\n\tstruct mpc_intsrc intsrc;\n\tint i;\n\tint ELCR_fallback = 0;\n\n\tintsrc.type = MP_INTSRC;\n\tintsrc.irqflag = MP_IRQTRIG_DEFAULT | MP_IRQPOL_DEFAULT;\n\tintsrc.srcbus = 0;\n\tintsrc.dstapic = mpc_ioapic_id(0);\n\n\tintsrc.irqtype = mp_INT;\n\n\t \n\tif (mpc_default_type == 5) {\n\t\tpr_info(\"ISA/PCI bus type with no IRQ information... falling back to ELCR\\n\");\n\n\t\tif (ELCR_trigger(0) || ELCR_trigger(1) || ELCR_trigger(2) ||\n\t\t    ELCR_trigger(13))\n\t\t\tpr_err(\"ELCR contains invalid data... not using ELCR\\n\");\n\t\telse {\n\t\t\tpr_info(\"Using ELCR to identify PCI interrupts\\n\");\n\t\t\tELCR_fallback = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tswitch (mpc_default_type) {\n\t\tcase 2:\n\t\t\tif (i == 0 || i == 13)\n\t\t\t\tcontinue;\t \n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (i == 2)\n\t\t\t\tcontinue;\t \n\t\t}\n\n\t\tif (ELCR_fallback) {\n\t\t\t \n\t\t\tif (ELCR_trigger(i)) {\n\t\t\t\tintsrc.irqflag = MP_IRQTRIG_LEVEL |\n\t\t\t\t\t\t MP_IRQPOL_ACTIVE_HIGH;\n\t\t\t} else {\n\t\t\t\tintsrc.irqflag = MP_IRQTRIG_DEFAULT |\n\t\t\t\t\t\t MP_IRQPOL_DEFAULT;\n\t\t\t}\n\t\t}\n\n\t\tintsrc.srcbusirq = i;\n\t\tintsrc.dstirq = i ? i : 2;\t \n\t\tmp_save_irq(&intsrc);\n\t}\n\n\tintsrc.irqtype = mp_ExtINT;\n\tintsrc.srcbusirq = 0;\n\tintsrc.dstirq = 0;\t \n\tmp_save_irq(&intsrc);\n}\n\n\nstatic void __init construct_ioapic_table(int mpc_default_type)\n{\n\tstruct mpc_ioapic ioapic;\n\tstruct mpc_bus bus;\n\n\tbus.type = MP_BUS;\n\tbus.busid = 0;\n\tswitch (mpc_default_type) {\n\tdefault:\n\t\tpr_err(\"???\\nUnknown standard configuration %d\\n\",\n\t\t       mpc_default_type);\n\t\tfallthrough;\n\tcase 1:\n\tcase 5:\n\t\tmemcpy(bus.bustype, \"ISA   \", 6);\n\t\tbreak;\n\tcase 2:\n\tcase 6:\n\tcase 3:\n\t\tmemcpy(bus.bustype, \"EISA  \", 6);\n\t\tbreak;\n\t}\n\tMP_bus_info(&bus);\n\tif (mpc_default_type > 4) {\n\t\tbus.busid = 1;\n\t\tmemcpy(bus.bustype, \"PCI   \", 6);\n\t\tMP_bus_info(&bus);\n\t}\n\n\tioapic.type\t= MP_IOAPIC;\n\tioapic.apicid\t= 2;\n\tioapic.apicver\t= mpc_default_type > 4 ? 0x10 : 0x01;\n\tioapic.flags\t= MPC_APIC_USABLE;\n\tioapic.apicaddr\t= IO_APIC_DEFAULT_PHYS_BASE;\n\tMP_ioapic_info(&ioapic);\n\n\t \n\tconstruct_default_ioirq_mptable(mpc_default_type);\n}\n#else\nstatic inline void __init construct_ioapic_table(int mpc_default_type) { }\n#endif\n\nstatic inline void __init construct_default_ISA_mptable(int mpc_default_type)\n{\n\tstruct mpc_cpu processor;\n\tstruct mpc_lintsrc lintsrc;\n\tint linttypes[2] = { mp_ExtINT, mp_NMI };\n\tint i;\n\n\t \n\tprocessor.type = MP_PROCESSOR;\n\t \n\tprocessor.apicver = mpc_default_type > 4 ? 0x10 : 0x01;\n\tprocessor.cpuflag = CPU_ENABLED;\n\tprocessor.cpufeature = (boot_cpu_data.x86 << 8) |\n\t    (boot_cpu_data.x86_model << 4) | boot_cpu_data.x86_stepping;\n\tprocessor.featureflag = boot_cpu_data.x86_capability[CPUID_1_EDX];\n\tprocessor.reserved[0] = 0;\n\tprocessor.reserved[1] = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tprocessor.apicid = i;\n\t\tMP_processor_info(&processor);\n\t}\n\n\tconstruct_ioapic_table(mpc_default_type);\n\n\tlintsrc.type = MP_LINTSRC;\n\tlintsrc.irqflag = MP_IRQTRIG_DEFAULT | MP_IRQPOL_DEFAULT;\n\tlintsrc.srcbusid = 0;\n\tlintsrc.srcbusirq = 0;\n\tlintsrc.destapic = MP_APIC_ALL;\n\tfor (i = 0; i < 2; i++) {\n\t\tlintsrc.irqtype = linttypes[i];\n\t\tlintsrc.destapiclint = i;\n\t\tMP_lintsrc_info(&lintsrc);\n\t}\n}\n\nstatic unsigned long mpf_base;\nstatic bool mpf_found;\n\nstatic unsigned long __init get_mpc_size(unsigned long physptr)\n{\n\tstruct mpc_table *mpc;\n\tunsigned long size;\n\n\tmpc = early_memremap(physptr, PAGE_SIZE);\n\tsize = mpc->length;\n\tearly_memunmap(mpc, PAGE_SIZE);\n\tapic_printk(APIC_VERBOSE, \"  mpc: %lx-%lx\\n\", physptr, physptr + size);\n\n\treturn size;\n}\n\nstatic int __init check_physptr(struct mpf_intel *mpf, unsigned int early)\n{\n\tstruct mpc_table *mpc;\n\tunsigned long size;\n\n\tsize = get_mpc_size(mpf->physptr);\n\tmpc = early_memremap(mpf->physptr, size);\n\n\t \n\tif (!smp_read_mpc(mpc, early)) {\n#ifdef CONFIG_X86_LOCAL_APIC\n\t\tsmp_found_config = 0;\n#endif\n\t\tpr_err(\"BIOS bug, MP table errors detected!...\\n\");\n\t\tpr_cont(\"... disabling SMP support. (tell your hw vendor)\\n\");\n\t\tearly_memunmap(mpc, size);\n\t\treturn -1;\n\t}\n\tearly_memunmap(mpc, size);\n\n\tif (early)\n\t\treturn -1;\n\n#ifdef CONFIG_X86_IO_APIC\n\t \n\tif (!mp_irq_entries) {\n\t\tstruct mpc_bus bus;\n\n\t\tpr_err(\"BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\\n\");\n\n\t\tbus.type = MP_BUS;\n\t\tbus.busid = 0;\n\t\tmemcpy(bus.bustype, \"ISA   \", 6);\n\t\tMP_bus_info(&bus);\n\n\t\tconstruct_default_ioirq_mptable(0);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nvoid __init default_get_smp_config(unsigned int early)\n{\n\tstruct mpf_intel *mpf;\n\n\tif (!smp_found_config)\n\t\treturn;\n\n\tif (!mpf_found)\n\t\treturn;\n\n\tif (acpi_lapic && early)\n\t\treturn;\n\n\t \n\tif (acpi_lapic && acpi_ioapic)\n\t\treturn;\n\n\tmpf = early_memremap(mpf_base, sizeof(*mpf));\n\tif (!mpf) {\n\t\tpr_err(\"MPTABLE: error mapping MP table\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"Intel MultiProcessor Specification v1.%d\\n\",\n\t\tmpf->specification);\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86_32)\n\tif (mpf->feature2 & (1 << 7)) {\n\t\tpr_info(\"    IMCR and PIC compatibility mode.\\n\");\n\t\tpic_mode = 1;\n\t} else {\n\t\tpr_info(\"    Virtual Wire compatibility mode.\\n\");\n\t\tpic_mode = 0;\n\t}\n#endif\n\t \n\tif (mpf->feature1) {\n\t\tif (early) {\n\t\t\t \n\t\t\tregister_lapic_address(APIC_DEFAULT_PHYS_BASE);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpr_info(\"Default MP configuration #%d\\n\", mpf->feature1);\n\t\tconstruct_default_ISA_mptable(mpf->feature1);\n\n\t} else if (mpf->physptr) {\n\t\tif (check_physptr(mpf, early))\n\t\t\tgoto out;\n\t} else\n\t\tBUG();\n\n\tif (!early)\n\t\tpr_info(\"Processors: %d\\n\", num_processors);\n\t \nout:\n\tearly_memunmap(mpf, sizeof(*mpf));\n}\n\nstatic void __init smp_reserve_memory(struct mpf_intel *mpf)\n{\n\tmemblock_reserve(mpf->physptr, get_mpc_size(mpf->physptr));\n}\n\nstatic int __init smp_scan_config(unsigned long base, unsigned long length)\n{\n\tunsigned int *bp;\n\tstruct mpf_intel *mpf;\n\tint ret = 0;\n\n\tapic_printk(APIC_VERBOSE, \"Scan for SMP in [mem %#010lx-%#010lx]\\n\",\n\t\t    base, base + length - 1);\n\tBUILD_BUG_ON(sizeof(*mpf) != 16);\n\n\twhile (length > 0) {\n\t\tbp = early_memremap(base, length);\n\t\tmpf = (struct mpf_intel *)bp;\n\t\tif ((*bp == SMP_MAGIC_IDENT) &&\n\t\t    (mpf->length == 1) &&\n\t\t    !mpf_checksum((unsigned char *)bp, 16) &&\n\t\t    ((mpf->specification == 1)\n\t\t     || (mpf->specification == 4))) {\n#ifdef CONFIG_X86_LOCAL_APIC\n\t\t\tsmp_found_config = 1;\n#endif\n\t\t\tmpf_base = base;\n\t\t\tmpf_found = true;\n\n\t\t\tpr_info(\"found SMP MP-table at [mem %#010lx-%#010lx]\\n\",\n\t\t\t\tbase, base + sizeof(*mpf) - 1);\n\n\t\t\tmemblock_reserve(base, sizeof(*mpf));\n\t\t\tif (mpf->physptr)\n\t\t\t\tsmp_reserve_memory(mpf);\n\n\t\t\tret = 1;\n\t\t}\n\t\tearly_memunmap(bp, length);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbase += 16;\n\t\tlength -= 16;\n\t}\n\treturn ret;\n}\n\nvoid __init default_find_smp_config(void)\n{\n\tunsigned int address;\n\n\t \n\tif (smp_scan_config(0x0, 0x400) ||\n\t    smp_scan_config(639 * 0x400, 0x400) ||\n\t    smp_scan_config(0xF0000, 0x10000))\n\t\treturn;\n\t \n\n\taddress = get_bios_ebda();\n\tif (address)\n\t\tsmp_scan_config(address, 0x400);\n}\n\n#ifdef CONFIG_X86_IO_APIC\nstatic u8 __initdata irq_used[MAX_IRQ_SOURCES];\n\nstatic int  __init get_MP_intsrc_index(struct mpc_intsrc *m)\n{\n\tint i;\n\n\tif (m->irqtype != mp_INT)\n\t\treturn 0;\n\n\tif (m->irqflag != (MP_IRQTRIG_LEVEL | MP_IRQPOL_ACTIVE_LOW))\n\t\treturn 0;\n\n\t \n\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tif (mp_irqs[i].irqtype != mp_INT)\n\t\t\tcontinue;\n\n\t\tif (mp_irqs[i].irqflag != (MP_IRQTRIG_LEVEL |\n\t\t\t\t\t   MP_IRQPOL_ACTIVE_LOW))\n\t\t\tcontinue;\n\n\t\tif (mp_irqs[i].srcbus != m->srcbus)\n\t\t\tcontinue;\n\t\tif (mp_irqs[i].srcbusirq != m->srcbusirq)\n\t\t\tcontinue;\n\t\tif (irq_used[i]) {\n\t\t\t \n\t\t\treturn -2;\n\t\t}\n\t\tirq_used[i] = 1;\n\t\treturn i;\n\t}\n\n\t \n\treturn -1;\n}\n\n#define SPARE_SLOT_NUM 20\n\nstatic struct mpc_intsrc __initdata *m_spare[SPARE_SLOT_NUM];\n\nstatic void __init check_irq_src(struct mpc_intsrc *m, int *nr_m_spare)\n{\n\tint i;\n\n\tapic_printk(APIC_VERBOSE, \"OLD \");\n\tprint_mp_irq_info(m);\n\n\ti = get_MP_intsrc_index(m);\n\tif (i > 0) {\n\t\tmemcpy(m, &mp_irqs[i], sizeof(*m));\n\t\tapic_printk(APIC_VERBOSE, \"NEW \");\n\t\tprint_mp_irq_info(&mp_irqs[i]);\n\t\treturn;\n\t}\n\tif (!i) {\n\t\t \n\t\treturn;\n\t}\n\tif (*nr_m_spare < SPARE_SLOT_NUM) {\n\t\t \n\t\tm_spare[*nr_m_spare] = m;\n\t\t*nr_m_spare += 1;\n\t}\n}\n\nstatic int __init\ncheck_slot(unsigned long mpc_new_phys, unsigned long mpc_new_length, int count)\n{\n\tif (!mpc_new_phys || count <= mpc_new_length) {\n\t\tWARN(1, \"update_mptable: No spare slots (length: %x)\\n\", count);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n#else  \nstatic\ninline void __init check_irq_src(struct mpc_intsrc *m, int *nr_m_spare) {}\n#endif  \n\nstatic int  __init replace_intsrc_all(struct mpc_table *mpc,\n\t\t\t\t\tunsigned long mpc_new_phys,\n\t\t\t\t\tunsigned long mpc_new_length)\n{\n#ifdef CONFIG_X86_IO_APIC\n\tint i;\n#endif\n\tint count = sizeof(*mpc);\n\tint nr_m_spare = 0;\n\tunsigned char *mpt = ((unsigned char *)mpc) + count;\n\n\tpr_info(\"mpc_length %x\\n\", mpc->length);\n\twhile (count < mpc->length) {\n\t\tswitch (*mpt) {\n\t\tcase MP_PROCESSOR:\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_cpu));\n\t\t\tbreak;\n\t\tcase MP_BUS:\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_bus));\n\t\t\tbreak;\n\t\tcase MP_IOAPIC:\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_ioapic));\n\t\t\tbreak;\n\t\tcase MP_INTSRC:\n\t\t\tcheck_irq_src((struct mpc_intsrc *)mpt, &nr_m_spare);\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_intsrc));\n\t\t\tbreak;\n\t\tcase MP_LINTSRC:\n\t\t\tskip_entry(&mpt, &count, sizeof(struct mpc_lintsrc));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsmp_dump_mptable(mpc, mpt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n#ifdef CONFIG_X86_IO_APIC\n\tfor (i = 0; i < mp_irq_entries; i++) {\n\t\tif (irq_used[i])\n\t\t\tcontinue;\n\n\t\tif (mp_irqs[i].irqtype != mp_INT)\n\t\t\tcontinue;\n\n\t\tif (mp_irqs[i].irqflag != (MP_IRQTRIG_LEVEL |\n\t\t\t\t\t   MP_IRQPOL_ACTIVE_LOW))\n\t\t\tcontinue;\n\n\t\tif (nr_m_spare > 0) {\n\t\t\tapic_printk(APIC_VERBOSE, \"*NEW* found\\n\");\n\t\t\tnr_m_spare--;\n\t\t\tmemcpy(m_spare[nr_m_spare], &mp_irqs[i], sizeof(mp_irqs[i]));\n\t\t\tm_spare[nr_m_spare] = NULL;\n\t\t} else {\n\t\t\tstruct mpc_intsrc *m = (struct mpc_intsrc *)mpt;\n\t\t\tcount += sizeof(struct mpc_intsrc);\n\t\t\tif (check_slot(mpc_new_phys, mpc_new_length, count) < 0)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(m, &mp_irqs[i], sizeof(*m));\n\t\t\tmpc->length = count;\n\t\t\tmpt += sizeof(struct mpc_intsrc);\n\t\t}\n\t\tprint_mp_irq_info(&mp_irqs[i]);\n\t}\n#endif\nout:\n\t \n\tmpc->checksum = 0;\n\tmpc->checksum -= mpf_checksum((unsigned char *)mpc, mpc->length);\n\n\treturn 0;\n}\n\nint enable_update_mptable;\n\nstatic int __init update_mptable_setup(char *str)\n{\n\tenable_update_mptable = 1;\n#ifdef CONFIG_PCI\n\tpci_routeirq = 1;\n#endif\n\treturn 0;\n}\nearly_param(\"update_mptable\", update_mptable_setup);\n\nstatic unsigned long __initdata mpc_new_phys;\nstatic unsigned long mpc_new_length __initdata = 4096;\n\n \nstatic int __initdata alloc_mptable;\nstatic int __init parse_alloc_mptable_opt(char *p)\n{\n\tenable_update_mptable = 1;\n#ifdef CONFIG_PCI\n\tpci_routeirq = 1;\n#endif\n\talloc_mptable = 1;\n\tif (!p)\n\t\treturn 0;\n\tmpc_new_length = memparse(p, &p);\n\treturn 0;\n}\nearly_param(\"alloc_mptable\", parse_alloc_mptable_opt);\n\nvoid __init e820__memblock_alloc_reserved_mpc_new(void)\n{\n\tif (enable_update_mptable && alloc_mptable)\n\t\tmpc_new_phys = e820__memblock_alloc_reserved(mpc_new_length, 4);\n}\n\nstatic int __init update_mp_table(void)\n{\n\tchar str[16];\n\tchar oem[10];\n\tstruct mpf_intel *mpf;\n\tstruct mpc_table *mpc, *mpc_new;\n\tunsigned long size;\n\n\tif (!enable_update_mptable)\n\t\treturn 0;\n\n\tif (!mpf_found)\n\t\treturn 0;\n\n\tmpf = early_memremap(mpf_base, sizeof(*mpf));\n\tif (!mpf) {\n\t\tpr_err(\"MPTABLE: mpf early_memremap() failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (mpf->feature1)\n\t\tgoto do_unmap_mpf;\n\n\tif (!mpf->physptr)\n\t\tgoto do_unmap_mpf;\n\n\tsize = get_mpc_size(mpf->physptr);\n\tmpc = early_memremap(mpf->physptr, size);\n\tif (!mpc) {\n\t\tpr_err(\"MPTABLE: mpc early_memremap() failed\\n\");\n\t\tgoto do_unmap_mpf;\n\t}\n\n\tif (!smp_check_mpc(mpc, oem, str))\n\t\tgoto do_unmap_mpc;\n\n\tpr_info(\"mpf: %llx\\n\", (u64)mpf_base);\n\tpr_info(\"physptr: %x\\n\", mpf->physptr);\n\n\tif (mpc_new_phys && mpc->length > mpc_new_length) {\n\t\tmpc_new_phys = 0;\n\t\tpr_info(\"mpc_new_length is %ld, please use alloc_mptable=8k\\n\",\n\t\t\tmpc_new_length);\n\t}\n\n\tif (!mpc_new_phys) {\n\t\tunsigned char old, new;\n\t\t \n\t\tmpc->checksum = 0;\n\t\told = mpf_checksum((unsigned char *)mpc, mpc->length);\n\t\tmpc->checksum = 0xff;\n\t\tnew = mpf_checksum((unsigned char *)mpc, mpc->length);\n\t\tif (old == new) {\n\t\t\tpr_info(\"mpc is readonly, please try alloc_mptable instead\\n\");\n\t\t\tgoto do_unmap_mpc;\n\t\t}\n\t\tpr_info(\"use in-position replacing\\n\");\n\t} else {\n\t\tmpc_new = early_memremap(mpc_new_phys, mpc_new_length);\n\t\tif (!mpc_new) {\n\t\t\tpr_err(\"MPTABLE: new mpc early_memremap() failed\\n\");\n\t\t\tgoto do_unmap_mpc;\n\t\t}\n\t\tmpf->physptr = mpc_new_phys;\n\t\tmemcpy(mpc_new, mpc, mpc->length);\n\t\tearly_memunmap(mpc, size);\n\t\tmpc = mpc_new;\n\t\tsize = mpc_new_length;\n\t\t \n\t\tif (mpc_new_phys - mpf->physptr) {\n\t\t\tstruct mpf_intel *mpf_new;\n\t\t\t \n\t\t\tmpf_new = early_memremap(0x400 - 16, sizeof(*mpf_new));\n\t\t\tif (!mpf_new) {\n\t\t\t\tpr_err(\"MPTABLE: new mpf early_memremap() failed\\n\");\n\t\t\t\tgoto do_unmap_mpc;\n\t\t\t}\n\t\t\tpr_info(\"mpf new: %x\\n\", 0x400 - 16);\n\t\t\tmemcpy(mpf_new, mpf, 16);\n\t\t\tearly_memunmap(mpf, sizeof(*mpf));\n\t\t\tmpf = mpf_new;\n\t\t\tmpf->physptr = mpc_new_phys;\n\t\t}\n\t\tmpf->checksum = 0;\n\t\tmpf->checksum -= mpf_checksum((unsigned char *)mpf, 16);\n\t\tpr_info(\"physptr new: %x\\n\", mpf->physptr);\n\t}\n\n\t \n\treplace_intsrc_all(mpc, mpc_new_phys, mpc_new_length);\n\ndo_unmap_mpc:\n\tearly_memunmap(mpc, size);\n\ndo_unmap_mpf:\n\tearly_memunmap(mpf, sizeof(*mpf));\n\n\treturn 0;\n}\n\nlate_initcall(update_mp_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}