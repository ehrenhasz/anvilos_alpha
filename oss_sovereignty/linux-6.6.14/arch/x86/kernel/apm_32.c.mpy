{
  "module_name": "apm_32.c",
  "hash_id": "de4a53717eabddebabe36ff867c2f5297db07dd448820f766eed4db1ef145072",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/apm_32.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"apm: \" fmt\n\n#include <linux/module.h>\n\n#include <linux/poll.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/timer.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/miscdevice.h>\n#include <linux/apm_bios.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/cputime.h>\n#include <linux/pm.h>\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/freezer.h>\n#include <linux/smp.h>\n#include <linux/dmi.h>\n#include <linux/suspend.h>\n#include <linux/kthread.h>\n#include <linux/jiffies.h>\n#include <linux/acpi.h>\n#include <linux/syscore_ops.h>\n#include <linux/i8253.h>\n#include <linux/cpuidle.h>\n\n#include <linux/uaccess.h>\n#include <asm/desc.h>\n#include <asm/olpc.h>\n#include <asm/paravirt.h>\n#include <asm/reboot.h>\n#include <asm/nospec-branch.h>\n#include <asm/ibt.h>\n\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\nextern int (*console_blank_hook)(int);\n#endif\n\n \n\n \n\n \n#define ALWAYS_CALL_BUSY   1\n\n \n#define APM_ZERO_SEGS\n\n#include <asm/apm.h>\n\n \n#undef INIT_TIMER_AFTER_SUSPEND\n\n#ifdef INIT_TIMER_AFTER_SUSPEND\n#include <linux/timex.h>\n#include <asm/io.h>\n#include <linux/delay.h>\n#endif\n\n \n#define APM_CHECK_TIMEOUT\t(HZ)\n\n \n#define DEFAULT_BOUNCE_INTERVAL\t(3 * HZ)\n\n \n#define APM_MAX_EVENTS\t\t20\n\n \nstruct apm_user {\n\tint\t\tmagic;\n\tstruct apm_user *next;\n\tunsigned int\tsuser: 1;\n\tunsigned int\twriter: 1;\n\tunsigned int\treader: 1;\n\tunsigned int\tsuspend_wait: 1;\n\tint\t\tsuspend_result;\n\tint\t\tsuspends_pending;\n\tint\t\tstandbys_pending;\n\tint\t\tsuspends_read;\n\tint\t\tstandbys_read;\n\tint\t\tevent_head;\n\tint\t\tevent_tail;\n\tapm_event_t\tevents[APM_MAX_EVENTS];\n};\n\n \n#define APM_BIOS_MAGIC\t\t0x4101\n\n \n#ifdef CONFIG_APM_CPU_IDLE\n#define DEFAULT_IDLE_THRESHOLD\t95\n#else\n#define DEFAULT_IDLE_THRESHOLD\t100\n#endif\n#define DEFAULT_IDLE_PERIOD\t(100 / 3)\n\nstatic int apm_cpu_idle(struct cpuidle_device *dev,\n\t\t\tstruct cpuidle_driver *drv, int index);\n\nstatic struct cpuidle_driver apm_idle_driver = {\n\t.name = \"apm_idle\",\n\t.owner = THIS_MODULE,\n\t.states = {\n\t\t{   },\n\t\t{  \n\t\t\t.name = \"APM\",\n\t\t\t.desc = \"APM idle\",\n\t\t\t.exit_latency = 250,\t \n\t\t\t.target_residency = 500,\t \n\t\t\t.enter = &apm_cpu_idle\n\t\t},\n\t},\n\t.state_count = 2,\n};\n\nstatic struct cpuidle_device apm_cpuidle_device;\n\n \n__visible struct {\n\tunsigned long\toffset;\n\tunsigned short\tsegment;\n} apm_bios_entry;\nstatic int clock_slowed;\nstatic int idle_threshold __read_mostly = DEFAULT_IDLE_THRESHOLD;\nstatic int idle_period __read_mostly = DEFAULT_IDLE_PERIOD;\nstatic int suspends_pending;\nstatic int standbys_pending;\nstatic int ignore_sys_suspend;\nstatic int ignore_normal_resume;\nstatic int bounce_interval __read_mostly = DEFAULT_BOUNCE_INTERVAL;\n\nstatic bool debug __read_mostly;\nstatic bool smp __read_mostly;\nstatic int apm_disabled = -1;\n#ifdef CONFIG_SMP\nstatic bool power_off;\n#else\nstatic bool power_off = 1;\n#endif\nstatic bool realmode_power_off;\n#ifdef CONFIG_APM_ALLOW_INTS\nstatic bool allow_ints = 1;\n#else\nstatic bool allow_ints;\n#endif\nstatic bool broken_psr;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(apm_waitqueue);\nstatic DECLARE_WAIT_QUEUE_HEAD(apm_suspend_waitqueue);\nstatic struct apm_user *user_list;\nstatic DEFINE_SPINLOCK(user_list_lock);\nstatic DEFINE_MUTEX(apm_mutex);\n\n \nstatic struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4092,\n\t\t\t(unsigned long)__va(0x400UL), PAGE_SIZE - 0x400 - 1);\n\nstatic const char driver_version[] = \"1.16ac\";\t \n\nstatic struct task_struct *kapmd_task;\n\n \nstatic const char * const apm_event_name[] = {\n\t\"system standby\",\n\t\"system suspend\",\n\t\"normal resume\",\n\t\"critical resume\",\n\t\"low battery\",\n\t\"power status change\",\n\t\"update time\",\n\t\"critical suspend\",\n\t\"user standby\",\n\t\"user suspend\",\n\t\"system standby resume\",\n\t\"capabilities change\"\n};\n#define NR_APM_EVENT_NAME ARRAY_SIZE(apm_event_name)\n\ntypedef struct lookup_t {\n\tint\tkey;\n\tchar \t*msg;\n} lookup_t;\n\n \n\nstatic const lookup_t error_table[] = {\n \n\t{ APM_DISABLED,\t\t\"Power management disabled\" },\n\t{ APM_CONNECTED,\t\"Real mode interface already connected\" },\n\t{ APM_NOT_CONNECTED,\t\"Interface not connected\" },\n\t{ APM_16_CONNECTED,\t\"16 bit interface already connected\" },\n \n\t{ APM_32_CONNECTED,\t\"32 bit interface already connected\" },\n\t{ APM_32_UNSUPPORTED,\t\"32 bit interface not supported\" },\n\t{ APM_BAD_DEVICE,\t\"Unrecognized device ID\" },\n\t{ APM_BAD_PARAM,\t\"Parameter out of range\" },\n\t{ APM_NOT_ENGAGED,\t\"Interface not engaged\" },\n\t{ APM_BAD_FUNCTION,     \"Function not supported\" },\n\t{ APM_RESUME_DISABLED,\t\"Resume timer disabled\" },\n\t{ APM_BAD_STATE,\t\"Unable to enter requested state\" },\n \n\t{ APM_NO_ERROR,\t\t\"BIOS did not set a return code\" },\n\t{ APM_NOT_PRESENT,\t\"No APM present\" }\n};\n#define ERROR_COUNT\tARRAY_SIZE(error_table)\n\n \n\nstatic void apm_error(char *str, int err)\n{\n\tint i;\n\n\tfor (i = 0; i < ERROR_COUNT; i++)\n\t\tif (error_table[i].key == err)\n\t\t\tbreak;\n\tif (i < ERROR_COUNT)\n\t\tpr_notice(\"%s: %s\\n\", str, error_table[i].msg);\n\telse if (err < 0)\n\t\tpr_notice(\"%s: linux error code %i\\n\", str, err);\n\telse\n\t\tpr_notice(\"%s: unknown error code %#2.2x\\n\",\n\t\t       str, err);\n}\n\n \n\nstatic inline unsigned long __apm_irq_save(void)\n{\n\tunsigned long flags;\n\tlocal_save_flags(flags);\n\tif (apm_info.allow_ints) {\n\t\tif (irqs_disabled_flags(flags))\n\t\t\tlocal_irq_enable();\n\t} else\n\t\tlocal_irq_disable();\n\n\treturn flags;\n}\n\n#define apm_irq_save(flags) \\\n\tdo { flags = __apm_irq_save(); } while (0)\n\nstatic inline void apm_irq_restore(unsigned long flags)\n{\n\tif (irqs_disabled_flags(flags))\n\t\tlocal_irq_disable();\n\telse if (irqs_disabled())\n\t\tlocal_irq_enable();\n}\n\n#ifdef APM_ZERO_SEGS\n#\tdefine APM_DECL_SEGS \\\n\t\tunsigned int saved_fs; unsigned int saved_gs;\n#\tdefine APM_DO_SAVE_SEGS \\\n\t\tsavesegment(fs, saved_fs); savesegment(gs, saved_gs)\n#\tdefine APM_DO_RESTORE_SEGS \\\n\t\tloadsegment(fs, saved_fs); loadsegment(gs, saved_gs)\n#else\n#\tdefine APM_DECL_SEGS\n#\tdefine APM_DO_SAVE_SEGS\n#\tdefine APM_DO_RESTORE_SEGS\n#endif\n\nstruct apm_bios_call {\n\tu32 func;\n\t \n\tu32 ebx;\n\tu32 ecx;\n\t \n\tu32 eax;\n\tu32 edx;\n\tu32 esi;\n\n\t \n\tint err;\n};\n\n \nstatic long __apm_bios_call(void *_call)\n{\n\tAPM_DECL_SEGS\n\tunsigned long\t\tflags;\n\tint\t\t\tcpu;\n\tstruct desc_struct\tsave_desc_40;\n\tstruct desc_struct\t*gdt;\n\tstruct apm_bios_call\t*call = _call;\n\tu64\t\t\tibt;\n\n\tcpu = get_cpu();\n\tBUG_ON(cpu != 0);\n\tgdt = get_cpu_gdt_rw(cpu);\n\tsave_desc_40 = gdt[0x40 / 8];\n\tgdt[0x40 / 8] = bad_bios_desc;\n\n\tapm_irq_save(flags);\n\tfirmware_restrict_branch_speculation_start();\n\tibt = ibt_save(true);\n\tAPM_DO_SAVE_SEGS;\n\tapm_bios_call_asm(call->func, call->ebx, call->ecx,\n\t\t\t  &call->eax, &call->ebx, &call->ecx, &call->edx,\n\t\t\t  &call->esi);\n\tAPM_DO_RESTORE_SEGS;\n\tibt_restore(ibt);\n\tfirmware_restrict_branch_speculation_end();\n\tapm_irq_restore(flags);\n\tgdt[0x40 / 8] = save_desc_40;\n\tput_cpu();\n\n\treturn call->eax & 0xff;\n}\n\n \nstatic int on_cpu0(long (*fn)(void *), struct apm_bios_call *call)\n{\n\tint ret;\n\n\t \n\tif (get_cpu() == 0) {\n\t\tret = fn(call);\n\t\tput_cpu();\n\t} else {\n\t\tput_cpu();\n\t\tret = work_on_cpu(0, fn, call);\n\t}\n\n\t \n\tif (ret < 0)\n\t\tcall->err = ret;\n\telse\n\t\tcall->err = (call->eax >> 8) & 0xff;\n\n\treturn ret;\n}\n\n \nstatic int apm_bios_call(struct apm_bios_call *call)\n{\n\treturn on_cpu0(__apm_bios_call, call);\n}\n\n \nstatic long __apm_bios_call_simple(void *_call)\n{\n\tu8\t\t\terror;\n\tAPM_DECL_SEGS\n\tunsigned long\t\tflags;\n\tint\t\t\tcpu;\n\tstruct desc_struct\tsave_desc_40;\n\tstruct desc_struct\t*gdt;\n\tstruct apm_bios_call\t*call = _call;\n\tu64\t\t\tibt;\n\n\tcpu = get_cpu();\n\tBUG_ON(cpu != 0);\n\tgdt = get_cpu_gdt_rw(cpu);\n\tsave_desc_40 = gdt[0x40 / 8];\n\tgdt[0x40 / 8] = bad_bios_desc;\n\n\tapm_irq_save(flags);\n\tfirmware_restrict_branch_speculation_start();\n\tibt = ibt_save(true);\n\tAPM_DO_SAVE_SEGS;\n\terror = apm_bios_call_simple_asm(call->func, call->ebx, call->ecx,\n\t\t\t\t\t &call->eax);\n\tAPM_DO_RESTORE_SEGS;\n\tibt_restore(ibt);\n\tfirmware_restrict_branch_speculation_end();\n\tapm_irq_restore(flags);\n\tgdt[0x40 / 8] = save_desc_40;\n\tput_cpu();\n\treturn error;\n}\n\n \nstatic int apm_bios_call_simple(u32 func, u32 ebx_in, u32 ecx_in, u32 *eax,\n\t\t\t\tint *err)\n{\n\tstruct apm_bios_call call;\n\tint ret;\n\n\tcall.func = func;\n\tcall.ebx = ebx_in;\n\tcall.ecx = ecx_in;\n\n\tret = on_cpu0(__apm_bios_call_simple, &call);\n\t*eax = call.eax;\n\t*err = call.err;\n\treturn ret;\n}\n\n \n\nstatic int apm_driver_version(u_short *val)\n{\n\tu32 eax;\n\tint err;\n\n\tif (apm_bios_call_simple(APM_FUNC_VERSION, 0, *val, &eax, &err))\n\t\treturn err;\n\t*val = eax;\n\treturn APM_SUCCESS;\n}\n\n \nstatic int apm_get_event(apm_event_t *event, apm_eventinfo_t *info)\n{\n\tstruct apm_bios_call call;\n\n\tcall.func = APM_FUNC_GET_EVENT;\n\tcall.ebx = call.ecx = 0;\n\n\tif (apm_bios_call(&call))\n\t\treturn call.err;\n\n\t*event = call.ebx;\n\tif (apm_info.connection_version < 0x0102)\n\t\t*info = ~0;  \n\telse\n\t\t*info = call.ecx;\n\treturn APM_SUCCESS;\n}\n\n \n\nstatic int set_power_state(u_short what, u_short state)\n{\n\tu32 eax;\n\tint err;\n\n\tif (apm_bios_call_simple(APM_FUNC_SET_STATE, what, state, &eax, &err))\n\t\treturn err;\n\treturn APM_SUCCESS;\n}\n\n \n\nstatic int set_system_power_state(u_short state)\n{\n\treturn set_power_state(APM_DEVICE_ALL, state);\n}\n\n \n\nstatic int apm_do_idle(void)\n{\n\tu32 eax;\n\tu8 ret = 0;\n\tint idled = 0;\n\tint err = 0;\n\n\tif (!need_resched()) {\n\t\tidled = 1;\n\t\tret = apm_bios_call_simple(APM_FUNC_IDLE, 0, 0, &eax, &err);\n\t}\n\n\tif (!idled)\n\t\treturn 0;\n\n\tif (ret) {\n\t\tstatic unsigned long t;\n\n\t\t \n\t\tif (++t < 5) {\n\t\t\tprintk(KERN_DEBUG \"apm_do_idle failed (%d)\\n\", err);\n\t\t\tt = jiffies;\n\t\t}\n\t\treturn -1;\n\t}\n\tclock_slowed = (apm_info.bios.flags & APM_IDLE_SLOWS_CLOCK) != 0;\n\treturn clock_slowed;\n}\n\n \n\nstatic void apm_do_busy(void)\n{\n\tu32 dummy;\n\tint err;\n\n\tif (clock_slowed || ALWAYS_CALL_BUSY) {\n\t\t(void)apm_bios_call_simple(APM_FUNC_BUSY, 0, 0, &dummy, &err);\n\t\tclock_slowed = 0;\n\t}\n}\n\n \n#define IDLE_CALC_LIMIT\t(HZ * 100)\n#define IDLE_LEAKY_MAX\t16\n\n \n\nstatic int apm_cpu_idle(struct cpuidle_device *dev,\n\tstruct cpuidle_driver *drv, int index)\n{\n\tstatic int use_apm_idle;  \n\tstatic unsigned int last_jiffies;  \n\tstatic u64 last_stime;  \n\tu64 stime, utime;\n\n\tint apm_idle_done = 0;\n\tunsigned int jiffies_since_last_check = jiffies - last_jiffies;\n\tunsigned int bucket;\n\nrecalc:\n\ttask_cputime(current, &utime, &stime);\n\tif (jiffies_since_last_check > IDLE_CALC_LIMIT) {\n\t\tuse_apm_idle = 0;\n\t} else if (jiffies_since_last_check > idle_period) {\n\t\tunsigned int idle_percentage;\n\n\t\tidle_percentage = nsecs_to_jiffies(stime - last_stime);\n\t\tidle_percentage *= 100;\n\t\tidle_percentage /= jiffies_since_last_check;\n\t\tuse_apm_idle = (idle_percentage > idle_threshold);\n\t\tif (apm_info.forbid_idle)\n\t\t\tuse_apm_idle = 0;\n\t}\n\n\tlast_jiffies = jiffies;\n\tlast_stime = stime;\n\n\tbucket = IDLE_LEAKY_MAX;\n\n\twhile (!need_resched()) {\n\t\tif (use_apm_idle) {\n\t\t\tunsigned int t;\n\n\t\t\tt = jiffies;\n\t\t\tswitch (apm_do_idle()) {\n\t\t\tcase 0:\n\t\t\t\tapm_idle_done = 1;\n\t\t\t\tif (t != jiffies) {\n\t\t\t\t\tif (bucket) {\n\t\t\t\t\t\tbucket = IDLE_LEAKY_MAX;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (bucket) {\n\t\t\t\t\tbucket--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tapm_idle_done = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdefault_idle();\n\t\tlocal_irq_disable();\n\t\tjiffies_since_last_check = jiffies - last_jiffies;\n\t\tif (jiffies_since_last_check > idle_period)\n\t\t\tgoto recalc;\n\t}\n\n\tif (apm_idle_done)\n\t\tapm_do_busy();\n\n\treturn index;\n}\n\n \n\nstatic void apm_power_off(void)\n{\n\t \n\tif (apm_info.realmode_power_off) {\n\t\tset_cpus_allowed_ptr(current, cpumask_of(0));\n\t\tmachine_real_restart(MRR_APM);\n\t} else {\n\t\t(void)set_system_power_state(APM_STATE_OFF);\n\t}\n}\n\n#ifdef CONFIG_APM_DO_ENABLE\n\n \n\nstatic int apm_enable_power_management(int enable)\n{\n\tu32 eax;\n\tint err;\n\n\tif ((enable == 0) && (apm_info.bios.flags & APM_BIOS_DISENGAGED))\n\t\treturn APM_NOT_ENGAGED;\n\tif (apm_bios_call_simple(APM_FUNC_ENABLE_PM, APM_DEVICE_BALL,\n\t\t\t\t enable, &eax, &err))\n\t\treturn err;\n\tif (enable)\n\t\tapm_info.bios.flags &= ~APM_BIOS_DISABLED;\n\telse\n\t\tapm_info.bios.flags |= APM_BIOS_DISABLED;\n\treturn APM_SUCCESS;\n}\n#endif\n\n \n\nstatic int apm_get_power_status(u_short *status, u_short *bat, u_short *life)\n{\n\tstruct apm_bios_call call;\n\n\tcall.func = APM_FUNC_GET_STATUS;\n\tcall.ebx = APM_DEVICE_ALL;\n\tcall.ecx = 0;\n\n\tif (apm_info.get_power_status_broken)\n\t\treturn APM_32_UNSUPPORTED;\n\tif (apm_bios_call(&call)) {\n\t\tif (!call.err)\n\t\t\treturn APM_NO_ERROR;\n\t\treturn call.err;\n\t}\n\t*status = call.ebx;\n\t*bat = call.ecx;\n\tif (apm_info.get_power_status_swabinminutes) {\n\t\t*life = swab16((u16)call.edx);\n\t\t*life |= 0x8000;\n\t} else\n\t\t*life = call.edx;\n\treturn APM_SUCCESS;\n}\n\n#if 0\nstatic int apm_get_battery_status(u_short which, u_short *status,\n\t\t\t\t  u_short *bat, u_short *life, u_short *nbat)\n{\n\tu32 eax;\n\tu32 ebx;\n\tu32 ecx;\n\tu32 edx;\n\tu32 esi;\n\n\tif (apm_info.connection_version < 0x0102) {\n\t\t \n\t\tif (which != 1)\n\t\t\treturn APM_BAD_DEVICE;\n\t\t*nbat = 1;\n\t\treturn apm_get_power_status(status, bat, life);\n\t}\n\n\tif (apm_bios_call(APM_FUNC_GET_STATUS, (0x8000 | (which)), 0, &eax,\n\t\t\t  &ebx, &ecx, &edx, &esi))\n\t\treturn (eax >> 8) & 0xff;\n\t*status = ebx;\n\t*bat = ecx;\n\t*life = edx;\n\t*nbat = esi;\n\treturn APM_SUCCESS;\n}\n#endif\n\n \n\nstatic int apm_engage_power_management(u_short device, int enable)\n{\n\tu32 eax;\n\tint err;\n\n\tif ((enable == 0) && (device == APM_DEVICE_ALL)\n\t    && (apm_info.bios.flags & APM_BIOS_DISABLED))\n\t\treturn APM_DISABLED;\n\tif (apm_bios_call_simple(APM_FUNC_ENGAGE_PM, device, enable,\n\t\t\t\t &eax, &err))\n\t\treturn err;\n\tif (device == APM_DEVICE_ALL) {\n\t\tif (enable)\n\t\t\tapm_info.bios.flags &= ~APM_BIOS_DISENGAGED;\n\t\telse\n\t\t\tapm_info.bios.flags |= APM_BIOS_DISENGAGED;\n\t}\n\treturn APM_SUCCESS;\n}\n\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\n\n \n\nstatic int apm_console_blank(int blank)\n{\n\tint error = APM_NOT_ENGAGED;  \n\tint i;\n\tu_short state;\n\tstatic const u_short dev[3] = { 0x100, 0x1FF, 0x101 };\n\n\tstate = blank ? APM_STATE_STANDBY : APM_STATE_READY;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev); i++) {\n\t\terror = set_power_state(dev[i], state);\n\n\t\tif ((error == APM_SUCCESS) || (error == APM_NO_ERROR))\n\t\t\treturn 1;\n\n\t\tif (error == APM_NOT_ENGAGED)\n\t\t\tbreak;\n\t}\n\n\tif (error == APM_NOT_ENGAGED) {\n\t\tstatic int tried;\n\t\tint eng_error;\n\t\tif (tried++ == 0) {\n\t\t\teng_error = apm_engage_power_management(APM_DEVICE_ALL, 1);\n\t\t\tif (eng_error) {\n\t\t\t\tapm_error(\"set display\", error);\n\t\t\t\tapm_error(\"engage interface\", eng_error);\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn apm_console_blank(blank);\n\t\t}\n\t}\n\tapm_error(\"set display\", error);\n\treturn 0;\n}\n#endif\n\nstatic int queue_empty(struct apm_user *as)\n{\n\treturn as->event_head == as->event_tail;\n}\n\nstatic apm_event_t get_queued_event(struct apm_user *as)\n{\n\tif (++as->event_tail >= APM_MAX_EVENTS)\n\t\tas->event_tail = 0;\n\treturn as->events[as->event_tail];\n}\n\nstatic void queue_event(apm_event_t event, struct apm_user *sender)\n{\n\tstruct apm_user *as;\n\n\tspin_lock(&user_list_lock);\n\tif (user_list == NULL)\n\t\tgoto out;\n\tfor (as = user_list; as != NULL; as = as->next) {\n\t\tif ((as == sender) || (!as->reader))\n\t\t\tcontinue;\n\t\tif (++as->event_head >= APM_MAX_EVENTS)\n\t\t\tas->event_head = 0;\n\n\t\tif (as->event_head == as->event_tail) {\n\t\t\tstatic int notified;\n\n\t\t\tif (notified++ == 0)\n\t\t\t\tpr_err(\"an event queue overflowed\\n\");\n\t\t\tif (++as->event_tail >= APM_MAX_EVENTS)\n\t\t\t\tas->event_tail = 0;\n\t\t}\n\t\tas->events[as->event_head] = event;\n\t\tif (!as->suser || !as->writer)\n\t\t\tcontinue;\n\t\tswitch (event) {\n\t\tcase APM_SYS_SUSPEND:\n\t\tcase APM_USER_SUSPEND:\n\t\t\tas->suspends_pending++;\n\t\t\tsuspends_pending++;\n\t\t\tbreak;\n\n\t\tcase APM_SYS_STANDBY:\n\t\tcase APM_USER_STANDBY:\n\t\t\tas->standbys_pending++;\n\t\t\tstandbys_pending++;\n\t\t\tbreak;\n\t\t}\n\t}\n\twake_up_interruptible(&apm_waitqueue);\nout:\n\tspin_unlock(&user_list_lock);\n}\n\nstatic void reinit_timer(void)\n{\n#ifdef INIT_TIMER_AFTER_SUSPEND\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&i8253_lock, flags);\n\t \n\toutb_p(0x34, PIT_MODE);\t\t \n\tudelay(10);\n\toutb_p(LATCH & 0xff, PIT_CH0);\t \n\tudelay(10);\n\toutb_p(LATCH >> 8, PIT_CH0);\t \n\tudelay(10);\n\traw_spin_unlock_irqrestore(&i8253_lock, flags);\n#endif\n}\n\nstatic int suspend(int vetoable)\n{\n\tint err;\n\tstruct apm_user\t*as;\n\n\tdpm_suspend_start(PMSG_SUSPEND);\n\tdpm_suspend_end(PMSG_SUSPEND);\n\n\tlocal_irq_disable();\n\tsyscore_suspend();\n\n\tlocal_irq_enable();\n\n\tsave_processor_state();\n\terr = set_system_power_state(APM_STATE_SUSPEND);\n\tignore_normal_resume = 1;\n\trestore_processor_state();\n\n\tlocal_irq_disable();\n\treinit_timer();\n\n\tif (err == APM_NO_ERROR)\n\t\terr = APM_SUCCESS;\n\tif (err != APM_SUCCESS)\n\t\tapm_error(\"suspend\", err);\n\terr = (err == APM_SUCCESS) ? 0 : -EIO;\n\n\tsyscore_resume();\n\tlocal_irq_enable();\n\n\tdpm_resume_start(PMSG_RESUME);\n\tdpm_resume_end(PMSG_RESUME);\n\n\tqueue_event(APM_NORMAL_RESUME, NULL);\n\tspin_lock(&user_list_lock);\n\tfor (as = user_list; as != NULL; as = as->next) {\n\t\tas->suspend_wait = 0;\n\t\tas->suspend_result = err;\n\t}\n\tspin_unlock(&user_list_lock);\n\twake_up_interruptible(&apm_suspend_waitqueue);\n\treturn err;\n}\n\nstatic void standby(void)\n{\n\tint err;\n\n\tdpm_suspend_end(PMSG_SUSPEND);\n\n\tlocal_irq_disable();\n\tsyscore_suspend();\n\tlocal_irq_enable();\n\n\terr = set_system_power_state(APM_STATE_STANDBY);\n\tif ((err != APM_SUCCESS) && (err != APM_NO_ERROR))\n\t\tapm_error(\"standby\", err);\n\n\tlocal_irq_disable();\n\tsyscore_resume();\n\tlocal_irq_enable();\n\n\tdpm_resume_start(PMSG_RESUME);\n}\n\nstatic apm_event_t get_event(void)\n{\n\tint error;\n\tapm_event_t event = APM_NO_EVENTS;  \n\tapm_eventinfo_t\tinfo;\n\n\tstatic int notified;\n\n\t \n\terror = apm_get_event(&event, &info);\n\tif (error == APM_SUCCESS)\n\t\treturn event;\n\n\tif ((error != APM_NO_EVENTS) && (notified++ == 0))\n\t\tapm_error(\"get_event\", error);\n\n\treturn 0;\n}\n\nstatic void check_events(void)\n{\n\tapm_event_t event;\n\tstatic unsigned long last_resume;\n\tstatic int ignore_bounce;\n\n\twhile ((event = get_event()) != 0) {\n\t\tif (debug) {\n\t\t\tif (event <= NR_APM_EVENT_NAME)\n\t\t\t\tprintk(KERN_DEBUG \"apm: received %s notify\\n\",\n\t\t\t\t       apm_event_name[event - 1]);\n\t\t\telse\n\t\t\t\tprintk(KERN_DEBUG \"apm: received unknown \"\n\t\t\t\t       \"event 0x%02x\\n\", event);\n\t\t}\n\t\tif (ignore_bounce\n\t\t    && (time_after(jiffies, last_resume + bounce_interval)))\n\t\t\tignore_bounce = 0;\n\n\t\tswitch (event) {\n\t\tcase APM_SYS_STANDBY:\n\t\tcase APM_USER_STANDBY:\n\t\t\tqueue_event(event, NULL);\n\t\t\tif (standbys_pending <= 0)\n\t\t\t\tstandby();\n\t\t\tbreak;\n\n\t\tcase APM_USER_SUSPEND:\n#ifdef CONFIG_APM_IGNORE_USER_SUSPEND\n\t\t\tif (apm_info.connection_version > 0x100)\n\t\t\t\tset_system_power_state(APM_STATE_REJECT);\n\t\t\tbreak;\n#endif\n\t\tcase APM_SYS_SUSPEND:\n\t\t\tif (ignore_bounce) {\n\t\t\t\tif (apm_info.connection_version > 0x100)\n\t\t\t\t\tset_system_power_state(APM_STATE_REJECT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (ignore_sys_suspend)\n\t\t\t\treturn;\n\t\t\tignore_sys_suspend = 1;\n\t\t\tqueue_event(event, NULL);\n\t\t\tif (suspends_pending <= 0)\n\t\t\t\t(void) suspend(1);\n\t\t\tbreak;\n\n\t\tcase APM_NORMAL_RESUME:\n\t\tcase APM_CRITICAL_RESUME:\n\t\tcase APM_STANDBY_RESUME:\n\t\t\tignore_sys_suspend = 0;\n\t\t\tlast_resume = jiffies;\n\t\t\tignore_bounce = 1;\n\t\t\tif ((event != APM_NORMAL_RESUME)\n\t\t\t    || (ignore_normal_resume == 0)) {\n\t\t\t\tdpm_resume_end(PMSG_RESUME);\n\t\t\t\tqueue_event(event, NULL);\n\t\t\t}\n\t\t\tignore_normal_resume = 0;\n\t\t\tbreak;\n\n\t\tcase APM_CAPABILITY_CHANGE:\n\t\tcase APM_LOW_BATTERY:\n\t\tcase APM_POWER_STATUS_CHANGE:\n\t\t\tqueue_event(event, NULL);\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase APM_UPDATE_TIME:\n\t\t\tbreak;\n\n\t\tcase APM_CRITICAL_SUSPEND:\n\t\t\t \n\t\t\t(void)suspend(0);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void apm_event_handler(void)\n{\n\tstatic int pending_count = 4;\n\tint err;\n\n\tif ((standbys_pending > 0) || (suspends_pending > 0)) {\n\t\tif ((apm_info.connection_version > 0x100) &&\n\t\t    (pending_count-- <= 0)) {\n\t\t\tpending_count = 4;\n\t\t\tif (debug)\n\t\t\t\tprintk(KERN_DEBUG \"apm: setting state busy\\n\");\n\t\t\terr = set_system_power_state(APM_STATE_BUSY);\n\t\t\tif (err)\n\t\t\t\tapm_error(\"busy\", err);\n\t\t}\n\t} else\n\t\tpending_count = 4;\n\tcheck_events();\n}\n\n \n\nstatic void apm_mainloop(void)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(&apm_waitqueue, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tfor (;;) {\n\t\tschedule_timeout(APM_CHECK_TIMEOUT);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tapm_event_handler();\n\t}\n\tremove_wait_queue(&apm_waitqueue, &wait);\n}\n\nstatic int check_apm_user(struct apm_user *as, const char *func)\n{\n\tif (as == NULL || as->magic != APM_BIOS_MAGIC) {\n\t\tpr_err(\"%s passed bad filp\\n\", func);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t do_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct apm_user *as;\n\tint i;\n\tapm_event_t event;\n\n\tas = fp->private_data;\n\tif (check_apm_user(as, \"read\"))\n\t\treturn -EIO;\n\tif ((int)count < sizeof(apm_event_t))\n\t\treturn -EINVAL;\n\tif ((queue_empty(as)) && (fp->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(apm_waitqueue, !queue_empty(as));\n\ti = count;\n\twhile ((i >= sizeof(event)) && !queue_empty(as)) {\n\t\tevent = get_queued_event(as);\n\t\tif (copy_to_user(buf, &event, sizeof(event))) {\n\t\t\tif (i < count)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tswitch (event) {\n\t\tcase APM_SYS_SUSPEND:\n\t\tcase APM_USER_SUSPEND:\n\t\t\tas->suspends_read++;\n\t\t\tbreak;\n\n\t\tcase APM_SYS_STANDBY:\n\t\tcase APM_USER_STANDBY:\n\t\t\tas->standbys_read++;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += sizeof(event);\n\t\ti -= sizeof(event);\n\t}\n\tif (i < count)\n\t\treturn count - i;\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nstatic __poll_t do_poll(struct file *fp, poll_table *wait)\n{\n\tstruct apm_user *as;\n\n\tas = fp->private_data;\n\tif (check_apm_user(as, \"poll\"))\n\t\treturn 0;\n\tpoll_wait(fp, &apm_waitqueue, wait);\n\tif (!queue_empty(as))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic long do_ioctl(struct file *filp, u_int cmd, u_long arg)\n{\n\tstruct apm_user *as;\n\tint ret;\n\n\tas = filp->private_data;\n\tif (check_apm_user(as, \"ioctl\"))\n\t\treturn -EIO;\n\tif (!as->suser || !as->writer)\n\t\treturn -EPERM;\n\tswitch (cmd) {\n\tcase APM_IOC_STANDBY:\n\t\tmutex_lock(&apm_mutex);\n\t\tif (as->standbys_read > 0) {\n\t\t\tas->standbys_read--;\n\t\t\tas->standbys_pending--;\n\t\t\tstandbys_pending--;\n\t\t} else\n\t\t\tqueue_event(APM_USER_STANDBY, as);\n\t\tif (standbys_pending <= 0)\n\t\t\tstandby();\n\t\tmutex_unlock(&apm_mutex);\n\t\tbreak;\n\tcase APM_IOC_SUSPEND:\n\t\tmutex_lock(&apm_mutex);\n\t\tif (as->suspends_read > 0) {\n\t\t\tas->suspends_read--;\n\t\t\tas->suspends_pending--;\n\t\t\tsuspends_pending--;\n\t\t} else\n\t\t\tqueue_event(APM_USER_SUSPEND, as);\n\t\tif (suspends_pending <= 0) {\n\t\t\tret = suspend(1);\n\t\t\tmutex_unlock(&apm_mutex);\n\t\t} else {\n\t\t\tas->suspend_wait = 1;\n\t\t\tmutex_unlock(&apm_mutex);\n\t\t\twait_event_interruptible(apm_suspend_waitqueue,\n\t\t\t\t\tas->suspend_wait == 0);\n\t\t\tret = as->suspend_result;\n\t\t}\n\t\treturn ret;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic int do_release(struct inode *inode, struct file *filp)\n{\n\tstruct apm_user *as;\n\n\tas = filp->private_data;\n\tif (check_apm_user(as, \"release\"))\n\t\treturn 0;\n\tfilp->private_data = NULL;\n\tif (as->standbys_pending > 0) {\n\t\tstandbys_pending -= as->standbys_pending;\n\t\tif (standbys_pending <= 0)\n\t\t\tstandby();\n\t}\n\tif (as->suspends_pending > 0) {\n\t\tsuspends_pending -= as->suspends_pending;\n\t\tif (suspends_pending <= 0)\n\t\t\t(void) suspend(1);\n\t}\n\tspin_lock(&user_list_lock);\n\tif (user_list == as)\n\t\tuser_list = as->next;\n\telse {\n\t\tstruct apm_user *as1;\n\n\t\tfor (as1 = user_list;\n\t\t     (as1 != NULL) && (as1->next != as);\n\t\t     as1 = as1->next)\n\t\t\t;\n\t\tif (as1 == NULL)\n\t\t\tpr_err(\"filp not in user list\\n\");\n\t\telse\n\t\t\tas1->next = as->next;\n\t}\n\tspin_unlock(&user_list_lock);\n\tkfree(as);\n\treturn 0;\n}\n\nstatic int do_open(struct inode *inode, struct file *filp)\n{\n\tstruct apm_user *as;\n\n\tas = kmalloc(sizeof(*as), GFP_KERNEL);\n\tif (as == NULL)\n\t\treturn -ENOMEM;\n\n\tas->magic = APM_BIOS_MAGIC;\n\tas->event_tail = as->event_head = 0;\n\tas->suspends_pending = as->standbys_pending = 0;\n\tas->suspends_read = as->standbys_read = 0;\n\t \n\tas->suser = capable(CAP_SYS_ADMIN);\n\tas->writer = (filp->f_mode & FMODE_WRITE) == FMODE_WRITE;\n\tas->reader = (filp->f_mode & FMODE_READ) == FMODE_READ;\n\tspin_lock(&user_list_lock);\n\tas->next = user_list;\n\tuser_list = as;\n\tspin_unlock(&user_list_lock);\n\tfilp->private_data = as;\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int proc_apm_show(struct seq_file *m, void *v)\n{\n\tunsigned short\tbx;\n\tunsigned short\tcx;\n\tunsigned short\tdx;\n\tint\t\terror;\n\tunsigned short  ac_line_status = 0xff;\n\tunsigned short  battery_status = 0xff;\n\tunsigned short  battery_flag   = 0xff;\n\tint\t\tpercentage     = -1;\n\tint             time_units     = -1;\n\tchar            *units         = \"?\";\n\n\tif ((num_online_cpus() == 1) &&\n\t    !(error = apm_get_power_status(&bx, &cx, &dx))) {\n\t\tac_line_status = (bx >> 8) & 0xff;\n\t\tbattery_status = bx & 0xff;\n\t\tif ((cx & 0xff) != 0xff)\n\t\t\tpercentage = cx & 0xff;\n\n\t\tif (apm_info.connection_version > 0x100) {\n\t\t\tbattery_flag = (cx >> 8) & 0xff;\n\t\t\tif (dx != 0xffff) {\n\t\t\t\tunits = (dx & 0x8000) ? \"min\" : \"sec\";\n\t\t\t\ttime_units = dx & 0x7fff;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tseq_printf(m, \"%s %d.%d 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\\n\",\n\t\t   driver_version,\n\t\t   (apm_info.bios.version >> 8) & 0xff,\n\t\t   apm_info.bios.version & 0xff,\n\t\t   apm_info.bios.flags,\n\t\t   ac_line_status,\n\t\t   battery_status,\n\t\t   battery_flag,\n\t\t   percentage,\n\t\t   time_units,\n\t\t   units);\n\treturn 0;\n}\n#endif\n\nstatic int apm(void *unused)\n{\n\tunsigned short\tbx;\n\tunsigned short\tcx;\n\tunsigned short\tdx;\n\tint\t\terror;\n\tchar \t\t*power_stat;\n\tchar \t\t*bat_stat;\n\n\t \n\tset_cpus_allowed_ptr(current, cpumask_of(0));\n\tBUG_ON(smp_processor_id() != 0);\n\n\tif (apm_info.connection_version == 0) {\n\t\tapm_info.connection_version = apm_info.bios.version;\n\t\tif (apm_info.connection_version > 0x100) {\n\t\t\t \n\t\t\tif (apm_info.connection_version > 0x0102)\n\t\t\t\tapm_info.connection_version = 0x0102;\n\t\t\terror = apm_driver_version(&apm_info.connection_version);\n\t\t\tif (error != APM_SUCCESS) {\n\t\t\t\tapm_error(\"driver version\", error);\n\t\t\t\t \n\t\t\t\tapm_info.connection_version = 0x100;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (debug)\n\t\tprintk(KERN_INFO \"apm: Connection version %d.%d\\n\",\n\t\t\t(apm_info.connection_version >> 8) & 0xff,\n\t\t\tapm_info.connection_version & 0xff);\n\n#ifdef CONFIG_APM_DO_ENABLE\n\tif (apm_info.bios.flags & APM_BIOS_DISABLED) {\n\t\t \n\t\terror = apm_enable_power_management(1);\n\t\tif (error) {\n\t\t\tapm_error(\"enable power management\", error);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n\tif ((apm_info.bios.flags & APM_BIOS_DISENGAGED)\n\t    && (apm_info.connection_version > 0x0100)) {\n\t\terror = apm_engage_power_management(APM_DEVICE_ALL, 1);\n\t\tif (error) {\n\t\t\tapm_error(\"engage power management\", error);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (debug && (num_online_cpus() == 1 || smp)) {\n\t\terror = apm_get_power_status(&bx, &cx, &dx);\n\t\tif (error)\n\t\t\tprintk(KERN_INFO \"apm: power status not available\\n\");\n\t\telse {\n\t\t\tswitch ((bx >> 8) & 0xff) {\n\t\t\tcase 0:\n\t\t\t\tpower_stat = \"off line\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpower_stat = \"on line\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpower_stat = \"on backup power\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpower_stat = \"unknown\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (bx & 0xff) {\n\t\t\tcase 0:\n\t\t\t\tbat_stat = \"high\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbat_stat = \"low\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbat_stat = \"critical\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbat_stat = \"charging\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbat_stat = \"unknown\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"apm: AC %s, battery status %s, battery life \",\n\t\t\t       power_stat, bat_stat);\n\t\t\tif ((cx & 0xff) == 0xff)\n\t\t\t\tprintk(\"unknown\\n\");\n\t\t\telse\n\t\t\t\tprintk(\"%d%%\\n\", cx & 0xff);\n\t\t\tif (apm_info.connection_version > 0x100) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"apm: battery flag 0x%02x, battery life \",\n\t\t\t\t       (cx >> 8) & 0xff);\n\t\t\t\tif (dx == 0xffff)\n\t\t\t\t\tprintk(\"unknown\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintk(\"%d %s\\n\", dx & 0x7fff,\n\t\t\t\t\t       (dx & 0x8000) ?\n\t\t\t\t\t       \"minutes\" : \"seconds\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (power_off)\n\t\tpm_power_off = apm_power_off;\n\n\tif (num_online_cpus() == 1 || smp) {\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\n\t\tconsole_blank_hook = apm_console_blank;\n#endif\n\t\tapm_mainloop();\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\n\t\tconsole_blank_hook = NULL;\n#endif\n\t}\n\n\treturn 0;\n}\n\n#ifndef MODULE\nstatic int __init apm_setup(char *str)\n{\n\tint invert;\n\n\twhile ((str != NULL) && (*str != '\\0')) {\n\t\tif (strncmp(str, \"off\", 3) == 0)\n\t\t\tapm_disabled = 1;\n\t\tif (strncmp(str, \"on\", 2) == 0)\n\t\t\tapm_disabled = 0;\n\t\tif ((strncmp(str, \"bounce-interval=\", 16) == 0) ||\n\t\t    (strncmp(str, \"bounce_interval=\", 16) == 0))\n\t\t\tbounce_interval = simple_strtol(str + 16, NULL, 0);\n\t\tif ((strncmp(str, \"idle-threshold=\", 15) == 0) ||\n\t\t    (strncmp(str, \"idle_threshold=\", 15) == 0))\n\t\t\tidle_threshold = simple_strtol(str + 15, NULL, 0);\n\t\tif ((strncmp(str, \"idle-period=\", 12) == 0) ||\n\t\t    (strncmp(str, \"idle_period=\", 12) == 0))\n\t\t\tidle_period = simple_strtol(str + 12, NULL, 0);\n\t\tinvert = (strncmp(str, \"no-\", 3) == 0) ||\n\t\t\t(strncmp(str, \"no_\", 3) == 0);\n\t\tif (invert)\n\t\t\tstr += 3;\n\t\tif (strncmp(str, \"debug\", 5) == 0)\n\t\t\tdebug = !invert;\n\t\tif ((strncmp(str, \"power-off\", 9) == 0) ||\n\t\t    (strncmp(str, \"power_off\", 9) == 0))\n\t\t\tpower_off = !invert;\n\t\tif (strncmp(str, \"smp\", 3) == 0) {\n\t\t\tsmp = !invert;\n\t\t\tidle_threshold = 100;\n\t\t}\n\t\tif ((strncmp(str, \"allow-ints\", 10) == 0) ||\n\t\t    (strncmp(str, \"allow_ints\", 10) == 0))\n\t\t\tapm_info.allow_ints = !invert;\n\t\tif ((strncmp(str, \"broken-psr\", 10) == 0) ||\n\t\t    (strncmp(str, \"broken_psr\", 10) == 0))\n\t\t\tapm_info.get_power_status_broken = !invert;\n\t\tif ((strncmp(str, \"realmode-power-off\", 18) == 0) ||\n\t\t    (strncmp(str, \"realmode_power_off\", 18) == 0))\n\t\t\tapm_info.realmode_power_off = !invert;\n\t\tstr = strchr(str, ',');\n\t\tif (str != NULL)\n\t\t\tstr += strspn(str, \", \\t\");\n\t}\n\treturn 1;\n}\n\n__setup(\"apm=\", apm_setup);\n#endif\n\nstatic const struct file_operations apm_bios_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= do_read,\n\t.poll\t\t= do_poll,\n\t.unlocked_ioctl\t= do_ioctl,\n\t.open\t\t= do_open,\n\t.release\t= do_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice apm_device = {\n\tAPM_MINOR_DEV,\n\t\"apm_bios\",\n\t&apm_bios_fops\n};\n\n\n \nstatic int __init print_if_true(const struct dmi_system_id *d)\n{\n\tprintk(\"%s\\n\", d->ident);\n\treturn 0;\n}\n\n \nstatic int __init broken_ps2_resume(const struct dmi_system_id *d)\n{\n\tprintk(KERN_INFO \"%s machine detected. Mousepad Resume Bug \"\n\t       \"workaround hopefully not needed.\\n\", d->ident);\n\treturn 0;\n}\n\n \nstatic int __init set_realmode_power_off(const struct dmi_system_id *d)\n{\n\tif (apm_info.realmode_power_off == 0) {\n\t\tapm_info.realmode_power_off = 1;\n\t\tprintk(KERN_INFO \"%s bios detected. \"\n\t\t       \"Using realmode poweroff only.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\n \nstatic int __init set_apm_ints(const struct dmi_system_id *d)\n{\n\tif (apm_info.allow_ints == 0) {\n\t\tapm_info.allow_ints = 1;\n\t\tprintk(KERN_INFO \"%s machine detected. \"\n\t\t       \"Enabling interrupts during APM calls.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\n \nstatic int __init apm_is_horked(const struct dmi_system_id *d)\n{\n\tif (apm_info.disabled == 0) {\n\t\tapm_info.disabled = 1;\n\t\tprintk(KERN_INFO \"%s machine detected. \"\n\t\t       \"Disabling APM.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\nstatic int __init apm_is_horked_d850md(const struct dmi_system_id *d)\n{\n\tif (apm_info.disabled == 0) {\n\t\tapm_info.disabled = 1;\n\t\tprintk(KERN_INFO \"%s machine detected. \"\n\t\t       \"Disabling APM.\\n\", d->ident);\n\t\tprintk(KERN_INFO \"This bug is fixed in bios P15 which is available for\\n\");\n\t\tprintk(KERN_INFO \"download from support.intel.com\\n\");\n\t}\n\treturn 0;\n}\n\n \nstatic int __init apm_likes_to_melt(const struct dmi_system_id *d)\n{\n\tif (apm_info.forbid_idle == 0) {\n\t\tapm_info.forbid_idle = 1;\n\t\tprintk(KERN_INFO \"%s machine detected. \"\n\t\t       \"Disabling APM idle calls.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\n \nstatic int __init broken_apm_power(const struct dmi_system_id *d)\n{\n\tapm_info.get_power_status_broken = 1;\n\tprintk(KERN_WARNING \"BIOS strings suggest APM bugs, \"\n\t       \"disabling power status reporting.\\n\");\n\treturn 0;\n}\n\n \nstatic int __init swab_apm_power_in_minutes(const struct dmi_system_id *d)\n{\n\tapm_info.get_power_status_swabinminutes = 1;\n\tprintk(KERN_WARNING \"BIOS strings suggest APM reports battery life \"\n\t       \"in minutes and wrong byte order.\\n\");\n\treturn 0;\n}\n\nstatic const struct dmi_system_id apm_dmi_table[] __initconst = {\n\t{\n\t\tprint_if_true,\n\t\tKERN_WARNING \"IBM T23 - BIOS 1.03b+ and controller firmware 1.02+ may be needed for Linux APM.\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"1AET38WW (1.01b)\"), },\n\t},\n\t{\t \n\t\tbroken_ps2_resume, \"Dell Latitude C600\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude C600\"), },\n\t},\n\t{\t \n\t\tset_apm_ints, \"Dell Latitude\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude C510\"), }\n\t},\n\t{\t \n\t\tapm_is_horked, \"Dell Inspiron 2500\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 2500\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A11\"), },\n\t},\n\t{\t \n\t\tset_apm_ints, \"Dell Inspiron\", {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 4000\"), },\n\t},\n\t{\t \n\t\tbroken_apm_power, \"Dell Inspiron 5000e\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A04\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/24/2000\"), },\n\t},\n\t{\t \n\t\tbroken_apm_power, \"Dell Inspiron 2500\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A12\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"02/04/2002\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Dell Dimension 4100\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XPS-Z\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A11\"), },\n\t},\n\t{\t \n\t\tset_apm_ints, \"Compaq 12XL125\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Compaq\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Compaq PC\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"4.06\"), },\n\t},\n\t{\t \n\t\tset_apm_ints, \"ASUSTeK\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"L8400K series Notebook PC\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"ABIT KX7-333[R]\",\n\t\t{\tDMI_MATCH(DMI_BOARD_VENDOR, \"ABIT\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"VT8367-8233A (KX7-333[R])\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Trigem Delhi3\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"TriGem Computer, Inc\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Delhi3\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Fujitsu-Siemens\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"hoenix/FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Version1.01\"), },\n\t},\n\t{\t \n\t\tapm_is_horked_d850md, \"Intel D850MD\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"MV85010A.86A.0016.P07.0201251536\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Intel D810EMO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"MO81010A.86A.0008.P04.0004170800\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Dell XPS-Z\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A11\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XPS-Z\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Sharp PC-PJ/AX\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"SHARP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PC-PJ/AX\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"SystemSoft\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Version R2.08\"), },\n\t},\n\t{\t \n\t\tapm_is_horked, \"Dell Inspiron 2500\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 2500\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"A11\"), },\n\t},\n\t{\t \n\t\tapm_likes_to_melt, \"Jabil AMD\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"American Megatrends Inc.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"0AASNP06\"), },\n\t},\n\t{\t \n\t\tapm_likes_to_melt, \"AMI Bios\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"American Megatrends Inc.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"0AASNP05\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0206H\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/23/99\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"W2K06H0\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"02/03/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0117A0\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"04/25/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0121Z1\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"05/11/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"WME01Z1\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/11/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0206Z3\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"12/25/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0203D0\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"05/12/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0203Z3\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/25/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0209Z3\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"05/12/01\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0204K2\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/28/00\"), },\n\t},\n\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0208P1\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"11/09/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"R0204P1\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"09/12/00\"), },\n\t},\n\t{\t \n\t\tswab_apm_power_in_minutes, \"Sony VAIO\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"WXPO1Z3\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"10/26/01\"), },\n\t},\n\t{\t \n\t\tset_realmode_power_off, \"Award Software v4.60 PGMA\",\n\t\t{\tDMI_MATCH(DMI_BIOS_VENDOR, \"Award Software International, Inc.\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"4.60 PGMA\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"134526184\"), },\n\t},\n\n\t \n\n\t{\t \n\t\tset_apm_ints, \"IBM\",\n\t\t{\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"), },\n\t},\n\n\t{ }\n};\n\n \nstatic int __init apm_init(void)\n{\n\tstruct desc_struct *gdt;\n\tint err;\n\n\tdmi_check_system(apm_dmi_table);\n\n\tif (apm_info.bios.version == 0 || machine_is_olpc()) {\n\t\tprintk(KERN_INFO \"apm: BIOS not found.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprintk(KERN_INFO\n\t       \"apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\\n\",\n\t       ((apm_info.bios.version >> 8) & 0xff),\n\t       (apm_info.bios.version & 0xff),\n\t       apm_info.bios.flags,\n\t       driver_version);\n\tif ((apm_info.bios.flags & APM_32_BIT_SUPPORT) == 0) {\n\t\tprintk(KERN_INFO \"apm: no 32 bit BIOS support\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (allow_ints)\n\t\tapm_info.allow_ints = 1;\n\tif (broken_psr)\n\t\tapm_info.get_power_status_broken = 1;\n\tif (realmode_power_off)\n\t\tapm_info.realmode_power_off = 1;\n\t \n\tif (apm_disabled != -1)\n\t\tapm_info.disabled = apm_disabled;\n\n\t \n\tif (apm_info.bios.version == 0x001)\n\t\tapm_info.bios.version = 0x100;\n\n\t \n\tif (apm_info.bios.version < 0x102)\n\t\tapm_info.bios.cseg_16_len = 0;  \n\n\tif (debug) {\n\t\tprintk(KERN_INFO \"apm: entry %x:%x cseg16 %x dseg %x\",\n\t\t\tapm_info.bios.cseg, apm_info.bios.offset,\n\t\t\tapm_info.bios.cseg_16, apm_info.bios.dseg);\n\t\tif (apm_info.bios.version > 0x100)\n\t\t\tprintk(\" cseg len %x, dseg len %x\",\n\t\t\t\tapm_info.bios.cseg_len,\n\t\t\t\tapm_info.bios.dseg_len);\n\t\tif (apm_info.bios.version > 0x101)\n\t\t\tprintk(\" cseg16 len %x\", apm_info.bios.cseg_16_len);\n\t\tprintk(\"\\n\");\n\t}\n\n\tif (apm_info.disabled) {\n\t\tpr_notice(\"disabled on user request.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif ((num_online_cpus() > 1) && !power_off && !smp) {\n\t\tpr_notice(\"disabled - APM is not SMP safe.\\n\");\n\t\tapm_info.disabled = 1;\n\t\treturn -ENODEV;\n\t}\n\tif (!acpi_disabled) {\n\t\tpr_notice(\"overridden by ACPI.\\n\");\n\t\tapm_info.disabled = 1;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tapm_bios_entry.offset = apm_info.bios.offset;\n\tapm_bios_entry.segment = APM_CS;\n\n\t \n\tgdt = get_cpu_gdt_rw(0);\n\tset_desc_base(&gdt[APM_CS >> 3],\n\t\t (unsigned long)__va((unsigned long)apm_info.bios.cseg << 4));\n\tset_desc_base(&gdt[APM_CS_16 >> 3],\n\t\t (unsigned long)__va((unsigned long)apm_info.bios.cseg_16 << 4));\n\tset_desc_base(&gdt[APM_DS >> 3],\n\t\t (unsigned long)__va((unsigned long)apm_info.bios.dseg << 4));\n\n\tproc_create_single(\"apm\", 0, NULL, proc_apm_show);\n\n\tkapmd_task = kthread_create(apm, NULL, \"kapmd\");\n\tif (IS_ERR(kapmd_task)) {\n\t\tpr_err(\"disabled - Unable to start kernel thread\\n\");\n\t\terr = PTR_ERR(kapmd_task);\n\t\tkapmd_task = NULL;\n\t\tremove_proc_entry(\"apm\", NULL);\n\t\treturn err;\n\t}\n\twake_up_process(kapmd_task);\n\n\tif (num_online_cpus() > 1 && !smp) {\n\t\tprintk(KERN_NOTICE\n\t\t       \"apm: disabled - APM is not SMP safe (power off active).\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (misc_register(&apm_device))\n\t\tprintk(KERN_WARNING \"apm: Could not register misc device.\\n\");\n\n\tif (HZ != 100)\n\t\tidle_period = (idle_period * HZ) / 100;\n\tif (idle_threshold < 100) {\n\t\tcpuidle_poll_state_init(&apm_idle_driver);\n\t\tif (!cpuidle_register_driver(&apm_idle_driver))\n\t\t\tif (cpuidle_register_device(&apm_cpuidle_device))\n\t\t\t\tcpuidle_unregister_driver(&apm_idle_driver);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit apm_exit(void)\n{\n\tint error;\n\n\tcpuidle_unregister_device(&apm_cpuidle_device);\n\tcpuidle_unregister_driver(&apm_idle_driver);\n\n\tif (((apm_info.bios.flags & APM_BIOS_DISENGAGED) == 0)\n\t    && (apm_info.connection_version > 0x0100)) {\n\t\terror = apm_engage_power_management(APM_DEVICE_ALL, 0);\n\t\tif (error)\n\t\t\tapm_error(\"disengage power management\", error);\n\t}\n\tmisc_deregister(&apm_device);\n\tremove_proc_entry(\"apm\", NULL);\n\tif (power_off)\n\t\tpm_power_off = NULL;\n\tif (kapmd_task) {\n\t\tkthread_stop(kapmd_task);\n\t\tkapmd_task = NULL;\n\t}\n}\n\nmodule_init(apm_init);\nmodule_exit(apm_exit);\n\nMODULE_AUTHOR(\"Stephen Rothwell\");\nMODULE_DESCRIPTION(\"Advanced Power Management\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Enable debug mode\");\nmodule_param(power_off, bool, 0444);\nMODULE_PARM_DESC(power_off, \"Enable power off\");\nmodule_param(bounce_interval, int, 0444);\nMODULE_PARM_DESC(bounce_interval,\n\t\t\"Set the number of ticks to ignore suspend bounces\");\nmodule_param(allow_ints, bool, 0444);\nMODULE_PARM_DESC(allow_ints, \"Allow interrupts during BIOS calls\");\nmodule_param(broken_psr, bool, 0444);\nMODULE_PARM_DESC(broken_psr, \"BIOS has a broken GetPowerStatus call\");\nmodule_param(realmode_power_off, bool, 0444);\nMODULE_PARM_DESC(realmode_power_off,\n\t\t\"Switch to real mode before powering off\");\nmodule_param(idle_threshold, int, 0444);\nMODULE_PARM_DESC(idle_threshold,\n\t\"System idle percentage above which to make APM BIOS idle calls\");\nmodule_param(idle_period, int, 0444);\nMODULE_PARM_DESC(idle_period,\n\t\"Period (in sec/100) over which to calculate the idle percentage\");\nmodule_param(smp, bool, 0444);\nMODULE_PARM_DESC(smp,\n\t\"Set this to enable APM use on an SMP platform. Use with caution on older systems\");\nMODULE_ALIAS_MISCDEV(APM_MINOR_DEV);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}