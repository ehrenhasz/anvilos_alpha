{
  "module_name": "kdebugfs.c",
  "hash_id": "ed6afb87164ff6a37a0794837354274ac56a06df0562686860488c67191718bd",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/kdebugfs.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n\n#include <asm/setup.h>\n\nstruct dentry *arch_debugfs_dir;\nEXPORT_SYMBOL(arch_debugfs_dir);\n\n#ifdef CONFIG_DEBUG_BOOT_PARAMS\nstruct setup_data_node {\n\tu64 paddr;\n\tu32 type;\n\tu32 len;\n};\n\nstatic ssize_t setup_data_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct setup_data_node *node = file->private_data;\n\tunsigned long remain;\n\tloff_t pos = *ppos;\n\tvoid *p;\n\tu64 pa;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tif (pos >= node->len)\n\t\treturn 0;\n\n\tif (count > node->len - pos)\n\t\tcount = node->len - pos;\n\n\tpa = node->paddr + pos;\n\n\t \n\tif (!(node->type & SETUP_INDIRECT) || node->type == SETUP_INDIRECT)\n\t\tpa += sizeof(struct setup_data);\n\n\tp = memremap(pa, count, MEMREMAP_WB);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tremain = copy_to_user(user_buf, p, count);\n\n\tmemunmap(p);\n\n\tif (remain)\n\t\treturn -EFAULT;\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_setup_data = {\n\t.read\t\t= setup_data_read,\n\t.open\t\t= simple_open,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic void __init\ncreate_setup_data_node(struct dentry *parent, int no,\n\t\t       struct setup_data_node *node)\n{\n\tstruct dentry *d;\n\tchar buf[16];\n\n\tsprintf(buf, \"%d\", no);\n\td = debugfs_create_dir(buf, parent);\n\n\tdebugfs_create_x32(\"type\", S_IRUGO, d, &node->type);\n\tdebugfs_create_file(\"data\", S_IRUGO, d, node, &fops_setup_data);\n}\n\nstatic int __init create_setup_data_nodes(struct dentry *parent)\n{\n\tstruct setup_indirect *indirect;\n\tstruct setup_data_node *node;\n\tstruct setup_data *data;\n\tu64 pa_data, pa_next;\n\tstruct dentry *d;\n\tint error;\n\tu32 len;\n\tint no = 0;\n\n\td = debugfs_create_dir(\"setup_data\", parent);\n\n\tpa_data = boot_params.hdr.setup_data;\n\n\twhile (pa_data) {\n\t\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err_dir;\n\t\t}\n\n\t\tdata = memremap(pa_data, sizeof(*data), MEMREMAP_WB);\n\t\tif (!data) {\n\t\t\tkfree(node);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err_dir;\n\t\t}\n\t\tpa_next = data->next;\n\n\t\tif (data->type == SETUP_INDIRECT) {\n\t\t\tlen = sizeof(*data) + data->len;\n\t\t\tmemunmap(data);\n\t\t\tdata = memremap(pa_data, len, MEMREMAP_WB);\n\t\t\tif (!data) {\n\t\t\t\tkfree(node);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto err_dir;\n\t\t\t}\n\n\t\t\tindirect = (struct setup_indirect *)data->data;\n\n\t\t\tif (indirect->type != SETUP_INDIRECT) {\n\t\t\t\tnode->paddr = indirect->addr;\n\t\t\t\tnode->type  = indirect->type;\n\t\t\t\tnode->len   = indirect->len;\n\t\t\t} else {\n\t\t\t\tnode->paddr = pa_data;\n\t\t\t\tnode->type  = data->type;\n\t\t\t\tnode->len   = data->len;\n\t\t\t}\n\t\t} else {\n\t\t\tnode->paddr = pa_data;\n\t\t\tnode->type  = data->type;\n\t\t\tnode->len   = data->len;\n\t\t}\n\n\t\tcreate_setup_data_node(d, no, node);\n\t\tpa_data = pa_next;\n\n\t\tmemunmap(data);\n\t\tno++;\n\t}\n\n\treturn 0;\n\nerr_dir:\n\tdebugfs_remove_recursive(d);\n\treturn error;\n}\n\nstatic struct debugfs_blob_wrapper boot_params_blob = {\n\t.data\t\t= &boot_params,\n\t.size\t\t= sizeof(boot_params),\n};\n\nstatic int __init boot_params_kdebugfs_init(void)\n{\n\tstruct dentry *dbp;\n\tint error;\n\n\tdbp = debugfs_create_dir(\"boot_params\", arch_debugfs_dir);\n\n\tdebugfs_create_x16(\"version\", S_IRUGO, dbp, &boot_params.hdr.version);\n\tdebugfs_create_blob(\"data\", S_IRUGO, dbp, &boot_params_blob);\n\n\terror = create_setup_data_nodes(dbp);\n\tif (error)\n\t\tdebugfs_remove_recursive(dbp);\n\n\treturn error;\n}\n#endif  \n\nstatic int __init arch_kdebugfs_init(void)\n{\n\tint error = 0;\n\n\tarch_debugfs_dir = debugfs_create_dir(\"x86\", NULL);\n\n#ifdef CONFIG_DEBUG_BOOT_PARAMS\n\terror = boot_params_kdebugfs_init();\n#endif\n\n\treturn error;\n}\narch_initcall(arch_kdebugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}