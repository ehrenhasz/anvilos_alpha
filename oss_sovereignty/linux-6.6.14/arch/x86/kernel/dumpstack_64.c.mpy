{
  "module_name": "dumpstack_64.c",
  "hash_id": "c2557c4f318858271a53be5d5943c2033359da2216429a822c75e8811e33d61b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/dumpstack_64.c",
  "human_readable_source": "\n \n#include <linux/sched/debug.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kdebug.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/kexec.h>\n#include <linux/sysfs.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n\n#include <asm/cpu_entry_area.h>\n#include <asm/stacktrace.h>\n\nstatic const char * const exception_stack_names[] = {\n\t\t[ ESTACK_DF\t]\t= \"#DF\",\n\t\t[ ESTACK_NMI\t]\t= \"NMI\",\n\t\t[ ESTACK_DB\t]\t= \"#DB\",\n\t\t[ ESTACK_MCE\t]\t= \"#MC\",\n\t\t[ ESTACK_VC\t]\t= \"#VC\",\n\t\t[ ESTACK_VC2\t]\t= \"#VC2\",\n};\n\nconst char *stack_type_name(enum stack_type type)\n{\n\tBUILD_BUG_ON(N_EXCEPTION_STACKS != 6);\n\n\tif (type == STACK_TYPE_TASK)\n\t\treturn \"TASK\";\n\n\tif (type == STACK_TYPE_IRQ)\n\t\treturn \"IRQ\";\n\n\tif (type == STACK_TYPE_SOFTIRQ)\n\t\treturn \"SOFTIRQ\";\n\n\tif (type == STACK_TYPE_ENTRY) {\n\t\t \n\t\treturn \"ENTRY_TRAMPOLINE\";\n\t}\n\n\tif (type >= STACK_TYPE_EXCEPTION && type <= STACK_TYPE_EXCEPTION_LAST)\n\t\treturn exception_stack_names[type - STACK_TYPE_EXCEPTION];\n\n\treturn NULL;\n}\n\n \nstruct estack_pages {\n\tu32\toffs;\n\tu16\tsize;\n\tu16\ttype;\n};\n\n#define EPAGERANGE(st)\t\t\t\t\t\t\t\\\n\t[PFN_DOWN(CEA_ESTACK_OFFS(st)) ...\t\t\t\t\\\n\t PFN_DOWN(CEA_ESTACK_OFFS(st) + CEA_ESTACK_SIZE(st) - 1)] = {\t\\\n\t\t.offs\t= CEA_ESTACK_OFFS(st),\t\t\t\t\\\n\t\t.size\t= CEA_ESTACK_SIZE(st),\t\t\t\t\\\n\t\t.type\t= STACK_TYPE_EXCEPTION + ESTACK_ ##st, }\n\n \nstatic const\nstruct estack_pages estack_pages[CEA_ESTACK_PAGES] ____cacheline_aligned = {\n\tEPAGERANGE(DF),\n\tEPAGERANGE(NMI),\n\tEPAGERANGE(DB),\n\tEPAGERANGE(MCE),\n\tEPAGERANGE(VC),\n\tEPAGERANGE(VC2),\n};\n\nstatic __always_inline bool in_exception_stack(unsigned long *stack, struct stack_info *info)\n{\n\tunsigned long begin, end, stk = (unsigned long)stack;\n\tconst struct estack_pages *ep;\n\tstruct pt_regs *regs;\n\tunsigned int k;\n\n\tBUILD_BUG_ON(N_EXCEPTION_STACKS != 6);\n\n\tbegin = (unsigned long)__this_cpu_read(cea_exception_stacks);\n\t \n\tif (!begin)\n\t\treturn false;\n\n\tend = begin + sizeof(struct cea_exception_stacks);\n\t \n\tif (stk < begin || stk >= end)\n\t\treturn false;\n\n\t \n\tk = (stk - begin) >> PAGE_SHIFT;\n\t \n\tep = &estack_pages[k];\n\t \n\tif (!ep->size)\n\t\treturn false;\n\n\tbegin += (unsigned long)ep->offs;\n\tend = begin + (unsigned long)ep->size;\n\tregs = (struct pt_regs *)end - 1;\n\n\tinfo->type\t= ep->type;\n\tinfo->begin\t= (unsigned long *)begin;\n\tinfo->end\t= (unsigned long *)end;\n\tinfo->next_sp\t= (unsigned long *)regs->sp;\n\treturn true;\n}\n\nstatic __always_inline bool in_irq_stack(unsigned long *stack, struct stack_info *info)\n{\n\tunsigned long *end = (unsigned long *)this_cpu_read(pcpu_hot.hardirq_stack_ptr);\n\tunsigned long *begin;\n\n\t \n\tend++;\n\tbegin = end - (IRQ_STACK_SIZE / sizeof(long));\n\n\t \n\tif (stack < begin || stack >= end)\n\t\treturn false;\n\n\tinfo->type\t= STACK_TYPE_IRQ;\n\tinfo->begin\t= begin;\n\tinfo->end\t= end;\n\n\t \n\tinfo->next_sp = (unsigned long *)*(end - 1);\n\n\treturn true;\n}\n\nbool noinstr get_stack_info_noinstr(unsigned long *stack, struct task_struct *task,\n\t\t\t\t    struct stack_info *info)\n{\n\tif (in_task_stack(stack, task, info))\n\t\treturn true;\n\n\tif (task != current)\n\t\treturn false;\n\n\tif (in_exception_stack(stack, info))\n\t\treturn true;\n\n\tif (in_irq_stack(stack, info))\n\t\treturn true;\n\n\tif (in_entry_stack(stack, info))\n\t\treturn true;\n\n\treturn false;\n}\n\nint get_stack_info(unsigned long *stack, struct task_struct *task,\n\t\t   struct stack_info *info, unsigned long *visit_mask)\n{\n\ttask = task ? : current;\n\n\tif (!stack)\n\t\tgoto unknown;\n\n\tif (!get_stack_info_noinstr(stack, task, info))\n\t\tgoto unknown;\n\n\t \n\tif (visit_mask) {\n\t\tif (*visit_mask & (1UL << info->type)) {\n\t\t\tif (task == current)\n\t\t\t\tprintk_deferred_once(KERN_WARNING \"WARNING: stack recursion on stack type %d\\n\", info->type);\n\t\t\tgoto unknown;\n\t\t}\n\t\t*visit_mask |= 1UL << info->type;\n\t}\n\n\treturn 0;\n\nunknown:\n\tinfo->type = STACK_TYPE_UNKNOWN;\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}