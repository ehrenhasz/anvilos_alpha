{
  "module_name": "espfix_64.c",
  "hash_id": "f89285ef354748bd13ac6eb1c27d84c2333dff27008e432f4d1605a35a5a0288",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/espfix_64.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/init_task.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/gfp.h>\n#include <linux/random.h>\n#include <linux/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/setup.h>\n#include <asm/espfix.h>\n\n \n#define ESPFIX_STACK_SIZE\t(8*8UL)\n#define ESPFIX_STACKS_PER_PAGE\t(PAGE_SIZE/ESPFIX_STACK_SIZE)\n\n \n#define ESPFIX_PAGE_SPACE\t(1UL << (P4D_SHIFT-PAGE_SHIFT-16))\n\n#define ESPFIX_MAX_CPUS\t\t(ESPFIX_STACKS_PER_PAGE * ESPFIX_PAGE_SPACE)\n#if CONFIG_NR_CPUS > ESPFIX_MAX_CPUS\n# error \"Need more virtual address space for the ESPFIX hack\"\n#endif\n\n#define PGALLOC_GFP (GFP_KERNEL | __GFP_ZERO)\n\n \nDEFINE_PER_CPU_READ_MOSTLY(unsigned long, espfix_stack);\nDEFINE_PER_CPU_READ_MOSTLY(unsigned long, espfix_waddr);\n\n \nstatic DEFINE_MUTEX(espfix_init_mutex);\n\n \n#define ESPFIX_MAX_PAGES  DIV_ROUND_UP(CONFIG_NR_CPUS, ESPFIX_STACKS_PER_PAGE)\nstatic void *espfix_pages[ESPFIX_MAX_PAGES];\n\nstatic __page_aligned_bss pud_t espfix_pud_page[PTRS_PER_PUD]\n\t__aligned(PAGE_SIZE);\n\nstatic unsigned int page_random, slot_random;\n\n \nstatic inline unsigned long espfix_base_addr(unsigned int cpu)\n{\n\tunsigned long page, slot;\n\tunsigned long addr;\n\n\tpage = (cpu / ESPFIX_STACKS_PER_PAGE) ^ page_random;\n\tslot = (cpu + slot_random) % ESPFIX_STACKS_PER_PAGE;\n\taddr = (page << PAGE_SHIFT) + (slot * ESPFIX_STACK_SIZE);\n\taddr = (addr & 0xffffUL) | ((addr & ~0xffffUL) << 16);\n\taddr += ESPFIX_BASE_ADDR;\n\treturn addr;\n}\n\n#define PTE_STRIDE        (65536/PAGE_SIZE)\n#define ESPFIX_PTE_CLONES (PTRS_PER_PTE/PTE_STRIDE)\n#define ESPFIX_PMD_CLONES PTRS_PER_PMD\n#define ESPFIX_PUD_CLONES (65536/(ESPFIX_PTE_CLONES*ESPFIX_PMD_CLONES))\n\n#define PGTABLE_PROT\t  ((_KERNPG_TABLE & ~_PAGE_RW) | _PAGE_NX)\n\nstatic void init_espfix_random(void)\n{\n\tunsigned long rand = get_random_long();\n\n\tslot_random = rand % ESPFIX_STACKS_PER_PAGE;\n\tpage_random = (rand / ESPFIX_STACKS_PER_PAGE)\n\t\t& (ESPFIX_PAGE_SPACE - 1);\n}\n\nvoid __init init_espfix_bsp(void)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\n\t \n\tpgd = &init_top_pgt[pgd_index(ESPFIX_BASE_ADDR)];\n\tp4d = p4d_alloc(&init_mm, pgd, ESPFIX_BASE_ADDR);\n\tp4d_populate(&init_mm, p4d, espfix_pud_page);\n\n\t \n\tinit_espfix_random();\n\n\t \n\tinit_espfix_ap(0);\n}\n\nvoid init_espfix_ap(int cpu)\n{\n\tunsigned int page;\n\tunsigned long addr;\n\tpud_t pud, *pud_p;\n\tpmd_t pmd, *pmd_p;\n\tpte_t pte, *pte_p;\n\tint n, node;\n\tvoid *stack_page;\n\tpteval_t ptemask;\n\n\t \n\tif (likely(per_cpu(espfix_stack, cpu)))\n\t\treturn;\t\t \n\n\taddr = espfix_base_addr(cpu);\n\tpage = cpu/ESPFIX_STACKS_PER_PAGE;\n\n\t \n\tstack_page = READ_ONCE(espfix_pages[page]);\n\tif (likely(stack_page))\n\t\tgoto done;\n\n\tmutex_lock(&espfix_init_mutex);\n\n\t \n\tstack_page = READ_ONCE(espfix_pages[page]);\n\tif (stack_page)\n\t\tgoto unlock_done;\n\n\tnode = cpu_to_node(cpu);\n\tptemask = __supported_pte_mask;\n\n\tpud_p = &espfix_pud_page[pud_index(addr)];\n\tpud = *pud_p;\n\tif (!pud_present(pud)) {\n\t\tstruct page *page = alloc_pages_node(node, PGALLOC_GFP, 0);\n\n\t\tpmd_p = (pmd_t *)page_address(page);\n\t\tpud = __pud(__pa(pmd_p) | (PGTABLE_PROT & ptemask));\n\t\tparavirt_alloc_pmd(&init_mm, __pa(pmd_p) >> PAGE_SHIFT);\n\t\tfor (n = 0; n < ESPFIX_PUD_CLONES; n++)\n\t\t\tset_pud(&pud_p[n], pud);\n\t}\n\n\tpmd_p = pmd_offset(&pud, addr);\n\tpmd = *pmd_p;\n\tif (!pmd_present(pmd)) {\n\t\tstruct page *page = alloc_pages_node(node, PGALLOC_GFP, 0);\n\n\t\tpte_p = (pte_t *)page_address(page);\n\t\tpmd = __pmd(__pa(pte_p) | (PGTABLE_PROT & ptemask));\n\t\tparavirt_alloc_pte(&init_mm, __pa(pte_p) >> PAGE_SHIFT);\n\t\tfor (n = 0; n < ESPFIX_PMD_CLONES; n++)\n\t\t\tset_pmd(&pmd_p[n], pmd);\n\t}\n\n\tpte_p = pte_offset_kernel(&pmd, addr);\n\tstack_page = page_address(alloc_pages_node(node, GFP_KERNEL, 0));\n\t \n\tpte = __pte(__pa(stack_page) | ((__PAGE_KERNEL_RO | _PAGE_ENC) & ptemask));\n\tfor (n = 0; n < ESPFIX_PTE_CLONES; n++)\n\t\tset_pte(&pte_p[n*PTE_STRIDE], pte);\n\n\t \n\tWRITE_ONCE(espfix_pages[page], stack_page);\n\nunlock_done:\n\tmutex_unlock(&espfix_init_mutex);\ndone:\n\tper_cpu(espfix_stack, cpu) = addr;\n\tper_cpu(espfix_waddr, cpu) = (unsigned long)stack_page\n\t\t\t\t      + (addr & ~PAGE_MASK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}