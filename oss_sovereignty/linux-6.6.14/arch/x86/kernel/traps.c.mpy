{
  "module_name": "traps.c",
  "hash_id": "57e338b890f6fe0e22a6f1d91b47192b77100747db8c26072909ab945c71cf90",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kernel/traps.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/context_tracking.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsan.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/kdebug.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/uprobes.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kexec.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/io.h>\n#include <linux/hardirq.h>\n#include <linux/atomic.h>\n#include <linux/iommu.h>\n\n#include <asm/stacktrace.h>\n#include <asm/processor.h>\n#include <asm/debugreg.h>\n#include <asm/realmode.h>\n#include <asm/text-patching.h>\n#include <asm/ftrace.h>\n#include <asm/traps.h>\n#include <asm/desc.h>\n#include <asm/fpu/api.h>\n#include <asm/cpu.h>\n#include <asm/cpu_entry_area.h>\n#include <asm/mce.h>\n#include <asm/fixmap.h>\n#include <asm/mach_traps.h>\n#include <asm/alternative.h>\n#include <asm/fpu/xstate.h>\n#include <asm/vm86.h>\n#include <asm/umip.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <asm/vdso.h>\n#include <asm/tdx.h>\n#include <asm/cfi.h>\n\n#ifdef CONFIG_X86_64\n#include <asm/x86_init.h>\n#else\n#include <asm/processor-flags.h>\n#include <asm/setup.h>\n#endif\n\n#include <asm/proto.h>\n\nDECLARE_BITMAP(system_vectors, NR_VECTORS);\n\n__always_inline int is_valid_bugaddr(unsigned long addr)\n{\n\tif (addr < TASK_SIZE_MAX)\n\t\treturn 0;\n\n\t \n\treturn *(unsigned short *)addr == INSN_UD2;\n}\n\nstatic nokprobe_inline int\ndo_trap_no_signal(struct task_struct *tsk, int trapnr, const char *str,\n\t\t  struct pt_regs *regs,\tlong error_code)\n{\n\tif (v8086_mode(regs)) {\n\t\t \n\t\tif (trapnr < X86_TRAP_UD) {\n\t\t\tif (!handle_vm86_trap((struct kernel_vm86_regs *) regs,\n\t\t\t\t\t\terror_code, trapnr))\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, trapnr, error_code, 0))\n\t\t\treturn 0;\n\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_nr = trapnr;\n\t\tdie(str, regs, error_code);\n\t} else {\n\t\tif (fixup_vdso_exception(regs, trapnr, error_code, 0))\n\t\t\treturn 0;\n\t}\n\n\t \n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = trapnr;\n\n\treturn -1;\n}\n\nstatic void show_signal(struct task_struct *tsk, int signr,\n\t\t\tconst char *type, const char *desc,\n\t\t\tstruct pt_regs *regs, long error_code)\n{\n\tif (show_unhandled_signals && unhandled_signal(tsk, signr) &&\n\t    printk_ratelimit()) {\n\t\tpr_info(\"%s[%d] %s%s ip:%lx sp:%lx error:%lx\",\n\t\t\ttsk->comm, task_pid_nr(tsk), type, desc,\n\t\t\tregs->ip, regs->sp, error_code);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n}\n\nstatic void\ndo_trap(int trapnr, int signr, char *str, struct pt_regs *regs,\n\tlong error_code, int sicode, void __user *addr)\n{\n\tstruct task_struct *tsk = current;\n\n\tif (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))\n\t\treturn;\n\n\tshow_signal(tsk, signr, \"trap \", str, regs, error_code);\n\n\tif (!sicode)\n\t\tforce_sig(signr);\n\telse\n\t\tforce_sig_fault(signr, sicode, addr);\n}\nNOKPROBE_SYMBOL(do_trap);\n\nstatic void do_error_trap(struct pt_regs *regs, long error_code, char *str,\n\tunsigned long trapnr, int signr, int sicode, void __user *addr)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=\n\t\t\tNOTIFY_STOP) {\n\t\tcond_local_irq_enable(regs);\n\t\tdo_trap(trapnr, signr, str, regs, error_code, sicode, addr);\n\t\tcond_local_irq_disable(regs);\n\t}\n}\n\n \nstatic __always_inline void __user *error_get_trap_addr(struct pt_regs *regs)\n{\n\treturn (void __user *)uprobe_get_trap_addr(regs);\n}\n\nDEFINE_IDTENTRY(exc_divide_error)\n{\n\tdo_error_trap(regs, 0, \"divide error\", X86_TRAP_DE, SIGFPE,\n\t\t      FPE_INTDIV, error_get_trap_addr(regs));\n}\n\nDEFINE_IDTENTRY(exc_overflow)\n{\n\tdo_error_trap(regs, 0, \"overflow\", X86_TRAP_OF, SIGSEGV, 0, NULL);\n}\n\n#ifdef CONFIG_X86_F00F_BUG\nvoid handle_invalid_op(struct pt_regs *regs)\n#else\nstatic inline void handle_invalid_op(struct pt_regs *regs)\n#endif\n{\n\tdo_error_trap(regs, 0, \"invalid opcode\", X86_TRAP_UD, SIGILL,\n\t\t      ILL_ILLOPN, error_get_trap_addr(regs));\n}\n\nstatic noinstr bool handle_bug(struct pt_regs *regs)\n{\n\tbool handled = false;\n\n\t \n\tkmsan_unpoison_entry_regs(regs);\n\tif (!is_valid_bugaddr(regs->ip))\n\t\treturn handled;\n\n\t \n\tinstrumentation_begin();\n\t \n\tif (regs->flags & X86_EFLAGS_IF)\n\t\traw_local_irq_enable();\n\tif (report_bug(regs->ip, regs) == BUG_TRAP_TYPE_WARN ||\n\t    handle_cfi_failure(regs) == BUG_TRAP_TYPE_WARN) {\n\t\tregs->ip += LEN_UD2;\n\t\thandled = true;\n\t}\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\traw_local_irq_disable();\n\tinstrumentation_end();\n\n\treturn handled;\n}\n\nDEFINE_IDTENTRY_RAW(exc_invalid_op)\n{\n\tirqentry_state_t state;\n\n\t \n\tif (!user_mode(regs) && handle_bug(regs))\n\t\treturn;\n\n\tstate = irqentry_enter(regs);\n\tinstrumentation_begin();\n\thandle_invalid_op(regs);\n\tinstrumentation_end();\n\tirqentry_exit(regs, state);\n}\n\nDEFINE_IDTENTRY(exc_coproc_segment_overrun)\n{\n\tdo_error_trap(regs, 0, \"coprocessor segment overrun\",\n\t\t      X86_TRAP_OLD_MF, SIGFPE, 0, NULL);\n}\n\nDEFINE_IDTENTRY_ERRORCODE(exc_invalid_tss)\n{\n\tdo_error_trap(regs, error_code, \"invalid TSS\", X86_TRAP_TS, SIGSEGV,\n\t\t      0, NULL);\n}\n\nDEFINE_IDTENTRY_ERRORCODE(exc_segment_not_present)\n{\n\tdo_error_trap(regs, error_code, \"segment not present\", X86_TRAP_NP,\n\t\t      SIGBUS, 0, NULL);\n}\n\nDEFINE_IDTENTRY_ERRORCODE(exc_stack_segment)\n{\n\tdo_error_trap(regs, error_code, \"stack segment\", X86_TRAP_SS, SIGBUS,\n\t\t      0, NULL);\n}\n\nDEFINE_IDTENTRY_ERRORCODE(exc_alignment_check)\n{\n\tchar *str = \"alignment check\";\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_AC, SIGBUS) == NOTIFY_STOP)\n\t\treturn;\n\n\tif (!user_mode(regs))\n\t\tdie(\"Split lock detected\\n\", regs, error_code);\n\n\tlocal_irq_enable();\n\n\tif (handle_user_split_lock(regs, error_code))\n\t\tgoto out;\n\n\tdo_trap(X86_TRAP_AC, SIGBUS, \"alignment check\", regs,\n\t\terror_code, BUS_ADRALN, NULL);\n\nout:\n\tlocal_irq_disable();\n}\n\n#ifdef CONFIG_VMAP_STACK\n__visible void __noreturn handle_stack_overflow(struct pt_regs *regs,\n\t\t\t\t\t\tunsigned long fault_address,\n\t\t\t\t\t\tstruct stack_info *info)\n{\n\tconst char *name = stack_type_name(info->type);\n\n\tprintk(KERN_EMERG \"BUG: %s stack guard page was hit at %p (stack is %p..%p)\\n\",\n\t       name, (void *)fault_address, info->begin, info->end);\n\n\tdie(\"stack guard page\", regs, 0);\n\n\t \n\tpanic(\"%s stack guard hit\", name);\n}\n#endif\n\n \nDEFINE_IDTENTRY_DF(exc_double_fault)\n{\n\tstatic const char str[] = \"double fault\";\n\tstruct task_struct *tsk = current;\n\n#ifdef CONFIG_VMAP_STACK\n\tunsigned long address = read_cr2();\n\tstruct stack_info info;\n#endif\n\n#ifdef CONFIG_X86_ESPFIX64\n\textern unsigned char native_irq_return_iret[];\n\n\t \n\tif (((long)regs->sp >> P4D_SHIFT) == ESPFIX_PGD_ENTRY &&\n\t\tregs->cs == __KERNEL_CS &&\n\t\tregs->ip == (unsigned long)native_irq_return_iret)\n\t{\n\t\tstruct pt_regs *gpregs = (struct pt_regs *)this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\t\tunsigned long *p = (unsigned long *)regs->sp;\n\n\t\t \n\t\tgpregs->ip\t= p[0];\n\t\tgpregs->cs\t= p[1];\n\t\tgpregs->flags\t= p[2];\n\t\tgpregs->sp\t= p[3];\n\t\tgpregs->ss\t= p[4];\n\t\tgpregs->orig_ax = 0;   \n\n\t\t \n\t\tregs->ip = (unsigned long)asm_exc_general_protection;\n\t\tregs->sp = (unsigned long)&gpregs->orig_ax;\n\n\t\treturn;\n\t}\n#endif\n\n\tirqentry_nmi_enter(regs);\n\tinstrumentation_begin();\n\tnotify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_DF, SIGSEGV);\n\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_DF;\n\n#ifdef CONFIG_VMAP_STACK\n\t \n\tif (get_stack_guard_info((void *)address, &info))\n\t\thandle_stack_overflow(regs, address, &info);\n#endif\n\n\tpr_emerg(\"PANIC: double fault, error_code: 0x%lx\\n\", error_code);\n\tdie(\"double fault\", regs, error_code);\n\tpanic(\"Machine halted.\");\n\tinstrumentation_end();\n}\n\nDEFINE_IDTENTRY(exc_bounds)\n{\n\tif (notify_die(DIE_TRAP, \"bounds\", regs, 0,\n\t\t\tX86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs))\n\t\tdie(\"bounds\", regs, 0);\n\n\tdo_trap(X86_TRAP_BR, SIGSEGV, \"bounds\", regs, 0, 0, NULL);\n\n\tcond_local_irq_disable(regs);\n}\n\nenum kernel_gp_hint {\n\tGP_NO_HINT,\n\tGP_NON_CANONICAL,\n\tGP_CANONICAL\n};\n\n \nstatic enum kernel_gp_hint get_kernel_gp_address(struct pt_regs *regs,\n\t\t\t\t\t\t unsigned long *addr)\n{\n\tu8 insn_buf[MAX_INSN_SIZE];\n\tstruct insn insn;\n\tint ret;\n\n\tif (copy_from_kernel_nofault(insn_buf, (void *)regs->ip,\n\t\t\tMAX_INSN_SIZE))\n\t\treturn GP_NO_HINT;\n\n\tret = insn_decode_kernel(&insn, insn_buf);\n\tif (ret < 0)\n\t\treturn GP_NO_HINT;\n\n\t*addr = (unsigned long)insn_get_addr_ref(&insn, regs);\n\tif (*addr == -1UL)\n\t\treturn GP_NO_HINT;\n\n#ifdef CONFIG_X86_64\n\t \n\tif (*addr < ~__VIRTUAL_MASK &&\n\t    *addr + insn.opnd_bytes - 1 > __VIRTUAL_MASK)\n\t\treturn GP_NON_CANONICAL;\n#endif\n\n\treturn GP_CANONICAL;\n}\n\n#define GPFSTR \"general protection fault\"\n\nstatic bool fixup_iopl_exception(struct pt_regs *regs)\n{\n\tstruct thread_struct *t = &current->thread;\n\tunsigned char byte;\n\tunsigned long ip;\n\n\tif (!IS_ENABLED(CONFIG_X86_IOPL_IOPERM) || t->iopl_emul != 3)\n\t\treturn false;\n\n\tif (insn_get_effective_ip(regs, &ip))\n\t\treturn false;\n\n\tif (get_user(byte, (const char __user *)ip))\n\t\treturn false;\n\n\tif (byte != 0xfa && byte != 0xfb)\n\t\treturn false;\n\n\tif (!t->iopl_warn && printk_ratelimit()) {\n\t\tpr_err(\"%s[%d] attempts to use CLI/STI, pretending it's a NOP, ip:%lx\",\n\t\t       current->comm, task_pid_nr(current), ip);\n\t\tprint_vma_addr(KERN_CONT \" in \", ip);\n\t\tpr_cont(\"\\n\");\n\t\tt->iopl_warn = 1;\n\t}\n\n\tregs->ip += 1;\n\treturn true;\n}\n\n \nstatic bool try_fixup_enqcmd_gp(void)\n{\n#ifdef CONFIG_IOMMU_SVA\n\tu32 pasid;\n\n\t \n\tlockdep_assert_irqs_disabled();\n\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_ENQCMD))\n\t\treturn false;\n\n\t \n\tif (!mm_valid_pasid(current->mm))\n\t\treturn false;\n\n\tpasid = current->mm->pasid;\n\n\t \n\tif (current->pasid_activated)\n\t\treturn false;\n\n\twrmsrl(MSR_IA32_PASID, pasid | MSR_IA32_PASID_VALID);\n\tcurrent->pasid_activated = 1;\n\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic bool gp_try_fixup_and_notify(struct pt_regs *regs, int trapnr,\n\t\t\t\t    unsigned long error_code, const char *str,\n\t\t\t\t    unsigned long address)\n{\n\tif (fixup_exception(regs, trapnr, error_code, address))\n\t\treturn true;\n\n\tcurrent->thread.error_code = error_code;\n\tcurrent->thread.trap_nr = trapnr;\n\n\t \n\tif (!preemptible() && kprobe_running() &&\n\t    kprobe_fault_handler(regs, trapnr))\n\t\treturn true;\n\n\treturn notify_die(DIE_GPF, str, regs, error_code, trapnr, SIGSEGV) == NOTIFY_STOP;\n}\n\nstatic void gp_user_force_sig_segv(struct pt_regs *regs, int trapnr,\n\t\t\t\t   unsigned long error_code, const char *str)\n{\n\tcurrent->thread.error_code = error_code;\n\tcurrent->thread.trap_nr = trapnr;\n\tshow_signal(current, SIGSEGV, \"\", str, regs, error_code);\n\tforce_sig(SIGSEGV);\n}\n\nDEFINE_IDTENTRY_ERRORCODE(exc_general_protection)\n{\n\tchar desc[sizeof(GPFSTR) + 50 + 2*sizeof(unsigned long) + 1] = GPFSTR;\n\tenum kernel_gp_hint hint = GP_NO_HINT;\n\tunsigned long gp_addr;\n\n\tif (user_mode(regs) && try_fixup_enqcmd_gp())\n\t\treturn;\n\n\tcond_local_irq_enable(regs);\n\n\tif (static_cpu_has(X86_FEATURE_UMIP)) {\n\t\tif (user_mode(regs) && fixup_umip_exception(regs))\n\t\t\tgoto exit;\n\t}\n\n\tif (v8086_mode(regs)) {\n\t\tlocal_irq_enable();\n\t\thandle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);\n\t\tlocal_irq_disable();\n\t\treturn;\n\t}\n\n\tif (user_mode(regs)) {\n\t\tif (fixup_iopl_exception(regs))\n\t\t\tgoto exit;\n\n\t\tif (fixup_vdso_exception(regs, X86_TRAP_GP, error_code, 0))\n\t\t\tgoto exit;\n\n\t\tgp_user_force_sig_segv(regs, X86_TRAP_GP, error_code, desc);\n\t\tgoto exit;\n\t}\n\n\tif (gp_try_fixup_and_notify(regs, X86_TRAP_GP, error_code, desc, 0))\n\t\tgoto exit;\n\n\tif (error_code)\n\t\tsnprintf(desc, sizeof(desc), \"segment-related \" GPFSTR);\n\telse\n\t\thint = get_kernel_gp_address(regs, &gp_addr);\n\n\tif (hint != GP_NO_HINT)\n\t\tsnprintf(desc, sizeof(desc), GPFSTR \", %s 0x%lx\",\n\t\t\t (hint == GP_NON_CANONICAL) ? \"probably for non-canonical address\"\n\t\t\t\t\t\t    : \"maybe for address\",\n\t\t\t gp_addr);\n\n\t \n\tif (hint != GP_NON_CANONICAL)\n\t\tgp_addr = 0;\n\n\tdie_addr(desc, regs, error_code, gp_addr);\n\nexit:\n\tcond_local_irq_disable(regs);\n}\n\nstatic bool do_int3(struct pt_regs *regs)\n{\n\tint res;\n\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, 0, X86_TRAP_BP,\n\t\t\t SIGTRAP) == NOTIFY_STOP)\n\t\treturn true;\n#endif  \n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\treturn true;\n#endif\n\tres = notify_die(DIE_INT3, \"int3\", regs, 0, X86_TRAP_BP, SIGTRAP);\n\n\treturn res == NOTIFY_STOP;\n}\nNOKPROBE_SYMBOL(do_int3);\n\nstatic void do_int3_user(struct pt_regs *regs)\n{\n\tif (do_int3(regs))\n\t\treturn;\n\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, 0, 0, NULL);\n\tcond_local_irq_disable(regs);\n}\n\nDEFINE_IDTENTRY_RAW(exc_int3)\n{\n\t \n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\t \n\tif (user_mode(regs)) {\n\t\tirqentry_enter_from_user_mode(regs);\n\t\tinstrumentation_begin();\n\t\tdo_int3_user(regs);\n\t\tinstrumentation_end();\n\t\tirqentry_exit_to_user_mode(regs);\n\t} else {\n\t\tirqentry_state_t irq_state = irqentry_nmi_enter(regs);\n\n\t\tinstrumentation_begin();\n\t\tif (!do_int3(regs))\n\t\t\tdie(\"int3\", regs, 0);\n\t\tinstrumentation_end();\n\t\tirqentry_nmi_exit(regs, irq_state);\n\t}\n}\n\n#ifdef CONFIG_X86_64\n \nasmlinkage __visible noinstr struct pt_regs *sync_regs(struct pt_regs *eregs)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)this_cpu_read(pcpu_hot.top_of_stack) - 1;\n\tif (regs != eregs)\n\t\t*regs = *eregs;\n\treturn regs;\n}\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nasmlinkage __visible noinstr struct pt_regs *vc_switch_off_ist(struct pt_regs *regs)\n{\n\tunsigned long sp, *stack;\n\tstruct stack_info info;\n\tstruct pt_regs *regs_ret;\n\n\t \n\tif (ip_within_syscall_gap(regs)) {\n\t\tsp = this_cpu_read(pcpu_hot.top_of_stack);\n\t\tgoto sync;\n\t}\n\n\t \n\tsp    = regs->sp;\n\tstack = (unsigned long *)sp;\n\n\tif (!get_stack_info_noinstr(stack, current, &info) || info.type == STACK_TYPE_ENTRY ||\n\t    info.type > STACK_TYPE_EXCEPTION_LAST)\n\t\tsp = __this_cpu_ist_top_va(VC2);\n\nsync:\n\t \n\tsp = ALIGN_DOWN(sp, 8) - sizeof(*regs_ret);\n\n\tregs_ret = (struct pt_regs *)sp;\n\t*regs_ret = *regs;\n\n\treturn regs_ret;\n}\n#endif\n\nasmlinkage __visible noinstr struct pt_regs *fixup_bad_iret(struct pt_regs *bad_regs)\n{\n\tstruct pt_regs tmp, *new_stack;\n\n\t \n\tnew_stack = (struct pt_regs *)__this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\n\t \n\t__memcpy(&tmp.ip, (void *)bad_regs->sp, 5*8);\n\n\t \n\t__memcpy(&tmp, bad_regs, offsetof(struct pt_regs, ip));\n\n\t \n\t__memcpy(new_stack, &tmp, sizeof(tmp));\n\n\tBUG_ON(!user_mode(new_stack));\n\treturn new_stack;\n}\n#endif\n\nstatic bool is_sysenter_singlestep(struct pt_regs *regs)\n{\n\t \n#ifdef CONFIG_X86_32\n\treturn (regs->ip - (unsigned long)__begin_SYSENTER_singlestep_region) <\n\t\t(unsigned long)__end_SYSENTER_singlestep_region -\n\t\t(unsigned long)__begin_SYSENTER_singlestep_region;\n#elif defined(CONFIG_IA32_EMULATION)\n\treturn (regs->ip - (unsigned long)entry_SYSENTER_compat) <\n\t\t(unsigned long)__end_entry_SYSENTER_compat -\n\t\t(unsigned long)entry_SYSENTER_compat;\n#else\n\treturn false;\n#endif\n}\n\nstatic __always_inline unsigned long debug_read_clear_dr6(void)\n{\n\tunsigned long dr6;\n\n\t \n\tget_debugreg(dr6, 6);\n\tset_debugreg(DR6_RESERVED, 6);\n\tdr6 ^= DR6_RESERVED;  \n\n\treturn dr6;\n}\n\n \n\nstatic bool notify_debug(struct pt_regs *regs, unsigned long *dr6)\n{\n\t \n\tif (notify_die(DIE_DEBUG, \"debug\", regs, (long)dr6, 0, SIGTRAP) == NOTIFY_STOP)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic __always_inline void exc_debug_kernel(struct pt_regs *regs,\n\t\t\t\t\t     unsigned long dr6)\n{\n\t \n\tunsigned long dr7 = local_db_save();\n\tirqentry_state_t irq_state = irqentry_nmi_enter(regs);\n\tinstrumentation_begin();\n\n\t \n\tWARN_ON_ONCE(user_mode(regs));\n\n\tif (test_thread_flag(TIF_BLOCKSTEP)) {\n\t\t \n\t\tunsigned long debugctl;\n\n\t\trdmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\twrmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);\n\t}\n\n\t \n\tif ((dr6 & DR_STEP) && is_sysenter_singlestep(regs))\n\t\tdr6 &= ~DR_STEP;\n\n\t \n\tif (!dr6)\n\t\tgoto out;\n\n\tif (notify_debug(regs, &dr6))\n\t\tgoto out;\n\n\t \n\tif (WARN_ON_ONCE(dr6 & DR_STEP))\n\t\tregs->flags &= ~X86_EFLAGS_TF;\nout:\n\tinstrumentation_end();\n\tirqentry_nmi_exit(regs, irq_state);\n\n\tlocal_db_restore(dr7);\n}\n\nstatic __always_inline void exc_debug_user(struct pt_regs *regs,\n\t\t\t\t\t   unsigned long dr6)\n{\n\tbool icebp;\n\n\t \n\tWARN_ON_ONCE(!user_mode(regs));\n\n\t \n\n\tirqentry_enter_from_user_mode(regs);\n\tinstrumentation_begin();\n\n\t \n\tcurrent->thread.virtual_dr6 = (dr6 & DR_STEP);\n\n\t \n\tclear_thread_flag(TIF_BLOCKSTEP);\n\n\t \n\ticebp = !dr6;\n\n\tif (notify_debug(regs, &dr6))\n\t\tgoto out;\n\n\t \n\tlocal_irq_enable();\n\n\tif (v8086_mode(regs)) {\n\t\thandle_vm86_trap((struct kernel_vm86_regs *)regs, 0, X86_TRAP_DB);\n\t\tgoto out_irq;\n\t}\n\n\t \n\tif (dr6 & DR_BUS_LOCK)\n\t\thandle_bus_lock(regs);\n\n\t \n\tdr6 |= current->thread.virtual_dr6;\n\tif (dr6 & (DR_STEP | DR_TRAP_BITS) || icebp)\n\t\tsend_sigtrap(regs, 0, get_si_code(dr6));\n\nout_irq:\n\tlocal_irq_disable();\nout:\n\tinstrumentation_end();\n\tirqentry_exit_to_user_mode(regs);\n}\n\n#ifdef CONFIG_X86_64\n \nDEFINE_IDTENTRY_DEBUG(exc_debug)\n{\n\texc_debug_kernel(regs, debug_read_clear_dr6());\n}\n\n \nDEFINE_IDTENTRY_DEBUG_USER(exc_debug)\n{\n\texc_debug_user(regs, debug_read_clear_dr6());\n}\n#else\n \nDEFINE_IDTENTRY_RAW(exc_debug)\n{\n\tunsigned long dr6 = debug_read_clear_dr6();\n\n\tif (user_mode(regs))\n\t\texc_debug_user(regs, dr6);\n\telse\n\t\texc_debug_kernel(regs, dr6);\n}\n#endif\n\n \nstatic void math_error(struct pt_regs *regs, int trapnr)\n{\n\tstruct task_struct *task = current;\n\tstruct fpu *fpu = &task->thread.fpu;\n\tint si_code;\n\tchar *str = (trapnr == X86_TRAP_MF) ? \"fpu exception\" :\n\t\t\t\t\t\t\"simd exception\";\n\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, trapnr, 0, 0))\n\t\t\tgoto exit;\n\n\t\ttask->thread.error_code = 0;\n\t\ttask->thread.trap_nr = trapnr;\n\n\t\tif (notify_die(DIE_TRAP, str, regs, 0, trapnr,\n\t\t\t       SIGFPE) != NOTIFY_STOP)\n\t\t\tdie(str, regs, 0);\n\t\tgoto exit;\n\t}\n\n\t \n\tfpu_sync_fpstate(fpu);\n\n\ttask->thread.trap_nr\t= trapnr;\n\ttask->thread.error_code = 0;\n\n\tsi_code = fpu__exception_code(fpu, trapnr);\n\t \n\tif (!si_code)\n\t\tgoto exit;\n\n\tif (fixup_vdso_exception(regs, trapnr, 0, 0))\n\t\tgoto exit;\n\n\tforce_sig_fault(SIGFPE, si_code,\n\t\t\t(void __user *)uprobe_get_trap_addr(regs));\nexit:\n\tcond_local_irq_disable(regs);\n}\n\nDEFINE_IDTENTRY(exc_coprocessor_error)\n{\n\tmath_error(regs, X86_TRAP_MF);\n}\n\nDEFINE_IDTENTRY(exc_simd_coprocessor_error)\n{\n\tif (IS_ENABLED(CONFIG_X86_INVD_BUG)) {\n\t\t \n\t\tif (!static_cpu_has(X86_FEATURE_XMM)) {\n\t\t\t__exc_general_protection(regs, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\tmath_error(regs, X86_TRAP_XF);\n}\n\nDEFINE_IDTENTRY(exc_spurious_interrupt_bug)\n{\n\t \n}\n\nstatic bool handle_xfd_event(struct pt_regs *regs)\n{\n\tu64 xfd_err;\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_X86_64) || !cpu_feature_enabled(X86_FEATURE_XFD))\n\t\treturn false;\n\n\trdmsrl(MSR_IA32_XFD_ERR, xfd_err);\n\tif (!xfd_err)\n\t\treturn false;\n\n\twrmsrl(MSR_IA32_XFD_ERR, 0);\n\n\t \n\tif (WARN_ON(!user_mode(regs)))\n\t\treturn false;\n\n\tlocal_irq_enable();\n\n\terr = xfd_enable_feature(xfd_err);\n\n\tswitch (err) {\n\tcase -EPERM:\n\t\tforce_sig_fault(SIGILL, ILL_ILLOPC, error_get_trap_addr(regs));\n\t\tbreak;\n\tcase -EFAULT:\n\t\tforce_sig(SIGSEGV);\n\t\tbreak;\n\t}\n\n\tlocal_irq_disable();\n\treturn true;\n}\n\nDEFINE_IDTENTRY(exc_device_not_available)\n{\n\tunsigned long cr0 = read_cr0();\n\n\tif (handle_xfd_event(regs))\n\t\treturn;\n\n#ifdef CONFIG_MATH_EMULATION\n\tif (!boot_cpu_has(X86_FEATURE_FPU) && (cr0 & X86_CR0_EM)) {\n\t\tstruct math_emu_info info = { };\n\n\t\tcond_local_irq_enable(regs);\n\n\t\tinfo.regs = regs;\n\t\tmath_emulate(&info);\n\n\t\tcond_local_irq_disable(regs);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tif (WARN(cr0 & X86_CR0_TS, \"CR0.TS was set\")) {\n\t\t \n\t\twrite_cr0(cr0 & ~X86_CR0_TS);\n\t} else {\n\t\t \n\t\tdie(\"unexpected #NM exception\", regs, 0);\n\t}\n}\n\n#ifdef CONFIG_INTEL_TDX_GUEST\n\n#define VE_FAULT_STR \"VE fault\"\n\nstatic void ve_raise_fault(struct pt_regs *regs, long error_code,\n\t\t\t   unsigned long address)\n{\n\tif (user_mode(regs)) {\n\t\tgp_user_force_sig_segv(regs, X86_TRAP_VE, error_code, VE_FAULT_STR);\n\t\treturn;\n\t}\n\n\tif (gp_try_fixup_and_notify(regs, X86_TRAP_VE, error_code,\n\t\t\t\t    VE_FAULT_STR, address)) {\n\t\treturn;\n\t}\n\n\tdie_addr(VE_FAULT_STR, regs, error_code, address);\n}\n\n \nDEFINE_IDTENTRY(exc_virtualization_exception)\n{\n\tstruct ve_info ve;\n\n\t \n\ttdx_get_ve_info(&ve);\n\n\tcond_local_irq_enable(regs);\n\n\t \n\tif (!tdx_handle_virt_exception(regs, &ve))\n\t\tve_raise_fault(regs, 0, ve.gla);\n\n\tcond_local_irq_disable(regs);\n}\n\n#endif\n\n#ifdef CONFIG_X86_32\nDEFINE_IDTENTRY_SW(iret_error)\n{\n\tlocal_irq_enable();\n\tif (notify_die(DIE_TRAP, \"iret exception\", regs, 0,\n\t\t\tX86_TRAP_IRET, SIGILL) != NOTIFY_STOP) {\n\t\tdo_trap(X86_TRAP_IRET, SIGILL, \"iret exception\", regs, 0,\n\t\t\tILL_BADSTK, (void __user *)NULL);\n\t}\n\tlocal_irq_disable();\n}\n#endif\n\nvoid __init trap_init(void)\n{\n\t \n\tsetup_cpu_entry_areas();\n\n\t \n\tsev_es_init_vc_handling();\n\n\t \n\tcpu_init_exception_handling();\n\t \n\tidt_setup_traps();\n\tcpu_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}