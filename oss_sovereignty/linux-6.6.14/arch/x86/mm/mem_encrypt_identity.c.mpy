{
  "module_name": "mem_encrypt_identity.c",
  "hash_id": "0c3abfb49450548379595795bee6b3a039db73bfb6a6a06b342c954e52a18086",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/mem_encrypt_identity.c",
  "human_readable_source": "\n \n\n#define DISABLE_BRANCH_PROFILING\n\n \n#define __pa(x)  ((unsigned long)(x))\n#define __va(x)  ((void *)((unsigned long)(x)))\n\n \n#undef CONFIG_PARAVIRT\n#undef CONFIG_PARAVIRT_XXL\n#undef CONFIG_PARAVIRT_SPINLOCKS\n\n \n#define USE_EARLY_PGTABLE_L5\n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/cc_platform.h>\n\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <asm/cmdline.h>\n#include <asm/coco.h>\n#include <asm/sev.h>\n\n#include \"mm_internal.h\"\n\n#define PGD_FLAGS\t\t_KERNPG_TABLE_NOENC\n#define P4D_FLAGS\t\t_KERNPG_TABLE_NOENC\n#define PUD_FLAGS\t\t_KERNPG_TABLE_NOENC\n#define PMD_FLAGS\t\t_KERNPG_TABLE_NOENC\n\n#define PMD_FLAGS_LARGE\t\t(__PAGE_KERNEL_LARGE_EXEC & ~_PAGE_GLOBAL)\n\n#define PMD_FLAGS_DEC\t\tPMD_FLAGS_LARGE\n#define PMD_FLAGS_DEC_WP\t((PMD_FLAGS_DEC & ~_PAGE_LARGE_CACHE_MASK) | \\\n\t\t\t\t (_PAGE_PAT_LARGE | _PAGE_PWT))\n\n#define PMD_FLAGS_ENC\t\t(PMD_FLAGS_LARGE | _PAGE_ENC)\n\n#define PTE_FLAGS\t\t(__PAGE_KERNEL_EXEC & ~_PAGE_GLOBAL)\n\n#define PTE_FLAGS_DEC\t\tPTE_FLAGS\n#define PTE_FLAGS_DEC_WP\t((PTE_FLAGS_DEC & ~_PAGE_CACHE_MASK) | \\\n\t\t\t\t (_PAGE_PAT | _PAGE_PWT))\n\n#define PTE_FLAGS_ENC\t\t(PTE_FLAGS | _PAGE_ENC)\n\nstruct sme_populate_pgd_data {\n\tvoid    *pgtable_area;\n\tpgd_t   *pgd;\n\n\tpmdval_t pmd_flags;\n\tpteval_t pte_flags;\n\tunsigned long paddr;\n\n\tunsigned long vaddr;\n\tunsigned long vaddr_end;\n};\n\n \nstatic char sme_workarea[2 * PMD_SIZE] __section(\".init.scratch\");\n\nstatic char sme_cmdline_arg[] __initdata = \"mem_encrypt\";\nstatic char sme_cmdline_on[]  __initdata = \"on\";\nstatic char sme_cmdline_off[] __initdata = \"off\";\n\nstatic void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)\n{\n\tunsigned long pgd_start, pgd_end, pgd_size;\n\tpgd_t *pgd_p;\n\n\tpgd_start = ppd->vaddr & PGDIR_MASK;\n\tpgd_end = ppd->vaddr_end & PGDIR_MASK;\n\n\tpgd_size = (((pgd_end - pgd_start) / PGDIR_SIZE) + 1) * sizeof(pgd_t);\n\n\tpgd_p = ppd->pgd + pgd_index(ppd->vaddr);\n\n\tmemset(pgd_p, 0, pgd_size);\n}\n\nstatic pud_t __init *sme_prepare_pgd(struct sme_populate_pgd_data *ppd)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = ppd->pgd + pgd_index(ppd->vaddr);\n\tif (pgd_none(*pgd)) {\n\t\tp4d = ppd->pgtable_area;\n\t\tmemset(p4d, 0, sizeof(*p4d) * PTRS_PER_P4D);\n\t\tppd->pgtable_area += sizeof(*p4d) * PTRS_PER_P4D;\n\t\tset_pgd(pgd, __pgd(PGD_FLAGS | __pa(p4d)));\n\t}\n\n\tp4d = p4d_offset(pgd, ppd->vaddr);\n\tif (p4d_none(*p4d)) {\n\t\tpud = ppd->pgtable_area;\n\t\tmemset(pud, 0, sizeof(*pud) * PTRS_PER_PUD);\n\t\tppd->pgtable_area += sizeof(*pud) * PTRS_PER_PUD;\n\t\tset_p4d(p4d, __p4d(P4D_FLAGS | __pa(pud)));\n\t}\n\n\tpud = pud_offset(p4d, ppd->vaddr);\n\tif (pud_none(*pud)) {\n\t\tpmd = ppd->pgtable_area;\n\t\tmemset(pmd, 0, sizeof(*pmd) * PTRS_PER_PMD);\n\t\tppd->pgtable_area += sizeof(*pmd) * PTRS_PER_PMD;\n\t\tset_pud(pud, __pud(PUD_FLAGS | __pa(pmd)));\n\t}\n\n\tif (pud_large(*pud))\n\t\treturn NULL;\n\n\treturn pud;\n}\n\nstatic void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd)\n{\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpud = sme_prepare_pgd(ppd);\n\tif (!pud)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, ppd->vaddr);\n\tif (pmd_large(*pmd))\n\t\treturn;\n\n\tset_pmd(pmd, __pmd(ppd->paddr | ppd->pmd_flags));\n}\n\nstatic void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd)\n{\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpud = sme_prepare_pgd(ppd);\n\tif (!pud)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, ppd->vaddr);\n\tif (pmd_none(*pmd)) {\n\t\tpte = ppd->pgtable_area;\n\t\tmemset(pte, 0, sizeof(*pte) * PTRS_PER_PTE);\n\t\tppd->pgtable_area += sizeof(*pte) * PTRS_PER_PTE;\n\t\tset_pmd(pmd, __pmd(PMD_FLAGS | __pa(pte)));\n\t}\n\n\tif (pmd_large(*pmd))\n\t\treturn;\n\n\tpte = pte_offset_kernel(pmd, ppd->vaddr);\n\tif (pte_none(*pte))\n\t\tset_pte(pte, __pte(ppd->paddr | ppd->pte_flags));\n}\n\nstatic void __init __sme_map_range_pmd(struct sme_populate_pgd_data *ppd)\n{\n\twhile (ppd->vaddr < ppd->vaddr_end) {\n\t\tsme_populate_pgd_large(ppd);\n\n\t\tppd->vaddr += PMD_SIZE;\n\t\tppd->paddr += PMD_SIZE;\n\t}\n}\n\nstatic void __init __sme_map_range_pte(struct sme_populate_pgd_data *ppd)\n{\n\twhile (ppd->vaddr < ppd->vaddr_end) {\n\t\tsme_populate_pgd(ppd);\n\n\t\tppd->vaddr += PAGE_SIZE;\n\t\tppd->paddr += PAGE_SIZE;\n\t}\n}\n\nstatic void __init __sme_map_range(struct sme_populate_pgd_data *ppd,\n\t\t\t\t   pmdval_t pmd_flags, pteval_t pte_flags)\n{\n\tunsigned long vaddr_end;\n\n\tppd->pmd_flags = pmd_flags;\n\tppd->pte_flags = pte_flags;\n\n\t \n\tvaddr_end = ppd->vaddr_end;\n\n\t \n\tppd->vaddr_end = ALIGN(ppd->vaddr, PMD_SIZE);\n\t__sme_map_range_pte(ppd);\n\n\t \n\tppd->vaddr_end = vaddr_end & PMD_MASK;\n\t__sme_map_range_pmd(ppd);\n\n\t \n\tppd->vaddr_end = vaddr_end;\n\t__sme_map_range_pte(ppd);\n}\n\nstatic void __init sme_map_range_encrypted(struct sme_populate_pgd_data *ppd)\n{\n\t__sme_map_range(ppd, PMD_FLAGS_ENC, PTE_FLAGS_ENC);\n}\n\nstatic void __init sme_map_range_decrypted(struct sme_populate_pgd_data *ppd)\n{\n\t__sme_map_range(ppd, PMD_FLAGS_DEC, PTE_FLAGS_DEC);\n}\n\nstatic void __init sme_map_range_decrypted_wp(struct sme_populate_pgd_data *ppd)\n{\n\t__sme_map_range(ppd, PMD_FLAGS_DEC_WP, PTE_FLAGS_DEC_WP);\n}\n\nstatic unsigned long __init sme_pgtable_calc(unsigned long len)\n{\n\tunsigned long entries = 0, tables = 0;\n\n\t \n\n\t \n\tif (PTRS_PER_P4D > 1)\n\t\tentries += (DIV_ROUND_UP(len, PGDIR_SIZE) + 1) * sizeof(p4d_t) * PTRS_PER_P4D;\n\tentries += (DIV_ROUND_UP(len, P4D_SIZE) + 1) * sizeof(pud_t) * PTRS_PER_PUD;\n\tentries += (DIV_ROUND_UP(len, PUD_SIZE) + 1) * sizeof(pmd_t) * PTRS_PER_PMD;\n\tentries += 2 * sizeof(pte_t) * PTRS_PER_PTE;\n\n\t \n\n\tif (PTRS_PER_P4D > 1)\n\t\ttables += DIV_ROUND_UP(entries, PGDIR_SIZE) * sizeof(p4d_t) * PTRS_PER_P4D;\n\ttables += DIV_ROUND_UP(entries, P4D_SIZE) * sizeof(pud_t) * PTRS_PER_PUD;\n\ttables += DIV_ROUND_UP(entries, PUD_SIZE) * sizeof(pmd_t) * PTRS_PER_PMD;\n\n\treturn entries + tables;\n}\n\nvoid __init sme_encrypt_kernel(struct boot_params *bp)\n{\n\tunsigned long workarea_start, workarea_end, workarea_len;\n\tunsigned long execute_start, execute_end, execute_len;\n\tunsigned long kernel_start, kernel_end, kernel_len;\n\tunsigned long initrd_start, initrd_end, initrd_len;\n\tstruct sme_populate_pgd_data ppd;\n\tunsigned long pgtable_area_len;\n\tunsigned long decrypted_base;\n\n\t \n\tif (!sme_get_me_mask() || sev_status & MSR_AMD64_SEV_ENABLED)\n\t\treturn;\n\n\t \n\n\t \n\tkernel_start = __pa_symbol(_text);\n\tkernel_end = ALIGN(__pa_symbol(_end), PMD_SIZE);\n\tkernel_len = kernel_end - kernel_start;\n\n\tinitrd_start = 0;\n\tinitrd_end = 0;\n\tinitrd_len = 0;\n#ifdef CONFIG_BLK_DEV_INITRD\n\tinitrd_len = (unsigned long)bp->hdr.ramdisk_size |\n\t\t     ((unsigned long)bp->ext_ramdisk_size << 32);\n\tif (initrd_len) {\n\t\tinitrd_start = (unsigned long)bp->hdr.ramdisk_image |\n\t\t\t       ((unsigned long)bp->ext_ramdisk_image << 32);\n\t\tinitrd_end = PAGE_ALIGN(initrd_start + initrd_len);\n\t\tinitrd_len = initrd_end - initrd_start;\n\t}\n#endif\n\n\t \n\tasm (\"lea sme_workarea(%%rip), %0\"\n\t     : \"=r\" (workarea_start)\n\t     : \"p\" (sme_workarea));\n\n\t \n\texecute_start = workarea_start;\n\texecute_end = execute_start + (PAGE_SIZE * 2) + PMD_SIZE;\n\texecute_len = execute_end - execute_start;\n\n\t \n\tpgtable_area_len = sizeof(pgd_t) * PTRS_PER_PGD;\n\tpgtable_area_len += sme_pgtable_calc(execute_end - kernel_start) * 2;\n\tif (initrd_len)\n\t\tpgtable_area_len += sme_pgtable_calc(initrd_len) * 2;\n\n\t \n\tpgtable_area_len += sme_pgtable_calc(execute_len + pgtable_area_len);\n\n\t \n\tworkarea_len = execute_len + pgtable_area_len;\n\tworkarea_end = ALIGN(workarea_start + workarea_len, PMD_SIZE);\n\n\t \n\tppd.pgtable_area = (void *)execute_end;\n\n\t \n\tppd.pgd = (pgd_t *)native_read_cr3_pa();\n\tppd.paddr = workarea_start;\n\tppd.vaddr = workarea_start;\n\tppd.vaddr_end = workarea_end;\n\tsme_map_range_decrypted(&ppd);\n\n\t \n\tnative_write_cr3(__native_read_cr3());\n\n\t \n\tppd.pgd = ppd.pgtable_area;\n\tmemset(ppd.pgd, 0, sizeof(pgd_t) * PTRS_PER_PGD);\n\tppd.pgtable_area += sizeof(pgd_t) * PTRS_PER_PGD;\n\n\t \n\tdecrypted_base = (pgd_index(workarea_end) + 1) & (PTRS_PER_PGD - 1);\n\tif (initrd_len) {\n\t\tunsigned long check_base;\n\n\t\tcheck_base = (pgd_index(initrd_end) + 1) & (PTRS_PER_PGD - 1);\n\t\tdecrypted_base = max(decrypted_base, check_base);\n\t}\n\tdecrypted_base <<= PGDIR_SHIFT;\n\n\t \n\tppd.paddr = kernel_start;\n\tppd.vaddr = kernel_start;\n\tppd.vaddr_end = kernel_end;\n\tsme_map_range_encrypted(&ppd);\n\n\t \n\tppd.paddr = kernel_start;\n\tppd.vaddr = kernel_start + decrypted_base;\n\tppd.vaddr_end = kernel_end + decrypted_base;\n\tsme_map_range_decrypted_wp(&ppd);\n\n\tif (initrd_len) {\n\t\t \n\t\tppd.paddr = initrd_start;\n\t\tppd.vaddr = initrd_start;\n\t\tppd.vaddr_end = initrd_end;\n\t\tsme_map_range_encrypted(&ppd);\n\t\t \n\t\tppd.paddr = initrd_start;\n\t\tppd.vaddr = initrd_start + decrypted_base;\n\t\tppd.vaddr_end = initrd_end + decrypted_base;\n\t\tsme_map_range_decrypted_wp(&ppd);\n\t}\n\n\t \n\tppd.paddr = workarea_start;\n\tppd.vaddr = workarea_start;\n\tppd.vaddr_end = workarea_end;\n\tsme_map_range_decrypted(&ppd);\n\n\tppd.paddr = workarea_start;\n\tppd.vaddr = workarea_start + decrypted_base;\n\tppd.vaddr_end = workarea_end + decrypted_base;\n\tsme_map_range_decrypted(&ppd);\n\n\t \n\tsme_encrypt_execute(kernel_start, kernel_start + decrypted_base,\n\t\t\t    kernel_len, workarea_start, (unsigned long)ppd.pgd);\n\n\tif (initrd_len)\n\t\tsme_encrypt_execute(initrd_start, initrd_start + decrypted_base,\n\t\t\t\t    initrd_len, workarea_start,\n\t\t\t\t    (unsigned long)ppd.pgd);\n\n\t \n\tppd.vaddr = kernel_start + decrypted_base;\n\tppd.vaddr_end = kernel_end + decrypted_base;\n\tsme_clear_pgd(&ppd);\n\n\tif (initrd_len) {\n\t\tppd.vaddr = initrd_start + decrypted_base;\n\t\tppd.vaddr_end = initrd_end + decrypted_base;\n\t\tsme_clear_pgd(&ppd);\n\t}\n\n\tppd.vaddr = workarea_start + decrypted_base;\n\tppd.vaddr_end = workarea_end + decrypted_base;\n\tsme_clear_pgd(&ppd);\n\n\t \n\tnative_write_cr3(__native_read_cr3());\n}\n\nvoid __init sme_enable(struct boot_params *bp)\n{\n\tconst char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned long feature_mask;\n\tbool active_by_default;\n\tunsigned long me_mask;\n\tchar buffer[16];\n\tbool snp;\n\tu64 msr;\n\n\tsnp = snp_init(bp);\n\n\t \n\teax = 0x80000000;\n\tecx = 0;\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\tif (eax < 0x8000001f)\n\t\treturn;\n\n#define AMD_SME_BIT\tBIT(0)\n#define AMD_SEV_BIT\tBIT(1)\n\n\t \n\teax = 0x8000001f;\n\tecx = 0;\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\t \n\tif (!(eax & (AMD_SEV_BIT | AMD_SME_BIT)))\n\t\treturn;\n\n\tme_mask = 1UL << (ebx & 0x3f);\n\n\t \n\tsev_status   = __rdmsr(MSR_AMD64_SEV);\n\tfeature_mask = (sev_status & MSR_AMD64_SEV_ENABLED) ? AMD_SEV_BIT : AMD_SME_BIT;\n\n\t \n\tif (snp && !(sev_status & MSR_AMD64_SEV_SNP_ENABLED))\n\t\tsnp_abort();\n\n\t \n\tif (feature_mask == AMD_SME_BIT) {\n\t\t \n\t\teax = 1;\n\t\tecx = 0;\n\t\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\t\tif (ecx & BIT(31))\n\t\t\treturn;\n\n\t\t \n\t\tmsr = __rdmsr(MSR_AMD64_SYSCFG);\n\t\tif (!(msr & MSR_AMD64_SYSCFG_MEM_ENCRYPT))\n\t\t\treturn;\n\t} else {\n\t\t \n\t\tsme_me_mask = me_mask;\n\t\tgoto out;\n\t}\n\n\t \n\tasm (\"lea sme_cmdline_arg(%%rip), %0\"\n\t     : \"=r\" (cmdline_arg)\n\t     : \"p\" (sme_cmdline_arg));\n\tasm (\"lea sme_cmdline_on(%%rip), %0\"\n\t     : \"=r\" (cmdline_on)\n\t     : \"p\" (sme_cmdline_on));\n\tasm (\"lea sme_cmdline_off(%%rip), %0\"\n\t     : \"=r\" (cmdline_off)\n\t     : \"p\" (sme_cmdline_off));\n\n\tif (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))\n\t\tactive_by_default = true;\n\telse\n\t\tactive_by_default = false;\n\n\tcmdline_ptr = (const char *)((u64)bp->hdr.cmd_line_ptr |\n\t\t\t\t     ((u64)bp->ext_cmd_line_ptr << 32));\n\n\tif (cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer)) < 0)\n\t\treturn;\n\n\tif (!strncmp(buffer, cmdline_on, sizeof(buffer)))\n\t\tsme_me_mask = me_mask;\n\telse if (!strncmp(buffer, cmdline_off, sizeof(buffer)))\n\t\tsme_me_mask = 0;\n\telse\n\t\tsme_me_mask = active_by_default ? me_mask : 0;\nout:\n\tif (sme_me_mask) {\n\t\tphysical_mask &= ~sme_me_mask;\n\t\tcc_vendor = CC_VENDOR_AMD;\n\t\tcc_set_mask(sme_me_mask);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}