{
  "module_name": "testmmiotrace.c",
  "hash_id": "421c7ab93901d45355142e6dee17b9bd7348ccaf2f0c221221c48717c1c3a572",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/testmmiotrace.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/mmiotrace.h>\n#include <linux/security.h>\n\nstatic unsigned long mmio_address;\nmodule_param_hw(mmio_address, ulong, iomem, 0);\nMODULE_PARM_DESC(mmio_address, \" Start address of the mapping of 16 kB \"\n\t\t\t\t\"(or 8 MB if read_far is non-zero).\");\n\nstatic unsigned long read_far = 0x400100;\nmodule_param(read_far, ulong, 0);\nMODULE_PARM_DESC(read_far, \" Offset of a 32-bit read within 8 MB \"\n\t\t\t\t\"(default: 0x400100).\");\n\nstatic unsigned v16(unsigned i)\n{\n\treturn i * 12 + 7;\n}\n\nstatic unsigned v32(unsigned i)\n{\n\treturn i * 212371 + 13;\n}\n\nstatic void do_write_test(void __iomem *p)\n{\n\tunsigned int i;\n\tpr_info(\"write test.\\n\");\n\tmmiotrace_printk(\"Write test.\\n\");\n\n\tfor (i = 0; i < 256; i++)\n\t\tiowrite8(i, p + i);\n\n\tfor (i = 1024; i < (5 * 1024); i += 2)\n\t\tiowrite16(v16(i), p + i);\n\n\tfor (i = (5 * 1024); i < (16 * 1024); i += 4)\n\t\tiowrite32(v32(i), p + i);\n}\n\nstatic void do_read_test(void __iomem *p)\n{\n\tunsigned int i;\n\tunsigned errs[3] = { 0 };\n\tpr_info(\"read test.\\n\");\n\tmmiotrace_printk(\"Read test.\\n\");\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ioread8(p + i) != i)\n\t\t\t++errs[0];\n\n\tfor (i = 1024; i < (5 * 1024); i += 2)\n\t\tif (ioread16(p + i) != v16(i))\n\t\t\t++errs[1];\n\n\tfor (i = (5 * 1024); i < (16 * 1024); i += 4)\n\t\tif (ioread32(p + i) != v32(i))\n\t\t\t++errs[2];\n\n\tmmiotrace_printk(\"Read errors: 8-bit %d, 16-bit %d, 32-bit %d.\\n\",\n\t\t\t\t\t\terrs[0], errs[1], errs[2]);\n}\n\nstatic void do_read_far_test(void __iomem *p)\n{\n\tpr_info(\"read far test.\\n\");\n\tmmiotrace_printk(\"Read far test.\\n\");\n\n\tioread32(p + read_far);\n}\n\nstatic void do_test(unsigned long size)\n{\n\tvoid __iomem *p = ioremap(mmio_address, size);\n\tif (!p) {\n\t\tpr_err(\"could not ioremap, aborting.\\n\");\n\t\treturn;\n\t}\n\tmmiotrace_printk(\"ioremap returned %p.\\n\", p);\n\tdo_write_test(p);\n\tdo_read_test(p);\n\tif (read_far && read_far < size - 4)\n\t\tdo_read_far_test(p);\n\tiounmap(p);\n}\n\n \nstatic void do_test_bulk_ioremapping(void)\n{\n\tvoid __iomem *p;\n\tint i;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tp = ioremap(mmio_address, PAGE_SIZE);\n\t\tif (p)\n\t\t\tiounmap(p);\n\t}\n\n\t \n\tsynchronize_rcu();\n}\n\nstatic int __init init(void)\n{\n\tunsigned long size = (read_far) ? (8 << 20) : (16 << 10);\n\tint ret = security_locked_down(LOCKDOWN_MMIOTRACE);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mmio_address == 0) {\n\t\tpr_err(\"you have to use the module argument mmio_address.\\n\");\n\t\tpr_err(\"DO NOT LOAD THIS MODULE UNLESS YOU REALLY KNOW WHAT YOU ARE DOING!\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpr_warn(\"WARNING: mapping %lu kB @ 0x%08lx in PCI address space, \"\n\t\t\"and writing 16 kB of rubbish in there.\\n\",\n\t\tsize >> 10, mmio_address);\n\tdo_test(size);\n\tdo_test_bulk_ioremapping();\n\tpr_info(\"All done.\\n\");\n\treturn 0;\n}\n\nstatic void __exit cleanup(void)\n{\n\tpr_debug(\"unloaded.\\n\");\n}\n\nmodule_init(init);\nmodule_exit(cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}