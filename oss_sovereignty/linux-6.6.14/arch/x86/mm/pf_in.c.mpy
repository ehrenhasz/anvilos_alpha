{
  "module_name": "pf_in.c",
  "hash_id": "2ce89f0f407376ac5e05bf1f042f2ddcbfcf192c35cf080fed09efb87fc665d6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/pf_in.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ptrace.h>  \n#include \"pf_in.h\"\n\n#ifdef __i386__\n \nstatic unsigned char prefix_codes[] = {\n\t0xF0, 0xF2, 0xF3, 0x2E, 0x36, 0x3E, 0x26, 0x64,\n\t0x65, 0x66, 0x67\n};\n \nstatic unsigned int reg_rop[] = {\n\t0x8A, 0x8B, 0xB60F, 0xB70F, 0xBE0F, 0xBF0F\n};\nstatic unsigned int reg_wop[] = { 0x88, 0x89, 0xAA, 0xAB };\nstatic unsigned int imm_wop[] = { 0xC6, 0xC7 };\n \nstatic unsigned int rw8[] = { 0x88, 0x8A, 0xC6, 0xAA };\nstatic unsigned int rw32[] = {\n\t0x89, 0x8B, 0xC7, 0xB60F, 0xB70F, 0xBE0F, 0xBF0F, 0xAB\n};\nstatic unsigned int mw8[] = { 0x88, 0x8A, 0xC6, 0xB60F, 0xBE0F, 0xAA };\nstatic unsigned int mw16[] = { 0xB70F, 0xBF0F };\nstatic unsigned int mw32[] = { 0x89, 0x8B, 0xC7, 0xAB };\nstatic unsigned int mw64[] = {};\n#else  \nstatic unsigned char prefix_codes[] = {\n\t0x66, 0x67, 0x2E, 0x3E, 0x26, 0x64, 0x65, 0x36,\n\t0xF0, 0xF3, 0xF2,\n\t \n\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f\n};\n \nstatic unsigned int reg_rop[] = {\n\t0x8A, 0x8B, 0xB60F, 0xB70F, 0xBE0F, 0xBF0F\n};\nstatic unsigned int reg_wop[] = { 0x88, 0x89, 0xAA, 0xAB };\nstatic unsigned int imm_wop[] = { 0xC6, 0xC7 };\nstatic unsigned int rw8[] = { 0xC6, 0x88, 0x8A, 0xAA };\nstatic unsigned int rw32[] = {\n\t0xC7, 0x89, 0x8B, 0xB60F, 0xB70F, 0xBE0F, 0xBF0F, 0xAB\n};\n \nstatic unsigned int mw8[] = { 0xC6, 0x88, 0x8A, 0xB60F, 0xBE0F, 0xAA };\n \nstatic unsigned int mw16[] = { 0xB70F, 0xBF0F };\n \nstatic unsigned int mw32[] = { 0xC7 };\n \nstatic unsigned int mw64[] = { 0x89, 0x8B, 0xAB };\n#endif  \n\nstruct prefix_bits {\n\tunsigned shorted:1;\n\tunsigned enlarged:1;\n\tunsigned rexr:1;\n\tunsigned rex:1;\n};\n\nstatic int skip_prefix(unsigned char *addr, struct prefix_bits *prf)\n{\n\tint i;\n\tunsigned char *p = addr;\n\tprf->shorted = 0;\n\tprf->enlarged = 0;\n\tprf->rexr = 0;\n\tprf->rex = 0;\n\nrestart:\n\tfor (i = 0; i < ARRAY_SIZE(prefix_codes); i++) {\n\t\tif (*p == prefix_codes[i]) {\n\t\t\tif (*p == 0x66)\n\t\t\t\tprf->shorted = 1;\n#ifdef __amd64__\n\t\t\tif ((*p & 0xf8) == 0x48)\n\t\t\t\tprf->enlarged = 1;\n\t\t\tif ((*p & 0xf4) == 0x44)\n\t\t\t\tprf->rexr = 1;\n\t\t\tif ((*p & 0xf0) == 0x40)\n\t\t\t\tprf->rex = 1;\n#endif\n\t\t\tp++;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\treturn (p - addr);\n}\n\nstatic int get_opcode(unsigned char *addr, unsigned int *opcode)\n{\n\tint len;\n\n\tif (*addr == 0x0F) {\n\t\t \n\t\t*opcode = *(unsigned short *)addr;\n\t\tlen = 2;\n\t} else {\n\t\t*opcode = *addr;\n\t\tlen = 1;\n\t}\n\n\treturn len;\n}\n\n#define CHECK_OP_TYPE(opcode, array, type) \\\n\tfor (i = 0; i < ARRAY_SIZE(array); i++) { \\\n\t\tif (array[i] == opcode) { \\\n\t\t\trv = type; \\\n\t\t\tgoto exit; \\\n\t\t} \\\n\t}\n\nenum reason_type get_ins_type(unsigned long ins_addr)\n{\n\tunsigned int opcode;\n\tunsigned char *p;\n\tstruct prefix_bits prf;\n\tint i;\n\tenum reason_type rv = OTHERS;\n\n\tp = (unsigned char *)ins_addr;\n\tp += skip_prefix(p, &prf);\n\tp += get_opcode(p, &opcode);\n\n\tCHECK_OP_TYPE(opcode, reg_rop, REG_READ);\n\tCHECK_OP_TYPE(opcode, reg_wop, REG_WRITE);\n\tCHECK_OP_TYPE(opcode, imm_wop, IMM_WRITE);\n\nexit:\n\treturn rv;\n}\n#undef CHECK_OP_TYPE\n\nstatic unsigned int get_ins_reg_width(unsigned long ins_addr)\n{\n\tunsigned int opcode;\n\tunsigned char *p;\n\tstruct prefix_bits prf;\n\tint i;\n\n\tp = (unsigned char *)ins_addr;\n\tp += skip_prefix(p, &prf);\n\tp += get_opcode(p, &opcode);\n\n\tfor (i = 0; i < ARRAY_SIZE(rw8); i++)\n\t\tif (rw8[i] == opcode)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(rw32); i++)\n\t\tif (rw32[i] == opcode)\n\t\t\treturn prf.shorted ? 2 : (prf.enlarged ? 8 : 4);\n\n\tprintk(KERN_ERR \"mmiotrace: Unknown opcode 0x%02x\\n\", opcode);\n\treturn 0;\n}\n\nunsigned int get_ins_mem_width(unsigned long ins_addr)\n{\n\tunsigned int opcode;\n\tunsigned char *p;\n\tstruct prefix_bits prf;\n\tint i;\n\n\tp = (unsigned char *)ins_addr;\n\tp += skip_prefix(p, &prf);\n\tp += get_opcode(p, &opcode);\n\n\tfor (i = 0; i < ARRAY_SIZE(mw8); i++)\n\t\tif (mw8[i] == opcode)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(mw16); i++)\n\t\tif (mw16[i] == opcode)\n\t\t\treturn 2;\n\n\tfor (i = 0; i < ARRAY_SIZE(mw32); i++)\n\t\tif (mw32[i] == opcode)\n\t\t\treturn prf.shorted ? 2 : 4;\n\n\tfor (i = 0; i < ARRAY_SIZE(mw64); i++)\n\t\tif (mw64[i] == opcode)\n\t\t\treturn prf.shorted ? 2 : (prf.enlarged ? 8 : 4);\n\n\tprintk(KERN_ERR \"mmiotrace: Unknown opcode 0x%02x\\n\", opcode);\n\treturn 0;\n}\n\n \nenum {\n\targ_AL = 0,\n\targ_CL = 1,\n\targ_DL = 2,\n\targ_BL = 3,\n\targ_AH = 4,\n\targ_CH = 5,\n\targ_DH = 6,\n\targ_BH = 7,\n\n\targ_AX = 0,\n\targ_CX = 1,\n\targ_DX = 2,\n\targ_BX = 3,\n\targ_SP = 4,\n\targ_BP = 5,\n\targ_SI = 6,\n\targ_DI = 7,\n#ifdef __amd64__\n\targ_R8  = 8,\n\targ_R9  = 9,\n\targ_R10 = 10,\n\targ_R11 = 11,\n\targ_R12 = 12,\n\targ_R13 = 13,\n\targ_R14 = 14,\n\targ_R15 = 15\n#endif\n};\n\nstatic unsigned char *get_reg_w8(int no, int rex, struct pt_regs *regs)\n{\n\tunsigned char *rv = NULL;\n\n\tswitch (no) {\n\tcase arg_AL:\n\t\trv = (unsigned char *)&regs->ax;\n\t\tbreak;\n\tcase arg_BL:\n\t\trv = (unsigned char *)&regs->bx;\n\t\tbreak;\n\tcase arg_CL:\n\t\trv = (unsigned char *)&regs->cx;\n\t\tbreak;\n\tcase arg_DL:\n\t\trv = (unsigned char *)&regs->dx;\n\t\tbreak;\n#ifdef __amd64__\n\tcase arg_R8:\n\t\trv = (unsigned char *)&regs->r8;\n\t\tbreak;\n\tcase arg_R9:\n\t\trv = (unsigned char *)&regs->r9;\n\t\tbreak;\n\tcase arg_R10:\n\t\trv = (unsigned char *)&regs->r10;\n\t\tbreak;\n\tcase arg_R11:\n\t\trv = (unsigned char *)&regs->r11;\n\t\tbreak;\n\tcase arg_R12:\n\t\trv = (unsigned char *)&regs->r12;\n\t\tbreak;\n\tcase arg_R13:\n\t\trv = (unsigned char *)&regs->r13;\n\t\tbreak;\n\tcase arg_R14:\n\t\trv = (unsigned char *)&regs->r14;\n\t\tbreak;\n\tcase arg_R15:\n\t\trv = (unsigned char *)&regs->r15;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rv)\n\t\treturn rv;\n\n\tif (rex) {\n\t\t \n\t\tswitch (no) {\n\t\tcase arg_SI:\n\t\t\trv = (unsigned char *)&regs->si;\n\t\t\tbreak;\n\t\tcase arg_DI:\n\t\t\trv = (unsigned char *)&regs->di;\n\t\t\tbreak;\n\t\tcase arg_BP:\n\t\t\trv = (unsigned char *)&regs->bp;\n\t\t\tbreak;\n\t\tcase arg_SP:\n\t\t\trv = (unsigned char *)&regs->sp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (no) {\n\t\tcase arg_AH:\n\t\t\trv = 1 + (unsigned char *)&regs->ax;\n\t\t\tbreak;\n\t\tcase arg_BH:\n\t\t\trv = 1 + (unsigned char *)&regs->bx;\n\t\t\tbreak;\n\t\tcase arg_CH:\n\t\t\trv = 1 + (unsigned char *)&regs->cx;\n\t\t\tbreak;\n\t\tcase arg_DH:\n\t\t\trv = 1 + (unsigned char *)&regs->dx;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rv)\n\t\tprintk(KERN_ERR \"mmiotrace: Error reg no# %d\\n\", no);\n\n\treturn rv;\n}\n\nstatic unsigned long *get_reg_w32(int no, struct pt_regs *regs)\n{\n\tunsigned long *rv = NULL;\n\n\tswitch (no) {\n\tcase arg_AX:\n\t\trv = &regs->ax;\n\t\tbreak;\n\tcase arg_BX:\n\t\trv = &regs->bx;\n\t\tbreak;\n\tcase arg_CX:\n\t\trv = &regs->cx;\n\t\tbreak;\n\tcase arg_DX:\n\t\trv = &regs->dx;\n\t\tbreak;\n\tcase arg_SP:\n\t\trv = &regs->sp;\n\t\tbreak;\n\tcase arg_BP:\n\t\trv = &regs->bp;\n\t\tbreak;\n\tcase arg_SI:\n\t\trv = &regs->si;\n\t\tbreak;\n\tcase arg_DI:\n\t\trv = &regs->di;\n\t\tbreak;\n#ifdef __amd64__\n\tcase arg_R8:\n\t\trv = &regs->r8;\n\t\tbreak;\n\tcase arg_R9:\n\t\trv = &regs->r9;\n\t\tbreak;\n\tcase arg_R10:\n\t\trv = &regs->r10;\n\t\tbreak;\n\tcase arg_R11:\n\t\trv = &regs->r11;\n\t\tbreak;\n\tcase arg_R12:\n\t\trv = &regs->r12;\n\t\tbreak;\n\tcase arg_R13:\n\t\trv = &regs->r13;\n\t\tbreak;\n\tcase arg_R14:\n\t\trv = &regs->r14;\n\t\tbreak;\n\tcase arg_R15:\n\t\trv = &regs->r15;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintk(KERN_ERR \"mmiotrace: Error reg no# %d\\n\", no);\n\t}\n\n\treturn rv;\n}\n\nunsigned long get_ins_reg_val(unsigned long ins_addr, struct pt_regs *regs)\n{\n\tunsigned int opcode;\n\tint reg;\n\tunsigned char *p;\n\tstruct prefix_bits prf;\n\tint i;\n\n\tp = (unsigned char *)ins_addr;\n\tp += skip_prefix(p, &prf);\n\tp += get_opcode(p, &opcode);\n\tfor (i = 0; i < ARRAY_SIZE(reg_rop); i++)\n\t\tif (reg_rop[i] == opcode)\n\t\t\tgoto do_work;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_wop); i++)\n\t\tif (reg_wop[i] == opcode)\n\t\t\tgoto do_work;\n\n\tprintk(KERN_ERR \"mmiotrace: Not a register instruction, opcode \"\n\t\t\t\t\t\t\t\"0x%02x\\n\", opcode);\n\tgoto err;\n\ndo_work:\n\t \n\tif (opcode == 0xAA || opcode == 0xAB) {\n\t\treg = arg_AX;\n\t} else {\n\t\tunsigned char mod_rm = *p;\n\t\treg = ((mod_rm >> 3) & 0x7) | (prf.rexr << 3);\n\t}\n\tswitch (get_ins_reg_width(ins_addr)) {\n\tcase 1:\n\t\treturn *get_reg_w8(reg, prf.rex, regs);\n\n\tcase 2:\n\t\treturn *(unsigned short *)get_reg_w32(reg, regs);\n\n\tcase 4:\n\t\treturn *(unsigned int *)get_reg_w32(reg, regs);\n\n#ifdef __amd64__\n\tcase 8:\n\t\treturn *(unsigned long *)get_reg_w32(reg, regs);\n#endif\n\n\tdefault:\n\t\tprintk(KERN_ERR \"mmiotrace: Error width# %d\\n\", reg);\n\t}\n\nerr:\n\treturn 0;\n}\n\nunsigned long get_ins_imm_val(unsigned long ins_addr)\n{\n\tunsigned int opcode;\n\tunsigned char mod_rm;\n\tunsigned char mod;\n\tunsigned char *p;\n\tstruct prefix_bits prf;\n\tint i;\n\n\tp = (unsigned char *)ins_addr;\n\tp += skip_prefix(p, &prf);\n\tp += get_opcode(p, &opcode);\n\tfor (i = 0; i < ARRAY_SIZE(imm_wop); i++)\n\t\tif (imm_wop[i] == opcode)\n\t\t\tgoto do_work;\n\n\tprintk(KERN_ERR \"mmiotrace: Not an immediate instruction, opcode \"\n\t\t\t\t\t\t\t\"0x%02x\\n\", opcode);\n\tgoto err;\n\ndo_work:\n\tmod_rm = *p;\n\tmod = mod_rm >> 6;\n\tp++;\n\tswitch (mod) {\n\tcase 0:\n\t\t \n\t\t \n\t\tif ((mod_rm & 0x7) == 0x5)\n\t\t\tp += 4;\n\t\tbreak;\n\n\tcase 1:\n\t\tp += 1;\n\t\tbreak;\n\n\tcase 2:\n\t\tp += 4;\n\t\tbreak;\n\n\tcase 3:\n\tdefault:\n\t\tprintk(KERN_ERR \"mmiotrace: not a memory access instruction \"\n\t\t\t\t\t\t\"at 0x%lx, rm_mod=0x%02x\\n\",\n\t\t\t\t\t\tins_addr, mod_rm);\n\t}\n\n\tswitch (get_ins_reg_width(ins_addr)) {\n\tcase 1:\n\t\treturn *(unsigned char *)p;\n\n\tcase 2:\n\t\treturn *(unsigned short *)p;\n\n\tcase 4:\n\t\treturn *(unsigned int *)p;\n\n#ifdef __amd64__\n\tcase 8:\n\t\treturn *(unsigned long *)p;\n#endif\n\n\tdefault:\n\t\tprintk(KERN_ERR \"mmiotrace: Error: width.\\n\");\n\t}\n\nerr:\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}