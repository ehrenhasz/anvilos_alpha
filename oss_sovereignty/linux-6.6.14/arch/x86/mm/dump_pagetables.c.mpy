{
  "module_name": "dump_pagetables.c",
  "hash_id": "50b9e42a3e4e5339dd420a1576b963a316de9db55ce410900f72c134a1e5ed16",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/dump_pagetables.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/pci.h>\n#include <linux/ptdump.h>\n\n#include <asm/e820/types.h>\n\n \nstruct pg_state {\n\tstruct ptdump_state ptdump;\n\tint level;\n\tpgprotval_t current_prot;\n\tpgprotval_t effective_prot;\n\tpgprotval_t prot_levels[5];\n\tunsigned long start_address;\n\tconst struct addr_marker *marker;\n\tunsigned long lines;\n\tbool to_dmesg;\n\tbool check_wx;\n\tunsigned long wx_pages;\n\tstruct seq_file *seq;\n};\n\nstruct addr_marker {\n\tunsigned long start_address;\n\tconst char *name;\n\tunsigned long max_lines;\n};\n\n \n\n#ifdef CONFIG_X86_64\n\nenum address_markers_idx {\n\tUSER_SPACE_NR = 0,\n\tKERNEL_SPACE_NR,\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tLDT_NR,\n#endif\n\tLOW_KERNEL_NR,\n\tVMALLOC_START_NR,\n\tVMEMMAP_START_NR,\n#ifdef CONFIG_KASAN\n\tKASAN_SHADOW_START_NR,\n\tKASAN_SHADOW_END_NR,\n#endif\n\tCPU_ENTRY_AREA_NR,\n#ifdef CONFIG_X86_ESPFIX64\n\tESPFIX_START_NR,\n#endif\n#ifdef CONFIG_EFI\n\tEFI_END_NR,\n#endif\n\tHIGH_KERNEL_NR,\n\tMODULES_VADDR_NR,\n\tMODULES_END_NR,\n\tFIXADDR_START_NR,\n\tEND_OF_SPACE_NR,\n};\n\nstatic struct addr_marker address_markers[] = {\n\t[USER_SPACE_NR]\t\t= { 0,\t\t\t\"User Space\" },\n\t[KERNEL_SPACE_NR]\t= { (1UL << 63),\t\"Kernel Space\" },\n\t[LOW_KERNEL_NR]\t\t= { 0UL,\t\t\"Low Kernel Mapping\" },\n\t[VMALLOC_START_NR]\t= { 0UL,\t\t\"vmalloc() Area\" },\n\t[VMEMMAP_START_NR]\t= { 0UL,\t\t\"Vmemmap\" },\n#ifdef CONFIG_KASAN\n\t \n\t[KASAN_SHADOW_START_NR]\t= { 0UL,\t\t\"KASAN shadow\" },\n\t[KASAN_SHADOW_END_NR]\t= { 0UL,\t\t\"KASAN shadow end\" },\n#endif\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t[LDT_NR]\t\t= { 0UL,\t\t\"LDT remap\" },\n#endif\n\t[CPU_ENTRY_AREA_NR]\t= { CPU_ENTRY_AREA_BASE,\"CPU entry Area\" },\n#ifdef CONFIG_X86_ESPFIX64\n\t[ESPFIX_START_NR]\t= { ESPFIX_BASE_ADDR,\t\"ESPfix Area\", 16 },\n#endif\n#ifdef CONFIG_EFI\n\t[EFI_END_NR]\t\t= { EFI_VA_END,\t\t\"EFI Runtime Services\" },\n#endif\n\t[HIGH_KERNEL_NR]\t= { __START_KERNEL_map,\t\"High Kernel Mapping\" },\n\t[MODULES_VADDR_NR]\t= { MODULES_VADDR,\t\"Modules\" },\n\t[MODULES_END_NR]\t= { MODULES_END,\t\"End Modules\" },\n\t[FIXADDR_START_NR]\t= { FIXADDR_START,\t\"Fixmap Area\" },\n\t[END_OF_SPACE_NR]\t= { -1,\t\t\tNULL }\n};\n\n#define INIT_PGD\t((pgd_t *) &init_top_pgt)\n\n#else  \n\nenum address_markers_idx {\n\tUSER_SPACE_NR = 0,\n\tKERNEL_SPACE_NR,\n\tVMALLOC_START_NR,\n\tVMALLOC_END_NR,\n#ifdef CONFIG_HIGHMEM\n\tPKMAP_BASE_NR,\n#endif\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tLDT_NR,\n#endif\n\tCPU_ENTRY_AREA_NR,\n\tFIXADDR_START_NR,\n\tEND_OF_SPACE_NR,\n};\n\nstatic struct addr_marker address_markers[] = {\n\t[USER_SPACE_NR]\t\t= { 0,\t\t\t\"User Space\" },\n\t[KERNEL_SPACE_NR]\t= { PAGE_OFFSET,\t\"Kernel Mapping\" },\n\t[VMALLOC_START_NR]\t= { 0UL,\t\t\"vmalloc() Area\" },\n\t[VMALLOC_END_NR]\t= { 0UL,\t\t\"vmalloc() End\" },\n#ifdef CONFIG_HIGHMEM\n\t[PKMAP_BASE_NR]\t\t= { 0UL,\t\t\"Persistent kmap() Area\" },\n#endif\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t[LDT_NR]\t\t= { 0UL,\t\t\"LDT remap\" },\n#endif\n\t[CPU_ENTRY_AREA_NR]\t= { 0UL,\t\t\"CPU entry area\" },\n\t[FIXADDR_START_NR]\t= { 0UL,\t\t\"Fixmap area\" },\n\t[END_OF_SPACE_NR]\t= { -1,\t\t\tNULL }\n};\n\n#define INIT_PGD\t(swapper_pg_dir)\n\n#endif  \n\n \n#define PTE_LEVEL_MULT (PAGE_SIZE)\n#define PMD_LEVEL_MULT (PTRS_PER_PTE * PTE_LEVEL_MULT)\n#define PUD_LEVEL_MULT (PTRS_PER_PMD * PMD_LEVEL_MULT)\n#define P4D_LEVEL_MULT (PTRS_PER_PUD * PUD_LEVEL_MULT)\n#define PGD_LEVEL_MULT (PTRS_PER_P4D * P4D_LEVEL_MULT)\n\n#define pt_dump_seq_printf(m, to_dmesg, fmt, args...)\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tif (to_dmesg)\t\t\t\t\t\\\n\t\tprintk(KERN_INFO fmt, ##args);\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tif (m)\t\t\t\t\t\t\\\n\t\t\tseq_printf(m, fmt, ##args);\t\t\\\n})\n\n#define pt_dump_cont_printf(m, to_dmesg, fmt, args...)\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tif (to_dmesg)\t\t\t\t\t\\\n\t\tprintk(KERN_CONT fmt, ##args);\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tif (m)\t\t\t\t\t\t\\\n\t\t\tseq_printf(m, fmt, ##args);\t\t\\\n})\n\n \nstatic void printk_prot(struct seq_file *m, pgprotval_t pr, int level, bool dmsg)\n{\n\tstatic const char * const level_name[] =\n\t\t{ \"pgd\", \"p4d\", \"pud\", \"pmd\", \"pte\" };\n\n\tif (!(pr & _PAGE_PRESENT)) {\n\t\t \n\t\tpt_dump_cont_printf(m, dmsg, \"                              \");\n\t} else {\n\t\tif (pr & _PAGE_USER)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"USR \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\t\tif (pr & _PAGE_RW)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"RW \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"ro \");\n\t\tif (pr & _PAGE_PWT)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"PWT \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\t\tif (pr & _PAGE_PCD)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"PCD \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\n\t\t \n\t\tif (level <= 3 && pr & _PAGE_PSE)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"PSE \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\t\tif ((level == 4 && pr & _PAGE_PAT) ||\n\t\t    ((level == 3 || level == 2) && pr & _PAGE_PAT_LARGE))\n\t\t\tpt_dump_cont_printf(m, dmsg, \"PAT \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\t\tif (pr & _PAGE_GLOBAL)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"GLB \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"    \");\n\t\tif (pr & _PAGE_NX)\n\t\t\tpt_dump_cont_printf(m, dmsg, \"NX \");\n\t\telse\n\t\t\tpt_dump_cont_printf(m, dmsg, \"x  \");\n\t}\n\tpt_dump_cont_printf(m, dmsg, \"%s\\n\", level_name[level]);\n}\n\nstatic void note_wx(struct pg_state *st, unsigned long addr)\n{\n\tunsigned long npages;\n\n\tnpages = (addr - st->start_address) / PAGE_SIZE;\n\n#ifdef CONFIG_PCI_BIOS\n\t \n\tif (pcibios_enabled && st->start_address >= PAGE_OFFSET + BIOS_BEGIN &&\n\t    addr <= PAGE_OFFSET + BIOS_END) {\n\t\tpr_warn_once(\"x86/mm: PCI BIOS W+X mapping %lu pages\\n\", npages);\n\t\treturn;\n\t}\n#endif\n\t \n\tst->wx_pages += npages;\n\tWARN_ONCE(__supported_pte_mask & _PAGE_NX,\n\t\t  \"x86/mm: Found insecure W+X mapping at address %pS\\n\",\n\t\t  (void *)st->start_address);\n}\n\nstatic void effective_prot(struct ptdump_state *pt_st, int level, u64 val)\n{\n\tstruct pg_state *st = container_of(pt_st, struct pg_state, ptdump);\n\tpgprotval_t prot = val & PTE_FLAGS_MASK;\n\tpgprotval_t effective;\n\n\tif (level > 0) {\n\t\tpgprotval_t higher_prot = st->prot_levels[level - 1];\n\n\t\teffective = (higher_prot & prot & (_PAGE_USER | _PAGE_RW)) |\n\t\t\t    ((higher_prot | prot) & _PAGE_NX);\n\t} else {\n\t\teffective = prot;\n\t}\n\n\tst->prot_levels[level] = effective;\n}\n\n \nstatic void note_page(struct ptdump_state *pt_st, unsigned long addr, int level,\n\t\t      u64 val)\n{\n\tstruct pg_state *st = container_of(pt_st, struct pg_state, ptdump);\n\tpgprotval_t new_prot, new_eff;\n\tpgprotval_t cur, eff;\n\tstatic const char units[] = \"BKMGTPE\";\n\tstruct seq_file *m = st->seq;\n\n\tnew_prot = val & PTE_FLAGS_MASK;\n\tif (!val)\n\t\tnew_eff = 0;\n\telse\n\t\tnew_eff = st->prot_levels[level];\n\n\t \n\tcur = st->current_prot;\n\teff = st->effective_prot;\n\n\tif (st->level == -1) {\n\t\t \n\t\tst->current_prot = new_prot;\n\t\tst->effective_prot = new_eff;\n\t\tst->level = level;\n\t\tst->marker = address_markers;\n\t\tst->lines = 0;\n\t\tpt_dump_seq_printf(m, st->to_dmesg, \"---[ %s ]---\\n\",\n\t\t\t\t   st->marker->name);\n\t} else if (new_prot != cur || new_eff != eff || level != st->level ||\n\t\t   addr >= st->marker[1].start_address) {\n\t\tconst char *unit = units;\n\t\tunsigned long delta;\n\t\tint width = sizeof(unsigned long) * 2;\n\n\t\tif (st->check_wx && (eff & _PAGE_RW) && !(eff & _PAGE_NX))\n\t\t\tnote_wx(st, addr);\n\n\t\t \n\t\tif (!st->marker->max_lines ||\n\t\t    st->lines < st->marker->max_lines) {\n\t\t\tpt_dump_seq_printf(m, st->to_dmesg,\n\t\t\t\t\t   \"0x%0*lx-0x%0*lx   \",\n\t\t\t\t\t   width, st->start_address,\n\t\t\t\t\t   width, addr);\n\n\t\t\tdelta = addr - st->start_address;\n\t\t\twhile (!(delta & 1023) && unit[1]) {\n\t\t\t\tdelta >>= 10;\n\t\t\t\tunit++;\n\t\t\t}\n\t\t\tpt_dump_cont_printf(m, st->to_dmesg, \"%9lu%c \",\n\t\t\t\t\t    delta, *unit);\n\t\t\tprintk_prot(m, st->current_prot, st->level,\n\t\t\t\t    st->to_dmesg);\n\t\t}\n\t\tst->lines++;\n\n\t\t \n\t\tif (addr >= st->marker[1].start_address) {\n\t\t\tif (st->marker->max_lines &&\n\t\t\t    st->lines > st->marker->max_lines) {\n\t\t\t\tunsigned long nskip =\n\t\t\t\t\tst->lines - st->marker->max_lines;\n\t\t\t\tpt_dump_seq_printf(m, st->to_dmesg,\n\t\t\t\t\t\t   \"... %lu entr%s skipped ... \\n\",\n\t\t\t\t\t\t   nskip,\n\t\t\t\t\t\t   nskip == 1 ? \"y\" : \"ies\");\n\t\t\t}\n\t\t\tst->marker++;\n\t\t\tst->lines = 0;\n\t\t\tpt_dump_seq_printf(m, st->to_dmesg, \"---[ %s ]---\\n\",\n\t\t\t\t\t   st->marker->name);\n\t\t}\n\n\t\tst->start_address = addr;\n\t\tst->current_prot = new_prot;\n\t\tst->effective_prot = new_eff;\n\t\tst->level = level;\n\t}\n}\n\nstatic void ptdump_walk_pgd_level_core(struct seq_file *m,\n\t\t\t\t       struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t       bool checkwx, bool dmesg)\n{\n\tconst struct ptdump_range ptdump_ranges[] = {\n#ifdef CONFIG_X86_64\n\t{0, PTRS_PER_PGD * PGD_LEVEL_MULT / 2},\n\t{GUARD_HOLE_END_ADDR, ~0UL},\n#else\n\t{0, ~0UL},\n#endif\n\t{0, 0}\n};\n\n\tstruct pg_state st = {\n\t\t.ptdump = {\n\t\t\t.note_page\t= note_page,\n\t\t\t.effective_prot = effective_prot,\n\t\t\t.range\t\t= ptdump_ranges\n\t\t},\n\t\t.level = -1,\n\t\t.to_dmesg\t= dmesg,\n\t\t.check_wx\t= checkwx,\n\t\t.seq\t\t= m\n\t};\n\n\tptdump_walk_pgd(&st.ptdump, mm, pgd);\n\n\tif (!checkwx)\n\t\treturn;\n\tif (st.wx_pages)\n\t\tpr_info(\"x86/mm: Checked W+X mappings: FAILED, %lu W+X pages found.\\n\",\n\t\t\tst.wx_pages);\n\telse\n\t\tpr_info(\"x86/mm: Checked W+X mappings: passed, no W+X pages found.\\n\");\n}\n\nvoid ptdump_walk_pgd_level(struct seq_file *m, struct mm_struct *mm)\n{\n\tptdump_walk_pgd_level_core(m, mm, mm->pgd, false, true);\n}\n\nvoid ptdump_walk_pgd_level_debugfs(struct seq_file *m, struct mm_struct *mm,\n\t\t\t\t   bool user)\n{\n\tpgd_t *pgd = mm->pgd;\n#ifdef CONFIG_PAGE_TABLE_ISOLATION\n\tif (user && boot_cpu_has(X86_FEATURE_PTI))\n\t\tpgd = kernel_to_user_pgdp(pgd);\n#endif\n\tptdump_walk_pgd_level_core(m, mm, pgd, false, false);\n}\nEXPORT_SYMBOL_GPL(ptdump_walk_pgd_level_debugfs);\n\nvoid ptdump_walk_user_pgd_level_checkwx(void)\n{\n#ifdef CONFIG_PAGE_TABLE_ISOLATION\n\tpgd_t *pgd = INIT_PGD;\n\n\tif (!(__supported_pte_mask & _PAGE_NX) ||\n\t    !boot_cpu_has(X86_FEATURE_PTI))\n\t\treturn;\n\n\tpr_info(\"x86/mm: Checking user space page tables\\n\");\n\tpgd = kernel_to_user_pgdp(pgd);\n\tptdump_walk_pgd_level_core(NULL, &init_mm, pgd, true, false);\n#endif\n}\n\nvoid ptdump_walk_pgd_level_checkwx(void)\n{\n\tptdump_walk_pgd_level_core(NULL, &init_mm, INIT_PGD, true, false);\n}\n\nstatic int __init pt_dump_init(void)\n{\n\t \n#ifdef CONFIG_X86_64\n\taddress_markers[LOW_KERNEL_NR].start_address = PAGE_OFFSET;\n\taddress_markers[VMALLOC_START_NR].start_address = VMALLOC_START;\n\taddress_markers[VMEMMAP_START_NR].start_address = VMEMMAP_START;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\taddress_markers[LDT_NR].start_address = LDT_BASE_ADDR;\n#endif\n#ifdef CONFIG_KASAN\n\taddress_markers[KASAN_SHADOW_START_NR].start_address = KASAN_SHADOW_START;\n\taddress_markers[KASAN_SHADOW_END_NR].start_address = KASAN_SHADOW_END;\n#endif\n#endif\n#ifdef CONFIG_X86_32\n\taddress_markers[VMALLOC_START_NR].start_address = VMALLOC_START;\n\taddress_markers[VMALLOC_END_NR].start_address = VMALLOC_END;\n# ifdef CONFIG_HIGHMEM\n\taddress_markers[PKMAP_BASE_NR].start_address = PKMAP_BASE;\n# endif\n\taddress_markers[FIXADDR_START_NR].start_address = FIXADDR_START;\n\taddress_markers[CPU_ENTRY_AREA_NR].start_address = CPU_ENTRY_AREA_BASE;\n# ifdef CONFIG_MODIFY_LDT_SYSCALL\n\taddress_markers[LDT_NR].start_address = LDT_BASE_ADDR;\n# endif\n#endif\n\treturn 0;\n}\n__initcall(pt_dump_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}