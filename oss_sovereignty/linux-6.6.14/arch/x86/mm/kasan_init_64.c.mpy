{
  "module_name": "kasan_init_64.c",
  "hash_id": "3e2aa73672da2adbef4d6020eb917dcdf3ea5161b9448492a51f9796201a86ec",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/kasan_init_64.c",
  "human_readable_source": "\n#define DISABLE_BRANCH_PROFILING\n#define pr_fmt(fmt) \"kasan: \" fmt\n\n \n#define USE_EARLY_PGTABLE_L5\n\n#include <linux/memblock.h>\n#include <linux/kasan.h>\n#include <linux/kdebug.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/vmalloc.h>\n\n#include <asm/e820/types.h>\n#include <asm/pgalloc.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cpu_entry_area.h>\n\nextern struct range pfn_mapped[E820_MAX_ENTRIES];\n\nstatic p4d_t tmp_p4d_table[MAX_PTRS_PER_P4D] __initdata __aligned(PAGE_SIZE);\n\nstatic __init void *early_alloc(size_t size, int nid, bool should_panic)\n{\n\tvoid *ptr = memblock_alloc_try_nid(size, size,\n\t\t\t__pa(MAX_DMA_ADDRESS), MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\n\tif (!ptr && should_panic)\n\t\tpanic(\"%pS: Failed to allocate page, nid=%d from=%lx\\n\",\n\t\t      (void *)_RET_IP_, nid, __pa(MAX_DMA_ADDRESS));\n\n\treturn ptr;\n}\n\nstatic void __init kasan_populate_pmd(pmd_t *pmd, unsigned long addr,\n\t\t\t\t      unsigned long end, int nid)\n{\n\tpte_t *pte;\n\n\tif (pmd_none(*pmd)) {\n\t\tvoid *p;\n\n\t\tif (boot_cpu_has(X86_FEATURE_PSE) &&\n\t\t    ((end - addr) == PMD_SIZE) &&\n\t\t    IS_ALIGNED(addr, PMD_SIZE)) {\n\t\t\tp = early_alloc(PMD_SIZE, nid, false);\n\t\t\tif (p && pmd_set_huge(pmd, __pa(p), PAGE_KERNEL))\n\t\t\t\treturn;\n\t\t\tmemblock_free(p, PMD_SIZE);\n\t\t}\n\n\t\tp = early_alloc(PAGE_SIZE, nid, true);\n\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t}\n\n\tpte = pte_offset_kernel(pmd, addr);\n\tdo {\n\t\tpte_t entry;\n\t\tvoid *p;\n\n\t\tif (!pte_none(*pte))\n\t\t\tcontinue;\n\n\t\tp = early_alloc(PAGE_SIZE, nid, true);\n\t\tentry = pfn_pte(PFN_DOWN(__pa(p)), PAGE_KERNEL);\n\t\tset_pte_at(&init_mm, addr, pte, entry);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}\n\nstatic void __init kasan_populate_pud(pud_t *pud, unsigned long addr,\n\t\t\t\t      unsigned long end, int nid)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tif (pud_none(*pud)) {\n\t\tvoid *p;\n\n\t\tif (boot_cpu_has(X86_FEATURE_GBPAGES) &&\n\t\t    ((end - addr) == PUD_SIZE) &&\n\t\t    IS_ALIGNED(addr, PUD_SIZE)) {\n\t\t\tp = early_alloc(PUD_SIZE, nid, false);\n\t\t\tif (p && pud_set_huge(pud, __pa(p), PAGE_KERNEL))\n\t\t\t\treturn;\n\t\t\tmemblock_free(p, PUD_SIZE);\n\t\t}\n\n\t\tp = early_alloc(PAGE_SIZE, nid, true);\n\t\tpud_populate(&init_mm, pud, p);\n\t}\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!pmd_large(*pmd))\n\t\t\tkasan_populate_pmd(pmd, addr, next, nid);\n\t} while (pmd++, addr = next, addr != end);\n}\n\nstatic void __init kasan_populate_p4d(p4d_t *p4d, unsigned long addr,\n\t\t\t\t      unsigned long end, int nid)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tif (p4d_none(*p4d)) {\n\t\tvoid *p = early_alloc(PAGE_SIZE, nid, true);\n\n\t\tp4d_populate(&init_mm, p4d, p);\n\t}\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (!pud_large(*pud))\n\t\t\tkasan_populate_pud(pud, addr, next, nid);\n\t} while (pud++, addr = next, addr != end);\n}\n\nstatic void __init kasan_populate_pgd(pgd_t *pgd, unsigned long addr,\n\t\t\t\t      unsigned long end, int nid)\n{\n\tvoid *p;\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tif (pgd_none(*pgd)) {\n\t\tp = early_alloc(PAGE_SIZE, nid, true);\n\t\tpgd_populate(&init_mm, pgd, p);\n\t}\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tkasan_populate_p4d(p4d, addr, next, nid);\n\t} while (p4d++, addr = next, addr != end);\n}\n\nstatic void __init kasan_populate_shadow(unsigned long addr, unsigned long end,\n\t\t\t\t\t int nid)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\taddr = addr & PAGE_MASK;\n\tend = round_up(end, PAGE_SIZE);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tkasan_populate_pgd(pgd, addr, next, nid);\n\t} while (pgd++, addr = next, addr != end);\n}\n\nstatic void __init map_range(struct range *range)\n{\n\tunsigned long start;\n\tunsigned long end;\n\n\tstart = (unsigned long)kasan_mem_to_shadow(pfn_to_kaddr(range->start));\n\tend = (unsigned long)kasan_mem_to_shadow(pfn_to_kaddr(range->end));\n\n\tkasan_populate_shadow(start, end, early_pfn_to_nid(range->start));\n}\n\nstatic void __init clear_pgds(unsigned long start,\n\t\t\tunsigned long end)\n{\n\tpgd_t *pgd;\n\t \n\tunsigned long pgd_end = end & PGDIR_MASK;\n\n\tfor (; start < pgd_end; start += PGDIR_SIZE) {\n\t\tpgd = pgd_offset_k(start);\n\t\t \n\t\tif (pgtable_l5_enabled())\n\t\t\tpgd_clear(pgd);\n\t\telse\n\t\t\tp4d_clear(p4d_offset(pgd, start));\n\t}\n\n\tpgd = pgd_offset_k(start);\n\tfor (; start < end; start += P4D_SIZE)\n\t\tp4d_clear(p4d_offset(pgd, start));\n}\n\nstatic inline p4d_t *early_p4d_offset(pgd_t *pgd, unsigned long addr)\n{\n\tunsigned long p4d;\n\n\tif (!pgtable_l5_enabled())\n\t\treturn (p4d_t *)pgd;\n\n\tp4d = pgd_val(*pgd) & PTE_PFN_MASK;\n\tp4d += __START_KERNEL_map - phys_base;\n\treturn (p4d_t *)p4d + p4d_index(addr);\n}\n\nstatic void __init kasan_early_p4d_populate(pgd_t *pgd,\n\t\tunsigned long addr,\n\t\tunsigned long end)\n{\n\tpgd_t pgd_entry;\n\tp4d_t *p4d, p4d_entry;\n\tunsigned long next;\n\n\tif (pgd_none(*pgd)) {\n\t\tpgd_entry = __pgd(_KERNPG_TABLE |\n\t\t\t\t\t__pa_nodebug(kasan_early_shadow_p4d));\n\t\tset_pgd(pgd, pgd_entry);\n\t}\n\n\tp4d = early_p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\n\t\tif (!p4d_none(*p4d))\n\t\t\tcontinue;\n\n\t\tp4d_entry = __p4d(_KERNPG_TABLE |\n\t\t\t\t\t__pa_nodebug(kasan_early_shadow_pud));\n\t\tset_p4d(p4d, p4d_entry);\n\t} while (p4d++, addr = next, addr != end && p4d_none(*p4d));\n}\n\nstatic void __init kasan_map_early_shadow(pgd_t *pgd)\n{\n\t \n\tunsigned long addr = KASAN_SHADOW_START & PGDIR_MASK;\n\tunsigned long end = KASAN_SHADOW_END;\n\tunsigned long next;\n\n\tpgd += pgd_index(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tkasan_early_p4d_populate(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}\n\nstatic void __init kasan_shallow_populate_p4ds(pgd_t *pgd,\n\t\t\t\t\t       unsigned long addr,\n\t\t\t\t\t       unsigned long end)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tvoid *p;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\n\t\tif (p4d_none(*p4d)) {\n\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE, true);\n\t\t\tp4d_populate(&init_mm, p4d, p);\n\t\t}\n\t} while (p4d++, addr = next, addr != end);\n}\n\nstatic void __init kasan_shallow_populate_pgds(void *start, void *end)\n{\n\tunsigned long addr, next;\n\tpgd_t *pgd;\n\tvoid *p;\n\n\taddr = (unsigned long)start;\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, (unsigned long)end);\n\n\t\tif (pgd_none(*pgd)) {\n\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE, true);\n\t\t\tpgd_populate(&init_mm, pgd, p);\n\t\t}\n\n\t\t \n\t\tkasan_shallow_populate_p4ds(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != (unsigned long)end);\n}\n\nvoid __init kasan_early_init(void)\n{\n\tint i;\n\tpteval_t pte_val = __pa_nodebug(kasan_early_shadow_page) |\n\t\t\t\t__PAGE_KERNEL | _PAGE_ENC;\n\tpmdval_t pmd_val = __pa_nodebug(kasan_early_shadow_pte) | _KERNPG_TABLE;\n\tpudval_t pud_val = __pa_nodebug(kasan_early_shadow_pmd) | _KERNPG_TABLE;\n\tp4dval_t p4d_val = __pa_nodebug(kasan_early_shadow_pud) | _KERNPG_TABLE;\n\n\t \n\tpte_val &= __default_kernel_pte_mask;\n\tpmd_val &= __default_kernel_pte_mask;\n\tpud_val &= __default_kernel_pte_mask;\n\tp4d_val &= __default_kernel_pte_mask;\n\n\tfor (i = 0; i < PTRS_PER_PTE; i++)\n\t\tkasan_early_shadow_pte[i] = __pte(pte_val);\n\n\tfor (i = 0; i < PTRS_PER_PMD; i++)\n\t\tkasan_early_shadow_pmd[i] = __pmd(pmd_val);\n\n\tfor (i = 0; i < PTRS_PER_PUD; i++)\n\t\tkasan_early_shadow_pud[i] = __pud(pud_val);\n\n\tfor (i = 0; pgtable_l5_enabled() && i < PTRS_PER_P4D; i++)\n\t\tkasan_early_shadow_p4d[i] = __p4d(p4d_val);\n\n\tkasan_map_early_shadow(early_top_pgt);\n\tkasan_map_early_shadow(init_top_pgt);\n}\n\nstatic unsigned long kasan_mem_to_shadow_align_down(unsigned long va)\n{\n\tunsigned long shadow = (unsigned long)kasan_mem_to_shadow((void *)va);\n\n\treturn round_down(shadow, PAGE_SIZE);\n}\n\nstatic unsigned long kasan_mem_to_shadow_align_up(unsigned long va)\n{\n\tunsigned long shadow = (unsigned long)kasan_mem_to_shadow((void *)va);\n\n\treturn round_up(shadow, PAGE_SIZE);\n}\n\nvoid __init kasan_populate_shadow_for_vaddr(void *va, size_t size, int nid)\n{\n\tunsigned long shadow_start, shadow_end;\n\n\tshadow_start = kasan_mem_to_shadow_align_down((unsigned long)va);\n\tshadow_end = kasan_mem_to_shadow_align_up((unsigned long)va + size);\n\tkasan_populate_shadow(shadow_start, shadow_end, nid);\n}\n\nvoid __init kasan_init(void)\n{\n\tunsigned long shadow_cea_begin, shadow_cea_per_cpu_begin, shadow_cea_end;\n\tint i;\n\n\tmemcpy(early_top_pgt, init_top_pgt, sizeof(early_top_pgt));\n\n\t \n\tif (pgtable_l5_enabled()) {\n\t\tvoid *ptr;\n\n\t\tptr = (void *)pgd_page_vaddr(*pgd_offset_k(KASAN_SHADOW_END));\n\t\tmemcpy(tmp_p4d_table, (void *)ptr, sizeof(tmp_p4d_table));\n\t\tset_pgd(&early_top_pgt[pgd_index(KASAN_SHADOW_END)],\n\t\t\t\t__pgd(__pa(tmp_p4d_table) | _KERNPG_TABLE));\n\t}\n\n\tload_cr3(early_top_pgt);\n\t__flush_tlb_all();\n\n\tclear_pgds(KASAN_SHADOW_START & PGDIR_MASK, KASAN_SHADOW_END);\n\n\tkasan_populate_early_shadow((void *)(KASAN_SHADOW_START & PGDIR_MASK),\n\t\t\tkasan_mem_to_shadow((void *)PAGE_OFFSET));\n\n\tfor (i = 0; i < E820_MAX_ENTRIES; i++) {\n\t\tif (pfn_mapped[i].end == 0)\n\t\t\tbreak;\n\n\t\tmap_range(&pfn_mapped[i]);\n\t}\n\n\tshadow_cea_begin = kasan_mem_to_shadow_align_down(CPU_ENTRY_AREA_BASE);\n\tshadow_cea_per_cpu_begin = kasan_mem_to_shadow_align_up(CPU_ENTRY_AREA_PER_CPU);\n\tshadow_cea_end = kasan_mem_to_shadow_align_up(CPU_ENTRY_AREA_BASE +\n\t\t\t\t\t\t      CPU_ENTRY_AREA_MAP_SIZE);\n\n\tkasan_populate_early_shadow(\n\t\tkasan_mem_to_shadow((void *)PAGE_OFFSET + MAXMEM),\n\t\tkasan_mem_to_shadow((void *)VMALLOC_START));\n\n\t \n\tif (IS_ENABLED(CONFIG_KASAN_VMALLOC))\n\t\tkasan_shallow_populate_pgds(\n\t\t\tkasan_mem_to_shadow((void *)VMALLOC_START),\n\t\t\tkasan_mem_to_shadow((void *)VMALLOC_END));\n\telse\n\t\tkasan_populate_early_shadow(\n\t\t\tkasan_mem_to_shadow((void *)VMALLOC_START),\n\t\t\tkasan_mem_to_shadow((void *)VMALLOC_END));\n\n\tkasan_populate_early_shadow(\n\t\tkasan_mem_to_shadow((void *)VMALLOC_END + 1),\n\t\t(void *)shadow_cea_begin);\n\n\t \n\tkasan_populate_shadow(shadow_cea_begin,\n\t\t\t      shadow_cea_per_cpu_begin, 0);\n\n\tkasan_populate_early_shadow((void *)shadow_cea_end,\n\t\t\tkasan_mem_to_shadow((void *)__START_KERNEL_map));\n\n\tkasan_populate_shadow((unsigned long)kasan_mem_to_shadow(_stext),\n\t\t\t      (unsigned long)kasan_mem_to_shadow(_end),\n\t\t\t      early_pfn_to_nid(__pa(_stext)));\n\n\tkasan_populate_early_shadow(kasan_mem_to_shadow((void *)MODULES_END),\n\t\t\t\t\t(void *)KASAN_SHADOW_END);\n\n\tload_cr3(init_top_pgt);\n\t__flush_tlb_all();\n\n\t \n\tmemset(kasan_early_shadow_page, 0, PAGE_SIZE);\n\tfor (i = 0; i < PTRS_PER_PTE; i++) {\n\t\tpte_t pte;\n\t\tpgprot_t prot;\n\n\t\tprot = __pgprot(__PAGE_KERNEL_RO | _PAGE_ENC);\n\t\tpgprot_val(prot) &= __default_kernel_pte_mask;\n\n\t\tpte = __pte(__pa(kasan_early_shadow_page) | pgprot_val(prot));\n\t\tset_pte(&kasan_early_shadow_pte[i], pte);\n\t}\n\t \n\t__flush_tlb_all();\n\n\tinit_task.kasan_depth = 0;\n\tpr_info(\"KernelAddressSanitizer initialized\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}