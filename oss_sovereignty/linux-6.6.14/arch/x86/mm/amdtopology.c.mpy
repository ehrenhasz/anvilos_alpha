{
  "module_name": "amdtopology.c",
  "hash_id": "e4acc0329442ffbca482402979b129702509fc86810471633265f09d55a2d4ea",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/amdtopology.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/nodemask.h>\n#include <linux/memblock.h>\n\n#include <asm/io.h>\n#include <linux/pci_ids.h>\n#include <linux/acpi.h>\n#include <asm/types.h>\n#include <asm/mmzone.h>\n#include <asm/proto.h>\n#include <asm/e820/api.h>\n#include <asm/pci-direct.h>\n#include <asm/numa.h>\n#include <asm/mpspec.h>\n#include <asm/apic.h>\n#include <asm/amd_nb.h>\n\nstatic unsigned char __initdata nodeids[8];\n\nstatic __init int find_northbridge(void)\n{\n\tint num;\n\n\tfor (num = 0; num < 32; num++) {\n\t\tu32 header;\n\n\t\theader = read_pci_config(0, num, 0, 0x00);\n\t\tif (header != (PCI_VENDOR_ID_AMD | (0x1100<<16)) &&\n\t\t\theader != (PCI_VENDOR_ID_AMD | (0x1200<<16)) &&\n\t\t\theader != (PCI_VENDOR_ID_AMD | (0x1300<<16)))\n\t\t\tcontinue;\n\n\t\theader = read_pci_config(0, num, 1, 0x00);\n\t\tif (header != (PCI_VENDOR_ID_AMD | (0x1101<<16)) &&\n\t\t\theader != (PCI_VENDOR_ID_AMD | (0x1201<<16)) &&\n\t\t\theader != (PCI_VENDOR_ID_AMD | (0x1301<<16)))\n\t\t\tcontinue;\n\t\treturn num;\n\t}\n\n\treturn -ENOENT;\n}\n\nint __init amd_numa_init(void)\n{\n\tu64 start = PFN_PHYS(0);\n\tu64 end = PFN_PHYS(max_pfn);\n\tunsigned numnodes;\n\tu64 prevbase;\n\tint i, j, nb;\n\tu32 nodeid, reg;\n\tunsigned int bits, cores, apicid_base;\n\n\tif (!early_pci_allowed())\n\t\treturn -EINVAL;\n\n\tnb = find_northbridge();\n\tif (nb < 0)\n\t\treturn nb;\n\n\tpr_info(\"Scanning NUMA topology in Northbridge %d\\n\", nb);\n\n\treg = read_pci_config(0, nb, 0, 0x60);\n\tnumnodes = ((reg >> 4) & 0xF) + 1;\n\tif (numnodes <= 1)\n\t\treturn -ENOENT;\n\n\tpr_info(\"Number of physical nodes %d\\n\", numnodes);\n\n\tprevbase = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tu64 base, limit;\n\n\t\tbase = read_pci_config(0, nb, 1, 0x40 + i*8);\n\t\tlimit = read_pci_config(0, nb, 1, 0x44 + i*8);\n\n\t\tnodeids[i] = nodeid = limit & 7;\n\t\tif ((base & 3) == 0) {\n\t\t\tif (i < numnodes)\n\t\t\t\tpr_info(\"Skipping disabled node %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodeid >= numnodes) {\n\t\t\tpr_info(\"Ignoring excess node %d (%Lx:%Lx)\\n\", nodeid,\n\t\t\t\tbase, limit);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!limit) {\n\t\t\tpr_info(\"Skipping node entry %d (base %Lx)\\n\",\n\t\t\t\ti, base);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((base >> 8) & 3 || (limit >> 8) & 3) {\n\t\t\tpr_err(\"Node %d using interleaving mode %Lx/%Lx\\n\",\n\t\t\t       nodeid, (base >> 8) & 3, (limit >> 8) & 3);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (node_isset(nodeid, numa_nodes_parsed)) {\n\t\t\tpr_info(\"Node %d already present, skipping\\n\",\n\t\t\t\tnodeid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlimit >>= 16;\n\t\tlimit++;\n\t\tlimit <<= 24;\n\n\t\tif (limit > end)\n\t\t\tlimit = end;\n\t\tif (limit <= base)\n\t\t\tcontinue;\n\n\t\tbase >>= 16;\n\t\tbase <<= 24;\n\n\t\tif (base < start)\n\t\t\tbase = start;\n\t\tif (limit > end)\n\t\t\tlimit = end;\n\t\tif (limit == base) {\n\t\t\tpr_err(\"Empty node %d\\n\", nodeid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (limit < base) {\n\t\t\tpr_err(\"Node %d bogus settings %Lx-%Lx.\\n\",\n\t\t\t       nodeid, base, limit);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (prevbase > base) {\n\t\t\tpr_err(\"Node map not sorted %Lx,%Lx\\n\",\n\t\t\t       prevbase, base);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpr_info(\"Node %d MemBase %016Lx Limit %016Lx\\n\",\n\t\t\tnodeid, base, limit);\n\n\t\tprevbase = base;\n\t\tnuma_add_memblk(nodeid, base, limit);\n\t\tnode_set(nodeid, numa_nodes_parsed);\n\t}\n\n\tif (nodes_empty(numa_nodes_parsed))\n\t\treturn -ENOENT;\n\n\t \n\tbits = boot_cpu_data.x86_coreid_bits;\n\tcores = 1 << bits;\n\tapicid_base = 0;\n\n\t \n\tearly_get_smp_config();\n\n\tif (boot_cpu_physical_apicid > 0) {\n\t\tpr_info(\"BSP APIC ID: %02x\\n\", boot_cpu_physical_apicid);\n\t\tapicid_base = boot_cpu_physical_apicid;\n\t}\n\n\tfor_each_node_mask(i, numa_nodes_parsed)\n\t\tfor (j = apicid_base; j < cores + apicid_base; j++)\n\t\t\tset_apicid_to_node((i << bits) + j, i);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}