{
  "module_name": "kaslr.c",
  "hash_id": "7e21fddcdad84c3448040883041e4ccd2db962b9cb9e65fed107895ca10bedee",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/kaslr.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/memblock.h>\n#include <linux/pgtable.h>\n\n#include <asm/setup.h>\n#include <asm/kaslr.h>\n\n#include \"mm_internal.h\"\n\n#define TB_SHIFT 40\n\n \nstatic const unsigned long vaddr_end = CPU_ENTRY_AREA_BASE;\n\n \nstatic __initdata struct kaslr_memory_region {\n\tunsigned long *base;\n\tunsigned long size_tb;\n} kaslr_regions[] = {\n\t{ &page_offset_base, 0 },\n\t{ &vmalloc_base, 0 },\n\t{ &vmemmap_base, 0 },\n};\n\n \nstatic inline unsigned long get_padding(struct kaslr_memory_region *region)\n{\n\treturn (region->size_tb << TB_SHIFT);\n}\n\n \nvoid __init kernel_randomize_memory(void)\n{\n\tsize_t i;\n\tunsigned long vaddr_start, vaddr;\n\tunsigned long rand, memory_tb;\n\tstruct rnd_state rand_state;\n\tunsigned long remain_entropy;\n\tunsigned long vmemmap_size;\n\n\tvaddr_start = pgtable_l5_enabled() ? __PAGE_OFFSET_BASE_L5 : __PAGE_OFFSET_BASE_L4;\n\tvaddr = vaddr_start;\n\n\t \n\tBUILD_BUG_ON(vaddr_start >= vaddr_end);\n\tBUILD_BUG_ON(vaddr_end != CPU_ENTRY_AREA_BASE);\n\tBUILD_BUG_ON(vaddr_end > __START_KERNEL_map);\n\n\tif (!kaslr_memory_enabled())\n\t\treturn;\n\n\tkaslr_regions[0].size_tb = 1 << (MAX_PHYSMEM_BITS - TB_SHIFT);\n\tkaslr_regions[1].size_tb = VMALLOC_SIZE_TB;\n\n\t \n\tBUG_ON(kaslr_regions[0].base != &page_offset_base);\n\tmemory_tb = DIV_ROUND_UP(max_pfn << PAGE_SHIFT, 1UL << TB_SHIFT) +\n\t\tCONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;\n\n\t \n\tif (memory_tb < kaslr_regions[0].size_tb)\n\t\tkaslr_regions[0].size_tb = memory_tb;\n\n\t \n\tvmemmap_size = (kaslr_regions[0].size_tb << (TB_SHIFT - PAGE_SHIFT)) *\n\t\t\tsizeof(struct page);\n\tkaslr_regions[2].size_tb = DIV_ROUND_UP(vmemmap_size, 1UL << TB_SHIFT);\n\n\t \n\tremain_entropy = vaddr_end - vaddr_start;\n\tfor (i = 0; i < ARRAY_SIZE(kaslr_regions); i++)\n\t\tremain_entropy -= get_padding(&kaslr_regions[i]);\n\n\tprandom_seed_state(&rand_state, kaslr_get_random_long(\"Memory\"));\n\n\tfor (i = 0; i < ARRAY_SIZE(kaslr_regions); i++) {\n\t\tunsigned long entropy;\n\n\t\t \n\t\tentropy = remain_entropy / (ARRAY_SIZE(kaslr_regions) - i);\n\t\tprandom_bytes_state(&rand_state, &rand, sizeof(rand));\n\t\tentropy = (rand % (entropy + 1)) & PUD_MASK;\n\t\tvaddr += entropy;\n\t\t*kaslr_regions[i].base = vaddr;\n\n\t\t \n\t\tvaddr += get_padding(&kaslr_regions[i]);\n\t\tvaddr = round_up(vaddr + 1, PUD_SIZE);\n\t\tremain_entropy -= entropy;\n\t}\n}\n\nvoid __meminit init_trampoline_kaslr(void)\n{\n\tpud_t *pud_page_tramp, *pud, *pud_tramp;\n\tp4d_t *p4d_page_tramp, *p4d, *p4d_tramp;\n\tunsigned long paddr, vaddr;\n\tpgd_t *pgd;\n\n\tpud_page_tramp = alloc_low_page();\n\n\t \n\tpaddr = 0;\n\tvaddr = (unsigned long)__va(paddr);\n\tpgd = pgd_offset_k(vaddr);\n\n\tp4d = p4d_offset(pgd, vaddr);\n\tpud = pud_offset(p4d, vaddr);\n\n\tpud_tramp = pud_page_tramp + pud_index(paddr);\n\t*pud_tramp = *pud;\n\n\tif (pgtable_l5_enabled()) {\n\t\tp4d_page_tramp = alloc_low_page();\n\n\t\tp4d_tramp = p4d_page_tramp + p4d_index(paddr);\n\n\t\tset_p4d(p4d_tramp,\n\t\t\t__p4d(_KERNPG_TABLE | __pa(pud_page_tramp)));\n\n\t\ttrampoline_pgd_entry =\n\t\t\t__pgd(_KERNPG_TABLE | __pa(p4d_page_tramp));\n\t} else {\n\t\ttrampoline_pgd_entry =\n\t\t\t__pgd(_KERNPG_TABLE | __pa(pud_page_tramp));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}