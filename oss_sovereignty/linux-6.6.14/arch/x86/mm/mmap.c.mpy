{
  "module_name": "mmap.c",
  "hash_id": "5b0891e8dec1a9fd155970f52661459f85ac9fbbefa46f6a48bd217a01eabb2b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/mmap.c",
  "human_readable_source": "\n \n\n#include <linux/personality.h>\n#include <linux/mm.h>\n#include <linux/random.h>\n#include <linux/limits.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/mm.h>\n#include <linux/compat.h>\n#include <linux/elf-randomize.h>\n#include <asm/elf.h>\n#include <asm/io.h>\n\n#include \"physaddr.h\"\n\nstruct va_alignment __read_mostly va_align = {\n\t.flags = -1,\n};\n\nunsigned long task_size_32bit(void)\n{\n\treturn IA32_PAGE_OFFSET;\n}\n\nunsigned long task_size_64bit(int full_addr_space)\n{\n\treturn full_addr_space ? TASK_SIZE_MAX : DEFAULT_MAP_WINDOW;\n}\n\nstatic unsigned long stack_maxrandom_size(unsigned long task_size)\n{\n\tunsigned long max = 0;\n\tif (current->flags & PF_RANDOMIZE) {\n\t\tmax = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());\n\t\tmax <<= PAGE_SHIFT;\n\t}\n\n\treturn max;\n}\n\n#ifdef CONFIG_COMPAT\n# define mmap32_rnd_bits  mmap_rnd_compat_bits\n# define mmap64_rnd_bits  mmap_rnd_bits\n#else\n# define mmap32_rnd_bits  mmap_rnd_bits\n# define mmap64_rnd_bits  mmap_rnd_bits\n#endif\n\n#define SIZE_128M    (128 * 1024 * 1024UL)\n\nstatic int mmap_is_legacy(void)\n{\n\tif (current->personality & ADDR_COMPAT_LAYOUT)\n\t\treturn 1;\n\n\treturn sysctl_legacy_va_layout;\n}\n\nstatic unsigned long arch_rnd(unsigned int rndbits)\n{\n\tif (!(current->flags & PF_RANDOMIZE))\n\t\treturn 0;\n\treturn (get_random_long() & ((1UL << rndbits) - 1)) << PAGE_SHIFT;\n}\n\nunsigned long arch_mmap_rnd(void)\n{\n\treturn arch_rnd(mmap_is_ia32() ? mmap32_rnd_bits : mmap64_rnd_bits);\n}\n\nstatic unsigned long mmap_base(unsigned long rnd, unsigned long task_size,\n\t\t\t       struct rlimit *rlim_stack)\n{\n\tunsigned long gap = rlim_stack->rlim_cur;\n\tunsigned long pad = stack_maxrandom_size(task_size) + stack_guard_gap;\n\tunsigned long gap_min, gap_max;\n\n\t \n\tif (gap + pad > gap)\n\t\tgap += pad;\n\n\t \n\tgap_min = SIZE_128M;\n\tgap_max = (task_size / 6) * 5;\n\n\tif (gap < gap_min)\n\t\tgap = gap_min;\n\telse if (gap > gap_max)\n\t\tgap = gap_max;\n\n\treturn PAGE_ALIGN(task_size - gap - rnd);\n}\n\nstatic unsigned long mmap_legacy_base(unsigned long rnd,\n\t\t\t\t      unsigned long task_size)\n{\n\treturn __TASK_UNMAPPED_BASE(task_size) + rnd;\n}\n\n \nstatic void arch_pick_mmap_base(unsigned long *base, unsigned long *legacy_base,\n\t\tunsigned long random_factor, unsigned long task_size,\n\t\tstruct rlimit *rlim_stack)\n{\n\t*legacy_base = mmap_legacy_base(random_factor, task_size);\n\tif (mmap_is_legacy())\n\t\t*base = *legacy_base;\n\telse\n\t\t*base = mmap_base(random_factor, task_size, rlim_stack);\n}\n\nvoid arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)\n{\n\tif (mmap_is_legacy())\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\telse\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\n\tarch_pick_mmap_base(&mm->mmap_base, &mm->mmap_legacy_base,\n\t\t\tarch_rnd(mmap64_rnd_bits), task_size_64bit(0),\n\t\t\trlim_stack);\n\n#ifdef CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES\n\t \n\tarch_pick_mmap_base(&mm->mmap_compat_base, &mm->mmap_compat_legacy_base,\n\t\t\tarch_rnd(mmap32_rnd_bits), task_size_32bit(),\n\t\t\trlim_stack);\n#endif\n}\n\nunsigned long get_mmap_base(int is_legacy)\n{\n\tstruct mm_struct *mm = current->mm;\n\n#ifdef CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES\n\tif (in_32bit_syscall()) {\n\t\treturn is_legacy ? mm->mmap_compat_legacy_base\n\t\t\t\t : mm->mmap_compat_base;\n\t}\n#endif\n\treturn is_legacy ? mm->mmap_legacy_base : mm->mmap_base;\n}\n\nconst char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}\n\n \nbool mmap_address_hint_valid(unsigned long addr, unsigned long len)\n{\n\tif (TASK_SIZE - len < addr)\n\t\treturn false;\n\n\treturn (addr > DEFAULT_MAP_WINDOW) == (addr + len > DEFAULT_MAP_WINDOW);\n}\n\n \nint valid_phys_addr_range(phys_addr_t addr, size_t count)\n{\n\treturn addr + count - 1 <= __pa(high_memory - 1);\n}\n\n \nint valid_mmap_phys_addr_range(unsigned long pfn, size_t count)\n{\n\tphys_addr_t addr = (phys_addr_t)pfn << PAGE_SHIFT;\n\n\treturn phys_addr_valid(addr + count - 1);\n}\n\n \nbool pfn_modify_allowed(unsigned long pfn, pgprot_t prot)\n{\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF))\n\t\treturn true;\n\tif (!__pte_needs_invert(pgprot_val(prot)))\n\t\treturn true;\n\t \n\tif (pfn_valid(pfn))\n\t\treturn true;\n\tif (pfn >= l1tf_pfn_limit() && !capable(CAP_SYS_ADMIN))\n\t\treturn false;\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}