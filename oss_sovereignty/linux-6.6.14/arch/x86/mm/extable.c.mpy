{
  "module_name": "extable.c",
  "hash_id": "fafa502733aeeeee05377b50634e6954fbfe1288e5282ca3c9e150179fc51265",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/extable.c",
  "human_readable_source": "\n#include <linux/extable.h>\n#include <linux/uaccess.h>\n#include <linux/sched/debug.h>\n#include <linux/bitfield.h>\n#include <xen/xen.h>\n\n#include <asm/fpu/api.h>\n#include <asm/sev.h>\n#include <asm/traps.h>\n#include <asm/kdebug.h>\n#include <asm/insn-eval.h>\n#include <asm/sgx.h>\n\nstatic inline unsigned long *pt_regs_nr(struct pt_regs *regs, int nr)\n{\n\tint reg_offset = pt_regs_offset(regs, nr);\n\tstatic unsigned long __dummy;\n\n\tif (WARN_ON_ONCE(reg_offset < 0))\n\t\treturn &__dummy;\n\n\treturn (unsigned long *)((unsigned long)regs + reg_offset);\n}\n\nstatic inline unsigned long\nex_fixup_addr(const struct exception_table_entry *x)\n{\n\treturn (unsigned long)&x->fixup + x->fixup;\n}\n\nstatic bool ex_handler_default(const struct exception_table_entry *e,\n\t\t\t       struct pt_regs *regs)\n{\n\tif (e->data & EX_FLAG_CLEAR_AX)\n\t\tregs->ax = 0;\n\tif (e->data & EX_FLAG_CLEAR_DX)\n\t\tregs->dx = 0;\n\n\tregs->ip = ex_fixup_addr(e);\n\treturn true;\n}\n\n \nstatic bool ex_handler_zeropad(const struct exception_table_entry *e,\n\t\t\t       struct pt_regs *regs,\n\t\t\t       unsigned long fault_addr)\n{\n\tstruct insn insn;\n\tconst unsigned long mask = sizeof(long) - 1;\n\tunsigned long offset, addr, next_ip, len;\n\tunsigned long *reg;\n\n\tnext_ip = ex_fixup_addr(e);\n\tlen = next_ip - regs->ip;\n\tif (len > MAX_INSN_SIZE)\n\t\treturn false;\n\n\tif (insn_decode(&insn, (void *) regs->ip, len, INSN_MODE_KERN))\n\t\treturn false;\n\tif (insn.length != len)\n\t\treturn false;\n\n\tif (insn.opcode.bytes[0] != 0x8b)\n\t\treturn false;\n\tif (insn.opnd_bytes != sizeof(long))\n\t\treturn false;\n\n\taddr = (unsigned long) insn_get_addr_ref(&insn, regs);\n\tif (addr == ~0ul)\n\t\treturn false;\n\n\toffset = addr & mask;\n\taddr = addr & ~mask;\n\tif (fault_addr != addr + sizeof(long))\n\t\treturn false;\n\n\treg = insn_get_modrm_reg_ptr(&insn, regs);\n\tif (!reg)\n\t\treturn false;\n\n\t*reg = *(unsigned long *)addr >> (offset * 8);\n\treturn ex_handler_default(e, regs);\n}\n\nstatic bool ex_handler_fault(const struct exception_table_entry *fixup,\n\t\t\t     struct pt_regs *regs, int trapnr)\n{\n\tregs->ax = trapnr;\n\treturn ex_handler_default(fixup, regs);\n}\n\nstatic bool ex_handler_sgx(const struct exception_table_entry *fixup,\n\t\t\t   struct pt_regs *regs, int trapnr)\n{\n\tregs->ax = trapnr | SGX_ENCLS_FAULT_FLAG;\n\treturn ex_handler_default(fixup, regs);\n}\n\n \nstatic bool ex_handler_fprestore(const struct exception_table_entry *fixup,\n\t\t\t\t struct pt_regs *regs)\n{\n\tregs->ip = ex_fixup_addr(fixup);\n\n\tWARN_ONCE(1, \"Bad FPU state detected at %pB, reinitializing FPU registers.\",\n\t\t  (void *)instruction_pointer(regs));\n\n\tfpu_reset_from_exception_fixup();\n\treturn true;\n}\n\n \nstatic bool gp_fault_address_ok(unsigned long fault_address)\n{\n#ifdef CONFIG_X86_64\n\t \n\tif (valid_user_address(fault_address))\n\t\treturn true;\n\n\t \n\tfault_address -= PAGE_SIZE;\n\tif (valid_user_address(fault_address))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic bool ex_handler_uaccess(const struct exception_table_entry *fixup,\n\t\t\t       struct pt_regs *regs, int trapnr,\n\t\t\t       unsigned long fault_address)\n{\n\tWARN_ONCE(trapnr == X86_TRAP_GP && !gp_fault_address_ok(fault_address),\n\t\t\"General protection fault in user access. Non-canonical address?\");\n\treturn ex_handler_default(fixup, regs);\n}\n\nstatic bool ex_handler_copy(const struct exception_table_entry *fixup,\n\t\t\t    struct pt_regs *regs, int trapnr)\n{\n\tWARN_ONCE(trapnr == X86_TRAP_GP, \"General protection fault in user access. Non-canonical address?\");\n\treturn ex_handler_fault(fixup, regs, trapnr);\n}\n\nstatic bool ex_handler_msr(const struct exception_table_entry *fixup,\n\t\t\t   struct pt_regs *regs, bool wrmsr, bool safe, int reg)\n{\n\tif (__ONCE_LITE_IF(!safe && wrmsr)) {\n\t\tpr_warn(\"unchecked MSR access error: WRMSR to 0x%x (tried to write 0x%08x%08x) at rIP: 0x%lx (%pS)\\n\",\n\t\t\t(unsigned int)regs->cx, (unsigned int)regs->dx,\n\t\t\t(unsigned int)regs->ax,  regs->ip, (void *)regs->ip);\n\t\tshow_stack_regs(regs);\n\t}\n\n\tif (__ONCE_LITE_IF(!safe && !wrmsr)) {\n\t\tpr_warn(\"unchecked MSR access error: RDMSR from 0x%x at rIP: 0x%lx (%pS)\\n\",\n\t\t\t(unsigned int)regs->cx, regs->ip, (void *)regs->ip);\n\t\tshow_stack_regs(regs);\n\t}\n\n\tif (!wrmsr) {\n\t\t \n\t\tregs->ax = 0;\n\t\tregs->dx = 0;\n\t}\n\n\tif (safe)\n\t\t*pt_regs_nr(regs, reg) = -EIO;\n\n\treturn ex_handler_default(fixup, regs);\n}\n\nstatic bool ex_handler_clear_fs(const struct exception_table_entry *fixup,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (static_cpu_has(X86_BUG_NULL_SEG))\n\t\tasm volatile (\"mov %0, %%fs\" : : \"rm\" (__USER_DS));\n\tasm volatile (\"mov %0, %%fs\" : : \"rm\" (0));\n\treturn ex_handler_default(fixup, regs);\n}\n\nstatic bool ex_handler_imm_reg(const struct exception_table_entry *fixup,\n\t\t\t       struct pt_regs *regs, int reg, int imm)\n{\n\t*pt_regs_nr(regs, reg) = (long)imm;\n\treturn ex_handler_default(fixup, regs);\n}\n\nstatic bool ex_handler_ucopy_len(const struct exception_table_entry *fixup,\n\t\t\t\t  struct pt_regs *regs, int trapnr,\n\t\t\t\t  unsigned long fault_address,\n\t\t\t\t  int reg, int imm)\n{\n\tregs->cx = imm * regs->cx + *pt_regs_nr(regs, reg);\n\treturn ex_handler_uaccess(fixup, regs, trapnr, fault_address);\n}\n\nint ex_get_fixup_type(unsigned long ip)\n{\n\tconst struct exception_table_entry *e = search_exception_tables(ip);\n\n\treturn e ? FIELD_GET(EX_DATA_TYPE_MASK, e->data) : EX_TYPE_NONE;\n}\n\nint fixup_exception(struct pt_regs *regs, int trapnr, unsigned long error_code,\n\t\t    unsigned long fault_addr)\n{\n\tconst struct exception_table_entry *e;\n\tint type, reg, imm;\n\n#ifdef CONFIG_PNPBIOS\n\tif (unlikely(SEGMENT_IS_PNP_CODE(regs->cs))) {\n\t\textern u32 pnp_bios_fault_eip, pnp_bios_fault_esp;\n\t\textern u32 pnp_bios_is_utter_crap;\n\t\tpnp_bios_is_utter_crap = 1;\n\t\tprintk(KERN_CRIT \"PNPBIOS fault.. attempting recovery.\\n\");\n\t\t__asm__ volatile(\n\t\t\t\"movl %0, %%esp\\n\\t\"\n\t\t\t\"jmp *%1\\n\\t\"\n\t\t\t: : \"g\" (pnp_bios_fault_esp), \"g\" (pnp_bios_fault_eip));\n\t\tpanic(\"do_trap: can't hit this\");\n\t}\n#endif\n\n\te = search_exception_tables(regs->ip);\n\tif (!e)\n\t\treturn 0;\n\n\ttype = FIELD_GET(EX_DATA_TYPE_MASK, e->data);\n\treg  = FIELD_GET(EX_DATA_REG_MASK,  e->data);\n\timm  = FIELD_GET(EX_DATA_IMM_MASK,  e->data);\n\n\tswitch (type) {\n\tcase EX_TYPE_DEFAULT:\n\tcase EX_TYPE_DEFAULT_MCE_SAFE:\n\t\treturn ex_handler_default(e, regs);\n\tcase EX_TYPE_FAULT:\n\tcase EX_TYPE_FAULT_MCE_SAFE:\n\t\treturn ex_handler_fault(e, regs, trapnr);\n\tcase EX_TYPE_UACCESS:\n\t\treturn ex_handler_uaccess(e, regs, trapnr, fault_addr);\n\tcase EX_TYPE_COPY:\n\t\treturn ex_handler_copy(e, regs, trapnr);\n\tcase EX_TYPE_CLEAR_FS:\n\t\treturn ex_handler_clear_fs(e, regs);\n\tcase EX_TYPE_FPU_RESTORE:\n\t\treturn ex_handler_fprestore(e, regs);\n\tcase EX_TYPE_BPF:\n\t\treturn ex_handler_bpf(e, regs);\n\tcase EX_TYPE_WRMSR:\n\t\treturn ex_handler_msr(e, regs, true, false, reg);\n\tcase EX_TYPE_RDMSR:\n\t\treturn ex_handler_msr(e, regs, false, false, reg);\n\tcase EX_TYPE_WRMSR_SAFE:\n\t\treturn ex_handler_msr(e, regs, true, true, reg);\n\tcase EX_TYPE_RDMSR_SAFE:\n\t\treturn ex_handler_msr(e, regs, false, true, reg);\n\tcase EX_TYPE_WRMSR_IN_MCE:\n\t\tex_handler_msr_mce(regs, true);\n\t\tbreak;\n\tcase EX_TYPE_RDMSR_IN_MCE:\n\t\tex_handler_msr_mce(regs, false);\n\t\tbreak;\n\tcase EX_TYPE_POP_REG:\n\t\tregs->sp += sizeof(long);\n\t\tfallthrough;\n\tcase EX_TYPE_IMM_REG:\n\t\treturn ex_handler_imm_reg(e, regs, reg, imm);\n\tcase EX_TYPE_FAULT_SGX:\n\t\treturn ex_handler_sgx(e, regs, trapnr);\n\tcase EX_TYPE_UCOPY_LEN:\n\t\treturn ex_handler_ucopy_len(e, regs, trapnr, fault_addr, reg, imm);\n\tcase EX_TYPE_ZEROPAD:\n\t\treturn ex_handler_zeropad(e, regs, fault_addr);\n\t}\n\tBUG();\n}\n\nextern unsigned int early_recursion_flag;\n\n \nvoid __init early_fixup_exception(struct pt_regs *regs, int trapnr)\n{\n\t \n\tif (trapnr == X86_TRAP_NMI)\n\t\treturn;\n\n\tif (early_recursion_flag > 2)\n\t\tgoto halt_loop;\n\n\t \n\tif (!xen_pv_domain() && regs->cs != __KERNEL_CS)\n\t\tgoto fail;\n\n\t \n\tif (fixup_exception(regs, trapnr, regs->orig_ax, 0))\n\t\treturn;\n\n\tif (trapnr == X86_TRAP_UD) {\n\t\tif (report_bug(regs->ip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\t \n\t\t\tregs->ip += LEN_UD2;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t}\n\nfail:\n\tearly_printk(\"PANIC: early exception 0x%02x IP %lx:%lx error %lx cr2 0x%lx\\n\",\n\t\t     (unsigned)trapnr, (unsigned long)regs->cs, regs->ip,\n\t\t     regs->orig_ax, read_cr2());\n\n\tshow_regs(regs);\n\nhalt_loop:\n\twhile (true)\n\t\thalt();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}