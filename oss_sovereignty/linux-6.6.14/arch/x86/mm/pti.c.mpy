{
  "module_name": "pti.c",
  "hash_id": "8df50e5fe28097e61b191f91c4ba364a0cc5ba6f373833d1d7e9e4ce9e4d31c6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/pti.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n\n#include <asm/cpufeature.h>\n#include <asm/hypervisor.h>\n#include <asm/vsyscall.h>\n#include <asm/cmdline.h>\n#include <asm/pti.h>\n#include <asm/tlbflush.h>\n#include <asm/desc.h>\n#include <asm/sections.h>\n#include <asm/set_memory.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt)     \"Kernel/User page tables isolation: \" fmt\n\n \n#ifndef __GFP_NOTRACK\n#define __GFP_NOTRACK\t0\n#endif\n\n \n#ifdef CONFIG_X86_64\n#define\tPTI_LEVEL_KERNEL_IMAGE\tPTI_CLONE_PMD\n#else\n#define\tPTI_LEVEL_KERNEL_IMAGE\tPTI_CLONE_PTE\n#endif\n\nstatic void __init pti_print_if_insecure(const char *reason)\n{\n\tif (boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))\n\t\tpr_info(\"%s\\n\", reason);\n}\n\nstatic void __init pti_print_if_secure(const char *reason)\n{\n\tif (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))\n\t\tpr_info(\"%s\\n\", reason);\n}\n\nstatic enum pti_mode {\n\tPTI_AUTO = 0,\n\tPTI_FORCE_OFF,\n\tPTI_FORCE_ON\n} pti_mode;\n\nvoid __init pti_check_boottime_disable(void)\n{\n\tchar arg[5];\n\tint ret;\n\n\t \n\tpti_mode = PTI_AUTO;\n\n\tif (hypervisor_is_type(X86_HYPER_XEN_PV)) {\n\t\tpti_mode = PTI_FORCE_OFF;\n\t\tpti_print_if_insecure(\"disabled on XEN PV.\");\n\t\treturn;\n\t}\n\n\tret = cmdline_find_option(boot_command_line, \"pti\", arg, sizeof(arg));\n\tif (ret > 0)  {\n\t\tif (ret == 3 && !strncmp(arg, \"off\", 3)) {\n\t\t\tpti_mode = PTI_FORCE_OFF;\n\t\t\tpti_print_if_insecure(\"disabled on command line.\");\n\t\t\treturn;\n\t\t}\n\t\tif (ret == 2 && !strncmp(arg, \"on\", 2)) {\n\t\t\tpti_mode = PTI_FORCE_ON;\n\t\t\tpti_print_if_secure(\"force enabled on command line.\");\n\t\t\tgoto enable;\n\t\t}\n\t\tif (ret == 4 && !strncmp(arg, \"auto\", 4)) {\n\t\t\tpti_mode = PTI_AUTO;\n\t\t\tgoto autosel;\n\t\t}\n\t}\n\n\tif (cmdline_find_option_bool(boot_command_line, \"nopti\") ||\n\t    cpu_mitigations_off()) {\n\t\tpti_mode = PTI_FORCE_OFF;\n\t\tpti_print_if_insecure(\"disabled on command line.\");\n\t\treturn;\n\t}\n\nautosel:\n\tif (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))\n\t\treturn;\nenable:\n\tsetup_force_cpu_cap(X86_FEATURE_PTI);\n}\n\npgd_t __pti_set_user_pgtbl(pgd_t *pgdp, pgd_t pgd)\n{\n\t \n\tif (!pgdp_maps_userspace(pgdp))\n\t\treturn pgd;\n\n\t \n\tkernel_to_user_pgdp(pgdp)->pgd = pgd.pgd;\n\n\t \n\tif ((pgd.pgd & (_PAGE_USER|_PAGE_PRESENT)) == (_PAGE_USER|_PAGE_PRESENT) &&\n\t    (__supported_pte_mask & _PAGE_NX))\n\t\tpgd.pgd |= _PAGE_NX;\n\n\t \n\treturn pgd;\n}\n\n \nstatic p4d_t *pti_user_pagetable_walk_p4d(unsigned long address)\n{\n\tpgd_t *pgd = kernel_to_user_pgdp(pgd_offset_k(address));\n\tgfp_t gfp = (GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);\n\n\tif (address < PAGE_OFFSET) {\n\t\tWARN_ONCE(1, \"attempt to walk user address\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pgd_none(*pgd)) {\n\t\tunsigned long new_p4d_page = __get_free_page(gfp);\n\t\tif (WARN_ON_ONCE(!new_p4d_page))\n\t\t\treturn NULL;\n\n\t\tset_pgd(pgd, __pgd(_KERNPG_TABLE | __pa(new_p4d_page)));\n\t}\n\tBUILD_BUG_ON(pgd_large(*pgd) != 0);\n\n\treturn p4d_offset(pgd, address);\n}\n\n \nstatic pmd_t *pti_user_pagetable_walk_pmd(unsigned long address)\n{\n\tgfp_t gfp = (GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\n\tp4d = pti_user_pagetable_walk_p4d(address);\n\tif (!p4d)\n\t\treturn NULL;\n\n\tBUILD_BUG_ON(p4d_large(*p4d) != 0);\n\tif (p4d_none(*p4d)) {\n\t\tunsigned long new_pud_page = __get_free_page(gfp);\n\t\tif (WARN_ON_ONCE(!new_pud_page))\n\t\t\treturn NULL;\n\n\t\tset_p4d(p4d, __p4d(_KERNPG_TABLE | __pa(new_pud_page)));\n\t}\n\n\tpud = pud_offset(p4d, address);\n\t \n\tif (pud_large(*pud)) {\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\tif (pud_none(*pud)) {\n\t\tunsigned long new_pmd_page = __get_free_page(gfp);\n\t\tif (WARN_ON_ONCE(!new_pmd_page))\n\t\t\treturn NULL;\n\n\t\tset_pud(pud, __pud(_KERNPG_TABLE | __pa(new_pmd_page)));\n\t}\n\n\treturn pmd_offset(pud, address);\n}\n\n \nstatic pte_t *pti_user_pagetable_walk_pte(unsigned long address)\n{\n\tgfp_t gfp = (GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpmd = pti_user_pagetable_walk_pmd(address);\n\tif (!pmd)\n\t\treturn NULL;\n\n\t \n\tif (pmd_large(*pmd)) {\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\tif (pmd_none(*pmd)) {\n\t\tunsigned long new_pte_page = __get_free_page(gfp);\n\t\tif (!new_pte_page)\n\t\t\treturn NULL;\n\n\t\tset_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(new_pte_page)));\n\t}\n\n\tpte = pte_offset_kernel(pmd, address);\n\tif (pte_flags(*pte) & _PAGE_USER) {\n\t\tWARN_ONCE(1, \"attempt to walk to user pte\\n\");\n\t\treturn NULL;\n\t}\n\treturn pte;\n}\n\n#ifdef CONFIG_X86_VSYSCALL_EMULATION\nstatic void __init pti_setup_vsyscall(void)\n{\n\tpte_t *pte, *target_pte;\n\tunsigned int level;\n\n\tpte = lookup_address(VSYSCALL_ADDR, &level);\n\tif (!pte || WARN_ON(level != PG_LEVEL_4K) || pte_none(*pte))\n\t\treturn;\n\n\ttarget_pte = pti_user_pagetable_walk_pte(VSYSCALL_ADDR);\n\tif (WARN_ON(!target_pte))\n\t\treturn;\n\n\t*target_pte = *pte;\n\tset_vsyscall_pgtable_user_bits(kernel_to_user_pgdp(swapper_pg_dir));\n}\n#else\nstatic void __init pti_setup_vsyscall(void) { }\n#endif\n\nenum pti_clone_level {\n\tPTI_CLONE_PMD,\n\tPTI_CLONE_PTE,\n};\n\nstatic void\npti_clone_pgtable(unsigned long start, unsigned long end,\n\t\t  enum pti_clone_level level)\n{\n\tunsigned long addr;\n\n\t \n\tfor (addr = start; addr < end;) {\n\t\tpte_t *pte, *target_pte;\n\t\tpmd_t *pmd, *target_pmd;\n\t\tpgd_t *pgd;\n\t\tp4d_t *p4d;\n\t\tpud_t *pud;\n\n\t\t \n\t\tif (addr < start)\n\t\t\tbreak;\n\n\t\tpgd = pgd_offset_k(addr);\n\t\tif (WARN_ON(pgd_none(*pgd)))\n\t\t\treturn;\n\t\tp4d = p4d_offset(pgd, addr);\n\t\tif (WARN_ON(p4d_none(*p4d)))\n\t\t\treturn;\n\n\t\tpud = pud_offset(p4d, addr);\n\t\tif (pud_none(*pud)) {\n\t\t\tWARN_ON_ONCE(addr & ~PUD_MASK);\n\t\t\taddr = round_up(addr + 1, PUD_SIZE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpmd = pmd_offset(pud, addr);\n\t\tif (pmd_none(*pmd)) {\n\t\t\tWARN_ON_ONCE(addr & ~PMD_MASK);\n\t\t\taddr = round_up(addr + 1, PMD_SIZE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_large(*pmd) || level == PTI_CLONE_PMD) {\n\t\t\ttarget_pmd = pti_user_pagetable_walk_pmd(addr);\n\t\t\tif (WARN_ON(!target_pmd))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (WARN_ON(!(pmd_flags(*pmd) & _PAGE_PRESENT)))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (boot_cpu_has(X86_FEATURE_PGE))\n\t\t\t\t*pmd = pmd_set_flags(*pmd, _PAGE_GLOBAL);\n\n\t\t\t \n\t\t\t*target_pmd = *pmd;\n\n\t\t\taddr += PMD_SIZE;\n\n\t\t} else if (level == PTI_CLONE_PTE) {\n\n\t\t\t \n\t\t\tpte = pte_offset_kernel(pmd, addr);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\taddr += PAGE_SIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (WARN_ON(!(pte_flags(*pte) & _PAGE_PRESENT)))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\ttarget_pte = pti_user_pagetable_walk_pte(addr);\n\t\t\tif (WARN_ON(!target_pte))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (boot_cpu_has(X86_FEATURE_PGE))\n\t\t\t\t*pte = pte_set_flags(*pte, _PAGE_GLOBAL);\n\n\t\t\t \n\t\t\t*target_pte = *pte;\n\n\t\t\taddr += PAGE_SIZE;\n\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_X86_64\n \nstatic void __init pti_clone_p4d(unsigned long addr)\n{\n\tp4d_t *kernel_p4d, *user_p4d;\n\tpgd_t *kernel_pgd;\n\n\tuser_p4d = pti_user_pagetable_walk_p4d(addr);\n\tif (!user_p4d)\n\t\treturn;\n\n\tkernel_pgd = pgd_offset_k(addr);\n\tkernel_p4d = p4d_offset(kernel_pgd, addr);\n\t*user_p4d = *kernel_p4d;\n}\n\n \nstatic void __init pti_clone_user_shared(void)\n{\n\tunsigned int cpu;\n\n\tpti_clone_p4d(CPU_ENTRY_AREA_BASE);\n\n\tfor_each_possible_cpu(cpu) {\n\t\t \n\n\t\tunsigned long va = (unsigned long)&per_cpu(cpu_tss_rw, cpu);\n\t\tphys_addr_t pa = per_cpu_ptr_to_phys((void *)va);\n\t\tpte_t *target_pte;\n\n\t\ttarget_pte = pti_user_pagetable_walk_pte(va);\n\t\tif (WARN_ON(!target_pte))\n\t\t\treturn;\n\n\t\t*target_pte = pfn_pte(pa >> PAGE_SHIFT, PAGE_KERNEL);\n\t}\n}\n\n#else  \n\n \nstatic void __init pti_clone_user_shared(void)\n{\n\tunsigned long start, end;\n\n\tstart = CPU_ENTRY_AREA_BASE;\n\tend   = start + (PAGE_SIZE * CPU_ENTRY_AREA_PAGES);\n\n\tpti_clone_pgtable(start, end, PTI_CLONE_PMD);\n}\n#endif  \n\n \nstatic void __init pti_setup_espfix64(void)\n{\n#ifdef CONFIG_X86_ESPFIX64\n\tpti_clone_p4d(ESPFIX_BASE_ADDR);\n#endif\n}\n\n \nstatic void pti_clone_entry_text(void)\n{\n\tpti_clone_pgtable((unsigned long) __entry_text_start,\n\t\t\t  (unsigned long) __entry_text_end,\n\t\t\t  PTI_CLONE_PMD);\n}\n\n \nstatic inline bool pti_kernel_image_global_ok(void)\n{\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_PCID))\n\t\treturn false;\n\n\t \n\tif (pti_mode != PTI_AUTO)\n\t\treturn false;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_K8))\n\t\treturn false;\n\n\t \n\tif (IS_ENABLED(CONFIG_RANDSTRUCT))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void pti_clone_kernel_text(void)\n{\n\t \n\tunsigned long start = PFN_ALIGN(_text);\n\tunsigned long end_clone  = (unsigned long)__end_rodata_aligned;\n\tunsigned long end_global = PFN_ALIGN((unsigned long)_etext);\n\n\tif (!pti_kernel_image_global_ok())\n\t\treturn;\n\n\tpr_debug(\"mapping partial kernel image into user address space\\n\");\n\n\t \n\tpti_clone_pgtable(start, end_clone, PTI_LEVEL_KERNEL_IMAGE);\n\n\t \n\n\t \n\tset_memory_global(start, (end_global - start) >> PAGE_SHIFT);\n}\n\nstatic void pti_set_kernel_image_nonglobal(void)\n{\n\t \n\tunsigned long start = PFN_ALIGN(_text);\n\tunsigned long end = ALIGN((unsigned long)_end, PMD_SIZE);\n\n\t \n\tset_memory_nonglobal(start, (end - start) >> PAGE_SHIFT);\n}\n\n \nvoid __init pti_init(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_PTI))\n\t\treturn;\n\n\tpr_info(\"enabled\\n\");\n\n#ifdef CONFIG_X86_32\n\t \n\tif (cpuid_ecx(0x1) & BIT(17)) {\n\t\t \n\t\tprintk(KERN_WARNING \"\\n\");\n\t\tprintk(KERN_WARNING \"************************************************************\\n\");\n\t\tprintk(KERN_WARNING \"** WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!  **\\n\");\n\t\tprintk(KERN_WARNING \"**                                                        **\\n\");\n\t\tprintk(KERN_WARNING \"** You are using 32-bit PTI on a 64-bit PCID-capable CPU. **\\n\");\n\t\tprintk(KERN_WARNING \"** Your performance will increase dramatically if you     **\\n\");\n\t\tprintk(KERN_WARNING \"** switch to a 64-bit kernel!                             **\\n\");\n\t\tprintk(KERN_WARNING \"**                                                        **\\n\");\n\t\tprintk(KERN_WARNING \"** WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!  **\\n\");\n\t\tprintk(KERN_WARNING \"************************************************************\\n\");\n\t}\n#endif\n\n\tpti_clone_user_shared();\n\n\t \n\tpti_set_kernel_image_nonglobal();\n\t \n\tpti_clone_entry_text();\n\tpti_setup_espfix64();\n\tpti_setup_vsyscall();\n}\n\n \nvoid pti_finalize(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_PTI))\n\t\treturn;\n\t \n\tpti_clone_entry_text();\n\tpti_clone_kernel_text();\n\n\tdebug_checkwx_user();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}