{
  "module_name": "numa.c",
  "hash_id": "3b3f792926cc565a2fbac54b2985349f9225f18efe87fe2ea138a5f1e8522cab",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/numa.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/ctype.h>\n#include <linux/nodemask.h>\n#include <linux/sched.h>\n#include <linux/topology.h>\n#include <linux/sort.h>\n\n#include <asm/e820/api.h>\n#include <asm/proto.h>\n#include <asm/dma.h>\n#include <asm/amd_nb.h>\n\n#include \"numa_internal.h\"\n\nint numa_off;\nnodemask_t numa_nodes_parsed __initdata;\n\nstruct pglist_data *node_data[MAX_NUMNODES] __read_mostly;\nEXPORT_SYMBOL(node_data);\n\nstatic struct numa_meminfo numa_meminfo __initdata_or_meminfo;\nstatic struct numa_meminfo numa_reserved_meminfo __initdata_or_meminfo;\n\nstatic int numa_distance_cnt;\nstatic u8 *numa_distance;\n\nstatic __init int numa_setup(char *opt)\n{\n\tif (!opt)\n\t\treturn -EINVAL;\n\tif (!strncmp(opt, \"off\", 3))\n\t\tnuma_off = 1;\n\tif (!strncmp(opt, \"fake=\", 5))\n\t\treturn numa_emu_cmdline(opt + 5);\n\tif (!strncmp(opt, \"noacpi\", 6))\n\t\tdisable_srat();\n\tif (!strncmp(opt, \"nohmat\", 6))\n\t\tdisable_hmat();\n\treturn 0;\n}\nearly_param(\"numa\", numa_setup);\n\n \ns16 __apicid_to_node[MAX_LOCAL_APIC] = {\n\t[0 ... MAX_LOCAL_APIC-1] = NUMA_NO_NODE\n};\n\nint numa_cpu_node(int cpu)\n{\n\tint apicid = early_per_cpu(x86_cpu_to_apicid, cpu);\n\n\tif (apicid != BAD_APICID)\n\t\treturn __apicid_to_node[apicid];\n\treturn NUMA_NO_NODE;\n}\n\ncpumask_var_t node_to_cpumask_map[MAX_NUMNODES];\nEXPORT_SYMBOL(node_to_cpumask_map);\n\n \nDEFINE_EARLY_PER_CPU(int, x86_cpu_to_node_map, NUMA_NO_NODE);\nEXPORT_EARLY_PER_CPU_SYMBOL(x86_cpu_to_node_map);\n\nvoid numa_set_node(int cpu, int node)\n{\n\tint *cpu_to_node_map = early_per_cpu_ptr(x86_cpu_to_node_map);\n\n\t \n\tif (cpu_to_node_map) {\n\t\tcpu_to_node_map[cpu] = node;\n\t\treturn;\n\t}\n\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\n\tif (cpu >= nr_cpu_ids || !cpu_possible(cpu)) {\n\t\tprintk(KERN_ERR \"numa_set_node: invalid cpu# (%d)\\n\", cpu);\n\t\tdump_stack();\n\t\treturn;\n\t}\n#endif\n\tper_cpu(x86_cpu_to_node_map, cpu) = node;\n\n\tset_cpu_numa_node(cpu, node);\n}\n\nvoid numa_clear_node(int cpu)\n{\n\tnuma_set_node(cpu, NUMA_NO_NODE);\n}\n\n \nvoid __init setup_node_to_cpumask_map(void)\n{\n\tunsigned int node;\n\n\t \n\tif (nr_node_ids == MAX_NUMNODES)\n\t\tsetup_nr_node_ids();\n\n\t \n\tfor (node = 0; node < nr_node_ids; node++)\n\t\talloc_bootmem_cpumask_var(&node_to_cpumask_map[node]);\n\n\t \n\tpr_debug(\"Node to cpumask map for %u nodes\\n\", nr_node_ids);\n}\n\nstatic int __init numa_add_memblk_to(int nid, u64 start, u64 end,\n\t\t\t\t     struct numa_meminfo *mi)\n{\n\t \n\tif (start == end)\n\t\treturn 0;\n\n\t \n\tif (start > end || nid < 0 || nid >= MAX_NUMNODES) {\n\t\tpr_warn(\"Warning: invalid memblk node %d [mem %#010Lx-%#010Lx]\\n\",\n\t\t\tnid, start, end - 1);\n\t\treturn 0;\n\t}\n\n\tif (mi->nr_blks >= NR_NODE_MEMBLKS) {\n\t\tpr_err(\"too many memblk ranges\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmi->blk[mi->nr_blks].start = start;\n\tmi->blk[mi->nr_blks].end = end;\n\tmi->blk[mi->nr_blks].nid = nid;\n\tmi->nr_blks++;\n\treturn 0;\n}\n\n \nvoid __init numa_remove_memblk_from(int idx, struct numa_meminfo *mi)\n{\n\tmi->nr_blks--;\n\tmemmove(&mi->blk[idx], &mi->blk[idx + 1],\n\t\t(mi->nr_blks - idx) * sizeof(mi->blk[0]));\n}\n\n \nstatic void __init numa_move_tail_memblk(struct numa_meminfo *dst, int idx,\n\t\t\t\t\t struct numa_meminfo *src)\n{\n\tdst->blk[dst->nr_blks++] = src->blk[idx];\n\tnuma_remove_memblk_from(idx, src);\n}\n\n \nint __init numa_add_memblk(int nid, u64 start, u64 end)\n{\n\treturn numa_add_memblk_to(nid, start, end, &numa_meminfo);\n}\n\n \nstatic void __init alloc_node_data(int nid)\n{\n\tconst size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);\n\tu64 nd_pa;\n\tvoid *nd;\n\tint tnid;\n\n\t \n\tnd_pa = memblock_phys_alloc_try_nid(nd_size, SMP_CACHE_BYTES, nid);\n\tif (!nd_pa) {\n\t\tpr_err(\"Cannot find %zu bytes in any node (initial node: %d)\\n\",\n\t\t       nd_size, nid);\n\t\treturn;\n\t}\n\tnd = __va(nd_pa);\n\n\t \n\tprintk(KERN_INFO \"NODE_DATA(%d) allocated [mem %#010Lx-%#010Lx]\\n\", nid,\n\t       nd_pa, nd_pa + nd_size - 1);\n\ttnid = early_pfn_to_nid(nd_pa >> PAGE_SHIFT);\n\tif (tnid != nid)\n\t\tprintk(KERN_INFO \"    NODE_DATA(%d) on node %d\\n\", nid, tnid);\n\n\tnode_data[nid] = nd;\n\tmemset(NODE_DATA(nid), 0, sizeof(pg_data_t));\n\n\tnode_set_online(nid);\n}\n\n \nint __init numa_cleanup_meminfo(struct numa_meminfo *mi)\n{\n\tconst u64 low = 0;\n\tconst u64 high = PFN_PHYS(max_pfn);\n\tint i, j, k;\n\n\t \n\tfor (i = 0; i < mi->nr_blks; i++) {\n\t\tstruct numa_memblk *bi = &mi->blk[i];\n\n\t\t \n\t\tif (!memblock_overlaps_region(&memblock.memory,\n\t\t\t\t\tbi->start, bi->end - bi->start)) {\n\t\t\tnuma_move_tail_memblk(&numa_reserved_meminfo, i--, mi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbi->start = max(bi->start, low);\n\n\t\t \n\t\tif (bi->end > high) {\n\t\t\tnuma_add_memblk_to(bi->nid, high, bi->end,\n\t\t\t\t\t   &numa_reserved_meminfo);\n\t\t\tbi->end = high;\n\t\t}\n\n\t\t \n\t\tif (bi->start >= bi->end)\n\t\t\tnuma_remove_memblk_from(i--, mi);\n\t}\n\n\t \n\tfor (i = 0; i < mi->nr_blks; i++) {\n\t\tstruct numa_memblk *bi = &mi->blk[i];\n\n\t\tfor (j = i + 1; j < mi->nr_blks; j++) {\n\t\t\tstruct numa_memblk *bj = &mi->blk[j];\n\t\t\tu64 start, end;\n\n\t\t\t \n\t\t\tif (bi->end > bj->start && bi->start < bj->end) {\n\t\t\t\tif (bi->nid != bj->nid) {\n\t\t\t\t\tpr_err(\"node %d [mem %#010Lx-%#010Lx] overlaps with node %d [mem %#010Lx-%#010Lx]\\n\",\n\t\t\t\t\t       bi->nid, bi->start, bi->end - 1,\n\t\t\t\t\t       bj->nid, bj->start, bj->end - 1);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tpr_warn(\"Warning: node %d [mem %#010Lx-%#010Lx] overlaps with itself [mem %#010Lx-%#010Lx]\\n\",\n\t\t\t\t\tbi->nid, bi->start, bi->end - 1,\n\t\t\t\t\tbj->start, bj->end - 1);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (bi->nid != bj->nid)\n\t\t\t\tcontinue;\n\t\t\tstart = min(bi->start, bj->start);\n\t\t\tend = max(bi->end, bj->end);\n\t\t\tfor (k = 0; k < mi->nr_blks; k++) {\n\t\t\t\tstruct numa_memblk *bk = &mi->blk[k];\n\n\t\t\t\tif (bi->nid == bk->nid)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (start < bk->end && end > bk->start)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k < mi->nr_blks)\n\t\t\t\tcontinue;\n\t\t\tprintk(KERN_INFO \"NUMA: Node %d [mem %#010Lx-%#010Lx] + [mem %#010Lx-%#010Lx] -> [mem %#010Lx-%#010Lx]\\n\",\n\t\t\t       bi->nid, bi->start, bi->end - 1, bj->start,\n\t\t\t       bj->end - 1, start, end - 1);\n\t\t\tbi->start = start;\n\t\t\tbi->end = end;\n\t\t\tnuma_remove_memblk_from(j--, mi);\n\t\t}\n\t}\n\n\t \n\tfor (i = mi->nr_blks; i < ARRAY_SIZE(mi->blk); i++) {\n\t\tmi->blk[i].start = mi->blk[i].end = 0;\n\t\tmi->blk[i].nid = NUMA_NO_NODE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __init numa_nodemask_from_meminfo(nodemask_t *nodemask,\n\t\t\t\t\t      const struct numa_meminfo *mi)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mi->blk); i++)\n\t\tif (mi->blk[i].start != mi->blk[i].end &&\n\t\t    mi->blk[i].nid != NUMA_NO_NODE)\n\t\t\tnode_set(mi->blk[i].nid, *nodemask);\n}\n\n \nvoid __init numa_reset_distance(void)\n{\n\tsize_t size = numa_distance_cnt * numa_distance_cnt * sizeof(numa_distance[0]);\n\n\t \n\tif (numa_distance_cnt)\n\t\tmemblock_free(numa_distance, size);\n\tnuma_distance_cnt = 0;\n\tnuma_distance = NULL;\t \n}\n\nstatic int __init numa_alloc_distance(void)\n{\n\tnodemask_t nodes_parsed;\n\tsize_t size;\n\tint i, j, cnt = 0;\n\tu64 phys;\n\n\t \n\tnodes_parsed = numa_nodes_parsed;\n\tnuma_nodemask_from_meminfo(&nodes_parsed, &numa_meminfo);\n\n\tfor_each_node_mask(i, nodes_parsed)\n\t\tcnt = i;\n\tcnt++;\n\tsize = cnt * cnt * sizeof(numa_distance[0]);\n\n\tphys = memblock_phys_alloc_range(size, PAGE_SIZE, 0,\n\t\t\t\t\t PFN_PHYS(max_pfn_mapped));\n\tif (!phys) {\n\t\tpr_warn(\"Warning: can't allocate distance table!\\n\");\n\t\t \n\t\tnuma_distance = (void *)1LU;\n\t\treturn -ENOMEM;\n\t}\n\n\tnuma_distance = __va(phys);\n\tnuma_distance_cnt = cnt;\n\n\t \n\tfor (i = 0; i < cnt; i++)\n\t\tfor (j = 0; j < cnt; j++)\n\t\t\tnuma_distance[i * cnt + j] = i == j ?\n\t\t\t\tLOCAL_DISTANCE : REMOTE_DISTANCE;\n\tprintk(KERN_DEBUG \"NUMA: Initialized distance table, cnt=%d\\n\", cnt);\n\n\treturn 0;\n}\n\n \nvoid __init numa_set_distance(int from, int to, int distance)\n{\n\tif (!numa_distance && numa_alloc_distance() < 0)\n\t\treturn;\n\n\tif (from >= numa_distance_cnt || to >= numa_distance_cnt ||\n\t\t\tfrom < 0 || to < 0) {\n\t\tpr_warn_once(\"Warning: node ids are out of bound, from=%d to=%d distance=%d\\n\",\n\t\t\t     from, to, distance);\n\t\treturn;\n\t}\n\n\tif ((u8)distance != distance ||\n\t    (from == to && distance != LOCAL_DISTANCE)) {\n\t\tpr_warn_once(\"Warning: invalid distance parameter, from=%d to=%d distance=%d\\n\",\n\t\t\t     from, to, distance);\n\t\treturn;\n\t}\n\n\tnuma_distance[from * numa_distance_cnt + to] = distance;\n}\n\nint __node_distance(int from, int to)\n{\n\tif (from >= numa_distance_cnt || to >= numa_distance_cnt)\n\t\treturn from == to ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\treturn numa_distance[from * numa_distance_cnt + to];\n}\nEXPORT_SYMBOL(__node_distance);\n\n \nstatic bool __init numa_meminfo_cover_memory(const struct numa_meminfo *mi)\n{\n\tu64 numaram, e820ram;\n\tint i;\n\n\tnumaram = 0;\n\tfor (i = 0; i < mi->nr_blks; i++) {\n\t\tu64 s = mi->blk[i].start >> PAGE_SHIFT;\n\t\tu64 e = mi->blk[i].end >> PAGE_SHIFT;\n\t\tnumaram += e - s;\n\t\tnumaram -= __absent_pages_in_range(mi->blk[i].nid, s, e);\n\t\tif ((s64)numaram < 0)\n\t\t\tnumaram = 0;\n\t}\n\n\te820ram = max_pfn - absent_pages_in_range(0, max_pfn);\n\n\t \n\tif ((s64)(e820ram - numaram) >= (1 << (20 - PAGE_SHIFT))) {\n\t\tprintk(KERN_ERR \"NUMA: nodes only cover %LuMB of your %LuMB e820 RAM. Not used.\\n\",\n\t\t       (numaram << PAGE_SHIFT) >> 20,\n\t\t       (e820ram << PAGE_SHIFT) >> 20);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void __init numa_clear_kernel_node_hotplug(void)\n{\n\tnodemask_t reserved_nodemask = NODE_MASK_NONE;\n\tstruct memblock_region *mb_region;\n\tint i;\n\n\t \n\tfor (i = 0; i < numa_meminfo.nr_blks; i++) {\n\t\tstruct numa_memblk *mb = numa_meminfo.blk + i;\n\t\tint ret;\n\n\t\tret = memblock_set_node(mb->start, mb->end - mb->start, &memblock.reserved, mb->nid);\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\t \n\tfor_each_reserved_mem_region(mb_region) {\n\t\tint nid = memblock_get_region_node(mb_region);\n\n\t\tif (nid != MAX_NUMNODES)\n\t\t\tnode_set(nid, reserved_nodemask);\n\t}\n\n\t \n\tfor (i = 0; i < numa_meminfo.nr_blks; i++) {\n\t\tstruct numa_memblk *mb = numa_meminfo.blk + i;\n\n\t\tif (!node_isset(mb->nid, reserved_nodemask))\n\t\t\tcontinue;\n\n\t\tmemblock_clear_hotplug(mb->start, mb->end - mb->start);\n\t}\n}\n\nstatic int __init numa_register_memblks(struct numa_meminfo *mi)\n{\n\tint i, nid;\n\n\t \n\tnode_possible_map = numa_nodes_parsed;\n\tnuma_nodemask_from_meminfo(&node_possible_map, mi);\n\tif (WARN_ON(nodes_empty(node_possible_map)))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < mi->nr_blks; i++) {\n\t\tstruct numa_memblk *mb = &mi->blk[i];\n\t\tmemblock_set_node(mb->start, mb->end - mb->start,\n\t\t\t\t  &memblock.memory, mb->nid);\n\t}\n\n\t \n\tnuma_clear_kernel_node_hotplug();\n\n\t \n\tif (IS_ENABLED(NODE_NOT_IN_PAGE_FLAGS)) {\n\t\tunsigned long pfn_align = node_map_pfn_alignment();\n\n\t\tif (pfn_align && pfn_align < PAGES_PER_SECTION) {\n\t\t\tpr_warn(\"Node alignment %LuMB < min %LuMB, rejecting NUMA config\\n\",\n\t\t\t\tPFN_PHYS(pfn_align) >> 20,\n\t\t\t\tPFN_PHYS(PAGES_PER_SECTION) >> 20);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!numa_meminfo_cover_memory(mi))\n\t\treturn -EINVAL;\n\n\t \n\tfor_each_node_mask(nid, node_possible_map) {\n\t\tu64 start = PFN_PHYS(max_pfn);\n\t\tu64 end = 0;\n\n\t\tfor (i = 0; i < mi->nr_blks; i++) {\n\t\t\tif (nid != mi->blk[i].nid)\n\t\t\t\tcontinue;\n\t\t\tstart = min(mi->blk[i].start, start);\n\t\t\tend = max(mi->blk[i].end, end);\n\t\t}\n\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\talloc_node_data(nid);\n\t}\n\n\t \n\tmemblock_dump_all();\n\treturn 0;\n}\n\n \nstatic void __init numa_init_array(void)\n{\n\tint rr, i;\n\n\trr = first_node(node_online_map);\n\tfor (i = 0; i < nr_cpu_ids; i++) {\n\t\tif (early_cpu_to_node(i) != NUMA_NO_NODE)\n\t\t\tcontinue;\n\t\tnuma_set_node(i, rr);\n\t\trr = next_node_in(rr, node_online_map);\n\t}\n}\n\nstatic int __init numa_init(int (*init_func)(void))\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < MAX_LOCAL_APIC; i++)\n\t\tset_apicid_to_node(i, NUMA_NO_NODE);\n\n\tnodes_clear(numa_nodes_parsed);\n\tnodes_clear(node_possible_map);\n\tnodes_clear(node_online_map);\n\tmemset(&numa_meminfo, 0, sizeof(numa_meminfo));\n\tWARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.memory,\n\t\t\t\t  MAX_NUMNODES));\n\tWARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.reserved,\n\t\t\t\t  MAX_NUMNODES));\n\t \n\tWARN_ON(memblock_clear_hotplug(0, ULLONG_MAX));\n\tnuma_reset_distance();\n\n\tret = init_func();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmemblock_set_bottom_up(false);\n\n\tret = numa_cleanup_meminfo(&numa_meminfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnuma_emulation(&numa_meminfo, numa_distance_cnt);\n\n\tret = numa_register_memblks(&numa_meminfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_cpu_ids; i++) {\n\t\tint nid = early_cpu_to_node(i);\n\n\t\tif (nid == NUMA_NO_NODE)\n\t\t\tcontinue;\n\t\tif (!node_online(nid))\n\t\t\tnuma_clear_node(i);\n\t}\n\tnuma_init_array();\n\n\treturn 0;\n}\n\n \nstatic int __init dummy_numa_init(void)\n{\n\tprintk(KERN_INFO \"%s\\n\",\n\t       numa_off ? \"NUMA turned off\" : \"No NUMA configuration found\");\n\tprintk(KERN_INFO \"Faking a node at [mem %#018Lx-%#018Lx]\\n\",\n\t       0LLU, PFN_PHYS(max_pfn) - 1);\n\n\tnode_set(0, numa_nodes_parsed);\n\tnuma_add_memblk(0, 0, PFN_PHYS(max_pfn));\n\n\treturn 0;\n}\n\n \nvoid __init x86_numa_init(void)\n{\n\tif (!numa_off) {\n#ifdef CONFIG_ACPI_NUMA\n\t\tif (!numa_init(x86_acpi_numa_init))\n\t\t\treturn;\n#endif\n#ifdef CONFIG_AMD_NUMA\n\t\tif (!numa_init(amd_numa_init))\n\t\t\treturn;\n#endif\n\t}\n\n\tnuma_init(dummy_numa_init);\n}\n\n\n \nvoid __init init_gi_nodes(void)\n{\n\tint nid;\n\n\t \n\tfor_each_node_state(nid, N_GENERIC_INITIATOR)\n\t\tif (!node_online(nid))\n\t\t\tnode_set_online(nid);\n}\n\n \nvoid __init init_cpu_to_node(void)\n{\n\tint cpu;\n\tu16 *cpu_to_apicid = early_per_cpu_ptr(x86_cpu_to_apicid);\n\n\tBUG_ON(cpu_to_apicid == NULL);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint node = numa_cpu_node(cpu);\n\n\t\tif (node == NUMA_NO_NODE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!node_online(node))\n\t\t\tnode_set_online(node);\n\n\t\tnuma_set_node(cpu, node);\n\t}\n}\n\n#ifndef CONFIG_DEBUG_PER_CPU_MAPS\n\n# ifndef CONFIG_NUMA_EMU\nvoid numa_add_cpu(int cpu)\n{\n\tcpumask_set_cpu(cpu, node_to_cpumask_map[early_cpu_to_node(cpu)]);\n}\n\nvoid numa_remove_cpu(int cpu)\n{\n\tcpumask_clear_cpu(cpu, node_to_cpumask_map[early_cpu_to_node(cpu)]);\n}\n# endif\t \n\n#else\t \n\nint __cpu_to_node(int cpu)\n{\n\tif (early_per_cpu_ptr(x86_cpu_to_node_map)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"cpu_to_node(%d): usage too early!\\n\", cpu);\n\t\tdump_stack();\n\t\treturn early_per_cpu_ptr(x86_cpu_to_node_map)[cpu];\n\t}\n\treturn per_cpu(x86_cpu_to_node_map, cpu);\n}\nEXPORT_SYMBOL(__cpu_to_node);\n\n \nint early_cpu_to_node(int cpu)\n{\n\tif (early_per_cpu_ptr(x86_cpu_to_node_map))\n\t\treturn early_per_cpu_ptr(x86_cpu_to_node_map)[cpu];\n\n\tif (!cpu_possible(cpu)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"early_cpu_to_node(%d): no per_cpu area!\\n\", cpu);\n\t\tdump_stack();\n\t\treturn NUMA_NO_NODE;\n\t}\n\treturn per_cpu(x86_cpu_to_node_map, cpu);\n}\n\nvoid debug_cpumask_set_cpu(int cpu, int node, bool enable)\n{\n\tstruct cpumask *mask;\n\n\tif (node == NUMA_NO_NODE) {\n\t\t \n\t\treturn;\n\t}\n\tmask = node_to_cpumask_map[node];\n\tif (!cpumask_available(mask)) {\n\t\tpr_err(\"node_to_cpumask_map[%i] NULL\\n\", node);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tcpumask_set_cpu(cpu, mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, mask);\n\n\tprintk(KERN_DEBUG \"%s cpu %d node %d: mask now %*pbl\\n\",\n\t\tenable ? \"numa_add_cpu\" : \"numa_remove_cpu\",\n\t\tcpu, node, cpumask_pr_args(mask));\n\treturn;\n}\n\n# ifndef CONFIG_NUMA_EMU\nstatic void numa_set_cpumask(int cpu, bool enable)\n{\n\tdebug_cpumask_set_cpu(cpu, early_cpu_to_node(cpu), enable);\n}\n\nvoid numa_add_cpu(int cpu)\n{\n\tnuma_set_cpumask(cpu, true);\n}\n\nvoid numa_remove_cpu(int cpu)\n{\n\tnuma_set_cpumask(cpu, false);\n}\n# endif\t \n\n \nconst struct cpumask *cpumask_of_node(int node)\n{\n\tif ((unsigned)node >= nr_node_ids) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"cpumask_of_node(%d): (unsigned)node >= nr_node_ids(%u)\\n\",\n\t\t\tnode, nr_node_ids);\n\t\tdump_stack();\n\t\treturn cpu_none_mask;\n\t}\n\tif (!cpumask_available(node_to_cpumask_map[node])) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"cpumask_of_node(%d): no node_to_cpumask_map!\\n\",\n\t\t\tnode);\n\t\tdump_stack();\n\t\treturn cpu_online_mask;\n\t}\n\treturn node_to_cpumask_map[node];\n}\nEXPORT_SYMBOL(cpumask_of_node);\n\n#endif\t \n\n#ifdef CONFIG_NUMA_KEEP_MEMINFO\nstatic int meminfo_to_nid(struct numa_meminfo *mi, u64 start)\n{\n\tint i;\n\n\tfor (i = 0; i < mi->nr_blks; i++)\n\t\tif (mi->blk[i].start <= start && mi->blk[i].end > start)\n\t\t\treturn mi->blk[i].nid;\n\treturn NUMA_NO_NODE;\n}\n\nint phys_to_target_node(phys_addr_t start)\n{\n\tint nid = meminfo_to_nid(&numa_meminfo, start);\n\n\t \n\tif (nid != NUMA_NO_NODE)\n\t\treturn nid;\n\n\treturn meminfo_to_nid(&numa_reserved_meminfo, start);\n}\nEXPORT_SYMBOL_GPL(phys_to_target_node);\n\nint memory_add_physaddr_to_nid(u64 start)\n{\n\tint nid = meminfo_to_nid(&numa_meminfo, start);\n\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_meminfo.blk[0].nid;\n\treturn nid;\n}\nEXPORT_SYMBOL_GPL(memory_add_physaddr_to_nid);\n\nstatic int __init cmp_memblk(const void *a, const void *b)\n{\n\tconst struct numa_memblk *ma = *(const struct numa_memblk **)a;\n\tconst struct numa_memblk *mb = *(const struct numa_memblk **)b;\n\n\treturn ma->start - mb->start;\n}\n\nstatic struct numa_memblk *numa_memblk_list[NR_NODE_MEMBLKS] __initdata;\n\n \n\nint __init numa_fill_memblks(u64 start, u64 end)\n{\n\tstruct numa_memblk **blk = &numa_memblk_list[0];\n\tstruct numa_meminfo *mi = &numa_meminfo;\n\tint count = 0;\n\tu64 prev_end;\n\n\t \n\tfor (int i = 0; i < mi->nr_blks; i++) {\n\t\tstruct numa_memblk *bi = &mi->blk[i];\n\n\t\tif (start < bi->end && end >= bi->start) {\n\t\t\tblk[count] = &mi->blk[i];\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count)\n\t\treturn NUMA_NO_MEMBLK;\n\n\t \n\tsort(&blk[0], count, sizeof(blk[0]), cmp_memblk, NULL);\n\n\t \n\tblk[0]->start = min(blk[0]->start, start);\n\tblk[count - 1]->end = max(blk[count - 1]->end, end);\n\n\t \n\tprev_end = blk[0]->end;\n\tfor (int i = 1; i < count; i++) {\n\t\tstruct numa_memblk *curr = blk[i];\n\n\t\tif (prev_end >= curr->start) {\n\t\t\tif (prev_end < curr->end)\n\t\t\t\tprev_end = curr->end;\n\t\t} else {\n\t\t\tcurr->start = prev_end;\n\t\t\tprev_end = curr->end;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}