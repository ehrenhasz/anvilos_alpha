{
  "module_name": "pkeys.c",
  "hash_id": "d4e7b9508bcc271c2a33a5c06e9e10617db3a6125240ae33c2c47038fc2d1105",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/pkeys.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\t\t \n#include <linux/mm_types.h>              \n#include <linux/pkeys.h>                 \n#include <uapi/asm-generic/mman-common.h>\n\n#include <asm/cpufeature.h>              \n#include <asm/mmu_context.h>             \n\nint __execute_only_pkey(struct mm_struct *mm)\n{\n\tbool need_to_set_mm_pkey = false;\n\tint execute_only_pkey = mm->context.execute_only_pkey;\n\tint ret;\n\n\t \n\tif (execute_only_pkey == -1) {\n\t\t \n\t\texecute_only_pkey = mm_pkey_alloc(mm);\n\t\tif (execute_only_pkey < 0)\n\t\t\treturn -1;\n\t\tneed_to_set_mm_pkey = true;\n\t}\n\n\t \n\tif (!need_to_set_mm_pkey &&\n\t    !__pkru_allows_read(read_pkru(), execute_only_pkey)) {\n\t\treturn execute_only_pkey;\n\t}\n\n\t \n\tret = arch_set_user_pkey_access(current, execute_only_pkey,\n\t\t\tPKEY_DISABLE_ACCESS);\n\t \n\tif (ret) {\n\t\tmm_set_pkey_free(mm, execute_only_pkey);\n\t\treturn -1;\n\t}\n\n\t \n\tif (need_to_set_mm_pkey)\n\t\tmm->context.execute_only_pkey = execute_only_pkey;\n\treturn execute_only_pkey;\n}\n\nstatic inline bool vma_is_pkey_exec_only(struct vm_area_struct *vma)\n{\n\t \n\tif ((vma->vm_flags & VM_ACCESS_FLAGS) != VM_EXEC)\n\t\treturn false;\n\tif (vma_pkey(vma) != vma->vm_mm->context.execute_only_pkey)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint __arch_override_mprotect_pkey(struct vm_area_struct *vma, int prot, int pkey)\n{\n\t \n\tif (pkey != -1)\n\t\treturn pkey;\n\n\t \n\tif (prot == PROT_EXEC) {\n\t\tpkey = execute_only_pkey(vma->vm_mm);\n\t\tif (pkey > 0)\n\t\t\treturn pkey;\n\t} else if (vma_is_pkey_exec_only(vma)) {\n\t\t \n\t\treturn ARCH_DEFAULT_PKEY;\n\t}\n\n\t \n\treturn vma_pkey(vma);\n}\n\n#define PKRU_AD_MASK(pkey)\t(PKRU_AD_BIT << ((pkey) * PKRU_BITS_PER_PKEY))\n\n \nu32 init_pkru_value = PKRU_AD_MASK( 1) | PKRU_AD_MASK( 2) |\n\t\t      PKRU_AD_MASK( 3) | PKRU_AD_MASK( 4) |\n\t\t      PKRU_AD_MASK( 5) | PKRU_AD_MASK( 6) |\n\t\t      PKRU_AD_MASK( 7) | PKRU_AD_MASK( 8) |\n\t\t      PKRU_AD_MASK( 9) | PKRU_AD_MASK(10) |\n\t\t      PKRU_AD_MASK(11) | PKRU_AD_MASK(12) |\n\t\t      PKRU_AD_MASK(13) | PKRU_AD_MASK(14) |\n\t\t      PKRU_AD_MASK(15);\n\nstatic ssize_t init_pkru_read_file(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"0x%x\\n\", init_pkru_value);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t init_pkru_write_file(struct file *file,\n\t\t const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tssize_t len;\n\tu32 new_init_pkru;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\t \n\tbuf[len] = '\\0';\n\tif (kstrtouint(buf, 0, &new_init_pkru))\n\t\treturn -EINVAL;\n\n\t \n\tif (new_init_pkru & (PKRU_AD_BIT|PKRU_WD_BIT))\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(init_pkru_value, new_init_pkru);\n\treturn count;\n}\n\nstatic const struct file_operations fops_init_pkru = {\n\t.read = init_pkru_read_file,\n\t.write = init_pkru_write_file,\n\t.llseek = default_llseek,\n};\n\nstatic int __init create_init_pkru_value(void)\n{\n\t \n\tif (!cpu_feature_enabled(X86_FEATURE_OSPKE))\n\t\treturn 0;\n\n\tdebugfs_create_file(\"init_pkru\", S_IRUSR | S_IWUSR,\n\t\t\tarch_debugfs_dir, NULL, &fops_init_pkru);\n\treturn 0;\n}\nlate_initcall(create_init_pkru_value);\n\nstatic __init int setup_init_pkru(char *opt)\n{\n\tu32 new_init_pkru;\n\n\tif (kstrtouint(opt, 0, &new_init_pkru))\n\t\treturn 1;\n\n\tWRITE_ONCE(init_pkru_value, new_init_pkru);\n\n\treturn 1;\n}\n__setup(\"init_pkru=\", setup_init_pkru);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}