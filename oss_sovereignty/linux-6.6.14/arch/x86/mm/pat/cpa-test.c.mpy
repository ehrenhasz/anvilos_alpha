{
  "module_name": "cpa-test.c",
  "hash_id": "5650f2c31acac0794b555d7caae660488ff0b594d433814244a6720d6fe9e9f8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/pat/cpa-test.c",
  "human_readable_source": "\n \n#include <linux/memblock.h>\n#include <linux/kthread.h>\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#include <asm/cacheflush.h>\n#include <asm/kdebug.h>\n\n \nstatic __read_mostly int print = 1;\n\nenum {\n\tNTEST\t\t\t= 3 * 100,\n\tNPAGES\t\t\t= 100,\n#ifdef CONFIG_X86_64\n\tLPS\t\t\t= (1 << PMD_SHIFT),\n#elif defined(CONFIG_X86_PAE)\n\tLPS\t\t\t= (1 << PMD_SHIFT),\n#else\n\tLPS\t\t\t= (1 << 22),\n#endif\n\tGPS\t\t\t= (1<<30)\n};\n\n#define PAGE_CPA_TEST\t__pgprot(_PAGE_CPA_TEST)\n\nstatic int pte_testbit(pte_t pte)\n{\n\treturn pte_flags(pte) & _PAGE_SOFTW1;\n}\n\nstruct split_state {\n\tlong lpg, gpg, spg, exec;\n\tlong min_exec, max_exec;\n};\n\nstatic int print_split(struct split_state *s)\n{\n\tlong i, expected, missed = 0;\n\tint err = 0;\n\n\ts->lpg = s->gpg = s->spg = s->exec = 0;\n\ts->min_exec = ~0UL;\n\ts->max_exec = 0;\n\tfor (i = 0; i < max_pfn_mapped; ) {\n\t\tunsigned long addr = (unsigned long)__va(i << PAGE_SHIFT);\n\t\tunsigned int level;\n\t\tpte_t *pte;\n\n\t\tpte = lookup_address(addr, &level);\n\t\tif (!pte) {\n\t\t\tmissed++;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (level == PG_LEVEL_1G && sizeof(long) == 8) {\n\t\t\ts->gpg++;\n\t\t\ti += GPS/PAGE_SIZE;\n\t\t} else if (level == PG_LEVEL_2M) {\n\t\t\tif ((pte_val(*pte) & _PAGE_PRESENT) && !(pte_val(*pte) & _PAGE_PSE)) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\"%lx level %d but not PSE %Lx\\n\",\n\t\t\t\t\taddr, level, (u64)pte_val(*pte));\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t\ts->lpg++;\n\t\t\ti += LPS/PAGE_SIZE;\n\t\t} else {\n\t\t\ts->spg++;\n\t\t\ti++;\n\t\t}\n\t\tif (!(pte_val(*pte) & _PAGE_NX)) {\n\t\t\ts->exec++;\n\t\t\tif (addr < s->min_exec)\n\t\t\t\ts->min_exec = addr;\n\t\t\tif (addr > s->max_exec)\n\t\t\t\ts->max_exec = addr;\n\t\t}\n\t}\n\tif (print) {\n\t\tprintk(KERN_INFO\n\t\t\t\" 4k %lu large %lu gb %lu x %lu[%lx-%lx] miss %lu\\n\",\n\t\t\ts->spg, s->lpg, s->gpg, s->exec,\n\t\t\ts->min_exec != ~0UL ? s->min_exec : 0,\n\t\t\ts->max_exec, missed);\n\t}\n\n\texpected = (s->gpg*GPS + s->lpg*LPS)/PAGE_SIZE + s->spg + missed;\n\tif (expected != i) {\n\t\tprintk(KERN_ERR \"CPA max_pfn_mapped %lu but expected %lu\\n\",\n\t\t\tmax_pfn_mapped, expected);\n\t\treturn 1;\n\t}\n\treturn err;\n}\n\nstatic unsigned long addr[NTEST];\nstatic unsigned int len[NTEST];\n\nstatic struct page *pages[NPAGES];\nstatic unsigned long addrs[NPAGES];\n\n \nstatic int pageattr_test(void)\n{\n\tstruct split_state sa, sb, sc;\n\tunsigned long *bm;\n\tpte_t *pte, pte0;\n\tint failed = 0;\n\tunsigned int level;\n\tint i, k;\n\tint err;\n\n\tif (print)\n\t\tprintk(KERN_INFO \"CPA self-test:\\n\");\n\n\tbm = vzalloc((max_pfn_mapped + 7) / 8);\n\tif (!bm) {\n\t\tprintk(KERN_ERR \"CPA Cannot vmalloc bitmap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfailed += print_split(&sa);\n\n\tfor (i = 0; i < NTEST; i++) {\n\t\tunsigned long pfn = get_random_u32_below(max_pfn_mapped);\n\n\t\taddr[i] = (unsigned long)__va(pfn << PAGE_SHIFT);\n\t\tlen[i] = get_random_u32_below(NPAGES);\n\t\tlen[i] = min_t(unsigned long, len[i], max_pfn_mapped - pfn - 1);\n\n\t\tif (len[i] == 0)\n\t\t\tlen[i] = 1;\n\n\t\tpte = NULL;\n\t\tpte0 = pfn_pte(0, __pgprot(0));  \n\n\t\tfor (k = 0; k < len[i]; k++) {\n\t\t\tpte = lookup_address(addr[i] + k*PAGE_SIZE, &level);\n\t\t\tif (!pte || pgprot_val(pte_pgprot(*pte)) == 0 ||\n\t\t\t    !(pte_val(*pte) & _PAGE_PRESENT)) {\n\t\t\t\taddr[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k == 0) {\n\t\t\t\tpte0 = *pte;\n\t\t\t} else {\n\t\t\t\tif (pgprot_val(pte_pgprot(*pte)) !=\n\t\t\t\t\tpgprot_val(pte_pgprot(pte0))) {\n\t\t\t\t\tlen[i] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (test_bit(pfn + k, bm)) {\n\t\t\t\tlen[i] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__set_bit(pfn + k, bm);\n\t\t\taddrs[k] = addr[i] + k*PAGE_SIZE;\n\t\t\tpages[k] = pfn_to_page(pfn + k);\n\t\t}\n\t\tif (!addr[i] || !pte || !k) {\n\t\t\taddr[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (i % 3) {\n\t\tcase 0:\n\t\t\terr = change_page_attr_set(&addr[i], len[i], PAGE_CPA_TEST, 0);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\terr = change_page_attr_set(addrs, len[1], PAGE_CPA_TEST, 1);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\terr = cpa_set_pages_array(pages, len[i], PAGE_CPA_TEST);\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"CPA %d failed %d\\n\", i, err);\n\t\t\tfailed++;\n\t\t}\n\n\t\tpte = lookup_address(addr[i], &level);\n\t\tif (!pte || !pte_testbit(*pte) || pte_huge(*pte)) {\n\t\t\tprintk(KERN_ERR \"CPA %lx: bad pte %Lx\\n\", addr[i],\n\t\t\t\tpte ? (u64)pte_val(*pte) : 0ULL);\n\t\t\tfailed++;\n\t\t}\n\t\tif (level != PG_LEVEL_4K) {\n\t\t\tprintk(KERN_ERR \"CPA %lx: unexpected level %d\\n\",\n\t\t\t\taddr[i], level);\n\t\t\tfailed++;\n\t\t}\n\n\t}\n\tvfree(bm);\n\n\tfailed += print_split(&sb);\n\n\tfor (i = 0; i < NTEST; i++) {\n\t\tif (!addr[i])\n\t\t\tcontinue;\n\t\tpte = lookup_address(addr[i], &level);\n\t\tif (!pte) {\n\t\t\tprintk(KERN_ERR \"CPA lookup of %lx failed\\n\", addr[i]);\n\t\t\tfailed++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = change_page_attr_clear(&addr[i], len[i], PAGE_CPA_TEST, 0);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"CPA reverting failed: %d\\n\", err);\n\t\t\tfailed++;\n\t\t}\n\t\tpte = lookup_address(addr[i], &level);\n\t\tif (!pte || pte_testbit(*pte)) {\n\t\t\tprintk(KERN_ERR \"CPA %lx: bad pte after revert %Lx\\n\",\n\t\t\t\taddr[i], pte ? (u64)pte_val(*pte) : 0ULL);\n\t\t\tfailed++;\n\t\t}\n\n\t}\n\n\tfailed += print_split(&sc);\n\n\tif (failed) {\n\t\tWARN(1, KERN_ERR \"NOT PASSED. Please report.\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tif (print)\n\t\t\tprintk(KERN_INFO \"ok.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int do_pageattr_test(void *__unused)\n{\n\twhile (!kthread_should_stop()) {\n\t\tschedule_timeout_interruptible(HZ*30);\n\t\tif (pageattr_test() < 0)\n\t\t\tbreak;\n\t\tif (print)\n\t\t\tprint--;\n\t}\n\treturn 0;\n}\n\nstatic int start_pageattr_test(void)\n{\n\tstruct task_struct *p;\n\n\tp = kthread_create(do_pageattr_test, NULL, \"pageattr-test\");\n\tif (!IS_ERR(p))\n\t\twake_up_process(p);\n\telse\n\t\tWARN_ON(1);\n\n\treturn 0;\n}\ndevice_initcall(start_pageattr_test);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}