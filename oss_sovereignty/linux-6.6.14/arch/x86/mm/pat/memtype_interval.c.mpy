{
  "module_name": "memtype_interval.c",
  "hash_id": "2b530620338b44457dfea5d0499d2fd8a81270b0acd8d17107af0920bcbae51b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/pat/memtype_interval.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/interval_tree_generic.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/pgtable.h>\n\n#include <asm/memtype.h>\n\n#include \"memtype.h\"\n\n \n\nstatic inline u64 interval_start(struct memtype *entry)\n{\n\treturn entry->start;\n}\n\nstatic inline u64 interval_end(struct memtype *entry)\n{\n\treturn entry->end - 1;\n}\n\nINTERVAL_TREE_DEFINE(struct memtype, rb, u64, subtree_max_end,\n\t\t     interval_start, interval_end,\n\t\t     static, interval)\n\nstatic struct rb_root_cached memtype_rbroot = RB_ROOT_CACHED;\n\nenum {\n\tMEMTYPE_EXACT_MATCH\t= 0,\n\tMEMTYPE_END_MATCH\t= 1\n};\n\nstatic struct memtype *memtype_match(u64 start, u64 end, int match_type)\n{\n\tstruct memtype *entry_match;\n\n\tentry_match = interval_iter_first(&memtype_rbroot, start, end-1);\n\n\twhile (entry_match != NULL && entry_match->start < end) {\n\t\tif ((match_type == MEMTYPE_EXACT_MATCH) &&\n\t\t    (entry_match->start == start) && (entry_match->end == end))\n\t\t\treturn entry_match;\n\n\t\tif ((match_type == MEMTYPE_END_MATCH) &&\n\t\t    (entry_match->start < start) && (entry_match->end == end))\n\t\t\treturn entry_match;\n\n\t\tentry_match = interval_iter_next(entry_match, start, end-1);\n\t}\n\n\treturn NULL;  \n}\n\nstatic int memtype_check_conflict(u64 start, u64 end,\n\t\t\t\t  enum page_cache_mode reqtype,\n\t\t\t\t  enum page_cache_mode *newtype)\n{\n\tstruct memtype *entry_match;\n\tenum page_cache_mode found_type = reqtype;\n\n\tentry_match = interval_iter_first(&memtype_rbroot, start, end-1);\n\tif (entry_match == NULL)\n\t\tgoto success;\n\n\tif (entry_match->type != found_type && newtype == NULL)\n\t\tgoto failure;\n\n\tdprintk(\"Overlap at 0x%Lx-0x%Lx\\n\", entry_match->start, entry_match->end);\n\tfound_type = entry_match->type;\n\n\tentry_match = interval_iter_next(entry_match, start, end-1);\n\twhile (entry_match) {\n\t\tif (entry_match->type != found_type)\n\t\t\tgoto failure;\n\n\t\tentry_match = interval_iter_next(entry_match, start, end-1);\n\t}\nsuccess:\n\tif (newtype)\n\t\t*newtype = found_type;\n\n\treturn 0;\n\nfailure:\n\tpr_info(\"x86/PAT: %s:%d conflicting memory types %Lx-%Lx %s<->%s\\n\",\n\t\tcurrent->comm, current->pid, start, end,\n\t\tcattr_name(found_type), cattr_name(entry_match->type));\n\n\treturn -EBUSY;\n}\n\nint memtype_check_insert(struct memtype *entry_new, enum page_cache_mode *ret_type)\n{\n\tint err = 0;\n\n\terr = memtype_check_conflict(entry_new->start, entry_new->end, entry_new->type, ret_type);\n\tif (err)\n\t\treturn err;\n\n\tif (ret_type)\n\t\tentry_new->type = *ret_type;\n\n\tinterval_insert(entry_new, &memtype_rbroot);\n\treturn 0;\n}\n\nstruct memtype *memtype_erase(u64 start, u64 end)\n{\n\tstruct memtype *entry_old;\n\n\t \n\tentry_old = memtype_match(start, end, MEMTYPE_EXACT_MATCH);\n\tif (!entry_old) {\n\t\tentry_old = memtype_match(start, end, MEMTYPE_END_MATCH);\n\t\tif (!entry_old)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (entry_old->start == start) {\n\t\t \n\t\tinterval_remove(entry_old, &memtype_rbroot);\n\t} else {\n\t\t \n\t\tinterval_remove(entry_old, &memtype_rbroot);\n\t\tentry_old->end = start;\n\t\tinterval_insert(entry_old, &memtype_rbroot);\n\n\t\treturn NULL;\n\t}\n\n\treturn entry_old;\n}\n\nstruct memtype *memtype_lookup(u64 addr)\n{\n\treturn interval_iter_first(&memtype_rbroot, addr, addr + PAGE_SIZE-1);\n}\n\n \n#ifdef CONFIG_DEBUG_FS\nint memtype_copy_nth_element(struct memtype *entry_out, loff_t pos)\n{\n\tstruct memtype *entry_match;\n\tint i = 1;\n\n\tentry_match = interval_iter_first(&memtype_rbroot, 0, ULONG_MAX);\n\n\twhile (entry_match && pos != i) {\n\t\tentry_match = interval_iter_next(entry_match, 0, ULONG_MAX);\n\t\ti++;\n\t}\n\n\tif (entry_match) {  \n\t\t*entry_out = *entry_match;\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}