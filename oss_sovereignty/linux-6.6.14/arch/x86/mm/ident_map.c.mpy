{
  "module_name": "ident_map.c",
  "hash_id": "15b2d173d73b6147fa6015fe781c8f53e1f629d474ac4c549d74bcd702cdc058",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/ident_map.c",
  "human_readable_source": "\n \n\nstatic void ident_pmd_init(struct x86_mapping_info *info, pmd_t *pmd_page,\n\t\t\t   unsigned long addr, unsigned long end)\n{\n\taddr &= PMD_MASK;\n\tfor (; addr < end; addr += PMD_SIZE) {\n\t\tpmd_t *pmd = pmd_page + pmd_index(addr);\n\n\t\tif (pmd_present(*pmd))\n\t\t\tcontinue;\n\n\t\tset_pmd(pmd, __pmd((addr - info->offset) | info->page_flag));\n\t}\n}\n\nstatic int ident_pud_init(struct x86_mapping_info *info, pud_t *pud_page,\n\t\t\t  unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\n\tfor (; addr < end; addr = next) {\n\t\tpud_t *pud = pud_page + pud_index(addr);\n\t\tpmd_t *pmd;\n\n\t\tnext = (addr & PUD_MASK) + PUD_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (info->direct_gbpages) {\n\t\t\tpud_t pudval;\n\n\t\t\tif (pud_present(*pud))\n\t\t\t\tcontinue;\n\n\t\t\taddr &= PUD_MASK;\n\t\t\tpudval = __pud((addr - info->offset) | info->page_flag);\n\t\t\tset_pud(pud, pudval);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_present(*pud)) {\n\t\t\tpmd = pmd_offset(pud, 0);\n\t\t\tident_pmd_init(info, pmd, addr, next);\n\t\t\tcontinue;\n\t\t}\n\t\tpmd = (pmd_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pmd)\n\t\t\treturn -ENOMEM;\n\t\tident_pmd_init(info, pmd, addr, next);\n\t\tset_pud(pud, __pud(__pa(pmd) | info->kernpg_flag));\n\t}\n\n\treturn 0;\n}\n\nstatic int ident_p4d_init(struct x86_mapping_info *info, p4d_t *p4d_page,\n\t\t\t  unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\tint result;\n\n\tfor (; addr < end; addr = next) {\n\t\tp4d_t *p4d = p4d_page + p4d_index(addr);\n\t\tpud_t *pud;\n\n\t\tnext = (addr & P4D_MASK) + P4D_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (p4d_present(*p4d)) {\n\t\t\tpud = pud_offset(p4d, 0);\n\t\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tcontinue;\n\t\t}\n\t\tpud = (pud_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pud)\n\t\t\treturn -ENOMEM;\n\n\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tset_p4d(p4d, __p4d(__pa(pud) | info->kernpg_flag));\n\t}\n\n\treturn 0;\n}\n\nint kernel_ident_mapping_init(struct x86_mapping_info *info, pgd_t *pgd_page,\n\t\t\t      unsigned long pstart, unsigned long pend)\n{\n\tunsigned long addr = pstart + info->offset;\n\tunsigned long end = pend + info->offset;\n\tunsigned long next;\n\tint result;\n\n\t \n\tif (!info->kernpg_flag)\n\t\tinfo->kernpg_flag = _KERNPG_TABLE;\n\n\t \n\tinfo->kernpg_flag &= __default_kernel_pte_mask;\n\n\tfor (; addr < end; addr = next) {\n\t\tpgd_t *pgd = pgd_page + pgd_index(addr);\n\t\tp4d_t *p4d;\n\n\t\tnext = (addr & PGDIR_MASK) + PGDIR_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (pgd_present(*pgd)) {\n\t\t\tp4d = p4d_offset(pgd, 0);\n\t\t\tresult = ident_p4d_init(info, p4d, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp4d = (p4d_t *)info->alloc_pgt_page(info->context);\n\t\tif (!p4d)\n\t\t\treturn -ENOMEM;\n\t\tresult = ident_p4d_init(info, p4d, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (pgtable_l5_enabled()) {\n\t\t\tset_pgd(pgd, __pgd(__pa(p4d) | info->kernpg_flag));\n\t\t} else {\n\t\t\t \n\t\t\tpud_t *pud = pud_offset(p4d, 0);\n\t\t\tset_pgd(pgd, __pgd(__pa(pud) | info->kernpg_flag));\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}