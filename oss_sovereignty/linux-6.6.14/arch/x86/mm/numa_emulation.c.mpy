{
  "module_name": "numa_emulation.c",
  "hash_id": "d62b4310a54a16cd0011dae9ca570222456b3cb7af28c469d7ed29c35c5d5066",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/numa_emulation.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/topology.h>\n#include <linux/memblock.h>\n#include <asm/dma.h>\n\n#include \"numa_internal.h\"\n\nstatic int emu_nid_to_phys[MAX_NUMNODES];\nstatic char *emu_cmdline __initdata;\n\nint __init numa_emu_cmdline(char *str)\n{\n\temu_cmdline = str;\n\treturn 0;\n}\n\nstatic int __init emu_find_memblk_by_nid(int nid, const struct numa_meminfo *mi)\n{\n\tint i;\n\n\tfor (i = 0; i < mi->nr_blks; i++)\n\t\tif (mi->blk[i].nid == nid)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\nstatic u64 __init mem_hole_size(u64 start, u64 end)\n{\n\tunsigned long start_pfn = PFN_UP(start);\n\tunsigned long end_pfn = PFN_DOWN(end);\n\n\tif (start_pfn < end_pfn)\n\t\treturn PFN_PHYS(absent_pages_in_range(start_pfn, end_pfn));\n\treturn 0;\n}\n\n \nstatic int __init emu_setup_memblk(struct numa_meminfo *ei,\n\t\t\t\t   struct numa_meminfo *pi,\n\t\t\t\t   int nid, int phys_blk, u64 size)\n{\n\tstruct numa_memblk *eb = &ei->blk[ei->nr_blks];\n\tstruct numa_memblk *pb = &pi->blk[phys_blk];\n\n\tif (ei->nr_blks >= NR_NODE_MEMBLKS) {\n\t\tpr_err(\"NUMA: Too many emulated memblks, failing emulation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tei->nr_blks++;\n\teb->start = pb->start;\n\teb->end = pb->start + size;\n\teb->nid = nid;\n\n\tif (emu_nid_to_phys[nid] == NUMA_NO_NODE)\n\t\temu_nid_to_phys[nid] = pb->nid;\n\n\tpb->start += size;\n\tif (pb->start >= pb->end) {\n\t\tWARN_ON_ONCE(pb->start > pb->end);\n\t\tnuma_remove_memblk_from(phys_blk, pi);\n\t}\n\n\tprintk(KERN_INFO \"Faking node %d at [mem %#018Lx-%#018Lx] (%LuMB)\\n\",\n\t       nid, eb->start, eb->end - 1, (eb->end - eb->start) >> 20);\n\treturn 0;\n}\n\n \nstatic int __init split_nodes_interleave(struct numa_meminfo *ei,\n\t\t\t\t\t struct numa_meminfo *pi,\n\t\t\t\t\t u64 addr, u64 max_addr, int nr_nodes)\n{\n\tnodemask_t physnode_mask = numa_nodes_parsed;\n\tu64 size;\n\tint big;\n\tint nid = 0;\n\tint i, ret;\n\n\tif (nr_nodes <= 0)\n\t\treturn -1;\n\tif (nr_nodes > MAX_NUMNODES) {\n\t\tpr_info(\"numa=fake=%d too large, reducing to %d\\n\",\n\t\t\tnr_nodes, MAX_NUMNODES);\n\t\tnr_nodes = MAX_NUMNODES;\n\t}\n\n\t \n\tsize = max_addr - addr - mem_hole_size(addr, max_addr);\n\tsize = PFN_PHYS((unsigned long)(size >> PAGE_SHIFT) / nr_nodes);\n\n\t \n\tbig = ((size & ~FAKE_NODE_MIN_HASH_MASK) * nr_nodes) /\n\t\tFAKE_NODE_MIN_SIZE;\n\n\tsize &= FAKE_NODE_MIN_HASH_MASK;\n\tif (!size) {\n\t\tpr_err(\"Not enough memory for each node.  \"\n\t\t\t\"NUMA emulation disabled.\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\twhile (!nodes_empty(physnode_mask)) {\n\t\tfor_each_node_mask(i, physnode_mask) {\n\t\t\tu64 dma32_end = PFN_PHYS(MAX_DMA32_PFN);\n\t\t\tu64 start, limit, end;\n\t\t\tint phys_blk;\n\n\t\t\tphys_blk = emu_find_memblk_by_nid(i, pi);\n\t\t\tif (phys_blk < 0) {\n\t\t\t\tnode_clear(i, physnode_mask);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstart = pi->blk[phys_blk].start;\n\t\t\tlimit = pi->blk[phys_blk].end;\n\t\t\tend = start + size;\n\n\t\t\tif (nid < big)\n\t\t\t\tend += FAKE_NODE_MIN_SIZE;\n\n\t\t\t \n\t\t\twhile (end - start - mem_hole_size(start, end) < size) {\n\t\t\t\tend += FAKE_NODE_MIN_SIZE;\n\t\t\t\tif (end > limit) {\n\t\t\t\t\tend = limit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (end < dma32_end && dma32_end - end -\n\t\t\t    mem_hole_size(end, dma32_end) < FAKE_NODE_MIN_SIZE)\n\t\t\t\tend = dma32_end;\n\n\t\t\t \n\t\t\tif (limit - end - mem_hole_size(end, limit) < size)\n\t\t\t\tend = limit;\n\n\t\t\tret = emu_setup_memblk(ei, pi, nid++ % nr_nodes,\n\t\t\t\t\t       phys_blk,\n\t\t\t\t\t       min(end, limit) - start);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic u64 __init find_end_of_node(u64 start, u64 max_addr, u64 size)\n{\n\tu64 end = start + size;\n\n\twhile (end - start - mem_hole_size(start, end) < size) {\n\t\tend += FAKE_NODE_MIN_SIZE;\n\t\tif (end > max_addr) {\n\t\t\tend = max_addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn end;\n}\n\nstatic u64 uniform_size(u64 max_addr, u64 base, u64 hole, int nr_nodes)\n{\n\tunsigned long max_pfn = PHYS_PFN(max_addr);\n\tunsigned long base_pfn = PHYS_PFN(base);\n\tunsigned long hole_pfns = PHYS_PFN(hole);\n\n\treturn PFN_PHYS((max_pfn - base_pfn - hole_pfns) / nr_nodes);\n}\n\n \nstatic int __init split_nodes_size_interleave_uniform(struct numa_meminfo *ei,\n\t\t\t\t\t      struct numa_meminfo *pi,\n\t\t\t\t\t      u64 addr, u64 max_addr, u64 size,\n\t\t\t\t\t      int nr_nodes, struct numa_memblk *pblk,\n\t\t\t\t\t      int nid)\n{\n\tnodemask_t physnode_mask = numa_nodes_parsed;\n\tint i, ret, uniform = 0;\n\tu64 min_size;\n\n\tif ((!size && !nr_nodes) || (nr_nodes && !pblk))\n\t\treturn -1;\n\n\t \n\tif (!nr_nodes)\n\t\tnr_nodes = MAX_NUMNODES;\n\telse {\n\t\tnodes_clear(physnode_mask);\n\t\tnode_set(pblk->nid, physnode_mask);\n\t\tuniform = 1;\n\t}\n\n\tif (uniform) {\n\t\tmin_size = uniform_size(max_addr, addr, 0, nr_nodes);\n\t\tsize = min_size;\n\t} else {\n\t\t \n\t\tmin_size = uniform_size(max_addr, addr,\n\t\t\t\tmem_hole_size(addr, max_addr), nr_nodes);\n\t}\n\tmin_size = ALIGN(max(min_size, FAKE_NODE_MIN_SIZE), FAKE_NODE_MIN_SIZE);\n\tif (size < min_size) {\n\t\tpr_err(\"Fake node size %LuMB too small, increasing to %LuMB\\n\",\n\t\t\tsize >> 20, min_size >> 20);\n\t\tsize = min_size;\n\t}\n\tsize = ALIGN_DOWN(size, FAKE_NODE_MIN_SIZE);\n\n\t \n\twhile (!nodes_empty(physnode_mask)) {\n\t\tfor_each_node_mask(i, physnode_mask) {\n\t\t\tu64 dma32_end = PFN_PHYS(MAX_DMA32_PFN);\n\t\t\tu64 start, limit, end;\n\t\t\tint phys_blk;\n\n\t\t\tphys_blk = emu_find_memblk_by_nid(i, pi);\n\t\t\tif (phys_blk < 0) {\n\t\t\t\tnode_clear(i, physnode_mask);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstart = pi->blk[phys_blk].start;\n\t\t\tlimit = pi->blk[phys_blk].end;\n\n\t\t\tif (uniform)\n\t\t\t\tend = start + size;\n\t\t\telse\n\t\t\t\tend = find_end_of_node(start, limit, size);\n\t\t\t \n\t\t\tif (end < dma32_end && dma32_end - end -\n\t\t\t    mem_hole_size(end, dma32_end) < FAKE_NODE_MIN_SIZE)\n\t\t\t\tend = dma32_end;\n\n\t\t\t \n\t\t\tif ((limit - end - mem_hole_size(end, limit) < size)\n\t\t\t\t\t&& !uniform)\n\t\t\t\tend = limit;\n\n\t\t\tret = emu_setup_memblk(ei, pi, nid++ % MAX_NUMNODES,\n\t\t\t\t\t       phys_blk,\n\t\t\t\t\t       min(end, limit) - start);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn nid;\n}\n\nstatic int __init split_nodes_size_interleave(struct numa_meminfo *ei,\n\t\t\t\t\t      struct numa_meminfo *pi,\n\t\t\t\t\t      u64 addr, u64 max_addr, u64 size)\n{\n\treturn split_nodes_size_interleave_uniform(ei, pi, addr, max_addr, size,\n\t\t\t0, NULL, 0);\n}\n\nstatic int __init setup_emu2phys_nid(int *dfl_phys_nid)\n{\n\tint i, max_emu_nid = 0;\n\n\t*dfl_phys_nid = NUMA_NO_NODE;\n\tfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++) {\n\t\tif (emu_nid_to_phys[i] != NUMA_NO_NODE) {\n\t\t\tmax_emu_nid = i;\n\t\t\tif (*dfl_phys_nid == NUMA_NO_NODE)\n\t\t\t\t*dfl_phys_nid = emu_nid_to_phys[i];\n\t\t}\n\t}\n\n\treturn max_emu_nid;\n}\n\n \nvoid __init numa_emulation(struct numa_meminfo *numa_meminfo, int numa_dist_cnt)\n{\n\tstatic struct numa_meminfo ei __initdata;\n\tstatic struct numa_meminfo pi __initdata;\n\tconst u64 max_addr = PFN_PHYS(max_pfn);\n\tu8 *phys_dist = NULL;\n\tsize_t phys_size = numa_dist_cnt * numa_dist_cnt * sizeof(phys_dist[0]);\n\tint max_emu_nid, dfl_phys_nid;\n\tint i, j, ret;\n\n\tif (!emu_cmdline)\n\t\tgoto no_emu;\n\n\tmemset(&ei, 0, sizeof(ei));\n\tpi = *numa_meminfo;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++)\n\t\temu_nid_to_phys[i] = NUMA_NO_NODE;\n\n\t \n\tif (strchr(emu_cmdline, 'U')) {\n\t\tnodemask_t physnode_mask = numa_nodes_parsed;\n\t\tunsigned long n;\n\t\tint nid = 0;\n\n\t\tn = simple_strtoul(emu_cmdline, &emu_cmdline, 0);\n\t\tret = -1;\n\t\tfor_each_node_mask(i, physnode_mask) {\n\t\t\t \n\t\t\tret = split_nodes_size_interleave_uniform(&ei, &pi,\n\t\t\t\t\tpi.blk[0].start, pi.blk[0].end, 0,\n\t\t\t\t\tn, &pi.blk[0], nid);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < n) {\n\t\t\t\tpr_info(\"%s: phys: %d only got %d of %ld nodes, failing\\n\",\n\t\t\t\t\t\t__func__, i, ret, n);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnid = ret;\n\t\t}\n\t} else if (strchr(emu_cmdline, 'M') || strchr(emu_cmdline, 'G')) {\n\t\tu64 size;\n\n\t\tsize = memparse(emu_cmdline, &emu_cmdline);\n\t\tret = split_nodes_size_interleave(&ei, &pi, 0, max_addr, size);\n\t} else {\n\t\tunsigned long n;\n\n\t\tn = simple_strtoul(emu_cmdline, &emu_cmdline, 0);\n\t\tret = split_nodes_interleave(&ei, &pi, 0, max_addr, n);\n\t}\n\tif (*emu_cmdline == ':')\n\t\temu_cmdline++;\n\n\tif (ret < 0)\n\t\tgoto no_emu;\n\n\tif (numa_cleanup_meminfo(&ei) < 0) {\n\t\tpr_warn(\"NUMA: Warning: constructed meminfo invalid, disabling emulation\\n\");\n\t\tgoto no_emu;\n\t}\n\n\t \n\tif (numa_dist_cnt) {\n\t\tu64 phys;\n\n\t\tphys = memblock_phys_alloc_range(phys_size, PAGE_SIZE, 0,\n\t\t\t\t\t\t PFN_PHYS(max_pfn_mapped));\n\t\tif (!phys) {\n\t\t\tpr_warn(\"NUMA: Warning: can't allocate copy of distance table, disabling emulation\\n\");\n\t\t\tgoto no_emu;\n\t\t}\n\t\tphys_dist = __va(phys);\n\n\t\tfor (i = 0; i < numa_dist_cnt; i++)\n\t\t\tfor (j = 0; j < numa_dist_cnt; j++)\n\t\t\t\tphys_dist[i * numa_dist_cnt + j] =\n\t\t\t\t\tnode_distance(i, j);\n\t}\n\n\t \n\tmax_emu_nid = setup_emu2phys_nid(&dfl_phys_nid);\n\n\t \n\t*numa_meminfo = ei;\n\n\t \n\tnodes_clear(numa_nodes_parsed);\n\tfor (i = 0; i < ARRAY_SIZE(ei.blk); i++)\n\t\tif (ei.blk[i].start != ei.blk[i].end &&\n\t\t    ei.blk[i].nid != NUMA_NO_NODE)\n\t\t\tnode_set(ei.blk[i].nid, numa_nodes_parsed);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(__apicid_to_node); i++) {\n\t\tif (__apicid_to_node[i] == NUMA_NO_NODE)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ARRAY_SIZE(emu_nid_to_phys); j++)\n\t\t\tif (__apicid_to_node[i] == emu_nid_to_phys[j])\n\t\t\t\tbreak;\n\t\t__apicid_to_node[i] = j < ARRAY_SIZE(emu_nid_to_phys) ? j : 0;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++)\n\t\tif (emu_nid_to_phys[i] == NUMA_NO_NODE)\n\t\t\temu_nid_to_phys[i] = dfl_phys_nid;\n\n\t \n\tnuma_reset_distance();\n\tfor (i = 0; i < max_emu_nid + 1; i++) {\n\t\tfor (j = 0; j < max_emu_nid + 1; j++) {\n\t\t\tint physi = emu_nid_to_phys[i];\n\t\t\tint physj = emu_nid_to_phys[j];\n\t\t\tint dist;\n\n\t\t\tif (get_option(&emu_cmdline, &dist) == 2)\n\t\t\t\t;\n\t\t\telse if (physi >= numa_dist_cnt || physj >= numa_dist_cnt)\n\t\t\t\tdist = physi == physj ?\n\t\t\t\t\tLOCAL_DISTANCE : REMOTE_DISTANCE;\n\t\t\telse\n\t\t\t\tdist = phys_dist[physi * numa_dist_cnt + physj];\n\n\t\t\tnuma_set_distance(i, j, dist);\n\t\t}\n\t}\n\n\t \n\tmemblock_free(phys_dist, phys_size);\n\treturn;\n\nno_emu:\n\t \n\tfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++)\n\t\temu_nid_to_phys[i] = i;\n}\n\n#ifndef CONFIG_DEBUG_PER_CPU_MAPS\nvoid numa_add_cpu(int cpu)\n{\n\tint physnid, nid;\n\n\tnid = early_cpu_to_node(cpu);\n\tBUG_ON(nid == NUMA_NO_NODE || !node_online(nid));\n\n\tphysnid = emu_nid_to_phys[nid];\n\n\t \n\tfor_each_online_node(nid)\n\t\tif (emu_nid_to_phys[nid] == physnid)\n\t\t\tcpumask_set_cpu(cpu, node_to_cpumask_map[nid]);\n}\n\nvoid numa_remove_cpu(int cpu)\n{\n\tint i;\n\n\tfor_each_online_node(i)\n\t\tcpumask_clear_cpu(cpu, node_to_cpumask_map[i]);\n}\n#else\t \nstatic void numa_set_cpumask(int cpu, bool enable)\n{\n\tint nid, physnid;\n\n\tnid = early_cpu_to_node(cpu);\n\tif (nid == NUMA_NO_NODE) {\n\t\t \n\t\treturn;\n\t}\n\n\tphysnid = emu_nid_to_phys[nid];\n\n\tfor_each_online_node(nid) {\n\t\tif (emu_nid_to_phys[nid] != physnid)\n\t\t\tcontinue;\n\n\t\tdebug_cpumask_set_cpu(cpu, nid, enable);\n\t}\n}\n\nvoid numa_add_cpu(int cpu)\n{\n\tnuma_set_cpumask(cpu, true);\n}\n\nvoid numa_remove_cpu(int cpu)\n{\n\tnuma_set_cpumask(cpu, false);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}