{
  "module_name": "hugetlbpage.c",
  "hash_id": "386c8df1321f513bae6aaa3de1da8e755fee3a490e82b1047ae0c353a60d4167",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/mm/hugetlbpage.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/err.h>\n#include <linux/sysctl.h>\n#include <linux/compat.h>\n#include <asm/mman.h>\n#include <asm/tlb.h>\n#include <asm/tlbflush.h>\n#include <asm/elf.h>\n\n \nint pmd_huge(pmd_t pmd)\n{\n\treturn !pmd_none(pmd) &&\n\t\t(pmd_val(pmd) & (_PAGE_PRESENT|_PAGE_PSE)) != _PAGE_PRESENT;\n}\n\n \nint pud_huge(pud_t pud)\n{\n#if CONFIG_PGTABLE_LEVELS > 2\n\treturn !pud_none(pud) &&\n\t\t(pud_val(pud) & (_PAGE_PRESENT|_PAGE_PSE)) != _PAGE_PRESENT;\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_HUGETLB_PAGE\nstatic unsigned long hugetlb_get_unmapped_area_bottomup(struct file *file,\n\t\tunsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tstruct hstate *h = hstate_file(file);\n\tstruct vm_unmapped_area_info info;\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = get_mmap_base(1);\n\n\t \n\tinfo.high_limit = in_32bit_syscall() ?\n\t\ttask_size_32bit() : task_size_64bit(addr > DEFAULT_MAP_WINDOW);\n\n\tinfo.align_mask = PAGE_MASK & ~huge_page_mask(h);\n\tinfo.align_offset = 0;\n\treturn vm_unmapped_area(&info);\n}\n\nstatic unsigned long hugetlb_get_unmapped_area_topdown(struct file *file,\n\t\tunsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tstruct hstate *h = hstate_file(file);\n\tstruct vm_unmapped_area_info info;\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = PAGE_SIZE;\n\tinfo.high_limit = get_mmap_base(0);\n\n\t \n\tif (addr > DEFAULT_MAP_WINDOW && !in_32bit_syscall())\n\t\tinfo.high_limit += TASK_SIZE_MAX - DEFAULT_MAP_WINDOW;\n\n\tinfo.align_mask = PAGE_MASK & ~huge_page_mask(h);\n\tinfo.align_offset = 0;\n\taddr = vm_unmapped_area(&info);\n\n\t \n\tif (addr & ~PAGE_MASK) {\n\t\tVM_BUG_ON(addr != -ENOMEM);\n\t\tinfo.flags = 0;\n\t\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\t\tinfo.high_limit = TASK_SIZE_LOW;\n\t\taddr = vm_unmapped_area(&info);\n\t}\n\n\treturn addr;\n}\n\nunsigned long\nhugetlb_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct hstate *h = hstate_file(file);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\n\tif (len & ~huge_page_mask(h))\n\t\treturn -EINVAL;\n\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (flags & MAP_FIXED) {\n\t\tif (prepare_hugepage_range(file, addr, len))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (addr) {\n\t\taddr &= huge_page_mask(h);\n\t\tif (!mmap_address_hint_valid(addr, len))\n\t\t\tgoto get_unmapped_area;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr + len <= vm_start_gap(vma))\n\t\t\treturn addr;\n\t}\n\nget_unmapped_area:\n\tif (mm->get_unmapped_area == arch_get_unmapped_area)\n\t\treturn hugetlb_get_unmapped_area_bottomup(file, addr, len,\n\t\t\t\tpgoff, flags);\n\telse\n\t\treturn hugetlb_get_unmapped_area_topdown(file, addr, len,\n\t\t\t\tpgoff, flags);\n}\n#endif  \n\n#ifdef CONFIG_X86_64\nbool __init arch_hugetlb_valid_size(unsigned long size)\n{\n\tif (size == PMD_SIZE)\n\t\treturn true;\n\telse if (size == PUD_SIZE && boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n#ifdef CONFIG_CONTIG_ALLOC\nstatic __init int gigantic_pages_init(void)\n{\n\t \n\tif (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\thugetlb_add_hstate(PUD_SHIFT - PAGE_SHIFT);\n\treturn 0;\n}\narch_initcall(gigantic_pages_init);\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}