{
  "module_name": "Kconfig.debug",
  "hash_id": "e0be4d308be5541da6d66ef403ff6b057b209f632762ecaf0f2896790bf76c9d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/Kconfig.debug",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\nconfig EARLY_PRINTK_USB\n\tbool\n\nconfig X86_VERBOSE_BOOTUP\n\tbool \"Enable verbose x86 bootup info messages\"\n\tdefault y\n\thelp\n\t  Enables the informational output from the decompression stage\n\t  (e.g. bzImage) of the boot. If you disable this you will still\n\t  see errors. Disable this if you want silent bootup.\n\nconfig EARLY_PRINTK\n\tbool \"Early printk\" if EXPERT\n\tdefault y\n\thelp\n\t  Write kernel log output directly into the VGA buffer or to a serial\n\t  port.\n\n\t  This is useful for kernel debugging when your machine crashes very\n\t  early before the console code is initialized. For normal operation\n\t  it is not recommended because it looks ugly and doesn't cooperate\n\t  with klogd/syslogd or the X server. You should normally say N here,\n\t  unless you want to debug such a crash.\n\nconfig EARLY_PRINTK_DBGP\n\tbool \"Early printk via EHCI debug port\"\n\tdepends on EARLY_PRINTK && PCI\n\tselect EARLY_PRINTK_USB\n\thelp\n\t  Write kernel log output directly into the EHCI debug port.\n\n\t  This is useful for kernel debugging when your machine crashes very\n\t  early before the console code is initialized. For normal operation\n\t  it is not recommended because it looks ugly and doesn't cooperate\n\t  with klogd/syslogd or the X server. You should normally say N here,\n\t  unless you want to debug such a crash. You need usb debug device.\n\nconfig EARLY_PRINTK_USB_XDBC\n\tbool \"Early printk via the xHCI debug port\"\n\tdepends on EARLY_PRINTK && PCI\n\tselect EARLY_PRINTK_USB\n\thelp\n\t  Write kernel log output directly into the xHCI debug port.\n\n\t  One use for this feature is kernel debugging, for example when your\n\t  machine crashes very early before the regular console code is\n\t  initialized. Other uses include simpler, lockless logging instead of\n\t  a full-blown printk console driver + klogd.\n\n\t  For normal production environments this is normally not recommended,\n\t  because it doesn't feed events into klogd/syslogd and doesn't try to\n\t  print anything on the screen.\n\n\t  You should normally say N here, unless you want to debug early\n\t  crashes or need a very simple printk logging facility.\n\nconfig EFI_PGT_DUMP\n\tbool \"Dump the EFI pagetable\"\n\tdepends on EFI\n\tselect PTDUMP_CORE\n\thelp\n\t  Enable this if you want to dump the EFI page table before\n\t  enabling virtual mode. This can be used to debug miscellaneous\n\t  issues with the mapping of the EFI runtime regions into that\n\t  table.\n\nconfig DEBUG_TLBFLUSH\n\tbool \"Set upper limit of TLB entries to flush one-by-one\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  X86-only for now.\n\n\t  This option allows the user to tune the amount of TLB entries the\n\t  kernel flushes one-by-one instead of doing a full TLB flush. In\n\t  certain situations, the former is cheaper. This is controlled by the\n\t  tlb_flushall_shift knob under /sys/kernel/debug/x86. If you set it\n\t  to -1, the code flushes the whole TLB unconditionally. Otherwise,\n\t  for positive values of it, the kernel will use single TLB entry\n\t  invalidating instructions according to the following formula:\n\n\t  flush_entries <= active_tlb_entries / 2^tlb_flushall_shift\n\n\t  If in doubt, say \"N\".\n\nconfig IOMMU_DEBUG\n\tbool \"Enable IOMMU debugging\"\n\tdepends on GART_IOMMU && DEBUG_KERNEL\n\tdepends on X86_64\n\thelp\n\t  Force the IOMMU to on even when you have less than 4GB of\n\t  memory and add debugging code. On overflow always panic. And\n\t  allow to enable IOMMU leak tracing. Can be disabled at boot\n\t  time with iommu=noforce. This will also enable scatter gather\n\t  list merging.  Currently not recommended for production\n\t  code. When you use it make sure you have a big enough\n\t  IOMMU/AGP aperture.  Most of the options enabled by this can\n\t  be set more finegrained using the iommu= command line\n\t  options. See Documentation/arch/x86/x86_64/boot-options.rst for more\n\t  details.\n\nconfig IOMMU_LEAK\n\tbool \"IOMMU leak tracing\"\n\tdepends on IOMMU_DEBUG && DMA_API_DEBUG\n\thelp\n\t  Add a simple leak tracer to the IOMMU code. This is useful when you\n\t  are debugging a buggy device driver that leaks IOMMU mappings.\n\nconfig HAVE_MMIOTRACE_SUPPORT\n\tdef_bool y\n\nconfig X86_DECODER_SELFTEST\n\tbool \"x86 instruction decoder selftest\"\n\tdepends on DEBUG_KERNEL && INSTRUCTION_DECODER\n\tdepends on !COMPILE_TEST\n\thelp\n\t  Perform x86 instruction decoder selftests at build time.\n\t  This option is useful for checking the sanity of x86 instruction\n\t  decoder code.\n\t  If unsure, say \"N\".\n\nchoice\n\tprompt \"IO delay type\"\n\tdefault IO_DELAY_0X80\n\nconfig IO_DELAY_0X80\n\tbool \"port 0x80 based port-IO delay [recommended]\"\n\thelp\n\t  This is the traditional Linux IO delay used for in/out_p.\n\t  It is the most tested hence safest selection here.\n\nconfig IO_DELAY_0XED\n\tbool \"port 0xed based port-IO delay\"\n\thelp\n\t  Use port 0xed as the IO delay. This frees up port 0x80 which is\n\t  often used as a hardware-debug port.\n\nconfig IO_DELAY_UDELAY\n\tbool \"udelay based port-IO delay\"\n\thelp\n\t  Use udelay(2) as the IO delay method. This provides the delay\n\t  while not having any side-effect on the IO port space.\n\nconfig IO_DELAY_NONE\n\tbool \"no port-IO delay\"\n\thelp\n\t  No port-IO delay. Will break on old boxes that require port-IO\n\t  delay for certain operations. Should work on most new machines.\n\nendchoice\n\nconfig DEBUG_BOOT_PARAMS\n\tbool \"Debug boot parameters\"\n\tdepends on DEBUG_KERNEL\n\tdepends on DEBUG_FS\n\thelp\n\t  This option will cause struct boot_params to be exported via debugfs.\n\nconfig CPA_DEBUG\n\tbool \"CPA self-test code\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  Do change_page_attr() self-tests every 30 seconds.\n\nconfig DEBUG_ENTRY\n\tbool \"Debug low-level entry code\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  This option enables sanity checks in x86's low-level entry code.\n\t  Some of these sanity checks may slow down kernel entries and\n\t  exits or otherwise impact performance.\n\n\t  If unsure, say N.\n\nconfig DEBUG_NMI_SELFTEST\n\tbool \"NMI Selftest\"\n\tdepends on DEBUG_KERNEL && X86_LOCAL_APIC\n\thelp\n\t  Enabling this option turns on a quick NMI selftest to verify\n\t  that the NMI behaves correctly.\n\n\t  This might help diagnose strange hangs that rely on NMI to\n\t  function properly.\n\n\t  If unsure, say N.\n\nconfig DEBUG_IMR_SELFTEST\n\tbool \"Isolated Memory Region self test\"\n\tdepends on INTEL_IMR\n\thelp\n\t  This option enables automated sanity testing of the IMR code.\n\t  Some simple tests are run to verify IMR bounds checking, alignment\n\t  and overlapping. This option is really only useful if you are\n\t  debugging an IMR memory map or are modifying the IMR code and want to\n\t  test your changes.\n\n\t  If unsure say N here.\n\nconfig X86_DEBUG_FPU\n\tbool \"Debug the x86 FPU code\"\n\tdepends on DEBUG_KERNEL\n\tdefault y\n\thelp\n\t  If this option is enabled then there will be extra sanity\n\t  checks and (boot time) debug printouts added to the kernel.\n\t  This debugging adds some small amount of runtime overhead\n\t  to the kernel.\n\n\t  If unsure, say N.\n\nconfig PUNIT_ATOM_DEBUG\n\ttristate \"ATOM Punit debug driver\"\n\tdepends on PCI\n\tselect DEBUG_FS\n\tselect IOSF_MBI\n\thelp\n\t  This is a debug driver, which gets the power states\n\t  of all Punit North Complex devices. The power states of\n\t  each device is exposed as part of the debugfs interface.\n\t  The current power state can be read from\n\t  /sys/kernel/debug/punit_atom/dev_power_state\n\nchoice\n\tprompt \"Choose kernel unwinder\"\n\tdefault UNWINDER_ORC if X86_64\n\tdefault UNWINDER_FRAME_POINTER if X86_32\n\thelp\n\t  This determines which method will be used for unwinding kernel stack\n\t  traces for panics, oopses, bugs, warnings, perf, /proc/<pid>/stack,\n\t  livepatch, lockdep, and more.\n\nconfig UNWINDER_ORC\n\tbool \"ORC unwinder\"\n\tdepends on X86_64\n\tselect OBJTOOL\n\thelp\n\t  This option enables the ORC (Oops Rewind Capability) unwinder for\n\t  unwinding kernel stack traces.  It uses a custom data format which is\n\t  a simplified version of the DWARF Call Frame Information standard.\n\n\t  This unwinder is more accurate across interrupt entry frames than the\n\t  frame pointer unwinder.  It also enables a 5-10% performance\n\t  improvement across the entire kernel compared to frame pointers.\n\n\t  Enabling this option will increase the kernel's runtime memory usage\n\t  by roughly 2-4MB, depending on your kernel config.\n\nconfig UNWINDER_FRAME_POINTER\n\tbool \"Frame pointer unwinder\"\n\tselect FRAME_POINTER\n\thelp\n\t  This option enables the frame pointer unwinder for unwinding kernel\n\t  stack traces.\n\n\t  The unwinder itself is fast and it uses less RAM than the ORC\n\t  unwinder, but the kernel text size will grow by ~3% and the kernel's\n\t  overall performance will degrade by roughly 5-10%.\n\nconfig UNWINDER_GUESS\n\tbool \"Guess unwinder\"\n\tdepends on EXPERT\n\tdepends on !STACKDEPOT\n\thelp\n\t  This option enables the \"guess\" unwinder for unwinding kernel stack\n\t  traces.  It scans the stack and reports every kernel text address it\n\t  finds.  Some of the addresses it reports may be incorrect.\n\n\t  While this option often produces false positives, it can still be\n\t  useful in many cases.  Unlike the other unwinders, it has no runtime\n\t  overhead.\n\nendchoice\n\nconfig FRAME_POINTER\n\tdepends on !UNWINDER_ORC && !UNWINDER_GUESS\n\tbool\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}