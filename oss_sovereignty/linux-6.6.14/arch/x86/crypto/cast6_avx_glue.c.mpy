{
  "module_name": "cast6_avx_glue.c",
  "hash_id": "7ca06c98786247096f263d67d0fb6004dd87c6d37acff5acf9be362ae16382b4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/cast6_avx_glue.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <crypto/algapi.h>\n#include <crypto/cast6.h>\n#include <crypto/internal/simd.h>\n\n#include \"ecb_cbc_helpers.h\"\n\n#define CAST6_PARALLEL_BLOCKS 8\n\nasmlinkage void cast6_ecb_enc_8way(const void *ctx, u8 *dst, const u8 *src);\nasmlinkage void cast6_ecb_dec_8way(const void *ctx, u8 *dst, const u8 *src);\n\nasmlinkage void cast6_cbc_dec_8way(const void *ctx, u8 *dst, const u8 *src);\n\nstatic int cast6_setkey_skcipher(struct crypto_skcipher *tfm,\n\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\treturn cast6_setkey(&tfm->base, key, keylen);\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAST6_BLOCK_SIZE, CAST6_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAST6_PARALLEL_BLOCKS, cast6_ecb_enc_8way);\n\tECB_BLOCK(1, __cast6_encrypt);\n\tECB_WALK_END();\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAST6_BLOCK_SIZE, CAST6_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAST6_PARALLEL_BLOCKS, cast6_ecb_dec_8way);\n\tECB_BLOCK(1, __cast6_decrypt);\n\tECB_WALK_END();\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAST6_BLOCK_SIZE, -1);\n\tCBC_ENC_BLOCK(__cast6_encrypt);\n\tCBC_WALK_END();\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAST6_BLOCK_SIZE, CAST6_PARALLEL_BLOCKS);\n\tCBC_DEC_BLOCK(CAST6_PARALLEL_BLOCKS, cast6_cbc_dec_8way);\n\tCBC_DEC_BLOCK(1, __cast6_decrypt);\n\tCBC_WALK_END();\n}\n\nstatic struct skcipher_alg cast6_algs[] = {\n\t{\n\t\t.base.cra_name\t\t= \"__ecb(cast6)\",\n\t\t.base.cra_driver_name\t= \"__ecb-cast6-avx\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAST6_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct cast6_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAST6_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAST6_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= cast6_setkey_skcipher,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"__cbc(cast6)\",\n\t\t.base.cra_driver_name\t= \"__cbc-cast6-avx\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAST6_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct cast6_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAST6_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAST6_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= CAST6_BLOCK_SIZE,\n\t\t.setkey\t\t\t= cast6_setkey_skcipher,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t},\n};\n\nstatic struct simd_skcipher_alg *cast6_simd_algs[ARRAY_SIZE(cast6_algs)];\n\nstatic int __init cast6_init(void)\n{\n\tconst char *feature_name;\n\n\tif (!cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM,\n\t\t\t\t&feature_name)) {\n\t\tpr_info(\"CPU feature '%s' is not supported.\\n\", feature_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn simd_register_skciphers_compat(cast6_algs,\n\t\t\t\t\t      ARRAY_SIZE(cast6_algs),\n\t\t\t\t\t      cast6_simd_algs);\n}\n\nstatic void __exit cast6_exit(void)\n{\n\tsimd_unregister_skciphers(cast6_algs, ARRAY_SIZE(cast6_algs),\n\t\t\t\t  cast6_simd_algs);\n}\n\nmodule_init(cast6_init);\nmodule_exit(cast6_exit);\n\nMODULE_DESCRIPTION(\"Cast6 Cipher Algorithm, AVX optimized\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CRYPTO(\"cast6\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}