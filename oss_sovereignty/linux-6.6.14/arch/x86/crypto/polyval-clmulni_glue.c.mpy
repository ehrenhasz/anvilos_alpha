{
  "module_name": "polyval-clmulni_glue.c",
  "hash_id": "eab5efce3ae98beb3a4318c3cfcac4b8fd217879147bb1a1b4d631c3e9f10e8e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/polyval-clmulni_glue.c",
  "human_readable_source": "\n \n\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/simd.h>\n#include <crypto/polyval.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <asm/cpu_device_id.h>\n#include <asm/simd.h>\n\n#define POLYVAL_ALIGN\t16\n#define POLYVAL_ALIGN_ATTR __aligned(POLYVAL_ALIGN)\n#define POLYVAL_ALIGN_EXTRA ((POLYVAL_ALIGN - 1) & ~(CRYPTO_MINALIGN - 1))\n#define POLYVAL_CTX_SIZE (sizeof(struct polyval_tfm_ctx) + POLYVAL_ALIGN_EXTRA)\n#define NUM_KEY_POWERS\t8\n\nstruct polyval_tfm_ctx {\n\t \n\tu8 key_powers[NUM_KEY_POWERS][POLYVAL_BLOCK_SIZE] POLYVAL_ALIGN_ATTR;\n};\n\nstruct polyval_desc_ctx {\n\tu8 buffer[POLYVAL_BLOCK_SIZE];\n\tu32 bytes;\n};\n\nasmlinkage void clmul_polyval_update(const struct polyval_tfm_ctx *keys,\n\tconst u8 *in, size_t nblocks, u8 *accumulator);\nasmlinkage void clmul_polyval_mul(u8 *op1, const u8 *op2);\n\nstatic inline struct polyval_tfm_ctx *polyval_tfm_ctx(struct crypto_shash *tfm)\n{\n\treturn PTR_ALIGN(crypto_shash_ctx(tfm), POLYVAL_ALIGN);\n}\n\nstatic void internal_polyval_update(const struct polyval_tfm_ctx *keys,\n\tconst u8 *in, size_t nblocks, u8 *accumulator)\n{\n\tif (likely(crypto_simd_usable())) {\n\t\tkernel_fpu_begin();\n\t\tclmul_polyval_update(keys, in, nblocks, accumulator);\n\t\tkernel_fpu_end();\n\t} else {\n\t\tpolyval_update_non4k(keys->key_powers[NUM_KEY_POWERS-1], in,\n\t\t\tnblocks, accumulator);\n\t}\n}\n\nstatic void internal_polyval_mul(u8 *op1, const u8 *op2)\n{\n\tif (likely(crypto_simd_usable())) {\n\t\tkernel_fpu_begin();\n\t\tclmul_polyval_mul(op1, op2);\n\t\tkernel_fpu_end();\n\t} else {\n\t\tpolyval_mul_non4k(op1, op2);\n\t}\n}\n\nstatic int polyval_x86_setkey(struct crypto_shash *tfm,\n\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct polyval_tfm_ctx *tctx = polyval_tfm_ctx(tfm);\n\tint i;\n\n\tif (keylen != POLYVAL_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tmemcpy(tctx->key_powers[NUM_KEY_POWERS-1], key, POLYVAL_BLOCK_SIZE);\n\n\tfor (i = NUM_KEY_POWERS-2; i >= 0; i--) {\n\t\tmemcpy(tctx->key_powers[i], key, POLYVAL_BLOCK_SIZE);\n\t\tinternal_polyval_mul(tctx->key_powers[i],\n\t\t\t\t     tctx->key_powers[i+1]);\n\t}\n\n\treturn 0;\n}\n\nstatic int polyval_x86_init(struct shash_desc *desc)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tmemset(dctx, 0, sizeof(*dctx));\n\n\treturn 0;\n}\n\nstatic int polyval_x86_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\tconst struct polyval_tfm_ctx *tctx = polyval_tfm_ctx(desc->tfm);\n\tu8 *pos;\n\tunsigned int nblocks;\n\tunsigned int n;\n\n\tif (dctx->bytes) {\n\t\tn = min(srclen, dctx->bytes);\n\t\tpos = dctx->buffer + POLYVAL_BLOCK_SIZE - dctx->bytes;\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tinternal_polyval_mul(dctx->buffer,\n\t\t\t\t\t    tctx->key_powers[NUM_KEY_POWERS-1]);\n\t}\n\n\twhile (srclen >= POLYVAL_BLOCK_SIZE) {\n\t\t \n\t\tnblocks = min(srclen, 4096U) / POLYVAL_BLOCK_SIZE;\n\t\tinternal_polyval_update(tctx, src, nblocks, dctx->buffer);\n\t\tsrclen -= nblocks * POLYVAL_BLOCK_SIZE;\n\t\tsrc += nblocks * POLYVAL_BLOCK_SIZE;\n\t}\n\n\tif (srclen) {\n\t\tdctx->bytes = POLYVAL_BLOCK_SIZE - srclen;\n\t\tpos = dctx->buffer;\n\t\twhile (srclen--)\n\t\t\t*pos++ ^= *src++;\n\t}\n\n\treturn 0;\n}\n\nstatic int polyval_x86_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\tconst struct polyval_tfm_ctx *tctx = polyval_tfm_ctx(desc->tfm);\n\n\tif (dctx->bytes) {\n\t\tinternal_polyval_mul(dctx->buffer,\n\t\t\t\t     tctx->key_powers[NUM_KEY_POWERS-1]);\n\t}\n\n\tmemcpy(dst, dctx->buffer, POLYVAL_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic struct shash_alg polyval_alg = {\n\t.digestsize\t= POLYVAL_DIGEST_SIZE,\n\t.init\t\t= polyval_x86_init,\n\t.update\t\t= polyval_x86_update,\n\t.final\t\t= polyval_x86_final,\n\t.setkey\t\t= polyval_x86_setkey,\n\t.descsize\t= sizeof(struct polyval_desc_ctx),\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"polyval\",\n\t\t.cra_driver_name\t= \"polyval-clmulni\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_blocksize\t\t= POLYVAL_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t= POLYVAL_CTX_SIZE,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n};\n\n__maybe_unused static const struct x86_cpu_id pcmul_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_PCLMULQDQ, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, pcmul_cpu_id);\n\nstatic int __init polyval_clmulni_mod_init(void)\n{\n\tif (!x86_match_cpu(pcmul_cpu_id))\n\t\treturn -ENODEV;\n\n\tif (!boot_cpu_has(X86_FEATURE_AVX))\n\t\treturn -ENODEV;\n\n\treturn crypto_register_shash(&polyval_alg);\n}\n\nstatic void __exit polyval_clmulni_mod_exit(void)\n{\n\tcrypto_unregister_shash(&polyval_alg);\n}\n\nmodule_init(polyval_clmulni_mod_init);\nmodule_exit(polyval_clmulni_mod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"POLYVAL hash function accelerated by PCLMULQDQ-NI\");\nMODULE_ALIAS_CRYPTO(\"polyval\");\nMODULE_ALIAS_CRYPTO(\"polyval-clmulni\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}