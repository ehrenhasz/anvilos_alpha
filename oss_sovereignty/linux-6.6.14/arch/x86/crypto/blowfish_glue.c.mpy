{
  "module_name": "blowfish_glue.c",
  "hash_id": "dc222fb2994b979cba1dc2a81aa3e0a6b92ba9a3b0be0276f17b1cb02af4d92d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/blowfish_glue.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/blowfish.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include \"ecb_cbc_helpers.h\"\n\n \nasmlinkage void blowfish_enc_blk(struct bf_ctx *ctx, u8 *dst, const u8 *src);\nasmlinkage void blowfish_dec_blk(struct bf_ctx *ctx, u8 *dst, const u8 *src);\n\n \nasmlinkage void blowfish_enc_blk_4way(struct bf_ctx *ctx, u8 *dst,\n\t\t\t\t      const u8 *src);\nasmlinkage void __blowfish_dec_blk_4way(struct bf_ctx *ctx, u8 *dst,\n\t\t\t\t\tconst u8 *src, bool cbc);\n\nstatic inline void blowfish_dec_ecb_4way(struct bf_ctx *ctx, u8 *dst,\n\t\t\t\t\t     const u8 *src)\n{\n\treturn __blowfish_dec_blk_4way(ctx, dst, src, false);\n}\n\nstatic inline void blowfish_dec_cbc_4way(struct bf_ctx *ctx, u8 *dst,\n\t\t\t\t\t     const u8 *src)\n{\n\treturn __blowfish_dec_blk_4way(ctx, dst, src, true);\n}\n\nstatic void blowfish_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tblowfish_enc_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n\nstatic void blowfish_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tblowfish_dec_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n\nstatic int blowfish_setkey_skcipher(struct crypto_skcipher *tfm,\n\t\t\t\t    const u8 *key, unsigned int keylen)\n{\n\treturn blowfish_setkey(&tfm->base, key, keylen);\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, BF_BLOCK_SIZE, -1);\n\tECB_BLOCK(4, blowfish_enc_blk_4way);\n\tECB_BLOCK(1, blowfish_enc_blk);\n\tECB_WALK_END();\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, BF_BLOCK_SIZE, -1);\n\tECB_BLOCK(4, blowfish_dec_ecb_4way);\n\tECB_BLOCK(1, blowfish_dec_blk);\n\tECB_WALK_END();\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, BF_BLOCK_SIZE, -1);\n\tCBC_ENC_BLOCK(blowfish_enc_blk);\n\tCBC_WALK_END();\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, BF_BLOCK_SIZE, -1);\n\tCBC_DEC_BLOCK(4, blowfish_dec_cbc_4way);\n\tCBC_DEC_BLOCK(1, blowfish_dec_blk);\n\tCBC_WALK_END();\n}\n\nstatic struct crypto_alg bf_cipher_alg = {\n\t.cra_name\t\t= \"blowfish\",\n\t.cra_driver_name\t= \"blowfish-asm\",\n\t.cra_priority\t\t= 200,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t= BF_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct bf_ctx),\n\t.cra_alignmask\t\t= 0,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_u = {\n\t\t.cipher = {\n\t\t\t.cia_min_keysize\t= BF_MIN_KEY_SIZE,\n\t\t\t.cia_max_keysize\t= BF_MAX_KEY_SIZE,\n\t\t\t.cia_setkey\t\t= blowfish_setkey,\n\t\t\t.cia_encrypt\t\t= blowfish_encrypt,\n\t\t\t.cia_decrypt\t\t= blowfish_decrypt,\n\t\t}\n\t}\n};\n\nstatic struct skcipher_alg bf_skcipher_algs[] = {\n\t{\n\t\t.base.cra_name\t\t= \"ecb(blowfish)\",\n\t\t.base.cra_driver_name\t= \"ecb-blowfish-asm\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_blocksize\t= BF_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct bf_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= BF_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= BF_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= blowfish_setkey_skcipher,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"cbc(blowfish)\",\n\t\t.base.cra_driver_name\t= \"cbc-blowfish-asm\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_blocksize\t= BF_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct bf_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= BF_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= BF_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= BF_BLOCK_SIZE,\n\t\t.setkey\t\t\t= blowfish_setkey_skcipher,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t},\n};\n\nstatic bool is_blacklisted_cpu(void)\n{\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn false;\n\n\tif (boot_cpu_data.x86 == 0x0f) {\n\t\t \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int force;\nmodule_param(force, int, 0);\nMODULE_PARM_DESC(force, \"Force module load, ignore CPU blacklist\");\n\nstatic int __init blowfish_init(void)\n{\n\tint err;\n\n\tif (!force && is_blacklisted_cpu()) {\n\t\tprintk(KERN_INFO\n\t\t\t\"blowfish-x86_64: performance on this CPU \"\n\t\t\t\"would be suboptimal: disabling \"\n\t\t\t\"blowfish-x86_64.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = crypto_register_alg(&bf_cipher_alg);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_register_skciphers(bf_skcipher_algs,\n\t\t\t\t\tARRAY_SIZE(bf_skcipher_algs));\n\tif (err)\n\t\tcrypto_unregister_alg(&bf_cipher_alg);\n\n\treturn err;\n}\n\nstatic void __exit blowfish_fini(void)\n{\n\tcrypto_unregister_alg(&bf_cipher_alg);\n\tcrypto_unregister_skciphers(bf_skcipher_algs,\n\t\t\t\t    ARRAY_SIZE(bf_skcipher_algs));\n}\n\nmodule_init(blowfish_init);\nmodule_exit(blowfish_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Blowfish Cipher Algorithm, asm optimized\");\nMODULE_ALIAS_CRYPTO(\"blowfish\");\nMODULE_ALIAS_CRYPTO(\"blowfish-asm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}