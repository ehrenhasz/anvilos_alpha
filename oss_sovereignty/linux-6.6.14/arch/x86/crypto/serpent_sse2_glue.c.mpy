{
  "module_name": "serpent_sse2_glue.c",
  "hash_id": "2c2f38532a5fe67d1cc7416f45484f84d03439f8a1c59aae885f09ae05afe180",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/serpent_sse2_glue.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <crypto/algapi.h>\n#include <crypto/b128ops.h>\n#include <crypto/internal/simd.h>\n#include <crypto/serpent.h>\n\n#include \"serpent-sse2.h\"\n#include \"ecb_cbc_helpers.h\"\n\nstatic int serpent_setkey_skcipher(struct crypto_skcipher *tfm,\n\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\treturn __serpent_setkey(crypto_skcipher_ctx(tfm), key, keylen);\n}\n\nstatic void serpent_decrypt_cbc_xway(const void *ctx, u8 *dst, const u8 *src)\n{\n\tu8 buf[SERPENT_PARALLEL_BLOCKS - 1][SERPENT_BLOCK_SIZE];\n\tconst u8 *s = src;\n\n\tif (dst == src)\n\t\ts = memcpy(buf, src, sizeof(buf));\n\tserpent_dec_blk_xway(ctx, dst, src);\n\tcrypto_xor(dst + SERPENT_BLOCK_SIZE, s, sizeof(buf));\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, SERPENT_BLOCK_SIZE, SERPENT_PARALLEL_BLOCKS);\n\tECB_BLOCK(SERPENT_PARALLEL_BLOCKS, serpent_enc_blk_xway);\n\tECB_BLOCK(1, __serpent_encrypt);\n\tECB_WALK_END();\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, SERPENT_BLOCK_SIZE, SERPENT_PARALLEL_BLOCKS);\n\tECB_BLOCK(SERPENT_PARALLEL_BLOCKS, serpent_dec_blk_xway);\n\tECB_BLOCK(1, __serpent_decrypt);\n\tECB_WALK_END();\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, SERPENT_BLOCK_SIZE, -1);\n\tCBC_ENC_BLOCK(__serpent_encrypt);\n\tCBC_WALK_END();\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, SERPENT_BLOCK_SIZE, SERPENT_PARALLEL_BLOCKS);\n\tCBC_DEC_BLOCK(SERPENT_PARALLEL_BLOCKS, serpent_decrypt_cbc_xway);\n\tCBC_DEC_BLOCK(1, __serpent_decrypt);\n\tCBC_WALK_END();\n}\n\nstatic struct skcipher_alg serpent_algs[] = {\n\t{\n\t\t.base.cra_name\t\t= \"__ecb(serpent)\",\n\t\t.base.cra_driver_name\t= \"__ecb-serpent-sse2\",\n\t\t.base.cra_priority\t= 400,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= SERPENT_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct serpent_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= SERPENT_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= SERPENT_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= serpent_setkey_skcipher,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"__cbc(serpent)\",\n\t\t.base.cra_driver_name\t= \"__cbc-serpent-sse2\",\n\t\t.base.cra_priority\t= 400,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= SERPENT_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct serpent_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= SERPENT_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= SERPENT_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= SERPENT_BLOCK_SIZE,\n\t\t.setkey\t\t\t= serpent_setkey_skcipher,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t},\n};\n\nstatic struct simd_skcipher_alg *serpent_simd_algs[ARRAY_SIZE(serpent_algs)];\n\nstatic int __init serpent_sse2_init(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_XMM2)) {\n\t\tprintk(KERN_INFO \"SSE2 instructions are not detected.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn simd_register_skciphers_compat(serpent_algs,\n\t\t\t\t\t      ARRAY_SIZE(serpent_algs),\n\t\t\t\t\t      serpent_simd_algs);\n}\n\nstatic void __exit serpent_sse2_exit(void)\n{\n\tsimd_unregister_skciphers(serpent_algs, ARRAY_SIZE(serpent_algs),\n\t\t\t\t  serpent_simd_algs);\n}\n\nmodule_init(serpent_sse2_init);\nmodule_exit(serpent_sse2_exit);\n\nMODULE_DESCRIPTION(\"Serpent Cipher Algorithm, SSE2 optimized\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CRYPTO(\"serpent\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}