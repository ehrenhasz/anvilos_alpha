{
  "module_name": "sha1_ssse3_asm.S",
  "hash_id": "b172ea1e267718eed2cdb61406794107f9f1158fd739ac3d578194a2abc6c90d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/sha1_ssse3_asm.S",
  "human_readable_source": " \n \n\n#include <linux/linkage.h>\n#include <linux/cfi_types.h>\n\n#define CTX\t%rdi\t \n#define BUF\t%rsi\t \n#define CNT\t%rdx\t \n\n#define REG_A\t%ecx\n#define REG_B\t%esi\n#define REG_C\t%edi\n#define REG_D\t%r12d\n#define REG_E\t%edx\n\n#define REG_T1\t%eax\n#define REG_T2\t%ebx\n\n#define K_BASE\t\t%r8\n#define HASH_PTR\t%r9\n#define BUFFER_PTR\t%r10\n#define BUFFER_END\t%r11\n\n#define W_TMP1\t%xmm0\n#define W_TMP2\t%xmm9\n\n#define W0\t%xmm1\n#define W4\t%xmm2\n#define W8\t%xmm3\n#define W12\t%xmm4\n#define W16\t%xmm5\n#define W20\t%xmm6\n#define W24\t%xmm7\n#define W28\t%xmm8\n\n#define XMM_SHUFB_BSWAP\t%xmm10\n\n \n#define WK(t)\t(((t) & 15) * 4)(%rsp)\n#define W_PRECALC_AHEAD\t16\n\n \n.macro SHA1_VECTOR_ASM  name\n\tSYM_TYPED_FUNC_START(\\name)\n\n\tpush\t%rbx\n\tpush\t%r12\n\tpush\t%rbp\n\tmov\t%rsp, %rbp\n\n\tsub\t$64, %rsp\t\t# allocate workspace\n\tand\t$~15, %rsp\t\t# align stack\n\n\tmov\tCTX, HASH_PTR\n\tmov\tBUF, BUFFER_PTR\n\n\tshl\t$6, CNT\t\t\t# multiply by 64\n\tadd\tBUF, CNT\n\tmov\tCNT, BUFFER_END\n\n\tlea\tK_XMM_AR(%rip), K_BASE\n\txmm_mov\tBSWAP_SHUFB_CTL(%rip), XMM_SHUFB_BSWAP\n\n\tSHA1_PIPELINED_MAIN_BODY\n\n\t# cleanup workspace\n\tmov\t$8, %ecx\n\tmov\t%rsp, %rdi\n\txor\t%eax, %eax\n\trep stosq\n\n\tmov\t%rbp, %rsp\t\t# deallocate workspace\n\tpop\t%rbp\n\tpop\t%r12\n\tpop\t%rbx\n\tRET\n\n\tSYM_FUNC_END(\\name)\n.endm\n\n \n.macro SHA1_PIPELINED_MAIN_BODY\n\tINIT_REGALLOC\n\n\tmov\t  (HASH_PTR), A\n\tmov\t 4(HASH_PTR), B\n\tmov\t 8(HASH_PTR), C\n\tmov\t12(HASH_PTR), D\n\tmov\t16(HASH_PTR), E\n\n  .set i, 0\n  .rept W_PRECALC_AHEAD\n\tW_PRECALC i\n    .set i, (i+1)\n  .endr\n\n.align 4\n1:\n\tRR F1,A,B,C,D,E,0\n\tRR F1,D,E,A,B,C,2\n\tRR F1,B,C,D,E,A,4\n\tRR F1,E,A,B,C,D,6\n\tRR F1,C,D,E,A,B,8\n\n\tRR F1,A,B,C,D,E,10\n\tRR F1,D,E,A,B,C,12\n\tRR F1,B,C,D,E,A,14\n\tRR F1,E,A,B,C,D,16\n\tRR F1,C,D,E,A,B,18\n\n\tRR F2,A,B,C,D,E,20\n\tRR F2,D,E,A,B,C,22\n\tRR F2,B,C,D,E,A,24\n\tRR F2,E,A,B,C,D,26\n\tRR F2,C,D,E,A,B,28\n\n\tRR F2,A,B,C,D,E,30\n\tRR F2,D,E,A,B,C,32\n\tRR F2,B,C,D,E,A,34\n\tRR F2,E,A,B,C,D,36\n\tRR F2,C,D,E,A,B,38\n\n\tRR F3,A,B,C,D,E,40\n\tRR F3,D,E,A,B,C,42\n\tRR F3,B,C,D,E,A,44\n\tRR F3,E,A,B,C,D,46\n\tRR F3,C,D,E,A,B,48\n\n\tRR F3,A,B,C,D,E,50\n\tRR F3,D,E,A,B,C,52\n\tRR F3,B,C,D,E,A,54\n\tRR F3,E,A,B,C,D,56\n\tRR F3,C,D,E,A,B,58\n\n\tadd\t$64, BUFFER_PTR\t\t# move to the next 64-byte block\n\tcmp\tBUFFER_END, BUFFER_PTR\t# if the current is the last one use\n\tcmovae\tK_BASE, BUFFER_PTR\t# dummy source to avoid buffer overrun\n\n\tRR F4,A,B,C,D,E,60\n\tRR F4,D,E,A,B,C,62\n\tRR F4,B,C,D,E,A,64\n\tRR F4,E,A,B,C,D,66\n\tRR F4,C,D,E,A,B,68\n\n\tRR F4,A,B,C,D,E,70\n\tRR F4,D,E,A,B,C,72\n\tRR F4,B,C,D,E,A,74\n\tRR F4,E,A,B,C,D,76\n\tRR F4,C,D,E,A,B,78\n\n\tUPDATE_HASH   (HASH_PTR), A\n\tUPDATE_HASH  4(HASH_PTR), B\n\tUPDATE_HASH  8(HASH_PTR), C\n\tUPDATE_HASH 12(HASH_PTR), D\n\tUPDATE_HASH 16(HASH_PTR), E\n\n\tRESTORE_RENAMED_REGS\n\tcmp\tK_BASE, BUFFER_PTR\t# K_BASE means, we reached the end\n\tjne\t1b\n.endm\n\n.macro INIT_REGALLOC\n  .set A, REG_A\n  .set B, REG_B\n  .set C, REG_C\n  .set D, REG_D\n  .set E, REG_E\n  .set T1, REG_T1\n  .set T2, REG_T2\n.endm\n\n.macro RESTORE_RENAMED_REGS\n\t# order is important (REG_C is where it should be)\n\tmov\tB, REG_B\n\tmov\tD, REG_D\n\tmov\tA, REG_A\n\tmov\tE, REG_E\n.endm\n\n.macro SWAP_REG_NAMES  a, b\n  .set _T, \\a\n  .set \\a, \\b\n  .set \\b, _T\n.endm\n\n.macro F1  b, c, d\n\tmov\t\\c, T1\n\tSWAP_REG_NAMES \\c, T1\n\txor\t\\d, T1\n\tand\t\\b, T1\n\txor\t\\d, T1\n.endm\n\n.macro F2  b, c, d\n\tmov\t\\d, T1\n\tSWAP_REG_NAMES \\d, T1\n\txor\t\\c, T1\n\txor\t\\b, T1\n.endm\n\n.macro F3  b, c ,d\n\tmov\t\\c, T1\n\tSWAP_REG_NAMES \\c, T1\n\tmov\t\\b, T2\n\tor\t\\b, T1\n\tand\t\\c, T2\n\tand\t\\d, T1\n\tor\tT2, T1\n.endm\n\n.macro F4  b, c, d\n\tF2 \\b, \\c, \\d\n.endm\n\n.macro UPDATE_HASH  hash, val\n\tadd\t\\hash, \\val\n\tmov\t\\val, \\hash\n.endm\n\n \n.macro RR  F, a, b, c, d, e, round\n\tadd\tWK(\\round), \\e\n\t\\F   \\b, \\c, \\d\t\t# t1 = F(b, c, d);\n\tW_PRECALC (\\round + W_PRECALC_AHEAD)\n\trol\t$30, \\b\n\tadd\tT1, \\e\n\tadd\tWK(\\round + 1), \\d\n\n\t\\F   \\a, \\b, \\c\n\tW_PRECALC (\\round + W_PRECALC_AHEAD + 1)\n\trol\t$5, \\a\n\tadd\t\\a, \\e\n\tadd\tT1, \\d\n\tror\t$7, \\a\t\t# (a <<r 5) >>r 7) => a <<r 30)\n\n\tmov\t\\e, T1\n\tSWAP_REG_NAMES \\e, T1\n\n\trol\t$5, T1\n\tadd\tT1, \\d\n\n\t# write:  \\a, \\b\n\t# rotate: \\a<=\\d, \\b<=\\e, \\c<=\\a, \\d<=\\b, \\e<=\\c\n.endm\n\n.macro W_PRECALC  r\n  .set i, \\r\n\n  .if (i < 20)\n    .set K_XMM, 0\n  .elseif (i < 40)\n    .set K_XMM, 16\n  .elseif (i < 60)\n    .set K_XMM, 32\n  .elseif (i < 80)\n    .set K_XMM, 48\n  .endif\n\n  .if ((i < 16) || ((i >= 80) && (i < (80 + W_PRECALC_AHEAD))))\n    .set i, ((\\r) % 80)\t    # pre-compute for the next iteration\n    .if (i == 0)\n\tW_PRECALC_RESET\n    .endif\n\tW_PRECALC_00_15\n  .elseif (i<32)\n\tW_PRECALC_16_31\n  .elseif (i < 80)    \n\tW_PRECALC_32_79\n  .endif\n.endm\n\n.macro W_PRECALC_RESET\n  .set W,          W0\n  .set W_minus_04, W4\n  .set W_minus_08, W8\n  .set W_minus_12, W12\n  .set W_minus_16, W16\n  .set W_minus_20, W20\n  .set W_minus_24, W24\n  .set W_minus_28, W28\n  .set W_minus_32, W\n.endm\n\n.macro W_PRECALC_ROTATE\n  .set W_minus_32, W_minus_28\n  .set W_minus_28, W_minus_24\n  .set W_minus_24, W_minus_20\n  .set W_minus_20, W_minus_16\n  .set W_minus_16, W_minus_12\n  .set W_minus_12, W_minus_08\n  .set W_minus_08, W_minus_04\n  .set W_minus_04, W\n  .set W,          W_minus_32\n.endm\n\n.macro W_PRECALC_SSSE3\n\n.macro W_PRECALC_00_15\n\tW_PRECALC_00_15_SSSE3\n.endm\n.macro W_PRECALC_16_31\n\tW_PRECALC_16_31_SSSE3\n.endm\n.macro W_PRECALC_32_79\n\tW_PRECALC_32_79_SSSE3\n.endm\n\n \n.macro W_PRECALC_00_15_SSSE3\n  .if ((i & 3) == 0)\n\tmovdqu\t(i*4)(BUFFER_PTR), W_TMP1\n  .elseif ((i & 3) == 1)\n\tpshufb\tXMM_SHUFB_BSWAP, W_TMP1\n\tmovdqa\tW_TMP1, W\n  .elseif ((i & 3) == 2)\n\tpaddd\t(K_BASE), W_TMP1\n  .elseif ((i & 3) == 3)\n\tmovdqa  W_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n \n.macro W_PRECALC_16_31_SSSE3\n  # blended scheduling of vector and scalar instruction streams, one 4-wide\n  # vector iteration / 4 scalar rounds\n  .if ((i & 3) == 0)\n\tmovdqa\tW_minus_12, W\n\tpalignr\t$8, W_minus_16, W\t# w[i-14]\n\tmovdqa\tW_minus_04, W_TMP1\n\tpsrldq\t$4, W_TMP1\t\t# w[i-3]\n\tpxor\tW_minus_08, W\n  .elseif ((i & 3) == 1)\n\tpxor\tW_minus_16, W_TMP1\n\tpxor\tW_TMP1, W\n\tmovdqa\tW, W_TMP2\n\tmovdqa\tW, W_TMP1\n\tpslldq\t$12, W_TMP2\n  .elseif ((i & 3) == 2)\n\tpsrld\t$31, W\n\tpslld\t$1, W_TMP1\n\tpor\tW, W_TMP1\n\tmovdqa\tW_TMP2, W\n\tpsrld\t$30, W_TMP2\n\tpslld\t$2, W\n  .elseif ((i & 3) == 3)\n\tpxor\tW, W_TMP1\n\tpxor\tW_TMP2, W_TMP1\n\tmovdqa\tW_TMP1, W\n\tpaddd\tK_XMM(K_BASE), W_TMP1\n\tmovdqa\tW_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n \n.macro W_PRECALC_32_79_SSSE3\n  .if ((i & 3) == 0)\n\tmovdqa\tW_minus_04, W_TMP1\n\tpxor\tW_minus_28, W\t\t# W is W_minus_32 before xor\n\tpalignr\t$8, W_minus_08, W_TMP1\n  .elseif ((i & 3) == 1)\n\tpxor\tW_minus_16, W\n\tpxor\tW_TMP1, W\n\tmovdqa\tW, W_TMP1\n  .elseif ((i & 3) == 2)\n\tpsrld\t$30, W\n\tpslld\t$2, W_TMP1\n\tpor\tW, W_TMP1\n  .elseif ((i & 3) == 3)\n\tmovdqa\tW_TMP1, W\n\tpaddd\tK_XMM(K_BASE), W_TMP1\n\tmovdqa\tW_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n.endm\t\t \n\n\n#define K1\t0x5a827999\n#define K2\t0x6ed9eba1\n#define K3\t0x8f1bbcdc\n#define K4\t0xca62c1d6\n\n.section .rodata\n.align 16\n\nK_XMM_AR:\n\t.long K1, K1, K1, K1\n\t.long K2, K2, K2, K2\n\t.long K3, K3, K3, K3\n\t.long K4, K4, K4, K4\n\nBSWAP_SHUFB_CTL:\n\t.long 0x00010203\n\t.long 0x04050607\n\t.long 0x08090a0b\n\t.long 0x0c0d0e0f\n\n\n.section .text\n\nW_PRECALC_SSSE3\n.macro xmm_mov a, b\n\tmovdqu\t\\a,\\b\n.endm\n\n \nSHA1_VECTOR_ASM     sha1_transform_ssse3\n\n.macro W_PRECALC_AVX\n\n.purgem W_PRECALC_00_15\n.macro  W_PRECALC_00_15\n    W_PRECALC_00_15_AVX\n.endm\n.purgem W_PRECALC_16_31\n.macro  W_PRECALC_16_31\n    W_PRECALC_16_31_AVX\n.endm\n.purgem W_PRECALC_32_79\n.macro  W_PRECALC_32_79\n    W_PRECALC_32_79_AVX\n.endm\n\n.macro W_PRECALC_00_15_AVX\n  .if ((i & 3) == 0)\n\tvmovdqu\t(i*4)(BUFFER_PTR), W_TMP1\n  .elseif ((i & 3) == 1)\n\tvpshufb\tXMM_SHUFB_BSWAP, W_TMP1, W\n  .elseif ((i & 3) == 2)\n\tvpaddd\t(K_BASE), W, W_TMP1\n  .elseif ((i & 3) == 3)\n\tvmovdqa\tW_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n.macro W_PRECALC_16_31_AVX\n  .if ((i & 3) == 0)\n\tvpalignr $8, W_minus_16, W_minus_12, W\t# w[i-14]\n\tvpsrldq\t$4, W_minus_04, W_TMP1\t\t# w[i-3]\n\tvpxor\tW_minus_08, W, W\n\tvpxor\tW_minus_16, W_TMP1, W_TMP1\n  .elseif ((i & 3) == 1)\n\tvpxor\tW_TMP1, W, W\n\tvpslldq\t$12, W, W_TMP2\n\tvpslld\t$1, W, W_TMP1\n  .elseif ((i & 3) == 2)\n\tvpsrld\t$31, W, W\n\tvpor\tW, W_TMP1, W_TMP1\n\tvpslld\t$2, W_TMP2, W\n\tvpsrld\t$30, W_TMP2, W_TMP2\n  .elseif ((i & 3) == 3)\n\tvpxor\tW, W_TMP1, W_TMP1\n\tvpxor\tW_TMP2, W_TMP1, W\n\tvpaddd\tK_XMM(K_BASE), W, W_TMP1\n\tvmovdqu\tW_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n.macro W_PRECALC_32_79_AVX\n  .if ((i & 3) == 0)\n\tvpalignr $8, W_minus_08, W_minus_04, W_TMP1\n\tvpxor\tW_minus_28, W, W\t\t# W is W_minus_32 before xor\n  .elseif ((i & 3) == 1)\n\tvpxor\tW_minus_16, W_TMP1, W_TMP1\n\tvpxor\tW_TMP1, W, W\n  .elseif ((i & 3) == 2)\n\tvpslld\t$2, W, W_TMP1\n\tvpsrld\t$30, W, W\n\tvpor\tW, W_TMP1, W\n  .elseif ((i & 3) == 3)\n\tvpaddd\tK_XMM(K_BASE), W, W_TMP1\n\tvmovdqu\tW_TMP1, WK(i&~3)\n\tW_PRECALC_ROTATE\n  .endif\n.endm\n\n.endm     \n\nW_PRECALC_AVX\n.purgem xmm_mov\n.macro xmm_mov a, b\n\tvmovdqu\t\\a,\\b\n.endm\n\n\n \nSHA1_VECTOR_ASM     sha1_transform_avx\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}