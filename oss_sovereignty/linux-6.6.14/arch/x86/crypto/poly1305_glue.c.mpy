{
  "module_name": "poly1305_glue.c",
  "hash_id": "18882d23bd02c1fce4f8ec40faea38b3e7ebaa13cb1f80f2e4a4f2813aebd98e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/poly1305_glue.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/poly1305.h>\n#include <crypto/internal/simd.h>\n#include <linux/crypto.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sizes.h>\n#include <asm/intel-family.h>\n#include <asm/simd.h>\n\nasmlinkage void poly1305_init_x86_64(void *ctx,\n\t\t\t\t     const u8 key[POLY1305_BLOCK_SIZE]);\nasmlinkage void poly1305_blocks_x86_64(void *ctx, const u8 *inp,\n\t\t\t\t       const size_t len, const u32 padbit);\nasmlinkage void poly1305_emit_x86_64(void *ctx, u8 mac[POLY1305_DIGEST_SIZE],\n\t\t\t\t     const u32 nonce[4]);\nasmlinkage void poly1305_emit_avx(void *ctx, u8 mac[POLY1305_DIGEST_SIZE],\n\t\t\t\t  const u32 nonce[4]);\nasmlinkage void poly1305_blocks_avx(void *ctx, const u8 *inp, const size_t len,\n\t\t\t\t    const u32 padbit);\nasmlinkage void poly1305_blocks_avx2(void *ctx, const u8 *inp, const size_t len,\n\t\t\t\t     const u32 padbit);\nasmlinkage void poly1305_blocks_avx512(void *ctx, const u8 *inp,\n\t\t\t\t       const size_t len, const u32 padbit);\n\nstatic __ro_after_init DEFINE_STATIC_KEY_FALSE(poly1305_use_avx);\nstatic __ro_after_init DEFINE_STATIC_KEY_FALSE(poly1305_use_avx2);\nstatic __ro_after_init DEFINE_STATIC_KEY_FALSE(poly1305_use_avx512);\n\nstruct poly1305_arch_internal {\n\tunion {\n\t\tstruct {\n\t\t\tu32 h[5];\n\t\t\tu32 is_base2_26;\n\t\t};\n\t\tu64 hs[3];\n\t};\n\tu64 r[2];\n\tu64 pad;\n\tstruct { u32 r2, r1, r4, r3; } rn[9];\n};\n\n \nstatic void convert_to_base2_64(void *ctx)\n{\n\tstruct poly1305_arch_internal *state = ctx;\n\tu32 cy;\n\n\tif (!state->is_base2_26)\n\t\treturn;\n\n\tcy = state->h[0] >> 26; state->h[0] &= 0x3ffffff; state->h[1] += cy;\n\tcy = state->h[1] >> 26; state->h[1] &= 0x3ffffff; state->h[2] += cy;\n\tcy = state->h[2] >> 26; state->h[2] &= 0x3ffffff; state->h[3] += cy;\n\tcy = state->h[3] >> 26; state->h[3] &= 0x3ffffff; state->h[4] += cy;\n\tstate->hs[0] = ((u64)state->h[2] << 52) | ((u64)state->h[1] << 26) | state->h[0];\n\tstate->hs[1] = ((u64)state->h[4] << 40) | ((u64)state->h[3] << 14) | (state->h[2] >> 12);\n\tstate->hs[2] = state->h[4] >> 24;\n#define ULT(a, b) ((a ^ ((a ^ b) | ((a - b) ^ b))) >> (sizeof(a) * 8 - 1))\n\tcy = (state->hs[2] >> 2) + (state->hs[2] & ~3ULL);\n\tstate->hs[2] &= 3;\n\tstate->hs[0] += cy;\n\tstate->hs[1] += (cy = ULT(state->hs[0], cy));\n\tstate->hs[2] += ULT(state->hs[1], cy);\n#undef ULT\n\tstate->is_base2_26 = 0;\n}\n\nstatic void poly1305_simd_init(void *ctx, const u8 key[POLY1305_BLOCK_SIZE])\n{\n\tpoly1305_init_x86_64(ctx, key);\n}\n\nstatic void poly1305_simd_blocks(void *ctx, const u8 *inp, size_t len,\n\t\t\t\t const u32 padbit)\n{\n\tstruct poly1305_arch_internal *state = ctx;\n\n\t \n\tBUILD_BUG_ON(SZ_4K < POLY1305_BLOCK_SIZE ||\n\t\t     SZ_4K % POLY1305_BLOCK_SIZE);\n\n\tif (!static_branch_likely(&poly1305_use_avx) ||\n\t    (len < (POLY1305_BLOCK_SIZE * 18) && !state->is_base2_26) ||\n\t    !crypto_simd_usable()) {\n\t\tconvert_to_base2_64(ctx);\n\t\tpoly1305_blocks_x86_64(ctx, inp, len, padbit);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tconst size_t bytes = min_t(size_t, len, SZ_4K);\n\n\t\tkernel_fpu_begin();\n\t\tif (IS_ENABLED(CONFIG_AS_AVX512) && static_branch_likely(&poly1305_use_avx512))\n\t\t\tpoly1305_blocks_avx512(ctx, inp, bytes, padbit);\n\t\telse if (static_branch_likely(&poly1305_use_avx2))\n\t\t\tpoly1305_blocks_avx2(ctx, inp, bytes, padbit);\n\t\telse\n\t\t\tpoly1305_blocks_avx(ctx, inp, bytes, padbit);\n\t\tkernel_fpu_end();\n\n\t\tlen -= bytes;\n\t\tinp += bytes;\n\t} while (len);\n}\n\nstatic void poly1305_simd_emit(void *ctx, u8 mac[POLY1305_DIGEST_SIZE],\n\t\t\t       const u32 nonce[4])\n{\n\tif (!static_branch_likely(&poly1305_use_avx))\n\t\tpoly1305_emit_x86_64(ctx, mac, nonce);\n\telse\n\t\tpoly1305_emit_avx(ctx, mac, nonce);\n}\n\nvoid poly1305_init_arch(struct poly1305_desc_ctx *dctx, const u8 key[POLY1305_KEY_SIZE])\n{\n\tpoly1305_simd_init(&dctx->h, key);\n\tdctx->s[0] = get_unaligned_le32(&key[16]);\n\tdctx->s[1] = get_unaligned_le32(&key[20]);\n\tdctx->s[2] = get_unaligned_le32(&key[24]);\n\tdctx->s[3] = get_unaligned_le32(&key[28]);\n\tdctx->buflen = 0;\n\tdctx->sset = true;\n}\nEXPORT_SYMBOL(poly1305_init_arch);\n\nstatic unsigned int crypto_poly1305_setdctxkey(struct poly1305_desc_ctx *dctx,\n\t\t\t\t\t       const u8 *inp, unsigned int len)\n{\n\tunsigned int acc = 0;\n\tif (unlikely(!dctx->sset)) {\n\t\tif (!dctx->rset && len >= POLY1305_BLOCK_SIZE) {\n\t\t\tpoly1305_simd_init(&dctx->h, inp);\n\t\t\tinp += POLY1305_BLOCK_SIZE;\n\t\t\tlen -= POLY1305_BLOCK_SIZE;\n\t\t\tacc += POLY1305_BLOCK_SIZE;\n\t\t\tdctx->rset = 1;\n\t\t}\n\t\tif (len >= POLY1305_BLOCK_SIZE) {\n\t\t\tdctx->s[0] = get_unaligned_le32(&inp[0]);\n\t\t\tdctx->s[1] = get_unaligned_le32(&inp[4]);\n\t\t\tdctx->s[2] = get_unaligned_le32(&inp[8]);\n\t\t\tdctx->s[3] = get_unaligned_le32(&inp[12]);\n\t\t\tacc += POLY1305_BLOCK_SIZE;\n\t\t\tdctx->sset = true;\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid poly1305_update_arch(struct poly1305_desc_ctx *dctx, const u8 *src,\n\t\t\t  unsigned int srclen)\n{\n\tunsigned int bytes, used;\n\n\tif (unlikely(dctx->buflen)) {\n\t\tbytes = min(srclen, POLY1305_BLOCK_SIZE - dctx->buflen);\n\t\tmemcpy(dctx->buf + dctx->buflen, src, bytes);\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t\tdctx->buflen += bytes;\n\n\t\tif (dctx->buflen == POLY1305_BLOCK_SIZE) {\n\t\t\tif (likely(!crypto_poly1305_setdctxkey(dctx, dctx->buf, POLY1305_BLOCK_SIZE)))\n\t\t\t\tpoly1305_simd_blocks(&dctx->h, dctx->buf, POLY1305_BLOCK_SIZE, 1);\n\t\t\tdctx->buflen = 0;\n\t\t}\n\t}\n\n\tif (likely(srclen >= POLY1305_BLOCK_SIZE)) {\n\t\tbytes = round_down(srclen, POLY1305_BLOCK_SIZE);\n\t\tsrclen -= bytes;\n\t\tused = crypto_poly1305_setdctxkey(dctx, src, bytes);\n\t\tif (likely(bytes - used))\n\t\t\tpoly1305_simd_blocks(&dctx->h, src + used, bytes - used, 1);\n\t\tsrc += bytes;\n\t}\n\n\tif (unlikely(srclen)) {\n\t\tdctx->buflen = srclen;\n\t\tmemcpy(dctx->buf, src, srclen);\n\t}\n}\nEXPORT_SYMBOL(poly1305_update_arch);\n\nvoid poly1305_final_arch(struct poly1305_desc_ctx *dctx, u8 *dst)\n{\n\tif (unlikely(dctx->buflen)) {\n\t\tdctx->buf[dctx->buflen++] = 1;\n\t\tmemset(dctx->buf + dctx->buflen, 0,\n\t\t       POLY1305_BLOCK_SIZE - dctx->buflen);\n\t\tpoly1305_simd_blocks(&dctx->h, dctx->buf, POLY1305_BLOCK_SIZE, 0);\n\t}\n\n\tpoly1305_simd_emit(&dctx->h, dst, dctx->s);\n\tmemzero_explicit(dctx, sizeof(*dctx));\n}\nEXPORT_SYMBOL(poly1305_final_arch);\n\nstatic int crypto_poly1305_init(struct shash_desc *desc)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\t*dctx = (struct poly1305_desc_ctx){};\n\treturn 0;\n}\n\nstatic int crypto_poly1305_update(struct shash_desc *desc,\n\t\t\t\t  const u8 *src, unsigned int srclen)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tpoly1305_update_arch(dctx, src, srclen);\n\treturn 0;\n}\n\nstatic int crypto_poly1305_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tif (unlikely(!dctx->sset))\n\t\treturn -ENOKEY;\n\n\tpoly1305_final_arch(dctx, dst);\n\treturn 0;\n}\n\nstatic struct shash_alg alg = {\n\t.digestsize\t= POLY1305_DIGEST_SIZE,\n\t.init\t\t= crypto_poly1305_init,\n\t.update\t\t= crypto_poly1305_update,\n\t.final\t\t= crypto_poly1305_final,\n\t.descsize\t= sizeof(struct poly1305_desc_ctx),\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"poly1305\",\n\t\t.cra_driver_name\t= \"poly1305-simd\",\n\t\t.cra_priority\t\t= 300,\n\t\t.cra_blocksize\t\t= POLY1305_BLOCK_SIZE,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init poly1305_simd_mod_init(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_AVX) &&\n\t    cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM, NULL))\n\t\tstatic_branch_enable(&poly1305_use_avx);\n\tif (boot_cpu_has(X86_FEATURE_AVX) && boot_cpu_has(X86_FEATURE_AVX2) &&\n\t    cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM, NULL))\n\t\tstatic_branch_enable(&poly1305_use_avx2);\n\tif (IS_ENABLED(CONFIG_AS_AVX512) && boot_cpu_has(X86_FEATURE_AVX) &&\n\t    boot_cpu_has(X86_FEATURE_AVX2) && boot_cpu_has(X86_FEATURE_AVX512F) &&\n\t    cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM | XFEATURE_MASK_AVX512, NULL) &&\n\t     \n\t    boot_cpu_data.x86_model != INTEL_FAM6_SKYLAKE_X)\n\t\tstatic_branch_enable(&poly1305_use_avx512);\n\treturn IS_REACHABLE(CONFIG_CRYPTO_HASH) ? crypto_register_shash(&alg) : 0;\n}\n\nstatic void __exit poly1305_simd_mod_exit(void)\n{\n\tif (IS_REACHABLE(CONFIG_CRYPTO_HASH))\n\t\tcrypto_unregister_shash(&alg);\n}\n\nmodule_init(poly1305_simd_mod_init);\nmodule_exit(poly1305_simd_mod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\nMODULE_DESCRIPTION(\"Poly1305 authenticator\");\nMODULE_ALIAS_CRYPTO(\"poly1305\");\nMODULE_ALIAS_CRYPTO(\"poly1305-simd\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}