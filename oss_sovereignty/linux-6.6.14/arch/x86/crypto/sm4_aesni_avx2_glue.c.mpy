{
  "module_name": "sm4_aesni_avx2_glue.c",
  "hash_id": "66509f2c8847762669fb981bd8e0b1c00004f7670b8d962c74aa05f0d89d4a66",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/sm4_aesni_avx2_glue.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/kernel.h>\n#include <asm/simd.h>\n#include <crypto/internal/simd.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/sm4.h>\n#include \"sm4-avx.h\"\n\n#define SM4_CRYPT16_BLOCK_SIZE\t(SM4_BLOCK_SIZE * 16)\n\nasmlinkage void sm4_aesni_avx2_ctr_enc_blk16(const u32 *rk, u8 *dst,\n\t\t\t\t\tconst u8 *src, u8 *iv);\nasmlinkage void sm4_aesni_avx2_cbc_dec_blk16(const u32 *rk, u8 *dst,\n\t\t\t\t\tconst u8 *src, u8 *iv);\nasmlinkage void sm4_aesni_avx2_cfb_dec_blk16(const u32 *rk, u8 *dst,\n\t\t\t\t\tconst u8 *src, u8 *iv);\n\nstatic int sm4_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\tunsigned int key_len)\n{\n\tstruct sm4_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\treturn sm4_expandkey(ctx, key, key_len);\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\treturn sm4_avx_cbc_decrypt(req, SM4_CRYPT16_BLOCK_SIZE,\n\t\t\t\tsm4_aesni_avx2_cbc_dec_blk16);\n}\n\n\nstatic int cfb_decrypt(struct skcipher_request *req)\n{\n\treturn sm4_avx_cfb_decrypt(req, SM4_CRYPT16_BLOCK_SIZE,\n\t\t\t\tsm4_aesni_avx2_cfb_dec_blk16);\n}\n\nstatic int ctr_crypt(struct skcipher_request *req)\n{\n\treturn sm4_avx_ctr_crypt(req, SM4_CRYPT16_BLOCK_SIZE,\n\t\t\t\tsm4_aesni_avx2_ctr_enc_blk16);\n}\n\nstatic struct skcipher_alg sm4_aesni_avx2_skciphers[] = {\n\t{\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"__ecb(sm4)\",\n\t\t\t.cra_driver_name\t= \"__ecb-sm4-aesni-avx2\",\n\t\t\t.cra_priority\t\t= 500,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t\t.cra_blocksize\t\t= SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct sm4_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.min_keysize\t= SM4_KEY_SIZE,\n\t\t.max_keysize\t= SM4_KEY_SIZE,\n\t\t.walksize\t= 16 * SM4_BLOCK_SIZE,\n\t\t.setkey\t\t= sm4_skcipher_setkey,\n\t\t.encrypt\t= sm4_avx_ecb_encrypt,\n\t\t.decrypt\t= sm4_avx_ecb_decrypt,\n\t}, {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"__cbc(sm4)\",\n\t\t\t.cra_driver_name\t= \"__cbc-sm4-aesni-avx2\",\n\t\t\t.cra_priority\t\t= 500,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t\t.cra_blocksize\t\t= SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct sm4_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.min_keysize\t= SM4_KEY_SIZE,\n\t\t.max_keysize\t= SM4_KEY_SIZE,\n\t\t.ivsize\t\t= SM4_BLOCK_SIZE,\n\t\t.walksize\t= 16 * SM4_BLOCK_SIZE,\n\t\t.setkey\t\t= sm4_skcipher_setkey,\n\t\t.encrypt\t= sm4_cbc_encrypt,\n\t\t.decrypt\t= cbc_decrypt,\n\t}, {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"__cfb(sm4)\",\n\t\t\t.cra_driver_name\t= \"__cfb-sm4-aesni-avx2\",\n\t\t\t.cra_priority\t\t= 500,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t\t.cra_blocksize\t\t= 1,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct sm4_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.min_keysize\t= SM4_KEY_SIZE,\n\t\t.max_keysize\t= SM4_KEY_SIZE,\n\t\t.ivsize\t\t= SM4_BLOCK_SIZE,\n\t\t.chunksize\t= SM4_BLOCK_SIZE,\n\t\t.walksize\t= 16 * SM4_BLOCK_SIZE,\n\t\t.setkey\t\t= sm4_skcipher_setkey,\n\t\t.encrypt\t= sm4_cfb_encrypt,\n\t\t.decrypt\t= cfb_decrypt,\n\t}, {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"__ctr(sm4)\",\n\t\t\t.cra_driver_name\t= \"__ctr-sm4-aesni-avx2\",\n\t\t\t.cra_priority\t\t= 500,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t\t.cra_blocksize\t\t= 1,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct sm4_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.min_keysize\t= SM4_KEY_SIZE,\n\t\t.max_keysize\t= SM4_KEY_SIZE,\n\t\t.ivsize\t\t= SM4_BLOCK_SIZE,\n\t\t.chunksize\t= SM4_BLOCK_SIZE,\n\t\t.walksize\t= 16 * SM4_BLOCK_SIZE,\n\t\t.setkey\t\t= sm4_skcipher_setkey,\n\t\t.encrypt\t= ctr_crypt,\n\t\t.decrypt\t= ctr_crypt,\n\t}\n};\n\nstatic struct simd_skcipher_alg *\nsimd_sm4_aesni_avx2_skciphers[ARRAY_SIZE(sm4_aesni_avx2_skciphers)];\n\nstatic int __init sm4_init(void)\n{\n\tconst char *feature_name;\n\n\tif (!boot_cpu_has(X86_FEATURE_AVX) ||\n\t    !boot_cpu_has(X86_FEATURE_AVX2) ||\n\t    !boot_cpu_has(X86_FEATURE_AES) ||\n\t    !boot_cpu_has(X86_FEATURE_OSXSAVE)) {\n\t\tpr_info(\"AVX2 or AES-NI instructions are not detected.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM,\n\t\t\t\t&feature_name)) {\n\t\tpr_info(\"CPU feature '%s' is not supported.\\n\", feature_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn simd_register_skciphers_compat(sm4_aesni_avx2_skciphers,\n\t\t\t\t\tARRAY_SIZE(sm4_aesni_avx2_skciphers),\n\t\t\t\t\tsimd_sm4_aesni_avx2_skciphers);\n}\n\nstatic void __exit sm4_exit(void)\n{\n\tsimd_unregister_skciphers(sm4_aesni_avx2_skciphers,\n\t\t\t\tARRAY_SIZE(sm4_aesni_avx2_skciphers),\n\t\t\t\tsimd_sm4_aesni_avx2_skciphers);\n}\n\nmodule_init(sm4_init);\nmodule_exit(sm4_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tianjia Zhang <tianjia.zhang@linux.alibaba.com>\");\nMODULE_DESCRIPTION(\"SM4 Cipher Algorithm, AES-NI/AVX2 optimized\");\nMODULE_ALIAS_CRYPTO(\"sm4\");\nMODULE_ALIAS_CRYPTO(\"sm4-aesni-avx2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}