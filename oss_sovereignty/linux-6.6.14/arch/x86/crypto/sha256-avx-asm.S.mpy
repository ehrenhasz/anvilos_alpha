{
  "module_name": "sha256-avx-asm.S",
  "hash_id": "a14232dd61bbeb2b789548aec65be85ad5939dd1852be2d6615a8106e72c05f7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/sha256-avx-asm.S",
  "human_readable_source": "########################################################################\n# Implement fast SHA-256 with AVX1 instructions. (x86_64)\n#\n# Copyright (C) 2013 Intel Corporation.\n#\n# Authors:\n#     James Guilford <james.guilford@intel.com>\n#     Kirk Yap <kirk.s.yap@intel.com>\n#     Tim Chen <tim.c.chen@linux.intel.com>\n#\n# This software is available to you under a choice of one of two\n# licenses.  You may choose to be licensed under the terms of the GNU\n# General Public License (GPL) Version 2, available from the file\n# COPYING in the main directory of this source tree, or the\n# OpenIB.org BSD license below:\n#\n#     Redistribution and use in source and binary forms, with or\n#     without modification, are permitted provided that the following\n#     conditions are met:\n#\n#      - Redistributions of source code must retain the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer.\n#\n#      - Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials\n#        provided with the distribution.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n########################################################################\n#\n# This code is described in an Intel White-Paper:\n# \"Fast SHA-256 Implementations on Intel Architecture Processors\"\n#\n# To find it, surf to http: \n# and search for that title.\n#\n########################################################################\n# This code schedules 1 block at a time, with 4 lanes per block\n########################################################################\n\n#include <linux/linkage.h>\n#include <linux/cfi_types.h>\n\n## assume buffers not aligned\n#define    VMOVDQ vmovdqu\n\n################################ Define Macros\n\n# addm [mem], reg\n# Add reg to mem using reg-mem add and store\n.macro addm p1 p2\n\tadd     \\p1, \\p2\n\tmov     \\p2, \\p1\n.endm\n\n\n.macro MY_ROR p1 p2\n\tshld    $(32-(\\p1)), \\p2, \\p2\n.endm\n\n################################\n\n# COPY_XMM_AND_BSWAP xmm, [mem], byte_flip_mask\n# Load xmm with mem and byte swap each dword\n.macro COPY_XMM_AND_BSWAP p1 p2 p3\n\tVMOVDQ \\p2, \\p1\n\tvpshufb \\p3, \\p1, \\p1\n.endm\n\n################################\n\nX0 = %xmm4\nX1 = %xmm5\nX2 = %xmm6\nX3 = %xmm7\n\nXTMP0 = %xmm0\nXTMP1 = %xmm1\nXTMP2 = %xmm2\nXTMP3 = %xmm3\nXTMP4 = %xmm8\nXFER = %xmm9\nXTMP5 = %xmm11\n\nSHUF_00BA = %xmm10      # shuffle xBxA -> 00BA\nSHUF_DC00 = %xmm12      # shuffle xDxC -> DC00\nBYTE_FLIP_MASK = %xmm13\n\nNUM_BLKS = %rdx   # 3rd arg\nINP = %rsi        # 2nd arg\nCTX = %rdi        # 1st arg\n\nSRND = %rsi       # clobbers INP\nc = %ecx\nd = %r8d\ne = %edx\nTBL = %r12\na = %eax\nb = %ebx\n\nf = %r9d\ng = %r10d\nh = %r11d\n\ny0 = %r13d\ny1 = %r14d\ny2 = %r15d\n\n\n_INP_END_SIZE = 8\n_INP_SIZE = 8\n_XFER_SIZE = 16\n_XMM_SAVE_SIZE = 0\n\n_INP_END = 0\n_INP            = _INP_END  + _INP_END_SIZE\n_XFER           = _INP      + _INP_SIZE\n_XMM_SAVE       = _XFER     + _XFER_SIZE\nSTACK_SIZE      = _XMM_SAVE + _XMM_SAVE_SIZE\n\n# rotate_Xs\n# Rotate values of symbols X0...X3\n.macro rotate_Xs\nX_ = X0\nX0 = X1\nX1 = X2\nX2 = X3\nX3 = X_\n.endm\n\n# ROTATE_ARGS\n# Rotate values of symbols a...h\n.macro ROTATE_ARGS\nTMP_ = h\nh = g\ng = f\nf = e\ne = d\nd = c\nc = b\nb = a\na = TMP_\n.endm\n\n.macro FOUR_ROUNDS_AND_SCHED\n\t## compute s0 four at a time and s1 two at a time\n\t## compute W[-16] + W[-7] 4 at a time\n\n\tmov     e, y0\t\t\t# y0 = e\n\tMY_ROR  (25-11), y0             # y0 = e >> (25-11)\n\tmov     a, y1                   # y1 = a\n\tvpalignr $4, X2, X3, XTMP0      # XTMP0 = W[-7]\n\tMY_ROR  (22-13), y1             # y1 = a >> (22-13)\n\txor     e, y0                   # y0 = e ^ (e >> (25-11))\n\tmov     f, y2                   # y2 = f\n\tMY_ROR  (11-6), y0              # y0 = (e >> (11-6)) ^ (e >> (25-6))\n\txor     a, y1                   # y1 = a ^ (a >> (22-13)\n\txor     g, y2                   # y2 = f^g\n\tvpaddd  X0, XTMP0, XTMP0        # XTMP0 = W[-7] + W[-16]\n\txor     e, y0                   # y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n\tand     e, y2                   # y2 = (f^g)&e\n\tMY_ROR  (13-2), y1              # y1 = (a >> (13-2)) ^ (a >> (22-2))\n\t## compute s0\n\tvpalignr $4, X0, X1, XTMP1      # XTMP1 = W[-15]\n\txor     a, y1                   # y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n\tMY_ROR  6, y0                   # y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n\txor     g, y2                   # y2 = CH = ((f^g)&e)^g\n\tMY_ROR  2, y1                   # y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n\tadd     y0, y2                  # y2 = S1 + CH\n\tadd     _XFER(%rsp), y2         # y2 = k + w + S1 + CH\n\tmov     a, y0                   # y0 = a\n\tadd     y2, h                   # h = h + S1 + CH + k + w\n\tmov     a, y2                   # y2 = a\n\tvpsrld  $7, XTMP1, XTMP2\n\tor      c, y0                   # y0 = a|c\n\tadd     h, d                    # d = d + h + S1 + CH + k + w\n\tand     c, y2                   # y2 = a&c\n\tvpslld  $(32-7), XTMP1, XTMP3\n\tand     b, y0                   # y0 = (a|c)&b\n\tadd     y1, h                   # h = h + S1 + CH + k + w + S0\n\tvpor    XTMP2, XTMP3, XTMP3     # XTMP1 = W[-15] MY_ROR 7\n\tor      y2, y0                  # y0 = MAJ = (a|c)&b)|(a&c)\n\tadd     y0, h                   # h = h + S1 + CH + k + w + S0 + MAJ\n\tROTATE_ARGS\n\tmov     e, y0                   # y0 = e\n\tmov     a, y1                   # y1 = a\n\tMY_ROR  (25-11), y0             # y0 = e >> (25-11)\n\txor     e, y0                   # y0 = e ^ (e >> (25-11))\n\tmov     f, y2                   # y2 = f\n\tMY_ROR  (22-13), y1             # y1 = a >> (22-13)\n\tvpsrld  $18, XTMP1, XTMP2       #\n\txor     a, y1                   # y1 = a ^ (a >> (22-13)\n\tMY_ROR  (11-6), y0              # y0 = (e >> (11-6)) ^ (e >> (25-6))\n\txor     g, y2                   # y2 = f^g\n\tvpsrld  $3, XTMP1, XTMP4        # XTMP4 = W[-15] >> 3\n\tMY_ROR  (13-2), y1              # y1 = (a >> (13-2)) ^ (a >> (22-2))\n\txor     e, y0                   # y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n\tand     e, y2                   # y2 = (f^g)&e\n\tMY_ROR  6, y0                   # y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n\tvpslld  $(32-18), XTMP1, XTMP1\n\txor     a, y1                   # y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n\txor     g, y2                   # y2 = CH = ((f^g)&e)^g\n\tvpxor   XTMP1, XTMP3, XTMP3     #\n\tadd     y0, y2                  # y2 = S1 + CH\n\tadd     (1*4 + _XFER)(%rsp), y2 # y2 = k + w + S1 + CH\n\tMY_ROR  2, y1                   # y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n\tvpxor   XTMP2, XTMP3, XTMP3     # XTMP1 = W[-15] MY_ROR 7 ^ W[-15] MY_ROR\n\tmov     a, y0                   # y0 = a\n\tadd     y2, h                   # h = h + S1 + CH + k + w\n\tmov     a, y2                   # y2 = a\n\tvpxor   XTMP4, XTMP3, XTMP1     # XTMP1 = s0\n\tor      c, y0                   # y0 = a|c\n\tadd     h, d                    # d = d + h + S1 + CH + k + w\n\tand     c, y2                   # y2 = a&c\n\t## compute low s1\n\tvpshufd $0b11111010, X3, XTMP2  # XTMP2 = W[-2] {BBAA}\n\tand     b, y0                   # y0 = (a|c)&b\n\tadd     y1, h                   # h = h + S1 + CH + k + w + S0\n\tvpaddd  XTMP1, XTMP0, XTMP0     # XTMP0 = W[-16] + W[-7] + s0\n\tor      y2, y0                  # y0 = MAJ = (a|c)&b)|(a&c)\n\tadd     y0, h                   # h = h + S1 + CH + k + w + S0 + MAJ\n\tROTATE_ARGS\n\tmov     e, y0                   # y0 = e\n\tmov     a, y1                   # y1 = a\n\tMY_ROR  (25-11), y0             # y0 = e >> (25-11)\n\txor     e, y0                   # y0 = e ^ (e >> (25-11))\n\tMY_ROR  (22-13), y1             # y1 = a >> (22-13)\n\tmov     f, y2                   # y2 = f\n\txor     a, y1                   # y1 = a ^ (a >> (22-13)\n\tMY_ROR  (11-6), y0              # y0 = (e >> (11-6)) ^ (e >> (25-6))\n\tvpsrld  $10, XTMP2, XTMP4       # XTMP4 = W[-2] >> 10 {BBAA}\n\txor     g, y2                   # y2 = f^g\n\tvpsrlq  $19, XTMP2, XTMP3       # XTMP3 = W[-2] MY_ROR 19 {xBxA}\n\txor     e, y0                   # y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n\tand     e, y2                   # y2 = (f^g)&e\n\tvpsrlq  $17, XTMP2, XTMP2       # XTMP2 = W[-2] MY_ROR 17 {xBxA}\n\tMY_ROR  (13-2), y1              # y1 = (a >> (13-2)) ^ (a >> (22-2))\n\txor     a, y1                   # y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n\txor     g, y2                   # y2 = CH = ((f^g)&e)^g\n\tMY_ROR  6, y0                   # y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n\tvpxor   XTMP3, XTMP2, XTMP2     #\n\tadd     y0, y2                  # y2 = S1 + CH\n\tMY_ROR  2, y1                   # y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n\tadd     (2*4 + _XFER)(%rsp), y2 # y2 = k + w + S1 + CH\n\tvpxor   XTMP2, XTMP4, XTMP4     # XTMP4 = s1 {xBxA}\n\tmov     a, y0                   # y0 = a\n\tadd     y2, h                   # h = h + S1 + CH + k + w\n\tmov     a, y2                   # y2 = a\n\tvpshufb SHUF_00BA, XTMP4, XTMP4 # XTMP4 = s1 {00BA}\n\tor      c, y0                   # y0 = a|c\n\tadd     h, d                    # d = d + h + S1 + CH + k + w\n\tand     c, y2                   # y2 = a&c\n\tvpaddd  XTMP4, XTMP0, XTMP0     # XTMP0 = {..., ..., W[1], W[0]}\n\tand     b, y0                   # y0 = (a|c)&b\n\tadd     y1, h                   # h = h + S1 + CH + k + w + S0\n\t## compute high s1\n\tvpshufd $0b01010000, XTMP0, XTMP2 # XTMP2 = W[-2] {DDCC}\n\tor      y2, y0                  # y0 = MAJ = (a|c)&b)|(a&c)\n\tadd     y0, h                   # h = h + S1 + CH + k + w + S0 + MAJ\n\tROTATE_ARGS\n\tmov     e, y0                   # y0 = e\n\tMY_ROR  (25-11), y0             # y0 = e >> (25-11)\n\tmov     a, y1                   # y1 = a\n\tMY_ROR  (22-13), y1             # y1 = a >> (22-13)\n\txor     e, y0                   # y0 = e ^ (e >> (25-11))\n\tmov     f, y2                   # y2 = f\n\tMY_ROR  (11-6), y0              # y0 = (e >> (11-6)) ^ (e >> (25-6))\n\tvpsrld  $10, XTMP2, XTMP5       # XTMP5 = W[-2] >> 10 {DDCC}\n\txor     a, y1                   # y1 = a ^ (a >> (22-13)\n\txor     g, y2                   # y2 = f^g\n\tvpsrlq  $19, XTMP2, XTMP3       # XTMP3 = W[-2] MY_ROR 19 {xDxC}\n\txor     e, y0                   # y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n\tand     e, y2                   # y2 = (f^g)&e\n\tMY_ROR  (13-2), y1              # y1 = (a >> (13-2)) ^ (a >> (22-2))\n\tvpsrlq  $17, XTMP2, XTMP2       # XTMP2 = W[-2] MY_ROR 17 {xDxC}\n\txor     a, y1                   # y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n\tMY_ROR  6, y0                   # y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n\txor     g, y2                   # y2 = CH = ((f^g)&e)^g\n\tvpxor   XTMP3, XTMP2, XTMP2\n\tMY_ROR  2, y1                   # y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n\tadd     y0, y2                  # y2 = S1 + CH\n\tadd     (3*4 + _XFER)(%rsp), y2 # y2 = k + w + S1 + CH\n\tvpxor   XTMP2, XTMP5, XTMP5     # XTMP5 = s1 {xDxC}\n\tmov     a, y0                   # y0 = a\n\tadd     y2, h                   # h = h + S1 + CH + k + w\n\tmov     a, y2                   # y2 = a\n\tvpshufb SHUF_DC00, XTMP5, XTMP5 # XTMP5 = s1 {DC00}\n\tor      c, y0                   # y0 = a|c\n\tadd     h, d                    # d = d + h + S1 + CH + k + w\n\tand     c, y2                   # y2 = a&c\n\tvpaddd  XTMP0, XTMP5, X0        # X0 = {W[3], W[2], W[1], W[0]}\n\tand     b, y0                   # y0 = (a|c)&b\n\tadd     y1, h                   # h = h + S1 + CH + k + w + S0\n\tor      y2, y0                  # y0 = MAJ = (a|c)&b)|(a&c)\n\tadd     y0, h                   # h = h + S1 + CH + k + w + S0 + MAJ\n\tROTATE_ARGS\n\trotate_Xs\n.endm\n\n## input is [rsp + _XFER + %1 * 4]\n.macro DO_ROUND round\n\tmov\te, y0\t\t\t# y0 = e\n        MY_ROR  (25-11), y0             # y0 = e >> (25-11)\n        mov     a, y1                   # y1 = a\n        xor     e, y0                   # y0 = e ^ (e >> (25-11))\n        MY_ROR  (22-13), y1             # y1 = a >> (22-13)\n        mov     f, y2                   # y2 = f\n        xor     a, y1                   # y1 = a ^ (a >> (22-13)\n        MY_ROR  (11-6), y0              # y0 = (e >> (11-6)) ^ (e >> (25-6))\n        xor     g, y2                   # y2 = f^g\n        xor     e, y0                   # y0 = e ^ (e >> (11-6)) ^ (e >> (25-6))\n        MY_ROR  (13-2), y1              # y1 = (a >> (13-2)) ^ (a >> (22-2))\n        and     e, y2                   # y2 = (f^g)&e\n        xor     a, y1                   # y1 = a ^ (a >> (13-2)) ^ (a >> (22-2))\n        MY_ROR  6, y0                   # y0 = S1 = (e>>6) & (e>>11) ^ (e>>25)\n        xor     g, y2                   # y2 = CH = ((f^g)&e)^g\n        add     y0, y2                  # y2 = S1 + CH\n        MY_ROR  2, y1                   # y1 = S0 = (a>>2) ^ (a>>13) ^ (a>>22)\n        offset = \\round * 4 + _XFER     #\n        add     offset(%rsp), y2\t# y2 = k + w + S1 + CH\n        mov     a, y0\t\t\t# y0 = a\n        add     y2, h                   # h = h + S1 + CH + k + w\n        mov     a, y2                   # y2 = a\n        or      c, y0                   # y0 = a|c\n        add     h, d                    # d = d + h + S1 + CH + k + w\n        and     c, y2                   # y2 = a&c\n        and     b, y0                   # y0 = (a|c)&b\n        add     y1, h                   # h = h + S1 + CH + k + w + S0\n        or      y2, y0                  # y0 = MAJ = (a|c)&b)|(a&c)\n        add     y0, h                   # h = h + S1 + CH + k + w + S0 + MAJ\n        ROTATE_ARGS\n.endm\n\n########################################################################\n## void sha256_transform_avx(state sha256_state *state, const u8 *data, int blocks)\n## arg 1 : pointer to state\n## arg 2 : pointer to input data\n## arg 3 : Num blocks\n########################################################################\n.text\nSYM_TYPED_FUNC_START(sha256_transform_avx)\n\tpushq   %rbx\n\tpushq   %r12\n\tpushq   %r13\n\tpushq   %r14\n\tpushq   %r15\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\n\tsubq    $STACK_SIZE, %rsp\t# allocate stack space\n\tand\t$~15, %rsp\t\t# align stack pointer\n\n\tshl     $6, NUM_BLKS\t\t# convert to bytes\n\tjz      .Ldone_hash\n\tadd     INP, NUM_BLKS\t\t# pointer to end of data\n\tmov     NUM_BLKS, _INP_END(%rsp)\n\n\t## load initial digest\n\tmov     4*0(CTX), a\n\tmov     4*1(CTX), b\n\tmov     4*2(CTX), c\n\tmov     4*3(CTX), d\n\tmov     4*4(CTX), e\n\tmov     4*5(CTX), f\n\tmov     4*6(CTX), g\n\tmov     4*7(CTX), h\n\n\tvmovdqa  PSHUFFLE_BYTE_FLIP_MASK(%rip), BYTE_FLIP_MASK\n\tvmovdqa  _SHUF_00BA(%rip), SHUF_00BA\n\tvmovdqa  _SHUF_DC00(%rip), SHUF_DC00\n.Lloop0:\n\tlea     K256(%rip), TBL\n\n\t## byte swap first 16 dwords\n\tCOPY_XMM_AND_BSWAP      X0, 0*16(INP), BYTE_FLIP_MASK\n\tCOPY_XMM_AND_BSWAP      X1, 1*16(INP), BYTE_FLIP_MASK\n\tCOPY_XMM_AND_BSWAP      X2, 2*16(INP), BYTE_FLIP_MASK\n\tCOPY_XMM_AND_BSWAP      X3, 3*16(INP), BYTE_FLIP_MASK\n\n\tmov     INP, _INP(%rsp)\n\n\t## schedule 48 input dwords, by doing 3 rounds of 16 each\n\tmov     $3, SRND\n.align 16\n.Lloop1:\n\tvpaddd  (TBL), X0, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tFOUR_ROUNDS_AND_SCHED\n\n\tvpaddd  1*16(TBL), X0, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tFOUR_ROUNDS_AND_SCHED\n\n\tvpaddd  2*16(TBL), X0, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tFOUR_ROUNDS_AND_SCHED\n\n\tvpaddd  3*16(TBL), X0, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tadd\t$4*16, TBL\n\tFOUR_ROUNDS_AND_SCHED\n\n\tsub     $1, SRND\n\tjne     .Lloop1\n\n\tmov     $2, SRND\n.Lloop2:\n\tvpaddd  (TBL), X0, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tDO_ROUND        0\n\tDO_ROUND        1\n\tDO_ROUND        2\n\tDO_ROUND        3\n\n\tvpaddd  1*16(TBL), X1, XFER\n\tvmovdqa XFER, _XFER(%rsp)\n\tadd     $2*16, TBL\n\tDO_ROUND        0\n\tDO_ROUND        1\n\tDO_ROUND        2\n\tDO_ROUND        3\n\n\tvmovdqa X2, X0\n\tvmovdqa X3, X1\n\n\tsub     $1, SRND\n\tjne     .Lloop2\n\n\taddm    (4*0)(CTX),a\n\taddm    (4*1)(CTX),b\n\taddm    (4*2)(CTX),c\n\taddm    (4*3)(CTX),d\n\taddm    (4*4)(CTX),e\n\taddm    (4*5)(CTX),f\n\taddm    (4*6)(CTX),g\n\taddm    (4*7)(CTX),h\n\n\tmov     _INP(%rsp), INP\n\tadd     $64, INP\n\tcmp     _INP_END(%rsp), INP\n\tjne     .Lloop0\n\n.Ldone_hash:\n\n\tmov\t%rbp, %rsp\n\tpopq\t%rbp\n\tpopq    %r15\n\tpopq    %r14\n\tpopq    %r13\n\tpopq\t%r12\n\tpopq    %rbx\n\tRET\nSYM_FUNC_END(sha256_transform_avx)\n\n.section\t.rodata.cst256.K256, \"aM\", @progbits, 256\n.align 64\nK256:\n\t.long 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5\n\t.long 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5\n\t.long 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3\n\t.long 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174\n\t.long 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc\n\t.long 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da\n\t.long 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7\n\t.long 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967\n\t.long 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13\n\t.long 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85\n\t.long 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3\n\t.long 0xd192e819,0xd6990624,0xf40e3585,0x106aa070\n\t.long 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5\n\t.long 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3\n\t.long 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208\n\t.long 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2\n\n.section\t.rodata.cst16.PSHUFFLE_BYTE_FLIP_MASK, \"aM\", @progbits, 16\n.align 16\nPSHUFFLE_BYTE_FLIP_MASK:\n\t.octa 0x0c0d0e0f08090a0b0405060700010203\n\n.section\t.rodata.cst16._SHUF_00BA, \"aM\", @progbits, 16\n.align 16\n# shuffle xBxA -> 00BA\n_SHUF_00BA:\n\t.octa 0xFFFFFFFFFFFFFFFF0b0a090803020100\n\n.section\t.rodata.cst16._SHUF_DC00, \"aM\", @progbits, 16\n.align 16\n# shuffle xDxC -> DC00\n_SHUF_DC00:\n\t.octa 0x0b0a090803020100FFFFFFFFFFFFFFFF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}