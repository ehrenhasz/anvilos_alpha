{
  "module_name": "crc32-pclmul_glue.c",
  "hash_id": "2b0e2ef947b2d9d6360b5f5ed5dd316a6ce4050e582b8dd70e5ffa97d3201480",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/crc32-pclmul_glue.c",
  "human_readable_source": " \n\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/crc32.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/simd.h>\n\n#include <asm/cpufeatures.h>\n#include <asm/cpu_device_id.h>\n#include <asm/simd.h>\n\n#define CHKSUM_BLOCK_SIZE\t1\n#define CHKSUM_DIGEST_SIZE\t4\n\n#define PCLMUL_MIN_LEN\t\t64L      \n#define SCALE_F\t\t\t16L\t \n#define SCALE_F_MASK\t\t(SCALE_F - 1)\n\nu32 crc32_pclmul_le_16(unsigned char const *buffer, size_t len, u32 crc32);\n\nstatic u32 __attribute__((pure))\n\tcrc32_pclmul_le(u32 crc, unsigned char const *p, size_t len)\n{\n\tunsigned int iquotient;\n\tunsigned int iremainder;\n\tunsigned int prealign;\n\n\tif (len < PCLMUL_MIN_LEN + SCALE_F_MASK || !crypto_simd_usable())\n\t\treturn crc32_le(crc, p, len);\n\n\tif ((long)p & SCALE_F_MASK) {\n\t\t \n\t\tprealign = SCALE_F - ((long)p & SCALE_F_MASK);\n\n\t\tcrc = crc32_le(crc, p, prealign);\n\t\tlen -= prealign;\n\t\tp = (unsigned char *)(((unsigned long)p + SCALE_F_MASK) &\n\t\t\t\t     ~SCALE_F_MASK);\n\t}\n\tiquotient = len & (~SCALE_F_MASK);\n\tiremainder = len & SCALE_F_MASK;\n\n\tkernel_fpu_begin();\n\tcrc = crc32_pclmul_le_16(p, iquotient, crc);\n\tkernel_fpu_end();\n\n\tif (iremainder)\n\t\tcrc = crc32_le(crc, p + iquotient, iremainder);\n\n\treturn crc;\n}\n\nstatic int crc32_pclmul_cra_init(struct crypto_tfm *tfm)\n{\n\tu32 *key = crypto_tfm_ctx(tfm);\n\n\t*key = 0;\n\n\treturn 0;\n}\n\nstatic int crc32_pclmul_setkey(struct crypto_shash *hash, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tu32 *mctx = crypto_shash_ctx(hash);\n\n\tif (keylen != sizeof(u32))\n\t\treturn -EINVAL;\n\t*mctx = le32_to_cpup((__le32 *)key);\n\treturn 0;\n}\n\nstatic int crc32_pclmul_init(struct shash_desc *desc)\n{\n\tu32 *mctx = crypto_shash_ctx(desc->tfm);\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*crcp = *mctx;\n\n\treturn 0;\n}\n\nstatic int crc32_pclmul_update(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len)\n{\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*crcp = crc32_pclmul_le(*crcp, data, len);\n\treturn 0;\n}\n\n \nstatic int __crc32_pclmul_finup(u32 *crcp, const u8 *data, unsigned int len,\n\t\t\t\tu8 *out)\n{\n\t*(__le32 *)out = cpu_to_le32(crc32_pclmul_le(*crcp, data, len));\n\treturn 0;\n}\n\nstatic int crc32_pclmul_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn __crc32_pclmul_finup(shash_desc_ctx(desc), data, len, out);\n}\n\nstatic int crc32_pclmul_final(struct shash_desc *desc, u8 *out)\n{\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*(__le32 *)out = cpu_to_le32p(crcp);\n\treturn 0;\n}\n\nstatic int crc32_pclmul_digest(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len, u8 *out)\n{\n\treturn __crc32_pclmul_finup(crypto_shash_ctx(desc->tfm), data, len,\n\t\t\t\t    out);\n}\n\nstatic struct shash_alg alg = {\n\t.setkey\t\t= crc32_pclmul_setkey,\n\t.init\t\t= crc32_pclmul_init,\n\t.update\t\t= crc32_pclmul_update,\n\t.final\t\t= crc32_pclmul_final,\n\t.finup\t\t= crc32_pclmul_finup,\n\t.digest\t\t= crc32_pclmul_digest,\n\t.descsize\t= sizeof(u32),\n\t.digestsize\t= CHKSUM_DIGEST_SIZE,\n\t.base\t\t= {\n\t\t\t.cra_name\t\t= \"crc32\",\n\t\t\t.cra_driver_name\t= \"crc32-pclmul\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_OPTIONAL_KEY,\n\t\t\t.cra_blocksize\t\t= CHKSUM_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(u32),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= crc32_pclmul_cra_init,\n\t}\n};\n\nstatic const struct x86_cpu_id crc32pclmul_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_PCLMULQDQ, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, crc32pclmul_cpu_id);\n\n\nstatic int __init crc32_pclmul_mod_init(void)\n{\n\n\tif (!x86_match_cpu(crc32pclmul_cpu_id)) {\n\t\tpr_info(\"PCLMULQDQ-NI instructions are not detected.\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn crypto_register_shash(&alg);\n}\n\nstatic void __exit crc32_pclmul_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n\nmodule_init(crc32_pclmul_mod_init);\nmodule_exit(crc32_pclmul_mod_fini);\n\nMODULE_AUTHOR(\"Alexander Boyko <alexander_boyko@xyratex.com>\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS_CRYPTO(\"crc32\");\nMODULE_ALIAS_CRYPTO(\"crc32-pclmul\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}