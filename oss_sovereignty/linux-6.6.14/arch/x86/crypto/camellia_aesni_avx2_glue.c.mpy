{
  "module_name": "camellia_aesni_avx2_glue.c",
  "hash_id": "d7ee23bbe612ccc8646f2e6997d64b752758239c4a1320a5b8e121c97769a720",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/camellia_aesni_avx2_glue.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/simd.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include \"camellia.h\"\n#include \"ecb_cbc_helpers.h\"\n\n#define CAMELLIA_AESNI_PARALLEL_BLOCKS 16\n#define CAMELLIA_AESNI_AVX2_PARALLEL_BLOCKS 32\n\n \nasmlinkage void camellia_ecb_enc_32way(const void *ctx, u8 *dst, const u8 *src);\nasmlinkage void camellia_ecb_dec_32way(const void *ctx, u8 *dst, const u8 *src);\n\nasmlinkage void camellia_cbc_dec_32way(const void *ctx, u8 *dst, const u8 *src);\n\nstatic int camellia_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn __camellia_setkey(crypto_skcipher_ctx(tfm), key, keylen);\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAMELLIA_BLOCK_SIZE, CAMELLIA_AESNI_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAMELLIA_AESNI_AVX2_PARALLEL_BLOCKS, camellia_ecb_enc_32way);\n\tECB_BLOCK(CAMELLIA_AESNI_PARALLEL_BLOCKS, camellia_ecb_enc_16way);\n\tECB_BLOCK(2, camellia_enc_blk_2way);\n\tECB_BLOCK(1, camellia_enc_blk);\n\tECB_WALK_END();\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAMELLIA_BLOCK_SIZE, CAMELLIA_AESNI_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAMELLIA_AESNI_AVX2_PARALLEL_BLOCKS, camellia_ecb_dec_32way);\n\tECB_BLOCK(CAMELLIA_AESNI_PARALLEL_BLOCKS, camellia_ecb_dec_16way);\n\tECB_BLOCK(2, camellia_dec_blk_2way);\n\tECB_BLOCK(1, camellia_dec_blk);\n\tECB_WALK_END();\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAMELLIA_BLOCK_SIZE, -1);\n\tCBC_ENC_BLOCK(camellia_enc_blk);\n\tCBC_WALK_END();\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAMELLIA_BLOCK_SIZE, CAMELLIA_AESNI_PARALLEL_BLOCKS);\n\tCBC_DEC_BLOCK(CAMELLIA_AESNI_AVX2_PARALLEL_BLOCKS, camellia_cbc_dec_32way);\n\tCBC_DEC_BLOCK(CAMELLIA_AESNI_PARALLEL_BLOCKS, camellia_cbc_dec_16way);\n\tCBC_DEC_BLOCK(2, camellia_decrypt_cbc_2way);\n\tCBC_DEC_BLOCK(1, camellia_dec_blk);\n\tCBC_WALK_END();\n}\n\nstatic struct skcipher_alg camellia_algs[] = {\n\t{\n\t\t.base.cra_name\t\t= \"__ecb(camellia)\",\n\t\t.base.cra_driver_name\t= \"__ecb-camellia-aesni-avx2\",\n\t\t.base.cra_priority\t= 500,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAMELLIA_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct camellia_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAMELLIA_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAMELLIA_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= camellia_setkey,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"__cbc(camellia)\",\n\t\t.base.cra_driver_name\t= \"__cbc-camellia-aesni-avx2\",\n\t\t.base.cra_priority\t= 500,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAMELLIA_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct camellia_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAMELLIA_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAMELLIA_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= CAMELLIA_BLOCK_SIZE,\n\t\t.setkey\t\t\t= camellia_setkey,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t},\n};\n\nstatic struct simd_skcipher_alg *camellia_simd_algs[ARRAY_SIZE(camellia_algs)];\n\nstatic int __init camellia_aesni_init(void)\n{\n\tconst char *feature_name;\n\n\tif (!boot_cpu_has(X86_FEATURE_AVX) ||\n\t    !boot_cpu_has(X86_FEATURE_AVX2) ||\n\t    !boot_cpu_has(X86_FEATURE_AES) ||\n\t    !boot_cpu_has(X86_FEATURE_OSXSAVE)) {\n\t\tpr_info(\"AVX2 or AES-NI instructions are not detected.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM,\n\t\t\t\t&feature_name)) {\n\t\tpr_info(\"CPU feature '%s' is not supported.\\n\", feature_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn simd_register_skciphers_compat(camellia_algs,\n\t\t\t\t\t      ARRAY_SIZE(camellia_algs),\n\t\t\t\t\t      camellia_simd_algs);\n}\n\nstatic void __exit camellia_aesni_fini(void)\n{\n\tsimd_unregister_skciphers(camellia_algs, ARRAY_SIZE(camellia_algs),\n\t\t\t\t  camellia_simd_algs);\n}\n\nmodule_init(camellia_aesni_init);\nmodule_exit(camellia_aesni_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Camellia Cipher Algorithm, AES-NI/AVX2 optimized\");\nMODULE_ALIAS_CRYPTO(\"camellia\");\nMODULE_ALIAS_CRYPTO(\"camellia-asm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}