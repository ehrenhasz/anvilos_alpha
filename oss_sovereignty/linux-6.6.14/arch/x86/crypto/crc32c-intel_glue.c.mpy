{
  "module_name": "crc32c-intel_glue.c",
  "hash_id": "6a64a1b26d1d327ec2e21459b28595f7ef29bd5649ebfc8faa010e8edf5fdde7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/crc32c-intel_glue.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/simd.h>\n\n#include <asm/cpufeatures.h>\n#include <asm/cpu_device_id.h>\n#include <asm/simd.h>\n\n#define CHKSUM_BLOCK_SIZE\t1\n#define CHKSUM_DIGEST_SIZE\t4\n\n#define SCALE_F\tsizeof(unsigned long)\n\n#ifdef CONFIG_X86_64\n#define CRC32_INST \"crc32q %1, %q0\"\n#else\n#define CRC32_INST \"crc32l %1, %0\"\n#endif\n\n#ifdef CONFIG_X86_64\n \n#define CRC32C_PCL_BREAKEVEN\t512\n\nasmlinkage unsigned int crc_pcl(const u8 *buffer, int len,\n\t\t\t\tunsigned int crc_init);\n#endif  \n\nstatic u32 crc32c_intel_le_hw_byte(u32 crc, unsigned char const *data, size_t length)\n{\n\twhile (length--) {\n\t\tasm(\"crc32b %1, %0\"\n\t\t    : \"+r\" (crc) : \"rm\" (*data));\n\t\tdata++;\n\t}\n\n\treturn crc;\n}\n\nstatic u32 __pure crc32c_intel_le_hw(u32 crc, unsigned char const *p, size_t len)\n{\n\tunsigned int iquotient = len / SCALE_F;\n\tunsigned int iremainder = len % SCALE_F;\n\tunsigned long *ptmp = (unsigned long *)p;\n\n\twhile (iquotient--) {\n\t\tasm(CRC32_INST\n\t\t    : \"+r\" (crc) : \"rm\" (*ptmp));\n\t\tptmp++;\n\t}\n\n\tif (iremainder)\n\t\tcrc = crc32c_intel_le_hw_byte(crc, (unsigned char *)ptmp,\n\t\t\t\t iremainder);\n\n\treturn crc;\n}\n\n \nstatic int crc32c_intel_setkey(struct crypto_shash *hash, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tu32 *mctx = crypto_shash_ctx(hash);\n\n\tif (keylen != sizeof(u32))\n\t\treturn -EINVAL;\n\t*mctx = le32_to_cpup((__le32 *)key);\n\treturn 0;\n}\n\nstatic int crc32c_intel_init(struct shash_desc *desc)\n{\n\tu32 *mctx = crypto_shash_ctx(desc->tfm);\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*crcp = *mctx;\n\n\treturn 0;\n}\n\nstatic int crc32c_intel_update(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len)\n{\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*crcp = crc32c_intel_le_hw(*crcp, data, len);\n\treturn 0;\n}\n\nstatic int __crc32c_intel_finup(u32 *crcp, const u8 *data, unsigned int len,\n\t\t\t\tu8 *out)\n{\n\t*(__le32 *)out = ~cpu_to_le32(crc32c_intel_le_hw(*crcp, data, len));\n\treturn 0;\n}\n\nstatic int crc32c_intel_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn __crc32c_intel_finup(shash_desc_ctx(desc), data, len, out);\n}\n\nstatic int crc32c_intel_final(struct shash_desc *desc, u8 *out)\n{\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t*(__le32 *)out = ~cpu_to_le32p(crcp);\n\treturn 0;\n}\n\nstatic int crc32c_intel_digest(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len, u8 *out)\n{\n\treturn __crc32c_intel_finup(crypto_shash_ctx(desc->tfm), data, len,\n\t\t\t\t    out);\n}\n\nstatic int crc32c_intel_cra_init(struct crypto_tfm *tfm)\n{\n\tu32 *key = crypto_tfm_ctx(tfm);\n\n\t*key = ~0;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\nstatic int crc32c_pcl_intel_update(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len)\n{\n\tu32 *crcp = shash_desc_ctx(desc);\n\n\t \n\tif (len >= CRC32C_PCL_BREAKEVEN && crypto_simd_usable()) {\n\t\tkernel_fpu_begin();\n\t\t*crcp = crc_pcl(data, len, *crcp);\n\t\tkernel_fpu_end();\n\t} else\n\t\t*crcp = crc32c_intel_le_hw(*crcp, data, len);\n\treturn 0;\n}\n\nstatic int __crc32c_pcl_intel_finup(u32 *crcp, const u8 *data, unsigned int len,\n\t\t\t\tu8 *out)\n{\n\tif (len >= CRC32C_PCL_BREAKEVEN && crypto_simd_usable()) {\n\t\tkernel_fpu_begin();\n\t\t*(__le32 *)out = ~cpu_to_le32(crc_pcl(data, len, *crcp));\n\t\tkernel_fpu_end();\n\t} else\n\t\t*(__le32 *)out =\n\t\t\t~cpu_to_le32(crc32c_intel_le_hw(*crcp, data, len));\n\treturn 0;\n}\n\nstatic int crc32c_pcl_intel_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn __crc32c_pcl_intel_finup(shash_desc_ctx(desc), data, len, out);\n}\n\nstatic int crc32c_pcl_intel_digest(struct shash_desc *desc, const u8 *data,\n\t\t\t       unsigned int len, u8 *out)\n{\n\treturn __crc32c_pcl_intel_finup(crypto_shash_ctx(desc->tfm), data, len,\n\t\t\t\t    out);\n}\n#endif  \n\nstatic struct shash_alg alg = {\n\t.setkey\t\t\t=\tcrc32c_intel_setkey,\n\t.init\t\t\t=\tcrc32c_intel_init,\n\t.update\t\t\t=\tcrc32c_intel_update,\n\t.final\t\t\t=\tcrc32c_intel_final,\n\t.finup\t\t\t=\tcrc32c_intel_finup,\n\t.digest\t\t\t=\tcrc32c_intel_digest,\n\t.descsize\t\t=\tsizeof(u32),\n\t.digestsize\t\t=\tCHKSUM_DIGEST_SIZE,\n\t.base\t\t\t=\t{\n\t\t.cra_name\t\t=\t\"crc32c\",\n\t\t.cra_driver_name\t=\t\"crc32c-intel\",\n\t\t.cra_priority\t\t=\t200,\n\t\t.cra_flags\t\t=\tCRYPTO_ALG_OPTIONAL_KEY,\n\t\t.cra_blocksize\t\t=\tCHKSUM_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t=\tsizeof(u32),\n\t\t.cra_module\t\t=\tTHIS_MODULE,\n\t\t.cra_init\t\t=\tcrc32c_intel_cra_init,\n\t}\n};\n\nstatic const struct x86_cpu_id crc32c_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_XMM4_2, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, crc32c_cpu_id);\n\nstatic int __init crc32c_intel_mod_init(void)\n{\n\tif (!x86_match_cpu(crc32c_cpu_id))\n\t\treturn -ENODEV;\n#ifdef CONFIG_X86_64\n\tif (boot_cpu_has(X86_FEATURE_PCLMULQDQ)) {\n\t\talg.update = crc32c_pcl_intel_update;\n\t\talg.finup = crc32c_pcl_intel_finup;\n\t\talg.digest = crc32c_pcl_intel_digest;\n\t}\n#endif\n\treturn crypto_register_shash(&alg);\n}\n\nstatic void __exit crc32c_intel_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n\nmodule_init(crc32c_intel_mod_init);\nmodule_exit(crc32c_intel_mod_fini);\n\nMODULE_AUTHOR(\"Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.com>\");\nMODULE_DESCRIPTION(\"CRC32c (Castagnoli) optimization using Intel Hardware.\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS_CRYPTO(\"crc32c\");\nMODULE_ALIAS_CRYPTO(\"crc32c-intel\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}