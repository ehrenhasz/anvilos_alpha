{
  "module_name": "sha512-ssse3-asm.S",
  "hash_id": "1f41b0a79ae66798a02c30ffb48a7d0e8f194dec11240559bd0fa547b947fcff",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/sha512-ssse3-asm.S",
  "human_readable_source": "########################################################################\n# Implement fast SHA-512 with SSSE3 instructions. (x86_64)\n#\n# Copyright (C) 2013 Intel Corporation.\n#\n# Authors:\n#     James Guilford <james.guilford@intel.com>\n#     Kirk Yap <kirk.s.yap@intel.com>\n#     David Cote <david.m.cote@intel.com>\n#     Tim Chen <tim.c.chen@linux.intel.com>\n#\n# This software is available to you under a choice of one of two\n# licenses.  You may choose to be licensed under the terms of the GNU\n# General Public License (GPL) Version 2, available from the file\n# COPYING in the main directory of this source tree, or the\n# OpenIB.org BSD license below:\n#\n#     Redistribution and use in source and binary forms, with or\n#     without modification, are permitted provided that the following\n#     conditions are met:\n#\n#      - Redistributions of source code must retain the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer.\n#\n#      - Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials\n#        provided with the distribution.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n########################################################################\n#\n# This code is described in an Intel White-Paper:\n# \"Fast SHA-512 Implementations on Intel Architecture Processors\"\n#\n# To find it, surf to http: \n# and search for that title.\n#\n########################################################################\n\n#include <linux/linkage.h>\n#include <linux/cfi_types.h>\n\n.text\n\n# Virtual Registers\n# ARG1\ndigest =\t%rdi\n# ARG2\nmsg =\t\t%rsi\n# ARG3\nmsglen =\t%rdx\nT1 =\t\t%rcx\nT2 =\t\t%r8\na_64 =\t\t%r9\nb_64 =\t\t%r10\nc_64 =\t\t%r11\nd_64 =\t\t%r12\ne_64 =\t\t%r13\nf_64 =\t\t%r14\ng_64 =\t\t%r15\nh_64 =\t\t%rbx\ntmp0 =\t\t%rax\n\n# Local variables (stack frame)\n\nW_SIZE = 80*8\nWK_SIZE = 2*8\n\nframe_W = 0\nframe_WK = frame_W + W_SIZE\nframe_size = frame_WK + WK_SIZE\n\n# Useful QWORD \"arrays\" for simpler memory references\n# MSG, DIGEST, K_t, W_t are arrays\n# WK_2(t) points to 1 of 2 qwords at frame.WK depdending on t being odd/even\n\n# Input message (arg1)\n#define MSG(i)    8*i(msg)\n\n# Output Digest (arg2)\n#define DIGEST(i) 8*i(digest)\n\n# SHA Constants (static mem)\n#define K_t(i)    8*i+K512(%rip)\n\n# Message Schedule (stack frame)\n#define W_t(i)    8*i+frame_W(%rsp)\n\n# W[t]+K[t] (stack frame)\n#define WK_2(i)   8*((i%2))+frame_WK(%rsp)\n\n.macro RotateState\n\t# Rotate symbols a..h right\n\tTMP   = h_64\n\th_64  = g_64\n\tg_64  = f_64\n\tf_64  = e_64\n\te_64  = d_64\n\td_64  = c_64\n\tc_64  = b_64\n\tb_64  = a_64\n\ta_64  = TMP\n.endm\n\n.macro SHA512_Round rnd\n\n\t# Compute Round %%t\n\tmov\tf_64, T1          # T1 = f\n\tmov\te_64, tmp0        # tmp = e\n\txor\tg_64, T1          # T1 = f ^ g\n\tror\t$23, tmp0 # 41    # tmp = e ror 23\n\tand\te_64, T1          # T1 = (f ^ g) & e\n\txor\te_64, tmp0        # tmp = (e ror 23) ^ e\n\txor\tg_64, T1          # T1 = ((f ^ g) & e) ^ g = CH(e,f,g)\n\tidx = \\rnd\n\tadd\tWK_2(idx), T1     # W[t] + K[t] from message scheduler\n\tror\t$4, tmp0  # 18    # tmp = ((e ror 23) ^ e) ror 4\n\txor\te_64, tmp0        # tmp = (((e ror 23) ^ e) ror 4) ^ e\n\tmov\ta_64, T2          # T2 = a\n\tadd\th_64, T1          # T1 = CH(e,f,g) + W[t] + K[t] + h\n\tror\t$14, tmp0 # 14    # tmp = ((((e ror23)^e)ror4)^e)ror14 = S1(e)\n\tadd\ttmp0, T1          # T1 = CH(e,f,g) + W[t] + K[t] + S1(e)\n\tmov\ta_64, tmp0        # tmp = a\n\txor\tc_64, T2          # T2 = a ^ c\n\tand\tc_64, tmp0        # tmp = a & c\n\tand\tb_64, T2          # T2 = (a ^ c) & b\n\txor\ttmp0, T2          # T2 = ((a ^ c) & b) ^ (a & c) = Maj(a,b,c)\n\tmov\ta_64, tmp0        # tmp = a\n\tror\t$5, tmp0 # 39     # tmp = a ror 5\n\txor\ta_64, tmp0        # tmp = (a ror 5) ^ a\n\tadd\tT1, d_64          # e(next_state) = d + T1\n\tror\t$6, tmp0 # 34     # tmp = ((a ror 5) ^ a) ror 6\n\txor\ta_64, tmp0        # tmp = (((a ror 5) ^ a) ror 6) ^ a\n\tlea\t(T1, T2), h_64    # a(next_state) = T1 + Maj(a,b,c)\n\tror\t$28, tmp0 # 28    # tmp = ((((a ror5)^a)ror6)^a)ror28 = S0(a)\n\tadd\ttmp0, h_64        # a(next_state) = T1 + Maj(a,b,c) S0(a)\n\tRotateState\n.endm\n\n.macro SHA512_2Sched_2Round_sse rnd\n\n\t# Compute rounds t-2 and t-1\n\t# Compute message schedule QWORDS t and t+1\n\n\t#   Two rounds are computed based on the values for K[t-2]+W[t-2] and\n\t# K[t-1]+W[t-1] which were previously stored at WK_2 by the message\n\t# scheduler.\n\t#   The two new schedule QWORDS are stored at [W_t(%%t)] and [W_t(%%t+1)].\n\t# They are then added to their respective SHA512 constants at\n\t# [K_t(%%t)] and [K_t(%%t+1)] and stored at dqword [WK_2(%%t)]\n\t#   For brievity, the comments following vectored instructions only refer to\n\t# the first of a pair of QWORDS.\n\t# Eg. XMM2=W[t-2] really means XMM2={W[t-2]|W[t-1]}\n\t#   The computation of the message schedule and the rounds are tightly\n\t# stitched to take advantage of instruction-level parallelism.\n\t# For clarity, integer instructions (for the rounds calculation) are indented\n\t# by one tab. Vectored instructions (for the message scheduler) are indented\n\t# by two tabs.\n\n\tmov\tf_64, T1\n\tidx = \\rnd -2\n\tmovdqa\tW_t(idx), %xmm2\t\t    # XMM2 = W[t-2]\n\txor\tg_64, T1\n\tand\te_64, T1\n\tmovdqa\t%xmm2, %xmm0\t            # XMM0 = W[t-2]\n\txor\tg_64, T1\n\tidx = \\rnd\n\tadd\tWK_2(idx), T1\n\tidx = \\rnd - 15\n\tmovdqu\tW_t(idx), %xmm5\t\t    # XMM5 = W[t-15]\n\tmov\te_64, tmp0\n\tror\t$23, tmp0 # 41\n\tmovdqa\t%xmm5, %xmm3\t            # XMM3 = W[t-15]\n\txor\te_64, tmp0\n\tror\t$4, tmp0 # 18\n\tpsrlq\t$61-19, %xmm0\t\t    # XMM0 = W[t-2] >> 42\n\txor\te_64, tmp0\n\tror\t$14, tmp0 # 14\n\tpsrlq\t$(8-7), %xmm3\t\t    # XMM3 = W[t-15] >> 1\n\tadd\ttmp0, T1\n\tadd\th_64, T1\n\tpxor\t%xmm2, %xmm0                # XMM0 = (W[t-2] >> 42) ^ W[t-2]\n\tmov\ta_64, T2\n\txor\tc_64, T2\n\tpxor\t%xmm5, %xmm3                # XMM3 = (W[t-15] >> 1) ^ W[t-15]\n\tand\tb_64, T2\n\tmov\ta_64, tmp0\n\tpsrlq\t$(19-6), %xmm0\t\t    # XMM0 = ((W[t-2]>>42)^W[t-2])>>13\n\tand\tc_64, tmp0\n\txor\ttmp0, T2\n\tpsrlq\t$(7-1), %xmm3\t\t    # XMM3 = ((W[t-15]>>1)^W[t-15])>>6\n\tmov\ta_64, tmp0\n\tror\t$5, tmp0 # 39\n\tpxor\t%xmm2, %xmm0\t            # XMM0 = (((W[t-2]>>42)^W[t-2])>>13)^W[t-2]\n\txor\ta_64, tmp0\n\tror\t$6, tmp0 # 34\n\tpxor\t%xmm5, %xmm3                # XMM3 = (((W[t-15]>>1)^W[t-15])>>6)^W[t-15]\n\txor\ta_64, tmp0\n\tror\t$28, tmp0 # 28\n\tpsrlq\t$6, %xmm0                   # XMM0 = ((((W[t-2]>>42)^W[t-2])>>13)^W[t-2])>>6\n\tadd\ttmp0, T2\n\tadd\tT1, d_64\n\tpsrlq\t$1, %xmm3                   # XMM3 = (((W[t-15]>>1)^W[t-15])>>6)^W[t-15]>>1\n\tlea\t(T1, T2), h_64\n\tRotateState\n\tmovdqa\t%xmm2, %xmm1\t            # XMM1 = W[t-2]\n\tmov\tf_64, T1\n\txor\tg_64, T1\n\tmovdqa\t%xmm5, %xmm4\t\t    # XMM4 = W[t-15]\n\tand\te_64, T1\n\txor\tg_64, T1\n\tpsllq\t$(64-19)-(64-61) , %xmm1    # XMM1 = W[t-2] << 42\n\tidx = \\rnd + 1\n\tadd\tWK_2(idx), T1\n\tmov\te_64, tmp0\n\tpsllq\t$(64-1)-(64-8), %xmm4\t    # XMM4 = W[t-15] << 7\n\tror\t$23, tmp0 # 41\n\txor\te_64, tmp0\n\tpxor\t%xmm2, %xmm1\t\t    # XMM1 = (W[t-2] << 42)^W[t-2]\n\tror\t$4, tmp0 # 18\n\txor\te_64, tmp0\n\tpxor\t%xmm5, %xmm4\t\t    # XMM4 = (W[t-15]<<7)^W[t-15]\n\tror\t$14, tmp0 # 14\n\tadd\ttmp0, T1\n\tpsllq\t$(64-61), %xmm1\t\t    # XMM1 = ((W[t-2] << 42)^W[t-2])<<3\n\tadd\th_64, T1\n\tmov\ta_64, T2\n\tpsllq\t$(64-8), %xmm4\t\t    # XMM4 = ((W[t-15]<<7)^W[t-15])<<56\n\txor\tc_64, T2\n\tand\tb_64, T2\n\tpxor\t%xmm1, %xmm0\t\t    # XMM0 = s1(W[t-2])\n\tmov\ta_64, tmp0\n\tand\tc_64, tmp0\n\tidx = \\rnd - 7\n\tmovdqu\tW_t(idx), %xmm1\t\t    # XMM1 = W[t-7]\n\txor\ttmp0, T2\n\tpxor\t%xmm4, %xmm3                # XMM3 = s0(W[t-15])\n\tmov\ta_64, tmp0\n\tpaddq\t%xmm3, %xmm0\t\t    # XMM0 = s1(W[t-2]) + s0(W[t-15])\n\tror\t$5, tmp0 # 39\n\tidx =\\rnd-16\n\tpaddq\tW_t(idx), %xmm0\t\t    # XMM0 = s1(W[t-2]) + s0(W[t-15]) + W[t-16]\n\txor\ta_64, tmp0\n\tpaddq\t%xmm1, %xmm0\t            # XMM0 = s1(W[t-2]) + W[t-7] + s0(W[t-15]) + W[t-16]\n\tror\t$6, tmp0 # 34\n\tmovdqa\t%xmm0, W_t(\\rnd)\t    # Store scheduled qwords\n\txor\ta_64, tmp0\n\tpaddq\tK_t(\\rnd), %xmm0\t    # Compute W[t]+K[t]\n\tror\t$28, tmp0 # 28\n\tidx = \\rnd\n\tmovdqa\t%xmm0, WK_2(idx)\t    # Store W[t]+K[t] for next rounds\n\tadd\ttmp0, T2\n\tadd\tT1, d_64\n\tlea\t(T1, T2), h_64\n\tRotateState\n.endm\n\n########################################################################\n## void sha512_transform_ssse3(struct sha512_state *state, const u8 *data,\n##\t\t\t       int blocks);\n# (struct sha512_state is assumed to begin with u64 state[8])\n# Purpose: Updates the SHA512 digest stored at \"state\" with the message\n# stored in \"data\".\n# The size of the message pointed to by \"data\" must be an integer multiple\n# of SHA512 message blocks.\n# \"blocks\" is the message length in SHA512 blocks.\n########################################################################\nSYM_TYPED_FUNC_START(sha512_transform_ssse3)\n\n\ttest msglen, msglen\n\tje .Lnowork\n\n\t# Save GPRs\n\tpush\t%rbx\n\tpush\t%r12\n\tpush\t%r13\n\tpush\t%r14\n\tpush\t%r15\n\n\t# Allocate Stack Space\n\tpush\t%rbp\n\tmov\t%rsp, %rbp\n\tsub\t$frame_size, %rsp\n\tand\t$~(0x20 - 1), %rsp\n\n.Lupdateblock:\n\n# Load state variables\n\tmov\tDIGEST(0), a_64\n\tmov\tDIGEST(1), b_64\n\tmov\tDIGEST(2), c_64\n\tmov\tDIGEST(3), d_64\n\tmov\tDIGEST(4), e_64\n\tmov\tDIGEST(5), f_64\n\tmov\tDIGEST(6), g_64\n\tmov\tDIGEST(7), h_64\n\n\tt = 0\n\t.rept 80/2 + 1\n\t# (80 rounds) / (2 rounds/iteration) + (1 iteration)\n\t# +1 iteration because the scheduler leads hashing by 1 iteration\n\t\t.if t < 2\n\t\t\t# BSWAP 2 QWORDS\n\t\t\tmovdqa\tXMM_QWORD_BSWAP(%rip), %xmm1\n\t\t\tmovdqu\tMSG(t), %xmm0\n\t\t\tpshufb\t%xmm1, %xmm0\t# BSWAP\n\t\t\tmovdqa\t%xmm0, W_t(t)\t# Store Scheduled Pair\n\t\t\tpaddq\tK_t(t), %xmm0\t# Compute W[t]+K[t]\n\t\t\tmovdqa\t%xmm0, WK_2(t)\t# Store into WK for rounds\n\t\t.elseif t < 16\n\t\t\t# BSWAP 2 QWORDS# Compute 2 Rounds\n\t\t\tmovdqu\tMSG(t), %xmm0\n\t\t\tpshufb\t%xmm1, %xmm0\t# BSWAP\n\t\t\tSHA512_Round t-2\t# Round t-2\n\t\t\tmovdqa\t%xmm0, W_t(t)\t# Store Scheduled Pair\n\t\t\tpaddq\tK_t(t), %xmm0\t# Compute W[t]+K[t]\n\t\t\tSHA512_Round t-1\t# Round t-1\n\t\t\tmovdqa\t%xmm0, WK_2(t)\t# Store W[t]+K[t] into WK\n\t\t.elseif t < 79\n\t\t\t# Schedule 2 QWORDS# Compute 2 Rounds\n\t\t\tSHA512_2Sched_2Round_sse t\n\t\t.else\n\t\t\t# Compute 2 Rounds\n\t\t\tSHA512_Round t-2\n\t\t\tSHA512_Round t-1\n\t\t.endif\n\t\tt = t+2\n\t.endr\n\n\t# Update digest\n\tadd\ta_64, DIGEST(0)\n\tadd\tb_64, DIGEST(1)\n\tadd\tc_64, DIGEST(2)\n\tadd\td_64, DIGEST(3)\n\tadd\te_64, DIGEST(4)\n\tadd\tf_64, DIGEST(5)\n\tadd\tg_64, DIGEST(6)\n\tadd\th_64, DIGEST(7)\n\n\t# Advance to next message block\n\tadd\t$16*8, msg\n\tdec\tmsglen\n\tjnz\t.Lupdateblock\n\n\t# Restore Stack Pointer\n\tmov\t%rbp, %rsp\n\tpop\t%rbp\n\n\t# Restore GPRs\n\tpop\t%r15\n\tpop\t%r14\n\tpop\t%r13\n\tpop\t%r12\n\tpop\t%rbx\n\n.Lnowork:\n\tRET\nSYM_FUNC_END(sha512_transform_ssse3)\n\n########################################################################\n### Binary Data\n\n.section\t.rodata.cst16.XMM_QWORD_BSWAP, \"aM\", @progbits, 16\n.align 16\n# Mask for byte-swapping a couple of qwords in an XMM register using (v)pshufb.\nXMM_QWORD_BSWAP:\n\t.octa 0x08090a0b0c0d0e0f0001020304050607\n\n# Mergeable 640-byte rodata section. This allows linker to merge the table\n# with other, exactly the same 640-byte fragment of another rodata section\n# (if such section exists).\n.section\t.rodata.cst640.K512, \"aM\", @progbits, 640\n.align 64\n# K[t] used in SHA512 hashing\nK512:\n\t.quad 0x428a2f98d728ae22,0x7137449123ef65cd\n\t.quad 0xb5c0fbcfec4d3b2f,0xe9b5dba58189dbbc\n\t.quad 0x3956c25bf348b538,0x59f111f1b605d019\n\t.quad 0x923f82a4af194f9b,0xab1c5ed5da6d8118\n\t.quad 0xd807aa98a3030242,0x12835b0145706fbe\n\t.quad 0x243185be4ee4b28c,0x550c7dc3d5ffb4e2\n\t.quad 0x72be5d74f27b896f,0x80deb1fe3b1696b1\n\t.quad 0x9bdc06a725c71235,0xc19bf174cf692694\n\t.quad 0xe49b69c19ef14ad2,0xefbe4786384f25e3\n\t.quad 0x0fc19dc68b8cd5b5,0x240ca1cc77ac9c65\n\t.quad 0x2de92c6f592b0275,0x4a7484aa6ea6e483\n\t.quad 0x5cb0a9dcbd41fbd4,0x76f988da831153b5\n\t.quad 0x983e5152ee66dfab,0xa831c66d2db43210\n\t.quad 0xb00327c898fb213f,0xbf597fc7beef0ee4\n\t.quad 0xc6e00bf33da88fc2,0xd5a79147930aa725\n\t.quad 0x06ca6351e003826f,0x142929670a0e6e70\n\t.quad 0x27b70a8546d22ffc,0x2e1b21385c26c926\n\t.quad 0x4d2c6dfc5ac42aed,0x53380d139d95b3df\n\t.quad 0x650a73548baf63de,0x766a0abb3c77b2a8\n\t.quad 0x81c2c92e47edaee6,0x92722c851482353b\n\t.quad 0xa2bfe8a14cf10364,0xa81a664bbc423001\n\t.quad 0xc24b8b70d0f89791,0xc76c51a30654be30\n\t.quad 0xd192e819d6ef5218,0xd69906245565a910\n\t.quad 0xf40e35855771202a,0x106aa07032bbd1b8\n\t.quad 0x19a4c116b8d2d0c8,0x1e376c085141ab53\n\t.quad 0x2748774cdf8eeb99,0x34b0bcb5e19b48a8\n\t.quad 0x391c0cb3c5c95a63,0x4ed8aa4ae3418acb\n\t.quad 0x5b9cca4f7763e373,0x682e6ff3d6b2b8a3\n\t.quad 0x748f82ee5defb2fc,0x78a5636f43172f60\n\t.quad 0x84c87814a1f0ab72,0x8cc702081a6439ec\n\t.quad 0x90befffa23631e28,0xa4506cebde82bde9\n\t.quad 0xbef9a3f7b2c67915,0xc67178f2e372532b\n\t.quad 0xca273eceea26619c,0xd186b8c721c0c207\n\t.quad 0xeada7dd6cde0eb1e,0xf57d4f7fee6ed178\n\t.quad 0x06f067aa72176fba,0x0a637dc5a2c898a6\n\t.quad 0x113f9804bef90dae,0x1b710b35131c471b\n\t.quad 0x28db77f523047d84,0x32caab7b40c72493\n\t.quad 0x3c9ebe0a15c9bebc,0x431d67c49c100d4c\n\t.quad 0x4cc5d4becb3e42b6,0x597f299cfc657e2a\n\t.quad 0x5fcb6fab3ad6faec,0x6c44198c4a475817\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}