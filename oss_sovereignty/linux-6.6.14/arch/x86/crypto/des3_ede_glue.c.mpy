{
  "module_name": "des3_ede_glue.c",
  "hash_id": "e52ec8cb7863fd59d9203577ac705759ad3e17fc7f895947136272e06fa65fb9",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/des3_ede_glue.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/des.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\nstruct des3_ede_x86_ctx {\n\tstruct des3_ede_ctx enc;\n\tstruct des3_ede_ctx dec;\n};\n\n \nasmlinkage void des3_ede_x86_64_crypt_blk(const u32 *expkey, u8 *dst,\n\t\t\t\t\t  const u8 *src);\n\n \nasmlinkage void des3_ede_x86_64_crypt_blk_3way(const u32 *expkey, u8 *dst,\n\t\t\t\t\t       const u8 *src);\n\nstatic inline void des3_ede_enc_blk(struct des3_ede_x86_ctx *ctx, u8 *dst,\n\t\t\t\t    const u8 *src)\n{\n\tu32 *enc_ctx = ctx->enc.expkey;\n\n\tdes3_ede_x86_64_crypt_blk(enc_ctx, dst, src);\n}\n\nstatic inline void des3_ede_dec_blk(struct des3_ede_x86_ctx *ctx, u8 *dst,\n\t\t\t\t    const u8 *src)\n{\n\tu32 *dec_ctx = ctx->dec.expkey;\n\n\tdes3_ede_x86_64_crypt_blk(dec_ctx, dst, src);\n}\n\nstatic inline void des3_ede_dec_blk_3way(struct des3_ede_x86_ctx *ctx, u8 *dst,\n\t\t\t\t\t const u8 *src)\n{\n\tu32 *dec_ctx = ctx->dec.expkey;\n\n\tdes3_ede_x86_64_crypt_blk_3way(dec_ctx, dst, src);\n}\n\nstatic void des3_ede_x86_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tdes3_ede_enc_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n\nstatic void des3_ede_x86_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tdes3_ede_dec_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n\nstatic int ecb_crypt(struct skcipher_request *req, const u32 *expkey)\n{\n\tconst unsigned int bsize = DES3_EDE_BLOCK_SIZE;\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile ((nbytes = walk.nbytes)) {\n\t\tu8 *wsrc = walk.src.virt.addr;\n\t\tu8 *wdst = walk.dst.virt.addr;\n\n\t\t \n\t\tif (nbytes >= bsize * 3) {\n\t\t\tdo {\n\t\t\t\tdes3_ede_x86_64_crypt_blk_3way(expkey, wdst,\n\t\t\t\t\t\t\t       wsrc);\n\n\t\t\t\twsrc += bsize * 3;\n\t\t\t\twdst += bsize * 3;\n\t\t\t\tnbytes -= bsize * 3;\n\t\t\t} while (nbytes >= bsize * 3);\n\n\t\t\tif (nbytes < bsize)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tdes3_ede_x86_64_crypt_blk(expkey, wdst, wsrc);\n\n\t\t\twsrc += bsize;\n\t\t\twdst += bsize;\n\t\t\tnbytes -= bsize;\n\t\t} while (nbytes >= bsize);\n\ndone:\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct des3_ede_x86_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\treturn ecb_crypt(req, ctx->enc.expkey);\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct des3_ede_x86_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\treturn ecb_crypt(req, ctx->dec.expkey);\n}\n\nstatic unsigned int __cbc_encrypt(struct des3_ede_x86_ctx *ctx,\n\t\t\t\t  struct skcipher_walk *walk)\n{\n\tunsigned int bsize = DES3_EDE_BLOCK_SIZE;\n\tunsigned int nbytes = walk->nbytes;\n\tu64 *src = (u64 *)walk->src.virt.addr;\n\tu64 *dst = (u64 *)walk->dst.virt.addr;\n\tu64 *iv = (u64 *)walk->iv;\n\n\tdo {\n\t\t*dst = *src ^ *iv;\n\t\tdes3_ede_enc_blk(ctx, (u8 *)dst, (u8 *)dst);\n\t\tiv = dst;\n\n\t\tsrc += 1;\n\t\tdst += 1;\n\t\tnbytes -= bsize;\n\t} while (nbytes >= bsize);\n\n\t*(u64 *)walk->iv = *iv;\n\treturn nbytes;\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct des3_ede_x86_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes) {\n\t\tnbytes = __cbc_encrypt(ctx, &walk);\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic unsigned int __cbc_decrypt(struct des3_ede_x86_ctx *ctx,\n\t\t\t\t  struct skcipher_walk *walk)\n{\n\tunsigned int bsize = DES3_EDE_BLOCK_SIZE;\n\tunsigned int nbytes = walk->nbytes;\n\tu64 *src = (u64 *)walk->src.virt.addr;\n\tu64 *dst = (u64 *)walk->dst.virt.addr;\n\tu64 ivs[3 - 1];\n\tu64 last_iv;\n\n\t \n\tsrc += nbytes / bsize - 1;\n\tdst += nbytes / bsize - 1;\n\n\tlast_iv = *src;\n\n\t \n\tif (nbytes >= bsize * 3) {\n\t\tdo {\n\t\t\tnbytes -= bsize * 3 - bsize;\n\t\t\tsrc -= 3 - 1;\n\t\t\tdst -= 3 - 1;\n\n\t\t\tivs[0] = src[0];\n\t\t\tivs[1] = src[1];\n\n\t\t\tdes3_ede_dec_blk_3way(ctx, (u8 *)dst, (u8 *)src);\n\n\t\t\tdst[1] ^= ivs[0];\n\t\t\tdst[2] ^= ivs[1];\n\n\t\t\tnbytes -= bsize;\n\t\t\tif (nbytes < bsize)\n\t\t\t\tgoto done;\n\n\t\t\t*dst ^= *(src - 1);\n\t\t\tsrc -= 1;\n\t\t\tdst -= 1;\n\t\t} while (nbytes >= bsize * 3);\n\t}\n\n\t \n\tfor (;;) {\n\t\tdes3_ede_dec_blk(ctx, (u8 *)dst, (u8 *)src);\n\n\t\tnbytes -= bsize;\n\t\tif (nbytes < bsize)\n\t\t\tbreak;\n\n\t\t*dst ^= *(src - 1);\n\t\tsrc -= 1;\n\t\tdst -= 1;\n\t}\n\ndone:\n\t*dst ^= *(u64 *)walk->iv;\n\t*(u64 *)walk->iv = last_iv;\n\n\treturn nbytes;\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct des3_ede_x86_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes) {\n\t\tnbytes = __cbc_decrypt(ctx, &walk);\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic int des3_ede_x86_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct des3_ede_x86_ctx *ctx = crypto_tfm_ctx(tfm);\n\tu32 i, j, tmp;\n\tint err;\n\n\terr = des3_ede_expand_key(&ctx->enc, key, keylen);\n\tif (err == -ENOKEY) {\n\t\tif (crypto_tfm_get_flags(tfm) & CRYPTO_TFM_REQ_FORBID_WEAK_KEYS)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\tif (err) {\n\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\treturn err;\n\t}\n\n\t \n\tj = DES3_EDE_EXPKEY_WORDS - 2;\n\tfor (i = 0; i < DES3_EDE_EXPKEY_WORDS; i += 2, j -= 2) {\n\t\ttmp = ror32(ctx->enc.expkey[i + 1], 4);\n\t\tctx->enc.expkey[i + 1] = tmp;\n\n\t\tctx->dec.expkey[j + 0] = ctx->enc.expkey[i + 0];\n\t\tctx->dec.expkey[j + 1] = tmp;\n\t}\n\n\treturn 0;\n}\n\nstatic int des3_ede_x86_setkey_skcipher(struct crypto_skcipher *tfm,\n\t\t\t\t\tconst u8 *key,\n\t\t\t\t\tunsigned int keylen)\n{\n\treturn des3_ede_x86_setkey(&tfm->base, key, keylen);\n}\n\nstatic struct crypto_alg des3_ede_cipher = {\n\t.cra_name\t\t= \"des3_ede\",\n\t.cra_driver_name\t= \"des3_ede-asm\",\n\t.cra_priority\t\t= 200,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t= DES3_EDE_BLOCK_SIZE,\n\t.cra_ctxsize\t\t= sizeof(struct des3_ede_x86_ctx),\n\t.cra_alignmask\t\t= 0,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_u = {\n\t\t.cipher = {\n\t\t\t.cia_min_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t\t.cia_max_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t\t.cia_setkey\t\t= des3_ede_x86_setkey,\n\t\t\t.cia_encrypt\t\t= des3_ede_x86_encrypt,\n\t\t\t.cia_decrypt\t\t= des3_ede_x86_decrypt,\n\t\t}\n\t}\n};\n\nstatic struct skcipher_alg des3_ede_skciphers[] = {\n\t{\n\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"ecb-des3_ede-asm\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct des3_ede_x86_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t\t= des3_ede_x86_setkey_skcipher,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"cbc-des3_ede-asm\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct des3_ede_x86_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.setkey\t\t\t= des3_ede_x86_setkey_skcipher,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t}\n};\n\nstatic bool is_blacklisted_cpu(void)\n{\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn false;\n\n\tif (boot_cpu_data.x86 == 0x0f) {\n\t\t \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int force;\nmodule_param(force, int, 0);\nMODULE_PARM_DESC(force, \"Force module load, ignore CPU blacklist\");\n\nstatic int __init des3_ede_x86_init(void)\n{\n\tint err;\n\n\tif (!force && is_blacklisted_cpu()) {\n\t\tpr_info(\"des3_ede-x86_64: performance on this CPU would be suboptimal: disabling des3_ede-x86_64.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = crypto_register_alg(&des3_ede_cipher);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_register_skciphers(des3_ede_skciphers,\n\t\t\t\t\tARRAY_SIZE(des3_ede_skciphers));\n\tif (err)\n\t\tcrypto_unregister_alg(&des3_ede_cipher);\n\n\treturn err;\n}\n\nstatic void __exit des3_ede_x86_fini(void)\n{\n\tcrypto_unregister_alg(&des3_ede_cipher);\n\tcrypto_unregister_skciphers(des3_ede_skciphers,\n\t\t\t\t    ARRAY_SIZE(des3_ede_skciphers));\n}\n\nmodule_init(des3_ede_x86_init);\nmodule_exit(des3_ede_x86_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Triple DES EDE Cipher Algorithm, asm optimized\");\nMODULE_ALIAS_CRYPTO(\"des3_ede\");\nMODULE_ALIAS_CRYPTO(\"des3_ede-asm\");\nMODULE_AUTHOR(\"Jussi Kivilinna <jussi.kivilinna@iki.fi>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}