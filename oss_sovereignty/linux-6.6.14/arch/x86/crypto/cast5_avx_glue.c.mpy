{
  "module_name": "cast5_avx_glue.c",
  "hash_id": "cb48d4f2985f7ff063189875ea22fc0236ea3d3a1f7ec21ebe9ab0899e1e0c56",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/cast5_avx_glue.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/cast5.h>\n#include <crypto/internal/simd.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include \"ecb_cbc_helpers.h\"\n\n#define CAST5_PARALLEL_BLOCKS 16\n\nasmlinkage void cast5_ecb_enc_16way(struct cast5_ctx *ctx, u8 *dst,\n\t\t\t\t    const u8 *src);\nasmlinkage void cast5_ecb_dec_16way(struct cast5_ctx *ctx, u8 *dst,\n\t\t\t\t    const u8 *src);\nasmlinkage void cast5_cbc_dec_16way(struct cast5_ctx *ctx, u8 *dst,\n\t\t\t\t    const u8 *src);\n\nstatic int cast5_setkey_skcipher(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\treturn cast5_setkey(&tfm->base, key, keylen);\n}\n\nstatic int ecb_encrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAST5_BLOCK_SIZE, CAST5_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAST5_PARALLEL_BLOCKS, cast5_ecb_enc_16way);\n\tECB_BLOCK(1, __cast5_encrypt);\n\tECB_WALK_END();\n}\n\nstatic int ecb_decrypt(struct skcipher_request *req)\n{\n\tECB_WALK_START(req, CAST5_BLOCK_SIZE, CAST5_PARALLEL_BLOCKS);\n\tECB_BLOCK(CAST5_PARALLEL_BLOCKS, cast5_ecb_dec_16way);\n\tECB_BLOCK(1, __cast5_decrypt);\n\tECB_WALK_END();\n}\n\nstatic int cbc_encrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAST5_BLOCK_SIZE, -1);\n\tCBC_ENC_BLOCK(__cast5_encrypt);\n\tCBC_WALK_END();\n}\n\nstatic int cbc_decrypt(struct skcipher_request *req)\n{\n\tCBC_WALK_START(req, CAST5_BLOCK_SIZE, CAST5_PARALLEL_BLOCKS);\n\tCBC_DEC_BLOCK(CAST5_PARALLEL_BLOCKS, cast5_cbc_dec_16way);\n\tCBC_DEC_BLOCK(1, __cast5_decrypt);\n\tCBC_WALK_END();\n}\n\nstatic struct skcipher_alg cast5_algs[] = {\n\t{\n\t\t.base.cra_name\t\t= \"__ecb(cast5)\",\n\t\t.base.cra_driver_name\t= \"__ecb-cast5-avx\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAST5_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct cast5_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAST5_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAST5_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= cast5_setkey_skcipher,\n\t\t.encrypt\t\t= ecb_encrypt,\n\t\t.decrypt\t\t= ecb_decrypt,\n\t}, {\n\t\t.base.cra_name\t\t= \"__cbc(cast5)\",\n\t\t.base.cra_driver_name\t= \"__cbc-cast5-avx\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_INTERNAL,\n\t\t.base.cra_blocksize\t= CAST5_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct cast5_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.min_keysize\t\t= CAST5_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= CAST5_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= CAST5_BLOCK_SIZE,\n\t\t.setkey\t\t\t= cast5_setkey_skcipher,\n\t\t.encrypt\t\t= cbc_encrypt,\n\t\t.decrypt\t\t= cbc_decrypt,\n\t}\n};\n\nstatic struct simd_skcipher_alg *cast5_simd_algs[ARRAY_SIZE(cast5_algs)];\n\nstatic int __init cast5_init(void)\n{\n\tconst char *feature_name;\n\n\tif (!cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM,\n\t\t\t\t&feature_name)) {\n\t\tpr_info(\"CPU feature '%s' is not supported.\\n\", feature_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn simd_register_skciphers_compat(cast5_algs,\n\t\t\t\t\t      ARRAY_SIZE(cast5_algs),\n\t\t\t\t\t      cast5_simd_algs);\n}\n\nstatic void __exit cast5_exit(void)\n{\n\tsimd_unregister_skciphers(cast5_algs, ARRAY_SIZE(cast5_algs),\n\t\t\t\t  cast5_simd_algs);\n}\n\nmodule_init(cast5_init);\nmodule_exit(cast5_exit);\n\nMODULE_DESCRIPTION(\"Cast5 Cipher Algorithm, AVX optimized\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CRYPTO(\"cast5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}