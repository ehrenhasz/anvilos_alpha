{
  "module_name": "ecb_cbc_helpers.h",
  "hash_id": "99efa5ee5f020c8363cb32a11cefcac4c30d366e91ce3cdba4002566a2dfd4f4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/ecb_cbc_helpers.h",
  "human_readable_source": " \n\n#ifndef _CRYPTO_ECB_CBC_HELPER_H\n#define _CRYPTO_ECB_CBC_HELPER_H\n\n#include <crypto/internal/skcipher.h>\n#include <asm/fpu/api.h>\n\n \n\n#define ECB_WALK_START(req, bsize, fpu_blocks) do {\t\t\t\\\n\tvoid *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\t\\\n\tconst int __fpu_blocks = (fpu_blocks);\t\t\t\t\\\n\tconst int __bsize = (bsize);\t\t\t\t\t\\\n\tstruct skcipher_walk walk;\t\t\t\t\t\\\n\tint err = skcipher_walk_virt(&walk, (req), false);\t\t\\\n\twhile (walk.nbytes > 0) {\t\t\t\t\t\\\n\t\tunsigned int nbytes = walk.nbytes;\t\t\t\\\n\t\tbool do_fpu = __fpu_blocks != -1 &&\t\t\t\\\n\t\t\t      nbytes >= __fpu_blocks * __bsize;\t\t\\\n\t\tconst u8 *src = walk.src.virt.addr;\t\t\t\\\n\t\tu8 *dst = walk.dst.virt.addr;\t\t\t\t\\\n\t\tu8 __maybe_unused buf[(bsize)];\t\t\t\t\\\n\t\tif (do_fpu) kernel_fpu_begin()\n\n#define CBC_WALK_START(req, bsize, fpu_blocks)\t\t\t\t\\\n\tECB_WALK_START(req, bsize, fpu_blocks)\n\n#define ECB_WALK_ADVANCE(blocks) do {\t\t\t\t\t\\\n\tdst += (blocks) * __bsize;\t\t\t\t\t\\\n\tsrc += (blocks) * __bsize;\t\t\t\t\t\\\n\tnbytes -= (blocks) * __bsize;\t\t\t\t\t\\\n} while (0)\n\n#define ECB_BLOCK(blocks, func) do {\t\t\t\t\t\\\n\tconst int __blocks = (blocks);\t\t\t\t\t\\\n\tif (do_fpu && __blocks < __fpu_blocks) {\t\t\t\\\n\t\tkernel_fpu_end();\t\t\t\t\t\\\n\t\tdo_fpu = false;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\twhile (nbytes >= __blocks * __bsize) {\t\t\t\t\\\n\t\t(func)(ctx, dst, src);\t\t\t\t\t\\\n\t\tECB_WALK_ADVANCE(blocks);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define CBC_ENC_BLOCK(func) do {\t\t\t\t\t\\\n\tconst u8 *__iv = walk.iv;\t\t\t\t\t\\\n\twhile (nbytes >= __bsize) {\t\t\t\t\t\\\n\t\tcrypto_xor_cpy(dst, src, __iv, __bsize);\t\t\\\n\t\t(func)(ctx, dst, dst);\t\t\t\t\t\\\n\t\t__iv = dst;\t\t\t\t\t\t\\\n\t\tECB_WALK_ADVANCE(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tmemcpy(walk.iv, __iv, __bsize);\t\t\t\t\t\\\n} while (0)\n\n#define CBC_DEC_BLOCK(blocks, func) do {\t\t\t\t\\\n\tconst int __blocks = (blocks);\t\t\t\t\t\\\n\tif (do_fpu && __blocks <  __fpu_blocks) {\t\t\t\\\n\t\tkernel_fpu_end();\t\t\t\t\t\\\n\t\tdo_fpu = false;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\twhile (nbytes >= __blocks * __bsize) {\t\t\t\t\\\n\t\tconst u8 *__iv = src + ((blocks) - 1) * __bsize;\t\\\n\t\tif (dst == src)\t\t\t\t\t\t\\\n\t\t\t__iv = memcpy(buf, __iv, __bsize);\t\t\\\n\t\t(func)(ctx, dst, src);\t\t\t\t\t\\\n\t\tcrypto_xor(dst, walk.iv, __bsize);\t\t\t\\\n\t\tmemcpy(walk.iv, __iv, __bsize);\t\t\t\t\\\n\t\tECB_WALK_ADVANCE(blocks);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ECB_WALK_END()\t\t\t\t\t\t\t\\\n\t\tif (do_fpu) kernel_fpu_end();\t\t\t\t\\\n\t\terr = skcipher_walk_done(&walk, nbytes);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn err;\t\t\t\t\t\t\t\\\n} while (0)\n\n#define CBC_WALK_END() ECB_WALK_END()\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}