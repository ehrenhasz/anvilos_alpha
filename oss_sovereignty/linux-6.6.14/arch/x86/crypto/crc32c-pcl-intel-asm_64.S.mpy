{
  "module_name": "crc32c-pcl-intel-asm_64.S",
  "hash_id": "bf79228a4a4ce8bc94ab4229fe85d0bc35b4e8225b8a1051548a71a14d408f0e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/crc32c-pcl-intel-asm_64.S",
  "human_readable_source": " \n\n#include <linux/linkage.h>\n#include <asm/nospec-branch.h>\n\n## ISCSI CRC 32 Implementation with crc32 and pclmulqdq Instruction\n\n.macro LABEL prefix n\n.L\\prefix\\n\\():\n.endm\n\n.macro JMPTBL_ENTRY i\n.quad .Lcrc_\\i\n.endm\n\n.macro JNC_LESS_THAN j\n\tjnc .Lless_than_\\j\n.endm\n\n# Define threshold where buffers are considered \"small\" and routed to more\n# efficient \"by-1\" code. This \"by-1\" code only handles up to 255 bytes, so\n# SMALL_SIZE can be no larger than 255.\n\n#define SMALL_SIZE 200\n\n.if (SMALL_SIZE > 255)\n.error \"SMALL_ SIZE must be < 256\"\n.endif\n\n# unsigned int crc_pcl(u8 *buffer, int len, unsigned int crc_init);\n\n.text\nSYM_FUNC_START(crc_pcl)\n#define    bufp\t\trdi\n#define    bufp_dw\t%edi\n#define    bufp_w\t%di\n#define    bufp_b\t%dil\n#define    bufptmp\t%rcx\n#define    block_0\t%rcx\n#define    block_1\t%rdx\n#define    block_2\t%r11\n#define    len\t\t%rsi\n#define    len_dw\t%esi\n#define    len_w\t%si\n#define    len_b\t%sil\n#define    crc_init_arg %rdx\n#define    tmp\t\t%rbx\n#define    crc_init\t%r8\n#define    crc_init_dw\t%r8d\n#define    crc1\t\t%r9\n#define    crc2\t\t%r10\n\n\tpushq   %rbx\n\tpushq   %rdi\n\tpushq   %rsi\n\n\t## Move crc_init for Linux to a different\n\tmov     crc_init_arg, crc_init\n\n\t################################################################\n\t## 1) ALIGN:\n\t################################################################\n\n\tmov     %bufp, bufptmp\t\t# rdi = *buf\n\tneg     %bufp\n\tand     $7, %bufp\t\t# calculate the unalignment amount of\n\t\t\t\t\t# the address\n\tje      .Lproc_block\t\t# Skip if aligned\n\n\t## If len is less than 8 and we're unaligned, we need to jump\n\t## to special code to avoid reading beyond the end of the buffer\n\tcmp     $8, len\n\tjae     .Ldo_align\n\t# less_than_8 expects length in upper 3 bits of len_dw\n\t# less_than_8_post_shl1 expects length = carryflag * 8 + len_dw[31:30]\n\tshl     $32-3+1, len_dw\n\tjmp     .Lless_than_8_post_shl1\n\n.Ldo_align:\n\t#### Calculate CRC of unaligned bytes of the buffer (if any)\n\tmovq    (bufptmp), tmp\t\t# load a quadward from the buffer\n\tadd     %bufp, bufptmp\t\t# align buffer pointer for quadword\n\t\t\t\t\t# processing\n\tsub     %bufp, len\t\t# update buffer length\n.Lalign_loop:\n\tcrc32b  %bl, crc_init_dw \t# compute crc32 of 1-byte\n\tshr     $8, tmp\t\t\t# get next byte\n\tdec     %bufp\n\tjne     .Lalign_loop\n\n.Lproc_block:\n\n\t################################################################\n\t## 2) PROCESS  BLOCKS:\n\t################################################################\n\n\t## compute num of bytes to be processed\n\tmovq    len, tmp\t\t# save num bytes in tmp\n\n\tcmpq    $128*24, len\n\tjae     .Lfull_block\n\n.Lcontinue_block:\n\tcmpq    $SMALL_SIZE, len\n\tjb      .Lsmall\n\n\t## len < 128*24\n\tmovq    $2731, %rax\t\t# 2731 = ceil(2^16 / 24)\n\tmul     len_dw\n\tshrq    $16, %rax\n\n\t## eax contains floor(bytes / 24) = num 24-byte chunks to do\n\n\t## process rax 24-byte chunks (128 >= rax >= 0)\n\n\t## compute end address of each block\n\t## block 0 (base addr + RAX * 8)\n\t## block 1 (base addr + RAX * 16)\n\t## block 2 (base addr + RAX * 24)\n\tlea     (bufptmp, %rax, 8), block_0\n\tlea     (block_0, %rax, 8), block_1\n\tlea     (block_1, %rax, 8), block_2\n\n\txor     crc1, crc1\n\txor     crc2, crc2\n\n\t## branch into array\n\tleaq\tjump_table(%rip), %bufp\n\tmov\t(%bufp,%rax,8), %bufp\n\tJMP_NOSPEC bufp\n\n\t################################################################\n\t## 2a) PROCESS FULL BLOCKS:\n\t################################################################\n.Lfull_block:\n\tmovl    $128,%eax\n\tlea     128*8*2(block_0), block_1\n\tlea     128*8*3(block_0), block_2\n\tadd     $128*8*1, block_0\n\n\txor     crc1,crc1\n\txor     crc2,crc2\n\n\t# Fall thruogh into top of crc array (crc_128)\n\n\t################################################################\n\t## 3) CRC Array:\n\t################################################################\n\n\ti=128\n.rept 128-1\n.altmacro\nLABEL crc_ %i\n.noaltmacro\n\tENDBR\n\tcrc32q   -i*8(block_0), crc_init\n\tcrc32q   -i*8(block_1), crc1\n\tcrc32q   -i*8(block_2), crc2\n\ti=(i-1)\n.endr\n\n.altmacro\nLABEL crc_ %i\n.noaltmacro\n\tENDBR\n\tcrc32q   -i*8(block_0), crc_init\n\tcrc32q   -i*8(block_1), crc1\n# SKIP  crc32  -i*8(block_2), crc2 ; Don't do this one yet\n\n\tmov     block_2, block_0\n\n\t################################################################\n\t## 4) Combine three results:\n\t################################################################\n\n\tlea\t(K_table-8)(%rip), %bufp\t\t# first entry is for idx 1\n\tshlq    $3, %rax\t\t\t# rax *= 8\n\tpmovzxdq (%bufp,%rax), %xmm0\t\t# 2 consts: K1:K2\n\tleal\t(%eax,%eax,2), %eax\t\t# rax *= 3 (total *24)\n\tsubq    %rax, tmp\t\t\t# tmp -= rax*24\n\n\tmovq    crc_init, %xmm1\t\t\t# CRC for block 1\n\tpclmulqdq $0x00, %xmm0, %xmm1\t\t# Multiply by K2\n\n\tmovq    crc1, %xmm2\t\t\t# CRC for block 2\n\tpclmulqdq $0x10, %xmm0, %xmm2\t\t# Multiply by K1\n\n\tpxor    %xmm2,%xmm1\n\tmovq    %xmm1, %rax\n\txor     -i*8(block_2), %rax\n\tmov     crc2, crc_init\n\tcrc32   %rax, crc_init\n\n\t################################################################\n\t## 5) Check for end:\n\t################################################################\n\nLABEL crc_ 0\n\tENDBR\n\tmov     tmp, len\n\tcmp     $128*24, tmp\n\tjae     .Lfull_block\n\tcmp     $24, tmp\n\tjae     .Lcontinue_block\n\n.Lless_than_24:\n\tshl     $32-4, len_dw\t\t\t# less_than_16 expects length\n\t\t\t\t\t\t# in upper 4 bits of len_dw\n\tjnc     .Lless_than_16\n\tcrc32q  (bufptmp), crc_init\n\tcrc32q  8(bufptmp), crc_init\n\tjz      .Ldo_return\n\tadd     $16, bufptmp\n\t# len is less than 8 if we got here\n\t# less_than_8 expects length in upper 3 bits of len_dw\n\t# less_than_8_post_shl1 expects length = carryflag * 8 + len_dw[31:30]\n\tshl     $2, len_dw\n\tjmp     .Lless_than_8_post_shl1\n\n\t#######################################################################\n\t## 6) LESS THAN 256-bytes REMAIN AT THIS POINT (8-bits of len are full)\n\t#######################################################################\n.Lsmall:\n\tshl $32-8, len_dw\t\t# Prepare len_dw for less_than_256\n\tj=256\n.rept 5\t\t\t\t\t# j = {256, 128, 64, 32, 16}\n.altmacro\nLABEL less_than_ %j\t\t\t# less_than_j: Length should be in\n\t\t\t\t\t# upper lg(j) bits of len_dw\n\tj=(j/2)\n\tshl     $1, len_dw\t\t# Get next MSB\n\tJNC_LESS_THAN %j\n.noaltmacro\n\ti=0\n.rept (j/8)\n\tcrc32q  i(bufptmp), crc_init\t# Compute crc32 of 8-byte data\n\ti=i+8\n.endr\n\tjz      .Ldo_return\t\t# Return if remaining length is zero\n\tadd     $j, bufptmp\t\t# Advance buf\n.endr\n\n.Lless_than_8:\t\t\t\t# Length should be stored in\n\t\t\t\t\t# upper 3 bits of len_dw\n\tshl     $1, len_dw\n.Lless_than_8_post_shl1:\n\tjnc     .Lless_than_4\n\tcrc32l  (bufptmp), crc_init_dw\t# CRC of 4 bytes\n\tjz      .Ldo_return\t\t# return if remaining data is zero\n\tadd     $4, bufptmp\n.Lless_than_4:\t\t\t\t# Length should be stored in\n\t\t\t\t\t# upper 2 bits of len_dw\n\tshl     $1, len_dw\n\tjnc     .Lless_than_2\n\tcrc32w  (bufptmp), crc_init_dw\t# CRC of 2 bytes\n\tjz      .Ldo_return\t\t# return if remaining data is zero\n\tadd     $2, bufptmp\n.Lless_than_2:\t\t\t\t# Length should be stored in the MSB\n\t\t\t\t\t# of len_dw\n\tshl     $1, len_dw\n\tjnc     .Lless_than_1\n\tcrc32b  (bufptmp), crc_init_dw\t# CRC of 1 byte\n.Lless_than_1:\t\t\t\t# Length should be zero\n.Ldo_return:\n\tmovq    crc_init, %rax\n\tpopq    %rsi\n\tpopq    %rdi\n\tpopq    %rbx\n        RET\nSYM_FUNC_END(crc_pcl)\n\n.section\t.rodata, \"a\", @progbits\n        ################################################################\n        ## jump table        Table is 129 entries x 2 bytes each\n        ################################################################\n.align 4\njump_table:\n\ti=0\n.rept 129\n.altmacro\nJMPTBL_ENTRY %i\n.noaltmacro\n\ti=i+1\n.endr\n\n\n\t################################################################\n\t## PCLMULQDQ tables\n\t## Table is 128 entries x 2 words (8 bytes) each\n\t################################################################\n.align 8\nK_table:\n\t.long 0x493c7d27, 0x00000001\n\t.long 0xba4fc28e, 0x493c7d27\n\t.long 0xddc0152b, 0xf20c0dfe\n\t.long 0x9e4addf8, 0xba4fc28e\n\t.long 0x39d3b296, 0x3da6d0cb\n\t.long 0x0715ce53, 0xddc0152b\n\t.long 0x47db8317, 0x1c291d04\n\t.long 0x0d3b6092, 0x9e4addf8\n\t.long 0xc96cfdc0, 0x740eef02\n\t.long 0x878a92a7, 0x39d3b296\n\t.long 0xdaece73e, 0x083a6eec\n\t.long 0xab7aff2a, 0x0715ce53\n\t.long 0x2162d385, 0xc49f4f67\n\t.long 0x83348832, 0x47db8317\n\t.long 0x299847d5, 0x2ad91c30\n\t.long 0xb9e02b86, 0x0d3b6092\n\t.long 0x18b33a4e, 0x6992cea2\n\t.long 0xb6dd949b, 0xc96cfdc0\n\t.long 0x78d9ccb7, 0x7e908048\n\t.long 0xbac2fd7b, 0x878a92a7\n\t.long 0xa60ce07b, 0x1b3d8f29\n\t.long 0xce7f39f4, 0xdaece73e\n\t.long 0x61d82e56, 0xf1d0f55e\n\t.long 0xd270f1a2, 0xab7aff2a\n\t.long 0xc619809d, 0xa87ab8a8\n\t.long 0x2b3cac5d, 0x2162d385\n\t.long 0x65863b64, 0x8462d800\n\t.long 0x1b03397f, 0x83348832\n\t.long 0xebb883bd, 0x71d111a8\n\t.long 0xb3e32c28, 0x299847d5\n\t.long 0x064f7f26, 0xffd852c6\n\t.long 0xdd7e3b0c, 0xb9e02b86\n\t.long 0xf285651c, 0xdcb17aa4\n\t.long 0x10746f3c, 0x18b33a4e\n\t.long 0xc7a68855, 0xf37c5aee\n\t.long 0x271d9844, 0xb6dd949b\n\t.long 0x8e766a0c, 0x6051d5a2\n\t.long 0x93a5f730, 0x78d9ccb7\n\t.long 0x6cb08e5c, 0x18b0d4ff\n\t.long 0x6b749fb2, 0xbac2fd7b\n\t.long 0x1393e203, 0x21f3d99c\n\t.long 0xcec3662e, 0xa60ce07b\n\t.long 0x96c515bb, 0x8f158014\n\t.long 0xe6fc4e6a, 0xce7f39f4\n\t.long 0x8227bb8a, 0xa00457f7\n\t.long 0xb0cd4768, 0x61d82e56\n\t.long 0x39c7ff35, 0x8d6d2c43\n\t.long 0xd7a4825c, 0xd270f1a2\n\t.long 0x0ab3844b, 0x00ac29cf\n\t.long 0x0167d312, 0xc619809d\n\t.long 0xf6076544, 0xe9adf796\n\t.long 0x26f6a60a, 0x2b3cac5d\n\t.long 0xa741c1bf, 0x96638b34\n\t.long 0x98d8d9cb, 0x65863b64\n\t.long 0x49c3cc9c, 0xe0e9f351\n\t.long 0x68bce87a, 0x1b03397f\n\t.long 0x57a3d037, 0x9af01f2d\n\t.long 0x6956fc3b, 0xebb883bd\n\t.long 0x42d98888, 0x2cff42cf\n\t.long 0x3771e98f, 0xb3e32c28\n\t.long 0xb42ae3d9, 0x88f25a3a\n\t.long 0x2178513a, 0x064f7f26\n\t.long 0xe0ac139e, 0x4e36f0b0\n\t.long 0x170076fa, 0xdd7e3b0c\n\t.long 0x444dd413, 0xbd6f81f8\n\t.long 0x6f345e45, 0xf285651c\n\t.long 0x41d17b64, 0x91c9bd4b\n\t.long 0xff0dba97, 0x10746f3c\n\t.long 0xa2b73df1, 0x885f087b\n\t.long 0xf872e54c, 0xc7a68855\n\t.long 0x1e41e9fc, 0x4c144932\n\t.long 0x86d8e4d2, 0x271d9844\n\t.long 0x651bd98b, 0x52148f02\n\t.long 0x5bb8f1bc, 0x8e766a0c\n\t.long 0xa90fd27a, 0xa3c6f37a\n\t.long 0xb3af077a, 0x93a5f730\n\t.long 0x4984d782, 0xd7c0557f\n\t.long 0xca6ef3ac, 0x6cb08e5c\n\t.long 0x234e0b26, 0x63ded06a\n\t.long 0xdd66cbbb, 0x6b749fb2\n\t.long 0x4597456a, 0x4d56973c\n\t.long 0xe9e28eb4, 0x1393e203\n\t.long 0x7b3ff57a, 0x9669c9df\n\t.long 0xc9c8b782, 0xcec3662e\n\t.long 0x3f70cc6f, 0xe417f38a\n\t.long 0x93e106a4, 0x96c515bb\n\t.long 0x62ec6c6d, 0x4b9e0f71\n\t.long 0xd813b325, 0xe6fc4e6a\n\t.long 0x0df04680, 0xd104b8fc\n\t.long 0x2342001e, 0x8227bb8a\n\t.long 0x0a2a8d7e, 0x5b397730\n\t.long 0x6d9a4957, 0xb0cd4768\n\t.long 0xe8b6368b, 0xe78eb416\n\t.long 0xd2c3ed1a, 0x39c7ff35\n\t.long 0x995a5724, 0x61ff0e01\n\t.long 0x9ef68d35, 0xd7a4825c\n\t.long 0x0c139b31, 0x8d96551c\n\t.long 0xf2271e60, 0x0ab3844b\n\t.long 0x0b0bf8ca, 0x0bf80dd2\n\t.long 0x2664fd8b, 0x0167d312\n\t.long 0xed64812d, 0x8821abed\n\t.long 0x02ee03b2, 0xf6076544\n\t.long 0x8604ae0f, 0x6a45d2b2\n\t.long 0x363bd6b3, 0x26f6a60a\n\t.long 0x135c83fd, 0xd8d26619\n\t.long 0x5fabe670, 0xa741c1bf\n\t.long 0x35ec3279, 0xde87806c\n\t.long 0x00bcf5f6, 0x98d8d9cb\n\t.long 0x8ae00689, 0x14338754\n\t.long 0x17f27698, 0x49c3cc9c\n\t.long 0x58ca5f00, 0x5bd2011f\n\t.long 0xaa7c7ad5, 0x68bce87a\n\t.long 0xb5cfca28, 0xdd07448e\n\t.long 0xded288f8, 0x57a3d037\n\t.long 0x59f229bc, 0xdde8f5b9\n\t.long 0x6d390dec, 0x6956fc3b\n\t.long 0x37170390, 0xa3e3e02c\n\t.long 0x6353c1cc, 0x42d98888\n\t.long 0xc4584f5c, 0xd73c7bea\n\t.long 0xf48642e9, 0x3771e98f\n\t.long 0x531377e2, 0x80ff0093\n\t.long 0xdd35bc8d, 0xb42ae3d9\n\t.long 0xb25b29f2, 0x8fe4c34d\n\t.long 0x9a5ede41, 0x2178513a\n\t.long 0xa563905d, 0xdf99fc11\n\t.long 0x45cddf4e, 0xe0ac139e\n\t.long 0xacfa3103, 0x6c23e841\n\t.long 0xa51b6135, 0x170076fa\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}