{
  "module_name": "polyval-clmulni_asm.S",
  "hash_id": "3a62217e6f729aaa53079fc2e4528c17e52e7ffe3286ddb85517d163c3ea68d3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/polyval-clmulni_asm.S",
  "human_readable_source": " \n \n \n\n#include <linux/linkage.h>\n#include <asm/frame.h>\n\n#define STRIDE_BLOCKS 8\n\n#define GSTAR %xmm7\n#define PL %xmm8\n#define PH %xmm9\n#define TMP_XMM %xmm11\n#define LO %xmm12\n#define HI %xmm13\n#define MI %xmm14\n#define SUM %xmm15\n\n#define KEY_POWERS %rdi\n#define MSG %rsi\n#define BLOCKS_LEFT %rdx\n#define ACCUMULATOR %rcx\n#define TMP %rax\n\n.section    .rodata.cst16.gstar, \"aM\", @progbits, 16\n.align 16\n\n.Lgstar:\n\t.quad 0xc200000000000000, 0xc200000000000000\n\n.text\n\n \n.macro schoolbook1 count\n\t.set i, 0\n\t.rept (\\count)\n\t\tschoolbook1_iteration i 0\n\t\t.set i, (i +1)\n\t.endr\n.endm\n\n \n.macro schoolbook1_iteration i xor_sum\n\tmovups (16*\\i)(MSG), %xmm0\n\t.if (\\i == 0 && \\xor_sum == 1)\n\t\tpxor SUM, %xmm0\n\t.endif\n\tvpclmulqdq $0x01, (16*\\i)(KEY_POWERS), %xmm0, %xmm2\n\tvpclmulqdq $0x00, (16*\\i)(KEY_POWERS), %xmm0, %xmm1\n\tvpclmulqdq $0x10, (16*\\i)(KEY_POWERS), %xmm0, %xmm3\n\tvpclmulqdq $0x11, (16*\\i)(KEY_POWERS), %xmm0, %xmm4\n\tvpxor %xmm2, MI, MI\n\tvpxor %xmm1, LO, LO\n\tvpxor %xmm4, HI, HI\n\tvpxor %xmm3, MI, MI\n.endm\n\n \n.macro schoolbook1_noload\n\tvpclmulqdq $0x01, %xmm0, %xmm1, MI\n\tvpclmulqdq $0x10, %xmm0, %xmm1, %xmm2\n\tvpclmulqdq $0x00, %xmm0, %xmm1, LO\n\tvpclmulqdq $0x11, %xmm0, %xmm1, HI\n\tvpxor %xmm2, MI, MI\n.endm\n\n \n.macro schoolbook2\n\tvpslldq $8, MI, PL\n\tvpsrldq $8, MI, PH\n\tpxor LO, PL\n\tpxor HI, PH\n.endm\n\n \n.macro montgomery_reduction dest\n\tvpclmulqdq $0x00, PL, GSTAR, TMP_XMM\t# TMP_XMM = T_1 : T_0 = P_0 * g*(x)\n\tpshufd $0b01001110, TMP_XMM, TMP_XMM\t# TMP_XMM = T_0 : T_1\n\tpxor PL, TMP_XMM\t\t\t# TMP_XMM = P_1 + T_0 : P_0 + T_1\n\tpxor TMP_XMM, PH\t\t\t# PH = P_3 + P_1 + T_0 : P_2 + P_0 + T_1\n\tpclmulqdq $0x11, GSTAR, TMP_XMM\t\t# TMP_XMM = V_1 : V_0 = V = [(P_1 + T_0) * g*(x)]\n\tvpxor TMP_XMM, PH, \\dest\n.endm\n\n \n.macro full_stride reduce\n\tpxor LO, LO\n\tpxor HI, HI\n\tpxor MI, MI\n\n\tschoolbook1_iteration 7 0\n\t.if \\reduce\n\t\tvpclmulqdq $0x00, PL, GSTAR, TMP_XMM\n\t.endif\n\n\tschoolbook1_iteration 6 0\n\t.if \\reduce\n\t\tpshufd $0b01001110, TMP_XMM, TMP_XMM\n\t.endif\n\n\tschoolbook1_iteration 5 0\n\t.if \\reduce\n\t\tpxor PL, TMP_XMM\n\t.endif\n\n\tschoolbook1_iteration 4 0\n\t.if \\reduce\n\t\tpxor TMP_XMM, PH\n\t.endif\n\n\tschoolbook1_iteration 3 0\n\t.if \\reduce\n\t\tpclmulqdq $0x11, GSTAR, TMP_XMM\n\t.endif\n\n\tschoolbook1_iteration 2 0\n\t.if \\reduce\n\t\tvpxor TMP_XMM, PH, SUM\n\t.endif\n\n\tschoolbook1_iteration 1 0\n\n\tschoolbook1_iteration 0 1\n\n\taddq $(8*16), MSG\n\tschoolbook2\n.endm\n\n \n.macro partial_stride\n\tmov BLOCKS_LEFT, TMP\n\tshlq $4, TMP\n\taddq $(16*STRIDE_BLOCKS), KEY_POWERS\n\tsubq TMP, KEY_POWERS\n\n\tmovups (MSG), %xmm0\n\tpxor SUM, %xmm0\n\tmovaps (KEY_POWERS), %xmm1\n\tschoolbook1_noload\n\tdec BLOCKS_LEFT\n\taddq $16, MSG\n\taddq $16, KEY_POWERS\n\n\ttest $4, BLOCKS_LEFT\n\tjz .Lpartial4BlocksDone\n\tschoolbook1 4\n\taddq $(4*16), MSG\n\taddq $(4*16), KEY_POWERS\n.Lpartial4BlocksDone:\n\ttest $2, BLOCKS_LEFT\n\tjz .Lpartial2BlocksDone\n\tschoolbook1 2\n\taddq $(2*16), MSG\n\taddq $(2*16), KEY_POWERS\n.Lpartial2BlocksDone:\n\ttest $1, BLOCKS_LEFT\n\tjz .LpartialDone\n\tschoolbook1 1\n.LpartialDone:\n\tschoolbook2\n\tmontgomery_reduction SUM\n.endm\n\n \nSYM_FUNC_START(clmul_polyval_mul)\n\tFRAME_BEGIN\n\tvmovdqa .Lgstar(%rip), GSTAR\n\tmovups (%rdi), %xmm0\n\tmovups (%rsi), %xmm1\n\tschoolbook1_noload\n\tschoolbook2\n\tmontgomery_reduction SUM\n\tmovups SUM, (%rdi)\n\tFRAME_END\n\tRET\nSYM_FUNC_END(clmul_polyval_mul)\n\n \nSYM_FUNC_START(clmul_polyval_update)\n\tFRAME_BEGIN\n\tvmovdqa .Lgstar(%rip), GSTAR\n\tmovups (ACCUMULATOR), SUM\n\tsubq $STRIDE_BLOCKS, BLOCKS_LEFT\n\tjs .LstrideLoopExit\n\tfull_stride 0\n\tsubq $STRIDE_BLOCKS, BLOCKS_LEFT\n\tjs .LstrideLoopExitReduce\n.LstrideLoop:\n\tfull_stride 1\n\tsubq $STRIDE_BLOCKS, BLOCKS_LEFT\n\tjns .LstrideLoop\n.LstrideLoopExitReduce:\n\tmontgomery_reduction SUM\n.LstrideLoopExit:\n\tadd $STRIDE_BLOCKS, BLOCKS_LEFT\n\tjz .LskipPartial\n\tpartial_stride\n.LskipPartial:\n\tmovups SUM, (ACCUMULATOR)\n\tFRAME_END\n\tRET\nSYM_FUNC_END(clmul_polyval_update)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}