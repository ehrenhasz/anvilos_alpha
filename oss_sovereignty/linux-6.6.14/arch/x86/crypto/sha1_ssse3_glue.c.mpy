{
  "module_name": "sha1_ssse3_glue.c",
  "hash_id": "d3fa7b518c7e49e21876b0cb3f276acf01d911deead6246af8f1ce4912abddb0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/sha1_ssse3_glue.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <crypto/internal/hash.h>\n#include <crypto/internal/simd.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <crypto/sha1.h>\n#include <crypto/sha1_base.h>\n#include <asm/cpu_device_id.h>\n#include <asm/simd.h>\n\nstatic const struct x86_cpu_id module_cpu_ids[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_AVX2, NULL),\n\tX86_MATCH_FEATURE(X86_FEATURE_AVX, NULL),\n\tX86_MATCH_FEATURE(X86_FEATURE_SSSE3, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, module_cpu_ids);\n\nstatic int sha1_update(struct shash_desc *desc, const u8 *data,\n\t\t\t     unsigned int len, sha1_block_fn *sha1_xform)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\n\tif (!crypto_simd_usable() ||\n\t    (sctx->count % SHA1_BLOCK_SIZE) + len < SHA1_BLOCK_SIZE)\n\t\treturn crypto_sha1_update(desc, data, len);\n\n\t \n\tBUILD_BUG_ON(offsetof(struct sha1_state, state) != 0);\n\n\tkernel_fpu_begin();\n\tsha1_base_do_update(desc, data, len, sha1_xform);\n\tkernel_fpu_end();\n\n\treturn 0;\n}\n\nstatic int sha1_finup(struct shash_desc *desc, const u8 *data,\n\t\t      unsigned int len, u8 *out, sha1_block_fn *sha1_xform)\n{\n\tif (!crypto_simd_usable())\n\t\treturn crypto_sha1_finup(desc, data, len, out);\n\n\tkernel_fpu_begin();\n\tif (len)\n\t\tsha1_base_do_update(desc, data, len, sha1_xform);\n\tsha1_base_do_finalize(desc, sha1_xform);\n\tkernel_fpu_end();\n\n\treturn sha1_base_finish(desc, out);\n}\n\nasmlinkage void sha1_transform_ssse3(struct sha1_state *state,\n\t\t\t\t     const u8 *data, int blocks);\n\nstatic int sha1_ssse3_update(struct shash_desc *desc, const u8 *data,\n\t\t\t     unsigned int len)\n{\n\treturn sha1_update(desc, data, len, sha1_transform_ssse3);\n}\n\nstatic int sha1_ssse3_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn sha1_finup(desc, data, len, out, sha1_transform_ssse3);\n}\n\n \nstatic int sha1_ssse3_final(struct shash_desc *desc, u8 *out)\n{\n\treturn sha1_ssse3_finup(desc, NULL, 0, out);\n}\n\nstatic struct shash_alg sha1_ssse3_alg = {\n\t.digestsize\t=\tSHA1_DIGEST_SIZE,\n\t.init\t\t=\tsha1_base_init,\n\t.update\t\t=\tsha1_ssse3_update,\n\t.final\t\t=\tsha1_ssse3_final,\n\t.finup\t\t=\tsha1_ssse3_finup,\n\t.descsize\t=\tsizeof(struct sha1_state),\n\t.base\t\t=\t{\n\t\t.cra_name\t=\t\"sha1\",\n\t\t.cra_driver_name =\t\"sha1-ssse3\",\n\t\t.cra_priority\t=\t150,\n\t\t.cra_blocksize\t=\tSHA1_BLOCK_SIZE,\n\t\t.cra_module\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic int register_sha1_ssse3(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_SSSE3))\n\t\treturn crypto_register_shash(&sha1_ssse3_alg);\n\treturn 0;\n}\n\nstatic void unregister_sha1_ssse3(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_SSSE3))\n\t\tcrypto_unregister_shash(&sha1_ssse3_alg);\n}\n\nasmlinkage void sha1_transform_avx(struct sha1_state *state,\n\t\t\t\t   const u8 *data, int blocks);\n\nstatic int sha1_avx_update(struct shash_desc *desc, const u8 *data,\n\t\t\t     unsigned int len)\n{\n\treturn sha1_update(desc, data, len, sha1_transform_avx);\n}\n\nstatic int sha1_avx_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn sha1_finup(desc, data, len, out, sha1_transform_avx);\n}\n\nstatic int sha1_avx_final(struct shash_desc *desc, u8 *out)\n{\n\treturn sha1_avx_finup(desc, NULL, 0, out);\n}\n\nstatic struct shash_alg sha1_avx_alg = {\n\t.digestsize\t=\tSHA1_DIGEST_SIZE,\n\t.init\t\t=\tsha1_base_init,\n\t.update\t\t=\tsha1_avx_update,\n\t.final\t\t=\tsha1_avx_final,\n\t.finup\t\t=\tsha1_avx_finup,\n\t.descsize\t=\tsizeof(struct sha1_state),\n\t.base\t\t=\t{\n\t\t.cra_name\t=\t\"sha1\",\n\t\t.cra_driver_name =\t\"sha1-avx\",\n\t\t.cra_priority\t=\t160,\n\t\t.cra_blocksize\t=\tSHA1_BLOCK_SIZE,\n\t\t.cra_module\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic bool avx_usable(void)\n{\n\tif (!cpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM, NULL)) {\n\t\tif (boot_cpu_has(X86_FEATURE_AVX))\n\t\t\tpr_info(\"AVX detected but unusable.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int register_sha1_avx(void)\n{\n\tif (avx_usable())\n\t\treturn crypto_register_shash(&sha1_avx_alg);\n\treturn 0;\n}\n\nstatic void unregister_sha1_avx(void)\n{\n\tif (avx_usable())\n\t\tcrypto_unregister_shash(&sha1_avx_alg);\n}\n\n#define SHA1_AVX2_BLOCK_OPTSIZE\t4\t \n\nasmlinkage void sha1_transform_avx2(struct sha1_state *state,\n\t\t\t\t    const u8 *data, int blocks);\n\nstatic bool avx2_usable(void)\n{\n\tif (avx_usable() && boot_cpu_has(X86_FEATURE_AVX2)\n\t\t&& boot_cpu_has(X86_FEATURE_BMI1)\n\t\t&& boot_cpu_has(X86_FEATURE_BMI2))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void sha1_apply_transform_avx2(struct sha1_state *state,\n\t\t\t\t      const u8 *data, int blocks)\n{\n\t \n\tif (blocks >= SHA1_AVX2_BLOCK_OPTSIZE)\n\t\tsha1_transform_avx2(state, data, blocks);\n\telse\n\t\tsha1_transform_avx(state, data, blocks);\n}\n\nstatic int sha1_avx2_update(struct shash_desc *desc, const u8 *data,\n\t\t\t     unsigned int len)\n{\n\treturn sha1_update(desc, data, len, sha1_apply_transform_avx2);\n}\n\nstatic int sha1_avx2_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn sha1_finup(desc, data, len, out, sha1_apply_transform_avx2);\n}\n\nstatic int sha1_avx2_final(struct shash_desc *desc, u8 *out)\n{\n\treturn sha1_avx2_finup(desc, NULL, 0, out);\n}\n\nstatic struct shash_alg sha1_avx2_alg = {\n\t.digestsize\t=\tSHA1_DIGEST_SIZE,\n\t.init\t\t=\tsha1_base_init,\n\t.update\t\t=\tsha1_avx2_update,\n\t.final\t\t=\tsha1_avx2_final,\n\t.finup\t\t=\tsha1_avx2_finup,\n\t.descsize\t=\tsizeof(struct sha1_state),\n\t.base\t\t=\t{\n\t\t.cra_name\t=\t\"sha1\",\n\t\t.cra_driver_name =\t\"sha1-avx2\",\n\t\t.cra_priority\t=\t170,\n\t\t.cra_blocksize\t=\tSHA1_BLOCK_SIZE,\n\t\t.cra_module\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic int register_sha1_avx2(void)\n{\n\tif (avx2_usable())\n\t\treturn crypto_register_shash(&sha1_avx2_alg);\n\treturn 0;\n}\n\nstatic void unregister_sha1_avx2(void)\n{\n\tif (avx2_usable())\n\t\tcrypto_unregister_shash(&sha1_avx2_alg);\n}\n\n#ifdef CONFIG_AS_SHA1_NI\nasmlinkage void sha1_ni_transform(struct sha1_state *digest, const u8 *data,\n\t\t\t\t  int rounds);\n\nstatic int sha1_ni_update(struct shash_desc *desc, const u8 *data,\n\t\t\t     unsigned int len)\n{\n\treturn sha1_update(desc, data, len, sha1_ni_transform);\n}\n\nstatic int sha1_ni_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t      unsigned int len, u8 *out)\n{\n\treturn sha1_finup(desc, data, len, out, sha1_ni_transform);\n}\n\nstatic int sha1_ni_final(struct shash_desc *desc, u8 *out)\n{\n\treturn sha1_ni_finup(desc, NULL, 0, out);\n}\n\nstatic struct shash_alg sha1_ni_alg = {\n\t.digestsize\t=\tSHA1_DIGEST_SIZE,\n\t.init\t\t=\tsha1_base_init,\n\t.update\t\t=\tsha1_ni_update,\n\t.final\t\t=\tsha1_ni_final,\n\t.finup\t\t=\tsha1_ni_finup,\n\t.descsize\t=\tsizeof(struct sha1_state),\n\t.base\t\t=\t{\n\t\t.cra_name\t=\t\"sha1\",\n\t\t.cra_driver_name =\t\"sha1-ni\",\n\t\t.cra_priority\t=\t250,\n\t\t.cra_blocksize\t=\tSHA1_BLOCK_SIZE,\n\t\t.cra_module\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic int register_sha1_ni(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_SHA_NI))\n\t\treturn crypto_register_shash(&sha1_ni_alg);\n\treturn 0;\n}\n\nstatic void unregister_sha1_ni(void)\n{\n\tif (boot_cpu_has(X86_FEATURE_SHA_NI))\n\t\tcrypto_unregister_shash(&sha1_ni_alg);\n}\n\n#else\nstatic inline int register_sha1_ni(void) { return 0; }\nstatic inline void unregister_sha1_ni(void) { }\n#endif\n\nstatic int __init sha1_ssse3_mod_init(void)\n{\n\tif (!x86_match_cpu(module_cpu_ids))\n\t\treturn -ENODEV;\n\n\tif (register_sha1_ssse3())\n\t\tgoto fail;\n\n\tif (register_sha1_avx()) {\n\t\tunregister_sha1_ssse3();\n\t\tgoto fail;\n\t}\n\n\tif (register_sha1_avx2()) {\n\t\tunregister_sha1_avx();\n\t\tunregister_sha1_ssse3();\n\t\tgoto fail;\n\t}\n\n\tif (register_sha1_ni()) {\n\t\tunregister_sha1_avx2();\n\t\tunregister_sha1_avx();\n\t\tunregister_sha1_ssse3();\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENODEV;\n}\n\nstatic void __exit sha1_ssse3_mod_fini(void)\n{\n\tunregister_sha1_ni();\n\tunregister_sha1_avx2();\n\tunregister_sha1_avx();\n\tunregister_sha1_ssse3();\n}\n\nmodule_init(sha1_ssse3_mod_init);\nmodule_exit(sha1_ssse3_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\");\n\nMODULE_ALIAS_CRYPTO(\"sha1\");\nMODULE_ALIAS_CRYPTO(\"sha1-ssse3\");\nMODULE_ALIAS_CRYPTO(\"sha1-avx\");\nMODULE_ALIAS_CRYPTO(\"sha1-avx2\");\n#ifdef CONFIG_AS_SHA1_NI\nMODULE_ALIAS_CRYPTO(\"sha1-ni\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}