{
  "module_name": "ghash-clmulni-intel_asm.S",
  "hash_id": "af46a28d474be8fe2bf389b84cd38ec1a781c6d52d8629ec8a599483aab5fa6c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/crypto/ghash-clmulni-intel_asm.S",
  "human_readable_source": " \n \n\n#include <linux/linkage.h>\n#include <asm/frame.h>\n\n.section\t.rodata.cst16.bswap_mask, \"aM\", @progbits, 16\n.align 16\n.Lbswap_mask:\n\t.octa 0x000102030405060708090a0b0c0d0e0f\n\n#define DATA\t%xmm0\n#define SHASH\t%xmm1\n#define T1\t%xmm2\n#define T2\t%xmm3\n#define T3\t%xmm4\n#define BSWAP\t%xmm5\n#define IN1\t%xmm6\n\n.text\n\n \nSYM_FUNC_START_LOCAL(__clmul_gf128mul_ble)\n\tmovaps DATA, T1\n\tpshufd $0b01001110, DATA, T2\n\tpshufd $0b01001110, SHASH, T3\n\tpxor DATA, T2\n\tpxor SHASH, T3\n\n\tpclmulqdq $0x00, SHASH, DATA\t# DATA = a0 * b0\n\tpclmulqdq $0x11, SHASH, T1\t# T1 = a1 * b1\n\tpclmulqdq $0x00, T3, T2\t\t# T2 = (a1 + a0) * (b1 + b0)\n\tpxor DATA, T2\n\tpxor T1, T2\t\t\t# T2 = a0 * b1 + a1 * b0\n\n\tmovaps T2, T3\n\tpslldq $8, T3\n\tpsrldq $8, T2\n\tpxor T3, DATA\n\tpxor T2, T1\t\t\t# <T1:DATA> is result of\n\t\t\t\t\t# carry-less multiplication\n\n\t# first phase of the reduction\n\tmovaps DATA, T3\n\tpsllq $1, T3\n\tpxor DATA, T3\n\tpsllq $5, T3\n\tpxor DATA, T3\n\tpsllq $57, T3\n\tmovaps T3, T2\n\tpslldq $8, T2\n\tpsrldq $8, T3\n\tpxor T2, DATA\n\tpxor T3, T1\n\n\t# second phase of the reduction\n\tmovaps DATA, T2\n\tpsrlq $5, T2\n\tpxor DATA, T2\n\tpsrlq $1, T2\n\tpxor DATA, T2\n\tpsrlq $1, T2\n\tpxor T2, T1\n\tpxor T1, DATA\n\tRET\nSYM_FUNC_END(__clmul_gf128mul_ble)\n\n \nSYM_FUNC_START(clmul_ghash_mul)\n\tFRAME_BEGIN\n\tmovups (%rdi), DATA\n\tmovups (%rsi), SHASH\n\tmovaps .Lbswap_mask(%rip), BSWAP\n\tpshufb BSWAP, DATA\n\tcall __clmul_gf128mul_ble\n\tpshufb BSWAP, DATA\n\tmovups DATA, (%rdi)\n\tFRAME_END\n\tRET\nSYM_FUNC_END(clmul_ghash_mul)\n\n \nSYM_FUNC_START(clmul_ghash_update)\n\tFRAME_BEGIN\n\tcmp $16, %rdx\n\tjb .Lupdate_just_ret\t# check length\n\tmovaps .Lbswap_mask(%rip), BSWAP\n\tmovups (%rdi), DATA\n\tmovups (%rcx), SHASH\n\tpshufb BSWAP, DATA\n.align 4\n.Lupdate_loop:\n\tmovups (%rsi), IN1\n\tpshufb BSWAP, IN1\n\tpxor IN1, DATA\n\tcall __clmul_gf128mul_ble\n\tsub $16, %rdx\n\tadd $16, %rsi\n\tcmp $16, %rdx\n\tjge .Lupdate_loop\n\tpshufb BSWAP, DATA\n\tmovups DATA, (%rdi)\n.Lupdate_just_ret:\n\tFRAME_END\n\tRET\nSYM_FUNC_END(clmul_ghash_update)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}