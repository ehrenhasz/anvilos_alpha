{
  "module_name": "Kconfig",
  "hash_id": "f3ffeb7832e39715d2c1e9a6f9b8dbec30e0fb6367b297f639a74714133f3e77",
  "original_prompt": "Ingested from linux-6.6.14/arch/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# General architecture dependent options\n#\n\n#\n# Note: arch/$(SRCARCH)/Kconfig needs to be included first so that it can\n# override the default values in this file.\n#\nsource \"arch/$(SRCARCH)/Kconfig\"\n\nmenu \"General architecture-dependent options\"\n\nconfig ARCH_HAS_SUBPAGE_FAULTS\n\tbool\n\thelp\n\t  Select if the architecture can check permissions at sub-page\n\t  granularity (e.g. arm64 MTE). The probe_user_*() functions\n\t  must be implemented.\n\nconfig HOTPLUG_SMT\n\tbool\n\nconfig SMT_NUM_THREADS_DYNAMIC\n\tbool\n\n# Selected by HOTPLUG_CORE_SYNC_DEAD or HOTPLUG_CORE_SYNC_FULL\nconfig HOTPLUG_CORE_SYNC\n\tbool\n\n# Basic CPU dead synchronization selected by architecture\nconfig HOTPLUG_CORE_SYNC_DEAD\n\tbool\n\tselect HOTPLUG_CORE_SYNC\n\n# Full CPU synchronization with alive state selected by architecture\nconfig HOTPLUG_CORE_SYNC_FULL\n\tbool\n\tselect HOTPLUG_CORE_SYNC_DEAD if HOTPLUG_CPU\n\tselect HOTPLUG_CORE_SYNC\n\nconfig HOTPLUG_SPLIT_STARTUP\n\tbool\n\tselect HOTPLUG_CORE_SYNC_FULL\n\nconfig HOTPLUG_PARALLEL\n\tbool\n\tselect HOTPLUG_SPLIT_STARTUP\n\nconfig GENERIC_ENTRY\n\tbool\n\nconfig KPROBES\n\tbool \"Kprobes\"\n\tdepends on MODULES\n\tdepends on HAVE_KPROBES\n\tselect KALLSYMS\n\tselect TASKS_RCU if PREEMPTION\n\thelp\n\t  Kprobes allows you to trap at almost any kernel address and\n\t  execute a callback function.  register_kprobe() establishes\n\t  a probepoint and specifies the callback.  Kprobes is useful\n\t  for kernel debugging, non-intrusive instrumentation and testing.\n\t  If in doubt, say \"N\".\n\nconfig JUMP_LABEL\n\tbool \"Optimize very unlikely/likely branches\"\n\tdepends on HAVE_ARCH_JUMP_LABEL\n\tselect OBJTOOL if HAVE_JUMP_LABEL_HACK\n\thelp\n\t  This option enables a transparent branch optimization that\n\t  makes certain almost-always-true or almost-always-false branch\n\t  conditions even cheaper to execute within the kernel.\n\n\t  Certain performance-sensitive kernel code, such as trace points,\n\t  scheduler functionality, networking code and KVM have such\n\t  branches and include support for this optimization technique.\n\n\t  If it is detected that the compiler has support for \"asm goto\",\n\t  the kernel will compile such branches with just a nop\n\t  instruction. When the condition flag is toggled to true, the\n\t  nop will be converted to a jump instruction to execute the\n\t  conditional block of instructions.\n\n\t  This technique lowers overhead and stress on the branch prediction\n\t  of the processor and generally makes the kernel faster. The update\n\t  of the condition is slower, but those are always very rare.\n\n\t  ( On 32-bit x86, the necessary options added to the compiler\n\t    flags may increase the size of the kernel slightly. )\n\nconfig STATIC_KEYS_SELFTEST\n\tbool \"Static key selftest\"\n\tdepends on JUMP_LABEL\n\thelp\n\t  Boot time self-test of the branch patching code.\n\nconfig STATIC_CALL_SELFTEST\n\tbool \"Static call selftest\"\n\tdepends on HAVE_STATIC_CALL\n\thelp\n\t  Boot time self-test of the call patching code.\n\nconfig OPTPROBES\n\tdef_bool y\n\tdepends on KPROBES && HAVE_OPTPROBES\n\tselect TASKS_RCU if PREEMPTION\n\nconfig KPROBES_ON_FTRACE\n\tdef_bool y\n\tdepends on KPROBES && HAVE_KPROBES_ON_FTRACE\n\tdepends on DYNAMIC_FTRACE_WITH_REGS\n\thelp\n\t  If function tracer is enabled and the arch supports full\n\t  passing of pt_regs to function tracing, then kprobes can\n\t  optimize on top of function tracing.\n\nconfig UPROBES\n\tdef_bool n\n\tdepends on ARCH_SUPPORTS_UPROBES\n\thelp\n\t  Uprobes is the user-space counterpart to kprobes: they\n\t  enable instrumentation applications (such as 'perf probe')\n\t  to establish unintrusive probes in user-space binaries and\n\t  libraries, by executing handler functions when the probes\n\t  are hit by user-space applications.\n\n\t  ( These probes come in the form of single-byte breakpoints,\n\t    managed by the kernel and kept transparent to the probed\n\t    application. )\n\nconfig HAVE_64BIT_ALIGNED_ACCESS\n\tdef_bool 64BIT && !HAVE_EFFICIENT_UNALIGNED_ACCESS\n\thelp\n\t  Some architectures require 64 bit accesses to be 64 bit\n\t  aligned, which also requires structs containing 64 bit values\n\t  to be 64 bit aligned too. This includes some 32 bit\n\t  architectures which can do 64 bit accesses, as well as 64 bit\n\t  architectures without unaligned access.\n\n\t  This symbol should be selected by an architecture if 64 bit\n\t  accesses are required to be 64 bit aligned in this way even\n\t  though it is not a 64 bit architecture.\n\n\t  See Documentation/core-api/unaligned-memory-access.rst for\n\t  more information on the topic of unaligned memory accesses.\n\nconfig HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tbool\n\thelp\n\t  Some architectures are unable to perform unaligned accesses\n\t  without the use of get_unaligned/put_unaligned. Others are\n\t  unable to perform such accesses efficiently (e.g. trap on\n\t  unaligned access and require fixing it up in the exception\n\t  handler.)\n\n\t  This symbol should be selected by an architecture if it can\n\t  perform unaligned accesses efficiently to allow different\n\t  code paths to be selected for these cases. Some network\n\t  drivers, for example, could opt to not fix up alignment\n\t  problems with received packets if doing so would not help\n\t  much.\n\n\t  See Documentation/core-api/unaligned-memory-access.rst for more\n\t  information on the topic of unaligned memory accesses.\n\nconfig ARCH_USE_BUILTIN_BSWAP\n\tbool\n\thelp\n\t  Modern versions of GCC (since 4.4) have builtin functions\n\t  for handling byte-swapping. Using these, instead of the old\n\t  inline assembler that the architecture code provides in the\n\t  __arch_bswapXX() macros, allows the compiler to see what's\n\t  happening and offers more opportunity for optimisation. In\n\t  particular, the compiler will be able to combine the byteswap\n\t  with a nearby load or store and use load-and-swap or\n\t  store-and-swap instructions if the architecture has them. It\n\t  should almost *never* result in code which is worse than the\n\t  hand-coded assembler in <asm/swab.h>.  But just in case it\n\t  does, the use of the builtins is optional.\n\n\t  Any architecture with load-and-swap or store-and-swap\n\t  instructions should set this. And it shouldn't hurt to set it\n\t  on architectures that don't have such instructions.\n\nconfig KRETPROBES\n\tdef_bool y\n\tdepends on KPROBES && (HAVE_KRETPROBES || HAVE_RETHOOK)\n\nconfig KRETPROBE_ON_RETHOOK\n\tdef_bool y\n\tdepends on HAVE_RETHOOK\n\tdepends on KRETPROBES\n\tselect RETHOOK\n\nconfig USER_RETURN_NOTIFIER\n\tbool\n\tdepends on HAVE_USER_RETURN_NOTIFIER\n\thelp\n\t  Provide a kernel-internal notification when a cpu is about to\n\t  switch to user mode.\n\nconfig HAVE_IOREMAP_PROT\n\tbool\n\nconfig HAVE_KPROBES\n\tbool\n\nconfig HAVE_KRETPROBES\n\tbool\n\nconfig HAVE_OPTPROBES\n\tbool\n\nconfig HAVE_KPROBES_ON_FTRACE\n\tbool\n\nconfig ARCH_CORRECT_STACKTRACE_ON_KRETPROBE\n\tbool\n\thelp\n\t  Since kretprobes modifies return address on the stack, the\n\t  stacktrace may see the kretprobe trampoline address instead\n\t  of correct one. If the architecture stacktrace code and\n\t  unwinder can adjust such entries, select this configuration.\n\nconfig HAVE_FUNCTION_ERROR_INJECTION\n\tbool\n\nconfig HAVE_NMI\n\tbool\n\nconfig HAVE_FUNCTION_DESCRIPTORS\n\tbool\n\nconfig TRACE_IRQFLAGS_SUPPORT\n\tbool\n\nconfig TRACE_IRQFLAGS_NMI_SUPPORT\n\tbool\n\n#\n# An arch should select this if it provides all these things:\n#\n#\ttask_pt_regs()\t\tin asm/processor.h or asm/ptrace.h\n#\tarch_has_single_step()\tif there is hardware single-step support\n#\tarch_has_block_step()\tif there is hardware block-step support\n#\tasm/syscall.h\t\tsupplying asm-generic/syscall.h interface\n#\tlinux/regset.h\t\tuser_regset interfaces\n#\tCORE_DUMP_USE_REGSET\t#define'd in linux/elf.h\n#\tTIF_SYSCALL_TRACE\tcalls ptrace_report_syscall_{entry,exit}\n#\tTIF_NOTIFY_RESUME\tcalls resume_user_mode_work()\n#\nconfig HAVE_ARCH_TRACEHOOK\n\tbool\n\nconfig HAVE_DMA_CONTIGUOUS\n\tbool\n\nconfig GENERIC_SMP_IDLE_THREAD\n\tbool\n\nconfig GENERIC_IDLE_POLL_SETUP\n\tbool\n\nconfig ARCH_HAS_FORTIFY_SOURCE\n\tbool\n\thelp\n\t  An architecture should select this when it can successfully\n\t  build and run with CONFIG_FORTIFY_SOURCE.\n\n#\n# Select if the arch provides a historic keepinit alias for the retain_initrd\n# command line option\n#\nconfig ARCH_HAS_KEEPINITRD\n\tbool\n\n# Select if arch has all set_memory_ro/rw/x/nx() functions in asm/cacheflush.h\nconfig ARCH_HAS_SET_MEMORY\n\tbool\n\n# Select if arch has all set_direct_map_invalid/default() functions\nconfig ARCH_HAS_SET_DIRECT_MAP\n\tbool\n\n#\n# Select if the architecture provides the arch_dma_set_uncached symbol to\n# either provide an uncached segment alias for a DMA allocation, or\n# to remap the page tables in place.\n#\nconfig ARCH_HAS_DMA_SET_UNCACHED\n\tbool\n\n#\n# Select if the architectures provides the arch_dma_clear_uncached symbol\n# to undo an in-place page table remap for uncached access.\n#\nconfig ARCH_HAS_DMA_CLEAR_UNCACHED\n\tbool\n\nconfig ARCH_HAS_CPU_FINALIZE_INIT\n\tbool\n\n# Select if arch init_task must go in the __init_task_data section\nconfig ARCH_TASK_STRUCT_ON_STACK\n\tbool\n\n# Select if arch has its private alloc_task_struct() function\nconfig ARCH_TASK_STRUCT_ALLOCATOR\n\tbool\n\nconfig HAVE_ARCH_THREAD_STRUCT_WHITELIST\n\tbool\n\tdepends on !ARCH_TASK_STRUCT_ALLOCATOR\n\thelp\n\t  An architecture should select this to provide hardened usercopy\n\t  knowledge about what region of the thread_struct should be\n\t  whitelisted for copying to userspace. Normally this is only the\n\t  FPU registers. Specifically, arch_thread_struct_whitelist()\n\t  should be implemented. Without this, the entire thread_struct\n\t  field in task_struct will be left whitelisted.\n\n# Select if arch has its private alloc_thread_stack() function\nconfig ARCH_THREAD_STACK_ALLOCATOR\n\tbool\n\n# Select if arch wants to size task_struct dynamically via arch_task_struct_size:\nconfig ARCH_WANTS_DYNAMIC_TASK_STRUCT\n\tbool\n\nconfig ARCH_WANTS_NO_INSTR\n\tbool\n\thelp\n\t  An architecture should select this if the noinstr macro is being used on\n\t  functions to denote that the toolchain should avoid instrumenting such\n\t  functions and is required for correctness.\n\nconfig ARCH_32BIT_OFF_T\n\tbool\n\tdepends on !64BIT\n\thelp\n\t  All new 32-bit architectures should have 64-bit off_t type on\n\t  userspace side which corresponds to the loff_t kernel type. This\n\t  is the requirement for modern ABIs. Some existing architectures\n\t  still support 32-bit off_t. This option is enabled for all such\n\t  architectures explicitly.\n\n# Selected by 64 bit architectures which have a 32 bit f_tinode in struct ustat\nconfig ARCH_32BIT_USTAT_F_TINODE\n\tbool\n\nconfig HAVE_ASM_MODVERSIONS\n\tbool\n\thelp\n\t  This symbol should be selected by an architecture if it provides\n\t  <asm/asm-prototypes.h> to support the module versioning for symbols\n\t  exported from assembly code.\n\nconfig HAVE_REGS_AND_STACK_ACCESS_API\n\tbool\n\thelp\n\t  This symbol should be selected by an architecture if it supports\n\t  the API needed to access registers and stack entries from pt_regs,\n\t  declared in asm/ptrace.h\n\t  For example the kprobes-based event tracer needs this API.\n\nconfig HAVE_RSEQ\n\tbool\n\tdepends on HAVE_REGS_AND_STACK_ACCESS_API\n\thelp\n\t  This symbol should be selected by an architecture if it\n\t  supports an implementation of restartable sequences.\n\nconfig HAVE_RUST\n\tbool\n\thelp\n\t  This symbol should be selected by an architecture if it\n\t  supports Rust.\n\nconfig HAVE_FUNCTION_ARG_ACCESS_API\n\tbool\n\thelp\n\t  This symbol should be selected by an architecture if it supports\n\t  the API needed to access function arguments from pt_regs,\n\t  declared in asm/ptrace.h\n\nconfig HAVE_HW_BREAKPOINT\n\tbool\n\tdepends on PERF_EVENTS\n\nconfig HAVE_MIXED_BREAKPOINTS_REGS\n\tbool\n\tdepends on HAVE_HW_BREAKPOINT\n\thelp\n\t  Depending on the arch implementation of hardware breakpoints,\n\t  some of them have separate registers for data and instruction\n\t  breakpoints addresses, others have mixed registers to store\n\t  them but define the access type in a control register.\n\t  Select this option if your arch implements breakpoints under the\n\t  latter fashion.\n\nconfig HAVE_USER_RETURN_NOTIFIER\n\tbool\n\nconfig HAVE_PERF_EVENTS_NMI\n\tbool\n\thelp\n\t  System hardware can generate an NMI using the perf event\n\t  subsystem.  Also has support for calculating CPU cycle events\n\t  to determine how many clock cycles in a given period.\n\nconfig HAVE_HARDLOCKUP_DETECTOR_PERF\n\tbool\n\tdepends on HAVE_PERF_EVENTS_NMI\n\thelp\n\t  The arch chooses to use the generic perf-NMI-based hardlockup\n\t  detector. Must define HAVE_PERF_EVENTS_NMI.\n\nconfig HAVE_HARDLOCKUP_DETECTOR_ARCH\n\tbool\n\thelp\n\t  The arch provides its own hardlockup detector implementation instead\n\t  of the generic ones.\n\n\t  It uses the same command line parameters, and sysctl interface,\n\t  as the generic hardlockup detectors.\n\nconfig HAVE_PERF_REGS\n\tbool\n\thelp\n\t  Support selective register dumps for perf events. This includes\n\t  bit-mapping of each registers and a unique architecture id.\n\nconfig HAVE_PERF_USER_STACK_DUMP\n\tbool\n\thelp\n\t  Support user stack dumps for perf event samples. This needs\n\t  access to the user stack pointer which is not unified across\n\t  architectures.\n\nconfig HAVE_ARCH_JUMP_LABEL\n\tbool\n\nconfig HAVE_ARCH_JUMP_LABEL_RELATIVE\n\tbool\n\nconfig MMU_GATHER_TABLE_FREE\n\tbool\n\nconfig MMU_GATHER_RCU_TABLE_FREE\n\tbool\n\tselect MMU_GATHER_TABLE_FREE\n\nconfig MMU_GATHER_PAGE_SIZE\n\tbool\n\nconfig MMU_GATHER_NO_RANGE\n\tbool\n\tselect MMU_GATHER_MERGE_VMAS\n\nconfig MMU_GATHER_NO_FLUSH_CACHE\n\tbool\n\nconfig MMU_GATHER_MERGE_VMAS\n\tbool\n\nconfig MMU_GATHER_NO_GATHER\n\tbool\n\tdepends on MMU_GATHER_TABLE_FREE\n\nconfig ARCH_WANT_IRQS_OFF_ACTIVATE_MM\n\tbool\n\thelp\n\t  Temporary select until all architectures can be converted to have\n\t  irqs disabled over activate_mm. Architectures that do IPI based TLB\n\t  shootdowns should enable this.\n\n# Use normal mm refcounting for MMU_LAZY_TLB kernel thread references.\n# MMU_LAZY_TLB_REFCOUNT=n can improve the scalability of context switching\n# to/from kernel threads when the same mm is running on a lot of CPUs (a large\n# multi-threaded application), by reducing contention on the mm refcount.\n#\n# This can be disabled if the architecture ensures no CPUs are using an mm as a\n# \"lazy tlb\" beyond its final refcount (i.e., by the time __mmdrop frees the mm\n# or its kernel page tables). This could be arranged by arch_exit_mmap(), or\n# final exit(2) TLB flush, for example.\n#\n# To implement this, an arch *must*:\n# Ensure the _lazy_tlb variants of mmgrab/mmdrop are used when manipulating\n# the lazy tlb reference of a kthread's ->active_mm (non-arch code has been\n# converted already).\nconfig MMU_LAZY_TLB_REFCOUNT\n\tdef_bool y\n\tdepends on !MMU_LAZY_TLB_SHOOTDOWN\n\n# This option allows MMU_LAZY_TLB_REFCOUNT=n. It ensures no CPUs are using an\n# mm as a lazy tlb beyond its last reference count, by shooting down these\n# users before the mm is deallocated. __mmdrop() first IPIs all CPUs that may\n# be using the mm as a lazy tlb, so that they may switch themselves to using\n# init_mm for their active mm. mm_cpumask(mm) is used to determine which CPUs\n# may be using mm as a lazy tlb mm.\n#\n# To implement this, an arch *must*:\n# - At the time of the final mmdrop of the mm, ensure mm_cpumask(mm) contains\n#   at least all possible CPUs in which the mm is lazy.\n# - It must meet the requirements for MMU_LAZY_TLB_REFCOUNT=n (see above).\nconfig MMU_LAZY_TLB_SHOOTDOWN\n\tbool\n\nconfig ARCH_HAVE_NMI_SAFE_CMPXCHG\n\tbool\n\nconfig ARCH_HAS_NMI_SAFE_THIS_CPU_OPS\n\tbool\n\nconfig HAVE_ALIGNED_STRUCT_PAGE\n\tbool\n\thelp\n\t  This makes sure that struct pages are double word aligned and that\n\t  e.g. the SLUB allocator can perform double word atomic operations\n\t  on a struct page for better performance. However selecting this\n\t  might increase the size of a struct page by a word.\n\nconfig HAVE_CMPXCHG_LOCAL\n\tbool\n\nconfig HAVE_CMPXCHG_DOUBLE\n\tbool\n\nconfig ARCH_WEAK_RELEASE_ACQUIRE\n\tbool\n\nconfig ARCH_WANT_IPC_PARSE_VERSION\n\tbool\n\nconfig ARCH_WANT_COMPAT_IPC_PARSE_VERSION\n\tbool\n\nconfig ARCH_WANT_OLD_COMPAT_IPC\n\tselect ARCH_WANT_COMPAT_IPC_PARSE_VERSION\n\tbool\n\nconfig HAVE_ARCH_SECCOMP\n\tbool\n\thelp\n\t  An arch should select this symbol to support seccomp mode 1 (the fixed\n\t  syscall policy), and must provide an overrides for __NR_seccomp_sigreturn,\n\t  and compat syscalls if the asm-generic/seccomp.h defaults need adjustment:\n\t  - __NR_seccomp_read_32\n\t  - __NR_seccomp_write_32\n\t  - __NR_seccomp_exit_32\n\t  - __NR_seccomp_sigreturn_32\n\nconfig HAVE_ARCH_SECCOMP_FILTER\n\tbool\n\tselect HAVE_ARCH_SECCOMP\n\thelp\n\t  An arch should select this symbol if it provides all of these things:\n\t  - all the requirements for HAVE_ARCH_SECCOMP\n\t  - syscall_get_arch()\n\t  - syscall_get_arguments()\n\t  - syscall_rollback()\n\t  - syscall_set_return_value()\n\t  - SIGSYS siginfo_t support\n\t  - secure_computing is called from a ptrace_event()-safe context\n\t  - secure_computing return value is checked and a return value of -1\n\t    results in the system call being skipped immediately.\n\t  - seccomp syscall wired up\n\t  - if !HAVE_SPARSE_SYSCALL_NR, have SECCOMP_ARCH_NATIVE,\n\t    SECCOMP_ARCH_NATIVE_NR, SECCOMP_ARCH_NATIVE_NAME defined. If\n\t    COMPAT is supported, have the SECCOMP_ARCH_COMPAT* defines too.\n\nconfig SECCOMP\n\tprompt \"Enable seccomp to safely execute untrusted bytecode\"\n\tdef_bool y\n\tdepends on HAVE_ARCH_SECCOMP\n\thelp\n\t  This kernel feature is useful for number crunching applications\n\t  that may need to handle untrusted bytecode during their\n\t  execution. By using pipes or other transports made available\n\t  to the process as file descriptors supporting the read/write\n\t  syscalls, it's possible to isolate those applications in their\n\t  own address space using seccomp. Once seccomp is enabled via\n\t  prctl(PR_SET_SECCOMP) or the seccomp() syscall, it cannot be\n\t  disabled and the task is only allowed to execute a few safe\n\t  syscalls defined by each seccomp mode.\n\n\t  If unsure, say Y.\n\nconfig SECCOMP_FILTER\n\tdef_bool y\n\tdepends on HAVE_ARCH_SECCOMP_FILTER && SECCOMP && NET\n\thelp\n\t  Enable tasks to build secure computing environments defined\n\t  in terms of Berkeley Packet Filter programs which implement\n\t  task-defined system call filtering polices.\n\n\t  See Documentation/userspace-api/seccomp_filter.rst for details.\n\nconfig SECCOMP_CACHE_DEBUG\n\tbool \"Show seccomp filter cache status in /proc/pid/seccomp_cache\"\n\tdepends on SECCOMP_FILTER && !HAVE_SPARSE_SYSCALL_NR\n\tdepends on PROC_FS\n\thelp\n\t  This enables the /proc/pid/seccomp_cache interface to monitor\n\t  seccomp cache data. The file format is subject to change. Reading\n\t  the file requires CAP_SYS_ADMIN.\n\n\t  This option is for debugging only. Enabling presents the risk that\n\t  an adversary may be able to infer the seccomp filter logic.\n\n\t  If unsure, say N.\n\nconfig HAVE_ARCH_STACKLEAK\n\tbool\n\thelp\n\t  An architecture should select this if it has the code which\n\t  fills the used part of the kernel stack with the STACKLEAK_POISON\n\t  value before returning from system calls.\n\nconfig HAVE_STACKPROTECTOR\n\tbool\n\thelp\n\t  An arch should select this symbol if:\n\t  - it has implemented a stack canary (e.g. __stack_chk_guard)\n\nconfig STACKPROTECTOR\n\tbool \"Stack Protector buffer overflow detection\"\n\tdepends on HAVE_STACKPROTECTOR\n\tdepends on $(cc-option,-fstack-protector)\n\tdefault y\n\thelp\n\t  This option turns on the \"stack-protector\" GCC feature. This\n\t  feature puts, at the beginning of functions, a canary value on\n\t  the stack just before the return address, and validates\n\t  the value just before actually returning.  Stack based buffer\n\t  overflows (that need to overwrite this return address) now also\n\t  overwrite the canary, which gets detected and the attack is then\n\t  neutralized via a kernel panic.\n\n\t  Functions will have the stack-protector canary logic added if they\n\t  have an 8-byte or larger character array on the stack.\n\n\t  This feature requires gcc version 4.2 or above, or a distribution\n\t  gcc with the feature backported (\"-fstack-protector\").\n\n\t  On an x86 \"defconfig\" build, this feature adds canary checks to\n\t  about 3% of all kernel functions, which increases kernel code size\n\t  by about 0.3%.\n\nconfig STACKPROTECTOR_STRONG\n\tbool \"Strong Stack Protector\"\n\tdepends on STACKPROTECTOR\n\tdepends on $(cc-option,-fstack-protector-strong)\n\tdefault y\n\thelp\n\t  Functions will have the stack-protector canary logic added in any\n\t  of the following conditions:\n\n\t  - local variable's address used as part of the right hand side of an\n\t    assignment or function argument\n\t  - local variable is an array (or union containing an array),\n\t    regardless of array type or length\n\t  - uses register local variables\n\n\t  This feature requires gcc version 4.9 or above, or a distribution\n\t  gcc with the feature backported (\"-fstack-protector-strong\").\n\n\t  On an x86 \"defconfig\" build, this feature adds canary checks to\n\t  about 20% of all kernel functions, which increases the kernel code\n\t  size by about 2%.\n\nconfig ARCH_SUPPORTS_SHADOW_CALL_STACK\n\tbool\n\thelp\n\t  An architecture should select this if it supports the compiler's\n\t  Shadow Call Stack and implements runtime support for shadow stack\n\t  switching.\n\nconfig SHADOW_CALL_STACK\n\tbool \"Shadow Call Stack\"\n\tdepends on ARCH_SUPPORTS_SHADOW_CALL_STACK\n\tdepends on DYNAMIC_FTRACE_WITH_ARGS || DYNAMIC_FTRACE_WITH_REGS || !FUNCTION_GRAPH_TRACER\n\thelp\n\t  This option enables the compiler's Shadow Call Stack, which\n\t  uses a shadow stack to protect function return addresses from\n\t  being overwritten by an attacker. More information can be found\n\t  in the compiler's documentation:\n\n\t  - Clang: https://clang.llvm.org/docs/ShadowCallStack.html\n\t  - GCC: https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html#Instrumentation-Options\n\n\t  Note that security guarantees in the kernel differ from the\n\t  ones documented for user space. The kernel must store addresses\n\t  of shadow stacks in memory, which means an attacker capable of\n\t  reading and writing arbitrary memory may be able to locate them\n\t  and hijack control flow by modifying the stacks.\n\nconfig DYNAMIC_SCS\n\tbool\n\thelp\n\t  Set by the arch code if it relies on code patching to insert the\n\t  shadow call stack push and pop instructions rather than on the\n\t  compiler.\n\nconfig LTO\n\tbool\n\thelp\n\t  Selected if the kernel will be built using the compiler's LTO feature.\n\nconfig LTO_CLANG\n\tbool\n\tselect LTO\n\thelp\n\t  Selected if the kernel will be built using Clang's LTO feature.\n\nconfig ARCH_SUPPORTS_LTO_CLANG\n\tbool\n\thelp\n\t  An architecture should select this option if it supports:\n\t  - compiling with Clang,\n\t  - compiling inline assembly with Clang's integrated assembler,\n\t  - and linking with LLD.\n\nconfig ARCH_SUPPORTS_LTO_CLANG_THIN\n\tbool\n\thelp\n\t  An architecture should select this option if it can support Clang's\n\t  ThinLTO mode.\n\nconfig HAS_LTO_CLANG\n\tdef_bool y\n\tdepends on CC_IS_CLANG && LD_IS_LLD && AS_IS_LLVM\n\tdepends on $(success,$(NM) --help | head -n 1 | grep -qi llvm)\n\tdepends on $(success,$(AR) --help | head -n 1 | grep -qi llvm)\n\tdepends on ARCH_SUPPORTS_LTO_CLANG\n\tdepends on !FTRACE_MCOUNT_USE_RECORDMCOUNT\n\t# https://github.com/ClangBuiltLinux/linux/issues/1721\n\tdepends on (!KASAN || KASAN_HW_TAGS || CLANG_VERSION >= 170000) || !DEBUG_INFO\n\tdepends on (!KCOV || CLANG_VERSION >= 170000) || !DEBUG_INFO\n\tdepends on !GCOV_KERNEL\n\thelp\n\t  The compiler and Kconfig options support building with Clang's\n\t  LTO.\n\nchoice\n\tprompt \"Link Time Optimization (LTO)\"\n\tdefault LTO_NONE\n\thelp\n\t  This option enables Link Time Optimization (LTO), which allows the\n\t  compiler to optimize binaries globally.\n\n\t  If unsure, select LTO_NONE. Note that LTO is very resource-intensive\n\t  so it's disabled by default.\n\nconfig LTO_NONE\n\tbool \"None\"\n\thelp\n\t  Build the kernel normally, without Link Time Optimization (LTO).\n\nconfig LTO_CLANG_FULL\n\tbool \"Clang Full LTO (EXPERIMENTAL)\"\n\tdepends on HAS_LTO_CLANG\n\tdepends on !COMPILE_TEST\n\tselect LTO_CLANG\n\thelp\n\t  This option enables Clang's full Link Time Optimization (LTO), which\n\t  allows the compiler to optimize the kernel globally. If you enable\n\t  this option, the compiler generates LLVM bitcode instead of ELF\n\t  object files, and the actual compilation from bitcode happens at\n\t  the LTO link step, which may take several minutes depending on the\n\t  kernel configuration. More information can be found from LLVM's\n\t  documentation:\n\n\t    https://llvm.org/docs/LinkTimeOptimization.html\n\n\t  During link time, this option can use a large amount of RAM, and\n\t  may take much longer than the ThinLTO option.\n\nconfig LTO_CLANG_THIN\n\tbool \"Clang ThinLTO (EXPERIMENTAL)\"\n\tdepends on HAS_LTO_CLANG && ARCH_SUPPORTS_LTO_CLANG_THIN\n\tselect LTO_CLANG\n\thelp\n\t  This option enables Clang's ThinLTO, which allows for parallel\n\t  optimization and faster incremental compiles compared to the\n\t  CONFIG_LTO_CLANG_FULL option. More information can be found\n\t  from Clang's documentation:\n\n\t    https://clang.llvm.org/docs/ThinLTO.html\n\n\t  If unsure, say Y.\nendchoice\n\nconfig ARCH_SUPPORTS_CFI_CLANG\n\tbool\n\thelp\n\t  An architecture should select this option if it can support Clang's\n\t  Control-Flow Integrity (CFI) checking.\n\nconfig ARCH_USES_CFI_TRAPS\n\tbool\n\nconfig CFI_CLANG\n\tbool \"Use Clang's Control Flow Integrity (CFI)\"\n\tdepends on ARCH_SUPPORTS_CFI_CLANG\n\tdepends on $(cc-option,-fsanitize=kcfi)\n\thelp\n\t  This option enables Clang\u2019s forward-edge Control Flow Integrity\n\t  (CFI) checking, where the compiler injects a runtime check to each\n\t  indirect function call to ensure the target is a valid function with\n\t  the correct static type. This restricts possible call targets and\n\t  makes it more difficult for an attacker to exploit bugs that allow\n\t  the modification of stored function pointers. More information can be\n\t  found from Clang's documentation:\n\n\t    https://clang.llvm.org/docs/ControlFlowIntegrity.html\n\nconfig CFI_PERMISSIVE\n\tbool \"Use CFI in permissive mode\"\n\tdepends on CFI_CLANG\n\thelp\n\t  When selected, Control Flow Integrity (CFI) violations result in a\n\t  warning instead of a kernel panic. This option should only be used\n\t  for finding indirect call type mismatches during development.\n\n\t  If unsure, say N.\n\nconfig HAVE_ARCH_WITHIN_STACK_FRAMES\n\tbool\n\thelp\n\t  An architecture should select this if it can walk the kernel stack\n\t  frames to determine if an object is part of either the arguments\n\t  or local variables (i.e. that it excludes saved return addresses,\n\t  and similar) by implementing an inline arch_within_stack_frames(),\n\t  which is used by CONFIG_HARDENED_USERCOPY.\n\nconfig HAVE_CONTEXT_TRACKING_USER\n\tbool\n\thelp\n\t  Provide kernel/user boundaries probes necessary for subsystems\n\t  that need it, such as userspace RCU extended quiescent state.\n\t  Syscalls need to be wrapped inside user_exit()-user_enter(), either\n\t  optimized behind static key or through the slow path using TIF_NOHZ\n\t  flag. Exceptions handlers must be wrapped as well. Irqs are already\n\t  protected inside ct_irq_enter/ct_irq_exit() but preemption or signal\n\t  handling on irq exit still need to be protected.\n\nconfig HAVE_CONTEXT_TRACKING_USER_OFFSTACK\n\tbool\n\thelp\n\t  Architecture neither relies on exception_enter()/exception_exit()\n\t  nor on schedule_user(). Also preempt_schedule_notrace() and\n\t  preempt_schedule_irq() can't be called in a preemptible section\n\t  while context tracking is CONTEXT_USER. This feature reflects a sane\n\t  entry implementation where the following requirements are met on\n\t  critical entry code, ie: before user_exit() or after user_enter():\n\n\t  - Critical entry code isn't preemptible (or better yet:\n\t    not interruptible).\n\t  - No use of RCU read side critical sections, unless ct_nmi_enter()\n\t    got called.\n\t  - No use of instrumentation, unless instrumentation_begin() got\n\t    called.\n\nconfig HAVE_TIF_NOHZ\n\tbool\n\thelp\n\t  Arch relies on TIF_NOHZ and syscall slow path to implement context\n\t  tracking calls to user_enter()/user_exit().\n\nconfig HAVE_VIRT_CPU_ACCOUNTING\n\tbool\n\nconfig HAVE_VIRT_CPU_ACCOUNTING_IDLE\n\tbool\n\thelp\n\t  Architecture has its own way to account idle CPU time and therefore\n\t  doesn't implement vtime_account_idle().\n\nconfig ARCH_HAS_SCALED_CPUTIME\n\tbool\n\nconfig HAVE_VIRT_CPU_ACCOUNTING_GEN\n\tbool\n\tdefault y if 64BIT\n\thelp\n\t  With VIRT_CPU_ACCOUNTING_GEN, cputime_t becomes 64-bit.\n\t  Before enabling this option, arch code must be audited\n\t  to ensure there are no races in concurrent read/write of\n\t  cputime_t. For example, reading/writing 64-bit cputime_t on\n\t  some 32-bit arches may require multiple accesses, so proper\n\t  locking is needed to protect against concurrent accesses.\n\nconfig HAVE_IRQ_TIME_ACCOUNTING\n\tbool\n\thelp\n\t  Archs need to ensure they use a high enough resolution clock to\n\t  support irq time accounting and then call enable_sched_clock_irqtime().\n\nconfig HAVE_MOVE_PUD\n\tbool\n\thelp\n\t  Architectures that select this are able to move page tables at the\n\t  PUD level. If there are only 3 page table levels, the move effectively\n\t  happens at the PGD level.\n\nconfig HAVE_MOVE_PMD\n\tbool\n\thelp\n\t  Archs that select this are able to move page tables at the PMD level.\n\nconfig HAVE_ARCH_TRANSPARENT_HUGEPAGE\n\tbool\n\nconfig HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\n\tbool\n\nconfig HAVE_ARCH_HUGE_VMAP\n\tbool\n\n#\n#  Archs that select this would be capable of PMD-sized vmaps (i.e.,\n#  arch_vmap_pmd_supported() returns true). The VM_ALLOW_HUGE_VMAP flag\n#  must be used to enable allocations to use hugepages.\n#\nconfig HAVE_ARCH_HUGE_VMALLOC\n\tdepends on HAVE_ARCH_HUGE_VMAP\n\tbool\n\nconfig ARCH_WANT_HUGE_PMD_SHARE\n\tbool\n\n# Archs that want to use pmd_mkwrite on kernel memory need it defined even\n# if there are no userspace memory management features that use it\nconfig ARCH_WANT_KERNEL_PMD_MKWRITE\n\tbool\n\nconfig ARCH_WANT_PMD_MKWRITE\n\tdef_bool TRANSPARENT_HUGEPAGE || ARCH_WANT_KERNEL_PMD_MKWRITE\n\nconfig HAVE_ARCH_SOFT_DIRTY\n\tbool\n\nconfig HAVE_MOD_ARCH_SPECIFIC\n\tbool\n\thelp\n\t  The arch uses struct mod_arch_specific to store data.  Many arches\n\t  just need a simple module loader without arch specific data - those\n\t  should not enable this.\n\nconfig MODULES_USE_ELF_RELA\n\tbool\n\thelp\n\t  Modules only use ELF RELA relocations.  Modules with ELF REL\n\t  relocations will give an error.\n\nconfig MODULES_USE_ELF_REL\n\tbool\n\thelp\n\t  Modules only use ELF REL relocations.  Modules with ELF RELA\n\t  relocations will give an error.\n\nconfig ARCH_WANTS_MODULES_DATA_IN_VMALLOC\n\tbool\n\thelp\n\t  For architectures like powerpc/32 which have constraints on module\n\t  allocation and need to allocate module data outside of module area.\n\nconfig HAVE_IRQ_EXIT_ON_IRQ_STACK\n\tbool\n\thelp\n\t  Architecture doesn't only execute the irq handler on the irq stack\n\t  but also irq_exit(). This way we can process softirqs on this irq\n\t  stack instead of switching to a new one when we call __do_softirq()\n\t  in the end of an hardirq.\n\t  This spares a stack switch and improves cache usage on softirq\n\t  processing.\n\nconfig HAVE_SOFTIRQ_ON_OWN_STACK\n\tbool\n\thelp\n\t  Architecture provides a function to run __do_softirq() on a\n\t  separate stack.\n\nconfig SOFTIRQ_ON_OWN_STACK\n\tdef_bool HAVE_SOFTIRQ_ON_OWN_STACK && !PREEMPT_RT\n\nconfig ALTERNATE_USER_ADDRESS_SPACE\n\tbool\n\thelp\n\t  Architectures set this when the CPU uses separate address\n\t  spaces for kernel and user space pointers. In this case, the\n\t  access_ok() check on a __user pointer is skipped.\n\nconfig PGTABLE_LEVELS\n\tint\n\tdefault 2\n\nconfig ARCH_HAS_ELF_RANDOMIZE\n\tbool\n\thelp\n\t  An architecture supports choosing randomized locations for\n\t  stack, mmap, brk, and ET_DYN. Defined functions:\n\t  - arch_mmap_rnd()\n\t  - arch_randomize_brk()\n\nconfig HAVE_ARCH_MMAP_RND_BITS\n\tbool\n\thelp\n\t  An arch should select this symbol if it supports setting a variable\n\t  number of bits for use in establishing the base address for mmap\n\t  allocations, has MMU enabled and provides values for both:\n\t  - ARCH_MMAP_RND_BITS_MIN\n\t  - ARCH_MMAP_RND_BITS_MAX\n\nconfig HAVE_EXIT_THREAD\n\tbool\n\thelp\n\t  An architecture implements exit_thread.\n\nconfig ARCH_MMAP_RND_BITS_MIN\n\tint\n\nconfig ARCH_MMAP_RND_BITS_MAX\n\tint\n\nconfig ARCH_MMAP_RND_BITS_DEFAULT\n\tint\n\nconfig ARCH_MMAP_RND_BITS\n\tint \"Number of bits to use for ASLR of mmap base address\" if EXPERT\n\trange ARCH_MMAP_RND_BITS_MIN ARCH_MMAP_RND_BITS_MAX\n\tdefault ARCH_MMAP_RND_BITS_DEFAULT if ARCH_MMAP_RND_BITS_DEFAULT\n\tdefault ARCH_MMAP_RND_BITS_MIN\n\tdepends on HAVE_ARCH_MMAP_RND_BITS\n\thelp\n\t  This value can be used to select the number of bits to use to\n\t  determine the random offset to the base address of vma regions\n\t  resulting from mmap allocations. This value will be bounded\n\t  by the architecture's minimum and maximum supported values.\n\n\t  This value can be changed after boot using the\n\t  /proc/sys/vm/mmap_rnd_bits tunable\n\nconfig HAVE_ARCH_MMAP_RND_COMPAT_BITS\n\tbool\n\thelp\n\t  An arch should select this symbol if it supports running applications\n\t  in compatibility mode, supports setting a variable number of bits for\n\t  use in establishing the base address for mmap allocations, has MMU\n\t  enabled and provides values for both:\n\t  - ARCH_MMAP_RND_COMPAT_BITS_MIN\n\t  - ARCH_MMAP_RND_COMPAT_BITS_MAX\n\nconfig ARCH_MMAP_RND_COMPAT_BITS_MIN\n\tint\n\nconfig ARCH_MMAP_RND_COMPAT_BITS_MAX\n\tint\n\nconfig ARCH_MMAP_RND_COMPAT_BITS_DEFAULT\n\tint\n\nconfig ARCH_MMAP_RND_COMPAT_BITS\n\tint \"Number of bits to use for ASLR of mmap base address for compatible applications\" if EXPERT\n\trange ARCH_MMAP_RND_COMPAT_BITS_MIN ARCH_MMAP_RND_COMPAT_BITS_MAX\n\tdefault ARCH_MMAP_RND_COMPAT_BITS_DEFAULT if ARCH_MMAP_RND_COMPAT_BITS_DEFAULT\n\tdefault ARCH_MMAP_RND_COMPAT_BITS_MIN\n\tdepends on HAVE_ARCH_MMAP_RND_COMPAT_BITS\n\thelp\n\t  This value can be used to select the number of bits to use to\n\t  determine the random offset to the base address of vma regions\n\t  resulting from mmap allocations for compatible applications This\n\t  value will be bounded by the architecture's minimum and maximum\n\t  supported values.\n\n\t  This value can be changed after boot using the\n\t  /proc/sys/vm/mmap_rnd_compat_bits tunable\n\nconfig HAVE_ARCH_COMPAT_MMAP_BASES\n\tbool\n\thelp\n\t  This allows 64bit applications to invoke 32-bit mmap() syscall\n\t  and vice-versa 32-bit applications to call 64-bit mmap().\n\t  Required for applications doing different bitness syscalls.\n\nconfig PAGE_SIZE_LESS_THAN_64KB\n\tdef_bool y\n\tdepends on !ARM64_64K_PAGES\n\tdepends on !IA64_PAGE_SIZE_64KB\n\tdepends on !PAGE_SIZE_64KB\n\tdepends on !PARISC_PAGE_SIZE_64KB\n\tdepends on PAGE_SIZE_LESS_THAN_256KB\n\nconfig PAGE_SIZE_LESS_THAN_256KB\n\tdef_bool y\n\tdepends on !PAGE_SIZE_256KB\n\n# This allows to use a set of generic functions to determine mmap base\n# address by giving priority to top-down scheme only if the process\n# is not in legacy mode (compat task, unlimited stack size or\n# sysctl_legacy_va_layout).\n# Architecture that selects this option can provide its own version of:\n# - STACK_RND_MASK\nconfig ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT\n\tbool\n\tdepends on MMU\n\tselect ARCH_HAS_ELF_RANDOMIZE\n\nconfig HAVE_OBJTOOL\n\tbool\n\nconfig HAVE_JUMP_LABEL_HACK\n\tbool\n\nconfig HAVE_NOINSTR_HACK\n\tbool\n\nconfig HAVE_NOINSTR_VALIDATION\n\tbool\n\nconfig HAVE_UACCESS_VALIDATION\n\tbool\n\tselect OBJTOOL\n\nconfig HAVE_STACK_VALIDATION\n\tbool\n\thelp\n\t  Architecture supports objtool compile-time frame pointer rule\n\t  validation.\n\nconfig HAVE_RELIABLE_STACKTRACE\n\tbool\n\thelp\n\t  Architecture has either save_stack_trace_tsk_reliable() or\n\t  arch_stack_walk_reliable() function which only returns a stack trace\n\t  if it can guarantee the trace is reliable.\n\nconfig HAVE_ARCH_HASH\n\tbool\n\tdefault n\n\thelp\n\t  If this is set, the architecture provides an <asm/hash.h>\n\t  file which provides platform-specific implementations of some\n\t  functions in <linux/hash.h> or fs/namei.c.\n\nconfig HAVE_ARCH_NVRAM_OPS\n\tbool\n\nconfig ISA_BUS_API\n\tdef_bool ISA\n\n#\n# ABI hall of shame\n#\nconfig CLONE_BACKWARDS\n\tbool\n\thelp\n\t  Architecture has tls passed as the 4th argument of clone(2),\n\t  not the 5th one.\n\nconfig CLONE_BACKWARDS2\n\tbool\n\thelp\n\t  Architecture has the first two arguments of clone(2) swapped.\n\nconfig CLONE_BACKWARDS3\n\tbool\n\thelp\n\t  Architecture has tls passed as the 3rd argument of clone(2),\n\t  not the 5th one.\n\nconfig ODD_RT_SIGACTION\n\tbool\n\thelp\n\t  Architecture has unusual rt_sigaction(2) arguments\n\nconfig OLD_SIGSUSPEND\n\tbool\n\thelp\n\t  Architecture has old sigsuspend(2) syscall, of one-argument variety\n\nconfig OLD_SIGSUSPEND3\n\tbool\n\thelp\n\t  Even weirder antique ABI - three-argument sigsuspend(2)\n\nconfig OLD_SIGACTION\n\tbool\n\thelp\n\t  Architecture has old sigaction(2) syscall.  Nope, not the same\n\t  as OLD_SIGSUSPEND | OLD_SIGSUSPEND3 - alpha has sigsuspend(2),\n\t  but fairly different variant of sigaction(2), thanks to OSF/1\n\t  compatibility...\n\nconfig COMPAT_OLD_SIGACTION\n\tbool\n\nconfig COMPAT_32BIT_TIME\n\tbool \"Provide system calls for 32-bit time_t\"\n\tdefault !64BIT || COMPAT\n\thelp\n\t  This enables 32 bit time_t support in addition to 64 bit time_t support.\n\t  This is relevant on all 32-bit architectures, and 64-bit architectures\n\t  as part of compat syscall handling.\n\nconfig ARCH_NO_PREEMPT\n\tbool\n\nconfig ARCH_SUPPORTS_RT\n\tbool\n\nconfig CPU_NO_EFFICIENT_FFS\n\tdef_bool n\n\nconfig HAVE_ARCH_VMAP_STACK\n\tdef_bool n\n\thelp\n\t  An arch should select this symbol if it can support kernel stacks\n\t  in vmalloc space.  This means:\n\n\t  - vmalloc space must be large enough to hold many kernel stacks.\n\t    This may rule out many 32-bit architectures.\n\n\t  - Stacks in vmalloc space need to work reliably.  For example, if\n\t    vmap page tables are created on demand, either this mechanism\n\t    needs to work while the stack points to a virtual address with\n\t    unpopulated page tables or arch code (switch_to() and switch_mm(),\n\t    most likely) needs to ensure that the stack's page table entries\n\t    are populated before running on a possibly unpopulated stack.\n\n\t  - If the stack overflows into a guard page, something reasonable\n\t    should happen.  The definition of \"reasonable\" is flexible, but\n\t    instantly rebooting without logging anything would be unfriendly.\n\nconfig VMAP_STACK\n\tdefault y\n\tbool \"Use a virtually-mapped stack\"\n\tdepends on HAVE_ARCH_VMAP_STACK\n\tdepends on !KASAN || KASAN_HW_TAGS || KASAN_VMALLOC\n\thelp\n\t  Enable this if you want the use virtually-mapped kernel stacks\n\t  with guard pages.  This causes kernel stack overflows to be\n\t  caught immediately rather than causing difficult-to-diagnose\n\t  corruption.\n\n\t  To use this with software KASAN modes, the architecture must support\n\t  backing virtual mappings with real shadow memory, and KASAN_VMALLOC\n\t  must be enabled.\n\nconfig HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET\n\tdef_bool n\n\thelp\n\t  An arch should select this symbol if it can support kernel stack\n\t  offset randomization with calls to add_random_kstack_offset()\n\t  during syscall entry and choose_random_kstack_offset() during\n\t  syscall exit. Careful removal of -fstack-protector-strong and\n\t  -fstack-protector should also be applied to the entry code and\n\t  closely examined, as the artificial stack bump looks like an array\n\t  to the compiler, so it will attempt to add canary checks regardless\n\t  of the static branch state.\n\nconfig RANDOMIZE_KSTACK_OFFSET\n\tbool \"Support for randomizing kernel stack offset on syscall entry\" if EXPERT\n\tdefault y\n\tdepends on HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET\n\tdepends on INIT_STACK_NONE || !CC_IS_CLANG || CLANG_VERSION >= 140000\n\thelp\n\t  The kernel stack offset can be randomized (after pt_regs) by\n\t  roughly 5 bits of entropy, frustrating memory corruption\n\t  attacks that depend on stack address determinism or\n\t  cross-syscall address exposures.\n\n\t  The feature is controlled via the \"randomize_kstack_offset=on/off\"\n\t  kernel boot param, and if turned off has zero overhead due to its use\n\t  of static branches (see JUMP_LABEL).\n\n\t  If unsure, say Y.\n\nconfig RANDOMIZE_KSTACK_OFFSET_DEFAULT\n\tbool \"Default state of kernel stack offset randomization\"\n\tdepends on RANDOMIZE_KSTACK_OFFSET\n\thelp\n\t  Kernel stack offset randomization is controlled by kernel boot param\n\t  \"randomize_kstack_offset=on/off\", and this config chooses the default\n\t  boot state.\n\nconfig ARCH_OPTIONAL_KERNEL_RWX\n\tdef_bool n\n\nconfig ARCH_OPTIONAL_KERNEL_RWX_DEFAULT\n\tdef_bool n\n\nconfig ARCH_HAS_STRICT_KERNEL_RWX\n\tdef_bool n\n\nconfig STRICT_KERNEL_RWX\n\tbool \"Make kernel text and rodata read-only\" if ARCH_OPTIONAL_KERNEL_RWX\n\tdepends on ARCH_HAS_STRICT_KERNEL_RWX\n\tdefault !ARCH_OPTIONAL_KERNEL_RWX || ARCH_OPTIONAL_KERNEL_RWX_DEFAULT\n\thelp\n\t  If this is set, kernel text and rodata memory will be made read-only,\n\t  and non-text memory will be made non-executable. This provides\n\t  protection against certain security exploits (e.g. executing the heap\n\t  or modifying text)\n\n\t  These features are considered standard security practice these days.\n\t  You should say Y here in almost all cases.\n\nconfig ARCH_HAS_STRICT_MODULE_RWX\n\tdef_bool n\n\nconfig STRICT_MODULE_RWX\n\tbool \"Set loadable kernel module data as NX and text as RO\" if ARCH_OPTIONAL_KERNEL_RWX\n\tdepends on ARCH_HAS_STRICT_MODULE_RWX && MODULES\n\tdefault !ARCH_OPTIONAL_KERNEL_RWX || ARCH_OPTIONAL_KERNEL_RWX_DEFAULT\n\thelp\n\t  If this is set, module text and rodata memory will be made read-only,\n\t  and non-text memory will be made non-executable. This provides\n\t  protection against certain security exploits (e.g. writing to text)\n\n# select if the architecture provides an asm/dma-direct.h header\nconfig ARCH_HAS_PHYS_TO_DMA\n\tbool\n\nconfig HAVE_ARCH_COMPILER_H\n\tbool\n\thelp\n\t  An architecture can select this if it provides an\n\t  asm/compiler.h header that should be included after\n\t  linux/compiler-*.h in order to override macro definitions that those\n\t  headers generally provide.\n\nconfig HAVE_ARCH_PREL32_RELOCATIONS\n\tbool\n\thelp\n\t  May be selected by an architecture if it supports place-relative\n\t  32-bit relocations, both in the toolchain and in the module loader,\n\t  in which case relative references can be used in special sections\n\t  for PCI fixup, initcalls etc which are only half the size on 64 bit\n\t  architectures, and don't require runtime relocation on relocatable\n\t  kernels.\n\nconfig ARCH_USE_MEMREMAP_PROT\n\tbool\n\nconfig LOCK_EVENT_COUNTS\n\tbool \"Locking event counts collection\"\n\tdepends on DEBUG_FS\n\thelp\n\t  Enable light-weight counting of various locking related events\n\t  in the system with minimal performance impact. This reduces\n\t  the chance of application behavior change because of timing\n\t  differences. The counts are reported via debugfs.\n\n# Select if the architecture has support for applying RELR relocations.\nconfig ARCH_HAS_RELR\n\tbool\n\nconfig RELR\n\tbool \"Use RELR relocation packing\"\n\tdepends on ARCH_HAS_RELR && TOOLS_SUPPORT_RELR\n\tdefault y\n\thelp\n\t  Store the kernel's dynamic relocations in the RELR relocation packing\n\t  format. Requires a compatible linker (LLD supports this feature), as\n\t  well as compatible NM and OBJCOPY utilities (llvm-nm and llvm-objcopy\n\t  are compatible).\n\nconfig ARCH_HAS_MEM_ENCRYPT\n\tbool\n\nconfig ARCH_HAS_CC_PLATFORM\n\tbool\n\nconfig HAVE_SPARSE_SYSCALL_NR\n\tbool\n\thelp\n\t  An architecture should select this if its syscall numbering is sparse\n\t  to save space. For example, MIPS architecture has a syscall array with\n\t  entries at 4000, 5000 and 6000 locations. This option turns on syscall\n\t  related optimizations for a given architecture.\n\nconfig ARCH_HAS_VDSO_DATA\n\tbool\n\nconfig HAVE_STATIC_CALL\n\tbool\n\nconfig HAVE_STATIC_CALL_INLINE\n\tbool\n\tdepends on HAVE_STATIC_CALL\n\tselect OBJTOOL\n\nconfig HAVE_PREEMPT_DYNAMIC\n\tbool\n\nconfig HAVE_PREEMPT_DYNAMIC_CALL\n\tbool\n\tdepends on HAVE_STATIC_CALL\n\tselect HAVE_PREEMPT_DYNAMIC\n\thelp\n\t  An architecture should select this if it can handle the preemption\n\t  model being selected at boot time using static calls.\n\n\t  Where an architecture selects HAVE_STATIC_CALL_INLINE, any call to a\n\t  preemption function will be patched directly.\n\n\t  Where an architecture does not select HAVE_STATIC_CALL_INLINE, any\n\t  call to a preemption function will go through a trampoline, and the\n\t  trampoline will be patched.\n\n\t  It is strongly advised to support inline static call to avoid any\n\t  overhead.\n\nconfig HAVE_PREEMPT_DYNAMIC_KEY\n\tbool\n\tdepends on HAVE_ARCH_JUMP_LABEL\n\tselect HAVE_PREEMPT_DYNAMIC\n\thelp\n\t  An architecture should select this if it can handle the preemption\n\t  model being selected at boot time using static keys.\n\n\t  Each preemption function will be given an early return based on a\n\t  static key. This should have slightly lower overhead than non-inline\n\t  static calls, as this effectively inlines each trampoline into the\n\t  start of its callee. This may avoid redundant work, and may\n\t  integrate better with CFI schemes.\n\n\t  This will have greater overhead than using inline static calls as\n\t  the call to the preemption function cannot be entirely elided.\n\nconfig ARCH_WANT_LD_ORPHAN_WARN\n\tbool\n\thelp\n\t  An arch should select this symbol once all linker sections are explicitly\n\t  included, size-asserted, or discarded in the linker scripts. This is\n\t  important because we never want expected sections to be placed heuristically\n\t  by the linker, since the locations of such sections can change between linker\n\t  versions.\n\nconfig HAVE_ARCH_PFN_VALID\n\tbool\n\nconfig ARCH_SUPPORTS_DEBUG_PAGEALLOC\n\tbool\n\nconfig ARCH_SUPPORTS_PAGE_TABLE_CHECK\n\tbool\n\nconfig ARCH_SPLIT_ARG64\n\tbool\n\thelp\n\t  If a 32-bit architecture requires 64-bit arguments to be split into\n\t  pairs of 32-bit arguments, select this option.\n\nconfig ARCH_HAS_ELFCORE_COMPAT\n\tbool\n\nconfig ARCH_HAS_PARANOID_L1D_FLUSH\n\tbool\n\nconfig ARCH_HAVE_TRACE_MMIO_ACCESS\n\tbool\n\nconfig DYNAMIC_SIGFRAME\n\tbool\n\n# Select, if arch has a named attribute group bound to NUMA device nodes.\nconfig HAVE_ARCH_NODE_DEV_GROUP\n\tbool\n\nconfig ARCH_HAS_NONLEAF_PMD_YOUNG\n\tbool\n\thelp\n\t  Architectures that select this option are capable of setting the\n\t  accessed bit in non-leaf PMD entries when using them as part of linear\n\t  address translations. Page table walkers that clear the accessed bit\n\t  may use this capability to reduce their search space.\n\nsource \"kernel/gcov/Kconfig\"\n\nsource \"scripts/gcc-plugins/Kconfig\"\n\nconfig FUNCTION_ALIGNMENT_4B\n\tbool\n\nconfig FUNCTION_ALIGNMENT_8B\n\tbool\n\nconfig FUNCTION_ALIGNMENT_16B\n\tbool\n\nconfig FUNCTION_ALIGNMENT_32B\n\tbool\n\nconfig FUNCTION_ALIGNMENT_64B\n\tbool\n\nconfig FUNCTION_ALIGNMENT\n\tint\n\tdefault 64 if FUNCTION_ALIGNMENT_64B\n\tdefault 32 if FUNCTION_ALIGNMENT_32B\n\tdefault 16 if FUNCTION_ALIGNMENT_16B\n\tdefault 8 if FUNCTION_ALIGNMENT_8B\n\tdefault 4 if FUNCTION_ALIGNMENT_4B\n\tdefault 0\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}