{
  "module_name": "digsig.c",
  "hash_id": "41a8ef72d5959ad87ad740eb52d3fa6ef618ee83e284b1e57dec9c64604e74ee",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/digsig.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/kernel_read_file.h>\n#include <linux/key-type.h>\n#include <linux/digsig.h>\n#include <linux/vmalloc.h>\n#include <crypto/public_key.h>\n#include <keys/system_keyring.h>\n\n#include \"integrity.h\"\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\n\nstatic const char * const keyring_name[INTEGRITY_KEYRING_MAX] = {\n#ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING\n\t\"_evm\",\n\t\"_ima\",\n#else\n\t\".evm\",\n\t\".ima\",\n#endif\n\t\".platform\",\n\t\".machine\",\n};\n\n#ifdef CONFIG_IMA_KEYRINGS_PERMIT_SIGNED_BY_BUILTIN_OR_SECONDARY\n#define restrict_link_to_ima restrict_link_by_digsig_builtin_and_secondary\n#else\n#define restrict_link_to_ima restrict_link_by_digsig_builtin\n#endif\n\nstatic struct key *integrity_keyring_from_id(const unsigned int id)\n{\n\tif (id >= INTEGRITY_KEYRING_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!keyring[id]) {\n\t\tkeyring[id] =\n\t\t\trequest_key(&key_type_keyring, keyring_name[id], NULL);\n\t\tif (IS_ERR(keyring[id])) {\n\t\t\tint err = PTR_ERR(keyring[id]);\n\t\t\tpr_err(\"no %s keyring: %d\\n\", keyring_name[id], err);\n\t\t\tkeyring[id] = NULL;\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn keyring[id];\n}\n\nint integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\n\t\t\t    const char *digest, int digestlen)\n{\n\tstruct key *keyring;\n\n\tif (siglen < 2)\n\t\treturn -EINVAL;\n\n\tkeyring = integrity_keyring_from_id(id);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tswitch (sig[1]) {\n\tcase 1:\n\t\t \n\t\treturn digsig_verify(keyring, sig + 1, siglen - 1, digest,\n\t\t\t\t     digestlen);\n\tcase 2:  \n\tcase 3:  \n\t\treturn asymmetric_verify(keyring, sig, siglen, digest,\n\t\t\t\t\t digestlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint integrity_modsig_verify(const unsigned int id, const struct modsig *modsig)\n{\n\tstruct key *keyring;\n\n\tkeyring = integrity_keyring_from_id(id);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\treturn ima_modsig_verify(keyring, modsig);\n}\n\nstatic int __init __integrity_init_keyring(const unsigned int id,\n\t\t\t\t\t   key_perm_t perm,\n\t\t\t\t\t   struct key_restriction *restriction)\n{\n\tconst struct cred *cred = current_cred();\n\tint err = 0;\n\n\tkeyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),\n\t\t\t\t    KGIDT_INIT(0), cred, perm,\n\t\t\t\t    KEY_ALLOC_NOT_IN_QUOTA, restriction, NULL);\n\tif (IS_ERR(keyring[id])) {\n\t\terr = PTR_ERR(keyring[id]);\n\t\tpr_info(\"Can't allocate %s keyring (%d)\\n\",\n\t\t\tkeyring_name[id], err);\n\t\tkeyring[id] = NULL;\n\t} else {\n\t\tif (id == INTEGRITY_KEYRING_PLATFORM)\n\t\t\tset_platform_trusted_keys(keyring[id]);\n\t\tif (id == INTEGRITY_KEYRING_MACHINE && imputed_trust_enabled())\n\t\t\tset_machine_trusted_keys(keyring[id]);\n\t\tif (id == INTEGRITY_KEYRING_IMA)\n\t\t\tload_module_cert(keyring[id]);\n\t}\n\n\treturn err;\n}\n\nint __init integrity_init_keyring(const unsigned int id)\n{\n\tstruct key_restriction *restriction;\n\tkey_perm_t perm;\n\tint ret;\n\n\tperm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW\n\t\t| KEY_USR_READ | KEY_USR_SEARCH;\n\n\tif (id == INTEGRITY_KEYRING_PLATFORM ||\n\t    (id == INTEGRITY_KEYRING_MACHINE &&\n\t    !IS_ENABLED(CONFIG_INTEGRITY_CA_MACHINE_KEYRING))) {\n\t\trestriction = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_INTEGRITY_TRUSTED_KEYRING))\n\t\treturn 0;\n\n\trestriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\tif (!restriction)\n\t\treturn -ENOMEM;\n\n\tif (id == INTEGRITY_KEYRING_MACHINE)\n\t\trestriction->check = restrict_link_by_ca;\n\telse\n\t\trestriction->check = restrict_link_to_ima;\n\n\t \n\tif (id != INTEGRITY_KEYRING_MACHINE)\n\t\tperm |= KEY_USR_WRITE;\n\nout:\n\tret = __integrity_init_keyring(id, perm, restriction);\n\tif (ret)\n\t\tkfree(restriction);\n\treturn ret;\n}\n\nstatic int __init integrity_add_key(const unsigned int id, const void *data,\n\t\t\t\t    off_t size, key_perm_t perm)\n{\n\tkey_ref_t key;\n\tint rc = 0;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1), \"asymmetric\",\n\t\t\t\t   NULL, data, size, perm,\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate %d\\n\", rc);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s'\\n\",\n\t\t\t  key_ref_to_ptr(key)->description);\n\t\tkey_ref_put(key);\n\t}\n\n\treturn rc;\n\n}\n\nint __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tvoid *data = NULL;\n\tsize_t size;\n\tint rc;\n\tkey_perm_t perm;\n\n\trc = kernel_read_file_from_path(path, 0, &data, INT_MAX, NULL,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\tsize = rc;\n\n\tperm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW | KEY_USR_READ;\n\n\tpr_info(\"Loading X.509 certificate: %s\\n\", path);\n\trc = integrity_add_key(id, (const void *)data, size, perm);\n\n\tvfree(data);\n\treturn rc;\n}\n\nint __init integrity_load_cert(const unsigned int id, const char *source,\n\t\t\t       const void *data, size_t len, key_perm_t perm)\n{\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tpr_info(\"Loading X.509 certificate: %s\\n\", source);\n\treturn integrity_add_key(id, data, len, perm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}