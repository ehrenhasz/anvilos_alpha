{
  "module_name": "digsig_asymmetric.c",
  "hash_id": "7562ff92df8d34deea0fa3c7e3566b29dc45695e5a2e5618dbb410848ebdad7e",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/digsig_asymmetric.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/ratelimit.h>\n#include <linux/key-type.h>\n#include <crypto/public_key.h>\n#include <crypto/hash_info.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n\n#include \"integrity.h\"\n\n \nstatic struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\n{\n\tstruct key *key;\n\tchar name[12];\n\n\tsprintf(name, \"id:%08x\", keyid);\n\n\tpr_debug(\"key search: \\\"%s\\\"\\n\", name);\n\n\tkey = get_ima_blacklist_keyring();\n\tif (key) {\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(key, 1),\n\t\t\t\t      &key_type_asymmetric, name, true);\n\t\tif (!IS_ERR(kref)) {\n\t\t\tpr_err(\"Key '%s' is in ima_blacklist_keyring\\n\", name);\n\t\t\treturn ERR_PTR(-EKEYREJECTED);\n\t\t}\n\t}\n\n\tif (keyring) {\n\t\t \n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t\t      &key_type_asymmetric, name, true);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_asymmetric, name, NULL);\n\t}\n\n\tif (IS_ERR(key)) {\n\t\tif (keyring)\n\t\t\tpr_err_ratelimited(\"Request for unknown key '%s' in '%s' keyring. err %ld\\n\",\n\t\t\t\t\t   name, keyring->description,\n\t\t\t\t\t   PTR_ERR(key));\n\t\telse\n\t\t\tpr_err_ratelimited(\"Request for unknown key '%s' err %ld\\n\",\n\t\t\t\t\t   name, PTR_ERR(key));\n\n\t\tswitch (PTR_ERR(key)) {\n\t\t\t \n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpr_debug(\"%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\n\treturn key;\n}\n\nint asymmetric_verify(struct key *keyring, const char *sig,\n\t\t      int siglen, const char *data, int datalen)\n{\n\tstruct public_key_signature pks;\n\tstruct signature_v2_hdr *hdr = (struct signature_v2_hdr *)sig;\n\tconst struct public_key *pk;\n\tstruct key *key;\n\tint ret;\n\n\tif (siglen <= sizeof(*hdr))\n\t\treturn -EBADMSG;\n\n\tsiglen -= sizeof(*hdr);\n\n\tif (siglen != be16_to_cpu(hdr->sig_size))\n\t\treturn -EBADMSG;\n\n\tif (hdr->hash_algo >= HASH_ALGO__LAST)\n\t\treturn -ENOPKG;\n\n\tkey = request_asymmetric_key(keyring, be32_to_cpu(hdr->keyid));\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tmemset(&pks, 0, sizeof(pks));\n\n\tpks.hash_algo = hash_algo_name[hdr->hash_algo];\n\n\tpk = asymmetric_key_public_key(key);\n\tpks.pkey_algo = pk->pkey_algo;\n\tif (!strcmp(pk->pkey_algo, \"rsa\")) {\n\t\tpks.encoding = \"pkcs1\";\n\t} else if (!strncmp(pk->pkey_algo, \"ecdsa-\", 6)) {\n\t\t \n\t\tpks.encoding = \"x962\";\n\t} else if (!strcmp(pk->pkey_algo, \"ecrdsa\") ||\n\t\t   !strcmp(pk->pkey_algo, \"sm2\")) {\n\t\tpks.encoding = \"raw\";\n\t} else {\n\t\tret = -ENOPKG;\n\t\tgoto out;\n\t}\n\n\tpks.digest = (u8 *)data;\n\tpks.digest_size = datalen;\n\tpks.s = hdr->sig;\n\tpks.s_size = siglen;\n\tret = verify_signature(key, &pks);\nout:\n\tkey_put(key);\n\tpr_debug(\"%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint integrity_kernel_module_request(char *kmod_name)\n{\n\tif (strncmp(kmod_name, \"crypto-pkcs1pad(rsa,\", 20) == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}