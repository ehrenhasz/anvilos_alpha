{
  "module_name": "ima_api.c",
  "hash_id": "92836c41954356b1b45d63b3d25076b6a71fead598f8eb66f3d0958441ce52f5",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_api.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/xattr.h>\n#include <linux/evm.h>\n#include <linux/fsverity.h>\n\n#include \"ima.h\"\n\n \nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry->digests);\n\tkfree(entry);\n}\n\n \nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry,\n\t\t\t    struct ima_template_desc *desc)\n{\n\tstruct ima_template_desc *template_desc;\n\tstruct tpm_digest *digests;\n\tint i, result = 0;\n\n\tif (desc)\n\t\ttemplate_desc = desc;\n\telse\n\t\ttemplate_desc = ima_template_desc_current();\n\n\t*entry = kzalloc(struct_size(*entry, template_data,\n\t\t\t\t     template_desc->num_fields), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tdigests = kcalloc(NR_BANKS(ima_tpm_chip) + ima_extra_slots,\n\t\t\t  sizeof(*digests), GFP_NOFS);\n\tif (!digests) {\n\t\tkfree(*entry);\n\t\t*entry = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t(*entry)->digests = digests;\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tconst struct ima_template_field *field =\n\t\t\ttemplate_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}\n\n \nint ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\n\tif (!violation) {\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}\n\n \nvoid ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause)\n{\n\tstruct ima_template_entry *entry;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_event_data event_data = { .iint = iint,\n\t\t\t\t\t     .file = file,\n\t\t\t\t\t     .filename = filename,\n\t\t\t\t\t     .violation = cause };\n\tint violation = 1;\n\tint result;\n\n\t \n\tatomic_long_inc(&ima_htable.violations);\n\n\tresult = ima_alloc_init_template(&event_data, &entry, NULL);\n\tif (result < 0) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresult = ima_store_template(entry, violation, inode,\n\t\t\t\t    filename, CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, cause, result, 0);\n}\n\n \nint ima_get_action(struct mnt_idmap *idmap, struct inode *inode,\n\t\t   const struct cred *cred, u32 secid, int mask,\n\t\t   enum ima_hooks func, int *pcr,\n\t\t   struct ima_template_desc **template_desc,\n\t\t   const char *func_data, unsigned int *allowed_algos)\n{\n\tint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;\n\n\tflags &= ima_policy_flag;\n\n\treturn ima_match_policy(idmap, inode, cred, secid, func, mask,\n\t\t\t\tflags, pcr, template_desc, func_data,\n\t\t\t\tallowed_algos);\n}\n\nstatic bool ima_get_verity_digest(struct integrity_iint_cache *iint,\n\t\t\t\t  struct ima_max_digest_data *hash)\n{\n\tenum hash_algo alg;\n\tint digest_len;\n\n\t \n\tdigest_len = fsverity_get_digest(iint->inode, hash->digest, NULL, &alg);\n\tif (digest_len == 0)\n\t\treturn false;\n\n\t \n\thash->hdr.algo = alg;\n\thash->hdr.length = digest_len;\n\treturn true;\n}\n\n \nint ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo, struct modsig *modsig)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tstruct inode *real_inode = d_real_inode(file_dentry(file));\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tstruct ima_max_digest_data hash;\n\tstruct kstat stat;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version = 0;\n\n\t \n\tif (modsig)\n\t\tima_collect_modsig(modsig, buf, size);\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t \n\tresult = vfs_getattr_nosec(&file->f_path, &stat, STATX_CHANGE_COOKIE,\n\t\t\t\t   AT_STATX_SYNC_AS_STAT);\n\tif (!result && (stat.result_mask & STATX_CHANGE_COOKIE))\n\t\ti_version = stat.change_cookie;\n\thash.hdr.algo = algo;\n\thash.hdr.length = hash_digest_size[algo];\n\n\t \n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (iint->flags & IMA_VERITY_REQUIRED) {\n\t\tif (!ima_get_verity_digest(iint, &hash)) {\n\t\t\taudit_cause = \"no-verity-digest\";\n\t\t\tresult = -ENODATA;\n\t\t}\n\t} else if (buf) {\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\t} else {\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\t}\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\tif (real_inode != inode) {\n\t\tiint->real_ino = real_inode->i_ino;\n\t\tiint->real_dev = real_inode->i_sb->s_dev;\n\t}\n\n\t \n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}\n\n \nvoid ima_store_measurement(struct integrity_iint_cache *iint,\n\t\t\t   struct file *file, const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, const struct modsig *modsig, int pcr,\n\t\t\t   struct ima_template_desc *template_desc)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"ENOMEM\";\n\tint result = -ENOMEM;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_template_entry *entry;\n\tstruct ima_event_data event_data = { .iint = iint,\n\t\t\t\t\t     .file = file,\n\t\t\t\t\t     .filename = filename,\n\t\t\t\t\t     .xattr_value = xattr_value,\n\t\t\t\t\t     .xattr_len = xattr_len,\n\t\t\t\t\t     .modsig = modsig };\n\tint violation = 0;\n\n\t \n\tif (iint->measured_pcrs & (0x1 << pcr) && !modsig)\n\t\treturn;\n\n\tresult = ima_alloc_init_template(&event_data, &entry, template_desc);\n\tif (result < 0) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t\t    op, audit_cause, result, 0);\n\t\treturn;\n\t}\n\n\tresult = ima_store_template(entry, violation, inode, filename, pcr);\n\tif ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {\n\t\tiint->flags |= IMA_MEASURED;\n\t\tiint->measured_pcrs |= (0x1 << pcr);\n\t}\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\n}\n\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename)\n{\n\tstruct audit_buffer *ab;\n\tchar *hash;\n\tconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\n\tint i;\n\n\tif (iint->flags & IMA_AUDITED)\n\t\treturn;\n\n\thash = kzalloc((iint->ima_hash->length * 2) + 1, GFP_KERNEL);\n\tif (!hash)\n\t\treturn;\n\n\tfor (i = 0; i < iint->ima_hash->length; i++)\n\t\thex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\n\thash[i * 2] = '\\0';\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_RULE);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"file=\");\n\taudit_log_untrustedstring(ab, filename);\n\taudit_log_format(ab, \" hash=\\\"%s:%s\\\"\", algo_name, hash);\n\n\taudit_log_task_info(ab);\n\taudit_log_end(ab);\n\n\tiint->flags |= IMA_AUDITED;\nout:\n\tkfree(hash);\n\treturn;\n}\n\n \nconst char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrscpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}