{
  "module_name": "ima_queue.c",
  "hash_id": "2004701f73b4c4b2e63b5dcb070b8706e3a3d8105a30d1dab981344f061cb20b",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_queue.c",
  "human_readable_source": "\n \n\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include \"ima.h\"\n\n#define AUDIT_CAUSE_LEN_MAX 32\n\n \nstatic struct tpm_digest *digests;\n\nLIST_HEAD(ima_measurements);\t \n#ifdef CONFIG_IMA_KEXEC\nstatic unsigned long binary_runtime_size;\n#else\nstatic unsigned long binary_runtime_size = ULONG_MAX;\n#endif\n\n \nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\n \nstatic DEFINE_MUTEX(ima_extend_list_mutex);\n\n \nstatic struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\n\t\t\t\t\t\t       int pcr)\n{\n\tstruct ima_queue_entry *qe, *ret = NULL;\n\tunsigned int key;\n\tint rc;\n\n\tkey = ima_hash_key(digest_value);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\n\t\trc = memcmp(qe->entry->digests[ima_hash_algo_idx].digest,\n\t\t\t    digest_value, hash_digest_size[ima_hash_algo]);\n\t\tif ((rc == 0) && (qe->entry->pcr == pcr)) {\n\t\t\tret = qe;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int get_binary_runtime_size(struct ima_template_entry *entry)\n{\n\tint size = 0;\n\n\tsize += sizeof(u32);\t \n\tsize += TPM_DIGEST_SIZE;\n\tsize += sizeof(int);\t \n\tsize += strlen(entry->template_desc->name);\n\tsize += sizeof(entry->template_data_len);\n\tsize += entry->template_data_len;\n\treturn size;\n}\n\n \nstatic int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digests[ima_hash_algo_idx].digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}\n\n \nunsigned long ima_get_binary_runtime_size(void)\n{\n\tif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\n\t\treturn ULONG_MAX;\n\telse\n\t\treturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\n}\n\nstatic int ima_pcr_extend(struct tpm_digest *digests_arg, int pcr)\n{\n\tint result = 0;\n\n\tif (!ima_tpm_chip)\n\t\treturn result;\n\n\tresult = tpm_pcr_extend(ima_tpm_chip, pcr, digests_arg);\n\tif (result != 0)\n\t\tpr_err(\"Error Communicating to TPM chip, result: %d\\n\", result);\n\treturn result;\n}\n\n \nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename)\n{\n\tu8 *digest = entry->digests[ima_hash_algo_idx].digest;\n\tstruct tpm_digest *digests_arg = entry->digests;\n\tconst char *audit_cause = \"hash_added\";\n\tchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\n\tint audit_info = 1;\n\tint result = 0, tpmresult = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tif (!violation && !IS_ENABLED(CONFIG_IMA_DISABLE_HTABLE)) {\n\t\tif (ima_lookup_digest_entry(digest, entry->pcr)) {\n\t\t\taudit_cause = \"hash_exists\";\n\t\t\tresult = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = ima_add_digest_entry(entry,\n\t\t\t\t      !IS_ENABLED(CONFIG_IMA_DISABLE_HTABLE));\n\tif (result < 0) {\n\t\taudit_cause = \"ENOMEM\";\n\t\taudit_info = 0;\n\t\tgoto out;\n\t}\n\n\tif (violation)\t\t \n\t\tdigests_arg = digests;\n\n\ttpmresult = ima_pcr_extend(digests_arg, entry->pcr);\n\tif (tpmresult != 0) {\n\t\tsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, \"TPM_error(%d)\",\n\t\t\t tpmresult);\n\t\taudit_cause = tpm_audit_cause;\n\t\taudit_info = 0;\n\t}\nout:\n\tmutex_unlock(&ima_extend_list_mutex);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, audit_cause, result, audit_info);\n\treturn result;\n}\n\nint ima_restore_measurement_entry(struct ima_template_entry *entry)\n{\n\tint result = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tresult = ima_add_digest_entry(entry, 0);\n\tmutex_unlock(&ima_extend_list_mutex);\n\treturn result;\n}\n\nint __init ima_init_digests(void)\n{\n\tu16 digest_size;\n\tu16 crypto_id;\n\tint i;\n\n\tif (!ima_tpm_chip)\n\t\treturn 0;\n\n\tdigests = kcalloc(ima_tpm_chip->nr_allocated_banks, sizeof(*digests),\n\t\t\t  GFP_NOFS);\n\tif (!digests)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ima_tpm_chip->nr_allocated_banks; i++) {\n\t\tdigests[i].alg_id = ima_tpm_chip->allocated_banks[i].alg_id;\n\t\tdigest_size = ima_tpm_chip->allocated_banks[i].digest_size;\n\t\tcrypto_id = ima_tpm_chip->allocated_banks[i].crypto_id;\n\n\t\t \n\t\tif (crypto_id == HASH_ALGO__LAST)\n\t\t\tdigest_size = SHA1_DIGEST_SIZE;\n\n\t\tmemset(digests[i].digest, 0xff, digest_size);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}