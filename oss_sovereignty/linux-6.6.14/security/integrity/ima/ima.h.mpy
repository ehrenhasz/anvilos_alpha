{
  "module_name": "ima.h",
  "hash_id": "1afe973e10f19ffdae1b33b171086e352f958b9740d57a0a91db9ea996e2b0fe",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_IMA_H\n#define __LINUX_IMA_H\n\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/hash.h>\n#include <linux/tpm.h>\n#include <linux/audit.h>\n#include <crypto/hash_info.h>\n\n#include \"../integrity.h\"\n\nenum ima_show_type { IMA_SHOW_BINARY, IMA_SHOW_BINARY_NO_FIELD_LEN,\n\t\t     IMA_SHOW_BINARY_OLD_STRING_FMT, IMA_SHOW_ASCII };\nenum tpm_pcrs { TPM_PCR0 = 0, TPM_PCR8 = 8, TPM_PCR10 = 10 };\n\n \n#define IMA_DIGEST_SIZE\t\tSHA1_DIGEST_SIZE\n#define IMA_EVENT_NAME_LEN_MAX\t255\n\n#define IMA_HASH_BITS 10\n#define IMA_MEASURE_HTABLE_SIZE (1 << IMA_HASH_BITS)\n\n#define IMA_TEMPLATE_FIELD_ID_MAX_LEN\t16\n#define IMA_TEMPLATE_NUM_FIELDS_MAX\t15\n\n#define IMA_TEMPLATE_IMA_NAME \"ima\"\n#define IMA_TEMPLATE_IMA_FMT \"d|n\"\n\n#define NR_BANKS(chip) ((chip != NULL) ? chip->nr_allocated_banks : 0)\n\n \nextern int ima_policy_flag;\n\n \nextern atomic_t ima_setxattr_allowed_hash_algorithms;\n\n \nextern int ima_hash_algo __ro_after_init;\nextern int ima_sha1_idx __ro_after_init;\nextern int ima_hash_algo_idx __ro_after_init;\nextern int ima_extra_slots __ro_after_init;\nextern int ima_appraise;\nextern struct tpm_chip *ima_tpm_chip;\nextern const char boot_aggregate_name[];\n\n \nstruct ima_event_data {\n\tstruct integrity_iint_cache *iint;\n\tstruct file *file;\n\tconst unsigned char *filename;\n\tstruct evm_ima_xattr_data *xattr_value;\n\tint xattr_len;\n\tconst struct modsig *modsig;\n\tconst char *violation;\n\tconst void *buf;\n\tint buf_len;\n};\n\n \nstruct ima_field_data {\n\tu8 *data;\n\tu32 len;\n};\n\n \nstruct ima_template_field {\n\tconst char field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN];\n\tint (*field_init)(struct ima_event_data *event_data,\n\t\t\t  struct ima_field_data *field_data);\n\tvoid (*field_show)(struct seq_file *m, enum ima_show_type show,\n\t\t\t   struct ima_field_data *field_data);\n};\n\n \nstruct ima_template_desc {\n\tstruct list_head list;\n\tchar *name;\n\tchar *fmt;\n\tint num_fields;\n\tconst struct ima_template_field **fields;\n};\n\nstruct ima_template_entry {\n\tint pcr;\n\tstruct tpm_digest *digests;\n\tstruct ima_template_desc *template_desc;  \n\tu32 template_data_len;\n\tstruct ima_field_data template_data[];\t \n};\n\nstruct ima_queue_entry {\n\tstruct hlist_node hnext;\t \n\tstruct list_head later;\t\t \n\tstruct ima_template_entry *entry;\n};\nextern struct list_head ima_measurements;\t \n\n \nstruct ima_kexec_hdr {\n\tu16 version;\n\tu16 _reserved0;\n\tu32 _reserved1;\n\tu64 buffer_size;\n\tu64 count;\n};\n\nextern const int read_idmap[];\n\n#ifdef CONFIG_HAVE_IMA_KEXEC\nvoid ima_load_kexec_buffer(void);\n#else\nstatic inline void ima_load_kexec_buffer(void) {}\n#endif  \n\n \nextern bool ima_canonical_fmt;\n\n \nint ima_init(void);\nint ima_fs_init(void);\nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename);\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash);\nint ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash);\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_entry *entry);\nint ima_calc_boot_aggregate(struct ima_digest_data *hash);\nvoid ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause);\nint ima_init_crypto(void);\nvoid ima_putc(struct seq_file *m, void *data, int datalen);\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size);\nint template_desc_init_fields(const char *template_fmt,\n\t\t\t      const struct ima_template_field ***fields,\n\t\t\t      int *num_fields);\nstruct ima_template_desc *ima_template_desc_current(void);\nstruct ima_template_desc *ima_template_desc_buf(void);\nstruct ima_template_desc *lookup_template_desc(const char *name);\nbool ima_template_has_modsig(const struct ima_template_desc *ima_template);\nint ima_restore_measurement_entry(struct ima_template_entry *entry);\nint ima_restore_measurement_list(loff_t bufsize, void *buf);\nint ima_measurements_show(struct seq_file *m, void *v);\nunsigned long ima_get_binary_runtime_size(void);\nint ima_init_template(void);\nvoid ima_init_template_list(void);\nint __init ima_init_digests(void);\nint ima_lsm_policy_change(struct notifier_block *nb, unsigned long event,\n\t\t\t  void *lsm_data);\n\n \nextern spinlock_t ima_queue_lock;\n\nstruct ima_h_table {\n\tatomic_long_t len;\t \n\tatomic_long_t violations;\n\tstruct hlist_head queue[IMA_MEASURE_HTABLE_SIZE];\n};\nextern struct ima_h_table ima_htable;\n\nstatic inline unsigned int ima_hash_key(u8 *digest)\n{\n\t \n\treturn (digest[0] | digest[1] << 8) % IMA_MEASURE_HTABLE_SIZE;\n}\n\n#define __ima_hooks(hook)\t\t\t\t\\\n\thook(NONE, none)\t\t\t\t\\\n\thook(FILE_CHECK, file)\t\t\t\t\\\n\thook(MMAP_CHECK, mmap)\t\t\t\t\\\n\thook(MMAP_CHECK_REQPROT, mmap_reqprot)\t\t\\\n\thook(BPRM_CHECK, bprm)\t\t\t\t\\\n\thook(CREDS_CHECK, creds)\t\t\t\\\n\thook(POST_SETATTR, post_setattr)\t\t\\\n\thook(MODULE_CHECK, module)\t\t\t\\\n\thook(FIRMWARE_CHECK, firmware)\t\t\t\\\n\thook(KEXEC_KERNEL_CHECK, kexec_kernel)\t\t\\\n\thook(KEXEC_INITRAMFS_CHECK, kexec_initramfs)\t\\\n\thook(POLICY_CHECK, policy)\t\t\t\\\n\thook(KEXEC_CMDLINE, kexec_cmdline)\t\t\\\n\thook(KEY_CHECK, key)\t\t\t\t\\\n\thook(CRITICAL_DATA, critical_data)\t\t\\\n\thook(SETXATTR_CHECK, setxattr_check)\t\t\\\n\thook(MAX_CHECK, none)\n\n#define __ima_hook_enumify(ENUM, str)\tENUM,\n#define __ima_stringify(arg) (#arg)\n#define __ima_hook_measuring_stringify(ENUM, str) \\\n\t\t(__ima_stringify(measuring_ ##str)),\n\nenum ima_hooks {\n\t__ima_hooks(__ima_hook_enumify)\n};\n\nstatic const char * const ima_hooks_measure_str[] = {\n\t__ima_hooks(__ima_hook_measuring_stringify)\n};\n\nstatic inline const char *func_measure_str(enum ima_hooks func)\n{\n\tif (func >= MAX_CHECK)\n\t\treturn ima_hooks_measure_str[NONE];\n\n\treturn ima_hooks_measure_str[func];\n}\n\nextern const char *const func_tokens[];\n\nstruct modsig;\n\n#ifdef CONFIG_IMA_QUEUE_EARLY_BOOT_KEYS\n \nstruct ima_key_entry {\n\tstruct list_head list;\n\tvoid *payload;\n\tsize_t payload_len;\n\tchar *keyring_name;\n};\nvoid ima_init_key_queue(void);\nbool ima_should_queue_key(void);\nbool ima_queue_key(struct key *keyring, const void *payload,\n\t\t   size_t payload_len);\nvoid ima_process_queued_keys(void);\n#else\nstatic inline void ima_init_key_queue(void) {}\nstatic inline bool ima_should_queue_key(void) { return false; }\nstatic inline bool ima_queue_key(struct key *keyring,\n\t\t\t\t const void *payload,\n\t\t\t\t size_t payload_len) { return false; }\nstatic inline void ima_process_queued_keys(void) {}\n#endif  \n\n \nint ima_get_action(struct mnt_idmap *idmap, struct inode *inode,\n\t\t   const struct cred *cred, u32 secid, int mask,\n\t\t   enum ima_hooks func, int *pcr,\n\t\t   struct ima_template_desc **template_desc,\n\t\t   const char *func_data, unsigned int *allowed_algos);\nint ima_must_measure(struct inode *inode, int mask, enum ima_hooks func);\nint ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo, struct modsig *modsig);\nvoid ima_store_measurement(struct integrity_iint_cache *iint, struct file *file,\n\t\t\t   const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, const struct modsig *modsig, int pcr,\n\t\t\t   struct ima_template_desc *template_desc);\nint process_buffer_measurement(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, const void *buf, int size,\n\t\t\t       const char *eventname, enum ima_hooks func,\n\t\t\t       int pcr, const char *func_data,\n\t\t\t       bool buf_hash, u8 *digest, size_t digest_len);\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename);\nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry,\n\t\t\t    struct ima_template_desc *template_desc);\nint ima_store_template(struct ima_template_entry *entry, int violation,\n\t\t       struct inode *inode,\n\t\t       const unsigned char *filename, int pcr);\nvoid ima_free_template_entry(struct ima_template_entry *entry);\nconst char *ima_d_path(const struct path *path, char **pathbuf, char *filename);\n\n \nint ima_match_policy(struct mnt_idmap *idmap, struct inode *inode,\n\t\t     const struct cred *cred, u32 secid, enum ima_hooks func,\n\t\t     int mask, int flags, int *pcr,\n\t\t     struct ima_template_desc **template_desc,\n\t\t     const char *func_data, unsigned int *allowed_algos);\nvoid ima_init_policy(void);\nvoid ima_update_policy(void);\nvoid ima_update_policy_flags(void);\nssize_t ima_parse_add_rule(char *);\nvoid ima_delete_rules(void);\nint ima_check_policy(void);\nvoid *ima_policy_start(struct seq_file *m, loff_t *pos);\nvoid *ima_policy_next(struct seq_file *m, void *v, loff_t *pos);\nvoid ima_policy_stop(struct seq_file *m, void *v);\nint ima_policy_show(struct seq_file *m, void *v);\n\n \n#define IMA_APPRAISE_ENFORCE\t0x01\n#define IMA_APPRAISE_FIX\t0x02\n#define IMA_APPRAISE_LOG\t0x04\n#define IMA_APPRAISE_MODULES\t0x08\n#define IMA_APPRAISE_FIRMWARE\t0x10\n#define IMA_APPRAISE_POLICY\t0x20\n#define IMA_APPRAISE_KEXEC\t0x40\n\n#ifdef CONFIG_IMA_APPRAISE\nint ima_check_blacklist(struct integrity_iint_cache *iint,\n\t\t\tconst struct modsig *modsig, int pcr);\nint ima_appraise_measurement(enum ima_hooks func,\n\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t     struct file *file, const unsigned char *filename,\n\t\t\t     struct evm_ima_xattr_data *xattr_value,\n\t\t\t     int xattr_len, const struct modsig *modsig);\nint ima_must_appraise(struct mnt_idmap *idmap, struct inode *inode,\n\t\t      int mask, enum ima_hooks func);\nvoid ima_update_xattr(struct integrity_iint_cache *iint, struct file *file);\nenum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t\t   enum ima_hooks func);\nenum hash_algo ima_get_hash_algo(const struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t int xattr_len);\nint ima_read_xattr(struct dentry *dentry,\n\t\t   struct evm_ima_xattr_data **xattr_value, int xattr_len);\n\n#else\nstatic inline int ima_check_blacklist(struct integrity_iint_cache *iint,\n\t\t\t\t      const struct modsig *modsig, int pcr)\n{\n\treturn 0;\n}\n\nstatic inline int ima_appraise_measurement(enum ima_hooks func,\n\t\t\t\t\t   struct integrity_iint_cache *iint,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   const unsigned char *filename,\n\t\t\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t\t   int xattr_len,\n\t\t\t\t\t   const struct modsig *modsig)\n{\n\treturn INTEGRITY_UNKNOWN;\n}\n\nstatic inline int ima_must_appraise(struct mnt_idmap *idmap,\n\t\t\t\t    struct inode *inode, int mask,\n\t\t\t\t    enum ima_hooks func)\n{\n\treturn 0;\n}\n\nstatic inline void ima_update_xattr(struct integrity_iint_cache *iint,\n\t\t\t\t    struct file *file)\n{\n}\n\nstatic inline enum integrity_status ima_get_cache_status(struct integrity_iint_cache\n\t\t\t\t\t\t\t *iint,\n\t\t\t\t\t\t\t enum ima_hooks func)\n{\n\treturn INTEGRITY_UNKNOWN;\n}\n\nstatic inline enum hash_algo\nima_get_hash_algo(struct evm_ima_xattr_data *xattr_value, int xattr_len)\n{\n\treturn ima_hash_algo;\n}\n\nstatic inline int ima_read_xattr(struct dentry *dentry,\n\t\t\t\t struct evm_ima_xattr_data **xattr_value,\n\t\t\t\t int xattr_len)\n{\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_IMA_APPRAISE_MODSIG\nint ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,\n\t\t    struct modsig **modsig);\nvoid ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size);\nint ima_get_modsig_digest(const struct modsig *modsig, enum hash_algo *algo,\n\t\t\t  const u8 **digest, u32 *digest_size);\nint ima_get_raw_modsig(const struct modsig *modsig, const void **data,\n\t\t       u32 *data_len);\nvoid ima_free_modsig(struct modsig *modsig);\n#else\nstatic inline int ima_read_modsig(enum ima_hooks func, const void *buf,\n\t\t\t\t  loff_t buf_len, struct modsig **modsig)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void ima_collect_modsig(struct modsig *modsig, const void *buf,\n\t\t\t\t      loff_t size)\n{\n}\n\nstatic inline int ima_get_modsig_digest(const struct modsig *modsig,\n\t\t\t\t\tenum hash_algo *algo, const u8 **digest,\n\t\t\t\t\tu32 *digest_size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ima_get_raw_modsig(const struct modsig *modsig,\n\t\t\t\t     const void **data, u32 *data_len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void ima_free_modsig(struct modsig *modsig)\n{\n}\n#endif  \n\n \n#ifdef CONFIG_IMA_LSM_RULES\n\n#define ima_filter_rule_init security_audit_rule_init\n#define ima_filter_rule_free security_audit_rule_free\n#define ima_filter_rule_match security_audit_rule_match\n\n#else\n\nstatic inline int ima_filter_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t       void **lsmrule)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void ima_filter_rule_free(void *lsmrule)\n{\n}\n\nstatic inline int ima_filter_rule_match(u32 secid, u32 field, u32 op,\n\t\t\t\t\tvoid *lsmrule)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n#ifdef\tCONFIG_IMA_READ_POLICY\n#define\tPOLICY_FILE_FLAGS\t(S_IWUSR | S_IRUSR)\n#else\n#define\tPOLICY_FILE_FLAGS\tS_IWUSR\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}