{
  "module_name": "ima_main.c",
  "hash_id": "c631412eb1e724d21f5406889a0029dc35ec6ff891b3e6e3f3c067427445b519",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/binfmts.h>\n#include <linux/kernel_read_file.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/iversion.h>\n\n#include \"ima.h\"\n\n#ifdef CONFIG_IMA_APPRAISE\nint ima_appraise = IMA_APPRAISE_ENFORCE;\n#else\nint ima_appraise;\n#endif\n\nint __ro_after_init ima_hash_algo = HASH_ALGO_SHA1;\nstatic int hash_setup_done;\n\nstatic struct notifier_block ima_lsm_policy_notifier = {\n\t.notifier_call = ima_lsm_policy_change,\n};\n\nstatic int __init hash_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i;\n\n\tif (hash_setup_done)\n\t\treturn 1;\n\n\tif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\n\t\tif (strncmp(str, \"sha1\", 4) == 0) {\n\t\t\tima_hash_algo = HASH_ALGO_SHA1;\n\t\t} else if (strncmp(str, \"md5\", 3) == 0) {\n\t\t\tima_hash_algo = HASH_ALGO_MD5;\n\t\t} else {\n\t\t\tpr_err(\"invalid hash algorithm \\\"%s\\\" for template \\\"%s\\\"\",\n\t\t\t\tstr, IMA_TEMPLATE_IMA_NAME);\n\t\t\treturn 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\ti = match_string(hash_algo_name, HASH_ALGO__LAST, str);\n\tif (i < 0) {\n\t\tpr_err(\"invalid hash algorithm \\\"%s\\\"\", str);\n\t\treturn 1;\n\t}\n\n\tima_hash_algo = i;\nout:\n\thash_setup_done = 1;\n\treturn 1;\n}\n__setup(\"ima_hash=\", hash_setup);\n\nenum hash_algo ima_get_current_hash_algo(void)\n{\n\treturn ima_hash_algo;\n}\n\n \nstatic int mmap_violation_check(enum ima_hooks func, struct file *file,\n\t\t\t\tchar **pathbuf, const char **pathname,\n\t\t\t\tchar *filename)\n{\n\tstruct inode *inode;\n\tint rc = 0;\n\n\tif ((func == MMAP_CHECK || func == MMAP_CHECK_REQPROT) &&\n\t    mapping_writably_mapped(file->f_mapping)) {\n\t\trc = -ETXTBSY;\n\t\tinode = file_inode(file);\n\n\t\tif (!*pathbuf)\t \n\t\t\t*pathname = ima_d_path(&file->f_path, pathbuf,\n\t\t\t\t\t       filename);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, *pathname,\n\t\t\t\t    \"mmap_file\", \"mmapped_writers\", rc, 0);\n\t}\n\treturn rc;\n}\n\n \nstatic void ima_rdwr_violation_check(struct file *file,\n\t\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t\t     int must_measure,\n\t\t\t\t     char **pathbuf,\n\t\t\t\t     const char **pathname,\n\t\t\t\t     char *filename)\n{\n\tstruct inode *inode = file_inode(file);\n\tfmode_t mode = file->f_mode;\n\tbool send_tomtou = false, send_writers = false;\n\n\tif (mode & FMODE_WRITE) {\n\t\tif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\n\t\t\tif (!iint)\n\t\t\t\tiint = integrity_iint_find(inode);\n\t\t\t \n\t\t\tif (iint && test_bit(IMA_MUST_MEASURE,\n\t\t\t\t\t\t&iint->atomic_flags))\n\t\t\t\tsend_tomtou = true;\n\t\t}\n\t} else {\n\t\tif (must_measure)\n\t\t\tset_bit(IMA_MUST_MEASURE, &iint->atomic_flags);\n\t\tif (inode_is_open_for_write(inode) && must_measure)\n\t\t\tsend_writers = true;\n\t}\n\n\tif (!send_tomtou && !send_writers)\n\t\treturn;\n\n\t*pathname = ima_d_path(&file->f_path, pathbuf, filename);\n\n\tif (send_tomtou)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"ToMToU\");\n\tif (send_writers)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"open_writers\");\n}\n\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\n\t\t\t\t  struct inode *inode, struct file *file)\n{\n\tfmode_t mode = file->f_mode;\n\tbool update;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn;\n\n\tmutex_lock(&iint->mutex);\n\tif (atomic_read(&inode->i_writecount) == 1) {\n\t\tstruct kstat stat;\n\n\t\tupdate = test_and_clear_bit(IMA_UPDATE_XATTR,\n\t\t\t\t\t    &iint->atomic_flags);\n\t\tif ((iint->flags & IMA_NEW_FILE) ||\n\t\t    vfs_getattr_nosec(&file->f_path, &stat,\n\t\t\t\t      STATX_CHANGE_COOKIE,\n\t\t\t\t      AT_STATX_SYNC_AS_STAT) ||\n\t\t    !(stat.result_mask & STATX_CHANGE_COOKIE) ||\n\t\t    stat.change_cookie != iint->version) {\n\t\t\tiint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\n\t\t\tiint->measured_pcrs = 0;\n\t\t\tif (update)\n\t\t\t\tima_update_xattr(iint, file);\n\t\t}\n\t}\n\tmutex_unlock(&iint->mutex);\n}\n\n \nvoid ima_file_free(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tima_check_last_writer(iint, inode, file);\n}\n\nstatic int process_measurement(struct file *file, const struct cred *cred,\n\t\t\t       u32 secid, char *buf, loff_t size, int mask,\n\t\t\t       enum ima_hooks func)\n{\n\tstruct inode *backing_inode, *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc = NULL;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = 0, action, must_appraise = 0;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tstruct modsig *modsig = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\tunsigned int allowed_algos = 0;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t \n\taction = ima_get_action(file_mnt_idmap(file), inode, cred, secid,\n\t\t\t\tmask, func, &pcr, &template_desc, NULL,\n\t\t\t\t&allowed_algos);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK ||\n\t\t\t    func == MMAP_CHECK_REQPROT) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t \n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\trc = -ENOMEM;\n\t}\n\n\tif (!rc && violation_check)\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname, filename);\n\n\tinode_unlock(inode);\n\n\tif (rc)\n\t\tgoto out;\n\tif (!action)\n\t\tgoto out;\n\n\tmutex_lock(&iint->mutex);\n\n\tif (test_and_clear_bit(IMA_CHANGE_ATTR, &iint->atomic_flags))\n\t\t \n\t\tiint->flags &= ~(IMA_APPRAISE | IMA_APPRAISED |\n\t\t\t\t IMA_APPRAISE_SUBMASK | IMA_APPRAISED_SUBMASK |\n\t\t\t\t IMA_NONACTION_FLAGS);\n\n\t \n\tif (test_and_clear_bit(IMA_CHANGE_XATTR, &iint->atomic_flags) ||\n\t    ((inode->i_sb->s_iflags & SB_I_IMA_UNVERIFIABLE_SIGNATURE) &&\n\t     !(inode->i_sb->s_iflags & SB_I_UNTRUSTED_MOUNTER) &&\n\t     !(action & IMA_FAIL_UNVERIFIABLE_SIGS))) {\n\t\tiint->flags &= ~IMA_DONE_MASK;\n\t\tiint->measured_pcrs = 0;\n\t}\n\n\t \n\tbacking_inode = d_real_inode(file_dentry(file));\n\tif (backing_inode != inode &&\n\t    (action & IMA_DO_MASK) && (iint->flags & IMA_DONE_MASK)) {\n\t\tif (!IS_I_VERSION(backing_inode) ||\n\t\t    backing_inode->i_sb->s_dev != iint->real_dev ||\n\t\t    backing_inode->i_ino != iint->real_ino ||\n\t\t    !inode_eq_iversion(backing_inode, iint->version)) {\n\t\t\tiint->flags &= ~IMA_DONE_MASK;\n\t\t\tiint->measured_pcrs = 0;\n\t\t}\n\t}\n\n\t \n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t \n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t \n\tif ((action & IMA_HASH) &&\n\t    !(test_bit(IMA_DIGSIG, &iint->atomic_flags))) {\n\t\txattr_len = ima_read_xattr(file_dentry(file),\n\t\t\t\t\t   &xattr_value, xattr_len);\n\t\tif ((xattr_value && xattr_len > 2) &&\n\t\t    (xattr_value->type == EVM_IMA_XATTR_DIGSIG))\n\t\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\t\tiint->flags |= IMA_HASHED;\n\t\taction ^= IMA_HASH;\n\t\tset_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);\n\t}\n\n\t \n\tif (!action) {\n\t\tif (must_appraise) {\n\t\t\trc = mmap_violation_check(func, file, &pathbuf,\n\t\t\t\t\t\t  &pathname, filename);\n\t\t\tif (!rc)\n\t\t\t\trc = ima_get_cache_status(iint, func);\n\t\t}\n\t\tgoto out_locked;\n\t}\n\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t \n\t\txattr_len = ima_read_xattr(file_dentry(file),\n\t\t\t\t\t   &xattr_value, xattr_len);\n\n\t\t \n\t\tif (iint->flags & IMA_MODSIG_ALLOWED) {\n\t\t\trc = ima_read_modsig(func, buf, size, &modsig);\n\n\t\t\tif (!rc && ima_template_has_modsig(template_desc) &&\n\t\t\t    iint->flags & IMA_MEASURED)\n\t\t\t\taction |= IMA_MEASURE;\n\t\t}\n\t}\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo, modsig);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_locked;\n\n\tif (!pathbuf)\t \n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, modsig, pcr,\n\t\t\t\t      template_desc);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK)) {\n\t\trc = ima_check_blacklist(iint, modsig, pcr);\n\t\tif (rc != -EPERM) {\n\t\t\tinode_lock(inode);\n\t\t\trc = ima_appraise_measurement(func, iint, file,\n\t\t\t\t\t\t      pathname, xattr_value,\n\t\t\t\t\t\t      xattr_len, modsig);\n\t\t\tinode_unlock(inode);\n\t\t}\n\t\tif (!rc)\n\t\t\trc = mmap_violation_check(func, file, &pathbuf,\n\t\t\t\t\t\t  &pathname, filename);\n\t}\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\n\n\t \n\tif (rc == 0 && must_appraise && allowed_algos != 0 &&\n\t    (allowed_algos & (1U << hash_algo)) == 0) {\n\t\trc = -EACCES;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, file_inode(file),\n\t\t\t\t    pathname, \"collect_data\",\n\t\t\t\t    \"denied-hash-algorithm\", rc, 0);\n\t}\nout_locked:\n\tif ((mask & MAY_WRITE) && test_bit(IMA_DIGSIG, &iint->atomic_flags) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tmutex_unlock(&iint->mutex);\n\tkfree(xattr_value);\n\tima_free_modsig(modsig);\nout:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\n\tif (must_appraise) {\n\t\tif (rc && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\t\treturn -EACCES;\n\t\tif (file->f_mode & FMODE_WRITE)\n\t\t\tset_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);\n\t}\n\treturn 0;\n}\n\n \nint ima_file_mmap(struct file *file, unsigned long reqprot,\n\t\t  unsigned long prot, unsigned long flags)\n{\n\tu32 secid;\n\tint ret;\n\n\tif (!file)\n\t\treturn 0;\n\n\tsecurity_current_getsecid_subj(&secid);\n\n\tif (reqprot & PROT_EXEC) {\n\t\tret = process_measurement(file, current_cred(), secid, NULL,\n\t\t\t\t\t  0, MAY_EXEC, MMAP_CHECK_REQPROT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (prot & PROT_EXEC)\n\t\treturn process_measurement(file, current_cred(), secid, NULL,\n\t\t\t\t\t   0, MAY_EXEC, MMAP_CHECK);\n\n\treturn 0;\n}\n\n \nint ima_file_mprotect(struct vm_area_struct *vma, unsigned long prot)\n{\n\tstruct ima_template_desc *template = NULL;\n\tstruct file *file;\n\tchar filename[NAME_MAX];\n\tchar *pathbuf = NULL;\n\tconst char *pathname = NULL;\n\tstruct inode *inode;\n\tint result = 0;\n\tint action;\n\tu32 secid;\n\tint pcr;\n\n\t \n\tif (!(ima_policy_flag & IMA_APPRAISE) || !vma->vm_file ||\n\t    !(prot & PROT_EXEC) || (vma->vm_flags & VM_EXEC))\n\t\treturn 0;\n\n\tsecurity_current_getsecid_subj(&secid);\n\tinode = file_inode(vma->vm_file);\n\taction = ima_get_action(file_mnt_idmap(vma->vm_file), inode,\n\t\t\t\tcurrent_cred(), secid, MAY_EXEC, MMAP_CHECK,\n\t\t\t\t&pcr, &template, NULL, NULL);\n\taction |= ima_get_action(file_mnt_idmap(vma->vm_file), inode,\n\t\t\t\t current_cred(), secid, MAY_EXEC,\n\t\t\t\t MMAP_CHECK_REQPROT, &pcr, &template, NULL,\n\t\t\t\t NULL);\n\n\t \n\tif (!(action & (IMA_MEASURE | IMA_APPRAISE_SUBMASK)))\n\t\treturn 0;\n\n\tif (action & IMA_APPRAISE_SUBMASK)\n\t\tresult = -EPERM;\n\n\tfile = vma->vm_file;\n\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, pathname,\n\t\t\t    \"collect_data\", \"failed-mprotect\", result, 0);\n\tif (pathbuf)\n\t\t__putname(pathbuf);\n\n\treturn result;\n}\n\n \nint ima_bprm_check(struct linux_binprm *bprm)\n{\n\tint ret;\n\tu32 secid;\n\n\tsecurity_current_getsecid_subj(&secid);\n\tret = process_measurement(bprm->file, current_cred(), secid, NULL, 0,\n\t\t\t\t  MAY_EXEC, BPRM_CHECK);\n\tif (ret)\n\t\treturn ret;\n\n\tsecurity_cred_getsecid(bprm->cred, &secid);\n\treturn process_measurement(bprm->file, bprm->cred, secid, NULL, 0,\n\t\t\t\t   MAY_EXEC, CREDS_CHECK);\n}\n\n \nint ima_file_check(struct file *file, int mask)\n{\n\tu32 secid;\n\n\tsecurity_current_getsecid_subj(&secid);\n\treturn process_measurement(file, current_cred(), secid, NULL, 0,\n\t\t\t\t   mask & (MAY_READ | MAY_WRITE | MAY_EXEC |\n\t\t\t\t\t   MAY_APPEND), FILE_CHECK);\n}\nEXPORT_SYMBOL_GPL(ima_file_check);\n\nstatic int __ima_inode_hash(struct inode *inode, struct file *file, char *buf,\n\t\t\t    size_t buf_size)\n{\n\tstruct integrity_iint_cache *iint = NULL, tmp_iint;\n\tint rc, hash_algo;\n\n\tif (ima_policy_flag) {\n\t\tiint = integrity_iint_find(inode);\n\t\tif (iint)\n\t\t\tmutex_lock(&iint->mutex);\n\t}\n\n\tif ((!iint || !(iint->flags & IMA_COLLECTED)) && file) {\n\t\tif (iint)\n\t\t\tmutex_unlock(&iint->mutex);\n\n\t\tmemset(&tmp_iint, 0, sizeof(tmp_iint));\n\t\ttmp_iint.inode = inode;\n\t\tmutex_init(&tmp_iint.mutex);\n\n\t\trc = ima_collect_measurement(&tmp_iint, file, NULL, 0,\n\t\t\t\t\t     ima_hash_algo, NULL);\n\t\tif (rc < 0) {\n\t\t\t \n\t\t\tif (rc != -ENOMEM)\n\t\t\t\tkfree(tmp_iint.ima_hash);\n\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tiint = &tmp_iint;\n\t\tmutex_lock(&iint->mutex);\n\t}\n\n\tif (!iint)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!iint->ima_hash || !(iint->flags & IMA_COLLECTED)) {\n\t\tmutex_unlock(&iint->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (buf) {\n\t\tsize_t copied_size;\n\n\t\tcopied_size = min_t(size_t, iint->ima_hash->length, buf_size);\n\t\tmemcpy(buf, iint->ima_hash->digest, copied_size);\n\t}\n\thash_algo = iint->ima_hash->algo;\n\tmutex_unlock(&iint->mutex);\n\n\tif (iint == &tmp_iint)\n\t\tkfree(iint->ima_hash);\n\n\treturn hash_algo;\n}\n\n \nint ima_file_hash(struct file *file, char *buf, size_t buf_size)\n{\n\tif (!file)\n\t\treturn -EINVAL;\n\n\treturn __ima_inode_hash(file_inode(file), file, buf, buf_size);\n}\nEXPORT_SYMBOL_GPL(ima_file_hash);\n\n \nint ima_inode_hash(struct inode *inode, char *buf, size_t buf_size)\n{\n\tif (!inode)\n\t\treturn -EINVAL;\n\n\treturn __ima_inode_hash(inode, NULL, buf, buf_size);\n}\nEXPORT_SYMBOL_GPL(ima_inode_hash);\n\n \nvoid ima_post_create_tmpfile(struct mnt_idmap *idmap,\n\t\t\t     struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\tint must_appraise;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tmust_appraise = ima_must_appraise(idmap, inode, MAY_ACCESS,\n\t\t\t\t\t  FILE_CHECK);\n\tif (!must_appraise)\n\t\treturn;\n\n\t \n\tiint = integrity_inode_get(inode);\n\tif (!iint)\n\t\treturn;\n\n\t \n\tset_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);\n\tiint->ima_file_status = INTEGRITY_PASS;\n}\n\n \nvoid ima_post_path_mknod(struct mnt_idmap *idmap,\n\t\t\t struct dentry *dentry)\n{\n\tstruct integrity_iint_cache *iint;\n\tstruct inode *inode = dentry->d_inode;\n\tint must_appraise;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tmust_appraise = ima_must_appraise(idmap, inode, MAY_ACCESS,\n\t\t\t\t\t  FILE_CHECK);\n\tif (!must_appraise)\n\t\treturn;\n\n\t \n\tiint = integrity_inode_get(inode);\n\tif (!iint)\n\t\treturn;\n\n\t \n\tiint->flags |= IMA_NEW_FILE;\n}\n\n \nint ima_read_file(struct file *file, enum kernel_read_file_id read_id,\n\t\t  bool contents)\n{\n\tenum ima_hooks func;\n\tu32 secid;\n\n\t \n\n\t \n\tif (contents)\n\t\treturn 0;\n\n\t \n\tfunc = read_idmap[read_id] ?: FILE_CHECK;\n\tsecurity_current_getsecid_subj(&secid);\n\treturn process_measurement(file, current_cred(), secid, NULL,\n\t\t\t\t   0, MAY_READ, func);\n}\n\nconst int read_idmap[READING_MAX_ID] = {\n\t[READING_FIRMWARE] = FIRMWARE_CHECK,\n\t[READING_MODULE] = MODULE_CHECK,\n\t[READING_KEXEC_IMAGE] = KEXEC_KERNEL_CHECK,\n\t[READING_KEXEC_INITRAMFS] = KEXEC_INITRAMFS_CHECK,\n\t[READING_POLICY] = POLICY_CHECK\n};\n\n \nint ima_post_read_file(struct file *file, void *buf, loff_t size,\n\t\t       enum kernel_read_file_id read_id)\n{\n\tenum ima_hooks func;\n\tu32 secid;\n\n\t \n\tif (!file && read_id == READING_X509_CERTIFICATE)\n\t\treturn 0;\n\n\tif (!file || !buf || size == 0) {  \n\t\tif (ima_appraise & IMA_APPRAISE_ENFORCE)\n\t\t\treturn -EACCES;\n\t\treturn 0;\n\t}\n\n\tfunc = read_idmap[read_id] ?: FILE_CHECK;\n\tsecurity_current_getsecid_subj(&secid);\n\treturn process_measurement(file, current_cred(), secid, buf, size,\n\t\t\t\t   MAY_READ, func);\n}\n\n \nint ima_load_data(enum kernel_load_data_id id, bool contents)\n{\n\tbool ima_enforce, sig_enforce;\n\n\tima_enforce =\n\t\t(ima_appraise & IMA_APPRAISE_ENFORCE) == IMA_APPRAISE_ENFORCE;\n\n\tswitch (id) {\n\tcase LOADING_KEXEC_IMAGE:\n\t\tif (IS_ENABLED(CONFIG_KEXEC_SIG)\n\t\t    && arch_ima_get_secureboot()) {\n\t\t\tpr_err(\"impossible to appraise a kernel image without a file descriptor; try using kexec_file_load syscall.\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (ima_enforce && (ima_appraise & IMA_APPRAISE_KEXEC)) {\n\t\t\tpr_err(\"impossible to appraise a kernel image without a file descriptor; try using kexec_file_load syscall.\\n\");\n\t\t\treturn -EACCES;\t \n\t\t}\n\t\tbreak;\n\tcase LOADING_FIRMWARE:\n\t\tif (ima_enforce && (ima_appraise & IMA_APPRAISE_FIRMWARE) && !contents) {\n\t\t\tpr_err(\"Prevent firmware sysfs fallback loading.\\n\");\n\t\t\treturn -EACCES;\t \n\t\t}\n\t\tbreak;\n\tcase LOADING_MODULE:\n\t\tsig_enforce = is_module_sig_enforced();\n\n\t\tif (ima_enforce && (!sig_enforce\n\t\t\t\t    && (ima_appraise & IMA_APPRAISE_MODULES))) {\n\t\t\tpr_err(\"impossible to appraise a module without a file descriptor. sig_enforce kernel parameter might help\\n\");\n\t\t\treturn -EACCES;\t \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint ima_post_load_data(char *buf, loff_t size,\n\t\t       enum kernel_load_data_id load_id,\n\t\t       char *description)\n{\n\tif (load_id == LOADING_FIRMWARE) {\n\t\tif ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&\n\t\t    (ima_appraise & IMA_APPRAISE_ENFORCE)) {\n\t\t\tpr_err(\"Prevent firmware loading_store.\\n\");\n\t\t\treturn -EACCES;  \n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nint process_buffer_measurement(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, const void *buf, int size,\n\t\t\t       const char *eventname, enum ima_hooks func,\n\t\t\t       int pcr, const char *func_data,\n\t\t\t       bool buf_hash, u8 *digest, size_t digest_len)\n{\n\tint ret = 0;\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry = NULL;\n\tstruct integrity_iint_cache iint = {};\n\tstruct ima_event_data event_data = {.iint = &iint,\n\t\t\t\t\t    .filename = eventname,\n\t\t\t\t\t    .buf = buf,\n\t\t\t\t\t    .buf_len = size};\n\tstruct ima_template_desc *template;\n\tstruct ima_max_digest_data hash;\n\tchar digest_hash[IMA_MAX_DIGEST_SIZE];\n\tint digest_hash_len = hash_digest_size[ima_hash_algo];\n\tint violation = 0;\n\tint action = 0;\n\tu32 secid;\n\n\tif (digest && digest_len < digest_hash_len)\n\t\treturn -EINVAL;\n\n\tif (!ima_policy_flag && !digest)\n\t\treturn -ENOENT;\n\n\ttemplate = ima_template_desc_buf();\n\tif (!template) {\n\t\tret = -EINVAL;\n\t\taudit_cause = \"ima_template_desc_buf\";\n\t\tgoto out;\n\t}\n\n\t \n\tif (func) {\n\t\tsecurity_current_getsecid_subj(&secid);\n\t\taction = ima_get_action(idmap, inode, current_cred(),\n\t\t\t\t\tsecid, 0, func, &pcr, &template,\n\t\t\t\t\tfunc_data, NULL);\n\t\tif (!(action & IMA_MEASURE) && !digest)\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (!pcr)\n\t\tpcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\n\tiint.ima_hash = &hash.hdr;\n\tiint.ima_hash->algo = ima_hash_algo;\n\tiint.ima_hash->length = hash_digest_size[ima_hash_algo];\n\n\tret = ima_calc_buffer_hash(buf, size, iint.ima_hash);\n\tif (ret < 0) {\n\t\taudit_cause = \"hashing_error\";\n\t\tgoto out;\n\t}\n\n\tif (buf_hash) {\n\t\tmemcpy(digest_hash, hash.hdr.digest, digest_hash_len);\n\n\t\tret = ima_calc_buffer_hash(digest_hash, digest_hash_len,\n\t\t\t\t\t   iint.ima_hash);\n\t\tif (ret < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto out;\n\t\t}\n\n\t\tevent_data.buf = digest_hash;\n\t\tevent_data.buf_len = digest_hash_len;\n\t}\n\n\tif (digest)\n\t\tmemcpy(digest, iint.ima_hash->digest, digest_hash_len);\n\n\tif (!ima_policy_flag || (func && !(action & IMA_MEASURE)))\n\t\treturn 1;\n\n\tret = ima_alloc_init_template(&event_data, &entry, template);\n\tif (ret < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto out;\n\t}\n\n\tret = ima_store_template(entry, violation, NULL, event_data.buf, pcr);\n\tif (ret < 0) {\n\t\taudit_cause = \"store_entry\";\n\t\tima_free_template_entry(entry);\n\t}\n\nout:\n\tif (ret < 0)\n\t\tintegrity_audit_message(AUDIT_INTEGRITY_PCR, NULL, eventname,\n\t\t\t\t\tfunc_measure_str(func),\n\t\t\t\t\taudit_cause, ret, 0, ret);\n\n\treturn ret;\n}\n\n \nvoid ima_kexec_cmdline(int kernel_fd, const void *buf, int size)\n{\n\tstruct fd f;\n\n\tif (!buf || !size)\n\t\treturn;\n\n\tf = fdget(kernel_fd);\n\tif (!f.file)\n\t\treturn;\n\n\tprocess_buffer_measurement(file_mnt_idmap(f.file), file_inode(f.file),\n\t\t\t\t   buf, size, \"kexec-cmdline\", KEXEC_CMDLINE, 0,\n\t\t\t\t   NULL, false, NULL, 0);\n\tfdput(f);\n}\n\n \nint ima_measure_critical_data(const char *event_label,\n\t\t\t      const char *event_name,\n\t\t\t      const void *buf, size_t buf_len,\n\t\t\t      bool hash, u8 *digest, size_t digest_len)\n{\n\tif (!event_name || !event_label || !buf || !buf_len)\n\t\treturn -ENOPARAM;\n\n\treturn process_buffer_measurement(&nop_mnt_idmap, NULL, buf, buf_len,\n\t\t\t\t\t  event_name, CRITICAL_DATA, 0,\n\t\t\t\t\t  event_label, hash, digest,\n\t\t\t\t\t  digest_len);\n}\nEXPORT_SYMBOL_GPL(ima_measure_critical_data);\n\nstatic int __init init_ima(void)\n{\n\tint error;\n\n\tima_appraise_parse_cmdline();\n\tima_init_template_list();\n\thash_setup(CONFIG_IMA_DEFAULT_HASH);\n\terror = ima_init();\n\n\tif (error && strcmp(hash_algo_name[ima_hash_algo],\n\t\t\t    CONFIG_IMA_DEFAULT_HASH) != 0) {\n\t\tpr_info(\"Allocating %s failed, going to use default hash algorithm %s\\n\",\n\t\t\thash_algo_name[ima_hash_algo], CONFIG_IMA_DEFAULT_HASH);\n\t\thash_setup_done = 0;\n\t\thash_setup(CONFIG_IMA_DEFAULT_HASH);\n\t\terror = ima_init();\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\terror = register_blocking_lsm_notifier(&ima_lsm_policy_notifier);\n\tif (error)\n\t\tpr_warn(\"Couldn't register LSM notifier, error %d\\n\", error);\n\n\tif (!error)\n\t\tima_update_policy_flags();\n\n\treturn error;\n}\n\nlate_initcall(init_ima);\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}