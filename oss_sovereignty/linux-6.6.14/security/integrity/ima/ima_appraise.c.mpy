{
  "module_name": "ima_appraise.c",
  "hash_id": "91c68cb71b4e833c78d2a28f4f35a040a161bf3fc5efa227af1eceb179fc97be",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_appraise.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/fsverity.h>\n#include <keys/system_keyring.h>\n#include <uapi/linux/fsverity.h>\n\n#include \"ima.h\"\n\n#ifdef CONFIG_IMA_APPRAISE_BOOTPARAM\nstatic char *ima_appraise_cmdline_default __initdata;\ncore_param(ima_appraise, ima_appraise_cmdline_default, charp, 0);\n\nvoid __init ima_appraise_parse_cmdline(void)\n{\n\tconst char *str = ima_appraise_cmdline_default;\n\tbool sb_state = arch_ima_get_secureboot();\n\tint appraisal_state = ima_appraise;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strncmp(str, \"off\", 3) == 0)\n\t\tappraisal_state = 0;\n\telse if (strncmp(str, \"log\", 3) == 0)\n\t\tappraisal_state = IMA_APPRAISE_LOG;\n\telse if (strncmp(str, \"fix\", 3) == 0)\n\t\tappraisal_state = IMA_APPRAISE_FIX;\n\telse if (strncmp(str, \"enforce\", 7) == 0)\n\t\tappraisal_state = IMA_APPRAISE_ENFORCE;\n\telse\n\t\tpr_err(\"invalid \\\"%s\\\" appraise option\", str);\n\n\t \n\tif (sb_state) {\n\t\tif (!(appraisal_state & IMA_APPRAISE_ENFORCE))\n\t\t\tpr_info(\"Secure boot enabled: ignoring ima_appraise=%s option\",\n\t\t\t\tstr);\n\t} else {\n\t\tima_appraise = appraisal_state;\n\t}\n}\n#endif\n\n \nbool is_ima_appraise_enabled(void)\n{\n\treturn ima_appraise & IMA_APPRAISE_ENFORCE;\n}\n\n \nint ima_must_appraise(struct mnt_idmap *idmap, struct inode *inode,\n\t\t      int mask, enum ima_hooks func)\n{\n\tu32 secid;\n\n\tif (!ima_appraise)\n\t\treturn 0;\n\n\tsecurity_current_getsecid_subj(&secid);\n\treturn ima_match_policy(idmap, inode, current_cred(), secid,\n\t\t\t\tfunc, mask, IMA_APPRAISE | IMA_HASH, NULL,\n\t\t\t\tNULL, NULL, NULL);\n}\n\nstatic int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(&nop_mnt_idmap, dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}\n\n \nenum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t\t   enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\tcase MMAP_CHECK_REQPROT:\n\t\treturn iint->ima_mmap_status;\n\tcase BPRM_CHECK:\n\t\treturn iint->ima_bprm_status;\n\tcase CREDS_CHECK:\n\t\treturn iint->ima_creds_status;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn iint->ima_file_status;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn iint->ima_read_status;\n\t}\n}\n\nstatic void ima_set_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t enum ima_hooks func,\n\t\t\t\t enum integrity_status status)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\tcase MMAP_CHECK_REQPROT:\n\t\tiint->ima_mmap_status = status;\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->ima_bprm_status = status;\n\t\tbreak;\n\tcase CREDS_CHECK:\n\t\tiint->ima_creds_status = status;\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->ima_file_status = status;\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->ima_read_status = status;\n\t\tbreak;\n\t}\n}\n\nstatic void ima_cache_flags(struct integrity_iint_cache *iint,\n\t\t\t     enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\tcase MMAP_CHECK_REQPROT:\n\t\tiint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase CREDS_CHECK:\n\t\tiint->flags |= (IMA_CREDS_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\t}\n}\n\nenum hash_algo ima_get_hash_algo(const struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t int xattr_len)\n{\n\tstruct signature_v2_hdr *sig;\n\tenum hash_algo ret;\n\n\tif (!xattr_value || xattr_len < 2)\n\t\t \n\t\treturn ima_hash_algo;\n\n\tswitch (xattr_value->type) {\n\tcase IMA_VERITY_DIGSIG:\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version != 3 || xattr_len <= sizeof(*sig) ||\n\t\t    sig->hash_algo >= HASH_ALGO__LAST)\n\t\t\treturn ima_hash_algo;\n\t\treturn sig->hash_algo;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version != 2 || xattr_len <= sizeof(*sig)\n\t\t    || sig->hash_algo >= HASH_ALGO__LAST)\n\t\t\treturn ima_hash_algo;\n\t\treturn sig->hash_algo;\n\tcase IMA_XATTR_DIGEST_NG:\n\t\t \n\t\tret = xattr_value->data[0];\n\t\tif (ret < HASH_ALGO__LAST)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IMA_XATTR_DIGEST:\n\t\t \n\t\tif (xattr_len == 21) {\n\t\t\tunsigned int zero = 0;\n\t\t\tif (!memcmp(&xattr_value->data[16], &zero, 4))\n\t\t\t\treturn HASH_ALGO_MD5;\n\t\t\telse\n\t\t\t\treturn HASH_ALGO_SHA1;\n\t\t} else if (xattr_len == 17)\n\t\t\treturn HASH_ALGO_MD5;\n\t\tbreak;\n\t}\n\n\t \n\treturn ima_hash_algo;\n}\n\nint ima_read_xattr(struct dentry *dentry,\n\t\t   struct evm_ima_xattr_data **xattr_value, int xattr_len)\n{\n\tint ret;\n\n\tret = vfs_getxattr_alloc(&nop_mnt_idmap, dentry, XATTR_NAME_IMA,\n\t\t\t\t (char **)xattr_value, xattr_len, GFP_NOFS);\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\treturn ret;\n}\n\n \nstatic int calc_file_id_hash(enum evm_ima_xattr_type type,\n\t\t\t     enum hash_algo algo, const u8 *digest,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct ima_file_id file_id = {\n\t\t.hash_type = IMA_VERITY_DIGSIG, .hash_algorithm = algo};\n\tunsigned int unused = HASH_MAX_DIGESTSIZE - hash_digest_size[algo];\n\n\tif (type != IMA_VERITY_DIGSIG)\n\t\treturn -EINVAL;\n\n\tmemcpy(file_id.hash, digest, hash_digest_size[algo]);\n\n\thash->algo = algo;\n\thash->length = hash_digest_size[algo];\n\n\treturn ima_calc_buffer_hash(&file_id, sizeof(file_id) - unused, hash);\n}\n\n \nstatic int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,\n\t\t\tstruct evm_ima_xattr_data *xattr_value, int xattr_len,\n\t\t\tenum integrity_status *status, const char **cause)\n{\n\tstruct ima_max_digest_data hash;\n\tstruct signature_v2_hdr *sig;\n\tint rc = -EINVAL, hash_start = 0;\n\tint mask;\n\n\tswitch (xattr_value->type) {\n\tcase IMA_XATTR_DIGEST_NG:\n\t\t \n\t\thash_start = 1;\n\t\tfallthrough;\n\tcase IMA_XATTR_DIGEST:\n\t\tif (*status != INTEGRITY_PASS_IMMUTABLE) {\n\t\t\tif (iint->flags & IMA_DIGSIG_REQUIRED) {\n\t\t\t\tif (iint->flags & IMA_VERITY_REQUIRED)\n\t\t\t\t\t*cause = \"verity-signature-required\";\n\t\t\t\telse\n\t\t\t\t\t*cause = \"IMA-signature-required\";\n\t\t\t\t*status = INTEGRITY_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclear_bit(IMA_DIGSIG, &iint->atomic_flags);\n\t\t} else {\n\t\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\t\t}\n\t\tif (xattr_len - sizeof(xattr_value->type) - hash_start >=\n\t\t\t\tiint->ima_hash->length)\n\t\t\t \n\t\t\trc = memcmp(&xattr_value->data[hash_start],\n\t\t\t\t    iint->ima_hash->digest,\n\t\t\t\t    iint->ima_hash->length);\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tif (rc) {\n\t\t\t*cause = \"invalid-hash\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\t*status = INTEGRITY_PASS;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\n\t\tmask = IMA_DIGSIG_REQUIRED | IMA_VERITY_REQUIRED;\n\t\tif ((iint->flags & mask) == mask) {\n\t\t\t*cause = \"verity-signature-required\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version >= 3) {\n\t\t\t*cause = \"invalid-signature-version\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\n\t\t\t\t\t     (const char *)xattr_value,\n\t\t\t\t\t     xattr_len,\n\t\t\t\t\t     iint->ima_hash->digest,\n\t\t\t\t\t     iint->ima_hash->length);\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\t*status = INTEGRITY_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_INTEGRITY_PLATFORM_KEYRING) && rc &&\n\t\t    func == KEXEC_KERNEL_CHECK)\n\t\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_PLATFORM,\n\t\t\t\t\t\t     (const char *)xattr_value,\n\t\t\t\t\t\t     xattr_len,\n\t\t\t\t\t\t     iint->ima_hash->digest,\n\t\t\t\t\t\t     iint->ima_hash->length);\n\t\tif (rc) {\n\t\t\t*cause = \"invalid-signature\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t} else {\n\t\t\t*status = INTEGRITY_PASS;\n\t\t}\n\t\tbreak;\n\tcase IMA_VERITY_DIGSIG:\n\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\n\t\tif (iint->flags & IMA_DIGSIG_REQUIRED) {\n\t\t\tif (!(iint->flags & IMA_VERITY_REQUIRED)) {\n\t\t\t\t*cause = \"IMA-signature-required\";\n\t\t\t\t*status = INTEGRITY_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version != 3) {\n\t\t\t*cause = \"invalid-signature-version\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = calc_file_id_hash(IMA_VERITY_DIGSIG, iint->ima_hash->algo,\n\t\t\t\t       iint->ima_hash->digest, &hash.hdr);\n\t\tif (rc) {\n\t\t\t*cause = \"sigv3-hashing-error\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\n\t\t\t\t\t     (const char *)xattr_value,\n\t\t\t\t\t     xattr_len, hash.digest,\n\t\t\t\t\t     hash.hdr.length);\n\t\tif (rc) {\n\t\t\t*cause = \"invalid-verity-signature\";\n\t\t\t*status = INTEGRITY_FAIL;\n\t\t} else {\n\t\t\t*status = INTEGRITY_PASS;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\t*status = INTEGRITY_UNKNOWN;\n\t\t*cause = \"unknown-ima-data\";\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int modsig_verify(enum ima_hooks func, const struct modsig *modsig,\n\t\t\t enum integrity_status *status, const char **cause)\n{\n\tint rc;\n\n\trc = integrity_modsig_verify(INTEGRITY_KEYRING_IMA, modsig);\n\tif (IS_ENABLED(CONFIG_INTEGRITY_PLATFORM_KEYRING) && rc &&\n\t    func == KEXEC_KERNEL_CHECK)\n\t\trc = integrity_modsig_verify(INTEGRITY_KEYRING_PLATFORM,\n\t\t\t\t\t     modsig);\n\tif (rc) {\n\t\t*cause = \"invalid-signature\";\n\t\t*status = INTEGRITY_FAIL;\n\t} else {\n\t\t*status = INTEGRITY_PASS;\n\t}\n\n\treturn rc;\n}\n\n \nint ima_check_blacklist(struct integrity_iint_cache *iint,\n\t\t\tconst struct modsig *modsig, int pcr)\n{\n\tenum hash_algo hash_algo;\n\tconst u8 *digest = NULL;\n\tu32 digestsize = 0;\n\tint rc = 0;\n\n\tif (!(iint->flags & IMA_CHECK_BLACKLIST))\n\t\treturn 0;\n\n\tif (iint->flags & IMA_MODSIG_ALLOWED && modsig) {\n\t\tima_get_modsig_digest(modsig, &hash_algo, &digest, &digestsize);\n\n\t\trc = is_binary_blacklisted(digest, digestsize);\n\t} else if (iint->flags & IMA_DIGSIG_REQUIRED && iint->ima_hash)\n\t\trc = is_binary_blacklisted(iint->ima_hash->digest, iint->ima_hash->length);\n\n\tif ((rc == -EPERM) && (iint->flags & IMA_MEASURE))\n\t\tprocess_buffer_measurement(&nop_mnt_idmap, NULL, digest, digestsize,\n\t\t\t\t\t   \"blacklisted-hash\", NONE,\n\t\t\t\t\t   pcr, NULL, false, NULL, 0);\n\n\treturn rc;\n}\n\n \nint ima_appraise_measurement(enum ima_hooks func,\n\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t     struct file *file, const unsigned char *filename,\n\t\t\t     struct evm_ima_xattr_data *xattr_value,\n\t\t\t     int xattr_len, const struct modsig *modsig)\n{\n\tstatic const char op[] = \"appraise_data\";\n\tconst char *cause = \"unknown\";\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_backing_inode(dentry);\n\tenum integrity_status status = INTEGRITY_UNKNOWN;\n\tint rc = xattr_len;\n\tbool try_modsig = iint->flags & IMA_MODSIG_ALLOWED && modsig;\n\n\t \n\tif (!(inode->i_opflags & IOP_XATTR) && !try_modsig)\n\t\treturn INTEGRITY_UNKNOWN;\n\n\t \n\tif (rc <= 0 && !try_modsig) {\n\t\tif (rc && rc != -ENODATA)\n\t\t\tgoto out;\n\n\t\tif (iint->flags & IMA_DIGSIG_REQUIRED) {\n\t\t\tif (iint->flags & IMA_VERITY_REQUIRED)\n\t\t\t\tcause = \"verity-signature-required\";\n\t\t\telse\n\t\t\t\tcause = \"IMA-signature-required\";\n\t\t} else {\n\t\t\tcause = \"missing-hash\";\n\t\t}\n\n\t\tstatus = INTEGRITY_NOLABEL;\n\t\tif (file->f_mode & FMODE_CREATED)\n\t\t\tiint->flags |= IMA_NEW_FILE;\n\t\tif ((iint->flags & IMA_NEW_FILE) &&\n\t\t    (!(iint->flags & IMA_DIGSIG_REQUIRED) ||\n\t\t     (inode->i_size == 0)))\n\t\t\tstatus = INTEGRITY_PASS;\n\t\tgoto out;\n\t}\n\n\tstatus = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value,\n\t\t\t\t rc < 0 ? 0 : rc, iint);\n\tswitch (status) {\n\tcase INTEGRITY_PASS:\n\tcase INTEGRITY_PASS_IMMUTABLE:\n\tcase INTEGRITY_UNKNOWN:\n\t\tbreak;\n\tcase INTEGRITY_NOXATTRS:\t \n\t\t \n\t\tif (try_modsig)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase INTEGRITY_NOLABEL:\t\t \n\t\tcause = \"missing-HMAC\";\n\t\tgoto out;\n\tcase INTEGRITY_FAIL_IMMUTABLE:\n\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\t\tcause = \"invalid-fail-immutable\";\n\t\tgoto out;\n\tcase INTEGRITY_FAIL:\t\t \n\t\tcause = \"invalid-HMAC\";\n\t\tgoto out;\n\tdefault:\n\t\tWARN_ONCE(true, \"Unexpected integrity status %d\\n\", status);\n\t}\n\n\tif (xattr_value)\n\t\trc = xattr_verify(func, iint, xattr_value, xattr_len, &status,\n\t\t\t\t  &cause);\n\n\t \n\tif (try_modsig &&\n\t    (!xattr_value || xattr_value->type == IMA_XATTR_DIGEST_NG ||\n\t     rc == -ENOKEY))\n\t\trc = modsig_verify(func, modsig, &status, &cause);\n\nout:\n\t \n\tif ((inode->i_sb->s_iflags & SB_I_IMA_UNVERIFIABLE_SIGNATURE) &&\n\t    ((inode->i_sb->s_iflags & SB_I_UNTRUSTED_MOUNTER) ||\n\t     (iint->flags & IMA_FAIL_UNVERIFIABLE_SIGS))) {\n\t\tstatus = INTEGRITY_FAIL;\n\t\tcause = \"unverifiable-signature\";\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\n\t\t\t\t    op, cause, rc, 0);\n\t} else if (status != INTEGRITY_PASS) {\n\t\t \n\t\tif ((ima_appraise & IMA_APPRAISE_FIX) && !try_modsig &&\n\t\t    (!xattr_value ||\n\t\t     xattr_value->type != EVM_IMA_XATTR_DIGSIG)) {\n\t\t\tif (!ima_fix_xattr(dentry, iint))\n\t\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\n\t\t \n\t\tif (inode->i_size == 0 && iint->flags & IMA_NEW_FILE &&\n\t\t    test_bit(IMA_DIGSIG, &iint->atomic_flags)) {\n\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\n\t\t\t\t    op, cause, rc, 0);\n\t} else {\n\t\tima_cache_flags(iint, func);\n\t}\n\n\tima_set_cache_status(iint, func, status);\n\treturn status;\n}\n\n \nvoid ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tint rc = 0;\n\n\t \n\tif (test_bit(IMA_DIGSIG, &iint->atomic_flags))\n\t\treturn;\n\n\tif ((iint->ima_file_status != INTEGRITY_PASS) &&\n\t    !(iint->flags & IMA_HASH))\n\t\treturn;\n\n\trc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo, NULL);\n\tif (rc < 0)\n\t\treturn;\n\n\tinode_lock(file_inode(file));\n\tima_fix_xattr(dentry, iint);\n\tinode_unlock(file_inode(file));\n}\n\n \nvoid ima_inode_post_setattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct integrity_iint_cache *iint;\n\tint action;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode)\n\t    || !(inode->i_opflags & IOP_XATTR))\n\t\treturn;\n\n\taction = ima_must_appraise(idmap, inode, MAY_ACCESS, POST_SETATTR);\n\tiint = integrity_iint_find(inode);\n\tif (iint) {\n\t\tset_bit(IMA_CHANGE_ATTR, &iint->atomic_flags);\n\t\tif (!action)\n\t\t\tclear_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);\n\t}\n}\n\n \nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\tiint->measured_pcrs = 0;\n\tset_bit(IMA_CHANGE_XATTR, &iint->atomic_flags);\n\tif (digsig)\n\t\tset_bit(IMA_DIGSIG, &iint->atomic_flags);\n\telse\n\t\tclear_bit(IMA_DIGSIG, &iint->atomic_flags);\n}\n\n \nstatic int validate_hash_algo(struct dentry *dentry,\n\t\t\t      const struct evm_ima_xattr_data *xattr_value,\n\t\t\t      size_t xattr_value_len)\n{\n\tchar *path = NULL, *pathbuf = NULL;\n\tenum hash_algo xattr_hash_algo;\n\tconst char *errmsg = \"unavailable-hash-algorithm\";\n\tunsigned int allowed_hashes;\n\n\txattr_hash_algo = ima_get_hash_algo(xattr_value, xattr_value_len);\n\n\tallowed_hashes = atomic_read(&ima_setxattr_allowed_hash_algorithms);\n\n\tif (allowed_hashes) {\n\t\t \n\t\tif (allowed_hashes & (1U << xattr_hash_algo))\n\t\t\treturn 0;\n\n\t\t \n\t\terrmsg = \"denied-hash-algorithm\";\n\t} else {\n\t\tif (likely(xattr_hash_algo == ima_hash_algo))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (crypto_has_alg(hash_algo_name[xattr_hash_algo], 0, 0))\n\t\t\treturn 0;\n\t}\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf)\n\t\treturn -EACCES;\n\n\tpath = dentry_path(dentry, pathbuf, PATH_MAX);\n\n\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, d_inode(dentry), path,\n\t\t\t    \"set_data\", errmsg, -EACCES, 0);\n\n\tkfree(pathbuf);\n\n\treturn -EACCES;\n}\n\nint ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xvalue = xattr_value;\n\tint digsig = 0;\n\tint result;\n\tint err;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len);\n\tif (result == 1) {\n\t\tif (!xattr_value_len || (xvalue->type >= IMA_XATTR_LAST))\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_hash_algo(dentry, xvalue, xattr_value_len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdigsig = (xvalue->type == EVM_IMA_XATTR_DIGSIG);\n\t} else if (!strcmp(xattr_name, XATTR_NAME_EVM) && xattr_value_len > 0) {\n\t\tdigsig = (xvalue->type == EVM_XATTR_PORTABLE_DIGSIG);\n\t}\n\tif (result == 1 || evm_revalidate_status(xattr_name)) {\n\t\tima_reset_appraise_flags(d_backing_inode(dentry), digsig);\n\t\tif (result == 1)\n\t\t\tresult = 0;\n\t}\n\treturn result;\n}\n\nint ima_inode_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      const char *acl_name, struct posix_acl *kacl)\n{\n\tif (evm_revalidate_status(acl_name))\n\t\tima_reset_appraise_flags(d_backing_inode(dentry), 0);\n\n\treturn 0;\n}\n\nint ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tint result;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, NULL, 0);\n\tif (result == 1 || evm_revalidate_status(xattr_name)) {\n\t\tima_reset_appraise_flags(d_backing_inode(dentry), 0);\n\t\tif (result == 1)\n\t\t\tresult = 0;\n\t}\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}