{
  "module_name": "ima_policy.c",
  "hash_id": "0045427f9a7604d1c8b1f0f021e5cf7e7b2bebaf7d0833fd827d2d969513fb03",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_policy.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel_read_file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/ima.h>\n\n#include \"ima.h\"\n\n \n#define IMA_FUNC\t0x0001\n#define IMA_MASK\t0x0002\n#define IMA_FSMAGIC\t0x0004\n#define IMA_UID\t\t0x0008\n#define IMA_FOWNER\t0x0010\n#define IMA_FSUUID\t0x0020\n#define IMA_INMASK\t0x0040\n#define IMA_EUID\t0x0080\n#define IMA_PCR\t\t0x0100\n#define IMA_FSNAME\t0x0200\n#define IMA_KEYRINGS\t0x0400\n#define IMA_LABEL\t0x0800\n#define IMA_VALIDATE_ALGOS\t0x1000\n#define IMA_GID\t\t0x2000\n#define IMA_EGID\t0x4000\n#define IMA_FGROUP\t0x8000\n\n#define UNKNOWN\t\t0\n#define MEASURE\t\t0x0001\t \n#define DONT_MEASURE\t0x0002\n#define APPRAISE\t0x0004\t \n#define DONT_APPRAISE\t0x0008\n#define AUDIT\t\t0x0040\n#define HASH\t\t0x0100\n#define DONT_HASH\t0x0200\n\n#define INVALID_PCR(a) (((a) < 0) || \\\n\t(a) >= (sizeof_field(struct integrity_iint_cache, measured_pcrs) * 8))\n\nint ima_policy_flag;\nstatic int temp_ima_appraise;\nstatic int build_ima_appraise __ro_after_init;\n\natomic_t ima_setxattr_allowed_hash_algorithms;\n\n#define MAX_LSM_RULES 6\nenum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,\n\tLSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE\n};\n\nenum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB };\n\nenum policy_rule_list { IMA_DEFAULT_POLICY = 1, IMA_CUSTOM_POLICY };\n\nstruct ima_rule_opt_list {\n\tsize_t count;\n\tchar *items[] __counted_by(count);\n};\n\n \nstatic inline bool vfsuid_gt_kuid(vfsuid_t vfsuid, kuid_t kuid)\n{\n\treturn __vfsuid_val(vfsuid) > __kuid_val(kuid);\n}\n\nstatic inline bool vfsgid_gt_kgid(vfsgid_t vfsgid, kgid_t kgid)\n{\n\treturn __vfsgid_val(vfsgid) > __kgid_val(kgid);\n}\n\nstatic inline bool vfsuid_lt_kuid(vfsuid_t vfsuid, kuid_t kuid)\n{\n\treturn __vfsuid_val(vfsuid) < __kuid_val(kuid);\n}\n\nstatic inline bool vfsgid_lt_kgid(vfsgid_t vfsgid, kgid_t kgid)\n{\n\treturn __vfsgid_val(vfsgid) < __kgid_val(kgid);\n}\n\nstruct ima_rule_entry {\n\tstruct list_head list;\n\tint action;\n\tunsigned int flags;\n\tenum ima_hooks func;\n\tint mask;\n\tunsigned long fsmagic;\n\tuuid_t fsuuid;\n\tkuid_t uid;\n\tkgid_t gid;\n\tkuid_t fowner;\n\tkgid_t fgroup;\n\tbool (*uid_op)(kuid_t cred_uid, kuid_t rule_uid);     \n\tbool (*gid_op)(kgid_t cred_gid, kgid_t rule_gid);\n\tbool (*fowner_op)(vfsuid_t vfsuid, kuid_t rule_uid);  \n\tbool (*fgroup_op)(vfsgid_t vfsgid, kgid_t rule_gid);  \n\tint pcr;\n\tunsigned int allowed_algos;  \n\tstruct {\n\t\tvoid *rule;\t \n\t\tchar *args_p;\t \n\t\tint type;\t \n\t} lsm[MAX_LSM_RULES];\n\tchar *fsname;\n\tstruct ima_rule_opt_list *keyrings;  \n\tstruct ima_rule_opt_list *label;  \n\tstruct ima_template_desc *template;\n};\n\n \nstatic_assert(\n\t8 * sizeof(unsigned int) >= HASH_ALGO__LAST,\n\t\"The bitfield allowed_algos in ima_rule_entry is too small to contain all the supported hash algorithms, consider using a bigger type\");\n\n \n\n \nstatic struct ima_rule_entry dont_measure_rules[] __ro_after_init = {\n\t{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SMACK_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP2_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = EFIVARFS_MAGIC, .flags = IMA_FSMAGIC}\n};\n\nstatic struct ima_rule_entry original_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n};\n\nstatic struct ima_rule_entry default_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = POLICY_CHECK, .flags = IMA_FUNC},\n};\n\nstatic struct ima_rule_entry default_appraise_rules[] __ro_after_init = {\n\t{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = RAMFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SMACK_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = EFIVARFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP2_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n#ifdef CONFIG_IMA_WRITE_POLICY\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t.flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &vfsuid_eq_kuid,\n\t .flags = IMA_FOWNER},\n#else\n\t \n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &vfsuid_eq_kuid,\n\t .flags = IMA_FOWNER | IMA_DIGSIG_REQUIRED},\n#endif\n};\n\nstatic struct ima_rule_entry build_appraise_rules[] __ro_after_init = {\n#ifdef CONFIG_IMA_APPRAISE_REQUIRE_MODULE_SIGS\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifdef CONFIG_IMA_APPRAISE_REQUIRE_FIRMWARE_SIGS\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifdef CONFIG_IMA_APPRAISE_REQUIRE_KEXEC_SIGS\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifdef CONFIG_IMA_APPRAISE_REQUIRE_POLICY_SIGS\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n};\n\nstatic struct ima_rule_entry secure_boot_rules[] __ro_after_init = {\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n};\n\nstatic struct ima_rule_entry critical_data_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = CRITICAL_DATA, .flags = IMA_FUNC},\n};\n\n \nstatic struct ima_rule_entry *arch_policy_entry __ro_after_init;\n\nstatic LIST_HEAD(ima_default_rules);\nstatic LIST_HEAD(ima_policy_rules);\nstatic LIST_HEAD(ima_temp_rules);\nstatic struct list_head __rcu *ima_rules = (struct list_head __rcu *)(&ima_default_rules);\n\nstatic int ima_policy __initdata;\n\nstatic int __init default_measure_policy_setup(char *str)\n{\n\tif (ima_policy)\n\t\treturn 1;\n\n\tima_policy = ORIGINAL_TCB;\n\treturn 1;\n}\n__setup(\"ima_tcb\", default_measure_policy_setup);\n\nstatic bool ima_use_appraise_tcb __initdata;\nstatic bool ima_use_secure_boot __initdata;\nstatic bool ima_use_critical_data __initdata;\nstatic bool ima_fail_unverifiable_sigs __ro_after_init;\nstatic int __init policy_setup(char *str)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&str, \" |\\n\")) != NULL) {\n\t\tif (*p == ' ')\n\t\t\tcontinue;\n\t\tif ((strcmp(p, \"tcb\") == 0) && !ima_policy)\n\t\t\tima_policy = DEFAULT_TCB;\n\t\telse if (strcmp(p, \"appraise_tcb\") == 0)\n\t\t\tima_use_appraise_tcb = true;\n\t\telse if (strcmp(p, \"secure_boot\") == 0)\n\t\t\tima_use_secure_boot = true;\n\t\telse if (strcmp(p, \"critical_data\") == 0)\n\t\t\tima_use_critical_data = true;\n\t\telse if (strcmp(p, \"fail_securely\") == 0)\n\t\t\tima_fail_unverifiable_sigs = true;\n\t\telse\n\t\t\tpr_err(\"policy \\\"%s\\\" not found\", p);\n\t}\n\n\treturn 1;\n}\n__setup(\"ima_policy=\", policy_setup);\n\nstatic int __init default_appraise_policy_setup(char *str)\n{\n\tima_use_appraise_tcb = true;\n\treturn 1;\n}\n__setup(\"ima_appraise_tcb\", default_appraise_policy_setup);\n\nstatic struct ima_rule_opt_list *ima_alloc_rule_opt_list(const substring_t *src)\n{\n\tstruct ima_rule_opt_list *opt_list;\n\tsize_t count = 0;\n\tchar *src_copy;\n\tchar *cur, *next;\n\tsize_t i;\n\n\tsrc_copy = match_strdup(src);\n\tif (!src_copy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnext = src_copy;\n\twhile ((cur = strsep(&next, \"|\"))) {\n\t\t \n\t\tif (!(*cur)) {\n\t\t\tkfree(src_copy);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tcount++;\n\t}\n\n\t \n\tif (!count) {\n\t\tkfree(src_copy);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\topt_list = kzalloc(struct_size(opt_list, items, count), GFP_KERNEL);\n\tif (!opt_list) {\n\t\tkfree(src_copy);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\topt_list->count = count;\n\n\t \n\tfor (i = 0, cur = src_copy; i < count; i++) {\n\t\topt_list->items[i] = cur;\n\t\tcur = strchr(cur, '\\0') + 1;\n\t}\n\n\treturn opt_list;\n}\n\nstatic void ima_free_rule_opt_list(struct ima_rule_opt_list *opt_list)\n{\n\tif (!opt_list)\n\t\treturn;\n\n\tif (opt_list->count) {\n\t\tkfree(opt_list->items[0]);\n\t\topt_list->count = 0;\n\t}\n\n\tkfree(opt_list);\n}\n\nstatic void ima_lsm_free_rule(struct ima_rule_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tima_filter_rule_free(entry->lsm[i].rule);\n\t\tkfree(entry->lsm[i].args_p);\n\t}\n}\n\nstatic void ima_free_rule(struct ima_rule_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\t \n\tkfree(entry->fsname);\n\tima_free_rule_opt_list(entry->keyrings);\n\tima_lsm_free_rule(entry);\n\tkfree(entry);\n}\n\nstatic struct ima_rule_entry *ima_lsm_copy_rule(struct ima_rule_entry *entry)\n{\n\tstruct ima_rule_entry *nentry;\n\tint i;\n\n\t \n\tnentry = kmemdup(entry, sizeof(*nentry), GFP_KERNEL);\n\tif (!nentry)\n\t\treturn NULL;\n\n\tmemset(nentry->lsm, 0, sizeof_field(struct ima_rule_entry, lsm));\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tif (!entry->lsm[i].args_p)\n\t\t\tcontinue;\n\n\t\tnentry->lsm[i].type = entry->lsm[i].type;\n\t\tnentry->lsm[i].args_p = entry->lsm[i].args_p;\n\n\t\tima_filter_rule_init(nentry->lsm[i].type, Audit_equal,\n\t\t\t\t     nentry->lsm[i].args_p,\n\t\t\t\t     &nentry->lsm[i].rule);\n\t\tif (!nentry->lsm[i].rule)\n\t\t\tpr_warn(\"rule for LSM \\'%s\\' is undefined\\n\",\n\t\t\t\tnentry->lsm[i].args_p);\n\t}\n\treturn nentry;\n}\n\nstatic int ima_lsm_update_rule(struct ima_rule_entry *entry)\n{\n\tint i;\n\tstruct ima_rule_entry *nentry;\n\n\tnentry = ima_lsm_copy_rule(entry);\n\tif (!nentry)\n\t\treturn -ENOMEM;\n\n\tlist_replace_rcu(&entry->list, &nentry->list);\n\tsynchronize_rcu();\n\t \n\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\tima_filter_rule_free(entry->lsm[i].rule);\n\tkfree(entry);\n\n\treturn 0;\n}\n\nstatic bool ima_rule_contains_lsm_cond(struct ima_rule_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\tif (entry->lsm[i].args_p)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void ima_lsm_update_rules(void)\n{\n\tstruct ima_rule_entry *entry, *e;\n\tint result;\n\n\tlist_for_each_entry_safe(entry, e, &ima_policy_rules, list) {\n\t\tif (!ima_rule_contains_lsm_cond(entry))\n\t\t\tcontinue;\n\n\t\tresult = ima_lsm_update_rule(entry);\n\t\tif (result) {\n\t\t\tpr_err(\"lsm rule update error %d\\n\", result);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint ima_lsm_policy_change(struct notifier_block *nb, unsigned long event,\n\t\t\t  void *lsm_data)\n{\n\tif (event != LSM_POLICY_CHANGE)\n\t\treturn NOTIFY_DONE;\n\n\tima_lsm_update_rules();\n\treturn NOTIFY_OK;\n}\n\n \nstatic bool ima_match_rule_data(struct ima_rule_entry *rule,\n\t\t\t\tconst char *func_data,\n\t\t\t\tconst struct cred *cred)\n{\n\tconst struct ima_rule_opt_list *opt_list = NULL;\n\tbool matched = false;\n\tsize_t i;\n\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\n\tswitch (rule->func) {\n\tcase KEY_CHECK:\n\t\tif (!rule->keyrings)\n\t\t\treturn true;\n\n\t\topt_list = rule->keyrings;\n\t\tbreak;\n\tcase CRITICAL_DATA:\n\t\tif (!rule->label)\n\t\t\treturn true;\n\n\t\topt_list = rule->label;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!func_data)\n\t\treturn false;\n\n\tfor (i = 0; i < opt_list->count; i++) {\n\t\tif (!strcmp(opt_list->items[i], func_data)) {\n\t\t\tmatched = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn matched;\n}\n\n \nstatic bool ima_match_rules(struct ima_rule_entry *rule,\n\t\t\t    struct mnt_idmap *idmap,\n\t\t\t    struct inode *inode, const struct cred *cred,\n\t\t\t    u32 secid, enum ima_hooks func, int mask,\n\t\t\t    const char *func_data)\n{\n\tint i;\n\tbool result = false;\n\tstruct ima_rule_entry *lsm_rule = rule;\n\tbool rule_reinitialized = false;\n\n\tif ((rule->flags & IMA_FUNC) &&\n\t    (rule->func != func && func != POST_SETATTR))\n\t\treturn false;\n\n\tswitch (func) {\n\tcase KEY_CHECK:\n\tcase CRITICAL_DATA:\n\t\treturn ((rule->func == func) &&\n\t\t\tima_match_rule_data(rule, func_data, cred));\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((rule->flags & IMA_MASK) &&\n\t    (rule->mask != mask && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_INMASK) &&\n\t    (!(rule->mask & mask) && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSNAME)\n\t    && strcmp(rule->fsname, inode->i_sb->s_type->name))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSUUID) &&\n\t    !uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\tif (rule->flags & IMA_EUID) {\n\t\tif (has_capability_noaudit(current, CAP_SETUID)) {\n\t\t\tif (!rule->uid_op(cred->euid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->suid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->uid, rule->uid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->uid_op(cred->euid, rule->uid))\n\t\t\treturn false;\n\t}\n\tif ((rule->flags & IMA_GID) && !rule->gid_op(cred->gid, rule->gid))\n\t\treturn false;\n\tif (rule->flags & IMA_EGID) {\n\t\tif (has_capability_noaudit(current, CAP_SETGID)) {\n\t\t\tif (!rule->gid_op(cred->egid, rule->gid)\n\t\t\t    && !rule->gid_op(cred->sgid, rule->gid)\n\t\t\t    && !rule->gid_op(cred->gid, rule->gid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->gid_op(cred->egid, rule->gid))\n\t\t\treturn false;\n\t}\n\tif ((rule->flags & IMA_FOWNER) &&\n\t    !rule->fowner_op(i_uid_into_vfsuid(idmap, inode),\n\t\t\t     rule->fowner))\n\t\treturn false;\n\tif ((rule->flags & IMA_FGROUP) &&\n\t    !rule->fgroup_op(i_gid_into_vfsgid(idmap, inode),\n\t\t\t     rule->fgroup))\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid;\n\n\t\tif (!lsm_rule->lsm[i].rule) {\n\t\t\tif (!lsm_rule->lsm[i].args_p)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\nretry:\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = ima_filter_rule_match(osid, lsm_rule->lsm[i].type,\n\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t   lsm_rule->lsm[i].rule);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\trc = ima_filter_rule_match(secid, lsm_rule->lsm[i].type,\n\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t   lsm_rule->lsm[i].rule);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == -ESTALE && !rule_reinitialized) {\n\t\t\tlsm_rule = ima_lsm_copy_rule(rule);\n\t\t\tif (lsm_rule) {\n\t\t\t\trule_reinitialized = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\tif (!rc) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tresult = true;\n\nout:\n\tif (rule_reinitialized) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\t\tima_filter_rule_free(lsm_rule->lsm[i].rule);\n\t\tkfree(lsm_rule);\n\t}\n\treturn result;\n}\n\n \nstatic int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\n{\n\tif (!(rule->flags & IMA_FUNC))\n\t\treturn IMA_FILE_APPRAISE;\n\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\tcase MMAP_CHECK_REQPROT:\n\t\treturn IMA_MMAP_APPRAISE;\n\tcase BPRM_CHECK:\n\t\treturn IMA_BPRM_APPRAISE;\n\tcase CREDS_CHECK:\n\t\treturn IMA_CREDS_APPRAISE;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn IMA_FILE_APPRAISE;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn IMA_READ_APPRAISE;\n\t}\n}\n\n \nint ima_match_policy(struct mnt_idmap *idmap, struct inode *inode,\n\t\t     const struct cred *cred, u32 secid, enum ima_hooks func,\n\t\t     int mask, int flags, int *pcr,\n\t\t     struct ima_template_desc **template_desc,\n\t\t     const char *func_data, unsigned int *allowed_algos)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\tstruct list_head *ima_rules_tmp;\n\n\tif (template_desc && !*template_desc)\n\t\t*template_desc = ima_template_desc_current();\n\n\trcu_read_lock();\n\tima_rules_tmp = rcu_dereference(ima_rules);\n\tlist_for_each_entry_rcu(entry, ima_rules_tmp, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, idmap, inode, cred, secid,\n\t\t\t\t     func, mask, func_data))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_NONACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE) {\n\t\t\taction |= get_subaction(entry, func);\n\t\t\taction &= ~IMA_HASH;\n\t\t\tif (ima_fail_unverifiable_sigs)\n\t\t\t\taction |= IMA_FAIL_UNVERIFIABLE_SIGS;\n\n\t\t\tif (allowed_algos &&\n\t\t\t    entry->flags & IMA_VALIDATE_ALGOS)\n\t\t\t\t*allowed_algos = entry->allowed_algos;\n\t\t}\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (template_desc && entry->template)\n\t\t\t*template_desc = entry->template;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}\n\n \nvoid ima_update_policy_flags(void)\n{\n\tstruct ima_rule_entry *entry;\n\tint new_policy_flag = 0;\n\tstruct list_head *ima_rules_tmp;\n\n\trcu_read_lock();\n\tima_rules_tmp = rcu_dereference(ima_rules);\n\tlist_for_each_entry_rcu(entry, ima_rules_tmp, list) {\n\t\t \n\t\tif (entry->func == SETXATTR_CHECK) {\n\t\t\tatomic_cmpxchg(&ima_setxattr_allowed_hash_algorithms,\n\t\t\t\t       0, entry->allowed_algos);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tnew_policy_flag |= entry->action;\n\t}\n\trcu_read_unlock();\n\n\tima_appraise |= (build_ima_appraise | temp_ima_appraise);\n\tif (!ima_appraise)\n\t\tnew_policy_flag &= ~IMA_APPRAISE;\n\n\tima_policy_flag = new_policy_flag;\n}\n\nstatic int ima_appraise_flag(enum ima_hooks func)\n{\n\tif (func == MODULE_CHECK)\n\t\treturn IMA_APPRAISE_MODULES;\n\telse if (func == FIRMWARE_CHECK)\n\t\treturn IMA_APPRAISE_FIRMWARE;\n\telse if (func == POLICY_CHECK)\n\t\treturn IMA_APPRAISE_POLICY;\n\telse if (func == KEXEC_KERNEL_CHECK)\n\t\treturn IMA_APPRAISE_KEXEC;\n\treturn 0;\n}\n\nstatic void add_rules(struct ima_rule_entry *entries, int count,\n\t\t      enum policy_rule_list policy_rule)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct ima_rule_entry *entry;\n\n\t\tif (policy_rule & IMA_DEFAULT_POLICY)\n\t\t\tlist_add_tail(&entries[i].list, &ima_default_rules);\n\n\t\tif (policy_rule & IMA_CUSTOM_POLICY) {\n\t\t\tentry = kmemdup(&entries[i], sizeof(*entry),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!entry)\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&entry->list, &ima_policy_rules);\n\t\t}\n\t\tif (entries[i].action == APPRAISE) {\n\t\t\tif (entries != build_appraise_rules)\n\t\t\t\ttemp_ima_appraise |=\n\t\t\t\t\tima_appraise_flag(entries[i].func);\n\t\t\telse\n\t\t\t\tbuild_ima_appraise |=\n\t\t\t\t\tima_appraise_flag(entries[i].func);\n\t\t}\n\t}\n}\n\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry);\n\nstatic int __init ima_init_arch_policy(void)\n{\n\tconst char * const *arch_rules;\n\tconst char * const *rules;\n\tint arch_entries = 0;\n\tint i = 0;\n\n\tarch_rules = arch_get_ima_policy();\n\tif (!arch_rules)\n\t\treturn arch_entries;\n\n\t \n\tfor (rules = arch_rules; *rules != NULL; rules++)\n\t\tarch_entries++;\n\n\tarch_policy_entry = kcalloc(arch_entries + 1,\n\t\t\t\t    sizeof(*arch_policy_entry), GFP_KERNEL);\n\tif (!arch_policy_entry)\n\t\treturn 0;\n\n\t \n\tfor (rules = arch_rules, i = 0; *rules != NULL; rules++) {\n\t\tchar rule[255];\n\t\tint result;\n\n\t\tresult = strscpy(rule, *rules, sizeof(rule));\n\n\t\tINIT_LIST_HEAD(&arch_policy_entry[i].list);\n\t\tresult = ima_parse_rule(rule, &arch_policy_entry[i]);\n\t\tif (result) {\n\t\t\tpr_warn(\"Skipping unknown architecture policy rule: %s\\n\",\n\t\t\t\trule);\n\t\t\tmemset(&arch_policy_entry[i], 0,\n\t\t\t       sizeof(*arch_policy_entry));\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}\n\n \nvoid __init ima_init_policy(void)\n{\n\tint build_appraise_entries, arch_entries;\n\n\t \n\tif (ima_policy)\n\t\tadd_rules(dont_measure_rules, ARRAY_SIZE(dont_measure_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\n\tswitch (ima_policy) {\n\tcase ORIGINAL_TCB:\n\t\tadd_rules(original_measurement_rules,\n\t\t\t  ARRAY_SIZE(original_measurement_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\t\tbreak;\n\tcase DEFAULT_TCB:\n\t\tadd_rules(default_measurement_rules,\n\t\t\t  ARRAY_SIZE(default_measurement_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tarch_entries = ima_init_arch_policy();\n\tif (!arch_entries)\n\t\tpr_info(\"No architecture policies found\\n\");\n\telse\n\t\tadd_rules(arch_policy_entry, arch_entries,\n\t\t\t  IMA_DEFAULT_POLICY | IMA_CUSTOM_POLICY);\n\n\t \n\tif (ima_use_secure_boot)\n\t\tadd_rules(secure_boot_rules, ARRAY_SIZE(secure_boot_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\n\t \n\tbuild_appraise_entries = ARRAY_SIZE(build_appraise_rules);\n\tif (build_appraise_entries) {\n\t\tif (ima_use_secure_boot)\n\t\t\tadd_rules(build_appraise_rules, build_appraise_entries,\n\t\t\t\t  IMA_CUSTOM_POLICY);\n\t\telse\n\t\t\tadd_rules(build_appraise_rules, build_appraise_entries,\n\t\t\t\t  IMA_DEFAULT_POLICY | IMA_CUSTOM_POLICY);\n\t}\n\n\tif (ima_use_appraise_tcb)\n\t\tadd_rules(default_appraise_rules,\n\t\t\t  ARRAY_SIZE(default_appraise_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\n\tif (ima_use_critical_data)\n\t\tadd_rules(critical_data_rules,\n\t\t\t  ARRAY_SIZE(critical_data_rules),\n\t\t\t  IMA_DEFAULT_POLICY);\n\n\tatomic_set(&ima_setxattr_allowed_hash_algorithms, 0);\n\n\tima_update_policy_flags();\n}\n\n \nint ima_check_policy(void)\n{\n\tif (list_empty(&ima_temp_rules))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nvoid ima_update_policy(void)\n{\n\tstruct list_head *policy = &ima_policy_rules;\n\n\tlist_splice_tail_init_rcu(&ima_temp_rules, policy, synchronize_rcu);\n\n\tif (ima_rules != (struct list_head __rcu *)policy) {\n\t\tima_policy_flag = 0;\n\n\t\trcu_assign_pointer(ima_rules, policy);\n\t\t \n\t\tkfree(arch_policy_entry);\n\t}\n\tima_update_policy_flags();\n\n\t \n\tima_process_queued_keys();\n}\n\n \nenum policy_opt {\n\tOpt_measure, Opt_dont_measure,\n\tOpt_appraise, Opt_dont_appraise,\n\tOpt_audit, Opt_hash, Opt_dont_hash,\n\tOpt_obj_user, Opt_obj_role, Opt_obj_type,\n\tOpt_subj_user, Opt_subj_role, Opt_subj_type,\n\tOpt_func, Opt_mask, Opt_fsmagic, Opt_fsname, Opt_fsuuid,\n\tOpt_uid_eq, Opt_euid_eq, Opt_gid_eq, Opt_egid_eq,\n\tOpt_fowner_eq, Opt_fgroup_eq,\n\tOpt_uid_gt, Opt_euid_gt, Opt_gid_gt, Opt_egid_gt,\n\tOpt_fowner_gt, Opt_fgroup_gt,\n\tOpt_uid_lt, Opt_euid_lt, Opt_gid_lt, Opt_egid_lt,\n\tOpt_fowner_lt, Opt_fgroup_lt,\n\tOpt_digest_type,\n\tOpt_appraise_type, Opt_appraise_flag, Opt_appraise_algos,\n\tOpt_permit_directio, Opt_pcr, Opt_template, Opt_keyrings,\n\tOpt_label, Opt_err\n};\n\nstatic const match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_appraise, \"appraise\"},\n\t{Opt_dont_appraise, \"dont_appraise\"},\n\t{Opt_audit, \"audit\"},\n\t{Opt_hash, \"hash\"},\n\t{Opt_dont_hash, \"dont_hash\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_fsname, \"fsname=%s\"},\n\t{Opt_fsuuid, \"fsuuid=%s\"},\n\t{Opt_uid_eq, \"uid=%s\"},\n\t{Opt_euid_eq, \"euid=%s\"},\n\t{Opt_gid_eq, \"gid=%s\"},\n\t{Opt_egid_eq, \"egid=%s\"},\n\t{Opt_fowner_eq, \"fowner=%s\"},\n\t{Opt_fgroup_eq, \"fgroup=%s\"},\n\t{Opt_uid_gt, \"uid>%s\"},\n\t{Opt_euid_gt, \"euid>%s\"},\n\t{Opt_gid_gt, \"gid>%s\"},\n\t{Opt_egid_gt, \"egid>%s\"},\n\t{Opt_fowner_gt, \"fowner>%s\"},\n\t{Opt_fgroup_gt, \"fgroup>%s\"},\n\t{Opt_uid_lt, \"uid<%s\"},\n\t{Opt_euid_lt, \"euid<%s\"},\n\t{Opt_gid_lt, \"gid<%s\"},\n\t{Opt_egid_lt, \"egid<%s\"},\n\t{Opt_fowner_lt, \"fowner<%s\"},\n\t{Opt_fgroup_lt, \"fgroup<%s\"},\n\t{Opt_digest_type, \"digest_type=%s\"},\n\t{Opt_appraise_type, \"appraise_type=%s\"},\n\t{Opt_appraise_flag, \"appraise_flag=%s\"},\n\t{Opt_appraise_algos, \"appraise_algos=%s\"},\n\t{Opt_permit_directio, \"permit_directio\"},\n\t{Opt_pcr, \"pcr=%s\"},\n\t{Opt_template, \"template=%s\"},\n\t{Opt_keyrings, \"keyrings=%s\"},\n\t{Opt_label, \"label=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ima_lsm_rule_init(struct ima_rule_entry *entry,\n\t\t\t     substring_t *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].args_p = match_strdup(args);\n\tif (!entry->lsm[lsm_rule].args_p)\n\t\treturn -ENOMEM;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = ima_filter_rule_init(entry->lsm[lsm_rule].type, Audit_equal,\n\t\t\t\t      entry->lsm[lsm_rule].args_p,\n\t\t\t\t      &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule) {\n\t\tpr_warn(\"rule for LSM \\'%s\\' is undefined\\n\",\n\t\t\tentry->lsm[lsm_rule].args_p);\n\n\t\tif (ima_rules == (struct list_head __rcu *)(&ima_default_rules)) {\n\t\t\tkfree(entry->lsm[lsm_rule].args_p);\n\t\t\tentry->lsm[lsm_rule].args_p = NULL;\n\t\t\tresult = -EINVAL;\n\t\t} else\n\t\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\nstatic void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      enum policy_opt rule_operator)\n{\n\tif (!ab)\n\t\treturn;\n\n\tswitch (rule_operator) {\n\tcase Opt_uid_gt:\n\tcase Opt_euid_gt:\n\tcase Opt_gid_gt:\n\tcase Opt_egid_gt:\n\tcase Opt_fowner_gt:\n\tcase Opt_fgroup_gt:\n\t\taudit_log_format(ab, \"%s>\", key);\n\t\tbreak;\n\tcase Opt_uid_lt:\n\tcase Opt_euid_lt:\n\tcase Opt_gid_lt:\n\tcase Opt_egid_lt:\n\tcase Opt_fowner_lt:\n\tcase Opt_fgroup_lt:\n\t\taudit_log_format(ab, \"%s<\", key);\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \"%s=\", key);\n\t}\n\taudit_log_format(ab, \"%s \", value);\n}\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\tima_log_string_op(ab, key, value, Opt_err);\n}\n\n \nstatic void check_template_modsig(const struct ima_template_desc *template)\n{\n#define MSG \"template with 'modsig' field also needs 'd-modsig' field\\n\"\n\tbool has_modsig, has_dmodsig;\n\tstatic bool checked;\n\tint i;\n\n\t \n\tif (checked)\n\t\treturn;\n\n\thas_modsig = has_dmodsig = false;\n\tfor (i = 0; i < template->num_fields; i++) {\n\t\tif (!strcmp(template->fields[i]->field_id, \"modsig\"))\n\t\t\thas_modsig = true;\n\t\telse if (!strcmp(template->fields[i]->field_id, \"d-modsig\"))\n\t\t\thas_dmodsig = true;\n\t}\n\n\tif (has_modsig && !has_dmodsig)\n\t\tpr_notice(MSG);\n\n\tchecked = true;\n#undef MSG\n}\n\n \nstatic void check_template_field(const struct ima_template_desc *template,\n\t\t\t\t const char *field, const char *msg)\n{\n\tint i;\n\n\tfor (i = 0; i < template->num_fields; i++)\n\t\tif (!strcmp(template->fields[i]->field_id, field))\n\t\t\treturn;\n\n\tpr_notice_once(\"%s\", msg);\n}\n\nstatic bool ima_validate_rule(struct ima_rule_entry *entry)\n{\n\t \n\tif (entry->action == UNKNOWN)\n\t\treturn false;\n\n\tif (entry->action != MEASURE && entry->flags & IMA_PCR)\n\t\treturn false;\n\n\tif (entry->action != APPRAISE &&\n\t    entry->flags & (IMA_DIGSIG_REQUIRED | IMA_MODSIG_ALLOWED |\n\t\t\t    IMA_CHECK_BLACKLIST | IMA_VALIDATE_ALGOS))\n\t\treturn false;\n\n\t \n\tif (((entry->flags & IMA_FUNC) && entry->func == NONE) ||\n\t    (!(entry->flags & IMA_FUNC) && entry->func != NONE))\n\t\treturn false;\n\n\t \n\tswitch (entry->func) {\n\tcase NONE:\n\tcase FILE_CHECK:\n\tcase MMAP_CHECK:\n\tcase MMAP_CHECK_REQPROT:\n\tcase BPRM_CHECK:\n\tcase CREDS_CHECK:\n\tcase POST_SETATTR:\n\tcase FIRMWARE_CHECK:\n\tcase POLICY_CHECK:\n\t\tif (entry->flags & ~(IMA_FUNC | IMA_MASK | IMA_FSMAGIC |\n\t\t\t\t     IMA_UID | IMA_FOWNER | IMA_FSUUID |\n\t\t\t\t     IMA_INMASK | IMA_EUID | IMA_PCR |\n\t\t\t\t     IMA_FSNAME | IMA_GID | IMA_EGID |\n\t\t\t\t     IMA_FGROUP | IMA_DIGSIG_REQUIRED |\n\t\t\t\t     IMA_PERMIT_DIRECTIO | IMA_VALIDATE_ALGOS |\n\t\t\t\t     IMA_CHECK_BLACKLIST | IMA_VERITY_REQUIRED))\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase MODULE_CHECK:\n\tcase KEXEC_KERNEL_CHECK:\n\tcase KEXEC_INITRAMFS_CHECK:\n\t\tif (entry->flags & ~(IMA_FUNC | IMA_MASK | IMA_FSMAGIC |\n\t\t\t\t     IMA_UID | IMA_FOWNER | IMA_FSUUID |\n\t\t\t\t     IMA_INMASK | IMA_EUID | IMA_PCR |\n\t\t\t\t     IMA_FSNAME | IMA_GID | IMA_EGID |\n\t\t\t\t     IMA_FGROUP | IMA_DIGSIG_REQUIRED |\n\t\t\t\t     IMA_PERMIT_DIRECTIO | IMA_MODSIG_ALLOWED |\n\t\t\t\t     IMA_CHECK_BLACKLIST | IMA_VALIDATE_ALGOS))\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase KEXEC_CMDLINE:\n\t\tif (entry->action & ~(MEASURE | DONT_MEASURE))\n\t\t\treturn false;\n\n\t\tif (entry->flags & ~(IMA_FUNC | IMA_FSMAGIC | IMA_UID |\n\t\t\t\t     IMA_FOWNER | IMA_FSUUID | IMA_EUID |\n\t\t\t\t     IMA_PCR | IMA_FSNAME | IMA_GID | IMA_EGID |\n\t\t\t\t     IMA_FGROUP))\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase KEY_CHECK:\n\t\tif (entry->action & ~(MEASURE | DONT_MEASURE))\n\t\t\treturn false;\n\n\t\tif (entry->flags & ~(IMA_FUNC | IMA_UID | IMA_GID | IMA_PCR |\n\t\t\t\t     IMA_KEYRINGS))\n\t\t\treturn false;\n\n\t\tif (ima_rule_contains_lsm_cond(entry))\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase CRITICAL_DATA:\n\t\tif (entry->action & ~(MEASURE | DONT_MEASURE))\n\t\t\treturn false;\n\n\t\tif (entry->flags & ~(IMA_FUNC | IMA_UID | IMA_GID | IMA_PCR |\n\t\t\t\t     IMA_LABEL))\n\t\t\treturn false;\n\n\t\tif (ima_rule_contains_lsm_cond(entry))\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase SETXATTR_CHECK:\n\t\t \n\t\tif (entry->action != APPRAISE)\n\t\t\treturn false;\n\n\t\t \n\t\tif (!(entry->flags & IMA_VALIDATE_ALGOS))\n\t\t\treturn false;\n\n\t\t \n\t\tif (entry->flags & ~(IMA_FUNC | IMA_VALIDATE_ALGOS))\n\t\t\treturn false;\n\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tif (entry->flags & IMA_CHECK_BLACKLIST &&\n\t    !(entry->flags & IMA_DIGSIG_REQUIRED))\n\t\treturn false;\n\n\t \n\tif (entry->action == APPRAISE &&\n\t    (entry->flags & IMA_VERITY_REQUIRED) &&\n\t    !(entry->flags & IMA_DIGSIG_REQUIRED))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic unsigned int ima_parse_appraise_algos(char *arg)\n{\n\tunsigned int res = 0;\n\tint idx;\n\tchar *token;\n\n\twhile ((token = strsep(&arg, \",\")) != NULL) {\n\t\tidx = match_string(hash_algo_name, HASH_ALGO__LAST, token);\n\n\t\tif (idx < 0) {\n\t\t\tpr_err(\"unknown hash algorithm \\\"%s\\\"\",\n\t\t\t       token);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!crypto_has_alg(hash_algo_name[idx], 0, 0)) {\n\t\t\tpr_err(\"unavailable hash algorithm \\\"%s\\\", check your kernel configuration\",\n\t\t\t       token);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tres |= (1U << idx);\n\t}\n\n\treturn res;\n}\n\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *from;\n\tchar *p;\n\tbool eid_token;  \n\tstruct ima_template_desc *template_desc;\n\tint result = 0;\n\n\tab = integrity_audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t\t       AUDIT_INTEGRITY_POLICY_RULE);\n\n\tentry->uid = INVALID_UID;\n\tentry->gid = INVALID_GID;\n\tentry->fowner = INVALID_UID;\n\tentry->fgroup = INVALID_GID;\n\tentry->uid_op = &uid_eq;\n\tentry->gid_op = &gid_eq;\n\tentry->fowner_op = &vfsuid_eq_kuid;\n\tentry->fgroup_op = &vfsgid_eq_kgid;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_appraise:\n\t\t\tima_log_string(ab, \"action\", \"appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_dont_appraise:\n\t\t\tima_log_string(ab, \"action\", \"dont_appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_audit:\n\t\t\tima_log_string(ab, \"action\", \"audit\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = AUDIT;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tima_log_string(ab, \"action\", \"hash\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = HASH;\n\t\t\tbreak;\n\t\tcase Opt_dont_hash:\n\t\t\tima_log_string(ab, \"action\", \"dont_hash\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_HASH;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t \n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"MODULE_CHECK\") == 0)\n\t\t\t\tentry->func = MODULE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FIRMWARE_CHECK\") == 0)\n\t\t\t\tentry->func = FIRMWARE_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\t|| (strcmp(args[0].from, \"MMAP_CHECK\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"MMAP_CHECK_REQPROT\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK_REQPROT;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"CREDS_CHECK\") == 0)\n\t\t\t\tentry->func = CREDS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_KERNEL_CHECK\") ==\n\t\t\t\t 0)\n\t\t\t\tentry->func = KEXEC_KERNEL_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_INITRAMFS_CHECK\")\n\t\t\t\t == 0)\n\t\t\t\tentry->func = KEXEC_INITRAMFS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"POLICY_CHECK\") == 0)\n\t\t\t\tentry->func = POLICY_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_CMDLINE\") == 0)\n\t\t\t\tentry->func = KEXEC_CMDLINE;\n\t\t\telse if (IS_ENABLED(CONFIG_IMA_MEASURE_ASYMMETRIC_KEYS) &&\n\t\t\t\t strcmp(args[0].from, \"KEY_CHECK\") == 0)\n\t\t\t\tentry->func = KEY_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"CRITICAL_DATA\") == 0)\n\t\t\t\tentry->func = CRITICAL_DATA;\n\t\t\telse if (strcmp(args[0].from, \"SETXATTR_CHECK\") == 0)\n\t\t\t\tentry->func = SETXATTR_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tfrom = args[0].from;\n\t\t\tif (*from == '^')\n\t\t\t\tfrom++;\n\n\t\t\tif ((strcmp(from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= (*args[0].from == '^')\n\t\t\t\t     ? IMA_INMASK : IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_fsname:\n\t\t\tima_log_string(ab, \"fsname\", args[0].from);\n\n\t\t\tentry->fsname = kstrdup(args[0].from, GFP_KERNEL);\n\t\t\tif (!entry->fsname) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = 0;\n\t\t\tentry->flags |= IMA_FSNAME;\n\t\t\tbreak;\n\t\tcase Opt_keyrings:\n\t\t\tima_log_string(ab, \"keyrings\", args[0].from);\n\n\t\t\tif (!IS_ENABLED(CONFIG_IMA_MEASURE_ASYMMETRIC_KEYS) ||\n\t\t\t    entry->keyrings) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->keyrings = ima_alloc_rule_opt_list(args);\n\t\t\tif (IS_ERR(entry->keyrings)) {\n\t\t\t\tresult = PTR_ERR(entry->keyrings);\n\t\t\t\tentry->keyrings = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->flags |= IMA_KEYRINGS;\n\t\t\tbreak;\n\t\tcase Opt_label:\n\t\t\tima_log_string(ab, \"label\", args[0].from);\n\n\t\t\tif (entry->label) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->label = ima_alloc_rule_opt_list(args);\n\t\t\tif (IS_ERR(entry->label)) {\n\t\t\t\tresult = PTR_ERR(entry->label);\n\t\t\t\tentry->label = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->flags |= IMA_LABEL;\n\t\t\tbreak;\n\t\tcase Opt_fsuuid:\n\t\t\tima_log_string(ab, \"fsuuid\", args[0].from);\n\n\t\t\tif (!uuid_is_null(&entry->fsuuid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = uuid_parse(args[0].from, &entry->fsuuid);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSUUID;\n\t\t\tbreak;\n\t\tcase Opt_uid_gt:\n\t\tcase Opt_euid_gt:\n\t\t\tentry->uid_op = &uid_gt;\n\t\t\tfallthrough;\n\t\tcase Opt_uid_lt:\n\t\tcase Opt_euid_lt:\n\t\t\tif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\n\t\t\t\tentry->uid_op = &uid_lt;\n\t\t\tfallthrough;\n\t\tcase Opt_uid_eq:\n\t\tcase Opt_euid_eq:\n\t\t\teid_token = (token == Opt_euid_eq) ||\n\t\t\t\t    (token == Opt_euid_gt) ||\n\t\t\t\t    (token == Opt_euid_lt);\n\n\t\t\tima_log_string_op(ab, eid_token ? \"euid\" : \"uid\",\n\t\t\t\t\t  args[0].from, token);\n\n\t\t\tif (uid_valid(entry->uid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = make_kuid(current_user_ns(),\n\t\t\t\t\t\t       (uid_t) lnum);\n\t\t\t\tif (!uid_valid(entry->uid) ||\n\t\t\t\t    (uid_t)lnum != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= eid_token\n\t\t\t\t\t    ? IMA_EUID : IMA_UID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid_gt:\n\t\tcase Opt_egid_gt:\n\t\t\tentry->gid_op = &gid_gt;\n\t\t\tfallthrough;\n\t\tcase Opt_gid_lt:\n\t\tcase Opt_egid_lt:\n\t\t\tif ((token == Opt_gid_lt) || (token == Opt_egid_lt))\n\t\t\t\tentry->gid_op = &gid_lt;\n\t\t\tfallthrough;\n\t\tcase Opt_gid_eq:\n\t\tcase Opt_egid_eq:\n\t\t\teid_token = (token == Opt_egid_eq) ||\n\t\t\t\t    (token == Opt_egid_gt) ||\n\t\t\t\t    (token == Opt_egid_lt);\n\n\t\t\tima_log_string_op(ab, eid_token ? \"egid\" : \"gid\",\n\t\t\t\t\t  args[0].from, token);\n\n\t\t\tif (gid_valid(entry->gid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->gid = make_kgid(current_user_ns(),\n\t\t\t\t\t\t       (gid_t)lnum);\n\t\t\t\tif (!gid_valid(entry->gid) ||\n\t\t\t\t    (((gid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= eid_token\n\t\t\t\t\t    ? IMA_EGID : IMA_GID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fowner_gt:\n\t\t\tentry->fowner_op = &vfsuid_gt_kuid;\n\t\t\tfallthrough;\n\t\tcase Opt_fowner_lt:\n\t\t\tif (token == Opt_fowner_lt)\n\t\t\t\tentry->fowner_op = &vfsuid_lt_kuid;\n\t\t\tfallthrough;\n\t\tcase Opt_fowner_eq:\n\t\t\tima_log_string_op(ab, \"fowner\", args[0].from, token);\n\n\t\t\tif (uid_valid(entry->fowner)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fowner = make_kuid(current_user_ns(),\n\t\t\t\t\t\t\t  (uid_t)lnum);\n\t\t\t\tif (!uid_valid(entry->fowner) ||\n\t\t\t\t    (((uid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FOWNER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fgroup_gt:\n\t\t\tentry->fgroup_op = &vfsgid_gt_kgid;\n\t\t\tfallthrough;\n\t\tcase Opt_fgroup_lt:\n\t\t\tif (token == Opt_fgroup_lt)\n\t\t\t\tentry->fgroup_op = &vfsgid_lt_kgid;\n\t\t\tfallthrough;\n\t\tcase Opt_fgroup_eq:\n\t\t\tima_log_string_op(ab, \"fgroup\", args[0].from, token);\n\n\t\t\tif (gid_valid(entry->fgroup)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fgroup = make_kgid(current_user_ns(),\n\t\t\t\t\t\t\t  (gid_t)lnum);\n\t\t\t\tif (!gid_valid(entry->fgroup) ||\n\t\t\t\t    (((gid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FGROUP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_digest_type:\n\t\t\tima_log_string(ab, \"digest_type\", args[0].from);\n\t\t\tif (entry->flags & IMA_DIGSIG_REQUIRED)\n\t\t\t\tresult = -EINVAL;\n\t\t\telse if ((strcmp(args[0].from, \"verity\")) == 0)\n\t\t\t\tentry->flags |= IMA_VERITY_REQUIRED;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_appraise_type:\n\t\t\tima_log_string(ab, \"appraise_type\", args[0].from);\n\n\t\t\tif ((strcmp(args[0].from, \"imasig\")) == 0) {\n\t\t\t\tif (entry->flags & IMA_VERITY_REQUIRED)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED | IMA_CHECK_BLACKLIST;\n\t\t\t} else if (strcmp(args[0].from, \"sigv3\") == 0) {\n\t\t\t\t \n\t\t\t\tif (entry->flags & IMA_VERITY_REQUIRED)\n\t\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED | IMA_CHECK_BLACKLIST;\n\t\t\t\telse\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t} else if (IS_ENABLED(CONFIG_IMA_APPRAISE_MODSIG) &&\n\t\t\t\t strcmp(args[0].from, \"imasig|modsig\") == 0) {\n\t\t\t\tif (entry->flags & IMA_VERITY_REQUIRED)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED |\n\t\t\t\t\t\tIMA_MODSIG_ALLOWED | IMA_CHECK_BLACKLIST;\n\t\t\t} else {\n\t\t\t\tresult = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_appraise_flag:\n\t\t\tima_log_string(ab, \"appraise_flag\", args[0].from);\n\t\t\tbreak;\n\t\tcase Opt_appraise_algos:\n\t\t\tima_log_string(ab, \"appraise_algos\", args[0].from);\n\n\t\t\tif (entry->allowed_algos) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->allowed_algos =\n\t\t\t\tima_parse_appraise_algos(args[0].from);\n\t\t\t \n\t\t\tif (!entry->allowed_algos) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry->flags |= IMA_VALIDATE_ALGOS;\n\n\t\t\tbreak;\n\t\tcase Opt_permit_directio:\n\t\t\tentry->flags |= IMA_PERMIT_DIRECTIO;\n\t\t\tbreak;\n\t\tcase Opt_pcr:\n\t\t\tima_log_string(ab, \"pcr\", args[0].from);\n\n\t\t\tresult = kstrtoint(args[0].from, 10, &entry->pcr);\n\t\t\tif (result || INVALID_PCR(entry->pcr))\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tentry->flags |= IMA_PCR;\n\n\t\t\tbreak;\n\t\tcase Opt_template:\n\t\t\tima_log_string(ab, \"template\", args[0].from);\n\t\t\tif (entry->action != MEASURE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemplate_desc = lookup_template_desc(args[0].from);\n\t\t\tif (!template_desc || entry->template) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\ttemplate_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t &(template_desc->fields),\n\t\t\t\t\t\t &(template_desc->num_fields));\n\t\t\tentry->template = template_desc;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && !ima_validate_rule(entry))\n\t\tresult = -EINVAL;\n\telse if (entry->action == APPRAISE)\n\t\ttemp_ima_appraise |= ima_appraise_flag(entry->func);\n\n\tif (!result && entry->flags & IMA_MODSIG_ALLOWED) {\n\t\ttemplate_desc = entry->template ? entry->template :\n\t\t\t\t\t\t  ima_template_desc_current();\n\t\tcheck_template_modsig(template_desc);\n\t}\n\n\t \n\tif (!result && entry->action == MEASURE &&\n\t    entry->flags & IMA_VERITY_REQUIRED) {\n\t\ttemplate_desc = entry->template ? entry->template :\n\t\t\t\t\t\t  ima_template_desc_current();\n\t\tcheck_template_field(template_desc, \"d-ngv2\",\n\t\t\t\t     \"verity rules should include d-ngv2\");\n\t}\n\n\taudit_log_format(ab, \"res=%d\", !result);\n\taudit_log_end(ab);\n\treturn result;\n}\n\n \nssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tima_free_rule(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}\n\n \nvoid ima_delete_rules(void)\n{\n\tstruct ima_rule_entry *entry, *tmp;\n\n\ttemp_ima_appraise = 0;\n\tlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\n\t\tlist_del(&entry->list);\n\t\tima_free_rule(entry);\n\t}\n}\n\n#define __ima_hook_stringify(func, str)\t(#func),\n\nconst char *const func_tokens[] = {\n\t__ima_hooks(__ima_hook_stringify)\n};\n\n#ifdef\tCONFIG_IMA_READ_POLICY\nenum {\n\tmask_exec = 0, mask_write, mask_read, mask_append\n};\n\nstatic const char *const mask_tokens[] = {\n\t\"^MAY_EXEC\",\n\t\"^MAY_WRITE\",\n\t\"^MAY_READ\",\n\t\"^MAY_APPEND\"\n};\n\nvoid *ima_policy_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_rule_entry *entry;\n\tstruct list_head *ima_rules_tmp;\n\n\trcu_read_lock();\n\tima_rules_tmp = rcu_dereference(ima_rules);\n\tlist_for_each_entry_rcu(entry, ima_rules_tmp, list) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn entry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nvoid *ima_policy_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_rule_entry *entry = v;\n\n\trcu_read_lock();\n\tentry = list_entry_rcu(entry->list.next, struct ima_rule_entry, list);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&entry->list == &ima_default_rules ||\n\t\t&entry->list == &ima_policy_rules) ? NULL : entry;\n}\n\nvoid ima_policy_stop(struct seq_file *m, void *v)\n{\n}\n\n#define pt(token)\tpolicy_tokens[token].pattern\n#define mt(token)\tmask_tokens[token]\n\n \nstatic void policy_func_show(struct seq_file *m, enum ima_hooks func)\n{\n\tif (func > 0 && func < MAX_CHECK)\n\t\tseq_printf(m, \"func=%s \", func_tokens[func]);\n\telse\n\t\tseq_printf(m, \"func=%d \", func);\n}\n\nstatic void ima_show_rule_opt_list(struct seq_file *m,\n\t\t\t\t   const struct ima_rule_opt_list *opt_list)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < opt_list->count; i++)\n\t\tseq_printf(m, \"%s%s\", i ? \"|\" : \"\", opt_list->items[i]);\n}\n\nstatic void ima_policy_show_appraise_algos(struct seq_file *m,\n\t\t\t\t\t   unsigned int allowed_hashes)\n{\n\tint idx, list_size = 0;\n\n\tfor (idx = 0; idx < HASH_ALGO__LAST; idx++) {\n\t\tif (!(allowed_hashes & (1U << idx)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (list_size++)\n\t\t\tseq_puts(m, \",\");\n\n\t\tseq_puts(m, hash_algo_name[idx]);\n\t}\n}\n\nint ima_policy_show(struct seq_file *m, void *v)\n{\n\tstruct ima_rule_entry *entry = v;\n\tint i;\n\tchar tbuf[64] = {0,};\n\tint offset = 0;\n\n\trcu_read_lock();\n\n\t \n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tif (entry->lsm[i].args_p && !entry->lsm[i].rule) {\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (entry->action & MEASURE)\n\t\tseq_puts(m, pt(Opt_measure));\n\tif (entry->action & DONT_MEASURE)\n\t\tseq_puts(m, pt(Opt_dont_measure));\n\tif (entry->action & APPRAISE)\n\t\tseq_puts(m, pt(Opt_appraise));\n\tif (entry->action & DONT_APPRAISE)\n\t\tseq_puts(m, pt(Opt_dont_appraise));\n\tif (entry->action & AUDIT)\n\t\tseq_puts(m, pt(Opt_audit));\n\tif (entry->action & HASH)\n\t\tseq_puts(m, pt(Opt_hash));\n\tif (entry->action & DONT_HASH)\n\t\tseq_puts(m, pt(Opt_dont_hash));\n\n\tseq_puts(m, \" \");\n\n\tif (entry->flags & IMA_FUNC)\n\t\tpolicy_func_show(m, entry->func);\n\n\tif ((entry->flags & IMA_MASK) || (entry->flags & IMA_INMASK)) {\n\t\tif (entry->flags & IMA_MASK)\n\t\t\toffset = 1;\n\t\tif (entry->mask & MAY_EXEC)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_exec) + offset);\n\t\tif (entry->mask & MAY_WRITE)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_write) + offset);\n\t\tif (entry->mask & MAY_READ)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_read) + offset);\n\t\tif (entry->mask & MAY_APPEND)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_append) + offset);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSMAGIC) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"0x%lx\", entry->fsmagic);\n\t\tseq_printf(m, pt(Opt_fsmagic), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSNAME) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%s\", entry->fsname);\n\t\tseq_printf(m, pt(Opt_fsname), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_KEYRINGS) {\n\t\tseq_puts(m, \"keyrings=\");\n\t\tima_show_rule_opt_list(m, entry->keyrings);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_LABEL) {\n\t\tseq_puts(m, \"label=\");\n\t\tima_show_rule_opt_list(m, entry->label);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_PCR) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", entry->pcr);\n\t\tseq_printf(m, pt(Opt_pcr), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSUUID) {\n\t\tseq_printf(m, \"fsuuid=%pU\", &entry->fsuuid);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_UID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_uid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_uid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_uid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_EUID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_euid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_euid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_euid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_GID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kgid_val(entry->gid));\n\t\tif (entry->gid_op == &gid_gt)\n\t\t\tseq_printf(m, pt(Opt_gid_gt), tbuf);\n\t\telse if (entry->gid_op == &gid_lt)\n\t\t\tseq_printf(m, pt(Opt_gid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_gid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_EGID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kgid_val(entry->gid));\n\t\tif (entry->gid_op == &gid_gt)\n\t\t\tseq_printf(m, pt(Opt_egid_gt), tbuf);\n\t\telse if (entry->gid_op == &gid_lt)\n\t\t\tseq_printf(m, pt(Opt_egid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_egid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FOWNER) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->fowner));\n\t\tif (entry->fowner_op == &vfsuid_gt_kuid)\n\t\t\tseq_printf(m, pt(Opt_fowner_gt), tbuf);\n\t\telse if (entry->fowner_op == &vfsuid_lt_kuid)\n\t\t\tseq_printf(m, pt(Opt_fowner_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_fowner_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FGROUP) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kgid_val(entry->fgroup));\n\t\tif (entry->fgroup_op == &vfsgid_gt_kgid)\n\t\t\tseq_printf(m, pt(Opt_fgroup_gt), tbuf);\n\t\telse if (entry->fgroup_op == &vfsgid_lt_kgid)\n\t\t\tseq_printf(m, pt(Opt_fgroup_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_fgroup_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_VALIDATE_ALGOS) {\n\t\tseq_puts(m, \"appraise_algos=\");\n\t\tima_policy_show_appraise_algos(m, entry->allowed_algos);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tif (entry->lsm[i].rule) {\n\t\t\tswitch (i) {\n\t\t\tcase LSM_OBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_obj_user),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_role),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_type),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_subj_user),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_role),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_type),\n\t\t\t\t\t   entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseq_puts(m, \" \");\n\t\t}\n\t}\n\tif (entry->template)\n\t\tseq_printf(m, \"template=%s \", entry->template->name);\n\tif (entry->flags & IMA_DIGSIG_REQUIRED) {\n\t\tif (entry->flags & IMA_VERITY_REQUIRED)\n\t\t\tseq_puts(m, \"appraise_type=sigv3 \");\n\t\telse if (entry->flags & IMA_MODSIG_ALLOWED)\n\t\t\tseq_puts(m, \"appraise_type=imasig|modsig \");\n\t\telse\n\t\t\tseq_puts(m, \"appraise_type=imasig \");\n\t}\n\tif (entry->flags & IMA_VERITY_REQUIRED)\n\t\tseq_puts(m, \"digest_type=verity \");\n\tif (entry->flags & IMA_PERMIT_DIRECTIO)\n\t\tseq_puts(m, \"permit_directio \");\n\trcu_read_unlock();\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n#endif\t \n\n#if defined(CONFIG_IMA_APPRAISE) && defined(CONFIG_INTEGRITY_TRUSTED_KEYRING)\n \nbool ima_appraise_signature(enum kernel_read_file_id id)\n{\n\tstruct ima_rule_entry *entry;\n\tbool found = false;\n\tenum ima_hooks func;\n\tstruct list_head *ima_rules_tmp;\n\n\tif (id >= READING_MAX_ID)\n\t\treturn false;\n\n\tif (id == READING_KEXEC_IMAGE && !(ima_appraise & IMA_APPRAISE_ENFORCE)\n\t    && security_locked_down(LOCKDOWN_KEXEC))\n\t\treturn false;\n\n\tfunc = read_idmap[id] ?: FILE_CHECK;\n\n\trcu_read_lock();\n\tima_rules_tmp = rcu_dereference(ima_rules);\n\tlist_for_each_entry_rcu(entry, ima_rules_tmp, list) {\n\t\tif (entry->action != APPRAISE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (entry->func && entry->func != func)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (entry->flags & IMA_DIGSIG_REQUIRED)\n\t\t\tfound = true;\n\n\t\t \n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}