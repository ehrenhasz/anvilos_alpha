{
  "module_name": "ima_template.c",
  "hash_id": "9e08d34af8847d7c4db43f1ce73f0f234d8e48020ed6ea7c835f92bf08fc1b13",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_template.c",
  "human_readable_source": "\n \n\n#include <linux/rculist.h>\n#include \"ima.h\"\n#include \"ima_template_lib.h\"\n\nenum header_fields { HDR_PCR, HDR_DIGEST, HDR_TEMPLATE_NAME,\n\t\t     HDR_TEMPLATE_DATA, HDR__LAST };\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"ima-ngv2\", .fmt = \"d-ngv2|n-ng\"},\n\t{.name = \"ima-sigv2\", .fmt = \"d-ngv2|n-ng|sig\"},\n\t{.name = \"ima-buf\", .fmt = \"d-ng|n-ng|buf\"},\n\t{.name = \"ima-modsig\", .fmt = \"d-ng|n-ng|sig|d-modsig|modsig\"},\n\t{.name = \"evm-sig\",\n\t .fmt = \"d-ng|n-ng|evmsig|xattrnames|xattrlengths|xattrvalues|iuid|igid|imode\"},\n\t{.name = \"\", .fmt = \"\"},\t \n};\n\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\nstatic int template_setup_done;\n\nstatic const struct ima_template_field supported_fields[] = {\n\t{.field_id = \"d\", .field_init = ima_eventdigest_init,\n\t .field_show = ima_show_template_digest},\n\t{.field_id = \"n\", .field_init = ima_eventname_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"d-ng\", .field_init = ima_eventdigest_ng_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"d-ngv2\", .field_init = ima_eventdigest_ngv2_init,\n\t .field_show = ima_show_template_digest_ngv2},\n\t{.field_id = \"n-ng\", .field_init = ima_eventname_ng_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"sig\", .field_init = ima_eventsig_init,\n\t .field_show = ima_show_template_sig},\n\t{.field_id = \"buf\", .field_init = ima_eventbuf_init,\n\t .field_show = ima_show_template_buf},\n\t{.field_id = \"d-modsig\", .field_init = ima_eventdigest_modsig_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"modsig\", .field_init = ima_eventmodsig_init,\n\t .field_show = ima_show_template_sig},\n\t{.field_id = \"evmsig\", .field_init = ima_eventevmsig_init,\n\t .field_show = ima_show_template_sig},\n\t{.field_id = \"iuid\", .field_init = ima_eventinodeuid_init,\n\t .field_show = ima_show_template_uint},\n\t{.field_id = \"igid\", .field_init = ima_eventinodegid_init,\n\t .field_show = ima_show_template_uint},\n\t{.field_id = \"imode\", .field_init = ima_eventinodemode_init,\n\t .field_show = ima_show_template_uint},\n\t{.field_id = \"xattrnames\",\n\t .field_init = ima_eventinodexattrnames_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"xattrlengths\",\n\t .field_init = ima_eventinodexattrlengths_init,\n\t .field_show = ima_show_template_sig},\n\t{.field_id = \"xattrvalues\",\n\t .field_init = ima_eventinodexattrvalues_init,\n\t .field_show = ima_show_template_sig},\n};\n\n \n#define MAX_TEMPLATE_NAME_LEN \\\n\tsizeof(\"d-ng|n-ng|evmsig|xattrnames|xattrlengths|xattrvalues|iuid|igid|imode\")\n\nstatic struct ima_template_desc *ima_template;\nstatic struct ima_template_desc *ima_buf_template;\n\n \nbool ima_template_has_modsig(const struct ima_template_desc *ima_template)\n{\n\tint i;\n\n\tfor (i = 0; i < ima_template->num_fields; i++)\n\t\tif (!strcmp(ima_template->fields[i]->field_id, \"modsig\") ||\n\t\t    !strcmp(ima_template->fields[i]->field_id, \"d-modsig\"))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __init ima_template_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc;\n\tint template_len = strlen(str);\n\n\tif (template_setup_done)\n\t\treturn 1;\n\n\tif (!ima_template)\n\t\tima_init_template_list();\n\n\t \n\ttemplate_desc = lookup_template_desc(str);\n\tif (!template_desc) {\n\t\tpr_err(\"template %s not found, using %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\t \n\tif (template_len == 3 && strcmp(str, IMA_TEMPLATE_IMA_NAME) == 0 &&\n\t    ima_hash_algo != HASH_ALGO_SHA1 && ima_hash_algo != HASH_ALGO_MD5) {\n\t\tpr_err(\"template does not support hash alg\\n\");\n\t\treturn 1;\n\t}\n\n\tima_template = template_desc;\n\ttemplate_setup_done = 1;\n\treturn 1;\n}\n__setup(\"ima_template=\", ima_template_setup);\n\nstatic int __init ima_template_fmt_setup(char *str)\n{\n\tint num_templates = ARRAY_SIZE(builtin_templates);\n\n\tif (template_setup_done)\n\t\treturn 1;\n\n\tif (template_desc_init_fields(str, NULL, NULL) < 0) {\n\t\tpr_err(\"format string '%s' not valid, using template %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\tbuiltin_templates[num_templates - 1].fmt = str;\n\tima_template = builtin_templates + num_templates - 1;\n\ttemplate_setup_done = 1;\n\n\treturn 1;\n}\n__setup(\"ima_template_fmt=\", ima_template_fmt_setup);\n\nstruct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}\n\nstatic const struct ima_template_field *\nlookup_template_field(const char *field_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\n\t\tif (strncmp(supported_fields[i].field_id, field_id,\n\t\t\t    IMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\n\t\t\treturn &supported_fields[i];\n\treturn NULL;\n}\n\nstatic int template_fmt_size(const char *template_fmt)\n{\n\tchar c;\n\tint template_fmt_len = strlen(template_fmt);\n\tint i = 0, j = 0;\n\n\twhile (i < template_fmt_len) {\n\t\tc = template_fmt[i];\n\t\tif (c == '|')\n\t\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j + 1;\n}\n\nint template_desc_init_fields(const char *template_fmt,\n\t\t\t      const struct ima_template_field ***fields,\n\t\t\t      int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tconst struct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0)  \n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(**fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(**fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}\n\nvoid ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}\n\nstruct ima_template_desc *ima_template_desc_buf(void)\n{\n\tif (!ima_buf_template) {\n\t\tima_init_template_list();\n\t\tima_buf_template = lookup_template_desc(\"ima-buf\");\n\t}\n\treturn ima_buf_template;\n}\n\nint __init ima_init_template(void)\n{\n\tstruct ima_template_desc *template = ima_template_desc_current();\n\tint result;\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0) {\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\t\treturn result;\n\t}\n\n\ttemplate = ima_template_desc_buf();\n\tif (!template) {\n\t\tpr_err(\"Failed to get ima-buf template\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0)\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\n\treturn result;\n}\n\nstatic struct ima_template_desc *restore_template_fmt(char *template_name)\n{\n\tstruct ima_template_desc *template_desc = NULL;\n\tint ret;\n\n\tret = template_desc_init_fields(template_name, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"attempting to initialize the template \\\"%s\\\" failed\\n\",\n\t\t\ttemplate_name);\n\t\tgoto out;\n\t}\n\n\ttemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\n\tif (!template_desc)\n\t\tgoto out;\n\n\ttemplate_desc->name = \"\";\n\ttemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\n\tif (!template_desc->fmt) {\n\t\tkfree(template_desc);\n\t\ttemplate_desc = NULL;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&template_list);\n\tlist_add_tail_rcu(&template_desc->list, &defined_templates);\n\tspin_unlock(&template_list);\nout:\n\treturn template_desc;\n}\n\nstatic int ima_restore_template_data(struct ima_template_desc *template_desc,\n\t\t\t\t     void *template_data,\n\t\t\t\t     int template_data_size,\n\t\t\t\t     struct ima_template_entry **entry)\n{\n\tstruct tpm_digest *digests;\n\tint ret = 0;\n\tint i;\n\n\t*entry = kzalloc(struct_size(*entry, template_data,\n\t\t\t\t     template_desc->num_fields), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tdigests = kcalloc(NR_BANKS(ima_tpm_chip) + ima_extra_slots,\n\t\t\t  sizeof(*digests), GFP_NOFS);\n\tif (!digests) {\n\t\tkfree(*entry);\n\t\treturn -ENOMEM;\n\t}\n\n\t(*entry)->digests = digests;\n\n\tret = ima_parse_buf(template_data, template_data + template_data_size,\n\t\t\t    NULL, template_desc->num_fields,\n\t\t\t    (*entry)->template_data, NULL, NULL,\n\t\t\t    ENFORCE_FIELDS | ENFORCE_BUFEND, \"template data\");\n\tif (ret < 0) {\n\t\tkfree((*entry)->digests);\n\t\tkfree(*entry);\n\t\treturn ret;\n\t}\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_field_data *field_data = &(*entry)->template_data[i];\n\t\tu8 *data = field_data->data;\n\n\t\t(*entry)->template_data[i].data =\n\t\t\tkzalloc(field_data->len + 1, GFP_KERNEL);\n\t\tif (!(*entry)->template_data[i].data) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy((*entry)->template_data[i].data, data, field_data->len);\n\t\t(*entry)->template_data_len += sizeof(field_data->len);\n\t\t(*entry)->template_data_len += field_data->len;\n\t}\n\n\tif (ret < 0) {\n\t\tima_free_template_entry(*entry);\n\t\t*entry = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nint ima_restore_measurement_list(loff_t size, void *buf)\n{\n\tchar template_name[MAX_TEMPLATE_NAME_LEN];\n\tunsigned char zero[TPM_DIGEST_SIZE] = { 0 };\n\n\tstruct ima_kexec_hdr *khdr = buf;\n\tstruct ima_field_data hdr[HDR__LAST] = {\n\t\t[HDR_PCR] = {.len = sizeof(u32)},\n\t\t[HDR_DIGEST] = {.len = TPM_DIGEST_SIZE},\n\t};\n\n\tvoid *bufp = buf + sizeof(*khdr);\n\tvoid *bufendp;\n\tstruct ima_template_entry *entry;\n\tstruct ima_template_desc *template_desc;\n\tDECLARE_BITMAP(hdr_mask, HDR__LAST);\n\tunsigned long count = 0;\n\tint ret = 0;\n\n\tif (!buf || size < sizeof(*khdr))\n\t\treturn 0;\n\n\tif (ima_canonical_fmt) {\n\t\tkhdr->version = le16_to_cpu((__force __le16)khdr->version);\n\t\tkhdr->count = le64_to_cpu((__force __le64)khdr->count);\n\t\tkhdr->buffer_size = le64_to_cpu((__force __le64)khdr->buffer_size);\n\t}\n\n\tif (khdr->version != 1) {\n\t\tpr_err(\"attempting to restore a incompatible measurement list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (khdr->count > ULONG_MAX - 1) {\n\t\tpr_err(\"attempting to restore too many measurements\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(hdr_mask, HDR__LAST);\n\tbitmap_set(hdr_mask, HDR_PCR, 1);\n\tbitmap_set(hdr_mask, HDR_DIGEST, 1);\n\n\t \n\tbufendp = buf + khdr->buffer_size;\n\twhile ((bufp < bufendp) && (count++ < khdr->count)) {\n\t\tint enforce_mask = ENFORCE_FIELDS;\n\n\t\tenforce_mask |= (count == khdr->count) ? ENFORCE_BUFEND : 0;\n\t\tret = ima_parse_buf(bufp, bufendp, &bufp, HDR__LAST, hdr, NULL,\n\t\t\t\t    hdr_mask, enforce_mask, \"entry header\");\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (hdr[HDR_TEMPLATE_NAME].len >= MAX_TEMPLATE_NAME_LEN) {\n\t\t\tpr_err(\"attempting to restore a template name that is too long\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmemcpy(template_name, hdr[HDR_TEMPLATE_NAME].data,\n\t\t       hdr[HDR_TEMPLATE_NAME].len);\n\t\ttemplate_name[hdr[HDR_TEMPLATE_NAME].len] = 0;\n\n\t\tif (strcmp(template_name, \"ima\") == 0) {\n\t\t\tpr_err(\"attempting to restore an unsupported template \\\"%s\\\" failed\\n\",\n\t\t\t       template_name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemplate_desc = lookup_template_desc(template_name);\n\t\tif (!template_desc) {\n\t\t\ttemplate_desc = restore_template_fmt(template_name);\n\t\t\tif (!template_desc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = template_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t&(template_desc->fields),\n\t\t\t\t\t\t&(template_desc->num_fields));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"attempting to restore the template fmt \\\"%s\\\" failed\\n\",\n\t\t\t       template_desc->fmt);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ima_restore_template_data(template_desc,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].data,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].len,\n\t\t\t\t\t\t&entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (memcmp(hdr[HDR_DIGEST].data, zero, sizeof(zero))) {\n\t\t\tret = ima_calc_field_array_hash(\n\t\t\t\t\t\t&entry->template_data[0],\n\t\t\t\t\t\tentry);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"cannot calculate template digest\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tentry->pcr = !ima_canonical_fmt ? *(u32 *)(hdr[HDR_PCR].data) :\n\t\t\t     le32_to_cpu(*(__le32 *)(hdr[HDR_PCR].data));\n\t\tret = ima_restore_measurement_entry(entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}