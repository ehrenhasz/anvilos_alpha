{
  "module_name": "ima_fs.c",
  "hash_id": "3e8a27a15a6d02749b46c65704ce2c9abf64fb4c96f806d0811f6e46727f3743",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_fs.c",
  "human_readable_source": "\n \n\n#include <linux/fcntl.h>\n#include <linux/kernel_read_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/parser.h>\n#include <linux/vmalloc.h>\n\n#include \"ima.h\"\n\nstatic DEFINE_MUTEX(ima_write_mutex);\n\nbool ima_canonical_fmt;\nstatic int __init default_canonical_fmt_setup(char *str)\n{\n#ifdef __BIG_ENDIAN\n\tima_canonical_fmt = true;\n#endif\n\treturn 1;\n}\n__setup(\"ima_canonical_fmt\", default_canonical_fmt_setup);\n\nstatic int valid_policy = 1;\n\nstatic ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[32];\t \n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, sizeof(tmpbuf), \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}\n\nstatic ssize_t ima_show_htable_violations(struct file *filp,\n\t\t\t\t\t  char __user *buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\n}\n\nstatic const struct file_operations ima_htable_violations_ops = {\n\t.read = ima_show_htable_violations,\n\t.llseek = generic_file_llseek,\n};\n\nstatic ssize_t ima_show_measurements_count(struct file *filp,\n\t\t\t\t\t   char __user *buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\n\n}\n\nstatic const struct file_operations ima_measurements_count_ops = {\n\t.read = ima_show_measurements_count,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic void *ima_measurements_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_queue_entry *qe;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn qe;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_queue_entry *qe = v;\n\n\t \n\trcu_read_lock();\n\tqe = list_entry_rcu(qe->later.next, struct ima_queue_entry, later);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&qe->later == &ima_measurements) ? NULL : qe;\n}\n\nstatic void ima_measurements_stop(struct seq_file *m, void *v)\n{\n}\n\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}\n\n \nint ima_measurements_show(struct seq_file *m, void *v)\n{\n\t \n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tu32 pcr, namelen, template_data_len;  \n\tbool is_ima_template = false;\n\tint i;\n\n\t \n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t \n\tpcr = !ima_canonical_fmt ? e->pcr : (__force u32)cpu_to_le32(e->pcr);\n\tima_putc(m, &pcr, sizeof(e->pcr));\n\n\t \n\tima_putc(m, e->digests[ima_sha1_idx].digest, TPM_DIGEST_SIZE);\n\n\t \n\tnamelen = !ima_canonical_fmt ? strlen(template_name) :\n\t\t(__force u32)cpu_to_le32(strlen(template_name));\n\tima_putc(m, &namelen, sizeof(namelen));\n\n\t \n\tima_putc(m, template_name, strlen(template_name));\n\n\t \n\tif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\n\t\tis_ima_template = true;\n\n\tif (!is_ima_template) {\n\t\ttemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\n\t\t\t(__force u32)cpu_to_le32(e->template_data_len);\n\t\tima_putc(m, &template_data_len, sizeof(e->template_data_len));\n\t}\n\n\t \n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tenum ima_show_type show = IMA_SHOW_BINARY;\n\t\tconst struct ima_template_field *field =\n\t\t\te->template_desc->fields[i];\n\n\t\tif (is_ima_template && strcmp(field->field_id, \"d\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\n\t\tif (is_ima_template && strcmp(field->field_id, \"n\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\n\t\tfield->field_show(m, show, &e->template_data[i]);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ima_measurments_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_measurements_show\n};\n\nstatic int ima_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_measurments_seqops);\n}\n\nstatic const struct file_operations ima_measurements_ops = {\n\t.open = ima_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}\n\n \nstatic int ima_ascii_measurements_show(struct seq_file *m, void *v)\n{\n\t \n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tint i;\n\n\t \n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t \n\tseq_printf(m, \"%2d \", e->pcr);\n\n\t \n\tima_print_digest(m, e->digests[ima_sha1_idx].digest, TPM_DIGEST_SIZE);\n\n\t \n\tseq_printf(m, \" %s\", template_name);\n\n\t \n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tseq_puts(m, \" \");\n\t\tif (e->template_data[i].len == 0)\n\t\t\tcontinue;\n\n\t\te->template_desc->fields[i]->field_show(m, IMA_SHOW_ASCII,\n\t\t\t\t\t\t\t&e->template_data[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations ima_ascii_measurements_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_ascii_measurements_show\n};\n\nstatic int ima_ascii_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_ascii_measurements_seqops);\n}\n\nstatic const struct file_operations ima_ascii_measurements_ops = {\n\t.open = ima_ascii_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic ssize_t ima_read_policy(char *path)\n{\n\tvoid *data = NULL;\n\tchar *datap;\n\tsize_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t \n\tdatap = path;\n\tstrsep(&datap, \"\\n\");\n\n\trc = kernel_read_file_from_path(path, 0, &data, INT_MAX, NULL,\n\t\t\t\t\tREADING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\tsize = rc;\n\trc = 0;\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, \"\\n\"))) {\n\t\tpr_debug(\"rule: %s\\n\", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (size)\n\t\treturn -EINVAL;\n\telse\n\t\treturn pathlen;\n}\n\nstatic ssize_t ima_write_policy(struct file *file, const char __user *buf,\n\t\t\t\tsize_t datalen, loff_t *ppos)\n{\n\tchar *data;\n\tssize_t result;\n\n\tif (datalen >= PAGE_SIZE)\n\t\tdatalen = PAGE_SIZE - 1;\n\n\t \n\tresult = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tdata = memdup_user_nul(buf, datalen);\n\tif (IS_ERR(data)) {\n\t\tresult = PTR_ERR(data);\n\t\tgoto out;\n\t}\n\n\tresult = mutex_lock_interruptible(&ima_write_mutex);\n\tif (result < 0)\n\t\tgoto out_free;\n\n\tif (data[0] == '/') {\n\t\tresult = ima_read_policy(data);\n\t} else if (ima_appraise & IMA_APPRAISE_POLICY) {\n\t\tpr_err(\"signed policy file (specified as an absolute pathname) required\\n\");\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t\t    \"policy_update\", \"signed policy required\",\n\t\t\t\t    1, 0);\n\t\tresult = -EACCES;\n\t} else {\n\t\tresult = ima_parse_add_rule(data);\n\t}\n\tmutex_unlock(&ima_write_mutex);\nout_free:\n\tkfree(data);\nout:\n\tif (result < 0)\n\t\tvalid_policy = 0;\n\n\treturn result;\n}\n\nstatic struct dentry *ima_dir;\nstatic struct dentry *ima_symlink;\nstatic struct dentry *binary_runtime_measurements;\nstatic struct dentry *ascii_runtime_measurements;\nstatic struct dentry *runtime_measurements_count;\nstatic struct dentry *violations;\nstatic struct dentry *ima_policy;\n\nenum ima_fs_flags {\n\tIMA_FS_BUSY,\n};\n\nstatic unsigned long ima_fs_flags;\n\n#ifdef\tCONFIG_IMA_READ_POLICY\nstatic const struct seq_operations ima_policy_seqops = {\n\t\t.start = ima_policy_start,\n\t\t.next = ima_policy_next,\n\t\t.stop = ima_policy_stop,\n\t\t.show = ima_policy_show,\n};\n#endif\n\n \nstatic int ima_open_policy(struct inode *inode, struct file *filp)\n{\n\tif (!(filp->f_flags & O_WRONLY)) {\n#ifndef\tCONFIG_IMA_READ_POLICY\n\t\treturn -EACCES;\n#else\n\t\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\t\treturn -EACCES;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn seq_open(filp, &ima_policy_seqops);\n#endif\n\t}\n\tif (test_and_set_bit(IMA_FS_BUSY, &ima_fs_flags))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \nstatic int ima_release_policy(struct inode *inode, struct file *file)\n{\n\tconst char *cause = valid_policy ? \"completed\" : \"failed\";\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\treturn seq_release(inode, file);\n\n\tif (valid_policy && ima_check_policy() < 0) {\n\t\tcause = \"failed\";\n\t\tvalid_policy = 0;\n\t}\n\n\tpr_info(\"policy update %s\\n\", cause);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t    \"policy_update\", cause, !valid_policy, 0);\n\n\tif (!valid_policy) {\n\t\tima_delete_rules();\n\t\tvalid_policy = 1;\n\t\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n\t\treturn 0;\n\t}\n\n\tima_update_policy();\n#if !defined(CONFIG_IMA_WRITE_POLICY) && !defined(CONFIG_IMA_READ_POLICY)\n\tsecurityfs_remove(ima_policy);\n\tima_policy = NULL;\n#elif defined(CONFIG_IMA_WRITE_POLICY)\n\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n#elif defined(CONFIG_IMA_READ_POLICY)\n\tinode->i_mode &= ~S_IWUSR;\n#endif\n\treturn 0;\n}\n\nstatic const struct file_operations ima_measure_policy_ops = {\n\t.open = ima_open_policy,\n\t.write = ima_write_policy,\n\t.read = seq_read,\n\t.release = ima_release_policy,\n\t.llseek = generic_file_llseek,\n};\n\nint __init ima_fs_init(void)\n{\n\tint ret;\n\n\tima_dir = securityfs_create_dir(\"ima\", integrity_dir);\n\tif (IS_ERR(ima_dir))\n\t\treturn PTR_ERR(ima_dir);\n\n\tima_symlink = securityfs_create_symlink(\"ima\", NULL, \"integrity/ima\",\n\t\t\t\t\t\tNULL);\n\tif (IS_ERR(ima_symlink)) {\n\t\tret = PTR_ERR(ima_symlink);\n\t\tgoto out;\n\t}\n\n\tbinary_runtime_measurements =\n\t    securityfs_create_file(\"binary_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_ops);\n\tif (IS_ERR(binary_runtime_measurements)) {\n\t\tret = PTR_ERR(binary_runtime_measurements);\n\t\tgoto out;\n\t}\n\n\tascii_runtime_measurements =\n\t    securityfs_create_file(\"ascii_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_ascii_measurements_ops);\n\tif (IS_ERR(ascii_runtime_measurements)) {\n\t\tret = PTR_ERR(ascii_runtime_measurements);\n\t\tgoto out;\n\t}\n\n\truntime_measurements_count =\n\t    securityfs_create_file(\"runtime_measurements_count\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_count_ops);\n\tif (IS_ERR(runtime_measurements_count)) {\n\t\tret = PTR_ERR(runtime_measurements_count);\n\t\tgoto out;\n\t}\n\n\tviolations =\n\t    securityfs_create_file(\"violations\", S_IRUSR | S_IRGRP,\n\t\t\t\t   ima_dir, NULL, &ima_htable_violations_ops);\n\tif (IS_ERR(violations)) {\n\t\tret = PTR_ERR(violations);\n\t\tgoto out;\n\t}\n\n\tima_policy = securityfs_create_file(\"policy\", POLICY_FILE_FLAGS,\n\t\t\t\t\t    ima_dir, NULL,\n\t\t\t\t\t    &ima_measure_policy_ops);\n\tif (IS_ERR(ima_policy)) {\n\t\tret = PTR_ERR(ima_policy);\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tsecurityfs_remove(ima_policy);\n\tsecurityfs_remove(violations);\n\tsecurityfs_remove(runtime_measurements_count);\n\tsecurityfs_remove(ascii_runtime_measurements);\n\tsecurityfs_remove(binary_runtime_measurements);\n\tsecurityfs_remove(ima_symlink);\n\tsecurityfs_remove(ima_dir);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}