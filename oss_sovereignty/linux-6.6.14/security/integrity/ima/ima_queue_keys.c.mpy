{
  "module_name": "ima_queue_keys.c",
  "hash_id": "0674cfe833542ef50308f456d251e1369a37d96ad3c83651afa157223ade7aa1",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_queue_keys.c",
  "human_readable_source": "\n \n\n#include <linux/user_namespace.h>\n#include <linux/workqueue.h>\n#include <keys/asymmetric-type.h>\n#include \"ima.h\"\n\n \nstatic bool ima_process_keys;\n\n \nstatic DEFINE_MUTEX(ima_keys_lock);\nstatic LIST_HEAD(ima_keys);\n\n \nstatic long ima_key_queue_timeout = 300000;  \nstatic void ima_keys_handler(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(ima_keys_delayed_work, ima_keys_handler);\nstatic bool timer_expired;\n\n \nstatic void ima_keys_handler(struct work_struct *work)\n{\n\ttimer_expired = true;\n\tima_process_queued_keys();\n}\n\n \nvoid ima_init_key_queue(void)\n{\n\tschedule_delayed_work(&ima_keys_delayed_work,\n\t\t\t      msecs_to_jiffies(ima_key_queue_timeout));\n}\n\nstatic void ima_free_key_entry(struct ima_key_entry *entry)\n{\n\tif (entry) {\n\t\tkfree(entry->payload);\n\t\tkfree(entry->keyring_name);\n\t\tkfree(entry);\n\t}\n}\n\nstatic struct ima_key_entry *ima_alloc_key_entry(struct key *keyring,\n\t\t\t\t\t\t const void *payload,\n\t\t\t\t\t\t size_t payload_len)\n{\n\tint rc = 0;\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_key_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry) {\n\t\tentry->payload = kmemdup(payload, payload_len, GFP_KERNEL);\n\t\tentry->keyring_name = kstrdup(keyring->description,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tentry->payload_len = payload_len;\n\t}\n\n\tif ((entry == NULL) || (entry->payload == NULL) ||\n\t    (entry->keyring_name == NULL)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\nout:\n\tif (rc) {\n\t\tintegrity_audit_message(AUDIT_INTEGRITY_PCR, NULL,\n\t\t\t\t\tkeyring->description,\n\t\t\t\t\tfunc_measure_str(KEY_CHECK),\n\t\t\t\t\taudit_cause, rc, 0, rc);\n\t\tima_free_key_entry(entry);\n\t\tentry = NULL;\n\t}\n\n\treturn entry;\n}\n\nbool ima_queue_key(struct key *keyring, const void *payload,\n\t\t   size_t payload_len)\n{\n\tbool queued = false;\n\tstruct ima_key_entry *entry;\n\n\tentry = ima_alloc_key_entry(keyring, payload, payload_len);\n\tif (!entry)\n\t\treturn false;\n\n\tmutex_lock(&ima_keys_lock);\n\tif (!ima_process_keys) {\n\t\tlist_add_tail(&entry->list, &ima_keys);\n\t\tqueued = true;\n\t}\n\tmutex_unlock(&ima_keys_lock);\n\n\tif (!queued)\n\t\tima_free_key_entry(entry);\n\n\treturn queued;\n}\n\n \nvoid ima_process_queued_keys(void)\n{\n\tstruct ima_key_entry *entry, *tmp;\n\tbool process = false;\n\n\tif (ima_process_keys)\n\t\treturn;\n\n\t \n\tmutex_lock(&ima_keys_lock);\n\tif (!ima_process_keys) {\n\t\tima_process_keys = true;\n\t\tprocess = true;\n\t}\n\tmutex_unlock(&ima_keys_lock);\n\n\tif (!process)\n\t\treturn;\n\n\tif (!timer_expired)\n\t\tcancel_delayed_work_sync(&ima_keys_delayed_work);\n\n\tlist_for_each_entry_safe(entry, tmp, &ima_keys, list) {\n\t\tif (!timer_expired)\n\t\t\tprocess_buffer_measurement(&nop_mnt_idmap, NULL,\n\t\t\t\t\t\t   entry->payload,\n\t\t\t\t\t\t   entry->payload_len,\n\t\t\t\t\t\t   entry->keyring_name,\n\t\t\t\t\t\t   KEY_CHECK, 0,\n\t\t\t\t\t\t   entry->keyring_name,\n\t\t\t\t\t\t   false, NULL, 0);\n\t\tlist_del(&entry->list);\n\t\tima_free_key_entry(entry);\n\t}\n}\n\ninline bool ima_should_queue_key(void)\n{\n\treturn !ima_process_keys;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}