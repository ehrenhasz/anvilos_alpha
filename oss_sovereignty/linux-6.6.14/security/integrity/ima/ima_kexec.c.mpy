{
  "module_name": "ima_kexec.c",
  "hash_id": "8f97cf2488e7112f3ed7c1024538a069e37f7595ad08a33daf6cecf2924f6ca0",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_kexec.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/kexec.h>\n#include <linux/of.h>\n#include <linux/ima.h>\n#include \"ima.h\"\n\n#ifdef CONFIG_IMA_KEXEC\nstatic int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\n\t\t\t\t     unsigned long segment_size)\n{\n\tstruct ima_queue_entry *qe;\n\tstruct seq_file file;\n\tstruct ima_kexec_hdr khdr;\n\tint ret = 0;\n\n\t \n\tfile.buf = vmalloc(segment_size);\n\tif (!file.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfile.size = segment_size;\n\tfile.read_pos = 0;\n\tfile.count = sizeof(khdr);\t \n\n\tmemset(&khdr, 0, sizeof(khdr));\n\tkhdr.version = 1;\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (file.count < file.size) {\n\t\t\tkhdr.count++;\n\t\t\tima_measurements_show(&file, qe);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tkhdr.buffer_size = file.count;\n\tif (ima_canonical_fmt) {\n\t\tkhdr.version = cpu_to_le16(khdr.version);\n\t\tkhdr.count = cpu_to_le64(khdr.count);\n\t\tkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\n\t}\n\tmemcpy(file.buf, &khdr, sizeof(khdr));\n\n\tprint_hex_dump_debug(\"ima dump: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     file.buf, file.count < 100 ? file.count : 100,\n\t\t\t     true);\n\n\t*buffer_size = file.count;\n\t*buffer = file.buf;\nout:\n\tif (ret == -EINVAL)\n\t\tvfree(file.buf);\n\treturn ret;\n}\n\n \nvoid ima_add_kexec_buffer(struct kimage *image)\n{\n\tstruct kexec_buf kbuf = { .image = image, .buf_align = PAGE_SIZE,\n\t\t\t\t  .buf_min = 0, .buf_max = ULONG_MAX,\n\t\t\t\t  .top_down = true };\n\tunsigned long binary_runtime_size;\n\n\t \n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size;\n\tsize_t kexec_segment_size;\n\tint ret;\n\n\t \n\tbinary_runtime_size = ima_get_binary_runtime_size();\n\tif (binary_runtime_size >= ULONG_MAX - PAGE_SIZE)\n\t\tkexec_segment_size = ULONG_MAX;\n\telse\n\t\tkexec_segment_size = ALIGN(ima_get_binary_runtime_size() +\n\t\t\t\t\t   PAGE_SIZE / 2, PAGE_SIZE);\n\tif ((kexec_segment_size == ULONG_MAX) ||\n\t    ((kexec_segment_size >> PAGE_SHIFT) > totalram_pages() / 2)) {\n\t\tpr_err(\"Binary measurement list too large.\\n\");\n\t\treturn;\n\t}\n\n\tima_dump_measurement_list(&kexec_buffer_size, &kexec_buffer,\n\t\t\t\t  kexec_segment_size);\n\tif (!kexec_buffer) {\n\t\tpr_err(\"Not enough memory for the kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tkbuf.buffer = kexec_buffer;\n\tkbuf.bufsz = kexec_buffer_size;\n\tkbuf.memsz = kexec_segment_size;\n\tret = kexec_add_buffer(&kbuf);\n\tif (ret) {\n\t\tpr_err(\"Error passing over kexec measurement buffer.\\n\");\n\t\tvfree(kexec_buffer);\n\t\treturn;\n\t}\n\n\timage->ima_buffer_addr = kbuf.mem;\n\timage->ima_buffer_size = kexec_segment_size;\n\timage->ima_buffer = kexec_buffer;\n\n\tpr_debug(\"kexec measurement buffer for the loaded kernel at 0x%lx.\\n\",\n\t\t kbuf.mem);\n}\n#endif  \n\n \nvoid __init ima_load_kexec_buffer(void)\n{\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size = 0;\n\tint rc;\n\n\trc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\n\tswitch (rc) {\n\tcase 0:\n\t\trc = ima_restore_measurement_list(kexec_buffer_size,\n\t\t\t\t\t\t  kexec_buffer);\n\t\tif (rc != 0)\n\t\t\tpr_err(\"Failed to restore the measurement list: %d\\n\",\n\t\t\t\trc);\n\n\t\tima_free_kexec_buffer();\n\t\tbreak;\n\tcase -ENOTSUPP:\n\t\tpr_debug(\"Restoring the measurement list not supported\\n\");\n\t\tbreak;\n\tcase -ENOENT:\n\t\tpr_debug(\"No measurement list to restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Error restoring the measurement list: %d\\n\", rc);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}