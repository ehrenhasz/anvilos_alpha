{
  "module_name": "ima_modsig.c",
  "hash_id": "7407eb73b893deb97f3481cf44a9f87f9b1248f968f0a0c7afe18d982e4d46b3",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_modsig.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module_signature.h>\n#include <keys/asymmetric-type.h>\n#include <crypto/pkcs7.h>\n\n#include \"ima.h\"\n\nstruct modsig {\n\tstruct pkcs7_message *pkcs7_msg;\n\n\tenum hash_algo hash_algo;\n\n\t \n\tconst u8 *digest;\n\tu32 digest_size;\n\n\t \n\tint raw_pkcs7_len;\n\tu8 raw_pkcs7[];\n};\n\n \nint ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,\n\t\t    struct modsig **modsig)\n{\n\tconst size_t marker_len = strlen(MODULE_SIG_STRING);\n\tconst struct module_signature *sig;\n\tstruct modsig *hdr;\n\tsize_t sig_len;\n\tconst void *p;\n\tint rc;\n\n\tif (buf_len <= marker_len + sizeof(*sig))\n\t\treturn -ENOENT;\n\n\tp = buf + buf_len - marker_len;\n\tif (memcmp(p, MODULE_SIG_STRING, marker_len))\n\t\treturn -ENOENT;\n\n\tbuf_len -= marker_len;\n\tsig = (const struct module_signature *)(p - sizeof(*sig));\n\n\trc = mod_check_sig(sig, buf_len, func_tokens[func]);\n\tif (rc)\n\t\treturn rc;\n\n\tsig_len = be32_to_cpu(sig->sig_len);\n\tbuf_len -= sig_len + sizeof(*sig);\n\n\t \n\thdr = kzalloc(sizeof(*hdr) + sig_len, GFP_KERNEL);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\thdr->pkcs7_msg = pkcs7_parse_message(buf + buf_len, sig_len);\n\tif (IS_ERR(hdr->pkcs7_msg)) {\n\t\trc = PTR_ERR(hdr->pkcs7_msg);\n\t\tkfree(hdr);\n\t\treturn rc;\n\t}\n\n\tmemcpy(hdr->raw_pkcs7, buf + buf_len, sig_len);\n\thdr->raw_pkcs7_len = sig_len;\n\n\t \n\thdr->hash_algo = HASH_ALGO__LAST;\n\n\t*modsig = hdr;\n\n\treturn 0;\n}\n\n \nvoid ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size)\n{\n\tint rc;\n\n\t \n\tsize -= modsig->raw_pkcs7_len + strlen(MODULE_SIG_STRING) +\n\t\tsizeof(struct module_signature);\n\trc = pkcs7_supply_detached_data(modsig->pkcs7_msg, buf, size);\n\tif (rc)\n\t\treturn;\n\n\t \n\trc = pkcs7_get_digest(modsig->pkcs7_msg, &modsig->digest,\n\t\t\t      &modsig->digest_size, &modsig->hash_algo);\n}\n\nint ima_modsig_verify(struct key *keyring, const struct modsig *modsig)\n{\n\treturn verify_pkcs7_message_sig(NULL, 0, modsig->pkcs7_msg, keyring,\n\t\t\t\t\tVERIFYING_MODULE_SIGNATURE, NULL, NULL);\n}\n\nint ima_get_modsig_digest(const struct modsig *modsig, enum hash_algo *algo,\n\t\t\t  const u8 **digest, u32 *digest_size)\n{\n\t*algo = modsig->hash_algo;\n\t*digest = modsig->digest;\n\t*digest_size = modsig->digest_size;\n\n\treturn 0;\n}\n\nint ima_get_raw_modsig(const struct modsig *modsig, const void **data,\n\t\t       u32 *data_len)\n{\n\t*data = &modsig->raw_pkcs7;\n\t*data_len = modsig->raw_pkcs7_len;\n\n\treturn 0;\n}\n\nvoid ima_free_modsig(struct modsig *modsig)\n{\n\tif (!modsig)\n\t\treturn;\n\n\tpkcs7_free_message(modsig->pkcs7_msg);\n\tkfree(modsig);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}