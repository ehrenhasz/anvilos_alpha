{
  "module_name": "ima_crypto.c",
  "hash_id": "8a8f86bfee76f6b75a7a8b64b00cc9948c52e580719d690416a3f97d9cf1356c",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_crypto.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/ratelimit.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <crypto/hash.h>\n\n#include \"ima.h\"\n\n \nstatic unsigned long ima_ahash_minsize;\nmodule_param_named(ahash_minsize, ima_ahash_minsize, ulong, 0644);\nMODULE_PARM_DESC(ahash_minsize, \"Minimum file size for ahash use\");\n\n \nstatic int ima_maxorder;\nstatic unsigned int ima_bufsize = PAGE_SIZE;\n\nstatic int param_set_bufsize(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long long size;\n\tint order;\n\n\tsize = memparse(val, NULL);\n\torder = get_order(size);\n\tif (order > MAX_ORDER)\n\t\treturn -EINVAL;\n\tima_maxorder = order;\n\tima_bufsize = PAGE_SIZE << order;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_bufsize = {\n\t.set = param_set_bufsize,\n\t.get = param_get_uint,\n};\n#define param_check_bufsize(name, p) __param_check(name, p, unsigned int)\n\nmodule_param_named(ahash_bufsize, ima_bufsize, bufsize, 0644);\nMODULE_PARM_DESC(ahash_bufsize, \"Maximum ahash buffer size\");\n\nstatic struct crypto_shash *ima_shash_tfm;\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstruct ima_algo_desc {\n\tstruct crypto_shash *tfm;\n\tenum hash_algo algo;\n};\n\nint ima_sha1_idx __ro_after_init;\nint ima_hash_algo_idx __ro_after_init;\n \nint ima_extra_slots __ro_after_init;\n\nstatic struct ima_algo_desc *ima_algo_array;\n\nstatic int __init ima_init_ima_crypto(void)\n{\n\tlong rc;\n\n\tima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\n\tif (IS_ERR(ima_shash_tfm)) {\n\t\trc = PTR_ERR(ima_shash_tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\",\n\t\t       hash_algo_name[ima_hash_algo], rc);\n\t\treturn rc;\n\t}\n\tpr_info(\"Allocated hash algorithm: %s\\n\",\n\t\thash_algo_name[ima_hash_algo]);\n\treturn 0;\n}\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc, i;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo == ima_hash_algo)\n\t\treturn tfm;\n\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip) + ima_extra_slots; i++)\n\t\tif (ima_algo_array[i].tfm && ima_algo_array[i].algo == algo)\n\t\t\treturn ima_algo_array[i].tfm;\n\n\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\trc = PTR_ERR(tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t       hash_algo_name[algo], rc);\n\t}\n\treturn tfm;\n}\n\nint __init ima_init_crypto(void)\n{\n\tenum hash_algo algo;\n\tlong rc;\n\tint i;\n\n\trc = ima_init_ima_crypto();\n\tif (rc)\n\t\treturn rc;\n\n\tima_sha1_idx = -1;\n\tima_hash_algo_idx = -1;\n\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip); i++) {\n\t\talgo = ima_tpm_chip->allocated_banks[i].crypto_id;\n\t\tif (algo == HASH_ALGO_SHA1)\n\t\t\tima_sha1_idx = i;\n\n\t\tif (algo == ima_hash_algo)\n\t\t\tima_hash_algo_idx = i;\n\t}\n\n\tif (ima_sha1_idx < 0) {\n\t\tima_sha1_idx = NR_BANKS(ima_tpm_chip) + ima_extra_slots++;\n\t\tif (ima_hash_algo == HASH_ALGO_SHA1)\n\t\t\tima_hash_algo_idx = ima_sha1_idx;\n\t}\n\n\tif (ima_hash_algo_idx < 0)\n\t\tima_hash_algo_idx = NR_BANKS(ima_tpm_chip) + ima_extra_slots++;\n\n\tima_algo_array = kcalloc(NR_BANKS(ima_tpm_chip) + ima_extra_slots,\n\t\t\t\t sizeof(*ima_algo_array), GFP_KERNEL);\n\tif (!ima_algo_array) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip); i++) {\n\t\talgo = ima_tpm_chip->allocated_banks[i].crypto_id;\n\t\tima_algo_array[i].algo = algo;\n\n\t\t \n\t\tif (algo == HASH_ALGO__LAST)\n\t\t\tcontinue;\n\n\t\tif (algo == ima_hash_algo) {\n\t\t\tima_algo_array[i].tfm = ima_shash_tfm;\n\t\t\tcontinue;\n\t\t}\n\n\t\tima_algo_array[i].tfm = ima_alloc_tfm(algo);\n\t\tif (IS_ERR(ima_algo_array[i].tfm)) {\n\t\t\tif (algo == HASH_ALGO_SHA1) {\n\t\t\t\trc = PTR_ERR(ima_algo_array[i].tfm);\n\t\t\t\tima_algo_array[i].tfm = NULL;\n\t\t\t\tgoto out_array;\n\t\t\t}\n\n\t\t\tima_algo_array[i].tfm = NULL;\n\t\t}\n\t}\n\n\tif (ima_sha1_idx >= NR_BANKS(ima_tpm_chip)) {\n\t\tif (ima_hash_algo == HASH_ALGO_SHA1) {\n\t\t\tima_algo_array[ima_sha1_idx].tfm = ima_shash_tfm;\n\t\t} else {\n\t\t\tima_algo_array[ima_sha1_idx].tfm =\n\t\t\t\t\t\tima_alloc_tfm(HASH_ALGO_SHA1);\n\t\t\tif (IS_ERR(ima_algo_array[ima_sha1_idx].tfm)) {\n\t\t\t\trc = PTR_ERR(ima_algo_array[ima_sha1_idx].tfm);\n\t\t\t\tgoto out_array;\n\t\t\t}\n\t\t}\n\n\t\tima_algo_array[ima_sha1_idx].algo = HASH_ALGO_SHA1;\n\t}\n\n\tif (ima_hash_algo_idx >= NR_BANKS(ima_tpm_chip) &&\n\t    ima_hash_algo_idx != ima_sha1_idx) {\n\t\tima_algo_array[ima_hash_algo_idx].tfm = ima_shash_tfm;\n\t\tima_algo_array[ima_hash_algo_idx].algo = ima_hash_algo;\n\t}\n\n\treturn 0;\nout_array:\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip) + ima_extra_slots; i++) {\n\t\tif (!ima_algo_array[i].tfm ||\n\t\t    ima_algo_array[i].tfm == ima_shash_tfm)\n\t\t\tcontinue;\n\n\t\tcrypto_free_shash(ima_algo_array[i].tfm);\n\t}\n\tkfree(ima_algo_array);\nout:\n\tcrypto_free_shash(ima_shash_tfm);\n\treturn rc;\n}\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tint i;\n\n\tif (tfm == ima_shash_tfm)\n\t\treturn;\n\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip) + ima_extra_slots; i++)\n\t\tif (ima_algo_array[i].tfm == tfm)\n\t\t\treturn;\n\n\tcrypto_free_shash(tfm);\n}\n\n \nstatic void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\n\t\t\t     int last_warn)\n{\n\tvoid *ptr;\n\tint order = ima_maxorder;\n\tgfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\n\n\tif (order)\n\t\torder = min(get_order(max_size), order);\n\n\tfor (; order; order--) {\n\t\tptr = (void *)__get_free_pages(gfp_mask, order);\n\t\tif (ptr) {\n\t\t\t*allocated_size = PAGE_SIZE << order;\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\t \n\n\tgfp_mask = GFP_KERNEL;\n\n\tif (!last_warn)\n\t\tgfp_mask |= __GFP_NOWARN;\n\n\tptr = (void *)__get_free_pages(gfp_mask, 0);\n\tif (ptr) {\n\t\t*allocated_size = PAGE_SIZE;\n\t\treturn ptr;\n\t}\n\n\t*allocated_size = 0;\n\treturn NULL;\n}\n\n \nstatic void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}\n\nstatic struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}\n\nstatic void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}\n\nstatic inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int ima_calc_file_hash_atfm(struct file *file,\n\t\t\t\t   struct ima_digest_data *hash,\n\t\t\t\t   struct crypto_ahash *tfm)\n{\n\tloff_t i_size, offset;\n\tchar *rbuf[2] = { NULL, };\n\tint rc, rbuf_len, active = 0, ahash_rc = 0;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg[1];\n\tstruct crypto_wait wait;\n\tsize_t rbuf_size[2];\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out1;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out2;\n\n\t \n\trbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\n\tif (!rbuf[0]) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t \n\tif (i_size > rbuf_size[0]) {\n\t\t \n\t\trbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\n\t\t\t\t\t  &rbuf_size[1], 0);\n\t}\n\n\tfor (offset = 0; offset < i_size; offset += rbuf_len) {\n\t\tif (!rbuf[1] && offset) {\n\t\t\t \n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\t\t \n\t\trbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\n\t\trc = integrity_kernel_read(file, offset, rbuf[active],\n\t\t\t\t\t   rbuf_len);\n\t\tif (rc != rbuf_len) {\n\t\t\tif (rc >= 0)\n\t\t\t\trc = -EINVAL;\n\t\t\t \n\t\t\tahash_wait(ahash_rc, &wait);\n\t\t\tgoto out3;\n\t\t}\n\n\t\tif (rbuf[1] && offset) {\n\t\t\t \n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\n\t\tsg_init_one(&sg[0], rbuf[active], rbuf_len);\n\t\tahash_request_set_crypt(req, sg, NULL, rbuf_len);\n\n\t\tahash_rc = crypto_ahash_update(req);\n\n\t\tif (rbuf[1])\n\t\t\tactive = !active;  \n\t}\n\t \n\trc = ahash_wait(ahash_rc, &wait);\nout3:\n\tima_free_pages(rbuf[0], rbuf_size[0]);\n\tima_free_pages(rbuf[1], rbuf_size[1]);\nout2:\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout1:\n\tahash_request_free(req);\n\treturn rc;\n}\n\nstatic int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_atfm(file, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}\n\nstatic int ima_calc_file_hash_tfm(struct file *file,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_shash *tfm)\n{\n\tloff_t i_size, offset = 0;\n\tchar *rbuf;\n\tint rc;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out;\n\n\trbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\twhile (offset < i_size) {\n\t\tint rbuf_len;\n\n\t\trbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\n\t\tif (rbuf_len < 0) {\n\t\t\trc = rbuf_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuf_len == 0) {\t \n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\toffset += rbuf_len;\n\n\t\trc = crypto_shash_update(shash, rbuf, rbuf_len);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tkfree(rbuf);\nout:\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}\n\nstatic int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_tfm(file, hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}\n\n \nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\tstruct file *f = file;\n\tbool new_file_instance = false;\n\n\t \n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tint flags = file->f_flags & ~(O_WRONLY | O_APPEND |\n\t\t\t\tO_TRUNC | O_CREAT | O_NOCTTY | O_EXCL);\n\t\tflags |= O_RDONLY;\n\t\tf = dentry_open(&file->f_path, flags, file->f_cred);\n\t\tif (IS_ERR(f))\n\t\t\treturn PTR_ERR(f);\n\n\t\tnew_file_instance = true;\n\t}\n\n\ti_size = i_size_read(file_inode(f));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(f, hash);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = ima_calc_file_shash(f, hash);\nout:\n\tif (new_file_instance)\n\t\tfput(f);\n\treturn rc;\n}\n\n \nstatic int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\n\t\t\t\t\t struct ima_template_entry *entry,\n\t\t\t\t\t int tfm_idx)\n{\n\tSHASH_DESC_ON_STACK(shash, ima_algo_array[tfm_idx].tfm);\n\tstruct ima_template_desc *td = entry->template_desc;\n\tint num_fields = entry->template_desc->num_fields;\n\tint rc, i;\n\n\tshash->tfm = ima_algo_array[tfm_idx].tfm;\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\n\t\tu8 *data_to_hash = field_data[i].data;\n\t\tu32 datalen = field_data[i].len;\n\t\tu32 datalen_to_hash = !ima_canonical_fmt ?\n\t\t\t\tdatalen : (__force u32)cpu_to_le32(datalen);\n\n\t\tif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t\t(const u8 *) &datalen_to_hash,\n\t\t\t\t\t\tsizeof(datalen_to_hash));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(td->fields[i]->field_id, \"n\") == 0) {\n\t\t\tmemcpy(buffer, data_to_hash, datalen);\n\t\t\tdata_to_hash = buffer;\n\t\t\tdatalen = IMA_EVENT_NAME_LEN_MAX + 1;\n\t\t}\n\t\trc = crypto_shash_update(shash, data_to_hash, datalen);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, entry->digests[tfm_idx].digest);\n\n\treturn rc;\n}\n\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_entry *entry)\n{\n\tu16 alg_id;\n\tint rc, i;\n\n\trc = ima_calc_field_array_hash_tfm(field_data, entry, ima_sha1_idx);\n\tif (rc)\n\t\treturn rc;\n\n\tentry->digests[ima_sha1_idx].alg_id = TPM_ALG_SHA1;\n\n\tfor (i = 0; i < NR_BANKS(ima_tpm_chip) + ima_extra_slots; i++) {\n\t\tif (i == ima_sha1_idx)\n\t\t\tcontinue;\n\n\t\tif (i < NR_BANKS(ima_tpm_chip)) {\n\t\t\talg_id = ima_tpm_chip->allocated_banks[i].alg_id;\n\t\t\tentry->digests[i].alg_id = alg_id;\n\t\t}\n\n\t\t \n\t\tif (!ima_algo_array[i].tfm) {\n\t\t\tmemcpy(entry->digests[i].digest,\n\t\t\t       entry->digests[ima_sha1_idx].digest,\n\t\t\t       TPM_DIGEST_SIZE);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = ima_calc_field_array_hash_tfm(field_data, entry, i);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic int calc_buffer_ahash_atfm(const void *buf, loff_t len,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_ahash *tfm)\n{\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_wait wait;\n\tint rc, ahash_rc = 0;\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out;\n\n\tsg_init_one(&sg, buf, len);\n\tahash_request_set_crypt(req, &sg, NULL, len);\n\n\tahash_rc = crypto_ahash_update(req);\n\n\t \n\trc = ahash_wait(ahash_rc, &wait);\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout:\n\tahash_request_free(req);\n\treturn rc;\n}\n\nstatic int calc_buffer_ahash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}\n\nstatic int calc_buffer_shash_tfm(const void *buf, loff_t size,\n\t\t\t\tstruct ima_digest_data *hash,\n\t\t\t\tstruct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tunsigned int len;\n\tint rc;\n\n\tshash->tfm = tfm;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\twhile (size) {\n\t\tlen = size < PAGE_SIZE ? size : PAGE_SIZE;\n\t\trc = crypto_shash_update(shash, buf, len);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}\n\nstatic int calc_buffer_shash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_shash_tfm(buf, len, hash, tfm);\n\n\tima_free_tfm(tfm);\n\treturn rc;\n}\n\nint ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash)\n{\n\tint rc;\n\n\tif (ima_ahash_minsize && len >= ima_ahash_minsize) {\n\t\trc = calc_buffer_ahash(buf, len, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn calc_buffer_shash(buf, len, hash);\n}\n\nstatic void ima_pcrread(u32 idx, struct tpm_digest *d)\n{\n\tif (!ima_tpm_chip)\n\t\treturn;\n\n\tif (tpm_pcr_read(ima_tpm_chip, idx, d) != 0)\n\t\tpr_err(\"Error Communicating to TPM chip\\n\");\n}\n\n \nstatic int ima_calc_boot_aggregate_tfm(char *digest, u16 alg_id,\n\t\t\t\t       struct crypto_shash *tfm)\n{\n\tstruct tpm_digest d = { .alg_id = alg_id, .digest = {0} };\n\tint rc;\n\tu32 i;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\n\tpr_devel(\"calculating the boot-aggregate based on TPM bank: %04x\\n\",\n\t\t d.alg_id);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\n\t\tima_pcrread(i, &d);\n\t\t \n\t\trc = crypto_shash_update(shash, d.digest,\n\t\t\t\t\t crypto_shash_digestsize(tfm));\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t}\n\t \n\tif (alg_id != TPM_ALG_SHA1) {\n\t\tfor (i = TPM_PCR8; i < TPM_PCR10; i++) {\n\t\t\tima_pcrread(i, &d);\n\t\t\trc = crypto_shash_update(shash, d.digest,\n\t\t\t\t\t\tcrypto_shash_digestsize(tfm));\n\t\t}\n\t}\n\tif (!rc)\n\t\tcrypto_shash_final(shash, digest);\n\treturn rc;\n}\n\nint ima_calc_boot_aggregate(struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tu16 crypto_id, alg_id;\n\tint rc, i, bank_idx = -1;\n\n\tfor (i = 0; i < ima_tpm_chip->nr_allocated_banks; i++) {\n\t\tcrypto_id = ima_tpm_chip->allocated_banks[i].crypto_id;\n\t\tif (crypto_id == hash->algo) {\n\t\t\tbank_idx = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (crypto_id == HASH_ALGO_SHA256)\n\t\t\tbank_idx = i;\n\n\t\tif (bank_idx == -1 && crypto_id == HASH_ALGO_SHA1)\n\t\t\tbank_idx = i;\n\t}\n\n\tif (bank_idx == -1) {\n\t\tpr_err(\"No suitable TPM algorithm for boot aggregate\\n\");\n\t\treturn 0;\n\t}\n\n\thash->algo = ima_tpm_chip->allocated_banks[bank_idx].crypto_id;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\thash->length = crypto_shash_digestsize(tfm);\n\talg_id = ima_tpm_chip->allocated_banks[bank_idx].alg_id;\n\trc = ima_calc_boot_aggregate_tfm(hash->digest, alg_id, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}