{
  "module_name": "ima_init.c",
  "hash_id": "4c611b67fd489183d50b1ffe509120bfbdac5fee5f074eb63d8c16e7b90946fe",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_init.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/ima.h>\n#include <generated/utsrelease.h>\n\n#include \"ima.h\"\n\n \nconst char boot_aggregate_name[] = \"boot_aggregate\";\nstruct tpm_chip *ima_tpm_chip;\n\n \nstatic int __init ima_add_boot_aggregate(void)\n{\n\tstatic const char op[] = \"add_boot_aggregate\";\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry;\n\tstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\n\tstruct ima_event_data event_data = { .iint = iint,\n\t\t\t\t\t     .filename = boot_aggregate_name };\n\tstruct ima_max_digest_data hash;\n\tint result = -ENOMEM;\n\tint violation = 0;\n\n\tmemset(iint, 0, sizeof(*iint));\n\tmemset(&hash, 0, sizeof(hash));\n\tiint->ima_hash = &hash.hdr;\n\tiint->ima_hash->algo = ima_hash_algo;\n\tiint->ima_hash->length = hash_digest_size[ima_hash_algo];\n\n\t \n\tif (ima_tpm_chip) {\n\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\t\tif (result < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tresult = ima_alloc_init_template(&event_data, &entry, NULL);\n\tif (result < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto err_out;\n\t}\n\n\tresult = ima_store_template(entry, violation, NULL,\n\t\t\t\t    boot_aggregate_name,\n\t\t\t\t    CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0) {\n\t\tima_free_template_entry(entry);\n\t\taudit_cause = \"store_entry\";\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\n\t\t\t    audit_cause, result, 0);\n\treturn result;\n}\n\n#ifdef CONFIG_IMA_LOAD_X509\nvoid __init ima_load_x509(void)\n{\n\tint unset_flags = ima_policy_flag & IMA_APPRAISE;\n\n\tima_policy_flag &= ~unset_flags;\n\tintegrity_load_x509(INTEGRITY_KEYRING_IMA, CONFIG_IMA_X509_PATH);\n\n\t \n\tevm_load_x509();\n\n\tima_policy_flag |= unset_flags;\n}\n#endif\n\nint __init ima_init(void)\n{\n\tint rc;\n\n\tima_tpm_chip = tpm_default_chip();\n\tif (!ima_tpm_chip)\n\t\tpr_info(\"No TPM chip found, activating TPM-bypass!\\n\");\n\n\trc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ima_init_crypto();\n\tif (rc)\n\t\treturn rc;\n\trc = ima_init_template();\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tima_load_kexec_buffer();\n\n\trc = ima_init_digests();\n\tif (rc != 0)\n\t\treturn rc;\n\trc = ima_add_boot_aggregate();\t \n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_policy();\n\n\trc = ima_fs_init();\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_key_queue();\n\n\tima_measure_critical_data(\"kernel_info\", \"kernel_version\",\n\t\t\t\t  UTS_RELEASE, strlen(UTS_RELEASE), false,\n\t\t\t\t  NULL, 0);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}