{
  "module_name": "ima_template_lib.c",
  "hash_id": "b01153f6d934264d8b300e11fa65f6592a268d686b1871ac87ecb1b0c3d39ea3",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/ima/ima_template_lib.c",
  "human_readable_source": "\n \n\n#include \"ima_template_lib.h\"\n#include <linux/xattr.h>\n#include <linux/evm.h>\n\nstatic bool ima_template_hash_algo_allowed(u8 algo)\n{\n\tif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\n\t\treturn true;\n\n\treturn false;\n}\n\nenum data_formats {\n\tDATA_FMT_DIGEST = 0,\n\tDATA_FMT_DIGEST_WITH_ALGO,\n\tDATA_FMT_DIGEST_WITH_TYPE_AND_ALGO,\n\tDATA_FMT_STRING,\n\tDATA_FMT_HEX,\n\tDATA_FMT_UINT\n};\n\nenum digest_type {\n\tDIGEST_TYPE_IMA,\n\tDIGEST_TYPE_VERITY,\n\tDIGEST_TYPE__LAST\n};\n\n#define DIGEST_TYPE_NAME_LEN_MAX 7\t \nstatic const char * const digest_type_name[DIGEST_TYPE__LAST] = {\n\t[DIGEST_TYPE_IMA] = \"ima\",\n\t[DIGEST_TYPE_VERITY] = \"verity\"\n};\n\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t \n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}\n\nstatic void ima_show_template_data_ascii(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf_ptr = field_data->data;\n\tu32 buflen = field_data->len;\n\n\tswitch (datafmt) {\n\tcase DATA_FMT_DIGEST_WITH_TYPE_AND_ALGO:\n\tcase DATA_FMT_DIGEST_WITH_ALGO:\n\t\tbuf_ptr = strrchr(field_data->data, ':');\n\t\tif (buf_ptr != field_data->data)\n\t\t\tseq_printf(m, \"%s\", field_data->data);\n\n\t\t \n\t\tbuf_ptr += 2;\n\t\tbuflen -= buf_ptr - field_data->data;\n\t\tfallthrough;\n\tcase DATA_FMT_DIGEST:\n\tcase DATA_FMT_HEX:\n\t\tif (!buflen)\n\t\t\tbreak;\n\t\tima_print_digest(m, buf_ptr, buflen);\n\t\tbreak;\n\tcase DATA_FMT_STRING:\n\t\tseq_printf(m, \"%s\", buf_ptr);\n\t\tbreak;\n\tcase DATA_FMT_UINT:\n\t\tswitch (field_data->len) {\n\t\tcase sizeof(u8):\n\t\t\tseq_printf(m, \"%u\", *(u8 *)buf_ptr);\n\t\t\tbreak;\n\t\tcase sizeof(u16):\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tseq_printf(m, \"%u\",\n\t\t\t\t\t   le16_to_cpu(*(__le16 *)buf_ptr));\n\t\t\telse\n\t\t\t\tseq_printf(m, \"%u\", *(u16 *)buf_ptr);\n\t\t\tbreak;\n\t\tcase sizeof(u32):\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tseq_printf(m, \"%u\",\n\t\t\t\t\t   le32_to_cpu(*(__le32 *)buf_ptr));\n\t\t\telse\n\t\t\t\tseq_printf(m, \"%u\", *(u32 *)buf_ptr);\n\t\t\tbreak;\n\t\tcase sizeof(u64):\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tseq_printf(m, \"%llu\",\n\t\t\t\t\t   le64_to_cpu(*(__le64 *)buf_ptr));\n\t\t\telse\n\t\t\t\tseq_printf(m, \"%llu\", *(u64 *)buf_ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ima_show_template_data_binary(struct seq_file *m,\n\t\t\t\t\t  enum ima_show_type show,\n\t\t\t\t\t  enum data_formats datafmt,\n\t\t\t\t\t  struct ima_field_data *field_data)\n{\n\tu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\n\t    strlen(field_data->data) : field_data->len;\n\n\tif (show != IMA_SHOW_BINARY_NO_FIELD_LEN) {\n\t\tu32 field_len = !ima_canonical_fmt ?\n\t\t\t\tlen : (__force u32)cpu_to_le32(len);\n\n\t\tima_putc(m, &field_len, sizeof(field_len));\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tima_putc(m, field_data->data, len);\n}\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ima_show_template_digest(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST, field_data);\n}\n\nvoid ima_show_template_digest_ng(struct seq_file *m, enum ima_show_type show,\n\t\t\t\t struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST_WITH_ALGO,\n\t\t\t\t     field_data);\n}\n\nvoid ima_show_template_digest_ngv2(struct seq_file *m, enum ima_show_type show,\n\t\t\t\t   struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show,\n\t\t\t\t     DATA_FMT_DIGEST_WITH_TYPE_AND_ALGO,\n\t\t\t\t     field_data);\n}\n\nvoid ima_show_template_string(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_STRING, field_data);\n}\n\nvoid ima_show_template_sig(struct seq_file *m, enum ima_show_type show,\n\t\t\t   struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_HEX, field_data);\n}\n\nvoid ima_show_template_buf(struct seq_file *m, enum ima_show_type show,\n\t\t\t   struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_HEX, field_data);\n}\n\nvoid ima_show_template_uint(struct seq_file *m, enum ima_show_type show,\n\t\t\t    struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_UINT, field_data);\n}\n\n \nint ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(*(__le32 *)bufp);\n\t\t\telse\n\t\t\t\tfields[i].len = *(u32 *)bufp;\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}\n\nstatic int ima_eventdigest_init_common(const u8 *digest, u32 digestsize,\n\t\t\t\t       u8 digest_type, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t \n\tu8 buffer[DIGEST_TYPE_NAME_LEN_MAX + CRYPTO_MAX_ALG_NAME + 2 +\n\t\tIMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (digest_type < DIGEST_TYPE__LAST && hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_TYPE_AND_ALGO;\n\t\toffset += 1 + sprintf(buffer, \"%s:%s:\",\n\t\t\t\t      digest_type_name[digest_type],\n\t\t\t\t      hash_algo_name[hash_algo]);\n\t} else if (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += 1 + sprintf(buffer, \"%s:\",\n\t\t\t\t      hash_algo_name[hash_algo]);\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t \n\t\toffset += hash_digest_size[hash_algo];\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}\n\n \nint ima_eventdigest_init(struct ima_event_data *event_data,\n\t\t\t struct ima_field_data *field_data)\n{\n\tstruct ima_max_digest_data hash;\n\tu8 *cur_digest = NULL;\n\tu32 cur_digestsize = 0;\n\tstruct inode *inode;\n\tint result;\n\n\tmemset(&hash, 0, sizeof(hash));\n\n\tif (event_data->violation)\t \n\t\tgoto out;\n\n\tif (ima_template_hash_algo_allowed(event_data->iint->ima_hash->algo)) {\n\t\tcur_digest = event_data->iint->ima_hash->digest;\n\t\tcur_digestsize = event_data->iint->ima_hash->length;\n\t\tgoto out;\n\t}\n\n\tif ((const char *)event_data->filename == boot_aggregate_name) {\n\t\tif (ima_tpm_chip) {\n\t\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\n\t\t\t \n\t\t\tif (!result && hash.hdr.algo != HASH_ALGO_SHA1)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (result < 0)\n\t\t\t\tmemset(&hash, 0, sizeof(hash));\n\t\t}\n\n\t\tcur_digest = hash.hdr.digest;\n\t\tcur_digestsize = hash_digest_size[HASH_ALGO_SHA1];\n\t\tgoto out;\n\t}\n\n\tif (!event_data->file)\t \n\t\treturn -EINVAL;\n\n\tinode = file_inode(event_data->file);\n\thash.hdr.algo = ima_template_hash_algo_allowed(ima_hash_algo) ?\n\t    ima_hash_algo : HASH_ALGO_SHA1;\n\tresult = ima_calc_file_hash(event_data->file, &hash.hdr);\n\tif (result) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    event_data->filename, \"collect_data\",\n\t\t\t\t    \"failed\", result, 0);\n\t\treturn result;\n\t}\n\tcur_digest = hash.hdr.digest;\n\tcur_digestsize = hash.hdr.length;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   DIGEST_TYPE__LAST, HASH_ALGO__LAST,\n\t\t\t\t\t   field_data);\n}\n\n \nint ima_eventdigest_ng_init(struct ima_event_data *event_data,\n\t\t\t    struct ima_field_data *field_data)\n{\n\tu8 *cur_digest = NULL, hash_algo = ima_hash_algo;\n\tu32 cur_digestsize = 0;\n\n\tif (event_data->violation)\t \n\t\tgoto out;\n\n\tcur_digest = event_data->iint->ima_hash->digest;\n\tcur_digestsize = event_data->iint->ima_hash->length;\n\n\thash_algo = event_data->iint->ima_hash->algo;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   DIGEST_TYPE__LAST, hash_algo,\n\t\t\t\t\t   field_data);\n}\n\n \nint ima_eventdigest_ngv2_init(struct ima_event_data *event_data,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tu8 *cur_digest = NULL, hash_algo = ima_hash_algo;\n\tu32 cur_digestsize = 0;\n\tu8 digest_type = DIGEST_TYPE_IMA;\n\n\tif (event_data->violation)\t \n\t\tgoto out;\n\n\tcur_digest = event_data->iint->ima_hash->digest;\n\tcur_digestsize = event_data->iint->ima_hash->length;\n\n\thash_algo = event_data->iint->ima_hash->algo;\n\tif (event_data->iint->flags & IMA_VERITY_REQUIRED)\n\t\tdigest_type = DIGEST_TYPE_VERITY;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   digest_type, hash_algo,\n\t\t\t\t\t   field_data);\n}\n\n \nint ima_eventdigest_modsig_init(struct ima_event_data *event_data,\n\t\t\t\tstruct ima_field_data *field_data)\n{\n\tenum hash_algo hash_algo;\n\tconst u8 *cur_digest;\n\tu32 cur_digestsize;\n\n\tif (!event_data->modsig)\n\t\treturn 0;\n\n\tif (event_data->violation) {\n\t\t \n\t\thash_algo = HASH_ALGO_SHA1;\n\t\tcur_digest = NULL;\n\t\tcur_digestsize = 0;\n\t} else {\n\t\tint rc;\n\n\t\trc = ima_get_modsig_digest(event_data->modsig, &hash_algo,\n\t\t\t\t\t   &cur_digest, &cur_digestsize);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\telse if (hash_algo == HASH_ALGO__LAST || cur_digestsize == 0)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   DIGEST_TYPE__LAST, hash_algo,\n\t\t\t\t\t   field_data);\n}\n\nstatic int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t \n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}\n\n \nint ima_eventname_init(struct ima_event_data *event_data,\n\t\t       struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, true);\n}\n\n \nint ima_eventname_ng_init(struct ima_event_data *event_data,\n\t\t\t  struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, false);\n}\n\n \nint ima_eventsig_init(struct ima_event_data *event_data,\n\t\t      struct ima_field_data *field_data)\n{\n\tstruct evm_ima_xattr_data *xattr_value = event_data->xattr_value;\n\n\tif (!xattr_value ||\n\t    (xattr_value->type != EVM_IMA_XATTR_DIGSIG &&\n\t     xattr_value->type != IMA_VERITY_DIGSIG))\n\t\treturn ima_eventevmsig_init(event_data, field_data);\n\n\treturn ima_write_template_field_data(xattr_value, event_data->xattr_len,\n\t\t\t\t\t     DATA_FMT_HEX, field_data);\n}\n\n \nint ima_eventbuf_init(struct ima_event_data *event_data,\n\t\t      struct ima_field_data *field_data)\n{\n\tif ((!event_data->buf) || (event_data->buf_len == 0))\n\t\treturn 0;\n\n\treturn ima_write_template_field_data(event_data->buf,\n\t\t\t\t\t     event_data->buf_len, DATA_FMT_HEX,\n\t\t\t\t\t     field_data);\n}\n\n \nint ima_eventmodsig_init(struct ima_event_data *event_data,\n\t\t\t struct ima_field_data *field_data)\n{\n\tconst void *data;\n\tu32 data_len;\n\tint rc;\n\n\tif (!event_data->modsig)\n\t\treturn 0;\n\n\t \n\trc = ima_get_raw_modsig(event_data->modsig, &data, &data_len);\n\tif (rc)\n\t\treturn rc;\n\n\treturn ima_write_template_field_data(data, data_len, DATA_FMT_HEX,\n\t\t\t\t\t     field_data);\n}\n\n \nint ima_eventevmsig_init(struct ima_event_data *event_data,\n\t\t\t struct ima_field_data *field_data)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tint rc = 0;\n\n\tif (!event_data->file)\n\t\treturn 0;\n\n\trc = vfs_getxattr_alloc(&nop_mnt_idmap, file_dentry(event_data->file),\n\t\t\t\tXATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0 || xattr_data->type != EVM_XATTR_PORTABLE_DIGSIG) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ima_write_template_field_data((char *)xattr_data, rc, DATA_FMT_HEX,\n\t\t\t\t\t   field_data);\n\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\n\nstatic int ima_eventinodedac_init_common(struct ima_event_data *event_data,\n\t\t\t\t\t struct ima_field_data *field_data,\n\t\t\t\t\t bool get_uid)\n{\n\tunsigned int id;\n\n\tif (!event_data->file)\n\t\treturn 0;\n\n\tif (get_uid)\n\t\tid = i_uid_read(file_inode(event_data->file));\n\telse\n\t\tid = i_gid_read(file_inode(event_data->file));\n\n\tif (ima_canonical_fmt) {\n\t\tif (sizeof(id) == sizeof(u16))\n\t\t\tid = (__force u16)cpu_to_le16(id);\n\t\telse\n\t\t\tid = (__force u32)cpu_to_le32(id);\n\t}\n\n\treturn ima_write_template_field_data((void *)&id, sizeof(id),\n\t\t\t\t\t     DATA_FMT_UINT, field_data);\n}\n\n \nint ima_eventinodeuid_init(struct ima_event_data *event_data,\n\t\t\t   struct ima_field_data *field_data)\n{\n\treturn ima_eventinodedac_init_common(event_data, field_data, true);\n}\n\n \nint ima_eventinodegid_init(struct ima_event_data *event_data,\n\t\t\t   struct ima_field_data *field_data)\n{\n\treturn ima_eventinodedac_init_common(event_data, field_data, false);\n}\n\n \nint ima_eventinodemode_init(struct ima_event_data *event_data,\n\t\t\t    struct ima_field_data *field_data)\n{\n\tstruct inode *inode;\n\tu16 mode;\n\n\tif (!event_data->file)\n\t\treturn 0;\n\n\tinode = file_inode(event_data->file);\n\tmode = inode->i_mode;\n\tif (ima_canonical_fmt)\n\t\tmode = (__force u16)cpu_to_le16(mode);\n\n\treturn ima_write_template_field_data((char *)&mode, sizeof(mode),\n\t\t\t\t\t     DATA_FMT_UINT, field_data);\n}\n\nstatic int ima_eventinodexattrs_init_common(struct ima_event_data *event_data,\n\t\t\t\t\t    struct ima_field_data *field_data,\n\t\t\t\t\t    char type)\n{\n\tu8 *buffer = NULL;\n\tint rc;\n\n\tif (!event_data->file)\n\t\treturn 0;\n\n\trc = evm_read_protected_xattrs(file_dentry(event_data->file), NULL, 0,\n\t\t\t\t       type, ima_canonical_fmt);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tbuffer = kmalloc(rc, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\trc = evm_read_protected_xattrs(file_dentry(event_data->file), buffer,\n\t\t\t\t       rc, type, ima_canonical_fmt);\n\tif (rc < 0) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ima_write_template_field_data((char *)buffer, rc, DATA_FMT_HEX,\n\t\t\t\t\t   field_data);\nout:\n\tkfree(buffer);\n\treturn rc;\n}\n\n \nint ima_eventinodexattrnames_init(struct ima_event_data *event_data,\n\t\t\t\t  struct ima_field_data *field_data)\n{\n\treturn ima_eventinodexattrs_init_common(event_data, field_data, 'n');\n}\n\n \nint ima_eventinodexattrlengths_init(struct ima_event_data *event_data,\n\t\t\t\t    struct ima_field_data *field_data)\n{\n\treturn ima_eventinodexattrs_init_common(event_data, field_data, 'l');\n}\n\n \nint ima_eventinodexattrvalues_init(struct ima_event_data *event_data,\n\t\t\t\t   struct ima_field_data *field_data)\n{\n\treturn ima_eventinodexattrs_init_common(event_data, field_data, 'v');\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}