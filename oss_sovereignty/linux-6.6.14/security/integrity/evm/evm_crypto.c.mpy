{
  "module_name": "evm_crypto.c",
  "hash_id": "b1294eaffd3f953bcf499549722730e16a9c83d3fbdbb33b3889b302bcd6f037",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/evm/evm_crypto.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"EVM: \"fmt\n\n#include <linux/export.h>\n#include <linux/crypto.h>\n#include <linux/xattr.h>\n#include <linux/evm.h>\n#include <keys/encrypted-type.h>\n#include <crypto/hash.h>\n#include <crypto/hash_info.h>\n#include \"evm.h\"\n\n#define EVMKEY \"evm-key\"\n#define MAX_KEY_SIZE 128\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic const int evmkey_len = MAX_KEY_SIZE;\n\nstatic struct crypto_shash *hmac_tfm;\nstatic struct crypto_shash *evm_tfm[HASH_ALGO__LAST];\n\nstatic DEFINE_MUTEX(mutex);\n\n#define EVM_SET_KEY_BUSY 0\n\nstatic unsigned long evm_set_key_flags;\n\nstatic const char evm_hmac[] = \"hmac(sha1)\";\n\n \nint evm_set_key(void *key, size_t keylen)\n{\n\tint rc;\n\n\trc = -EBUSY;\n\tif (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))\n\t\tgoto busy;\n\trc = -EINVAL;\n\tif (keylen > MAX_KEY_SIZE)\n\t\tgoto inval;\n\tmemcpy(evmkey, key, keylen);\n\tevm_initialized |= EVM_INIT_HMAC;\n\tpr_info(\"key initialized\\n\");\n\treturn 0;\ninval:\n\tclear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);\nbusy:\n\tpr_err(\"key initialization failed\\n\");\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(evm_set_key);\n\nstatic struct shash_desc *init_desc(char type, uint8_t hash_algo)\n{\n\tlong rc;\n\tconst char *algo;\n\tstruct crypto_shash **tfm, *tmp_tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\tif (hash_algo >= HASH_ALGO__LAST)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\ttfm = &evm_tfm[hash_algo];\n\t\talgo = hash_algo_name[hash_algo];\n\t}\n\n\tif (*tfm)\n\t\tgoto alloc;\n\tmutex_lock(&mutex);\n\tif (*tfm)\n\t\tgoto unlock;\n\n\ttmp_tfm = crypto_alloc_shash(algo, 0, CRYPTO_NOLOAD);\n\tif (IS_ERR(tmp_tfm)) {\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo,\n\t\t       PTR_ERR(tmp_tfm));\n\t\tmutex_unlock(&mutex);\n\t\treturn ERR_CAST(tmp_tfm);\n\t}\n\tif (type == EVM_XATTR_HMAC) {\n\t\trc = crypto_shash_setkey(tmp_tfm, evmkey, evmkey_len);\n\t\tif (rc) {\n\t\t\tcrypto_free_shash(tmp_tfm);\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t}\n\t*tfm = tmp_tfm;\nunlock:\n\tmutex_unlock(&mutex);\nalloc:\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}\n\n \nstatic void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char type, char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\t \n\tif (type != EVM_XATTR_PORTABLE_DIGSIG) {\n\t\thmac_misc.ino = inode->i_ino;\n\t\thmac_misc.generation = inode->i_generation;\n\t}\n\t \n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif ((evm_hmac_attrs & EVM_ATTR_FSUUID) &&\n\t    type != EVM_XATTR_PORTABLE_DIGSIG)\n\t\tcrypto_shash_update(desc, (u8 *)&inode->i_sb->s_uuid, UUID_SIZE);\n\tcrypto_shash_final(desc, digest);\n\n\tpr_debug(\"hmac_misc: (%zu) [%*phN]\\n\", sizeof(struct h_misc),\n\t\t (int)sizeof(struct h_misc), &hmac_misc);\n}\n\n \nstatic void dump_security_xattr_l(const char *prefix, const void *src,\n\t\t\t\t  size_t count)\n{\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\n\tchar *asciihex, *p;\n\n\tp = asciihex = kmalloc(count * 2 + 1, GFP_KERNEL);\n\tif (!asciihex)\n\t\treturn;\n\n\tp = bin2hex(p, src, count);\n\t*p = 0;\n\tpr_debug(\"%s: (%zu) %.*s\\n\", prefix, count, (int)count * 2, asciihex);\n\tkfree(asciihex);\n#endif\n}\n\nstatic void dump_security_xattr(const char *name, const char *value,\n\t\t\t\tsize_t value_len)\n{\n\tif (value_len < 64)\n\t\tpr_debug(\"%s: (%zu) [%*phN]\\n\", name, value_len,\n\t\t\t (int)value_len, value);\n\telse\n\t\tdump_security_xattr_l(name, value, value_len);\n}\n\n \nstatic int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\t const char *req_xattr_name,\n\t\t\t\t const char *req_xattr_value,\n\t\t\t\t size_t req_xattr_value_len,\n\t\t\t\t uint8_t type, struct evm_digest *data)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct xattr_list *xattr;\n\tstruct shash_desc *desc;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size, user_space_size;\n\tbool ima_present = false;\n\n\tif (!(inode->i_opflags & IOP_XATTR) ||\n\t    inode->i_sb->s_user_ns != &init_user_ns)\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type, data->hdr.algo);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tdata->hdr.length = crypto_shash_digestsize(desc->tfm);\n\n\terror = -ENODATA;\n\tlist_for_each_entry_lockless(xattr, &evm_config_xattrnames, list) {\n\t\tbool is_ima = false;\n\n\t\tif (strcmp(xattr->name, XATTR_NAME_IMA) == 0)\n\t\t\tis_ima = true;\n\n\t\t \n\t\tif (type != EVM_XATTR_PORTABLE_DIGSIG && !xattr->enabled)\n\t\t\tcontinue;\n\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(xattr->name, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tif (is_ima)\n\t\t\t\tima_present = true;\n\n\t\t\tdump_security_xattr(req_xattr_name,\n\t\t\t\t\t    req_xattr_value,\n\t\t\t\t\t    req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(&nop_mnt_idmap, dentry, xattr->name,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\tuser_space_size = vfs_getxattr(&nop_mnt_idmap, dentry,\n\t\t\t\t\t       xattr->name, NULL, 0);\n\t\tif (user_space_size != size)\n\t\t\tpr_debug(\"file %s: xattr %s size mismatch (kernel: %d, user: %d)\\n\",\n\t\t\t\t dentry->d_name.name, xattr->name, size,\n\t\t\t\t user_space_size);\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t\tif (is_ima)\n\t\t\tima_present = true;\n\n\t\tdump_security_xattr(xattr->name, xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, type, data->digest);\n\n\t \n\tif (type == EVM_XATTR_PORTABLE_DIGSIG && !ima_present)\n\t\terror = -EPERM;\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}\n\nint evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  struct evm_digest *data)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\t    req_xattr_value_len, EVM_XATTR_HMAC, data);\n}\n\nint evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char type, struct evm_digest *data)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\t     req_xattr_value_len, type, data);\n}\n\nstatic int evm_is_immutable(struct dentry *dentry, struct inode *inode)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct integrity_iint_cache *iint;\n\tint rc = 0;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint && (iint->flags & EVM_IMMUTABLE_DIGSIG))\n\t\treturn 1;\n\n\t \n\trc = vfs_getxattr_alloc(&nop_mnt_idmap, dentry, XATTR_NAME_EVM,\n\t\t\t\t(char **)&xattr_data, 0, GFP_NOFS);\n\tif (rc <= 0) {\n\t\tif (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (xattr_data->type == EVM_XATTR_PORTABLE_DIGSIG)\n\t\trc = 1;\n\telse\n\t\trc = 0;\n\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\n\n\n \nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_digest data;\n\tint rc = 0;\n\n\t \n\trc = evm_is_immutable(dentry, inode);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (rc)\n\t\treturn -EPERM;\n\n\tdata.hdr.algo = HASH_ALGO_SHA1;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, &data);\n\tif (rc == 0) {\n\t\tdata.hdr.xattr.sha1.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(&nop_mnt_idmap, dentry,\n\t\t\t\t\t   XATTR_NAME_EVM,\n\t\t\t\t\t   &data.hdr.xattr.data[1],\n\t\t\t\t\t   SHA1_DIGEST_SIZE + 1, 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(&nop_mnt_idmap, dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}\n\nint evm_init_hmac(struct inode *inode, const struct xattr *xattrs,\n\t\t  char *hmac_val)\n{\n\tstruct shash_desc *desc;\n\tconst struct xattr *xattr;\n\n\tdesc = init_desc(EVM_XATTR_HMAC, HASH_ALGO_SHA1);\n\tif (IS_ERR(desc)) {\n\t\tpr_info(\"init_desc failed\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tfor (xattr = xattrs; xattr->name; xattr++) {\n\t\tif (!evm_protected_xattr(xattr->name))\n\t\t\tcontinue;\n\n\t\tcrypto_shash_update(desc, xattr->value, xattr->value_len);\n\t}\n\n\thmac_add_misc(desc, inode, EVM_XATTR_HMAC, hmac_val);\n\tkfree(desc);\n\treturn 0;\n}\n\n \nint evm_init_key(void)\n{\n\tstruct key *evm_key;\n\tstruct encrypted_key_payload *ekp;\n\tint rc;\n\n\tevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\n\tif (IS_ERR(evm_key))\n\t\treturn -ENOENT;\n\n\tdown_read(&evm_key->sem);\n\tekp = evm_key->payload.data[0];\n\n\trc = evm_set_key(ekp->decrypted_data, ekp->decrypted_datalen);\n\n\t \n\tmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\n\tup_read(&evm_key->sem);\n\tkey_put(evm_key);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}