{
  "module_name": "evm_secfs.c",
  "hash_id": "f6c5e0312cf7b8692912d72b954960d798a602466553f267567b0fb5a6601926",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/evm/evm_secfs.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include \"evm.h\"\n\nstatic struct dentry *evm_dir;\nstatic struct dentry *evm_init_tpm;\nstatic struct dentry *evm_symlink;\n\n#ifdef CONFIG_EVM_ADD_XATTRS\nstatic struct dentry *evm_xattrs;\nstatic DEFINE_MUTEX(xattr_list_mutex);\nstatic int evm_xattrs_locked;\n#endif\n\n \nstatic ssize_t evm_read_key(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", (evm_initialized & ~EVM_SETUP_COMPLETE));\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}\n\n \nstatic ssize_t evm_write_key(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP_COMPLETE))\n\t\treturn -EPERM;\n\n\tret = kstrtouint_from_user(buf, count, 0, &i);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!i || (i & ~EVM_INIT_MASK) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif ((i & EVM_ALLOW_METADATA_WRITES) &&\n\t    (evm_initialized & EVM_INIT_HMAC) != 0)\n\t\treturn -EPERM;\n\n\tif (i & EVM_INIT_HMAC) {\n\t\tret = evm_init_key();\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\t \n\t\ti |= EVM_SETUP_COMPLETE;\n\t}\n\n\tevm_initialized |= i;\n\n\t \n\tif (evm_initialized & EVM_INIT_HMAC)\n\t\tevm_initialized &= ~(EVM_ALLOW_METADATA_WRITES);\n\n\treturn count;\n}\n\nstatic const struct file_operations evm_key_ops = {\n\t.read\t\t= evm_read_key,\n\t.write\t\t= evm_write_key,\n};\n\n#ifdef CONFIG_EVM_ADD_XATTRS\n \nstatic ssize_t evm_read_xattrs(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar *temp;\n\tint offset = 0;\n\tssize_t rc, size = 0;\n\tstruct xattr_list *xattr;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\trc = mutex_lock_interruptible(&xattr_list_mutex);\n\tif (rc)\n\t\treturn -ERESTARTSYS;\n\n\tlist_for_each_entry(xattr, &evm_config_xattrnames, list) {\n\t\tif (!xattr->enabled)\n\t\t\tcontinue;\n\n\t\tsize += strlen(xattr->name) + 1;\n\t}\n\n\ttemp = kmalloc(size + 1, GFP_KERNEL);\n\tif (!temp) {\n\t\tmutex_unlock(&xattr_list_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(xattr, &evm_config_xattrnames, list) {\n\t\tif (!xattr->enabled)\n\t\t\tcontinue;\n\n\t\tsprintf(temp + offset, \"%s\\n\", xattr->name);\n\t\toffset += strlen(xattr->name) + 1;\n\t}\n\n\tmutex_unlock(&xattr_list_mutex);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\tkfree(temp);\n\n\treturn rc;\n}\n\n \nstatic ssize_t evm_write_xattrs(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint len, err;\n\tstruct xattr_list *xattr, *tmp;\n\tstruct audit_buffer *ab;\n\tstruct iattr newattrs;\n\tstruct inode *inode;\n\n\tif (!capable(CAP_SYS_ADMIN) || evm_xattrs_locked)\n\t\treturn -EPERM;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (count > XATTR_NAME_MAX)\n\t\treturn -E2BIG;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_EVM_XATTR);\n\tif (!ab && IS_ENABLED(CONFIG_AUDIT))\n\t\treturn -ENOMEM;\n\n\txattr = kmalloc(sizeof(struct xattr_list), GFP_KERNEL);\n\tif (!xattr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\txattr->enabled = true;\n\txattr->name = memdup_user_nul(buf, count);\n\tif (IS_ERR(xattr->name)) {\n\t\terr = PTR_ERR(xattr->name);\n\t\txattr->name = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tlen = strlen(xattr->name);\n\tif (len && xattr->name[len-1] == '\\n')\n\t\txattr->name[len-1] = '\\0';\n\n\taudit_log_format(ab, \"xattr=\");\n\taudit_log_untrustedstring(ab, xattr->name);\n\n\tif (strcmp(xattr->name, \".\") == 0) {\n\t\tevm_xattrs_locked = 1;\n\t\tnewattrs.ia_mode = S_IFREG | 0440;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tinode = evm_xattrs->d_inode;\n\t\tinode_lock(inode);\n\t\terr = simple_setattr(&nop_mnt_idmap, evm_xattrs, &newattrs);\n\t\tinode_unlock(inode);\n\t\tif (!err)\n\t\t\terr = count;\n\t\tgoto out;\n\t}\n\n\tif (strncmp(xattr->name, XATTR_SECURITY_PREFIX,\n\t\t    XATTR_SECURITY_PREFIX_LEN) != 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&xattr_list_mutex);\n\tlist_for_each_entry(tmp, &evm_config_xattrnames, list) {\n\t\tif (strcmp(xattr->name, tmp->name) == 0) {\n\t\t\terr = -EEXIST;\n\t\t\tif (!tmp->enabled) {\n\t\t\t\ttmp->enabled = true;\n\t\t\t\terr = count;\n\t\t\t}\n\t\t\tmutex_unlock(&xattr_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_tail_rcu(&xattr->list, &evm_config_xattrnames);\n\tmutex_unlock(&xattr_list_mutex);\n\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n\treturn count;\nout:\n\taudit_log_format(ab, \" res=%d\", (err < 0) ? err : 0);\n\taudit_log_end(ab);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n}\n\nstatic const struct file_operations evm_xattr_ops = {\n\t.read\t\t= evm_read_xattrs,\n\t.write\t\t= evm_write_xattrs,\n};\n\nstatic int evm_init_xattrs(void)\n{\n\tevm_xattrs = securityfs_create_file(\"evm_xattrs\", 0660, evm_dir, NULL,\n\t\t\t\t\t    &evm_xattr_ops);\n\tif (!evm_xattrs || IS_ERR(evm_xattrs))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#else\nstatic int evm_init_xattrs(void)\n{\n\treturn 0;\n}\n#endif\n\nint __init evm_init_secfs(void)\n{\n\tint error = 0;\n\n\tevm_dir = securityfs_create_dir(\"evm\", integrity_dir);\n\tif (!evm_dir || IS_ERR(evm_dir))\n\t\treturn -EFAULT;\n\n\tevm_init_tpm = securityfs_create_file(\"evm\", 0660,\n\t\t\t\t\t      evm_dir, NULL, &evm_key_ops);\n\tif (!evm_init_tpm || IS_ERR(evm_init_tpm)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tevm_symlink = securityfs_create_symlink(\"evm\", NULL,\n\t\t\t\t\t\t\"integrity/evm/evm\", NULL);\n\tif (!evm_symlink || IS_ERR(evm_symlink)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (evm_init_xattrs() != 0) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tsecurityfs_remove(evm_symlink);\n\tsecurityfs_remove(evm_init_tpm);\n\tsecurityfs_remove(evm_dir);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}