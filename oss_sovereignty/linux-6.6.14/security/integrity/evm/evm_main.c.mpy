{
  "module_name": "evm_main.c",
  "hash_id": "8fa5a3dd18a3a3a280625cc0bcb084e8e18f102f4f66666899633074da800a74",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/evm/evm_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"EVM: \"fmt\n\n#include <linux/init.h>\n#include <linux/crypto.h>\n#include <linux/audit.h>\n#include <linux/xattr.h>\n#include <linux/integrity.h>\n#include <linux/evm.h>\n#include <linux/magic.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/lsm_hooks.h>\n\n#include <crypto/hash.h>\n#include <crypto/hash_info.h>\n#include <crypto/algapi.h>\n#include \"evm.h\"\n\nint evm_initialized;\n\nstatic const char * const integrity_status_msg[] = {\n\t\"pass\", \"pass_immutable\", \"fail\", \"fail_immutable\", \"no_label\",\n\t\"no_xattrs\", \"unknown\"\n};\nint evm_hmac_attrs;\n\nstatic struct xattr_list evm_config_default_xattrnames[] = {\n\t{\n\t .name = XATTR_NAME_SELINUX,\n\t .enabled = IS_ENABLED(CONFIG_SECURITY_SELINUX)\n\t},\n\t{\n\t .name = XATTR_NAME_SMACK,\n\t .enabled = IS_ENABLED(CONFIG_SECURITY_SMACK)\n\t},\n\t{\n\t .name = XATTR_NAME_SMACKEXEC,\n\t .enabled = IS_ENABLED(CONFIG_EVM_EXTRA_SMACK_XATTRS)\n\t},\n\t{\n\t .name = XATTR_NAME_SMACKTRANSMUTE,\n\t .enabled = IS_ENABLED(CONFIG_EVM_EXTRA_SMACK_XATTRS)\n\t},\n\t{\n\t .name = XATTR_NAME_SMACKMMAP,\n\t .enabled = IS_ENABLED(CONFIG_EVM_EXTRA_SMACK_XATTRS)\n\t},\n\t{\n\t .name = XATTR_NAME_APPARMOR,\n\t .enabled = IS_ENABLED(CONFIG_SECURITY_APPARMOR)\n\t},\n\t{\n\t .name = XATTR_NAME_IMA,\n\t .enabled = IS_ENABLED(CONFIG_IMA_APPRAISE)\n\t},\n\t{\n\t .name = XATTR_NAME_CAPS,\n\t .enabled = true\n\t},\n};\n\nLIST_HEAD(evm_config_xattrnames);\n\nstatic int evm_fixmode __ro_after_init;\nstatic int __init evm_set_fixmode(char *str)\n{\n\tif (strncmp(str, \"fix\", 3) == 0)\n\t\tevm_fixmode = 1;\n\telse\n\t\tpr_err(\"invalid \\\"%s\\\" mode\", str);\n\n\treturn 1;\n}\n__setup(\"evm=\", evm_set_fixmode);\n\nstatic void __init evm_init_config(void)\n{\n\tint i, xattrs;\n\n\txattrs = ARRAY_SIZE(evm_config_default_xattrnames);\n\n\tpr_info(\"Initialising EVM extended attributes:\\n\");\n\tfor (i = 0; i < xattrs; i++) {\n\t\tpr_info(\"%s%s\\n\", evm_config_default_xattrnames[i].name,\n\t\t\t!evm_config_default_xattrnames[i].enabled ?\n\t\t\t\" (disabled)\" : \"\");\n\t\tlist_add_tail(&evm_config_default_xattrnames[i].list,\n\t\t\t      &evm_config_xattrnames);\n\t}\n\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}\n\nstatic bool evm_key_loaded(void)\n{\n\treturn (bool)(evm_initialized & EVM_KEY_MASK);\n}\n\n \nstatic bool evm_hmac_disabled(void)\n{\n\tif (evm_initialized & EVM_INIT_HMAC)\n\t\treturn false;\n\n\tif (!(evm_initialized & EVM_SETUP_COMPLETE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct xattr_list *xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tlist_for_each_entry_lockless(xattr, &evm_config_xattrnames, list) {\n\t\terror = __vfs_getxattr(dentry, inode, xattr->name, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct signature_v2_hdr *hdr;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tstruct evm_digest digest;\n\tstruct inode *inode;\n\tint rc, xattr_len, evm_immutable = 0;\n\n\tif (iint && (iint->evm_status == INTEGRITY_PASS ||\n\t\t     iint->evm_status == INTEGRITY_PASS_IMMUTABLE))\n\t\treturn iint->evm_status;\n\n\t \n\n\t \n\trc = vfs_getxattr_alloc(&nop_mnt_idmap, dentry, XATTR_NAME_EVM,\n\t\t\t\t(char **)&xattr_data, 0, GFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS;  \n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t \n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_xattr)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdigest.hdr.algo = HASH_ALGO_SHA1;\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, &digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->data, digest.digest,\n\t\t\t\t   SHA1_DIGEST_SIZE);\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_XATTR_PORTABLE_DIGSIG:\n\t\tevm_immutable = 1;\n\t\tfallthrough;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\t \n\t\tif (xattr_len <= sizeof(struct signature_v2_hdr)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\thdr = (struct signature_v2_hdr *)xattr_data;\n\t\tdigest.hdr.algo = hdr->hash_algo;\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, xattr_data->type, &digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tdigest.digest, digest.hdr.length);\n\t\tif (!rc) {\n\t\t\tinode = d_backing_inode(dentry);\n\n\t\t\tif (xattr_data->type == EVM_XATTR_PORTABLE_DIGSIG) {\n\t\t\t\tif (iint)\n\t\t\t\t\tiint->flags |= EVM_IMMUTABLE_DIGSIG;\n\t\t\t\tevm_status = INTEGRITY_PASS_IMMUTABLE;\n\t\t\t} else if (!IS_RDONLY(inode) &&\n\t\t\t\t   !(inode->i_sb->s_readonly_remount) &&\n\t\t\t\t   !IS_IMMUTABLE(inode)) {\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\tif (rc == -ENODATA)\n\t\t\tevm_status = INTEGRITY_NOXATTRS;\n\t\telse if (evm_immutable)\n\t\t\tevm_status = INTEGRITY_FAIL_IMMUTABLE;\n\t\telse\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t}\n\tpr_debug(\"digest: (%d) [%*phN]\\n\", digest.hdr.length, digest.hdr.length,\n\t\t  digest.digest);\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n\nstatic int evm_protected_xattr_common(const char *req_xattr_name,\n\t\t\t\t      bool all_xattrs)\n{\n\tint namelen;\n\tint found = 0;\n\tstruct xattr_list *xattr;\n\n\tnamelen = strlen(req_xattr_name);\n\tlist_for_each_entry_lockless(xattr, &evm_config_xattrnames, list) {\n\t\tif (!all_xattrs && !xattr->enabled)\n\t\t\tcontinue;\n\n\t\tif ((strlen(xattr->name) == namelen)\n\t\t    && (strncmp(req_xattr_name, xattr->name, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    xattr->name + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nint evm_protected_xattr(const char *req_xattr_name)\n{\n\treturn evm_protected_xattr_common(req_xattr_name, false);\n}\n\nint evm_protected_xattr_if_enabled(const char *req_xattr_name)\n{\n\treturn evm_protected_xattr_common(req_xattr_name, true);\n}\n\n \nint evm_read_protected_xattrs(struct dentry *dentry, u8 *buffer,\n\t\t\t      int buffer_size, char type, bool canonical_fmt)\n{\n\tstruct xattr_list *xattr;\n\tint rc, size, total_size = 0;\n\n\tlist_for_each_entry_lockless(xattr, &evm_config_xattrnames, list) {\n\t\trc = __vfs_getxattr(dentry, d_backing_inode(dentry),\n\t\t\t\t    xattr->name, NULL, 0);\n\t\tif (rc < 0 && rc == -ENODATA)\n\t\t\tcontinue;\n\t\telse if (rc < 0)\n\t\t\treturn rc;\n\n\t\tswitch (type) {\n\t\tcase 'n':\n\t\t\tsize = strlen(xattr->name) + 1;\n\t\t\tif (buffer) {\n\t\t\t\tif (total_size)\n\t\t\t\t\t*(buffer + total_size - 1) = '|';\n\n\t\t\t\tmemcpy(buffer + total_size, xattr->name, size);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tsize = sizeof(u32);\n\t\t\tif (buffer) {\n\t\t\t\tif (canonical_fmt)\n\t\t\t\t\trc = (__force int)cpu_to_le32(rc);\n\n\t\t\t\t*(u32 *)(buffer + total_size) = rc;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tsize = rc;\n\t\t\tif (buffer) {\n\t\t\t\trc = __vfs_getxattr(dentry,\n\t\t\t\t\td_backing_inode(dentry), xattr->name,\n\t\t\t\t\tbuffer + total_size,\n\t\t\t\t\tbuffer_size - total_size);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttotal_size += size;\n\t}\n\n\treturn total_size;\n}\n\n \nenum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_key_loaded() || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}\nEXPORT_SYMBOL_GPL(evm_verifyxattr);\n\n \nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_key_loaded() || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn INTEGRITY_PASS;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}\n\n \nstatic int evm_xattr_change(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, const char *xattr_name,\n\t\t\t    const void *xattr_value, size_t xattr_value_len)\n{\n\tchar *xattr_data = NULL;\n\tint rc = 0;\n\n\trc = vfs_getxattr_alloc(&nop_mnt_idmap, dentry, xattr_name, &xattr_data,\n\t\t\t\t0, GFP_NOFS);\n\tif (rc < 0) {\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\tif (rc == xattr_value_len)\n\t\trc = !!memcmp(xattr_value, xattr_data, rc);\n\telse\n\t\trc = 1;\n\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\n\n \nstatic int evm_protect_xattr(struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\t \n\t\tif (evm_hmac_disabled())\n\t\t\treturn 0;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\t \n\tif (evm_hmac_disabled() && (evm_status == INTEGRITY_NOLABEL ||\n\t    evm_status == INTEGRITY_UNKNOWN))\n\t\treturn 0;\n\n\t \n\tif (evm_status == INTEGRITY_FAIL_IMMUTABLE)\n\t\treturn 0;\n\n\tif (evm_status == INTEGRITY_PASS_IMMUTABLE &&\n\t    !evm_xattr_change(idmap, dentry, xattr_name, xattr_value,\n\t\t\t      xattr_value_len))\n\t\treturn 0;\n\n\tif (evm_status != INTEGRITY_PASS &&\n\t    evm_status != INTEGRITY_PASS_IMMUTABLE)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}\n\n \nint evm_inode_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t       const char *xattr_name, const void *xattr_value,\n\t\t       size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = xattr_value;\n\n\t \n\tif (evm_initialized & EVM_ALLOW_METADATA_WRITES)\n\t\treturn 0;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!xattr_value_len)\n\t\t\treturn -EINVAL;\n\t\tif (xattr_data->type != EVM_IMA_XATTR_DIGSIG &&\n\t\t    xattr_data->type != EVM_XATTR_PORTABLE_DIGSIG)\n\t\t\treturn -EPERM;\n\t}\n\treturn evm_protect_xattr(idmap, dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len);\n}\n\n \nint evm_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, const char *xattr_name)\n{\n\t \n\tif (evm_initialized & EVM_ALLOW_METADATA_WRITES)\n\t\treturn 0;\n\n\treturn evm_protect_xattr(idmap, dentry, xattr_name, NULL, 0);\n}\n\n#ifdef CONFIG_FS_POSIX_ACL\nstatic int evm_inode_set_acl_change(struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *dentry, const char *name,\n\t\t\t\t    struct posix_acl *kacl)\n{\n\tint rc;\n\n\tumode_t mode;\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!kacl)\n\t\treturn 1;\n\n\trc = posix_acl_update_mode(idmap, inode, &mode, &kacl);\n\tif (rc || (inode->i_mode != mode))\n\t\treturn 1;\n\n\treturn 0;\n}\n#else\nstatic inline int evm_inode_set_acl_change(struct mnt_idmap *idmap,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   struct posix_acl *kacl)\n{\n\treturn 0;\n}\n#endif\n\n \nint evm_inode_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      const char *acl_name, struct posix_acl *kacl)\n{\n\tenum integrity_status evm_status;\n\n\t \n\tif (evm_initialized & EVM_ALLOW_METADATA_WRITES)\n\t\treturn 0;\n\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\treturn 0;\n\n\t \n\tif (evm_hmac_disabled() && (evm_status == INTEGRITY_NOLABEL ||\n\t    evm_status == INTEGRITY_UNKNOWN))\n\t\treturn 0;\n\n\t \n\tif (evm_status == INTEGRITY_FAIL_IMMUTABLE)\n\t\treturn 0;\n\n\tif (evm_status == INTEGRITY_PASS_IMMUTABLE &&\n\t    !evm_inode_set_acl_change(idmap, dentry, acl_name, kacl))\n\t\treturn 0;\n\n\tif (evm_status != INTEGRITY_PASS_IMMUTABLE)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn -EPERM;\n}\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}\n\n \nbool evm_revalidate_status(const char *xattr_name)\n{\n\tif (!evm_key_loaded())\n\t\treturn false;\n\n\t \n\tif (!xattr_name)\n\t\treturn true;\n\n\tif (!evm_protected_xattr(xattr_name) && !posix_xattr_acl(xattr_name) &&\n\t    strcmp(xattr_name, XATTR_NAME_EVM))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (!evm_revalidate_status(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tif (!strcmp(xattr_name, XATTR_NAME_EVM))\n\t\treturn;\n\n\tif (!(evm_initialized & EVM_INIT_HMAC))\n\t\treturn;\n\n\tevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\n}\n\n \nvoid evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_revalidate_status(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tif (!strcmp(xattr_name, XATTR_NAME_EVM))\n\t\treturn;\n\n\tif (!(evm_initialized & EVM_INIT_HMAC))\n\t\treturn;\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}\n\nstatic int evm_attr_change(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (!i_uid_needs_update(idmap, attr, inode) &&\n\t    !i_gid_needs_update(idmap, attr, inode) &&\n\t    (!(ia_valid & ATTR_MODE) || attr->ia_mode == inode->i_mode))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nint evm_inode_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tenum integrity_status evm_status;\n\n\t \n\tif (evm_initialized & EVM_ALLOW_METADATA_WRITES)\n\t\treturn 0;\n\n\tif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\n\t\treturn 0;\n\tevm_status = evm_verify_current_integrity(dentry);\n\t \n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS) ||\n\t    (evm_status == INTEGRITY_FAIL_IMMUTABLE) ||\n\t    (evm_hmac_disabled() && (evm_status == INTEGRITY_NOLABEL ||\n\t     evm_status == INTEGRITY_UNKNOWN)))\n\t\treturn 0;\n\n\tif (evm_status == INTEGRITY_PASS_IMMUTABLE &&\n\t    !evm_attr_change(idmap, dentry, attr))\n\t\treturn 0;\n\n\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t    integrity_status_msg[evm_status], -EPERM, 0);\n\treturn -EPERM;\n}\n\n \nvoid evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\n{\n\tif (!evm_revalidate_status(NULL))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tif (!(evm_initialized & EVM_INIT_HMAC))\n\t\treturn;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\tevm_update_evmxattr(dentry, NULL, NULL, 0);\n}\n\n \nint evm_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t    const struct qstr *qstr, struct xattr *xattrs,\n\t\t\t    int *xattr_count)\n{\n\tstruct evm_xattr *xattr_data;\n\tstruct xattr *xattr, *evm_xattr;\n\tbool evm_protected_xattrs = false;\n\tint rc;\n\n\tif (!(evm_initialized & EVM_INIT_HMAC) || !xattrs)\n\t\treturn 0;\n\n\t \n\tfor (xattr = xattrs; xattr->name; xattr++) {\n\t\tif (evm_protected_xattr(xattr->name))\n\t\t\tevm_protected_xattrs = true;\n\t}\n\n\t \n\tif (!evm_protected_xattrs)\n\t\treturn 0;\n\n\tevm_xattr = lsm_get_xattr_slot(xattrs, xattr_count);\n\t \n\tWARN_ONCE(evm_xattr != xattr,\n\t\t  \"%s: xattrs terminator is not the first non-filled slot\\n\",\n\t\t  __func__);\n\n\txattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\n\tif (!xattr_data)\n\t\treturn -ENOMEM;\n\n\txattr_data->data.type = EVM_XATTR_HMAC;\n\trc = evm_init_hmac(inode, xattrs, xattr_data->digest);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tevm_xattr->value = xattr_data;\n\tevm_xattr->value_len = sizeof(*xattr_data);\n\tevm_xattr->name = XATTR_EVM_SUFFIX;\n\treturn 0;\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(evm_inode_init_security);\n\n#ifdef CONFIG_EVM_LOAD_X509\nvoid __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}\n#endif\n\nstatic int __init init_evm(void)\n{\n\tint error;\n\tstruct list_head *pos, *q;\n\n\tevm_init_config();\n\n\terror = integrity_init_keyring(INTEGRITY_KEYRING_EVM);\n\tif (error)\n\t\tgoto error;\n\n\terror = evm_init_secfs();\n\tif (error < 0) {\n\t\tpr_info(\"Error registering secfs\\n\");\n\t\tgoto error;\n\t}\n\nerror:\n\tif (error != 0) {\n\t\tif (!list_empty(&evm_config_xattrnames)) {\n\t\t\tlist_for_each_safe(pos, q, &evm_config_xattrnames)\n\t\t\t\tlist_del(pos);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nlate_initcall(init_evm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}