{
  "module_name": "iint.c",
  "hash_id": "c1ca8b238884f48ad49bbfe59aad852565d6ee998263dfd6c17122dfdae91afc",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/iint.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/lsm_hooks.h>\n#include \"integrity.h\"\n\nstatic struct rb_root integrity_iint_tree = RB_ROOT;\nstatic DEFINE_RWLOCK(integrity_iint_lock);\nstatic struct kmem_cache *iint_cache __read_mostly;\n\nstruct dentry *integrity_dir;\n\n \nstatic struct integrity_iint_cache *__integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\tstruct rb_node *n = integrity_iint_tree.rb_node;\n\n\twhile (n) {\n\t\tiint = rb_entry(n, struct integrity_iint_cache, rb_node);\n\n\t\tif (inode < iint->inode)\n\t\t\tn = n->rb_left;\n\t\telse if (inode > iint->inode)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn iint;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}\n\n#define IMA_MAX_NESTING (FILESYSTEM_MAX_STACK_DEPTH+1)\n\n \nstatic inline void iint_lockdep_annotate(struct integrity_iint_cache *iint,\n\t\t\t\t\t struct inode *inode)\n{\n#ifdef CONFIG_LOCKDEP\n\tstatic struct lock_class_key iint_mutex_key[IMA_MAX_NESTING];\n\n\tint depth = inode->i_sb->s_stack_depth;\n\n\tif (WARN_ON_ONCE(depth < 0 || depth >= IMA_MAX_NESTING))\n\t\tdepth = 0;\n\n\tlockdep_set_class(&iint->mutex, &iint_mutex_key[depth]);\n#endif\n}\n\nstatic void iint_init_always(struct integrity_iint_cache *iint,\n\t\t\t     struct inode *inode)\n{\n\tiint->ima_hash = NULL;\n\tiint->version = 0;\n\tiint->flags = 0UL;\n\tiint->atomic_flags = 0UL;\n\tiint->ima_file_status = INTEGRITY_UNKNOWN;\n\tiint->ima_mmap_status = INTEGRITY_UNKNOWN;\n\tiint->ima_bprm_status = INTEGRITY_UNKNOWN;\n\tiint->ima_read_status = INTEGRITY_UNKNOWN;\n\tiint->ima_creds_status = INTEGRITY_UNKNOWN;\n\tiint->evm_status = INTEGRITY_UNKNOWN;\n\tiint->measured_pcrs = 0;\n\tmutex_init(&iint->mutex);\n\tiint_lockdep_annotate(iint, inode);\n}\n\nstatic void iint_free(struct integrity_iint_cache *iint)\n{\n\tkfree(iint->ima_hash);\n\tmutex_destroy(&iint->mutex);\n\tkmem_cache_free(iint_cache, iint);\n}\n\n \nstruct integrity_iint_cache *integrity_inode_get(struct inode *inode)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node, *parent = NULL;\n\tstruct integrity_iint_cache *iint, *test_iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\treturn iint;\n\n\tiint = kmem_cache_alloc(iint_cache, GFP_NOFS);\n\tif (!iint)\n\t\treturn NULL;\n\n\tiint_init_always(iint, inode);\n\n\twrite_lock(&integrity_iint_lock);\n\n\tp = &integrity_iint_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttest_iint = rb_entry(parent, struct integrity_iint_cache,\n\t\t\t\t     rb_node);\n\t\tif (inode < test_iint->inode) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (inode > test_iint->inode) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\twrite_unlock(&integrity_iint_lock);\n\t\t\tkmem_cache_free(iint_cache, iint);\n\t\t\treturn test_iint;\n\t\t}\n\t}\n\n\tiint->inode = inode;\n\tnode = &iint->rb_node;\n\tinode->i_flags |= S_IMA;\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &integrity_iint_tree);\n\n\twrite_unlock(&integrity_iint_lock);\n\treturn iint;\n}\n\n \nvoid integrity_inode_free(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn;\n\n\twrite_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\trb_erase(&iint->rb_node, &integrity_iint_tree);\n\twrite_unlock(&integrity_iint_lock);\n\n\tiint_free(iint);\n}\n\nstatic void iint_init_once(void *foo)\n{\n\tstruct integrity_iint_cache *iint = (struct integrity_iint_cache *) foo;\n\n\tmemset(iint, 0, sizeof(*iint));\n}\n\nstatic int __init integrity_iintcache_init(void)\n{\n\tiint_cache =\n\t    kmem_cache_create(\"iint_cache\", sizeof(struct integrity_iint_cache),\n\t\t\t      0, SLAB_PANIC, iint_init_once);\n\treturn 0;\n}\nDEFINE_LSM(integrity) = {\n\t.name = \"integrity\",\n\t.init = integrity_iintcache_init,\n\t.order = LSM_ORDER_LAST,\n};\n\n\n \nint integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\treturn __kernel_read(file, addr, count, &offset);\n}\n\n \nvoid __init integrity_load_keys(void)\n{\n\tima_load_x509();\n\n\tif (!IS_ENABLED(CONFIG_IMA_LOAD_X509))\n\t\tevm_load_x509();\n}\n\nstatic int __init integrity_fs_init(void)\n{\n\tintegrity_dir = securityfs_create_dir(\"integrity\", NULL);\n\tif (IS_ERR(integrity_dir)) {\n\t\tint ret = PTR_ERR(integrity_dir);\n\n\t\tif (ret != -ENODEV)\n\t\t\tpr_err(\"Unable to create integrity sysfs dir: %d\\n\",\n\t\t\t       ret);\n\t\tintegrity_dir = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nlate_initcall(integrity_fs_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}