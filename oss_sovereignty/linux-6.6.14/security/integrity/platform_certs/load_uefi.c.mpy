{
  "module_name": "load_uefi.c",
  "hash_id": "14ba949f82f7e10e4016835ab76e9c022d5bbbdd637619a3279a66c8d860153f",
  "original_prompt": "Ingested from linux-6.6.14/security/integrity/platform_certs/load_uefi.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/efi.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n#include \"../integrity.h\"\n#include \"keyring_handler.h\"\n\n \nstatic const struct dmi_system_id uefi_skip_cert[] = {\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro15,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro15,2\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro15,3\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro15,4\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro16,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro16,2\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro16,3\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookPro16,4\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookAir8,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookAir8,2\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacBookAir9,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"Macmini8,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"MacPro7,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"iMac20,1\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"iMac20,2\") },\n\t{ UEFI_QUIRK_SKIP_CERT(\"Apple Inc.\", \"iMacPro1,1\") },\n\t{ }\n};\n\n \nstatic __init bool uefi_check_ignore_db(void)\n{\n\tefi_status_t status;\n\tunsigned int db = 0;\n\tunsigned long size = sizeof(db);\n\tefi_guid_t guid = EFI_SHIM_LOCK_GUID;\n\n\tstatus = efi.get_variable(L\"MokIgnoreDB\", &guid, NULL, &size, &db);\n\treturn status == EFI_SUCCESS;\n}\n\n \nstatic __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,\n\t\t\t\t  unsigned long *size, efi_status_t *status)\n{\n\tunsigned long lsize = 4;\n\tunsigned long tmpdb[4];\n\tvoid *db;\n\n\t*status = efi.get_variable(name, guid, NULL, &lsize, &tmpdb);\n\tif (*status == EFI_NOT_FOUND)\n\t\treturn NULL;\n\n\tif (*status != EFI_BUFFER_TOO_SMALL) {\n\t\tpr_err(\"Couldn't get size: 0x%lx\\n\", *status);\n\t\treturn NULL;\n\t}\n\n\tdb = kmalloc(lsize, GFP_KERNEL);\n\tif (!db)\n\t\treturn NULL;\n\n\t*status = efi.get_variable(name, guid, NULL, &lsize, db);\n\tif (*status != EFI_SUCCESS) {\n\t\tkfree(db);\n\t\tpr_err(\"Error reading db var: 0x%lx\\n\", *status);\n\t\treturn NULL;\n\t}\n\n\t*size = lsize;\n\treturn db;\n}\n\n \nstatic int __init load_moklist_certs(void)\n{\n\tstruct efi_mokvar_table_entry *mokvar_entry;\n\tefi_guid_t mok_var = EFI_SHIM_LOCK_GUID;\n\tvoid *mok;\n\tunsigned long moksize;\n\tefi_status_t status;\n\tint rc;\n\n\t \n\tmokvar_entry = efi_mokvar_entry_find(\"MokListRT\");\n\tif (mokvar_entry) {\n\t\trc = parse_efi_signature_list(\"UEFI:MokListRT (MOKvar table)\",\n\t\t\t\t\t      mokvar_entry->data,\n\t\t\t\t\t      mokvar_entry->data_size,\n\t\t\t\t\t      get_handler_for_mok);\n\t\t \n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tpr_err(\"Couldn't parse MokListRT signatures from EFI MOKvar config table: %d\\n\",\n\t\t       rc);\n\t}\n\n\t \n\tmok = get_cert_list(L\"MokListRT\", &mok_var, &moksize, &status);\n\tif (mok) {\n\t\trc = parse_efi_signature_list(\"UEFI:MokListRT\",\n\t\t\t\t\t      mok, moksize, get_handler_for_mok);\n\t\tkfree(mok);\n\t\tif (rc)\n\t\t\tpr_err(\"Couldn't parse MokListRT signatures: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (status == EFI_NOT_FOUND)\n\t\tpr_debug(\"MokListRT variable wasn't found\\n\");\n\telse\n\t\tpr_info(\"Couldn't get UEFI MokListRT\\n\");\n\treturn 0;\n}\n\n \nstatic int __init load_uefi_certs(void)\n{\n\tefi_guid_t secure_var = EFI_IMAGE_SECURITY_DATABASE_GUID;\n\tefi_guid_t mok_var = EFI_SHIM_LOCK_GUID;\n\tvoid *db = NULL, *dbx = NULL, *mokx = NULL;\n\tunsigned long dbsize = 0, dbxsize = 0, mokxsize = 0;\n\tefi_status_t status;\n\tint rc = 0;\n\tconst struct dmi_system_id *dmi_id;\n\n\tdmi_id = dmi_first_match(uefi_skip_cert);\n\tif (dmi_id) {\n\t\tpr_err(\"Reading UEFI Secure Boot Certs is not supported on T2 Macs.\\n\");\n\t\treturn false;\n\t}\n\n\tif (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\treturn false;\n\n\t \n\tif (!uefi_check_ignore_db()) {\n\t\tdb = get_cert_list(L\"db\", &secure_var, &dbsize, &status);\n\t\tif (!db) {\n\t\t\tif (status == EFI_NOT_FOUND)\n\t\t\t\tpr_debug(\"MODSIGN: db variable wasn't found\\n\");\n\t\t\telse\n\t\t\t\tpr_err(\"MODSIGN: Couldn't get UEFI db list\\n\");\n\t\t} else {\n\t\t\trc = parse_efi_signature_list(\"UEFI:db\",\n\t\t\t\t\tdb, dbsize, get_handler_for_db);\n\t\t\tif (rc)\n\t\t\t\tpr_err(\"Couldn't parse db signatures: %d\\n\",\n\t\t\t\t       rc);\n\t\t\tkfree(db);\n\t\t}\n\t}\n\n\tdbx = get_cert_list(L\"dbx\", &secure_var, &dbxsize, &status);\n\tif (!dbx) {\n\t\tif (status == EFI_NOT_FOUND)\n\t\t\tpr_debug(\"dbx variable wasn't found\\n\");\n\t\telse\n\t\t\tpr_info(\"Couldn't get UEFI dbx list\\n\");\n\t} else {\n\t\trc = parse_efi_signature_list(\"UEFI:dbx\",\n\t\t\t\t\t      dbx, dbxsize,\n\t\t\t\t\t      get_handler_for_dbx);\n\t\tif (rc)\n\t\t\tpr_err(\"Couldn't parse dbx signatures: %d\\n\", rc);\n\t\tkfree(dbx);\n\t}\n\n\t \n\tif (!arch_ima_get_secureboot())\n\t\treturn 0;\n\n\tmokx = get_cert_list(L\"MokListXRT\", &mok_var, &mokxsize, &status);\n\tif (!mokx) {\n\t\tif (status == EFI_NOT_FOUND)\n\t\t\tpr_debug(\"mokx variable wasn't found\\n\");\n\t\telse\n\t\t\tpr_info(\"Couldn't get mokx list\\n\");\n\t} else {\n\t\trc = parse_efi_signature_list(\"UEFI:MokListXRT\",\n\t\t\t\t\t      mokx, mokxsize,\n\t\t\t\t\t      get_handler_for_dbx);\n\t\tif (rc)\n\t\t\tpr_err(\"Couldn't parse mokx signatures %d\\n\", rc);\n\t\tkfree(mokx);\n\t}\n\n\t \n\trc = load_moklist_certs();\n\n\treturn rc;\n}\nlate_initcall(load_uefi_certs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}