{
  "module_name": "commoncap.c",
  "hash_id": "e7701c07be0ad1bc1989bad2c394145ce7b3cc5c90425c7a2d0f91f89d2c10f6",
  "original_prompt": "Ingested from linux-6.6.14/security/commoncap.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/lsm_hooks.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/ptrace.h>\n#include <linux/xattr.h>\n#include <linux/hugetlb.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/securebits.h>\n#include <linux/user_namespace.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/mnt_idmapping.h>\n\n \nstatic void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}\n\n \nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, unsigned int opts)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t \n\tfor (;;) {\n\t\t \n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t \n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t \n\t\tns = ns->parent;\n\t}\n\n\t \n}\n\n \nint cap_settime(const struct timespec64 *ts, const struct timezone *tz)\n{\n\tif (!capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nint cap_ptrace_access_check(struct task_struct *child, unsigned int mode)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\tconst kernel_cap_t *caller_caps;\n\n\trcu_read_lock();\n\tcred = current_cred();\n\tchild_cred = __task_cred(child);\n\tif (mode & PTRACE_MODE_FSCREDS)\n\t\tcaller_caps = &cred->cap_effective;\n\telse\n\t\tcaller_caps = &cred->cap_permitted;\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, *caller_caps))\n\t\tgoto out;\n\tif (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint cap_ptrace_traceme(struct task_struct *parent)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(parent);\n\tchild_cred = current_cred();\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))\n\t\tgoto out;\n\tif (has_ns_capability(parent, child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint cap_capget(const struct task_struct *target, kernel_cap_t *effective,\n\t       kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tconst struct cred *cred;\n\n\t \n\trcu_read_lock();\n\tcred = __task_cred(target);\n\t*effective   = cred->cap_effective;\n\t*inheritable = cred->cap_inheritable;\n\t*permitted   = cred->cap_permitted;\n\trcu_read_unlock();\n\treturn 0;\n}\n\n \nstatic inline int cap_inh_is_capped(void)\n{\n\t \n\tif (cap_capable(current_cred(), current_cred()->user_ns,\n\t\t\tCAP_SETPCAP, CAP_OPT_NONE) == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint cap_capset(struct cred *new,\n\t       const struct cred *old,\n\t       const kernel_cap_t *effective,\n\t       const kernel_cap_t *inheritable,\n\t       const kernel_cap_t *permitted)\n{\n\tif (cap_inh_is_capped() &&\n\t    !cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_permitted)))\n\t\t \n\t\treturn -EPERM;\n\n\tif (!cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_bset)))\n\t\t \n\t\treturn -EPERM;\n\n\t \n\tif (!cap_issubset(*permitted, old->cap_permitted))\n\t\treturn -EPERM;\n\n\t \n\tif (!cap_issubset(*effective, *permitted))\n\t\treturn -EPERM;\n\n\tnew->cap_effective   = *effective;\n\tnew->cap_inheritable = *inheritable;\n\tnew->cap_permitted   = *permitted;\n\n\t \n\tnew->cap_ambient = cap_intersect(new->cap_ambient,\n\t\t\t\t\t cap_intersect(*permitted,\n\t\t\t\t\t\t       *inheritable));\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nint cap_inode_need_killpriv(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tint error;\n\n\terror = __vfs_getxattr(dentry, inode, XATTR_NAME_CAPS, NULL, 0);\n\treturn error > 0;\n}\n\n \nint cap_inode_killpriv(struct mnt_idmap *idmap, struct dentry *dentry)\n{\n\tint error;\n\n\terror = __vfs_removexattr(idmap, dentry, XATTR_NAME_CAPS);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\treturn error;\n}\n\nstatic bool rootid_owns_currentns(vfsuid_t rootvfsuid)\n{\n\tstruct user_namespace *ns;\n\tkuid_t kroot;\n\n\tif (!vfsuid_valid(rootvfsuid))\n\t\treturn false;\n\n\tkroot = vfsuid_into_kuid(rootvfsuid);\n\tfor (ns = current_user_ns();; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}\n\nstatic bool is_v2header(int size, const struct vfs_cap_data *cap)\n{\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(le32_to_cpu(cap->magic_etc)) == VFS_CAP_REVISION_2;\n}\n\nstatic bool is_v3header(int size, const struct vfs_cap_data *cap)\n{\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(le32_to_cpu(cap->magic_etc)) == VFS_CAP_REVISION_3;\n}\n\n \nint cap_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t  struct inode *inode, const char *name, void **buffer,\n\t\t\t  bool alloc)\n{\n\tint size;\n\tkuid_t kroot;\n\tvfsuid_t vfsroot;\n\tu32 nsmagic, magic;\n\tuid_t root, mappedroot;\n\tchar *tmpbuf = NULL;\n\tstruct vfs_cap_data *cap;\n\tstruct vfs_ns_cap_data *nscap = NULL;\n\tstruct dentry *dentry;\n\tstruct user_namespace *fs_ns;\n\n\tif (strcmp(name, \"capability\") != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = d_find_any_alias(inode);\n\tif (!dentry)\n\t\treturn -EINVAL;\n\tsize = vfs_getxattr_alloc(idmap, dentry, XATTR_NAME_CAPS, &tmpbuf,\n\t\t\t\t  sizeof(struct vfs_ns_cap_data), GFP_NOFS);\n\tdput(dentry);\n\t \n\tif (size < 0 || !tmpbuf)\n\t\tgoto out_free;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tcap = (struct vfs_cap_data *) tmpbuf;\n\tif (is_v2header(size, cap)) {\n\t\troot = 0;\n\t} else if (is_v3header(size, cap)) {\n\t\tnscap = (struct vfs_ns_cap_data *) tmpbuf;\n\t\troot = le32_to_cpu(nscap->rootid);\n\t} else {\n\t\tsize = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tkroot = make_kuid(fs_ns, root);\n\n\t \n\tvfsroot = make_vfsuid(idmap, fs_ns, kroot);\n\n\t \n\tmappedroot = from_kuid(current_user_ns(), vfsuid_into_kuid(vfsroot));\n\tif (mappedroot != (uid_t)-1 && mappedroot != (uid_t)0) {\n\t\tsize = sizeof(struct vfs_ns_cap_data);\n\t\tif (alloc) {\n\t\t\tif (!nscap) {\n\t\t\t\t \n\t\t\t\tnscap = kzalloc(size, GFP_ATOMIC);\n\t\t\t\tif (!nscap) {\n\t\t\t\t\tsize = -ENOMEM;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tnsmagic = VFS_CAP_REVISION_3;\n\t\t\t\tmagic = le32_to_cpu(cap->magic_etc);\n\t\t\t\tif (magic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t\t\t\tnsmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\t\t\t\tmemcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\t\t\t\tnscap->magic_etc = cpu_to_le32(nsmagic);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttmpbuf = NULL;\n\t\t\t}\n\t\t\tnscap->rootid = cpu_to_le32(mappedroot);\n\t\t\t*buffer = nscap;\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!rootid_owns_currentns(vfsroot)) {\n\t\tsize = -EOVERFLOW;\n\t\tgoto out_free;\n\t}\n\n\t \n\tsize = sizeof(struct vfs_cap_data);\n\tif (alloc) {\n\t\tif (nscap) {\n\t\t\t \n\t\t\tcap = kzalloc(size, GFP_ATOMIC);\n\t\t\tif (!cap) {\n\t\t\t\tsize = -ENOMEM;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmagic = VFS_CAP_REVISION_2;\n\t\t\tnsmagic = le32_to_cpu(nscap->magic_etc);\n\t\t\tif (nsmagic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t\t\tmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\t\t\tmemcpy(&cap->data, &nscap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\t\t\tcap->magic_etc = cpu_to_le32(magic);\n\t\t} else {\n\t\t\t \n\t\t\ttmpbuf = NULL;\n\t\t}\n\t\t*buffer = cap;\n\t}\nout_free:\n\tkfree(tmpbuf);\n\treturn size;\n}\n\n \nstatic vfsuid_t rootid_from_xattr(const void *value, size_t size,\n\t\t\t\t  struct user_namespace *task_ns)\n{\n\tconst struct vfs_ns_cap_data *nscap = value;\n\tuid_t rootid = 0;\n\n\tif (size == XATTR_CAPS_SZ_3)\n\t\trootid = le32_to_cpu(nscap->rootid);\n\n\treturn VFSUIDT_INIT(make_kuid(task_ns, rootid));\n}\n\nstatic bool validheader(size_t size, const struct vfs_cap_data *cap)\n{\n\treturn is_v2header(size, cap) || is_v3header(size, cap);\n}\n\n \nint cap_convert_nscap(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      const void **ivalue, size_t size)\n{\n\tstruct vfs_ns_cap_data *nscap;\n\tuid_t nsrootid;\n\tconst struct vfs_cap_data *cap = *ivalue;\n\t__u32 magic, nsmagic;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct user_namespace *task_ns = current_user_ns(),\n\t\t*fs_ns = inode->i_sb->s_user_ns;\n\tkuid_t rootid;\n\tvfsuid_t vfsrootid;\n\tsize_t newsize;\n\n\tif (!*ivalue)\n\t\treturn -EINVAL;\n\tif (!validheader(size, cap))\n\t\treturn -EINVAL;\n\tif (!capable_wrt_inode_uidgid(idmap, inode, CAP_SETFCAP))\n\t\treturn -EPERM;\n\tif (size == XATTR_CAPS_SZ_2 && (idmap == &nop_mnt_idmap))\n\t\tif (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP))\n\t\t\t \n\t\t\treturn size;\n\n\tvfsrootid = rootid_from_xattr(*ivalue, size, task_ns);\n\tif (!vfsuid_valid(vfsrootid))\n\t\treturn -EINVAL;\n\n\trootid = from_vfsuid(idmap, fs_ns, vfsrootid);\n\tif (!uid_valid(rootid))\n\t\treturn -EINVAL;\n\n\tnsrootid = from_kuid(fs_ns, rootid);\n\tif (nsrootid == -1)\n\t\treturn -EINVAL;\n\n\tnewsize = sizeof(struct vfs_ns_cap_data);\n\tnscap = kmalloc(newsize, GFP_ATOMIC);\n\tif (!nscap)\n\t\treturn -ENOMEM;\n\tnscap->rootid = cpu_to_le32(nsrootid);\n\tnsmagic = VFS_CAP_REVISION_3;\n\tmagic = le32_to_cpu(cap->magic_etc);\n\tif (magic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\tnsmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\tnscap->magic_etc = cpu_to_le32(nsmagic);\n\tmemcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\n\t*ivalue = nscap;\n\treturn newsize;\n}\n\n \nstatic inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\n\t\t\t\t\t  struct linux_binprm *bprm,\n\t\t\t\t\t  bool *effective,\n\t\t\t\t\t  bool *has_fcap)\n{\n\tstruct cred *new = bprm->cred;\n\tint ret = 0;\n\n\tif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t*effective = true;\n\n\tif (caps->magic_etc & VFS_CAP_REVISION_MASK)\n\t\t*has_fcap = true;\n\n\t \n\tnew->cap_permitted.val =\n\t\t(new->cap_bset.val & caps->permitted.val) |\n\t\t(new->cap_inheritable.val & caps->inheritable.val);\n\n\tif (caps->permitted.val & ~new->cap_permitted.val)\n\t\t \n\t\tret = -EPERM;\n\n\t \n\treturn *effective ? ret : 0;\n}\n\n \nint get_vfs_caps_from_disk(struct mnt_idmap *idmap,\n\t\t\t   const struct dentry *dentry,\n\t\t\t   struct cpu_vfs_cap_data *cpu_caps)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\t__u32 magic_etc;\n\tint size;\n\tstruct vfs_ns_cap_data data, *nscaps = &data;\n\tstruct vfs_cap_data *caps = (struct vfs_cap_data *) &data;\n\tkuid_t rootkuid;\n\tvfsuid_t rootvfsuid;\n\tstruct user_namespace *fs_ns;\n\n\tmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\n\n\tif (!inode)\n\t\treturn -ENODATA;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tsize = __vfs_getxattr((struct dentry *)dentry, inode,\n\t\t\t      XATTR_NAME_CAPS, &data, XATTR_CAPS_SZ);\n\tif (size == -ENODATA || size == -EOPNOTSUPP)\n\t\t \n\t\treturn -ENODATA;\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size < sizeof(magic_etc))\n\t\treturn -EINVAL;\n\n\tcpu_caps->magic_etc = magic_etc = le32_to_cpu(caps->magic_etc);\n\n\trootkuid = make_kuid(fs_ns, 0);\n\tswitch (magic_etc & VFS_CAP_REVISION_MASK) {\n\tcase VFS_CAP_REVISION_1:\n\t\tif (size != XATTR_CAPS_SZ_1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_2:\n\t\tif (size != XATTR_CAPS_SZ_2)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_3:\n\t\tif (size != XATTR_CAPS_SZ_3)\n\t\t\treturn -EINVAL;\n\t\trootkuid = make_kuid(fs_ns, le32_to_cpu(nscaps->rootid));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trootvfsuid = make_vfsuid(idmap, fs_ns, rootkuid);\n\tif (!vfsuid_valid(rootvfsuid))\n\t\treturn -ENODATA;\n\n\t \n\tif (!rootid_owns_currentns(rootvfsuid))\n\t\treturn -ENODATA;\n\n\tcpu_caps->permitted.val = le32_to_cpu(caps->data[0].permitted);\n\tcpu_caps->inheritable.val = le32_to_cpu(caps->data[0].inheritable);\n\n\t \n\tif ((magic_etc & VFS_CAP_REVISION_MASK) != VFS_CAP_REVISION_1) {\n\t\tcpu_caps->permitted.val += (u64)le32_to_cpu(caps->data[1].permitted) << 32;\n\t\tcpu_caps->inheritable.val += (u64)le32_to_cpu(caps->data[1].inheritable) << 32;\n\t}\n\n\tcpu_caps->permitted.val &= CAP_VALID_MASK;\n\tcpu_caps->inheritable.val &= CAP_VALID_MASK;\n\n\tcpu_caps->rootid = vfsuid_into_kuid(rootvfsuid);\n\n\treturn 0;\n}\n\n \nstatic int get_file_caps(struct linux_binprm *bprm, struct file *file,\n\t\t\t bool *effective, bool *has_fcap)\n{\n\tint rc = 0;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tcap_clear(bprm->cred->cap_permitted);\n\n\tif (!file_caps_enabled)\n\t\treturn 0;\n\n\tif (!mnt_may_suid(file->f_path.mnt))\n\t\treturn 0;\n\n\t \n\tif (!current_in_userns(file->f_path.mnt->mnt_sb->s_user_ns))\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(file_mnt_idmap(file),\n\t\t\t\t    file->f_path.dentry, &vcaps);\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tprintk(KERN_NOTICE \"Invalid argument reading file caps for %s\\n\",\n\t\t\t\t\tbprm->filename);\n\t\telse if (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_fcap);\n\nout:\n\tif (rc)\n\t\tcap_clear(bprm->cred->cap_permitted);\n\n\treturn rc;\n}\n\nstatic inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }\n\nstatic inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }\n\nstatic inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }\n\n \nstatic void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,\n\t\t\t\t   bool *effective, kuid_t root_uid)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\n\tif (!root_privileged())\n\t\treturn;\n\t \n\tif (has_fcap && __is_suid(root_uid, new)) {\n\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\treturn;\n\t}\n\t \n\tif (__is_eff(root_uid, new) || __is_real(root_uid, new)) {\n\t\t \n\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t old->cap_inheritable);\n\t}\n\t \n\tif (__is_eff(root_uid, new))\n\t\t*effective = true;\n}\n\n#define __cap_gained(field, target, source) \\\n\t!cap_issubset(target->cap_##field, source->cap_##field)\n#define __cap_grew(target, source, cred) \\\n\t!cap_issubset(cred->cap_##target, cred->cap_##source)\n#define __cap_full(field, cred) \\\n\tcap_issubset(CAP_FULL_SET, cred->cap_##field)\n\nstatic inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }\n\nstatic inline bool __is_setgid(struct cred *new, const struct cred *old)\n{ return !gid_eq(new->egid, old->gid); }\n\n \nstatic inline bool nonroot_raised_pE(struct cred *new, const struct cred *old,\n\t\t\t\t     kuid_t root, bool has_fcap)\n{\n\tbool ret = false;\n\n\tif ((__cap_grew(effective, ambient, new) &&\n\t     !(__cap_full(effective, new) &&\n\t       (__is_eff(root, new) || __is_real(root, new)) &&\n\t       root_privileged())) ||\n\t    (root_privileged() &&\n\t     __is_suid(root, new) &&\n\t     !__cap_full(effective, new)) ||\n\t    (!__is_setuid(new, old) &&\n\t     ((has_fcap &&\n\t       __cap_gained(permitted, new, old)) ||\n\t      __cap_gained(ambient, new, old))))\n\n\t\tret = true;\n\n\treturn ret;\n}\n\n \nint cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)\n{\n\t \n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective = false, has_fcap = false, is_setid;\n\tint ret;\n\tkuid_t root_uid;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(old)))\n\t\treturn -EPERM;\n\n\tret = get_file_caps(bprm, file, &effective, &has_fcap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\troot_uid = make_kuid(new->user_ns, 0);\n\n\thandle_privileged_root(bprm, has_fcap, &effective, root_uid);\n\n\t \n\tif (__cap_gained(permitted, new, old))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t \n\tis_setid = __is_setuid(new, old) || __is_setgid(new, old);\n\n\tif ((is_setid || __cap_gained(permitted, new, old)) &&\n\t    ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) ||\n\t     !ptracer_capable(current, new->user_ns))) {\n\t\t \n\t\tif (!ns_capable(new->user_ns, CAP_SETUID) ||\n\t\t    (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\t \n\tif (has_fcap || is_setid)\n\t\tcap_clear(new->cap_ambient);\n\n\t \n\tnew->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);\n\n\t \n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tnew->cap_effective = new->cap_ambient;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\tif (nonroot_raised_pE(new, old, root_uid, has_fcap)) {\n\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\t \n\tif (is_setid ||\n\t    (!__is_real(root_uid, new) &&\n\t     (effective ||\n\t      __cap_grew(permitted, ambient, new))))\n\t\tbprm->secureexec = 1;\n\n\treturn 0;\n}\n\n \nint cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\tstruct user_namespace *user_ns = dentry->d_sb->s_user_ns;\n\n\t \n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) != 0)\n\t\treturn 0;\n\n\t \n\tif (strcmp(name, XATTR_NAME_CAPS) == 0)\n\t\treturn 0;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nint cap_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, const char *name)\n{\n\tstruct user_namespace *user_ns = dentry->d_sb->s_user_ns;\n\n\t \n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) != 0)\n\t\treturn 0;\n\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\t \n\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\tif (!inode)\n\t\t\treturn -EINVAL;\n\t\tif (!capable_wrt_inode_uidgid(idmap, inode, CAP_SETFCAP))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nstatic inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\n{\n\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\n\tif ((uid_eq(old->uid, root_uid) ||\n\t     uid_eq(old->euid, root_uid) ||\n\t     uid_eq(old->suid, root_uid)) &&\n\t    (!uid_eq(new->uid, root_uid) &&\n\t     !uid_eq(new->euid, root_uid) &&\n\t     !uid_eq(new->suid, root_uid))) {\n\t\tif (!issecure(SECURE_KEEP_CAPS)) {\n\t\t\tcap_clear(new->cap_permitted);\n\t\t\tcap_clear(new->cap_effective);\n\t\t}\n\n\t\t \n\t\tcap_clear(new->cap_ambient);\n\t}\n\tif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\n\t\tcap_clear(new->cap_effective);\n\tif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\n\t\tnew->cap_effective = new->cap_permitted;\n}\n\n \nint cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)\n{\n\tswitch (flags) {\n\tcase LSM_SETID_RE:\n\tcase LSM_SETID_ID:\n\tcase LSM_SETID_RES:\n\t\t \n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP))\n\t\t\tcap_emulate_setxuid(new, old);\n\t\tbreak;\n\n\tcase LSM_SETID_FS:\n\t\t \n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\t\t\tif (uid_eq(old->fsuid, root_uid) && !uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_drop_fs_set(new->cap_effective);\n\n\t\t\tif (!uid_eq(old->fsuid, root_uid) && uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_raise_fs_set(new->cap_effective,\n\t\t\t\t\t\t\t new->cap_permitted);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \nint cap_task_setscheduler(struct task_struct *p)\n{\n\treturn cap_safe_nice(p);\n}\n\n \nint cap_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn cap_safe_nice(p);\n}\n\n \nint cap_task_setnice(struct task_struct *p, int nice)\n{\n\treturn cap_safe_nice(p);\n}\n\n \nstatic int cap_prctl_drop(unsigned long cap)\n{\n\tstruct cred *new;\n\n\tif (!ns_capable(current_user_ns(), CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tcap_lower(new->cap_bset, cap);\n\treturn commit_creds(new);\n}\n\n \nint cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new;\n\n\tswitch (option) {\n\tcase PR_CAPBSET_READ:\n\t\tif (!cap_valid(arg2))\n\t\t\treturn -EINVAL;\n\t\treturn !!cap_raised(old->cap_bset, arg2);\n\n\tcase PR_CAPBSET_DROP:\n\t\treturn cap_prctl_drop(arg2);\n\n\t \n\tcase PR_SET_SECUREBITS:\n\t\tif ((((old->securebits & SECURE_ALL_LOCKS) >> 1)\n\t\t     & (old->securebits ^ arg2))\t\t\t \n\t\t    || ((old->securebits & SECURE_ALL_LOCKS & ~arg2))\t \n\t\t    || (arg2 & ~(SECURE_ALL_LOCKS | SECURE_ALL_BITS))\t \n\t\t    || (cap_capable(current_cred(),\n\t\t\t\t    current_cred()->user_ns,\n\t\t\t\t    CAP_SETPCAP,\n\t\t\t\t    CAP_OPT_NONE) != 0)\t\t\t \n\t\t\t \n\t\t    )\n\t\t\t \n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->securebits = arg2;\n\t\treturn commit_creds(new);\n\n\tcase PR_GET_SECUREBITS:\n\t\treturn old->securebits;\n\n\tcase PR_GET_KEEPCAPS:\n\t\treturn !!issecure(SECURE_KEEP_CAPS);\n\n\tcase PR_SET_KEEPCAPS:\n\t\tif (arg2 > 1)  \n\t\t\treturn -EINVAL;\n\t\tif (issecure(SECURE_KEEP_CAPS_LOCKED))\n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tif (arg2)\n\t\t\tnew->securebits |= issecure_mask(SECURE_KEEP_CAPS);\n\t\telse\n\t\t\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\t\treturn commit_creds(new);\n\n\tcase PR_CAP_AMBIENT:\n\t\tif (arg2 == PR_CAP_AMBIENT_CLEAR_ALL) {\n\t\t\tif (arg3 | arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcap_clear(new->cap_ambient);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\t\tif (((!cap_valid(arg3)) | arg4 | arg5))\n\t\t\treturn -EINVAL;\n\n\t\tif (arg2 == PR_CAP_AMBIENT_IS_SET) {\n\t\t\treturn !!cap_raised(current_cred()->cap_ambient, arg3);\n\t\t} else if (arg2 != PR_CAP_AMBIENT_RAISE &&\n\t\t\t   arg2 != PR_CAP_AMBIENT_LOWER) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE &&\n\t\t\t    (!cap_raised(current_cred()->cap_permitted, arg3) ||\n\t\t\t     !cap_raised(current_cred()->cap_inheritable,\n\t\t\t\t\t arg3) ||\n\t\t\t     issecure(SECURE_NO_CAP_AMBIENT_RAISE)))\n\t\t\t\treturn -EPERM;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE)\n\t\t\t\tcap_raise(new->cap_ambient, arg3);\n\t\t\telse\n\t\t\t\tcap_lower(new->cap_ambient, arg3);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\tdefault:\n\t\t \n\t\treturn -ENOSYS;\n\t}\n}\n\n \nint cap_vm_enough_memory(struct mm_struct *mm, long pages)\n{\n\tint cap_sys_admin = 0;\n\n\tif (cap_capable(current_cred(), &init_user_ns,\n\t\t\t\tCAP_SYS_ADMIN, CAP_OPT_NOAUDIT) == 0)\n\t\tcap_sys_admin = 1;\n\n\treturn cap_sys_admin;\n}\n\n \nint cap_mmap_addr(unsigned long addr)\n{\n\tint ret = 0;\n\n\tif (addr < dac_mmap_min_addr) {\n\t\tret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO,\n\t\t\t\t  CAP_OPT_NONE);\n\t\t \n\t\tif (ret == 0)\n\t\t\tcurrent->flags |= PF_SUPERPRIV;\n\t}\n\treturn ret;\n}\n\nint cap_mmap_file(struct file *file, unsigned long reqprot,\n\t\t  unsigned long prot, unsigned long flags)\n{\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY\n\nstatic struct security_hook_list capability_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(capable, cap_capable),\n\tLSM_HOOK_INIT(settime, cap_settime),\n\tLSM_HOOK_INIT(ptrace_access_check, cap_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, cap_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, cap_capget),\n\tLSM_HOOK_INIT(capset, cap_capset),\n\tLSM_HOOK_INIT(bprm_creds_from_file, cap_bprm_creds_from_file),\n\tLSM_HOOK_INIT(inode_need_killpriv, cap_inode_need_killpriv),\n\tLSM_HOOK_INIT(inode_killpriv, cap_inode_killpriv),\n\tLSM_HOOK_INIT(inode_getsecurity, cap_inode_getsecurity),\n\tLSM_HOOK_INIT(mmap_addr, cap_mmap_addr),\n\tLSM_HOOK_INIT(mmap_file, cap_mmap_file),\n\tLSM_HOOK_INIT(task_fix_setuid, cap_task_fix_setuid),\n\tLSM_HOOK_INIT(task_prctl, cap_task_prctl),\n\tLSM_HOOK_INIT(task_setscheduler, cap_task_setscheduler),\n\tLSM_HOOK_INIT(task_setioprio, cap_task_setioprio),\n\tLSM_HOOK_INIT(task_setnice, cap_task_setnice),\n\tLSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),\n};\n\nstatic int __init capability_init(void)\n{\n\tsecurity_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),\n\t\t\t\t\"capability\");\n\treturn 0;\n}\n\nDEFINE_LSM(capability) = {\n\t.name = \"capability\",\n\t.order = LSM_ORDER_FIRST,\n\t.init = capability_init,\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}