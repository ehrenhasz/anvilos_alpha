{
  "module_name": "loadpin.c",
  "hash_id": "ffb1a75bad31472ed7889817332ee2f393ba39e93d13006e451b1c7253da3e6a",
  "original_prompt": "Ingested from linux-6.6.14/security/loadpin/loadpin.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"LoadPin: \" fmt\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/kernel_read_file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/path.h>\n#include <linux/sched.h>\t \n#include <linux/string_helpers.h>\n#include <linux/dm-verity-loadpin.h>\n#include <uapi/linux/loadpin.h>\n\n#define VERITY_DIGEST_FILE_HEADER \"# LOADPIN_TRUSTED_VERITY_ROOT_DIGESTS\"\n\nstatic void report_load(const char *origin, struct file *file, char *operation)\n{\n\tchar *cmdline, *pathname;\n\n\tpathname = kstrdup_quotable_file(file, GFP_KERNEL);\n\tcmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\n\n\tpr_notice(\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\",\n\t\t  origin, operation,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  pathname,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  task_pid_nr(current),\n\t\t  cmdline ? \"\\\"\" : \"\", cmdline, cmdline ? \"\\\"\" : \"\");\n\n\tkfree(cmdline);\n\tkfree(pathname);\n}\n\nstatic int enforce = IS_ENABLED(CONFIG_SECURITY_LOADPIN_ENFORCE);\nstatic char *exclude_read_files[READING_MAX_ID];\nstatic int ignore_read_file_id[READING_MAX_ID] __ro_after_init;\nstatic struct super_block *pinned_root;\nstatic DEFINE_SPINLOCK(pinned_root_spinlock);\n#ifdef CONFIG_SECURITY_LOADPIN_VERITY\nstatic bool deny_reading_verity_digests;\n#endif\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table loadpin_sysctl_table[] = {\n\t{\n\t\t.procname       = \"enforce\",\n\t\t.data           = &enforce,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ONE,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{ }\n};\n\nstatic void set_sysctl(bool is_writable)\n{\n\t \n\tif (is_writable)\n\t\tloadpin_sysctl_table[0].extra1 = SYSCTL_ZERO;\n\telse\n\t\tloadpin_sysctl_table[0].extra1 = SYSCTL_ONE;\n}\n#else\nstatic inline void set_sysctl(bool is_writable) { }\n#endif\n\nstatic void report_writable(struct super_block *mnt_sb, bool writable)\n{\n\tif (mnt_sb->s_bdev) {\n\t\tpr_info(\"%pg (%u:%u): %s\\n\", mnt_sb->s_bdev,\n\t\t\tMAJOR(mnt_sb->s_bdev->bd_dev),\n\t\t\tMINOR(mnt_sb->s_bdev->bd_dev),\n\t\t\twritable ? \"writable\" : \"read-only\");\n\t} else\n\t\tpr_info(\"mnt_sb lacks block device, treating as: writable\\n\");\n\n\tif (!writable)\n\t\tpr_info(\"load pinning engaged.\\n\");\n}\n\n \nstatic bool sb_is_writable(struct super_block *mnt_sb)\n{\n\tbool writable = true;\n\n\tif (mnt_sb->s_bdev)\n\t\twritable = !bdev_read_only(mnt_sb->s_bdev);\n\n\treturn writable;\n}\n\nstatic void loadpin_sb_free_security(struct super_block *mnt_sb)\n{\n\t \n\tif (!IS_ERR_OR_NULL(pinned_root) && mnt_sb == pinned_root) {\n\t\tif (enforce) {\n\t\t\tpinned_root = ERR_PTR(-EIO);\n\t\t\tpr_info(\"umount pinned fs: refusing further loads\\n\");\n\t\t} else {\n\t\t\tpinned_root = NULL;\n\t\t}\n\t}\n}\n\nstatic int loadpin_check(struct file *file, enum kernel_read_file_id id)\n{\n\tstruct super_block *load_root;\n\tconst char *origin = kernel_read_file_id_str(id);\n\tbool first_root_pin = false;\n\tbool load_root_writable;\n\n\t \n\tif ((unsigned int)id < ARRAY_SIZE(ignore_read_file_id) &&\n\t    ignore_read_file_id[id]) {\n\t\treport_load(origin, file, \"pinning-excluded\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!file) {\n\t\tif (!enforce) {\n\t\t\treport_load(origin, NULL, \"old-api-pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, NULL, \"old-api-denied\");\n\t\treturn -EPERM;\n\t}\n\n\tload_root = file->f_path.mnt->mnt_sb;\n\tload_root_writable = sb_is_writable(load_root);\n\n\t \n\tspin_lock(&pinned_root_spinlock);\n\t \n\tif (!pinned_root) {\n\t\tpinned_root = load_root;\n\t\tfirst_root_pin = true;\n\t}\n\tspin_unlock(&pinned_root_spinlock);\n\n\tif (first_root_pin) {\n\t\treport_writable(pinned_root, load_root_writable);\n\t\tset_sysctl(load_root_writable);\n\t\treport_load(origin, file, \"pinned\");\n\t}\n\n\tif (IS_ERR_OR_NULL(pinned_root) ||\n\t    ((load_root != pinned_root) && !dm_verity_loadpin_is_bdev_trusted(load_root->s_bdev))) {\n\t\tif (unlikely(!enforce)) {\n\t\t\treport_load(origin, file, \"pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, file, \"denied\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int loadpin_read_file(struct file *file, enum kernel_read_file_id id,\n\t\t\t     bool contents)\n{\n\t \n\treturn loadpin_check(file, id);\n}\n\nstatic int loadpin_load_data(enum kernel_load_data_id id, bool contents)\n{\n\t \n\treturn loadpin_check(NULL, (enum kernel_read_file_id) id);\n}\n\nstatic struct security_hook_list loadpin_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(sb_free_security, loadpin_sb_free_security),\n\tLSM_HOOK_INIT(kernel_read_file, loadpin_read_file),\n\tLSM_HOOK_INIT(kernel_load_data, loadpin_load_data),\n};\n\nstatic void __init parse_exclude(void)\n{\n\tint i, j;\n\tchar *cur;\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(exclude_read_files) !=\n\t\t     ARRAY_SIZE(ignore_read_file_id));\n\tBUILD_BUG_ON(ARRAY_SIZE(kernel_read_file_str) <\n\t\t     ARRAY_SIZE(ignore_read_file_id));\n\n\tfor (i = 0; i < ARRAY_SIZE(exclude_read_files); i++) {\n\t\tcur = exclude_read_files[i];\n\t\tif (!cur)\n\t\t\tbreak;\n\t\tif (*cur == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(ignore_read_file_id); j++) {\n\t\t\tif (strcmp(cur, kernel_read_file_str[j]) == 0) {\n\t\t\t\tpr_info(\"excluding: %s\\n\",\n\t\t\t\t\tkernel_read_file_str[j]);\n\t\t\t\tignore_read_file_id[j] = 1;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __init loadpin_init(void)\n{\n\tpr_info(\"ready to pin (currently %senforcing)\\n\",\n\t\tenforce ? \"\" : \"not \");\n\tparse_exclude();\n#ifdef CONFIG_SYSCTL\n\tif (!register_sysctl(\"kernel/loadpin\", loadpin_sysctl_table))\n\t\tpr_notice(\"sysctl registration failed!\\n\");\n#endif\n\tsecurity_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), \"loadpin\");\n\n\treturn 0;\n}\n\nDEFINE_LSM(loadpin) = {\n\t.name = \"loadpin\",\n\t.init = loadpin_init,\n};\n\n#ifdef CONFIG_SECURITY_LOADPIN_VERITY\n\nenum loadpin_securityfs_interface_index {\n\tLOADPIN_DM_VERITY,\n};\n\nstatic int read_trusted_verity_root_digests(unsigned int fd)\n{\n\tstruct fd f;\n\tvoid *data;\n\tint rc;\n\tchar *p, *d;\n\n\tif (deny_reading_verity_digests)\n\t\treturn -EPERM;\n\n\t \n\tif (!list_empty(&dm_verity_loadpin_trusted_root_digests))\n\t\treturn -EPERM;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EINVAL;\n\n\tdata = kzalloc(SZ_4K, GFP_KERNEL);\n\tif (!data) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\trc = kernel_read_file(f.file, 0, (void **)&data, SZ_4K - 1, NULL, READING_POLICY);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tp = data;\n\tp[rc] = '\\0';\n\tp = strim(p);\n\n\tp = strim(data);\n\twhile ((d = strsep(&p, \"\\n\")) != NULL) {\n\t\tint len;\n\t\tstruct dm_verity_loadpin_trusted_root_digest *trd;\n\n\t\tif (d == data) {\n\t\t\t \n\t\t\tif (strcmp(d, VERITY_DIGEST_FILE_HEADER)) {\n\t\t\t\trc = -EPROTO;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(d);\n\n\t\tif (len % 2) {\n\t\t\trc = -EPROTO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen /= 2;\n\n\t\ttrd = kzalloc(struct_size(trd, data, len), GFP_KERNEL);\n\t\tif (!trd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\ttrd->len = len;\n\n\t\tif (hex2bin(trd->data, d, len)) {\n\t\t\tkfree(trd);\n\t\t\trc = -EPROTO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&trd->node, &dm_verity_loadpin_trusted_root_digests);\n\t}\n\n\tif (list_empty(&dm_verity_loadpin_trusted_root_digests)) {\n\t\trc = -EPROTO;\n\t\tgoto err;\n\t}\n\n\tkfree(data);\n\tfdput(f);\n\n\treturn 0;\n\nerr:\n\tkfree(data);\n\n\t \n\t{\n\t\tstruct dm_verity_loadpin_trusted_root_digest *trd, *tmp;\n\n\t\tlist_for_each_entry_safe(trd, tmp, &dm_verity_loadpin_trusted_root_digests, node) {\n\t\t\tlist_del(&trd->node);\n\t\t\tkfree(trd);\n\t\t}\n\t}\n\n\t \n\tdeny_reading_verity_digests = true;\n\n\tfdput(f);\n\n\treturn rc;\n}\n\n \n\nstatic long dm_verity_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *uarg = (void __user *)arg;\n\tunsigned int fd;\n\n\tswitch (cmd) {\n\tcase LOADPIN_IOC_SET_TRUSTED_VERITY_DIGESTS:\n\t\tif (copy_from_user(&fd, uarg, sizeof(fd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn read_trusted_verity_root_digests(fd);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations loadpin_dm_verity_ops = {\n\t.unlocked_ioctl = dm_verity_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\n \nstatic int __init init_loadpin_securityfs(void)\n{\n\tstruct dentry *loadpin_dir, *dentry;\n\n\tloadpin_dir = securityfs_create_dir(\"loadpin\", NULL);\n\tif (IS_ERR(loadpin_dir)) {\n\t\tpr_err(\"LoadPin: could not create securityfs dir: %ld\\n\",\n\t\t       PTR_ERR(loadpin_dir));\n\t\treturn PTR_ERR(loadpin_dir);\n\t}\n\n\tdentry = securityfs_create_file(\"dm-verity\", 0600, loadpin_dir,\n\t\t\t\t\t(void *)LOADPIN_DM_VERITY, &loadpin_dm_verity_ops);\n\tif (IS_ERR(dentry)) {\n\t\tpr_err(\"LoadPin: could not create securityfs entry 'dm-verity': %ld\\n\",\n\t\t       PTR_ERR(dentry));\n\t\treturn PTR_ERR(dentry);\n\t}\n\n\treturn 0;\n}\n\nfs_initcall(init_loadpin_securityfs);\n\n#endif  \n\n \nmodule_param(enforce, int, 0);\nMODULE_PARM_DESC(enforce, \"Enforce module/firmware pinning\");\nmodule_param_array_named(exclude, exclude_read_files, charp, NULL, 0);\nMODULE_PARM_DESC(exclude, \"Exclude pinning specific read file types\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}