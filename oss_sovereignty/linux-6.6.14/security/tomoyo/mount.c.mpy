{
  "module_name": "mount.c",
  "hash_id": "ec15e09eec8423d6837b41bd6863a320fd9b9e258b9a46a0ce5cec16620305b2",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/mount.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <uapi/linux/mount.h>\n#include \"common.h\"\n\n \nstatic const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};\n\n \nstatic int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file mount %s %s %s 0x%lX\\n\",\n\t\t\t\t r->param.mount.dev->name,\n\t\t\t\t r->param.mount.dir->name,\n\t\t\t\t r->param.mount.type->name,\n\t\t\t\t r->param.mount.flags);\n}\n\n \nstatic bool tomoyo_check_mount_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mount_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn tomoyo_compare_number_union(r->param.mount.flags,\n\t\t\t\t\t   &acl->flags) &&\n\t\ttomoyo_compare_name_union(r->param.mount.type,\n\t\t\t\t\t  &acl->fs_type) &&\n\t\ttomoyo_compare_name_union(r->param.mount.dir,\n\t\t\t\t\t  &acl->dir_name) &&\n\t\t(!r->param.mount.need_dev ||\n\t\t tomoyo_compare_name_union(r->param.mount.dev,\n\t\t\t\t\t   &acl->dev_name));\n}\n\n \nstatic int tomoyo_mount_acl(struct tomoyo_request_info *r,\n\t\t\t    const char *dev_name,\n\t\t\t    const struct path *dir, const char *type,\n\t\t\t    unsigned long flags)\n{\n\tstruct tomoyo_obj_info obj = { };\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\tr->obj = &obj;\n\n\t \n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t \n\tobj.path2 = *dir;\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t \n\tif (type == tomoyo_mounts[TOMOYO_MOUNT_REMOUNT]) {\n\t\t \n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED]) {\n\t\t \n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_BIND] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {\n\t\tneed_dev = -1;  \n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t \n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t \n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tobj.path1 = path;\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\t \n\tif (obj.path1.dentry)\n\t\tpath_put(&obj.path1);\n\treturn error;\n}\n\n \nint tomoyo_mount_permission(const char *dev_name, const struct path *path,\n\t\t\t    const char *type, unsigned long flags,\n\t\t\t    void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_REMOUNT];\n\t\tflags &= ~MS_REMOUNT;\n\t} else if (flags & MS_BIND) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_BIND];\n\t\tflags &= ~MS_BIND;\n\t} else if (flags & MS_SHARED) {\n\t\tif (flags & (MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED];\n\t\tflags &= ~MS_SHARED;\n\t} else if (flags & MS_PRIVATE) {\n\t\tif (flags & (MS_SHARED | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE];\n\t\tflags &= ~MS_PRIVATE;\n\t} else if (flags & MS_SLAVE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE];\n\t\tflags &= ~MS_SLAVE;\n\t} else if (flags & MS_UNBINDABLE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE];\n\t\tflags &= ~MS_UNBINDABLE;\n\t} else if (flags & MS_MOVE) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MOVE];\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}