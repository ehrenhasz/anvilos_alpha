{
  "module_name": "file.c",
  "hash_id": "362265931c345b6124933c69bb65ab8d368b5e08f896d45801d8ee8e6a26695c",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/file.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/slab.h>\n\n \nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\n \nconst u8 tomoyo_pnnn2mac[TOMOYO_MAX_MKDEV_OPERATION] = {\n\t[TOMOYO_TYPE_MKBLOCK] = TOMOYO_MAC_FILE_MKBLOCK,\n\t[TOMOYO_TYPE_MKCHAR]  = TOMOYO_MAC_FILE_MKCHAR,\n};\n\n \nconst u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};\n\n \nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\n \nvoid tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}\n\n \nconst struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}\n\n \nvoid tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}\n\n \nbool tomoyo_compare_number_union(const unsigned long value,\n\t\t\t\t const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_number_matches_group(value, value, ptr->group);\n\treturn value >= ptr->values[0] && value <= ptr->values[1];\n}\n\n \nstatic void tomoyo_add_slash(struct tomoyo_path_info *buf)\n{\n\tif (buf->is_dir)\n\t\treturn;\n\t \n\tstrcat((char *) buf->name, \"/\");\n\ttomoyo_fill_path_info(buf);\n}\n\n \nstatic bool tomoyo_get_realpath(struct tomoyo_path_info *buf, const struct path *path)\n{\n\tbuf->name = tomoyo_realpath_from_path(path);\n\tif (buf->name) {\n\t\ttomoyo_fill_path_info(buf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int tomoyo_audit_path_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file %s %s\\n\", tomoyo_path_keyword\n\t\t\t\t [r->param.path.operation],\n\t\t\t\t r->param.path.filename->name);\n}\n\n \nstatic int tomoyo_audit_path2_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file %s %s %s\\n\", tomoyo_mac_keywords\n\t\t\t\t [tomoyo_pp2mac[r->param.path2.operation]],\n\t\t\t\t r->param.path2.filename1->name,\n\t\t\t\t r->param.path2.filename2->name);\n}\n\n \nstatic int tomoyo_audit_mkdev_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file %s %s 0%o %u %u\\n\",\n\t\t\t\t tomoyo_mac_keywords\n\t\t\t\t [tomoyo_pnnn2mac[r->param.mkdev.operation]],\n\t\t\t\t r->param.mkdev.filename->name,\n\t\t\t\t r->param.mkdev.mode, r->param.mkdev.major,\n\t\t\t\t r->param.mkdev.minor);\n}\n\n \nstatic int tomoyo_audit_path_number_log(struct tomoyo_request_info *r)\n{\n\tconst u8 type = r->param.path_number.operation;\n\tu8 radix;\n\tchar buffer[64];\n\n\tswitch (type) {\n\tcase TOMOYO_TYPE_CREATE:\n\tcase TOMOYO_TYPE_MKDIR:\n\tcase TOMOYO_TYPE_MKFIFO:\n\tcase TOMOYO_TYPE_MKSOCK:\n\tcase TOMOYO_TYPE_CHMOD:\n\t\tradix = TOMOYO_VALUE_TYPE_OCTAL;\n\t\tbreak;\n\tcase TOMOYO_TYPE_IOCTL:\n\t\tradix = TOMOYO_VALUE_TYPE_HEXADECIMAL;\n\t\tbreak;\n\tdefault:\n\t\tradix = TOMOYO_VALUE_TYPE_DECIMAL;\n\t\tbreak;\n\t}\n\ttomoyo_print_ulong(buffer, sizeof(buffer), r->param.path_number.number,\n\t\t\t   radix);\n\treturn tomoyo_supervisor(r, \"file %s %s %s\\n\", tomoyo_mac_keywords\n\t\t\t\t [tomoyo_pn2mac[type]],\n\t\t\t\t r->param.path_number.filename->name, buffer);\n}\n\n \nstatic bool tomoyo_check_path_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_path_acl *acl = container_of(ptr, typeof(*acl),\n\t\t\t\t\t\t\t head);\n\n\tif (acl->perm & (1 << r->param.path.operation)) {\n\t\tr->param.path.matched_path =\n\t\t\ttomoyo_compare_name_union(r->param.path.filename,\n\t\t\t\t\t\t  &acl->name);\n\t\treturn r->param.path.matched_path != NULL;\n\t}\n\treturn false;\n}\n\n \nstatic bool tomoyo_check_path_number_acl(struct tomoyo_request_info *r,\n\t\t\t\t\t const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_path_number_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.path_number.operation)) &&\n\t\ttomoyo_compare_number_union(r->param.path_number.number,\n\t\t\t\t\t    &acl->number) &&\n\t\ttomoyo_compare_name_union(r->param.path_number.filename,\n\t\t\t\t\t  &acl->name);\n}\n\n \nstatic bool tomoyo_check_path2_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_path2_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.path2.operation)) &&\n\t\ttomoyo_compare_name_union(r->param.path2.filename1, &acl->name1)\n\t\t&& tomoyo_compare_name_union(r->param.path2.filename2,\n\t\t\t\t\t     &acl->name2);\n}\n\n \nstatic bool tomoyo_check_mkdev_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mkdev_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.mkdev.operation)) &&\n\t\ttomoyo_compare_number_union(r->param.mkdev.mode,\n\t\t\t\t\t    &acl->mode) &&\n\t\ttomoyo_compare_number_union(r->param.mkdev.major,\n\t\t\t\t\t    &acl->major) &&\n\t\ttomoyo_compare_number_union(r->param.mkdev.minor,\n\t\t\t\t\t    &acl->minor) &&\n\t\ttomoyo_compare_name_union(r->param.mkdev.filename,\n\t\t\t\t\t  &acl->name);\n}\n\n \nstatic bool tomoyo_same_path_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_path_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_path_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn tomoyo_same_name_union(&p1->name, &p2->name);\n}\n\n \nstatic bool tomoyo_merge_path_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu16 * const a_perm = &container_of(a, struct tomoyo_path_acl, head)\n\t\t->perm;\n\tu16 perm = READ_ONCE(*a_perm);\n\tconst u16 b_perm = container_of(b, struct tomoyo_path_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nstatic int tomoyo_update_path_acl(const u16 perm,\n\t\t\t\t  struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_path_acl e = {\n\t\t.head.type = TOMOYO_TYPE_PATH_ACL,\n\t\t.perm = perm\n\t};\n\tint error;\n\n\tif (!tomoyo_parse_name_union(param, &e.name))\n\t\terror = -EINVAL;\n\telse\n\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_path_acl,\n\t\t\t\t\t     tomoyo_merge_path_acl);\n\ttomoyo_put_name_union(&e.name);\n\treturn error;\n}\n\n \nstatic bool tomoyo_same_mkdev_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_mkdev_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_mkdev_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn tomoyo_same_name_union(&p1->name, &p2->name) &&\n\t\ttomoyo_same_number_union(&p1->mode, &p2->mode) &&\n\t\ttomoyo_same_number_union(&p1->major, &p2->major) &&\n\t\ttomoyo_same_number_union(&p1->minor, &p2->minor);\n}\n\n \nstatic bool tomoyo_merge_mkdev_acl(struct tomoyo_acl_info *a,\n\t\t\t\t   struct tomoyo_acl_info *b,\n\t\t\t\t   const bool is_delete)\n{\n\tu8 *const a_perm = &container_of(a, struct tomoyo_mkdev_acl,\n\t\t\t\t\t head)->perm;\n\tu8 perm = READ_ONCE(*a_perm);\n\tconst u8 b_perm = container_of(b, struct tomoyo_mkdev_acl, head)\n\t\t->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nstatic int tomoyo_update_mkdev_acl(const u8 perm,\n\t\t\t\t   struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_mkdev_acl e = {\n\t\t.head.type = TOMOYO_TYPE_MKDEV_ACL,\n\t\t.perm = perm\n\t};\n\tint error;\n\n\tif (!tomoyo_parse_name_union(param, &e.name) ||\n\t    !tomoyo_parse_number_union(param, &e.mode) ||\n\t    !tomoyo_parse_number_union(param, &e.major) ||\n\t    !tomoyo_parse_number_union(param, &e.minor))\n\t\terror = -EINVAL;\n\telse\n\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_mkdev_acl,\n\t\t\t\t\t     tomoyo_merge_mkdev_acl);\n\ttomoyo_put_name_union(&e.name);\n\ttomoyo_put_number_union(&e.mode);\n\ttomoyo_put_number_union(&e.major);\n\ttomoyo_put_number_union(&e.minor);\n\treturn error;\n}\n\n \nstatic bool tomoyo_same_path2_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t  const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_path2_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_path2_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn tomoyo_same_name_union(&p1->name1, &p2->name1) &&\n\t\ttomoyo_same_name_union(&p1->name2, &p2->name2);\n}\n\n \nstatic bool tomoyo_merge_path2_acl(struct tomoyo_acl_info *a,\n\t\t\t\t   struct tomoyo_acl_info *b,\n\t\t\t\t   const bool is_delete)\n{\n\tu8 * const a_perm = &container_of(a, struct tomoyo_path2_acl, head)\n\t\t->perm;\n\tu8 perm = READ_ONCE(*a_perm);\n\tconst u8 b_perm = container_of(b, struct tomoyo_path2_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nstatic int tomoyo_update_path2_acl(const u8 perm,\n\t\t\t\t   struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_path2_acl e = {\n\t\t.head.type = TOMOYO_TYPE_PATH2_ACL,\n\t\t.perm = perm\n\t};\n\tint error;\n\n\tif (!tomoyo_parse_name_union(param, &e.name1) ||\n\t    !tomoyo_parse_name_union(param, &e.name2))\n\t\terror = -EINVAL;\n\telse\n\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_path2_acl,\n\t\t\t\t\t     tomoyo_merge_path2_acl);\n\ttomoyo_put_name_union(&e.name1);\n\ttomoyo_put_name_union(&e.name2);\n\treturn error;\n}\n\n \nstatic int tomoyo_path_permission(struct tomoyo_request_info *r, u8 operation,\n\t\t\t\t  const struct tomoyo_path_info *filename)\n{\n\tint error;\n\n\tr->type = tomoyo_p2mac[operation];\n\tr->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);\n\tif (r->mode == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tr->param_type = TOMOYO_TYPE_PATH_ACL;\n\tr->param.path.filename = filename;\n\tr->param.path.operation = operation;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_path_acl);\n\t\terror = tomoyo_audit_path_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\treturn error;\n}\n\n \nint tomoyo_execute_permission(struct tomoyo_request_info *r,\n\t\t\t      const struct tomoyo_path_info *filename)\n{\n\t \n\tr->type = TOMOYO_MAC_FILE_EXECUTE;\n\tr->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);\n\tr->param_type = TOMOYO_TYPE_PATH_ACL;\n\tr->param.path.filename = filename;\n\tr->param.path.operation = TOMOYO_TYPE_EXECUTE;\n\ttomoyo_check_acl(r, tomoyo_check_path_acl);\n\tr->ee->transition = r->matched_acl && r->matched_acl->cond ?\n\t\tr->matched_acl->cond->transit : NULL;\n\tif (r->mode != TOMOYO_CONFIG_DISABLED)\n\t\treturn tomoyo_audit_path_log(r);\n\treturn 0;\n}\n\n \nstatic bool tomoyo_same_path_number_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_path_number_acl *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t       head);\n\tconst struct tomoyo_path_number_acl *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t       head);\n\n\treturn tomoyo_same_name_union(&p1->name, &p2->name) &&\n\t\ttomoyo_same_number_union(&p1->number, &p2->number);\n}\n\n \nstatic bool tomoyo_merge_path_number_acl(struct tomoyo_acl_info *a,\n\t\t\t\t\t struct tomoyo_acl_info *b,\n\t\t\t\t\t const bool is_delete)\n{\n\tu8 * const a_perm = &container_of(a, struct tomoyo_path_number_acl,\n\t\t\t\t\t  head)->perm;\n\tu8 perm = READ_ONCE(*a_perm);\n\tconst u8 b_perm = container_of(b, struct tomoyo_path_number_acl, head)\n\t\t->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nstatic int tomoyo_update_path_number_acl(const u8 perm,\n\t\t\t\t\t struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_path_number_acl e = {\n\t\t.head.type = TOMOYO_TYPE_PATH_NUMBER_ACL,\n\t\t.perm = perm\n\t};\n\tint error;\n\n\tif (!tomoyo_parse_name_union(param, &e.name) ||\n\t    !tomoyo_parse_number_union(param, &e.number))\n\t\terror = -EINVAL;\n\telse\n\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_path_number_acl,\n\t\t\t\t\t     tomoyo_merge_path_number_acl);\n\ttomoyo_put_name_union(&e.name);\n\ttomoyo_put_number_union(&e.number);\n\treturn error;\n}\n\n \nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}\n\n \nint tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}\n\n \nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}\n\n \nint tomoyo_mkdev_perm(const u8 operation, const struct path *path,\n\t\t      const unsigned int mode, unsigned int dev)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\terror = -ENOMEM;\n\tif (tomoyo_get_realpath(&buf, path)) {\n\t\tr.obj = &obj;\n\t\tdev = new_decode_dev(dev);\n\t\tr.param_type = TOMOYO_TYPE_MKDEV_ACL;\n\t\tr.param.mkdev.filename = &buf;\n\t\tr.param.mkdev.operation = operation;\n\t\tr.param.mkdev.mode = mode;\n\t\tr.param.mkdev.major = MAJOR(dev);\n\t\tr.param.mkdev.minor = MINOR(dev);\n\t\ttomoyo_check_acl(&r, tomoyo_check_mkdev_acl);\n\t\terror = tomoyo_audit_mkdev_log(&r);\n\t\tkfree(buf.name);\n\t}\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}\n\n \nint tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}\n\n \nstatic bool tomoyo_same_mount_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t  const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_mount_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_mount_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn tomoyo_same_name_union(&p1->dev_name, &p2->dev_name) &&\n\t\ttomoyo_same_name_union(&p1->dir_name, &p2->dir_name) &&\n\t\ttomoyo_same_name_union(&p1->fs_type, &p2->fs_type) &&\n\t\ttomoyo_same_number_union(&p1->flags, &p2->flags);\n}\n\n \nstatic int tomoyo_update_mount_acl(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_mount_acl e = { .head.type = TOMOYO_TYPE_MOUNT_ACL };\n\tint error;\n\n\tif (!tomoyo_parse_name_union(param, &e.dev_name) ||\n\t    !tomoyo_parse_name_union(param, &e.dir_name) ||\n\t    !tomoyo_parse_name_union(param, &e.fs_type) ||\n\t    !tomoyo_parse_number_union(param, &e.flags))\n\t\terror = -EINVAL;\n\telse\n\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_mount_acl, NULL);\n\ttomoyo_put_name_union(&e.dev_name);\n\ttomoyo_put_name_union(&e.dir_name);\n\ttomoyo_put_name_union(&e.fs_type);\n\ttomoyo_put_number_union(&e.flags);\n\treturn error;\n}\n\n \nint tomoyo_write_file(struct tomoyo_acl_param *param)\n{\n\tu16 perm = 0;\n\tu8 type;\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (type = 0; type < TOMOYO_MAX_PATH_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_path_keyword[type]))\n\t\t\tperm |= 1 << type;\n\tif (perm)\n\t\treturn tomoyo_update_path_acl(perm, param);\n\tfor (type = 0; type < TOMOYO_MAX_PATH2_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation,\n\t\t\t\t   tomoyo_mac_keywords[tomoyo_pp2mac[type]]))\n\t\t\tperm |= 1 << type;\n\tif (perm)\n\t\treturn tomoyo_update_path2_acl(perm, param);\n\tfor (type = 0; type < TOMOYO_MAX_PATH_NUMBER_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation,\n\t\t\t\t   tomoyo_mac_keywords[tomoyo_pn2mac[type]]))\n\t\t\tperm |= 1 << type;\n\tif (perm)\n\t\treturn tomoyo_update_path_number_acl(perm, param);\n\tfor (type = 0; type < TOMOYO_MAX_MKDEV_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation,\n\t\t\t\t   tomoyo_mac_keywords[tomoyo_pnnn2mac[type]]))\n\t\t\tperm |= 1 << type;\n\tif (perm)\n\t\treturn tomoyo_update_mkdev_acl(perm, param);\n\tif (tomoyo_permstr(operation,\n\t\t\t   tomoyo_mac_keywords[TOMOYO_MAC_FILE_MOUNT]))\n\t\treturn tomoyo_update_mount_acl(param);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}