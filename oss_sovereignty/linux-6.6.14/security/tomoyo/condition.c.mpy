{
  "module_name": "condition.c",
  "hash_id": "3872418d6295e16774fb01b97ad6a1cb9a2acb74892339f655eca9facb02b9aa",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/condition.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/slab.h>\n\n \nLIST_HEAD(tomoyo_condition_list);\n\n \nstatic bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\n\t\t\tconst int argc, const struct tomoyo_argv *argv,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info arg;\n\n\targ.name = arg_ptr;\n\tfor (i = 0; i < argc; argv++, checked++, i++) {\n\t\tbool result;\n\n\t\tif (index != argv->index)\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\ttomoyo_fill_path_info(&arg);\n\t\tresult = tomoyo_path_matches_pattern(&arg, argv->value);\n\t\tif (argv->is_not)\n\t\t\tresult = !result;\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool tomoyo_envp(const char *env_name, const char *env_value,\n\t\t\tconst int envc, const struct tomoyo_envp *envp,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info name;\n\tstruct tomoyo_path_info value;\n\n\tname.name = env_name;\n\ttomoyo_fill_path_info(&name);\n\tvalue.name = env_value;\n\ttomoyo_fill_path_info(&value);\n\tfor (i = 0; i < envc; envp++, checked++, i++) {\n\t\tbool result;\n\n\t\tif (!tomoyo_path_matches_pattern(&name, envp->name))\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\tif (envp->value) {\n\t\t\tresult = tomoyo_path_matches_pattern(&value,\n\t\t\t\t\t\t\t     envp->value);\n\t\t\tif (envp->is_not)\n\t\t\t\tresult = !result;\n\t\t} else {\n\t\t\tresult = true;\n\t\t\tif (!envp->is_not)\n\t\t\t\tresult = !result;\n\t\t}\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\n\t\t\t     const u16 argc, const struct tomoyo_argv *argv,\n\t\t\t     const u16 envc, const struct tomoyo_envp *envp)\n{\n\tstruct linux_binprm *bprm = ee->bprm;\n\tstruct tomoyo_page_dump *dump = &ee->dump;\n\tchar *arg_ptr = ee->tmp;\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool result = true;\n\tu8 local_checked[32];\n\tu8 *checked;\n\n\tif (argc + envc <= sizeof(local_checked)) {\n\t\tchecked = local_checked;\n\t\tmemset(local_checked, 0, sizeof(local_checked));\n\t} else {\n\t\tchecked = kzalloc(argc + envc, GFP_NOFS);\n\t\tif (!checked)\n\t\t\treturn false;\n\t}\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump)) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += PAGE_SIZE - offset;\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\t \n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++] =\n\t\t\t\t\t\t((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (argv_count) {\n\t\t\t\tif (!tomoyo_argv(bprm->argc - argv_count,\n\t\t\t\t\t\t arg_ptr, argc, argv,\n\t\t\t\t\t\t checked)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targv_count--;\n\t\t\t} else if (envp_count) {\n\t\t\t\tchar *cp = strchr(arg_ptr, '=');\n\n\t\t\t\tif (cp) {\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tif (!tomoyo_envp(arg_ptr, cp + 1,\n\t\t\t\t\t\t\t envc, envp,\n\t\t\t\t\t\t\t checked + argc)) {\n\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tenvp_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t\tif (!result)\n\t\t\tbreak;\n\t}\nout:\n\tif (result) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (checked[i])\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (argv[i].is_not)\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < envc; envp++, i++) {\n\t\t\tif (checked[argc + i])\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((!envp->value && !envp->is_not) ||\n\t\t\t    (envp->value && envp->is_not))\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (checked != local_checked)\n\t\tkfree(checked);\n\treturn result;\n}\n\n \nstatic bool tomoyo_scan_exec_realpath(struct file *file,\n\t\t\t\t      const struct tomoyo_name_union *ptr,\n\t\t\t\t      const bool match)\n{\n\tbool result;\n\tstruct tomoyo_path_info exe;\n\n\tif (!file)\n\t\treturn false;\n\texe.name = tomoyo_realpath_from_path(&file->f_path);\n\tif (!exe.name)\n\t\treturn false;\n\ttomoyo_fill_path_info(&exe);\n\tresult = tomoyo_compare_name_union(&exe, ptr);\n\tkfree(exe.name);\n\treturn result == match;\n}\n\n \nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}\n\n \nstatic bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}\n\n \nstatic bool tomoyo_parse_argv(char *left, char *right,\n\t\t\t      struct tomoyo_argv *argv)\n{\n\tif (tomoyo_parse_ulong(&argv->index, &left) !=\n\t    TOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\n\t\treturn false;\n\targv->value = tomoyo_get_dqword(right);\n\treturn argv->value != NULL;\n}\n\n \nstatic bool tomoyo_parse_envp(char *left, char *right,\n\t\t\t      struct tomoyo_envp *envp)\n{\n\tconst struct tomoyo_path_info *name;\n\tconst struct tomoyo_path_info *value;\n\tchar *cp = left + strlen(left) - 1;\n\n\tif (*cp-- != ']' || *cp != '\"')\n\t\tgoto out;\n\t*cp = '\\0';\n\tif (!tomoyo_correct_word(left))\n\t\tgoto out;\n\tname = tomoyo_get_name(left);\n\tif (!name)\n\t\tgoto out;\n\tif (!strcmp(right, \"NULL\")) {\n\t\tvalue = NULL;\n\t} else {\n\t\tvalue = tomoyo_get_dqword(right);\n\t\tif (!value) {\n\t\t\ttomoyo_put_name(name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tenvp->name = name;\n\tenvp->value = value;\n\treturn true;\nout:\n\treturn false;\n}\n\n \nstatic inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\n\t\t\t\t\t const struct tomoyo_condition *b)\n{\n\treturn a->size == b->size && a->condc == b->condc &&\n\t\ta->numbers_count == b->numbers_count &&\n\t\ta->names_count == b->names_count &&\n\t\ta->argc == b->argc && a->envc == b->envc &&\n\t\ta->grant_log == b->grant_log && a->transit == b->transit &&\n\t\t!memcmp(a + 1, b + 1, a->size - sizeof(*a));\n}\n\n \nstatic u8 tomoyo_condition_type(const char *word)\n{\n\tu8 i;\n\n\tfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\n\t\tif (!strcmp(word, tomoyo_condition_keyword[i]))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n \n \n\n#ifdef DEBUG_CONDITION\n#define dprintk printk\n#else\n#define dprintk(...) do { } while (0)\n#endif\n\n \nstatic struct tomoyo_condition *tomoyo_commit_condition\n(struct tomoyo_condition *entry)\n{\n\tstruct tomoyo_condition *ptr;\n\tbool found = false;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\n\t\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\t\tptr = NULL;\n\t\tfound = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\n\t\tif (!tomoyo_same_condition(ptr, entry) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\t \n\t\tatomic_inc(&ptr->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tif (tomoyo_memory_ok(entry)) {\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add(&entry->head.list, &tomoyo_condition_list);\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tptr = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tif (found) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t\tentry = ptr;\n\t}\n\treturn entry;\n}\n\n \nstatic char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_condition *e)\n{\n\tchar * const pos = param->data;\n\tbool flag;\n\n\tif (*pos == '<') {\n\t\te->transit = tomoyo_get_domainname(param);\n\t\tgoto done;\n\t}\n\t{\n\t\tchar *cp = strchr(pos, ' ');\n\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tflag = tomoyo_correct_path(pos) || !strcmp(pos, \"keep\") ||\n\t\t\t!strcmp(pos, \"initialize\") || !strcmp(pos, \"reset\") ||\n\t\t\t!strcmp(pos, \"child\") || !strcmp(pos, \"parent\");\n\t\tif (cp)\n\t\t\t*cp = ' ';\n\t}\n\tif (!flag)\n\t\treturn pos;\n\te->transit = tomoyo_get_name(tomoyo_read_token(param));\ndone:\n\tif (e->transit)\n\t\treturn param->data;\n\t \n\treturn \"/\";\n}\n\n \nstruct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_condition *entry = NULL;\n\tstruct tomoyo_condition_element *condp = NULL;\n\tstruct tomoyo_number_union *numbers_p = NULL;\n\tstruct tomoyo_name_union *names_p = NULL;\n\tstruct tomoyo_argv *argv = NULL;\n\tstruct tomoyo_envp *envp = NULL;\n\tstruct tomoyo_condition e = { };\n\tchar * const start_of_string =\n\t\ttomoyo_get_transit_preference(param, &e);\n\tchar * const end_of_string = start_of_string + strlen(start_of_string);\n\tchar *pos;\n\nrerun:\n\tpos = start_of_string;\n\twhile (1) {\n\t\tu8 left = -1;\n\t\tu8 right = -1;\n\t\tchar *left_word = pos;\n\t\tchar *cp;\n\t\tchar *right_word;\n\t\tbool is_not;\n\n\t\tif (!*left_word)\n\t\t\tbreak;\n\t\t \n\t\tcp = strchr(pos, ' ');\n\t\tif (cp) {\n\t\t\t*cp = '\\0';  \n\t\t\tpos = cp + 1;\n\t\t} else {\n\t\t\tpos = \"\";\n\t\t}\n\t\tright_word = strchr(left_word, '=');\n\t\tif (!right_word || right_word == left_word)\n\t\t\tgoto out;\n\t\tis_not = *(right_word - 1) == '!';\n\t\tif (is_not)\n\t\t\t*(right_word++ - 1) = '\\0';  \n\t\telse if (*(right_word + 1) != '=')\n\t\t\t*right_word++ = '\\0';  \n\t\telse\n\t\t\tgoto out;\n\t\tdprintk(KERN_WARNING \"%u: <%s>%s=<%s>\\n\", __LINE__, left_word,\n\t\t\tis_not ? \"!\" : \"\", right_word);\n\t\tif (!strcmp(left_word, \"grant_log\")) {\n\t\t\tif (entry) {\n\t\t\t\tif (is_not ||\n\t\t\t\t    entry->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\t\t\tgoto out;\n\t\t\t\telse if (!strcmp(right_word, \"yes\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_YES;\n\t\t\t\telse if (!strcmp(right_word, \"no\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_NO;\n\t\t\t\telse\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.argv[\", 10)) {\n\t\t\tif (!argv) {\n\t\t\t\te.argc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.argc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ARGV_ENTRY;\n\t\t\t\targv->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_argv(left_word + 10,\n\t\t\t\t\t\t       right_word, argv++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.envp[\\\"\", 11)) {\n\t\t\tif (!envp) {\n\t\t\t\te.envc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.envc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ENVP_ENTRY;\n\t\t\t\tenvp->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_envp(left_word + 11,\n\t\t\t\t\t\t       right_word, envp++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tleft = tomoyo_condition_type(left_word);\n\t\tdprintk(KERN_WARNING \"%u: <%s> left=%u\\n\", __LINE__, left_word,\n\t\t\tleft);\n\t\tif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tleft = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = left_word;\n\t\t\t\tif (*left_word == '@' ||\n\t\t\t\t    !tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!condp)\n\t\t\te.condc++;\n\t\telse\n\t\t\te.condc--;\n\t\tif (left == TOMOYO_EXEC_REALPATH ||\n\t\t    left == TOMOYO_SYMLINK_TARGET) {\n\t\t\tif (!names_p) {\n\t\t\t\te.names_count++;\n\t\t\t} else {\n\t\t\t\te.names_count--;\n\t\t\t\tright = TOMOYO_NAME_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_name_union_quoted(param,\n\t\t\t\t\t\t\t\t    names_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tright = tomoyo_condition_type(right_word);\n\t\tif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tright = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nstore_value:\n\t\tif (!condp) {\n\t\t\tdprintk(KERN_WARNING \"%u: dry_run left=%u right=%u match=%u\\n\",\n\t\t\t\t__LINE__, left, right, !is_not);\n\t\t\tcontinue;\n\t\t}\n\t\tcondp->left = left;\n\t\tcondp->right = right;\n\t\tcondp->equals = !is_not;\n\t\tdprintk(KERN_WARNING \"%u: left=%u right=%u match=%u\\n\",\n\t\t\t__LINE__, condp->left, condp->right,\n\t\t\tcondp->equals);\n\t\tcondp++;\n\t}\n\tdprintk(KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\",\n\t\t__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\n\t\te.envc);\n\tif (entry) {\n\t\tBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc);\n\t\treturn tomoyo_commit_condition(entry);\n\t}\n\te.size = sizeof(*entry)\n\t\t+ e.condc * sizeof(struct tomoyo_condition_element)\n\t\t+ e.numbers_count * sizeof(struct tomoyo_number_union)\n\t\t+ e.names_count * sizeof(struct tomoyo_name_union)\n\t\t+ e.argc * sizeof(struct tomoyo_argv)\n\t\t+ e.envc * sizeof(struct tomoyo_envp);\n\tentry = kzalloc(e.size, GFP_NOFS);\n\tif (!entry)\n\t\tgoto out2;\n\t*entry = e;\n\te.transit = NULL;\n\tcondp = (struct tomoyo_condition_element *) (entry + 1);\n\tnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\n\tnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\n\targv = (struct tomoyo_argv *) (names_p + e.names_count);\n\tenvp = (struct tomoyo_envp *) (argv + e.argc);\n\t{\n\t\tbool flag = false;\n\n\t\tfor (pos = start_of_string; pos < end_of_string; pos++) {\n\t\t\tif (*pos)\n\t\t\t\tcontinue;\n\t\t\tif (flag)  \n\t\t\t\t*pos = ' ';\n\t\t\telse if (*(pos + 1) == '=')  \n\t\t\t\t*pos = '!';\n\t\t\telse  \n\t\t\t\t*pos = '=';\n\t\t\tflag = !flag;\n\t\t}\n\t}\n\tgoto rerun;\nout:\n\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\tif (entry) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t}\nout2:\n\ttomoyo_put_name(e.transit);\n\treturn NULL;\n}\n\n \nvoid tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1)  \n\t\t\tdput(dentry);\n\t}\n}\n\n \nbool tomoyo_condition(struct tomoyo_request_info *r,\n\t\t      const struct tomoyo_condition *cond)\n{\n\tu32 i;\n\tunsigned long min_v[2] = { 0, 0 };\n\tunsigned long max_v[2] = { 0, 0 };\n\tconst struct tomoyo_condition_element *condp;\n\tconst struct tomoyo_number_union *numbers_p;\n\tconst struct tomoyo_name_union *names_p;\n\tconst struct tomoyo_argv *argv;\n\tconst struct tomoyo_envp *envp;\n\tstruct tomoyo_obj_info *obj;\n\tu16 condc;\n\tu16 argc;\n\tu16 envc;\n\tstruct linux_binprm *bprm = NULL;\n\n\tif (!cond)\n\t\treturn true;\n\tcondc = cond->condc;\n\targc = cond->argc;\n\tenvc = cond->envc;\n\tobj = r->obj;\n\tif (r->ee)\n\t\tbprm = r->ee->bprm;\n\tif (!bprm && (argc || envc))\n\t\treturn false;\n\tcondp = (struct tomoyo_condition_element *) (cond + 1);\n\tnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\n\tnames_p = (const struct tomoyo_name_union *)\n\t\t(numbers_p + cond->numbers_count);\n\targv = (const struct tomoyo_argv *) (names_p + cond->names_count);\n\tenvp = (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < condc; i++) {\n\t\tconst bool match = condp->equals;\n\t\tconst u8 left = condp->left;\n\t\tconst u8 right = condp->right;\n\t\tbool is_bitop[2] = { false, false };\n\t\tu8 j;\n\n\t\tcondp++;\n\t\t \n\t\tif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\n\t\t\tcontinue;\n\t\t \n\t\tif (right == TOMOYO_NAME_UNION) {\n\t\t\tconst struct tomoyo_name_union *ptr = names_p++;\n\t\t\tstruct tomoyo_path_info *symlink;\n\t\t\tstruct tomoyo_execve *ee;\n\t\t\tstruct file *file;\n\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_SYMLINK_TARGET:\n\t\t\t\tsymlink = obj ? obj->symlink_target : NULL;\n\t\t\t\tif (!symlink ||\n\t\t\t\t    !tomoyo_compare_name_union(symlink, ptr)\n\t\t\t\t    == match)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_REALPATH:\n\t\t\t\tee = r->ee;\n\t\t\t\tfile = ee ? ee->bprm->file : NULL;\n\t\t\t\tif (!tomoyo_scan_exec_realpath(file, ptr,\n\t\t\t\t\t\t\t       match))\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tconst u8 index = j ? right : left;\n\t\t\tunsigned long value = 0;\n\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_TASK_UID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_uid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_euid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_suid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_fsuid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_GID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_gid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_egid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_sgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_fsgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PID:\n\t\t\t\tvalue = tomoyo_sys_getpid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PPID:\n\t\t\t\tvalue = tomoyo_sys_getppid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SOCKET:\n\t\t\t\tvalue = S_IFSOCK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SYMLINK:\n\t\t\t\tvalue = S_IFLNK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FILE:\n\t\t\t\tvalue = S_IFREG;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_BLOCK_DEV:\n\t\t\t\tvalue = S_IFBLK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_DIRECTORY:\n\t\t\t\tvalue = S_IFDIR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_CHAR_DEV:\n\t\t\t\tvalue = S_IFCHR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FIFO:\n\t\t\t\tvalue = S_IFIFO;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\t\tvalue = S_ISUID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\t\tvalue = S_ISGID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\t\tvalue = S_ISVTX;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\t\tvalue = 0400;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\t\tvalue = 0200;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\t\tvalue = 0100;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\t\tvalue = 0040;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\t\tvalue = 0020;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\t\tvalue = 0010;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\t\tvalue = 0004;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\t\tvalue = 0002;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tvalue = 0001;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ARGC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->argc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ENVC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->envc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!obj)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!obj->validate_done) {\n\t\t\t\t\ttomoyo_get_attributes(obj);\n\t\t\t\t\tobj->validate_done = true;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tu8 stat_index;\n\t\t\t\t\tstruct tomoyo_mini_stat *stat;\n\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH1_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH2_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj->stat_valid[stat_index])\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tstat = &obj->stat[stat_index];\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\t\tvalue = from_kuid(&init_user_ns, stat->uid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\t\tvalue = from_kgid(&init_user_ns, stat->gid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\t\tvalue = stat->ino;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\t\tvalue = stat->mode & S_IFMT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tvalue = stat->mode & S_IALLUGO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_v[j] = value;\n\t\t\tmin_v[j] = value;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tis_bitop[j] = true;\n\t\t\t}\n\t\t}\n\t\tif (left == TOMOYO_NUMBER_UNION) {\n\t\t\t \n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\n\t\t\tmin_v[0] = ptr->values[0];\n\t\t\tmax_v[0] = ptr->values[1];\n\t\t}\n\t\tif (right == TOMOYO_NUMBER_UNION) {\n\t\t\t \n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\n\t\t\tif (ptr->group) {\n\t\t\t\tif (tomoyo_number_matches_group(min_v[0],\n\t\t\t\t\t\t\t\tmax_v[0],\n\t\t\t\t\t\t\t\tptr->group)\n\t\t\t\t    == match)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif ((min_v[0] <= ptr->values[1] &&\n\t\t\t\t     max_v[0] >= ptr->values[0]) == match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (is_bitop[0] && is_bitop[1]) {\n\t\t\tgoto out;\n\t\t} else if (is_bitop[0]) {\n\t\t\tswitch (right) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (is_bitop[1]) {\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\n\t\t\tcontinue;\nout:\n\t\treturn false;\n\t}\n\t \n\tif (r->ee && (argc || envc))\n\t\treturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}