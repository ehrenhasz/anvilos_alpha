{
  "module_name": "util.c",
  "hash_id": "c5f7b8eca0fce24707ec93a4525c4b70c03eb22bb5fa9358f00bdb68b7207b0e",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/util.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n#include \"common.h\"\n\n \nDEFINE_MUTEX(tomoyo_policy_lock);\n\n \nbool tomoyo_policy_loaded;\n\n \nconst u8 tomoyo_index2category[TOMOYO_MAX_MAC_INDEX] = {\n\t \n\t[TOMOYO_MAC_FILE_EXECUTE]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_OPEN]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CREATE]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UNLINK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_GETATTR]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RMDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKFIFO]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKSOCK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_SYMLINK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKCHAR]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_LINK]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RENAME]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHMOD]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHOWN]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHGRP]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_IOCTL]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHROOT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MOUNT]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UMOUNT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = TOMOYO_MAC_CATEGORY_FILE,\n\t \n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t \n\t[TOMOYO_MAC_ENVIRON]         = TOMOYO_MAC_CATEGORY_MISC,\n};\n\n \nvoid tomoyo_convert_time(time64_t time64, struct tomoyo_time *stamp)\n{\n\tstruct tm tm;\n\n\ttime64_to_tm(time64, 0, &tm);\n\tstamp->sec = tm.tm_sec;\n\tstamp->min = tm.tm_min;\n\tstamp->hour = tm.tm_hour;\n\tstamp->day = tm.tm_mday;\n\tstamp->month = tm.tm_mon + 1;\n\tstamp->year = tm.tm_year + 1900;\n}\n\n \nbool tomoyo_permstr(const char *string, const char *keyword)\n{\n\tconst char *cp = strstr(string, keyword);\n\n\tif (cp)\n\t\treturn cp == string || *(cp - 1) == '/';\n\treturn false;\n}\n\n \nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}\n\nstatic bool tomoyo_correct_path2(const char *filename, const size_t len);\n\n \nconst struct tomoyo_path_info *tomoyo_get_domainname\n(struct tomoyo_acl_param *param)\n{\n\tchar *start = param->data;\n\tchar *pos = start;\n\n\twhile (*pos) {\n\t\tif (*pos++ != ' ' ||\n\t\t    tomoyo_correct_path2(pos, strchrnul(pos, ' ') - pos))\n\t\t\tcontinue;\n\t\t*(pos - 1) = '\\0';\n\t\tbreak;\n\t}\n\tparam->data = pos;\n\tif (tomoyo_correct_domain(start))\n\t\treturn tomoyo_get_name(start);\n\treturn NULL;\n}\n\n \nu8 tomoyo_parse_ulong(unsigned long *result, char **str)\n{\n\tconst char *cp = *str;\n\tchar *ep;\n\tint base = 10;\n\n\tif (*cp == '0') {\n\t\tchar c = *(cp + 1);\n\n\t\tif (c == 'x' || c == 'X') {\n\t\t\tbase = 16;\n\t\t\tcp += 2;\n\t\t} else if (c >= '0' && c <= '7') {\n\t\t\tbase = 8;\n\t\t\tcp++;\n\t\t}\n\t}\n\t*result = simple_strtoul(cp, &ep, base);\n\tif (cp == ep)\n\t\treturn TOMOYO_VALUE_TYPE_INVALID;\n\t*str = ep;\n\tswitch (base) {\n\tcase 16:\n\t\treturn TOMOYO_VALUE_TYPE_HEXADECIMAL;\n\tcase 8:\n\t\treturn TOMOYO_VALUE_TYPE_OCTAL;\n\tdefault:\n\t\treturn TOMOYO_VALUE_TYPE_DECIMAL;\n\t}\n}\n\n \nvoid tomoyo_print_ulong(char *buffer, const int buffer_len,\n\t\t\tconst unsigned long value, const u8 type)\n{\n\tif (type == TOMOYO_VALUE_TYPE_DECIMAL)\n\t\tsnprintf(buffer, buffer_len, \"%lu\", value);\n\telse if (type == TOMOYO_VALUE_TYPE_OCTAL)\n\t\tsnprintf(buffer, buffer_len, \"0%lo\", value);\n\telse if (type == TOMOYO_VALUE_TYPE_HEXADECIMAL)\n\t\tsnprintf(buffer, buffer_len, \"0x%lX\", value);\n\telse\n\t\tsnprintf(buffer, buffer_len, \"type(%u)\", type);\n}\n\n \nbool tomoyo_parse_name_union(struct tomoyo_acl_param *param,\n\t\t\t     struct tomoyo_name_union *ptr)\n{\n\tchar *filename;\n\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_PATH_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tfilename = tomoyo_read_token(param);\n\tif (!tomoyo_correct_word(filename))\n\t\treturn false;\n\tptr->filename = tomoyo_get_name(filename);\n\treturn ptr->filename != NULL;\n}\n\n \nbool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}\n\n \nstatic inline bool tomoyo_byte_range(const char *str)\n{\n\treturn *str >= '0' && *str++ <= '3' &&\n\t\t*str >= '0' && *str++ <= '7' &&\n\t\t*str >= '0' && *str <= '7';\n}\n\n \nstatic inline bool tomoyo_alphabet_char(const char c)\n{\n\treturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\n \nstatic inline u8 tomoyo_make_byte(const u8 c1, const u8 c2, const u8 c3)\n{\n\treturn ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');\n}\n\n \nstatic inline bool tomoyo_valid(const unsigned char c)\n{\n\treturn c > ' ' && c < 127;\n}\n\n \nstatic inline bool tomoyo_invalid(const unsigned char c)\n{\n\treturn c && (c <= ' ' || c >= 127);\n}\n\n \nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}\n\n \nvoid tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}\n\n \nstatic bool tomoyo_correct_word2(const char *string, size_t len)\n{\n\tu8 recursion = 20;\n\tconst char *const start = string;\n\tbool in_repetition = false;\n\n\tif (!len)\n\t\tgoto out;\n\twhile (len--) {\n\t\tunsigned char c = *string++;\n\n\t\tif (c == '\\\\') {\n\t\t\tif (!len--)\n\t\t\t\tgoto out;\n\t\t\tc = *string++;\n\t\t\tif (c >= '0' && c <= '3') {\n\t\t\t\tunsigned char d;\n\t\t\t\tunsigned char e;\n\n\t\t\t\tif (!len-- || !len--)\n\t\t\t\t\tgoto out;\n\t\t\t\td = *string++;\n\t\t\t\te = *string++;\n\t\t\t\tif (d < '0' || d > '7' || e < '0' || e > '7')\n\t\t\t\t\tgoto out;\n\t\t\t\tc = tomoyo_make_byte(c, d, e);\n\t\t\t\tif (c <= ' ' || c >= 127)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tswitch (c) {\n\t\t\tcase '\\\\':   \n\t\t\tcase '+':    \n\t\t\tcase '?':    \n\t\t\tcase 'x':    \n\t\t\tcase 'a':    \n\t\t\tcase '-':    \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!recursion--)\n\t\t\t\tgoto out;\n\t\t\tswitch (c) {\n\t\t\tcase '*':    \n\t\t\tcase '@':    \n\t\t\tcase '$':    \n\t\t\tcase 'X':    \n\t\t\tcase 'A':    \n\t\t\t\tcontinue;\n\t\t\tcase '{':    \n\t\t\t\tif (string - 3 < start || *(string - 3) != '/')\n\t\t\t\t\tgoto out;\n\t\t\t\tin_repetition = true;\n\t\t\t\tcontinue;\n\t\t\tcase '}':    \n\t\t\t\tif (*string != '/')\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!in_repetition)\n\t\t\t\t\tgoto out;\n\t\t\t\tin_repetition = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (in_repetition && c == '/') {\n\t\t\tgoto out;\n\t\t} else if (c <= ' ' || c >= 127) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (in_repetition)\n\t\tgoto out;\n\treturn true;\n out:\n\treturn false;\n}\n\n \nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}\n\n \nstatic bool tomoyo_correct_path2(const char *filename, const size_t len)\n{\n\tconst char *cp1 = memchr(filename, '/', len);\n\tconst char *cp2 = memchr(filename, '.', len);\n\n\treturn cp1 && (!cp2 || (cp1 < cp2)) && tomoyo_correct_word2(filename, len);\n}\n\n \nbool tomoyo_correct_path(const char *filename)\n{\n\treturn tomoyo_correct_path2(filename, strlen(filename));\n}\n\n \nbool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (!tomoyo_correct_path2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}\n\n \nbool tomoyo_domain_def(const unsigned char *buffer)\n{\n\tconst unsigned char *cp;\n\tint len;\n\n\tif (*buffer != '<')\n\t\treturn false;\n\tcp = strchr(buffer, ' ');\n\tif (!cp)\n\t\tlen = strlen(buffer);\n\telse\n\t\tlen = cp - buffer;\n\tif (buffer[len - 1] != '>' ||\n\t    !tomoyo_correct_word2(buffer + 1, len - 2))\n\t\treturn false;\n\treturn true;\n}\n\n \nstruct tomoyo_domain_info *tomoyo_find_domain(const char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (!domain->is_deleted &&\n\t\t    !tomoyo_pathcmp(&name, domain->domainname))\n\t\t\treturn domain;\n\t}\n\treturn NULL;\n}\n\n \nstatic int tomoyo_const_part_length(const char *filename)\n{\n\tchar c;\n\tint len = 0;\n\n\tif (!filename)\n\t\treturn 0;\n\twhile ((c = *filename++) != '\\0') {\n\t\tif (c != '\\\\') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\t\tc = *filename++;\n\t\tswitch (c) {\n\t\tcase '\\\\':   \n\t\t\tlen += 2;\n\t\t\tcontinue;\n\t\tcase '0':    \n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\t\tc = *filename++;\n\t\t\tif (c < '0' || c > '7')\n\t\t\t\tbreak;\n\t\t\tc = *filename++;\n\t\t\tif (c < '0' || c > '7')\n\t\t\t\tbreak;\n\t\t\tlen += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn len;\n}\n\n \nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}\n\n \nstatic bool tomoyo_file_matches_pattern2(const char *filename,\n\t\t\t\t\t const char *filename_end,\n\t\t\t\t\t const char *pattern,\n\t\t\t\t\t const char *pattern_end)\n{\n\twhile (filename < filename_end && pattern < pattern_end) {\n\t\tchar c;\n\t\tint i;\n\t\tint j;\n\n\t\tif (*pattern != '\\\\') {\n\t\t\tif (*filename++ != *pattern++)\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tc = *filename;\n\t\tpattern++;\n\t\tswitch (*pattern) {\n\t\tcase '?':\n\t\t\tif (c == '/') {\n\t\t\t\treturn false;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (filename[1] == '\\\\')\n\t\t\t\t\tfilename++;\n\t\t\t\telse if (tomoyo_byte_range(filename + 1))\n\t\t\t\t\tfilename += 3;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (c != '\\\\')\n\t\t\t\treturn false;\n\t\t\tif (*++filename != '\\\\')\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tif (!isdigit(c))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (!isxdigit(c))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tif (!tomoyo_alphabet_char(c))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\t\tif (c == '\\\\' && tomoyo_byte_range(filename + 1)\n\t\t\t    && strncmp(filename + 1, pattern, 3) == 0) {\n\t\t\t\tfilename += 3;\n\t\t\t\tpattern += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn false;  \n\t\tcase '*':\n\t\tcase '@':\n\t\t\tfor (i = 0; i <= filename_end - filename; i++) {\n\t\t\t\tif (tomoyo_file_matches_pattern2(\n\t\t\t\t\t\t    filename + i, filename_end,\n\t\t\t\t\t\t    pattern + 1, pattern_end))\n\t\t\t\t\treturn true;\n\t\t\t\tc = filename[i];\n\t\t\t\tif (c == '.' && *pattern == '@')\n\t\t\t\t\tbreak;\n\t\t\t\tif (c != '\\\\')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (filename[i + 1] == '\\\\')\n\t\t\t\t\ti++;\n\t\t\t\telse if (tomoyo_byte_range(filename + i + 1))\n\t\t\t\t\ti += 3;\n\t\t\t\telse\n\t\t\t\t\tbreak;  \n\t\t\t}\n\t\t\treturn false;  \n\t\tdefault:\n\t\t\tj = 0;\n\t\t\tc = *pattern;\n\t\t\tif (c == '$') {\n\t\t\t\twhile (isdigit(filename[j]))\n\t\t\t\t\tj++;\n\t\t\t} else if (c == 'X') {\n\t\t\t\twhile (isxdigit(filename[j]))\n\t\t\t\t\tj++;\n\t\t\t} else if (c == 'A') {\n\t\t\t\twhile (tomoyo_alphabet_char(filename[j]))\n\t\t\t\t\tj++;\n\t\t\t}\n\t\t\tfor (i = 1; i <= j; i++) {\n\t\t\t\tif (tomoyo_file_matches_pattern2(\n\t\t\t\t\t\t    filename + i, filename_end,\n\t\t\t\t\t\t    pattern + 1, pattern_end))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;  \n\t\t}\n\t\tfilename++;\n\t\tpattern++;\n\t}\n\twhile (*pattern == '\\\\' &&\n\t       (*(pattern + 1) == '*' || *(pattern + 1) == '@'))\n\t\tpattern += 2;\n\treturn filename == filename_end && pattern == pattern_end;\n}\n\n \nstatic bool tomoyo_file_matches_pattern(const char *filename,\n\t\t\t\t\tconst char *filename_end,\n\t\t\t\t\tconst char *pattern,\n\t\t\t\t\tconst char *pattern_end)\n{\n\tconst char *pattern_start = pattern;\n\tbool first = true;\n\tbool result;\n\n\twhile (pattern < pattern_end - 1) {\n\t\t \n\t\tif (*pattern++ != '\\\\' || *pattern++ != '-')\n\t\t\tcontinue;\n\t\tresult = tomoyo_file_matches_pattern2(filename,\n\t\t\t\t\t\t      filename_end,\n\t\t\t\t\t\t      pattern_start,\n\t\t\t\t\t\t      pattern - 2);\n\t\tif (first)\n\t\t\tresult = !result;\n\t\tif (result)\n\t\t\treturn false;\n\t\tfirst = false;\n\t\tpattern_start = pattern;\n\t}\n\tresult = tomoyo_file_matches_pattern2(filename, filename_end,\n\t\t\t\t\t      pattern_start, pattern_end);\n\treturn first ? result : !result;\n}\n\n \nstatic bool tomoyo_path_matches_pattern2(const char *f, const char *p)\n{\n\tconst char *f_delimiter;\n\tconst char *p_delimiter;\n\n\twhile (*f && *p) {\n\t\tf_delimiter = strchr(f, '/');\n\t\tif (!f_delimiter)\n\t\t\tf_delimiter = f + strlen(f);\n\t\tp_delimiter = strchr(p, '/');\n\t\tif (!p_delimiter)\n\t\t\tp_delimiter = p + strlen(p);\n\t\tif (*p == '\\\\' && *(p + 1) == '{')\n\t\t\tgoto recursive;\n\t\tif (!tomoyo_file_matches_pattern(f, f_delimiter, p,\n\t\t\t\t\t\t p_delimiter))\n\t\t\treturn false;\n\t\tf = f_delimiter;\n\t\tif (*f)\n\t\t\tf++;\n\t\tp = p_delimiter;\n\t\tif (*p)\n\t\t\tp++;\n\t}\n\t \n\twhile (*p == '\\\\' &&\n\t       (*(p + 1) == '*' || *(p + 1) == '@'))\n\t\tp += 2;\n\treturn !*f && !*p;\n recursive:\n\t \n\tif (*(p - 1) != '/' || p_delimiter <= p + 3 || *p_delimiter != '/' ||\n\t    *(p_delimiter - 1) != '}' || *(p_delimiter - 2) != '\\\\')\n\t\treturn false;  \n\tdo {\n\t\t \n\t\tif (!tomoyo_file_matches_pattern(f, f_delimiter, p + 2,\n\t\t\t\t\t\t p_delimiter - 2))\n\t\t\tbreak;\n\t\t \n\t\tf = f_delimiter;\n\t\tif (!*f)\n\t\t\tbreak;\n\t\tf++;\n\t\t \n\t\tif (tomoyo_path_matches_pattern2(f, p_delimiter + 1))\n\t\t\treturn true;\n\t\tf_delimiter = strchr(f, '/');\n\t} while (f_delimiter);\n\treturn false;  \n}\n\n \nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t \n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t \n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t \n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}\n\n \nconst char *tomoyo_get_exe(void)\n{\n\tstruct file *exe_file;\n\tconst char *cp;\n\tstruct mm_struct *mm = current->mm;\n\n\tif (!mm)\n\t\treturn NULL;\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\treturn NULL;\n\n\tcp = tomoyo_realpath_from_path(&exe_file->f_path);\n\tfput(exe_file);\n\treturn cp;\n}\n\n \nint tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,\n\t\t    const u8 index)\n{\n\tu8 mode;\n\tstruct tomoyo_profile *p;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn TOMOYO_CONFIG_DISABLED;\n\tp = tomoyo_profile(ns, profile);\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[tomoyo_index2category[index]\n\t\t\t\t + TOMOYO_MAX_MAC_INDEX];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\treturn mode & 3;\n}\n\n \nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}\n\n \nbool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)\n{\n\tunsigned int count = 0;\n\tstruct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\n\tif (r->mode != TOMOYO_CONFIG_LEARNING)\n\t\treturn false;\n\tif (!domain)\n\t\treturn true;\n\tif (READ_ONCE(domain->flags[TOMOYO_DIF_QUOTA_WARNED]))\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &domain->acl_info_list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tu16 perm;\n\n\t\tif (ptr->is_deleted)\n\t\t\tcontinue;\n\t\t \n\t\tswitch (ptr->type) {\n\t\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_path_acl, head)->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_path2_acl, head)->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_path_number_acl, head)\n\t\t\t\t  ->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_mkdev_acl, head)->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_INET_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_inet_acl, head)->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t\tperm = data_race(container_of(ptr, struct tomoyo_unix_acl, head)->perm);\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t\tperm = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tperm = 1;\n\t\t}\n\t\tcount += hweight16(perm);\n\t}\n\tif (count < tomoyo_profile(domain->ns, domain->profile)->\n\t    pref[TOMOYO_PREF_MAX_LEARNING_ENTRY])\n\t\treturn true;\n\tWRITE_ONCE(domain->flags[TOMOYO_DIF_QUOTA_WARNED], true);\n\t \n\ttomoyo_write_log(r, \"%s\", tomoyo_dif[TOMOYO_DIF_QUOTA_WARNED]);\n#ifndef CONFIG_SECURITY_TOMOYO_INSECURE_BUILTIN_SETTING\n\tpr_warn(\"WARNING: Domain '%s' has too many ACLs to hold. Stopped learning mode.\\n\",\n\t\tdomain->domainname->name);\n#endif\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}