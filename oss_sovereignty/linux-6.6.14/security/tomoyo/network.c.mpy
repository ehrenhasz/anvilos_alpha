{
  "module_name": "network.c",
  "hash_id": "d79c74499132a5f71b426f91cfc08039a13f12892df5c3917d23545d132c4f95",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/network.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/slab.h>\n\n \nstruct tomoyo_inet_addr_info {\n\t__be16 port;            \n\tconst __be32 *address;  \n\tbool is_ipv6;\n};\n\n \nstruct tomoyo_unix_addr_info {\n\tu8 *addr;  \n\tunsigned int addr_len;\n};\n\n \nstruct tomoyo_addr_info {\n\tu8 protocol;\n\tu8 operation;\n\tstruct tomoyo_inet_addr_info inet;\n\tstruct tomoyo_unix_addr_info unix0;\n};\n\n \nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \",  \n\t[4] = \" \",  \n};\n\n \nbool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}\n\n \nstatic void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}\n\n \nvoid tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}\n\n \nstatic const u8 tomoyo_inet2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_SEND,\n\t},\n\t[SOCK_RAW]    = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_RAW_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_RAW_SEND,\n\t},\n};\n\n \nstatic const u8 tomoyo_unix2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND,\n\t},\n\t[SOCK_SEQPACKET] = {\n\t\t[TOMOYO_NETWORK_BIND]    =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,\n\t},\n};\n\n \nstatic bool tomoyo_same_inet_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_inet_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_inet_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_ipaddr_union(&p1->address, &p2->address) &&\n\t\ttomoyo_same_number_union(&p1->port, &p2->port);\n}\n\n \nstatic bool tomoyo_same_unix_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_unix_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_unix_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_name_union(&p1->name, &p2->name);\n}\n\n \nstatic bool tomoyo_merge_inet_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_inet_acl, head)->perm;\n\tu8 perm = READ_ONCE(*a_perm);\n\tconst u8 b_perm = container_of(b, struct tomoyo_inet_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nstatic bool tomoyo_merge_unix_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_unix_acl, head)->perm;\n\tu8 perm = READ_ONCE(*a_perm);\n\tconst u8 b_perm = container_of(b, struct tomoyo_unix_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\tWRITE_ONCE(*a_perm, perm);\n\treturn !perm;\n}\n\n \nint tomoyo_write_inet_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_inet_acl e = { .head.type = TOMOYO_TYPE_INET_ACL };\n\tint error = -EINVAL;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\te.address.group =\n\t\t\ttomoyo_get_group(param, TOMOYO_ADDRESS_GROUP);\n\t\tif (!e.address.group)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t}\n\tif (!tomoyo_parse_number_union(param, &e.port) ||\n\t    e.port.values[1] > 65535)\n\t\tgoto out;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_inet_acl,\n\t\t\t\t     tomoyo_merge_inet_acl);\nout:\n\ttomoyo_put_group(e.address.group);\n\ttomoyo_put_number_union(&e.port);\n\treturn error;\n}\n\n \nint tomoyo_write_unix_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_unix_acl e = { .head.type = TOMOYO_TYPE_UNIX_ACL };\n\tint error;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (!tomoyo_parse_name_union(param, &e.name))\n\t\treturn -EINVAL;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_unix_acl,\n\t\t\t\t     tomoyo_merge_unix_acl);\n\ttomoyo_put_name_union(&e.name);\n\treturn error;\n}\n\n \nstatic int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}\n\n \nstatic int tomoyo_audit_inet_log(struct tomoyo_request_info *r)\n{\n\tchar buf[128];\n\tint len;\n\tconst __be32 *address = r->param.inet_network.address;\n\n\tif (r->param.inet_network.is_ipv6)\n\t\ttomoyo_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)\n\t\t\t\t  address, (const struct in6_addr *) address);\n\telse\n\t\ttomoyo_print_ipv4(buf, sizeof(buf), address, address);\n\tlen = strlen(buf);\n\tsnprintf(buf + len, sizeof(buf) - len, \" %u\",\n\t\t r->param.inet_network.port);\n\treturn tomoyo_audit_net_log(r, \"inet\", r->param.inet_network.protocol,\n\t\t\t\t    r->param.inet_network.operation, buf);\n}\n\n \nstatic int tomoyo_audit_unix_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_audit_net_log(r, \"unix\", r->param.unix_network.protocol,\n\t\t\t\t    r->param.unix_network.operation,\n\t\t\t\t    r->param.unix_network.address->name);\n}\n\n \nstatic bool tomoyo_check_inet_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_inet_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\tconst u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;\n\n\tif (!(acl->perm & (1 << r->param.inet_network.operation)) ||\n\t    !tomoyo_compare_number_union(r->param.inet_network.port,\n\t\t\t\t\t &acl->port))\n\t\treturn false;\n\tif (acl->address.group)\n\t\treturn tomoyo_address_matches_group\n\t\t\t(r->param.inet_network.is_ipv6,\n\t\t\t r->param.inet_network.address, acl->address.group);\n\treturn acl->address.is_ipv6 == r->param.inet_network.is_ipv6 &&\n\t\tmemcmp(&acl->address.ip[0],\n\t\t       r->param.inet_network.address, size) <= 0 &&\n\t\tmemcmp(r->param.inet_network.address,\n\t\t       &acl->address.ip[1], size) <= 0;\n}\n\n \nstatic bool tomoyo_check_unix_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_unix_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.unix_network.operation)) &&\n\t\ttomoyo_compare_name_union(r->param.unix_network.address,\n\t\t\t\t\t  &acl->name);\n}\n\n \nstatic int tomoyo_inet_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_inet2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tr.param_type = TOMOYO_TYPE_INET_ACL;\n\t\tr.param.inet_network.protocol = address->protocol;\n\t\tr.param.inet_network.operation = address->operation;\n\t\tr.param.inet_network.is_ipv6 = address->inet.is_ipv6;\n\t\tr.param.inet_network.address = address->inet.address;\n\t\tr.param.inet_network.port = ntohs(address->inet.port);\n\t\tdo {\n\t\t\ttomoyo_check_acl(&r, tomoyo_check_inet_acl);\n\t\t\terror = tomoyo_audit_inet_log(&r);\n\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}\n\n \nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tif (addr_len < offsetofend(struct sockaddr, sa_family))\n\t\treturn 0;\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}\n\n \nstatic int tomoyo_unix_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_unix2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tchar *buf = address->unix0.addr;\n\t\tint len = address->unix0.addr_len - sizeof(sa_family_t);\n\n\t\tif (len <= 0) {\n\t\t\tbuf = \"anonymous\";\n\t\t\tlen = 9;\n\t\t} else if (buf[0]) {\n\t\t\tlen = strnlen(buf, len);\n\t\t}\n\t\tbuf = tomoyo_encode2(buf, len);\n\t\tif (buf) {\n\t\t\tstruct tomoyo_path_info addr;\n\n\t\t\taddr.name = buf;\n\t\t\ttomoyo_fill_path_info(&addr);\n\t\t\tr.param_type = TOMOYO_TYPE_UNIX_ACL;\n\t\t\tr.param.unix_network.protocol = address->protocol;\n\t\t\tr.param.unix_network.operation = address->operation;\n\t\t\tr.param.unix_network.address = &addr;\n\t\t\tdo {\n\t\t\t\ttomoyo_check_acl(&r, tomoyo_check_unix_acl);\n\t\t\t\terror = tomoyo_audit_unix_log(&r);\n\t\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t\t\tkfree(buf);\n\t\t} else\n\t\t\terror = -ENOMEM;\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}\n\n \nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr_len < offsetofend(struct sockaddr, sa_family))\n\t\treturn 0;\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}\n\n \nstatic bool tomoyo_kernel_service(void)\n{\n\t \n\treturn current->flags & PF_KTHREAD;\n}\n\n \nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nint tomoyo_socket_listen_permission(struct socket *sock)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\tstruct sockaddr_storage addr;\n\tint addr_len;\n\n\tif (!family || (type != SOCK_STREAM && type != SOCK_SEQPACKET))\n\t\treturn 0;\n\t{\n\t\tconst int error = sock->ops->getname(sock, (struct sockaddr *)\n\t\t\t\t\t\t     &addr, 0);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\taddr_len = error;\n\t}\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_LISTEN;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *) &addr,\n\t\t\t\t\t\t addr_len, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) &addr, addr_len,\n\t\t\t\t\t 0, &address);\n}\n\n \nint tomoyo_socket_connect_permission(struct socket *sock,\n\t\t\t\t     struct sockaddr *addr, int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\taddress.protocol = type;\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\t\taddress.operation = TOMOYO_NETWORK_SEND;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\taddress.operation = TOMOYO_NETWORK_CONNECT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}\n\n \nint tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t  int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\tcase SOCK_SEQPACKET:\n\t\taddress.protocol = type;\n\t\taddress.operation = TOMOYO_NETWORK_BIND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}\n\n \nint tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int size)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!msg->msg_name || !family ||\n\t    (type != SOCK_DGRAM && type != SOCK_RAW))\n\t\treturn 0;\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_SEND;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name,\n\t\t\t\t\t\t msg->msg_namelen, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) msg->msg_name,\n\t\t\t\t\t msg->msg_namelen,\n\t\t\t\t\t sock->sk->sk_protocol, &address);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}