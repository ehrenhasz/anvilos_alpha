{
  "module_name": "gc.c",
  "hash_id": "41a8307fd6267902c51a3ef9098021ab79e98af01a1027e2d15c1d87c7c362ba",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/gc.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/kthread.h>\n#include <linux/slab.h>\n\n \nstatic inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}\n\n \nstatic LIST_HEAD(tomoyo_io_buffer_list);\n \nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\n \nstatic bool tomoyo_struct_used_by_io_buffer(const struct list_head *element)\n{\n\tstruct tomoyo_io_buffer *head;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tif (head->r.domain == element || head->r.group == element ||\n\t\t    head->r.acl == element || &head->w.domain->list == element)\n\t\t\tin_use = true;\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}\n\n \nstatic bool tomoyo_name_used_by_io_buffer(const char *string)\n{\n\tstruct tomoyo_io_buffer *head;\n\tconst size_t size = strlen(string) + 1;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\tint i;\n\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tfor (i = 0; i < TOMOYO_MAX_IO_READ_QUEUE; i++) {\n\t\t\tconst char *w = head->r.w[i];\n\n\t\t\tif (w < string || w > string + size)\n\t\t\t\tcontinue;\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}\n\n \nstatic inline void tomoyo_del_transition_control(struct list_head *element)\n{\n\tstruct tomoyo_transition_control *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\n\ttomoyo_put_name(ptr->domainname);\n\ttomoyo_put_name(ptr->program);\n}\n\n \nstatic inline void tomoyo_del_aggregator(struct list_head *element)\n{\n\tstruct tomoyo_aggregator *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\n\ttomoyo_put_name(ptr->original_name);\n\ttomoyo_put_name(ptr->aggregated_name);\n}\n\n \nstatic inline void tomoyo_del_manager(struct list_head *element)\n{\n\tstruct tomoyo_manager *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\n\ttomoyo_put_name(ptr->manager);\n}\n\n \nstatic void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic inline void tomoyo_del_domain(struct list_head *element)\n{\n\tstruct tomoyo_domain_info *domain =\n\t\tcontainer_of(element, typeof(*domain), list);\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\n\t \n\tlist_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {\n\t\ttomoyo_del_acl(&acl->list);\n\t\ttomoyo_memory_free(acl);\n\t}\n\ttomoyo_put_name(domain->domainname);\n}\n\n \nvoid tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}\n\n \nstatic inline void tomoyo_del_name(struct list_head *element)\n{\n\t \n}\n\n \nstatic inline void tomoyo_del_path_group(struct list_head *element)\n{\n\tstruct tomoyo_path_group *member =\n\t\tcontainer_of(element, typeof(*member), head.list);\n\n\ttomoyo_put_name(member->member_name);\n}\n\n \nstatic inline void tomoyo_del_group(struct list_head *element)\n{\n\tstruct tomoyo_group *group =\n\t\tcontainer_of(element, typeof(*group), head.list);\n\n\ttomoyo_put_name(group->group_name);\n}\n\n \nstatic inline void tomoyo_del_address_group(struct list_head *element)\n{\n\t \n}\n\n \nstatic inline void tomoyo_del_number_group(struct list_head *element)\n{\n\t \n}\n\n \nstatic void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t \n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t \n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t \n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t \n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t \n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}\n\n \nstatic void tomoyo_collect_member(const enum tomoyo_policy_id id,\n\t\t\t\t  struct list_head *member_list)\n{\n\tstruct tomoyo_acl_head *member;\n\tstruct tomoyo_acl_head *tmp;\n\n\tlist_for_each_entry_safe(member, tmp, member_list, list) {\n\t\tif (!member->is_deleted)\n\t\t\tcontinue;\n\t\tmember->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(id, &member->list);\n\t}\n}\n\n \nstatic void tomoyo_collect_acl(struct list_head *list)\n{\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\n\tlist_for_each_entry_safe(acl, tmp, list, list) {\n\t\tif (!acl->is_deleted)\n\t\t\tcontinue;\n\t\tacl->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(TOMOYO_ID_ACL, &acl->list);\n\t}\n}\n\n \nstatic void tomoyo_collect_entry(void)\n{\n\tint i;\n\tenum tomoyo_policy_id id;\n\tstruct tomoyo_policy_namespace *ns;\n\n\tmutex_lock(&tomoyo_policy_lock);\n\t{\n\t\tstruct tomoyo_domain_info *domain;\n\t\tstruct tomoyo_domain_info *tmp;\n\n\t\tlist_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,\n\t\t\t\t\t list) {\n\t\t\ttomoyo_collect_acl(&domain->acl_info_list);\n\t\t\tif (!domain->is_deleted || atomic_read(&domain->users))\n\t\t\t\tcontinue;\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (id = 0; id < TOMOYO_MAX_POLICY; id++)\n\t\t\ttomoyo_collect_member(id, &ns->policy_list[id]);\n\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\ttomoyo_collect_acl(&ns->acl_group[i]);\n\t}\n\t{\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\n\t\tlist_for_each_entry_safe(ptr, tmp, &tomoyo_condition_list,\n\t\t\t\t\t list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_CONDITION, &ptr->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++) {\n\t\t\tstruct list_head *list = &ns->group_list[i];\n\t\t\tstruct tomoyo_group *group;\n\t\t\tstruct tomoyo_group *tmp;\n\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tid = TOMOYO_ID_PATH_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = TOMOYO_ID_NUMBER_GROUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = TOMOYO_ID_ADDRESS_GROUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(group, tmp, list, head.list) {\n\t\t\t\ttomoyo_collect_member(id, &group->member_list);\n\t\t\t\tif (!list_empty(&group->member_list) ||\n\t\t\t\t    atomic_read(&group->head.users) > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tatomic_set(&group->head.users,\n\t\t\t\t\t   TOMOYO_GC_IN_PROGRESS);\n\t\t\t\ttomoyo_try_to_gc(TOMOYO_ID_GROUP,\n\t\t\t\t\t\t &group->head.list);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_HASH; i++) {\n\t\tstruct list_head *list = &tomoyo_name_list[i];\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\n\t\tlist_for_each_entry_safe(ptr, tmp, list, list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_NAME, &ptr->list);\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n}\n\n \nstatic int tomoyo_gc_thread(void *unused)\n{\n\t \n\tstatic DEFINE_MUTEX(tomoyo_gc_mutex);\n\n\tif (!mutex_trylock(&tomoyo_gc_mutex))\n\t\tgoto out;\n\ttomoyo_collect_entry();\n\t{\n\t\tstruct tomoyo_io_buffer *head;\n\t\tstruct tomoyo_io_buffer *tmp;\n\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\tlist_for_each_entry_safe(head, tmp, &tomoyo_io_buffer_list,\n\t\t\t\t\t list) {\n\t\t\tif (head->users)\n\t\t\t\tcontinue;\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t}\n\tmutex_unlock(&tomoyo_gc_mutex);\nout:\n\t \n\treturn 0;\n}\n\n \nvoid tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}