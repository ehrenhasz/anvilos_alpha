{
  "module_name": "domain.c",
  "hash_id": "8480bd4d91972519ccf603eeb47829d09abace72139f5cf8b1c201da288b4de0",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/domain.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n \n\n \nstruct tomoyo_domain_info tomoyo_kernel_domain;\n\n \nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate)(const struct tomoyo_acl_head\n\t\t\t\t\t\t *,\n\t\t\t\t\t\t const struct tomoyo_acl_head\n\t\t\t\t\t\t *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}\n\n \nstatic inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\treturn a->type == b->type && a->cond == b->cond;\n}\n\n \nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate)(const struct tomoyo_acl_info\n\t\t\t\t\t\t *,\n\t\t\t\t\t\t const struct tomoyo_acl_info\n\t\t\t\t\t\t *),\n\t\t\t bool (*merge_duplicate)(struct tomoyo_acl_info *,\n\t\t\t\t\t\t struct tomoyo_acl_info *,\n\t\t\t\t\t\t const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}\n\n \nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry)(struct tomoyo_request_info *,\n\t\t\t\t\t  const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tconst struct list_head *list = &domain->acl_info_list;\n\tu16 i = 0;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tfor (; i < TOMOYO_MAX_ACL_GROUPS; i++) {\n\t\tif (!test_bit(i, domain->group))\n\t\t\tcontinue;\n\t\tlist = &domain->ns->acl_group[i++];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}\n\n \nLIST_HEAD(tomoyo_domain_list);\n\n \nstatic const char *tomoyo_last_word(const char *name)\n{\n\tconst char *cp = strrchr(name, ' ');\n\n\tif (cp)\n\t\treturn cp + 1;\n\treturn name;\n}\n\n \nstatic bool tomoyo_same_transition_control(const struct tomoyo_acl_head *a,\n\t\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_transition_control *p1 = container_of(a,\n\t\t\t\t\t\t\t\t  typeof(*p1),\n\t\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_transition_control *p2 = container_of(b,\n\t\t\t\t\t\t\t\t  typeof(*p2),\n\t\t\t\t\t\t\t\t  head);\n\n\treturn p1->type == p2->type && p1->is_last_name == p2->is_last_name\n\t\t&& p1->domainname == p2->domainname\n\t\t&& p1->program == p2->program;\n}\n\n \nint tomoyo_write_transition_control(struct tomoyo_acl_param *param,\n\t\t\t\t    const u8 type)\n{\n\tstruct tomoyo_transition_control e = { .type = type };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tchar *program = param->data;\n\tchar *domainname = strstr(program, \" from \");\n\n\tif (domainname) {\n\t\t*domainname = '\\0';\n\t\tdomainname += 6;\n\t} else if (type == TOMOYO_TRANSITION_CONTROL_NO_KEEP ||\n\t\t   type == TOMOYO_TRANSITION_CONTROL_KEEP) {\n\t\tdomainname = program;\n\t\tprogram = NULL;\n\t}\n\tif (program && strcmp(program, \"any\")) {\n\t\tif (!tomoyo_correct_path(program))\n\t\t\treturn -EINVAL;\n\t\te.program = tomoyo_get_name(program);\n\t\tif (!e.program)\n\t\t\tgoto out;\n\t}\n\tif (domainname && strcmp(domainname, \"any\")) {\n\t\tif (!tomoyo_correct_domain(domainname)) {\n\t\t\tif (!tomoyo_correct_path(domainname))\n\t\t\t\tgoto out;\n\t\t\te.is_last_name = true;\n\t\t}\n\t\te.domainname = tomoyo_get_name(domainname);\n\t\tif (!e.domainname)\n\t\t\tgoto out;\n\t}\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_transition_control);\nout:\n\ttomoyo_put_name(e.domainname);\n\ttomoyo_put_name(e.program);\n\treturn error;\n}\n\n \nstatic inline bool tomoyo_scan_transition\n(const struct list_head *list, const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program, const char *last_name,\n const enum tomoyo_transition_type type)\n{\n\tconst struct tomoyo_transition_control *ptr;\n\n\tlist_for_each_entry_rcu(ptr, list, head.list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (ptr->head.is_deleted || ptr->type != type)\n\t\t\tcontinue;\n\t\tif (ptr->domainname) {\n\t\t\tif (!ptr->is_last_name) {\n\t\t\t\tif (ptr->domainname != domainname)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (strcmp(ptr->domainname->name, last_name))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ptr->program && tomoyo_pathcmp(ptr->program, program))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic enum tomoyo_transition_type tomoyo_transition_type\n(const struct tomoyo_policy_namespace *ns,\n const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program)\n{\n\tconst char *last_name = tomoyo_last_word(domainname->name);\n\tenum tomoyo_transition_type type = TOMOYO_TRANSITION_CONTROL_NO_RESET;\n\n\twhile (type < TOMOYO_MAX_TRANSITION_TYPE) {\n\t\tconst struct list_head * const list =\n\t\t\t&ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\n\t\tif (!tomoyo_scan_transition(list, domainname, program,\n\t\t\t\t\t    last_name, type)) {\n\t\t\ttype++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type != TOMOYO_TRANSITION_CONTROL_NO_RESET &&\n\t\t    type != TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE)\n\t\t\tbreak;\n\t\t \n\t\ttype++;\n\t\ttype++;\n\t}\n\treturn type;\n}\n\n \nstatic bool tomoyo_same_aggregator(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_aggregator *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_aggregator *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t  head);\n\n\treturn p1->original_name == p2->original_name &&\n\t\tp1->aggregated_name == p2->aggregated_name;\n}\n\n \nint tomoyo_write_aggregator(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_aggregator e = { };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tconst char *original_name = tomoyo_read_token(param);\n\tconst char *aggregated_name = tomoyo_read_token(param);\n\n\tif (!tomoyo_correct_word(original_name) ||\n\t    !tomoyo_correct_path(aggregated_name))\n\t\treturn -EINVAL;\n\te.original_name = tomoyo_get_name(original_name);\n\te.aggregated_name = tomoyo_get_name(aggregated_name);\n\tif (!e.original_name || !e.aggregated_name ||\n\t    e.aggregated_name->is_patterned)  \n\t\tgoto out;\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_aggregator);\nout:\n\ttomoyo_put_name(e.original_name);\n\ttomoyo_put_name(e.aggregated_name);\n\treturn error;\n}\n\n \nstatic struct tomoyo_policy_namespace *tomoyo_find_namespace\n(const char *name, const unsigned int len)\n{\n\tstruct tomoyo_policy_namespace *ns;\n\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tif (strncmp(name, ns->name, len) ||\n\t\t    (name[len] && name[len] != ' '))\n\t\t\tcontinue;\n\t\treturn ns;\n\t}\n\treturn NULL;\n}\n\n \nstruct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS | __GFP_NOWARN);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}\n\n \nstatic bool tomoyo_namespace_jump(const char *domainname)\n{\n\tconst char *namespace = tomoyo_current_namespace()->name;\n\tconst int len = strlen(namespace);\n\n\treturn strncmp(domainname, namespace, len) ||\n\t\t(domainname[len] && domainname[len] != ' ');\n}\n\n \nstruct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t \n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t \n\t \n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t \n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t \n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\n\t\te.profile = domain->profile;\n\t\tmemcpy(e.group, domain->group, sizeof(e.group));\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\tint i;\n\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\t\tif (test_bit(i, entry->group))\n\t\t\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\",\n\t\t\t\t\t\t\t i);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}\n\n \nstatic int tomoyo_environ(struct tomoyo_execve *ee)\n{\n\tstruct tomoyo_request_info *r = &ee->r;\n\tstruct linux_binprm *bprm = ee->bprm;\n\t \n\tstruct tomoyo_page_dump env_page = { };\n\tchar *arg_ptr;  \n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tint error = -ENOMEM;\n\n\tee->r.type = TOMOYO_MAC_ENVIRON;\n\tee->r.profile = r->domain->profile;\n\tee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,\n\t\t\t\t     TOMOYO_MAC_ENVIRON);\n\tif (!r->mode || !envp_count)\n\t\treturn 0;\n\targ_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!arg_ptr)\n\t\tgoto out;\n\twhile (error == -ENOMEM) {\n\t\tif (!tomoyo_dump_page(bprm, pos, &env_page))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t \n\t\twhile (argv_count && offset < PAGE_SIZE) {\n\t\t\tif (!env_page.data[offset++])\n\t\t\t\targv_count--;\n\t\t}\n\t\tif (argv_count) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst unsigned char c = env_page.data[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '=') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\0';\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++]\n\t\t\t\t\t\t= ((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (tomoyo_env_perm(r, arg_ptr)) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!--envp_count) {\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t}\nout:\n\tif (r->mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\tkfree(env_page.data);\n\tkfree(arg_ptr);\n\treturn error;\n}\n\n \nint tomoyo_find_next_domain(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *old_domain = tomoyo_domain();\n\tstruct tomoyo_domain_info *domain = NULL;\n\tconst char *original_name = bprm->filename;\n\tint retval = -ENOMEM;\n\tbool reject_on_transition_failure = false;\n\tconst struct tomoyo_path_info *candidate;\n\tstruct tomoyo_path_info exename;\n\tstruct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);\n\n\tif (!ee)\n\t\treturn -ENOMEM;\n\tee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!ee->tmp) {\n\t\tkfree(ee);\n\t\treturn -ENOMEM;\n\t}\n\t \n\ttomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\tee->r.ee = ee;\n\tee->bprm = bprm;\n\tee->r.obj = &ee->obj;\n\tee->obj.path1 = bprm->file->f_path;\n\t \n\tretval = -ENOENT;\n\texename.name = tomoyo_realpath_nofollow(original_name);\n\tif (!exename.name)\n\t\tgoto out;\n\ttomoyo_fill_path_info(&exename);\nretry:\n\t \n\t{\n\t\tstruct tomoyo_aggregator *ptr;\n\t\tstruct list_head *list =\n\t\t\t&old_domain->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\n\t\t \n\t\tcandidate = &exename;\n\t\tlist_for_each_entry_rcu(ptr, list, head.list,\n\t\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\t\tif (ptr->head.is_deleted ||\n\t\t\t    !tomoyo_path_matches_pattern(&exename,\n\t\t\t\t\t\t\t ptr->original_name))\n\t\t\t\tcontinue;\n\t\t\tcandidate = ptr->aggregated_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tretval = tomoyo_execute_permission(&ee->r, candidate);\n\tif (retval == TOMOYO_RETRY_REQUEST)\n\t\tgoto retry;\n\tif (retval < 0)\n\t\tgoto out;\n\t \n\tif (ee->r.param.path.matched_path)\n\t\tcandidate = ee->r.param.path.matched_path;\n\n\t \n\tif (ee->transition) {\n\t\tconst char *domainname = ee->transition->name;\n\n\t\treject_on_transition_failure = true;\n\t\tif (!strcmp(domainname, \"keep\"))\n\t\t\tgoto force_keep_domain;\n\t\tif (!strcmp(domainname, \"child\"))\n\t\t\tgoto force_child_domain;\n\t\tif (!strcmp(domainname, \"reset\"))\n\t\t\tgoto force_reset_domain;\n\t\tif (!strcmp(domainname, \"initialize\"))\n\t\t\tgoto force_initialize_domain;\n\t\tif (!strcmp(domainname, \"parent\")) {\n\t\t\tchar *cp;\n\n\t\t\tstrscpy(ee->tmp, old_domain->domainname->name, TOMOYO_EXEC_TMPSIZE);\n\t\t\tcp = strrchr(ee->tmp, ' ');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\t\t} else if (*domainname == '<')\n\t\t\tstrscpy(ee->tmp, domainname, TOMOYO_EXEC_TMPSIZE);\n\t\telse\n\t\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t\t old_domain->domainname->name, domainname);\n\t\tgoto force_jump_domain;\n\t}\n\t \n\tswitch (tomoyo_transition_type(old_domain->ns, old_domain->domainname,\n\t\t\t\t       candidate)) {\n\tcase TOMOYO_TRANSITION_CONTROL_RESET:\nforce_reset_domain:\n\t\t \n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"<%s>\",\n\t\t\t candidate->name);\n\t\t \n\t\treject_on_transition_failure = true;\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_INITIALIZE:\nforce_initialize_domain:\n\t\t \n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->ns->name, candidate->name);\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_KEEP:\nforce_keep_domain:\n\t\t \n\t\tdomain = old_domain;\n\t\tbreak;\n\tdefault:\n\t\tif (old_domain == &tomoyo_kernel_domain &&\n\t\t    !tomoyo_policy_loaded) {\n\t\t\t \n\t\t\tdomain = old_domain;\n\t\t\tbreak;\n\t\t}\nforce_child_domain:\n\t\t \n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->domainname->name, candidate->name);\n\t\tbreak;\n\t}\nforce_jump_domain:\n\tif (!domain)\n\t\tdomain = tomoyo_assign_domain(ee->tmp, true);\n\tif (domain)\n\t\tretval = 0;\n\telse if (reject_on_transition_failure) {\n\t\tpr_warn(\"ERROR: Domain '%s' not ready.\\n\", ee->tmp);\n\t\tretval = -ENOMEM;\n\t} else if (ee->r.mode == TOMOYO_CONFIG_ENFORCING)\n\t\tretval = -ENOMEM;\n\telse {\n\t\tretval = 0;\n\t\tif (!old_domain->flags[TOMOYO_DIF_TRANSITION_FAILED]) {\n\t\t\told_domain->flags[TOMOYO_DIF_TRANSITION_FAILED] = true;\n\t\t\tee->r.granted = false;\n\t\t\ttomoyo_write_log(&ee->r, \"%s\", tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]);\n\t\t\tpr_warn(\"ERROR: Domain '%s' not defined.\\n\", ee->tmp);\n\t\t}\n\t}\n out:\n\tif (!domain)\n\t\tdomain = old_domain;\n\t \n\t{\n\t\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\t\ts->old_domain_info = s->domain_info;\n\t\ts->domain_info = domain;\n\t\tatomic_inc(&domain->users);\n\t}\n\tkfree(exename.name);\n\tif (!retval) {\n\t\tee->r.domain = domain;\n\t\tretval = tomoyo_environ(ee);\n\t}\n\tkfree(ee->tmp);\n\tkfree(ee->dump.data);\n\tkfree(ee);\n\treturn retval;\n}\n\n \nbool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n#ifdef CONFIG_MMU\n\tint ret;\n#endif\n\n\t \n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t \n#ifdef CONFIG_MMU\n\t \n\tmmap_read_lock(bprm->mm);\n\tret = get_user_pages_remote(bprm->mm, pos, 1,\n\t\t\t\t    FOLL_FORCE, &page, NULL);\n\tmmap_read_unlock(bprm->mm);\n\tif (ret <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t \n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t \n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}