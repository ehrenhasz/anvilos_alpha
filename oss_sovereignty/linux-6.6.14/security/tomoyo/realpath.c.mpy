{
  "module_name": "realpath.c",
  "hash_id": "735d6b54dd09278bc92ece7e7782b5061c7d2be957139675216b69bb8c7597c4",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/realpath.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/magic.h>\n#include <linux/proc_fs.h>\n\n \nchar *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t \n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}\n\n \nchar *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}\n\n \nstatic char *tomoyo_get_absolute_path(const struct path *path, char * const buffer,\n\t\t\t\t      const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\n\tif (buflen >= 256) {\n\t\t \n\t\tpos = d_absolute_path(path, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(path->dentry);\n\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}\n\n \nstatic char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}\n\n \nstatic char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t   const int buflen)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\n\n\tif (IS_ERR(pos))\n\t\treturn pos;\n\t \n\tif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\n\t\tchar *ep;\n\t\tconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\n\t\tstruct pid_namespace *proc_pidns = proc_pid_ns(sb);\n\n\t\tif (*ep == '/' && pid && pid ==\n\t\t    task_tgid_nr_ns(current, proc_pidns)) {\n\t\t\tpos = ep - 5;\n\t\t\tif (pos < buffer)\n\t\t\t\tgoto out;\n\t\t\tmemmove(pos, \"/self\", 5);\n\t\t}\n\t\tgoto prepend_filesystem_name;\n\t}\n\t \n\tif (!MAJOR(sb->s_dev))\n\t\tgoto prepend_filesystem_name;\n\t{\n\t\tstruct inode *inode = d_backing_inode(sb->s_root);\n\n\t\t \n\t\tif (!inode->i_op->rename)\n\t\t\tgoto prepend_filesystem_name;\n\t}\n\t \n\t{\n\t\tchar name[64];\n\t\tint name_len;\n\t\tconst dev_t dev = sb->s_dev;\n\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tsnprintf(name, sizeof(name) - 1, \"dev(%u,%u):\", MAJOR(dev),\n\t\t\t MINOR(dev));\n\t\tname_len = strlen(name);\n\t\tpos -= name_len;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\treturn pos;\n\t}\n\t \nprepend_filesystem_name:\n\t{\n\t\tconst char *name = sb->s_type->name;\n\t\tconst int name_len = strlen(name);\n\n\t\tpos -= name_len + 1;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\tpos[name_len] = ':';\n\t}\n\treturn pos;\nout:\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb = dentry->d_sb;\n\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t \n\t\tbuf[buf_len - 1] = '\\0';\n\t\t \n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t \n\t\tif ((!inode->i_op->rename &&\n\t\t     !(sb->s_type->fs_flags & FS_REQUIRES_DEV)))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t \n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t \n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}\n\n \nchar *tomoyo_realpath_nofollow(const char *pathname)\n{\n\tstruct path path;\n\n\tif (pathname && kern_path(pathname, 0, &path) == 0) {\n\t\tchar *buf = tomoyo_realpath_from_path(&path);\n\n\t\tpath_put(&path);\n\t\treturn buf;\n\t}\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}