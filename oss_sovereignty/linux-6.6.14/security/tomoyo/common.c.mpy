{
  "module_name": "common.c",
  "hash_id": "56f77144ca9ebae6739e3d6a5088a17d3b8adcb33430042ca51811bfbbb6c5f3",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/common.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/string_helpers.h>\n#include \"common.h\"\n\n \nconst char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};\n\n \nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t \n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t \n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t \n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t \n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\n\n \nconst char * const tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {\n\t[TOMOYO_TASK_UID]             = \"task.uid\",\n\t[TOMOYO_TASK_EUID]            = \"task.euid\",\n\t[TOMOYO_TASK_SUID]            = \"task.suid\",\n\t[TOMOYO_TASK_FSUID]           = \"task.fsuid\",\n\t[TOMOYO_TASK_GID]             = \"task.gid\",\n\t[TOMOYO_TASK_EGID]            = \"task.egid\",\n\t[TOMOYO_TASK_SGID]            = \"task.sgid\",\n\t[TOMOYO_TASK_FSGID]           = \"task.fsgid\",\n\t[TOMOYO_TASK_PID]             = \"task.pid\",\n\t[TOMOYO_TASK_PPID]            = \"task.ppid\",\n\t[TOMOYO_EXEC_ARGC]            = \"exec.argc\",\n\t[TOMOYO_EXEC_ENVC]            = \"exec.envc\",\n\t[TOMOYO_TYPE_IS_SOCKET]       = \"socket\",\n\t[TOMOYO_TYPE_IS_SYMLINK]      = \"symlink\",\n\t[TOMOYO_TYPE_IS_FILE]         = \"file\",\n\t[TOMOYO_TYPE_IS_BLOCK_DEV]    = \"block\",\n\t[TOMOYO_TYPE_IS_DIRECTORY]    = \"directory\",\n\t[TOMOYO_TYPE_IS_CHAR_DEV]     = \"char\",\n\t[TOMOYO_TYPE_IS_FIFO]         = \"fifo\",\n\t[TOMOYO_MODE_SETUID]          = \"setuid\",\n\t[TOMOYO_MODE_SETGID]          = \"setgid\",\n\t[TOMOYO_MODE_STICKY]          = \"sticky\",\n\t[TOMOYO_MODE_OWNER_READ]      = \"owner_read\",\n\t[TOMOYO_MODE_OWNER_WRITE]     = \"owner_write\",\n\t[TOMOYO_MODE_OWNER_EXECUTE]   = \"owner_execute\",\n\t[TOMOYO_MODE_GROUP_READ]      = \"group_read\",\n\t[TOMOYO_MODE_GROUP_WRITE]     = \"group_write\",\n\t[TOMOYO_MODE_GROUP_EXECUTE]   = \"group_execute\",\n\t[TOMOYO_MODE_OTHERS_READ]     = \"others_read\",\n\t[TOMOYO_MODE_OTHERS_WRITE]    = \"others_write\",\n\t[TOMOYO_MODE_OTHERS_EXECUTE]  = \"others_execute\",\n\t[TOMOYO_EXEC_REALPATH]        = \"exec.realpath\",\n\t[TOMOYO_SYMLINK_TARGET]       = \"symlink.target\",\n\t[TOMOYO_PATH1_UID]            = \"path1.uid\",\n\t[TOMOYO_PATH1_GID]            = \"path1.gid\",\n\t[TOMOYO_PATH1_INO]            = \"path1.ino\",\n\t[TOMOYO_PATH1_MAJOR]          = \"path1.major\",\n\t[TOMOYO_PATH1_MINOR]          = \"path1.minor\",\n\t[TOMOYO_PATH1_PERM]           = \"path1.perm\",\n\t[TOMOYO_PATH1_TYPE]           = \"path1.type\",\n\t[TOMOYO_PATH1_DEV_MAJOR]      = \"path1.dev_major\",\n\t[TOMOYO_PATH1_DEV_MINOR]      = \"path1.dev_minor\",\n\t[TOMOYO_PATH2_UID]            = \"path2.uid\",\n\t[TOMOYO_PATH2_GID]            = \"path2.gid\",\n\t[TOMOYO_PATH2_INO]            = \"path2.ino\",\n\t[TOMOYO_PATH2_MAJOR]          = \"path2.major\",\n\t[TOMOYO_PATH2_MINOR]          = \"path2.minor\",\n\t[TOMOYO_PATH2_PERM]           = \"path2.perm\",\n\t[TOMOYO_PATH2_TYPE]           = \"path2.type\",\n\t[TOMOYO_PATH2_DEV_MAJOR]      = \"path2.dev_major\",\n\t[TOMOYO_PATH2_DEV_MINOR]      = \"path2.dev_minor\",\n\t[TOMOYO_PATH1_PARENT_UID]     = \"path1.parent.uid\",\n\t[TOMOYO_PATH1_PARENT_GID]     = \"path1.parent.gid\",\n\t[TOMOYO_PATH1_PARENT_INO]     = \"path1.parent.ino\",\n\t[TOMOYO_PATH1_PARENT_PERM]    = \"path1.parent.perm\",\n\t[TOMOYO_PATH2_PARENT_UID]     = \"path2.parent.uid\",\n\t[TOMOYO_PATH2_PARENT_GID]     = \"path2.parent.gid\",\n\t[TOMOYO_PATH2_PARENT_INO]     = \"path2.parent.ino\",\n\t[TOMOYO_PATH2_PARENT_PERM]    = \"path2.parent.perm\",\n};\n\n \nstatic const char * const tomoyo_pref_keywords[TOMOYO_MAX_PREF] = {\n\t[TOMOYO_PREF_MAX_AUDIT_LOG]      = \"max_audit_log\",\n\t[TOMOYO_PREF_MAX_LEARNING_ENTRY] = \"max_learning_entry\",\n};\n\n \nconst char * const tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = \"execute\",\n\t[TOMOYO_TYPE_READ]       = \"read\",\n\t[TOMOYO_TYPE_WRITE]      = \"write\",\n\t[TOMOYO_TYPE_APPEND]     = \"append\",\n\t[TOMOYO_TYPE_UNLINK]     = \"unlink\",\n\t[TOMOYO_TYPE_GETATTR]    = \"getattr\",\n\t[TOMOYO_TYPE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_TYPE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_TYPE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_TYPE_CHROOT]     = \"chroot\",\n\t[TOMOYO_TYPE_UMOUNT]     = \"unmount\",\n};\n\n \nconst char * const tomoyo_socket_keyword[TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[TOMOYO_NETWORK_BIND]    = \"bind\",\n\t[TOMOYO_NETWORK_LISTEN]  = \"listen\",\n\t[TOMOYO_NETWORK_CONNECT] = \"connect\",\n\t[TOMOYO_NETWORK_SEND]    = \"send\",\n};\n\n \nstatic const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};\n\n \nstatic bool tomoyo_manage_by_non_root;\n\n \n\n \n__printf(3, 4)\nstatic void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}\n\n \nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t \n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}\n\n \nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...) __printf(2, 3);\n\n \nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}\n\n \nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}\n\n \nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}\n\n \nstatic void tomoyo_set_slash(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"/\");\n}\n\n \nLIST_HEAD(tomoyo_namespace_list);\n \nstatic bool tomoyo_namespace_enabled;\n\n \nvoid tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20150505;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}\n\n \nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}\n\n \nstatic void tomoyo_print_name_union(struct tomoyo_io_buffer *head,\n\t\t\t\t    const struct tomoyo_name_union *ptr)\n{\n\ttomoyo_set_space(head);\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t}\n}\n\n \nstatic void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}\n\n \nstatic void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}\n\n \nstatic void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}\n\n \nstatic struct tomoyo_profile *tomoyo_assign_profile\n(struct tomoyo_policy_namespace *ns, const unsigned int profile)\n{\n\tstruct tomoyo_profile *ptr;\n\tstruct tomoyo_profile *entry;\n\n\tif (profile >= TOMOYO_MAX_PROFILES)\n\t\treturn NULL;\n\tptr = ns->profile_ptr[profile];\n\tif (ptr)\n\t\treturn ptr;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS | __GFP_NOWARN);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = ns->profile_ptr[profile];\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tptr = entry;\n\t\tptr->default_config = TOMOYO_CONFIG_DISABLED |\n\t\t\tTOMOYO_CONFIG_WANT_GRANT_LOG |\n\t\t\tTOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\tmemset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,\n\t\t       sizeof(ptr->config));\n\t\tptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;\n\t\tptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;\n\t\tmb();  \n\t\tns->profile_ptr[profile] = ptr;\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n out:\n\tkfree(entry);\n\treturn ptr;\n}\n\n \nstruct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,\n\t\t\t\t      const u8 profile)\n{\n\tstatic struct tomoyo_profile tomoyo_null_profile;\n\tstruct tomoyo_profile *ptr = ns->profile_ptr[profile];\n\n\tif (!ptr)\n\t\tptr = &tomoyo_null_profile;\n\treturn ptr;\n}\n\n \nstatic s8 tomoyo_find_yesno(const char *string, const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\n\tif (cp) {\n\t\tcp += strlen(find);\n\t\tif (!strncmp(cp, \"=yes\", 4))\n\t\t\treturn 1;\n\t\telse if (!strncmp(cp, \"=no\", 3))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n \nstatic void tomoyo_set_uint(unsigned int *i, const char *string,\n\t\t\t    const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\n\tif (cp)\n\t\tsscanf(cp + strlen(find), \"=%u\", i);\n}\n\n \nstatic int tomoyo_set_mode(char *name, const char *value,\n\t\t\t   struct tomoyo_profile *profile)\n{\n\tu8 i;\n\tu8 config;\n\n\tif (!strcmp(name, \"CONFIG\")) {\n\t\ti = TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX;\n\t\tconfig = profile->default_config;\n\t} else if (tomoyo_str_starts(&name, \"CONFIG::\")) {\n\t\tconfig = 0;\n\t\tfor (i = 0; i < TOMOYO_MAX_MAC_INDEX\n\t\t\t     + TOMOYO_MAX_MAC_CATEGORY_INDEX; i++) {\n\t\t\tint len = 0;\n\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX) {\n\t\t\t\tconst u8 c = tomoyo_index2category[i];\n\t\t\t\tconst char *category =\n\t\t\t\t\ttomoyo_category_keywords[c];\n\n\t\t\t\tlen = strlen(category);\n\t\t\t\tif (strncmp(name, category, len) ||\n\t\t\t\t    name[len++] != ':' || name[len++] != ':')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(name + len, tomoyo_mac_keywords[i]))\n\t\t\t\tcontinue;\n\t\t\tconfig = profile->config[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (i == TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (strstr(value, \"use_default\")) {\n\t\tconfig = TOMOYO_CONFIG_USE_DEFAULT;\n\t} else {\n\t\tu8 mode;\n\n\t\tfor (mode = 0; mode < 4; mode++)\n\t\t\tif (strstr(value, tomoyo_mode[mode]))\n\t\t\t\t \n\t\t\t\tconfig = (config & ~7) | mode;\n\t\tif (config != TOMOYO_CONFIG_USE_DEFAULT) {\n\t\t\tswitch (tomoyo_find_yesno(value, \"grant_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (tomoyo_find_yesno(value, \"reject_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\tprofile->config[i] = config;\n\telse if (config != TOMOYO_CONFIG_USE_DEFAULT)\n\t\tprofile->default_config = config;\n\treturn 0;\n}\n\n \nstatic int tomoyo_write_profile(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tunsigned int i;\n\tchar *cp;\n\tstruct tomoyo_profile *profile;\n\n\tif (sscanf(data, \"PROFILE_VERSION=%u\", &head->w.ns->profile_version)\n\t    == 1)\n\t\treturn 0;\n\ti = simple_strtoul(data, &cp, 10);\n\tif (*cp != '-')\n\t\treturn -EINVAL;\n\tdata = cp + 1;\n\tprofile = tomoyo_assign_profile(head->w.ns, i);\n\tif (!profile)\n\t\treturn -EINVAL;\n\tcp = strchr(data, '=');\n\tif (!cp)\n\t\treturn -EINVAL;\n\t*cp++ = '\\0';\n\tif (!strcmp(data, \"COMMENT\")) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tconst struct tomoyo_path_info *new_comment\n\t\t\t= tomoyo_get_name(cp);\n\t\tconst struct tomoyo_path_info *old_comment;\n\n\t\tif (!new_comment)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock(&lock);\n\t\told_comment = profile->comment;\n\t\tprofile->comment = new_comment;\n\t\tspin_unlock(&lock);\n\t\ttomoyo_put_name(old_comment);\n\t\treturn 0;\n\t}\n\tif (!strcmp(data, \"PREFERENCE\")) {\n\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\ttomoyo_set_uint(&profile->pref[i], cp,\n\t\t\t\t\ttomoyo_pref_keywords[i]);\n\t\treturn 0;\n\t}\n\treturn tomoyo_set_mode(data, cp, profile);\n}\n\n \nstatic void tomoyo_print_config(struct tomoyo_io_buffer *head, const u8 config)\n{\n\ttomoyo_io_printf(head, \"={ mode=%s grant_log=%s reject_log=%s }\\n\",\n\t\t\t tomoyo_mode[config & 3],\n\t\t\t str_yes_no(config & TOMOYO_CONFIG_WANT_GRANT_LOG),\n\t\t\t str_yes_no(config & TOMOYO_CONFIG_WANT_REJECT_LOG));\n}\n\n \nstatic void tomoyo_read_profile(struct tomoyo_io_buffer *head)\n{\n\tu8 index;\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tconst struct tomoyo_profile *profile;\n\n\tif (head->r.eof)\n\t\treturn;\n next:\n\tindex = head->r.index;\n\tprofile = ns->profile_ptr[index];\n\tswitch (head->r.step) {\n\tcase 0:\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"PROFILE_VERSION=%u\\n\",\n\t\t\t\t ns->profile_version);\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 1:\n\t\tfor ( ; head->r.index < TOMOYO_MAX_PROFILES;\n\t\t      head->r.index++)\n\t\t\tif (ns->profile_ptr[head->r.index])\n\t\t\t\tbreak;\n\t\tif (head->r.index == TOMOYO_MAX_PROFILES) {\n\t\t\thead->r.eof = true;\n\t\t\treturn;\n\t\t}\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 2:\n\t\t{\n\t\t\tu8 i;\n\t\t\tconst struct tomoyo_path_info *comment =\n\t\t\t\tprofile->comment;\n\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-COMMENT=\", index);\n\t\t\ttomoyo_set_string(head, comment ? comment->name : \"\");\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-PREFERENCE={ \", index);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\t\ttomoyo_io_printf(head, \"%s=%u \",\n\t\t\t\t\t\t tomoyo_pref_keywords[i],\n\t\t\t\t\t\t profile->pref[i]);\n\t\t\ttomoyo_set_string(head, \"}\\n\");\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\t{\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-%s\", index, \"CONFIG\");\n\t\t\ttomoyo_print_config(head, profile->default_config);\n\t\t\thead->r.bit = 0;\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfor ( ; head->r.bit < TOMOYO_MAX_MAC_INDEX\n\t\t\t      + TOMOYO_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {\n\t\t\tconst u8 i = head->r.bit;\n\t\t\tconst u8 config = profile->config[i];\n\n\t\t\tif (config == TOMOYO_CONFIG_USE_DEFAULT)\n\t\t\t\tcontinue;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX)\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s::%s\",\n\t\t\t\t\t\t index,\n\t\t\t\t\t\t tomoyo_category_keywords\n\t\t\t\t\t\t [tomoyo_index2category[i]],\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\telse\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s\", index,\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\ttomoyo_print_config(head, config);\n\t\t\thead->r.bit++;\n\t\t\tbreak;\n\t\t}\n\t\tif (head->r.bit == TOMOYO_MAX_MAC_INDEX\n\t\t    + TOMOYO_MAX_MAC_CATEGORY_INDEX) {\n\t\t\thead->r.index++;\n\t\t\thead->r.step = 1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (tomoyo_flush(head))\n\t\tgoto next;\n}\n\n \nstatic bool tomoyo_same_manager(const struct tomoyo_acl_head *a,\n\t\t\t\tconst struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_manager, head)->manager ==\n\t\tcontainer_of(b, struct tomoyo_manager, head)->manager;\n}\n\n \nstatic int tomoyo_update_manager_entry(const char *manager,\n\t\t\t\t       const bool is_delete)\n{\n\tstruct tomoyo_manager e = { };\n\tstruct tomoyo_acl_param param = {\n\t\t \n\t\t.is_delete = is_delete,\n\t\t.list = &tomoyo_kernel_namespace.policy_list[TOMOYO_ID_MANAGER],\n\t};\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\n\tif (!tomoyo_correct_domain(manager) &&\n\t    !tomoyo_correct_word(manager))\n\t\treturn -EINVAL;\n\te.manager = tomoyo_get_name(manager);\n\tif (e.manager) {\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), &param,\n\t\t\t\t\t     tomoyo_same_manager);\n\t\ttomoyo_put_name(e.manager);\n\t}\n\treturn error;\n}\n\n \nstatic int tomoyo_write_manager(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\n\tif (!strcmp(data, \"manage_by_non_root\")) {\n\t\ttomoyo_manage_by_non_root = !head->w.is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_update_manager_entry(data, head->w.is_delete);\n}\n\n \nstatic void tomoyo_read_manager(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.acl, &tomoyo_kernel_namespace.policy_list[TOMOYO_ID_MANAGER]) {\n\t\tstruct tomoyo_manager *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), head.list);\n\n\t\tif (ptr->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn;\n\t\ttomoyo_set_string(head, ptr->manager->name);\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.eof = true;\n}\n\n \nstatic bool tomoyo_manager(void)\n{\n\tstruct tomoyo_manager *ptr;\n\tconst char *exe;\n\tconst struct task_struct *task = current;\n\tconst struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;\n\tbool found = IS_ENABLED(CONFIG_SECURITY_TOMOYO_INSECURE_BUILTIN_SETTING);\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn true;\n\tif (!tomoyo_manage_by_non_root &&\n\t    (!uid_eq(task->cred->uid,  GLOBAL_ROOT_UID) ||\n\t     !uid_eq(task->cred->euid, GLOBAL_ROOT_UID)))\n\t\treturn false;\n\texe = tomoyo_get_exe();\n\tif (!exe)\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &tomoyo_kernel_namespace.policy_list[TOMOYO_ID_MANAGER], head.list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (!ptr->head.is_deleted &&\n\t\t    (!tomoyo_pathcmp(domainname, ptr->manager) ||\n\t\t     !strcmp(exe, ptr->manager->name))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {  \n\t\tstatic pid_t last_pid;\n\t\tconst pid_t pid = current->pid;\n\n\t\tif (last_pid != pid) {\n\t\t\tpr_warn(\"%s ( %s ) is not permitted to update policies.\\n\",\n\t\t\t\tdomainname->name, exe);\n\t\t\tlast_pid = pid;\n\t\t}\n\t}\n\tkfree(exe);\n\treturn found;\n}\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\n\n \nstatic bool tomoyo_select_domain(struct tomoyo_io_buffer *head,\n\t\t\t\t const char *data)\n{\n\tunsigned int pid;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tbool global_pid = false;\n\n\tif (strncmp(data, \"select \", 7))\n\t\treturn false;\n\tdata += 7;\n\tif (sscanf(data, \"pid=%u\", &pid) == 1 ||\n\t    (global_pid = true, sscanf(data, \"global-pid=%u\", &pid) == 1)) {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tif (global_pid)\n\t\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\telse\n\t\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\tdomain = tomoyo_task(p)->domain_info;\n\t\trcu_read_unlock();\n\t} else if (!strncmp(data, \"domain=\", 7)) {\n\t\tif (tomoyo_domain_def(data + 7))\n\t\t\tdomain = tomoyo_find_domain(data + 7);\n\t} else if (sscanf(data, \"Q=%u\", &pid) == 1) {\n\t\tdomain = tomoyo_find_domain_by_qid(pid);\n\t} else\n\t\treturn false;\n\thead->w.domain = domain;\n\t \n\tif (!head->read_buf)\n\t\treturn true;  \n\tmemset(&head->r, 0, sizeof(head->r));\n\thead->r.print_this_domain_only = true;\n\tif (domain)\n\t\thead->r.domain = &domain->list;\n\telse\n\t\thead->r.eof = true;\n\ttomoyo_io_printf(head, \"# select %s\\n\", data);\n\tif (domain && domain->is_deleted)\n\t\ttomoyo_io_printf(head, \"# This is a deleted domain.\\n\");\n\treturn true;\n}\n\n \nstatic bool tomoyo_same_task_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_task_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_task_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->domainname == p2->domainname;\n}\n\n \nstatic int tomoyo_write_task(struct tomoyo_acl_param *param)\n{\n\tint error = -EINVAL;\n\n\tif (tomoyo_str_starts(&param->data, \"manual_domain_transition \")) {\n\t\tstruct tomoyo_task_acl e = {\n\t\t\t.head.type = TOMOYO_TYPE_MANUAL_TASK_ACL,\n\t\t\t.domainname = tomoyo_get_domainname(param),\n\t\t};\n\n\t\tif (e.domainname)\n\t\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t\t     tomoyo_same_task_acl,\n\t\t\t\t\t\t     NULL);\n\t\ttomoyo_put_name(e.domainname);\n\t}\n\treturn error;\n}\n\n \nstatic int tomoyo_delete_domain(char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -EINTR;\n\t \n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\t \n\t\tif (domain == &tomoyo_kernel_domain)\n\t\t\tcontinue;\n\t\tif (domain->is_deleted ||\n\t\t    tomoyo_pathcmp(domain->domainname, &name))\n\t\t\tcontinue;\n\t\tdomain->is_deleted = true;\n\t\tbreak;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn 0;\n}\n\n \nstatic int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write)(struct tomoyo_acl_param *param);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}\n\n \nconst char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS] = {\n\t[TOMOYO_DIF_QUOTA_WARNED]      = \"quota_exceeded\\n\",\n\t[TOMOYO_DIF_TRANSITION_FAILED] = \"transition_failed\\n\",\n};\n\n \nstatic int tomoyo_write_domain(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct tomoyo_policy_namespace *ns;\n\tstruct tomoyo_domain_info *domain = head->w.domain;\n\tconst bool is_delete = head->w.is_delete;\n\tbool is_select = !is_delete && tomoyo_str_starts(&data, \"select \");\n\tunsigned int idx;\n\n\tif (*data == '<') {\n\t\tint ret = 0;\n\n\t\tdomain = NULL;\n\t\tif (is_delete)\n\t\t\tret = tomoyo_delete_domain(data);\n\t\telse if (is_select)\n\t\t\tdomain = tomoyo_find_domain(data);\n\t\telse\n\t\t\tdomain = tomoyo_assign_domain(data, false);\n\t\thead->w.domain = domain;\n\t\treturn ret;\n\t}\n\tif (!domain)\n\t\treturn -EINVAL;\n\tns = domain->ns;\n\tif (sscanf(data, \"use_profile %u\", &idx) == 1\n\t    && idx < TOMOYO_MAX_PROFILES) {\n\t\tif (!tomoyo_policy_loaded || ns->profile_ptr[idx])\n\t\t\tif (!is_delete)\n\t\t\t\tdomain->profile = (u8) idx;\n\t\treturn 0;\n\t}\n\tif (sscanf(data, \"use_group %u\\n\", &idx) == 1\n\t    && idx < TOMOYO_MAX_ACL_GROUPS) {\n\t\tif (!is_delete)\n\t\t\tset_bit(idx, domain->group);\n\t\telse\n\t\t\tclear_bit(idx, domain->group);\n\t\treturn 0;\n\t}\n\tfor (idx = 0; idx < TOMOYO_MAX_DOMAIN_INFO_FLAGS; idx++) {\n\t\tconst char *cp = tomoyo_dif[idx];\n\n\t\tif (strncmp(data, cp, strlen(cp) - 1))\n\t\t\tcontinue;\n\t\tdomain->flags[idx] = !is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_write_domain2(ns, &domain->acl_info_list, data,\n\t\t\t\t    is_delete);\n}\n\n \nstatic bool tomoyo_print_condition(struct tomoyo_io_buffer *head,\n\t\t\t\t   const struct tomoyo_condition *cond)\n{\n\tswitch (head->r.cond_step) {\n\tcase 0:\n\t\thead->r.cond_index = 0;\n\t\thead->r.cond_step++;\n\t\tif (cond->transit) {\n\t\t\ttomoyo_set_space(head);\n\t\t\ttomoyo_set_string(head, cond->transit->name);\n\t\t}\n\t\tfallthrough;\n\tcase 1:\n\t\t{\n\t\t\tconst u16 condc = cond->condc;\n\t\t\tconst struct tomoyo_condition_element *condp =\n\t\t\t\t(typeof(condp)) (cond + 1);\n\t\t\tconst struct tomoyo_number_union *numbers_p =\n\t\t\t\t(typeof(numbers_p)) (condp + condc);\n\t\t\tconst struct tomoyo_name_union *names_p =\n\t\t\t\t(typeof(names_p))\n\t\t\t\t(numbers_p + cond->numbers_count);\n\t\t\tconst struct tomoyo_argv *argv =\n\t\t\t\t(typeof(argv)) (names_p + cond->names_count);\n\t\t\tconst struct tomoyo_envp *envp =\n\t\t\t\t(typeof(envp)) (argv + cond->argc);\n\t\t\tu16 skip;\n\n\t\t\tfor (skip = 0; skip < head->r.cond_index; skip++) {\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\n\t\t\t\tcondp++;\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\tnames_p++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (head->r.cond_index < condc) {\n\t\t\t\tconst u8 match = condp->equals;\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn false;\n\t\t\t\tcondp++;\n\t\t\t\thead->r.cond_index++;\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\ttomoyo_io_printf(head,\n\t\t\t\t\t\t\t \"exec.argv[%lu]%s=\\\"\",\n\t\t\t\t\t\t\t argv->index, argv->is_not ? \"!\" : \"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  argv->value->name);\n\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  \"exec.envp[\\\"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  envp->name->name);\n\t\t\t\t\ttomoyo_io_printf(head, \"\\\"]%s=\", envp->is_not ? \"!\" : \"\");\n\t\t\t\t\tif (envp->value) {\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t\ttomoyo_set_string(head, envp->value->name);\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t\t  \"NULL\");\n\t\t\t\t\t}\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       tomoyo_condition_keyword[left]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttomoyo_set_string(head, match ? \"=\" : \"!=\");\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\ttomoyo_print_name_union_quoted\n\t\t\t\t\t\t(head, names_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t  tomoyo_condition_keyword[right]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thead->r.cond_step++;\n\t\tfallthrough;\n\tcase 2:\n\t\tif (!tomoyo_flush(head))\n\t\t\tbreak;\n\t\thead->r.cond_step++;\n\t\tfallthrough;\n\tcase 3:\n\t\tif (cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\ttomoyo_io_printf(head, \" grant_log=%s\",\n\t\t\t\t\t str_yes_no(cond->grant_log ==\n\t\t\t\t\t\t    TOMOYO_GRANTLOG_YES));\n\t\ttomoyo_set_lf(head);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void tomoyo_set_group(struct tomoyo_io_buffer *head,\n\t\t\t     const char *category)\n{\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY) {\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"acl_group %u \",\n\t\t\t\t head->r.acl_group_index);\n\t}\n\ttomoyo_set_string(head, category);\n}\n\n \nstatic bool tomoyo_print_entry(struct tomoyo_io_buffer *head,\n\t\t\t       struct tomoyo_acl_info *acl)\n{\n\tconst u8 acl_type = acl->type;\n\tbool first = true;\n\tu8 bit;\n\n\tif (head->r.print_cond_part)\n\t\tgoto print_cond_part;\n\tif (acl->is_deleted)\n\t\treturn true;\n\tif (!tomoyo_flush(head))\n\t\treturn false;\n\telse if (acl_type == TOMOYO_TYPE_PATH_ACL) {\n\t\tstruct tomoyo_path_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u16 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (head->r.print_transition_related_only &&\n\t\t\t    bit != TOMOYO_TYPE_EXECUTE)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_path_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MANUAL_TASK_ACL) {\n\t\tstruct tomoyo_task_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"task \");\n\t\ttomoyo_set_string(head, \"manual_domain_transition \");\n\t\ttomoyo_set_string(head, ptr->domainname->name);\n\t} else if (head->r.print_transition_related_only) {\n\t\treturn true;\n\t} else if (acl_type == TOMOYO_TYPE_PATH2_ACL) {\n\t\tstruct tomoyo_path2_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH2_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pp2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name1);\n\t\ttomoyo_print_name_union(head, &ptr->name2);\n\t} else if (acl_type == TOMOYO_TYPE_PATH_NUMBER_ACL) {\n\t\tstruct tomoyo_path_number_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_NUMBER_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->number);\n\t} else if (acl_type == TOMOYO_TYPE_MKDEV_ACL) {\n\t\tstruct tomoyo_mkdev_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_MKDEV_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pnnn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->mode);\n\t\ttomoyo_print_number_union(head, &ptr->major);\n\t\ttomoyo_print_number_union(head, &ptr->minor);\n\t} else if (acl_type == TOMOYO_TYPE_INET_ACL) {\n\t\tstruct tomoyo_inet_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network inet \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_set_space(head);\n\t\tif (ptr->address.group) {\n\t\t\ttomoyo_set_string(head, \"@\");\n\t\t\ttomoyo_set_string(head, ptr->address.group->group_name\n\t\t\t\t\t  ->name);\n\t\t} else {\n\t\t\tchar buf[128];\n\n\t\t\ttomoyo_print_ip(buf, sizeof(buf), &ptr->address);\n\t\t\ttomoyo_io_printf(head, \"%s\", buf);\n\t\t}\n\t\ttomoyo_print_number_union(head, &ptr->port);\n\t} else if (acl_type == TOMOYO_TYPE_UNIX_ACL) {\n\t\tstruct tomoyo_unix_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network unix \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MOUNT_ACL) {\n\t\tstruct tomoyo_mount_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"file mount\");\n\t\ttomoyo_print_name_union(head, &ptr->dev_name);\n\t\ttomoyo_print_name_union(head, &ptr->dir_name);\n\t\ttomoyo_print_name_union(head, &ptr->fs_type);\n\t\ttomoyo_print_number_union(head, &ptr->flags);\n\t} else if (acl_type == TOMOYO_TYPE_ENV_ACL) {\n\t\tstruct tomoyo_env_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"misc env \");\n\t\ttomoyo_set_string(head, ptr->env->name);\n\t}\n\tif (acl->cond) {\n\t\thead->r.print_cond_part = true;\n\t\thead->r.cond_step = 0;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\nprint_cond_part:\n\t\tif (!tomoyo_print_condition(head, acl->cond))\n\t\t\treturn false;\n\t\thead->r.print_cond_part = false;\n\t} else {\n\t\ttomoyo_set_lf(head);\n\t}\n\treturn true;\n}\n\n \nstatic bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}\n\n \nstatic void tomoyo_read_domain(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.domain, &tomoyo_domain_list) {\n\t\tstruct tomoyo_domain_info *domain =\n\t\t\tlist_entry(head->r.domain, typeof(*domain), list);\n\t\tu8 i;\n\n\t\tswitch (head->r.step) {\n\t\tcase 0:\n\t\t\tif (domain->is_deleted &&\n\t\t\t    !head->r.print_this_domain_only)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\ttomoyo_set_string(head, domain->domainname->name);\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_io_printf(head, \"use_profile %u\\n\",\n\t\t\t\t\t domain->profile);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_DOMAIN_INFO_FLAGS; i++)\n\t\t\t\tif (domain->flags[i])\n\t\t\t\t\ttomoyo_set_string(head, tomoyo_dif[i]);\n\t\t\thead->r.index = 0;\n\t\t\thead->r.step++;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\twhile (head->r.index < TOMOYO_MAX_ACL_GROUPS) {\n\t\t\t\ti = head->r.index++;\n\t\t\t\tif (!test_bit(i, domain->group))\n\t\t\t\t\tcontinue;\n\t\t\t\ttomoyo_io_printf(head, \"use_group %u\\n\", i);\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\thead->r.index = 0;\n\t\t\thead->r.step++;\n\t\t\ttomoyo_set_lf(head);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tif (!tomoyo_read_domain2(head, &domain->acl_info_list))\n\t\t\t\treturn;\n\t\t\thead->r.step++;\n\t\t\tif (!tomoyo_set_lf(head))\n\t\t\t\treturn;\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\thead->r.step = 0;\n\t\t\tif (head->r.print_this_domain_only)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n done:\n\thead->r.eof = true;\n}\n\n \nstatic int tomoyo_write_pid(struct tomoyo_io_buffer *head)\n{\n\thead->r.eof = false;\n\treturn 0;\n}\n\n \nstatic void tomoyo_read_pid(struct tomoyo_io_buffer *head)\n{\n\tchar *buf = head->write_buf;\n\tbool global_pid = false;\n\tunsigned int pid;\n\tstruct task_struct *p;\n\tstruct tomoyo_domain_info *domain = NULL;\n\n\t \n\tif (!buf) {\n\t\thead->r.eof = true;\n\t\treturn;  \n\t}\n\tif (head->r.w_pos || head->r.eof)\n\t\treturn;\n\thead->r.eof = true;\n\tif (tomoyo_str_starts(&buf, \"global-pid \"))\n\t\tglobal_pid = true;\n\tif (kstrtouint(buf, 10, &pid))\n\t\treturn;\n\trcu_read_lock();\n\tif (global_pid)\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\telse\n\t\tp = find_task_by_vpid(pid);\n\tif (p)\n\t\tdomain = tomoyo_task(p)->domain_info;\n\trcu_read_unlock();\n\tif (!domain)\n\t\treturn;\n\ttomoyo_io_printf(head, \"%u %u \", pid, domain->profile);\n\ttomoyo_set_string(head, domain->domainname->name);\n}\n\n \nstatic const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};\n\n \nstatic const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};\n\n \nstatic int tomoyo_write_exception(struct tomoyo_io_buffer *head)\n{\n\tconst bool is_delete = head->w.is_delete;\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = head->w.ns,\n\t\t.is_delete = is_delete,\n\t\t.data = head->write_buf,\n\t};\n\tu8 i;\n\n\tif (tomoyo_str_starts(&param.data, \"aggregator \"))\n\t\treturn tomoyo_write_aggregator(&param);\n\tfor (i = 0; i < TOMOYO_MAX_TRANSITION_TYPE; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_transition_type[i]))\n\t\t\treturn tomoyo_write_transition_control(&param, i);\n\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_group_name[i]))\n\t\t\treturn tomoyo_write_group(&param, i);\n\tif (tomoyo_str_starts(&param.data, \"acl_group \")) {\n\t\tunsigned int group;\n\t\tchar *data;\n\n\t\tgroup = simple_strtoul(param.data, &data, 10);\n\t\tif (group < TOMOYO_MAX_ACL_GROUPS && *data++ == ' ')\n\t\t\treturn tomoyo_write_domain2\n\t\t\t\t(head->w.ns, &head->w.ns->acl_group[group],\n\t\t\t\t data, is_delete);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->group_list[idx];\n\n\tlist_for_each_cookie(head->r.group, list) {\n\t\tstruct tomoyo_group *group =\n\t\t\tlist_entry(head->r.group, typeof(*group), head.list);\n\n\t\tlist_for_each_cookie(head->r.acl, &group->member_list) {\n\t\t\tstruct tomoyo_acl_head *ptr =\n\t\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\n\t\t\tif (ptr->is_deleted)\n\t\t\t\tcontinue;\n\t\t\tif (!tomoyo_flush(head))\n\t\t\t\treturn false;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_set_string(head, tomoyo_group_name[idx]);\n\t\t\ttomoyo_set_string(head, group->group_name->name);\n\t\t\tif (idx == TOMOYO_PATH_GROUP) {\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head, container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name);\n\t\t\t} else if (idx == TOMOYO_NUMBER_GROUP) {\n\t\t\t\ttomoyo_print_number_union(head, &container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number);\n\t\t\t} else if (idx == TOMOYO_ADDRESS_GROUP) {\n\t\t\t\tchar buffer[128];\n\t\t\t\tstruct tomoyo_address_group *member =\n\t\t\t\t\tcontainer_of(ptr, typeof(*member),\n\t\t\t\t\t\t     head);\n\n\t\t\t\ttomoyo_print_ip(buffer, sizeof(buffer),\n\t\t\t\t\t\t&member->address);\n\t\t\t\ttomoyo_io_printf(head, \" %s\", buffer);\n\t\t\t}\n\t\t\ttomoyo_set_lf(head);\n\t\t}\n\t\thead->r.acl = NULL;\n\t}\n\thead->r.group = NULL;\n\treturn true;\n}\n\n \nstatic bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->policy_list[idx];\n\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_head *acl =\n\t\t\tcontainer_of(head->r.acl, typeof(*acl), list);\n\t\tif (acl->is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\n\t\tswitch (idx) {\n\t\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\t\t{\n\t\t\t\tstruct tomoyo_transition_control *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, tomoyo_transition_type\n\t\t\t\t\t\t  [ptr->type]);\n\t\t\t\ttomoyo_set_string(head, ptr->program ?\n\t\t\t\t\t\t  ptr->program->name : \"any\");\n\t\t\t\ttomoyo_set_string(head, \" from \");\n\t\t\t\ttomoyo_set_string(head, ptr->domainname ?\n\t\t\t\t\t\t  ptr->domainname->name :\n\t\t\t\t\t\t  \"any\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TOMOYO_ID_AGGREGATOR:\n\t\t\t{\n\t\t\t\tstruct tomoyo_aggregator *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, \"aggregator \");\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t  ptr->original_name->name);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       ptr->aggregated_name->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}\n\n \nstatic void tomoyo_read_exception(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\n\tif (head->r.eof)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY &&\n\t       tomoyo_read_policy(head, head->r.step))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP &&\n\t       tomoyo_read_group(head, head->r.step - TOMOYO_MAX_POLICY))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP\n\t       + TOMOYO_MAX_ACL_GROUPS) {\n\t\thead->r.acl_group_index = head->r.step - TOMOYO_MAX_POLICY\n\t\t\t- TOMOYO_MAX_GROUP;\n\t\tif (!tomoyo_read_domain2(head, &ns->acl_group\n\t\t\t\t\t [head->r.acl_group_index]))\n\t\t\treturn;\n\t\thead->r.step++;\n\t}\n\thead->r.eof = true;\n}\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\n \nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\n\n \nstruct tomoyo_query {\n\tstruct list_head list;\n\tstruct tomoyo_domain_info *domain;\n\tchar *query;\n\tsize_t query_len;\n\tunsigned int serial;\n\tu8 timer;\n\tu8 answer;\n\tu8 retry;\n};\n\n \nstatic LIST_HEAD(tomoyo_query_list);\n\n \nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\n \nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\n \nstatic int tomoyo_truncate(char *str)\n{\n\tchar *start = str;\n\n\twhile (*(unsigned char *) str > (unsigned char) ' ')\n\t\tstr++;\n\t*str = '\\0';\n\treturn strlen(start) + 1;\n}\n\n \nstatic void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)\n{\n\tchar *buffer;\n\tchar *realpath = NULL;\n\tchar *argv0 = NULL;\n\tchar *symlink = NULL;\n\tchar *cp = strchr(header, '\\n');\n\tint len;\n\n\tif (!cp)\n\t\treturn;\n\tcp = strchr(cp + 1, '\\n');\n\tif (!cp)\n\t\treturn;\n\t*cp++ = '\\0';\n\tlen = strlen(cp) + 1;\n\t \n\tif (*cp == 'f') {\n\t\targv0 = strstr(header, \" argv[]={ \\\"\");\n\t\tif (argv0) {\n\t\t\targv0 += 10;\n\t\t\tlen += tomoyo_truncate(argv0) + 14;\n\t\t}\n\t\trealpath = strstr(header, \" exec={ realpath=\\\"\");\n\t\tif (realpath) {\n\t\t\trealpath += 8;\n\t\t\tlen += tomoyo_truncate(realpath) + 6;\n\t\t}\n\t\tsymlink = strstr(header, \" symlink.target=\\\"\");\n\t\tif (symlink)\n\t\t\tlen += tomoyo_truncate(symlink + 1) + 1;\n\t}\n\tbuffer = kmalloc(len, GFP_NOFS);\n\tif (!buffer)\n\t\treturn;\n\tsnprintf(buffer, len - 1, \"%s\", cp);\n\tif (realpath)\n\t\ttomoyo_addprintf(buffer, len, \" exec.%s\", realpath);\n\tif (argv0)\n\t\ttomoyo_addprintf(buffer, len, \" exec.argv[0]=%s\", argv0);\n\tif (symlink)\n\t\ttomoyo_addprintf(buffer, len, \"%s\", symlink);\n\ttomoyo_normalize_line(buffer);\n\tif (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,\n\t\t\t\t  false))\n\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\tkfree(buffer);\n}\n\n \nint tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(NULL, 0, fmt, args) + 1;\n\tva_end(args);\n\t \n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t \n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t \n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n\t \n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = kmalloc_size_roundup(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t \n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3:  \n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}\n\n \nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}\n\n \nstatic __poll_t tomoyo_poll_query(struct file *file, poll_table *wait)\n{\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\tpoll_wait(file, &tomoyo_query_wait, wait);\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\n \nstatic void tomoyo_read_query(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *tmp;\n\tunsigned int pos = 0;\n\tsize_t len = 0;\n\tchar *buf;\n\n\tif (head->r.w_pos)\n\t\treturn;\n\tkfree(head->read_buf);\n\thead->read_buf = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\tlen = ptr->query_len;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (!len) {\n\t\thead->r.query_index = 0;\n\t\treturn;\n\t}\n\tbuf = kzalloc(len + 32, GFP_NOFS);\n\tif (!buf)\n\t\treturn;\n\tpos = 0;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\t \n\t\tif (len == ptr->query_len)\n\t\t\tsnprintf(buf, len + 31, \"Q%u-%hu\\n%s\", ptr->serial,\n\t\t\t\t ptr->retry, ptr->query);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (buf[0]) {\n\t\thead->read_buf = buf;\n\t\thead->r.w[head->r.w_pos++] = buf;\n\t\thead->r.query_index++;\n\t} else {\n\t\tkfree(buf);\n\t}\n}\n\n \nstatic int tomoyo_write_answer(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct list_head *tmp;\n\tunsigned int serial;\n\tunsigned int answer;\n\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\n\t\tptr->timer = 0;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (sscanf(data, \"A%u=%u\", &serial, &answer) != 2)\n\t\treturn -EINVAL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tptr->answer = answer;\n\t\t \n\t\tif (ptr->answer)\n\t\t\tlist_del_init(&ptr->list);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn 0;\n}\n\n \nstatic void tomoyo_read_version(struct tomoyo_io_buffer *head)\n{\n\tif (!head->r.eof) {\n\t\ttomoyo_io_printf(head, \"2.6.0\");\n\t\thead->r.eof = true;\n\t}\n}\n\n \nstatic const char * const tomoyo_policy_headers[TOMOYO_MAX_POLICY_STAT] = {\n\t[TOMOYO_STAT_POLICY_UPDATES]    = \"update:\",\n\t[TOMOYO_STAT_POLICY_LEARNING]   = \"violation in learning mode:\",\n\t[TOMOYO_STAT_POLICY_PERMISSIVE] = \"violation in permissive mode:\",\n\t[TOMOYO_STAT_POLICY_ENFORCING]  = \"violation in enforcing mode:\",\n};\n\n \nstatic const char * const tomoyo_memory_headers[TOMOYO_MAX_MEMORY_STAT] = {\n\t[TOMOYO_MEMORY_POLICY] = \"policy:\",\n\t[TOMOYO_MEMORY_AUDIT]  = \"audit log:\",\n\t[TOMOYO_MEMORY_QUERY]  = \"query message:\",\n};\n\n \nstatic atomic_t tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\n \nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\n \nvoid tomoyo_update_stat(const u8 index)\n{\n\tatomic_inc(&tomoyo_stat_updated[index]);\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}\n\n \nstatic void tomoyo_read_stat(struct tomoyo_io_buffer *head)\n{\n\tu8 i;\n\tunsigned int total = 0;\n\n\tif (head->r.eof)\n\t\treturn;\n\tfor (i = 0; i < TOMOYO_MAX_POLICY_STAT; i++) {\n\t\ttomoyo_io_printf(head, \"Policy %-30s %10u\",\n\t\t\t\t tomoyo_policy_headers[i],\n\t\t\t\t atomic_read(&tomoyo_stat_updated[i]));\n\t\tif (tomoyo_stat_modified[i]) {\n\t\t\tstruct tomoyo_time stamp;\n\n\t\t\ttomoyo_convert_time(tomoyo_stat_modified[i], &stamp);\n\t\t\ttomoyo_io_printf(head, \" (Last: %04u/%02u/%02u %02u:%02u:%02u)\",\n\t\t\t\t\t stamp.year, stamp.month, stamp.day,\n\t\t\t\t\t stamp.hour, stamp.min, stamp.sec);\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++) {\n\t\tunsigned int used = tomoyo_memory_used[i];\n\n\t\ttotal += used;\n\t\ttomoyo_io_printf(head, \"Memory used by %-22s %10u\",\n\t\t\t\t tomoyo_memory_headers[i], used);\n\t\tused = tomoyo_memory_quota[i];\n\t\tif (used)\n\t\t\ttomoyo_io_printf(head, \" (Quota: %10u)\", used);\n\t\ttomoyo_set_lf(head);\n\t}\n\ttomoyo_io_printf(head, \"Total memory used:                    %10u\\n\",\n\t\t\t total);\n\thead->r.eof = true;\n}\n\n \nstatic int tomoyo_write_stat(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tu8 i;\n\n\tif (tomoyo_str_starts(&data, \"Memory used by \"))\n\t\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++)\n\t\t\tif (tomoyo_str_starts(&data, tomoyo_memory_headers[i]))\n\t\t\t\tsscanf(data, \"%u\", &tomoyo_memory_quota[i]);\n\treturn 0;\n}\n\n \nint tomoyo_open_control(const u8 type, struct file *file)\n{\n\tstruct tomoyo_io_buffer *head = kzalloc(sizeof(*head), GFP_NOFS);\n\n\tif (!head)\n\t\treturn -ENOMEM;\n\tmutex_init(&head->io_sem);\n\thead->type = type;\n\tswitch (type) {\n\tcase TOMOYO_DOMAINPOLICY:\n\t\t \n\t\thead->write = tomoyo_write_domain;\n\t\thead->read = tomoyo_read_domain;\n\t\tbreak;\n\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t \n\t\thead->write = tomoyo_write_exception;\n\t\thead->read = tomoyo_read_exception;\n\t\tbreak;\n\tcase TOMOYO_AUDIT:\n\t\t \n\t\thead->poll = tomoyo_poll_log;\n\t\thead->read = tomoyo_read_log;\n\t\tbreak;\n\tcase TOMOYO_PROCESS_STATUS:\n\t\t \n\t\thead->write = tomoyo_write_pid;\n\t\thead->read = tomoyo_read_pid;\n\t\tbreak;\n\tcase TOMOYO_VERSION:\n\t\t \n\t\thead->read = tomoyo_read_version;\n\t\thead->readbuf_size = 128;\n\t\tbreak;\n\tcase TOMOYO_STAT:\n\t\t \n\t\thead->write = tomoyo_write_stat;\n\t\thead->read = tomoyo_read_stat;\n\t\thead->readbuf_size = 1024;\n\t\tbreak;\n\tcase TOMOYO_PROFILE:\n\t\t \n\t\thead->write = tomoyo_write_profile;\n\t\thead->read = tomoyo_read_profile;\n\t\tbreak;\n\tcase TOMOYO_QUERY:  \n\t\thead->poll = tomoyo_poll_query;\n\t\thead->write = tomoyo_write_answer;\n\t\thead->read = tomoyo_read_query;\n\t\tbreak;\n\tcase TOMOYO_MANAGER:\n\t\t \n\t\thead->write = tomoyo_write_manager;\n\t\thead->read = tomoyo_read_manager;\n\t\tbreak;\n\t}\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\t \n\t\thead->read = NULL;\n\t\thead->poll = NULL;\n\t} else if (!head->poll) {\n\t\t \n\t\tif (!head->readbuf_size)\n\t\t\thead->readbuf_size = 4096 * 2;\n\t\thead->read_buf = kzalloc(head->readbuf_size, GFP_NOFS);\n\t\tif (!head->read_buf) {\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t \n\t\thead->write = NULL;\n\t} else if (head->write) {\n\t\thead->writebuf_size = 4096 * 2;\n\t\thead->write_buf = kzalloc(head->writebuf_size, GFP_NOFS);\n\t\tif (!head->write_buf) {\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t \n\tif (type == TOMOYO_QUERY)\n\t\tatomic_inc(&tomoyo_query_observers);\n\tfile->private_data = head;\n\ttomoyo_notify_gc(head, true);\n\treturn 0;\n}\n\n \n__poll_t tomoyo_poll_control(struct file *file, poll_table *wait)\n{\n\tstruct tomoyo_io_buffer *head = file->private_data;\n\n\tif (head->poll)\n\t\treturn head->poll(file, wait) | EPOLLOUT | EPOLLWRNORM;\n\treturn EPOLLIN | EPOLLRDNORM | EPOLLOUT | EPOLLWRNORM;\n}\n\n \nstatic inline void tomoyo_set_namespace_cursor(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *ns;\n\n\tif (head->type != TOMOYO_EXCEPTIONPOLICY &&\n\t    head->type != TOMOYO_PROFILE)\n\t\treturn;\n\t \n\tns = head->r.ns;\n\tif (!ns || (head->r.eof && ns->next != &tomoyo_namespace_list)) {\n\t\t \n\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\thead->r.ns = ns ? ns->next : tomoyo_namespace_list.next;\n\t}\n}\n\n \nstatic inline bool tomoyo_has_more_namespace(struct tomoyo_io_buffer *head)\n{\n\treturn (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t\thead->type == TOMOYO_PROFILE) && head->r.eof &&\n\t\thead->r.ns->next != &tomoyo_namespace_list;\n}\n\n \nssize_t tomoyo_read_control(struct tomoyo_io_buffer *head, char __user *buffer,\n\t\t\t    const int buffer_len)\n{\n\tint len;\n\tint idx;\n\n\tif (!head->read)\n\t\treturn -EINVAL;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf = buffer;\n\thead->read_user_buf_avail = buffer_len;\n\tidx = tomoyo_read_lock();\n\tif (tomoyo_flush(head))\n\t\t \n\t\tdo {\n\t\t\ttomoyo_set_namespace_cursor(head);\n\t\t\thead->read(head);\n\t\t} while (tomoyo_flush(head) &&\n\t\t\t tomoyo_has_more_namespace(head));\n\ttomoyo_read_unlock(idx);\n\tlen = head->read_user_buf - buffer;\n\tmutex_unlock(&head->io_sem);\n\treturn len;\n}\n\n \nstatic int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t \n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t \n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t \n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t \n\treturn head->write(head);\n}\n\n \nssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,\n\t\t\t     const char __user *buffer, const int buffer_len)\n{\n\tint error = buffer_len;\n\tsize_t avail_len = buffer_len;\n\tchar *cp0 = head->write_buf;\n\tint idx;\n\n\tif (!head->write)\n\t\treturn -EINVAL;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf_avail = 0;\n\tidx = tomoyo_read_lock();\n\t \n\twhile (avail_len > 0) {\n\t\tchar c;\n\n\t\tif (head->w.avail >= head->writebuf_size - 1) {\n\t\t\tconst int len = head->writebuf_size * 2;\n\t\t\tchar *cp = kzalloc(len, GFP_NOFS);\n\n\t\t\tif (!cp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(cp, cp0, head->w.avail);\n\t\t\tkfree(cp0);\n\t\t\thead->write_buf = cp;\n\t\t\tcp0 = cp;\n\t\t\thead->writebuf_size = len;\n\t\t}\n\t\tif (get_user(c, buffer)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer++;\n\t\tavail_len--;\n\t\tcp0[head->w.avail++] = c;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tcp0[head->w.avail - 1] = '\\0';\n\t\thead->w.avail = 0;\n\t\ttomoyo_normalize_line(cp0);\n\t\tif (!strcmp(cp0, \"reset\")) {\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t\thead->w.domain = NULL;\n\t\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tswitch (head->type) {\n\t\tcase TOMOYO_PROCESS_STATUS:\n\t\t\t \n\t\t\tbreak;\n\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tif (tomoyo_select_domain(head, cp0))\n\t\t\t\tcontinue;\n\t\t\tfallthrough;\n\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tif (!strcmp(cp0, \"select transition_only\")) {\n\t\t\t\thead->r.print_transition_related_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (!tomoyo_manager()) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (tomoyo_parse_policy(head, cp0)) {\n\t\tcase -EPERM:\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\tcase 0:\n\t\t\tswitch (head->type) {\n\t\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tcase TOMOYO_STAT:\n\t\t\tcase TOMOYO_PROFILE:\n\t\t\tcase TOMOYO_MANAGER:\n\t\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\ttomoyo_read_unlock(idx);\n\tmutex_unlock(&head->io_sem);\n\treturn error;\n}\n\n \nvoid tomoyo_close_control(struct tomoyo_io_buffer *head)\n{\n\t \n\tif (head->type == TOMOYO_QUERY &&\n\t    atomic_dec_and_test(&tomoyo_query_observers))\n\t\twake_up_all(&tomoyo_answer_wait);\n\ttomoyo_notify_gc(head, false);\n}\n\n \nvoid tomoyo_check_profile(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tconst int idx = tomoyo_read_lock();\n\n\ttomoyo_policy_loaded = true;\n\tpr_info(\"TOMOYO: 2.6.0\\n\");\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tconst u8 profile = domain->profile;\n\t\tstruct tomoyo_policy_namespace *ns = domain->ns;\n\n\t\tif (ns->profile_version == 20110903) {\n\t\t\tpr_info_once(\"Converting profile version from %u to %u.\\n\",\n\t\t\t\t     20110903, 20150505);\n\t\t\tns->profile_version = 20150505;\n\t\t}\n\t\tif (ns->profile_version != 20150505)\n\t\t\tpr_err(\"Profile version %u is not supported.\\n\",\n\t\t\t       ns->profile_version);\n\t\telse if (!ns->profile_ptr[profile])\n\t\t\tpr_err(\"Profile %u (used by '%s') is not defined.\\n\",\n\t\t\t       profile, domain->domainname->name);\n\t\telse\n\t\t\tcontinue;\n\t\tpr_err(\"Userland tools for TOMOYO 2.6 must be installed and policy must be initialized.\\n\");\n\t\tpr_err(\"Please see https://tomoyo.osdn.jp/2.6/ for more information.\\n\");\n\t\tpanic(\"STOP!\");\n\t}\n\ttomoyo_read_unlock(idx);\n\tpr_info(\"Mandatory Access Control activated.\\n\");\n}\n\n \nvoid __init tomoyo_load_builtin_policy(void)\n{\n#ifdef CONFIG_SECURITY_TOMOYO_INSECURE_BUILTIN_SETTING\n\tstatic char tomoyo_builtin_profile[] __initdata =\n\t\t\"PROFILE_VERSION=20150505\\n\"\n\t\t\"0-CONFIG={ mode=learning grant_log=no reject_log=yes }\\n\";\n\tstatic char tomoyo_builtin_exception_policy[] __initdata =\n\t\t\"aggregator proc:/self/exe /proc/self/exe\\n\";\n\tstatic char tomoyo_builtin_domain_policy[] __initdata = \"\";\n\tstatic char tomoyo_builtin_manager[] __initdata = \"\";\n\tstatic char tomoyo_builtin_stat[] __initdata = \"\";\n#else\n\t \n#include \"builtin-policy.h\"\n#endif\n\tu8 i;\n\tconst int idx = tomoyo_read_lock();\n\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct tomoyo_io_buffer head = { };\n\t\tchar *start = \"\";\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tstart = tomoyo_builtin_profile;\n\t\t\thead.type = TOMOYO_PROFILE;\n\t\t\thead.write = tomoyo_write_profile;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart = tomoyo_builtin_exception_policy;\n\t\t\thead.type = TOMOYO_EXCEPTIONPOLICY;\n\t\t\thead.write = tomoyo_write_exception;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = tomoyo_builtin_domain_policy;\n\t\t\thead.type = TOMOYO_DOMAINPOLICY;\n\t\t\thead.write = tomoyo_write_domain;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstart = tomoyo_builtin_manager;\n\t\t\thead.type = TOMOYO_MANAGER;\n\t\t\thead.write = tomoyo_write_manager;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstart = tomoyo_builtin_stat;\n\t\t\thead.type = TOMOYO_STAT;\n\t\t\thead.write = tomoyo_write_stat;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tchar *end = strchr(start, '\\n');\n\n\t\t\tif (!end)\n\t\t\t\tbreak;\n\t\t\t*end = '\\0';\n\t\t\ttomoyo_normalize_line(start);\n\t\t\thead.write_buf = start;\n\t\t\ttomoyo_parse_policy(&head, start);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\ttomoyo_read_unlock(idx);\n#ifdef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\ttomoyo_check_profile();\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}