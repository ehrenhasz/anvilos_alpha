{
  "module_name": "securityfs_if.c",
  "hash_id": "b033d119d245ddf000bf3ffff2ffa6c8238afba183999dc30525cdec48e712b0",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/securityfs_if.c",
  "human_readable_source": "\n \n\n#include <linux/security.h>\n#include \"common.h\"\n\n \nstatic bool tomoyo_check_task_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_task_acl *acl = container_of(ptr, typeof(*acl),\n\t\t\t\t\t\t\t head);\n\n\treturn !tomoyo_pathcmp(r->param.task.domainname, acl->domainname);\n}\n\n \nstatic ssize_t tomoyo_write_self(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *data;\n\tint error;\n\n\tif (!count || count >= TOMOYO_EXEC_TMPSIZE - 10)\n\t\treturn -ENOMEM;\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\ttomoyo_normalize_line(data);\n\tif (tomoyo_correct_domain(data)) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tstruct tomoyo_path_info name;\n\t\tstruct tomoyo_request_info r;\n\n\t\tname.name = data;\n\t\ttomoyo_fill_path_info(&name);\n\t\t \n\t\ttomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\t\tr.param_type = TOMOYO_TYPE_MANUAL_TASK_ACL;\n\t\tr.param.task.domainname = &name;\n\t\ttomoyo_check_acl(&r, tomoyo_check_task_acl);\n\t\tif (!r.granted)\n\t\t\terror = -EPERM;\n\t\telse {\n\t\t\tstruct tomoyo_domain_info *new_domain =\n\t\t\t\ttomoyo_assign_domain(data, true);\n\t\t\tif (!new_domain) {\n\t\t\t\terror = -ENOENT;\n\t\t\t} else {\n\t\t\t\tstruct tomoyo_task *s = tomoyo_task(current);\n\t\t\t\tstruct tomoyo_domain_info *old_domain =\n\t\t\t\t\ts->domain_info;\n\n\t\t\t\ts->domain_info = new_domain;\n\t\t\t\tatomic_inc(&new_domain->users);\n\t\t\t\tatomic_dec(&old_domain->users);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\ttomoyo_read_unlock(idx);\n\t} else\n\t\terror = -EINVAL;\n\tkfree(data);\n\treturn error ? error : count;\n}\n\n \nstatic ssize_t tomoyo_read_self(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tconst char *domain = tomoyo_domain()->domainname->name;\n\tloff_t len = strlen(domain);\n\tloff_t pos = *ppos;\n\n\tif (pos >= len || !count)\n\t\treturn 0;\n\tlen -= pos;\n\tif (count < len)\n\t\tlen = count;\n\tif (copy_to_user(buf, domain + pos, len))\n\t\treturn -EFAULT;\n\t*ppos += len;\n\treturn len;\n}\n\n \nstatic const struct file_operations tomoyo_self_operations = {\n\t.write = tomoyo_write_self,\n\t.read  = tomoyo_read_self,\n};\n\n \nstatic int tomoyo_open(struct inode *inode, struct file *file)\n{\n\tconst u8 key = (uintptr_t) file_inode(file)->i_private;\n\n\treturn tomoyo_open_control(key, file);\n}\n\n \nstatic int tomoyo_release(struct inode *inode, struct file *file)\n{\n\ttomoyo_close_control(file->private_data);\n\treturn 0;\n}\n\n \nstatic __poll_t tomoyo_poll(struct file *file, poll_table *wait)\n{\n\treturn tomoyo_poll_control(file, wait);\n}\n\n \nstatic ssize_t tomoyo_read(struct file *file, char __user *buf, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\treturn tomoyo_read_control(file->private_data, buf, count);\n}\n\n \nstatic ssize_t tomoyo_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn tomoyo_write_control(file->private_data, buf, count);\n}\n\n \nstatic const struct file_operations tomoyo_operations = {\n\t.open    = tomoyo_open,\n\t.release = tomoyo_release,\n\t.poll    = tomoyo_poll,\n\t.read    = tomoyo_read,\n\t.write   = tomoyo_write,\n\t.llseek  = noop_llseek,\n};\n\n \nstatic void __init tomoyo_create_entry(const char *name, const umode_t mode,\n\t\t\t\t       struct dentry *parent, const u8 key)\n{\n\tsecurityfs_create_file(name, mode, parent, (void *) (uintptr_t) key,\n\t\t\t       &tomoyo_operations);\n}\n\n \nstatic int __init tomoyo_initerface_init(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct dentry *tomoyo_dir;\n\n\tif (!tomoyo_enabled)\n\t\treturn 0;\n\tdomain = tomoyo_domain();\n\t \n\tif (domain != &tomoyo_kernel_domain)\n\t\treturn 0;\n\n\ttomoyo_dir = securityfs_create_dir(\"tomoyo\", NULL);\n\ttomoyo_create_entry(\"query\",            0600, tomoyo_dir,\n\t\t\t    TOMOYO_QUERY);\n\ttomoyo_create_entry(\"domain_policy\",    0600, tomoyo_dir,\n\t\t\t    TOMOYO_DOMAINPOLICY);\n\ttomoyo_create_entry(\"exception_policy\", 0600, tomoyo_dir,\n\t\t\t    TOMOYO_EXCEPTIONPOLICY);\n\ttomoyo_create_entry(\"audit\",            0400, tomoyo_dir,\n\t\t\t    TOMOYO_AUDIT);\n\ttomoyo_create_entry(\".process_status\",  0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROCESS_STATUS);\n\ttomoyo_create_entry(\"stat\",             0644, tomoyo_dir,\n\t\t\t    TOMOYO_STAT);\n\ttomoyo_create_entry(\"profile\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROFILE);\n\ttomoyo_create_entry(\"manager\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_MANAGER);\n\ttomoyo_create_entry(\"version\",          0400, tomoyo_dir,\n\t\t\t    TOMOYO_VERSION);\n\tsecurityfs_create_file(\"self_domain\", 0666, tomoyo_dir, NULL,\n\t\t\t       &tomoyo_self_operations);\n\ttomoyo_load_builtin_policy();\n\treturn 0;\n}\n\nfs_initcall(tomoyo_initerface_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}