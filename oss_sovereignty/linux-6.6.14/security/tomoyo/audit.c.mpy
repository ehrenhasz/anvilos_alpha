{
  "module_name": "audit.c",
  "hash_id": "914577045dba8f69e64f2825655e088713b242170b2734097cf07db409ecb43c",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/audit.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/slab.h>\n\n \nstatic char *tomoyo_print_bprm(struct linux_binprm *bprm,\n\t\t\t       struct tomoyo_page_dump *dump)\n{\n\tstatic const int tomoyo_buffer_len = 4096 * 2;\n\tchar *buffer = kzalloc(tomoyo_buffer_len, GFP_NOFS);\n\tchar *cp;\n\tchar *last_start;\n\tint len;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool truncated = false;\n\n\tif (!buffer)\n\t\treturn NULL;\n\tlen = snprintf(buffer, tomoyo_buffer_len - 1, \"argv[]={ \");\n\tcp = buffer + len;\n\tif (!argv_count) {\n\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\tcp += 11;\n\t}\n\tlast_start = cp;\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t \n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\n\t\t\tif (cp == last_start)\n\t\t\t\t*cp++ = '\"';\n\t\t\tif (cp >= buffer + tomoyo_buffer_len - 32) {\n\t\t\t\t \n\t\t\t\ttruncated = true;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t*cp++ = c;\n\t\t\t} else if (!c) {\n\t\t\t\t*cp++ = '\"';\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tlast_start = cp;\n\t\t\t} else {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t\t*cp++ = (c & 7) + '0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (argv_count) {\n\t\t\t\tif (--argv_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\t\t\t\tcp += 11;\n\t\t\t\t\tlast_start = cp;\n\t\t\t\t\ttruncated = false;\n\t\t\t\t}\n\t\t\t} else if (envp_count) {\n\t\t\t\tif (--envp_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!argv_count && !envp_count)\n\t\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t}\n\t*cp++ = '}';\n\t*cp = '\\0';\n\treturn buffer;\nout:\n\tsnprintf(buffer, tomoyo_buffer_len - 1,\n\t\t \"argv[]={ ... } envp[]= { ... }\");\n\treturn buffer;\n}\n\n \nstatic inline const char *tomoyo_filetype(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase 0:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FILE];\n\tcase S_IFDIR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_DIRECTORY];\n\tcase S_IFLNK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SYMLINK];\n\tcase S_IFIFO:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FIFO];\n\tcase S_IFSOCK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SOCKET];\n\tcase S_IFBLK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_BLOCK_DEV];\n\tcase S_IFCHR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_CHAR_DEV];\n\t}\n\treturn \"unknown\";  \n}\n\n \nstatic char *tomoyo_print_header(struct tomoyo_request_info *r)\n{\n\tstruct tomoyo_time stamp;\n\tconst pid_t gpid = task_pid_nr(current);\n\tstruct tomoyo_obj_info *obj = r->obj;\n\tstatic const int tomoyo_buffer_len = 4096;\n\tchar *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);\n\tint pos;\n\tu8 i;\n\n\tif (!buffer)\n\t\treturn NULL;\n\n\ttomoyo_convert_time(ktime_get_real_seconds(), &stamp);\n\n\tpos = snprintf(buffer, tomoyo_buffer_len - 1,\n\t\t       \"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s granted=%s (global-pid=%u) task={ pid=%u ppid=%u uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u fsuid=%u fsgid=%u }\",\n\t\t       stamp.year, stamp.month, stamp.day, stamp.hour,\n\t\t       stamp.min, stamp.sec, r->profile, tomoyo_mode[r->mode],\n\t\t       str_yes_no(r->granted), gpid, tomoyo_sys_getpid(),\n\t\t       tomoyo_sys_getppid(),\n\t\t       from_kuid(&init_user_ns, current_uid()),\n\t\t       from_kgid(&init_user_ns, current_gid()),\n\t\t       from_kuid(&init_user_ns, current_euid()),\n\t\t       from_kgid(&init_user_ns, current_egid()),\n\t\t       from_kuid(&init_user_ns, current_suid()),\n\t\t       from_kgid(&init_user_ns, current_sgid()),\n\t\t       from_kuid(&init_user_ns, current_fsuid()),\n\t\t       from_kgid(&init_user_ns, current_fsgid()));\n\tif (!obj)\n\t\tgoto no_obj_info;\n\tif (!obj->validate_done) {\n\t\ttomoyo_get_attributes(obj);\n\t\tobj->validate_done = true;\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct tomoyo_mini_stat *stat;\n\t\tunsigned int dev;\n\t\tumode_t mode;\n\n\t\tif (!obj->stat_valid[i])\n\t\t\tcontinue;\n\t\tstat = &obj->stat[i];\n\t\tdev = stat->dev;\n\t\tmode = stat->mode;\n\t\tif (i & 1) {\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" path%u.parent={ uid=%u gid=%u ino=%lu perm=0%o }\",\n\t\t\t\t\t(i >> 1) + 1,\n\t\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\t\tstat->mode & S_IALLUGO);\n\t\t\tcontinue;\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" path%u={ uid=%u gid=%u ino=%lu major=%u minor=%u perm=0%o type=%s\",\n\t\t\t\t(i >> 1) + 1,\n\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\tMAJOR(dev), MINOR(dev),\n\t\t\t\tmode & S_IALLUGO, tomoyo_filetype(mode));\n\t\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\t\tdev = stat->rdev;\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" dev_major=%u dev_minor=%u\",\n\t\t\t\t\tMAJOR(dev), MINOR(dev));\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" }\");\n\t}\nno_obj_info:\n\tif (pos < tomoyo_buffer_len - 1)\n\t\treturn buffer;\n\tkfree(buffer);\n\treturn NULL;\n}\n\n \nchar *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t \n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t \n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t \n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = kmalloc_size_roundup(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);\n\n \nstruct tomoyo_log {\n\tstruct list_head list;\n\tchar *log;\n\tint size;\n};\n\n \nstatic LIST_HEAD(tomoyo_log);\n\n \nstatic DEFINE_SPINLOCK(tomoyo_log_lock);\n\n \nstatic unsigned int tomoyo_log_count;\n\n \nstatic bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,\n\t\t\t     const u8 profile, const u8 index,\n\t\t\t     const struct tomoyo_acl_info *matched_acl,\n\t\t\t     const bool is_granted)\n{\n\tu8 mode;\n\tconst u8 category = tomoyo_index2category[index] +\n\t\tTOMOYO_MAX_MAC_INDEX;\n\tstruct tomoyo_profile *p;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn false;\n\tp = tomoyo_profile(ns, profile);\n\tif (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])\n\t\treturn false;\n\tif (is_granted && matched_acl && matched_acl->cond &&\n\t    matched_acl->cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\treturn matched_acl->cond->grant_log == TOMOYO_GRANTLOG_YES;\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[category];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\tif (is_granted)\n\t\treturn mode & TOMOYO_CONFIG_WANT_GRANT_LOG;\n\treturn mode & TOMOYO_CONFIG_WANT_REJECT_LOG;\n}\n\n \nvoid tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = kmalloc_size_roundup(strlen(buf) + 1);\n\t \n\tentry->size = len + kmalloc_size_roundup(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}\n\n \nvoid tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(NULL, 0, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}\n\n \nvoid tomoyo_read_log(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_log *ptr = NULL;\n\n\tif (head->r.w_pos)\n\t\treturn;\n\tkfree(head->read_buf);\n\thead->read_buf = NULL;\n\tspin_lock(&tomoyo_log_lock);\n\tif (!list_empty(&tomoyo_log)) {\n\t\tptr = list_entry(tomoyo_log.next, typeof(*ptr), list);\n\t\tlist_del(&ptr->list);\n\t\ttomoyo_log_count--;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] -= ptr->size;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (ptr) {\n\t\thead->read_buf = ptr->log;\n\t\thead->r.w[head->r.w_pos++] = head->read_buf;\n\t\tkfree(ptr);\n\t}\n}\n\n \n__poll_t tomoyo_poll_log(struct file *file, poll_table *wait)\n{\n\tif (tomoyo_log_count)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\tpoll_wait(file, &tomoyo_log_wait, wait);\n\tif (tomoyo_log_count)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}