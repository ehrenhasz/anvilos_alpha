{
  "module_name": "tomoyo.c",
  "hash_id": "5339a19f4578e41c2d1bd3bad145fcf1d251e9613b464d0c0df790268f30dc62",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/tomoyo.c",
  "human_readable_source": "\n \n\n#include <linux/lsm_hooks.h>\n#include \"common.h\"\n\n \nstruct tomoyo_domain_info *tomoyo_domain(void)\n{\n\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\tif (s->old_domain_info && !current->in_execve) {\n\t\tatomic_dec(&s->old_domain_info->users);\n\t\ts->old_domain_info = NULL;\n\t}\n\treturn s->domain_info;\n}\n\n \nstatic int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t       gfp_t gfp)\n{\n\t \n\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\tif (s->old_domain_info && !current->in_execve) {\n\t\tatomic_dec(&s->domain_info->users);\n\t\ts->domain_info = s->old_domain_info;\n\t\ts->old_domain_info = NULL;\n\t}\n\treturn 0;\n}\n\n \nstatic void tomoyo_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\t \n\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\tatomic_dec(&s->old_domain_info->users);\n\ts->old_domain_info = NULL;\n}\n\n#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n \nstatic int tomoyo_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\t \n\tif (!tomoyo_policy_loaded)\n\t\ttomoyo_load_policy(bprm->filename);\n\treturn 0;\n}\n#endif\n\n \nstatic int tomoyo_bprm_check_security(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\t \n\tif (!s->old_domain_info) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tconst int err = tomoyo_find_next_domain(bprm);\n\n\t\ttomoyo_read_unlock(idx);\n\t\treturn err;\n\t}\n\t \n\treturn tomoyo_check_open_permission(s->domain_info,\n\t\t\t\t\t    &bprm->file->f_path, O_RDONLY);\n}\n\n \nstatic int tomoyo_inode_getattr(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_GETATTR, path, NULL);\n}\n\n \nstatic int tomoyo_path_truncate(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);\n}\n\n \nstatic int tomoyo_file_truncate(struct file *file)\n{\n\treturn tomoyo_path_truncate(&file->f_path);\n}\n\n \nstatic int tomoyo_path_unlink(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UNLINK, &path, NULL);\n}\n\n \nstatic int tomoyo_path_mkdir(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,\n\t\t\t\t       mode & S_IALLUGO);\n}\n\n \nstatic int tomoyo_path_rmdir(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\n\treturn tomoyo_path_perm(TOMOYO_TYPE_RMDIR, &path, NULL);\n}\n\n \nstatic int tomoyo_path_symlink(const struct path *parent, struct dentry *dentry,\n\t\t\t       const char *old_name)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\n\treturn tomoyo_path_perm(TOMOYO_TYPE_SYMLINK, &path, old_name);\n}\n\n \nstatic int tomoyo_path_mknod(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode, unsigned int dev)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\tint type = TOMOYO_TYPE_CREATE;\n\tconst unsigned int perm = mode & S_IALLUGO;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFCHR:\n\t\ttype = TOMOYO_TYPE_MKCHAR;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\ttype = TOMOYO_TYPE_MKBLOCK;\n\t\tbreak;\n\tdefault:\n\t\tgoto no_dev;\n\t}\n\treturn tomoyo_mkdev_perm(type, &path, perm, dev);\n no_dev:\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\ttype = TOMOYO_TYPE_MKFIFO;\n\t\tbreak;\n\tcase S_IFSOCK:\n\t\ttype = TOMOYO_TYPE_MKSOCK;\n\t\tbreak;\n\t}\n\treturn tomoyo_path_number_perm(type, &path, perm);\n}\n\n \nstatic int tomoyo_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct path path1 = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_LINK, &path1, &path2);\n}\n\n \nstatic int tomoyo_path_rename(const struct path *old_parent,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      const struct path *new_parent,\n\t\t\t      struct dentry *new_dentry,\n\t\t\t      const unsigned int flags)\n{\n\tstruct path path1 = { .mnt = old_parent->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_parent->mnt, .dentry = new_dentry };\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\tconst int err = tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path2,\n\t\t\t\t&path1);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path1, &path2);\n}\n\n \nstatic int tomoyo_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tif (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,\n\t\t\t\t\t    O_WRONLY | (arg & O_APPEND));\n}\n\n \nstatic int tomoyo_file_open(struct file *f)\n{\n\t \n\tif (current->in_execve)\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &f->f_path,\n\t\t\t\t\t    f->f_flags);\n}\n\n \nstatic int tomoyo_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_IOCTL, &file->f_path, cmd);\n}\n\n \nstatic int tomoyo_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,\n\t\t\t\t       mode & S_IALLUGO);\n}\n\n \nstatic int tomoyo_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\tint error = 0;\n\n\tif (uid_valid(uid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHOWN, path,\n\t\t\t\t\t\tfrom_kuid(&init_user_ns, uid));\n\tif (!error && gid_valid(gid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHGRP, path,\n\t\t\t\t\t\tfrom_kgid(&init_user_ns, gid));\n\treturn error;\n}\n\n \nstatic int tomoyo_path_chroot(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_CHROOT, path, NULL);\n}\n\n \nstatic int tomoyo_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t   const char *type, unsigned long flags, void *data)\n{\n\treturn tomoyo_mount_permission(dev_name, path, type, flags, data);\n}\n\n \nstatic int tomoyo_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UMOUNT, &path, NULL);\n}\n\n \nstatic int tomoyo_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n{\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);\n}\n\n \nstatic int tomoyo_socket_listen(struct socket *sock, int backlog)\n{\n\treturn tomoyo_socket_listen_permission(sock);\n}\n\n \nstatic int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t int addr_len)\n{\n\treturn tomoyo_socket_connect_permission(sock, addr, addr_len);\n}\n\n \nstatic int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int addr_len)\n{\n\treturn tomoyo_socket_bind_permission(sock, addr, addr_len);\n}\n\n \nstatic int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int size)\n{\n\treturn tomoyo_socket_sendmsg_permission(sock, msg, size);\n}\n\nstruct lsm_blob_sizes tomoyo_blob_sizes __ro_after_init = {\n\t.lbs_task = sizeof(struct tomoyo_task),\n};\n\n \nstatic int tomoyo_task_alloc(struct task_struct *task,\n\t\t\t     unsigned long clone_flags)\n{\n\tstruct tomoyo_task *old = tomoyo_task(current);\n\tstruct tomoyo_task *new = tomoyo_task(task);\n\n\tnew->domain_info = old->domain_info;\n\tatomic_inc(&new->domain_info->users);\n\tnew->old_domain_info = NULL;\n\treturn 0;\n}\n\n \nstatic void tomoyo_task_free(struct task_struct *task)\n{\n\tstruct tomoyo_task *s = tomoyo_task(task);\n\n\tif (s->domain_info) {\n\t\tatomic_dec(&s->domain_info->users);\n\t\ts->domain_info = NULL;\n\t}\n\tif (s->old_domain_info) {\n\t\tatomic_dec(&s->old_domain_info->users);\n\t\ts->old_domain_info = NULL;\n\t}\n}\n\n \nstatic struct security_hook_list tomoyo_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(cred_prepare, tomoyo_cred_prepare),\n\tLSM_HOOK_INIT(bprm_committed_creds, tomoyo_bprm_committed_creds),\n\tLSM_HOOK_INIT(task_alloc, tomoyo_task_alloc),\n\tLSM_HOOK_INIT(task_free, tomoyo_task_free),\n#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\tLSM_HOOK_INIT(bprm_creds_for_exec, tomoyo_bprm_creds_for_exec),\n#endif\n\tLSM_HOOK_INIT(bprm_check_security, tomoyo_bprm_check_security),\n\tLSM_HOOK_INIT(file_fcntl, tomoyo_file_fcntl),\n\tLSM_HOOK_INIT(file_open, tomoyo_file_open),\n\tLSM_HOOK_INIT(file_truncate, tomoyo_file_truncate),\n\tLSM_HOOK_INIT(path_truncate, tomoyo_path_truncate),\n\tLSM_HOOK_INIT(path_unlink, tomoyo_path_unlink),\n\tLSM_HOOK_INIT(path_mkdir, tomoyo_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, tomoyo_path_rmdir),\n\tLSM_HOOK_INIT(path_symlink, tomoyo_path_symlink),\n\tLSM_HOOK_INIT(path_mknod, tomoyo_path_mknod),\n\tLSM_HOOK_INIT(path_link, tomoyo_path_link),\n\tLSM_HOOK_INIT(path_rename, tomoyo_path_rename),\n\tLSM_HOOK_INIT(inode_getattr, tomoyo_inode_getattr),\n\tLSM_HOOK_INIT(file_ioctl, tomoyo_file_ioctl),\n\tLSM_HOOK_INIT(path_chmod, tomoyo_path_chmod),\n\tLSM_HOOK_INIT(path_chown, tomoyo_path_chown),\n\tLSM_HOOK_INIT(path_chroot, tomoyo_path_chroot),\n\tLSM_HOOK_INIT(sb_mount, tomoyo_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, tomoyo_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, tomoyo_sb_pivotroot),\n\tLSM_HOOK_INIT(socket_bind, tomoyo_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, tomoyo_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, tomoyo_socket_listen),\n\tLSM_HOOK_INIT(socket_sendmsg, tomoyo_socket_sendmsg),\n};\n\n \nDEFINE_SRCU(tomoyo_ss);\n\nint tomoyo_enabled __ro_after_init = 1;\n\n \nstatic int __init tomoyo_init(void)\n{\n\tstruct tomoyo_task *s = tomoyo_task(current);\n\n\t \n\tsecurity_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), \"tomoyo\");\n\tpr_info(\"TOMOYO Linux initialized\\n\");\n\ts->domain_info = &tomoyo_kernel_domain;\n\tatomic_inc(&tomoyo_kernel_domain.users);\n\ts->old_domain_info = NULL;\n\ttomoyo_mm_init();\n\n\treturn 0;\n}\n\nDEFINE_LSM(tomoyo) = {\n\t.name = \"tomoyo\",\n\t.enabled = &tomoyo_enabled,\n\t.flags = LSM_FLAG_LEGACY_MAJOR,\n\t.blobs = &tomoyo_blob_sizes,\n\t.init = tomoyo_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}