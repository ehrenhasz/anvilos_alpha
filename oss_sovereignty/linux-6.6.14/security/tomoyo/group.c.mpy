{
  "module_name": "group.c",
  "hash_id": "0058feb275b25f7dd31e3ad5ad905ef3a4428101ca8539ea77dbdf36e37bd9dc",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/group.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n#include \"common.h\"\n\n \nstatic bool tomoyo_same_path_group(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_path_group, head)->member_name ==\n\t\tcontainer_of(b, struct tomoyo_path_group, head)->member_name;\n}\n\n \nstatic bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,\n\t\t\t\t     const struct tomoyo_acl_head *b)\n{\n\treturn !memcmp(&container_of(a, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       &container_of(b, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       sizeof(container_of(a, struct tomoyo_number_group, head)\n\t\t\t      ->number));\n}\n\n \nstatic bool tomoyo_same_address_group(const struct tomoyo_acl_head *a,\n\t\t\t\t      const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_address_group *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t     head);\n\tconst struct tomoyo_address_group *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t     head);\n\n\treturn tomoyo_same_ipaddr_union(&p1->address, &p2->address);\n}\n\n \nint tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\n{\n\tstruct tomoyo_group *group = tomoyo_get_group(param, type);\n\tint error = -EINVAL;\n\n\tif (!group)\n\t\treturn -ENOMEM;\n\tparam->list = &group->member_list;\n\tif (type == TOMOYO_PATH_GROUP) {\n\t\tstruct tomoyo_path_group e = { };\n\n\t\te.member_name = tomoyo_get_name(tomoyo_read_token(param));\n\t\tif (!e.member_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_path_group);\n\t\ttomoyo_put_name(e.member_name);\n\t} else if (type == TOMOYO_NUMBER_GROUP) {\n\t\tstruct tomoyo_number_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_number_union(param, &e.number))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_number_group);\n\t\t \n\t} else {\n\t\tstruct tomoyo_address_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_address_group);\n\t}\nout:\n\ttomoyo_put_group(group);\n\treturn error;\n}\n\n \nconst struct tomoyo_path_info *\ntomoyo_path_matches_group(const struct tomoyo_path_info *pathname,\n\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_path_group *member;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_path_matches_pattern(pathname, member->member_name))\n\t\t\tcontinue;\n\t\treturn member->member_name;\n\t}\n\treturn NULL;\n}\n\n \nbool tomoyo_number_matches_group(const unsigned long min,\n\t\t\t\t const unsigned long max,\n\t\t\t\t const struct tomoyo_group *group)\n{\n\tstruct tomoyo_number_group *member;\n\tbool matched = false;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (min > member->number.values[1] ||\n\t\t    max < member->number.values[0])\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}\n\n \nbool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\n\t\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_address_group *member;\n\tbool matched = false;\n\tconst u8 size = is_ipv6 ? 16 : 4;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list,\n\t\t\t\tsrcu_read_lock_held(&tomoyo_ss)) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (member->address.is_ipv6 != is_ipv6)\n\t\t\tcontinue;\n\t\tif (memcmp(&member->address.ip[0], address, size) > 0 ||\n\t\t    memcmp(address, &member->address.ip[1], size) > 0)\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}