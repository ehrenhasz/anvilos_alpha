{
  "module_name": "memory.c",
  "hash_id": "4c169a8bdb5efbb94550c05493e1a08bf416684fa043abf7778ecb51a824f53f",
  "original_prompt": "Ingested from linux-6.6.14/security/tomoyo/memory.c",
  "human_readable_source": "\n \n\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include \"common.h\"\n\n \nvoid tomoyo_warn_oom(const char *function)\n{\n\t \n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\n\tif (tomoyo_last_pid != pid) {\n\t\tpr_warn(\"ERROR: Out of memory at %s.\\n\", function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}\n\n \nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\n \nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\n \nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}\n\n \nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}\n\n \nstruct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}\n\n \nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\n \nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS | __GFP_NOWARN);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}\n\n \nstruct tomoyo_policy_namespace tomoyo_kernel_namespace;\n\n \nvoid __init tomoyo_mm_init(void)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < TOMOYO_MAX_HASH; idx++)\n\t\tINIT_LIST_HEAD(&tomoyo_name_list[idx]);\n\ttomoyo_kernel_namespace.name = \"<kernel>\";\n\ttomoyo_init_policy_namespace(&tomoyo_kernel_namespace);\n\ttomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;\n\tINIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);\n\ttomoyo_kernel_domain.domainname = tomoyo_get_name(\"<kernel>\");\n\tlist_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}