{
  "module_name": "inode.c",
  "hash_id": "4787962d50fe4c8af761287f932814e2e4a4bca9e680b2caa4ffb70981b688a1",
  "original_prompt": "Ingested from linux-6.6.14/security/inode.c",
  "human_readable_source": "\n \n\n \n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include <linux/security.h>\n#include <linux/lsm_hooks.h>\n#include <linux/magic.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\n\nstatic void securityfs_free_inode(struct inode *inode)\n{\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tfree_inode_nonrcu(inode);\n}\n\nstatic const struct super_operations securityfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.free_inode\t= securityfs_free_inode,\n};\n\nstatic int securityfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstatic const struct tree_descr files[] = {{\"\"}};\n\tint error;\n\n\terror = simple_fill_super(sb, SECURITYFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\n\tsb->s_op = &securityfs_super_operations;\n\n\treturn 0;\n}\n\nstatic int securityfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, securityfs_fill_super);\n}\n\nstatic const struct fs_context_operations securityfs_context_ops = {\n\t.get_tree\t= securityfs_get_tree,\n};\n\nstatic int securityfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &securityfs_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.init_fs_context = securityfs_init_fs_context,\n\t.kill_sb =\tkill_litter_super,\n};\n\n \nstatic struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}\n\n \nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}\nEXPORT_SYMBOL_GPL(securityfs_create_file);\n\n \nstruct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(securityfs_create_dir);\n\n \nstruct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = securityfs_create_dentry(name, S_IFLNK | 0444, parent,\n\t\t\t\t\tlink, NULL, iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}\nEXPORT_SYMBOL_GPL(securityfs_create_symlink);\n\n \nvoid securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}\nEXPORT_SYMBOL_GPL(securityfs_remove);\n\n#ifdef CONFIG_SECURITY\nstatic struct dentry *lsm_dentry;\nstatic ssize_t lsm_read(struct file *filp, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, count, ppos, lsm_names,\n\t\tstrlen(lsm_names));\n}\n\nstatic const struct file_operations lsm_ops = {\n\t.read = lsm_read,\n\t.llseek = generic_file_llseek,\n};\n#endif\n\nstatic int __init securityfs_init(void)\n{\n\tint retval;\n\n\tretval = sysfs_create_mount_point(kernel_kobj, \"security\");\n\tif (retval)\n\t\treturn retval;\n\n\tretval = register_filesystem(&fs_type);\n\tif (retval) {\n\t\tsysfs_remove_mount_point(kernel_kobj, \"security\");\n\t\treturn retval;\n\t}\n#ifdef CONFIG_SECURITY\n\tlsm_dentry = securityfs_create_file(\"lsm\", 0444, NULL, NULL,\n\t\t\t\t\t\t&lsm_ops);\n#endif\n\treturn 0;\n}\ncore_initcall(securityfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}