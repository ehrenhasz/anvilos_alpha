{
  "module_name": "file.c",
  "hash_id": "714a38b65172bbebcb7af6687804f506378a91db129757ba90f26194c6a529b8",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/file.c",
  "human_readable_source": "\n \n\n#include <linux/tty.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/file.h\"\n#include \"include/match.h\"\n#include \"include/net.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n\nstatic u32 map_mask_to_chr_mask(u32 mask)\n{\n\tu32 m = mask & PERMS_CHRS_MASK;\n\n\tif (mask & AA_MAY_GETATTR)\n\t\tm |= MAY_READ;\n\tif (mask & (AA_MAY_SETATTR | AA_MAY_CHMOD | AA_MAY_CHOWN))\n\t\tm |= MAY_WRITE;\n\n\treturn m;\n}\n\n \nstatic void file_audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\tkuid_t fsuid = ad->subj_cred ? ad->subj_cred->fsuid : current_fsuid();\n\tchar str[10];\n\n\tif (ad->request & AA_AUDIT_FILE_MASK) {\n\t\taa_perm_mask_to_str(str, sizeof(str), aa_file_perm_chrs,\n\t\t\t\t    map_mask_to_chr_mask(ad->request));\n\t\taudit_log_format(ab, \" requested_mask=\\\"%s\\\"\", str);\n\t}\n\tif (ad->denied & AA_AUDIT_FILE_MASK) {\n\t\taa_perm_mask_to_str(str, sizeof(str), aa_file_perm_chrs,\n\t\t\t\t    map_mask_to_chr_mask(ad->denied));\n\t\taudit_log_format(ab, \" denied_mask=\\\"%s\\\"\", str);\n\t}\n\tif (ad->request & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" fsuid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, fsuid));\n\t\taudit_log_format(ab, \" ouid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, ad->fs.ouid));\n\t}\n\n\tif (ad->peer) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\t\tFLAG_VIEW_SUBNS, GFP_KERNEL);\n\t} else if (ad->fs.target) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taudit_log_untrustedstring(ab, ad->fs.target);\n\t}\n}\n\n \nint aa_audit_file(const struct cred *subj_cred,\n\t\t  struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_TASK, AA_CLASS_FILE, op);\n\n\tad.subj_cred = subj_cred;\n\tad.request = request;\n\tad.name = name;\n\tad.fs.target = target;\n\tad.peer = tlabel;\n\tad.fs.ouid = ouid;\n\tad.info = info;\n\tad.error = error;\n\tad.common.u.tsk = NULL;\n\n\tif (likely(!ad.error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t \n\t\tad.request &= mask;\n\n\t\tif (likely(!ad.request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t \n\t\tad.request = ad.request & ~perms->allow;\n\t\tAA_BUG(!ad.request);\n\n\t\tif (ad.request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t \n\t\tif ((ad.request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\tad.request &= ~perms->quiet;\n\n\t\tif (!ad.request)\n\t\t\treturn ad.error;\n\t}\n\n\tad.denied = ad.request & ~perms->allow;\n\treturn aa_audit(type, profile, &ad, file_audit_cb);\n}\n\n \nstatic inline bool is_deleted(struct dentry *dentry)\n{\n\tif (d_unlinked(dentry) && d_backing_inode(dentry)->i_nlink == 0)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int path_name(const char *op, const struct cred *subj_cred,\n\t\t     struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(subj_cred,\n\t\t\t\t      profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstruct aa_perms default_perms = {};\n \nstruct aa_perms *aa_lookup_fperms(struct aa_policydb *file_rules,\n\t\t\t\t aa_state_t state, struct path_cond *cond)\n{\n\tunsigned int index = ACCEPT_TABLE(file_rules->dfa)[state];\n\n\tif (!(file_rules->perms))\n\t\treturn &default_perms;\n\n\tif (uid_eq(current_fsuid(), cond->uid))\n\t\treturn &(file_rules->perms[index]);\n\n\treturn &(file_rules->perms[index + 1]);\n}\n\n \naa_state_t aa_str_perms(struct aa_policydb *file_rules, aa_state_t start,\n\t\t\tconst char *name, struct path_cond *cond,\n\t\t\tstruct aa_perms *perms)\n{\n\taa_state_t state;\n\tstate = aa_dfa_match(file_rules->dfa, start, name);\n\t*perms = *(aa_lookup_fperms(file_rules, state, cond));\n\n\treturn state;\n}\n\nstatic int __aa_path_perm(const char *op, const struct cred *subj_cred,\n\t\t\t  struct aa_profile *profile, const char *name,\n\t\t\t  u32 request, struct path_cond *cond, int flags,\n\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tint e = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\taa_str_perms(&(rules->file), rules->file.start[AA_CLASS_FILE],\n\t\t     name, cond, perms);\n\tif (request & ~perms->allow)\n\t\te = -EACCES;\n\treturn aa_audit_file(subj_cred,\n\t\t\t     profile, perms, op, request, name, NULL, NULL,\n\t\t\t     cond->uid, NULL, e);\n}\n\n\nstatic int profile_path_perm(const char *op, const struct cred *subj_cred,\n\t\t\t     struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, subj_cred, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, subj_cred, profile, name, request, cond,\n\t\t\t      flags, perms);\n}\n\n \nint aa_path_perm(const char *op, const struct cred *subj_cred,\n\t\t struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tbuffer = aa_get_buffer(false);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, subj_cred, profile, path, buffer,\n\t\t\t\t\t  request, cond, flags, &perms));\n\n\taa_put_buffer(buffer);\n\n\treturn error;\n}\n\n \nstatic inline bool xindex_is_subset(u32 link, u32 target)\n{\n\tif (((link & ~AA_X_UNSAFE) != (target & ~AA_X_UNSAFE)) ||\n\t    ((link & AA_X_UNSAFE) && !(target & AA_X_UNSAFE)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int profile_path_link(const struct cred *subj_cred,\n\t\t\t     struct aa_profile *profile,\n\t\t\t     const struct path *link, char *buffer,\n\t\t\t     const struct path *target, char *buffer2,\n\t\t\t     struct path_cond *cond)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tconst char *lname, *tname = NULL;\n\tstruct aa_perms lperms = {}, perms;\n\tconst char *info = NULL;\n\tu32 request = AA_MAY_LINK;\n\taa_state_t state;\n\tint error;\n\n\terror = path_name(OP_LINK, subj_cred, &profile->label, link,\n\t\t\t  profile->path_flags,\n\t\t\t  buffer, &lname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\t \n\terror = path_name(OP_LINK, subj_cred, &profile->label, target,\n\t\t\t  profile->path_flags,\n\t\t\t  buffer2, &tname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\t \n\tstate = aa_str_perms(&(rules->file),\n\t\t\t     rules->file.start[AA_CLASS_FILE], lname,\n\t\t\t     cond, &lperms);\n\n\tif (!(lperms.allow & AA_MAY_LINK))\n\t\tgoto audit;\n\n\t \n\tstate = aa_dfa_null_transition(rules->file.dfa, state);\n\taa_str_perms(&(rules->file), state, tname, cond, &perms);\n\n\t \n\tlperms.audit = perms.audit;\n\tlperms.quiet = perms.quiet;\n\tlperms.kill = perms.kill;\n\n\tif (!(perms.allow & AA_MAY_LINK)) {\n\t\tinfo = \"target restricted\";\n\t\tlperms = perms;\n\t\tgoto audit;\n\t}\n\n\t \n\tif (!(perms.allow & AA_LINK_SUBSET))\n\t\tgoto done_tests;\n\n\t \n\taa_str_perms(&(rules->file), rules->file.start[AA_CLASS_FILE],\n\t\t     tname, cond, &perms);\n\n\t \n\trequest = lperms.allow & ~AA_MAY_LINK;\n\tlperms.allow &= perms.allow | AA_MAY_LINK;\n\n\trequest |= AA_AUDIT_FILE_MASK & (lperms.allow & ~perms.allow);\n\tif (request & ~lperms.allow) {\n\t\tgoto audit;\n\t} else if ((lperms.allow & MAY_EXEC) &&\n\t\t   !xindex_is_subset(lperms.xindex, perms.xindex)) {\n\t\tlperms.allow &= ~MAY_EXEC;\n\t\trequest |= MAY_EXEC;\n\t\tinfo = \"link not subset of target\";\n\t\tgoto audit;\n\t}\n\ndone_tests:\n\terror = 0;\n\naudit:\n\treturn aa_audit_file(subj_cred,\n\t\t\t     profile, &lperms, OP_LINK, request, lname, tname,\n\t\t\t     NULL, cond->uid, info, error);\n}\n\n \nint aa_path_link(const struct cred *subj_cred,\n\t\t struct aa_label *label, struct dentry *old_dentry,\n\t\t const struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\tstruct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path_cond cond = {\n\t\td_backing_inode(old_dentry)->i_uid,\n\t\td_backing_inode(old_dentry)->i_mode\n\t};\n\tchar *buffer = NULL, *buffer2 = NULL;\n\tstruct aa_profile *profile;\n\tint error;\n\n\t \n\tbuffer = aa_get_buffer(false);\n\tbuffer2 = aa_get_buffer(false);\n\terror = -ENOMEM;\n\tif (!buffer || !buffer2)\n\t\tgoto out;\n\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_link(subj_cred, profile, &link, buffer,\n\t\t\t\t\t  &target, buffer2, &cond));\nout:\n\taa_put_buffer(buffer);\n\taa_put_buffer(buffer2);\n\treturn error;\n}\n\nstatic void update_file_ctx(struct aa_file_ctx *fctx, struct aa_label *label,\n\t\t\t    u32 request)\n{\n\tstruct aa_label *l, *old;\n\n\t \n\tspin_lock(&fctx->lock);\n\told = rcu_dereference_protected(fctx->label,\n\t\t\t\t\tlockdep_is_held(&fctx->lock));\n\tl = aa_label_merge(old, label, GFP_ATOMIC);\n\tif (l) {\n\t\tif (l != old) {\n\t\t\trcu_assign_pointer(fctx->label, l);\n\t\t\taa_put_label(old);\n\t\t} else\n\t\t\taa_put_label(l);\n\t\tfctx->allow |= request;\n\t}\n\tspin_unlock(&fctx->lock);\n}\n\nstatic int __file_path_perm(const char *op, const struct cred *subj_cred,\n\t\t\t    struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied, bool in_atomic)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(file_mnt_idmap(file),\n\t\t\t\t\t    file_inode(file));\n\tstruct path_cond cond = {\n\t\t.uid = vfsuid_into_kuid(vfsuid),\n\t\t.mode = file_inode(file)->i_mode\n\t};\n\tchar *buffer;\n\tint flags, error;\n\n\t \n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\t \n\t\treturn 0;\n\n\tflags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);\n\tbuffer = aa_get_buffer(in_atomic);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t \n\terror = fn_for_each_not_in_set(flabel, label, profile,\n\t\t\tprofile_path_perm(op, subj_cred, profile,\n\t\t\t\t\t  &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms));\n\tif (denied && !error) {\n\t\t \n\t\tif (label == flabel)\n\t\t\terror = fn_for_each(label, profile,\n\t\t\t\tprofile_path_perm(op, subj_cred,\n\t\t\t\t\t\t  profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t\telse\n\t\t\terror = fn_for_each_not_in_set(label, flabel, profile,\n\t\t\t\tprofile_path_perm(op, subj_cred,\n\t\t\t\t\t\t  profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\taa_put_buffer(buffer);\n\n\treturn error;\n}\n\nstatic int __file_sock_perm(const char *op, const struct cred *subj_cred,\n\t\t\t    struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied)\n{\n\tstruct socket *sock = (struct socket *) file->private_data;\n\tint error;\n\n\tAA_BUG(!sock);\n\n\t \n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\treturn 0;\n\n\t \n\terror = aa_sock_file_perm(subj_cred, label, op, request, sock);\n\tif (denied) {\n\t\t \n\t\t \n\t\tlast_error(error, aa_sock_file_perm(subj_cred, flabel, op,\n\t\t\t\t\t\t    request, sock));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\treturn error;\n}\n\n \nint aa_file_perm(const char *op, const struct cred *subj_cred,\n\t\t struct aa_label *label, struct file *file,\n\t\t u32 request, bool in_atomic)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t \n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label))) {\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\n\tflabel  = aa_get_newest_label(flabel);\n\trcu_read_unlock();\n\t \n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, subj_cred, label, flabel, file,\n\t\t\t\t\t request, denied, in_atomic);\n\n\telse if (S_ISSOCK(file_inode(file)->i_mode))\n\t\terror = __file_sock_perm(op, subj_cred, label, flabel, file,\n\t\t\t\t\t request, denied);\n\taa_put_label(flabel);\n\ndone:\n\treturn error;\n}\n\nstatic void revalidate_tty(const struct cred *subj_cred, struct aa_label *label)\n{\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock(&tty->files_lock);\n\tif (!list_empty(&tty->tty_files)) {\n\t\tstruct tty_file_private *file_priv;\n\t\tstruct file *file;\n\t\t \n\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t     struct tty_file_private, list);\n\t\tfile = file_priv->file;\n\n\t\tif (aa_file_perm(OP_INHERIT, subj_cred, label, file,\n\t\t\t\t MAY_READ | MAY_WRITE, IN_ATOMIC))\n\t\t\tdrop_tty = 1;\n\t}\n\tspin_unlock(&tty->files_lock);\n\ttty_kref_put(tty);\n\n\tif (drop_tty)\n\t\tno_tty();\n}\n\nstruct cred_label {\n\tconst struct cred *cred;\n\tstruct aa_label *label;\n};\n\nstatic int match_file(const void *p, struct file *file, unsigned int fd)\n{\n\tstruct cred_label *cl = (struct cred_label *)p;\n\n\tif (aa_file_perm(OP_INHERIT, cl->cred, cl->label, file,\n\t\t\t aa_map_file_to_perms(file), IN_ATOMIC))\n\t\treturn fd + 1;\n\treturn 0;\n}\n\n\n \nvoid aa_inherit_files(const struct cred *cred, struct files_struct *files)\n{\n\tstruct aa_label *label = aa_get_newest_cred_label(cred);\n\tstruct cred_label cl = {\n\t\t.cred = cred,\n\t\t.label = label,\n\t};\n\tstruct file *devnull = NULL;\n\tunsigned int n;\n\n\trevalidate_tty(cred, label);\n\n\t \n\tn = iterate_fd(files, 0, match_file, &cl);\n\tif (!n)  \n\t\tgoto out;\n\n\tdevnull = dentry_open(&aa_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t \n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, &cl)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\nout:\n\taa_put_label(label);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}