{
  "module_name": "resource.c",
  "hash_id": "eedbfbaf14d09d7c94ac1b2f9fa4b4c05617cf1a5329e7fa1e8e6dbaf7d83b82",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/resource.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/security.h>\n\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/resource.h\"\n#include \"include/policy.h\"\n\n \n#include \"rlim_names.h\"\n\nstruct aa_sfs_entry aa_sfs_entry_rlimit[] = {\n\tAA_SFS_FILE_STRING(\"mask\", AA_SFS_RLIMIT_MASK),\n\t{ }\n};\n\n \nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\taudit_log_format(ab, \" rlimit=%s value=%lu\",\n\t\t\t rlim_names[ad->rlim.rlim], ad->rlim.max);\n\tif (ad->peer) {\n\t\taudit_log_format(ab, \" peer=\");\n\t\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\t\tFLAGS_NONE, GFP_ATOMIC);\n\t}\n}\n\n \nstatic int audit_resource(const struct cred *subj_cred,\n\t\t\t  struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_RLIMITS,\n\t\t\t  OP_SETRLIMIT);\n\n\tad.subj_cred = subj_cred;\n\tad.rlim.rlim = resource;\n\tad.rlim.max = value;\n\tad.peer = peer;\n\tad.info = info;\n\tad.error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &ad, audit_cb);\n}\n\n \nint aa_map_resource(int resource)\n{\n\treturn rlim_map[resource];\n}\n\nstatic int profile_setrlimit(const struct cred *subj_cred,\n\t\t\t     struct aa_profile *profile, unsigned int resource,\n\t\t\t     struct rlimit *new_rlim)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tint e = 0;\n\n\tif (rules->rlimits.mask & (1 << resource) && new_rlim->rlim_max >\n\t    rules->rlimits.limits[resource].rlim_max)\n\t\te = -EACCES;\n\treturn audit_resource(subj_cred, profile, resource, new_rlim->rlim_max,\n\t\t\t      NULL, NULL, e);\n}\n\n \nint aa_task_setrlimit(const struct cred *subj_cred, struct aa_label *label,\n\t\t      struct task_struct *task,\n\t\t      unsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *peer;\n\tint error = 0;\n\n\trcu_read_lock();\n\tpeer = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\t \n\n\tif (label != peer &&\n\t    aa_capable(subj_cred, label, CAP_SYS_RESOURCE, CAP_OPT_NOAUDIT) != 0)\n\t\terror = fn_for_each(label, profile,\n\t\t\t\taudit_resource(subj_cred, profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES));\n\telse\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tprofile_setrlimit(subj_cred, profile, resource,\n\t\t\t\t\t\t  new_rlim));\n\taa_put_label(peer);\n\n\treturn error;\n}\n\n \nvoid __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)\n{\n\tunsigned int mask = 0;\n\tstruct rlimit *rlim, *initrlim;\n\tstruct aa_profile *old, *new;\n\tstruct label_it i;\n\n\told = labels_profile(old_l);\n\tnew = labels_profile(new_l);\n\n\t \n\tlabel_for_each_confined(i, old_l, old) {\n\t\tstruct aa_ruleset *rules = list_first_entry(&old->rules,\n\t\t\t\t\t\t\t    typeof(*rules),\n\t\t\t\t\t\t\t    list);\n\t\tif (rules->rlimits.mask) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++,\n\t\t\t\t     mask <<= 1) {\n\t\t\t\tif (rules->rlimits.mask & mask) {\n\t\t\t\t\trlim = current->signal->rlim + j;\n\t\t\t\t\tinitrlim = init_task.signal->rlim + j;\n\t\t\t\t\trlim->rlim_cur = min(rlim->rlim_max,\n\t\t\t\t\t\t\t    initrlim->rlim_cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlabel_for_each_confined(i, new_l, new) {\n\t\tstruct aa_ruleset *rules = list_first_entry(&new->rules,\n\t\t\t\t\t\t\t    typeof(*rules),\n\t\t\t\t\t\t\t    list);\n\t\tint j;\n\n\t\tif (!rules->rlimits.mask)\n\t\t\tcontinue;\n\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++, mask <<= 1) {\n\t\t\tif (!(rules->rlimits.mask & mask))\n\t\t\t\tcontinue;\n\n\t\t\trlim = current->signal->rlim + j;\n\t\t\trlim->rlim_max = min(rlim->rlim_max,\n\t\t\t\t\t     rules->rlimits.limits[j].rlim_max);\n\t\t\t \n\t\t\trlim->rlim_cur = min(rlim->rlim_cur, rlim->rlim_max);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}