{
  "module_name": "apparmorfs.c",
  "hash_id": "049020bbcea5109c4f23faf9500eca1f953db127276df4383ac9fafe750752ff",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/apparmorfs.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/poll.h>\n#include <linux/zstd.h>\n#include <uapi/linux/major.h>\n#include <uapi/linux/magic.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/crypto.h\"\n#include \"include/ipc.h\"\n#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/policy_ns.h\"\n#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/task.h\"\n\n \n\n\n \n\nstruct rawdata_f_data {\n\tstruct aa_loaddata *loaddata;\n};\n\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n#define RAWDATA_F_DATA_BUF(p) (char *)(p + 1)\n\nstatic void rawdata_f_data_free(struct rawdata_f_data *private)\n{\n\tif (!private)\n\t\treturn;\n\n\taa_put_loaddata(private->loaddata);\n\tkvfree(private);\n}\n\nstatic struct rawdata_f_data *rawdata_f_data_alloc(size_t size)\n{\n\tstruct rawdata_f_data *ret;\n\n\tif (size > SIZE_MAX - sizeof(*ret))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = kvzalloc(sizeof(*ret) + size, GFP_KERNEL);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn ret;\n}\n#endif\n\n \nstatic int mangle_name(const char *name, char *target)\n{\n\tchar *t = target;\n\n\twhile (*name == '/' || *name == '.')\n\t\tname++;\n\n\tif (target) {\n\t\tfor (; *name; name++) {\n\t\t\tif (*name == '/')\n\t\t\t\t*(t)++ = '.';\n\t\t\telse if (isspace(*name))\n\t\t\t\t*(t)++ = '_';\n\t\t\telse if (isalnum(*name) || strchr(\"._-\", *name))\n\t\t\t\t*(t)++ = *name;\n\t\t}\n\n\t\t*t = 0;\n\t} else {\n\t\tint len = 0;\n\t\tfor (; *name; name++) {\n\t\t\tif (isalnum(*name) || isspace(*name) ||\n\t\t\t    strchr(\"/._-\", *name))\n\t\t\t\tlen++;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn t - target;\n}\n\n\n \n\n#define AAFS_NAME\t\t\"apparmorfs\"\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\n\n\nstatic int aafs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tseq_printf(seq, \"%s:[%lu]\", AAFS_NAME, d_inode(dentry)->i_ino);\n\treturn 0;\n}\n\nstatic void aafs_free_inode(struct inode *inode)\n{\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tfree_inode_nonrcu(inode);\n}\n\nstatic const struct super_operations aafs_super_ops = {\n\t.statfs = simple_statfs,\n\t.free_inode = aafs_free_inode,\n\t.show_path = aafs_show_path,\n};\n\nstatic int apparmorfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstatic struct tree_descr files[] = { {\"\"} };\n\tint error;\n\n\terror = simple_fill_super(sb, AAFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\tsb->s_op = &aafs_super_ops;\n\n\treturn 0;\n}\n\nstatic int apparmorfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, apparmorfs_fill_super);\n}\n\nstatic const struct fs_context_operations apparmorfs_context_ops = {\n\t.get_tree\t= apparmorfs_get_tree,\n};\n\nstatic int apparmorfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &apparmorfs_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.init_fs_context = apparmorfs_init_fs_context,\n\t.kill_sb = kill_anon_super,\n};\n\n \nstatic int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}\n\n \nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}\n\n \nstatic struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}\n\n \nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}\n\n \nstatic void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}\n\n\n \n\n \nstatic struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t \n\t\treturn ERR_PTR(-ESPIPE);\n\n\t \n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\taa_put_loaddata(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}\n\nstatic ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t \n\terror = aa_may_manage_policy(current_cred(), label, ns, mask);\n\tif (error)\n\t\tgoto end_section;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\nend_section:\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}\n\n \nstatic ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\n\t\t\t    loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY, buf, size, pos, ns);\n\n\taa_put_ns(ns);\n\n\treturn error;\n}\n\nstatic const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};\n\n \nstatic ssize_t profile_replace(struct file *f, const char __user *buf,\n\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY | AA_MAY_REPLACE_POLICY,\n\t\t\t\t  buf, size, pos, ns);\n\taa_put_ns(ns);\n\n\treturn error;\n}\n\nstatic const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};\n\n \nstatic ssize_t profile_remove(struct file *f, const char __user *buf,\n\t\t\t      size_t size, loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\n\tlabel = begin_current_label_crit_section();\n\t \n\terror = aa_may_manage_policy(current_cred(), label, ns,\n\t\t\t\t     AA_MAY_REMOVE_POLICY);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tdata = aa_simple_write_to_buffer(buf, size + 1, size, pos);\n\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\tdata->data[size] = 0;\n\t\terror = aa_remove_profiles(ns, label, data->data, size);\n\t\taa_put_loaddata(data);\n\t}\n out:\n\tend_current_label_crit_section(label);\n\taa_put_ns(ns);\n\treturn error;\n}\n\nstatic const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};\n\nstruct aa_revision {\n\tstruct aa_ns *ns;\n\tlong last_read;\n};\n\n \nstatic int ns_revision_release(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = file->private_data;\n\n\tif (rev) {\n\t\taa_put_ns(rev->ns);\n\t\tkfree(rev);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ns_revision_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *ppos)\n{\n\tstruct aa_revision *rev = file->private_data;\n\tchar buffer[32];\n\tlong last_read;\n\tint avail;\n\n\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\tlast_read = rev->last_read;\n\tif (last_read == rev->ns->revision) {\n\t\tmutex_unlock(&rev->ns->lock);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (wait_event_interruptible(rev->ns->wait,\n\t\t\t\t\t     last_read !=\n\t\t\t\t\t     READ_ONCE(rev->ns->revision)))\n\t\t\treturn -ERESTARTSYS;\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t}\n\n\tavail = sprintf(buffer, \"%ld\\n\", rev->ns->revision);\n\tif (*ppos + size > avail) {\n\t\trev->last_read = rev->ns->revision;\n\t\t*ppos = 0;\n\t}\n\tmutex_unlock(&rev->ns->lock);\n\n\treturn simple_read_from_buffer(buf, size, ppos, buffer, avail);\n}\n\nstatic int ns_revision_open(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = kzalloc(sizeof(*rev), GFP_KERNEL);\n\n\tif (!rev)\n\t\treturn -ENOMEM;\n\n\trev->ns = aa_get_ns(inode->i_private);\n\tif (!rev->ns)\n\t\trev->ns = aa_get_current_ns();\n\tfile->private_data = rev;\n\n\treturn 0;\n}\n\nstatic __poll_t ns_revision_poll(struct file *file, poll_table *pt)\n{\n\tstruct aa_revision *rev = file->private_data;\n\t__poll_t mask = 0;\n\n\tif (rev) {\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t\tpoll_wait(file, &rev->ns->wait, pt);\n\t\tif (rev->last_read < rev->ns->revision)\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\tmutex_unlock(&rev->ns->lock);\n\t}\n\n\treturn mask;\n}\n\nvoid __aa_bump_ns_revision(struct aa_ns *ns)\n{\n\tWRITE_ONCE(ns->revision, READ_ONCE(ns->revision) + 1);\n\twake_up_interruptible(&ns->wait);\n}\n\nstatic const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};\n\nstatic void profile_query_cb(struct aa_profile *profile, struct aa_perms *perms,\n\t\t\t     const char *match_str, size_t match_len)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms tmp = { };\n\taa_state_t state = DFA_NOMATCH;\n\n\tif (profile_unconfined(profile))\n\t\treturn;\n\tif (rules->file.dfa && *match_str == AA_CLASS_FILE) {\n\t\tstate = aa_dfa_match_len(rules->file.dfa,\n\t\t\t\t\t rules->file.start[AA_CLASS_FILE],\n\t\t\t\t\t match_str + 1, match_len - 1);\n\t\tif (state) {\n\t\t\tstruct path_cond cond = { };\n\n\t\t\ttmp = *(aa_lookup_fperms(&(rules->file), state, &cond));\n\t\t}\n\t} else if (rules->policy.dfa) {\n\t\tif (!RULE_MEDIATES(rules, *match_str))\n\t\t\treturn;\t \n\t\tstate = aa_dfa_match_len(rules->policy.dfa,\n\t\t\t\t\t rules->policy.start[0],\n\t\t\t\t\t match_str, match_len);\n\t\tif (state)\n\t\t\ttmp = *aa_lookup_perms(&rules->policy, state);\n\t}\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum_raw(perms, &tmp);\n}\n\n\n \nstatic ssize_t query_data(char *buf, size_t buf_len,\n\t\t\t  char *query, size_t query_len)\n{\n\tchar *out;\n\tconst char *key;\n\tstruct label_it i;\n\tstruct aa_label *label, *curr;\n\tstruct aa_profile *profile;\n\tstruct aa_data *data;\n\tu32 bytes, blocks;\n\t__le32 outle32;\n\n\tif (!query_len)\n\t\treturn -EINVAL;  \n\n\tkey = query + strnlen(query, query_len) + 1;\n\tif (key + 1 >= query + query_len)\n\t\treturn -EINVAL;  \n\tif (key + strnlen(key, query + query_len - key) >= query + query_len)\n\t\treturn -EINVAL;  \n\n\tif (buf_len < sizeof(bytes) + sizeof(blocks))\n\t\treturn -EINVAL;  \n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, query, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t \n\tmemset(buf, 0, sizeof(bytes) + sizeof(blocks));\n\tout = buf + sizeof(bytes) + sizeof(blocks);\n\n\tblocks = 0;\n\tlabel_for_each_confined(i, label, profile) {\n\t\tif (!profile->data)\n\t\t\tcontinue;\n\n\t\tdata = rhashtable_lookup_fast(profile->data, &key,\n\t\t\t\t\t      profile->data->p);\n\n\t\tif (data) {\n\t\t\tif (out + sizeof(outle32) + data->size > buf +\n\t\t\t    buf_len) {\n\t\t\t\taa_put_label(label);\n\t\t\t\treturn -EINVAL;  \n\t\t\t}\n\t\t\toutle32 = __cpu_to_le32(data->size);\n\t\t\tmemcpy(out, &outle32, sizeof(outle32));\n\t\t\tout += sizeof(outle32);\n\t\t\tmemcpy(out, data->data, data->size);\n\t\t\tout += data->size;\n\t\t\tblocks++;\n\t\t}\n\t}\n\taa_put_label(label);\n\n\toutle32 = __cpu_to_le32(out - buf - sizeof(bytes));\n\tmemcpy(buf, &outle32, sizeof(outle32));\n\toutle32 = __cpu_to_le32(blocks);\n\tmemcpy(buf + sizeof(bytes), &outle32, sizeof(outle32));\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t query_label(char *buf, size_t buf_len,\n\t\t\t   char *query, size_t query_len, bool view_only)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *label, *curr;\n\tchar *label_name, *match_str;\n\tsize_t label_name_len, match_len;\n\tstruct aa_perms perms;\n\tstruct label_it i;\n\n\tif (!query_len)\n\t\treturn -EINVAL;\n\n\tlabel_name = query;\n\tlabel_name_len = strnlen(query, query_len);\n\tif (!label_name_len || label_name_len == query_len)\n\t\treturn -EINVAL;\n\n\t \n\tmatch_str = label_name + label_name_len + 1;\n\tmatch_len = query_len - label_name_len - 1;\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, label_name, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tperms = allperms;\n\tif (view_only) {\n\t\tlabel_for_each_in_ns(i, labels_ns(label), label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t} else {\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t}\n\taa_put_label(label);\n\n\treturn scnprintf(buf, buf_len,\n\t\t      \"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\",\n\t\t      perms.allow, perms.deny, perms.audit, perms.quiet);\n}\n\n \nstruct multi_transaction {\n\tstruct kref count;\n\tssize_t size;\n\tchar data[];\n};\n\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic void multi_transaction_kref(struct kref *kref)\n{\n\tstruct multi_transaction *t;\n\n\tt = container_of(kref, struct multi_transaction, count);\n\tfree_page((unsigned long) t);\n}\n\nstatic struct multi_transaction *\nget_multi_transaction(struct multi_transaction *t)\n{\n\tif  (t)\n\t\tkref_get(&(t->count));\n\n\treturn t;\n}\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}\n\n \nstatic void multi_transaction_set(struct file *file,\n\t\t\t\t  struct multi_transaction *new, size_t n)\n{\n\tstruct multi_transaction *old;\n\n\tAA_BUG(n > MULTI_TRANSACTION_LIMIT);\n\n\tnew->size = n;\n\tspin_lock(&file->f_lock);\n\told = (struct multi_transaction *) file->private_data;\n\tfile->private_data = new;\n\tspin_unlock(&file->f_lock);\n\tput_multi_transaction(old);\n}\n\nstatic struct multi_transaction *multi_transaction_new(struct file *file,\n\t\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t\t       size_t size)\n{\n\tstruct multi_transaction *t;\n\n\tif (size > MULTI_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tt = (struct multi_transaction *)get_zeroed_page(GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&t->count);\n\tif (copy_from_user(t->data, buf, size)) {\n\t\tput_multi_transaction(t);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn t;\n}\n\nstatic ssize_t multi_transaction_read(struct file *file, char __user *buf,\n\t\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct multi_transaction *t;\n\tssize_t ret;\n\n\tspin_lock(&file->f_lock);\n\tt = get_multi_transaction(file->private_data);\n\tspin_unlock(&file->f_lock);\n\n\tif (!t)\n\t\treturn 0;\n\n\tret = simple_read_from_buffer(buf, size, pos, t->data, t->size);\n\tput_multi_transaction(t);\n\n\treturn ret;\n}\n\nstatic int multi_transaction_release(struct inode *inode, struct file *file)\n{\n\tput_multi_transaction(file->private_data);\n\n\treturn 0;\n}\n\n#define QUERY_CMD_LABEL\t\t\"label\\0\"\n#define QUERY_CMD_LABEL_LEN\t6\n#define QUERY_CMD_PROFILE\t\"profile\\0\"\n#define QUERY_CMD_PROFILE_LEN\t8\n#define QUERY_CMD_LABELALL\t\"labelall\\0\"\n#define QUERY_CMD_LABELALL_LEN\t9\n#define QUERY_CMD_DATA\t\t\"data\\0\"\n#define QUERY_CMD_DATA_LEN\t5\n\n \nstatic ssize_t aa_write_access(struct file *file, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct multi_transaction *t;\n\tssize_t len;\n\n\tif (*ppos)\n\t\treturn -ESPIPE;\n\n\tt = multi_transaction_new(file, ubuf, count);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\tif (count > QUERY_CMD_PROFILE_LEN &&\n\t    !memcmp(t->data, QUERY_CMD_PROFILE, QUERY_CMD_PROFILE_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_PROFILE_LEN,\n\t\t\t\t  count - QUERY_CMD_PROFILE_LEN, true);\n\t} else if (count > QUERY_CMD_LABEL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABEL, QUERY_CMD_LABEL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABEL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABEL_LEN, true);\n\t} else if (count > QUERY_CMD_LABELALL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABELALL,\n\t\t\t   QUERY_CMD_LABELALL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABELALL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABELALL_LEN, false);\n\t} else if (count > QUERY_CMD_DATA_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_DATA, QUERY_CMD_DATA_LEN)) {\n\t\tlen = query_data(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t t->data + QUERY_CMD_DATA_LEN,\n\t\t\t\t count - QUERY_CMD_DATA_LEN);\n\t} else\n\t\tlen = -EINVAL;\n\n\tif (len < 0) {\n\t\tput_multi_transaction(t);\n\t\treturn len;\n\t}\n\n\tmulti_transaction_set(file, t, len);\n\n\treturn count;\n}\n\nstatic const struct file_operations aa_sfs_access = {\n\t.write\t\t= aa_write_access,\n\t.read\t\t= multi_transaction_read,\n\t.release\t= multi_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int aa_sfs_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_sfs_entry *fs_file = seq->private;\n\n\tif (!fs_file)\n\t\treturn 0;\n\n\tswitch (fs_file->v_type) {\n\tcase AA_SFS_TYPE_BOOLEAN:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.boolean ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase AA_SFS_TYPE_STRING:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.string);\n\t\tbreak;\n\tcase AA_SFS_TYPE_U64:\n\t\tseq_printf(seq, \"%#08lx\\n\", fs_file->v.u64);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}\n\nconst struct file_operations aa_sfs_seq_file_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= aa_sfs_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n \n\n#define SEQ_PROFILE_FOPS(NAME)\t\t\t\t\t\t      \\\nstatic int seq_profile_ ##NAME ##_open(struct inode *inode, struct file *file)\\\n{\t\t\t\t\t\t\t\t\t      \\\n\treturn seq_profile_open(inode, file, seq_profile_ ##NAME ##_show);    \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic const struct file_operations seq_profile_ ##NAME ##_fops = {\t      \\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t      \\\n\t.open\t\t= seq_profile_ ##NAME ##_open,\t\t\t      \\\n\t.read\t\t= seq_read,\t\t\t\t\t      \\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t      \\\n\t.release\t= seq_profile_release,\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\nstatic int seq_profile_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(inode->i_private);\n\tint error = single_open(file, show, proxy);\n\n\tif (error) {\n\t\tfile->private_data = NULL;\n\t\taa_put_proxy(proxy);\n\t}\n\n\treturn error;\n}\n\nstatic int seq_profile_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\tif (seq)\n\t\taa_put_proxy(seq->private);\n\treturn single_release(inode, file);\n}\n\nstatic int seq_profile_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}\n\nstatic int seq_profile_mode_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", aa_profile_mode_names[profile->mode]);\n\taa_put_label(label);\n\n\treturn 0;\n}\n\nstatic int seq_profile_attach_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tif (profile->attach.xmatch_str)\n\t\tseq_printf(seq, \"%s\\n\", profile->attach.xmatch_str);\n\telse if (profile->attach.xmatch.dfa)\n\t\tseq_puts(seq, \"<unknown>\\n\");\n\telse\n\t\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}\n\nstatic int seq_profile_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tunsigned int i, size = aa_hash_size();\n\n\tif (profile->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", profile->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\taa_put_label(label);\n\n\treturn 0;\n}\n\nSEQ_PROFILE_FOPS(name);\nSEQ_PROFILE_FOPS(mode);\nSEQ_PROFILE_FOPS(attach);\nSEQ_PROFILE_FOPS(hash);\n\n \n\n#define SEQ_NS_FOPS(NAME)\t\t\t\t\t\t      \\\nstatic int seq_ns_ ##NAME ##_open(struct inode *inode, struct file *file)     \\\n{\t\t\t\t\t\t\t\t\t      \\\n\treturn single_open(file, seq_ns_ ##NAME ##_show, inode->i_private);   \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic const struct file_operations seq_ns_ ##NAME ##_fops = {\t      \\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t      \\\n\t.open\t\t= seq_ns_ ##NAME ##_open,\t\t\t      \\\n\t.read\t\t= seq_read,\t\t\t\t\t      \\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t      \\\n\t.release\t= single_release,\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\nstatic int seq_ns_stacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%s\\n\", label->size > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}\n\nstatic int seq_ns_nsstacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\tstruct aa_profile *profile;\n\tstruct label_it it;\n\tint count = 1;\n\n\tlabel = begin_current_label_crit_section();\n\n\tif (label->size > 1) {\n\t\tlabel_for_each(it, label, profile)\n\t\t\tif (profile->ns != labels_ns(label)) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tseq_printf(seq, \"%s\\n\", count > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}\n\nstatic int seq_ns_level_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%d\\n\", labels_ns(label)->level);\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}\n\nstatic int seq_ns_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label = begin_current_label_crit_section();\n\tseq_printf(seq, \"%s\\n\", labels_ns(label)->base.name);\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}\n\nstatic int seq_ns_compress_min_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"%d\\n\", AA_MIN_CLEVEL);\n\treturn 0;\n}\n\nstatic int seq_ns_compress_max_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"%d\\n\", AA_MAX_CLEVEL);\n\treturn 0;\n}\n\nSEQ_NS_FOPS(stacked);\nSEQ_NS_FOPS(nsstacked);\nSEQ_NS_FOPS(level);\nSEQ_NS_FOPS(name);\nSEQ_NS_FOPS(compress_min);\nSEQ_NS_FOPS(compress_max);\n\n\n \n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n#define SEQ_RAWDATA_FOPS(NAME)\t\t\t\t\t\t      \\\nstatic int seq_rawdata_ ##NAME ##_open(struct inode *inode, struct file *file)\\\n{\t\t\t\t\t\t\t\t\t      \\\n\treturn seq_rawdata_open(inode, file, seq_rawdata_ ##NAME ##_show);    \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic const struct file_operations seq_rawdata_ ##NAME ##_fops = {\t      \\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t      \\\n\t.open\t\t= seq_rawdata_ ##NAME ##_open,\t\t\t      \\\n\t.read\t\t= seq_read,\t\t\t\t\t      \\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t      \\\n\t.release\t= seq_rawdata_release,\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\nstatic int seq_rawdata_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_loaddata *data = __aa_get_loaddata(inode->i_private);\n\tint error;\n\n\tif (!data)\n\t\t \n\t\treturn -ENOENT;\n\n\terror = single_open(file, show, data);\n\tif (error) {\n\t\tAA_BUG(file->private_data &&\n\t\t       ((struct seq_file *)file->private_data)->private);\n\t\taa_put_loaddata(data);\n\t}\n\n\treturn error;\n}\n\nstatic int seq_rawdata_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\n\tif (seq)\n\t\taa_put_loaddata(seq->private);\n\n\treturn single_release(inode, file);\n}\n\nstatic int seq_rawdata_abi_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"v%d\\n\", data->abi);\n\n\treturn 0;\n}\n\nstatic int seq_rawdata_revision_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"%ld\\n\", data->revision);\n\n\treturn 0;\n}\n\nstatic int seq_rawdata_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\tunsigned int i, size = aa_hash_size();\n\n\tif (data->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", data->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\n\treturn 0;\n}\n\nstatic int seq_rawdata_compressed_size_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"%zu\\n\", data->compressed_size);\n\n\treturn 0;\n}\n\nSEQ_RAWDATA_FOPS(abi);\nSEQ_RAWDATA_FOPS(revision);\nSEQ_RAWDATA_FOPS(hash);\nSEQ_RAWDATA_FOPS(compressed_size);\n\nstatic int decompress_zstd(char *src, size_t slen, char *dst, size_t dlen)\n{\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n\tif (slen < dlen) {\n\t\tconst size_t wksp_len = zstd_dctx_workspace_bound();\n\t\tzstd_dctx *ctx;\n\t\tvoid *wksp;\n\t\tsize_t out_len;\n\t\tint ret = 0;\n\n\t\twksp = kvzalloc(wksp_len, GFP_KERNEL);\n\t\tif (!wksp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tctx = zstd_init_dctx(wksp, wksp_len);\n\t\tif (ctx == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tout_len = zstd_decompress_dctx(ctx, dst, dlen, src, slen);\n\t\tif (zstd_is_error(out_len)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\ncleanup:\n\t\tkvfree(wksp);\n\t\treturn ret;\n\t}\n#endif\n\n\tif (dlen < slen)\n\t\treturn -EINVAL;\n\tmemcpy(dst, src, slen);\n\treturn 0;\n}\n\nstatic ssize_t rawdata_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct rawdata_f_data *private = file->private_data;\n\n\treturn simple_read_from_buffer(buf, size, ppos,\n\t\t\t\t       RAWDATA_F_DATA_BUF(private),\n\t\t\t\t       private->loaddata->size);\n}\n\nstatic int rawdata_release(struct inode *inode, struct file *file)\n{\n\trawdata_f_data_free(file->private_data);\n\n\treturn 0;\n}\n\nstatic int rawdata_open(struct inode *inode, struct file *file)\n{\n\tint error;\n\tstruct aa_loaddata *loaddata;\n\tstruct rawdata_f_data *private;\n\n\tif (!aa_current_policy_view_capable(NULL))\n\t\treturn -EACCES;\n\n\tloaddata = __aa_get_loaddata(inode->i_private);\n\tif (!loaddata)\n\t\t \n\t\treturn -ENOENT;\n\n\tprivate = rawdata_f_data_alloc(loaddata->size);\n\tif (IS_ERR(private)) {\n\t\terror = PTR_ERR(private);\n\t\tgoto fail_private_alloc;\n\t}\n\n\tprivate->loaddata = loaddata;\n\n\terror = decompress_zstd(loaddata->data, loaddata->compressed_size,\n\t\t\t\tRAWDATA_F_DATA_BUF(private),\n\t\t\t\tloaddata->size);\n\tif (error)\n\t\tgoto fail_decompress;\n\n\tfile->private_data = private;\n\treturn 0;\n\nfail_decompress:\n\trawdata_f_data_free(private);\n\treturn error;\n\nfail_private_alloc:\n\taa_put_loaddata(loaddata);\n\treturn error;\n}\n\nstatic const struct file_operations rawdata_fops = {\n\t.open = rawdata_open,\n\t.read = rawdata_read,\n\t.llseek = generic_file_llseek,\n\t.release = rawdata_release,\n};\n\nstatic void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t \n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}\n\nvoid __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}\n\nint __aa_fs_create_rawdata(struct aa_ns *ns, struct aa_loaddata *rawdata)\n{\n\tstruct dentry *dent, *dir;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!rawdata);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\tAA_BUG(!ns_subdata_dir(ns));\n\n\t \n\trawdata->name = kasprintf(GFP_KERNEL, \"%ld\", ns->revision);\n\tif (!rawdata->name)\n\t\treturn -ENOMEM;\n\n\tdir = aafs_create_dir(rawdata->name, ns_subdata_dir(ns));\n\tif (IS_ERR(dir))\n\t\t \n\t\treturn PTR_ERR(dir);\n\trawdata->dents[AAFS_LOADDATA_DIR] = dir;\n\n\tdent = aafs_create_file(\"abi\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_abi_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_ABI] = dent;\n\n\tdent = aafs_create_file(\"revision\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_revision_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_REVISION] = dent;\n\n\tif (aa_g_hash_policy) {\n\t\tdent = aafs_create_file(\"sha1\", S_IFREG | 0444, dir,\n\t\t\t\t\t      rawdata, &seq_rawdata_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\trawdata->dents[AAFS_LOADDATA_HASH] = dent;\n\t}\n\n\tdent = aafs_create_file(\"compressed_size\", S_IFREG | 0444, dir,\n\t\t\t\trawdata,\n\t\t\t\t&seq_rawdata_compressed_size_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_COMPRESSED_SIZE] = dent;\n\n\tdent = aafs_create_file(\"raw_data\", S_IFREG | 0444,\n\t\t\t\t      dir, rawdata, &rawdata_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_DATA] = dent;\n\td_inode(dent)->i_size = rawdata->size;\n\n\trawdata->ns = aa_get_ns(ns);\n\tlist_add(&rawdata->list, &ns->rawdata_list);\n\t \n\n\treturn 0;\n\nfail:\n\tremove_rawdata_dents(rawdata);\n\n\treturn PTR_ERR(dent);\n}\n#endif  \n\n\n \n\n \nvoid __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}\n\n \nvoid __aafs_profile_migrate_dents(struct aa_profile *old,\n\t\t\t\t  struct aa_profile *new)\n{\n\tint i;\n\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(old)->lock));\n\n\tfor (i = 0; i < AAFS_PROF_SIZEOF; i++) {\n\t\tnew->dents[i] = old->dents[i];\n\t\tif (new->dents[i]) {\n\t\t\tstruct inode *inode = d_inode(new->dents[i]);\n\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\t}\n\t\told->dents[i] = NULL;\n\t}\n}\n\nstatic struct dentry *create_profile_file(struct dentry *dir, const char *name,\n\t\t\t\t\t  struct aa_profile *profile,\n\t\t\t\t\t  const struct file_operations *fops)\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(profile->label.proxy);\n\tstruct dentry *dent;\n\n\tdent = aafs_create_file(name, S_IFREG | 0444, dir, proxy, fops);\n\tif (IS_ERR(dent))\n\t\taa_put_proxy(proxy);\n\n\treturn dent;\n}\n\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\nstatic int profile_depth(struct aa_profile *profile)\n{\n\tint depth = 0;\n\n\trcu_read_lock();\n\tfor (depth = 0; profile; profile = rcu_access_pointer(profile->parent))\n\t\tdepth++;\n\trcu_read_unlock();\n\n\treturn depth;\n}\n\nstatic char *gen_symlink_name(int depth, const char *dirname, const char *fname)\n{\n\tchar *buffer, *s;\n\tint error;\n\tint size = depth * 6 + strlen(dirname) + strlen(fname) + 11;\n\n\ts = buffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (; depth > 0; depth--) {\n\t\tstrcpy(s, \"../../\");\n\t\ts += 6;\n\t\tsize -= 6;\n\t}\n\n\terror = snprintf(s, size, \"raw_data/%s/%s\", dirname, fname);\n\tif (error >= size || error < 0) {\n\t\tkfree(buffer);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\treturn buffer;\n}\n\nstatic void rawdata_link_cb(void *arg)\n{\n\tkfree(arg);\n}\n\nstatic const char *rawdata_get_link_base(struct dentry *dentry,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct delayed_call *done,\n\t\t\t\t\t const char *name)\n{\n\tstruct aa_proxy *proxy = inode->i_private;\n\tstruct aa_label *label;\n\tstruct aa_profile *profile;\n\tchar *target;\n\tint depth;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tlabel = aa_get_label_rcu(&proxy->label);\n\tprofile = labels_profile(label);\n\tdepth = profile_depth(profile);\n\ttarget = gen_symlink_name(depth, profile->rawdata->name, name);\n\taa_put_label(label);\n\n\tif (IS_ERR(target))\n\t\treturn target;\n\n\tset_delayed_call(done, rawdata_link_cb, target);\n\n\treturn target;\n}\n\nstatic const char *rawdata_get_link_sha1(struct dentry *dentry,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct delayed_call *done)\n{\n\treturn rawdata_get_link_base(dentry, inode, done, \"sha1\");\n}\n\nstatic const char *rawdata_get_link_abi(struct dentry *dentry,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct delayed_call *done)\n{\n\treturn rawdata_get_link_base(dentry, inode, done, \"abi\");\n}\n\nstatic const char *rawdata_get_link_data(struct dentry *dentry,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct delayed_call *done)\n{\n\treturn rawdata_get_link_base(dentry, inode, done, \"raw_data\");\n}\n\nstatic const struct inode_operations rawdata_link_sha1_iops = {\n\t.get_link\t= rawdata_get_link_sha1,\n};\n\nstatic const struct inode_operations rawdata_link_abi_iops = {\n\t.get_link\t= rawdata_get_link_abi,\n};\nstatic const struct inode_operations rawdata_link_data_iops = {\n\t.get_link\t= rawdata_get_link_data,\n};\n#endif  \n\n \nint __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t \n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n\tif (profile->rawdata) {\n\t\tif (aa_g_hash_policy) {\n\t\t\tdent = aafs_create(\"raw_sha1\", S_IFLNK | 0444, dir,\n\t\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t\t   &rawdata_link_sha1_iops);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto fail;\n\t\t\taa_get_proxy(profile->label.proxy);\n\t\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\t\t}\n\t\tdent = aafs_create(\"raw_abi\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_abi_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\tdent = aafs_create(\"raw_data\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_data_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n#endif  \n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}\n\nstatic int ns_mkdir_op(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct aa_ns *ns, *parent;\n\t \n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(current_cred(), label, NULL,\n\t\t\t\t     AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\tparent = aa_get_ns(dir->i_private);\n\tAA_BUG(d_inode(ns_subns_dir(parent)) != dir);\n\n\t \n\tinode_unlock(dir);\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tif (error)\n\t\tgoto out;\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode | S_IFDIR,  NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\tif (error)\n\t\tgoto out_pin;\n\n\tns = __aa_find_or_create_ns(parent, READ_ONCE(dentry->d_name.name),\n\t\t\t\t    dentry);\n\tif (IS_ERR(ns)) {\n\t\terror = PTR_ERR(ns);\n\t\tns = NULL;\n\t}\n\n\taa_put_ns(ns);\t\t \nout_pin:\n\tif (error)\n\t\tsimple_release_fs(&aafs_mnt, &aafs_count);\nout:\n\tmutex_unlock(&parent->lock);\n\taa_put_ns(parent);\n\n\treturn error;\n}\n\nstatic int ns_rmdir_op(struct inode *dir, struct dentry *dentry)\n{\n\tstruct aa_ns *ns, *parent;\n\t \n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(current_cred(), label, NULL,\n\t\t\t\t     AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\tparent = aa_get_ns(dir->i_private);\n\t \n\tinode_unlock(dir);\n\tinode_unlock(dentry->d_inode);\n\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tns = aa_get_ns(__aa_findn_ns(&parent->sub_ns, dentry->d_name.name,\n\t\t\t\t     dentry->d_name.len));\n\tif (!ns) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\tAA_BUG(ns_dir(ns) != dentry);\n\n\t__aa_remove_ns(ns);\n\taa_put_ns(ns);\n\nout:\n\tmutex_unlock(&parent->lock);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tinode_lock(dentry->d_inode);\n\taa_put_ns(parent);\n\n\treturn error;\n}\n\nstatic const struct inode_operations ns_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= ns_mkdir_op,\n\t.rmdir\t\t= ns_rmdir_op,\n};\n\nstatic void __aa_fs_list_remove_rawdata(struct aa_ns *ns)\n{\n\tstruct aa_loaddata *ent, *tmp;\n\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry_safe(ent, tmp, &ns->rawdata_list, list)\n\t\t__aa_fs_remove_rawdata(ent);\n}\n\n \nvoid __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}\n\n \nstatic int __aafs_ns_mkdir_entries(struct aa_ns *ns, struct dentry *dir)\n{\n\tstruct dentry *dent;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!dir);\n\n\tdent = aafs_create_dir(\"profiles\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subprofs_dir(ns) = dent;\n\n\tdent = aafs_create_dir(\"raw_data\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subdata_dir(ns) = dent;\n\n\tdent = aafs_create_file(\"revision\", 0444, dir, ns,\n\t\t\t\t&aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subrevision(ns) = dent;\n\n\tdent = aafs_create_file(\".load\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subload(ns) = dent;\n\n\tdent = aafs_create_file(\".replace\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subreplace(ns) = dent;\n\n\tdent = aafs_create_file(\".remove\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subremove(ns) = dent;\n\n\t   \n\tdent = aafs_create(\"namespaces\", S_IFDIR | 0755, dir, ns, NULL, NULL,\n\t\t\t   &ns_dir_inode_operations);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subns_dir(ns) = dent;\n\n\treturn 0;\n}\n\n \nint __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t \n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t \n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t \n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}\n\n \nstatic struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t \n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t \n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}\n\n \nstatic struct aa_profile *__next_profile(struct aa_profile *p)\n{\n\tstruct aa_profile *parent;\n\tstruct aa_ns *ns = p->ns;\n\n\tAA_BUG(!mutex_is_locked(&profiles_ns(p)->lock));\n\n\t \n\tif (!list_empty(&p->base.profiles))\n\t\treturn list_first_entry(&p->base.profiles, typeof(*p),\n\t\t\t\t\tbase.list);\n\n\t \n\tparent = rcu_dereference_protected(p->parent,\n\t\t\t\t\t   mutex_is_locked(&p->ns->lock));\n\twhile (parent) {\n\t\tp = list_next_entry(p, base.list);\n\t\tif (!list_entry_is_head(p, &parent->base.profiles, base.list))\n\t\t\treturn p;\n\t\tp = parent;\n\t\tparent = rcu_dereference_protected(parent->parent,\n\t\t\t\t\t    mutex_is_locked(&parent->ns->lock));\n\t}\n\n\t \n\tp = list_next_entry(p, base.list);\n\tif (!list_entry_is_head(p, &ns->base.profiles, base.list))\n\t\treturn p;\n\n\treturn NULL;\n}\n\n \nstatic struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t \n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}\n\n \nstatic void *p_start(struct seq_file *f, loff_t *pos)\n{\n\tstruct aa_profile *profile = NULL;\n\tstruct aa_ns *root = aa_get_current_ns();\n\tloff_t l = *pos;\n\tf->private = root;\n\n\t \n\tmutex_lock_nested(&root->lock, root->level);\n\tprofile = __first_profile(root, root);\n\n\t \n\tfor (; profile && l > 0; l--)\n\t\tprofile = next_profile(root, profile);\n\n\treturn profile;\n}\n\n \nstatic void *p_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *ns = f->private;\n\t(*pos)++;\n\n\treturn next_profile(ns, profile);\n}\n\n \nstatic void p_stop(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *root = f->private, *ns;\n\n\tif (profile) {\n\t\tfor (ns = profile->ns; ns && ns != root; ns = ns->parent)\n\t\t\tmutex_unlock(&ns->lock);\n\t}\n\tmutex_unlock(&root->lock);\n\taa_put_ns(root);\n}\n\n \nstatic int seq_show_profile(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = (struct aa_profile *)p;\n\tstruct aa_ns *root = f->private;\n\n\taa_label_seq_xprint(f, root, &profile->label,\n\t\t\t    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS, GFP_KERNEL);\n\tseq_putc(f, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations aa_sfs_profiles_op = {\n\t.start = p_start,\n\t.next = p_next,\n\t.stop = p_stop,\n\t.show = seq_show_profile,\n};\n\nstatic int profiles_open(struct inode *inode, struct file *file)\n{\n\tif (!aa_current_policy_view_capable(NULL))\n\t\treturn -EACCES;\n\n\treturn seq_open(file, &aa_sfs_profiles_op);\n}\n\nstatic int profiles_release(struct inode *inode, struct file *file)\n{\n\treturn seq_release(inode, file);\n}\n\nstatic const struct file_operations aa_sfs_profiles_fops = {\n\t.open = profiles_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = profiles_release,\n};\n\n\n \nstatic struct aa_sfs_entry aa_sfs_entry_file[] = {\n\tAA_SFS_FILE_STRING(\"mask\",\n\t\t\t   \"create read write exec append mmap_exec link lock\"),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_ptrace[] = {\n\tAA_SFS_FILE_STRING(\"mask\", \"read trace\"),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_signal[] = {\n\tAA_SFS_FILE_STRING(\"mask\", AA_SFS_SIG_MASK),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_attach[] = {\n\tAA_SFS_FILE_BOOLEAN(\"xattr\", 1),\n\t{ }\n};\nstatic struct aa_sfs_entry aa_sfs_entry_domain[] = {\n\tAA_SFS_FILE_BOOLEAN(\"change_hat\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"change_hatv\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"change_onexec\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"change_profile\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"stack\",\t\t1),\n\tAA_SFS_FILE_BOOLEAN(\"fix_binfmt_elf_mmap\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"post_nnp_subset\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"computed_longest_left\",\t1),\n\tAA_SFS_DIR(\"attach_conditions\",\t\taa_sfs_entry_attach),\n\tAA_SFS_FILE_STRING(\"version\", \"1.2\"),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_versions[] = {\n\tAA_SFS_FILE_BOOLEAN(\"v5\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"v6\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"v7\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"v8\",\t1),\n\tAA_SFS_FILE_BOOLEAN(\"v9\",\t1),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_policy[] = {\n\tAA_SFS_DIR(\"versions\",\t\t\taa_sfs_entry_versions),\n\tAA_SFS_FILE_BOOLEAN(\"set_load\",\t\t1),\n\t \n\tAA_SFS_FILE_U64(\"outofband\",\t\tMAX_OOB_SUPPORTED),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_mount[] = {\n\tAA_SFS_FILE_STRING(\"mask\", \"mount umount pivot_root\"),\n\tAA_SFS_FILE_STRING(\"move_mount\", \"detached\"),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_ns[] = {\n\tAA_SFS_FILE_BOOLEAN(\"profile\",\t\t1),\n\tAA_SFS_FILE_BOOLEAN(\"pivot_root\",\t0),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_query_label[] = {\n\tAA_SFS_FILE_STRING(\"perms\", \"allow deny audit quiet\"),\n\tAA_SFS_FILE_BOOLEAN(\"data\",\t\t1),\n\tAA_SFS_FILE_BOOLEAN(\"multi_transaction\",\t1),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_query[] = {\n\tAA_SFS_DIR(\"label\",\t\t\taa_sfs_entry_query_label),\n\t{ }\n};\nstatic struct aa_sfs_entry aa_sfs_entry_features[] = {\n\tAA_SFS_DIR(\"policy\",\t\t\taa_sfs_entry_policy),\n\tAA_SFS_DIR(\"domain\",\t\t\taa_sfs_entry_domain),\n\tAA_SFS_DIR(\"file\",\t\t\taa_sfs_entry_file),\n\tAA_SFS_DIR(\"network_v8\",\t\taa_sfs_entry_network),\n\tAA_SFS_DIR(\"mount\",\t\t\taa_sfs_entry_mount),\n\tAA_SFS_DIR(\"namespaces\",\t\taa_sfs_entry_ns),\n\tAA_SFS_FILE_U64(\"capability\",\t\tVFS_CAP_FLAGS_MASK),\n\tAA_SFS_DIR(\"rlimit\",\t\t\taa_sfs_entry_rlimit),\n\tAA_SFS_DIR(\"caps\",\t\t\taa_sfs_entry_caps),\n\tAA_SFS_DIR(\"ptrace\",\t\t\taa_sfs_entry_ptrace),\n\tAA_SFS_DIR(\"signal\",\t\t\taa_sfs_entry_signal),\n\tAA_SFS_DIR(\"query\",\t\t\taa_sfs_entry_query),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry_apparmor[] = {\n\tAA_SFS_FILE_FOPS(\".access\", 0666, &aa_sfs_access),\n\tAA_SFS_FILE_FOPS(\".stacked\", 0444, &seq_ns_stacked_fops),\n\tAA_SFS_FILE_FOPS(\".ns_stacked\", 0444, &seq_ns_nsstacked_fops),\n\tAA_SFS_FILE_FOPS(\".ns_level\", 0444, &seq_ns_level_fops),\n\tAA_SFS_FILE_FOPS(\".ns_name\", 0444, &seq_ns_name_fops),\n\tAA_SFS_FILE_FOPS(\"profiles\", 0444, &aa_sfs_profiles_fops),\n\tAA_SFS_FILE_FOPS(\"raw_data_compression_level_min\", 0444, &seq_ns_compress_min_fops),\n\tAA_SFS_FILE_FOPS(\"raw_data_compression_level_max\", 0444, &seq_ns_compress_max_fops),\n\tAA_SFS_DIR(\"features\", aa_sfs_entry_features),\n\t{ }\n};\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\n \nstatic int __init entry_create_file(struct aa_sfs_entry *fs_file,\n\t\t\t\t    struct dentry *parent)\n{\n\tint error = 0;\n\n\tfs_file->dentry = securityfs_create_file(fs_file->name,\n\t\t\t\t\t\t S_IFREG | fs_file->mode,\n\t\t\t\t\t\t parent, fs_file,\n\t\t\t\t\t\t fs_file->file_ops);\n\tif (IS_ERR(fs_file->dentry)) {\n\t\terror = PTR_ERR(fs_file->dentry);\n\t\tfs_file->dentry = NULL;\n\t}\n\treturn error;\n}\n\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n \nstatic int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}\n\n \nstatic void __init entry_remove_file(struct aa_sfs_entry *fs_file)\n{\n\tif (!fs_file->dentry)\n\t\treturn;\n\n\tsecurityfs_remove(fs_file->dentry);\n\tfs_file->dentry = NULL;\n}\n\n \nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}\n\n \nvoid __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}\n\n\n#define NULL_FILE_NAME \".null\"\nstruct path aa_null;\n\nstatic int aa_mk_null_file(struct dentry *parent)\n{\n\tstruct vfsmount *mount = NULL;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint count = 0;\n\tint error = simple_pin_fs(parent->d_sb->s_type, &mount, &count);\n\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\tinode = new_inode(parent->d_inode->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFCHR | S_IRUGO | S_IWUGO;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO,\n\t\t\t   MKDEV(MEM_MAJOR, 3));\n\td_instantiate(dentry, inode);\n\taa_null.dentry = dget(dentry);\n\taa_null.mnt = mntget(mount);\n\n\terror = 0;\n\nout1:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(parent));\n\tsimple_release_fs(&mount, &count);\n\treturn error;\n}\n\n\n\nstatic const char *policy_get_link(struct dentry *dentry,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct delayed_call *done)\n{\n\tstruct aa_ns *ns;\n\tstruct path path;\n\tint error;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tns = aa_get_current_ns();\n\tpath.mnt = mntget(aafs_mnt);\n\tpath.dentry = dget(ns_dir(ns));\n\terror = nd_jump_link(&path);\n\taa_put_ns(ns);\n\n\treturn ERR_PTR(error);\n}\n\nstatic int policy_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t   int buflen)\n{\n\tchar name[32];\n\tint res;\n\n\tres = snprintf(name, sizeof(name), \"%s:[%lu]\", AAFS_NAME,\n\t\t       d_inode(dentry)->i_ino);\n\tif (res > 0 && res < sizeof(name))\n\t\tres = readlink_copy(buffer, buflen, name);\n\telse\n\t\tres = -ENOENT;\n\n\treturn res;\n}\n\nstatic const struct inode_operations policy_link_iops = {\n\t.readlink\t= policy_readlink,\n\t.get_link\t= policy_get_link,\n};\n\n\n \nstatic int __init aa_create_aafs(void)\n{\n\tstruct dentry *dent;\n\tint error;\n\n\tif (!apparmor_initialized)\n\t\treturn 0;\n\n\tif (aa_sfs_entry.dentry) {\n\t\tAA_ERROR(\"%s: AppArmor securityfs already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\taafs_mnt = kern_mount(&aafs_ops);\n\tif (IS_ERR(aafs_mnt))\n\t\tpanic(\"can't set apparmorfs up\\n\");\n\taafs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n\n\t \n\terror = entry_create_dir(&aa_sfs_entry, NULL);\n\tif (error)\n\t\tgoto error;\n\n\tdent = securityfs_create_file(\".load\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\tgoto dent_error;\n\tns_subload(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".replace\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\tgoto dent_error;\n\tns_subreplace(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".remove\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\tgoto dent_error;\n\tns_subremove(root_ns) = dent;\n\n\tdent = securityfs_create_file(\"revision\", 0444, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\tgoto dent_error;\n\tns_subrevision(root_ns) = dent;\n\n\t \n\tmutex_lock_nested(&root_ns->lock, root_ns->level);\n\terror = __aafs_ns_mkdir(root_ns, aafs_mnt->mnt_root, \".policy\",\n\t\t\t\taafs_mnt->mnt_root);\n\tmutex_unlock(&root_ns->lock);\n\tif (error)\n\t\tgoto error;\n\n\t \n\tdent = securityfs_create_symlink(\"policy\", aa_sfs_entry.dentry,\n\t\t\t\t\t NULL, &policy_link_iops);\n\tif (IS_ERR(dent))\n\t\tgoto dent_error;\n\n\terror = aa_mk_null_file(aa_sfs_entry.dentry);\n\tif (error)\n\t\tgoto error;\n\n\t \n\n\t \n\taa_info_message(\"AppArmor Filesystem Enabled\");\n\treturn 0;\n\ndent_error:\n\terror = PTR_ERR(dent);\nerror:\n\taa_destroy_aafs();\n\tAA_ERROR(\"Error creating AppArmor securityfs\\n\");\n\treturn error;\n}\n\nfs_initcall(aa_create_aafs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}