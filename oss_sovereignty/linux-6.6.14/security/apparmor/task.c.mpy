{
  "module_name": "task.c",
  "hash_id": "21b8d568fa3cfb5878a1e9266086a598000874c9266160c5dead940c820e8bbe",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/task.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/policy.h\"\n#include \"include/task.h\"\n\n \nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\treturn p;\n}\n\n \nint aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_label *old = aa_current_raw_label();\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tstruct cred *new;\n\n\tAA_BUG(!label);\n\n\tif (old == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (ctx->nnp && label_is_stale(ctx->nnp)) {\n\t\tstruct aa_label *tmp = ctx->nnp;\n\n\t\tctx->nnp = aa_get_newest_label(tmp);\n\t\taa_put_label(tmp);\n\t}\n\tif (unconfined(label) || (labels_ns(old) != labels_ns(label)))\n\t\t \n\t\taa_clear_task_ctx_trans(task_ctx(current));\n\n\t \n\taa_get_label(label);\n\taa_put_label(cred_label(new));\n\tset_cred_label(new, label);\n\n\tcommit_creds(new);\n\treturn 0;\n}\n\n\n \nint aa_set_current_onexec(struct aa_label *label, bool stack)\n{\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\n\taa_get_label(label);\n\taa_put_label(ctx->onexec);\n\tctx->onexec = label;\n\tctx->token = stack;\n\n\treturn 0;\n}\n\n \nint aa_set_current_hat(struct aa_label *label, u64 token)\n{\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tAA_BUG(!label);\n\n\tif (!ctx->previous) {\n\t\t \n\t\tctx->previous = cred_label(new);\n\t\tctx->token = token;\n\t} else if (ctx->token == token) {\n\t\taa_put_label(cred_label(new));\n\t} else {\n\t\t \n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\n\tset_cred_label(new, aa_get_newest_label(label));\n\t \n\taa_put_label(ctx->onexec);\n\tctx->onexec = NULL;\n\n\tcommit_creds(new);\n\treturn 0;\n}\n\n \nint aa_restore_previous_label(u64 token)\n{\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tstruct cred *new;\n\n\tif (ctx->token != token)\n\t\treturn -EACCES;\n\t \n\tif (!ctx->previous)\n\t\treturn 0;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\taa_put_label(cred_label(new));\n\tset_cred_label(new, aa_get_newest_label(ctx->previous));\n\tAA_BUG(!cred_label(new));\n\t \n\taa_clear_task_ctx_trans(ctx);\n\n\tcommit_creds(new);\n\n\treturn 0;\n}\n\n \nstatic const char *audit_ptrace_mask(u32 mask)\n{\n\tswitch (mask) {\n\tcase MAY_READ:\n\t\treturn \"read\";\n\tcase MAY_WRITE:\n\t\treturn \"trace\";\n\tcase AA_MAY_BE_READ:\n\t\treturn \"readby\";\n\tcase AA_MAY_BE_TRACED:\n\t\treturn \"tracedby\";\n\t}\n\treturn \"\";\n}\n\n \nstatic void audit_ptrace_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->request & AA_PTRACE_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\\\"%s\\\"\",\n\t\t\t\t audit_ptrace_mask(ad->request));\n\n\t\tif (ad->denied & AA_PTRACE_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\\\"%s\\\"\",\n\t\t\t\t\t audit_ptrace_mask(ad->denied));\n\t\t}\n\t}\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}\n\n \n \nstatic int profile_ptrace_perm(const struct cred *cred,\n\t\t\t       struct aa_profile *profile,\n\t\t\t       struct aa_label *peer, u32 request,\n\t\t\t       struct apparmor_audit_data *ad)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms perms = { };\n\n\tad->subj_cred = cred;\n\tad->peer = peer;\n\taa_profile_match_label(profile, rules, peer, AA_CLASS_PTRACE, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, ad, audit_ptrace_cb);\n}\n\nstatic int profile_tracee_perm(const struct cred *cred,\n\t\t\t       struct aa_profile *tracee,\n\t\t\t       struct aa_label *tracer, u32 request,\n\t\t\t       struct apparmor_audit_data *ad)\n{\n\tif (profile_unconfined(tracee) || unconfined(tracer) ||\n\t    !ANY_RULE_MEDIATES(&tracee->rules, AA_CLASS_PTRACE))\n\t\treturn 0;\n\n\treturn profile_ptrace_perm(cred, tracee, tracer, request, ad);\n}\n\nstatic int profile_tracer_perm(const struct cred *cred,\n\t\t\t       struct aa_profile *tracer,\n\t\t\t       struct aa_label *tracee, u32 request,\n\t\t\t       struct apparmor_audit_data *ad)\n{\n\tif (profile_unconfined(tracer))\n\t\treturn 0;\n\n\tif (ANY_RULE_MEDIATES(&tracer->rules, AA_CLASS_PTRACE))\n\t\treturn profile_ptrace_perm(cred, tracer, tracee, request, ad);\n\n\t \n\tif (&tracer->label == tracee)\n\t\treturn 0;\n\n\tad->subj_label = &tracer->label;\n\tad->peer = tracee;\n\tad->request = 0;\n\tad->error = aa_capable(cred, &tracer->label, CAP_SYS_PTRACE,\n\t\t\t       CAP_OPT_NONE);\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, tracer, ad, audit_ptrace_cb);\n}\n\n \nint aa_may_ptrace(const struct cred *tracer_cred, struct aa_label *tracer,\n\t\t  const struct cred *tracee_cred, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tstruct aa_profile *profile;\n\tu32 xrequest = request << PTRACE_PERM_SHIFT;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, AA_CLASS_PTRACE, OP_PTRACE);\n\n\treturn xcheck_labels(tracer, tracee, profile,\n\t\t\tprofile_tracer_perm(tracer_cred, profile, tracee,\n\t\t\t\t\t    request, &sa),\n\t\t\tprofile_tracee_perm(tracee_cred, profile, tracer,\n\t\t\t\t\t    xrequest, &sa));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}