{
  "module_name": "capability.c",
  "hash_id": "787f3a8c346ee2a183ebf65d2d62fee21c3c3812c7371e62b3d774c91d713974",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/capability.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n\n#include \"include/apparmor.h\"\n#include \"include/capability.h\"\n#include \"include/cred.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n\n \n#include \"capability_names.h\"\n\nstruct aa_sfs_entry aa_sfs_entry_caps[] = {\n\tAA_SFS_FILE_STRING(\"mask\", AA_SFS_CAPS_MASK),\n\t{ }\n};\n\nstruct audit_cache {\n\tstruct aa_profile *profile;\n\tkernel_cap_t caps;\n};\n\nstatic DEFINE_PER_CPU(struct audit_cache, audit_cache);\n\n \nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\taudit_log_format(ab, \" capname=\");\n\taudit_log_untrustedstring(ab, capability_names[sa->u.cap]);\n}\n\n \nstatic int audit_caps(struct apparmor_audit_data *ad, struct aa_profile *profile,\n\t\t      int cap, int error)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct audit_cache *ent;\n\tint type = AUDIT_APPARMOR_AUTO;\n\n\tad->error = error;\n\n\tif (likely(!error)) {\n\t\t \n\t\tif (likely((AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(rules->caps.audit, cap)))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else if (KILL_MODE(profile) ||\n\t\t   cap_raised(rules->caps.kill, cap)) {\n\t\ttype = AUDIT_APPARMOR_KILL;\n\t} else if (cap_raised(rules->caps.quiet, cap) &&\n\t\t   AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t   AUDIT_MODE(profile) != AUDIT_ALL) {\n\t\t \n\t\treturn error;\n\t}\n\n\t \n\tent = &get_cpu_var(audit_cache);\n\tif (profile == ent->profile && cap_raised(ent->caps, cap)) {\n\t\tput_cpu_var(audit_cache);\n\t\tif (COMPLAIN_MODE(profile))\n\t\t\treturn complain_error(error);\n\t\treturn error;\n\t} else {\n\t\taa_put_profile(ent->profile);\n\t\tent->profile = aa_get_profile(profile);\n\t\tcap_raise(ent->caps, cap);\n\t}\n\tput_cpu_var(audit_cache);\n\n\treturn aa_audit(type, profile, ad, audit_cb);\n}\n\n \nstatic int profile_capable(struct aa_profile *profile, int cap,\n\t\t\t   unsigned int opts, struct apparmor_audit_data *ad)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tint error;\n\n\tif (cap_raised(rules->caps.allow, cap) &&\n\t    !cap_raised(rules->caps.denied, cap))\n\t\terror = 0;\n\telse\n\t\terror = -EPERM;\n\n\tif (opts & CAP_OPT_NOAUDIT) {\n\t\tif (!COMPLAIN_MODE(profile))\n\t\t\treturn error;\n\t\t \n\t\tad->info = \"optional: no audit\";\n\t}\n\n\treturn audit_caps(ad, profile, cap, error);\n}\n\n \nint aa_capable(const struct cred *subj_cred, struct aa_label *label,\n\t       int cap, unsigned int opts)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_CAP, AA_CLASS_CAP, OP_CAPABLE);\n\n\tad.subj_cred = subj_cred;\n\tad.common.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, opts, &ad));\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}