{
  "module_name": "mount.c",
  "hash_id": "01216148c365021ebe28225e0aee524e98a8c37e0fbfb4c364b45ead7ea10f5b",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/mount.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <uapi/linux/mount.h>\n\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/domain.h\"\n#include \"include/file.h\"\n#include \"include/match.h\"\n#include \"include/mount.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n\n\nstatic void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)\n{\n\tif (flags & MS_RDONLY)\n\t\taudit_log_format(ab, \"ro\");\n\telse\n\t\taudit_log_format(ab, \"rw\");\n\tif (flags & MS_NOSUID)\n\t\taudit_log_format(ab, \", nosuid\");\n\tif (flags & MS_NODEV)\n\t\taudit_log_format(ab, \", nodev\");\n\tif (flags & MS_NOEXEC)\n\t\taudit_log_format(ab, \", noexec\");\n\tif (flags & MS_SYNCHRONOUS)\n\t\taudit_log_format(ab, \", sync\");\n\tif (flags & MS_REMOUNT)\n\t\taudit_log_format(ab, \", remount\");\n\tif (flags & MS_MANDLOCK)\n\t\taudit_log_format(ab, \", mand\");\n\tif (flags & MS_DIRSYNC)\n\t\taudit_log_format(ab, \", dirsync\");\n\tif (flags & MS_NOATIME)\n\t\taudit_log_format(ab, \", noatime\");\n\tif (flags & MS_NODIRATIME)\n\t\taudit_log_format(ab, \", nodiratime\");\n\tif (flags & MS_BIND)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rbind\" : \", bind\");\n\tif (flags & MS_MOVE)\n\t\taudit_log_format(ab, \", move\");\n\tif (flags & MS_SILENT)\n\t\taudit_log_format(ab, \", silent\");\n\tif (flags & MS_POSIXACL)\n\t\taudit_log_format(ab, \", acl\");\n\tif (flags & MS_UNBINDABLE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\");\n\tif (flags & MS_PRIVATE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\");\n\tif (flags & MS_SLAVE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\");\n\tif (flags & MS_SHARED)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\");\n\tif (flags & MS_RELATIME)\n\t\taudit_log_format(ab, \", relatime\");\n\tif (flags & MS_I_VERSION)\n\t\taudit_log_format(ab, \", iversion\");\n\tif (flags & MS_STRICTATIME)\n\t\taudit_log_format(ab, \", strictatime\");\n\tif (flags & MS_NOUSER)\n\t\taudit_log_format(ab, \", nouser\");\n}\n\n \nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->mnt.type) {\n\t\taudit_log_format(ab, \" fstype=\");\n\t\taudit_log_untrustedstring(ab, ad->mnt.type);\n\t}\n\tif (ad->mnt.src_name) {\n\t\taudit_log_format(ab, \" srcname=\");\n\t\taudit_log_untrustedstring(ab, ad->mnt.src_name);\n\t}\n\tif (ad->mnt.trans) {\n\t\taudit_log_format(ab, \" trans=\");\n\t\taudit_log_untrustedstring(ab, ad->mnt.trans);\n\t}\n\tif (ad->mnt.flags) {\n\t\taudit_log_format(ab, \" flags=\\\"\");\n\t\taudit_mnt_flags(ab, ad->mnt.flags);\n\t\taudit_log_format(ab, \"\\\"\");\n\t}\n\tif (ad->mnt.data) {\n\t\taudit_log_format(ab, \" options=\");\n\t\taudit_log_untrustedstring(ab, ad->mnt.data);\n\t}\n}\n\n \nstatic int audit_mount(const struct cred *subj_cred,\n\t\t       struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_MOUNT, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t \n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t \n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t \n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\tad.subj_cred = subj_cred;\n\tad.name = name;\n\tad.mnt.src_name = src_name;\n\tad.mnt.type = type;\n\tad.mnt.trans = trans;\n\tad.mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\tad.mnt.data = data;\n\tad.info = info;\n\tad.error = error;\n\n\treturn aa_audit(audit_type, profile, &ad, audit_cb);\n}\n\n \nstatic aa_state_t match_mnt_flags(struct aa_dfa *dfa, aa_state_t state,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i <= 31 ; ++i) {\n\t\tif ((1 << i) & flags)\n\t\t\tstate = aa_dfa_next(dfa, state, i + 1);\n\t}\n\n\treturn state;\n}\n\nstatic const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\",\n\t\"failed perms check\"\n};\n\n \nstatic int do_match_mnt(struct aa_policydb *policy, aa_state_t start,\n\t\t\tconst char *mntpnt, const char *devname,\n\t\t\tconst char *type, unsigned long flags,\n\t\t\tvoid *data, bool binary, struct aa_perms *perms)\n{\n\taa_state_t state;\n\n\tAA_BUG(!policy);\n\tAA_BUG(!policy->dfa);\n\tAA_BUG(!policy->perms);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(policy->dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(policy->dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(policy->dfa, state, devname);\n\tstate = aa_dfa_null_transition(policy->dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(policy->dfa, state, type);\n\tstate = aa_dfa_null_transition(policy->dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(policy->dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = *aa_lookup_perms(policy, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n\t\treturn 0;\n\n\t \n\tif (data && !binary && (perms->allow & AA_MNT_CONT_MATCH)) {\n\t\tstate = aa_dfa_null_transition(policy->dfa, state);\n\t\tif (!state)\n\t\t\treturn 4;\n\n\t\tstate = aa_dfa_match(policy->dfa, state, data);\n\t\tif (!state)\n\t\t\treturn 5;\n\t\t*perms = *aa_lookup_perms(policy, state);\n\t\tif (perms->allow & AA_MAY_MOUNT)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn 6;\n}\n\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}\n\n \nstatic int match_mnt_path_str(const struct cred *subj_cred,\n\t\t\t      struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\tif (!RULE_MEDIATES(rules, AA_CLASS_MOUNT))\n\t\treturn 0;\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(&rules->policy,\n\t\t\t   rules->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(subj_cred, profile, OP_MOUNT, mntpnt, devname,\n\t\t\t   type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}\n\n \nstatic int match_mnt(const struct cred *subj_cred,\n\t\t     struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, const struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (!RULE_MEDIATES(rules, AA_CLASS_MOUNT))\n\t\treturn 0;\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(subj_cred, profile, path, buffer, devname,\n\t\t\t\t  type, flags, data, binary, info);\n}\n\nint aa_remount(const struct cred *subj_cred,\n\t       struct aa_label *label, const struct path *path,\n\t       unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tbool binary;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tbinary = path->dentry->d_sb->s_type->fs_flags & FS_BINARY_MOUNTDATA;\n\n\tbuffer = aa_get_buffer(false);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(subj_cred, profile, path, buffer, NULL,\n\t\t\t\t  NULL, NULL,\n\t\t\t\t  flags, data, binary));\n\taa_put_buffer(buffer);\n\n\treturn error;\n}\n\nint aa_bind_mount(const struct cred *subj_cred,\n\t\t  struct aa_label *label, const struct path *path,\n\t\t  const char *dev_name, unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tflags &= MS_REC | MS_BIND;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tbuffer = aa_get_buffer(false);\n\told_buffer = aa_get_buffer(false);\n\terror = -ENOMEM;\n\tif (!buffer || !old_buffer)\n\t\tgoto out;\n\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(subj_cred, profile, path, buffer, &old_path,\n\t\t\t\t  old_buffer, NULL, flags, NULL, false));\nout:\n\taa_put_buffer(buffer);\n\taa_put_buffer(old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nint aa_mount_change_type(const struct cred *subj_cred,\n\t\t\t struct aa_label *label, const struct path *path,\n\t\t\t unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\t \n\tflags &= (MS_REC | MS_SILENT | MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t  MS_UNBINDABLE);\n\n\tbuffer = aa_get_buffer(false);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(subj_cred, profile, path, buffer, NULL,\n\t\t\t\t  NULL, NULL,\n\t\t\t\t  flags, NULL, false));\n\taa_put_buffer(buffer);\n\n\treturn error;\n}\n\nint aa_move_mount(const struct cred *subj_cred,\n\t\t  struct aa_label *label, const struct path *from_path,\n\t\t  const struct path *to_path)\n{\n\tstruct aa_profile *profile;\n\tchar *to_buffer = NULL, *from_buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!from_path);\n\tAA_BUG(!to_path);\n\n\tto_buffer = aa_get_buffer(false);\n\tfrom_buffer = aa_get_buffer(false);\n\terror = -ENOMEM;\n\tif (!to_buffer || !from_buffer)\n\t\tgoto out;\n\n\tif (!our_mnt(from_path->mnt))\n\t\t \n\t\tfrom_path = NULL;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(subj_cred, profile, to_path, to_buffer,\n\t\t\t\t  from_path, from_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false));\nout:\n\taa_put_buffer(to_buffer);\n\taa_put_buffer(from_buffer);\n\n\treturn error;\n}\n\nint aa_move_mount_old(const struct cred *subj_cred, struct aa_label *label,\n\t\t      const struct path *path, const char *orig_name)\n{\n\tstruct path old_path;\n\tint error;\n\n\tif (!orig_name || !*orig_name)\n\t\treturn -EINVAL;\n\terror = kern_path(orig_name, LOOKUP_FOLLOW, &old_path);\n\tif (error)\n\t\treturn error;\n\n\terror = aa_move_mount(subj_cred, label, &old_path, path);\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nint aa_new_mount(const struct cred *subj_cred, struct aa_label *label,\n\t\t const char *dev_name, const struct path *path,\n\t\t const char *type, unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *dev_buffer = NULL;\n\tbool binary = true;\n\tint error;\n\tint requires_dev = 0;\n\tstruct path tmp_path, *dev_path = NULL;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (type) {\n\t\tstruct file_system_type *fstype;\n\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype)\n\t\t\treturn -ENODEV;\n\t\tbinary = fstype->fs_flags & FS_BINARY_MOUNTDATA;\n\t\trequires_dev = fstype->fs_flags & FS_REQUIRES_DEV;\n\t\tput_filesystem(fstype);\n\n\t\tif (requires_dev) {\n\t\t\tif (!dev_name || !*dev_name)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdev_path = &tmp_path;\n\t\t}\n\t}\n\n\tbuffer = aa_get_buffer(false);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_path) {\n\t\tdev_buffer = aa_get_buffer(false);\n\t\tif (!dev_buffer) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tmatch_mnt(subj_cred, profile, path, buffer,\n\t\t\t\t\t  dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary));\n\t} else {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tmatch_mnt_path_str(subj_cred, profile, path,\n\t\t\t\t\tbuffer, dev_name,\n\t\t\t\t\ttype, flags, data, binary, NULL));\n\t}\n\nout:\n\taa_put_buffer(buffer);\n\taa_put_buffer(dev_buffer);\n\tif (dev_path)\n\t\tpath_put(dev_path);\n\n\treturn error;\n}\n\nstatic int profile_umount(const struct cred *subj_cred,\n\t\t\t  struct aa_profile *profile, const struct path *path,\n\t\t\t  char *buffer)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms perms = { };\n\tconst char *name = NULL, *info = NULL;\n\taa_state_t state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\tif (!RULE_MEDIATES(rules, AA_CLASS_MOUNT))\n\t\treturn 0;\n\n\terror = aa_path_name(path, path_flags(profile, path), buffer, &name,\n\t\t\t     &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\tstate = aa_dfa_match(rules->policy.dfa,\n\t\t\t     rules->policy.start[AA_CLASS_MOUNT],\n\t\t\t     name);\n\tperms = *aa_lookup_perms(&rules->policy, state);\n\tif (AA_MAY_UMOUNT & ~perms.allow)\n\t\terror = -EACCES;\n\naudit:\n\treturn audit_mount(subj_cred, profile, OP_UMOUNT, name, NULL, NULL,\n\t\t\t   NULL, 0, NULL,\n\t\t\t   AA_MAY_UMOUNT, &perms, info, error);\n}\n\nint aa_umount(const struct cred *subj_cred, struct aa_label *label,\n\t      struct vfsmount *mnt, int flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\tAA_BUG(!label);\n\tAA_BUG(!mnt);\n\n\tbuffer = aa_get_buffer(false);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_umount(subj_cred, profile, &path, buffer));\n\taa_put_buffer(buffer);\n\n\treturn error;\n}\n\n \nstatic struct aa_label *build_pivotroot(const struct cred *subj_cred,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tconst struct path *new_path,\n\t\t\t\t\tchar *new_buffer,\n\t\t\t\t\tconst struct path *old_path,\n\t\t\t\t\tchar *old_buffer)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tconst char *old_name, *new_name = NULL, *info = NULL;\n\tconst char *trans_name = NULL;\n\tstruct aa_perms perms = { };\n\taa_state_t state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!new_path);\n\tAA_BUG(!old_path);\n\n\tif (profile_unconfined(profile) ||\n\t    !RULE_MEDIATES(rules, AA_CLASS_MOUNT))\n\t\treturn aa_get_newest_label(&profile->label);\n\n\terror = aa_path_name(old_path, path_flags(profile, old_path),\n\t\t\t     old_buffer, &old_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\terror = aa_path_name(new_path, path_flags(profile, new_path),\n\t\t\t     new_buffer, &new_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\tstate = aa_dfa_match(rules->policy.dfa,\n\t\t\t     rules->policy.start[AA_CLASS_MOUNT],\n\t\t\t     new_name);\n\tstate = aa_dfa_null_transition(rules->policy.dfa, state);\n\tstate = aa_dfa_match(rules->policy.dfa, state, old_name);\n\tperms = *aa_lookup_perms(&rules->policy, state);\n\n\tif (AA_MAY_PIVOTROOT & perms.allow)\n\t\terror = 0;\n\naudit:\n\terror = audit_mount(subj_cred, profile, OP_PIVOTROOT, new_name,\n\t\t\t    old_name,\n\t\t\t    NULL, trans_name, 0, NULL, AA_MAY_PIVOTROOT,\n\t\t\t    &perms, info, error);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn aa_get_newest_label(&profile->label);\n}\n\nint aa_pivotroot(const struct cred *subj_cred, struct aa_label *label,\n\t\t const struct path *old_path,\n\t\t const struct path *new_path)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\told_buffer = aa_get_buffer(false);\n\tnew_buffer = aa_get_buffer(false);\n\terror = -ENOMEM;\n\tif (!old_buffer || !new_buffer)\n\t\tgoto out;\n\ttarget = fn_label_build(label, profile, GFP_KERNEL,\n\t\t\tbuild_pivotroot(subj_cred, profile, new_path,\n\t\t\t\t\tnew_buffer,\n\t\t\t\t\told_path, old_buffer));\n\tif (!target) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} else if (!IS_ERR(target)) {\n\t\terror = aa_replace_current_label(target);\n\t\tif (error) {\n\t\t\t \n\t\t\taa_put_label(target);\n\t\t\tgoto out;\n\t\t}\n\t\taa_put_label(target);\n\t} else\n\t\t \n\t\terror = PTR_ERR(target);\nout:\n\taa_put_buffer(old_buffer);\n\taa_put_buffer(new_buffer);\n\n\treturn error;\n\nfail:\n\t \n\terror = fn_for_each(label, profile,\n\t\t\taudit_mount(subj_cred, profile, OP_PIVOTROOT,\n\t\t\t\t    NULL  ,\n\t\t\t\t    NULL  ,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error));\n\tgoto out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}