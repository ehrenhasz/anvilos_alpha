{
  "module_name": "match.c",
  "hash_id": "1b59ef0f50f6e123ce0c687668541aa849675543ab0e251a90e4276ef41fa3bd",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/match.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/kref.h>\n\n#include \"include/lib.h\"\n#include \"include/match.h\"\n\n#define base_idx(X) ((X) & 0xffffff)\n\nstatic char nulldfa_src[] = {\n\t#include \"nulldfa.in\"\n};\nstruct aa_dfa *nulldfa;\n\nstatic char stacksplitdfa_src[] = {\n\t#include \"stacksplitdfa.in\"\n};\nstruct aa_dfa *stacksplitdfa;\n\nint __init aa_setup_dfa_engine(void)\n{\n\tint error;\n\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\n\t\t\t\tTO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (IS_ERR(nulldfa)) {\n\t\terror = PTR_ERR(nulldfa);\n\t\tnulldfa = NULL;\n\t\treturn error;\n\t}\n\n\tstacksplitdfa = aa_dfa_unpack(stacksplitdfa_src,\n\t\t\t\t      sizeof(stacksplitdfa_src),\n\t\t\t\t      TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\t      TO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (IS_ERR(stacksplitdfa)) {\n\t\taa_put_dfa(nulldfa);\n\t\tnulldfa = NULL;\n\t\terror = PTR_ERR(stacksplitdfa);\n\t\tstacksplitdfa = NULL;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nvoid __init aa_teardown_dfa_engine(void)\n{\n\taa_put_dfa(stacksplitdfa);\n\taa_put_dfa(nulldfa);\n}\n\n \nstatic struct table_header *unpack_table(char *blob, size_t bsize)\n{\n\tstruct table_header *table = NULL;\n\tstruct table_header th;\n\tsize_t tsize;\n\n\tif (bsize < sizeof(struct table_header))\n\t\tgoto out;\n\n\t \n\tth.td_id = be16_to_cpu(*(__be16 *) (blob)) - 1;\n\tif (th.td_id > YYTD_ID_MAX)\n\t\tgoto out;\n\tth.td_flags = be16_to_cpu(*(__be16 *) (blob + 2));\n\tth.td_lolen = be32_to_cpu(*(__be32 *) (blob + 8));\n\tblob += sizeof(struct table_header);\n\n\tif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\n\t      th.td_flags == YYTD_DATA8))\n\t\tgoto out;\n\n\t \n\tif (th.td_lolen == 0)\n\t\tgoto out;\n\ttsize = table_size(th.td_lolen, th.td_flags);\n\tif (bsize < tsize)\n\t\tgoto out;\n\n\ttable = kvzalloc(tsize, GFP_KERNEL);\n\tif (table) {\n\t\ttable->td_id = th.td_id;\n\t\ttable->td_flags = th.td_flags;\n\t\ttable->td_lolen = th.td_lolen;\n\t\tif (th.td_flags == YYTD_DATA8)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u8, u8, byte_to_byte);\n\t\telse if (th.td_flags == YYTD_DATA16)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u16, __be16, be16_to_cpu);\n\t\telse if (th.td_flags == YYTD_DATA32)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u32, __be32, be32_to_cpu);\n\t\telse\n\t\t\tgoto fail;\n\t\t \n\t\tif (is_vmalloc_addr(table))\n\t\t\tvm_unmap_aliases();\n\t}\n\nout:\n\treturn table;\nfail:\n\tkvfree(table);\n\treturn NULL;\n}\n\n \nstatic int verify_table_headers(struct table_header **tables, int flags)\n{\n\tsize_t state_count, trans_count;\n\tint error = -EPROTO;\n\n\t \n\tif (!(tables[YYTD_ID_DEF] && tables[YYTD_ID_BASE] &&\n\t      tables[YYTD_ID_NXT] && tables[YYTD_ID_CHK]))\n\t\tgoto out;\n\n\t \n\tstate_count = tables[YYTD_ID_BASE]->td_lolen;\n\tif (ACCEPT1_FLAGS(flags)) {\n\t\tif (!tables[YYTD_ID_ACCEPT])\n\t\t\tgoto out;\n\t\tif (state_count != tables[YYTD_ID_ACCEPT]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (ACCEPT2_FLAGS(flags)) {\n\t\tif (!tables[YYTD_ID_ACCEPT2])\n\t\t\tgoto out;\n\t\tif (state_count != tables[YYTD_ID_ACCEPT2]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (state_count != tables[YYTD_ID_DEF]->td_lolen)\n\t\tgoto out;\n\n\t \n\ttrans_count = tables[YYTD_ID_NXT]->td_lolen;\n\tif (trans_count != tables[YYTD_ID_CHK]->td_lolen)\n\t\tgoto out;\n\n\t \n\tif (tables[YYTD_ID_EC] && tables[YYTD_ID_EC]->td_lolen != 256)\n\t\tgoto out;\n\n\terror = 0;\nout:\n\treturn error;\n}\n\n \nstatic int verify_dfa(struct aa_dfa *dfa)\n{\n\tsize_t i, state_count, trans_count;\n\tint error = -EPROTO;\n\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\ttrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\n\tif (state_count == 0)\n\t\tgoto out;\n\tfor (i = 0; i < state_count; i++) {\n\t\tif (!(BASE_TABLE(dfa)[i] & MATCH_FLAG_DIFF_ENCODE) &&\n\t\t    (DEFAULT_TABLE(dfa)[i] >= state_count))\n\t\t\tgoto out;\n\t\tif (BASE_TABLE(dfa)[i] & MATCH_FLAGS_INVALID) {\n\t\t\tpr_err(\"AppArmor DFA state with invalid match flags\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((BASE_TABLE(dfa)[i] & MATCH_FLAG_DIFF_ENCODE)) {\n\t\t\tif (!(dfa->flags & YYTH_FLAG_DIFF_ENCODE)) {\n\t\t\t\tpr_err(\"AppArmor DFA diff encoded transition state without header flag\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif ((BASE_TABLE(dfa)[i] & MATCH_FLAG_OOB_TRANSITION)) {\n\t\t\tif (base_idx(BASE_TABLE(dfa)[i]) < dfa->max_oob) {\n\t\t\t\tpr_err(\"AppArmor DFA out of bad transition out of range\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!(dfa->flags & YYTH_FLAG_OOB_TRANS)) {\n\t\t\t\tpr_err(\"AppArmor DFA out of bad transition state without header flag\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (base_idx(BASE_TABLE(dfa)[i]) + 255 >= trans_count) {\n\t\t\tpr_err(\"AppArmor DFA next/check upper bounds error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < trans_count; i++) {\n\t\tif (NEXT_TABLE(dfa)[i] >= state_count)\n\t\t\tgoto out;\n\t\tif (CHECK_TABLE(dfa)[i] >= state_count)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < state_count; i++) {\n\t\tsize_t j, k;\n\n\t\tfor (j = i;\n\t\t     (BASE_TABLE(dfa)[j] & MATCH_FLAG_DIFF_ENCODE) &&\n\t\t     !(BASE_TABLE(dfa)[j] & MARK_DIFF_ENCODE);\n\t\t     j = k) {\n\t\t\tk = DEFAULT_TABLE(dfa)[j];\n\t\t\tif (j == k)\n\t\t\t\tgoto out;\n\t\t\tif (k < j)\n\t\t\t\tbreak;\t\t \n\t\t\tBASE_TABLE(dfa)[j] |= MARK_DIFF_ENCODE;\n\t\t}\n\t}\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n \nstatic void dfa_free(struct aa_dfa *dfa)\n{\n\tif (dfa) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(dfa->tables); i++) {\n\t\t\tkvfree(dfa->tables[i]);\n\t\t\tdfa->tables[i] = NULL;\n\t\t}\n\t\tkfree(dfa);\n\t}\n}\n\n \nvoid aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}\n\n \nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t \n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tif (dfa->flags & ~(YYTH_FLAGS))\n\t\tgoto fail;\n\n\t \n\tdfa->max_oob = 1;\n\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t \n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\terror = verify_table_headers(dfa->tables, flags);\n\tif (error)\n\t\tgoto fail;\n\n\tif (flags & DFA_FLAG_VERIFY_STATES) {\n\t\terror = verify_dfa(dfa);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}\n\n#define match_char(state, def, base, next, check, C)\t\\\ndo {\t\t\t\t\t\t\t\\\n\tu32 b = (base)[(state)];\t\t\t\\\n\tunsigned int pos = base_idx(b) + (C);\t\t\\\n\tif ((check)[pos] != (state)) {\t\t\t\\\n\t\t(state) = (def)[(state)];\t\t\\\n\t\tif (b & MATCH_FLAG_DIFF_ENCODE)\t\t\\\n\t\t\tcontinue;\t\t\t\\\n\t\tbreak;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t(state) = (next)[pos];\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n} while (1)\n\n \naa_state_t aa_dfa_match_len(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t    const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\taa_state_t state = start;\n\n\tif (state == DFA_NOMATCH)\n\t\treturn DFA_NOMATCH;\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\tfor (; len; len--)\n\t\t\tmatch_char(state, def, base, next, check,\n\t\t\t\t   equiv[(u8) *str++]);\n\t} else {\n\t\t \n\t\tfor (; len; len--)\n\t\t\tmatch_char(state, def, base, next, check, (u8) *str++);\n\t}\n\n\treturn state;\n}\n\n \naa_state_t aa_dfa_match(struct aa_dfa *dfa, aa_state_t start, const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\taa_state_t state = start;\n\n\tif (state == DFA_NOMATCH)\n\t\treturn DFA_NOMATCH;\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t \n\t\twhile (*str)\n\t\t\tmatch_char(state, def, base, next, check,\n\t\t\t\t   equiv[(u8) *str++]);\n\t} else {\n\t\t \n\t\twhile (*str)\n\t\t\tmatch_char(state, def, base, next, check, (u8) *str++);\n\t}\n\n\treturn state;\n}\n\n \naa_state_t aa_dfa_next(struct aa_dfa *dfa, aa_state_t state, const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\tmatch_char(state, def, base, next, check, equiv[(u8) c]);\n\t} else\n\t\tmatch_char(state, def, base, next, check, (u8) c);\n\n\treturn state;\n}\n\naa_state_t aa_dfa_outofband_transition(struct aa_dfa *dfa, aa_state_t state)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tu32 b = (base)[(state)];\n\n\tif (!(b & MATCH_FLAG_OOB_TRANSITION))\n\t\treturn DFA_NOMATCH;\n\n\t \n\tmatch_char(state, def, base, next, check, -1);\n\n\treturn state;\n}\n\n \naa_state_t aa_dfa_match_until(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t\tconst char *str, const char **retpos)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tu32 *accept = ACCEPT_TABLE(dfa);\n\taa_state_t state = start, pos;\n\n\tif (state == DFA_NOMATCH)\n\t\treturn DFA_NOMATCH;\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t \n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (accept[state])\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (accept[state])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*retpos = str;\n\treturn state;\n}\n\n \naa_state_t aa_dfa_matchn_until(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t\t const char *str, int n, const char **retpos)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tu32 *accept = ACCEPT_TABLE(dfa);\n\taa_state_t state = start, pos;\n\n\t*retpos = NULL;\n\tif (state == DFA_NOMATCH)\n\t\treturn DFA_NOMATCH;\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t \n\t\tfor (; n; n--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (accept[state])\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (; n; n--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (accept[state])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*retpos = str;\n\treturn state;\n}\n\n#define inc_wb_pos(wb)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\twb->pos = (wb->pos + 1) & (WB_HISTORY_SIZE - 1);\t\t\\\n\twb->len = (wb->len + 1) & (WB_HISTORY_SIZE - 1);\t\t\\\n} while (0)\n\n \nstatic bool is_loop(struct match_workbuf *wb, aa_state_t state,\n\t\t    unsigned int *adjust)\n{\n\taa_state_t pos = wb->pos;\n\taa_state_t i;\n\n\tif (wb->history[pos] < state)\n\t\treturn false;\n\n\tfor (i = 0; i <= wb->len; i++) {\n\t\tif (wb->history[pos] == state) {\n\t\t\t*adjust = i;\n\t\t\treturn true;\n\t\t}\n\t\tif (pos == 0)\n\t\t\tpos = WB_HISTORY_SIZE;\n\t\tpos--;\n\t}\n\n\t*adjust = i;\n\treturn true;\n}\n\nstatic aa_state_t leftmatch_fb(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t\t const char *str, struct match_workbuf *wb,\n\t\t\t\t unsigned int *count)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\taa_state_t state = start, pos;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!str);\n\tAA_BUG(!wb);\n\tAA_BUG(!count);\n\n\t*count = 0;\n\tif (state == DFA_NOMATCH)\n\t\treturn DFA_NOMATCH;\n\n\t \n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t \n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t \n\t\twhile (*str) {\n\t\t\tunsigned int adjust;\n\n\t\t\twb->history[wb->pos] = state;\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (is_loop(wb, state, &adjust)) {\n\t\t\t\tstate = aa_dfa_match(dfa, state, str);\n\t\t\t\t*count -= adjust;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinc_wb_pos(wb);\n\t\t\t(*count)++;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (*str) {\n\t\t\tunsigned int adjust;\n\n\t\t\twb->history[wb->pos] = state;\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t\tif (is_loop(wb, state, &adjust)) {\n\t\t\t\tstate = aa_dfa_match(dfa, state, str);\n\t\t\t\t*count -= adjust;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinc_wb_pos(wb);\n\t\t\t(*count)++;\n\t\t}\n\t}\n\nout:\n\tif (!state)\n\t\t*count = 0;\n\treturn state;\n}\n\n \naa_state_t aa_dfa_leftmatch(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t    const char *str, unsigned int *count)\n{\n\tDEFINE_MATCH_WB(wb);\n\n\t \n\n\treturn leftmatch_fb(dfa, start, str, &wb, count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}