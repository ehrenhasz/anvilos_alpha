{
  "module_name": "secid.c",
  "hash_id": "c7a3dc446d88608ccc217d3668b2014cbaf4f3af289c83d4911d4e88c51c2226",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/secid.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/xarray.h>\n\n#include \"include/cred.h\"\n#include \"include/lib.h\"\n#include \"include/secid.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n\n \n#define AA_FIRST_SECID 2\n\nstatic DEFINE_XARRAY_FLAGS(aa_secids, XA_FLAGS_LOCK_IRQ | XA_FLAGS_TRACK_FREE);\n\nint apparmor_display_secid_mode;\n\n \n\n \nvoid aa_secid_update(u32 secid, struct aa_label *label)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&aa_secids, flags);\n\t__xa_store(&aa_secids, secid, label, 0);\n\txa_unlock_irqrestore(&aa_secids, flags);\n}\n\n \nstruct aa_label *aa_secid_to_label(u32 secid)\n{\n\treturn xa_load(&aa_secids, secid);\n}\n\nint apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\t \n\tstruct aa_label *label = aa_secid_to_label(secid);\n\tint flags = FLAG_VIEW_SUBNS | FLAG_HIDDEN_UNCONFINED | FLAG_ABS_ROOT;\n\tint len;\n\n\tAA_BUG(!seclen);\n\n\tif (!label)\n\t\treturn -EINVAL;\n\n\tif (apparmor_display_secid_mode)\n\t\tflags |= FLAG_SHOW_MODE;\n\n\tif (secdata)\n\t\tlen = aa_label_asxprint(secdata, root_ns, label,\n\t\t\t\t\tflags, GFP_ATOMIC);\n\telse\n\t\tlen = aa_label_snxprint(NULL, 0, root_ns, label, flags);\n\n\tif (len < 0)\n\t\treturn -ENOMEM;\n\n\t*seclen = len;\n\n\treturn 0;\n}\n\nint apparmor_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\tstruct aa_label *label;\n\n\tlabel = aa_label_strn_parse(&root_ns->unconfined->label, secdata,\n\t\t\t\t    seclen, GFP_KERNEL, false, false);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\t*secid = label->secid;\n\n\treturn 0;\n}\n\nvoid apparmor_release_secctx(char *secdata, u32 seclen)\n{\n\tkfree(secdata);\n}\n\n \nint aa_alloc_secid(struct aa_label *label, gfp_t gfp)\n{\n\tunsigned long flags;\n\tint ret;\n\n\txa_lock_irqsave(&aa_secids, flags);\n\tret = __xa_alloc(&aa_secids, &label->secid, label,\n\t\t\tXA_LIMIT(AA_FIRST_SECID, INT_MAX), gfp);\n\txa_unlock_irqrestore(&aa_secids, flags);\n\n\tif (ret < 0) {\n\t\tlabel->secid = AA_SECID_INVALID;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nvoid aa_free_secid(u32 secid)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&aa_secids, flags);\n\t__xa_erase(&aa_secids, secid);\n\txa_unlock_irqrestore(&aa_secids, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}