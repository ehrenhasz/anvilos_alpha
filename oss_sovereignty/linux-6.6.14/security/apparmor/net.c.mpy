{
  "module_name": "net.c",
  "hash_id": "a4435e6068dcd2931b64cdf68d2e21f596e8c679c0f1ff494ccf346e1a047838",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/net.c",
  "human_readable_source": "\n \n\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/label.h\"\n#include \"include/net.h\"\n#include \"include/policy.h\"\n#include \"include/secid.h\"\n\n#include \"net_names.h\"\n\n\nstruct aa_sfs_entry aa_sfs_entry_network[] = {\n\tAA_SFS_FILE_STRING(\"af_mask\",\tAA_SFS_AF_MASK),\n\t{ }\n};\n\nstatic const char * const net_mask_names[] = {\n\t\"unknown\",\n\t\"send\",\n\t\"receive\",\n\t\"unknown\",\n\n\t\"create\",\n\t\"shutdown\",\n\t\"connect\",\n\t\"unknown\",\n\n\t\"setattr\",\n\t\"getattr\",\n\t\"setcred\",\n\t\"getcred\",\n\n\t\"chmod\",\n\t\"chown\",\n\t\"chgrp\",\n\t\"lock\",\n\n\t\"mmap\",\n\t\"mprot\",\n\t\"unknown\",\n\t\"unknown\",\n\n\t\"accept\",\n\t\"bind\",\n\t\"listen\",\n\t\"unknown\",\n\n\t\"setopt\",\n\t\"getopt\",\n\t\"unknown\",\n\t\"unknown\",\n\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n};\n\n\n \nvoid audit_net_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (address_family_names[sa->u.net->family])\n\t\taudit_log_format(ab, \" family=\\\"%s\\\"\",\n\t\t\t\t address_family_names[sa->u.net->family]);\n\telse\n\t\taudit_log_format(ab, \" family=\\\"unknown(%d)\\\"\",\n\t\t\t\t sa->u.net->family);\n\tif (sock_type_names[ad->net.type])\n\t\taudit_log_format(ab, \" sock_type=\\\"%s\\\"\",\n\t\t\t\t sock_type_names[ad->net.type]);\n\telse\n\t\taudit_log_format(ab, \" sock_type=\\\"unknown(%d)\\\"\",\n\t\t\t\t ad->net.type);\n\taudit_log_format(ab, \" protocol=%d\", ad->net.protocol);\n\n\tif (ad->request & NET_PERMS_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taa_audit_perm_mask(ab, ad->request, NULL, 0,\n\t\t\t\t   net_mask_names, NET_PERMS_MASK);\n\n\t\tif (ad->denied & NET_PERMS_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\");\n\t\t\taa_audit_perm_mask(ab, ad->denied, NULL, 0,\n\t\t\t\t\t   net_mask_names, NET_PERMS_MASK);\n\t\t}\n\t}\n\tif (ad->peer) {\n\t\taudit_log_format(ab, \" peer=\");\n\t\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\t\tFLAGS_NONE, GFP_ATOMIC);\n\t}\n}\n\n \nint aa_profile_af_perm(struct aa_profile *profile,\n\t\t       struct apparmor_audit_data *ad, u32 request, u16 family,\n\t\t       int type)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms perms = { };\n\taa_state_t state;\n\t__be16 buffer[2];\n\n\tAA_BUG(family >= AF_MAX);\n\tAA_BUG(type < 0 || type >= SOCK_MAX);\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\tstate = RULE_MEDIATES(rules, AA_CLASS_NET);\n\tif (!state)\n\t\treturn 0;\n\n\tbuffer[0] = cpu_to_be16(family);\n\tbuffer[1] = cpu_to_be16((u16) type);\n\tstate = aa_dfa_match_len(rules->policy.dfa, state, (char *) &buffer,\n\t\t\t\t 4);\n\tperms = *aa_lookup_perms(&rules->policy, state);\n\taa_apply_modes_to_perms(profile, &perms);\n\n\treturn aa_check_perms(profile, &perms, request, ad, audit_net_cb);\n}\n\nint aa_af_perm(const struct cred *subj_cred, struct aa_label *label,\n\t       const char *op, u32 request, u16 family, int type, int protocol)\n{\n\tstruct aa_profile *profile;\n\tDEFINE_AUDIT_NET(ad, op, NULL, family, type, protocol);\n\n\treturn fn_for_each_confined(label, profile,\n\t\t\taa_profile_af_perm(profile, &ad, request, family,\n\t\t\t\t\t   type));\n}\n\nstatic int aa_label_sk_perm(const struct cred *subj_cred,\n\t\t\t    struct aa_label *label,\n\t\t\t    const char *op, u32 request,\n\t\t\t    struct sock *sk)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!sk);\n\n\tif (ctx->label != kernel_t && !unconfined(label)) {\n\t\tstruct aa_profile *profile;\n\t\tDEFINE_AUDIT_SK(ad, op, sk);\n\n\t\tad.subj_cred = subj_cred;\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t    aa_profile_af_sk_perm(profile, &ad, request, sk));\n\t}\n\n\treturn error;\n}\n\nint aa_sk_perm(const char *op, u32 request, struct sock *sk)\n{\n\tstruct aa_label *label;\n\tint error;\n\n\tAA_BUG(!sk);\n\tAA_BUG(in_interrupt());\n\n\t \n\tlabel = begin_current_label_crit_section();\n\terror = aa_label_sk_perm(current_cred(), label, op, request, sk);\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}\n\n\nint aa_sock_file_perm(const struct cred *subj_cred, struct aa_label *label,\n\t\t      const char *op, u32 request, struct socket *sock)\n{\n\tAA_BUG(!label);\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\n\treturn aa_label_sk_perm(subj_cred, label, op, request, sock->sk);\n}\n\n#ifdef CONFIG_NETWORK_SECMARK\nstatic int apparmor_secmark_init(struct aa_secmark *secmark)\n{\n\tstruct aa_label *label;\n\n\tif (secmark->label[0] == '*') {\n\t\tsecmark->secid = AA_SECID_WILDCARD;\n\t\treturn 0;\n\t}\n\n\tlabel = aa_label_strn_parse(&root_ns->unconfined->label,\n\t\t\t\t    secmark->label, strlen(secmark->label),\n\t\t\t\t    GFP_ATOMIC, false, false);\n\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tsecmark->secid = label->secid;\n\n\treturn 0;\n}\n\nstatic int aa_secmark_perm(struct aa_profile *profile, u32 request, u32 secid,\n\t\t\t   struct apparmor_audit_data *ad)\n{\n\tint i, ret;\n\tstruct aa_perms perms = { };\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\n\tif (rules->secmark_count == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < rules->secmark_count; i++) {\n\t\tif (!rules->secmark[i].secid) {\n\t\t\tret = apparmor_secmark_init(&rules->secmark[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (rules->secmark[i].secid == secid ||\n\t\t    rules->secmark[i].secid == AA_SECID_WILDCARD) {\n\t\t\tif (rules->secmark[i].deny)\n\t\t\t\tperms.deny = ALL_PERMS_MASK;\n\t\t\telse\n\t\t\t\tperms.allow = ALL_PERMS_MASK;\n\n\t\t\tif (rules->secmark[i].audit)\n\t\t\t\tperms.audit = ALL_PERMS_MASK;\n\t\t}\n\t}\n\n\taa_apply_modes_to_perms(profile, &perms);\n\n\treturn aa_check_perms(profile, &perms, request, ad, audit_net_cb);\n}\n\nint apparmor_secmark_check(struct aa_label *label, char *op, u32 request,\n\t\t\t   u32 secid, const struct sock *sk)\n{\n\tstruct aa_profile *profile;\n\tDEFINE_AUDIT_SK(ad, op, sk);\n\n\treturn fn_for_each_confined(label, profile,\n\t\t\t\t    aa_secmark_perm(profile, request, secid,\n\t\t\t\t\t\t    &ad));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}