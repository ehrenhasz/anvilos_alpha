{
  "module_name": "domain.c",
  "hash_id": "9a53265efa0473ef5926bc7a8e84621eff69e65c48f35fd5cfad23ff2b81def1",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/domain.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/xattr.h>\n#include <linux/user_namespace.h>\n\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/cred.h\"\n#include \"include/domain.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/match.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/policy_ns.h\"\n\n \nstatic int may_change_ptraced_domain(const struct cred *to_cred,\n\t\t\t\t     struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tconst struct cred *tracer_cred = NULL;\n\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer) {\n\t\t \n\t\ttracerl = aa_get_task_label(tracer);\n\t\ttracer_cred = get_task_cred(tracer);\n\t}\n\t \n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracer_cred, tracerl, to_cred, to_label,\n\t\t\t      PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\tput_cred(tracer_cred);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}\n\n \n \nstatic inline aa_state_t match_component(struct aa_profile *profile,\n\t\t\t\t\t struct aa_profile *tp,\n\t\t\t\t\t bool stack, aa_state_t state)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(rules->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(rules->file.dfa, state, tp->base.hname);\n\n\t \n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(rules->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(rules->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(rules->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(rules->file.dfa, state, tp->base.hname);\n}\n\n \nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label, bool stack,\n\t\t\t\taa_state_t state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct path_cond cond = { };\n\n\t \n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t \n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(rules->file.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, false, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = *(aa_lookup_fperms(&(rules->file), state, &cond));\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}\n\n \nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, bool stack,\n\t\t\t\t  aa_state_t start, bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tstruct path_cond cond = { };\n\taa_state_t state = 0;\n\n\t \n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t \n\treturn 0;\n\nnext:\n\ttmp = *(aa_lookup_fperms(&(rules->file), state, &cond));\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = *(aa_lookup_fperms(&(rules->file), state, &cond));\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}\n\n \nstatic int label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t       bool stack, aa_state_t state, bool subns, u32 request,\n\t\t       struct aa_perms *perms)\n{\n\tint error;\n\n\t*perms = nullperms;\n\terror = label_compound_match(profile, label, stack, state, subns,\n\t\t\t\t     request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, stack, state, subns,\n\t\t\t\t      request, perms);\n}\n\n \n\n \nstatic int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, aa_state_t start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t \n\treturn label_match(profile, target, stack, start, true, request, perms);\n}\n\n \nstatic int aa_xattrs_match(const struct linux_binprm *bprm,\n\t\t\t   struct aa_profile *profile, aa_state_t state)\n{\n\tint i;\n\tstruct dentry *d;\n\tchar *value = NULL;\n\tstruct aa_attachment *attach = &profile->attach;\n\tint size, value_size = 0, ret = attach->xattr_count;\n\n\tif (!bprm || !attach->xattr_count)\n\t\treturn 0;\n\tmight_sleep();\n\n\t \n\tstate = aa_dfa_outofband_transition(attach->xmatch.dfa, state);\n\td = bprm->file->f_path.dentry;\n\n\tfor (i = 0; i < attach->xattr_count; i++) {\n\t\tsize = vfs_getxattr_alloc(&nop_mnt_idmap, d, attach->xattrs[i],\n\t\t\t\t\t  &value, value_size, GFP_KERNEL);\n\t\tif (size >= 0) {\n\t\t\tu32 index, perm;\n\n\t\t\t \n\t\t\tstate = aa_dfa_null_transition(attach->xmatch.dfa,\n\t\t\t\t\t\t       state);\n\t\t\t \n\t\t\tstate = aa_dfa_match_len(attach->xmatch.dfa, state,\n\t\t\t\t\t\t value, size);\n\t\t\tindex = ACCEPT_TABLE(attach->xmatch.dfa)[state];\n\t\t\tperm = attach->xmatch.perms[index].allow;\n\t\t\tif (!(perm & MAY_EXEC)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tstate = aa_dfa_outofband_transition(attach->xmatch.dfa, state);\n\t\tif (size < 0) {\n\t\t\t \n\t\t\tif (!state) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tret--;\n\t\t}\n\t}\n\nout:\n\tkfree(value);\n\treturn ret;\n}\n\n \nstatic struct aa_label *find_attach(const struct linux_binprm *bprm,\n\t\t\t\t    struct aa_ns *ns, struct list_head *head,\n\t\t\t\t    const char *name, const char **info)\n{\n\tint candidate_len = 0, candidate_xattrs = 0;\n\tbool conflict = false;\n\tstruct aa_profile *profile, *candidate = NULL;\n\n\tAA_BUG(!name);\n\tAA_BUG(!head);\n\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(profile, head, base.list) {\n\t\tstruct aa_attachment *attach = &profile->attach;\n\n\t\tif (profile->label.flags & FLAG_NULL &&\n\t\t    &profile->label == ns_unconfined(profile->ns))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (attach->xmatch.dfa) {\n\t\t\tunsigned int count;\n\t\t\taa_state_t state;\n\t\t\tu32 index, perm;\n\n\t\t\tstate = aa_dfa_leftmatch(attach->xmatch.dfa,\n\t\t\t\t\tattach->xmatch.start[AA_CLASS_XMATCH],\n\t\t\t\t\tname, &count);\n\t\t\tindex = ACCEPT_TABLE(attach->xmatch.dfa)[state];\n\t\t\tperm = attach->xmatch.perms[index].allow;\n\t\t\t \n\t\t\tif (perm & MAY_EXEC) {\n\t\t\t\tint ret = 0;\n\n\t\t\t\tif (count < candidate_len)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (bprm && attach->xattr_count) {\n\t\t\t\t\tlong rev = READ_ONCE(ns->revision);\n\n\t\t\t\t\tif (!aa_get_profile_not0(profile))\n\t\t\t\t\t\tgoto restart;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tret = aa_xattrs_match(bprm, profile,\n\t\t\t\t\t\t\t      state);\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\taa_put_profile(profile);\n\t\t\t\t\tif (rev !=\n\t\t\t\t\t    READ_ONCE(ns->revision))\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto restart;\n\t\t\t\t\t \n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (count == candidate_len &&\n\t\t\t\t    ret <= candidate_xattrs) {\n\t\t\t\t\t \n\t\t\t\t\tif (ret == candidate_xattrs)\n\t\t\t\t\t\tconflict = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tcandidate = profile;\n\t\t\t\tcandidate_len = max(count, attach->xmatch_len);\n\t\t\t\tcandidate_xattrs = ret;\n\t\t\t\tconflict = false;\n\t\t\t}\n\t\t} else if (!strcmp(profile->base.name, name)) {\n\t\t\t \n\t\t\tcandidate = profile;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!candidate || conflict) {\n\t\tif (conflict)\n\t\t\t*info = \"conflicting profile attachments\";\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\nout:\n\tcandidate = aa_get_newest_profile(candidate);\n\trcu_read_unlock();\n\n\treturn &candidate->label;\n}\n\nstatic const char *next_name(int xtype, const char *name)\n{\n\treturn NULL;\n}\n\n \nstruct aa_label *x_table_lookup(struct aa_profile *profile, u32 xindex,\n\t\t\t\tconst char **name)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_label *label = NULL;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tint index = xindex & AA_X_INDEX_MASK;\n\n\tAA_BUG(!name);\n\n\t \n\t \n\tfor (*name = rules->file.trans.table[index]; !label && *name;\n\t     *name = next_name(xtype, *name)) {\n\t\tif (xindex & AA_X_CHILD) {\n\t\t\tstruct aa_profile *new_profile;\n\t\t\t \n\t\t\tnew_profile = aa_find_child(profile, *name);\n\t\t\tif (new_profile)\n\t\t\t\tlabel = &new_profile->label;\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = aa_label_parse(&profile->label, *name, GFP_KERNEL,\n\t\t\t\t       true, false);\n\t\tif (IS_ERR(label))\n\t\t\tlabel = NULL;\n\t}\n\n\t \n\n\treturn label;\n}\n\n \nstatic struct aa_label *x_to_label(struct aa_profile *profile,\n\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t   const char *name, u32 xindex,\n\t\t\t\t   const char **lookupname,\n\t\t\t\t   const char **info)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_label *new = NULL;\n\tstruct aa_ns *ns = profile->ns;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tconst char *stack = NULL;\n\n\tswitch (xtype) {\n\tcase AA_X_NONE:\n\t\t \n\t\t*lookupname = NULL;\n\t\tbreak;\n\tcase AA_X_TABLE:\n\t\t \n\t\tstack = rules->file.trans.table[xindex & AA_X_INDEX_MASK];\n\t\tif (*stack != '&') {\n\t\t\t \n\t\t\tnew = x_table_lookup(profile, xindex, lookupname);\n\t\t\tstack = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase AA_X_NAME:\n\t\tif (xindex & AA_X_CHILD)\n\t\t\t \n\t\t\tnew = find_attach(bprm, ns, &profile->base.profiles,\n\t\t\t\t\t  name, info);\n\t\telse\n\t\t\t \n\t\t\tnew = find_attach(bprm, ns, &ns->base.profiles,\n\t\t\t\t\t  name, info);\n\t\t*lookupname = name;\n\t\tbreak;\n\t}\n\n\tif (!new) {\n\t\tif (xindex & AA_X_INHERIT) {\n\t\t\t \n\t\t\t*info = \"ix fallback\";\n\t\t\t \n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t} else if (xindex & AA_X_UNCONFINED) {\n\t\t\tnew = aa_get_newest_label(ns_unconfined(profile->ns));\n\t\t\t*info = \"ux fallback\";\n\t\t}\n\t}\n\n\tif (new && stack) {\n\t\t \n\t\tstruct aa_label *base = new;\n\n\t\tnew = aa_label_parse(base, stack, GFP_KERNEL, true, false);\n\t\tif (IS_ERR(new))\n\t\t\tnew = NULL;\n\t\taa_put_label(base);\n\t}\n\n\t \n\treturn new;\n}\n\nstatic struct aa_label *profile_transition(const struct cred *subj_cred,\n\t\t\t\t\t   struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\taa_state_t state = rules->file.start[AA_CLASS_FILE];\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(bprm, profile->ns,\n\t\t\t\t  &profile->ns->base.profiles, name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t \n\tstate = aa_str_perms(&(rules->file), state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t \n\t\tnew = x_to_label(profile, bprm, name, perms.xindex, &target,\n\t\t\t\t &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t \n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t \n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t \n\t\tstruct aa_profile *new_profile = NULL;\n\n\t\tnew_profile = aa_new_learning_profile(profile, false, name,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t \n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_KERNEL);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(subj_cred, profile, &perms, OP_EXEC, MAY_EXEC, name,\n\t\t      target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}\n\nstatic int profile_onexec(const struct cred *subj_cred,\n\t\t\t  struct aa_profile *profile, struct aa_label *onexec,\n\t\t\t  bool stack, const struct linux_binprm *bprm,\n\t\t\t  char *buffer, struct path_cond *cond,\n\t\t\t  bool *secure_exec)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\taa_state_t state = rules->file.start[AA_CLASS_FILE];\n\tstruct aa_perms perms = {};\n\tconst char *xname = NULL, *info = \"change_profile onexec\";\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (profile_unconfined(profile)) {\n\t\t \n\t\t \n\t\treturn 0;\n\t}\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &xname, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t}\n\t\txname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\t \n\tstate = aa_str_perms(&(rules->file), state, xname, cond, &perms);\n\tif (!(perms.allow & AA_MAY_ONEXEC)) {\n\t\tinfo = \"no change_onexec valid for executable\";\n\t\tgoto audit;\n\t}\n\t \n\tstate = aa_dfa_null_transition(rules->file.dfa, state);\n\terror = change_profile_perms(profile, onexec, stack, AA_MAY_ONEXEC,\n\t\t\t\t     state, &perms);\n\tif (error) {\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\", xname);\n\t\t\taa_label_printk(onexec, GFP_KERNEL);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\treturn aa_audit_file(subj_cred, profile, &perms, OP_EXEC,\n\t\t\t     AA_MAY_ONEXEC, xname,\n\t\t\t     NULL, onexec, cond->uid, info, error);\n}\n\n \n\nstatic struct aa_label *handle_onexec(const struct cred *subj_cred,\n\t\t\t\t      struct aa_label *label,\n\t\t\t\t      struct aa_label *onexec, bool stack,\n\t\t\t\t      const struct linux_binprm *bprm,\n\t\t\t\t      char *buffer, struct path_cond *cond,\n\t\t\t\t      bool *unsafe)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(subj_cred, profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(subj_cred, profile, bprm,\n\t\t\t\t\t\t   buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t \n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(subj_cred, profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\taa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_KERNEL),\n\t\t\t\tprofile_transition(subj_cred, profile, bprm,\n\t\t\t\t\t\t   buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\t}\n\n\tif (new)\n\t\treturn new;\n\n\t \n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(subj_cred, profile, &nullperms,\n\t\t\t\t      OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM));\n\treturn ERR_PTR(error);\n}\n\n \nint apparmor_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *new = NULL;\n\tconst struct cred *subj_cred;\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\tbool unsafe = false;\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(file_mnt_idmap(bprm->file),\n\t\t\t\t\t    file_inode(bprm->file));\n\tstruct path_cond cond = {\n\t\tvfsuid_into_kuid(vfsuid),\n\t\tfile_inode(bprm->file)->i_mode\n\t};\n\n\tsubj_cred = current_cred();\n\tctx = task_ctx(current);\n\tAA_BUG(!cred_label(bprm->cred));\n\tAA_BUG(!ctx);\n\n\tlabel = aa_get_newest_label(cred_label(bprm->cred));\n\n\t \n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) && !unconfined(label) &&\n\t    !ctx->nnp)\n\t\tctx->nnp = aa_get_label(label);\n\n\t \n\tbuffer = aa_get_buffer(false);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (ctx->onexec)\n\t\tnew = handle_onexec(subj_cred, label, ctx->onexec, ctx->token,\n\t\t\t\t    bprm, buffer, &cond, &unsafe);\n\telse\n\t\tnew = fn_label_build(label, profile, GFP_KERNEL,\n\t\t\t\tprofile_transition(subj_cred, profile, bprm,\n\t\t\t\t\t\t   buffer,\n\t\t\t\t\t\t   &cond, &unsafe));\n\n\tAA_BUG(!new);\n\tif (IS_ERR(new)) {\n\t\terror = PTR_ERR(new);\n\t\tgoto done;\n\t} else if (!new) {\n\t\terror = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !unconfined(label) &&\n\t    !aa_label_is_unconfined_subset(new, ctx->nnp)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tgoto audit;\n\t}\n\n\tif (bprm->unsafe & LSM_UNSAFE_SHARE) {\n\t\t \n\t\t;\n\t}\n\n\tif (bprm->unsafe & (LSM_UNSAFE_PTRACE)) {\n\t\t \n\t\terror = may_change_ptraced_domain(bprm->cred, new, &info);\n\t\tif (error)\n\t\t\tgoto audit;\n\t}\n\n\tif (unsafe) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"scrubbing environment variables for %s \"\n\t\t\t\t   \"label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_KERNEL);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->secureexec = 1;\n\t}\n\n\tif (label->proxy != new->proxy) {\n\t\t \n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: clearing unsafe personality \"\n\t\t\t\t   \"bits. %s label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_KERNEL);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t}\n\taa_put_label(cred_label(bprm->cred));\n\t \n\tset_cred_label(bprm->cred, new);\n\ndone:\n\taa_put_label(label);\n\taa_put_buffer(buffer);\n\n\treturn error;\n\naudit:\n\terror = fn_for_each(label, profile,\n\t\t\taa_audit_file(current_cred(), profile, &nullperms,\n\t\t\t\t      OP_EXEC, MAY_EXEC,\n\t\t\t\t      bprm->filename, NULL, new,\n\t\t\t\t      vfsuid_into_kuid(vfsuid), info, error));\n\taa_put_label(new);\n\tgoto done;\n}\n\n \n\n\n \nstatic struct aa_label *build_change_hat(const struct cred *subj_cred,\n\t\t\t\t\t struct aa_profile *profile,\n\t\t\t\t\t const char *name, bool sibling)\n{\n\tstruct aa_profile *root, *hat = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile_rcu(&profile->parent);\n\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile(profile);\n\t} else {\n\t\tinfo = \"conflicting target types\";\n\t\terror = -EPERM;\n\t\tgoto audit;\n\t}\n\n\that = aa_find_child(root, name);\n\tif (!hat) {\n\t\terror = -ENOENT;\n\t\tif (COMPLAIN_MODE(profile)) {\n\t\t\that = aa_new_learning_profile(profile, true, name,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!hat) {\n\t\t\t\tinfo = \"failed null profile create\";\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\taa_put_profile(root);\n\naudit:\n\taa_audit_file(subj_cred, profile, &nullperms, OP_CHANGE_HAT,\n\t\t      AA_MAY_CHANGEHAT,\n\t\t      name, hat ? hat->base.hname : NULL,\n\t\t      hat ? &hat->label : NULL, GLOBAL_ROOT_UID, info,\n\t\t      error);\n\tif (!hat || (error && error != -ENOENT))\n\t\treturn ERR_PTR(error);\n\t \n\treturn &hat->label;\n}\n\n \nstatic struct aa_label *change_hat(const struct cred *subj_cred,\n\t\t\t\t   struct aa_label *label, const char *hats[],\n\t\t\t\t   int count, int flags)\n{\n\tstruct aa_profile *profile, *root, *hat = NULL;\n\tstruct aa_label *new;\n\tstruct label_it it;\n\tbool sibling = false;\n\tconst char *name, *info = NULL;\n\tint i, error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!hats);\n\tAA_BUG(count < 1);\n\n\tif (PROFILE_IS_HAT(labels_profile(label)))\n\t\tsibling = true;\n\n\t \n\tfor (i = 0; i < count && !hat; i++) {\n\t\tname = hats[i];\n\t\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile_rcu(&profile->parent);\n\t\t\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile(profile);\n\t\t\t} else {\t \n\t\t\t\tinfo = \"conflicting targets types\";\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\that = aa_find_child(root, name);\n\t\t\taa_put_profile(root);\n\t\t\tif (!hat) {\n\t\t\t\tif (!COMPLAIN_MODE(profile))\n\t\t\t\t\tgoto outer_continue;\n\t\t\t\t \n\t\t\t} else if (!PROFILE_IS_HAT(hat)) {\n\t\t\t\tinfo = \"target not hat\";\n\t\t\t\terror = -EPERM;\n\t\t\t\taa_put_profile(hat);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\taa_put_profile(hat);\n\t\t}\n\t\t \n\t\tgoto build;\nouter_continue:\n\t;\n\t}\n\t \n\tname = NULL;\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\tif (!list_empty(&profile->base.profiles)) {\n\t\t\tinfo = \"hat not found\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tinfo = \"no hats defined\";\n\terror = -ECHILD;\n\nfail:\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t \n\t\t \n\t\tif (count > 1 || COMPLAIN_MODE(profile)) {\n\t\t\taa_audit_file(subj_cred, profile, &nullperms,\n\t\t\t\t      OP_CHANGE_HAT,\n\t\t\t\t      AA_MAY_CHANGEHAT, name, NULL, NULL,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error);\n\t\t}\n\t}\n\treturn ERR_PTR(error);\n\nbuild:\n\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t   build_change_hat(subj_cred, profile, name,\n\t\t\t\t\t\t    sibling),\n\t\t\t\t   aa_get_label(&profile->label));\n\tif (!new) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}  \n\n\treturn new;\n}\n\n \nint aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *subj_cred;\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t \n\tsubj_cred = get_current_cred();\n\tlabel = aa_get_newest_cred_label(subj_cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\t \n\tif (task_no_new_privs(current) && !unconfined(label) && !ctx->nnp)\n\t\tctx->nnp = aa_get_label(label);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(subj_cred, label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terror = may_change_ptraced_domain(subj_cred, new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (task_no_new_privs(current) && !unconfined(label) &&\n\t\t    !aa_label_is_unconfined_subset(new, ctx->nnp)) {\n\t\t\t \n\t\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t \n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t \n\t\tif (task_no_new_privs(current) && !unconfined(label) &&\n\t\t    !aa_label_is_unconfined_subset(previous, ctx->nnp)) {\n\t\t\t \n\t\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t}  \n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(subj_cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(subj_cred, profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}\n\n\nstatic int change_profile_perms_wrapper(const char *op, const char *name,\n\t\t\t\t\tconst struct cred *subj_cred,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\t\tu32 request, struct aa_perms *perms)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (!error)\n\t\terror = change_profile_perms(profile, target, stack, request,\n\t\t\t\t\t     rules->file.start[AA_CLASS_FILE],\n\t\t\t\t\t     perms);\n\tif (error)\n\t\terror = aa_audit_file(subj_cred, profile, perms, op, request,\n\t\t\t\t      name,\n\t\t\t\t      NULL, target, GLOBAL_ROOT_UID, info,\n\t\t\t\t      error);\n\n\treturn error;\n}\n\n \nint aa_change_profile(const char *fqname, int flags)\n{\n\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t \n\tbool stack = flags & AA_CHANGE_STACK;\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tconst struct cred *subj_cred = get_current_cred();\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tlabel = aa_get_current_label();\n\n\t \n\tif (task_no_new_privs(current) && !unconfined(label) && !ctx->nnp)\n\t\tctx->nnp = aa_get_label(label);\n\n\tif (!fqname || !*fqname) {\n\t\taa_put_label(label);\n\t\tAA_DEBUG(\"no profile name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t \n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = \"label not found\";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t \n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t \n\t\ttprofile = aa_new_learning_profile(labels_profile(label), false,\n\t\t\t\t\t\t   fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = \"failed null profile create\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t \n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     subj_cred,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t \n\t\tgoto out;\n\n\t \n\ncheck:\n\t \n\terror = may_change_ptraced_domain(subj_cred, target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t \n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\t \n\tif (!stack) {\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t\t   aa_get_label(target),\n\t\t\t\t\t   aa_get_label(&profile->label));\n\t\t \n\t\tif (task_no_new_privs(current) && !unconfined(label) &&\n\t\t    !aa_label_is_unconfined_subset(new, ctx->nnp)) {\n\t\t\t \n\t\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t \n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\tif (IS_ERR_OR_NULL(new)) {\n\t\t\tinfo = \"failed to build target label\";\n\t\t\tif (!new)\n\t\t\t\terror = -ENOMEM;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\tperms.allow = 0;\n\t\t\tgoto audit;\n\t\t}\n\t\terror = aa_replace_current_label(new);\n\t} else {\n\t\tif (new) {\n\t\t\taa_put_label(new);\n\t\t\tnew = NULL;\n\t\t}\n\n\t\t \n\t\terror = aa_set_current_onexec(target, stack);\n\t}\n\naudit:\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(subj_cred,\n\t\t\t\t      profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error));\n\nout:\n\taa_put_label(new);\n\taa_put_label(target);\n\taa_put_label(label);\n\tput_cred(subj_cred);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}