{
  "module_name": "policy_compat.c",
  "hash_id": "b10fbc1b948314ad92b1c96e1f3c9e7b65dda94871ff192789c41fdbe49669f6",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/policy_compat.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/errno.h>\n\n#include \"include/lib.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_compat.h\"\n\n \nstatic u32 dfa_map_xindex(u16 mask)\n{\n\tu16 old_index = (mask >> 10) & 0xf;\n\tu32 index = 0;\n\n\tif (mask & 0x100)\n\t\tindex |= AA_X_UNSAFE;\n\tif (mask & 0x200)\n\t\tindex |= AA_X_INHERIT;\n\tif (mask & 0x80)\n\t\tindex |= AA_X_UNCONFINED;\n\n\tif (old_index == 1) {\n\t\tindex |= AA_X_UNCONFINED;\n\t} else if (old_index == 2) {\n\t\tindex |= AA_X_NAME;\n\t} else if (old_index == 3) {\n\t\tindex |= AA_X_NAME | AA_X_CHILD;\n\t} else if (old_index) {\n\t\tindex |= AA_X_TABLE;\n\t\tindex |= old_index - 4;\n\t}\n\n\treturn index;\n}\n\n \n#define dfa_user_allow(dfa, state) (((ACCEPT_TABLE(dfa)[state]) & 0x7f) | \\\n\t\t\t\t    ((ACCEPT_TABLE(dfa)[state]) & 0x80000000))\n#define dfa_user_xbits(dfa, state) (((ACCEPT_TABLE(dfa)[state]) >> 7) & 0x7f)\n#define dfa_user_audit(dfa, state) ((ACCEPT_TABLE2(dfa)[state]) & 0x7f)\n#define dfa_user_quiet(dfa, state) (((ACCEPT_TABLE2(dfa)[state]) >> 7) & 0x7f)\n#define dfa_user_xindex(dfa, state) \\\n\t(dfa_map_xindex(ACCEPT_TABLE(dfa)[state] & 0x3fff))\n\n#define dfa_other_allow(dfa, state) ((((ACCEPT_TABLE(dfa)[state]) >> 14) & \\\n\t\t\t\t      0x7f) |\t\t\t\t\\\n\t\t\t\t     ((ACCEPT_TABLE(dfa)[state]) & 0x80000000))\n#define dfa_other_xbits(dfa, state) \\\n\t((((ACCEPT_TABLE(dfa)[state]) >> 7) >> 14) & 0x7f)\n#define dfa_other_audit(dfa, state) (((ACCEPT_TABLE2(dfa)[state]) >> 14) & 0x7f)\n#define dfa_other_quiet(dfa, state) \\\n\t((((ACCEPT_TABLE2(dfa)[state]) >> 7) >> 14) & 0x7f)\n#define dfa_other_xindex(dfa, state) \\\n\tdfa_map_xindex((ACCEPT_TABLE(dfa)[state] >> 14) & 0x3fff)\n\n \nstatic u32 map_old_perms(u32 old)\n{\n\tu32 new = old & 0xf;\n\n\tif (old & MAY_READ)\n\t\tnew |= AA_MAY_GETATTR | AA_MAY_OPEN;\n\tif (old & MAY_WRITE)\n\t\tnew |= AA_MAY_SETATTR | AA_MAY_CREATE | AA_MAY_DELETE |\n\t\t       AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_OPEN;\n\tif (old & 0x10)\n\t\tnew |= AA_MAY_LINK;\n\t \n\tif (old & 0x20)\n\t\tnew |= AA_MAY_LOCK | AA_LINK_SUBSET;\n\tif (old & 0x40)\t \n\t\tnew |= AA_EXEC_MMAP;\n\n\treturn new;\n}\n\nstatic void compute_fperms_allow(struct aa_perms *perms, struct aa_dfa *dfa,\n\t\t\t\t aa_state_t state)\n{\n\tperms->allow |= AA_MAY_GETATTR;\n\n\t \n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms->allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms->allow |= AA_MAY_ONEXEC;\n}\n\nstatic struct aa_perms compute_fperms_user(struct aa_dfa *dfa,\n\t\t\t\t\t   aa_state_t state)\n{\n\tstruct aa_perms perms = { };\n\n\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\tperms.xindex = dfa_user_xindex(dfa, state);\n\n\tcompute_fperms_allow(&perms, dfa, state);\n\n\treturn perms;\n}\n\nstatic struct aa_perms compute_fperms_other(struct aa_dfa *dfa,\n\t\t\t\t\t    aa_state_t state)\n{\n\tstruct aa_perms perms = { };\n\n\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\tperms.xindex = dfa_other_xindex(dfa, state);\n\n\tcompute_fperms_allow(&perms, dfa, state);\n\n\treturn perms;\n}\n\n \nstatic struct aa_perms *compute_fperms(struct aa_dfa *dfa,\n\t\t\t\t       u32 *size)\n{\n\taa_state_t state;\n\tunsigned int state_count;\n\tstruct aa_perms *table;\n\n\tAA_BUG(!dfa);\n\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\t \n\ttable = kvcalloc(state_count * 2, sizeof(struct aa_perms), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\t*size = state_count * 2;\n\n\tfor (state = 0; state < state_count; state++) {\n\t\ttable[state * 2] = compute_fperms_user(dfa, state);\n\t\ttable[state * 2 + 1] = compute_fperms_other(dfa, state);\n\t}\n\n\treturn table;\n}\n\nstatic struct aa_perms *compute_xmatch_perms(struct aa_dfa *xmatch,\n\t\t\t\t      u32 *size)\n{\n\tstruct aa_perms *perms;\n\tint state;\n\tint state_count;\n\n\tAA_BUG(!xmatch);\n\n\tstate_count = xmatch->tables[YYTD_ID_BASE]->td_lolen;\n\t \n\tperms = kvcalloc(state_count, sizeof(struct aa_perms), GFP_KERNEL);\n\tif (!perms)\n\t\treturn NULL;\n\t*size = state_count;\n\n\t \n\tfor (state = 1; state < state_count; state++)\n\t\tperms[state].allow = dfa_user_allow(xmatch, state);\n\n\treturn perms;\n}\n\nstatic u32 map_other(u32 x)\n{\n\treturn ((x & 0x3) << 8) |\t \n\t\t((x & 0x1c) << 18) |\t \n\t\t((x & 0x60) << 19);\t \n}\n\nstatic u32 map_xbits(u32 x)\n{\n\treturn ((x & 0x1) << 7) |\n\t\t((x & 0x7e) << 9);\n}\n\nstatic struct aa_perms compute_perms_entry(struct aa_dfa *dfa,\n\t\t\t\t\t   aa_state_t state,\n\t\t\t\t\t   u32 version)\n{\n\tstruct aa_perms perms = { };\n\n\tperms.allow = dfa_user_allow(dfa, state);\n\tperms.audit = dfa_user_audit(dfa, state);\n\tperms.quiet = dfa_user_quiet(dfa, state);\n\n\t \n\tperms.allow |= map_other(dfa_other_allow(dfa, state));\n\tif (VERSION_LE(version, v8))\n\t\tperms.allow |= AA_MAY_LOCK;\n\telse\n\t\tperms.allow |= map_xbits(dfa_user_xbits(dfa, state));\n\n\t \n\tperms.audit |= map_other(dfa_other_audit(dfa, state));\n\tperms.quiet |= map_other(dfa_other_quiet(dfa, state));\n\tif (VERSION_GT(version, v8))\n\t\tperms.quiet |= map_xbits(dfa_other_xbits(dfa, state));\n\n\treturn perms;\n}\n\nstatic struct aa_perms *compute_perms(struct aa_dfa *dfa, u32 version,\n\t\t\t\t      u32 *size)\n{\n\tunsigned int state;\n\tunsigned int state_count;\n\tstruct aa_perms *table;\n\n\tAA_BUG(!dfa);\n\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\t \n\ttable = kvcalloc(state_count, sizeof(struct aa_perms), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\t*size = state_count;\n\n\t \n\tfor (state = 1; state < state_count; state++)\n\t\ttable[state] = compute_perms_entry(dfa, state, version);\n\n\treturn table;\n}\n\n \nstatic void remap_dfa_accept(struct aa_dfa *dfa, unsigned int factor)\n{\n\tunsigned int state;\n\tunsigned int state_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\n\tAA_BUG(!dfa);\n\n\tfor (state = 0; state < state_count; state++)\n\t\tACCEPT_TABLE(dfa)[state] = state * factor;\n\tkvfree(dfa->tables[YYTD_ID_ACCEPT2]);\n\tdfa->tables[YYTD_ID_ACCEPT2] = NULL;\n}\n\n \nint aa_compat_map_xmatch(struct aa_policydb *policy)\n{\n\tpolicy->perms = compute_xmatch_perms(policy->dfa, &policy->size);\n\tif (!policy->perms)\n\t\treturn -ENOMEM;\n\n\tremap_dfa_accept(policy->dfa, 1);\n\n\treturn 0;\n}\n\nint aa_compat_map_policy(struct aa_policydb *policy, u32 version)\n{\n\tpolicy->perms = compute_perms(policy->dfa, version, &policy->size);\n\tif (!policy->perms)\n\t\treturn -ENOMEM;\n\n\tremap_dfa_accept(policy->dfa, 1);\n\n\treturn 0;\n}\n\nint aa_compat_map_file(struct aa_policydb *policy)\n{\n\tpolicy->perms = compute_fperms(policy->dfa, &policy->size);\n\tif (!policy->perms)\n\t\treturn -ENOMEM;\n\n\tremap_dfa_accept(policy->dfa, 2);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}