{
  "module_name": "label.c",
  "hash_id": "0bf8340af4803c1f908a517b0b612127fcf2d4214e4c24278012d678755fe459",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/label.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/seq_file.h>\n#include <linux/sort.h>\n\n#include \"include/apparmor.h\"\n#include \"include/cred.h\"\n#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/secid.h\"\n\n\n \n\n#define PROXY_POISON 97\n#define LABEL_POISON 100\n\nstatic void free_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy) {\n\t\t \n\t\taa_put_label(rcu_dereference_protected(proxy->label, true));\n\t\tmemset(proxy, 0, sizeof(*proxy));\n\t\tRCU_INIT_POINTER(proxy->label, (struct aa_label *)PROXY_POISON);\n\t\tkfree(proxy);\n\t}\n}\n\nvoid aa_proxy_kref(struct kref *kref)\n{\n\tstruct aa_proxy *proxy = container_of(kref, struct aa_proxy, count);\n\n\tfree_proxy(proxy);\n}\n\nstruct aa_proxy *aa_alloc_proxy(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_proxy *new;\n\n\tnew = kzalloc(sizeof(struct aa_proxy), gfp);\n\tif (new) {\n\t\tkref_init(&new->count);\n\t\trcu_assign_pointer(new->label, aa_get_label(label));\n\t}\n\treturn new;\n}\n\n \nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_write(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}\n\nstatic void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}\n\n\n \nstatic int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}\n\n \nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}\n\n \nstatic int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}\n\nstatic bool vec_is_stale(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (profile_is_stale(vec[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic long accum_vec_flags(struct aa_profile **vec, int n)\n{\n\tlong u = FLAG_UNCONFINED;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tu |= vec[i]->label.flags & (FLAG_DEBUG1 | FLAG_DEBUG2 |\n\t\t\t\t\t    FLAG_STALE);\n\t\tif (!(u & vec[i]->label.flags & FLAG_UNCONFINED))\n\t\t\tu &= ~FLAG_UNCONFINED;\n\t}\n\n\treturn u;\n}\n\nstatic int sort_cmp(const void *a, const void *b)\n{\n\treturn profile_cmp(*(struct aa_profile **)a, *(struct aa_profile **)b);\n}\n\n \nstatic inline int unique(struct aa_profile **vec, int n)\n{\n\tint i, pos, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\tpos = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint res = profile_cmp(vec[pos], vec[i]);\n\n\t\tAA_BUG(res > 0, \"vec not sorted\");\n\t\tif (res == 0) {\n\t\t\t \n\t\t\taa_put_profile(vec[i]);\n\t\t\tdups++;\n\t\t\tcontinue;\n\t\t}\n\t\tpos++;\n\t\tif (dups)\n\t\t\tvec[pos] = vec[i];\n\t}\n\n\tAA_BUG(dups < 0);\n\n\treturn dups;\n}\n\n \nint aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t \n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t \n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}\n\n\nvoid aa_label_destroy(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\tif (!label_isprofile(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\taa_put_str(label->hname);\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\taa_put_profile(profile);\n\t\t\tlabel->vec[i.i] = (struct aa_profile *)\n\t\t\t\t\t   (LABEL_POISON + (long) i.i);\n\t\t}\n\t}\n\n\tif (label->proxy) {\n\t\tif (rcu_dereference_protected(label->proxy->label, true) == label)\n\t\t\trcu_assign_pointer(label->proxy->label, NULL);\n\t\taa_put_proxy(label->proxy);\n\t}\n\taa_free_secid(label->secid);\n\n\tlabel->proxy = (struct aa_proxy *) PROXY_POISON + 1;\n}\n\nvoid aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\taa_label_destroy(label);\n\tkfree(label);\n}\n\nstatic void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}\n\nstatic void label_free_rcu(struct rcu_head *head)\n{\n\tstruct aa_label *label = container_of(head, struct aa_label, rcu);\n\n\tif (label->flags & FLAG_IN_TREE)\n\t\t(void) aa_label_remove(label);\n\tlabel_free_switch(label);\n}\n\nvoid aa_label_kref(struct kref *kref)\n{\n\tstruct aa_label *label = container_of(kref, struct aa_label, count);\n\tstruct aa_ns *ns = labels_ns(label);\n\n\tif (!ns) {\n\t\t \n\t\tlabel_free_switch(label);\n\t\treturn;\n\t}\n\t \n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.profiles));\n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.list));\n\n\t \n\tcall_rcu(&label->rcu, label_free_rcu);\n}\n\nstatic void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t \n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}\n\nbool aa_label_init(struct aa_label *label, int size, gfp_t gfp)\n{\n\tAA_BUG(!label);\n\tAA_BUG(size < 1);\n\n\tif (aa_alloc_secid(label, gfp) < 0)\n\t\treturn false;\n\n\tlabel->size = size;\t\t\t \n\tlabel->vec[size] = NULL;\t\t \n\tkref_init(&label->count);\n\tRB_CLEAR_NODE(&label->node);\n\n\treturn true;\n}\n\n \nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t \n\tnew = kzalloc(struct_size(new, vec, size + 1), gfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size, gfp))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t \n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}\n\n\n \nstatic int label_cmp(struct aa_label *a, struct aa_label *b)\n{\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn 0;\n\n\treturn vec_cmp(a->vec, a->size, b->vec, b->size);\n}\n\n \nint aa_label_next_confined(struct aa_label *label, int i)\n{\n\tAA_BUG(!label);\n\tAA_BUG(i < 0);\n\n\tfor (; i < label->size; i++) {\n\t\tif (!profile_unconfined(label->vec[i]))\n\t\t\treturn i;\n\t}\n\n\treturn i;\n}\n\n \nstruct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t      struct aa_label *set,\n\t\t\t\t\t      struct aa_label *sub)\n{\n\tAA_BUG(!set);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > set->size);\n\tAA_BUG(!sub);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > sub->size);\n\n\twhile (I->j < sub->size && I->i < set->size) {\n\t\tint res = profile_cmp(sub->vec[I->j], set->vec[I->i]);\n\n\t\tif (res == 0) {\n\t\t\t(I->j)++;\n\t\t\t(I->i)++;\n\t\t} else if (res > 0)\n\t\t\t(I->i)++;\n\t\telse\n\t\t\treturn sub->vec[(I->j)++];\n\t}\n\n\tif (I->j < sub->size)\n\t\treturn sub->vec[(I->j)++];\n\n\treturn NULL;\n}\n\n \nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}\n\n \nbool aa_label_is_unconfined_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\tstruct aa_profile *p;\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\tdo {\n\t\tp = __aa_label_next_not_in_set(&i, set, sub);\n\t\tif (p && !profile_unconfined(p))\n\t\t\tbreak;\n\t} while (p);\n\n\treturn p == NULL;\n}\n\n\n \nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_write(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_write(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_write(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t \n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t \n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse  \n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t \n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}\n\n \nstatic struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}\n\n\n \nbool aa_label_remove(struct aa_label *label)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\tunsigned long flags;\n\tbool res;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tres = __label_remove(label, ns_unconfined(labels_ns(label)));\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}\n\n \nbool aa_label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tif (name_is_shared(old, new) && labels_ns(old) == labels_ns(new)) {\n\t\twrite_lock_irqsave(&labels_set(old)->lock, flags);\n\t\tif (old->proxy != new->proxy)\n\t\t\t__proxy_share(old, new);\n\t\telse\n\t\t\t__aa_proxy_redirect(old, new);\n\t\tres = __label_replace(old, new);\n\t\twrite_unlock_irqrestore(&labels_set(old)->lock, flags);\n\t} else {\n\t\tstruct aa_label *l;\n\t\tstruct aa_labelset *ls = labels_set(old);\n\n\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\tres = __label_remove(old, new);\n\t\tif (labels_ns(old) != labels_ns(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\tls = labels_set(new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t}\n\t\tl = __label_insert(ls, new, true);\n\t\tres = (l == new);\n\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\taa_put_label(l);\n\t}\n\n\treturn res;\n}\n\n \nstatic struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}\n\n \nstatic struct aa_label *vec_create_and_insert_label(struct aa_profile **vec,\n\t\t\t\t\t\t    int len, gfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tstruct aa_label *new;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tif (len == 1)\n\t\treturn aa_get_label(&vec[0]->label);\n\n\tls = labels_set(&vec[len - 1]->label);\n\n\t \n\tnew = aa_label_alloc(len, NULL, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++)\n\t\tnew->vec[i] = aa_get_profile(vec[i]);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(ls, new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(label, new);\n\n\treturn label;\n}\n\nstruct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct aa_label *label = vec_find(vec, len);\n\n\tif (label)\n\t\treturn label;\n\n\treturn vec_create_and_insert_label(vec, len, gfp);\n}\n\n \nstruct aa_label *aa_label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn vec_find(label->vec, label->size);\n}\n\n\n \nstruct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *label)\n{\n\tstruct aa_label *l;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\n\t \n\tif (!label_is_stale(label)) {\n\t\tread_lock_irqsave(&ls->lock, flags);\n\t\tl = __label_find(label);\n\t\tread_unlock_irqrestore(&ls->lock, flags);\n\t\tif (l)\n\t\t\treturn l;\n\t}\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tl = __label_insert(ls, label, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn l;\n}\n\n\n \nstruct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b)\n{\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > a->size);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > b->size);\n\n\tif (I->i < a->size) {\n\t\tif (I->j < b->size) {\n\t\t\tint res = profile_cmp(a->vec[I->i], b->vec[I->j]);\n\n\t\t\tif (res > 0)\n\t\t\t\treturn b->vec[(I->j)++];\n\t\t\tif (res == 0)\n\t\t\t\t(I->j)++;\n\t\t}\n\n\t\treturn a->vec[(I->i)++];\n\t}\n\n\tif (I->j < b->size)\n\t\treturn b->vec[(I->j)++];\n\n\treturn NULL;\n}\n\n \nstatic int label_merge_cmp(struct aa_label *a, struct aa_label *b,\n\t\t\t   struct aa_label *z)\n{\n\tstruct aa_profile *p = NULL;\n\tstruct label_it i = { };\n\tint k;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!z);\n\n\tfor (k = 0;\n\t     k < z->size && (p = aa_label_next_in_merge(&i, a, b));\n\t     k++) {\n\t\tint res = profile_cmp(p, z->vec[k]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\tif (p)\n\t\treturn 1;\n\telse if (k < z->size)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic struct aa_label *label_merge_insert(struct aa_label *new,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct aa_label *label;\n\tstruct aa_labelset *ls;\n\tstruct aa_profile *next;\n\tstruct label_it i;\n\tunsigned long flags;\n\tint k = 0, invcount = 0;\n\tbool stale = false;\n\n\tAA_BUG(!a);\n\tAA_BUG(a->size < 0);\n\tAA_BUG(!b);\n\tAA_BUG(b->size < 0);\n\tAA_BUG(!new);\n\tAA_BUG(new->size < a->size + b->size);\n\n\tlabel_for_each_in_merge(i, a, b, next) {\n\t\tAA_BUG(!next);\n\t\tif (profile_is_stale(next)) {\n\t\t\tnew->vec[k] = aa_get_newest_profile(next);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy->label);\n\t\t\tif (next->label.proxy != new->vec[k]->label.proxy)\n\t\t\t\tinvcount++;\n\t\t\tk++;\n\t\t\tstale = true;\n\t\t} else\n\t\t\tnew->vec[k++] = aa_get_profile(next);\n\t}\n\t \n\tnew->size = k;\n\tnew->vec[k] = NULL;\n\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t \n\t\tif (new->size == 1) {\n\t\t\tlabel = aa_get_label(&new->vec[0]->label);\n\t\t\treturn label;\n\t\t}\n\t} else if (!stale) {\n\t\t \n\t\tif (k == a->size)\n\t\t\treturn aa_get_label(a);\n\t\telse if (k == b->size)\n\t\t\treturn aa_get_label(b);\n\t}\n\tnew->flags |= accum_vec_flags(new->vec, new->size);\n\tls = labels_set(new);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(labels_set(new), new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}\n\n \nstatic struct aa_labelset *labelset_of_merge(struct aa_label *a,\n\t\t\t\t\t     struct aa_label *b)\n{\n\tstruct aa_ns *nsa = labels_ns(a);\n\tstruct aa_ns *nsb = labels_ns(b);\n\n\tif (ns_cmp(nsa, nsb) <= 0)\n\t\treturn &nsa->labels;\n\treturn &nsb->labels;\n}\n\n \nstatic struct aa_label *__label_find_merge(struct aa_labelset *ls,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn __label_find(a);\n\n\tnode  = ls->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = container_of(node, struct aa_label,\n\t\t\t\t\t\t     node);\n\t\tint result = label_merge_cmp(a, b, this);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}\n\n\n \nstruct aa_label *aa_label_find_merge(struct aa_label *a, struct aa_label *b)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label, *ar = NULL, *br = NULL;\n\tunsigned long flags;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (label_is_stale(a))\n\t\ta = ar = aa_get_newest_label(a);\n\tif (label_is_stale(b))\n\t\tb = br = aa_get_newest_label(b);\n\tls = labelset_of_merge(a, b);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_find_merge(ls, a, b);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\taa_put_label(ar);\n\taa_put_label(br);\n\n\treturn label;\n}\n\n \nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t \n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t \n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}\n\n \nstatic inline aa_state_t match_component(struct aa_profile *profile,\n\t\t\t\t\t struct aa_ruleset *rules,\n\t\t\t\t\t struct aa_profile *tp,\n\t\t\t\t\t aa_state_t state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(rules->policy.dfa, state, tp->base.hname);\n\n\t \n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(rules->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(rules->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(rules->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(rules->policy.dfa, state, tp->base.hname);\n}\n\n \nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_ruleset *rules,\n\t\t\t\tstruct aa_label *label,\n\t\t\t\taa_state_t state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\n\t \n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, rules, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t \n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(rules->policy.dfa, state, \"//&\");\n\t\tstate = match_component(profile, rules, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = *aa_lookup_perms(&rules->policy, state);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn state;\n}\n\n \nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_ruleset *rules,\n\t\t\t\t  struct aa_label *label, aa_state_t start,\n\t\t\t\t  bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\taa_state_t state = 0;\n\n\t \n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, rules, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t \n\treturn 0;\n\nnext:\n\ttmp = *aa_lookup_perms(&rules->policy, state);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, rules, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = *aa_lookup_perms(&rules->policy, state);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}\n\n \nint aa_label_match(struct aa_profile *profile, struct aa_ruleset *rules,\n\t\t   struct aa_label *label, aa_state_t state, bool subns,\n\t\t   u32 request, struct aa_perms *perms)\n{\n\tint error = label_compound_match(profile, rules, label, state, subns,\n\t\t\t\t\t request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, rules, label, state, subns,\n\t\t\t\t      request, perms);\n}\n\n\n \nbool aa_update_label_name(struct aa_ns *ns, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tchar __counted *name;\n\tbool res = false;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!label);\n\n\tif (label->hname || labels_ns(label) != ns)\n\t\treturn res;\n\n\tif (aa_label_acntsxprint(&name, ns, label, FLAGS_NONE, gfp) < 0)\n\t\treturn res;\n\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tif (!label->hname && label->flags & FLAG_IN_TREE) {\n\t\tlabel->hname = name;\n\t\tres = true;\n\t} else\n\t\taa_put_str(name);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}\n\n \nstatic inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}\n\n \n#define update_for_len(total, len, size, str)\t\\\ndo {\t\t\t\t\t\\\n\tsize_t ulen = len;\t\t\\\n\t\t\t\t\t\\\n\tAA_BUG(len < 0);\t\t\\\n\ttotal += ulen;\t\t\t\\\n\tulen = min(ulen, size);\t\t\\\n\tsize -= ulen;\t\t\t\\\n\tstr += ulen;\t\t\t\\\n} while (0)\n\n \nstatic int aa_profile_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t\t       struct aa_profile *profile, int flags,\n\t\t\t       struct aa_ns **prev_ns)\n{\n\tconst char *ns_name = NULL;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!profile);\n\n\tif (!view)\n\t\tview = profiles_ns(profile);\n\n\tif (view != profile->ns &&\n\t    (!prev_ns || (*prev_ns != profile->ns))) {\n\t\tif (prev_ns)\n\t\t\t*prev_ns = profile->ns;\n\t\tns_name = aa_ns_name(view, profile->ns,\n\t\t\t\t     flags & FLAG_VIEW_SUBNS);\n\t\tif (ns_name == aa_hidden_ns_name) {\n\t\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\t\treturn snprintf(str, size, \"%s\", ns_name);\n\t\t}\n\t}\n\n\tif ((flags & FLAG_SHOW_MODE) && profile != profile->ns->unconfined) {\n\t\tconst char *modestr = aa_profile_mode_names[profile->mode];\n\n\t\tif (ns_name)\n\t\t\treturn snprintf(str, size, \":%s:%s (%s)\", ns_name,\n\t\t\t\t\tprofile->base.hname, modestr);\n\t\treturn snprintf(str, size, \"%s (%s)\", profile->base.hname,\n\t\t\t\tmodestr);\n\t}\n\n\tif (ns_name)\n\t\treturn snprintf(str, size, \":%s:%s\", ns_name,\n\t\t\t\tprofile->base.hname);\n\treturn snprintf(str, size, \"%s\", profile->base.hname);\n}\n\nstatic const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tcount++;\n\t\t\tif (profile == profile->ns->unconfined)\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t \n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}\n\n \nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t \n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\n \nint aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tssize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (AA_DEBUG_LABEL && (flags & FLAG_ABS_ROOT)) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"_\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t \n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}\n#undef update_for_len\n\n \nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}\n\n \nint aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = aa_str_alloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}\n\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len < 0) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}\n\nvoid aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len < 0) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_puts(f, str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_puts(f, label->hname);\n}\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len < 0) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}\n\nvoid aa_label_audit(struct audit_buffer *ab, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xaudit(ab, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}\n\nvoid aa_label_seq_print(struct seq_file *f, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_seq_xprint(f, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}\n\nstatic int label_count_strn_entries(const char *str, size_t n)\n{\n\tconst char *end = str + n;\n\tconst char *split;\n\tint count = 1;\n\n\tAA_BUG(!str);\n\n\tfor (split = aa_label_strn_split(str, end - str);\n\t     split;\n\t     split = aa_label_strn_split(str, end - str)) {\n\t\tcount++;\n\t\tstr = split + 3;\n\t}\n\n\treturn count;\n}\n\n \nstatic struct aa_profile *fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\t    struct aa_label *currentbase,\n\t\t\t\t\t    const char *str, size_t n)\n{\n\tconst char *first = skipn_spaces(str, n);\n\n\tif (first && *first == ':')\n\t\treturn aa_fqlookupn_profile(base, str, n);\n\n\treturn aa_fqlookupn_profile(currentbase, str, n);\n}\n\n \nstruct aa_label *aa_label_strn_parse(struct aa_label *base, const char *str,\n\t\t\t\t     size_t n, gfp_t gfp, bool create,\n\t\t\t\t     bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tconst char *end = str + n;\n\tconst char *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skipn_spaces(str, n);\n\tif (str == NULL || (AA_DEBUG_LABEL && *str == '_' &&\n\t\t\t    base != &root_ns->unconfined->label))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = label_count_strn_entries(str, end - str);\n\tif (*str == '&' || force_stack) {\n\t\t \n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = aa_label_strn_split(str, end - str), i = stack;\n\t     split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t \n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = aa_label_strn_split(str, end - str);\n\t}\n\t \n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, end - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t \n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t \n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t \n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\treturn aa_label_strn_parse(base, str, strlen(str), gfp, create,\n\t\t\t\t   force_stack);\n}\n\n \nvoid aa_labelset_destroy(struct aa_labelset *ls)\n{\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (node = rb_first(&ls->root); node; node = rb_first(&ls->root)) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\n\t\tif (labels_ns(this) != root_ns)\n\t\t\t__label_remove(this,\n\t\t\t\t       ns_unconfined(labels_ns(this)->parent));\n\t\telse\n\t\t\t__label_remove(this, NULL);\n\t}\n\twrite_unlock_irqrestore(&ls->lock, flags);\n}\n\n \nvoid aa_labelset_init(struct aa_labelset *ls)\n{\n\tAA_BUG(!ls);\n\n\trwlock_init(&ls->lock);\n\tls->root = RB_ROOT;\n}\n\nstatic struct aa_label *labelset_next_stale(struct aa_labelset *ls)\n{\n\tstruct aa_label *label;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\tread_lock_irqsave(&ls->lock, flags);\n\n\t__labelset_for_each(ls, node) {\n\t\tlabel = rb_entry(node, struct aa_label, node);\n\t\tif ((label_is_stale(label) ||\n\t\t     vec_is_stale(label->vec, label->size)) &&\n\t\t    __aa_get_label(label))\n\t\t\tgoto out;\n\n\t}\n\tlabel = NULL;\n\nout:\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}\n\n \nstatic struct aa_label *__label_update(struct aa_label *label)\n{\n\tstruct aa_label *new, *tmp;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tint i, invcount = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!mutex_is_locked(&labels_ns(label)->lock));\n\n\tnew = aa_label_alloc(label->size, label->proxy, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t \n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (i = 0; i < label->size; i++) {\n\t\tAA_BUG(!label->vec[i]);\n\t\tnew->vec[i] = aa_get_newest_profile(label->vec[i]);\n\t\tAA_BUG(!new->vec[i]);\n\t\tAA_BUG(!new->vec[i]->label.proxy);\n\t\tAA_BUG(!new->vec[i]->label.proxy->label);\n\t\tif (new->vec[i]->label.proxy != label->vec[i]->label.proxy)\n\t\t\tinvcount++;\n\t}\n\n\t \n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t \n\t\tif (new->size == 1) {\n\t\t\ttmp = aa_get_label(&new->vec[0]->label);\n\t\t\tAA_BUG(tmp == label);\n\t\t\tgoto remove;\n\t\t}\n\t\tif (labels_set(label) != labels_set(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\ttmp = aa_label_insert(labels_set(new), new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t\tgoto remove;\n\t\t}\n\t} else\n\t\tAA_BUG(labels_ns(label) != labels_ns(new));\n\n\ttmp = __label_insert(labels_set(label), new, true);\nremove:\n\t \n\t__label_remove(label, tmp);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(tmp, new);\n\n\treturn tmp;\n}\n\n \nstatic void __labelset_update(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tdo {\n\t\tlabel = labelset_next_stale(&ns->labels);\n\t\tif (label) {\n\t\t\tstruct aa_label *l = __label_update(label);\n\n\t\t\taa_put_label(l);\n\t\t\taa_put_label(label);\n\t\t}\n\t} while (label);\n}\n\n \nvoid __aa_labelset_update_subtree(struct aa_ns *ns)\n{\n\tstruct aa_ns *child;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\t__labelset_update(ns);\n\n\tlist_for_each_entry(child, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&child->lock, child->level);\n\t\t__aa_labelset_update_subtree(child);\n\t\tmutex_unlock(&child->lock);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}