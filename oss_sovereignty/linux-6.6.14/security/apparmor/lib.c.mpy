{
  "module_name": "lib.c",
  "hash_id": "539568786c4d898f75f1c06c5f746128076cf7158718ec64a92032e9493cd713",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/lib.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include \"include/lib.h\"\n#include \"include/perms.h\"\n#include \"include/policy.h\"\n\nstruct aa_perms nullperms;\nstruct aa_perms allperms = { .allow = ALL_PERMS_MASK,\n\t\t\t     .quiet = ALL_PERMS_MASK,\n\t\t\t     .hide = ALL_PERMS_MASK };\n\n \nvoid aa_free_str_table(struct aa_str_table *t)\n{\n\tint i;\n\n\tif (t) {\n\t\tif (!t->table)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < t->size; i++)\n\t\t\tkfree_sensitive(t->table[i]);\n\t\tkfree_sensitive(t->table);\n\t\tt->table = NULL;\n\t\tt->size = 0;\n\t}\n}\n\n \nchar *aa_split_fqname(char *fqname, char **ns_name)\n{\n\tchar *name = strim(fqname);\n\n\t*ns_name = NULL;\n\tif (name[0] == ':') {\n\t\tchar *split = strchr(&name[1], ':');\n\t\t*ns_name = skip_spaces(&name[1]);\n\t\tif (split) {\n\t\t\t \n\t\t\t*split++ = 0;\n\t\t\tif (strncmp(split, \"//\", 2) == 0)\n\t\t\t\tsplit += 2;\n\t\t\tname = skip_spaces(split);\n\t\t} else\n\t\t\t \n\t\t\tname = NULL;\n\t}\n\tif (name && *name == 0)\n\t\tname = NULL;\n\n\treturn name;\n}\n\n \n\nconst char *skipn_spaces(const char *str, size_t n)\n{\n\tfor (; n && isspace(*str); --n)\n\t\t++str;\n\tif (n)\n\t\treturn (char *)str;\n\treturn NULL;\n}\n\nconst char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,\n\t\t\t     size_t *ns_len)\n{\n\tconst char *end = fqname + n;\n\tconst char *name = skipn_spaces(fqname, n);\n\n\t*ns_name = NULL;\n\t*ns_len = 0;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tif (name[0] == ':') {\n\t\tchar *split = strnchr(&name[1], end - &name[1], ':');\n\t\t*ns_name = skipn_spaces(&name[1], end - &name[1]);\n\t\tif (!*ns_name)\n\t\t\treturn NULL;\n\t\tif (split) {\n\t\t\t*ns_len = split - *ns_name;\n\t\t\tif (*ns_len == 0)\n\t\t\t\t*ns_name = NULL;\n\t\t\tsplit++;\n\t\t\tif (end - split > 1 && strncmp(split, \"//\", 2) == 0)\n\t\t\t\tsplit += 2;\n\t\t\tname = skipn_spaces(split, end - split);\n\t\t} else {\n\t\t\t \n\t\t\tname = NULL;\n\t\t\t*ns_len = end - *ns_name;\n\t\t}\n\t}\n\tif (name && *name == 0)\n\t\tname = NULL;\n\n\treturn name;\n}\n\n \nvoid aa_info_message(const char *str)\n{\n\tif (audit_enabled) {\n\t\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_NONE, NULL);\n\n\t\tad.info = str;\n\t\taa_audit_msg(AUDIT_APPARMOR_STATUS, &ad, NULL);\n\t}\n\tprintk(KERN_INFO \"AppArmor: %s\\n\", str);\n}\n\n__counted char *aa_str_alloc(int size, gfp_t gfp)\n{\n\tstruct counted_str *str;\n\n\tstr = kmalloc(struct_size(str, name, size), gfp);\n\tif (!str)\n\t\treturn NULL;\n\n\tkref_init(&str->count);\n\treturn str->name;\n}\n\nvoid aa_str_kref(struct kref *kref)\n{\n\tkfree(container_of(kref, struct counted_str, count));\n}\n\n\nconst char aa_file_perm_chrs[] = \"xwracd         km l     \";\nconst char *aa_file_perm_names[] = {\n\t\"exec\",\n\t\"write\",\n\t\"read\",\n\t\"append\",\n\n\t\"create\",\n\t\"delete\",\n\t\"open\",\n\t\"rename\",\n\n\t\"setattr\",\n\t\"getattr\",\n\t\"setcred\",\n\t\"getcred\",\n\n\t\"chmod\",\n\t\"chown\",\n\t\"chgrp\",\n\t\"lock\",\n\n\t\"mmap\",\n\t\"mprot\",\n\t\"link\",\n\t\"snapshot\",\n\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\n\t\"stack\",\n\t\"change_onexec\",\n\t\"change_profile\",\n\t\"change_hat\",\n};\n\n \nvoid aa_perm_mask_to_str(char *str, size_t str_size, const char *chrs, u32 mask)\n{\n\tunsigned int i, perm = 1;\n\tsize_t num_chrs = strlen(chrs);\n\n\tfor (i = 0; i < num_chrs; perm <<= 1, i++) {\n\t\tif (mask & perm) {\n\t\t\t \n\t\t\tif (WARN_ON_ONCE(str_size <= 1))\n\t\t\t\tbreak;\n\n\t\t\t*str++ = chrs[i];\n\t\t\tstr_size--;\n\t\t}\n\t}\n\t*str = '\\0';\n}\n\nvoid aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,\n\t\t\t u32 mask)\n{\n\tconst char *fmt = \"%s\";\n\tunsigned int i, perm = 1;\n\tbool prev = false;\n\n\tfor (i = 0; i < 32; perm <<= 1, i++) {\n\t\tif (mask & perm) {\n\t\t\taudit_log_format(ab, fmt, names[i]);\n\t\t\tif (!prev) {\n\t\t\t\tprev = true;\n\t\t\t\tfmt = \" %s\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,\n\t\t\tu32 chrsmask, const char * const *names, u32 namesmask)\n{\n\tchar str[33];\n\n\taudit_log_format(ab, \"\\\"\");\n\tif ((mask & chrsmask) && chrs) {\n\t\taa_perm_mask_to_str(str, sizeof(str), chrs, mask & chrsmask);\n\t\tmask &= ~chrsmask;\n\t\taudit_log_format(ab, \"%s\", str);\n\t\tif (mask & namesmask)\n\t\t\taudit_log_format(ab, \" \");\n\t}\n\tif ((mask & namesmask) && names)\n\t\taa_audit_perm_names(ab, names, mask & namesmask);\n\taudit_log_format(ab, \"\\\"\");\n}\n\n \nstatic void aa_audit_perms_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->request) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taa_audit_perm_mask(ab, ad->request, aa_file_perm_chrs,\n\t\t\t\t   PERMS_CHRS_MASK, aa_file_perm_names,\n\t\t\t\t   PERMS_NAMES_MASK);\n\t}\n\tif (ad->denied) {\n\t\taudit_log_format(ab, \"denied_mask=\");\n\t\taa_audit_perm_mask(ab, ad->denied, aa_file_perm_chrs,\n\t\t\t\t   PERMS_CHRS_MASK, aa_file_perm_names,\n\t\t\t\t   PERMS_NAMES_MASK);\n\t}\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\t\t      FLAGS_NONE, GFP_ATOMIC);\n}\n\n \nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\tfallthrough;\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\tfallthrough;\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n\telse if (USER_MODE(profile))\n\t\tperms->prompt = ALL_PERMS_MASK;\n}\n\nvoid aa_profile_match_label(struct aa_profile *profile,\n\t\t\t    struct aa_ruleset *rules,\n\t\t\t    struct aa_label *label,\n\t\t\t    int type, u32 request, struct aa_perms *perms)\n{\n\t \n\taa_state_t state;\n\n\tstate = aa_dfa_next(rules->policy.dfa,\n\t\t\t    rules->policy.start[AA_CLASS_LABEL],\n\t\t\t    type);\n\taa_label_match(profile, rules, label, state, false, request, perms);\n}\n\n\n \nint aa_profile_label_perm(struct aa_profile *profile, struct aa_profile *target,\n\t\t\t  u32 request, int type, u32 *deny,\n\t\t\t  struct apparmor_audit_data *ad)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms perms;\n\n\tad->peer = &target->label;\n\tad->request = request;\n\n\taa_profile_match_label(profile, rules, &target->label, type, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\t*deny |= request & perms.deny;\n\treturn aa_check_perms(profile, &perms, request, ad, aa_audit_perms_cb);\n}\n\n \nint aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,\n\t\t   u32 request, struct apparmor_audit_data *ad,\n\t\t   void (*cb)(struct audit_buffer *, void *))\n{\n\tint type, error;\n\tu32 denied = request & (~perms->allow | perms->deny);\n\n\tif (likely(!denied)) {\n\t\t \n\t\trequest &= perms->audit;\n\t\tif (!request || !ad)\n\t\t\treturn 0;\n\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\terror = 0;\n\t} else {\n\t\terror = -EACCES;\n\n\t\tif (denied & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\t\telse if (denied == (denied & perms->complain))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\n\t\tif (denied == (denied & perms->hide))\n\t\t\terror = -ENOENT;\n\n\t\tdenied &= ~perms->quiet;\n\t\tif (!ad || !denied)\n\t\t\treturn error;\n\t}\n\n\tif (ad) {\n\t\tad->subj_label = &profile->label;\n\t\tad->request = request;\n\t\tad->denied = denied;\n\t\tad->error = error;\n\t\taa_audit_msg(type, ad, cb);\n\t}\n\n\tif (type == AUDIT_APPARMOR_ALLOWED)\n\t\terror = 0;\n\n\treturn error;\n}\n\n\n \nbool aa_policy_init(struct aa_policy *policy, const char *prefix,\n\t\t    const char *name, gfp_t gfp)\n{\n\tchar *hname;\n\n\t \n\tif (prefix) {\n\t\thname = aa_str_alloc(strlen(prefix) + strlen(name) + 3, gfp);\n\t\tif (hname)\n\t\t\tsprintf(hname, \"%s//%s\", prefix, name);\n\t} else {\n\t\thname = aa_str_alloc(strlen(name) + 1, gfp);\n\t\tif (hname)\n\t\t\tstrcpy(hname, name);\n\t}\n\tif (!hname)\n\t\treturn false;\n\tpolicy->hname = hname;\n\t \n\tpolicy->name = basename(policy->hname);\n\tINIT_LIST_HEAD(&policy->list);\n\tINIT_LIST_HEAD(&policy->profiles);\n\n\treturn true;\n}\n\n \nvoid aa_policy_destroy(struct aa_policy *policy)\n{\n\tAA_BUG(on_list_rcu(&policy->profiles));\n\tAA_BUG(on_list_rcu(&policy->list));\n\n\t \n\taa_put_str(policy->hname);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}