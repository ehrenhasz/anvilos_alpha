{
  "module_name": "lib.h",
  "hash_id": "e11b86ecbdda55765c7a653e8f81f14304a4f78646796b4cb59f8ac7423601d1",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/lib.h",
  "human_readable_source": " \n \n\n#ifndef __AA_LIB_H\n#define __AA_LIB_H\n\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/lsm_hooks.h>\n\n#include \"match.h\"\n\n \n\n#define DEBUG_ON (aa_g_debug)\n \n#define AA_DEBUG_LABEL DEBUG_ON\n#define dbg_printk(__fmt, __args...) pr_debug(__fmt, ##__args)\n#define AA_DEBUG(fmt, args...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (DEBUG_ON)\t\t\t\t\t\t\\\n\t\t\tpr_debug_ratelimited(\"AppArmor: \" fmt, ##args);\t\\\n\t} while (0)\n\n#define AA_WARN(X) WARN((X), \"APPARMOR WARN %s: %s\\n\", __func__, #X)\n\n#define AA_BUG(X, args...)\t\t\t\t\t\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\t_Pragma(\"GCC diagnostic ignored \\\"-Wformat-zero-length\\\"\"); \\\n\t\tAA_BUG_FMT((X), \"\" args);\t\t\t\t    \\\n\t\t_Pragma(\"GCC diagnostic warning \\\"-Wformat-zero-length\\\"\"); \\\n\t} while (0)\n#ifdef CONFIG_SECURITY_APPARMOR_DEBUG_ASSERTS\n#define AA_BUG_FMT(X, fmt, args...)\t\t\t\t\t\\\n\tWARN((X), \"AppArmor WARN %s: (\" #X \"): \" fmt, __func__, ##args)\n#else\n#define AA_BUG_FMT(X, fmt, args...) no_printk(fmt, ##args)\n#endif\n\n#define AA_ERROR(fmt, args...)\t\t\t\t\t\t\\\n\tpr_err_ratelimited(\"AppArmor: \" fmt, ##args)\n\n \nextern int apparmor_initialized;\n\n \nconst char *skipn_spaces(const char *str, size_t n);\nchar *aa_split_fqname(char *args, char **ns_name);\nconst char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,\n\t\t\t     size_t *ns_len);\nvoid aa_info_message(const char *str);\n\n \nextern struct lsm_blob_sizes apparmor_blob_sizes;\n\n \nstatic inline bool aa_strneq(const char *str, const char *sub, int len)\n{\n\treturn !strncmp(str, sub, len) && !str[len];\n}\n\n \nstatic inline aa_state_t aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\taa_state_t start)\n{\n\t \n\treturn aa_dfa_next(dfa, start, 0);\n}\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}\n\nstruct aa_str_table {\n\tint size;\n\tchar **table;\n};\n\nvoid aa_free_str_table(struct aa_str_table *table);\n\nstruct counted_str {\n\tstruct kref count;\n\tchar name[];\n};\n\n#define str_to_counted(str) \\\n\t((struct counted_str *)(str - offsetof(struct counted_str, name)))\n\n#define __counted\t \n\nvoid aa_str_kref(struct kref *kref);\nchar *aa_str_alloc(int size, gfp_t gfp);\n\n\nstatic inline __counted char *aa_get_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_get(&(str_to_counted(str)->count));\n\n\treturn str;\n}\n\nstatic inline void aa_put_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_put(&str_to_counted(str)->count, aa_str_kref);\n}\n\n\n \nstruct aa_policy {\n\tconst char *name;\n\t__counted char *hname;\n\tstruct list_head list;\n\tstruct list_head profiles;\n};\n\n \nstatic inline const char *basename(const char *hname)\n{\n\tchar *split;\n\n\thname = strim((char *)hname);\n\tfor (split = strstr(hname, \"//\"); split; split = strstr(hname, \"//\"))\n\t\thname = split + 2;\n\n\treturn hname;\n}\n\n \nstatic inline struct aa_policy *__policy_find(struct list_head *head,\n\t\t\t\t\t      const char *name)\n{\n\tstruct aa_policy *policy;\n\n\tlist_for_each_entry_rcu(policy, head, list) {\n\t\tif (!strcmp(policy->name, name))\n\t\t\treturn policy;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline struct aa_policy *__policy_strn_find(struct list_head *head,\n\t\t\t\t\t    const char *str, int len)\n{\n\tstruct aa_policy *policy;\n\n\tlist_for_each_entry_rcu(policy, head, list) {\n\t\tif (aa_strneq(policy->name, str, len))\n\t\t\treturn policy;\n\t}\n\n\treturn NULL;\n}\n\nbool aa_policy_init(struct aa_policy *policy, const char *prefix,\n\t\t    const char *name, gfp_t gfp);\nvoid aa_policy_destroy(struct aa_policy *policy);\n\n\n \n#define fn_label_build(L, P, GFP, FN)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__label__ __do_cleanup, __done;\t\t\t\t\t\\\n\tstruct aa_label *__new_;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif ((L)->size > 1) {\t\t\t\t\t\t\\\n\t\t \t\\\n\t\tstruct label_it __i;\t\t\t\t\t\\\n\t\tint __j, __k, __count;\t\t\t\t\t\\\n\t\tDEFINE_VEC(label, __lvec);\t\t\t\t\\\n\t\tDEFINE_VEC(profile, __pvec);\t\t\t\t\\\n\t\tif (vec_setup(label, __lvec, (L)->size, (GFP)))\t{\t\\\n\t\t\t__new_ = NULL;\t\t\t\t\t\\\n\t\t\tgoto __done;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t__j = 0;\t\t\t\t\t\t\\\n\t\tlabel_for_each(__i, (L), (P)) {\t\t\t\t\\\n\t\t\t__new_ = (FN);\t\t\t\t\t\\\n\t\t\tAA_BUG(!__new_);\t\t\t\t\\\n\t\t\tif (IS_ERR(__new_))\t\t\t\t\\\n\t\t\t\tgoto __do_cleanup;\t\t\t\\\n\t\t\t__lvec[__j++] = __new_;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tfor (__j = __count = 0; __j < (L)->size; __j++)\t\t\\\n\t\t\t__count += __lvec[__j]->size;\t\t\t\\\n\t\tif (!vec_setup(profile, __pvec, __count, (GFP))) {\t\\\n\t\t\tfor (__j = __k = 0; __j < (L)->size; __j++) {\t\\\n\t\t\t\tlabel_for_each(__i, __lvec[__j], (P))\t\\\n\t\t\t\t\t__pvec[__k++] = aa_get_profile(P); \\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\t__count -= aa_vec_unique(__pvec, __count, 0);\t\\\n\t\t\tif (__count > 1) {\t\t\t\t\\\n\t\t\t\t__new_ = aa_vec_find_or_create_label(__pvec,\\\n\t\t\t\t\t\t     __count, (GFP));\t\\\n\t\t\t\t \t\t\\\n\t\t\t\tif (!__new_)\t\t\t\t\\\n\t\t\t\t\t__new_ = NULL;\t\t\t\\\n\t\t\t} else\t\t\t\t\t\t\\\n\t\t\t\t__new_ = aa_get_label(&__pvec[0]->label); \\\n\t\t\tvec_cleanup(profile, __pvec, __count);\t\t\\\n\t\t} else\t\t\t\t\t\t\t\\\n\t\t\t__new_ = NULL;\t\t\t\t\t\\\n__do_cleanup:\t\t\t\t\t\t\t\t\\\n\t\tvec_cleanup(label, __lvec, (L)->size);\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t(P) = labels_profile(L);\t\t\t\t\\\n\t\t__new_ = (FN);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n__done:\t\t\t\t\t\t\t\t\t\\\n\tif (!__new_)\t\t\t\t\t\t\t\\\n\t\tAA_DEBUG(\"label build failed\\n\");\t\t\t\\\n\t(__new_);\t\t\t\t\t\t\t\\\n})\n\n\n#define __fn_build_in_ns(NS, P, NS_FN, OTHER_FN)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct aa_label *__new;\t\t\t\t\t\t\\\n\tif ((P)->ns != (NS))\t\t\t\t\t\t\\\n\t\t__new = (OTHER_FN);\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__new = (NS_FN);\t\t\t\t\t\\\n\t(__new);\t\t\t\t\t\t\t\\\n})\n\n#define fn_label_build_in_ns(L, P, GFP, NS_FN, OTHER_FN)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tfn_label_build((L), (P), (GFP),\t\t\t\t\t\\\n\t\t__fn_build_in_ns(labels_ns(L), (P), (NS_FN), (OTHER_FN))); \\\n})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}