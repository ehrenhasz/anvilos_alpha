{
  "module_name": "policy.h",
  "hash_id": "1821ae340ac15772f057d5e74e367e7a0946da860b2612953ce5f151692644bb",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/policy.h",
  "human_readable_source": " \n \n\n#ifndef __AA_POLICY_H\n#define __AA_POLICY_H\n\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/kref.h>\n#include <linux/rhashtable.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n\n#include \"apparmor.h\"\n#include \"audit.h\"\n#include \"capability.h\"\n#include \"domain.h\"\n#include \"file.h\"\n#include \"lib.h\"\n#include \"label.h\"\n#include \"net.h\"\n#include \"perms.h\"\n#include \"resource.h\"\n\n\nstruct aa_ns;\n\nextern int unprivileged_userns_apparmor_policy;\n\nextern const char *const aa_profile_mode_names[];\n#define APPARMOR_MODE_NAMES_MAX_INDEX 4\n\n#define PROFILE_MODE(_profile, _mode)\t\t\\\n\t((aa_g_profile_mode == (_mode)) ||\t\\\n\t ((_profile)->mode == (_mode)))\n\n#define COMPLAIN_MODE(_profile)\tPROFILE_MODE((_profile), APPARMOR_COMPLAIN)\n\n#define USER_MODE(_profile)\tPROFILE_MODE((_profile), APPARMOR_USER)\n\n#define KILL_MODE(_profile) PROFILE_MODE((_profile), APPARMOR_KILL)\n\n#define PROFILE_IS_HAT(_profile) ((_profile)->label.flags & FLAG_HAT)\n\n#define CHECK_DEBUG1(_profile) ((_profile)->label.flags & FLAG_DEBUG1)\n\n#define CHECK_DEBUG2(_profile) ((_profile)->label.flags & FLAG_DEBUG2)\n\n#define profile_is_stale(_profile) (label_is_stale(&(_profile)->label))\n\n#define on_list_rcu(X) (!list_empty(X) && (X)->prev != LIST_POISON2)\n\n \nenum profile_mode {\n\tAPPARMOR_ENFORCE,\t \n\tAPPARMOR_COMPLAIN,\t \n\tAPPARMOR_KILL,\t\t \n\tAPPARMOR_UNCONFINED,\t \n\tAPPARMOR_USER,\t\t \n};\n\n\n \nstruct aa_policydb {\n\tstruct aa_dfa *dfa;\n\tstruct {\n\t\tstruct aa_perms *perms;\n\t\tu32 size;\n\t};\n\tstruct aa_str_table trans;\n\taa_state_t start[AA_CLASS_LAST + 1];\n};\n\nstatic inline void aa_destroy_policydb(struct aa_policydb *policy)\n{\n\taa_put_dfa(policy->dfa);\n\tif (policy->perms)\n\t\tkvfree(policy->perms);\n\taa_free_str_table(&policy->trans);\n\n}\n\nstatic inline struct aa_perms *aa_lookup_perms(struct aa_policydb *policy,\n\t\t\t\t\t       aa_state_t state)\n{\n\tunsigned int index = ACCEPT_TABLE(policy->dfa)[state];\n\n\tif (!(policy->perms))\n\t\treturn &default_perms;\n\n\treturn &(policy->perms[index]);\n}\n\n\n \nstruct aa_data {\n\tchar *key;\n\tu32 size;\n\tchar *data;\n\tstruct rhash_head head;\n};\n\n \nstruct aa_ruleset {\n\tstruct list_head list;\n\n\tint size;\n\n\t \n\tstruct aa_policydb policy;\n\tstruct aa_policydb file;\n\tstruct aa_caps caps;\n\n\tstruct aa_rlimit rlimits;\n\n\tint secmark_count;\n\tstruct aa_secmark *secmark;\n};\n\n \nstruct aa_attachment {\n\tconst char *xmatch_str;\n\tstruct aa_policydb xmatch;\n\tunsigned int xmatch_len;\n\tint xattr_count;\n\tchar **xattrs;\n};\n\n \nstruct aa_profile {\n\tstruct aa_policy base;\n\tstruct aa_profile __rcu *parent;\n\n\tstruct aa_ns *ns;\n\tconst char *rename;\n\n\tenum audit_mode audit;\n\tlong mode;\n\tu32 path_flags;\n\tconst char *disconnected;\n\n\tstruct aa_attachment attach;\n\tstruct list_head rules;\n\n\tstruct aa_loaddata *rawdata;\n\tunsigned char *hash;\n\tchar *dirname;\n\tstruct dentry *dents[AAFS_PROF_SIZEOF];\n\tstruct rhashtable *data;\n\tstruct aa_label label;\n};\n\nextern enum profile_mode aa_g_profile_mode;\n\n#define AA_MAY_LOAD_POLICY\tAA_MAY_APPEND\n#define AA_MAY_REPLACE_POLICY\tAA_MAY_WRITE\n#define AA_MAY_REMOVE_POLICY\tAA_MAY_DELETE\n\n#define profiles_ns(P) ((P)->ns)\n#define name_is_shared(A, B) ((A)->hname && (A)->hname == (B)->hname)\n\nvoid aa_add_profile(struct aa_policy *common, struct aa_profile *profile);\n\n\nvoid aa_free_proxy_kref(struct kref *kref);\nstruct aa_ruleset *aa_alloc_ruleset(gfp_t gfp);\nstruct aa_profile *aa_alloc_profile(const char *name, struct aa_proxy *proxy,\n\t\t\t\t    gfp_t gfp);\nstruct aa_profile *aa_alloc_null(struct aa_profile *parent, const char *name,\n\t\t\t\t gfp_t gfp);\nstruct aa_profile *aa_new_learning_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t\t   const char *base, gfp_t gfp);\nvoid aa_free_profile(struct aa_profile *profile);\nvoid aa_free_profile_kref(struct kref *kref);\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name);\nstruct aa_profile *aa_lookupn_profile(struct aa_ns *ns, const char *hname,\n\t\t\t\t      size_t n);\nstruct aa_profile *aa_lookup_profile(struct aa_ns *ns, const char *name);\nstruct aa_profile *aa_fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\tconst char *fqname, size_t n);\nstruct aa_profile *aa_match_profile(struct aa_ns *ns, const char *name);\n\nssize_t aa_replace_profiles(struct aa_ns *view, struct aa_label *label,\n\t\t\t    u32 mask, struct aa_loaddata *udata);\nssize_t aa_remove_profiles(struct aa_ns *view, struct aa_label *label,\n\t\t\t   char *name, size_t size);\nvoid __aa_profile_list_release(struct list_head *head);\n\n#define PROF_ADD 1\n#define PROF_REPLACE 0\n\n#define profile_unconfined(X) ((X)->mode == APPARMOR_UNCONFINED)\n\n \nstatic inline struct aa_profile *aa_get_newest_profile(struct aa_profile *p)\n{\n\treturn labels_profile(aa_get_newest_label(&p->label));\n}\n\nstatic inline aa_state_t RULE_MEDIATES(struct aa_ruleset *rules,\n\t\t\t\t       unsigned char class)\n{\n\tif (class <= AA_CLASS_LAST)\n\t\treturn rules->policy.start[class];\n\telse\n\t\treturn aa_dfa_match_len(rules->policy.dfa,\n\t\t\t\t\trules->policy.start[0], &class, 1);\n}\n\nstatic inline aa_state_t RULE_MEDIATES_AF(struct aa_ruleset *rules, u16 AF)\n{\n\taa_state_t state = RULE_MEDIATES(rules, AA_CLASS_NET);\n\t__be16 be_af = cpu_to_be16(AF);\n\n\tif (!state)\n\t\treturn DFA_NOMATCH;\n\treturn aa_dfa_match_len(rules->policy.dfa, state, (char *) &be_af, 2);\n}\n\nstatic inline aa_state_t ANY_RULE_MEDIATES(struct list_head *head,\n\t\t\t\t\t   unsigned char class)\n{\n\tstruct aa_ruleset *rule;\n\n\t \n\trule = list_first_entry(head, typeof(*rule), list);\n\treturn RULE_MEDIATES(rule, class);\n}\n\n \nstatic inline struct aa_profile *aa_get_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_get(&(p->label.count));\n\n\treturn p;\n}\n\n \nstatic inline struct aa_profile *aa_get_profile_not0(struct aa_profile *p)\n{\n\tif (p && kref_get_unless_zero(&p->label.count))\n\t\treturn p;\n\n\treturn NULL;\n}\n\n \nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}\n\n \nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}\n\nstatic inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}\n\nbool aa_policy_view_capable(const struct cred *subj_cred,\n\t\t\t    struct aa_label *label, struct aa_ns *ns);\nbool aa_policy_admin_capable(const struct cred *subj_cred,\n\t\t\t     struct aa_label *label, struct aa_ns *ns);\nint aa_may_manage_policy(const struct cred *subj_cred,\n\t\t\t struct aa_label *label, struct aa_ns *ns,\n\t\t\t u32 mask);\nbool aa_current_policy_view_capable(struct aa_ns *ns);\nbool aa_current_policy_admin_capable(struct aa_ns *ns);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}