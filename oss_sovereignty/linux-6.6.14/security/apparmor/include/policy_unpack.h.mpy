{
  "module_name": "policy_unpack.h",
  "hash_id": "d631ded070cdab4519e2c2fbf3920a8e3fe70e94f53a523c58efafb54f14dfdc",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/policy_unpack.h",
  "human_readable_source": " \n \n\n#ifndef __POLICY_INTERFACE_H\n#define __POLICY_INTERFACE_H\n\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/dcache.h>\n#include <linux/workqueue.h>\n\n\nstruct aa_load_ent {\n\tstruct list_head list;\n\tstruct aa_profile *new;\n\tstruct aa_profile *old;\n\tstruct aa_profile *rename;\n\tconst char *ns_name;\n};\n\nvoid aa_load_ent_free(struct aa_load_ent *ent);\nstruct aa_load_ent *aa_load_ent_alloc(void);\n\n#define PACKED_FLAG_HAT\t\t1\n#define PACKED_FLAG_DEBUG1\t2\n#define PACKED_FLAG_DEBUG2\t4\n\n#define PACKED_MODE_ENFORCE\t0\n#define PACKED_MODE_COMPLAIN\t1\n#define PACKED_MODE_KILL\t2\n#define PACKED_MODE_UNCONFINED\t3\n#define PACKED_MODE_USER\t4\n\nstruct aa_ns;\n\nenum {\n\tAAFS_LOADDATA_ABI = 0,\n\tAAFS_LOADDATA_REVISION,\n\tAAFS_LOADDATA_HASH,\n\tAAFS_LOADDATA_DATA,\n\tAAFS_LOADDATA_COMPRESSED_SIZE,\n\tAAFS_LOADDATA_DIR,\t\t \n\tAAFS_LOADDATA_NDENTS\t\t \n};\n\n \n\nenum aa_code {\n\tAA_U8,\n\tAA_U16,\n\tAA_U32,\n\tAA_U64,\n\tAA_NAME,\t\t \n\tAA_STRING,\n\tAA_BLOB,\n\tAA_STRUCT,\n\tAA_STRUCTEND,\n\tAA_LIST,\n\tAA_LISTEND,\n\tAA_ARRAY,\n\tAA_ARRAYEND,\n};\n\n \nstruct aa_ext {\n\tvoid *start;\n\tvoid *end;\n\tvoid *pos;\t\t \n\tu32 version;\n};\n\n \nstruct aa_loaddata {\n\tstruct kref count;\n\tstruct list_head list;\n\tstruct work_struct work;\n\tstruct dentry *dents[AAFS_LOADDATA_NDENTS];\n\tstruct aa_ns *ns;\n\tchar *name;\n\tsize_t size;\t\t\t \n\tsize_t compressed_size;\t\t \n\tlong revision;\t\t\t \n\tint abi;\n\tunsigned char *hash;\n\n\t \n\tchar *data;\n};\n\nint aa_unpack(struct aa_loaddata *udata, struct list_head *lh, const char **ns);\n\n \nstatic inline struct aa_loaddata *\n__aa_get_loaddata(struct aa_loaddata *data)\n{\n\tif (data && kref_get_unless_zero(&(data->count)))\n\t\treturn data;\n\n\treturn NULL;\n}\n\n \nstatic inline struct aa_loaddata *\naa_get_loaddata(struct aa_loaddata *data)\n{\n\tstruct aa_loaddata *tmp = __aa_get_loaddata(data);\n\n\tAA_BUG(data && !tmp);\n\n\treturn tmp;\n}\n\nvoid __aa_loaddata_update(struct aa_loaddata *data, long revision);\nbool aa_rawdata_eq(struct aa_loaddata *l, struct aa_loaddata *r);\nvoid aa_loaddata_kref(struct kref *kref);\nstruct aa_loaddata *aa_loaddata_alloc(size_t size);\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}\n\n#if IS_ENABLED(CONFIG_KUNIT)\nbool aa_inbounds(struct aa_ext *e, size_t size);\nsize_t aa_unpack_u16_chunk(struct aa_ext *e, char **chunk);\nbool aa_unpack_X(struct aa_ext *e, enum aa_code code);\nbool aa_unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name);\nbool aa_unpack_u32(struct aa_ext *e, u32 *data, const char *name);\nbool aa_unpack_u64(struct aa_ext *e, u64 *data, const char *name);\nbool aa_unpack_array(struct aa_ext *e, const char *name, u16 *size);\nsize_t aa_unpack_blob(struct aa_ext *e, char **blob, const char *name);\nint aa_unpack_str(struct aa_ext *e, const char **string, const char *name);\nint aa_unpack_strdup(struct aa_ext *e, char **string, const char *name);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}