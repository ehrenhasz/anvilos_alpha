{
  "module_name": "label.h",
  "hash_id": "b9ded7f6cc184267e491a3db5ad47b1e8d243e9d131db41efa9a19dbf7344b10",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/label.h",
  "human_readable_source": " \n \n\n#ifndef __AA_LABEL_H\n#define __AA_LABEL_H\n\n#include <linux/atomic.h>\n#include <linux/audit.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n\n#include \"apparmor.h\"\n#include \"lib.h\"\n\nstruct aa_ns;\n\n#define LOCAL_VEC_ENTRIES 8\n#define DEFINE_VEC(T, V)\t\t\t\t\t\t\\\n\tstruct aa_ ## T *(_ ## V ## _localtmp)[LOCAL_VEC_ENTRIES];\t\\\n\tstruct aa_ ## T **(V)\n\n#define vec_setup(T, V, N, GFP)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif ((N) <= LOCAL_VEC_ENTRIES) {\t\t\t\t\t\\\n\t\ttypeof(N) i;\t\t\t\t\t\t\\\n\t\t(V) = (_ ## V ## _localtmp);\t\t\t\t\\\n\t\tfor (i = 0; i < (N); i++)\t\t\t\t\\\n\t\t\t(V)[i] = NULL;\t\t\t\t\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t(V) = kzalloc(sizeof(struct aa_ ## T *) * (N), (GFP));\t\\\n\t(V) ? 0 : -ENOMEM;\t\t\t\t\t\t\\\n})\n\n#define vec_cleanup(T, V, N)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < (N); i++) {\t\t\t\t\t\\\n\t\tif (!IS_ERR_OR_NULL((V)[i]))\t\t\t\t\\\n\t\t\taa_put_ ## T((V)[i]);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif ((V) != _ ## V ## _localtmp)\t\t\t\t\t\\\n\t\tkfree(V);\t\t\t\t\t\t\\\n} while (0)\n\n#define vec_last(VEC, SIZE) ((VEC)[(SIZE) - 1])\n#define vec_ns(VEC, SIZE) (vec_last((VEC), (SIZE))->ns)\n#define vec_labelset(VEC, SIZE) (&vec_ns((VEC), (SIZE))->labels)\n#define cleanup_domain_vec(V, L) cleanup_label_vec((V), (L)->size)\n\nstruct aa_profile;\n#define VEC_FLAG_TERMINATE 1\nint aa_vec_unique(struct aa_profile **vec, int n, int flags);\nstruct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp);\n#define aa_sort_and_merge_vec(N, V) \\\n\taa_sort_and_merge_profiles((N), (struct aa_profile **)(V))\n\n\n \nstruct aa_labelset {\n\trwlock_t lock;\n\n\tstruct rb_root root;\n};\n\n#define __labelset_for_each(LS, N) \\\n\tfor ((N) = rb_first(&(LS)->root); (N); (N) = rb_next(N))\n\nenum label_flags {\n\tFLAG_HAT = 1,\t\t\t \n\tFLAG_UNCONFINED = 2,\t\t \n\tFLAG_NULL = 4,\t\t\t \n\tFLAG_IX_ON_NAME_ERROR = 8,\t \n\tFLAG_IMMUTIBLE = 0x10,\t\t \n\tFLAG_USER_DEFINED = 0x20,\t \n\tFLAG_NO_LIST_REF = 0x40,\t \n\tFLAG_NS_COUNT = 0x80,\t\t \n\tFLAG_IN_TREE = 0x100,\t\t \n\tFLAG_PROFILE = 0x200,\t\t \n\tFLAG_EXPLICIT = 0x400,\t\t \n\tFLAG_STALE = 0x800,\t\t \n\tFLAG_RENAMED = 0x1000,\t\t \n\tFLAG_REVOKED = 0x2000,\t\t \n\tFLAG_DEBUG1 = 0x4000,\n\tFLAG_DEBUG2 = 0x8000,\n\n\t \n\t \n};\n\nstruct aa_label;\nstruct aa_proxy {\n\tstruct kref count;\n\tstruct aa_label __rcu *label;\n};\n\nstruct label_it {\n\tint i, j;\n};\n\n \nstruct aa_label {\n\tstruct kref count;\n\tstruct rb_node node;\n\tstruct rcu_head rcu;\n\tstruct aa_proxy *proxy;\n\t__counted char *hname;\n\tlong flags;\n\tu32 secid;\n\tint size;\n\tstruct aa_profile *vec[];\n};\n\n#define last_error(E, FN)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tint __subE = (FN);\t\t\t\t\\\n\tif (__subE)\t\t\t\t\t\\\n\t\t(E) = __subE;\t\t\t\t\\\n} while (0)\n\n#define label_isprofile(X) ((X)->flags & FLAG_PROFILE)\n#define label_unconfined(X) ((X)->flags & FLAG_UNCONFINED)\n#define unconfined(X) label_unconfined(X)\n#define label_is_stale(X) ((X)->flags & FLAG_STALE)\n#define __label_make_stale(X) ((X)->flags |= FLAG_STALE)\n#define labels_ns(X) (vec_ns(&((X)->vec[0]), (X)->size))\n#define labels_set(X) (&labels_ns(X)->labels)\n#define labels_view(X) labels_ns(X)\n#define labels_profile(X) ((X)->vec[(X)->size - 1])\n\n\nint aa_label_next_confined(struct aa_label *l, int i);\n\n \n#define label_for_each(I, L, P)\t\t\t\t\t\t\\\n\tfor ((I).i = 0; ((P) = (L)->vec[(I).i]); ++((I).i))\n\n \n#define label_for_each_cont(I, L, P)\t\t\t\t\t\\\n\tfor (++((I).i); ((P) = (L)->vec[(I).i]); ++((I).i))\n\n#define next_comb(I, L1, L2)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(I).j++;\t\t\t\t\t\t\t\\\n\tif ((I).j >= (L2)->size) {\t\t\t\t\t\\\n\t\t(I).i++;\t\t\t\t\t\t\\\n\t\t(I).j = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\n \n#define label_for_each_comb(I, L1, L2, P1, P2)\t\t\t\t\\\nfor ((I).i = (I).j = 0;\t\t\t\t\t\t\t\\\n\t((P1) = (L1)->vec[(I).i]) && ((P2) = (L2)->vec[(I).j]);\t\t\\\n\t(I) = next_comb(I, L1, L2))\n\n#define fn_for_each_comb(L1, L2, P1, P2, FN)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct label_it i;\t\t\t\t\t\t\\\n\tint __E = 0;\t\t\t\t\t\t\t\\\n\tlabel_for_each_comb(i, (L1), (L2), (P1), (P2)) {\t\t\\\n\t\tlast_error(__E, (FN));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__E;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define label_for_each_confined(I, L, P)\t\t\t\t\\\n\tfor ((I).i = aa_label_next_confined((L), 0);\t\t\t\\\n\t     ((P) = (L)->vec[(I).i]);\t\t\t\t\t\\\n\t     (I).i = aa_label_next_confined((L), (I).i + 1))\n\n#define label_for_each_in_merge(I, A, B, P)\t\t\t\t\\\n\tfor ((I).i = (I).j = 0;\t\t\t\t\t\t\\\n\t     ((P) = aa_label_next_in_merge(&(I), (A), (B)));\t\t\\\n\t     )\n\n#define label_for_each_not_in_set(I, SET, SUB, P)\t\t\t\\\n\tfor ((I).i = (I).j = 0;\t\t\t\t\t\t\\\n\t     ((P) = __aa_label_next_not_in_set(&(I), (SET), (SUB)));\t\\\n\t     )\n\n#define next_in_ns(i, NS, L)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(i) ___i = (i);\t\t\t\t\t\t\\\n\twhile ((L)->vec[___i] && (L)->vec[___i]->ns != (NS))\t\t\\\n\t\t(___i)++;\t\t\t\t\t\t\\\n\t(___i);\t\t\t\t\t\t\t\t\\\n})\n\n#define label_for_each_in_ns(I, NS, L, P)\t\t\t\t\\\n\tfor ((I).i = next_in_ns(0, (NS), (L));\t\t\t\t\\\n\t     ((P) = (L)->vec[(I).i]);\t\t\t\t\t\\\n\t     (I).i = next_in_ns((I).i + 1, (NS), (L)))\n\n#define fn_for_each_in_ns(L, P, FN)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct label_it __i;\t\t\t\t\t\t\\\n\tstruct aa_ns *__ns = labels_ns(L);\t\t\t\t\\\n\tint __E = 0;\t\t\t\t\t\t\t\\\n\tlabel_for_each_in_ns(__i, __ns, (L), (P)) {\t\t\t\\\n\t\tlast_error(__E, (FN));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__E;\t\t\t\t\t\t\t\t\\\n})\n\n\n#define fn_for_each_XXX(L, P, FN, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct label_it i;\t\t\t\t\t\t\\\n\tint __E = 0;\t\t\t\t\t\t\t\\\n\tlabel_for_each ## __VA_ARGS__(i, (L), (P)) {\t\t\t\\\n\t\tlast_error(__E, (FN));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__E;\t\t\t\t\t\t\t\t\\\n})\n\n#define fn_for_each(L, P, FN) fn_for_each_XXX(L, P, FN)\n#define fn_for_each_confined(L, P, FN) fn_for_each_XXX(L, P, FN, _confined)\n\n#define fn_for_each2_XXX(L1, L2, P, FN, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct label_it i;\t\t\t\t\t\t\\\n\tint __E = 0;\t\t\t\t\t\t\t\\\n\tlabel_for_each ## __VA_ARGS__(i, (L1), (L2), (P)) {\t\t\\\n\t\tlast_error(__E, (FN));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__E;\t\t\t\t\t\t\t\t\\\n})\n\n#define fn_for_each_in_merge(L1, L2, P, FN)\t\t\t\t\\\n\tfn_for_each2_XXX((L1), (L2), P, FN, _in_merge)\n#define fn_for_each_not_in_set(L1, L2, P, FN)\t\t\t\t\\\n\tfn_for_each2_XXX((L1), (L2), P, FN, _not_in_set)\n\n#define LABEL_MEDIATES(L, C)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct aa_profile *profile;\t\t\t\t\t\\\n\tstruct label_it i;\t\t\t\t\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\tlabel_for_each(i, (L), profile) {\t\t\t\t\\\n\t\tif (RULE_MEDIATES(&profile->rules, (C))) {\t\t\\\n\t\t\tret = 1;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n\nvoid aa_labelset_destroy(struct aa_labelset *ls);\nvoid aa_labelset_init(struct aa_labelset *ls);\nvoid __aa_labelset_update_subtree(struct aa_ns *ns);\n\nvoid aa_label_destroy(struct aa_label *label);\nvoid aa_label_free(struct aa_label *label);\nvoid aa_label_kref(struct kref *kref);\nbool aa_label_init(struct aa_label *label, int size, gfp_t gfp);\nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp);\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub);\nbool aa_label_is_unconfined_subset(struct aa_label *set, struct aa_label *sub);\nstruct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t     struct aa_label *set,\n\t\t\t\t\t     struct aa_label *sub);\nbool aa_label_remove(struct aa_label *label);\nstruct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *l);\nbool aa_label_replace(struct aa_label *old, struct aa_label *new);\nbool aa_label_make_newest(struct aa_labelset *ls, struct aa_label *old,\n\t\t\t  struct aa_label *new);\n\nstruct aa_label *aa_label_find(struct aa_label *l);\n\nstruct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b);\nstruct aa_label *aa_label_find_merge(struct aa_label *a, struct aa_label *b);\nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp);\n\n\nbool aa_update_label_name(struct aa_ns *ns, struct aa_label *label, gfp_t gfp);\n\n#define FLAGS_NONE 0\n#define FLAG_SHOW_MODE 1\n#define FLAG_VIEW_SUBNS 2\n#define FLAG_HIDDEN_UNCONFINED 4\n#define FLAG_ABS_ROOT 8\nint aa_label_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t      struct aa_label *label, int flags);\nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp);\nint aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp);\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp);\nvoid aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp);\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp);\nvoid aa_label_audit(struct audit_buffer *ab, struct aa_label *label, gfp_t gfp);\nvoid aa_label_seq_print(struct seq_file *f, struct aa_label *label, gfp_t gfp);\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp);\n\nstruct aa_label *aa_label_strn_parse(struct aa_label *base, const char *str,\n\t\t\t\t     size_t n, gfp_t gfp, bool create,\n\t\t\t\t     bool force_stack);\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack);\n\nstatic inline const char *aa_label_strn_split(const char *str, int n)\n{\n\tconst char *pos;\n\taa_state_t state;\n\n\tstate = aa_dfa_matchn_until(stacksplitdfa, DFA_START, str, n, &pos);\n\tif (!ACCEPT_TABLE(stacksplitdfa)[state])\n\t\treturn NULL;\n\n\treturn pos - 3;\n}\n\nstatic inline const char *aa_label_str_split(const char *str)\n{\n\tconst char *pos;\n\taa_state_t state;\n\n\tstate = aa_dfa_match_until(stacksplitdfa, DFA_START, str, &pos);\n\tif (!ACCEPT_TABLE(stacksplitdfa)[state])\n\t\treturn NULL;\n\n\treturn pos - 3;\n}\n\n\n\nstruct aa_perms;\nstruct aa_ruleset;\nint aa_label_match(struct aa_profile *profile, struct aa_ruleset *rules,\n\t\t   struct aa_label *label, aa_state_t state, bool subns,\n\t\t   u32 request, struct aa_perms *perms);\n\n\n \nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}\n\nstatic inline struct aa_label *aa_get_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_get(&(l->count));\n\n\treturn l;\n}\n\n\n \nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}\n\n \nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t \n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}\n\n\nstruct aa_proxy *aa_alloc_proxy(struct aa_label *l, gfp_t gfp);\nvoid aa_proxy_kref(struct kref *kref);\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}\n\nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}