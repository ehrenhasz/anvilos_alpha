{
  "module_name": "file.h",
  "hash_id": "4fef95b2772c6a301dc4567e4cc707dd55fb1fe287e11126736f56c6ce001349",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/file.h",
  "human_readable_source": " \n \n\n#ifndef __AA_FILE_H\n#define __AA_FILE_H\n\n#include <linux/spinlock.h>\n\n#include \"domain.h\"\n#include \"match.h\"\n#include \"perms.h\"\n\nstruct aa_policydb;\nstruct aa_profile;\nstruct path;\n\n#define mask_mode_t(X) (X & (MAY_EXEC | MAY_WRITE | MAY_READ | MAY_APPEND))\n\n#define AA_AUDIT_FILE_MASK\t(MAY_READ | MAY_WRITE | MAY_EXEC | MAY_APPEND |\\\n\t\t\t\t AA_MAY_CREATE | AA_MAY_DELETE |\t\\\n\t\t\t\t AA_MAY_GETATTR | AA_MAY_SETATTR | \\\n\t\t\t\t AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_LOCK | \\\n\t\t\t\t AA_EXEC_MMAP | AA_MAY_LINK)\n\nstatic inline struct aa_file_ctx *file_ctx(struct file *file)\n{\n\treturn file->f_security + apparmor_blob_sizes.lbs_file;\n}\n\n \nstruct aa_file_ctx {\n\tspinlock_t lock;\n\tstruct aa_label __rcu *label;\n\tu32 allow;\n};\n\n \nstatic inline struct aa_file_ctx *aa_alloc_file_ctx(struct aa_label *label,\n\t\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_file_ctx *ctx;\n\n\tctx = kzalloc(sizeof(struct aa_file_ctx), gfp);\n\tif (ctx) {\n\t\tspin_lock_init(&ctx->lock);\n\t\trcu_assign_pointer(ctx->label, aa_get_label(label));\n\t}\n\treturn ctx;\n}\n\n \nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkfree_sensitive(ctx);\n\t}\n}\n\nstatic inline struct aa_label *aa_get_file_label(struct aa_file_ctx *ctx)\n{\n\treturn aa_get_label_rcu(&ctx->label);\n}\n\n \n#define AA_X_INDEX_MASK\t\tAA_INDEX_MASK\n\n#define AA_X_TYPE_MASK\t\t0x0c000000\n#define AA_X_NONE\t\tAA_INDEX_NONE\n#define AA_X_NAME\t\t0x04000000  \n#define AA_X_TABLE\t\t0x08000000  \n\n#define AA_X_UNSAFE\t\t0x10000000\n#define AA_X_CHILD\t\t0x20000000\n#define AA_X_INHERIT\t\t0x40000000\n#define AA_X_UNCONFINED\t\t0x80000000\n\n \nstruct path_cond {\n\tkuid_t uid;\n\tumode_t mode;\n};\n\n#define COMBINED_PERM_MASK(X) ((X).allow | (X).audit | (X).quiet | (X).kill)\n\nint aa_audit_file(const struct cred *cred,\n\t\t  struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel, kuid_t ouid,\n\t\t  const char *info, int error);\n\nstruct aa_perms *aa_lookup_fperms(struct aa_policydb *file_rules,\n\t\t\t\t  aa_state_t state, struct path_cond *cond);\naa_state_t aa_str_perms(struct aa_policydb *file_rules, aa_state_t start,\n\t\t\tconst char *name, struct path_cond *cond,\n\t\t\tstruct aa_perms *perms);\n\nint aa_path_perm(const char *op, const struct cred *subj_cred,\n\t\t struct aa_label *label, const struct path *path,\n\t\t int flags, u32 request, struct path_cond *cond);\n\nint aa_path_link(const struct cred *subj_cred, struct aa_label *label,\n\t\t struct dentry *old_dentry, const struct path *new_dir,\n\t\t struct dentry *new_dentry);\n\nint aa_file_perm(const char *op, const struct cred *subj_cred,\n\t\t struct aa_label *label, struct file *file,\n\t\t u32 request, bool in_atomic);\n\nvoid aa_inherit_files(const struct cred *cred, struct files_struct *files);\n\n\n \nstatic inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t \n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}