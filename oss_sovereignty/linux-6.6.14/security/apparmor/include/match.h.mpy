{
  "module_name": "match.h",
  "hash_id": "fbf9d5f01deddb25c4bacba878a5233f5352379a653d5d097b3470d6411a690e",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/include/match.h",
  "human_readable_source": " \n \n\n#ifndef __AA_MATCH_H\n#define __AA_MATCH_H\n\n#include <linux/kref.h>\n\n#define DFA_NOMATCH\t\t\t0\n#define DFA_START\t\t\t1\n\n\n \n\n#define YYTH_MAGIC\t0x1B5E783D\n#define YYTH_FLAG_DIFF_ENCODE\t1\n#define YYTH_FLAG_OOB_TRANS\t2\n#define YYTH_FLAGS (YYTH_FLAG_DIFF_ENCODE | YYTH_FLAG_OOB_TRANS)\n\n#define MAX_OOB_SUPPORTED\t1\n\nstruct table_set_header {\n\tu32 th_magic;\t\t \n\tu32 th_hsize;\n\tu32 th_ssize;\n\tu16 th_flags;\n\tchar th_version[];\n};\n\n \n#define\tYYTD_ID_ACCEPT\t0\n#define YYTD_ID_BASE\t1\n#define YYTD_ID_CHK\t2\n#define YYTD_ID_DEF\t3\n#define YYTD_ID_EC\t4\n#define YYTD_ID_META\t5\n#define YYTD_ID_ACCEPT2 6\n#define YYTD_ID_NXT\t7\n#define YYTD_ID_TSIZE\t8\n#define YYTD_ID_MAX\t8\n\n#define YYTD_DATA8\t1\n#define YYTD_DATA16\t2\n#define YYTD_DATA32\t4\n#define YYTD_DATA64\t8\n\n \n#define ACCEPT1_FLAGS(X) ((X) & 0x3f)\n#define ACCEPT2_FLAGS(X) ACCEPT1_FLAGS((X) >> YYTD_ID_ACCEPT2)\n#define TO_ACCEPT1_FLAG(X) ACCEPT1_FLAGS(X)\n#define TO_ACCEPT2_FLAG(X) (ACCEPT1_FLAGS(X) << YYTD_ID_ACCEPT2)\n#define DFA_FLAG_VERIFY_STATES 0x1000\n\nstruct table_header {\n\tu16 td_id;\n\tu16 td_flags;\n\tu32 td_hilen;\n\tu32 td_lolen;\n\tchar td_data[];\n};\n\n#define DEFAULT_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_DEF]->td_data))\n#define BASE_TABLE(DFA) ((u32 *)((DFA)->tables[YYTD_ID_BASE]->td_data))\n#define NEXT_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_NXT]->td_data))\n#define CHECK_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_CHK]->td_data))\n#define EQUIV_TABLE(DFA) ((u8 *)((DFA)->tables[YYTD_ID_EC]->td_data))\n#define ACCEPT_TABLE(DFA) ((u32 *)((DFA)->tables[YYTD_ID_ACCEPT]->td_data))\n#define ACCEPT_TABLE2(DFA) ((u32 *)((DFA)->tables[YYTD_ID_ACCEPT2]->td_data))\n\nstruct aa_dfa {\n\tstruct kref count;\n\tu16 flags;\n\tu32 max_oob;\n\tstruct table_header *tables[YYTD_ID_TSIZE];\n};\n\nextern struct aa_dfa *nulldfa;\nextern struct aa_dfa *stacksplitdfa;\n\n#define byte_to_byte(X) (X)\n\n#define UNPACK_ARRAY(TABLE, BLOB, LEN, TTYPE, BTYPE, NTOHX)\t\\\n\tdo { \\\n\t\ttypeof(LEN) __i; \\\n\t\tTTYPE *__t = (TTYPE *) TABLE; \\\n\t\tBTYPE *__b = (BTYPE *) BLOB; \\\n\t\tfor (__i = 0; __i < LEN; __i++) { \\\n\t\t\t__t[__i] = NTOHX(__b[__i]); \\\n\t\t} \\\n\t} while (0)\n\nstatic inline size_t table_size(size_t len, size_t el_size)\n{\n\treturn ALIGN(sizeof(struct table_header) + len * el_size, 8);\n}\n\nint aa_setup_dfa_engine(void);\nvoid aa_teardown_dfa_engine(void);\n\n#define aa_state_t unsigned int\n\nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags);\naa_state_t aa_dfa_match_len(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t    const char *str, int len);\naa_state_t aa_dfa_match(struct aa_dfa *dfa, aa_state_t start,\n\t\t\tconst char *str);\naa_state_t aa_dfa_next(struct aa_dfa *dfa, aa_state_t state, const char c);\naa_state_t aa_dfa_outofband_transition(struct aa_dfa *dfa, aa_state_t state);\naa_state_t aa_dfa_match_until(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t      const char *str, const char **retpos);\naa_state_t aa_dfa_matchn_until(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t       const char *str, int n, const char **retpos);\n\nvoid aa_dfa_free_kref(struct kref *kref);\n\n#define WB_HISTORY_SIZE 24\nstruct match_workbuf {\n\tunsigned int count;\n\tunsigned int pos;\n\tunsigned int len;\n\tunsigned int size;\t \n\tunsigned int history[WB_HISTORY_SIZE];\n};\n#define DEFINE_MATCH_WB(N)\t\t\\\nstruct match_workbuf N = {\t\t\\\n\t.count = 0,\t\t\t\\\n\t.pos = 0,\t\t\t\\\n\t.len = 0,\t\t\t\\\n}\n\naa_state_t aa_dfa_leftmatch(struct aa_dfa *dfa, aa_state_t start,\n\t\t\t    const char *str, unsigned int *count);\n\n \nstatic inline struct aa_dfa *aa_get_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_get(&(dfa->count));\n\n\treturn dfa;\n}\n\n \nstatic inline void aa_put_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_put(&dfa->count, aa_dfa_free_kref);\n}\n\n#define MATCH_FLAG_DIFF_ENCODE 0x80000000\n#define MARK_DIFF_ENCODE 0x40000000\n#define MATCH_FLAG_OOB_TRANSITION 0x20000000\n#define MATCH_FLAGS_MASK 0xff000000\n#define MATCH_FLAGS_VALID (MATCH_FLAG_DIFF_ENCODE | MATCH_FLAG_OOB_TRANSITION)\n#define MATCH_FLAGS_INVALID (MATCH_FLAGS_MASK & ~MATCH_FLAGS_VALID)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}