{
  "module_name": "policy_ns.c",
  "hash_id": "3db93e4bff4285738deffa98ddb5d24c4854de4331d88f94ea984e35782b1635",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/policy_ns.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"include/apparmor.h\"\n#include \"include/cred.h\"\n#include \"include/policy_ns.h\"\n#include \"include/label.h\"\n#include \"include/policy.h\"\n\n \nstruct aa_label *kernel_t;\n\n \nstruct aa_ns *root_ns;\nconst char *aa_hidden_ns_name = \"---\";\n\n \nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t \n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t \n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}\n\nstatic struct aa_profile *alloc_unconfined(const char *name)\n{\n\tstruct aa_profile *profile;\n\n\tprofile = aa_alloc_null(NULL, name, GFP_KERNEL);\n\tif (!profile)\n\t\treturn NULL;\n\n\tprofile->label.flags |= FLAG_IX_ON_NAME_ERROR |\n\t\tFLAG_IMMUTIBLE | FLAG_NS_COUNT | FLAG_UNCONFINED;\n\tprofile->mode = APPARMOR_UNCONFINED;\n\n\treturn profile;\n}\n\n \nstatic struct aa_ns *alloc_ns(const char *prefix, const char *name)\n{\n\tstruct aa_ns *ns;\n\n\tns = kzalloc(sizeof(*ns), GFP_KERNEL);\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, ns);\n\tif (!ns)\n\t\treturn NULL;\n\tif (!aa_policy_init(&ns->base, prefix, name, GFP_KERNEL))\n\t\tgoto fail_ns;\n\n\tINIT_LIST_HEAD(&ns->sub_ns);\n\tINIT_LIST_HEAD(&ns->rawdata_list);\n\tmutex_init(&ns->lock);\n\tinit_waitqueue_head(&ns->wait);\n\n\t \n\tns->unconfined = alloc_unconfined(\"unconfined\");\n\tif (!ns->unconfined)\n\t\tgoto fail_unconfined;\n\t \n\tns->unconfined->ns = ns;\n\n\tatomic_set(&ns->uniq_null, 0);\n\n\taa_labelset_init(&ns->labels);\n\n\treturn ns;\n\nfail_unconfined:\n\taa_policy_destroy(&ns->base);\nfail_ns:\n\tkfree_sensitive(ns);\n\treturn NULL;\n}\n\n \nvoid aa_free_ns(struct aa_ns *ns)\n{\n\tif (!ns)\n\t\treturn;\n\n\taa_policy_destroy(&ns->base);\n\taa_labelset_destroy(&ns->labels);\n\taa_put_ns(ns->parent);\n\n\tns->unconfined->ns = NULL;\n\taa_free_profile(ns->unconfined);\n\tkfree_sensitive(ns);\n}\n\n \nstruct aa_ns *aa_findn_ns(struct aa_ns *root, const char *name, size_t n)\n{\n\tstruct aa_ns *ns = NULL;\n\n\trcu_read_lock();\n\tns = aa_get_ns(__aa_findn_ns(&root->sub_ns, name, n));\n\trcu_read_unlock();\n\n\treturn ns;\n}\n\n \nstruct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)\n{\n\treturn aa_findn_ns(root, name, strlen(name));\n}\n\n \nstruct aa_ns *__aa_lookupn_ns(struct aa_ns *view, const char *hname, size_t n)\n{\n\tstruct aa_ns *ns = view;\n\tconst char *split;\n\n\tfor (split = strnstr(hname, \"//\", n); split;\n\t     split = strnstr(hname, \"//\", n)) {\n\t\tns = __aa_findn_ns(&ns->sub_ns, hname, split - hname);\n\t\tif (!ns)\n\t\t\treturn NULL;\n\n\t\tn -= split + 2 - hname;\n\t\thname = split + 2;\n\t}\n\n\tif (n)\n\t\treturn __aa_findn_ns(&ns->sub_ns, hname, n);\n\treturn NULL;\n}\n\n \nstruct aa_ns *aa_lookupn_ns(struct aa_ns *view, const char *name, size_t n)\n{\n\tstruct aa_ns *ns = NULL;\n\n\trcu_read_lock();\n\tns = aa_get_ns(__aa_lookupn_ns(view, name, n));\n\trcu_read_unlock();\n\n\treturn ns;\n}\n\nstatic struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,\n\t\t\t\t    struct dentry *dir)\n{\n\tstruct aa_ns *ns;\n\tint error;\n\n\tAA_BUG(!parent);\n\tAA_BUG(!name);\n\tAA_BUG(!mutex_is_locked(&parent->lock));\n\n\tns = alloc_ns(parent->base.hname, name);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tns->level = parent->level + 1;\n\tmutex_lock_nested(&ns->lock, ns->level);\n\terror = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name, dir);\n\tif (error) {\n\t\tAA_ERROR(\"Failed to create interface for ns %s\\n\",\n\t\t\t ns->base.name);\n\t\tmutex_unlock(&ns->lock);\n\t\taa_free_ns(ns);\n\t\treturn ERR_PTR(error);\n\t}\n\tns->parent = aa_get_ns(parent);\n\tlist_add_rcu(&ns->base.list, &parent->sub_ns);\n\t \n\taa_get_ns(ns);\n\tmutex_unlock(&ns->lock);\n\n\treturn ns;\n}\n\n \nstruct aa_ns *__aa_find_or_create_ns(struct aa_ns *parent, const char *name,\n\t\t\t\t     struct dentry *dir)\n{\n\tstruct aa_ns *ns;\n\n\tAA_BUG(!mutex_is_locked(&parent->lock));\n\n\t \n\t \n\tns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\n\tif (!ns)\n\t\tns = __aa_create_ns(parent, name, dir);\n\telse\n\t\tns = ERR_PTR(-EEXIST);\n\n\t \n\treturn ns;\n}\n\n \nstruct aa_ns *aa_prepare_ns(struct aa_ns *parent, const char *name)\n{\n\tstruct aa_ns *ns;\n\n\tmutex_lock_nested(&parent->lock, parent->level);\n\t \n\t \n\tns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\n\tif (!ns)\n\t\tns = __aa_create_ns(parent, name, NULL);\n\tmutex_unlock(&parent->lock);\n\n\t \n\treturn ns;\n}\n\nstatic void __ns_list_release(struct list_head *head);\n\n \nstatic void destroy_ns(struct aa_ns *ns)\n{\n\tif (!ns)\n\t\treturn;\n\n\tmutex_lock_nested(&ns->lock, ns->level);\n\t \n\t__aa_profile_list_release(&ns->base.profiles);\n\n\t \n\t__ns_list_release(&ns->sub_ns);\n\n\tif (ns->parent) {\n\t\tunsigned long flags;\n\n\t\twrite_lock_irqsave(&ns->labels.lock, flags);\n\t\t__aa_proxy_redirect(ns_unconfined(ns),\n\t\t\t\t    ns_unconfined(ns->parent));\n\t\twrite_unlock_irqrestore(&ns->labels.lock, flags);\n\t}\n\t__aafs_ns_rmdir(ns);\n\tmutex_unlock(&ns->lock);\n}\n\n \nvoid __aa_remove_ns(struct aa_ns *ns)\n{\n\t \n\tlist_del_rcu(&ns->base.list);\n\tdestroy_ns(ns);\n\taa_put_ns(ns);\n}\n\n \nstatic void __ns_list_release(struct list_head *head)\n{\n\tstruct aa_ns *ns, *tmp;\n\n\tlist_for_each_entry_safe(ns, tmp, head, base.list)\n\t\t__aa_remove_ns(ns);\n\n}\n\n \nint __init aa_alloc_root_ns(void)\n{\n\tstruct aa_profile *kernel_p;\n\n\t \n\troot_ns = alloc_ns(NULL, \"root\");\n\tif (!root_ns)\n\t\treturn -ENOMEM;\n\n\tkernel_p = alloc_unconfined(\"kernel_t\");\n\tif (!kernel_p) {\n\t\tdestroy_ns(root_ns);\n\t\taa_free_ns(root_ns);\n\t\treturn -ENOMEM;\n\t}\n\tkernel_t = &kernel_p->label;\n\troot_ns->unconfined->ns = aa_get_ns(root_ns);\n\n\treturn 0;\n}\n\n  \nvoid __init aa_free_root_ns(void)\n{\n\t struct aa_ns *ns = root_ns;\n\n\t root_ns = NULL;\n\n\t aa_label_free(kernel_t);\n\t destroy_ns(ns);\n\t aa_put_ns(ns);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}