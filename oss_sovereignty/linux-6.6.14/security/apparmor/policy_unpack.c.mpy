{
  "module_name": "policy_unpack.c",
  "hash_id": "28633bc745f2e945d3bba773d38ab670347771fee04fe98d5ad6eac1320b296c",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/policy_unpack.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <kunit/visibility.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/zstd.h>\n\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include \"include/cred.h\"\n#include \"include/crypto.h\"\n#include \"include/file.h\"\n#include \"include/match.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_compat.h\"\n\n \nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->iface.ns) {\n\t\taudit_log_format(ab, \" ns=\");\n\t\taudit_log_untrustedstring(ab, ad->iface.ns);\n\t}\n\tif (ad->name) {\n\t\taudit_log_format(ab, \" name=\");\n\t\taudit_log_untrustedstring(ab, ad->name);\n\t}\n\tif (ad->iface.pos)\n\t\taudit_log_format(ab, \" offset=%ld\", ad->iface.pos);\n}\n\n \nstatic int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_NONE, NULL);\n\tif (e)\n\t\tad.iface.pos = e->pos - e->start;\n\tad.iface.ns = ns_name;\n\tif (new)\n\t\tad.name = new->base.hname;\n\telse\n\t\tad.name = name;\n\tad.info = info;\n\tad.error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &ad, audit_cb);\n}\n\nvoid __aa_loaddata_update(struct aa_loaddata *data, long revision)\n{\n\tAA_BUG(!data);\n\tAA_BUG(!data->ns);\n\tAA_BUG(!mutex_is_locked(&data->ns->lock));\n\tAA_BUG(data->revision > revision);\n\n\tdata->revision = revision;\n\tif ((data->dents[AAFS_LOADDATA_REVISION])) {\n\t\tstruct inode *inode;\n\n\t\tinode = d_inode(data->dents[AAFS_LOADDATA_DIR]);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\n\t\tinode = d_inode(data->dents[AAFS_LOADDATA_REVISION]);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t}\n}\n\nbool aa_rawdata_eq(struct aa_loaddata *l, struct aa_loaddata *r)\n{\n\tif (l->size != r->size)\n\t\treturn false;\n\tif (l->compressed_size != r->compressed_size)\n\t\treturn false;\n\tif (aa_g_hash_policy && memcmp(l->hash, r->hash, aa_hash_size()) != 0)\n\t\treturn false;\n\treturn memcmp(l->data, r->data, r->compressed_size ?: r->size) == 0;\n}\n\n \nstatic void do_loaddata_free(struct work_struct *work)\n{\n\tstruct aa_loaddata *d = container_of(work, struct aa_loaddata, work);\n\tstruct aa_ns *ns = aa_get_ns(d->ns);\n\n\tif (ns) {\n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\t__aa_fs_remove_rawdata(d);\n\t\tmutex_unlock(&ns->lock);\n\t\taa_put_ns(ns);\n\t}\n\n\tkfree_sensitive(d->hash);\n\tkfree_sensitive(d->name);\n\tkvfree(d->data);\n\tkfree_sensitive(d);\n}\n\nvoid aa_loaddata_kref(struct kref *kref)\n{\n\tstruct aa_loaddata *d = container_of(kref, struct aa_loaddata, count);\n\n\tif (d) {\n\t\tINIT_WORK(&d->work, do_loaddata_free);\n\t\tschedule_work(&d->work);\n\t}\n}\n\nstruct aa_loaddata *aa_loaddata_alloc(size_t size)\n{\n\tstruct aa_loaddata *d;\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (d == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\td->data = kvzalloc(size, GFP_KERNEL);\n\tif (!d->data) {\n\t\tkfree(d);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tkref_init(&d->count);\n\tINIT_LIST_HEAD(&d->list);\n\n\treturn d;\n}\n\n \nVISIBLE_IF_KUNIT bool aa_inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_inbounds);\n\n \nVISIBLE_IF_KUNIT size_t aa_unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\tvoid *pos = e->pos;\n\n\tif (!aa_inbounds(e, sizeof(u16)))\n\t\tgoto fail;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!aa_inbounds(e, size))\n\t\tgoto fail;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_u16_chunk);\n\n \nVISIBLE_IF_KUNIT bool aa_unpack_X(struct aa_ext *e, enum aa_code code)\n{\n\tif (!aa_inbounds(e, 1))\n\t\treturn false;\n\tif (*(u8 *) e->pos != code)\n\t\treturn false;\n\te->pos++;\n\treturn true;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_X);\n\n \nVISIBLE_IF_KUNIT bool aa_unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t \n\tvoid *pos = e->pos;\n\t \n\tif (aa_unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = aa_unpack_u16_chunk(e, &tag);\n\t\t \n\t\tif (name && (!size || tag[size-1] != '\\0' || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t \n\t\tgoto fail;\n\t}\n\n\t \n\tif (aa_unpack_X(e, code))\n\t\treturn true;\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_nameX);\n\nstatic bool unpack_u8(struct aa_ext *e, u8 *data, const char *name)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_U8, name)) {\n\t\tif (!aa_inbounds(e, sizeof(u8)))\n\t\t\tgoto fail;\n\t\tif (data)\n\t\t\t*data = *((u8 *)e->pos);\n\t\te->pos += sizeof(u8);\n\t\treturn true;\n\t}\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\n\nVISIBLE_IF_KUNIT bool aa_unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_U32, name)) {\n\t\tif (!aa_inbounds(e, sizeof(u32)))\n\t\t\tgoto fail;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn true;\n\t}\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_u32);\n\nVISIBLE_IF_KUNIT bool aa_unpack_u64(struct aa_ext *e, u64 *data, const char *name)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_U64, name)) {\n\t\tif (!aa_inbounds(e, sizeof(u64)))\n\t\t\tgoto fail;\n\t\tif (data)\n\t\t\t*data = le64_to_cpu(get_unaligned((__le64 *) e->pos));\n\t\te->pos += sizeof(u64);\n\t\treturn true;\n\t}\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_u64);\n\nstatic bool aa_unpack_cap_low(struct aa_ext *e, kernel_cap_t *data, const char *name)\n{\n\tu32 val;\n\n\tif (!aa_unpack_u32(e, &val, name))\n\t\treturn false;\n\tdata->val = val;\n\treturn true;\n}\n\nstatic bool aa_unpack_cap_high(struct aa_ext *e, kernel_cap_t *data, const char *name)\n{\n\tu32 val;\n\n\tif (!aa_unpack_u32(e, &val, name))\n\t\treturn false;\n\tdata->val = (u32)data->val | ((u64)val << 32);\n\treturn true;\n}\n\nVISIBLE_IF_KUNIT bool aa_unpack_array(struct aa_ext *e, const char *name, u16 *size)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_ARRAY, name)) {\n\t\tif (!aa_inbounds(e, sizeof(u16)))\n\t\t\tgoto fail;\n\t\t*size = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn true;\n\t}\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_array);\n\nVISIBLE_IF_KUNIT size_t aa_unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!aa_inbounds(e, sizeof(u32)))\n\t\t\tgoto fail;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (aa_inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_blob);\n\nVISIBLE_IF_KUNIT int aa_unpack_str(struct aa_ext *e, const char **string, const char *name)\n{\n\tchar *src_str;\n\tsize_t size = 0;\n\tvoid *pos = e->pos;\n\t*string = NULL;\n\tif (aa_unpack_nameX(e, AA_STRING, name)) {\n\t\tsize = aa_unpack_u16_chunk(e, &src_str);\n\t\tif (size) {\n\t\t\t \n\t\t\tif (src_str[size - 1] != 0)\n\t\t\t\tgoto fail;\n\t\t\t*string = src_str;\n\n\t\t\treturn size;\n\t\t}\n\t}\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_str);\n\nVISIBLE_IF_KUNIT int aa_unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = aa_unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}\nEXPORT_SYMBOL_IF_KUNIT(aa_unpack_strdup);\n\n\n \nstatic struct aa_dfa *unpack_dfa(struct aa_ext *e, int flags)\n{\n\tchar *blob = NULL;\n\tsize_t size;\n\tstruct aa_dfa *dfa = NULL;\n\n\tsize = aa_unpack_blob(e, &blob, \"aadfa\");\n\tif (size) {\n\t\t \n\t\tsize_t sz = blob - (char *) e->start -\n\t\t\t((e->pos - e->start) & 7);\n\t\tsize_t pad = ALIGN(sz, 8) - sz;\n\t\tif (aa_g_paranoid_load)\n\t\t\tflags |= DFA_FLAG_VERIFY_STATES;\n\t\tdfa = aa_dfa_unpack(blob + pad, size - pad, flags);\n\n\t\tif (IS_ERR(dfa))\n\t\t\treturn dfa;\n\n\t}\n\n\treturn dfa;\n}\n\n \nstatic bool unpack_trans_table(struct aa_ext *e, struct aa_str_table *strs)\n{\n\tvoid *saved_pos = e->pos;\n\tchar **table = NULL;\n\n\t \n\tif (aa_unpack_nameX(e, AA_STRUCT, \"xtable\")) {\n\t\tu16 size;\n\t\tint i;\n\n\t\tif (!aa_unpack_array(e, NULL, &size))\n\t\t\t \n\t\t\tgoto fail;\n\t\ttable = kcalloc(size, sizeof(char *), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tstrs->table = table;\n\t\tstrs->size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = aa_unpack_strdup(e, &str, NULL);\n\t\t\t \n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\ttable[i] = str;\n\t\t\t \n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*str == ':') {\n\t\t\t\t \n\t\t\t\tif (!str[1])\n\t\t\t\t\tgoto fail;\n\t\t\t\t \n\t\t\t\tif (c == 1)\n\t\t\t\t\tstr[pos] = ':';\n\t\t\t\telse if (c > 1)\n\t\t\t\t\tgoto fail;\n\t\t\t} else if (c)\n\t\t\t\t \n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn true;\n\nfail:\n\taa_free_str_table(strs);\n\te->pos = saved_pos;\n\treturn false;\n}\n\nstatic bool unpack_xattrs(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *pos = e->pos;\n\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"xattrs\")) {\n\t\tu16 size;\n\t\tint i;\n\n\t\tif (!aa_unpack_array(e, NULL, &size))\n\t\t\tgoto fail;\n\t\tprofile->attach.xattr_count = size;\n\t\tprofile->attach.xattrs = kcalloc(size, sizeof(char *), GFP_KERNEL);\n\t\tif (!profile->attach.xattrs)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (!aa_unpack_strdup(e, &profile->attach.xattrs[i], NULL))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\treturn true;\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\n\nstatic bool unpack_secmark(struct aa_ext *e, struct aa_ruleset *rules)\n{\n\tvoid *pos = e->pos;\n\tu16 size;\n\tint i;\n\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"secmark\")) {\n\t\tif (!aa_unpack_array(e, NULL, &size))\n\t\t\tgoto fail;\n\n\t\trules->secmark = kcalloc(size, sizeof(struct aa_secmark),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!rules->secmark)\n\t\t\tgoto fail;\n\n\t\trules->secmark_count = size;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (!unpack_u8(e, &rules->secmark[i].audit, NULL))\n\t\t\t\tgoto fail;\n\t\t\tif (!unpack_u8(e, &rules->secmark[i].deny, NULL))\n\t\t\t\tgoto fail;\n\t\t\tif (!aa_unpack_strdup(e, &rules->secmark[i].label, NULL))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\treturn true;\n\nfail:\n\tif (rules->secmark) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tkfree(rules->secmark[i].label);\n\t\tkfree(rules->secmark);\n\t\trules->secmark_count = 0;\n\t\trules->secmark = NULL;\n\t}\n\n\te->pos = pos;\n\treturn false;\n}\n\nstatic bool unpack_rlimits(struct aa_ext *e, struct aa_ruleset *rules)\n{\n\tvoid *pos = e->pos;\n\n\t \n\tif (aa_unpack_nameX(e, AA_STRUCT, \"rlimits\")) {\n\t\tu16 size;\n\t\tint i;\n\t\tu32 tmp = 0;\n\t\tif (!aa_unpack_u32(e, &tmp, NULL))\n\t\t\tgoto fail;\n\t\trules->rlimits.mask = tmp;\n\n\t\tif (!aa_unpack_array(e, NULL, &size) ||\n\t\t    size > RLIM_NLIMITS)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu64 tmp2 = 0;\n\t\t\tint a = aa_map_resource(i);\n\t\t\tif (!aa_unpack_u64(e, &tmp2, NULL))\n\t\t\t\tgoto fail;\n\t\t\trules->rlimits.limits[a].rlim_max = tmp2;\n\t\t}\n\t\tif (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn true;\n\nfail:\n\te->pos = pos;\n\treturn false;\n}\n\nstatic bool unpack_perm(struct aa_ext *e, u32 version, struct aa_perms *perm)\n{\n\tif (version != 1)\n\t\treturn false;\n\n\treturn\taa_unpack_u32(e, &perm->allow, NULL) &&\n\t\taa_unpack_u32(e, &perm->allow, NULL) &&\n\t\taa_unpack_u32(e, &perm->deny, NULL) &&\n\t\taa_unpack_u32(e, &perm->subtree, NULL) &&\n\t\taa_unpack_u32(e, &perm->cond, NULL) &&\n\t\taa_unpack_u32(e, &perm->kill, NULL) &&\n\t\taa_unpack_u32(e, &perm->complain, NULL) &&\n\t\taa_unpack_u32(e, &perm->prompt, NULL) &&\n\t\taa_unpack_u32(e, &perm->audit, NULL) &&\n\t\taa_unpack_u32(e, &perm->quiet, NULL) &&\n\t\taa_unpack_u32(e, &perm->hide, NULL) &&\n\t\taa_unpack_u32(e, &perm->xindex, NULL) &&\n\t\taa_unpack_u32(e, &perm->tag, NULL) &&\n\t\taa_unpack_u32(e, &perm->label, NULL);\n}\n\nstatic ssize_t unpack_perms_table(struct aa_ext *e, struct aa_perms **perms)\n{\n\tvoid *pos = e->pos;\n\tu16 size = 0;\n\n\tAA_BUG(!perms);\n\t \n\tif (aa_unpack_nameX(e, AA_STRUCT, \"perms\")) {\n\t\tint i;\n\t\tu32 version;\n\n\t\tif (!aa_unpack_u32(e, &version, \"version\"))\n\t\t\tgoto fail_reset;\n\t\tif (!aa_unpack_array(e, NULL, &size))\n\t\t\tgoto fail_reset;\n\t\t*perms = kcalloc(size, sizeof(struct aa_perms), GFP_KERNEL);\n\t\tif (!*perms)\n\t\t\tgoto fail_reset;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (!unpack_perm(e, version, &(*perms)[i]))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!aa_unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t} else\n\t\t*perms = NULL;\n\n\treturn size;\n\nfail:\n\tkfree(*perms);\nfail_reset:\n\te->pos = pos;\n\treturn -EPROTO;\n}\n\nstatic int unpack_pdb(struct aa_ext *e, struct aa_policydb *policy,\n\t\t      bool required_dfa, bool required_trans,\n\t\t      const char **info)\n{\n\tvoid *pos = e->pos;\n\tint i, flags, error = -EPROTO;\n\tssize_t size;\n\n\tsize = unpack_perms_table(e, &policy->perms);\n\tif (size < 0) {\n\t\terror = size;\n\t\tpolicy->perms = NULL;\n\t\t*info = \"failed to unpack - perms\";\n\t\tgoto fail;\n\t}\n\tpolicy->size = size;\n\n\tif (policy->perms) {\n\t\t \n\t\tflags = TO_ACCEPT1_FLAG(YYTD_DATA32);\n\t} else {\n\t\t \n\t\tflags = TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32);\n\t}\n\n\tpolicy->dfa = unpack_dfa(e, flags);\n\tif (IS_ERR(policy->dfa)) {\n\t\terror = PTR_ERR(policy->dfa);\n\t\tpolicy->dfa = NULL;\n\t\t*info = \"failed to unpack - dfa\";\n\t\tgoto fail;\n\t} else if (!policy->dfa) {\n\t\tif (required_dfa) {\n\t\t\t*info = \"missing required dfa\";\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (!aa_unpack_u32(e, &policy->start[0], \"start\"))\n\t\t \n\t\tpolicy->start[0] = DFA_START;\n\tif (!aa_unpack_u32(e, &policy->start[AA_CLASS_FILE], \"dfa_start\")) {\n\t\t \n\t\tpolicy->start[AA_CLASS_FILE] = DFA_START;\n\t}\t \n\tfor (i = AA_CLASS_FILE + 1; i <= AA_CLASS_LAST; i++) {\n\t\tpolicy->start[i] = aa_dfa_next(policy->dfa, policy->start[0],\n\t\t\t\t\t       i);\n\t}\n\tif (!unpack_trans_table(e, &policy->trans) && required_trans) {\n\t\t*info = \"failed to unpack profile transition table\";\n\t\tgoto fail;\n\t}\n\n\t \n\t \nout:\n\treturn 0;\n\nfail:\n\te->pos = pos;\n\treturn error;\n}\n\nstatic u32 strhash(const void *data, u32 len, u32 seed)\n{\n\tconst char * const *key = data;\n\n\treturn jhash(*key, strlen(*key), seed);\n}\n\nstatic int datacmp(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct aa_data *data = obj;\n\tconst char * const *key = arg->key;\n\n\treturn strcmp(data->key, *key);\n}\n\n \nstatic struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)\n{\n\tstruct aa_ruleset *rules;\n\tstruct aa_profile *profile = NULL;\n\tconst char *tmpname, *tmpns = NULL, *name = NULL;\n\tconst char *info = \"failed to unpack profile\";\n\tsize_t ns_len;\n\tstruct rhashtable_params params = { 0 };\n\tchar *key = NULL, *disconnected = NULL;\n\tstruct aa_data *data;\n\tint error = -EPROTO;\n\tkernel_cap_t tmpcap;\n\tu32 tmp;\n\n\t*ns_name = NULL;\n\n\t \n\tif (!aa_unpack_nameX(e, AA_STRUCT, \"profile\"))\n\t\tgoto fail;\n\tif (!aa_unpack_str(e, &name, NULL))\n\t\tgoto fail;\n\tif (*name == '\\0')\n\t\tgoto fail;\n\n\ttmpname = aa_splitn_fqname(name, strlen(name), &tmpns, &ns_len);\n\tif (tmpns) {\n\t\tif (!tmpname) {\n\t\t\tinfo = \"empty profile name\";\n\t\t\tgoto fail;\n\t\t}\n\t\t*ns_name = kstrndup(tmpns, ns_len, GFP_KERNEL);\n\t\tif (!*ns_name) {\n\t\t\tinfo = \"out of memory\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tname = tmpname;\n\t}\n\n\tprofile = aa_alloc_profile(name, NULL, GFP_KERNEL);\n\tif (!profile) {\n\t\tinfo = \"out of memory\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\trules = list_first_entry(&profile->rules, typeof(*rules), list);\n\n\t \n\t(void) aa_unpack_str(e, &profile->rename, \"rename\");\n\n\t \n\t(void) aa_unpack_str(e, &profile->attach.xmatch_str, \"attach\");\n\n\t \n\terror = unpack_pdb(e, &profile->attach.xmatch, false, false, &info);\n\tif (error) {\n\t\tinfo = \"bad xmatch\";\n\t\tgoto fail;\n\t}\n\n\t \n\tif (profile->attach.xmatch.dfa) {\n\t\tif (!aa_unpack_u32(e, &tmp, NULL)) {\n\t\t\tinfo = \"missing xmatch len\";\n\t\t\tgoto fail;\n\t\t}\n\t\tprofile->attach.xmatch_len = tmp;\n\t\tprofile->attach.xmatch.start[AA_CLASS_XMATCH] = DFA_START;\n\t\tif (!profile->attach.xmatch.perms) {\n\t\t\terror = aa_compat_map_xmatch(&profile->attach.xmatch);\n\t\t\tif (error) {\n\t\t\t\tinfo = \"failed to convert xmatch permission table\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t(void) aa_unpack_strdup(e, &disconnected, \"disconnected\");\n\tprofile->disconnected = disconnected;\n\n\t \n\tif (!aa_unpack_nameX(e, AA_STRUCT, \"flags\")) {\n\t\tinfo = \"profile missing flags\";\n\t\tgoto fail;\n\t}\n\tinfo = \"failed to unpack profile flags\";\n\tif (!aa_unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp & PACKED_FLAG_HAT)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tif (tmp & PACKED_FLAG_DEBUG1)\n\t\tprofile->label.flags |= FLAG_DEBUG1;\n\tif (tmp & PACKED_FLAG_DEBUG2)\n\t\tprofile->label.flags |= FLAG_DEBUG2;\n\tif (!aa_unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG)) {\n\t\tprofile->mode = APPARMOR_COMPLAIN;\n\t} else if (tmp == PACKED_MODE_ENFORCE) {\n\t\tprofile->mode = APPARMOR_ENFORCE;\n\t} else if (tmp == PACKED_MODE_KILL) {\n\t\tprofile->mode = APPARMOR_KILL;\n\t} else if (tmp == PACKED_MODE_UNCONFINED) {\n\t\tprofile->mode = APPARMOR_UNCONFINED;\n\t\tprofile->label.flags |= FLAG_UNCONFINED;\n\t} else if (tmp == PACKED_MODE_USER) {\n\t\tprofile->mode = APPARMOR_USER;\n\t} else {\n\t\tgoto fail;\n\t}\n\tif (!aa_unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp)\n\t\tprofile->audit = AUDIT_ALL;\n\n\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\tgoto fail;\n\n\t \n\tif (aa_unpack_u32(e, &profile->path_flags, \"path_flags\"))\n\t\tprofile->path_flags |= profile->label.flags &\n\t\t\tPATH_MEDIATE_DELETED;\n\telse\n\t\t \n\t\tprofile->path_flags = PATH_MEDIATE_DELETED;\n\n\tinfo = \"failed to unpack profile capabilities\";\n\tif (!aa_unpack_cap_low(e, &rules->caps.allow, NULL))\n\t\tgoto fail;\n\tif (!aa_unpack_cap_low(e, &rules->caps.audit, NULL))\n\t\tgoto fail;\n\tif (!aa_unpack_cap_low(e, &rules->caps.quiet, NULL))\n\t\tgoto fail;\n\tif (!aa_unpack_cap_low(e, &tmpcap, NULL))\n\t\tgoto fail;\n\n\tinfo = \"failed to unpack upper profile capabilities\";\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"caps64\")) {\n\t\t \n\t\tif (!aa_unpack_cap_high(e, &rules->caps.allow, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_cap_high(e, &rules->caps.audit, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_cap_high(e, &rules->caps.quiet, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_cap_high(e, &tmpcap, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tinfo = \"failed to unpack extended profile capabilities\";\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"capsx\")) {\n\t\t \n\t\tif (!aa_unpack_cap_low(e, &rules->caps.extended, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_cap_high(e, &rules->caps.extended, NULL))\n\t\t\tgoto fail;\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tif (!unpack_xattrs(e, profile)) {\n\t\tinfo = \"failed to unpack profile xattrs\";\n\t\tgoto fail;\n\t}\n\n\tif (!unpack_rlimits(e, rules)) {\n\t\tinfo = \"failed to unpack profile rlimits\";\n\t\tgoto fail;\n\t}\n\n\tif (!unpack_secmark(e, rules)) {\n\t\tinfo = \"failed to unpack profile secmark rules\";\n\t\tgoto fail;\n\t}\n\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"policydb\")) {\n\t\t \n\t\tinfo = \"failed to unpack policydb\";\n\t\terror = unpack_pdb(e, &rules->policy, true, false,\n\t\t\t\t   &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\t \n\t\tif (aa_dfa_next(rules->policy.dfa, rules->policy.start[0],\n\t\t\t\tAA_CLASS_FILE))\n\t\t\trules->policy.start[AA_CLASS_FILE] =\n\t\t\t  aa_dfa_next(rules->policy.dfa,\n\t\t\t\t      rules->policy.start[0],\n\t\t\t\t      AA_CLASS_FILE);\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!rules->policy.perms) {\n\t\t\terror = aa_compat_map_policy(&rules->policy,\n\t\t\t\t\t\t     e->version);\n\t\t\tif (error) {\n\t\t\t\tinfo = \"failed to remap policydb permission table\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trules->policy.dfa = aa_get_dfa(nulldfa);\n\t\trules->policy.perms = kcalloc(2, sizeof(struct aa_perms),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!rules->policy.perms)\n\t\t\tgoto fail;\n\t\trules->policy.size = 2;\n\t}\n\t \n\terror = unpack_pdb(e, &rules->file, false, true, &info);\n\tif (error) {\n\t\tgoto fail;\n\t} else if (rules->file.dfa) {\n\t\tif (!rules->file.perms) {\n\t\t\terror = aa_compat_map_file(&rules->file);\n\t\t\tif (error) {\n\t\t\t\tinfo = \"failed to remap file permission table\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else if (rules->policy.dfa &&\n\t\t   rules->policy.start[AA_CLASS_FILE]) {\n\t\trules->file.dfa = aa_get_dfa(rules->policy.dfa);\n\t\trules->file.start[AA_CLASS_FILE] = rules->policy.start[AA_CLASS_FILE];\n\t\trules->file.perms = kcalloc(rules->policy.size,\n\t\t\t\t\t    sizeof(struct aa_perms),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!rules->file.perms)\n\t\t\tgoto fail;\n\t\tmemcpy(rules->file.perms, rules->policy.perms,\n\t\t       rules->policy.size * sizeof(struct aa_perms));\n\t\trules->file.size = rules->policy.size;\n\t} else {\n\t\trules->file.dfa = aa_get_dfa(nulldfa);\n\t\trules->file.perms = kcalloc(2, sizeof(struct aa_perms),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!rules->file.perms)\n\t\t\tgoto fail;\n\t\trules->file.size = 2;\n\t}\n\terror = -EPROTO;\n\tif (aa_unpack_nameX(e, AA_STRUCT, \"data\")) {\n\t\tinfo = \"out of memory\";\n\t\tprofile->data = kzalloc(sizeof(*profile->data), GFP_KERNEL);\n\t\tif (!profile->data) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tparams.nelem_hint = 3;\n\t\tparams.key_len = sizeof(void *);\n\t\tparams.key_offset = offsetof(struct aa_data, key);\n\t\tparams.head_offset = offsetof(struct aa_data, head);\n\t\tparams.hashfn = strhash;\n\t\tparams.obj_cmpfn = datacmp;\n\n\t\tif (rhashtable_init(profile->data, &params)) {\n\t\t\tinfo = \"failed to init key, value hash table\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\twhile (aa_unpack_strdup(e, &key, NULL)) {\n\t\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tkfree_sensitive(key);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdata->key = key;\n\t\t\tdata->size = aa_unpack_blob(e, &data->data, NULL);\n\t\t\tdata->data = kvmemdup(data->data, data->size, GFP_KERNEL);\n\t\t\tif (data->size && !data->data) {\n\t\t\t\tkfree_sensitive(data->key);\n\t\t\t\tkfree_sensitive(data);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (rhashtable_insert_fast(profile->data, &data->head,\n\t\t\t\t\t\t   profile->data->p)) {\n\t\t\t\tkfree_sensitive(data->key);\n\t\t\t\tkfree_sensitive(data);\n\t\t\t\tinfo = \"failed to insert data to table\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\t\tinfo = \"failed to unpack end of key, value data table\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!aa_unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\tinfo = \"failed to unpack end of profile\";\n\t\tgoto fail;\n\t}\n\n\treturn profile;\n\nfail:\n\tif (error == 0)\n\t\t \n\t\terror = -EPROTO;\n\tif (*ns_name) {\n\t\tkfree(*ns_name);\n\t\t*ns_name = NULL;\n\t}\n\tif (profile)\n\t\tname = NULL;\n\telse if (!name)\n\t\tname = \"unknown\";\n\taudit_iface(profile, NULL, name, info, e, error);\n\taa_free_profile(profile);\n\n\treturn ERR_PTR(error);\n}\n\n \nstatic int verify_header(struct aa_ext *e, int required, const char **ns)\n{\n\tint error = -EPROTONOSUPPORT;\n\tconst char *name = NULL;\n\t*ns = NULL;\n\n\t \n\tif (!aa_unpack_u32(e, &e->version, \"version\")) {\n\t\tif (required) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid profile format\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tif (VERSION_LT(e->version, v5) || VERSION_GT(e->version, v9)) {\n\t\taudit_iface(NULL, NULL, NULL, \"unsupported interface version\",\n\t\t\t    e, error);\n\t\treturn error;\n\t}\n\n\t \n\tif (aa_unpack_str(e, &name, \"namespace\")) {\n\t\tif (*name == '\\0') {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid namespace name\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t\tif (*ns && strcmp(*ns, name)) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid ns change\", e,\n\t\t\t\t    error);\n\t\t} else if (!*ns) {\n\t\t\t*ns = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!*ns)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool verify_dfa_accept_index(struct aa_dfa *dfa, int table_size)\n{\n\tint i;\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tif (ACCEPT_TABLE(dfa)[i] >= table_size)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool verify_perm(struct aa_perms *perm)\n{\n\t \n\tif (perm->allow & perm->deny)\n\t\treturn false;\n\tif (perm->subtree & ~perm->allow)\n\t\treturn false;\n\tif (perm->cond & (perm->allow | perm->deny))\n\t\treturn false;\n\tif (perm->kill & perm->allow)\n\t\treturn false;\n\tif (perm->complain & (perm->allow | perm->deny))\n\t\treturn false;\n\tif (perm->prompt & (perm->allow | perm->deny))\n\t\treturn false;\n\tif (perm->complain & perm->prompt)\n\t\treturn false;\n\tif (perm->hide & perm->allow)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool verify_perms(struct aa_policydb *pdb)\n{\n\tint i;\n\n\tfor (i = 0; i < pdb->size; i++) {\n\t\tif (!verify_perm(&pdb->perms[i]))\n\t\t\treturn false;\n\t\t \n\t\tif ((pdb->perms[i].xindex & AA_X_TYPE_MASK) == AA_X_TABLE &&\n\t\t    (pdb->perms[i].xindex & AA_X_INDEX_MASK) >= pdb->trans.size)\n\t\t\treturn false;\n\t\tif (pdb->perms[i].tag && pdb->perms[i].tag >= pdb->trans.size)\n\t\t\treturn false;\n\t\tif (pdb->perms[i].label &&\n\t\t    pdb->perms[i].label >= pdb->trans.size)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int verify_profile(struct aa_profile *profile)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tif (!rules)\n\t\treturn 0;\n\n\tif ((rules->file.dfa && !verify_dfa_accept_index(rules->file.dfa,\n\t\t\t\t\t\t\t rules->file.size)) ||\n\t    (rules->policy.dfa &&\n\t     !verify_dfa_accept_index(rules->policy.dfa, rules->policy.size))) {\n\t\taudit_iface(profile, NULL, NULL,\n\t\t\t    \"Unpack: Invalid named transition\", NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\tif (!verify_perms(&rules->file)) {\n\t\taudit_iface(profile, NULL, NULL,\n\t\t\t    \"Unpack: Invalid perm index\", NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\tif (!verify_perms(&rules->policy)) {\n\t\taudit_iface(profile, NULL, NULL,\n\t\t\t    \"Unpack: Invalid perm index\", NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\tif (!verify_perms(&profile->attach.xmatch)) {\n\t\taudit_iface(profile, NULL, NULL,\n\t\t\t    \"Unpack: Invalid perm index\", NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nvoid aa_load_ent_free(struct aa_load_ent *ent)\n{\n\tif (ent) {\n\t\taa_put_profile(ent->rename);\n\t\taa_put_profile(ent->old);\n\t\taa_put_profile(ent->new);\n\t\tkfree(ent->ns_name);\n\t\tkfree_sensitive(ent);\n\t}\n}\n\nstruct aa_load_ent *aa_load_ent_alloc(void)\n{\n\tstruct aa_load_ent *ent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (ent)\n\t\tINIT_LIST_HEAD(&ent->list);\n\treturn ent;\n}\n\nstatic int compress_zstd(const char *src, size_t slen, char **dst, size_t *dlen)\n{\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n\tconst zstd_parameters params =\n\t\tzstd_get_params(aa_g_rawdata_compression_level, slen);\n\tconst size_t wksp_len = zstd_cctx_workspace_bound(&params.cParams);\n\tvoid *wksp = NULL;\n\tzstd_cctx *ctx = NULL;\n\tsize_t out_len = zstd_compress_bound(slen);\n\tvoid *out = NULL;\n\tint ret = 0;\n\n\tout = kvzalloc(out_len, GFP_KERNEL);\n\tif (!out) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\twksp = kvzalloc(wksp_len, GFP_KERNEL);\n\tif (!wksp) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tctx = zstd_init_cctx(wksp, wksp_len);\n\tif (!ctx) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tout_len = zstd_compress_cctx(ctx, out, out_len, src, slen, &params);\n\tif (zstd_is_error(out_len) || out_len >= slen) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_vmalloc_addr(out)) {\n\t\t*dst = kvzalloc(out_len, GFP_KERNEL);\n\t\tif (*dst) {\n\t\t\tmemcpy(*dst, out, out_len);\n\t\t\tkvfree(out);\n\t\t\tout = NULL;\n\t\t}\n\t} else {\n\t\t \n\t\t*dst = krealloc(out, out_len, GFP_KERNEL);\n\t}\n\n\tif (!*dst) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t*dlen = out_len;\n\ncleanup:\n\tif (ret) {\n\t\tkvfree(out);\n\t\t*dst = NULL;\n\t}\n\n\tkvfree(wksp);\n\treturn ret;\n#else\n\t*dlen = slen;\n\treturn 0;\n#endif\n}\n\nstatic int compress_loaddata(struct aa_loaddata *data)\n{\n\tAA_BUG(data->compressed_size > 0);\n\n\t \n\tif (aa_g_rawdata_compression_level != 0) {\n\t\tvoid *udata = data->data;\n\t\tint error = compress_zstd(udata, data->size, &data->data,\n\t\t\t\t\t  &data->compressed_size);\n\t\tif (error) {\n\t\t\tdata->compressed_size = data->size;\n\t\t\treturn error;\n\t\t}\n\t\tif (udata != data->data)\n\t\t\tkvfree(udata);\n\t} else\n\t\tdata->compressed_size = data->size;\n\n\treturn 0;\n}\n\n \nint aa_unpack(struct aa_loaddata *udata, struct list_head *lh,\n\t      const char **ns)\n{\n\tstruct aa_load_ent *tmp, *ent;\n\tstruct aa_profile *profile = NULL;\n\tchar *ns_name = NULL;\n\tint error;\n\tstruct aa_ext e = {\n\t\t.start = udata->data,\n\t\t.end = udata->data + udata->size,\n\t\t.pos = udata->data,\n\t};\n\n\t*ns = NULL;\n\twhile (e.pos < e.end) {\n\t\tvoid *start;\n\t\terror = verify_header(&e, e.pos == e.start, ns);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tstart = e.pos;\n\t\tprofile = unpack_profile(&e, &ns_name);\n\t\tif (IS_ERR(profile)) {\n\t\t\terror = PTR_ERR(profile);\n\t\t\tgoto fail;\n\t\t}\n\n\t\terror = verify_profile(profile);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tif (aa_g_hash_policy)\n\t\t\terror = aa_calc_profile_hash(profile, e.version, start,\n\t\t\t\t\t\t     e.pos - start);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tent = aa_load_ent_alloc();\n\t\tif (!ent) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail_profile;\n\t\t}\n\n\t\tent->new = profile;\n\t\tent->ns_name = ns_name;\n\t\tns_name = NULL;\n\t\tlist_add_tail(&ent->list, lh);\n\t}\n\tudata->abi = e.version & K_ABI_MASK;\n\tif (aa_g_hash_policy) {\n\t\tudata->hash = aa_calc_hash(udata->data, udata->size);\n\t\tif (IS_ERR(udata->hash)) {\n\t\t\terror = PTR_ERR(udata->hash);\n\t\t\tudata->hash = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (aa_g_export_binary) {\n\t\terror = compress_loaddata(udata);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail_profile:\n\tkfree(ns_name);\n\taa_put_profile(profile);\n\nfail:\n\tlist_for_each_entry_safe(ent, tmp, lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}