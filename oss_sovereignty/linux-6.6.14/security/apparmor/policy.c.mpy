{
  "module_name": "policy.c",
  "hash_id": "891b5457180abb9768cdfe24c2c2efead620719c946dc14aee83298c4b8de9b8",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/policy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/rculist.h>\n#include <linux/user_namespace.h>\n\n#include \"include/apparmor.h\"\n#include \"include/capability.h\"\n#include \"include/cred.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/match.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n\nint unprivileged_userns_apparmor_policy = 1;\n\nconst char *const aa_profile_mode_names[] = {\n\t\"enforce\",\n\t\"complain\",\n\t\"kill\",\n\t\"unconfined\",\n\t\"user\",\n};\n\n\n \nstatic void __add_profile(struct list_head *list, struct aa_profile *profile)\n{\n\tstruct aa_label *l;\n\n\tAA_BUG(!list);\n\tAA_BUG(!profile);\n\tAA_BUG(!profile->ns);\n\tAA_BUG(!mutex_is_locked(&profile->ns->lock));\n\n\tlist_add_rcu(&profile->base.list, list);\n\t \n\taa_get_profile(profile);\n\tl = aa_label_insert(&profile->ns->labels, &profile->label);\n\tAA_BUG(l != &profile->label);\n\taa_put_label(l);\n}\n\n \nstatic void __list_remove_profile(struct aa_profile *profile)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!profile->ns);\n\tAA_BUG(!mutex_is_locked(&profile->ns->lock));\n\n\tlist_del_rcu(&profile->base.list);\n\taa_put_profile(profile);\n}\n\n \nstatic void __remove_profile(struct aa_profile *profile)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!profile->ns);\n\tAA_BUG(!mutex_is_locked(&profile->ns->lock));\n\n\t \n\t__aa_profile_list_release(&profile->base.profiles);\n\t \n\taa_label_remove(&profile->label);\n\t__aafs_profile_rmdir(profile);\n\t__list_remove_profile(profile);\n}\n\n \nvoid __aa_profile_list_release(struct list_head *head)\n{\n\tstruct aa_profile *profile, *tmp;\n\tlist_for_each_entry_safe(profile, tmp, head, base.list)\n\t\t__remove_profile(profile);\n}\n\n \nstatic void aa_free_data(void *ptr, void *arg)\n{\n\tstruct aa_data *data = ptr;\n\n\tkfree_sensitive(data->data);\n\tkfree_sensitive(data->key);\n\tkfree_sensitive(data);\n}\n\nstatic void free_attachment(struct aa_attachment *attach)\n{\n\tint i;\n\n\tfor (i = 0; i < attach->xattr_count; i++)\n\t\tkfree_sensitive(attach->xattrs[i]);\n\tkfree_sensitive(attach->xattrs);\n\taa_destroy_policydb(&attach->xmatch);\n}\n\nstatic void free_ruleset(struct aa_ruleset *rules)\n{\n\tint i;\n\n\taa_destroy_policydb(&rules->file);\n\taa_destroy_policydb(&rules->policy);\n\taa_free_cap_rules(&rules->caps);\n\taa_free_rlimit_rules(&rules->rlimits);\n\n\tfor (i = 0; i < rules->secmark_count; i++)\n\t\tkfree_sensitive(rules->secmark[i].label);\n\tkfree_sensitive(rules->secmark);\n\tkfree_sensitive(rules);\n}\n\nstruct aa_ruleset *aa_alloc_ruleset(gfp_t gfp)\n{\n\tstruct aa_ruleset *rules;\n\n\trules = kzalloc(sizeof(*rules), gfp);\n\tif (rules)\n\t\tINIT_LIST_HEAD(&rules->list);\n\n\treturn rules;\n}\n\n \nvoid aa_free_profile(struct aa_profile *profile)\n{\n\tstruct aa_ruleset *rule, *tmp;\n\tstruct rhashtable *rht;\n\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, profile);\n\n\tif (!profile)\n\t\treturn;\n\n\t \n\taa_policy_destroy(&profile->base);\n\taa_put_profile(rcu_access_pointer(profile->parent));\n\n\taa_put_ns(profile->ns);\n\tkfree_sensitive(profile->rename);\n\tkfree_sensitive(profile->disconnected);\n\n\tfree_attachment(&profile->attach);\n\n\t \n\tlist_for_each_entry_safe(rule, tmp, &profile->rules, list) {\n\t\tlist_del_init(&rule->list);\n\t\tfree_ruleset(rule);\n\t}\n\tkfree_sensitive(profile->dirname);\n\n\tif (profile->data) {\n\t\trht = profile->data;\n\t\tprofile->data = NULL;\n\t\trhashtable_free_and_destroy(rht, aa_free_data, NULL);\n\t\tkfree_sensitive(rht);\n\t}\n\n\tkfree_sensitive(profile->hash);\n\taa_put_loaddata(profile->rawdata);\n\taa_label_destroy(&profile->label);\n\n\tkfree_sensitive(profile);\n}\n\n \nstruct aa_profile *aa_alloc_profile(const char *hname, struct aa_proxy *proxy,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ruleset *rules;\n\n\t \n\tprofile = kzalloc(struct_size(profile, label.vec, 2), gfp);\n\tif (!profile)\n\t\treturn NULL;\n\n\tif (!aa_policy_init(&profile->base, NULL, hname, gfp))\n\t\tgoto fail;\n\tif (!aa_label_init(&profile->label, 1, gfp))\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&profile->rules);\n\n\t \n\trules = aa_alloc_ruleset(gfp);\n\tif (!rules)\n\t\tgoto fail;\n\tlist_add(&rules->list, &profile->rules);\n\n\t \n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(&profile->label, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\tprofile->label.proxy = proxy;\n\n\tprofile->label.hname = profile->base.hname;\n\tprofile->label.flags |= FLAG_PROFILE;\n\tprofile->label.vec[0] = profile;\n\n\t \n\treturn profile;\n\nfail:\n\taa_free_profile(profile);\n\n\treturn NULL;\n}\n\n \n\n \nstatic struct aa_profile *__strn_find_child(struct list_head *head,\n\t\t\t\t\t    const char *name, int len)\n{\n\treturn (struct aa_profile *)__policy_strn_find(head, name, len);\n}\n\n \nstatic struct aa_profile *__find_child(struct list_head *head, const char *name)\n{\n\treturn __strn_find_child(head, name, strlen(name));\n}\n\n \nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t \n\treturn profile;\n}\n\n \nstatic struct aa_policy *__lookup_parent(struct aa_ns *ns,\n\t\t\t\t\t const char *hname)\n{\n\tstruct aa_policy *policy;\n\tstruct aa_profile *profile = NULL;\n\tchar *split;\n\n\tpolicy = &ns->base;\n\n\tfor (split = strstr(hname, \"//\"); split;) {\n\t\tprofile = __strn_find_child(&policy->profiles, hname,\n\t\t\t\t\t    split - hname);\n\t\tif (!profile)\n\t\t\treturn NULL;\n\t\tpolicy = &profile->base;\n\t\thname = split + 2;\n\t\tsplit = strstr(hname, \"//\");\n\t}\n\tif (!profile)\n\t\treturn &ns->base;\n\treturn &profile->base;\n}\n\n \nstatic struct aa_policy *__create_missing_ancestors(struct aa_ns *ns,\n\t\t\t\t\t\t    const char *hname,\n\t\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_policy *policy;\n\tstruct aa_profile *parent, *profile = NULL;\n\tchar *split;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!hname);\n\n\tpolicy = &ns->base;\n\n\tfor (split = strstr(hname, \"//\"); split;) {\n\t\tparent = profile;\n\t\tprofile = __strn_find_child(&policy->profiles, hname,\n\t\t\t\t\t    split - hname);\n\t\tif (!profile) {\n\t\t\tconst char *name = kstrndup(hname, split - hname,\n\t\t\t\t\t\t    gfp);\n\t\t\tif (!name)\n\t\t\t\treturn NULL;\n\t\t\tprofile = aa_alloc_null(parent, name, gfp);\n\t\t\tkfree(name);\n\t\t\tif (!profile)\n\t\t\t\treturn NULL;\n\t\t\tif (!parent)\n\t\t\t\tprofile->ns = aa_get_ns(ns);\n\t\t}\n\t\tpolicy = &profile->base;\n\t\thname = split + 2;\n\t\tsplit = strstr(hname, \"//\");\n\t}\n\tif (!profile)\n\t\treturn &ns->base;\n\treturn &profile->base;\n}\n\n \nstatic struct aa_profile *__lookupn_profile(struct aa_policy *base,\n\t\t\t\t\t    const char *hname, size_t n)\n{\n\tstruct aa_profile *profile = NULL;\n\tconst char *split;\n\n\tfor (split = strnstr(hname, \"//\", n); split;\n\t     split = strnstr(hname, \"//\", n)) {\n\t\tprofile = __strn_find_child(&base->profiles, hname,\n\t\t\t\t\t    split - hname);\n\t\tif (!profile)\n\t\t\treturn NULL;\n\n\t\tbase = &profile->base;\n\t\tn -= split + 2 - hname;\n\t\thname = split + 2;\n\t}\n\n\tif (n)\n\t\treturn __strn_find_child(&base->profiles, hname, n);\n\treturn NULL;\n}\n\nstatic struct aa_profile *__lookup_profile(struct aa_policy *base,\n\t\t\t\t\t   const char *hname)\n{\n\treturn __lookupn_profile(base, hname, strlen(hname));\n}\n\n \nstruct aa_profile *aa_lookupn_profile(struct aa_ns *ns, const char *hname,\n\t\t\t\t      size_t n)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __lookupn_profile(&ns->base, hname, n);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t \n\tif (!profile && strncmp(hname, \"unconfined\", n) == 0)\n\t\tprofile = aa_get_newest_profile(ns->unconfined);\n\n\t \n\treturn profile;\n}\n\nstruct aa_profile *aa_lookup_profile(struct aa_ns *ns, const char *hname)\n{\n\treturn aa_lookupn_profile(ns, hname, strlen(hname));\n}\n\nstruct aa_profile *aa_fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\tconst char *fqname, size_t n)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *ns;\n\tconst char *name, *ns_name;\n\tsize_t ns_len;\n\n\tname = aa_splitn_fqname(fqname, n, &ns_name, &ns_len);\n\tif (ns_name) {\n\t\tns = aa_lookupn_ns(labels_ns(base), ns_name, ns_len);\n\t\tif (!ns)\n\t\t\treturn NULL;\n\t} else\n\t\tns = aa_get_ns(labels_ns(base));\n\n\tif (name)\n\t\tprofile = aa_lookupn_profile(ns, name, n - (name - fqname));\n\telse if (ns)\n\t\t \n\t\tprofile = aa_get_newest_profile(ns->unconfined);\n\telse\n\t\tprofile = NULL;\n\taa_put_ns(ns);\n\n\treturn profile;\n}\n\n\nstruct aa_profile *aa_alloc_null(struct aa_profile *parent, const char *name,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ruleset *rules;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\treturn NULL;\n\n\t \n\tprofile->label.flags |= FLAG_NULL;\n\trules = list_first_entry(&profile->rules, typeof(*rules), list);\n\trules->file.dfa = aa_get_dfa(nulldfa);\n\trules->file.perms = kcalloc(2, sizeof(struct aa_perms), GFP_KERNEL);\n\tif (!rules->file.perms)\n\t\tgoto fail;\n\trules->file.size = 2;\n\trules->policy.dfa = aa_get_dfa(nulldfa);\n\trules->policy.perms = kcalloc(2, sizeof(struct aa_perms), GFP_KERNEL);\n\tif (!rules->policy.perms)\n\t\tgoto fail;\n\trules->policy.size = 2;\n\n\tif (parent) {\n\t\tprofile->path_flags = parent->path_flags;\n\n\t\t \n\t\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\t\tprofile->ns = aa_get_ns(parent->ns);\n\t}\n\n\treturn profile;\n\nfail:\n\taa_free_profile(profile);\n\n\treturn NULL;\n}\n\n \nstruct aa_profile *aa_new_learning_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t\t   const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t \n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t \n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_null(parent, name, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t \nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}\n\n \nstatic int replacement_allowed(struct aa_profile *profile, int noreplace,\n\t\t\t       const char **info)\n{\n\tif (profile) {\n\t\tif (profile->label.flags & FLAG_IMMUTIBLE) {\n\t\t\t*info = \"cannot replace immutable profile\";\n\t\t\treturn -EPERM;\n\t\t} else if (noreplace) {\n\t\t\t*info = \"profile already exists\";\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->iface.ns) {\n\t\taudit_log_format(ab, \" ns=\");\n\t\taudit_log_untrustedstring(ab, ad->iface.ns);\n\t}\n}\n\n \nstatic int audit_policy(struct aa_label *subj_label, const char *op,\n\t\t\tconst char *ns_name, const char *name,\n\t\t\tconst char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_NONE, op);\n\n\tad.iface.ns = ns_name;\n\tad.name = name;\n\tad.info = info;\n\tad.error = error;\n\tad.subj_label = subj_label;\n\n\taa_audit_msg(AUDIT_APPARMOR_STATUS, &ad, audit_cb);\n\n\treturn error;\n}\n\n \nstatic int policy_ns_capable(const struct cred *subj_cred,\n\t\t\t     struct aa_label *label,\n\t\t\t     struct user_namespace *userns, int cap)\n{\n\tint err;\n\n\t \n\terr = cap_capable(subj_cred, userns, cap, CAP_OPT_NONE);\n\tif (!err)\n\t\terr = aa_capable(subj_cred, label, cap, CAP_OPT_NONE);\n\n\treturn err;\n}\n\n \nbool aa_policy_view_capable(const struct cred *subj_cred,\n\t\t\t     struct aa_label *label, struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = subj_cred->user_ns;\n\tstruct aa_ns *view_ns = labels_view(label);\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\n\treturn response;\n}\n\nbool aa_policy_admin_capable(const struct cred *subj_cred,\n\t\t\t     struct aa_label *label, struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = subj_cred->user_ns;\n\tbool capable = policy_ns_capable(subj_cred, label, user_ns,\n\t\t\t\t\t CAP_MAC_ADMIN) == 0;\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn aa_policy_view_capable(subj_cred, label, ns) && capable &&\n\t\t!aa_g_lock_policy;\n}\n\nbool aa_current_policy_view_capable(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\tbool res;\n\n\tlabel = __begin_current_label_crit_section();\n\tres = aa_policy_view_capable(current_cred(), label, ns);\n\t__end_current_label_crit_section(label);\n\n\treturn res;\n}\n\nbool aa_current_policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\tbool res;\n\n\tlabel = __begin_current_label_crit_section();\n\tres = aa_policy_admin_capable(current_cred(), label, ns);\n\t__end_current_label_crit_section(label);\n\n\treturn res;\n}\n\n \nint aa_may_manage_policy(const struct cred *subj_cred, struct aa_label *label,\n\t\t\t struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t \n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!aa_policy_admin_capable(subj_cred, label, ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t \n\treturn 0;\n}\n\nstatic struct aa_profile *__list_lookup_parent(struct list_head *lh,\n\t\t\t\t\t       struct aa_profile *profile)\n{\n\tconst char *base = basename(profile->base.hname);\n\tlong len = base - profile->base.hname;\n\tstruct aa_load_ent *ent;\n\n\t \n\tif (len <= 2)\n\t\treturn NULL;\n\tlen -= 2;\n\n\tlist_for_each_entry(ent, lh, list) {\n\t\tif (ent->new == profile)\n\t\t\tcontinue;\n\t\tif (strncmp(ent->new->base.hname, profile->base.hname, len) ==\n\t\t    0 && ent->new->base.hname[len] == 0)\n\t\t\treturn ent->new;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void __replace_profile(struct aa_profile *old, struct aa_profile *new)\n{\n\tstruct aa_profile *child, *tmp;\n\n\tif (!list_empty(&old->base.profiles)) {\n\t\tLIST_HEAD(lh);\n\t\tlist_splice_init_rcu(&old->base.profiles, &lh, synchronize_rcu);\n\n\t\tlist_for_each_entry_safe(child, tmp, &lh, base.list) {\n\t\t\tstruct aa_profile *p;\n\n\t\t\tlist_del_init(&child->base.list);\n\t\t\tp = __find_child(&new->base.profiles, child->base.name);\n\t\t\tif (p) {\n\t\t\t\t \n\t\t\t\t__replace_profile(child, p);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tp = aa_deref_parent(child);\n\t\t\trcu_assign_pointer(child->parent, aa_get_profile(new));\n\t\t\tlist_add_rcu(&child->base.list, &new->base.profiles);\n\t\t\taa_put_profile(p);\n\t\t}\n\t}\n\n\tif (!rcu_access_pointer(new->parent)) {\n\t\tstruct aa_profile *parent = aa_deref_parent(old);\n\t\trcu_assign_pointer(new->parent, aa_get_profile(parent));\n\t}\n\taa_label_replace(&old->label, &new->label);\n\t \n\t__aafs_profile_migrate_dents(old, new);\n\n\tif (list_empty(&new->base.list)) {\n\t\t \n\t\tlist_replace_rcu(&old->base.list, &new->base.list);\n\t\taa_get_profile(new);\n\t\taa_put_profile(old);\n\t} else\n\t\t__list_remove_profile(old);\n}\n\n \nstatic int __lookup_replace(struct aa_ns *ns, const char *hname,\n\t\t\t    bool noreplace, struct aa_profile **p,\n\t\t\t    const char **info)\n{\n\t*p = aa_get_profile(__lookup_profile(&ns->base, hname));\n\tif (*p) {\n\t\tint error = replacement_allowed(*p, noreplace, info);\n\t\tif (error) {\n\t\t\t*info = \"profile can not be replaced\";\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void share_name(struct aa_profile *old, struct aa_profile *new)\n{\n\taa_put_str(new->base.hname);\n\taa_get_str(old->base.hname);\n\tnew->base.hname = old->base.hname;\n\tnew->base.name = old->base.name;\n\tnew->label.hname = old->label.hname;\n}\n\n \nstatic struct aa_profile *update_to_newest_parent(struct aa_profile *new)\n{\n\tstruct aa_profile *parent, *newest;\n\n\tparent = rcu_dereference_protected(new->parent,\n\t\t\t\t\t   mutex_is_locked(&new->ns->lock));\n\tnewest = aa_get_newest_profile(parent);\n\n\t \n\tif (newest != parent) {\n\t\taa_put_profile(parent);\n\t\trcu_assign_pointer(new->parent, newest);\n\t} else\n\t\taa_put_profile(newest);\n\n\treturn newest;\n}\n\n \nssize_t aa_replace_profiles(struct aa_ns *policy_ns, struct aa_label *label,\n\t\t\t    u32 mask, struct aa_loaddata *udata)\n{\n\tconst char *ns_name = NULL, *info = NULL;\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_load_ent *ent, *tmp;\n\tstruct aa_loaddata *rawdata_ent;\n\tconst char *op;\n\tssize_t count, error;\n\tLIST_HEAD(lh);\n\n\top = mask & AA_MAY_REPLACE_POLICY ? OP_PROF_REPL : OP_PROF_LOAD;\n\taa_get_loaddata(udata);\n\t \n\terror = aa_unpack(udata, &lh, &ns_name);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tcount = 0;\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (ns_name) {\n\t\t\tif (ent->ns_name &&\n\t\t\t    strcmp(ent->ns_name, ns_name) != 0) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if (ent->ns_name) {\n\t\t\tif (count) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tns_name = ent->ns_name;\n\t\t} else\n\t\t\tcount++;\n\t}\n\tif (ns_name) {\n\t\tns = aa_prepare_ns(policy_ns ? policy_ns : labels_ns(label),\n\t\t\t\t   ns_name);\n\t\tif (IS_ERR(ns)) {\n\t\t\top = OP_PROF_LOAD;\n\t\t\tinfo = \"failed to prepare namespace\";\n\t\t\terror = PTR_ERR(ns);\n\t\t\tns = NULL;\n\t\t\tent = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(label));\n\n\tmutex_lock_nested(&ns->lock, ns->level);\n\t \n\tif (!list_empty(&ns->rawdata_list)) {\n\t\tlist_for_each_entry(rawdata_ent, &ns->rawdata_list, list) {\n\t\t\tif (aa_rawdata_eq(rawdata_ent, udata)) {\n\t\t\t\tstruct aa_loaddata *tmp;\n\n\t\t\t\ttmp = __aa_get_loaddata(rawdata_ent);\n\t\t\t\t \n\t\t\t\tif (tmp) {\n\t\t\t\t\taa_put_loaddata(udata);\n\t\t\t\t\tudata = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\tlist_for_each_entry(ent, &lh, list) {\n\t\tstruct aa_policy *policy;\n\t\tstruct aa_profile *p;\n\n\t\tif (aa_g_export_binary)\n\t\t\tent->new->rawdata = aa_get_loaddata(udata);\n\t\terror = __lookup_replace(ns, ent->new->base.hname,\n\t\t\t\t\t !(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t &ent->old, &info);\n\t\tif (error)\n\t\t\tgoto fail_lock;\n\n\t\tif (ent->new->rename) {\n\t\t\terror = __lookup_replace(ns, ent->new->rename,\n\t\t\t\t\t\t!(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t\t&ent->rename, &info);\n\t\t\tif (error)\n\t\t\t\tgoto fail_lock;\n\t\t}\n\n\t\t \n\t\tent->new->ns = aa_get_ns(ns);\n\n\t\tif (ent->old || ent->rename)\n\t\t\tcontinue;\n\n\t\t \n\t\tp = NULL;\n\t\tpolicy = __lookup_parent(ns, ent->new->base.hname);\n\t\tif (!policy) {\n\t\t\t \n\t\t\tp = __list_lookup_parent(&lh, ent->new);\n\t\t\tif (!p) {\n\t\t\t\t \n\t\t\t\tpolicy = __create_missing_ancestors(ns,\n\t\t\t\t\t\t\tent->new->base.hname,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!policy) {\n\t\t\t\t\terror = -ENOENT;\n\t\t\t\t\tinfo = \"parent does not exist\";\n\t\t\t\t\tgoto fail_lock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!p && policy != &ns->base)\n\t\t\t \n\t\t\tp = (struct aa_profile *) policy;\n\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t}\n\n\t \n\tif (!udata->dents[AAFS_LOADDATA_DIR] && aa_g_export_binary) {\n\t\terror = __aa_fs_create_rawdata(ns, udata);\n\t\tif (error) {\n\t\t\tinfo = \"failed to create raw_data dir and files\";\n\t\t\tent = NULL;\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (!ent->old) {\n\t\t\tstruct dentry *parent;\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *p;\n\t\t\t\tp = aa_deref_parent(ent->new);\n\t\t\t\tparent = prof_child_dir(p);\n\t\t\t} else\n\t\t\t\tparent = ns_subprofs_dir(ent->new->ns);\n\t\t\terror = __aafs_profile_mkdir(ent->new, parent);\n\t\t}\n\n\t\tif (error) {\n\t\t\tinfo = \"failed to create\";\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\n\t \n\t__aa_bump_ns_revision(ns);\n\tif (aa_g_export_binary)\n\t\t__aa_loaddata_update(udata, ns->revision);\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\top = (!ent->old && !ent->rename) ? OP_PROF_LOAD : OP_PROF_REPL;\n\n\t\tif (ent->old && ent->old->rawdata == ent->new->rawdata &&\n\t\t    ent->new->rawdata) {\n\t\t\t \n\t\t\taudit_policy(label, op, ns_name, ent->new->base.hname,\n\t\t\t\t     \"same as current profile, skipping\",\n\t\t\t\t     error);\n\t\t\t \n\t\t\taa_put_proxy(ent->new->label.proxy);\n\t\t\tent->new->label.proxy = NULL;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t \n\t\taudit_policy(label, op, ns_name, ent->new->base.hname, NULL,\n\t\t\t     error);\n\n\t\tif (ent->old) {\n\t\t\tshare_name(ent->old, ent->new);\n\t\t\t__replace_profile(ent->old, ent->new);\n\t\t} else {\n\t\t\tstruct list_head *lh;\n\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *parent;\n\n\t\t\t\tparent = update_to_newest_parent(ent->new);\n\t\t\t\tlh = &parent->base.profiles;\n\t\t\t} else\n\t\t\t\tlh = &ns->base.profiles;\n\t\t\t__add_profile(lh, ent->new);\n\t\t}\n\tskip:\n\t\taa_load_ent_free(ent);\n\t}\n\t__aa_labelset_update_subtree(ns);\n\tmutex_unlock(&ns->lock);\n\nout:\n\taa_put_ns(ns);\n\taa_put_loaddata(udata);\n\tkfree(ns_name);\n\n\tif (error)\n\t\treturn error;\n\treturn udata->size;\n\nfail_lock:\n\tmutex_unlock(&ns->lock);\n\n\t \n\top = (ent && !ent->old) ? OP_PROF_LOAD : OP_PROF_REPL;\nfail:\n\t  audit_policy(label, op, ns_name, ent ? ent->new->base.hname : NULL,\n\t\t       info, error);\n\t \n\tinfo = \"valid profile in failed atomic policy load\";\n\tlist_for_each_entry(tmp, &lh, list) {\n\t\tif (tmp == ent) {\n\t\t\tinfo = \"unchecked profile in failed atomic policy load\";\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\top = (!tmp->old) ? OP_PROF_LOAD : OP_PROF_REPL;\n\t\taudit_policy(label, op, ns_name, tmp->new->base.hname, info,\n\t\t\t     error);\n\t}\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\tgoto out;\n}\n\n \nssize_t aa_remove_profiles(struct aa_ns *policy_ns, struct aa_label *subj,\n\t\t\t   char *fqname, size_t size)\n{\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_profile *profile = NULL;\n\tconst char *name = fqname, *info = NULL;\n\tconst char *ns_name = NULL;\n\tssize_t error = 0;\n\n\tif (*fqname == 0) {\n\t\tinfo = \"no profile specified\";\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tif (fqname[0] == ':') {\n\t\tsize_t ns_len;\n\n\t\tname = aa_splitn_fqname(fqname, size, &ns_name, &ns_len);\n\t\t \n\t\tns = aa_lookupn_ns(policy_ns ? policy_ns : labels_ns(subj),\n\t\t\t\t   ns_name, ns_len);\n\t\tif (!ns) {\n\t\t\tinfo = \"namespace does not exist\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\t \n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(subj));\n\n\tif (!name) {\n\t\t \n\t\tmutex_lock_nested(&ns->parent->lock, ns->parent->level);\n\t\t__aa_bump_ns_revision(ns);\n\t\t__aa_remove_ns(ns);\n\t\tmutex_unlock(&ns->parent->lock);\n\t} else {\n\t\t \n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\tprofile = aa_get_profile(__lookup_profile(&ns->base, name));\n\t\tif (!profile) {\n\t\t\terror = -ENOENT;\n\t\t\tinfo = \"profile does not exist\";\n\t\t\tgoto fail_ns_lock;\n\t\t}\n\t\tname = profile->base.hname;\n\t\t__aa_bump_ns_revision(ns);\n\t\t__remove_profile(profile);\n\t\t__aa_labelset_update_subtree(ns);\n\t\tmutex_unlock(&ns->lock);\n\t}\n\n\t \n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\taa_put_ns(ns);\n\taa_put_profile(profile);\n\treturn size;\n\nfail_ns_lock:\n\tmutex_unlock(&ns->lock);\n\taa_put_ns(ns);\n\nfail:\n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}