{
  "module_name": "path.c",
  "hash_id": "2adf33ddb2ad210816b4d2e94b65590bf250f8bf8865026a9638bcf96608eb74",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/path.c",
  "human_readable_source": "\n \n\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nsproxy.h>\n#include <linux/path.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n\n#include \"include/apparmor.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n\n \nstatic int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}\n\n#define CHROOT_NSCONNECT (PATH_CHROOT_REL | PATH_CHROOT_NSCONNECT)\n\n \nstatic int disconnect(const struct path *path, char *buf, char **name,\n\t\t      int flags, const char *disconnected)\n{\n\tint error = 0;\n\n\tif (!(flags & PATH_CONNECT_PATH) &&\n\t    !(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\n\t      our_mnt(path->mnt))) {\n\t\t \n\t\terror = -EACCES;\n\t\tif (**name == '/')\n\t\t\t*name = *name + 1;\n\t} else {\n\t\tif (**name != '/')\n\t\t\t \n\t\t\terror = prepend(name, *name - buf, \"/\", 1);\n\t\tif (!error && disconnected)\n\t\t\terror = prepend(name, *name - buf, disconnected,\n\t\t\t\t\tstrlen(disconnected));\n\t}\n\n\treturn error;\n}\n\n \nstatic int d_namespace_path(const struct path *path, char *buf, char **name,\n\t\t\t    int flags, const char *disconnected)\n{\n\tchar *res;\n\tint error = 0;\n\tint connected = 1;\n\tint isdir = (flags & PATH_IS_DIR) ? 1 : 0;\n\tint buflen = aa_g_path_max - isdir;\n\n\tif (path->mnt->mnt_flags & MNT_INTERNAL) {\n\t\t \n\t\tres = dentry_path(path->dentry, buf, buflen);\n\t\t*name = res;\n\t\tif (IS_ERR(res)) {\n\t\t\t*name = buf;\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\n\t\t    strncmp(*name, \"/sys/\", 5) == 0) {\n\t\t\t \n\t\t\terror = prepend(name, *name - buf, \"/proc\", 5);\n\t\t\tgoto out;\n\t\t} else\n\t\t\terror = disconnect(path, buf, name, flags,\n\t\t\t\t\t   disconnected);\n\t\tgoto out;\n\t}\n\n\t \n\tif (flags & PATH_CHROOT_REL) {\n\t\tstruct path root;\n\t\tget_fs_root(current->fs, &root);\n\t\tres = __d_path(path, &root, buf, buflen);\n\t\tpath_put(&root);\n\t} else {\n\t\tres = d_absolute_path(path, buf, buflen);\n\t\tif (!our_mnt(path->mnt))\n\t\t\tconnected = 0;\n\t}\n\n\t \n\tif (!res || IS_ERR(res)) {\n\t\tif (PTR_ERR(res) == -ENAMETOOLONG) {\n\t\t\terror = -ENAMETOOLONG;\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t\tconnected = 0;\n\t\tres = dentry_path_raw(path->dentry, buf, buflen);\n\t\tif (IS_ERR(res)) {\n\t\t\terror = PTR_ERR(res);\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t} else if (!our_mnt(path->mnt))\n\t\tconnected = 0;\n\n\t*name = res;\n\n\tif (!connected)\n\t\terror = disconnect(path, buf, name, flags, disconnected);\n\n\t \n\tif (d_unlinked(path->dentry) && d_is_positive(path->dentry) &&\n\t    !(flags & (PATH_MEDIATE_DELETED | PATH_DELEGATE_DELETED))) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t}\n\nout:\n\t \n\tif (!error && isdir && ((*name)[1] != '\\0' || (*name)[0] != '/'))\n\t\tstrcpy(&buf[aa_g_path_max - 2], \"/\");\n\n\treturn error;\n}\n\n \nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}