{
  "module_name": "audit.c",
  "hash_id": "c616eb783f834348c3e2aaac33aac8c38050376897867cc2e6d194ebab1e3b7c",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/audit.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/socket.h>\n\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/policy_ns.h\"\n#include \"include/secid.h\"\n\nconst char *const audit_mode_names[] = {\n\t\"normal\",\n\t\"quiet_denied\",\n\t\"quiet\",\n\t\"noquiet\",\n\t\"all\"\n};\n\nstatic const char *const aa_audit_type[] = {\n\t\"AUDIT\",\n\t\"ALLOWED\",\n\t\"DENIED\",\n\t\"HINT\",\n\t\"STATUS\",\n\t\"ERROR\",\n\t\"KILLED\",\n\t\"AUTO\"\n};\n\nstatic const char *const aa_class_names[] = {\n\t\"none\",\n\t\"unknown\",\n\t\"file\",\n\t\"cap\",\n\t\"net\",\n\t\"rlimits\",\n\t\"domain\",\n\t\"mount\",\n\t\"unknown\",\n\t\"ptrace\",\n\t\"signal\",\n\t\"xmatch\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"net\",\n\t\"unknown\",\n\t\"label\",\n\t\"posix_mqueue\",\n\t\"io_uring\",\n\t\"module\",\n\t\"lsm\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"X\",\n\t\"dbus\",\n};\n\n\n \n\n \nstatic void audit_pre(struct audit_buffer *ab, void *va)\n{\n\tstruct apparmor_audit_data *ad = aad_of_va(va);\n\n\tif (aa_g_audit_header) {\n\t\taudit_log_format(ab, \"apparmor=\\\"%s\\\"\",\n\t\t\t\t aa_audit_type[ad->type]);\n\t}\n\n\tif (ad->op)\n\t\taudit_log_format(ab, \" operation=\\\"%s\\\"\", ad->op);\n\n\tif (ad->class)\n\t\taudit_log_format(ab, \" class=\\\"%s\\\"\",\n\t\t\t\t ad->class <= AA_CLASS_LAST ?\n\t\t\t\t aa_class_names[ad->class] :\n\t\t\t\t \"unknown\");\n\n\tif (ad->info) {\n\t\taudit_log_format(ab, \" info=\\\"%s\\\"\", ad->info);\n\t\tif (ad->error)\n\t\t\taudit_log_format(ab, \" error=%d\", ad->error);\n\t}\n\n\tif (ad->subj_label) {\n\t\tstruct aa_label *label = ad->subj_label;\n\n\t\tif (label_isprofile(label)) {\n\t\t\tstruct aa_profile *profile = labels_profile(label);\n\n\t\t\tif (profile->ns != root_ns) {\n\t\t\t\taudit_log_format(ab, \" namespace=\");\n\t\t\t\taudit_log_untrustedstring(ab,\n\t\t\t\t\t\t       profile->ns->base.hname);\n\t\t\t}\n\t\t\taudit_log_format(ab, \" profile=\");\n\t\t\taudit_log_untrustedstring(ab, profile->base.hname);\n\t\t} else {\n\t\t\taudit_log_format(ab, \" label=\");\n\t\t\taa_label_xaudit(ab, root_ns, label, FLAG_VIEW_SUBNS,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t}\n\t}\n\n\tif (ad->name) {\n\t\taudit_log_format(ab, \" name=\");\n\t\taudit_log_untrustedstring(ab, ad->name);\n\t}\n}\n\n \nvoid aa_audit_msg(int type, struct apparmor_audit_data *ad,\n\t\t  void (*cb) (struct audit_buffer *, void *))\n{\n\tad->type = type;\n\tcommon_lsm_audit(&ad->common, audit_pre, cb);\n}\n\n \nint aa_audit(int type, struct aa_profile *profile,\n\t     struct apparmor_audit_data *ad,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!ad->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET_DENIED))\n\t\treturn ad->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\tad->subj_label = &profile->label;\n\n\taa_audit_msg(type, ad, cb);\n\n\tif (ad->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tad->common.type == LSM_AUDIT_DATA_TASK &&\n\t\t\tad->common.u.tsk ? ad->common.u.tsk : current);\n\n\tif (ad->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(ad->error);\n\n\treturn ad->error;\n}\n\nstruct aa_audit_rule {\n\tstruct aa_label *label;\n};\n\nvoid aa_audit_rule_free(void *vrule)\n{\n\tstruct aa_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tif (!IS_ERR(rule->label))\n\t\t\taa_put_label(rule->label);\n\t\tkfree(rule);\n\t}\n}\n\nint aa_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct aa_audit_rule *rule;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_ROLE:\n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trule = kzalloc(sizeof(struct aa_audit_rule), GFP_KERNEL);\n\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\t \n\trule->label = aa_label_parse(&root_ns->unconfined->label, rulestr,\n\t\t\t\t     GFP_KERNEL, true, false);\n\tif (IS_ERR(rule->label)) {\n\t\tint err = PTR_ERR(rule->label);\n\t\taa_audit_rule_free(rule);\n\t\treturn err;\n\t}\n\n\t*vrule = rule;\n\treturn 0;\n}\n\nint aa_audit_rule_known(struct audit_krule *rule)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint aa_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule)\n{\n\tstruct aa_audit_rule *rule = vrule;\n\tstruct aa_label *label;\n\tint found = 0;\n\n\tlabel = aa_secid_to_label(sid);\n\n\tif (!label)\n\t\treturn -ENOENT;\n\n\tif (aa_label_is_subset(label, rule->label))\n\t\tfound = 1;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\treturn found;\n\t\tcase Audit_not_equal:\n\t\t\treturn !found;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}