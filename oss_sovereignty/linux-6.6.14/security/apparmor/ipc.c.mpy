{
  "module_name": "ipc.c",
  "hash_id": "86c8c07c302f78056548d5300ff7bc9276244238040fad5283b9c0346ecccd07",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/ipc.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/cred.h\"\n#include \"include/policy.h\"\n#include \"include/ipc.h\"\n#include \"include/sig_names.h\"\n\n\nstatic inline int map_signal_num(int sig)\n{\n\tif (sig > SIGRTMAX)\n\t\treturn SIGUNKNOWN;\n\telse if (sig >= SIGRTMIN)\n\t\treturn sig - SIGRTMIN + SIGRT_BASE;\n\telse if (sig < MAXMAPPED_SIG)\n\t\treturn sig_map[sig];\n\treturn SIGUNKNOWN;\n}\n\n \nstatic const char *audit_signal_mask(u32 mask)\n{\n\tif (mask & MAY_READ)\n\t\treturn \"receive\";\n\tif (mask & MAY_WRITE)\n\t\treturn \"send\";\n\treturn \"\";\n}\n\n \nstatic void audit_signal_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tstruct apparmor_audit_data *ad = aad(sa);\n\n\tif (ad->request & AA_SIGNAL_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\\\"%s\\\"\",\n\t\t\t\t audit_signal_mask(ad->request));\n\t\tif (ad->denied & AA_SIGNAL_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\\\"%s\\\"\",\n\t\t\t\t\t audit_signal_mask(ad->denied));\n\t\t}\n\t}\n\tif (ad->signal == SIGUNKNOWN)\n\t\taudit_log_format(ab, \"signal=unknown(%d)\",\n\t\t\t\t ad->unmappedsig);\n\telse if (ad->signal < MAXMAPPED_SIGNAME)\n\t\taudit_log_format(ab, \" signal=%s\", sig_names[ad->signal]);\n\telse\n\t\taudit_log_format(ab, \" signal=rtmin+%d\",\n\t\t\t\t ad->signal - SIGRT_BASE);\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}\n\nstatic int profile_signal_perm(const struct cred *cred,\n\t\t\t       struct aa_profile *profile,\n\t\t\t       struct aa_label *peer, u32 request,\n\t\t\t       struct apparmor_audit_data *ad)\n{\n\tstruct aa_ruleset *rules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t    typeof(*rules), list);\n\tstruct aa_perms perms;\n\taa_state_t state;\n\n\tif (profile_unconfined(profile) ||\n\t    !ANY_RULE_MEDIATES(&profile->rules, AA_CLASS_SIGNAL))\n\t\treturn 0;\n\n\tad->subj_cred = cred;\n\tad->peer = peer;\n\t \n\tstate = aa_dfa_next(rules->policy.dfa,\n\t\t\t    rules->policy.start[AA_CLASS_SIGNAL],\n\t\t\t    ad->signal);\n\taa_label_match(profile, rules, peer, state, false, request, &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, ad, audit_signal_cb);\n}\n\nint aa_may_signal(const struct cred *subj_cred, struct aa_label *sender,\n\t\t  const struct cred *target_cred, struct aa_label *target,\n\t\t  int sig)\n{\n\tstruct aa_profile *profile;\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_SIGNAL, OP_SIGNAL);\n\n\tad.signal = map_signal_num(sig);\n\tad.unmappedsig = sig;\n\treturn xcheck_labels(sender, target, profile,\n\t\t\t     profile_signal_perm(subj_cred, profile, target,\n\t\t\t\t\t\t MAY_WRITE, &ad),\n\t\t\t     profile_signal_perm(target_cred, profile, sender,\n\t\t\t\t\t\t MAY_READ, &ad));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}