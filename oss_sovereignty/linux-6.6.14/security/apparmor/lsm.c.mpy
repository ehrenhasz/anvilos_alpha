{
  "module_name": "lsm.c",
  "hash_id": "346efc0665882ab5287fd8387a3a5c3da9da6f02c61aa12cc3320ffff1a09fe7",
  "original_prompt": "Ingested from linux-6.6.14/security/apparmor/lsm.c",
  "human_readable_source": "\n \n\n#include <linux/lsm_hooks.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/audit.h>\n#include <linux/user_namespace.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/zstd.h>\n#include <net/sock.h>\n#include <uapi/linux/mount.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/cred.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/net.h\"\n#include \"include/path.h\"\n#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/policy_ns.h\"\n#include \"include/procattr.h\"\n#include \"include/mount.h\"\n#include \"include/secid.h\"\n\n \nint apparmor_initialized;\n\nunion aa_buffer {\n\tstruct list_head list;\n\tDECLARE_FLEX_ARRAY(char, buffer);\n};\n\n#define RESERVE_COUNT 2\nstatic int reserve_count = RESERVE_COUNT;\nstatic int buffer_count;\n\nstatic LIST_HEAD(aa_global_buffers);\nstatic DEFINE_SPINLOCK(aa_buffers_lock);\n\n \n\n \nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_put_label(cred_label(cred));\n\tset_cred_label(cred, NULL);\n}\n\n \nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\tset_cred_label(cred, NULL);\n\treturn 0;\n}\n\n \nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\tset_cred_label(new, aa_get_newest_label(cred_label(old)));\n\treturn 0;\n}\n\n \nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tset_cred_label(new, aa_get_newest_label(cred_label(old)));\n}\n\nstatic void apparmor_task_free(struct task_struct *task)\n{\n\n\taa_free_task_ctx(task_ctx(task));\n}\n\nstatic int apparmor_task_alloc(struct task_struct *task,\n\t\t\t       unsigned long clone_flags)\n{\n\tstruct aa_task_ctx *new = task_ctx(task);\n\n\taa_dup_task_ctx(new, task_ctx(current));\n\n\treturn 0;\n}\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct aa_label *tracer, *tracee;\n\tconst struct cred *cred;\n\tint error;\n\n\tcred = get_task_cred(child);\n\ttracee = cred_label(cred);\t \n\ttracer = __begin_current_label_crit_section();\n\terror = aa_may_ptrace(current_cred(), tracer, cred, tracee,\n\t\t\t(mode & PTRACE_MODE_READ) ? AA_PTRACE_READ\n\t\t\t\t\t\t  : AA_PTRACE_TRACE);\n\t__end_current_label_crit_section(tracer);\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\tstruct aa_label *tracer, *tracee;\n\tconst struct cred *cred;\n\tint error;\n\n\ttracee = __begin_current_label_crit_section();\n\tcred = get_task_cred(parent);\n\ttracer = cred_label(cred);\t \n\terror = aa_may_ptrace(cred, tracer, current_cred(), tracee,\n\t\t\t      AA_PTRACE_TRACE);\n\tput_cred(cred);\n\t__end_current_label_crit_section(tracee);\n\n\treturn error;\n}\n\n \nstatic int apparmor_capget(const struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_label *label;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tlabel = aa_get_newest_cred_label(cred);\n\n\t \n\tif (!unconfined(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each_confined(i, label, profile) {\n\t\t\tstruct aa_ruleset *rules;\n\t\t\tif (COMPLAIN_MODE(profile))\n\t\t\t\tcontinue;\n\t\t\trules = list_first_entry(&profile->rules,\n\t\t\t\t\t\t typeof(*rules), list);\n\t\t\t*effective = cap_intersect(*effective,\n\t\t\t\t\t\t   rules->caps.allow);\n\t\t\t*permitted = cap_intersect(*permitted,\n\t\t\t\t\t\t   rules->caps.allow);\n\t\t}\n\t}\n\trcu_read_unlock();\n\taa_put_label(label);\n\n\treturn 0;\n}\n\nstatic int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t    int cap, unsigned int opts)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_newest_cred_label(cred);\n\tif (!unconfined(label))\n\t\terror = aa_capable(cred, label, cap, opts);\n\taa_put_label(label);\n\n\treturn error;\n}\n\n \nstatic int common_perm(const char *op, const struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_perm(op, current_cred(), label, path, 0, mask,\n\t\t\t\t     cond);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\n \nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(mnt_idmap(path->mnt),\n\t\t\t\t\t    d_backing_inode(path->dentry));\n\tstruct path_cond cond = {\n\t\tvfsuid_into_kuid(vfsuid),\n\t\td_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}\n\n \nstatic int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}\n\n \nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\tvfsuid_t vfsuid;\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tvfsuid = i_uid_into_vfsuid(mnt_idmap(dir->mnt), inode);\n\tcond.uid = vfsuid_into_kuid(vfsuid);\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\n \nstatic int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\nstatic int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}\n\nstatic int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}\n\nstatic int apparmor_path_truncate(const struct path *path)\n{\n\treturn common_perm_cond(OP_TRUNC, path, MAY_WRITE | AA_MAY_SETATTR);\n}\n\nstatic int apparmor_file_truncate(struct file *file)\n{\n\treturn apparmor_path_truncate(&file->f_path);\n}\n\nstatic int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}\n\nstatic int apparmor_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_link(current_cred(), label, old_dentry, new_dir,\n\t\t\t\t     new_dentry);\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tconst struct path *new_dir, struct dentry *new_dentry,\n\t\t\t\tconst unsigned int flags)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\tif ((flags & RENAME_EXCHANGE) && !path_mediated_fs(new_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tstruct mnt_idmap *idmap = mnt_idmap(old_dir->mnt);\n\t\tvfsuid_t vfsuid;\n\t\tstruct path old_path = { .mnt = old_dir->mnt,\n\t\t\t\t\t .dentry = old_dentry };\n\t\tstruct path new_path = { .mnt = new_dir->mnt,\n\t\t\t\t\t .dentry = new_dentry };\n\t\tstruct path_cond cond = {\n\t\t\t.mode = d_backing_inode(old_dentry)->i_mode\n\t\t};\n\t\tvfsuid = i_uid_into_vfsuid(idmap, d_backing_inode(old_dentry));\n\t\tcond.uid = vfsuid_into_kuid(vfsuid);\n\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tstruct path_cond cond_exchange = {\n\t\t\t\t.mode = d_backing_inode(new_dentry)->i_mode,\n\t\t\t};\n\t\t\tvfsuid = i_uid_into_vfsuid(idmap, d_backing_inode(old_dentry));\n\t\t\tcond_exchange.uid = vfsuid_into_kuid(vfsuid);\n\n\t\t\terror = aa_path_perm(OP_RENAME_SRC, current_cred(),\n\t\t\t\t\t     label, &new_path, 0,\n\t\t\t\t\t     MAY_READ | AA_MAY_GETATTR | MAY_WRITE |\n\t\t\t\t\t     AA_MAY_SETATTR | AA_MAY_DELETE,\n\t\t\t\t\t     &cond_exchange);\n\t\t\tif (!error)\n\t\t\t\terror = aa_path_perm(OP_RENAME_DEST, current_cred(),\n\t\t\t\t\t\t     label, &old_path,\n\t\t\t\t\t\t     0, MAY_WRITE | AA_MAY_SETATTR |\n\t\t\t\t\t\t     AA_MAY_CREATE, &cond_exchange);\n\t\t}\n\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_SRC, current_cred(),\n\t\t\t\t\t     label, &old_path, 0,\n\t\t\t\t\t     MAY_READ | AA_MAY_GETATTR | MAY_WRITE |\n\t\t\t\t\t     AA_MAY_SETATTR | AA_MAY_DELETE,\n\t\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, current_cred(),\n\t\t\t\t\t     label, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_SETATTR |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn common_perm_cond(OP_CHMOD, path, AA_MAY_CHMOD);\n}\n\nstatic int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_cond(OP_CHOWN, path, AA_MAY_CHOWN);\n}\n\nstatic int apparmor_inode_getattr(const struct path *path)\n{\n\treturn common_perm_cond(OP_GETATTR, path, AA_MAY_GETATTR);\n}\n\nstatic int apparmor_file_open(struct file *file)\n{\n\tstruct aa_file_ctx *fctx = file_ctx(file);\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(file->f_path.dentry))\n\t\treturn 0;\n\n\t \n\tif (current->in_execve) {\n\t\tfctx->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tlabel = aa_get_newest_cred_label(file->f_cred);\n\tif (!unconfined(label)) {\n\t\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\t\tstruct inode *inode = file_inode(file);\n\t\tvfsuid_t vfsuid;\n\t\tstruct path_cond cond = {\n\t\t\t.mode = inode->i_mode,\n\t\t};\n\t\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\t\tcond.uid = vfsuid_into_kuid(vfsuid);\n\n\t\terror = aa_path_perm(OP_OPEN, file->f_cred,\n\t\t\t\t     label, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t \n\t\tfctx->allow = aa_map_file_to_perms(file);\n\t}\n\taa_put_label(label);\n\n\treturn error;\n}\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\tstruct aa_file_ctx *ctx = file_ctx(file);\n\tstruct aa_label *label = begin_current_label_crit_section();\n\n\tspin_lock_init(&ctx->lock);\n\trcu_assign_pointer(ctx->label, aa_get_label(label));\n\tend_current_label_crit_section(label);\n\treturn 0;\n}\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\tstruct aa_file_ctx *ctx = file_ctx(file);\n\n\tif (ctx)\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n}\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask,\n\t\t\t    bool in_atomic)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t \n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, current_cred(), label, file, mask, in_atomic);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_file_receive(struct file *file)\n{\n\treturn common_file_perm(OP_FRECEIVE, file, aa_map_file_to_perms(file),\n\t\t\t\tfalse);\n}\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask, false);\n}\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask, false);\n}\n\nstatic int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags, bool in_atomic)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t \n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask, in_atomic);\n}\n\nstatic int apparmor_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags)\n{\n\treturn common_mmap(OP_FMMAP, file, prot, flags, GFP_ATOMIC);\n}\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0,\n\t\t\t   false);\n}\n\nstatic int apparmor_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t     const char *type, unsigned long flags, void *data)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t \n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\tflags &= ~AA_MS_IGNORE_MASK;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tif (flags & MS_REMOUNT)\n\t\t\terror = aa_remount(current_cred(), label, path, flags,\n\t\t\t\t\t   data);\n\t\telse if (flags & MS_BIND)\n\t\t\terror = aa_bind_mount(current_cred(), label, path,\n\t\t\t\t\t      dev_name, flags);\n\t\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t\t\t  MS_UNBINDABLE))\n\t\t\terror = aa_mount_change_type(current_cred(), label,\n\t\t\t\t\t\t     path, flags);\n\t\telse if (flags & MS_MOVE)\n\t\t\terror = aa_move_mount_old(current_cred(), label, path,\n\t\t\t\t\t\t  dev_name);\n\t\telse\n\t\t\terror = aa_new_mount(current_cred(), label, dev_name,\n\t\t\t\t\t     path, type, flags, data);\n\t}\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_move_mount(const struct path *from_path,\n\t\t\t       const struct path *to_path)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_move_mount(current_cred(), label, from_path,\n\t\t\t\t      to_path);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_umount(current_cred(), label, mnt, flags);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_sb_pivotroot(const struct path *old_path,\n\t\t\t\t const struct path *new_path)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_current_label();\n\tif (!unconfined(label))\n\t\terror = aa_pivotroot(current_cred(), label, old_path, new_path);\n\taa_put_label(label);\n\n\treturn error;\n}\n\nstatic int apparmor_getprocattr(struct task_struct *task, const char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\t \n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_ctx *ctx = task_ctx(current);\n\tstruct aa_label *label = NULL;\n\n\tif (strcmp(name, \"current\") == 0)\n\t\tlabel = aa_get_newest_label(cred_label(cred));\n\telse if (strcmp(name, \"prev\") == 0  && ctx->previous)\n\t\tlabel = aa_get_newest_label(ctx->previous);\n\telse if (strcmp(name, \"exec\") == 0 && ctx->onexec)\n\t\tlabel = aa_get_newest_label(ctx->onexec);\n\telse\n\t\terror = -EINVAL;\n\n\tif (label)\n\t\terror = aa_getprocattr(label, value);\n\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_setprocattr(const char *name, void *value,\n\t\t\t\tsize_t size)\n{\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_NONE,\n\t\t\t  OP_SETPROCATTR);\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (args[size - 1] != '\\0') {\n\t\t \n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (largs ? largs : (char *) value));\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"stack\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_STACK);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_change_profile(args, AA_CHANGE_ONEXEC);\n\t\telse if (strcmp(command, \"stack\") == 0)\n\t\t\terror = aa_change_profile(args, (AA_CHANGE_ONEXEC |\n\t\t\t\t\t\t\t AA_CHANGE_STACK));\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t \n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tad.subj_label = begin_current_label_crit_section();\n\tad.info = name;\n\tad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &ad, NULL);\n\tend_current_label_crit_section(ad.subj_label);\n\tgoto out;\n}\n\n \nstatic void apparmor_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\tstruct aa_label *new_label = cred_label(bprm->cred);\n\n\t \n\tif ((new_label->proxy == label->proxy) ||\n\t    (unconfined(new_label)))\n\t\treturn;\n\n\taa_inherit_files(bprm->cred, current->files);\n\n\tcurrent->pdeath_signal = 0;\n\n\t \n\t__aa_transition_rlimits(label, new_label);\n}\n\n \nstatic void apparmor_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\t \n\taa_clear_task_ctx_trans(task_ctx(current));\n\n\treturn;\n}\n\nstatic void apparmor_current_getsecid_subj(u32 *secid)\n{\n\tstruct aa_label *label = aa_get_current_label();\n\t*secid = label->secid;\n\taa_put_label(label);\n}\n\nstatic void apparmor_task_getsecid_obj(struct task_struct *p, u32 *secid)\n{\n\tstruct aa_label *label = aa_get_task_label(p);\n\t*secid = label->secid;\n\taa_put_label(label);\n}\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_label *label = __begin_current_label_crit_section();\n\tint error = 0;\n\n\tif (!unconfined(label))\n\t\terror = aa_task_setrlimit(current_cred(), label, task,\n\t\t\t\t\t  resource, new_rlim);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}\n\nstatic int apparmor_task_kill(struct task_struct *target, struct kernel_siginfo *info,\n\t\t\t      int sig, const struct cred *cred)\n{\n\tconst struct cred *tc;\n\tstruct aa_label *cl, *tl;\n\tint error;\n\n\ttc = get_task_cred(target);\n\ttl = aa_get_newest_cred_label(tc);\n\tif (cred) {\n\t\t \n\t\tcl = aa_get_newest_cred_label(cred);\n\t\terror = aa_may_signal(cred, cl, tc, tl, sig);\n\t\taa_put_label(cl);\n\t} else {\n\t\tcl = __begin_current_label_crit_section();\n\t\terror = aa_may_signal(current_cred(), cl, tc, tl, sig);\n\t\t__end_current_label_crit_section(cl);\n\t}\n\taa_put_label(tl);\n\tput_cred(tc);\n\n\treturn error;\n}\n\n \nstatic int apparmor_sk_alloc_security(struct sock *sk, int family, gfp_t flags)\n{\n\tstruct aa_sk_ctx *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), flags);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tSK_CTX(sk) = ctx;\n\n\treturn 0;\n}\n\n \nstatic void apparmor_sk_free_security(struct sock *sk)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\n\tSK_CTX(sk) = NULL;\n\taa_put_label(ctx->label);\n\taa_put_label(ctx->peer);\n\tkfree(ctx);\n}\n\n \nstatic void apparmor_sk_clone_security(const struct sock *sk,\n\t\t\t\t       struct sock *newsk)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\tstruct aa_sk_ctx *new = SK_CTX(newsk);\n\n\tif (new->label)\n\t\taa_put_label(new->label);\n\tnew->label = aa_get_label(ctx->label);\n\n\tif (new->peer)\n\t\taa_put_label(new->peer);\n\tnew->peer = aa_get_label(ctx->peer);\n}\n\n \nstatic int apparmor_socket_create(int family, int type, int protocol, int kern)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tAA_BUG(in_interrupt());\n\n\tlabel = begin_current_label_crit_section();\n\tif (!(kern || unconfined(label)))\n\t\terror = af_select(family,\n\t\t\t\t  create_perm(label, family, type, protocol),\n\t\t\t\t  aa_af_perm(current_cred(), label,\n\t\t\t\t\t     OP_CREATE, AA_MAY_CREATE,\n\t\t\t\t\t     family, type, protocol));\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}\n\n \nstatic int apparmor_socket_post_create(struct socket *sock, int family,\n\t\t\t\t       int type, int protocol, int kern)\n{\n\tstruct aa_label *label;\n\n\tif (kern) {\n\t\tlabel = aa_get_label(kernel_t);\n\t} else\n\t\tlabel = aa_get_current_label();\n\n\tif (sock->sk) {\n\t\tstruct aa_sk_ctx *ctx = SK_CTX(sock->sk);\n\n\t\taa_put_label(ctx->label);\n\t\tctx->label = aa_get_label(label);\n\t}\n\taa_put_label(label);\n\n\treturn 0;\n}\n\n \nstatic int apparmor_socket_bind(struct socket *sock,\n\t\t\t\tstruct sockaddr *address, int addrlen)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(!address);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t bind_perm(sock, address, addrlen),\n\t\t\t aa_sk_perm(OP_BIND, AA_MAY_BIND, sock->sk));\n}\n\n \nstatic int apparmor_socket_connect(struct socket *sock,\n\t\t\t\t   struct sockaddr *address, int addrlen)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(!address);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t connect_perm(sock, address, addrlen),\n\t\t\t aa_sk_perm(OP_CONNECT, AA_MAY_CONNECT, sock->sk));\n}\n\n \nstatic int apparmor_socket_listen(struct socket *sock, int backlog)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t listen_perm(sock, backlog),\n\t\t\t aa_sk_perm(OP_LISTEN, AA_MAY_LISTEN, sock->sk));\n}\n\n \nstatic int apparmor_socket_accept(struct socket *sock, struct socket *newsock)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(!newsock);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t accept_perm(sock, newsock),\n\t\t\t aa_sk_perm(OP_ACCEPT, AA_MAY_ACCEPT, sock->sk));\n}\n\nstatic int aa_sock_msg_perm(const char *op, u32 request, struct socket *sock,\n\t\t\t    struct msghdr *msg, int size)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(!msg);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t msg_perm(op, request, sock, msg, size),\n\t\t\t aa_sk_perm(op, request, sock->sk));\n}\n\n \nstatic int apparmor_socket_sendmsg(struct socket *sock,\n\t\t\t\t   struct msghdr *msg, int size)\n{\n\treturn aa_sock_msg_perm(OP_SENDMSG, AA_MAY_SEND, sock, msg, size);\n}\n\n \nstatic int apparmor_socket_recvmsg(struct socket *sock,\n\t\t\t\t   struct msghdr *msg, int size, int flags)\n{\n\treturn aa_sock_msg_perm(OP_RECVMSG, AA_MAY_RECEIVE, sock, msg, size);\n}\n\n \nstatic int aa_sock_perm(const char *op, u32 request, struct socket *sock)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t sock_perm(op, request, sock),\n\t\t\t aa_sk_perm(op, request, sock->sk));\n}\n\n \nstatic int apparmor_socket_getsockname(struct socket *sock)\n{\n\treturn aa_sock_perm(OP_GETSOCKNAME, AA_MAY_GETATTR, sock);\n}\n\n \nstatic int apparmor_socket_getpeername(struct socket *sock)\n{\n\treturn aa_sock_perm(OP_GETPEERNAME, AA_MAY_GETATTR, sock);\n}\n\n \nstatic int aa_sock_opt_perm(const char *op, u32 request, struct socket *sock,\n\t\t\t    int level, int optname)\n{\n\tAA_BUG(!sock);\n\tAA_BUG(!sock->sk);\n\tAA_BUG(in_interrupt());\n\n\treturn af_select(sock->sk->sk_family,\n\t\t\t opt_perm(op, request, sock, level, optname),\n\t\t\t aa_sk_perm(op, request, sock->sk));\n}\n\n \nstatic int apparmor_socket_getsockopt(struct socket *sock, int level,\n\t\t\t\t      int optname)\n{\n\treturn aa_sock_opt_perm(OP_GETSOCKOPT, AA_MAY_GETOPT, sock,\n\t\t\t\tlevel, optname);\n}\n\n \nstatic int apparmor_socket_setsockopt(struct socket *sock, int level,\n\t\t\t\t      int optname)\n{\n\treturn aa_sock_opt_perm(OP_SETSOCKOPT, AA_MAY_SETOPT, sock,\n\t\t\t\tlevel, optname);\n}\n\n \nstatic int apparmor_socket_shutdown(struct socket *sock, int how)\n{\n\treturn aa_sock_perm(OP_SHUTDOWN, AA_MAY_SHUTDOWN, sock);\n}\n\n#ifdef CONFIG_NETWORK_SECMARK\n \nstatic int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\n\tif (!skb->secmark)\n\t\treturn 0;\n\n\treturn apparmor_secmark_check(ctx->label, OP_RECVMSG, AA_MAY_RECEIVE,\n\t\t\t\t      skb->secmark, sk);\n}\n#endif\n\n\nstatic struct aa_label *sk_peer_label(struct sock *sk)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\n\tif (ctx->peer)\n\t\treturn ctx->peer;\n\n\treturn ERR_PTR(-ENOPROTOOPT);\n}\n\n \nstatic int apparmor_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t     sockptr_t optval, sockptr_t optlen,\n\t\t\t\t\t     unsigned int len)\n{\n\tchar *name = NULL;\n\tint slen, error = 0;\n\tstruct aa_label *label;\n\tstruct aa_label *peer;\n\n\tlabel = begin_current_label_crit_section();\n\tpeer = sk_peer_label(sock->sk);\n\tif (IS_ERR(peer)) {\n\t\terror = PTR_ERR(peer);\n\t\tgoto done;\n\t}\n\tslen = aa_label_asxprint(&name, labels_ns(label), peer,\n\t\t\t\t FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\t FLAG_HIDDEN_UNCONFINED, GFP_KERNEL);\n\t \n\tif (slen < 0) {\n\t\terror = -ENOMEM;\n\t\tgoto done;\n\t}\n\tif (slen > len) {\n\t\terror = -ERANGE;\n\t\tgoto done_len;\n\t}\n\n\tif (copy_to_sockptr(optval, name, slen))\n\t\terror = -EFAULT;\ndone_len:\n\tif (copy_to_sockptr(optlen, &slen, sizeof(slen)))\n\t\terror = -EFAULT;\ndone:\n\tend_current_label_crit_section(label);\n\tkfree(name);\n\treturn error;\n}\n\n \nstatic int apparmor_socket_getpeersec_dgram(struct socket *sock,\n\t\t\t\t\t    struct sk_buff *skb, u32 *secid)\n\n{\n\t \n\treturn -ENOPROTOOPT;\n}\n\n \nstatic void apparmor_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\n\tif (!ctx->label)\n\t\tctx->label = aa_get_current_label();\n}\n\n#ifdef CONFIG_NETWORK_SECMARK\nstatic int apparmor_inet_conn_request(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req)\n{\n\tstruct aa_sk_ctx *ctx = SK_CTX(sk);\n\n\tif (!skb->secmark)\n\t\treturn 0;\n\n\treturn apparmor_secmark_check(ctx->label, OP_CONNECT, AA_MAY_CONNECT,\n\t\t\t\t      skb->secmark, sk);\n}\n#endif\n\n \nstruct lsm_blob_sizes apparmor_blob_sizes __ro_after_init = {\n\t.lbs_cred = sizeof(struct aa_label *),\n\t.lbs_file = sizeof(struct aa_file_ctx),\n\t.lbs_task = sizeof(struct aa_task_ctx),\n};\n\nstatic struct security_hook_list apparmor_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, apparmor_capget),\n\tLSM_HOOK_INIT(capable, apparmor_capable),\n\n\tLSM_HOOK_INIT(move_mount, apparmor_move_mount),\n\tLSM_HOOK_INIT(sb_mount, apparmor_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, apparmor_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, apparmor_sb_pivotroot),\n\n\tLSM_HOOK_INIT(path_link, apparmor_path_link),\n\tLSM_HOOK_INIT(path_unlink, apparmor_path_unlink),\n\tLSM_HOOK_INIT(path_symlink, apparmor_path_symlink),\n\tLSM_HOOK_INIT(path_mkdir, apparmor_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, apparmor_path_rmdir),\n\tLSM_HOOK_INIT(path_mknod, apparmor_path_mknod),\n\tLSM_HOOK_INIT(path_rename, apparmor_path_rename),\n\tLSM_HOOK_INIT(path_chmod, apparmor_path_chmod),\n\tLSM_HOOK_INIT(path_chown, apparmor_path_chown),\n\tLSM_HOOK_INIT(path_truncate, apparmor_path_truncate),\n\tLSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),\n\n\tLSM_HOOK_INIT(file_open, apparmor_file_open),\n\tLSM_HOOK_INIT(file_receive, apparmor_file_receive),\n\tLSM_HOOK_INIT(file_permission, apparmor_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, apparmor_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, apparmor_file_free_security),\n\tLSM_HOOK_INIT(mmap_file, apparmor_mmap_file),\n\tLSM_HOOK_INIT(file_mprotect, apparmor_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, apparmor_file_lock),\n\tLSM_HOOK_INIT(file_truncate, apparmor_file_truncate),\n\n\tLSM_HOOK_INIT(getprocattr, apparmor_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, apparmor_setprocattr),\n\n\tLSM_HOOK_INIT(sk_alloc_security, apparmor_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, apparmor_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, apparmor_sk_clone_security),\n\n\tLSM_HOOK_INIT(socket_create, apparmor_socket_create),\n\tLSM_HOOK_INIT(socket_post_create, apparmor_socket_post_create),\n\tLSM_HOOK_INIT(socket_bind, apparmor_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, apparmor_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, apparmor_socket_listen),\n\tLSM_HOOK_INIT(socket_accept, apparmor_socket_accept),\n\tLSM_HOOK_INIT(socket_sendmsg, apparmor_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_recvmsg, apparmor_socket_recvmsg),\n\tLSM_HOOK_INIT(socket_getsockname, apparmor_socket_getsockname),\n\tLSM_HOOK_INIT(socket_getpeername, apparmor_socket_getpeername),\n\tLSM_HOOK_INIT(socket_getsockopt, apparmor_socket_getsockopt),\n\tLSM_HOOK_INIT(socket_setsockopt, apparmor_socket_setsockopt),\n\tLSM_HOOK_INIT(socket_shutdown, apparmor_socket_shutdown),\n#ifdef CONFIG_NETWORK_SECMARK\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, apparmor_socket_sock_rcv_skb),\n#endif\n\tLSM_HOOK_INIT(socket_getpeersec_stream,\n\t\t      apparmor_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram,\n\t\t      apparmor_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sock_graft, apparmor_sock_graft),\n#ifdef CONFIG_NETWORK_SECMARK\n\tLSM_HOOK_INIT(inet_conn_request, apparmor_inet_conn_request),\n#endif\n\n\tLSM_HOOK_INIT(cred_alloc_blank, apparmor_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, apparmor_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, apparmor_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, apparmor_cred_transfer),\n\n\tLSM_HOOK_INIT(bprm_creds_for_exec, apparmor_bprm_creds_for_exec),\n\tLSM_HOOK_INIT(bprm_committing_creds, apparmor_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, apparmor_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(task_free, apparmor_task_free),\n\tLSM_HOOK_INIT(task_alloc, apparmor_task_alloc),\n\tLSM_HOOK_INIT(current_getsecid_subj, apparmor_current_getsecid_subj),\n\tLSM_HOOK_INIT(task_getsecid_obj, apparmor_task_getsecid_obj),\n\tLSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),\n\tLSM_HOOK_INIT(task_kill, apparmor_task_kill),\n\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, aa_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, aa_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, aa_audit_rule_match),\n\tLSM_HOOK_INIT(audit_rule_free, aa_audit_rule_free),\n#endif\n\n\tLSM_HOOK_INIT(secid_to_secctx, apparmor_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, apparmor_secctx_to_secid),\n\tLSM_HOOK_INIT(release_secctx, apparmor_release_secctx),\n};\n\n \n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\n#define param_check_aabool param_check_bool\nstatic const struct kernel_param_ops param_ops_aabool = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aabool,\n\t.get = param_get_aabool\n};\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\n#define param_check_aauint param_check_uint\nstatic const struct kernel_param_ops param_ops_aauint = {\n\t.set = param_set_aauint,\n\t.get = param_get_aauint\n};\n\nstatic int param_set_aacompressionlevel(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp);\nstatic int param_get_aacompressionlevel(char *buffer,\n\t\t\t\t\tconst struct kernel_param *kp);\n#define param_check_aacompressionlevel param_check_int\nstatic const struct kernel_param_ops param_ops_aacompressionlevel = {\n\t.set = param_set_aacompressionlevel,\n\t.get = param_get_aacompressionlevel\n};\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\n#define param_check_aalockpolicy param_check_bool\nstatic const struct kernel_param_ops param_ops_aalockpolicy = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aalockpolicy,\n\t.get = param_get_aalockpolicy\n};\n\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\n\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\n\n \n\n \nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nmodule_param_call(mode, param_set_mode, param_get_mode,\n\t\t  &aa_g_profile_mode, S_IRUSR | S_IWUSR);\n\n \nbool aa_g_hash_policy = IS_ENABLED(CONFIG_SECURITY_APPARMOR_HASH_DEFAULT);\n#ifdef CONFIG_SECURITY_APPARMOR_HASH\nmodule_param_named(hash_policy, aa_g_hash_policy, aabool, S_IRUSR | S_IWUSR);\n#endif\n\n \nbool aa_g_export_binary = IS_ENABLED(CONFIG_SECURITY_APPARMOR_EXPORT_BINARY);\n#ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\nmodule_param_named(export_binary, aa_g_export_binary, aabool, 0600);\n#endif\n\n \nint aa_g_rawdata_compression_level = AA_DEFAULT_CLEVEL;\nmodule_param_named(rawdata_compression_level, aa_g_rawdata_compression_level,\n\t\t   aacompressionlevel, 0400);\n\n \nbool aa_g_debug = IS_ENABLED(CONFIG_SECURITY_APPARMOR_DEBUG_MESSAGES);\nmodule_param_named(debug, aa_g_debug, aabool, S_IRUSR | S_IWUSR);\n\n \nenum audit_mode aa_g_audit;\nmodule_param_call(audit, param_set_audit, param_get_audit,\n\t\t  &aa_g_audit, S_IRUSR | S_IWUSR);\n\n \nbool aa_g_audit_header = true;\nmodule_param_named(audit_header, aa_g_audit_header, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n \nbool aa_g_lock_policy;\nmodule_param_named(lock_policy, aa_g_lock_policy, aalockpolicy,\n\t\t   S_IRUSR | S_IWUSR);\n\n \nbool aa_g_logsyscall;\nmodule_param_named(logsyscall, aa_g_logsyscall, aabool, S_IRUSR | S_IWUSR);\n\n \nunsigned int aa_g_path_max = 2 * PATH_MAX;\nmodule_param_named(path_max, aa_g_path_max, aauint, S_IRUSR);\n\n \nbool aa_g_paranoid_load = IS_ENABLED(CONFIG_SECURITY_APPARMOR_PARANOID_LOAD);\nmodule_param_named(paranoid_load, aa_g_paranoid_load, aabool, S_IRUGO);\n\nstatic int param_get_aaintbool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aaintbool(const char *val, const struct kernel_param *kp);\n#define param_check_aaintbool param_check_int\nstatic const struct kernel_param_ops param_ops_aaintbool = {\n\t.set = param_set_aaintbool,\n\t.get = param_get_aaintbool\n};\n \nstatic int apparmor_enabled __ro_after_init = 1;\nmodule_param_named(enabled, apparmor_enabled, aaintbool, 0444);\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n\n__setup(\"apparmor=\", apparmor_enabled_setup);\n\n \nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tint error;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\t \n\tif (apparmor_initialized)\n\t\treturn -EPERM;\n\n\terror = param_set_uint(val, kp);\n\taa_g_path_max = max_t(uint32_t, aa_g_path_max, sizeof(union aa_buffer));\n\tpr_info(\"AppArmor: buffer size set to %d bytes\\n\", aa_g_path_max);\n\n\treturn error;\n}\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n\n \nstatic int param_set_aaintbool(const char *val, const struct kernel_param *kp)\n{\n\tstruct kernel_param kp_local;\n\tbool value;\n\tint error;\n\n\tif (apparmor_initialized)\n\t\treturn -EPERM;\n\n\t \n\tvalue = !!*((int *)kp->arg);\n\tmemcpy(&kp_local, kp, sizeof(kp_local));\n\tkp_local.arg = &value;\n\n\terror = param_set_bool(val, &kp_local);\n\tif (!error)\n\t\t*((int *)kp->arg) = *((bool *)kp_local.arg);\n\treturn error;\n}\n\n \nstatic int param_get_aaintbool(char *buffer, const struct kernel_param *kp)\n{\n\tstruct kernel_param kp_local;\n\tbool value;\n\n\t \n\tvalue = !!*((int *)kp->arg);\n\tmemcpy(&kp_local, kp, sizeof(kp_local));\n\tkp_local.arg = &value;\n\n\treturn param_get_bool(buffer, &kp_local);\n}\n\nstatic int param_set_aacompressionlevel(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tint error;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized)\n\t\treturn -EPERM;\n\n\terror = param_set_int(val, kp);\n\n\taa_g_rawdata_compression_level = clamp(aa_g_rawdata_compression_level,\n\t\t\t\t\t       AA_MIN_CLEVEL, AA_MAX_CLEVEL);\n\tpr_info(\"AppArmor: policy rawdata compression level set to %d\\n\",\n\t\taa_g_rawdata_compression_level);\n\n\treturn error;\n}\n\nstatic int param_get_aacompressionlevel(char *buffer,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_int(buffer, kp);\n}\n\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}\n\nstatic int param_set_audit(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\ti = match_string(audit_mode_names, AUDIT_MAX_INDEX, val);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\taa_g_audit = i;\n\treturn 0;\n}\n\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_view_capable(NULL))\n\t\treturn -EPERM;\n\n\treturn sprintf(buffer, \"%s\", aa_profile_mode_names[aa_g_profile_mode]);\n}\n\nstatic int param_set_mode(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !aa_current_policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\ti = match_string(aa_profile_mode_names, APPARMOR_MODE_NAMES_MAX_INDEX,\n\t\t\t val);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\taa_g_profile_mode = i;\n\treturn 0;\n}\n\nchar *aa_get_buffer(bool in_atomic)\n{\n\tunion aa_buffer *aa_buf;\n\tbool try_again = true;\n\tgfp_t flags = (GFP_KERNEL | __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\nretry:\n\tspin_lock(&aa_buffers_lock);\n\tif (buffer_count > reserve_count ||\n\t    (in_atomic && !list_empty(&aa_global_buffers))) {\n\t\taa_buf = list_first_entry(&aa_global_buffers, union aa_buffer,\n\t\t\t\t\t  list);\n\t\tlist_del(&aa_buf->list);\n\t\tbuffer_count--;\n\t\tspin_unlock(&aa_buffers_lock);\n\t\treturn aa_buf->buffer;\n\t}\n\tif (in_atomic) {\n\t\t \n\t\treserve_count++;\n\t\tflags = GFP_ATOMIC;\n\t}\n\tspin_unlock(&aa_buffers_lock);\n\n\tif (!in_atomic)\n\t\tmight_sleep();\n\taa_buf = kmalloc(aa_g_path_max, flags);\n\tif (!aa_buf) {\n\t\tif (try_again) {\n\t\t\ttry_again = false;\n\t\t\tgoto retry;\n\t\t}\n\t\tpr_warn_once(\"AppArmor: Failed to allocate a memory buffer.\\n\");\n\t\treturn NULL;\n\t}\n\treturn aa_buf->buffer;\n}\n\nvoid aa_put_buffer(char *buf)\n{\n\tunion aa_buffer *aa_buf;\n\n\tif (!buf)\n\t\treturn;\n\taa_buf = container_of(buf, union aa_buffer, buffer[0]);\n\n\tspin_lock(&aa_buffers_lock);\n\tlist_add(&aa_buf->list, &aa_global_buffers);\n\tbuffer_count++;\n\tspin_unlock(&aa_buffers_lock);\n}\n\n \n\n \nstatic int __init set_init_ctx(void)\n{\n\tstruct cred *cred = (__force struct cred *)current->real_cred;\n\n\tset_cred_label(cred, aa_get_label(ns_unconfined(root_ns)));\n\n\treturn 0;\n}\n\nstatic void destroy_buffers(void)\n{\n\tunion aa_buffer *aa_buf;\n\n\tspin_lock(&aa_buffers_lock);\n\twhile (!list_empty(&aa_global_buffers)) {\n\t\taa_buf = list_first_entry(&aa_global_buffers, union aa_buffer,\n\t\t\t\t\t list);\n\t\tlist_del(&aa_buf->list);\n\t\tspin_unlock(&aa_buffers_lock);\n\t\tkfree(aa_buf);\n\t\tspin_lock(&aa_buffers_lock);\n\t}\n\tspin_unlock(&aa_buffers_lock);\n}\n\nstatic int __init alloc_buffers(void)\n{\n\tunion aa_buffer *aa_buf;\n\tint i, num;\n\n\t \n\tif (num_online_cpus() > 1)\n\t\tnum = 4 + RESERVE_COUNT;\n\telse\n\t\tnum = 2 + RESERVE_COUNT;\n\n\tfor (i = 0; i < num; i++) {\n\n\t\taa_buf = kmalloc(aa_g_path_max, GFP_KERNEL |\n\t\t\t\t __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\t\tif (!aa_buf) {\n\t\t\tdestroy_buffers();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\taa_put_buffer(aa_buf->buffer);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SYSCTL\nstatic int apparmor_dointvec(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!aa_current_policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn proc_dointvec(table, write, buffer, lenp, ppos);\n}\n\nstatic struct ctl_table apparmor_sysctl_table[] = {\n\t{\n\t\t.procname       = \"unprivileged_userns_apparmor_policy\",\n\t\t.data           = &unprivileged_userns_apparmor_policy,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0600,\n\t\t.proc_handler   = apparmor_dointvec,\n\t},\n\t{\n\t\t.procname       = \"apparmor_display_secid_mode\",\n\t\t.data           = &apparmor_display_secid_mode,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0600,\n\t\t.proc_handler   = apparmor_dointvec,\n\t},\n\n\t{ }\n};\n\nstatic int __init apparmor_init_sysctl(void)\n{\n\treturn register_sysctl(\"kernel\", apparmor_sysctl_table) ? 0 : -ENOMEM;\n}\n#else\nstatic inline int apparmor_init_sysctl(void)\n{\n\treturn 0;\n}\n#endif  \n\n#if defined(CONFIG_NETFILTER) && defined(CONFIG_NETWORK_SECMARK)\nstatic unsigned int apparmor_ip_postroute(void *priv,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  const struct nf_hook_state *state)\n{\n\tstruct aa_sk_ctx *ctx;\n\tstruct sock *sk;\n\n\tif (!skb->secmark)\n\t\treturn NF_ACCEPT;\n\n\tsk = skb_to_full_sk(skb);\n\tif (sk == NULL)\n\t\treturn NF_ACCEPT;\n\n\tctx = SK_CTX(sk);\n\tif (!apparmor_secmark_check(ctx->label, OP_SENDMSG, AA_MAY_SEND,\n\t\t\t\t    skb->secmark, sk))\n\t\treturn NF_ACCEPT;\n\n\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n}\n\nstatic const struct nf_hook_ops apparmor_nf_ops[] = {\n\t{\n\t\t.hook =         apparmor_ip_postroute,\n\t\t.pf =           NFPROTO_IPV4,\n\t\t.hooknum =      NF_INET_POST_ROUTING,\n\t\t.priority =     NF_IP_PRI_SELINUX_FIRST,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.hook =         apparmor_ip_postroute,\n\t\t.pf =           NFPROTO_IPV6,\n\t\t.hooknum =      NF_INET_POST_ROUTING,\n\t\t.priority =     NF_IP6_PRI_SELINUX_FIRST,\n\t},\n#endif\n};\n\nstatic int __net_init apparmor_nf_register(struct net *net)\n{\n\treturn nf_register_net_hooks(net, apparmor_nf_ops,\n\t\t\t\t    ARRAY_SIZE(apparmor_nf_ops));\n}\n\nstatic void __net_exit apparmor_nf_unregister(struct net *net)\n{\n\tnf_unregister_net_hooks(net, apparmor_nf_ops,\n\t\t\t\tARRAY_SIZE(apparmor_nf_ops));\n}\n\nstatic struct pernet_operations apparmor_net_ops = {\n\t.init = apparmor_nf_register,\n\t.exit = apparmor_nf_unregister,\n};\n\nstatic int __init apparmor_nf_ip_init(void)\n{\n\tint err;\n\n\tif (!apparmor_enabled)\n\t\treturn 0;\n\n\terr = register_pernet_subsys(&apparmor_net_ops);\n\tif (err)\n\t\tpanic(\"Apparmor: register_pernet_subsys: error %d\\n\", err);\n\n\treturn 0;\n}\n__initcall(apparmor_nf_ip_init);\n#endif\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\terror = aa_setup_dfa_engine();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to setup dfa engine\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = apparmor_init_sysctl();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to register sysctls\\n\");\n\t\tgoto alloc_out;\n\n\t}\n\n\terror = alloc_buffers();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate work buffers\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = set_init_ctx();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\taa_free_root_ns();\n\t\tgoto buffers_out;\n\t}\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),\n\t\t\t\t\"apparmor\");\n\n\t \n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nbuffers_out:\n\tdestroy_buffers();\nalloc_out:\n\taa_destroy_aafs();\n\taa_teardown_dfa_engine();\n\n\tapparmor_enabled = false;\n\treturn error;\n}\n\nDEFINE_LSM(apparmor) = {\n\t.name = \"apparmor\",\n\t.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,\n\t.enabled = &apparmor_enabled,\n\t.blobs = &apparmor_blob_sizes,\n\t.init = apparmor_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}