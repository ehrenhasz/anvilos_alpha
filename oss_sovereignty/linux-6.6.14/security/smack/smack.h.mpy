{
  "module_name": "smack.h",
  "hash_id": "635134c231fccd653848d75b90081e8e1075f507662f384da2ee0766c9d5c3e4",
  "original_prompt": "Ingested from linux-6.6.14/security/smack/smack.h",
  "human_readable_source": " \n \n\n#ifndef _SECURITY_SMACK_H\n#define _SECURITY_SMACK_H\n\n#include <linux/capability.h>\n#include <linux/spinlock.h>\n#include <linux/lsm_hooks.h>\n#include <linux/in.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#endif  \n#include <net/netlabel.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/lsm_audit.h>\n#include <linux/msg.h>\n\n \n#if IS_ENABLED(CONFIG_IPV6) && !defined(CONFIG_SECURITY_SMACK_NETFILTER)\n#define SMACK_IPV6_PORT_LABELING 1\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6) && defined(CONFIG_SECURITY_SMACK_NETFILTER)\n#define SMACK_IPV6_SECMARK_LABELING 1\n#endif\n\n \n#define SMK_LABELLEN\t24\n#define SMK_LONGLABEL\t256\n\n \nstruct smack_known {\n\tstruct list_head\t\tlist;\n\tstruct hlist_node\t\tsmk_hashed;\n\tchar\t\t\t\t*smk_known;\n\tu32\t\t\t\tsmk_secid;\n\tstruct netlbl_lsm_secattr\tsmk_netlabel;\t \n\tstruct list_head\t\tsmk_rules;\t \n\tstruct mutex\t\t\tsmk_rules_lock;\t \n};\n\n \n#define SMK_CIPSOLEN\t24\n\nstruct superblock_smack {\n\tstruct smack_known\t*smk_root;\n\tstruct smack_known\t*smk_floor;\n\tstruct smack_known\t*smk_hat;\n\tstruct smack_known\t*smk_default;\n\tint\t\t\tsmk_flags;\n};\n\n \n#define SMK_SB_INITIALIZED\t0x01\n#define SMK_SB_UNTRUSTED\t0x02\n\nstruct socket_smack {\n\tstruct smack_known\t*smk_out;\t \n\tstruct smack_known\t*smk_in;\t \n\tstruct smack_known\t*smk_packet;\t \n\tint\t\t\tsmk_state;\t \n};\n#define\tSMK_NETLBL_UNSET\t0\n#define\tSMK_NETLBL_UNLABELED\t1\n#define\tSMK_NETLBL_LABELED\t2\n#define\tSMK_NETLBL_REQSKB\t3\n\n \nstruct inode_smack {\n\tstruct smack_known\t*smk_inode;\t \n\tstruct smack_known\t*smk_task;\t \n\tstruct smack_known\t*smk_mmap;\t \n\tint\t\t\tsmk_flags;\t \n};\n\nstruct task_smack {\n\tstruct smack_known\t*smk_task;\t \n\tstruct smack_known\t*smk_forked;\t \n\tstruct smack_known\t*smk_transmuted; \n\tstruct list_head\tsmk_rules;\t \n\tstruct mutex\t\tsmk_rules_lock;\t \n\tstruct list_head\tsmk_relabel;\t \n};\n\n#define\tSMK_INODE_INSTANT\t0x01\t \n#define\tSMK_INODE_TRANSMUTE\t0x02\t \n#define\tSMK_INODE_CHANGED\t0x04\t \n#define\tSMK_INODE_IMPURE\t0x08\t \n\n \nstruct smack_rule {\n\tstruct list_head\tlist;\n\tstruct smack_known\t*smk_subject;\n\tstruct smack_known\t*smk_object;\n\tint\t\t\tsmk_access;\n};\n\n \nstruct smk_net4addr {\n\tstruct list_head\tlist;\n\tstruct in_addr\t\tsmk_host;\t \n\tstruct in_addr\t\tsmk_mask;\t \n\tint\t\t\tsmk_masks;\t \n\tstruct smack_known\t*smk_label;\t \n};\n\n \nstruct smk_net6addr {\n\tstruct list_head\tlist;\n\tstruct in6_addr\t\tsmk_host;\t \n\tstruct in6_addr\t\tsmk_mask;\t \n\tint\t\t\tsmk_masks;\t \n\tstruct smack_known\t*smk_label;\t \n};\n\n \nstruct smk_port_label {\n\tstruct list_head\tlist;\n\tstruct sock\t\t*smk_sock;\t \n\tunsigned short\t\tsmk_port;\t \n\tstruct smack_known\t*smk_in;\t \n\tstruct smack_known\t*smk_out;\t \n\tshort\t\t\tsmk_sock_type;\t \n\tshort\t\t\tsmk_can_reuse;\n};\n\nstruct smack_known_list_elem {\n\tstruct list_head\tlist;\n\tstruct smack_known\t*smk_label;\n};\n\nenum {\n\tOpt_error = -1,\n\tOpt_fsdefault = 0,\n\tOpt_fsfloor = 1,\n\tOpt_fshat = 2,\n\tOpt_fsroot = 3,\n\tOpt_fstransmute = 4,\n};\n\n#define SMACK_DELETE_OPTION\t\"-DELETE\"\n#define SMACK_CIPSO_OPTION \t\"-CIPSO\"\n\n \n#define SMACK_CIPSO_DOI_DEFAULT\t\t3\t \n#define SMACK_CIPSO_DOI_INVALID\t\t-1\t \n#define SMACK_CIPSO_DIRECT_DEFAULT\t250\t \n#define SMACK_CIPSO_MAPPED_DEFAULT\t251\t \n#define SMACK_CIPSO_MAXLEVEL            255      \n \n#define SMACK_CIPSO_MAXCATNUM           184      \n\n \n#define SMACK_PTRACE_DEFAULT\t0\n#define SMACK_PTRACE_EXACT\t1\n#define SMACK_PTRACE_DRACONIAN\t2\n#define SMACK_PTRACE_MAX\tSMACK_PTRACE_DRACONIAN\n\n \n#define MAY_TRANSMUTE\t0x00001000\t \n#define MAY_LOCK\t0x00002000\t \n#define MAY_BRINGUP\t0x00004000\t \n\n \n#ifdef CONFIG_SECURITY_SMACK_APPEND_SIGNALS\n#define MAY_DELIVER\tMAY_APPEND\t \n#else\n#define MAY_DELIVER\tMAY_WRITE\t \n#endif\n\n#define SMACK_BRINGUP_ALLOW\t\t1\t \n#define SMACK_UNCONFINED_SUBJECT\t2\t \n#define SMACK_UNCONFINED_OBJECT\t\t3\t \n\n \n#define MAY_ANYREAD\t(MAY_READ | MAY_EXEC)\n#define MAY_READWRITE\t(MAY_READ | MAY_WRITE)\n#define MAY_NOT\t\t0\n\n \n#define SMK_NUM_ACCESS_TYPE 7\n\n \nstruct smack_audit_data {\n\tconst char *function;\n\tchar *subject;\n\tchar *object;\n\tchar *request;\n\tint result;\n};\n\n \nstruct smk_audit_info {\n#ifdef CONFIG_AUDIT\n\tstruct common_audit_data a;\n\tstruct smack_audit_data sad;\n#endif\n};\n\n \nint smk_access_entry(char *, char *, struct list_head *);\nint smk_access(struct smack_known *, struct smack_known *,\n\t       int, struct smk_audit_info *);\nint smk_tskacc(struct task_smack *, struct smack_known *,\n\t       u32, struct smk_audit_info *);\nint smk_curacc(struct smack_known *, u32, struct smk_audit_info *);\nstruct smack_known *smack_from_secid(const u32);\nchar *smk_parse_smack(const char *string, int len);\nint smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);\nstruct smack_known *smk_import_entry(const char *, int);\nvoid smk_insert_entry(struct smack_known *skp);\nstruct smack_known *smk_find_entry(const char *);\nbool smack_privileged(int cap);\nbool smack_privileged_cred(int cap, const struct cred *cred);\nvoid smk_destroy_label_list(struct list_head *list);\nint smack_populate_secattr(struct smack_known *skp);\n\n \nextern int smack_enabled __initdata;\nextern int smack_cipso_direct;\nextern int smack_cipso_mapped;\nextern struct smack_known *smack_net_ambient;\nextern struct smack_known *smack_syslog_label;\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nextern struct smack_known *smack_unconfined;\n#endif\nextern int smack_ptrace_rule;\nextern struct lsm_blob_sizes smack_blob_sizes;\n\nextern struct smack_known smack_known_floor;\nextern struct smack_known smack_known_hat;\nextern struct smack_known smack_known_huh;\nextern struct smack_known smack_known_star;\nextern struct smack_known smack_known_web;\n\nextern struct mutex\tsmack_known_lock;\nextern struct list_head smack_known_list;\nextern struct list_head smk_net4addr_list;\nextern struct list_head smk_net6addr_list;\n\nextern struct mutex     smack_onlycap_lock;\nextern struct list_head smack_onlycap_list;\n\n#define SMACK_HASH_SLOTS 16\nextern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\nextern struct kmem_cache *smack_rule_cache;\n\nstatic inline struct task_smack *smack_cred(const struct cred *cred)\n{\n\treturn cred->security + smack_blob_sizes.lbs_cred;\n}\n\nstatic inline struct smack_known **smack_file(const struct file *file)\n{\n\treturn (struct smack_known **)(file->f_security +\n\t\t\t\t       smack_blob_sizes.lbs_file);\n}\n\nstatic inline struct inode_smack *smack_inode(const struct inode *inode)\n{\n\treturn inode->i_security + smack_blob_sizes.lbs_inode;\n}\n\nstatic inline struct smack_known **smack_msg_msg(const struct msg_msg *msg)\n{\n\treturn msg->security + smack_blob_sizes.lbs_msg_msg;\n}\n\nstatic inline struct smack_known **smack_ipc(const struct kern_ipc_perm *ipc)\n{\n\treturn ipc->security + smack_blob_sizes.lbs_ipc;\n}\n\nstatic inline struct superblock_smack *smack_superblock(\n\t\t\t\t\tconst struct super_block *superblock)\n{\n\treturn superblock->s_security + smack_blob_sizes.lbs_superblock;\n}\n\n \nstatic inline int smk_inode_transmutable(const struct inode *isp)\n{\n\tstruct inode_smack *sip = smack_inode(isp);\n\treturn (sip->smk_flags & SMK_INODE_TRANSMUTE) != 0;\n}\n\n \nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = smack_inode(isp);\n\treturn sip->smk_inode;\n}\n\n \nstatic inline struct smack_known *smk_of_task(const struct task_smack *tsp)\n{\n\treturn tsp->smk_task;\n}\n\nstatic inline struct smack_known *smk_of_task_struct_obj(\n\t\t\t\t\t\tconst struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tcred = __task_cred(t);\n\tskp = smk_of_task(smack_cred(cred));\n\n\trcu_read_unlock();\n\n\treturn skp;\n}\n\n \nstatic inline struct smack_known *smk_of_forked(const struct task_smack *tsp)\n{\n\treturn tsp->smk_forked;\n}\n\n \nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(smack_cred(current_cred()));\n}\n\n \n#define SMACK_AUDIT_DENIED 0x1\n#define SMACK_AUDIT_ACCEPT 0x2\nextern int log_policy;\n\nvoid smack_log(char *subject_label, char *object_label,\n\t\tint request,\n\t\tint result, struct smk_audit_info *auditdata);\n\n#ifdef CONFIG_AUDIT\n\n \nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n\tmemset(&a->sad, 0, sizeof(a->sad));\n\ta->a.type = type;\n\ta->a.smack_audit_data = &a->sad;\n\ta->a.smack_audit_data->function = func;\n}\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}\n\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n\ta->a.u.tsk = t;\n}\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n\ta->a.u.dentry = d;\n}\nstatic inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n\ta->a.u.inode = i;\n}\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n\ta->a.u.path = p;\n}\nstatic inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n\ta->a.u.net->sk = sk;\n}\n\n#else  \n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}\nstatic inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}\nstatic inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n}\n#endif\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}