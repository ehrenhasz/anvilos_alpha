{
  "module_name": "smack_lsm.c",
  "hash_id": "eafd637d2add9052aef55d5810a324ea1295befed646ae0a4e03ac28e1e0b34a",
  "original_prompt": "Ingested from linux-6.6.14/security/smack/smack_lsm.c",
  "human_readable_source": "\n \n\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/stat.h>\n#include <linux/kd.h>\n#include <asm/ioctls.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/dccp.h>\n#include <linux/icmpv6.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <net/cipso_ipv4.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/audit.h>\n#include <linux/magic.h>\n#include <linux/dcache.h>\n#include <linux/personality.h>\n#include <linux/msg.h>\n#include <linux/shm.h>\n#include <linux/binfmts.h>\n#include <linux/parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/watch_queue.h>\n#include <linux/io_uring.h>\n#include \"smack.h\"\n\n#define TRANS_TRUE\t\"TRUE\"\n#define TRANS_TRUE_SIZE\t4\n\n#define SMK_CONNECTING\t0\n#define SMK_RECEIVING\t1\n#define SMK_SENDING\t2\n\n \n#define SMACK_INODE_INIT_XATTRS 2\n\n#ifdef SMACK_IPV6_PORT_LABELING\nstatic DEFINE_MUTEX(smack_ipv6_lock);\nstatic LIST_HEAD(smk_ipv6_port_list);\n#endif\nstruct kmem_cache *smack_rule_cache;\nint smack_enabled __initdata;\n\n#define A(s) {\"smack\"#s, sizeof(\"smack\"#s) - 1, Opt_##s}\nstatic struct {\n\tconst char *name;\n\tint len;\n\tint opt;\n} smk_mount_opts[] = {\n\t{\"smackfsdef\", sizeof(\"smackfsdef\") - 1, Opt_fsdefault},\n\tA(fsdefault), A(fsfloor), A(fshat), A(fsroot), A(fstransmute)\n};\n#undef A\n\nstatic int match_opt_prefix(char *s, int l, char **arg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(smk_mount_opts); i++) {\n\t\tsize_t len = smk_mount_opts[i].len;\n\t\tif (len > l || memcmp(s, smk_mount_opts[i].name, len))\n\t\t\tcontinue;\n\t\tif (len == l || s[len] != '=')\n\t\t\tcontinue;\n\t\t*arg = s + len + 1;\n\t\treturn smk_mount_opts[i].opt;\n\t}\n\treturn Opt_error;\n}\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic char *smk_bu_mess[] = {\n\t\"Bringup Error\",\t \n\t\"Bringup\",\t\t \n\t\"Unconfined Subject\",\t \n\t\"Unconfined Object\",\t \n};\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}\n#else\n#define smk_bu_note(note, sskp, oskp, mode, RC) (RC)\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}\n#else\n#define smk_bu_current(note, oskp, mode, RC) (RC)\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct smack_known *smk_task = smk_of_task_struct_obj(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}\n#else\n#define smk_bu_task(otp, mode, RC) (RC)\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct inode_smack *isp = smack_inode(inode);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}\n#else\n#define smk_bu_inode(inode, mode, RC) (RC)\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = smack_inode(inode);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}\n#else\n#define smk_bu_file(file, mode, RC) (RC)\n#endif\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\nstatic int smk_bu_credfile(const struct cred *cred, struct file *file,\n\t\t\t\tint mode, int rc)\n{\n\tstruct task_smack *tsp = smack_cred(cred);\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = smack_inode(inode);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}\n#else\n#define smk_bu_credfile(cred, file, mode, RC) (RC)\n#endif\n\n \nstatic struct smack_known *smk_fetch(const char *name, struct inode *ip,\n\t\t\t\t\tstruct dentry *dp)\n{\n\tint rc;\n\tchar *buffer;\n\tstruct smack_known *skp = NULL;\n\n\tif (!(ip->i_opflags & IOP_XATTR))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tbuffer = kzalloc(SMK_LONGLABEL, GFP_NOFS);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = __vfs_getxattr(dp, ip, name, buffer, SMK_LONGLABEL);\n\tif (rc < 0)\n\t\tskp = ERR_PTR(rc);\n\telse if (rc == 0)\n\t\tskp = NULL;\n\telse\n\t\tskp = smk_import_entry(buffer, rc);\n\n\tkfree(buffer);\n\n\treturn skp;\n}\n\n \nstatic void init_inode_smack(struct inode *inode, struct smack_known *skp)\n{\n\tstruct inode_smack *isp = smack_inode(inode);\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n}\n\n \nstatic void init_task_smack(struct task_smack *tsp, struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked)\n{\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n}\n\n \nstatic int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_rule *nrp;\n\tstruct smack_rule *orp;\n\tint rc = 0;\n\n\tlist_for_each_entry_rcu(orp, ohead, list) {\n\t\tnrp = kmem_cache_zalloc(smack_rule_cache, gfp);\n\t\tif (nrp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t*nrp = *orp;\n\t\tlist_add_rcu(&nrp->list, nhead);\n\t}\n\treturn rc;\n}\n\n \nstatic int smk_copy_relabel(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_known_list_elem *nklep;\n\tstruct smack_known_list_elem *oklep;\n\n\tlist_for_each_entry(oklep, ohead, list) {\n\t\tnklep = kzalloc(sizeof(struct smack_known_list_elem), gfp);\n\t\tif (nklep == NULL) {\n\t\t\tsmk_destroy_label_list(nhead);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnklep->smk_label = oklep->smk_label;\n\t\tlist_add(&nklep->list, nhead);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline unsigned int smk_ptrace_mode(unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_ATTACH)\n\t\treturn MAY_READWRITE;\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn MAY_READ;\n\n\treturn 0;\n}\n\n \nstatic int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\tconst struct cred *tracercred;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttracercred = __task_cred(tracer);\n\ttsp = smack_cred(tracercred);\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (smack_privileged_cred(CAP_SYS_PTRACE, tracercred))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t \n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \n\n \nstatic int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)\n{\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task_struct_obj(ctp);\n\n\treturn smk_ptrace_rule_check(current, skp, mode, __func__);\n}\n\n \nstatic int smack_ptrace_traceme(struct task_struct *ptp)\n{\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task(smack_cred(current_cred()));\n\n\treturn smk_ptrace_rule_check(ptp, skp, PTRACE_MODE_ATTACH, __func__);\n}\n\n \nstatic int smack_syslog(int typefrom_file)\n{\n\tint rc = 0;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\tif (smack_syslog_label != NULL && smack_syslog_label != skp)\n\t\trc = -EACCES;\n\n\treturn rc;\n}\n\n \n\n \nstatic int smack_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_smack *sbsp = smack_superblock(sb);\n\n\tsbsp->smk_root = &smack_known_floor;\n\tsbsp->smk_default = &smack_known_floor;\n\tsbsp->smk_floor = &smack_known_floor;\n\tsbsp->smk_hat = &smack_known_hat;\n\t \n\n\treturn 0;\n}\n\nstruct smack_mnt_opts {\n\tconst char *fsdefault;\n\tconst char *fsfloor;\n\tconst char *fshat;\n\tconst char *fsroot;\n\tconst char *fstransmute;\n};\n\nstatic void smack_free_mnt_opts(void *mnt_opts)\n{\n\tkfree(mnt_opts);\n}\n\nstatic int smack_add_opt(int token, const char *s, void **mnt_opts)\n{\n\tstruct smack_mnt_opts *opts = *mnt_opts;\n\tstruct smack_known *skp;\n\n\tif (!opts) {\n\t\topts = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);\n\t\tif (!opts)\n\t\t\treturn -ENOMEM;\n\t\t*mnt_opts = opts;\n\t}\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tskp = smk_import_entry(s, 0);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tswitch (token) {\n\tcase Opt_fsdefault:\n\t\tif (opts->fsdefault)\n\t\t\tgoto out_opt_err;\n\t\topts->fsdefault = skp->smk_known;\n\t\tbreak;\n\tcase Opt_fsfloor:\n\t\tif (opts->fsfloor)\n\t\t\tgoto out_opt_err;\n\t\topts->fsfloor = skp->smk_known;\n\t\tbreak;\n\tcase Opt_fshat:\n\t\tif (opts->fshat)\n\t\t\tgoto out_opt_err;\n\t\topts->fshat = skp->smk_known;\n\t\tbreak;\n\tcase Opt_fsroot:\n\t\tif (opts->fsroot)\n\t\t\tgoto out_opt_err;\n\t\topts->fsroot = skp->smk_known;\n\t\tbreak;\n\tcase Opt_fstransmute:\n\t\tif (opts->fstransmute)\n\t\t\tgoto out_opt_err;\n\t\topts->fstransmute = skp->smk_known;\n\t\tbreak;\n\t}\n\treturn 0;\n\nout_opt_err:\n\tpr_warn(\"Smack: duplicate mount options\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int smack_fs_context_submount(struct fs_context *fc,\n\t\t\t\t struct super_block *reference)\n{\n\tstruct superblock_smack *sbsp;\n\tstruct smack_mnt_opts *ctx;\n\tstruct inode_smack *isp;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tfc->security = ctx;\n\n\tsbsp = smack_superblock(reference);\n\tisp = smack_inode(reference->s_root->d_inode);\n\n\tif (sbsp->smk_default) {\n\t\tctx->fsdefault = kstrdup(sbsp->smk_default->smk_known, GFP_KERNEL);\n\t\tif (!ctx->fsdefault)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (sbsp->smk_floor) {\n\t\tctx->fsfloor = kstrdup(sbsp->smk_floor->smk_known, GFP_KERNEL);\n\t\tif (!ctx->fsfloor)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (sbsp->smk_hat) {\n\t\tctx->fshat = kstrdup(sbsp->smk_hat->smk_known, GFP_KERNEL);\n\t\tif (!ctx->fshat)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (isp->smk_flags & SMK_INODE_TRANSMUTE) {\n\t\tif (sbsp->smk_root) {\n\t\t\tctx->fstransmute = kstrdup(sbsp->smk_root->smk_known, GFP_KERNEL);\n\t\t\tif (!ctx->fstransmute)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int smack_fs_context_dup(struct fs_context *fc,\n\t\t\t\tstruct fs_context *src_fc)\n{\n\tstruct smack_mnt_opts *dst, *src = src_fc->security;\n\n\tif (!src)\n\t\treturn 0;\n\n\tfc->security = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);\n\tif (!fc->security)\n\t\treturn -ENOMEM;\n\n\tdst = fc->security;\n\tdst->fsdefault = src->fsdefault;\n\tdst->fsfloor = src->fsfloor;\n\tdst->fshat = src->fshat;\n\tdst->fsroot = src->fsroot;\n\tdst->fstransmute = src->fstransmute;\n\n\treturn 0;\n}\n\nstatic const struct fs_parameter_spec smack_fs_parameters[] = {\n\tfsparam_string(\"smackfsdef\",\t\tOpt_fsdefault),\n\tfsparam_string(\"smackfsdefault\",\tOpt_fsdefault),\n\tfsparam_string(\"smackfsfloor\",\t\tOpt_fsfloor),\n\tfsparam_string(\"smackfshat\",\t\tOpt_fshat),\n\tfsparam_string(\"smackfsroot\",\t\tOpt_fsroot),\n\tfsparam_string(\"smackfstransmute\",\tOpt_fstransmute),\n\t{}\n};\n\n \nstatic int smack_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t\tstruct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tint opt, rc;\n\n\topt = fs_parse(fc, smack_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\trc = smack_add_opt(opt, param->string, &fc->security);\n\tif (!rc)\n\t\tparam->string = NULL;\n\treturn rc;\n}\n\nstatic int smack_sb_eat_lsm_opts(char *options, void **mnt_opts)\n{\n\tchar *from = options, *to = options;\n\tbool first = true;\n\n\twhile (1) {\n\t\tchar *next = strchr(from, ',');\n\t\tint token, len, rc;\n\t\tchar *arg = NULL;\n\n\t\tif (next)\n\t\t\tlen = next - from;\n\t\telse\n\t\t\tlen = strlen(from);\n\n\t\ttoken = match_opt_prefix(from, len, &arg);\n\t\tif (token != Opt_error) {\n\t\t\targ = kmemdup_nul(arg, from + len - arg, GFP_KERNEL);\n\t\t\trc = smack_add_opt(token, arg, mnt_opts);\n\t\t\tkfree(arg);\n\t\t\tif (unlikely(rc)) {\n\t\t\t\tif (*mnt_opts)\n\t\t\t\t\tsmack_free_mnt_opts(*mnt_opts);\n\t\t\t\t*mnt_opts = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!first) {\t \n\t\t\t\tfrom--;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\t\t\tto += len;\n\t\t\tfirst = false;\n\t\t}\n\t\tif (!from[len])\n\t\t\tbreak;\n\t\tfrom += len + 1;\n\t}\n\t*to = '\\0';\n\treturn 0;\n}\n\n \nstatic int smack_set_mnt_opts(struct super_block *sb,\n\t\tvoid *mnt_opts,\n\t\tunsigned long kern_flags,\n\t\tunsigned long *set_kern_flags)\n{\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *inode = d_backing_inode(root);\n\tstruct superblock_smack *sp = smack_superblock(sb);\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tstruct smack_mnt_opts *opts = mnt_opts;\n\tbool transmute = false;\n\n\tif (sp->smk_flags & SMK_SB_INITIALIZED)\n\t\treturn 0;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\t \n\t\tif (opts)\n\t\t\treturn -EPERM;\n\t\t \n\t\tskp = smk_of_current();\n\t\tsp->smk_root = skp;\n\t\tsp->smk_default = skp;\n\t\t \n\t\tif (sb->s_user_ns != &init_user_ns &&\n\t\t    sb->s_magic != SYSFS_MAGIC && sb->s_magic != TMPFS_MAGIC &&\n\t\t    sb->s_magic != RAMFS_MAGIC) {\n\t\t\ttransmute = true;\n\t\t\tsp->smk_flags |= SMK_SB_UNTRUSTED;\n\t\t}\n\t}\n\n\tsp->smk_flags |= SMK_SB_INITIALIZED;\n\n\tif (opts) {\n\t\tif (opts->fsdefault) {\n\t\t\tskp = smk_import_entry(opts->fsdefault, 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_default = skp;\n\t\t}\n\t\tif (opts->fsfloor) {\n\t\t\tskp = smk_import_entry(opts->fsfloor, 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_floor = skp;\n\t\t}\n\t\tif (opts->fshat) {\n\t\t\tskp = smk_import_entry(opts->fshat, 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_hat = skp;\n\t\t}\n\t\tif (opts->fsroot) {\n\t\t\tskp = smk_import_entry(opts->fsroot, 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t}\n\t\tif (opts->fstransmute) {\n\t\t\tskp = smk_import_entry(opts->fstransmute, 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\ttransmute = true;\n\t\t}\n\t}\n\n\t \n\tinit_inode_smack(inode, sp->smk_root);\n\n\tif (transmute) {\n\t\tisp = smack_inode(inode);\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smack_sb_statfs(struct dentry *dentry)\n{\n\tstruct superblock_smack *sbp = smack_superblock(dentry->d_sb);\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(sbp->smk_floor, MAY_READ, &ad);\n\trc = smk_bu_current(\"statfs\", sbp->smk_floor, MAY_READ, rc);\n\treturn rc;\n}\n\n \n\n \nstatic int smack_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tstruct task_smack *bsp = smack_cred(bprm->cred);\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint rc;\n\n\tisp = smack_inode(inode);\n\tif (isp->smk_task == NULL || isp->smk_task == bsp->smk_task)\n\t\treturn 0;\n\n\tsbsp = smack_superblock(inode->i_sb);\n\tif ((sbsp->smk_flags & SMK_SB_UNTRUSTED) &&\n\t    isp->smk_task != sbsp->smk_root)\n\t\treturn 0;\n\n\tif (bprm->unsafe & LSM_UNSAFE_PTRACE) {\n\t\tstruct task_struct *tracer;\n\t\trc = 0;\n\n\t\trcu_read_lock();\n\t\ttracer = ptrace_parent(current);\n\t\tif (likely(tracer != NULL))\n\t\t\trc = smk_ptrace_rule_check(tracer,\n\t\t\t\t\t\t   isp->smk_task,\n\t\t\t\t\t\t   PTRACE_MODE_ATTACH,\n\t\t\t\t\t\t   __func__);\n\t\trcu_read_unlock();\n\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t}\n\tif (bprm->unsafe & ~LSM_UNSAFE_PTRACE)\n\t\treturn -EPERM;\n\n\tbsp->smk_task = isp->smk_task;\n\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t \n\tif (bsp->smk_task != bsp->smk_forked)\n\t\tbprm->secureexec = 1;\n\n\treturn 0;\n}\n\n \n\n \nstatic int smack_inode_alloc_security(struct inode *inode)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tinit_inode_smack(inode, skp);\n\treturn 0;\n}\n\n \nstatic int smack_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t     const struct qstr *qstr,\n\t\t\t\t     struct xattr *xattrs, int *xattr_count)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct smack_known *skp = smk_of_task(tsp);\n\tstruct smack_known *isp = smk_of_inode(inode);\n\tstruct smack_known *dsp = smk_of_inode(dir);\n\tstruct xattr *xattr = lsm_get_xattr_slot(xattrs, xattr_count);\n\tint may;\n\n\tif (xattr) {\n\t\t \n\t\tif (tsp->smk_task != tsp->smk_transmuted) {\n\t\t\trcu_read_lock();\n\t\t\tmay = smk_access_entry(skp->smk_known, dsp->smk_known,\n\t\t\t\t\t       &skp->smk_rules);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\t \n\t\tif ((tsp->smk_task == tsp->smk_transmuted) ||\n\t\t    (may > 0 && ((may & MAY_TRANSMUTE) != 0) &&\n\t\t     smk_inode_transmutable(dir))) {\n\t\t\tstruct xattr *xattr_transmute;\n\n\t\t\t \n\t\t\tif (tsp->smk_task != tsp->smk_transmuted)\n\t\t\t\tisp = dsp;\n\t\t\txattr_transmute = lsm_get_xattr_slot(xattrs,\n\t\t\t\t\t\t\t     xattr_count);\n\t\t\tif (xattr_transmute) {\n\t\t\t\txattr_transmute->value = kmemdup(TRANS_TRUE,\n\t\t\t\t\t\t\t\t TRANS_TRUE_SIZE,\n\t\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!xattr_transmute->value)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\txattr_transmute->value_len = TRANS_TRUE_SIZE;\n\t\t\t\txattr_transmute->name = XATTR_SMACK_TRANSMUTE;\n\t\t\t}\n\t\t}\n\n\t\txattr->value = kstrdup(isp->smk_known, GFP_NOFS);\n\t\tif (!xattr->value)\n\t\t\treturn -ENOMEM;\n\n\t\txattr->value_len = strlen(isp->smk_known);\n\t\txattr->name = XATTR_SMACK_SUFFIX;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smack_inode_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_WRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *ip = d_backing_inode(dentry);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t \n\trc = smk_curacc(smk_of_inode(ip), MAY_WRITE, &ad);\n\trc = smk_bu_inode(ip, MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t \n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\treturn rc;\n}\n\n \nstatic int smack_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t \n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t \n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_inode_rename(struct inode *old_inode,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      struct inode *new_inode,\n\t\t\t      struct dentry *new_dentry)\n{\n\tint rc;\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_READWRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_READWRITE, rc);\n\t}\n\treturn rc;\n}\n\n \nstatic int smack_inode_permission(struct inode *inode, int mask)\n{\n\tstruct superblock_smack *sbsp = smack_superblock(inode->i_sb);\n\tstruct smk_audit_info ad;\n\tint no_block = mask & MAY_NOT_BLOCK;\n\tint rc;\n\n\tmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\n\t \n\tif (mask == 0)\n\t\treturn 0;\n\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED) {\n\t\tif (smk_of_inode(inode) != sbsp->smk_root)\n\t\t\treturn -EACCES;\n\t}\n\n\t \n\tif (no_block)\n\t\treturn -ECHILD;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\tsmk_ad_setfield_u_fs_inode(&ad, inode);\n\trc = smk_curacc(smk_of_inode(inode), mask, &ad);\n\trc = smk_bu_inode(inode, mask, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\t \n\tif (iattr->ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_getattr(const struct path *path)\n{\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, *path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_inode(inode, MAY_READ, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_setxattr(struct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *dentry, const char *name,\n\t\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tint check_priv = 0;\n\tint check_import = 0;\n\tint check_star = 0;\n\tint rc = 0;\n\n\t \n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t\t   strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t\tcheck_star = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tcheck_priv = 1;\n\t\tif (size != TRANS_TRUE_SIZE ||\n\t\t    strncmp(value, TRANS_TRUE, TRANS_TRUE_SIZE) != 0)\n\t\t\trc = -EINVAL;\n\t} else\n\t\trc = cap_inode_setxattr(dentry, name, value, size, flags);\n\n\tif (check_priv && !smack_privileged(CAP_MAC_ADMIN))\n\t\trc = -EPERM;\n\n\tif (rc == 0 && check_import) {\n\t\tskp = size ? smk_import_entry(value, size) : NULL;\n\t\tif (IS_ERR(skp))\n\t\t\trc = PTR_ERR(skp);\n\t\telse if (skp == NULL || (check_star &&\n\t\t    (skp == &smack_known_star || skp == &smack_known_web)))\n\t\t\trc = -EINVAL;\n\t}\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\tif (rc == 0) {\n\t\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic void smack_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp = smack_inode(d_backing_inode(dentry));\n\n\tif (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\t\treturn;\n\t}\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_inode = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_task = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_mmap = skp;\n\t}\n\n\treturn;\n}\n\n \nstatic int smack_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_READ, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_READ, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry, const char *name)\n{\n\tstruct inode_smack *isp;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\t\trc = -EPERM;\n\t} else\n\t\trc = cap_inode_removexattr(idmap, dentry, name);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tisp = smack_inode(d_backing_inode(dentry));\n\t \n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tstruct super_block *sbp = dentry->d_sb;\n\t\tstruct superblock_smack *sbsp = smack_superblock(sbp);\n\n\t\tisp->smk_inode = sbsp->smk_default;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0)\n\t\tisp->smk_task = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0)\n\t\tisp->smk_mmap = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0)\n\t\tisp->smk_flags &= ~SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}\n\n \nstatic int smack_inode_set_acl(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, const char *acl_name,\n\t\t\t       struct posix_acl *kacl)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_get_acl(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, const char *acl_name)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_READ, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_READ, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_remove_acl(struct mnt_idmap *idmap,\n\t\t\t\t  struct dentry *dentry, const char *acl_name)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\treturn rc;\n}\n\n \nstatic int smack_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t\t   struct inode *inode, const char *name,\n\t\t\t\t   void **buffer, bool alloc)\n{\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tstruct super_block *sbp;\n\tstruct inode *ip = inode;\n\tstruct smack_known *isp;\n\tstruct inode_smack *ispp;\n\tsize_t label_len;\n\tchar *label = NULL;\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tisp = smk_of_inode(inode);\n\t} else if (strcmp(name, XATTR_SMACK_TRANSMUTE) == 0) {\n\t\tispp = smack_inode(inode);\n\t\tif (ispp->smk_flags & SMK_INODE_TRANSMUTE)\n\t\t\tlabel = TRANS_TRUE;\n\t\telse\n\t\t\tlabel = \"\";\n\t} else {\n\t\t \n\t\tsbp = ip->i_sb;\n\t\tif (sbp->s_magic != SOCKFS_MAGIC)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsock = SOCKET_I(ip);\n\t\tif (sock == NULL || sock->sk == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tssp = sock->sk->sk_security;\n\n\t\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\t\tisp = ssp->smk_in;\n\t\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\n\t\t\tisp = ssp->smk_out;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!label)\n\t\tlabel = isp->smk_known;\n\n\tlabel_len = strlen(label);\n\n\tif (alloc) {\n\t\t*buffer = kstrdup(label, GFP_KERNEL);\n\t\tif (*buffer == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn label_len;\n}\n\n\n \nstatic int smack_inode_listsecurity(struct inode *inode, char *buffer,\n\t\t\t\t    size_t buffer_size)\n{\n\tint len = sizeof(XATTR_NAME_SMACK);\n\n\tif (buffer != NULL && len <= buffer_size)\n\t\tmemcpy(buffer, XATTR_NAME_SMACK, len);\n\n\treturn len;\n}\n\n \nstatic void smack_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tstruct smack_known *skp = smk_of_inode(inode);\n\n\t*secid = skp->smk_secid;\n}\n\n \n\n \n\n \nstatic int smack_file_alloc_security(struct file *file)\n{\n\tstruct smack_known **blob = smack_file(file);\n\n\t*blob = smk_of_current();\n\treturn 0;\n}\n\n \nstatic int smack_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t}\n\n\tif (rc == 0 && (_IOC_DIR(cmd) & _IOC_READ)) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\t\trc = smk_bu_file(file, MAY_READ, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_file_lock(struct file *file, unsigned int cmd)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\trc = smk_bu_file(file, MAY_LOCK, rc);\n\treturn rc;\n}\n\n \nstatic int smack_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase F_GETLK:\n\t\tbreak;\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\t\trc = smk_bu_file(file, MAY_LOCK, rc);\n\t\tbreak;\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_mmap_file(struct file *file,\n\t\t\t   unsigned long reqprot, unsigned long prot,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *mkp;\n\tstruct smack_rule *srp;\n\tstruct task_smack *tsp;\n\tstruct smack_known *okp;\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint may;\n\tint mmay;\n\tint tmay;\n\tint rc;\n\n\tif (file == NULL)\n\t\treturn 0;\n\n\tif (unlikely(IS_PRIVATE(file_inode(file))))\n\t\treturn 0;\n\n\tisp = smack_inode(file_inode(file));\n\tif (isp->smk_mmap == NULL)\n\t\treturn 0;\n\tsbsp = smack_superblock(file_inode(file)->i_sb);\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED &&\n\t    isp->smk_mmap != sbsp->smk_root)\n\t\treturn -EACCES;\n\tmkp = isp->smk_mmap;\n\n\ttsp = smack_cred(current_cred());\n\tskp = smk_of_current();\n\trc = 0;\n\n\trcu_read_lock();\n\t \n\tlist_for_each_entry_rcu(srp, &skp->smk_rules, list) {\n\t\tokp = srp->smk_object;\n\t\t \n\t\tif (mkp->smk_known == okp->smk_known)\n\t\t\tcontinue;\n\t\t \n\t\tmay = smk_access_entry(srp->smk_subject->smk_known,\n\t\t\t\t       okp->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may == -ENOENT)\n\t\t\tmay = srp->smk_access;\n\t\telse\n\t\t\tmay &= srp->smk_access;\n\t\t \n\t\tif (may == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tmmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&mkp->smk_rules);\n\t\tif (mmay == -ENOENT) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\ttmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&tsp->smk_rules);\n\t\tif (tmay != -ENOENT)\n\t\t\tmmay &= tmay;\n\n\t\t \n\t\tif ((may | mmay) != mmay) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n \nstatic void smack_file_set_fowner(struct file *file)\n{\n\tstruct smack_known **blob = smack_file(file);\n\n\t*blob = smk_of_current();\n}\n\n \nstatic int smack_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t     struct fown_struct *fown, int signum)\n{\n\tstruct smack_known **blob;\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task(smack_cred(tsk->cred));\n\tconst struct cred *tcred;\n\tstruct file *file;\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\t \n\tfile = container_of(fown, struct file, f_owner);\n\n\t \n\tblob = smack_file(file);\n\tskp = *blob;\n\trc = smk_access(skp, tkp, MAY_DELIVER, NULL);\n\trc = smk_bu_note(\"sigiotask\", skp, tkp, MAY_DELIVER, rc);\n\n\trcu_read_lock();\n\ttcred = __task_cred(tsk);\n\tif (rc != 0 && smack_privileged_cred(CAP_MAC_OVERRIDE, tcred))\n\t\trc = 0;\n\trcu_read_unlock();\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, tsk);\n\tsmack_log(skp->smk_known, tkp->smk_known, MAY_DELIVER, rc, &ad);\n\treturn rc;\n}\n\n \nstatic int smack_file_receive(struct file *file)\n{\n\tint rc;\n\tint may = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\tstruct socket *sock;\n\tstruct task_smack *tsp;\n\tstruct socket_smack *ssp;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (inode->i_sb->s_magic == SOCKFS_MAGIC) {\n\t\tsock = SOCKET_I(inode);\n\t\tssp = sock->sk->sk_security;\n\t\ttsp = smack_cred(current_cred());\n\t\t \n\t\trc = smk_access(tsp->smk_task, ssp->smk_out, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = smk_access(ssp->smk_in, tsp->smk_task, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\treturn rc;\n\t}\n\t \n\tif (file->f_mode & FMODE_READ)\n\t\tmay = MAY_READ;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tmay |= MAY_WRITE;\n\n\trc = smk_curacc(smk_of_inode(inode), may, &ad);\n\trc = smk_bu_file(file, may, rc);\n\treturn rc;\n}\n\n \nstatic int smack_file_open(struct file *file)\n{\n\tstruct task_smack *tsp = smack_cred(file->f_cred);\n\tstruct inode *inode = file_inode(file);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_tskacc(tsp, smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_credfile(file->f_cred, file, MAY_READ, rc);\n\n\treturn rc;\n}\n\n \n\n \nstatic int smack_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\tinit_task_smack(smack_cred(cred), NULL, NULL);\n\treturn 0;\n}\n\n\n \nstatic void smack_cred_free(struct cred *cred)\n{\n\tstruct task_smack *tsp = smack_cred(cred);\n\tstruct smack_rule *rp;\n\tstruct list_head *l;\n\tstruct list_head *n;\n\n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tlist_for_each_safe(l, n, &tsp->smk_rules) {\n\t\trp = list_entry(l, struct smack_rule, list);\n\t\tlist_del(&rp->list);\n\t\tkmem_cache_free(smack_rule_cache, rp);\n\t}\n}\n\n \nstatic int smack_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t      gfp_t gfp)\n{\n\tstruct task_smack *old_tsp = smack_cred(old);\n\tstruct task_smack *new_tsp = smack_cred(new);\n\tint rc;\n\n\tinit_task_smack(new_tsp, old_tsp->smk_task, old_tsp->smk_task);\n\n\trc = smk_copy_rules(&new_tsp->smk_rules, &old_tsp->smk_rules, gfp);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = smk_copy_relabel(&new_tsp->smk_relabel, &old_tsp->smk_relabel,\n\t\t\t\tgfp);\n\treturn rc;\n}\n\n \nstatic void smack_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tstruct task_smack *old_tsp = smack_cred(old);\n\tstruct task_smack *new_tsp = smack_cred(new);\n\n\tnew_tsp->smk_task = old_tsp->smk_task;\n\tnew_tsp->smk_forked = old_tsp->smk_task;\n\tmutex_init(&new_tsp->smk_rules_lock);\n\tINIT_LIST_HEAD(&new_tsp->smk_rules);\n\n\t \n}\n\n \nstatic void smack_cred_getsecid(const struct cred *cred, u32 *secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(smack_cred(cred));\n\t*secid = skp->smk_secid;\n\trcu_read_unlock();\n}\n\n \nstatic int smack_kernel_act_as(struct cred *new, u32 secid)\n{\n\tstruct task_smack *new_tsp = smack_cred(new);\n\n\tnew_tsp->smk_task = smack_from_secid(secid);\n\treturn 0;\n}\n\n \nstatic int smack_kernel_create_files_as(struct cred *new,\n\t\t\t\t\tstruct inode *inode)\n{\n\tstruct inode_smack *isp = smack_inode(inode);\n\tstruct task_smack *tsp = smack_cred(new);\n\n\ttsp->smk_forked = isp->smk_inode;\n\ttsp->smk_task = tsp->smk_forked;\n\treturn 0;\n}\n\n \nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct_obj(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}\n\n \nstatic int smack_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}\n\n \nstatic int smack_task_getpgid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}\n\n \nstatic int smack_task_getsid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}\n\n \nstatic void smack_current_getsecid_subj(u32 *secid)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\t*secid = skp->smk_secid;\n}\n\n \nstatic void smack_task_getsecid_obj(struct task_struct *p, u32 *secid)\n{\n\tstruct smack_known *skp = smk_of_task_struct_obj(p);\n\n\t*secid = skp->smk_secid;\n}\n\n \nstatic int smack_task_setnice(struct task_struct *p, int nice)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}\n\n \nstatic int smack_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}\n\n \nstatic int smack_task_getioprio(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}\n\n \nstatic int smack_task_setscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}\n\n \nstatic int smack_task_getscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}\n\n \nstatic int smack_task_movememory(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}\n\n \nstatic int smack_task_kill(struct task_struct *p, struct kernel_siginfo *info,\n\t\t\t   int sig, const struct cred *cred)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task_struct_obj(p);\n\tint rc;\n\n\tif (!sig)\n\t\treturn 0;  \n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\t \n\tif (cred == NULL) {\n\t\trc = smk_curacc(tkp, MAY_DELIVER, &ad);\n\t\trc = smk_bu_task(p, MAY_DELIVER, rc);\n\t\treturn rc;\n\t}\n\t \n\tskp = smk_of_task(smack_cred(cred));\n\trc = smk_access(skp, tkp, MAY_DELIVER, &ad);\n\trc = smk_bu_note(\"USB signal\", skp, tkp, MAY_DELIVER, rc);\n\treturn rc;\n}\n\n \nstatic void smack_task_to_inode(struct task_struct *p, struct inode *inode)\n{\n\tstruct inode_smack *isp = smack_inode(inode);\n\tstruct smack_known *skp = smk_of_task_struct_obj(p);\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags |= SMK_INODE_INSTANT;\n}\n\n \n\n \nstatic int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct socket_smack *ssp;\n\n\tssp = kzalloc(sizeof(struct socket_smack), gfp_flags);\n\tif (ssp == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t} else {\n\t\tssp->smk_in = skp;\n\t\tssp->smk_out = skp;\n\t}\n\tssp->smk_packet = NULL;\n\n\tsk->sk_security = ssp;\n\n\treturn 0;\n}\n\n \nstatic void smack_sk_free_security(struct sock *sk)\n{\n#ifdef SMACK_IPV6_PORT_LABELING\n\tstruct smk_port_label *spp;\n\n\tif (sk->sk_family == PF_INET6) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (spp->smk_sock != sk)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_can_reuse = 1;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\n\tkfree(sk->sk_security);\n}\n\n \nstatic void smack_sk_clone_security(const struct sock *sk, struct sock *newsk)\n{\n\tstruct socket_smack *ssp_old = sk->sk_security;\n\tstruct socket_smack *ssp_new = newsk->sk_security;\n\n\t*ssp_new = *ssp_old;\n}\n\n \nstatic struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t \n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}\n\n \nstatic bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t \n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t \n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t \n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int smack_netlbl_add(struct sock *sk)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = ssp->smk_out;\n\tint rc;\n\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\n\trc = netlbl_sock_setattr(sk, sk->sk_family, &skp->smk_netlabel);\n\tswitch (rc) {\n\tcase 0:\n\t\tssp->smk_state = SMK_NETLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tssp->smk_state = SMK_NETLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}\n\n \nstatic void smack_netlbl_delete(struct sock *sk)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\n\t \n\tif (ssp->smk_state != SMK_NETLBL_LABELED)\n\t\treturn;\n\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\tnetlbl_sock_delattr(sk);\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tssp->smk_state = SMK_NETLBL_UNLABELED;\n}\n\n \nstatic int smk_ipv4_check(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc = 0;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t\t \n\t\tif (!rc)\n\t\t\tsmack_netlbl_delete(sk);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n \nstatic int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = address->sin6_port;\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}\n\n#ifdef SMACK_IPV6_PORT_LABELING\n \nstatic void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t \n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t \n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t \n\tif (port == 0)\n\t\treturn;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t \n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}\n\n \nstatic int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t \n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t \n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t \n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}\n#endif\n\n \nstatic int smack_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *nsp = smack_inode(inode);\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tint rc = 0;\n\n\tif (value == NULL || size > SMK_LONGLABEL || size == 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tnsp->smk_inode = skp;\n\t\tnsp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn 0;\n\t}\n\t \n\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tsock = SOCKET_I(inode);\n\tif (sock == NULL || sock->sk == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tssp = sock->sk->sk_security;\n\n\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\tssp->smk_in = skp;\n\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\n\t\tssp->smk_out = skp;\n\t\tif (sock->sk->sk_family == PF_INET) {\n\t\t\trc = smack_netlbl_add(sock->sk);\n\t\t\tif (rc != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",\n\t\t\t\t\t__func__, -rc);\n\t\t}\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n#ifdef SMACK_IPV6_PORT_LABELING\n\tif (sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, NULL);\n#endif\n\n\treturn 0;\n}\n\n \nstatic int smack_socket_post_create(struct socket *sock, int family,\n\t\t\t\t    int type, int protocol, int kern)\n{\n\tstruct socket_smack *ssp;\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\n\t \n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp = sock->sk->sk_security;\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t}\n\n\tif (family != PF_INET)\n\t\treturn 0;\n\t \n\treturn smack_netlbl_add(sock->sk);\n}\n\n \nstatic int smack_socket_socketpair(struct socket *socka,\n\t\t                   struct socket *sockb)\n{\n\tstruct socket_smack *asp = socka->sk->sk_security;\n\tstruct socket_smack *bsp = sockb->sk->sk_security;\n\n\tasp->smk_packet = bsp->smk_out;\n\tbsp->smk_packet = asp->smk_out;\n\n\treturn 0;\n}\n\n#ifdef SMACK_IPV6_PORT_LABELING\n \nstatic int smack_socket_bind(struct socket *sock, struct sockaddr *address,\n\t\t\t\tint addrlen)\n{\n\tif (sock->sk != NULL && sock->sk->sk_family == PF_INET6) {\n\t\tif (addrlen < SIN6_LEN_RFC2133 ||\n\t\t    address->sa_family != AF_INET6)\n\t\t\treturn -EINVAL;\n\t\tsmk_ipv6_port_label(sock, address);\n\t}\n\treturn 0;\n}\n#endif  \n\n \nstatic int smack_socket_connect(struct socket *sock, struct sockaddr *sap,\n\t\t\t\tint addrlen)\n{\n\tint rc = 0;\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\tif (sock->sk->sk_family != PF_INET &&\n\t    (!IS_ENABLED(CONFIG_IPV6) || sock->sk->sk_family != PF_INET6))\n\t\treturn 0;\n\tif (addrlen < offsetofend(struct sockaddr, sa_family))\n\t\treturn 0;\n\tif (IS_ENABLED(CONFIG_IPV6) && sap->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sip = (struct sockaddr_in6 *)sap;\n\t\tstruct smack_known *rsp = NULL;\n\n\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\treturn 0;\n\t\tif (__is_defined(SMACK_IPV6_SECMARK_LABELING))\n\t\t\trsp = smack_ipv6host_label(sip);\n\t\tif (rsp != NULL) {\n\t\t\tstruct socket_smack *ssp = sock->sk->sk_security;\n\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sip,\n\t\t\t\t\t    SMK_CONNECTING);\n\t\t}\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sip, SMK_CONNECTING);\n#endif\n\n\t\treturn rc;\n\t}\n\tif (sap->sa_family != AF_INET || addrlen < sizeof(struct sockaddr_in))\n\t\treturn 0;\n\trc = smk_ipv4_check(sock->sk, (struct sockaddr_in *)sap);\n\treturn rc;\n}\n\n \nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}\n\n \nstatic int smack_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct smack_known **blob = smack_msg_msg(msg);\n\n\t*blob = smk_of_current();\n\treturn 0;\n}\n\n \nstatic struct smack_known *smack_of_ipc(struct kern_ipc_perm *isp)\n{\n\tstruct smack_known **blob = smack_ipc(isp);\n\n\treturn *blob;\n}\n\n \nstatic int smack_ipc_alloc_security(struct kern_ipc_perm *isp)\n{\n\tstruct smack_known **blob = smack_ipc(isp);\n\n\t*blob = smk_of_current();\n\treturn 0;\n}\n\n \nstatic int smk_curacc_shm(struct kern_ipc_perm *isp, int access)\n{\n\tstruct smack_known *ssp = smack_of_ipc(isp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = isp->id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}\n\n \nstatic int smack_shm_associate(struct kern_ipc_perm *isp, int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(isp, may);\n}\n\n \nstatic int smack_shm_shmctl(struct kern_ipc_perm *isp, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase SHM_STAT:\n\tcase SHM_STAT_ANY:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn smk_curacc_shm(isp, may);\n}\n\n \nstatic int smack_shm_shmat(struct kern_ipc_perm *isp, char __user *shmaddr,\n\t\t\t   int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(isp, may);\n}\n\n \nstatic int smk_curacc_sem(struct kern_ipc_perm *isp, int access)\n{\n\tstruct smack_known *ssp = smack_of_ipc(isp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = isp->id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}\n\n \nstatic int smack_sem_associate(struct kern_ipc_perm *isp, int semflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(semflg);\n\treturn smk_curacc_sem(isp, may);\n}\n\n \nstatic int smack_sem_semctl(struct kern_ipc_perm *isp, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\tcase GETVAL:\n\tcase GETALL:\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\tcase SEM_STAT_ANY:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase SETVAL:\n\tcase SETALL:\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_sem(isp, may);\n}\n\n \nstatic int smack_sem_semop(struct kern_ipc_perm *isp, struct sembuf *sops,\n\t\t\t   unsigned nsops, int alter)\n{\n\treturn smk_curacc_sem(isp, MAY_READWRITE);\n}\n\n \nstatic int smk_curacc_msq(struct kern_ipc_perm *isp, int access)\n{\n\tstruct smack_known *msp = smack_of_ipc(isp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = isp->id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}\n\n \nstatic int smack_msg_queue_associate(struct kern_ipc_perm *isp, int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(isp, may);\n}\n\n \nstatic int smack_msg_queue_msgctl(struct kern_ipc_perm *isp, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\tcase MSG_STAT_ANY:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase MSG_INFO:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_msq(isp, may);\n}\n\n \nstatic int smack_msg_queue_msgsnd(struct kern_ipc_perm *isp, struct msg_msg *msg,\n\t\t\t\t  int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(isp, may);\n}\n\n \nstatic int smack_msg_queue_msgrcv(struct kern_ipc_perm *isp,\n\t\t\t\t  struct msg_msg *msg,\n\t\t\t\t  struct task_struct *target, long type,\n\t\t\t\t  int mode)\n{\n\treturn smk_curacc_msq(isp, MAY_READWRITE);\n}\n\n \nstatic int smack_ipc_permission(struct kern_ipc_perm *ipp, short flag)\n{\n\tstruct smack_known **blob = smack_ipc(ipp);\n\tstruct smack_known *iskp = *blob;\n\tint may = smack_flags_to_may(flag);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = ipp->id;\n#endif\n\trc = smk_curacc(iskp, may, &ad);\n\trc = smk_bu_current(\"svipc\", iskp, may, rc);\n\treturn rc;\n}\n\n \nstatic void smack_ipc_getsecid(struct kern_ipc_perm *ipp, u32 *secid)\n{\n\tstruct smack_known **blob = smack_ipc(ipp);\n\tstruct smack_known *iskp = *blob;\n\n\t*secid = iskp->smk_secid;\n}\n\n \nstatic void smack_d_instantiate(struct dentry *opt_dentry, struct inode *inode)\n{\n\tstruct super_block *sbp;\n\tstruct superblock_smack *sbsp;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tstruct smack_known *ckp = smk_of_current();\n\tstruct smack_known *final;\n\tchar trattr[TRANS_TRUE_SIZE];\n\tint transflag = 0;\n\tint rc;\n\tstruct dentry *dp;\n\n\tif (inode == NULL)\n\t\treturn;\n\n\tisp = smack_inode(inode);\n\n\t \n\tif (isp->smk_flags & SMK_INODE_INSTANT)\n\t\treturn;\n\n\tsbp = inode->i_sb;\n\tsbsp = smack_superblock(sbp);\n\t \n\tfinal = sbsp->smk_default;\n\n\t \n\tif (opt_dentry->d_parent == opt_dentry) {\n\t\tswitch (sbp->s_magic) {\n\t\tcase CGROUP_SUPER_MAGIC:\n\t\tcase CGROUP2_SUPER_MAGIC:\n\t\t\t \n\t\t\tsbsp->smk_root = &smack_known_star;\n\t\t\tsbsp->smk_default = &smack_known_star;\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\tcase TMPFS_MAGIC:\n\t\t\t \n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase PIPEFS_MAGIC:\n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase SOCKFS_MAGIC:\n\t\t\t \n\t\t\tisp->smk_inode = &smack_known_star;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\t}\n\t\tisp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn;\n\t}\n\n\t \n\tswitch (sbp->s_magic) {\n\tcase SMACK_MAGIC:\n\tcase CGROUP_SUPER_MAGIC:\n\tcase CGROUP2_SUPER_MAGIC:\n\t\t \n\t\tfinal = &smack_known_star;\n\t\tbreak;\n\tcase DEVPTS_SUPER_MAGIC:\n\t\t \n\t\tfinal = ckp;\n\t\tbreak;\n\tcase PROC_SUPER_MAGIC:\n\t\t \n\t\tbreak;\n\tcase TMPFS_MAGIC:\n\t\t \n\t\tfinal = &smack_known_star;\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\t \n\n\t\t \n\t\tif (S_ISSOCK(inode->i_mode)) {\n\t\t\tfinal = &smack_known_star;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!(inode->i_opflags & IOP_XATTR))\n\t\t        break;\n\t\t \n\t\tdp = dget(opt_dentry);\n\t\tskp = smk_fetch(XATTR_NAME_SMACK, inode, dp);\n\t\tif (!IS_ERR_OR_NULL(skp))\n\t\t\tfinal = skp;\n\n\t\t \n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\t \n\t\t\trc = __vfs_getxattr(dp, inode,\n\t\t\t\t\t    XATTR_NAME_SMACKTRANSMUTE, trattr,\n\t\t\t\t\t    TRANS_TRUE_SIZE);\n\t\t\tif (rc >= 0 && strncmp(trattr, TRANS_TRUE,\n\t\t\t\t\t       TRANS_TRUE_SIZE) != 0)\n\t\t\t\trc = -EINVAL;\n\t\t\tif (rc >= 0)\n\t\t\t\ttransflag = SMK_INODE_TRANSMUTE;\n\t\t}\n\t\t \n\t\tskp = smk_fetch(XATTR_NAME_SMACKEXEC, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_task = skp;\n\n\t\tskp = smk_fetch(XATTR_NAME_SMACKMMAP, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_mmap = skp;\n\n\t\tdput(dp);\n\t\tbreak;\n\t}\n\n\tif (final == NULL)\n\t\tisp->smk_inode = ckp;\n\telse\n\t\tisp->smk_inode = final;\n\n\tisp->smk_flags |= (SMK_INODE_INSTANT | transflag);\n\n\treturn;\n}\n\n \nstatic int smack_getprocattr(struct task_struct *p, const char *name, char **value)\n{\n\tstruct smack_known *skp = smk_of_task_struct_obj(p);\n\tchar *cp;\n\tint slen;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tcp = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (cp == NULL)\n\t\treturn -ENOMEM;\n\n\tslen = strlen(cp);\n\t*value = cp;\n\treturn slen;\n}\n\n \nstatic int smack_setprocattr(const char *name, void *value, size_t size)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct cred *new;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN) && list_empty(&tsp->smk_relabel))\n\t\treturn -EPERM;\n\n\tif (value == NULL || size == 0 || size >= SMK_LONGLABEL)\n\t\treturn -EINVAL;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t \n\tif (skp == &smack_known_web || skp == &smack_known_star)\n\t\treturn -EINVAL;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\trc = -EPERM;\n\t\tlist_for_each_entry(sklep, &tsp->smk_relabel, list)\n\t\t\tif (sklep->smk_label == skp) {\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnew = prepare_creds();\n\tif (new == NULL)\n\t\treturn -ENOMEM;\n\n\ttsp = smack_cred(new);\n\ttsp->smk_task = skp;\n\t \n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tcommit_creds(new);\n\treturn size;\n}\n\n \nstatic int smack_unix_stream_connect(struct sock *sock,\n\t\t\t\t     struct sock *other, struct sock *newsk)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *okp;\n\tstruct socket_smack *ssp = sock->sk_security;\n\tstruct socket_smack *osp = other->sk_security;\n\tstruct socket_smack *nsp = newsk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n\tif (!smack_privileged(CAP_MAC_OVERRIDE)) {\n\t\tskp = ssp->smk_out;\n\t\tokp = osp->smk_in;\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tsmk_ad_setfield_u_net_sk(&ad, other);\n#endif\n\t\trc = smk_access(skp, okp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"UDS connect\", skp, okp, MAY_WRITE, rc);\n\t\tif (rc == 0) {\n\t\t\tokp = osp->smk_out;\n\t\t\tskp = ssp->smk_in;\n\t\t\trc = smk_access(okp, skp, MAY_WRITE, &ad);\n\t\t\trc = smk_bu_note(\"UDS connect\", okp, skp,\n\t\t\t\t\t\tMAY_WRITE, rc);\n\t\t}\n\t}\n\n\t \n\tif (rc == 0) {\n\t\tnsp->smk_packet = ssp->smk_out;\n\t\tssp->smk_packet = osp->smk_out;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_unix_may_send(struct socket *sock, struct socket *other)\n{\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct socket_smack *osp = other->sk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tsmk_ad_setfield_u_net_sk(&ad, other->sk);\n#endif\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\trc = smk_access(ssp->smk_out, osp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"UDS send\", ssp->smk_out, osp->smk_in, MAY_WRITE, rc);\n\treturn rc;\n}\n\n \nstatic int smack_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\tint size)\n{\n\tstruct sockaddr_in *sip = (struct sockaddr_in *) msg->msg_name;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *sap = (struct sockaddr_in6 *) msg->msg_name;\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smack_known *rsp;\n#endif\n\tint rc = 0;\n\n\t \n\tif (sip == NULL)\n\t\treturn 0;\n\n\tswitch (sock->sk->sk_family) {\n\tcase AF_INET:\n\t\tif (msg->msg_namelen < sizeof(struct sockaddr_in) ||\n\t\t    sip->sin_family != AF_INET)\n\t\t\treturn -EINVAL;\n\t\trc = smk_ipv4_check(sock->sk, sip);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (msg->msg_namelen < SIN6_LEN_RFC2133 ||\n\t\t    sap->sin6_family != AF_INET6)\n\t\t\treturn -EINVAL;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\trsp = smack_ipv6host_label(sap);\n\t\tif (rsp != NULL)\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sap,\n\t\t\t\t\t\tSMK_CONNECTING);\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sap, SMK_SENDING);\n#endif\n#endif  \n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nstatic struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\t \n\tif ((sap->flags & NETLBL_SECATTR_CACHE) != 0)\n\t\treturn (struct smack_known *)sap->cache->data;\n\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t \n\t\treturn smack_from_secid(sap->attr.secid);\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t \n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\t \n\treturn smack_net_ambient;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int smk_skb_to_addr_ipv6(struct sk_buff *skb, struct sockaddr_in6 *sip)\n{\n\tu8 nexthdr;\n\tint offset;\n\tint proto = -EINVAL;\n\tstruct ipv6hdr _ipv6h;\n\tstruct ipv6hdr *ip6;\n\t__be16 frag_off;\n\tstruct tcphdr _tcph, *th;\n\tstruct udphdr _udph, *uh;\n\tstruct dccp_hdr _dccph, *dh;\n\n\tsip->sin6_port = 0;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tsip->sin6_addr = ip6->saddr;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tproto = nexthdr;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th != NULL)\n\t\t\tsip->sin6_port = th->source;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh != NULL)\n\t\t\tsip->sin6_port = uh->source;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh != NULL)\n\t\t\tsip->sin6_port = dh->dccph_sport;\n\t\tbreak;\n\t}\n\treturn proto;\n}\n#endif  \n\n \n#ifdef CONFIG_NETWORK_SECMARK\nstatic struct smack_known *smack_from_skb(struct sk_buff *skb)\n{\n\tif (skb == NULL || skb->secmark == 0)\n\t\treturn NULL;\n\n\treturn smack_from_secid(skb->secmark);\n}\n#else\nstatic inline struct smack_known *smack_from_skb(struct sk_buff *skb)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic struct smack_known *smack_from_netlbl(const struct sock *sk, u16 family,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct socket_smack *ssp = NULL;\n\tstruct smack_known *skp = NULL;\n\n\tnetlbl_secattr_init(&secattr);\n\n\tif (sk)\n\t\tssp = sk->sk_security;\n\n\tif (netlbl_skbuff_getattr(skb, family, &secattr) == 0) {\n\t\tskp = smack_from_secattr(&secattr, ssp);\n\t\tif (secattr.flags & NETLBL_SECATTR_CACHEABLE)\n\t\t\tnetlbl_cache_add(skb, family, &skp->smk_netlabel);\n\t}\n\n\tnetlbl_secattr_destroy(&secattr);\n\n\treturn skp;\n}\n\n \nstatic int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n\tu16 family = sk->sk_family;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 sadd;\n\tint proto;\n\n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n#endif  \n\n\tswitch (family) {\n\tcase PF_INET:\n\t\t \n\t\tskp = smack_from_skb(skb);\n\t\tif (skp == NULL) {\n\t\t\tskp = smack_from_netlbl(sk, family, skb);\n\t\t\tif (skp == NULL)\n\t\t\t\tskp = smack_net_ambient;\n\t\t}\n\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t\t \n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n\t\tif (rc != 0)\n\t\t\tnetlbl_skbuff_err(skb, family, rc, 0);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tproto = smk_skb_to_addr_ipv6(skb, &sadd);\n\t\tif (proto != IPPROTO_UDP && proto != IPPROTO_UDPLITE &&\n\t\t    proto != IPPROTO_TCP && proto != IPPROTO_DCCP)\n\t\t\tbreak;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\tskp = smack_from_skb(skb);\n\t\tif (skp == NULL) {\n\t\t\tif (smk_ipv6_localhost(&sadd))\n\t\t\t\tbreak;\n\t\t\tskp = smack_ipv6host_label(&sadd);\n\t\t\tif (skp == NULL)\n\t\t\t\tskp = smack_net_ambient;\n\t\t}\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv6_skb_to_auditdata(skb, &ad.a, NULL);\n#endif  \n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv6 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n#endif  \n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sk, &sadd, SMK_RECEIVING);\n#endif  \n\t\tif (rc != 0)\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t\tICMPV6_ADM_PROHIBITED, 0);\n\t\tbreak;\n#endif  \n\t}\n\n\treturn rc;\n}\n\n \nstatic int smack_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t  sockptr_t optval, sockptr_t optlen,\n\t\t\t\t\t  unsigned int len)\n{\n\tstruct socket_smack *ssp;\n\tchar *rcp = \"\";\n\tu32 slen = 1;\n\tint rc = 0;\n\n\tssp = sock->sk->sk_security;\n\tif (ssp->smk_packet != NULL) {\n\t\trcp = ssp->smk_packet->smk_known;\n\t\tslen = strlen(rcp) + 1;\n\t}\n\tif (slen > len) {\n\t\trc = -ERANGE;\n\t\tgoto out_len;\n\t}\n\n\tif (copy_to_sockptr(optval, rcp, slen))\n\t\trc = -EFAULT;\nout_len:\n\tif (copy_to_sockptr(optlen, &slen, sizeof(slen)))\n\t\trc = -EFAULT;\n\treturn rc;\n}\n\n\n \nstatic int smack_socket_getpeersec_dgram(struct socket *sock,\n\t\t\t\t\t struct sk_buff *skb, u32 *secid)\n\n{\n\tstruct socket_smack *ssp = NULL;\n\tstruct smack_known *skp;\n\tstruct sock *sk = NULL;\n\tint family = PF_UNSPEC;\n\tu32 s = 0;\t \n\n\tif (skb != NULL) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tfamily = PF_INET6;\n#endif  \n\t}\n\tif (family == PF_UNSPEC && sock != NULL)\n\t\tfamily = sock->sk->sk_family;\n\n\tswitch (family) {\n\tcase PF_UNIX:\n\t\tssp = sock->sk->sk_security;\n\t\ts = ssp->smk_out->smk_secid;\n\t\tbreak;\n\tcase PF_INET:\n\t\tskp = smack_from_skb(skb);\n\t\tif (skp) {\n\t\t\ts = skp->smk_secid;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sock != NULL)\n\t\t\tsk = sock->sk;\n\t\tskp = smack_from_netlbl(sk, family, skb);\n\t\tif (skp != NULL)\n\t\t\ts = skp->smk_secid;\n\t\tbreak;\n\tcase PF_INET6:\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\tskp = smack_from_skb(skb);\n\t\tif (skp)\n\t\t\ts = skp->smk_secid;\n#endif\n\t\tbreak;\n\t}\n\t*secid = s;\n\tif (s == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic void smack_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct socket_smack *ssp;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (sk == NULL ||\n\t    (sk->sk_family != PF_INET && sk->sk_family != PF_INET6))\n\t\treturn;\n\n\tssp = sk->sk_security;\n\tssp->smk_in = skp;\n\tssp->smk_out = skp;\n\t \n}\n\n \nstatic int smack_inet_conn_request(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t   struct request_sock *req)\n{\n\tu16 family = sk->sk_family;\n\tstruct smack_known *skp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct sockaddr_in addr;\n\tstruct iphdr *hdr;\n\tstruct smack_known *hskp;\n\tint rc;\n\tstruct smk_audit_info ad;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (family == PF_INET6) {\n\t\t \n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n\t\telse\n\t\t\treturn 0;\n\t}\n#endif  \n\n\t \n\tskp = smack_from_skb(skb);\n\tif (skp == NULL) {\n\t\tskp = smack_from_netlbl(sk, family, skb);\n\t\tif (skp == NULL)\n\t\t\tskp = &smack_known_huh;\n\t}\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = family;\n\tad.a.u.net->netif = skb->skb_iif;\n\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t \n\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv4 connect\", skp, ssp->smk_in, MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\treq->peer_secid = skp->smk_secid;\n\n\t \n\thdr = ip_hdr(skb);\n\taddr.sin_addr.s_addr = hdr->saddr;\n\trcu_read_lock();\n\thskp = smack_ipv4host_label(&addr);\n\trcu_read_unlock();\n\n\tif (hskp == NULL)\n\t\trc = netlbl_req_setattr(req, &skp->smk_netlabel);\n\telse\n\t\tnetlbl_req_delattr(req);\n\n\treturn rc;\n}\n\n \nstatic void smack_inet_csk_clone(struct sock *sk,\n\t\t\t\t const struct request_sock *req)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp;\n\n\tif (req->peer_secid != 0) {\n\t\tskp = smack_from_secid(req->peer_secid);\n\t\tssp->smk_packet = skp;\n\t} else\n\t\tssp->smk_packet = NULL;\n}\n\n \n#ifdef CONFIG_KEYS\n\n \nstatic int smack_key_alloc(struct key *key, const struct cred *cred,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp = smk_of_task(smack_cred(cred));\n\n\tkey->security = skp;\n\treturn 0;\n}\n\n \nstatic void smack_key_free(struct key *key)\n{\n\tkey->security = NULL;\n}\n\n \nstatic int smack_key_permission(key_ref_t key_ref,\n\t\t\t\tconst struct cred *cred,\n\t\t\t\tenum key_need_perm need_perm)\n{\n\tstruct key *keyp;\n\tstruct smk_audit_info ad;\n\tstruct smack_known *tkp = smk_of_task(smack_cred(cred));\n\tint request = 0;\n\tint rc;\n\n\t \n\tswitch (need_perm) {\n\tcase KEY_NEED_READ:\n\tcase KEY_NEED_SEARCH:\n\tcase KEY_NEED_VIEW:\n\t\trequest |= MAY_READ;\n\t\tbreak;\n\tcase KEY_NEED_WRITE:\n\tcase KEY_NEED_LINK:\n\tcase KEY_NEED_SETATTR:\n\t\trequest |= MAY_WRITE;\n\t\tbreak;\n\tcase KEY_NEED_UNSPECIFIED:\n\tcase KEY_NEED_UNLINK:\n\tcase KEY_SYSADMIN_OVERRIDE:\n\tcase KEY_AUTHTOKEN_OVERRIDE:\n\tcase KEY_DEFER_PERM_CHECK:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tkeyp = key_ref_to_ptr(key_ref);\n\tif (keyp == NULL)\n\t\treturn -EINVAL;\n\t \n\tif (keyp->security == NULL)\n\t\treturn 0;\n\t \n\tif (tkp == NULL)\n\t\treturn -EACCES;\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_KEY);\n\tad.a.u.key_struct.key = keyp->serial;\n\tad.a.u.key_struct.key_desc = keyp->description;\n#endif\n\trc = smk_access(tkp, keyp->security, request, &ad);\n\trc = smk_bu_note(\"key access\", tkp, keyp->security, request, rc);\n\treturn rc;\n}\n\n \nstatic int smack_key_getsecurity(struct key *key, char **_buffer)\n{\n\tstruct smack_known *skp = key->security;\n\tsize_t length;\n\tchar *copy;\n\n\tif (key->security == NULL) {\n\t\t*_buffer = NULL;\n\t\treturn 0;\n\t}\n\n\tcopy = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn -ENOMEM;\n\tlength = strlen(copy) + 1;\n\n\t*_buffer = copy;\n\treturn length;\n}\n\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\n \nstatic int smack_watch_key(struct key *key)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *tkp = smk_of_current();\n\tint rc;\n\n\tif (key == NULL)\n\t\treturn -EINVAL;\n\t \n\tif (key->security == NULL)\n\t\treturn 0;\n\t \n\tif (tkp == NULL)\n\t\treturn -EACCES;\n\n\tif (smack_privileged_cred(CAP_MAC_OVERRIDE, current_cred()))\n\t\treturn 0;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_KEY);\n\tad.a.u.key_struct.key = key->serial;\n\tad.a.u.key_struct.key_desc = key->description;\n#endif\n\trc = smk_access(tkp, key->security, MAY_READ, &ad);\n\trc = smk_bu_note(\"key watch\", tkp, key->security, MAY_READ, rc);\n\treturn rc;\n}\n#endif  \n#endif  \n\n#ifdef CONFIG_WATCH_QUEUE\n \nstatic int smack_post_notification(const struct cred *w_cred,\n\t\t\t\t   const struct cred *cred,\n\t\t\t\t   struct watch_notification *n)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *subj, *obj;\n\tint rc;\n\n\t \n\tif (n->type == WATCH_TYPE_META)\n\t\treturn 0;\n\n\tif (!cred)\n\t\treturn 0;\n\tsubj = smk_of_task(smack_cred(cred));\n\tobj = smk_of_task(smack_cred(w_cred));\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_NOTIFICATION);\n\trc = smk_access(subj, obj, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"notification\", subj, obj, MAY_WRITE, rc);\n\treturn rc;\n}\n#endif  \n\n \n#ifdef CONFIG_AUDIT\n\n \nstatic int smack_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct smack_known *skp;\n\tchar **rule = (char **)vrule;\n\t*rule = NULL;\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn -EINVAL;\n\n\tif (op != Audit_equal && op != Audit_not_equal)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(rulestr, 0);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t*rule = skp->smk_known;\n\n\treturn 0;\n}\n\n \nstatic int smack_audit_rule_known(struct audit_krule *krule)\n{\n\tstruct audit_field *f;\n\tint i;\n\n\tfor (i = 0; i < krule->field_count; i++) {\n\t\tf = &krule->fields[i];\n\n\t\tif (f->type == AUDIT_SUBJ_USER || f->type == AUDIT_OBJ_USER)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smack_audit_rule_match(u32 secid, u32 field, u32 op, void *vrule)\n{\n\tstruct smack_known *skp;\n\tchar *rule = vrule;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"Smack: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn 0;\n\n\tskp = smack_from_secid(secid);\n\n\t \n\tif (op == Audit_equal)\n\t\treturn (rule == skp->smk_known);\n\tif (op == Audit_not_equal)\n\t\treturn (rule != skp->smk_known);\n\n\treturn 0;\n}\n\n \n\n#endif  \n\n \nstatic int smack_ismaclabel(const char *name)\n{\n\treturn (strcmp(name, XATTR_SMACK_SUFFIX) == 0);\n}\n\n\n \nstatic int smack_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\tstruct smack_known *skp = smack_from_secid(secid);\n\n\tif (secdata)\n\t\t*secdata = skp->smk_known;\n\t*seclen = strlen(skp->smk_known);\n\treturn 0;\n}\n\n \nstatic int smack_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\tstruct smack_known *skp = smk_find_entry(secdata);\n\n\tif (skp)\n\t\t*secid = skp->smk_secid;\n\telse\n\t\t*secid = 0;\n\treturn 0;\n}\n\n \n\nstatic int smack_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\treturn smack_inode_setsecurity(inode, XATTR_SMACK_SUFFIX, ctx,\n\t\t\t\t       ctxlen, 0);\n}\n\nstatic int smack_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn __vfs_setxattr_noperm(&nop_mnt_idmap, dentry, XATTR_NAME_SMACK,\n\t\t\t\t     ctx, ctxlen, 0);\n}\n\nstatic int smack_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\tstruct smack_known *skp = smk_of_inode(inode);\n\n\t*ctx = skp->smk_known;\n\t*ctxlen = strlen(skp->smk_known);\n\treturn 0;\n}\n\nstatic int smack_inode_copy_up(struct dentry *dentry, struct cred **new)\n{\n\n\tstruct task_smack *tsp;\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp;\n\tstruct cred *new_creds = *new;\n\n\tif (new_creds == NULL) {\n\t\tnew_creds = prepare_creds();\n\t\tif (new_creds == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsp = smack_cred(new_creds);\n\n\t \n\tisp = smack_inode(d_inode(dentry));\n\tskp = isp->smk_inode;\n\ttsp->smk_task = skp;\n\t*new = new_creds;\n\treturn 0;\n}\n\nstatic int smack_inode_copy_up_xattr(const char *name)\n{\n\t \n\tif (strcmp(name, XATTR_NAME_SMACK) == 0)\n\t\treturn 1;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int smack_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\tstruct qstr *name,\n\t\t\t\t\tconst struct cred *old,\n\t\t\t\t\tstruct cred *new)\n{\n\tstruct task_smack *otsp = smack_cred(old);\n\tstruct task_smack *ntsp = smack_cred(new);\n\tstruct inode_smack *isp;\n\tint may;\n\n\t \n\tntsp->smk_task = otsp->smk_task;\n\n\t \n\tisp = smack_inode(d_inode(dentry->d_parent));\n\n\tif (isp->smk_flags & SMK_INODE_TRANSMUTE) {\n\t\trcu_read_lock();\n\t\tmay = smk_access_entry(otsp->smk_task->smk_known,\n\t\t\t\t       isp->smk_inode->smk_known,\n\t\t\t\t       &otsp->smk_task->smk_rules);\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (may > 0 && (may & MAY_TRANSMUTE)) {\n\t\t\tntsp->smk_task = isp->smk_inode;\n\t\t\tntsp->smk_transmuted = ntsp->smk_task;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IO_URING\n \nstatic int smack_uring_override_creds(const struct cred *new)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\tstruct task_smack *nsp = smack_cred(new);\n\n\t \n\tif (tsp->smk_task == nsp->smk_task)\n\t\treturn 0;\n\n\tif (smack_privileged_cred(CAP_MAC_OVERRIDE, current_cred()))\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\n \nstatic int smack_uring_sqpoll(void)\n{\n\tif (smack_privileged_cred(CAP_MAC_ADMIN, current_cred()))\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\n \nstatic int smack_uring_cmd(struct io_uring_cmd *ioucmd)\n{\n\tstruct file *file = ioucmd->file;\n\tstruct smk_audit_info ad;\n\tstruct task_smack *tsp;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!file)\n\t\treturn -EINVAL;\n\n\ttsp = smack_cred(file->f_cred);\n\tinode = file_inode(file);\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_tskacc(tsp, smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_credfile(file->f_cred, file, MAY_READ, rc);\n\n\treturn rc;\n}\n\n#endif  \n\nstruct lsm_blob_sizes smack_blob_sizes __ro_after_init = {\n\t.lbs_cred = sizeof(struct task_smack),\n\t.lbs_file = sizeof(struct smack_known *),\n\t.lbs_inode = sizeof(struct inode_smack),\n\t.lbs_ipc = sizeof(struct smack_known *),\n\t.lbs_msg_msg = sizeof(struct smack_known *),\n\t.lbs_superblock = sizeof(struct superblock_smack),\n\t.lbs_xattr_count = SMACK_INODE_INIT_XATTRS,\n};\n\nstatic struct security_hook_list smack_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),\n\tLSM_HOOK_INIT(syslog, smack_syslog),\n\n\tLSM_HOOK_INIT(fs_context_submount, smack_fs_context_submount),\n\tLSM_HOOK_INIT(fs_context_dup, smack_fs_context_dup),\n\tLSM_HOOK_INIT(fs_context_parse_param, smack_fs_context_parse_param),\n\n\tLSM_HOOK_INIT(sb_alloc_security, smack_sb_alloc_security),\n\tLSM_HOOK_INIT(sb_free_mnt_opts, smack_free_mnt_opts),\n\tLSM_HOOK_INIT(sb_eat_lsm_opts, smack_sb_eat_lsm_opts),\n\tLSM_HOOK_INIT(sb_statfs, smack_sb_statfs),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),\n\n\tLSM_HOOK_INIT(bprm_creds_for_exec, smack_bprm_creds_for_exec),\n\n\tLSM_HOOK_INIT(inode_alloc_security, smack_inode_alloc_security),\n\tLSM_HOOK_INIT(inode_init_security, smack_inode_init_security),\n\tLSM_HOOK_INIT(inode_link, smack_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, smack_inode_unlink),\n\tLSM_HOOK_INIT(inode_rmdir, smack_inode_rmdir),\n\tLSM_HOOK_INIT(inode_rename, smack_inode_rename),\n\tLSM_HOOK_INIT(inode_permission, smack_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, smack_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, smack_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, smack_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, smack_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, smack_inode_getxattr),\n\tLSM_HOOK_INIT(inode_removexattr, smack_inode_removexattr),\n\tLSM_HOOK_INIT(inode_set_acl, smack_inode_set_acl),\n\tLSM_HOOK_INIT(inode_get_acl, smack_inode_get_acl),\n\tLSM_HOOK_INIT(inode_remove_acl, smack_inode_remove_acl),\n\tLSM_HOOK_INIT(inode_getsecurity, smack_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, smack_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, smack_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, smack_inode_getsecid),\n\n\tLSM_HOOK_INIT(file_alloc_security, smack_file_alloc_security),\n\tLSM_HOOK_INIT(file_ioctl, smack_file_ioctl),\n\tLSM_HOOK_INIT(file_lock, smack_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, smack_file_fcntl),\n\tLSM_HOOK_INIT(mmap_file, smack_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, cap_mmap_addr),\n\tLSM_HOOK_INIT(file_set_fowner, smack_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, smack_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, smack_file_receive),\n\n\tLSM_HOOK_INIT(file_open, smack_file_open),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, smack_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, smack_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, smack_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, smack_cred_transfer),\n\tLSM_HOOK_INIT(cred_getsecid, smack_cred_getsecid),\n\tLSM_HOOK_INIT(kernel_act_as, smack_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, smack_kernel_create_files_as),\n\tLSM_HOOK_INIT(task_setpgid, smack_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, smack_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, smack_task_getsid),\n\tLSM_HOOK_INIT(current_getsecid_subj, smack_current_getsecid_subj),\n\tLSM_HOOK_INIT(task_getsecid_obj, smack_task_getsecid_obj),\n\tLSM_HOOK_INIT(task_setnice, smack_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, smack_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, smack_task_getioprio),\n\tLSM_HOOK_INIT(task_setscheduler, smack_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, smack_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, smack_task_movememory),\n\tLSM_HOOK_INIT(task_kill, smack_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, smack_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, smack_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, smack_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_msg_alloc_security, smack_msg_msg_alloc_security),\n\n\tLSM_HOOK_INIT(msg_queue_alloc_security, smack_ipc_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_associate, smack_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, smack_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, smack_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, smack_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_alloc_security, smack_ipc_alloc_security),\n\tLSM_HOOK_INIT(shm_associate, smack_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, smack_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, smack_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_alloc_security, smack_ipc_alloc_security),\n\tLSM_HOOK_INIT(sem_associate, smack_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, smack_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, smack_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, smack_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, smack_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, smack_setprocattr),\n\n\tLSM_HOOK_INIT(unix_stream_connect, smack_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, smack_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_post_create, smack_socket_post_create),\n\tLSM_HOOK_INIT(socket_socketpair, smack_socket_socketpair),\n#ifdef SMACK_IPV6_PORT_LABELING\n\tLSM_HOOK_INIT(socket_bind, smack_socket_bind),\n#endif\n\tLSM_HOOK_INIT(socket_connect, smack_socket_connect),\n\tLSM_HOOK_INIT(socket_sendmsg, smack_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, smack_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream, smack_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, smack_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_alloc_security, smack_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, smack_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, smack_sk_clone_security),\n\tLSM_HOOK_INIT(sock_graft, smack_sock_graft),\n\tLSM_HOOK_INIT(inet_conn_request, smack_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, smack_inet_csk_clone),\n\n  \n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, smack_key_alloc),\n\tLSM_HOOK_INIT(key_free, smack_key_free),\n\tLSM_HOOK_INIT(key_permission, smack_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, smack_key_getsecurity),\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\tLSM_HOOK_INIT(watch_key, smack_watch_key),\n#endif\n#endif  \n\n#ifdef CONFIG_WATCH_QUEUE\n\tLSM_HOOK_INIT(post_notification, smack_post_notification),\n#endif\n\n  \n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, smack_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, smack_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, smack_audit_rule_match),\n#endif  \n\n\tLSM_HOOK_INIT(ismaclabel, smack_ismaclabel),\n\tLSM_HOOK_INIT(secid_to_secctx, smack_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, smack_secctx_to_secid),\n\tLSM_HOOK_INIT(inode_notifysecctx, smack_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, smack_inode_setsecctx),\n\tLSM_HOOK_INIT(inode_getsecctx, smack_inode_getsecctx),\n\tLSM_HOOK_INIT(inode_copy_up, smack_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, smack_inode_copy_up_xattr),\n\tLSM_HOOK_INIT(dentry_create_files_as, smack_dentry_create_files_as),\n#ifdef CONFIG_IO_URING\n\tLSM_HOOK_INIT(uring_override_creds, smack_uring_override_creds),\n\tLSM_HOOK_INIT(uring_sqpoll, smack_uring_sqpoll),\n\tLSM_HOOK_INIT(uring_cmd, smack_uring_cmd),\n#endif\n};\n\n\nstatic __init void init_smack_known_list(void)\n{\n\t \n\tmutex_init(&smack_known_huh.smk_rules_lock);\n\tmutex_init(&smack_known_hat.smk_rules_lock);\n\tmutex_init(&smack_known_floor.smk_rules_lock);\n\tmutex_init(&smack_known_star.smk_rules_lock);\n\tmutex_init(&smack_known_web.smk_rules_lock);\n\t \n\tINIT_LIST_HEAD(&smack_known_huh.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_hat.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_star.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_floor.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_web.smk_rules);\n\t \n\tsmk_insert_entry(&smack_known_huh);\n\tsmk_insert_entry(&smack_known_hat);\n\tsmk_insert_entry(&smack_known_star);\n\tsmk_insert_entry(&smack_known_floor);\n\tsmk_insert_entry(&smack_known_web);\n}\n\n \nstatic __init int smack_init(void)\n{\n\tstruct cred *cred = (struct cred *) current->cred;\n\tstruct task_smack *tsp;\n\n\tsmack_rule_cache = KMEM_CACHE(smack_rule, 0);\n\tif (!smack_rule_cache)\n\t\treturn -ENOMEM;\n\n\t \n\ttsp = smack_cred(cred);\n\tinit_task_smack(tsp, &smack_known_floor, &smack_known_floor);\n\n\t \n\tsecurity_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), \"smack\");\n\tsmack_enabled = 1;\n\n\tpr_info(\"Smack:  Initializing.\\n\");\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\tpr_info(\"Smack:  Netfilter enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\tpr_info(\"Smack:  IPv6 port labeling enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tpr_info(\"Smack:  IPv6 Netfilter enabled.\\n\");\n#endif\n\n\t \n\tinit_smack_known_list();\n\n\treturn 0;\n}\n\n \nDEFINE_LSM(smack) = {\n\t.name = \"smack\",\n\t.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,\n\t.blobs = &smack_blob_sizes,\n\t.init = smack_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}