{
  "module_name": "smack_access.c",
  "hash_id": "a1553f4b5218fd52976320e9d4e6b82a6f8e360f7b54407b152a0fb1ca23b19b",
  "original_prompt": "Ingested from linux-6.6.14/security/smack/smack_access.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include \"smack.h\"\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\n\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\n\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\n\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nLIST_HEAD(smack_known_list);\n\n \nstatic u32 smack_next_secid = 10;\n\n \nint log_policy = SMACK_AUDIT_DENIED;\n\n \nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tint may = srp->smk_access;\n\t\t\t \n\t\t\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\t\t\tmay |= MAY_LOCK;\n\t\t\treturn may;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n \nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t \n\t \n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t \n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t \n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t \n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t \n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t \n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t \n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}\n\n \nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t \n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t \n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t \n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}\n\n \nint smk_curacc(struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct task_smack *tsp = smack_cred(current_cred());\n\n\treturn smk_tskacc(tsp, obj_known, mode, a);\n}\n\n#ifdef CONFIG_AUDIT\n \nstatic inline void smack_str_from_perm(char *string, int access)\n{\n\tint i = 0;\n\n\tif (access & MAY_READ)\n\t\tstring[i++] = 'r';\n\tif (access & MAY_WRITE)\n\t\tstring[i++] = 'w';\n\tif (access & MAY_EXEC)\n\t\tstring[i++] = 'x';\n\tif (access & MAY_APPEND)\n\t\tstring[i++] = 'a';\n\tif (access & MAY_TRANSMUTE)\n\t\tstring[i++] = 't';\n\tif (access & MAY_LOCK)\n\t\tstring[i++] = 'l';\n\tstring[i] = '\\0';\n}\n \nstatic void smack_log_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\tstruct smack_audit_data *sad = ad->smack_audit_data;\n\taudit_log_format(ab, \"lsm=SMACK fn=%s action=%s\",\n\t\t\t ad->smack_audit_data->function,\n\t\t\t sad->result ? \"denied\" : \"granted\");\n\taudit_log_format(ab, \" subject=\");\n\taudit_log_untrustedstring(ab, sad->subject);\n\taudit_log_format(ab, \" object=\");\n\taudit_log_untrustedstring(ab, sad->object);\n\tif (sad->request[0] == '\\0')\n\t\taudit_log_format(ab, \" labels_differ\");\n\telse\n\t\taudit_log_format(ab, \" requested=%s\", sad->request);\n}\n\n \nvoid smack_log(char *subject_label, char *object_label, int request,\n\t       int result, struct smk_audit_info *ad)\n{\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 5];\n#else\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\n#endif\n\tstruct smack_audit_data *sad;\n\tstruct common_audit_data *a = &ad->a;\n\n\t \n\tif (result < 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\n\t\treturn;\n\tif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\n\t\treturn;\n\n\tsad = a->smack_audit_data;\n\n\tif (sad->function == NULL)\n\t\tsad->function = \"unknown\";\n\n\t \n\tsmack_str_from_perm(request_buffer, request);\n\tsad->subject = subject_label;\n\tsad->object  = object_label;\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t \n\tif (result == SMACK_UNCONFINED_SUBJECT)\n\t\tstrcat(request_buffer, \"(US)\");\n\telse if (result == SMACK_UNCONFINED_OBJECT)\n\t\tstrcat(request_buffer, \"(UO)\");\n\n\tif (result > 0)\n\t\tresult = 0;\n#endif\n\tsad->request = request_buffer;\n\tsad->result  = result;\n\n\tcommon_lsm_audit(a, smack_log_callback, NULL);\n}\n#else  \nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}\n#endif\n\nDEFINE_MUTEX(smack_known_lock);\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\n \nvoid smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}\n\n \nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}\n\n \nchar *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t \n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kstrndup(string, i, GFP_NOFS);\n\tif (!smack)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn smack;\n}\n\n \nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_NOFS);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}\n\n \nint smack_populate_secattr(struct smack_known *skp)\n{\n\tint slen;\n\n\tskp->smk_netlabel.attr.secid = skp->smk_secid;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (skp->smk_netlabel.cache != NULL) {\n\t\tskp->smk_netlabel.flags |= NETLBL_SECATTR_CACHE;\n\t\tskp->smk_netlabel.cache->free = NULL;\n\t\tskp->smk_netlabel.cache->data = skp;\n\t}\n\tskp->smk_netlabel.flags |= NETLBL_SECATTR_SECID |\n\t\t\t\t   NETLBL_SECATTR_MLS_LVL |\n\t\t\t\t   NETLBL_SECATTR_DOMAIN;\n\t \n\tslen = strlen(skp->smk_known);\n\tif (slen < SMK_CIPSOLEN)\n\t\treturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t\t      &skp->smk_netlabel, slen);\n\n\treturn smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t      &skp->smk_netlabel, sizeof(skp->smk_secid));\n}\n\n \nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_NOFS);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\n\trc = smack_populate_secattr(skp);\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t \n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}\n\n \nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t \n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}\n\n \nLIST_HEAD(smack_onlycap_list);\nDEFINE_MUTEX(smack_onlycap_lock);\n\n \nbool smack_privileged_cred(int cap, const struct cred *cred)\n{\n\tstruct task_smack *tsp = smack_cred(cred);\n\tstruct smack_known *skp = tsp->smk_task;\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\trc = cap_capable(cred, &init_user_ns, cap, CAP_OPT_NONE);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}\n\n \nbool smack_privileged(int cap)\n{\n\t \n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn smack_privileged_cred(cap, current_cred());\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}