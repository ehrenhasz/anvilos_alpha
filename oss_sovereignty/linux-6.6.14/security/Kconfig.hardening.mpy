{
  "module_name": "Kconfig.hardening",
  "hash_id": "fe9524f99bdb64bb8a1b22250c126bc0dff18aee166888272141911173da37ab",
  "original_prompt": "Ingested from linux-6.6.14/security/Kconfig.hardening",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"Kernel hardening options\"\n\nconfig GCC_PLUGIN_STRUCTLEAK\n\tbool\n\thelp\n\t  While the kernel is built with warnings enabled for any missed\n\t  stack variable initializations, this warning is silenced for\n\t  anything passed by reference to another function, under the\n\t  occasionally misguided assumption that the function will do\n\t  the initialization. As this regularly leads to exploitable\n\t  flaws, this plugin is available to identify and zero-initialize\n\t  such variables, depending on the chosen level of coverage.\n\n\t  This plugin was originally ported from grsecurity/PaX. More\n\t  information at:\n\t   * https://grsecurity.net/\n\t   * https://pax.grsecurity.net/\n\nmenu \"Memory initialization\"\n\nconfig CC_HAS_AUTO_VAR_INIT_PATTERN\n\tdef_bool $(cc-option,-ftrivial-auto-var-init=pattern)\n\nconfig CC_HAS_AUTO_VAR_INIT_ZERO_BARE\n\tdef_bool $(cc-option,-ftrivial-auto-var-init=zero)\n\nconfig CC_HAS_AUTO_VAR_INIT_ZERO_ENABLER\n\t# Clang 16 and later warn about using the -enable flag, but it\n\t# is required before then.\n\tdef_bool $(cc-option,-ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang)\n\tdepends on !CC_HAS_AUTO_VAR_INIT_ZERO_BARE\n\nconfig CC_HAS_AUTO_VAR_INIT_ZERO\n\tdef_bool CC_HAS_AUTO_VAR_INIT_ZERO_BARE || CC_HAS_AUTO_VAR_INIT_ZERO_ENABLER\n\nchoice\n\tprompt \"Initialize kernel stack variables at function entry\"\n\tdefault GCC_PLUGIN_STRUCTLEAK_BYREF_ALL if COMPILE_TEST && GCC_PLUGINS\n\tdefault INIT_STACK_ALL_PATTERN if COMPILE_TEST && CC_HAS_AUTO_VAR_INIT_PATTERN\n\tdefault INIT_STACK_ALL_ZERO if CC_HAS_AUTO_VAR_INIT_ZERO\n\tdefault INIT_STACK_NONE\n\thelp\n\t  This option enables initialization of stack variables at\n\t  function entry time. This has the possibility to have the\n\t  greatest coverage (since all functions can have their\n\t  variables initialized), but the performance impact depends\n\t  on the function calling complexity of a given workload's\n\t  syscalls.\n\n\t  This chooses the level of coverage over classes of potentially\n\t  uninitialized variables. The selected class of variable will be\n\t  initialized before use in a function.\n\n\tconfig INIT_STACK_NONE\n\t\tbool \"no automatic stack variable initialization (weakest)\"\n\t\thelp\n\t\t  Disable automatic stack variable initialization.\n\t\t  This leaves the kernel vulnerable to the standard\n\t\t  classes of uninitialized stack variable exploits\n\t\t  and information exposures.\n\n\tconfig GCC_PLUGIN_STRUCTLEAK_USER\n\t\tbool \"zero-init structs marked for userspace (weak)\"\n\t\t# Plugin can be removed once the kernel only supports GCC 12+\n\t\tdepends on GCC_PLUGINS && !CC_HAS_AUTO_VAR_INIT_ZERO\n\t\tselect GCC_PLUGIN_STRUCTLEAK\n\t\thelp\n\t\t  Zero-initialize any structures on the stack containing\n\t\t  a __user attribute. This can prevent some classes of\n\t\t  uninitialized stack variable exploits and information\n\t\t  exposures, like CVE-2013-2141:\n\t\t  https://git.kernel.org/linus/b9e146d8eb3b9eca\n\n\tconfig GCC_PLUGIN_STRUCTLEAK_BYREF\n\t\tbool \"zero-init structs passed by reference (strong)\"\n\t\t# Plugin can be removed once the kernel only supports GCC 12+\n\t\tdepends on GCC_PLUGINS && !CC_HAS_AUTO_VAR_INIT_ZERO\n\t\tdepends on !(KASAN && KASAN_STACK)\n\t\tselect GCC_PLUGIN_STRUCTLEAK\n\t\thelp\n\t\t  Zero-initialize any structures on the stack that may\n\t\t  be passed by reference and had not already been\n\t\t  explicitly initialized. This can prevent most classes\n\t\t  of uninitialized stack variable exploits and information\n\t\t  exposures, like CVE-2017-1000410:\n\t\t  https://git.kernel.org/linus/06e7e776ca4d3654\n\n\t\t  As a side-effect, this keeps a lot of variables on the\n\t\t  stack that can otherwise be optimized out, so combining\n\t\t  this with CONFIG_KASAN_STACK can lead to a stack overflow\n\t\t  and is disallowed.\n\n\tconfig GCC_PLUGIN_STRUCTLEAK_BYREF_ALL\n\t\tbool \"zero-init everything passed by reference (very strong)\"\n\t\t# Plugin can be removed once the kernel only supports GCC 12+\n\t\tdepends on GCC_PLUGINS && !CC_HAS_AUTO_VAR_INIT_ZERO\n\t\tdepends on !(KASAN && KASAN_STACK)\n\t\tselect GCC_PLUGIN_STRUCTLEAK\n\t\thelp\n\t\t  Zero-initialize any stack variables that may be passed\n\t\t  by reference and had not already been explicitly\n\t\t  initialized. This is intended to eliminate all classes\n\t\t  of uninitialized stack variable exploits and information\n\t\t  exposures.\n\n\t\t  As a side-effect, this keeps a lot of variables on the\n\t\t  stack that can otherwise be optimized out, so combining\n\t\t  this with CONFIG_KASAN_STACK can lead to a stack overflow\n\t\t  and is disallowed.\n\n\tconfig INIT_STACK_ALL_PATTERN\n\t\tbool \"pattern-init everything (strongest)\"\n\t\tdepends on CC_HAS_AUTO_VAR_INIT_PATTERN\n\t\tdepends on !KMSAN\n\t\thelp\n\t\t  Initializes everything on the stack (including padding)\n\t\t  with a specific debug value. This is intended to eliminate\n\t\t  all classes of uninitialized stack variable exploits and\n\t\t  information exposures, even variables that were warned about\n\t\t  having been left uninitialized.\n\n\t\t  Pattern initialization is known to provoke many existing bugs\n\t\t  related to uninitialized locals, e.g. pointers receive\n\t\t  non-NULL values, buffer sizes and indices are very big. The\n\t\t  pattern is situation-specific; Clang on 64-bit uses 0xAA\n\t\t  repeating for all types and padding except float and double\n\t\t  which use 0xFF repeating (-NaN). Clang on 32-bit uses 0xFF\n\t\t  repeating for all types and padding.\n\n\tconfig INIT_STACK_ALL_ZERO\n\t\tbool \"zero-init everything (strongest and safest)\"\n\t\tdepends on CC_HAS_AUTO_VAR_INIT_ZERO\n\t\tdepends on !KMSAN\n\t\thelp\n\t\t  Initializes everything on the stack (including padding)\n\t\t  with a zero value. This is intended to eliminate all\n\t\t  classes of uninitialized stack variable exploits and\n\t\t  information exposures, even variables that were warned\n\t\t  about having been left uninitialized.\n\n\t\t  Zero initialization provides safe defaults for strings\n\t\t  (immediately NUL-terminated), pointers (NULL), indices\n\t\t  (index 0), and sizes (0 length), so it is therefore more\n\t\t  suitable as a production security mitigation than pattern\n\t\t  initialization.\n\nendchoice\n\nconfig GCC_PLUGIN_STRUCTLEAK_VERBOSE\n\tbool \"Report forcefully initialized variables\"\n\tdepends on GCC_PLUGIN_STRUCTLEAK\n\tdepends on !COMPILE_TEST\t# too noisy\n\thelp\n\t  This option will cause a warning to be printed each time the\n\t  structleak plugin finds a variable it thinks needs to be\n\t  initialized. Since not all existing initializers are detected\n\t  by the plugin, this can produce false positive warnings.\n\nconfig GCC_PLUGIN_STACKLEAK\n\tbool \"Poison kernel stack before returning from syscalls\"\n\tdepends on GCC_PLUGINS\n\tdepends on HAVE_ARCH_STACKLEAK\n\thelp\n\t  This option makes the kernel erase the kernel stack before\n\t  returning from system calls. This has the effect of leaving\n\t  the stack initialized to the poison value, which both reduces\n\t  the lifetime of any sensitive stack contents and reduces\n\t  potential for uninitialized stack variable exploits or information\n\t  exposures (it does not cover functions reaching the same stack\n\t  depth as prior functions during the same syscall). This blocks\n\t  most uninitialized stack variable attacks, with the performance\n\t  impact being driven by the depth of the stack usage, rather than\n\t  the function calling complexity.\n\n\t  The performance impact on a single CPU system kernel compilation\n\t  sees a 1% slowdown, other systems and workloads may vary and you\n\t  are advised to test this feature on your expected workload before\n\t  deploying it.\n\n\t  This plugin was ported from grsecurity/PaX. More information at:\n\t   * https://grsecurity.net/\n\t   * https://pax.grsecurity.net/\n\nconfig GCC_PLUGIN_STACKLEAK_VERBOSE\n\tbool \"Report stack depth analysis instrumentation\" if EXPERT\n\tdepends on GCC_PLUGIN_STACKLEAK\n\tdepends on !COMPILE_TEST\t# too noisy\n\thelp\n\t  This option will cause a warning to be printed each time the\n\t  stackleak plugin finds a function it thinks needs to be\n\t  instrumented. This is useful for comparing coverage between\n\t  builds.\n\nconfig STACKLEAK_TRACK_MIN_SIZE\n\tint \"Minimum stack frame size of functions tracked by STACKLEAK\"\n\tdefault 100\n\trange 0 4096\n\tdepends on GCC_PLUGIN_STACKLEAK\n\thelp\n\t  The STACKLEAK gcc plugin instruments the kernel code for tracking\n\t  the lowest border of the kernel stack (and for some other purposes).\n\t  It inserts the stackleak_track_stack() call for the functions with\n\t  a stack frame size greater than or equal to this parameter.\n\t  If unsure, leave the default value 100.\n\nconfig STACKLEAK_METRICS\n\tbool \"Show STACKLEAK metrics in the /proc file system\"\n\tdepends on GCC_PLUGIN_STACKLEAK\n\tdepends on PROC_FS\n\thelp\n\t  If this is set, STACKLEAK metrics for every task are available in\n\t  the /proc file system. In particular, /proc/<pid>/stack_depth\n\t  shows the maximum kernel stack consumption for the current and\n\t  previous syscalls. Although this information is not precise, it\n\t  can be useful for estimating the STACKLEAK performance impact for\n\t  your workloads.\n\nconfig STACKLEAK_RUNTIME_DISABLE\n\tbool \"Allow runtime disabling of kernel stack erasing\"\n\tdepends on GCC_PLUGIN_STACKLEAK\n\thelp\n\t  This option provides 'stack_erasing' sysctl, which can be used in\n\t  runtime to control kernel stack erasing for kernels built with\n\t  CONFIG_GCC_PLUGIN_STACKLEAK.\n\nconfig INIT_ON_ALLOC_DEFAULT_ON\n\tbool \"Enable heap memory zeroing on allocation by default\"\n\tdepends on !KMSAN\n\thelp\n\t  This has the effect of setting \"init_on_alloc=1\" on the kernel\n\t  command line. This can be disabled with \"init_on_alloc=0\".\n\t  When \"init_on_alloc\" is enabled, all page allocator and slab\n\t  allocator memory will be zeroed when allocated, eliminating\n\t  many kinds of \"uninitialized heap memory\" flaws, especially\n\t  heap content exposures. The performance impact varies by\n\t  workload, but most cases see <1% impact. Some synthetic\n\t  workloads have measured as high as 7%.\n\nconfig INIT_ON_FREE_DEFAULT_ON\n\tbool \"Enable heap memory zeroing on free by default\"\n\tdepends on !KMSAN\n\thelp\n\t  This has the effect of setting \"init_on_free=1\" on the kernel\n\t  command line. This can be disabled with \"init_on_free=0\".\n\t  Similar to \"init_on_alloc\", when \"init_on_free\" is enabled,\n\t  all page allocator and slab allocator memory will be zeroed\n\t  when freed, eliminating many kinds of \"uninitialized heap memory\"\n\t  flaws, especially heap content exposures. The primary difference\n\t  with \"init_on_free\" is that data lifetime in memory is reduced,\n\t  as anything freed is wiped immediately, making live forensics or\n\t  cold boot memory attacks unable to recover freed memory contents.\n\t  The performance impact varies by workload, but is more expensive\n\t  than \"init_on_alloc\" due to the negative cache effects of\n\t  touching \"cold\" memory areas. Most cases see 3-5% impact. Some\n\t  synthetic workloads have measured as high as 8%.\n\nconfig CC_HAS_ZERO_CALL_USED_REGS\n\tdef_bool $(cc-option,-fzero-call-used-regs=used-gpr)\n\t# https://github.com/ClangBuiltLinux/linux/issues/1766\n\t# https://github.com/llvm/llvm-project/issues/59242\n\tdepends on !CC_IS_CLANG || CLANG_VERSION > 150006\n\nconfig ZERO_CALL_USED_REGS\n\tbool \"Enable register zeroing on function exit\"\n\tdepends on CC_HAS_ZERO_CALL_USED_REGS\n\thelp\n\t  At the end of functions, always zero any caller-used register\n\t  contents. This helps ensure that temporary values are not\n\t  leaked beyond the function boundary. This means that register\n\t  contents are less likely to be available for side channels\n\t  and information exposures. Additionally, this helps reduce the\n\t  number of useful ROP gadgets by about 20% (and removes compiler\n\t  generated \"write-what-where\" gadgets) in the resulting kernel\n\t  image. This has a less than 1% performance impact on most\n\t  workloads. Image size growth depends on architecture, and should\n\t  be evaluated for suitability. For example, x86_64 grows by less\n\t  than 1%, and arm64 grows by about 5%.\n\nendmenu\n\nmenu \"Hardening of kernel data structures\"\n\nconfig LIST_HARDENED\n\tbool \"Check integrity of linked list manipulation\"\n\thelp\n\t  Minimal integrity checking in the linked-list manipulation routines\n\t  to catch memory corruptions that are not guaranteed to result in an\n\t  immediate access fault.\n\n\t  If unsure, say N.\n\nconfig BUG_ON_DATA_CORRUPTION\n\tbool \"Trigger a BUG when data corruption is detected\"\n\tselect LIST_HARDENED\n\thelp\n\t  Select this option if the kernel should BUG when it encounters\n\t  data corruption in kernel memory structures when they get checked\n\t  for validity.\n\n\t  If unsure, say N.\n\nendmenu\n\nconfig CC_HAS_RANDSTRUCT\n\tdef_bool $(cc-option,-frandomize-layout-seed-file=/dev/null)\n\t# Randstruct was first added in Clang 15, but it isn't safe to use until\n\t# Clang 16 due to https://github.com/llvm/llvm-project/issues/60349\n\tdepends on !CC_IS_CLANG || CLANG_VERSION >= 160000\n\nchoice\n\tprompt \"Randomize layout of sensitive kernel structures\"\n\tdefault RANDSTRUCT_FULL if COMPILE_TEST && (GCC_PLUGINS || CC_HAS_RANDSTRUCT)\n\tdefault RANDSTRUCT_NONE\n\thelp\n\t  If you enable this, the layouts of structures that are entirely\n\t  function pointers (and have not been manually annotated with\n\t  __no_randomize_layout), or structures that have been explicitly\n\t  marked with __randomize_layout, will be randomized at compile-time.\n\t  This can introduce the requirement of an additional information\n\t  exposure vulnerability for exploits targeting these structure\n\t  types.\n\n\t  Enabling this feature will introduce some performance impact,\n\t  slightly increase memory usage, and prevent the use of forensic\n\t  tools like Volatility against the system (unless the kernel\n\t  source tree isn't cleaned after kernel installation).\n\n\t  The seed used for compilation is in scripts/basic/randomize.seed.\n\t  It remains after a \"make clean\" to allow for external modules to\n\t  be compiled with the existing seed and will be removed by a\n\t  \"make mrproper\" or \"make distclean\". This file should not be made\n\t  public, or the structure layout can be determined.\n\n\tconfig RANDSTRUCT_NONE\n\t\tbool \"Disable structure layout randomization\"\n\t\thelp\n\t\t  Build normally: no structure layout randomization.\n\n\tconfig RANDSTRUCT_FULL\n\t\tbool \"Fully randomize structure layout\"\n\t\tdepends on CC_HAS_RANDSTRUCT || GCC_PLUGINS\n\t\tselect MODVERSIONS if MODULES\n\t\thelp\n\t\t  Fully randomize the member layout of sensitive\n\t\t  structures as much as possible, which may have both a\n\t\t  memory size and performance impact.\n\n\t\t  One difference between the Clang and GCC plugin\n\t\t  implementations is the handling of bitfields. The GCC\n\t\t  plugin treats them as fully separate variables,\n\t\t  introducing sometimes significant padding. Clang tries\n\t\t  to keep adjacent bitfields together, but with their bit\n\t\t  ordering randomized.\n\n\tconfig RANDSTRUCT_PERFORMANCE\n\t\tbool \"Limit randomization of structure layout to cache-lines\"\n\t\tdepends on GCC_PLUGINS\n\t\tselect MODVERSIONS if MODULES\n\t\thelp\n\t\t  Randomization of sensitive kernel structures will make a\n\t\t  best effort at restricting randomization to cacheline-sized\n\t\t  groups of members. It will further not randomize bitfields\n\t\t  in structures. This reduces the performance hit of RANDSTRUCT\n\t\t  at the cost of weakened randomization.\nendchoice\n\nconfig RANDSTRUCT\n\tdef_bool !RANDSTRUCT_NONE\n\nconfig GCC_PLUGIN_RANDSTRUCT\n\tdef_bool GCC_PLUGINS && RANDSTRUCT\n\thelp\n\t  Use GCC plugin to randomize structure layout.\n\n\t  This plugin was ported from grsecurity/PaX. More\n\t  information at:\n\t   * https://grsecurity.net/\n\t   * https://pax.grsecurity.net/\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}