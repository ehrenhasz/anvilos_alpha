{
  "module_name": "yama_lsm.c",
  "hash_id": "ef1592717a6b21a3ffb77f184f7f6130800346487fc9cc65e97d2ef03b293c85",
  "original_prompt": "Ingested from linux-6.6.14/security/yama/yama_lsm.c",
  "human_readable_source": "\n \n\n#include <linux/lsm_hooks.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/prctl.h>\n#include <linux/ratelimit.h>\n#include <linux/workqueue.h>\n#include <linux/string_helpers.h>\n#include <linux/task_work.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define YAMA_SCOPE_DISABLED\t0\n#define YAMA_SCOPE_RELATIONAL\t1\n#define YAMA_SCOPE_CAPABILITY\t2\n#define YAMA_SCOPE_NO_ATTACH\t3\n\nstatic int ptrace_scope = YAMA_SCOPE_RELATIONAL;\n\n \nstruct ptrace_relation {\n\tstruct task_struct *tracer;\n\tstruct task_struct *tracee;\n\tbool invalid;\n\tstruct list_head node;\n\tstruct rcu_head rcu;\n};\n\nstatic LIST_HEAD(ptracer_relations);\nstatic DEFINE_SPINLOCK(ptracer_relations_lock);\n\nstatic void yama_relation_cleanup(struct work_struct *work);\nstatic DECLARE_WORK(yama_relation_work, yama_relation_cleanup);\n\nstruct access_report_info {\n\tstruct callback_head work;\n\tconst char *access;\n\tstruct task_struct *target;\n\tstruct task_struct *agent;\n};\n\nstatic void __report_access(struct callback_head *work)\n{\n\tstruct access_report_info *info =\n\t\tcontainer_of(work, struct access_report_info, work);\n\tchar *target_cmd, *agent_cmd;\n\n\ttarget_cmd = kstrdup_quotable_cmdline(info->target, GFP_KERNEL);\n\tagent_cmd = kstrdup_quotable_cmdline(info->agent, GFP_KERNEL);\n\n\tpr_notice_ratelimited(\n\t\t\"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\tinfo->access, target_cmd, info->target->pid, agent_cmd,\n\t\tinfo->agent->pid);\n\n\tkfree(agent_cmd);\n\tkfree(target_cmd);\n\n\tput_task_struct(info->agent);\n\tput_task_struct(info->target);\n\tkfree(info);\n}\n\n \nstatic void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock);  \n\n\tif (current->flags & PF_KTHREAD) {\n\t\t \n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, TWA_RESUME) == 0)\n\t\treturn;  \n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}\n\n \nstatic void yama_relation_cleanup(struct work_struct *work)\n{\n\tstruct ptrace_relation *relation;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid) {\n\t\t\tlist_del_rcu(&relation->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t}\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n}\n\n \nstatic int yama_ptracer_add(struct task_struct *tracer,\n\t\t\t    struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation, *added;\n\n\tadded = kmalloc(sizeof(*added), GFP_KERNEL);\n\tif (!added)\n\t\treturn -ENOMEM;\n\n\tadded->tracee = tracee;\n\tadded->tracer = tracer;\n\tadded->invalid = false;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tlist_replace_rcu(&relation->node, &added->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_rcu(&added->node, &ptracer_relations);\n\nout:\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n\treturn 0;\n}\n\n \nstatic void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}\n\n \nstatic void yama_task_free(struct task_struct *task)\n{\n\tyama_ptracer_del(task, task);\n}\n\n \nstatic int yama_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tint rc = -ENOSYS;\n\tstruct task_struct *myself = current;\n\n\tswitch (option) {\n\tcase PR_SET_PTRACER:\n\t\t \n\t\trcu_read_lock();\n\t\tif (!thread_group_leader(myself))\n\t\t\tmyself = rcu_dereference(myself->group_leader);\n\t\tget_task_struct(myself);\n\t\trcu_read_unlock();\n\n\t\tif (arg2 == 0) {\n\t\t\tyama_ptracer_del(NULL, myself);\n\t\t\trc = 0;\n\t\t} else if (arg2 == PR_SET_PTRACER_ANY || (int)arg2 == -1) {\n\t\t\trc = yama_ptracer_add(NULL, myself);\n\t\t} else {\n\t\t\tstruct task_struct *tracer;\n\n\t\t\ttracer = find_get_task_by_vpid(arg2);\n\t\t\tif (!tracer) {\n\t\t\t\trc = -EINVAL;\n\t\t\t} else {\n\t\t\t\trc = yama_ptracer_add(tracer, myself);\n\t\t\t\tput_task_struct(tracer);\n\t\t\t}\n\t\t}\n\n\t\tput_task_struct(myself);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n \nstatic int ptracer_exception_found(struct task_struct *tracer,\n\t\t\t\t   struct task_struct *tracee)\n{\n\tint rc = 0;\n\tstruct ptrace_relation *relation;\n\tstruct task_struct *parent = NULL;\n\tbool found = false;\n\n\trcu_read_lock();\n\n\t \n\tparent = ptrace_parent(tracee);\n\tif (parent != NULL && same_thread_group(parent, tracer)) {\n\t\trc = 1;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!thread_group_leader(tracee))\n\t\ttracee = rcu_dereference(tracee->group_leader);\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tparent = relation->tracer;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (parent == NULL || task_is_descendant(parent, tracer)))\n\t\trc = 1;\n\nunlock:\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n \nstatic int yama_ptrace_access_check(struct task_struct *child,\n\t\t\t\t    unsigned int mode)\n{\n\tint rc = 0;\n\n\t \n\tif (mode & PTRACE_MODE_ATTACH) {\n\t\tswitch (ptrace_scope) {\n\t\tcase YAMA_SCOPE_DISABLED:\n\t\t\t \n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_RELATIONAL:\n\t\t\trcu_read_lock();\n\t\t\tif (!pid_alive(child))\n\t\t\t\trc = -EPERM;\n\t\t\tif (!rc && !task_is_descendant(current, child) &&\n\t\t\t    !ptracer_exception_found(current, child) &&\n\t\t\t    !ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_CAPABILITY:\n\t\t\trcu_read_lock();\n\t\t\tif (!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_NO_ATTACH:\n\t\tdefault:\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc && (mode & PTRACE_MODE_NOAUDIT) == 0)\n\t\treport_access(\"attach\", child, current);\n\n\treturn rc;\n}\n\n \nstatic int yama_ptrace_traceme(struct task_struct *parent)\n{\n\tint rc = 0;\n\n\t \n\tswitch (ptrace_scope) {\n\tcase YAMA_SCOPE_CAPABILITY:\n\t\tif (!has_ns_capability(parent, current_user_ns(), CAP_SYS_PTRACE))\n\t\t\trc = -EPERM;\n\t\tbreak;\n\tcase YAMA_SCOPE_NO_ATTACH:\n\t\trc = -EPERM;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\ttask_lock(current);\n\t\treport_access(\"traceme\", current, parent);\n\t\ttask_unlock(current);\n\t}\n\n\treturn rc;\n}\n\nstatic struct security_hook_list yama_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, yama_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, yama_ptrace_traceme),\n\tLSM_HOOK_INIT(task_prctl, yama_task_prctl),\n\tLSM_HOOK_INIT(task_free, yama_task_free),\n};\n\n#ifdef CONFIG_SYSCTL\nstatic int yama_dointvec_minmax(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table table_copy;\n\n\tif (write && !capable(CAP_SYS_PTRACE))\n\t\treturn -EPERM;\n\n\t \n\ttable_copy = *table;\n\tif (*(int *)table_copy.data == *(int *)table_copy.extra2)\n\t\ttable_copy.extra1 = table_copy.extra2;\n\n\treturn proc_dointvec_minmax(&table_copy, write, buffer, lenp, ppos);\n}\n\nstatic int max_scope = YAMA_SCOPE_NO_ATTACH;\n\nstatic struct ctl_table yama_sysctl_table[] = {\n\t{\n\t\t.procname       = \"ptrace_scope\",\n\t\t.data           = &ptrace_scope,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = yama_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = &max_scope,\n\t},\n\t{ }\n};\nstatic void __init yama_init_sysctl(void)\n{\n\tif (!register_sysctl(\"kernel/yama\", yama_sysctl_table))\n\t\tpanic(\"Yama: sysctl registration failed.\\n\");\n}\n#else\nstatic inline void yama_init_sysctl(void) { }\n#endif  \n\nstatic int __init yama_init(void)\n{\n\tpr_info(\"Yama: becoming mindful.\\n\");\n\tsecurity_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), \"yama\");\n\tyama_init_sysctl();\n\treturn 0;\n}\n\nDEFINE_LSM(yama) = {\n\t.name = \"yama\",\n\t.init = yama_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}