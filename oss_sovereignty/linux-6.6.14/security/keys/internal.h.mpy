{
  "module_name": "internal.h",
  "hash_id": "b3c02fe49990bb05dcae411fbddcb59855b816360260dc5b35e551b3e8757a98",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/internal.h",
  "human_readable_source": " \n \n\n#ifndef _INTERNAL_H\n#define _INTERNAL_H\n\n#include <linux/sched.h>\n#include <linux/wait_bit.h>\n#include <linux/cred.h>\n#include <linux/key-type.h>\n#include <linux/task_work.h>\n#include <linux/keyctl.h>\n#include <linux/refcount.h>\n#include <linux/watch_queue.h>\n#include <linux/compat.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct iovec;\n\n#ifdef __KDEBUG\n#define kenter(FMT, ...) \\\n\tprintk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tprintk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tprintk(KERN_DEBUG \"   \"FMT\"\\n\", ##__VA_ARGS__)\n#else\n#define kenter(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tno_printk(KERN_DEBUG FMT\"\\n\", ##__VA_ARGS__)\n#endif\n\nextern struct key_type key_type_dead;\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\n \n \nstruct key_user {\n\tstruct rb_node\t\tnode;\n\tstruct mutex\t\tcons_lock;\t \n\tspinlock_t\t\tlock;\n\trefcount_t\t\tusage;\t\t \n\tatomic_t\t\tnkeys;\t\t \n\tatomic_t\t\tnikeys;\t\t \n\tkuid_t\t\t\tuid;\n\tint\t\t\tqnkeys;\t\t \n\tint\t\t\tqnbytes;\t \n};\n\nextern struct rb_root\tkey_user_tree;\nextern spinlock_t\tkey_user_lock;\nextern struct key_user\troot_key_user;\n\nextern struct key_user *key_user_lookup(kuid_t uid);\nextern void key_user_put(struct key_user *user);\n\n \nextern unsigned key_quota_root_maxkeys;\nextern unsigned key_quota_root_maxbytes;\nextern unsigned key_quota_maxkeys;\nextern unsigned key_quota_maxbytes;\n\n#define KEYQUOTA_LINK_BYTES\t4\t\t \n\n\nextern struct kmem_cache *key_jar;\nextern struct rb_root key_serial_tree;\nextern spinlock_t key_serial_lock;\nextern struct mutex key_construction_mutex;\nextern wait_queue_head_t request_key_conswq;\n\nextern void key_set_index_key(struct keyring_index_key *index_key);\nextern struct key_type *key_type_lookup(const char *type);\nextern void key_type_put(struct key_type *ktype);\n\nextern int __key_link_lock(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key);\nextern int __key_move_lock(struct key *l_keyring, struct key *u_keyring,\n\t\t\t   const struct keyring_index_key *index_key);\nextern int __key_link_begin(struct key *keyring,\n\t\t\t    const struct keyring_index_key *index_key,\n\t\t\t    struct assoc_array_edit **_edit);\nextern int __key_link_check_live_key(struct key *keyring, struct key *key);\nextern void __key_link(struct key *keyring, struct key *key,\n\t\t       struct assoc_array_edit **_edit);\nextern void __key_link_end(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key,\n\t\t\t   struct assoc_array_edit *edit);\n\nextern key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t\t    const struct keyring_index_key *index_key);\n\nextern struct key *keyring_search_instkey(struct key *keyring,\n\t\t\t\t\t  key_serial_t target_id);\n\nextern int iterate_over_keyring(const struct key *keyring,\n\t\t\t\tint (*func)(const struct key *key, void *data),\n\t\t\t\tvoid *data);\n\nstruct keyring_search_context {\n\tstruct keyring_index_key index_key;\n\tconst struct cred\t*cred;\n\tstruct key_match_data\tmatch_data;\n\tunsigned\t\tflags;\n#define KEYRING_SEARCH_NO_STATE_CHECK\t0x0001\t \n#define KEYRING_SEARCH_DO_STATE_CHECK\t0x0002\t \n#define KEYRING_SEARCH_NO_UPDATE_TIME\t0x0004\t \n#define KEYRING_SEARCH_NO_CHECK_PERM\t0x0008\t \n#define KEYRING_SEARCH_DETECT_TOO_DEEP\t0x0010\t \n#define KEYRING_SEARCH_SKIP_EXPIRED\t0x0020\t \n#define KEYRING_SEARCH_RECURSE\t\t0x0040\t \n\n\tint (*iterator)(const void *object, void *iterator_data);\n\n\t \n\tint\t\t\tskipped_ret;\n\tbool\t\t\tpossessed;\n\tkey_ref_t\t\tresult;\n\ttime64_t\t\tnow;\n};\n\nextern bool key_default_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data);\nextern key_ref_t keyring_search_rcu(key_ref_t keyring_ref,\n\t\t\t\t    struct keyring_search_context *ctx);\n\nextern key_ref_t search_cred_keyrings_rcu(struct keyring_search_context *ctx);\nextern key_ref_t search_process_keyrings_rcu(struct keyring_search_context *ctx);\n\nextern struct key *find_keyring_by_name(const char *name, bool uid_keyring);\n\nextern int look_up_user_keyrings(struct key **, struct key **);\nextern struct key *get_user_session_keyring_rcu(const struct cred *);\nextern int install_thread_keyring_to_cred(struct cred *);\nextern int install_process_keyring_to_cred(struct cred *);\nextern int install_session_keyring_to_cred(struct cred *, struct key *);\n\nextern struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tstruct key_tag *domain_tag,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tvoid *aux,\n\t\t\t\t\tstruct key *dest_keyring,\n\t\t\t\t\tunsigned long flags);\n\nextern bool lookup_user_key_possessed(const struct key *key,\n\t\t\t\t      const struct key_match_data *match_data);\n\nextern long join_session_keyring(const char *name);\nextern void key_change_session_keyring(struct callback_head *twork);\n\nextern struct work_struct key_gc_work;\nextern unsigned key_gc_delay;\nextern void keyring_gc(struct key *keyring, time64_t limit);\nextern void keyring_restriction_gc(struct key *keyring,\n\t\t\t\t   struct key_type *dead_type);\nvoid key_set_expiry(struct key *key, time64_t expiry);\nextern void key_schedule_gc(time64_t gc_at);\nextern void key_schedule_gc_links(void);\nextern void key_gc_keytype(struct key_type *ktype);\n\nextern int key_task_permission(const key_ref_t key_ref,\n\t\t\t       const struct cred *cred,\n\t\t\t       enum key_need_perm need_perm);\n\nstatic inline void notify_key(struct key *key,\n\t\t\t      enum key_notification_subtype subtype, u32 aux)\n{\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\tstruct key_notification n = {\n\t\t.watch.type\t= WATCH_TYPE_KEY_NOTIFY,\n\t\t.watch.subtype\t= subtype,\n\t\t.watch.info\t= watch_sizeof(n),\n\t\t.key_id\t\t= key_serial(key),\n\t\t.aux\t\t= aux,\n\t};\n\n\tpost_watch_notification(key->watchers, &n.watch, current_cred(),\n\t\t\t\tn.key_id);\n#endif\n}\n\n \nstatic inline int key_permission(const key_ref_t key_ref,\n\t\t\t\t enum key_need_perm need_perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), need_perm);\n}\n\nextern struct key_type key_type_request_key_auth;\nextern struct key *request_key_auth_new(struct key *target,\n\t\t\t\t\tconst char *op,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tstruct key *dest_keyring);\n\nextern struct key *key_get_instantiation_authkey(key_serial_t target_id);\n\n \nstatic inline bool key_is_dead(const struct key *key, time64_t limit)\n{\n\ttime64_t expiry = key->expiry;\n\n\tif (expiry != TIME64_MAX) {\n\t\tif (!(key->type->flags & KEY_TYPE_INSTANT_REAP))\n\t\t\texpiry += key_gc_delay;\n\t\tif (expiry <= limit)\n\t\t\treturn true;\n\t}\n\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\tkey->domain_tag->removed;\n}\n\n \nextern long keyctl_get_keyring_ID(key_serial_t, int);\nextern long keyctl_join_session_keyring(const char __user *);\nextern long keyctl_update_key(key_serial_t, const void __user *, size_t);\nextern long keyctl_revoke_key(key_serial_t);\nextern long keyctl_keyring_clear(key_serial_t);\nextern long keyctl_keyring_link(key_serial_t, key_serial_t);\nextern long keyctl_keyring_move(key_serial_t, key_serial_t, key_serial_t, unsigned int);\nextern long keyctl_keyring_unlink(key_serial_t, key_serial_t);\nextern long keyctl_describe_key(key_serial_t, char __user *, size_t);\nextern long keyctl_keyring_search(key_serial_t, const char __user *,\n\t\t\t\t  const char __user *, key_serial_t);\nextern long keyctl_read_key(key_serial_t, char __user *, size_t);\nextern long keyctl_chown_key(key_serial_t, uid_t, gid_t);\nextern long keyctl_setperm_key(key_serial_t, key_perm_t);\nextern long keyctl_instantiate_key(key_serial_t, const void __user *,\n\t\t\t\t   size_t, key_serial_t);\nextern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);\nextern long keyctl_set_reqkey_keyring(int);\nextern long keyctl_set_timeout(key_serial_t, unsigned);\nextern long keyctl_assume_authority(key_serial_t);\nextern long keyctl_get_security(key_serial_t keyid, char __user *buffer,\n\t\t\t\tsize_t buflen);\nextern long keyctl_session_to_parent(void);\nextern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);\nextern long keyctl_instantiate_key_iov(key_serial_t,\n\t\t\t\t       const struct iovec __user *,\n\t\t\t\t       unsigned, key_serial_t);\nextern long keyctl_invalidate_key(key_serial_t);\nextern long keyctl_restrict_keyring(key_serial_t id,\n\t\t\t\t    const char __user *_type,\n\t\t\t\t    const char __user *_restriction);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\nextern long keyctl_get_persistent(uid_t, key_serial_t);\nextern unsigned persistent_keyring_expiry;\n#else\nstatic inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n#ifdef CONFIG_KEY_DH_OPERATIONS\nextern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t      size_t, struct keyctl_kdf_params __user *);\nextern long __keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t\tsize_t, struct keyctl_kdf_params *);\n#ifdef CONFIG_COMPAT\nextern long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct compat_keyctl_kdf_params __user *kdf);\n#endif\n#define KEYCTL_KDF_MAX_OUTPUT_LEN\t1024\t \n#define KEYCTL_KDF_MAX_OI_LEN\t\t64\t \n#else\nstatic inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\t     char __user *buffer, size_t buflen,\n\t\t\t\t     struct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#ifdef CONFIG_COMPAT\nstatic inline long compat_keyctl_dh_compute(\n\t\t\t\tstruct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n#endif\n\n#ifdef CONFIG_ASYMMETRIC_KEY_TYPE\nextern long keyctl_pkey_query(key_serial_t,\n\t\t\t      const char __user *,\n\t\t\t      struct keyctl_pkey_query __user *);\n\nextern long keyctl_pkey_verify(const struct keyctl_pkey_params __user *,\n\t\t\t       const char __user *,\n\t\t\t       const void __user *, const void __user *);\n\nextern long keyctl_pkey_e_d_s(int,\n\t\t\t      const struct keyctl_pkey_params __user *,\n\t\t\t      const char __user *,\n\t\t\t      const void __user *, void __user *);\n#else\nstatic inline long keyctl_pkey_query(key_serial_t id,\n\t\t\t\t     const char __user *_info,\n\t\t\t\t     struct keyctl_pkey_query __user *_res)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline long keyctl_pkey_verify(const struct keyctl_pkey_params __user *params,\n\t\t\t\t      const char __user *_info,\n\t\t\t\t      const void __user *_in,\n\t\t\t\t      const void __user *_in2)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline long keyctl_pkey_e_d_s(int op,\n\t\t\t\t     const struct keyctl_pkey_params __user *params,\n\t\t\t\t     const char __user *_info,\n\t\t\t\t     const void __user *_in,\n\t\t\t\t     void __user *_out)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nextern long keyctl_capabilities(unsigned char __user *_buffer, size_t buflen);\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\nextern long keyctl_watch_key(key_serial_t, int, int);\n#else\nstatic inline long keyctl_watch_key(key_serial_t key_id, int watch_fd, int watch_id)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \n#ifdef KEY_DEBUGGING\nextern void __key_check(const struct key *);\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}\n\n#else\n\n#define key_check(key) do {} while(0)\n\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}