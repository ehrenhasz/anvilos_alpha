{
  "module_name": "big_key.c",
  "hash_id": "5177cfde2327f5c77e1ee2d0828aacade0ce3183e8e4ab660e279b7ad1c5fed5",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/big_key.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"big_key: \"fmt\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <linux/random.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n#include <crypto/chacha20poly1305.h>\n\n \nstruct big_key_payload {\n\tu8 *data;\n\tstruct path path;\n\tsize_t length;\n};\n#define to_big_key_payload(payload)\t\t\t\\\n\t(struct big_key_payload *)((payload).data)\n\n \n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n \nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t.update\t\t\t= big_key_update,\n};\n\n \nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(prep->payload);\n\tstruct file *file;\n\tu8 *buf, *enckey;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tsize_t enclen = datalen + CHACHA20POLY1305_AUTHTAG_SIZE;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(*payload) != sizeof(prep->payload.data));\n\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\treturn -EINVAL;\n\n\t \n\tprep->quotalen = 16;\n\n\tpayload->length = datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t \n\t\tloff_t pos = 0;\n\n\t\tbuf = kvmalloc(enclen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tenckey = kmalloc(CHACHA20POLY1305_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_random_bytes_wait(enckey, CHACHA20POLY1305_KEY_SIZE);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_enckey;\n\n\t\t \n\t\tchacha20poly1305_encrypt(buf, prep->data, datalen, NULL, 0,\n\t\t\t\t\t 0, enckey);\n\n\t\t \n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, buf, enclen, &pos);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t \n\t\tpayload->data = enckey;\n\t\tpayload->path = file->f_path;\n\t\tpath_get(&payload->path);\n\t\tfput(file);\n\t\tkvfree_sensitive(buf, enclen);\n\t} else {\n\t\t \n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tpayload->data = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkfree_sensitive(enckey);\nerror:\n\tkvfree_sensitive(buf, enclen);\n\treturn ret;\n}\n\n \nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(prep->payload);\n\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD)\n\t\tpath_put(&payload->path);\n\tkfree_sensitive(payload->data);\n}\n\n \nvoid big_key_revoke(struct key *key)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(key->payload);\n\n\t \n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) && payload->length > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(&payload->path, 0);\n}\n\n \nvoid big_key_destroy(struct key *key)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(key->payload);\n\n\tif (payload->length > BIG_KEY_FILE_THRESHOLD) {\n\t\tpath_put(&payload->path);\n\t\tpayload->path.mnt = NULL;\n\t\tpayload->path.dentry = NULL;\n\t}\n\tkfree_sensitive(payload->data);\n\tpayload->data = NULL;\n}\n\n \nint big_key_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (key_is_positive(key))\n\t\tbig_key_destroy(key);\n\n\treturn generic_key_instantiate(key, prep);\n}\n\n \nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(key->payload);\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   payload->length,\n\t\t\t   payload->length > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n \nlong big_key_read(const struct key *key, char *buffer, size_t buflen)\n{\n\tstruct big_key_payload *payload = to_big_key_payload(key->payload);\n\tsize_t datalen = payload->length;\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct file *file;\n\t\tu8 *buf, *enckey = payload->data;\n\t\tsize_t enclen = datalen + CHACHA20POLY1305_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tbuf = kvmalloc(enclen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(&payload->path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tret = kernel_read(file, buf, enclen, &pos);\n\t\tif (ret != enclen) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = chacha20poly1305_decrypt(buf, buf, enclen, NULL, 0, 0,\n\t\t\t\t\t       enckey) ? 0 : -EBADMSG;\n\t\tif (unlikely(ret))\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t \n\t\tmemcpy(buffer, buf, datalen);\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkvfree_sensitive(buf, enclen);\n\t} else {\n\t\tret = datalen;\n\t\tmemcpy(buffer, payload->data, datalen);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}\n\nlate_initcall(big_key_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}