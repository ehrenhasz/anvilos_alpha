{
  "module_name": "key.c",
  "hash_id": "0295866257bdc1aaa43ddda986fd7e43227f7c31fa65fb05b2db4ffacef81501",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/key.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/ima.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree;  \nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree;  \nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 1000000;\t \nunsigned int key_quota_root_maxbytes = 25000000;  \nunsigned int key_quota_maxkeys = 200;\t\t \nunsigned int key_quota_maxbytes = 20000;\t \n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n \nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n \nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent, **p;\n\ntry_again:\n\tparent = NULL;\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t \n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t \n\tif (!candidate) {\n\t\t \n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t \n\t\tgoto try_again;\n\t}\n\n\t \n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t \nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n \nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n \nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t \n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1;  \n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t \n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t \nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n \nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t \n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t \n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 > maxkeys ||\n\t\t\t    user->qnbytes + quotalen > maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t \n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\tkey->index_key.type = type;\n\tkey_set_index_key(&key->index_key);\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->expiry = TIME64_MAX;\n\tkey->restrict_link = restrict_link;\n\tkey->last_used_at = ktime_get_real_seconds();\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\tif (flags & KEY_ALLOC_SET_KEEP)\n\t\tkey->flags |= 1 << KEY_FLAG_KEEP;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t \n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t \n\trefcount_inc(&key->domain_tag->usage);\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n \nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t \n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta > maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t \n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n \nstatic void mark_key_instantiated(struct key *key, int reject_error)\n{\n\t \n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}\n\n \nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t \n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t \n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tmark_key_instantiated(key, 0);\n\t\t\tnotify_key(key, NOTIFY_KEY_INSTANTIATED, 0);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t \n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(keyring, key, _edit);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (authkey)\n\t\t\t\tkey_invalidate(authkey);\n\n\t\t\tkey_set_expiry(key, prep->expiry);\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t \n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n \nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit = NULL;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.orig_description = key->description;\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_lock(keyring, &key->index_key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error_link_end;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n \nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit = NULL;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_lock(keyring, &key->index_key);\n\t\tif (link_ret == 0) {\n\t\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\t\tif (link_ret < 0)\n\t\t\t\t__key_link_end(keyring, &key->index_key, edit);\n\t\t}\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t \n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t \n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnotify_key(key, NOTIFY_KEY_INSTANTIATED, -error);\n\t\tkey_set_expiry(key, ktime_get_real_seconds() + timeout);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t \n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(keyring, key, &edit);\n\n\t\t \n\t\tif (authkey)\n\t\t\tkey_invalidate(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t \n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n \nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n \nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t \n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t \n\tif (!refcount_inc_not_zero(&key->usage))\n\t\tgoto not_found;\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n \nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t \n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\ttime64_t expiry = TIME64_MAX;\n\n\t \n\tdown_write(&key->sem);\n\n\tif (timeout > 0)\n\t\texpiry = ktime_get_real_seconds() + timeout;\n\tkey_set_expiry(key, expiry);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n \nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n \nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t \n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0) {\n\t\t \n\t\tmark_key_instantiated(key, 0);\n\t\tnotify_key(key, NOTIFY_KEY_UPDATED, 0);\n\t}\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n \nstatic key_ref_t __key_create_or_update(key_ref_t keyring_ref,\n\t\t\t\t\tconst char *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tconst void *payload,\n\t\t\t\t\tsize_t plen,\n\t\t\t\t\tkey_perm_t perm,\n\t\t\t\t\tunsigned long flags,\n\t\t\t\t\tbool allow_update)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit = NULL;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t \n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.orig_description = description;\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\tkey_set_index_key(&index_key);\n\n\tret = __key_link_lock(keyring, &index_key);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t \n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t \n\tif (allow_update) {\n\t\tif (index_key.type->update) {\n\t\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\t\tif (key_ref)\n\t\t\t\tgoto found_matching_key;\n\t\t}\n\t} else {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref) {\n\t\t\tkey_ref_put(key_ref);\n\t\t\tkey_ref = ERR_PTR(-EEXIST);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t \n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t \n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t \n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tima_post_key_create_or_update(keyring, key, payload, plen,\n\t\t\t\t      flags, true);\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t \n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tif (ret < 0) {\n\t\t\tkey_ref_put(key_ref);\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t}\n\n\tkey_ref = __key_update(key_ref, &prep);\n\n\tif (!IS_ERR(key_ref))\n\t\tima_post_key_create_or_update(keyring, key,\n\t\t\t\t\t      payload, plen,\n\t\t\t\t\t      flags, false);\n\n\tgoto error_free_prep;\n}\n\n \nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\treturn __key_create_or_update(keyring_ref, type, description, payload,\n\t\t\t\t      plen, perm, flags, true);\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n \nkey_ref_t key_create(key_ref_t keyring_ref,\n\t\t     const char *type,\n\t\t     const char *description,\n\t\t     const void *payload,\n\t\t     size_t plen,\n\t\t     key_perm_t perm,\n\t\t     unsigned long flags)\n{\n\treturn __key_create_or_update(keyring_ref, type, description, payload,\n\t\t\t\t      plen, perm, flags, false);\n}\nEXPORT_SYMBOL(key_create);\n\n \nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t \n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0) {\n\t\t \n\t\tmark_key_instantiated(key, 0);\n\t\tnotify_key(key, NOTIFY_KEY_UPDATED, 0);\n\t}\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n \nvoid key_revoke(struct key *key)\n{\n\ttime64_t time;\n\n\tkey_check(key);\n\n\t \n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags)) {\n\t\tnotify_key(key, NOTIFY_KEY_REVOKED, 0);\n\t\tif (key->type->revoke)\n\t\t\tkey->type->revoke(key);\n\n\t\t \n\t\ttime = ktime_get_real_seconds();\n\t\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\t\tkey->revoked_at = time;\n\t\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t\t}\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n \nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\t\tnotify_key(key, NOTIFY_KEY_INVALIDATED, 0);\n\t\t\tkey_schedule_gc_links();\n\t\t}\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n \nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\trcu_assign_keypointer(key, prep->payload.data[0]);\n\t\tkey->payload.data[1] = prep->payload.data[1];\n\t\tkey->payload.data[2] = prep->payload.data[2];\n\t\tkey->payload.data[3] = prep->payload.data[3];\n\t\tprep->payload.data[0] = NULL;\n\t\tprep->payload.data[1] = NULL;\n\t\tprep->payload.data[2] = NULL;\n\t\tprep->payload.data[3] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n \nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t \n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n \nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n \nvoid __init key_init(void)\n{\n\t \n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t \n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t \n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}