{
  "module_name": "keyctl.c",
  "hash_id": "29f44d403ab3636805225c971df403a3d4a4e0295908c5d7cb73b65e8df40c8e",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/keyctl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <keys/request_key_auth-type.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic const unsigned char keyrings_capabilities[2] = {\n\t[0] = (KEYCTL_CAPS0_CAPABILITIES |\n\t       (IS_ENABLED(CONFIG_PERSISTENT_KEYRINGS)\t? KEYCTL_CAPS0_PERSISTENT_KEYRINGS : 0) |\n\t       (IS_ENABLED(CONFIG_KEY_DH_OPERATIONS)\t? KEYCTL_CAPS0_DIFFIE_HELLMAN : 0) |\n\t       (IS_ENABLED(CONFIG_ASYMMETRIC_KEY_TYPE)\t? KEYCTL_CAPS0_PUBLIC_KEY : 0) |\n\t       (IS_ENABLED(CONFIG_BIG_KEYS)\t\t? KEYCTL_CAPS0_BIG_KEY : 0) |\n\t       KEYCTL_CAPS0_INVALIDATE |\n\t       KEYCTL_CAPS0_RESTRICT_KEYRING |\n\t       KEYCTL_CAPS0_MOVE\n\t       ),\n\t[1] = (KEYCTL_CAPS1_NS_KEYRING_NAME |\n\t       KEYCTL_CAPS1_NS_KEY_TAG |\n\t       (IS_ENABLED(CONFIG_KEY_NOTIFICATIONS)\t? KEYCTL_CAPS1_NOTIFICATIONS : 0)\n\t       ),\n};\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n \nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t \n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t \n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t \n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t \n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree_sensitive(payload, plen);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n \nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t \n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t \n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t \n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t \n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t \n\tkey = request_key_and_link(ktype, description, NULL, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t \n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t \n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t \n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t \n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t \n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t \n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkvfree_sensitive(payload, plen);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t \n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, KEY_SYSADMIN_OVERRIDE);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n \nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t \n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0,\n\t\t\t\t\t\t      KEY_SYSADMIN_OVERRIDE);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_PARTIAL, KEY_NEED_UNLINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_keyring_move(key_serial_t id, key_serial_t from_ringid,\n\t\t\t key_serial_t to_ringid, unsigned int flags)\n{\n\tkey_ref_t key_ref, from_ref, to_ref;\n\tlong ret;\n\n\tif (flags & ~KEYCTL_MOVE_EXCL)\n\t\treturn -EINVAL;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tfrom_ref = lookup_user_key(from_ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(from_ref)) {\n\t\tret = PTR_ERR(from_ref);\n\t\tgoto error2;\n\t}\n\n\tto_ref = lookup_user_key(to_ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(to_ref)) {\n\t\tret = PTR_ERR(to_ref);\n\t\tgoto error3;\n\t}\n\n\tret = key_move(key_ref_to_ptr(key_ref), key_ref_to_ptr(from_ref),\n\t\t       key_ref_to_ptr(to_ref), flags);\n\n\tkey_ref_put(to_ref);\nerror3:\n\tkey_ref_put(from_ref);\nerror2:\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n \nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t \n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  KEY_AUTHTOKEN_OVERRIDE);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t \n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t \n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t \n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t \n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t \n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t \n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t \n\tkey_ref = keyring_search(keyring_ref, ktype, description, true);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t \n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t \n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n \nstatic long __keyctl_read_key(struct key *key, char *buffer, size_t buflen)\n{\n\tlong ret;\n\n\tdown_read(&key->sem);\n\tret = key_validate(key);\n\tif (ret == 0)\n\t\tret = key->type->read(key, buffer, buflen);\n\tup_read(&key->sem);\n\treturn ret;\n}\n\n \nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tchar *key_data = NULL;\n\tsize_t key_data_len;\n\n\t \n\tkey_ref = lookup_user_key(keyid, 0, KEY_DEFER_PERM_CHECK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto key_put_out;  \n\n\t \n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto key_put_out;\n\n\t \n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto key_put_out;\n\t}\n\n\t \ncan_read_key:\n\tif (!key->type->read) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto key_put_out;\n\t}\n\n\tif (!buffer || !buflen) {\n\t\t \n\t\tret = __keyctl_read_key(key, NULL, 0);\n\t\tgoto key_put_out;\n\t}\n\n\t \n\tkey_data_len = (buflen <= PAGE_SIZE) ? buflen : 0;\n\tfor (;;) {\n\t\tif (key_data_len) {\n\t\t\tkey_data = kvmalloc(key_data_len, GFP_KERNEL);\n\t\t\tif (!key_data) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto key_put_out;\n\t\t\t}\n\t\t}\n\n\t\tret = __keyctl_read_key(key, key_data, key_data_len);\n\n\t\t \n\t\tif (ret <= 0 || ret > buflen)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret > key_data_len) {\n\t\t\tif (unlikely(key_data))\n\t\t\t\tkvfree_sensitive(key_data, key_data_len);\n\t\t\tkey_data_len = ret;\n\t\t\tcontinue;\t \n\t\t}\n\n\t\tif (copy_to_user(buffer, key_data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\tkvfree_sensitive(key_data, key_data_len);\n\nkey_put_out:\n\tkey_put(key);\nout:\n\treturn ret;\n}\n\n \nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t \n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t{\n\t\tbool is_privileged_op = false;\n\n\t\t \n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tis_privileged_op = true;\n\n\t\t \n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tis_privileged_op = true;\n\n\t\tif (is_privileged_op && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto error_put;\n\t}\n\n\t \n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t \n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 > maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen > maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t \n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tnotify_key(key, NOTIFY_KEY_SETATTR, 0);\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n \nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t \n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t \n\tif (uid_eq(key->uid, current_fsuid()) || capable(CAP_SYS_ADMIN)) {\n\t\tkey->perm = perm;\n\t\tnotify_key(key, NOTIFY_KEY_SETATTR, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n \nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t \n\tif (ringid == 0)\n\t\treturn 0;\n\n\t \n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t \n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n \nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n \nstatic long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t \n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t \n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t \n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t \n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t \n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tkvfree_sensitive(payload, plen);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(ITER_SOURCE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n \nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(ITER_SOURCE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n \nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n \nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t \n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t \n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t \n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t \n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n \nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t \n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  KEY_AUTHTOKEN_OVERRIDE);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags)) {\n\t\tret = -EPERM;\n\t} else {\n\t\tkey_set_timeout(key, timeout);\n\t\tnotify_key(key, NOTIFY_KEY_SETATTR, 0);\n\t}\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t \n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t \n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t \n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}\n\n \nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t \n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t  KEY_AUTHTOKEN_OVERRIDE);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t \n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t \n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n \nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t \n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = rcu_dereference_protected(me->real_parent,\n\t\t\t\t\t   lockdep_is_held(&tasklist_lock));\n\n\t \n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t \n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t \n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t \n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t \n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t \n\tret = task_work_add(parent, newwork, TWA_RESUME);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n \nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tret = -EINVAL;\n\tif (_type) {\n\t\tif (!_restriction)\n\t\t\tgoto error;\n\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (_restriction)\n\t\t\tgoto error;\n\t}\n\n\tret = keyring_restrict(key_ref, _type ? type : NULL, restriction);\n\tkfree(restriction);\nerror:\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\n \nlong keyctl_watch_key(key_serial_t id, int watch_queue_fd, int watch_id)\n{\n\tstruct watch_queue *wqueue;\n\tstruct watch_list *wlist = NULL;\n\tstruct watch *watch = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tif (watch_id < -1 || watch_id > 0xff)\n\t\treturn -EINVAL;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\n\twqueue = get_watch_queue(watch_queue_fd);\n\tif (IS_ERR(wqueue)) {\n\t\tret = PTR_ERR(wqueue);\n\t\tgoto err_key;\n\t}\n\n\tif (watch_id >= 0) {\n\t\tret = -ENOMEM;\n\t\tif (!key->watchers) {\n\t\t\twlist = kzalloc(sizeof(*wlist), GFP_KERNEL);\n\t\t\tif (!wlist)\n\t\t\t\tgoto err_wqueue;\n\t\t\tinit_watch_list(wlist, NULL);\n\t\t}\n\n\t\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\t\tif (!watch)\n\t\t\tgoto err_wlist;\n\n\t\tinit_watch(watch, wqueue);\n\t\twatch->id\t= key->serial;\n\t\twatch->info_id\t= (u32)watch_id << WATCH_INFO_ID__SHIFT;\n\n\t\tret = security_watch_key(key);\n\t\tif (ret < 0)\n\t\t\tgoto err_watch;\n\n\t\tdown_write(&key->sem);\n\t\tif (!key->watchers) {\n\t\t\tkey->watchers = wlist;\n\t\t\twlist = NULL;\n\t\t}\n\n\t\tret = add_watch_to_object(watch, key->watchers);\n\t\tup_write(&key->sem);\n\n\t\tif (ret == 0)\n\t\t\twatch = NULL;\n\t} else {\n\t\tret = -EBADSLT;\n\t\tif (key->watchers) {\n\t\t\tdown_write(&key->sem);\n\t\t\tret = remove_watch_from_object(key->watchers,\n\t\t\t\t\t\t       wqueue, key_serial(key),\n\t\t\t\t\t\t       false);\n\t\t\tup_write(&key->sem);\n\t\t}\n\t}\n\nerr_watch:\n\tkfree(watch);\nerr_wlist:\n\tkfree(wlist);\nerr_wqueue:\n\tput_watch_queue(wqueue);\nerr_key:\n\tkey_put(key);\n\treturn ret;\n}\n#endif  \n\n \nlong keyctl_capabilities(unsigned char __user *_buffer, size_t buflen)\n{\n\tsize_t size = buflen;\n\n\tif (size > 0) {\n\t\tif (size > sizeof(keyrings_capabilities))\n\t\t\tsize = sizeof(keyrings_capabilities);\n\t\tif (copy_to_user(_buffer, keyrings_capabilities, size) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (size < buflen &&\n\t\t    clear_user(_buffer + size, buflen - size) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn sizeof(keyrings_capabilities);\n}\n\n \nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (struct keyctl_kdf_params __user *) arg5);\n\n\tcase KEYCTL_RESTRICT_KEYRING:\n\t\treturn keyctl_restrict_keyring((key_serial_t) arg2,\n\t\t\t\t\t       (const char __user *) arg3,\n\t\t\t\t\t       (const char __user *) arg4);\n\n\tcase KEYCTL_PKEY_QUERY:\n\t\tif (arg3 != 0)\n\t\t\treturn -EINVAL;\n\t\treturn keyctl_pkey_query((key_serial_t)arg2,\n\t\t\t\t\t (const char __user *)arg4,\n\t\t\t\t\t (struct keyctl_pkey_query __user *)arg5);\n\n\tcase KEYCTL_PKEY_ENCRYPT:\n\tcase KEYCTL_PKEY_DECRYPT:\n\tcase KEYCTL_PKEY_SIGN:\n\t\treturn keyctl_pkey_e_d_s(\n\t\t\toption,\n\t\t\t(const struct keyctl_pkey_params __user *)arg2,\n\t\t\t(const char __user *)arg3,\n\t\t\t(const void __user *)arg4,\n\t\t\t(void __user *)arg5);\n\n\tcase KEYCTL_PKEY_VERIFY:\n\t\treturn keyctl_pkey_verify(\n\t\t\t(const struct keyctl_pkey_params __user *)arg2,\n\t\t\t(const char __user *)arg3,\n\t\t\t(const void __user *)arg4,\n\t\t\t(const void __user *)arg5);\n\n\tcase KEYCTL_MOVE:\n\t\treturn keyctl_keyring_move((key_serial_t)arg2,\n\t\t\t\t\t   (key_serial_t)arg3,\n\t\t\t\t\t   (key_serial_t)arg4,\n\t\t\t\t\t   (unsigned int)arg5);\n\n\tcase KEYCTL_CAPABILITIES:\n\t\treturn keyctl_capabilities((unsigned char __user *)arg2, (size_t)arg3);\n\n\tcase KEYCTL_WATCH_KEY:\n\t\treturn keyctl_watch_key((key_serial_t)arg2, (int)arg3, (int)arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}