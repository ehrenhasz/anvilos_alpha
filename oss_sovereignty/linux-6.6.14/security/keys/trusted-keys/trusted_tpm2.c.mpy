{
  "module_name": "trusted_tpm2.c",
  "hash_id": "e0292ce9c9f1857135d0189915fb6624b364618d0cf8b0095631b15eb37f9b53",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/trusted-keys/trusted_tpm2.c",
  "human_readable_source": "\n \n\n#include <linux/asn1_encoder.h>\n#include <linux/oid_registry.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include <keys/trusted-type.h>\n#include <keys/trusted_tpm.h>\n\n#include <asm/unaligned.h>\n\n#include \"tpm2key.asn1.h\"\n\nstatic struct tpm2_hash tpm2_hash_map[] = {\n\t{HASH_ALGO_SHA1, TPM_ALG_SHA1},\n\t{HASH_ALGO_SHA256, TPM_ALG_SHA256},\n\t{HASH_ALGO_SHA384, TPM_ALG_SHA384},\n\t{HASH_ALGO_SHA512, TPM_ALG_SHA512},\n\t{HASH_ALGO_SM3_256, TPM_ALG_SM3_256},\n};\n\nstatic u32 tpm2key_oid[] = { 2, 23, 133, 10, 1, 5 };\n\nstatic int tpm2_key_encode(struct trusted_key_payload *payload,\n\t\t\t   struct trusted_key_options *options,\n\t\t\t   u8 *src, u32 len)\n{\n\tconst int SCRATCH_SIZE = PAGE_SIZE;\n\tu8 *scratch = kmalloc(SCRATCH_SIZE, GFP_KERNEL);\n\tu8 *work = scratch, *work1;\n\tu8 *end_work = scratch + SCRATCH_SIZE;\n\tu8 *priv, *pub;\n\tu16 priv_len, pub_len;\n\n\tpriv_len = get_unaligned_be16(src) + 2;\n\tpriv = src;\n\n\tsrc += priv_len;\n\n\tpub_len = get_unaligned_be16(src) + 2;\n\tpub = src;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\twork = asn1_encode_oid(work, end_work, tpm2key_oid,\n\t\t\t       asn1_oid_len(tpm2key_oid));\n\n\tif (options->blobauth_len == 0) {\n\t\tunsigned char bool[3], *w = bool;\n\t\t \n\t\tw = asn1_encode_boolean(w, w + sizeof(bool), true);\n\t\tif (WARN(IS_ERR(w), \"BUG: Boolean failed to encode\"))\n\t\t\treturn PTR_ERR(w);\n\t\twork = asn1_encode_tag(work, end_work, 0, bool, w - bool);\n\t}\n\n\t \n\tif (WARN(work - scratch + pub_len + priv_len + 14 > SCRATCH_SIZE,\n\t\t \"BUG: scratch buffer is too small\"))\n\t\treturn -EINVAL;\n\n\twork = asn1_encode_integer(work, end_work, options->keyhandle);\n\twork = asn1_encode_octet_string(work, end_work, pub, pub_len);\n\twork = asn1_encode_octet_string(work, end_work, priv, priv_len);\n\n\twork1 = payload->blob;\n\twork1 = asn1_encode_sequence(work1, work1 + sizeof(payload->blob),\n\t\t\t\t     scratch, work - scratch);\n\tif (WARN(IS_ERR(work1), \"BUG: ASN.1 encoder failed\"))\n\t\treturn PTR_ERR(work1);\n\n\treturn work1 - payload->blob;\n}\n\nstruct tpm2_key_context {\n\tu32 parent;\n\tconst u8 *pub;\n\tu32 pub_len;\n\tconst u8 *priv;\n\tu32 priv_len;\n};\n\nstatic int tpm2_key_decode(struct trusted_key_payload *payload,\n\t\t\t   struct trusted_key_options *options,\n\t\t\t   u8 **buf)\n{\n\tint ret;\n\tstruct tpm2_key_context ctx;\n\tu8 *blob;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\n\tret = asn1_ber_decoder(&tpm2key_decoder, &ctx, payload->blob,\n\t\t\t       payload->blob_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.priv_len + ctx.pub_len > MAX_BLOB_SIZE)\n\t\treturn -EINVAL;\n\n\tblob = kmalloc(ctx.priv_len + ctx.pub_len + 4, GFP_KERNEL);\n\tif (!blob)\n\t\treturn -ENOMEM;\n\n\t*buf = blob;\n\toptions->keyhandle = ctx.parent;\n\n\tmemcpy(blob, ctx.priv, ctx.priv_len);\n\tblob += ctx.priv_len;\n\n\tmemcpy(blob, ctx.pub, ctx.pub_len);\n\n\treturn 0;\n}\n\nint tpm2_key_parent(void *context, size_t hdrlen,\n\t\t  unsigned char tag,\n\t\t  const void *value, size_t vlen)\n{\n\tstruct tpm2_key_context *ctx = context;\n\tconst u8 *v = value;\n\tint i;\n\n\tctx->parent = 0;\n\tfor (i = 0; i < vlen; i++) {\n\t\tctx->parent <<= 8;\n\t\tctx->parent |= v[i];\n\t}\n\n\treturn 0;\n}\n\nint tpm2_key_type(void *context, size_t hdrlen,\n\t\tunsigned char tag,\n\t\tconst void *value, size_t vlen)\n{\n\tenum OID oid = look_up_OID(value, vlen);\n\n\tif (oid != OID_TPMSealedData) {\n\t\tchar buffer[50];\n\n\t\tsprint_oid(value, vlen, buffer, sizeof(buffer));\n\t\tpr_debug(\"OID is \\\"%s\\\" which is not TPMSealedData\\n\",\n\t\t\t buffer);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint tpm2_key_pub(void *context, size_t hdrlen,\n\t       unsigned char tag,\n\t       const void *value, size_t vlen)\n{\n\tstruct tpm2_key_context *ctx = context;\n\n\tctx->pub = value;\n\tctx->pub_len = vlen;\n\n\treturn 0;\n}\n\nint tpm2_key_priv(void *context, size_t hdrlen,\n\t\tunsigned char tag,\n\t\tconst void *value, size_t vlen)\n{\n\tstruct tpm2_key_context *ctx = context;\n\n\tctx->priv = value;\n\tctx->priv_len = vlen;\n\n\treturn 0;\n}\n\n \nstatic void tpm2_buf_append_auth(struct tpm_buf *buf, u32 session_handle,\n\t\t\t\t const u8 *nonce, u16 nonce_len,\n\t\t\t\t u8 attributes,\n\t\t\t\t const u8 *hmac, u16 hmac_len)\n{\n\ttpm_buf_append_u32(buf, 9 + nonce_len + hmac_len);\n\ttpm_buf_append_u32(buf, session_handle);\n\ttpm_buf_append_u16(buf, nonce_len);\n\n\tif (nonce && nonce_len)\n\t\ttpm_buf_append(buf, nonce, nonce_len);\n\n\ttpm_buf_append_u8(buf, attributes);\n\ttpm_buf_append_u16(buf, hmac_len);\n\n\tif (hmac && hmac_len)\n\t\ttpm_buf_append(buf, hmac, hmac_len);\n}\n\n \nint tpm2_seal_trusted(struct tpm_chip *chip,\n\t\t      struct trusted_key_payload *payload,\n\t\t      struct trusted_key_options *options)\n{\n\tint blob_len = 0;\n\tstruct tpm_buf buf;\n\tu32 hash;\n\tu32 flags;\n\tint i;\n\tint rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(tpm2_hash_map); i++) {\n\t\tif (options->hash == tpm2_hash_map[i].crypto_id) {\n\t\t\thash = tpm2_hash_map[i].tpm_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(tpm2_hash_map))\n\t\treturn -EINVAL;\n\n\tif (!options->keyhandle)\n\t\treturn -EINVAL;\n\n\trc = tpm_try_get_ops(chip);\n\tif (rc)\n\t\treturn rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_CREATE);\n\tif (rc) {\n\t\ttpm_put_ops(chip);\n\t\treturn rc;\n\t}\n\n\ttpm_buf_append_u32(&buf, options->keyhandle);\n\ttpm2_buf_append_auth(&buf, TPM2_RS_PW,\n\t\t\t     NULL  , 0,\n\t\t\t     0  ,\n\t\t\t     options->keyauth  ,\n\t\t\t     TPM_DIGEST_SIZE);\n\n\t \n\ttpm_buf_append_u16(&buf, 4 + options->blobauth_len + payload->key_len);\n\n\ttpm_buf_append_u16(&buf, options->blobauth_len);\n\tif (options->blobauth_len)\n\t\ttpm_buf_append(&buf, options->blobauth, options->blobauth_len);\n\n\ttpm_buf_append_u16(&buf, payload->key_len);\n\ttpm_buf_append(&buf, payload->key, payload->key_len);\n\n\t \n\ttpm_buf_append_u16(&buf, 14 + options->policydigest_len);\n\ttpm_buf_append_u16(&buf, TPM_ALG_KEYEDHASH);\n\ttpm_buf_append_u16(&buf, hash);\n\n\t \n\tflags = 0;\n\tflags |= options->policydigest_len ? 0 : TPM2_OA_USER_WITH_AUTH;\n\tflags |= payload->migratable ? 0 : (TPM2_OA_FIXED_TPM |\n\t\t\t\t\t    TPM2_OA_FIXED_PARENT);\n\ttpm_buf_append_u32(&buf, flags);\n\n\t \n\ttpm_buf_append_u16(&buf, options->policydigest_len);\n\tif (options->policydigest_len)\n\t\ttpm_buf_append(&buf, options->policydigest,\n\t\t\t       options->policydigest_len);\n\n\t \n\ttpm_buf_append_u16(&buf, TPM_ALG_NULL);\n\ttpm_buf_append_u16(&buf, 0);\n\n\t \n\ttpm_buf_append_u16(&buf, 0);\n\n\t \n\ttpm_buf_append_u32(&buf, 0);\n\n\tif (buf.flags & TPM_BUF_OVERFLOW) {\n\t\trc = -E2BIG;\n\t\tgoto out;\n\t}\n\n\trc = tpm_transmit_cmd(chip, &buf, 4, \"sealing data\");\n\tif (rc)\n\t\tgoto out;\n\n\tblob_len = be32_to_cpup((__be32 *) &buf.data[TPM_HEADER_SIZE]);\n\tif (blob_len > MAX_BLOB_SIZE) {\n\t\trc = -E2BIG;\n\t\tgoto out;\n\t}\n\tif (tpm_buf_length(&buf) < TPM_HEADER_SIZE + 4 + blob_len) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tblob_len = tpm2_key_encode(payload, options,\n\t\t\t\t   &buf.data[TPM_HEADER_SIZE + 4],\n\t\t\t\t   blob_len);\n\nout:\n\ttpm_buf_destroy(&buf);\n\n\tif (rc > 0) {\n\t\tif (tpm2_rc_value(rc) == TPM2_RC_HASH)\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\trc = -EPERM;\n\t}\n\tif (blob_len < 0)\n\t\trc = blob_len;\n\telse\n\t\tpayload->blob_len = blob_len;\n\n\ttpm_put_ops(chip);\n\treturn rc;\n}\n\n \nstatic int tpm2_load_cmd(struct tpm_chip *chip,\n\t\t\t struct trusted_key_payload *payload,\n\t\t\t struct trusted_key_options *options,\n\t\t\t u32 *blob_handle)\n{\n\tstruct tpm_buf buf;\n\tunsigned int private_len;\n\tunsigned int public_len;\n\tunsigned int blob_len;\n\tu8 *blob, *pub;\n\tint rc;\n\tu32 attrs;\n\n\trc = tpm2_key_decode(payload, options, &blob);\n\tif (rc) {\n\t\t \n\t\tblob = payload->blob;\n\t\tpayload->old_format = 1;\n\t}\n\n\t \n\tif (!options->keyhandle)\n\t\treturn -EINVAL;\n\n\t \n\tif (payload->blob_len < 4)\n\t\treturn -EINVAL;\n\n\tprivate_len = get_unaligned_be16(blob);\n\n\t \n\tif (private_len + 2 + 2 > (payload->blob_len))\n\t\treturn -E2BIG;\n\n\tpublic_len = get_unaligned_be16(blob + 2 + private_len);\n\tif (private_len + 2 + public_len + 2 > payload->blob_len)\n\t\treturn -E2BIG;\n\n\tpub = blob + 2 + private_len + 2;\n\t \n\tattrs = get_unaligned_be32(pub + 4);\n\n\tif ((attrs & (TPM2_OA_FIXED_TPM | TPM2_OA_FIXED_PARENT)) ==\n\t    (TPM2_OA_FIXED_TPM | TPM2_OA_FIXED_PARENT))\n\t\tpayload->migratable = 0;\n\telse\n\t\tpayload->migratable = 1;\n\n\tblob_len = private_len + public_len + 4;\n\tif (blob_len > payload->blob_len)\n\t\treturn -E2BIG;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_LOAD);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, options->keyhandle);\n\ttpm2_buf_append_auth(&buf, TPM2_RS_PW,\n\t\t\t     NULL  , 0,\n\t\t\t     0  ,\n\t\t\t     options->keyauth  ,\n\t\t\t     TPM_DIGEST_SIZE);\n\n\ttpm_buf_append(&buf, blob, blob_len);\n\n\tif (buf.flags & TPM_BUF_OVERFLOW) {\n\t\trc = -E2BIG;\n\t\tgoto out;\n\t}\n\n\trc = tpm_transmit_cmd(chip, &buf, 4, \"loading blob\");\n\tif (!rc)\n\t\t*blob_handle = be32_to_cpup(\n\t\t\t(__be32 *) &buf.data[TPM_HEADER_SIZE]);\n\nout:\n\tif (blob != payload->blob)\n\t\tkfree(blob);\n\ttpm_buf_destroy(&buf);\n\n\tif (rc > 0)\n\t\trc = -EPERM;\n\n\treturn rc;\n}\n\n \nstatic int tpm2_unseal_cmd(struct tpm_chip *chip,\n\t\t\t   struct trusted_key_payload *payload,\n\t\t\t   struct trusted_key_options *options,\n\t\t\t   u32 blob_handle)\n{\n\tstruct tpm_buf buf;\n\tu16 data_len;\n\tu8 *data;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_UNSEAL);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, blob_handle);\n\ttpm2_buf_append_auth(&buf,\n\t\t\t     options->policyhandle ?\n\t\t\t     options->policyhandle : TPM2_RS_PW,\n\t\t\t     NULL  , 0,\n\t\t\t     TPM2_SA_CONTINUE_SESSION,\n\t\t\t     options->blobauth  ,\n\t\t\t     options->blobauth_len);\n\n\trc = tpm_transmit_cmd(chip, &buf, 6, \"unsealing\");\n\tif (rc > 0)\n\t\trc = -EPERM;\n\n\tif (!rc) {\n\t\tdata_len = be16_to_cpup(\n\t\t\t(__be16 *) &buf.data[TPM_HEADER_SIZE + 4]);\n\t\tif (data_len < MIN_KEY_SIZE ||  data_len > MAX_KEY_SIZE) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tpm_buf_length(&buf) < TPM_HEADER_SIZE + 6 + data_len) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tdata = &buf.data[TPM_HEADER_SIZE + 6];\n\n\t\tif (payload->old_format) {\n\t\t\t \n\t\t\tmemcpy(payload->key, data, data_len - 1);\n\t\t\tpayload->key_len = data_len - 1;\n\t\t\tpayload->migratable = data[data_len - 1];\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(payload->key, data, data_len);\n\t\t\tpayload->key_len = data_len;\n\t\t}\n\t}\n\nout:\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\n \nint tpm2_unseal_trusted(struct tpm_chip *chip,\n\t\t\tstruct trusted_key_payload *payload,\n\t\t\tstruct trusted_key_options *options)\n{\n\tu32 blob_handle;\n\tint rc;\n\n\trc = tpm_try_get_ops(chip);\n\tif (rc)\n\t\treturn rc;\n\n\trc = tpm2_load_cmd(chip, payload, options, &blob_handle);\n\tif (rc)\n\t\tgoto out;\n\n\trc = tpm2_unseal_cmd(chip, payload, options, blob_handle);\n\ttpm2_flush_context(chip, blob_handle);\n\nout:\n\ttpm_put_ops(chip);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}