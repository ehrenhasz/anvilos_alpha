{
  "module_name": "trusted_tpm1.c",
  "hash_id": "5be8dccf53e44a26e10f0c1db23d0a0dd6f77ca36b1eba2c8f703578a8a4a99d",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/trusted-keys/trusted_tpm1.c",
  "human_readable_source": "\n \n\n#include <crypto/hash_info.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha1.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include <keys/trusted_tpm.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\nstatic struct tpm_chip *chip;\nstatic struct tpm_digest *digests;\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkfree_sensitive(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkfree_sensitive(sdesc);\n\treturn ret;\n}\n\n \nint TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned int h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = !!h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkfree_sensitive(sdesc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(TSS_authhmac);\n\n \nint TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree_sensitive(sdesc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(TSS_checkhmac1);\n\n \nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree_sensitive(sdesc);\n\treturn ret;\n}\n\n \nint trusted_tpm_send(unsigned char *cmd, size_t buflen)\n{\n\tint rc;\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t \n\t\trc = -EPERM;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(trusted_tpm_send);\n\n \nstatic int pcrlock(const int pcrnum)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn tpm_pcr_extend(chip, pcrnum, digests) ? -EINVAL : 0;\n}\n\n \nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(chip, ononce, TPM_NONCE_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn -EIO;\n\n\ttpm_buf_reset(tb, TPM_TAG_RQU_COMMAND, TPM_ORD_OSAP);\n\ttpm_buf_append_u16(tb, type);\n\ttpm_buf_append_u32(tb, handle);\n\ttpm_buf_append(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n \nint oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\ttpm_buf_reset(tb, TPM_TAG_RQU_COMMAND, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(oiap);\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n \nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t \n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t \n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t \n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(chip, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t \n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t \n\tif (pcrinfosize == 0) {\n\t\t \n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t \n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\ttpm_buf_reset(tb, TPM_TAG_RQU_AUTH1_COMMAND, TPM_ORD_SEAL);\n\ttpm_buf_append_u32(tb, keyhandle);\n\ttpm_buf_append(tb, td->encauth, SHA1_DIGEST_SIZE);\n\ttpm_buf_append_u32(tb, pcrinfosize);\n\ttpm_buf_append(tb, pcrinfo, pcrinfosize);\n\ttpm_buf_append_u32(tb, datalen);\n\ttpm_buf_append(tb, data, datalen);\n\ttpm_buf_append_u32(tb, sess.handle);\n\ttpm_buf_append(tb, td->nonceodd, TPM_NONCE_SIZE);\n\ttpm_buf_append_u8(tb, cont);\n\ttpm_buf_append(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t \n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t \n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkfree_sensitive(td);\n\treturn ret;\n}\n\n \nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tint ret;\n\n\t \n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tret = tpm_get_random(chip, nonceodd, TPM_NONCE_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"tpm_get_random failed (%d)\\n\", ret);\n\t\treturn -EIO;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttpm_buf_reset(tb, TPM_TAG_RQU_AUTH2_COMMAND, TPM_ORD_UNSEAL);\n\ttpm_buf_append_u32(tb, keyhandle);\n\ttpm_buf_append(tb, blob, bloblen);\n\ttpm_buf_append_u32(tb, authhandle1);\n\ttpm_buf_append(tb, nonceodd, TPM_NONCE_SIZE);\n\ttpm_buf_append_u8(tb, cont);\n\ttpm_buf_append(tb, authdata1, SHA1_DIGEST_SIZE);\n\ttpm_buf_append_u32(tb, authhandle2);\n\ttpm_buf_append(tb, nonceodd, TPM_NONCE_SIZE);\n\ttpm_buf_append_u8(tb, cont);\n\ttpm_buf_append(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n \nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf tb;\n\tint ret;\n\n\tret = tpm_buf_init(&tb, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(&tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"srkseal failed (%d)\\n\", ret);\n\n\ttpm_buf_destroy(&tb);\n\treturn ret;\n}\n\n \nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf tb;\n\tint ret;\n\n\tret = tpm_buf_init(&tb, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tpm_unseal(&tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t \n\t\tp->migratable = p->key[--p->key_len];\n\n\ttpm_buf_destroy(&tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable,\n\tOpt_hash,\n\tOpt_policydigest,\n\tOpt_policyhandle,\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\n \nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(chip);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\tif (!c)\n\t\treturn 0;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\t \n\t\t\topt->blobauth_len = strlen(args[0].from);\n\n\t\t\tif (opt->blobauth_len == 2 * TPM_DIGEST_SIZE) {\n\t\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t\t      TPM_DIGEST_SIZE);\n\t\t\t\tif (res < 0)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\topt->blobauth_len = TPM_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tpm2 && opt->blobauth_len <= sizeof(opt->blobauth)) {\n\t\t\t\tmemcpy(opt->blobauth, args[0].from,\n\t\t\t\t       opt->blobauth_len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn -EINVAL;\n\n\t\t\tbreak;\n\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse if (*args[0].from != '1')\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(chip);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t \n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic int trusted_tpm_seal(struct trusted_key_payload *p, char *datablob)\n{\n\tstruct trusted_key_options *options = NULL;\n\tint ret = 0;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(chip);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\toptions = trusted_options_alloc();\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\tret = getoptions(datablob, p, options);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_options(options);\n\n\tif (!options->keyhandle && !tpm2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tpm2)\n\t\tret = tpm2_seal_trusted(chip, p, options);\n\telse\n\t\tret = key_seal(p, options);\n\tif (ret < 0) {\n\t\tpr_info(\"key_seal failed (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (options->pcrlock) {\n\t\tret = pcrlock(options->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"pcrlock failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree_sensitive(options);\n\treturn ret;\n}\n\nstatic int trusted_tpm_unseal(struct trusted_key_payload *p, char *datablob)\n{\n\tstruct trusted_key_options *options = NULL;\n\tint ret = 0;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(chip);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\toptions = trusted_options_alloc();\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\tret = getoptions(datablob, p, options);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_options(options);\n\n\tif (!options->keyhandle && !tpm2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tpm2)\n\t\tret = tpm2_unseal_trusted(chip, p, options);\n\telse\n\t\tret = key_unseal(p, options);\n\tif (ret < 0)\n\t\tpr_info(\"key_unseal failed (%d)\\n\", ret);\n\n\tif (options->pcrlock) {\n\t\tret = pcrlock(options->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"pcrlock failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree_sensitive(options);\n\treturn ret;\n}\n\nstatic int trusted_tpm_get_random(unsigned char *key, size_t key_len)\n{\n\treturn tpm_get_random(chip, key, key_len);\n}\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, 0);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, 0);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_digests(void)\n{\n\tint i;\n\n\tdigests = kcalloc(chip->nr_allocated_banks, sizeof(*digests),\n\t\t\t  GFP_KERNEL);\n\tif (!digests)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < chip->nr_allocated_banks; i++)\n\t\tdigests[i].alg_id = chip->allocated_banks[i].alg_id;\n\n\treturn 0;\n}\n\nstatic int __init trusted_tpm_init(void)\n{\n\tint ret;\n\n\tchip = tpm_default_chip();\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tret = init_digests();\n\tif (ret < 0)\n\t\tgoto err_put;\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\tgoto err_free;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\tgoto err_release;\n\treturn 0;\nerr_release:\n\ttrusted_shash_release();\nerr_free:\n\tkfree(digests);\nerr_put:\n\tput_device(&chip->dev);\n\treturn ret;\n}\n\nstatic void trusted_tpm_exit(void)\n{\n\tif (chip) {\n\t\tput_device(&chip->dev);\n\t\tkfree(digests);\n\t\ttrusted_shash_release();\n\t\tunregister_key_type(&key_type_trusted);\n\t}\n}\n\nstruct trusted_key_ops trusted_key_tpm_ops = {\n\t.migratable = 1,  \n\t.init = trusted_tpm_init,\n\t.seal = trusted_tpm_seal,\n\t.unseal = trusted_tpm_unseal,\n\t.get_random = trusted_tpm_get_random,\n\t.exit = trusted_tpm_exit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}