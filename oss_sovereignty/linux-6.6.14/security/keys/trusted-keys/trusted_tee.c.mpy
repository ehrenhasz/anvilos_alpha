{
  "module_name": "trusted_tee.c",
  "hash_id": "6afab0ff34838a35cf3bbbfbc8a1c0b74ffc8345a54d1ef0a57b77205ba841af",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/trusted-keys/trusted_tee.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/key-type.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tee_drv.h>\n#include <linux/uuid.h>\n\n#include <keys/trusted_tee.h>\n\n#define DRIVER_NAME \"trusted-key-tee\"\n\n \n#define TA_CMD_GET_RANDOM\t0x0\n\n \n#define TA_CMD_SEAL\t\t0x1\n\n \n#define TA_CMD_UNSEAL\t\t0x2\n\n \nstruct trusted_key_tee_private {\n\tstruct device *dev;\n\tstruct tee_context *ctx;\n\tu32 session_id;\n\tstruct tee_shm *shm_pool;\n};\n\nstatic struct trusted_key_tee_private pvt_data;\n\n \nstatic int trusted_tee_seal(struct trusted_key_payload *p, char *datablob)\n{\n\tint ret;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\tstruct tee_shm *reg_shm = NULL;\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\treg_shm = tee_shm_register_kernel_buf(pvt_data.ctx, p->key,\n\t\t\t\t\t      sizeof(p->key) + sizeof(p->blob));\n\tif (IS_ERR(reg_shm)) {\n\t\tdev_err(pvt_data.dev, \"shm register failed\\n\");\n\t\treturn PTR_ERR(reg_shm);\n\t}\n\n\tinv_arg.func = TA_CMD_SEAL;\n\tinv_arg.session = pvt_data.session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\tparam[0].u.memref.shm = reg_shm;\n\tparam[0].u.memref.size = p->key_len;\n\tparam[0].u.memref.shm_offs = 0;\n\tparam[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[1].u.memref.shm = reg_shm;\n\tparam[1].u.memref.size = sizeof(p->blob);\n\tparam[1].u.memref.shm_offs = sizeof(p->key);\n\n\tret = tee_client_invoke_func(pvt_data.ctx, &inv_arg, param);\n\tif ((ret < 0) || (inv_arg.ret != 0)) {\n\t\tdev_err(pvt_data.dev, \"TA_CMD_SEAL invoke err: %x\\n\",\n\t\t\tinv_arg.ret);\n\t\tret = -EFAULT;\n\t} else {\n\t\tp->blob_len = param[1].u.memref.size;\n\t}\n\n\ttee_shm_free(reg_shm);\n\n\treturn ret;\n}\n\n \nstatic int trusted_tee_unseal(struct trusted_key_payload *p, char *datablob)\n{\n\tint ret;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\tstruct tee_shm *reg_shm = NULL;\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\treg_shm = tee_shm_register_kernel_buf(pvt_data.ctx, p->key,\n\t\t\t\t\t      sizeof(p->key) + sizeof(p->blob));\n\tif (IS_ERR(reg_shm)) {\n\t\tdev_err(pvt_data.dev, \"shm register failed\\n\");\n\t\treturn PTR_ERR(reg_shm);\n\t}\n\n\tinv_arg.func = TA_CMD_UNSEAL;\n\tinv_arg.session = pvt_data.session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\tparam[0].u.memref.shm = reg_shm;\n\tparam[0].u.memref.size = p->blob_len;\n\tparam[0].u.memref.shm_offs = sizeof(p->key);\n\tparam[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[1].u.memref.shm = reg_shm;\n\tparam[1].u.memref.size = sizeof(p->key);\n\tparam[1].u.memref.shm_offs = 0;\n\n\tret = tee_client_invoke_func(pvt_data.ctx, &inv_arg, param);\n\tif ((ret < 0) || (inv_arg.ret != 0)) {\n\t\tdev_err(pvt_data.dev, \"TA_CMD_UNSEAL invoke err: %x\\n\",\n\t\t\tinv_arg.ret);\n\t\tret = -EFAULT;\n\t} else {\n\t\tp->key_len = param[1].u.memref.size;\n\t}\n\n\ttee_shm_free(reg_shm);\n\n\treturn ret;\n}\n\n \nstatic int trusted_tee_get_random(unsigned char *key, size_t key_len)\n{\n\tint ret;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\tstruct tee_shm *reg_shm = NULL;\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\treg_shm = tee_shm_register_kernel_buf(pvt_data.ctx, key, key_len);\n\tif (IS_ERR(reg_shm)) {\n\t\tdev_err(pvt_data.dev, \"key shm register failed\\n\");\n\t\treturn PTR_ERR(reg_shm);\n\t}\n\n\tinv_arg.func = TA_CMD_GET_RANDOM;\n\tinv_arg.session = pvt_data.session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[0].u.memref.shm = reg_shm;\n\tparam[0].u.memref.size = key_len;\n\tparam[0].u.memref.shm_offs = 0;\n\n\tret = tee_client_invoke_func(pvt_data.ctx, &inv_arg, param);\n\tif ((ret < 0) || (inv_arg.ret != 0)) {\n\t\tdev_err(pvt_data.dev, \"TA_CMD_GET_RANDOM invoke err: %x\\n\",\n\t\t\tinv_arg.ret);\n\t\tret = -EFAULT;\n\t} else {\n\t\tret = param[0].u.memref.size;\n\t}\n\n\ttee_shm_free(reg_shm);\n\n\treturn ret;\n}\n\nstatic int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\tif (ver->impl_id == TEE_IMPL_ID_OPTEE &&\n\t    ver->gen_caps & TEE_GEN_CAP_REG_MEM)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int trusted_key_probe(struct device *dev)\n{\n\tstruct tee_client_device *rng_device = to_tee_client_device(dev);\n\tint ret;\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\n\tpvt_data.ctx = tee_client_open_context(NULL, optee_ctx_match, NULL,\n\t\t\t\t\t       NULL);\n\tif (IS_ERR(pvt_data.ctx))\n\t\treturn -ENODEV;\n\n\tmemcpy(sess_arg.uuid, rng_device->id.uuid.b, TEE_IOCTL_UUID_LEN);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;\n\tsess_arg.num_params = 0;\n\n\tret = tee_client_open_session(pvt_data.ctx, &sess_arg, NULL);\n\tif ((ret < 0) || (sess_arg.ret != 0)) {\n\t\tdev_err(dev, \"tee_client_open_session failed, err: %x\\n\",\n\t\t\tsess_arg.ret);\n\t\tret = -EINVAL;\n\t\tgoto out_ctx;\n\t}\n\tpvt_data.session_id = sess_arg.session;\n\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\tgoto out_sess;\n\n\tpvt_data.dev = dev;\n\n\treturn 0;\n\nout_sess:\n\ttee_client_close_session(pvt_data.ctx, pvt_data.session_id);\nout_ctx:\n\ttee_client_close_context(pvt_data.ctx);\n\n\treturn ret;\n}\n\nstatic int trusted_key_remove(struct device *dev)\n{\n\tunregister_key_type(&key_type_trusted);\n\ttee_client_close_session(pvt_data.ctx, pvt_data.session_id);\n\ttee_client_close_context(pvt_data.ctx);\n\n\treturn 0;\n}\n\nstatic const struct tee_client_device_id trusted_key_id_table[] = {\n\t{UUID_INIT(0xf04a0fe7, 0x1f5d, 0x4b9b,\n\t\t   0xab, 0xf7, 0x61, 0x9b, 0x85, 0xb4, 0xce, 0x8c)},\n\t{}\n};\nMODULE_DEVICE_TABLE(tee, trusted_key_id_table);\n\nstatic struct tee_client_driver trusted_key_driver = {\n\t.id_table\t= trusted_key_id_table,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.bus\t\t= &tee_bus_type,\n\t\t.probe\t\t= trusted_key_probe,\n\t\t.remove\t\t= trusted_key_remove,\n\t},\n};\n\nstatic int trusted_tee_init(void)\n{\n\treturn driver_register(&trusted_key_driver.driver);\n}\n\nstatic void trusted_tee_exit(void)\n{\n\tdriver_unregister(&trusted_key_driver.driver);\n}\n\nstruct trusted_key_ops trusted_key_tee_ops = {\n\t.migratable = 0,  \n\t.init = trusted_tee_init,\n\t.seal = trusted_tee_seal,\n\t.unseal = trusted_tee_unseal,\n\t.get_random = trusted_tee_get_random,\n\t.exit = trusted_tee_exit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}