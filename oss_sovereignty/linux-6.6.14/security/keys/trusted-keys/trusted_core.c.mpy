{
  "module_name": "trusted_core.c",
  "hash_id": "22e82cdeb770408d47199eb283fffbb461aae89ca815140ab3304f5c219d7cb5",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/trusted-keys/trusted_core.c",
  "human_readable_source": "\n \n\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/trusted_tee.h>\n#include <keys/trusted_caam.h>\n#include <keys/trusted_tpm.h>\n#include <linux/capability.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/key-type.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/static_call.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic char *trusted_rng = \"default\";\nmodule_param_named(rng, trusted_rng, charp, 0);\nMODULE_PARM_DESC(rng, \"Select trusted key RNG\");\n\nstatic char *trusted_key_source;\nmodule_param_named(source, trusted_key_source, charp, 0);\nMODULE_PARM_DESC(source, \"Select trusted keys source (tpm, tee or caam)\");\n\nstatic const struct trusted_key_source trusted_key_sources[] = {\n#if defined(CONFIG_TRUSTED_KEYS_TPM)\n\t{ \"tpm\", &trusted_key_tpm_ops },\n#endif\n#if defined(CONFIG_TRUSTED_KEYS_TEE)\n\t{ \"tee\", &trusted_key_tee_ops },\n#endif\n#if defined(CONFIG_TRUSTED_KEYS_CAAM)\n\t{ \"caam\", &trusted_key_caam_ops },\n#endif\n};\n\nDEFINE_STATIC_CALL_NULL(trusted_key_seal, *trusted_key_sources[0].ops->seal);\nDEFINE_STATIC_CALL_NULL(trusted_key_unseal,\n\t\t\t*trusted_key_sources[0].ops->unseal);\nDEFINE_STATIC_CALL_NULL(trusted_key_get_random,\n\t\t\t*trusted_key_sources[0].ops->get_random);\nstatic void (*trusted_key_exit)(void);\nstatic unsigned char migratable;\n\nenum {\n\tOpt_err,\n\tOpt_new, Opt_load, Opt_update,\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\n \nstatic int datablob_parse(char **datablob, struct trusted_key_payload *p)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t \n\tc = strsep(datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t \n\t\tc = strsep(datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t \n\t\tc = strsep(datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof(*p));\n\tif (ret < 0)\n\t\tgoto err;\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err;\n\n\tp->migratable = migratable;\nerr:\n\treturn p;\n}\n\n \nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob, *orig_datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\torig_datablob = datablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(&datablob, payload);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tret = static_call(trusted_key_unseal)(payload, datablob);\n\t\tdump_payload(payload);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = static_call(trusted_key_get_random)(payload->key,\n\t\t\t\t\t\t\t  key_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"key_create failed (%d)\\n\", ret);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = static_call(trusted_key_seal)(payload, datablob);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tkfree_sensitive(orig_datablob);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkfree_sensitive(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkfree_sensitive(p);\n}\n\n \nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob, *orig_datablob;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\torig_datablob = datablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(&datablob, new_p);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree_sensitive(new_p);\n\t\tgoto out;\n\t}\n\n\t \n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = static_call(trusted_key_seal)(new_p, datablob);\n\tif (ret < 0) {\n\t\tpr_info(\"key_seal failed (%d)\\n\", ret);\n\t\tkfree_sensitive(new_p);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree_sensitive(orig_datablob);\n\treturn ret;\n}\n\n \nstatic long trusted_read(const struct key *key, char *buffer,\n\t\t\t size_t buflen)\n{\n\tconst struct trusted_key_payload *p;\n\tchar *bufp;\n\tint i;\n\n\tp = dereference_key_locked(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tif (buffer && buflen >= 2 * p->blob_len) {\n\t\tbufp = buffer;\n\t\tfor (i = 0; i < p->blob_len; i++)\n\t\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\t}\n\treturn 2 * p->blob_len;\n}\n\n \nstatic void trusted_destroy(struct key *key)\n{\n\tkfree_sensitive(key->payload.data[0]);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic int kernel_get_random(unsigned char *key, size_t key_len)\n{\n\treturn get_random_bytes_wait(key, key_len) ?: key_len;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint (*get_random)(unsigned char *key, size_t key_len);\n\tint i, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(trusted_key_sources); i++) {\n\t\tif (trusted_key_source &&\n\t\t    strncmp(trusted_key_source, trusted_key_sources[i].name,\n\t\t\t    strlen(trusted_key_sources[i].name)))\n\t\t\tcontinue;\n\n\t\t \n\t\tget_random = trusted_key_sources[i].ops->get_random;\n\t\tif (trusted_rng && strcmp(trusted_rng, \"default\")) {\n\t\t\tif (!strcmp(trusted_rng, \"kernel\")) {\n\t\t\t\tget_random = kernel_get_random;\n\t\t\t} else if (strcmp(trusted_rng, trusted_key_sources[i].name) ||\n\t\t\t\t   !get_random) {\n\t\t\t\tpr_warn(\"Unsupported RNG. Supported: kernel\");\n\t\t\t\tif (get_random)\n\t\t\t\t\tpr_cont(\", %s\", trusted_key_sources[i].name);\n\t\t\t\tpr_cont(\", default\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (!get_random)\n\t\t\tget_random = kernel_get_random;\n\n\t\tret = trusted_key_sources[i].ops->init();\n\t\tif (!ret) {\n\t\t\tstatic_call_update(trusted_key_seal, trusted_key_sources[i].ops->seal);\n\t\t\tstatic_call_update(trusted_key_unseal, trusted_key_sources[i].ops->unseal);\n\t\t\tstatic_call_update(trusted_key_get_random, get_random);\n\n\t\t\ttrusted_key_exit = trusted_key_sources[i].ops->exit;\n\t\t\tmigratable = trusted_key_sources[i].ops->migratable;\n\t\t}\n\n\t\tif (!ret || ret != -ENODEV)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (ret == -ENODEV)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\tif (trusted_key_exit)\n\t\t(*trusted_key_exit)();\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}