{
  "module_name": "proc.c",
  "hash_id": "6e7d501d24e97280368d66957a8c49f388c052da4d4aef52086482dbfc8f7a37",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/proc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <asm/errno.h>\n#include \"internal.h\"\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_keys_ops = {\n\t.start\t= proc_keys_start,\n\t.next\t= proc_keys_next,\n\t.stop\t= proc_keys_stop,\n\t.show\t= proc_keys_show,\n};\n\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_key_users_ops = {\n\t.start\t= proc_key_users_start,\n\t.next\t= proc_key_users_next,\n\t.stop\t= proc_key_users_stop,\n\t.show\t= proc_key_users_show,\n};\n\n \nstatic int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_seq(\"keys\", 0, NULL, &proc_keys_ops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create_seq(\"key-users\", 0, NULL, &proc_key_users_ops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}\n\n__initcall(key_proc_init);\n\n \nstatic struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_serial_lock)\n{\n\tkey_serial_t pos = *_pos;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\tif (*_pos > INT_MAX)\n\t\treturn NULL;\n\tkey = find_ge_key(p, pos);\n\tif (!key)\n\t\treturn NULL;\n\t*_pos = key->serial;\n\treturn &key->serial_node;\n}\n\nstatic inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}\n\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\telse\n\t\t(*_pos)++;\n\treturn n;\n}\n\nstatic void proc_keys_stop(struct seq_file *p, void *v)\n\t__releases(key_serial_lock)\n{\n\tspin_unlock(&key_serial_lock);\n}\n\nstatic int proc_keys_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key *key = rb_entry(_p, struct key, serial_node);\n\tunsigned long flags;\n\tkey_ref_t key_ref, skey_ref;\n\ttime64_t now, expiry;\n\tchar xbuf[16];\n\tshort state;\n\tu64 timo;\n\tint rc;\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= key->index_key,\n\t\t.cred\t\t\t= m->file->f_cred,\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.raw_data\t= key,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_RECURSE),\n\t};\n\n\tkey_ref = make_key_ref(key, 0);\n\n\t \n\tif (key->perm & KEY_POS_VIEW) {\n\t\trcu_read_lock();\n\t\tskey_ref = search_cred_keyrings_rcu(&ctx);\n\t\trcu_read_unlock();\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_ref_put(skey_ref);\n\t\t\tkey_ref = make_key_ref(key, 1);\n\t\t}\n\t}\n\n\t \n\trc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tnow = ktime_get_real_seconds();\n\n\trcu_read_lock();\n\n\t \n\texpiry = READ_ONCE(key->expiry);\n\tif (expiry == TIME64_MAX) {\n\t\tmemcpy(xbuf, \"perm\", 5);\n\t} else if (now >= expiry) {\n\t\tmemcpy(xbuf, \"expd\", 5);\n\t} else {\n\t\ttimo = expiry - now;\n\n\t\tif (timo < 60)\n\t\t\tsprintf(xbuf, \"%llus\", timo);\n\t\telse if (timo < 60*60)\n\t\t\tsprintf(xbuf, \"%llum\", div_u64(timo, 60));\n\t\telse if (timo < 60*60*24)\n\t\t\tsprintf(xbuf, \"%lluh\", div_u64(timo, 60 * 60));\n\t\telse if (timo < 60*60*24*7)\n\t\t\tsprintf(xbuf, \"%llud\", div_u64(timo, 60 * 60 * 24));\n\t\telse\n\t\t\tsprintf(xbuf, \"%lluw\", div_u64(timo, 60 * 60 * 24 * 7));\n\t}\n\n\tstate = key_read_state(key);\n\n#define showflag(FLAGS, LETTER, FLAG) \\\n\t((FLAGS & (1 << FLAG)) ? LETTER : '-')\n\n\tflags = READ_ONCE(key->flags);\n\tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n\t\t   key->serial,\n\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n\t\t   showflag(flags, 'R', KEY_FLAG_REVOKED),\n\t\t   showflag(flags, 'D', KEY_FLAG_DEAD),\n\t\t   showflag(flags, 'Q', KEY_FLAG_IN_QUOTA),\n\t\t   showflag(flags, 'U', KEY_FLAG_USER_CONSTRUCT),\n\t\t   state < 0 ? 'N' : '-',\n\t\t   showflag(flags, 'i', KEY_FLAG_INVALIDATED),\n\t\t   refcount_read(&key->usage),\n\t\t   xbuf,\n\t\t   key->perm,\n\t\t   from_kuid_munged(seq_user_ns(m), key->uid),\n\t\t   from_kgid_munged(seq_user_ns(m), key->gid),\n\t\t   key->type->name);\n\n#undef showflag\n\n\tif (key->type->describe)\n\t\tkey->type->describe(key, m);\n\tseq_putc(m, '\\n');\n\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}\n\nstatic struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}\n\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_user_lock)\n{\n\tstruct rb_node *_p;\n\tloff_t pos = *_pos;\n\n\tspin_lock(&key_user_lock);\n\n\t_p = key_user_first(seq_user_ns(p), &key_user_tree);\n\twhile (pos > 0 && _p) {\n\t\tpos--;\n\t\t_p = key_user_next(seq_user_ns(p), _p);\n\t}\n\n\treturn _p;\n}\n\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\t(*_pos)++;\n\treturn key_user_next(seq_user_ns(p), (struct rb_node *)v);\n}\n\nstatic void proc_key_users_stop(struct seq_file *p, void *v)\n\t__releases(key_user_lock)\n{\n\tspin_unlock(&key_user_lock);\n}\n\nstatic int proc_key_users_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key_user *user = rb_entry(_p, struct key_user, node);\n\tunsigned maxkeys = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\tunsigned maxbytes = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\tseq_printf(m, \"%5u: %5d %d/%d %d/%d %d/%d\\n\",\n\t\t   from_kuid_munged(seq_user_ns(m), user->uid),\n\t\t   refcount_read(&user->usage),\n\t\t   atomic_read(&user->nkeys),\n\t\t   atomic_read(&user->nikeys),\n\t\t   user->qnkeys,\n\t\t   maxkeys,\n\t\t   user->qnbytes,\n\t\t   maxbytes);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}