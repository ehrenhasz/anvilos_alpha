{
  "module_name": "request_key.c",
  "hash_id": "b70ca66b13aa44e4838b3c50de36438e6ec29d7a4e7b0631e386d1e8f14d8897",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/request_key.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include \"internal.h\"\n#include <keys/request_key_auth-type.h>\n\n#define key_negative_timeout\t60\t \n\nstatic struct key *check_cached_key(struct keyring_search_context *ctx)\n{\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tstruct key *key = current->cached_requested_key;\n\n\tif (key &&\n\t    ctx->match_data.cmp(key, &ctx->match_data) &&\n\t    !(key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t    (1 << KEY_FLAG_REVOKED))))\n\t\treturn key_get(key);\n#endif\n\treturn NULL;\n}\n\nstatic void cache_requested_key(struct key *key)\n{\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tstruct task_struct *t = current;\n\n\t \n\tif (!(t->flags & PF_KTHREAD)) {\n\t\tkey_put(t->cached_requested_key);\n\t\tt->cached_requested_key = key_get(key);\n\t\tset_tsk_thread_flag(t, TIF_NOTIFY_RESUME);\n\t}\n#endif\n}\n\n \nvoid complete_request_key(struct key *authkey, int error)\n{\n\tstruct request_key_auth *rka = get_request_key_auth(authkey);\n\tstruct key *key = rka->target_key;\n\n\tkenter(\"%d{%d},%d\", authkey->serial, key->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(key, key_negative_timeout, NULL, authkey);\n\telse\n\t\tkey_revoke(authkey);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n \nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n \nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n \nstatic int call_usermodehelper_keys(const char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n \nstatic int call_sbin_request_key(struct key *authkey, void *aux)\n{\n\tstatic char const request_key[] = \"/sbin/request-key\";\n\tstruct request_key_auth *rka = get_request_key_auth(authkey);\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = rka->target_key, *keyring, *session, *user_session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, rka->op);\n\n\tret = look_up_user_keyrings(NULL, &user_session);\n\tif (ret < 0)\n\t\tgoto error_us;\n\n\t \n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t \n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t \n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t \n\tsprintf(key_str, \"%d\", key->serial);\n\n\t \n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\tsession = cred->session_keyring;\n\tif (!session)\n\t\tsession = user_session;\n\tsskey = session->serial;\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t \n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t \n\ti = 0;\n\targv[i++] = (char *)request_key;\n\targv[i++] = (char *)rka->op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t \n\tret = call_usermodehelper_keys(request_key, argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t \n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t \n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tkey_put(user_session);\nerror_us:\n\tcomplete_request_key(authkey, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\t \n\tauthkey = request_key_auth_new(key, \"create\", callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey))\n\t\treturn PTR_ERR(authkey);\n\n\t \n\tactor = call_sbin_request_key;\n\tif (key->type->request_key)\n\t\tactor = key->type->request_key;\n\n\tret = actor(authkey, aux);\n\n\t \n\tWARN_ON(ret < 0 &&\n\t\t!test_bit(KEY_FLAG_INVALIDATED, &authkey->flags));\n\n\tkey_put(authkey);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tint ret;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t \n\tif (dest_keyring) {\n\t\t \n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tbool do_perm_check = true;\n\n\t\t \n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = get_request_key_auth(authkey);\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring) {\n\t\t\t\t\tdo_perm_check = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfallthrough;\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\tdest_keyring = key_get(cred->session_keyring);\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tret = look_up_user_keyrings(NULL, &dest_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tret = look_up_user_keyrings(&dest_keyring, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t \n\t\tif (dest_keyring && do_perm_check) {\n\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n\t\t\t\t\t     KEY_NEED_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tkey_put(dest_keyring);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn 0;\n}\n\n \nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit = NULL;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags, NULL);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_lock(dest_keyring, &key->index_key);\n\t\tif (ret < 0)\n\t\t\tgoto link_lock_failed;\n\t}\n\n\t \n\tmutex_lock(&key_construction_mutex);\n\n\trcu_read_lock();\n\tkey_ref = search_process_keyrings_rcu(ctx);\n\trcu_read_unlock();\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_alloc_failed;\n\t\t__key_link(dest_keyring, key, &edit);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &key->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t \nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_alloc_failed_unlocked;\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(dest_keyring, key, &edit);\n\t\t__key_link_end(dest_keyring, &key->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_alloc_failed:\n\tmutex_unlock(&key_construction_mutex);\nlink_alloc_failed_unlocked:\n\t__key_link_end(dest_keyring, &key->index_key, edit);\nlink_lock_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n \nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t struct key_tag *domain_tag,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.domain_tag\t= domain_tag,\n\t\t.index_key.description\t= description,\n\t\t.index_key.desc_len\t= strlen(description),\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED |\n\t\t\t\t\t   KEYRING_SEARCH_RECURSE),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = check_cached_key(&ctx);\n\tif (key)\n\t\tgoto error_free;\n\n\t \n\trcu_read_lock();\n\tkey_ref = search_process_keyrings_rcu(&ctx);\n\trcu_read_unlock();\n\n\tif (!IS_ERR(key_ref)) {\n\t\tif (dest_keyring) {\n\t\t\tret = key_task_permission(key_ref, current_cred(),\n\t\t\t\t\t\t  KEY_NEED_LINK);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref_put(key_ref);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcache_requested_key(key);\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t \n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n \nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n \nstruct key *request_key_tag(struct key_type *type,\n\t\t\t    const char *description,\n\t\t\t    struct key_tag *domain_tag,\n\t\t\t    const char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, domain_tag,\n\t\t\t\t   callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_tag);\n\n \nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     struct key_tag *domain_tag,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, domain_tag,\n\t\t\t\t   callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n \nstruct key *request_key_rcu(struct key_type *type,\n\t\t\t    const char *description,\n\t\t\t    struct key_tag *domain_tag)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.domain_tag\t= domain_tag,\n\t\t.index_key.description\t= description,\n\t\t.index_key.desc_len\t= strlen(description),\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\n\tkenter(\"%s,%s\", type->name, description);\n\n\tkey = check_cached_key(&ctx);\n\tif (key)\n\t\treturn key;\n\n\t \n\tkey_ref = search_process_keyrings_rcu(&ctx);\n\tif (IS_ERR(key_ref)) {\n\t\tkey = ERR_CAST(key_ref);\n\t\tif (PTR_ERR(key_ref) == -EAGAIN)\n\t\t\tkey = ERR_PTR(-ENOKEY);\n\t} else {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tcache_requested_key(key);\n\t}\n\n\tkleave(\" = %p\", key);\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_rcu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}