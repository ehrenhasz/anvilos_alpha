{
  "module_name": "Kconfig",
  "hash_id": "3cd02689566d4d4a54640fd5e30b5244f0adba4c0c3592a9eb167deef41d8132",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Key management configuration\n#\n\nconfig KEYS\n\tbool \"Enable access key retention support\"\n\tselect ASSOCIATIVE_ARRAY\n\thelp\n\t  This option provides support for retaining authentication tokens and\n\t  access keys in the kernel.\n\n\t  It also includes provision of methods by which such keys might be\n\t  associated with a process so that network filesystems, encryption\n\t  support and the like can find them.\n\n\t  Furthermore, a special type of key is available that acts as keyring:\n\t  a searchable sequence of keys. Each process is equipped with access\n\t  to five standard keyrings: UID-specific, GID-specific, session,\n\t  process and thread.\n\n\t  If you are unsure as to whether this is required, answer N.\n\nconfig KEYS_REQUEST_CACHE\n\tbool \"Enable temporary caching of the last request_key() result\"\n\tdepends on KEYS\n\thelp\n\t  This option causes the result of the last successful request_key()\n\t  call that didn't upcall to the kernel to be cached temporarily in the\n\t  task_struct.  The cache is cleared by exit and just prior to the\n\t  resumption of userspace.\n\n\t  This allows the key used for multiple step processes where each step\n\t  wants to request a key that is likely the same as the one requested\n\t  by the last step to save on the searching.\n\n\t  An example of such a process is a pathwalk through a network\n\t  filesystem in which each method needs to request an authentication\n\t  key.  Pathwalk will call multiple methods for each dentry traversed\n\t  (permission, d_revalidate, lookup, getxattr, getacl, ...).\n\nconfig PERSISTENT_KEYRINGS\n\tbool \"Enable register of persistent per-UID keyrings\"\n\tdepends on KEYS\n\thelp\n\t  This option provides a register of persistent per-UID keyrings,\n\t  primarily aimed at Kerberos key storage.  The keyrings are persistent\n\t  in the sense that they stay around after all processes of that UID\n\t  have exited, not that they survive the machine being rebooted.\n\n\t  A particular keyring may be accessed by either the user whose keyring\n\t  it is or by a process with administrative privileges.  The active\n\t  LSMs gets to rule on which admin-level processes get to access the\n\t  cache.\n\n\t  Keyrings are created and added into the register upon demand and get\n\t  removed if they expire (a default timeout is set upon creation).\n\nconfig BIG_KEYS\n\tbool \"Large payload keys\"\n\tdepends on KEYS\n\tdepends on TMPFS\n\tdepends on CRYPTO_LIB_CHACHA20POLY1305 = y\n\thelp\n\t  This option provides support for holding large keys within the kernel\n\t  (for example Kerberos ticket caches).  The data may be stored out to\n\t  swapspace by tmpfs.\n\n\t  If you are unsure as to whether this is required, answer N.\n\nconfig TRUSTED_KEYS\n\ttristate \"TRUSTED KEYS\"\n\tdepends on KEYS\n\thelp\n\t  This option provides support for creating, sealing, and unsealing\n\t  keys in the kernel. Trusted keys are random number symmetric keys,\n\t  generated and sealed by a trust source selected at kernel boot-time.\n\t  Userspace will only ever see encrypted blobs.\n\n\t  If you are unsure as to whether this is required, answer N.\n\nif TRUSTED_KEYS\nsource \"security/keys/trusted-keys/Kconfig\"\nendif\n\nconfig ENCRYPTED_KEYS\n\ttristate \"ENCRYPTED KEYS\"\n\tdepends on KEYS\n\tselect CRYPTO\n\tselect CRYPTO_HMAC\n\tselect CRYPTO_AES\n\tselect CRYPTO_CBC\n\tselect CRYPTO_SHA256\n\tselect CRYPTO_RNG\n\thelp\n\t  This option provides support for create/encrypting/decrypting keys\n\t  in the kernel.  Encrypted keys are instantiated using kernel\n\t  generated random numbers or provided decrypted data, and are\n\t  encrypted/decrypted with a 'master' symmetric key. The 'master'\n\t  key can be either a trusted-key or user-key type. Only encrypted\n\t  blobs are ever output to Userspace.\n\n\t  If you are unsure as to whether this is required, answer N.\n\nconfig USER_DECRYPTED_DATA\n\tbool \"Allow encrypted keys with user decrypted data\"\n\tdepends on ENCRYPTED_KEYS\n\thelp\n\t  This option provides support for instantiating encrypted keys using\n\t  user-provided decrypted data.  The decrypted data must be hex-ascii\n\t  encoded.\n\n\t  If you are unsure as to whether this is required, answer N.\n\nconfig KEY_DH_OPERATIONS\n       bool \"Diffie-Hellman operations on retained keys\"\n       depends on KEYS\n       select CRYPTO\n       select CRYPTO_KDF800108_CTR\n       select CRYPTO_DH\n       help\n\t This option provides support for calculating Diffie-Hellman\n\t public keys and shared secrets using values stored as keys\n\t in the kernel.\n\n\t If you are unsure as to whether this is required, answer N.\n\nconfig KEY_NOTIFICATIONS\n\tbool \"Provide key/keyring change notifications\"\n\tdepends on KEYS && WATCH_QUEUE\n\thelp\n\t  This option provides support for getting change notifications\n\t  on keys and keyrings on which the caller has View permission.\n\t  This makes use of pipes to handle the notification buffer and\n\t  provides KEYCTL_WATCH_KEY to enable/disable watches.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}