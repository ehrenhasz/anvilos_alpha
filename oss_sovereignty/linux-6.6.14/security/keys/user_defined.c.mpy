{
  "module_name": "user_defined.c",
  "hash_id": "ee214e083681b54c1f71f174bbeafc2aa3655716ad1b6034aa469ab1a33b6aac",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/user_defined.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n \nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n \nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n \nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t \n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n \nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree_sensitive(prep->payload.data[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\nstatic void user_free_payload_rcu(struct rcu_head *head)\n{\n\tstruct user_key_payload *payload;\n\n\tpayload = container_of(head, struct user_key_payload, rcu);\n\tkfree_sensitive(payload);\n}\n\n \nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t \n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(user_update);\n\n \nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = user_key_payload_locked(key);\n\n\t \n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&upayload->rcu, user_free_payload_rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n \nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkfree_sensitive(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n \nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n \nlong user_read(const struct key *key, char *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload_locked(key);\n\tret = upayload->datalen;\n\n\t \n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tmemcpy(buffer, upayload->data, buflen);\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n \nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t \n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t \n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}