{
  "module_name": "gc.c",
  "hash_id": "46ecc5f23e234ee36abd2e61fb10c73f72b9659a496e0ba985fbcba689ce0ff4",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/gc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <keys/keyring-type.h>\n#include \"internal.h\"\n\n \nunsigned key_gc_delay = 5 * 60;\n\n \nstatic void key_garbage_collector(struct work_struct *work);\nDECLARE_WORK(key_gc_work, key_garbage_collector);\n\n \nstatic void key_gc_timer_func(struct timer_list *);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func);\n\nstatic time64_t key_gc_next_run = TIME64_MAX;\nstatic struct key_type *key_gc_dead_keytype;\n\nstatic unsigned long key_gc_flags;\n#define KEY_GC_KEY_EXPIRED\t0\t \n#define KEY_GC_REAP_KEYTYPE\t1\t \n#define KEY_GC_REAPING_KEYTYPE\t2\t \n\n\n \nstruct key_type key_type_dead = {\n\t.name = \".dead\",\n};\n\n \nvoid key_schedule_gc(time64_t gc_at)\n{\n\tunsigned long expires;\n\ttime64_t now = ktime_get_real_seconds();\n\n\tkenter(\"%lld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}\n\n \nvoid key_set_expiry(struct key *key, time64_t expiry)\n{\n\tkey->expiry = expiry;\n\tif (expiry != TIME64_MAX) {\n\t\tif (!(key->type->flags & KEY_TYPE_INSTANT_REAP))\n\t\t\texpiry += key_gc_delay;\n\t\tkey_schedule_gc(expiry);\n\t}\n}\n\n \nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}\n\n \nstatic void key_gc_timer_func(struct timer_list *unused)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = TIME64_MAX;\n\tkey_schedule_gc_links();\n}\n\n \nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}\n\n \nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\t\tremove_watch_list(key->watchers, key->serial);\n\t\tkey->watchers = NULL;\n#endif\n\n\t\t \n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t \n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\t\tkey_put_tag(key->domain_tag);\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n\n \nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t \n#define KEY_GC_REAP_AGAIN\t0x01\t \n#define KEY_GC_REAPING_LINKS\t0x02\t \n#define KEY_GC_REAPING_DEAD_1\t0x10\t \n#define KEY_GC_REAPING_DEAD_2\t0x20\t \n#define KEY_GC_REAPING_DEAD_3\t0x40\t \n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t \n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime64_t new_timer, limit, expiry;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = ktime_get_real_seconds();\n\n\t \n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = TIME64_MAX;\n\n\t \n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (refcount_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t} else if (key->type == &key_type_keyring &&\n\t\t\t\t   key->restrict_link) {\n\t\t\t\tgoto found_restricted_keyring;\n\t\t\t}\n\t\t}\n\n\t\texpiry = key->expiry;\n\t\tif (expiry != TIME64_MAX) {\n\t\t\tif (!(key->type->flags & KEY_TYPE_INSTANT_REAP))\n\t\t\t\texpiry += key_gc_delay;\n\t\t\tif (expiry > limit && expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %lld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t \n\tkdebug(\"pass complete\");\n\n\tif (new_timer != TIME64_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t \n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t \n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t \nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t \nfound_restricted_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_restriction_gc(key, key_gc_dead_keytype);\n\tgoto maybe_resched;\n\n\t \nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t \ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}