{
  "module_name": "keyctl_pkey.c",
  "hash_id": "815725a38c05a403629eecc646b8050124817bdbaf6ce557f7cf642ee31fe9eb",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/keyctl_pkey.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/parser.h>\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nstatic void keyctl_pkey_params_free(struct kernel_pkey_params *params)\n{\n\tkfree(params->info);\n\tkey_put(params->key);\n}\n\nenum {\n\tOpt_err,\n\tOpt_enc,\t\t \n\tOpt_hash,\t\t \n};\n\nstatic const match_table_t param_keys = {\n\t{ Opt_enc,\t\"enc=%s\" },\n\t{ Opt_hash,\t\"hash=%s\" },\n\t{ Opt_err,\tNULL }\n};\n\n \nstatic int keyctl_pkey_params_parse(struct kernel_pkey_params *params)\n{\n\tunsigned long token_mask = 0;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *c = params->info, *p, *q;\n\tint token;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, param_keys, args);\n\t\tif (token == Opt_err)\n\t\t\treturn -EINVAL;\n\t\tif (__test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\t\tq = args[0].from;\n\t\tif (!q[0])\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_enc:\n\t\t\tparams->encoding = q;\n\t\t\tbreak;\n\n\t\tcase Opt_hash:\n\t\t\tparams->hash_algo = q;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int keyctl_pkey_params_get(key_serial_t id,\n\t\t\t\t  const char __user *_info,\n\t\t\t\t  struct kernel_pkey_params *params)\n{\n\tkey_ref_t key_ref;\n\tvoid *p;\n\tint ret;\n\n\tmemset(params, 0, sizeof(*params));\n\tparams->encoding = \"raw\";\n\n\tp = strndup_user(_info, PAGE_SIZE);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\tparams->info = p;\n\n\tret = keyctl_pkey_params_parse(params);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\tparams->key = key_ref_to_ptr(key_ref);\n\n\tif (!params->key->type->asym_query)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic int keyctl_pkey_params_get_2(const struct keyctl_pkey_params __user *_params,\n\t\t\t\t    const char __user *_info,\n\t\t\t\t    int op,\n\t\t\t\t    struct kernel_pkey_params *params)\n{\n\tstruct keyctl_pkey_params uparams;\n\tstruct kernel_pkey_query info;\n\tint ret;\n\n\tmemset(params, 0, sizeof(*params));\n\tparams->encoding = \"raw\";\n\n\tif (copy_from_user(&uparams, _params, sizeof(uparams)) != 0)\n\t\treturn -EFAULT;\n\n\tret = keyctl_pkey_params_get(uparams.key_id, _info, params);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = params->key->type->asym_query(params, &info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (op) {\n\tcase KEYCTL_PKEY_ENCRYPT:\n\t\tif (uparams.in_len  > info.max_dec_size ||\n\t\t    uparams.out_len > info.max_enc_size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase KEYCTL_PKEY_DECRYPT:\n\t\tif (uparams.in_len  > info.max_enc_size ||\n\t\t    uparams.out_len > info.max_dec_size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase KEYCTL_PKEY_SIGN:\n\t\tif (uparams.in_len  > info.max_data_size ||\n\t\t    uparams.out_len > info.max_sig_size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase KEYCTL_PKEY_VERIFY:\n\t\tif (uparams.in_len  > info.max_data_size ||\n\t\t    uparams.in2_len > info.max_sig_size)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tparams->in_len  = uparams.in_len;\n\tparams->out_len = uparams.out_len;  \n\treturn 0;\n}\n\n \nlong keyctl_pkey_query(key_serial_t id,\n\t\t       const char __user *_info,\n\t\t       struct keyctl_pkey_query __user *_res)\n{\n\tstruct kernel_pkey_params params;\n\tstruct kernel_pkey_query res;\n\tlong ret;\n\n\tret = keyctl_pkey_params_get(id, _info, &params);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = params.key->type->asym_query(&params, &res);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EFAULT;\n\tif (copy_to_user(_res, &res, sizeof(res)) == 0 &&\n\t    clear_user(_res->__spare, sizeof(_res->__spare)) == 0)\n\t\tret = 0;\n\nerror:\n\tkeyctl_pkey_params_free(&params);\n\treturn ret;\n}\n\n \nlong keyctl_pkey_e_d_s(int op,\n\t\t       const struct keyctl_pkey_params __user *_params,\n\t\t       const char __user *_info,\n\t\t       const void __user *_in,\n\t\t       void __user *_out)\n{\n\tstruct kernel_pkey_params params;\n\tvoid *in, *out;\n\tlong ret;\n\n\tret = keyctl_pkey_params_get_2(_params, _info, op, &params);\n\tif (ret < 0)\n\t\tgoto error_params;\n\n\tret = -EOPNOTSUPP;\n\tif (!params.key->type->asym_eds_op)\n\t\tgoto error_params;\n\n\tswitch (op) {\n\tcase KEYCTL_PKEY_ENCRYPT:\n\t\tparams.op = kernel_pkey_encrypt;\n\t\tbreak;\n\tcase KEYCTL_PKEY_DECRYPT:\n\t\tparams.op = kernel_pkey_decrypt;\n\t\tbreak;\n\tcase KEYCTL_PKEY_SIGN:\n\t\tparams.op = kernel_pkey_sign;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tin = memdup_user(_in, params.in_len);\n\tif (IS_ERR(in)) {\n\t\tret = PTR_ERR(in);\n\t\tgoto error_params;\n\t}\n\n\tret = -ENOMEM;\n\tout = kmalloc(params.out_len, GFP_KERNEL);\n\tif (!out)\n\t\tgoto error_in;\n\n\tret = params.key->type->asym_eds_op(&params, in, out);\n\tif (ret < 0)\n\t\tgoto error_out;\n\n\tif (copy_to_user(_out, out, ret) != 0)\n\t\tret = -EFAULT;\n\nerror_out:\n\tkfree(out);\nerror_in:\n\tkfree(in);\nerror_params:\n\tkeyctl_pkey_params_free(&params);\n\treturn ret;\n}\n\n \nlong keyctl_pkey_verify(const struct keyctl_pkey_params __user *_params,\n\t\t\tconst char __user *_info,\n\t\t\tconst void __user *_in,\n\t\t\tconst void __user *_in2)\n{\n\tstruct kernel_pkey_params params;\n\tvoid *in, *in2;\n\tlong ret;\n\n\tret = keyctl_pkey_params_get_2(_params, _info, KEYCTL_PKEY_VERIFY,\n\t\t\t\t       &params);\n\tif (ret < 0)\n\t\tgoto error_params;\n\n\tret = -EOPNOTSUPP;\n\tif (!params.key->type->asym_verify_signature)\n\t\tgoto error_params;\n\n\tin = memdup_user(_in, params.in_len);\n\tif (IS_ERR(in)) {\n\t\tret = PTR_ERR(in);\n\t\tgoto error_params;\n\t}\n\n\tin2 = memdup_user(_in2, params.in2_len);\n\tif (IS_ERR(in2)) {\n\t\tret = PTR_ERR(in2);\n\t\tgoto error_in;\n\t}\n\n\tparams.op = kernel_pkey_verify;\n\tret = params.key->type->asym_verify_signature(&params, in, in2);\n\n\tkfree(in2);\nerror_in:\n\tkfree(in);\nerror_params:\n\tkeyctl_pkey_params_free(&params);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}