{
  "module_name": "keyring.c",
  "hash_id": "2faf6364478144edeeb370af61501608c5b381437175734b1b22d8570647da01",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/keyring.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include <net/net_namespace.h>\n#include \"internal.h\"\n\n \n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n \n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\n \nvoid key_free_user_ns(struct user_namespace *ns)\n{\n\twrite_lock(&keyring_name_lock);\n\tlist_del_init(&ns->keyring_name_list);\n\twrite_unlock(&keyring_name_lock);\n\n\tkey_put(ns->user_keyring_register);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tkey_put(ns->persistent_keyring_register);\n#endif\n}\n\n \nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n \nstatic DEFINE_MUTEX(keyring_serialise_link_lock);\n\n \nstatic void keyring_publish_name(struct key *keyring)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\tif (keyring->description &&\n\t    keyring->description[0] &&\n\t    keyring->description[0] != '.') {\n\t\twrite_lock(&keyring_name_lock);\n\t\tlist_add_tail(&keyring->name_link, &ns->keyring_name_list);\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n \nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n \nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n \nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t \n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n \nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n \nstatic void hash_key_type_and_desc(struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tpiece = (unsigned long)index_key->domain_tag;\n\tacc = mult_64x32_and_fold(acc, piece);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t \n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t \n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\thash |= (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\telse if (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\thash = (hash + (hash << level_shift)) & ~fan_mask;\n\tindex_key->hash = hash;\n}\n\n \nvoid key_set_index_key(struct keyring_index_key *index_key)\n{\n\tstatic struct key_tag default_domain_tag = { .usage = REFCOUNT_INIT(1), };\n\tsize_t n = min_t(size_t, index_key->desc_len, sizeof(index_key->desc));\n\n\tmemcpy(index_key->desc, index_key->description, n);\n\n\tif (!index_key->domain_tag) {\n\t\tif (index_key->type->flags & KEY_TYPE_NET_DOMAIN)\n\t\t\tindex_key->domain_tag = current->nsproxy->net_ns->key_domain;\n\t\telse\n\t\t\tindex_key->domain_tag = &default_domain_tag;\n\t}\n\n\thash_key_type_and_desc(index_key);\n}\n\n \nbool key_put_tag(struct key_tag *tag)\n{\n\tif (refcount_dec_and_test(&tag->usage)) {\n\t\tkfree_rcu(tag, rcu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid key_remove_domain(struct key_tag *domain_tag)\n{\n\tdomain_tag->removed = true;\n\tif (!key_put_tag(domain_tag))\n\t\tkey_schedule_gc_links();\n}\n\n \nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tconst u8 *d;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn index_key->hash;\n\tcase 1:\n\t\treturn index_key->x;\n\tcase 2:\n\t\treturn (unsigned long)index_key->type;\n\tcase 3:\n\t\treturn (unsigned long)index_key->domain_tag;\n\tdefault:\n\t\tlevel -= 4;\n\t\tif (desc_len <= sizeof(index_key->desc))\n\t\t\treturn 0;\n\n\t\td = index_key->description + sizeof(index_key->desc);\n\t\td += level * sizeof(long);\n\t\tdesc_len -= sizeof(index_key->desc);\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= *d++;\n\t\t} while (--desc_len > 0);\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.domain_tag == index_key->domain_tag &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n \nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = a->hash;\n\tseg_b = b->hash;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\n\t \n\tseg_a = a->x;\n\tseg_b = b->x;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += sizeof(unsigned long);\n\n\t \n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += sizeof(unsigned long);\n\n\tseg_a = (unsigned long)a->domain_tag;\n\tseg_b = (unsigned long)b->domain_tag;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += sizeof(unsigned long);\n\n\ti = sizeof(a->desc);\n\tif (a->desc_len <= i)\n\t\tgoto same;\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n \nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n \nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n \nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n \nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_positive(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tbuflen;\n\tsize_t\t\t\tcount;\n\tkey_serial_t\t\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\t*ctx->buffer++ = key->serial;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n \nstatic long keyring_read(const struct key *keyring,\n\t\t\t char *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tlong ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\t \n\tif (buffer && buflen) {\n\t\tctx.buffer = (key_serial_t *)buffer;\n\t\tctx.buflen = buflen;\n\t\tctx.count = 0;\n\t\tret = assoc_array_iterate(&keyring->keys,\n\t\t\t\t\t  keyring_read_iterator, &ctx);\n\t\tif (ret < 0) {\n\t\t\tkleave(\" = %ld [iterate]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = keyring->keys.nr_leaves_on_tree * sizeof(key_serial_t);\n\tif (ret <= buflen)\n\t\tkleave(\"= %ld [ok]\", ret);\n\telse\n\t\tkleave(\"= %ld [buffer too small]\", ret);\n\treturn ret;\n}\n\n \nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n \nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}\n\n \nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n \nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = READ_ONCE(key->flags);\n\tshort state = READ_ONCE(key->state);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t \n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (expiry && ctx->now >= expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t \n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t \n\t\tif (state < 0) {\n\t\t\tctx->result = ERR_PTR(state);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t \n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n \nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n \nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tkey_set_index_key(&ctx->index_key);\n\n\t \n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t \ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t \n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t \n\tif (!(ctx->flags & KEYRING_SEARCH_RECURSE))\n\t\tgoto not_this_keyring;\n\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t \n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t \n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tslot = 0;\nascend_to_node:\n\t \n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t \n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t \n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t \n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tslot++;\n\n\t \n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t \nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t \n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t \nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n \nkey_ref_t keyring_search_rcu(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\tctx->now = ktime_get_real_seconds();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\treturn ctx->result;\n}\n\n \nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description,\n\t\t\t bool recurse)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.index_key.desc_len\t= strlen(description),\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (recurse)\n\t\tctx.flags |= KEYRING_SEARCH_RECURSE;\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\trcu_read_lock();\n\tkey = keyring_search_rcu(keyring, &ctx);\n\trcu_read_unlock();\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}\n\n \nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\n \nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}\n\n \nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link) {\n\t\tret = -EEXIST;\n\t} else if (keyring_detect_restriction_cycle(keyring, restrict_link)) {\n\t\tret = -EDEADLK;\n\t} else {\n\t\tkeyring->restrict_link = restrict_link;\n\t\tnotify_key(keyring, NOTIFY_KEY_SETATTR, 0);\n\t}\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_restrict);\n\n \nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n \nstruct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tstruct key *keyring;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tread_lock(&keyring_name_lock);\n\n\t \n\tlist_for_each_entry(keyring, &ns->keyring_name_list, name_link) {\n\t\tif (!kuid_has_mapping(ns, keyring->user->uid))\n\t\t\tcontinue;\n\n\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\tcontinue;\n\n\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\tcontinue;\n\n\t\tif (uid_keyring) {\n\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t      &keyring->flags))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\tcontinue;\n\t\tkeyring->last_used_at = ktime_get_real_seconds();\n\t\tgoto out;\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t \n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n \nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP |\n\t\t\t\t\t   KEYRING_SEARCH_RECURSE),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n \nint __key_link_lock(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_lock)\n{\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\t \n\tif (index_key->type == &key_type_keyring)\n\t\tmutex_lock(&keyring_serialise_link_lock);\n\n\treturn 0;\n}\n\n \nint __key_move_lock(struct key *l_keyring, struct key *u_keyring,\n\t\t    const struct keyring_index_key *index_key)\n\t__acquires(&l_keyring->sem)\n\t__acquires(&u_keyring->sem)\n\t__acquires(&keyring_serialise_link_lock)\n{\n\tif (l_keyring->type != &key_type_keyring ||\n\t    u_keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\t \n\tif (l_keyring < u_keyring) {\n\t\tdown_write(&l_keyring->sem);\n\t\tdown_write_nested(&u_keyring->sem, 1);\n\t} else {\n\t\tdown_write(&u_keyring->sem);\n\t\tdown_write_nested(&l_keyring->sem, 1);\n\t}\n\n\t \n\tif (index_key->type == &key_type_keyring)\n\t\tmutex_lock(&keyring_serialise_link_lock);\n\n\treturn 0;\n}\n\n \nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\tBUG_ON(*_edit != NULL);\n\n\t*_edit = NULL;\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error;\n\n\t \n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\n\t \n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t \n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n \nvoid __key_link(struct key *keyring, struct key *key,\n\t\tstruct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n\tnotify_key(keyring, NOTIFY_KEY_LINKED, key_serial(key));\n}\n\n \nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_lock)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tmutex_unlock(&keyring_serialise_link_lock);\n}\n\n \nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}\n\n \nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit = NULL;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_lock(keyring, &key->index_key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret < 0)\n\t\tgoto error_end;\n\n\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\tret = __key_link_check_restriction(keyring, key);\n\tif (ret == 0)\n\t\tret = __key_link_check_live_key(keyring, key);\n\tif (ret == 0)\n\t\t__key_link(keyring, key, &edit);\n\nerror_end:\n\t__key_link_end(keyring, &key->index_key, edit);\nerror:\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n \nstatic int __key_unlink_lock(struct key *keyring)\n\t__acquires(&keyring->sem)\n{\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\treturn 0;\n}\n\n \nstatic int __key_unlink_begin(struct key *keyring, struct key *key,\n\t\t\t      struct assoc_array_edit **_edit)\n{\n\tstruct assoc_array_edit *edit;\n\n\tBUG_ON(*_edit != NULL);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit))\n\t\treturn PTR_ERR(edit);\n\n\tif (!edit)\n\t\treturn -ENOENT;\n\n\t*_edit = edit;\n\treturn 0;\n}\n\n \nstatic void __key_unlink(struct key *keyring, struct key *key,\n\t\t\t struct assoc_array_edit **_edit)\n{\n\tassoc_array_apply_edit(*_edit);\n\tnotify_key(keyring, NOTIFY_KEY_UNLINKED, key_serial(key));\n\t*_edit = NULL;\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n}\n\n \nstatic void __key_unlink_end(struct key *keyring,\n\t\t\t     struct key *key,\n\t\t\t     struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n{\n\tif (edit)\n\t\tassoc_array_cancel_edit(edit);\n\tup_write(&keyring->sem);\n}\n\n \nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit = NULL;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_unlink_lock(keyring);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __key_unlink_begin(keyring, key, &edit);\n\tif (ret == 0)\n\t\t__key_unlink(keyring, key, &edit);\n\t__key_unlink_end(keyring, key, edit);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n \nint key_move(struct key *key,\n\t     struct key *from_keyring,\n\t     struct key *to_keyring,\n\t     unsigned int flags)\n{\n\tstruct assoc_array_edit *from_edit = NULL, *to_edit = NULL;\n\tint ret;\n\n\tkenter(\"%d,%d,%d\", key->serial, from_keyring->serial, to_keyring->serial);\n\n\tif (from_keyring == to_keyring)\n\t\treturn 0;\n\n\tkey_check(key);\n\tkey_check(from_keyring);\n\tkey_check(to_keyring);\n\n\tret = __key_move_lock(from_keyring, to_keyring, &key->index_key);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = __key_unlink_begin(from_keyring, key, &from_edit);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = __key_link_begin(to_keyring, &key->index_key, &to_edit);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (to_edit->dead_leaf && (flags & KEYCTL_MOVE_EXCL))\n\t\tgoto error;\n\n\tret = __key_link_check_restriction(to_keyring, key);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = __key_link_check_live_key(to_keyring, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t__key_unlink(from_keyring, key, &from_edit);\n\t__key_link(to_keyring, key, &to_edit);\nerror:\n\t__key_link_end(to_keyring, &key->index_key, to_edit);\n\t__key_unlink_end(from_keyring, key, from_edit);\nout:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_move);\n\n \nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tnotify_key(keyring, NOTIFY_KEY_CLEARED, 0);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n \nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n \nvoid keyring_gc(struct key *keyring, time64_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t \n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n\n \nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t \n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t \n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}