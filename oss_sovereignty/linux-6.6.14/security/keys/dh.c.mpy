{
  "module_name": "dh.c",
  "hash_id": "c13e6c98aaeb69ab25ad21dafdc0b9e2101497bec7e4c0d3900768a22af0abac",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/dh.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/kpp.h>\n#include <crypto/dh.h>\n#include <crypto/kdf_sp800108.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nstatic ssize_t dh_data_from_key(key_serial_t keyid, const void **data)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong status;\n\tssize_t ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = -EOPNOTSUPP;\n\tif (key->type == &key_type_user) {\n\t\tdown_read(&key->sem);\n\t\tstatus = key_validate(key);\n\t\tif (status == 0) {\n\t\t\tconst struct user_key_payload *payload;\n\t\t\tuint8_t *duplicate;\n\n\t\t\tpayload = user_key_payload_locked(key);\n\n\t\t\tduplicate = kmemdup(payload->data, payload->datalen,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (duplicate) {\n\t\t\t\t*data = duplicate;\n\t\t\t\tret = payload->datalen;\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tup_read(&key->sem);\n\t}\n\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\nstatic void dh_free_data(struct dh *dh)\n{\n\tkfree_sensitive(dh->key);\n\tkfree_sensitive(dh->p);\n\tkfree_sensitive(dh->g);\n}\n\nstatic int kdf_alloc(struct crypto_shash **hash, char *hashname)\n{\n\tstruct crypto_shash *tfm;\n\n\t \n\ttfm = crypto_alloc_shash(hashname, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"could not allocate digest TFM handle %s\\n\", hashname);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tif (crypto_shash_digestsize(tfm) == 0) {\n\t\tcrypto_free_shash(tfm);\n\t\treturn -EINVAL;\n\t}\n\n\t*hash = tfm;\n\n\treturn 0;\n}\n\nstatic void kdf_dealloc(struct crypto_shash *hash)\n{\n\tif (hash)\n\t\tcrypto_free_shash(hash);\n}\n\nstatic int keyctl_dh_compute_kdf(struct crypto_shash *hash,\n\t\t\t\t char __user *buffer, size_t buflen,\n\t\t\t\t uint8_t *kbuf, size_t kbuflen)\n{\n\tstruct kvec kbuf_iov = { .iov_base = kbuf, .iov_len = kbuflen };\n\tuint8_t *outbuf = NULL;\n\tint ret;\n\tsize_t outbuf_len = roundup(buflen, crypto_shash_digestsize(hash));\n\n\toutbuf = kmalloc(outbuf_len, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = crypto_kdf108_ctr_generate(hash, &kbuf_iov, 1, outbuf, outbuf_len);\n\tif (ret)\n\t\tgoto err;\n\n\tret = buflen;\n\tif (copy_to_user(buffer, outbuf, buflen) != 0)\n\t\tret = -EFAULT;\n\nerr:\n\tkfree_sensitive(outbuf);\n\treturn ret;\n}\n\nlong __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tDECLARE_CRYPTO_WAIT(compl);\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct crypto_shash *hash = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t \n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t \n\t\tret = kdf_alloc(&hash, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t \n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t crypto_req_done, &compl);\n\n\t \n\tret = crypto_kpp_generate_public_key(req);\n\tret = crypto_wait_req(ret, &compl);\n\tif (ret)\n\t\tgoto out6;\n\n\tif (kdfcopy) {\n\t\t \n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(hash, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkfree_sensitive(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkfree_sensitive(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(hash);\n\treturn ret;\n}\n\nlong keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t       char __user *buffer, size_t buflen,\n\t\t       struct keyctl_kdf_params __user *kdf)\n{\n\tstruct keyctl_kdf_params kdfcopy;\n\n\tif (!kdf)\n\t\treturn __keyctl_dh_compute(params, buffer, buflen, NULL);\n\n\tif (copy_from_user(&kdfcopy, kdf, sizeof(kdfcopy)) != 0)\n\t\treturn -EFAULT;\n\n\treturn __keyctl_dh_compute(params, buffer, buflen, &kdfcopy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}