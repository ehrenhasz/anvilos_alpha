{
  "module_name": "request_key_auth.c",
  "hash_id": "9058453ffc1e0f0ddf28c4dcddb95bac566c0d1285579cd586b734785b0d96c4",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/request_key_auth.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <keys/request_key_auth-type.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char *, size_t);\n\n \nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n \nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\trcu_assign_keypointer(key, (struct request_key_auth *)prep->data);\n\treturn 0;\n}\n\n \nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = dereference_key_rcu(key);\n\n\tif (!rka)\n\t\treturn;\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}\n\n \nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = dereference_key_locked(key);\n\tsize_t datalen;\n\tlong ret;\n\n\tif (!rka)\n\t\treturn -EKEYREVOKED;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t \n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tmemcpy(buffer, rka->callout_info, buflen);\n\t}\n\n\treturn ret;\n}\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}\n\n \nstatic void request_key_auth_rcu_disposal(struct rcu_head *rcu)\n{\n\tstruct request_key_auth *rka =\n\t\tcontainer_of(rcu, struct request_key_auth, rcu);\n\n\tfree_request_key_auth(rka);\n}\n\n \nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = dereference_key_locked(key);\n\n\tkenter(\"{%d}\", key->serial);\n\trcu_assign_keypointer(key, NULL);\n\tcall_rcu(&rka->rcu, request_key_auth_rcu_disposal);\n}\n\n \nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = rcu_access_pointer(key->payload.rcu_data0);\n\n\tkenter(\"{%d}\", key->serial);\n\tif (rka) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&rka->rcu, request_key_auth_rcu_disposal);\n\t}\n}\n\n \nstruct key *request_key_auth_new(struct key *target, const char *op,\n\t\t\t\t const void *callout_info, size_t callout_len,\n\t\t\t\t struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret = -ENOMEM;\n\n\tkenter(\"%d,\", target->serial);\n\n\t \n\trka = kzalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka)\n\t\tgoto error;\n\trka->callout_info = kmemdup(callout_info, callout_len, GFP_KERNEL);\n\tif (!rka->callout_info)\n\t\tgoto error_free_rka;\n\trka->callout_len = callout_len;\n\tstrscpy(rka->op, op, sizeof(rka->op));\n\n\t \n\tif (cred->request_key_auth) {\n\t\t \n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t \n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &cred->request_key_auth->flags)) {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tret = -EKEYREVOKED;\n\t\t\tgoto error_free_rka;\n\t\t}\n\n\t\tirka = cred->request_key_auth->payload.data[0];\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t \n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\n\t \n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH | KEY_POS_LINK |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_free_rka;\n\t}\n\n\t \n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_put_authkey;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, refcount_read(&authkey->usage));\n\treturn authkey;\n\nerror_put_authkey:\n\tkey_put(authkey);\nerror_free_rka:\n\tfree_request_key_auth(rka);\nerror:\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_RECURSE),\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tctx.index_key.desc_len = sprintf(description, \"%x\", target_id);\n\n\trcu_read_lock();\n\tauthkey_ref = search_process_keyrings_rcu(&ctx);\n\trcu_read_unlock();\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}