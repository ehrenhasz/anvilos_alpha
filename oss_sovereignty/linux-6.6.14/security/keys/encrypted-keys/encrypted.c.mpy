{
  "module_name": "encrypted.c",
  "hash_id": "5ba9566f34896c9878ff398df5382cbf095f82103419d2bd10370615edc47a3c",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/encrypted-keys/encrypted.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/ctype.h>\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n#include <crypto/skcipher.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic const char key_format_enc32[] = \"enc32\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n#define KEY_ENC32_PAYLOAD_LEN 32\n\nstatic struct crypto_shash *hash_tfm;\n\nenum {\n\tOpt_new, Opt_load, Opt_update, Opt_err\n};\n\nenum {\n\tOpt_default, Opt_ecryptfs, Opt_enc32, Opt_error\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_enc32, \"enc32\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic bool user_decrypted_data = IS_ENABLED(CONFIG_USER_DECRYPTED_DATA);\nmodule_param(user_decrypted_data, bool, 0);\nMODULE_PARM_DESC(user_decrypted_data,\n\t\"Allow instantiation of encrypted keys using provided decrypted data\");\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}\n\n \nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv, char **decrypted_data)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t \n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_enc32:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*decrypted_data = strsep(&datablob, \" \\t\");\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t \n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t \n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n \nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t \n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = crypto_shash_tfm_digest(tfm, buf, buflen, digest);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n \nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = crypto_shash_tfm_digest(hash_tfm, derived_buf, derived_buf_len,\n\t\t\t\t      derived_key);\n\tkfree_sensitive(derived_buf);\n\treturn ret;\n}\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n \nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n \nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t \n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}\n\n \nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen,\n\t\t\t\t\t\t\t const char *decrypted_data)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint i;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\n\tif (decrypted_data) {\n\t\tif (!user_decrypted_data) {\n\t\t\tpr_err(\"encrypted key: instantiation of keys using provided decrypted data is disabled since CONFIG_USER_DECRYPTED_DATA is set to false\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tif (strlen(decrypted_data) != decrypted_datalen * 2) {\n\t\t\tpr_err(\"encrypted key: decrypted data provided does not match decrypted data length provided\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tfor (i = 0; i < strlen(decrypted_data); i++) {\n\t\t\tif (!isxdigit(decrypted_data[i])) {\n\t\t\t\tpr_err(\"encrypted key: decrypted data provided must contain only hexadecimal characters\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (format) {\n\t\tif (!strcmp(format, key_format_ecryptfs)) {\n\t\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format must be equal to %d bytes\\n\",\n\t\t\t\t\tECRYPTFS_MAX_KEY_BYTES);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t\t} else if (!strcmp(format, key_format_enc32)) {\n\t\t\tif (decrypted_datalen != KEY_ENC32_PAYLOAD_LEN) {\n\t\t\t\tpr_err(\"encrypted_key: enc32 key payload incorrect length: %d\\n\",\n\t\t\t\t\t\tdecrypted_datalen);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n \nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv, const char *decrypted_data)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (hex_encoded_iv) {\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\t} else if (decrypted_data) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\t\tret = hex2bin(epayload->decrypted_data, decrypted_data,\n\t\t\t      epayload->decrypted_datalen);\n\t} else {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\t\tget_random_bytes(epayload->decrypted_data, epayload->decrypted_datalen);\n\t}\n\treturn ret;\n}\n\n \nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tchar *decrypted_data = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv, &decrypted_data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen, decrypted_data);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv, decrypted_data);\n\tif (ret < 0) {\n\t\tkfree_sensitive(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkfree_sensitive(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tkfree_sensitive(epayload);\n}\n\n \nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen, NULL);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree_sensitive(buf);\n\treturn ret;\n}\n\n \nstatic long encrypted_read(const struct key *key, char *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t \n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tmemcpy(buffer, ascii_buf, asciiblob_len);\n\tkfree_sensitive(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n \nstatic void encrypted_destroy(struct key *key)\n{\n\tkfree_sensitive(key->payload.data[0]);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\thash_tfm = crypto_alloc_shash(hash_alg, 0, 0);\n\tif (IS_ERR(hash_tfm)) {\n\t\tpr_err(\"encrypted_key: can't allocate %s transform: %ld\\n\",\n\t\t       hash_alg, PTR_ERR(hash_tfm));\n\t\treturn PTR_ERR(hash_tfm);\n\t}\n\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tcrypto_free_shash(hash_tfm);\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tcrypto_free_shash(hash_tfm);\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}