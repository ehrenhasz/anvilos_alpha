{
  "module_name": "process_keys.c",
  "hash_id": "b3406196a9a550acba2a80e8c1a32ea2a077c8bae0a9ef47a32087a66bd93753",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/process_keys.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <keys/request_key_auth-type.h>\n#include \"internal.h\"\n\n \nstatic DEFINE_MUTEX(key_session_mutex);\n\n \nstruct key_user root_key_user = {\n\t.usage\t\t= REFCOUNT_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n \nstatic struct key *get_user_register(struct user_namespace *user_ns)\n{\n\tstruct key *reg_keyring = READ_ONCE(user_ns->user_keyring_register);\n\n\tif (reg_keyring)\n\t\treturn reg_keyring;\n\n\tdown_write(&user_ns->keyring_sem);\n\n\t \n\treg_keyring = user_ns->user_keyring_register;\n\tif (!reg_keyring) {\n\t\treg_keyring = keyring_alloc(\".user_reg\",\n\t\t\t\t\t    user_ns->owner, INVALID_GID,\n\t\t\t\t\t    &init_cred,\n\t\t\t\t\t    KEY_POS_WRITE | KEY_POS_SEARCH |\n\t\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\t    0,\n\t\t\t\t\t    NULL, NULL);\n\t\tif (!IS_ERR(reg_keyring))\n\t\t\tsmp_store_release(&user_ns->user_keyring_register,\n\t\t\t\t\t  reg_keyring);\n\t}\n\n\tup_write(&user_ns->keyring_sem);\n\n\t \n\treturn reg_keyring;\n}\n\n \nint look_up_user_keyrings(struct key **_user_keyring,\n\t\t\t  struct key **_user_session_keyring)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct key *reg_keyring, *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tkey_ref_t uid_keyring_r, session_keyring_r;\n\tuid_t uid = from_kuid(user_ns, cred->user->uid);\n\tchar buf[20];\n\tint ret;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\n\tkenter(\"%u\", uid);\n\n\treg_keyring = get_user_register(user_ns);\n\tif (IS_ERR(reg_keyring))\n\t\treturn PTR_ERR(reg_keyring);\n\n\tdown_write(&user_ns->keyring_sem);\n\tret = 0;\n\n\t \n\tsnprintf(buf, sizeof(buf), \"_uid.%u\", uid);\n\tuid_keyring_r = keyring_search(make_key_ref(reg_keyring, true),\n\t\t\t\t       &key_type_keyring, buf, false);\n\tkdebug(\"_uid %p\", uid_keyring_r);\n\tif (uid_keyring_r == ERR_PTR(-EAGAIN)) {\n\t\tuid_keyring = keyring_alloc(buf, cred->user->uid, INVALID_GID,\n\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t    KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t    NULL, reg_keyring);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\tgoto error;\n\t\t}\n\t} else if (IS_ERR(uid_keyring_r)) {\n\t\tret = PTR_ERR(uid_keyring_r);\n\t\tgoto error;\n\t} else {\n\t\tuid_keyring = key_ref_to_ptr(uid_keyring_r);\n\t}\n\n\t \n\tsnprintf(buf, sizeof(buf), \"_uid_ses.%u\", uid);\n\tsession_keyring_r = keyring_search(make_key_ref(reg_keyring, true),\n\t\t\t\t\t   &key_type_keyring, buf, false);\n\tkdebug(\"_uid_ses %p\", session_keyring_r);\n\tif (session_keyring_r == ERR_PTR(-EAGAIN)) {\n\t\tsession_keyring = keyring_alloc(buf, cred->user->uid, INVALID_GID,\n\t\t\t\t\t\tcred, user_keyring_perm,\n\t\t\t\t\t\tKEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\tKEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\tNULL, NULL);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tret = PTR_ERR(session_keyring);\n\t\t\tgoto error_release;\n\t\t}\n\n\t\t \n\t\tret = key_link(session_keyring, uid_keyring);\n\t\tif (ret < 0)\n\t\t\tgoto error_release_session;\n\n\t\t \n\t\tret = key_link(reg_keyring, session_keyring);\n\t\tif (ret < 0)\n\t\t\tgoto error_release_session;\n\t} else if (IS_ERR(session_keyring_r)) {\n\t\tret = PTR_ERR(session_keyring_r);\n\t\tgoto error_release;\n\t} else {\n\t\tsession_keyring = key_ref_to_ptr(session_keyring_r);\n\t}\n\n\tup_write(&user_ns->keyring_sem);\n\n\tif (_user_session_keyring)\n\t\t*_user_session_keyring = session_keyring;\n\telse\n\t\tkey_put(session_keyring);\n\tif (_user_keyring)\n\t\t*_user_keyring = uid_keyring;\n\telse\n\t\tkey_put(uid_keyring);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_session:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tup_write(&user_ns->keyring_sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstruct key *get_user_session_keyring_rcu(const struct cred *cred)\n{\n\tstruct key *reg_keyring = READ_ONCE(cred->user_ns->user_keyring_register);\n\tkey_ref_t session_keyring_r;\n\tchar buf[20];\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_keyring,\n\t\t.index_key.description\t= buf,\n\t\t.cred\t\t\t= cred,\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= buf,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\n\tif (!reg_keyring)\n\t\treturn NULL;\n\n\tctx.index_key.desc_len = snprintf(buf, sizeof(buf), \"_uid_ses.%u\",\n\t\t\t\t\t  from_kuid(cred->user_ns,\n\t\t\t\t\t\t    cred->user->uid));\n\n\tsession_keyring_r = keyring_search_rcu(make_key_ref(reg_keyring, true),\n\t\t\t\t\t       &ctx);\n\tif (IS_ERR(session_keyring_r))\n\t\treturn NULL;\n\treturn key_ref_to_ptr(session_keyring_r);\n}\n\n \nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n \nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n \nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n \nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n \nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t \n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t \n\told = cred->session_keyring;\n\tcred->session_keyring = keyring;\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n \nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n \nvoid key_fsuid_changed(struct cred *new_cred)\n{\n\t \n\tif (new_cred->thread_keyring) {\n\t\tdown_write(&new_cred->thread_keyring->sem);\n\t\tnew_cred->thread_keyring->uid = new_cred->fsuid;\n\t\tup_write(&new_cred->thread_keyring->sem);\n\t}\n}\n\n \nvoid key_fsgid_changed(struct cred *new_cred)\n{\n\t \n\tif (new_cred->thread_keyring) {\n\t\tdown_write(&new_cred->thread_keyring->sem);\n\t\tnew_cred->thread_keyring->gid = new_cred->fsgid;\n\t\tup_write(&new_cred->thread_keyring->sem);\n\t}\n}\n\n \nkey_ref_t search_cred_keyrings_rcu(struct keyring_search_context *ctx)\n{\n\tstruct key *user_session;\n\tkey_ref_t key_ref, ret, err;\n\tconst struct cred *cred = ctx->cred;\n\n\t \n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t \n\tif (cred->thread_keyring) {\n\t\tkey_ref = keyring_search_rcu(\n\t\t\tmake_key_ref(cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN:  \n\t\tcase -ENOKEY:  \n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (cred->process_keyring) {\n\t\tkey_ref = keyring_search_rcu(\n\t\t\tmake_key_ref(cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN:  \n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase -ENOKEY:  \n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (cred->session_keyring) {\n\t\tkey_ref = keyring_search_rcu(\n\t\t\tmake_key_ref(cred->session_keyring, 1), ctx);\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN:  \n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase -ENOKEY:  \n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\telse if ((user_session = get_user_session_keyring_rcu(cred))) {\n\t\tkey_ref = keyring_search_rcu(make_key_ref(user_session, 1),\n\t\t\t\t\t     ctx);\n\t\tkey_put(user_session);\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN:  \n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase -ENOKEY:  \n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n \nkey_ref_t search_process_keyrings_rcu(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tkey_ref = search_cred_keyrings_rcu(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t \n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\t\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_cred_keyrings_rcu(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t}\n\t}\n\n\t \n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n \nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n \nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  enum key_need_perm need_perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_RECURSE),\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key, *user_session;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t \n\t\t\tret = look_up_user_keyrings(NULL, &user_session);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(user_session);\n\n\t\t\tkey_put(user_session);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t    &ctx.cred->session_keyring->flags) &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tret = look_up_user_keyrings(&key, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tret = look_up_user_keyrings(NULL, &key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t \n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t \n\t\tctx.index_key\t\t\t= key->index_key;\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\trcu_read_lock();\n\t\tskey_ref = search_process_keyrings_rcu(&ctx);\n\t\trcu_read_unlock();\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t \n\tif (need_perm != KEY_NEED_UNLINK) {\n\t\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\t\tret = wait_for_key_construction(key, true);\n\t\t\tswitch (ret) {\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\tgoto invalid_key;\n\t\t\tdefault:\n\t\t\t\tif (need_perm != KEY_AUTHTOKEN_OVERRIDE &&\n\t\t\t\t    need_perm != KEY_DEFER_PERM_CHECK)\n\t\t\t\t\tgoto invalid_key;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (need_perm != KEY_DEFER_PERM_CHECK) {\n\t\t\tret = key_validate(key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto invalid_key;\n\t\t}\n\n\t\tret = -EIO;\n\t\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\t\tgoto invalid_key;\n\t}\n\n\t \n\tret = key_task_permission(key_ref, ctx.cred, need_perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t \nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\nEXPORT_SYMBOL(lookup_user_key);\n\n \nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t \n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t \n\tmutex_lock(&key_session_mutex);\n\n\t \n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t \n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tret = 0;\n\t\tgoto error3;\n\t}\n\n\t \n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error3;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror3:\n\tkey_put(keyring);\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n \nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(!get_ucounts(old->ucounts))) {\n\t\tWARN_ONCE(1, \"In %s get_ucounts failed\\n\", __func__);\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->ucounts\t= old->ucounts;\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n \nstatic int __init init_root_keyring(void)\n{\n\treturn look_up_user_keyrings(NULL, NULL);\n}\n\nlate_initcall(init_root_keyring);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}