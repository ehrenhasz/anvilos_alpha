{
  "module_name": "persistent.c",
  "hash_id": "540df98ca71193f9dd851453bb54480bbfc08a24d063805e2ccf71dc95f2945a",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/persistent.c",
  "human_readable_source": "\n \n\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n\n#include \"internal.h\"\n\nunsigned persistent_keyring_expiry = 3 * 24 * 3600;  \n\n \nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}\n\n \nstatic key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t\t       struct keyring_index_key *index_key)\n{\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\n\tif (!ns->persistent_keyring_register) {\n\t\tlong err = key_create_persistent_register(ns);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t} else {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tpersistent_ref = find_key_to_update(reg_ref, index_key);\n\t\tif (persistent_ref)\n\t\t\treturn persistent_ref;\n\t}\n\n\tpersistent = keyring_alloc(index_key->description,\n\t\t\t\t   uid, INVALID_GID, current_cred(),\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA, NULL,\n\t\t\t\t   ns->persistent_keyring_register);\n\tif (IS_ERR(persistent))\n\t\treturn ERR_CAST(persistent);\n\n\treturn make_key_ref(persistent, true);\n}\n\n \nstatic long key_get_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t       key_ref_t dest_ref)\n{\n\tstruct keyring_index_key index_key;\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\tchar buf[32];\n\tlong ret;\n\n\t \n\tmemset(&index_key, 0, sizeof(index_key));\n\tindex_key.type = &key_type_keyring;\n\tindex_key.description = buf;\n\tindex_key.desc_len = sprintf(buf, \"_persistent.%u\", from_kuid(ns, uid));\n\tkey_set_index_key(&index_key);\n\n\tif (ns->persistent_keyring_register) {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tdown_read(&ns->keyring_sem);\n\t\tpersistent_ref = find_key_to_update(reg_ref, &index_key);\n\t\tup_read(&ns->keyring_sem);\n\n\t\tif (persistent_ref)\n\t\t\tgoto found;\n\t}\n\n\t \n\tdown_write(&ns->keyring_sem);\n\tpersistent_ref = key_create_persistent(ns, uid, &index_key);\n\tup_write(&ns->keyring_sem);\n\tif (!IS_ERR(persistent_ref))\n\t\tgoto found;\n\n\treturn PTR_ERR(persistent_ref);\n\nfound:\n\tret = key_task_permission(persistent_ref, current_cred(), KEY_NEED_LINK);\n\tif (ret == 0) {\n\t\tpersistent = key_ref_to_ptr(persistent_ref);\n\t\tret = key_link(key_ref_to_ptr(dest_ref), persistent);\n\t\tif (ret == 0) {\n\t\t\tkey_set_timeout(persistent, persistent_keyring_expiry);\n\t\t\tret = persistent->serial;\n\t\t}\n\t}\n\n\tkey_ref_put(persistent_ref);\n\treturn ret;\n}\n\n \nlong keyctl_get_persistent(uid_t _uid, key_serial_t destid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tkey_ref_t dest_ref;\n\tkuid_t uid;\n\tlong ret;\n\n\t \n\tif (_uid == (uid_t)-1) {\n\t\tuid = current_uid();\n\t} else {\n\t\tuid = make_kuid(ns, _uid);\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!uid_eq(uid, current_uid()) &&\n\t\t    !uid_eq(uid, current_euid()) &&\n\t\t    !ns_capable(ns, CAP_SETUID))\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\tdest_ref = lookup_user_key(destid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(dest_ref))\n\t\treturn PTR_ERR(dest_ref);\n\tif (key_ref_to_ptr(dest_ref)->type != &key_type_keyring) {\n\t\tret = -ENOTDIR;\n\t\tgoto out_put_dest;\n\t}\n\n\tret = key_get_persistent(ns, uid, dest_ref);\n\nout_put_dest:\n\tkey_ref_put(dest_ref);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}