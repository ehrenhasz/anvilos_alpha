{
  "module_name": "permission.c",
  "hash_id": "7f02615607b5e9be99bf97c1920cac16c90ca32b49324bdb12c295372bff440d",
  "original_prompt": "Ingested from linux-6.6.14/security/keys/permission.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/security.h>\n#include \"internal.h\"\n\n \nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tenum key_need_perm need_perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm, mask;\n\tint ret;\n\n\tswitch (need_perm) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EACCES;\n\tcase KEY_NEED_UNLINK:\n\tcase KEY_SYSADMIN_OVERRIDE:\n\tcase KEY_AUTHTOKEN_OVERRIDE:\n\tcase KEY_DEFER_PERM_CHECK:\n\t\tgoto lsm;\n\n\tcase KEY_NEED_VIEW:\tmask = KEY_OTH_VIEW;\tbreak;\n\tcase KEY_NEED_READ:\tmask = KEY_OTH_READ;\tbreak;\n\tcase KEY_NEED_WRITE:\tmask = KEY_OTH_WRITE;\tbreak;\n\tcase KEY_NEED_SEARCH:\tmask = KEY_OTH_SEARCH;\tbreak;\n\tcase KEY_NEED_LINK:\tmask = KEY_OTH_LINK;\tbreak;\n\tcase KEY_NEED_SETATTR:\tmask = KEY_OTH_SETATTR;\tbreak;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t \n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t \n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t \n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t \n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tif ((kperm & mask) != mask)\n\t\treturn -EACCES;\n\n\t \nlsm:\n\treturn security_key_permission(key_ref, cred, need_perm);\n}\nEXPORT_SYMBOL(key_task_permission);\n\n \nint key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t \n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t \n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(key_validate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}