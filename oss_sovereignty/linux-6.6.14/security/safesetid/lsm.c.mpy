{
  "module_name": "lsm.c",
  "hash_id": "9f9822e84829df07a5689509cf1217fa92aaa4cee7c80997180d3e173cd142e2",
  "original_prompt": "Ingested from linux-6.6.14/security/safesetid/lsm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SafeSetID: \" fmt\n\n#include <linux/lsm_hooks.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/security.h>\n#include \"lsm.h\"\n\n \nint safesetid_initialized __initdata;\n\nstruct setid_ruleset __rcu *safesetid_setuid_rules;\nstruct setid_ruleset __rcu *safesetid_setgid_rules;\n\n\n \nenum sid_policy_type _setid_policy_lookup(struct setid_ruleset *policy,\n\t\tkid_t src, kid_t dst)\n{\n\tstruct setid_rule *rule;\n\tenum sid_policy_type result = SIDPOL_DEFAULT;\n\n\tif (policy->type == UID) {\n\t\thash_for_each_possible(policy->rules, rule, next, __kuid_val(src.uid)) {\n\t\t\tif (!uid_eq(rule->src_id.uid, src.uid))\n\t\t\t\tcontinue;\n\t\t\tif (uid_eq(rule->dst_id.uid, dst.uid))\n\t\t\t\treturn SIDPOL_ALLOWED;\n\t\t\tresult = SIDPOL_CONSTRAINED;\n\t\t}\n\t} else if (policy->type == GID) {\n\t\thash_for_each_possible(policy->rules, rule, next, __kgid_val(src.gid)) {\n\t\t\tif (!gid_eq(rule->src_id.gid, src.gid))\n\t\t\t\tcontinue;\n\t\t\tif (gid_eq(rule->dst_id.gid, dst.gid)){\n\t\t\t\treturn SIDPOL_ALLOWED;\n\t\t\t}\n\t\t\tresult = SIDPOL_CONSTRAINED;\n\t\t}\n\t} else {\n\t\t \n\t\tresult = SIDPOL_CONSTRAINED;\n\t}\n\treturn result;\n}\n\n \nstatic enum sid_policy_type setid_policy_lookup(kid_t src, kid_t dst, enum setid_type new_type)\n{\n\tenum sid_policy_type result = SIDPOL_DEFAULT;\n\tstruct setid_ruleset *pol;\n\n\trcu_read_lock();\n\tif (new_type == UID)\n\t\tpol = rcu_dereference(safesetid_setuid_rules);\n\telse if (new_type == GID)\n\t\tpol = rcu_dereference(safesetid_setgid_rules);\n\telse {  \n\t\tresult = SIDPOL_CONSTRAINED;\n\t\trcu_read_unlock();\n\t\treturn result;\n\t}\n\n\tif (pol) {\n\t\tpol->type = new_type;\n\t\tresult = _setid_policy_lookup(pol, src, dst);\n\t}\n\trcu_read_unlock();\n\treturn result;\n}\n\nstatic int safesetid_security_capable(const struct cred *cred,\n\t\t\t\t      struct user_namespace *ns,\n\t\t\t\t      int cap,\n\t\t\t\t      unsigned int opts)\n{\n\t \n\tif (cap != CAP_SETUID && cap != CAP_SETGID)\n\t\treturn 0;\n\n\t \n\tif ((opts & CAP_OPT_INSETID) != 0)\n\t\treturn 0;\n\n\tswitch (cap) {\n\tcase CAP_SETUID:\n\t\t \n\t\tif (setid_policy_lookup((kid_t){.uid = cred->uid}, INVALID_ID, UID) == SIDPOL_DEFAULT)\n\t\t\treturn 0;\n\t\t \n\t\tpr_warn(\"Operation requires CAP_SETUID, which is not available to UID %u for operations besides approved set*uid transitions\\n\",\n\t\t\t__kuid_val(cred->uid));\n\t\treturn -EPERM;\n\tcase CAP_SETGID:\n\t\t \n\t\tif (setid_policy_lookup((kid_t){.gid = cred->gid}, INVALID_ID, GID) == SIDPOL_DEFAULT)\n\t\t\treturn 0;\n\t\t \n\t\tpr_warn(\"Operation requires CAP_SETGID, which is not available to GID %u for operations besides approved set*gid transitions\\n\",\n\t\t\t__kgid_val(cred->gid));\n\t\treturn -EPERM;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n \nstatic bool id_permitted_for_cred(const struct cred *old, kid_t new_id, enum setid_type new_type)\n{\n\tbool permitted;\n\n\t \n\tif (new_type == UID) {\n\t\tif (uid_eq(new_id.uid, old->uid) || uid_eq(new_id.uid, old->euid) ||\n\t\t\tuid_eq(new_id.uid, old->suid))\n\t\t\treturn true;\n\t} else if (new_type == GID){\n\t\tif (gid_eq(new_id.gid, old->gid) || gid_eq(new_id.gid, old->egid) ||\n\t\t\tgid_eq(new_id.gid, old->sgid))\n\t\t\treturn true;\n\t} else  \n\t\treturn false;\n\n\t \n\tpermitted =\n\t    setid_policy_lookup((kid_t){.uid = old->uid}, new_id, new_type) != SIDPOL_CONSTRAINED;\n\n\tif (!permitted) {\n\t\tif (new_type == UID) {\n\t\t\tpr_warn(\"UID transition ((%d,%d,%d) -> %d) blocked\\n\",\n\t\t\t\t__kuid_val(old->uid), __kuid_val(old->euid),\n\t\t\t\t__kuid_val(old->suid), __kuid_val(new_id.uid));\n\t\t} else if (new_type == GID) {\n\t\t\tpr_warn(\"GID transition ((%d,%d,%d) -> %d) blocked\\n\",\n\t\t\t\t__kgid_val(old->gid), __kgid_val(old->egid),\n\t\t\t\t__kgid_val(old->sgid), __kgid_val(new_id.gid));\n\t\t} else  \n\t\t\treturn false;\n\t}\n\treturn permitted;\n}\n\n \nstatic int safesetid_task_fix_setuid(struct cred *new,\n\t\t\t\t     const struct cred *old,\n\t\t\t\t     int flags)\n{\n\n\t \n\tif (setid_policy_lookup((kid_t){.uid = old->uid}, INVALID_ID, UID) == SIDPOL_DEFAULT)\n\t\treturn 0;\n\n\tif (id_permitted_for_cred(old, (kid_t){.uid = new->uid}, UID) &&\n\t    id_permitted_for_cred(old, (kid_t){.uid = new->euid}, UID) &&\n\t    id_permitted_for_cred(old, (kid_t){.uid = new->suid}, UID) &&\n\t    id_permitted_for_cred(old, (kid_t){.uid = new->fsuid}, UID))\n\t\treturn 0;\n\n\t \n\tforce_sig(SIGKILL);\n\treturn -EACCES;\n}\n\nstatic int safesetid_task_fix_setgid(struct cred *new,\n\t\t\t\t     const struct cred *old,\n\t\t\t\t     int flags)\n{\n\n\t \n\tif (setid_policy_lookup((kid_t){.gid = old->gid}, INVALID_ID, GID) == SIDPOL_DEFAULT)\n\t\treturn 0;\n\n\tif (id_permitted_for_cred(old, (kid_t){.gid = new->gid}, GID) &&\n\t    id_permitted_for_cred(old, (kid_t){.gid = new->egid}, GID) &&\n\t    id_permitted_for_cred(old, (kid_t){.gid = new->sgid}, GID) &&\n\t    id_permitted_for_cred(old, (kid_t){.gid = new->fsgid}, GID))\n\t\treturn 0;\n\n\t \n\tforce_sig(SIGKILL);\n\treturn -EACCES;\n}\n\nstatic int safesetid_task_fix_setgroups(struct cred *new, const struct cred *old)\n{\n\tint i;\n\n\t \n\tif (setid_policy_lookup((kid_t){.gid = old->gid}, INVALID_ID, GID) == SIDPOL_DEFAULT)\n\t\treturn 0;\n\n\tget_group_info(new->group_info);\n\tfor (i = 0; i < new->group_info->ngroups; i++) {\n\t\tif (!id_permitted_for_cred(old, (kid_t){.gid = new->group_info->gid[i]}, GID)) {\n\t\t\tput_group_info(new->group_info);\n\t\t\t \n\t\t\tforce_sig(SIGKILL);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\tput_group_info(new->group_info);\n\treturn 0;\n}\n\nstatic struct security_hook_list safesetid_security_hooks[] = {\n\tLSM_HOOK_INIT(task_fix_setuid, safesetid_task_fix_setuid),\n\tLSM_HOOK_INIT(task_fix_setgid, safesetid_task_fix_setgid),\n\tLSM_HOOK_INIT(task_fix_setgroups, safesetid_task_fix_setgroups),\n\tLSM_HOOK_INIT(capable, safesetid_security_capable)\n};\n\nstatic int __init safesetid_security_init(void)\n{\n\tsecurity_add_hooks(safesetid_security_hooks,\n\t\t\t   ARRAY_SIZE(safesetid_security_hooks), \"safesetid\");\n\n\t \n\tsafesetid_initialized = 1;\n\n\treturn 0;\n}\n\nDEFINE_LSM(safesetid_security_init) = {\n\t.init = safesetid_security_init,\n\t.name = \"safesetid\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}