{
  "module_name": "securityfs.c",
  "hash_id": "bce399108fd73bf2afbe9de07dbc08cb630dc782eebb2cb2d9b604a10a3e223d",
  "original_prompt": "Ingested from linux-6.6.14/security/safesetid/securityfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SafeSetID: \" fmt\n\n#include <linux/security.h>\n#include <linux/cred.h>\n\n#include \"lsm.h\"\n\nstatic DEFINE_MUTEX(uid_policy_update_lock);\nstatic DEFINE_MUTEX(gid_policy_update_lock);\n\n \nstatic int parse_policy_line(struct file *file, char *buf,\n\tstruct setid_rule *rule)\n{\n\tchar *child_str;\n\tint ret;\n\tu32 parsed_parent, parsed_child;\n\n\t \n\tchild_str = strchr(buf, ':');\n\tif (child_str == NULL)\n\t\treturn -EINVAL;\n\t*child_str = '\\0';\n\tchild_str++;\n\n\tret = kstrtou32(buf, 0, &parsed_parent);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kstrtou32(child_str, 0, &parsed_child);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rule->type == UID){\n\t\trule->src_id.uid = make_kuid(file->f_cred->user_ns, parsed_parent);\n\t\trule->dst_id.uid = make_kuid(file->f_cred->user_ns, parsed_child);\n\t\tif (!uid_valid(rule->src_id.uid) || !uid_valid(rule->dst_id.uid))\n\t\t\treturn -EINVAL;\n\t} else if (rule->type == GID){\n\t\trule->src_id.gid = make_kgid(file->f_cred->user_ns, parsed_parent);\n\t\trule->dst_id.gid = make_kgid(file->f_cred->user_ns, parsed_child);\n\t\tif (!gid_valid(rule->src_id.gid) || !gid_valid(rule->dst_id.gid))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void __release_ruleset(struct rcu_head *rcu)\n{\n\tstruct setid_ruleset *pol =\n\t\tcontainer_of(rcu, struct setid_ruleset, rcu);\n\tint bucket;\n\tstruct setid_rule *rule;\n\tstruct hlist_node *tmp;\n\n\thash_for_each_safe(pol->rules, bucket, tmp, rule, next)\n\t\tkfree(rule);\n\tkfree(pol->policy_str);\n\tkfree(pol);\n}\n\nstatic void release_ruleset(struct setid_ruleset *pol){\n\tcall_rcu(&pol->rcu, __release_ruleset);\n}\n\nstatic void insert_rule(struct setid_ruleset *pol, struct setid_rule *rule)\n{\n\tif (pol->type == UID)\n\t\thash_add(pol->rules, &rule->next, __kuid_val(rule->src_id.uid));\n\telse if (pol->type == GID)\n\t\thash_add(pol->rules, &rule->next, __kgid_val(rule->src_id.gid));\n\telse  \n\t\treturn;\n}\n\nstatic int verify_ruleset(struct setid_ruleset *pol)\n{\n\tint bucket;\n\tstruct setid_rule *rule, *nrule;\n\tint res = 0;\n\n\thash_for_each(pol->rules, bucket, rule, next) {\n\t\tif (_setid_policy_lookup(pol, rule->dst_id, INVALID_ID) == SIDPOL_DEFAULT) {\n\t\t\tif (pol->type == UID) {\n\t\t\t\tpr_warn(\"insecure policy detected: uid %d is constrained but transitively unconstrained through uid %d\\n\",\n\t\t\t\t\t__kuid_val(rule->src_id.uid),\n\t\t\t\t\t__kuid_val(rule->dst_id.uid));\n\t\t\t} else if (pol->type == GID) {\n\t\t\t\tpr_warn(\"insecure policy detected: gid %d is constrained but transitively unconstrained through gid %d\\n\",\n\t\t\t\t\t__kgid_val(rule->src_id.gid),\n\t\t\t\t\t__kgid_val(rule->dst_id.gid));\n\t\t\t} else {  \n\t\t\t\tres = -EINVAL;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tres = -EINVAL;\n\n\t\t\t \n\t\t\tnrule = kmalloc(sizeof(struct setid_rule), GFP_KERNEL);\n\t\t\tif (!nrule)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (pol->type == UID){\n\t\t\t\tnrule->src_id.uid = rule->dst_id.uid;\n\t\t\t\tnrule->dst_id.uid = rule->dst_id.uid;\n\t\t\t\tnrule->type = UID;\n\t\t\t} else {  \n\t\t\t\tnrule->src_id.gid = rule->dst_id.gid;\n\t\t\t\tnrule->dst_id.gid = rule->dst_id.gid;\n\t\t\t\tnrule->type = GID;\n\t\t\t}\n\t\t\tinsert_rule(pol, nrule);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ssize_t handle_policy_update(struct file *file,\n\t\t\t\t    const char __user *ubuf, size_t len, enum setid_type policy_type)\n{\n\tstruct setid_ruleset *pol;\n\tchar *buf, *p, *end;\n\tint err;\n\n\tpol = kmalloc(sizeof(struct setid_ruleset), GFP_KERNEL);\n\tif (!pol)\n\t\treturn -ENOMEM;\n\tpol->policy_str = NULL;\n\tpol->type = policy_type;\n\thash_init(pol->rules);\n\n\tp = buf = memdup_user_nul(ubuf, len);\n\tif (IS_ERR(buf)) {\n\t\terr = PTR_ERR(buf);\n\t\tgoto out_free_pol;\n\t}\n\tpol->policy_str = kstrdup(buf, GFP_KERNEL);\n\tif (pol->policy_str == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_buf;\n\t}\n\n\t \n\twhile (*p != '\\0') {\n\t\tstruct setid_rule *rule;\n\n\t\tend = strchr(p, '\\n');\n\t\tif (end == NULL) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_buf;\n\t\t}\n\t\t*end = '\\0';\n\n\t\trule = kmalloc(sizeof(struct setid_rule), GFP_KERNEL);\n\t\tif (!rule) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_buf;\n\t\t}\n\n\t\trule->type = policy_type;\n\t\terr = parse_policy_line(file, p, rule);\n\t\tif (err)\n\t\t\tgoto out_free_rule;\n\n\t\tif (_setid_policy_lookup(pol, rule->src_id, rule->dst_id) == SIDPOL_ALLOWED) {\n\t\t\tpr_warn(\"bad policy: duplicate entry\\n\");\n\t\t\terr = -EEXIST;\n\t\t\tgoto out_free_rule;\n\t\t}\n\n\t\tinsert_rule(pol, rule);\n\t\tp = end + 1;\n\t\tcontinue;\n\nout_free_rule:\n\t\tkfree(rule);\n\t\tgoto out_free_buf;\n\t}\n\n\terr = verify_ruleset(pol);\n\t \n\tif (err && err != -EINVAL)\n\t\tgoto out_free_buf;\n\n\t \n\tif (policy_type == UID) {\n\t\tmutex_lock(&uid_policy_update_lock);\n\t\tpol = rcu_replace_pointer(safesetid_setuid_rules, pol,\n\t\t\t\t\t  lockdep_is_held(&uid_policy_update_lock));\n\t\tmutex_unlock(&uid_policy_update_lock);\n\t} else if (policy_type == GID) {\n\t\tmutex_lock(&gid_policy_update_lock);\n\t\tpol = rcu_replace_pointer(safesetid_setgid_rules, pol,\n\t\t\t\t\t  lockdep_is_held(&gid_policy_update_lock));\n\t\tmutex_unlock(&gid_policy_update_lock);\n\t} else {\n\t\t \n\t\tpr_warn(\"error: bad policy type\");\n\t}\n\terr = len;\n\nout_free_buf:\n\tkfree(buf);\nout_free_pol:\n\tif (pol)\n\t\trelease_ruleset(pol);\n\treturn err;\n}\n\nstatic ssize_t safesetid_uid_file_write(struct file *file,\n\t\t\t\t    const char __user *buf,\n\t\t\t\t    size_t len,\n\t\t\t\t    loff_t *ppos)\n{\n\tif (!file_ns_capable(file, &init_user_ns, CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\treturn handle_policy_update(file, buf, len, UID);\n}\n\nstatic ssize_t safesetid_gid_file_write(struct file *file,\n\t\t\t\t    const char __user *buf,\n\t\t\t\t    size_t len,\n\t\t\t\t    loff_t *ppos)\n{\n\tif (!file_ns_capable(file, &init_user_ns, CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\treturn handle_policy_update(file, buf, len, GID);\n}\n\nstatic ssize_t safesetid_file_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t len, loff_t *ppos, struct mutex *policy_update_lock, struct __rcu setid_ruleset* ruleset)\n{\n\tssize_t res = 0;\n\tstruct setid_ruleset *pol;\n\tconst char *kbuf;\n\n\tmutex_lock(policy_update_lock);\n\tpol = rcu_dereference_protected(ruleset, lockdep_is_held(policy_update_lock));\n\tif (pol) {\n\t\tkbuf = pol->policy_str;\n\t\tres = simple_read_from_buffer(buf, len, ppos,\n\t\t\t\t\t      kbuf, strlen(kbuf));\n\t}\n\tmutex_unlock(policy_update_lock);\n\n\treturn res;\n}\n\nstatic ssize_t safesetid_uid_file_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t len, loff_t *ppos)\n{\n\treturn safesetid_file_read(file, buf, len, ppos,\n\t\t\t\t   &uid_policy_update_lock, safesetid_setuid_rules);\n}\n\nstatic ssize_t safesetid_gid_file_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t len, loff_t *ppos)\n{\n\treturn safesetid_file_read(file, buf, len, ppos,\n\t\t\t\t   &gid_policy_update_lock, safesetid_setgid_rules);\n}\n\n\n\nstatic const struct file_operations safesetid_uid_file_fops = {\n\t.read = safesetid_uid_file_read,\n\t.write = safesetid_uid_file_write,\n};\n\nstatic const struct file_operations safesetid_gid_file_fops = {\n\t.read = safesetid_gid_file_read,\n\t.write = safesetid_gid_file_write,\n};\n\nstatic int __init safesetid_init_securityfs(void)\n{\n\tint ret;\n\tstruct dentry *policy_dir;\n\tstruct dentry *uid_policy_file;\n\tstruct dentry *gid_policy_file;\n\n\tif (!safesetid_initialized)\n\t\treturn 0;\n\n\tpolicy_dir = securityfs_create_dir(\"safesetid\", NULL);\n\tif (IS_ERR(policy_dir)) {\n\t\tret = PTR_ERR(policy_dir);\n\t\tgoto error;\n\t}\n\n\tuid_policy_file = securityfs_create_file(\"uid_allowlist_policy\", 0600,\n\t\t\tpolicy_dir, NULL, &safesetid_uid_file_fops);\n\tif (IS_ERR(uid_policy_file)) {\n\t\tret = PTR_ERR(uid_policy_file);\n\t\tgoto error;\n\t}\n\n\tgid_policy_file = securityfs_create_file(\"gid_allowlist_policy\", 0600,\n\t\t\tpolicy_dir, NULL, &safesetid_gid_file_fops);\n\tif (IS_ERR(gid_policy_file)) {\n\t\tret = PTR_ERR(gid_policy_file);\n\t\tgoto error;\n\t}\n\n\n\treturn 0;\n\nerror:\n\tsecurityfs_remove(policy_dir);\n\treturn ret;\n}\nfs_initcall(safesetid_init_securityfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}