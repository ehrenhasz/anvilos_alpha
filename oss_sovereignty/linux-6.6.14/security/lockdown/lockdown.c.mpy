{
  "module_name": "lockdown.c",
  "hash_id": "3769d95419be563172c0f2dc9f9670ef2c224cc424b7299f71e77f758dc27205",
  "original_prompt": "Ingested from linux-6.6.14/security/lockdown/lockdown.c",
  "human_readable_source": "\n \n\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/lsm_hooks.h>\n\nstatic enum lockdown_reason kernel_locked_down;\n\nstatic const enum lockdown_reason lockdown_levels[] = {LOCKDOWN_NONE,\n\t\t\t\t\t\t LOCKDOWN_INTEGRITY_MAX,\n\t\t\t\t\t\t LOCKDOWN_CONFIDENTIALITY_MAX};\n\n \nstatic int lock_kernel_down(const char *where, enum lockdown_reason level)\n{\n\tif (kernel_locked_down >= level)\n\t\treturn -EPERM;\n\n\tkernel_locked_down = level;\n\tpr_notice(\"Kernel is locked down from %s; see man kernel_lockdown.7\\n\",\n\t\t  where);\n\treturn 0;\n}\n\nstatic int __init lockdown_param(char *level)\n{\n\tif (!level)\n\t\treturn -EINVAL;\n\n\tif (strcmp(level, \"integrity\") == 0)\n\t\tlock_kernel_down(\"command line\", LOCKDOWN_INTEGRITY_MAX);\n\telse if (strcmp(level, \"confidentiality\") == 0)\n\t\tlock_kernel_down(\"command line\", LOCKDOWN_CONFIDENTIALITY_MAX);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nearly_param(\"lockdown\", lockdown_param);\n\n \nstatic int lockdown_is_locked_down(enum lockdown_reason what)\n{\n\tif (WARN(what >= LOCKDOWN_CONFIDENTIALITY_MAX,\n\t\t \"Invalid lockdown reason\"))\n\t\treturn -EPERM;\n\n\tif (kernel_locked_down >= what) {\n\t\tif (lockdown_reasons[what])\n\t\t\tpr_notice_ratelimited(\"Lockdown: %s: %s is restricted; see man kernel_lockdown.7\\n\",\n\t\t\t\t  current->comm, lockdown_reasons[what]);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct security_hook_list lockdown_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(locked_down, lockdown_is_locked_down),\n};\n\nstatic int __init lockdown_lsm_init(void)\n{\n#if defined(CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY)\n\tlock_kernel_down(\"Kernel configuration\", LOCKDOWN_INTEGRITY_MAX);\n#elif defined(CONFIG_LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY)\n\tlock_kernel_down(\"Kernel configuration\", LOCKDOWN_CONFIDENTIALITY_MAX);\n#endif\n\tsecurity_add_hooks(lockdown_hooks, ARRAY_SIZE(lockdown_hooks),\n\t\t\t   \"lockdown\");\n\treturn 0;\n}\n\nstatic ssize_t lockdown_read(struct file *filp, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tchar temp[80];\n\tint i, offset = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(lockdown_levels); i++) {\n\t\tenum lockdown_reason level = lockdown_levels[i];\n\n\t\tif (lockdown_reasons[level]) {\n\t\t\tconst char *label = lockdown_reasons[level];\n\n\t\t\tif (kernel_locked_down == level)\n\t\t\t\toffset += sprintf(temp+offset, \"[%s] \", label);\n\t\t\telse\n\t\t\t\toffset += sprintf(temp+offset, \"%s \", label);\n\t\t}\n\t}\n\n\t \n\tif (offset > 0)\n\t\ttemp[offset-1] = '\\n';\n\n\treturn simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n}\n\nstatic ssize_t lockdown_write(struct file *file, const char __user *buf,\n\t\t\t      size_t n, loff_t *ppos)\n{\n\tchar *state;\n\tint i, len, err = -EINVAL;\n\n\tstate = memdup_user_nul(buf, n);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tlen = strlen(state);\n\tif (len && state[len-1] == '\\n') {\n\t\tstate[len-1] = '\\0';\n\t\tlen--;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lockdown_levels); i++) {\n\t\tenum lockdown_reason level = lockdown_levels[i];\n\t\tconst char *label = lockdown_reasons[level];\n\n\t\tif (label && !strcmp(state, label))\n\t\t\terr = lock_kernel_down(\"securityfs\", level);\n\t}\n\n\tkfree(state);\n\treturn err ? err : n;\n}\n\nstatic const struct file_operations lockdown_ops = {\n\t.read  = lockdown_read,\n\t.write = lockdown_write,\n};\n\nstatic int __init lockdown_secfs_init(void)\n{\n\tstruct dentry *dentry;\n\n\tdentry = securityfs_create_file(\"lockdown\", 0644, NULL, NULL,\n\t\t\t\t\t&lockdown_ops);\n\treturn PTR_ERR_OR_ZERO(dentry);\n}\n\ncore_initcall(lockdown_secfs_init);\n\n#ifdef CONFIG_SECURITY_LOCKDOWN_LSM_EARLY\nDEFINE_EARLY_LSM(lockdown) = {\n#else\nDEFINE_LSM(lockdown) = {\n#endif\n\t.name = \"lockdown\",\n\t.init = lockdown_lsm_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}