{
  "module_name": "device_cgroup.c",
  "hash_id": "bddfe4432bdbf88fc7136b1f5b022878adef318deb580d65ff313b964788858f",
  "original_prompt": "Ingested from linux-6.6.14/security/device_cgroup.c",
  "human_readable_source": "\n \n\n#include <linux/bpf-cgroup.h>\n#include <linux/device_cgroup.h>\n#include <linux/cgroup.h>\n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n\n#ifdef CONFIG_CGROUP_DEVICE\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nenum devcg_behavior {\n\tDEVCG_DEFAULT_NONE,\n\tDEVCG_DEFAULT_ALLOW,\n\tDEVCG_DEFAULT_DENY,\n};\n\n \n\nstruct dev_exception_item {\n\tu32 major, minor;\n\tshort type;\n\tshort access;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\nstruct dev_cgroup {\n\tstruct cgroup_subsys_state css;\n\tstruct list_head exceptions;\n\tenum devcg_behavior behavior;\n};\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}\n\nstatic inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\n{\n\treturn css_to_devcgroup(task_css(task, devices_cgrp_id));\n}\n\n \nstatic int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic void dev_exceptions_move(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(ex, tmp, orig, list) {\n\t\tlist_move_tail(&ex->list, dest);\n\t}\n}\n\n \nstatic int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}\n\n \nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}\n\nstatic void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}\n\n \nstatic void dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\t__dev_exception_clean(dev_cgroup);\n}\n\nstatic inline bool is_devcg_online(const struct dev_cgroup *devcg)\n{\n\treturn (devcg->behavior != DEVCG_DEFAULT_NONE);\n}\n\n \nstatic int devcgroup_online(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\tstruct dev_cgroup *parent_dev_cgroup = css_to_devcgroup(css->parent);\n\tint ret = 0;\n\n\tmutex_lock(&devcgroup_mutex);\n\n\tif (parent_dev_cgroup == NULL)\n\t\tdev_cgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\telse {\n\t\tret = dev_exceptions_copy(&dev_cgroup->exceptions,\n\t\t\t\t\t  &parent_dev_cgroup->exceptions);\n\t\tif (!ret)\n\t\t\tdev_cgroup->behavior = parent_dev_cgroup->behavior;\n\t}\n\tmutex_unlock(&devcgroup_mutex);\n\n\treturn ret;\n}\n\nstatic void devcgroup_offline(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\tmutex_lock(&devcgroup_mutex);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\tmutex_unlock(&devcgroup_mutex);\n}\n\n \nstatic struct cgroup_subsys_state *\ndevcgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\n\tdev_cgroup = kzalloc(sizeof(*dev_cgroup), GFP_KERNEL);\n\tif (!dev_cgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&dev_cgroup->exceptions);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\n\treturn &dev_cgroup->css;\n}\n\nstatic void devcgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\t__dev_exception_clean(dev_cgroup);\n\tkfree(dev_cgroup);\n}\n\n#define DEVCG_ALLOW 1\n#define DEVCG_DENY 2\n#define DEVCG_LIST 3\n\n#define MAJMINLEN 13\n#define ACCLEN 4\n\nstatic void set_access(char *acc, short access)\n{\n\tint idx = 0;\n\tmemset(acc, 0, ACCLEN);\n\tif (access & DEVCG_ACC_READ)\n\t\tacc[idx++] = 'r';\n\tif (access & DEVCG_ACC_WRITE)\n\t\tacc[idx++] = 'w';\n\tif (access & DEVCG_ACC_MKNOD)\n\t\tacc[idx++] = 'm';\n}\n\nstatic char type_to_char(short type)\n{\n\tif (type == DEVCG_DEV_ALL)\n\t\treturn 'a';\n\tif (type == DEVCG_DEV_CHAR)\n\t\treturn 'c';\n\tif (type == DEVCG_DEV_BLOCK)\n\t\treturn 'b';\n\treturn 'X';\n}\n\nstatic void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}\n\nstatic int devcgroup_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dev_cgroup *devcgroup = css_to_devcgroup(seq_css(m));\n\tstruct dev_exception_item *ex;\n\tchar maj[MAJMINLEN], min[MAJMINLEN], acc[ACCLEN];\n\n\trcu_read_lock();\n\t \n\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tset_access(acc, DEVCG_ACC_MASK);\n\t\tset_majmin(maj, ~0);\n\t\tset_majmin(min, ~0);\n\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(DEVCG_DEV_ALL),\n\t\t\t   maj, min, acc);\n\t} else {\n\t\tlist_for_each_entry_rcu(ex, &devcgroup->exceptions, list) {\n\t\t\tset_access(acc, ex->access);\n\t\t\tset_majmin(maj, ex->major);\n\t\t\tset_majmin(min, ex->minor);\n\t\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(ex->type),\n\t\t\t\t   maj, min, acc);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n \nstatic bool match_exception(struct list_head *exceptions, short type,\n\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\tif (ex->major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t \n\t\tif (access & (~ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list,\n\t\t\t\tlockdep_is_held(&devcgroup_mutex)) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t \n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t \n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool verify_new_ex(struct dev_cgroup *dev_cgroup,\n\t\t          struct dev_exception_item *refex,\n\t\t          enum devcg_behavior behavior)\n{\n\tbool match = false;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex),\n\t\t\t \"device_cgroup:verify_new_ex called without proper synchronization\");\n\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tif (behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t  \n\t\t\treturn true;\n\t\t} else {\n\t\t\t  \n\t\t\tmatch = match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t\t\trefex->type,\n\t\t\t\t\t\t\trefex->major,\n\t\t\t\t\t\t\trefex->minor,\n\t\t\t\t\t\t\trefex->access);\n\n\t\t\tif (match)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t \n\t\tmatch = match_exception(&dev_cgroup->exceptions, refex->type,\n\t\t\t\t\trefex->major, refex->minor,\n\t\t\t\t\trefex->access);\n\n\t\tif (match)\n\t\t\t \n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}\n\n \nstatic int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}\n\n \nstatic bool parent_allows_removal(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn true;\n\n\t \n\tif (childcg->behavior == DEVCG_DEFAULT_DENY)\n\t\treturn true;\n\n\t \n\treturn !match_exception_partial(&parent->exceptions, ex->type,\n\t\t\t\t\tex->major, ex->minor, ex->access);\n}\n\n \nstatic inline int may_allow_all(struct dev_cgroup *parent)\n{\n\tif (!parent)\n\t\treturn 1;\n\treturn parent->behavior == DEVCG_DEFAULT_ALLOW;\n}\n\n \nstatic void revalidate_active_exceptions(struct dev_cgroup *devcg)\n{\n\tstruct dev_exception_item *ex;\n\tstruct list_head *this, *tmp;\n\n\tlist_for_each_safe(this, tmp, &devcg->exceptions) {\n\t\tex = container_of(this, struct dev_exception_item, list);\n\t\tif (!parent_has_perm(devcg, ex))\n\t\t\tdev_exception_rm(devcg, ex);\n\t}\n}\n\n \nstatic int propagate_exception(struct dev_cgroup *devcg_root,\n\t\t\t       struct dev_exception_item *ex)\n{\n\tstruct cgroup_subsys_state *pos;\n\tint rc = 0;\n\n\trcu_read_lock();\n\n\tcss_for_each_descendant_pre(pos, &devcg_root->css) {\n\t\tstruct dev_cgroup *devcg = css_to_devcgroup(pos);\n\n\t\t \n\t\tif (pos == &devcg_root->css || !is_devcg_online(devcg))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\n\t\t    devcg->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\trc = dev_exception_add(devcg, ex);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else {\n\t\t\t \n\t\t\tdev_exception_rm(devcg, ex);\n\t\t}\n\t\trevalidate_active_exceptions(devcg);\n\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nstatic int devcgroup_update_access(struct dev_cgroup *devcgroup,\n\t\t\t\t   int filetype, char *buffer)\n{\n\tconst char *b;\n\tchar temp[12];\t\t \n\tint count, rc = 0;\n\tstruct dev_exception_item ex;\n\tstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\n\tstruct dev_cgroup tmp_devcgrp;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(&ex, 0, sizeof(ex));\n\tmemset(&tmp_devcgrp, 0, sizeof(tmp_devcgrp));\n\tb = buffer;\n\n\tswitch (*b) {\n\tcase 'a':\n\t\tswitch (filetype) {\n\t\tcase DEVCG_ALLOW:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!may_allow_all(parent))\n\t\t\t\treturn -EPERM;\n\t\t\tif (!parent) {\n\t\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\t\tdev_exception_clean(devcgroup);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&tmp_devcgrp.exceptions);\n\t\t\trc = dev_exceptions_copy(&tmp_devcgrp.exceptions,\n\t\t\t\t\t\t &devcgroup->exceptions);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\trc = dev_exceptions_copy(&devcgroup->exceptions,\n\t\t\t\t\t\t &parent->exceptions);\n\t\t\tif (rc) {\n\t\t\t\tdev_exceptions_move(&devcgroup->exceptions,\n\t\t\t\t\t\t    &tmp_devcgrp.exceptions);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\tdev_exception_clean(&tmp_devcgrp);\n\t\t\tbreak;\n\t\tcase DEVCG_DENY:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_DENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase 'b':\n\t\tex.type = DEVCG_DEV_BLOCK;\n\t\tbreak;\n\tcase 'c':\n\t\tex.type = DEVCG_DEV_CHAR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tb++;\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tb++;\n\tif (*b == '*') {\n\t\tex.major = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.major);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (*b != ':')\n\t\treturn -EINVAL;\n\tb++;\n\n\t \n\tif (*b == '*') {\n\t\tex.minor = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.minor);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tfor (b++, count = 0; count < 3; count++, b++) {\n\t\tswitch (*b) {\n\t\tcase 'r':\n\t\t\tex.access |= DEVCG_ACC_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tex.access |= DEVCG_ACC_WRITE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tex.access |= DEVCG_ACC_MKNOD;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcount = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (filetype) {\n\tcase DEVCG_ALLOW:\n\t\t \n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t \n\t\t\tif (!parent_allows_removal(devcgroup, &ex))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent_has_perm(devcgroup, &ex))\n\t\t\treturn -EPERM;\n\t\trc = dev_exception_add(devcgroup, &ex);\n\t\tbreak;\n\tcase DEVCG_DENY:\n\t\t \n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\telse\n\t\t\trc = dev_exception_add(devcgroup, &ex);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t \n\t\trc = propagate_exception(devcgroup, &ex);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t devcgroup_access_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tint retval;\n\n\tmutex_lock(&devcgroup_mutex);\n\tretval = devcgroup_update_access(css_to_devcgroup(of_css(of)),\n\t\t\t\t\t of_cft(of)->private, strstrip(buf));\n\tmutex_unlock(&devcgroup_mutex);\n\treturn retval ?: nbytes;\n}\n\nstatic struct cftype dev_cgroup_files[] = {\n\t{\n\t\t.name = \"allow\",\n\t\t.write = devcgroup_access_write,\n\t\t.private = DEVCG_ALLOW,\n\t},\n\t{\n\t\t.name = \"deny\",\n\t\t.write = devcgroup_access_write,\n\t\t.private = DEVCG_DENY,\n\t},\n\t{\n\t\t.name = \"list\",\n\t\t.seq_show = devcgroup_seq_show,\n\t\t.private = DEVCG_LIST,\n\t},\n\t{ }\t \n};\n\nstruct cgroup_subsys devices_cgrp_subsys = {\n\t.css_alloc = devcgroup_css_alloc,\n\t.css_free = devcgroup_css_free,\n\t.css_online = devcgroup_online,\n\t.css_offline = devcgroup_offline,\n\t.legacy_cftypes = dev_cgroup_files,\n};\n\n \nstatic int devcgroup_legacy_check_permission(short type, u32 major, u32 minor,\n\t\t\t\t\tshort access)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\tbool rc;\n\n\trcu_read_lock();\n\tdev_cgroup = task_devcgroup(current);\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW)\n\t\t \n\t\trc = !match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t      type, major, minor, access);\n\telse\n\t\t \n\t\trc = match_exception(&dev_cgroup->exceptions, type, major,\n\t\t\t\t     minor, access);\n\trcu_read_unlock();\n\n\tif (!rc)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n#endif  \n\n#if defined(CONFIG_CGROUP_DEVICE) || defined(CONFIG_CGROUP_BPF)\n\nint devcgroup_check_permission(short type, u32 major, u32 minor, short access)\n{\n\tint rc = BPF_CGROUP_RUN_PROG_DEVICE_CGROUP(type, major, minor, access);\n\n\tif (rc)\n\t\treturn rc;\n\n\t#ifdef CONFIG_CGROUP_DEVICE\n\treturn devcgroup_legacy_check_permission(type, major, minor, access);\n\n\t#else  \n\treturn 0;\n\n\t#endif  \n}\nEXPORT_SYMBOL(devcgroup_check_permission);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}