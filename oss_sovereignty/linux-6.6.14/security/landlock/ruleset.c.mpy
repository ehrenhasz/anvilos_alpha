{
  "module_name": "ruleset.c",
  "hash_id": "f63cb1a09f33e66a50ec07e10f26b37b684d95200edef743654e65bac83c5e71",
  "original_prompt": "Ingested from linux-6.6.14/security/landlock/ruleset.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bug.h>\n#include <linux/compiler_types.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/lockdep.h>\n#include <linux/overflow.h>\n#include <linux/rbtree.h>\n#include <linux/refcount.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include \"limits.h\"\n#include \"object.h\"\n#include \"ruleset.h\"\n\nstatic struct landlock_ruleset *create_ruleset(const u32 num_layers)\n{\n\tstruct landlock_ruleset *new_ruleset;\n\n\tnew_ruleset =\n\t\tkzalloc(struct_size(new_ruleset, fs_access_masks, num_layers),\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tif (!new_ruleset)\n\t\treturn ERR_PTR(-ENOMEM);\n\trefcount_set(&new_ruleset->usage, 1);\n\tmutex_init(&new_ruleset->lock);\n\tnew_ruleset->root = RB_ROOT;\n\tnew_ruleset->num_layers = num_layers;\n\t \n\treturn new_ruleset;\n}\n\nstruct landlock_ruleset *\nlandlock_create_ruleset(const access_mask_t fs_access_mask)\n{\n\tstruct landlock_ruleset *new_ruleset;\n\n\t \n\tif (!fs_access_mask)\n\t\treturn ERR_PTR(-ENOMSG);\n\tnew_ruleset = create_ruleset(1);\n\tif (!IS_ERR(new_ruleset))\n\t\tnew_ruleset->fs_access_masks[0] = fs_access_mask;\n\treturn new_ruleset;\n}\n\nstatic void build_check_rule(void)\n{\n\tconst struct landlock_rule rule = {\n\t\t.num_layers = ~0,\n\t};\n\n\tBUILD_BUG_ON(rule.num_layers < LANDLOCK_MAX_NUM_LAYERS);\n}\n\nstatic struct landlock_rule *\ncreate_rule(struct landlock_object *const object,\n\t    const struct landlock_layer (*const layers)[], const u32 num_layers,\n\t    const struct landlock_layer *const new_layer)\n{\n\tstruct landlock_rule *new_rule;\n\tu32 new_num_layers;\n\n\tbuild_check_rule();\n\tif (new_layer) {\n\t\t \n\t\tif (WARN_ON_ONCE(num_layers >= LANDLOCK_MAX_NUM_LAYERS))\n\t\t\treturn ERR_PTR(-E2BIG);\n\t\tnew_num_layers = num_layers + 1;\n\t} else {\n\t\tnew_num_layers = num_layers;\n\t}\n\tnew_rule = kzalloc(struct_size(new_rule, layers, new_num_layers),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\tif (!new_rule)\n\t\treturn ERR_PTR(-ENOMEM);\n\tRB_CLEAR_NODE(&new_rule->node);\n\tlandlock_get_object(object);\n\tnew_rule->object = object;\n\tnew_rule->num_layers = new_num_layers;\n\t \n\tmemcpy(new_rule->layers, layers,\n\t       flex_array_size(new_rule, layers, num_layers));\n\tif (new_layer)\n\t\t \n\t\tnew_rule->layers[new_rule->num_layers - 1] = *new_layer;\n\treturn new_rule;\n}\n\nstatic void free_rule(struct landlock_rule *const rule)\n{\n\tmight_sleep();\n\tif (!rule)\n\t\treturn;\n\tlandlock_put_object(rule->object);\n\tkfree(rule);\n}\n\nstatic void build_check_ruleset(void)\n{\n\tconst struct landlock_ruleset ruleset = {\n\t\t.num_rules = ~0,\n\t\t.num_layers = ~0,\n\t};\n\ttypeof(ruleset.fs_access_masks[0]) fs_access_mask = ~0;\n\n\tBUILD_BUG_ON(ruleset.num_rules < LANDLOCK_MAX_NUM_RULES);\n\tBUILD_BUG_ON(ruleset.num_layers < LANDLOCK_MAX_NUM_LAYERS);\n\tBUILD_BUG_ON(fs_access_mask < LANDLOCK_MASK_ACCESS_FS);\n}\n\n \nstatic int insert_rule(struct landlock_ruleset *const ruleset,\n\t\t       struct landlock_object *const object,\n\t\t       const struct landlock_layer (*const layers)[],\n\t\t       size_t num_layers)\n{\n\tstruct rb_node **walker_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct landlock_rule *new_rule;\n\n\tmight_sleep();\n\tlockdep_assert_held(&ruleset->lock);\n\tif (WARN_ON_ONCE(!object || !layers))\n\t\treturn -ENOENT;\n\twalker_node = &(ruleset->root.rb_node);\n\twhile (*walker_node) {\n\t\tstruct landlock_rule *const this =\n\t\t\trb_entry(*walker_node, struct landlock_rule, node);\n\n\t\tif (this->object != object) {\n\t\t\tparent_node = *walker_node;\n\t\t\tif (this->object < object)\n\t\t\t\twalker_node = &((*walker_node)->rb_right);\n\t\t\telse\n\t\t\t\twalker_node = &((*walker_node)->rb_left);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (WARN_ON_ONCE(num_layers != 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif ((*layers)[0].level == 0) {\n\t\t\t \n\t\t\tif (WARN_ON_ONCE(this->num_layers != 1))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (WARN_ON_ONCE(this->layers[0].level != 0))\n\t\t\t\treturn -EINVAL;\n\t\t\tthis->layers[0].access |= (*layers)[0].access;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (WARN_ON_ONCE(this->layers[0].level == 0))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tnew_rule = create_rule(object, &this->layers, this->num_layers,\n\t\t\t\t       &(*layers)[0]);\n\t\tif (IS_ERR(new_rule))\n\t\t\treturn PTR_ERR(new_rule);\n\t\trb_replace_node(&this->node, &new_rule->node, &ruleset->root);\n\t\tfree_rule(this);\n\t\treturn 0;\n\t}\n\n\t \n\tbuild_check_ruleset();\n\tif (ruleset->num_rules >= LANDLOCK_MAX_NUM_RULES)\n\t\treturn -E2BIG;\n\tnew_rule = create_rule(object, layers, num_layers, NULL);\n\tif (IS_ERR(new_rule))\n\t\treturn PTR_ERR(new_rule);\n\trb_link_node(&new_rule->node, parent_node, walker_node);\n\trb_insert_color(&new_rule->node, &ruleset->root);\n\truleset->num_rules++;\n\treturn 0;\n}\n\nstatic void build_check_layer(void)\n{\n\tconst struct landlock_layer layer = {\n\t\t.level = ~0,\n\t\t.access = ~0,\n\t};\n\n\tBUILD_BUG_ON(layer.level < LANDLOCK_MAX_NUM_LAYERS);\n\tBUILD_BUG_ON(layer.access < LANDLOCK_MASK_ACCESS_FS);\n}\n\n \nint landlock_insert_rule(struct landlock_ruleset *const ruleset,\n\t\t\t struct landlock_object *const object,\n\t\t\t const access_mask_t access)\n{\n\tstruct landlock_layer layers[] = { {\n\t\t.access = access,\n\t\t \n\t\t.level = 0,\n\t} };\n\n\tbuild_check_layer();\n\treturn insert_rule(ruleset, object, &layers, ARRAY_SIZE(layers));\n}\n\nstatic inline void get_hierarchy(struct landlock_hierarchy *const hierarchy)\n{\n\tif (hierarchy)\n\t\trefcount_inc(&hierarchy->usage);\n}\n\nstatic void put_hierarchy(struct landlock_hierarchy *hierarchy)\n{\n\twhile (hierarchy && refcount_dec_and_test(&hierarchy->usage)) {\n\t\tconst struct landlock_hierarchy *const freeme = hierarchy;\n\n\t\thierarchy = hierarchy->parent;\n\t\tkfree(freeme);\n\t}\n}\n\nstatic int merge_ruleset(struct landlock_ruleset *const dst,\n\t\t\t struct landlock_ruleset *const src)\n{\n\tstruct landlock_rule *walker_rule, *next_rule;\n\tint err = 0;\n\n\tmight_sleep();\n\t \n\tif (WARN_ON_ONCE(!src))\n\t\treturn 0;\n\t \n\tif (WARN_ON_ONCE(!dst || !dst->hierarchy))\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&dst->lock);\n\tmutex_lock_nested(&src->lock, SINGLE_DEPTH_NESTING);\n\n\t \n\tif (WARN_ON_ONCE(src->num_layers != 1 || dst->num_layers < 1)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tdst->fs_access_masks[dst->num_layers - 1] = src->fs_access_masks[0];\n\n\t \n\trbtree_postorder_for_each_entry_safe(walker_rule, next_rule, &src->root,\n\t\t\t\t\t     node) {\n\t\tstruct landlock_layer layers[] = { {\n\t\t\t.level = dst->num_layers,\n\t\t} };\n\n\t\tif (WARN_ON_ONCE(walker_rule->num_layers != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (WARN_ON_ONCE(walker_rule->layers[0].level != 0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tlayers[0].access = walker_rule->layers[0].access;\n\t\terr = insert_rule(dst, walker_rule->object, &layers,\n\t\t\t\t  ARRAY_SIZE(layers));\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&src->lock);\n\tmutex_unlock(&dst->lock);\n\treturn err;\n}\n\nstatic int inherit_ruleset(struct landlock_ruleset *const parent,\n\t\t\t   struct landlock_ruleset *const child)\n{\n\tstruct landlock_rule *walker_rule, *next_rule;\n\tint err = 0;\n\n\tmight_sleep();\n\tif (!parent)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&child->lock);\n\tmutex_lock_nested(&parent->lock, SINGLE_DEPTH_NESTING);\n\n\t \n\trbtree_postorder_for_each_entry_safe(walker_rule, next_rule,\n\t\t\t\t\t     &parent->root, node) {\n\t\terr = insert_rule(child, walker_rule->object,\n\t\t\t\t  &walker_rule->layers,\n\t\t\t\t  walker_rule->num_layers);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (WARN_ON_ONCE(child->num_layers <= parent->num_layers)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\t \n\tmemcpy(child->fs_access_masks, parent->fs_access_masks,\n\t       flex_array_size(parent, fs_access_masks, parent->num_layers));\n\n\tif (WARN_ON_ONCE(!parent->hierarchy)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tget_hierarchy(parent->hierarchy);\n\tchild->hierarchy->parent = parent->hierarchy;\n\nout_unlock:\n\tmutex_unlock(&parent->lock);\n\tmutex_unlock(&child->lock);\n\treturn err;\n}\n\nstatic void free_ruleset(struct landlock_ruleset *const ruleset)\n{\n\tstruct landlock_rule *freeme, *next;\n\n\tmight_sleep();\n\trbtree_postorder_for_each_entry_safe(freeme, next, &ruleset->root, node)\n\t\tfree_rule(freeme);\n\tput_hierarchy(ruleset->hierarchy);\n\tkfree(ruleset);\n}\n\nvoid landlock_put_ruleset(struct landlock_ruleset *const ruleset)\n{\n\tmight_sleep();\n\tif (ruleset && refcount_dec_and_test(&ruleset->usage))\n\t\tfree_ruleset(ruleset);\n}\n\nstatic void free_ruleset_work(struct work_struct *const work)\n{\n\tstruct landlock_ruleset *ruleset;\n\n\truleset = container_of(work, struct landlock_ruleset, work_free);\n\tfree_ruleset(ruleset);\n}\n\nvoid landlock_put_ruleset_deferred(struct landlock_ruleset *const ruleset)\n{\n\tif (ruleset && refcount_dec_and_test(&ruleset->usage)) {\n\t\tINIT_WORK(&ruleset->work_free, free_ruleset_work);\n\t\tschedule_work(&ruleset->work_free);\n\t}\n}\n\n \nstruct landlock_ruleset *\nlandlock_merge_ruleset(struct landlock_ruleset *const parent,\n\t\t       struct landlock_ruleset *const ruleset)\n{\n\tstruct landlock_ruleset *new_dom;\n\tu32 num_layers;\n\tint err;\n\n\tmight_sleep();\n\tif (WARN_ON_ONCE(!ruleset || parent == ruleset))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (parent) {\n\t\tif (parent->num_layers >= LANDLOCK_MAX_NUM_LAYERS)\n\t\t\treturn ERR_PTR(-E2BIG);\n\t\tnum_layers = parent->num_layers + 1;\n\t} else {\n\t\tnum_layers = 1;\n\t}\n\n\t \n\tnew_dom = create_ruleset(num_layers);\n\tif (IS_ERR(new_dom))\n\t\treturn new_dom;\n\tnew_dom->hierarchy =\n\t\tkzalloc(sizeof(*new_dom->hierarchy), GFP_KERNEL_ACCOUNT);\n\tif (!new_dom->hierarchy) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_dom;\n\t}\n\trefcount_set(&new_dom->hierarchy->usage, 1);\n\n\t \n\terr = inherit_ruleset(parent, new_dom);\n\tif (err)\n\t\tgoto out_put_dom;\n\n\t \n\terr = merge_ruleset(new_dom, ruleset);\n\tif (err)\n\t\tgoto out_put_dom;\n\n\treturn new_dom;\n\nout_put_dom:\n\tlandlock_put_ruleset(new_dom);\n\treturn ERR_PTR(err);\n}\n\n \nconst struct landlock_rule *\nlandlock_find_rule(const struct landlock_ruleset *const ruleset,\n\t\t   const struct landlock_object *const object)\n{\n\tconst struct rb_node *node;\n\n\tif (!object)\n\t\treturn NULL;\n\tnode = ruleset->root.rb_node;\n\twhile (node) {\n\t\tstruct landlock_rule *this =\n\t\t\trb_entry(node, struct landlock_rule, node);\n\n\t\tif (this->object == object)\n\t\t\treturn this;\n\t\tif (this->object < object)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tnode = node->rb_left;\n\t}\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}