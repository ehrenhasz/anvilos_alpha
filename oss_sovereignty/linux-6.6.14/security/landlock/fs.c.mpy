{
  "module_name": "fs.c",
  "hash_id": "239f84c5acec0582a3a288581e0843b48afddc4baf7b7306b4b99cf1f135022f",
  "original_prompt": "Ingested from linux-6.6.14/security/landlock/fs.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/bits.h>\n#include <linux/compiler_types.h>\n#include <linux/dcache.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/lsm_hooks.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/path.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/types.h>\n#include <linux/wait_bit.h>\n#include <linux/workqueue.h>\n#include <uapi/linux/landlock.h>\n\n#include \"common.h\"\n#include \"cred.h\"\n#include \"fs.h\"\n#include \"limits.h\"\n#include \"object.h\"\n#include \"ruleset.h\"\n#include \"setup.h\"\n\n \n\nstatic void release_inode(struct landlock_object *const object)\n\t__releases(object->lock)\n{\n\tstruct inode *const inode = object->underobj;\n\tstruct super_block *sb;\n\n\tif (!inode) {\n\t\tspin_unlock(&object->lock);\n\t\treturn;\n\t}\n\n\t \n\tobject->underobj = NULL;\n\t \n\tsb = inode->i_sb;\n\tatomic_long_inc(&landlock_superblock(sb)->inode_refs);\n\tspin_unlock(&object->lock);\n\t \n\trcu_assign_pointer(landlock_inode(inode)->object, NULL);\n\t \n\n\tiput(inode);\n\tif (atomic_long_dec_and_test(&landlock_superblock(sb)->inode_refs))\n\t\twake_up_var(&landlock_superblock(sb)->inode_refs);\n}\n\nstatic const struct landlock_object_underops landlock_fs_underops = {\n\t.release = release_inode\n};\n\n \n\nstatic struct landlock_object *get_inode_object(struct inode *const inode)\n{\n\tstruct landlock_object *object, *new_object;\n\tstruct landlock_inode_security *inode_sec = landlock_inode(inode);\n\n\trcu_read_lock();\nretry:\n\tobject = rcu_dereference(inode_sec->object);\n\tif (object) {\n\t\tif (likely(refcount_inc_not_zero(&object->usage))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn object;\n\t\t}\n\t\t \n\t\tspin_lock(&object->lock);\n\t\tspin_unlock(&object->lock);\n\t\tgoto retry;\n\t}\n\trcu_read_unlock();\n\n\t \n\tnew_object = landlock_create_object(&landlock_fs_underops, inode);\n\tif (IS_ERR(new_object))\n\t\treturn new_object;\n\n\t \n\tspin_lock(&inode->i_lock);\n\tif (unlikely(rcu_access_pointer(inode_sec->object))) {\n\t\t \n\t\tspin_unlock(&inode->i_lock);\n\t\tkfree(new_object);\n\n\t\trcu_read_lock();\n\t\tgoto retry;\n\t}\n\n\t \n\tihold(inode);\n\trcu_assign_pointer(inode_sec->object, new_object);\n\tspin_unlock(&inode->i_lock);\n\treturn new_object;\n}\n\n \n \n#define ACCESS_FILE ( \\\n\tLANDLOCK_ACCESS_FS_EXECUTE | \\\n\tLANDLOCK_ACCESS_FS_WRITE_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_FILE | \\\n\tLANDLOCK_ACCESS_FS_TRUNCATE)\n \n\n \n \n#define ACCESS_INITIALLY_DENIED ( \\\n\tLANDLOCK_ACCESS_FS_REFER)\n \n\n \nint landlock_append_fs_rule(struct landlock_ruleset *const ruleset,\n\t\t\t    const struct path *const path,\n\t\t\t    access_mask_t access_rights)\n{\n\tint err;\n\tstruct landlock_object *object;\n\n\t \n\tif (!d_is_dir(path->dentry) &&\n\t    (access_rights | ACCESS_FILE) != ACCESS_FILE)\n\t\treturn -EINVAL;\n\tif (WARN_ON_ONCE(ruleset->num_layers != 1))\n\t\treturn -EINVAL;\n\n\t \n\taccess_rights |=\n\t\tLANDLOCK_MASK_ACCESS_FS &\n\t\t~(ruleset->fs_access_masks[0] | ACCESS_INITIALLY_DENIED);\n\tobject = get_inode_object(d_backing_inode(path->dentry));\n\tif (IS_ERR(object))\n\t\treturn PTR_ERR(object);\n\tmutex_lock(&ruleset->lock);\n\terr = landlock_insert_rule(ruleset, object, access_rights);\n\tmutex_unlock(&ruleset->lock);\n\t \n\tlandlock_put_object(object);\n\treturn err;\n}\n\n \n\n \nstatic inline const struct landlock_rule *\nfind_rule(const struct landlock_ruleset *const domain,\n\t  const struct dentry *const dentry)\n{\n\tconst struct landlock_rule *rule;\n\tconst struct inode *inode;\n\n\t \n\tif (d_is_negative(dentry))\n\t\treturn NULL;\n\n\tinode = d_backing_inode(dentry);\n\trcu_read_lock();\n\trule = landlock_find_rule(\n\t\tdomain, rcu_dereference(landlock_inode(inode)->object));\n\trcu_read_unlock();\n\treturn rule;\n}\n\n \nstatic inline bool\nunmask_layers(const struct landlock_rule *const rule,\n\t      const access_mask_t access_request,\n\t      layer_mask_t (*const layer_masks)[LANDLOCK_NUM_ACCESS_FS])\n{\n\tsize_t layer_level;\n\n\tif (!access_request || !layer_masks)\n\t\treturn true;\n\tif (!rule)\n\t\treturn false;\n\n\t \n\tfor (layer_level = 0; layer_level < rule->num_layers; layer_level++) {\n\t\tconst struct landlock_layer *const layer =\n\t\t\t&rule->layers[layer_level];\n\t\tconst layer_mask_t layer_bit = BIT_ULL(layer->level - 1);\n\t\tconst unsigned long access_req = access_request;\n\t\tunsigned long access_bit;\n\t\tbool is_empty;\n\n\t\t \n\t\tis_empty = true;\n\t\tfor_each_set_bit(access_bit, &access_req,\n\t\t\t\t ARRAY_SIZE(*layer_masks)) {\n\t\t\tif (layer->access & BIT_ULL(access_bit))\n\t\t\t\t(*layer_masks)[access_bit] &= ~layer_bit;\n\t\t\tis_empty = is_empty && !(*layer_masks)[access_bit];\n\t\t}\n\t\tif (is_empty)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline bool is_nouser_or_private(const struct dentry *dentry)\n{\n\treturn (dentry->d_sb->s_flags & SB_NOUSER) ||\n\t       (d_is_positive(dentry) &&\n\t\tunlikely(IS_PRIVATE(d_backing_inode(dentry))));\n}\n\nstatic inline access_mask_t\nget_handled_accesses(const struct landlock_ruleset *const domain)\n{\n\taccess_mask_t access_dom = ACCESS_INITIALLY_DENIED;\n\tsize_t layer_level;\n\n\tfor (layer_level = 0; layer_level < domain->num_layers; layer_level++)\n\t\taccess_dom |= domain->fs_access_masks[layer_level];\n\treturn access_dom & LANDLOCK_MASK_ACCESS_FS;\n}\n\n \nstatic inline access_mask_t\ninit_layer_masks(const struct landlock_ruleset *const domain,\n\t\t const access_mask_t access_request,\n\t\t layer_mask_t (*const layer_masks)[LANDLOCK_NUM_ACCESS_FS])\n{\n\taccess_mask_t handled_accesses = 0;\n\tsize_t layer_level;\n\n\tmemset(layer_masks, 0, sizeof(*layer_masks));\n\t \n\tif (!access_request)\n\t\treturn 0;\n\n\t \n\tfor (layer_level = 0; layer_level < domain->num_layers; layer_level++) {\n\t\tconst unsigned long access_req = access_request;\n\t\tunsigned long access_bit;\n\n\t\tfor_each_set_bit(access_bit, &access_req,\n\t\t\t\t ARRAY_SIZE(*layer_masks)) {\n\t\t\t \n\t\t\tif (BIT_ULL(access_bit) &\n\t\t\t    (domain->fs_access_masks[layer_level] |\n\t\t\t     ACCESS_INITIALLY_DENIED)) {\n\t\t\t\t(*layer_masks)[access_bit] |=\n\t\t\t\t\tBIT_ULL(layer_level);\n\t\t\t\thandled_accesses |= BIT_ULL(access_bit);\n\t\t\t}\n\t\t}\n\t}\n\treturn handled_accesses;\n}\n\n \nstatic inline bool no_more_access(\n\tconst layer_mask_t (*const layer_masks_parent1)[LANDLOCK_NUM_ACCESS_FS],\n\tconst layer_mask_t (*const layer_masks_child1)[LANDLOCK_NUM_ACCESS_FS],\n\tconst bool child1_is_directory,\n\tconst layer_mask_t (*const layer_masks_parent2)[LANDLOCK_NUM_ACCESS_FS],\n\tconst layer_mask_t (*const layer_masks_child2)[LANDLOCK_NUM_ACCESS_FS],\n\tconst bool child2_is_directory)\n{\n\tunsigned long access_bit;\n\n\tfor (access_bit = 0; access_bit < ARRAY_SIZE(*layer_masks_parent2);\n\t     access_bit++) {\n\t\t \n\t\tconst bool is_file_access =\n\t\t\t!!(BIT_ULL(access_bit) & ACCESS_FILE);\n\n\t\tif (child1_is_directory || is_file_access) {\n\t\t\t \n\t\t\tif ((((*layer_masks_parent1)[access_bit] &\n\t\t\t      (*layer_masks_child1)[access_bit]) |\n\t\t\t     (*layer_masks_parent2)[access_bit]) !=\n\t\t\t    (*layer_masks_parent2)[access_bit])\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!layer_masks_child2)\n\t\t\tcontinue;\n\t\tif (child2_is_directory || is_file_access) {\n\t\t\t \n\t\t\tif ((((*layer_masks_parent2)[access_bit] &\n\t\t\t      (*layer_masks_child2)[access_bit]) |\n\t\t\t     (*layer_masks_parent1)[access_bit]) !=\n\t\t\t    (*layer_masks_parent1)[access_bit])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic inline bool\nscope_to_request(const access_mask_t access_request,\n\t\t layer_mask_t (*const layer_masks)[LANDLOCK_NUM_ACCESS_FS])\n{\n\tconst unsigned long access_req = access_request;\n\tunsigned long access_bit;\n\n\tif (WARN_ON_ONCE(!layer_masks))\n\t\treturn true;\n\n\tfor_each_clear_bit(access_bit, &access_req, ARRAY_SIZE(*layer_masks))\n\t\t(*layer_masks)[access_bit] = 0;\n\treturn !memchr_inv(layer_masks, 0, sizeof(*layer_masks));\n}\n\n \nstatic inline bool\nis_eacces(const layer_mask_t (*const layer_masks)[LANDLOCK_NUM_ACCESS_FS],\n\t  const access_mask_t access_request)\n{\n\tunsigned long access_bit;\n\t \n\tconst unsigned long access_check = access_request &\n\t\t\t\t\t   ~LANDLOCK_ACCESS_FS_REFER;\n\n\tif (!layer_masks)\n\t\treturn false;\n\n\tfor_each_set_bit(access_bit, &access_check, ARRAY_SIZE(*layer_masks)) {\n\t\tif ((*layer_masks)[access_bit])\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool is_access_to_paths_allowed(\n\tconst struct landlock_ruleset *const domain,\n\tconst struct path *const path,\n\tconst access_mask_t access_request_parent1,\n\tlayer_mask_t (*const layer_masks_parent1)[LANDLOCK_NUM_ACCESS_FS],\n\tconst struct dentry *const dentry_child1,\n\tconst access_mask_t access_request_parent2,\n\tlayer_mask_t (*const layer_masks_parent2)[LANDLOCK_NUM_ACCESS_FS],\n\tconst struct dentry *const dentry_child2)\n{\n\tbool allowed_parent1 = false, allowed_parent2 = false, is_dom_check,\n\t     child1_is_directory = true, child2_is_directory = true;\n\tstruct path walker_path;\n\taccess_mask_t access_masked_parent1, access_masked_parent2;\n\tlayer_mask_t _layer_masks_child1[LANDLOCK_NUM_ACCESS_FS],\n\t\t_layer_masks_child2[LANDLOCK_NUM_ACCESS_FS];\n\tlayer_mask_t(*layer_masks_child1)[LANDLOCK_NUM_ACCESS_FS] = NULL,\n\t(*layer_masks_child2)[LANDLOCK_NUM_ACCESS_FS] = NULL;\n\n\tif (!access_request_parent1 && !access_request_parent2)\n\t\treturn true;\n\tif (WARN_ON_ONCE(!domain || !path))\n\t\treturn true;\n\tif (is_nouser_or_private(path->dentry))\n\t\treturn true;\n\tif (WARN_ON_ONCE(domain->num_layers < 1 || !layer_masks_parent1))\n\t\treturn false;\n\n\tif (unlikely(layer_masks_parent2)) {\n\t\tif (WARN_ON_ONCE(!dentry_child1))\n\t\t\treturn false;\n\t\t \n\t\taccess_masked_parent1 = access_masked_parent2 =\n\t\t\tget_handled_accesses(domain);\n\t\tis_dom_check = true;\n\t} else {\n\t\tif (WARN_ON_ONCE(dentry_child1 || dentry_child2))\n\t\t\treturn false;\n\t\t \n\t\taccess_masked_parent1 = access_request_parent1;\n\t\taccess_masked_parent2 = access_request_parent2;\n\t\tis_dom_check = false;\n\t}\n\n\tif (unlikely(dentry_child1)) {\n\t\tunmask_layers(find_rule(domain, dentry_child1),\n\t\t\t      init_layer_masks(domain, LANDLOCK_MASK_ACCESS_FS,\n\t\t\t\t\t       &_layer_masks_child1),\n\t\t\t      &_layer_masks_child1);\n\t\tlayer_masks_child1 = &_layer_masks_child1;\n\t\tchild1_is_directory = d_is_dir(dentry_child1);\n\t}\n\tif (unlikely(dentry_child2)) {\n\t\tunmask_layers(find_rule(domain, dentry_child2),\n\t\t\t      init_layer_masks(domain, LANDLOCK_MASK_ACCESS_FS,\n\t\t\t\t\t       &_layer_masks_child2),\n\t\t\t      &_layer_masks_child2);\n\t\tlayer_masks_child2 = &_layer_masks_child2;\n\t\tchild2_is_directory = d_is_dir(dentry_child2);\n\t}\n\n\twalker_path = *path;\n\tpath_get(&walker_path);\n\t \n\twhile (true) {\n\t\tstruct dentry *parent_dentry;\n\t\tconst struct landlock_rule *rule;\n\n\t\t \n\t\tif (unlikely(is_dom_check &&\n\t\t\t     no_more_access(\n\t\t\t\t     layer_masks_parent1, layer_masks_child1,\n\t\t\t\t     child1_is_directory, layer_masks_parent2,\n\t\t\t\t     layer_masks_child2,\n\t\t\t\t     child2_is_directory))) {\n\t\t\tallowed_parent1 = scope_to_request(\n\t\t\t\taccess_request_parent1, layer_masks_parent1);\n\t\t\tallowed_parent2 = scope_to_request(\n\t\t\t\taccess_request_parent2, layer_masks_parent2);\n\n\t\t\t \n\t\t\tif (allowed_parent1 && allowed_parent2)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tis_dom_check = false;\n\t\t\taccess_masked_parent1 = access_request_parent1;\n\t\t\taccess_masked_parent2 = access_request_parent2;\n\t\t}\n\n\t\trule = find_rule(domain, walker_path.dentry);\n\t\tallowed_parent1 = unmask_layers(rule, access_masked_parent1,\n\t\t\t\t\t\tlayer_masks_parent1);\n\t\tallowed_parent2 = unmask_layers(rule, access_masked_parent2,\n\t\t\t\t\t\tlayer_masks_parent2);\n\n\t\t \n\t\tif (allowed_parent1 && allowed_parent2)\n\t\t\tbreak;\n\njump_up:\n\t\tif (walker_path.dentry == walker_path.mnt->mnt_root) {\n\t\t\tif (follow_up(&walker_path)) {\n\t\t\t\t \n\t\t\t\tgoto jump_up;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(IS_ROOT(walker_path.dentry))) {\n\t\t\t \n\t\t\tallowed_parent1 = allowed_parent2 =\n\t\t\t\t!!(walker_path.mnt->mnt_flags & MNT_INTERNAL);\n\t\t\tbreak;\n\t\t}\n\t\tparent_dentry = dget_parent(walker_path.dentry);\n\t\tdput(walker_path.dentry);\n\t\twalker_path.dentry = parent_dentry;\n\t}\n\tpath_put(&walker_path);\n\n\treturn allowed_parent1 && allowed_parent2;\n}\n\nstatic inline int check_access_path(const struct landlock_ruleset *const domain,\n\t\t\t\t    const struct path *const path,\n\t\t\t\t    access_mask_t access_request)\n{\n\tlayer_mask_t layer_masks[LANDLOCK_NUM_ACCESS_FS] = {};\n\n\taccess_request = init_layer_masks(domain, access_request, &layer_masks);\n\tif (is_access_to_paths_allowed(domain, path, access_request,\n\t\t\t\t       &layer_masks, NULL, 0, NULL, NULL))\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic inline int current_check_access_path(const struct path *const path,\n\t\t\t\t\t    const access_mask_t access_request)\n{\n\tconst struct landlock_ruleset *const dom =\n\t\tlandlock_get_current_domain();\n\n\tif (!dom)\n\t\treturn 0;\n\treturn check_access_path(dom, path, access_request);\n}\n\nstatic inline access_mask_t get_mode_access(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_SYM;\n\tcase 0:\n\t\t \n\tcase S_IFREG:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_REG;\n\tcase S_IFDIR:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_DIR;\n\tcase S_IFCHR:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_CHAR;\n\tcase S_IFBLK:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_BLOCK;\n\tcase S_IFIFO:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn LANDLOCK_ACCESS_FS_MAKE_SOCK;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\nstatic inline access_mask_t maybe_remove(const struct dentry *const dentry)\n{\n\tif (d_is_negative(dentry))\n\t\treturn 0;\n\treturn d_is_dir(dentry) ? LANDLOCK_ACCESS_FS_REMOVE_DIR :\n\t\t\t\t  LANDLOCK_ACCESS_FS_REMOVE_FILE;\n}\n\n \nstatic bool collect_domain_accesses(\n\tconst struct landlock_ruleset *const domain,\n\tconst struct dentry *const mnt_root, struct dentry *dir,\n\tlayer_mask_t (*const layer_masks_dom)[LANDLOCK_NUM_ACCESS_FS])\n{\n\tunsigned long access_dom;\n\tbool ret = false;\n\n\tif (WARN_ON_ONCE(!domain || !mnt_root || !dir || !layer_masks_dom))\n\t\treturn true;\n\tif (is_nouser_or_private(dir))\n\t\treturn true;\n\n\taccess_dom = init_layer_masks(domain, LANDLOCK_MASK_ACCESS_FS,\n\t\t\t\t      layer_masks_dom);\n\n\tdget(dir);\n\twhile (true) {\n\t\tstruct dentry *parent_dentry;\n\n\t\t \n\t\tif (unmask_layers(find_rule(domain, dir), access_dom,\n\t\t\t\t  layer_masks_dom)) {\n\t\t\t \n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dir == mnt_root || WARN_ON_ONCE(IS_ROOT(dir)))\n\t\t\tbreak;\n\n\t\tparent_dentry = dget_parent(dir);\n\t\tdput(dir);\n\t\tdir = parent_dentry;\n\t}\n\tdput(dir);\n\treturn ret;\n}\n\n \nstatic int current_check_refer_path(struct dentry *const old_dentry,\n\t\t\t\t    const struct path *const new_dir,\n\t\t\t\t    struct dentry *const new_dentry,\n\t\t\t\t    const bool removable, const bool exchange)\n{\n\tconst struct landlock_ruleset *const dom =\n\t\tlandlock_get_current_domain();\n\tbool allow_parent1, allow_parent2;\n\taccess_mask_t access_request_parent1, access_request_parent2;\n\tstruct path mnt_dir;\n\tlayer_mask_t layer_masks_parent1[LANDLOCK_NUM_ACCESS_FS],\n\t\tlayer_masks_parent2[LANDLOCK_NUM_ACCESS_FS];\n\n\tif (!dom)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(dom->num_layers < 1))\n\t\treturn -EACCES;\n\tif (unlikely(d_is_negative(old_dentry)))\n\t\treturn -ENOENT;\n\tif (exchange) {\n\t\tif (unlikely(d_is_negative(new_dentry)))\n\t\t\treturn -ENOENT;\n\t\taccess_request_parent1 =\n\t\t\tget_mode_access(d_backing_inode(new_dentry)->i_mode);\n\t} else {\n\t\taccess_request_parent1 = 0;\n\t}\n\taccess_request_parent2 =\n\t\tget_mode_access(d_backing_inode(old_dentry)->i_mode);\n\tif (removable) {\n\t\taccess_request_parent1 |= maybe_remove(old_dentry);\n\t\taccess_request_parent2 |= maybe_remove(new_dentry);\n\t}\n\n\t \n\tif (old_dentry->d_parent == new_dir->dentry) {\n\t\t \n\t\taccess_request_parent1 = init_layer_masks(\n\t\t\tdom, access_request_parent1 | access_request_parent2,\n\t\t\t&layer_masks_parent1);\n\t\tif (is_access_to_paths_allowed(\n\t\t\t    dom, new_dir, access_request_parent1,\n\t\t\t    &layer_masks_parent1, NULL, 0, NULL, NULL))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\taccess_request_parent1 |= LANDLOCK_ACCESS_FS_REFER;\n\taccess_request_parent2 |= LANDLOCK_ACCESS_FS_REFER;\n\n\t \n\tmnt_dir.mnt = new_dir->mnt;\n\tmnt_dir.dentry = new_dir->mnt->mnt_root;\n\n\t \n\tallow_parent1 = collect_domain_accesses(dom, mnt_dir.dentry,\n\t\t\t\t\t\told_dentry->d_parent,\n\t\t\t\t\t\t&layer_masks_parent1);\n\tallow_parent2 = collect_domain_accesses(\n\t\tdom, mnt_dir.dentry, new_dir->dentry, &layer_masks_parent2);\n\n\tif (allow_parent1 && allow_parent2)\n\t\treturn 0;\n\n\t \n\tif (is_access_to_paths_allowed(\n\t\t    dom, &mnt_dir, access_request_parent1, &layer_masks_parent1,\n\t\t    old_dentry, access_request_parent2, &layer_masks_parent2,\n\t\t    exchange ? new_dentry : NULL))\n\t\treturn 0;\n\n\t \n\tif (likely(is_eacces(&layer_masks_parent1, access_request_parent1) ||\n\t\t   is_eacces(&layer_masks_parent2, access_request_parent2)))\n\t\treturn -EACCES;\n\n\t \n\treturn -EXDEV;\n}\n\n \n\nstatic void hook_inode_free_security(struct inode *const inode)\n{\n\t \n\tWARN_ON_ONCE(landlock_inode(inode)->object);\n}\n\n \n\n \nstatic void hook_sb_delete(struct super_block *const sb)\n{\n\tstruct inode *inode, *prev_inode = NULL;\n\n\tif (!landlock_initialized)\n\t\treturn;\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tstruct landlock_object *object;\n\n\t\t \n\t\tif (!atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_lock(&inode->i_lock);\n\t\t \n\t\tif (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tobject = rcu_dereference(landlock_inode(inode)->object);\n\t\tif (!object) {\n\t\t\trcu_read_unlock();\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\t \n\t\tspin_lock(&object->lock);\n\t\tif (object->underobj == inode) {\n\t\t\tobject->underobj = NULL;\n\t\t\tspin_unlock(&object->lock);\n\t\t\trcu_read_unlock();\n\n\t\t\t \n\t\t\trcu_assign_pointer(landlock_inode(inode)->object, NULL);\n\t\t\t \n\t\t\tiput(inode);\n\t\t} else {\n\t\t\tspin_unlock(&object->lock);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tif (prev_inode) {\n\t\t\t \n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\t \n\t\t\tiput(prev_inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&sb->s_inode_list_lock);\n\t\t}\n\t\tprev_inode = inode;\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\t \n\tif (prev_inode)\n\t\tiput(prev_inode);\n\t \n\twait_var_event(&landlock_superblock(sb)->inode_refs,\n\t\t       !atomic_long_read(&landlock_superblock(sb)->inode_refs));\n}\n\n \nstatic int hook_sb_mount(const char *const dev_name,\n\t\t\t const struct path *const path, const char *const type,\n\t\t\t const unsigned long flags, void *const data)\n{\n\tif (!landlock_get_current_domain())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\nstatic int hook_move_mount(const struct path *const from_path,\n\t\t\t   const struct path *const to_path)\n{\n\tif (!landlock_get_current_domain())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\n \nstatic int hook_sb_umount(struct vfsmount *const mnt, const int flags)\n{\n\tif (!landlock_get_current_domain())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\nstatic int hook_sb_remount(struct super_block *const sb, void *const mnt_opts)\n{\n\tif (!landlock_get_current_domain())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\n \nstatic int hook_sb_pivotroot(const struct path *const old_path,\n\t\t\t     const struct path *const new_path)\n{\n\tif (!landlock_get_current_domain())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\n \n\nstatic int hook_path_link(struct dentry *const old_dentry,\n\t\t\t  const struct path *const new_dir,\n\t\t\t  struct dentry *const new_dentry)\n{\n\treturn current_check_refer_path(old_dentry, new_dir, new_dentry, false,\n\t\t\t\t\tfalse);\n}\n\nstatic int hook_path_rename(const struct path *const old_dir,\n\t\t\t    struct dentry *const old_dentry,\n\t\t\t    const struct path *const new_dir,\n\t\t\t    struct dentry *const new_dentry,\n\t\t\t    const unsigned int flags)\n{\n\t \n\treturn current_check_refer_path(old_dentry, new_dir, new_dentry, true,\n\t\t\t\t\t!!(flags & RENAME_EXCHANGE));\n}\n\nstatic int hook_path_mkdir(const struct path *const dir,\n\t\t\t   struct dentry *const dentry, const umode_t mode)\n{\n\treturn current_check_access_path(dir, LANDLOCK_ACCESS_FS_MAKE_DIR);\n}\n\nstatic int hook_path_mknod(const struct path *const dir,\n\t\t\t   struct dentry *const dentry, const umode_t mode,\n\t\t\t   const unsigned int dev)\n{\n\tconst struct landlock_ruleset *const dom =\n\t\tlandlock_get_current_domain();\n\n\tif (!dom)\n\t\treturn 0;\n\treturn check_access_path(dom, dir, get_mode_access(mode));\n}\n\nstatic int hook_path_symlink(const struct path *const dir,\n\t\t\t     struct dentry *const dentry,\n\t\t\t     const char *const old_name)\n{\n\treturn current_check_access_path(dir, LANDLOCK_ACCESS_FS_MAKE_SYM);\n}\n\nstatic int hook_path_unlink(const struct path *const dir,\n\t\t\t    struct dentry *const dentry)\n{\n\treturn current_check_access_path(dir, LANDLOCK_ACCESS_FS_REMOVE_FILE);\n}\n\nstatic int hook_path_rmdir(const struct path *const dir,\n\t\t\t   struct dentry *const dentry)\n{\n\treturn current_check_access_path(dir, LANDLOCK_ACCESS_FS_REMOVE_DIR);\n}\n\nstatic int hook_path_truncate(const struct path *const path)\n{\n\treturn current_check_access_path(path, LANDLOCK_ACCESS_FS_TRUNCATE);\n}\n\n \n\n \nstatic inline access_mask_t\nget_required_file_open_access(const struct file *const file)\n{\n\taccess_mask_t access = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\t \n\t\tif (S_ISDIR(file_inode(file)->i_mode))\n\t\t\treturn LANDLOCK_ACCESS_FS_READ_DIR;\n\t\taccess = LANDLOCK_ACCESS_FS_READ_FILE;\n\t}\n\tif (file->f_mode & FMODE_WRITE)\n\t\taccess |= LANDLOCK_ACCESS_FS_WRITE_FILE;\n\t \n\tif (file->f_flags & __FMODE_EXEC)\n\t\taccess |= LANDLOCK_ACCESS_FS_EXECUTE;\n\treturn access;\n}\n\nstatic int hook_file_alloc_security(struct file *const file)\n{\n\t \n\tlandlock_file(file)->allowed_access = LANDLOCK_MASK_ACCESS_FS;\n\treturn 0;\n}\n\nstatic int hook_file_open(struct file *const file)\n{\n\tlayer_mask_t layer_masks[LANDLOCK_NUM_ACCESS_FS] = {};\n\taccess_mask_t open_access_request, full_access_request, allowed_access;\n\tconst access_mask_t optional_access = LANDLOCK_ACCESS_FS_TRUNCATE;\n\tconst struct landlock_ruleset *const dom =\n\t\tlandlock_get_current_domain();\n\n\tif (!dom)\n\t\treturn 0;\n\n\t \n\topen_access_request = get_required_file_open_access(file);\n\n\t \n\tfull_access_request = open_access_request | optional_access;\n\n\tif (is_access_to_paths_allowed(\n\t\t    dom, &file->f_path,\n\t\t    init_layer_masks(dom, full_access_request, &layer_masks),\n\t\t    &layer_masks, NULL, 0, NULL, NULL)) {\n\t\tallowed_access = full_access_request;\n\t} else {\n\t\tunsigned long access_bit;\n\t\tconst unsigned long access_req = full_access_request;\n\n\t\t \n\t\tallowed_access = 0;\n\t\tfor_each_set_bit(access_bit, &access_req,\n\t\t\t\t ARRAY_SIZE(layer_masks)) {\n\t\t\tif (!layer_masks[access_bit])\n\t\t\t\tallowed_access |= BIT_ULL(access_bit);\n\t\t}\n\t}\n\n\t \n\tlandlock_file(file)->allowed_access = allowed_access;\n\n\tif ((open_access_request & allowed_access) == open_access_request)\n\t\treturn 0;\n\n\treturn -EACCES;\n}\n\nstatic int hook_file_truncate(struct file *const file)\n{\n\t \n\tif (landlock_file(file)->allowed_access & LANDLOCK_ACCESS_FS_TRUNCATE)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic struct security_hook_list landlock_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(inode_free_security, hook_inode_free_security),\n\n\tLSM_HOOK_INIT(sb_delete, hook_sb_delete),\n\tLSM_HOOK_INIT(sb_mount, hook_sb_mount),\n\tLSM_HOOK_INIT(move_mount, hook_move_mount),\n\tLSM_HOOK_INIT(sb_umount, hook_sb_umount),\n\tLSM_HOOK_INIT(sb_remount, hook_sb_remount),\n\tLSM_HOOK_INIT(sb_pivotroot, hook_sb_pivotroot),\n\n\tLSM_HOOK_INIT(path_link, hook_path_link),\n\tLSM_HOOK_INIT(path_rename, hook_path_rename),\n\tLSM_HOOK_INIT(path_mkdir, hook_path_mkdir),\n\tLSM_HOOK_INIT(path_mknod, hook_path_mknod),\n\tLSM_HOOK_INIT(path_symlink, hook_path_symlink),\n\tLSM_HOOK_INIT(path_unlink, hook_path_unlink),\n\tLSM_HOOK_INIT(path_rmdir, hook_path_rmdir),\n\tLSM_HOOK_INIT(path_truncate, hook_path_truncate),\n\n\tLSM_HOOK_INIT(file_alloc_security, hook_file_alloc_security),\n\tLSM_HOOK_INIT(file_open, hook_file_open),\n\tLSM_HOOK_INIT(file_truncate, hook_file_truncate),\n};\n\n__init void landlock_add_fs_hooks(void)\n{\n\tsecurity_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),\n\t\t\t   LANDLOCK_NAME);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}