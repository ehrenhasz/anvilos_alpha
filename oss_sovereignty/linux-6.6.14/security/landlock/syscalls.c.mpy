{
  "module_name": "syscalls.c",
  "hash_id": "25de582ec87900034a1db1db5bf9ac2fc30547996851187510e03bba1da7828e",
  "original_prompt": "Ingested from linux-6.6.14/security/landlock/syscalls.c",
  "human_readable_source": "\n \n\n#include <asm/current.h>\n#include <linux/anon_inodes.h>\n#include <linux/build_bug.h>\n#include <linux/capability.h>\n#include <linux/compiler_types.h>\n#include <linux/dcache.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/limits.h>\n#include <linux/mount.h>\n#include <linux/path.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/stddef.h>\n#include <linux/syscalls.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/landlock.h>\n\n#include \"cred.h\"\n#include \"fs.h\"\n#include \"limits.h\"\n#include \"ruleset.h\"\n#include \"setup.h\"\n\n \nstatic __always_inline int\ncopy_min_struct_from_user(void *const dst, const size_t ksize,\n\t\t\t  const size_t ksize_min, const void __user *const src,\n\t\t\t  const size_t usize)\n{\n\t \n\tBUILD_BUG_ON(!dst);\n\tif (!src)\n\t\treturn -EFAULT;\n\n\t \n\tBUILD_BUG_ON(ksize <= 0);\n\tBUILD_BUG_ON(ksize < ksize_min);\n\tif (usize < ksize_min)\n\t\treturn -EINVAL;\n\tif (usize > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\t \n\treturn copy_struct_from_user(dst, ksize, src, usize);\n}\n\n \nstatic void build_check_abi(void)\n{\n\tstruct landlock_ruleset_attr ruleset_attr;\n\tstruct landlock_path_beneath_attr path_beneath_attr;\n\tsize_t ruleset_size, path_beneath_size;\n\n\t \n\truleset_size = sizeof(ruleset_attr.handled_access_fs);\n\tBUILD_BUG_ON(sizeof(ruleset_attr) != ruleset_size);\n\tBUILD_BUG_ON(sizeof(ruleset_attr) != 8);\n\n\tpath_beneath_size = sizeof(path_beneath_attr.allowed_access);\n\tpath_beneath_size += sizeof(path_beneath_attr.parent_fd);\n\tBUILD_BUG_ON(sizeof(path_beneath_attr) != path_beneath_size);\n\tBUILD_BUG_ON(sizeof(path_beneath_attr) != 12);\n}\n\n \n\nstatic int fop_ruleset_release(struct inode *const inode,\n\t\t\t       struct file *const filp)\n{\n\tstruct landlock_ruleset *ruleset = filp->private_data;\n\n\tlandlock_put_ruleset(ruleset);\n\treturn 0;\n}\n\nstatic ssize_t fop_dummy_read(struct file *const filp, char __user *const buf,\n\t\t\t      const size_t size, loff_t *const ppos)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic ssize_t fop_dummy_write(struct file *const filp,\n\t\t\t       const char __user *const buf, const size_t size,\n\t\t\t       loff_t *const ppos)\n{\n\t \n\treturn -EINVAL;\n}\n\n \nstatic const struct file_operations ruleset_fops = {\n\t.release = fop_ruleset_release,\n\t.read = fop_dummy_read,\n\t.write = fop_dummy_write,\n};\n\n#define LANDLOCK_ABI_VERSION 3\n\n \nSYSCALL_DEFINE3(landlock_create_ruleset,\n\t\tconst struct landlock_ruleset_attr __user *const, attr,\n\t\tconst size_t, size, const __u32, flags)\n{\n\tstruct landlock_ruleset_attr ruleset_attr;\n\tstruct landlock_ruleset *ruleset;\n\tint err, ruleset_fd;\n\n\t \n\tbuild_check_abi();\n\n\tif (!landlock_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags) {\n\t\tif ((flags == LANDLOCK_CREATE_RULESET_VERSION) && !attr &&\n\t\t    !size)\n\t\t\treturn LANDLOCK_ABI_VERSION;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = copy_min_struct_from_user(&ruleset_attr, sizeof(ruleset_attr),\n\t\t\t\t\toffsetofend(typeof(ruleset_attr),\n\t\t\t\t\t\t    handled_access_fs),\n\t\t\t\t\tattr, size);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((ruleset_attr.handled_access_fs | LANDLOCK_MASK_ACCESS_FS) !=\n\t    LANDLOCK_MASK_ACCESS_FS)\n\t\treturn -EINVAL;\n\n\t \n\truleset = landlock_create_ruleset(ruleset_attr.handled_access_fs);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\t \n\truleset_fd = anon_inode_getfd(\"[landlock-ruleset]\", &ruleset_fops,\n\t\t\t\t      ruleset, O_RDWR | O_CLOEXEC);\n\tif (ruleset_fd < 0)\n\t\tlandlock_put_ruleset(ruleset);\n\treturn ruleset_fd;\n}\n\n \nstatic struct landlock_ruleset *get_ruleset_from_fd(const int fd,\n\t\t\t\t\t\t    const fmode_t mode)\n{\n\tstruct fd ruleset_f;\n\tstruct landlock_ruleset *ruleset;\n\n\truleset_f = fdget(fd);\n\tif (!ruleset_f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\t \n\tif (ruleset_f.file->f_op != &ruleset_fops) {\n\t\truleset = ERR_PTR(-EBADFD);\n\t\tgoto out_fdput;\n\t}\n\tif (!(ruleset_f.file->f_mode & mode)) {\n\t\truleset = ERR_PTR(-EPERM);\n\t\tgoto out_fdput;\n\t}\n\truleset = ruleset_f.file->private_data;\n\tif (WARN_ON_ONCE(ruleset->num_layers != 1)) {\n\t\truleset = ERR_PTR(-EINVAL);\n\t\tgoto out_fdput;\n\t}\n\tlandlock_get_ruleset(ruleset);\n\nout_fdput:\n\tfdput(ruleset_f);\n\treturn ruleset;\n}\n\n \n\n \nstatic int get_path_from_fd(const s32 fd, struct path *const path)\n{\n\tstruct fd f;\n\tint err = 0;\n\n\tBUILD_BUG_ON(!__same_type(\n\t\tfd, ((struct landlock_path_beneath_attr *)NULL)->parent_fd));\n\n\t \n\tf = fdget_raw(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\t \n\tif ((f.file->f_op == &ruleset_fops) ||\n\t    (f.file->f_path.mnt->mnt_flags & MNT_INTERNAL) ||\n\t    (f.file->f_path.dentry->d_sb->s_flags & SB_NOUSER) ||\n\t    d_is_negative(f.file->f_path.dentry) ||\n\t    IS_PRIVATE(d_backing_inode(f.file->f_path.dentry))) {\n\t\terr = -EBADFD;\n\t\tgoto out_fdput;\n\t}\n\t*path = f.file->f_path;\n\tpath_get(path);\n\nout_fdput:\n\tfdput(f);\n\treturn err;\n}\n\n \nSYSCALL_DEFINE4(landlock_add_rule, const int, ruleset_fd,\n\t\tconst enum landlock_rule_type, rule_type,\n\t\tconst void __user *const, rule_attr, const __u32, flags)\n{\n\tstruct landlock_path_beneath_attr path_beneath_attr;\n\tstruct path path;\n\tstruct landlock_ruleset *ruleset;\n\tint res, err;\n\n\tif (!landlock_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (flags)\n\t\treturn -EINVAL;\n\n\t \n\truleset = get_ruleset_from_fd(ruleset_fd, FMODE_CAN_WRITE);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\tif (rule_type != LANDLOCK_RULE_PATH_BENEATH) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_ruleset;\n\t}\n\n\t \n\tres = copy_from_user(&path_beneath_attr, rule_attr,\n\t\t\t     sizeof(path_beneath_attr));\n\tif (res) {\n\t\terr = -EFAULT;\n\t\tgoto out_put_ruleset;\n\t}\n\n\t \n\tif (!path_beneath_attr.allowed_access) {\n\t\terr = -ENOMSG;\n\t\tgoto out_put_ruleset;\n\t}\n\t \n\tif ((path_beneath_attr.allowed_access | ruleset->fs_access_masks[0]) !=\n\t    ruleset->fs_access_masks[0]) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_ruleset;\n\t}\n\n\t \n\terr = get_path_from_fd(path_beneath_attr.parent_fd, &path);\n\tif (err)\n\t\tgoto out_put_ruleset;\n\n\t \n\terr = landlock_append_fs_rule(ruleset, &path,\n\t\t\t\t      path_beneath_attr.allowed_access);\n\tpath_put(&path);\n\nout_put_ruleset:\n\tlandlock_put_ruleset(ruleset);\n\treturn err;\n}\n\n \n\n \nSYSCALL_DEFINE2(landlock_restrict_self, const int, ruleset_fd, const __u32,\n\t\tflags)\n{\n\tstruct landlock_ruleset *new_dom, *ruleset;\n\tstruct cred *new_cred;\n\tstruct landlock_cred_security *new_llcred;\n\tint err;\n\n\tif (!landlock_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!task_no_new_privs(current) &&\n\t    !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (flags)\n\t\treturn -EINVAL;\n\n\t \n\truleset = get_ruleset_from_fd(ruleset_fd, FMODE_CAN_READ);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\t \n\tnew_cred = prepare_creds();\n\tif (!new_cred) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_ruleset;\n\t}\n\tnew_llcred = landlock_cred(new_cred);\n\n\t \n\tnew_dom = landlock_merge_ruleset(new_llcred->domain, ruleset);\n\tif (IS_ERR(new_dom)) {\n\t\terr = PTR_ERR(new_dom);\n\t\tgoto out_put_creds;\n\t}\n\n\t \n\tlandlock_put_ruleset(new_llcred->domain);\n\tnew_llcred->domain = new_dom;\n\n\tlandlock_put_ruleset(ruleset);\n\treturn commit_creds(new_cred);\n\nout_put_creds:\n\tabort_creds(new_cred);\n\nout_put_ruleset:\n\tlandlock_put_ruleset(ruleset);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}