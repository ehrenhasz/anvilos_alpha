{
  "module_name": "security.c",
  "hash_id": "e13a984b954eabf680b2cc03ba454d114b22aad18763ef45f3b94a4e2af94aa0",
  "original_prompt": "Ingested from linux-6.6.14/security/security.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"LSM: \" fmt\n\n#include <linux/bpf.h>\n#include <linux/capability.h>\n#include <linux/dcache.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kernel_read_file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/integrity.h>\n#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/fsnotify.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/personality.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/msg.h>\n#include <net/flow.h>\n\n \n#define LSM_COUNT (__end_lsm_info - __start_lsm_info)\n\n \nconst char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX + 1] = {\n\t[LOCKDOWN_NONE] = \"none\",\n\t[LOCKDOWN_MODULE_SIGNATURE] = \"unsigned module loading\",\n\t[LOCKDOWN_DEV_MEM] = \"/dev/mem,kmem,port\",\n\t[LOCKDOWN_EFI_TEST] = \"/dev/efi_test access\",\n\t[LOCKDOWN_KEXEC] = \"kexec of unsigned images\",\n\t[LOCKDOWN_HIBERNATION] = \"hibernation\",\n\t[LOCKDOWN_PCI_ACCESS] = \"direct PCI access\",\n\t[LOCKDOWN_IOPORT] = \"raw io port access\",\n\t[LOCKDOWN_MSR] = \"raw MSR access\",\n\t[LOCKDOWN_ACPI_TABLES] = \"modifying ACPI tables\",\n\t[LOCKDOWN_DEVICE_TREE] = \"modifying device tree contents\",\n\t[LOCKDOWN_PCMCIA_CIS] = \"direct PCMCIA CIS storage\",\n\t[LOCKDOWN_TIOCSSERIAL] = \"reconfiguration of serial port IO\",\n\t[LOCKDOWN_MODULE_PARAMETERS] = \"unsafe module parameters\",\n\t[LOCKDOWN_MMIOTRACE] = \"unsafe mmio\",\n\t[LOCKDOWN_DEBUGFS] = \"debugfs access\",\n\t[LOCKDOWN_XMON_WR] = \"xmon write access\",\n\t[LOCKDOWN_BPF_WRITE_USER] = \"use of bpf to write user RAM\",\n\t[LOCKDOWN_DBG_WRITE_KERNEL] = \"use of kgdb/kdb to write kernel RAM\",\n\t[LOCKDOWN_RTAS_ERROR_INJECTION] = \"RTAS error injection\",\n\t[LOCKDOWN_INTEGRITY_MAX] = \"integrity\",\n\t[LOCKDOWN_KCORE] = \"/proc/kcore access\",\n\t[LOCKDOWN_KPROBES] = \"use of kprobes\",\n\t[LOCKDOWN_BPF_READ_KERNEL] = \"use of bpf to read kernel RAM\",\n\t[LOCKDOWN_DBG_READ_KERNEL] = \"use of kgdb/kdb to read kernel RAM\",\n\t[LOCKDOWN_PERF] = \"unsafe use of perf\",\n\t[LOCKDOWN_TRACEFS] = \"use of tracefs\",\n\t[LOCKDOWN_XMON_RW] = \"xmon read and write access\",\n\t[LOCKDOWN_XFRM_SECRET] = \"xfrm SA secret\",\n\t[LOCKDOWN_CONFIDENTIALITY_MAX] = \"confidentiality\",\n};\n\nstruct security_hook_heads security_hook_heads __ro_after_init;\nstatic BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);\n\nstatic struct kmem_cache *lsm_file_cache;\nstatic struct kmem_cache *lsm_inode_cache;\n\nchar *lsm_names;\nstatic struct lsm_blob_sizes blob_sizes __ro_after_init;\n\n \nstatic __initdata const char *chosen_lsm_order;\nstatic __initdata const char *chosen_major_lsm;\n\nstatic __initconst const char *const builtin_lsm_order = CONFIG_LSM;\n\n \nstatic __initdata struct lsm_info **ordered_lsms;\nstatic __initdata struct lsm_info *exclusive;\n\nstatic __initdata bool debug;\n#define init_debug(...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (debug)\t\t\t\t\t\\\n\t\t\tpr_info(__VA_ARGS__);\t\t\t\\\n\t} while (0)\n\nstatic bool __init is_enabled(struct lsm_info *lsm)\n{\n\tif (!lsm->enabled)\n\t\treturn false;\n\n\treturn *lsm->enabled;\n}\n\n \nstatic int lsm_enabled_true __initdata = 1;\nstatic int lsm_enabled_false __initdata = 0;\nstatic void __init set_enabled(struct lsm_info *lsm, bool enabled)\n{\n\t \n\tif (!lsm->enabled) {\n\t\tif (enabled)\n\t\t\tlsm->enabled = &lsm_enabled_true;\n\t\telse\n\t\t\tlsm->enabled = &lsm_enabled_false;\n\t} else if (lsm->enabled == &lsm_enabled_true) {\n\t\tif (!enabled)\n\t\t\tlsm->enabled = &lsm_enabled_false;\n\t} else if (lsm->enabled == &lsm_enabled_false) {\n\t\tif (enabled)\n\t\t\tlsm->enabled = &lsm_enabled_true;\n\t} else {\n\t\t*lsm->enabled = enabled;\n\t}\n}\n\n \nstatic bool __init exists_ordered_lsm(struct lsm_info *lsm)\n{\n\tstruct lsm_info **check;\n\n\tfor (check = ordered_lsms; *check; check++)\n\t\tif (*check == lsm)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int last_lsm __initdata;\nstatic void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)\n{\n\t \n\tif (exists_ordered_lsm(lsm))\n\t\treturn;\n\n\tif (WARN(last_lsm == LSM_COUNT, \"%s: out of LSM slots!?\\n\", from))\n\t\treturn;\n\n\t \n\tif (!lsm->enabled)\n\t\tlsm->enabled = &lsm_enabled_true;\n\tordered_lsms[last_lsm++] = lsm;\n\n\tinit_debug(\"%s ordered: %s (%s)\\n\", from, lsm->name,\n\t\t   is_enabled(lsm) ? \"enabled\" : \"disabled\");\n}\n\n \nstatic bool __init lsm_allowed(struct lsm_info *lsm)\n{\n\t \n\tif (!is_enabled(lsm))\n\t\treturn false;\n\n\t \n\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && exclusive) {\n\t\tinit_debug(\"exclusive disabled: %s\\n\", lsm->name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void __init lsm_set_blob_size(int *need, int *lbs)\n{\n\tint offset;\n\n\tif (*need <= 0)\n\t\treturn;\n\n\toffset = ALIGN(*lbs, sizeof(void *));\n\t*lbs = offset + *need;\n\t*need = offset;\n}\n\nstatic void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)\n{\n\tif (!needed)\n\t\treturn;\n\n\tlsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);\n\tlsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);\n\t \n\tif (needed->lbs_inode && blob_sizes.lbs_inode == 0)\n\t\tblob_sizes.lbs_inode = sizeof(struct rcu_head);\n\tlsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);\n\tlsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);\n\tlsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);\n\tlsm_set_blob_size(&needed->lbs_superblock, &blob_sizes.lbs_superblock);\n\tlsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);\n\tlsm_set_blob_size(&needed->lbs_xattr_count,\n\t\t\t  &blob_sizes.lbs_xattr_count);\n}\n\n \nstatic void __init prepare_lsm(struct lsm_info *lsm)\n{\n\tint enabled = lsm_allowed(lsm);\n\n\t \n\tset_enabled(lsm, enabled);\n\n\t \n\tif (enabled) {\n\t\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {\n\t\t\texclusive = lsm;\n\t\t\tinit_debug(\"exclusive chosen:   %s\\n\", lsm->name);\n\t\t}\n\n\t\tlsm_set_blob_sizes(lsm->blobs);\n\t}\n}\n\n \nstatic void __init initialize_lsm(struct lsm_info *lsm)\n{\n\tif (is_enabled(lsm)) {\n\t\tint ret;\n\n\t\tinit_debug(\"initializing %s\\n\", lsm->name);\n\t\tret = lsm->init();\n\t\tWARN(ret, \"%s failed to initialize: %d\\n\", lsm->name, ret);\n\t}\n}\n\n \nstatic void __init ordered_lsm_parse(const char *order, const char *origin)\n{\n\tstruct lsm_info *lsm;\n\tchar *sep, *name, *next;\n\n\t \n\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n\t\tif (lsm->order == LSM_ORDER_FIRST)\n\t\t\tappend_ordered_lsm(lsm, \"  first\");\n\t}\n\n\t \n\tif (chosen_major_lsm) {\n\t\tstruct lsm_info *major;\n\n\t\t \n\t\tfor (major = __start_lsm_info; major < __end_lsm_info;\n\t\t     major++) {\n\t\t\tif ((major->flags & LSM_FLAG_LEGACY_MAJOR) &&\n\t\t\t    strcmp(major->name, chosen_major_lsm) != 0) {\n\t\t\t\tset_enabled(major, false);\n\t\t\t\tinit_debug(\"security=%s disabled: %s (only one legacy major LSM)\\n\",\n\t\t\t\t\t   chosen_major_lsm, major->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tsep = kstrdup(order, GFP_KERNEL);\n\tnext = sep;\n\t \n\twhile ((name = strsep(&next, \",\")) != NULL) {\n\t\tbool found = false;\n\n\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n\t\t\tif (strcmp(lsm->name, name) == 0) {\n\t\t\t\tif (lsm->order == LSM_ORDER_MUTABLE)\n\t\t\t\t\tappend_ordered_lsm(lsm, origin);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tinit_debug(\"%s ignored: %s (not built into kernel)\\n\",\n\t\t\t\t   origin, name);\n\t}\n\n\t \n\tif (chosen_major_lsm) {\n\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n\t\t\tif (exists_ordered_lsm(lsm))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(lsm->name, chosen_major_lsm) == 0)\n\t\t\t\tappend_ordered_lsm(lsm, \"security=\");\n\t\t}\n\t}\n\n\t \n\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n\t\tif (lsm->order == LSM_ORDER_LAST)\n\t\t\tappend_ordered_lsm(lsm, \"   last\");\n\t}\n\n\t \n\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n\t\tif (exists_ordered_lsm(lsm))\n\t\t\tcontinue;\n\t\tset_enabled(lsm, false);\n\t\tinit_debug(\"%s skipped: %s (not in requested order)\\n\",\n\t\t\t   origin, lsm->name);\n\t}\n\n\tkfree(sep);\n}\n\nstatic void __init lsm_early_cred(struct cred *cred);\nstatic void __init lsm_early_task(struct task_struct *task);\n\nstatic int lsm_append(const char *new, char **result);\n\nstatic void __init report_lsm_order(void)\n{\n\tstruct lsm_info **lsm, *early;\n\tint first = 0;\n\n\tpr_info(\"initializing lsm=\");\n\n\t \n\tfor (early = __start_early_lsm_info;\n\t     early < __end_early_lsm_info; early++)\n\t\tif (is_enabled(early))\n\t\t\tpr_cont(\"%s%s\", first++ == 0 ? \"\" : \",\", early->name);\n\tfor (lsm = ordered_lsms; *lsm; lsm++)\n\t\tif (is_enabled(*lsm))\n\t\t\tpr_cont(\"%s%s\", first++ == 0 ? \"\" : \",\", (*lsm)->name);\n\n\tpr_cont(\"\\n\");\n}\n\nstatic void __init ordered_lsm_init(void)\n{\n\tstruct lsm_info **lsm;\n\n\tordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),\n\t\t\t       GFP_KERNEL);\n\n\tif (chosen_lsm_order) {\n\t\tif (chosen_major_lsm) {\n\t\t\tpr_warn(\"security=%s is ignored because it is superseded by lsm=%s\\n\",\n\t\t\t\tchosen_major_lsm, chosen_lsm_order);\n\t\t\tchosen_major_lsm = NULL;\n\t\t}\n\t\tordered_lsm_parse(chosen_lsm_order, \"cmdline\");\n\t} else\n\t\tordered_lsm_parse(builtin_lsm_order, \"builtin\");\n\n\tfor (lsm = ordered_lsms; *lsm; lsm++)\n\t\tprepare_lsm(*lsm);\n\n\treport_lsm_order();\n\n\tinit_debug(\"cred blob size       = %d\\n\", blob_sizes.lbs_cred);\n\tinit_debug(\"file blob size       = %d\\n\", blob_sizes.lbs_file);\n\tinit_debug(\"inode blob size      = %d\\n\", blob_sizes.lbs_inode);\n\tinit_debug(\"ipc blob size        = %d\\n\", blob_sizes.lbs_ipc);\n\tinit_debug(\"msg_msg blob size    = %d\\n\", blob_sizes.lbs_msg_msg);\n\tinit_debug(\"superblock blob size = %d\\n\", blob_sizes.lbs_superblock);\n\tinit_debug(\"task blob size       = %d\\n\", blob_sizes.lbs_task);\n\tinit_debug(\"xattr slots          = %d\\n\", blob_sizes.lbs_xattr_count);\n\n\t \n\tif (blob_sizes.lbs_file)\n\t\tlsm_file_cache = kmem_cache_create(\"lsm_file_cache\",\n\t\t\t\t\t\t   blob_sizes.lbs_file, 0,\n\t\t\t\t\t\t   SLAB_PANIC, NULL);\n\tif (blob_sizes.lbs_inode)\n\t\tlsm_inode_cache = kmem_cache_create(\"lsm_inode_cache\",\n\t\t\t\t\t\t    blob_sizes.lbs_inode, 0,\n\t\t\t\t\t\t    SLAB_PANIC, NULL);\n\n\tlsm_early_cred((struct cred *) current->cred);\n\tlsm_early_task(current);\n\tfor (lsm = ordered_lsms; *lsm; lsm++)\n\t\tinitialize_lsm(*lsm);\n\n\tkfree(ordered_lsms);\n}\n\nint __init early_security_init(void)\n{\n\tstruct lsm_info *lsm;\n\n#define LSM_HOOK(RET, DEFAULT, NAME, ...) \\\n\tINIT_HLIST_HEAD(&security_hook_heads.NAME);\n#include \"linux/lsm_hook_defs.h\"\n#undef LSM_HOOK\n\n\tfor (lsm = __start_early_lsm_info; lsm < __end_early_lsm_info; lsm++) {\n\t\tif (!lsm->enabled)\n\t\t\tlsm->enabled = &lsm_enabled_true;\n\t\tprepare_lsm(lsm);\n\t\tinitialize_lsm(lsm);\n\t}\n\n\treturn 0;\n}\n\n \nint __init security_init(void)\n{\n\tstruct lsm_info *lsm;\n\n\tinit_debug(\"legacy security=%s\\n\", chosen_major_lsm ? : \" *unspecified*\");\n\tinit_debug(\"  CONFIG_LSM=%s\\n\", builtin_lsm_order);\n\tinit_debug(\"boot arg lsm=%s\\n\", chosen_lsm_order ? : \" *unspecified*\");\n\n\t \n\tfor (lsm = __start_early_lsm_info; lsm < __end_early_lsm_info; lsm++) {\n\t\tinit_debug(\"  early started: %s (%s)\\n\", lsm->name,\n\t\t\t   is_enabled(lsm) ? \"enabled\" : \"disabled\");\n\t\tif (lsm->enabled)\n\t\t\tlsm_append(lsm->name, &lsm_names);\n\t}\n\n\t \n\tordered_lsm_init();\n\n\treturn 0;\n}\n\n \nstatic int __init choose_major_lsm(char *str)\n{\n\tchosen_major_lsm = str;\n\treturn 1;\n}\n__setup(\"security=\", choose_major_lsm);\n\n \nstatic int __init choose_lsm_order(char *str)\n{\n\tchosen_lsm_order = str;\n\treturn 1;\n}\n__setup(\"lsm=\", choose_lsm_order);\n\n \nstatic int __init enable_debug(char *str)\n{\n\tdebug = true;\n\treturn 1;\n}\n__setup(\"lsm.debug\", enable_debug);\n\nstatic bool match_last_lsm(const char *list, const char *lsm)\n{\n\tconst char *last;\n\n\tif (WARN_ON(!list || !lsm))\n\t\treturn false;\n\tlast = strrchr(list, ',');\n\tif (last)\n\t\t \n\t\tlast++;\n\telse\n\t\tlast = list;\n\treturn !strcmp(last, lsm);\n}\n\nstatic int lsm_append(const char *new, char **result)\n{\n\tchar *cp;\n\n\tif (*result == NULL) {\n\t\t*result = kstrdup(new, GFP_KERNEL);\n\t\tif (*result == NULL)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tif (match_last_lsm(*result, new))\n\t\t\treturn 0;\n\t\tcp = kasprintf(GFP_KERNEL, \"%s,%s\", *result, new);\n\t\tif (cp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkfree(*result);\n\t\t*result = cp;\n\t}\n\treturn 0;\n}\n\n \nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t       const char *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\thlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\n\t \n\tif (slab_is_available()) {\n\t\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n\t}\n}\n\nint call_blocking_lsm_notifier(enum lsm_event event, void *data)\n{\n\treturn blocking_notifier_call_chain(&blocking_lsm_notifier_chain,\n\t\t\t\t\t    event, data);\n}\nEXPORT_SYMBOL(call_blocking_lsm_notifier);\n\nint register_blocking_lsm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&blocking_lsm_notifier_chain,\n\t\t\t\t\t\tnb);\n}\nEXPORT_SYMBOL(register_blocking_lsm_notifier);\n\nint unregister_blocking_lsm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL(unregister_blocking_lsm_notifier);\n\n \nstatic int lsm_cred_alloc(struct cred *cred, gfp_t gfp)\n{\n\tif (blob_sizes.lbs_cred == 0) {\n\t\tcred->security = NULL;\n\t\treturn 0;\n\t}\n\n\tcred->security = kzalloc(blob_sizes.lbs_cred, gfp);\n\tif (cred->security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic void __init lsm_early_cred(struct cred *cred)\n{\n\tint rc = lsm_cred_alloc(cred, GFP_KERNEL);\n\n\tif (rc)\n\t\tpanic(\"%s: Early cred alloc failed.\\n\", __func__);\n}\n\n \nstatic int lsm_file_alloc(struct file *file)\n{\n\tif (!lsm_file_cache) {\n\t\tfile->f_security = NULL;\n\t\treturn 0;\n\t}\n\n\tfile->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);\n\tif (file->f_security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nint lsm_inode_alloc(struct inode *inode)\n{\n\tif (!lsm_inode_cache) {\n\t\tinode->i_security = NULL;\n\t\treturn 0;\n\t}\n\n\tinode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);\n\tif (inode->i_security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic int lsm_task_alloc(struct task_struct *task)\n{\n\tif (blob_sizes.lbs_task == 0) {\n\t\ttask->security = NULL;\n\t\treturn 0;\n\t}\n\n\ttask->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);\n\tif (task->security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic int lsm_ipc_alloc(struct kern_ipc_perm *kip)\n{\n\tif (blob_sizes.lbs_ipc == 0) {\n\t\tkip->security = NULL;\n\t\treturn 0;\n\t}\n\n\tkip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);\n\tif (kip->security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic int lsm_msg_msg_alloc(struct msg_msg *mp)\n{\n\tif (blob_sizes.lbs_msg_msg == 0) {\n\t\tmp->security = NULL;\n\t\treturn 0;\n\t}\n\n\tmp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);\n\tif (mp->security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic void __init lsm_early_task(struct task_struct *task)\n{\n\tint rc = lsm_task_alloc(task);\n\n\tif (rc)\n\t\tpanic(\"%s: Early task alloc failed.\\n\", __func__);\n}\n\n \nstatic int lsm_superblock_alloc(struct super_block *sb)\n{\n\tif (blob_sizes.lbs_superblock == 0) {\n\t\tsb->s_security = NULL;\n\t\treturn 0;\n\t}\n\n\tsb->s_security = kzalloc(blob_sizes.lbs_superblock, GFP_KERNEL);\n\tif (sb->s_security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \n#define LSM_RET_DEFAULT(NAME) (NAME##_default)\n#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)\n#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \\\n\tstatic const int __maybe_unused LSM_RET_DEFAULT(NAME) = (DEFAULT);\n#define LSM_HOOK(RET, DEFAULT, NAME, ...) \\\n\tDECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)\n\n#include <linux/lsm_hook_defs.h>\n#undef LSM_HOOK\n\n \n\n#define call_void_hook(FUNC, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstruct security_hook_list *P;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) \\\n\t\t\tP->hook.FUNC(__VA_ARGS__);\t\t\\\n\t} while (0)\n\n#define call_int_hook(FUNC, IRC, ...) ({\t\t\t\\\n\tint RC = IRC;\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstruct security_hook_list *P;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \\\n\t\t\tRC = P->hook.FUNC(__VA_ARGS__);\t\t\\\n\t\t\tif (RC != 0)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0);\t\t\t\t\t\t\\\n\tRC;\t\t\t\t\t\t\t\\\n})\n\n \n\n \nint security_binder_set_context_mgr(const struct cred *mgr)\n{\n\treturn call_int_hook(binder_set_context_mgr, 0, mgr);\n}\n\n \nint security_binder_transaction(const struct cred *from,\n\t\t\t\tconst struct cred *to)\n{\n\treturn call_int_hook(binder_transaction, 0, from, to);\n}\n\n \nint security_binder_transfer_binder(const struct cred *from,\n\t\t\t\t    const struct cred *to)\n{\n\treturn call_int_hook(binder_transfer_binder, 0, from, to);\n}\n\n \nint security_binder_transfer_file(const struct cred *from,\n\t\t\t\t  const struct cred *to, const struct file *file)\n{\n\treturn call_int_hook(binder_transfer_file, 0, from, to, file);\n}\n\n \nint security_ptrace_access_check(struct task_struct *child, unsigned int mode)\n{\n\treturn call_int_hook(ptrace_access_check, 0, child, mode);\n}\n\n \nint security_ptrace_traceme(struct task_struct *parent)\n{\n\treturn call_int_hook(ptrace_traceme, 0, parent);\n}\n\n \nint security_capget(const struct task_struct *target,\n\t\t    kernel_cap_t *effective,\n\t\t    kernel_cap_t *inheritable,\n\t\t    kernel_cap_t *permitted)\n{\n\treturn call_int_hook(capget, 0, target,\n\t\t\t     effective, inheritable, permitted);\n}\n\n \nint security_capset(struct cred *new, const struct cred *old,\n\t\t    const kernel_cap_t *effective,\n\t\t    const kernel_cap_t *inheritable,\n\t\t    const kernel_cap_t *permitted)\n{\n\treturn call_int_hook(capset, 0, new, old,\n\t\t\t     effective, inheritable, permitted);\n}\n\n \nint security_capable(const struct cred *cred,\n\t\t     struct user_namespace *ns,\n\t\t     int cap,\n\t\t     unsigned int opts)\n{\n\treturn call_int_hook(capable, 0, cred, ns, cap, opts);\n}\n\n \nint security_quotactl(int cmds, int type, int id, struct super_block *sb)\n{\n\treturn call_int_hook(quotactl, 0, cmds, type, id, sb);\n}\n\n \nint security_quota_on(struct dentry *dentry)\n{\n\treturn call_int_hook(quota_on, 0, dentry);\n}\n\n \nint security_syslog(int type)\n{\n\treturn call_int_hook(syslog, 0, type);\n}\n\n \nint security_settime64(const struct timespec64 *ts, const struct timezone *tz)\n{\n\treturn call_int_hook(settime, 0, ts, tz);\n}\n\n \nint security_vm_enough_memory_mm(struct mm_struct *mm, long pages)\n{\n\tstruct security_hook_list *hp;\n\tint cap_sys_admin = 1;\n\tint rc;\n\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {\n\t\trc = hp->hook.vm_enough_memory(mm, pages);\n\t\tif (rc <= 0) {\n\t\t\tcap_sys_admin = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn __vm_enough_memory(mm, pages, cap_sys_admin);\n}\n\n \nint security_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\treturn call_int_hook(bprm_creds_for_exec, 0, bprm);\n}\n\n \nint security_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)\n{\n\treturn call_int_hook(bprm_creds_from_file, 0, bprm, file);\n}\n\n \nint security_bprm_check(struct linux_binprm *bprm)\n{\n\tint ret;\n\n\tret = call_int_hook(bprm_check_security, 0, bprm);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_bprm_check(bprm);\n}\n\n \nvoid security_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tcall_void_hook(bprm_committing_creds, bprm);\n}\n\n \nvoid security_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\tcall_void_hook(bprm_committed_creds, bprm);\n}\n\n \nint security_fs_context_submount(struct fs_context *fc, struct super_block *reference)\n{\n\treturn call_int_hook(fs_context_submount, 0, fc, reference);\n}\n\n \nint security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n{\n\treturn call_int_hook(fs_context_dup, 0, fc, src_fc);\n}\n\n \nint security_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t    struct fs_parameter *param)\n{\n\tstruct security_hook_list *hp;\n\tint trc;\n\tint rc = -ENOPARAM;\n\n\thlist_for_each_entry(hp, &security_hook_heads.fs_context_parse_param,\n\t\t\t     list) {\n\t\ttrc = hp->hook.fs_context_parse_param(fc, param);\n\t\tif (trc == 0)\n\t\t\trc = 0;\n\t\telse if (trc != -ENOPARAM)\n\t\t\treturn trc;\n\t}\n\treturn rc;\n}\n\n \nint security_sb_alloc(struct super_block *sb)\n{\n\tint rc = lsm_superblock_alloc(sb);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(sb_alloc_security, 0, sb);\n\tif (unlikely(rc))\n\t\tsecurity_sb_free(sb);\n\treturn rc;\n}\n\n \nvoid security_sb_delete(struct super_block *sb)\n{\n\tcall_void_hook(sb_delete, sb);\n}\n\n \nvoid security_sb_free(struct super_block *sb)\n{\n\tcall_void_hook(sb_free_security, sb);\n\tkfree(sb->s_security);\n\tsb->s_security = NULL;\n}\n\n \nvoid security_free_mnt_opts(void **mnt_opts)\n{\n\tif (!*mnt_opts)\n\t\treturn;\n\tcall_void_hook(sb_free_mnt_opts, *mnt_opts);\n\t*mnt_opts = NULL;\n}\nEXPORT_SYMBOL(security_free_mnt_opts);\n\n \nint security_sb_eat_lsm_opts(char *options, void **mnt_opts)\n{\n\treturn call_int_hook(sb_eat_lsm_opts, 0, options, mnt_opts);\n}\nEXPORT_SYMBOL(security_sb_eat_lsm_opts);\n\n \nint security_sb_mnt_opts_compat(struct super_block *sb,\n\t\t\t\tvoid *mnt_opts)\n{\n\treturn call_int_hook(sb_mnt_opts_compat, 0, sb, mnt_opts);\n}\nEXPORT_SYMBOL(security_sb_mnt_opts_compat);\n\n \nint security_sb_remount(struct super_block *sb,\n\t\t\tvoid *mnt_opts)\n{\n\treturn call_int_hook(sb_remount, 0, sb, mnt_opts);\n}\nEXPORT_SYMBOL(security_sb_remount);\n\n \nint security_sb_kern_mount(struct super_block *sb)\n{\n\treturn call_int_hook(sb_kern_mount, 0, sb);\n}\n\n \nint security_sb_show_options(struct seq_file *m, struct super_block *sb)\n{\n\treturn call_int_hook(sb_show_options, 0, m, sb);\n}\n\n \nint security_sb_statfs(struct dentry *dentry)\n{\n\treturn call_int_hook(sb_statfs, 0, dentry);\n}\n\n \nint security_sb_mount(const char *dev_name, const struct path *path,\n\t\t      const char *type, unsigned long flags, void *data)\n{\n\treturn call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);\n}\n\n \nint security_sb_umount(struct vfsmount *mnt, int flags)\n{\n\treturn call_int_hook(sb_umount, 0, mnt, flags);\n}\n\n \nint security_sb_pivotroot(const struct path *old_path,\n\t\t\t  const struct path *new_path)\n{\n\treturn call_int_hook(sb_pivotroot, 0, old_path, new_path);\n}\n\n \nint security_sb_set_mnt_opts(struct super_block *sb,\n\t\t\t     void *mnt_opts,\n\t\t\t     unsigned long kern_flags,\n\t\t\t     unsigned long *set_kern_flags)\n{\n\treturn call_int_hook(sb_set_mnt_opts,\n\t\t\t     mnt_opts ? -EOPNOTSUPP : 0, sb,\n\t\t\t     mnt_opts, kern_flags, set_kern_flags);\n}\nEXPORT_SYMBOL(security_sb_set_mnt_opts);\n\n \nint security_sb_clone_mnt_opts(const struct super_block *oldsb,\n\t\t\t       struct super_block *newsb,\n\t\t\t       unsigned long kern_flags,\n\t\t\t       unsigned long *set_kern_flags)\n{\n\treturn call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb,\n\t\t\t     kern_flags, set_kern_flags);\n}\nEXPORT_SYMBOL(security_sb_clone_mnt_opts);\n\n \nint security_move_mount(const struct path *from_path,\n\t\t\tconst struct path *to_path)\n{\n\treturn call_int_hook(move_mount, 0, from_path, to_path);\n}\n\n \nint security_path_notify(const struct path *path, u64 mask,\n\t\t\t unsigned int obj_type)\n{\n\treturn call_int_hook(path_notify, 0, path, mask, obj_type);\n}\n\n \nint security_inode_alloc(struct inode *inode)\n{\n\tint rc = lsm_inode_alloc(inode);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(inode_alloc_security, 0, inode);\n\tif (unlikely(rc))\n\t\tsecurity_inode_free(inode);\n\treturn rc;\n}\n\nstatic void inode_free_by_rcu(struct rcu_head *head)\n{\n\t \n\tkmem_cache_free(lsm_inode_cache, head);\n}\n\n \nvoid security_inode_free(struct inode *inode)\n{\n\tintegrity_inode_free(inode);\n\tcall_void_hook(inode_free_security, inode);\n\t \n\tif (inode->i_security)\n\t\tcall_rcu((struct rcu_head *)inode->i_security,\n\t\t\t inode_free_by_rcu);\n}\n\n \nint security_dentry_init_security(struct dentry *dentry, int mode,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  const char **xattr_name, void **ctx,\n\t\t\t\t  u32 *ctxlen)\n{\n\tstruct security_hook_list *hp;\n\tint rc;\n\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.dentry_init_security,\n\t\t\t     list) {\n\t\trc = hp->hook.dentry_init_security(dentry, mode, name,\n\t\t\t\t\t\t   xattr_name, ctx, ctxlen);\n\t\tif (rc != LSM_RET_DEFAULT(dentry_init_security))\n\t\t\treturn rc;\n\t}\n\treturn LSM_RET_DEFAULT(dentry_init_security);\n}\nEXPORT_SYMBOL(security_dentry_init_security);\n\n \nint security_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t    struct qstr *name,\n\t\t\t\t    const struct cred *old, struct cred *new)\n{\n\treturn call_int_hook(dentry_create_files_as, 0, dentry, mode,\n\t\t\t     name, old, new);\n}\nEXPORT_SYMBOL(security_dentry_create_files_as);\n\n \nint security_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t const struct qstr *qstr,\n\t\t\t\t const initxattrs initxattrs, void *fs_data)\n{\n\tstruct security_hook_list *hp;\n\tstruct xattr *new_xattrs = NULL;\n\tint ret = -EOPNOTSUPP, xattr_count = 0;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tif (!blob_sizes.lbs_xattr_count)\n\t\treturn 0;\n\n\tif (initxattrs) {\n\t\t \n\t\tnew_xattrs = kcalloc(blob_sizes.lbs_xattr_count + 2,\n\t\t\t\t     sizeof(*new_xattrs), GFP_NOFS);\n\t\tif (!new_xattrs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\thlist_for_each_entry(hp, &security_hook_heads.inode_init_security,\n\t\t\t     list) {\n\t\tret = hp->hook.inode_init_security(inode, dir, qstr, new_xattrs,\n\t\t\t\t\t\t  &xattr_count);\n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\tgoto out;\n\t\t \n\t}\n\n\t \n\tif (!xattr_count)\n\t\tgoto out;\n\n\tret = evm_inode_init_security(inode, dir, qstr, new_xattrs,\n\t\t\t\t      &xattr_count);\n\tif (ret)\n\t\tgoto out;\n\tret = initxattrs(inode, new_xattrs, fs_data);\nout:\n\tfor (; xattr_count > 0; xattr_count--)\n\t\tkfree(new_xattrs[xattr_count - 1].value);\n\tkfree(new_xattrs);\n\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n}\nEXPORT_SYMBOL(security_inode_init_security);\n\n \nint security_inode_init_security_anon(struct inode *inode,\n\t\t\t\t      const struct qstr *name,\n\t\t\t\t      const struct inode *context_inode)\n{\n\treturn call_int_hook(inode_init_security_anon, 0, inode, name,\n\t\t\t     context_inode);\n}\n\n#ifdef CONFIG_SECURITY_PATH\n \nint security_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\tumode_t mode, unsigned int dev)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_mknod, 0, dir, dentry, mode, dev);\n}\nEXPORT_SYMBOL(security_path_mknod);\n\n \nint security_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\tumode_t mode)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_mkdir, 0, dir, dentry, mode);\n}\nEXPORT_SYMBOL(security_path_mkdir);\n\n \nint security_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_rmdir, 0, dir, dentry);\n}\n\n \nint security_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_unlink, 0, dir, dentry);\n}\nEXPORT_SYMBOL(security_path_unlink);\n\n \nint security_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t  const char *old_name)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_symlink, 0, dir, dentry, old_name);\n}\n\n \nint security_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t       struct dentry *new_dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);\n}\n\n \nint security_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t const struct path *new_dir, struct dentry *new_dentry,\n\t\t\t unsigned int flags)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n\t\t     (d_is_positive(new_dentry) &&\n\t\t      IS_PRIVATE(d_backing_inode(new_dentry)))))\n\t\treturn 0;\n\n\treturn call_int_hook(path_rename, 0, old_dir, old_dentry, new_dir,\n\t\t\t     new_dentry, flags);\n}\nEXPORT_SYMBOL(security_path_rename);\n\n \nint security_path_truncate(const struct path *path)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_truncate, 0, path);\n}\n\n \nint security_path_chmod(const struct path *path, umode_t mode)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_chmod, 0, path, mode);\n}\n\n \nint security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(path_chown, 0, path, uid, gid);\n}\n\n \nint security_path_chroot(const struct path *path)\n{\n\treturn call_int_hook(path_chroot, 0, path);\n}\n#endif  \n\n \nint security_inode_create(struct inode *dir, struct dentry *dentry,\n\t\t\t  umode_t mode)\n{\n\tif (unlikely(IS_PRIVATE(dir)))\n\t\treturn 0;\n\treturn call_int_hook(inode_create, 0, dir, dentry, mode);\n}\nEXPORT_SYMBOL_GPL(security_inode_create);\n\n \nint security_inode_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\tstruct dentry *new_dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_link, 0, old_dentry, dir, new_dentry);\n}\n\n \nint security_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_unlink, 0, dir, dentry);\n}\n\n \nint security_inode_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t   const char *old_name)\n{\n\tif (unlikely(IS_PRIVATE(dir)))\n\t\treturn 0;\n\treturn call_int_hook(inode_symlink, 0, dir, dentry, old_name);\n}\n\n \nint security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tif (unlikely(IS_PRIVATE(dir)))\n\t\treturn 0;\n\treturn call_int_hook(inode_mkdir, 0, dir, dentry, mode);\n}\nEXPORT_SYMBOL_GPL(security_inode_mkdir);\n\n \nint security_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_rmdir, 0, dir, dentry);\n}\n\n \nint security_inode_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t dev)\n{\n\tif (unlikely(IS_PRIVATE(dir)))\n\t\treturn 0;\n\treturn call_int_hook(inode_mknod, 0, dir, dentry, mode, dev);\n}\n\n \nint security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n\t\t     (d_is_positive(new_dentry) &&\n\t\t      IS_PRIVATE(d_backing_inode(new_dentry)))))\n\t\treturn 0;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\tint err = call_int_hook(inode_rename, 0, new_dir, new_dentry,\n\t\t\t\t\told_dir, old_dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn call_int_hook(inode_rename, 0, old_dir, old_dentry,\n\t\t\t     new_dir, new_dentry);\n}\n\n \nint security_inode_readlink(struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_readlink, 0, dentry);\n}\n\n \nint security_inode_follow_link(struct dentry *dentry, struct inode *inode,\n\t\t\t       bool rcu)\n{\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\treturn call_int_hook(inode_follow_link, 0, dentry, inode, rcu);\n}\n\n \nint security_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\treturn call_int_hook(inode_permission, 0, inode, mask);\n}\n\n \nint security_inode_setattr(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct iattr *attr)\n{\n\tint ret;\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\tret = call_int_hook(inode_setattr, 0, dentry, attr);\n\tif (ret)\n\t\treturn ret;\n\treturn evm_inode_setattr(idmap, dentry, attr);\n}\nEXPORT_SYMBOL_GPL(security_inode_setattr);\n\n \nint security_inode_getattr(const struct path *path)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_getattr, 0, path);\n}\n\n \nint security_inode_setxattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, const char *name,\n\t\t\t    const void *value, size_t size, int flags)\n{\n\tint ret;\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\t \n\tret = call_int_hook(inode_setxattr, 1, idmap, dentry, name, value,\n\t\t\t    size, flags);\n\n\tif (ret == 1)\n\t\tret = cap_inode_setxattr(dentry, name, value, size, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = ima_inode_setxattr(dentry, name, value, size);\n\tif (ret)\n\t\treturn ret;\n\treturn evm_inode_setxattr(idmap, dentry, name, value, size);\n}\n\n \nint security_inode_set_acl(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, const char *acl_name,\n\t\t\t   struct posix_acl *kacl)\n{\n\tint ret;\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\tret = call_int_hook(inode_set_acl, 0, idmap, dentry, acl_name,\n\t\t\t    kacl);\n\tif (ret)\n\t\treturn ret;\n\tret = ima_inode_set_acl(idmap, dentry, acl_name, kacl);\n\tif (ret)\n\t\treturn ret;\n\treturn evm_inode_set_acl(idmap, dentry, acl_name, kacl);\n}\n\n \nint security_inode_get_acl(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, const char *acl_name)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_get_acl, 0, idmap, dentry, acl_name);\n}\n\n \nint security_inode_remove_acl(struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, const char *acl_name)\n{\n\tint ret;\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\tret = call_int_hook(inode_remove_acl, 0, idmap, dentry, acl_name);\n\tif (ret)\n\t\treturn ret;\n\tret = ima_inode_remove_acl(idmap, dentry, acl_name);\n\tif (ret)\n\t\treturn ret;\n\treturn evm_inode_remove_acl(idmap, dentry, acl_name);\n}\n\n \nvoid security_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn;\n\tcall_void_hook(inode_post_setxattr, dentry, name, value, size, flags);\n\tevm_inode_post_setxattr(dentry, name, value, size);\n}\n\n \nint security_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_getxattr, 0, dentry, name);\n}\n\n \nint security_inode_listxattr(struct dentry *dentry)\n{\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\treturn call_int_hook(inode_listxattr, 0, dentry);\n}\n\n \nint security_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, const char *name)\n{\n\tint ret;\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\t \n\tret = call_int_hook(inode_removexattr, 1, idmap, dentry, name);\n\tif (ret == 1)\n\t\tret = cap_inode_removexattr(idmap, dentry, name);\n\tif (ret)\n\t\treturn ret;\n\tret = ima_inode_removexattr(dentry, name);\n\tif (ret)\n\t\treturn ret;\n\treturn evm_inode_removexattr(idmap, dentry, name);\n}\n\n \nint security_inode_need_killpriv(struct dentry *dentry)\n{\n\treturn call_int_hook(inode_need_killpriv, 0, dentry);\n}\n\n \nint security_inode_killpriv(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry)\n{\n\treturn call_int_hook(inode_killpriv, 0, idmap, dentry);\n}\n\n \nint security_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, const char *name,\n\t\t\t       void **buffer, bool alloc)\n{\n\tstruct security_hook_list *hp;\n\tint rc;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn LSM_RET_DEFAULT(inode_getsecurity);\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {\n\t\trc = hp->hook.inode_getsecurity(idmap, inode, name, buffer,\n\t\t\t\t\t\talloc);\n\t\tif (rc != LSM_RET_DEFAULT(inode_getsecurity))\n\t\t\treturn rc;\n\t}\n\treturn LSM_RET_DEFAULT(inode_getsecurity);\n}\n\n \nint security_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t       const void *value, size_t size, int flags)\n{\n\tstruct security_hook_list *hp;\n\tint rc;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn LSM_RET_DEFAULT(inode_setsecurity);\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {\n\t\trc = hp->hook.inode_setsecurity(inode, name, value, size,\n\t\t\t\t\t\tflags);\n\t\tif (rc != LSM_RET_DEFAULT(inode_setsecurity))\n\t\t\treturn rc;\n\t}\n\treturn LSM_RET_DEFAULT(inode_setsecurity);\n}\n\n \nint security_inode_listsecurity(struct inode *inode,\n\t\t\t\tchar *buffer, size_t buffer_size)\n{\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\treturn call_int_hook(inode_listsecurity, 0, inode, buffer, buffer_size);\n}\nEXPORT_SYMBOL(security_inode_listsecurity);\n\n \nvoid security_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tcall_void_hook(inode_getsecid, inode, secid);\n}\n\n \nint security_inode_copy_up(struct dentry *src, struct cred **new)\n{\n\treturn call_int_hook(inode_copy_up, 0, src, new);\n}\nEXPORT_SYMBOL(security_inode_copy_up);\n\n \nint security_inode_copy_up_xattr(const char *name)\n{\n\tstruct security_hook_list *hp;\n\tint rc;\n\n\t \n\thlist_for_each_entry(hp,\n\t\t\t     &security_hook_heads.inode_copy_up_xattr, list) {\n\t\trc = hp->hook.inode_copy_up_xattr(name);\n\t\tif (rc != LSM_RET_DEFAULT(inode_copy_up_xattr))\n\t\t\treturn rc;\n\t}\n\n\treturn LSM_RET_DEFAULT(inode_copy_up_xattr);\n}\nEXPORT_SYMBOL(security_inode_copy_up_xattr);\n\n \nint security_kernfs_init_security(struct kernfs_node *kn_dir,\n\t\t\t\t  struct kernfs_node *kn)\n{\n\treturn call_int_hook(kernfs_init_security, 0, kn_dir, kn);\n}\n\n \nint security_file_permission(struct file *file, int mask)\n{\n\tint ret;\n\n\tret = call_int_hook(file_permission, 0, file, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fsnotify_perm(file, mask);\n}\n\n \nint security_file_alloc(struct file *file)\n{\n\tint rc = lsm_file_alloc(file);\n\n\tif (rc)\n\t\treturn rc;\n\trc = call_int_hook(file_alloc_security, 0, file);\n\tif (unlikely(rc))\n\t\tsecurity_file_free(file);\n\treturn rc;\n}\n\n \nvoid security_file_free(struct file *file)\n{\n\tvoid *blob;\n\n\tcall_void_hook(file_free_security, file);\n\n\tblob = file->f_security;\n\tif (blob) {\n\t\tfile->f_security = NULL;\n\t\tkmem_cache_free(lsm_file_cache, blob);\n\t}\n}\n\n \nint security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn call_int_hook(file_ioctl, 0, file, cmd, arg);\n}\nEXPORT_SYMBOL_GPL(security_file_ioctl);\n\nstatic inline unsigned long mmap_prot(struct file *file, unsigned long prot)\n{\n\t \n\tif ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)\n\t\treturn prot;\n\tif (!(current->personality & READ_IMPLIES_EXEC))\n\t\treturn prot;\n\t \n\tif (!file)\n\t\treturn prot | PROT_EXEC;\n\t \n\tif (!path_noexec(&file->f_path)) {\n#ifndef CONFIG_MMU\n\t\tif (file->f_op->mmap_capabilities) {\n\t\t\tunsigned caps = file->f_op->mmap_capabilities(file);\n\t\t\tif (!(caps & NOMMU_MAP_EXEC))\n\t\t\t\treturn prot;\n\t\t}\n#endif\n\t\treturn prot | PROT_EXEC;\n\t}\n\t \n\treturn prot;\n}\n\n \nint security_mmap_file(struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tunsigned long prot_adj = mmap_prot(file, prot);\n\tint ret;\n\n\tret = call_int_hook(mmap_file, 0, file, prot, prot_adj, flags);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_file_mmap(file, prot, prot_adj, flags);\n}\n\n \nint security_mmap_addr(unsigned long addr)\n{\n\treturn call_int_hook(mmap_addr, 0, addr);\n}\n\n \nint security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\n\t\t\t   unsigned long prot)\n{\n\tint ret;\n\n\tret = call_int_hook(file_mprotect, 0, vma, reqprot, prot);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_file_mprotect(vma, prot);\n}\n\n \nint security_file_lock(struct file *file, unsigned int cmd)\n{\n\treturn call_int_hook(file_lock, 0, file, cmd);\n}\n\n \nint security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn call_int_hook(file_fcntl, 0, file, cmd, arg);\n}\n\n \nvoid security_file_set_fowner(struct file *file)\n{\n\tcall_void_hook(file_set_fowner, file);\n}\n\n \nint security_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t struct fown_struct *fown, int sig)\n{\n\treturn call_int_hook(file_send_sigiotask, 0, tsk, fown, sig);\n}\n\n \nint security_file_receive(struct file *file)\n{\n\treturn call_int_hook(file_receive, 0, file);\n}\n\n \nint security_file_open(struct file *file)\n{\n\tint ret;\n\n\tret = call_int_hook(file_open, 0, file);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fsnotify_perm(file, MAY_OPEN);\n}\n\n \nint security_file_truncate(struct file *file)\n{\n\treturn call_int_hook(file_truncate, 0, file);\n}\n\n \nint security_task_alloc(struct task_struct *task, unsigned long clone_flags)\n{\n\tint rc = lsm_task_alloc(task);\n\n\tif (rc)\n\t\treturn rc;\n\trc = call_int_hook(task_alloc, 0, task, clone_flags);\n\tif (unlikely(rc))\n\t\tsecurity_task_free(task);\n\treturn rc;\n}\n\n \nvoid security_task_free(struct task_struct *task)\n{\n\tcall_void_hook(task_free, task);\n\n\tkfree(task->security);\n\ttask->security = NULL;\n}\n\n \nint security_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\tint rc = lsm_cred_alloc(cred, gfp);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = call_int_hook(cred_alloc_blank, 0, cred, gfp);\n\tif (unlikely(rc))\n\t\tsecurity_cred_free(cred);\n\treturn rc;\n}\n\n \nvoid security_cred_free(struct cred *cred)\n{\n\t \n\tif (unlikely(cred->security == NULL))\n\t\treturn;\n\n\tcall_void_hook(cred_free, cred);\n\n\tkfree(cred->security);\n\tcred->security = NULL;\n}\n\n \nint security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)\n{\n\tint rc = lsm_cred_alloc(new, gfp);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = call_int_hook(cred_prepare, 0, new, old, gfp);\n\tif (unlikely(rc))\n\t\tsecurity_cred_free(new);\n\treturn rc;\n}\n\n \nvoid security_transfer_creds(struct cred *new, const struct cred *old)\n{\n\tcall_void_hook(cred_transfer, new, old);\n}\n\n \nvoid security_cred_getsecid(const struct cred *c, u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(cred_getsecid, c, secid);\n}\nEXPORT_SYMBOL(security_cred_getsecid);\n\n \nint security_kernel_act_as(struct cred *new, u32 secid)\n{\n\treturn call_int_hook(kernel_act_as, 0, new, secid);\n}\n\n \nint security_kernel_create_files_as(struct cred *new, struct inode *inode)\n{\n\treturn call_int_hook(kernel_create_files_as, 0, new, inode);\n}\n\n \nint security_kernel_module_request(char *kmod_name)\n{\n\tint ret;\n\n\tret = call_int_hook(kernel_module_request, 0, kmod_name);\n\tif (ret)\n\t\treturn ret;\n\treturn integrity_kernel_module_request(kmod_name);\n}\n\n \nint security_kernel_read_file(struct file *file, enum kernel_read_file_id id,\n\t\t\t      bool contents)\n{\n\tint ret;\n\n\tret = call_int_hook(kernel_read_file, 0, file, id, contents);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_read_file(file, id, contents);\n}\nEXPORT_SYMBOL_GPL(security_kernel_read_file);\n\n \nint security_kernel_post_read_file(struct file *file, char *buf, loff_t size,\n\t\t\t\t   enum kernel_read_file_id id)\n{\n\tint ret;\n\n\tret = call_int_hook(kernel_post_read_file, 0, file, buf, size, id);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_post_read_file(file, buf, size, id);\n}\nEXPORT_SYMBOL_GPL(security_kernel_post_read_file);\n\n \nint security_kernel_load_data(enum kernel_load_data_id id, bool contents)\n{\n\tint ret;\n\n\tret = call_int_hook(kernel_load_data, 0, id, contents);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_load_data(id, contents);\n}\nEXPORT_SYMBOL_GPL(security_kernel_load_data);\n\n \nint security_kernel_post_load_data(char *buf, loff_t size,\n\t\t\t\t   enum kernel_load_data_id id,\n\t\t\t\t   char *description)\n{\n\tint ret;\n\n\tret = call_int_hook(kernel_post_load_data, 0, buf, size, id,\n\t\t\t    description);\n\tif (ret)\n\t\treturn ret;\n\treturn ima_post_load_data(buf, size, id, description);\n}\nEXPORT_SYMBOL_GPL(security_kernel_post_load_data);\n\n \nint security_task_fix_setuid(struct cred *new, const struct cred *old,\n\t\t\t     int flags)\n{\n\treturn call_int_hook(task_fix_setuid, 0, new, old, flags);\n}\n\n \nint security_task_fix_setgid(struct cred *new, const struct cred *old,\n\t\t\t     int flags)\n{\n\treturn call_int_hook(task_fix_setgid, 0, new, old, flags);\n}\n\n \nint security_task_fix_setgroups(struct cred *new, const struct cred *old)\n{\n\treturn call_int_hook(task_fix_setgroups, 0, new, old);\n}\n\n \nint security_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn call_int_hook(task_setpgid, 0, p, pgid);\n}\n\n \nint security_task_getpgid(struct task_struct *p)\n{\n\treturn call_int_hook(task_getpgid, 0, p);\n}\n\n \nint security_task_getsid(struct task_struct *p)\n{\n\treturn call_int_hook(task_getsid, 0, p);\n}\n\n \nvoid security_current_getsecid_subj(u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(current_getsecid_subj, secid);\n}\nEXPORT_SYMBOL(security_current_getsecid_subj);\n\n \nvoid security_task_getsecid_obj(struct task_struct *p, u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(task_getsecid_obj, p, secid);\n}\nEXPORT_SYMBOL(security_task_getsecid_obj);\n\n \nint security_task_setnice(struct task_struct *p, int nice)\n{\n\treturn call_int_hook(task_setnice, 0, p, nice);\n}\n\n \nint security_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn call_int_hook(task_setioprio, 0, p, ioprio);\n}\n\n \nint security_task_getioprio(struct task_struct *p)\n{\n\treturn call_int_hook(task_getioprio, 0, p);\n}\n\n \nint security_task_prlimit(const struct cred *cred, const struct cred *tcred,\n\t\t\t  unsigned int flags)\n{\n\treturn call_int_hook(task_prlimit, 0, cred, tcred, flags);\n}\n\n \nint security_task_setrlimit(struct task_struct *p, unsigned int resource,\n\t\t\t    struct rlimit *new_rlim)\n{\n\treturn call_int_hook(task_setrlimit, 0, p, resource, new_rlim);\n}\n\n \nint security_task_setscheduler(struct task_struct *p)\n{\n\treturn call_int_hook(task_setscheduler, 0, p);\n}\n\n \nint security_task_getscheduler(struct task_struct *p)\n{\n\treturn call_int_hook(task_getscheduler, 0, p);\n}\n\n \nint security_task_movememory(struct task_struct *p)\n{\n\treturn call_int_hook(task_movememory, 0, p);\n}\n\n \nint security_task_kill(struct task_struct *p, struct kernel_siginfo *info,\n\t\t       int sig, const struct cred *cred)\n{\n\treturn call_int_hook(task_kill, 0, p, info, sig, cred);\n}\n\n \nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\tint thisrc;\n\tint rc = LSM_RET_DEFAULT(task_prctl);\n\tstruct security_hook_list *hp;\n\n\thlist_for_each_entry(hp, &security_hook_heads.task_prctl, list) {\n\t\tthisrc = hp->hook.task_prctl(option, arg2, arg3, arg4, arg5);\n\t\tif (thisrc != LSM_RET_DEFAULT(task_prctl)) {\n\t\t\trc = thisrc;\n\t\t\tif (thisrc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nvoid security_task_to_inode(struct task_struct *p, struct inode *inode)\n{\n\tcall_void_hook(task_to_inode, p, inode);\n}\n\n \nint security_create_user_ns(const struct cred *cred)\n{\n\treturn call_int_hook(userns_create, 0, cred);\n}\n\n \nint security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)\n{\n\treturn call_int_hook(ipc_permission, 0, ipcp, flag);\n}\n\n \nvoid security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(ipc_getsecid, ipcp, secid);\n}\n\n \nint security_msg_msg_alloc(struct msg_msg *msg)\n{\n\tint rc = lsm_msg_msg_alloc(msg);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(msg_msg_alloc_security, 0, msg);\n\tif (unlikely(rc))\n\t\tsecurity_msg_msg_free(msg);\n\treturn rc;\n}\n\n \nvoid security_msg_msg_free(struct msg_msg *msg)\n{\n\tcall_void_hook(msg_msg_free_security, msg);\n\tkfree(msg->security);\n\tmsg->security = NULL;\n}\n\n \nint security_msg_queue_alloc(struct kern_ipc_perm *msq)\n{\n\tint rc = lsm_ipc_alloc(msq);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(msg_queue_alloc_security, 0, msq);\n\tif (unlikely(rc))\n\t\tsecurity_msg_queue_free(msq);\n\treturn rc;\n}\n\n \nvoid security_msg_queue_free(struct kern_ipc_perm *msq)\n{\n\tcall_void_hook(msg_queue_free_security, msq);\n\tkfree(msq->security);\n\tmsq->security = NULL;\n}\n\n \nint security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg)\n{\n\treturn call_int_hook(msg_queue_associate, 0, msq, msqflg);\n}\n\n \nint security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)\n{\n\treturn call_int_hook(msg_queue_msgctl, 0, msq, cmd);\n}\n\n \nint security_msg_queue_msgsnd(struct kern_ipc_perm *msq,\n\t\t\t      struct msg_msg *msg, int msqflg)\n{\n\treturn call_int_hook(msg_queue_msgsnd, 0, msq, msg, msqflg);\n}\n\n \nint security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,\n\t\t\t      struct task_struct *target, long type, int mode)\n{\n\treturn call_int_hook(msg_queue_msgrcv, 0, msq, msg, target, type, mode);\n}\n\n \nint security_shm_alloc(struct kern_ipc_perm *shp)\n{\n\tint rc = lsm_ipc_alloc(shp);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(shm_alloc_security, 0, shp);\n\tif (unlikely(rc))\n\t\tsecurity_shm_free(shp);\n\treturn rc;\n}\n\n \nvoid security_shm_free(struct kern_ipc_perm *shp)\n{\n\tcall_void_hook(shm_free_security, shp);\n\tkfree(shp->security);\n\tshp->security = NULL;\n}\n\n \nint security_shm_associate(struct kern_ipc_perm *shp, int shmflg)\n{\n\treturn call_int_hook(shm_associate, 0, shp, shmflg);\n}\n\n \nint security_shm_shmctl(struct kern_ipc_perm *shp, int cmd)\n{\n\treturn call_int_hook(shm_shmctl, 0, shp, cmd);\n}\n\n \nint security_shm_shmat(struct kern_ipc_perm *shp,\n\t\t       char __user *shmaddr, int shmflg)\n{\n\treturn call_int_hook(shm_shmat, 0, shp, shmaddr, shmflg);\n}\n\n \nint security_sem_alloc(struct kern_ipc_perm *sma)\n{\n\tint rc = lsm_ipc_alloc(sma);\n\n\tif (unlikely(rc))\n\t\treturn rc;\n\trc = call_int_hook(sem_alloc_security, 0, sma);\n\tif (unlikely(rc))\n\t\tsecurity_sem_free(sma);\n\treturn rc;\n}\n\n \nvoid security_sem_free(struct kern_ipc_perm *sma)\n{\n\tcall_void_hook(sem_free_security, sma);\n\tkfree(sma->security);\n\tsma->security = NULL;\n}\n\n \nint security_sem_associate(struct kern_ipc_perm *sma, int semflg)\n{\n\treturn call_int_hook(sem_associate, 0, sma, semflg);\n}\n\n \nint security_sem_semctl(struct kern_ipc_perm *sma, int cmd)\n{\n\treturn call_int_hook(sem_semctl, 0, sma, cmd);\n}\n\n \nint security_sem_semop(struct kern_ipc_perm *sma, struct sembuf *sops,\n\t\t       unsigned nsops, int alter)\n{\n\treturn call_int_hook(sem_semop, 0, sma, sops, nsops, alter);\n}\n\n \nvoid security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}\nEXPORT_SYMBOL(security_d_instantiate);\n\n \nint security_getprocattr(struct task_struct *p, const char *lsm,\n\t\t\t const char *name, char **value)\n{\n\tstruct security_hook_list *hp;\n\n\thlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {\n\t\tif (lsm != NULL && strcmp(lsm, hp->lsm))\n\t\t\tcontinue;\n\t\treturn hp->hook.getprocattr(p, name, value);\n\t}\n\treturn LSM_RET_DEFAULT(getprocattr);\n}\n\n \nint security_setprocattr(const char *lsm, const char *name, void *value,\n\t\t\t size_t size)\n{\n\tstruct security_hook_list *hp;\n\n\thlist_for_each_entry(hp, &security_hook_heads.setprocattr, list) {\n\t\tif (lsm != NULL && strcmp(lsm, hp->lsm))\n\t\t\tcontinue;\n\t\treturn hp->hook.setprocattr(name, value, size);\n\t}\n\treturn LSM_RET_DEFAULT(setprocattr);\n}\n\n \nint security_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\treturn call_int_hook(netlink_send, 0, sk, skb);\n}\n\n \nint security_ismaclabel(const char *name)\n{\n\treturn call_int_hook(ismaclabel, 0, name);\n}\nEXPORT_SYMBOL(security_ismaclabel);\n\n \nint security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\tstruct security_hook_list *hp;\n\tint rc;\n\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {\n\t\trc = hp->hook.secid_to_secctx(secid, secdata, seclen);\n\t\tif (rc != LSM_RET_DEFAULT(secid_to_secctx))\n\t\t\treturn rc;\n\t}\n\n\treturn LSM_RET_DEFAULT(secid_to_secctx);\n}\nEXPORT_SYMBOL(security_secid_to_secctx);\n\n \nint security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\t*secid = 0;\n\treturn call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);\n}\nEXPORT_SYMBOL(security_secctx_to_secid);\n\n \nvoid security_release_secctx(char *secdata, u32 seclen)\n{\n\tcall_void_hook(release_secctx, secdata, seclen);\n}\nEXPORT_SYMBOL(security_release_secctx);\n\n \nvoid security_inode_invalidate_secctx(struct inode *inode)\n{\n\tcall_void_hook(inode_invalidate_secctx, inode);\n}\nEXPORT_SYMBOL(security_inode_invalidate_secctx);\n\n \nint security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\treturn call_int_hook(inode_notifysecctx, 0, inode, ctx, ctxlen);\n}\nEXPORT_SYMBOL(security_inode_notifysecctx);\n\n \nint security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn call_int_hook(inode_setsecctx, 0, dentry, ctx, ctxlen);\n}\nEXPORT_SYMBOL(security_inode_setsecctx);\n\n \nint security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\treturn call_int_hook(inode_getsecctx, -EOPNOTSUPP, inode, ctx, ctxlen);\n}\nEXPORT_SYMBOL(security_inode_getsecctx);\n\n#ifdef CONFIG_WATCH_QUEUE\n \nint security_post_notification(const struct cred *w_cred,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct watch_notification *n)\n{\n\treturn call_int_hook(post_notification, 0, w_cred, cred, n);\n}\n#endif  \n\n#ifdef CONFIG_KEY_NOTIFICATIONS\n \nint security_watch_key(struct key *key)\n{\n\treturn call_int_hook(watch_key, 0, key);\n}\n#endif  \n\n#ifdef CONFIG_SECURITY_NETWORK\n \nint security_unix_stream_connect(struct sock *sock, struct sock *other,\n\t\t\t\t struct sock *newsk)\n{\n\treturn call_int_hook(unix_stream_connect, 0, sock, other, newsk);\n}\nEXPORT_SYMBOL(security_unix_stream_connect);\n\n \nint security_unix_may_send(struct socket *sock,  struct socket *other)\n{\n\treturn call_int_hook(unix_may_send, 0, sock, other);\n}\nEXPORT_SYMBOL(security_unix_may_send);\n\n \nint security_socket_create(int family, int type, int protocol, int kern)\n{\n\treturn call_int_hook(socket_create, 0, family, type, protocol, kern);\n}\n\n \nint security_socket_post_create(struct socket *sock, int family,\n\t\t\t\tint type, int protocol, int kern)\n{\n\treturn call_int_hook(socket_post_create, 0, sock, family, type,\n\t\t\t     protocol, kern);\n}\n\n \nint security_socket_socketpair(struct socket *socka, struct socket *sockb)\n{\n\treturn call_int_hook(socket_socketpair, 0, socka, sockb);\n}\nEXPORT_SYMBOL(security_socket_socketpair);\n\n \nint security_socket_bind(struct socket *sock,\n\t\t\t struct sockaddr *address, int addrlen)\n{\n\treturn call_int_hook(socket_bind, 0, sock, address, addrlen);\n}\n\n \nint security_socket_connect(struct socket *sock,\n\t\t\t    struct sockaddr *address, int addrlen)\n{\n\treturn call_int_hook(socket_connect, 0, sock, address, addrlen);\n}\n\n \nint security_socket_listen(struct socket *sock, int backlog)\n{\n\treturn call_int_hook(socket_listen, 0, sock, backlog);\n}\n\n \nint security_socket_accept(struct socket *sock, struct socket *newsock)\n{\n\treturn call_int_hook(socket_accept, 0, sock, newsock);\n}\n\n \nint security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)\n{\n\treturn call_int_hook(socket_sendmsg, 0, sock, msg, size);\n}\n\n \nint security_socket_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    int size, int flags)\n{\n\treturn call_int_hook(socket_recvmsg, 0, sock, msg, size, flags);\n}\n\n \nint security_socket_getsockname(struct socket *sock)\n{\n\treturn call_int_hook(socket_getsockname, 0, sock);\n}\n\n \nint security_socket_getpeername(struct socket *sock)\n{\n\treturn call_int_hook(socket_getpeername, 0, sock);\n}\n\n \nint security_socket_getsockopt(struct socket *sock, int level, int optname)\n{\n\treturn call_int_hook(socket_getsockopt, 0, sock, level, optname);\n}\n\n \nint security_socket_setsockopt(struct socket *sock, int level, int optname)\n{\n\treturn call_int_hook(socket_setsockopt, 0, sock, level, optname);\n}\n\n \nint security_socket_shutdown(struct socket *sock, int how)\n{\n\treturn call_int_hook(socket_shutdown, 0, sock, how);\n}\n\n \nint security_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\treturn call_int_hook(socket_sock_rcv_skb, 0, sk, skb);\n}\nEXPORT_SYMBOL(security_sock_rcv_skb);\n\n \nint security_socket_getpeersec_stream(struct socket *sock, sockptr_t optval,\n\t\t\t\t      sockptr_t optlen, unsigned int len)\n{\n\treturn call_int_hook(socket_getpeersec_stream, -ENOPROTOOPT, sock,\n\t\t\t     optval, optlen, len);\n}\n\n \nint security_socket_getpeersec_dgram(struct socket *sock,\n\t\t\t\t     struct sk_buff *skb, u32 *secid)\n{\n\treturn call_int_hook(socket_getpeersec_dgram, -ENOPROTOOPT, sock,\n\t\t\t     skb, secid);\n}\nEXPORT_SYMBOL(security_socket_getpeersec_dgram);\n\n \nint security_sk_alloc(struct sock *sk, int family, gfp_t priority)\n{\n\treturn call_int_hook(sk_alloc_security, 0, sk, family, priority);\n}\n\n \nvoid security_sk_free(struct sock *sk)\n{\n\tcall_void_hook(sk_free_security, sk);\n}\n\n \nvoid security_sk_clone(const struct sock *sk, struct sock *newsk)\n{\n\tcall_void_hook(sk_clone_security, sk, newsk);\n}\nEXPORT_SYMBOL(security_sk_clone);\n\n \nvoid security_sk_classify_flow(const struct sock *sk, struct flowi_common *flic)\n{\n\tcall_void_hook(sk_getsecid, sk, &flic->flowic_secid);\n}\nEXPORT_SYMBOL(security_sk_classify_flow);\n\n \nvoid security_req_classify_flow(const struct request_sock *req,\n\t\t\t\tstruct flowi_common *flic)\n{\n\tcall_void_hook(req_classify_flow, req, flic);\n}\nEXPORT_SYMBOL(security_req_classify_flow);\n\n \nvoid security_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tcall_void_hook(sock_graft, sk, parent);\n}\nEXPORT_SYMBOL(security_sock_graft);\n\n \nint security_inet_conn_request(const struct sock *sk,\n\t\t\t       struct sk_buff *skb, struct request_sock *req)\n{\n\treturn call_int_hook(inet_conn_request, 0, sk, skb, req);\n}\nEXPORT_SYMBOL(security_inet_conn_request);\n\n \nvoid security_inet_csk_clone(struct sock *newsk,\n\t\t\t     const struct request_sock *req)\n{\n\tcall_void_hook(inet_csk_clone, newsk, req);\n}\n\n \nvoid security_inet_conn_established(struct sock *sk,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tcall_void_hook(inet_conn_established, sk, skb);\n}\nEXPORT_SYMBOL(security_inet_conn_established);\n\n \nint security_secmark_relabel_packet(u32 secid)\n{\n\treturn call_int_hook(secmark_relabel_packet, 0, secid);\n}\nEXPORT_SYMBOL(security_secmark_relabel_packet);\n\n \nvoid security_secmark_refcount_inc(void)\n{\n\tcall_void_hook(secmark_refcount_inc);\n}\nEXPORT_SYMBOL(security_secmark_refcount_inc);\n\n \nvoid security_secmark_refcount_dec(void)\n{\n\tcall_void_hook(secmark_refcount_dec);\n}\nEXPORT_SYMBOL(security_secmark_refcount_dec);\n\n \nint security_tun_dev_alloc_security(void **security)\n{\n\treturn call_int_hook(tun_dev_alloc_security, 0, security);\n}\nEXPORT_SYMBOL(security_tun_dev_alloc_security);\n\n \nvoid security_tun_dev_free_security(void *security)\n{\n\tcall_void_hook(tun_dev_free_security, security);\n}\nEXPORT_SYMBOL(security_tun_dev_free_security);\n\n \nint security_tun_dev_create(void)\n{\n\treturn call_int_hook(tun_dev_create, 0);\n}\nEXPORT_SYMBOL(security_tun_dev_create);\n\n \nint security_tun_dev_attach_queue(void *security)\n{\n\treturn call_int_hook(tun_dev_attach_queue, 0, security);\n}\nEXPORT_SYMBOL(security_tun_dev_attach_queue);\n\n \nint security_tun_dev_attach(struct sock *sk, void *security)\n{\n\treturn call_int_hook(tun_dev_attach, 0, sk, security);\n}\nEXPORT_SYMBOL(security_tun_dev_attach);\n\n \nint security_tun_dev_open(void *security)\n{\n\treturn call_int_hook(tun_dev_open, 0, security);\n}\nEXPORT_SYMBOL(security_tun_dev_open);\n\n \nint security_sctp_assoc_request(struct sctp_association *asoc,\n\t\t\t\tstruct sk_buff *skb)\n{\n\treturn call_int_hook(sctp_assoc_request, 0, asoc, skb);\n}\nEXPORT_SYMBOL(security_sctp_assoc_request);\n\n \nint security_sctp_bind_connect(struct sock *sk, int optname,\n\t\t\t       struct sockaddr *address, int addrlen)\n{\n\treturn call_int_hook(sctp_bind_connect, 0, sk, optname,\n\t\t\t     address, addrlen);\n}\nEXPORT_SYMBOL(security_sctp_bind_connect);\n\n \nvoid security_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk,\n\t\t\t    struct sock *newsk)\n{\n\tcall_void_hook(sctp_sk_clone, asoc, sk, newsk);\n}\nEXPORT_SYMBOL(security_sctp_sk_clone);\n\n \nint security_sctp_assoc_established(struct sctp_association *asoc,\n\t\t\t\t    struct sk_buff *skb)\n{\n\treturn call_int_hook(sctp_assoc_established, 0, asoc, skb);\n}\nEXPORT_SYMBOL(security_sctp_assoc_established);\n\n \nint security_mptcp_add_subflow(struct sock *sk, struct sock *ssk)\n{\n\treturn call_int_hook(mptcp_add_subflow, 0, sk, ssk);\n}\n\n#endif\t \n\n#ifdef CONFIG_SECURITY_INFINIBAND\n \nint security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)\n{\n\treturn call_int_hook(ib_pkey_access, 0, sec, subnet_prefix, pkey);\n}\nEXPORT_SYMBOL(security_ib_pkey_access);\n\n \nint security_ib_endport_manage_subnet(void *sec,\n\t\t\t\t      const char *dev_name, u8 port_num)\n{\n\treturn call_int_hook(ib_endport_manage_subnet, 0, sec,\n\t\t\t     dev_name, port_num);\n}\nEXPORT_SYMBOL(security_ib_endport_manage_subnet);\n\n \nint security_ib_alloc_security(void **sec)\n{\n\treturn call_int_hook(ib_alloc_security, 0, sec);\n}\nEXPORT_SYMBOL(security_ib_alloc_security);\n\n \nvoid security_ib_free_security(void *sec)\n{\n\tcall_void_hook(ib_free_security, sec);\n}\nEXPORT_SYMBOL(security_ib_free_security);\n#endif\t \n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n \nint security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t       struct xfrm_user_sec_ctx *sec_ctx,\n\t\t\t       gfp_t gfp)\n{\n\treturn call_int_hook(xfrm_policy_alloc_security, 0, ctxp, sec_ctx, gfp);\n}\nEXPORT_SYMBOL(security_xfrm_policy_alloc);\n\n \nint security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\n\t\t\t       struct xfrm_sec_ctx **new_ctxp)\n{\n\treturn call_int_hook(xfrm_policy_clone_security, 0, old_ctx, new_ctxp);\n}\n\n \nvoid security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\n{\n\tcall_void_hook(xfrm_policy_free_security, ctx);\n}\nEXPORT_SYMBOL(security_xfrm_policy_free);\n\n \nint security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\n{\n\treturn call_int_hook(xfrm_policy_delete_security, 0, ctx);\n}\n\n \nint security_xfrm_state_alloc(struct xfrm_state *x,\n\t\t\t      struct xfrm_user_sec_ctx *sec_ctx)\n{\n\treturn call_int_hook(xfrm_state_alloc, 0, x, sec_ctx);\n}\nEXPORT_SYMBOL(security_xfrm_state_alloc);\n\n \nint security_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_sec_ctx *polsec, u32 secid)\n{\n\treturn call_int_hook(xfrm_state_alloc_acquire, 0, x, polsec, secid);\n}\n\n \nint security_xfrm_state_delete(struct xfrm_state *x)\n{\n\treturn call_int_hook(xfrm_state_delete_security, 0, x);\n}\nEXPORT_SYMBOL(security_xfrm_state_delete);\n\n \nvoid security_xfrm_state_free(struct xfrm_state *x)\n{\n\tcall_void_hook(xfrm_state_free_security, x);\n}\n\n \nint security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid)\n{\n\treturn call_int_hook(xfrm_policy_lookup, 0, ctx, fl_secid);\n}\n\n \nint security_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t       struct xfrm_policy *xp,\n\t\t\t\t       const struct flowi_common *flic)\n{\n\tstruct security_hook_list *hp;\n\tint rc = LSM_RET_DEFAULT(xfrm_state_pol_flow_match);\n\n\t \n\thlist_for_each_entry(hp, &security_hook_heads.xfrm_state_pol_flow_match,\n\t\t\t     list) {\n\t\trc = hp->hook.xfrm_state_pol_flow_match(x, xp, flic);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nint security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)\n{\n\treturn call_int_hook(xfrm_decode_session, 0, skb, secid, 1);\n}\n\nvoid security_skb_classify_flow(struct sk_buff *skb, struct flowi_common *flic)\n{\n\tint rc = call_int_hook(xfrm_decode_session, 0, skb, &flic->flowic_secid,\n\t\t\t       0);\n\n\tBUG_ON(rc);\n}\nEXPORT_SYMBOL(security_skb_classify_flow);\n#endif\t \n\n#ifdef CONFIG_KEYS\n \nint security_key_alloc(struct key *key, const struct cred *cred,\n\t\t       unsigned long flags)\n{\n\treturn call_int_hook(key_alloc, 0, key, cred, flags);\n}\n\n \nvoid security_key_free(struct key *key)\n{\n\tcall_void_hook(key_free, key);\n}\n\n \nint security_key_permission(key_ref_t key_ref, const struct cred *cred,\n\t\t\t    enum key_need_perm need_perm)\n{\n\treturn call_int_hook(key_permission, 0, key_ref, cred, need_perm);\n}\n\n \nint security_key_getsecurity(struct key *key, char **buffer)\n{\n\t*buffer = NULL;\n\treturn call_int_hook(key_getsecurity, 0, key, buffer);\n}\n#endif\t \n\n#ifdef CONFIG_AUDIT\n \nint security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)\n{\n\treturn call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);\n}\n\n \nint security_audit_rule_known(struct audit_krule *krule)\n{\n\treturn call_int_hook(audit_rule_known, 0, krule);\n}\n\n \nvoid security_audit_rule_free(void *lsmrule)\n{\n\tcall_void_hook(audit_rule_free, lsmrule);\n}\n\n \nint security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)\n{\n\treturn call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);\n}\n#endif  \n\n#ifdef CONFIG_BPF_SYSCALL\n \nint security_bpf(int cmd, union bpf_attr *attr, unsigned int size)\n{\n\treturn call_int_hook(bpf, 0, cmd, attr, size);\n}\n\n \nint security_bpf_map(struct bpf_map *map, fmode_t fmode)\n{\n\treturn call_int_hook(bpf_map, 0, map, fmode);\n}\n\n \nint security_bpf_prog(struct bpf_prog *prog)\n{\n\treturn call_int_hook(bpf_prog, 0, prog);\n}\n\n \nint security_bpf_map_alloc(struct bpf_map *map)\n{\n\treturn call_int_hook(bpf_map_alloc_security, 0, map);\n}\n\n \nint security_bpf_prog_alloc(struct bpf_prog_aux *aux)\n{\n\treturn call_int_hook(bpf_prog_alloc_security, 0, aux);\n}\n\n \nvoid security_bpf_map_free(struct bpf_map *map)\n{\n\tcall_void_hook(bpf_map_free_security, map);\n}\n\n \nvoid security_bpf_prog_free(struct bpf_prog_aux *aux)\n{\n\tcall_void_hook(bpf_prog_free_security, aux);\n}\n#endif  \n\n \nint security_locked_down(enum lockdown_reason what)\n{\n\treturn call_int_hook(locked_down, 0, what);\n}\nEXPORT_SYMBOL(security_locked_down);\n\n#ifdef CONFIG_PERF_EVENTS\n \nint security_perf_event_open(struct perf_event_attr *attr, int type)\n{\n\treturn call_int_hook(perf_event_open, 0, attr, type);\n}\n\n \nint security_perf_event_alloc(struct perf_event *event)\n{\n\treturn call_int_hook(perf_event_alloc, 0, event);\n}\n\n \nvoid security_perf_event_free(struct perf_event *event)\n{\n\tcall_void_hook(perf_event_free, event);\n}\n\n \nint security_perf_event_read(struct perf_event *event)\n{\n\treturn call_int_hook(perf_event_read, 0, event);\n}\n\n \nint security_perf_event_write(struct perf_event *event)\n{\n\treturn call_int_hook(perf_event_write, 0, event);\n}\n#endif  \n\n#ifdef CONFIG_IO_URING\n \nint security_uring_override_creds(const struct cred *new)\n{\n\treturn call_int_hook(uring_override_creds, 0, new);\n}\n\n \nint security_uring_sqpoll(void)\n{\n\treturn call_int_hook(uring_sqpoll, 0);\n}\n\n \nint security_uring_cmd(struct io_uring_cmd *ioucmd)\n{\n\treturn call_int_hook(uring_cmd, 0, ioucmd);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}