{
  "module_name": "netif.c",
  "hash_id": "c1ca36d29dd88c23b5e73fc1ff15adaff41fcc22943ec6742bf9638284bbdb51",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/netif.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/rcupdate.h>\n#include <net/net_namespace.h>\n\n#include \"security.h\"\n#include \"objsec.h\"\n#include \"netif.h\"\n\n#define SEL_NETIF_HASH_SIZE\t64\n#define SEL_NETIF_HASH_MAX\t1024\n\nstruct sel_netif {\n\tstruct list_head list;\n\tstruct netif_security_struct nsec;\n\tstruct rcu_head rcu_head;\n};\n\nstatic u32 sel_netif_total;\nstatic DEFINE_SPINLOCK(sel_netif_lock);\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\n \nstatic inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}\n\n \nstatic inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tu32 idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}\n\n \nstatic int sel_netif_insert(struct sel_netif *netif)\n{\n\tu32 idx;\n\n\tif (sel_netif_total >= SEL_NETIF_HASH_MAX)\n\t\treturn -ENOSPC;\n\n\tidx = sel_netif_hashfn(netif->nsec.ns, netif->nsec.ifindex);\n\tlist_add_rcu(&netif->list, &sel_netif_hash[idx]);\n\tsel_netif_total++;\n\n\treturn 0;\n}\n\n \nstatic void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}\n\n \nstatic int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)\n{\n\tint ret = 0;\n\tstruct sel_netif *netif;\n\tstruct sel_netif *new;\n\tstruct net_device *dev;\n\n\t \n\n\tdev = dev_get_by_index(ns, ifindex);\n\tif (unlikely(dev == NULL)) {\n\t\tpr_warn(\"SELinux: failure in %s(), invalid network interface (%d)\\n\",\n\t\t\t__func__, ifindex);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif != NULL) {\n\t\t*sid = netif->nsec.sid;\n\t\tgoto out;\n\t}\n\n\tret = security_netif_sid(dev->name, sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new) {\n\t\tnew->nsec.ns = ns;\n\t\tnew->nsec.ifindex = ifindex;\n\t\tnew->nsec.sid = *sid;\n\t\tif (sel_netif_insert(new))\n\t\t\tkfree(new);\n\t}\n\nout:\n\tspin_unlock_bh(&sel_netif_lock);\n\tdev_put(dev);\n\tif (unlikely(ret))\n\t\tpr_warn(\"SELinux: failure in %s(), unable to determine network interface label (%d)\\n\",\n\t\t\t__func__, ifindex);\n\treturn ret;\n}\n\n \nint sel_netif_sid(struct net *ns, int ifindex, u32 *sid)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (likely(netif != NULL)) {\n\t\t*sid = netif->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netif_sid_slow(ns, ifindex, sid);\n}\n\n \nstatic void sel_netif_kill(const struct net *ns, int ifindex)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif)\n\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n\trcu_read_unlock();\n}\n\n \nvoid sel_netif_flush(void)\n{\n\tint idx;\n\tstruct sel_netif *netif;\n\n\tspin_lock_bh(&sel_netif_lock);\n\tfor (idx = 0; idx < SEL_NETIF_HASH_SIZE; idx++)\n\t\tlist_for_each_entry(netif, &sel_netif_hash[idx], list)\n\t\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n}\n\nstatic int sel_netif_netdev_notifier_handler(struct notifier_block *this,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (event == NETDEV_DOWN)\n\t\tsel_netif_kill(dev_net(dev), dev->ifindex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sel_netif_netdev_notifier = {\n\t.notifier_call = sel_netif_netdev_notifier_handler,\n};\n\nstatic __init int sel_netif_init(void)\n{\n\tint i;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tfor (i = 0; i < SEL_NETIF_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&sel_netif_hash[i]);\n\n\tregister_netdevice_notifier(&sel_netif_netdev_notifier);\n\n\treturn 0;\n}\n\n__initcall(sel_netif_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}