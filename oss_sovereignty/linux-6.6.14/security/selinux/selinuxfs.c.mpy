{
  "module_name": "selinuxfs.c",
  "hash_id": "563b355e3be5912885088eec193bde906c9ab8cb2b511555a9115170c31083c7",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/selinuxfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/security.h>\n#include <linux/major.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/audit.h>\n#include <linux/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/ctype.h>\n\n \n\n#include \"flask.h\"\n#include \"avc.h\"\n#include \"avc_ss.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include \"conditional.h\"\n#include \"ima.h\"\n\nenum sel_inos {\n\tSEL_ROOT_INO = 2,\n\tSEL_LOAD,\t \n\tSEL_ENFORCE,\t \n\tSEL_CONTEXT,\t \n\tSEL_ACCESS,\t \n\tSEL_CREATE,\t \n\tSEL_RELABEL,\t \n\tSEL_USER,\t \n\tSEL_POLICYVERS,\t \n\tSEL_COMMIT_BOOLS,  \n\tSEL_MLS,\t \n\tSEL_DISABLE,\t \n\tSEL_MEMBER,\t \n\tSEL_CHECKREQPROT,  \n\tSEL_COMPAT_NET,\t \n\tSEL_REJECT_UNKNOWN,  \n\tSEL_DENY_UNKNOWN,  \n\tSEL_STATUS,\t \n\tSEL_POLICY,\t \n\tSEL_VALIDATE_TRANS,  \n\tSEL_INO_NEXT,\t \n};\n\nstruct selinux_fs_info {\n\tstruct dentry *bool_dir;\n\tunsigned int bool_num;\n\tchar **bool_pending_names;\n\tint *bool_pending_values;\n\tstruct dentry *class_dir;\n\tunsigned long last_class_ino;\n\tbool policy_opened;\n\tstruct dentry *policycap_dir;\n\tunsigned long last_ino;\n\tstruct super_block *sb;\n};\n\nstatic int selinux_fs_info_create(struct super_block *sb)\n{\n\tstruct selinux_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(*fsi), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn -ENOMEM;\n\n\tfsi->last_ino = SEL_INO_NEXT - 1;\n\tfsi->sb = sb;\n\tsb->s_fs_info = fsi;\n\treturn 0;\n}\n\nstatic void selinux_fs_info_free(struct super_block *sb)\n{\n\tstruct selinux_fs_info *fsi = sb->s_fs_info;\n\tunsigned int i;\n\n\tif (fsi) {\n\t\tfor (i = 0; i < fsi->bool_num; i++)\n\t\t\tkfree(fsi->bool_pending_names[i]);\n\t\tkfree(fsi->bool_pending_names);\n\t\tkfree(fsi->bool_pending_values);\n\t}\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}\n\n#define SEL_INITCON_INO_OFFSET\t\t0x01000000\n#define SEL_BOOL_INO_OFFSET\t\t0x02000000\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n#define SEL_POLICYCAP_INO_OFFSET\t0x08000000\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\n#define BOOL_DIR_NAME \"booleans\"\n#define CLASS_DIR_NAME \"class\"\n#define POLICYCAP_DIR_NAME \"policy_capabilities\"\n\n#define TMPBUFLEN\t12\nstatic ssize_t sel_read_enforce(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\",\n\t\t\t   enforcing_enabled());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\n#ifdef CONFIG_SECURITY_SELINUX_DEVELOP\nstatic ssize_t sel_write_enforce(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint scan_value;\n\tbool old_value, new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &scan_value) != 1)\n\t\tgoto out;\n\n\tnew_value = !!scan_value;\n\n\told_value = enforcing_enabled();\n\tif (new_value != old_value) {\n\t\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t\t      SECCLASS_SECURITY, SECURITY__SETENFORCE,\n\t\t\t\t      NULL);\n\t\tif (length)\n\t\t\tgoto out;\n\t\taudit_log(audit_context(), GFP_KERNEL, AUDIT_MAC_STATUS,\n\t\t\t\"enforcing=%d old_enforcing=%d auid=%u ses=%u\"\n\t\t\t\" enabled=1 old-enabled=1 lsm=selinux res=1\",\n\t\t\tnew_value, old_value,\n\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\taudit_get_sessionid(current));\n\t\tenforcing_set(new_value);\n\t\tif (new_value)\n\t\t\tavc_ss_reset(0);\n\t\tselnl_notify_setenforce(new_value);\n\t\tselinux_status_update_setenforce(new_value);\n\t\tif (!new_value)\n\t\t\tcall_blocking_lsm_notifier(LSM_POLICY_CHANGE, NULL);\n\n\t\tselinux_ima_measure_state();\n\t}\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}\n#else\n#define sel_write_enforce NULL\n#endif\n\nstatic const struct file_operations sel_enforce_ops = {\n\t.read\t\t= sel_read_enforce,\n\t.write\t\t= sel_write_enforce,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_read_handle_unknown(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tino_t ino = file_inode(filp)->i_ino;\n\tint handle_unknown = (ino == SEL_REJECT_UNKNOWN) ?\n\t\tsecurity_get_reject_unknown() :\n\t\t!security_get_allow_unknown();\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", handle_unknown);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations sel_handle_unknown_ops = {\n\t.read\t\t= sel_read_handle_unknown,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_open_handle_status(struct inode *inode, struct file *filp)\n{\n\tstruct page    *status = selinux_kernel_status_page();\n\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tfilp->private_data = status;\n\n\treturn 0;\n}\n\nstatic ssize_t sel_read_handle_status(struct file *filp, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct page    *status = filp->private_data;\n\n\tBUG_ON(!status);\n\n\treturn simple_read_from_buffer(buf, count, ppos,\n\t\t\t\t       page_address(status),\n\t\t\t\t       sizeof(struct selinux_kernel_status));\n}\n\nstatic int sel_mmap_handle_status(struct file *filp,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct page    *status = filp->private_data;\n\tunsigned long\tsize = vma->vm_end - vma->vm_start;\n\n\tBUG_ON(!status);\n\n\t \n\tif (vma->vm_pgoff > 0 || size != PAGE_SIZE)\n\t\treturn -EIO;\n\t \n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\t \n\tvm_flags_clear(vma, VM_MAYWRITE);\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(status),\n\t\t\t       size, vma->vm_page_prot);\n}\n\nstatic const struct file_operations sel_handle_status_ops = {\n\t.open\t\t= sel_open_handle_status,\n\t.read\t\t= sel_read_handle_status,\n\t.mmap\t\t= sel_mmap_handle_status,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_write_disable(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tif (sscanf(page, \"%d\", &new_value) != 1) {\n\t\tlength = -EINVAL;\n\t\tgoto out;\n\t}\n\tlength = count;\n\n\tif (new_value) {\n\t\tpr_err(\"SELinux: https://github.com/SELinuxProject/selinux-kernel/wiki/DEPRECATE-runtime-disable\\n\");\n\t\tpr_err(\"SELinux: Runtime disable is not supported, use selinux=0 on the kernel cmdline.\\n\");\n\t}\n\nout:\n\tkfree(page);\n\treturn length;\n}\n\nstatic const struct file_operations sel_disable_ops = {\n\t.write\t\t= sel_write_disable,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_read_policyvers(struct file *filp, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", POLICYDB_VERSION_MAX);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations sel_policyvers_ops = {\n\t.read\t\t= sel_read_policyvers,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n \nstatic int sel_make_bools(struct selinux_policy *newpolicy, struct dentry *bool_dir,\n\t\t\t  unsigned int *bool_num, char ***bool_pending_names,\n\t\t\t  int **bool_pending_values);\nstatic int sel_make_classes(struct selinux_policy *newpolicy,\n\t\t\t    struct dentry *class_dir,\n\t\t\t    unsigned long *last_class_ino);\n\n \nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\n \nstatic struct dentry *sel_make_disconnected_dir(struct super_block *sb,\n\t\t\t\t\t\tunsigned long *ino);\n\n \nstatic void sel_remove_entries(struct dentry *de);\n\nstatic ssize_t sel_read_mls(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\",\n\t\t\t   security_mls_enabled());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations sel_mls_ops = {\n\t.read\t\t= sel_read_mls,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstruct policy_load_memory {\n\tsize_t len;\n\tvoid *data;\n};\n\nstatic int sel_open_policy(struct inode *inode, struct file *filp)\n{\n\tstruct selinux_fs_info *fsi = inode->i_sb->s_fs_info;\n\tstruct policy_load_memory *plm = NULL;\n\tint rc;\n\n\tBUG_ON(filp->private_data);\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\trc = -EBUSY;\n\tif (fsi->policy_opened)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tplm = kzalloc(sizeof(*plm), GFP_KERNEL);\n\tif (!plm)\n\t\tgoto err;\n\n\trc = security_read_policy(&plm->data, &plm->len);\n\tif (rc)\n\t\tgoto err;\n\n\tif ((size_t)i_size_read(inode) != plm->len) {\n\t\tinode_lock(inode);\n\t\ti_size_write(inode, plm->len);\n\t\tinode_unlock(inode);\n\t}\n\n\tfsi->policy_opened = 1;\n\n\tfilp->private_data = plm;\n\n\tmutex_unlock(&selinux_state.policy_mutex);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&selinux_state.policy_mutex);\n\n\tif (plm)\n\t\tvfree(plm->data);\n\tkfree(plm);\n\treturn rc;\n}\n\nstatic int sel_release_policy(struct inode *inode, struct file *filp)\n{\n\tstruct selinux_fs_info *fsi = inode->i_sb->s_fs_info;\n\tstruct policy_load_memory *plm = filp->private_data;\n\n\tBUG_ON(!plm);\n\n\tfsi->policy_opened = 0;\n\n\tvfree(plm->data);\n\tkfree(plm);\n\n\treturn 0;\n}\n\nstatic ssize_t sel_read_policy(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct policy_load_memory *plm = filp->private_data;\n\tint ret;\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn simple_read_from_buffer(buf, count, ppos, plm->data, plm->len);\n}\n\nstatic vm_fault_t sel_mmap_policy_fault(struct vm_fault *vmf)\n{\n\tstruct policy_load_memory *plm = vmf->vma->vm_file->private_data;\n\tunsigned long offset;\n\tstruct page *page;\n\n\tif (vmf->flags & (FAULT_FLAG_MKWRITE | FAULT_FLAG_WRITE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= roundup(plm->len, PAGE_SIZE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tpage = vmalloc_to_page(plm->data + offset);\n\tget_page(page);\n\n\tvmf->page = page;\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct sel_mmap_policy_ops = {\n\t.fault = sel_mmap_policy_fault,\n\t.page_mkwrite = sel_mmap_policy_fault,\n};\n\nstatic int sel_mmap_policy(struct file *filp, struct vm_area_struct *vma)\n{\n\tif (vma->vm_flags & VM_SHARED) {\n\t\t \n\t\tvm_flags_clear(vma, VM_MAYWRITE);\n\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\treturn -EACCES;\n\t}\n\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_ops = &sel_mmap_policy_ops;\n\n\treturn 0;\n}\n\nstatic const struct file_operations sel_policy_ops = {\n\t.open\t\t= sel_open_policy,\n\t.read\t\t= sel_read_policy,\n\t.mmap\t\t= sel_mmap_policy,\n\t.release\t= sel_release_policy,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic void sel_remove_old_bool_data(unsigned int bool_num, char **bool_names,\n\t\t\t\t     int *bool_values)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < bool_num; i++)\n\t\tkfree(bool_names[i]);\n\tkfree(bool_names);\n\tkfree(bool_values);\n}\n\nstatic int sel_make_policy_nodes(struct selinux_fs_info *fsi,\n\t\t\t\tstruct selinux_policy *newpolicy)\n{\n\tint ret = 0;\n\tstruct dentry *tmp_parent, *tmp_bool_dir, *tmp_class_dir, *old_dentry;\n\tunsigned int tmp_bool_num, old_bool_num;\n\tchar **tmp_bool_names, **old_bool_names;\n\tint *tmp_bool_values, *old_bool_values;\n\tunsigned long tmp_ino = fsi->last_ino;  \n\n\ttmp_parent = sel_make_disconnected_dir(fsi->sb, &tmp_ino);\n\tif (IS_ERR(tmp_parent))\n\t\treturn PTR_ERR(tmp_parent);\n\n\ttmp_ino = fsi->bool_dir->d_inode->i_ino - 1;  \n\ttmp_bool_dir = sel_make_dir(tmp_parent, BOOL_DIR_NAME, &tmp_ino);\n\tif (IS_ERR(tmp_bool_dir)) {\n\t\tret = PTR_ERR(tmp_bool_dir);\n\t\tgoto out;\n\t}\n\n\ttmp_ino = fsi->class_dir->d_inode->i_ino - 1;  \n\ttmp_class_dir = sel_make_dir(tmp_parent, CLASS_DIR_NAME, &tmp_ino);\n\tif (IS_ERR(tmp_class_dir)) {\n\t\tret = PTR_ERR(tmp_class_dir);\n\t\tgoto out;\n\t}\n\n\tret = sel_make_bools(newpolicy, tmp_bool_dir, &tmp_bool_num,\n\t\t\t     &tmp_bool_names, &tmp_bool_values);\n\tif (ret)\n\t\tgoto out;\n\n\tret = sel_make_classes(newpolicy, tmp_class_dir,\n\t\t\t       &fsi->last_class_ino);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\told_dentry = fsi->bool_dir;\n\tlock_rename(tmp_bool_dir, old_dentry);\n\td_exchange(tmp_bool_dir, fsi->bool_dir);\n\n\told_bool_num = fsi->bool_num;\n\told_bool_names = fsi->bool_pending_names;\n\told_bool_values = fsi->bool_pending_values;\n\n\tfsi->bool_num = tmp_bool_num;\n\tfsi->bool_pending_names = tmp_bool_names;\n\tfsi->bool_pending_values = tmp_bool_values;\n\n\tsel_remove_old_bool_data(old_bool_num, old_bool_names, old_bool_values);\n\n\tfsi->bool_dir = tmp_bool_dir;\n\tunlock_rename(tmp_bool_dir, old_dentry);\n\n\t \n\told_dentry = fsi->class_dir;\n\tlock_rename(tmp_class_dir, old_dentry);\n\td_exchange(tmp_class_dir, fsi->class_dir);\n\tfsi->class_dir = tmp_class_dir;\n\tunlock_rename(tmp_class_dir, old_dentry);\n\nout:\n\t \n\tsel_remove_entries(tmp_parent);\n\tdput(tmp_parent);  \n\n\treturn ret;\n}\n\nstatic ssize_t sel_write_load(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n\n{\n\tstruct selinux_fs_info *fsi = file_inode(file)->i_sb->s_fs_info;\n\tstruct selinux_load_state load_state;\n\tssize_t length;\n\tvoid *data = NULL;\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__LOAD_POLICY, NULL);\n\tif (length)\n\t\tgoto out;\n\n\t \n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tdata = vmalloc(count);\n\tif (!data)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(data, buf, count) != 0)\n\t\tgoto out;\n\n\tlength = security_load_policy(data, count, &load_state);\n\tif (length) {\n\t\tpr_warn_ratelimited(\"SELinux: failed to load policy\\n\");\n\t\tgoto out;\n\t}\n\n\tlength = sel_make_policy_nodes(fsi, load_state.policy);\n\tif (length) {\n\t\tpr_warn_ratelimited(\"SELinux: failed to initialize selinuxfs\\n\");\n\t\tselinux_policy_cancel(&load_state);\n\t\tgoto out;\n\t}\n\n\tselinux_policy_commit(&load_state);\n\n\tlength = count;\n\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_MAC_POLICY_LOAD,\n\t\t\"auid=%u ses=%u lsm=selinux res=1\",\n\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\taudit_get_sessionid(current));\nout:\n\tmutex_unlock(&selinux_state.policy_mutex);\n\tvfree(data);\n\treturn length;\n}\n\nstatic const struct file_operations sel_load_ops = {\n\t.write\t\t= sel_write_load,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_write_context(struct file *file, char *buf, size_t size)\n{\n\tchar *canon = NULL;\n\tu32 sid, len;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_to_sid(buf, size, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(sid, &canon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tpr_err(\"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, canon, len);\n\tlength = len;\nout:\n\tkfree(canon);\n\treturn length;\n}\n\nstatic ssize_t sel_read_checkreqprot(struct file *filp, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   checkreqprot_get());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t sel_write_checkreqprot(struct file *file, const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\tunsigned int new_value;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETCHECKREQPROT,\n\t\t\t      NULL);\n\tif (length)\n\t\treturn length;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tif (sscanf(page, \"%u\", &new_value) != 1) {\n\t\tlength = -EINVAL;\n\t\tgoto out;\n\t}\n\tlength = count;\n\n\tif (new_value) {\n\t\tchar comm[sizeof(current->comm)];\n\n\t\tmemcpy(comm, current->comm, sizeof(comm));\n\t\tpr_err(\"SELinux: %s (%d) set checkreqprot to 1. This is no longer supported.\\n\",\n\t\t       comm, current->pid);\n\t}\n\n\tselinux_ima_measure_state();\n\nout:\n\tkfree(page);\n\treturn length;\n}\nstatic const struct file_operations sel_checkreqprot_ops = {\n\t.read\t\t= sel_read_checkreqprot,\n\t.write\t\t= sel_write_checkreqprot,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_write_validatetrans(struct file *file,\n\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *oldcon = NULL, *newcon = NULL, *taskcon = NULL;\n\tchar *req = NULL;\n\tu32 osid, nsid, tsid;\n\tu16 tclass;\n\tint rc;\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__VALIDATE_TRANS, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t \n\trc = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\treq = memdup_user_nul(buf, count);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\toldcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!oldcon)\n\t\tgoto out;\n\n\tnewcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!newcon)\n\t\tgoto out;\n\n\ttaskcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!taskcon)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (sscanf(req, \"%s %s %hu %s\", oldcon, newcon, &tclass, taskcon) != 4)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(oldcon, &osid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(newcon, &nsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(taskcon, &tsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_validate_transition_user(osid, nsid, tsid, tclass);\n\tif (!rc)\n\t\trc = count;\nout:\n\tkfree(req);\n\tkfree(oldcon);\n\tkfree(newcon);\n\tkfree(taskcon);\n\treturn rc;\n}\n\nstatic const struct file_operations sel_transition_ops = {\n\t.write\t\t= sel_write_validatetrans,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n \nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t (*const write_op[])(struct file *, char *, size_t) = {\n\t[SEL_ACCESS] = sel_write_access,\n\t[SEL_CREATE] = sel_write_create,\n\t[SEL_RELABEL] = sel_write_relabel,\n\t[SEL_USER] = sel_write_user,\n\t[SEL_MEMBER] = sel_write_member,\n\t[SEL_CONTEXT] = sel_write_context,\n};\n\nstatic ssize_t selinux_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino = file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv = write_op[ino](file, data, size);\n\tif (rv > 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}\n\nstatic const struct file_operations transaction_ops = {\n\t.write\t\t= selinux_transaction_write,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n \n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid;\n\tu16 tclass;\n\tstruct av_decision avd;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_AV, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tsecurity_compute_av_user(ssid, tsid, tclass, &avd);\n\n\tlength = scnprintf(buf, SIMPLE_TRANSACTION_LIMIT,\n\t\t\t  \"%x %x %x %x %u %x\",\n\t\t\t  avd.allowed, 0xffffffff,\n\t\t\t  avd.auditallow, avd.auditdeny,\n\t\t\t  avd.seqno, avd.flags);\nout:\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}\n\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tchar *namebuf = NULL, *objname = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\tint nargs;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tnamebuf = kzalloc(size + 1, GFP_KERNEL);\n\tif (!namebuf)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tnargs = sscanf(buf, \"%s %s %hu %s\", scon, tcon, &tclass, namebuf);\n\tif (nargs < 3 || nargs > 4)\n\t\tgoto out;\n\tif (nargs == 4) {\n\t\t \n\t\tchar   *r, *w;\n\t\tint     c1, c2;\n\n\t\tr = w = namebuf;\n\t\tdo {\n\t\t\tc1 = *r++;\n\t\t\tif (c1 == '+')\n\t\t\t\tc1 = ' ';\n\t\t\telse if (c1 == '%') {\n\t\t\t\tc1 = hex_to_bin(*r++);\n\t\t\t\tif (c1 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc2 = hex_to_bin(*r++);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc1 = (c1 << 4) | c2;\n\t\t\t}\n\t\t\t*w++ = c1;\n\t\t} while (c1 != '\\0');\n\n\t\tobjname = namebuf;\n\t}\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_transition_sid_user(ssid, tsid, tclass,\n\t\t\t\t\t      objname, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tpr_err(\"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(namebuf);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}\n\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_change_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT)\n\t\tgoto out;\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}\n\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size)\n{\n\tchar *con = NULL, *user = NULL, *ptr;\n\tu32 sid, *sids = NULL;\n\tssize_t length;\n\tchar *newcon;\n\tint rc;\n\tu32 i, len, nsids;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_USER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!con)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tuser = kzalloc(size + 1, GFP_KERNEL);\n\tif (!user)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s\", con, user) != 2)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(con, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_get_user_sids(sid, user, &sids, &nsids);\n\tif (length)\n\t\tgoto out;\n\n\tlength = sprintf(buf, \"%u\", nsids) + 1;\n\tptr = buf + length;\n\tfor (i = 0; i < nsids; i++) {\n\t\trc = security_sid_to_context(sids[i], &newcon, &len);\n\t\tif (rc) {\n\t\t\tlength = rc;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((length + len) >= SIMPLE_TRANSACTION_LIMIT) {\n\t\t\tkfree(newcon);\n\t\t\tlength = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(ptr, newcon, len);\n\t\tkfree(newcon);\n\t\tptr += len;\n\t\tlength += len;\n\t}\nout:\n\tkfree(sids);\n\tkfree(user);\n\tkfree(con);\n\treturn length;\n}\n\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_member_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tpr_err(\"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}\n\nstatic struct inode *sel_make_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = inode_set_ctime_current(ret);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t sel_read_bool(struct file *filep, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct selinux_fs_info *fsi = file_inode(filep)->i_sb->s_fs_info;\n\tchar *page = NULL;\n\tssize_t length;\n\tssize_t ret;\n\tint cur_enforcing;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\n\tret = -EINVAL;\n\tif (index >= fsi->bool_num || strcmp(name,\n\t\t\t\t\t     fsi->bool_pending_names[index]))\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out_unlock;\n\n\tcur_enforcing = security_get_bool_value(index);\n\tif (cur_enforcing < 0) {\n\t\tret = cur_enforcing;\n\t\tgoto out_unlock;\n\t}\n\tlength = scnprintf(page, PAGE_SIZE, \"%d %d\", cur_enforcing,\n\t\t\t  fsi->bool_pending_values[index]);\n\tmutex_unlock(&selinux_state.policy_mutex);\n\tret = simple_read_from_buffer(buf, count, ppos, page, length);\nout_free:\n\tfree_page((unsigned long)page);\n\treturn ret;\n\nout_unlock:\n\tmutex_unlock(&selinux_state.policy_mutex);\n\tgoto out_free;\n}\n\nstatic ssize_t sel_write_bool(struct file *filep, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct selinux_fs_info *fsi = file_inode(filep)->i_sb->s_fs_info;\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (index >= fsi->bool_num || strcmp(name,\n\t\t\t\t\t     fsi->bool_pending_names[index]))\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tif (new_value)\n\t\tnew_value = 1;\n\n\tfsi->bool_pending_values[index] = new_value;\n\tlength = count;\n\nout:\n\tmutex_unlock(&selinux_state.policy_mutex);\n\tkfree(page);\n\treturn length;\n}\n\nstatic const struct file_operations sel_bool_ops = {\n\t.read\t\t= sel_read_bool,\n\t.write\t\t= sel_write_bool,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_commit_bools_write(struct file *filep,\n\t\t\t\t      const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct selinux_fs_info *fsi = file_inode(filep)->i_sb->s_fs_info;\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tlength = 0;\n\tif (new_value && fsi->bool_pending_values)\n\t\tlength = security_set_bools(fsi->bool_num,\n\t\t\t\t\t    fsi->bool_pending_values);\n\n\tif (!length)\n\t\tlength = count;\n\nout:\n\tmutex_unlock(&selinux_state.policy_mutex);\n\tkfree(page);\n\treturn length;\n}\n\nstatic const struct file_operations sel_commit_bools_ops = {\n\t.write\t\t= sel_commit_bools_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}\n\nstatic int sel_make_bools(struct selinux_policy *newpolicy, struct dentry *bool_dir,\n\t\t\t  unsigned int *bool_num, char ***bool_pending_names,\n\t\t\t  int **bool_pending_values)\n{\n\tint ret;\n\tssize_t len;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tstruct inode_security_struct *isec;\n\tchar **names = NULL, *page;\n\tu32 i, num;\n\tint *values = NULL;\n\tu32 sid;\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tret = security_get_bools(newpolicy, &num, &names, &values);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = -ENOMEM;\n\t\tdentry = d_alloc_name(bool_dir, names[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\tret = -ENOMEM;\n\t\tinode = sel_make_inode(bool_dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = -ENAMETOOLONG;\n\t\tlen = snprintf(page, PAGE_SIZE, \"/%s/%s\", BOOL_DIR_NAME, names[i]);\n\t\tif (len >= PAGE_SIZE) {\n\t\t\tdput(dentry);\n\t\t\tiput(inode);\n\t\t\tgoto out;\n\t\t}\n\n\t\tisec = selinux_inode(inode);\n\t\tret = selinux_policy_genfs_sid(newpolicy, \"selinuxfs\", page,\n\t\t\t\t\t SECCLASS_FILE, &sid);\n\t\tif (ret) {\n\t\t\tpr_warn_ratelimited(\"SELinux: no sid found, defaulting to security isid for %s\\n\",\n\t\t\t\t\t   page);\n\t\t\tsid = SECINITSID_SECURITY;\n\t\t}\n\n\t\tisec->sid = sid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tinode->i_fop = &sel_bool_ops;\n\t\tinode->i_ino = i|SEL_BOOL_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\t*bool_num = num;\n\t*bool_pending_names = names;\n\t*bool_pending_values = values;\n\n\tfree_page((unsigned long)page);\n\treturn 0;\nout:\n\tfree_page((unsigned long)page);\n\n\tif (names) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tkfree(names[i]);\n\t\tkfree(names);\n\t}\n\tkfree(values);\n\tsel_remove_entries(bool_dir);\n\n\treturn ret;\n}\n\nstatic ssize_t sel_read_avc_cache_threshold(struct file *filp, char __user *buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   avc_get_cache_threshold());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t sel_write_avc_cache_threshold(struct file *file,\n\t\t\t\t\t     const char __user *buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t ret;\n\tunsigned int new_value;\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t   SECCLASS_SECURITY, SECURITY__SETSECPARAM,\n\t\t\t   NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tret = -EINVAL;\n\tif (sscanf(page, \"%u\", &new_value) != 1)\n\t\tgoto out;\n\n\tavc_set_cache_threshold(new_value);\n\n\tret = count;\nout:\n\tkfree(page);\n\treturn ret;\n}\n\nstatic ssize_t sel_read_avc_hash_stats(struct file *filp, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlength = avc_get_hash_stats(page);\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, page, length);\n\tfree_page((unsigned long)page);\n\n\treturn length;\n}\n\nstatic ssize_t sel_read_sidtab_hash_stats(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlength = security_sidtab_hash_stats(page);\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, page,\n\t\t\t\t\t\tlength);\n\tfree_page((unsigned long)page);\n\n\treturn length;\n}\n\nstatic const struct file_operations sel_sidtab_hash_stats_ops = {\n\t.read\t\t= sel_read_sidtab_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations sel_avc_cache_threshold_ops = {\n\t.read\t\t= sel_read_avc_cache_threshold,\n\t.write\t\t= sel_write_avc_cache_threshold,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations sel_avc_hash_stats_ops = {\n\t.read\t\t= sel_read_avc_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\nstatic struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\t(*idx)++;\n\treturn NULL;\n}\n\nstatic void *sel_avc_stats_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t n = *pos - 1;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn sel_avc_get_stat_idx(&n);\n}\n\nstatic void *sel_avc_stats_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn sel_avc_get_stat_idx(pos);\n}\n\nstatic int sel_avc_stats_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct avc_cache_stats *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"lookups hits misses allocations reclaims frees\\n\");\n\t} else {\n\t\tunsigned int lookups = st->lookups;\n\t\tunsigned int misses = st->misses;\n\t\tunsigned int hits = lookups - misses;\n\t\tseq_printf(seq, \"%u %u %u %u %u %u\\n\", lookups,\n\t\t\t   hits, misses, st->allocations,\n\t\t\t   st->reclaims, st->frees);\n\t}\n\treturn 0;\n}\n\nstatic void sel_avc_stats_seq_stop(struct seq_file *seq, void *v)\n{ }\n\nstatic const struct seq_operations sel_avc_cache_stats_seq_ops = {\n\t.start\t\t= sel_avc_stats_seq_start,\n\t.next\t\t= sel_avc_stats_seq_next,\n\t.show\t\t= sel_avc_stats_seq_show,\n\t.stop\t\t= sel_avc_stats_seq_stop,\n};\n\nstatic int sel_open_avc_cache_stats(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &sel_avc_cache_stats_seq_ops);\n}\n\nstatic const struct file_operations sel_avc_cache_stats_ops = {\n\t.open\t\t= sel_open_avc_cache_stats,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n#endif\n\nstatic int sel_make_avc_files(struct dentry *dir)\n{\n\tstruct super_block *sb = dir->d_sb;\n\tstruct selinux_fs_info *fsi = sb->s_fs_info;\n\tunsigned int i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"cache_threshold\",\n\t\t  &sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\n\t\t{ \"hash_stats\", &sel_avc_hash_stats_ops, S_IRUGO },\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n\t\t{ \"cache_stats\", &sel_avc_cache_stats_ops, S_IRUGO },\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++fsi->last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}\n\nstatic int sel_make_ss_files(struct dentry *dir)\n{\n\tstruct super_block *sb = dir->d_sb;\n\tstruct selinux_fs_info *fsi = sb->s_fs_info;\n\tunsigned int i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"sidtab_hash_stats\", &sel_sidtab_hash_stats_ops, S_IRUGO },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++fsi->last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t sel_read_initcon(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *con;\n\tu32 sid, len;\n\tssize_t ret;\n\n\tsid = file_inode(file)->i_ino&SEL_INO_MASK;\n\tret = security_sid_to_context(sid, &con, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos, con, len);\n\tkfree(con);\n\treturn ret;\n}\n\nstatic const struct file_operations sel_initcon_ops = {\n\t.read\t\t= sel_read_initcon,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_initcon_files(struct dentry *dir)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i <= SECINITSID_NUM; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\t\tconst char *s = security_get_initial_sid_context(i);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tdentry = d_alloc_name(dir, s);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinode->i_fop = &sel_initcon_ops;\n\t\tinode->i_ino = i|SEL_INITCON_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}\n\nstatic inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}\n\nstatic inline u16 sel_ino_to_class(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\n}\n\nstatic inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\n{\n\treturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\n}\n\nstatic inline u32 sel_ino_to_perm(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\n}\n\nstatic ssize_t sel_read_class(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = scnprintf(res, sizeof(res), \"%d\", sel_ino_to_class(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}\n\nstatic const struct file_operations sel_class_ops = {\n\t.read\t\t= sel_read_class,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_read_perm(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = scnprintf(res, sizeof(res), \"%d\", sel_ino_to_perm(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}\n\nstatic const struct file_operations sel_perm_ops = {\n\t.read\t\t= sel_read_perm,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t sel_read_policycap(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint value;\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tunsigned long i_ino = file_inode(file)->i_ino;\n\n\tvalue = security_policycap_supported(i_ino & SEL_INO_MASK);\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", value);\n\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations sel_policycap_ops = {\n\t.read\t\t= sel_read_policycap,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_perm_files(struct selinux_policy *newpolicy,\n\t\t\tchar *objclass, int classvalue,\n\t\t\tstruct dentry *dir)\n{\n\tu32 i, nperms;\n\tint rc;\n\tchar **perms;\n\n\trc = security_get_permissions(newpolicy, objclass, &perms, &nperms);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nperms; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\trc = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, perms[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_fop = &sel_perm_ops;\n\t\t \n\t\tinode->i_ino = sel_perm_to_ino(classvalue, i + 1);\n\t\td_add(dentry, inode);\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nperms; i++)\n\t\tkfree(perms[i]);\n\tkfree(perms);\n\treturn rc;\n}\n\nstatic int sel_make_class_dir_entries(struct selinux_policy *newpolicy,\n\t\t\t\tchar *classname, int index,\n\t\t\t\tstruct dentry *dir)\n{\n\tstruct super_block *sb = dir->d_sb;\n\tstruct selinux_fs_info *fsi = sb->s_fs_info;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tdentry = d_alloc_name(dir, \"index\");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, \"perms\", &fsi->last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\treturn sel_make_perm_files(newpolicy, classname, index, dentry);\n}\n\nstatic int sel_make_classes(struct selinux_policy *newpolicy,\n\t\t\t    struct dentry *class_dir,\n\t\t\t    unsigned long *last_class_ino)\n{\n\tu32 i, nclasses;\n\tint rc;\n\tchar **classes;\n\n\trc = security_get_classes(newpolicy, &classes, &nclasses);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\t*last_class_ino = sel_class_to_ino(nclasses + 2);\n\n\tfor (i = 0; i < nclasses; i++) {\n\t\tstruct dentry *class_name_dir;\n\n\t\tclass_name_dir = sel_make_dir(class_dir, classes[i],\n\t\t\t\t\t      last_class_ino);\n\t\tif (IS_ERR(class_name_dir)) {\n\t\t\trc = PTR_ERR(class_name_dir);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trc = sel_make_class_dir_entries(newpolicy, classes[i], i + 1,\n\t\t\t\tclass_name_dir);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nclasses; i++)\n\t\tkfree(classes[i]);\n\tkfree(classes);\n\treturn rc;\n}\n\nstatic int sel_make_policycap(struct selinux_fs_info *fsi)\n{\n\tunsigned int iter;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tfor (iter = 0; iter <= POLICYDB_CAP_MAX; iter++) {\n\t\tif (iter < ARRAY_SIZE(selinux_policycap_names))\n\t\t\tdentry = d_alloc_name(fsi->policycap_dir,\n\t\t\t\t\t      selinux_policycap_names[iter]);\n\t\telse\n\t\t\tdentry = d_alloc_name(fsi->policycap_dir, \"unknown\");\n\n\t\tif (dentry == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(fsi->sb, S_IFREG | 0444);\n\t\tif (inode == NULL) {\n\t\t\tdput(dentry);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinode->i_fop = &sel_policycap_ops;\n\t\tinode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t \n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t \n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}\n\nstatic struct dentry *sel_make_disconnected_dir(struct super_block *sb,\n\t\t\t\t\t\tunsigned long *ino)\n{\n\tstruct inode *inode = sel_make_inode(sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t \n\tinc_nlink(inode);\n\treturn d_obtain_alias(inode);\n}\n\n#define NULL_FILE_NAME \"null\"\n\nstatic int sel_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct selinux_fs_info *fsi;\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct inode_security_struct *isec;\n\n\tstatic const struct tree_descr selinux_files[] = {\n\t\t[SEL_LOAD] = {\"load\", &sel_load_ops, S_IRUSR|S_IWUSR},\n\t\t[SEL_ENFORCE] = {\"enforce\", &sel_enforce_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_CONTEXT] = {\"context\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_ACCESS] = {\"access\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CREATE] = {\"create\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_RELABEL] = {\"relabel\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_USER] = {\"user\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_POLICYVERS] = {\"policyvers\", &sel_policyvers_ops, S_IRUGO},\n\t\t[SEL_COMMIT_BOOLS] = {\"commit_pending_bools\", &sel_commit_bools_ops, S_IWUSR},\n\t\t[SEL_MLS] = {\"mls\", &sel_mls_ops, S_IRUGO},\n\t\t[SEL_DISABLE] = {\"disable\", &sel_disable_ops, S_IWUSR},\n\t\t[SEL_MEMBER] = {\"member\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CHECKREQPROT] = {\"checkreqprot\", &sel_checkreqprot_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_REJECT_UNKNOWN] = {\"reject_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_DENY_UNKNOWN] = {\"deny_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_STATUS] = {\"status\", &sel_handle_status_ops, S_IRUGO},\n\t\t[SEL_POLICY] = {\"policy\", &sel_policy_ops, S_IRUGO},\n\t\t[SEL_VALIDATE_TRANS] = {\"validatetrans\", &sel_transition_ops,\n\t\t\t\t\tS_IWUGO},\n\t\t  {\"\"}\n\t};\n\n\tret = selinux_fs_info_create(sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = simple_fill_super(sb, SELINUX_MAGIC, selinux_files);\n\tif (ret)\n\t\tgoto err;\n\n\tfsi = sb->s_fs_info;\n\tfsi->bool_dir = sel_make_dir(sb->s_root, BOOL_DIR_NAME, &fsi->last_ino);\n\tif (IS_ERR(fsi->bool_dir)) {\n\t\tret = PTR_ERR(fsi->bool_dir);\n\t\tfsi->bool_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tret = -ENOMEM;\n\tdentry = d_alloc_name(sb->s_root, NULL_FILE_NAME);\n\tif (!dentry)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tinode = sel_make_inode(sb, S_IFCHR | S_IRUGO | S_IWUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\tgoto err;\n\t}\n\n\tinode->i_ino = ++fsi->last_ino;\n\tisec = selinux_inode(inode);\n\tisec->sid = SECINITSID_DEVNULL;\n\tisec->sclass = SECCLASS_CHR_FILE;\n\tisec->initialized = LABEL_INITIALIZED;\n\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR, 3));\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(sb->s_root, \"avc\", &fsi->last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_avc_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tdentry = sel_make_dir(sb->s_root, \"ss\", &fsi->last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_ss_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tdentry = sel_make_dir(sb->s_root, \"initial_contexts\", &fsi->last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_initcon_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tfsi->class_dir = sel_make_dir(sb->s_root, CLASS_DIR_NAME, &fsi->last_ino);\n\tif (IS_ERR(fsi->class_dir)) {\n\t\tret = PTR_ERR(fsi->class_dir);\n\t\tfsi->class_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tfsi->policycap_dir = sel_make_dir(sb->s_root, POLICYCAP_DIR_NAME,\n\t\t\t\t\t  &fsi->last_ino);\n\tif (IS_ERR(fsi->policycap_dir)) {\n\t\tret = PTR_ERR(fsi->policycap_dir);\n\t\tfsi->policycap_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tret = sel_make_policycap(fsi);\n\tif (ret) {\n\t\tpr_err(\"SELinux: failed to load policy capabilities\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tpr_err(\"SELinux: %s:  failed while creating inodes\\n\",\n\t\t__func__);\n\n\tselinux_fs_info_free(sb);\n\n\treturn ret;\n}\n\nstatic int sel_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, sel_fill_super);\n}\n\nstatic const struct fs_context_operations sel_context_ops = {\n\t.get_tree\t= sel_get_tree,\n};\n\nstatic int sel_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &sel_context_ops;\n\treturn 0;\n}\n\nstatic void sel_kill_sb(struct super_block *sb)\n{\n\tselinux_fs_info_free(sb);\n\tkill_litter_super(sb);\n}\n\nstatic struct file_system_type sel_fs_type = {\n\t.name\t\t= \"selinuxfs\",\n\t.init_fs_context = sel_init_fs_context,\n\t.kill_sb\t= sel_kill_sb,\n};\n\nstatic struct vfsmount *selinuxfs_mount __ro_after_init;\nstruct path selinux_null __ro_after_init;\n\nstatic int __init init_sel_fs(void)\n{\n\tstruct qstr null_name = QSTR_INIT(NULL_FILE_NAME,\n\t\t\t\t\t  sizeof(NULL_FILE_NAME)-1);\n\tint err;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\terr = sysfs_create_mount_point(fs_kobj, \"selinux\");\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&sel_fs_type);\n\tif (err) {\n\t\tsysfs_remove_mount_point(fs_kobj, \"selinux\");\n\t\treturn err;\n\t}\n\n\tselinux_null.mnt = selinuxfs_mount = kern_mount(&sel_fs_type);\n\tif (IS_ERR(selinuxfs_mount)) {\n\t\tpr_err(\"selinuxfs:  could not mount!\\n\");\n\t\terr = PTR_ERR(selinuxfs_mount);\n\t\tselinuxfs_mount = NULL;\n\t}\n\tselinux_null.dentry = d_hash_and_lookup(selinux_null.mnt->mnt_root,\n\t\t\t\t\t\t&null_name);\n\tif (IS_ERR(selinux_null.dentry)) {\n\t\tpr_err(\"selinuxfs:  could not lookup null!\\n\");\n\t\terr = PTR_ERR(selinux_null.dentry);\n\t\tselinux_null.dentry = NULL;\n\t}\n\n\treturn err;\n}\n\n__initcall(init_sel_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}