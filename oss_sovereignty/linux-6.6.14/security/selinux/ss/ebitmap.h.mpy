{
  "module_name": "ebitmap.h",
  "hash_id": "a227d40bfe6098881a6864fd9946fe1193a0d8c9db414239046095bdf3ba4739",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/ebitmap.h",
  "human_readable_source": " \n \n#ifndef _SS_EBITMAP_H_\n#define _SS_EBITMAP_H_\n\n#include <net/netlabel.h>\n\n#ifdef CONFIG_64BIT\n#define\tEBITMAP_NODE_SIZE\t64\n#else\n#define\tEBITMAP_NODE_SIZE\t32\n#endif\n\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n#define EBITMAP_UNIT_SIZE\tBITS_PER_LONG\n#define EBITMAP_SIZE\t\t(EBITMAP_UNIT_NUMS * EBITMAP_UNIT_SIZE)\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_SHIFT_UNIT_SIZE(x)\t\t\t\t\t\\\n\t(((x) >> EBITMAP_UNIT_SIZE / 2) >> EBITMAP_UNIT_SIZE / 2)\n\nstruct ebitmap_node {\n\tstruct ebitmap_node *next;\n\tunsigned long maps[EBITMAP_UNIT_NUMS];\n\tu32 startbit;\n};\n\nstruct ebitmap {\n\tstruct ebitmap_node *node;\t \n\tu32 highbit;\t \n};\n\n#define ebitmap_length(e) ((e)->highbit)\n\nstatic inline unsigned int ebitmap_start_positive(const struct ebitmap *e,\n\t\t\t\t\t\t  struct ebitmap_node **n)\n{\n\tunsigned int ofs;\n\n\tfor (*n = e->node; *n; *n = (*n)->next) {\n\t\tofs = find_first_bit((*n)->maps, EBITMAP_SIZE);\n\t\tif (ofs < EBITMAP_SIZE)\n\t\t\treturn (*n)->startbit + ofs;\n\t}\n\treturn ebitmap_length(e);\n}\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}\n\nstatic inline unsigned int ebitmap_next_positive(const struct ebitmap *e,\n\t\t\t\t\t\t struct ebitmap_node **n,\n\t\t\t\t\t\t unsigned int bit)\n{\n\tunsigned int ofs;\n\n\tofs = find_next_bit((*n)->maps, EBITMAP_SIZE, bit - (*n)->startbit + 1);\n\tif (ofs < EBITMAP_SIZE)\n\t\treturn ofs + (*n)->startbit;\n\n\tfor (*n = (*n)->next; *n; *n = (*n)->next) {\n\t\tofs = find_first_bit((*n)->maps, EBITMAP_SIZE);\n\t\tif (ofs < EBITMAP_SIZE)\n\t\t\treturn ofs + (*n)->startbit;\n\t}\n\treturn ebitmap_length(e);\n}\n\n#define EBITMAP_NODE_INDEX(node, bit)\t\\\n\t(((bit) - (node)->startbit) / EBITMAP_UNIT_SIZE)\n#define EBITMAP_NODE_OFFSET(node, bit)\t\\\n\t(((bit) - (node)->startbit) % EBITMAP_UNIT_SIZE)\n\nstatic inline int ebitmap_node_get_bit(const struct ebitmap_node *n,\n\t\t\t\t       unsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tif ((n->maps[index] & (EBITMAP_BIT << ofs)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}\n\nstatic inline void ebitmap_node_clr_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] &= ~(EBITMAP_BIT << ofs);\n}\n\n#define ebitmap_for_each_positive_bit(e, n, bit)\t\\\n\tfor ((bit) = ebitmap_start_positive(e, &(n));\t\\\n\t     (bit) < ebitmap_length(e);\t\t\t\\\n\t     (bit) = ebitmap_next_positive(e, &(n), bit))\t\\\n\nint ebitmap_cmp(const struct ebitmap *e1, const struct ebitmap *e2);\nint ebitmap_cpy(struct ebitmap *dst, const struct ebitmap *src);\nint ebitmap_and(struct ebitmap *dst, const struct ebitmap *e1, const struct ebitmap *e2);\nint ebitmap_contains(const struct ebitmap *e1, const struct ebitmap *e2, u32 last_e2bit);\nint ebitmap_get_bit(const struct ebitmap *e, unsigned long bit);\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value);\nvoid ebitmap_destroy(struct ebitmap *e);\nint ebitmap_read(struct ebitmap *e, void *fp);\nint ebitmap_write(const struct ebitmap *e, void *fp);\nu32 ebitmap_hash(const struct ebitmap *e, u32 hash);\n\n#ifdef CONFIG_NETLABEL\nint ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap);\nint ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap);\n#else\nstatic inline int ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t\t\tstruct netlbl_lsm_catmap **catmap)\n{\n\treturn -ENOMEM;\n}\nstatic inline int ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t\t\tstruct netlbl_lsm_catmap *catmap)\n{\n\treturn -ENOMEM;\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}