{
  "module_name": "context.h",
  "hash_id": "9a9c82fde176304630236984b0c283f30115cee818b8840ec2de40b7700201c9",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/context.h",
  "human_readable_source": " \n \n#ifndef _SS_CONTEXT_H_\n#define _SS_CONTEXT_H_\n\n#include \"ebitmap.h\"\n#include \"mls_types.h\"\n#include \"security.h\"\n\n \nstruct context {\n\tu32 user;\n\tu32 role;\n\tu32 type;\n\tu32 len;         \n\tstruct mls_range range;\n\tchar *str;\t \n};\n\nstatic inline void mls_context_init(struct context *c)\n{\n\tmemset(&c->range, 0, sizeof(c->range));\n}\n\nstatic inline int mls_context_cpy(struct context *dst, const struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}\n\n \nstatic inline int mls_context_cpy_low(struct context *dst, const struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}\n\n \nstatic inline int mls_context_cpy_high(struct context *dst, const struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}\n\n\nstatic inline int mls_context_glblub(struct context *dst,\n\t\t\t\t     const struct context *c1, const struct context *c2)\n{\n\tstruct mls_range *dr = &dst->range;\n\tconst struct mls_range *r1 = &c1->range, *r2 = &c2->range;\n\tint rc = 0;\n\n\tif (r1->level[1].sens < r2->level[0].sens ||\n\t    r2->level[1].sens < r1->level[0].sens)\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tdr->level[0].sens = max(r1->level[0].sens, r2->level[0].sens);\n\n\t \n\tdr->level[1].sens = min(r1->level[1].sens, r2->level[1].sens);\n\n\trc = ebitmap_and(&dr->level[0].cat,\n\t\t\t &r1->level[0].cat, &r2->level[0].cat);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ebitmap_and(&dr->level[1].cat,\n\t\t\t &r1->level[1].cat, &r2->level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\nout:\n\treturn rc;\n}\n\nstatic inline int mls_context_cmp(const struct context *c1, const struct context *c2)\n{\n\treturn ((c1->range.level[0].sens == c2->range.level[0].sens) &&\n\t\tebitmap_cmp(&c1->range.level[0].cat, &c2->range.level[0].cat) &&\n\t\t(c1->range.level[1].sens == c2->range.level[1].sens) &&\n\t\tebitmap_cmp(&c1->range.level[1].cat, &c2->range.level[1].cat));\n}\n\nstatic inline void mls_context_destroy(struct context *c)\n{\n\tebitmap_destroy(&c->range.level[0].cat);\n\tebitmap_destroy(&c->range.level[1].cat);\n\tmls_context_init(c);\n}\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}\n\nstatic inline int context_cpy(struct context *dst, const struct context *src)\n{\n\tint rc;\n\n\tdst->user = src->user;\n\tdst->role = src->role;\n\tdst->type = src->type;\n\tif (src->str) {\n\t\tdst->str = kstrdup(src->str, GFP_ATOMIC);\n\t\tif (!dst->str)\n\t\t\treturn -ENOMEM;\n\t\tdst->len = src->len;\n\t} else {\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t}\n\trc = mls_context_cpy(dst, src);\n\tif (rc) {\n\t\tkfree(dst->str);\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}\n\nstatic inline int context_cmp(const struct context *c1, const struct context *c2)\n{\n\tif (c1->len && c2->len)\n\t\treturn (c1->len == c2->len && !strcmp(c1->str, c2->str));\n\tif (c1->len || c2->len)\n\t\treturn 0;\n\treturn ((c1->user == c2->user) &&\n\t\t(c1->role == c2->role) &&\n\t\t(c1->type == c2->type) &&\n\t\tmls_context_cmp(c1, c2));\n}\n\nu32 context_compute_hash(const struct context *c);\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}