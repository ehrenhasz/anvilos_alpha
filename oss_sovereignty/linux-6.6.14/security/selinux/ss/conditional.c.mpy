{
  "module_name": "conditional.c",
  "hash_id": "25742341b18c070fa23efa73241e3eb2ac1c4550394721ff57a4099f9ef79aee",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/conditional.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include \"security.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n\n \nstatic int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\n{\n\tu32 i;\n\tint s[COND_EXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tif (expr->len == 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < expr->len; i++) {\n\t\tstruct cond_expr_node *node = &expr->nodes[i];\n\n\t\tswitch (node->expr_type) {\n\t\tcase COND_BOOL:\n\t\t\tif (sp == (COND_EXPR_MAXDEPTH - 1))\n\t\t\t\treturn -1;\n\t\t\tsp++;\n\t\t\ts[sp] = p->bool_val_to_struct[node->boolean - 1]->state;\n\t\t\tbreak;\n\t\tcase COND_NOT:\n\t\t\tif (sp < 0)\n\t\t\t\treturn -1;\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase COND_OR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_AND:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_XOR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] ^= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_EQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] == s[sp + 1]);\n\t\t\tbreak;\n\t\tcase COND_NEQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] != s[sp + 1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn s[0];\n}\n\n \nstatic void evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tstruct avtab_node *avnode;\n\tint new_state;\n\tu32 i;\n\n\tnew_state = cond_evaluate_expr(p, &node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tpr_err(\"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t \n\t\tfor (i = 0; i < node->true_list.len; i++) {\n\t\t\tavnode = node->true_list.nodes[i];\n\t\t\tif (new_state <= 0)\n\t\t\t\tavnode->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tavnode->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (i = 0; i < node->false_list.len; i++) {\n\t\t\tavnode = node->false_list.nodes[i];\n\t\t\t \n\t\t\tif (new_state)\n\t\t\t\tavnode->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tavnode->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n}\n\nvoid evaluate_cond_nodes(struct policydb *p)\n{\n\tu32 i;\n\n\tfor (i = 0; i < p->cond_list_len; i++)\n\t\tevaluate_cond_node(p, &p->cond_list[i]);\n}\n\nvoid cond_policydb_init(struct policydb *p)\n{\n\tp->bool_val_to_struct = NULL;\n\tp->cond_list = NULL;\n\tp->cond_list_len = 0;\n\n\tavtab_init(&p->te_cond_avtab);\n}\n\nstatic void cond_node_destroy(struct cond_node *node)\n{\n\tkfree(node->expr.nodes);\n\t \n\tkfree(node->true_list.nodes);\n\tkfree(node->false_list.nodes);\n}\n\nstatic void cond_list_destroy(struct policydb *p)\n{\n\tu32 i;\n\n\tfor (i = 0; i < p->cond_list_len; i++)\n\t\tcond_node_destroy(&p->cond_list[i]);\n\tkfree(p->cond_list);\n\tp->cond_list = NULL;\n\tp->cond_list_len = 0;\n}\n\nvoid cond_policydb_destroy(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tavtab_destroy(&p->te_cond_avtab);\n\tcond_list_destroy(p);\n}\n\nint cond_init_bool_indexes(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tp->bool_val_to_struct = kmalloc_array(p->p_bools.nprim,\n\t\t\t\t\t      sizeof(*p->bool_val_to_struct),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!p->bool_val_to_struct)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint cond_destroy_bool(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}\n\nint cond_index_bool(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cond_bool_datum *booldatum;\n\n\tbooldatum = datum;\n\tp = datap;\n\n\tif (!booldatum->value || booldatum->value > p->p_bools.nprim)\n\t\treturn -EINVAL;\n\n\tp->sym_val_to_name[SYM_BOOLS][booldatum->value - 1] = key;\n\tp->bool_val_to_struct[booldatum->value - 1] = booldatum;\n\n\treturn 0;\n}\n\nstatic int bool_isvalid(struct cond_bool_datum *b)\n{\n\tif (!(b->state == 0 || b->state == 1))\n\t\treturn 0;\n\treturn 1;\n}\n\nint cond_read_bool(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cond_bool_datum *booldatum;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tbooldatum = kzalloc(sizeof(*booldatum), GFP_KERNEL);\n\tif (!booldatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof(buf));\n\tif (rc)\n\t\tgoto err;\n\n\tbooldatum->value = le32_to_cpu(buf[0]);\n\tbooldatum->state = le32_to_cpu(buf[1]);\n\n\trc = -EINVAL;\n\tif (!bool_isvalid(booldatum))\n\t\tgoto err;\n\n\tlen = le32_to_cpu(buf[2]);\n\tif (((len == 0) || (len == (u32)-1)))\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tkey = kmalloc(len + 1, GFP_KERNEL);\n\tif (!key)\n\t\tgoto err;\n\trc = next_entry(key, fp, len);\n\tif (rc)\n\t\tgoto err;\n\tkey[len] = '\\0';\n\trc = symtab_insert(s, key, booldatum);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tcond_destroy_bool(key, booldatum, NULL);\n\treturn rc;\n}\n\nstruct cond_insertf_data {\n\tstruct policydb *p;\n\tstruct avtab_node **dst;\n\tstruct cond_av_list *other;\n};\n\nstatic int cond_insertf(struct avtab *a, const struct avtab_key *k,\n\t\t\tconst struct avtab_datum *d, void *ptr)\n{\n\tstruct cond_insertf_data *data = ptr;\n\tstruct policydb *p = data->p;\n\tstruct cond_av_list *other = data->other;\n\tstruct avtab_node *node_ptr;\n\tu32 i;\n\tbool found;\n\n\t \n\tif (k->specified & AVTAB_TYPE) {\n\t\tif (avtab_search_node(&p->te_avtab, k)) {\n\t\t\tpr_err(\"SELinux: type rule already exists outside of a conditional.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (other) {\n\t\t\tnode_ptr = avtab_search_node(&p->te_cond_avtab, k);\n\t\t\tif (node_ptr) {\n\t\t\t\tif (avtab_search_node_next(node_ptr, k->specified)) {\n\t\t\t\t\tpr_err(\"SELinux: too many conflicting type rules.\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t\tfor (i = 0; i < other->len; i++) {\n\t\t\t\t\tif (other->nodes[i] == node_ptr) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tpr_err(\"SELinux: conflicting type rules.\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (avtab_search_node(&p->te_cond_avtab, k)) {\n\t\t\t\tpr_err(\"SELinux: conflicting type rules when adding type rule for true.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tnode_ptr = avtab_insert_nonunique(&p->te_cond_avtab, k, d);\n\tif (!node_ptr) {\n\t\tpr_err(\"SELinux: could not insert rule.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*data->dst = node_ptr;\n\treturn 0;\n}\n\nstatic int cond_read_av_list(struct policydb *p, void *fp,\n\t\t\t     struct cond_av_list *list,\n\t\t\t     struct cond_av_list *other)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 i, len;\n\tstruct cond_insertf_data data;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\tif (len == 0)\n\t\treturn 0;\n\n\tlist->nodes = kcalloc(len, sizeof(*list->nodes), GFP_KERNEL);\n\tif (!list->nodes)\n\t\treturn -ENOMEM;\n\n\tdata.p = p;\n\tdata.other = other;\n\tfor (i = 0; i < len; i++) {\n\t\tdata.dst = &list->nodes[i];\n\t\trc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\n\t\t\t\t     &data);\n\t\tif (rc) {\n\t\t\tkfree(list->nodes);\n\t\t\tlist->nodes = NULL;\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tlist->len = len;\n\treturn 0;\n}\n\nstatic int expr_node_isvalid(struct policydb *p, struct cond_expr_node *expr)\n{\n\tif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\n\t\tpr_err(\"SELinux: conditional expressions uses unknown operator.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (expr->boolean > p->p_bools.nprim) {\n\t\tpr_err(\"SELinux: conditional expressions uses unknown bool.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\n{\n\t__le32 buf[2];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\treturn rc;\n\n\tnode->cur_state = le32_to_cpu(buf[0]);\n\n\t \n\tlen = le32_to_cpu(buf[1]);\n\tnode->expr.nodes = kcalloc(len, sizeof(*node->expr.nodes), GFP_KERNEL);\n\tif (!node->expr.nodes)\n\t\treturn -ENOMEM;\n\n\tnode->expr.len = len;\n\n\tfor (i = 0; i < len; i++) {\n\t\tstruct cond_expr_node *expr = &node->expr.nodes[i];\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\texpr->expr_type = le32_to_cpu(buf[0]);\n\t\texpr->boolean = le32_to_cpu(buf[1]);\n\n\t\tif (!expr_node_isvalid(p, expr))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = cond_read_av_list(p, fp, &node->true_list, NULL);\n\tif (rc)\n\t\treturn rc;\n\treturn cond_read_av_list(p, fp, &node->false_list, &node->true_list);\n}\n\nint cond_read_list(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(buf));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\n\tp->cond_list = kcalloc(len, sizeof(*p->cond_list), GFP_KERNEL);\n\tif (!p->cond_list)\n\t\treturn -ENOMEM;\n\n\trc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\n\tif (rc)\n\t\tgoto err;\n\n\tp->cond_list_len = len;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = cond_read_node(p, &p->cond_list[i], fp);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tcond_list_destroy(p);\n\treturn rc;\n}\n\nint cond_write_bool(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cond_bool_datum *booldatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(booldatum->value);\n\tbuf[1] = cpu_to_le32(booldatum->state);\n\tbuf[2] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}\n\n \nstatic int cond_write_av_list(struct policydb *p,\n\t\t\t      struct cond_av_list *list, struct policy_file *fp)\n{\n\t__le32 buf[1];\n\tu32 i;\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(list->len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < list->len; i++) {\n\t\trc = avtab_write_item(p, list->nodes[i], fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int cond_write_node(struct policydb *p, struct cond_node *node,\n\t\t    struct policy_file *fp)\n{\n\t__le32 buf[2];\n\tint rc;\n\tu32 i;\n\n\tbuf[0] = cpu_to_le32(node->cur_state);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(node->expr.len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < node->expr.len; i++) {\n\t\tbuf[0] = cpu_to_le32(node->expr.nodes[i].expr_type);\n\t\tbuf[1] = cpu_to_le32(node->expr.nodes[i].boolean);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = cond_write_av_list(p, &node->true_list, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = cond_write_av_list(p, &node->false_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nint cond_write_list(struct policydb *p, void *fp)\n{\n\tu32 i;\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(p->cond_list_len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->cond_list_len; i++) {\n\t\trc = cond_write_node(p, &p->cond_list[i], fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nvoid cond_compute_xperms(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct extended_perms_decision *xpermd)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !xpermd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif (node->key.specified & AVTAB_ENABLED)\n\t\t\tservices_compute_xperms_decision(xpermd, node);\n\t}\n}\n \nvoid cond_compute_av(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct av_decision *avd, struct extended_perms *xperms)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !avd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\n\t\t\tavd->allowed |= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\n\t\t\t \n\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\n\t\t\tavd->auditallow |= node->datum.u.data;\n\t\tif (xperms && (node->key.specified & AVTAB_ENABLED) &&\n\t\t\t\t(node->key.specified & AVTAB_XPERMS))\n\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t}\n}\n\nstatic int cond_dup_av_list(struct cond_av_list *new,\n\t\t\tstruct cond_av_list *orig,\n\t\t\tstruct avtab *avtab)\n{\n\tu32 i;\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->nodes = kcalloc(orig->len, sizeof(*new->nodes), GFP_KERNEL);\n\tif (!new->nodes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < orig->len; i++) {\n\t\tnew->nodes[i] = avtab_insert_nonunique(avtab,\n\t\t\t\t\t\t       &orig->nodes[i]->key,\n\t\t\t\t\t\t       &orig->nodes[i]->datum);\n\t\tif (!new->nodes[i])\n\t\t\treturn -ENOMEM;\n\t\tnew->len++;\n\t}\n\n\treturn 0;\n}\n\nstatic int duplicate_policydb_cond_list(struct policydb *newp,\n\t\t\t\t\tstruct policydb *origp)\n{\n\tint rc;\n\tu32 i;\n\n\trc = avtab_alloc_dup(&newp->te_cond_avtab, &origp->te_cond_avtab);\n\tif (rc)\n\t\treturn rc;\n\n\tnewp->cond_list_len = 0;\n\tnewp->cond_list = kcalloc(origp->cond_list_len,\n\t\t\t\tsizeof(*newp->cond_list),\n\t\t\t\tGFP_KERNEL);\n\tif (!newp->cond_list)\n\t\tgoto error;\n\n\tfor (i = 0; i < origp->cond_list_len; i++) {\n\t\tstruct cond_node *newn = &newp->cond_list[i];\n\t\tstruct cond_node *orign = &origp->cond_list[i];\n\n\t\tnewp->cond_list_len++;\n\n\t\tnewn->cur_state = orign->cur_state;\n\t\tnewn->expr.nodes = kmemdup(orign->expr.nodes,\n\t\t\t\torign->expr.len * sizeof(*orign->expr.nodes),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!newn->expr.nodes)\n\t\t\tgoto error;\n\n\t\tnewn->expr.len = orign->expr.len;\n\n\t\trc = cond_dup_av_list(&newn->true_list, &orign->true_list,\n\t\t\t\t&newp->te_cond_avtab);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trc = cond_dup_av_list(&newn->false_list, &orign->false_list,\n\t\t\t\t&newp->te_cond_avtab);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tavtab_destroy(&newp->te_cond_avtab);\n\tcond_list_destroy(newp);\n\treturn -ENOMEM;\n}\n\nstatic int cond_bools_destroy(void *key, void *datum, void *args)\n{\n\t \n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int cond_bools_copy(struct hashtab_node *new, struct hashtab_node *orig, void *args)\n{\n\tstruct cond_bool_datum *datum;\n\n\tdatum = kmemdup(orig->datum, sizeof(struct cond_bool_datum),\n\t\t\tGFP_KERNEL);\n\tif (!datum)\n\t\treturn -ENOMEM;\n\n\tnew->key = orig->key;  \n\tnew->datum = datum;\n\treturn 0;\n}\n\nstatic int cond_bools_index(void *key, void *datum, void *args)\n{\n\tstruct cond_bool_datum *booldatum, **cond_bool_array;\n\n\tbooldatum = datum;\n\tcond_bool_array = args;\n\tcond_bool_array[booldatum->value - 1] = booldatum;\n\n\treturn 0;\n}\n\nstatic int duplicate_policydb_bools(struct policydb *newdb,\n\t\t\t\tstruct policydb *orig)\n{\n\tstruct cond_bool_datum **cond_bool_array;\n\tint rc;\n\n\tcond_bool_array = kmalloc_array(orig->p_bools.nprim,\n\t\t\t\t\tsizeof(*orig->bool_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!cond_bool_array)\n\t\treturn -ENOMEM;\n\n\trc = hashtab_duplicate(&newdb->p_bools.table, &orig->p_bools.table,\n\t\t\tcond_bools_copy, cond_bools_destroy, NULL);\n\tif (rc) {\n\t\tkfree(cond_bool_array);\n\t\treturn -ENOMEM;\n\t}\n\n\thashtab_map(&newdb->p_bools.table, cond_bools_index, cond_bool_array);\n\tnewdb->bool_val_to_struct = cond_bool_array;\n\n\tnewdb->p_bools.nprim = orig->p_bools.nprim;\n\n\treturn 0;\n}\n\nvoid cond_policydb_destroy_dup(struct policydb *p)\n{\n\thashtab_map(&p->p_bools.table, cond_bools_destroy, NULL);\n\thashtab_destroy(&p->p_bools.table);\n\tcond_policydb_destroy(p);\n}\n\nint cond_policydb_dup(struct policydb *new, struct policydb *orig)\n{\n\tcond_policydb_init(new);\n\n\tif (duplicate_policydb_bools(new, orig))\n\t\treturn -ENOMEM;\n\n\tif (duplicate_policydb_cond_list(new, orig)) {\n\t\tcond_policydb_destroy_dup(new);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}