{
  "module_name": "sidtab.c",
  "hash_id": "e2200a39ad4556ce50936d90bf707fee584cba43f064fdd88e362bdcd6c75835",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/sidtab.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <asm/barrier.h>\n#include \"flask.h\"\n#include \"security.h\"\n#include \"sidtab.h\"\n#include \"services.h\"\n\nstruct sidtab_str_cache {\n\tstruct rcu_head rcu_member;\n\tstruct list_head lru_member;\n\tstruct sidtab_entry *parent;\n\tu32 len;\n\tchar str[];\n};\n\n#define index_to_sid(index) ((index) + SECINITSID_NUM + 1)\n#define sid_to_index(sid) ((sid) - (SECINITSID_NUM + 1))\n\nint sidtab_init(struct sidtab *s)\n{\n\tu32 i;\n\n\tmemset(s->roots, 0, sizeof(s->roots));\n\n\tfor (i = 0; i < SECINITSID_NUM; i++)\n\t\ts->isids[i].set = 0;\n\n\ts->frozen = false;\n\ts->count = 0;\n\ts->convert = NULL;\n\thash_init(s->context_to_sid);\n\n\tspin_lock_init(&s->lock);\n\n#if CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0\n\ts->cache_free_slots = CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE;\n\tINIT_LIST_HEAD(&s->cache_lru_list);\n\tspin_lock_init(&s->cache_lock);\n#endif\n\n\treturn 0;\n}\n\nstatic u32 context_to_sid(struct sidtab *s, struct context *context, u32 hash)\n{\n\tstruct sidtab_entry *entry;\n\tu32 sid = 0;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(s->context_to_sid, entry, list, hash) {\n\t\tif (entry->hash != hash)\n\t\t\tcontinue;\n\t\tif (context_cmp(&entry->context, context)) {\n\t\t\tsid = entry->sid;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn sid;\n}\n\nint sidtab_set_initial(struct sidtab *s, u32 sid, struct context *context)\n{\n\tstruct sidtab_isid_entry *isid;\n\tu32 hash;\n\tint rc;\n\n\tif (sid == 0 || sid > SECINITSID_NUM)\n\t\treturn -EINVAL;\n\n\tisid = &s->isids[sid - 1];\n\n\trc = context_cpy(&isid->entry.context, context);\n\tif (rc)\n\t\treturn rc;\n\n#if CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0\n\tisid->entry.cache = NULL;\n#endif\n\tisid->set = 1;\n\n\thash = context_compute_hash(context);\n\n\t \n\tif (!context_to_sid(s, context, hash)) {\n\t\tisid->entry.sid = sid;\n\t\tisid->entry.hash = hash;\n\t\thash_add(s->context_to_sid, &isid->entry.list, hash);\n\t}\n\n\treturn 0;\n}\n\nint sidtab_hash_stats(struct sidtab *sidtab, char *page)\n{\n\tint i;\n\tint chain_len = 0;\n\tint slots_used = 0;\n\tint entries = 0;\n\tint max_chain_len = 0;\n\tint cur_bucket = 0;\n\tstruct sidtab_entry *entry;\n\n\trcu_read_lock();\n\thash_for_each_rcu(sidtab->context_to_sid, i, entry, list) {\n\t\tentries++;\n\t\tif (i == cur_bucket) {\n\t\t\tchain_len++;\n\t\t\tif (chain_len == 1)\n\t\t\t\tslots_used++;\n\t\t} else {\n\t\t\tcur_bucket = i;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain_len = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (chain_len > max_chain_len)\n\t\tmax_chain_len = chain_len;\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\", entries,\n\t\t\t slots_used, SIDTAB_HASH_BUCKETS, max_chain_len);\n}\n\nstatic u32 sidtab_level_from_count(u32 count)\n{\n\tu32 capacity = SIDTAB_LEAF_ENTRIES;\n\tu32 level = 0;\n\n\twhile (count > capacity) {\n\t\tcapacity <<= SIDTAB_INNER_SHIFT;\n\t\t++level;\n\t}\n\treturn level;\n}\n\nstatic int sidtab_alloc_roots(struct sidtab *s, u32 level)\n{\n\tu32 l;\n\n\tif (!s->roots[0].ptr_leaf) {\n\t\ts->roots[0].ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!s->roots[0].ptr_leaf)\n\t\t\treturn -ENOMEM;\n\t}\n\tfor (l = 1; l <= level; ++l)\n\t\tif (!s->roots[l].ptr_inner) {\n\t\t\ts->roots[l].ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!s->roots[l].ptr_inner)\n\t\t\t\treturn -ENOMEM;\n\t\t\ts->roots[l].ptr_inner->entries[0] = s->roots[l - 1];\n\t\t}\n\treturn 0;\n}\n\nstatic struct sidtab_entry *sidtab_do_lookup(struct sidtab *s, u32 index,\n\t\t\t\t\t     int alloc)\n{\n\tunion sidtab_entry_inner *entry;\n\tu32 level, capacity_shift, leaf_index = index / SIDTAB_LEAF_ENTRIES;\n\n\t \n\tlevel = sidtab_level_from_count(index + 1);\n\tcapacity_shift = level * SIDTAB_INNER_SHIFT;\n\n\t \n\tif (alloc && sidtab_alloc_roots(s, level) != 0)\n\t\treturn NULL;\n\n\t \n\tentry = &s->roots[level];\n\twhile (level != 0) {\n\t\tcapacity_shift -= SIDTAB_INNER_SHIFT;\n\t\t--level;\n\n\t\tentry = &entry->ptr_inner->entries[leaf_index >> capacity_shift];\n\t\tleaf_index &= ((u32)1 << capacity_shift) - 1;\n\n\t\tif (!entry->ptr_inner) {\n\t\t\tif (alloc)\n\t\t\t\tentry->ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\tif (!entry->ptr_inner)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (!entry->ptr_leaf) {\n\t\tif (alloc)\n\t\t\tentry->ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t\t  GFP_ATOMIC);\n\t\tif (!entry->ptr_leaf)\n\t\t\treturn NULL;\n\t}\n\treturn &entry->ptr_leaf->entries[index % SIDTAB_LEAF_ENTRIES];\n}\n\nstatic struct sidtab_entry *sidtab_lookup(struct sidtab *s, u32 index)\n{\n\t \n\tu32 count = smp_load_acquire(&s->count);\n\n\tif (index >= count)\n\t\treturn NULL;\n\n\treturn sidtab_do_lookup(s, index, 0);\n}\n\nstatic struct sidtab_entry *sidtab_lookup_initial(struct sidtab *s, u32 sid)\n{\n\treturn s->isids[sid - 1].set ? &s->isids[sid - 1].entry : NULL;\n}\n\nstatic struct sidtab_entry *sidtab_search_core(struct sidtab *s, u32 sid,\n\t\t\t\t\t       int force)\n{\n\tif (sid != 0) {\n\t\tstruct sidtab_entry *entry;\n\n\t\tif (sid > SECINITSID_NUM)\n\t\t\tentry = sidtab_lookup(s, sid_to_index(sid));\n\t\telse\n\t\t\tentry = sidtab_lookup_initial(s, sid);\n\t\tif (entry && (!entry->context.len || force))\n\t\t\treturn entry;\n\t}\n\n\treturn sidtab_lookup_initial(s, SECINITSID_UNLABELED);\n}\n\nstruct sidtab_entry *sidtab_search_entry(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 0);\n}\n\nstruct sidtab_entry *sidtab_search_entry_force(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 1);\n}\n\nint sidtab_context_to_sid(struct sidtab *s, struct context *context,\n\t\t\t  u32 *sid)\n{\n\tunsigned long flags;\n\tu32 count, hash = context_compute_hash(context);\n\tstruct sidtab_convert_params *convert;\n\tstruct sidtab_entry *dst, *dst_convert;\n\tint rc;\n\n\t*sid = context_to_sid(s, context, hash);\n\tif (*sid)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&s->lock, flags);\n\n\trc = 0;\n\t*sid = context_to_sid(s, context, hash);\n\tif (*sid)\n\t\tgoto out_unlock;\n\n\tif (unlikely(s->frozen)) {\n\t\t \n\t\trc = -ESTALE;\n\t\tgoto out_unlock;\n\t}\n\n\tcount = s->count;\n\n\t \n\trc = -EOVERFLOW;\n\tif (count >= SIDTAB_MAX)\n\t\tgoto out_unlock;\n\n\t \n\trc = -ENOMEM;\n\tdst = sidtab_do_lookup(s, count, 1);\n\tif (!dst)\n\t\tgoto out_unlock;\n\n\tdst->sid = index_to_sid(count);\n\tdst->hash = hash;\n\n\trc = context_cpy(&dst->context, context);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\tconvert = s->convert;\n\tif (convert) {\n\t\tstruct sidtab *target = convert->target;\n\n\t\trc = -ENOMEM;\n\t\tdst_convert = sidtab_do_lookup(target, count, 1);\n\t\tif (!dst_convert) {\n\t\t\tcontext_destroy(&dst->context);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\trc = services_convert_context(convert->args,\n\t\t\t\t\t      context, &dst_convert->context,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\tif (rc) {\n\t\t\tcontext_destroy(&dst->context);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tdst_convert->sid = index_to_sid(count);\n\t\tdst_convert->hash = context_compute_hash(&dst_convert->context);\n\t\ttarget->count = count + 1;\n\n\t\thash_add_rcu(target->context_to_sid,\n\t\t\t     &dst_convert->list, dst_convert->hash);\n\t}\n\n\tif (context->len)\n\t\tpr_info(\"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\tcontext->str);\n\n\t*sid = index_to_sid(count);\n\n\t \n\tsmp_store_release(&s->count, count + 1);\n\thash_add_rcu(s->context_to_sid, &dst->list, dst->hash);\n\n\trc = 0;\nout_unlock:\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn rc;\n}\n\nstatic void sidtab_convert_hashtable(struct sidtab *s, u32 count)\n{\n\tstruct sidtab_entry *entry;\n\tu32 i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tentry = sidtab_do_lookup(s, i, 0);\n\t\tentry->sid = index_to_sid(i);\n\t\tentry->hash = context_compute_hash(&entry->context);\n\n\t\thash_add_rcu(s->context_to_sid, &entry->list, entry->hash);\n\t}\n}\n\nstatic int sidtab_convert_tree(union sidtab_entry_inner *edst,\n\t\t\t       union sidtab_entry_inner *esrc,\n\t\t\t       u32 *pos, u32 count, u32 level,\n\t\t\t       struct sidtab_convert_params *convert)\n{\n\tint rc;\n\tu32 i;\n\n\tif (level != 0) {\n\t\tif (!edst->ptr_inner) {\n\t\t\tedst->ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!edst->ptr_inner)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < SIDTAB_INNER_ENTRIES && *pos < count) {\n\t\t\trc = sidtab_convert_tree(&edst->ptr_inner->entries[i],\n\t\t\t\t\t\t &esrc->ptr_inner->entries[i],\n\t\t\t\t\t\t pos, count, level - 1,\n\t\t\t\t\t\t convert);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tif (!edst->ptr_leaf) {\n\t\t\tedst->ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!edst->ptr_leaf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < SIDTAB_LEAF_ENTRIES && *pos < count) {\n\t\t\trc = services_convert_context(convert->args,\n\t\t\t\t\t&esrc->ptr_leaf->entries[i].context,\n\t\t\t\t\t&edst->ptr_leaf->entries[i].context,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\t(*pos)++;\n\t\t\ti++;\n\t\t}\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\nint sidtab_convert(struct sidtab *s, struct sidtab_convert_params *params)\n{\n\tunsigned long flags;\n\tu32 count, level, pos;\n\tint rc;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\t \n\tif (s->convert) {\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tcount = s->count;\n\tlevel = sidtab_level_from_count(count);\n\n\t \n\trc = sidtab_do_lookup(params->target, count - 1, 1) ? 0 : -ENOMEM;\n\tif (rc) {\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\treturn rc;\n\t}\n\n\t \n\tparams->target->count = count;\n\n\t \n\ts->convert = params;\n\n\t \n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\tpr_info(\"SELinux:  Converting %u SID table entries...\\n\", count);\n\n\t \n\tpos = 0;\n\trc = sidtab_convert_tree(&params->target->roots[level],\n\t\t\t\t &s->roots[level], &pos, count, level, params);\n\tif (rc) {\n\t\t \n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\ts->convert = NULL;\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\treturn rc;\n\t}\n\t \n\tspin_lock_irqsave(&s->lock, flags);\n\tsidtab_convert_hashtable(params->target, count);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nvoid sidtab_cancel_convert(struct sidtab *s)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&s->lock, flags);\n\ts->convert = NULL;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nvoid sidtab_freeze_begin(struct sidtab *s, unsigned long *flags) __acquires(&s->lock)\n{\n\tspin_lock_irqsave(&s->lock, *flags);\n\ts->frozen = true;\n\ts->convert = NULL;\n}\nvoid sidtab_freeze_end(struct sidtab *s, unsigned long *flags) __releases(&s->lock)\n{\n\tspin_unlock_irqrestore(&s->lock, *flags);\n}\n\nstatic void sidtab_destroy_entry(struct sidtab_entry *entry)\n{\n\tcontext_destroy(&entry->context);\n#if CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0\n\tkfree(rcu_dereference_raw(entry->cache));\n#endif\n}\n\nstatic void sidtab_destroy_tree(union sidtab_entry_inner entry, u32 level)\n{\n\tu32 i;\n\n\tif (level != 0) {\n\t\tstruct sidtab_node_inner *node = entry.ptr_inner;\n\n\t\tif (!node)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < SIDTAB_INNER_ENTRIES; i++)\n\t\t\tsidtab_destroy_tree(node->entries[i], level - 1);\n\t\tkfree(node);\n\t} else {\n\t\tstruct sidtab_node_leaf *node = entry.ptr_leaf;\n\n\t\tif (!node)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < SIDTAB_LEAF_ENTRIES; i++)\n\t\t\tsidtab_destroy_entry(&node->entries[i]);\n\t\tkfree(node);\n\t}\n}\n\nvoid sidtab_destroy(struct sidtab *s)\n{\n\tu32 i, level;\n\n\tfor (i = 0; i < SECINITSID_NUM; i++)\n\t\tif (s->isids[i].set)\n\t\t\tsidtab_destroy_entry(&s->isids[i].entry);\n\n\tlevel = SIDTAB_MAX_LEVEL;\n\twhile (level && !s->roots[level].ptr_inner)\n\t\t--level;\n\n\tsidtab_destroy_tree(s->roots[level], level);\n\t \n}\n\n#if CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0\n\nvoid sidtab_sid2str_put(struct sidtab *s, struct sidtab_entry *entry,\n\t\t\tconst char *str, u32 str_len)\n{\n\tstruct sidtab_str_cache *cache, *victim = NULL;\n\tunsigned long flags;\n\n\t \n\tif (entry->context.len)\n\t\treturn;\n\n\tspin_lock_irqsave(&s->cache_lock, flags);\n\n\tcache = rcu_dereference_protected(entry->cache,\n\t\t\t\t\t  lockdep_is_held(&s->cache_lock));\n\tif (cache) {\n\t\t \n\t\tlist_move(&cache->lru_member, &s->cache_lru_list);\n\t\tgoto out_unlock;\n\t}\n\n\tcache = kmalloc(struct_size(cache, str, str_len), GFP_ATOMIC);\n\tif (!cache)\n\t\tgoto out_unlock;\n\n\tif (s->cache_free_slots == 0) {\n\t\t \n\t\tvictim = container_of(s->cache_lru_list.prev,\n\t\t\t\t      struct sidtab_str_cache, lru_member);\n\t\tlist_del(&victim->lru_member);\n\t\trcu_assign_pointer(victim->parent->cache, NULL);\n\t} else {\n\t\ts->cache_free_slots--;\n\t}\n\tcache->parent = entry;\n\tcache->len = str_len;\n\tmemcpy(cache->str, str, str_len);\n\tlist_add(&cache->lru_member, &s->cache_lru_list);\n\n\trcu_assign_pointer(entry->cache, cache);\n\nout_unlock:\n\tspin_unlock_irqrestore(&s->cache_lock, flags);\n\tkfree_rcu(victim, rcu_member);\n}\n\nint sidtab_sid2str_get(struct sidtab *s, struct sidtab_entry *entry,\n\t\t       char **out, u32 *out_len)\n{\n\tstruct sidtab_str_cache *cache;\n\tint rc = 0;\n\n\tif (entry->context.len)\n\t\treturn -ENOENT;  \n\n\trcu_read_lock();\n\n\tcache = rcu_dereference(entry->cache);\n\tif (!cache) {\n\t\trc = -ENOENT;\n\t} else {\n\t\t*out_len = cache->len;\n\t\tif (out) {\n\t\t\t*out = kmemdup(cache->str, cache->len, GFP_ATOMIC);\n\t\t\tif (!*out)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (!rc && out)\n\t\tsidtab_sid2str_put(s, entry, *out, *out_len);\n\treturn rc;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}