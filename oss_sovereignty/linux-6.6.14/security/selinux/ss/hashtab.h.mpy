{
  "module_name": "hashtab.h",
  "hash_id": "8b328734f3319d4856aa287f9b929b11f0fc311e8cf571b5c35e5c349f89457e",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/hashtab.h",
  "human_readable_source": " \n \n#ifndef _SS_HASHTAB_H_\n#define _SS_HASHTAB_H_\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\n#define HASHTAB_MAX_NODES\tU32_MAX\n\nstruct hashtab_key_params {\n\tu32 (*hash)(const void *key);\t \n\tint (*cmp)(const void *key1, const void *key2);\n\t\t\t\t\t \n};\n\nstruct hashtab_node {\n\tvoid *key;\n\tvoid *datum;\n\tstruct hashtab_node *next;\n};\n\nstruct hashtab {\n\tstruct hashtab_node **htable;\t \n\tu32 size;\t\t\t \n\tu32 nel;\t\t\t \n};\n\nstruct hashtab_info {\n\tu32 slots_used;\n\tu32 max_chain_len;\n};\n\n \nint hashtab_init(struct hashtab *h, u32 nel_hint);\n\nint __hashtab_insert(struct hashtab *h, struct hashtab_node **dst,\n\t\t     void *key, void *datum);\n\n \nstatic inline int hashtab_insert(struct hashtab *h, void *key, void *datum,\n\t\t\t\t struct hashtab_key_params key_params)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur;\n\n\tcond_resched();\n\n\tif (!h->size || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = key_params.hash(key) & (h->size - 1);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur) {\n\t\tint cmp = key_params.cmp(key, cur->key);\n\n\t\tif (cmp == 0)\n\t\t\treturn -EEXIST;\n\t\tif (cmp < 0)\n\t\t\tbreak;\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\treturn __hashtab_insert(h, prev ? &prev->next : &h->htable[hvalue],\n\t\t\t\tkey, datum);\n}\n\n \nstatic inline void *hashtab_search(struct hashtab *h, const void *key,\n\t\t\t\t   struct hashtab_key_params key_params)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h->size)\n\t\treturn NULL;\n\n\thvalue = key_params.hash(key) & (h->size - 1);\n\tcur = h->htable[hvalue];\n\twhile (cur) {\n\t\tint cmp = key_params.cmp(key, cur->key);\n\n\t\tif (cmp == 0)\n\t\t\treturn cur->datum;\n\t\tif (cmp < 0)\n\t\t\tbreak;\n\t\tcur = cur->next;\n\t}\n\treturn NULL;\n}\n\n \nvoid hashtab_destroy(struct hashtab *h);\n\n \nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args);\n\nint hashtab_duplicate(struct hashtab *new, struct hashtab *orig,\n\t\tint (*copy)(struct hashtab_node *new,\n\t\t\tstruct hashtab_node *orig, void *args),\n\t\tint (*destroy)(void *k, void *d, void *args),\n\t\tvoid *args);\n\n#ifdef CONFIG_SECURITY_SELINUX_DEBUG\n \nvoid hashtab_stat(struct hashtab *h, struct hashtab_info *info);\n#else\nstatic inline void hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}