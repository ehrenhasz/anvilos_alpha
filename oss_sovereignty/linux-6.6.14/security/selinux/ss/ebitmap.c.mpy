{
  "module_name": "ebitmap.c",
  "hash_id": "81ded60752528b3b72e719c027bdab82794f788325f03d2eda169d0dd7022219",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/ebitmap.c",
  "human_readable_source": "\n \n \n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jhash.h>\n#include <net/netlabel.h>\n#include \"ebitmap.h\"\n#include \"policydb.h\"\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep __ro_after_init;\n\nint ebitmap_cmp(const struct ebitmap *e1, const struct ebitmap *e2)\n{\n\tconst struct ebitmap_node *n1, *n2;\n\n\tif (e1->highbit != e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\twhile (n1 && n2 &&\n\t       (n1->startbit == n2->startbit) &&\n\t       !memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n1 || n2)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint ebitmap_cpy(struct ebitmap *dst, const struct ebitmap *src)\n{\n\tstruct ebitmap_node *new, *prev;\n\tconst struct ebitmap_node *n;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}\n\nint ebitmap_and(struct ebitmap *dst, const struct ebitmap *e1, const struct ebitmap *e2)\n{\n\tstruct ebitmap_node *n;\n\tint bit, rc;\n\n\tebitmap_init(dst);\n\n\tebitmap_for_each_positive_bit(e1, n, bit) {\n\t\tif (ebitmap_get_bit(e2, bit)) {\n\t\t\trc = ebitmap_set_bit(dst, bit, 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n#ifdef CONFIG_NETLABEL\n \nint ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap)\n{\n\tstruct ebitmap_node *e_iter = ebmap->node;\n\tunsigned long e_map;\n\tu32 offset;\n\tunsigned int iter;\n\tint rc;\n\n\tif (e_iter == NULL) {\n\t\t*catmap = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*catmap != NULL)\n\t\tnetlbl_catmap_free(*catmap);\n\t*catmap = NULL;\n\n\twhile (e_iter) {\n\t\toffset = e_iter->startbit;\n\t\tfor (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {\n\t\t\te_map = e_iter->maps[iter];\n\t\t\tif (e_map != 0) {\n\t\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   e_map,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto netlbl_export_failure;\n\t\t\t}\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t}\n\t\te_iter = e_iter->next;\n\t}\n\n\treturn 0;\n\nnetlbl_export_failure:\n\tnetlbl_catmap_free(*catmap);\n\treturn -ENOMEM;\n}\n\n \nint ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap)\n{\n\tint rc;\n\tstruct ebitmap_node *e_iter = NULL;\n\tstruct ebitmap_node *e_prev = NULL;\n\tu32 offset = 0, idx;\n\tunsigned long bitmap;\n\n\tfor (;;) {\n\t\trc = netlbl_catmap_getlong(catmap, &offset, &bitmap);\n\t\tif (rc < 0)\n\t\t\tgoto netlbl_import_failure;\n\t\tif (offset == (u32)-1)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (bitmap == 0) {\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e_iter == NULL ||\n\t\t    offset >= e_iter->startbit + EBITMAP_SIZE) {\n\t\t\te_prev = e_iter;\n\t\t\te_iter = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\t\tif (e_iter == NULL)\n\t\t\t\tgoto netlbl_import_failure;\n\t\t\te_iter->startbit = offset - (offset % EBITMAP_SIZE);\n\t\t\tif (e_prev == NULL)\n\t\t\t\tebmap->node = e_iter;\n\t\t\telse\n\t\t\t\te_prev->next = e_iter;\n\t\t\tebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\n\t\t}\n\n\t\t \n\t\tidx = EBITMAP_NODE_INDEX(e_iter, offset);\n\t\te_iter->maps[idx] = bitmap;\n\n\t\t \n\t\toffset += EBITMAP_UNIT_SIZE;\n\t}\n\n\t \n\treturn 0;\n\nnetlbl_import_failure:\n\tebitmap_destroy(ebmap);\n\treturn -ENOMEM;\n}\n#endif  \n\n \nint ebitmap_contains(const struct ebitmap *e1, const struct ebitmap *e2, u32 last_e2bit)\n{\n\tconst struct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t \n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint ebitmap_get_bit(const struct ebitmap *e, unsigned long bit)\n{\n\tconst struct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t \n\t\t\t\tif (!n->next) {\n\t\t\t\t\t \n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t \n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n}\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\t__le32 ebitmap_start;\n\tu64 map;\n\t__le64 mapbits;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tpr_err(\"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t \n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&ebitmap_start, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(ebitmap_start);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tpr_err(\"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tpr_err(\"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tpr_err(\"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t \n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tpr_err(\"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&mapbits, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(mapbits);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}\n\nint ebitmap_write(const struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t \n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t \n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t \n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nu32 ebitmap_hash(const struct ebitmap *e, u32 hash)\n{\n\tstruct ebitmap_node *node;\n\n\t \n\thash = jhash_1word(e->highbit, hash);\n\tfor (node = e->node; node; node = node->next) {\n\t\thash = jhash_1word(node->startbit, hash);\n\t\thash = jhash(node->maps, sizeof(node->maps), hash);\n\t}\n\treturn hash;\n}\n\nvoid __init ebitmap_cache_init(void)\n{\n\tebitmap_node_cachep = kmem_cache_create(\"ebitmap_node\",\n\t\t\t\t\t\t\tsizeof(struct ebitmap_node),\n\t\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}