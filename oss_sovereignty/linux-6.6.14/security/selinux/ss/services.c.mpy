{
  "module_name": "services.c",
  "hash_id": "eb8a1ecf62bd47a54afd7f123b6830f2271176d9c808c27855137abc53196fb2",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/services.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/sched.h>\n#include <linux/audit.h>\n#include <linux/vmalloc.h>\n#include <linux/lsm_hooks.h>\n#include <net/netlabel.h>\n\n#include \"flask.h\"\n#include \"avc.h\"\n#include \"avc_ss.h\"\n#include \"security.h\"\n#include \"context.h\"\n#include \"policydb.h\"\n#include \"sidtab.h\"\n#include \"services.h\"\n#include \"conditional.h\"\n#include \"mls.h\"\n#include \"objsec.h\"\n#include \"netlabel.h\"\n#include \"xfrm.h\"\n#include \"ebitmap.h\"\n#include \"audit.h\"\n#include \"policycap_names.h\"\n#include \"ima.h\"\n\nstruct selinux_policy_convert_data {\n\tstruct convert_context_args args;\n\tstruct sidtab_convert_params sidtab_params;\n};\n\n \nstatic int context_struct_to_string(struct policydb *policydb,\n\t\t\t\t    struct context *context,\n\t\t\t\t    char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int sidtab_entry_to_string(struct policydb *policydb,\n\t\t\t\t  struct sidtab *sidtab,\n\t\t\t\t  struct sidtab_entry *entry,\n\t\t\t\t  char **scontext,\n\t\t\t\t  u32 *scontext_len);\n\nstatic void context_struct_compute_av(struct policydb *policydb,\n\t\t\t\t      struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd,\n\t\t\t\t      struct extended_perms *xperms);\n\nstatic int selinux_set_mapping(struct policydb *pol,\n\t\t\t       const struct security_class_mapping *map,\n\t\t\t       struct selinux_map *out_map)\n{\n\tu16 i, j;\n\tbool print_unknown_handle = false;\n\n\t \n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t \n\tout_map->mapping = kcalloc(++i, sizeof(*out_map->mapping), GFP_ATOMIC);\n\tif (!out_map->mapping)\n\t\treturn -ENOMEM;\n\n\t \n\tj = 0;\n\twhile (map[j].name) {\n\t\tconst struct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map->mapping + j;\n\t\tu16 k;\n\n\t\t \n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tpr_info(\"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms[k]) {\n\t\t\t \n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tpr_info(\"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tpr_info(\"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\tout_map->size = i;\n\treturn 0;\nerr:\n\tkfree(out_map->mapping);\n\tout_map->mapping = NULL;\n\treturn -EINVAL;\n}\n\n \n\nstatic u16 unmap_class(struct selinux_map *map, u16 tclass)\n{\n\tif (tclass < map->size)\n\t\treturn map->mapping[tclass].value;\n\n\treturn tclass;\n}\n\n \nstatic u16 map_class(struct selinux_map *map, u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < map->size; i++) {\n\t\tif (map->mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}\n\nstatic void map_decision(struct selinux_map *map,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < map->size) {\n\t\tstruct selinux_mapping *mapping = &map->mapping[tclass];\n\t\tunsigned int i, n = mapping->num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & mapping->perms[i])\n\t\t\t\tresult |= (u32)1<<i;\n\t\t\tif (allow_unknown && !mapping->perms[i])\n\t\t\t\tresult |= (u32)1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & mapping->perms[i])\n\t\t\t\tresult |= (u32)1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & mapping->perms[i])\n\t\t\t\tresult |= (u32)1<<i;\n\t\t\tif (!allow_unknown && !mapping->perms[i])\n\t\t\t\tresult |= (u32)1<<i;\n\t\t}\n\t\t \n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= (u32)1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}\n\nint security_mls_enabled(void)\n{\n\tint mls_enabled;\n\tstruct selinux_policy *policy;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tmls_enabled = policy->policydb.mls_enabled;\n\trcu_read_unlock();\n\treturn mls_enabled;\n}\n\n \nstatic int constraint_expr_eval(struct policydb *policydb,\n\t\t\t\tstruct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb->role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb->role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_EQ:\n\t\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_NEQ:\n\t\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}\n\n \nstatic int dump_masked_av_helper(void *k, void *d, void *args)\n{\n\tstruct perm_datum *pdatum = d;\n\tchar **permission_names = args;\n\n\tBUG_ON(pdatum->value < 1 || pdatum->value > 32);\n\n\tpermission_names[pdatum->value - 1] = (char *)k;\n\n\treturn 0;\n}\n\nstatic void security_dump_masked_av(struct policydb *policydb,\n\t\t\t\t    struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb->class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t \n\tif (common_dat &&\n\t    hashtab_map(&common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(&tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t \n\tif (context_struct_to_string(policydb, scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(policydb, tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t \n\tab = audit_log_start(audit_context(),\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t \n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n}\n\n \nstatic void type_attribute_bounds_av(struct policydb *policydb,\n\t\t\t\t     struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext, *tcontextp = tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = policydb->type_val_to_struct[scontext->type - 1];\n\tBUG_ON(!source);\n\n\tif (!source->bounds)\n\t\treturn;\n\n\ttarget = policydb->type_val_to_struct[tcontext->type - 1];\n\tBUG_ON(!target);\n\n\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\tlo_scontext.type = source->bounds;\n\n\tif (target->bounds) {\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\t\ttcontextp = &lo_tcontext;\n\t}\n\n\tcontext_struct_compute_av(policydb, &lo_scontext,\n\t\t\t\t  tcontextp,\n\t\t\t\t  tclass,\n\t\t\t\t  &lo_avd,\n\t\t\t\t  NULL);\n\n\tmasked = ~lo_avd.allowed & avd->allowed;\n\n\tif (likely(!masked))\n\t\treturn;\t\t \n\n\t \n\tavd->allowed &= ~masked;\n\n\t \n\tsecurity_dump_masked_av(policydb, scontext, tcontext,\n\t\t\t\ttclass, masked, \"bounds\");\n}\n\n \nvoid services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t \n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\txperms->len = 1;\n}\n\n \nstatic void context_struct_compute_av(struct policydb *policydb,\n\t\t\t\t      struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd,\n\t\t\t\t      struct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb->p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb->class_val_to_struct[tclass - 1];\n\n\t \n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = &policydb->type_attr_map_array[scontext->type - 1];\n\ttattr = &policydb->type_attr_map_array[tcontext->type - 1];\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb->te_avtab,\n\t\t\t\t\t\t      &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t \n\t\t\tcond_compute_av(&policydb->te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t \n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(policydb, scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t \n\tif (tclass == policydb->process_class &&\n\t    (avd->allowed & policydb->process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb->role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb->process_trans_perms;\n\t}\n\n\t \n\ttype_attribute_bounds_av(policydb, scontext, tcontext,\n\t\t\t\t tclass, avd);\n}\n\nstatic int security_validtrans_handle_fail(struct selinux_policy *policy,\n\t\t\t\t\tstruct sidtab_entry *oentry,\n\t\t\t\t\tstruct sidtab_entry *nentry,\n\t\t\t\t\tstruct sidtab_entry *tentry,\n\t\t\t\t\tu16 tclass)\n{\n\tstruct policydb *p = &policy->policydb;\n\tstruct sidtab *sidtab = policy->sidtab;\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (sidtab_entry_to_string(p, sidtab, oentry, &o, &olen))\n\t\tgoto out;\n\tif (sidtab_entry_to_string(p, sidtab, nentry, &n, &nlen))\n\t\tgoto out;\n\tif (sidtab_entry_to_string(p, sidtab, tentry, &t, &tlen))\n\t\tgoto out;\n\taudit_log(audit_context(), GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(p, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!enforcing_enabled())\n\t\treturn 0;\n\treturn -EPERM;\n}\n\nstatic int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct sidtab_entry *oentry;\n\tstruct sidtab_entry *nentry;\n\tstruct sidtab_entry *tentry;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tif (!user)\n\t\ttclass = unmap_class(&policy->map, orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb->p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb->class_val_to_struct[tclass - 1];\n\n\toentry = sidtab_search_entry(sidtab, oldsid);\n\tif (!oentry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnentry = sidtab_search_entry(sidtab, newsid);\n\tif (!nentry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttentry = sidtab_search_entry(sidtab, tasksid);\n\tif (!tentry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(policydb, &oentry->context,\n\t\t\t\t\t  &nentry->context, &tentry->context,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(policy,\n\t\t\t\t\t\t\t\toentry,\n\t\t\t\t\t\t\t\tnentry,\n\t\t\t\t\t\t\t\ttentry,\n\t\t\t\t\t\t\t\ttclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nint security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t      u16 tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t      tclass, true);\n}\n\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 orig_tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t      orig_tclass, false);\n}\n\n \nint security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct sidtab_entry *old_entry, *new_entry;\n\tstruct type_datum *type;\n\tu32 index;\n\tint rc;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\trc = -EINVAL;\n\told_entry = sidtab_search_entry(sidtab, old_sid);\n\tif (!old_entry) {\n\t\tpr_err(\"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, old_sid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnew_entry = sidtab_search_entry(sidtab, new_sid);\n\tif (!new_entry) {\n\t\tpr_err(\"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, new_sid);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t \n\tif (old_entry->context.type == new_entry->context.type)\n\t\tgoto out;\n\n\tindex = new_entry->context.type;\n\twhile (true) {\n\t\ttype = policydb->type_val_to_struct[index - 1];\n\t\tBUG_ON(!type);\n\n\t\t \n\t\trc = -EPERM;\n\t\tif (!type->bounds)\n\t\t\tbreak;\n\n\t\t \n\t\trc = 0;\n\t\tif (type->bounds == old_entry->context.type)\n\t\t\tbreak;\n\n\t\tindex = type->bounds;\n\t}\n\n\tif (rc) {\n\t\tchar *old_name = NULL;\n\t\tchar *new_name = NULL;\n\t\tu32 length;\n\n\t\tif (!sidtab_entry_to_string(policydb, sidtab, old_entry,\n\t\t\t\t\t    &old_name, &length) &&\n\t\t    !sidtab_entry_to_string(policydb, sidtab, new_entry,\n\t\t\t\t\t    &new_name, &length)) {\n\t\t\taudit_log(audit_context(),\n\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t  \"op=security_bounded_transition \"\n\t\t\t\t  \"seresult=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\",\n\t\t\t\t  old_name, new_name);\n\t\t}\n\t\tkfree(new_name);\n\t\tkfree(old_name);\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\nstatic void avd_init(struct selinux_policy *policy, struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (policy)\n\t\tavd->seqno = policy->latest_granting;\n\telse\n\t\tavd->seqno = 0;\n\tavd->flags = 0;\n}\n\nvoid services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}\n\nvoid security_compute_xperms_decision(u32 ssid,\n\t\t\t\t      u32 tsid,\n\t\t\t\t      u16 orig_tclass,\n\t\t\t\t      u8 driver,\n\t\t\t\t      struct extended_perms_decision *xpermd)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tu16 tclass;\n\tstruct context *scontext, *tcontext;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\txpermd->driver = driver;\n\txpermd->used = 0;\n\tmemset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p));\n\tmemset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));\n\tmemset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));\n\n\trcu_read_lock();\n\tif (!selinux_initialized())\n\t\tgoto allow;\n\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tscontext = sidtab_search(sidtab, ssid);\n\tif (!scontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(sidtab, tsid);\n\tif (!tcontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(&policy->map, orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb->allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\n\tif (unlikely(!tclass || tclass > policydb->p_classes.nprim)) {\n\t\tpr_warn_ratelimited(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\tgoto out;\n\t}\n\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_XPERMS;\n\tsattr = &policydb->type_attr_map_array[scontext->type - 1];\n\ttattr = &policydb->type_attr_map_array[tcontext->type - 1];\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb->te_avtab,\n\t\t\t\t\t\t      &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified))\n\t\t\t\tservices_compute_xperms_decision(xpermd, node);\n\n\t\t\tcond_compute_xperms(&policydb->te_cond_avtab,\n\t\t\t\t\t\t&avkey, xpermd);\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\treturn;\nallow:\n\tmemset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));\n\tgoto out;\n}\n\n \nvoid security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd,\n\t\t\t struct extended_perms *xperms)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tavd_init(policy, avd);\n\txperms->len = 0;\n\tif (!selinux_initialized())\n\t\tgoto allow;\n\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tscontext = sidtab_search(sidtab, ssid);\n\tif (!scontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ebitmap_get_bit(&policydb->permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(sidtab, tsid);\n\tif (!tcontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(&policy->map, orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb->allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(policydb, scontext, tcontext, tclass, avd,\n\t\t\t\t  xperms);\n\tmap_decision(&policy->map, orig_tclass, avd,\n\t\t     policydb->allow_unknown);\nout:\n\trcu_read_unlock();\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\nvoid security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tavd_init(policy, avd);\n\tif (!selinux_initialized())\n\t\tgoto allow;\n\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tscontext = sidtab_search(sidtab, ssid);\n\tif (!scontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ebitmap_get_bit(&policydb->permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(sidtab, tsid);\n\tif (!tcontext) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb->allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(policydb, scontext, tcontext, tclass, avd,\n\t\t\t\t  NULL);\n out:\n\trcu_read_unlock();\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\n \nstatic int context_struct_to_string(struct policydb *p,\n\t\t\t\t    struct context *context,\n\t\t\t\t    char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\t*scontext_len += strlen(sym_name(p, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(p, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(p, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(p, context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t \n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t \n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(p, SYM_USERS, context->user - 1),\n\t\tsym_name(p, SYM_ROLES, context->role - 1),\n\t\tsym_name(p, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(p, context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}\n\nstatic int sidtab_entry_to_string(struct policydb *p,\n\t\t\t\t  struct sidtab *sidtab,\n\t\t\t\t  struct sidtab_entry *entry,\n\t\t\t\t  char **scontext, u32 *scontext_len)\n{\n\tint rc = sidtab_sid2str_get(sidtab, entry, scontext, scontext_len);\n\n\tif (rc != -ENOENT)\n\t\treturn rc;\n\n\trc = context_struct_to_string(p, &entry->context, scontext,\n\t\t\t\t      scontext_len);\n\tif (!rc && scontext)\n\t\tsidtab_sid2str_put(sidtab, entry, *scontext, *scontext_len);\n\treturn rc;\n}\n\n#include \"initial_sid_to_string.h\"\n\nint security_sidtab_hash_stats(char *page)\n{\n\tstruct selinux_policy *policy;\n\tint rc;\n\n\tif (!selinux_initialized()) {\n\t\tpr_err(\"SELinux: %s:  called before initial load_policy\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\trc = sidtab_hash_stats(policy->sidtab, page);\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\nconst char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force,\n\t\t\t\t\tint only_invalid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct sidtab_entry *entry;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!selinux_initialized()) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\t\t\tconst char *s = initial_sid_to_string[sid];\n\n\t\t\tif (!s)\n\t\t\t\treturn -EINVAL;\n\t\t\t*scontext_len = strlen(s) + 1;\n\t\t\tif (!scontext)\n\t\t\t\treturn 0;\n\t\t\tscontextp = kmemdup(s, *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp)\n\t\t\t\treturn -ENOMEM;\n\t\t\t*scontext = scontextp;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\treturn -EINVAL;\n\t}\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tif (force)\n\t\tentry = sidtab_search_entry_force(sidtab, sid);\n\telse\n\t\tentry = sidtab_search_entry(sidtab, sid);\n\tif (!entry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (only_invalid && !entry->context.len)\n\t\tgoto out_unlock;\n\n\trc = sidtab_entry_to_string(policydb, sidtab, entry, scontext,\n\t\t\t\t    scontext_len);\n\nout_unlock:\n\trcu_read_unlock();\n\treturn rc;\n\n}\n\n \nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext,\n\t\t\t\t\t    scontext_len, 0, 0);\n}\n\nint security_sid_to_context_force(u32 sid,\n\t\t\t\t  char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext,\n\t\t\t\t\t    scontext_len, 1, 0);\n}\n\n \nint security_sid_to_context_inval(u32 sid,\n\t\t\t\t  char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext,\n\t\t\t\t\t    scontext_len, 1, 1);\n}\n\n \nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t \n\n\trc = -EINVAL;\n\tscontextp = scontext;\n\n\t \n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = symtab_search(&pol->p_users, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t \n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = symtab_search(&pol->p_roles, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t \n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = symtab_search(&pol->p_types, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t \n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\t \n\tscontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\n\tif (!selinux_initialized()) {\n\t\tu32 i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tconst char *s = initial_sid_to_string[i];\n\n\t\t\tif (s && !strcmp(s, scontext2)) {\n\t\t\t\t*sid = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\tgoto out;\n\t}\n\t*sid = SECSID_NULL;\n\n\tif (force) {\n\t\t \n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\nretry:\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\trc = string_to_context_struct(policydb, sidtab, scontext2,\n\t\t\t\t      &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = strlen(str) + 1;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(sidtab, &context, sid);\n\tif (rc == -ESTALE) {\n\t\trcu_read_unlock();\n\t\tif (context.str) {\n\t\t\tstr = context.str;\n\t\t\tcontext.str = NULL;\n\t\t}\n\t\tcontext_destroy(&context);\n\t\tgoto retry;\n\t}\n\tcontext_destroy(&context);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}\n\n \nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext),\n\t\t\t\t       sid, gfp);\n}\n\n \nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *sid, u32 def_sid, gfp_t gfp_flags)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, def_sid, gfp_flags, 1);\n}\n\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 1);\n}\n\nstatic int compute_sid_handle_invalid_context(\n\tstruct selinux_policy *policy,\n\tstruct sidtab_entry *sentry,\n\tstruct sidtab_entry *tentry,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tstruct policydb *policydb = &policy->policydb;\n\tstruct sidtab *sidtab = policy->sidtab;\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\tstruct audit_buffer *ab;\n\n\tif (sidtab_entry_to_string(policydb, sidtab, sentry, &s, &slen))\n\t\tgoto out;\n\tif (sidtab_entry_to_string(policydb, sidtab, tentry, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(policydb, newcontext, &n, &nlen))\n\t\tgoto out;\n\tab = audit_log_start(audit_context(), GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\taudit_log_format(ab,\n\t\t\t \"op=security_compute_sid invalid_context=\");\n\t \n\taudit_log_n_untrustedstring(ab, n, nlen - 1);\n\taudit_log_format(ab, \" scontext=%s tcontext=%s tclass=%s\",\n\t\t\t s, t, sym_name(policydb, SYM_CLASSES, tclass-1));\n\taudit_log_end(ab);\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!enforcing_enabled())\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic void filename_compute_type(struct policydb *policydb,\n\t\t\t\t  struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans_key ft;\n\tstruct filename_trans_datum *datum;\n\n\t \n\tif (!ebitmap_get_bit(&policydb->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\tdatum = policydb_filenametr_search(policydb, &ft);\n\twhile (datum) {\n\t\tif (ebitmap_get_bit(&datum->stypes, stype - 1)) {\n\t\t\tnewcontext->type = datum->otype;\n\t\t\treturn;\n\t\t}\n\t\tdatum = datum->next;\n\t}\n}\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu16 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct class_datum *cladatum;\n\tstruct context *scontext, *tcontext, newcontext;\n\tstruct sidtab_entry *sentry, *tentry;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *avnode, *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!selinux_initialized()) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS:  \n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\nretry:\n\tcladatum = NULL;\n\tcontext_init(&newcontext);\n\n\trcu_read_lock();\n\n\tpolicy = rcu_dereference(selinux_state.policy);\n\n\tif (kern) {\n\t\ttclass = unmap_class(&policy->map, orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(&policy->map,\n\t\t\t\t\t\t\t  tclass));\n\t}\n\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tsentry = sidtab_search_entry(sidtab, ssid);\n\tif (!sentry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttentry = sidtab_search_entry(sidtab, tsid);\n\tif (!tentry) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tscontext = &sentry->context;\n\ttcontext = &tentry->context;\n\n\tif (tclass && tclass <= policydb->p_classes.nprim)\n\t\tcladatum = policydb->class_val_to_struct[tclass - 1];\n\n\t \n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t \n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t \n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb->process_class) || sock)\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t \n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb->process_class) || sock) {\n\t\t\t \n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t \n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t \n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavnode = avtab_search_node(&policydb->te_avtab, &avkey);\n\n\t \n\tif (!avnode) {\n\t\tnode = avtab_search_node(&policydb->te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavnode = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avnode) {\n\t\t \n\t\tnewcontext.type = avnode->datum.u.data;\n\t}\n\n\t \n\tif (objname)\n\t\tfilename_compute_type(policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t \n\tif (specified & AVTAB_TRANSITION) {\n\t\t \n\t\tstruct role_trans_datum *rtd;\n\t\tstruct role_trans_key rtk = {\n\t\t\t.role = scontext->role,\n\t\t\t.type = tcontext->type,\n\t\t\t.tclass = tclass,\n\t\t};\n\n\t\trtd = policydb_roletr_search(policydb, &rtk);\n\t\tif (rtd)\n\t\t\tnewcontext.role = rtd->new_role;\n\t}\n\n\t \n\trc = mls_compute_sid(policydb, scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\tif (!policydb_context_isvalid(policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(policy, sentry,\n\t\t\t\t\t\t\ttentry, tclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t \n\trc = sidtab_context_to_sid(sidtab, &newcontext, out_sid);\n\tif (rc == -ESTALE) {\n\t\trcu_read_unlock();\n\t\tcontext_destroy(&newcontext);\n\t\tgoto retry;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}\n\n \nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass,\n\t\t\t\t    AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass,\n\t\t\t\t    AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}\n\n \nint security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass,\n\t\t\t\t    AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}\n\n \nint security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}\n\nstatic inline int convert_context_handle_invalid_context(\n\tstruct policydb *policydb,\n\tstruct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (enforcing_enabled())\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(policydb, context, &s, &len)) {\n\t\tpr_warn(\"SELinux:  Context %s would be invalid if enforcing\\n\",\n\t\t\ts);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}\n\n \nint services_convert_context(struct convert_context_args *args,\n\t\t\t     struct context *oldc, struct context *newc,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct ocontext *oc;\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\tif (oldc->str) {\n\t\ts = kstrdup(oldc->str, gfp_flags);\n\t\tif (!s)\n\t\t\treturn -ENOMEM;\n\n\t\trc = string_to_context_struct(args->newp, NULL, s, newc, SECSID_NULL);\n\t\tif (rc == -EINVAL) {\n\t\t\t \n\t\t\tmemcpy(s, oldc->str, oldc->len);\n\t\t\tcontext_init(newc);\n\t\t\tnewc->str = s;\n\t\t\tnewc->len = oldc->len;\n\t\t\treturn 0;\n\t\t}\n\t\tkfree(s);\n\t\tif (rc) {\n\t\t\t \n\t\t\tpr_err(\"SELinux:   Unable to map context %s, rc = %d.\\n\",\n\t\t\t       oldc->str, -rc);\n\t\t\treturn rc;\n\t\t}\n\t\tpr_info(\"SELinux:  Context %s became valid (mapped).\\n\",\n\t\t\toldc->str);\n\t\treturn 0;\n\t}\n\n\tcontext_init(newc);\n\n\t \n\tusrdatum = symtab_search(&args->newp->p_users,\n\t\t\t\t sym_name(args->oldp, SYM_USERS, oldc->user - 1));\n\tif (!usrdatum)\n\t\tgoto bad;\n\tnewc->user = usrdatum->value;\n\n\t \n\trole = symtab_search(&args->newp->p_roles,\n\t\t\t     sym_name(args->oldp, SYM_ROLES, oldc->role - 1));\n\tif (!role)\n\t\tgoto bad;\n\tnewc->role = role->value;\n\n\t \n\ttypdatum = symtab_search(&args->newp->p_types,\n\t\t\t\t sym_name(args->oldp, SYM_TYPES, oldc->type - 1));\n\tif (!typdatum)\n\t\tgoto bad;\n\tnewc->type = typdatum->value;\n\n\t \n\tif (args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\trc = mls_convert_context(args->oldp, args->newp, oldc, newc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\t \n\t\toc = args->newp->ocontexts[OCON_ISID];\n\t\twhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\n\t\t\toc = oc->next;\n\t\tif (!oc) {\n\t\t\tpr_err(\"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\trc = mls_range_set(newc, &oc->context[0].range);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\t \n\tif (!policydb_context_isvalid(args->newp, newc)) {\n\t\trc = convert_context_handle_invalid_context(args->oldp, oldc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\nbad:\n\t \n\trc = context_struct_to_string(args->oldp, oldc, &s, &len);\n\tif (rc)\n\t\treturn rc;\n\tcontext_destroy(newc);\n\tnewc->str = s;\n\tnewc->len = len;\n\tpr_info(\"SELinux:  Context %s became invalid (unmapped).\\n\",\n\t\tnewc->str);\n\treturn 0;\n}\n\nstatic void security_load_policycaps(struct selinux_policy *policy)\n{\n\tstruct policydb *p;\n\tunsigned int i;\n\tstruct ebitmap_node *node;\n\n\tp = &policy->policydb;\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_state.policycap); i++)\n\t\tWRITE_ONCE(selinux_state.policycap[i],\n\t\t\tebitmap_get_bit(&p->policycaps, i));\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)\n\t\tpr_info(\"SELinux:  policy capability %s=%d\\n\",\n\t\t\tselinux_policycap_names[i],\n\t\t\tebitmap_get_bit(&p->policycaps, i));\n\n\tebitmap_for_each_positive_bit(&p->policycaps, node, i) {\n\t\tif (i >= ARRAY_SIZE(selinux_policycap_names))\n\t\t\tpr_info(\"SELinux:  unknown policy capability %u\\n\",\n\t\t\t\ti);\n\t}\n}\n\nstatic int security_preserve_bools(struct selinux_policy *oldpolicy,\n\t\t\t\tstruct selinux_policy *newpolicy);\n\nstatic void selinux_policy_free(struct selinux_policy *policy)\n{\n\tif (!policy)\n\t\treturn;\n\n\tsidtab_destroy(policy->sidtab);\n\tkfree(policy->map.mapping);\n\tpolicydb_destroy(&policy->policydb);\n\tkfree(policy->sidtab);\n\tkfree(policy);\n}\n\nstatic void selinux_policy_cond_free(struct selinux_policy *policy)\n{\n\tcond_policydb_destroy_dup(&policy->policydb);\n\tkfree(policy);\n}\n\nvoid selinux_policy_cancel(struct selinux_load_state *load_state)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *oldpolicy;\n\n\toldpolicy = rcu_dereference_protected(state->policy,\n\t\t\t\t\tlockdep_is_held(&state->policy_mutex));\n\n\tsidtab_cancel_convert(oldpolicy->sidtab);\n\tselinux_policy_free(load_state->policy);\n\tkfree(load_state->convert_data);\n}\n\nstatic void selinux_notify_policy_change(u32 seqno)\n{\n\t \n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\tselinux_ima_measure_state_locked();\n}\n\nvoid selinux_policy_commit(struct selinux_load_state *load_state)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *oldpolicy, *newpolicy = load_state->policy;\n\tunsigned long flags;\n\tu32 seqno;\n\n\toldpolicy = rcu_dereference_protected(state->policy,\n\t\t\t\t\tlockdep_is_held(&state->policy_mutex));\n\n\t \n\tif (oldpolicy) {\n\t\tif (oldpolicy->policydb.mls_enabled && !newpolicy->policydb.mls_enabled)\n\t\t\tpr_info(\"SELinux: Disabling MLS support...\\n\");\n\t\telse if (!oldpolicy->policydb.mls_enabled && newpolicy->policydb.mls_enabled)\n\t\t\tpr_info(\"SELinux: Enabling MLS support...\\n\");\n\t}\n\n\t \n\tif (oldpolicy)\n\t\tnewpolicy->latest_granting = oldpolicy->latest_granting + 1;\n\telse\n\t\tnewpolicy->latest_granting = 1;\n\tseqno = newpolicy->latest_granting;\n\n\t \n\tif (oldpolicy) {\n\t\tsidtab_freeze_begin(oldpolicy->sidtab, &flags);\n\t\trcu_assign_pointer(state->policy, newpolicy);\n\t\tsidtab_freeze_end(oldpolicy->sidtab, &flags);\n\t} else {\n\t\trcu_assign_pointer(state->policy, newpolicy);\n\t}\n\n\t \n\tsecurity_load_policycaps(newpolicy);\n\n\tif (!selinux_initialized()) {\n\t\t \n\t\tselinux_mark_initialized();\n\t\tselinux_complete_init();\n\t}\n\n\t \n\tsynchronize_rcu();\n\tselinux_policy_free(oldpolicy);\n\tkfree(load_state->convert_data);\n\n\t \n\tselinux_notify_policy_change(seqno);\n}\n\n \nint security_load_policy(void *data, size_t len,\n\t\t\t struct selinux_load_state *load_state)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *newpolicy, *oldpolicy;\n\tstruct selinux_policy_convert_data *convert_data;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\tnewpolicy = kzalloc(sizeof(*newpolicy), GFP_KERNEL);\n\tif (!newpolicy)\n\t\treturn -ENOMEM;\n\n\tnewpolicy->sidtab = kzalloc(sizeof(*newpolicy->sidtab), GFP_KERNEL);\n\tif (!newpolicy->sidtab) {\n\t\trc = -ENOMEM;\n\t\tgoto err_policy;\n\t}\n\n\trc = policydb_read(&newpolicy->policydb, fp);\n\tif (rc)\n\t\tgoto err_sidtab;\n\n\tnewpolicy->policydb.len = len;\n\trc = selinux_set_mapping(&newpolicy->policydb, secclass_map,\n\t\t\t\t&newpolicy->map);\n\tif (rc)\n\t\tgoto err_policydb;\n\n\trc = policydb_load_isids(&newpolicy->policydb, newpolicy->sidtab);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  unable to load the initial SIDs\\n\");\n\t\tgoto err_mapping;\n\t}\n\n\tif (!selinux_initialized()) {\n\t\t \n\t\tload_state->policy = newpolicy;\n\t\tload_state->convert_data = NULL;\n\t\treturn 0;\n\t}\n\n\toldpolicy = rcu_dereference_protected(state->policy,\n\t\t\t\t\tlockdep_is_held(&state->policy_mutex));\n\n\t \n\trc = security_preserve_bools(oldpolicy, newpolicy);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err_free_isids;\n\t}\n\n\t \n\n\tconvert_data = kmalloc(sizeof(*convert_data), GFP_KERNEL);\n\tif (!convert_data) {\n\t\trc = -ENOMEM;\n\t\tgoto err_free_isids;\n\t}\n\n\tconvert_data->args.oldp = &oldpolicy->policydb;\n\tconvert_data->args.newp = &newpolicy->policydb;\n\n\tconvert_data->sidtab_params.args = &convert_data->args;\n\tconvert_data->sidtab_params.target = newpolicy->sidtab;\n\n\trc = sidtab_convert(oldpolicy->sidtab, &convert_data->sidtab_params);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err_free_convert_data;\n\t}\n\n\tload_state->policy = newpolicy;\n\tload_state->convert_data = convert_data;\n\treturn 0;\n\nerr_free_convert_data:\n\tkfree(convert_data);\nerr_free_isids:\n\tsidtab_destroy(newpolicy->sidtab);\nerr_mapping:\n\tkfree(newpolicy->map.mapping);\nerr_policydb:\n\tpolicydb_destroy(&newpolicy->policydb);\nerr_sidtab:\n\tkfree(newpolicy->sidtab);\nerr_policy:\n\tkfree(newpolicy);\n\n\treturn rc;\n}\n\n \nstatic int ocontext_to_sid(struct sidtab *sidtab, struct ocontext *c,\n\t\t\t   size_t index, u32 *out_sid)\n{\n\tint rc;\n\tu32 sid;\n\n\t \n\tsid = smp_load_acquire(&c->sid[index]);\n\tif (!sid) {\n\t\trc = sidtab_context_to_sid(sidtab, &c->context[index], &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tsmp_store_release(&c->sid[index], sid);\n\t}\n\t*out_sid = sid;\n\treturn 0;\n}\n\n \nint security_port_sid(u8 protocol, u16 port, u32 *out_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct ocontext *c;\n\tint rc;\n\n\tif (!selinux_initialized()) {\n\t\t*out_sid = SECINITSID_PORT;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tc = policydb->ocontexts[OCON_PORT];\n\twhile (c) {\n\t\tif (c->u.port.protocol == protocol &&\n\t\t    c->u.port.low_port <= port &&\n\t\t    c->u.port.high_port >= port)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\trc = ocontext_to_sid(sidtab, c, 0, out_sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\t*out_sid = SECINITSID_PORT;\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nint security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct ocontext *c;\n\tint rc;\n\n\tif (!selinux_initialized()) {\n\t\t*out_sid = SECINITSID_UNLABELED;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tc = policydb->ocontexts[OCON_IBPKEY];\n\twhile (c) {\n\t\tif (c->u.ibpkey.low_pkey <= pkey_num &&\n\t\t    c->u.ibpkey.high_pkey >= pkey_num &&\n\t\t    c->u.ibpkey.subnet_prefix == subnet_prefix)\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\trc = ocontext_to_sid(sidtab, c, 0, out_sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nint security_ib_endport_sid(const char *dev_name, u8 port_num, u32 *out_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct ocontext *c;\n\tint rc;\n\n\tif (!selinux_initialized()) {\n\t\t*out_sid = SECINITSID_UNLABELED;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tc = policydb->ocontexts[OCON_IBENDPORT];\n\twhile (c) {\n\t\tif (c->u.ibendport.port == port_num &&\n\t\t    !strncmp(c->u.ibendport.dev_name,\n\t\t\t     dev_name,\n\t\t\t     IB_DEVICE_NAME_MAX))\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\trc = ocontext_to_sid(sidtab, c, 0, out_sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nint security_netif_sid(char *name, u32 *if_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tint rc;\n\tstruct ocontext *c;\n\n\tif (!selinux_initialized()) {\n\t\t*if_sid = SECINITSID_NETIF;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tc = policydb->ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\trc = ocontext_to_sid(sidtab, c, 0, if_sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}\n\n \nint security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tint rc;\n\tstruct ocontext *c;\n\n\tif (!selinux_initialized()) {\n\t\t*out_sid = SECINITSID_NODE;\n\t\treturn 0;\n\t}\n\nretry:\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb->ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb->ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\trc = ocontext_to_sid(sidtab, c, 0, out_sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n#define SIDS_NEL 25\n\n \n\nint security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 i, j, mynel, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_KERNEL);\n\tif (!mysids)\n\t\treturn -ENOMEM;\n\nretry:\n\tmynel = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = symtab_search(&policydb->p_users, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb->role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(policydb, fromcon, user,\n\t\t\t\t\t\t &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(sidtab, &usercon, &sid);\n\t\t\tif (rc == -ESTALE) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\trcu_read_unlock();\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\treturn rc;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\treturn rc;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS,  \n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\n\treturn 0;\n}\n\n \nstatic inline int __security_genfs_sid(struct selinux_policy *policy,\n\t\t\t\t       const char *fstype,\n\t\t\t\t       const char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tstruct policydb *policydb = &policy->policydb;\n\tstruct sidtab *sidtab = policy->sidtab;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(&policy->map, orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb->genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\tif (!genfs || cmp)\n\t\treturn -ENOENT;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tsize_t len = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\tif (!c)\n\t\treturn -ENOENT;\n\n\treturn ocontext_to_sid(sidtab, c, 0, sid);\n}\n\n \nint security_genfs_sid(const char *fstype,\n\t\t       const char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tstruct selinux_policy *policy;\n\tint retval;\n\n\tif (!selinux_initialized()) {\n\t\t*sid = SECINITSID_UNLABELED;\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\trcu_read_lock();\n\t\tpolicy = rcu_dereference(selinux_state.policy);\n\t\tretval = __security_genfs_sid(policy, fstype, path,\n\t\t\t\t\t      orig_sclass, sid);\n\t\trcu_read_unlock();\n\t} while (retval == -ESTALE);\n\treturn retval;\n}\n\nint selinux_policy_genfs_sid(struct selinux_policy *policy,\n\t\t\tconst char *fstype,\n\t\t\tconst char *path,\n\t\t\tu16 orig_sclass,\n\t\t\tu32 *sid)\n{\n\t \n\treturn __security_genfs_sid(policy, fstype, path, orig_sclass, sid);\n}\n\n \nint security_fs_use(struct super_block *sb)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tint rc;\n\tstruct ocontext *c;\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\tconst char *fstype = sb->s_type->name;\n\n\tif (!selinux_initialized()) {\n\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\tsbsec->sid = SECINITSID_UNLABELED;\n\t\treturn 0;\n\t}\n\nretry:\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tc = policydb->ocontexts[OCON_FSUSE];\n\twhile (c) {\n\t\tif (strcmp(fstype, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tsbsec->behavior = c->v.behavior;\n\t\trc = ocontext_to_sid(sidtab, c, 0, &sbsec->sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\trc = __security_genfs_sid(policy, fstype, \"/\",\n\t\t\t\t\tSECCLASS_DIR, &sbsec->sid);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nint security_get_bools(struct selinux_policy *policy,\n\t\t       u32 *len, char ***names, int **values)\n{\n\tstruct policydb *policydb;\n\tu32 i;\n\tint rc;\n\n\tpolicydb = &policy->policydb;\n\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb->p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb->bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(policydb, SYM_BOOLS, i),\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t\tkfree(*names);\n\t}\n\tkfree(*values);\n\t*len = 0;\n\t*names = NULL;\n\t*values = NULL;\n\tgoto out;\n}\n\n\nint security_set_bools(u32 len, int *values)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *newpolicy, *oldpolicy;\n\tint rc;\n\tu32 i, seqno = 0;\n\n\tif (!selinux_initialized())\n\t\treturn -EINVAL;\n\n\toldpolicy = rcu_dereference_protected(state->policy,\n\t\t\t\t\tlockdep_is_held(&state->policy_mutex));\n\n\t \n\tif (WARN_ON(len != oldpolicy->policydb.p_bools.nprim))\n\t\treturn -EINVAL;\n\n\tnewpolicy = kmemdup(oldpolicy, sizeof(*newpolicy), GFP_KERNEL);\n\tif (!newpolicy)\n\t\treturn -ENOMEM;\n\n\t \n\trc = cond_policydb_dup(&newpolicy->policydb, &oldpolicy->policydb);\n\tif (rc) {\n\t\tkfree(newpolicy);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tint new_state = !!values[i];\n\t\tint old_state = newpolicy->policydb.bool_val_to_struct[i]->state;\n\n\t\tif (new_state != old_state) {\n\t\t\taudit_log(audit_context(), GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&newpolicy->policydb, SYM_BOOLS, i),\n\t\t\t\tnew_state,\n\t\t\t\told_state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t\tnewpolicy->policydb.bool_val_to_struct[i]->state = new_state;\n\t\t}\n\t}\n\n\t \n\tevaluate_cond_nodes(&newpolicy->policydb);\n\n\t \n\tnewpolicy->latest_granting = oldpolicy->latest_granting + 1;\n\tseqno = newpolicy->latest_granting;\n\n\t \n\trcu_assign_pointer(state->policy, newpolicy);\n\n\t \n\tsynchronize_rcu();\n\tselinux_policy_cond_free(oldpolicy);\n\n\t \n\tselinux_notify_policy_change(seqno);\n\treturn 0;\n}\n\nint security_get_bool_value(u32 index)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tint rc;\n\tu32 len;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\n\trc = -EFAULT;\n\tlen = policydb->p_bools.nprim;\n\tif (index >= len)\n\t\tgoto out;\n\n\trc = policydb->bool_val_to_struct[index]->state;\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstatic int security_preserve_bools(struct selinux_policy *oldpolicy,\n\t\t\t\tstruct selinux_policy *newpolicy)\n{\n\tint rc, *bvalues = NULL;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tu32 i, nbools = 0;\n\n\trc = security_get_bools(oldpolicy, &nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = symtab_search(&newpolicy->policydb.p_bools,\n\t\t\t\t\tbnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tevaluate_cond_nodes(&newpolicy->policydb);\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}\n\n \nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tstruct context *context1;\n\tstruct context *context2;\n\tstruct context newcon;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\tif (!selinux_initialized()) {\n\t\t*new_sid = sid;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\tcontext_init(&newcon);\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tif (!policydb->mls_enabled) {\n\t\t*new_sid = sid;\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext1 = sidtab_search(sidtab, sid);\n\tif (!context1) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext2 = sidtab_search(sidtab, mls_sid);\n\tif (!context2) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, mls_sid);\n\t\tgoto out_unlock;\n\t}\n\n\tnewcon.user = context1->user;\n\tnewcon.role = context1->role;\n\tnewcon.type = context1->type;\n\trc = mls_context_cpy(&newcon, context2);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\tif (!policydb_context_isvalid(policydb, &newcon)) {\n\t\trc = convert_context_handle_invalid_context(policydb,\n\t\t\t\t\t\t\t&newcon);\n\t\tif (rc) {\n\t\t\tif (!context_struct_to_string(policydb, &newcon, &s,\n\t\t\t\t\t\t      &len)) {\n\t\t\t\tstruct audit_buffer *ab;\n\n\t\t\t\tab = audit_log_start(audit_context(),\n\t\t\t\t\t\t     GFP_ATOMIC,\n\t\t\t\t\t\t     AUDIT_SELINUX_ERR);\n\t\t\t\taudit_log_format(ab,\n\t\t\t\t\t\t \"op=security_sid_mls_copy invalid_context=\");\n\t\t\t\t \n\t\t\t\taudit_log_n_untrustedstring(ab, s, len - 1);\n\t\t\t\taudit_log_end(ab);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\trc = sidtab_context_to_sid(sidtab, &newcon, new_sid);\n\tif (rc == -ESTALE) {\n\t\trcu_read_unlock();\n\t\tcontext_destroy(&newcon);\n\t\tgoto retry;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\tcontext_destroy(&newcon);\n\treturn rc;\n}\n\n \nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tint rc;\n\tstruct context *nlbl_ctx;\n\tstruct context *xfrm_ctx;\n\n\t*peer_sid = SECSID_NULL;\n\n\t \n\tif (xfrm_sid == SECSID_NULL) {\n\t\t*peer_sid = nlbl_sid;\n\t\treturn 0;\n\t}\n\t \n\tif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\n\t\t*peer_sid = xfrm_sid;\n\t\treturn 0;\n\t}\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\t \n\tif (!policydb->mls_enabled) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnlbl_ctx = sidtab_search(sidtab, nlbl_sid);\n\tif (!nlbl_ctx) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, nlbl_sid);\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\txfrm_ctx = sidtab_search(sidtab, xfrm_sid);\n\tif (!xfrm_ctx) {\n\t\tpr_err(\"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, xfrm_sid);\n\t\tgoto out;\n\t}\n\trc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\t*peer_sid = xfrm_sid;\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstatic int get_classes_callback(void *k, void *d, void *args)\n{\n\tstruct class_datum *datum = d;\n\tchar *name = k, **classes = args;\n\tu32 value = datum->value - 1;\n\n\tclasses[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!classes[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_classes(struct selinux_policy *policy,\n\t\t\t char ***classes, u32 *nclasses)\n{\n\tstruct policydb *policydb;\n\tint rc;\n\n\tpolicydb = &policy->policydb;\n\n\trc = -ENOMEM;\n\t*nclasses = policydb->p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(&policydb->p_classes.table, get_classes_callback,\n\t\t\t *classes);\n\tif (rc) {\n\t\tu32 i;\n\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\treturn rc;\n}\n\nstatic int get_permissions_callback(void *k, void *d, void *args)\n{\n\tstruct perm_datum *datum = d;\n\tchar *name = k, **perms = args;\n\tu32 value = datum->value - 1;\n\n\tperms[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!perms[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_permissions(struct selinux_policy *policy,\n\t\t\t     const char *class, char ***perms, u32 *nperms)\n{\n\tstruct policydb *policydb;\n\tu32 i;\n\tint rc;\n\tstruct class_datum *match;\n\n\tpolicydb = &policy->policydb;\n\n\trc = -EINVAL;\n\tmatch = symtab_search(&policydb->p_classes, class);\n\tif (!match) {\n\t\tpr_err(\"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(&match->comdatum->permissions.table,\n\t\t\t\t get_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(&match->permissions.table, get_permissions_callback,\n\t\t\t *perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\treturn rc;\n\nerr:\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}\n\nint security_get_reject_unknown(void)\n{\n\tstruct selinux_policy *policy;\n\tint value;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tvalue = policy->policydb.reject_unknown;\n\trcu_read_unlock();\n\treturn value;\n}\n\nint security_get_allow_unknown(void)\n{\n\tstruct selinux_policy *policy;\n\tint value;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tvalue = policy->policydb.allow_unknown;\n\trcu_read_unlock();\n\treturn value;\n}\n\n \nint security_policycap_supported(unsigned int req_cap)\n{\n\tstruct selinux_policy *policy;\n\tint rc;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\trc = ebitmap_get_bit(&policy->policydb.policycaps, req_cap);\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\nstruct selinux_audit_rule {\n\tu32 au_seqno;\n\tstruct context au_ctxt;\n};\n\nvoid selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}\n\nint selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct selinux_audit_rule *tmprule;\n\tstruct role_datum *roledatum;\n\tstruct type_datum *typedatum;\n\tstruct user_datum *userdatum;\n\tstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\n\tint rc = 0;\n\n\t*rule = NULL;\n\n\tif (!selinux_initialized())\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\t\t \n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t \n\t\tif (strchr(rulestr, '-'))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\ttmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\n\tif (!tmprule)\n\t\treturn -ENOMEM;\n\tcontext_init(&tmprule->au_ctxt);\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(state->policy);\n\tpolicydb = &policy->policydb;\n\ttmprule->au_seqno = policy->latest_granting;\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tuserdatum = symtab_search(&policydb->p_users, rulestr);\n\t\tif (!userdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\ttmprule->au_ctxt.user = userdatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\troledatum = symtab_search(&policydb->p_roles, rulestr);\n\t\tif (!roledatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\ttmprule->au_ctxt.role = roledatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\ttypedatum = symtab_search(&policydb->p_types, rulestr);\n\t\tif (!typedatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\ttmprule->au_ctxt.type = typedatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\trc = mls_from_string(policydb, rulestr, &tmprule->au_ctxt,\n\t\t\t\t     GFP_ATOMIC);\n\t\tif (rc)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\t*rule = tmprule;\n\treturn 0;\n\nerr:\n\trcu_read_unlock();\n\tselinux_audit_rule_free(tmprule);\n\t*rule = NULL;\n\treturn rc;\n}\n\n \nint selinux_audit_rule_known(struct audit_krule *rule)\n{\n\tu32 i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *policy;\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tpolicy = rcu_dereference(state->policy);\n\n\tif (rule->au_seqno < policy->latest_granting) {\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(policy->sidtab, sid);\n\tif (unlikely(!ctxt)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: unrecognized SID %d\\n\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn match;\n}\n\nstatic int aurule_avc_callback(u32 event)\n{\n\tif (event == AVC_CALLBACK_RESET)\n\t\treturn audit_update_lsm_rules();\n\treturn 0;\n}\n\nstatic int __init aurule_init(void)\n{\n\tint err;\n\n\terr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\n\tif (err)\n\t\tpanic(\"avc_add_callback() failed, error %d\\n\", err);\n\n\treturn err;\n}\n__initcall(aurule_init);\n\n#ifdef CONFIG_NETLABEL\n \nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}\n\n \nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tstruct sidtab *sidtab;\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!selinux_initialized()) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\nretry:\n\trc = 0;\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\tsidtab = policy->sidtab;\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(policydb, &ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = mls_import_netlbl_cat(policydb, &ctx_new, secattr);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(policydb, &ctx_new)) {\n\t\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = sidtab_context_to_sid(sidtab, &ctx_new, sid);\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t\tif (rc == -ESTALE) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\t} else\n\t\t*sid = SECSID_NULL;\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct selinux_policy *policy;\n\tstruct policydb *policydb;\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpolicy = rcu_dereference(selinux_state.policy);\n\tpolicydb = &policy->policydb;\n\n\trc = -ENOENT;\n\tctx = sidtab_search(policy->sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(policydb, ctx, secattr);\n\trc = mls_export_netlbl_cat(policydb, ctx, secattr);\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\n#endif  \n\n \nstatic int __security_read_policy(struct selinux_policy *policy,\n\t\t\t\t  void *data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tfp.data = data;\n\tfp.len = *len;\n\n\trc = policydb_write(&policy->policydb, &fp);\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)data;\n\treturn 0;\n}\n\n \nint security_read_policy(void **data, size_t *len)\n{\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *policy;\n\n\tpolicy = rcu_dereference_protected(\n\t\t\tstate->policy, lockdep_is_held(&state->policy_mutex));\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\t*len = policy->policydb.len;\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\treturn __security_read_policy(policy, *data, len);\n}\n\n \nint security_read_state_kernel(void **data, size_t *len)\n{\n\tint err;\n\tstruct selinux_state *state = &selinux_state;\n\tstruct selinux_policy *policy;\n\n\tpolicy = rcu_dereference_protected(\n\t\t\tstate->policy, lockdep_is_held(&state->policy_mutex));\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\t*len = policy->policydb.len;\n\t*data = vmalloc(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\terr = __security_read_policy(policy, *data, len);\n\tif (err) {\n\t\tvfree(*data);\n\t\t*data = NULL;\n\t\t*len = 0;\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}