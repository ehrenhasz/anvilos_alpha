{
  "module_name": "avtab.c",
  "hash_id": "f3f0b0eaee4e22d74f5e292048c3817702cfa7dfa1ae7b148398d6412798ac5c",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/avtab.c",
  "human_readable_source": " \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include \"avtab.h\"\n#include \"policydb.h\"\n\nstatic struct kmem_cache *avtab_node_cachep __ro_after_init;\nstatic struct kmem_cache *avtab_xperms_cachep __ro_after_init;\n\n \nstatic inline u32 avtab_hash(const struct avtab_key *keyp, u32 mask)\n{\n\tstatic const u32 c1 = 0xcc9e2d51;\n\tstatic const u32 c2 = 0x1b873593;\n\tstatic const u32 r1 = 15;\n\tstatic const u32 r2 = 13;\n\tstatic const u32 m  = 5;\n\tstatic const u32 n  = 0xe6546b64;\n\n\tu32 hash = 0;\n\n#define mix(input) do { \\\n\t\tu32 v = input; \\\n\t\tv *= c1; \\\n\t\tv = (v << r1) | (v >> (32 - r1)); \\\n\t\tv *= c2; \\\n\t\thash ^= v; \\\n\t\thash = (hash << r2) | (hash >> (32 - r2)); \\\n\t\thash = hash * m + n; \\\n\t} while (0)\n\n\tmix(keyp->target_class);\n\tmix(keyp->target_type);\n\tmix(keyp->source_type);\n\n#undef mix\n\n\thash ^= hash >> 16;\n\thash *= 0x85ebca6b;\n\thash ^= hash >> 13;\n\thash *= 0xc2b2ae35;\n\thash ^= hash >> 16;\n\n\treturn hash & mask;\n}\n\nstatic struct avtab_node*\navtab_insert_node(struct avtab *h, u32 hvalue,\n\t\t  struct avtab_node *prev,\n\t\t  const struct avtab_key *key, const struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tstruct avtab_node **n = &h->htable[hvalue];\n\n\t\tnewnode->next = *n;\n\t\t*n = newnode;\n\t}\n\n\th->nel++;\n\treturn newnode;\n}\n\nstatic int avtab_insert(struct avtab *h, const struct avtab_key *key,\n\t\t\tconst struct avtab_datum *datum)\n{\n\tu32 hvalue;\n\tstruct avtab_node *prev, *cur, *newnode;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->nslot || h->nel == U32_MAX)\n\t\treturn -EINVAL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = h->htable[hvalue];\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified)) {\n\t\t\t \n\t\t\tif (specified & AVTAB_XPERMS)\n\t\t\t\tbreak;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\n\tnewnode = avtab_insert_node(h, hvalue, prev, key, datum);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstruct avtab_node *avtab_insert_nonunique(struct avtab *h,\n\t\t\t\t\t  const struct avtab_key *key,\n\t\t\t\t\t  const struct avtab_datum *datum)\n{\n\tu32 hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->nslot || h->nel == U32_MAX)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = h->htable[hvalue];\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, key, datum);\n}\n\n \nstruct avtab_node *avtab_search_node(struct avtab *h,\n\t\t\t\t     const struct avtab_key *key)\n{\n\tu32 hvalue;\n\tstruct avtab_node *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->nslot)\n\t\treturn NULL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (cur = h->htable[hvalue]; cur;\n\t     cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, u16 specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nvoid avtab_destroy(struct avtab *h)\n{\n\tu32 i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tkvfree(h->htable);\n\th->htable = NULL;\n\th->nel = 0;\n\th->nslot = 0;\n\th->mask = 0;\n}\n\nvoid avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\th->nslot = 0;\n\th->mask = 0;\n}\n\nstatic int avtab_alloc_common(struct avtab *h, u32 nslot)\n{\n\tif (!nslot)\n\t\treturn 0;\n\n\th->htable = kvcalloc(nslot, sizeof(void *), GFP_KERNEL);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n\th->nslot = nslot;\n\th->mask = nslot - 1;\n\treturn 0;\n}\n\nint avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tint rc;\n\tu32 nslot = 0;\n\n\tif (nrules != 0) {\n\t\tu32 shift = 1;\n\t\tu32 work = nrules >> 3;\n\t\twhile (work) {\n\t\t\twork >>= 1;\n\t\t\tshift++;\n\t\t}\n\t\tnslot = 1 << shift;\n\t\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\n\t\trc = avtab_alloc_common(h, nslot);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tpr_debug(\"SELinux: %d avtab hash slots, %d rules.\\n\", nslot, nrules);\n\treturn 0;\n}\n\nint avtab_alloc_dup(struct avtab *new, const struct avtab *orig)\n{\n\treturn avtab_alloc_common(new, orig->nslot);\n}\n\n#ifdef CONFIG_SECURITY_SELINUX_DEBUG\nvoid avtab_hash_eval(struct avtab *h, const char *tag)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += (unsigned long long)chain_len * chain_len;\n\t\t}\n\t}\n\n\tpr_debug(\"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}\n#endif  \n\nstatic const uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};\n\nint avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, const struct avtab_key *k,\n\t\t\t\t   const struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, i;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint rc;\n\tunsigned int set, vers = pol->policyvers;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tpr_err(\"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tpr_err(\"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tpr_err(\"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tpr_err(\"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tpr_err(\"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tpr_err(\"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tpr_err(\"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tpr_err(\"SELinux: avtab: entry only had %d items, expected %d\\n\",\n\t\t\t       items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tpr_err(\"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tpr_err(\"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tpr_err(\"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tpr_err(\"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}\n\nstatic int avtab_insertf(struct avtab *a, const struct avtab_key *k,\n\t\t\t const struct avtab_datum *d, void *p)\n{\n\treturn avtab_insert(a, k, d);\n}\n\nint avtab_read(struct avtab *a, void *fp, struct policydb *pol)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 nel, i;\n\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0) {\n\t\tpr_err(\"SELinux: avtab: truncated table\\n\");\n\t\tgoto bad;\n\t}\n\tnel = le32_to_cpu(buf[0]);\n\tif (!nel) {\n\t\tpr_err(\"SELinux: avtab: table is empty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\trc = avtab_alloc(a, nel);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM)\n\t\t\t\tpr_err(\"SELinux: avtab: out of memory\\n\");\n\t\t\telse if (rc == -EEXIST)\n\t\t\t\tpr_err(\"SELinux: avtab: duplicate entry\\n\");\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n\nbad:\n\tavtab_destroy(a);\n\tgoto out;\n}\n\nint avtab_write_item(struct policydb *p, const struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}\n\nint avtab_write(struct policydb *p, struct avtab *a, void *fp)\n{\n\tu32 i;\n\tint rc = 0;\n\tstruct avtab_node *cur;\n\t__le32 buf[1];\n\n\tbuf[0] = cpu_to_le32(a->nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < a->nslot; i++) {\n\t\tfor (cur = a->htable[i]; cur;\n\t\t     cur = cur->next) {\n\t\t\trc = avtab_write_item(p, cur, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nvoid __init avtab_cache_init(void)\n{\n\tavtab_node_cachep = kmem_cache_create(\"avtab_node\",\n\t\t\t\t\t      sizeof(struct avtab_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\tavtab_xperms_cachep = kmem_cache_create(\"avtab_extended_perms\",\n\t\t\t\t\t\tsizeof(struct avtab_extended_perms),\n\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}