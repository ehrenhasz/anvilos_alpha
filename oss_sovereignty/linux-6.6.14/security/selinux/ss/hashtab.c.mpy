{
  "module_name": "hashtab.c",
  "hash_id": "8d35edd8c584f71ea2be2a0418e5721547e1d2f4e7e5219e768fe5f0a6d3a4ee",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/hashtab.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include \"hashtab.h\"\n#include \"security.h\"\n\nstatic struct kmem_cache *hashtab_node_cachep __ro_after_init;\n\n \nstatic u32 hashtab_compute_size(u32 nel)\n{\n\treturn nel == 0 ? 0 : roundup_pow_of_two(nel);\n}\n\nint hashtab_init(struct hashtab *h, u32 nel_hint)\n{\n\tu32 size = hashtab_compute_size(nel_hint);\n\n\t \n\th->nel = 0;\n\th->size = 0;\n\th->htable = NULL;\n\n\tif (size) {\n\t\th->htable = kcalloc(size, sizeof(*h->htable), GFP_KERNEL);\n\t\tif (!h->htable)\n\t\t\treturn -ENOMEM;\n\t\th->size = size;\n\t}\n\treturn 0;\n}\n\nint __hashtab_insert(struct hashtab *h, struct hashtab_node **dst,\n\t\t     void *key, void *datum)\n{\n\tstruct hashtab_node *newnode;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tnewnode->next = *dst;\n\t*dst = newnode;\n\n\th->nel++;\n\treturn 0;\n}\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n}\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY_SELINUX_DEBUG\nvoid hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tstruct hashtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tinfo->slots_used = slots_used;\n\tinfo->max_chain_len = max_chain_len;\n}\n#endif  \n\nint hashtab_duplicate(struct hashtab *new, struct hashtab *orig,\n\t\tint (*copy)(struct hashtab_node *new,\n\t\t\tstruct hashtab_node *orig, void *args),\n\t\tint (*destroy)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tstruct hashtab_node *cur, *tmp, *tail;\n\tu32 i;\n\tint rc;\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->htable = kcalloc(orig->size, sizeof(*new->htable), GFP_KERNEL);\n\tif (!new->htable)\n\t\treturn -ENOMEM;\n\n\tnew->size = orig->size;\n\n\tfor (i = 0; i < orig->size; i++) {\n\t\ttail = NULL;\n\t\tfor (cur = orig->htable[i]; cur; cur = cur->next) {\n\t\t\ttmp = kmem_cache_zalloc(hashtab_node_cachep,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\tgoto error;\n\t\t\trc = copy(tmp, cur, args);\n\t\t\tif (rc) {\n\t\t\t\tkmem_cache_free(hashtab_node_cachep, tmp);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttmp->next = NULL;\n\t\t\tif (!tail)\n\t\t\t\tnew->htable[i] = tmp;\n\t\t\telse\n\t\t\t\ttail->next = tmp;\n\t\t\ttail = tmp;\n\t\t\tnew->nel++;\n\t\t}\n\t}\n\n\treturn 0;\n\n error:\n\tfor (i = 0; i < new->size; i++) {\n\t\tfor (cur = new->htable[i]; cur; cur = tmp) {\n\t\t\ttmp = cur->next;\n\t\t\tdestroy(cur->key, cur->datum, args);\n\t\t\tkmem_cache_free(hashtab_node_cachep, cur);\n\t\t}\n\t}\n\tkfree(new->htable);\n\tmemset(new, 0, sizeof(*new));\n\treturn -ENOMEM;\n}\n\nvoid __init hashtab_cache_init(void)\n{\n\t\thashtab_node_cachep = kmem_cache_create(\"hashtab_node\",\n\t\t\tsizeof(struct hashtab_node),\n\t\t\t0, SLAB_PANIC, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}