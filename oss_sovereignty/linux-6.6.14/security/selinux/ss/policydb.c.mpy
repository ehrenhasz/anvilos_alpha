{
  "module_name": "policydb.c",
  "hash_id": "bcc7af8ef2390b70bdb4c8f237165102ba275c3e9c5e33f2a6d5da03515f377c",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/policydb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/audit.h>\n#include \"security.h\"\n\n#include \"policydb.h\"\n#include \"conditional.h\"\n#include \"mls.h\"\n#include \"services.h\"\n\n#ifdef CONFIG_SECURITY_SELINUX_DEBUG\nstatic const char *const symtab_name[SYM_NUM] = {\n\t\"common prefixes\",\n\t\"classes\",\n\t\"roles\",\n\t\"types\",\n\t\"users\",\n\t\"bools\",\n\t\"levels\",\n\t\"categories\",\n};\n#endif\n\nstruct policydb_compat_info {\n\tunsigned int version;\n\tunsigned int sym_num;\n\tunsigned int ocon_num;\n};\n\n \nstatic const struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_GLBLUB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_COMP_FTRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};\n\nstatic const struct policydb_compat_info *policydb_lookup_compat(unsigned int version)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version)\n\t\t\treturn &policydb_compat[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic int perm_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int common_destroy(void *key, void *datum, void *p)\n{\n\tstruct common_datum *comdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcomdatum = datum;\n\t\thashtab_map(&comdatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(&comdatum->permissions.table);\n\t}\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic void constraint_expr_destroy(struct constraint_expr *expr)\n{\n\tif (expr) {\n\t\tebitmap_destroy(&expr->names);\n\t\tif (expr->type_names) {\n\t\t\tebitmap_destroy(&expr->type_names->types);\n\t\t\tebitmap_destroy(&expr->type_names->negset);\n\t\t\tkfree(expr->type_names);\n\t\t}\n\t\tkfree(expr);\n\t}\n}\n\nstatic int cls_destroy(void *key, void *datum, void *p)\n{\n\tstruct class_datum *cladatum;\n\tstruct constraint_node *constraint, *ctemp;\n\tstruct constraint_expr *e, *etmp;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcladatum = datum;\n\t\thashtab_map(&cladatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(&cladatum->permissions.table);\n\t\tconstraint = cladatum->constraints;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\n\t\tconstraint = cladatum->validatetrans;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\t\tkfree(cladatum->comkey);\n\t}\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int role_destroy(void *key, void *datum, void *p)\n{\n\tstruct role_datum *role;\n\n\tkfree(key);\n\tif (datum) {\n\t\trole = datum;\n\t\tebitmap_destroy(&role->dominates);\n\t\tebitmap_destroy(&role->types);\n\t}\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int type_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int user_destroy(void *key, void *datum, void *p)\n{\n\tstruct user_datum *usrdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tusrdatum = datum;\n\t\tebitmap_destroy(&usrdatum->roles);\n\t\tebitmap_destroy(&usrdatum->range.level[0].cat);\n\t\tebitmap_destroy(&usrdatum->range.level[1].cat);\n\t\tebitmap_destroy(&usrdatum->dfltlevel.cat);\n\t}\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int sens_destroy(void *key, void *datum, void *p)\n{\n\tstruct level_datum *levdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tlevdatum = datum;\n\t\tif (levdatum->level)\n\t\t\tebitmap_destroy(&levdatum->level->cat);\n\t\tkfree(levdatum->level);\n\t}\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int cat_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic int (*const destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) = {\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};\n\nstatic int filenametr_destroy(void *key, void *datum, void *p)\n{\n\tstruct filename_trans_key *ft = key;\n\tstruct filename_trans_datum *next, *d = datum;\n\n\tkfree(ft->name);\n\tkfree(key);\n\tdo {\n\t\tebitmap_destroy(&d->stypes);\n\t\tnext = d->next;\n\t\tkfree(d);\n\t\td = next;\n\t} while (unlikely(d));\n\tcond_resched();\n\treturn 0;\n}\n\nstatic int range_tr_destroy(void *key, void *datum, void *p)\n{\n\tstruct mls_range *rt = datum;\n\n\tkfree(key);\n\tebitmap_destroy(&rt->level[0].cat);\n\tebitmap_destroy(&rt->level[1].cat);\n\tkfree(datum);\n\tcond_resched();\n\treturn 0;\n}\n\nstatic int role_tr_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}\n\nstatic void ocontext_destroy(struct ocontext *c, unsigned int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}\n\n \nstatic int roles_init(struct policydb *p)\n{\n\tchar *key = NULL;\n\tint rc;\n\tstruct role_datum *role;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\trc = -EINVAL;\n\trole->value = ++p->p_roles.nprim;\n\tif (role->value != OBJECT_R_VAL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tkey = kstrdup(OBJECT_R, GFP_KERNEL);\n\tif (!key)\n\t\tgoto out;\n\n\trc = symtab_insert(&p->p_roles, key, role);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(key);\n\tkfree(role);\n\treturn rc;\n}\n\nstatic u32 filenametr_hash(const void *k)\n{\n\tconst struct filename_trans_key *ft = k;\n\tunsigned long hash;\n\tunsigned int byte_num;\n\tunsigned char focus;\n\n\thash = ft->ttype ^ ft->tclass;\n\n\tbyte_num = 0;\n\twhile ((focus = ft->name[byte_num++]))\n\t\thash = partial_name_hash(focus, hash);\n\treturn hash;\n}\n\nstatic int filenametr_cmp(const void *k1, const void *k2)\n{\n\tconst struct filename_trans_key *ft1 = k1;\n\tconst struct filename_trans_key *ft2 = k2;\n\tint v;\n\n\tv = ft1->ttype - ft2->ttype;\n\tif (v)\n\t\treturn v;\n\n\tv = ft1->tclass - ft2->tclass;\n\tif (v)\n\t\treturn v;\n\n\treturn strcmp(ft1->name, ft2->name);\n\n}\n\nstatic const struct hashtab_key_params filenametr_key_params = {\n\t.hash = filenametr_hash,\n\t.cmp = filenametr_cmp,\n};\n\nstruct filename_trans_datum *policydb_filenametr_search(\n\tstruct policydb *p, struct filename_trans_key *key)\n{\n\treturn hashtab_search(&p->filename_trans, key, filenametr_key_params);\n}\n\nstatic u32 rangetr_hash(const void *k)\n{\n\tconst struct range_trans *key = k;\n\n\treturn key->source_type + (key->target_type << 3) +\n\t\t(key->target_class << 5);\n}\n\nstatic int rangetr_cmp(const void *k1, const void *k2)\n{\n\tconst struct range_trans *key1 = k1, *key2 = k2;\n\tint v;\n\n\tv = key1->source_type - key2->source_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_type - key2->target_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_class - key2->target_class;\n\n\treturn v;\n}\n\nstatic const struct hashtab_key_params rangetr_key_params = {\n\t.hash = rangetr_hash,\n\t.cmp = rangetr_cmp,\n};\n\nstruct mls_range *policydb_rangetr_search(struct policydb *p,\n\t\t\t\t\t  struct range_trans *key)\n{\n\treturn hashtab_search(&p->range_tr, key, rangetr_key_params);\n}\n\nstatic u32 role_trans_hash(const void *k)\n{\n\tconst struct role_trans_key *key = k;\n\n\treturn key->role + (key->type << 3) + (key->tclass << 5);\n}\n\nstatic int role_trans_cmp(const void *k1, const void *k2)\n{\n\tconst struct role_trans_key *key1 = k1, *key2 = k2;\n\tint v;\n\n\tv = key1->role - key2->role;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->type - key2->type;\n\tif (v)\n\t\treturn v;\n\n\treturn key1->tclass - key2->tclass;\n}\n\nstatic const struct hashtab_key_params roletr_key_params = {\n\t.hash = role_trans_hash,\n\t.cmp = role_trans_cmp,\n};\n\nstruct role_trans_datum *policydb_roletr_search(struct policydb *p,\n\t\t\t\t\t\tstruct role_trans_key *key)\n{\n\treturn hashtab_search(&p->role_tr, key, roletr_key_params);\n}\n\n \nstatic void policydb_init(struct policydb *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\n\tavtab_init(&p->te_avtab);\n\tcond_policydb_init(p);\n\n\tebitmap_init(&p->filename_trans_ttypes);\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n}\n\n \n\nstatic int common_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct common_datum *comdatum;\n\n\tcomdatum = datum;\n\tp = datap;\n\tif (!comdatum->value || comdatum->value > p->p_commons.nprim)\n\t\treturn -EINVAL;\n\n\tp->sym_val_to_name[SYM_COMMONS][comdatum->value - 1] = key;\n\n\treturn 0;\n}\n\nstatic int class_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct class_datum *cladatum;\n\n\tcladatum = datum;\n\tp = datap;\n\tif (!cladatum->value || cladatum->value > p->p_classes.nprim)\n\t\treturn -EINVAL;\n\n\tp->sym_val_to_name[SYM_CLASSES][cladatum->value - 1] = key;\n\tp->class_val_to_struct[cladatum->value - 1] = cladatum;\n\treturn 0;\n}\n\nstatic int role_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct role_datum *role;\n\n\trole = datum;\n\tp = datap;\n\tif (!role->value\n\t    || role->value > p->p_roles.nprim\n\t    || role->bounds > p->p_roles.nprim)\n\t\treturn -EINVAL;\n\n\tp->sym_val_to_name[SYM_ROLES][role->value - 1] = key;\n\tp->role_val_to_struct[role->value - 1] = role;\n\treturn 0;\n}\n\nstatic int type_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct type_datum *typdatum;\n\n\ttypdatum = datum;\n\tp = datap;\n\n\tif (typdatum->primary) {\n\t\tif (!typdatum->value\n\t\t    || typdatum->value > p->p_types.nprim\n\t\t    || typdatum->bounds > p->p_types.nprim)\n\t\t\treturn -EINVAL;\n\t\tp->sym_val_to_name[SYM_TYPES][typdatum->value - 1] = key;\n\t\tp->type_val_to_struct[typdatum->value - 1] = typdatum;\n\t}\n\n\treturn 0;\n}\n\nstatic int user_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct user_datum *usrdatum;\n\n\tusrdatum = datum;\n\tp = datap;\n\tif (!usrdatum->value\n\t    || usrdatum->value > p->p_users.nprim\n\t    || usrdatum->bounds > p->p_users.nprim)\n\t\treturn -EINVAL;\n\n\tp->sym_val_to_name[SYM_USERS][usrdatum->value - 1] = key;\n\tp->user_val_to_struct[usrdatum->value - 1] = usrdatum;\n\treturn 0;\n}\n\nstatic int sens_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct level_datum *levdatum;\n\n\tlevdatum = datum;\n\tp = datap;\n\n\tif (!levdatum->isalias) {\n\t\tif (!levdatum->level->sens ||\n\t\t    levdatum->level->sens > p->p_levels.nprim)\n\t\t\treturn -EINVAL;\n\n\t\tp->sym_val_to_name[SYM_LEVELS][levdatum->level->sens - 1] = key;\n\t}\n\n\treturn 0;\n}\n\nstatic int cat_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cat_datum *catdatum;\n\n\tcatdatum = datum;\n\tp = datap;\n\n\tif (!catdatum->isalias) {\n\t\tif (!catdatum->value || catdatum->value > p->p_cats.nprim)\n\t\t\treturn -EINVAL;\n\n\t\tp->sym_val_to_name[SYM_CATS][catdatum->value - 1] = key;\n\t}\n\n\treturn 0;\n}\n\nstatic int (*const index_f[SYM_NUM]) (void *key, void *datum, void *datap) = {\n\tcommon_index,\n\tclass_index,\n\trole_index,\n\ttype_index,\n\tuser_index,\n\tcond_index_bool,\n\tsens_index,\n\tcat_index,\n};\n\n#ifdef CONFIG_SECURITY_SELINUX_DEBUG\nstatic void hash_eval(struct hashtab *h, const char *hash_name)\n{\n\tstruct hashtab_info info;\n\n\thashtab_stat(h, &info);\n\tpr_debug(\"SELinux: %s:  %d entries and %d/%d buckets used, longest chain length %d\\n\",\n\t\t hash_name, h->nel, info.slots_used, h->size,\n\t\t info.max_chain_len);\n}\n\nstatic void symtab_hash_eval(struct symtab *s)\n{\n\tint i;\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thash_eval(&s[i].table, symtab_name[i]);\n}\n\n#else\nstatic inline void hash_eval(struct hashtab *h, const char *hash_name)\n{\n}\nstatic inline void symtab_hash_eval(struct symtab *s)\n{\n}\n#endif  \n\n \nstatic int policydb_index(struct policydb *p)\n{\n\tint i, rc;\n\n\tif (p->mls_enabled)\n\t\tpr_debug(\"SELinux:  %d users, %d roles, %d types, %d bools, %d sens, %d cats\\n\",\n\t\t\t p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim,\n\t\t\t p->p_bools.nprim, p->p_levels.nprim, p->p_cats.nprim);\n\telse\n\t\tpr_debug(\"SELinux:  %d users, %d roles, %d types, %d bools\\n\",\n\t\t\t p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim,\n\t\t\t p->p_bools.nprim);\n\n\tpr_debug(\"SELinux:  %d classes, %d rules\\n\",\n\t\t p->p_classes.nprim, p->te_avtab.nel);\n\n\tavtab_hash_eval(&p->te_avtab, \"rules\");\n\tsymtab_hash_eval(p->symtab);\n\n\tp->class_val_to_struct = kcalloc(p->p_classes.nprim,\n\t\t\t\t\t sizeof(*p->class_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->class_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->role_val_to_struct = kcalloc(p->p_roles.nprim,\n\t\t\t\t\tsizeof(*p->role_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->role_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->user_val_to_struct = kcalloc(p->p_users.nprim,\n\t\t\t\t\tsizeof(*p->user_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->user_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->type_val_to_struct = kvcalloc(p->p_types.nprim,\n\t\t\t\t\t sizeof(*p->type_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->type_val_to_struct)\n\t\treturn -ENOMEM;\n\n\trc = cond_init_bool_indexes(p);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = kvcalloc(p->symtab[i].nprim,\n\t\t\t\t\t\t sizeof(char *),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!p->sym_val_to_name[i])\n\t\t\treturn -ENOMEM;\n\n\t\trc = hashtab_map(&p->symtab[i].table, index_f[i], p);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nvoid policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tu32 i;\n\tstruct role_allow *ra, *lra = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(&p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(&p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\tkvfree(p->sym_val_to_name[i]);\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tkvfree(p->type_val_to_struct);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\thashtab_map(&p->role_tr, role_tr_destroy, NULL);\n\thashtab_destroy(&p->role_tr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(&p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(&p->filename_trans);\n\n\thashtab_map(&p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(&p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++)\n\t\t\tebitmap_destroy(&p->type_attr_map_array[i]);\n\t\tkvfree(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}\n\n \nint policydb_load_isids(struct policydb *p, struct sidtab *s)\n{\n\tstruct ocontext *head, *c;\n\tint rc;\n\n\trc = sidtab_init(s);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  out of memory on SID table init\\n\");\n\t\treturn rc;\n\t}\n\n\thead = p->ocontexts[OCON_ISID];\n\tfor (c = head; c; c = c->next) {\n\t\tu32 sid = c->sid[0];\n\t\tconst char *name = security_get_initial_sid_context(sid);\n\n\t\tif (sid == SECSID_NULL) {\n\t\t\tpr_err(\"SELinux:  SID 0 was assigned a context.\\n\");\n\t\t\tsidtab_destroy(s);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\trc = sidtab_set_initial(s, sid, &c->context[0]);\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux:  unable to load initial SID %s.\\n\",\n\t\t\t       name);\n\t\t\tsidtab_destroy(s);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}\n\nint policydb_role_isvalid(struct policydb *p, unsigned int role)\n{\n\tif (!role || role > p->p_roles.nprim)\n\t\treturn 0;\n\treturn 1;\n}\n\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t \n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t \n\t\t\treturn 0;\n\n\t\t \n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t \n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tpr_err(\"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tpr_err(\"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tpr_err(\"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}\n\n \nstatic int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tpr_err(\"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tpr_err(\"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tpr_err(\"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags | __GFP_NOWARN);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(str, fp, len);\n\tif (rc) {\n\t\tkfree(str);\n\t\treturn rc;\n\t}\n\n\tstr[len] = '\\0';\n\t*strp = str;\n\treturn 0;\n}\n\nstatic int perm_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = symtab_insert(s, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}\n\nstatic int common_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct common_datum *comdatum;\n\t__le32 buf[4];\n\tu32 i, len, nel;\n\tint rc;\n\n\tcomdatum = kzalloc(sizeof(*comdatum), GFP_KERNEL);\n\tif (!comdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcomdatum->value = le32_to_cpu(buf[1]);\n\tnel = le32_to_cpu(buf[3]);\n\n\trc = symtab_init(&comdatum->permissions, nel);\n\tif (rc)\n\t\tgoto bad;\n\tcomdatum->permissions.nprim = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, &comdatum->permissions, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = symtab_insert(s, key, comdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcommon_destroy(key, comdatum, NULL);\n\treturn rc;\n}\n\nstatic void type_set_init(struct type_set *t)\n{\n\tebitmap_init(&t->types);\n\tebitmap_init(&t->negset);\n}\n\nstatic int type_set_read(struct type_set *t, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (ebitmap_read(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_read(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tt->flags = le32_to_cpu(buf[0]);\n\n\treturn 0;\n}\n\n\nstatic int read_cons_helper(struct policydb *p,\n\t\t\t\tstruct constraint_node **nodep,\n\t\t\t\tu32 ncons, int allowxtarget, void *fp)\n{\n\tstruct constraint_node *c, *lc;\n\tstruct constraint_expr *e, *le;\n\t__le32 buf[3];\n\tu32 i, j, nexpr;\n\tint rc, depth;\n\n\tlc = NULL;\n\tfor (i = 0; i < ncons; i++) {\n\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tif (lc)\n\t\t\tlc->next = c;\n\t\telse\n\t\t\t*nodep = c;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tc->permissions = le32_to_cpu(buf[0]);\n\t\tnexpr = le32_to_cpu(buf[1]);\n\t\tle = NULL;\n\t\tdepth = -1;\n\t\tfor (j = 0; j < nexpr; j++) {\n\t\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (le)\n\t\t\t\tle->next = e;\n\t\t\telse\n\t\t\t\tc->expr = e;\n\n\t\t\trc = next_entry(buf, fp, (sizeof(u32) * 3));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\te->expr_type = le32_to_cpu(buf[0]);\n\t\t\te->attr = le32_to_cpu(buf[1]);\n\t\t\te->op = le32_to_cpu(buf[2]);\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NOT:\n\t\t\t\tif (depth < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_AND:\n\t\t\tcase CEXPR_OR:\n\t\t\t\tif (depth < 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth--;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ATTR:\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\tif (!allowxtarget && (e->attr & CEXPR_XTARGET))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\trc = ebitmap_read(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t    POLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\te->type_names = kzalloc(sizeof\n\t\t\t\t\t\t(*e->type_names), GFP_KERNEL);\n\t\t\t\t\tif (!e->type_names)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\ttype_set_init(e->type_names);\n\t\t\t\t\trc = type_set_read(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tle = e;\n\t\t}\n\t\tif (depth != 0)\n\t\t\treturn -EINVAL;\n\t\tlc = c;\n\t}\n\n\treturn 0;\n}\n\nstatic int class_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct class_datum *cladatum;\n\t__le32 buf[6];\n\tu32 i, len, len2, ncons, nel;\n\tint rc;\n\n\tcladatum = kzalloc(sizeof(*cladatum), GFP_KERNEL);\n\tif (!cladatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof(u32)*6);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlen2 = le32_to_cpu(buf[1]);\n\tcladatum->value = le32_to_cpu(buf[2]);\n\tnel = le32_to_cpu(buf[4]);\n\n\trc = symtab_init(&cladatum->permissions, nel);\n\tif (rc)\n\t\tgoto bad;\n\tcladatum->permissions.nprim = le32_to_cpu(buf[3]);\n\n\tncons = le32_to_cpu(buf[5]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (len2) {\n\t\trc = str_read(&cladatum->comkey, GFP_KERNEL, fp, len2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tcladatum->comdatum = symtab_search(&p->p_commons,\n\t\t\t\t\t\t   cladatum->comkey);\n\t\tif (!cladatum->comdatum) {\n\t\t\tpr_err(\"SELinux:  unknown common %s\\n\",\n\t\t\t       cladatum->comkey);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, &cladatum->permissions, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = read_cons_helper(p, &cladatum->constraints, ncons, 0, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_VALIDATETRANS) {\n\t\t \n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tncons = le32_to_cpu(buf[0]);\n\t\trc = read_cons_helper(p, &cladatum->validatetrans,\n\t\t\t\tncons, 1, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\tcladatum->default_user = le32_to_cpu(buf[0]);\n\t\tcladatum->default_role = le32_to_cpu(buf[1]);\n\t\tcladatum->default_range = le32_to_cpu(buf[2]);\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tcladatum->default_type = le32_to_cpu(buf[0]);\n\t}\n\n\trc = symtab_insert(s, key, cladatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tcls_destroy(key, cladatum, NULL);\n\treturn rc;\n}\n\nstatic int role_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct role_datum *role;\n\tint rc;\n\tunsigned int to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\trole->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\trole->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->dominates, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->types, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (strcmp(key, OBJECT_R) == 0) {\n\t\trc = -EINVAL;\n\t\tif (role->value != OBJECT_R_VAL) {\n\t\t\tpr_err(\"SELinux: Role %s has wrong value %d\\n\",\n\t\t\t       OBJECT_R, role->value);\n\t\t\tgoto bad;\n\t\t}\n\t\trc = 0;\n\t\tgoto bad;\n\t}\n\n\trc = symtab_insert(s, key, role);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\trole_destroy(key, role, NULL);\n\treturn rc;\n}\n\nstatic int type_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct type_datum *typdatum;\n\tint rc;\n\tunsigned int to_read = 3;\n\t__le32 buf[4];\n\tu32 len;\n\n\ttypdatum = kzalloc(sizeof(*typdatum), GFP_KERNEL);\n\tif (!typdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 4;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\ttypdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 prop = le32_to_cpu(buf[2]);\n\n\t\tif (prop & TYPEDATUM_PROPERTY_PRIMARY)\n\t\t\ttypdatum->primary = 1;\n\t\tif (prop & TYPEDATUM_PROPERTY_ATTRIBUTE)\n\t\t\ttypdatum->attribute = 1;\n\n\t\ttypdatum->bounds = le32_to_cpu(buf[3]);\n\t} else {\n\t\ttypdatum->primary = le32_to_cpu(buf[2]);\n\t}\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = symtab_insert(s, key, typdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\ttype_destroy(key, typdatum, NULL);\n\treturn rc;\n}\n\n\n \nstatic int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tpr_err(\"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tpr_err(\"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int user_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct user_datum *usrdatum;\n\tint rc;\n\tunsigned int to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\tusrdatum = kzalloc(sizeof(*usrdatum), GFP_KERNEL);\n\tif (!usrdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tusrdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tusrdatum->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&usrdatum->roles, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&usrdatum->range, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\trc = mls_read_level(&usrdatum->dfltlevel, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = symtab_insert(s, key, usrdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tuser_destroy(key, usrdatum, NULL);\n\treturn rc;\n}\n\nstatic int sens_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct level_datum *levdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tlevdatum = kzalloc(sizeof(*levdatum), GFP_KERNEL);\n\tif (!levdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlevdatum->isalias = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tlevdatum->level = kmalloc(sizeof(*levdatum->level), GFP_KERNEL);\n\tif (!levdatum->level)\n\t\tgoto bad;\n\n\trc = mls_read_level(levdatum->level, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = symtab_insert(s, key, levdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tsens_destroy(key, levdatum, NULL);\n\treturn rc;\n}\n\nstatic int cat_read(struct policydb *p, struct symtab *s, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cat_datum *catdatum;\n\tint rc;\n\t__le32 buf[3];\n\tu32 len;\n\n\tcatdatum = kzalloc(sizeof(*catdatum), GFP_KERNEL);\n\tif (!catdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcatdatum->value = le32_to_cpu(buf[1]);\n\tcatdatum->isalias = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = symtab_insert(s, key, catdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcat_destroy(key, catdatum, NULL);\n\treturn rc;\n}\n\nstatic int (*const read_f[SYM_NUM]) (struct policydb *p,\n\t\t\t\t     struct symtab *s, void *fp) = {\n\tcommon_read,\n\tclass_read,\n\trole_read,\n\ttype_read,\n\tuser_read,\n\tcond_read_bool,\n\tsens_read,\n\tcat_read,\n};\n\nstatic int user_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct user_datum *upper, *user;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = user = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tu32 bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tpr_err(\"SELinux: user %s: \"\n\t\t\t       \"too deep or looped boundary\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->user_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&user->roles, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->roles, bit))\n\t\t\t\tcontinue;\n\n\t\t\tpr_err(\"SELinux: boundary violated policy: \"\n\t\t\t       \"user=%s role=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_USERS, user->value - 1),\n\t\t\t       sym_name(p, SYM_ROLES, bit),\n\t\t\t       sym_name(p, SYM_USERS, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int role_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct role_datum *upper, *role;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = role = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tu32 bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tpr_err(\"SELinux: role %s: \"\n\t\t\t       \"too deep or looped bounds\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->role_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&role->types, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->types, bit))\n\t\t\t\tcontinue;\n\n\t\t\tpr_err(\"SELinux: boundary violated policy: \"\n\t\t\t       \"role=%s type=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_ROLES, role->value - 1),\n\t\t\t       sym_name(p, SYM_TYPES, bit),\n\t\t\t       sym_name(p, SYM_ROLES, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int type_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct type_datum *upper;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = datum;\n\twhile (upper->bounds) {\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tpr_err(\"SELinux: type %s: \"\n\t\t\t       \"too deep or looped boundary\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->type_val_to_struct[upper->bounds - 1];\n\t\tBUG_ON(!upper);\n\n\t\tif (upper->attribute) {\n\t\t\tpr_err(\"SELinux: type %s: \"\n\t\t\t       \"bounded by attribute %s\\n\",\n\t\t\t       (char *) key,\n\t\t\t       sym_name(p, SYM_TYPES, upper->value - 1));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int policydb_bounds_sanity_check(struct policydb *p)\n{\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\n\t\treturn 0;\n\n\trc = hashtab_map(&p->p_users.table, user_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(&p->p_roles.table, role_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(&p->p_types.table, type_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nu16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = symtab_search(&p->p_classes, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}\n\nu32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = symtab_search(&comdatum->permissions, name);\n\tif (!perdatum)\n\t\tperdatum = symtab_search(&cladatum->permissions, name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}\n\nstatic int range_read(struct policydb *p, void *fp)\n{\n\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint rc;\n\t__le32 buf[2];\n\tu32 i, nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\n\trc = hashtab_init(&p->range_tr, nel);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\t\tif (!rt)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt->source_type = le32_to_cpu(buf[0]);\n\t\trt->target_type = le32_to_cpu(buf[1]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trt->target_class = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trt->target_class = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_type_isvalid(p, rt->source_type) ||\n\t\t    !policydb_type_isvalid(p, rt->target_type) ||\n\t\t    !policydb_class_isvalid(p, rt->target_class))\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\t\tif (!r)\n\t\t\tgoto out;\n\n\t\trc = mls_read_range_helper(r, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = -EINVAL;\n\t\tif (!mls_range_isvalid(p, r)) {\n\t\t\tpr_warn(\"SELinux:  rangetrans:  invalid range\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = hashtab_insert(&p->range_tr, rt, r, rangetr_key_params);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt = NULL;\n\t\tr = NULL;\n\t}\n\thash_eval(&p->range_tr, \"rangetr\");\n\trc = 0;\nout:\n\tkfree(rt);\n\tkfree(r);\n\treturn rc;\n}\n\nstatic int filename_trans_read_helper_compat(struct policydb *p, void *fp)\n{\n\tstruct filename_trans_key key, *ft = NULL;\n\tstruct filename_trans_datum *last, *datum = NULL;\n\tchar *name = NULL;\n\tu32 len, stype, otype;\n\t__le32 buf[4];\n\tint rc;\n\n\t \n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tlen = le32_to_cpu(buf[0]);\n\n\t \n\trc = str_read(&name, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\tif (rc)\n\t\tgoto out;\n\n\tstype = le32_to_cpu(buf[0]);\n\tkey.ttype = le32_to_cpu(buf[1]);\n\tkey.tclass = le32_to_cpu(buf[2]);\n\tkey.name = name;\n\n\totype = le32_to_cpu(buf[3]);\n\n\tlast = NULL;\n\tdatum = policydb_filenametr_search(p, &key);\n\twhile (datum) {\n\t\tif (unlikely(ebitmap_get_bit(&datum->stypes, stype - 1))) {\n\t\t\t \n\t\t\tdatum = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (likely(datum->otype == otype))\n\t\t\tbreak;\n\t\tlast = datum;\n\t\tdatum = datum->next;\n\t}\n\tif (!datum) {\n\t\trc = -ENOMEM;\n\t\tdatum = kmalloc(sizeof(*datum), GFP_KERNEL);\n\t\tif (!datum)\n\t\t\tgoto out;\n\n\t\tebitmap_init(&datum->stypes);\n\t\tdatum->otype = otype;\n\t\tdatum->next = NULL;\n\n\t\tif (unlikely(last)) {\n\t\t\tlast->next = datum;\n\t\t} else {\n\t\t\trc = -ENOMEM;\n\t\t\tft = kmemdup(&key, sizeof(key), GFP_KERNEL);\n\t\t\tif (!ft)\n\t\t\t\tgoto out;\n\n\t\t\trc = hashtab_insert(&p->filename_trans, ft, datum,\n\t\t\t\t\t    filenametr_key_params);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tname = NULL;\n\n\t\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes,\n\t\t\t\t\t     key.ttype, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\tkfree(name);\n\treturn ebitmap_set_bit(&datum->stypes, stype - 1, 1);\n\nout:\n\tkfree(ft);\n\tkfree(name);\n\tkfree(datum);\n\treturn rc;\n}\n\nstatic int filename_trans_read_helper(struct policydb *p, void *fp)\n{\n\tstruct filename_trans_key *ft = NULL;\n\tstruct filename_trans_datum **dst, *datum, *first = NULL;\n\tchar *name = NULL;\n\tu32 len, ttype, tclass, ndatum, i;\n\t__le32 buf[3];\n\tint rc;\n\n\t \n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tlen = le32_to_cpu(buf[0]);\n\n\t \n\trc = str_read(&name, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 3);\n\tif (rc)\n\t\tgoto out;\n\n\tttype = le32_to_cpu(buf[0]);\n\ttclass = le32_to_cpu(buf[1]);\n\n\tndatum = le32_to_cpu(buf[2]);\n\tif (ndatum == 0) {\n\t\tpr_err(\"SELinux:  Filename transition key with no datum\\n\");\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdst = &first;\n\tfor (i = 0; i < ndatum; i++) {\n\t\trc = -ENOMEM;\n\t\tdatum = kmalloc(sizeof(*datum), GFP_KERNEL);\n\t\tif (!datum)\n\t\t\tgoto out;\n\n\t\tdatum->next = NULL;\n\t\t*dst = datum;\n\n\t\t \n\t\trc = ebitmap_read(&datum->stypes, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tdatum->otype = le32_to_cpu(buf[0]);\n\n\t\tdst = &datum->next;\n\t}\n\n\trc = -ENOMEM;\n\tft = kmalloc(sizeof(*ft), GFP_KERNEL);\n\tif (!ft)\n\t\tgoto out;\n\n\tft->ttype = ttype;\n\tft->tclass = tclass;\n\tft->name = name;\n\n\trc = hashtab_insert(&p->filename_trans, ft, first,\n\t\t\t    filenametr_key_params);\n\tif (rc == -EEXIST)\n\t\tpr_err(\"SELinux:  Duplicate filename transition key\\n\");\n\tif (rc)\n\t\tgoto out;\n\n\treturn ebitmap_set_bit(&p->filename_trans_ttypes, ttype, 1);\n\nout:\n\tkfree(ft);\n\tkfree(name);\n\twhile (first) {\n\t\tdatum = first;\n\t\tfirst = first->next;\n\n\t\tebitmap_destroy(&datum->stypes);\n\t\tkfree(datum);\n\t}\n\treturn rc;\n}\n\nstatic int filename_trans_read(struct policydb *p, void *fp)\n{\n\tu32 nel, i;\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tif (p->policyvers < POLICYDB_VERSION_COMP_FTRANS) {\n\t\tp->compat_filename_trans_count = nel;\n\n\t\trc = hashtab_init(&p->filename_trans, (1 << 11));\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < nel; i++) {\n\t\t\trc = filename_trans_read_helper_compat(p, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\trc = hashtab_init(&p->filename_trans, nel);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < nel; i++) {\n\t\t\trc = filename_trans_read_helper(p, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\thash_eval(&p->filename_trans, \"filenametr\");\n\treturn 0;\n}\n\nstatic int genfs_read(struct policydb *p, void *fp)\n{\n\tint rc;\n\tu32 i, j, nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (genfs_p = NULL, genfs = p->genfs; genfs;\n\t\t     genfs_p = genfs, genfs = genfs->next) {\n\t\t\trc = -EINVAL;\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\n\t\t\t\tpr_err(\"SELinux:  dup genfs fstype %s\\n\",\n\t\t\t\t       newgenfs->fstype);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tnewgenfs->next = genfs;\n\t\tif (genfs_p)\n\t\t\tgenfs_p->next = newgenfs;\n\t\telse\n\t\t\tp->genfs = newgenfs;\n\t\tgenfs = newgenfs;\n\t\tnewgenfs = NULL;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tnel2 = le32_to_cpu(buf[0]);\n\t\tfor (j = 0; j < nel2; j++) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\trc = -ENOMEM;\n\t\t\tnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\n\t\t\tif (!newc)\n\t\t\t\tgoto out;\n\n\t\t\trc = str_read(&newc->u.name, GFP_KERNEL, fp, len);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tnewc->v.sclass = le32_to_cpu(buf[0]);\n\t\t\trc = context_read_and_validate(&newc->context[0], p, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tfor (l = NULL, c = genfs->head; c;\n\t\t\t     l = c, c = c->next) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tif (!strcmp(newc->u.name, c->u.name) &&\n\t\t\t\t    (!c->v.sclass || !newc->v.sclass ||\n\t\t\t\t     newc->v.sclass == c->v.sclass)) {\n\t\t\t\t\tpr_err(\"SELinux:  dup genfs entry (%s,%s)\\n\",\n\t\t\t\t\t       genfs->fstype, c->u.name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlen = strlen(newc->u.name);\n\t\t\t\tlen2 = strlen(c->u.name);\n\t\t\t\tif (len > len2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewc->next = c;\n\t\t\tif (l)\n\t\t\t\tl->next = newc;\n\t\t\telse\n\t\t\t\tgenfs->head = newc;\n\t\t\tnewc = NULL;\n\t\t}\n\t}\n\trc = 0;\nout:\n\tif (newgenfs) {\n\t\tkfree(newgenfs->fstype);\n\t\tkfree(newgenfs);\n\t}\n\tocontext_destroy(newc, OCON_FSUSE);\n\n\treturn rc;\n}\n\nstatic int ocontext_read(struct policydb *p, const struct policydb_compat_info *info,\n\t\t\t void *fp)\n{\n\tint rc;\n\tunsigned int i;\n\tu32 j, nel, len;\n\t__be64 prefixbuf[1];\n\t__le32 buf[3];\n\tstruct ocontext *l, *c;\n\tu32 nodebuf[8];\n\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tnel = le32_to_cpu(buf[0]);\n\n\t\tl = NULL;\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = -ENOMEM;\n\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\tif (!c)\n\t\t\t\tgoto out;\n\t\t\tif (l)\n\t\t\t\tl->next = c;\n\t\t\telse\n\t\t\t\tp->ocontexts[i] = c;\n\t\t\tl = c;\n\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->sid[0] = le32_to_cpu(buf[0]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (i == OCON_FS)\n\t\t\t\t\tpr_warn(\"SELinux:  void and deprecated fs ocon %s\\n\",\n\t\t\t\t\t\tc->u.name);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\trc = context_read_and_validate(&c->context[1], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.port.protocol = le32_to_cpu(buf[0]);\n\t\t\t\tc->u.port.low_port = le32_to_cpu(buf[1]);\n\t\t\t\tc->u.port.high_port = le32_to_cpu(buf[2]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.node.addr = nodebuf[0];  \n\t\t\t\tc->u.node.mask = nodebuf[1];  \n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tc->v.behavior = le32_to_cpu(buf[0]);\n\t\t\t\t \n\t\t\t\tif (c->v.behavior == SECURITY_FS_USE_MNTPOINT)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (c->v.behavior > SECURITY_FS_USE_MAX)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlen = le32_to_cpu(buf[1]);\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6: {\n\t\t\t\tint k;\n\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 8);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.addr[k] = nodebuf[k];\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.mask[k] = nodebuf[k+4];\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBPKEY: {\n\t\t\t\tu32 pkey_lo, pkey_hi;\n\n\t\t\t\trc = next_entry(prefixbuf, fp, sizeof(u64));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t \n\t\t\t\tc->u.ibpkey.subnet_prefix = be64_to_cpu(prefixbuf[0]);\n\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tpkey_lo = le32_to_cpu(buf[0]);\n\t\t\t\tpkey_hi = le32_to_cpu(buf[1]);\n\n\t\t\t\tif (pkey_lo > U16_MAX || pkey_hi > U16_MAX) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibpkey.low_pkey  = pkey_lo;\n\t\t\t\tc->u.ibpkey.high_pkey = pkey_hi;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBENDPORT: {\n\t\t\t\tu32 port;\n\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.ibendport.dev_name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tport = le32_to_cpu(buf[1]);\n\t\t\t\tif (port > U8_MAX || port == 0) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibendport.port = port;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}  \n\t\t\t}  \n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nint policydb_read(struct policydb *p, void *fp)\n{\n\tstruct role_allow *ra, *lra;\n\tstruct role_trans_key *rtk = NULL;\n\tstruct role_trans_datum *rtd = NULL;\n\tint rc;\n\t__le32 buf[4];\n\tu32 i, j, len, nprim, nel, perm;\n\n\tchar *policydb_str;\n\tconst struct policydb_compat_info *info;\n\n\tpolicydb_init(p);\n\n\t \n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\n\t\tpr_err(\"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_MAGIC);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tlen = le32_to_cpu(buf[1]);\n\tif (len != strlen(POLICYDB_STRING)) {\n\t\tpr_err(\"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\",\n\t\t       len, strlen(POLICYDB_STRING));\n\t\tgoto bad;\n\t}\n\n\trc = -ENOMEM;\n\tpolicydb_str = kmalloc(len + 1, GFP_KERNEL);\n\tif (!policydb_str) {\n\t\tpr_err(\"SELinux:  unable to allocate memory for policydb \"\n\t\t       \"string of length %d\\n\", len);\n\t\tgoto bad;\n\t}\n\n\trc = next_entry(policydb_str, fp, len);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  truncated policydb string identifier\\n\");\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tpolicydb_str[len] = '\\0';\n\tif (strcmp(policydb_str, POLICYDB_STRING)) {\n\t\tpr_err(\"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\", policydb_str, POLICYDB_STRING);\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\t \n\tkfree(policydb_str);\n\tpolicydb_str = NULL;\n\n\t \n\trc = next_entry(buf, fp, sizeof(u32)*4);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->policyvers = le32_to_cpu(buf[0]);\n\tif (p->policyvers < POLICYDB_VERSION_MIN ||\n\t    p->policyvers > POLICYDB_VERSION_MAX) {\n\t\tpr_err(\"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\n\t\tgoto bad;\n\t}\n\n\tif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\n\t\tp->mls_enabled = 1;\n\n\t\trc = -EINVAL;\n\t\tif (p->policyvers < POLICYDB_VERSION_MLS) {\n\t\t\tpr_err(\"SELinux: security policydb version %d \"\n\t\t\t\t\"(MLS) not backwards compatible\\n\",\n\t\t\t\tp->policyvers);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tp->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\n\tp->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_read(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_read(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tpr_err(\"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\", p->policyvers);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[2]) != info->sym_num ||\n\t\tle32_to_cpu(buf[3]) != info->ocon_num) {\n\t\tpr_err(\"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),\n\t\t\tle32_to_cpu(buf[3]),\n\t\t       info->sym_num, info->ocon_num);\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < info->sym_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tnprim = le32_to_cpu(buf[0]);\n\t\tnel = le32_to_cpu(buf[1]);\n\n\t\trc = symtab_init(&p->symtab[i], nel);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (i == SYM_ROLES) {\n\t\t\trc = roles_init(p);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = read_f[i](p, &p->symtab[i], fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tp->symtab[i].nprim = nprim;\n\t}\n\n\trc = -EINVAL;\n\tp->process_class = string_to_security_class(p, \"process\");\n\tif (!p->process_class) {\n\t\tpr_err(\"SELinux: process class is required, not defined in policy\\n\");\n\t\tgoto bad;\n\t}\n\n\trc = avtab_read(&p->te_avtab, fp, p);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOOL) {\n\t\trc = cond_read_list(p, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\n\trc = hashtab_init(&p->role_tr, nel);\n\tif (rc)\n\t\tgoto bad;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trtk = kmalloc(sizeof(*rtk), GFP_KERNEL);\n\t\tif (!rtk)\n\t\t\tgoto bad;\n\n\t\trc = -ENOMEM;\n\t\trtd = kmalloc(sizeof(*rtd), GFP_KERNEL);\n\t\tif (!rtd)\n\t\t\tgoto bad;\n\n\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trtk->role = le32_to_cpu(buf[0]);\n\t\trtk->type = le32_to_cpu(buf[1]);\n\t\trtd->new_role = le32_to_cpu(buf[2]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t\trtk->tclass = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trtk->tclass = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_role_isvalid(p, rtk->role) ||\n\t\t    !policydb_type_isvalid(p, rtk->type) ||\n\t\t    !policydb_class_isvalid(p, rtk->tclass) ||\n\t\t    !policydb_role_isvalid(p, rtd->new_role))\n\t\t\tgoto bad;\n\n\t\trc = hashtab_insert(&p->role_tr, rtk, rtd, roletr_key_params);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trtk = NULL;\n\t\trtd = NULL;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tlra = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (!ra)\n\t\t\tgoto bad;\n\t\tif (lra)\n\t\t\tlra->next = ra;\n\t\telse\n\t\t\tp->role_allow = ra;\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tra->role = le32_to_cpu(buf[0]);\n\t\tra->new_role = le32_to_cpu(buf[1]);\n\t\tif (!policydb_role_isvalid(p, ra->role) ||\n\t\t    !policydb_role_isvalid(p, ra->new_role))\n\t\t\tgoto bad;\n\t\tlra = ra;\n\t}\n\n\trc = filename_trans_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = policydb_index(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tperm = string_to_av_perm(p, p->process_class, \"transition\");\n\tif (!perm) {\n\t\tpr_err(\"SELinux: process transition permission is required, not defined in policy\\n\");\n\t\tgoto bad;\n\t}\n\tp->process_trans_perms = perm;\n\tperm = string_to_av_perm(p, p->process_class, \"dyntransition\");\n\tif (!perm) {\n\t\tpr_err(\"SELinux: process dyntransition permission is required, not defined in policy\\n\");\n\t\tgoto bad;\n\t}\n\tp->process_trans_perms |= perm;\n\n\trc = ocontext_read(p, info, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = genfs_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = range_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tp->type_attr_map_array = kvcalloc(p->p_types.nprim,\n\t\t\t\t\t  sizeof(*p->type_attr_map_array),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!p->type_attr_map_array)\n\t\tgoto bad;\n\n\t \n\tfor (i = 0; i < p->p_types.nprim; i++)\n\t\tebitmap_init(&p->type_attr_map_array[i]);\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = &p->type_attr_map_array[i];\n\n\t\tif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\n\t\t\trc = ebitmap_read(e, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\t\t \n\t\trc = ebitmap_set_bit(e, i, 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = policydb_bounds_sanity_check(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tkfree(rtk);\n\tkfree(rtd);\n\tpolicydb_destroy(p);\n\tgoto out;\n}\n\n \nstatic int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int sens_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct level_datum *levdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(levdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(levdatum->level, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int cat_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cat_datum *catdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(catdatum->value);\n\tbuf[2] = cpu_to_le32(catdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int role_trans_write_one(void *key, void *datum, void *ptr)\n{\n\tstruct role_trans_key *rtk = key;\n\tstruct role_trans_datum *rtd = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\t__le32 buf[3];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(rtk->role);\n\tbuf[1] = cpu_to_le32(rtk->type);\n\tbuf[2] = cpu_to_le32(rtd->new_role);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\tbuf[0] = cpu_to_le32(rtk->tclass);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int role_trans_write(struct policydb *p, void *fp)\n{\n\tstruct policy_data pd = { .p = p, .fp = fp };\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(p->role_tr.nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn hashtab_map(&p->role_tr, role_trans_write_one, &pd);\n}\n\nstatic int role_allow_write(struct role_allow *r, void *fp)\n{\n\tstruct role_allow *ra;\n\t__le32 buf[2];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (ra = r; ra; ra = ra->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (ra = r; ra; ra = ra->next) {\n\t\tbuf[0] = cpu_to_le32(ra->role);\n\t\tbuf[1] = cpu_to_le32(ra->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\n \nstatic int context_write(struct policydb *p, struct context *c,\n\t\t\t void *fp)\n{\n\tint rc;\n\t__le32 buf[3];\n\n\tbuf[0] = cpu_to_le32(c->user);\n\tbuf[1] = cpu_to_le32(c->role);\n\tbuf[2] = cpu_to_le32(c->type);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&c->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \n\nstatic int perm_write(void *vkey, void *datum, void *fp)\n{\n\tchar *key = vkey;\n\tstruct perm_datum *perdatum = datum;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(perdatum->value);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int common_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct common_datum *comdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(comdatum->value);\n\tbuf[2] = cpu_to_le32(comdatum->permissions.nprim);\n\tbuf[3] = cpu_to_le32(comdatum->permissions.table.nel);\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(&comdatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int type_set_write(struct type_set *t, void *fp)\n{\n\tint rc;\n\t__le32 buf[1];\n\n\tif (ebitmap_write(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_write(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\tbuf[0] = cpu_to_le32(t->flags);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int write_cons_helper(struct policydb *p, struct constraint_node *node,\n\t\t\t     void *fp)\n{\n\tstruct constraint_node *c;\n\tstruct constraint_expr *e;\n\t__le32 buf[3];\n\tu32 nel;\n\tint rc;\n\n\tfor (c = node; c; c = c->next) {\n\t\tnel = 0;\n\t\tfor (e = c->expr; e; e = e->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(c->permissions);\n\t\tbuf[1] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (e = c->expr; e; e = e->next) {\n\t\t\tbuf[0] = cpu_to_le32(e->expr_type);\n\t\t\tbuf[1] = cpu_to_le32(e->attr);\n\t\t\tbuf[2] = cpu_to_le32(e->op);\n\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\trc = ebitmap_write(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\trc = type_set_write(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int class_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct class_datum *cladatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tstruct constraint_node *c;\n\t__le32 buf[6];\n\tu32 ncons;\n\tsize_t len, len2;\n\tint rc;\n\n\tlen = strlen(key);\n\tif (cladatum->comkey)\n\t\tlen2 = strlen(cladatum->comkey);\n\telse\n\t\tlen2 = 0;\n\n\tncons = 0;\n\tfor (c = cladatum->constraints; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(len2);\n\tbuf[2] = cpu_to_le32(cladatum->value);\n\tbuf[3] = cpu_to_le32(cladatum->permissions.nprim);\n\tbuf[4] = cpu_to_le32(cladatum->permissions.table.nel);\n\tbuf[5] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 6, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cladatum->comkey) {\n\t\trc = put_entry(cladatum->comkey, 1, len2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = hashtab_map(&cladatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->constraints, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tncons = 0;\n\tfor (c = cladatum->validatetrans; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->validatetrans, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_user);\n\t\tbuf[1] = cpu_to_le32(cladatum->default_role);\n\t\tbuf[2] = cpu_to_le32(cladatum->default_range);\n\n\t\trc = put_entry(buf, sizeof(uint32_t), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_type);\n\t\trc = put_entry(buf, sizeof(uint32_t), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int role_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct role_datum *role = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(role->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(role->bounds);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->dominates, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->types, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int type_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct type_datum *typdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tint rc;\n\tsize_t items, len;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(typdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 properties = 0;\n\n\t\tif (typdatum->primary)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_PRIMARY;\n\n\t\tif (typdatum->attribute)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_ATTRIBUTE;\n\n\t\tbuf[items++] = cpu_to_le32(properties);\n\t\tbuf[items++] = cpu_to_le32(typdatum->bounds);\n\t} else {\n\t\tbuf[items++] = cpu_to_le32(typdatum->primary);\n\t}\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int user_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct user_datum *usrdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(usrdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(usrdatum->bounds);\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&usrdatum->roles, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&usrdatum->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(&usrdatum->dfltlevel, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int (*const write_f[SYM_NUM]) (void *key, void *datum, void *datap) = {\n\tcommon_write,\n\tclass_write,\n\trole_write,\n\ttype_write,\n\tuser_write,\n\tcond_write_bool,\n\tsens_write,\n\tcat_write,\n};\n\nstatic int ocontext_write(struct policydb *p, const struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j;\n\tint rc;\n\tsize_t nel, len;\n\t__be64 prefixbuf[1];\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr;  \n\t\t\t\tnodebuf[1] = c->u.node.mask;  \n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j];  \n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j];  \n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t \n\t\t\t\tprefixbuf[0] = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\trc = put_entry(prefixbuf, sizeof(u64), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int genfs_write(struct policydb *p, void *fp)\n{\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tsize_t len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next) {\n\t\tlen = strlen(genfs->fstype);\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(genfs->fstype, 1, len, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlen = 0;\n\t\tfor (c = genfs->head; c; c = c->next)\n\t\t\tlen++;\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = genfs->head; c; c = c->next) {\n\t\t\tlen = strlen(c->u.name);\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbuf[0] = cpu_to_le32(c->v.sclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int range_write_helper(void *key, void *data, void *ptr)\n{\n\t__le32 buf[2];\n\tstruct range_trans *rt = key;\n\tstruct mls_range *r = data;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(rt->source_type);\n\tbuf[1] = cpu_to_le32(rt->target_type);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\tbuf[0] = cpu_to_le32(rt->target_class);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = mls_write_range_helper(r, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int range_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\tstruct policy_data pd;\n\n\tpd.p = p;\n\tpd.fp = fp;\n\n\tbuf[0] = cpu_to_le32(p->range_tr.nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = hashtab_map(&p->range_tr, range_write_helper, &pd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int filename_write_helper_compat(void *key, void *data, void *ptr)\n{\n\tstruct filename_trans_key *ft = key;\n\tstruct filename_trans_datum *datum = data;\n\tstruct ebitmap_node *node;\n\tvoid *fp = ptr;\n\t__le32 buf[4];\n\tint rc;\n\tu32 bit, len = strlen(ft->name);\n\n\tdo {\n\t\tebitmap_for_each_positive_bit(&datum->stypes, node, bit) {\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\trc = put_entry(ft->name, sizeof(char), len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf[0] = cpu_to_le32(bit + 1);\n\t\t\tbuf[1] = cpu_to_le32(ft->ttype);\n\t\t\tbuf[2] = cpu_to_le32(ft->tclass);\n\t\t\tbuf[3] = cpu_to_le32(datum->otype);\n\n\t\t\trc = put_entry(buf, sizeof(u32), 4, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tdatum = datum->next;\n\t} while (unlikely(datum));\n\n\treturn 0;\n}\n\nstatic int filename_write_helper(void *key, void *data, void *ptr)\n{\n\tstruct filename_trans_key *ft = key;\n\tstruct filename_trans_datum *datum;\n\tvoid *fp = ptr;\n\t__le32 buf[3];\n\tint rc;\n\tu32 ndatum, len = strlen(ft->name);\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(ft->name, sizeof(char), len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tndatum = 0;\n\tdatum = data;\n\tdo {\n\t\tndatum++;\n\t\tdatum = datum->next;\n\t} while (unlikely(datum));\n\n\tbuf[0] = cpu_to_le32(ft->ttype);\n\tbuf[1] = cpu_to_le32(ft->tclass);\n\tbuf[2] = cpu_to_le32(ndatum);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tdatum = data;\n\tdo {\n\t\trc = ebitmap_write(&datum->stypes, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf[0] = cpu_to_le32(datum->otype);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tdatum = datum->next;\n\t} while (unlikely(datum));\n\n\treturn 0;\n}\n\nstatic int filename_trans_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\tif (p->policyvers < POLICYDB_VERSION_COMP_FTRANS) {\n\t\tbuf[0] = cpu_to_le32(p->compat_filename_trans_count);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = hashtab_map(&p->filename_trans,\n\t\t\t\t filename_write_helper_compat, fp);\n\t} else {\n\t\tbuf[0] = cpu_to_le32(p->filename_trans.nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = hashtab_map(&p->filename_trans, filename_write_helper, fp);\n\t}\n\treturn rc;\n}\n\n \nint policydb_write(struct policydb *p, void *fp)\n{\n\tunsigned int num_syms;\n\tint rc;\n\t__le32 buf[4];\n\tu32 config, i;\n\tsize_t len;\n\tconst struct policydb_compat_info *info;\n\n\t \n\tif (p->policyvers < POLICYDB_VERSION_AVTAB) {\n\t\tpr_err(\"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\", p->policyvers,\n\t\t       POLICYDB_VERSION_AVTAB);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = 0;\n\tif (p->mls_enabled)\n\t\tconfig |= POLICYDB_CONFIG_MLS;\n\n\tif (p->reject_unknown)\n\t\tconfig |= REJECT_UNKNOWN;\n\tif (p->allow_unknown)\n\t\tconfig |= ALLOW_UNKNOWN;\n\n\t \n\tbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\n\tlen = strlen(POLICYDB_STRING);\n\tbuf[1] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(POLICYDB_STRING, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tpr_err(\"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\\n\", p->policyvers);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = cpu_to_le32(p->policyvers);\n\tbuf[1] = cpu_to_le32(config);\n\tbuf[2] = cpu_to_le32(info->sym_num);\n\tbuf[3] = cpu_to_le32(info->ocon_num);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_write(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_write(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnum_syms = info->sym_num;\n\tfor (i = 0; i < num_syms; i++) {\n\t\tstruct policy_data pd;\n\n\t\tpd.fp = fp;\n\t\tpd.p = p;\n\n\t\tbuf[0] = cpu_to_le32(p->symtab[i].nprim);\n\t\tbuf[1] = cpu_to_le32(p->symtab[i].table.nel);\n\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = hashtab_map(&p->symtab[i].table, write_f[i], &pd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = avtab_write(p, &p->te_avtab, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cond_write_list(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_allow_write(p->role_allow, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = filename_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocontext_write(p, info, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genfs_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = range_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = &p->type_attr_map_array[i];\n\n\t\trc = ebitmap_write(e, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}