{
  "module_name": "mls.c",
  "hash_id": "87ab2c91c8c9eb00580dbe15884579be09eb386d4f8a2a663dc5bfc6fda7480b",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ss/mls.c",
  "human_readable_source": "\n \n \n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <net/netlabel.h>\n#include \"sidtab.h\"\n#include \"mls.h\"\n#include \"policydb.h\"\n#include \"services.h\"\n\n \nint mls_compute_context_len(struct policydb *p, struct context *context)\n{\n\tint i, l, len, head, prev;\n\tchar *nm;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!p->mls_enabled)\n\t\treturn 0;\n\n\tlen = 1;  \n\tfor (l = 0; l < 2; l++) {\n\t\tu32 index_sens = context->range.level[l].sens;\n\t\tlen += strlen(sym_name(p, SYM_LEVELS, index_sens - 1));\n\n\t\t \n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t \n\t\t\t\tif (head != prev) {\n\t\t\t\t\tnm = sym_name(p, SYM_CATS, prev);\n\t\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\t}\n\t\t\t\tnm = sym_name(p, SYM_CATS, i);\n\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t\tif (prev != head) {\n\t\t\tnm = sym_name(p, SYM_CATS, prev);\n\t\t\tlen += strlen(nm) + 1;\n\t\t}\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n \nvoid mls_sid_to_context(struct policydb *p,\n\t\t\tstruct context *context,\n\t\t\tchar **scontext)\n{\n\tchar *scontextp, *nm;\n\tint i, l, head, prev;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!p->mls_enabled)\n\t\treturn;\n\n\tscontextp = *scontext;\n\n\t*scontextp = ':';\n\tscontextp++;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tstrcpy(scontextp, sym_name(p, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1));\n\t\tscontextp += strlen(scontextp);\n\n\t\t \n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t \n\t\t\t\tif (prev != head) {\n\t\t\t\t\tif (prev - head > 1)\n\t\t\t\t\t\t*scontextp++ = '.';\n\t\t\t\t\telse\n\t\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\t\tnm = sym_name(p, SYM_CATS, prev);\n\t\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\t\tscontextp += strlen(nm);\n\t\t\t\t}\n\t\t\t\tif (prev < 0)\n\t\t\t\t\t*scontextp++ = ':';\n\t\t\t\telse\n\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\tnm = sym_name(p, SYM_CATS, i);\n\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\tscontextp += strlen(nm);\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\n\t\tif (prev != head) {\n\t\t\tif (prev - head > 1)\n\t\t\t\t*scontextp++ = '.';\n\t\t\telse\n\t\t\t\t*scontextp++ = ',';\n\t\t\tnm = sym_name(p, SYM_CATS, prev);\n\t\t\tstrcpy(scontextp, nm);\n\t\t\tscontextp += strlen(nm);\n\t\t}\n\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*scontextp++ = '-';\n\t\t}\n\t}\n\n\t*scontext = scontextp;\n}\n\nint mls_level_isvalid(struct policydb *p, struct mls_level *l)\n{\n\tstruct level_datum *levdatum;\n\n\tif (!l->sens || l->sens > p->p_levels.nprim)\n\t\treturn 0;\n\tlevdatum = symtab_search(&p->p_levels,\n\t\t\t\t sym_name(p, SYM_LEVELS, l->sens - 1));\n\tif (!levdatum)\n\t\treturn 0;\n\n\t \n\treturn ebitmap_contains(&levdatum->level->cat, &l->cat,\n\t\t\t\tp->p_cats.nprim);\n}\n\nint mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}\n\n \nint mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t \n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0;  \n\n\treturn 1;\n}\n\n \nint mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char *scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\tchar *sensitivity, *cur_cat, *next_cat, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tu32 i;\n\tint l, rc;\n\tchar *rangep[2];\n\n\tif (!pol->mls_enabled) {\n\t\t \n\t\tif (oldc && def_sid == SECSID_NULL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\treturn -EINVAL;\n\n\t\treturn mls_context_cpy(context, defcon);\n\t}\n\n\t \n\trangep[0] = scontext;\n\trangep[1] = strchr(scontext, '-');\n\tif (rangep[1]) {\n\t\trangep[1][0] = '\\0';\n\t\trangep[1]++;\n\t}\n\n\t \n\tfor (l = 0; l < 2; l++) {\n\t\t \n\t\tsensitivity = rangep[l];\n\t\tif (sensitivity == NULL)\n\t\t\tbreak;\n\t\tnext_cat = strchr(sensitivity, ':');\n\t\tif (next_cat)\n\t\t\t*(next_cat++) = '\\0';\n\n\t\t \n\t\tlevdatum = symtab_search(&pol->p_levels, sensitivity);\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\t \n\t\twhile (next_cat != NULL) {\n\t\t\tcur_cat = next_cat;\n\t\t\tnext_cat = strchr(next_cat, ',');\n\t\t\tif (next_cat != NULL)\n\t\t\t\t*(next_cat++) = '\\0';\n\n\t\t\t \n\t\t\trngptr = strchr(cur_cat, '.');\n\t\t\tif (rngptr != NULL) {\n\t\t\t\t \n\t\t\t\t*rngptr++ = '\\0';\n\t\t\t}\n\n\t\t\tcatdatum = symtab_search(&pol->p_cats, cur_cat);\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\tif (rngptr == NULL)\n\t\t\t\tcontinue;\n\n\t\t\trngdatum = symtab_search(&pol->p_cats, rngptr);\n\t\t\tif (!rngdatum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (catdatum->value >= rngdatum->value)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (rangep[1] == NULL) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nint mls_from_string(struct policydb *p, char *str, struct context *context,\n\t\t    gfp_t gfp_mask)\n{\n\tchar *tmpstr;\n\tint rc;\n\n\tif (!p->mls_enabled)\n\t\treturn -EINVAL;\n\n\ttmpstr = kstrdup(str, gfp_mask);\n\tif (!tmpstr) {\n\t\trc = -ENOMEM;\n\t} else {\n\t\trc = mls_context_to_sid(p, ':', tmpstr, context,\n\t\t\t\t\tNULL, SECSID_NULL);\n\t\tkfree(tmpstr);\n\t}\n\n\treturn rc;\n}\n\n \nint mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t \n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint mls_setup_user_range(struct policydb *p,\n\t\t\t struct context *fromcon, struct user_datum *user,\n\t\t\t struct context *usercon)\n{\n\tif (p->mls_enabled) {\n\t\tstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\n\t\tstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\n\t\tstruct mls_level *user_low = &(user->range.level[0]);\n\t\tstruct mls_level *user_clr = &(user->range.level[1]);\n\t\tstruct mls_level *user_def = &(user->dfltlevel);\n\t\tstruct mls_level *usercon_sen = &(usercon->range.level[0]);\n\t\tstruct mls_level *usercon_clr = &(usercon->range.level[1]);\n\n\t\t \n\t\tif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\n\t\t\t*usercon_sen = *user_def;\n\t\telse if (mls_level_between(fromcon_sen, user_def, user_clr))\n\t\t\t*usercon_sen = *fromcon_sen;\n\t\telse if (mls_level_between(fromcon_clr, user_low, user_def))\n\t\t\t*usercon_sen = *user_low;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (mls_level_dom(user_clr, fromcon_clr))\n\t\t\t*usercon_clr = *fromcon_clr;\n\t\telse if (mls_level_dom(fromcon_clr, user_clr))\n\t\t\t*usercon_clr = *user_clr;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint mls_convert_context(struct policydb *oldp,\n\t\t\tstruct policydb *newp,\n\t\t\tstruct context *oldc,\n\t\t\tstruct context *newc)\n{\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum;\n\tstruct ebitmap_node *node;\n\tu32 i;\n\tint l;\n\n\tif (!oldp->mls_enabled || !newp->mls_enabled)\n\t\treturn 0;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tchar *name = sym_name(oldp, SYM_LEVELS,\n\t\t\t\t      oldc->range.level[l].sens - 1);\n\n\t\tlevdatum = symtab_search(&newp->p_levels, name);\n\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tnewc->range.level[l].sens = levdatum->level->sens;\n\n\t\tebitmap_for_each_positive_bit(&oldc->range.level[l].cat,\n\t\t\t\t\t      node, i) {\n\t\t\tint rc;\n\n\t\t\tcatdatum = symtab_search(&newp->p_cats,\n\t\t\t\t\t\t sym_name(oldp, SYM_CATS, i));\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\t\t\trc = ebitmap_set_bit(&newc->range.level[l].cat,\n\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mls_compute_sid(struct policydb *p,\n\t\t    struct context *scontext,\n\t\t    struct context *tcontext,\n\t\t    u16 tclass,\n\t\t    u32 specified,\n\t\t    struct context *newcontext,\n\t\t    bool sock)\n{\n\tstruct range_trans rtr;\n\tstruct mls_range *r;\n\tstruct class_datum *cladatum;\n\tchar default_range = 0;\n\n\tif (!p->mls_enabled)\n\t\treturn 0;\n\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\t\t \n\t\trtr.source_type = scontext->type;\n\t\trtr.target_type = tcontext->type;\n\t\trtr.target_class = tclass;\n\t\tr = policydb_rangetr_search(p, &rtr);\n\t\tif (r)\n\t\t\treturn mls_range_set(newcontext, r);\n\n\t\tif (tclass && tclass <= p->p_classes.nprim) {\n\t\t\tcladatum = p->class_val_to_struct[tclass - 1];\n\t\t\tif (cladatum)\n\t\t\t\tdefault_range = cladatum->default_range;\n\t\t}\n\n\t\tswitch (default_range) {\n\t\tcase DEFAULT_SOURCE_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\tcase DEFAULT_TARGET_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, tcontext);\n\t\tcase DEFAULT_GLBLUB:\n\t\t\treturn mls_context_glblub(newcontext,\n\t\t\t\t\t\t  scontext, tcontext);\n\t\t}\n\n\t\tfallthrough;\n\tcase AVTAB_CHANGE:\n\t\tif ((tclass == p->process_class) || sock)\n\t\t\t \n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\telse\n\t\t\t \n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\tcase AVTAB_MEMBER:\n\t\t \n\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_NETLABEL\n \nvoid mls_export_netlbl_lvl(struct policydb *p,\n\t\t\t   struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!p->mls_enabled)\n\t\treturn;\n\n\tsecattr->attr.mls.lvl = context->range.level[0].sens - 1;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n}\n\n \nvoid mls_import_netlbl_lvl(struct policydb *p,\n\t\t\t   struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!p->mls_enabled)\n\t\treturn;\n\n\tcontext->range.level[0].sens = secattr->attr.mls.lvl + 1;\n\tcontext->range.level[1].sens = context->range.level[0].sens;\n}\n\n \nint mls_export_netlbl_cat(struct policydb *p,\n\t\t\t  struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!p->mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_export(&context->range.level[0].cat,\n\t\t\t\t   &secattr->attr.mls.cat);\n\tif (rc == 0 && secattr->attr.mls.cat != NULL)\n\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\n\treturn rc;\n}\n\n \nint mls_import_netlbl_cat(struct policydb *p,\n\t\t\t  struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!p->mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc)\n\t\tgoto import_netlbl_cat_failure;\n\tmemcpy(&context->range.level[1].cat, &context->range.level[0].cat,\n\t       sizeof(context->range.level[0].cat));\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\treturn rc;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}