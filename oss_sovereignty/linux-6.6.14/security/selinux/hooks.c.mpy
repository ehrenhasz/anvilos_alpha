{
  "module_name": "hooks.c",
  "hash_id": "8c43693ed68503ca1d7fc07bc4af9f4dfed590b799b0774c6b24badfbe20f40d",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/hooks.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kd.h>\n#include <linux/kernel.h>\n#include <linux/kernel_read_file.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/lsm_hooks.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include <linux/unistd.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/tty.h>\n#include <net/icmp.h>\n#include <net/ip.h>\t\t \n#include <net/tcp.h>\t\t \n#include <net/inet_connection_sock.h>\n#include <net/net_namespace.h>\n#include <net/netlabel.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\t \n#include <net/netlink.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/dccp.h>\n#include <linux/sctp.h>\n#include <net/sctp/structs.h>\n#include <linux/quota.h>\n#include <linux/un.h>\t\t \n#include <net/af_unix.h>\t \n#include <linux/parser.h>\n#include <linux/nfs_mount.h>\n#include <net/ipv6.h>\n#include <linux/hugetlb.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/posix-timers.h>\n#include <linux/syslog.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/msg.h>\n#include <linux/shm.h>\n#include <linux/bpf.h>\n#include <linux/kernfs.h>\n#include <linux/stringhash.h>\t \n#include <uapi/linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/fanotify.h>\n#include <linux/io_uring.h>\n\n#include \"avc.h\"\n#include \"objsec.h\"\n#include \"netif.h\"\n#include \"netnode.h\"\n#include \"netport.h\"\n#include \"ibpkey.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"audit.h\"\n#include \"avc_ss.h\"\n\n#define SELINUX_INODE_INIT_XATTRS 1\n\nstruct selinux_state selinux_state;\n\n \nstatic atomic_t selinux_secmark_refcount = ATOMIC_INIT(0);\n\n#ifdef CONFIG_SECURITY_SELINUX_DEVELOP\nstatic int selinux_enforcing_boot __initdata;\n\nstatic int __init enforcing_setup(char *str)\n{\n\tunsigned long enforcing;\n\tif (!kstrtoul(str, 0, &enforcing))\n\t\tselinux_enforcing_boot = enforcing ? 1 : 0;\n\treturn 1;\n}\n__setup(\"enforcing=\", enforcing_setup);\n#else\n#define selinux_enforcing_boot 1\n#endif\n\nint selinux_enabled_boot __initdata = 1;\n#ifdef CONFIG_SECURITY_SELINUX_BOOTPARAM\nstatic int __init selinux_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tif (!kstrtoul(str, 0, &enabled))\n\t\tselinux_enabled_boot = enabled ? 1 : 0;\n\treturn 1;\n}\n__setup(\"selinux=\", selinux_enabled_setup);\n#endif\n\nstatic int __init checkreqprot_setup(char *str)\n{\n\tunsigned long checkreqprot;\n\n\tif (!kstrtoul(str, 0, &checkreqprot)) {\n\t\tif (checkreqprot)\n\t\t\tpr_err(\"SELinux: checkreqprot set to 1 via kernel parameter.  This is no longer supported.\\n\");\n\t}\n\treturn 1;\n}\n__setup(\"checkreqprot=\", checkreqprot_setup);\n\n \nstatic int selinux_secmark_enabled(void)\n{\n\treturn (selinux_policycap_alwaysnetwork() ||\n\t\tatomic_read(&selinux_secmark_refcount));\n}\n\n \nstatic int selinux_peerlbl_enabled(void)\n{\n\treturn (selinux_policycap_alwaysnetwork() ||\n\t\tnetlbl_enabled() || selinux_xfrm_enabled());\n}\n\nstatic int selinux_netcache_avc_callback(u32 event)\n{\n\tif (event == AVC_CALLBACK_RESET) {\n\t\tsel_netif_flush();\n\t\tsel_netnode_flush();\n\t\tsel_netport_flush();\n\t\tsynchronize_net();\n\t}\n\treturn 0;\n}\n\nstatic int selinux_lsm_notifier_avc_callback(u32 event)\n{\n\tif (event == AVC_CALLBACK_RESET) {\n\t\tsel_ib_pkey_flush();\n\t\tcall_blocking_lsm_notifier(LSM_POLICY_CHANGE, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cred_init_security(void)\n{\n\tstruct task_security_struct *tsec;\n\n\ttsec = selinux_cred(unrcu_pointer(current->real_cred));\n\ttsec->osid = tsec->sid = SECINITSID_KERNEL;\n}\n\n \nstatic inline u32 cred_sid(const struct cred *cred)\n{\n\tconst struct task_security_struct *tsec;\n\n\ttsec = selinux_cred(cred);\n\treturn tsec->sid;\n}\n\nstatic void __ad_net_init(struct common_audit_data *ad,\n\t\t\t  struct lsm_network_audit *net,\n\t\t\t  int ifindex, struct sock *sk, u16 family)\n{\n\tad->type = LSM_AUDIT_DATA_NET;\n\tad->u.net = net;\n\tnet->netif = ifindex;\n\tnet->sk = sk;\n\tnet->family = family;\n}\n\nstatic void ad_net_init_from_sk(struct common_audit_data *ad,\n\t\t\t\tstruct lsm_network_audit *net,\n\t\t\t\tstruct sock *sk)\n{\n\t__ad_net_init(ad, net, 0, sk, 0);\n}\n\nstatic void ad_net_init_from_iif(struct common_audit_data *ad,\n\t\t\t\t struct lsm_network_audit *net,\n\t\t\t\t int ifindex, u16 family)\n{\n\t__ad_net_init(ad, net, ifindex, NULL, family);\n}\n\n \nstatic inline u32 task_sid_obj(const struct task_struct *task)\n{\n\tu32 sid;\n\n\trcu_read_lock();\n\tsid = cred_sid(__task_cred(task));\n\trcu_read_unlock();\n\treturn sid;\n}\n\nstatic int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);\n\n \nstatic int __inode_security_revalidate(struct inode *inode,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       bool may_sleep)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\n\tmight_sleep_if(may_sleep);\n\n\tif (selinux_initialized() &&\n\t    isec->initialized != LABEL_INITIALIZED) {\n\t\tif (!may_sleep)\n\t\t\treturn -ECHILD;\n\n\t\t \n\t\tinode_doinit_with_dentry(inode, dentry);\n\t}\n\treturn 0;\n}\n\nstatic struct inode_security_struct *inode_security_novalidate(struct inode *inode)\n{\n\treturn selinux_inode(inode);\n}\n\nstatic struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)\n{\n\tint error;\n\n\terror = __inode_security_revalidate(inode, NULL, !rcu);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\treturn selinux_inode(inode);\n}\n\n \nstatic struct inode_security_struct *inode_security(struct inode *inode)\n{\n\t__inode_security_revalidate(inode, NULL, true);\n\treturn selinux_inode(inode);\n}\n\nstatic struct inode_security_struct *backing_inode_security_novalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\treturn selinux_inode(inode);\n}\n\n \nstatic struct inode_security_struct *backing_inode_security(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\t__inode_security_revalidate(inode, dentry, true);\n\treturn selinux_inode(inode);\n}\n\nstatic void inode_free_security(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tstruct superblock_security_struct *sbsec;\n\n\tif (!isec)\n\t\treturn;\n\tsbsec = selinux_superblock(inode->i_sb);\n\t \n\tif (!list_empty_careful(&isec->list)) {\n\t\tspin_lock(&sbsec->isec_lock);\n\t\tlist_del_init(&isec->list);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t}\n}\n\nstruct selinux_mnt_opts {\n\tu32 fscontext_sid;\n\tu32 context_sid;\n\tu32 rootcontext_sid;\n\tu32 defcontext_sid;\n};\n\nstatic void selinux_free_mnt_opts(void *mnt_opts)\n{\n\tkfree(mnt_opts);\n}\n\nenum {\n\tOpt_error = -1,\n\tOpt_context = 0,\n\tOpt_defcontext = 1,\n\tOpt_fscontext = 2,\n\tOpt_rootcontext = 3,\n\tOpt_seclabel = 4,\n};\n\n#define A(s, has_arg) {#s, sizeof(#s) - 1, Opt_##s, has_arg}\nstatic const struct {\n\tconst char *name;\n\tint len;\n\tint opt;\n\tbool has_arg;\n} tokens[] = {\n\tA(context, true),\n\tA(fscontext, true),\n\tA(defcontext, true),\n\tA(rootcontext, true),\n\tA(seclabel, false),\n};\n#undef A\n\nstatic int match_opt_prefix(char *s, int l, char **arg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tokens); i++) {\n\t\tsize_t len = tokens[i].len;\n\t\tif (len > l || memcmp(s, tokens[i].name, len))\n\t\t\tcontinue;\n\t\tif (tokens[i].has_arg) {\n\t\t\tif (len == l || s[len] != '=')\n\t\t\t\tcontinue;\n\t\t\t*arg = s + len + 1;\n\t\t} else if (len != l)\n\t\t\tcontinue;\n\t\treturn tokens[i].opt;\n\t}\n\treturn Opt_error;\n}\n\n#define SEL_MOUNT_FAIL_MSG \"SELinux:  duplicate or incompatible mount options\\n\"\n\nstatic int may_context_mount_sb_relabel(u32 sid,\n\t\t\tstruct superblock_security_struct *sbsec,\n\t\t\tconst struct cred *cred)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(cred);\n\tint rc;\n\n\trc = avc_has_perm(tsec->sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELFROM, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(tsec->sid, sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELTO, NULL);\n\treturn rc;\n}\n\nstatic int may_context_mount_inode_relabel(u32 sid,\n\t\t\tstruct superblock_security_struct *sbsec,\n\t\t\tconst struct cred *cred)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(cred);\n\tint rc;\n\trc = avc_has_perm(tsec->sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELFROM, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__ASSOCIATE, NULL);\n\treturn rc;\n}\n\nstatic int selinux_is_genfs_special_handling(struct super_block *sb)\n{\n\t \n\treturn\t!strcmp(sb->s_type->name, \"sysfs\") ||\n\t\t!strcmp(sb->s_type->name, \"pstore\") ||\n\t\t!strcmp(sb->s_type->name, \"debugfs\") ||\n\t\t!strcmp(sb->s_type->name, \"tracefs\") ||\n\t\t!strcmp(sb->s_type->name, \"rootfs\") ||\n\t\t(selinux_policycap_cgroupseclabel() &&\n\t\t (!strcmp(sb->s_type->name, \"cgroup\") ||\n\t\t  !strcmp(sb->s_type->name, \"cgroup2\")));\n}\n\nstatic int selinux_is_sblabel_mnt(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\n\t \n\tBUILD_BUG_ON(SECURITY_FS_USE_MAX != 7);\n\n\tswitch (sbsec->behavior) {\n\tcase SECURITY_FS_USE_XATTR:\n\tcase SECURITY_FS_USE_TRANS:\n\tcase SECURITY_FS_USE_TASK:\n\tcase SECURITY_FS_USE_NATIVE:\n\t\treturn 1;\n\n\tcase SECURITY_FS_USE_GENFS:\n\t\treturn selinux_is_genfs_special_handling(sb);\n\n\t \n\tcase SECURITY_FS_USE_MNTPOINT:\n\tcase SECURITY_FS_USE_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sb_check_xattr_support(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *root_inode = d_backing_inode(root);\n\tu32 sid;\n\tint rc;\n\n\t \n\tif (!(root_inode->i_opflags & IOP_XATTR)) {\n\t\tpr_warn(\"SELinux: (dev %s, type %s) has no xattr support\\n\",\n\t\t\tsb->s_id, sb->s_type->name);\n\t\tgoto fallback;\n\t}\n\n\trc = __vfs_getxattr(root, root_inode, XATTR_NAME_SELINUX, NULL, 0);\n\tif (rc < 0 && rc != -ENODATA) {\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\tpr_warn(\"SELinux: (dev %s, type %s) has no security xattr handler\\n\",\n\t\t\t\tsb->s_id, sb->s_type->name);\n\t\t\tgoto fallback;\n\t\t} else {\n\t\t\tpr_warn(\"SELinux: (dev %s, type %s) getxattr errno %d\\n\",\n\t\t\t\tsb->s_id, sb->s_type->name, -rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n\nfallback:\n\t \n\trc = security_genfs_sid(sb->s_type->name, \"/\",\n\t\t\t\tSECCLASS_DIR, &sid);\n\tif (rc)\n\t\treturn -EOPNOTSUPP;\n\n\tpr_warn(\"SELinux: (dev %s, type %s) falling back to genfs\\n\",\n\t\tsb->s_id, sb->s_type->name);\n\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\tsbsec->sid = sid;\n\treturn 0;\n}\n\nstatic int sb_finish_set_opts(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *root_inode = d_backing_inode(root);\n\tint rc = 0;\n\n\tif (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n\t\trc = sb_check_xattr_support(sb);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tsbsec->flags |= SE_SBINITIALIZED;\n\n\t \n\tif (selinux_is_sblabel_mnt(sb))\n\t\tsbsec->flags |= SBLABEL_MNT;\n\telse\n\t\tsbsec->flags &= ~SBLABEL_MNT;\n\n\t \n\trc = inode_doinit_with_dentry(root_inode, root);\n\n\t \n\tspin_lock(&sbsec->isec_lock);\n\twhile (!list_empty(&sbsec->isec_head)) {\n\t\tstruct inode_security_struct *isec =\n\t\t\t\tlist_first_entry(&sbsec->isec_head,\n\t\t\t\t\t   struct inode_security_struct, list);\n\t\tstruct inode *inode = isec->inode;\n\t\tlist_del_init(&isec->list);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t\tinode = igrab(inode);\n\t\tif (inode) {\n\t\t\tif (!IS_PRIVATE(inode))\n\t\t\t\tinode_doinit_with_dentry(inode, NULL);\n\t\t\tiput(inode);\n\t\t}\n\t\tspin_lock(&sbsec->isec_lock);\n\t}\n\tspin_unlock(&sbsec->isec_lock);\n\treturn rc;\n}\n\nstatic int bad_option(struct superblock_security_struct *sbsec, char flag,\n\t\t      u32 old_sid, u32 new_sid)\n{\n\tchar mnt_flags = sbsec->flags & SE_MNTMASK;\n\n\t \n\tif (sbsec->flags & SE_SBINITIALIZED)\n\t\tif (!(sbsec->flags & flag) ||\n\t\t    (old_sid != new_sid))\n\t\t\treturn 1;\n\n\t \n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\tif (mnt_flags & flag)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int selinux_set_mnt_opts(struct super_block *sb,\n\t\t\t\tvoid *mnt_opts,\n\t\t\t\tunsigned long kern_flags,\n\t\t\t\tunsigned long *set_kern_flags)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\tstruct dentry *root = sb->s_root;\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct inode_security_struct *root_isec;\n\tu32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;\n\tu32 defcontext_sid = 0;\n\tint rc = 0;\n\n\t \n\tif (kern_flags && !set_kern_flags)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sbsec->lock);\n\n\tif (!selinux_initialized()) {\n\t\tif (!opts) {\n\t\t\t \n\t\t\tif (kern_flags & SECURITY_LSM_NATIVE_LABELS) {\n\t\t\t\tsbsec->flags |= SE_SBNATIVE;\n\t\t\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\trc = -EINVAL;\n\t\tpr_warn(\"SELinux: Unable to set superblock options \"\n\t\t\t\"before the security server is initialized\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif ((sbsec->flags & SE_SBINITIALIZED) && (sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)\n\t    && !opts)\n\t\tgoto out;\n\n\troot_isec = backing_inode_security_novalidate(root);\n\n\t \n\tif (opts) {\n\t\tif (opts->fscontext_sid) {\n\t\t\tfscontext_sid = opts->fscontext_sid;\n\t\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,\n\t\t\t\t\tfscontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= FSCONTEXT_MNT;\n\t\t}\n\t\tif (opts->context_sid) {\n\t\t\tcontext_sid = opts->context_sid;\n\t\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,\n\t\t\t\t\tcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= CONTEXT_MNT;\n\t\t}\n\t\tif (opts->rootcontext_sid) {\n\t\t\trootcontext_sid = opts->rootcontext_sid;\n\t\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,\n\t\t\t\t\trootcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= ROOTCONTEXT_MNT;\n\t\t}\n\t\tif (opts->defcontext_sid) {\n\t\t\tdefcontext_sid = opts->defcontext_sid;\n\t\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,\n\t\t\t\t\tdefcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= DEFCONTEXT_MNT;\n\t\t}\n\t}\n\n\tif (sbsec->flags & SE_SBINITIALIZED) {\n\t\t \n\t\tif ((sbsec->flags & SE_MNTMASK) && !opts)\n\t\t\tgoto out_double_mount;\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(sb->s_type->name, \"proc\") == 0)\n\t\tsbsec->flags |= SE_SBPROC | SE_SBGENFS;\n\n\tif (!strcmp(sb->s_type->name, \"debugfs\") ||\n\t    !strcmp(sb->s_type->name, \"tracefs\") ||\n\t    !strcmp(sb->s_type->name, \"binder\") ||\n\t    !strcmp(sb->s_type->name, \"bpf\") ||\n\t    !strcmp(sb->s_type->name, \"pstore\") ||\n\t    !strcmp(sb->s_type->name, \"securityfs\"))\n\t\tsbsec->flags |= SE_SBGENFS;\n\n\tif (!strcmp(sb->s_type->name, \"sysfs\") ||\n\t    !strcmp(sb->s_type->name, \"cgroup\") ||\n\t    !strcmp(sb->s_type->name, \"cgroup2\"))\n\t\tsbsec->flags |= SE_SBGENFS | SE_SBGENFS_XATTR;\n\n\tif (!sbsec->behavior) {\n\t\t \n\t\trc = security_fs_use(sb);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: security_fs_use(%s) returned %d\\n\",\n\t\t\t\t\t__func__, sb->s_type->name, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (sb->s_user_ns != &init_user_ns &&\n\t    strcmp(sb->s_type->name, \"tmpfs\") &&\n\t    strcmp(sb->s_type->name, \"ramfs\") &&\n\t    strcmp(sb->s_type->name, \"devpts\") &&\n\t    strcmp(sb->s_type->name, \"overlay\")) {\n\t\tif (context_sid || fscontext_sid || rootcontext_sid ||\n\t\t    defcontext_sid) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_MNTPOINT;\n\t\t\trc = security_transition_sid(current_sid(),\n\t\t\t\t\t\t     current_sid(),\n\t\t\t\t\t\t     SECCLASS_FILE, NULL,\n\t\t\t\t\t\t     &sbsec->mntpoint_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tgoto out_set_opts;\n\t}\n\n\t \n\tif (fscontext_sid) {\n\t\trc = may_context_mount_sb_relabel(fscontext_sid, sbsec, cred);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tsbsec->sid = fscontext_sid;\n\t}\n\n\t \n\tif (sbsec->flags & SE_SBNATIVE) {\n\t\t \n\t\tsbsec->behavior = SECURITY_FS_USE_NATIVE;\n\t} else if (kern_flags & SECURITY_LSM_NATIVE_LABELS && !context_sid) {\n\t\tsbsec->behavior = SECURITY_FS_USE_NATIVE;\n\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t}\n\n\tif (context_sid) {\n\t\tif (!fscontext_sid) {\n\t\t\trc = may_context_mount_sb_relabel(context_sid, sbsec,\n\t\t\t\t\t\t\t  cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tsbsec->sid = context_sid;\n\t\t} else {\n\t\t\trc = may_context_mount_inode_relabel(context_sid, sbsec,\n\t\t\t\t\t\t\t     cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!rootcontext_sid)\n\t\t\trootcontext_sid = context_sid;\n\n\t\tsbsec->mntpoint_sid = context_sid;\n\t\tsbsec->behavior = SECURITY_FS_USE_MNTPOINT;\n\t}\n\n\tif (rootcontext_sid) {\n\t\trc = may_context_mount_inode_relabel(rootcontext_sid, sbsec,\n\t\t\t\t\t\t     cred);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\troot_isec->sid = rootcontext_sid;\n\t\troot_isec->initialized = LABEL_INITIALIZED;\n\t}\n\n\tif (defcontext_sid) {\n\t\tif (sbsec->behavior != SECURITY_FS_USE_XATTR &&\n\t\t\tsbsec->behavior != SECURITY_FS_USE_NATIVE) {\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"SELinux: defcontext option is \"\n\t\t\t       \"invalid for this filesystem type\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (defcontext_sid != sbsec->def_sid) {\n\t\t\trc = may_context_mount_inode_relabel(defcontext_sid,\n\t\t\t\t\t\t\t     sbsec, cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tsbsec->def_sid = defcontext_sid;\n\t}\n\nout_set_opts:\n\trc = sb_finish_set_opts(sb);\nout:\n\tmutex_unlock(&sbsec->lock);\n\treturn rc;\nout_double_mount:\n\trc = -EINVAL;\n\tpr_warn(\"SELinux: mount invalid.  Same superblock, different \"\n\t       \"security settings for (dev %s, type %s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\tgoto out;\n}\n\nstatic int selinux_cmp_sb_context(const struct super_block *oldsb,\n\t\t\t\t    const struct super_block *newsb)\n{\n\tstruct superblock_security_struct *old = selinux_superblock(oldsb);\n\tstruct superblock_security_struct *new = selinux_superblock(newsb);\n\tchar oldflags = old->flags & SE_MNTMASK;\n\tchar newflags = new->flags & SE_MNTMASK;\n\n\tif (oldflags != newflags)\n\t\tgoto mismatch;\n\tif ((oldflags & FSCONTEXT_MNT) && old->sid != new->sid)\n\t\tgoto mismatch;\n\tif ((oldflags & CONTEXT_MNT) && old->mntpoint_sid != new->mntpoint_sid)\n\t\tgoto mismatch;\n\tif ((oldflags & DEFCONTEXT_MNT) && old->def_sid != new->def_sid)\n\t\tgoto mismatch;\n\tif (oldflags & ROOTCONTEXT_MNT) {\n\t\tstruct inode_security_struct *oldroot = backing_inode_security(oldsb->s_root);\n\t\tstruct inode_security_struct *newroot = backing_inode_security(newsb->s_root);\n\t\tif (oldroot->sid != newroot->sid)\n\t\t\tgoto mismatch;\n\t}\n\treturn 0;\nmismatch:\n\tpr_warn(\"SELinux: mount invalid.  Same superblock, \"\n\t\t\t    \"different security settings for (dev %s, \"\n\t\t\t    \"type %s)\\n\", newsb->s_id, newsb->s_type->name);\n\treturn -EBUSY;\n}\n\nstatic int selinux_sb_clone_mnt_opts(const struct super_block *oldsb,\n\t\t\t\t\tstruct super_block *newsb,\n\t\t\t\t\tunsigned long kern_flags,\n\t\t\t\t\tunsigned long *set_kern_flags)\n{\n\tint rc = 0;\n\tconst struct superblock_security_struct *oldsbsec =\n\t\t\t\t\t\tselinux_superblock(oldsb);\n\tstruct superblock_security_struct *newsbsec = selinux_superblock(newsb);\n\n\tint set_fscontext =\t(oldsbsec->flags & FSCONTEXT_MNT);\n\tint set_context =\t(oldsbsec->flags & CONTEXT_MNT);\n\tint set_rootcontext =\t(oldsbsec->flags & ROOTCONTEXT_MNT);\n\n\t \n\tif (kern_flags && !set_kern_flags)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&newsbsec->lock);\n\n\t \n\tif (!selinux_initialized()) {\n\t\tif (kern_flags & SECURITY_LSM_NATIVE_LABELS) {\n\t\t\tnewsbsec->flags |= SE_SBNATIVE;\n\t\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tBUG_ON(!(oldsbsec->flags & SE_SBINITIALIZED));\n\n\t \n\tif (newsbsec->flags & SE_SBINITIALIZED) {\n\t\tmutex_unlock(&newsbsec->lock);\n\t\tif ((kern_flags & SECURITY_LSM_NATIVE_LABELS) && !set_context)\n\t\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t\treturn selinux_cmp_sb_context(oldsb, newsb);\n\t}\n\n\tnewsbsec->flags = oldsbsec->flags;\n\n\tnewsbsec->sid = oldsbsec->sid;\n\tnewsbsec->def_sid = oldsbsec->def_sid;\n\tnewsbsec->behavior = oldsbsec->behavior;\n\n\tif (newsbsec->behavior == SECURITY_FS_USE_NATIVE &&\n\t\t!(kern_flags & SECURITY_LSM_NATIVE_LABELS) && !set_context) {\n\t\trc = security_fs_use(newsb);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (kern_flags & SECURITY_LSM_NATIVE_LABELS && !set_context) {\n\t\tnewsbsec->behavior = SECURITY_FS_USE_NATIVE;\n\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t}\n\n\tif (set_context) {\n\t\tu32 sid = oldsbsec->mntpoint_sid;\n\n\t\tif (!set_fscontext)\n\t\t\tnewsbsec->sid = sid;\n\t\tif (!set_rootcontext) {\n\t\t\tstruct inode_security_struct *newisec = backing_inode_security(newsb->s_root);\n\t\t\tnewisec->sid = sid;\n\t\t}\n\t\tnewsbsec->mntpoint_sid = sid;\n\t}\n\tif (set_rootcontext) {\n\t\tconst struct inode_security_struct *oldisec = backing_inode_security(oldsb->s_root);\n\t\tstruct inode_security_struct *newisec = backing_inode_security(newsb->s_root);\n\n\t\tnewisec->sid = oldisec->sid;\n\t}\n\n\tsb_finish_set_opts(newsb);\nout:\n\tmutex_unlock(&newsbsec->lock);\n\treturn rc;\n}\n\n \nstatic int selinux_add_opt(int token, const char *s, void **mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = *mnt_opts;\n\tu32 *dst_sid;\n\tint rc;\n\n\tif (token == Opt_seclabel)\n\t\t \n\t\treturn 0;\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (!selinux_initialized()) {\n\t\tpr_warn(\"SELinux: Unable to set superblock options before the security server is initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!opts) {\n\t\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\t\tif (!opts)\n\t\t\treturn -ENOMEM;\n\t\t*mnt_opts = opts;\n\t}\n\n\tswitch (token) {\n\tcase Opt_context:\n\t\tif (opts->context_sid || opts->defcontext_sid)\n\t\t\tgoto err;\n\t\tdst_sid = &opts->context_sid;\n\t\tbreak;\n\tcase Opt_fscontext:\n\t\tif (opts->fscontext_sid)\n\t\t\tgoto err;\n\t\tdst_sid = &opts->fscontext_sid;\n\t\tbreak;\n\tcase Opt_rootcontext:\n\t\tif (opts->rootcontext_sid)\n\t\t\tgoto err;\n\t\tdst_sid = &opts->rootcontext_sid;\n\t\tbreak;\n\tcase Opt_defcontext:\n\t\tif (opts->context_sid || opts->defcontext_sid)\n\t\t\tgoto err;\n\t\tdst_sid = &opts->defcontext_sid;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\trc = security_context_str_to_sid(s, dst_sid, GFP_KERNEL);\n\tif (rc)\n\t\tpr_warn(\"SELinux: security_context_str_to_sid (%s) failed with errno=%d\\n\",\n\t\t\ts, rc);\n\treturn rc;\n\nerr:\n\tpr_warn(SEL_MOUNT_FAIL_MSG);\n\treturn -EINVAL;\n}\n\nstatic int show_sid(struct seq_file *m, u32 sid)\n{\n\tchar *context = NULL;\n\tu32 len;\n\tint rc;\n\n\trc = security_sid_to_context(sid, &context, &len);\n\tif (!rc) {\n\t\tbool has_comma = strchr(context, ',');\n\n\t\tseq_putc(m, '=');\n\t\tif (has_comma)\n\t\t\tseq_putc(m, '\\\"');\n\t\tseq_escape(m, context, \"\\\"\\n\\\\\");\n\t\tif (has_comma)\n\t\t\tseq_putc(m, '\\\"');\n\t}\n\tkfree(context);\n\treturn rc;\n}\n\nstatic int selinux_sb_show_options(struct seq_file *m, struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\tint rc;\n\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\tif (sbsec->flags & FSCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, FSCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & CONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, CONTEXT_STR);\n\t\trc = show_sid(m, sbsec->mntpoint_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & DEFCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, DEFCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->def_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & ROOTCONTEXT_MNT) {\n\t\tstruct dentry *root = sb->s_root;\n\t\tstruct inode_security_struct *isec = backing_inode_security(root);\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, ROOTCONTEXT_STR);\n\t\trc = show_sid(m, isec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & SBLABEL_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, SECLABEL_STR);\n\t}\n\treturn 0;\n}\n\nstatic inline u16 inode_mode_to_security_class(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\treturn SECCLASS_SOCK_FILE;\n\tcase S_IFLNK:\n\t\treturn SECCLASS_LNK_FILE;\n\tcase S_IFREG:\n\t\treturn SECCLASS_FILE;\n\tcase S_IFBLK:\n\t\treturn SECCLASS_BLK_FILE;\n\tcase S_IFDIR:\n\t\treturn SECCLASS_DIR;\n\tcase S_IFCHR:\n\t\treturn SECCLASS_CHR_FILE;\n\tcase S_IFIFO:\n\t\treturn SECCLASS_FIFO_FILE;\n\n\t}\n\n\treturn SECCLASS_FILE;\n}\n\nstatic inline int default_protocol_stream(int protocol)\n{\n\treturn (protocol == IPPROTO_IP || protocol == IPPROTO_TCP ||\n\t\tprotocol == IPPROTO_MPTCP);\n}\n\nstatic inline int default_protocol_dgram(int protocol)\n{\n\treturn (protocol == IPPROTO_IP || protocol == IPPROTO_UDP);\n}\n\nstatic inline u16 socket_type_to_security_class(int family, int type, int protocol)\n{\n\tbool extsockclass = selinux_policycap_extsockclass();\n\n\tswitch (family) {\n\tcase PF_UNIX:\n\t\tswitch (type) {\n\t\tcase SOCK_STREAM:\n\t\tcase SOCK_SEQPACKET:\n\t\t\treturn SECCLASS_UNIX_STREAM_SOCKET;\n\t\tcase SOCK_DGRAM:\n\t\tcase SOCK_RAW:\n\t\t\treturn SECCLASS_UNIX_DGRAM_SOCKET;\n\t\t}\n\t\tbreak;\n\tcase PF_INET:\n\tcase PF_INET6:\n\t\tswitch (type) {\n\t\tcase SOCK_STREAM:\n\t\tcase SOCK_SEQPACKET:\n\t\t\tif (default_protocol_stream(protocol))\n\t\t\t\treturn SECCLASS_TCP_SOCKET;\n\t\t\telse if (extsockclass && protocol == IPPROTO_SCTP)\n\t\t\t\treturn SECCLASS_SCTP_SOCKET;\n\t\t\telse\n\t\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\tcase SOCK_DGRAM:\n\t\t\tif (default_protocol_dgram(protocol))\n\t\t\t\treturn SECCLASS_UDP_SOCKET;\n\t\t\telse if (extsockclass && (protocol == IPPROTO_ICMP ||\n\t\t\t\t\t\t  protocol == IPPROTO_ICMPV6))\n\t\t\t\treturn SECCLASS_ICMP_SOCKET;\n\t\t\telse\n\t\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\tcase SOCK_DCCP:\n\t\t\treturn SECCLASS_DCCP_SOCKET;\n\t\tdefault:\n\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\t}\n\t\tbreak;\n\tcase PF_NETLINK:\n\t\tswitch (protocol) {\n\t\tcase NETLINK_ROUTE:\n\t\t\treturn SECCLASS_NETLINK_ROUTE_SOCKET;\n\t\tcase NETLINK_SOCK_DIAG:\n\t\t\treturn SECCLASS_NETLINK_TCPDIAG_SOCKET;\n\t\tcase NETLINK_NFLOG:\n\t\t\treturn SECCLASS_NETLINK_NFLOG_SOCKET;\n\t\tcase NETLINK_XFRM:\n\t\t\treturn SECCLASS_NETLINK_XFRM_SOCKET;\n\t\tcase NETLINK_SELINUX:\n\t\t\treturn SECCLASS_NETLINK_SELINUX_SOCKET;\n\t\tcase NETLINK_ISCSI:\n\t\t\treturn SECCLASS_NETLINK_ISCSI_SOCKET;\n\t\tcase NETLINK_AUDIT:\n\t\t\treturn SECCLASS_NETLINK_AUDIT_SOCKET;\n\t\tcase NETLINK_FIB_LOOKUP:\n\t\t\treturn SECCLASS_NETLINK_FIB_LOOKUP_SOCKET;\n\t\tcase NETLINK_CONNECTOR:\n\t\t\treturn SECCLASS_NETLINK_CONNECTOR_SOCKET;\n\t\tcase NETLINK_NETFILTER:\n\t\t\treturn SECCLASS_NETLINK_NETFILTER_SOCKET;\n\t\tcase NETLINK_DNRTMSG:\n\t\t\treturn SECCLASS_NETLINK_DNRT_SOCKET;\n\t\tcase NETLINK_KOBJECT_UEVENT:\n\t\t\treturn SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET;\n\t\tcase NETLINK_GENERIC:\n\t\t\treturn SECCLASS_NETLINK_GENERIC_SOCKET;\n\t\tcase NETLINK_SCSITRANSPORT:\n\t\t\treturn SECCLASS_NETLINK_SCSITRANSPORT_SOCKET;\n\t\tcase NETLINK_RDMA:\n\t\t\treturn SECCLASS_NETLINK_RDMA_SOCKET;\n\t\tcase NETLINK_CRYPTO:\n\t\t\treturn SECCLASS_NETLINK_CRYPTO_SOCKET;\n\t\tdefault:\n\t\t\treturn SECCLASS_NETLINK_SOCKET;\n\t\t}\n\tcase PF_PACKET:\n\t\treturn SECCLASS_PACKET_SOCKET;\n\tcase PF_KEY:\n\t\treturn SECCLASS_KEY_SOCKET;\n\tcase PF_APPLETALK:\n\t\treturn SECCLASS_APPLETALK_SOCKET;\n\t}\n\n\tif (extsockclass) {\n\t\tswitch (family) {\n\t\tcase PF_AX25:\n\t\t\treturn SECCLASS_AX25_SOCKET;\n\t\tcase PF_IPX:\n\t\t\treturn SECCLASS_IPX_SOCKET;\n\t\tcase PF_NETROM:\n\t\t\treturn SECCLASS_NETROM_SOCKET;\n\t\tcase PF_ATMPVC:\n\t\t\treturn SECCLASS_ATMPVC_SOCKET;\n\t\tcase PF_X25:\n\t\t\treturn SECCLASS_X25_SOCKET;\n\t\tcase PF_ROSE:\n\t\t\treturn SECCLASS_ROSE_SOCKET;\n\t\tcase PF_DECnet:\n\t\t\treturn SECCLASS_DECNET_SOCKET;\n\t\tcase PF_ATMSVC:\n\t\t\treturn SECCLASS_ATMSVC_SOCKET;\n\t\tcase PF_RDS:\n\t\t\treturn SECCLASS_RDS_SOCKET;\n\t\tcase PF_IRDA:\n\t\t\treturn SECCLASS_IRDA_SOCKET;\n\t\tcase PF_PPPOX:\n\t\t\treturn SECCLASS_PPPOX_SOCKET;\n\t\tcase PF_LLC:\n\t\t\treturn SECCLASS_LLC_SOCKET;\n\t\tcase PF_CAN:\n\t\t\treturn SECCLASS_CAN_SOCKET;\n\t\tcase PF_TIPC:\n\t\t\treturn SECCLASS_TIPC_SOCKET;\n\t\tcase PF_BLUETOOTH:\n\t\t\treturn SECCLASS_BLUETOOTH_SOCKET;\n\t\tcase PF_IUCV:\n\t\t\treturn SECCLASS_IUCV_SOCKET;\n\t\tcase PF_RXRPC:\n\t\t\treturn SECCLASS_RXRPC_SOCKET;\n\t\tcase PF_ISDN:\n\t\t\treturn SECCLASS_ISDN_SOCKET;\n\t\tcase PF_PHONET:\n\t\t\treturn SECCLASS_PHONET_SOCKET;\n\t\tcase PF_IEEE802154:\n\t\t\treturn SECCLASS_IEEE802154_SOCKET;\n\t\tcase PF_CAIF:\n\t\t\treturn SECCLASS_CAIF_SOCKET;\n\t\tcase PF_ALG:\n\t\t\treturn SECCLASS_ALG_SOCKET;\n\t\tcase PF_NFC:\n\t\t\treturn SECCLASS_NFC_SOCKET;\n\t\tcase PF_VSOCK:\n\t\t\treturn SECCLASS_VSOCK_SOCKET;\n\t\tcase PF_KCM:\n\t\t\treturn SECCLASS_KCM_SOCKET;\n\t\tcase PF_QIPCRTR:\n\t\t\treturn SECCLASS_QIPCRTR_SOCKET;\n\t\tcase PF_SMC:\n\t\t\treturn SECCLASS_SMC_SOCKET;\n\t\tcase PF_XDP:\n\t\t\treturn SECCLASS_XDP_SOCKET;\n\t\tcase PF_MCTP:\n\t\t\treturn SECCLASS_MCTP_SOCKET;\n#if PF_MAX > 46\n#error New address family defined, please update this function.\n#endif\n\t\t}\n\t}\n\n\treturn SECCLASS_SOCKET;\n}\n\nstatic int selinux_genfs_get_sid(struct dentry *dentry,\n\t\t\t\t u16 tclass,\n\t\t\t\t u16 flags,\n\t\t\t\t u32 *sid)\n{\n\tint rc;\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *buffer, *path;\n\n\tbuffer = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tpath = dentry_path_raw(dentry, buffer, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\trc = PTR_ERR(path);\n\telse {\n\t\tif (flags & SE_SBPROC) {\n\t\t\t \n\t\t\twhile (path[1] >= '0' && path[1] <= '9') {\n\t\t\t\tpath[1] = '/';\n\t\t\t\tpath++;\n\t\t\t}\n\t\t}\n\t\trc = security_genfs_sid(sb->s_type->name,\n\t\t\t\t\tpath, tclass, sid);\n\t\tif (rc == -ENOENT) {\n\t\t\t \n\t\t\t*sid = SECINITSID_UNLABELED;\n\t\t\trc = 0;\n\t\t}\n\t}\n\tfree_page((unsigned long)buffer);\n\treturn rc;\n}\n\nstatic int inode_doinit_use_xattr(struct inode *inode, struct dentry *dentry,\n\t\t\t\t  u32 def_sid, u32 *sid)\n{\n#define INITCONTEXTLEN 255\n\tchar *context;\n\tunsigned int len;\n\tint rc;\n\n\tlen = INITCONTEXTLEN;\n\tcontext = kmalloc(len + 1, GFP_NOFS);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext[len] = '\\0';\n\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX, context, len);\n\tif (rc == -ERANGE) {\n\t\tkfree(context);\n\n\t\t \n\t\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX, NULL, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tlen = rc;\n\t\tcontext = kmalloc(len + 1, GFP_NOFS);\n\t\tif (!context)\n\t\t\treturn -ENOMEM;\n\n\t\tcontext[len] = '\\0';\n\t\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX,\n\t\t\t\t    context, len);\n\t}\n\tif (rc < 0) {\n\t\tkfree(context);\n\t\tif (rc != -ENODATA) {\n\t\t\tpr_warn(\"SELinux: %s:  getxattr returned %d for dev=%s ino=%ld\\n\",\n\t\t\t\t__func__, -rc, inode->i_sb->s_id, inode->i_ino);\n\t\t\treturn rc;\n\t\t}\n\t\t*sid = def_sid;\n\t\treturn 0;\n\t}\n\n\trc = security_context_to_sid_default(context, rc, sid,\n\t\t\t\t\t     def_sid, GFP_NOFS);\n\tif (rc) {\n\t\tchar *dev = inode->i_sb->s_id;\n\t\tunsigned long ino = inode->i_ino;\n\n\t\tif (rc == -EINVAL) {\n\t\t\tpr_notice_ratelimited(\"SELinux: inode=%lu on dev=%s was found to have an invalid context=%s.  This indicates you may need to relabel the inode or the filesystem in question.\\n\",\n\t\t\t\t\t      ino, dev, context);\n\t\t} else {\n\t\t\tpr_warn(\"SELinux: %s:  context_to_sid(%s) returned %d for dev=%s ino=%ld\\n\",\n\t\t\t\t__func__, context, -rc, dev, ino);\n\t\t}\n\t}\n\tkfree(context);\n\treturn 0;\n}\n\n \nstatic int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry)\n{\n\tstruct superblock_security_struct *sbsec = NULL;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 task_sid, sid = 0;\n\tu16 sclass;\n\tstruct dentry *dentry;\n\tint rc = 0;\n\n\tif (isec->initialized == LABEL_INITIALIZED)\n\t\treturn 0;\n\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_INITIALIZED)\n\t\tgoto out_unlock;\n\n\tif (isec->sclass == SECCLASS_FILE)\n\t\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\n\tsbsec = selinux_superblock(inode->i_sb);\n\tif (!(sbsec->flags & SE_SBINITIALIZED)) {\n\t\t \n\t\tspin_lock(&sbsec->isec_lock);\n\t\tif (list_empty(&isec->list))\n\t\t\tlist_add(&isec->list, &sbsec->isec_head);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t\tgoto out_unlock;\n\t}\n\n\tsclass = isec->sclass;\n\ttask_sid = isec->task_sid;\n\tsid = isec->sid;\n\tisec->initialized = LABEL_PENDING;\n\tspin_unlock(&isec->lock);\n\n\tswitch (sbsec->behavior) {\n\t \n\tcase SECURITY_FS_USE_NATIVE:\n\tcase SECURITY_FS_USE_XATTR:\n\t\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\t\tsid = sbsec->def_sid;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (opt_dentry) {\n\t\t\t \n\t\t\tdentry = dget(opt_dentry);\n\t\t} else {\n\t\t\t \n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (!dentry)\n\t\t\t\tdentry = d_find_any_alias(inode);\n\t\t}\n\t\tif (!dentry) {\n\t\t\t \n\t\t\tgoto out_invalid;\n\t\t}\n\n\t\trc = inode_doinit_use_xattr(inode, dentry, sbsec->def_sid,\n\t\t\t\t\t    &sid);\n\t\tdput(dentry);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SECURITY_FS_USE_TASK:\n\t\tsid = task_sid;\n\t\tbreak;\n\tcase SECURITY_FS_USE_TRANS:\n\t\t \n\t\tsid = sbsec->sid;\n\n\t\t \n\t\trc = security_transition_sid(task_sid, sid,\n\t\t\t\t\t     sclass, NULL, &sid);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SECURITY_FS_USE_MNTPOINT:\n\t\tsid = sbsec->mntpoint_sid;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsid = sbsec->sid;\n\n\t\tif ((sbsec->flags & SE_SBGENFS) &&\n\t\t     (!S_ISLNK(inode->i_mode) ||\n\t\t      selinux_policycap_genfs_seclabel_symlinks())) {\n\t\t\t \n\t\t\tif (opt_dentry) {\n\t\t\t\t \n\t\t\t\tdentry = dget(opt_dentry);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdentry = d_find_alias(inode);\n\t\t\t\tif (!dentry)\n\t\t\t\t\tdentry = d_find_any_alias(inode);\n\t\t\t}\n\t\t\t \n\t\t\tif (!dentry)\n\t\t\t\tgoto out_invalid;\n\t\t\trc = selinux_genfs_get_sid(dentry, sclass,\n\t\t\t\t\t\t   sbsec->flags, &sid);\n\t\t\tif (rc) {\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif ((sbsec->flags & SE_SBGENFS_XATTR) &&\n\t\t\t    (inode->i_opflags & IOP_XATTR)) {\n\t\t\t\trc = inode_doinit_use_xattr(inode, dentry,\n\t\t\t\t\t\t\t    sid, &sid);\n\t\t\t\tif (rc) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_PENDING) {\n\t\tif (rc) {\n\t\t\tisec->initialized = LABEL_INVALID;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tisec->sid = sid;\n\t}\n\nout_unlock:\n\tspin_unlock(&isec->lock);\n\treturn rc;\n\nout_invalid:\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_PENDING) {\n\t\tisec->initialized = LABEL_INVALID;\n\t\tisec->sid = sid;\n\t}\n\tspin_unlock(&isec->lock);\n\treturn 0;\n}\n\n \nstatic inline u32 signal_to_av(int sig)\n{\n\tu32 perm = 0;\n\n\tswitch (sig) {\n\tcase SIGCHLD:\n\t\t \n\t\tperm = PROCESS__SIGCHLD;\n\t\tbreak;\n\tcase SIGKILL:\n\t\t \n\t\tperm = PROCESS__SIGKILL;\n\t\tbreak;\n\tcase SIGSTOP:\n\t\t \n\t\tperm = PROCESS__SIGSTOP;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tperm = PROCESS__SIGNAL;\n\t\tbreak;\n\t}\n\n\treturn perm;\n}\n\n#if CAP_LAST_CAP > 63\n#error Fix SELinux to handle capabilities > 63.\n#endif\n\n \nstatic int cred_has_capability(const struct cred *cred,\n\t\t\t       int cap, unsigned int opts, bool initns)\n{\n\tstruct common_audit_data ad;\n\tstruct av_decision avd;\n\tu16 sclass;\n\tu32 sid = cred_sid(cred);\n\tu32 av = CAP_TO_MASK(cap);\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_CAP;\n\tad.u.cap = cap;\n\n\tswitch (CAP_TO_INDEX(cap)) {\n\tcase 0:\n\t\tsclass = initns ? SECCLASS_CAPABILITY : SECCLASS_CAP_USERNS;\n\t\tbreak;\n\tcase 1:\n\t\tsclass = initns ? SECCLASS_CAPABILITY2 : SECCLASS_CAP2_USERNS;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"SELinux:  out of range capability %d\\n\", cap);\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\trc = avc_has_perm_noaudit(sid, sid, sclass, av, 0, &avd);\n\tif (!(opts & CAP_OPT_NOAUDIT)) {\n\t\tint rc2 = avc_audit(sid, sid, sclass, av, &avd, rc, &ad);\n\t\tif (rc2)\n\t\t\treturn rc2;\n\t}\n\treturn rc;\n}\n\n \nstatic int inode_has_perm(const struct cred *cred,\n\t\t\t  struct inode *inode,\n\t\t\t  u32 perms,\n\t\t\t  struct common_audit_data *adp)\n{\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsid = cred_sid(cred);\n\tisec = selinux_inode(inode);\n\n\treturn avc_has_perm(sid, isec->sid, isec->sclass, perms, adp);\n}\n\n \nstatic inline int dentry_has_perm(const struct cred *cred,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  u32 av)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\t__inode_security_revalidate(inode, dentry, true);\n\treturn inode_has_perm(cred, inode, av, &ad);\n}\n\n \nstatic inline int path_has_perm(const struct cred *cred,\n\t\t\t\tconst struct path *path,\n\t\t\t\tu32 av)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = *path;\n\t__inode_security_revalidate(inode, path->dentry, true);\n\treturn inode_has_perm(cred, inode, av, &ad);\n}\n\n \nstatic inline int file_path_has_perm(const struct cred *cred,\n\t\t\t\t     struct file *file,\n\t\t\t\t     u32 av)\n{\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\treturn inode_has_perm(cred, file_inode(file), av, &ad);\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic int bpf_fd_pass(const struct file *file, u32 sid);\n#endif\n\n \nstatic int file_has_perm(const struct cred *cred,\n\t\t\t struct file *file,\n\t\t\t u32 av)\n{\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode *inode = file_inode(file);\n\tstruct common_audit_data ad;\n\tu32 sid = cred_sid(cred);\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(sid, fsec->sid,\n\t\t\t\t  SECCLASS_FD,\n\t\t\t\t  FD__USE,\n\t\t\t\t  &ad);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_BPF_SYSCALL\n\trc = bpf_fd_pass(file, cred_sid(cred));\n\tif (rc)\n\t\treturn rc;\n#endif\n\n\t \n\trc = 0;\n\tif (av)\n\t\trc = inode_has_perm(cred, inode, av, &ad);\n\nout:\n\treturn rc;\n}\n\n \nstatic int\nselinux_determine_inode_label(const struct task_security_struct *tsec,\n\t\t\t\t struct inode *dir,\n\t\t\t\t const struct qstr *name, u16 tclass,\n\t\t\t\t u32 *_new_isid)\n{\n\tconst struct superblock_security_struct *sbsec =\n\t\t\t\t\t\tselinux_superblock(dir->i_sb);\n\n\tif ((sbsec->flags & SE_SBINITIALIZED) &&\n\t    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {\n\t\t*_new_isid = sbsec->mntpoint_sid;\n\t} else if ((sbsec->flags & SBLABEL_MNT) &&\n\t\t   tsec->create_sid) {\n\t\t*_new_isid = tsec->create_sid;\n\t} else {\n\t\tconst struct inode_security_struct *dsec = inode_security(dir);\n\t\treturn security_transition_sid(tsec->sid,\n\t\t\t\t\t       dsec->sid, tclass,\n\t\t\t\t\t       name, _new_isid);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int may_create(struct inode *dir,\n\t\t      struct dentry *dentry,\n\t\t      u16 tclass)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct inode_security_struct *dsec;\n\tstruct superblock_security_struct *sbsec;\n\tu32 sid, newsid;\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tdsec = inode_security(dir);\n\tsbsec = selinux_superblock(dir->i_sb);\n\n\tsid = tsec->sid;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\trc = avc_has_perm(sid, dsec->sid, SECCLASS_DIR,\n\t\t\t  DIR__ADD_NAME | DIR__SEARCH,\n\t\t\t  &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = selinux_determine_inode_label(tsec, dir, &dentry->d_name, tclass,\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(sid, newsid, tclass, FILE__CREATE, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(newsid, sbsec->sid,\n\t\t\t    SECCLASS_FILESYSTEM,\n\t\t\t    FILESYSTEM__ASSOCIATE, &ad);\n}\n\n#define MAY_LINK\t0\n#define MAY_UNLINK\t1\n#define MAY_RMDIR\t2\n\n \nstatic int may_link(struct inode *dir,\n\t\t    struct dentry *dentry,\n\t\t    int kind)\n\n{\n\tstruct inode_security_struct *dsec, *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tu32 av;\n\tint rc;\n\n\tdsec = inode_security(dir);\n\tisec = backing_inode_security(dentry);\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\tav = DIR__SEARCH;\n\tav |= (kind ? DIR__REMOVE_NAME : DIR__ADD_NAME);\n\trc = avc_has_perm(sid, dsec->sid, SECCLASS_DIR, av, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (kind) {\n\tcase MAY_LINK:\n\t\tav = FILE__LINK;\n\t\tbreak;\n\tcase MAY_UNLINK:\n\t\tav = FILE__UNLINK;\n\t\tbreak;\n\tcase MAY_RMDIR:\n\t\tav = DIR__RMDIR;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"SELinux: %s:  unrecognized kind %d\\n\",\n\t\t\t__func__, kind);\n\t\treturn 0;\n\t}\n\n\trc = avc_has_perm(sid, isec->sid, isec->sclass, av, &ad);\n\treturn rc;\n}\n\nstatic inline int may_rename(struct inode *old_dir,\n\t\t\t     struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir,\n\t\t\t     struct dentry *new_dentry)\n{\n\tstruct inode_security_struct *old_dsec, *new_dsec, *old_isec, *new_isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tu32 av;\n\tint old_is_dir, new_is_dir;\n\tint rc;\n\n\told_dsec = inode_security(old_dir);\n\told_isec = backing_inode_security(old_dentry);\n\told_is_dir = d_is_dir(old_dentry);\n\tnew_dsec = inode_security(new_dir);\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\n\tad.u.dentry = old_dentry;\n\trc = avc_has_perm(sid, old_dsec->sid, SECCLASS_DIR,\n\t\t\t  DIR__REMOVE_NAME | DIR__SEARCH, &ad);\n\tif (rc)\n\t\treturn rc;\n\trc = avc_has_perm(sid, old_isec->sid,\n\t\t\t  old_isec->sclass, FILE__RENAME, &ad);\n\tif (rc)\n\t\treturn rc;\n\tif (old_is_dir && new_dir != old_dir) {\n\t\trc = avc_has_perm(sid, old_isec->sid,\n\t\t\t\t  old_isec->sclass, DIR__REPARENT, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tad.u.dentry = new_dentry;\n\tav = DIR__ADD_NAME | DIR__SEARCH;\n\tif (d_is_positive(new_dentry))\n\t\tav |= DIR__REMOVE_NAME;\n\trc = avc_has_perm(sid, new_dsec->sid, SECCLASS_DIR, av, &ad);\n\tif (rc)\n\t\treturn rc;\n\tif (d_is_positive(new_dentry)) {\n\t\tnew_isec = backing_inode_security(new_dentry);\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\t\trc = avc_has_perm(sid, new_isec->sid,\n\t\t\t\t  new_isec->sclass,\n\t\t\t\t  (new_is_dir ? DIR__RMDIR : FILE__UNLINK), &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int superblock_has_perm(const struct cred *cred,\n\t\t\t       struct super_block *sb,\n\t\t\t       u32 perms,\n\t\t\t       struct common_audit_data *ad)\n{\n\tstruct superblock_security_struct *sbsec;\n\tu32 sid = cred_sid(cred);\n\n\tsbsec = selinux_superblock(sb);\n\treturn avc_has_perm(sid, sbsec->sid, SECCLASS_FILESYSTEM, perms, ad);\n}\n\n \nstatic inline u32 file_mask_to_av(int mode, int mask)\n{\n\tu32 av = 0;\n\n\tif (!S_ISDIR(mode)) {\n\t\tif (mask & MAY_EXEC)\n\t\t\tav |= FILE__EXECUTE;\n\t\tif (mask & MAY_READ)\n\t\t\tav |= FILE__READ;\n\n\t\tif (mask & MAY_APPEND)\n\t\t\tav |= FILE__APPEND;\n\t\telse if (mask & MAY_WRITE)\n\t\t\tav |= FILE__WRITE;\n\n\t} else {\n\t\tif (mask & MAY_EXEC)\n\t\t\tav |= DIR__SEARCH;\n\t\tif (mask & MAY_WRITE)\n\t\t\tav |= DIR__WRITE;\n\t\tif (mask & MAY_READ)\n\t\t\tav |= DIR__READ;\n\t}\n\n\treturn av;\n}\n\n \nstatic inline u32 file_to_av(const struct file *file)\n{\n\tu32 av = 0;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tav |= FILE__READ;\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (file->f_flags & O_APPEND)\n\t\t\tav |= FILE__APPEND;\n\t\telse\n\t\t\tav |= FILE__WRITE;\n\t}\n\tif (!av) {\n\t\t \n\t\tav = FILE__IOCTL;\n\t}\n\n\treturn av;\n}\n\n \nstatic inline u32 open_file_to_av(struct file *file)\n{\n\tu32 av = file_to_av(file);\n\tstruct inode *inode = file_inode(file);\n\n\tif (selinux_policycap_openperm() &&\n\t    inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\tav |= FILE__OPEN;\n\n\treturn av;\n}\n\n \n\nstatic int selinux_binder_set_context_mgr(const struct cred *mgr)\n{\n\treturn avc_has_perm(current_sid(), cred_sid(mgr), SECCLASS_BINDER,\n\t\t\t    BINDER__SET_CONTEXT_MGR, NULL);\n}\n\nstatic int selinux_binder_transaction(const struct cred *from,\n\t\t\t\t      const struct cred *to)\n{\n\tu32 mysid = current_sid();\n\tu32 fromsid = cred_sid(from);\n\tu32 tosid = cred_sid(to);\n\tint rc;\n\n\tif (mysid != fromsid) {\n\t\trc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER,\n\t\t\t\t  BINDER__IMPERSONATE, NULL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn avc_has_perm(fromsid, tosid,\n\t\t\t    SECCLASS_BINDER, BINDER__CALL, NULL);\n}\n\nstatic int selinux_binder_transfer_binder(const struct cred *from,\n\t\t\t\t\t  const struct cred *to)\n{\n\treturn avc_has_perm(cred_sid(from), cred_sid(to),\n\t\t\t    SECCLASS_BINDER, BINDER__TRANSFER,\n\t\t\t    NULL);\n}\n\nstatic int selinux_binder_transfer_file(const struct cred *from,\n\t\t\t\t\tconst struct cred *to,\n\t\t\t\t\tconst struct file *file)\n{\n\tu32 sid = cred_sid(to);\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode_security_struct *isec;\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = file->f_path;\n\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(sid, fsec->sid,\n\t\t\t\t  SECCLASS_FD,\n\t\t\t\t  FD__USE,\n\t\t\t\t  &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n#ifdef CONFIG_BPF_SYSCALL\n\trc = bpf_fd_pass(file, sid);\n\tif (rc)\n\t\treturn rc;\n#endif\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\n\tisec = backing_inode_security(dentry);\n\treturn avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),\n\t\t\t    &ad);\n}\n\nstatic int selinux_ptrace_access_check(struct task_struct *child,\n\t\t\t\t       unsigned int mode)\n{\n\tu32 sid = current_sid();\n\tu32 csid = task_sid_obj(child);\n\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn avc_has_perm(sid, csid, SECCLASS_FILE, FILE__READ,\n\t\t\t\tNULL);\n\n\treturn avc_has_perm(sid, csid, SECCLASS_PROCESS, PROCESS__PTRACE,\n\t\t\tNULL);\n}\n\nstatic int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(task_sid_obj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}\n\nstatic int selinux_capget(const struct task_struct *target, kernel_cap_t *effective,\n\t\t\t  kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(target),\n\t\t\tSECCLASS_PROCESS, PROCESS__GETCAP, NULL);\n}\n\nstatic int selinux_capset(struct cred *new, const struct cred *old,\n\t\t\t  const kernel_cap_t *effective,\n\t\t\t  const kernel_cap_t *inheritable,\n\t\t\t  const kernel_cap_t *permitted)\n{\n\treturn avc_has_perm(cred_sid(old), cred_sid(new), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETCAP, NULL);\n}\n\n \n\nstatic int selinux_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t   int cap, unsigned int opts)\n{\n\treturn cred_has_capability(cred, cap, opts, ns == &init_user_ns);\n}\n\nstatic int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)\n{\n\tconst struct cred *cred = current_cred();\n\tint rc = 0;\n\n\tif (!sb)\n\t\treturn 0;\n\n\tswitch (cmds) {\n\tcase Q_SYNC:\n\tcase Q_QUOTAON:\n\tcase Q_QUOTAOFF:\n\tcase Q_SETINFO:\n\tcase Q_SETQUOTA:\n\tcase Q_XQUOTAOFF:\n\tcase Q_XQUOTAON:\n\tcase Q_XSETQLIM:\n\t\trc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAMOD, NULL);\n\t\tbreak;\n\tcase Q_GETFMT:\n\tcase Q_GETINFO:\n\tcase Q_GETQUOTA:\n\tcase Q_XGETQUOTA:\n\tcase Q_XGETQSTAT:\n\tcase Q_XGETQSTATV:\n\tcase Q_XGETNEXTQUOTA:\n\t\trc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAGET, NULL);\n\t\tbreak;\n\tdefault:\n\t\trc = 0;   \n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int selinux_quota_on(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__QUOTAON);\n}\n\nstatic int selinux_syslog(int type)\n{\n\tswitch (type) {\n\tcase SYSLOG_ACTION_READ_ALL:\t \n\tcase SYSLOG_ACTION_SIZE_BUFFER:\t \n\t\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_READ, NULL);\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\t \n\tcase SYSLOG_ACTION_CONSOLE_ON:\t \n\t \n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_CONSOLE,\n\t\t\t\t    NULL);\n\t}\n\t \n\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_MOD, NULL);\n}\n\n \nstatic int selinux_vm_enough_memory(struct mm_struct *mm, long pages)\n{\n\tint rc, cap_sys_admin = 0;\n\n\trc = cred_has_capability(current_cred(), CAP_SYS_ADMIN,\n\t\t\t\t CAP_OPT_NOAUDIT, true);\n\tif (rc == 0)\n\t\tcap_sys_admin = 1;\n\n\treturn cap_sys_admin;\n}\n\n \n\nstatic u32 ptrace_parent_sid(void)\n{\n\tu32 sid = 0;\n\tstruct task_struct *tracer;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\tsid = task_sid_obj(tracer);\n\trcu_read_unlock();\n\n\treturn sid;\n}\n\nstatic int check_nnp_nosuid(const struct linux_binprm *bprm,\n\t\t\t    const struct task_security_struct *old_tsec,\n\t\t\t    const struct task_security_struct *new_tsec)\n{\n\tint nnp = (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS);\n\tint nosuid = !mnt_may_suid(bprm->file->f_path.mnt);\n\tint rc;\n\tu32 av;\n\n\tif (!nnp && !nosuid)\n\t\treturn 0;  \n\n\tif (new_tsec->sid == old_tsec->sid)\n\t\treturn 0;  \n\n\t \n\tif (selinux_policycap_nnp_nosuid_transition()) {\n\t\tav = 0;\n\t\tif (nnp)\n\t\t\tav |= PROCESS2__NNP_TRANSITION;\n\t\tif (nosuid)\n\t\t\tav |= PROCESS2__NOSUID_TRANSITION;\n\t\trc = avc_has_perm(old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS2, av, NULL);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\t \n\trc = security_bounded_transition(old_tsec->sid,\n\t\t\t\t\t new_tsec->sid);\n\tif (!rc)\n\t\treturn 0;\n\n\t \n\tif (nnp)\n\t\treturn -EPERM;\n\treturn -EACCES;\n}\n\nstatic int selinux_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\tconst struct task_security_struct *old_tsec;\n\tstruct task_security_struct *new_tsec;\n\tstruct inode_security_struct *isec;\n\tstruct common_audit_data ad;\n\tstruct inode *inode = file_inode(bprm->file);\n\tint rc;\n\n\t \n\n\told_tsec = selinux_cred(current_cred());\n\tnew_tsec = selinux_cred(bprm->cred);\n\tisec = inode_security(inode);\n\n\t \n\tnew_tsec->sid = old_tsec->sid;\n\tnew_tsec->osid = old_tsec->sid;\n\n\t \n\tnew_tsec->create_sid = 0;\n\tnew_tsec->keycreate_sid = 0;\n\tnew_tsec->sockcreate_sid = 0;\n\n\tif (old_tsec->exec_sid) {\n\t\tnew_tsec->sid = old_tsec->exec_sid;\n\t\t \n\t\tnew_tsec->exec_sid = 0;\n\n\t\t \n\t\trc = check_nnp_nosuid(bprm, old_tsec, new_tsec);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\trc = security_transition_sid(old_tsec->sid,\n\t\t\t\t\t     isec->sid, SECCLASS_PROCESS, NULL,\n\t\t\t\t\t     &new_tsec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = check_nnp_nosuid(bprm, old_tsec, new_tsec);\n\t\tif (rc)\n\t\t\tnew_tsec->sid = old_tsec->sid;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = bprm->file;\n\n\tif (new_tsec->sid == old_tsec->sid) {\n\t\trc = avc_has_perm(old_tsec->sid, isec->sid,\n\t\t\t\t  SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\trc = avc_has_perm(old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS, PROCESS__TRANSITION, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = avc_has_perm(new_tsec->sid, isec->sid,\n\t\t\t\t  SECCLASS_FILE, FILE__ENTRYPOINT, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (bprm->unsafe & LSM_UNSAFE_SHARE) {\n\t\t\trc = avc_has_perm(old_tsec->sid, new_tsec->sid,\n\t\t\t\t\t  SECCLASS_PROCESS, PROCESS__SHARE,\n\t\t\t\t\t  NULL);\n\t\t\tif (rc)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t \n\t\tif (bprm->unsafe & LSM_UNSAFE_PTRACE) {\n\t\t\tu32 ptsid = ptrace_parent_sid();\n\t\t\tif (ptsid != 0) {\n\t\t\t\trc = avc_has_perm(ptsid, new_tsec->sid,\n\t\t\t\t\t\t  SECCLASS_PROCESS,\n\t\t\t\t\t\t  PROCESS__PTRACE, NULL);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t\t \n\t\trc = avc_has_perm(old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS, PROCESS__NOATSECURE,\n\t\t\t\t  NULL);\n\t\tbprm->secureexec |= !!rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int match_file(const void *p, struct file *file, unsigned fd)\n{\n\treturn file_has_perm(p, file, file_to_av(file)) ? fd + 1 : 0;\n}\n\n \nstatic inline void flush_unauthorized_files(const struct cred *cred,\n\t\t\t\t\t    struct files_struct *files)\n{\n\tstruct file *file, *devnull = NULL;\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\tunsigned n;\n\n\ttty = get_current_tty();\n\tif (tty) {\n\t\tspin_lock(&tty->files_lock);\n\t\tif (!list_empty(&tty->tty_files)) {\n\t\t\tstruct tty_file_private *file_priv;\n\n\t\t\t \n\t\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t\tstruct tty_file_private, list);\n\t\t\tfile = file_priv->file;\n\t\t\tif (file_path_has_perm(cred, file, FILE__READ | FILE__WRITE))\n\t\t\t\tdrop_tty = 1;\n\t\t}\n\t\tspin_unlock(&tty->files_lock);\n\t\ttty_kref_put(tty);\n\t}\n\t \n\tif (drop_tty)\n\t\tno_tty();\n\n\t \n\tn = iterate_fd(files, 0, match_file, cred);\n\tif (!n)  \n\t\treturn;\n\n\tdevnull = dentry_open(&selinux_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t \n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, cred)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\n}\n\n \nstatic void selinux_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tstruct task_security_struct *new_tsec;\n\tstruct rlimit *rlim, *initrlim;\n\tint rc, i;\n\n\tnew_tsec = selinux_cred(bprm->cred);\n\tif (new_tsec->sid == new_tsec->osid)\n\t\treturn;\n\n\t \n\tflush_unauthorized_files(bprm->cred, current->files);\n\n\t \n\tcurrent->pdeath_signal = 0;\n\n\t \n\trc = avc_has_perm(new_tsec->osid, new_tsec->sid, SECCLASS_PROCESS,\n\t\t\t  PROCESS__RLIMITINH, NULL);\n\tif (rc) {\n\t\t \n\t\ttask_lock(current);\n\t\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\t\trlim = current->signal->rlim + i;\n\t\t\tinitrlim = init_task.signal->rlim + i;\n\t\t\trlim->rlim_cur = min(rlim->rlim_max, initrlim->rlim_cur);\n\t\t}\n\t\ttask_unlock(current);\n\t\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\t\tupdate_rlimit_cpu(current, rlimit(RLIMIT_CPU));\n\t}\n}\n\n \nstatic void selinux_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 osid, sid;\n\tint rc;\n\n\tosid = tsec->osid;\n\tsid = tsec->sid;\n\n\tif (sid == osid)\n\t\treturn;\n\n\t \n\trc = avc_has_perm(osid, sid, SECCLASS_PROCESS, PROCESS__SIGINH, NULL);\n\tif (rc) {\n\t\tclear_itimer();\n\n\t\tspin_lock_irq(&unrcu_pointer(current->sighand)->siglock);\n\t\tif (!fatal_signal_pending(current)) {\n\t\t\tflush_sigqueue(&current->pending);\n\t\t\tflush_sigqueue(&current->signal->shared_pending);\n\t\t\tflush_signal_handlers(current, 1);\n\t\t\tsigemptyset(&current->blocked);\n\t\t\trecalc_sigpending();\n\t\t}\n\t\tspin_unlock_irq(&unrcu_pointer(current->sighand)->siglock);\n\t}\n\n\t \n\tread_lock(&tasklist_lock);\n\t__wake_up_parent(current, unrcu_pointer(current->real_parent));\n\tread_unlock(&tasklist_lock);\n}\n\n \n\nstatic int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\n\treturn 0;\n}\n\nstatic inline int opt_len(const char *s)\n{\n\tbool open_quote = false;\n\tint len;\n\tchar c;\n\n\tfor (len = 0; (c = s[len]) != '\\0'; len++) {\n\t\tif (c == '\"')\n\t\t\topen_quote = !open_quote;\n\t\tif (c == ',' && !open_quote)\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int selinux_sb_eat_lsm_opts(char *options, void **mnt_opts)\n{\n\tchar *from = options;\n\tchar *to = options;\n\tbool first = true;\n\tint rc;\n\n\twhile (1) {\n\t\tint len = opt_len(from);\n\t\tint token;\n\t\tchar *arg = NULL;\n\n\t\ttoken = match_opt_prefix(from, len, &arg);\n\n\t\tif (token != Opt_error) {\n\t\t\tchar *p, *q;\n\n\t\t\t \n\t\t\tif (arg) {\n\t\t\t\tfor (p = q = arg; p < from + len; p++) {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (c != '\"')\n\t\t\t\t\t\t*q++ = c;\n\t\t\t\t}\n\t\t\t\targ = kmemdup_nul(arg, q - arg, GFP_KERNEL);\n\t\t\t\tif (!arg) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tgoto free_opt;\n\t\t\t\t}\n\t\t\t}\n\t\t\trc = selinux_add_opt(token, arg, mnt_opts);\n\t\t\tkfree(arg);\n\t\t\targ = NULL;\n\t\t\tif (unlikely(rc)) {\n\t\t\t\tgoto free_opt;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!first) {\t\n\t\t\t\tfrom--;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\t\t\tto += len;\n\t\t\tfirst = false;\n\t\t}\n\t\tif (!from[len])\n\t\t\tbreak;\n\t\tfrom += len + 1;\n\t}\n\t*to = '\\0';\n\treturn 0;\n\nfree_opt:\n\tif (*mnt_opts) {\n\t\tselinux_free_mnt_opts(*mnt_opts);\n\t\t*mnt_opts = NULL;\n\t}\n\treturn rc;\n}\n\nstatic int selinux_sb_mnt_opts_compat(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\n\t \n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn opts ? 1 : 0;\n\n\t \n\tif (!opts)\n\t\treturn (sbsec->flags & SE_MNTMASK) ? 1 : 0;\n\n\tif (opts->fscontext_sid) {\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,\n\t\t\t       opts->fscontext_sid))\n\t\t\treturn 1;\n\t}\n\tif (opts->context_sid) {\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,\n\t\t\t       opts->context_sid))\n\t\t\treturn 1;\n\t}\n\tif (opts->rootcontext_sid) {\n\t\tstruct inode_security_struct *root_isec;\n\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,\n\t\t\t       opts->rootcontext_sid))\n\t\t\treturn 1;\n\t}\n\tif (opts->defcontext_sid) {\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,\n\t\t\t       opts->defcontext_sid))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = selinux_superblock(sb);\n\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\n\tif (!opts)\n\t\treturn 0;\n\n\tif (opts->fscontext_sid) {\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,\n\t\t\t       opts->fscontext_sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context_sid) {\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,\n\t\t\t       opts->context_sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext_sid) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,\n\t\t\t       opts->rootcontext_sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext_sid) {\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,\n\t\t\t       opts->defcontext_sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\n\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}\n\nstatic int selinux_sb_kern_mount(struct super_block *sb)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = sb->s_root;\n\treturn superblock_has_perm(cred, sb, FILESYSTEM__MOUNT, &ad);\n}\n\nstatic int selinux_sb_statfs(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry->d_sb->s_root;\n\treturn superblock_has_perm(cred, dentry->d_sb, FILESYSTEM__GETATTR, &ad);\n}\n\nstatic int selinux_mount(const char *dev_name,\n\t\t\t const struct path *path,\n\t\t\t const char *type,\n\t\t\t unsigned long flags,\n\t\t\t void *data)\n{\n\tconst struct cred *cred = current_cred();\n\n\tif (flags & MS_REMOUNT)\n\t\treturn superblock_has_perm(cred, path->dentry->d_sb,\n\t\t\t\t\t   FILESYSTEM__REMOUNT, NULL);\n\telse\n\t\treturn path_has_perm(cred, path, FILE__MOUNTON);\n}\n\nstatic int selinux_move_mount(const struct path *from_path,\n\t\t\t      const struct path *to_path)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn path_has_perm(cred, to_path, FILE__MOUNTON);\n}\n\nstatic int selinux_umount(struct vfsmount *mnt, int flags)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn superblock_has_perm(cred, mnt->mnt_sb,\n\t\t\t\t   FILESYSTEM__UNMOUNT, NULL);\n}\n\nstatic int selinux_fs_context_submount(struct fs_context *fc,\n\t\t\t\t   struct super_block *reference)\n{\n\tconst struct superblock_security_struct *sbsec = selinux_superblock(reference);\n\tstruct selinux_mnt_opts *opts;\n\n\t \n\tif (!(sbsec->flags & (FSCONTEXT_MNT|CONTEXT_MNT|DEFCONTEXT_MNT)))\n\t\treturn 0;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\tif (sbsec->flags & FSCONTEXT_MNT)\n\t\topts->fscontext_sid = sbsec->sid;\n\tif (sbsec->flags & CONTEXT_MNT)\n\t\topts->context_sid = sbsec->mntpoint_sid;\n\tif (sbsec->flags & DEFCONTEXT_MNT)\n\t\topts->defcontext_sid = sbsec->def_sid;\n\tfc->security = opts;\n\treturn 0;\n}\n\nstatic int selinux_fs_context_dup(struct fs_context *fc,\n\t\t\t\t  struct fs_context *src_fc)\n{\n\tconst struct selinux_mnt_opts *src = src_fc->security;\n\n\tif (!src)\n\t\treturn 0;\n\n\tfc->security = kmemdup(src, sizeof(*src), GFP_KERNEL);\n\treturn fc->security ? 0 : -ENOMEM;\n}\n\nstatic const struct fs_parameter_spec selinux_fs_parameters[] = {\n\tfsparam_string(CONTEXT_STR,\tOpt_context),\n\tfsparam_string(DEFCONTEXT_STR,\tOpt_defcontext),\n\tfsparam_string(FSCONTEXT_STR,\tOpt_fscontext),\n\tfsparam_string(ROOTCONTEXT_STR,\tOpt_rootcontext),\n\tfsparam_flag  (SECLABEL_STR,\tOpt_seclabel),\n\t{}\n};\n\nstatic int selinux_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t\t  struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, selinux_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\treturn selinux_add_opt(opt, param->string, &fc->security);\n}\n\n \n\nstatic int selinux_inode_alloc_security(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = current_sid();\n\n\tspin_lock_init(&isec->lock);\n\tINIT_LIST_HEAD(&isec->list);\n\tisec->inode = inode;\n\tisec->sid = SECINITSID_UNLABELED;\n\tisec->sclass = SECCLASS_FILE;\n\tisec->task_sid = sid;\n\tisec->initialized = LABEL_INVALID;\n\n\treturn 0;\n}\n\nstatic void selinux_inode_free_security(struct inode *inode)\n{\n\tinode_free_security(inode);\n}\n\nstatic int selinux_dentry_init_security(struct dentry *dentry, int mode,\n\t\t\t\t\tconst struct qstr *name,\n\t\t\t\t\tconst char **xattr_name, void **ctx,\n\t\t\t\t\tu32 *ctxlen)\n{\n\tu32 newsid;\n\tint rc;\n\n\trc = selinux_determine_inode_label(selinux_cred(current_cred()),\n\t\t\t\t\t   d_inode(dentry->d_parent), name,\n\t\t\t\t\t   inode_mode_to_security_class(mode),\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (xattr_name)\n\t\t*xattr_name = XATTR_NAME_SELINUX;\n\n\treturn security_sid_to_context(newsid, (char **)ctx,\n\t\t\t\t       ctxlen);\n}\n\nstatic int selinux_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\t  struct qstr *name,\n\t\t\t\t\t  const struct cred *old,\n\t\t\t\t\t  struct cred *new)\n{\n\tu32 newsid;\n\tint rc;\n\tstruct task_security_struct *tsec;\n\n\trc = selinux_determine_inode_label(selinux_cred(old),\n\t\t\t\t\t   d_inode(dentry->d_parent), name,\n\t\t\t\t\t   inode_mode_to_security_class(mode),\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\ttsec = selinux_cred(new);\n\ttsec->create_sid = newsid;\n\treturn 0;\n}\n\nstatic int selinux_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t       const struct qstr *qstr,\n\t\t\t\t       struct xattr *xattrs, int *xattr_count)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct superblock_security_struct *sbsec;\n\tstruct xattr *xattr = lsm_get_xattr_slot(xattrs, xattr_count);\n\tu32 newsid, clen;\n\tint rc;\n\tchar *context;\n\n\tsbsec = selinux_superblock(dir->i_sb);\n\n\tnewsid = tsec->create_sid;\n\n\trc = selinux_determine_inode_label(tsec, dir, qstr,\n\t\tinode_mode_to_security_class(inode->i_mode),\n\t\t&newsid);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (sbsec->flags & SE_SBINITIALIZED) {\n\t\tstruct inode_security_struct *isec = selinux_inode(inode);\n\t\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\t\tisec->sid = newsid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t}\n\n\tif (!selinux_initialized() ||\n\t    !(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (xattr) {\n\t\trc = security_sid_to_context_force(newsid,\n\t\t\t\t\t\t   &context, &clen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\txattr->value = context;\n\t\txattr->value_len = clen;\n\t\txattr->name = XATTR_SELINUX_SUFFIX;\n\t}\n\n\treturn 0;\n}\n\nstatic int selinux_inode_init_security_anon(struct inode *inode,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    const struct inode *context_inode)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tint rc;\n\n\tif (unlikely(!selinux_initialized()))\n\t\treturn 0;\n\n\tisec = selinux_inode(inode);\n\n\t \n\n\tif (context_inode) {\n\t\tstruct inode_security_struct *context_isec =\n\t\t\tselinux_inode(context_inode);\n\t\tif (context_isec->initialized != LABEL_INITIALIZED) {\n\t\t\tpr_err(\"SELinux:  context_inode is not initialized\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tisec->sclass = context_isec->sclass;\n\t\tisec->sid = context_isec->sid;\n\t} else {\n\t\tisec->sclass = SECCLASS_ANON_INODE;\n\t\trc = security_transition_sid(\n\t\t\ttsec->sid, tsec->sid,\n\t\t\tisec->sclass, name, &isec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tisec->initialized = LABEL_INITIALIZED;\n\t \n\n\tad.type = LSM_AUDIT_DATA_ANONINODE;\n\tad.u.anonclass = name ? (const char *)name->name : \"?\";\n\n\treturn avc_has_perm(tsec->sid,\n\t\t\t    isec->sid,\n\t\t\t    isec->sclass,\n\t\t\t    FILE__CREATE,\n\t\t\t    &ad);\n}\n\nstatic int selinux_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn may_create(dir, dentry, SECCLASS_FILE);\n}\n\nstatic int selinux_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)\n{\n\treturn may_link(dir, old_dentry, MAY_LINK);\n}\n\nstatic int selinux_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn may_link(dir, dentry, MAY_UNLINK);\n}\n\nstatic int selinux_inode_symlink(struct inode *dir, struct dentry *dentry, const char *name)\n{\n\treturn may_create(dir, dentry, SECCLASS_LNK_FILE);\n}\n\nstatic int selinux_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mask)\n{\n\treturn may_create(dir, dentry, SECCLASS_DIR);\n}\n\nstatic int selinux_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn may_link(dir, dentry, MAY_RMDIR);\n}\n\nstatic int selinux_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\treturn may_create(dir, dentry, inode_mode_to_security_class(mode));\n}\n\nstatic int selinux_inode_rename(struct inode *old_inode, struct dentry *old_dentry,\n\t\t\t\tstruct inode *new_inode, struct dentry *new_dentry)\n{\n\treturn may_rename(old_inode, old_dentry, new_inode, new_dentry);\n}\n\nstatic int selinux_inode_readlink(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__READ);\n}\n\nstatic int selinux_inode_follow_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t     bool rcu)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\tsid = cred_sid(cred);\n\tisec = inode_security_rcu(inode, rcu);\n\tif (IS_ERR(isec))\n\t\treturn PTR_ERR(isec);\n\n\treturn avc_has_perm(sid, isec->sid, isec->sclass, FILE__READ, &ad);\n}\n\nstatic noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\n\treturn slow_avc_audit(current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n}\n\nstatic int selinux_inode_permission(struct inode *inode, int mask)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 perms;\n\tbool from_access;\n\tbool no_block = mask & MAY_NOT_BLOCK;\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\tstruct av_decision avd;\n\tint rc, rc2;\n\tu32 audited, denied;\n\n\tfrom_access = mask & MAY_ACCESS;\n\tmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\n\n\t \n\tif (!mask)\n\t\treturn 0;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tperms = file_mask_to_av(inode->i_mode, mask);\n\n\tsid = cred_sid(cred);\n\tisec = inode_security_rcu(inode, no_block);\n\tif (IS_ERR(isec))\n\t\treturn PTR_ERR(isec);\n\n\trc = avc_has_perm_noaudit(sid, isec->sid, isec->sclass, perms, 0,\n\t\t\t\t  &avd);\n\taudited = avc_audit_required(perms, &avd, rc,\n\t\t\t\t     from_access ? FILE__AUDIT_ACCESS : 0,\n\t\t\t\t     &denied);\n\tif (likely(!audited))\n\t\treturn rc;\n\n\trc2 = audit_inode_permission(inode, perms, audited, denied, rc);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}\n\nstatic int selinux_inode_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tunsigned int ia_valid = iattr->ia_valid;\n\t__u32 av = FILE__WRITE;\n\n\t \n\tif (ia_valid & ATTR_FORCE) {\n\t\tia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_MODE |\n\t\t\t      ATTR_FORCE);\n\t\tif (!ia_valid)\n\t\t\treturn 0;\n\t}\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID |\n\t\t\tATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_TIMES_SET))\n\t\treturn dentry_has_perm(cred, dentry, FILE__SETATTR);\n\n\tif (selinux_policycap_openperm() &&\n\t    inode->i_sb->s_magic != SOCKFS_MAGIC &&\n\t    (ia_valid & ATTR_SIZE) &&\n\t    !(ia_valid & ATTR_FILE))\n\t\tav |= FILE__OPEN;\n\n\treturn dentry_has_perm(cred, dentry, av);\n}\n\nstatic int selinux_inode_getattr(const struct path *path)\n{\n\treturn path_has_perm(current_cred(), path, FILE__GETATTR);\n}\n\nstatic bool has_cap_mac_admin(bool audit)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned int opts = audit ? CAP_OPT_NONE : CAP_OPT_NOAUDIT;\n\n\tif (cap_capable(cred, &init_user_ns, CAP_MAC_ADMIN, opts))\n\t\treturn false;\n\tif (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true))\n\t\treturn false;\n\treturn true;\n}\n\nstatic int selinux_inode_setxattr(struct mnt_idmap *idmap,\n\t\t\t\t  struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct inode_security_struct *isec;\n\tstruct superblock_security_struct *sbsec;\n\tstruct common_audit_data ad;\n\tu32 newsid, sid = current_sid();\n\tint rc = 0;\n\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\trc = cap_inode_setxattr(dentry, name, value, size, flags);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n\t}\n\n\tif (!selinux_initialized())\n\t\treturn (inode_owner_or_capable(idmap, inode) ? 0 : -EPERM);\n\n\tsbsec = selinux_superblock(inode->i_sb);\n\tif (!(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EPERM;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\tisec = backing_inode_security(dentry);\n\trc = avc_has_perm(sid, isec->sid, isec->sclass,\n\t\t\t  FILE__RELABELFROM, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = security_context_to_sid(value, size, &newsid,\n\t\t\t\t     GFP_KERNEL);\n\tif (rc == -EINVAL) {\n\t\tif (!has_cap_mac_admin(true)) {\n\t\t\tstruct audit_buffer *ab;\n\t\t\tsize_t audit_size;\n\n\t\t\t \n\t\t\tif (value) {\n\t\t\t\tconst char *str = value;\n\n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t} else {\n\t\t\t\taudit_size = 0;\n\t\t\t}\n\t\t\tab = audit_log_start(audit_context(),\n\t\t\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\t\t\tif (!ab)\n\t\t\t\treturn rc;\n\t\t\taudit_log_format(ab, \"op=setxattr invalid_context=\");\n\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\taudit_log_end(ab);\n\n\t\t\treturn rc;\n\t\t}\n\t\trc = security_context_to_sid_force(value,\n\t\t\t\t\t\t   size, &newsid);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(sid, newsid, isec->sclass,\n\t\t\t  FILE__RELABELTO, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = security_validate_transition(isec->sid, newsid,\n\t\t\t\t\t  sid, isec->sclass);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(newsid,\n\t\t\t    sbsec->sid,\n\t\t\t    SECCLASS_FILESYSTEM,\n\t\t\t    FILESYSTEM__ASSOCIATE,\n\t\t\t    &ad);\n}\n\nstatic int selinux_inode_set_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct dentry *dentry, const char *acl_name,\n\t\t\t\t struct posix_acl *kacl)\n{\n\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n}\n\nstatic int selinux_inode_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct dentry *dentry, const char *acl_name)\n{\n\treturn dentry_has_perm(current_cred(), dentry, FILE__GETATTR);\n}\n\nstatic int selinux_inode_remove_acl(struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *dentry, const char *acl_name)\n{\n\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n}\n\nstatic void selinux_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tconst void *value, size_t size,\n\t\t\t\t\tint flags)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct inode_security_struct *isec;\n\tu32 newsid;\n\tint rc;\n\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!selinux_initialized()) {\n\t\t \n\t\treturn;\n\t}\n\n\trc = security_context_to_sid_force(value, size,\n\t\t\t\t\t   &newsid);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  unable to map context to SID\"\n\t\t       \"for (%s, %lu), rc=%d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, -rc);\n\t\treturn;\n\t}\n\n\tisec = backing_inode_security(dentry);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = newsid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}\n\nstatic int selinux_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__GETATTR);\n}\n\nstatic int selinux_inode_listxattr(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__GETATTR);\n}\n\nstatic int selinux_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t\t     struct dentry *dentry, const char *name)\n{\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\tint rc = cap_inode_removexattr(idmap, dentry, name);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n\t}\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\t \n\treturn -EACCES;\n}\n\nstatic int selinux_path_notify(const struct path *path, u64 mask,\n\t\t\t\t\t\tunsigned int obj_type)\n{\n\tint ret;\n\tu32 perm;\n\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = *path;\n\n\t \n\tswitch (obj_type) {\n\tcase FSNOTIFY_OBJ_TYPE_VFSMOUNT:\n\t\tperm = FILE__WATCH_MOUNT;\n\t\tbreak;\n\tcase FSNOTIFY_OBJ_TYPE_SB:\n\t\tperm = FILE__WATCH_SB;\n\t\tret = superblock_has_perm(current_cred(), path->dentry->d_sb,\n\t\t\t\t\t\tFILESYSTEM__WATCH, &ad);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase FSNOTIFY_OBJ_TYPE_INODE:\n\t\tperm = FILE__WATCH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mask & (ALL_FSNOTIFY_PERM_EVENTS))\n\t\tperm |= FILE__WATCH_WITH_PERM;\n\n\t \n\tif (mask & (FS_ACCESS | FS_ACCESS_PERM | FS_CLOSE_NOWRITE))\n\t\tperm |= FILE__WATCH_READS;\n\n\treturn path_has_perm(current_cred(), path, perm);\n}\n\n \nstatic int selinux_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t\t     struct inode *inode, const char *name,\n\t\t\t\t     void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\n\t \n\tif (!selinux_initialized() ||\n\t    strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}\n\nstatic int selinux_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t     const void *value, size_t size, int flags)\n{\n\tstruct inode_security_struct *isec = inode_security_novalidate(inode);\n\tstruct superblock_security_struct *sbsec;\n\tu32 newsid;\n\tint rc;\n\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\n\tsbsec = selinux_superblock(inode->i_sb);\n\tif (!(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!value || !size)\n\t\treturn -EACCES;\n\n\trc = security_context_to_sid(value, size, &newsid,\n\t\t\t\t     GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = newsid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n\treturn 0;\n}\n\nstatic int selinux_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n{\n\tconst int len = sizeof(XATTR_NAME_SELINUX);\n\n\tif (!selinux_initialized())\n\t\treturn 0;\n\n\tif (buffer && len <= buffer_size)\n\t\tmemcpy(buffer, XATTR_NAME_SELINUX, len);\n\treturn len;\n}\n\nstatic void selinux_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tstruct inode_security_struct *isec = inode_security_novalidate(inode);\n\t*secid = isec->sid;\n}\n\nstatic int selinux_inode_copy_up(struct dentry *src, struct cred **new)\n{\n\tu32 sid;\n\tstruct task_security_struct *tsec;\n\tstruct cred *new_creds = *new;\n\n\tif (new_creds == NULL) {\n\t\tnew_creds = prepare_creds();\n\t\tif (!new_creds)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsec = selinux_cred(new_creds);\n\t \n\tselinux_inode_getsecid(d_inode(src), &sid);\n\ttsec->create_sid = sid;\n\t*new = new_creds;\n\treturn 0;\n}\n\nstatic int selinux_inode_copy_up_xattr(const char *name)\n{\n\t \n\tif (strcmp(name, XATTR_NAME_SELINUX) == 0)\n\t\treturn 1;  \n\t \n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic int selinux_kernfs_init_security(struct kernfs_node *kn_dir,\n\t\t\t\t\tstruct kernfs_node *kn)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 parent_sid, newsid, clen;\n\tint rc;\n\tchar *context;\n\n\trc = kernfs_xattr_get(kn_dir, XATTR_NAME_SELINUX, NULL, 0);\n\tif (rc == -ENODATA)\n\t\treturn 0;\n\telse if (rc < 0)\n\t\treturn rc;\n\n\tclen = (u32)rc;\n\tcontext = kmalloc(clen, GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\trc = kernfs_xattr_get(kn_dir, XATTR_NAME_SELINUX, context, clen);\n\tif (rc < 0) {\n\t\tkfree(context);\n\t\treturn rc;\n\t}\n\n\trc = security_context_to_sid(context, clen, &parent_sid,\n\t\t\t\t     GFP_KERNEL);\n\tkfree(context);\n\tif (rc)\n\t\treturn rc;\n\n\tif (tsec->create_sid) {\n\t\tnewsid = tsec->create_sid;\n\t} else {\n\t\tu16 secclass = inode_mode_to_security_class(kn->mode);\n\t\tstruct qstr q;\n\n\t\tq.name = kn->name;\n\t\tq.hash_len = hashlen_string(kn_dir, kn->name);\n\n\t\trc = security_transition_sid(tsec->sid,\n\t\t\t\t\t     parent_sid, secclass, &q,\n\t\t\t\t\t     &newsid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = security_sid_to_context_force(newsid,\n\t\t\t\t\t   &context, &clen);\n\tif (rc)\n\t\treturn rc;\n\n\trc = kernfs_xattr_set(kn, XATTR_NAME_SELINUX, context, clen,\n\t\t\t      XATTR_CREATE);\n\tkfree(context);\n\treturn rc;\n}\n\n\n \n\nstatic int selinux_revalidate_file_permission(struct file *file, int mask)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *inode = file_inode(file);\n\n\t \n\tif ((file->f_flags & O_APPEND) && (mask & MAY_WRITE))\n\t\tmask |= MAY_APPEND;\n\n\treturn file_has_perm(cred, file,\n\t\t\t     file_mask_to_av(inode->i_mode, mask));\n}\n\nstatic int selinux_file_permission(struct file *file, int mask)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode_security_struct *isec;\n\tu32 sid = current_sid();\n\n\tif (!mask)\n\t\t \n\t\treturn 0;\n\n\tisec = inode_security(inode);\n\tif (sid == fsec->sid && fsec->isid == isec->sid &&\n\t    fsec->pseqno == avc_policy_seqno())\n\t\t \n\t\treturn 0;\n\n\treturn selinux_revalidate_file_permission(file, mask);\n}\n\nstatic int selinux_file_alloc_security(struct file *file)\n{\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tu32 sid = current_sid();\n\n\tfsec->sid = sid;\n\tfsec->fown_sid = sid;\n\n\treturn 0;\n}\n\n \nstatic int ioctl_has_perm(const struct cred *cred, struct file *file,\n\t\tu32 requested, u16 cmd)\n{\n\tstruct common_audit_data ad;\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_security_struct *isec;\n\tstruct lsm_ioctlop_audit ioctl;\n\tu32 ssid = cred_sid(cred);\n\tint rc;\n\tu8 driver = cmd >> 8;\n\tu8 xperm = cmd & 0xff;\n\n\tad.type = LSM_AUDIT_DATA_IOCTL_OP;\n\tad.u.op = &ioctl;\n\tad.u.op->cmd = cmd;\n\tad.u.op->path = file->f_path;\n\n\tif (ssid != fsec->sid) {\n\t\trc = avc_has_perm(ssid, fsec->sid,\n\t\t\t\tSECCLASS_FD,\n\t\t\t\tFD__USE,\n\t\t\t\t&ad);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tisec = inode_security(inode);\n\trc = avc_has_extended_perms(ssid, isec->sid, isec->sclass,\n\t\t\t\t    requested, driver, xperm, &ad);\nout:\n\treturn rc;\n}\n\nstatic int selinux_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tconst struct cred *cred = current_cred();\n\tint error = 0;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\tcase FIBMAP:\n\tcase FIGETBSZ:\n\tcase FS_IOC_GETFLAGS:\n\tcase FS_IOC_GETVERSION:\n\t\terror = file_has_perm(cred, file, FILE__GETATTR);\n\t\tbreak;\n\n\tcase FS_IOC_SETFLAGS:\n\tcase FS_IOC_SETVERSION:\n\t\terror = file_has_perm(cred, file, FILE__SETATTR);\n\t\tbreak;\n\n\t \n\tcase FIONBIO:\n\tcase FIOASYNC:\n\t\terror = file_has_perm(cred, file, 0);\n\t\tbreak;\n\n\tcase KDSKBENT:\n\tcase KDSKBSENT:\n\t\terror = cred_has_capability(cred, CAP_SYS_TTY_CONFIG,\n\t\t\t\t\t    CAP_OPT_NONE, true);\n\t\tbreak;\n\n\tcase FIOCLEX:\n\tcase FIONCLEX:\n\t\tif (!selinux_policycap_ioctl_skip_cloexec())\n\t\t\terror = ioctl_has_perm(cred, file, FILE__IOCTL, (u16) cmd);\n\t\tbreak;\n\n\t \n\tdefault:\n\t\terror = ioctl_has_perm(cred, file, FILE__IOCTL, (u16) cmd);\n\t}\n\treturn error;\n}\n\nstatic int default_noexec __ro_after_init;\n\nstatic int file_map_prot_check(struct file *file, unsigned long prot, int shared)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 sid = cred_sid(cred);\n\tint rc = 0;\n\n\tif (default_noexec &&\n\t    (prot & PROT_EXEC) && (!file || IS_PRIVATE(file_inode(file)) ||\n\t\t\t\t   (!shared && (prot & PROT_WRITE)))) {\n\t\t \n\t\trc = avc_has_perm(sid, sid, SECCLASS_PROCESS,\n\t\t\t\t  PROCESS__EXECMEM, NULL);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\tif (file) {\n\t\t \n\t\tu32 av = FILE__READ;\n\n\t\t \n\t\tif (shared && (prot & PROT_WRITE))\n\t\t\tav |= FILE__WRITE;\n\n\t\tif (prot & PROT_EXEC)\n\t\t\tav |= FILE__EXECUTE;\n\n\t\treturn file_has_perm(cred, file, av);\n\t}\n\nerror:\n\treturn rc;\n}\n\nstatic int selinux_mmap_addr(unsigned long addr)\n{\n\tint rc = 0;\n\n\tif (addr < CONFIG_LSM_MMAP_MIN_ADDR) {\n\t\tu32 sid = current_sid();\n\t\trc = avc_has_perm(sid, sid, SECCLASS_MEMPROTECT,\n\t\t\t\t  MEMPROTECT__MMAP_ZERO, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_mmap_file(struct file *file,\n\t\t\t     unsigned long reqprot __always_unused,\n\t\t\t     unsigned long prot, unsigned long flags)\n{\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tif (file) {\n\t\tad.type = LSM_AUDIT_DATA_FILE;\n\t\tad.u.file = file;\n\t\trc = inode_has_perm(current_cred(), file_inode(file),\n\t\t\t\t    FILE__MAP, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn file_map_prot_check(file, prot,\n\t\t\t\t   (flags & MAP_TYPE) == MAP_SHARED);\n}\n\nstatic int selinux_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t unsigned long reqprot __always_unused,\n\t\t\t\t unsigned long prot)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 sid = cred_sid(cred);\n\n\tif (default_noexec &&\n\t    (prot & PROT_EXEC) && !(vma->vm_flags & VM_EXEC)) {\n\t\tint rc = 0;\n\t\tif (vma_is_initial_heap(vma)) {\n\t\t\trc = avc_has_perm(sid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t  PROCESS__EXECHEAP, NULL);\n\t\t} else if (!vma->vm_file && (vma_is_initial_stack(vma) ||\n\t\t\t    vma_is_stack_for_current(vma))) {\n\t\t\trc = avc_has_perm(sid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t  PROCESS__EXECSTACK, NULL);\n\t\t} else if (vma->vm_file && vma->anon_vma) {\n\t\t\t \n\t\t\trc = file_has_perm(cred, vma->vm_file, FILE__EXECMOD);\n\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn file_map_prot_check(vma->vm_file, prot, vma->vm_flags&VM_SHARED);\n}\n\nstatic int selinux_file_lock(struct file *file, unsigned int cmd)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn file_has_perm(cred, file, FILE__LOCK);\n}\n\nstatic int selinux_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tconst struct cred *cred = current_cred();\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase F_SETFL:\n\t\tif ((file->f_flags & O_APPEND) && !(arg & O_APPEND)) {\n\t\t\terr = file_has_perm(cred, file, FILE__WRITE);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\tcase F_GETFL:\n\tcase F_GETOWN:\n\tcase F_GETSIG:\n\tcase F_GETOWNER_UIDS:\n\t\t \n\t\terr = file_has_perm(cred, file, 0);\n\t\tbreak;\n\tcase F_GETLK:\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n#if BITS_PER_LONG == 32\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n#endif\n\t\terr = file_has_perm(cred, file, FILE__LOCK);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void selinux_file_set_fowner(struct file *file)\n{\n\tstruct file_security_struct *fsec;\n\n\tfsec = selinux_file(file);\n\tfsec->fown_sid = current_sid();\n}\n\nstatic int selinux_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t       struct fown_struct *fown, int signum)\n{\n\tstruct file *file;\n\tu32 sid = task_sid_obj(tsk);\n\tu32 perm;\n\tstruct file_security_struct *fsec;\n\n\t \n\tfile = container_of(fown, struct file, f_owner);\n\n\tfsec = selinux_file(file);\n\n\tif (!signum)\n\t\tperm = signal_to_av(SIGIO);  \n\telse\n\t\tperm = signal_to_av(signum);\n\n\treturn avc_has_perm(fsec->fown_sid, sid,\n\t\t\t    SECCLASS_PROCESS, perm, NULL);\n}\n\nstatic int selinux_file_receive(struct file *file)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn file_has_perm(cred, file, file_to_av(file));\n}\n\nstatic int selinux_file_open(struct file *file)\n{\n\tstruct file_security_struct *fsec;\n\tstruct inode_security_struct *isec;\n\n\tfsec = selinux_file(file);\n\tisec = inode_security(file_inode(file));\n\t \n\tfsec->isid = isec->sid;\n\tfsec->pseqno = avc_policy_seqno();\n\t \n\treturn file_path_has_perm(file->f_cred, file, open_file_to_av(file));\n}\n\n \n\nstatic int selinux_task_alloc(struct task_struct *task,\n\t\t\t      unsigned long clone_flags)\n{\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, sid, SECCLASS_PROCESS, PROCESS__FORK, NULL);\n}\n\n \nstatic int selinux_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\tgfp_t gfp)\n{\n\tconst struct task_security_struct *old_tsec = selinux_cred(old);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\n\t*tsec = *old_tsec;\n\treturn 0;\n}\n\n \nstatic void selinux_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct task_security_struct *old_tsec = selinux_cred(old);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\n\t*tsec = *old_tsec;\n}\n\nstatic void selinux_cred_getsecid(const struct cred *c, u32 *secid)\n{\n\t*secid = cred_sid(c);\n}\n\n \nstatic int selinux_kernel_act_as(struct cred *new, u32 secid)\n{\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\tu32 sid = current_sid();\n\tint ret;\n\n\tret = avc_has_perm(sid, secid,\n\t\t\t   SECCLASS_KERNEL_SERVICE,\n\t\t\t   KERNEL_SERVICE__USE_AS_OVERRIDE,\n\t\t\t   NULL);\n\tif (ret == 0) {\n\t\ttsec->sid = secid;\n\t\ttsec->create_sid = 0;\n\t\ttsec->keycreate_sid = 0;\n\t\ttsec->sockcreate_sid = 0;\n\t}\n\treturn ret;\n}\n\n \nstatic int selinux_kernel_create_files_as(struct cred *new, struct inode *inode)\n{\n\tstruct inode_security_struct *isec = inode_security(inode);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\tu32 sid = current_sid();\n\tint ret;\n\n\tret = avc_has_perm(sid, isec->sid,\n\t\t\t   SECCLASS_KERNEL_SERVICE,\n\t\t\t   KERNEL_SERVICE__CREATE_FILES_AS,\n\t\t\t   NULL);\n\n\tif (ret == 0)\n\t\ttsec->create_sid = isec->sid;\n\treturn ret;\n}\n\nstatic int selinux_kernel_module_request(char *kmod_name)\n{\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_KMOD;\n\tad.u.kmod_name = kmod_name;\n\n\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL, SECCLASS_SYSTEM,\n\t\t\t    SYSTEM__MODULE_REQUEST, &ad);\n}\n\nstatic int selinux_kernel_module_from_file(struct file *file)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tstruct file_security_struct *fsec;\n\tu32 sid = current_sid();\n\tint rc;\n\n\t \n\tif (file == NULL)\n\t\treturn avc_has_perm(sid, sid, SECCLASS_SYSTEM,\n\t\t\t\t\tSYSTEM__MODULE_LOAD, NULL);\n\n\t \n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\tfsec = selinux_file(file);\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tisec = inode_security(file_inode(file));\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,\n\t\t\t\tSYSTEM__MODULE_LOAD, &ad);\n}\n\nstatic int selinux_kernel_read_file(struct file *file,\n\t\t\t\t    enum kernel_read_file_id id,\n\t\t\t\t    bool contents)\n{\n\tint rc = 0;\n\n\tswitch (id) {\n\tcase READING_MODULE:\n\t\trc = selinux_kernel_module_from_file(contents ? file : NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_kernel_load_data(enum kernel_load_data_id id, bool contents)\n{\n\tint rc = 0;\n\n\tswitch (id) {\n\tcase LOADING_MODULE:\n\t\trc = selinux_kernel_module_from_file(NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETPGID, NULL);\n}\n\nstatic int selinux_task_getpgid(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETPGID, NULL);\n}\n\nstatic int selinux_task_getsid(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSESSION, NULL);\n}\n\nstatic void selinux_current_getsecid_subj(u32 *secid)\n{\n\t*secid = current_sid();\n}\n\nstatic void selinux_task_getsecid_obj(struct task_struct *p, u32 *secid)\n{\n\t*secid = task_sid_obj(p);\n}\n\nstatic int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_getioprio(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSCHED, NULL);\n}\n\nstatic int selinux_task_prlimit(const struct cred *cred, const struct cred *tcred,\n\t\t\t\tunsigned int flags)\n{\n\tu32 av = 0;\n\n\tif (!flags)\n\t\treturn 0;\n\tif (flags & LSM_PRLIMIT_WRITE)\n\t\tav |= PROCESS__SETRLIMIT;\n\tif (flags & LSM_PRLIMIT_READ)\n\t\tav |= PROCESS__GETRLIMIT;\n\treturn avc_has_perm(cred_sid(cred), cred_sid(tcred),\n\t\t\t    SECCLASS_PROCESS, av, NULL);\n}\n\nstatic int selinux_task_setrlimit(struct task_struct *p, unsigned int resource,\n\t\tstruct rlimit *new_rlim)\n{\n\tstruct rlimit *old_rlim = p->signal->rlim + resource;\n\n\t \n\tif (old_rlim->rlim_max != new_rlim->rlim_max)\n\t\treturn avc_has_perm(current_sid(), task_sid_obj(p),\n\t\t\t\t    SECCLASS_PROCESS, PROCESS__SETRLIMIT, NULL);\n\n\treturn 0;\n}\n\nstatic int selinux_task_setscheduler(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_getscheduler(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSCHED, NULL);\n}\n\nstatic int selinux_task_movememory(struct task_struct *p)\n{\n\treturn avc_has_perm(current_sid(), task_sid_obj(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_kill(struct task_struct *p, struct kernel_siginfo *info,\n\t\t\t\tint sig, const struct cred *cred)\n{\n\tu32 secid;\n\tu32 perm;\n\n\tif (!sig)\n\t\tperm = PROCESS__SIGNULL;  \n\telse\n\t\tperm = signal_to_av(sig);\n\tif (!cred)\n\t\tsecid = current_sid();\n\telse\n\t\tsecid = cred_sid(cred);\n\treturn avc_has_perm(secid, task_sid_obj(p), SECCLASS_PROCESS, perm, NULL);\n}\n\nstatic void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid_obj(p);\n\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}\n\nstatic int selinux_userns_create(const struct cred *cred)\n{\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, sid, SECCLASS_USER_NAMESPACE,\n\t\t\tUSER_NAMESPACE__CREATE, NULL);\n}\n\n \nstatic int selinux_parse_skb_ipv4(struct sk_buff *skb,\n\t\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint offset, ihlen, ret = -EINVAL;\n\tstruct iphdr _iph, *ih;\n\n\toffset = skb_network_offset(skb);\n\tih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\n\tif (ih == NULL)\n\t\tgoto out;\n\n\tihlen = ih->ihl * 4;\n\tif (ihlen < sizeof(_iph))\n\t\tgoto out;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\tret = 0;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\n#if IS_ENABLED(CONFIG_IP_SCTP)\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n \nstatic int selinux_parse_skb_ipv6(struct sk_buff *skb,\n\t\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tu8 nexthdr;\n\tint ret = -EINVAL, offset;\n\tstruct ipv6hdr _ipv6h, *ip6;\n\t__be16 frag_off;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\tgoto out;\n\n\tad->u.net->v6info.saddr = ip6->saddr;\n\tad->u.net->v6info.daddr = ip6->daddr;\n\tret = 0;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\tgoto out;\n\n\tif (proto)\n\t\t*proto = nexthdr;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\n#if IS_ENABLED(CONFIG_IP_SCTP)\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n#endif\n\t \n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n#endif  \n\nstatic int selinux_parse_skb(struct sk_buff *skb, struct common_audit_data *ad,\n\t\t\t     char **_addrp, int src, u8 *proto)\n{\n\tchar *addrp;\n\tint ret;\n\n\tswitch (ad->u.net->family) {\n\tcase PF_INET:\n\t\tret = selinux_parse_skb_ipv4(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v4info.saddr :\n\t\t\t\t       &ad->u.net->v4info.daddr);\n\t\tgoto okay;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tret = selinux_parse_skb_ipv6(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v6info.saddr :\n\t\t\t\t       &ad->u.net->v6info.daddr);\n\t\tgoto okay;\n#endif\t \n\tdefault:\n\t\taddrp = NULL;\n\t\tgoto okay;\n\t}\n\nparse_error:\n\tpr_warn(\n\t       \"SELinux: failure in selinux_parse_skb(),\"\n\t       \" unable to parse packet\\n\");\n\treturn ret;\n\nokay:\n\tif (_addrp)\n\t\t*_addrp = addrp;\n\treturn 0;\n}\n\n \nstatic int selinux_skb_peerlbl_sid(struct sk_buff *skb, u16 family, u32 *sid)\n{\n\tint err;\n\tu32 xfrm_sid;\n\tu32 nlbl_sid;\n\tu32 nlbl_type;\n\n\terr = selinux_xfrm_skb_sid(skb, &xfrm_sid);\n\tif (unlikely(err))\n\t\treturn -EACCES;\n\terr = selinux_netlbl_skbuff_getsid(skb, family, &nlbl_type, &nlbl_sid);\n\tif (unlikely(err))\n\t\treturn -EACCES;\n\n\terr = security_net_peersid_resolve(nlbl_sid,\n\t\t\t\t\t   nlbl_type, xfrm_sid, sid);\n\tif (unlikely(err)) {\n\t\tpr_warn(\n\t\t       \"SELinux: failure in selinux_skb_peerlbl_sid(),\"\n\t\t       \" unable to determine packet's peer label\\n\");\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int selinux_conn_sid(u32 sk_sid, u32 skb_sid, u32 *conn_sid)\n{\n\tint err = 0;\n\n\tif (skb_sid != SECSID_NULL)\n\t\terr = security_sid_mls_copy(sk_sid, skb_sid,\n\t\t\t\t\t    conn_sid);\n\telse\n\t\t*conn_sid = sk_sid;\n\n\treturn err;\n}\n\n \n\nstatic int socket_sockcreate_sid(const struct task_security_struct *tsec,\n\t\t\t\t u16 secclass, u32 *socksid)\n{\n\tif (tsec->sockcreate_sid > SECSID_NULL) {\n\t\t*socksid = tsec->sockcreate_sid;\n\t\treturn 0;\n\t}\n\n\treturn security_transition_sid(tsec->sid, tsec->sid,\n\t\t\t\t       secclass, NULL, socksid);\n}\n\nstatic int sock_has_perm(struct sock *sk, u32 perms)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\n\tif (sksec->sid == SECINITSID_KERNEL)\n\t\treturn 0;\n\n\tad_net_init_from_sk(&ad, &net, sk);\n\n\treturn avc_has_perm(current_sid(), sksec->sid, sksec->sclass, perms,\n\t\t\t    &ad);\n}\n\nstatic int selinux_socket_create(int family, int type,\n\t\t\t\t int protocol, int kern)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 newsid;\n\tu16 secclass;\n\tint rc;\n\n\tif (kern)\n\t\treturn 0;\n\n\tsecclass = socket_type_to_security_class(family, type, protocol);\n\trc = socket_sockcreate_sid(tsec, secclass, &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(tsec->sid, newsid, secclass, SOCKET__CREATE, NULL);\n}\n\nstatic int selinux_socket_post_create(struct socket *sock, int family,\n\t\t\t\t      int type, int protocol, int kern)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct inode_security_struct *isec = inode_security_novalidate(SOCK_INODE(sock));\n\tstruct sk_security_struct *sksec;\n\tu16 sclass = socket_type_to_security_class(family, type, protocol);\n\tu32 sid = SECINITSID_KERNEL;\n\tint err = 0;\n\n\tif (!kern) {\n\t\terr = socket_sockcreate_sid(tsec, sclass, &sid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tisec->sclass = sclass;\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\n\tif (sock->sk) {\n\t\tsksec = sock->sk->sk_security;\n\t\tsksec->sclass = sclass;\n\t\tsksec->sid = sid;\n\t\t \n\t\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\t\tsksec->sctp_assoc_state = SCTP_ASSOC_UNSET;\n\n\t\terr = selinux_netlbl_socket_post_create(sock->sk, family);\n\t}\n\n\treturn err;\n}\n\nstatic int selinux_socket_socketpair(struct socket *socka,\n\t\t\t\t     struct socket *sockb)\n{\n\tstruct sk_security_struct *sksec_a = socka->sk->sk_security;\n\tstruct sk_security_struct *sksec_b = sockb->sk->sk_security;\n\n\tsksec_a->peer_sid = sksec_b->sid;\n\tsksec_b->peer_sid = sksec_a->sid;\n\n\treturn 0;\n}\n\n \n\nstatic int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 family;\n\tint err;\n\n\terr = sock_has_perm(sk, SOCKET__BIND);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfamily = sk->sk_family;\n\tif (family == PF_INET || family == PF_INET6) {\n\t\tchar *addrp;\n\t\tstruct common_audit_data ad;\n\t\tstruct lsm_network_audit net = {0,};\n\t\tstruct sockaddr_in *addr4 = NULL;\n\t\tstruct sockaddr_in6 *addr6 = NULL;\n\t\tu16 family_sa;\n\t\tunsigned short snum;\n\t\tu32 sid, node_perm;\n\n\t\t \n\t\tif (addrlen < offsetofend(struct sockaddr, sa_family))\n\t\t\treturn -EINVAL;\n\t\tfamily_sa = address->sa_family;\n\t\tswitch (family_sa) {\n\t\tcase AF_UNSPEC:\n\t\tcase AF_INET:\n\t\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\t\treturn -EINVAL;\n\t\t\taddr4 = (struct sockaddr_in *)address;\n\t\t\tif (family_sa == AF_UNSPEC) {\n\t\t\t\tif (family == PF_INET6) {\n\t\t\t\t\t \n\t\t\t\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t \n\t\t\t\t\tgoto err_af;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (addr4->sin_addr.s_addr != htonl(INADDR_ANY))\n\t\t\t\t\tgoto err_af;\n\t\t\t\tfamily_sa = AF_INET;\n\t\t\t}\n\t\t\tsnum = ntohs(addr4->sin_port);\n\t\t\taddrp = (char *)&addr4->sin_addr.s_addr;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\taddr6 = (struct sockaddr_in6 *)address;\n\t\t\tsnum = ntohs(addr6->sin6_port);\n\t\t\taddrp = (char *)&addr6->sin6_addr.s6_addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_af;\n\t\t}\n\n\t\tad.type = LSM_AUDIT_DATA_NET;\n\t\tad.u.net = &net;\n\t\tad.u.net->sport = htons(snum);\n\t\tad.u.net->family = family_sa;\n\n\t\tif (snum) {\n\t\t\tint low, high;\n\n\t\t\tinet_get_local_port_range(sock_net(sk), &low, &high);\n\n\t\t\tif (inet_port_requires_bind_service(sock_net(sk), snum) ||\n\t\t\t    snum < low || snum > high) {\n\t\t\t\terr = sel_netport_sid(sk->sk_protocol,\n\t\t\t\t\t\t      snum, &sid);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\terr = avc_has_perm(sksec->sid, sid,\n\t\t\t\t\t\t   sksec->sclass,\n\t\t\t\t\t\t   SOCKET__NAME_BIND, &ad);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tswitch (sksec->sclass) {\n\t\tcase SECCLASS_TCP_SOCKET:\n\t\t\tnode_perm = TCP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_UDP_SOCKET:\n\t\t\tnode_perm = UDP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_DCCP_SOCKET:\n\t\t\tnode_perm = DCCP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_SCTP_SOCKET:\n\t\t\tnode_perm = SCTP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnode_perm = RAWIP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = sel_netnode_sid(addrp, family_sa, &sid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (family_sa == AF_INET)\n\t\t\tad.u.net->v4info.saddr = addr4->sin_addr.s_addr;\n\t\telse\n\t\t\tad.u.net->v6info.saddr = addr6->sin6_addr;\n\n\t\terr = avc_has_perm(sksec->sid, sid,\n\t\t\t\t   sksec->sclass, node_perm, &ad);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\nerr_af:\n\t \n\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\treturn -EINVAL;\n\treturn -EAFNOSUPPORT;\n}\n\n \nstatic int selinux_socket_connect_helper(struct socket *sock,\n\t\t\t\t\t struct sockaddr *address, int addrlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tint err;\n\n\terr = sock_has_perm(sk, SOCKET__CONNECT);\n\tif (err)\n\t\treturn err;\n\tif (addrlen < offsetofend(struct sockaddr, sa_family))\n\t\treturn -EINVAL;\n\n\t \n\tif (address->sa_family == AF_UNSPEC)\n\t\treturn 0;\n\n\t \n\tif (sksec->sclass == SECCLASS_TCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_DCCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_SCTP_SOCKET) {\n\t\tstruct common_audit_data ad;\n\t\tstruct lsm_network_audit net = {0,};\n\t\tstruct sockaddr_in *addr4 = NULL;\n\t\tstruct sockaddr_in6 *addr6 = NULL;\n\t\tunsigned short snum;\n\t\tu32 sid, perm;\n\n\t\t \n\t\tswitch (address->sa_family) {\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *)address;\n\t\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\t\treturn -EINVAL;\n\t\t\tsnum = ntohs(addr4->sin_port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *)address;\n\t\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tsnum = ntohs(addr6->sin6_port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\t\t\treturn -EINVAL;\n\t\t\telse\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\terr = sel_netport_sid(sk->sk_protocol, snum, &sid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (sksec->sclass) {\n\t\tcase SECCLASS_TCP_SOCKET:\n\t\t\tperm = TCP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\tcase SECCLASS_DCCP_SOCKET:\n\t\t\tperm = DCCP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\tcase SECCLASS_SCTP_SOCKET:\n\t\t\tperm = SCTP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\t}\n\n\t\tad.type = LSM_AUDIT_DATA_NET;\n\t\tad.u.net = &net;\n\t\tad.u.net->dport = htons(snum);\n\t\tad.u.net->family = address->sa_family;\n\t\terr = avc_has_perm(sksec->sid, sid, sksec->sclass, perm, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int selinux_socket_connect(struct socket *sock,\n\t\t\t\t  struct sockaddr *address, int addrlen)\n{\n\tint err;\n\tstruct sock *sk = sock->sk;\n\n\terr = selinux_socket_connect_helper(sock, address, addrlen);\n\tif (err)\n\t\treturn err;\n\n\treturn selinux_netlbl_socket_connect(sk, address);\n}\n\nstatic int selinux_socket_listen(struct socket *sock, int backlog)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__LISTEN);\n}\n\nstatic int selinux_socket_accept(struct socket *sock, struct socket *newsock)\n{\n\tint err;\n\tstruct inode_security_struct *isec;\n\tstruct inode_security_struct *newisec;\n\tu16 sclass;\n\tu32 sid;\n\n\terr = sock_has_perm(sock->sk, SOCKET__ACCEPT);\n\tif (err)\n\t\treturn err;\n\n\tisec = inode_security_novalidate(SOCK_INODE(sock));\n\tspin_lock(&isec->lock);\n\tsclass = isec->sclass;\n\tsid = isec->sid;\n\tspin_unlock(&isec->lock);\n\n\tnewisec = inode_security_novalidate(SOCK_INODE(newsock));\n\tnewisec->sclass = sclass;\n\tnewisec->sid = sid;\n\tnewisec->initialized = LABEL_INITIALIZED;\n\n\treturn 0;\n}\n\nstatic int selinux_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int size)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__WRITE);\n}\n\nstatic int selinux_socket_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int size, int flags)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__READ);\n}\n\nstatic int selinux_socket_getsockname(struct socket *sock)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETATTR);\n}\n\nstatic int selinux_socket_getpeername(struct socket *sock)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETATTR);\n}\n\nstatic int selinux_socket_setsockopt(struct socket *sock, int level, int optname)\n{\n\tint err;\n\n\terr = sock_has_perm(sock->sk, SOCKET__SETOPT);\n\tif (err)\n\t\treturn err;\n\n\treturn selinux_netlbl_socket_setsockopt(sock, level, optname);\n}\n\nstatic int selinux_socket_getsockopt(struct socket *sock, int level,\n\t\t\t\t     int optname)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETOPT);\n}\n\nstatic int selinux_socket_shutdown(struct socket *sock, int how)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__SHUTDOWN);\n}\n\nstatic int selinux_socket_unix_stream_connect(struct sock *sock,\n\t\t\t\t\t      struct sock *other,\n\t\t\t\t\t      struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec_sock = sock->sk_security;\n\tstruct sk_security_struct *sksec_other = other->sk_security;\n\tstruct sk_security_struct *sksec_new = newsk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tint err;\n\n\tad_net_init_from_sk(&ad, &net, other);\n\n\terr = avc_has_perm(sksec_sock->sid, sksec_other->sid,\n\t\t\t   sksec_other->sclass,\n\t\t\t   UNIX_STREAM_SOCKET__CONNECTTO, &ad);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsksec_new->peer_sid = sksec_sock->sid;\n\terr = security_sid_mls_copy(sksec_other->sid,\n\t\t\t\t    sksec_sock->sid, &sksec_new->sid);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsksec_sock->peer_sid = sksec_new->sid;\n\n\treturn 0;\n}\n\nstatic int selinux_socket_unix_may_send(struct socket *sock,\n\t\t\t\t\tstruct socket *other)\n{\n\tstruct sk_security_struct *ssec = sock->sk->sk_security;\n\tstruct sk_security_struct *osec = other->sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\n\tad_net_init_from_sk(&ad, &net, other->sk);\n\n\treturn avc_has_perm(ssec->sid, osec->sid, osec->sclass, SOCKET__SENDTO,\n\t\t\t    &ad);\n}\n\nstatic int selinux_inet_sys_rcv_skb(struct net *ns, int ifindex,\n\t\t\t\t    char *addrp, u16 family, u32 peer_sid,\n\t\t\t\t    struct common_audit_data *ad)\n{\n\tint err;\n\tu32 if_sid;\n\tu32 node_sid;\n\n\terr = sel_netif_sid(ns, ifindex, &if_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(peer_sid, if_sid,\n\t\t\t   SECCLASS_NETIF, NETIF__INGRESS, ad);\n\tif (err)\n\t\treturn err;\n\n\terr = sel_netnode_sid(addrp, family, &node_sid);\n\tif (err)\n\t\treturn err;\n\treturn avc_has_perm(peer_sid, node_sid,\n\t\t\t    SECCLASS_NODE, NODE__RECVFROM, ad);\n}\n\nstatic int selinux_sock_rcv_skb_compat(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       u16 family)\n{\n\tint err = 0;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu32 sk_sid = sksec->sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tchar *addrp;\n\n\tad_net_init_from_iif(&ad, &net, skb->skb_iif, family);\n\terr = selinux_parse_skb(skb, &ad, &addrp, 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (selinux_secmark_enabled()) {\n\t\terr = avc_has_perm(sk_sid, skb->secmark, SECCLASS_PACKET,\n\t\t\t\t   PACKET__RECV, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = selinux_netlbl_sock_rcv_skb(sksec, skb, family, &ad);\n\tif (err)\n\t\treturn err;\n\terr = selinux_xfrm_sock_rcv_skb(sksec->sid, skb, &ad);\n\n\treturn err;\n}\n\nstatic int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint err, peerlbl_active, secmark_active;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 family = sk->sk_family;\n\tu32 sk_sid = sksec->sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tchar *addrp;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\t \n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\t \n\tif (!selinux_policycap_netpeer())\n\t\treturn selinux_sock_rcv_skb_compat(sk, skb, family);\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn 0;\n\n\tad_net_init_from_iif(&ad, &net, skb->skb_iif, family);\n\terr = selinux_parse_skb(skb, &ad, &addrp, 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (peerlbl_active) {\n\t\tu32 peer_sid;\n\n\t\terr = selinux_skb_peerlbl_sid(skb, family, &peer_sid);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = selinux_inet_sys_rcv_skb(sock_net(sk), skb->skb_iif,\n\t\t\t\t\t       addrp, family, peer_sid, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t\terr = avc_has_perm(sk_sid, peer_sid, SECCLASS_PEER,\n\t\t\t\t   PEER__RECV, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (secmark_active) {\n\t\terr = avc_has_perm(sk_sid, skb->secmark, SECCLASS_PACKET,\n\t\t\t\t   PACKET__RECV, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int selinux_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t    sockptr_t optval, sockptr_t optlen,\n\t\t\t\t\t    unsigned int len)\n{\n\tint err = 0;\n\tchar *scontext = NULL;\n\tu32 scontext_len;\n\tstruct sk_security_struct *sksec = sock->sk->sk_security;\n\tu32 peer_sid = SECSID_NULL;\n\n\tif (sksec->sclass == SECCLASS_UNIX_STREAM_SOCKET ||\n\t    sksec->sclass == SECCLASS_TCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\tpeer_sid = sksec->peer_sid;\n\tif (peer_sid == SECSID_NULL)\n\t\treturn -ENOPROTOOPT;\n\n\terr = security_sid_to_context(peer_sid, &scontext,\n\t\t\t\t      &scontext_len);\n\tif (err)\n\t\treturn err;\n\tif (scontext_len > len) {\n\t\terr = -ERANGE;\n\t\tgoto out_len;\n\t}\n\n\tif (copy_to_sockptr(optval, scontext, scontext_len))\n\t\terr = -EFAULT;\nout_len:\n\tif (copy_to_sockptr(optlen, &scontext_len, sizeof(scontext_len)))\n\t\terr = -EFAULT;\n\tkfree(scontext);\n\treturn err;\n}\n\nstatic int selinux_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)\n{\n\tu32 peer_secid = SECSID_NULL;\n\tu16 family;\n\tstruct inode_security_struct *isec;\n\n\tif (skb && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\telse if (skb && skb->protocol == htons(ETH_P_IPV6))\n\t\tfamily = PF_INET6;\n\telse if (sock)\n\t\tfamily = sock->sk->sk_family;\n\telse\n\t\tgoto out;\n\n\tif (sock && family == PF_UNIX) {\n\t\tisec = inode_security_novalidate(SOCK_INODE(sock));\n\t\tpeer_secid = isec->sid;\n\t} else if (skb)\n\t\tselinux_skb_peerlbl_sid(skb, family, &peer_secid);\n\nout:\n\t*secid = peer_secid;\n\tif (peer_secid == SECSID_NULL)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int selinux_sk_alloc_security(struct sock *sk, int family, gfp_t priority)\n{\n\tstruct sk_security_struct *sksec;\n\n\tsksec = kzalloc(sizeof(*sksec), priority);\n\tif (!sksec)\n\t\treturn -ENOMEM;\n\n\tsksec->peer_sid = SECINITSID_UNLABELED;\n\tsksec->sid = SECINITSID_UNLABELED;\n\tsksec->sclass = SECCLASS_SOCKET;\n\tselinux_netlbl_sk_security_reset(sksec);\n\tsk->sk_security = sksec;\n\n\treturn 0;\n}\n\nstatic void selinux_sk_free_security(struct sock *sk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tsk->sk_security = NULL;\n\tselinux_netlbl_sk_security_free(sksec);\n\tkfree(sksec);\n}\n\nstatic void selinux_sk_clone_security(const struct sock *sk, struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\tnewsksec->sid = sksec->sid;\n\tnewsksec->peer_sid = sksec->peer_sid;\n\tnewsksec->sclass = sksec->sclass;\n\n\tselinux_netlbl_sk_security_reset(newsksec);\n}\n\nstatic void selinux_sk_getsecid(const struct sock *sk, u32 *secid)\n{\n\tif (!sk)\n\t\t*secid = SECINITSID_ANY_SOCKET;\n\telse {\n\t\tconst struct sk_security_struct *sksec = sk->sk_security;\n\n\t\t*secid = sksec->sid;\n\t}\n}\n\nstatic void selinux_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct inode_security_struct *isec =\n\t\tinode_security_novalidate(SOCK_INODE(parent));\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (sk->sk_family == PF_INET || sk->sk_family == PF_INET6 ||\n\t    sk->sk_family == PF_UNIX)\n\t\tisec->sid = sksec->sid;\n\tsksec->sclass = isec->sclass;\n}\n\n \nstatic int selinux_sctp_process_new_assoc(struct sctp_association *asoc,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tu16 family = sk->sk_family;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tint err;\n\n\t \n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\tif (selinux_peerlbl_enabled()) {\n\t\tasoc->peer_secid = SECSID_NULL;\n\n\t\t \n\t\terr = selinux_skb_peerlbl_sid(skb, family, &asoc->peer_secid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (asoc->peer_secid == SECSID_NULL)\n\t\t\tasoc->peer_secid = SECINITSID_UNLABELED;\n\t} else {\n\t\tasoc->peer_secid = SECINITSID_UNLABELED;\n\t}\n\n\tif (sksec->sctp_assoc_state == SCTP_ASSOC_UNSET) {\n\t\tsksec->sctp_assoc_state = SCTP_ASSOC_SET;\n\n\t\t \n\t\tsksec->peer_sid = asoc->peer_secid;\n\t} else if (sksec->peer_sid != asoc->peer_secid) {\n\t\t \n\t\tad_net_init_from_sk(&ad, &net, asoc->base.sk);\n\t\terr = avc_has_perm(sksec->peer_sid, asoc->peer_secid,\n\t\t\t\t   sksec->sclass, SCTP_SOCKET__ASSOCIATION,\n\t\t\t\t   &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int selinux_sctp_assoc_request(struct sctp_association *asoc,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sk_security_struct *sksec = asoc->base.sk->sk_security;\n\tu32 conn_sid;\n\tint err;\n\n\tif (!selinux_policycap_extsockclass())\n\t\treturn 0;\n\n\terr = selinux_sctp_process_new_assoc(asoc, skb);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = selinux_conn_sid(sksec->sid, asoc->peer_secid, &conn_sid);\n\tif (err)\n\t\treturn err;\n\n\tasoc->secid = conn_sid;\n\n\t \n\treturn selinux_netlbl_sctp_assoc_request(asoc, skb);\n}\n\n \nstatic int selinux_sctp_assoc_established(struct sctp_association *asoc,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sk_security_struct *sksec = asoc->base.sk->sk_security;\n\n\tif (!selinux_policycap_extsockclass())\n\t\treturn 0;\n\n\t \n\tasoc->secid = sksec->sid;\n\n\treturn selinux_sctp_process_new_assoc(asoc, skb);\n}\n\n \nstatic int selinux_sctp_bind_connect(struct sock *sk, int optname,\n\t\t\t\t     struct sockaddr *address,\n\t\t\t\t     int addrlen)\n{\n\tint len, err = 0, walk_size = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *addr;\n\tstruct socket *sock;\n\n\tif (!selinux_policycap_extsockclass())\n\t\treturn 0;\n\n\t \n\tsock = sk->sk_socket;\n\taddr_buf = address;\n\n\twhile (walk_size < addrlen) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrlen)\n\t\t\treturn -EINVAL;\n\n\t\taddr = addr_buf;\n\t\tswitch (addr->sa_family) {\n\t\tcase AF_UNSPEC:\n\t\tcase AF_INET:\n\t\t\tlen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (walk_size + len > addrlen)\n\t\t\treturn -EINVAL;\n\n\t\terr = -EINVAL;\n\t\tswitch (optname) {\n\t\t \n\t\tcase SCTP_PRIMARY_ADDR:\n\t\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t\terr = selinux_socket_bind(sock, addr, len);\n\t\t\tbreak;\n\t\t \n\t\tcase SCTP_SOCKOPT_CONNECTX:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_SENDMSG_CONNECT:\n\t\t\terr = selinux_socket_connect_helper(sock, addr, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = selinux_netlbl_socket_connect_locked(sk, addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\taddr_buf += len;\n\t\twalk_size += len;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void selinux_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk,\n\t\t\t\t  struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\t \n\tif (!selinux_policycap_extsockclass())\n\t\treturn selinux_sk_clone_security(sk, newsk);\n\n\tnewsksec->sid = asoc->secid;\n\tnewsksec->peer_sid = asoc->peer_secid;\n\tnewsksec->sclass = sksec->sclass;\n\tselinux_netlbl_sctp_sk_clone(sk, newsk);\n}\n\nstatic int selinux_mptcp_add_subflow(struct sock *sk, struct sock *ssk)\n{\n\tstruct sk_security_struct *ssksec = ssk->sk_security;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tssksec->sclass = sksec->sclass;\n\tssksec->sid = sksec->sid;\n\n\t \n\tselinux_netlbl_sk_security_free(ssksec);\n\treturn selinux_netlbl_socket_post_create(ssk, ssk->sk_family);\n}\n\nstatic int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t     struct request_sock *req)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tint err;\n\tu16 family = req->rsk_ops->family;\n\tu32 connsid;\n\tu32 peersid;\n\n\terr = selinux_skb_peerlbl_sid(skb, family, &peersid);\n\tif (err)\n\t\treturn err;\n\terr = selinux_conn_sid(sksec->sid, peersid, &connsid);\n\tif (err)\n\t\treturn err;\n\treq->secid = connsid;\n\treq->peer_secid = peersid;\n\n\treturn selinux_netlbl_inet_conn_request(req, family);\n}\n\nstatic void selinux_inet_csk_clone(struct sock *newsk,\n\t\t\t\t   const struct request_sock *req)\n{\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\tnewsksec->sid = req->secid;\n\tnewsksec->peer_sid = req->peer_secid;\n\t \n\n\t \n\tselinux_netlbl_inet_csk_clone(newsk, req->rsk_ops->family);\n}\n\nstatic void selinux_inet_conn_established(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 family = sk->sk_family;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t \n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\tselinux_skb_peerlbl_sid(skb, family, &sksec->peer_sid);\n}\n\nstatic int selinux_secmark_relabel_packet(u32 sid)\n{\n\tconst struct task_security_struct *tsec;\n\tu32 tsid;\n\n\ttsec = selinux_cred(current_cred());\n\ttsid = tsec->sid;\n\n\treturn avc_has_perm(tsid, sid, SECCLASS_PACKET, PACKET__RELABELTO,\n\t\t\t    NULL);\n}\n\nstatic void selinux_secmark_refcount_inc(void)\n{\n\tatomic_inc(&selinux_secmark_refcount);\n}\n\nstatic void selinux_secmark_refcount_dec(void)\n{\n\tatomic_dec(&selinux_secmark_refcount);\n}\n\nstatic void selinux_req_classify_flow(const struct request_sock *req,\n\t\t\t\t      struct flowi_common *flic)\n{\n\tflic->flowic_secid = req->secid;\n}\n\nstatic int selinux_tun_dev_alloc_security(void **security)\n{\n\tstruct tun_security_struct *tunsec;\n\n\ttunsec = kzalloc(sizeof(*tunsec), GFP_KERNEL);\n\tif (!tunsec)\n\t\treturn -ENOMEM;\n\ttunsec->sid = current_sid();\n\n\t*security = tunsec;\n\treturn 0;\n}\n\nstatic void selinux_tun_dev_free_security(void *security)\n{\n\tkfree(security);\n}\n\nstatic int selinux_tun_dev_create(void)\n{\n\tu32 sid = current_sid();\n\n\t \n\n\treturn avc_has_perm(sid, sid, SECCLASS_TUN_SOCKET, TUN_SOCKET__CREATE,\n\t\t\t    NULL);\n}\n\nstatic int selinux_tun_dev_attach_queue(void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\n\treturn avc_has_perm(current_sid(), tunsec->sid, SECCLASS_TUN_SOCKET,\n\t\t\t    TUN_SOCKET__ATTACH_QUEUE, NULL);\n}\n\nstatic int selinux_tun_dev_attach(struct sock *sk, void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t \n\n\tsksec->sid = tunsec->sid;\n\tsksec->sclass = SECCLASS_TUN_SOCKET;\n\n\treturn 0;\n}\n\nstatic int selinux_tun_dev_open(void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\tu32 sid = current_sid();\n\tint err;\n\n\terr = avc_has_perm(sid, tunsec->sid, SECCLASS_TUN_SOCKET,\n\t\t\t   TUN_SOCKET__RELABELFROM, NULL);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(sid, sid, SECCLASS_TUN_SOCKET,\n\t\t\t   TUN_SOCKET__RELABELTO, NULL);\n\tif (err)\n\t\treturn err;\n\ttunsec->sid = sid;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NETFILTER\n\nstatic unsigned int selinux_ip_forward(void *priv, struct sk_buff *skb,\n\t\t\t\t       const struct nf_hook_state *state)\n{\n\tint ifindex;\n\tu16 family;\n\tchar *addrp;\n\tu32 peer_sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tint secmark_active, peerlbl_active;\n\n\tif (!selinux_policycap_netpeer())\n\t\treturn NF_ACCEPT;\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn NF_ACCEPT;\n\n\tfamily = state->pf;\n\tif (selinux_skb_peerlbl_sid(skb, family, &peer_sid) != 0)\n\t\treturn NF_DROP;\n\n\tifindex = state->in->ifindex;\n\tad_net_init_from_iif(&ad, &net, ifindex, family);\n\tif (selinux_parse_skb(skb, &ad, &addrp, 1, NULL) != 0)\n\t\treturn NF_DROP;\n\n\tif (peerlbl_active) {\n\t\tint err;\n\n\t\terr = selinux_inet_sys_rcv_skb(state->net, ifindex,\n\t\t\t\t\t       addrp, family, peer_sid, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 1);\n\t\t\treturn NF_DROP;\n\t\t}\n\t}\n\n\tif (secmark_active)\n\t\tif (avc_has_perm(peer_sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, PACKET__FORWARD_IN, &ad))\n\t\t\treturn NF_DROP;\n\n\tif (netlbl_enabled())\n\t\t \n\t\tif (selinux_netlbl_skbuff_setsid(skb, family, peer_sid) != 0)\n\t\t\treturn NF_DROP;\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ip_output(void *priv, struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct sock *sk;\n\tu32 sid;\n\n\tif (!netlbl_enabled())\n\t\treturn NF_ACCEPT;\n\n\t \n\tsk = skb->sk;\n\tif (sk) {\n\t\tstruct sk_security_struct *sksec;\n\n\t\tif (sk_listener(sk))\n\t\t\t \n\t\t\treturn NF_ACCEPT;\n\n\t\t \n\t\tsksec = sk->sk_security;\n\t\tsid = sksec->sid;\n\t} else\n\t\tsid = SECINITSID_KERNEL;\n\tif (selinux_netlbl_skbuff_setsid(skb, state->pf, sid) != 0)\n\t\treturn NF_DROP;\n\n\treturn NF_ACCEPT;\n}\n\n\nstatic unsigned int selinux_ip_postroute_compat(struct sk_buff *skb,\n\t\t\t\t\tconst struct nf_hook_state *state)\n{\n\tstruct sock *sk;\n\tstruct sk_security_struct *sksec;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tu8 proto = 0;\n\n\tsk = skb_to_full_sk(skb);\n\tif (sk == NULL)\n\t\treturn NF_ACCEPT;\n\tsksec = sk->sk_security;\n\n\tad_net_init_from_iif(&ad, &net, state->out->ifindex, state->pf);\n\tif (selinux_parse_skb(skb, &ad, NULL, 0, &proto))\n\t\treturn NF_DROP;\n\n\tif (selinux_secmark_enabled())\n\t\tif (avc_has_perm(sksec->sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, PACKET__SEND, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\tif (selinux_xfrm_postroute_last(sksec->sid, skb, &ad, proto))\n\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ip_postroute(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\tu16 family;\n\tu32 secmark_perm;\n\tu32 peer_sid;\n\tint ifindex;\n\tstruct sock *sk;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net;\n\tchar *addrp;\n\tint secmark_active, peerlbl_active;\n\n\t \n\tif (!selinux_policycap_netpeer())\n\t\treturn selinux_ip_postroute_compat(skb, state);\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn NF_ACCEPT;\n\n\tsk = skb_to_full_sk(skb);\n\n#ifdef CONFIG_XFRM\n\t \n\tif (skb_dst(skb) != NULL && skb_dst(skb)->xfrm != NULL &&\n\t    !(sk && sk_listener(sk)))\n\t\treturn NF_ACCEPT;\n#endif\n\n\tfamily = state->pf;\n\tif (sk == NULL) {\n\t\t \n\t\tif (skb->skb_iif) {\n\t\t\tsecmark_perm = PACKET__FORWARD_OUT;\n\t\t\tif (selinux_skb_peerlbl_sid(skb, family, &peer_sid))\n\t\t\t\treturn NF_DROP;\n\t\t} else {\n\t\t\tsecmark_perm = PACKET__SEND;\n\t\t\tpeer_sid = SECINITSID_KERNEL;\n\t\t}\n\t} else if (sk_listener(sk)) {\n\t\t \n\t\tu32 skb_sid;\n\t\tstruct sk_security_struct *sksec;\n\n\t\tsksec = sk->sk_security;\n\t\tif (selinux_skb_peerlbl_sid(skb, family, &skb_sid))\n\t\t\treturn NF_DROP;\n\t\t \n\t\tif (skb_sid == SECSID_NULL) {\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED)\n\t\t\t\t\treturn NF_ACCEPT;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED)\n\t\t\t\t\treturn NF_ACCEPT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\t\t\t}\n\t\t}\n\t\tif (selinux_conn_sid(sksec->sid, skb_sid, &peer_sid))\n\t\t\treturn NF_DROP;\n\t\tsecmark_perm = PACKET__SEND;\n\t} else {\n\t\t \n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\t\tpeer_sid = sksec->sid;\n\t\tsecmark_perm = PACKET__SEND;\n\t}\n\n\tifindex = state->out->ifindex;\n\tad_net_init_from_iif(&ad, &net, ifindex, family);\n\tif (selinux_parse_skb(skb, &ad, &addrp, 0, NULL))\n\t\treturn NF_DROP;\n\n\tif (secmark_active)\n\t\tif (avc_has_perm(peer_sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, secmark_perm, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\tif (peerlbl_active) {\n\t\tu32 if_sid;\n\t\tu32 node_sid;\n\n\t\tif (sel_netif_sid(state->net, ifindex, &if_sid))\n\t\t\treturn NF_DROP;\n\t\tif (avc_has_perm(peer_sid, if_sid,\n\t\t\t\t SECCLASS_NETIF, NETIF__EGRESS, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\t\tif (sel_netnode_sid(addrp, family, &node_sid))\n\t\t\treturn NF_DROP;\n\t\tif (avc_has_perm(peer_sid, node_sid,\n\t\t\t\t SECCLASS_NODE, NODE__SENDTO, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\t}\n\n\treturn NF_ACCEPT;\n}\n#endif\t \n\nstatic int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tunsigned int msg_len;\n\tunsigned int data_len = skb->len;\n\tunsigned char *data = skb->data;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 sclass = sksec->sclass;\n\tu32 perm;\n\n\twhile (data_len >= nlmsg_total_size(0)) {\n\t\tnlh = (struct nlmsghdr *)data;\n\n\t\t \n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)\n\t\t\treturn 0;\n\n\t\trc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);\n\t\tif (rc == 0) {\n\t\t\trc = sock_has_perm(sk, perm);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t \n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t\t\" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t\t\" pid=%d comm=%s\\n\",\n\t\t\t\tsk->sk_protocol, nlh->nlmsg_type,\n\t\t\t\tsecclass_map[sclass - 1].name,\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\t\tif (enforcing_enabled() &&\n\t\t\t    !security_get_allow_unknown())\n\t\t\t\treturn rc;\n\t\t\trc = 0;\n\t\t} else if (rc == -ENOENT) {\n\t\t\t \n\t\t\trc = 0;\n\t\t} else {\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msg_len >= data_len)\n\t\t\treturn 0;\n\t\tdata_len -= msg_len;\n\t\tdata += msg_len;\n\t}\n\n\treturn rc;\n}\n\nstatic void ipc_init_security(struct ipc_security_struct *isec, u16 sclass)\n{\n\tisec->sclass = sclass;\n\tisec->sid = current_sid();\n}\n\nstatic int ipc_has_perm(struct kern_ipc_perm *ipc_perms,\n\t\t\tu32 perms)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(ipc_perms);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = ipc_perms->key;\n\n\treturn avc_has_perm(sid, isec->sid, isec->sclass, perms, &ad);\n}\n\nstatic int selinux_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct msg_security_struct *msec;\n\n\tmsec = selinux_msg_msg(msg);\n\tmsec->sid = SECINITSID_UNLABELED;\n\n\treturn 0;\n}\n\n \nstatic int selinux_msg_queue_alloc_security(struct kern_ipc_perm *msq)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(msq);\n\tipc_init_security(isec, SECCLASS_MSGQ);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t    MSGQ__CREATE, &ad);\n}\n\nstatic int selinux_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(msq);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t    MSGQ__ASSOCIATE, &ad);\n}\n\nstatic int selinux_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)\n{\n\tu32 perms;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase MSG_INFO:\n\t\t \n\t\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\tcase MSG_STAT_ANY:\n\t\tperms = MSGQ__GETATTR | MSGQ__ASSOCIATE;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = MSGQ__SETATTR;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = MSGQ__DESTROY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn ipc_has_perm(msq, perms);\n}\n\nstatic int selinux_msg_queue_msgsnd(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct msg_security_struct *msec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint rc;\n\n\tisec = selinux_ipc(msq);\n\tmsec = selinux_msg_msg(msg);\n\n\t \n\tif (msec->sid == SECINITSID_UNLABELED) {\n\t\t \n\t\trc = security_transition_sid(sid, isec->sid,\n\t\t\t\t\t     SECCLASS_MSG, NULL, &msec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\t \n\trc = avc_has_perm(sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t  MSGQ__WRITE, &ad);\n\tif (!rc)\n\t\t \n\t\trc = avc_has_perm(sid, msec->sid, SECCLASS_MSG,\n\t\t\t\t  MSG__SEND, &ad);\n\tif (!rc)\n\t\t \n\t\trc = avc_has_perm(msec->sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t\t  MSGQ__ENQUEUE, &ad);\n\n\treturn rc;\n}\n\nstatic int selinux_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,\n\t\t\t\t    struct task_struct *target,\n\t\t\t\t    long type, int mode)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct msg_security_struct *msec;\n\tstruct common_audit_data ad;\n\tu32 sid = task_sid_obj(target);\n\tint rc;\n\n\tisec = selinux_ipc(msq);\n\tmsec = selinux_msg_msg(msg);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\trc = avc_has_perm(sid, isec->sid,\n\t\t\t  SECCLASS_MSGQ, MSGQ__READ, &ad);\n\tif (!rc)\n\t\trc = avc_has_perm(sid, msec->sid,\n\t\t\t\t  SECCLASS_MSG, MSG__RECEIVE, &ad);\n\treturn rc;\n}\n\n \nstatic int selinux_shm_alloc_security(struct kern_ipc_perm *shp)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(shp);\n\tipc_init_security(isec, SECCLASS_SHM);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = shp->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SHM,\n\t\t\t    SHM__CREATE, &ad);\n}\n\nstatic int selinux_shm_associate(struct kern_ipc_perm *shp, int shmflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(shp);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = shp->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SHM,\n\t\t\t    SHM__ASSOCIATE, &ad);\n}\n\n \nstatic int selinux_shm_shmctl(struct kern_ipc_perm *shp, int cmd)\n{\n\tu32 perms;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\t\t \n\t\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase IPC_STAT:\n\tcase SHM_STAT:\n\tcase SHM_STAT_ANY:\n\t\tperms = SHM__GETATTR | SHM__ASSOCIATE;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = SHM__SETATTR;\n\t\tbreak;\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t\tperms = SHM__LOCK;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = SHM__DESTROY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn ipc_has_perm(shp, perms);\n}\n\nstatic int selinux_shm_shmat(struct kern_ipc_perm *shp,\n\t\t\t     char __user *shmaddr, int shmflg)\n{\n\tu32 perms;\n\n\tif (shmflg & SHM_RDONLY)\n\t\tperms = SHM__READ;\n\telse\n\t\tperms = SHM__READ | SHM__WRITE;\n\n\treturn ipc_has_perm(shp, perms);\n}\n\n \nstatic int selinux_sem_alloc_security(struct kern_ipc_perm *sma)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(sma);\n\tipc_init_security(isec, SECCLASS_SEM);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = sma->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SEM,\n\t\t\t    SEM__CREATE, &ad);\n}\n\nstatic int selinux_sem_associate(struct kern_ipc_perm *sma, int semflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(sma);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = sma->key;\n\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SEM,\n\t\t\t    SEM__ASSOCIATE, &ad);\n}\n\n \nstatic int selinux_sem_semctl(struct kern_ipc_perm *sma, int cmd)\n{\n\tint err;\n\tu32 perms;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\t \n\t\treturn avc_has_perm(current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\t\tperms = SEM__GETATTR;\n\t\tbreak;\n\tcase GETVAL:\n\tcase GETALL:\n\t\tperms = SEM__READ;\n\t\tbreak;\n\tcase SETVAL:\n\tcase SETALL:\n\t\tperms = SEM__WRITE;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = SEM__DESTROY;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = SEM__SETATTR;\n\t\tbreak;\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\tcase SEM_STAT_ANY:\n\t\tperms = SEM__GETATTR | SEM__ASSOCIATE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = ipc_has_perm(sma, perms);\n\treturn err;\n}\n\nstatic int selinux_sem_semop(struct kern_ipc_perm *sma,\n\t\t\t     struct sembuf *sops, unsigned nsops, int alter)\n{\n\tu32 perms;\n\n\tif (alter)\n\t\tperms = SEM__READ | SEM__WRITE;\n\telse\n\t\tperms = SEM__READ;\n\n\treturn ipc_has_perm(sma, perms);\n}\n\nstatic int selinux_ipc_permission(struct kern_ipc_perm *ipcp, short flag)\n{\n\tu32 av = 0;\n\n\tav = 0;\n\tif (flag & S_IRUGO)\n\t\tav |= IPC__UNIX_READ;\n\tif (flag & S_IWUGO)\n\t\tav |= IPC__UNIX_WRITE;\n\n\tif (av == 0)\n\t\treturn 0;\n\n\treturn ipc_has_perm(ipcp, av);\n}\n\nstatic void selinux_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)\n{\n\tstruct ipc_security_struct *isec = selinux_ipc(ipcp);\n\t*secid = isec->sid;\n}\n\nstatic void selinux_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (inode)\n\t\tinode_doinit_with_dentry(inode, dentry);\n}\n\nstatic int selinux_getprocattr(struct task_struct *p,\n\t\t\t       const char *name, char **value)\n{\n\tconst struct task_security_struct *__tsec;\n\tu32 sid;\n\tint error;\n\tunsigned len;\n\n\trcu_read_lock();\n\t__tsec = selinux_cred(__task_cred(p));\n\n\tif (current != p) {\n\t\terror = avc_has_perm(current_sid(), __tsec->sid,\n\t\t\t\t     SECCLASS_PROCESS, PROCESS__GETATTR, NULL);\n\t\tif (error)\n\t\t\tgoto bad;\n\t}\n\n\tif (!strcmp(name, \"current\"))\n\t\tsid = __tsec->sid;\n\telse if (!strcmp(name, \"prev\"))\n\t\tsid = __tsec->osid;\n\telse if (!strcmp(name, \"exec\"))\n\t\tsid = __tsec->exec_sid;\n\telse if (!strcmp(name, \"fscreate\"))\n\t\tsid = __tsec->create_sid;\n\telse if (!strcmp(name, \"keycreate\"))\n\t\tsid = __tsec->keycreate_sid;\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\tsid = __tsec->sockcreate_sid;\n\telse {\n\t\terror = -EINVAL;\n\t\tgoto bad;\n\t}\n\trcu_read_unlock();\n\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_sid_to_context(sid, value, &len);\n\tif (error)\n\t\treturn error;\n\treturn len;\n\nbad:\n\trcu_read_unlock();\n\treturn error;\n}\n\nstatic int selinux_setprocattr(const char *name, void *value, size_t size)\n{\n\tstruct task_security_struct *tsec;\n\tstruct cred *new;\n\tu32 mysid = current_sid(), sid = 0, ptsid;\n\tint error;\n\tchar *str = value;\n\n\t \n\tif (!strcmp(name, \"exec\"))\n\t\terror = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETEXEC, NULL);\n\telse if (!strcmp(name, \"fscreate\"))\n\t\terror = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETFSCREATE, NULL);\n\telse if (!strcmp(name, \"keycreate\"))\n\t\terror = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETKEYCREATE, NULL);\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\terror = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETSOCKCREATE, NULL);\n\telse if (!strcmp(name, \"current\"))\n\t\terror = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETCURRENT, NULL);\n\telse\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (size && str[0] && str[0] != '\\n') {\n\t\tif (str[size-1] == '\\n') {\n\t\t\tstr[size-1] = 0;\n\t\t\tsize--;\n\t\t}\n\t\terror = security_context_to_sid(value, size,\n\t\t\t\t\t\t&sid, GFP_KERNEL);\n\t\tif (error == -EINVAL && !strcmp(name, \"fscreate\")) {\n\t\t\tif (!has_cap_mac_admin(true)) {\n\t\t\t\tstruct audit_buffer *ab;\n\t\t\t\tsize_t audit_size;\n\n\t\t\t\t \n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t\tab = audit_log_start(audit_context(),\n\t\t\t\t\t\t     GFP_ATOMIC,\n\t\t\t\t\t\t     AUDIT_SELINUX_ERR);\n\t\t\t\tif (!ab)\n\t\t\t\t\treturn error;\n\t\t\t\taudit_log_format(ab, \"op=fscreate invalid_context=\");\n\t\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\t\taudit_log_end(ab);\n\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\terror = security_context_to_sid_force(value, size,\n\t\t\t\t\t\t\t&sid);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t \n\ttsec = selinux_cred(new);\n\tif (!strcmp(name, \"exec\")) {\n\t\ttsec->exec_sid = sid;\n\t} else if (!strcmp(name, \"fscreate\")) {\n\t\ttsec->create_sid = sid;\n\t} else if (!strcmp(name, \"keycreate\")) {\n\t\tif (sid) {\n\t\t\terror = avc_has_perm(mysid, sid,\n\t\t\t\t\t     SECCLASS_KEY, KEY__CREATE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\t\ttsec->keycreate_sid = sid;\n\t} else if (!strcmp(name, \"sockcreate\")) {\n\t\ttsec->sockcreate_sid = sid;\n\t} else if (!strcmp(name, \"current\")) {\n\t\terror = -EINVAL;\n\t\tif (sid == 0)\n\t\t\tgoto abort_change;\n\n\t\t \n\t\tif (!current_is_single_threaded()) {\n\t\t\terror = security_bounded_transition(tsec->sid, sid);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\t \n\t\terror = avc_has_perm(tsec->sid, sid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__DYNTRANSITION, NULL);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\n\t\t \n\t\tptsid = ptrace_parent_sid();\n\t\tif (ptsid != 0) {\n\t\t\terror = avc_has_perm(ptsid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t     PROCESS__PTRACE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\ttsec->sid = sid;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto abort_change;\n\t}\n\n\tcommit_creds(new);\n\treturn size;\n\nabort_change:\n\tabort_creds(new);\n\treturn error;\n}\n\nstatic int selinux_ismaclabel(const char *name)\n{\n\treturn (strcmp(name, XATTR_SELINUX_SUFFIX) == 0);\n}\n\nstatic int selinux_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\treturn security_sid_to_context(secid,\n\t\t\t\t       secdata, seclen);\n}\n\nstatic int selinux_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\treturn security_context_to_sid(secdata, seclen,\n\t\t\t\t       secid, GFP_KERNEL);\n}\n\nstatic void selinux_release_secctx(char *secdata, u32 seclen)\n{\n\tkfree(secdata);\n}\n\nstatic void selinux_inode_invalidate_secctx(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\n\tspin_lock(&isec->lock);\n\tisec->initialized = LABEL_INVALID;\n\tspin_unlock(&isec->lock);\n}\n\n \nstatic int selinux_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\tint rc = selinux_inode_setsecurity(inode, XATTR_SELINUX_SUFFIX,\n\t\t\t\t\t   ctx, ctxlen, 0);\n\t \n\treturn rc == -EOPNOTSUPP ? 0 : rc;\n}\n\n \nstatic int selinux_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn __vfs_setxattr_noperm(&nop_mnt_idmap, dentry, XATTR_NAME_SELINUX,\n\t\t\t\t     ctx, ctxlen, 0);\n}\n\nstatic int selinux_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\tint len = 0;\n\tlen = selinux_inode_getsecurity(&nop_mnt_idmap, inode,\n\t\t\t\t\tXATTR_SELINUX_SUFFIX, ctx, true);\n\tif (len < 0)\n\t\treturn len;\n\t*ctxlen = len;\n\treturn 0;\n}\n#ifdef CONFIG_KEYS\n\nstatic int selinux_key_alloc(struct key *k, const struct cred *cred,\n\t\t\t     unsigned long flags)\n{\n\tconst struct task_security_struct *tsec;\n\tstruct key_security_struct *ksec;\n\n\tksec = kzalloc(sizeof(struct key_security_struct), GFP_KERNEL);\n\tif (!ksec)\n\t\treturn -ENOMEM;\n\n\ttsec = selinux_cred(cred);\n\tif (tsec->keycreate_sid)\n\t\tksec->sid = tsec->keycreate_sid;\n\telse\n\t\tksec->sid = tsec->sid;\n\n\tk->security = ksec;\n\treturn 0;\n}\n\nstatic void selinux_key_free(struct key *k)\n{\n\tstruct key_security_struct *ksec = k->security;\n\n\tk->security = NULL;\n\tkfree(ksec);\n}\n\nstatic int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  enum key_need_perm need_perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 perm, sid;\n\n\tswitch (need_perm) {\n\tcase KEY_NEED_VIEW:\n\t\tperm = KEY__VIEW;\n\t\tbreak;\n\tcase KEY_NEED_READ:\n\t\tperm = KEY__READ;\n\t\tbreak;\n\tcase KEY_NEED_WRITE:\n\t\tperm = KEY__WRITE;\n\t\tbreak;\n\tcase KEY_NEED_SEARCH:\n\t\tperm = KEY__SEARCH;\n\t\tbreak;\n\tcase KEY_NEED_LINK:\n\t\tperm = KEY__LINK;\n\t\tbreak;\n\tcase KEY_NEED_SETATTR:\n\t\tperm = KEY__SETATTR;\n\t\tbreak;\n\tcase KEY_NEED_UNLINK:\n\tcase KEY_SYSADMIN_OVERRIDE:\n\tcase KEY_AUTHTOKEN_OVERRIDE:\n\tcase KEY_DEFER_PERM_CHECK:\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EPERM;\n\n\t}\n\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\n\treturn avc_has_perm(sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}\n\nstatic int selinux_key_getsecurity(struct key *key, char **_buffer)\n{\n\tstruct key_security_struct *ksec = key->security;\n\tchar *context = NULL;\n\tunsigned len;\n\tint rc;\n\n\trc = security_sid_to_context(ksec->sid,\n\t\t\t\t     &context, &len);\n\tif (!rc)\n\t\trc = len;\n\t*_buffer = context;\n\treturn rc;\n}\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\nstatic int selinux_watch_key(struct key *key)\n{\n\tstruct key_security_struct *ksec = key->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, ksec->sid, SECCLASS_KEY, KEY__VIEW, NULL);\n}\n#endif\n#endif\n\n#ifdef CONFIG_SECURITY_INFINIBAND\nstatic int selinux_ib_pkey_access(void *ib_sec, u64 subnet_prefix, u16 pkey_val)\n{\n\tstruct common_audit_data ad;\n\tint err;\n\tu32 sid = 0;\n\tstruct ib_security_struct *sec = ib_sec;\n\tstruct lsm_ibpkey_audit ibpkey;\n\n\terr = sel_ib_pkey_sid(subnet_prefix, pkey_val, &sid);\n\tif (err)\n\t\treturn err;\n\n\tad.type = LSM_AUDIT_DATA_IBPKEY;\n\tibpkey.subnet_prefix = subnet_prefix;\n\tibpkey.pkey = pkey_val;\n\tad.u.ibpkey = &ibpkey;\n\treturn avc_has_perm(sec->sid, sid,\n\t\t\t    SECCLASS_INFINIBAND_PKEY,\n\t\t\t    INFINIBAND_PKEY__ACCESS, &ad);\n}\n\nstatic int selinux_ib_endport_manage_subnet(void *ib_sec, const char *dev_name,\n\t\t\t\t\t    u8 port_num)\n{\n\tstruct common_audit_data ad;\n\tint err;\n\tu32 sid = 0;\n\tstruct ib_security_struct *sec = ib_sec;\n\tstruct lsm_ibendport_audit ibendport;\n\n\terr = security_ib_endport_sid(dev_name, port_num,\n\t\t\t\t      &sid);\n\n\tif (err)\n\t\treturn err;\n\n\tad.type = LSM_AUDIT_DATA_IBENDPORT;\n\tibendport.dev_name = dev_name;\n\tibendport.port = port_num;\n\tad.u.ibendport = &ibendport;\n\treturn avc_has_perm(sec->sid, sid,\n\t\t\t    SECCLASS_INFINIBAND_ENDPORT,\n\t\t\t    INFINIBAND_ENDPORT__MANAGE_SUBNET, &ad);\n}\n\nstatic int selinux_ib_alloc_security(void **ib_sec)\n{\n\tstruct ib_security_struct *sec;\n\n\tsec = kzalloc(sizeof(*sec), GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\tsec->sid = current_sid();\n\n\t*ib_sec = sec;\n\treturn 0;\n}\n\nstatic void selinux_ib_free_security(void *ib_sec)\n{\n\tkfree(ib_sec);\n}\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic int selinux_bpf(int cmd, union bpf_attr *attr,\n\t\t\t\t     unsigned int size)\n{\n\tu32 sid = current_sid();\n\tint ret;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\tret = avc_has_perm(sid, sid, SECCLASS_BPF, BPF__MAP_CREATE,\n\t\t\t\t   NULL);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\tret = avc_has_perm(sid, sid, SECCLASS_BPF, BPF__PROG_LOAD,\n\t\t\t\t   NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 bpf_map_fmode_to_av(fmode_t fmode)\n{\n\tu32 av = 0;\n\n\tif (fmode & FMODE_READ)\n\t\tav |= BPF__MAP_READ;\n\tif (fmode & FMODE_WRITE)\n\t\tav |= BPF__MAP_WRITE;\n\treturn av;\n}\n\n \nstatic int bpf_fd_pass(const struct file *file, u32 sid)\n{\n\tstruct bpf_security_struct *bpfsec;\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tint ret;\n\n\tif (file->f_op == &bpf_map_fops) {\n\t\tmap = file->private_data;\n\t\tbpfsec = map->security;\n\t\tret = avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t\t   bpf_map_fmode_to_av(file->f_mode), NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (file->f_op == &bpf_prog_fops) {\n\t\tprog = file->private_data;\n\t\tbpfsec = prog->aux->security;\n\t\tret = avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t\t   BPF__PROG_RUN, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int selinux_bpf_map(struct bpf_map *map, fmode_t fmode)\n{\n\tu32 sid = current_sid();\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = map->security;\n\treturn avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t    bpf_map_fmode_to_av(fmode), NULL);\n}\n\nstatic int selinux_bpf_prog(struct bpf_prog *prog)\n{\n\tu32 sid = current_sid();\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = prog->aux->security;\n\treturn avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t    BPF__PROG_RUN, NULL);\n}\n\nstatic int selinux_bpf_map_alloc(struct bpf_map *map)\n{\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);\n\tif (!bpfsec)\n\t\treturn -ENOMEM;\n\n\tbpfsec->sid = current_sid();\n\tmap->security = bpfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_bpf_map_free(struct bpf_map *map)\n{\n\tstruct bpf_security_struct *bpfsec = map->security;\n\n\tmap->security = NULL;\n\tkfree(bpfsec);\n}\n\nstatic int selinux_bpf_prog_alloc(struct bpf_prog_aux *aux)\n{\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);\n\tif (!bpfsec)\n\t\treturn -ENOMEM;\n\n\tbpfsec->sid = current_sid();\n\taux->security = bpfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_bpf_prog_free(struct bpf_prog_aux *aux)\n{\n\tstruct bpf_security_struct *bpfsec = aux->security;\n\n\taux->security = NULL;\n\tkfree(bpfsec);\n}\n#endif\n\nstruct lsm_blob_sizes selinux_blob_sizes __ro_after_init = {\n\t.lbs_cred = sizeof(struct task_security_struct),\n\t.lbs_file = sizeof(struct file_security_struct),\n\t.lbs_inode = sizeof(struct inode_security_struct),\n\t.lbs_ipc = sizeof(struct ipc_security_struct),\n\t.lbs_msg_msg = sizeof(struct msg_security_struct),\n\t.lbs_superblock = sizeof(struct superblock_security_struct),\n\t.lbs_xattr_count = SELINUX_INODE_INIT_XATTRS,\n};\n\n#ifdef CONFIG_PERF_EVENTS\nstatic int selinux_perf_event_open(struct perf_event_attr *attr, int type)\n{\n\tu32 requested, sid = current_sid();\n\n\tif (type == PERF_SECURITY_OPEN)\n\t\trequested = PERF_EVENT__OPEN;\n\telse if (type == PERF_SECURITY_CPU)\n\t\trequested = PERF_EVENT__CPU;\n\telse if (type == PERF_SECURITY_KERNEL)\n\t\trequested = PERF_EVENT__KERNEL;\n\telse if (type == PERF_SECURITY_TRACEPOINT)\n\t\trequested = PERF_EVENT__TRACEPOINT;\n\telse\n\t\treturn -EINVAL;\n\n\treturn avc_has_perm(sid, sid, SECCLASS_PERF_EVENT,\n\t\t\t    requested, NULL);\n}\n\nstatic int selinux_perf_event_alloc(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec;\n\n\tperfsec = kzalloc(sizeof(*perfsec), GFP_KERNEL);\n\tif (!perfsec)\n\t\treturn -ENOMEM;\n\n\tperfsec->sid = current_sid();\n\tevent->security = perfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_perf_event_free(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\n\tevent->security = NULL;\n\tkfree(perfsec);\n}\n\nstatic int selinux_perf_event_read(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, perfsec->sid,\n\t\t\t    SECCLASS_PERF_EVENT, PERF_EVENT__READ, NULL);\n}\n\nstatic int selinux_perf_event_write(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, perfsec->sid,\n\t\t\t    SECCLASS_PERF_EVENT, PERF_EVENT__WRITE, NULL);\n}\n#endif\n\n#ifdef CONFIG_IO_URING\n \nstatic int selinux_uring_override_creds(const struct cred *new)\n{\n\treturn avc_has_perm(current_sid(), cred_sid(new),\n\t\t\t    SECCLASS_IO_URING, IO_URING__OVERRIDE_CREDS, NULL);\n}\n\n \nstatic int selinux_uring_sqpoll(void)\n{\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(sid, sid,\n\t\t\t    SECCLASS_IO_URING, IO_URING__SQPOLL, NULL);\n}\n\n \nstatic int selinux_uring_cmd(struct io_uring_cmd *ioucmd)\n{\n\tstruct file *file = ioucmd->file;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\treturn avc_has_perm(current_sid(), isec->sid,\n\t\t\t    SECCLASS_IO_URING, IO_URING__CMD, &ad);\n}\n#endif  \n\n \nstatic struct security_hook_list selinux_hooks[] __ro_after_init = {\n\tLSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),\n\tLSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),\n\tLSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),\n\tLSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),\n\n\tLSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, selinux_capget),\n\tLSM_HOOK_INIT(capset, selinux_capset),\n\tLSM_HOOK_INIT(capable, selinux_capable),\n\tLSM_HOOK_INIT(quotactl, selinux_quotactl),\n\tLSM_HOOK_INIT(quota_on, selinux_quota_on),\n\tLSM_HOOK_INIT(syslog, selinux_syslog),\n\tLSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),\n\n\tLSM_HOOK_INIT(netlink_send, selinux_netlink_send),\n\n\tLSM_HOOK_INIT(bprm_creds_for_exec, selinux_bprm_creds_for_exec),\n\tLSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(sb_free_mnt_opts, selinux_free_mnt_opts),\n\tLSM_HOOK_INIT(sb_mnt_opts_compat, selinux_sb_mnt_opts_compat),\n\tLSM_HOOK_INIT(sb_remount, selinux_sb_remount),\n\tLSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),\n\tLSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),\n\tLSM_HOOK_INIT(sb_mount, selinux_mount),\n\tLSM_HOOK_INIT(sb_umount, selinux_umount),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),\n\n\tLSM_HOOK_INIT(move_mount, selinux_move_mount),\n\n\tLSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),\n\tLSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),\n\n\tLSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),\n\tLSM_HOOK_INIT(inode_init_security_anon, selinux_inode_init_security_anon),\n\tLSM_HOOK_INIT(inode_create, selinux_inode_create),\n\tLSM_HOOK_INIT(inode_link, selinux_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),\n\tLSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),\n\tLSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),\n\tLSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),\n\tLSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),\n\tLSM_HOOK_INIT(inode_rename, selinux_inode_rename),\n\tLSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),\n\tLSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),\n\tLSM_HOOK_INIT(inode_permission, selinux_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),\n\tLSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),\n\tLSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),\n\tLSM_HOOK_INIT(inode_set_acl, selinux_inode_set_acl),\n\tLSM_HOOK_INIT(inode_get_acl, selinux_inode_get_acl),\n\tLSM_HOOK_INIT(inode_remove_acl, selinux_inode_remove_acl),\n\tLSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),\n\tLSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),\n\tLSM_HOOK_INIT(path_notify, selinux_path_notify),\n\n\tLSM_HOOK_INIT(kernfs_init_security, selinux_kernfs_init_security),\n\n\tLSM_HOOK_INIT(file_permission, selinux_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),\n\tLSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),\n\tLSM_HOOK_INIT(mmap_file, selinux_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),\n\tLSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, selinux_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),\n\tLSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, selinux_file_receive),\n\n\tLSM_HOOK_INIT(file_open, selinux_file_open),\n\n\tLSM_HOOK_INIT(task_alloc, selinux_task_alloc),\n\tLSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),\n\tLSM_HOOK_INIT(cred_getsecid, selinux_cred_getsecid),\n\tLSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),\n\tLSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),\n\tLSM_HOOK_INIT(kernel_load_data, selinux_kernel_load_data),\n\tLSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),\n\tLSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, selinux_task_getsid),\n\tLSM_HOOK_INIT(current_getsecid_subj, selinux_current_getsecid_subj),\n\tLSM_HOOK_INIT(task_getsecid_obj, selinux_task_getsecid_obj),\n\tLSM_HOOK_INIT(task_setnice, selinux_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),\n\tLSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),\n\tLSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),\n\tLSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, selinux_task_movememory),\n\tLSM_HOOK_INIT(task_kill, selinux_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),\n\tLSM_HOOK_INIT(userns_create, selinux_userns_create),\n\n\tLSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_associate, selinux_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_associate, selinux_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, selinux_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, selinux_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, selinux_setprocattr),\n\n\tLSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),\n\tLSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),\n\tLSM_HOOK_INIT(release_secctx, selinux_release_secctx),\n\tLSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),\n\tLSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),\n\n\tLSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_create, selinux_socket_create),\n\tLSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),\n\tLSM_HOOK_INIT(socket_socketpair, selinux_socket_socketpair),\n\tLSM_HOOK_INIT(socket_bind, selinux_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, selinux_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, selinux_socket_listen),\n\tLSM_HOOK_INIT(socket_accept, selinux_socket_accept),\n\tLSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),\n\tLSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),\n\tLSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),\n\tLSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),\n\tLSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),\n\tLSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream,\n\t\t\tselinux_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),\n\tLSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),\n\tLSM_HOOK_INIT(sock_graft, selinux_sock_graft),\n\tLSM_HOOK_INIT(sctp_assoc_request, selinux_sctp_assoc_request),\n\tLSM_HOOK_INIT(sctp_sk_clone, selinux_sctp_sk_clone),\n\tLSM_HOOK_INIT(sctp_bind_connect, selinux_sctp_bind_connect),\n\tLSM_HOOK_INIT(sctp_assoc_established, selinux_sctp_assoc_established),\n\tLSM_HOOK_INIT(mptcp_add_subflow, selinux_mptcp_add_subflow),\n\tLSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),\n\tLSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),\n\tLSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),\n\tLSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),\n\tLSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),\n\tLSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),\n\tLSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),\n\tLSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),\n\tLSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),\n\tLSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),\n\tLSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),\n\tLSM_HOOK_INIT(ib_endport_manage_subnet,\n\t\t      selinux_ib_endport_manage_subnet),\n\tLSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),\n\tLSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),\n\tLSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),\n\tLSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),\n\tLSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),\n\tLSM_HOOK_INIT(xfrm_state_pol_flow_match,\n\t\t\tselinux_xfrm_state_pol_flow_match),\n\tLSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),\n#endif\n\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_free, selinux_key_free),\n\tLSM_HOOK_INIT(key_permission, selinux_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, selinux_key_getsecurity),\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\tLSM_HOOK_INIT(watch_key, selinux_watch_key),\n#endif\n#endif\n\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_known, selinux_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, selinux_audit_rule_match),\n\tLSM_HOOK_INIT(audit_rule_free, selinux_audit_rule_free),\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf, selinux_bpf),\n\tLSM_HOOK_INIT(bpf_map, selinux_bpf_map),\n\tLSM_HOOK_INIT(bpf_prog, selinux_bpf_prog),\n\tLSM_HOOK_INIT(bpf_map_free_security, selinux_bpf_map_free),\n\tLSM_HOOK_INIT(bpf_prog_free_security, selinux_bpf_prog_free),\n#endif\n\n#ifdef CONFIG_PERF_EVENTS\n\tLSM_HOOK_INIT(perf_event_open, selinux_perf_event_open),\n\tLSM_HOOK_INIT(perf_event_free, selinux_perf_event_free),\n\tLSM_HOOK_INIT(perf_event_read, selinux_perf_event_read),\n\tLSM_HOOK_INIT(perf_event_write, selinux_perf_event_write),\n#endif\n\n#ifdef CONFIG_IO_URING\n\tLSM_HOOK_INIT(uring_override_creds, selinux_uring_override_creds),\n\tLSM_HOOK_INIT(uring_sqpoll, selinux_uring_sqpoll),\n\tLSM_HOOK_INIT(uring_cmd, selinux_uring_cmd),\n#endif\n\n\t \n\tLSM_HOOK_INIT(fs_context_submount, selinux_fs_context_submount),\n\tLSM_HOOK_INIT(fs_context_dup, selinux_fs_context_dup),\n\tLSM_HOOK_INIT(fs_context_parse_param, selinux_fs_context_parse_param),\n\tLSM_HOOK_INIT(sb_eat_lsm_opts, selinux_sb_eat_lsm_opts),\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),\n#endif\n\n\t \n\tLSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_alloc_security,\n\t\t      selinux_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),\n\tLSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),\n\tLSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),\n\tLSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),\n\tLSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),\n\tLSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),\n\tLSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),\n\tLSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc_acquire,\n\t\t      selinux_xfrm_state_alloc_acquire),\n#endif\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, selinux_key_alloc),\n#endif\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, selinux_audit_rule_init),\n#endif\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf_map_alloc_security, selinux_bpf_map_alloc),\n\tLSM_HOOK_INIT(bpf_prog_alloc_security, selinux_bpf_prog_alloc),\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tLSM_HOOK_INIT(perf_event_alloc, selinux_perf_event_alloc),\n#endif\n};\n\nstatic __init int selinux_init(void)\n{\n\tpr_info(\"SELinux:  Initializing.\\n\");\n\n\tmemset(&selinux_state, 0, sizeof(selinux_state));\n\tenforcing_set(selinux_enforcing_boot);\n\tselinux_avc_init();\n\tmutex_init(&selinux_state.status_lock);\n\tmutex_init(&selinux_state.policy_mutex);\n\n\t \n\tcred_init_security();\n\n\tdefault_noexec = !(VM_DATA_DEFAULT_FLAGS & VM_EXEC);\n\tif (!default_noexec)\n\t\tpr_notice(\"SELinux:  virtual memory is executable by default\\n\");\n\n\tavc_init();\n\n\tavtab_cache_init();\n\n\tebitmap_cache_init();\n\n\thashtab_cache_init();\n\n\tsecurity_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks), \"selinux\");\n\n\tif (avc_add_callback(selinux_netcache_avc_callback, AVC_CALLBACK_RESET))\n\t\tpanic(\"SELinux: Unable to register AVC netcache callback\\n\");\n\n\tif (avc_add_callback(selinux_lsm_notifier_avc_callback, AVC_CALLBACK_RESET))\n\t\tpanic(\"SELinux: Unable to register AVC LSM notifier callback\\n\");\n\n\tif (selinux_enforcing_boot)\n\t\tpr_debug(\"SELinux:  Starting in enforcing mode\\n\");\n\telse\n\t\tpr_debug(\"SELinux:  Starting in permissive mode\\n\");\n\n\tfs_validate_description(\"selinux\", selinux_fs_parameters);\n\n\treturn 0;\n}\n\nstatic void delayed_superblock_init(struct super_block *sb, void *unused)\n{\n\tselinux_set_mnt_opts(sb, NULL, 0, NULL);\n}\n\nvoid selinux_complete_init(void)\n{\n\tpr_debug(\"SELinux:  Completing initialization.\\n\");\n\n\t \n\tpr_debug(\"SELinux:  Setting up existing superblocks.\\n\");\n\titerate_supers(delayed_superblock_init, NULL);\n}\n\n \nDEFINE_LSM(selinux) = {\n\t.name = \"selinux\",\n\t.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,\n\t.enabled = &selinux_enabled_boot,\n\t.blobs = &selinux_blob_sizes,\n\t.init = selinux_init,\n};\n\n#if defined(CONFIG_NETFILTER)\nstatic const struct nf_hook_ops selinux_nf_ops[] = {\n\t{\n\t\t.hook =\t\tselinux_ip_postroute,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_POST_ROUTING,\n\t\t.priority =\tNF_IP_PRI_SELINUX_LAST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ip_forward,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_FORWARD,\n\t\t.priority =\tNF_IP_PRI_SELINUX_FIRST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ip_output,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_LOCAL_OUT,\n\t\t.priority =\tNF_IP_PRI_SELINUX_FIRST,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.hook =\t\tselinux_ip_postroute,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_POST_ROUTING,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_LAST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ip_forward,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_FORWARD,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_FIRST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ip_output,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_LOCAL_OUT,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_FIRST,\n\t},\n#endif\t \n};\n\nstatic int __net_init selinux_nf_register(struct net *net)\n{\n\treturn nf_register_net_hooks(net, selinux_nf_ops,\n\t\t\t\t     ARRAY_SIZE(selinux_nf_ops));\n}\n\nstatic void __net_exit selinux_nf_unregister(struct net *net)\n{\n\tnf_unregister_net_hooks(net, selinux_nf_ops,\n\t\t\t\tARRAY_SIZE(selinux_nf_ops));\n}\n\nstatic struct pernet_operations selinux_net_ops = {\n\t.init = selinux_nf_register,\n\t.exit = selinux_nf_unregister,\n};\n\nstatic int __init selinux_nf_ip_init(void)\n{\n\tint err;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tpr_debug(\"SELinux:  Registering netfilter hooks\\n\");\n\n\terr = register_pernet_subsys(&selinux_net_ops);\n\tif (err)\n\t\tpanic(\"SELinux: register_pernet_subsys: error %d\\n\", err);\n\n\treturn 0;\n}\n__initcall(selinux_nf_ip_init);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}