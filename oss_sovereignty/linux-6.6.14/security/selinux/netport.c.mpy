{
  "module_name": "netport.c",
  "hash_id": "5df2efe5f938d5f26f03106d0a4e4cddd49fb84636bb4b056ba449440b80f2bf",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/netport.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n\n#include \"netport.h\"\n#include \"objsec.h\"\n\n#define SEL_NETPORT_HASH_SIZE       256\n#define SEL_NETPORT_HASH_BKT_LIMIT   16\n\nstruct sel_netport_bkt {\n\tint size;\n\tstruct list_head list;\n};\n\nstruct sel_netport {\n\tstruct netport_security_struct psec;\n\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n \n\nstatic DEFINE_SPINLOCK(sel_netport_lock);\nstatic struct sel_netport_bkt sel_netport_hash[SEL_NETPORT_HASH_SIZE];\n\n \nstatic unsigned int sel_netport_hashfn(u16 pnum)\n{\n\treturn (pnum & (SEL_NETPORT_HASH_SIZE - 1));\n}\n\n \nstatic struct sel_netport *sel_netport_find(u8 protocol, u16 pnum)\n{\n\tunsigned int idx;\n\tstruct sel_netport *port;\n\n\tidx = sel_netport_hashfn(pnum);\n\tlist_for_each_entry_rcu(port, &sel_netport_hash[idx].list, list)\n\t\tif (port->psec.port == pnum && port->psec.protocol == protocol)\n\t\t\treturn port;\n\n\treturn NULL;\n}\n\n \nstatic void sel_netport_insert(struct sel_netport *port)\n{\n\tunsigned int idx;\n\n\t \n\tidx = sel_netport_hashfn(port->psec.port);\n\tlist_add_rcu(&port->list, &sel_netport_hash[idx].list);\n\tif (sel_netport_hash[idx].size == SEL_NETPORT_HASH_BKT_LIMIT) {\n\t\tstruct sel_netport *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tlist_tail_rcu(&sel_netport_hash[idx].list),\n\t\t\t\tlockdep_is_held(&sel_netport_lock)),\n\t\t\tstruct sel_netport, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netport_hash[idx].size++;\n}\n\n \nstatic int sel_netport_sid_slow(u8 protocol, u16 pnum, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netport *port;\n\tstruct sel_netport *new;\n\n\tspin_lock_bh(&sel_netport_lock);\n\tport = sel_netport_find(protocol, pnum);\n\tif (port != NULL) {\n\t\t*sid = port->psec.sid;\n\t\tspin_unlock_bh(&sel_netport_lock);\n\t\treturn 0;\n\t}\n\n\tret = security_port_sid(protocol, pnum, sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new) {\n\t\tnew->psec.port = pnum;\n\t\tnew->psec.protocol = protocol;\n\t\tnew->psec.sid = *sid;\n\t\tsel_netport_insert(new);\n\t}\n\nout:\n\tspin_unlock_bh(&sel_netport_lock);\n\tif (unlikely(ret))\n\t\tpr_warn(\"SELinux: failure in %s(), unable to determine network port label\\n\",\n\t\t\t__func__);\n\treturn ret;\n}\n\n \nint sel_netport_sid(u8 protocol, u16 pnum, u32 *sid)\n{\n\tstruct sel_netport *port;\n\n\trcu_read_lock();\n\tport = sel_netport_find(protocol, pnum);\n\tif (port != NULL) {\n\t\t*sid = port->psec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netport_sid_slow(protocol, pnum, sid);\n}\n\n \nvoid sel_netport_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_netport *port, *port_tmp;\n\n\tspin_lock_bh(&sel_netport_lock);\n\tfor (idx = 0; idx < SEL_NETPORT_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(port, port_tmp,\n\t\t\t\t\t &sel_netport_hash[idx].list, list) {\n\t\t\tlist_del_rcu(&port->list);\n\t\t\tkfree_rcu(port, rcu);\n\t\t}\n\t\tsel_netport_hash[idx].size = 0;\n\t}\n\tspin_unlock_bh(&sel_netport_lock);\n}\n\nstatic __init int sel_netport_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_NETPORT_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_netport_hash[iter].list);\n\t\tsel_netport_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}\n\n__initcall(sel_netport_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}