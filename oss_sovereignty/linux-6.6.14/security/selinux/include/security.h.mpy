{
  "module_name": "security.h",
  "hash_id": "d5184ef2ed43ce5186a4ef79b094effa4f389fea251b2c89485a0c903871bea4",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/include/security.h",
  "human_readable_source": " \n \n\n#ifndef _SELINUX_SECURITY_H_\n#define _SELINUX_SECURITY_H_\n\n#include <linux/compiler.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/refcount.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/printk.h>\n#include \"flask.h\"\n#include \"policycap.h\"\n\n#define SECSID_NULL\t\t\t0x00000000  \n#define SECSID_WILD\t\t\t0xffffffff  \n#define SECCLASS_NULL\t\t\t0x0000  \n\n \n#define POLICYDB_VERSION_BASE\t\t15\n#define POLICYDB_VERSION_BOOL\t\t16\n#define POLICYDB_VERSION_IPV6\t\t17\n#define POLICYDB_VERSION_NLCLASS\t18\n#define POLICYDB_VERSION_VALIDATETRANS\t19\n#define POLICYDB_VERSION_MLS\t\t19\n#define POLICYDB_VERSION_AVTAB\t\t20\n#define POLICYDB_VERSION_RANGETRANS\t21\n#define POLICYDB_VERSION_POLCAP\t\t22\n#define POLICYDB_VERSION_PERMISSIVE\t23\n#define POLICYDB_VERSION_BOUNDARY\t24\n#define POLICYDB_VERSION_FILENAME_TRANS\t25\n#define POLICYDB_VERSION_ROLETRANS\t26\n#define POLICYDB_VERSION_NEW_OBJECT_DEFAULTS\t27\n#define POLICYDB_VERSION_DEFAULT_TYPE\t28\n#define POLICYDB_VERSION_CONSTRAINT_NAMES\t29\n#define POLICYDB_VERSION_XPERMS_IOCTL\t30\n#define POLICYDB_VERSION_INFINIBAND\t\t31\n#define POLICYDB_VERSION_GLBLUB\t\t32\n#define POLICYDB_VERSION_COMP_FTRANS\t33  \n\n \n#define POLICYDB_VERSION_MIN   POLICYDB_VERSION_BASE\n#define POLICYDB_VERSION_MAX   POLICYDB_VERSION_COMP_FTRANS\n\n \n#define SE_MNTMASK\t0x0f\n \n \n#define CONTEXT_MNT\t0x01\n#define FSCONTEXT_MNT\t0x02\n#define ROOTCONTEXT_MNT\t0x04\n#define DEFCONTEXT_MNT\t0x08\n#define SBLABEL_MNT\t0x10\n \n#define SE_SBINITIALIZED\t0x0100\n#define SE_SBPROC\t\t0x0200\n#define SE_SBGENFS\t\t0x0400\n#define SE_SBGENFS_XATTR\t0x0800\n#define SE_SBNATIVE\t\t0x1000\n\n#define CONTEXT_STR\t\"context\"\n#define FSCONTEXT_STR\t\"fscontext\"\n#define ROOTCONTEXT_STR\t\"rootcontext\"\n#define DEFCONTEXT_STR\t\"defcontext\"\n#define SECLABEL_STR \"seclabel\"\n\nstruct netlbl_lsm_secattr;\n\nextern int selinux_enabled_boot;\n\n \n#define TYPEDATUM_PROPERTY_PRIMARY\t0x0001\n#define TYPEDATUM_PROPERTY_ATTRIBUTE\t0x0002\n\n \n#define POLICYDB_BOUNDS_MAXDEPTH\t4\n\nstruct selinux_policy;\n\nstruct selinux_state {\n#ifdef CONFIG_SECURITY_SELINUX_DEVELOP\n\tbool enforcing;\n#endif\n\tbool initialized;\n\tbool policycap[__POLICYDB_CAP_MAX];\n\n\tstruct page *status_page;\n\tstruct mutex status_lock;\n\n\tstruct selinux_policy __rcu *policy;\n\tstruct mutex policy_mutex;\n} __randomize_layout;\n\nvoid selinux_avc_init(void);\n\nextern struct selinux_state selinux_state;\n\nstatic inline bool selinux_initialized(void)\n{\n\t \n\treturn smp_load_acquire(&selinux_state.initialized);\n}\n\nstatic inline void selinux_mark_initialized(void)\n{\n\t \n\tsmp_store_release(&selinux_state.initialized, true);\n}\n\n#ifdef CONFIG_SECURITY_SELINUX_DEVELOP\nstatic inline bool enforcing_enabled(void)\n{\n\treturn READ_ONCE(selinux_state.enforcing);\n}\n\nstatic inline void enforcing_set(bool value)\n{\n\tWRITE_ONCE(selinux_state.enforcing, value);\n}\n#else\nstatic inline bool enforcing_enabled(void)\n{\n\treturn true;\n}\n\nstatic inline void enforcing_set(bool value)\n{\n}\n#endif\n\nstatic inline bool checkreqprot_get(void)\n{\n\t \n\treturn 0;\n}\n\nstatic inline bool selinux_policycap_netpeer(void)\n{\n\treturn READ_ONCE(selinux_state.policycap[POLICYDB_CAP_NETPEER]);\n}\n\nstatic inline bool selinux_policycap_openperm(void)\n{\n\treturn READ_ONCE(selinux_state.policycap[POLICYDB_CAP_OPENPERM]);\n}\n\nstatic inline bool selinux_policycap_extsockclass(void)\n{\n\treturn READ_ONCE(selinux_state.policycap[POLICYDB_CAP_EXTSOCKCLASS]);\n}\n\nstatic inline bool selinux_policycap_alwaysnetwork(void)\n{\n\treturn READ_ONCE(selinux_state.policycap[POLICYDB_CAP_ALWAYSNETWORK]);\n}\n\nstatic inline bool selinux_policycap_cgroupseclabel(void)\n{\n\treturn READ_ONCE(selinux_state.policycap[POLICYDB_CAP_CGROUPSECLABEL]);\n}\n\nstatic inline bool selinux_policycap_nnp_nosuid_transition(void)\n{\n\treturn READ_ONCE(\n\t\tselinux_state.policycap[POLICYDB_CAP_NNP_NOSUID_TRANSITION]);\n}\n\nstatic inline bool selinux_policycap_genfs_seclabel_symlinks(void)\n{\n\treturn READ_ONCE(\n\t\tselinux_state.policycap[POLICYDB_CAP_GENFS_SECLABEL_SYMLINKS]);\n}\n\nstatic inline bool selinux_policycap_ioctl_skip_cloexec(void)\n{\n\treturn READ_ONCE(\n\t\tselinux_state.policycap[POLICYDB_CAP_IOCTL_SKIP_CLOEXEC]);\n}\n\nstruct selinux_policy_convert_data;\n\nstruct selinux_load_state {\n\tstruct selinux_policy *policy;\n\tstruct selinux_policy_convert_data *convert_data;\n};\n\nint security_mls_enabled(void);\nint security_load_policy(void *data, size_t len,\n\t\t\t struct selinux_load_state *load_state);\nvoid selinux_policy_commit(struct selinux_load_state *load_state);\nvoid selinux_policy_cancel(struct selinux_load_state *load_state);\nint security_read_policy(void **data, size_t *len);\nint security_read_state_kernel(void **data, size_t *len);\nint security_policycap_supported(unsigned int req_cap);\n\n#define SEL_VEC_MAX 32\nstruct av_decision {\n\tu32 allowed;\n\tu32 auditallow;\n\tu32 auditdeny;\n\tu32 seqno;\n\tu32 flags;\n};\n\n#define XPERMS_ALLOWED 1\n#define XPERMS_AUDITALLOW 2\n#define XPERMS_DONTAUDIT 4\n\n#define security_xperm_set(perms, x) ((perms)[(x) >> 5] |= 1 << ((x) & 0x1f))\n#define security_xperm_test(perms, x) (1 & ((perms)[(x) >> 5] >> ((x) & 0x1f)))\nstruct extended_perms_data {\n\tu32 p[8];\n};\n\nstruct extended_perms_decision {\n\tu8 used;\n\tu8 driver;\n\tstruct extended_perms_data *allowed;\n\tstruct extended_perms_data *auditallow;\n\tstruct extended_perms_data *dontaudit;\n};\n\nstruct extended_perms {\n\tu16 len;\t \n\tstruct extended_perms_data drivers;  \n};\n\n \n#define AVD_FLAGS_PERMISSIVE\t0x0001\n\nvoid security_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct extended_perms *xperms);\n\nvoid security_compute_xperms_decision(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t      u8 driver,\n\t\t\t\t      struct extended_perms_decision *xpermd);\n\nvoid security_compute_av_user(u32 ssid, u32 tsid,\n\t\t\t      u16 tclass, struct av_decision *avd);\n\nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid);\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid);\n\nint security_member_sid(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid);\n\nint security_change_sid(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid);\n\nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len);\n\nint security_sid_to_context_inval(u32 sid, char **scontext, u32 *scontext_len);\n\nint security_context_to_sid(const char *scontext, u32 scontext_len,\n\t\t\t    u32 *out_sid, gfp_t gfp);\n\nint security_context_str_to_sid(const char *scontext, u32 *out_sid, gfp_t gfp);\n\nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *out_sid, u32 def_sid, gfp_t gfp_flags);\n\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid);\n\nint security_get_user_sids(u32 callsid, char *username, u32 **sids, u32 *nel);\n\nint security_port_sid(u8 protocol, u16 port, u32 *out_sid);\n\nint security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid);\n\nint security_ib_endport_sid(const char *dev_name, u8 port_num, u32 *out_sid);\n\nint security_netif_sid(char *name, u32 *if_sid);\n\nint security_node_sid(u16 domain, void *addr, u32 addrlen,\n\t\t      u32 *out_sid);\n\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 tclass);\n\nint security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t      u16 tclass);\n\nint security_bounded_transition(u32 oldsid, u32 newsid);\n\nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid);\n\nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid);\n\nint security_get_classes(struct selinux_policy *policy,\n\t\t\t char ***classes, u32 *nclasses);\nint security_get_permissions(struct selinux_policy *policy,\n\t\t\t     const char *class, char ***perms, u32 *nperms);\nint security_get_reject_unknown(void);\nint security_get_allow_unknown(void);\n\n#define SECURITY_FS_USE_XATTR\t\t1  \n#define SECURITY_FS_USE_TRANS\t\t2  \n#define SECURITY_FS_USE_TASK\t\t3  \n#define SECURITY_FS_USE_GENFS\t\t4  \n#define SECURITY_FS_USE_NONE\t\t5  \n#define SECURITY_FS_USE_MNTPOINT\t6  \n#define SECURITY_FS_USE_NATIVE\t\t7  \n#define SECURITY_FS_USE_MAX\t\t7  \n\nint security_fs_use(struct super_block *sb);\n\nint security_genfs_sid(const char *fstype, const char *path, u16 sclass,\n\t\t       u32 *sid);\n\nint selinux_policy_genfs_sid(struct selinux_policy *policy,\n\t\t       const char *fstype, const char *path, u16 sclass,\n\t\t       u32 *sid);\n\n#ifdef CONFIG_NETLABEL\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid);\n\nint security_netlbl_sid_to_secattr(u32 sid,\n\t\t\t\t   struct netlbl_lsm_secattr *secattr);\n#else\nstatic inline int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t    u32 *sid)\n{\n\treturn -EIDRM;\n}\n\nstatic inline int security_netlbl_sid_to_secattr(u32 sid,\n\t\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOENT;\n}\n#endif  \n\nconst char *security_get_initial_sid_context(u32 sid);\n\n \nextern struct page *selinux_kernel_status_page(void);\n\n#define SELINUX_KERNEL_STATUS_VERSION\t1\nstruct selinux_kernel_status {\n\tu32\tversion;\t \n\tu32\tsequence;\t \n\tu32\tenforcing;\t \n\tu32\tpolicyload;\t \n\tu32\tdeny_unknown;\t \n\t \n} __packed;\n\nextern void selinux_status_update_setenforce(bool enforcing);\nextern void selinux_status_update_policyload(u32 seqno);\nextern void selinux_complete_init(void);\nextern struct path selinux_null;\nextern void selnl_notify_setenforce(int val);\nextern void selnl_notify_policyload(u32 seqno);\nextern int selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm);\n\nextern void avtab_cache_init(void);\nextern void ebitmap_cache_init(void);\nextern void hashtab_cache_init(void);\nextern int security_sidtab_hash_stats(char *page);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}