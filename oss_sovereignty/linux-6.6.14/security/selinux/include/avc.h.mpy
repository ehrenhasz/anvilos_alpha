{
  "module_name": "avc.h",
  "hash_id": "f50462911787d43bb9059999c72833c1fa86a22cf8a06570cbc4fdb77c6dc950",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/include/avc.h",
  "human_readable_source": " \n \n#ifndef _SELINUX_AVC_H_\n#define _SELINUX_AVC_H_\n\n#include <linux/stddef.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/kdev_t.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/audit.h>\n#include <linux/lsm_audit.h>\n#include <linux/in6.h>\n#include \"flask.h\"\n#include \"av_permissions.h\"\n#include \"security.h\"\n\n \nstruct avc_entry;\n\nstruct task_struct;\nstruct inode;\nstruct sock;\nstruct sk_buff;\n\n \nstruct avc_cache_stats {\n\tunsigned int lookups;\n\tunsigned int misses;\n\tunsigned int allocations;\n\tunsigned int reclaims;\n\tunsigned int frees;\n};\n\n \nstruct selinux_audit_data {\n\tu32 ssid;\n\tu32 tsid;\n\tu16 tclass;\n\tu32 requested;\n\tu32 audited;\n\tu32 denied;\n\tint result;\n} __randomize_layout;\n\n \n\nvoid __init avc_init(void);\n\nstatic inline u32 avc_audit_required(u32 requested,\n\t\t\t      struct av_decision *avd,\n\t\t\t      int result,\n\t\t\t      u32 auditdeny,\n\t\t\t      u32 *deniedp)\n{\n\tu32 denied, audited;\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\t \n\t\tif (auditdeny && !(auditdeny & avd->auditdeny))\n\t\t\taudited = 0;\n\t} else if (result)\n\t\taudited = denied = requested;\n\telse\n\t\taudited = requested & avd->auditallow;\n\t*deniedp = denied;\n\treturn audited;\n}\n\nint slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t   u32 requested, u32 audited, u32 denied, int result,\n\t\t   struct common_audit_data *a);\n\n \nstatic inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a);\n}\n\n#define AVC_STRICT 1  \n#define AVC_EXTENDED_PERMS 2\t \nint avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd);\n\nint avc_has_perm(u32 ssid, u32 tsid,\n\t\t u16 tclass, u32 requested,\n\t\t struct common_audit_data *auditdata);\n\nint avc_has_extended_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,\n\t\t\t   u8 driver, u8 perm, struct common_audit_data *ad);\n\n\nu32 avc_policy_seqno(void);\n\n#define AVC_CALLBACK_GRANT\t\t1\n#define AVC_CALLBACK_TRY_REVOKE\t\t2\n#define AVC_CALLBACK_REVOKE\t\t4\n#define AVC_CALLBACK_RESET\t\t8\n#define AVC_CALLBACK_AUDITALLOW_ENABLE\t16\n#define AVC_CALLBACK_AUDITALLOW_DISABLE\t32\n#define AVC_CALLBACK_AUDITDENY_ENABLE\t64\n#define AVC_CALLBACK_AUDITDENY_DISABLE\t128\n#define AVC_CALLBACK_ADD_XPERMS\t\t256\n\nint avc_add_callback(int (*callback)(u32 event), u32 events);\n\n \nint avc_get_hash_stats(char *page);\nunsigned int avc_get_cache_threshold(void);\nvoid avc_set_cache_threshold(unsigned int cache_threshold);\n\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\nDECLARE_PER_CPU(struct avc_cache_stats, avc_cache_stats);\n#endif\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}