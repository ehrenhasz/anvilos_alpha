{
  "module_name": "netnode.c",
  "hash_id": "dcf696ebffd9adc73a8a0bee57d12476cb7c4e9fbd59f9b0ae4671a7191c3257",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/netnode.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n\n#include \"netnode.h\"\n#include \"objsec.h\"\n\n#define SEL_NETNODE_HASH_SIZE       256\n#define SEL_NETNODE_HASH_BKT_LIMIT   16\n\nstruct sel_netnode_bkt {\n\tunsigned int size;\n\tstruct list_head list;\n};\n\nstruct sel_netnode {\n\tstruct netnode_security_struct nsec;\n\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n \n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\n \nstatic unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t \n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}\n\n \nstatic unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t \n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}\n\n \nstatic struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(const __be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(const __be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}\n\n \nstatic void sel_netnode_insert(struct sel_netnode *node)\n{\n\tunsigned int idx;\n\n\tswitch (node->nsec.family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(node->nsec.addr.ipv4);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(&node->nsec.addr.ipv6);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t \n\tlist_add_rcu(&node->list, &sel_netnode_hash[idx].list);\n\tif (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {\n\t\tstruct sel_netnode *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tlist_tail_rcu(&sel_netnode_hash[idx].list),\n\t\t\t\tlockdep_is_held(&sel_netnode_lock)),\n\t\t\tstruct sel_netnode, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netnode_hash[idx].size++;\n}\n\n \nstatic int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netnode *node;\n\tstruct sel_netnode *new;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\tspin_unlock_bh(&sel_netnode_lock);\n\t\treturn 0;\n\t}\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tswitch (family) {\n\tcase PF_INET:\n\t\tret = security_node_sid(PF_INET,\n\t\t\t\t\taddr, sizeof(struct in_addr), sid);\n\t\tif (new)\n\t\t\tnew->nsec.addr.ipv4 = *(__be32 *)addr;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tret = security_node_sid(PF_INET6,\n\t\t\t\t\taddr, sizeof(struct in6_addr), sid);\n\t\tif (new)\n\t\t\tnew->nsec.addr.ipv6 = *(struct in6_addr *)addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tret = -EINVAL;\n\t}\n\tif (ret == 0 && new) {\n\t\tnew->nsec.family = family;\n\t\tnew->nsec.sid = *sid;\n\t\tsel_netnode_insert(new);\n\t} else\n\t\tkfree(new);\n\n\tspin_unlock_bh(&sel_netnode_lock);\n\tif (unlikely(ret))\n\t\tpr_warn(\"SELinux: failure in %s(), unable to determine network node label\\n\",\n\t\t\t__func__);\n\treturn ret;\n}\n\n \nint sel_netnode_sid(void *addr, u16 family, u32 *sid)\n{\n\tstruct sel_netnode *node;\n\n\trcu_read_lock();\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netnode_sid_slow(addr, family, sid);\n}\n\n \nvoid sel_netnode_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node, *node_tmp;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tfor (idx = 0; idx < SEL_NETNODE_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(node, node_tmp,\n\t\t\t\t\t &sel_netnode_hash[idx].list, list) {\n\t\t\t\tlist_del_rcu(&node->list);\n\t\t\t\tkfree_rcu(node, rcu);\n\t\t}\n\t\tsel_netnode_hash[idx].size = 0;\n\t}\n\tspin_unlock_bh(&sel_netnode_lock);\n}\n\nstatic __init int sel_netnode_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_NETNODE_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_netnode_hash[iter].list);\n\t\tsel_netnode_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}\n\n__initcall(sel_netnode_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}