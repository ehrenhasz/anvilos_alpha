{
  "module_name": "xfrm.c",
  "hash_id": "538706c637da697c953b54d3677d0cd8590eaf469d895496ec2db23e94cf06e2",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/xfrm.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/xfrm.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n#include <linux/atomic.h>\n\n#include \"avc.h\"\n#include \"objsec.h\"\n#include \"xfrm.h\"\n\n \natomic_t selinux_xfrm_refcount __read_mostly = ATOMIC_INIT(0);\n\n \nstatic inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}\n\n \nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}\n\n \nstatic int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(struct_size(ctx, ctx_str, str_len + 1), gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len,\n\t\t\t\t     &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}\n\n \nstatic void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}\n\n \nstatic int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}\n\n \nint selinux_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid)\n{\n\tint rc;\n\n\t \n\tif (!ctx)\n\t\treturn 0;\n\n\t \n\tif (!selinux_authorizable_ctx(ctx))\n\t\treturn -EINVAL;\n\n\trc = avc_has_perm(fl_secid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, NULL);\n\treturn (rc == -EACCES ? -ESRCH : rc);\n}\n\n \nint selinux_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_policy *xp,\n\t\t\t\t      const struct flowi_common *flic)\n{\n\tu32 state_sid;\n\tu32 flic_sid;\n\n\tif (!xp->security)\n\t\tif (x->security)\n\t\t\t \n\t\t\treturn 0;\n\t\telse\n\t\t\t \n\t\t\treturn 1;\n\telse\n\t\tif (!x->security)\n\t\t\t \n\t\t\treturn 0;\n\t\telse\n\t\t\tif (!selinux_authorizable_xfrm(x))\n\t\t\t\t \n\t\t\t\treturn 0;\n\n\tstate_sid = x->security->ctx_sid;\n\tflic_sid = flic->flowic_secid;\n\n\tif (flic_sid != state_sid)\n\t\treturn 0;\n\n\t \n\treturn (avc_has_perm(flic_sid, state_sid,\n\t\t\t     SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO,\n\t\t\t     NULL) ? 0 : 1);\n}\n\nstatic u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x;\n\n\tif (dst == NULL)\n\t\treturn SECSID_NULL;\n\tx = dst->xfrm;\n\tif (x == NULL || !selinux_authorizable_xfrm(x))\n\t\treturn SECSID_NULL;\n\n\treturn x->security->ctx_sid;\n}\n\nstatic int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb_sec_path(skb);\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}\n\n \nint selinux_xfrm_decode_session(struct sk_buff *skb, u32 *sid, int ckall)\n{\n\tif (skb == NULL) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\treturn selinux_xfrm_skb_sid_ingress(skb, sid, ckall);\n}\n\nint selinux_xfrm_skb_sid(struct sk_buff *skb, u32 *sid)\n{\n\tint rc;\n\n\trc = selinux_xfrm_skb_sid_ingress(skb, sid, 0);\n\tif (rc == 0 && *sid == SECSID_NULL)\n\t\t*sid = selinux_xfrm_skb_sid_egress(skb);\n\n\treturn rc;\n}\n\n \nint selinux_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t      struct xfrm_user_sec_ctx *uctx,\n\t\t\t      gfp_t gfp)\n{\n\treturn selinux_xfrm_alloc_user(ctxp, uctx, gfp);\n}\n\n \nint selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\n\t\t\t      struct xfrm_sec_ctx **new_ctxp)\n{\n\tstruct xfrm_sec_ctx *new_ctx;\n\n\tif (!old_ctx)\n\t\treturn 0;\n\n\tnew_ctx = kmemdup(old_ctx, sizeof(*old_ctx) + old_ctx->ctx_len,\n\t\t\t  GFP_ATOMIC);\n\tif (!new_ctx)\n\t\treturn -ENOMEM;\n\tatomic_inc(&selinux_xfrm_refcount);\n\t*new_ctxp = new_ctx;\n\n\treturn 0;\n}\n\n \nvoid selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\n{\n\tselinux_xfrm_free(ctx);\n}\n\n \nint selinux_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\n{\n\treturn selinux_xfrm_delete(ctx);\n}\n\n \nint selinux_xfrm_state_alloc(struct xfrm_state *x,\n\t\t\t     struct xfrm_user_sec_ctx *uctx)\n{\n\treturn selinux_xfrm_alloc_user(&x->security, uctx, GFP_KERNEL);\n}\n\n \nint selinux_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t     struct xfrm_sec_ctx *polsec, u32 secid)\n{\n\tint rc;\n\tstruct xfrm_sec_ctx *ctx;\n\tchar *ctx_str = NULL;\n\tu32 str_len;\n\n\tif (!polsec)\n\t\treturn 0;\n\n\tif (secid == 0)\n\t\treturn -EINVAL;\n\n\trc = security_sid_to_context(secid, &ctx_str,\n\t\t\t\t     &str_len);\n\tif (rc)\n\t\treturn rc;\n\n\tctx = kmalloc(struct_size(ctx, ctx_str, str_len), GFP_ATOMIC);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_sid = secid;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, ctx_str, str_len);\n\n\tx->security = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\nout:\n\tkfree(ctx_str);\n\treturn rc;\n}\n\n \nvoid selinux_xfrm_state_free(struct xfrm_state *x)\n{\n\tselinux_xfrm_free(x->security);\n}\n\n \nint selinux_xfrm_state_delete(struct xfrm_state *x)\n{\n\treturn selinux_xfrm_delete(x->security);\n}\n\n \nint selinux_xfrm_sock_rcv_skb(u32 sk_sid, struct sk_buff *skb,\n\t\t\t      struct common_audit_data *ad)\n{\n\tint i;\n\tstruct sec_path *sp = skb_sec_path(skb);\n\tu32 peer_sid = SECINITSID_UNLABELED;\n\n\tif (sp) {\n\t\tfor (i = 0; i < sp->len; i++) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\n\t\t\tif (x && selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\t\t\t\tpeer_sid = ctx->ctx_sid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn avc_has_perm(sk_sid, peer_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, ad);\n}\n\n \nint selinux_xfrm_postroute_last(u32 sk_sid, struct sk_buff *skb,\n\t\t\t\tstruct common_audit_data *ad, u8 proto)\n{\n\tstruct dst_entry *dst;\n\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\tcase IPPROTO_COMP:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdst = skb_dst(skb);\n\tif (dst) {\n\t\tstruct dst_entry *iter;\n\n\t\tfor (iter = dst; iter != NULL; iter = xfrm_dst_child(iter)) {\n\t\t\tstruct xfrm_state *x = iter->xfrm;\n\n\t\t\tif (x && selinux_authorizable_xfrm(x))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn avc_has_perm(sk_sid, SECINITSID_UNLABELED,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, ad);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}