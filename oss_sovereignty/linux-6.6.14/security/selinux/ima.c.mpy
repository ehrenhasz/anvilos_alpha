{
  "module_name": "ima.c",
  "hash_id": "6600710749d5598477e8e04947c02a3ee30542bdb5f913ad49a359b2dbd99c73",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ima.c",
  "human_readable_source": "\n \n#include <linux/vmalloc.h>\n#include <linux/ima.h>\n#include \"security.h\"\n#include \"ima.h\"\n\n \nstatic char *selinux_ima_collect_state(void)\n{\n\tconst char *on = \"=1;\", *off = \"=0;\";\n\tchar *buf;\n\tint buf_len, len, i, rc;\n\n\tbuf_len = strlen(\"initialized=0;enforcing=0;checkreqprot=0;\") + 1;\n\n\tlen = strlen(on);\n\tfor (i = 0; i < __POLICYDB_CAP_MAX; i++)\n\t\tbuf_len += strlen(selinux_policycap_names[i]) + len;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\trc = strscpy(buf, \"initialized\", buf_len);\n\tWARN_ON(rc < 0);\n\n\trc = strlcat(buf, selinux_initialized() ? on : off, buf_len);\n\tWARN_ON(rc >= buf_len);\n\n\trc = strlcat(buf, \"enforcing\", buf_len);\n\tWARN_ON(rc >= buf_len);\n\n\trc = strlcat(buf, enforcing_enabled() ? on : off, buf_len);\n\tWARN_ON(rc >= buf_len);\n\n\trc = strlcat(buf, \"checkreqprot\", buf_len);\n\tWARN_ON(rc >= buf_len);\n\n\trc = strlcat(buf, checkreqprot_get() ? on : off, buf_len);\n\tWARN_ON(rc >= buf_len);\n\n\tfor (i = 0; i < __POLICYDB_CAP_MAX; i++) {\n\t\trc = strlcat(buf, selinux_policycap_names[i], buf_len);\n\t\tWARN_ON(rc >= buf_len);\n\n\t\trc = strlcat(buf, selinux_state.policycap[i] ? on : off,\n\t\t\tbuf_len);\n\t\tWARN_ON(rc >= buf_len);\n\t}\n\n\treturn buf;\n}\n\n \nvoid selinux_ima_measure_state_locked(void)\n{\n\tchar *state_str = NULL;\n\tvoid *policy = NULL;\n\tsize_t policy_len;\n\tint rc = 0;\n\n\tlockdep_assert_held(&selinux_state.policy_mutex);\n\n\tstate_str = selinux_ima_collect_state();\n\tif (!state_str) {\n\t\tpr_err(\"SELinux: %s: failed to read state.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tima_measure_critical_data(\"selinux\", \"selinux-state\",\n\t\t\t\t  state_str, strlen(state_str), false,\n\t\t\t\t  NULL, 0);\n\n\tkfree(state_str);\n\n\t \n\tif (!selinux_initialized())\n\t\treturn;\n\n\trc = security_read_state_kernel(&policy, &policy_len);\n\tif (rc) {\n\t\tpr_err(\"SELinux: %s: failed to read policy %d.\\n\", __func__, rc);\n\t\treturn;\n\t}\n\n\tima_measure_critical_data(\"selinux\", \"selinux-policy-hash\",\n\t\t\t\t  policy, policy_len, true,\n\t\t\t\t  NULL, 0);\n\n\tvfree(policy);\n}\n\n \nvoid selinux_ima_measure_state(void)\n{\n\tlockdep_assert_not_held(&selinux_state.policy_mutex);\n\n\tmutex_lock(&selinux_state.policy_mutex);\n\tselinux_ima_measure_state_locked();\n\tmutex_unlock(&selinux_state.policy_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}