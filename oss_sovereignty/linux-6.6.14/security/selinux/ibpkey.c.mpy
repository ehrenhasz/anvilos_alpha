{
  "module_name": "ibpkey.c",
  "hash_id": "e5b39e68b6bdccfda8513e439fadbb9d248f955798d04482633aee4b66ebdbb6",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/ibpkey.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n\n#include \"ibpkey.h\"\n#include \"objsec.h\"\n\n#define SEL_PKEY_HASH_SIZE       256\n#define SEL_PKEY_HASH_BKT_LIMIT   16\n\nstruct sel_ib_pkey_bkt {\n\tint size;\n\tstruct list_head list;\n};\n\nstruct sel_ib_pkey {\n\tstruct pkey_security_struct psec;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\n \nstatic unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}\n\n \nstatic struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\n{\n\tunsigned int idx;\n\n\t \n\tidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\n\tlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\n\tif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\n\t\tstruct sel_ib_pkey *tail;\n\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tlist_tail_rcu(&sel_ib_pkey_hash[idx].list),\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock)),\n\t\t\tstruct sel_ib_pkey, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else {\n\t\tsel_ib_pkey_hash[idx].size++;\n\t}\n}\n\n \nstatic int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tint ret;\n\tstruct sel_ib_pkey *pkey;\n\tstruct sel_ib_pkey *new = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\t\treturn 0;\n\t}\n\n\tret = security_ib_pkey_sid(subnet_prefix, pkey_num,\n\t\t\t\t   sid);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnew->psec.subnet_prefix = subnet_prefix;\n\tnew->psec.pkey = pkey_num;\n\tnew->psec.sid = *sid;\n\tsel_ib_pkey_insert(new);\n\nout:\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\treturn ret;\n}\n\n \nint sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tstruct sel_ib_pkey *pkey;\n\n\trcu_read_lock();\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_ib_pkey_sid_slow(subnet_prefix, pkey_num, sid);\n}\n\n \nvoid sel_ib_pkey_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey, *pkey_tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tfor (idx = 0; idx < SEL_PKEY_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(pkey, pkey_tmp,\n\t\t\t\t\t &sel_ib_pkey_hash[idx].list, list) {\n\t\t\tlist_del_rcu(&pkey->list);\n\t\t\tkfree_rcu(pkey, rcu);\n\t\t}\n\t\tsel_ib_pkey_hash[idx].size = 0;\n\t}\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n}\n\nstatic __init int sel_ib_pkey_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_PKEY_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_ib_pkey_hash[iter].list);\n\t\tsel_ib_pkey_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}\n\nsubsys_initcall(sel_ib_pkey_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}