{
  "module_name": "avc.c",
  "hash_id": "e89ae945a32cfe11c6f5fccdbb3634a480ae6f53610aecd2a9da9a849da84fa5",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/avc.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <net/af_unix.h>\n#include <linux/ip.h>\n#include <linux/audit.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include \"avc.h\"\n#include \"avc_ss.h\"\n#include \"classmap.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/avc.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n#define AVC_DEF_CACHE_THRESHOLD\t\t512\n#define AVC_CACHE_RECLAIM\t\t16\n\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n#define avc_cache_stats_incr(field)\tthis_cpu_inc(avc_cache_stats.field)\n#else\n#define avc_cache_stats_incr(field)\tdo {} while (0)\n#endif\n\nstruct avc_entry {\n\tu32\t\t\tssid;\n\tu32\t\t\ttsid;\n\tu16\t\t\ttclass;\n\tstruct av_decision\tavd;\n\tstruct avc_xperms_node\t*xp_node;\n};\n\nstruct avc_node {\n\tstruct avc_entry\tae;\n\tstruct hlist_node\tlist;  \n\tstruct rcu_head\t\trhead;\n};\n\nstruct avc_xperms_decision_node {\n\tstruct extended_perms_decision xpd;\n\tstruct list_head xpd_list;  \n};\n\nstruct avc_xperms_node {\n\tstruct extended_perms xp;\n\tstruct list_head xpd_head;  \n};\n\nstruct avc_cache {\n\tstruct hlist_head\tslots[AVC_CACHE_SLOTS];  \n\tspinlock_t\t\tslots_lock[AVC_CACHE_SLOTS];  \n\tatomic_t\t\tlru_hint;\t \n\tatomic_t\t\tactive_nodes;\n\tu32\t\t\tlatest_notif;\t \n};\n\nstruct avc_callback_node {\n\tint (*callback) (u32 event);\n\tu32 events;\n\tstruct avc_callback_node *next;\n};\n\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\nDEFINE_PER_CPU(struct avc_cache_stats, avc_cache_stats) = { 0 };\n#endif\n\nstruct selinux_avc {\n\tunsigned int avc_cache_threshold;\n\tstruct avc_cache avc_cache;\n};\n\nstatic struct selinux_avc selinux_avc;\n\nvoid selinux_avc_init(void)\n{\n\tint i;\n\n\tselinux_avc.avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\tINIT_HLIST_HEAD(&selinux_avc.avc_cache.slots[i]);\n\t\tspin_lock_init(&selinux_avc.avc_cache.slots_lock[i]);\n\t}\n\tatomic_set(&selinux_avc.avc_cache.active_nodes, 0);\n\tatomic_set(&selinux_avc.avc_cache.lru_hint, 0);\n}\n\nunsigned int avc_get_cache_threshold(void)\n{\n\treturn selinux_avc.avc_cache_threshold;\n}\n\nvoid avc_set_cache_threshold(unsigned int cache_threshold)\n{\n\tselinux_avc.avc_cache_threshold = cache_threshold;\n}\n\nstatic struct avc_callback_node *avc_callbacks __ro_after_init;\nstatic struct kmem_cache *avc_node_cachep __ro_after_init;\nstatic struct kmem_cache *avc_xperms_data_cachep __ro_after_init;\nstatic struct kmem_cache *avc_xperms_decision_cachep __ro_after_init;\nstatic struct kmem_cache *avc_xperms_cachep __ro_after_init;\n\nstatic inline u32 avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}\n\n \nvoid __init avc_init(void)\n{\n\tavc_node_cachep = kmem_cache_create(\"avc_node\", sizeof(struct avc_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_cachep = kmem_cache_create(\"avc_xperms_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_decision_cachep = kmem_cache_create(\n\t\t\t\t\t\"avc_xperms_decision_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_decision_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_data_cachep = kmem_cache_create(\"avc_xperms_data\",\n\t\t\t\t\tsizeof(struct extended_perms_data),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n}\n\nint avc_get_hash_stats(char *page)\n{\n\tint i, chain_len, max_chain_len, slots_used;\n\tstruct avc_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &selinux_avc.avc_cache.slots[i];\n\t\tif (!hlist_empty(head)) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\thlist_for_each_entry_rcu(node, head, list)\n\t\t\t\tchain_len++;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\",\n\t\t\t atomic_read(&selinux_avc.avc_cache.active_nodes),\n\t\t\t slots_used, AVC_CACHE_SLOTS, max_chain_len);\n}\n\n \nstatic struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}\n\nstatic inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}\n\nstatic void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\n\t\t\t\tu8 driver, u8 perm)\n{\n\tstruct extended_perms_decision *xpd;\n\tsecurity_xperm_set(xp_node->xp.drivers.p, driver);\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (xpd && xpd->allowed)\n\t\tsecurity_xperm_set(xpd->allowed->p, perm);\n}\n\nstatic void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}\n\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}\n\nstatic void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}\n\n \nstatic inline void avc_quick_copy_xperms_decision(u8 perm,\n\t\t\tstruct extended_perms_decision *dest,\n\t\t\tstruct extended_perms_decision *src)\n{\n\t \n\tu8 i = perm >> 5;\n\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tdest->allowed->p[i] = src->allowed->p[i];\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tdest->auditallow->p[i] = src->auditallow->p[i];\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tdest->dontaudit->p[i] = src->dontaudit->p[i];\n}\n\nstatic struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep,\n\t\t\t\t     GFP_NOWAIT | __GFP_NOWARN);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}\n\nstatic int avc_add_xperms_decision(struct avc_node *node,\n\t\t\tstruct extended_perms_decision *src)\n{\n\tstruct avc_xperms_decision_node *dest_xpd;\n\n\tnode->ae.xp_node->xp.len++;\n\tdest_xpd = avc_xperms_decision_alloc(src->used);\n\tif (!dest_xpd)\n\t\treturn -ENOMEM;\n\tavc_copy_xperms_decision(&dest_xpd->xpd, src);\n\tlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\n\treturn 0;\n}\n\nstatic struct avc_xperms_node *avc_xperms_alloc(void)\n{\n\tstruct avc_xperms_node *xp_node;\n\n\txp_node = kmem_cache_zalloc(avc_xperms_cachep, GFP_NOWAIT | __GFP_NOWARN);\n\tif (!xp_node)\n\t\treturn xp_node;\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\treturn xp_node;\n}\n\nstatic int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t \n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}\n\nstatic inline u32 avc_xperms_audit_required(u32 requested,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm,\n\t\t\t\t\tint result,\n\t\t\t\t\tu32 *deniedp)\n{\n\tu32 denied, audited;\n\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\tif (audited && xpd) {\n\t\t\tif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t} else if (result) {\n\t\taudited = denied = requested;\n\t} else {\n\t\taudited = requested & avd->auditallow;\n\t\tif (audited && xpd) {\n\t\t\tif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t}\n\n\t*deniedp = denied;\n\treturn audited;\n}\n\nstatic inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t   u32 requested, struct av_decision *avd,\n\t\t\t\t   struct extended_perms_decision *xpd,\n\t\t\t\t   u8 perm, int result,\n\t\t\t\t   struct common_audit_data *ad)\n{\n\tu32 audited, denied;\n\n\taudited = avc_xperms_audit_required(\n\t\t\trequested, avd, xpd, perm, result, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass, requested,\n\t\t\taudited, denied, result, ad);\n}\n\nstatic void avc_node_free(struct rcu_head *rhead)\n{\n\tstruct avc_node *node = container_of(rhead, struct avc_node, rhead);\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n}\n\nstatic void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&selinux_avc.avc_cache.active_nodes);\n}\n\nstatic void avc_node_kill(struct avc_node *node)\n{\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n\tatomic_dec(&selinux_avc.avc_cache.active_nodes);\n}\n\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&selinux_avc.avc_cache.active_nodes);\n}\n\nstatic inline int avc_reclaim_node(void)\n{\n\tstruct avc_node *node;\n\tint hvalue, try, ecx;\n\tunsigned long flags;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\n\t\thvalue = atomic_inc_return(&selinux_avc.avc_cache.lru_hint) &\n\t\t\t(AVC_CACHE_SLOTS - 1);\n\t\thead = &selinux_avc.avc_cache.slots[hvalue];\n\t\tlock = &selinux_avc.avc_cache.slots_lock[hvalue];\n\n\t\tif (!spin_trylock_irqsave(lock, flags))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list) {\n\t\t\tavc_node_delete(node);\n\t\t\tavc_cache_stats_incr(reclaims);\n\t\t\tecx++;\n\t\t\tif (ecx >= AVC_CACHE_RECLAIM) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tspin_unlock_irqrestore(lock, flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\nout:\n\treturn ecx;\n}\n\nstatic struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT | __GFP_NOWARN);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&selinux_avc.avc_cache.active_nodes) >\n\t    selinux_avc.avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}\n\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}\n\nstatic inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node, *ret = NULL;\n\tu32 hvalue;\n\tstruct hlist_head *head;\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &selinux_avc.avc_cache.slots[hvalue];\n\thlist_for_each_entry_rcu(node, head, list) {\n\t\tif (ssid == node->ae.ssid &&\n\t\t    tclass == node->ae.tclass &&\n\t\t    tsid == node->ae.tsid) {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}\n\nstatic int avc_latest_notif_update(u32 seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < selinux_avc.avc_cache.latest_notif) {\n\t\t\tpr_warn(\"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, selinux_avc.avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > selinux_avc.avc_cache.latest_notif)\n\t\t\tselinux_avc.avc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}\n\n \nstatic void avc_insert(u32 ssid, u32 tsid, u16 tclass,\n\t\t       struct av_decision *avd, struct avc_xperms_node *xp_node)\n{\n\tstruct avc_node *pos, *node = NULL;\n\tu32 hvalue;\n\tunsigned long flag;\n\tspinlock_t *lock;\n\tstruct hlist_head *head;\n\n\tif (avc_latest_notif_update(avd->seqno, 1))\n\t\treturn;\n\n\tnode = avc_alloc_node();\n\tif (!node)\n\t\treturn;\n\n\tavc_node_populate(node, ssid, tsid, tclass, avd);\n\tif (avc_xperms_populate(node, xp_node)) {\n\t\tavc_node_kill(node);\n\t\treturn;\n\t}\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &selinux_avc.avc_cache.slots[hvalue];\n\tlock = &selinux_avc.avc_cache.slots_lock[hvalue];\n\tspin_lock_irqsave(lock, flag);\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (pos->ae.ssid == ssid &&\n\t\t\tpos->ae.tsid == tsid &&\n\t\t\tpos->ae.tclass == tclass) {\n\t\t\tavc_node_replace(node, pos);\n\t\t\tgoto found;\n\t\t}\n\t}\n\thlist_add_head_rcu(&node->list, head);\nfound:\n\tspin_unlock_irqrestore(lock, flag);\n}\n\n \nstatic void avc_audit_pre_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\tstruct selinux_audit_data *sad = ad->selinux_audit_data;\n\tu32 av = sad->audited, perm;\n\tconst char *const *perms;\n\tu32 i;\n\n\taudit_log_format(ab, \"avc:  %s \", sad->denied ? \"denied\" : \"granted\");\n\n\tif (av == 0) {\n\t\taudit_log_format(ab, \" null\");\n\t\treturn;\n\t}\n\n\tperms = secclass_map[sad->tclass-1].perms;\n\n\taudit_log_format(ab, \" {\");\n\ti = 0;\n\tperm = 1;\n\twhile (i < (sizeof(av) * 8)) {\n\t\tif ((perm & av) && perms[i]) {\n\t\t\taudit_log_format(ab, \" %s\", perms[i]);\n\t\t\tav &= ~perm;\n\t\t}\n\t\ti++;\n\t\tperm <<= 1;\n\t}\n\n\tif (av)\n\t\taudit_log_format(ab, \" 0x%x\", av);\n\n\taudit_log_format(ab, \" } for \");\n}\n\n \nstatic void avc_audit_post_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\tstruct selinux_audit_data *sad = ad->selinux_audit_data;\n\tchar *scontext = NULL;\n\tchar *tcontext = NULL;\n\tconst char *tclass = NULL;\n\tu32 scontext_len;\n\tu32 tcontext_len;\n\tint rc;\n\n\trc = security_sid_to_context(sad->ssid, &scontext,\n\t\t\t\t     &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" ssid=%d\", sad->ssid);\n\telse\n\t\taudit_log_format(ab, \" scontext=%s\", scontext);\n\n\trc = security_sid_to_context(sad->tsid, &tcontext,\n\t\t\t\t     &tcontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" tsid=%d\", sad->tsid);\n\telse\n\t\taudit_log_format(ab, \" tcontext=%s\", tcontext);\n\n\ttclass = secclass_map[sad->tclass-1].name;\n\taudit_log_format(ab, \" tclass=%s\", tclass);\n\n\tif (sad->denied)\n\t\taudit_log_format(ab, \" permissive=%u\", sad->result ? 0 : 1);\n\n\ttrace_selinux_audited(sad, scontext, tcontext, tclass);\n\tkfree(tcontext);\n\tkfree(scontext);\n\n\t \n\trc = security_sid_to_context_inval(sad->ssid, &scontext,\n\t\t\t\t\t   &scontext_len);\n\tif (!rc && scontext) {\n\t\tif (scontext_len && scontext[scontext_len - 1] == '\\0')\n\t\t\tscontext_len--;\n\t\taudit_log_format(ab, \" srawcon=\");\n\t\taudit_log_n_untrustedstring(ab, scontext, scontext_len);\n\t\tkfree(scontext);\n\t}\n\n\trc = security_sid_to_context_inval(sad->tsid, &scontext,\n\t\t\t\t\t   &scontext_len);\n\tif (!rc && scontext) {\n\t\tif (scontext_len && scontext[scontext_len - 1] == '\\0')\n\t\t\tscontext_len--;\n\t\taudit_log_format(ab, \" trawcon=\");\n\t\taudit_log_n_untrustedstring(ab, scontext, scontext_len);\n\t\tkfree(scontext);\n\t}\n}\n\n \nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    u32 requested, u32 audited, u32 denied, int result,\n\t\t\t    struct common_audit_data *a)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (WARN_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map)))\n\t\treturn -EINVAL;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}\n\n \nint __init avc_add_callback(int (*callback)(u32 event), u32 events)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0;\n\n\tc = kmalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->callback = callback;\n\tc->events = events;\n\tc->next = avc_callbacks;\n\tavc_callbacks = c;\nout:\n\treturn rc;\n}\n\n \nstatic int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\t   u32 tsid, u16 tclass, u32 seqno,\n\t\t\t   struct extended_perms_decision *xpd,\n\t\t\t   u32 flags)\n{\n\tu32 hvalue;\n\tint rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &selinux_avc.avc_cache.slots[hvalue];\n\tlock = &selinux_avc.avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tavc_node_kill(node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}\n\n \nstatic void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &selinux_avc.avc_cache.slots[i];\n\t\tlock = &selinux_avc.avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t \n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}\n\n \nint avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t \n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}\n\n \nstatic noinline void avc_compute_av(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t    struct av_decision *avd,\n\t\t\t\t    struct avc_xperms_node *xp_node)\n{\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\tavc_insert(ssid, tsid, tclass, avd, xp_node);\n}\n\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t       u16 tclass, u32 requested,\n\t\t\t       u8 driver, u8 xperm, unsigned int flags,\n\t\t\t       struct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (enforcing_enabled() &&\n\t    !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver,\n\t\t\txperm, ssid, tsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}\n\n \nint avc_has_extended_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,\n\t\t\t   u8 driver, u8 xperm, struct common_audit_data *ad)\n{\n\tstruct avc_node *node;\n\tstruct av_decision avd;\n\tu32 denied;\n\tstruct extended_perms_decision local_xpd;\n\tstruct extended_perms_decision *xpd = NULL;\n\tstruct extended_perms_data allowed;\n\tstruct extended_perms_data auditallow;\n\tstruct extended_perms_data dontaudit;\n\tstruct avc_xperms_node local_xp_node;\n\tstruct avc_xperms_node *xp_node;\n\tint rc = 0, rc2;\n\n\txp_node = &local_xp_node;\n\tif (WARN_ON(!requested))\n\t\treturn -EACCES;\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node)) {\n\t\tavc_compute_av(ssid, tsid, tclass, &avd, xp_node);\n\t} else {\n\t\tmemcpy(&avd, &node->ae.avd, sizeof(avd));\n\t\txp_node = node->ae.xp_node;\n\t}\n\t \n\tif (!xp_node || !xp_node->xp.len)\n\t\tgoto decision;\n\n\tlocal_xpd.allowed = &allowed;\n\tlocal_xpd.auditallow = &auditallow;\n\tlocal_xpd.dontaudit = &dontaudit;\n\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (unlikely(!xpd)) {\n\t\t \n\t\tif (!security_xperm_test(xp_node->xp.drivers.p, driver)) {\n\t\t\tavd.allowed &= ~requested;\n\t\t\tgoto decision;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsecurity_compute_xperms_decision(ssid, tsid, tclass,\n\t\t\t\t\t\t driver, &local_xpd);\n\t\trcu_read_lock();\n\t\tavc_update_node(AVC_CALLBACK_ADD_XPERMS, requested,\n\t\t\t\tdriver, xperm, ssid, tsid, tclass, avd.seqno,\n\t\t\t\t&local_xpd, 0);\n\t} else {\n\t\tavc_quick_copy_xperms_decision(xperm, &local_xpd, xpd);\n\t}\n\txpd = &local_xpd;\n\n\tif (!avc_xperms_has_perm(xpd, xperm, XPERMS_ALLOWED))\n\t\tavd.allowed &= ~requested;\n\ndecision:\n\tdenied = requested & ~(avd.allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested,\n\t\t\t\tdriver, xperm, AVC_EXTENDED_PERMS, &avd);\n\n\trcu_read_unlock();\n\n\trc2 = avc_xperms_audit(ssid, tsid, tclass, requested,\n\t\t\t&avd, xpd, xperm, rc, ad);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}\n\n \nstatic noinline int avc_perm_nonode(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t    u32 requested, unsigned int flags,\n\t\t\t\t    struct av_decision *avd)\n{\n\tu32 denied;\n\tstruct avc_xperms_node xp_node;\n\n\tavc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\treturn avc_denied(ssid, tsid, tclass, requested, 0, 0,\n\t\t\t\t  flags, avd);\n\treturn 0;\n}\n\n \ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tunsigned int flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tu32 denied;\n\tstruct avc_node *node;\n\n\tif (WARN_ON(!requested))\n\t\treturn -EACCES;\n\n\trcu_read_lock();\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node)) {\n\t\trcu_read_unlock();\n\t\treturn avc_perm_nonode(ssid, tsid, tclass, requested,\n\t\t\t\t       flags, avd);\n\t}\n\tdenied = requested & ~node->ae.avd.allowed;\n\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\trcu_read_unlock();\n\n\tif (unlikely(denied))\n\t\treturn avc_denied(ssid, tsid, tclass, requested, 0, 0,\n\t\t\t\t  flags, avd);\n\treturn 0;\n}\n\n \nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0,\n\t\t\t\t  &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc,\n\t\t\tauditdata);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}\n\nu32 avc_policy_seqno(void)\n{\n\treturn selinux_avc.avc_cache.latest_notif;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}