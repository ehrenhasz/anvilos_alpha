{
  "module_name": "netlabel.c",
  "hash_id": "ae7d7512255730fc128ef9e0bfdc26ed762e34a612287159a595a55dc607d7af",
  "original_prompt": "Ingested from linux-6.6.14/security/selinux/netlabel.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/gfp.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/sock.h>\n#include <net/netlabel.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"netlabel.h\"\n\n \nstatic int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}\n\n \nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}\n\n \nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}\n\n \nvoid selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}\n\n \nvoid selinux_netlbl_err(struct sk_buff *skb, u16 family, int error, int gateway)\n{\n\tnetlbl_skbuff_err(skb, family, error, gateway);\n}\n\n \nvoid selinux_netlbl_sk_security_free(struct sk_security_struct *sksec)\n{\n\tif (!sksec->nlbl_secattr)\n\t\treturn;\n\n\tnetlbl_secattr_free(sksec->nlbl_secattr);\n\tsksec->nlbl_secattr = NULL;\n\tsksec->nlbl_state = NLBL_UNSET;\n}\n\n \nvoid selinux_netlbl_sk_security_reset(struct sk_security_struct *sksec)\n{\n\tsksec->nlbl_state = NLBL_UNSET;\n}\n\n \nint selinux_netlbl_skbuff_getsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 *type,\n\t\t\t\t u32 *sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled()) {\n\t\t*type = NETLBL_NLTYPE_NONE;\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, sid);\n\telse\n\t\t*sid = SECSID_NULL;\n\t*type = secattr.type;\n\tnetlbl_secattr_destroy(&secattr);\n\n\treturn rc;\n}\n\n \nint selinux_netlbl_skbuff_setsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr_storage;\n\tstruct netlbl_lsm_secattr *secattr = NULL;\n\tstruct sock *sk;\n\n\t \n\tsk = skb_to_full_sk(skb);\n\tif (sk != NULL) {\n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t\tif (sksec->nlbl_state != NLBL_REQSKB)\n\t\t\treturn 0;\n\t\tsecattr = selinux_netlbl_sock_getattr(sk, sid);\n\t}\n\tif (secattr == NULL) {\n\t\tsecattr = &secattr_storage;\n\t\tnetlbl_secattr_init(secattr);\n\t\trc = security_netlbl_sid_to_secattr(sid, secattr);\n\t\tif (rc != 0)\n\t\t\tgoto skbuff_setsid_return;\n\t}\n\n\trc = netlbl_skbuff_setattr(skb, family, secattr);\n\nskbuff_setsid_return:\n\tif (secattr == &secattr_storage)\n\t\tnetlbl_secattr_destroy(secattr);\n\treturn rc;\n}\n\n \nint selinux_netlbl_sctp_assoc_request(struct sctp_association *asoc,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct sk_security_struct *sksec = asoc->base.sk->sk_security;\n\tstruct sockaddr_in addr4;\n\tstruct sockaddr_in6 addr6;\n\n\tif (asoc->base.sk->sk_family != PF_INET &&\n\t    asoc->base.sk->sk_family != PF_INET6)\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = security_netlbl_sid_to_secattr(asoc->secid, &secattr);\n\tif (rc != 0)\n\t\tgoto assoc_request_return;\n\n\t \n\tif (ip_hdr(skb)->version == 4) {\n\t\taddr4.sin_family = AF_INET;\n\t\taddr4.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\trc = netlbl_conn_setattr(asoc->base.sk, (void *)&addr4, &secattr);\n\t} else if (IS_ENABLED(CONFIG_IPV6) && ip_hdr(skb)->version == 6) {\n\t\taddr6.sin6_family = AF_INET6;\n\t\taddr6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\trc = netlbl_conn_setattr(asoc->base.sk, (void *)&addr6, &secattr);\n\t} else {\n\t\trc = -EAFNOSUPPORT;\n\t}\n\n\tif (rc == 0)\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\nassoc_request_return:\n\tnetlbl_secattr_destroy(&secattr);\n\treturn rc;\n}\n\n \nint selinux_netlbl_inet_conn_request(struct request_sock *req, u16 family)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = security_netlbl_sid_to_secattr(req->secid, &secattr);\n\tif (rc != 0)\n\t\tgoto inet_conn_request_return;\n\trc = netlbl_req_setattr(req, &secattr);\ninet_conn_request_return:\n\tnetlbl_secattr_destroy(&secattr);\n\treturn rc;\n}\n\n \nvoid selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (family == PF_INET)\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\telse\n\t\tsksec->nlbl_state = NLBL_UNSET;\n}\n\n \nvoid selinux_netlbl_sctp_sk_clone(struct sock *sk, struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\tnewsksec->nlbl_state = sksec->nlbl_state;\n}\n\n \nint selinux_netlbl_socket_post_create(struct sock *sk, u16 family)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, family, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nint selinux_netlbl_sock_rcv_skb(struct sk_security_struct *sksec,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu16 family,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tint rc;\n\tu32 nlbl_sid;\n\tu32 perm;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled())\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, &nlbl_sid);\n\telse\n\t\tnlbl_sid = SECINITSID_UNLABELED;\n\tnetlbl_secattr_destroy(&secattr);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tswitch (sksec->sclass) {\n\tcase SECCLASS_UDP_SOCKET:\n\t\tperm = UDP_SOCKET__RECVFROM;\n\t\tbreak;\n\tcase SECCLASS_TCP_SOCKET:\n\t\tperm = TCP_SOCKET__RECVFROM;\n\t\tbreak;\n\tdefault:\n\t\tperm = RAWIP_SOCKET__RECVFROM;\n\t}\n\n\trc = avc_has_perm(sksec->sid, nlbl_sid, sksec->sclass, perm, ad);\n\tif (rc == 0)\n\t\treturn 0;\n\n\tif (nlbl_sid != SECINITSID_UNLABELED)\n\t\tnetlbl_skbuff_err(skb, family, rc, 0);\n\treturn rc;\n}\n\n \nstatic inline int selinux_netlbl_option(int level, int optname)\n{\n\treturn (level == IPPROTO_IP && optname == IP_OPTIONS) ||\n\t\t(level == IPPROTO_IPV6 && optname == IPV6_HOPOPTS);\n}\n\n \nint selinux_netlbl_socket_setsockopt(struct socket *sock,\n\t\t\t\t     int level,\n\t\t\t\t     int optname)\n{\n\tint rc = 0;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (selinux_netlbl_option(level, optname) &&\n\t    (sksec->nlbl_state == NLBL_LABELED ||\n\t     sksec->nlbl_state == NLBL_CONNLABELED)) {\n\t\tnetlbl_secattr_init(&secattr);\n\t\tlock_sock(sk);\n\t\t \n\t\trc = netlbl_sock_getattr(sk, &secattr);\n\t\trelease_sock(sk);\n\t\tif (rc == 0)\n\t\t\trc = -EACCES;\n\t\telse if (rc == -ENOMSG)\n\t\t\trc = 0;\n\t\tnetlbl_secattr_destroy(&secattr);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int selinux_netlbl_socket_connect_helper(struct sock *sk,\n\t\t\t\t\t\tstruct sockaddr *addr)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\t \n\tif (addr->sa_family == AF_UNSPEC) {\n\t\tnetlbl_sock_delattr(sk);\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\treturn rc;\n\t}\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\trc = netlbl_conn_setattr(sk, addr, secattr);\n\tif (rc == 0)\n\t\tsksec->nlbl_state = NLBL_CONNLABELED;\n\n\treturn rc;\n}\n\n \nint selinux_netlbl_socket_connect_locked(struct sock *sk,\n\t\t\t\t\t struct sockaddr *addr)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (sksec->nlbl_state != NLBL_REQSKB &&\n\t    sksec->nlbl_state != NLBL_CONNLABELED)\n\t\treturn 0;\n\n\treturn selinux_netlbl_socket_connect_helper(sk, addr);\n}\n\n \nint selinux_netlbl_socket_connect(struct sock *sk, struct sockaddr *addr)\n{\n\tint rc;\n\n\tlock_sock(sk);\n\trc = selinux_netlbl_socket_connect_locked(sk, addr);\n\trelease_sock(sk);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}