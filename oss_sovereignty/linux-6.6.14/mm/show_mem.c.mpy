{
  "module_name": "show_mem.c",
  "hash_id": "e09780c5451e7689cdee5226a3f865f835dc5c28be4e307f906cfca3ebbe2e6b",
  "original_prompt": "Ingested from linux-6.6.14/mm/show_mem.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/cma.h>\n#include <linux/cpuset.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/mmzone.h>\n#include <linux/swap.h>\n#include <linux/vmstat.h>\n\n#include \"internal.h\"\n#include \"swap.h\"\n\natomic_long_t _totalram_pages __read_mostly;\nEXPORT_SYMBOL(_totalram_pages);\nunsigned long totalreserve_pages __read_mostly;\nunsigned long totalcma_pages __read_mostly;\n\nstatic inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}\n\nlong si_mem_available(void)\n{\n\tlong available;\n\tunsigned long pagecache;\n\tunsigned long wmark_low = 0;\n\tunsigned long pages[NR_LRU_LISTS];\n\tunsigned long reclaimable;\n\tstruct zone *zone;\n\tint lru;\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_node_page_state(NR_LRU_BASE + lru);\n\n\tfor_each_zone(zone)\n\t\twmark_low += low_wmark_pages(zone);\n\n\t \n\tavailable = global_zone_page_state(NR_FREE_PAGES) - totalreserve_pages;\n\n\t \n\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\n\tpagecache -= min(pagecache / 2, wmark_low);\n\tavailable += pagecache;\n\n\t \n\treclaimable = global_node_page_state_pages(NR_SLAB_RECLAIMABLE_B) +\n\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);\n\tavailable += reclaimable - min(reclaimable / 2, wmark_low);\n\n\tif (available < 0)\n\t\tavailable = 0;\n\treturn available;\n}\nEXPORT_SYMBOL_GPL(si_mem_available);\n\nvoid si_meminfo(struct sysinfo *val)\n{\n\tval->totalram = totalram_pages();\n\tval->sharedram = global_node_page_state(NR_SHMEM);\n\tval->freeram = global_zone_page_state(NR_FREE_PAGES);\n\tval->bufferram = nr_blockdev_pages();\n\tval->totalhigh = totalhigh_pages();\n\tval->freehigh = nr_free_highpages();\n\tval->mem_unit = PAGE_SIZE;\n}\n\nEXPORT_SYMBOL(si_meminfo);\n\n#ifdef CONFIG_NUMA\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t \n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += zone_managed_pages(&pgdat->node_zones[zone_type]);\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone_managed_pages(zone);\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}\n#endif\n\n \nstatic bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)\n{\n\tif (!(flags & SHOW_MEM_FILTER_NODES))\n\t\treturn false;\n\n\t \n\tif (!nodemask)\n\t\tnodemask = &cpuset_current_mems_allowed;\n\n\treturn !node_isset(nid, *nodemask);\n}\n\nstatic void show_migration_types(unsigned char type)\n{\n\tstatic const char types[MIGRATE_TYPES] = {\n\t\t[MIGRATE_UNMOVABLE]\t= 'U',\n\t\t[MIGRATE_MOVABLE]\t= 'M',\n\t\t[MIGRATE_RECLAIMABLE]\t= 'E',\n\t\t[MIGRATE_HIGHATOMIC]\t= 'H',\n#ifdef CONFIG_CMA\n\t\t[MIGRATE_CMA]\t\t= 'C',\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t\t[MIGRATE_ISOLATE]\t= 'I',\n#endif\n\t};\n\tchar tmp[MIGRATE_TYPES + 1];\n\tchar *p = tmp;\n\tint i;\n\n\tfor (i = 0; i < MIGRATE_TYPES; i++) {\n\t\tif (type & (1 << i))\n\t\t\t*p++ = types[i];\n\t}\n\n\t*p = '\\0';\n\tprintk(KERN_CONT \"(%s) \", tmp);\n}\n\nstatic bool node_has_managed_zones(pg_data_t *pgdat, int max_zone_idx)\n{\n\tint zone_idx;\n\tfor (zone_idx = 0; zone_idx <= max_zone_idx; zone_idx++)\n\t\tif (zone_managed_pages(pgdat->node_zones + zone_idx))\n\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic void show_free_areas(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)\n{\n\tunsigned long free_pcp = 0;\n\tint cpu, nid;\n\tstruct zone *zone;\n\tpg_data_t *pgdat;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (zone_idx(zone) > max_zone_idx)\n\t\t\tcontinue;\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->per_cpu_pageset, cpu)->count;\n\t}\n\n\tprintk(\"active_anon:%lu inactive_anon:%lu isolated_anon:%lu\\n\"\n\t\t\" active_file:%lu inactive_file:%lu isolated_file:%lu\\n\"\n\t\t\" unevictable:%lu dirty:%lu writeback:%lu\\n\"\n\t\t\" slab_reclaimable:%lu slab_unreclaimable:%lu\\n\"\n\t\t\" mapped:%lu shmem:%lu pagetables:%lu\\n\"\n\t\t\" sec_pagetables:%lu bounce:%lu\\n\"\n\t\t\" kernel_misc_reclaimable:%lu\\n\"\n\t\t\" free:%lu free_pcp:%lu free_cma:%lu\\n\",\n\t\tglobal_node_page_state(NR_ACTIVE_ANON),\n\t\tglobal_node_page_state(NR_INACTIVE_ANON),\n\t\tglobal_node_page_state(NR_ISOLATED_ANON),\n\t\tglobal_node_page_state(NR_ACTIVE_FILE),\n\t\tglobal_node_page_state(NR_INACTIVE_FILE),\n\t\tglobal_node_page_state(NR_ISOLATED_FILE),\n\t\tglobal_node_page_state(NR_UNEVICTABLE),\n\t\tglobal_node_page_state(NR_FILE_DIRTY),\n\t\tglobal_node_page_state(NR_WRITEBACK),\n\t\tglobal_node_page_state_pages(NR_SLAB_RECLAIMABLE_B),\n\t\tglobal_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B),\n\t\tglobal_node_page_state(NR_FILE_MAPPED),\n\t\tglobal_node_page_state(NR_SHMEM),\n\t\tglobal_node_page_state(NR_PAGETABLE),\n\t\tglobal_node_page_state(NR_SECONDARY_PAGETABLE),\n\t\tglobal_zone_page_state(NR_BOUNCE),\n\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE),\n\t\tglobal_zone_page_state(NR_FREE_PAGES),\n\t\tfree_pcp,\n\t\tglobal_zone_page_state(NR_FREE_CMA_PAGES));\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tif (show_mem_node_skip(filter, pgdat->node_id, nodemask))\n\t\t\tcontinue;\n\t\tif (!node_has_managed_zones(pgdat, max_zone_idx))\n\t\t\tcontinue;\n\n\t\tprintk(\"Node %d\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" isolated(anon):%lukB\"\n\t\t\t\" isolated(file):%lukB\"\n\t\t\t\" mapped:%lukB\"\n\t\t\t\" dirty:%lukB\"\n\t\t\t\" writeback:%lukB\"\n\t\t\t\" shmem:%lukB\"\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\" shmem_thp:%lukB\"\n\t\t\t\" shmem_pmdmapped:%lukB\"\n\t\t\t\" anon_thp:%lukB\"\n#endif\n\t\t\t\" writeback_tmp:%lukB\"\n\t\t\t\" kernel_stack:%lukB\"\n#ifdef CONFIG_SHADOW_CALL_STACK\n\t\t\t\" shadow_call_stack:%lukB\"\n#endif\n\t\t\t\" pagetables:%lukB\"\n\t\t\t\" sec_pagetables:%lukB\"\n\t\t\t\" all_unreclaimable? %s\"\n\t\t\t\"\\n\",\n\t\t\tpgdat->node_id,\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_UNEVICTABLE)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_MAPPED)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_DIRTY)),\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK)),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM)),\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_THPS)),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)),\n\t\t\tK(node_page_state(pgdat, NR_ANON_THPS)),\n#endif\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\n\t\t\tnode_page_state(pgdat, NR_KERNEL_STACK_KB),\n#ifdef CONFIG_SHADOW_CALL_STACK\n\t\t\tnode_page_state(pgdat, NR_KERNEL_SCS_KB),\n#endif\n\t\t\tK(node_page_state(pgdat, NR_PAGETABLE)),\n\t\t\tK(node_page_state(pgdat, NR_SECONDARY_PAGETABLE)),\n\t\t\tpgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?\n\t\t\t\t\"yes\" : \"no\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tint i;\n\n\t\tif (zone_idx(zone) > max_zone_idx)\n\t\t\tcontinue;\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfree_pcp = 0;\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->per_cpu_pageset, cpu)->count;\n\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT\n\t\t\t\"%s\"\n\t\t\t\" free:%lukB\"\n\t\t\t\" boost:%lukB\"\n\t\t\t\" min:%lukB\"\n\t\t\t\" low:%lukB\"\n\t\t\t\" high:%lukB\"\n\t\t\t\" reserved_highatomic:%luKB\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" writepending:%lukB\"\n\t\t\t\" present:%lukB\"\n\t\t\t\" managed:%lukB\"\n\t\t\t\" mlocked:%lukB\"\n\t\t\t\" bounce:%lukB\"\n\t\t\t\" free_pcp:%lukB\"\n\t\t\t\" local_pcp:%ukB\"\n\t\t\t\" free_cma:%lukB\"\n\t\t\t\"\\n\",\n\t\t\tzone->name,\n\t\t\tK(zone_page_state(zone, NR_FREE_PAGES)),\n\t\t\tK(zone->watermark_boost),\n\t\t\tK(min_wmark_pages(zone)),\n\t\t\tK(low_wmark_pages(zone)),\n\t\t\tK(high_wmark_pages(zone)),\n\t\t\tK(zone->nr_reserved_highatomic),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),\n\t\t\tK(zone->present_pages),\n\t\t\tK(zone_managed_pages(zone)),\n\t\t\tK(zone_page_state(zone, NR_MLOCK)),\n\t\t\tK(zone_page_state(zone, NR_BOUNCE)),\n\t\t\tK(free_pcp),\n\t\t\tK(this_cpu_read(zone->per_cpu_pageset->count)),\n\t\t\tK(zone_page_state(zone, NR_FREE_CMA_PAGES)));\n\t\tprintk(\"lowmem_reserve[]:\");\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\t\tprintk(KERN_CONT \" %ld\", zone->lowmem_reserve[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int order;\n\t\tunsigned long nr[MAX_ORDER + 1], flags, total = 0;\n\t\tunsigned char types[MAX_ORDER + 1];\n\n\t\tif (zone_idx(zone) > max_zone_idx)\n\t\t\tcontinue;\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT \"%s: \", zone->name);\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order <= MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &zone->free_area[order];\n\t\t\tint type;\n\n\t\t\tnr[order] = area->nr_free;\n\t\t\ttotal += nr[order] << order;\n\n\t\t\ttypes[order] = 0;\n\t\t\tfor (type = 0; type < MIGRATE_TYPES; type++) {\n\t\t\t\tif (!free_area_empty(area, type))\n\t\t\t\t\ttypes[order] |= 1 << type;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\tfor (order = 0; order <= MAX_ORDER; order++) {\n\t\t\tprintk(KERN_CONT \"%lu*%lukB \",\n\t\t\t       nr[order], K(1UL) << order);\n\t\t\tif (nr[order])\n\t\t\t\tshow_migration_types(types[order]);\n\t\t}\n\t\tprintk(KERN_CONT \"= %lukB\\n\", K(total));\n\t}\n\n\tfor_each_online_node(nid) {\n\t\tif (show_mem_node_skip(filter, nid, nodemask))\n\t\t\tcontinue;\n\t\thugetlb_show_meminfo_node(nid);\n\t}\n\n\tprintk(\"%ld total pagecache pages\\n\", global_node_page_state(NR_FILE_PAGES));\n\n\tshow_swap_cache_info();\n}\n\nvoid __show_mem(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)\n{\n\tunsigned long total = 0, reserved = 0, highmem = 0;\n\tstruct zone *zone;\n\n\tprintk(\"Mem-Info:\\n\");\n\tshow_free_areas(filter, nodemask, max_zone_idx);\n\n\tfor_each_populated_zone(zone) {\n\n\t\ttotal += zone->present_pages;\n\t\treserved += zone->present_pages - zone_managed_pages(zone);\n\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone->present_pages;\n\t}\n\n\tprintk(\"%lu pages RAM\\n\", total);\n\tprintk(\"%lu pages HighMem/MovableOnly\\n\", highmem);\n\tprintk(\"%lu pages reserved\\n\", reserved);\n#ifdef CONFIG_CMA\n\tprintk(\"%lu pages cma reserved\\n\", totalcma_pages);\n#endif\n#ifdef CONFIG_MEMORY_FAILURE\n\tprintk(\"%lu pages hwpoisoned\\n\", atomic_long_read(&num_poisoned_pages));\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}