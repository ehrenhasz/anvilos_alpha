{
  "module_name": "shuffle.c",
  "hash_id": "996625324678792ac69c2d686c0f38cb070176fe22b32cee45bb1e6d8647cf59",
  "original_prompt": "Ingested from linux-6.6.14/mm/shuffle.c",
  "human_readable_source": "\n\n\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/mmzone.h>\n#include <linux/random.h>\n#include <linux/moduleparam.h>\n#include \"internal.h\"\n#include \"shuffle.h\"\n\nDEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);\n\nstatic bool shuffle_param;\n\nstatic __meminit int shuffle_param_set(const char *val,\n\t\tconst struct kernel_param *kp)\n{\n\tif (param_set_bool(val, kp))\n\t\treturn -EINVAL;\n\tif (*(bool *)kp->arg)\n\t\tstatic_branch_enable(&page_alloc_shuffle_key);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops shuffle_param_ops = {\n\t.set = shuffle_param_set,\n\t.get = param_get_bool,\n};\nmodule_param_cb(shuffle, &shuffle_param_ops, &shuffle_param, 0400);\n\n \nstatic struct page * __meminit shuffle_valid_page(struct zone *zone,\n\t\t\t\t\t\t  unsigned long pfn, int order)\n{\n\tstruct page *page = pfn_to_online_page(pfn);\n\n\t \n\n\t \n\tif (!page)\n\t\treturn NULL;\n\n\t \n\tif (page_zone(page) != zone)\n\t\treturn NULL;\n\n\t \n\tif (!PageBuddy(page))\n\t\treturn NULL;\n\n\t \n\tif (buddy_order(page) != order)\n\t\treturn NULL;\n\n\treturn page;\n}\n\n \n#define SHUFFLE_RETRY 10\nvoid __meminit __shuffle_zone(struct zone *z)\n{\n\tunsigned long i, flags;\n\tunsigned long start_pfn = z->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(z);\n\tconst int order = SHUFFLE_ORDER;\n\tconst int order_pages = 1 << order;\n\n\tspin_lock_irqsave(&z->lock, flags);\n\tstart_pfn = ALIGN(start_pfn, order_pages);\n\tfor (i = start_pfn; i < end_pfn; i += order_pages) {\n\t\tunsigned long j;\n\t\tint migratetype, retry;\n\t\tstruct page *page_i, *page_j;\n\n\t\t \n\t\tpage_i = shuffle_valid_page(z, i, order);\n\t\tif (!page_i)\n\t\t\tcontinue;\n\n\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {\n\t\t\t \n\t\t\tj = z->zone_start_pfn +\n\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,\n\t\t\t\t\t\torder_pages);\n\t\t\tpage_j = shuffle_valid_page(z, j, order);\n\t\t\tif (page_j && page_j != page_i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (retry >= SHUFFLE_RETRY) {\n\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmigratetype = get_pageblock_migratetype(page_i);\n\t\tif (get_pageblock_migratetype(page_j) != migratetype) {\n\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_swap(&page_i->lru, &page_j->lru);\n\n\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);\n\n\t\t \n\t\tif ((i % (100 * order_pages)) == 0) {\n\t\t\tspin_unlock_irqrestore(&z->lock, flags);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&z->lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&z->lock, flags);\n}\n\n \nvoid __meminit __shuffle_free_memory(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tshuffle_zone(z);\n}\n\nbool shuffle_pick_tail(void)\n{\n\tstatic u64 rand;\n\tstatic u8 rand_bits;\n\tbool ret;\n\n\t \n\tif (rand_bits == 0) {\n\t\trand_bits = 64;\n\t\trand = get_random_u64();\n\t}\n\n\tret = rand & 1;\n\n\trand_bits--;\n\trand >>= 1;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}