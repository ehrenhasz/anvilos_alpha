{
  "module_name": "page_counter.c",
  "hash_id": "a490a217b85d034e26055355da644085d4ccfa9fa4f067141a86d0fe1abdcc28",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_counter.c",
  "human_readable_source": "\n \n\n#include <linux/page_counter.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/bug.h>\n#include <asm/page.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tprotected = min(usage, READ_ONCE(c->min));\n\told_protected = atomic_long_read(&c->min_usage);\n\tif (protected != old_protected) {\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tprotected = min(usage, READ_ONCE(c->low));\n\told_protected = atomic_long_read(&c->low_usage);\n\tif (protected != old_protected) {\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}\n\n \nvoid page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\t \n\tif (WARN_ONCE(new < 0, \"page_counter underflow: %ld nr_pages=%lu\\n\",\n\t\t      new, nr_pages)) {\n\t\tnew = 0;\n\t\tatomic_long_set(&counter->usage, new);\n\t}\n\tpropagate_protected_usage(counter, new);\n}\n\n \nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(c, new);\n\t\t \n\t\tif (new > READ_ONCE(c->watermark))\n\t\t\tWRITE_ONCE(c->watermark, new);\n\t}\n}\n\n \nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t \n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\t \n\t\t\tdata_race(c->failcnt++);\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(c, new);\n\t\t \n\t\tif (new > READ_ONCE(c->watermark))\n\t\t\tWRITE_ONCE(c->watermark, new);\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}\n\n \nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}\n\n \nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t \n\t\tusage = page_counter_read(counter);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (page_counter_read(counter) <= usage || nr_pages >= old)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}\n\n \nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tWRITE_ONCE(counter->min, nr_pages);\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}\n\n \nvoid page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tWRITE_ONCE(counter->low, nr_pages);\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}\n\n \nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}