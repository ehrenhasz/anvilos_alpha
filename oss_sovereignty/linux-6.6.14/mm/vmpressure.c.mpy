{
  "module_name": "vmpressure.c",
  "hash_id": "a3125371bd04f237da8062bd7c70e04737ed3d8764951f1a60eb62f4ef298a1c",
  "original_prompt": "Ingested from linux-6.6.14/mm/vmpressure.c",
  "human_readable_source": "\n \n\n#include <linux/cgroup.h>\n#include <linux/fs.h>\n#include <linux/log2.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/vmstat.h>\n#include <linux/eventfd.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/printk.h>\n#include <linux/vmpressure.h>\n\n \nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\n\n \nstatic const unsigned int vmpressure_level_med = 60;\nstatic const unsigned int vmpressure_level_critical = 95;\n\n \nstatic const unsigned int vmpressure_level_critical_prio = ilog2(100 / 10);\n\nstatic struct vmpressure *work_to_vmpressure(struct work_struct *work)\n{\n\treturn container_of(work, struct vmpressure, work);\n}\n\nstatic struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\n{\n\tstruct mem_cgroup *memcg = vmpressure_to_memcg(vmpr);\n\n\tmemcg = parent_mem_cgroup(memcg);\n\tif (!memcg)\n\t\treturn NULL;\n\treturn memcg_to_vmpressure(memcg);\n}\n\nenum vmpressure_levels {\n\tVMPRESSURE_LOW = 0,\n\tVMPRESSURE_MEDIUM,\n\tVMPRESSURE_CRITICAL,\n\tVMPRESSURE_NUM_LEVELS,\n};\n\nenum vmpressure_modes {\n\tVMPRESSURE_NO_PASSTHROUGH = 0,\n\tVMPRESSURE_HIERARCHY,\n\tVMPRESSURE_LOCAL,\n\tVMPRESSURE_NUM_MODES,\n};\n\nstatic const char * const vmpressure_str_levels[] = {\n\t[VMPRESSURE_LOW] = \"low\",\n\t[VMPRESSURE_MEDIUM] = \"medium\",\n\t[VMPRESSURE_CRITICAL] = \"critical\",\n};\n\nstatic const char * const vmpressure_str_modes[] = {\n\t[VMPRESSURE_NO_PASSTHROUGH] = \"default\",\n\t[VMPRESSURE_HIERARCHY] = \"hierarchy\",\n\t[VMPRESSURE_LOCAL] = \"local\",\n};\n\nstatic enum vmpressure_levels vmpressure_level(unsigned long pressure)\n{\n\tif (pressure >= vmpressure_level_critical)\n\t\treturn VMPRESSURE_CRITICAL;\n\telse if (pressure >= vmpressure_level_med)\n\t\treturn VMPRESSURE_MEDIUM;\n\treturn VMPRESSURE_LOW;\n}\n\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t \n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t \n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}\n\nstruct vmpressure_event {\n\tstruct eventfd_ctx *efd;\n\tenum vmpressure_levels level;\n\tenum vmpressure_modes mode;\n\tstruct list_head node;\n};\n\nstatic bool vmpressure_event(struct vmpressure *vmpr,\n\t\t\t     const enum vmpressure_levels level,\n\t\t\t     bool ancestor, bool signalled)\n{\n\tstruct vmpressure_event *ev;\n\tbool ret = false;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ancestor && ev->mode == VMPRESSURE_LOCAL)\n\t\t\tcontinue;\n\t\tif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\n\t\t\tcontinue;\n\t\tif (level < ev->level)\n\t\t\tcontinue;\n\t\teventfd_signal(ev->efd, 1);\n\t\tret = true;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n\n\treturn ret;\n}\n\nstatic void vmpressure_work_fn(struct work_struct *work)\n{\n\tstruct vmpressure *vmpr = work_to_vmpressure(work);\n\tunsigned long scanned;\n\tunsigned long reclaimed;\n\tenum vmpressure_levels level;\n\tbool ancestor = false;\n\tbool signalled = false;\n\n\tspin_lock(&vmpr->sr_lock);\n\t \n\tscanned = vmpr->tree_scanned;\n\tif (!scanned) {\n\t\tspin_unlock(&vmpr->sr_lock);\n\t\treturn;\n\t}\n\n\treclaimed = vmpr->tree_reclaimed;\n\tvmpr->tree_scanned = 0;\n\tvmpr->tree_reclaimed = 0;\n\tspin_unlock(&vmpr->sr_lock);\n\n\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\tdo {\n\t\tif (vmpressure_event(vmpr, level, ancestor, signalled))\n\t\t\tsignalled = true;\n\t\tancestor = true;\n\t} while ((vmpr = vmpressure_parent(vmpr)));\n}\n\n \nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t \n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && !tree)\n\t\treturn;\n\n\tvmpr = memcg_to_vmpressure(memcg);\n\n\t \n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t \n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t \n\t\tif (!memcg || mem_cgroup_is_root(memcg))\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t \n\t\t\tWRITE_ONCE(memcg->socket_pressure, jiffies + HZ);\n\t\t}\n\t}\n}\n\n \nvoid vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\n{\n\t \n\tif (prio > vmpressure_level_critical_prio)\n\t\treturn;\n\n\t \n\tvmpressure(gfp, memcg, true, vmpressure_win, 0);\n}\n\n#define MAX_VMPRESSURE_ARGS_LEN\t(strlen(\"critical\") + strlen(\"hierarchy\") + 2)\n\n \nint vmpressure_register_event(struct mem_cgroup *memcg,\n\t\t\t      struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\tenum vmpressure_modes mode = VMPRESSURE_NO_PASSTHROUGH;\n\tenum vmpressure_levels level;\n\tchar *spec, *spec_orig;\n\tchar *token;\n\tint ret = 0;\n\n\tspec_orig = spec = kstrndup(args, MAX_VMPRESSURE_ARGS_LEN, GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\t \n\ttoken = strsep(&spec, \",\");\n\tret = match_string(vmpressure_str_levels, VMPRESSURE_NUM_LEVELS, token);\n\tif (ret < 0)\n\t\tgoto out;\n\tlevel = ret;\n\n\t \n\ttoken = strsep(&spec, \",\");\n\tif (token) {\n\t\tret = match_string(vmpressure_str_modes, VMPRESSURE_NUM_MODES, token);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tmode = ret;\n\t}\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tev->efd = eventfd;\n\tev->level = level;\n\tev->mode = mode;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_add(&ev->node, &vmpr->events);\n\tmutex_unlock(&vmpr->events_lock);\n\tret = 0;\nout:\n\tkfree(spec_orig);\n\treturn ret;\n}\n\n \nvoid vmpressure_unregister_event(struct mem_cgroup *memcg,\n\t\t\t\t struct eventfd_ctx *eventfd)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ev->efd != eventfd)\n\t\t\tcontinue;\n\t\tlist_del(&ev->node);\n\t\tkfree(ev);\n\t\tbreak;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n}\n\n \nvoid vmpressure_init(struct vmpressure *vmpr)\n{\n\tspin_lock_init(&vmpr->sr_lock);\n\tmutex_init(&vmpr->events_lock);\n\tINIT_LIST_HEAD(&vmpr->events);\n\tINIT_WORK(&vmpr->work, vmpressure_work_fn);\n}\n\n \nvoid vmpressure_cleanup(struct vmpressure *vmpr)\n{\n\t \n\tflush_work(&vmpr->work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}