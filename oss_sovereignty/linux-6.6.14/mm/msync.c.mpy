{
  "module_name": "msync.c",
  "hash_id": "f67310e5ea7961cac22474dc074106082d95499e016f752dda2b9073e71c9d71",
  "original_prompt": "Ingested from linux-6.6.14/mm/msync.c",
  "human_readable_source": "\n \n\n \n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n\n \nSYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)\n{\n\tunsigned long end;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint unmapped_error = 0;\n\tint error = -EINVAL;\n\n\tstart = untagged_addr(start);\n\n\tif (flags & ~(MS_ASYNC | MS_INVALIDATE | MS_SYNC))\n\t\tgoto out;\n\tif (offset_in_page(start))\n\t\tgoto out;\n\tif ((flags & MS_ASYNC) && (flags & MS_SYNC))\n\t\tgoto out;\n\terror = -ENOMEM;\n\tlen = (len + ~PAGE_MASK) & PAGE_MASK;\n\tend = start + len;\n\tif (end < start)\n\t\tgoto out;\n\terror = 0;\n\tif (end == start)\n\t\tgoto out;\n\t \n\tmmap_read_lock(mm);\n\tvma = find_vma(mm, start);\n\tfor (;;) {\n\t\tstruct file *file;\n\t\tloff_t fstart, fend;\n\n\t\t \n\t\terror = -ENOMEM;\n\t\tif (!vma)\n\t\t\tgoto out_unlock;\n\t\t \n\t\tif (start < vma->vm_start) {\n\t\t\tif (flags == MS_ASYNC)\n\t\t\t\tgoto out_unlock;\n\t\t\tstart = vma->vm_start;\n\t\t\tif (start >= end)\n\t\t\t\tgoto out_unlock;\n\t\t\tunmapped_error = -ENOMEM;\n\t\t}\n\t\t \n\t\tif ((flags & MS_INVALIDATE) &&\n\t\t\t\t(vma->vm_flags & VM_LOCKED)) {\n\t\t\terror = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tfile = vma->vm_file;\n\t\tfstart = (start - vma->vm_start) +\n\t\t\t ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\t\tfend = fstart + (min(end, vma->vm_end) - start) - 1;\n\t\tstart = vma->vm_end;\n\t\tif ((flags & MS_SYNC) && file &&\n\t\t\t\t(vma->vm_flags & VM_SHARED)) {\n\t\t\tget_file(file);\n\t\t\tmmap_read_unlock(mm);\n\t\t\terror = vfs_fsync_range(file, fstart, fend, 1);\n\t\t\tfput(file);\n\t\t\tif (error || start >= end)\n\t\t\t\tgoto out;\n\t\t\tmmap_read_lock(mm);\n\t\t\tvma = find_vma(mm, start);\n\t\t} else {\n\t\t\tif (start >= end) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tvma = find_vma(mm, vma->vm_end);\n\t\t}\n\t}\nout_unlock:\n\tmmap_read_unlock(mm);\nout:\n\treturn error ? : unmapped_error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}