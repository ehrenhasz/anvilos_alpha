{
  "module_name": "migrate_device.c",
  "hash_id": "d0ca2f482074a59e69bb35dd9e7f98636b7365efd4aa4f092bafbffd530e6dc3",
  "original_prompt": "Ingested from linux-6.6.14/mm/migrate_device.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/memremap.h>\n#include <linux/migrate.h>\n#include <linux/mm.h>\n#include <linux/mm_inline.h>\n#include <linux/mmu_notifier.h>\n#include <linux/oom.h>\n#include <linux/pagewalk.h>\n#include <linux/rmap.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include \"internal.h\"\n\nstatic int migrate_vma_collect_skip(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int migrate_vma_collect_hole(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    __always_unused int depth,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\t \n\tif (!vma_is_anonymous(walk->vma))\n\t\treturn migrate_vma_collect_skip(start, end, walk);\n\n\tfor (addr = start; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->src[migrate->npages] = MIGRATE_PFN_MIGRATE;\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->npages++;\n\t\tmigrate->cpages++;\n\t}\n\n\treturn 0;\n}\n\nstatic int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\nagain:\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tstruct page *page;\n\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpage = pmd_page(*pmdp);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tif (unlikely(!trylock_page(page)))\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (ret)\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t}\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tunsigned long mpfn = 0, pfn;\n\t\tstruct page *page;\n\t\tswp_entry_t entry;\n\t\tpte_t pte;\n\n\t\tpte = ptep_get(ptep);\n\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!pte_present(pte)) {\n\t\t\t \n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\t\tgoto next;\n\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\t\tgoto next;\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\t\tgoto next;\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\n\t\t \n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t\tmpfn = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tget_page(page);\n\n\t\t \n\t\tif (trylock_page(page)) {\n\t\t\tbool anon_exclusive;\n\t\t\tpte_t swp_pte;\n\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = PageAnon(page) && PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\n\t\t\t\tif (page_try_share_anon_rmap(page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tmpfn = 0;\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\n\t\t\tmigrate->cpages++;\n\n\t\t\t \n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(page_folio(page));\n\n\t\t\t \n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\n\t\t\t \n\t\t\tpage_remove_rmap(page, vma, false);\n\t\t\tput_page(page);\n\n\t\t\tif (pte_present(pte))\n\t\t\t\tunmapped++;\n\t\t} else {\n\t\t\tput_page(page);\n\t\t\tmpfn = 0;\n\t\t}\n\nnext:\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n\t \n\tif (unmapped)\n\t\tflush_tlb_range(walk->vma, start, end);\n\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(ptep - 1, ptl);\n\n\treturn 0;\n}\n\nstatic const struct mm_walk_ops migrate_vma_walk_ops = {\n\t.pmd_entry\t\t= migrate_vma_collect_pmd,\n\t.pte_hole\t\t= migrate_vma_collect_hole,\n\t.walk_lock\t\t= PGWALK_RDLOCK,\n};\n\n \nstatic void migrate_vma_collect(struct migrate_vma *migrate)\n{\n\tstruct mmu_notifier_range range;\n\n\t \n\tmmu_notifier_range_init_owner(&range, MMU_NOTIFY_MIGRATE, 0,\n\t\tmigrate->vma->vm_mm, migrate->start, migrate->end,\n\t\tmigrate->pgmap_owner);\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twalk_page_range(migrate->vma->vm_mm, migrate->start, migrate->end,\n\t\t\t&migrate_vma_walk_ops, migrate);\n\n\tmmu_notifier_invalidate_range_end(&range);\n\tmigrate->end = migrate->start + (migrate->npages << PAGE_SHIFT);\n}\n\n \nstatic bool migrate_vma_check_page(struct page *page, struct page *fault_page)\n{\n\t \n\tint extra = 1 + (page == fault_page);\n\n\t \n\tif (PageCompound(page))\n\t\treturn false;\n\n\t \n\tif (is_zone_device_page(page))\n\t\textra++;\n\n\t \n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic unsigned long migrate_device_unmap(unsigned long *src_pfns,\n\t\t\t\t\t  unsigned long npages,\n\t\t\t\t\t  struct page *fault_page)\n{\n\tunsigned long i, restore = 0;\n\tbool allow_drain = true;\n\tunsigned long unmapped = 0;\n\n\tlru_add_drain();\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tstruct folio *folio;\n\n\t\tif (!page) {\n\t\t\tif (src_pfns[i] & MIGRATE_PFN_MIGRATE)\n\t\t\t\tunmapped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t \n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (!isolate_lru_page(page)) {\n\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\trestore++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tput_page(page);\n\t\t}\n\n\t\tfolio = page_folio(page);\n\t\tif (folio_mapped(folio))\n\t\t\ttry_to_migrate(folio, 0);\n\n\t\tif (page_mapped(page) ||\n\t\t    !migrate_vma_check_page(page, fault_page)) {\n\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\tget_page(page);\n\t\t\t\tputback_lru_page(page);\n\t\t\t}\n\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\trestore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tunmapped++;\n\t}\n\n\tfor (i = 0; i < npages && restore; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tstruct folio *folio;\n\n\t\tif (!page || (src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tfolio = page_folio(page);\n\t\tremove_migration_ptes(folio, folio, false);\n\n\t\tsrc_pfns[i] = 0;\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\trestore--;\n\t}\n\n\treturn unmapped;\n}\n\n \nstatic void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tmigrate->cpages = migrate_device_unmap(migrate->src, migrate->npages,\n\t\t\t\t\tmigrate->fault_page);\n}\n\n \nint migrate_vma_setup(struct migrate_vma *args)\n{\n\tlong nr_pages = (args->end - args->start) >> PAGE_SHIFT;\n\n\targs->start &= PAGE_MASK;\n\targs->end &= PAGE_MASK;\n\tif (!args->vma || is_vm_hugetlb_page(args->vma) ||\n\t    (args->vma->vm_flags & VM_SPECIAL) || vma_is_dax(args->vma))\n\t\treturn -EINVAL;\n\tif (nr_pages <= 0)\n\t\treturn -EINVAL;\n\tif (args->start < args->vma->vm_start ||\n\t    args->start >= args->vma->vm_end)\n\t\treturn -EINVAL;\n\tif (args->end <= args->vma->vm_start || args->end > args->vma->vm_end)\n\t\treturn -EINVAL;\n\tif (!args->src || !args->dst)\n\t\treturn -EINVAL;\n\tif (args->fault_page && !is_device_private_page(args->fault_page))\n\t\treturn -EINVAL;\n\n\tmemset(args->src, 0, sizeof(*args->src) * nr_pages);\n\targs->cpages = 0;\n\targs->npages = 0;\n\n\tmigrate_vma_collect(args);\n\n\tif (args->cpages)\n\t\tmigrate_vma_unmap(args);\n\n\t \n\treturn 0;\n\n}\nEXPORT_SYMBOL(migrate_vma_setup);\n\n \nstatic void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned long *src)\n{\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool flush = false;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpgd_t *pgdp;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\tpte_t orig_pte;\n\n\t \n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\tif (pte_alloc(mm, pmdp))\n\t\tgoto abort;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_charge(page_folio(page), vma->vm_mm, GFP_KERNEL))\n\t\tgoto abort;\n\n\t \n\t__SetPageUptodate(page);\n\n\tif (is_device_private_page(page)) {\n\t\tswp_entry_t swp_entry;\n\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tswp_entry = make_writable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\telse\n\t\t\tswp_entry = make_readable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\tentry = swp_entry_to_pte(swp_entry);\n\t} else {\n\t\tif (is_zone_device_page(page) &&\n\t\t    !is_device_coherent_page(page)) {\n\t\t\tpr_warn_once(\"Unsupported ZONE_DEVICE page type.\\n\");\n\t\t\tgoto abort;\n\t\t}\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto abort;\n\torig_pte = ptep_get(ptep);\n\n\tif (check_stable_address_space(mm))\n\t\tgoto unlock_abort;\n\n\tif (pte_present(orig_pte)) {\n\t\tunsigned long pfn = pte_pfn(orig_pte);\n\n\t\tif (!is_zero_pfn(pfn))\n\t\t\tgoto unlock_abort;\n\t\tflush = true;\n\t} else if (!pte_none(orig_pte))\n\t\tgoto unlock_abort;\n\n\t \n\tif (userfaultfd_missing(vma))\n\t\tgoto unlock_abort;\n\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, addr);\n\tif (!is_zone_device_page(page))\n\t\tlru_cache_add_inactive_or_unevictable(page, vma);\n\tget_page(page);\n\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(orig_pte));\n\t\tptep_clear_flush(vma, addr, ptep);\n\t\tset_pte_at_notify(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t} else {\n\t\t \n\t\tset_pte_at(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t}\n\n\tpte_unmap_unlock(ptep, ptl);\n\t*src = MIGRATE_PFN_MIGRATE;\n\treturn;\n\nunlock_abort:\n\tpte_unmap_unlock(ptep, ptl);\nabort:\n\t*src &= ~MIGRATE_PFN_MIGRATE;\n}\n\nstatic void __migrate_device_pages(unsigned long *src_pfns,\n\t\t\t\tunsigned long *dst_pfns, unsigned long npages,\n\t\t\t\tstruct migrate_vma *migrate)\n{\n\tstruct mmu_notifier_range range;\n\tunsigned long i;\n\tbool notified = false;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\tunsigned long addr;\n\n\t\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tVM_BUG_ON(!migrate);\n\t\t\taddr = migrate->start + i*PAGE_SIZE;\n\t\t\tif (!notified) {\n\t\t\t\tnotified = true;\n\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&src_pfns[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_device_private_page(newpage) ||\n\t\t    is_device_coherent_page(newpage)) {\n\t\t\tif (mapping) {\n\t\t\t\tstruct folio *folio;\n\n\t\t\t\tfolio = page_folio(page);\n\n\t\t\t\t \n\t\t\t\tif (!folio_test_anon(folio) ||\n\t\t\t\t    !folio_free_swap(folio)) {\n\t\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (is_zone_device_page(newpage)) {\n\t\t\t \n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (migrate && migrate->fault_page == page)\n\t\t\tr = migrate_folio_extra(mapping, page_folio(newpage),\n\t\t\t\t\t\tpage_folio(page),\n\t\t\t\t\t\tMIGRATE_SYNC_NO_COPY, 1);\n\t\telse\n\t\t\tr = migrate_folio(mapping, page_folio(newpage),\n\t\t\t\t\tpage_folio(page), MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_end(&range);\n}\n\n \nvoid migrate_device_pages(unsigned long *src_pfns, unsigned long *dst_pfns,\n\t\t\tunsigned long npages)\n{\n\t__migrate_device_pages(src_pfns, dst_pfns, npages, NULL);\n}\nEXPORT_SYMBOL(migrate_device_pages);\n\n \nvoid migrate_vma_pages(struct migrate_vma *migrate)\n{\n\t__migrate_device_pages(migrate->src, migrate->dst, migrate->npages, migrate);\n}\nEXPORT_SYMBOL(migrate_vma_pages);\n\n \nvoid migrate_device_finalize(unsigned long *src_pfns,\n\t\t\tunsigned long *dst_pfns, unsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct folio *dst, *src;\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\n\t\tif (!page) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE) || !newpage) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tnewpage = page;\n\t\t}\n\n\t\tsrc = page_folio(page);\n\t\tdst = page_folio(newpage);\n\t\tremove_migration_ptes(src, dst, false);\n\t\tfolio_unlock(src);\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\n\t\tif (newpage != page) {\n\t\t\tunlock_page(newpage);\n\t\t\tif (is_zone_device_page(newpage))\n\t\t\t\tput_page(newpage);\n\t\t\telse\n\t\t\t\tputback_lru_page(newpage);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(migrate_device_finalize);\n\n \nvoid migrate_vma_finalize(struct migrate_vma *migrate)\n{\n\tmigrate_device_finalize(migrate->src, migrate->dst, migrate->npages);\n}\nEXPORT_SYMBOL(migrate_vma_finalize);\n\n \nint migrate_device_range(unsigned long *src_pfns, unsigned long start,\n\t\t\tunsigned long npages)\n{\n\tunsigned long i, pfn;\n\n\tfor (pfn = start, i = 0; i < npages; pfn++, i++) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (!get_page_unless_zero(page)) {\n\t\t\tsrc_pfns[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!trylock_page(page)) {\n\t\t\tsrc_pfns[i] = 0;\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_pfns[i] = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t}\n\n\tmigrate_device_unmap(src_pfns, npages, NULL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(migrate_device_range);\n\n \nint migrate_device_coherent_page(struct page *page)\n{\n\tunsigned long src_pfn, dst_pfn = 0;\n\tstruct page *dpage;\n\n\tWARN_ON_ONCE(PageCompound(page));\n\n\tlock_page(page);\n\tsrc_pfn = migrate_pfn(page_to_pfn(page)) | MIGRATE_PFN_MIGRATE;\n\n\t \n\tmigrate_device_unmap(&src_pfn, 1, NULL);\n\tif (!(src_pfn & MIGRATE_PFN_MIGRATE))\n\t\treturn -EBUSY;\n\n\tdpage = alloc_page(GFP_USER | __GFP_NOWARN);\n\tif (dpage) {\n\t\tlock_page(dpage);\n\t\tdst_pfn = migrate_pfn(page_to_pfn(dpage));\n\t}\n\n\tmigrate_device_pages(&src_pfn, &dst_pfn, 1);\n\tif (src_pfn & MIGRATE_PFN_MIGRATE)\n\t\tcopy_highpage(dpage, page);\n\tmigrate_device_finalize(&src_pfn, &dst_pfn, 1);\n\n\tif (src_pfn & MIGRATE_PFN_MIGRATE)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}