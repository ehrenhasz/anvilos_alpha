{
  "module_name": "debug_page_alloc.c",
  "hash_id": "d7e12598e6f126510c2ecaedf9cf9bbfb57bbc0718d084cb2977542681662618",
  "original_prompt": "Ingested from linux-6.6.14/mm/debug_page_alloc.c",
  "human_readable_source": "\n#include <linux/mm.h>\n#include <linux/page-isolation.h>\n\nunsigned int _debug_guardpage_minorder;\n\nbool _debug_pagealloc_enabled_early __read_mostly\n\t\t\t= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);\nEXPORT_SYMBOL(_debug_pagealloc_enabled_early);\nDEFINE_STATIC_KEY_FALSE(_debug_pagealloc_enabled);\nEXPORT_SYMBOL(_debug_pagealloc_enabled);\n\nDEFINE_STATIC_KEY_FALSE(_debug_guardpage_enabled);\n\nstatic int __init early_debug_pagealloc(char *buf)\n{\n\treturn kstrtobool(buf, &_debug_pagealloc_enabled_early);\n}\nearly_param(\"debug_pagealloc\", early_debug_pagealloc);\n\nstatic int __init debug_guardpage_minorder_setup(char *buf)\n{\n\tunsigned long res;\n\n\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_ORDER / 2) {\n\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");\n\t\treturn 0;\n\t}\n\t_debug_guardpage_minorder = res;\n\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);\n\treturn 0;\n}\nearly_param(\"debug_guardpage_minorder\", debug_guardpage_minorder_setup);\n\nbool __set_page_guard(struct zone *zone, struct page *page, unsigned int order,\n\t\t      int migratetype)\n{\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\n\t__SetPageGuard(page);\n\tINIT_LIST_HEAD(&page->buddy_list);\n\tset_page_private(page, order);\n\t \n\tif (!is_migrate_isolate(migratetype))\n\t\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\n\treturn true;\n}\n\nvoid __clear_page_guard(struct zone *zone, struct page *page, unsigned int order,\n\t\t      int migratetype)\n{\n\t__ClearPageGuard(page);\n\n\tset_page_private(page, 0);\n\tif (!is_migrate_isolate(migratetype))\n\t\t__mod_zone_freepage_state(zone, (1 << order), migratetype);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}