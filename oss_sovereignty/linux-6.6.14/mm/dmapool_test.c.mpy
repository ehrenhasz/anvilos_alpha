{
  "module_name": "dmapool_test.c",
  "hash_id": "31ed574e1b3d4a96d72a66ccad893fc65a5da6234986f339fd1eb64aa8889c42",
  "original_prompt": "Ingested from linux-6.6.14/mm/dmapool_test.c",
  "human_readable_source": "#include <linux/device.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n\n#define NR_TESTS (100)\n\nstruct dma_pool_pair {\n\tdma_addr_t dma;\n\tvoid *v;\n};\n\nstruct dmapool_parms {\n\tsize_t size;\n\tsize_t align;\n\tsize_t boundary;\n};\n\nstatic const struct dmapool_parms pool_parms[] = {\n\t{ .size = 16, .align = 16, .boundary = 0 },\n\t{ .size = 64, .align = 64, .boundary = 0 },\n\t{ .size = 256, .align = 256, .boundary = 0 },\n\t{ .size = 1024, .align = 1024, .boundary = 0 },\n\t{ .size = 4096, .align = 4096, .boundary = 0 },\n\t{ .size = 68, .align = 32, .boundary = 4096 },\n};\n\nstatic struct dma_pool *pool;\nstatic struct device test_dev;\nstatic u64 dma_mask;\n\nstatic inline int nr_blocks(int size)\n{\n\treturn clamp_t(int, (PAGE_SIZE / size) * 512, 1024, 8192);\n}\n\nstatic int dmapool_test_alloc(struct dma_pool_pair *p, int blocks)\n{\n\tint i;\n\n\tfor (i = 0; i < blocks; i++) {\n\t\tp[i].v = dma_pool_alloc(pool, GFP_KERNEL,\n\t\t\t\t\t&p[i].dma);\n\t\tif (!p[i].v)\n\t\t\tgoto pool_fail;\n\t}\n\n\tfor (i = 0; i < blocks; i++)\n\t\tdma_pool_free(pool, p[i].v, p[i].dma);\n\n\treturn 0;\n\npool_fail:\n\tfor (--i; i >= 0; i--)\n\t\tdma_pool_free(pool, p[i].v, p[i].dma);\n\treturn -ENOMEM;\n}\n\nstatic int dmapool_test_block(const struct dmapool_parms *parms)\n{\n\tint blocks = nr_blocks(parms->size);\n\tktime_t start_time, end_time;\n\tstruct dma_pool_pair *p;\n\tint i, ret;\n\n\tp = kcalloc(blocks, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpool = dma_pool_create(\"test pool\", &test_dev, parms->size,\n\t\t\t       parms->align, parms->boundary);\n\tif (!pool) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pairs;\n\t}\n\n\tstart_time = ktime_get();\n\tfor (i = 0; i < NR_TESTS; i++) {\n\t\tret = dmapool_test_alloc(p, blocks);\n\t\tif (ret)\n\t\t\tgoto free_pool;\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n\tend_time = ktime_get();\n\n\tprintk(\"dmapool test: size:%-4zu align:%-4zu blocks:%-4d time:%llu\\n\",\n\t\tparms->size, parms->align, blocks,\n\t\tktime_us_delta(end_time, start_time));\n\nfree_pool:\n\tdma_pool_destroy(pool);\nfree_pairs:\n\tkfree(p);\n\treturn ret;\n}\n\nstatic void dmapool_test_release(struct device *dev)\n{\n}\n\nstatic int dmapool_checks(void)\n{\n\tint i, ret;\n\n\tret = dev_set_name(&test_dev, \"dmapool-test\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_register(&test_dev);\n\tif (ret) {\n\t\tprintk(\"%s: register failed:%d\\n\", __func__, ret);\n\t\tgoto put_device;\n\t}\n\n\ttest_dev.release = dmapool_test_release;\n\tset_dma_ops(&test_dev, NULL);\n\ttest_dev.dma_mask = &dma_mask;\n\tret = dma_set_mask_and_coherent(&test_dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tprintk(\"%s: mask failed:%d\\n\", __func__, ret);\n\t\tgoto del_device;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pool_parms); i++) {\n\t\tret = dmapool_test_block(&pool_parms[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ndel_device:\n\tdevice_del(&test_dev);\nput_device:\n\tput_device(&test_dev);\n\treturn ret;\n}\n\nstatic void dmapool_exit(void)\n{\n}\n\nmodule_init(dmapool_checks);\nmodule_exit(dmapool_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}