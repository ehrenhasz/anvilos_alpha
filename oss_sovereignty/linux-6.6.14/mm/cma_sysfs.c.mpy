{
  "module_name": "cma_sysfs.c",
  "hash_id": "ca227c18d6bec04e6e68bc0798e06c101323ac9ab7b3c3d65573969ea6b2021d",
  "original_prompt": "Ingested from linux-6.6.14/mm/cma_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/cma.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"cma.h\"\n\n#define CMA_ATTR_RO(_name) \\\n\tstatic struct kobj_attribute _name##_attr = __ATTR_RO(_name)\n\nvoid cma_sysfs_account_success_pages(struct cma *cma, unsigned long nr_pages)\n{\n\tatomic64_add(nr_pages, &cma->nr_pages_succeeded);\n}\n\nvoid cma_sysfs_account_fail_pages(struct cma *cma, unsigned long nr_pages)\n{\n\tatomic64_add(nr_pages, &cma->nr_pages_failed);\n}\n\nstatic inline struct cma *cma_from_kobj(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct cma_kobject, kobj)->cma;\n}\n\nstatic ssize_t alloc_pages_success_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct cma *cma = cma_from_kobj(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  atomic64_read(&cma->nr_pages_succeeded));\n}\nCMA_ATTR_RO(alloc_pages_success);\n\nstatic ssize_t alloc_pages_fail_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\tstruct cma *cma = cma_from_kobj(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", atomic64_read(&cma->nr_pages_failed));\n}\nCMA_ATTR_RO(alloc_pages_fail);\n\nstatic void cma_kobj_release(struct kobject *kobj)\n{\n\tstruct cma *cma = cma_from_kobj(kobj);\n\tstruct cma_kobject *cma_kobj = cma->cma_kobj;\n\n\tkfree(cma_kobj);\n\tcma->cma_kobj = NULL;\n}\n\nstatic struct attribute *cma_attrs[] = {\n\t&alloc_pages_success_attr.attr,\n\t&alloc_pages_fail_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cma);\n\nstatic const struct kobj_type cma_ktype = {\n\t.release = cma_kobj_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = cma_groups,\n};\n\nstatic int __init cma_sysfs_init(void)\n{\n\tstruct kobject *cma_kobj_root;\n\tstruct cma_kobject *cma_kobj;\n\tstruct cma *cma;\n\tint i, err;\n\n\tcma_kobj_root = kobject_create_and_add(\"cma\", mm_kobj);\n\tif (!cma_kobj_root)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cma_area_count; i++) {\n\t\tcma_kobj = kzalloc(sizeof(*cma_kobj), GFP_KERNEL);\n\t\tif (!cma_kobj) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcma = &cma_areas[i];\n\t\tcma->cma_kobj = cma_kobj;\n\t\tcma_kobj->cma = cma;\n\t\terr = kobject_init_and_add(&cma_kobj->kobj, &cma_ktype,\n\t\t\t\t\t   cma_kobj_root, \"%s\", cma->name);\n\t\tif (err) {\n\t\t\tkobject_put(&cma_kobj->kobj);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\twhile (--i >= 0) {\n\t\tcma = &cma_areas[i];\n\t\tkobject_put(&cma->cma_kobj->kobj);\n\t}\n\tkobject_put(cma_kobj_root);\n\n\treturn err;\n}\nsubsys_initcall(cma_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}