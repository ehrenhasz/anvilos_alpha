{
  "module_name": "shrinker_debug.c",
  "hash_id": "dfe19e64460ad297f667f38ab93b352423a445f11573f34f52902d3019c2b2a9",
  "original_prompt": "Ingested from linux-6.6.14/mm/shrinker_debug.c",
  "human_readable_source": "\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/shrinker.h>\n#include <linux/memcontrol.h>\n\n \nextern struct rw_semaphore shrinker_rwsem;\nextern struct list_head shrinker_list;\n\nstatic DEFINE_IDA(shrinker_debugfs_ida);\nstatic struct dentry *shrinker_debugfs_root;\n\nstatic unsigned long shrinker_count_objects(struct shrinker *shrinker,\n\t\t\t\t\t    struct mem_cgroup *memcg,\n\t\t\t\t\t    unsigned long *count_per_node)\n{\n\tunsigned long nr, total = 0;\n\tint nid;\n\n\tfor_each_node(nid) {\n\t\tif (nid == 0 || (shrinker->flags & SHRINKER_NUMA_AWARE)) {\n\t\t\tstruct shrink_control sc = {\n\t\t\t\t.gfp_mask = GFP_KERNEL,\n\t\t\t\t.nid = nid,\n\t\t\t\t.memcg = memcg,\n\t\t\t};\n\n\t\t\tnr = shrinker->count_objects(shrinker, &sc);\n\t\t\tif (nr == SHRINK_EMPTY)\n\t\t\t\tnr = 0;\n\t\t} else {\n\t\t\tnr = 0;\n\t\t}\n\n\t\tcount_per_node[nid] = nr;\n\t\ttotal += nr;\n\t}\n\n\treturn total;\n}\n\nstatic int shrinker_debugfs_count_show(struct seq_file *m, void *v)\n{\n\tstruct shrinker *shrinker = m->private;\n\tunsigned long *count_per_node;\n\tstruct mem_cgroup *memcg;\n\tunsigned long total;\n\tbool memcg_aware;\n\tint ret, nid;\n\n\tcount_per_node = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!count_per_node)\n\t\treturn -ENOMEM;\n\n\tret = down_read_killable(&shrinker_rwsem);\n\tif (ret) {\n\t\tkfree(count_per_node);\n\t\treturn ret;\n\t}\n\trcu_read_lock();\n\n\tmemcg_aware = shrinker->flags & SHRINKER_MEMCG_AWARE;\n\n\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\tdo {\n\t\tif (memcg && !mem_cgroup_online(memcg))\n\t\t\tcontinue;\n\n\t\ttotal = shrinker_count_objects(shrinker,\n\t\t\t\t\t       memcg_aware ? memcg : NULL,\n\t\t\t\t\t       count_per_node);\n\t\tif (total) {\n\t\t\tseq_printf(m, \"%lu\", mem_cgroup_ino(memcg));\n\t\t\tfor_each_node(nid)\n\t\t\t\tseq_printf(m, \" %lu\", count_per_node[nid]);\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t\tif (!memcg_aware) {\n\t\t\tmem_cgroup_iter_break(NULL, memcg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tmem_cgroup_iter_break(NULL, memcg);\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);\n\n\trcu_read_unlock();\n\tup_read(&shrinker_rwsem);\n\n\tkfree(count_per_node);\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(shrinker_debugfs_count);\n\nstatic int shrinker_debugfs_scan_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t shrinker_debugfs_scan_write(struct file *file,\n\t\t\t\t\t   const char __user *buf,\n\t\t\t\t\t   size_t size, loff_t *pos)\n{\n\tstruct shrinker *shrinker = file->private_data;\n\tunsigned long nr_to_scan = 0, ino, read_len;\n\tstruct shrink_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\tstruct mem_cgroup *memcg = NULL;\n\tint nid;\n\tchar kbuf[72];\n\tssize_t ret;\n\n\tread_len = size < (sizeof(kbuf) - 1) ? size : (sizeof(kbuf) - 1);\n\tif (copy_from_user(kbuf, buf, read_len))\n\t\treturn -EFAULT;\n\tkbuf[read_len] = '\\0';\n\n\tif (sscanf(kbuf, \"%lu %d %lu\", &ino, &nid, &nr_to_scan) != 3)\n\t\treturn -EINVAL;\n\n\tif (nid < 0 || nid >= nr_node_ids)\n\t\treturn -EINVAL;\n\n\tif (nr_to_scan == 0)\n\t\treturn size;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tmemcg = mem_cgroup_get_from_ino(ino);\n\t\tif (!memcg || IS_ERR(memcg))\n\t\t\treturn -ENOENT;\n\n\t\tif (!mem_cgroup_online(memcg)) {\n\t\t\tmem_cgroup_put(memcg);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else if (ino != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = down_read_killable(&shrinker_rwsem);\n\tif (ret) {\n\t\tmem_cgroup_put(memcg);\n\t\treturn ret;\n\t}\n\n\tsc.nid = nid;\n\tsc.memcg = memcg;\n\tsc.nr_to_scan = nr_to_scan;\n\tsc.nr_scanned = nr_to_scan;\n\n\tshrinker->scan_objects(shrinker, &sc);\n\n\tup_read(&shrinker_rwsem);\n\tmem_cgroup_put(memcg);\n\n\treturn size;\n}\n\nstatic const struct file_operations shrinker_debugfs_scan_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = shrinker_debugfs_scan_open,\n\t.write\t = shrinker_debugfs_scan_write,\n};\n\nint shrinker_debugfs_add(struct shrinker *shrinker)\n{\n\tstruct dentry *entry;\n\tchar buf[128];\n\tint id;\n\n\tlockdep_assert_held(&shrinker_rwsem);\n\n\t \n\tif (!shrinker_debugfs_root)\n\t\treturn 0;\n\n\tid = ida_alloc(&shrinker_debugfs_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\tshrinker->debugfs_id = id;\n\n\tsnprintf(buf, sizeof(buf), \"%s-%d\", shrinker->name, id);\n\n\t \n\tentry = debugfs_create_dir(buf, shrinker_debugfs_root);\n\tif (IS_ERR(entry)) {\n\t\tida_free(&shrinker_debugfs_ida, id);\n\t\treturn PTR_ERR(entry);\n\t}\n\tshrinker->debugfs_entry = entry;\n\n\tdebugfs_create_file(\"count\", 0440, entry, shrinker,\n\t\t\t    &shrinker_debugfs_count_fops);\n\tdebugfs_create_file(\"scan\", 0220, entry, shrinker,\n\t\t\t    &shrinker_debugfs_scan_fops);\n\treturn 0;\n}\n\nint shrinker_debugfs_rename(struct shrinker *shrinker, const char *fmt, ...)\n{\n\tstruct dentry *entry;\n\tchar buf[128];\n\tconst char *new, *old;\n\tva_list ap;\n\tint ret = 0;\n\n\tva_start(ap, fmt);\n\tnew = kvasprintf_const(GFP_KERNEL, fmt, ap);\n\tva_end(ap);\n\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tdown_write(&shrinker_rwsem);\n\n\told = shrinker->name;\n\tshrinker->name = new;\n\n\tif (shrinker->debugfs_entry) {\n\t\tsnprintf(buf, sizeof(buf), \"%s-%d\", shrinker->name,\n\t\t\t shrinker->debugfs_id);\n\n\t\tentry = debugfs_rename(shrinker_debugfs_root,\n\t\t\t\t       shrinker->debugfs_entry,\n\t\t\t\t       shrinker_debugfs_root, buf);\n\t\tif (IS_ERR(entry))\n\t\t\tret = PTR_ERR(entry);\n\t\telse\n\t\t\tshrinker->debugfs_entry = entry;\n\t}\n\n\tup_write(&shrinker_rwsem);\n\n\tkfree_const(old);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(shrinker_debugfs_rename);\n\nstruct dentry *shrinker_debugfs_detach(struct shrinker *shrinker,\n\t\t\t\t       int *debugfs_id)\n{\n\tstruct dentry *entry = shrinker->debugfs_entry;\n\n\tlockdep_assert_held(&shrinker_rwsem);\n\n\tkfree_const(shrinker->name);\n\tshrinker->name = NULL;\n\n\t*debugfs_id = entry ? shrinker->debugfs_id : -1;\n\tshrinker->debugfs_entry = NULL;\n\n\treturn entry;\n}\n\nvoid shrinker_debugfs_remove(struct dentry *debugfs_entry, int debugfs_id)\n{\n\tdebugfs_remove_recursive(debugfs_entry);\n\tida_free(&shrinker_debugfs_ida, debugfs_id);\n}\n\nstatic int __init shrinker_debugfs_init(void)\n{\n\tstruct shrinker *shrinker;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tdentry = debugfs_create_dir(\"shrinker\", NULL);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tshrinker_debugfs_root = dentry;\n\n\t \n\tdown_write(&shrinker_rwsem);\n\tlist_for_each_entry(shrinker, &shrinker_list, list)\n\t\tif (!shrinker->debugfs_entry) {\n\t\t\tret = shrinker_debugfs_add(shrinker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tup_write(&shrinker_rwsem);\n\n\treturn ret;\n}\nlate_initcall(shrinker_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}