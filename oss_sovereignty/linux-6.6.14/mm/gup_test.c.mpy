{
  "module_name": "gup_test.c",
  "hash_id": "17c470a0954a8439d29891c340693cb6d725742d0ad21338e9cf0be4f59c7e1b",
  "original_prompt": "Ingested from linux-6.6.14/mm/gup_test.c",
  "human_readable_source": "#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ktime.h>\n#include <linux/debugfs.h>\n#include <linux/highmem.h>\n#include \"gup_test.h\"\n\nstatic void put_back_pages(unsigned int cmd, struct page **pages,\n\t\t\t   unsigned long nr_pages, unsigned int gup_test_flags)\n{\n\tunsigned long i;\n\n\tswitch (cmd) {\n\tcase GUP_FAST_BENCHMARK:\n\tcase GUP_BASIC_TEST:\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(pages[i]);\n\t\tbreak;\n\n\tcase PIN_FAST_BENCHMARK:\n\tcase PIN_BASIC_TEST:\n\tcase PIN_LONGTERM_BENCHMARK:\n\t\tunpin_user_pages(pages, nr_pages);\n\t\tbreak;\n\tcase DUMP_USER_PAGES_TEST:\n\t\tif (gup_test_flags & GUP_TEST_FLAG_DUMP_PAGES_USE_PIN) {\n\t\t\tunpin_user_pages(pages, nr_pages);\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(pages[i]);\n\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void verify_dma_pinned(unsigned int cmd, struct page **pages,\n\t\t\t      unsigned long nr_pages)\n{\n\tunsigned long i;\n\tstruct folio *folio;\n\n\tswitch (cmd) {\n\tcase PIN_FAST_BENCHMARK:\n\tcase PIN_BASIC_TEST:\n\tcase PIN_LONGTERM_BENCHMARK:\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tfolio = page_folio(pages[i]);\n\n\t\t\tif (WARN(!folio_maybe_dma_pinned(folio),\n\t\t\t\t \"pages[%lu] is NOT dma-pinned\\n\", i)) {\n\n\t\t\t\tdump_page(&folio->page, \"gup_test failure\");\n\t\t\t\tbreak;\n\t\t\t} else if (cmd == PIN_LONGTERM_BENCHMARK &&\n\t\t\t\tWARN(!folio_is_longterm_pinnable(folio),\n\t\t\t\t     \"pages[%lu] is NOT pinnable but pinned\\n\",\n\t\t\t\t     i)) {\n\t\t\t\tdump_page(&folio->page, \"gup_test failure\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void dump_pages_test(struct gup_test *gup, struct page **pages,\n\t\t\t    unsigned long nr_pages)\n{\n\tunsigned int index_to_dump;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < GUP_TEST_MAX_PAGES_TO_DUMP; i++) {\n\t\tif (gup->which_pages[i] > nr_pages) {\n\t\t\tpr_warn(\"ZEROING due to out of range: .which_pages[%u]: %u\\n\",\n\t\t\t\ti, gup->which_pages[i]);\n\t\t\tgup->which_pages[i] = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < GUP_TEST_MAX_PAGES_TO_DUMP; i++) {\n\t\tindex_to_dump = gup->which_pages[i];\n\n\t\tif (index_to_dump) {\n\t\t\tindex_to_dump--; \n\t\t\tpr_info(\"---- page #%u, starting from user virt addr: 0x%llx\\n\",\n\t\t\t\tindex_to_dump, gup->addr);\n\t\t\tdump_page(pages[index_to_dump],\n\t\t\t\t  \"gup_test: dump_pages() test\");\n\t\t}\n\t}\n}\n\nstatic int __gup_test_ioctl(unsigned int cmd,\n\t\tstruct gup_test *gup)\n{\n\tktime_t start_time, end_time;\n\tunsigned long i, nr_pages, addr, next;\n\tlong nr;\n\tstruct page **pages;\n\tint ret = 0;\n\tbool needs_mmap_lock =\n\t\tcmd != GUP_FAST_BENCHMARK && cmd != PIN_FAST_BENCHMARK;\n\n\tif (gup->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tnr_pages = gup->size / PAGE_SIZE;\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tif (needs_mmap_lock && mmap_read_lock_killable(current->mm)) {\n\t\tret = -EINTR;\n\t\tgoto free_pages;\n\t}\n\n\ti = 0;\n\tnr = gup->nr_pages_per_call;\n\tstart_time = ktime_get();\n\tfor (addr = gup->addr; addr < gup->addr + gup->size; addr = next) {\n\t\tif (nr != gup->nr_pages_per_call)\n\t\t\tbreak;\n\n\t\tnext = addr + nr * PAGE_SIZE;\n\t\tif (next > gup->addr + gup->size) {\n\t\t\tnext = gup->addr + gup->size;\n\t\t\tnr = (next - addr) / PAGE_SIZE;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase GUP_FAST_BENCHMARK:\n\t\t\tnr = get_user_pages_fast(addr, nr, gup->gup_flags,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase GUP_BASIC_TEST:\n\t\t\tnr = get_user_pages(addr, nr, gup->gup_flags, pages + i);\n\t\t\tbreak;\n\t\tcase PIN_FAST_BENCHMARK:\n\t\t\tnr = pin_user_pages_fast(addr, nr, gup->gup_flags,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase PIN_BASIC_TEST:\n\t\t\tnr = pin_user_pages(addr, nr, gup->gup_flags, pages + i);\n\t\t\tbreak;\n\t\tcase PIN_LONGTERM_BENCHMARK:\n\t\t\tnr = pin_user_pages(addr, nr,\n\t\t\t\t\t    gup->gup_flags | FOLL_LONGTERM,\n\t\t\t\t\t    pages + i);\n\t\t\tbreak;\n\t\tcase DUMP_USER_PAGES_TEST:\n\t\t\tif (gup->test_flags & GUP_TEST_FLAG_DUMP_PAGES_USE_PIN)\n\t\t\t\tnr = pin_user_pages(addr, nr, gup->gup_flags,\n\t\t\t\t\t\t    pages + i);\n\t\t\telse\n\t\t\t\tnr = get_user_pages(addr, nr, gup->gup_flags,\n\t\t\t\t\t\t    pages + i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (nr <= 0)\n\t\t\tbreak;\n\t\ti += nr;\n\t}\n\tend_time = ktime_get();\n\n\t \n\tnr_pages = i;\n\n\tgup->get_delta_usec = ktime_us_delta(end_time, start_time);\n\tgup->size = addr - gup->addr;\n\n\t \n\tverify_dma_pinned(cmd, pages, nr_pages);\n\n\tif (cmd == DUMP_USER_PAGES_TEST)\n\t\tdump_pages_test(gup, pages, nr_pages);\n\n\tstart_time = ktime_get();\n\n\tput_back_pages(cmd, pages, nr_pages, gup->test_flags);\n\n\tend_time = ktime_get();\n\tgup->put_delta_usec = ktime_us_delta(end_time, start_time);\n\nunlock:\n\tif (needs_mmap_lock)\n\t\tmmap_read_unlock(current->mm);\nfree_pages:\n\tkvfree(pages);\n\treturn ret;\n}\n\nstatic DEFINE_MUTEX(pin_longterm_test_mutex);\nstatic struct page **pin_longterm_test_pages;\nstatic unsigned long pin_longterm_test_nr_pages;\n\nstatic inline void pin_longterm_test_stop(void)\n{\n\tif (pin_longterm_test_pages) {\n\t\tif (pin_longterm_test_nr_pages)\n\t\t\tunpin_user_pages(pin_longterm_test_pages,\n\t\t\t\t\t pin_longterm_test_nr_pages);\n\t\tkvfree(pin_longterm_test_pages);\n\t\tpin_longterm_test_pages = NULL;\n\t\tpin_longterm_test_nr_pages = 0;\n\t}\n}\n\nstatic inline int pin_longterm_test_start(unsigned long arg)\n{\n\tlong nr_pages, cur_pages, addr, remaining_pages;\n\tint gup_flags = FOLL_LONGTERM;\n\tstruct pin_longterm_test args;\n\tstruct page **pages;\n\tint ret = 0;\n\tbool fast;\n\n\tif (pin_longterm_test_pages)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (void __user *)arg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tif (args.flags &\n\t    ~(PIN_LONGTERM_TEST_FLAG_USE_WRITE|PIN_LONGTERM_TEST_FLAG_USE_FAST))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(args.addr | args.size, PAGE_SIZE))\n\t\treturn -EINVAL;\n\tif (args.size > LONG_MAX)\n\t\treturn -EINVAL;\n\tnr_pages = args.size / PAGE_SIZE;\n\tif (!nr_pages)\n\t\treturn -EINVAL;\n\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tif (args.flags & PIN_LONGTERM_TEST_FLAG_USE_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\tfast = !!(args.flags & PIN_LONGTERM_TEST_FLAG_USE_FAST);\n\n\tif (!fast && mmap_read_lock_killable(current->mm)) {\n\t\tkvfree(pages);\n\t\treturn -EINTR;\n\t}\n\n\tpin_longterm_test_pages = pages;\n\tpin_longterm_test_nr_pages = 0;\n\n\twhile (nr_pages - pin_longterm_test_nr_pages) {\n\t\tremaining_pages = nr_pages - pin_longterm_test_nr_pages;\n\t\taddr = args.addr + pin_longterm_test_nr_pages * PAGE_SIZE;\n\n\t\tif (fast)\n\t\t\tcur_pages = pin_user_pages_fast(addr, remaining_pages,\n\t\t\t\t\t\t\tgup_flags, pages);\n\t\telse\n\t\t\tcur_pages = pin_user_pages(addr, remaining_pages,\n\t\t\t\t\t\t   gup_flags, pages);\n\t\tif (cur_pages < 0) {\n\t\t\tpin_longterm_test_stop();\n\t\t\tret = cur_pages;\n\t\t\tbreak;\n\t\t}\n\t\tpin_longterm_test_nr_pages += cur_pages;\n\t\tpages += cur_pages;\n\t}\n\n\tif (!fast)\n\t\tmmap_read_unlock(current->mm);\n\treturn ret;\n}\n\nstatic inline int pin_longterm_test_read(unsigned long arg)\n{\n\t__u64 user_addr;\n\tunsigned long i;\n\n\tif (!pin_longterm_test_pages)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&user_addr, (void __user *)arg, sizeof(user_addr)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < pin_longterm_test_nr_pages; i++) {\n\t\tvoid *addr = kmap_local_page(pin_longterm_test_pages[i]);\n\t\tunsigned long ret;\n\n\t\tret = copy_to_user((void __user *)(unsigned long)user_addr, addr,\n\t\t\t\t   PAGE_SIZE);\n\t\tkunmap_local(addr);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tuser_addr += PAGE_SIZE;\n\t}\n\treturn 0;\n}\n\nstatic long pin_longterm_test_ioctl(struct file *filep, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\tint ret = -EINVAL;\n\n\tif (mutex_lock_killable(&pin_longterm_test_mutex))\n\t\treturn -EINTR;\n\n\tswitch (cmd) {\n\tcase PIN_LONGTERM_TEST_START:\n\t\tret = pin_longterm_test_start(arg);\n\t\tbreak;\n\tcase PIN_LONGTERM_TEST_STOP:\n\t\tpin_longterm_test_stop();\n\t\tret = 0;\n\t\tbreak;\n\tcase PIN_LONGTERM_TEST_READ:\n\t\tret = pin_longterm_test_read(arg);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&pin_longterm_test_mutex);\n\treturn ret;\n}\n\nstatic long gup_test_ioctl(struct file *filep, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct gup_test gup;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase GUP_FAST_BENCHMARK:\n\tcase PIN_FAST_BENCHMARK:\n\tcase PIN_LONGTERM_BENCHMARK:\n\tcase GUP_BASIC_TEST:\n\tcase PIN_BASIC_TEST:\n\tcase DUMP_USER_PAGES_TEST:\n\t\tbreak;\n\tcase PIN_LONGTERM_TEST_START:\n\tcase PIN_LONGTERM_TEST_STOP:\n\tcase PIN_LONGTERM_TEST_READ:\n\t\treturn pin_longterm_test_ioctl(filep, cmd, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&gup, (void __user *)arg, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\tret = __gup_test_ioctl(cmd, &gup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user((void __user *)arg, &gup, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int gup_test_release(struct inode *inode, struct file *file)\n{\n\tpin_longterm_test_stop();\n\n\treturn 0;\n}\n\nstatic const struct file_operations gup_test_fops = {\n\t.open = nonseekable_open,\n\t.unlocked_ioctl = gup_test_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.release = gup_test_release,\n};\n\nstatic int __init gup_test_init(void)\n{\n\tdebugfs_create_file_unsafe(\"gup_test\", 0600, NULL, NULL,\n\t\t\t\t   &gup_test_fops);\n\n\treturn 0;\n}\n\nlate_initcall(gup_test_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}