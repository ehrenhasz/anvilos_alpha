{
  "module_name": "usercopy.c",
  "hash_id": "be0ab1b1e8e5fb51c4d708bd9d3f88eaf6b8ae606a464a473760bfca3af521fe",
  "original_prompt": "Ingested from linux-6.6.14/mm/usercopy.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/kstrtox.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/thread_info.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/jump_label.h>\n#include <asm/sections.h>\n#include \"slab.h\"\n\n \nstatic noinline int check_stack_object(const void *obj, unsigned long len)\n{\n\tconst void * const stack = task_stack_page(current);\n\tconst void * const stackend = stack + THREAD_SIZE;\n\tint ret;\n\n\t \n\tif (obj + len <= stack || stackend <= obj)\n\t\treturn NOT_STACK;\n\n\t \n\tif (obj < stack || stackend < obj + len)\n\t\treturn BAD_STACK;\n\n\t \n\tret = arch_within_stack_frames(stack, stackend, obj, len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER\n\tif (IS_ENABLED(CONFIG_STACK_GROWSUP)) {\n\t\tif ((void *)current_stack_pointer < obj + len)\n\t\t\treturn BAD_STACK;\n\t} else {\n\t\tif (obj < (void *)current_stack_pointer)\n\t\t\treturn BAD_STACK;\n\t}\n#endif\n\n\treturn GOOD_STACK;\n}\n\n \nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t \n\tBUG();\n}\n\n \nstatic bool overlaps(const unsigned long ptr, unsigned long n,\n\t\t     unsigned long low, unsigned long high)\n{\n\tconst unsigned long check_low = ptr;\n\tunsigned long check_high = check_low + n;\n\n\t \n\tif (check_low >= high || check_high <= low)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic inline void check_kernel_text_object(const unsigned long ptr,\n\t\t\t\t\t    unsigned long n, bool to_user)\n{\n\tunsigned long textlow = (unsigned long)_stext;\n\tunsigned long texthigh = (unsigned long)_etext;\n\tunsigned long textlow_linear, texthigh_linear;\n\n\tif (overlaps(ptr, n, textlow, texthigh))\n\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);\n\n\t \n\ttextlow_linear = (unsigned long)lm_alias(textlow);\n\t \n\tif (textlow_linear == textlow)\n\t\treturn;\n\n\t \n\ttexthigh_linear = (unsigned long)lm_alias(texthigh);\n\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))\n\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,\n\t\t\t       ptr - textlow_linear, n);\n}\n\nstatic inline void check_bogus_address(const unsigned long ptr, unsigned long n,\n\t\t\t\t       bool to_user)\n{\n\t \n\tif (ptr + (n - 1) < ptr)\n\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);\n\n\t \n\tif (ZERO_OR_NULL_PTR(ptr))\n\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);\n}\n\nstatic inline void check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t     bool to_user)\n{\n\tunsigned long addr = (unsigned long)ptr;\n\tunsigned long offset;\n\tstruct folio *folio;\n\n\tif (is_kmap_addr(ptr)) {\n\t\toffset = offset_in_page(ptr);\n\t\tif (n > PAGE_SIZE - offset)\n\t\t\tusercopy_abort(\"kmap\", NULL, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tif (is_vmalloc_addr(ptr) && !pagefault_disabled()) {\n\t\tstruct vmap_area *area = find_vmap_area(addr);\n\n\t\tif (!area)\n\t\t\tusercopy_abort(\"vmalloc\", \"no area\", to_user, 0, n);\n\n\t\tif (n > area->va_end - addr) {\n\t\t\toffset = addr - area->va_start;\n\t\t\tusercopy_abort(\"vmalloc\", NULL, to_user, offset, n);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!virt_addr_valid(ptr))\n\t\treturn;\n\n\tfolio = virt_to_folio(ptr);\n\n\tif (folio_test_slab(folio)) {\n\t\t \n\t\t__check_heap_object(ptr, n, folio_slab(folio), to_user);\n\t} else if (folio_test_large(folio)) {\n\t\toffset = ptr - folio_address(folio);\n\t\tif (n > folio_size(folio) - offset)\n\t\t\tusercopy_abort(\"page alloc\", NULL, to_user, offset, n);\n\t}\n}\n\nstatic DEFINE_STATIC_KEY_FALSE_RO(bypass_usercopy_checks);\n\n \nvoid __check_object_size(const void *ptr, unsigned long n, bool to_user)\n{\n\tif (static_branch_unlikely(&bypass_usercopy_checks))\n\t\treturn;\n\n\t \n\tif (!n)\n\t\treturn;\n\n\t \n\tcheck_bogus_address((const unsigned long)ptr, n, to_user);\n\n\t \n\tswitch (check_stack_object(ptr, n)) {\n\tcase NOT_STACK:\n\t\t \n\t\tbreak;\n\tcase GOOD_FRAME:\n\tcase GOOD_STACK:\n\t\t \n\t\treturn;\n\tdefault:\n\t\tusercopy_abort(\"process stack\", NULL, to_user,\n#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER\n\t\t\tIS_ENABLED(CONFIG_STACK_GROWSUP) ?\n\t\t\t\tptr - (void *)current_stack_pointer :\n\t\t\t\t(void *)current_stack_pointer - ptr,\n#else\n\t\t\t0,\n#endif\n\t\t\tn);\n\t}\n\n\t \n\tcheck_heap_object(ptr, n, to_user);\n\n\t \n\tcheck_kernel_text_object((const unsigned long)ptr, n, to_user);\n}\nEXPORT_SYMBOL(__check_object_size);\n\nstatic bool enable_checks __initdata = true;\n\nstatic int __init parse_hardened_usercopy(char *str)\n{\n\tif (kstrtobool(str, &enable_checks))\n\t\tpr_warn(\"Invalid option string for hardened_usercopy: '%s'\\n\",\n\t\t\tstr);\n\treturn 1;\n}\n\n__setup(\"hardened_usercopy=\", parse_hardened_usercopy);\n\nstatic int __init set_hardened_usercopy(void)\n{\n\tif (enable_checks == false)\n\t\tstatic_branch_enable(&bypass_usercopy_checks);\n\treturn 1;\n}\n\nlate_initcall(set_hardened_usercopy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}