{
  "module_name": "percpu-internal.h",
  "hash_id": "ee3f0f33893774eefe79675d94d0a4f8ed0de2e5f6811c91c73c05a4c637e585",
  "original_prompt": "Ingested from linux-6.6.14/mm/percpu-internal.h",
  "human_readable_source": " \n#ifndef _MM_PERCPU_INTERNAL_H\n#define _MM_PERCPU_INTERNAL_H\n\n#include <linux/types.h>\n#include <linux/percpu.h>\n#include <linux/memcontrol.h>\n\n \nstruct pcpu_block_md {\n\tint\t\t\tscan_hint;\t \n\tint\t\t\tscan_hint_start;  \n\tint                     contig_hint;     \n\tint                     contig_hint_start;  \n\tint                     left_free;       \n\tint                     right_free;      \n\tint                     first_free;      \n\tint\t\t\tnr_bits;\t \n};\n\nstruct pcpu_chunk {\n#ifdef CONFIG_PERCPU_STATS\n\tint\t\t\tnr_alloc;\t \n\tsize_t\t\t\tmax_alloc_size;  \n#endif\n\n\tstruct list_head\tlist;\t\t \n\tint\t\t\tfree_bytes;\t \n\tstruct pcpu_block_md\tchunk_md;\n\tunsigned long\t\t*bound_map;\t \n\n\t \n\tvoid\t\t\t*base_addr ____cacheline_aligned_in_smp;\n\n\tunsigned long\t\t*alloc_map;\t \n\tstruct pcpu_block_md\t*md_blocks;\t \n\n\tvoid\t\t\t*data;\t\t \n\tbool\t\t\timmutable;\t \n\tbool\t\t\tisolated;\t \n\tint\t\t\tstart_offset;\t \n\tint\t\t\tend_offset;\t \n#ifdef CONFIG_MEMCG_KMEM\n\tstruct obj_cgroup\t**obj_cgroups;\t \n#endif\n\n\tint\t\t\tnr_pages;\t \n\tint\t\t\tnr_populated;\t \n\tint                     nr_empty_pop_pages;  \n\tunsigned long\t\tpopulated[];\t \n};\n\nextern spinlock_t pcpu_lock;\n\nextern struct list_head *pcpu_chunk_lists;\nextern int pcpu_nr_slots;\nextern int pcpu_sidelined_slot;\nextern int pcpu_to_depopulate_slot;\nextern int pcpu_nr_empty_pop_pages;\n\nextern struct pcpu_chunk *pcpu_first_chunk;\nextern struct pcpu_chunk *pcpu_reserved_chunk;\n\n \nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}\n\n \nstatic inline int pcpu_nr_pages_to_map_bits(int pages)\n{\n\treturn pages * PAGE_SIZE / PCPU_MIN_ALLOC_SIZE;\n}\n\n \nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}\n\n \nstatic inline size_t pcpu_obj_full_size(size_t size)\n{\n\tsize_t extra_size = 0;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tif (!mem_cgroup_kmem_disabled())\n\t\textra_size += size / PCPU_MIN_ALLOC_SIZE * sizeof(struct obj_cgroup *);\n#endif\n\n\treturn size * num_possible_cpus() + extra_size;\n}\n\n#ifdef CONFIG_PERCPU_STATS\n\n#include <linux/spinlock.h>\n\nstruct percpu_stats {\n\tu64 nr_alloc;\t\t \n\tu64 nr_dealloc;\t\t \n\tu64 nr_cur_alloc;\t \n\tu64 nr_max_alloc;\t \n\tu32 nr_chunks;\t\t \n\tu32 nr_max_chunks;\t \n\tsize_t min_alloc_size;\t \n\tsize_t max_alloc_size;\t \n};\n\nextern struct percpu_stats pcpu_stats;\nextern struct pcpu_alloc_info pcpu_stats_ai;\n\n \nstatic inline void pcpu_stats_save_ai(const struct pcpu_alloc_info *ai)\n{\n\tmemcpy(&pcpu_stats_ai, ai, sizeof(struct pcpu_alloc_info));\n\n\t \n\tpcpu_stats.min_alloc_size = pcpu_stats_ai.unit_size;\n}\n\n \nstatic inline void pcpu_stats_area_alloc(struct pcpu_chunk *chunk, size_t size)\n{\n\tlockdep_assert_held(&pcpu_lock);\n\n\tpcpu_stats.nr_alloc++;\n\tpcpu_stats.nr_cur_alloc++;\n\tpcpu_stats.nr_max_alloc =\n\t\tmax(pcpu_stats.nr_max_alloc, pcpu_stats.nr_cur_alloc);\n\tpcpu_stats.min_alloc_size =\n\t\tmin(pcpu_stats.min_alloc_size, size);\n\tpcpu_stats.max_alloc_size =\n\t\tmax(pcpu_stats.max_alloc_size, size);\n\n\tchunk->nr_alloc++;\n\tchunk->max_alloc_size = max(chunk->max_alloc_size, size);\n}\n\n \nstatic inline void pcpu_stats_area_dealloc(struct pcpu_chunk *chunk)\n{\n\tlockdep_assert_held(&pcpu_lock);\n\n\tpcpu_stats.nr_dealloc++;\n\tpcpu_stats.nr_cur_alloc--;\n\n\tchunk->nr_alloc--;\n}\n\n \nstatic inline void pcpu_stats_chunk_alloc(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tpcpu_stats.nr_chunks++;\n\tpcpu_stats.nr_max_chunks =\n\t\tmax(pcpu_stats.nr_max_chunks, pcpu_stats.nr_chunks);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}\n\n \nstatic inline void pcpu_stats_chunk_dealloc(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tpcpu_stats.nr_chunks--;\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}\n\n#else\n\nstatic inline void pcpu_stats_save_ai(const struct pcpu_alloc_info *ai)\n{\n}\n\nstatic inline void pcpu_stats_area_alloc(struct pcpu_chunk *chunk, size_t size)\n{\n}\n\nstatic inline void pcpu_stats_area_dealloc(struct pcpu_chunk *chunk)\n{\n}\n\nstatic inline void pcpu_stats_chunk_alloc(void)\n{\n}\n\nstatic inline void pcpu_stats_chunk_dealloc(void)\n{\n}\n\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}