{
  "module_name": "maccess.c",
  "hash_id": "85fbf7727f3385e8ec182f1d64801db673d5e2f621ea059683e03855e1b0db3c",
  "original_prompt": "Ingested from linux-6.6.14/mm/maccess.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <asm/tlb.h>\n\nbool __weak copy_from_kernel_nofault_allowed(const void *unsafe_src,\n\t\tsize_t size)\n{\n\treturn true;\n}\n\n#define copy_from_kernel_nofault_loop(dst, src, len, type, err_label)\t\\\n\twhile (len >= sizeof(type)) {\t\t\t\t\t\\\n\t\t__get_kernel_nofault(dst, src, type, err_label);\t\t\\\n\t\tdst += sizeof(type);\t\t\t\t\t\\\n\t\tsrc += sizeof(type);\t\t\t\t\t\\\n\t\tlen -= sizeof(type);\t\t\t\t\t\\\n\t}\n\nlong copy_from_kernel_nofault(void *dst, const void *src, size_t size)\n{\n\tunsigned long align = 0;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\talign = (unsigned long)dst | (unsigned long)src;\n\n\tif (!copy_from_kernel_nofault_allowed(src, size))\n\t\treturn -ERANGE;\n\n\tpagefault_disable();\n\tif (!(align & 7))\n\t\tcopy_from_kernel_nofault_loop(dst, src, size, u64, Efault);\n\tif (!(align & 3))\n\t\tcopy_from_kernel_nofault_loop(dst, src, size, u32, Efault);\n\tif (!(align & 1))\n\t\tcopy_from_kernel_nofault_loop(dst, src, size, u16, Efault);\n\tcopy_from_kernel_nofault_loop(dst, src, size, u8, Efault);\n\tpagefault_enable();\n\treturn 0;\nEfault:\n\tpagefault_enable();\n\treturn -EFAULT;\n}\nEXPORT_SYMBOL_GPL(copy_from_kernel_nofault);\n\n#define copy_to_kernel_nofault_loop(dst, src, len, type, err_label)\t\\\n\twhile (len >= sizeof(type)) {\t\t\t\t\t\\\n\t\t__put_kernel_nofault(dst, src, type, err_label);\t\t\\\n\t\tdst += sizeof(type);\t\t\t\t\t\\\n\t\tsrc += sizeof(type);\t\t\t\t\t\\\n\t\tlen -= sizeof(type);\t\t\t\t\t\\\n\t}\n\nlong copy_to_kernel_nofault(void *dst, const void *src, size_t size)\n{\n\tunsigned long align = 0;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\talign = (unsigned long)dst | (unsigned long)src;\n\n\tpagefault_disable();\n\tif (!(align & 7))\n\t\tcopy_to_kernel_nofault_loop(dst, src, size, u64, Efault);\n\tif (!(align & 3))\n\t\tcopy_to_kernel_nofault_loop(dst, src, size, u32, Efault);\n\tif (!(align & 1))\n\t\tcopy_to_kernel_nofault_loop(dst, src, size, u16, Efault);\n\tcopy_to_kernel_nofault_loop(dst, src, size, u8, Efault);\n\tpagefault_enable();\n\treturn 0;\nEfault:\n\tpagefault_enable();\n\treturn -EFAULT;\n}\n\nlong strncpy_from_kernel_nofault(char *dst, const void *unsafe_addr, long count)\n{\n\tconst void *src = unsafe_addr;\n\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\tif (!copy_from_kernel_nofault_allowed(unsafe_addr, count))\n\t\treturn -ERANGE;\n\n\tpagefault_disable();\n\tdo {\n\t\t__get_kernel_nofault(dst, src, u8, Efault);\n\t\tdst++;\n\t\tsrc++;\n\t} while (dst[-1] && src - unsafe_addr < count);\n\tpagefault_enable();\n\n\tdst[-1] = '\\0';\n\treturn src - unsafe_addr;\nEfault:\n\tpagefault_enable();\n\tdst[0] = '\\0';\n\treturn -EFAULT;\n}\n\n \nlong copy_from_user_nofault(void *dst, const void __user *src, size_t size)\n{\n\tlong ret = -EFAULT;\n\n\tif (!__access_ok(src, size))\n\t\treturn ret;\n\n\tif (!nmi_uaccess_okay())\n\t\treturn ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, size);\n\tpagefault_enable();\n\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(copy_from_user_nofault);\n\n \nlong copy_to_user_nofault(void __user *dst, const void *src, size_t size)\n{\n\tlong ret = -EFAULT;\n\n\tif (access_ok(dst, size)) {\n\t\tpagefault_disable();\n\t\tret = __copy_to_user_inatomic(dst, src, size);\n\t\tpagefault_enable();\n\t}\n\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(copy_to_user_nofault);\n\n \nlong strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr,\n\t\t\t      long count)\n{\n\tlong ret;\n\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tpagefault_disable();\n\tret = strncpy_from_user(dst, unsafe_addr, count);\n\tpagefault_enable();\n\n\tif (ret >= count) {\n\t\tret = count;\n\t\tdst[ret - 1] = '\\0';\n\t} else if (ret > 0) {\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n \nlong strnlen_user_nofault(const void __user *unsafe_addr, long count)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = strnlen_user(unsafe_addr, count);\n\tpagefault_enable();\n\n\treturn ret;\n}\n\nvoid __copy_overflow(int size, unsigned long count)\n{\n\tWARN(1, \"Buffer overflow detected (%d < %lu)!\\n\", size, count);\n}\nEXPORT_SYMBOL(__copy_overflow);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}