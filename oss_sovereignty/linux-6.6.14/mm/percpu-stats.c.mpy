{
  "module_name": "percpu-stats.c",
  "hash_id": "833fc88872da10f1d20b1f6e46f84276235e6bd6f33c54273272bc8d41e2079f",
  "original_prompt": "Ingested from linux-6.6.14/mm/percpu-stats.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n\n#include \"percpu-internal.h\"\n\n#define P(X, Y) \\\n\tseq_printf(m, \"  %-20s: %12lld\\n\", X, (long long int)Y)\n\nstruct percpu_stats pcpu_stats;\nstruct pcpu_alloc_info pcpu_stats_ai;\n\nstatic int cmpint(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}\n\n \nstatic int find_max_nr_alloc(void)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\n\tmax_nr_alloc = 0;\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++)\n\t\tlist_for_each_entry(chunk, &pcpu_chunk_lists[slot], list)\n\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);\n\n\treturn max_nr_alloc;\n}\n\n \nstatic void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,\n\t\t\t    int *buffer)\n{\n\tstruct pcpu_block_md *chunk_md = &chunk->chunk_md;\n\tint i, last_alloc, as_len, start, end;\n\tint *alloc_sizes, *p;\n\t \n\tint sum_frag = 0, max_frag = 0;\n\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;\n\n\talloc_sizes = buffer;\n\n\t \n\tlast_alloc = find_last_bit(chunk->alloc_map,\n\t\t\t\t   pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);\n\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?\n\t\t     last_alloc + 1 : 0;\n\n\tas_len = 0;\n\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\n\t \n\twhile (start < last_alloc) {\n\t\tif (test_bit(start, chunk->alloc_map)) {\n\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = 1;\n\t\t} else {\n\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = -1;\n\t\t}\n\n\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;\n\n\t\tstart = end;\n\t}\n\n\t \n\tif (as_len > 0) {\n\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);\n\n\t\t \n\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {\n\t\t\tsum_frag -= *p;\n\t\t\tmax_frag = max(max_frag, -1 * (*p));\n\t\t}\n\n\t\tcur_min_alloc = alloc_sizes[i];\n\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];\n\t\tcur_max_alloc = alloc_sizes[as_len - 1];\n\t}\n\n\tP(\"nr_alloc\", chunk->nr_alloc);\n\tP(\"max_alloc_size\", chunk->max_alloc_size);\n\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);\n\tP(\"first_bit\", chunk_md->first_free);\n\tP(\"free_bytes\", chunk->free_bytes);\n\tP(\"contig_bytes\", chunk_md->contig_hint * PCPU_MIN_ALLOC_SIZE);\n\tP(\"sum_frag\", sum_frag);\n\tP(\"max_frag\", max_frag);\n\tP(\"cur_min_alloc\", cur_min_alloc);\n\tP(\"cur_med_alloc\", cur_med_alloc);\n\tP(\"cur_max_alloc\", cur_max_alloc);\n\tseq_putc(m, '\\n');\n}\n\nstatic int percpu_stats_show(struct seq_file *m, void *v)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\tint *buffer;\n\nalloc_buffer:\n\tspin_lock_irq(&pcpu_lock);\n\tmax_nr_alloc = find_max_nr_alloc();\n\tspin_unlock_irq(&pcpu_lock);\n\n\t \n\tbuffer = vmalloc_array(2 * max_nr_alloc + 1, sizeof(int));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pcpu_lock);\n\n\t \n\tif (max_nr_alloc < find_max_nr_alloc()) {\n\t\tspin_unlock_irq(&pcpu_lock);\n\t\tvfree(buffer);\n\t\tgoto alloc_buffer;\n\t}\n\n#define PL(X)\t\t\t\t\t\t\t\t\\\n\tseq_printf(m, \"  %-20s: %12lld\\n\", #X, (long long int)pcpu_stats_ai.X)\n\n\tseq_printf(m,\n\t\t\t\"Percpu Memory Statistics\\n\"\n\t\t\t\"Allocation Info:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPL(unit_size);\n\tPL(static_size);\n\tPL(reserved_size);\n\tPL(dyn_size);\n\tPL(atom_size);\n\tPL(alloc_size);\n\tseq_putc(m, '\\n');\n\n#undef PL\n\n#define PU(X) \\\n\tseq_printf(m, \"  %-20s: %12llu\\n\", #X, (unsigned long long)pcpu_stats.X)\n\n\tseq_printf(m,\n\t\t\t\"Global Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPU(nr_alloc);\n\tPU(nr_dealloc);\n\tPU(nr_cur_alloc);\n\tPU(nr_max_alloc);\n\tPU(nr_chunks);\n\tPU(nr_max_chunks);\n\tPU(min_alloc_size);\n\tPU(max_alloc_size);\n\tP(\"empty_pop_pages\", pcpu_nr_empty_pop_pages);\n\tseq_putc(m, '\\n');\n\n#undef PU\n\n\tseq_printf(m,\n\t\t\t\"Per Chunk Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\n\tif (pcpu_reserved_chunk) {\n\t\tseq_puts(m, \"Chunk: <- Reserved Chunk\\n\");\n\t\tchunk_map_stats(m, pcpu_reserved_chunk, buffer);\n\t}\n\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_chunk_lists[slot], list) {\n\t\t\tif (chunk == pcpu_first_chunk)\n\t\t\t\tseq_puts(m, \"Chunk: <- First Chunk\\n\");\n\t\t\telse if (slot == pcpu_to_depopulate_slot)\n\t\t\t\tseq_puts(m, \"Chunk (to_depopulate)\\n\");\n\t\t\telse if (slot == pcpu_sidelined_slot)\n\t\t\t\tseq_puts(m, \"Chunk (sidelined):\\n\");\n\t\t\telse\n\t\t\t\tseq_puts(m, \"Chunk:\\n\");\n\t\t\tchunk_map_stats(m, chunk, buffer);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&pcpu_lock);\n\n\tvfree(buffer);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(percpu_stats);\n\nstatic int __init init_percpu_stats_debugfs(void)\n{\n\tdebugfs_create_file(\"percpu_stats\", 0444, NULL, NULL,\n\t\t\t&percpu_stats_fops);\n\n\treturn 0;\n}\n\nlate_initcall(init_percpu_stats_debugfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}