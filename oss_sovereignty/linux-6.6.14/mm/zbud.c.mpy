{
  "module_name": "zbud.c",
  "hash_id": "9827cb2daab26d4d25a0db9a3fec7b2aa73af42742de469f3feb2b62ee68bdfd",
  "original_prompt": "Ingested from linux-6.6.14/mm/zbud.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/atomic.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/zpool.h>\n\n \n \n#define NCHUNKS_ORDER\t6\n\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstruct zbud_pool;\n\n \nstruct zbud_pool {\n\tspinlock_t lock;\n\tunion {\n\t\t \n\t\tstruct list_head buddied;\n\t\tstruct list_head unbuddied[NCHUNKS];\n\t};\n\tu64 pages_nr;\n};\n\n \nstruct zbud_header {\n\tstruct list_head buddy;\n\tunsigned int first_chunks;\n\tunsigned int last_chunks;\n};\n\n \n \nenum buddy {\n\tFIRST,\n\tLAST\n};\n\n \nstatic int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}\n\n#define for_each_unbuddied_list(_iter, _begin) \\\n\tfor ((_iter) = (_begin); (_iter) < NCHUNKS; (_iter)++)\n\n \nstatic struct zbud_header *init_zbud_page(struct page *page)\n{\n\tstruct zbud_header *zhdr = page_address(page);\n\tzhdr->first_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\treturn zhdr;\n}\n\n \nstatic void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}\n\n \nstatic unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t \n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t \n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse  \n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}\n\n \nstatic struct zbud_header *handle_to_zbud_header(unsigned long handle)\n{\n\treturn (struct zbud_header *)(handle & PAGE_MASK);\n}\n\n \nstatic int num_free_chunks(struct zbud_header *zhdr)\n{\n\t \n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}\n\n \n \nstatic struct zbud_pool *zbud_create_pool(gfp_t gfp)\n{\n\tstruct zbud_pool *pool;\n\tint i;\n\n\tpool = kzalloc(sizeof(struct zbud_pool), gfp);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tfor_each_unbuddied_list(i, 0)\n\t\tINIT_LIST_HEAD(&pool->unbuddied[i]);\n\tINIT_LIST_HEAD(&pool->buddied);\n\tpool->pages_nr = 0;\n\treturn pool;\n}\n\n \nstatic void zbud_destroy_pool(struct zbud_pool *pool)\n{\n\tkfree(pool);\n}\n\n \nstatic int zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks, i, freechunks;\n\tstruct zbud_header *zhdr = NULL;\n\tenum buddy bud;\n\tstruct page *page;\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\treturn -ENOSPC;\n\tchunks = size_to_chunks(size);\n\tspin_lock(&pool->lock);\n\n\t \n\tfor_each_unbuddied_list(i, chunks) {\n\t\tif (!list_empty(&pool->unbuddied[i])) {\n\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],\n\t\t\t\t\tstruct zbud_header, buddy);\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tif (zhdr->first_chunks == 0)\n\t\t\t\tbud = FIRST;\n\t\t\telse\n\t\t\t\tbud = LAST;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\tspin_unlock(&pool->lock);\n\tpage = alloc_page(gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tspin_lock(&pool->lock);\n\tpool->pages_nr++;\n\tzhdr = init_zbud_page(page);\n\tbud = FIRST;\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse\n\t\tzhdr->last_chunks = chunks;\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\n\t\t \n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t} else {\n\t\t \n\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t}\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\n\treturn 0;\n}\n\n \nstatic void zbud_free(struct zbud_pool *pool, unsigned long handle)\n{\n\tstruct zbud_header *zhdr;\n\tint freechunks;\n\n\tspin_lock(&pool->lock);\n\tzhdr = handle_to_zbud_header(handle);\n\n\t \n\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\n\t\tzhdr->last_chunks = 0;\n\telse\n\t\tzhdr->first_chunks = 0;\n\n\t \n\tlist_del(&zhdr->buddy);\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t \n\t\tfree_zbud_page(zhdr);\n\t\tpool->pages_nr--;\n\t} else {\n\t\t \n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t}\n\n\tspin_unlock(&pool->lock);\n}\n\n \nstatic void *zbud_map(struct zbud_pool *pool, unsigned long handle)\n{\n\treturn (void *)(handle);\n}\n\n \nstatic void zbud_unmap(struct zbud_pool *pool, unsigned long handle)\n{\n}\n\n \nstatic u64 zbud_get_pool_size(struct zbud_pool *pool)\n{\n\treturn pool->pages_nr;\n}\n\n \n\nstatic void *zbud_zpool_create(const char *name, gfp_t gfp)\n{\n\treturn zbud_create_pool(gfp);\n}\n\nstatic void zbud_zpool_destroy(void *pool)\n{\n\tzbud_destroy_pool(pool);\n}\n\nstatic int zbud_zpool_malloc(void *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn zbud_alloc(pool, size, gfp, handle);\n}\nstatic void zbud_zpool_free(void *pool, unsigned long handle)\n{\n\tzbud_free(pool, handle);\n}\n\nstatic void *zbud_zpool_map(void *pool, unsigned long handle,\n\t\t\tenum zpool_mapmode mm)\n{\n\treturn zbud_map(pool, handle);\n}\nstatic void zbud_zpool_unmap(void *pool, unsigned long handle)\n{\n\tzbud_unmap(pool, handle);\n}\n\nstatic u64 zbud_zpool_total_size(void *pool)\n{\n\treturn zbud_get_pool_size(pool) * PAGE_SIZE;\n}\n\nstatic struct zpool_driver zbud_zpool_driver = {\n\t.type =\t\t\"zbud\",\n\t.sleep_mapped = true,\n\t.owner =\tTHIS_MODULE,\n\t.create =\tzbud_zpool_create,\n\t.destroy =\tzbud_zpool_destroy,\n\t.malloc =\tzbud_zpool_malloc,\n\t.free =\t\tzbud_zpool_free,\n\t.map =\t\tzbud_zpool_map,\n\t.unmap =\tzbud_zpool_unmap,\n\t.total_size =\tzbud_zpool_total_size,\n};\n\nMODULE_ALIAS(\"zpool-zbud\");\n\nstatic int __init init_zbud(void)\n{\n\t \n\tBUILD_BUG_ON(sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED);\n\tpr_info(\"loaded\\n\");\n\n\tzpool_register_driver(&zbud_zpool_driver);\n\n\treturn 0;\n}\n\nstatic void __exit exit_zbud(void)\n{\n\tzpool_unregister_driver(&zbud_zpool_driver);\n\tpr_info(\"unloaded\\n\");\n}\n\nmodule_init(init_zbud);\nmodule_exit(exit_zbud);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Seth Jennings <sjennings@variantweb.net>\");\nMODULE_DESCRIPTION(\"Buddy Allocator for Compressed Pages\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}