{
  "module_name": "percpu-km.c",
  "hash_id": "a8907737fbd43e200f25c221df7a886fbcf328e36f20e02ad8a28f34f9fffa89",
  "original_prompt": "Ingested from linux-6.6.14/mm/percpu-km.c",
  "human_readable_source": "\n \n\n#if defined(CONFIG_SMP) && defined(CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK)\n#error \"contiguous percpu allocation is incompatible with paged first chunk\"\n#endif\n\n#include <linux/log2.h>\n\nstatic void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,\n\t\t\t\t      int page_start, int page_end)\n{\n\t \n}\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end)\n{\n\t \n}\n\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\tstruct pcpu_chunk *chunk;\n\tstruct page *pages;\n\tunsigned long flags;\n\tint i;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tpages = alloc_pages(gfp, order_base_2(nr_pages));\n\tif (!pages) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpcpu_set_page_chunk(nth_page(pages, i), chunk);\n\n\tchunk->data = pages;\n\tchunk->base_addr = page_address(pages);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\tpcpu_chunk_populated(chunk, 0, nr_pages);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\n\tif (!chunk)\n\t\treturn;\n\n\tpcpu_stats_chunk_dealloc();\n\ttrace_percpu_destroy_chunk(chunk->base_addr);\n\n\tif (chunk->data)\n\t\t__free_pages(chunk->data, order_base_2(nr_pages));\n\tpcpu_free_chunk(chunk);\n}\n\nstatic struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\n{\n\tsize_t nr_pages, alloc_pages;\n\n\t \n\tif (ai->nr_groups != 1) {\n\t\tpr_crit(\"can't handle more than one group\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_pages = (ai->groups[0].nr_units * ai->unit_size) >> PAGE_SHIFT;\n\talloc_pages = roundup_pow_of_two(nr_pages);\n\n\tif (alloc_pages > nr_pages)\n\t\tpr_warn(\"wasting %zu pages per chunk\\n\",\n\t\t\talloc_pages - nr_pages);\n\n\treturn 0;\n}\n\nstatic bool pcpu_should_reclaim_chunk(struct pcpu_chunk *chunk)\n{\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}