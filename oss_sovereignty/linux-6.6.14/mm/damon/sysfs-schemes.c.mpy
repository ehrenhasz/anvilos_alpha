{
  "module_name": "sysfs-schemes.c",
  "hash_id": "f13ffd9405b6a0223974cf05906d01801647302fe9582425be24ade5358031df",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/sysfs-schemes.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"sysfs-common.h\"\n\n \n\nstruct damon_sysfs_scheme_region {\n\tstruct kobject kobj;\n\tstruct damon_addr_range ar;\n\tunsigned int nr_accesses;\n\tunsigned int age;\n\tstruct list_head list;\n};\n\nstatic struct damon_sysfs_scheme_region *damon_sysfs_scheme_region_alloc(\n\t\tstruct damon_region *region)\n{\n\tstruct damon_sysfs_scheme_region *sysfs_region = kmalloc(\n\t\t\tsizeof(*sysfs_region), GFP_KERNEL);\n\n\tif (!sysfs_region)\n\t\treturn NULL;\n\tsysfs_region->kobj = (struct kobject){};\n\tsysfs_region->ar = region->ar;\n\tsysfs_region->nr_accesses = region->nr_accesses;\n\tsysfs_region->age = region->age;\n\tINIT_LIST_HEAD(&sysfs_region->list);\n\treturn sysfs_region;\n}\n\nstatic ssize_t start_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_scheme_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_region, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.start);\n}\n\nstatic ssize_t end_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_scheme_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_region, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.end);\n}\n\nstatic ssize_t nr_accesses_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_region, kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", region->nr_accesses);\n}\n\nstatic ssize_t age_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_scheme_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_region, kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", region->age);\n}\n\nstatic void damon_sysfs_scheme_region_release(struct kobject *kobj)\n{\n\tstruct damon_sysfs_scheme_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_region, kobj);\n\n\tlist_del(&region->list);\n\tkfree(region);\n}\n\nstatic struct kobj_attribute damon_sysfs_scheme_region_start_attr =\n\t\t__ATTR_RO_MODE(start, 0400);\n\nstatic struct kobj_attribute damon_sysfs_scheme_region_end_attr =\n\t\t__ATTR_RO_MODE(end, 0400);\n\nstatic struct kobj_attribute damon_sysfs_scheme_region_nr_accesses_attr =\n\t\t__ATTR_RO_MODE(nr_accesses, 0400);\n\nstatic struct kobj_attribute damon_sysfs_scheme_region_age_attr =\n\t\t__ATTR_RO_MODE(age, 0400);\n\nstatic struct attribute *damon_sysfs_scheme_region_attrs[] = {\n\t&damon_sysfs_scheme_region_start_attr.attr,\n\t&damon_sysfs_scheme_region_end_attr.attr,\n\t&damon_sysfs_scheme_region_nr_accesses_attr.attr,\n\t&damon_sysfs_scheme_region_age_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_scheme_region);\n\nstatic const struct kobj_type damon_sysfs_scheme_region_ktype = {\n\t.release = damon_sysfs_scheme_region_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_scheme_region_groups,\n};\n\n \n\nstruct damon_sysfs_scheme_regions {\n\tstruct kobject kobj;\n\tstruct list_head regions_list;\n\tint nr_regions;\n\tunsigned long total_bytes;\n};\n\nstatic struct damon_sysfs_scheme_regions *\ndamon_sysfs_scheme_regions_alloc(void)\n{\n\tstruct damon_sysfs_scheme_regions *regions = kmalloc(sizeof(*regions),\n\t\t\tGFP_KERNEL);\n\n\tif (!regions)\n\t\treturn NULL;\n\n\tregions->kobj = (struct kobject){};\n\tINIT_LIST_HEAD(&regions->regions_list);\n\tregions->nr_regions = 0;\n\tregions->total_bytes = 0;\n\treturn regions;\n}\n\nstatic ssize_t total_bytes_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_regions *regions = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_regions, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", regions->total_bytes);\n}\n\nstatic void damon_sysfs_scheme_regions_rm_dirs(\n\t\tstruct damon_sysfs_scheme_regions *regions)\n{\n\tstruct damon_sysfs_scheme_region *r, *next;\n\n\tlist_for_each_entry_safe(r, next, &regions->regions_list, list) {\n\t\t \n\t\tkobject_put(&r->kobj);\n\t\tregions->nr_regions--;\n\t}\n}\n\nstatic void damon_sysfs_scheme_regions_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_scheme_regions, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_scheme_regions_total_bytes_attr =\n\t\t__ATTR_RO_MODE(total_bytes, 0400);\n\nstatic struct attribute *damon_sysfs_scheme_regions_attrs[] = {\n\t&damon_sysfs_scheme_regions_total_bytes_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_scheme_regions);\n\nstatic const struct kobj_type damon_sysfs_scheme_regions_ktype = {\n\t.release = damon_sysfs_scheme_regions_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_scheme_regions_groups,\n};\n\n \n\nstruct damon_sysfs_stats {\n\tstruct kobject kobj;\n\tunsigned long nr_tried;\n\tunsigned long sz_tried;\n\tunsigned long nr_applied;\n\tunsigned long sz_applied;\n\tunsigned long qt_exceeds;\n};\n\nstatic struct damon_sysfs_stats *damon_sysfs_stats_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_stats), GFP_KERNEL);\n}\n\nstatic ssize_t nr_tried_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_stats *stats = container_of(kobj,\n\t\t\tstruct damon_sysfs_stats, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", stats->nr_tried);\n}\n\nstatic ssize_t sz_tried_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_stats *stats = container_of(kobj,\n\t\t\tstruct damon_sysfs_stats, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", stats->sz_tried);\n}\n\nstatic ssize_t nr_applied_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_stats *stats = container_of(kobj,\n\t\t\tstruct damon_sysfs_stats, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", stats->nr_applied);\n}\n\nstatic ssize_t sz_applied_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_stats *stats = container_of(kobj,\n\t\t\tstruct damon_sysfs_stats, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", stats->sz_applied);\n}\n\nstatic ssize_t qt_exceeds_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_stats *stats = container_of(kobj,\n\t\t\tstruct damon_sysfs_stats, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", stats->qt_exceeds);\n}\n\nstatic void damon_sysfs_stats_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_stats, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_stats_nr_tried_attr =\n\t\t__ATTR_RO_MODE(nr_tried, 0400);\n\nstatic struct kobj_attribute damon_sysfs_stats_sz_tried_attr =\n\t\t__ATTR_RO_MODE(sz_tried, 0400);\n\nstatic struct kobj_attribute damon_sysfs_stats_nr_applied_attr =\n\t\t__ATTR_RO_MODE(nr_applied, 0400);\n\nstatic struct kobj_attribute damon_sysfs_stats_sz_applied_attr =\n\t\t__ATTR_RO_MODE(sz_applied, 0400);\n\nstatic struct kobj_attribute damon_sysfs_stats_qt_exceeds_attr =\n\t\t__ATTR_RO_MODE(qt_exceeds, 0400);\n\nstatic struct attribute *damon_sysfs_stats_attrs[] = {\n\t&damon_sysfs_stats_nr_tried_attr.attr,\n\t&damon_sysfs_stats_sz_tried_attr.attr,\n\t&damon_sysfs_stats_nr_applied_attr.attr,\n\t&damon_sysfs_stats_sz_applied_attr.attr,\n\t&damon_sysfs_stats_qt_exceeds_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_stats);\n\nstatic const struct kobj_type damon_sysfs_stats_ktype = {\n\t.release = damon_sysfs_stats_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_stats_groups,\n};\n\n \n\nstruct damon_sysfs_scheme_filter {\n\tstruct kobject kobj;\n\tenum damos_filter_type type;\n\tbool matching;\n\tchar *memcg_path;\n\tstruct damon_addr_range addr_range;\n\tint target_idx;\n};\n\nstatic struct damon_sysfs_scheme_filter *damon_sysfs_scheme_filter_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_scheme_filter), GFP_KERNEL);\n}\n\n \nstatic const char * const damon_sysfs_scheme_filter_type_strs[] = {\n\t\"anon\",\n\t\"memcg\",\n\t\"addr\",\n\t\"target\",\n};\n\nstatic ssize_t type_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tdamon_sysfs_scheme_filter_type_strs[filter->type]);\n}\n\nstatic ssize_t type_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tenum damos_filter_type type;\n\tssize_t ret = -EINVAL;\n\n\tfor (type = 0; type < NR_DAMOS_FILTER_TYPES; type++) {\n\t\tif (sysfs_streq(buf, damon_sysfs_scheme_filter_type_strs[\n\t\t\t\t\ttype])) {\n\t\t\tfilter->type = type;\n\t\t\tret = count;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ssize_t matching_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%c\\n\", filter->matching ? 'Y' : 'N');\n}\n\nstatic ssize_t matching_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tbool matching;\n\tint err = kstrtobool(buf, &matching);\n\n\tif (err)\n\t\treturn err;\n\n\tfilter->matching = matching;\n\treturn count;\n}\n\nstatic ssize_t memcg_path_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tfilter->memcg_path ? filter->memcg_path : \"\");\n}\n\nstatic ssize_t memcg_path_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tchar *path = kmalloc(sizeof(*path) * (count + 1), GFP_KERNEL);\n\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tstrscpy(path, buf, count + 1);\n\tfilter->memcg_path = path;\n\treturn count;\n}\n\nstatic ssize_t addr_start_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", filter->addr_range.start);\n}\n\nstatic ssize_t addr_start_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tint err = kstrtoul(buf, 0, &filter->addr_range.start);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t addr_end_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", filter->addr_range.end);\n}\n\nstatic ssize_t addr_end_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tint err = kstrtoul(buf, 0, &filter->addr_range.end);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t damon_target_idx_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", filter->target_idx);\n}\n\nstatic ssize_t damon_target_idx_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\tint err = kstrtoint(buf, 0, &filter->target_idx);\n\n\treturn err ? err : count;\n}\n\nstatic void damon_sysfs_scheme_filter_release(struct kobject *kobj)\n{\n\tstruct damon_sysfs_scheme_filter *filter = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filter, kobj);\n\n\tkfree(filter->memcg_path);\n\tkfree(filter);\n}\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_type_attr =\n\t\t__ATTR_RW_MODE(type, 0600);\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_matching_attr =\n\t\t__ATTR_RW_MODE(matching, 0600);\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_memcg_path_attr =\n\t\t__ATTR_RW_MODE(memcg_path, 0600);\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_addr_start_attr =\n\t\t__ATTR_RW_MODE(addr_start, 0600);\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_addr_end_attr =\n\t\t__ATTR_RW_MODE(addr_end, 0600);\n\nstatic struct kobj_attribute damon_sysfs_scheme_filter_damon_target_idx_attr =\n\t\t__ATTR_RW_MODE(damon_target_idx, 0600);\n\nstatic struct attribute *damon_sysfs_scheme_filter_attrs[] = {\n\t&damon_sysfs_scheme_filter_type_attr.attr,\n\t&damon_sysfs_scheme_filter_matching_attr.attr,\n\t&damon_sysfs_scheme_filter_memcg_path_attr.attr,\n\t&damon_sysfs_scheme_filter_addr_start_attr.attr,\n\t&damon_sysfs_scheme_filter_addr_end_attr.attr,\n\t&damon_sysfs_scheme_filter_damon_target_idx_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_scheme_filter);\n\nstatic const struct kobj_type damon_sysfs_scheme_filter_ktype = {\n\t.release = damon_sysfs_scheme_filter_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_scheme_filter_groups,\n};\n\n \n\nstruct damon_sysfs_scheme_filters {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_scheme_filter **filters_arr;\n\tint nr;\n};\n\nstatic struct damon_sysfs_scheme_filters *\ndamon_sysfs_scheme_filters_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_scheme_filters), GFP_KERNEL);\n}\n\nstatic void damon_sysfs_scheme_filters_rm_dirs(\n\t\tstruct damon_sysfs_scheme_filters *filters)\n{\n\tstruct damon_sysfs_scheme_filter **filters_arr = filters->filters_arr;\n\tint i;\n\n\tfor (i = 0; i < filters->nr; i++)\n\t\tkobject_put(&filters_arr[i]->kobj);\n\tfilters->nr = 0;\n\tkfree(filters_arr);\n\tfilters->filters_arr = NULL;\n}\n\nstatic int damon_sysfs_scheme_filters_add_dirs(\n\t\tstruct damon_sysfs_scheme_filters *filters, int nr_filters)\n{\n\tstruct damon_sysfs_scheme_filter **filters_arr, *filter;\n\tint err, i;\n\n\tdamon_sysfs_scheme_filters_rm_dirs(filters);\n\tif (!nr_filters)\n\t\treturn 0;\n\n\tfilters_arr = kmalloc_array(nr_filters, sizeof(*filters_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!filters_arr)\n\t\treturn -ENOMEM;\n\tfilters->filters_arr = filters_arr;\n\n\tfor (i = 0; i < nr_filters; i++) {\n\t\tfilter = damon_sysfs_scheme_filter_alloc();\n\t\tif (!filter) {\n\t\t\tdamon_sysfs_scheme_filters_rm_dirs(filters);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&filter->kobj,\n\t\t\t\t&damon_sysfs_scheme_filter_ktype,\n\t\t\t\t&filters->kobj, \"%d\", i);\n\t\tif (err) {\n\t\t\tkobject_put(&filter->kobj);\n\t\t\tdamon_sysfs_scheme_filters_rm_dirs(filters);\n\t\t\treturn err;\n\t\t}\n\n\t\tfilters_arr[i] = filter;\n\t\tfilters->nr++;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t nr_filters_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_scheme_filters *filters = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme_filters, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", filters->nr);\n}\n\nstatic ssize_t nr_filters_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme_filters *filters;\n\tint nr, err = kstrtoint(buf, 0, &nr);\n\n\tif (err)\n\t\treturn err;\n\tif (nr < 0)\n\t\treturn -EINVAL;\n\n\tfilters = container_of(kobj, struct damon_sysfs_scheme_filters, kobj);\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_scheme_filters_add_dirs(filters, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic void damon_sysfs_scheme_filters_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_scheme_filters, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_scheme_filters_nr_attr =\n\t\t__ATTR_RW_MODE(nr_filters, 0600);\n\nstatic struct attribute *damon_sysfs_scheme_filters_attrs[] = {\n\t&damon_sysfs_scheme_filters_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_scheme_filters);\n\nstatic const struct kobj_type damon_sysfs_scheme_filters_ktype = {\n\t.release = damon_sysfs_scheme_filters_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_scheme_filters_groups,\n};\n\n \n\nstruct damon_sysfs_watermarks {\n\tstruct kobject kobj;\n\tenum damos_wmark_metric metric;\n\tunsigned long interval_us;\n\tunsigned long high;\n\tunsigned long mid;\n\tunsigned long low;\n};\n\nstatic struct damon_sysfs_watermarks *damon_sysfs_watermarks_alloc(\n\t\tenum damos_wmark_metric metric, unsigned long interval_us,\n\t\tunsigned long high, unsigned long mid, unsigned long low)\n{\n\tstruct damon_sysfs_watermarks *watermarks = kmalloc(\n\t\t\tsizeof(*watermarks), GFP_KERNEL);\n\n\tif (!watermarks)\n\t\treturn NULL;\n\twatermarks->kobj = (struct kobject){};\n\twatermarks->metric = metric;\n\twatermarks->interval_us = interval_us;\n\twatermarks->high = high;\n\twatermarks->mid = mid;\n\twatermarks->low = low;\n\treturn watermarks;\n}\n\n \nstatic const char * const damon_sysfs_wmark_metric_strs[] = {\n\t\"none\",\n\t\"free_mem_rate\",\n};\n\nstatic ssize_t metric_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tdamon_sysfs_wmark_metric_strs[watermarks->metric]);\n}\n\nstatic ssize_t metric_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\tenum damos_wmark_metric metric;\n\n\tfor (metric = 0; metric < NR_DAMOS_WMARK_METRICS; metric++) {\n\t\tif (sysfs_streq(buf, damon_sysfs_wmark_metric_strs[metric])) {\n\t\t\twatermarks->metric = metric;\n\t\t\treturn count;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t interval_us_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", watermarks->interval_us);\n}\n\nstatic ssize_t interval_us_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\tint err = kstrtoul(buf, 0, &watermarks->interval_us);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t high_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", watermarks->high);\n}\n\nstatic ssize_t high_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\tint err = kstrtoul(buf, 0, &watermarks->high);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t mid_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", watermarks->mid);\n}\n\nstatic ssize_t mid_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\tint err = kstrtoul(buf, 0, &watermarks->mid);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t low_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", watermarks->low);\n}\n\nstatic ssize_t low_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_watermarks *watermarks = container_of(kobj,\n\t\t\tstruct damon_sysfs_watermarks, kobj);\n\tint err = kstrtoul(buf, 0, &watermarks->low);\n\n\treturn err ? err : count;\n}\n\nstatic void damon_sysfs_watermarks_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_watermarks, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_watermarks_metric_attr =\n\t\t__ATTR_RW_MODE(metric, 0600);\n\nstatic struct kobj_attribute damon_sysfs_watermarks_interval_us_attr =\n\t\t__ATTR_RW_MODE(interval_us, 0600);\n\nstatic struct kobj_attribute damon_sysfs_watermarks_high_attr =\n\t\t__ATTR_RW_MODE(high, 0600);\n\nstatic struct kobj_attribute damon_sysfs_watermarks_mid_attr =\n\t\t__ATTR_RW_MODE(mid, 0600);\n\nstatic struct kobj_attribute damon_sysfs_watermarks_low_attr =\n\t\t__ATTR_RW_MODE(low, 0600);\n\nstatic struct attribute *damon_sysfs_watermarks_attrs[] = {\n\t&damon_sysfs_watermarks_metric_attr.attr,\n\t&damon_sysfs_watermarks_interval_us_attr.attr,\n\t&damon_sysfs_watermarks_high_attr.attr,\n\t&damon_sysfs_watermarks_mid_attr.attr,\n\t&damon_sysfs_watermarks_low_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_watermarks);\n\nstatic const struct kobj_type damon_sysfs_watermarks_ktype = {\n\t.release = damon_sysfs_watermarks_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_watermarks_groups,\n};\n\n \n\nstruct damon_sysfs_weights {\n\tstruct kobject kobj;\n\tunsigned int sz;\n\tunsigned int nr_accesses;\n\tunsigned int age;\n};\n\nstatic struct damon_sysfs_weights *damon_sysfs_weights_alloc(unsigned int sz,\n\t\tunsigned int nr_accesses, unsigned int age)\n{\n\tstruct damon_sysfs_weights *weights = kmalloc(sizeof(*weights),\n\t\t\tGFP_KERNEL);\n\n\tif (!weights)\n\t\treturn NULL;\n\tweights->kobj = (struct kobject){};\n\tweights->sz = sz;\n\tweights->nr_accesses = nr_accesses;\n\tweights->age = age;\n\treturn weights;\n}\n\nstatic ssize_t sz_permil_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", weights->sz);\n}\n\nstatic ssize_t sz_permil_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\tint err = kstrtouint(buf, 0, &weights->sz);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t nr_accesses_permil_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", weights->nr_accesses);\n}\n\nstatic ssize_t nr_accesses_permil_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\tint err = kstrtouint(buf, 0, &weights->nr_accesses);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t age_permil_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", weights->age);\n}\n\nstatic ssize_t age_permil_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_weights *weights = container_of(kobj,\n\t\t\tstruct damon_sysfs_weights, kobj);\n\tint err = kstrtouint(buf, 0, &weights->age);\n\n\treturn err ? err : count;\n}\n\nstatic void damon_sysfs_weights_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_weights, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_weights_sz_attr =\n\t\t__ATTR_RW_MODE(sz_permil, 0600);\n\nstatic struct kobj_attribute damon_sysfs_weights_nr_accesses_attr =\n\t\t__ATTR_RW_MODE(nr_accesses_permil, 0600);\n\nstatic struct kobj_attribute damon_sysfs_weights_age_attr =\n\t\t__ATTR_RW_MODE(age_permil, 0600);\n\nstatic struct attribute *damon_sysfs_weights_attrs[] = {\n\t&damon_sysfs_weights_sz_attr.attr,\n\t&damon_sysfs_weights_nr_accesses_attr.attr,\n\t&damon_sysfs_weights_age_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_weights);\n\nstatic const struct kobj_type damon_sysfs_weights_ktype = {\n\t.release = damon_sysfs_weights_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_weights_groups,\n};\n\n \n\nstruct damon_sysfs_quotas {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_weights *weights;\n\tunsigned long ms;\n\tunsigned long sz;\n\tunsigned long reset_interval_ms;\n};\n\nstatic struct damon_sysfs_quotas *damon_sysfs_quotas_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_quotas), GFP_KERNEL);\n}\n\nstatic int damon_sysfs_quotas_add_dirs(struct damon_sysfs_quotas *quotas)\n{\n\tstruct damon_sysfs_weights *weights;\n\tint err;\n\n\tweights = damon_sysfs_weights_alloc(0, 0, 0);\n\tif (!weights)\n\t\treturn -ENOMEM;\n\n\terr = kobject_init_and_add(&weights->kobj, &damon_sysfs_weights_ktype,\n\t\t\t&quotas->kobj, \"weights\");\n\tif (err)\n\t\tkobject_put(&weights->kobj);\n\telse\n\t\tquotas->weights = weights;\n\treturn err;\n}\n\nstatic void damon_sysfs_quotas_rm_dirs(struct damon_sysfs_quotas *quotas)\n{\n\tkobject_put(&quotas->weights->kobj);\n}\n\nstatic ssize_t ms_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", quotas->ms);\n}\n\nstatic ssize_t ms_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\tint err = kstrtoul(buf, 0, &quotas->ms);\n\n\tif (err)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic ssize_t bytes_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", quotas->sz);\n}\n\nstatic ssize_t bytes_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\tint err = kstrtoul(buf, 0, &quotas->sz);\n\n\tif (err)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic ssize_t reset_interval_ms_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", quotas->reset_interval_ms);\n}\n\nstatic ssize_t reset_interval_ms_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_quotas *quotas = container_of(kobj,\n\t\t\tstruct damon_sysfs_quotas, kobj);\n\tint err = kstrtoul(buf, 0, &quotas->reset_interval_ms);\n\n\tif (err)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic void damon_sysfs_quotas_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_quotas, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_quotas_ms_attr =\n\t\t__ATTR_RW_MODE(ms, 0600);\n\nstatic struct kobj_attribute damon_sysfs_quotas_sz_attr =\n\t\t__ATTR_RW_MODE(bytes, 0600);\n\nstatic struct kobj_attribute damon_sysfs_quotas_reset_interval_ms_attr =\n\t\t__ATTR_RW_MODE(reset_interval_ms, 0600);\n\nstatic struct attribute *damon_sysfs_quotas_attrs[] = {\n\t&damon_sysfs_quotas_ms_attr.attr,\n\t&damon_sysfs_quotas_sz_attr.attr,\n\t&damon_sysfs_quotas_reset_interval_ms_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_quotas);\n\nstatic const struct kobj_type damon_sysfs_quotas_ktype = {\n\t.release = damon_sysfs_quotas_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_quotas_groups,\n};\n\n \n\nstruct damon_sysfs_access_pattern {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_ul_range *sz;\n\tstruct damon_sysfs_ul_range *nr_accesses;\n\tstruct damon_sysfs_ul_range *age;\n};\n\nstatic\nstruct damon_sysfs_access_pattern *damon_sysfs_access_pattern_alloc(void)\n{\n\tstruct damon_sysfs_access_pattern *access_pattern =\n\t\tkmalloc(sizeof(*access_pattern), GFP_KERNEL);\n\n\tif (!access_pattern)\n\t\treturn NULL;\n\taccess_pattern->kobj = (struct kobject){};\n\treturn access_pattern;\n}\n\nstatic int damon_sysfs_access_pattern_add_range_dir(\n\t\tstruct damon_sysfs_access_pattern *access_pattern,\n\t\tstruct damon_sysfs_ul_range **range_dir_ptr,\n\t\tchar *name)\n{\n\tstruct damon_sysfs_ul_range *range = damon_sysfs_ul_range_alloc(0, 0);\n\tint err;\n\n\tif (!range)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&range->kobj, &damon_sysfs_ul_range_ktype,\n\t\t\t&access_pattern->kobj, name);\n\tif (err)\n\t\tkobject_put(&range->kobj);\n\telse\n\t\t*range_dir_ptr = range;\n\treturn err;\n}\n\nstatic int damon_sysfs_access_pattern_add_dirs(\n\t\tstruct damon_sysfs_access_pattern *access_pattern)\n{\n\tint err;\n\n\terr = damon_sysfs_access_pattern_add_range_dir(access_pattern,\n\t\t\t&access_pattern->sz, \"sz\");\n\tif (err)\n\t\tgoto put_sz_out;\n\n\terr = damon_sysfs_access_pattern_add_range_dir(access_pattern,\n\t\t\t&access_pattern->nr_accesses, \"nr_accesses\");\n\tif (err)\n\t\tgoto put_nr_accesses_sz_out;\n\n\terr = damon_sysfs_access_pattern_add_range_dir(access_pattern,\n\t\t\t&access_pattern->age, \"age\");\n\tif (err)\n\t\tgoto put_age_nr_accesses_sz_out;\n\treturn 0;\n\nput_age_nr_accesses_sz_out:\n\tkobject_put(&access_pattern->age->kobj);\n\taccess_pattern->age = NULL;\nput_nr_accesses_sz_out:\n\tkobject_put(&access_pattern->nr_accesses->kobj);\n\taccess_pattern->nr_accesses = NULL;\nput_sz_out:\n\tkobject_put(&access_pattern->sz->kobj);\n\taccess_pattern->sz = NULL;\n\treturn err;\n}\n\nstatic void damon_sysfs_access_pattern_rm_dirs(\n\t\tstruct damon_sysfs_access_pattern *access_pattern)\n{\n\tkobject_put(&access_pattern->sz->kobj);\n\tkobject_put(&access_pattern->nr_accesses->kobj);\n\tkobject_put(&access_pattern->age->kobj);\n}\n\nstatic void damon_sysfs_access_pattern_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_access_pattern, kobj));\n}\n\nstatic struct attribute *damon_sysfs_access_pattern_attrs[] = {\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_access_pattern);\n\nstatic const struct kobj_type damon_sysfs_access_pattern_ktype = {\n\t.release = damon_sysfs_access_pattern_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_access_pattern_groups,\n};\n\n \n\nstruct damon_sysfs_scheme {\n\tstruct kobject kobj;\n\tenum damos_action action;\n\tstruct damon_sysfs_access_pattern *access_pattern;\n\tstruct damon_sysfs_quotas *quotas;\n\tstruct damon_sysfs_watermarks *watermarks;\n\tstruct damon_sysfs_scheme_filters *filters;\n\tstruct damon_sysfs_stats *stats;\n\tstruct damon_sysfs_scheme_regions *tried_regions;\n};\n\n \nstatic const char * const damon_sysfs_damos_action_strs[] = {\n\t\"willneed\",\n\t\"cold\",\n\t\"pageout\",\n\t\"hugepage\",\n\t\"nohugepage\",\n\t\"lru_prio\",\n\t\"lru_deprio\",\n\t\"stat\",\n};\n\nstatic struct damon_sysfs_scheme *damon_sysfs_scheme_alloc(\n\t\tenum damos_action action)\n{\n\tstruct damon_sysfs_scheme *scheme = kmalloc(sizeof(*scheme),\n\t\t\t\tGFP_KERNEL);\n\n\tif (!scheme)\n\t\treturn NULL;\n\tscheme->kobj = (struct kobject){};\n\tscheme->action = action;\n\treturn scheme;\n}\n\nstatic int damon_sysfs_scheme_set_access_pattern(\n\t\tstruct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_access_pattern *access_pattern;\n\tint err;\n\n\taccess_pattern = damon_sysfs_access_pattern_alloc();\n\tif (!access_pattern)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&access_pattern->kobj,\n\t\t\t&damon_sysfs_access_pattern_ktype, &scheme->kobj,\n\t\t\t\"access_pattern\");\n\tif (err)\n\t\tgoto out;\n\terr = damon_sysfs_access_pattern_add_dirs(access_pattern);\n\tif (err)\n\t\tgoto out;\n\tscheme->access_pattern = access_pattern;\n\treturn 0;\n\nout:\n\tkobject_put(&access_pattern->kobj);\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_set_quotas(struct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_quotas *quotas = damon_sysfs_quotas_alloc();\n\tint err;\n\n\tif (!quotas)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&quotas->kobj, &damon_sysfs_quotas_ktype,\n\t\t\t&scheme->kobj, \"quotas\");\n\tif (err)\n\t\tgoto out;\n\terr = damon_sysfs_quotas_add_dirs(quotas);\n\tif (err)\n\t\tgoto out;\n\tscheme->quotas = quotas;\n\treturn 0;\n\nout:\n\tkobject_put(&quotas->kobj);\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_set_watermarks(struct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_watermarks *watermarks =\n\t\tdamon_sysfs_watermarks_alloc(DAMOS_WMARK_NONE, 0, 0, 0, 0);\n\tint err;\n\n\tif (!watermarks)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&watermarks->kobj,\n\t\t\t&damon_sysfs_watermarks_ktype, &scheme->kobj,\n\t\t\t\"watermarks\");\n\tif (err)\n\t\tkobject_put(&watermarks->kobj);\n\telse\n\t\tscheme->watermarks = watermarks;\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_set_filters(struct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_scheme_filters *filters =\n\t\tdamon_sysfs_scheme_filters_alloc();\n\tint err;\n\n\tif (!filters)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&filters->kobj,\n\t\t\t&damon_sysfs_scheme_filters_ktype, &scheme->kobj,\n\t\t\t\"filters\");\n\tif (err)\n\t\tkobject_put(&filters->kobj);\n\telse\n\t\tscheme->filters = filters;\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_set_stats(struct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_stats *stats = damon_sysfs_stats_alloc();\n\tint err;\n\n\tif (!stats)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&stats->kobj, &damon_sysfs_stats_ktype,\n\t\t\t&scheme->kobj, \"stats\");\n\tif (err)\n\t\tkobject_put(&stats->kobj);\n\telse\n\t\tscheme->stats = stats;\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_set_tried_regions(\n\t\tstruct damon_sysfs_scheme *scheme)\n{\n\tstruct damon_sysfs_scheme_regions *tried_regions =\n\t\tdamon_sysfs_scheme_regions_alloc();\n\tint err;\n\n\tif (!tried_regions)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&tried_regions->kobj,\n\t\t\t&damon_sysfs_scheme_regions_ktype, &scheme->kobj,\n\t\t\t\"tried_regions\");\n\tif (err)\n\t\tkobject_put(&tried_regions->kobj);\n\telse\n\t\tscheme->tried_regions = tried_regions;\n\treturn err;\n}\n\nstatic int damon_sysfs_scheme_add_dirs(struct damon_sysfs_scheme *scheme)\n{\n\tint err;\n\n\terr = damon_sysfs_scheme_set_access_pattern(scheme);\n\tif (err)\n\t\treturn err;\n\terr = damon_sysfs_scheme_set_quotas(scheme);\n\tif (err)\n\t\tgoto put_access_pattern_out;\n\terr = damon_sysfs_scheme_set_watermarks(scheme);\n\tif (err)\n\t\tgoto put_quotas_access_pattern_out;\n\terr = damon_sysfs_scheme_set_filters(scheme);\n\tif (err)\n\t\tgoto put_watermarks_quotas_access_pattern_out;\n\terr = damon_sysfs_scheme_set_stats(scheme);\n\tif (err)\n\t\tgoto put_filters_watermarks_quotas_access_pattern_out;\n\terr = damon_sysfs_scheme_set_tried_regions(scheme);\n\tif (err)\n\t\tgoto put_tried_regions_out;\n\treturn 0;\n\nput_tried_regions_out:\n\tkobject_put(&scheme->tried_regions->kobj);\n\tscheme->tried_regions = NULL;\nput_filters_watermarks_quotas_access_pattern_out:\n\tkobject_put(&scheme->filters->kobj);\n\tscheme->filters = NULL;\nput_watermarks_quotas_access_pattern_out:\n\tkobject_put(&scheme->watermarks->kobj);\n\tscheme->watermarks = NULL;\nput_quotas_access_pattern_out:\n\tkobject_put(&scheme->quotas->kobj);\n\tscheme->quotas = NULL;\nput_access_pattern_out:\n\tkobject_put(&scheme->access_pattern->kobj);\n\tscheme->access_pattern = NULL;\n\treturn err;\n}\n\nstatic void damon_sysfs_scheme_rm_dirs(struct damon_sysfs_scheme *scheme)\n{\n\tdamon_sysfs_access_pattern_rm_dirs(scheme->access_pattern);\n\tkobject_put(&scheme->access_pattern->kobj);\n\tdamon_sysfs_quotas_rm_dirs(scheme->quotas);\n\tkobject_put(&scheme->quotas->kobj);\n\tkobject_put(&scheme->watermarks->kobj);\n\tdamon_sysfs_scheme_filters_rm_dirs(scheme->filters);\n\tkobject_put(&scheme->filters->kobj);\n\tkobject_put(&scheme->stats->kobj);\n\tdamon_sysfs_scheme_regions_rm_dirs(scheme->tried_regions);\n\tkobject_put(&scheme->tried_regions->kobj);\n}\n\nstatic ssize_t action_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_scheme *scheme = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme, kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tdamon_sysfs_damos_action_strs[scheme->action]);\n}\n\nstatic ssize_t action_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_scheme *scheme = container_of(kobj,\n\t\t\tstruct damon_sysfs_scheme, kobj);\n\tenum damos_action action;\n\n\tfor (action = 0; action < NR_DAMOS_ACTIONS; action++) {\n\t\tif (sysfs_streq(buf, damon_sysfs_damos_action_strs[action])) {\n\t\t\tscheme->action = action;\n\t\t\treturn count;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic void damon_sysfs_scheme_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_scheme, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_scheme_action_attr =\n\t\t__ATTR_RW_MODE(action, 0600);\n\nstatic struct attribute *damon_sysfs_scheme_attrs[] = {\n\t&damon_sysfs_scheme_action_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_scheme);\n\nstatic const struct kobj_type damon_sysfs_scheme_ktype = {\n\t.release = damon_sysfs_scheme_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_scheme_groups,\n};\n\n \n\nstruct damon_sysfs_schemes *damon_sysfs_schemes_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_schemes), GFP_KERNEL);\n}\n\nvoid damon_sysfs_schemes_rm_dirs(struct damon_sysfs_schemes *schemes)\n{\n\tstruct damon_sysfs_scheme **schemes_arr = schemes->schemes_arr;\n\tint i;\n\n\tfor (i = 0; i < schemes->nr; i++) {\n\t\tdamon_sysfs_scheme_rm_dirs(schemes_arr[i]);\n\t\tkobject_put(&schemes_arr[i]->kobj);\n\t}\n\tschemes->nr = 0;\n\tkfree(schemes_arr);\n\tschemes->schemes_arr = NULL;\n}\n\nstatic int damon_sysfs_schemes_add_dirs(struct damon_sysfs_schemes *schemes,\n\t\tint nr_schemes)\n{\n\tstruct damon_sysfs_scheme **schemes_arr, *scheme;\n\tint err, i;\n\n\tdamon_sysfs_schemes_rm_dirs(schemes);\n\tif (!nr_schemes)\n\t\treturn 0;\n\n\tschemes_arr = kmalloc_array(nr_schemes, sizeof(*schemes_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!schemes_arr)\n\t\treturn -ENOMEM;\n\tschemes->schemes_arr = schemes_arr;\n\n\tfor (i = 0; i < nr_schemes; i++) {\n\t\tscheme = damon_sysfs_scheme_alloc(DAMOS_STAT);\n\t\tif (!scheme) {\n\t\t\tdamon_sysfs_schemes_rm_dirs(schemes);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&scheme->kobj,\n\t\t\t\t&damon_sysfs_scheme_ktype, &schemes->kobj,\n\t\t\t\t\"%d\", i);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = damon_sysfs_scheme_add_dirs(scheme);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tschemes_arr[i] = scheme;\n\t\tschemes->nr++;\n\t}\n\treturn 0;\n\nout:\n\tdamon_sysfs_schemes_rm_dirs(schemes);\n\tkobject_put(&scheme->kobj);\n\treturn err;\n}\n\nstatic ssize_t nr_schemes_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_schemes *schemes = container_of(kobj,\n\t\t\tstruct damon_sysfs_schemes, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", schemes->nr);\n}\n\nstatic ssize_t nr_schemes_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_schemes *schemes;\n\tint nr, err = kstrtoint(buf, 0, &nr);\n\n\tif (err)\n\t\treturn err;\n\tif (nr < 0)\n\t\treturn -EINVAL;\n\n\tschemes = container_of(kobj, struct damon_sysfs_schemes, kobj);\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_schemes_add_dirs(schemes, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\treturn count;\n}\n\nstatic void damon_sysfs_schemes_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_schemes, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_schemes_nr_attr =\n\t\t__ATTR_RW_MODE(nr_schemes, 0600);\n\nstatic struct attribute *damon_sysfs_schemes_attrs[] = {\n\t&damon_sysfs_schemes_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_schemes);\n\nconst struct kobj_type damon_sysfs_schemes_ktype = {\n\t.release = damon_sysfs_schemes_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_schemes_groups,\n};\n\nstatic bool damon_sysfs_memcg_path_eq(struct mem_cgroup *memcg,\n\t\tchar *memcg_path_buf, char *path)\n{\n#ifdef CONFIG_MEMCG\n\tcgroup_path(memcg->css.cgroup, memcg_path_buf, PATH_MAX);\n\tif (sysfs_streq(memcg_path_buf, path))\n\t\treturn true;\n#endif  \n\treturn false;\n}\n\nstatic int damon_sysfs_memcg_path_to_id(char *memcg_path, unsigned short *id)\n{\n\tstruct mem_cgroup *memcg;\n\tchar *path;\n\tbool found = false;\n\n\tif (!memcg_path)\n\t\treturn -EINVAL;\n\n\tpath = kmalloc(sizeof(*path) * PATH_MAX, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfor (memcg = mem_cgroup_iter(NULL, NULL, NULL); memcg;\n\t\t\tmemcg = mem_cgroup_iter(NULL, memcg, NULL)) {\n\t\t \n\t\tif (!mem_cgroup_id(memcg))\n\t\t\tcontinue;\n\t\tif (damon_sysfs_memcg_path_eq(memcg, path, memcg_path)) {\n\t\t\t*id = mem_cgroup_id(memcg);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(path);\n\treturn found ? 0 : -EINVAL;\n}\n\nstatic int damon_sysfs_set_scheme_filters(struct damos *scheme,\n\t\tstruct damon_sysfs_scheme_filters *sysfs_filters)\n{\n\tint i;\n\tstruct damos_filter *filter, *next;\n\n\tdamos_for_each_filter_safe(filter, next, scheme)\n\t\tdamos_destroy_filter(filter);\n\n\tfor (i = 0; i < sysfs_filters->nr; i++) {\n\t\tstruct damon_sysfs_scheme_filter *sysfs_filter =\n\t\t\tsysfs_filters->filters_arr[i];\n\t\tstruct damos_filter *filter =\n\t\t\tdamos_new_filter(sysfs_filter->type,\n\t\t\t\t\tsysfs_filter->matching);\n\t\tint err;\n\n\t\tif (!filter)\n\t\t\treturn -ENOMEM;\n\t\tif (filter->type == DAMOS_FILTER_TYPE_MEMCG) {\n\t\t\terr = damon_sysfs_memcg_path_to_id(\n\t\t\t\t\tsysfs_filter->memcg_path,\n\t\t\t\t\t&filter->memcg_id);\n\t\t\tif (err) {\n\t\t\t\tdamos_destroy_filter(filter);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (filter->type == DAMOS_FILTER_TYPE_ADDR) {\n\t\t\tif (sysfs_filter->addr_range.end <\n\t\t\t\t\tsysfs_filter->addr_range.start) {\n\t\t\t\tdamos_destroy_filter(filter);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfilter->addr_range = sysfs_filter->addr_range;\n\t\t} else if (filter->type == DAMOS_FILTER_TYPE_TARGET) {\n\t\t\tfilter->target_idx = sysfs_filter->target_idx;\n\t\t}\n\n\t\tdamos_add_filter(scheme, filter);\n\t}\n\treturn 0;\n}\n\nstatic struct damos *damon_sysfs_mk_scheme(\n\t\tstruct damon_sysfs_scheme *sysfs_scheme)\n{\n\tstruct damon_sysfs_access_pattern *access_pattern =\n\t\tsysfs_scheme->access_pattern;\n\tstruct damon_sysfs_quotas *sysfs_quotas = sysfs_scheme->quotas;\n\tstruct damon_sysfs_weights *sysfs_weights = sysfs_quotas->weights;\n\tstruct damon_sysfs_watermarks *sysfs_wmarks = sysfs_scheme->watermarks;\n\tstruct damon_sysfs_scheme_filters *sysfs_filters =\n\t\tsysfs_scheme->filters;\n\tstruct damos *scheme;\n\tint err;\n\n\tstruct damos_access_pattern pattern = {\n\t\t.min_sz_region = access_pattern->sz->min,\n\t\t.max_sz_region = access_pattern->sz->max,\n\t\t.min_nr_accesses = access_pattern->nr_accesses->min,\n\t\t.max_nr_accesses = access_pattern->nr_accesses->max,\n\t\t.min_age_region = access_pattern->age->min,\n\t\t.max_age_region = access_pattern->age->max,\n\t};\n\tstruct damos_quota quota = {\n\t\t.ms = sysfs_quotas->ms,\n\t\t.sz = sysfs_quotas->sz,\n\t\t.reset_interval = sysfs_quotas->reset_interval_ms,\n\t\t.weight_sz = sysfs_weights->sz,\n\t\t.weight_nr_accesses = sysfs_weights->nr_accesses,\n\t\t.weight_age = sysfs_weights->age,\n\t};\n\tstruct damos_watermarks wmarks = {\n\t\t.metric = sysfs_wmarks->metric,\n\t\t.interval = sysfs_wmarks->interval_us,\n\t\t.high = sysfs_wmarks->high,\n\t\t.mid = sysfs_wmarks->mid,\n\t\t.low = sysfs_wmarks->low,\n\t};\n\n\tscheme = damon_new_scheme(&pattern, sysfs_scheme->action, &quota,\n\t\t\t&wmarks);\n\tif (!scheme)\n\t\treturn NULL;\n\n\terr = damon_sysfs_set_scheme_filters(scheme, sysfs_filters);\n\tif (err) {\n\t\tdamon_destroy_scheme(scheme);\n\t\treturn NULL;\n\t}\n\treturn scheme;\n}\n\nstatic void damon_sysfs_update_scheme(struct damos *scheme,\n\t\tstruct damon_sysfs_scheme *sysfs_scheme)\n{\n\tstruct damon_sysfs_access_pattern *access_pattern =\n\t\tsysfs_scheme->access_pattern;\n\tstruct damon_sysfs_quotas *sysfs_quotas = sysfs_scheme->quotas;\n\tstruct damon_sysfs_weights *sysfs_weights = sysfs_quotas->weights;\n\tstruct damon_sysfs_watermarks *sysfs_wmarks = sysfs_scheme->watermarks;\n\tint err;\n\n\tscheme->pattern.min_sz_region = access_pattern->sz->min;\n\tscheme->pattern.max_sz_region = access_pattern->sz->max;\n\tscheme->pattern.min_nr_accesses = access_pattern->nr_accesses->min;\n\tscheme->pattern.max_nr_accesses = access_pattern->nr_accesses->max;\n\tscheme->pattern.min_age_region = access_pattern->age->min;\n\tscheme->pattern.max_age_region = access_pattern->age->max;\n\n\tscheme->action = sysfs_scheme->action;\n\n\tscheme->quota.ms = sysfs_quotas->ms;\n\tscheme->quota.sz = sysfs_quotas->sz;\n\tscheme->quota.reset_interval = sysfs_quotas->reset_interval_ms;\n\tscheme->quota.weight_sz = sysfs_weights->sz;\n\tscheme->quota.weight_nr_accesses = sysfs_weights->nr_accesses;\n\tscheme->quota.weight_age = sysfs_weights->age;\n\n\tscheme->wmarks.metric = sysfs_wmarks->metric;\n\tscheme->wmarks.interval = sysfs_wmarks->interval_us;\n\tscheme->wmarks.high = sysfs_wmarks->high;\n\tscheme->wmarks.mid = sysfs_wmarks->mid;\n\tscheme->wmarks.low = sysfs_wmarks->low;\n\n\terr = damon_sysfs_set_scheme_filters(scheme, sysfs_scheme->filters);\n\tif (err)\n\t\tdamon_destroy_scheme(scheme);\n}\n\nint damon_sysfs_set_schemes(struct damon_ctx *ctx,\n\t\tstruct damon_sysfs_schemes *sysfs_schemes)\n{\n\tstruct damos *scheme, *next;\n\tint i = 0;\n\n\tdamon_for_each_scheme_safe(scheme, next, ctx) {\n\t\tif (i < sysfs_schemes->nr)\n\t\t\tdamon_sysfs_update_scheme(scheme,\n\t\t\t\t\tsysfs_schemes->schemes_arr[i]);\n\t\telse\n\t\t\tdamon_destroy_scheme(scheme);\n\t\ti++;\n\t}\n\n\tfor (; i < sysfs_schemes->nr; i++) {\n\t\tstruct damos *scheme, *next;\n\n\t\tscheme = damon_sysfs_mk_scheme(sysfs_schemes->schemes_arr[i]);\n\t\tif (!scheme) {\n\t\t\tdamon_for_each_scheme_safe(scheme, next, ctx)\n\t\t\t\tdamon_destroy_scheme(scheme);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdamon_add_scheme(ctx, scheme);\n\t}\n\treturn 0;\n}\n\nvoid damon_sysfs_schemes_update_stats(\n\t\tstruct damon_sysfs_schemes *sysfs_schemes,\n\t\tstruct damon_ctx *ctx)\n{\n\tstruct damos *scheme;\n\tint schemes_idx = 0;\n\n\tdamon_for_each_scheme(scheme, ctx) {\n\t\tstruct damon_sysfs_stats *sysfs_stats;\n\n\t\t \n\t\tif (schemes_idx >= sysfs_schemes->nr)\n\t\t\tbreak;\n\n\t\tsysfs_stats = sysfs_schemes->schemes_arr[schemes_idx++]->stats;\n\t\tsysfs_stats->nr_tried = scheme->stat.nr_tried;\n\t\tsysfs_stats->sz_tried = scheme->stat.sz_tried;\n\t\tsysfs_stats->nr_applied = scheme->stat.nr_applied;\n\t\tsysfs_stats->sz_applied = scheme->stat.sz_applied;\n\t\tsysfs_stats->qt_exceeds = scheme->stat.qt_exceeds;\n\t}\n}\n\n \nstatic struct damon_sysfs_schemes *damon_sysfs_schemes_for_damos_callback;\nstatic int damon_sysfs_schemes_region_idx;\nstatic bool damos_regions_upd_total_bytes_only;\n\n \nstatic int damon_sysfs_before_damos_apply(struct damon_ctx *ctx,\n\t\tstruct damon_target *t, struct damon_region *r,\n\t\tstruct damos *s)\n{\n\tstruct damos *scheme;\n\tstruct damon_sysfs_scheme_regions *sysfs_regions;\n\tstruct damon_sysfs_scheme_region *region;\n\tstruct damon_sysfs_schemes *sysfs_schemes =\n\t\tdamon_sysfs_schemes_for_damos_callback;\n\tint schemes_idx = 0;\n\n\tdamon_for_each_scheme(scheme, ctx) {\n\t\tif (scheme == s)\n\t\t\tbreak;\n\t\tschemes_idx++;\n\t}\n\n\t \n\tif (schemes_idx >= sysfs_schemes->nr)\n\t\treturn 0;\n\n\tsysfs_regions = sysfs_schemes->schemes_arr[schemes_idx]->tried_regions;\n\tsysfs_regions->total_bytes += r->ar.end - r->ar.start;\n\tif (damos_regions_upd_total_bytes_only)\n\t\treturn 0;\n\n\tregion = damon_sysfs_scheme_region_alloc(r);\n\tif (!region)\n\t\treturn 0;\n\tlist_add_tail(&region->list, &sysfs_regions->regions_list);\n\tsysfs_regions->nr_regions++;\n\tif (kobject_init_and_add(&region->kobj,\n\t\t\t\t&damon_sysfs_scheme_region_ktype,\n\t\t\t\t&sysfs_regions->kobj, \"%d\",\n\t\t\t\tdamon_sysfs_schemes_region_idx++)) {\n\t\tkobject_put(&region->kobj);\n\t}\n\treturn 0;\n}\n\n \nint damon_sysfs_schemes_clear_regions(\n\t\tstruct damon_sysfs_schemes *sysfs_schemes,\n\t\tstruct damon_ctx *ctx)\n{\n\tstruct damos *scheme;\n\tint schemes_idx = 0;\n\n\tdamon_for_each_scheme(scheme, ctx) {\n\t\tstruct damon_sysfs_scheme *sysfs_scheme;\n\n\t\t \n\t\tif (schemes_idx >= sysfs_schemes->nr)\n\t\t\tbreak;\n\n\t\tsysfs_scheme = sysfs_schemes->schemes_arr[schemes_idx++];\n\t\tdamon_sysfs_scheme_regions_rm_dirs(\n\t\t\t\tsysfs_scheme->tried_regions);\n\t\tsysfs_scheme->tried_regions->total_bytes = 0;\n\t}\n\treturn 0;\n}\n\n \nint damon_sysfs_schemes_update_regions_start(\n\t\tstruct damon_sysfs_schemes *sysfs_schemes,\n\t\tstruct damon_ctx *ctx, bool total_bytes_only)\n{\n\tdamon_sysfs_schemes_clear_regions(sysfs_schemes, ctx);\n\tdamon_sysfs_schemes_for_damos_callback = sysfs_schemes;\n\tdamos_regions_upd_total_bytes_only = total_bytes_only;\n\tctx->callback.before_damos_apply = damon_sysfs_before_damos_apply;\n\treturn 0;\n}\n\n \nint damon_sysfs_schemes_update_regions_stop(struct damon_ctx *ctx)\n{\n\tdamon_sysfs_schemes_for_damos_callback = NULL;\n\tctx->callback.before_damos_apply = NULL;\n\tdamon_sysfs_schemes_region_idx = 0;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}