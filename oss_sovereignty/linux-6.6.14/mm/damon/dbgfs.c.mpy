{
  "module_name": "dbgfs.c",
  "hash_id": "237ad9efc58322acac8ad095e3f4d28a3078beb30eedd43be5e1296f670ca624",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/dbgfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"damon-dbgfs: \" fmt\n\n#include <linux/damon.h>\n#include <linux/debugfs.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/page_idle.h>\n#include <linux/slab.h>\n\nstatic struct damon_ctx **dbgfs_ctxs;\nstatic int dbgfs_nr_ctxs;\nstatic struct dentry **dbgfs_dirs;\nstatic DEFINE_MUTEX(damon_dbgfs_lock);\n\nstatic void damon_dbgfs_warn_deprecation(void)\n{\n\tpr_warn_once(\"DAMON debugfs interface is deprecated, \"\n\t\t     \"so users should move to DAMON_SYSFS. If you cannot, \"\n\t\t     \"please report your usecase to damon@lists.linux.dev and \"\n\t\t     \"linux-mm@kvack.org.\\n\");\n}\n\n \nstatic char *user_input_str(const char __user *buf, size_t count, loff_t *ppos)\n{\n\tchar *kbuf;\n\tssize_t ret;\n\n\t \n\tif (*ppos)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tkbuf = kmalloc(count + 1, GFP_KERNEL | __GFP_NOWARN);\n\tif (!kbuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = simple_write_to_buffer(kbuf, count + 1, ppos, buf, count);\n\tif (ret != count) {\n\t\tkfree(kbuf);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tkbuf[ret] = '\\0';\n\n\treturn kbuf;\n}\n\nstatic ssize_t dbgfs_attrs_read(struct file *file,\n\t\tchar __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar kbuf[128];\n\tint ret;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tret = scnprintf(kbuf, ARRAY_SIZE(kbuf), \"%lu %lu %lu %lu %lu\\n\",\n\t\t\tctx->attrs.sample_interval, ctx->attrs.aggr_interval,\n\t\t\tctx->attrs.ops_update_interval,\n\t\t\tctx->attrs.min_nr_regions, ctx->attrs.max_nr_regions);\n\tmutex_unlock(&ctx->kdamond_lock);\n\n\treturn simple_read_from_buffer(buf, count, ppos, kbuf, ret);\n}\n\nstatic ssize_t dbgfs_attrs_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tstruct damon_attrs attrs;\n\tchar *kbuf;\n\tssize_t ret;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tif (sscanf(kbuf, \"%lu %lu %lu %lu %lu\",\n\t\t\t\t&attrs.sample_interval, &attrs.aggr_interval,\n\t\t\t\t&attrs.ops_update_interval,\n\t\t\t\t&attrs.min_nr_regions,\n\t\t\t\t&attrs.max_nr_regions) != 5) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\tret = damon_set_attrs(ctx, &attrs);\n\tif (!ret)\n\t\tret = count;\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}\n\n \nstatic int damos_action_to_dbgfs_scheme_action(enum damos_action action)\n{\n\tswitch (action) {\n\tcase DAMOS_WILLNEED:\n\t\treturn 0;\n\tcase DAMOS_COLD:\n\t\treturn 1;\n\tcase DAMOS_PAGEOUT:\n\t\treturn 2;\n\tcase DAMOS_HUGEPAGE:\n\t\treturn 3;\n\tcase DAMOS_NOHUGEPAGE:\n\t\treturn 4;\n\tcase DAMOS_STAT:\n\t\treturn 5;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t sprint_schemes(struct damon_ctx *c, char *buf, ssize_t len)\n{\n\tstruct damos *s;\n\tint written = 0;\n\tint rc;\n\n\tdamon_for_each_scheme(s, c) {\n\t\trc = scnprintf(&buf[written], len - written,\n\t\t\t\t\"%lu %lu %u %u %u %u %d %lu %lu %lu %u %u %u %d %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",\n\t\t\t\ts->pattern.min_sz_region,\n\t\t\t\ts->pattern.max_sz_region,\n\t\t\t\ts->pattern.min_nr_accesses,\n\t\t\t\ts->pattern.max_nr_accesses,\n\t\t\t\ts->pattern.min_age_region,\n\t\t\t\ts->pattern.max_age_region,\n\t\t\t\tdamos_action_to_dbgfs_scheme_action(s->action),\n\t\t\t\ts->quota.ms, s->quota.sz,\n\t\t\t\ts->quota.reset_interval,\n\t\t\t\ts->quota.weight_sz,\n\t\t\t\ts->quota.weight_nr_accesses,\n\t\t\t\ts->quota.weight_age,\n\t\t\t\ts->wmarks.metric, s->wmarks.interval,\n\t\t\t\ts->wmarks.high, s->wmarks.mid, s->wmarks.low,\n\t\t\t\ts->stat.nr_tried, s->stat.sz_tried,\n\t\t\t\ts->stat.nr_applied, s->stat.sz_applied,\n\t\t\t\ts->stat.qt_exceeds);\n\t\tif (!rc)\n\t\t\treturn -ENOMEM;\n\n\t\twritten += rc;\n\t}\n\treturn written;\n}\n\nstatic ssize_t dbgfs_schemes_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf;\n\tssize_t len;\n\n\tkbuf = kmalloc(count, GFP_KERNEL | __GFP_NOWARN);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tlen = sprint_schemes(ctx, kbuf, count);\n\tmutex_unlock(&ctx->kdamond_lock);\n\tif (len < 0)\n\t\tgoto out;\n\tlen = simple_read_from_buffer(buf, count, ppos, kbuf, len);\n\nout:\n\tkfree(kbuf);\n\treturn len;\n}\n\nstatic void free_schemes_arr(struct damos **schemes, ssize_t nr_schemes)\n{\n\tssize_t i;\n\n\tfor (i = 0; i < nr_schemes; i++)\n\t\tkfree(schemes[i]);\n\tkfree(schemes);\n}\n\n \nstatic enum damos_action dbgfs_scheme_action_to_damos_action(int dbgfs_action)\n{\n\tswitch (dbgfs_action) {\n\tcase 0:\n\t\treturn DAMOS_WILLNEED;\n\tcase 1:\n\t\treturn DAMOS_COLD;\n\tcase 2:\n\t\treturn DAMOS_PAGEOUT;\n\tcase 3:\n\t\treturn DAMOS_HUGEPAGE;\n\tcase 4:\n\t\treturn DAMOS_NOHUGEPAGE;\n\tcase 5:\n\t\treturn DAMOS_STAT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic struct damos **str_to_schemes(const char *str, ssize_t len,\n\t\t\t\tssize_t *nr_schemes)\n{\n\tstruct damos *scheme, **schemes;\n\tconst int max_nr_schemes = 256;\n\tint pos = 0, parsed, ret;\n\tunsigned int action_input;\n\tenum damos_action action;\n\n\tschemes = kmalloc_array(max_nr_schemes, sizeof(scheme),\n\t\t\tGFP_KERNEL);\n\tif (!schemes)\n\t\treturn NULL;\n\n\t*nr_schemes = 0;\n\twhile (pos < len && *nr_schemes < max_nr_schemes) {\n\t\tstruct damos_access_pattern pattern = {};\n\t\tstruct damos_quota quota = {};\n\t\tstruct damos_watermarks wmarks;\n\n\t\tret = sscanf(&str[pos],\n\t\t\t\t\"%lu %lu %u %u %u %u %u %lu %lu %lu %u %u %u %u %lu %lu %lu %lu%n\",\n\t\t\t\t&pattern.min_sz_region, &pattern.max_sz_region,\n\t\t\t\t&pattern.min_nr_accesses,\n\t\t\t\t&pattern.max_nr_accesses,\n\t\t\t\t&pattern.min_age_region,\n\t\t\t\t&pattern.max_age_region,\n\t\t\t\t&action_input, &quota.ms,\n\t\t\t\t&quota.sz, &quota.reset_interval,\n\t\t\t\t&quota.weight_sz, &quota.weight_nr_accesses,\n\t\t\t\t&quota.weight_age, &wmarks.metric,\n\t\t\t\t&wmarks.interval, &wmarks.high, &wmarks.mid,\n\t\t\t\t&wmarks.low, &parsed);\n\t\tif (ret != 18)\n\t\t\tbreak;\n\t\taction = dbgfs_scheme_action_to_damos_action(action_input);\n\t\tif ((int)action < 0)\n\t\t\tgoto fail;\n\n\t\tif (pattern.min_sz_region > pattern.max_sz_region ||\n\t\t    pattern.min_nr_accesses > pattern.max_nr_accesses ||\n\t\t    pattern.min_age_region > pattern.max_age_region)\n\t\t\tgoto fail;\n\n\t\tif (wmarks.high < wmarks.mid || wmarks.high < wmarks.low ||\n\t\t    wmarks.mid <  wmarks.low)\n\t\t\tgoto fail;\n\n\t\tpos += parsed;\n\t\tscheme = damon_new_scheme(&pattern, action, &quota, &wmarks);\n\t\tif (!scheme)\n\t\t\tgoto fail;\n\n\t\tschemes[*nr_schemes] = scheme;\n\t\t*nr_schemes += 1;\n\t}\n\treturn schemes;\nfail:\n\tfree_schemes_arr(schemes, *nr_schemes);\n\treturn NULL;\n}\n\nstatic ssize_t dbgfs_schemes_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf;\n\tstruct damos **schemes;\n\tssize_t nr_schemes = 0, ret;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tschemes = str_to_schemes(kbuf, count, &nr_schemes);\n\tif (!schemes) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\tdamon_set_schemes(ctx, schemes, nr_schemes);\n\tret = count;\n\tnr_schemes = 0;\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\n\tfree_schemes_arr(schemes, nr_schemes);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic ssize_t sprint_target_ids(struct damon_ctx *ctx, char *buf, ssize_t len)\n{\n\tstruct damon_target *t;\n\tint id;\n\tint written = 0;\n\tint rc;\n\n\tdamon_for_each_target(t, ctx) {\n\t\tif (damon_target_has_pid(ctx))\n\t\t\t \n\t\t\tid = pid_vnr(t->pid);\n\t\telse\n\t\t\t \n\t\t\tid = 42;\n\n\t\trc = scnprintf(&buf[written], len - written, \"%d \", id);\n\t\tif (!rc)\n\t\t\treturn -ENOMEM;\n\t\twritten += rc;\n\t}\n\tif (written)\n\t\twritten -= 1;\n\twritten += scnprintf(&buf[written], len - written, \"\\n\");\n\treturn written;\n}\n\nstatic ssize_t dbgfs_target_ids_read(struct file *file,\n\t\tchar __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tssize_t len;\n\tchar ids_buf[320];\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tlen = sprint_target_ids(ctx, ids_buf, 320);\n\tmutex_unlock(&ctx->kdamond_lock);\n\tif (len < 0)\n\t\treturn len;\n\n\treturn simple_read_from_buffer(buf, count, ppos, ids_buf, len);\n}\n\n \nstatic int *str_to_ints(const char *str, ssize_t len, ssize_t *nr_ints)\n{\n\tint *array;\n\tconst int max_nr_ints = 32;\n\tint nr;\n\tint pos = 0, parsed, ret;\n\n\t*nr_ints = 0;\n\tarray = kmalloc_array(max_nr_ints, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn NULL;\n\twhile (*nr_ints < max_nr_ints && pos < len) {\n\t\tret = sscanf(&str[pos], \"%d%n\", &nr, &parsed);\n\t\tpos += parsed;\n\t\tif (ret != 1)\n\t\t\tbreak;\n\t\tarray[*nr_ints] = nr;\n\t\t*nr_ints += 1;\n\t}\n\n\treturn array;\n}\n\nstatic void dbgfs_put_pids(struct pid **pids, int nr_pids)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pids; i++)\n\t\tput_pid(pids[i]);\n}\n\n \nstatic struct pid **str_to_pids(const char *str, ssize_t len, ssize_t *nr_pids)\n{\n\tint *ints;\n\tssize_t nr_ints;\n\tstruct pid **pids;\n\n\t*nr_pids = 0;\n\n\tints = str_to_ints(str, len, &nr_ints);\n\tif (!ints)\n\t\treturn NULL;\n\n\tpids = kmalloc_array(nr_ints, sizeof(*pids), GFP_KERNEL);\n\tif (!pids)\n\t\tgoto out;\n\n\tfor (; *nr_pids < nr_ints; (*nr_pids)++) {\n\t\tpids[*nr_pids] = find_get_pid(ints[*nr_pids]);\n\t\tif (!pids[*nr_pids]) {\n\t\t\tdbgfs_put_pids(pids, *nr_pids);\n\t\t\tkfree(ints);\n\t\t\tkfree(pids);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\nout:\n\tkfree(ints);\n\treturn pids;\n}\n\n \nstatic int dbgfs_set_targets(struct damon_ctx *ctx, ssize_t nr_targets,\n\t\tstruct pid **pids)\n{\n\tssize_t i;\n\tstruct damon_target *t, *next;\n\n\tdamon_for_each_target_safe(t, next, ctx) {\n\t\tif (damon_target_has_pid(ctx))\n\t\t\tput_pid(t->pid);\n\t\tdamon_destroy_target(t);\n\t}\n\n\tfor (i = 0; i < nr_targets; i++) {\n\t\tt = damon_new_target();\n\t\tif (!t) {\n\t\t\tdamon_for_each_target_safe(t, next, ctx)\n\t\t\t\tdamon_destroy_target(t);\n\t\t\tif (damon_target_has_pid(ctx))\n\t\t\t\tdbgfs_put_pids(pids, nr_targets);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (damon_target_has_pid(ctx))\n\t\t\tt->pid = pids[i];\n\t\tdamon_add_target(ctx, t);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t dbgfs_target_ids_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tbool id_is_pid = true;\n\tchar *kbuf;\n\tstruct pid **target_pids = NULL;\n\tssize_t nr_targets;\n\tssize_t ret;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tif (!strncmp(kbuf, \"paddr\\n\", count)) {\n\t\tid_is_pid = false;\n\t\tnr_targets = 1;\n\t}\n\n\tif (id_is_pid) {\n\t\ttarget_pids = str_to_pids(kbuf, count, &nr_targets);\n\t\tif (!target_pids) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tif (id_is_pid)\n\t\t\tdbgfs_put_pids(target_pids, nr_targets);\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tdbgfs_set_targets(ctx, 0, NULL);\n\tif (!nr_targets) {\n\t\tret = count;\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tif (id_is_pid)\n\t\tret = damon_select_ops(ctx, DAMON_OPS_VADDR);\n\telse\n\t\tret = damon_select_ops(ctx, DAMON_OPS_PADDR);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = dbgfs_set_targets(ctx, nr_targets, target_pids);\n\tif (!ret)\n\t\tret = count;\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\n\tkfree(target_pids);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic ssize_t sprint_init_regions(struct damon_ctx *c, char *buf, ssize_t len)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r;\n\tint target_idx = 0;\n\tint written = 0;\n\tint rc;\n\n\tdamon_for_each_target(t, c) {\n\t\tdamon_for_each_region(r, t) {\n\t\t\trc = scnprintf(&buf[written], len - written,\n\t\t\t\t\t\"%d %lu %lu\\n\",\n\t\t\t\t\ttarget_idx, r->ar.start, r->ar.end);\n\t\t\tif (!rc)\n\t\t\t\treturn -ENOMEM;\n\t\t\twritten += rc;\n\t\t}\n\t\ttarget_idx++;\n\t}\n\treturn written;\n}\n\nstatic ssize_t dbgfs_init_regions_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf;\n\tssize_t len;\n\n\tkbuf = kmalloc(count, GFP_KERNEL | __GFP_NOWARN);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tmutex_unlock(&ctx->kdamond_lock);\n\t\tlen = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tlen = sprint_init_regions(ctx, kbuf, count);\n\tmutex_unlock(&ctx->kdamond_lock);\n\tif (len < 0)\n\t\tgoto out;\n\tlen = simple_read_from_buffer(buf, count, ppos, kbuf, len);\n\nout:\n\tkfree(kbuf);\n\treturn len;\n}\n\nstatic int add_init_region(struct damon_ctx *c, int target_idx,\n\t\tstruct damon_addr_range *ar)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r, *prev;\n\tunsigned long idx = 0;\n\tint rc = -EINVAL;\n\n\tif (ar->start >= ar->end)\n\t\treturn -EINVAL;\n\n\tdamon_for_each_target(t, c) {\n\t\tif (idx++ == target_idx) {\n\t\t\tr = damon_new_region(ar->start, ar->end);\n\t\t\tif (!r)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdamon_add_region(r, t);\n\t\t\tif (damon_nr_regions(t) > 1) {\n\t\t\t\tprev = damon_prev_region(r);\n\t\t\t\tif (prev->ar.end > r->ar.start) {\n\t\t\t\t\tdamon_destroy_region(r, t);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\trc = 0;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int set_init_regions(struct damon_ctx *c, const char *str, ssize_t len)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r, *next;\n\tint pos = 0, parsed, ret;\n\tint target_idx;\n\tstruct damon_addr_range ar;\n\tint err;\n\n\tdamon_for_each_target(t, c) {\n\t\tdamon_for_each_region_safe(r, next, t)\n\t\t\tdamon_destroy_region(r, t);\n\t}\n\n\twhile (pos < len) {\n\t\tret = sscanf(&str[pos], \"%d %lu %lu%n\",\n\t\t\t\t&target_idx, &ar.start, &ar.end, &parsed);\n\t\tif (ret != 3)\n\t\t\tbreak;\n\t\terr = add_init_region(c, target_idx, &ar);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\tpos += parsed;\n\t}\n\n\treturn 0;\n\nfail:\n\tdamon_for_each_target(t, c) {\n\t\tdamon_for_each_region_safe(r, next, t)\n\t\t\tdamon_destroy_region(r, t);\n\t}\n\treturn err;\n}\n\nstatic ssize_t dbgfs_init_regions_write(struct file *file,\n\t\t\t\t\t  const char __user *buf, size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf;\n\tssize_t ret = count;\n\tint err;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\terr = set_init_regions(ctx, kbuf, ret);\n\tif (err)\n\t\tret = err;\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic ssize_t dbgfs_kdamond_pid_read(struct file *file,\n\t\tchar __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf;\n\tssize_t len;\n\n\tkbuf = kmalloc(count, GFP_KERNEL | __GFP_NOWARN);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond)\n\t\tlen = scnprintf(kbuf, count, \"%d\\n\", ctx->kdamond->pid);\n\telse\n\t\tlen = scnprintf(kbuf, count, \"none\\n\");\n\tmutex_unlock(&ctx->kdamond_lock);\n\tif (!len)\n\t\tgoto out;\n\tlen = simple_read_from_buffer(buf, count, ppos, kbuf, len);\n\nout:\n\tkfree(kbuf);\n\treturn len;\n}\n\nstatic int damon_dbgfs_open(struct inode *inode, struct file *file)\n{\n\tdamon_dbgfs_warn_deprecation();\n\n\tfile->private_data = inode->i_private;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic const struct file_operations attrs_fops = {\n\t.open = damon_dbgfs_open,\n\t.read = dbgfs_attrs_read,\n\t.write = dbgfs_attrs_write,\n};\n\nstatic const struct file_operations schemes_fops = {\n\t.open = damon_dbgfs_open,\n\t.read = dbgfs_schemes_read,\n\t.write = dbgfs_schemes_write,\n};\n\nstatic const struct file_operations target_ids_fops = {\n\t.open = damon_dbgfs_open,\n\t.read = dbgfs_target_ids_read,\n\t.write = dbgfs_target_ids_write,\n};\n\nstatic const struct file_operations init_regions_fops = {\n\t.open = damon_dbgfs_open,\n\t.read = dbgfs_init_regions_read,\n\t.write = dbgfs_init_regions_write,\n};\n\nstatic const struct file_operations kdamond_pid_fops = {\n\t.open = damon_dbgfs_open,\n\t.read = dbgfs_kdamond_pid_read,\n};\n\nstatic void dbgfs_fill_ctx_dir(struct dentry *dir, struct damon_ctx *ctx)\n{\n\tconst char * const file_names[] = {\"attrs\", \"schemes\", \"target_ids\",\n\t\t\"init_regions\", \"kdamond_pid\"};\n\tconst struct file_operations *fops[] = {&attrs_fops, &schemes_fops,\n\t\t&target_ids_fops, &init_regions_fops, &kdamond_pid_fops};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(file_names); i++)\n\t\tdebugfs_create_file(file_names[i], 0600, dir, ctx, fops[i]);\n}\n\nstatic void dbgfs_before_terminate(struct damon_ctx *ctx)\n{\n\tstruct damon_target *t, *next;\n\n\tif (!damon_target_has_pid(ctx))\n\t\treturn;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tdamon_for_each_target_safe(t, next, ctx) {\n\t\tput_pid(t->pid);\n\t\tdamon_destroy_target(t);\n\t}\n\tmutex_unlock(&ctx->kdamond_lock);\n}\n\nstatic struct damon_ctx *dbgfs_new_ctx(void)\n{\n\tstruct damon_ctx *ctx;\n\n\tctx = damon_new_ctx();\n\tif (!ctx)\n\t\treturn NULL;\n\n\tif (damon_select_ops(ctx, DAMON_OPS_VADDR) &&\n\t\t\tdamon_select_ops(ctx, DAMON_OPS_PADDR)) {\n\t\tdamon_destroy_ctx(ctx);\n\t\treturn NULL;\n\t}\n\tctx->callback.before_terminate = dbgfs_before_terminate;\n\treturn ctx;\n}\n\nstatic void dbgfs_destroy_ctx(struct damon_ctx *ctx)\n{\n\tdamon_destroy_ctx(ctx);\n}\n\n \nstatic int dbgfs_mk_context(char *name)\n{\n\tstruct dentry *root, **new_dirs, *new_dir;\n\tstruct damon_ctx **new_ctxs, *new_ctx;\n\n\tif (damon_nr_running_ctxs())\n\t\treturn -EBUSY;\n\n\tnew_ctxs = krealloc(dbgfs_ctxs, sizeof(*dbgfs_ctxs) *\n\t\t\t(dbgfs_nr_ctxs + 1), GFP_KERNEL);\n\tif (!new_ctxs)\n\t\treturn -ENOMEM;\n\tdbgfs_ctxs = new_ctxs;\n\n\tnew_dirs = krealloc(dbgfs_dirs, sizeof(*dbgfs_dirs) *\n\t\t\t(dbgfs_nr_ctxs + 1), GFP_KERNEL);\n\tif (!new_dirs)\n\t\treturn -ENOMEM;\n\tdbgfs_dirs = new_dirs;\n\n\troot = dbgfs_dirs[0];\n\tif (!root)\n\t\treturn -ENOENT;\n\n\tnew_dir = debugfs_create_dir(name, root);\n\t \n\tif (IS_ERR(new_dir))\n\t\treturn PTR_ERR(new_dir);\n\tdbgfs_dirs[dbgfs_nr_ctxs] = new_dir;\n\n\tnew_ctx = dbgfs_new_ctx();\n\tif (!new_ctx) {\n\t\tdebugfs_remove(new_dir);\n\t\tdbgfs_dirs[dbgfs_nr_ctxs] = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tdbgfs_ctxs[dbgfs_nr_ctxs] = new_ctx;\n\tdbgfs_fill_ctx_dir(dbgfs_dirs[dbgfs_nr_ctxs],\n\t\t\tdbgfs_ctxs[dbgfs_nr_ctxs]);\n\tdbgfs_nr_ctxs++;\n\n\treturn 0;\n}\n\nstatic ssize_t dbgfs_mk_context_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tchar *kbuf;\n\tchar *ctx_name;\n\tssize_t ret;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\tctx_name = kmalloc(count + 1, GFP_KERNEL);\n\tif (!ctx_name) {\n\t\tkfree(kbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (sscanf(kbuf, \"%s\", ctx_name) != 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&damon_dbgfs_lock);\n\tret = dbgfs_mk_context(ctx_name);\n\tif (!ret)\n\t\tret = count;\n\tmutex_unlock(&damon_dbgfs_lock);\n\nout:\n\tkfree(kbuf);\n\tkfree(ctx_name);\n\treturn ret;\n}\n\n \nstatic int dbgfs_rm_context(char *name)\n{\n\tstruct dentry *root, *dir, **new_dirs;\n\tstruct inode *inode;\n\tstruct damon_ctx **new_ctxs;\n\tint i, j;\n\tint ret = 0;\n\n\tif (damon_nr_running_ctxs())\n\t\treturn -EBUSY;\n\n\troot = dbgfs_dirs[0];\n\tif (!root)\n\t\treturn -ENOENT;\n\n\tdir = debugfs_lookup(name, root);\n\tif (!dir)\n\t\treturn -ENOENT;\n\n\tinode = d_inode(dir);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tnew_dirs = kmalloc_array(dbgfs_nr_ctxs - 1, sizeof(*dbgfs_dirs),\n\t\t\tGFP_KERNEL);\n\tif (!new_dirs) {\n\t\tret = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\tnew_ctxs = kmalloc_array(dbgfs_nr_ctxs - 1, sizeof(*dbgfs_ctxs),\n\t\t\tGFP_KERNEL);\n\tif (!new_ctxs) {\n\t\tret = -ENOMEM;\n\t\tgoto out_new_dirs;\n\t}\n\n\tfor (i = 0, j = 0; i < dbgfs_nr_ctxs; i++) {\n\t\tif (dbgfs_dirs[i] == dir) {\n\t\t\tdebugfs_remove(dbgfs_dirs[i]);\n\t\t\tdbgfs_destroy_ctx(dbgfs_ctxs[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tnew_dirs[j] = dbgfs_dirs[i];\n\t\tnew_ctxs[j++] = dbgfs_ctxs[i];\n\t}\n\n\tkfree(dbgfs_dirs);\n\tkfree(dbgfs_ctxs);\n\n\tdbgfs_dirs = new_dirs;\n\tdbgfs_ctxs = new_ctxs;\n\tdbgfs_nr_ctxs--;\n\n\tgoto out_dput;\n\nout_new_dirs:\n\tkfree(new_dirs);\nout_dput:\n\tdput(dir);\n\treturn ret;\n}\n\nstatic ssize_t dbgfs_rm_context_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tchar *kbuf;\n\tssize_t ret;\n\tchar *ctx_name;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\tctx_name = kmalloc(count + 1, GFP_KERNEL);\n\tif (!ctx_name) {\n\t\tkfree(kbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (sscanf(kbuf, \"%s\", ctx_name) != 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&damon_dbgfs_lock);\n\tret = dbgfs_rm_context(ctx_name);\n\tif (!ret)\n\t\tret = count;\n\tmutex_unlock(&damon_dbgfs_lock);\n\nout:\n\tkfree(kbuf);\n\tkfree(ctx_name);\n\treturn ret;\n}\n\nstatic ssize_t dbgfs_monitor_on_read(struct file *file,\n\t\tchar __user *buf, size_t count, loff_t *ppos)\n{\n\tchar monitor_on_buf[5];\n\tbool monitor_on = damon_nr_running_ctxs() != 0;\n\tint len;\n\n\tlen = scnprintf(monitor_on_buf, 5, monitor_on ? \"on\\n\" : \"off\\n\");\n\n\treturn simple_read_from_buffer(buf, count, ppos, monitor_on_buf, len);\n}\n\nstatic ssize_t dbgfs_monitor_on_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *kbuf;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t \n\tif (sscanf(kbuf, \"%s\", kbuf) != 1) {\n\t\tkfree(kbuf);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&damon_dbgfs_lock);\n\tif (!strncmp(kbuf, \"on\", count)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dbgfs_nr_ctxs; i++) {\n\t\t\tif (damon_targets_empty(dbgfs_ctxs[i])) {\n\t\t\t\tkfree(kbuf);\n\t\t\t\tmutex_unlock(&damon_dbgfs_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tret = damon_start(dbgfs_ctxs, dbgfs_nr_ctxs, true);\n\t} else if (!strncmp(kbuf, \"off\", count)) {\n\t\tret = damon_stop(dbgfs_ctxs, dbgfs_nr_ctxs);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&damon_dbgfs_lock);\n\n\tif (!ret)\n\t\tret = count;\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic int damon_dbgfs_static_file_open(struct inode *inode, struct file *file)\n{\n\tdamon_dbgfs_warn_deprecation();\n\treturn nonseekable_open(inode, file);\n}\n\nstatic const struct file_operations mk_contexts_fops = {\n\t.open = damon_dbgfs_static_file_open,\n\t.write = dbgfs_mk_context_write,\n};\n\nstatic const struct file_operations rm_contexts_fops = {\n\t.open = damon_dbgfs_static_file_open,\n\t.write = dbgfs_rm_context_write,\n};\n\nstatic const struct file_operations monitor_on_fops = {\n\t.open = damon_dbgfs_static_file_open,\n\t.read = dbgfs_monitor_on_read,\n\t.write = dbgfs_monitor_on_write,\n};\n\nstatic int __init __damon_dbgfs_init(void)\n{\n\tstruct dentry *dbgfs_root;\n\tconst char * const file_names[] = {\"mk_contexts\", \"rm_contexts\",\n\t\t\"monitor_on\"};\n\tconst struct file_operations *fops[] = {&mk_contexts_fops,\n\t\t&rm_contexts_fops, &monitor_on_fops};\n\tint i;\n\n\tdbgfs_root = debugfs_create_dir(\"damon\", NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(file_names); i++)\n\t\tdebugfs_create_file(file_names[i], 0600, dbgfs_root, NULL,\n\t\t\t\tfops[i]);\n\tdbgfs_fill_ctx_dir(dbgfs_root, dbgfs_ctxs[0]);\n\n\tdbgfs_dirs = kmalloc(sizeof(dbgfs_root), GFP_KERNEL);\n\tif (!dbgfs_dirs) {\n\t\tdebugfs_remove(dbgfs_root);\n\t\treturn -ENOMEM;\n\t}\n\tdbgfs_dirs[0] = dbgfs_root;\n\n\treturn 0;\n}\n\n \n\nstatic int __init damon_dbgfs_init(void)\n{\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&damon_dbgfs_lock);\n\tdbgfs_ctxs = kmalloc(sizeof(*dbgfs_ctxs), GFP_KERNEL);\n\tif (!dbgfs_ctxs)\n\t\tgoto out;\n\tdbgfs_ctxs[0] = dbgfs_new_ctx();\n\tif (!dbgfs_ctxs[0]) {\n\t\tkfree(dbgfs_ctxs);\n\t\tgoto out;\n\t}\n\tdbgfs_nr_ctxs = 1;\n\n\trc = __damon_dbgfs_init();\n\tif (rc) {\n\t\tkfree(dbgfs_ctxs[0]);\n\t\tkfree(dbgfs_ctxs);\n\t\tpr_err(\"%s: dbgfs init failed\\n\", __func__);\n\t}\n\nout:\n\tmutex_unlock(&damon_dbgfs_lock);\n\treturn rc;\n}\n\nmodule_init(damon_dbgfs_init);\n\n#include \"dbgfs-test.h\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}