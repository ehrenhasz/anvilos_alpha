{
  "module_name": "sysfs.c",
  "hash_id": "16ee17da5b2328a8dbd5336f12d54846997ade3b8c29545f585be18806534ba2",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/pid.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"sysfs-common.h\"\n\n \n\nstruct damon_sysfs_region {\n\tstruct kobject kobj;\n\tstruct damon_addr_range ar;\n};\n\nstatic struct damon_sysfs_region *damon_sysfs_region_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_region), GFP_KERNEL);\n}\n\nstatic ssize_t start_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_region, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.start);\n}\n\nstatic ssize_t start_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_region, kobj);\n\tint err = kstrtoul(buf, 0, &region->ar.start);\n\n\treturn err ? err : count;\n}\n\nstatic ssize_t end_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_region, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.end);\n}\n\nstatic ssize_t end_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_region *region = container_of(kobj,\n\t\t\tstruct damon_sysfs_region, kobj);\n\tint err = kstrtoul(buf, 0, &region->ar.end);\n\n\treturn err ? err : count;\n}\n\nstatic void damon_sysfs_region_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_region, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_region_start_attr =\n\t\t__ATTR_RW_MODE(start, 0600);\n\nstatic struct kobj_attribute damon_sysfs_region_end_attr =\n\t\t__ATTR_RW_MODE(end, 0600);\n\nstatic struct attribute *damon_sysfs_region_attrs[] = {\n\t&damon_sysfs_region_start_attr.attr,\n\t&damon_sysfs_region_end_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_region);\n\nstatic const struct kobj_type damon_sysfs_region_ktype = {\n\t.release = damon_sysfs_region_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_region_groups,\n};\n\n \n\nstruct damon_sysfs_regions {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_region **regions_arr;\n\tint nr;\n};\n\nstatic struct damon_sysfs_regions *damon_sysfs_regions_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_regions), GFP_KERNEL);\n}\n\nstatic void damon_sysfs_regions_rm_dirs(struct damon_sysfs_regions *regions)\n{\n\tstruct damon_sysfs_region **regions_arr = regions->regions_arr;\n\tint i;\n\n\tfor (i = 0; i < regions->nr; i++)\n\t\tkobject_put(&regions_arr[i]->kobj);\n\tregions->nr = 0;\n\tkfree(regions_arr);\n\tregions->regions_arr = NULL;\n}\n\nstatic int damon_sysfs_regions_add_dirs(struct damon_sysfs_regions *regions,\n\t\tint nr_regions)\n{\n\tstruct damon_sysfs_region **regions_arr, *region;\n\tint err, i;\n\n\tdamon_sysfs_regions_rm_dirs(regions);\n\tif (!nr_regions)\n\t\treturn 0;\n\n\tregions_arr = kmalloc_array(nr_regions, sizeof(*regions_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!regions_arr)\n\t\treturn -ENOMEM;\n\tregions->regions_arr = regions_arr;\n\n\tfor (i = 0; i < nr_regions; i++) {\n\t\tregion = damon_sysfs_region_alloc();\n\t\tif (!region) {\n\t\t\tdamon_sysfs_regions_rm_dirs(regions);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&region->kobj,\n\t\t\t\t&damon_sysfs_region_ktype, &regions->kobj,\n\t\t\t\t\"%d\", i);\n\t\tif (err) {\n\t\t\tkobject_put(&region->kobj);\n\t\t\tdamon_sysfs_regions_rm_dirs(regions);\n\t\t\treturn err;\n\t\t}\n\n\t\tregions_arr[i] = region;\n\t\tregions->nr++;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t nr_regions_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_regions *regions = container_of(kobj,\n\t\t\tstruct damon_sysfs_regions, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", regions->nr);\n}\n\nstatic ssize_t nr_regions_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_regions *regions;\n\tint nr, err = kstrtoint(buf, 0, &nr);\n\n\tif (err)\n\t\treturn err;\n\tif (nr < 0)\n\t\treturn -EINVAL;\n\n\tregions = container_of(kobj, struct damon_sysfs_regions, kobj);\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_regions_add_dirs(regions, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic void damon_sysfs_regions_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_regions, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_regions_nr_attr =\n\t\t__ATTR_RW_MODE(nr_regions, 0600);\n\nstatic struct attribute *damon_sysfs_regions_attrs[] = {\n\t&damon_sysfs_regions_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_regions);\n\nstatic const struct kobj_type damon_sysfs_regions_ktype = {\n\t.release = damon_sysfs_regions_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_regions_groups,\n};\n\n \n\nstruct damon_sysfs_target {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_regions *regions;\n\tint pid;\n};\n\nstatic struct damon_sysfs_target *damon_sysfs_target_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_target), GFP_KERNEL);\n}\n\nstatic int damon_sysfs_target_add_dirs(struct damon_sysfs_target *target)\n{\n\tstruct damon_sysfs_regions *regions = damon_sysfs_regions_alloc();\n\tint err;\n\n\tif (!regions)\n\t\treturn -ENOMEM;\n\n\terr = kobject_init_and_add(&regions->kobj, &damon_sysfs_regions_ktype,\n\t\t\t&target->kobj, \"regions\");\n\tif (err)\n\t\tkobject_put(&regions->kobj);\n\telse\n\t\ttarget->regions = regions;\n\treturn err;\n}\n\nstatic void damon_sysfs_target_rm_dirs(struct damon_sysfs_target *target)\n{\n\tdamon_sysfs_regions_rm_dirs(target->regions);\n\tkobject_put(&target->regions->kobj);\n}\n\nstatic ssize_t pid_target_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_target *target = container_of(kobj,\n\t\t\tstruct damon_sysfs_target, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", target->pid);\n}\n\nstatic ssize_t pid_target_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_target *target = container_of(kobj,\n\t\t\tstruct damon_sysfs_target, kobj);\n\tint err = kstrtoint(buf, 0, &target->pid);\n\n\tif (err)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic void damon_sysfs_target_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_target, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_target_pid_attr =\n\t\t__ATTR_RW_MODE(pid_target, 0600);\n\nstatic struct attribute *damon_sysfs_target_attrs[] = {\n\t&damon_sysfs_target_pid_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_target);\n\nstatic const struct kobj_type damon_sysfs_target_ktype = {\n\t.release = damon_sysfs_target_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_target_groups,\n};\n\n \n\nstruct damon_sysfs_targets {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_target **targets_arr;\n\tint nr;\n};\n\nstatic struct damon_sysfs_targets *damon_sysfs_targets_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_targets), GFP_KERNEL);\n}\n\nstatic void damon_sysfs_targets_rm_dirs(struct damon_sysfs_targets *targets)\n{\n\tstruct damon_sysfs_target **targets_arr = targets->targets_arr;\n\tint i;\n\n\tfor (i = 0; i < targets->nr; i++) {\n\t\tdamon_sysfs_target_rm_dirs(targets_arr[i]);\n\t\tkobject_put(&targets_arr[i]->kobj);\n\t}\n\ttargets->nr = 0;\n\tkfree(targets_arr);\n\ttargets->targets_arr = NULL;\n}\n\nstatic int damon_sysfs_targets_add_dirs(struct damon_sysfs_targets *targets,\n\t\tint nr_targets)\n{\n\tstruct damon_sysfs_target **targets_arr, *target;\n\tint err, i;\n\n\tdamon_sysfs_targets_rm_dirs(targets);\n\tif (!nr_targets)\n\t\treturn 0;\n\n\ttargets_arr = kmalloc_array(nr_targets, sizeof(*targets_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!targets_arr)\n\t\treturn -ENOMEM;\n\ttargets->targets_arr = targets_arr;\n\n\tfor (i = 0; i < nr_targets; i++) {\n\t\ttarget = damon_sysfs_target_alloc();\n\t\tif (!target) {\n\t\t\tdamon_sysfs_targets_rm_dirs(targets);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&target->kobj,\n\t\t\t\t&damon_sysfs_target_ktype, &targets->kobj,\n\t\t\t\t\"%d\", i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = damon_sysfs_target_add_dirs(target);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttargets_arr[i] = target;\n\t\ttargets->nr++;\n\t}\n\treturn 0;\n\nout:\n\tdamon_sysfs_targets_rm_dirs(targets);\n\tkobject_put(&target->kobj);\n\treturn err;\n}\n\nstatic ssize_t nr_targets_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_targets *targets = container_of(kobj,\n\t\t\tstruct damon_sysfs_targets, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", targets->nr);\n}\n\nstatic ssize_t nr_targets_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_targets *targets;\n\tint nr, err = kstrtoint(buf, 0, &nr);\n\n\tif (err)\n\t\treturn err;\n\tif (nr < 0)\n\t\treturn -EINVAL;\n\n\ttargets = container_of(kobj, struct damon_sysfs_targets, kobj);\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_targets_add_dirs(targets, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic void damon_sysfs_targets_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_targets, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_targets_nr_attr =\n\t\t__ATTR_RW_MODE(nr_targets, 0600);\n\nstatic struct attribute *damon_sysfs_targets_attrs[] = {\n\t&damon_sysfs_targets_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_targets);\n\nstatic const struct kobj_type damon_sysfs_targets_ktype = {\n\t.release = damon_sysfs_targets_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_targets_groups,\n};\n\n \n\nstruct damon_sysfs_intervals {\n\tstruct kobject kobj;\n\tunsigned long sample_us;\n\tunsigned long aggr_us;\n\tunsigned long update_us;\n};\n\nstatic struct damon_sysfs_intervals *damon_sysfs_intervals_alloc(\n\t\tunsigned long sample_us, unsigned long aggr_us,\n\t\tunsigned long update_us)\n{\n\tstruct damon_sysfs_intervals *intervals = kmalloc(sizeof(*intervals),\n\t\t\tGFP_KERNEL);\n\n\tif (!intervals)\n\t\treturn NULL;\n\n\tintervals->kobj = (struct kobject){};\n\tintervals->sample_us = sample_us;\n\tintervals->aggr_us = aggr_us;\n\tintervals->update_us = update_us;\n\treturn intervals;\n}\n\nstatic ssize_t sample_us_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", intervals->sample_us);\n}\n\nstatic ssize_t sample_us_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\tunsigned long us;\n\tint err = kstrtoul(buf, 0, &us);\n\n\tif (err)\n\t\treturn err;\n\n\tintervals->sample_us = us;\n\treturn count;\n}\n\nstatic ssize_t aggr_us_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", intervals->aggr_us);\n}\n\nstatic ssize_t aggr_us_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\tunsigned long us;\n\tint err = kstrtoul(buf, 0, &us);\n\n\tif (err)\n\t\treturn err;\n\n\tintervals->aggr_us = us;\n\treturn count;\n}\n\nstatic ssize_t update_us_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", intervals->update_us);\n}\n\nstatic ssize_t update_us_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_intervals *intervals = container_of(kobj,\n\t\t\tstruct damon_sysfs_intervals, kobj);\n\tunsigned long us;\n\tint err = kstrtoul(buf, 0, &us);\n\n\tif (err)\n\t\treturn err;\n\n\tintervals->update_us = us;\n\treturn count;\n}\n\nstatic void damon_sysfs_intervals_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_intervals, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_intervals_sample_us_attr =\n\t\t__ATTR_RW_MODE(sample_us, 0600);\n\nstatic struct kobj_attribute damon_sysfs_intervals_aggr_us_attr =\n\t\t__ATTR_RW_MODE(aggr_us, 0600);\n\nstatic struct kobj_attribute damon_sysfs_intervals_update_us_attr =\n\t\t__ATTR_RW_MODE(update_us, 0600);\n\nstatic struct attribute *damon_sysfs_intervals_attrs[] = {\n\t&damon_sysfs_intervals_sample_us_attr.attr,\n\t&damon_sysfs_intervals_aggr_us_attr.attr,\n\t&damon_sysfs_intervals_update_us_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_intervals);\n\nstatic const struct kobj_type damon_sysfs_intervals_ktype = {\n\t.release = damon_sysfs_intervals_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_intervals_groups,\n};\n\n \n\nstruct damon_sysfs_attrs {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_intervals *intervals;\n\tstruct damon_sysfs_ul_range *nr_regions_range;\n};\n\nstatic struct damon_sysfs_attrs *damon_sysfs_attrs_alloc(void)\n{\n\tstruct damon_sysfs_attrs *attrs = kmalloc(sizeof(*attrs), GFP_KERNEL);\n\n\tif (!attrs)\n\t\treturn NULL;\n\tattrs->kobj = (struct kobject){};\n\treturn attrs;\n}\n\nstatic int damon_sysfs_attrs_add_dirs(struct damon_sysfs_attrs *attrs)\n{\n\tstruct damon_sysfs_intervals *intervals;\n\tstruct damon_sysfs_ul_range *nr_regions_range;\n\tint err;\n\n\tintervals = damon_sysfs_intervals_alloc(5000, 100000, 60000000);\n\tif (!intervals)\n\t\treturn -ENOMEM;\n\n\terr = kobject_init_and_add(&intervals->kobj,\n\t\t\t&damon_sysfs_intervals_ktype, &attrs->kobj,\n\t\t\t\"intervals\");\n\tif (err)\n\t\tgoto put_intervals_out;\n\tattrs->intervals = intervals;\n\n\tnr_regions_range = damon_sysfs_ul_range_alloc(10, 1000);\n\tif (!nr_regions_range) {\n\t\terr = -ENOMEM;\n\t\tgoto put_intervals_out;\n\t}\n\n\terr = kobject_init_and_add(&nr_regions_range->kobj,\n\t\t\t&damon_sysfs_ul_range_ktype, &attrs->kobj,\n\t\t\t\"nr_regions\");\n\tif (err)\n\t\tgoto put_nr_regions_intervals_out;\n\tattrs->nr_regions_range = nr_regions_range;\n\treturn 0;\n\nput_nr_regions_intervals_out:\n\tkobject_put(&nr_regions_range->kobj);\n\tattrs->nr_regions_range = NULL;\nput_intervals_out:\n\tkobject_put(&intervals->kobj);\n\tattrs->intervals = NULL;\n\treturn err;\n}\n\nstatic void damon_sysfs_attrs_rm_dirs(struct damon_sysfs_attrs *attrs)\n{\n\tkobject_put(&attrs->nr_regions_range->kobj);\n\tkobject_put(&attrs->intervals->kobj);\n}\n\nstatic void damon_sysfs_attrs_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_attrs, kobj));\n}\n\nstatic struct attribute *damon_sysfs_attrs_attrs[] = {\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_attrs);\n\nstatic const struct kobj_type damon_sysfs_attrs_ktype = {\n\t.release = damon_sysfs_attrs_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_attrs_groups,\n};\n\n \n\n \nstatic const char * const damon_sysfs_ops_strs[] = {\n\t\"vaddr\",\n\t\"fvaddr\",\n\t\"paddr\",\n};\n\nstruct damon_sysfs_context {\n\tstruct kobject kobj;\n\tenum damon_ops_id ops_id;\n\tstruct damon_sysfs_attrs *attrs;\n\tstruct damon_sysfs_targets *targets;\n\tstruct damon_sysfs_schemes *schemes;\n};\n\nstatic struct damon_sysfs_context *damon_sysfs_context_alloc(\n\t\tenum damon_ops_id ops_id)\n{\n\tstruct damon_sysfs_context *context = kmalloc(sizeof(*context),\n\t\t\t\tGFP_KERNEL);\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->kobj = (struct kobject){};\n\tcontext->ops_id = ops_id;\n\treturn context;\n}\n\nstatic int damon_sysfs_context_set_attrs(struct damon_sysfs_context *context)\n{\n\tstruct damon_sysfs_attrs *attrs = damon_sysfs_attrs_alloc();\n\tint err;\n\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&attrs->kobj, &damon_sysfs_attrs_ktype,\n\t\t\t&context->kobj, \"monitoring_attrs\");\n\tif (err)\n\t\tgoto out;\n\terr = damon_sysfs_attrs_add_dirs(attrs);\n\tif (err)\n\t\tgoto out;\n\tcontext->attrs = attrs;\n\treturn 0;\n\nout:\n\tkobject_put(&attrs->kobj);\n\treturn err;\n}\n\nstatic int damon_sysfs_context_set_targets(struct damon_sysfs_context *context)\n{\n\tstruct damon_sysfs_targets *targets = damon_sysfs_targets_alloc();\n\tint err;\n\n\tif (!targets)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&targets->kobj, &damon_sysfs_targets_ktype,\n\t\t\t&context->kobj, \"targets\");\n\tif (err) {\n\t\tkobject_put(&targets->kobj);\n\t\treturn err;\n\t}\n\tcontext->targets = targets;\n\treturn 0;\n}\n\nstatic int damon_sysfs_context_set_schemes(struct damon_sysfs_context *context)\n{\n\tstruct damon_sysfs_schemes *schemes = damon_sysfs_schemes_alloc();\n\tint err;\n\n\tif (!schemes)\n\t\treturn -ENOMEM;\n\terr = kobject_init_and_add(&schemes->kobj, &damon_sysfs_schemes_ktype,\n\t\t\t&context->kobj, \"schemes\");\n\tif (err) {\n\t\tkobject_put(&schemes->kobj);\n\t\treturn err;\n\t}\n\tcontext->schemes = schemes;\n\treturn 0;\n}\n\nstatic int damon_sysfs_context_add_dirs(struct damon_sysfs_context *context)\n{\n\tint err;\n\n\terr = damon_sysfs_context_set_attrs(context);\n\tif (err)\n\t\treturn err;\n\n\terr = damon_sysfs_context_set_targets(context);\n\tif (err)\n\t\tgoto put_attrs_out;\n\n\terr = damon_sysfs_context_set_schemes(context);\n\tif (err)\n\t\tgoto put_targets_attrs_out;\n\treturn 0;\n\nput_targets_attrs_out:\n\tkobject_put(&context->targets->kobj);\n\tcontext->targets = NULL;\nput_attrs_out:\n\tkobject_put(&context->attrs->kobj);\n\tcontext->attrs = NULL;\n\treturn err;\n}\n\nstatic void damon_sysfs_context_rm_dirs(struct damon_sysfs_context *context)\n{\n\tdamon_sysfs_attrs_rm_dirs(context->attrs);\n\tkobject_put(&context->attrs->kobj);\n\tdamon_sysfs_targets_rm_dirs(context->targets);\n\tkobject_put(&context->targets->kobj);\n\tdamon_sysfs_schemes_rm_dirs(context->schemes);\n\tkobject_put(&context->schemes->kobj);\n}\n\nstatic ssize_t avail_operations_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tenum damon_ops_id id;\n\tint len = 0;\n\n\tfor (id = 0; id < NR_DAMON_OPS; id++) {\n\t\tif (!damon_is_registered_ops(id))\n\t\t\tcontinue;\n\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\",\n\t\t\t\tdamon_sysfs_ops_strs[id]);\n\t}\n\treturn len;\n}\n\nstatic ssize_t operations_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_context *context = container_of(kobj,\n\t\t\tstruct damon_sysfs_context, kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", damon_sysfs_ops_strs[context->ops_id]);\n}\n\nstatic ssize_t operations_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_context *context = container_of(kobj,\n\t\t\tstruct damon_sysfs_context, kobj);\n\tenum damon_ops_id id;\n\n\tfor (id = 0; id < NR_DAMON_OPS; id++) {\n\t\tif (sysfs_streq(buf, damon_sysfs_ops_strs[id])) {\n\t\t\tcontext->ops_id = id;\n\t\t\treturn count;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic void damon_sysfs_context_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_context, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_context_avail_operations_attr =\n\t\t__ATTR_RO_MODE(avail_operations, 0400);\n\nstatic struct kobj_attribute damon_sysfs_context_operations_attr =\n\t\t__ATTR_RW_MODE(operations, 0600);\n\nstatic struct attribute *damon_sysfs_context_attrs[] = {\n\t&damon_sysfs_context_avail_operations_attr.attr,\n\t&damon_sysfs_context_operations_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_context);\n\nstatic const struct kobj_type damon_sysfs_context_ktype = {\n\t.release = damon_sysfs_context_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_context_groups,\n};\n\n \n\nstruct damon_sysfs_contexts {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_context **contexts_arr;\n\tint nr;\n};\n\nstatic struct damon_sysfs_contexts *damon_sysfs_contexts_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_contexts), GFP_KERNEL);\n}\n\nstatic void damon_sysfs_contexts_rm_dirs(struct damon_sysfs_contexts *contexts)\n{\n\tstruct damon_sysfs_context **contexts_arr = contexts->contexts_arr;\n\tint i;\n\n\tfor (i = 0; i < contexts->nr; i++) {\n\t\tdamon_sysfs_context_rm_dirs(contexts_arr[i]);\n\t\tkobject_put(&contexts_arr[i]->kobj);\n\t}\n\tcontexts->nr = 0;\n\tkfree(contexts_arr);\n\tcontexts->contexts_arr = NULL;\n}\n\nstatic int damon_sysfs_contexts_add_dirs(struct damon_sysfs_contexts *contexts,\n\t\tint nr_contexts)\n{\n\tstruct damon_sysfs_context **contexts_arr, *context;\n\tint err, i;\n\n\tdamon_sysfs_contexts_rm_dirs(contexts);\n\tif (!nr_contexts)\n\t\treturn 0;\n\n\tcontexts_arr = kmalloc_array(nr_contexts, sizeof(*contexts_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!contexts_arr)\n\t\treturn -ENOMEM;\n\tcontexts->contexts_arr = contexts_arr;\n\n\tfor (i = 0; i < nr_contexts; i++) {\n\t\tcontext = damon_sysfs_context_alloc(DAMON_OPS_VADDR);\n\t\tif (!context) {\n\t\t\tdamon_sysfs_contexts_rm_dirs(contexts);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&context->kobj,\n\t\t\t\t&damon_sysfs_context_ktype, &contexts->kobj,\n\t\t\t\t\"%d\", i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = damon_sysfs_context_add_dirs(context);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tcontexts_arr[i] = context;\n\t\tcontexts->nr++;\n\t}\n\treturn 0;\n\nout:\n\tdamon_sysfs_contexts_rm_dirs(contexts);\n\tkobject_put(&context->kobj);\n\treturn err;\n}\n\nstatic ssize_t nr_contexts_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_contexts *contexts = container_of(kobj,\n\t\t\tstruct damon_sysfs_contexts, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", contexts->nr);\n}\n\nstatic ssize_t nr_contexts_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_contexts *contexts;\n\tint nr, err;\n\n\terr = kstrtoint(buf, 0, &nr);\n\tif (err)\n\t\treturn err;\n\t \n\tif (nr < 0 || 1 < nr)\n\t\treturn -EINVAL;\n\n\tcontexts = container_of(kobj, struct damon_sysfs_contexts, kobj);\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_contexts_add_dirs(contexts, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic void damon_sysfs_contexts_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_contexts, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_contexts_nr_attr\n\t\t= __ATTR_RW_MODE(nr_contexts, 0600);\n\nstatic struct attribute *damon_sysfs_contexts_attrs[] = {\n\t&damon_sysfs_contexts_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_contexts);\n\nstatic const struct kobj_type damon_sysfs_contexts_ktype = {\n\t.release = damon_sysfs_contexts_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_contexts_groups,\n};\n\n \n\nstruct damon_sysfs_kdamond {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_contexts *contexts;\n\tstruct damon_ctx *damon_ctx;\n};\n\nstatic struct damon_sysfs_kdamond *damon_sysfs_kdamond_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_kdamond), GFP_KERNEL);\n}\n\nstatic int damon_sysfs_kdamond_add_dirs(struct damon_sysfs_kdamond *kdamond)\n{\n\tstruct damon_sysfs_contexts *contexts;\n\tint err;\n\n\tcontexts = damon_sysfs_contexts_alloc();\n\tif (!contexts)\n\t\treturn -ENOMEM;\n\n\terr = kobject_init_and_add(&contexts->kobj,\n\t\t\t&damon_sysfs_contexts_ktype, &kdamond->kobj,\n\t\t\t\"contexts\");\n\tif (err) {\n\t\tkobject_put(&contexts->kobj);\n\t\treturn err;\n\t}\n\tkdamond->contexts = contexts;\n\n\treturn err;\n}\n\nstatic void damon_sysfs_kdamond_rm_dirs(struct damon_sysfs_kdamond *kdamond)\n{\n\tdamon_sysfs_contexts_rm_dirs(kdamond->contexts);\n\tkobject_put(&kdamond->contexts->kobj);\n}\n\nstatic bool damon_sysfs_ctx_running(struct damon_ctx *ctx)\n{\n\tbool running;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\trunning = ctx->kdamond != NULL;\n\tmutex_unlock(&ctx->kdamond_lock);\n\treturn running;\n}\n\n \nenum damon_sysfs_cmd {\n\t \n\tDAMON_SYSFS_CMD_ON,\n\t \n\tDAMON_SYSFS_CMD_OFF,\n\t \n\tDAMON_SYSFS_CMD_COMMIT,\n\t \n\tDAMON_SYSFS_CMD_UPDATE_SCHEMES_STATS,\n\t \n\tDAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_BYTES,\n\t \n\tDAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_REGIONS,\n\t \n\tDAMON_SYSFS_CMD_CLEAR_SCHEMES_TRIED_REGIONS,\n\t \n\tNR_DAMON_SYSFS_CMDS,\n};\n\n \nstatic const char * const damon_sysfs_cmd_strs[] = {\n\t\"on\",\n\t\"off\",\n\t\"commit\",\n\t\"update_schemes_stats\",\n\t\"update_schemes_tried_bytes\",\n\t\"update_schemes_tried_regions\",\n\t\"clear_schemes_tried_regions\",\n};\n\n \nstruct damon_sysfs_cmd_request {\n\tenum damon_sysfs_cmd cmd;\n\tstruct damon_sysfs_kdamond *kdamond;\n};\n\n \nstatic struct damon_sysfs_cmd_request damon_sysfs_cmd_request;\n\nstatic ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,\n\t\t\tstruct damon_sysfs_kdamond, kobj);\n\tstruct damon_ctx *ctx = kdamond->damon_ctx;\n\tbool running;\n\n\tif (!ctx)\n\t\trunning = false;\n\telse\n\t\trunning = damon_sysfs_ctx_running(ctx);\n\n\treturn sysfs_emit(buf, \"%s\\n\", running ?\n\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_ON] :\n\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_OFF]);\n}\n\nstatic int damon_sysfs_set_attrs(struct damon_ctx *ctx,\n\t\tstruct damon_sysfs_attrs *sys_attrs)\n{\n\tstruct damon_sysfs_intervals *sys_intervals = sys_attrs->intervals;\n\tstruct damon_sysfs_ul_range *sys_nr_regions =\n\t\tsys_attrs->nr_regions_range;\n\tstruct damon_attrs attrs = {\n\t\t.sample_interval = sys_intervals->sample_us,\n\t\t.aggr_interval = sys_intervals->aggr_us,\n\t\t.ops_update_interval = sys_intervals->update_us,\n\t\t.min_nr_regions = sys_nr_regions->min,\n\t\t.max_nr_regions = sys_nr_regions->max,\n\t};\n\treturn damon_set_attrs(ctx, &attrs);\n}\n\nstatic void damon_sysfs_destroy_targets(struct damon_ctx *ctx)\n{\n\tstruct damon_target *t, *next;\n\tbool has_pid = damon_target_has_pid(ctx);\n\n\tdamon_for_each_target_safe(t, next, ctx) {\n\t\tif (has_pid)\n\t\t\tput_pid(t->pid);\n\t\tdamon_destroy_target(t);\n\t}\n}\n\nstatic int damon_sysfs_set_regions(struct damon_target *t,\n\t\tstruct damon_sysfs_regions *sysfs_regions)\n{\n\tstruct damon_addr_range *ranges = kmalloc_array(sysfs_regions->nr,\n\t\t\tsizeof(*ranges), GFP_KERNEL | __GFP_NOWARN);\n\tint i, err = -EINVAL;\n\n\tif (!ranges)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < sysfs_regions->nr; i++) {\n\t\tstruct damon_sysfs_region *sys_region =\n\t\t\tsysfs_regions->regions_arr[i];\n\n\t\tif (sys_region->ar.start > sys_region->ar.end)\n\t\t\tgoto out;\n\n\t\tranges[i].start = sys_region->ar.start;\n\t\tranges[i].end = sys_region->ar.end;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (ranges[i - 1].end > ranges[i].start)\n\t\t\tgoto out;\n\t}\n\terr = damon_set_regions(t, ranges, sysfs_regions->nr);\nout:\n\tkfree(ranges);\n\treturn err;\n\n}\n\nstatic int damon_sysfs_add_target(struct damon_sysfs_target *sys_target,\n\t\tstruct damon_ctx *ctx)\n{\n\tstruct damon_target *t = damon_new_target();\n\tint err = -EINVAL;\n\n\tif (!t)\n\t\treturn -ENOMEM;\n\tdamon_add_target(ctx, t);\n\tif (damon_target_has_pid(ctx)) {\n\t\tt->pid = find_get_pid(sys_target->pid);\n\t\tif (!t->pid)\n\t\t\tgoto destroy_targets_out;\n\t}\n\terr = damon_sysfs_set_regions(t, sys_target->regions);\n\tif (err)\n\t\tgoto destroy_targets_out;\n\treturn 0;\n\ndestroy_targets_out:\n\tdamon_sysfs_destroy_targets(ctx);\n\treturn err;\n}\n\nstatic int damon_sysfs_update_target_pid(struct damon_target *target, int pid)\n{\n\tstruct pid *pid_new;\n\n\tpid_new = find_get_pid(pid);\n\tif (!pid_new)\n\t\treturn -EINVAL;\n\n\tif (pid_new == target->pid) {\n\t\tput_pid(pid_new);\n\t\treturn 0;\n\t}\n\n\tput_pid(target->pid);\n\ttarget->pid = pid_new;\n\treturn 0;\n}\n\nstatic int damon_sysfs_update_target(struct damon_target *target,\n\t\tstruct damon_ctx *ctx,\n\t\tstruct damon_sysfs_target *sys_target)\n{\n\tint err = 0;\n\n\tif (damon_target_has_pid(ctx)) {\n\t\terr = damon_sysfs_update_target_pid(target, sys_target->pid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (sys_target->regions->nr)\n\t\terr = damon_sysfs_set_regions(target, sys_target->regions);\n\treturn err;\n}\n\nstatic int damon_sysfs_set_targets(struct damon_ctx *ctx,\n\t\tstruct damon_sysfs_targets *sysfs_targets)\n{\n\tstruct damon_target *t, *next;\n\tint i = 0, err;\n\n\t \n\tif (ctx->ops.id == DAMON_OPS_PADDR && sysfs_targets->nr > 1)\n\t\treturn -EINVAL;\n\n\tdamon_for_each_target_safe(t, next, ctx) {\n\t\tif (i < sysfs_targets->nr) {\n\t\t\terr = damon_sysfs_update_target(t, ctx,\n\t\t\t\t\tsysfs_targets->targets_arr[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (damon_target_has_pid(ctx))\n\t\t\t\tput_pid(t->pid);\n\t\t\tdamon_destroy_target(t);\n\t\t}\n\t\ti++;\n\t}\n\n\tfor (; i < sysfs_targets->nr; i++) {\n\t\tstruct damon_sysfs_target *st = sysfs_targets->targets_arr[i];\n\n\t\terr = damon_sysfs_add_target(st, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic bool damon_sysfs_schemes_regions_updating;\n\nstatic void damon_sysfs_before_terminate(struct damon_ctx *ctx)\n{\n\tstruct damon_target *t, *next;\n\tstruct damon_sysfs_kdamond *kdamond;\n\tenum damon_sysfs_cmd cmd;\n\n\t \n\tkdamond = damon_sysfs_cmd_request.kdamond;\n\tcmd = damon_sysfs_cmd_request.cmd;\n\tif (kdamond && ctx == kdamond->damon_ctx &&\n\t\t\t(cmd == DAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_REGIONS ||\n\t\t\t cmd == DAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_BYTES) &&\n\t\t\tdamon_sysfs_schemes_regions_updating) {\n\t\tdamon_sysfs_schemes_update_regions_stop(ctx);\n\t\tdamon_sysfs_schemes_regions_updating = false;\n\t\tmutex_unlock(&damon_sysfs_lock);\n\t}\n\n\tif (!damon_target_has_pid(ctx))\n\t\treturn;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tdamon_for_each_target_safe(t, next, ctx) {\n\t\tput_pid(t->pid);\n\t\tdamon_destroy_target(t);\n\t}\n\tmutex_unlock(&ctx->kdamond_lock);\n}\n\n \nstatic int damon_sysfs_upd_schemes_stats(struct damon_sysfs_kdamond *kdamond)\n{\n\tstruct damon_ctx *ctx = kdamond->damon_ctx;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\tdamon_sysfs_schemes_update_stats(\n\t\t\tkdamond->contexts->contexts_arr[0]->schemes, ctx);\n\treturn 0;\n}\n\nstatic int damon_sysfs_upd_schemes_regions_start(\n\t\tstruct damon_sysfs_kdamond *kdamond, bool total_bytes_only)\n{\n\tstruct damon_ctx *ctx = kdamond->damon_ctx;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\treturn damon_sysfs_schemes_update_regions_start(\n\t\t\tkdamond->contexts->contexts_arr[0]->schemes, ctx,\n\t\t\ttotal_bytes_only);\n}\n\nstatic int damon_sysfs_upd_schemes_regions_stop(\n\t\tstruct damon_sysfs_kdamond *kdamond)\n{\n\tstruct damon_ctx *ctx = kdamond->damon_ctx;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\treturn damon_sysfs_schemes_update_regions_stop(ctx);\n}\n\nstatic int damon_sysfs_clear_schemes_regions(\n\t\tstruct damon_sysfs_kdamond *kdamond)\n{\n\tstruct damon_ctx *ctx = kdamond->damon_ctx;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\treturn damon_sysfs_schemes_clear_regions(\n\t\t\tkdamond->contexts->contexts_arr[0]->schemes, ctx);\n}\n\nstatic inline bool damon_sysfs_kdamond_running(\n\t\tstruct damon_sysfs_kdamond *kdamond)\n{\n\treturn kdamond->damon_ctx &&\n\t\tdamon_sysfs_ctx_running(kdamond->damon_ctx);\n}\n\nstatic int damon_sysfs_apply_inputs(struct damon_ctx *ctx,\n\t\tstruct damon_sysfs_context *sys_ctx)\n{\n\tint err;\n\n\terr = damon_select_ops(ctx, sys_ctx->ops_id);\n\tif (err)\n\t\treturn err;\n\terr = damon_sysfs_set_attrs(ctx, sys_ctx->attrs);\n\tif (err)\n\t\treturn err;\n\terr = damon_sysfs_set_targets(ctx, sys_ctx->targets);\n\tif (err)\n\t\treturn err;\n\treturn damon_sysfs_set_schemes(ctx, sys_ctx->schemes);\n}\n\n \nstatic int damon_sysfs_commit_input(struct damon_sysfs_kdamond *kdamond)\n{\n\tif (!damon_sysfs_kdamond_running(kdamond))\n\t\treturn -EINVAL;\n\t \n\tif (kdamond->contexts->nr != 1)\n\t\treturn -EINVAL;\n\n\treturn damon_sysfs_apply_inputs(kdamond->damon_ctx,\n\t\t\tkdamond->contexts->contexts_arr[0]);\n}\n\n \nstatic int damon_sysfs_cmd_request_callback(struct damon_ctx *c)\n{\n\tstruct damon_sysfs_kdamond *kdamond;\n\tbool total_bytes_only = false;\n\tint err = 0;\n\n\t \n\tif (!damon_sysfs_schemes_regions_updating &&\n\t\t\t!mutex_trylock(&damon_sysfs_lock))\n\t\treturn 0;\n\tkdamond = damon_sysfs_cmd_request.kdamond;\n\tif (!kdamond || kdamond->damon_ctx != c)\n\t\tgoto out;\n\tswitch (damon_sysfs_cmd_request.cmd) {\n\tcase DAMON_SYSFS_CMD_UPDATE_SCHEMES_STATS:\n\t\terr = damon_sysfs_upd_schemes_stats(kdamond);\n\t\tbreak;\n\tcase DAMON_SYSFS_CMD_COMMIT:\n\t\terr = damon_sysfs_commit_input(kdamond);\n\t\tbreak;\n\tcase DAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_BYTES:\n\t\ttotal_bytes_only = true;\n\t\tfallthrough;\n\tcase DAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_REGIONS:\n\t\tif (!damon_sysfs_schemes_regions_updating) {\n\t\t\terr = damon_sysfs_upd_schemes_regions_start(kdamond,\n\t\t\t\t\ttotal_bytes_only);\n\t\t\tif (!err) {\n\t\t\t\tdamon_sysfs_schemes_regions_updating = true;\n\t\t\t\tgoto keep_lock_out;\n\t\t\t}\n\t\t} else {\n\t\t\terr = damon_sysfs_upd_schemes_regions_stop(kdamond);\n\t\t\tdamon_sysfs_schemes_regions_updating = false;\n\t\t}\n\t\tbreak;\n\tcase DAMON_SYSFS_CMD_CLEAR_SCHEMES_TRIED_REGIONS:\n\t\terr = damon_sysfs_clear_schemes_regions(kdamond);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tdamon_sysfs_cmd_request.kdamond = NULL;\nout:\n\tif (!damon_sysfs_schemes_regions_updating)\n\t\tmutex_unlock(&damon_sysfs_lock);\nkeep_lock_out:\n\treturn err;\n}\n\nstatic struct damon_ctx *damon_sysfs_build_ctx(\n\t\tstruct damon_sysfs_context *sys_ctx)\n{\n\tstruct damon_ctx *ctx = damon_new_ctx();\n\tint err;\n\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = damon_sysfs_apply_inputs(ctx, sys_ctx);\n\tif (err) {\n\t\tdamon_destroy_ctx(ctx);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tctx->callback.after_wmarks_check = damon_sysfs_cmd_request_callback;\n\tctx->callback.after_aggregation = damon_sysfs_cmd_request_callback;\n\tctx->callback.before_terminate = damon_sysfs_before_terminate;\n\treturn ctx;\n}\n\nstatic int damon_sysfs_turn_damon_on(struct damon_sysfs_kdamond *kdamond)\n{\n\tstruct damon_ctx *ctx;\n\tint err;\n\n\tif (damon_sysfs_kdamond_running(kdamond))\n\t\treturn -EBUSY;\n\tif (damon_sysfs_cmd_request.kdamond == kdamond)\n\t\treturn -EBUSY;\n\t \n\tif (kdamond->contexts->nr != 1)\n\t\treturn -EINVAL;\n\n\tif (kdamond->damon_ctx)\n\t\tdamon_destroy_ctx(kdamond->damon_ctx);\n\tkdamond->damon_ctx = NULL;\n\n\tctx = damon_sysfs_build_ctx(kdamond->contexts->contexts_arr[0]);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\terr = damon_start(&ctx, 1, false);\n\tif (err) {\n\t\tdamon_destroy_ctx(ctx);\n\t\treturn err;\n\t}\n\tkdamond->damon_ctx = ctx;\n\treturn err;\n}\n\nstatic int damon_sysfs_turn_damon_off(struct damon_sysfs_kdamond *kdamond)\n{\n\tif (!kdamond->damon_ctx)\n\t\treturn -EINVAL;\n\treturn damon_stop(&kdamond->damon_ctx, 1);\n\t \n}\n\n \nstatic int damon_sysfs_handle_cmd(enum damon_sysfs_cmd cmd,\n\t\tstruct damon_sysfs_kdamond *kdamond)\n{\n\tbool need_wait = true;\n\n\t \n\tswitch (cmd) {\n\tcase DAMON_SYSFS_CMD_ON:\n\t\treturn damon_sysfs_turn_damon_on(kdamond);\n\tcase DAMON_SYSFS_CMD_OFF:\n\t\treturn damon_sysfs_turn_damon_off(kdamond);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (damon_sysfs_cmd_request.kdamond)\n\t\treturn -EBUSY;\n\tif (!damon_sysfs_kdamond_running(kdamond))\n\t\treturn -EINVAL;\n\tdamon_sysfs_cmd_request.cmd = cmd;\n\tdamon_sysfs_cmd_request.kdamond = kdamond;\n\n\t \n\tmutex_unlock(&damon_sysfs_lock);\n\twhile (need_wait) {\n\t\tschedule_timeout_idle(msecs_to_jiffies(100));\n\t\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\t\tcontinue;\n\t\tif (!damon_sysfs_cmd_request.kdamond) {\n\t\t\t \n\t\t\tneed_wait = false;\n\t\t} else if (!damon_sysfs_kdamond_running(kdamond)) {\n\t\t\t \n\t\t\tneed_wait = false;\n\t\t\tdamon_sysfs_cmd_request.kdamond = NULL;\n\t\t}\n\t\tmutex_unlock(&damon_sysfs_lock);\n\t}\n\tmutex_lock(&damon_sysfs_lock);\n\treturn 0;\n}\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,\n\t\t\tstruct damon_sysfs_kdamond, kobj);\n\tenum damon_sysfs_cmd cmd;\n\tssize_t ret = -EINVAL;\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\tfor (cmd = 0; cmd < NR_DAMON_SYSFS_CMDS; cmd++) {\n\t\tif (sysfs_streq(buf, damon_sysfs_cmd_strs[cmd])) {\n\t\t\tret = damon_sysfs_handle_cmd(cmd, kdamond);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (!ret)\n\t\tret = count;\n\treturn ret;\n}\n\nstatic ssize_t pid_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,\n\t\t\tstruct damon_sysfs_kdamond, kobj);\n\tstruct damon_ctx *ctx;\n\tint pid = -1;\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\tctx = kdamond->damon_ctx;\n\tif (!ctx)\n\t\tgoto out;\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond)\n\t\tpid = ctx->kdamond->pid;\n\tmutex_unlock(&ctx->kdamond_lock);\nout:\n\tmutex_unlock(&damon_sysfs_lock);\n\treturn sysfs_emit(buf, \"%d\\n\", pid);\n}\n\nstatic void damon_sysfs_kdamond_release(struct kobject *kobj)\n{\n\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,\n\t\t\tstruct damon_sysfs_kdamond, kobj);\n\n\tif (kdamond->damon_ctx)\n\t\tdamon_destroy_ctx(kdamond->damon_ctx);\n\tkfree(kdamond);\n}\n\nstatic struct kobj_attribute damon_sysfs_kdamond_state_attr =\n\t\t__ATTR_RW_MODE(state, 0600);\n\nstatic struct kobj_attribute damon_sysfs_kdamond_pid_attr =\n\t\t__ATTR_RO_MODE(pid, 0400);\n\nstatic struct attribute *damon_sysfs_kdamond_attrs[] = {\n\t&damon_sysfs_kdamond_state_attr.attr,\n\t&damon_sysfs_kdamond_pid_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_kdamond);\n\nstatic const struct kobj_type damon_sysfs_kdamond_ktype = {\n\t.release = damon_sysfs_kdamond_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_kdamond_groups,\n};\n\n \n\nstruct damon_sysfs_kdamonds {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_kdamond **kdamonds_arr;\n\tint nr;\n};\n\nstatic struct damon_sysfs_kdamonds *damon_sysfs_kdamonds_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_kdamonds), GFP_KERNEL);\n}\n\nstatic void damon_sysfs_kdamonds_rm_dirs(struct damon_sysfs_kdamonds *kdamonds)\n{\n\tstruct damon_sysfs_kdamond **kdamonds_arr = kdamonds->kdamonds_arr;\n\tint i;\n\n\tfor (i = 0; i < kdamonds->nr; i++) {\n\t\tdamon_sysfs_kdamond_rm_dirs(kdamonds_arr[i]);\n\t\tkobject_put(&kdamonds_arr[i]->kobj);\n\t}\n\tkdamonds->nr = 0;\n\tkfree(kdamonds_arr);\n\tkdamonds->kdamonds_arr = NULL;\n}\n\nstatic bool damon_sysfs_kdamonds_busy(struct damon_sysfs_kdamond **kdamonds,\n\t\tint nr_kdamonds)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_kdamonds; i++) {\n\t\tif (damon_sysfs_kdamond_running(kdamonds[i]) ||\n\t\t    damon_sysfs_cmd_request.kdamond == kdamonds[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int damon_sysfs_kdamonds_add_dirs(struct damon_sysfs_kdamonds *kdamonds,\n\t\tint nr_kdamonds)\n{\n\tstruct damon_sysfs_kdamond **kdamonds_arr, *kdamond;\n\tint err, i;\n\n\tif (damon_sysfs_kdamonds_busy(kdamonds->kdamonds_arr, kdamonds->nr))\n\t\treturn -EBUSY;\n\n\tdamon_sysfs_kdamonds_rm_dirs(kdamonds);\n\tif (!nr_kdamonds)\n\t\treturn 0;\n\n\tkdamonds_arr = kmalloc_array(nr_kdamonds, sizeof(*kdamonds_arr),\n\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!kdamonds_arr)\n\t\treturn -ENOMEM;\n\tkdamonds->kdamonds_arr = kdamonds_arr;\n\n\tfor (i = 0; i < nr_kdamonds; i++) {\n\t\tkdamond = damon_sysfs_kdamond_alloc();\n\t\tif (!kdamond) {\n\t\t\tdamon_sysfs_kdamonds_rm_dirs(kdamonds);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = kobject_init_and_add(&kdamond->kobj,\n\t\t\t\t&damon_sysfs_kdamond_ktype, &kdamonds->kobj,\n\t\t\t\t\"%d\", i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = damon_sysfs_kdamond_add_dirs(kdamond);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tkdamonds_arr[i] = kdamond;\n\t\tkdamonds->nr++;\n\t}\n\treturn 0;\n\nout:\n\tdamon_sysfs_kdamonds_rm_dirs(kdamonds);\n\tkobject_put(&kdamond->kobj);\n\treturn err;\n}\n\nstatic ssize_t nr_kdamonds_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct damon_sysfs_kdamonds *kdamonds = container_of(kobj,\n\t\t\tstruct damon_sysfs_kdamonds, kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", kdamonds->nr);\n}\n\nstatic ssize_t nr_kdamonds_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tstruct damon_sysfs_kdamonds *kdamonds;\n\tint nr, err;\n\n\terr = kstrtoint(buf, 0, &nr);\n\tif (err)\n\t\treturn err;\n\tif (nr < 0)\n\t\treturn -EINVAL;\n\n\tkdamonds = container_of(kobj, struct damon_sysfs_kdamonds, kobj);\n\n\tif (!mutex_trylock(&damon_sysfs_lock))\n\t\treturn -EBUSY;\n\terr = damon_sysfs_kdamonds_add_dirs(kdamonds, nr);\n\tmutex_unlock(&damon_sysfs_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic void damon_sysfs_kdamonds_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_kdamonds, kobj));\n}\n\nstatic struct kobj_attribute damon_sysfs_kdamonds_nr_attr =\n\t\t__ATTR_RW_MODE(nr_kdamonds, 0600);\n\nstatic struct attribute *damon_sysfs_kdamonds_attrs[] = {\n\t&damon_sysfs_kdamonds_nr_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_kdamonds);\n\nstatic const struct kobj_type damon_sysfs_kdamonds_ktype = {\n\t.release = damon_sysfs_kdamonds_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_kdamonds_groups,\n};\n\n \n\nstruct damon_sysfs_ui_dir {\n\tstruct kobject kobj;\n\tstruct damon_sysfs_kdamonds *kdamonds;\n};\n\nstatic struct damon_sysfs_ui_dir *damon_sysfs_ui_dir_alloc(void)\n{\n\treturn kzalloc(sizeof(struct damon_sysfs_ui_dir), GFP_KERNEL);\n}\n\nstatic int damon_sysfs_ui_dir_add_dirs(struct damon_sysfs_ui_dir *ui_dir)\n{\n\tstruct damon_sysfs_kdamonds *kdamonds;\n\tint err;\n\n\tkdamonds = damon_sysfs_kdamonds_alloc();\n\tif (!kdamonds)\n\t\treturn -ENOMEM;\n\n\terr = kobject_init_and_add(&kdamonds->kobj,\n\t\t\t&damon_sysfs_kdamonds_ktype, &ui_dir->kobj,\n\t\t\t\"kdamonds\");\n\tif (err) {\n\t\tkobject_put(&kdamonds->kobj);\n\t\treturn err;\n\t}\n\tui_dir->kdamonds = kdamonds;\n\treturn err;\n}\n\nstatic void damon_sysfs_ui_dir_release(struct kobject *kobj)\n{\n\tkfree(container_of(kobj, struct damon_sysfs_ui_dir, kobj));\n}\n\nstatic struct attribute *damon_sysfs_ui_dir_attrs[] = {\n\tNULL,\n};\nATTRIBUTE_GROUPS(damon_sysfs_ui_dir);\n\nstatic const struct kobj_type damon_sysfs_ui_dir_ktype = {\n\t.release = damon_sysfs_ui_dir_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = damon_sysfs_ui_dir_groups,\n};\n\nstatic int __init damon_sysfs_init(void)\n{\n\tstruct kobject *damon_sysfs_root;\n\tstruct damon_sysfs_ui_dir *admin;\n\tint err;\n\n\tdamon_sysfs_root = kobject_create_and_add(\"damon\", mm_kobj);\n\tif (!damon_sysfs_root)\n\t\treturn -ENOMEM;\n\n\tadmin = damon_sysfs_ui_dir_alloc();\n\tif (!admin) {\n\t\tkobject_put(damon_sysfs_root);\n\t\treturn -ENOMEM;\n\t}\n\terr = kobject_init_and_add(&admin->kobj, &damon_sysfs_ui_dir_ktype,\n\t\t\tdamon_sysfs_root, \"admin\");\n\tif (err)\n\t\tgoto out;\n\terr = damon_sysfs_ui_dir_add_dirs(admin);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tkobject_put(&admin->kobj);\n\tkobject_put(damon_sysfs_root);\n\treturn err;\n}\nsubsys_initcall(damon_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}