{
  "module_name": "core-test.h",
  "hash_id": "24013c421a7ac4192f2fbf7d7aee7096552b2a79a26bb505d21c47d3ce9eb793",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/core-test.h",
  "human_readable_source": " \n \n\n#ifdef CONFIG_DAMON_KUNIT_TEST\n\n#ifndef _DAMON_CORE_TEST_H\n#define _DAMON_CORE_TEST_H\n\n#include <kunit/test.h>\n\nstatic void damon_test_regions(struct kunit *test)\n{\n\tstruct damon_region *r;\n\tstruct damon_target *t;\n\n\tr = damon_new_region(1, 2);\n\tKUNIT_EXPECT_EQ(test, 1ul, r->ar.start);\n\tKUNIT_EXPECT_EQ(test, 2ul, r->ar.end);\n\tKUNIT_EXPECT_EQ(test, 0u, r->nr_accesses);\n\n\tt = damon_new_target();\n\tKUNIT_EXPECT_EQ(test, 0u, damon_nr_regions(t));\n\n\tdamon_add_region(r, t);\n\tKUNIT_EXPECT_EQ(test, 1u, damon_nr_regions(t));\n\n\tdamon_del_region(r, t);\n\tKUNIT_EXPECT_EQ(test, 0u, damon_nr_regions(t));\n\n\tdamon_free_target(t);\n}\n\nstatic unsigned int nr_damon_targets(struct damon_ctx *ctx)\n{\n\tstruct damon_target *t;\n\tunsigned int nr_targets = 0;\n\n\tdamon_for_each_target(t, ctx)\n\t\tnr_targets++;\n\n\treturn nr_targets;\n}\n\nstatic void damon_test_target(struct kunit *test)\n{\n\tstruct damon_ctx *c = damon_new_ctx();\n\tstruct damon_target *t;\n\n\tt = damon_new_target();\n\tKUNIT_EXPECT_EQ(test, 0u, nr_damon_targets(c));\n\n\tdamon_add_target(c, t);\n\tKUNIT_EXPECT_EQ(test, 1u, nr_damon_targets(c));\n\n\tdamon_destroy_target(t);\n\tKUNIT_EXPECT_EQ(test, 0u, nr_damon_targets(c));\n\n\tdamon_destroy_ctx(c);\n}\n\n \nstatic void damon_test_aggregate(struct kunit *test)\n{\n\tstruct damon_ctx *ctx = damon_new_ctx();\n\tunsigned long saddr[][3] = {{10, 20, 30}, {5, 42, 49}, {13, 33, 55} };\n\tunsigned long eaddr[][3] = {{15, 27, 40}, {31, 45, 55}, {23, 44, 66} };\n\tunsigned long accesses[][3] = {{42, 95, 84}, {10, 20, 30}, {0, 1, 2} };\n\tstruct damon_target *t;\n\tstruct damon_region *r;\n\tint it, ir;\n\n\tfor (it = 0; it < 3; it++) {\n\t\tt = damon_new_target();\n\t\tdamon_add_target(ctx, t);\n\t}\n\n\tit = 0;\n\tdamon_for_each_target(t, ctx) {\n\t\tfor (ir = 0; ir < 3; ir++) {\n\t\t\tr = damon_new_region(saddr[it][ir], eaddr[it][ir]);\n\t\t\tr->nr_accesses = accesses[it][ir];\n\t\t\tdamon_add_region(r, t);\n\t\t}\n\t\tit++;\n\t}\n\tkdamond_reset_aggregated(ctx);\n\tit = 0;\n\tdamon_for_each_target(t, ctx) {\n\t\tir = 0;\n\t\t \n\t\tdamon_for_each_region(r, t) {\n\t\t\tKUNIT_EXPECT_EQ(test, 0u, r->nr_accesses);\n\t\t\tir++;\n\t\t}\n\t\t \n\t\tKUNIT_EXPECT_EQ(test, 3, ir);\n\t\tit++;\n\t}\n\t \n\tKUNIT_EXPECT_EQ(test, 3, it);\n\n\tdamon_destroy_ctx(ctx);\n}\n\nstatic void damon_test_split_at(struct kunit *test)\n{\n\tstruct damon_ctx *c = damon_new_ctx();\n\tstruct damon_target *t;\n\tstruct damon_region *r;\n\n\tt = damon_new_target();\n\tr = damon_new_region(0, 100);\n\tdamon_add_region(r, t);\n\tdamon_split_region_at(t, r, 25);\n\tKUNIT_EXPECT_EQ(test, r->ar.start, 0ul);\n\tKUNIT_EXPECT_EQ(test, r->ar.end, 25ul);\n\n\tr = damon_next_region(r);\n\tKUNIT_EXPECT_EQ(test, r->ar.start, 25ul);\n\tKUNIT_EXPECT_EQ(test, r->ar.end, 100ul);\n\n\tdamon_free_target(t);\n\tdamon_destroy_ctx(c);\n}\n\nstatic void damon_test_merge_two(struct kunit *test)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r, *r2, *r3;\n\tint i;\n\n\tt = damon_new_target();\n\tr = damon_new_region(0, 100);\n\tr->nr_accesses = 10;\n\tdamon_add_region(r, t);\n\tr2 = damon_new_region(100, 300);\n\tr2->nr_accesses = 20;\n\tdamon_add_region(r2, t);\n\n\tdamon_merge_two_regions(t, r, r2);\n\tKUNIT_EXPECT_EQ(test, r->ar.start, 0ul);\n\tKUNIT_EXPECT_EQ(test, r->ar.end, 300ul);\n\tKUNIT_EXPECT_EQ(test, r->nr_accesses, 16u);\n\n\ti = 0;\n\tdamon_for_each_region(r3, t) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, r, r3);\n\t\ti++;\n\t}\n\tKUNIT_EXPECT_EQ(test, i, 1);\n\n\tdamon_free_target(t);\n}\n\nstatic struct damon_region *__nth_region_of(struct damon_target *t, int idx)\n{\n\tstruct damon_region *r;\n\tunsigned int i = 0;\n\n\tdamon_for_each_region(r, t) {\n\t\tif (i++ == idx)\n\t\t\treturn r;\n\t}\n\n\treturn NULL;\n}\n\nstatic void damon_test_merge_regions_of(struct kunit *test)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r;\n\tunsigned long sa[] = {0, 100, 114, 122, 130, 156, 170, 184};\n\tunsigned long ea[] = {100, 112, 122, 130, 156, 170, 184, 230};\n\tunsigned int nrs[] = {0, 0, 10, 10, 20, 30, 1, 2};\n\n\tunsigned long saddrs[] = {0, 114, 130, 156, 170};\n\tunsigned long eaddrs[] = {112, 130, 156, 170, 230};\n\tint i;\n\n\tt = damon_new_target();\n\tfor (i = 0; i < ARRAY_SIZE(sa); i++) {\n\t\tr = damon_new_region(sa[i], ea[i]);\n\t\tr->nr_accesses = nrs[i];\n\t\tdamon_add_region(r, t);\n\t}\n\n\tdamon_merge_regions_of(t, 9, 9999);\n\t \n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 5u);\n\tfor (i = 0; i < 5; i++) {\n\t\tr = __nth_region_of(t, i);\n\t\tKUNIT_EXPECT_EQ(test, r->ar.start, saddrs[i]);\n\t\tKUNIT_EXPECT_EQ(test, r->ar.end, eaddrs[i]);\n\t}\n\tdamon_free_target(t);\n}\n\nstatic void damon_test_split_regions_of(struct kunit *test)\n{\n\tstruct damon_ctx *c = damon_new_ctx();\n\tstruct damon_target *t;\n\tstruct damon_region *r;\n\n\tt = damon_new_target();\n\tr = damon_new_region(0, 22);\n\tdamon_add_region(r, t);\n\tdamon_split_regions_of(t, 2);\n\tKUNIT_EXPECT_LE(test, damon_nr_regions(t), 2u);\n\tdamon_free_target(t);\n\n\tt = damon_new_target();\n\tr = damon_new_region(0, 220);\n\tdamon_add_region(r, t);\n\tdamon_split_regions_of(t, 4);\n\tKUNIT_EXPECT_LE(test, damon_nr_regions(t), 4u);\n\tdamon_free_target(t);\n\tdamon_destroy_ctx(c);\n}\n\nstatic void damon_test_ops_registration(struct kunit *test)\n{\n\tstruct damon_ctx *c = damon_new_ctx();\n\tstruct damon_operations ops, bak;\n\n\t \n\tKUNIT_EXPECT_EQ(test, damon_select_ops(c, DAMON_OPS_VADDR), 0);\n\tKUNIT_EXPECT_EQ(test, damon_select_ops(c, DAMON_OPS_PADDR), 0);\n\n\t \n\tops.id = DAMON_OPS_VADDR;\n\tKUNIT_EXPECT_EQ(test, damon_register_ops(&ops), -EINVAL);\n\tops.id = DAMON_OPS_PADDR;\n\tKUNIT_EXPECT_EQ(test, damon_register_ops(&ops), -EINVAL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, damon_select_ops(c, NR_DAMON_OPS), -EINVAL);\n\n\t \n\tmutex_lock(&damon_ops_lock);\n\tbak = damon_registered_ops[DAMON_OPS_VADDR];\n\tdamon_registered_ops[DAMON_OPS_VADDR] = (struct damon_operations){};\n\tmutex_unlock(&damon_ops_lock);\n\n\tops.id = DAMON_OPS_VADDR;\n\tKUNIT_EXPECT_EQ(test, damon_register_ops(&ops), 0);\n\n\tmutex_lock(&damon_ops_lock);\n\tdamon_registered_ops[DAMON_OPS_VADDR] = bak;\n\tmutex_unlock(&damon_ops_lock);\n\n\t \n\tKUNIT_EXPECT_EQ(test, damon_register_ops(&ops), -EINVAL);\n}\n\nstatic void damon_test_set_regions(struct kunit *test)\n{\n\tstruct damon_target *t = damon_new_target();\n\tstruct damon_region *r1 = damon_new_region(4, 16);\n\tstruct damon_region *r2 = damon_new_region(24, 32);\n\tstruct damon_addr_range range = {.start = 8, .end = 28};\n\tunsigned long expects[] = {8, 16, 16, 24, 24, 28};\n\tint expect_idx = 0;\n\tstruct damon_region *r;\n\n\tdamon_add_region(r1, t);\n\tdamon_add_region(r2, t);\n\tdamon_set_regions(t, &range, 1);\n\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 3);\n\tdamon_for_each_region(r, t) {\n\t\tKUNIT_EXPECT_EQ(test, r->ar.start, expects[expect_idx++]);\n\t\tKUNIT_EXPECT_EQ(test, r->ar.end, expects[expect_idx++]);\n\t}\n\tdamon_destroy_target(t);\n}\n\nstatic void damon_test_update_monitoring_result(struct kunit *test)\n{\n\tstruct damon_attrs old_attrs = {\n\t\t.sample_interval = 10, .aggr_interval = 1000,};\n\tstruct damon_attrs new_attrs;\n\tstruct damon_region *r = damon_new_region(3, 7);\n\n\tr->nr_accesses = 15;\n\tr->age = 20;\n\n\tnew_attrs = (struct damon_attrs){\n\t\t.sample_interval = 100, .aggr_interval = 10000,};\n\tdamon_update_monitoring_result(r, &old_attrs, &new_attrs);\n\tKUNIT_EXPECT_EQ(test, r->nr_accesses, 15);\n\tKUNIT_EXPECT_EQ(test, r->age, 2);\n\n\tnew_attrs = (struct damon_attrs){\n\t\t.sample_interval = 1, .aggr_interval = 1000};\n\tdamon_update_monitoring_result(r, &old_attrs, &new_attrs);\n\tKUNIT_EXPECT_EQ(test, r->nr_accesses, 150);\n\tKUNIT_EXPECT_EQ(test, r->age, 2);\n\n\tnew_attrs = (struct damon_attrs){\n\t\t.sample_interval = 1, .aggr_interval = 100};\n\tdamon_update_monitoring_result(r, &old_attrs, &new_attrs);\n\tKUNIT_EXPECT_EQ(test, r->nr_accesses, 150);\n\tKUNIT_EXPECT_EQ(test, r->age, 20);\n}\n\nstatic void damon_test_set_attrs(struct kunit *test)\n{\n\tstruct damon_ctx *c = damon_new_ctx();\n\tstruct damon_attrs valid_attrs = {\n\t\t.min_nr_regions = 10, .max_nr_regions = 1000,\n\t\t.sample_interval = 5000, .aggr_interval = 100000,};\n\tstruct damon_attrs invalid_attrs;\n\n\tKUNIT_EXPECT_EQ(test, damon_set_attrs(c, &valid_attrs), 0);\n\n\tinvalid_attrs = valid_attrs;\n\tinvalid_attrs.min_nr_regions = 1;\n\tKUNIT_EXPECT_EQ(test, damon_set_attrs(c, &invalid_attrs), -EINVAL);\n\n\tinvalid_attrs = valid_attrs;\n\tinvalid_attrs.max_nr_regions = 9;\n\tKUNIT_EXPECT_EQ(test, damon_set_attrs(c, &invalid_attrs), -EINVAL);\n\n\tinvalid_attrs = valid_attrs;\n\tinvalid_attrs.aggr_interval = 4999;\n\tKUNIT_EXPECT_EQ(test, damon_set_attrs(c, &invalid_attrs), -EINVAL);\n}\n\nstatic void damos_test_new_filter(struct kunit *test)\n{\n\tstruct damos_filter *filter;\n\n\tfilter = damos_new_filter(DAMOS_FILTER_TYPE_ANON, true);\n\tKUNIT_EXPECT_EQ(test, filter->type, DAMOS_FILTER_TYPE_ANON);\n\tKUNIT_EXPECT_EQ(test, filter->matching, true);\n\tKUNIT_EXPECT_PTR_EQ(test, filter->list.prev, &filter->list);\n\tKUNIT_EXPECT_PTR_EQ(test, filter->list.next, &filter->list);\n\tdamos_destroy_filter(filter);\n}\n\nstatic void damos_test_filter_out(struct kunit *test)\n{\n\tstruct damon_target *t;\n\tstruct damon_region *r, *r2;\n\tstruct damos_filter *f;\n\n\tf = damos_new_filter(DAMOS_FILTER_TYPE_ADDR, true);\n\tf->addr_range = (struct damon_addr_range){\n\t\t.start = DAMON_MIN_REGION * 2, .end = DAMON_MIN_REGION * 6};\n\n\tt = damon_new_target();\n\tr = damon_new_region(DAMON_MIN_REGION * 3, DAMON_MIN_REGION * 5);\n\tdamon_add_region(r, t);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, __damos_filter_out(NULL, t, r, f));\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 1);\n\n\t \n\tr->ar.start = DAMON_MIN_REGION * 1;\n\tr->ar.end = DAMON_MIN_REGION * 2;\n\tKUNIT_EXPECT_FALSE(test, __damos_filter_out(NULL, t, r, f));\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 1);\n\n\t \n\tr->ar.start = DAMON_MIN_REGION * 6;\n\tr->ar.end = DAMON_MIN_REGION * 8;\n\tKUNIT_EXPECT_FALSE(test, __damos_filter_out(NULL, t, r, f));\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 1);\n\n\t \n\tr->ar.start = DAMON_MIN_REGION * 1;\n\tr->ar.end = DAMON_MIN_REGION * 4;\n\tKUNIT_EXPECT_FALSE(test, __damos_filter_out(NULL, t, r, f));\n\t \n\tKUNIT_EXPECT_EQ(test, r->ar.start, DAMON_MIN_REGION * 1);\n\tKUNIT_EXPECT_EQ(test, r->ar.end, DAMON_MIN_REGION * 2);\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 2);\n\tr2 = damon_next_region(r);\n\tKUNIT_EXPECT_EQ(test, r2->ar.start, DAMON_MIN_REGION * 2);\n\tKUNIT_EXPECT_EQ(test, r2->ar.end, DAMON_MIN_REGION * 4);\n\tdamon_destroy_region(r2, t);\n\n\t \n\tr->ar.start = DAMON_MIN_REGION * 2;\n\tr->ar.end = DAMON_MIN_REGION * 8;\n\tKUNIT_EXPECT_TRUE(test, __damos_filter_out(NULL, t, r, f));\n\t \n\tKUNIT_EXPECT_EQ(test, r->ar.start, DAMON_MIN_REGION * 2);\n\tKUNIT_EXPECT_EQ(test, r->ar.end, DAMON_MIN_REGION * 6);\n\tKUNIT_EXPECT_EQ(test, damon_nr_regions(t), 2);\n\tr2 = damon_next_region(r);\n\tKUNIT_EXPECT_EQ(test, r2->ar.start, DAMON_MIN_REGION * 6);\n\tKUNIT_EXPECT_EQ(test, r2->ar.end, DAMON_MIN_REGION * 8);\n\tdamon_destroy_region(r2, t);\n\n\tdamon_free_target(t);\n\tdamos_free_filter(f);\n}\n\nstatic struct kunit_case damon_test_cases[] = {\n\tKUNIT_CASE(damon_test_target),\n\tKUNIT_CASE(damon_test_regions),\n\tKUNIT_CASE(damon_test_aggregate),\n\tKUNIT_CASE(damon_test_split_at),\n\tKUNIT_CASE(damon_test_merge_two),\n\tKUNIT_CASE(damon_test_merge_regions_of),\n\tKUNIT_CASE(damon_test_split_regions_of),\n\tKUNIT_CASE(damon_test_ops_registration),\n\tKUNIT_CASE(damon_test_set_regions),\n\tKUNIT_CASE(damon_test_update_monitoring_result),\n\tKUNIT_CASE(damon_test_set_attrs),\n\tKUNIT_CASE(damos_test_new_filter),\n\tKUNIT_CASE(damos_test_filter_out),\n\t{},\n};\n\nstatic struct kunit_suite damon_test_suite = {\n\t.name = \"damon\",\n\t.test_cases = damon_test_cases,\n};\nkunit_test_suite(damon_test_suite);\n\n#endif  \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}