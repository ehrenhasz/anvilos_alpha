{
  "module_name": "lru_sort.c",
  "hash_id": "2475b93bb298dee7ff6cef3f6a92ff016f5682e283a9af6559e11b0295962b01",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/lru_sort.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"damon-lru-sort: \" fmt\n\n#include <linux/damon.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n\n#include \"modules-common.h\"\n\n#ifdef MODULE_PARAM_PREFIX\n#undef MODULE_PARAM_PREFIX\n#endif\n#define MODULE_PARAM_PREFIX \"damon_lru_sort.\"\n\n \nstatic bool enabled __read_mostly;\n\n \nstatic bool commit_inputs __read_mostly;\nmodule_param(commit_inputs, bool, 0600);\n\n \nstatic unsigned long hot_thres_access_freq = 500;\nmodule_param(hot_thres_access_freq, ulong, 0600);\n\n \nstatic unsigned long cold_min_age __read_mostly = 120000000;\nmodule_param(cold_min_age, ulong, 0600);\n\nstatic struct damos_quota damon_lru_sort_quota = {\n\t \n\t.ms = 10,\n\t.sz = 0,\n\t.reset_interval = 1000,\n\t \n\t.weight_sz = 0,\n\t.weight_nr_accesses = 1,\n\t.weight_age = 0,\n};\nDEFINE_DAMON_MODULES_DAMOS_TIME_QUOTA(damon_lru_sort_quota);\n\nstatic struct damos_watermarks damon_lru_sort_wmarks = {\n\t.metric = DAMOS_WMARK_FREE_MEM_RATE,\n\t.interval = 5000000,\t \n\t.high = 200,\t\t \n\t.mid = 150,\t\t \n\t.low = 50,\t\t \n};\nDEFINE_DAMON_MODULES_WMARKS_PARAMS(damon_lru_sort_wmarks);\n\nstatic struct damon_attrs damon_lru_sort_mon_attrs = {\n\t.sample_interval = 5000,\t \n\t.aggr_interval = 100000,\t \n\t.ops_update_interval = 0,\n\t.min_nr_regions = 10,\n\t.max_nr_regions = 1000,\n};\nDEFINE_DAMON_MODULES_MON_ATTRS_PARAMS(damon_lru_sort_mon_attrs);\n\n \nstatic unsigned long monitor_region_start __read_mostly;\nmodule_param(monitor_region_start, ulong, 0600);\n\n \nstatic unsigned long monitor_region_end __read_mostly;\nmodule_param(monitor_region_end, ulong, 0600);\n\n \nstatic int kdamond_pid __read_mostly = -1;\nmodule_param(kdamond_pid, int, 0400);\n\nstatic struct damos_stat damon_lru_sort_hot_stat;\nDEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_lru_sort_hot_stat,\n\t\tlru_sort_tried_hot_regions, lru_sorted_hot_regions,\n\t\thot_quota_exceeds);\n\nstatic struct damos_stat damon_lru_sort_cold_stat;\nDEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_lru_sort_cold_stat,\n\t\tlru_sort_tried_cold_regions, lru_sorted_cold_regions,\n\t\tcold_quota_exceeds);\n\nstatic struct damos_access_pattern damon_lru_sort_stub_pattern = {\n\t \n\t.min_sz_region = PAGE_SIZE,\n\t.max_sz_region = ULONG_MAX,\n\t \n\t.min_nr_accesses = 0,\n\t.max_nr_accesses = UINT_MAX,\n\t \n\t.min_age_region = 0,\n\t.max_age_region = UINT_MAX,\n};\n\nstatic struct damon_ctx *ctx;\nstatic struct damon_target *target;\n\nstatic struct damos *damon_lru_sort_new_scheme(\n\t\tstruct damos_access_pattern *pattern, enum damos_action action)\n{\n\tstruct damos_quota quota = damon_lru_sort_quota;\n\n\t \n\tquota.ms = quota.ms / 2;\n\n\treturn damon_new_scheme(\n\t\t\t \n\t\t\tpattern,\n\t\t\t \n\t\t\taction,\n\t\t\t \n\t\t\t&quota,\n\t\t\t \n\t\t\t&damon_lru_sort_wmarks);\n}\n\n \nstatic struct damos *damon_lru_sort_new_hot_scheme(unsigned int hot_thres)\n{\n\tstruct damos_access_pattern pattern = damon_lru_sort_stub_pattern;\n\n\tpattern.min_nr_accesses = hot_thres;\n\treturn damon_lru_sort_new_scheme(&pattern, DAMOS_LRU_PRIO);\n}\n\n \nstatic struct damos *damon_lru_sort_new_cold_scheme(unsigned int cold_thres)\n{\n\tstruct damos_access_pattern pattern = damon_lru_sort_stub_pattern;\n\n\tpattern.max_nr_accesses = 0;\n\tpattern.min_age_region = cold_thres;\n\treturn damon_lru_sort_new_scheme(&pattern, DAMOS_LRU_DEPRIO);\n}\n\nstatic int damon_lru_sort_apply_parameters(void)\n{\n\tstruct damos *scheme;\n\tunsigned int hot_thres, cold_thres;\n\tint err = 0;\n\n\terr = damon_set_attrs(ctx, &damon_lru_sort_mon_attrs);\n\tif (err)\n\t\treturn err;\n\n\thot_thres = damon_max_nr_accesses(&damon_lru_sort_mon_attrs) *\n\t\thot_thres_access_freq / 1000;\n\tscheme = damon_lru_sort_new_hot_scheme(hot_thres);\n\tif (!scheme)\n\t\treturn -ENOMEM;\n\tdamon_set_schemes(ctx, &scheme, 1);\n\n\tcold_thres = cold_min_age / damon_lru_sort_mon_attrs.aggr_interval;\n\tscheme = damon_lru_sort_new_cold_scheme(cold_thres);\n\tif (!scheme)\n\t\treturn -ENOMEM;\n\tdamon_add_scheme(ctx, scheme);\n\n\treturn damon_set_region_biggest_system_ram_default(target,\n\t\t\t\t\t&monitor_region_start,\n\t\t\t\t\t&monitor_region_end);\n}\n\nstatic int damon_lru_sort_turn(bool on)\n{\n\tint err;\n\n\tif (!on) {\n\t\terr = damon_stop(&ctx, 1);\n\t\tif (!err)\n\t\t\tkdamond_pid = -1;\n\t\treturn err;\n\t}\n\n\terr = damon_lru_sort_apply_parameters();\n\tif (err)\n\t\treturn err;\n\n\terr = damon_start(&ctx, 1, true);\n\tif (err)\n\t\treturn err;\n\tkdamond_pid = ctx->kdamond->pid;\n\treturn 0;\n}\n\nstatic int damon_lru_sort_enabled_store(const char *val,\n\t\tconst struct kernel_param *kp)\n{\n\tbool is_enabled = enabled;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool(val, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (is_enabled == enable)\n\t\treturn 0;\n\n\t \n\tif (!ctx)\n\t\tgoto set_param_out;\n\n\terr = damon_lru_sort_turn(enable);\n\tif (err)\n\t\treturn err;\n\nset_param_out:\n\tenabled = enable;\n\treturn err;\n}\n\nstatic const struct kernel_param_ops enabled_param_ops = {\n\t.set = damon_lru_sort_enabled_store,\n\t.get = param_get_bool,\n};\n\nmodule_param_cb(enabled, &enabled_param_ops, &enabled, 0600);\nMODULE_PARM_DESC(enabled,\n\t\"Enable or disable DAMON_LRU_SORT (default: disabled)\");\n\nstatic int damon_lru_sort_handle_commit_inputs(void)\n{\n\tint err;\n\n\tif (!commit_inputs)\n\t\treturn 0;\n\n\terr = damon_lru_sort_apply_parameters();\n\tcommit_inputs = false;\n\treturn err;\n}\n\nstatic int damon_lru_sort_after_aggregation(struct damon_ctx *c)\n{\n\tstruct damos *s;\n\n\t \n\tdamon_for_each_scheme(s, c) {\n\t\tif (s->action == DAMOS_LRU_PRIO)\n\t\t\tdamon_lru_sort_hot_stat = s->stat;\n\t\telse if (s->action == DAMOS_LRU_DEPRIO)\n\t\t\tdamon_lru_sort_cold_stat = s->stat;\n\t}\n\n\treturn damon_lru_sort_handle_commit_inputs();\n}\n\nstatic int damon_lru_sort_after_wmarks_check(struct damon_ctx *c)\n{\n\treturn damon_lru_sort_handle_commit_inputs();\n}\n\nstatic int __init damon_lru_sort_init(void)\n{\n\tint err = damon_modules_new_paddr_ctx_target(&ctx, &target);\n\n\tif (err)\n\t\treturn err;\n\n\tctx->callback.after_wmarks_check = damon_lru_sort_after_wmarks_check;\n\tctx->callback.after_aggregation = damon_lru_sort_after_aggregation;\n\n\t \n\tif (enabled)\n\t\terr = damon_lru_sort_turn(true);\n\n\treturn err;\n}\n\nmodule_init(damon_lru_sort_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}