{
  "module_name": "reclaim.c",
  "hash_id": "a061745c97dad39088dc38bc83e64a56d16815748e32f666adf725d1eb045d97",
  "original_prompt": "Ingested from linux-6.6.14/mm/damon/reclaim.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"damon-reclaim: \" fmt\n\n#include <linux/damon.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n\n#include \"modules-common.h\"\n\n#ifdef MODULE_PARAM_PREFIX\n#undef MODULE_PARAM_PREFIX\n#endif\n#define MODULE_PARAM_PREFIX \"damon_reclaim.\"\n\n \nstatic bool enabled __read_mostly;\n\n \nstatic bool commit_inputs __read_mostly;\nmodule_param(commit_inputs, bool, 0600);\n\n \nstatic unsigned long min_age __read_mostly = 120000000;\nmodule_param(min_age, ulong, 0600);\n\nstatic struct damos_quota damon_reclaim_quota = {\n\t \n\t.ms = 10,\n\t.sz = 128 * 1024 * 1024,\n\t.reset_interval = 1000,\n\t \n\t.weight_sz = 0,\n\t.weight_nr_accesses = 0,\n\t.weight_age = 1\n};\nDEFINE_DAMON_MODULES_DAMOS_QUOTAS(damon_reclaim_quota);\n\nstatic struct damos_watermarks damon_reclaim_wmarks = {\n\t.metric = DAMOS_WMARK_FREE_MEM_RATE,\n\t.interval = 5000000,\t \n\t.high = 500,\t\t \n\t.mid = 400,\t\t \n\t.low = 200,\t\t \n};\nDEFINE_DAMON_MODULES_WMARKS_PARAMS(damon_reclaim_wmarks);\n\nstatic struct damon_attrs damon_reclaim_mon_attrs = {\n\t.sample_interval = 5000,\t \n\t.aggr_interval = 100000,\t \n\t.ops_update_interval = 0,\n\t.min_nr_regions = 10,\n\t.max_nr_regions = 1000,\n};\nDEFINE_DAMON_MODULES_MON_ATTRS_PARAMS(damon_reclaim_mon_attrs);\n\n \nstatic unsigned long monitor_region_start __read_mostly;\nmodule_param(monitor_region_start, ulong, 0600);\n\n \nstatic unsigned long monitor_region_end __read_mostly;\nmodule_param(monitor_region_end, ulong, 0600);\n\n \nstatic bool skip_anon __read_mostly;\nmodule_param(skip_anon, bool, 0600);\n\n \nstatic int kdamond_pid __read_mostly = -1;\nmodule_param(kdamond_pid, int, 0400);\n\nstatic struct damos_stat damon_reclaim_stat;\nDEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_reclaim_stat,\n\t\treclaim_tried_regions, reclaimed_regions, quota_exceeds);\n\nstatic struct damon_ctx *ctx;\nstatic struct damon_target *target;\n\nstatic struct damos *damon_reclaim_new_scheme(void)\n{\n\tstruct damos_access_pattern pattern = {\n\t\t \n\t\t.min_sz_region = PAGE_SIZE,\n\t\t.max_sz_region = ULONG_MAX,\n\t\t \n\t\t.min_nr_accesses = 0,\n\t\t.max_nr_accesses = 0,\n\t\t \n\t\t.min_age_region = min_age /\n\t\t\tdamon_reclaim_mon_attrs.aggr_interval,\n\t\t.max_age_region = UINT_MAX,\n\t};\n\n\treturn damon_new_scheme(\n\t\t\t&pattern,\n\t\t\t \n\t\t\tDAMOS_PAGEOUT,\n\t\t\t \n\t\t\t&damon_reclaim_quota,\n\t\t\t \n\t\t\t&damon_reclaim_wmarks);\n}\n\nstatic int damon_reclaim_apply_parameters(void)\n{\n\tstruct damos *scheme;\n\tstruct damos_filter *filter;\n\tint err = 0;\n\n\terr = damon_set_attrs(ctx, &damon_reclaim_mon_attrs);\n\tif (err)\n\t\treturn err;\n\n\t \n\tscheme = damon_reclaim_new_scheme();\n\tif (!scheme)\n\t\treturn -ENOMEM;\n\tif (skip_anon) {\n\t\tfilter = damos_new_filter(DAMOS_FILTER_TYPE_ANON, true);\n\t\tif (!filter) {\n\t\t\t \n\t\t\tdamon_destroy_scheme(scheme);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdamos_add_filter(scheme, filter);\n\t}\n\tdamon_set_schemes(ctx, &scheme, 1);\n\n\treturn damon_set_region_biggest_system_ram_default(target,\n\t\t\t\t\t&monitor_region_start,\n\t\t\t\t\t&monitor_region_end);\n}\n\nstatic int damon_reclaim_turn(bool on)\n{\n\tint err;\n\n\tif (!on) {\n\t\terr = damon_stop(&ctx, 1);\n\t\tif (!err)\n\t\t\tkdamond_pid = -1;\n\t\treturn err;\n\t}\n\n\terr = damon_reclaim_apply_parameters();\n\tif (err)\n\t\treturn err;\n\n\terr = damon_start(&ctx, 1, true);\n\tif (err)\n\t\treturn err;\n\tkdamond_pid = ctx->kdamond->pid;\n\treturn 0;\n}\n\nstatic int damon_reclaim_enabled_store(const char *val,\n\t\tconst struct kernel_param *kp)\n{\n\tbool is_enabled = enabled;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool(val, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (is_enabled == enable)\n\t\treturn 0;\n\n\t \n\tif (!ctx)\n\t\tgoto set_param_out;\n\n\terr = damon_reclaim_turn(enable);\n\tif (err)\n\t\treturn err;\n\nset_param_out:\n\tenabled = enable;\n\treturn err;\n}\n\nstatic const struct kernel_param_ops enabled_param_ops = {\n\t.set = damon_reclaim_enabled_store,\n\t.get = param_get_bool,\n};\n\nmodule_param_cb(enabled, &enabled_param_ops, &enabled, 0600);\nMODULE_PARM_DESC(enabled,\n\t\"Enable or disable DAMON_RECLAIM (default: disabled)\");\n\nstatic int damon_reclaim_handle_commit_inputs(void)\n{\n\tint err;\n\n\tif (!commit_inputs)\n\t\treturn 0;\n\n\terr = damon_reclaim_apply_parameters();\n\tcommit_inputs = false;\n\treturn err;\n}\n\nstatic int damon_reclaim_after_aggregation(struct damon_ctx *c)\n{\n\tstruct damos *s;\n\n\t \n\tdamon_for_each_scheme(s, c)\n\t\tdamon_reclaim_stat = s->stat;\n\n\treturn damon_reclaim_handle_commit_inputs();\n}\n\nstatic int damon_reclaim_after_wmarks_check(struct damon_ctx *c)\n{\n\treturn damon_reclaim_handle_commit_inputs();\n}\n\nstatic int __init damon_reclaim_init(void)\n{\n\tint err = damon_modules_new_paddr_ctx_target(&ctx, &target);\n\n\tif (err)\n\t\treturn err;\n\n\tctx->callback.after_wmarks_check = damon_reclaim_after_wmarks_check;\n\tctx->callback.after_aggregation = damon_reclaim_after_aggregation;\n\n\t \n\tif (enabled)\n\t\terr = damon_reclaim_turn(true);\n\n\treturn err;\n}\n\nmodule_init(damon_reclaim_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}