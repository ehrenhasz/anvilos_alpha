{
  "module_name": "mincore.c",
  "hash_id": "14c00ca2df97a437f8561c1ea5b5a202116e5d3aaf862110d60af075d1940c1c",
  "original_prompt": "Ingested from linux-6.6.14/mm/mincore.c",
  "human_readable_source": "\n \n\n \n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/pagewalk.h>\n#include <linux/mman.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/pgtable.h>\n\n#include <linux/uaccess.h>\n#include \"swap.h\"\n\nstatic int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tunsigned char present;\n\tunsigned char *vec = walk->private;\n\n\t \n\tpresent = pte && !huge_pte_none_mostly(huge_ptep_get(pte));\n\tfor (; addr != end; vec++, addr += PAGE_SIZE)\n\t\t*vec = present;\n\twalk->private = vec;\n#else\n\tBUG();\n#endif\n\treturn 0;\n}\n\n \nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t index)\n{\n\tunsigned char present = 0;\n\tstruct folio *folio;\n\n\t \n\tfolio = filemap_get_incore_folio(mapping, index);\n\tif (!IS_ERR(folio)) {\n\t\tpresent = folio_test_uptodate(folio);\n\t\tfolio_put(folio);\n\t}\n\n\treturn present;\n}\n\nstatic int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}\n\nstatic int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   __always_unused int depth,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}\n\nstatic int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tif (!ptep) {\n\t\twalk->action = ACTION_AGAIN;\n\t\treturn 0;\n\t}\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = ptep_get(ptep);\n\n\t\t \n\t\tif (pte_none_mostly(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse {  \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t \n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n\nstatic inline bool can_do_mincore(struct vm_area_struct *vma)\n{\n\tif (vma_is_anonymous(vma))\n\t\treturn true;\n\tif (!vma->vm_file)\n\t\treturn false;\n\t \n\treturn inode_owner_or_capable(&nop_mnt_idmap,\n\t\t\t\t      file_inode(vma->vm_file)) ||\n\t       file_permission(vma->vm_file, MAY_WRITE) == 0;\n}\n\nstatic const struct mm_walk_ops mincore_walk_ops = {\n\t.pmd_entry\t\t= mincore_pte_range,\n\t.pte_hole\t\t= mincore_unmapped_range,\n\t.hugetlb_entry\t\t= mincore_hugetlb,\n\t.walk_lock\t\t= PGWALK_RDLOCK,\n};\n\n \nstatic long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint err;\n\n\tvma = vma_lookup(current->mm, addr);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tend = min(vma->vm_end, addr + (pages << PAGE_SHIFT));\n\tif (!can_do_mincore(vma)) {\n\t\tunsigned long pages = DIV_ROUND_UP(end - addr, PAGE_SIZE);\n\t\tmemset(vec, 1, pages);\n\t\treturn pages;\n\t}\n\terr = walk_page_range(vma->vm_mm, addr, end, &mincore_walk_ops, vec);\n\tif (err < 0)\n\t\treturn err;\n\treturn (end - addr) >> PAGE_SHIFT;\n}\n\n \nSYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,\n\t\tunsigned char __user *, vec)\n{\n\tlong retval;\n\tunsigned long pages;\n\tunsigned char *tmp;\n\n\tstart = untagged_addr(start);\n\n\t \n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\t \n\tif (!access_ok((void __user *) start, len))\n\t\treturn -ENOMEM;\n\n\t \n\tpages = len >> PAGE_SHIFT;\n\tpages += (offset_in_page(len)) != 0;\n\n\tif (!access_ok(vec, pages))\n\t\treturn -EFAULT;\n\n\ttmp = (void *) __get_free_page(GFP_USER);\n\tif (!tmp)\n\t\treturn -EAGAIN;\n\n\tretval = 0;\n\twhile (pages) {\n\t\t \n\t\tmmap_read_lock(current->mm);\n\t\tretval = do_mincore(start, min(pages, PAGE_SIZE), tmp);\n\t\tmmap_read_unlock(current->mm);\n\n\t\tif (retval <= 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(vec, tmp, retval)) {\n\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpages -= retval;\n\t\tvec += retval;\n\t\tstart += retval << PAGE_SHIFT;\n\t\tretval = 0;\n\t}\n\tfree_page((unsigned long) tmp);\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}