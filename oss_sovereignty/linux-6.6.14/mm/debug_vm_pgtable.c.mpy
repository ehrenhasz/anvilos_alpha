{
  "module_name": "debug_vm_pgtable.c",
  "hash_id": "129c73ffb5b064ac1ec2abc94c13c82b9182e75b0e7d078d32de8eb12a58a392",
  "original_prompt": "Ingested from linux-6.6.14/mm/debug_vm_pgtable.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"debug_vm_pgtable: [%-25s]: \" fmt, __func__\n\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/kernel.h>\n#include <linux/kconfig.h>\n#include <linux/memblock.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mm_types.h>\n#include <linux/module.h>\n#include <linux/pfn_t.h>\n#include <linux/printk.h>\n#include <linux/pgtable.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/start_kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/io.h>\n\n#include <asm/cacheflush.h>\n#include <asm/pgalloc.h>\n#include <asm/tlbflush.h>\n\n \n#define S390_SKIP_MASK\t\tGENMASK(3, 0)\n#if __BITS_PER_LONG == 64\n#define PPC64_SKIP_MASK\t\tGENMASK(62, 62)\n#else\n#define PPC64_SKIP_MASK\t\t0x0\n#endif\n#define ARCH_SKIP_MASK (S390_SKIP_MASK | PPC64_SKIP_MASK)\n#define RANDOM_ORVALUE (GENMASK(BITS_PER_LONG - 1, 0) & ~ARCH_SKIP_MASK)\n#define RANDOM_NZVALUE\tGENMASK(7, 0)\n\nstruct pgtable_debug_args {\n\tstruct mm_struct\t*mm;\n\tstruct vm_area_struct\t*vma;\n\n\tpgd_t\t\t\t*pgdp;\n\tp4d_t\t\t\t*p4dp;\n\tpud_t\t\t\t*pudp;\n\tpmd_t\t\t\t*pmdp;\n\tpte_t\t\t\t*ptep;\n\n\tp4d_t\t\t\t*start_p4dp;\n\tpud_t\t\t\t*start_pudp;\n\tpmd_t\t\t\t*start_pmdp;\n\tpgtable_t\t\tstart_ptep;\n\n\tunsigned long\t\tvaddr;\n\tpgprot_t\t\tpage_prot;\n\tpgprot_t\t\tpage_prot_none;\n\n\tbool\t\t\tis_contiguous_page;\n\tunsigned long\t\tpud_pfn;\n\tunsigned long\t\tpmd_pfn;\n\tunsigned long\t\tpte_pfn;\n\n\tunsigned long\t\tfixed_alignment;\n\tunsigned long\t\tfixed_pgd_pfn;\n\tunsigned long\t\tfixed_p4d_pfn;\n\tunsigned long\t\tfixed_pud_pfn;\n\tunsigned long\t\tfixed_pmd_pfn;\n\tunsigned long\t\tfixed_pte_pfn;\n};\n\nstatic void __init pte_basic_tests(struct pgtable_debug_args *args, int idx)\n{\n\tpgprot_t prot = vm_get_page_prot(idx);\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, prot);\n\tunsigned long val = idx, *ptr = &val;\n\n\tpr_debug(\"Validating PTE basic (%pGv)\\n\", ptr);\n\n\t \n\tWARN_ON(pte_dirty(pte_wrprotect(pte)));\n\n\tWARN_ON(!pte_same(pte, pte));\n\tWARN_ON(!pte_young(pte_mkyoung(pte_mkold(pte))));\n\tWARN_ON(!pte_dirty(pte_mkdirty(pte_mkclean(pte))));\n\tWARN_ON(!pte_write(pte_mkwrite(pte_wrprotect(pte), args->vma)));\n\tWARN_ON(pte_young(pte_mkold(pte_mkyoung(pte))));\n\tWARN_ON(pte_dirty(pte_mkclean(pte_mkdirty(pte))));\n\tWARN_ON(pte_write(pte_wrprotect(pte_mkwrite(pte, args->vma))));\n\tWARN_ON(pte_dirty(pte_wrprotect(pte_mkclean(pte))));\n\tWARN_ON(!pte_dirty(pte_wrprotect(pte_mkdirty(pte))));\n}\n\nstatic void __init pte_advanced_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tpte_t pte;\n\n\t \n\tpage = (args->pte_pfn != ULONG_MAX) ? pfn_to_page(args->pte_pfn) : NULL;\n\tif (!page)\n\t\treturn;\n\n\tpr_debug(\"Validating PTE advanced\\n\");\n\tif (WARN_ON(!args->ptep))\n\t\treturn;\n\n\tpte = pfn_pte(args->pte_pfn, args->page_prot);\n\tset_pte_at(args->mm, args->vaddr, args->ptep, pte);\n\tflush_dcache_page(page);\n\tptep_set_wrprotect(args->mm, args->vaddr, args->ptep);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(pte_write(pte));\n\tptep_get_and_clear(args->mm, args->vaddr, args->ptep);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(!pte_none(pte));\n\n\tpte = pfn_pte(args->pte_pfn, args->page_prot);\n\tpte = pte_wrprotect(pte);\n\tpte = pte_mkclean(pte);\n\tset_pte_at(args->mm, args->vaddr, args->ptep, pte);\n\tflush_dcache_page(page);\n\tpte = pte_mkwrite(pte, args->vma);\n\tpte = pte_mkdirty(pte);\n\tptep_set_access_flags(args->vma, args->vaddr, args->ptep, pte, 1);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(!(pte_write(pte) && pte_dirty(pte)));\n\tptep_get_and_clear_full(args->mm, args->vaddr, args->ptep, 1);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(!pte_none(pte));\n\n\tpte = pfn_pte(args->pte_pfn, args->page_prot);\n\tpte = pte_mkyoung(pte);\n\tset_pte_at(args->mm, args->vaddr, args->ptep, pte);\n\tflush_dcache_page(page);\n\tptep_test_and_clear_young(args->vma, args->vaddr, args->ptep);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(pte_young(pte));\n\n\tptep_get_and_clear_full(args->mm, args->vaddr, args->ptep, 1);\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void __init pmd_basic_tests(struct pgtable_debug_args *args, int idx)\n{\n\tpgprot_t prot = vm_get_page_prot(idx);\n\tunsigned long val = idx, *ptr = &val;\n\tpmd_t pmd;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD basic (%pGv)\\n\", ptr);\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, prot);\n\n\t \n\tWARN_ON(pmd_dirty(pmd_wrprotect(pmd)));\n\n\n\tWARN_ON(!pmd_same(pmd, pmd));\n\tWARN_ON(!pmd_young(pmd_mkyoung(pmd_mkold(pmd))));\n\tWARN_ON(!pmd_dirty(pmd_mkdirty(pmd_mkclean(pmd))));\n\tWARN_ON(!pmd_write(pmd_mkwrite(pmd_wrprotect(pmd), args->vma)));\n\tWARN_ON(pmd_young(pmd_mkold(pmd_mkyoung(pmd))));\n\tWARN_ON(pmd_dirty(pmd_mkclean(pmd_mkdirty(pmd))));\n\tWARN_ON(pmd_write(pmd_wrprotect(pmd_mkwrite(pmd, args->vma))));\n\tWARN_ON(pmd_dirty(pmd_wrprotect(pmd_mkclean(pmd))));\n\tWARN_ON(!pmd_dirty(pmd_wrprotect(pmd_mkdirty(pmd))));\n\t \n\tWARN_ON(!pmd_bad(pmd_mkhuge(pmd)));\n}\n\nstatic void __init pmd_advanced_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tpmd_t pmd;\n\tunsigned long vaddr = args->vaddr;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpage = (args->pmd_pfn != ULONG_MAX) ? pfn_to_page(args->pmd_pfn) : NULL;\n\tif (!page)\n\t\treturn;\n\n\t \n\tpr_debug(\"Validating PMD advanced\\n\");\n\t \n\tvaddr &= HPAGE_PMD_MASK;\n\n\tpgtable_trans_huge_deposit(args->mm, args->pmdp, args->start_ptep);\n\n\tpmd = pfn_pmd(args->pmd_pfn, args->page_prot);\n\tset_pmd_at(args->mm, vaddr, args->pmdp, pmd);\n\tflush_dcache_page(page);\n\tpmdp_set_wrprotect(args->mm, vaddr, args->pmdp);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(pmd_write(pmd));\n\tpmdp_huge_get_and_clear(args->mm, vaddr, args->pmdp);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(!pmd_none(pmd));\n\n\tpmd = pfn_pmd(args->pmd_pfn, args->page_prot);\n\tpmd = pmd_wrprotect(pmd);\n\tpmd = pmd_mkclean(pmd);\n\tset_pmd_at(args->mm, vaddr, args->pmdp, pmd);\n\tflush_dcache_page(page);\n\tpmd = pmd_mkwrite(pmd, args->vma);\n\tpmd = pmd_mkdirty(pmd);\n\tpmdp_set_access_flags(args->vma, vaddr, args->pmdp, pmd, 1);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(!(pmd_write(pmd) && pmd_dirty(pmd)));\n\tpmdp_huge_get_and_clear_full(args->vma, vaddr, args->pmdp, 1);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(!pmd_none(pmd));\n\n\tpmd = pmd_mkhuge(pfn_pmd(args->pmd_pfn, args->page_prot));\n\tpmd = pmd_mkyoung(pmd);\n\tset_pmd_at(args->mm, vaddr, args->pmdp, pmd);\n\tflush_dcache_page(page);\n\tpmdp_test_and_clear_young(args->vma, vaddr, args->pmdp);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(pmd_young(pmd));\n\n\t \n\tpmdp_huge_get_and_clear(args->mm, vaddr, args->pmdp);\n\tpgtable_trans_huge_withdraw(args->mm, args->pmdp);\n}\n\nstatic void __init pmd_leaf_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD leaf\\n\");\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\n\t \n\tpmd = pmd_mkhuge(pmd);\n\tWARN_ON(!pmd_leaf(pmd));\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nstatic void __init pud_basic_tests(struct pgtable_debug_args *args, int idx)\n{\n\tpgprot_t prot = vm_get_page_prot(idx);\n\tunsigned long val = idx, *ptr = &val;\n\tpud_t pud;\n\n\tif (!has_transparent_pud_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PUD basic (%pGv)\\n\", ptr);\n\tpud = pfn_pud(args->fixed_pud_pfn, prot);\n\n\t \n\tWARN_ON(pud_dirty(pud_wrprotect(pud)));\n\n\tWARN_ON(!pud_same(pud, pud));\n\tWARN_ON(!pud_young(pud_mkyoung(pud_mkold(pud))));\n\tWARN_ON(!pud_dirty(pud_mkdirty(pud_mkclean(pud))));\n\tWARN_ON(pud_dirty(pud_mkclean(pud_mkdirty(pud))));\n\tWARN_ON(!pud_write(pud_mkwrite(pud_wrprotect(pud))));\n\tWARN_ON(pud_write(pud_wrprotect(pud_mkwrite(pud))));\n\tWARN_ON(pud_young(pud_mkold(pud_mkyoung(pud))));\n\tWARN_ON(pud_dirty(pud_wrprotect(pud_mkclean(pud))));\n\tWARN_ON(!pud_dirty(pud_wrprotect(pud_mkdirty(pud))));\n\n\tif (mm_pmd_folded(args->mm))\n\t\treturn;\n\n\t \n\tWARN_ON(!pud_bad(pud_mkhuge(pud)));\n}\n\nstatic void __init pud_advanced_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tunsigned long vaddr = args->vaddr;\n\tpud_t pud;\n\n\tif (!has_transparent_pud_hugepage())\n\t\treturn;\n\n\tpage = (args->pud_pfn != ULONG_MAX) ? pfn_to_page(args->pud_pfn) : NULL;\n\tif (!page)\n\t\treturn;\n\n\t \n\tpr_debug(\"Validating PUD advanced\\n\");\n\t \n\tvaddr &= HPAGE_PUD_MASK;\n\n\tpud = pfn_pud(args->pud_pfn, args->page_prot);\n\tset_pud_at(args->mm, vaddr, args->pudp, pud);\n\tflush_dcache_page(page);\n\tpudp_set_wrprotect(args->mm, vaddr, args->pudp);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(pud_write(pud));\n\n#ifndef __PAGETABLE_PMD_FOLDED\n\tpudp_huge_get_and_clear(args->mm, vaddr, args->pudp);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(!pud_none(pud));\n#endif  \n\tpud = pfn_pud(args->pud_pfn, args->page_prot);\n\tpud = pud_wrprotect(pud);\n\tpud = pud_mkclean(pud);\n\tset_pud_at(args->mm, vaddr, args->pudp, pud);\n\tflush_dcache_page(page);\n\tpud = pud_mkwrite(pud);\n\tpud = pud_mkdirty(pud);\n\tpudp_set_access_flags(args->vma, vaddr, args->pudp, pud, 1);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(!(pud_write(pud) && pud_dirty(pud)));\n\n#ifndef __PAGETABLE_PMD_FOLDED\n\tpudp_huge_get_and_clear_full(args->vma, vaddr, args->pudp, 1);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(!pud_none(pud));\n#endif  \n\n\tpud = pfn_pud(args->pud_pfn, args->page_prot);\n\tpud = pud_mkyoung(pud);\n\tset_pud_at(args->mm, vaddr, args->pudp, pud);\n\tflush_dcache_page(page);\n\tpudp_test_and_clear_young(args->vma, vaddr, args->pudp);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(pud_young(pud));\n\n\tpudp_huge_get_and_clear(args->mm, vaddr, args->pudp);\n}\n\nstatic void __init pud_leaf_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud;\n\n\tif (!has_transparent_pud_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PUD leaf\\n\");\n\tpud = pfn_pud(args->fixed_pud_pfn, args->page_prot);\n\t \n\tpud = pud_mkhuge(pud);\n\tWARN_ON(!pud_leaf(pud));\n}\n#else   \nstatic void __init pud_basic_tests(struct pgtable_debug_args *args, int idx) { }\nstatic void __init pud_advanced_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_leaf_tests(struct pgtable_debug_args *args) { }\n#endif  \n#else   \nstatic void __init pmd_basic_tests(struct pgtable_debug_args *args, int idx) { }\nstatic void __init pud_basic_tests(struct pgtable_debug_args *args, int idx) { }\nstatic void __init pmd_advanced_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_advanced_tests(struct pgtable_debug_args *args) { }\nstatic void __init pmd_leaf_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_leaf_tests(struct pgtable_debug_args *args) { }\n#endif  \n\n#ifdef CONFIG_HAVE_ARCH_HUGE_VMAP\nstatic void __init pmd_huge_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!arch_vmap_pmd_supported(args->page_prot) ||\n\t    args->fixed_alignment < PMD_SIZE)\n\t\treturn;\n\n\tpr_debug(\"Validating PMD huge\\n\");\n\t \n\tWRITE_ONCE(*args->pmdp, __pmd(0));\n\tWARN_ON(!pmd_set_huge(args->pmdp, __pfn_to_phys(args->fixed_pmd_pfn), args->page_prot));\n\tWARN_ON(!pmd_clear_huge(args->pmdp));\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(!pmd_none(pmd));\n}\n\nstatic void __init pud_huge_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud;\n\n\tif (!arch_vmap_pud_supported(args->page_prot) ||\n\t    args->fixed_alignment < PUD_SIZE)\n\t\treturn;\n\n\tpr_debug(\"Validating PUD huge\\n\");\n\t \n\tWRITE_ONCE(*args->pudp, __pud(0));\n\tWARN_ON(!pud_set_huge(args->pudp, __pfn_to_phys(args->fixed_pud_pfn), args->page_prot));\n\tWARN_ON(!pud_clear_huge(args->pudp));\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(!pud_none(pud));\n}\n#else  \nstatic void __init pmd_huge_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_huge_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic void __init p4d_basic_tests(struct pgtable_debug_args *args)\n{\n\tp4d_t p4d;\n\n\tpr_debug(\"Validating P4D basic\\n\");\n\tmemset(&p4d, RANDOM_NZVALUE, sizeof(p4d_t));\n\tWARN_ON(!p4d_same(p4d, p4d));\n}\n\nstatic void __init pgd_basic_tests(struct pgtable_debug_args *args)\n{\n\tpgd_t pgd;\n\n\tpr_debug(\"Validating PGD basic\\n\");\n\tmemset(&pgd, RANDOM_NZVALUE, sizeof(pgd_t));\n\tWARN_ON(!pgd_same(pgd, pgd));\n}\n\n#ifndef __PAGETABLE_PUD_FOLDED\nstatic void __init pud_clear_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud = READ_ONCE(*args->pudp);\n\n\tif (mm_pmd_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating PUD clear\\n\");\n\tpud = __pud(pud_val(pud) | RANDOM_ORVALUE);\n\tWRITE_ONCE(*args->pudp, pud);\n\tpud_clear(args->pudp);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(!pud_none(pud));\n}\n\nstatic void __init pud_populate_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud;\n\n\tif (mm_pmd_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating PUD populate\\n\");\n\t \n\tpud_populate(args->mm, args->pudp, args->start_pmdp);\n\tpud = READ_ONCE(*args->pudp);\n\tWARN_ON(pud_bad(pud));\n}\n#else   \nstatic void __init pud_clear_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_populate_tests(struct pgtable_debug_args *args) { }\n#endif  \n\n#ifndef __PAGETABLE_P4D_FOLDED\nstatic void __init p4d_clear_tests(struct pgtable_debug_args *args)\n{\n\tp4d_t p4d = READ_ONCE(*args->p4dp);\n\n\tif (mm_pud_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating P4D clear\\n\");\n\tp4d = __p4d(p4d_val(p4d) | RANDOM_ORVALUE);\n\tWRITE_ONCE(*args->p4dp, p4d);\n\tp4d_clear(args->p4dp);\n\tp4d = READ_ONCE(*args->p4dp);\n\tWARN_ON(!p4d_none(p4d));\n}\n\nstatic void __init p4d_populate_tests(struct pgtable_debug_args *args)\n{\n\tp4d_t p4d;\n\n\tif (mm_pud_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating P4D populate\\n\");\n\t \n\tpud_clear(args->pudp);\n\tp4d_clear(args->p4dp);\n\tp4d_populate(args->mm, args->p4dp, args->start_pudp);\n\tp4d = READ_ONCE(*args->p4dp);\n\tWARN_ON(p4d_bad(p4d));\n}\n\nstatic void __init pgd_clear_tests(struct pgtable_debug_args *args)\n{\n\tpgd_t pgd = READ_ONCE(*(args->pgdp));\n\n\tif (mm_p4d_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating PGD clear\\n\");\n\tpgd = __pgd(pgd_val(pgd) | RANDOM_ORVALUE);\n\tWRITE_ONCE(*args->pgdp, pgd);\n\tpgd_clear(args->pgdp);\n\tpgd = READ_ONCE(*args->pgdp);\n\tWARN_ON(!pgd_none(pgd));\n}\n\nstatic void __init pgd_populate_tests(struct pgtable_debug_args *args)\n{\n\tpgd_t pgd;\n\n\tif (mm_p4d_folded(args->mm))\n\t\treturn;\n\n\tpr_debug(\"Validating PGD populate\\n\");\n\t \n\tp4d_clear(args->p4dp);\n\tpgd_clear(args->pgdp);\n\tpgd_populate(args->mm, args->pgdp, args->start_p4dp);\n\tpgd = READ_ONCE(*args->pgdp);\n\tWARN_ON(pgd_bad(pgd));\n}\n#else   \nstatic void __init p4d_clear_tests(struct pgtable_debug_args *args) { }\nstatic void __init pgd_clear_tests(struct pgtable_debug_args *args) { }\nstatic void __init p4d_populate_tests(struct pgtable_debug_args *args) { }\nstatic void __init pgd_populate_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic void __init pte_clear_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tpte_t pte = pfn_pte(args->pte_pfn, args->page_prot);\n\n\tpage = (args->pte_pfn != ULONG_MAX) ? pfn_to_page(args->pte_pfn) : NULL;\n\tif (!page)\n\t\treturn;\n\n\t \n\tpr_debug(\"Validating PTE clear\\n\");\n\tif (WARN_ON(!args->ptep))\n\t\treturn;\n\n#ifndef CONFIG_RISCV\n\tpte = __pte(pte_val(pte) | RANDOM_ORVALUE);\n#endif\n\tset_pte_at(args->mm, args->vaddr, args->ptep, pte);\n\tflush_dcache_page(page);\n\tbarrier();\n\tptep_clear(args->mm, args->vaddr, args->ptep);\n\tpte = ptep_get(args->ptep);\n\tWARN_ON(!pte_none(pte));\n}\n\nstatic void __init pmd_clear_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd = READ_ONCE(*args->pmdp);\n\n\tpr_debug(\"Validating PMD clear\\n\");\n\tpmd = __pmd(pmd_val(pmd) | RANDOM_ORVALUE);\n\tWRITE_ONCE(*args->pmdp, pmd);\n\tpmd_clear(args->pmdp);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(!pmd_none(pmd));\n}\n\nstatic void __init pmd_populate_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tpr_debug(\"Validating PMD populate\\n\");\n\t \n\tpmd_populate(args->mm, args->pmdp, args->start_ptep);\n\tpmd = READ_ONCE(*args->pmdp);\n\tWARN_ON(pmd_bad(pmd));\n}\n\nstatic void __init pte_special_tests(struct pgtable_debug_args *args)\n{\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, args->page_prot);\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL))\n\t\treturn;\n\n\tpr_debug(\"Validating PTE special\\n\");\n\tWARN_ON(!pte_special(pte_mkspecial(pte)));\n}\n\nstatic void __init pte_protnone_tests(struct pgtable_debug_args *args)\n{\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, args->page_prot_none);\n\n\tif (!IS_ENABLED(CONFIG_NUMA_BALANCING))\n\t\treturn;\n\n\tpr_debug(\"Validating PTE protnone\\n\");\n\tWARN_ON(!pte_protnone(pte));\n\tWARN_ON(!pte_present(pte));\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void __init pmd_protnone_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!IS_ENABLED(CONFIG_NUMA_BALANCING))\n\t\treturn;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD protnone\\n\");\n\tpmd = pmd_mkhuge(pfn_pmd(args->fixed_pmd_pfn, args->page_prot_none));\n\tWARN_ON(!pmd_protnone(pmd));\n\tWARN_ON(!pmd_present(pmd));\n}\n#else   \nstatic void __init pmd_protnone_tests(struct pgtable_debug_args *args) { }\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_PTE_DEVMAP\nstatic void __init pte_devmap_tests(struct pgtable_debug_args *args)\n{\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, args->page_prot);\n\n\tpr_debug(\"Validating PTE devmap\\n\");\n\tWARN_ON(!pte_devmap(pte_mkdevmap(pte)));\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void __init pmd_devmap_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD devmap\\n\");\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\tWARN_ON(!pmd_devmap(pmd_mkdevmap(pmd)));\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nstatic void __init pud_devmap_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud;\n\n\tif (!has_transparent_pud_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PUD devmap\\n\");\n\tpud = pfn_pud(args->fixed_pud_pfn, args->page_prot);\n\tWARN_ON(!pud_devmap(pud_mkdevmap(pud)));\n}\n#else   \nstatic void __init pud_devmap_tests(struct pgtable_debug_args *args) { }\n#endif  \n#else   \nstatic void __init pmd_devmap_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_devmap_tests(struct pgtable_debug_args *args) { }\n#endif  \n#else\nstatic void __init pte_devmap_tests(struct pgtable_debug_args *args) { }\nstatic void __init pmd_devmap_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_devmap_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic void __init pte_soft_dirty_tests(struct pgtable_debug_args *args)\n{\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, args->page_prot);\n\n\tif (!IS_ENABLED(CONFIG_MEM_SOFT_DIRTY))\n\t\treturn;\n\n\tpr_debug(\"Validating PTE soft dirty\\n\");\n\tWARN_ON(!pte_soft_dirty(pte_mksoft_dirty(pte)));\n\tWARN_ON(pte_soft_dirty(pte_clear_soft_dirty(pte)));\n}\n\nstatic void __init pte_swap_soft_dirty_tests(struct pgtable_debug_args *args)\n{\n\tpte_t pte = pfn_pte(args->fixed_pte_pfn, args->page_prot);\n\n\tif (!IS_ENABLED(CONFIG_MEM_SOFT_DIRTY))\n\t\treturn;\n\n\tpr_debug(\"Validating PTE swap soft dirty\\n\");\n\tWARN_ON(!pte_swp_soft_dirty(pte_swp_mksoft_dirty(pte)));\n\tWARN_ON(pte_swp_soft_dirty(pte_swp_clear_soft_dirty(pte)));\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void __init pmd_soft_dirty_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!IS_ENABLED(CONFIG_MEM_SOFT_DIRTY))\n\t\treturn;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD soft dirty\\n\");\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\tWARN_ON(!pmd_soft_dirty(pmd_mksoft_dirty(pmd)));\n\tWARN_ON(pmd_soft_dirty(pmd_clear_soft_dirty(pmd)));\n}\n\nstatic void __init pmd_swap_soft_dirty_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) ||\n\t\t!IS_ENABLED(CONFIG_ARCH_ENABLE_THP_MIGRATION))\n\t\treturn;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD swap soft dirty\\n\");\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\tWARN_ON(!pmd_swp_soft_dirty(pmd_swp_mksoft_dirty(pmd)));\n\tWARN_ON(pmd_swp_soft_dirty(pmd_swp_clear_soft_dirty(pmd)));\n}\n#else   \nstatic void __init pmd_soft_dirty_tests(struct pgtable_debug_args *args) { }\nstatic void __init pmd_swap_soft_dirty_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic void __init pte_swap_exclusive_tests(struct pgtable_debug_args *args)\n{\n\tunsigned long max_swap_offset;\n\tswp_entry_t entry, entry2;\n\tpte_t pte;\n\n\tpr_debug(\"Validating PTE swap exclusive\\n\");\n\n\t \n\tmax_swap_offset = swp_offset(pte_to_swp_entry(swp_entry_to_pte(swp_entry(0, ~0UL))));\n\n\t \n\tentry = swp_entry((1 << MAX_SWAPFILES_SHIFT) - 1, max_swap_offset);\n\n\tpte = swp_entry_to_pte(entry);\n\tWARN_ON(pte_swp_exclusive(pte));\n\tWARN_ON(!is_swap_pte(pte));\n\tentry2 = pte_to_swp_entry(pte);\n\tWARN_ON(memcmp(&entry, &entry2, sizeof(entry)));\n\n\tpte = pte_swp_mkexclusive(pte);\n\tWARN_ON(!pte_swp_exclusive(pte));\n\tWARN_ON(!is_swap_pte(pte));\n\tWARN_ON(pte_swp_soft_dirty(pte));\n\tentry2 = pte_to_swp_entry(pte);\n\tWARN_ON(memcmp(&entry, &entry2, sizeof(entry)));\n\n\tpte = pte_swp_clear_exclusive(pte);\n\tWARN_ON(pte_swp_exclusive(pte));\n\tWARN_ON(!is_swap_pte(pte));\n\tentry2 = pte_to_swp_entry(pte);\n\tWARN_ON(memcmp(&entry, &entry2, sizeof(entry)));\n}\n\nstatic void __init pte_swap_tests(struct pgtable_debug_args *args)\n{\n\tswp_entry_t swp;\n\tpte_t pte;\n\n\tpr_debug(\"Validating PTE swap\\n\");\n\tpte = pfn_pte(args->fixed_pte_pfn, args->page_prot);\n\tswp = __pte_to_swp_entry(pte);\n\tpte = __swp_entry_to_pte(swp);\n\tWARN_ON(args->fixed_pte_pfn != pte_pfn(pte));\n}\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\nstatic void __init pmd_swap_tests(struct pgtable_debug_args *args)\n{\n\tswp_entry_t swp;\n\tpmd_t pmd;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD swap\\n\");\n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\tswp = __pmd_to_swp_entry(pmd);\n\tpmd = __swp_entry_to_pmd(swp);\n\tWARN_ON(args->fixed_pmd_pfn != pmd_pfn(pmd));\n}\n#else   \nstatic void __init pmd_swap_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic void __init swap_migration_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tswp_entry_t swp;\n\n\tif (!IS_ENABLED(CONFIG_MIGRATION))\n\t\treturn;\n\n\t \n\tpage = (args->pte_pfn != ULONG_MAX) ? pfn_to_page(args->pte_pfn) : NULL;\n\tif (!page)\n\t\treturn;\n\n\tpr_debug(\"Validating swap migration\\n\");\n\n\t \n\t__SetPageLocked(page);\n\tswp = make_writable_migration_entry(page_to_pfn(page));\n\tWARN_ON(!is_migration_entry(swp));\n\tWARN_ON(!is_writable_migration_entry(swp));\n\n\tswp = make_readable_migration_entry(swp_offset(swp));\n\tWARN_ON(!is_migration_entry(swp));\n\tWARN_ON(is_writable_migration_entry(swp));\n\n\tswp = make_readable_migration_entry(page_to_pfn(page));\n\tWARN_ON(!is_migration_entry(swp));\n\tWARN_ON(is_writable_migration_entry(swp));\n\t__ClearPageLocked(page);\n}\n\n#ifdef CONFIG_HUGETLB_PAGE\nstatic void __init hugetlb_basic_tests(struct pgtable_debug_args *args)\n{\n\tstruct page *page;\n\tpte_t pte;\n\n\tpr_debug(\"Validating HugeTLB basic\\n\");\n\t \n\tpage = pfn_to_page(args->fixed_pmd_pfn);\n\tpte = mk_huge_pte(page, args->page_prot);\n\n\tWARN_ON(!huge_pte_dirty(huge_pte_mkdirty(pte)));\n\tWARN_ON(!huge_pte_write(huge_pte_mkwrite(huge_pte_wrprotect(pte))));\n\tWARN_ON(huge_pte_write(huge_pte_wrprotect(huge_pte_mkwrite(pte))));\n\n#ifdef CONFIG_ARCH_WANT_GENERAL_HUGETLB\n\tpte = pfn_pte(args->fixed_pmd_pfn, args->page_prot);\n\n\tWARN_ON(!pte_huge(arch_make_huge_pte(pte, PMD_SHIFT, VM_ACCESS_FLAGS)));\n#endif  \n}\n#else   \nstatic void __init hugetlb_basic_tests(struct pgtable_debug_args *args) { }\n#endif  \n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void __init pmd_thp_tests(struct pgtable_debug_args *args)\n{\n\tpmd_t pmd;\n\n\tif (!has_transparent_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PMD based THP\\n\");\n\t \n\tpmd = pfn_pmd(args->fixed_pmd_pfn, args->page_prot);\n\tWARN_ON(!pmd_trans_huge(pmd_mkhuge(pmd)));\n\n#ifndef __HAVE_ARCH_PMDP_INVALIDATE\n\tWARN_ON(!pmd_trans_huge(pmd_mkinvalid(pmd_mkhuge(pmd))));\n\tWARN_ON(!pmd_present(pmd_mkinvalid(pmd_mkhuge(pmd))));\n#endif  \n}\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nstatic void __init pud_thp_tests(struct pgtable_debug_args *args)\n{\n\tpud_t pud;\n\n\tif (!has_transparent_pud_hugepage())\n\t\treturn;\n\n\tpr_debug(\"Validating PUD based THP\\n\");\n\tpud = pfn_pud(args->fixed_pud_pfn, args->page_prot);\n\tWARN_ON(!pud_trans_huge(pud_mkhuge(pud)));\n\n\t \n}\n#else   \nstatic void __init pud_thp_tests(struct pgtable_debug_args *args) { }\n#endif  \n#else   \nstatic void __init pmd_thp_tests(struct pgtable_debug_args *args) { }\nstatic void __init pud_thp_tests(struct pgtable_debug_args *args) { }\n#endif  \n\nstatic unsigned long __init get_random_vaddr(void)\n{\n\tunsigned long random_vaddr, random_pages, total_user_pages;\n\n\ttotal_user_pages = (TASK_SIZE - FIRST_USER_ADDRESS) / PAGE_SIZE;\n\n\trandom_pages = get_random_long() % total_user_pages;\n\trandom_vaddr = FIRST_USER_ADDRESS + random_pages * PAGE_SIZE;\n\n\treturn random_vaddr;\n}\n\nstatic void __init destroy_args(struct pgtable_debug_args *args)\n{\n\tstruct page *page = NULL;\n\n\t \n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&\n\t    has_transparent_pud_hugepage() &&\n\t    args->pud_pfn != ULONG_MAX) {\n\t\tif (args->is_contiguous_page) {\n\t\t\tfree_contig_range(args->pud_pfn,\n\t\t\t\t\t  (1 << (HPAGE_PUD_SHIFT - PAGE_SHIFT)));\n\t\t} else {\n\t\t\tpage = pfn_to_page(args->pud_pfn);\n\t\t\t__free_pages(page, HPAGE_PUD_SHIFT - PAGE_SHIFT);\n\t\t}\n\n\t\targs->pud_pfn = ULONG_MAX;\n\t\targs->pmd_pfn = ULONG_MAX;\n\t\targs->pte_pfn = ULONG_MAX;\n\t}\n\n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&\n\t    has_transparent_hugepage() &&\n\t    args->pmd_pfn != ULONG_MAX) {\n\t\tif (args->is_contiguous_page) {\n\t\t\tfree_contig_range(args->pmd_pfn, (1 << HPAGE_PMD_ORDER));\n\t\t} else {\n\t\t\tpage = pfn_to_page(args->pmd_pfn);\n\t\t\t__free_pages(page, HPAGE_PMD_ORDER);\n\t\t}\n\n\t\targs->pmd_pfn = ULONG_MAX;\n\t\targs->pte_pfn = ULONG_MAX;\n\t}\n\n\tif (args->pte_pfn != ULONG_MAX) {\n\t\tpage = pfn_to_page(args->pte_pfn);\n\t\t__free_page(page);\n\n\t\targs->pte_pfn = ULONG_MAX;\n\t}\n\n\t \n\tif (args->start_ptep) {\n\t\tpte_free(args->mm, args->start_ptep);\n\t\tmm_dec_nr_ptes(args->mm);\n\t}\n\n\tif (args->start_pmdp) {\n\t\tpmd_free(args->mm, args->start_pmdp);\n\t\tmm_dec_nr_pmds(args->mm);\n\t}\n\n\tif (args->start_pudp) {\n\t\tpud_free(args->mm, args->start_pudp);\n\t\tmm_dec_nr_puds(args->mm);\n\t}\n\n\tif (args->start_p4dp)\n\t\tp4d_free(args->mm, args->start_p4dp);\n\n\t \n\tif (args->vma)\n\t\tvm_area_free(args->vma);\n\n\tif (args->mm)\n\t\tmmdrop(args->mm);\n}\n\nstatic struct page * __init\ndebug_vm_pgtable_alloc_huge_page(struct pgtable_debug_args *args, int order)\n{\n\tstruct page *page = NULL;\n\n#ifdef CONFIG_CONTIG_ALLOC\n\tif (order > MAX_ORDER) {\n\t\tpage = alloc_contig_pages((1 << order), GFP_KERNEL,\n\t\t\t\t\t  first_online_node, NULL);\n\t\tif (page) {\n\t\t\targs->is_contiguous_page = true;\n\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\n\tif (order <= MAX_ORDER)\n\t\tpage = alloc_pages(GFP_KERNEL, order);\n\n\treturn page;\n}\n\n \nstatic void  __init phys_align_check(phys_addr_t pstart,\n\t\t\t\t     phys_addr_t pend, unsigned long psize,\n\t\t\t\t     phys_addr_t *physp, unsigned long *alignp)\n{\n\tphys_addr_t aligned_start, aligned_end;\n\n\tif (pstart == 0)\n\t\tpstart = PAGE_SIZE;\n\n\taligned_start = ALIGN(pstart, psize);\n\taligned_end = aligned_start + psize;\n\n\tif (aligned_end > aligned_start && aligned_end <= pend) {\n\t\t*alignp = psize;\n\t\t*physp = aligned_start;\n\t}\n}\n\nstatic void __init init_fixed_pfns(struct pgtable_debug_args *args)\n{\n\tu64 idx;\n\tphys_addr_t phys, pstart, pend;\n\n\t \n\n\tphys = __pa_symbol(&start_kernel);\n\targs->fixed_alignment = PAGE_SIZE;\n\n\tfor_each_mem_range(idx, &pstart, &pend) {\n\t\t \n\t\tphys_align_check(pstart, pend, PUD_SIZE, &phys,\n\t\t\t\t &args->fixed_alignment);\n\n\t\t \n\t\tif (args->fixed_alignment == PUD_SIZE)\n\t\t\tbreak;\n\n\t\t \n\t\tif (args->fixed_alignment < PMD_SIZE)\n\t\t\tphys_align_check(pstart, pend, PMD_SIZE, &phys,\n\t\t\t\t\t &args->fixed_alignment);\n\t}\n\n\targs->fixed_pgd_pfn = __phys_to_pfn(phys & PGDIR_MASK);\n\targs->fixed_p4d_pfn = __phys_to_pfn(phys & P4D_MASK);\n\targs->fixed_pud_pfn = __phys_to_pfn(phys & PUD_MASK);\n\targs->fixed_pmd_pfn = __phys_to_pfn(phys & PMD_MASK);\n\targs->fixed_pte_pfn = __phys_to_pfn(phys & PAGE_MASK);\n\tWARN_ON(!pfn_valid(args->fixed_pte_pfn));\n}\n\n\nstatic int __init init_args(struct pgtable_debug_args *args)\n{\n\tstruct page *page = NULL;\n\tint ret = 0;\n\n\t \n\tmemset(args, 0, sizeof(*args));\n\targs->vaddr              = get_random_vaddr();\n\targs->page_prot          = vm_get_page_prot(VM_ACCESS_FLAGS);\n\targs->page_prot_none     = vm_get_page_prot(VM_NONE);\n\targs->is_contiguous_page = false;\n\targs->pud_pfn            = ULONG_MAX;\n\targs->pmd_pfn            = ULONG_MAX;\n\targs->pte_pfn            = ULONG_MAX;\n\targs->fixed_pgd_pfn      = ULONG_MAX;\n\targs->fixed_p4d_pfn      = ULONG_MAX;\n\targs->fixed_pud_pfn      = ULONG_MAX;\n\targs->fixed_pmd_pfn      = ULONG_MAX;\n\targs->fixed_pte_pfn      = ULONG_MAX;\n\n\t \n\targs->mm = mm_alloc();\n\tif (!args->mm) {\n\t\tpr_err(\"Failed to allocate mm struct\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\targs->vma = vm_area_alloc(args->mm);\n\tif (!args->vma) {\n\t\tpr_err(\"Failed to allocate vma\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\targs->pgdp = pgd_offset(args->mm, args->vaddr);\n\targs->p4dp = p4d_alloc(args->mm, args->pgdp, args->vaddr);\n\tif (!args->p4dp) {\n\t\tpr_err(\"Failed to allocate p4d entries\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\targs->start_p4dp = p4d_offset(args->pgdp, 0UL);\n\tWARN_ON(!args->start_p4dp);\n\n\targs->pudp = pud_alloc(args->mm, args->p4dp, args->vaddr);\n\tif (!args->pudp) {\n\t\tpr_err(\"Failed to allocate pud entries\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\targs->start_pudp = pud_offset(args->p4dp, 0UL);\n\tWARN_ON(!args->start_pudp);\n\n\targs->pmdp = pmd_alloc(args->mm, args->pudp, args->vaddr);\n\tif (!args->pmdp) {\n\t\tpr_err(\"Failed to allocate pmd entries\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\targs->start_pmdp = pmd_offset(args->pudp, 0UL);\n\tWARN_ON(!args->start_pmdp);\n\n\tif (pte_alloc(args->mm, args->pmdp)) {\n\t\tpr_err(\"Failed to allocate pte entries\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\targs->start_ptep = pmd_pgtable(READ_ONCE(*args->pmdp));\n\tWARN_ON(!args->start_ptep);\n\n\tinit_fixed_pfns(args);\n\n\t \n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&\n\t    has_transparent_pud_hugepage()) {\n\t\tpage = debug_vm_pgtable_alloc_huge_page(args,\n\t\t\t\tHPAGE_PUD_SHIFT - PAGE_SHIFT);\n\t\tif (page) {\n\t\t\targs->pud_pfn = page_to_pfn(page);\n\t\t\targs->pmd_pfn = args->pud_pfn;\n\t\t\targs->pte_pfn = args->pud_pfn;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&\n\t    has_transparent_hugepage()) {\n\t\tpage = debug_vm_pgtable_alloc_huge_page(args, HPAGE_PMD_ORDER);\n\t\tif (page) {\n\t\t\targs->pmd_pfn = page_to_pfn(page);\n\t\t\targs->pte_pfn = args->pmd_pfn;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page)\n\t\targs->pte_pfn = page_to_pfn(page);\n\n\treturn 0;\n\nerror:\n\tdestroy_args(args);\n\treturn ret;\n}\n\nstatic int __init debug_vm_pgtable(void)\n{\n\tstruct pgtable_debug_args args;\n\tspinlock_t *ptl = NULL;\n\tint idx, ret;\n\n\tpr_info(\"Validating architecture page table helpers\\n\");\n\tret = init_args(&args);\n\tif (ret)\n\t\treturn ret;\n\n\t \n#define VM_FLAGS_START\t(VM_NONE)\n#define VM_FLAGS_END\t(VM_SHARED | VM_EXEC | VM_WRITE | VM_READ)\n\n\tfor (idx = VM_FLAGS_START; idx <= VM_FLAGS_END; idx++) {\n\t\tpte_basic_tests(&args, idx);\n\t\tpmd_basic_tests(&args, idx);\n\t\tpud_basic_tests(&args, idx);\n\t}\n\n\t \n\tp4d_basic_tests(&args);\n\tpgd_basic_tests(&args);\n\n\tpmd_leaf_tests(&args);\n\tpud_leaf_tests(&args);\n\n\tpte_special_tests(&args);\n\tpte_protnone_tests(&args);\n\tpmd_protnone_tests(&args);\n\n\tpte_devmap_tests(&args);\n\tpmd_devmap_tests(&args);\n\tpud_devmap_tests(&args);\n\n\tpte_soft_dirty_tests(&args);\n\tpmd_soft_dirty_tests(&args);\n\tpte_swap_soft_dirty_tests(&args);\n\tpmd_swap_soft_dirty_tests(&args);\n\n\tpte_swap_exclusive_tests(&args);\n\n\tpte_swap_tests(&args);\n\tpmd_swap_tests(&args);\n\n\tswap_migration_tests(&args);\n\n\tpmd_thp_tests(&args);\n\tpud_thp_tests(&args);\n\n\thugetlb_basic_tests(&args);\n\n\t \n\n\targs.ptep = pte_offset_map_lock(args.mm, args.pmdp, args.vaddr, &ptl);\n\tpte_clear_tests(&args);\n\tpte_advanced_tests(&args);\n\tif (args.ptep)\n\t\tpte_unmap_unlock(args.ptep, ptl);\n\n\tptl = pmd_lock(args.mm, args.pmdp);\n\tpmd_clear_tests(&args);\n\tpmd_advanced_tests(&args);\n\tpmd_huge_tests(&args);\n\tpmd_populate_tests(&args);\n\tspin_unlock(ptl);\n\n\tptl = pud_lock(args.mm, args.pudp);\n\tpud_clear_tests(&args);\n\tpud_advanced_tests(&args);\n\tpud_huge_tests(&args);\n\tpud_populate_tests(&args);\n\tspin_unlock(ptl);\n\n\tspin_lock(&(args.mm->page_table_lock));\n\tp4d_clear_tests(&args);\n\tpgd_clear_tests(&args);\n\tp4d_populate_tests(&args);\n\tpgd_populate_tests(&args);\n\tspin_unlock(&(args.mm->page_table_lock));\n\n\tdestroy_args(&args);\n\treturn 0;\n}\nlate_initcall(debug_vm_pgtable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}