{
  "module_name": "huge_memory.c",
  "hash_id": "c73c5be141093e2c94f8d44ebeb212b6c240bc77638e5ea9bd5fe67738cdf1ea",
  "original_prompt": "Ingested from linux-6.6.14/mm/huge_memory.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/swap.h>\n#include <linux/shrinker.h>\n#include <linux/mm_inline.h>\n#include <linux/swapops.h>\n#include <linux/backing-dev.h>\n#include <linux/dax.h>\n#include <linux/khugepaged.h>\n#include <linux/freezer.h>\n#include <linux/pfn_t.h>\n#include <linux/mman.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/debugfs.h>\n#include <linux/migrate.h>\n#include <linux/hashtable.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page_idle.h>\n#include <linux/shmem_fs.h>\n#include <linux/oom.h>\n#include <linux/numa.h>\n#include <linux/page_owner.h>\n#include <linux/sched/sysctl.h>\n#include <linux/memory-tiers.h>\n\n#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include \"internal.h\"\n#include \"swap.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/thp.h>\n\n \nunsigned long transparent_hugepage_flags __read_mostly =\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS\n\t(1<<TRANSPARENT_HUGEPAGE_FLAG)|\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE_MADVISE\n\t(1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG)|\n#endif\n\t(1<<TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG)|\n\t(1<<TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG)|\n\t(1<<TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n\nstatic struct shrinker deferred_split_shrinker;\n\nstatic atomic_t huge_zero_refcount;\nstruct page *huge_zero_page __read_mostly;\nunsigned long huge_zero_pfn __read_mostly = ~0UL;\n\nbool hugepage_vma_check(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t\tbool smaps, bool in_pf, bool enforce_sysfs)\n{\n\tif (!vma->vm_mm)\t\t \n\t\treturn false;\n\n\t \n\tif ((vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\t \n\tif (transparent_hugepage_flags & (1 << TRANSPARENT_HUGEPAGE_UNSUPPORTED))\n\t\treturn false;\n\n\t \n\tif (vma_is_dax(vma))\n\t\treturn in_pf;\n\n\t \n\tif (vm_flags & VM_NO_KHUGEPAGED)\n\t\treturn false;\n\n\t \n\tif (!in_pf &&\n\t    !transhuge_vma_suitable(vma, (vma->vm_end - HPAGE_PMD_SIZE)))\n\t\treturn false;\n\n\t \n\tif (!in_pf && shmem_file(vma->vm_file))\n\t\treturn shmem_is_huge(file_inode(vma->vm_file), vma->vm_pgoff,\n\t\t\t\t     !enforce_sysfs, vma->vm_mm, vm_flags);\n\n\t \n\tif (enforce_sysfs &&\n\t    (!hugepage_flags_enabled() || (!(vm_flags & VM_HUGEPAGE) &&\n\t\t\t\t\t   !hugepage_flags_always())))\n\t\treturn false;\n\n\t \n\tif (!in_pf && file_thp_enabled(vma))\n\t\treturn true;\n\n\tif (!vma_is_anonymous(vma))\n\t\treturn false;\n\n\tif (vma_is_temporary_stack(vma))\n\t\treturn false;\n\n\t \n\tif (!vma->anon_vma)\n\t\treturn (smaps || in_pf);\n\n\treturn true;\n}\n\nstatic bool get_huge_zero_page(void)\n{\n\tstruct page *zero_page;\nretry:\n\tif (likely(atomic_inc_not_zero(&huge_zero_refcount)))\n\t\treturn true;\n\n\tzero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,\n\t\t\tHPAGE_PMD_ORDER);\n\tif (!zero_page) {\n\t\tcount_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);\n\t\treturn false;\n\t}\n\tpreempt_disable();\n\tif (cmpxchg(&huge_zero_page, NULL, zero_page)) {\n\t\tpreempt_enable();\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\tgoto retry;\n\t}\n\tWRITE_ONCE(huge_zero_pfn, page_to_pfn(zero_page));\n\n\t \n\tatomic_set(&huge_zero_refcount, 2);\n\tpreempt_enable();\n\tcount_vm_event(THP_ZERO_PAGE_ALLOC);\n\treturn true;\n}\n\nstatic void put_huge_zero_page(void)\n{\n\t \n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}\n\nstruct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}\n\nvoid mm_put_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n}\n\nstatic unsigned long shrink_huge_zero_page_count(struct shrinker *shrink,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\t \n\treturn atomic_read(&huge_zero_refcount) == 1 ? HPAGE_PMD_NR : 0;\n}\n\nstatic unsigned long shrink_huge_zero_page_scan(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tif (atomic_cmpxchg(&huge_zero_refcount, 1, 0) == 1) {\n\t\tstruct page *zero_page = xchg(&huge_zero_page, NULL);\n\t\tBUG_ON(zero_page == NULL);\n\t\tWRITE_ONCE(huge_zero_pfn, ~0UL);\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\treturn HPAGE_PMD_NR;\n\t}\n\n\treturn 0;\n}\n\nstatic struct shrinker huge_zero_page_shrinker = {\n\t.count_objects = shrink_huge_zero_page_count,\n\t.scan_objects = shrink_huge_zero_page_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tconst char *output;\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags))\n\t\toutput = \"[always] madvise never\";\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags))\n\t\toutput = \"always [madvise] never\";\n\telse\n\t\toutput = \"always madvise [never]\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\n\nstatic ssize_t enabled_store(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tssize_t ret = count;\n\n\tif (sysfs_streq(buf, \"always\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"never\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\tret = -EINVAL;\n\n\tif (ret > 0) {\n\t\tint err = start_stop_khugepaged();\n\t\tif (err)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\nstatic struct kobj_attribute enabled_attr = __ATTR_RW(enabled);\n\nssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf,\n\t\t\t\t  enum transparent_hugepage_flag flag)\n{\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!test_bit(flag, &transparent_hugepage_flags));\n}\n\nssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}\n\nstatic ssize_t defrag_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tconst char *output;\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG,\n\t\t     &transparent_hugepage_flags))\n\t\toutput = \"[always] defer defer+madvise madvise never\";\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG,\n\t\t\t  &transparent_hugepage_flags))\n\t\toutput = \"always [defer] defer+madvise madvise never\";\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags))\n\t\toutput = \"always defer [defer+madvise] madvise never\";\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags))\n\t\toutput = \"always defer defer+madvise [madvise] never\";\n\telse\n\t\toutput = \"always defer defer+madvise madvise [never]\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\n\nstatic ssize_t defrag_store(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tif (sysfs_streq(buf, \"always\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"defer+madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"defer\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (sysfs_streq(buf, \"never\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nstatic struct kobj_attribute defrag_attr = __ATTR_RW(defrag);\n\nstatic ssize_t use_zero_page_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\t\t TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}\nstatic ssize_t use_zero_page_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}\nstatic struct kobj_attribute use_zero_page_attr = __ATTR_RW(use_zero_page);\n\nstatic ssize_t hpage_pmd_size_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%lu\\n\", HPAGE_PMD_SIZE);\n}\nstatic struct kobj_attribute hpage_pmd_size_attr =\n\t__ATTR_RO(hpage_pmd_size);\n\nstatic struct attribute *hugepage_attr[] = {\n\t&enabled_attr.attr,\n\t&defrag_attr.attr,\n\t&use_zero_page_attr.attr,\n\t&hpage_pmd_size_attr.attr,\n#ifdef CONFIG_SHMEM\n\t&shmem_enabled_attr.attr,\n#endif\n\tNULL,\n};\n\nstatic const struct attribute_group hugepage_attr_group = {\n\t.attrs = hugepage_attr,\n};\n\nstatic int __init hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\tint err;\n\n\t*hugepage_kobj = kobject_create_and_add(\"transparent_hugepage\", mm_kobj);\n\tif (unlikely(!*hugepage_kobj)) {\n\t\tpr_err(\"failed to create transparent hugepage kobject\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &hugepage_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto delete_obj;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &khugepaged_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto remove_hp_group;\n\t}\n\n\treturn 0;\n\nremove_hp_group:\n\tsysfs_remove_group(*hugepage_kobj, &hugepage_attr_group);\ndelete_obj:\n\tkobject_put(*hugepage_kobj);\n\treturn err;\n}\n\nstatic void __init hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n\tsysfs_remove_group(hugepage_kobj, &khugepaged_attr_group);\n\tsysfs_remove_group(hugepage_kobj, &hugepage_attr_group);\n\tkobject_put(hugepage_kobj);\n}\n#else\nstatic inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\treturn 0;\n}\n\nstatic inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n}\n#endif  \n\nstatic int __init hugepage_init(void)\n{\n\tint err;\n\tstruct kobject *hugepage_kobj;\n\n\tif (!has_transparent_hugepage()) {\n\t\ttransparent_hugepage_flags = 1 << TRANSPARENT_HUGEPAGE_UNSUPPORTED;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER > MAX_ORDER);\n\t \n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER < 2);\n\n\terr = hugepage_init_sysfs(&hugepage_kobj);\n\tif (err)\n\t\tgoto err_sysfs;\n\n\terr = khugepaged_init();\n\tif (err)\n\t\tgoto err_slab;\n\n\terr = register_shrinker(&huge_zero_page_shrinker, \"thp-zero\");\n\tif (err)\n\t\tgoto err_hzp_shrinker;\n\terr = register_shrinker(&deferred_split_shrinker, \"thp-deferred_split\");\n\tif (err)\n\t\tgoto err_split_shrinker;\n\n\t \n\tif (totalram_pages() < (512 << (20 - PAGE_SHIFT))) {\n\t\ttransparent_hugepage_flags = 0;\n\t\treturn 0;\n\t}\n\n\terr = start_stop_khugepaged();\n\tif (err)\n\t\tgoto err_khugepaged;\n\n\treturn 0;\nerr_khugepaged:\n\tunregister_shrinker(&deferred_split_shrinker);\nerr_split_shrinker:\n\tunregister_shrinker(&huge_zero_page_shrinker);\nerr_hzp_shrinker:\n\tkhugepaged_destroy();\nerr_slab:\n\thugepage_exit_sysfs(hugepage_kobj);\nerr_sysfs:\n\treturn err;\n}\nsubsys_initcall(hugepage_init);\n\nstatic int __init setup_transparent_hugepage(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\tif (!strcmp(str, \"always\")) {\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"never\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"transparent_hugepage= cannot parse, ignored\\n\");\n\treturn ret;\n}\n__setup(\"transparent_hugepage=\", setup_transparent_hugepage);\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd, vma);\n\treturn pmd;\n}\n\n#ifdef CONFIG_MEMCG\nstatic inline\nstruct deferred_split *get_deferred_split_queue(struct folio *folio)\n{\n\tstruct mem_cgroup *memcg = folio_memcg(folio);\n\tstruct pglist_data *pgdat = NODE_DATA(folio_nid(folio));\n\n\tif (memcg)\n\t\treturn &memcg->deferred_split_queue;\n\telse\n\t\treturn &pgdat->deferred_split_queue;\n}\n#else\nstatic inline\nstruct deferred_split *get_deferred_split_queue(struct folio *folio)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(folio_nid(folio));\n\n\treturn &pgdat->deferred_split_queue;\n}\n#endif\n\nvoid folio_prep_large_rmappable(struct folio *folio)\n{\n\tVM_BUG_ON_FOLIO(folio_order(folio) < 2, folio);\n\tINIT_LIST_HEAD(&folio->_deferred_list);\n\tfolio_set_large_rmappable(folio);\n}\n\nstatic inline bool is_transparent_hugepage(struct folio *folio)\n{\n\tif (!folio_test_large(folio))\n\t\treturn false;\n\n\treturn is_huge_zero_page(&folio->page) ||\n\t\tfolio_test_large_rmappable(folio);\n}\n\nstatic unsigned long __thp_get_unmapped_area(struct file *filp,\n\t\tunsigned long addr, unsigned long len,\n\t\tloff_t off, unsigned long flags, unsigned long size)\n{\n\tloff_t off_end = off + len;\n\tloff_t off_align = round_up(off, size);\n\tunsigned long len_pad, ret;\n\n\tif (off_end <= off_align || (off_end - off_align) < size)\n\t\treturn 0;\n\n\tlen_pad = len + size;\n\tif (len_pad < len || (off + len_pad) < off)\n\t\treturn 0;\n\n\tret = current->mm->get_unmapped_area(filp, addr, len_pad,\n\t\t\t\t\t      off >> PAGE_SHIFT, flags);\n\n\t \n\tif (IS_ERR_VALUE(ret))\n\t\treturn 0;\n\n\t \n\tif (ret == addr)\n\t\treturn addr;\n\n\tret += (off - ret) & (size - 1);\n\treturn ret;\n}\n\nunsigned long thp_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tunsigned long ret;\n\tloff_t off = (loff_t)pgoff << PAGE_SHIFT;\n\n\tret = __thp_get_unmapped_area(filp, addr, len, off, flags, PMD_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);\n}\nEXPORT_SYMBOL_GPL(thp_get_unmapped_area);\n\nstatic vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,\n\t\t\tstruct page *page, gfp_t gfp)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct folio *folio = page_folio(page);\n\tpgtable_t pgtable;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tvm_fault_t ret = 0;\n\n\tVM_BUG_ON_FOLIO(!folio_test_large(folio), folio);\n\n\tif (mem_cgroup_charge(folio, vma->vm_mm, gfp)) {\n\t\tfolio_put(folio);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tcount_vm_event(THP_FAULT_FALLBACK_CHARGE);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\tfolio_throttle_swaprate(folio, gfp);\n\n\tpgtable = pte_alloc_one(vma->vm_mm);\n\tif (unlikely(!pgtable)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto release;\n\t}\n\n\tclear_huge_page(page, vmf->address, HPAGE_PMD_NR);\n\t \n\t__folio_mark_uptodate(folio);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\tgoto unlock_release;\n\t} else {\n\t\tpmd_t entry;\n\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock_release;\n\n\t\t \n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tfolio_put(folio);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\treturn ret;\n\t\t}\n\n\t\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tfolio_add_new_anon_rmap(folio, vma, haddr);\n\t\tfolio_add_lru_vma(folio, vma);\n\t\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, pgtable);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tspin_unlock(vmf->ptl);\n\t\tcount_vm_event(THP_FAULT_ALLOC);\n\t\tcount_memcg_event_mm(vma->vm_mm, THP_FAULT_ALLOC);\n\t}\n\n\treturn 0;\nunlock_release:\n\tspin_unlock(vmf->ptl);\nrelease:\n\tif (pgtable)\n\t\tpte_free(vma->vm_mm, pgtable);\n\tfolio_put(folio);\n\treturn ret;\n\n}\n\n \ngfp_t vma_thp_gfp_mask(struct vm_area_struct *vma)\n{\n\tconst bool vma_madvised = vma && (vma->vm_flags & VM_HUGEPAGE);\n\n\t \n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\n\t \n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM;\n\n\t \n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT |\n\t\t\t(vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t__GFP_KSWAPD_RECLAIM);\n\n\t \n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT |\n\t\t       (vma_madvised ? __GFP_DIRECT_RECLAIM : 0);\n\n\treturn GFP_TRANSHUGE_LIGHT;\n}\n\n \nstatic void set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n}\n\nvm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tgfp_t gfp;\n\tstruct folio *folio;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\n\tif (!transhuge_vma_suitable(vma, haddr))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\tkhugepaged_enter_vma(vma, vma->vm_flags);\n\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm) &&\n\t\t\ttransparent_hugepage_use_zero_page()) {\n\t\tpgtable_t pgtable;\n\t\tstruct page *zero_page;\n\t\tvm_fault_t ret;\n\t\tpgtable = pte_alloc_one(vma->vm_mm);\n\t\tif (unlikely(!pgtable))\n\t\t\treturn VM_FAULT_OOM;\n\t\tzero_page = mm_get_huge_zero_page(vma->vm_mm);\n\t\tif (unlikely(!zero_page)) {\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\t\treturn VM_FAULT_FALLBACK;\n\t\t}\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tret = 0;\n\t\tif (pmd_none(*vmf->pmd)) {\n\t\t\tret = check_stable_address_space(vma->vm_mm);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\t} else if (userfaultfd_missing(vma)) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\t} else {\n\t\t\t\tset_huge_zero_page(pgtable, vma->vm_mm, vma,\n\t\t\t\t\t\t   haddr, vmf->pmd, zero_page);\n\t\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t}\n\t\treturn ret;\n\t}\n\tgfp = vma_thp_gfp_mask(vma);\n\tfolio = vma_alloc_folio(gfp, HPAGE_PMD_ORDER, vma, haddr, true);\n\tif (unlikely(!folio)) {\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\treturn __do_huge_pmd_anonymous_page(vmf, &folio->page, gfp);\n}\n\nstatic void insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, pfn_t pfn, pgprot_t prot, bool write,\n\t\tpgtable_t pgtable)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!pmd_none(*pmd)) {\n\t\tif (write) {\n\t\t\tif (pmd_pfn(*pmd) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_huge_zero_pmd(*pmd));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = pmd_mkyoung(*pmd);\n\t\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\t\tif (pmdp_set_access_flags(vma, addr, pmd, entry, 1))\n\t\t\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\t\t}\n\n\t\tgoto out_unlock;\n\t}\n\n\tentry = pmd_mkhuge(pfn_t_pmd(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pmd_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pmd_mkyoung(pmd_mkdirty(entry));\n\t\tentry = maybe_pmd_mkwrite(entry, vma);\n\t}\n\n\tif (pgtable) {\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\t\tmm_inc_nr_ptes(mm);\n\t\tpgtable = NULL;\n\t}\n\n\tset_pmd_at(mm, addr, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\nout_unlock:\n\tspin_unlock(ptl);\n\tif (pgtable)\n\t\tpte_free(mm, pgtable);\n}\n\n \nvm_fault_t vmf_insert_pfn_pmd(struct vm_fault *vmf, pfn_t pfn, bool write)\n{\n\tunsigned long addr = vmf->address & PMD_MASK;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tpgtable_t pgtable = NULL;\n\n\t \n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (arch_needs_pgtable_deposit()) {\n\t\tpgtable = pte_alloc_one(vma->vm_mm);\n\t\tif (!pgtable)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pmd(vma, addr, vmf->pmd, pfn, pgprot, write, pgtable);\n\treturn VM_FAULT_NOPAGE;\n}\nEXPORT_SYMBOL_GPL(vmf_insert_pfn_pmd);\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nstatic pud_t maybe_pud_mkwrite(pud_t pud, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpud = pud_mkwrite(pud);\n\treturn pud;\n}\n\nstatic void insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, pfn_t pfn, bool write)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgprot_t prot = vma->vm_page_prot;\n\tpud_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(mm, pud);\n\tif (!pud_none(*pud)) {\n\t\tif (write) {\n\t\t\tif (pud_pfn(*pud) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_huge_zero_pud(*pud));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = pud_mkyoung(*pud);\n\t\t\tentry = maybe_pud_mkwrite(pud_mkdirty(entry), vma);\n\t\t\tif (pudp_set_access_flags(vma, addr, pud, entry, 1))\n\t\t\t\tupdate_mmu_cache_pud(vma, addr, pud);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\tentry = pud_mkhuge(pfn_t_pud(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pud_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pud_mkyoung(pud_mkdirty(entry));\n\t\tentry = maybe_pud_mkwrite(entry, vma);\n\t}\n\tset_pud_at(mm, addr, pud, entry);\n\tupdate_mmu_cache_pud(vma, addr, pud);\n\nout_unlock:\n\tspin_unlock(ptl);\n}\n\n \nvm_fault_t vmf_insert_pfn_pud(struct vm_fault *vmf, pfn_t pfn, bool write)\n{\n\tunsigned long addr = vmf->address & PUD_MASK;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgprot_t pgprot = vma->vm_page_prot;\n\n\t \n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pud(vma, addr, vmf->pud, pfn, write);\n\treturn VM_FAULT_NOPAGE;\n}\nEXPORT_SYMBOL_GPL(vmf_insert_pfn_pud);\n#endif  \n\nstatic void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t      pmd_t *pmd, bool write)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (write)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\t  pmd, _pmd, write))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}\n\nstruct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tint ret;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t ;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags & FOLL_WRITE);\n\n\t \n\tif (!(flags & (FOLL_GET | FOLL_PIN)))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tret = try_grab_page(page, flags);\n\tif (ret)\n\t\tpage = ERR_PTR(ret);\n\n\treturn page;\n}\n\nint copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,\n\t\t  struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tstruct page *src_page;\n\tpmd_t pmd;\n\tpgtable_t pgtable = NULL;\n\tint ret = -ENOMEM;\n\n\t \n\tif (!vma_is_anonymous(dst_vma))\n\t\treturn 0;\n\n\tpgtable = pte_alloc_one(dst_mm);\n\tif (unlikely(!pgtable))\n\t\tgoto out;\n\n\tdst_ptl = pmd_lock(dst_mm, dst_pmd);\n\tsrc_ptl = pmd_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpmd = *src_pmd;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\tif (!is_readable_migration_entry(entry)) {\n\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tswp_offset(entry));\n\t\t\tpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\t\t\tif (pmd_swp_uffd_wp(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mkuffd_wp(pmd);\n\t\t\tset_pmd_at(src_mm, addr, src_pmd, pmd);\n\t\t}\n\t\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(dst_mm);\n\t\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\t\tif (!userfaultfd_wp(dst_vma))\n\t\t\tpmd = pmd_swp_clear_uffd_wp(pmd);\n\t\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\n\tif (unlikely(!pmd_trans_huge(pmd))) {\n\t\tpte_free(dst_mm, pgtable);\n\t\tgoto out_unlock;\n\t}\n\t \n\tif (is_huge_zero_pmd(pmd)) {\n\t\t \n\t\tmm_get_huge_zero_page(dst_mm);\n\t\tgoto out_zero_page;\n\t}\n\n\tsrc_page = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!PageHead(src_page), src_page);\n\n\tget_page(src_page);\n\tif (unlikely(page_try_dup_anon_rmap(src_page, true, src_vma))) {\n\t\t \n\t\tput_page(src_page);\n\t\tpte_free(dst_mm, pgtable);\n\t\tspin_unlock(src_ptl);\n\t\tspin_unlock(dst_ptl);\n\t\t__split_huge_pmd(src_vma, src_pmd, addr, false, NULL);\n\t\treturn -EAGAIN;\n\t}\n\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\nout_zero_page:\n\tmm_inc_nr_ptes(dst_mm);\n\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\tpmdp_set_wrprotect(src_mm, addr, src_pmd);\n\tif (!userfaultfd_wp(dst_vma))\n\t\tpmd = pmd_clear_uffd_wp(pmd);\n\tpmd = pmd_mkold(pmd_wrprotect(pmd));\n\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\nout:\n\treturn ret;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nstatic void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\t      pud_t *pud, bool write)\n{\n\tpud_t _pud;\n\n\t_pud = pud_mkyoung(*pud);\n\tif (write)\n\t\t_pud = pud_mkdirty(_pud);\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\t  pud, _pud, write))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}\n\nstruct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pud_pfn(*pud);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tint ret;\n\n\tassert_spin_locked(pud_lockptr(mm, pud));\n\n\tif (flags & FOLL_WRITE && !pud_write(*pud))\n\t\treturn NULL;\n\n\tif (pud_present(*pud) && pud_devmap(*pud))\n\t\t ;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pud(vma, addr, pud, flags & FOLL_WRITE);\n\n\t \n\tif (!(flags & (FOLL_GET | FOLL_PIN)))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\n\tret = try_grab_page(page, flags);\n\tif (ret)\n\t\tpage = ERR_PTR(ret);\n\n\treturn page;\n}\n\nint copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tpud_t pud;\n\tint ret;\n\n\tdst_ptl = pud_lock(dst_mm, dst_pud);\n\tsrc_ptl = pud_lockptr(src_mm, src_pud);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpud = *src_pud;\n\tif (unlikely(!pud_trans_huge(pud) && !pud_devmap(pud)))\n\t\tgoto out_unlock;\n\n\t \n\tif (is_huge_zero_pud(pud)) {\n\t\t \n\t}\n\n\t \n\tpudp_set_wrprotect(src_mm, addr, src_pud);\n\tpud = pud_mkold(pud_wrprotect(pud));\n\tset_pud_at(dst_mm, addr, dst_pud, pud);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n\treturn ret;\n}\n\nvoid huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)\n{\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pud_lock(vmf->vma->vm_mm, vmf->pud);\n\tif (unlikely(!pud_same(*vmf->pud, orig_pud)))\n\t\tgoto unlock;\n\n\ttouch_pud(vmf->vma, vmf->address, vmf->pud, write);\nunlock:\n\tspin_unlock(vmf->ptl);\n}\n#endif  \n\nvoid huge_pmd_set_accessed(struct vm_fault *vmf)\n{\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, vmf->orig_pmd)))\n\t\tgoto unlock;\n\n\ttouch_pmd(vmf->vma, vmf->address, vmf->pmd, write);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}\n\nvm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf)\n{\n\tconst bool unshare = vmf->flags & FAULT_FLAG_UNSHARE;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct folio *folio;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tpmd_t orig_pmd = vmf->orig_pmd;\n\n\tvmf->ptl = pmd_lockptr(vma->vm_mm, vmf->pmd);\n\tVM_BUG_ON_VMA(!vma->anon_vma, vma);\n\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto fallback;\n\n\tspin_lock(vmf->ptl);\n\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\treturn 0;\n\t}\n\n\tpage = pmd_page(orig_pmd);\n\tfolio = page_folio(page);\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\t \n\tif (PageAnonExclusive(page))\n\t\tgoto reuse;\n\n\tif (!folio_trylock(folio)) {\n\t\tfolio_get(folio);\n\t\tspin_unlock(vmf->ptl);\n\t\tfolio_lock(folio);\n\t\tspin_lock(vmf->ptl);\n\t\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\treturn 0;\n\t\t}\n\t\tfolio_put(folio);\n\t}\n\n\t \n\tif (PageAnonExclusive(page)) {\n\t\tfolio_unlock(folio);\n\t\tgoto reuse;\n\t}\n\n\t \n\tif (folio_ref_count(folio) >\n\t\t\t1 + folio_test_swapcache(folio) * folio_nr_pages(folio))\n\t\tgoto unlock_fallback;\n\tif (folio_test_swapcache(folio))\n\t\tfolio_free_swap(folio);\n\tif (folio_ref_count(folio) == 1) {\n\t\tpmd_t entry;\n\n\t\tpage_move_anon_rmap(page, vma);\n\t\tfolio_unlock(folio);\nreuse:\n\t\tif (unlikely(unshare)) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\treturn 0;\n\t\t}\n\t\tentry = pmd_mkyoung(orig_pmd);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tif (pmdp_set_access_flags(vma, haddr, vmf->pmd, entry, 1))\n\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tspin_unlock(vmf->ptl);\n\t\treturn 0;\n\t}\n\nunlock_fallback:\n\tfolio_unlock(folio);\n\tspin_unlock(vmf->ptl);\nfallback:\n\t__split_huge_pmd(vma, vmf->pmd, vmf->address, false, NULL);\n\treturn VM_FAULT_FALLBACK;\n}\n\nstatic inline bool can_change_pmd_writable(struct vm_area_struct *vma,\n\t\t\t\t\t   unsigned long addr, pmd_t pmd)\n{\n\tstruct page *page;\n\n\tif (WARN_ON_ONCE(!(vma->vm_flags & VM_WRITE)))\n\t\treturn false;\n\n\t \n\tif (pmd_protnone(pmd))\n\t\treturn false;\n\n\t \n\tif (vma_soft_dirty_enabled(vma) && !pmd_soft_dirty(pmd))\n\t\treturn false;\n\n\t \n\tif (userfaultfd_huge_pmd_wp(vma, pmd))\n\t\treturn false;\n\n\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\t \n\t\tpage = vm_normal_page_pmd(vma, addr, pmd);\n\t\treturn page && PageAnon(page) && PageAnonExclusive(page);\n\t}\n\n\t \n\treturn pmd_dirty(pmd);\n}\n\n \nstatic inline bool can_follow_write_pmd(pmd_t pmd, struct page *page,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned int flags)\n{\n\t \n\tif (pmd_write(pmd))\n\t\treturn true;\n\n\t \n\tif (!(flags & FOLL_FORCE))\n\t\treturn false;\n\n\t \n\tif (vma->vm_flags & (VM_MAYSHARE | VM_SHARED))\n\t\treturn false;\n\n\t \n\tif (!(vma->vm_flags & VM_MAYWRITE))\n\t\treturn false;\n\n\t \n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn false;\n\n\t \n\tif (!page || !PageAnon(page) || !PageAnonExclusive(page))\n\t\treturn false;\n\n\t \n\tif (vma_soft_dirty_enabled(vma) && !pmd_soft_dirty(pmd))\n\t\treturn false;\n\treturn !userfaultfd_huge_pmd_wp(vma, pmd);\n}\n\nstruct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tint ret;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\n\tif ((flags & FOLL_WRITE) &&\n\t    !can_follow_write_pmd(*pmd, page, vma, flags))\n\t\treturn NULL;\n\n\t \n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (pmd_protnone(*pmd) && !gup_can_follow_protnone(vma, flags))\n\t\treturn NULL;\n\n\tif (!pmd_write(*pmd) && gup_must_unshare(vma, flags, page))\n\t\treturn ERR_PTR(-EMLINK);\n\n\tVM_BUG_ON_PAGE((flags & FOLL_PIN) && PageAnon(page) &&\n\t\t\t!PageAnonExclusive(page), page);\n\n\tret = try_grab_page(page, flags);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags & FOLL_WRITE);\n\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\n\treturn page;\n}\n\n \nvm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpmd_t oldpmd = vmf->orig_pmd;\n\tpmd_t pmd;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tint page_nid = NUMA_NO_NODE;\n\tint target_nid, last_cpupid = (-1 & LAST_CPUPID_MASK);\n\tbool migrated = false, writable = false;\n\tint flags = 0;\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(oldpmd, *vmf->pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\tgoto out;\n\t}\n\n\tpmd = pmd_modify(oldpmd, vma->vm_page_prot);\n\n\t \n\twritable = pmd_write(pmd);\n\tif (!writable && vma_wants_manual_pte_write_upgrade(vma) &&\n\t    can_change_pmd_writable(vma, vmf->address, pmd))\n\t\twritable = true;\n\n\tpage = vm_normal_page_pmd(vma, haddr, pmd);\n\tif (!page)\n\t\tgoto out_map;\n\n\t \n\tif (!writable)\n\t\tflags |= TNF_NO_GROUP;\n\n\tpage_nid = page_to_nid(page);\n\t \n\tif (node_is_toptier(page_nid))\n\t\tlast_cpupid = page_cpupid_last(page);\n\ttarget_nid = numa_migrate_prep(page, vma, haddr, page_nid,\n\t\t\t\t       &flags);\n\n\tif (target_nid == NUMA_NO_NODE) {\n\t\tput_page(page);\n\t\tgoto out_map;\n\t}\n\n\tspin_unlock(vmf->ptl);\n\twritable = false;\n\n\tmigrated = migrate_misplaced_page(page, vma, target_nid);\n\tif (migrated) {\n\t\tflags |= TNF_MIGRATED;\n\t\tpage_nid = target_nid;\n\t} else {\n\t\tflags |= TNF_MIGRATE_FAIL;\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tif (unlikely(!pmd_same(oldpmd, *vmf->pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto out_map;\n\t}\n\nout:\n\tif (page_nid != NUMA_NO_NODE)\n\t\ttask_numa_fault(last_cpupid, page_nid, HPAGE_PMD_NR,\n\t\t\t\tflags);\n\n\treturn 0;\n\nout_map:\n\t \n\tpmd = pmd_modify(oldpmd, vma->vm_page_prot);\n\tpmd = pmd_mkyoung(pmd);\n\tif (writable)\n\t\tpmd = pmd_mkwrite(pmd, vma);\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, pmd);\n\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\tspin_unlock(vmf->ptl);\n\tgoto out;\n}\n\n \nbool madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long addr, unsigned long next)\n{\n\tspinlock_t *ptl;\n\tpmd_t orig_pmd;\n\tstruct folio *folio;\n\tstruct mm_struct *mm = tlb->mm;\n\tbool ret = false;\n\n\ttlb_change_page_size(tlb, HPAGE_PMD_SIZE);\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\tgoto out_unlocked;\n\n\torig_pmd = *pmd;\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto out;\n\n\tif (unlikely(!pmd_present(orig_pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\tgoto out;\n\t}\n\n\tfolio = pfn_folio(pmd_pfn(orig_pmd));\n\t \n\tif (folio_estimated_sharers(folio) != 1)\n\t\tgoto out;\n\n\tif (!folio_trylock(folio))\n\t\tgoto out;\n\n\t \n\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\tfolio_get(folio);\n\t\tspin_unlock(ptl);\n\t\tsplit_folio(folio);\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\tgoto out_unlocked;\n\t}\n\n\tif (folio_test_dirty(folio))\n\t\tfolio_clear_dirty(folio);\n\tfolio_unlock(folio);\n\n\tif (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {\n\t\tpmdp_invalidate(vma, addr, pmd);\n\t\torig_pmd = pmd_mkold(orig_pmd);\n\t\torig_pmd = pmd_mkclean(orig_pmd);\n\n\t\tset_pmd_at(mm, addr, pmd, orig_pmd);\n\t\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\t}\n\n\tfolio_mark_lazyfree(folio);\n\tret = true;\nout:\n\tspin_unlock(ptl);\nout_unlocked:\n\treturn ret;\n}\n\nstatic inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}\n\nint zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pmd_t *pmd, unsigned long addr)\n{\n\tpmd_t orig_pmd;\n\tspinlock_t *ptl;\n\n\ttlb_change_page_size(tlb, HPAGE_PMD_SIZE);\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t \n\torig_pmd = pmdp_huge_get_and_clear_full(vma, addr, pmd,\n\t\t\t\t\t\ttlb->fullmm);\n\tarch_check_zapped_pmd(vma, orig_pmd);\n\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\tif (vma_is_special_huge(vma)) {\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t} else if (is_huge_zero_pmd(orig_pmd)) {\n\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t} else {\n\t\tstruct page *page = NULL;\n\t\tint flush_needed = 1;\n\n\t\tif (pmd_present(orig_pmd)) {\n\t\t\tpage = pmd_page(orig_pmd);\n\t\t\tpage_remove_rmap(page, vma, true);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(page) < 0, page);\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t} else if (thp_migration_supported()) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(orig_pmd));\n\t\t\tentry = pmd_to_swp_entry(orig_pmd);\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tflush_needed = 0;\n\t\t} else\n\t\t\tWARN_ONCE(1, \"Non present huge pmd without pmd migration enabled!\");\n\n\t\tif (PageAnon(page)) {\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tif (arch_needs_pgtable_deposit())\n\t\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\t}\n\n\t\tspin_unlock(ptl);\n\t\tif (flush_needed)\n\t\t\ttlb_remove_page_size(tlb, page, HPAGE_PMD_SIZE);\n\t}\n\treturn 1;\n}\n\n#ifndef pmd_move_must_withdraw\nstatic inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl,\n\t\t\t\t\t spinlock_t *old_pmd_ptl,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\t \n\treturn (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);\n}\n#endif\n\nstatic pmd_t move_soft_dirty_pmd(pmd_t pmd)\n{\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (unlikely(is_pmd_migration_entry(pmd)))\n\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\telse if (pmd_present(pmd))\n\t\tpmd = pmd_mksoft_dirty(pmd);\n#endif\n\treturn pmd;\n}\n\nbool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)\n{\n\tspinlock_t *old_ptl, *new_ptl;\n\tpmd_t pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool force_flush = false;\n\n\t \n\tif (!pmd_none(*new_pmd)) {\n\t\tVM_BUG_ON(pmd_trans_huge(*new_pmd));\n\t\treturn false;\n\t}\n\n\t \n\told_ptl = __pmd_trans_huge_lock(old_pmd, vma);\n\tif (old_ptl) {\n\t\tnew_ptl = pmd_lockptr(mm, new_pmd);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n\t\tif (pmd_present(pmd))\n\t\t\tforce_flush = true;\n\t\tVM_BUG_ON(!pmd_none(*new_pmd));\n\n\t\tif (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {\n\t\t\tpgtable_t pgtable;\n\t\t\tpgtable = pgtable_trans_huge_withdraw(mm, old_pmd);\n\t\t\tpgtable_trans_huge_deposit(mm, new_pmd, pgtable);\n\t\t}\n\t\tpmd = move_soft_dirty_pmd(pmd);\n\t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n\t\tif (force_flush)\n\t\t\tflush_pmd_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_unlock(new_ptl);\n\t\tspin_unlock(old_ptl);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nint change_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t    pmd_t *pmd, unsigned long addr, pgprot_t newprot,\n\t\t    unsigned long cp_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tspinlock_t *ptl;\n\tpmd_t oldpmd, entry;\n\tbool prot_numa = cp_flags & MM_CP_PROT_NUMA;\n\tbool uffd_wp = cp_flags & MM_CP_UFFD_WP;\n\tbool uffd_wp_resolve = cp_flags & MM_CP_UFFD_WP_RESOLVE;\n\tint ret = 1;\n\n\ttlb_change_page_size(tlb, HPAGE_PMD_SIZE);\n\n\tif (prot_numa && !thp_migration_supported())\n\t\treturn 1;\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (is_swap_pmd(*pmd)) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(*pmd);\n\t\tstruct page *page = pfn_swap_entry_to_page(entry);\n\t\tpmd_t newpmd;\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(*pmd));\n\t\tif (is_writable_migration_entry(entry)) {\n\t\t\t \n\t\t\tif (PageAnon(page))\n\t\t\t\tentry = make_readable_exclusive_migration_entry(swp_offset(entry));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(swp_offset(entry));\n\t\t\tnewpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*pmd))\n\t\t\t\tnewpmd = pmd_swp_mksoft_dirty(newpmd);\n\t\t} else {\n\t\t\tnewpmd = *pmd;\n\t\t}\n\n\t\tif (uffd_wp)\n\t\t\tnewpmd = pmd_swp_mkuffd_wp(newpmd);\n\t\telse if (uffd_wp_resolve)\n\t\t\tnewpmd = pmd_swp_clear_uffd_wp(newpmd);\n\t\tif (!pmd_same(*pmd, newpmd))\n\t\t\tset_pmd_at(mm, addr, pmd, newpmd);\n\t\tgoto unlock;\n\t}\n#endif\n\n\tif (prot_numa) {\n\t\tstruct page *page;\n\t\tbool toptier;\n\t\t \n\t\tif (is_huge_zero_pmd(*pmd))\n\t\t\tgoto unlock;\n\n\t\tif (pmd_protnone(*pmd))\n\t\t\tgoto unlock;\n\n\t\tpage = pmd_page(*pmd);\n\t\ttoptier = node_is_toptier(page_to_nid(page));\n\t\t \n\t\tif (!(sysctl_numa_balancing_mode & NUMA_BALANCING_NORMAL) &&\n\t\t    toptier)\n\t\t\tgoto unlock;\n\n\t\tif (sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING &&\n\t\t    !toptier)\n\t\t\txchg_page_access_time(page, jiffies_to_msecs(jiffies));\n\t}\n\t \n\toldpmd = pmdp_invalidate_ad(vma, addr, pmd);\n\n\tentry = pmd_modify(oldpmd, newprot);\n\tif (uffd_wp)\n\t\tentry = pmd_mkuffd_wp(entry);\n\telse if (uffd_wp_resolve)\n\t\t \n\t\tentry = pmd_clear_uffd_wp(entry);\n\n\t \n\tif ((cp_flags & MM_CP_TRY_CHANGE_WRITABLE) && !pmd_write(entry) &&\n\t    can_change_pmd_writable(vma, addr, entry))\n\t\tentry = pmd_mkwrite(entry, vma);\n\n\tret = HPAGE_PMD_NR;\n\tset_pmd_at(mm, addr, pmd, entry);\n\n\tif (huge_pmd_needs_flush(oldpmd, entry))\n\t\ttlb_flush_pmd_range(tlb, addr, HPAGE_PMD_SIZE);\nunlock:\n\tspin_unlock(ptl);\n\treturn ret;\n}\n\n \nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}\n\n \nspinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\nint zap_huge_pud(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pud_t *pud, unsigned long addr)\n{\n\tspinlock_t *ptl;\n\n\tptl = __pud_trans_huge_lock(pud, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n\tpudp_huge_get_and_clear_full(vma, addr, pud, tlb->fullmm);\n\ttlb_remove_pud_tlb_entry(tlb, pud, addr);\n\tif (vma_is_special_huge(vma)) {\n\t\tspin_unlock(ptl);\n\t\t \n\t} else {\n\t\t \n\t\tBUG();\n\t}\n\treturn 1;\n}\n\nstatic void __split_huge_pud_locked(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long haddr)\n{\n\tVM_BUG_ON(haddr & ~HPAGE_PUD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PUD_SIZE, vma);\n\tVM_BUG_ON(!pud_trans_huge(*pud) && !pud_devmap(*pud));\n\n\tcount_vm_event(THP_SPLIT_PUD);\n\n\tpudp_huge_clear_flush(vma, haddr, pud);\n}\n\nvoid __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma->vm_mm,\n\t\t\t\taddress & HPAGE_PUD_MASK,\n\t\t\t\t(address & HPAGE_PUD_MASK) + HPAGE_PUD_SIZE);\n\tmmu_notifier_invalidate_range_start(&range);\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, range.start);\n\nout:\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(&range);\n}\n#endif  \n\nstatic void __split_huge_zero_page_pmd(struct vm_area_struct *vma,\n\t\tunsigned long haddr, pmd_t *pmd)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgtable_t pgtable;\n\tpmd_t _pmd, old_pmd;\n\tunsigned long addr;\n\tpte_t *pte;\n\tint i;\n\n\t \n\told_pmd = pmdp_huge_clear_flush(vma, haddr, pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tpte = pte_offset_map(&_pmd, haddr);\n\tVM_BUG_ON(!pte);\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry;\n\n\t\tentry = pfn_pte(my_zero_pfn(addr), vma->vm_page_prot);\n\t\tentry = pte_mkspecial(entry);\n\t\tif (pmd_uffd_wp(old_pmd))\n\t\t\tentry = pte_mkuffd_wp(entry);\n\t\tVM_BUG_ON(!pte_none(ptep_get(pte)));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tpte++;\n\t}\n\tpte_unmap(pte - 1);\n\tsmp_wmb();  \n\tpmd_populate(mm, pmd, pgtable);\n}\n\nstatic void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long haddr, bool freeze)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tpgtable_t pgtable;\n\tpmd_t old_pmd, _pmd;\n\tbool young, write, soft_dirty, pmd_migration = false, uffd_wp = false;\n\tbool anon_exclusive = false, dirty = false;\n\tunsigned long addr;\n\tpte_t *pte;\n\tint i;\n\n\tVM_BUG_ON(haddr & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);\n\tVM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd));\n\n\tcount_vm_event(THP_SPLIT_PMD);\n\n\tif (!vma_is_anonymous(vma)) {\n\t\told_pmd = pmdp_huge_clear_flush(vma, haddr, pmd);\n\t\t \n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(mm, pmd);\n\t\tif (vma_is_special_huge(vma))\n\t\t\treturn;\n\t\tif (unlikely(is_pmd_migration_entry(old_pmd))) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t} else {\n\t\t\tpage = pmd_page(old_pmd);\n\t\t\tif (!PageDirty(page) && pmd_dirty(old_pmd))\n\t\t\t\tset_page_dirty(page);\n\t\t\tif (!PageReferenced(page) && pmd_young(old_pmd))\n\t\t\t\tSetPageReferenced(page);\n\t\t\tpage_remove_rmap(page, vma, true);\n\t\t\tput_page(page);\n\t\t}\n\t\tadd_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\treturn;\n\t}\n\n\tif (is_huge_zero_pmd(*pmd)) {\n\t\t \n\t\treturn __split_huge_zero_page_pmd(vma, haddr, pmd);\n\t}\n\n\t \n\told_pmd = pmdp_invalidate(vma, haddr, pmd);\n\n\tpmd_migration = is_pmd_migration_entry(old_pmd);\n\tif (unlikely(pmd_migration)) {\n\t\tswp_entry_t entry;\n\n\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\tpage = pfn_swap_entry_to_page(entry);\n\t\twrite = is_writable_migration_entry(entry);\n\t\tif (PageAnon(page))\n\t\t\tanon_exclusive = is_readable_exclusive_migration_entry(entry);\n\t\tyoung = is_migration_entry_young(entry);\n\t\tdirty = is_migration_entry_dirty(entry);\n\t\tsoft_dirty = pmd_swp_soft_dirty(old_pmd);\n\t\tuffd_wp = pmd_swp_uffd_wp(old_pmd);\n\t} else {\n\t\tpage = pmd_page(old_pmd);\n\t\tif (pmd_dirty(old_pmd)) {\n\t\t\tdirty = true;\n\t\t\tSetPageDirty(page);\n\t\t}\n\t\twrite = pmd_write(old_pmd);\n\t\tyoung = pmd_young(old_pmd);\n\t\tsoft_dirty = pmd_soft_dirty(old_pmd);\n\t\tuffd_wp = pmd_uffd_wp(old_pmd);\n\n\t\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\t\t \n\t\tanon_exclusive = PageAnon(page) && PageAnonExclusive(page);\n\t\tif (freeze && anon_exclusive && page_try_share_anon_rmap(page))\n\t\t\tfreeze = false;\n\t\tif (!freeze)\n\t\t\tpage_ref_add(page, HPAGE_PMD_NR - 1);\n\t}\n\n\t \n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tpte = pte_offset_map(&_pmd, haddr);\n\tVM_BUG_ON(!pte);\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry;\n\t\t \n\t\tif (freeze || pmd_migration) {\n\t\t\tswp_entry_t swp_entry;\n\t\t\tif (write)\n\t\t\t\tswp_entry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page + i));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tswp_entry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page + i));\n\t\t\telse\n\t\t\t\tswp_entry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page + i));\n\t\t\tif (young)\n\t\t\t\tswp_entry = make_migration_entry_young(swp_entry);\n\t\t\tif (dirty)\n\t\t\t\tswp_entry = make_migration_entry_dirty(swp_entry);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_swp_mksoft_dirty(entry);\n\t\t\tif (uffd_wp)\n\t\t\t\tentry = pte_swp_mkuffd_wp(entry);\n\t\t} else {\n\t\t\tentry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));\n\t\t\tif (write)\n\t\t\t\tentry = pte_mkwrite(entry, vma);\n\t\t\tif (anon_exclusive)\n\t\t\t\tSetPageAnonExclusive(page + i);\n\t\t\tif (!young)\n\t\t\t\tentry = pte_mkold(entry);\n\t\t\t \n\t\t\tif (dirty)\n\t\t\t\tentry = pte_mkdirty(entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_mksoft_dirty(entry);\n\t\t\tif (uffd_wp)\n\t\t\t\tentry = pte_mkuffd_wp(entry);\n\t\t\tpage_add_anon_rmap(page + i, vma, addr, RMAP_NONE);\n\t\t}\n\t\tVM_BUG_ON(!pte_none(ptep_get(pte)));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tpte++;\n\t}\n\tpte_unmap(pte - 1);\n\n\tif (!pmd_migration)\n\t\tpage_remove_rmap(page, vma, true);\n\tif (freeze)\n\t\tput_page(page);\n\n\tsmp_wmb();  \n\tpmd_populate(mm, pmd, pgtable);\n}\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct folio *folio)\n{\n\tspinlock_t *ptl;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma->vm_mm,\n\t\t\t\taddress & HPAGE_PMD_MASK,\n\t\t\t\t(address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE);\n\tmmu_notifier_invalidate_range_start(&range);\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\n\t \n\tVM_BUG_ON(freeze && !folio);\n\tVM_WARN_ON_ONCE(folio && !folio_test_locked(folio));\n\n\tif (pmd_trans_huge(*pmd) || pmd_devmap(*pmd) ||\n\t    is_pmd_migration_entry(*pmd)) {\n\t\t \n\t\tif (folio && folio != page_folio(pmd_page(*pmd)))\n\t\t\tgoto out;\n\t\t__split_huge_pmd_locked(vma, pmd, range.start, freeze);\n\t}\n\nout:\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(&range);\n}\n\nvoid split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct folio *folio)\n{\n\tpmd_t *pmd = mm_find_pmd(vma->vm_mm, address);\n\n\tif (!pmd)\n\t\treturn;\n\n\t__split_huge_pmd(vma, pmd, address, freeze, folio);\n}\n\nstatic inline void split_huge_pmd_if_needed(struct vm_area_struct *vma, unsigned long address)\n{\n\t \n\tif (!IS_ALIGNED(address, HPAGE_PMD_SIZE) &&\n\t    range_in_vma(vma, ALIGN_DOWN(address, HPAGE_PMD_SIZE),\n\t\t\t ALIGN(address, HPAGE_PMD_SIZE)))\n\t\tsplit_huge_pmd_address(vma, address, false, NULL);\n}\n\nvoid vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t     unsigned long start,\n\t\t\t     unsigned long end,\n\t\t\t     long adjust_next)\n{\n\t \n\tsplit_huge_pmd_if_needed(vma, start);\n\n\t \n\tsplit_huge_pmd_if_needed(vma, end);\n\n\t \n\tif (adjust_next > 0) {\n\t\tstruct vm_area_struct *next = find_vma(vma->vm_mm, vma->vm_end);\n\t\tunsigned long nstart = next->vm_start;\n\t\tnstart += adjust_next;\n\t\tsplit_huge_pmd_if_needed(next, nstart);\n\t}\n}\n\nstatic void unmap_folio(struct folio *folio)\n{\n\tenum ttu_flags ttu_flags = TTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD |\n\t\tTTU_SYNC;\n\n\tVM_BUG_ON_FOLIO(!folio_test_large(folio), folio);\n\n\t \n\tif (folio_test_anon(folio))\n\t\ttry_to_migrate(folio, ttu_flags);\n\telse\n\t\ttry_to_unmap(folio, ttu_flags | TTU_IGNORE_MLOCK);\n}\n\nstatic void remap_page(struct folio *folio, unsigned long nr)\n{\n\tint i = 0;\n\n\t \n\tif (!folio_test_anon(folio))\n\t\treturn;\n\tfor (;;) {\n\t\tremove_migration_ptes(folio, folio, true);\n\t\ti += folio_nr_pages(folio);\n\t\tif (i >= nr)\n\t\t\tbreak;\n\t\tfolio = folio_next(folio);\n\t}\n}\n\nstatic void lru_add_page_tail(struct page *head, struct page *tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tVM_BUG_ON_PAGE(!PageHead(head), head);\n\tVM_BUG_ON_PAGE(PageCompound(tail), head);\n\tVM_BUG_ON_PAGE(PageLRU(tail), head);\n\tlockdep_assert_held(&lruvec->lru_lock);\n\n\tif (list) {\n\t\t \n\t\tVM_WARN_ON(PageLRU(head));\n\t\tget_page(tail);\n\t\tlist_add_tail(&tail->lru, list);\n\t} else {\n\t\t \n\t\tVM_WARN_ON(!PageLRU(head));\n\t\tif (PageUnevictable(tail))\n\t\t\ttail->mlock_count = 0;\n\t\telse\n\t\t\tlist_add_tail(&tail->lru, &head->lru);\n\t\tSetPageLRU(tail);\n\t}\n}\n\nstatic void __split_huge_page_tail(struct folio *folio, int tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tstruct page *head = &folio->page;\n\tstruct page *page_tail = head + tail;\n\t \n\tstruct folio *new_folio = (struct folio *)page_tail;\n\n\tVM_BUG_ON_PAGE(atomic_read(&page_tail->_mapcount) != -1, page_tail);\n\n\t \n\tpage_tail->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\tpage_tail->flags |= (head->flags &\n\t\t\t((1L << PG_referenced) |\n\t\t\t (1L << PG_swapbacked) |\n\t\t\t (1L << PG_swapcache) |\n\t\t\t (1L << PG_mlocked) |\n\t\t\t (1L << PG_uptodate) |\n\t\t\t (1L << PG_active) |\n\t\t\t (1L << PG_workingset) |\n\t\t\t (1L << PG_locked) |\n\t\t\t (1L << PG_unevictable) |\n#ifdef CONFIG_ARCH_USES_PG_ARCH_X\n\t\t\t (1L << PG_arch_2) |\n\t\t\t (1L << PG_arch_3) |\n#endif\n\t\t\t (1L << PG_dirty) |\n\t\t\t LRU_GEN_MASK | LRU_REFS_MASK));\n\n\t \n\tVM_BUG_ON_PAGE(tail > 2 && page_tail->mapping != TAIL_MAPPING,\n\t\t\tpage_tail);\n\tpage_tail->mapping = head->mapping;\n\tpage_tail->index = head->index + tail;\n\n\t \n\tif (unlikely(page_tail->private)) {\n\t\tVM_WARN_ON_ONCE_PAGE(true, page_tail);\n\t\tpage_tail->private = 0;\n\t}\n\tif (folio_test_swapcache(folio))\n\t\tnew_folio->swap.val = folio->swap.val + tail;\n\n\t \n\tsmp_wmb();\n\n\t \n\tclear_compound_head(page_tail);\n\n\t \n\tpage_ref_unfreeze(page_tail, 1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head)));\n\n\tif (page_is_young(head))\n\t\tset_page_young(page_tail);\n\tif (page_is_idle(head))\n\t\tset_page_idle(page_tail);\n\n\tpage_cpupid_xchg_last(page_tail, page_cpupid_last(head));\n\n\t \n\tlru_add_page_tail(head, page_tail, lruvec, list);\n}\n\nstatic void __split_huge_page(struct page *page, struct list_head *list,\n\t\tpgoff_t end)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct page *head = &folio->page;\n\tstruct lruvec *lruvec;\n\tstruct address_space *swap_cache = NULL;\n\tunsigned long offset = 0;\n\tunsigned int nr = thp_nr_pages(head);\n\tint i, nr_dropped = 0;\n\n\t \n\tsplit_page_memcg(head, nr);\n\n\tif (folio_test_anon(folio) && folio_test_swapcache(folio)) {\n\t\toffset = swp_offset(folio->swap);\n\t\tswap_cache = swap_address_space(folio->swap);\n\t\txa_lock(&swap_cache->i_pages);\n\t}\n\n\t \n\tlruvec = folio_lruvec_lock(folio);\n\n\tClearPageHasHWPoisoned(head);\n\n\tfor (i = nr - 1; i >= 1; i--) {\n\t\t__split_huge_page_tail(folio, i, lruvec, list);\n\t\t \n\t\tif (head[i].index >= end) {\n\t\t\tstruct folio *tail = page_folio(head + i);\n\n\t\t\tif (shmem_mapping(head->mapping))\n\t\t\t\tnr_dropped++;\n\t\t\telse if (folio_test_clear_dirty(tail))\n\t\t\t\tfolio_account_cleaned(tail,\n\t\t\t\t\tinode_to_wb(folio->mapping->host));\n\t\t\t__filemap_remove_folio(tail, NULL);\n\t\t\tfolio_put(tail);\n\t\t} else if (!PageAnon(page)) {\n\t\t\t__xa_store(&head->mapping->i_pages, head[i].index,\n\t\t\t\t\thead + i, 0);\n\t\t} else if (swap_cache) {\n\t\t\t__xa_store(&swap_cache->i_pages, offset + i,\n\t\t\t\t\thead + i, 0);\n\t\t}\n\t}\n\n\tClearPageCompound(head);\n\tunlock_page_lruvec(lruvec);\n\t \n\n\tsplit_page_owner(head, nr);\n\n\t \n\tif (PageAnon(head)) {\n\t\t \n\t\tif (PageSwapCache(head)) {\n\t\t\tpage_ref_add(head, 2);\n\t\t\txa_unlock(&swap_cache->i_pages);\n\t\t} else {\n\t\t\tpage_ref_inc(head);\n\t\t}\n\t} else {\n\t\t \n\t\tpage_ref_add(head, 2);\n\t\txa_unlock(&head->mapping->i_pages);\n\t}\n\tlocal_irq_enable();\n\n\tif (nr_dropped)\n\t\tshmem_uncharge(head->mapping->host, nr_dropped);\n\tremap_page(folio, nr);\n\n\tif (folio_test_swapcache(folio))\n\t\tsplit_swap_cluster(folio->swap);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *subpage = head + i;\n\t\tif (subpage == page)\n\t\t\tcontinue;\n\t\tunlock_page(subpage);\n\n\t\t \n\t\tfree_page_and_swap_cache(subpage);\n\t}\n}\n\n \nbool can_split_folio(struct folio *folio, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t \n\tif (folio_test_anon(folio))\n\t\textra_pins = folio_test_swapcache(folio) ?\n\t\t\t\tfolio_nr_pages(folio) : 0;\n\telse\n\t\textra_pins = folio_nr_pages(folio);\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn folio_mapcount(folio) == folio_ref_count(folio) - extra_pins - 1;\n}\n\n \nint split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct deferred_split *ds_queue = get_deferred_split_queue(folio);\n\tXA_STATE(xas, &folio->mapping->i_pages, folio->index);\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint extra_pins, ret;\n\tpgoff_t end;\n\tbool is_hzp;\n\n\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n\tVM_BUG_ON_FOLIO(!folio_test_large(folio), folio);\n\n\tis_hzp = is_huge_zero_page(&folio->page);\n\tif (is_hzp) {\n\t\tpr_warn_ratelimited(\"Called split_huge_page for huge zero page\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (folio_test_writeback(folio))\n\t\treturn -EBUSY;\n\n\tif (folio_test_anon(folio)) {\n\t\t \n\t\tanon_vma = folio_get_anon_vma(folio);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tend = -1;\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tgfp_t gfp;\n\n\t\tmapping = folio->mapping;\n\n\t\t \n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgfp = current_gfp_context(mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\tGFP_RECLAIM_MASK);\n\n\t\tif (!filemap_release_folio(folio, gfp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\txas_split_alloc(&xas, folio, folio_order(folio), gfp);\n\t\tif (xas_error(&xas)) {\n\t\t\tret = xas_error(&xas);\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\n\t\t \n\t\tend = DIV_ROUND_UP(i_size_read(mapping->host), PAGE_SIZE);\n\t\tif (shmem_mapping(mapping))\n\t\t\tend = shmem_fallocend(mapping->host, end);\n\t}\n\n\t \n\tif (!can_split_folio(folio, &extra_pins)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tunmap_folio(folio);\n\n\t \n\tlocal_irq_disable();\n\tif (mapping) {\n\t\t \n\t\txas_lock(&xas);\n\t\txas_reset(&xas);\n\t\tif (xas_load(&xas) != folio)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tspin_lock(&ds_queue->split_queue_lock);\n\tif (folio_ref_freeze(folio, 1 + extra_pins)) {\n\t\tif (!list_empty(&folio->_deferred_list)) {\n\t\t\tds_queue->split_queue_len--;\n\t\t\tlist_del(&folio->_deferred_list);\n\t\t}\n\t\tspin_unlock(&ds_queue->split_queue_lock);\n\t\tif (mapping) {\n\t\t\tint nr = folio_nr_pages(folio);\n\n\t\t\txas_split(&xas, folio, folio_order(folio));\n\t\t\tif (folio_test_pmd_mappable(folio)) {\n\t\t\t\tif (folio_test_swapbacked(folio)) {\n\t\t\t\t\t__lruvec_stat_mod_folio(folio,\n\t\t\t\t\t\t\tNR_SHMEM_THPS, -nr);\n\t\t\t\t} else {\n\t\t\t\t\t__lruvec_stat_mod_folio(folio,\n\t\t\t\t\t\t\tNR_FILE_THPS, -nr);\n\t\t\t\t\tfilemap_nr_thps_dec(mapping);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t__split_huge_page(page, list, end);\n\t\tret = 0;\n\t} else {\n\t\tspin_unlock(&ds_queue->split_queue_lock);\nfail:\n\t\tif (mapping)\n\t\t\txas_unlock(&xas);\n\t\tlocal_irq_enable();\n\t\tremap_page(folio, folio_nr_pages(folio));\n\t\tret = -EAGAIN;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\txas_destroy(&xas);\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}\n\nvoid folio_undo_large_rmappable(struct folio *folio)\n{\n\tstruct deferred_split *ds_queue;\n\tunsigned long flags;\n\n\t \n\tif (data_race(list_empty(&folio->_deferred_list)))\n\t\treturn;\n\n\tds_queue = get_deferred_split_queue(folio);\n\tspin_lock_irqsave(&ds_queue->split_queue_lock, flags);\n\tif (!list_empty(&folio->_deferred_list)) {\n\t\tds_queue->split_queue_len--;\n\t\tlist_del(&folio->_deferred_list);\n\t}\n\tspin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);\n}\n\nvoid deferred_split_folio(struct folio *folio)\n{\n\tstruct deferred_split *ds_queue = get_deferred_split_queue(folio);\n#ifdef CONFIG_MEMCG\n\tstruct mem_cgroup *memcg = folio_memcg(folio);\n#endif\n\tunsigned long flags;\n\n\tVM_BUG_ON_FOLIO(folio_order(folio) < 2, folio);\n\n\t \n\tif (folio_test_swapcache(folio))\n\t\treturn;\n\n\tif (!list_empty(&folio->_deferred_list))\n\t\treturn;\n\n\tspin_lock_irqsave(&ds_queue->split_queue_lock, flags);\n\tif (list_empty(&folio->_deferred_list)) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(&folio->_deferred_list, &ds_queue->split_queue);\n\t\tds_queue->split_queue_len++;\n#ifdef CONFIG_MEMCG\n\t\tif (memcg)\n\t\t\tset_shrinker_bit(memcg, folio_nid(folio),\n\t\t\t\t\t deferred_split_shrinker.id);\n#endif\n\t}\n\tspin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);\n}\n\nstatic unsigned long deferred_split_count(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\tstruct deferred_split *ds_queue = &pgdata->deferred_split_queue;\n\n#ifdef CONFIG_MEMCG\n\tif (sc->memcg)\n\t\tds_queue = &sc->memcg->deferred_split_queue;\n#endif\n\treturn READ_ONCE(ds_queue->split_queue_len);\n}\n\nstatic unsigned long deferred_split_scan(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\tstruct deferred_split *ds_queue = &pgdata->deferred_split_queue;\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\tstruct folio *folio, *next;\n\tint split = 0;\n\n#ifdef CONFIG_MEMCG\n\tif (sc->memcg)\n\t\tds_queue = &sc->memcg->deferred_split_queue;\n#endif\n\n\tspin_lock_irqsave(&ds_queue->split_queue_lock, flags);\n\t \n\tlist_for_each_entry_safe(folio, next, &ds_queue->split_queue,\n\t\t\t\t\t\t\t_deferred_list) {\n\t\tif (folio_try_get(folio)) {\n\t\t\tlist_move(&folio->_deferred_list, &list);\n\t\t} else {\n\t\t\t \n\t\t\tlist_del_init(&folio->_deferred_list);\n\t\t\tds_queue->split_queue_len--;\n\t\t}\n\t\tif (!--sc->nr_to_scan)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);\n\n\tlist_for_each_entry_safe(folio, next, &list, _deferred_list) {\n\t\tif (!folio_trylock(folio))\n\t\t\tgoto next;\n\t\t \n\t\tif (!split_folio(folio))\n\t\t\tsplit++;\n\t\tfolio_unlock(folio);\nnext:\n\t\tfolio_put(folio);\n\t}\n\n\tspin_lock_irqsave(&ds_queue->split_queue_lock, flags);\n\tlist_splice_tail(&list, &ds_queue->split_queue);\n\tspin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);\n\n\t \n\tif (!split && list_empty(&ds_queue->split_queue))\n\t\treturn SHRINK_STOP;\n\treturn split;\n}\n\nstatic struct shrinker deferred_split_shrinker = {\n\t.count_objects = deferred_split_count,\n\t.scan_objects = deferred_split_scan,\n\t.seeks = DEFAULT_SEEKS,\n\t.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE |\n\t\t SHRINKER_NONSLAB,\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic void split_huge_pages_all(void)\n{\n\tstruct zone *zone;\n\tstruct page *page;\n\tstruct folio *folio;\n\tunsigned long pfn, max_zone_pfn;\n\tunsigned long total = 0, split = 0;\n\n\tpr_debug(\"Split all THPs\\n\");\n\tfor_each_zone(zone) {\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++) {\n\t\t\tint nr_pages;\n\n\t\t\tpage = pfn_to_online_page(pfn);\n\t\t\tif (!page || PageTail(page))\n\t\t\t\tcontinue;\n\t\t\tfolio = page_folio(page);\n\t\t\tif (!folio_try_get(folio))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page_folio(page) != folio))\n\t\t\t\tgoto next;\n\n\t\t\tif (zone != folio_zone(folio))\n\t\t\t\tgoto next;\n\n\t\t\tif (!folio_test_large(folio)\n\t\t\t\t|| folio_test_hugetlb(folio)\n\t\t\t\t|| !folio_test_lru(folio))\n\t\t\t\tgoto next;\n\n\t\t\ttotal++;\n\t\t\tfolio_lock(folio);\n\t\t\tnr_pages = folio_nr_pages(folio);\n\t\t\tif (!split_folio(folio))\n\t\t\t\tsplit++;\n\t\t\tpfn += nr_pages - 1;\n\t\t\tfolio_unlock(folio);\nnext:\n\t\t\tfolio_put(folio);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tpr_debug(\"%lu of %lu THP split\\n\", split, total);\n}\n\nstatic inline bool vma_not_suitable_for_thp_split(struct vm_area_struct *vma)\n{\n\treturn vma_is_special_huge(vma) || (vma->vm_flags & VM_IO) ||\n\t\t    is_vm_hugetlb_page(vma);\n}\n\nstatic int split_huge_pages_pid(int pid, unsigned long vaddr_start,\n\t\t\t\tunsigned long vaddr_end)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long total = 0, split = 0;\n\tunsigned long addr;\n\n\tvaddr_start &= PAGE_MASK;\n\tvaddr_end &= PAGE_MASK;\n\n\t \n\trcu_read_lock();\n\ttask = find_task_by_vpid(pid);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\trcu_read_unlock();\n\n\t \n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"Split huge pages in pid: %d, vaddr: [0x%lx - 0x%lx]\\n\",\n\t\t pid, vaddr_start, vaddr_end);\n\n\tmmap_read_lock(mm);\n\t \n\tfor (addr = vaddr_start; addr < vaddr_end; addr += PAGE_SIZE) {\n\t\tstruct vm_area_struct *vma = vma_lookup(mm, addr);\n\t\tstruct page *page;\n\t\tstruct folio *folio;\n\n\t\tif (!vma)\n\t\t\tbreak;\n\n\t\t \n\t\tif (vma_not_suitable_for_thp_split(vma)) {\n\t\t\taddr = vma->vm_end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpage = follow_page(vma, addr, FOLL_GET | FOLL_DUMP);\n\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tcontinue;\n\n\t\tfolio = page_folio(page);\n\t\tif (!is_transparent_hugepage(folio))\n\t\t\tgoto next;\n\n\t\ttotal++;\n\t\tif (!can_split_folio(folio, NULL))\n\t\t\tgoto next;\n\n\t\tif (!folio_trylock(folio))\n\t\t\tgoto next;\n\n\t\tif (!split_folio(folio))\n\t\t\tsplit++;\n\n\t\tfolio_unlock(folio);\nnext:\n\t\tfolio_put(folio);\n\t\tcond_resched();\n\t}\n\tmmap_read_unlock(mm);\n\tmmput(mm);\n\n\tpr_debug(\"%lu of %lu THP split\\n\", split, total);\n\nout:\n\treturn ret;\n}\n\nstatic int split_huge_pages_in_file(const char *file_path, pgoff_t off_start,\n\t\t\t\tpgoff_t off_end)\n{\n\tstruct filename *file;\n\tstruct file *candidate;\n\tstruct address_space *mapping;\n\tint ret = -EINVAL;\n\tpgoff_t index;\n\tint nr_pages = 1;\n\tunsigned long total = 0, split = 0;\n\n\tfile = getname_kernel(file_path);\n\tif (IS_ERR(file))\n\t\treturn ret;\n\n\tcandidate = file_open_name(file, O_RDONLY, 0);\n\tif (IS_ERR(candidate))\n\t\tgoto out;\n\n\tpr_debug(\"split file-backed THPs in file: %s, page offset: [0x%lx - 0x%lx]\\n\",\n\t\t file_path, off_start, off_end);\n\n\tmapping = candidate->f_mapping;\n\n\tfor (index = off_start; index < off_end; index += nr_pages) {\n\t\tstruct folio *folio = filemap_get_folio(mapping, index);\n\n\t\tnr_pages = 1;\n\t\tif (IS_ERR(folio))\n\t\t\tcontinue;\n\n\t\tif (!folio_test_large(folio))\n\t\t\tgoto next;\n\n\t\ttotal++;\n\t\tnr_pages = folio_nr_pages(folio);\n\n\t\tif (!folio_trylock(folio))\n\t\t\tgoto next;\n\n\t\tif (!split_folio(folio))\n\t\t\tsplit++;\n\n\t\tfolio_unlock(folio);\nnext:\n\t\tfolio_put(folio);\n\t\tcond_resched();\n\t}\n\n\tfilp_close(candidate, NULL);\n\tret = 0;\n\n\tpr_debug(\"%lu of %lu file-backed THP split\\n\", split, total);\nout:\n\tputname(file);\n\treturn ret;\n}\n\n#define MAX_INPUT_BUF_SZ 255\n\nstatic ssize_t split_huge_pages_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppops)\n{\n\tstatic DEFINE_MUTEX(split_debug_mutex);\n\tssize_t ret;\n\t \n\tchar input_buf[MAX_INPUT_BUF_SZ];\n\tint pid;\n\tunsigned long vaddr_start, vaddr_end;\n\n\tret = mutex_lock_interruptible(&split_debug_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\n\tmemset(input_buf, 0, MAX_INPUT_BUF_SZ);\n\tif (copy_from_user(input_buf, buf, min_t(size_t, count, MAX_INPUT_BUF_SZ)))\n\t\tgoto out;\n\n\tinput_buf[MAX_INPUT_BUF_SZ - 1] = '\\0';\n\n\tif (input_buf[0] == '/') {\n\t\tchar *tok;\n\t\tchar *buf = input_buf;\n\t\tchar file_path[MAX_INPUT_BUF_SZ];\n\t\tpgoff_t off_start = 0, off_end = 0;\n\t\tsize_t input_len = strlen(input_buf);\n\n\t\ttok = strsep(&buf, \",\");\n\t\tif (tok) {\n\t\t\tstrcpy(file_path, tok);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = sscanf(buf, \"0x%lx,0x%lx\", &off_start, &off_end);\n\t\tif (ret != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = split_huge_pages_in_file(file_path, off_start, off_end);\n\t\tif (!ret)\n\t\t\tret = input_len;\n\n\t\tgoto out;\n\t}\n\n\tret = sscanf(input_buf, \"%d,0x%lx,0x%lx\", &pid, &vaddr_start, &vaddr_end);\n\tif (ret == 1 && pid == 1) {\n\t\tsplit_huge_pages_all();\n\t\tret = strlen(input_buf);\n\t\tgoto out;\n\t} else if (ret != 3) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = split_huge_pages_pid(pid, vaddr_start, vaddr_end);\n\tif (!ret)\n\t\tret = strlen(input_buf);\nout:\n\tmutex_unlock(&split_debug_mutex);\n\treturn ret;\n\n}\n\nstatic const struct file_operations split_huge_pages_fops = {\n\t.owner\t = THIS_MODULE,\n\t.write\t = split_huge_pages_write,\n\t.llseek  = no_llseek,\n};\n\nstatic int __init split_huge_pages_debugfs(void)\n{\n\tdebugfs_create_file(\"split_huge_pages\", 0200, NULL, NULL,\n\t\t\t    &split_huge_pages_fops);\n\treturn 0;\n}\nlate_initcall(split_huge_pages_debugfs);\n#endif\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\nint set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tbool anon_exclusive;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn 0;\n\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = pmdp_invalidate(vma, address, pvmw->pmd);\n\n\t \n\tanon_exclusive = PageAnon(page) && PageAnonExclusive(page);\n\tif (anon_exclusive && page_try_share_anon_rmap(page)) {\n\t\tset_pmd_at(mm, address, pvmw->pmd, pmdval);\n\t\treturn -EBUSY;\n\t}\n\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tif (pmd_write(pmdval))\n\t\tentry = make_writable_migration_entry(page_to_pfn(page));\n\telse if (anon_exclusive)\n\t\tentry = make_readable_exclusive_migration_entry(page_to_pfn(page));\n\telse\n\t\tentry = make_readable_migration_entry(page_to_pfn(page));\n\tif (pmd_young(pmdval))\n\t\tentry = make_migration_entry_young(entry);\n\tif (pmd_dirty(pmdval))\n\t\tentry = make_migration_entry_dirty(entry);\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tif (pmd_uffd_wp(pmdval))\n\t\tpmdswp = pmd_swp_mkuffd_wp(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, vma, true);\n\tput_page(page);\n\ttrace_set_migration_pmd(address, pmd_val(pmdswp));\n\n\treturn 0;\n}\n\nvoid remove_migration_pmd(struct page_vma_mapped_walk *pvmw, struct page *new)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\tpmd_t pmde;\n\tswp_entry_t entry;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tentry = pmd_to_swp_entry(*pvmw->pmd);\n\tget_page(new);\n\tpmde = mk_huge_pmd(new, READ_ONCE(vma->vm_page_prot));\n\tif (pmd_swp_soft_dirty(*pvmw->pmd))\n\t\tpmde = pmd_mksoft_dirty(pmde);\n\tif (is_writable_migration_entry(entry))\n\t\tpmde = pmd_mkwrite(pmde, vma);\n\tif (pmd_swp_uffd_wp(*pvmw->pmd))\n\t\tpmde = pmd_mkuffd_wp(pmde);\n\tif (!is_migration_entry_young(entry))\n\t\tpmde = pmd_mkold(pmde);\n\t \n\tif (PageDirty(new) && is_migration_entry_dirty(entry))\n\t\tpmde = pmd_mkdirty(pmde);\n\n\tif (PageAnon(new)) {\n\t\trmap_t rmap_flags = RMAP_COMPOUND;\n\n\t\tif (!is_readable_migration_entry(entry))\n\t\t\trmap_flags |= RMAP_EXCLUSIVE;\n\n\t\tpage_add_anon_rmap(new, vma, haddr, rmap_flags);\n\t} else {\n\t\tpage_add_file_rmap(new, vma, true);\n\t}\n\tVM_BUG_ON(pmd_write(pmde) && PageAnon(new) && !PageAnonExclusive(new));\n\tset_pmd_at(mm, haddr, pvmw->pmd, pmde);\n\n\t \n\tupdate_mmu_cache_pmd(vma, address, pvmw->pmd);\n\ttrace_remove_migration_pmd(address, pmd_val(pmde));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}