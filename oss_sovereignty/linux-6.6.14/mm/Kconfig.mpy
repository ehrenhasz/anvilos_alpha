{
  "module_name": "Kconfig",
  "hash_id": "11b2a0c24a68d3a1c97034b45d8dff60365bb3f620b0fcd3a818495e3337bd07",
  "original_prompt": "Ingested from linux-6.6.14/mm/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\nmenu \"Memory Management options\"\n\n#\n# For some reason microblaze and nios2 hard code SWAP=n.  Hopefully we can\n# add proper SWAP support to them, in which case this can be remove.\n#\nconfig ARCH_NO_SWAP\n\tbool\n\nconfig ZPOOL\n\tbool\n\nmenuconfig SWAP\n\tbool \"Support for paging of anonymous memory (swap)\"\n\tdepends on MMU && BLOCK && !ARCH_NO_SWAP\n\tdefault y\n\thelp\n\t  This option allows you to choose whether you want to have support\n\t  for so called swap devices or swap files in your kernel that are\n\t  used to provide more virtual memory than the actual RAM present\n\t  in your computer.  If unsure say Y.\n\nconfig ZSWAP\n\tbool \"Compressed cache for swap pages\"\n\tdepends on SWAP\n\tselect CRYPTO\n\tselect ZPOOL\n\thelp\n\t  A lightweight compressed cache for swap pages.  It takes\n\t  pages that are in the process of being swapped out and attempts to\n\t  compress them into a dynamically allocated RAM-based memory pool.\n\t  This can result in a significant I/O reduction on swap device and,\n\t  in the case where decompressing from RAM is faster than swap device\n\t  reads, can also improve workload performance.\n\nconfig ZSWAP_DEFAULT_ON\n\tbool \"Enable the compressed cache for swap pages by default\"\n\tdepends on ZSWAP\n\thelp\n\t  If selected, the compressed cache for swap pages will be enabled\n\t  at boot, otherwise it will be disabled.\n\n\t  The selection made here can be overridden by using the kernel\n\t  command line 'zswap.enabled=' option.\n\nconfig ZSWAP_EXCLUSIVE_LOADS_DEFAULT_ON\n\tbool \"Invalidate zswap entries when pages are loaded\"\n\tdepends on ZSWAP\n\thelp\n\t  If selected, exclusive loads for zswap will be enabled at boot,\n\t  otherwise it will be disabled.\n\n\t  If exclusive loads are enabled, when a page is loaded from zswap,\n\t  the zswap entry is invalidated at once, as opposed to leaving it\n\t  in zswap until the swap entry is freed.\n\n\t  This avoids having two copies of the same page in memory\n\t  (compressed and uncompressed) after faulting in a page from zswap.\n\t  The cost is that if the page was never dirtied and needs to be\n\t  swapped out again, it will be re-compressed.\n\nchoice\n\tprompt \"Default compressor\"\n\tdepends on ZSWAP\n\tdefault ZSWAP_COMPRESSOR_DEFAULT_LZO\n\thelp\n\t  Selects the default compression algorithm for the compressed cache\n\t  for swap pages.\n\n\t  For an overview what kind of performance can be expected from\n\t  a particular compression algorithm please refer to the benchmarks\n\t  available at the following LWN page:\n\t  https://lwn.net/Articles/751795/\n\n\t  If in doubt, select 'LZO'.\n\n\t  The selection made here can be overridden by using the kernel\n\t  command line 'zswap.compressor=' option.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_DEFLATE\n\tbool \"Deflate\"\n\tselect CRYPTO_DEFLATE\n\thelp\n\t  Use the Deflate algorithm as the default compression algorithm.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_LZO\n\tbool \"LZO\"\n\tselect CRYPTO_LZO\n\thelp\n\t  Use the LZO algorithm as the default compression algorithm.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_842\n\tbool \"842\"\n\tselect CRYPTO_842\n\thelp\n\t  Use the 842 algorithm as the default compression algorithm.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_LZ4\n\tbool \"LZ4\"\n\tselect CRYPTO_LZ4\n\thelp\n\t  Use the LZ4 algorithm as the default compression algorithm.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_LZ4HC\n\tbool \"LZ4HC\"\n\tselect CRYPTO_LZ4HC\n\thelp\n\t  Use the LZ4HC algorithm as the default compression algorithm.\n\nconfig ZSWAP_COMPRESSOR_DEFAULT_ZSTD\n\tbool \"zstd\"\n\tselect CRYPTO_ZSTD\n\thelp\n\t  Use the zstd algorithm as the default compression algorithm.\nendchoice\n\nconfig ZSWAP_COMPRESSOR_DEFAULT\n       string\n       depends on ZSWAP\n       default \"deflate\" if ZSWAP_COMPRESSOR_DEFAULT_DEFLATE\n       default \"lzo\" if ZSWAP_COMPRESSOR_DEFAULT_LZO\n       default \"842\" if ZSWAP_COMPRESSOR_DEFAULT_842\n       default \"lz4\" if ZSWAP_COMPRESSOR_DEFAULT_LZ4\n       default \"lz4hc\" if ZSWAP_COMPRESSOR_DEFAULT_LZ4HC\n       default \"zstd\" if ZSWAP_COMPRESSOR_DEFAULT_ZSTD\n       default \"\"\n\nchoice\n\tprompt \"Default allocator\"\n\tdepends on ZSWAP\n\tdefault ZSWAP_ZPOOL_DEFAULT_ZBUD\n\thelp\n\t  Selects the default allocator for the compressed cache for\n\t  swap pages.\n\t  The default is 'zbud' for compatibility, however please do\n\t  read the description of each of the allocators below before\n\t  making a right choice.\n\n\t  The selection made here can be overridden by using the kernel\n\t  command line 'zswap.zpool=' option.\n\nconfig ZSWAP_ZPOOL_DEFAULT_ZBUD\n\tbool \"zbud\"\n\tselect ZBUD\n\thelp\n\t  Use the zbud allocator as the default allocator.\n\nconfig ZSWAP_ZPOOL_DEFAULT_Z3FOLD\n\tbool \"z3fold\"\n\tselect Z3FOLD\n\thelp\n\t  Use the z3fold allocator as the default allocator.\n\nconfig ZSWAP_ZPOOL_DEFAULT_ZSMALLOC\n\tbool \"zsmalloc\"\n\tselect ZSMALLOC\n\thelp\n\t  Use the zsmalloc allocator as the default allocator.\nendchoice\n\nconfig ZSWAP_ZPOOL_DEFAULT\n       string\n       depends on ZSWAP\n       default \"zbud\" if ZSWAP_ZPOOL_DEFAULT_ZBUD\n       default \"z3fold\" if ZSWAP_ZPOOL_DEFAULT_Z3FOLD\n       default \"zsmalloc\" if ZSWAP_ZPOOL_DEFAULT_ZSMALLOC\n       default \"\"\n\nconfig ZBUD\n\ttristate \"2:1 compression allocator (zbud)\"\n\tdepends on ZSWAP\n\thelp\n\t  A special purpose allocator for storing compressed pages.\n\t  It is designed to store up to two compressed pages per physical\n\t  page.  While this design limits storage density, it has simple and\n\t  deterministic reclaim properties that make it preferable to a higher\n\t  density approach when reclaim will be used.\n\nconfig Z3FOLD\n\ttristate \"3:1 compression allocator (z3fold)\"\n\tdepends on ZSWAP\n\thelp\n\t  A special purpose allocator for storing compressed pages.\n\t  It is designed to store up to three compressed pages per physical\n\t  page. It is a ZBUD derivative so the simplicity and determinism are\n\t  still there.\n\nconfig ZSMALLOC\n\ttristate\n\tprompt \"N:1 compression allocator (zsmalloc)\" if ZSWAP\n\tdepends on MMU\n\thelp\n\t  zsmalloc is a slab-based memory allocator designed to store\n\t  pages of various compression levels efficiently. It achieves\n\t  the highest storage density with the least amount of fragmentation.\n\nconfig ZSMALLOC_STAT\n\tbool \"Export zsmalloc statistics\"\n\tdepends on ZSMALLOC\n\tselect DEBUG_FS\n\thelp\n\t  This option enables code in the zsmalloc to collect various\n\t  statistics about what's happening in zsmalloc and exports that\n\t  information to userspace via debugfs.\n\t  If unsure, say N.\n\nconfig ZSMALLOC_CHAIN_SIZE\n\tint \"Maximum number of physical pages per-zspage\"\n\tdefault 8\n\trange 4 16\n\tdepends on ZSMALLOC\n\thelp\n\t  This option sets the upper limit on the number of physical pages\n\t  that a zmalloc page (zspage) can consist of. The optimal zspage\n\t  chain size is calculated for each size class during the\n\t  initialization of the pool.\n\n\t  Changing this option can alter the characteristics of size classes,\n\t  such as the number of pages per zspage and the number of objects\n\t  per zspage. This can also result in different configurations of\n\t  the pool, as zsmalloc merges size classes with similar\n\t  characteristics.\n\n\t  For more information, see zsmalloc documentation.\n\nmenu \"SLAB allocator options\"\n\nchoice\n\tprompt \"Choose SLAB allocator\"\n\tdefault SLUB\n\thelp\n\t   This option allows to select a slab allocator.\n\nconfig SLAB_DEPRECATED\n\tbool \"SLAB (DEPRECATED)\"\n\tdepends on !PREEMPT_RT\n\thelp\n\t  Deprecated and scheduled for removal in a few cycles. Replaced by\n\t  SLUB.\n\n\t  If you cannot migrate to SLUB, please contact linux-mm@kvack.org\n\t  and the people listed in the SLAB ALLOCATOR section of MAINTAINERS\n\t  file, explaining why.\n\n\t  The regular slab allocator that is established and known to work\n\t  well in all environments. It organizes cache hot objects in\n\t  per cpu and per node queues.\n\nconfig SLUB\n\tbool \"SLUB (Unqueued Allocator)\"\n\thelp\n\t   SLUB is a slab allocator that minimizes cache line usage\n\t   instead of managing queues of cached objects (SLAB approach).\n\t   Per cpu caching is realized using slabs of objects instead\n\t   of queues of objects. SLUB can use memory efficiently\n\t   and has enhanced diagnostics. SLUB is the default choice for\n\t   a slab allocator.\n\nendchoice\n\nconfig SLAB\n\tbool\n\tdefault y\n\tdepends on SLAB_DEPRECATED\n\nconfig SLUB_TINY\n\tbool \"Configure SLUB for minimal memory footprint\"\n\tdepends on SLUB && EXPERT\n\tselect SLAB_MERGE_DEFAULT\n\thelp\n\t   Configures the SLUB allocator in a way to achieve minimal memory\n\t   footprint, sacrificing scalability, debugging and other features.\n\t   This is intended only for the smallest system that had used the\n\t   SLOB allocator and is not recommended for systems with more than\n\t   16MB RAM.\n\n\t   If unsure, say N.\n\nconfig SLAB_MERGE_DEFAULT\n\tbool \"Allow slab caches to be merged\"\n\tdefault y\n\tdepends on SLAB || SLUB\n\thelp\n\t  For reduced kernel memory fragmentation, slab caches can be\n\t  merged when they share the same size and other characteristics.\n\t  This carries a risk of kernel heap overflows being able to\n\t  overwrite objects from merged caches (and more easily control\n\t  cache layout), which makes such heap attacks easier to exploit\n\t  by attackers. By keeping caches unmerged, these kinds of exploits\n\t  can usually only damage objects in the same cache. To disable\n\t  merging at runtime, \"slab_nomerge\" can be passed on the kernel\n\t  command line.\n\nconfig SLAB_FREELIST_RANDOM\n\tbool \"Randomize slab freelist\"\n\tdepends on SLAB || (SLUB && !SLUB_TINY)\n\thelp\n\t  Randomizes the freelist order used on creating new pages. This\n\t  security feature reduces the predictability of the kernel slab\n\t  allocator against heap overflows.\n\nconfig SLAB_FREELIST_HARDENED\n\tbool \"Harden slab freelist metadata\"\n\tdepends on SLAB || (SLUB && !SLUB_TINY)\n\thelp\n\t  Many kernel heap attacks try to target slab cache metadata and\n\t  other infrastructure. This options makes minor performance\n\t  sacrifices to harden the kernel slab allocator against common\n\t  freelist exploit methods. Some slab implementations have more\n\t  sanity-checking than others. This option is most effective with\n\t  CONFIG_SLUB.\n\nconfig SLUB_STATS\n\tdefault n\n\tbool \"Enable SLUB performance statistics\"\n\tdepends on SLUB && SYSFS && !SLUB_TINY\n\thelp\n\t  SLUB statistics are useful to debug SLUBs allocation behavior in\n\t  order find ways to optimize the allocator. This should never be\n\t  enabled for production use since keeping statistics slows down\n\t  the allocator by a few percentage points. The slabinfo command\n\t  supports the determination of the most active slabs to figure\n\t  out which slabs are relevant to a particular load.\n\t  Try running: slabinfo -DA\n\nconfig SLUB_CPU_PARTIAL\n\tdefault y\n\tdepends on SLUB && SMP && !SLUB_TINY\n\tbool \"SLUB per cpu partial cache\"\n\thelp\n\t  Per cpu partial caches accelerate objects allocation and freeing\n\t  that is local to a processor at the price of more indeterminism\n\t  in the latency of the free. On overflow these caches will be cleared\n\t  which requires the taking of locks that may cause latency spikes.\n\t  Typically one would choose no for a realtime system.\n\nconfig RANDOM_KMALLOC_CACHES\n\tdefault n\n\tdepends on SLUB && !SLUB_TINY\n\tbool \"Randomize slab caches for normal kmalloc\"\n\thelp\n\t  A hardening feature that creates multiple copies of slab caches for\n\t  normal kmalloc allocation and makes kmalloc randomly pick one based\n\t  on code address, which makes the attackers more difficult to spray\n\t  vulnerable memory objects on the heap for the purpose of exploiting\n\t  memory vulnerabilities.\n\n\t  Currently the number of copies is set to 16, a reasonably large value\n\t  that effectively diverges the memory objects allocated for different\n\t  subsystems or modules into different caches, at the expense of a\n\t  limited degree of memory and CPU overhead that relates to hardware and\n\t  system workload.\n\nendmenu # SLAB allocator options\n\nconfig SHUFFLE_PAGE_ALLOCATOR\n\tbool \"Page allocator randomization\"\n\tdefault SLAB_FREELIST_RANDOM && ACPI_NUMA\n\thelp\n\t  Randomization of the page allocator improves the average\n\t  utilization of a direct-mapped memory-side-cache. See section\n\t  5.2.27 Heterogeneous Memory Attribute Table (HMAT) in the ACPI\n\t  6.2a specification for an example of how a platform advertises\n\t  the presence of a memory-side-cache. There are also incidental\n\t  security benefits as it reduces the predictability of page\n\t  allocations to compliment SLAB_FREELIST_RANDOM, but the\n\t  default granularity of shuffling on the MAX_ORDER i.e, 10th\n\t  order of pages is selected based on cache utilization benefits\n\t  on x86.\n\n\t  While the randomization improves cache utilization it may\n\t  negatively impact workloads on platforms without a cache. For\n\t  this reason, by default, the randomization is enabled only\n\t  after runtime detection of a direct-mapped memory-side-cache.\n\t  Otherwise, the randomization may be force enabled with the\n\t  'page_alloc.shuffle' kernel command line parameter.\n\n\t  Say Y if unsure.\n\nconfig COMPAT_BRK\n\tbool \"Disable heap randomization\"\n\tdefault y\n\thelp\n\t  Randomizing heap placement makes heap exploits harder, but it\n\t  also breaks ancient binaries (including anything libc5 based).\n\t  This option changes the bootup default to heap randomization\n\t  disabled, and can be overridden at runtime by setting\n\t  /proc/sys/kernel/randomize_va_space to 2.\n\n\t  On non-ancient distros (post-2000 ones) N is usually a safe choice.\n\nconfig MMAP_ALLOW_UNINITIALIZED\n\tbool \"Allow mmapped anonymous memory to be uninitialized\"\n\tdepends on EXPERT && !MMU\n\tdefault n\n\thelp\n\t  Normally, and according to the Linux spec, anonymous memory obtained\n\t  from mmap() has its contents cleared before it is passed to\n\t  userspace.  Enabling this config option allows you to request that\n\t  mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus\n\t  providing a huge performance boost.  If this option is not enabled,\n\t  then the flag will be ignored.\n\n\t  This is taken advantage of by uClibc's malloc(), and also by\n\t  ELF-FDPIC binfmt's brk and stack allocator.\n\n\t  Because of the obvious security issues, this option should only be\n\t  enabled on embedded devices where you control what is run in\n\t  userspace.  Since that isn't generally a problem on no-MMU systems,\n\t  it is normally safe to say Y here.\n\n\t  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.\n\nconfig SELECT_MEMORY_MODEL\n\tdef_bool y\n\tdepends on ARCH_SELECT_MEMORY_MODEL\n\nchoice\n\tprompt \"Memory model\"\n\tdepends on SELECT_MEMORY_MODEL\n\tdefault SPARSEMEM_MANUAL if ARCH_SPARSEMEM_DEFAULT\n\tdefault FLATMEM_MANUAL\n\thelp\n\t  This option allows you to change some of the ways that\n\t  Linux manages its memory internally. Most users will\n\t  only have one option here selected by the architecture\n\t  configuration. This is normal.\n\nconfig FLATMEM_MANUAL\n\tbool \"Flat Memory\"\n\tdepends on !ARCH_SPARSEMEM_ENABLE || ARCH_FLATMEM_ENABLE\n\thelp\n\t  This option is best suited for non-NUMA systems with\n\t  flat address space. The FLATMEM is the most efficient\n\t  system in terms of performance and resource consumption\n\t  and it is the best option for smaller systems.\n\n\t  For systems that have holes in their physical address\n\t  spaces and for features like NUMA and memory hotplug,\n\t  choose \"Sparse Memory\".\n\n\t  If unsure, choose this option (Flat Memory) over any other.\n\nconfig SPARSEMEM_MANUAL\n\tbool \"Sparse Memory\"\n\tdepends on ARCH_SPARSEMEM_ENABLE\n\thelp\n\t  This will be the only option for some systems, including\n\t  memory hot-plug systems.  This is normal.\n\n\t  This option provides efficient support for systems with\n\t  holes is their physical address space and allows memory\n\t  hot-plug and hot-remove.\n\n\t  If unsure, choose \"Flat Memory\" over this option.\n\nendchoice\n\nconfig SPARSEMEM\n\tdef_bool y\n\tdepends on (!SELECT_MEMORY_MODEL && ARCH_SPARSEMEM_ENABLE) || SPARSEMEM_MANUAL\n\nconfig FLATMEM\n\tdef_bool y\n\tdepends on !SPARSEMEM || FLATMEM_MANUAL\n\n#\n# SPARSEMEM_EXTREME (which is the default) does some bootmem\n# allocations when sparse_init() is called.  If this cannot\n# be done on your architecture, select this option.  However,\n# statically allocating the mem_section[] array can potentially\n# consume vast quantities of .bss, so be careful.\n#\n# This option will also potentially produce smaller runtime code\n# with gcc 3.4 and later.\n#\nconfig SPARSEMEM_STATIC\n\tbool\n\n#\n# Architecture platforms which require a two level mem_section in SPARSEMEM\n# must select this option. This is usually for architecture platforms with\n# an extremely sparse physical address space.\n#\nconfig SPARSEMEM_EXTREME\n\tdef_bool y\n\tdepends on SPARSEMEM && !SPARSEMEM_STATIC\n\nconfig SPARSEMEM_VMEMMAP_ENABLE\n\tbool\n\nconfig SPARSEMEM_VMEMMAP\n\tbool \"Sparse Memory virtual memmap\"\n\tdepends on SPARSEMEM && SPARSEMEM_VMEMMAP_ENABLE\n\tdefault y\n\thelp\n\t  SPARSEMEM_VMEMMAP uses a virtually mapped memmap to optimise\n\t  pfn_to_page and page_to_pfn operations.  This is the most\n\t  efficient option when sufficient kernel resources are available.\n#\n# Select this config option from the architecture Kconfig, if it is preferred\n# to enable the feature of HugeTLB/dev_dax vmemmap optimization.\n#\nconfig ARCH_WANT_OPTIMIZE_DAX_VMEMMAP\n\tbool\n\nconfig ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP\n\tbool\n\nconfig HAVE_MEMBLOCK_PHYS_MAP\n\tbool\n\nconfig HAVE_FAST_GUP\n\tdepends on MMU\n\tbool\n\n# Don't discard allocated memory used to track \"memory\" and \"reserved\" memblocks\n# after early boot, so it can still be used to test for validity of memory.\n# Also, memblocks are updated with memory hot(un)plug.\nconfig ARCH_KEEP_MEMBLOCK\n\tbool\n\n# Keep arch NUMA mapping infrastructure post-init.\nconfig NUMA_KEEP_MEMINFO\n\tbool\n\nconfig MEMORY_ISOLATION\n\tbool\n\n# IORESOURCE_SYSTEM_RAM regions in the kernel resource tree that are marked\n# IORESOURCE_EXCLUSIVE cannot be mapped to user space, for example, via\n# /dev/mem.\nconfig EXCLUSIVE_SYSTEM_RAM\n\tdef_bool y\n\tdepends on !DEVMEM || STRICT_DEVMEM\n\n#\n# Only be set on architectures that have completely implemented memory hotplug\n# feature. If you are not sure, don't touch it.\n#\nconfig HAVE_BOOTMEM_INFO_NODE\n\tdef_bool n\n\nconfig ARCH_ENABLE_MEMORY_HOTPLUG\n\tbool\n\nconfig ARCH_ENABLE_MEMORY_HOTREMOVE\n\tbool\n\n# eventually, we can have this option just 'select SPARSEMEM'\nmenuconfig MEMORY_HOTPLUG\n\tbool \"Memory hotplug\"\n\tselect MEMORY_ISOLATION\n\tdepends on SPARSEMEM\n\tdepends on ARCH_ENABLE_MEMORY_HOTPLUG\n\tdepends on 64BIT\n\tselect NUMA_KEEP_MEMINFO if NUMA\n\nif MEMORY_HOTPLUG\n\nconfig MEMORY_HOTPLUG_DEFAULT_ONLINE\n\tbool \"Online the newly added memory blocks by default\"\n\tdepends on MEMORY_HOTPLUG\n\thelp\n\t  This option sets the default policy setting for memory hotplug\n\t  onlining policy (/sys/devices/system/memory/auto_online_blocks) which\n\t  determines what happens to newly added memory regions. Policy setting\n\t  can always be changed at runtime.\n\t  See Documentation/admin-guide/mm/memory-hotplug.rst for more information.\n\n\t  Say Y here if you want all hot-plugged memory blocks to appear in\n\t  'online' state by default.\n\t  Say N here if you want the default policy to keep all hot-plugged\n\t  memory blocks in 'offline' state.\n\nconfig MEMORY_HOTREMOVE\n\tbool \"Allow for memory hot remove\"\n\tselect HAVE_BOOTMEM_INFO_NODE if (X86_64 || PPC64)\n\tdepends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE\n\tdepends on MIGRATION\n\nconfig MHP_MEMMAP_ON_MEMORY\n\tdef_bool y\n\tdepends on MEMORY_HOTPLUG && SPARSEMEM_VMEMMAP\n\tdepends on ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE\n\nendif # MEMORY_HOTPLUG\n\nconfig ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE\n       bool\n\n# Heavily threaded applications may benefit from splitting the mm-wide\n# page_table_lock, so that faults on different parts of the user address\n# space can be handled with less contention: split it at this NR_CPUS.\n# Default to 4 for wider testing, though 8 might be more appropriate.\n# ARM's adjust_pte (unused if VIPT) depends on mm-wide page_table_lock.\n# PA-RISC 7xxx's spinlock_t would enlarge struct page from 32 to 44 bytes.\n# SPARC32 allocates multiple pte tables within a single page, and therefore\n# a per-page lock leads to problems when multiple tables need to be locked\n# at the same time (e.g. copy_page_range()).\n# DEBUG_SPINLOCK and DEBUG_LOCK_ALLOC spinlock_t also enlarge struct page.\n#\nconfig SPLIT_PTLOCK_CPUS\n\tint\n\tdefault \"999999\" if !MMU\n\tdefault \"999999\" if ARM && !CPU_CACHE_VIPT\n\tdefault \"999999\" if PARISC && !PA20\n\tdefault \"999999\" if SPARC32\n\tdefault \"4\"\n\nconfig ARCH_ENABLE_SPLIT_PMD_PTLOCK\n\tbool\n\n#\n# support for memory balloon\nconfig MEMORY_BALLOON\n\tbool\n\n#\n# support for memory balloon compaction\nconfig BALLOON_COMPACTION\n\tbool \"Allow for balloon memory compaction/migration\"\n\tdef_bool y\n\tdepends on COMPACTION && MEMORY_BALLOON\n\thelp\n\t  Memory fragmentation introduced by ballooning might reduce\n\t  significantly the number of 2MB contiguous memory blocks that can be\n\t  used within a guest, thus imposing performance penalties associated\n\t  with the reduced number of transparent huge pages that could be used\n\t  by the guest workload. Allowing the compaction & migration for memory\n\t  pages enlisted as being part of memory balloon devices avoids the\n\t  scenario aforementioned and helps improving memory defragmentation.\n\n#\n# support for memory compaction\nconfig COMPACTION\n\tbool \"Allow for memory compaction\"\n\tdef_bool y\n\tselect MIGRATION\n\tdepends on MMU\n\thelp\n\t  Compaction is the only memory management component to form\n\t  high order (larger physically contiguous) memory blocks\n\t  reliably. The page allocator relies on compaction heavily and\n\t  the lack of the feature can lead to unexpected OOM killer\n\t  invocations for high order memory requests. You shouldn't\n\t  disable this option unless there really is a strong reason for\n\t  it and then we would be really interested to hear about that at\n\t  linux-mm@kvack.org.\n\nconfig COMPACT_UNEVICTABLE_DEFAULT\n\tint\n\tdepends on COMPACTION\n\tdefault 0 if PREEMPT_RT\n\tdefault 1\n\n#\n# support for free page reporting\nconfig PAGE_REPORTING\n\tbool \"Free page reporting\"\n\tdef_bool n\n\thelp\n\t  Free page reporting allows for the incremental acquisition of\n\t  free pages from the buddy allocator for the purpose of reporting\n\t  those pages to another entity, such as a hypervisor, so that the\n\t  memory can be freed within the host for other uses.\n\n#\n# support for page migration\n#\nconfig MIGRATION\n\tbool \"Page migration\"\n\tdef_bool y\n\tdepends on (NUMA || ARCH_ENABLE_MEMORY_HOTREMOVE || COMPACTION || CMA) && MMU\n\thelp\n\t  Allows the migration of the physical location of pages of processes\n\t  while the virtual addresses are not changed. This is useful in\n\t  two situations. The first is on NUMA systems to put pages nearer\n\t  to the processors accessing. The second is when allocating huge\n\t  pages as migration can relocate pages to satisfy a huge page\n\t  allocation instead of reclaiming.\n\nconfig DEVICE_MIGRATION\n\tdef_bool MIGRATION && ZONE_DEVICE\n\nconfig ARCH_ENABLE_HUGEPAGE_MIGRATION\n\tbool\n\nconfig ARCH_ENABLE_THP_MIGRATION\n\tbool\n\nconfig HUGETLB_PAGE_SIZE_VARIABLE\n\tdef_bool n\n\thelp\n\t  Allows the pageblock_order value to be dynamic instead of just standard\n\t  HUGETLB_PAGE_ORDER when there are multiple HugeTLB page sizes available\n\t  on a platform.\n\n\t  Note that the pageblock_order cannot exceed MAX_ORDER and will be\n\t  clamped down to MAX_ORDER.\n\nconfig CONTIG_ALLOC\n\tdef_bool (MEMORY_ISOLATION && COMPACTION) || CMA\n\nconfig PHYS_ADDR_T_64BIT\n\tdef_bool 64BIT\n\nconfig BOUNCE\n\tbool \"Enable bounce buffers\"\n\tdefault y\n\tdepends on BLOCK && MMU && HIGHMEM\n\thelp\n\t  Enable bounce buffers for devices that cannot access the full range of\n\t  memory available to the CPU. Enabled by default when HIGHMEM is\n\t  selected, but you may say n to override this.\n\nconfig MMU_NOTIFIER\n\tbool\n\tselect INTERVAL_TREE\n\nconfig KSM\n\tbool \"Enable KSM for page merging\"\n\tdepends on MMU\n\tselect XXHASH\n\thelp\n\t  Enable Kernel Samepage Merging: KSM periodically scans those areas\n\t  of an application's address space that an app has advised may be\n\t  mergeable.  When it finds pages of identical content, it replaces\n\t  the many instances by a single page with that content, so\n\t  saving memory until one or another app needs to modify the content.\n\t  Recommended for use with KVM, or with other duplicative applications.\n\t  See Documentation/mm/ksm.rst for more information: KSM is inactive\n\t  until a program has madvised that an area is MADV_MERGEABLE, and\n\t  root has set /sys/kernel/mm/ksm/run to 1 (if CONFIG_SYSFS is set).\n\nconfig DEFAULT_MMAP_MIN_ADDR\n\tint \"Low address space to protect from user allocation\"\n\tdepends on MMU\n\tdefault 4096\n\thelp\n\t  This is the portion of low virtual memory which should be protected\n\t  from userspace allocation.  Keeping a user from writing to low pages\n\t  can help reduce the impact of kernel NULL pointer bugs.\n\n\t  For most ia64, ppc64 and x86 users with lots of address space\n\t  a value of 65536 is reasonable and should cause no problems.\n\t  On arm and other archs it should not be higher than 32768.\n\t  Programs which use vm86 functionality or have some need to map\n\t  this low address space will need CAP_SYS_RAWIO or disable this\n\t  protection by setting the value to 0.\n\n\t  This value can be changed after boot using the\n\t  /proc/sys/vm/mmap_min_addr tunable.\n\nconfig ARCH_SUPPORTS_MEMORY_FAILURE\n\tbool\n\nconfig MEMORY_FAILURE\n\tdepends on MMU\n\tdepends on ARCH_SUPPORTS_MEMORY_FAILURE\n\tbool \"Enable recovery from hardware memory errors\"\n\tselect MEMORY_ISOLATION\n\tselect RAS\n\thelp\n\t  Enables code to recover from some memory failures on systems\n\t  with MCA recovery. This allows a system to continue running\n\t  even when some of its memory has uncorrected errors. This requires\n\t  special hardware support and typically ECC memory.\n\nconfig HWPOISON_INJECT\n\ttristate \"HWPoison pages injector\"\n\tdepends on MEMORY_FAILURE && DEBUG_KERNEL && PROC_FS\n\tselect PROC_PAGE_MONITOR\n\nconfig NOMMU_INITIAL_TRIM_EXCESS\n\tint \"Turn on mmap() excess space trimming before booting\"\n\tdepends on !MMU\n\tdefault 1\n\thelp\n\t  The NOMMU mmap() frequently needs to allocate large contiguous chunks\n\t  of memory on which to store mappings, but it can only ask the system\n\t  allocator for chunks in 2^N*PAGE_SIZE amounts - which is frequently\n\t  more than it requires.  To deal with this, mmap() is able to trim off\n\t  the excess and return it to the allocator.\n\n\t  If trimming is enabled, the excess is trimmed off and returned to the\n\t  system allocator, which can cause extra fragmentation, particularly\n\t  if there are a lot of transient processes.\n\n\t  If trimming is disabled, the excess is kept, but not used, which for\n\t  long-term mappings means that the space is wasted.\n\n\t  Trimming can be dynamically controlled through a sysctl option\n\t  (/proc/sys/vm/nr_trim_pages) which specifies the minimum number of\n\t  excess pages there must be before trimming should occur, or zero if\n\t  no trimming is to occur.\n\n\t  This option specifies the initial value of this option.  The default\n\t  of 1 says that all excess pages should be trimmed.\n\n\t  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.\n\nconfig ARCH_WANT_GENERAL_HUGETLB\n\tbool\n\nconfig ARCH_WANTS_THP_SWAP\n\tdef_bool n\n\nmenuconfig TRANSPARENT_HUGEPAGE\n\tbool \"Transparent Hugepage Support\"\n\tdepends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT\n\tselect COMPACTION\n\tselect XARRAY_MULTI\n\thelp\n\t  Transparent Hugepages allows the kernel to use huge pages and\n\t  huge tlb transparently to the applications whenever possible.\n\t  This feature can improve computing performance to certain\n\t  applications by speeding up page faults during memory\n\t  allocation, by reducing the number of tlb misses and by speeding\n\t  up the pagetable walking.\n\n\t  If memory constrained on embedded, you may want to say N.\n\nif TRANSPARENT_HUGEPAGE\n\nchoice\n\tprompt \"Transparent Hugepage Support sysfs defaults\"\n\tdepends on TRANSPARENT_HUGEPAGE\n\tdefault TRANSPARENT_HUGEPAGE_ALWAYS\n\thelp\n\t  Selects the sysfs defaults for Transparent Hugepage Support.\n\n\tconfig TRANSPARENT_HUGEPAGE_ALWAYS\n\t\tbool \"always\"\n\thelp\n\t  Enabling Transparent Hugepage always, can increase the\n\t  memory footprint of applications without a guaranteed\n\t  benefit but it will work automatically for all applications.\n\n\tconfig TRANSPARENT_HUGEPAGE_MADVISE\n\t\tbool \"madvise\"\n\thelp\n\t  Enabling Transparent Hugepage madvise, will only provide a\n\t  performance improvement benefit to the applications using\n\t  madvise(MADV_HUGEPAGE) but it won't risk to increase the\n\t  memory footprint of applications without a guaranteed\n\t  benefit.\nendchoice\n\nconfig THP_SWAP\n\tdef_bool y\n\tdepends on TRANSPARENT_HUGEPAGE && ARCH_WANTS_THP_SWAP && SWAP && 64BIT\n\thelp\n\t  Swap transparent huge pages in one piece, without splitting.\n\t  XXX: For now, swap cluster backing transparent huge page\n\t  will be split after swapout.\n\n\t  For selection by architectures with reasonable THP sizes.\n\nconfig READ_ONLY_THP_FOR_FS\n\tbool \"Read-only THP for filesystems (EXPERIMENTAL)\"\n\tdepends on TRANSPARENT_HUGEPAGE && SHMEM\n\n\thelp\n\t  Allow khugepaged to put read-only file-backed pages in THP.\n\n\t  This is marked experimental because it is a new feature. Write\n\t  support of file THPs will be developed in the next few release\n\t  cycles.\n\nendif # TRANSPARENT_HUGEPAGE\n\n#\n# UP and nommu archs use km based percpu allocator\n#\nconfig NEED_PER_CPU_KM\n\tdepends on !SMP || !MMU\n\tbool\n\tdefault y\n\nconfig NEED_PER_CPU_EMBED_FIRST_CHUNK\n\tbool\n\nconfig NEED_PER_CPU_PAGE_FIRST_CHUNK\n\tbool\n\nconfig USE_PERCPU_NUMA_NODE_ID\n\tbool\n\nconfig HAVE_SETUP_PER_CPU_AREA\n\tbool\n\nconfig CMA\n\tbool \"Contiguous Memory Allocator\"\n\tdepends on MMU\n\tselect MIGRATION\n\tselect MEMORY_ISOLATION\n\thelp\n\t  This enables the Contiguous Memory Allocator which allows other\n\t  subsystems to allocate big physically-contiguous blocks of memory.\n\t  CMA reserves a region of memory and allows only movable pages to\n\t  be allocated from it. This way, the kernel can use the memory for\n\t  pagecache and when a subsystem requests for contiguous area, the\n\t  allocated pages are migrated away to serve the contiguous request.\n\n\t  If unsure, say \"n\".\n\nconfig CMA_DEBUG\n\tbool \"CMA debug messages (DEVELOPMENT)\"\n\tdepends on DEBUG_KERNEL && CMA\n\thelp\n\t  Turns on debug messages in CMA.  This produces KERN_DEBUG\n\t  messages for every CMA call as well as various messages while\n\t  processing calls such as dma_alloc_from_contiguous().\n\t  This option does not affect warning and error messages.\n\nconfig CMA_DEBUGFS\n\tbool \"CMA debugfs interface\"\n\tdepends on CMA && DEBUG_FS\n\thelp\n\t  Turns on the DebugFS interface for CMA.\n\nconfig CMA_SYSFS\n\tbool \"CMA information through sysfs interface\"\n\tdepends on CMA && SYSFS\n\thelp\n\t  This option exposes some sysfs attributes to get information\n\t  from CMA.\n\nconfig CMA_AREAS\n\tint \"Maximum count of the CMA areas\"\n\tdepends on CMA\n\tdefault 19 if NUMA\n\tdefault 7\n\thelp\n\t  CMA allows to create CMA areas for particular purpose, mainly,\n\t  used as device private area. This parameter sets the maximum\n\t  number of CMA area in the system.\n\n\t  If unsure, leave the default value \"7\" in UMA and \"19\" in NUMA.\n\nconfig MEM_SOFT_DIRTY\n\tbool \"Track memory changes\"\n\tdepends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS\n\tselect PROC_PAGE_MONITOR\n\thelp\n\t  This option enables memory changes tracking by introducing a\n\t  soft-dirty bit on pte-s. This bit it set when someone writes\n\t  into a page just as regular dirty bit, but unlike the latter\n\t  it can be cleared by hands.\n\n\t  See Documentation/admin-guide/mm/soft-dirty.rst for more details.\n\nconfig GENERIC_EARLY_IOREMAP\n\tbool\n\nconfig STACK_MAX_DEFAULT_SIZE_MB\n\tint \"Default maximum user stack size for 32-bit processes (MB)\"\n\tdefault 100\n\trange 8 2048\n\tdepends on STACK_GROWSUP && (!64BIT || COMPAT)\n\thelp\n\t  This is the maximum stack size in Megabytes in the VM layout of 32-bit\n\t  user processes when the stack grows upwards (currently only on parisc\n\t  arch) when the RLIMIT_STACK hard limit is unlimited.\n\n\t  A sane initial value is 100 MB.\n\nconfig DEFERRED_STRUCT_PAGE_INIT\n\tbool \"Defer initialisation of struct pages to kthreads\"\n\tdepends on SPARSEMEM\n\tdepends on !NEED_PER_CPU_KM\n\tdepends on 64BIT\n\tselect PADATA\n\thelp\n\t  Ordinarily all struct pages are initialised during early boot in a\n\t  single thread. On very large machines this can take a considerable\n\t  amount of time. If this option is set, large machines will bring up\n\t  a subset of memmap at boot and then initialise the rest in parallel.\n\t  This has a potential performance impact on tasks running early in the\n\t  lifetime of the system until these kthreads finish the\n\t  initialisation.\n\nconfig PAGE_IDLE_FLAG\n\tbool\n\tselect PAGE_EXTENSION if !64BIT\n\thelp\n\t  This adds PG_idle and PG_young flags to 'struct page'.  PTE Accessed\n\t  bit writers can set the state of the bit in the flags so that PTE\n\t  Accessed bit readers may avoid disturbance.\n\nconfig IDLE_PAGE_TRACKING\n\tbool \"Enable idle page tracking\"\n\tdepends on SYSFS && MMU\n\tselect PAGE_IDLE_FLAG\n\thelp\n\t  This feature allows to estimate the amount of user pages that have\n\t  not been touched during a given period of time. This information can\n\t  be useful to tune memory cgroup limits and/or for job placement\n\t  within a compute cluster.\n\n\t  See Documentation/admin-guide/mm/idle_page_tracking.rst for\n\t  more details.\n\nconfig ARCH_HAS_CACHE_LINE_SIZE\n\tbool\n\nconfig ARCH_HAS_CURRENT_STACK_POINTER\n\tbool\n\thelp\n\t  In support of HARDENED_USERCOPY performing stack variable lifetime\n\t  checking, an architecture-agnostic way to find the stack pointer\n\t  is needed. Once an architecture defines an unsigned long global\n\t  register alias named \"current_stack_pointer\", this config can be\n\t  selected.\n\nconfig ARCH_HAS_PTE_DEVMAP\n\tbool\n\nconfig ARCH_HAS_ZONE_DMA_SET\n\tbool\n\nconfig ZONE_DMA\n\tbool \"Support DMA zone\" if ARCH_HAS_ZONE_DMA_SET\n\tdefault y if ARM64 || X86\n\nconfig ZONE_DMA32\n\tbool \"Support DMA32 zone\" if ARCH_HAS_ZONE_DMA_SET\n\tdepends on !X86_32\n\tdefault y if ARM64\n\nconfig ZONE_DEVICE\n\tbool \"Device memory (pmem, HMM, etc...) hotplug support\"\n\tdepends on MEMORY_HOTPLUG\n\tdepends on MEMORY_HOTREMOVE\n\tdepends on SPARSEMEM_VMEMMAP\n\tdepends on ARCH_HAS_PTE_DEVMAP\n\tselect XARRAY_MULTI\n\n\thelp\n\t  Device memory hotplug support allows for establishing pmem,\n\t  or other device driver discovered memory regions, in the\n\t  memmap. This allows pfn_to_page() lookups of otherwise\n\t  \"device-physical\" addresses which is needed for using a DAX\n\t  mapping in an O_DIRECT operation, among other things.\n\n\t  If FS_DAX is enabled, then say Y.\n\n#\n# Helpers to mirror range of the CPU page tables of a process into device page\n# tables.\n#\nconfig HMM_MIRROR\n\tbool\n\tdepends on MMU\n\nconfig GET_FREE_REGION\n\tdepends on SPARSEMEM\n\tbool\n\nconfig DEVICE_PRIVATE\n\tbool \"Unaddressable device memory (GPU memory, ...)\"\n\tdepends on ZONE_DEVICE\n\tselect GET_FREE_REGION\n\n\thelp\n\t  Allows creation of struct pages to represent unaddressable device\n\t  memory; i.e., memory that is only accessible from the device (or\n\t  group of devices). You likely also want to select HMM_MIRROR.\n\nconfig VMAP_PFN\n\tbool\n\nconfig ARCH_USES_HIGH_VMA_FLAGS\n\tbool\nconfig ARCH_HAS_PKEYS\n\tbool\n\nconfig ARCH_USES_PG_ARCH_X\n\tbool\n\thelp\n\t  Enable the definition of PG_arch_x page flags with x > 1. Only\n\t  suitable for 64-bit architectures with CONFIG_FLATMEM or\n\t  CONFIG_SPARSEMEM_VMEMMAP enabled, otherwise there may not be\n\t  enough room for additional bits in page->flags.\n\nconfig VM_EVENT_COUNTERS\n\tdefault y\n\tbool \"Enable VM event counters for /proc/vmstat\" if EXPERT\n\thelp\n\t  VM event counters are needed for event counts to be shown.\n\t  This option allows the disabling of the VM event counters\n\t  on EXPERT systems.  /proc/vmstat will only show page counts\n\t  if VM event counters are disabled.\n\nconfig PERCPU_STATS\n\tbool \"Collect percpu memory statistics\"\n\thelp\n\t  This feature collects and exposes statistics via debugfs. The\n\t  information includes global and per chunk statistics, which can\n\t  be used to help understand percpu memory usage.\n\nconfig GUP_TEST\n\tbool \"Enable infrastructure for get_user_pages()-related unit tests\"\n\tdepends on DEBUG_FS\n\thelp\n\t  Provides /sys/kernel/debug/gup_test, which in turn provides a way\n\t  to make ioctl calls that can launch kernel-based unit tests for\n\t  the get_user_pages*() and pin_user_pages*() family of API calls.\n\n\t  These tests include benchmark testing of the _fast variants of\n\t  get_user_pages*() and pin_user_pages*(), as well as smoke tests of\n\t  the non-_fast variants.\n\n\t  There is also a sub-test that allows running dump_page() on any\n\t  of up to eight pages (selected by command line args) within the\n\t  range of user-space addresses. These pages are either pinned via\n\t  pin_user_pages*(), or pinned via get_user_pages*(), as specified\n\t  by other command line arguments.\n\n\t  See tools/testing/selftests/mm/gup_test.c\n\ncomment \"GUP_TEST needs to have DEBUG_FS enabled\"\n\tdepends on !GUP_TEST && !DEBUG_FS\n\nconfig GUP_GET_PXX_LOW_HIGH\n\tbool\n\nconfig DMAPOOL_TEST\n\ttristate \"Enable a module to run time tests on dma_pool\"\n\tdepends on HAS_DMA\n\thelp\n\t  Provides a test module that will allocate and free many blocks of\n\t  various sizes and report how long it takes. This is intended to\n\t  provide a consistent way to measure how changes to the\n\t  dma_pool_alloc/free routines affect performance.\n\nconfig ARCH_HAS_PTE_SPECIAL\n\tbool\n\n#\n# Some architectures require a special hugepage directory format that is\n# required to support multiple hugepage sizes. For example a4fe3ce76\n# \"powerpc/mm: Allow more flexible layouts for hugepage pagetables\"\n# introduced it on powerpc.  This allows for a more flexible hugepage\n# pagetable layouts.\n#\nconfig ARCH_HAS_HUGEPD\n\tbool\n\nconfig MAPPING_DIRTY_HELPERS\n        bool\n\nconfig KMAP_LOCAL\n\tbool\n\nconfig KMAP_LOCAL_NON_LINEAR_PTE_ARRAY\n\tbool\n\n# struct io_mapping based helper.  Selected by drivers that need them\nconfig IO_MAPPING\n\tbool\n\nconfig MEMFD_CREATE\n\tbool \"Enable memfd_create() system call\" if EXPERT\n\nconfig SECRETMEM\n\tdefault y\n\tbool \"Enable memfd_secret() system call\" if EXPERT\n\tdepends on ARCH_HAS_SET_DIRECT_MAP\n\thelp\n\t  Enable the memfd_secret() system call with the ability to create\n\t  memory areas visible only in the context of the owning process and\n\t  not mapped to other processes and other kernel page tables.\n\nconfig ANON_VMA_NAME\n\tbool \"Anonymous VMA name support\"\n\tdepends on PROC_FS && ADVISE_SYSCALLS && MMU\n\n\thelp\n\t  Allow naming anonymous virtual memory areas.\n\n\t  This feature allows assigning names to virtual memory areas. Assigned\n\t  names can be later retrieved from /proc/pid/maps and /proc/pid/smaps\n\t  and help identifying individual anonymous memory areas.\n\t  Assigning a name to anonymous virtual memory area might prevent that\n\t  area from being merged with adjacent virtual memory areas due to the\n\t  difference in their name.\n\nconfig USERFAULTFD\n\tbool \"Enable userfaultfd() system call\"\n\tdepends on MMU\n\thelp\n\t  Enable the userfaultfd() system call that allows to intercept and\n\t  handle page faults in userland.\n\nconfig HAVE_ARCH_USERFAULTFD_WP\n\tbool\n\thelp\n\t  Arch has userfaultfd write protection support\n\nconfig HAVE_ARCH_USERFAULTFD_MINOR\n\tbool\n\thelp\n\t  Arch has userfaultfd minor fault support\n\nconfig PTE_MARKER_UFFD_WP\n\tbool \"Userfaultfd write protection support for shmem/hugetlbfs\"\n\tdefault y\n\tdepends on HAVE_ARCH_USERFAULTFD_WP\n\n\thelp\n\t  Allows to create marker PTEs for userfaultfd write protection\n\t  purposes.  It is required to enable userfaultfd write protection on\n\t  file-backed memory types like shmem and hugetlbfs.\n\n# multi-gen LRU {\nconfig LRU_GEN\n\tbool \"Multi-Gen LRU\"\n\tdepends on MMU\n\t# make sure folio->flags has enough spare bits\n\tdepends on 64BIT || !SPARSEMEM || SPARSEMEM_VMEMMAP\n\thelp\n\t  A high performance LRU implementation to overcommit memory. See\n\t  Documentation/admin-guide/mm/multigen_lru.rst for details.\n\nconfig LRU_GEN_ENABLED\n\tbool \"Enable by default\"\n\tdepends on LRU_GEN\n\thelp\n\t  This option enables the multi-gen LRU by default.\n\nconfig LRU_GEN_STATS\n\tbool \"Full stats for debugging\"\n\tdepends on LRU_GEN\n\thelp\n\t  Do not enable this option unless you plan to look at historical stats\n\t  from evicted generations for debugging purpose.\n\n\t  This option has a per-memcg and per-node memory overhead.\n# }\n\nconfig ARCH_SUPPORTS_PER_VMA_LOCK\n       def_bool n\n\nconfig PER_VMA_LOCK\n\tdef_bool y\n\tdepends on ARCH_SUPPORTS_PER_VMA_LOCK && MMU && SMP\n\thelp\n\t  Allow per-vma locking during page fault handling.\n\n\t  This feature allows locking each virtual memory area separately when\n\t  handling page faults instead of taking mmap_lock.\n\nconfig LOCK_MM_AND_FIND_VMA\n\tbool\n\tdepends on !STACK_GROWSUP\n\nsource \"mm/damon/Kconfig\"\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}