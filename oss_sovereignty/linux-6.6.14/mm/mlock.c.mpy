{
  "module_name": "mlock.c",
  "hash_id": "7f7be4365e393877f1c61f33011b79e6622ebe584cfa2b6344691d3ba6aabc5e",
  "original_prompt": "Ingested from linux-6.6.14/mm/mlock.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/user.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/pagewalk.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/mmzone.h>\n#include <linux/hugetlb.h>\n#include <linux/memcontrol.h>\n#include <linux/mm_inline.h>\n#include <linux/secretmem.h>\n\n#include \"internal.h\"\n\nstruct mlock_fbatch {\n\tlocal_lock_t lock;\n\tstruct folio_batch fbatch;\n};\n\nstatic DEFINE_PER_CPU(struct mlock_fbatch, mlock_fbatch) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nbool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(can_do_mlock);\n\n \n\nstatic struct lruvec *__mlock_folio(struct folio *folio, struct lruvec *lruvec)\n{\n\t \n\tif (!folio_test_clear_lru(folio))\n\t\treturn lruvec;\n\n\tlruvec = folio_lruvec_relock_irq(folio, lruvec);\n\n\tif (unlikely(folio_evictable(folio))) {\n\t\t \n\t\tif (folio_test_unevictable(folio)) {\n\t\t\tlruvec_del_folio(lruvec, folio);\n\t\t\tfolio_clear_unevictable(folio);\n\t\t\tlruvec_add_folio(lruvec, folio);\n\n\t\t\t__count_vm_events(UNEVICTABLE_PGRESCUED,\n\t\t\t\t\t  folio_nr_pages(folio));\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (folio_test_unevictable(folio)) {\n\t\tif (folio_test_mlocked(folio))\n\t\t\tfolio->mlock_count++;\n\t\tgoto out;\n\t}\n\n\tlruvec_del_folio(lruvec, folio);\n\tfolio_clear_active(folio);\n\tfolio_set_unevictable(folio);\n\tfolio->mlock_count = !!folio_test_mlocked(folio);\n\tlruvec_add_folio(lruvec, folio);\n\t__count_vm_events(UNEVICTABLE_PGCULLED, folio_nr_pages(folio));\nout:\n\tfolio_set_lru(folio);\n\treturn lruvec;\n}\n\nstatic struct lruvec *__mlock_new_folio(struct folio *folio, struct lruvec *lruvec)\n{\n\tVM_BUG_ON_FOLIO(folio_test_lru(folio), folio);\n\n\tlruvec = folio_lruvec_relock_irq(folio, lruvec);\n\n\t \n\tif (unlikely(folio_evictable(folio)))\n\t\tgoto out;\n\n\tfolio_set_unevictable(folio);\n\tfolio->mlock_count = !!folio_test_mlocked(folio);\n\t__count_vm_events(UNEVICTABLE_PGCULLED, folio_nr_pages(folio));\nout:\n\tlruvec_add_folio(lruvec, folio);\n\tfolio_set_lru(folio);\n\treturn lruvec;\n}\n\nstatic struct lruvec *__munlock_folio(struct folio *folio, struct lruvec *lruvec)\n{\n\tint nr_pages = folio_nr_pages(folio);\n\tbool isolated = false;\n\n\tif (!folio_test_clear_lru(folio))\n\t\tgoto munlock;\n\n\tisolated = true;\n\tlruvec = folio_lruvec_relock_irq(folio, lruvec);\n\n\tif (folio_test_unevictable(folio)) {\n\t\t \n\t\tif (folio->mlock_count)\n\t\t\tfolio->mlock_count--;\n\t\tif (folio->mlock_count)\n\t\t\tgoto out;\n\t}\n\t \n\nmunlock:\n\tif (folio_test_clear_mlocked(folio)) {\n\t\t__zone_stat_mod_folio(folio, NR_MLOCK, -nr_pages);\n\t\tif (isolated || !folio_test_unevictable(folio))\n\t\t\t__count_vm_events(UNEVICTABLE_PGMUNLOCKED, nr_pages);\n\t\telse\n\t\t\t__count_vm_events(UNEVICTABLE_PGSTRANDED, nr_pages);\n\t}\n\n\t \n\tif (isolated && folio_test_unevictable(folio) && folio_evictable(folio)) {\n\t\tlruvec_del_folio(lruvec, folio);\n\t\tfolio_clear_unevictable(folio);\n\t\tlruvec_add_folio(lruvec, folio);\n\t\t__count_vm_events(UNEVICTABLE_PGRESCUED, nr_pages);\n\t}\nout:\n\tif (isolated)\n\t\tfolio_set_lru(folio);\n\treturn lruvec;\n}\n\n \n#define LRU_FOLIO 0x1\n#define NEW_FOLIO 0x2\nstatic inline struct folio *mlock_lru(struct folio *folio)\n{\n\treturn (struct folio *)((unsigned long)folio + LRU_FOLIO);\n}\n\nstatic inline struct folio *mlock_new(struct folio *folio)\n{\n\treturn (struct folio *)((unsigned long)folio + NEW_FOLIO);\n}\n\n \nstatic void mlock_folio_batch(struct folio_batch *fbatch)\n{\n\tstruct lruvec *lruvec = NULL;\n\tunsigned long mlock;\n\tstruct folio *folio;\n\tint i;\n\n\tfor (i = 0; i < folio_batch_count(fbatch); i++) {\n\t\tfolio = fbatch->folios[i];\n\t\tmlock = (unsigned long)folio & (LRU_FOLIO | NEW_FOLIO);\n\t\tfolio = (struct folio *)((unsigned long)folio - mlock);\n\t\tfbatch->folios[i] = folio;\n\n\t\tif (mlock & LRU_FOLIO)\n\t\t\tlruvec = __mlock_folio(folio, lruvec);\n\t\telse if (mlock & NEW_FOLIO)\n\t\t\tlruvec = __mlock_new_folio(folio, lruvec);\n\t\telse\n\t\t\tlruvec = __munlock_folio(folio, lruvec);\n\t}\n\n\tif (lruvec)\n\t\tunlock_page_lruvec_irq(lruvec);\n\tfolios_put(fbatch->folios, folio_batch_count(fbatch));\n\tfolio_batch_reinit(fbatch);\n}\n\nvoid mlock_drain_local(void)\n{\n\tstruct folio_batch *fbatch;\n\n\tlocal_lock(&mlock_fbatch.lock);\n\tfbatch = this_cpu_ptr(&mlock_fbatch.fbatch);\n\tif (folio_batch_count(fbatch))\n\t\tmlock_folio_batch(fbatch);\n\tlocal_unlock(&mlock_fbatch.lock);\n}\n\nvoid mlock_drain_remote(int cpu)\n{\n\tstruct folio_batch *fbatch;\n\n\tWARN_ON_ONCE(cpu_online(cpu));\n\tfbatch = &per_cpu(mlock_fbatch.fbatch, cpu);\n\tif (folio_batch_count(fbatch))\n\t\tmlock_folio_batch(fbatch);\n}\n\nbool need_mlock_drain(int cpu)\n{\n\treturn folio_batch_count(&per_cpu(mlock_fbatch.fbatch, cpu));\n}\n\n \nvoid mlock_folio(struct folio *folio)\n{\n\tstruct folio_batch *fbatch;\n\n\tlocal_lock(&mlock_fbatch.lock);\n\tfbatch = this_cpu_ptr(&mlock_fbatch.fbatch);\n\n\tif (!folio_test_set_mlocked(folio)) {\n\t\tint nr_pages = folio_nr_pages(folio);\n\n\t\tzone_stat_mod_folio(folio, NR_MLOCK, nr_pages);\n\t\t__count_vm_events(UNEVICTABLE_PGMLOCKED, nr_pages);\n\t}\n\n\tfolio_get(folio);\n\tif (!folio_batch_add(fbatch, mlock_lru(folio)) ||\n\t    folio_test_large(folio) || lru_cache_disabled())\n\t\tmlock_folio_batch(fbatch);\n\tlocal_unlock(&mlock_fbatch.lock);\n}\n\n \nvoid mlock_new_folio(struct folio *folio)\n{\n\tstruct folio_batch *fbatch;\n\tint nr_pages = folio_nr_pages(folio);\n\n\tlocal_lock(&mlock_fbatch.lock);\n\tfbatch = this_cpu_ptr(&mlock_fbatch.fbatch);\n\tfolio_set_mlocked(folio);\n\n\tzone_stat_mod_folio(folio, NR_MLOCK, nr_pages);\n\t__count_vm_events(UNEVICTABLE_PGMLOCKED, nr_pages);\n\n\tfolio_get(folio);\n\tif (!folio_batch_add(fbatch, mlock_new(folio)) ||\n\t    folio_test_large(folio) || lru_cache_disabled())\n\t\tmlock_folio_batch(fbatch);\n\tlocal_unlock(&mlock_fbatch.lock);\n}\n\n \nvoid munlock_folio(struct folio *folio)\n{\n\tstruct folio_batch *fbatch;\n\n\tlocal_lock(&mlock_fbatch.lock);\n\tfbatch = this_cpu_ptr(&mlock_fbatch.fbatch);\n\t \n\tfolio_get(folio);\n\tif (!folio_batch_add(fbatch, folio) ||\n\t    folio_test_large(folio) || lru_cache_disabled())\n\t\tmlock_folio_batch(fbatch);\n\tlocal_unlock(&mlock_fbatch.lock);\n}\n\nstatic int mlock_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t   unsigned long end, struct mm_walk *walk)\n\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *start_pte, *pte;\n\tpte_t ptent;\n\tstruct folio *folio;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tif (!pmd_present(*pmd))\n\t\t\tgoto out;\n\t\tif (is_huge_zero_pmd(*pmd))\n\t\t\tgoto out;\n\t\tfolio = page_folio(pmd_page(*pmd));\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_folio(folio);\n\t\telse\n\t\t\tmunlock_folio(folio);\n\t\tgoto out;\n\t}\n\n\tstart_pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (!start_pte) {\n\t\twalk->action = ACTION_AGAIN;\n\t\treturn 0;\n\t}\n\tfor (pte = start_pte; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = ptep_get(pte);\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tfolio = vm_normal_folio(vma, addr, ptent);\n\t\tif (!folio || folio_is_zone_device(folio))\n\t\t\tcontinue;\n\t\tif (folio_test_large(folio))\n\t\t\tcontinue;\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_folio(folio);\n\t\telse\n\t\t\tmunlock_folio(folio);\n\t}\n\tpte_unmap(start_pte);\nout:\n\tspin_unlock(ptl);\n\tcond_resched();\n\treturn 0;\n}\n\n \nstatic void mlock_vma_pages_range(struct vm_area_struct *vma,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstatic const struct mm_walk_ops mlock_walk_ops = {\n\t\t.pmd_entry = mlock_pte_range,\n\t\t.walk_lock = PGWALK_WRLOCK_VERIFY,\n\t};\n\n\t \n\tif (newflags & VM_LOCKED)\n\t\tnewflags |= VM_IO;\n\tvma_start_write(vma);\n\tvm_flags_reset_once(vma, newflags);\n\n\tlru_add_drain();\n\twalk_page_range(vma->vm_mm, start, end, &mlock_walk_ops, NULL);\n\tlru_add_drain();\n\n\tif (newflags & VM_IO) {\n\t\tnewflags &= ~VM_IO;\n\t\tvm_flags_reset_once(vma, newflags);\n\t}\n}\n\n \nstatic int mlock_fixup(struct vma_iterator *vmi, struct vm_area_struct *vma,\n\t       struct vm_area_struct **prev, unsigned long start,\n\t       unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tvm_flags_t oldflags = vma->vm_flags;\n\n\tif (newflags == oldflags || (oldflags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma) || vma_is_secretmem(vma))\n\t\t \n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(vmi, mm, *prev, start, end, newflags,\n\t\t\tvma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\tvma->vm_userfaultfd_ctx, anon_vma_name(vma));\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(vmi, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(vmi, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t \n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!(newflags & VM_LOCKED))\n\t\tnr_pages = -nr_pages;\n\telse if (oldflags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t \n\tif ((newflags & VM_LOCKED) && (oldflags & VM_LOCKED)) {\n\t\t \n\t\tvma_start_write(vma);\n\t\tvm_flags_reset(vma, newflags);\n\t} else {\n\t\tmlock_vma_pages_range(vma, start, end, newflags);\n\t}\nout:\n\t*prev = vma;\n\treturn ret;\n}\n\nstatic int apply_vma_lock_flags(unsigned long start, size_t len,\n\t\t\t\tvm_flags_t flags)\n{\n\tunsigned long nstart, end, tmp;\n\tstruct vm_area_struct *vma, *prev;\n\tVMA_ITERATOR(vmi, current->mm, start);\n\n\tVM_BUG_ON(offset_in_page(start));\n\tVM_BUG_ON(len != PAGE_ALIGN(len));\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tvma = vma_iter_load(&vmi);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\n\tprev = vma_prev(&vmi);\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tnstart = start;\n\ttmp = vma->vm_start;\n\tfor_each_vma_range(vmi, vma, end) {\n\t\tint error;\n\t\tvm_flags_t newflags;\n\n\t\tif (vma->vm_start != tmp)\n\t\t\treturn -ENOMEM;\n\n\t\tnewflags = vma->vm_flags & ~VM_LOCKED_MASK;\n\t\tnewflags |= flags;\n\t\t \n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mlock_fixup(&vmi, vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttmp = vma_iter_end(&vmi);\n\t\tnstart = tmp;\n\t}\n\n\tif (tmp < end)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic unsigned long count_mm_mlocked_page_nr(struct mm_struct *mm,\n\t\tunsigned long start, size_t len)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long count = 0;\n\tunsigned long end;\n\tVMA_ITERATOR(vmi, mm, start);\n\n\t \n\tif (unlikely(ULONG_MAX - len < start))\n\t\tend = ULONG_MAX;\n\telse\n\t\tend = start + len;\n\n\tfor_each_vma_range(vmi, vma, end) {\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\tcount -= (start - vma->vm_start);\n\t\t\tif (end < vma->vm_end) {\n\t\t\t\tcount += end - vma->vm_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += vma->vm_end - vma->vm_start;\n\t\t}\n\t}\n\n\treturn count >> PAGE_SHIFT;\n}\n\n \nstatic int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}\n\nstatic __must_check int do_mlock(unsigned long start, size_t len, vm_flags_t flags)\n{\n\tunsigned long locked;\n\tunsigned long lock_limit;\n\tint error = -ENOMEM;\n\n\tstart = untagged_addr(start);\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\tlocked = len >> PAGE_SHIFT;\n\n\tif (mmap_write_lock_killable(current->mm))\n\t\treturn -EINTR;\n\n\tlocked += current->mm->locked_vm;\n\tif ((locked > lock_limit) && (!capable(CAP_IPC_LOCK))) {\n\t\t \n\t\tlocked -= count_mm_mlocked_page_nr(current->mm,\n\t\t\t\tstart, len);\n\t}\n\n\t \n\tif ((locked <= lock_limit) || capable(CAP_IPC_LOCK))\n\t\terror = apply_vma_lock_flags(start, len, flags);\n\n\tmmap_write_unlock(current->mm);\n\tif (error)\n\t\treturn error;\n\n\terror = __mm_populate(start, len, 0);\n\tif (error)\n\t\treturn __mlock_posix_error_return(error);\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)\n{\n\treturn do_mlock(start, len, VM_LOCKED);\n}\n\nSYSCALL_DEFINE3(mlock2, unsigned long, start, size_t, len, int, flags)\n{\n\tvm_flags_t vm_flags = VM_LOCKED;\n\n\tif (flags & ~MLOCK_ONFAULT)\n\t\treturn -EINVAL;\n\n\tif (flags & MLOCK_ONFAULT)\n\t\tvm_flags |= VM_LOCKONFAULT;\n\n\treturn do_mlock(start, len, vm_flags);\n}\n\nSYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)\n{\n\tint ret;\n\n\tstart = untagged_addr(start);\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tif (mmap_write_lock_killable(current->mm))\n\t\treturn -EINTR;\n\tret = apply_vma_lock_flags(start, len, 0);\n\tmmap_write_unlock(current->mm);\n\n\treturn ret;\n}\n\n \nstatic int apply_mlockall_flags(int flags)\n{\n\tVMA_ITERATOR(vmi, current->mm, 0);\n\tstruct vm_area_struct *vma, *prev = NULL;\n\tvm_flags_t to_add = 0;\n\n\tcurrent->mm->def_flags &= ~VM_LOCKED_MASK;\n\tif (flags & MCL_FUTURE) {\n\t\tcurrent->mm->def_flags |= VM_LOCKED;\n\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tcurrent->mm->def_flags |= VM_LOCKONFAULT;\n\n\t\tif (!(flags & MCL_CURRENT))\n\t\t\tgoto out;\n\t}\n\n\tif (flags & MCL_CURRENT) {\n\t\tto_add |= VM_LOCKED;\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tto_add |= VM_LOCKONFAULT;\n\t}\n\n\tfor_each_vma(vmi, vma) {\n\t\tvm_flags_t newflags;\n\n\t\tnewflags = vma->vm_flags & ~VM_LOCKED_MASK;\n\t\tnewflags |= to_add;\n\n\t\t \n\t\tmlock_fixup(&vmi, vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\t    newflags);\n\t\tcond_resched();\n\t}\nout:\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(mlockall, int, flags)\n{\n\tunsigned long lock_limit;\n\tint ret;\n\n\tif (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)) ||\n\t    flags == MCL_ONFAULT)\n\t\treturn -EINVAL;\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\n\tif (mmap_write_lock_killable(current->mm))\n\t\treturn -EINTR;\n\n\tret = -ENOMEM;\n\tif (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||\n\t    capable(CAP_IPC_LOCK))\n\t\tret = apply_mlockall_flags(flags);\n\tmmap_write_unlock(current->mm);\n\tif (!ret && (flags & MCL_CURRENT))\n\t\tmm_populate(0, TASK_SIZE);\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE0(munlockall)\n{\n\tint ret;\n\n\tif (mmap_write_lock_killable(current->mm))\n\t\treturn -EINTR;\n\tret = apply_mlockall_flags(0);\n\tmmap_write_unlock(current->mm);\n\treturn ret;\n}\n\n \nstatic DEFINE_SPINLOCK(shmlock_user_lock);\n\nint user_shm_lock(size_t size, struct ucounts *ucounts)\n{\n\tunsigned long lock_limit, locked;\n\tlong memlock;\n\tint allowed = 0;\n\n\tlocked = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tif (lock_limit != RLIM_INFINITY)\n\t\tlock_limit >>= PAGE_SHIFT;\n\tspin_lock(&shmlock_user_lock);\n\tmemlock = inc_rlimit_ucounts(ucounts, UCOUNT_RLIMIT_MEMLOCK, locked);\n\n\tif ((memlock == LONG_MAX || memlock > lock_limit) && !capable(CAP_IPC_LOCK)) {\n\t\tdec_rlimit_ucounts(ucounts, UCOUNT_RLIMIT_MEMLOCK, locked);\n\t\tgoto out;\n\t}\n\tif (!get_ucounts(ucounts)) {\n\t\tdec_rlimit_ucounts(ucounts, UCOUNT_RLIMIT_MEMLOCK, locked);\n\t\tallowed = 0;\n\t\tgoto out;\n\t}\n\tallowed = 1;\nout:\n\tspin_unlock(&shmlock_user_lock);\n\treturn allowed;\n}\n\nvoid user_shm_unlock(size_t size, struct ucounts *ucounts)\n{\n\tspin_lock(&shmlock_user_lock);\n\tdec_rlimit_ucounts(ucounts, UCOUNT_RLIMIT_MEMLOCK, (size + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\tspin_unlock(&shmlock_user_lock);\n\tput_ucounts(ucounts);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}