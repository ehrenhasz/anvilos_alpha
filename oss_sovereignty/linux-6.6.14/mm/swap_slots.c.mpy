{
  "module_name": "swap_slots.c",
  "hash_id": "04ec3066b88c9a257e4485ddf9f3b33de24bf2fa1e65a0335aaea292147e58e7",
  "original_prompt": "Ingested from linux-6.6.14/mm/swap_slots.c",
  "human_readable_source": "\n \n\n#include <linux/swap_slots.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\nstatic bool\tswap_slot_cache_active;\nbool\tswap_slot_cache_enabled;\nstatic bool\tswap_slot_cache_initialized;\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\n \nstatic DEFINE_MUTEX(swap_slots_cache_enable_mutex);\n\nstatic void __drain_swap_slots_cache(unsigned int type);\n\n#define use_swap_slot_cache (swap_slot_cache_active && swap_slot_cache_enabled)\n#define SLOTS_CACHE 0x1\n#define SLOTS_CACHE_RET 0x2\n\nstatic void deactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = false;\n\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\tmutex_unlock(&swap_slots_cache_mutex);\n}\n\nstatic void reactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = true;\n\tmutex_unlock(&swap_slots_cache_mutex);\n}\n\n \nvoid disable_swap_slots_cache_lock(void)\n{\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tswap_slot_cache_enabled = false;\n\tif (swap_slot_cache_initialized) {\n\t\t \n\t\tcpus_read_lock();\n\t\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\t\tcpus_read_unlock();\n\t}\n}\n\nstatic void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}\n\nvoid reenable_swap_slots_cache_unlock(void)\n{\n\t__reenable_swap_slots_cache();\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n}\n\nstatic bool check_cache_active(void)\n{\n\tlong pages;\n\n\tif (!swap_slot_cache_enabled)\n\t\treturn false;\n\n\tpages = get_nr_swap_pages();\n\tif (!swap_slot_cache_active) {\n\t\tif (pages > num_online_cpus() *\n\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)\n\t\t\treactivate_swap_slots_cache();\n\t\tgoto out;\n\t}\n\n\t \n\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)\n\t\tdeactivate_swap_slots_cache();\nout:\n\treturn swap_slot_cache_active;\n}\n\nstatic int alloc_swap_slot_cache(unsigned int cpu)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots, *slots_ret;\n\n\t \n\tslots = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t GFP_KERNEL);\n\tif (!slots)\n\t\treturn -ENOMEM;\n\n\tslots_ret = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t     GFP_KERNEL);\n\tif (!slots_ret) {\n\t\tkvfree(slots);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&swap_slots_cache_mutex);\n\tcache = &per_cpu(swp_slots, cpu);\n\tif (cache->slots || cache->slots_ret) {\n\t\t \n\t\tmutex_unlock(&swap_slots_cache_mutex);\n\n\t\tkvfree(slots);\n\t\tkvfree(slots_ret);\n\n\t\treturn 0;\n\t}\n\n\tif (!cache->lock_initialized) {\n\t\tmutex_init(&cache->alloc_lock);\n\t\tspin_lock_init(&cache->free_lock);\n\t\tcache->lock_initialized = true;\n\t}\n\tcache->nr = 0;\n\tcache->cur = 0;\n\tcache->n_ret = 0;\n\t \n\tmb();\n\tcache->slots = slots;\n\tcache->slots_ret = slots_ret;\n\tmutex_unlock(&swap_slots_cache_mutex);\n\treturn 0;\n}\n\nstatic void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,\n\t\t\t\t  bool free_slots)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots = NULL;\n\n\tcache = &per_cpu(swp_slots, cpu);\n\tif ((type & SLOTS_CACHE) && cache->slots) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);\n\t\tcache->cur = 0;\n\t\tcache->nr = 0;\n\t\tif (free_slots && cache->slots) {\n\t\t\tkvfree(cache->slots);\n\t\t\tcache->slots = NULL;\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t}\n\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\tcache->n_ret = 0;\n\t\tif (free_slots && cache->slots_ret) {\n\t\t\tslots = cache->slots_ret;\n\t\t\tcache->slots_ret = NULL;\n\t\t}\n\t\tspin_unlock_irq(&cache->free_lock);\n\t\tkvfree(slots);\n\t}\n}\n\nstatic void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t \n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}\n\nstatic int free_slot_cache(unsigned int cpu)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tdrain_slots_cache_cpu(cpu, SLOTS_CACHE | SLOTS_CACHE_RET, true);\n\tmutex_unlock(&swap_slots_cache_mutex);\n\treturn 0;\n}\n\nvoid enable_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tif (!swap_slot_cache_initialized) {\n\t\tint ret;\n\n\t\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"swap_slots_cache\",\n\t\t\t\t\talloc_swap_slot_cache, free_slot_cache);\n\t\tif (WARN_ONCE(ret < 0, \"Cache allocation failed (%s), operating \"\n\t\t\t\t       \"without swap slots cache.\\n\", __func__))\n\t\t\tgoto out_unlock;\n\n\t\tswap_slot_cache_initialized = true;\n\t}\n\n\t__reenable_swap_slots_cache();\nout_unlock:\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n}\n\n \nstatic int refill_swap_slots_cache(struct swap_slots_cache *cache)\n{\n\tif (!use_swap_slot_cache)\n\t\treturn 0;\n\n\tcache->cur = 0;\n\tif (swap_slot_cache_active)\n\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,\n\t\t\t\t\t   cache->slots, 1);\n\n\treturn cache->nr;\n}\n\nvoid free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t \n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t \n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n}\n\nswp_entry_t folio_alloc_swap(struct folio *folio)\n{\n\tswp_entry_t entry;\n\tstruct swap_slots_cache *cache;\n\n\tentry.val = 0;\n\n\tif (folio_test_large(folio)) {\n\t\tif (IS_ENABLED(CONFIG_THP_SWAP) && arch_thp_swp_supported())\n\t\t\tget_swap_pages(1, &entry, folio_nr_pages(folio));\n\t\tgoto out;\n\t}\n\n\t \n\tcache = raw_cpu_ptr(&swp_slots);\n\n\tif (likely(check_cache_active() && cache->slots)) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tif (cache->slots) {\nrepeat:\n\t\t\tif (cache->nr) {\n\t\t\t\tentry = cache->slots[cache->cur];\n\t\t\t\tcache->slots[cache->cur++].val = 0;\n\t\t\t\tcache->nr--;\n\t\t\t} else if (refill_swap_slots_cache(cache)) {\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t\tif (entry.val)\n\t\t\tgoto out;\n\t}\n\n\tget_swap_pages(1, &entry, 1);\nout:\n\tif (mem_cgroup_try_charge_swap(folio, entry)) {\n\t\tput_swap_folio(folio, entry);\n\t\tentry.val = 0;\n\t}\n\treturn entry;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}