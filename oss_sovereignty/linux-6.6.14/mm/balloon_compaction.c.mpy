{
  "module_name": "balloon_compaction.c",
  "hash_id": "ec16014cdd619603cc3ce4636ef0762f8d40dcc0f0a02626190ff24068dcbfe3",
  "original_prompt": "Ingested from linux-6.6.14/mm/balloon_compaction.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/balloon_compaction.h>\n\nstatic void balloon_page_enqueue_one(struct balloon_dev_info *b_dev_info,\n\t\t\t\t     struct page *page)\n{\n\t \n\tBUG_ON(!trylock_page(page));\n\tballoon_page_insert(b_dev_info, page);\n\tunlock_page(page);\n\t__count_vm_event(BALLOON_INFLATE);\n}\n\n \nsize_t balloon_page_list_enqueue(struct balloon_dev_info *b_dev_info,\n\t\t\t\t struct list_head *pages)\n{\n\tstruct page *page, *tmp;\n\tunsigned long flags;\n\tsize_t n_pages = 0;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_for_each_entry_safe(page, tmp, pages, lru) {\n\t\tlist_del(&page->lru);\n\t\tballoon_page_enqueue_one(b_dev_info, page);\n\t\tn_pages++;\n\t}\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\treturn n_pages;\n}\nEXPORT_SYMBOL_GPL(balloon_page_list_enqueue);\n\n \nsize_t balloon_page_list_dequeue(struct balloon_dev_info *b_dev_info,\n\t\t\t\t struct list_head *pages, size_t n_req_pages)\n{\n\tstruct page *page, *tmp;\n\tunsigned long flags;\n\tsize_t n_pages = 0;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\n\t\tif (n_pages == n_req_pages)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!trylock_page(page))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_BALLOON_COMPACTION) &&\n\t\t    PageIsolated(page)) {\n\t\t\t \n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\t\tballoon_page_delete(page);\n\t\t__count_vm_event(BALLOON_DEFLATE);\n\t\tlist_add(&page->lru, pages);\n\t\tunlock_page(page);\n\t\tn_pages++;\n\t}\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\treturn n_pages;\n}\nEXPORT_SYMBOL_GPL(balloon_page_list_dequeue);\n\n \nstruct page *balloon_page_alloc(void)\n{\n\tstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\n\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY |\n\t\t\t\t       __GFP_NOWARN);\n\treturn page;\n}\nEXPORT_SYMBOL_GPL(balloon_page_alloc);\n\n \nvoid balloon_page_enqueue(struct balloon_dev_info *b_dev_info,\n\t\t\t  struct page *page)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tballoon_page_enqueue_one(b_dev_info, page);\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n}\nEXPORT_SYMBOL_GPL(balloon_page_enqueue);\n\n \nstruct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\n{\n\tunsigned long flags;\n\tLIST_HEAD(pages);\n\tint n_pages;\n\n\tn_pages = balloon_page_list_dequeue(b_dev_info, &pages, 1);\n\n\tif (n_pages != 1) {\n\t\t \n\t\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\t\tif (unlikely(list_empty(&b_dev_info->pages) &&\n\t\t\t     !b_dev_info->isolated_pages))\n\t\t\tBUG();\n\t\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\t\treturn NULL;\n\t}\n\treturn list_first_entry(&pages, struct page, lru);\n}\nEXPORT_SYMBOL_GPL(balloon_page_dequeue);\n\n#ifdef CONFIG_BALLOON_COMPACTION\n\nstatic bool balloon_page_isolate(struct page *page, isolate_mode_t mode)\n\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_del(&page->lru);\n\tb_dev_info->isolated_pages++;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\treturn true;\n}\n\nstatic void balloon_page_putback(struct page *page)\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_add(&page->lru, &b_dev_info->pages);\n\tb_dev_info->isolated_pages--;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n}\n\n \nstatic int balloon_page_migrate(struct page *newpage, struct page *page,\n\t\tenum migrate_mode mode)\n{\n\tstruct balloon_dev_info *balloon = balloon_page_device(page);\n\n\t \n\tif (mode == MIGRATE_SYNC_NO_COPY)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\treturn balloon->migratepage(balloon, newpage, page, mode);\n}\n\nconst struct movable_operations balloon_mops = {\n\t.migrate_page = balloon_page_migrate,\n\t.isolate_page = balloon_page_isolate,\n\t.putback_page = balloon_page_putback,\n};\nEXPORT_SYMBOL_GPL(balloon_mops);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}