{
  "module_name": "cma_debug.c",
  "hash_id": "1ac9a14d7c46d76303d8eecb87094880cf6dbe199c56a2d8e5351e98ad7e6566",
  "original_prompt": "Ingested from linux-6.6.14/mm/cma_debug.c",
  "human_readable_source": "\n \n\n\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm_types.h>\n\n#include \"cma.h\"\n\nstruct cma_mem {\n\tstruct hlist_node node;\n\tstruct page *p;\n\tunsigned long n;\n};\n\nstatic int cma_debugfs_get(void *data, u64 *val)\n{\n\tunsigned long *p = data;\n\n\t*val = *p;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cma_debugfs_fops, cma_debugfs_get, NULL, \"%llu\\n\");\n\nstatic int cma_used_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long used;\n\n\tspin_lock_irq(&cma->lock);\n\t \n\tused = bitmap_weight(cma->bitmap, (int)cma_bitmap_maxno(cma));\n\tspin_unlock_irq(&cma->lock);\n\t*val = (u64)used << cma->order_per_bit;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cma_used_fops, cma_used_get, NULL, \"%llu\\n\");\n\nstatic int cma_maxchunk_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long maxchunk = 0;\n\tunsigned long start, end = 0;\n\tunsigned long bitmap_maxno = cma_bitmap_maxno(cma);\n\n\tspin_lock_irq(&cma->lock);\n\tfor (;;) {\n\t\tstart = find_next_zero_bit(cma->bitmap, bitmap_maxno, end);\n\t\tif (start >= bitmap_maxno)\n\t\t\tbreak;\n\t\tend = find_next_bit(cma->bitmap, bitmap_maxno, start);\n\t\tmaxchunk = max(end - start, maxchunk);\n\t}\n\tspin_unlock_irq(&cma->lock);\n\t*val = (u64)maxchunk << cma->order_per_bit;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cma_maxchunk_fops, cma_maxchunk_get, NULL, \"%llu\\n\");\n\nstatic void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}\n\nstatic struct cma_mem *cma_get_entry_from_list(struct cma *cma)\n{\n\tstruct cma_mem *mem = NULL;\n\n\tspin_lock(&cma->mem_head_lock);\n\tif (!hlist_empty(&cma->mem_head)) {\n\t\tmem = hlist_entry(cma->mem_head.first, struct cma_mem, node);\n\t\thlist_del_init(&mem->node);\n\t}\n\tspin_unlock(&cma->mem_head_lock);\n\n\treturn mem;\n}\n\nstatic int cma_free_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem = NULL;\n\n\twhile (count) {\n\t\tmem = cma_get_entry_from_list(cma);\n\t\tif (mem == NULL)\n\t\t\treturn 0;\n\n\t\tif (mem->n <= count) {\n\t\t\tcma_release(cma, mem->p, mem->n);\n\t\t\tcount -= mem->n;\n\t\t\tkfree(mem);\n\t\t} else if (cma->order_per_bit == 0) {\n\t\t\tcma_release(cma, mem->p, count);\n\t\t\tmem->p += count;\n\t\t\tmem->n -= count;\n\t\t\tcount = 0;\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t} else {\n\t\t\tpr_debug(\"cma: cannot release partial block when order_per_bit != 0\\n\");\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nstatic int cma_free_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_free_mem(cma, pages);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cma_free_fops, NULL, cma_free_write, \"%llu\\n\");\n\nstatic int cma_alloc_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem;\n\tstruct page *p;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tp = cma_alloc(cma, count, 0, false);\n\tif (!p) {\n\t\tkfree(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem->p = p;\n\tmem->n = count;\n\n\tcma_add_to_cma_mem_list(cma, mem);\n\n\treturn 0;\n}\n\nstatic int cma_alloc_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_alloc_mem(cma, pages);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cma_alloc_fops, NULL, cma_alloc_write, \"%llu\\n\");\n\nstatic void cma_debugfs_add_one(struct cma *cma, struct dentry *root_dentry)\n{\n\tstruct dentry *tmp;\n\n\ttmp = debugfs_create_dir(cma->name, root_dentry);\n\n\tdebugfs_create_file(\"alloc\", 0200, tmp, cma, &cma_alloc_fops);\n\tdebugfs_create_file(\"free\", 0200, tmp, cma, &cma_free_fops);\n\tdebugfs_create_file(\"base_pfn\", 0444, tmp,\n\t\t\t    &cma->base_pfn, &cma_debugfs_fops);\n\tdebugfs_create_file(\"count\", 0444, tmp, &cma->count, &cma_debugfs_fops);\n\tdebugfs_create_file(\"order_per_bit\", 0444, tmp,\n\t\t\t    &cma->order_per_bit, &cma_debugfs_fops);\n\tdebugfs_create_file(\"used\", 0444, tmp, cma, &cma_used_fops);\n\tdebugfs_create_file(\"maxchunk\", 0444, tmp, cma, &cma_maxchunk_fops);\n\n\tcma->dfs_bitmap.array = (u32 *)cma->bitmap;\n\tcma->dfs_bitmap.n_elements = DIV_ROUND_UP(cma_bitmap_maxno(cma),\n\t\t\t\t\t\t  BITS_PER_BYTE * sizeof(u32));\n\tdebugfs_create_u32_array(\"bitmap\", 0444, tmp, &cma->dfs_bitmap);\n}\n\nstatic int __init cma_debugfs_init(void)\n{\n\tstruct dentry *cma_debugfs_root;\n\tint i;\n\n\tcma_debugfs_root = debugfs_create_dir(\"cma\", NULL);\n\n\tfor (i = 0; i < cma_area_count; i++)\n\t\tcma_debugfs_add_one(&cma_areas[i], cma_debugfs_root);\n\n\treturn 0;\n}\nlate_initcall(cma_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}