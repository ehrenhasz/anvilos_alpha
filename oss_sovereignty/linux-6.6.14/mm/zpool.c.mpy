{
  "module_name": "zpool.c",
  "hash_id": "8f3c46001373dbfafcbb0354b3ace0c5f6be78393762ce60d9322a40de38a6d7",
  "original_prompt": "Ingested from linux-6.6.14/mm/zpool.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/zpool.h>\n\nstruct zpool {\n\tstruct zpool_driver *driver;\n\tvoid *pool;\n};\n\nstatic LIST_HEAD(drivers_head);\nstatic DEFINE_SPINLOCK(drivers_lock);\n\n \nvoid zpool_register_driver(struct zpool_driver *driver)\n{\n\tspin_lock(&drivers_lock);\n\tatomic_set(&driver->refcount, 0);\n\tlist_add(&driver->list, &drivers_head);\n\tspin_unlock(&drivers_lock);\n}\nEXPORT_SYMBOL(zpool_register_driver);\n\n \nint zpool_unregister_driver(struct zpool_driver *driver)\n{\n\tint ret = 0, refcount;\n\n\tspin_lock(&drivers_lock);\n\trefcount = atomic_read(&driver->refcount);\n\tWARN_ON(refcount < 0);\n\tif (refcount > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_del(&driver->list);\n\tspin_unlock(&drivers_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(zpool_unregister_driver);\n\n \nstatic struct zpool_driver *zpool_get_driver(const char *type)\n{\n\tstruct zpool_driver *driver;\n\n\tspin_lock(&drivers_lock);\n\tlist_for_each_entry(driver, &drivers_head, list) {\n\t\tif (!strcmp(driver->type, type)) {\n\t\t\tbool got = try_module_get(driver->owner);\n\n\t\t\tif (got)\n\t\t\t\tatomic_inc(&driver->refcount);\n\t\t\tspin_unlock(&drivers_lock);\n\t\t\treturn got ? driver : NULL;\n\t\t}\n\t}\n\n\tspin_unlock(&drivers_lock);\n\treturn NULL;\n}\n\nstatic void zpool_put_driver(struct zpool_driver *driver)\n{\n\tatomic_dec(&driver->refcount);\n\tmodule_put(driver->owner);\n}\n\n \nbool zpool_has_pool(char *type)\n{\n\tstruct zpool_driver *driver = zpool_get_driver(type);\n\n\tif (!driver) {\n\t\trequest_module(\"zpool-%s\", type);\n\t\tdriver = zpool_get_driver(type);\n\t}\n\n\tif (!driver)\n\t\treturn false;\n\n\tzpool_put_driver(driver);\n\treturn true;\n}\nEXPORT_SYMBOL(zpool_has_pool);\n\n \nstruct zpool *zpool_create_pool(const char *type, const char *name, gfp_t gfp)\n{\n\tstruct zpool_driver *driver;\n\tstruct zpool *zpool;\n\n\tpr_debug(\"creating pool type %s\\n\", type);\n\n\tdriver = zpool_get_driver(type);\n\n\tif (!driver) {\n\t\trequest_module(\"zpool-%s\", type);\n\t\tdriver = zpool_get_driver(type);\n\t}\n\n\tif (!driver) {\n\t\tpr_err(\"no driver for type %s\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tzpool = kmalloc(sizeof(*zpool), gfp);\n\tif (!zpool) {\n\t\tpr_err(\"couldn't create zpool - out of memory\\n\");\n\t\tzpool_put_driver(driver);\n\t\treturn NULL;\n\t}\n\n\tzpool->driver = driver;\n\tzpool->pool = driver->create(name, gfp);\n\n\tif (!zpool->pool) {\n\t\tpr_err(\"couldn't create %s pool\\n\", type);\n\t\tzpool_put_driver(driver);\n\t\tkfree(zpool);\n\t\treturn NULL;\n\t}\n\n\tpr_debug(\"created pool type %s\\n\", type);\n\n\treturn zpool;\n}\n\n \nvoid zpool_destroy_pool(struct zpool *zpool)\n{\n\tpr_debug(\"destroying pool type %s\\n\", zpool->driver->type);\n\n\tzpool->driver->destroy(zpool->pool);\n\tzpool_put_driver(zpool->driver);\n\tkfree(zpool);\n}\n\n \nconst char *zpool_get_type(struct zpool *zpool)\n{\n\treturn zpool->driver->type;\n}\n\n \nbool zpool_malloc_support_movable(struct zpool *zpool)\n{\n\treturn zpool->driver->malloc_support_movable;\n}\n\n \nint zpool_malloc(struct zpool *zpool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn zpool->driver->malloc(zpool->pool, size, gfp, handle);\n}\n\n \nvoid zpool_free(struct zpool *zpool, unsigned long handle)\n{\n\tzpool->driver->free(zpool->pool, handle);\n}\n\n \nvoid *zpool_map_handle(struct zpool *zpool, unsigned long handle,\n\t\t\tenum zpool_mapmode mapmode)\n{\n\treturn zpool->driver->map(zpool->pool, handle, mapmode);\n}\n\n \nvoid zpool_unmap_handle(struct zpool *zpool, unsigned long handle)\n{\n\tzpool->driver->unmap(zpool->pool, handle);\n}\n\n \nu64 zpool_get_total_size(struct zpool *zpool)\n{\n\treturn zpool->driver->total_size(zpool->pool);\n}\n\n \nbool zpool_can_sleep_mapped(struct zpool *zpool)\n{\n\treturn zpool->driver->sleep_mapped;\n}\n\nMODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");\nMODULE_DESCRIPTION(\"Common API for compressed memory storage\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}