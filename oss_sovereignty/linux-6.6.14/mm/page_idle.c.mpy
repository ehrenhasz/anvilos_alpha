{
  "module_name": "page_idle.c",
  "hash_id": "58fdcce2e401dcad10099446712236da225e5fe9deeebfd7139dee27ea39570a",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_idle.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/memory_hotplug.h>\n#include <linux/mm.h>\n#include <linux/mmzone.h>\n#include <linux/pagemap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/page_ext.h>\n#include <linux/page_idle.h>\n\n#include \"internal.h\"\n\n#define BITMAP_CHUNK_SIZE\tsizeof(u64)\n#define BITMAP_CHUNK_BITS\t(BITMAP_CHUNK_SIZE * BITS_PER_BYTE)\n\n \nstatic struct folio *page_idle_get_folio(unsigned long pfn)\n{\n\tstruct page *page = pfn_to_online_page(pfn);\n\tstruct folio *folio;\n\n\tif (!page || PageTail(page))\n\t\treturn NULL;\n\n\tfolio = page_folio(page);\n\tif (!folio_test_lru(folio) || !folio_try_get(folio))\n\t\treturn NULL;\n\tif (unlikely(page_folio(page) != folio || !folio_test_lru(folio))) {\n\t\tfolio_put(folio);\n\t\tfolio = NULL;\n\t}\n\treturn folio;\n}\n\nstatic bool page_idle_clear_pte_refs_one(struct folio *folio,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr, void *arg)\n{\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, addr, 0);\n\tbool referenced = false;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddr = pvmw.address;\n\t\tif (pvmw.pte) {\n\t\t\t \n\t\t\tif (ptep_clear_young_notify(vma, addr, pvmw.pte))\n\t\t\t\treferenced = true;\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_young_notify(vma, addr, pvmw.pmd))\n\t\t\t\treferenced = true;\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\tif (referenced) {\n\t\tfolio_clear_idle(folio);\n\t\t \n\t\tfolio_set_young(folio);\n\t}\n\treturn true;\n}\n\nstatic void page_idle_clear_pte_refs(struct folio *folio)\n{\n\t \n\tstatic struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!folio_mapped(folio) || !folio_raw_mapping(folio))\n\t\treturn;\n\n\tneed_lock = !folio_test_anon(folio) || folio_test_ksm(folio);\n\tif (need_lock && !folio_trylock(folio))\n\t\treturn;\n\n\trmap_walk(folio, &rwc);\n\n\tif (need_lock)\n\t\tfolio_unlock(folio);\n}\n\nstatic ssize_t page_idle_bitmap_read(struct file *file, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t pos, size_t count)\n{\n\tu64 *out = (u64 *)buf;\n\tstruct folio *folio;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn 0;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = max_pfn;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif (!bit)\n\t\t\t*out = 0ULL;\n\t\tfolio = page_idle_get_folio(pfn);\n\t\tif (folio) {\n\t\t\tif (folio_test_idle(folio)) {\n\t\t\t\t \n\t\t\t\tpage_idle_clear_pte_refs(folio);\n\t\t\t\tif (folio_test_idle(folio))\n\t\t\t\t\t*out |= 1ULL << bit;\n\t\t\t}\n\t\t\tfolio_put(folio);\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tout++;\n\t\tcond_resched();\n\t}\n\treturn (char *)out - buf;\n}\n\nstatic ssize_t page_idle_bitmap_write(struct file *file, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t pos, size_t count)\n{\n\tconst u64 *in = (u64 *)buf;\n\tstruct folio *folio;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn -ENXIO;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = max_pfn;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif ((*in >> bit) & 1) {\n\t\t\tfolio = page_idle_get_folio(pfn);\n\t\t\tif (folio) {\n\t\t\t\tpage_idle_clear_pte_refs(folio);\n\t\t\t\tfolio_set_idle(folio);\n\t\t\t\tfolio_put(folio);\n\t\t\t}\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tin++;\n\t\tcond_resched();\n\t}\n\treturn (char *)in - buf;\n}\n\nstatic struct bin_attribute page_idle_bitmap_attr =\n\t\t__BIN_ATTR(bitmap, 0600,\n\t\t\t   page_idle_bitmap_read, page_idle_bitmap_write, 0);\n\nstatic struct bin_attribute *page_idle_bin_attrs[] = {\n\t&page_idle_bitmap_attr,\n\tNULL,\n};\n\nstatic const struct attribute_group page_idle_attr_group = {\n\t.bin_attrs = page_idle_bin_attrs,\n\t.name = \"page_idle\",\n};\n\nstatic int __init page_idle_init(void)\n{\n\tint err;\n\n\terr = sysfs_create_group(mm_kobj, &page_idle_attr_group);\n\tif (err) {\n\t\tpr_err(\"page_idle: register sysfs failed\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\nsubsys_initcall(page_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}