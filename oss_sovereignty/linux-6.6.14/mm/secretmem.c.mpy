{
  "module_name": "secretmem.c",
  "hash_id": "bab0d52ce9c78e0833a4f90dc0ad1ba3a7a5ded86bda88f1ffbd9d47489e1be8",
  "original_prompt": "Ingested from linux-6.6.14/mm/secretmem.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/memfd.h>\n#include <linux/bitops.h>\n#include <linux/printk.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/pseudo_fs.h>\n#include <linux/secretmem.h>\n#include <linux/set_memory.h>\n#include <linux/sched/signal.h>\n\n#include <uapi/linux/magic.h>\n\n#include <asm/tlbflush.h>\n\n#include \"internal.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"secretmem: \" fmt\n\n \n#define SECRETMEM_MODE_MASK\t(0x0)\n#define SECRETMEM_FLAGS_MASK\tSECRETMEM_MODE_MASK\n\nstatic bool secretmem_enable __ro_after_init = 1;\nmodule_param_named(enable, secretmem_enable, bool, 0400);\nMODULE_PARM_DESC(secretmem_enable,\n\t\t \"Enable secretmem and memfd_secret(2) system call\");\n\nstatic atomic_t secretmem_users;\n\nbool secretmem_active(void)\n{\n\treturn !!atomic_read(&secretmem_users);\n}\n\nstatic vm_fault_t secretmem_fault(struct vm_fault *vmf)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tpgoff_t offset = vmf->pgoff;\n\tgfp_t gfp = vmf->gfp_mask;\n\tunsigned long addr;\n\tstruct page *page;\n\tstruct folio *folio;\n\tvm_fault_t ret;\n\tint err;\n\n\tif (((loff_t)vmf->pgoff << PAGE_SHIFT) >= i_size_read(inode))\n\t\treturn vmf_error(-EINVAL);\n\n\tfilemap_invalidate_lock_shared(mapping);\n\nretry:\n\tpage = find_lock_page(mapping, offset);\n\tif (!page) {\n\t\tfolio = folio_alloc(gfp | __GFP_ZERO, 0);\n\t\tif (!folio) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = &folio->page;\n\t\terr = set_direct_map_invalid_noflush(page);\n\t\tif (err) {\n\t\t\tfolio_put(folio);\n\t\t\tret = vmf_error(err);\n\t\t\tgoto out;\n\t\t}\n\n\t\t__folio_mark_uptodate(folio);\n\t\terr = filemap_add_folio(mapping, folio, offset, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tfolio_put(folio);\n\t\t\t \n\t\t\tset_direct_map_default_noflush(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto retry;\n\n\t\t\tret = vmf_error(err);\n\t\t\tgoto out;\n\t\t}\n\n\t\taddr = (unsigned long)page_address(page);\n\t\tflush_tlb_kernel_range(addr, addr + PAGE_SIZE);\n\t}\n\n\tvmf->page = page;\n\tret = VM_FAULT_LOCKED;\n\nout:\n\tfilemap_invalidate_unlock_shared(mapping);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct secretmem_vm_ops = {\n\t.fault = secretmem_fault,\n};\n\nstatic int secretmem_release(struct inode *inode, struct file *file)\n{\n\tatomic_dec(&secretmem_users);\n\treturn 0;\n}\n\nstatic int secretmem_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long len = vma->vm_end - vma->vm_start;\n\n\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)\n\t\treturn -EINVAL;\n\n\tif (!mlock_future_ok(vma->vm_mm, vma->vm_flags | VM_LOCKED, len))\n\t\treturn -EAGAIN;\n\n\tvm_flags_set(vma, VM_LOCKED | VM_DONTDUMP);\n\tvma->vm_ops = &secretmem_vm_ops;\n\n\treturn 0;\n}\n\nbool vma_is_secretmem(struct vm_area_struct *vma)\n{\n\treturn vma->vm_ops == &secretmem_vm_ops;\n}\n\nstatic const struct file_operations secretmem_fops = {\n\t.release\t= secretmem_release,\n\t.mmap\t\t= secretmem_mmap,\n};\n\nstatic int secretmem_migrate_folio(struct address_space *mapping,\n\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)\n{\n\treturn -EBUSY;\n}\n\nstatic void secretmem_free_folio(struct folio *folio)\n{\n\tset_direct_map_default_noflush(&folio->page);\n\tfolio_zero_segment(folio, 0, folio_size(folio));\n}\n\nconst struct address_space_operations secretmem_aops = {\n\t.dirty_folio\t= noop_dirty_folio,\n\t.free_folio\t= secretmem_free_folio,\n\t.migrate_folio\t= secretmem_migrate_folio,\n};\n\nstatic int secretmem_setattr(struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned int ia_valid = iattr->ia_valid;\n\tint ret;\n\n\tfilemap_invalidate_lock(mapping);\n\n\tif ((ia_valid & ATTR_SIZE) && inode->i_size)\n\t\tret = -EINVAL;\n\telse\n\t\tret = simple_setattr(idmap, dentry, iattr);\n\n\tfilemap_invalidate_unlock(mapping);\n\n\treturn ret;\n}\n\nstatic const struct inode_operations secretmem_iops = {\n\t.setattr = secretmem_setattr,\n};\n\nstatic struct vfsmount *secretmem_mnt;\n\nstatic struct file *secretmem_file_create(unsigned long flags)\n{\n\tstruct file *file;\n\tstruct inode *inode;\n\tconst char *anon_name = \"[secretmem]\";\n\tconst struct qstr qname = QSTR_INIT(anon_name, strlen(anon_name));\n\tint err;\n\n\tinode = alloc_anon_inode(secretmem_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\terr = security_inode_init_security_anon(inode, &qname, NULL);\n\tif (err) {\n\t\tfile = ERR_PTR(err);\n\t\tgoto err_free_inode;\n\t}\n\n\tfile = alloc_file_pseudo(inode, secretmem_mnt, \"secretmem\",\n\t\t\t\t O_RDWR, &secretmem_fops);\n\tif (IS_ERR(file))\n\t\tgoto err_free_inode;\n\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\tmapping_set_unevictable(inode->i_mapping);\n\n\tinode->i_op = &secretmem_iops;\n\tinode->i_mapping->a_ops = &secretmem_aops;\n\n\t \n\tinode->i_mode |= S_IFREG;\n\tinode->i_size = 0;\n\n\treturn file;\n\nerr_free_inode:\n\tiput(inode);\n\treturn file;\n}\n\nSYSCALL_DEFINE1(memfd_secret, unsigned int, flags)\n{\n\tstruct file *file;\n\tint fd, err;\n\n\t \n\tBUILD_BUG_ON(SECRETMEM_FLAGS_MASK & O_CLOEXEC);\n\n\tif (!secretmem_enable)\n\t\treturn -ENOSYS;\n\n\tif (flags & ~(SECRETMEM_FLAGS_MASK | O_CLOEXEC))\n\t\treturn -EINVAL;\n\tif (atomic_read(&secretmem_users) < 0)\n\t\treturn -ENFILE;\n\n\tfd = get_unused_fd_flags(flags & O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = secretmem_file_create(flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto err_put_fd;\n\t}\n\n\tfile->f_flags |= O_LARGEFILE;\n\n\tatomic_inc(&secretmem_users);\n\tfd_install(fd, file);\n\treturn fd;\n\nerr_put_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}\n\nstatic int secretmem_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, SECRETMEM_MAGIC) ? 0 : -ENOMEM;\n}\n\nstatic struct file_system_type secretmem_fs = {\n\t.name\t\t= \"secretmem\",\n\t.init_fs_context = secretmem_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init secretmem_init(void)\n{\n\tif (!secretmem_enable)\n\t\treturn 0;\n\n\tsecretmem_mnt = kern_mount(&secretmem_fs);\n\tif (IS_ERR(secretmem_mnt))\n\t\treturn PTR_ERR(secretmem_mnt);\n\n\t \n\tsecretmem_mnt->mnt_flags |= MNT_NOEXEC;\n\n\treturn 0;\n}\nfs_initcall(secretmem_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}