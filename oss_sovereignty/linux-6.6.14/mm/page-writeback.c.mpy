{
  "module_name": "page-writeback.c",
  "hash_id": "e1216b8fc710ddb9cd0fa1fd03779ef3baac77cb00f409219c574d0e0ea54a5b",
  "original_prompt": "Ingested from linux-6.6.14/mm/page-writeback.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/mpage.h>\n#include <linux/rmap.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/sysctl.h>\n#include <linux/cpu.h>\n#include <linux/syscalls.h>\n#include <linux/pagevec.h>\n#include <linux/timer.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <trace/events/writeback.h>\n\n#include \"internal.h\"\n\n \n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\n \n#define DIRTY_POLL_THRESH\t(128 >> (PAGE_SHIFT - 10))\n\n \n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\n#define RATELIMIT_CALC_SHIFT\t10\n\n \nstatic long ratelimit_pages = 32;\n\n \n\n \nstatic int dirty_background_ratio = 10;\n\n \nstatic unsigned long dirty_background_bytes;\n\n \nstatic int vm_highmem_is_dirtyable;\n\n \nstatic int vm_dirty_ratio = 20;\n\n \nstatic unsigned long vm_dirty_bytes;\n\n \nunsigned int dirty_writeback_interval = 5 * 100;  \n\nEXPORT_SYMBOL_GPL(dirty_writeback_interval);\n\n \nunsigned int dirty_expire_interval = 30 * 100;  \n\n \nint laptop_mode;\n\nEXPORT_SYMBOL(laptop_mode);\n\n \n\nstruct wb_domain global_wb_domain;\n\n \nstruct dirty_throttle_control {\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct wb_domain\t*dom;\n\tstruct dirty_throttle_control *gdtc;\t \n#endif\n\tstruct bdi_writeback\t*wb;\n\tstruct fprop_local_percpu *wb_completions;\n\n\tunsigned long\t\tavail;\t\t \n\tunsigned long\t\tdirty;\t\t \n\tunsigned long\t\tthresh;\t\t \n\tunsigned long\t\tbg_thresh;\t \n\n\tunsigned long\t\twb_dirty;\t \n\tunsigned long\t\twb_thresh;\n\tunsigned long\t\twb_bg_thresh;\n\n\tunsigned long\t\tpos_ratio;\n};\n\n \n#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\n#define GDTC_INIT(__wb)\t\t.wb = (__wb),\t\t\t\t\\\n\t\t\t\t.dom = &global_wb_domain,\t\t\\\n\t\t\t\t.wb_completions = &(__wb)->completions\n\n#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain\n\n#define MDTC_INIT(__wb, __gdtc)\t.wb = (__wb),\t\t\t\t\\\n\t\t\t\t.dom = mem_cgroup_wb_domain(__wb),\t\\\n\t\t\t\t.wb_completions = &(__wb)->memcg_completions, \\\n\t\t\t\t.gdtc = __gdtc\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn mdtc->gdtc;\n}\n\nstatic struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn &wb->memcg_completions;\n}\n\nstatic void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\tunsigned long this_bw = READ_ONCE(wb->avg_write_bandwidth);\n\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);\n\tunsigned long long min = wb->bdi->min_ratio;\n\tunsigned long long max = wb->bdi->max_ratio;\n\n\t \n\tif (this_bw < tot_bw) {\n\t\tif (min) {\n\t\t\tmin *= this_bw;\n\t\t\tmin = div64_ul(min, tot_bw);\n\t\t}\n\t\tif (max < 100 * BDI_RATIO_SCALE) {\n\t\t\tmax *= this_bw;\n\t\t\tmax = div64_ul(max, tot_bw);\n\t\t}\n\t}\n\n\t*minp = min;\n\t*maxp = max;\n}\n\n#else\t \n\n#define GDTC_INIT(__wb)\t\t.wb = (__wb),                           \\\n\t\t\t\t.wb_completions = &(__wb)->completions\n#define GDTC_INIT_NO_WB\n#define MDTC_INIT(__wb, __gdtc)\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}\n\nstatic struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn NULL;\n}\n\nstatic void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\t*minp = wb->bdi->min_ratio;\n\t*maxp = wb->bdi->max_ratio;\n}\n\n#endif\t \n\n \n\n \nstatic unsigned long node_dirtyable_memory(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pages = 0;\n\tint z;\n\n\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t \n\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);\n\n\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);\n\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);\n\n\treturn nr_pages;\n}\n\nstatic unsigned long highmem_dirtyable_memory(unsigned long total)\n{\n#ifdef CONFIG_HIGHMEM\n\tint node;\n\tunsigned long x = 0;\n\tint i;\n\n\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *z;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tif (!is_highmem_idx(i))\n\t\t\t\tcontinue;\n\n\t\t\tz = &NODE_DATA(node)->node_zones[i];\n\t\t\tif (!populated_zone(z))\n\t\t\t\tcontinue;\n\n\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);\n\t\t\t \n\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);\n\t\t\tx += nr_pages;\n\t\t}\n\t}\n\n\t \n\treturn min(x, total);\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t \n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t \n}\n\n \nstatic void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t \n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t \n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t \n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t \n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}\n\n \nvoid global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}\n\n \nstatic unsigned long node_dirty_limit(struct pglist_data *pgdat)\n{\n\tunsigned long node_memory = node_dirtyable_memory(pgdat);\n\tstruct task_struct *tsk = current;\n\tunsigned long dirty;\n\n\tif (vm_dirty_bytes)\n\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *\n\t\t\tnode_memory / global_dirtyable_memory();\n\telse\n\t\tdirty = vm_dirty_ratio * node_memory / 100;\n\n\tif (rt_task(tsk))\n\t\tdirty += dirty / 4;\n\n\treturn dirty;\n}\n\n \nbool node_dirty_ok(struct pglist_data *pgdat)\n{\n\tunsigned long limit = node_dirty_limit(pgdat);\n\tunsigned long nr_pages = 0;\n\n\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);\n\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);\n\n\treturn nr_pages <= limit;\n}\n\n#ifdef CONFIG_SYSCTL\nstatic int dirty_background_ratio_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_bytes = 0;\n\treturn ret;\n}\n\nstatic int dirty_background_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_ratio = 0;\n\treturn ret;\n}\n\nstatic int dirty_ratio_handler(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint old_ratio = vm_dirty_ratio;\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_bytes = 0;\n\t}\n\treturn ret;\n}\n\nstatic int dirty_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tunsigned long old_bytes = vm_dirty_bytes;\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_ratio = 0;\n\t}\n\treturn ret;\n}\n#endif\n\nstatic unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t \n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}\n\nstatic void wb_domain_writeout_add(struct wb_domain *dom,\n\t\t\t\t   struct fprop_local_percpu *completions,\n\t\t\t\t   unsigned int max_prop_frac, long nr)\n{\n\t__fprop_add_percpu_max(&dom->completions, completions,\n\t\t\t       max_prop_frac, nr);\n\t \n\tif (unlikely(!dom->period_time)) {\n\t\t \n\t\tdom->period_time = wp_next_time(jiffies);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t}\n}\n\n \nstatic inline void __wb_writeout_add(struct bdi_writeback *wb, long nr)\n{\n\tstruct wb_domain *cgdom;\n\n\twb_stat_mod(wb, WB_WRITTEN, nr);\n\twb_domain_writeout_add(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac, nr);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_add(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac, nr);\n}\n\nvoid wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__wb_writeout_add(wb, 1);\n\tlocal_irq_restore(flags);\n}\nEXPORT_SYMBOL_GPL(wb_writeout_inc);\n\n \nstatic void writeout_period(struct timer_list *t)\n{\n\tstruct wb_domain *dom = from_timer(dom, t, period_timer);\n\tint miss_periods = (jiffies - dom->period_time) /\n\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;\n\n\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {\n\t\tdom->period_time = wp_next_time(dom->period_time +\n\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t} else {\n\t\t \n\t\tdom->period_time = 0;\n\t}\n}\n\nint wb_domain_init(struct wb_domain *dom, gfp_t gfp)\n{\n\tmemset(dom, 0, sizeof(*dom));\n\n\tspin_lock_init(&dom->lock);\n\n\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);\n\n\tdom->dirty_limit_tstamp = jiffies;\n\n\treturn fprop_global_init(&dom->completions, gfp);\n}\n\n#ifdef CONFIG_CGROUP_WRITEBACK\nvoid wb_domain_exit(struct wb_domain *dom)\n{\n\tdel_timer_sync(&dom->period_timer);\n\tfprop_global_destroy(&dom->completions);\n}\n#endif\n\n \nstatic unsigned int bdi_min_ratio;\n\nstatic int bdi_check_pages_limit(unsigned long pages)\n{\n\tunsigned long max_dirty_pages = global_dirtyable_memory();\n\n\tif (pages > max_dirty_pages)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned long bdi_ratio_from_pages(unsigned long pages)\n{\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\tunsigned long ratio;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tratio = div64_u64(pages * 100ULL * BDI_RATIO_SCALE, dirty_thresh);\n\n\treturn ratio;\n}\n\nstatic u64 bdi_get_bytes(unsigned int ratio)\n{\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\tu64 bytes;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tbytes = (dirty_thresh * PAGE_SIZE * ratio) / BDI_RATIO_SCALE / 100;\n\n\treturn bytes;\n}\n\nstatic int __bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tunsigned int delta;\n\tint ret = 0;\n\n\tif (min_ratio > 100 * BDI_RATIO_SCALE)\n\t\treturn -EINVAL;\n\tmin_ratio *= BDI_RATIO_SCALE;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tif (min_ratio < bdi->min_ratio) {\n\t\t\tdelta = bdi->min_ratio - min_ratio;\n\t\t\tbdi_min_ratio -= delta;\n\t\t\tbdi->min_ratio = min_ratio;\n\t\t} else {\n\t\t\tdelta = min_ratio - bdi->min_ratio;\n\t\t\tif (bdi_min_ratio + delta < 100 * BDI_RATIO_SCALE) {\n\t\t\t\tbdi_min_ratio += delta;\n\t\t\t\tbdi->min_ratio = min_ratio;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}\n\nstatic int __bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned int max_ratio)\n{\n\tint ret = 0;\n\n\tif (max_ratio > 100 * BDI_RATIO_SCALE)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (bdi->min_ratio > max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tbdi->max_ratio = max_ratio;\n\t\tbdi->max_prop_frac = (FPROP_FRAC_BASE * max_ratio) / 100;\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}\n\nint bdi_set_min_ratio_no_scale(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\treturn __bdi_set_min_ratio(bdi, min_ratio);\n}\n\nint bdi_set_max_ratio_no_scale(struct backing_dev_info *bdi, unsigned int max_ratio)\n{\n\treturn __bdi_set_max_ratio(bdi, max_ratio);\n}\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\treturn __bdi_set_min_ratio(bdi, min_ratio * BDI_RATIO_SCALE);\n}\n\nint bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned int max_ratio)\n{\n\treturn __bdi_set_max_ratio(bdi, max_ratio * BDI_RATIO_SCALE);\n}\nEXPORT_SYMBOL(bdi_set_max_ratio);\n\nu64 bdi_get_min_bytes(struct backing_dev_info *bdi)\n{\n\treturn bdi_get_bytes(bdi->min_ratio);\n}\n\nint bdi_set_min_bytes(struct backing_dev_info *bdi, u64 min_bytes)\n{\n\tint ret;\n\tunsigned long pages = min_bytes >> PAGE_SHIFT;\n\tunsigned long min_ratio;\n\n\tret = bdi_check_pages_limit(pages);\n\tif (ret)\n\t\treturn ret;\n\n\tmin_ratio = bdi_ratio_from_pages(pages);\n\treturn __bdi_set_min_ratio(bdi, min_ratio);\n}\n\nu64 bdi_get_max_bytes(struct backing_dev_info *bdi)\n{\n\treturn bdi_get_bytes(bdi->max_ratio);\n}\n\nint bdi_set_max_bytes(struct backing_dev_info *bdi, u64 max_bytes)\n{\n\tint ret;\n\tunsigned long pages = max_bytes >> PAGE_SHIFT;\n\tunsigned long max_ratio;\n\n\tret = bdi_check_pages_limit(pages);\n\tif (ret)\n\t\treturn ret;\n\n\tmax_ratio = bdi_ratio_from_pages(pages);\n\treturn __bdi_set_max_ratio(bdi, max_ratio);\n}\n\nint bdi_set_strict_limit(struct backing_dev_info *bdi, unsigned int strict_limit)\n{\n\tif (strict_limit > 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (strict_limit)\n\t\tbdi->capabilities |= BDI_CAP_STRICTLIMIT;\n\telse\n\t\tbdi->capabilities &= ~BDI_CAP_STRICTLIMIT;\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn 0;\n}\n\nstatic unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}\n\nstatic unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}\n\n \nstatic void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}\n\n \nstatic unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tunsigned long numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t \n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 * BDI_RATIO_SCALE - bdi_min_ratio)) / (100 * BDI_RATIO_SCALE);\n\twb_thresh *= numerator;\n\twb_thresh = div64_ul(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / (100 * BDI_RATIO_SCALE);\n\tif (wb_thresh > (thresh * wb_max_ratio) / (100 * BDI_RATIO_SCALE))\n\t\twb_thresh = thresh * wb_max_ratio / (100 * BDI_RATIO_SCALE);\n\n\treturn wb_thresh;\n}\n\nunsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),\n\t\t\t\t\t       .thresh = thresh };\n\treturn __wb_calc_thresh(&gdtc);\n}\n\n \nstatic long long pos_ratio_polynom(unsigned long setpoint,\n\t\t\t\t\t  unsigned long dirty,\n\t\t\t\t\t  unsigned long limit)\n{\n\tlong long pos_ratio;\n\tlong x;\n\n\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,\n\t\t      (limit - setpoint) | 1);\n\tpos_ratio = x;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;\n\n\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);\n}\n\n \nstatic void wb_position_ratio(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long write_bw = READ_ONCE(wb->avg_write_bandwidth);\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long wb_thresh = dtc->wb_thresh;\n\tunsigned long x_intercept;\n\tunsigned long setpoint;\t\t \n\tunsigned long wb_setpoint;\n\tunsigned long span;\n\tlong long pos_ratio;\t\t \n\tlong x;\n\n\tdtc->pos_ratio = 0;\n\n\tif (unlikely(dtc->dirty >= limit))\n\t\treturn;\n\n\t \n\tsetpoint = (freerun + limit) / 2;\n\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);\n\n\t \n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tlong long wb_pos_ratio;\n\n\t\tif (dtc->wb_dirty < 8) {\n\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,\n\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dtc->wb_dirty >= wb_thresh)\n\t\t\treturn;\n\n\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,\n\t\t\t\t\t\t    dtc->wb_bg_thresh);\n\n\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)\n\t\t\treturn;\n\n\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,\n\t\t\t\t\t\t wb_thresh);\n\n\t\t \n\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (unlikely(wb_thresh > dtc->thresh))\n\t\twb_thresh = dtc->thresh;\n\t \n\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);\n\t \n\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);\n\twb_setpoint = setpoint * (u64)x >> 16;\n\t \n\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;\n\tx_intercept = wb_setpoint + span;\n\n\tif (dtc->wb_dirty < x_intercept - span / 4) {\n\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),\n\t\t\t\t      (x_intercept - wb_setpoint) | 1);\n\t} else\n\t\tpos_ratio /= 4;\n\n\t \n\tx_intercept = wb_thresh / 2;\n\tif (dtc->wb_dirty < x_intercept) {\n\t\tif (dtc->wb_dirty > x_intercept / 8)\n\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,\n\t\t\t\t\t    dtc->wb_dirty);\n\t\telse\n\t\t\tpos_ratio *= 8;\n\t}\n\n\tdtc->pos_ratio = pos_ratio;\n}\n\nstatic void wb_update_write_bandwidth(struct bdi_writeback *wb,\n\t\t\t\t      unsigned long elapsed,\n\t\t\t\t      unsigned long written)\n{\n\tconst unsigned long period = roundup_pow_of_two(3 * HZ);\n\tunsigned long avg = wb->avg_write_bandwidth;\n\tunsigned long old = wb->write_bandwidth;\n\tu64 bw;\n\n\t \n\tbw = written - min(written, wb->written_stamp);\n\tbw *= HZ;\n\tif (unlikely(elapsed > period)) {\n\t\tbw = div64_ul(bw, elapsed);\n\t\tavg = bw;\n\t\tgoto out;\n\t}\n\tbw += (u64)wb->write_bandwidth * (period - elapsed);\n\tbw >>= ilog2(period);\n\n\t \n\tif (avg > old && old >= (unsigned long)bw)\n\t\tavg -= (avg - old) >> 3;\n\n\tif (avg < old && old <= (unsigned long)bw)\n\t\tavg += (old - avg) >> 3;\n\nout:\n\t \n\tavg = max(avg, 1LU);\n\tif (wb_has_dirty_io(wb)) {\n\t\tlong delta = avg - wb->avg_write_bandwidth;\n\t\tWARN_ON_ONCE(atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);\n\t}\n\twb->write_bandwidth = bw;\n\tWRITE_ONCE(wb->avg_write_bandwidth, avg);\n}\n\nstatic void update_dirty_limit(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tunsigned long limit = dom->dirty_limit;\n\n\t \n\tif (limit < thresh) {\n\t\tlimit = thresh;\n\t\tgoto update;\n\t}\n\n\t \n\tthresh = max(thresh, dtc->dirty);\n\tif (limit > thresh) {\n\t\tlimit -= (limit - thresh) >> 5;\n\t\tgoto update;\n\t}\n\treturn;\nupdate:\n\tdom->dirty_limit = limit;\n}\n\nstatic void domain_update_dirty_limit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long now)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\n\t \n\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))\n\t\treturn;\n\n\tspin_lock(&dom->lock);\n\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {\n\t\tupdate_dirty_limit(dtc);\n\t\tdom->dirty_limit_tstamp = now;\n\t}\n\tspin_unlock(&dom->lock);\n}\n\n \nstatic void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long dirtied,\n\t\t\t\t      unsigned long elapsed)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long dirty = dtc->dirty;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long setpoint = (freerun + limit) / 2;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;\n\tunsigned long dirty_rate;\n\tunsigned long task_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\tunsigned long step;\n\tunsigned long x;\n\tunsigned long shift;\n\n\t \n\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;\n\n\t \n\ttask_ratelimit = (u64)dirty_ratelimit *\n\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;\n\ttask_ratelimit++;  \n\n\t \n\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,\n\t\t\t\t\t   dirty_rate | 1);\n\t \n\tif (unlikely(balanced_dirty_ratelimit > write_bw))\n\t\tbalanced_dirty_ratelimit = write_bw;\n\n\t \n\n\t \n\tstep = 0;\n\n\t \n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tdirty = dtc->wb_dirty;\n\t\tif (dtc->wb_dirty < 8)\n\t\t\tsetpoint = dtc->wb_dirty + 1;\n\t\telse\n\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;\n\t}\n\n\tif (dirty < setpoint) {\n\t\tx = min3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit < x)\n\t\t\tstep = x - dirty_ratelimit;\n\t} else {\n\t\tx = max3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit > x)\n\t\t\tstep = dirty_ratelimit - x;\n\t}\n\n\t \n\tshift = dirty_ratelimit / (2 * step + 1);\n\tif (shift < BITS_PER_LONG)\n\t\tstep = DIV_ROUND_UP(step >> shift, 8);\n\telse\n\t\tstep = 0;\n\n\tif (dirty_ratelimit < balanced_dirty_ratelimit)\n\t\tdirty_ratelimit += step;\n\telse\n\t\tdirty_ratelimit -= step;\n\n\tWRITE_ONCE(wb->dirty_ratelimit, max(dirty_ratelimit, 1UL));\n\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;\n\n\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);\n}\n\nstatic void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tspin_lock(&wb->list_lock);\n\n\t \n\telapsed = max(now - wb->bw_time_stamp, 1UL);\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\tif (update_ratelimit) {\n\t\tdomain_update_dirty_limit(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t \n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_dirty_limit(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\tWRITE_ONCE(wb->bw_time_stamp, now);\n\tspin_unlock(&wb->list_lock);\n}\n\nvoid wb_update_bandwidth(struct bdi_writeback *wb)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb) };\n\n\t__wb_update_bandwidth(&gdtc, NULL, false);\n}\n\n \n#define WB_BANDWIDTH_IDLE_JIF (HZ)\n\nstatic void wb_bandwidth_estimate_start(struct bdi_writeback *wb)\n{\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - READ_ONCE(wb->bw_time_stamp);\n\n\tif (elapsed > WB_BANDWIDTH_IDLE_JIF &&\n\t    !atomic_read(&wb->writeback_inodes)) {\n\t\tspin_lock(&wb->list_lock);\n\t\twb->dirtied_stamp = wb_stat(wb, WB_DIRTIED);\n\t\twb->written_stamp = wb_stat(wb, WB_WRITTEN);\n\t\tWRITE_ONCE(wb->bw_time_stamp, now);\n\t\tspin_unlock(&wb->list_lock);\n\t}\n}\n\n \nstatic unsigned long dirty_poll_interval(unsigned long dirty,\n\t\t\t\t\t unsigned long thresh)\n{\n\tif (thresh > dirty)\n\t\treturn 1UL << (ilog2(thresh - dirty) >> 1);\n\n\treturn 1;\n}\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = READ_ONCE(wb->avg_write_bandwidth);\n\tunsigned long t;\n\n\t \n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}\n\nstatic long wb_min_pause(struct bdi_writeback *wb,\n\t\t\t long max_pause,\n\t\t\t unsigned long task_ratelimit,\n\t\t\t unsigned long dirty_ratelimit,\n\t\t\t int *nr_dirtied_pause)\n{\n\tlong hi = ilog2(READ_ONCE(wb->avg_write_bandwidth));\n\tlong lo = ilog2(READ_ONCE(wb->dirty_ratelimit));\n\tlong t;\t\t \n\tlong pause;\t \n\tint pages;\t \n\n\t \n\tt = max(1, HZ / 100);\n\n\t \n\tif (hi > lo)\n\t\tt += (hi - lo) * (10 * HZ) / 1024;\n\n\t \n\tt = min(t, 1 + max_pause / 2);\n\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\n\t \n\tif (pages < DIRTY_POLL_THRESH) {\n\t\tt = max_pause;\n\t\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\t\tif (pages > DIRTY_POLL_THRESH) {\n\t\t\tpages = DIRTY_POLL_THRESH;\n\t\t\tt = HZ * DIRTY_POLL_THRESH / dirty_ratelimit;\n\t\t}\n\t}\n\n\tpause = HZ * pages / (task_ratelimit + 1);\n\tif (pause > max_pause) {\n\t\tt = max_pause;\n\t\tpages = task_ratelimit * t / roundup_pow_of_two(HZ);\n\t}\n\n\t*nr_dirtied_pause = pages;\n\t \n\treturn pages >= DIRTY_POLL_THRESH ? 1 + t / 2 : t;\n}\n\nstatic inline void wb_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long wb_reclaimable;\n\n\t \n\tdtc->wb_thresh = __wb_calc_thresh(dtc);\n\tdtc->wb_bg_thresh = dtc->thresh ?\n\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;\n\n\t \n\tif (dtc->wb_thresh < 2 * wb_stat_error()) {\n\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);\n\t} else {\n\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);\n\t}\n}\n\n \nstatic int balance_dirty_pages(struct bdi_writeback *wb,\n\t\t\t       unsigned long pages_dirtied, unsigned int flags)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tstruct dirty_throttle_control *sdtc;\n\tunsigned long nr_reclaimable;\t \n\tlong period;\n\tlong pause;\n\tlong max_pause;\n\tlong min_pause;\n\tint nr_dirtied_pause;\n\tbool dirty_exceeded = false;\n\tunsigned long task_ratelimit;\n\tunsigned long dirty_ratelimit;\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;\n\tunsigned long start_time = jiffies;\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long dirty, thresh, bg_thresh;\n\t\tunsigned long m_dirty = 0;\t \n\t\tunsigned long m_thresh = 0;\n\t\tunsigned long m_bg_thresh = 0;\n\n\t\tnr_reclaimable = global_node_page_state(NR_FILE_DIRTY);\n\t\tgdtc->avail = global_dirtyable_memory();\n\t\tgdtc->dirty = nr_reclaimable + global_node_page_state(NR_WRITEBACK);\n\n\t\tdomain_dirty_limits(gdtc);\n\n\t\tif (unlikely(strictlimit)) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tdirty = gdtc->wb_dirty;\n\t\t\tthresh = gdtc->wb_thresh;\n\t\t\tbg_thresh = gdtc->wb_bg_thresh;\n\t\t} else {\n\t\t\tdirty = gdtc->dirty;\n\t\t\tthresh = gdtc->thresh;\n\t\t\tbg_thresh = gdtc->bg_thresh;\n\t\t}\n\n\t\tif (mdtc) {\n\t\t\tunsigned long filepages, headroom, writeback;\n\n\t\t\t \n\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,\n\t\t\t\t\t    &mdtc->dirty, &writeback);\n\t\t\tmdtc->dirty += writeback;\n\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\n\t\t\tdomain_dirty_limits(mdtc);\n\n\t\t\tif (unlikely(strictlimit)) {\n\t\t\t\twb_dirty_limits(mdtc);\n\t\t\t\tm_dirty = mdtc->wb_dirty;\n\t\t\t\tm_thresh = mdtc->wb_thresh;\n\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;\n\t\t\t} else {\n\t\t\t\tm_dirty = mdtc->dirty;\n\t\t\t\tm_thresh = mdtc->thresh;\n\t\t\t\tm_bg_thresh = mdtc->bg_thresh;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!laptop_mode && nr_reclaimable > gdtc->bg_thresh &&\n\t\t    !writeback_in_progress(wb))\n\t\t\twb_start_background_writeback(wb);\n\n\t\t \n\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&\n\t\t    (!mdtc ||\n\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {\n\t\t\tunsigned long intv;\n\t\t\tunsigned long m_intv;\n\nfree_running:\n\t\t\tintv = dirty_poll_interval(dirty, thresh);\n\t\t\tm_intv = ULONG_MAX;\n\n\t\t\tcurrent->dirty_paused_when = now;\n\t\t\tcurrent->nr_dirtied = 0;\n\t\t\tif (mdtc)\n\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);\n\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (unlikely(!writeback_in_progress(wb)))\n\t\t\twb_start_background_writeback(wb);\n\n\t\tmem_cgroup_flush_foreign(wb);\n\n\t\t \n\t\tif (!strictlimit) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&\n\t\t\t    gdtc->wb_dirty <\n\t\t\t    dirty_freerun_ceiling(gdtc->wb_thresh,\n\t\t\t\t\t\t  gdtc->wb_bg_thresh))\n\t\t\t\t \n\t\t\t\tgoto free_running;\n\t\t}\n\n\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&\n\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);\n\n\t\twb_position_ratio(gdtc);\n\t\tsdtc = gdtc;\n\n\t\tif (mdtc) {\n\t\t\t \n\t\t\tif (!strictlimit) {\n\t\t\t\twb_dirty_limits(mdtc);\n\n\t\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&\n\t\t\t\t    mdtc->wb_dirty <\n\t\t\t\t    dirty_freerun_ceiling(mdtc->wb_thresh,\n\t\t\t\t\t\t\t  mdtc->wb_bg_thresh))\n\t\t\t\t\t \n\t\t\t\t\tgoto free_running;\n\t\t\t}\n\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&\n\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);\n\n\t\t\twb_position_ratio(mdtc);\n\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)\n\t\t\t\tsdtc = mdtc;\n\t\t}\n\n\t\tif (dirty_exceeded != wb->dirty_exceeded)\n\t\t\twb->dirty_exceeded = dirty_exceeded;\n\n\t\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +\n\t\t\t\t\t   BANDWIDTH_INTERVAL))\n\t\t\t__wb_update_bandwidth(gdtc, mdtc, true);\n\n\t\t \n\t\tdirty_ratelimit = READ_ONCE(wb->dirty_ratelimit);\n\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>\n\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;\n\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);\n\t\tmin_pause = wb_min_pause(wb, max_pause,\n\t\t\t\t\t task_ratelimit, dirty_ratelimit,\n\t\t\t\t\t &nr_dirtied_pause);\n\n\t\tif (unlikely(task_ratelimit == 0)) {\n\t\t\tperiod = max_pause;\n\t\t\tpause = max_pause;\n\t\t\tgoto pause;\n\t\t}\n\t\tperiod = HZ * pages_dirtied / task_ratelimit;\n\t\tpause = period;\n\t\tif (current->dirty_paused_when)\n\t\t\tpause -= now - current->dirty_paused_when;\n\t\t \n\t\tif (pause < min_pause) {\n\t\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t\t  period,\n\t\t\t\t\t\t  min(pause, 0L),\n\t\t\t\t\t\t  start_time);\n\t\t\tif (pause < -HZ) {\n\t\t\t\tcurrent->dirty_paused_when = now;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (period) {\n\t\t\t\tcurrent->dirty_paused_when += period;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)\n\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pause > max_pause)) {\n\t\t\t \n\t\t\tnow += min(pause - max_pause, max_pause);\n\t\t\tpause = max_pause;\n\t\t}\n\npause:\n\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t  period,\n\t\t\t\t\t  pause,\n\t\t\t\t\t  start_time);\n\t\tif (flags & BDP_ASYNC) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\t__set_current_state(TASK_KILLABLE);\n\t\twb->dirty_sleep = now;\n\t\tio_schedule_timeout(pause);\n\n\t\tcurrent->dirty_paused_when = now + pause;\n\t\tcurrent->nr_dirtied = 0;\n\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;\n\n\t\t \n\t\tif (task_ratelimit)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sdtc->wb_dirty <= wb_stat_error())\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\n \nDEFINE_PER_CPU(int, dirty_throttle_leaks) = 0;\n\n \nint balance_dirty_pages_ratelimited_flags(struct address_space *mapping,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint ret = 0;\n\tint *p;\n\n\tif (!(bdi->capabilities & BDI_CAP_WRITEBACK))\n\t\treturn ret;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t \n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t \n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tret = balance_dirty_pages(wb, current->nr_dirtied, flags);\n\n\twb_put(wb);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(balance_dirty_pages_ratelimited_flags);\n\n \nvoid balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tbalance_dirty_pages_ratelimited_flags(mapping, 0);\n}\nEXPORT_SYMBOL(balance_dirty_pages_ratelimited);\n\n \nbool wb_over_bg_thresh(struct bdi_writeback *wb)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tunsigned long reclaimable;\n\tunsigned long thresh;\n\n\t \n\tgdtc->avail = global_dirtyable_memory();\n\tgdtc->dirty = global_node_page_state(NR_FILE_DIRTY);\n\tdomain_dirty_limits(gdtc);\n\n\tif (gdtc->dirty > gdtc->bg_thresh)\n\t\treturn true;\n\n\tthresh = wb_calc_thresh(gdtc->wb, gdtc->bg_thresh);\n\tif (thresh < 2 * wb_stat_error())\n\t\treclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\telse\n\t\treclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\n\tif (reclaimable > thresh)\n\t\treturn true;\n\n\tif (mdtc) {\n\t\tunsigned long filepages, headroom, writeback;\n\n\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom, &mdtc->dirty,\n\t\t\t\t    &writeback);\n\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\t\tdomain_dirty_limits(mdtc);\t \n\n\t\tif (mdtc->dirty > mdtc->bg_thresh)\n\t\t\treturn true;\n\n\t\tthresh = wb_calc_thresh(mdtc->wb, mdtc->bg_thresh);\n\t\tif (thresh < 2 * wb_stat_error())\n\t\t\treclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\telse\n\t\t\treclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\n\t\tif (reclaimable > thresh)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_SYSCTL\n \nstatic int dirty_writeback_centisecs_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos)\n{\n\tunsigned int old_interval = dirty_writeback_interval;\n\tint ret;\n\n\tret = proc_dointvec(table, write, buffer, length, ppos);\n\n\t \n\tif (!ret && write && dirty_writeback_interval &&\n\t\tdirty_writeback_interval != old_interval)\n\t\twakeup_flusher_threads(WB_REASON_PERIODIC);\n\n\treturn ret;\n}\n#endif\n\nvoid laptop_mode_timer_fn(struct timer_list *t)\n{\n\tstruct backing_dev_info *backing_dev_info =\n\t\tfrom_timer(backing_dev_info, t, laptop_mode_wb_timer);\n\n\twakeup_flusher_threads_bdi(backing_dev_info, WB_REASON_LAPTOP_TIMER);\n}\n\n \nvoid laptop_io_completion(struct backing_dev_info *info)\n{\n\tmod_timer(&info->laptop_mode_wb_timer, jiffies + laptop_mode);\n}\n\n \nvoid laptop_sync_completion(void)\n{\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\tdel_timer(&bdi->laptop_mode_wb_timer);\n\n\trcu_read_unlock();\n}\n\n \n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}\n\nstatic int page_writeback_cpu_online(unsigned int cpu)\n{\n\twriteback_set_ratelimit();\n\treturn 0;\n}\n\n#ifdef CONFIG_SYSCTL\n\n \nstatic const unsigned long dirty_bytes_min = 2 * PAGE_SIZE;\n\nstatic struct ctl_table vm_page_writeback_sysctls[] = {\n\t{\n\t\t.procname   = \"dirty_background_ratio\",\n\t\t.data       = &dirty_background_ratio,\n\t\t.maxlen     = sizeof(dirty_background_ratio),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = dirty_background_ratio_handler,\n\t\t.extra1     = SYSCTL_ZERO,\n\t\t.extra2     = SYSCTL_ONE_HUNDRED,\n\t},\n\t{\n\t\t.procname   = \"dirty_background_bytes\",\n\t\t.data       = &dirty_background_bytes,\n\t\t.maxlen     = sizeof(dirty_background_bytes),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = dirty_background_bytes_handler,\n\t\t.extra1     = SYSCTL_LONG_ONE,\n\t},\n\t{\n\t\t.procname   = \"dirty_ratio\",\n\t\t.data       = &vm_dirty_ratio,\n\t\t.maxlen     = sizeof(vm_dirty_ratio),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = dirty_ratio_handler,\n\t\t.extra1     = SYSCTL_ZERO,\n\t\t.extra2     = SYSCTL_ONE_HUNDRED,\n\t},\n\t{\n\t\t.procname   = \"dirty_bytes\",\n\t\t.data       = &vm_dirty_bytes,\n\t\t.maxlen     = sizeof(vm_dirty_bytes),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = dirty_bytes_handler,\n\t\t.extra1     = (void *)&dirty_bytes_min,\n\t},\n\t{\n\t\t.procname   = \"dirty_writeback_centisecs\",\n\t\t.data       = &dirty_writeback_interval,\n\t\t.maxlen     = sizeof(dirty_writeback_interval),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = dirty_writeback_centisecs_handler,\n\t},\n\t{\n\t\t.procname   = \"dirty_expire_centisecs\",\n\t\t.data       = &dirty_expire_interval,\n\t\t.maxlen     = sizeof(dirty_expire_interval),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = proc_dointvec_minmax,\n\t\t.extra1     = SYSCTL_ZERO,\n\t},\n#ifdef CONFIG_HIGHMEM\n\t{\n\t\t.procname\t= \"highmem_is_dirtyable\",\n\t\t.data\t\t= &vm_highmem_is_dirtyable,\n\t\t.maxlen\t\t= sizeof(vm_highmem_is_dirtyable),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"laptop_mode\",\n\t\t.data\t\t= &laptop_mode,\n\t\t.maxlen\t\t= sizeof(laptop_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{}\n};\n#endif\n\n \nvoid __init page_writeback_init(void)\n{\n\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));\n\n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",\n\t\t\t  page_writeback_cpu_online, NULL);\n\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,\n\t\t\t  page_writeback_cpu_online);\n#ifdef CONFIG_SYSCTL\n\tregister_sysctl_init(\"vm\", vm_page_writeback_sysctls);\n#endif\n}\n\n \nvoid tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tunsigned int tagged = 0;\n\tvoid *page;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {\n\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n}\nEXPORT_SYMBOL(tag_pages_for_writeback);\n\n \nint write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data)\n{\n\tint ret = 0;\n\tint done = 0;\n\tint error;\n\tstruct folio_batch fbatch;\n\tint nr_folios;\n\tpgoff_t index;\n\tpgoff_t end;\t\t \n\tpgoff_t done_index;\n\tint range_whole = 0;\n\txa_mark_t tag;\n\n\tfolio_batch_init(&fbatch);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index;  \n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages) {\n\t\ttag_pages_for_writeback(mapping, index, end);\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\t} else {\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\t}\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\n\t\tnr_folios = filemap_get_folios_tag(mapping, &index, end,\n\t\t\t\ttag, &fbatch);\n\n\t\tif (nr_folios == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct folio *folio = fbatch.folios[i];\n\t\t\tunsigned long nr;\n\n\t\t\tdone_index = folio->index;\n\n\t\t\tfolio_lock(folio);\n\n\t\t\t \n\t\t\tif (unlikely(folio->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!folio_test_dirty(folio)) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (folio_test_writeback(folio)) {\n\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\t\tfolio_wait_writeback(folio);\n\t\t\t\telse\n\t\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tBUG_ON(folio_test_writeback(folio));\n\t\t\tif (!folio_clear_dirty_for_io(folio))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));\n\t\t\terror = writepage(folio, wbc, data);\n\t\t\tnr = folio_nr_pages(folio);\n\t\t\tif (unlikely(error)) {\n\t\t\t\t \n\t\t\t\tif (error == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\t\tfolio_unlock(folio);\n\t\t\t\t\terror = 0;\n\t\t\t\t} else if (wbc->sync_mode != WB_SYNC_ALL) {\n\t\t\t\t\tret = error;\n\t\t\t\t\tdone_index = folio->index + nr;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t}\n\n\t\t\t \n\t\t\twbc->nr_to_write -= nr;\n\t\t\tif (wbc->nr_to_write <= 0 &&\n\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\t}\n\n\t \n\tif (wbc->range_cyclic && !done)\n\t\tdone_index = 0;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(write_cache_pages);\n\nstatic int writepage_cb(struct folio *folio, struct writeback_control *wbc,\n\t\tvoid *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(&folio->page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}\n\nint do_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct bdi_writeback *wb;\n\n\tif (wbc->nr_to_write <= 0)\n\t\treturn 0;\n\twb = inode_to_wb_wbc(mapping->host, wbc);\n\twb_bandwidth_estimate_start(wb);\n\twhile (1) {\n\t\tif (mapping->a_ops->writepages) {\n\t\t\tret = mapping->a_ops->writepages(mapping, wbc);\n\t\t} else if (mapping->a_ops->writepage) {\n\t\t\tstruct blk_plug plug;\n\n\t\t\tblk_start_plug(&plug);\n\t\t\tret = write_cache_pages(mapping, wbc, writepage_cb,\n\t\t\t\t\t\tmapping);\n\t\t\tblk_finish_plug(&plug);\n\t\t} else {\n\t\t\t \n\t\t\tret = 0;\n\t\t}\n\t\tif (ret != -ENOMEM || wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tbreak;\n\n\t\t \n\t\treclaim_throttle(NODE_DATA(numa_node_id()),\n\t\t\tVMSCAN_THROTTLE_WRITEBACK);\n\t}\n\t \n\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +\n\t\t\t\t   BANDWIDTH_INTERVAL))\n\t\twb_update_bandwidth(wb);\n\treturn ret;\n}\n\n \nbool noop_dirty_folio(struct address_space *mapping, struct folio *folio)\n{\n\tif (!folio_test_dirty(folio))\n\t\treturn !folio_test_set_dirty(folio);\n\treturn false;\n}\nEXPORT_SYMBOL(noop_dirty_folio);\n\n \nstatic void folio_account_dirtied(struct folio *folio,\n\t\tstruct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\n\ttrace_writeback_dirty_folio(folio, mapping);\n\n\tif (mapping_can_writeback(mapping)) {\n\t\tstruct bdi_writeback *wb;\n\t\tlong nr = folio_nr_pages(folio);\n\n\t\tinode_attach_wb(inode, folio);\n\t\twb = inode_to_wb(inode);\n\n\t\t__lruvec_stat_mod_folio(folio, NR_FILE_DIRTY, nr);\n\t\t__zone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, nr);\n\t\t__node_stat_mod_folio(folio, NR_DIRTIED, nr);\n\t\twb_stat_mod(wb, WB_RECLAIMABLE, nr);\n\t\twb_stat_mod(wb, WB_DIRTIED, nr);\n\t\ttask_io_account_write(nr * PAGE_SIZE);\n\t\tcurrent->nr_dirtied += nr;\n\t\t__this_cpu_add(bdp_ratelimits, nr);\n\n\t\tmem_cgroup_track_foreign_dirty(folio, wb);\n\t}\n}\n\n \nvoid folio_account_cleaned(struct folio *folio, struct bdi_writeback *wb)\n{\n\tlong nr = folio_nr_pages(folio);\n\n\tlruvec_stat_mod_folio(folio, NR_FILE_DIRTY, -nr);\n\tzone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, -nr);\n\twb_stat_mod(wb, WB_RECLAIMABLE, -nr);\n\ttask_io_account_cancelled_write(nr * PAGE_SIZE);\n}\n\n \nvoid __folio_mark_dirty(struct folio *folio, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (folio->mapping) {\t \n\t\tWARN_ON_ONCE(warn && !folio_test_uptodate(folio));\n\t\tfolio_account_dirtied(folio, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, folio_index(folio),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}\n\n \nbool filemap_dirty_folio(struct address_space *mapping, struct folio *folio)\n{\n\tfolio_memcg_lock(folio);\n\tif (folio_test_set_dirty(folio)) {\n\t\tfolio_memcg_unlock(folio);\n\t\treturn false;\n\t}\n\n\t__folio_mark_dirty(folio, mapping, !folio_test_private(folio));\n\tfolio_memcg_unlock(folio);\n\n\tif (mapping->host) {\n\t\t \n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(filemap_dirty_folio);\n\n \nbool folio_redirty_for_writepage(struct writeback_control *wbc,\n\t\tstruct folio *folio)\n{\n\tstruct address_space *mapping = folio->mapping;\n\tlong nr = folio_nr_pages(folio);\n\tbool ret;\n\n\twbc->pages_skipped += nr;\n\tret = filemap_dirty_folio(mapping, folio);\n\tif (mapping && mapping_can_writeback(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tcurrent->nr_dirtied -= nr;\n\t\tnode_stat_mod_folio(folio, NR_DIRTIED, -nr);\n\t\twb_stat_mod(wb, WB_DIRTIED, -nr);\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(folio_redirty_for_writepage);\n\n \nbool folio_mark_dirty(struct folio *folio)\n{\n\tstruct address_space *mapping = folio_mapping(folio);\n\n\tif (likely(mapping)) {\n\t\t \n\t\tif (folio_test_reclaim(folio))\n\t\t\tfolio_clear_reclaim(folio);\n\t\treturn mapping->a_ops->dirty_folio(mapping, folio);\n\t}\n\n\treturn noop_dirty_folio(mapping, folio);\n}\nEXPORT_SYMBOL(folio_mark_dirty);\n\n \nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}\nEXPORT_SYMBOL(set_page_dirty_lock);\n\n \nvoid __folio_cancel_dirty(struct folio *folio)\n{\n\tstruct address_space *mapping = folio_mapping(folio);\n\n\tif (mapping_can_writeback(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\tfolio_memcg_lock(folio);\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\n\t\tif (folio_test_clear_dirty(folio))\n\t\t\tfolio_account_cleaned(folio, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\tfolio_memcg_unlock(folio);\n\t} else {\n\t\tfolio_clear_dirty(folio);\n\t}\n}\nEXPORT_SYMBOL(__folio_cancel_dirty);\n\n \nbool folio_clear_dirty_for_io(struct folio *folio)\n{\n\tstruct address_space *mapping = folio_mapping(folio);\n\tbool ret = false;\n\n\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n\n\tif (mapping && mapping_can_writeback(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t \n\t\tif (folio_mkclean(folio))\n\t\t\tfolio_mark_dirty(folio);\n\t\t \n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (folio_test_clear_dirty(folio)) {\n\t\t\tlong nr = folio_nr_pages(folio);\n\t\t\tlruvec_stat_mod_folio(folio, NR_FILE_DIRTY, -nr);\n\t\t\tzone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, -nr);\n\t\t\twb_stat_mod(wb, WB_RECLAIMABLE, -nr);\n\t\t\tret = true;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn folio_test_clear_dirty(folio);\n}\nEXPORT_SYMBOL(folio_clear_dirty_for_io);\n\nstatic void wb_inode_writeback_start(struct bdi_writeback *wb)\n{\n\tatomic_inc(&wb->writeback_inodes);\n}\n\nstatic void wb_inode_writeback_end(struct bdi_writeback *wb)\n{\n\tunsigned long flags;\n\tatomic_dec(&wb->writeback_inodes);\n\t \n\tspin_lock_irqsave(&wb->work_lock, flags);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tqueue_delayed_work(bdi_wq, &wb->bw_dwork, BANDWIDTH_INTERVAL);\n\tspin_unlock_irqrestore(&wb->work_lock, flags);\n}\n\nbool __folio_end_writeback(struct folio *folio)\n{\n\tlong nr = folio_nr_pages(folio);\n\tstruct address_space *mapping = folio_mapping(folio);\n\tbool ret;\n\n\tfolio_memcg_lock(folio);\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = folio_test_clear_writeback(folio);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, folio_index(folio),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi->capabilities & BDI_CAP_WRITEBACK_ACCT) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\twb_stat_mod(wb, WB_WRITEBACK, -nr);\n\t\t\t\t__wb_writeout_add(wb, nr);\n\t\t\t\tif (!mapping_tagged(mapping,\n\t\t\t\t\t\t    PAGECACHE_TAG_WRITEBACK))\n\t\t\t\t\twb_inode_writeback_end(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = folio_test_clear_writeback(folio);\n\t}\n\tif (ret) {\n\t\tlruvec_stat_mod_folio(folio, NR_WRITEBACK, -nr);\n\t\tzone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, -nr);\n\t\tnode_stat_mod_folio(folio, NR_WRITTEN, nr);\n\t}\n\tfolio_memcg_unlock(folio);\n\treturn ret;\n}\n\nbool __folio_start_writeback(struct folio *folio, bool keep_write)\n{\n\tlong nr = folio_nr_pages(folio);\n\tstruct address_space *mapping = folio_mapping(folio);\n\tbool ret;\n\tint access_ret;\n\n\tfolio_memcg_lock(folio);\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tXA_STATE(xas, &mapping->i_pages, folio_index(folio));\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txas_lock_irqsave(&xas, flags);\n\t\txas_load(&xas);\n\t\tret = folio_test_set_writeback(folio);\n\t\tif (!ret) {\n\t\t\tbool on_wblist;\n\n\t\t\ton_wblist = mapping_tagged(mapping,\n\t\t\t\t\t\t   PAGECACHE_TAG_WRITEBACK);\n\n\t\t\txas_set_mark(&xas, PAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi->capabilities & BDI_CAP_WRITEBACK_ACCT) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\twb_stat_mod(wb, WB_WRITEBACK, nr);\n\t\t\t\tif (!on_wblist)\n\t\t\t\t\twb_inode_writeback_start(wb);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mapping->host && !on_wblist)\n\t\t\t\tsb_mark_inode_writeback(mapping->host);\n\t\t}\n\t\tif (!folio_test_dirty(folio))\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_DIRTY);\n\t\tif (!keep_write)\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\txas_unlock_irqrestore(&xas, flags);\n\t} else {\n\t\tret = folio_test_set_writeback(folio);\n\t}\n\tif (!ret) {\n\t\tlruvec_stat_mod_folio(folio, NR_WRITEBACK, nr);\n\t\tzone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, nr);\n\t}\n\tfolio_memcg_unlock(folio);\n\taccess_ret = arch_make_folio_accessible(folio);\n\t \n\tVM_BUG_ON_FOLIO(access_ret != 0, folio);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__folio_start_writeback);\n\n \nvoid folio_wait_writeback(struct folio *folio)\n{\n\twhile (folio_test_writeback(folio)) {\n\t\ttrace_folio_wait_writeback(folio, folio_mapping(folio));\n\t\tfolio_wait_bit(folio, PG_writeback);\n\t}\n}\nEXPORT_SYMBOL_GPL(folio_wait_writeback);\n\n \nint folio_wait_writeback_killable(struct folio *folio)\n{\n\twhile (folio_test_writeback(folio)) {\n\t\ttrace_folio_wait_writeback(folio, folio_mapping(folio));\n\t\tif (folio_wait_bit_killable(folio, PG_writeback))\n\t\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(folio_wait_writeback_killable);\n\n \nvoid folio_wait_stable(struct folio *folio)\n{\n\tif (mapping_stable_writes(folio_mapping(folio)))\n\t\tfolio_wait_writeback(folio);\n}\nEXPORT_SYMBOL_GPL(folio_wait_stable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}