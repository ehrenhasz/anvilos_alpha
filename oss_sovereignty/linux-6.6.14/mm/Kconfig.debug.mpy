{
  "module_name": "Kconfig.debug",
  "hash_id": "90cfa1c7599e3b87c619cb2ceb2e6b7710d64a752c2f8abb8379ce19affa52d1",
  "original_prompt": "Ingested from linux-6.6.14/mm/Kconfig.debug",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nconfig PAGE_EXTENSION\n\tbool \"Extend memmap on extra space for more information on page\"\n\thelp\n\t  Extend memmap on extra space for more information on page. This\n\t  could be used for debugging features that need to insert extra\n\t  field for every page. This extension enables us to save memory\n\t  by not allocating this extra memory according to boottime\n\t  configuration.\n\nconfig DEBUG_PAGEALLOC\n\tbool \"Debug page memory allocations\"\n\tdepends on DEBUG_KERNEL\n\tdepends on !HIBERNATION || ARCH_SUPPORTS_DEBUG_PAGEALLOC && !PPC && !SPARC\n\tselect PAGE_POISONING if !ARCH_SUPPORTS_DEBUG_PAGEALLOC\n\thelp\n\t  Unmap pages from the kernel linear mapping after free_pages().\n\t  Depending on runtime enablement, this results in a small or large\n\t  slowdown, but helps to find certain types of memory corruption.\n\n\t  Also, the state of page tracking structures is checked more often as\n\t  pages are being allocated and freed, as unexpected state changes\n\t  often happen for same reasons as memory corruption (e.g. double free,\n\t  use-after-free). The error reports for these checks can be augmented\n\t  with stack traces of last allocation and freeing of the page, when\n\t  PAGE_OWNER is also selected and enabled on boot.\n\n\t  For architectures which don't enable ARCH_SUPPORTS_DEBUG_PAGEALLOC,\n\t  fill the pages with poison patterns after free_pages() and verify\n\t  the patterns before alloc_pages(). Additionally, this option cannot\n\t  be enabled in combination with hibernation as that would result in\n\t  incorrect warnings of memory corruption after a resume because free\n\t  pages are not saved to the suspend image.\n\n\t  By default this option will have a small overhead, e.g. by not\n\t  allowing the kernel mapping to be backed by large pages on some\n\t  architectures. Even bigger overhead comes when the debugging is\n\t  enabled by DEBUG_PAGEALLOC_ENABLE_DEFAULT or the debug_pagealloc\n\t  command line parameter.\n\nconfig DEBUG_PAGEALLOC_ENABLE_DEFAULT\n\tbool \"Enable debug page memory allocations by default?\"\n\tdepends on DEBUG_PAGEALLOC\n\thelp\n\t  Enable debug page memory allocations by default? This value\n\t  can be overridden by debug_pagealloc=off|on.\n\nconfig DEBUG_SLAB\n\tbool \"Debug slab memory allocations\"\n\tdepends on DEBUG_KERNEL && SLAB\n\thelp\n\t  Say Y here to have the kernel do limited verification on memory\n\t  allocation as well as poisoning memory on free to catch use of freed\n\t  memory. This can make kmalloc/kfree-intensive workloads much slower.\n\nconfig SLUB_DEBUG\n\tdefault y\n\tbool \"Enable SLUB debugging support\" if EXPERT\n\tdepends on SLUB && SYSFS && !SLUB_TINY\n\tselect STACKDEPOT if STACKTRACE_SUPPORT\n\thelp\n\t  SLUB has extensive debug support features. Disabling these can\n\t  result in significant savings in code size. While /sys/kernel/slab\n\t  will still exist (with SYSFS enabled), it will not provide e.g. cache\n\t  validation.\n\nconfig SLUB_DEBUG_ON\n\tbool \"SLUB debugging on by default\"\n\tdepends on SLUB && SLUB_DEBUG\n\tselect STACKDEPOT_ALWAYS_INIT if STACKTRACE_SUPPORT\n\tdefault n\n\thelp\n\t  Boot with debugging on by default. SLUB boots by default with\n\t  the runtime debug capabilities switched off. Enabling this is\n\t  equivalent to specifying the \"slub_debug\" parameter on boot.\n\t  There is no support for more fine grained debug control like\n\t  possible with slub_debug=xxx. SLUB debugging may be switched\n\t  off in a kernel built with CONFIG_SLUB_DEBUG_ON by specifying\n\t  \"slub_debug=-\".\n\nconfig PAGE_OWNER\n\tbool \"Track page owner\"\n\tdepends on DEBUG_KERNEL && STACKTRACE_SUPPORT\n\tselect DEBUG_FS\n\tselect STACKTRACE\n\tselect STACKDEPOT\n\tselect PAGE_EXTENSION\n\thelp\n\t  This keeps track of what call chain is the owner of a page, may\n\t  help to find bare alloc_page(s) leaks. Even if you include this\n\t  feature on your build, it is disabled in default. You should pass\n\t  \"page_owner=on\" to boot parameter in order to enable it. Eats\n\t  a fair amount of memory if enabled. See tools/mm/page_owner_sort.c\n\t  for user-space helper.\n\n\t  If unsure, say N.\n\nconfig PAGE_TABLE_CHECK\n\tbool \"Check for invalid mappings in user page tables\"\n\tdepends on ARCH_SUPPORTS_PAGE_TABLE_CHECK\n\tdepends on EXCLUSIVE_SYSTEM_RAM\n\tselect PAGE_EXTENSION\n\thelp\n\t  Check that anonymous page is not being mapped twice with read write\n\t  permissions. Check that anonymous and file pages are not being\n\t  erroneously shared. Since the checking is performed at the time\n\t  entries are added and removed to user page tables, leaking, corruption\n\t  and double mapping problems are detected synchronously.\n\n\t  If unsure say \"n\".\n\nconfig PAGE_TABLE_CHECK_ENFORCED\n\tbool \"Enforce the page table checking by default\"\n\tdepends on PAGE_TABLE_CHECK\n\thelp\n\t  Always enable page table checking.  By default the page table checking\n\t  is disabled, and can be optionally enabled via page_table_check=on\n\t  kernel parameter. This config enforces that page table check is always\n\t  enabled.\n\n\t  If unsure say \"n\".\n\nconfig PAGE_POISONING\n\tbool \"Poison pages after freeing\"\n\thelp\n\t  Fill the pages with poison patterns after free_pages() and verify\n\t  the patterns before alloc_pages. The filling of the memory helps\n\t  reduce the risk of information leaks from freed data. This does\n\t  have a potential performance impact if enabled with the\n\t  \"page_poison=1\" kernel boot option.\n\n\t  Note that \"poison\" here is not the same thing as the \"HWPoison\"\n\t  for CONFIG_MEMORY_FAILURE. This is software poisoning only.\n\n\t  If you are only interested in sanitization of freed pages without\n\t  checking the poison pattern on alloc, you can boot the kernel with\n\t  \"init_on_free=1\" instead of enabling this.\n\n\t  If unsure, say N\n\nconfig DEBUG_PAGE_REF\n\tbool \"Enable tracepoint to track down page reference manipulation\"\n\tdepends on DEBUG_KERNEL\n\tdepends on TRACEPOINTS\n\thelp\n\t  This is a feature to add tracepoint for tracking down page reference\n\t  manipulation. This tracking is useful to diagnose functional failure\n\t  due to migration failures caused by page reference mismatches.  Be\n\t  careful when enabling this feature because it adds about 30 KB to the\n\t  kernel code.  However the runtime performance overhead is virtually\n\t  nil until the tracepoints are actually enabled.\n\nconfig DEBUG_RODATA_TEST\n    bool \"Testcase for the marking rodata read-only\"\n    depends on STRICT_KERNEL_RWX\n\thelp\n      This option enables a testcase for the setting rodata read-only.\n\nconfig ARCH_HAS_DEBUG_WX\n\tbool\n\nconfig DEBUG_WX\n\tbool \"Warn on W+X mappings at boot\"\n\tdepends on ARCH_HAS_DEBUG_WX\n\tdepends on MMU\n\tselect PTDUMP_CORE\n\thelp\n\t  Generate a warning if any W+X mappings are found at boot.\n\n\t  This is useful for discovering cases where the kernel is leaving W+X\n\t  mappings after applying NX, as such mappings are a security risk.\n\n\t  Look for a message in dmesg output like this:\n\n\t    <arch>/mm: Checked W+X mappings: passed, no W+X pages found.\n\n\t  or like this, if the check failed:\n\n\t    <arch>/mm: Checked W+X mappings: failed, <N> W+X pages found.\n\n\t  Note that even if the check fails, your kernel is possibly\n\t  still fine, as W+X mappings are not a security hole in\n\t  themselves, what they do is that they make the exploitation\n\t  of other unfixed kernel bugs easier.\n\n\t  There is no runtime or memory usage effect of this option\n\t  once the kernel has booted up - it's a one time check.\n\n\t  If in doubt, say \"Y\".\n\nconfig GENERIC_PTDUMP\n\tbool\n\nconfig PTDUMP_CORE\n\tbool\n\nconfig PTDUMP_DEBUGFS\n\tbool \"Export kernel pagetable layout to userspace via debugfs\"\n\tdepends on DEBUG_KERNEL\n\tdepends on DEBUG_FS\n\tdepends on GENERIC_PTDUMP\n\tselect PTDUMP_CORE\n\thelp\n\t  Say Y here if you want to show the kernel pagetable layout in a\n\t  debugfs file. This information is only useful for kernel developers\n\t  who are working in architecture specific areas of the kernel.\n\t  It is probably not a good idea to enable this feature in a production\n\t  kernel.\n\n\t  If in doubt, say N.\n\nconfig HAVE_DEBUG_KMEMLEAK\n\tbool\n\nconfig DEBUG_KMEMLEAK\n\tbool \"Kernel memory leak detector\"\n\tdepends on DEBUG_KERNEL && HAVE_DEBUG_KMEMLEAK\n\tselect DEBUG_FS\n\tselect STACKTRACE if STACKTRACE_SUPPORT\n\tselect KALLSYMS\n\tselect CRC32\n\tselect STACKDEPOT\n\tselect STACKDEPOT_ALWAYS_INIT if !DEBUG_KMEMLEAK_DEFAULT_OFF\n\thelp\n\t  Say Y here if you want to enable the memory leak\n\t  detector. The memory allocation/freeing is traced in a way\n\t  similar to the Boehm's conservative garbage collector, the\n\t  difference being that the orphan objects are not freed but\n\t  only shown in /sys/kernel/debug/kmemleak. Enabling this\n\t  feature will introduce an overhead to memory\n\t  allocations. See Documentation/dev-tools/kmemleak.rst for more\n\t  details.\n\n\t  Enabling DEBUG_SLAB or SLUB_DEBUG may increase the chances\n\t  of finding leaks due to the slab objects poisoning.\n\n\t  In order to access the kmemleak file, debugfs needs to be\n\t  mounted (usually at /sys/kernel/debug).\n\nconfig DEBUG_KMEMLEAK_MEM_POOL_SIZE\n\tint \"Kmemleak memory pool size\"\n\tdepends on DEBUG_KMEMLEAK\n\trange 200 1000000\n\tdefault 16000\n\thelp\n\t  Kmemleak must track all the memory allocations to avoid\n\t  reporting false positives. Since memory may be allocated or\n\t  freed before kmemleak is fully initialised, use a static pool\n\t  of metadata objects to track such callbacks. After kmemleak is\n\t  fully initialised, this memory pool acts as an emergency one\n\t  if slab allocations fail.\n\nconfig DEBUG_KMEMLEAK_DEFAULT_OFF\n\tbool \"Default kmemleak to off\"\n\tdepends on DEBUG_KMEMLEAK\n\thelp\n\t  Say Y here to disable kmemleak by default. It can then be enabled\n\t  on the command line via kmemleak=on.\n\nconfig DEBUG_KMEMLEAK_AUTO_SCAN\n\tbool \"Enable kmemleak auto scan thread on boot up\"\n\tdefault y\n\tdepends on DEBUG_KMEMLEAK\n\thelp\n\t  Depending on the cpu, kmemleak scan may be cpu intensive and can\n\t  stall user tasks at times. This option enables/disables automatic\n\t  kmemleak scan at boot up.\n\n\t  Say N here to disable kmemleak auto scan thread to stop automatic\n\t  scanning. Disabling this option disables automatic reporting of\n\t  memory leaks.\n\n\t  If unsure, say Y.\n\nconfig PER_VMA_LOCK_STATS\n\tbool \"Statistics for per-vma locks\"\n\tdepends on PER_VMA_LOCK\n\thelp\n\t  Say Y here to enable success, retry and failure counters of page\n\t  faults handled under protection of per-vma locks. When enabled, the\n\t  counters are exposed in /proc/vmstat. This information is useful for\n\t  kernel developers to evaluate effectiveness of per-vma locks and to\n\t  identify pathological cases. Counting these events introduces a small\n\t  overhead in the page fault path.\n\n\t  If in doubt, say N.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}