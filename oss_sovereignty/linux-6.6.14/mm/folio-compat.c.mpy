{
  "module_name": "folio-compat.c",
  "hash_id": "2915d23c4b7c6819796d19d3ef8c44aef906de3782153905c371880862d1fe69",
  "original_prompt": "Ingested from linux-6.6.14/mm/folio-compat.c",
  "human_readable_source": " \n\n#include <linux/migrate.h>\n#include <linux/pagemap.h>\n#include <linux/rmap.h>\n#include <linux/swap.h>\n#include \"internal.h\"\n\nstruct address_space *page_mapping(struct page *page)\n{\n\treturn folio_mapping(page_folio(page));\n}\nEXPORT_SYMBOL(page_mapping);\n\nvoid unlock_page(struct page *page)\n{\n\treturn folio_unlock(page_folio(page));\n}\nEXPORT_SYMBOL(unlock_page);\n\nvoid end_page_writeback(struct page *page)\n{\n\treturn folio_end_writeback(page_folio(page));\n}\nEXPORT_SYMBOL(end_page_writeback);\n\nvoid wait_on_page_writeback(struct page *page)\n{\n\treturn folio_wait_writeback(page_folio(page));\n}\nEXPORT_SYMBOL_GPL(wait_on_page_writeback);\n\nvoid wait_for_stable_page(struct page *page)\n{\n\treturn folio_wait_stable(page_folio(page));\n}\nEXPORT_SYMBOL_GPL(wait_for_stable_page);\n\nvoid mark_page_accessed(struct page *page)\n{\n\tfolio_mark_accessed(page_folio(page));\n}\nEXPORT_SYMBOL(mark_page_accessed);\n\nbool set_page_writeback(struct page *page)\n{\n\treturn folio_start_writeback(page_folio(page));\n}\nEXPORT_SYMBOL(set_page_writeback);\n\nbool set_page_dirty(struct page *page)\n{\n\treturn folio_mark_dirty(page_folio(page));\n}\nEXPORT_SYMBOL(set_page_dirty);\n\nint __set_page_dirty_nobuffers(struct page *page)\n{\n\treturn filemap_dirty_folio(page_mapping(page), page_folio(page));\n}\nEXPORT_SYMBOL(__set_page_dirty_nobuffers);\n\nbool clear_page_dirty_for_io(struct page *page)\n{\n\treturn folio_clear_dirty_for_io(page_folio(page));\n}\nEXPORT_SYMBOL(clear_page_dirty_for_io);\n\nbool redirty_page_for_writepage(struct writeback_control *wbc,\n\t\tstruct page *page)\n{\n\treturn folio_redirty_for_writepage(wbc, page_folio(page));\n}\nEXPORT_SYMBOL(redirty_page_for_writepage);\n\nvoid lru_cache_add_inactive_or_unevictable(struct page *page,\n\t\tstruct vm_area_struct *vma)\n{\n\tfolio_add_lru_vma(page_folio(page), vma);\n}\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\tpgoff_t index, gfp_t gfp)\n{\n\treturn filemap_add_folio(mapping, page_folio(page), index, gfp);\n}\nEXPORT_SYMBOL(add_to_page_cache_lru);\n\nnoinline\nstruct page *pagecache_get_page(struct address_space *mapping, pgoff_t index,\n\t\tfgf_t fgp_flags, gfp_t gfp)\n{\n\tstruct folio *folio;\n\n\tfolio = __filemap_get_folio(mapping, index, fgp_flags, gfp);\n\tif (IS_ERR(folio))\n\t\treturn NULL;\n\treturn folio_file_page(folio, index);\n}\nEXPORT_SYMBOL(pagecache_get_page);\n\nstruct page *grab_cache_page_write_begin(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index)\n{\n\treturn pagecache_get_page(mapping, index, FGP_WRITEBEGIN,\n\t\t\tmapping_gfp_mask(mapping));\n}\nEXPORT_SYMBOL(grab_cache_page_write_begin);\n\nbool isolate_lru_page(struct page *page)\n{\n\tif (WARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\"))\n\t\treturn false;\n\treturn folio_isolate_lru((struct folio *)page);\n}\n\nvoid putback_lru_page(struct page *page)\n{\n\tfolio_putback_lru(page_folio(page));\n}\n\n#ifdef CONFIG_MMU\nvoid page_add_new_anon_rmap(struct page *page, struct vm_area_struct *vma,\n\t\tunsigned long address)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\treturn folio_add_new_anon_rmap((struct folio *)page, vma, address);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}