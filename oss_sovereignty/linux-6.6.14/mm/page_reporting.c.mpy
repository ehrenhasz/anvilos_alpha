{
  "module_name": "page_reporting.c",
  "hash_id": "382a01a9e1c7042cb554748ed4802fe2c90200e15fde29a849812d25092ed0eb",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_reporting.c",
  "human_readable_source": "\n#include <linux/mm.h>\n#include <linux/mmzone.h>\n#include <linux/page_reporting.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/scatterlist.h>\n\n#include \"page_reporting.h\"\n#include \"internal.h\"\n\n \nunsigned int page_reporting_order = -1;\n\nstatic int page_order_update_notify(const char *val, const struct kernel_param *kp)\n{\n\t \n\treturn  param_set_uint_minmax(val, kp, 0, MAX_ORDER);\n}\n\nstatic const struct kernel_param_ops page_reporting_param_ops = {\n\t.set = &page_order_update_notify,\n\t \n\t.get = &param_get_int,\n};\n\nmodule_param_cb(page_reporting_order, &page_reporting_param_ops,\n\t\t\t&page_reporting_order, 0644);\nMODULE_PARM_DESC(page_reporting_order, \"Set page reporting order\");\n\n \nEXPORT_SYMBOL_GPL(page_reporting_order);\n\n#define PAGE_REPORTING_DELAY\t(2 * HZ)\nstatic struct page_reporting_dev_info __rcu *pr_dev_info __read_mostly;\n\nenum {\n\tPAGE_REPORTING_IDLE = 0,\n\tPAGE_REPORTING_REQUESTED,\n\tPAGE_REPORTING_ACTIVE\n};\n\n \nstatic void\n__page_reporting_request(struct page_reporting_dev_info *prdev)\n{\n\tunsigned int state;\n\n\t \n\tstate = atomic_read(&prdev->state);\n\tif (state == PAGE_REPORTING_REQUESTED)\n\t\treturn;\n\n\t \n\tstate = atomic_xchg(&prdev->state, PAGE_REPORTING_REQUESTED);\n\tif (state != PAGE_REPORTING_IDLE)\n\t\treturn;\n\n\t \n\tschedule_delayed_work(&prdev->work, PAGE_REPORTING_DELAY);\n}\n\n \nvoid __page_reporting_notify(void)\n{\n\tstruct page_reporting_dev_info *prdev;\n\n\t \n\trcu_read_lock();\n\tprdev = rcu_dereference(pr_dev_info);\n\tif (likely(prdev))\n\t\t__page_reporting_request(prdev);\n\n\trcu_read_unlock();\n}\n\nstatic void\npage_reporting_drain(struct page_reporting_dev_info *prdev,\n\t\t     struct scatterlist *sgl, unsigned int nents, bool reported)\n{\n\tstruct scatterlist *sg = sgl;\n\n\t \n\tdo {\n\t\tstruct page *page = sg_page(sg);\n\t\tint mt = get_pageblock_migratetype(page);\n\t\tunsigned int order = get_order(sg->length);\n\n\t\t__putback_isolated_page(page, order, mt);\n\n\t\t \n\t\tif (!reported)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (PageBuddy(page) && buddy_order(page) == order)\n\t\t\t__SetPageReported(page);\n\t} while ((sg = sg_next(sg)));\n\n\t \n\tsg_init_table(sgl, nents);\n}\n\n \nstatic int\npage_reporting_cycle(struct page_reporting_dev_info *prdev, struct zone *zone,\n\t\t     unsigned int order, unsigned int mt,\n\t\t     struct scatterlist *sgl, unsigned int *offset)\n{\n\tstruct free_area *area = &zone->free_area[order];\n\tstruct list_head *list = &area->free_list[mt];\n\tunsigned int page_len = PAGE_SIZE << order;\n\tstruct page *page, *next;\n\tlong budget;\n\tint err = 0;\n\n\t \n\tif (list_empty(list))\n\t\treturn err;\n\n\tspin_lock_irq(&zone->lock);\n\n\t \n\tbudget = DIV_ROUND_UP(area->nr_free, PAGE_REPORTING_CAPACITY * 16);\n\n\t \n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\t \n\t\tif (PageReported(page))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (budget < 0) {\n\t\t\tatomic_set(&prdev->state, PAGE_REPORTING_REQUESTED);\n\t\t\tnext = page;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (*offset) {\n\t\t\tif (!__isolate_free_page(page, order)) {\n\t\t\t\tnext = page;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\t--(*offset);\n\t\t\tsg_set_page(&sgl[*offset], page, page_len, 0);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!list_is_first(&page->lru, list))\n\t\t\tlist_rotate_to_front(&page->lru, list);\n\n\t\t \n\t\tspin_unlock_irq(&zone->lock);\n\n\t\t \n\t\terr = prdev->report(prdev, sgl, PAGE_REPORTING_CAPACITY);\n\n\t\t \n\t\t*offset = PAGE_REPORTING_CAPACITY;\n\n\t\t \n\t\tbudget--;\n\n\t\t \n\t\tspin_lock_irq(&zone->lock);\n\n\t\t \n\t\tpage_reporting_drain(prdev, sgl, PAGE_REPORTING_CAPACITY, !err);\n\n\t\t \n\t\tnext = list_first_entry(list, struct page, lru);\n\n\t\t \n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!list_entry_is_head(next, list, lru) && !list_is_first(&next->lru, list))\n\t\tlist_rotate_to_front(&next->lru, list);\n\n\tspin_unlock_irq(&zone->lock);\n\n\treturn err;\n}\n\nstatic int\npage_reporting_process_zone(struct page_reporting_dev_info *prdev,\n\t\t\t    struct scatterlist *sgl, struct zone *zone)\n{\n\tunsigned int order, mt, leftover, offset = PAGE_REPORTING_CAPACITY;\n\tunsigned long watermark;\n\tint err = 0;\n\n\t \n\twatermark = low_wmark_pages(zone) +\n\t\t    (PAGE_REPORTING_CAPACITY << page_reporting_order);\n\n\t \n\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\treturn err;\n\n\t \n\tfor (order = page_reporting_order; order <= MAX_ORDER; order++) {\n\t\tfor (mt = 0; mt < MIGRATE_TYPES; mt++) {\n\t\t\t \n\t\t\tif (is_migrate_isolate(mt))\n\t\t\t\tcontinue;\n\n\t\t\terr = page_reporting_cycle(prdev, zone, order, mt,\n\t\t\t\t\t\t   sgl, &offset);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tleftover = PAGE_REPORTING_CAPACITY - offset;\n\tif (leftover) {\n\t\tsgl = &sgl[offset];\n\t\terr = prdev->report(prdev, sgl, leftover);\n\n\t\t \n\t\tspin_lock_irq(&zone->lock);\n\t\tpage_reporting_drain(prdev, sgl, leftover, !err);\n\t\tspin_unlock_irq(&zone->lock);\n\t}\n\n\treturn err;\n}\n\nstatic void page_reporting_process(struct work_struct *work)\n{\n\tstruct delayed_work *d_work = to_delayed_work(work);\n\tstruct page_reporting_dev_info *prdev =\n\t\tcontainer_of(d_work, struct page_reporting_dev_info, work);\n\tint err = 0, state = PAGE_REPORTING_ACTIVE;\n\tstruct scatterlist *sgl;\n\tstruct zone *zone;\n\n\t \n\tatomic_set(&prdev->state, state);\n\n\t \n\tsgl = kmalloc_array(PAGE_REPORTING_CAPACITY, sizeof(*sgl), GFP_KERNEL);\n\tif (!sgl)\n\t\tgoto err_out;\n\n\tsg_init_table(sgl, PAGE_REPORTING_CAPACITY);\n\n\tfor_each_zone(zone) {\n\t\terr = page_reporting_process_zone(prdev, sgl, zone);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tkfree(sgl);\nerr_out:\n\t \n\tstate = atomic_cmpxchg(&prdev->state, state, PAGE_REPORTING_IDLE);\n\tif (state == PAGE_REPORTING_REQUESTED)\n\t\tschedule_delayed_work(&prdev->work, PAGE_REPORTING_DELAY);\n}\n\nstatic DEFINE_MUTEX(page_reporting_mutex);\nDEFINE_STATIC_KEY_FALSE(page_reporting_enabled);\n\nint page_reporting_register(struct page_reporting_dev_info *prdev)\n{\n\tint err = 0;\n\n\tmutex_lock(&page_reporting_mutex);\n\n\t \n\tif (rcu_dereference_protected(pr_dev_info,\n\t\t\t\tlockdep_is_held(&page_reporting_mutex))) {\n\t\terr = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\t \n\n\tif (page_reporting_order == -1) {\n\t\tif (prdev->order > 0 && prdev->order <= MAX_ORDER)\n\t\t\tpage_reporting_order = prdev->order;\n\t\telse\n\t\t\tpage_reporting_order = pageblock_order;\n\t}\n\n\t \n\tatomic_set(&prdev->state, PAGE_REPORTING_IDLE);\n\tINIT_DELAYED_WORK(&prdev->work, &page_reporting_process);\n\n\t \n\t__page_reporting_request(prdev);\n\n\t \n\trcu_assign_pointer(pr_dev_info, prdev);\n\n\t \n\tif (!static_key_enabled(&page_reporting_enabled)) {\n\t\tstatic_branch_enable(&page_reporting_enabled);\n\t\tpr_info(\"Free page reporting enabled\\n\");\n\t}\nerr_out:\n\tmutex_unlock(&page_reporting_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(page_reporting_register);\n\nvoid page_reporting_unregister(struct page_reporting_dev_info *prdev)\n{\n\tmutex_lock(&page_reporting_mutex);\n\n\tif (prdev == rcu_dereference_protected(pr_dev_info,\n\t\t\t\tlockdep_is_held(&page_reporting_mutex))) {\n\t\t \n\t\tRCU_INIT_POINTER(pr_dev_info, NULL);\n\t\tsynchronize_rcu();\n\n\t\t \n\t\tcancel_delayed_work_sync(&prdev->work);\n\t}\n\n\tmutex_unlock(&page_reporting_mutex);\n}\nEXPORT_SYMBOL_GPL(page_reporting_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}