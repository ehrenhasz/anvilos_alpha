{
  "module_name": "shmem_quota.c",
  "hash_id": "e325158195784f7176a67ffc3d1dff635c99f87ae9dda355f3c3800c5ffdbfc5",
  "original_prompt": "Ingested from linux-6.6.14/mm/shmem_quota.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/shmem_fs.h>\n\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n\n#ifdef CONFIG_TMPFS_QUOTA\n\n \n#define SHMEM_MAX_IQ_TIME 604800\t \n#define SHMEM_MAX_DQ_TIME 604800\t \n\nstruct quota_id {\n\tstruct rb_node\tnode;\n\tqid_t\t\tid;\n\tqsize_t\t\tbhardlimit;\n\tqsize_t\t\tbsoftlimit;\n\tqsize_t\t\tihardlimit;\n\tqsize_t\t\tisoftlimit;\n};\n\nstatic int shmem_check_quota_file(struct super_block *sb, int type)\n{\n\t \n\treturn 1;\n}\n\n \nstatic int shmem_read_file_info(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct mem_dqinfo *info = &dqopt->info[type];\n\n\tinfo->dqi_priv = kzalloc(sizeof(struct rb_root), GFP_NOFS);\n\tif (!info->dqi_priv)\n\t\treturn -ENOMEM;\n\n\tinfo->dqi_max_spc_limit = SHMEM_QUOTA_MAX_SPC_LIMIT;\n\tinfo->dqi_max_ino_limit = SHMEM_QUOTA_MAX_INO_LIMIT;\n\n\tinfo->dqi_bgrace = SHMEM_MAX_DQ_TIME;\n\tinfo->dqi_igrace = SHMEM_MAX_IQ_TIME;\n\tinfo->dqi_flags = 0;\n\n\treturn 0;\n}\n\nstatic int shmem_write_file_info(struct super_block *sb, int type)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int shmem_free_file_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = &sb_dqopt(sb)->info[type];\n\tstruct rb_root *root = info->dqi_priv;\n\tstruct quota_id *entry;\n\tstruct rb_node *node;\n\n\tinfo->dqi_priv = NULL;\n\tnode = rb_first(root);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct quota_id, node);\n\t\tnode = rb_next(&entry->node);\n\n\t\trb_erase(&entry->node, root);\n\t\tkfree(entry);\n\t}\n\n\tkfree(root);\n\treturn 0;\n}\n\nstatic int shmem_get_next_id(struct super_block *sb, struct kqid *qid)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, qid->type);\n\tstruct rb_node *node = ((struct rb_root *)info->dqi_priv)->rb_node;\n\tqid_t id = from_kqid(&init_user_ns, *qid);\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct quota_id *entry = NULL;\n\tint ret = 0;\n\n\tif (!sb_has_quota_active(sb, qid->type))\n\t\treturn -ESRCH;\n\n\tdown_read(&dqopt->dqio_sem);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct quota_id, node);\n\n\t\tif (id < entry->id)\n\t\t\tnode = node->rb_left;\n\t\telse if (id > entry->id)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto got_next_id;\n\t}\n\n\tif (!entry) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (id > entry->id) {\n\t\tnode = rb_next(&entry->node);\n\t\tif (!node) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tentry = rb_entry(node, struct quota_id, node);\n\t}\n\ngot_next_id:\n\t*qid = make_kqid(&init_user_ns, qid->type, entry->id);\nout_unlock:\n\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\n \nstatic int shmem_acquire_dquot(struct dquot *dquot)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(dquot->dq_sb, dquot->dq_id.type);\n\tstruct rb_node **n = &((struct rb_root *)info->dqi_priv)->rb_node;\n\tstruct shmem_sb_info *sbinfo = dquot->dq_sb->s_fs_info;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\tstruct quota_id *new_entry, *entry;\n\tqid_t id = from_kqid(&init_user_ns, dquot->dq_id);\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\tint ret = 0;\n\n\tmutex_lock(&dquot->dq_lock);\n\n\tdown_write(&dqopt->dqio_sem);\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct quota_id, node);\n\n\t\tif (id < entry->id)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (id > entry->id)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t \n\tnew_entry = kzalloc(sizeof(struct quota_id), GFP_NOFS);\n\tif (!new_entry) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tnew_entry->id = id;\n\tif (dquot->dq_id.type == USRQUOTA) {\n\t\tnew_entry->bhardlimit = sbinfo->qlimits.usrquota_bhardlimit;\n\t\tnew_entry->ihardlimit = sbinfo->qlimits.usrquota_ihardlimit;\n\t} else if (dquot->dq_id.type == GRPQUOTA) {\n\t\tnew_entry->bhardlimit = sbinfo->qlimits.grpquota_bhardlimit;\n\t\tnew_entry->ihardlimit = sbinfo->qlimits.grpquota_ihardlimit;\n\t}\n\n\tnew_node = &new_entry->node;\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, (struct rb_root *)info->dqi_priv);\n\tentry = new_entry;\n\nfound:\n\t \n\tspin_lock(&dquot->dq_dqb_lock);\n\tdquot->dq_dqb.dqb_bhardlimit = entry->bhardlimit;\n\tdquot->dq_dqb.dqb_bsoftlimit = entry->bsoftlimit;\n\tdquot->dq_dqb.dqb_ihardlimit = entry->ihardlimit;\n\tdquot->dq_dqb.dqb_isoftlimit = entry->isoftlimit;\n\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dquot->dq_dqb_lock);\n\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_unlock:\n\tup_write(&dqopt->dqio_sem);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}\n\nstatic bool shmem_is_empty_dquot(struct dquot *dquot)\n{\n\tstruct shmem_sb_info *sbinfo = dquot->dq_sb->s_fs_info;\n\tqsize_t bhardlimit;\n\tqsize_t ihardlimit;\n\n\tif (dquot->dq_id.type == USRQUOTA) {\n\t\tbhardlimit = sbinfo->qlimits.usrquota_bhardlimit;\n\t\tihardlimit = sbinfo->qlimits.usrquota_ihardlimit;\n\t} else if (dquot->dq_id.type == GRPQUOTA) {\n\t\tbhardlimit = sbinfo->qlimits.grpquota_bhardlimit;\n\t\tihardlimit = sbinfo->qlimits.grpquota_ihardlimit;\n\t}\n\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\n\t\t(dquot->dq_dqb.dqb_curspace == 0 &&\n\t\t dquot->dq_dqb.dqb_curinodes == 0 &&\n\t\t dquot->dq_dqb.dqb_bhardlimit == bhardlimit &&\n\t\t dquot->dq_dqb.dqb_ihardlimit == ihardlimit))\n\t\treturn true;\n\n\treturn false;\n}\n \nstatic int shmem_release_dquot(struct dquot *dquot)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(dquot->dq_sb, dquot->dq_id.type);\n\tstruct rb_node *node = ((struct rb_root *)info->dqi_priv)->rb_node;\n\tqid_t id = from_kqid(&init_user_ns, dquot->dq_id);\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\tstruct quota_id *entry = NULL;\n\n\tmutex_lock(&dquot->dq_lock);\n\t \n\tif (dquot_is_busy(dquot))\n\t\tgoto out_dqlock;\n\n\tdown_write(&dqopt->dqio_sem);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct quota_id, node);\n\n\t\tif (id < entry->id)\n\t\t\tnode = node->rb_left;\n\t\telse if (id > entry->id)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t \n\tWARN_ONCE(1, \"quota id %u from dquot %p, not in rb tree!\\n\", id, dquot);\n\tup_write(&dqopt->dqio_sem);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn -ENOENT;\n\nfound:\n\tif (shmem_is_empty_dquot(dquot)) {\n\t\t \n\t\trb_erase(&entry->node, info->dqi_priv);\n\t\tkfree(entry);\n\t} else {\n\t\t \n\t\tspin_lock(&dquot->dq_dqb_lock);\n\t\tentry->bhardlimit = dquot->dq_dqb.dqb_bhardlimit;\n\t\tentry->bsoftlimit = dquot->dq_dqb.dqb_bsoftlimit;\n\t\tentry->ihardlimit = dquot->dq_dqb.dqb_ihardlimit;\n\t\tentry->isoftlimit = dquot->dq_dqb.dqb_isoftlimit;\n\t\tspin_unlock(&dquot->dq_dqb_lock);\n\t}\n\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tup_write(&dqopt->dqio_sem);\n\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn 0;\n}\n\nstatic int shmem_mark_dquot_dirty(struct dquot *dquot)\n{\n\treturn 0;\n}\n\nstatic int shmem_dquot_write_info(struct super_block *sb, int type)\n{\n\treturn 0;\n}\n\nstatic const struct quota_format_ops shmem_format_ops = {\n\t.check_quota_file\t= shmem_check_quota_file,\n\t.read_file_info\t\t= shmem_read_file_info,\n\t.write_file_info\t= shmem_write_file_info,\n\t.free_file_info\t\t= shmem_free_file_info,\n};\n\nstruct quota_format_type shmem_quota_format = {\n\t.qf_fmt_id = QFMT_SHMEM,\n\t.qf_ops = &shmem_format_ops,\n\t.qf_owner = THIS_MODULE\n};\n\nconst struct dquot_operations shmem_quota_operations = {\n\t.acquire_dquot\t\t= shmem_acquire_dquot,\n\t.release_dquot\t\t= shmem_release_dquot,\n\t.alloc_dquot\t\t= dquot_alloc,\n\t.destroy_dquot\t\t= dquot_destroy,\n\t.write_info\t\t= shmem_dquot_write_info,\n\t.mark_dirty\t\t= shmem_mark_dquot_dirty,\n\t.get_next_id\t\t= shmem_get_next_id,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}