{
  "module_name": "process_vm_access.c",
  "hash_id": "c56fb3076afd68fb80c02df21d982ba8976f6914159ffe730f5720af55288543",
  "original_prompt": "Ingested from linux-6.6.14/mm/process_vm_access.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/mm.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/highmem.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\n \nstatic int process_vm_rw_pages(struct page **pages,\n\t\t\t       unsigned offset,\n\t\t\t       size_t len,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       int vm_write)\n{\n\t \n\twhile (len && iov_iter_count(iter)) {\n\t\tstruct page *page = *pages++;\n\t\tsize_t copy = PAGE_SIZE - offset;\n\t\tsize_t copied;\n\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tif (vm_write)\n\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);\n\t\telse\n\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);\n\n\t\tlen -= copied;\n\t\tif (copied < copy && iov_iter_count(iter))\n\t\t\treturn -EFAULT;\n\t\toffset = 0;\n\t}\n\treturn 0;\n}\n\n \n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\n \nstatic int process_vm_rw_single_vec(unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    struct iov_iter *iter,\n\t\t\t\t    struct page **process_pages,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    struct task_struct *task,\n\t\t\t\t    int vm_write)\n{\n\tunsigned long pa = addr & PAGE_MASK;\n\tunsigned long start_offset = addr - pa;\n\tunsigned long nr_pages;\n\tssize_t rc = 0;\n\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES\n\t\t/ sizeof(struct pages *);\n\tunsigned int flags = 0;\n\n\t \n\tif (len == 0)\n\t\treturn 0;\n\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;\n\n\tif (vm_write)\n\t\tflags |= FOLL_WRITE;\n\n\twhile (!rc && nr_pages && iov_iter_count(iter)) {\n\t\tint pinned_pages = min(nr_pages, max_pages_per_loop);\n\t\tint locked = 1;\n\t\tsize_t bytes;\n\n\t\t \n\t\tmmap_read_lock(mm);\n\t\tpinned_pages = pin_user_pages_remote(mm, pa, pinned_pages,\n\t\t\t\t\t\t     flags, process_pages,\n\t\t\t\t\t\t     &locked);\n\t\tif (locked)\n\t\t\tmmap_read_unlock(mm);\n\t\tif (pinned_pages <= 0)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = pinned_pages * PAGE_SIZE - start_offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\trc = process_vm_rw_pages(process_pages,\n\t\t\t\t\t start_offset, bytes, iter,\n\t\t\t\t\t vm_write);\n\t\tlen -= bytes;\n\t\tstart_offset = 0;\n\t\tnr_pages -= pinned_pages;\n\t\tpa += pinned_pages * PAGE_SIZE;\n\n\t\t \n\t\tunpin_user_pages_dirty_lock(process_pages, pinned_pages,\n\t\t\t\t\t    vm_write);\n\t}\n\n\treturn rc;\n}\n\n \n#define PVM_MAX_PP_ARRAY_COUNT 16\n\n \nstatic ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t \n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t \n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t \n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t \n\ttotal_len -= iov_iter_count(iter);\n\n\t \n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}\n\n \nstatic ssize_t process_vm_rw(pid_t pid,\n\t\t\t     const struct iovec __user *lvec,\n\t\t\t     unsigned long liovcnt,\n\t\t\t     const struct iovec __user *rvec,\n\t\t\t     unsigned long riovcnt,\n\t\t\t     unsigned long flags, int vm_write)\n{\n\tstruct iovec iovstack_l[UIO_FASTIOV];\n\tstruct iovec iovstack_r[UIO_FASTIOV];\n\tstruct iovec *iov_l = iovstack_l;\n\tstruct iovec *iov_r;\n\tstruct iov_iter iter;\n\tssize_t rc;\n\tint dir = vm_write ? ITER_SOURCE : ITER_DEST;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\t \n\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!iov_iter_count(&iter))\n\t\tgoto free_iov_l;\n\tiov_r = iovec_from_user(rvec, riovcnt, UIO_FASTIOV, iovstack_r,\n\t\t\t\tin_compat_syscall());\n\tif (IS_ERR(iov_r)) {\n\t\trc = PTR_ERR(iov_r);\n\t\tgoto free_iov_l;\n\t}\n\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);\n\tif (iov_r != iovstack_r)\n\t\tkfree(iov_r);\nfree_iov_l:\n\tkfree(iov_l);\n\treturn rc;\n}\n\nSYSCALL_DEFINE6(process_vm_readv, pid_t, pid, const struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 0);\n}\n\nSYSCALL_DEFINE6(process_vm_writev, pid_t, pid,\n\t\tconst struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}