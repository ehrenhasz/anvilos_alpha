{
  "module_name": "page_vma_mapped.c",
  "hash_id": "9bf0cab3c49adbe7a5de0a13cc116687e006708929798bbfb3b52ece144cf7d3",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_vma_mapped.c",
  "human_readable_source": "\n#include <linux/mm.h>\n#include <linux/rmap.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n\n#include \"internal.h\"\n\nstatic inline bool not_found(struct page_vma_mapped_walk *pvmw)\n{\n\tpage_vma_mapped_walk_done(pvmw);\n\treturn false;\n}\n\nstatic bool map_pte(struct page_vma_mapped_walk *pvmw, spinlock_t **ptlp)\n{\n\tpte_t ptent;\n\n\tif (pvmw->flags & PVMW_SYNC) {\n\t\t \n\t\tpvmw->pte = pte_offset_map_lock(pvmw->vma->vm_mm, pvmw->pmd,\n\t\t\t\t\t\tpvmw->address, &pvmw->ptl);\n\t\t*ptlp = pvmw->ptl;\n\t\treturn !!pvmw->pte;\n\t}\n\n\t \n\tpvmw->pte = pte_offset_map_nolock(pvmw->vma->vm_mm, pvmw->pmd,\n\t\t\t\t\t  pvmw->address, ptlp);\n\tif (!pvmw->pte)\n\t\treturn false;\n\n\tptent = ptep_get(pvmw->pte);\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tif (!is_swap_pte(ptent))\n\t\t\treturn false;\n\t} else if (is_swap_pte(ptent)) {\n\t\tswp_entry_t entry;\n\t\t \n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!is_device_private_entry(entry) &&\n\t\t    !is_device_exclusive_entry(entry))\n\t\t\treturn false;\n\t} else if (!pte_present(ptent)) {\n\t\treturn false;\n\t}\n\tpvmw->ptl = *ptlp;\n\tspin_lock(pvmw->ptl);\n\treturn true;\n}\n\n \nstatic bool check_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tunsigned long pfn;\n\tpte_t ptent = ptep_get(pvmw->pte);\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tswp_entry_t entry;\n\t\tif (!is_swap_pte(ptent))\n\t\t\treturn false;\n\t\tentry = pte_to_swp_entry(ptent);\n\n\t\tif (!is_migration_entry(entry) &&\n\t\t    !is_device_exclusive_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = swp_offset_pfn(entry);\n\t} else if (is_swap_pte(ptent)) {\n\t\tswp_entry_t entry;\n\n\t\t \n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!is_device_private_entry(entry) &&\n\t\t    !is_device_exclusive_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = swp_offset_pfn(entry);\n\t} else {\n\t\tif (!pte_present(ptent))\n\t\t\treturn false;\n\n\t\tpfn = pte_pfn(ptent);\n\t}\n\n\treturn (pfn - pvmw->pfn) < pvmw->nr_pages;\n}\n\n \nstatic bool check_pmd(unsigned long pfn, struct page_vma_mapped_walk *pvmw)\n{\n\tif ((pfn + HPAGE_PMD_NR - 1) < pvmw->pfn)\n\t\treturn false;\n\tif (pfn > pvmw->pfn + pvmw->nr_pages - 1)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void step_forward(struct page_vma_mapped_walk *pvmw, unsigned long size)\n{\n\tpvmw->address = (pvmw->address + size) & ~(size - 1);\n\tif (!pvmw->address)\n\t\tpvmw->address = ULONG_MAX;\n}\n\n \nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long end;\n\tspinlock_t *ptl;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t \n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\tstruct hstate *hstate = hstate_vma(vma);\n\t\tunsigned long size = huge_page_size(hstate);\n\t\t \n\t\tif (pvmw->pte)\n\t\t\treturn not_found(pvmw);\n\t\t \n\t\tpvmw->pte = hugetlb_walk(vma, pvmw->address, size);\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lock(hstate, mm, pvmw->pte);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\n\n\tend = vma_address_end(pvmw);\n\tif (pvmw->pte)\n\t\tgoto next_pte;\nrestart:\n\tdo {\n\t\tpgd = pgd_offset(mm, pvmw->address);\n\t\tif (!pgd_present(*pgd)) {\n\t\t\tstep_forward(pvmw, PGDIR_SIZE);\n\t\t\tcontinue;\n\t\t}\n\t\tp4d = p4d_offset(pgd, pvmw->address);\n\t\tif (!p4d_present(*p4d)) {\n\t\t\tstep_forward(pvmw, P4D_SIZE);\n\t\t\tcontinue;\n\t\t}\n\t\tpud = pud_offset(p4d, pvmw->address);\n\t\tif (!pud_present(*pud)) {\n\t\t\tstep_forward(pvmw, PUD_SIZE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t\t \n\t\tpmde = pmdp_get_lockless(pvmw->pmd);\n\n\t\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde) ||\n\t\t    (pmd_present(pmde) && pmd_devmap(pmde))) {\n\t\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\t\tpmde = *pvmw->pmd;\n\t\t\tif (!pmd_present(pmde)) {\n\t\t\t\tswp_entry_t entry;\n\n\t\t\t\tif (!thp_migration_supported() ||\n\t\t\t\t    !(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tentry = pmd_to_swp_entry(pmde);\n\t\t\t\tif (!is_migration_entry(entry) ||\n\t\t\t\t    !check_pmd(swp_offset_pfn(entry), pvmw))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (likely(pmd_trans_huge(pmde) || pmd_devmap(pmde))) {\n\t\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (!check_pmd(pmd_pfn(pmde), pvmw))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t \n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t} else if (!pmd_present(pmde)) {\n\t\t\t \n\t\t\tif ((pvmw->flags & PVMW_SYNC) &&\n\t\t\t    transhuge_vma_suitable(vma, pvmw->address) &&\n\t\t\t    (pvmw->nr_pages >= HPAGE_PMD_NR)) {\n\t\t\t\tspinlock_t *ptl = pmd_lock(mm, pvmw->pmd);\n\n\t\t\t\tspin_unlock(ptl);\n\t\t\t}\n\t\t\tstep_forward(pvmw, PMD_SIZE);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!map_pte(pvmw, &ptl)) {\n\t\t\tif (!pvmw->pte)\n\t\t\t\tgoto restart;\n\t\t\tgoto next_pte;\n\t\t}\nthis_pte:\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= end)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t \n\t\t\tif ((pvmw->address & (PMD_SIZE - PAGE_SIZE)) == 0) {\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tpvmw->pte = NULL;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tpvmw->pte++;\n\t\t} while (pte_none(ptep_get(pvmw->pte)));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = ptl;\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t\tgoto this_pte;\n\t} while (pvmw->address < end);\n\n\treturn false;\n}\n\n \nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.pfn = page_to_pfn(page),\n\t\t.nr_pages = 1,\n\t\t.vma = vma,\n\t\t.flags = PVMW_SYNC,\n\t};\n\n\tpvmw.address = vma_address(page, vma);\n\tif (pvmw.address == -EFAULT)\n\t\treturn 0;\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\treturn 0;\n\tpage_vma_mapped_walk_done(&pvmw);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}