{
  "module_name": "fadvise.c",
  "hash_id": "dc635258ce43e9c6dc6df044ec14ccc58808e58db68bc2660f86a44b36029e02",
  "original_prompt": "Ingested from linux-6.6.14/mm/fadvise.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/backing-dev.h>\n#include <linux/fadvise.h>\n#include <linux/writeback.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n\n#include <asm/unistd.h>\n\n#include \"internal.h\"\n\n \n\nint generic_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tloff_t endbyte;\t\t\t \n\tpgoff_t start_index;\n\tpgoff_t end_index;\n\tunsigned long nrpages;\n\n\tinode = file_inode(file);\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tmapping = file->f_mapping;\n\tif (!mapping || len < 0)\n\t\treturn -EINVAL;\n\n\tbdi = inode_to_bdi(mapping->host);\n\n\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {\n\t\tswitch (advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\tcase POSIX_FADV_WILLNEED:\n\t\tcase POSIX_FADV_NOREUSE:\n\t\tcase POSIX_FADV_DONTNEED:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tendbyte = (u64)offset + (u64)len;\n\tif (!len || endbyte < len)\n\t\tendbyte = LLONG_MAX;\n\telse\n\t\tendbyte--;\t\t \n\n\tswitch (advice) {\n\tcase POSIX_FADV_NORMAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~(FMODE_RANDOM | FMODE_NOREUSE);\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_RANDOM:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_WILLNEED:\n\t\t \n\t\tstart_index = offset >> PAGE_SHIFT;\n\t\tend_index = endbyte >> PAGE_SHIFT;\n\n\t\t \n\t\tnrpages = end_index - start_index + 1;\n\t\tif (!nrpages)\n\t\t\tnrpages = ~0UL;\n\n\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);\n\t\tbreak;\n\tcase POSIX_FADV_NOREUSE:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_NOREUSE;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_DONTNEED:\n\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t   WB_SYNC_NONE);\n\n\t\t \n\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;\n\t\tend_index = (endbyte >> PAGE_SHIFT);\n\t\t \n\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&\n\t\t\t\tendbyte != inode->i_size - 1) {\n\t\t\t \n\t\t\tif (end_index == 0)\n\t\t\t\tbreak;\n\n\t\t\tend_index--;\n\t\t}\n\n\t\tif (end_index >= start_index) {\n\t\t\tunsigned long nr_failed = 0;\n\n\t\t\t \n\t\t\tlru_add_drain();\n\n\t\t\tmapping_try_invalidate(mapping, start_index, end_index,\n\t\t\t\t\t&nr_failed);\n\n\t\t\t \n\t\t\tif (nr_failed) {\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tinvalidate_mapping_pages(mapping, start_index,\n\t\t\t\t\t\tend_index);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(generic_fadvise);\n\nint vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}\nEXPORT_SYMBOL(vfs_fadvise);\n\n#ifdef CONFIG_ADVISE_SYSCALLS\n\nint ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice)\n{\n\tstruct fd f = fdget(fd);\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = vfs_fadvise(f.file, offset, len, advice);\n\n\tfdput(f);\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}\n\n#ifdef __ARCH_WANT_SYS_FADVISE64\n\nSYSCALL_DEFINE4(fadvise64, int, fd, loff_t, offset, size_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}\n\n#endif\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_FADVISE64_64)\n\nCOMPAT_SYSCALL_DEFINE6(fadvise64_64, int, fd, compat_arg_u64_dual(offset),\n\t\t       compat_arg_u64_dual(len), int, advice)\n{\n\treturn ksys_fadvise64_64(fd, compat_arg_u64_glue(offset),\n\t\t\t\t compat_arg_u64_glue(len), advice);\n}\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}