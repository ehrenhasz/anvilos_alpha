{
  "module_name": "page_io.c",
  "hash_id": "69319df80bab5895084187e6dc4f6a438a262aa9050993a7ec37b0962acd92e0",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_io.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/bio.h>\n#include <linux/swapops.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/psi.h>\n#include <linux/uio.h>\n#include <linux/sched/task.h>\n#include <linux/delayacct.h>\n#include <linux/zswap.h>\n#include \"swap.h\"\n\nstatic void __end_swap_bio_write(struct bio *bio)\n{\n\tstruct folio *folio = bio_first_folio_all(bio);\n\n\tif (bio->bi_status) {\n\t\t \n\t\tfolio_mark_dirty(folio);\n\t\tpr_alert_ratelimited(\"Write-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);\n\t\tfolio_clear_reclaim(folio);\n\t}\n\tfolio_end_writeback(folio);\n}\n\nstatic void end_swap_bio_write(struct bio *bio)\n{\n\t__end_swap_bio_write(bio);\n\tbio_put(bio);\n}\n\nstatic void __end_swap_bio_read(struct bio *bio)\n{\n\tstruct folio *folio = bio_first_folio_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert_ratelimited(\"Read-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);\n\t} else {\n\t\tfolio_mark_uptodate(folio);\n\t}\n\tfolio_unlock(folio);\n}\n\nstatic void end_swap_bio_read(struct bio *bio)\n{\n\t__end_swap_bio_read(bio);\n\tbio_put(bio);\n}\n\nint generic_swapfile_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file,\n\t\t\t\tsector_t *span)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tint nr_extents = 0;\n\tint ret;\n\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\n\t \n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block &&\n\t\t\tpage_no < sis->max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\n\t\tcond_resched();\n\n\t\tfirst_block = probe_block;\n\t\tret = bmap(inode, &first_block);\n\t\tif (ret || !first_block)\n\t\t\tgoto bad_bmap;\n\n\t\t \n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\n\t\t\tblock = probe_block + block_in_page;\n\t\t\tret = bmap(inode, &block);\n\t\t\tif (ret || !block)\n\t\t\t\tgoto bad_bmap;\n\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\t \n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t \n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\n\t\t \n\t\tret = add_swap_extent(sis, page_no, 1, first_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnr_extents += ret;\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\tret = nr_extents;\n\t*span = 1 + highest_block - lowest_block;\n\tif (page_no == 0)\n\t\tpage_no = 1;\t \n\tsis->max = page_no;\n\tsis->pages = page_no - 1;\n\tsis->highest_bit = page_no - 1;\nout:\n\treturn ret;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}\n\n \nint swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct folio *folio = page_folio(page);\n\tint ret;\n\n\tif (folio_free_swap(folio)) {\n\t\tfolio_unlock(folio);\n\t\treturn 0;\n\t}\n\t \n\tret = arch_prepare_to_swap(&folio->page);\n\tif (ret) {\n\t\tfolio_mark_dirty(folio);\n\t\tfolio_unlock(folio);\n\t\treturn ret;\n\t}\n\tif (zswap_store(folio)) {\n\t\tfolio_start_writeback(folio);\n\t\tfolio_unlock(folio);\n\t\tfolio_end_writeback(folio);\n\t\treturn 0;\n\t}\n\t__swap_writepage(&folio->page, wbc);\n\treturn 0;\n}\n\nstatic inline void count_swpout_vm_event(struct folio *folio)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (unlikely(folio_test_pmd_mappable(folio)))\n\t\tcount_vm_event(THP_SWPOUT);\n#endif\n\tcount_vm_events(PSWPOUT, folio_nr_pages(folio));\n}\n\n#if defined(CONFIG_MEMCG) && defined(CONFIG_BLK_CGROUP)\nstatic void bio_associate_blkg_from_page(struct bio *bio, struct folio *folio)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = folio_memcg(folio);\n\tif (!memcg)\n\t\treturn;\n\n\trcu_read_lock();\n\tcss = cgroup_e_css(memcg->css.cgroup, &io_cgrp_subsys);\n\tbio_associate_blkg_from_css(bio, css);\n\trcu_read_unlock();\n}\n#else\n#define bio_associate_blkg_from_page(bio, folio)\t\tdo { } while (0)\n#endif  \n\nstruct swap_iocb {\n\tstruct kiocb\t\tiocb;\n\tstruct bio_vec\t\tbvec[SWAP_CLUSTER_MAX];\n\tint\t\t\tpages;\n\tint\t\t\tlen;\n};\nstatic mempool_t *sio_pool;\n\nint sio_pool_init(void)\n{\n\tif (!sio_pool) {\n\t\tmempool_t *pool = mempool_create_kmalloc_pool(\n\t\t\tSWAP_CLUSTER_MAX, sizeof(struct swap_iocb));\n\t\tif (cmpxchg(&sio_pool, NULL, pool))\n\t\t\tmempool_destroy(pool);\n\t}\n\tif (!sio_pool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void sio_write_complete(struct kiocb *iocb, long ret)\n{\n\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);\n\tstruct page *page = sio->bvec[0].bv_page;\n\tint p;\n\n\tif (ret != sio->len) {\n\t\t \n\t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",\n\t\t\t\t   ret, page_file_offset(page));\n\t\tfor (p = 0; p < sio->pages; p++) {\n\t\t\tpage = sio->bvec[p].bv_page;\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t}\n\t} else {\n\t\tfor (p = 0; p < sio->pages; p++)\n\t\t\tcount_swpout_vm_event(page_folio(sio->bvec[p].bv_page));\n\t}\n\n\tfor (p = 0; p < sio->pages; p++)\n\t\tend_page_writeback(sio->bvec[p].bv_page);\n\n\tmempool_free(sio, sio_pool);\n}\n\nstatic void swap_writepage_fs(struct page *page, struct writeback_control *wbc)\n{\n\tstruct swap_iocb *sio = NULL;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tstruct file *swap_file = sis->swap_file;\n\tloff_t pos = page_file_offset(page);\n\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (wbc->swap_plug)\n\t\tsio = *wbc->swap_plug;\n\tif (sio) {\n\t\tif (sio->iocb.ki_filp != swap_file ||\n\t\t    sio->iocb.ki_pos + sio->len != pos) {\n\t\t\tswap_write_unplug(sio);\n\t\t\tsio = NULL;\n\t\t}\n\t}\n\tif (!sio) {\n\t\tsio = mempool_alloc(sio_pool, GFP_NOIO);\n\t\tinit_sync_kiocb(&sio->iocb, swap_file);\n\t\tsio->iocb.ki_complete = sio_write_complete;\n\t\tsio->iocb.ki_pos = pos;\n\t\tsio->pages = 0;\n\t\tsio->len = 0;\n\t}\n\tbvec_set_page(&sio->bvec[sio->pages], page, thp_size(page), 0);\n\tsio->len += thp_size(page);\n\tsio->pages += 1;\n\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !wbc->swap_plug) {\n\t\tswap_write_unplug(sio);\n\t\tsio = NULL;\n\t}\n\tif (wbc->swap_plug)\n\t\t*wbc->swap_plug = sio;\n}\n\nstatic void swap_writepage_bdev_sync(struct page *page,\n\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)\n{\n\tstruct bio_vec bv;\n\tstruct bio bio;\n\tstruct folio *folio = page_folio(page);\n\n\tbio_init(&bio, sis->bdev, &bv, 1,\n\t\t REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc));\n\tbio.bi_iter.bi_sector = swap_page_sector(page);\n\t__bio_add_page(&bio, page, thp_size(page), 0);\n\n\tbio_associate_blkg_from_page(&bio, folio);\n\tcount_swpout_vm_event(folio);\n\n\tfolio_start_writeback(folio);\n\tfolio_unlock(folio);\n\n\tsubmit_bio_wait(&bio);\n\t__end_swap_bio_write(&bio);\n}\n\nstatic void swap_writepage_bdev_async(struct page *page,\n\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)\n{\n\tstruct bio *bio;\n\tstruct folio *folio = page_folio(page);\n\n\tbio = bio_alloc(sis->bdev, 1,\n\t\t\tREQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc),\n\t\t\tGFP_NOIO);\n\tbio->bi_iter.bi_sector = swap_page_sector(page);\n\tbio->bi_end_io = end_swap_bio_write;\n\t__bio_add_page(bio, page, thp_size(page), 0);\n\n\tbio_associate_blkg_from_page(bio, folio);\n\tcount_swpout_vm_event(folio);\n\tfolio_start_writeback(folio);\n\tfolio_unlock(folio);\n\tsubmit_bio(bio);\n}\n\nvoid __swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t \n\tif (data_race(sis->flags & SWP_FS_OPS))\n\t\tswap_writepage_fs(page, wbc);\n\telse if (sis->flags & SWP_SYNCHRONOUS_IO)\n\t\tswap_writepage_bdev_sync(page, wbc, sis);\n\telse\n\t\tswap_writepage_bdev_async(page, wbc, sis);\n}\n\nvoid swap_write_unplug(struct swap_iocb *sio)\n{\n\tstruct iov_iter from;\n\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;\n\tint ret;\n\n\tiov_iter_bvec(&from, ITER_SOURCE, sio->bvec, sio->pages, sio->len);\n\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);\n\tif (ret != -EIOCBQUEUED)\n\t\tsio_write_complete(&sio->iocb, ret);\n}\n\nstatic void sio_read_complete(struct kiocb *iocb, long ret)\n{\n\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);\n\tint p;\n\n\tif (ret == sio->len) {\n\t\tfor (p = 0; p < sio->pages; p++) {\n\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);\n\n\t\t\tfolio_mark_uptodate(folio);\n\t\t\tfolio_unlock(folio);\n\t\t}\n\t\tcount_vm_events(PSWPIN, sio->pages);\n\t} else {\n\t\tfor (p = 0; p < sio->pages; p++) {\n\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);\n\n\t\t\tfolio_unlock(folio);\n\t\t}\n\t\tpr_alert_ratelimited(\"Read-error on swap-device\\n\");\n\t}\n\tmempool_free(sio, sio_pool);\n}\n\nstatic void swap_readpage_fs(struct page *page,\n\t\t\t     struct swap_iocb **plug)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tstruct swap_iocb *sio = NULL;\n\tloff_t pos = page_file_offset(page);\n\n\tif (plug)\n\t\tsio = *plug;\n\tif (sio) {\n\t\tif (sio->iocb.ki_filp != sis->swap_file ||\n\t\t    sio->iocb.ki_pos + sio->len != pos) {\n\t\t\tswap_read_unplug(sio);\n\t\t\tsio = NULL;\n\t\t}\n\t}\n\tif (!sio) {\n\t\tsio = mempool_alloc(sio_pool, GFP_KERNEL);\n\t\tinit_sync_kiocb(&sio->iocb, sis->swap_file);\n\t\tsio->iocb.ki_pos = pos;\n\t\tsio->iocb.ki_complete = sio_read_complete;\n\t\tsio->pages = 0;\n\t\tsio->len = 0;\n\t}\n\tbvec_set_page(&sio->bvec[sio->pages], page, thp_size(page), 0);\n\tsio->len += thp_size(page);\n\tsio->pages += 1;\n\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !plug) {\n\t\tswap_read_unplug(sio);\n\t\tsio = NULL;\n\t}\n\tif (plug)\n\t\t*plug = sio;\n}\n\nstatic void swap_readpage_bdev_sync(struct page *page,\n\t\tstruct swap_info_struct *sis)\n{\n\tstruct bio_vec bv;\n\tstruct bio bio;\n\n\tbio_init(&bio, sis->bdev, &bv, 1, REQ_OP_READ);\n\tbio.bi_iter.bi_sector = swap_page_sector(page);\n\t__bio_add_page(&bio, page, thp_size(page), 0);\n\t \n\tget_task_struct(current);\n\tcount_vm_event(PSWPIN);\n\tsubmit_bio_wait(&bio);\n\t__end_swap_bio_read(&bio);\n\tput_task_struct(current);\n}\n\nstatic void swap_readpage_bdev_async(struct page *page,\n\t\tstruct swap_info_struct *sis)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(sis->bdev, 1, REQ_OP_READ, GFP_KERNEL);\n\tbio->bi_iter.bi_sector = swap_page_sector(page);\n\tbio->bi_end_io = end_swap_bio_read;\n\t__bio_add_page(bio, page, thp_size(page), 0);\n\tcount_vm_event(PSWPIN);\n\tsubmit_bio(bio);\n}\n\nvoid swap_readpage(struct page *page, bool synchronous, struct swap_iocb **plug)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tbool workingset = folio_test_workingset(folio);\n\tunsigned long pflags;\n\tbool in_thrashing;\n\n\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio) && !synchronous, folio);\n\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n\tVM_BUG_ON_FOLIO(folio_test_uptodate(folio), folio);\n\n\t \n\tif (workingset) {\n\t\tdelayacct_thrashing_start(&in_thrashing);\n\t\tpsi_memstall_enter(&pflags);\n\t}\n\tdelayacct_swapin_start();\n\n\tif (zswap_load(folio)) {\n\t\tfolio_mark_uptodate(folio);\n\t\tfolio_unlock(folio);\n\t} else if (data_race(sis->flags & SWP_FS_OPS)) {\n\t\tswap_readpage_fs(page, plug);\n\t} else if (synchronous || (sis->flags & SWP_SYNCHRONOUS_IO)) {\n\t\tswap_readpage_bdev_sync(page, sis);\n\t} else {\n\t\tswap_readpage_bdev_async(page, sis);\n\t}\n\n\tif (workingset) {\n\t\tdelayacct_thrashing_end(&in_thrashing);\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\tdelayacct_swapin_end();\n}\n\nvoid __swap_read_unplug(struct swap_iocb *sio)\n{\n\tstruct iov_iter from;\n\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;\n\tint ret;\n\n\tiov_iter_bvec(&from, ITER_DEST, sio->bvec, sio->pages, sio->len);\n\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);\n\tif (ret != -EIOCBQUEUED)\n\t\tsio_read_complete(&sio->iocb, ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}