{
  "module_name": "ptdump.c",
  "hash_id": "7b18f342399b8f0cc3c510f09f933f360f2d1cf2453a07c0979236edca668ef5",
  "original_prompt": "Ingested from linux-6.6.14/mm/ptdump.c",
  "human_readable_source": "\n\n#include <linux/pagewalk.h>\n#include <linux/ptdump.h>\n#include <linux/kasan.h>\n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n \nstatic inline int note_kasan_page_table(struct mm_walk *walk,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct ptdump_state *st = walk->private;\n\n\tst->note_page(st, addr, 4, pte_val(kasan_early_shadow_pte[0]));\n\n\twalk->action = ACTION_CONTINUE;\n\n\treturn 0;\n}\n#endif\n\nstatic int ptdump_pgd_entry(pgd_t *pgd, unsigned long addr,\n\t\t\t    unsigned long next, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\tpgd_t val = READ_ONCE(*pgd);\n\n#if CONFIG_PGTABLE_LEVELS > 4 && \\\n\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))\n\tif (pgd_page(val) == virt_to_page(lm_alias(kasan_early_shadow_p4d)))\n\t\treturn note_kasan_page_table(walk, addr);\n#endif\n\n\tif (st->effective_prot)\n\t\tst->effective_prot(st, 0, pgd_val(val));\n\n\tif (pgd_leaf(val)) {\n\t\tst->note_page(st, addr, 0, pgd_val(val));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptdump_p4d_entry(p4d_t *p4d, unsigned long addr,\n\t\t\t    unsigned long next, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\tp4d_t val = READ_ONCE(*p4d);\n\n#if CONFIG_PGTABLE_LEVELS > 3 && \\\n\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))\n\tif (p4d_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pud)))\n\t\treturn note_kasan_page_table(walk, addr);\n#endif\n\n\tif (st->effective_prot)\n\t\tst->effective_prot(st, 1, p4d_val(val));\n\n\tif (p4d_leaf(val)) {\n\t\tst->note_page(st, addr, 1, p4d_val(val));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptdump_pud_entry(pud_t *pud, unsigned long addr,\n\t\t\t    unsigned long next, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\tpud_t val = READ_ONCE(*pud);\n\n#if CONFIG_PGTABLE_LEVELS > 2 && \\\n\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))\n\tif (pud_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pmd)))\n\t\treturn note_kasan_page_table(walk, addr);\n#endif\n\n\tif (st->effective_prot)\n\t\tst->effective_prot(st, 2, pud_val(val));\n\n\tif (pud_leaf(val)) {\n\t\tst->note_page(st, addr, 2, pud_val(val));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptdump_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\t\t    unsigned long next, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\tpmd_t val = READ_ONCE(*pmd);\n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n\tif (pmd_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pte)))\n\t\treturn note_kasan_page_table(walk, addr);\n#endif\n\n\tif (st->effective_prot)\n\t\tst->effective_prot(st, 3, pmd_val(val));\n\tif (pmd_leaf(val)) {\n\t\tst->note_page(st, addr, 3, pmd_val(val));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptdump_pte_entry(pte_t *pte, unsigned long addr,\n\t\t\t    unsigned long next, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\tpte_t val = ptep_get_lockless(pte);\n\n\tif (st->effective_prot)\n\t\tst->effective_prot(st, 4, pte_val(val));\n\n\tst->note_page(st, addr, 4, pte_val(val));\n\n\treturn 0;\n}\n\nstatic int ptdump_hole(unsigned long addr, unsigned long next,\n\t\t       int depth, struct mm_walk *walk)\n{\n\tstruct ptdump_state *st = walk->private;\n\n\tst->note_page(st, addr, depth, 0);\n\n\treturn 0;\n}\n\nstatic const struct mm_walk_ops ptdump_ops = {\n\t.pgd_entry\t= ptdump_pgd_entry,\n\t.p4d_entry\t= ptdump_p4d_entry,\n\t.pud_entry\t= ptdump_pud_entry,\n\t.pmd_entry\t= ptdump_pmd_entry,\n\t.pte_entry\t= ptdump_pte_entry,\n\t.pte_hole\t= ptdump_hole,\n};\n\nvoid ptdump_walk_pgd(struct ptdump_state *st, struct mm_struct *mm, pgd_t *pgd)\n{\n\tconst struct ptdump_range *range = st->range;\n\n\tmmap_write_lock(mm);\n\twhile (range->start != range->end) {\n\t\twalk_page_range_novma(mm, range->start, range->end,\n\t\t\t\t      &ptdump_ops, pgd, st);\n\t\trange++;\n\t}\n\tmmap_write_unlock(mm);\n\n\t \n\tst->note_page(st, 0, -1, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}