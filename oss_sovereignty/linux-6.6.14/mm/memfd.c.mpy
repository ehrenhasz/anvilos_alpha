{
  "module_name": "memfd.c",
  "hash_id": "62c95ad75ebfe69fc7ec68bd0ce03a4ed8a472466c66426ff0a008b5fd0f4349",
  "original_prompt": "Ingested from linux-6.6.14/mm/memfd.c",
  "human_readable_source": " \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/khugepaged.h>\n#include <linux/syscalls.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/memfd.h>\n#include <linux/pid_namespace.h>\n#include <uapi/linux/memfd.h>\n\n \n#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE\n#define LAST_SCAN               4        \n\nstatic void memfd_tag_pins(struct xa_state *xas)\n{\n\tstruct page *page;\n\tint latency = 0;\n\tint cache_count;\n\n\tlru_add_drain();\n\n\txas_lock_irq(xas);\n\txas_for_each(xas, page, ULONG_MAX) {\n\t\tcache_count = 1;\n\t\tif (!xa_is_value(page) &&\n\t\t    PageTransHuge(page) && !PageHuge(page))\n\t\t\tcache_count = HPAGE_PMD_NR;\n\n\t\tif (!xa_is_value(page) &&\n\t\t    page_count(page) - total_mapcount(page) != cache_count)\n\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);\n\t\tif (cache_count != 1)\n\t\t\txas_set(xas, page->index + cache_count);\n\n\t\tlatency += cache_count;\n\t\tif (latency < XA_CHECK_SCHED)\n\t\t\tcontinue;\n\t\tlatency = 0;\n\n\t\txas_pause(xas);\n\t\txas_unlock_irq(xas);\n\t\tcond_resched();\n\t\txas_lock_irq(xas);\n\t}\n\txas_unlock_irq(xas);\n}\n\n \nstatic int memfd_wait_for_pins(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tint error, scan;\n\n\tmemfd_tag_pins(&xas);\n\n\terror = 0;\n\tfor (scan = 0; scan <= LAST_SCAN; scan++) {\n\t\tint latency = 0;\n\t\tint cache_count;\n\n\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))\n\t\t\tbreak;\n\n\t\tif (!scan)\n\t\t\tlru_add_drain_all();\n\t\telse if (schedule_timeout_killable((HZ << scan) / 200))\n\t\t\tscan = LAST_SCAN;\n\n\t\txas_set(&xas, 0);\n\t\txas_lock_irq(&xas);\n\t\txas_for_each_marked(&xas, page, ULONG_MAX, MEMFD_TAG_PINNED) {\n\t\t\tbool clear = true;\n\n\t\t\tcache_count = 1;\n\t\t\tif (!xa_is_value(page) &&\n\t\t\t    PageTransHuge(page) && !PageHuge(page))\n\t\t\t\tcache_count = HPAGE_PMD_NR;\n\n\t\t\tif (!xa_is_value(page) && cache_count !=\n\t\t\t    page_count(page) - total_mapcount(page)) {\n\t\t\t\t \n\t\t\t\tif (scan == LAST_SCAN)\n\t\t\t\t\terror = -EBUSY;\n\t\t\t\telse\n\t\t\t\t\tclear = false;\n\t\t\t}\n\t\t\tif (clear)\n\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);\n\n\t\t\tlatency += cache_count;\n\t\t\tif (latency < XA_CHECK_SCHED)\n\t\t\t\tcontinue;\n\t\t\tlatency = 0;\n\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcond_resched();\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\txas_unlock_irq(&xas);\n\t}\n\n\treturn error;\n}\n\nstatic unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}\n\n#define F_ALL_SEALS (F_SEAL_SEAL | \\\n\t\t     F_SEAL_EXEC | \\\n\t\t     F_SEAL_SHRINK | \\\n\t\t     F_SEAL_GROW | \\\n\t\t     F_SEAL_WRITE | \\\n\t\t     F_SEAL_FUTURE_WRITE)\n\nstatic int memfd_add_seals(struct file *file, unsigned int seals)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int *file_seals;\n\tint error;\n\n\t \n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\tif (seals & ~(unsigned int)F_ALL_SEALS)\n\t\treturn -EINVAL;\n\n\tinode_lock(inode);\n\n\tfile_seals = memfd_file_seals_ptr(file);\n\tif (!file_seals) {\n\t\terror = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (*file_seals & F_SEAL_SEAL) {\n\t\terror = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {\n\t\terror = mapping_deny_writable(file->f_mapping);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\terror = memfd_wait_for_pins(file->f_mapping);\n\t\tif (error) {\n\t\t\tmapping_allow_writable(file->f_mapping);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)\n\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;\n\n\t*file_seals |= seals;\n\terror = 0;\n\nunlock:\n\tinode_unlock(inode);\n\treturn error;\n}\n\nstatic int memfd_get_seals(struct file *file)\n{\n\tunsigned int *seals = memfd_file_seals_ptr(file);\n\n\treturn seals ? *seals : -EINVAL;\n}\n\nlong memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)\n{\n\tlong error;\n\n\tswitch (cmd) {\n\tcase F_ADD_SEALS:\n\t\terror = memfd_add_seals(file, arg);\n\t\tbreak;\n\tcase F_GET_SEALS:\n\t\terror = memfd_get_seals(file);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}\n\n#define MFD_NAME_PREFIX \"memfd:\"\n#define MFD_NAME_PREFIX_LEN (sizeof(MFD_NAME_PREFIX) - 1)\n#define MFD_NAME_MAX_LEN (NAME_MAX - MFD_NAME_PREFIX_LEN)\n\n#define MFD_ALL_FLAGS (MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_HUGETLB | MFD_NOEXEC_SEAL | MFD_EXEC)\n\nstatic int check_sysctl_memfd_noexec(unsigned int *flags)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\tint sysctl = pidns_memfd_noexec_scope(ns);\n\n\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {\n\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)\n\t\t\t*flags |= MFD_NOEXEC_SEAL;\n\t\telse\n\t\t\t*flags |= MFD_EXEC;\n\t}\n\n\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {\n\t\tpr_err_ratelimited(\n\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), sysctl);\n\t\treturn -EACCES;\n\t}\n#endif\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(memfd_create,\n\t\tconst char __user *, uname,\n\t\tunsigned int, flags)\n{\n\tunsigned int *file_seals;\n\tstruct file *file;\n\tint fd, error;\n\tchar *name;\n\tlong len;\n\n\tif (!(flags & MFD_HUGETLB)) {\n\t\tif (flags & ~(unsigned int)MFD_ALL_FLAGS)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (flags & ~(unsigned int)(MFD_ALL_FLAGS |\n\t\t\t\t(MFD_HUGE_MASK << MFD_HUGE_SHIFT)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((flags & MFD_EXEC) && (flags & MFD_NOEXEC_SEAL))\n\t\treturn -EINVAL;\n\n\tif (!(flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {\n\t\tpr_warn_once(\n\t\t\t\"%s[%d]: memfd_create() called without MFD_EXEC or MFD_NOEXEC_SEAL set\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\n\terror = check_sysctl_memfd_noexec(&flags);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tlen = strnlen_user(uname, MFD_NAME_MAX_LEN + 1);\n\tif (len <= 0)\n\t\treturn -EFAULT;\n\tif (len > MFD_NAME_MAX_LEN + 1)\n\t\treturn -EINVAL;\n\n\tname = kmalloc(len + MFD_NAME_PREFIX_LEN, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tstrcpy(name, MFD_NAME_PREFIX);\n\tif (copy_from_user(&name[MFD_NAME_PREFIX_LEN], uname, len)) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\t \n\tif (name[len + MFD_NAME_PREFIX_LEN - 1]) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\tfd = get_unused_fd_flags((flags & MFD_CLOEXEC) ? O_CLOEXEC : 0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto err_name;\n\t}\n\n\tif (flags & MFD_HUGETLB) {\n\t\tfile = hugetlb_file_setup(name, 0, VM_NORESERVE,\n\t\t\t\t\tHUGETLB_ANONHUGE_INODE,\n\t\t\t\t\t(flags >> MFD_HUGE_SHIFT) &\n\t\t\t\t\tMFD_HUGE_MASK);\n\t} else\n\t\tfile = shmem_file_setup(name, 0, VM_NORESERVE);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_fd;\n\t}\n\tfile->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tfile->f_flags |= O_LARGEFILE;\n\n\tif (flags & MFD_NOEXEC_SEAL) {\n\t\tstruct inode *inode = file_inode(file);\n\n\t\tinode->i_mode &= ~0111;\n\t\tfile_seals = memfd_file_seals_ptr(file);\n\t\tif (file_seals) {\n\t\t\t*file_seals &= ~F_SEAL_SEAL;\n\t\t\t*file_seals |= F_SEAL_EXEC;\n\t\t}\n\t} else if (flags & MFD_ALLOW_SEALING) {\n\t\t \n\t\tfile_seals = memfd_file_seals_ptr(file);\n\t\tif (file_seals)\n\t\t\t*file_seals &= ~F_SEAL_SEAL;\n\t}\n\n\tfd_install(fd, file);\n\tkfree(name);\n\treturn fd;\n\nerr_fd:\n\tput_unused_fd(fd);\nerr_name:\n\tkfree(name);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}