{
  "module_name": "quarantine.c",
  "hash_id": "2daf25e8c0074f2d069d65d6449e79f70a7793b697a0e8cf41b65aa9531b458f",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/quarantine.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/hash.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/percpu.h>\n#include <linux/printk.h>\n#include <linux/shrinker.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/cpuhotplug.h>\n\n#include \"../slab.h\"\n#include \"kasan.h\"\n\n \n\n \nstruct qlist_head {\n\tstruct qlist_node *head;\n\tstruct qlist_node *tail;\n\tsize_t bytes;\n\tbool offline;\n};\n\n#define QLIST_INIT { NULL, NULL, 0 }\n\nstatic bool qlist_empty(struct qlist_head *q)\n{\n\treturn !q->head;\n}\n\nstatic void qlist_init(struct qlist_head *q)\n{\n\tq->head = q->tail = NULL;\n\tq->bytes = 0;\n}\n\nstatic void qlist_put(struct qlist_head *q, struct qlist_node *qlink,\n\t\tsize_t size)\n{\n\tif (unlikely(qlist_empty(q)))\n\t\tq->head = qlink;\n\telse\n\t\tq->tail->next = qlink;\n\tq->tail = qlink;\n\tqlink->next = NULL;\n\tq->bytes += size;\n}\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}\n\n#define QUARANTINE_PERCPU_SIZE (1 << 20)\n#define QUARANTINE_BATCHES \\\n\t(1024 > 4 * CONFIG_NR_CPUS ? 1024 : 4 * CONFIG_NR_CPUS)\n\n \nstatic DEFINE_PER_CPU(struct qlist_head, cpu_quarantine);\n\n \nstatic struct qlist_head global_quarantine[QUARANTINE_BATCHES];\nstatic int quarantine_head;\nstatic int quarantine_tail;\n \nstatic unsigned long quarantine_size;\nstatic DEFINE_RAW_SPINLOCK(quarantine_lock);\nDEFINE_STATIC_SRCU(remove_cache_srcu);\n\nstruct cpu_shrink_qlist {\n\traw_spinlock_t lock;\n\tstruct qlist_head qlist;\n};\n\nstatic DEFINE_PER_CPU(struct cpu_shrink_qlist, shrink_qlist) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(shrink_qlist.lock),\n};\n\n \nstatic unsigned long quarantine_max_size;\n\n \nstatic unsigned long quarantine_batch_size;\n\n \n#define QUARANTINE_FRACTION 32\n\nstatic struct kmem_cache *qlink_to_cache(struct qlist_node *qlink)\n{\n\treturn virt_to_slab(qlink)->slab_cache;\n}\n\nstatic void *qlink_to_object(struct qlist_node *qlink, struct kmem_cache *cache)\n{\n\tstruct kasan_free_meta *free_info =\n\t\tcontainer_of(qlink, struct kasan_free_meta,\n\t\t\t     quarantine_link);\n\n\treturn ((void *)free_info) - cache->kasan_info.free_meta_offset;\n}\n\nstatic void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)\n{\n\tvoid *object = qlink_to_object(qlink, cache);\n\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);\n\tunsigned long flags;\n\n\tif (IS_ENABLED(CONFIG_SLAB))\n\t\tlocal_irq_save(flags);\n\n\t \n\tif (slab_want_init_on_free(cache) &&\n\t    cache->kasan_info.free_meta_offset == 0)\n\t\tmemzero_explicit(meta, sizeof(*meta));\n\n\t \n\t*(u8 *)kasan_mem_to_shadow(object) = KASAN_SLAB_FREE;\n\n\t___cache_free(cache, object, _THIS_IP_);\n\n\tif (IS_ENABLED(CONFIG_SLAB))\n\t\tlocal_irq_restore(flags);\n}\n\nstatic void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)\n{\n\tstruct qlist_node *qlink;\n\n\tif (unlikely(qlist_empty(q)))\n\t\treturn;\n\n\tqlink = q->head;\n\twhile (qlink) {\n\t\tstruct kmem_cache *obj_cache =\n\t\t\tcache ? cache :\tqlink_to_cache(qlink);\n\t\tstruct qlist_node *next = qlink->next;\n\n\t\tqlink_free(qlink, obj_cache);\n\t\tqlink = next;\n\t}\n\tqlist_init(q);\n}\n\nbool kasan_quarantine_put(struct kmem_cache *cache, void *object)\n{\n\tunsigned long flags;\n\tstruct qlist_head *q;\n\tstruct qlist_head temp = QLIST_INIT;\n\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);\n\n\t \n\tif (!meta)\n\t\treturn false;\n\n\t \n\tlocal_irq_save(flags);\n\n\tq = this_cpu_ptr(&cpu_quarantine);\n\tif (q->offline) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false;\n\t}\n\tqlist_put(q, &meta->quarantine_link, cache->size);\n\tif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE)) {\n\t\tqlist_move_all(q, &temp);\n\n\t\traw_spin_lock(&quarantine_lock);\n\t\tWRITE_ONCE(quarantine_size, quarantine_size + temp.bytes);\n\t\tqlist_move_all(&temp, &global_quarantine[quarantine_tail]);\n\t\tif (global_quarantine[quarantine_tail].bytes >=\n\t\t\t\tREAD_ONCE(quarantine_batch_size)) {\n\t\t\tint new_tail;\n\n\t\t\tnew_tail = quarantine_tail + 1;\n\t\t\tif (new_tail == QUARANTINE_BATCHES)\n\t\t\t\tnew_tail = 0;\n\t\t\tif (new_tail != quarantine_head)\n\t\t\t\tquarantine_tail = new_tail;\n\t\t}\n\t\traw_spin_unlock(&quarantine_lock);\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn true;\n}\n\nvoid kasan_quarantine_reduce(void)\n{\n\tsize_t total_size, new_quarantine_size, percpu_quarantines;\n\tunsigned long flags;\n\tint srcu_idx;\n\tstruct qlist_head to_free = QLIST_INIT;\n\n\tif (likely(READ_ONCE(quarantine_size) <=\n\t\t   READ_ONCE(quarantine_max_size)))\n\t\treturn;\n\n\t \n\tsrcu_idx = srcu_read_lock(&remove_cache_srcu);\n\traw_spin_lock_irqsave(&quarantine_lock, flags);\n\n\t \n\ttotal_size = (totalram_pages() << PAGE_SHIFT) /\n\t\tQUARANTINE_FRACTION;\n\tpercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();\n\tnew_quarantine_size = (total_size < percpu_quarantines) ?\n\t\t0 : total_size - percpu_quarantines;\n\tWRITE_ONCE(quarantine_max_size, new_quarantine_size);\n\t \n\tWRITE_ONCE(quarantine_batch_size, max((size_t)QUARANTINE_PERCPU_SIZE,\n\t\t2 * total_size / QUARANTINE_BATCHES));\n\n\tif (likely(quarantine_size > quarantine_max_size)) {\n\t\tqlist_move_all(&global_quarantine[quarantine_head], &to_free);\n\t\tWRITE_ONCE(quarantine_size, quarantine_size - to_free.bytes);\n\t\tquarantine_head++;\n\t\tif (quarantine_head == QUARANTINE_BATCHES)\n\t\t\tquarantine_head = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&quarantine_lock, flags);\n\n\tqlist_free_all(&to_free, NULL);\n\tsrcu_read_unlock(&remove_cache_srcu, srcu_idx);\n}\n\nstatic void qlist_move_cache(struct qlist_head *from,\n\t\t\t\t   struct qlist_head *to,\n\t\t\t\t   struct kmem_cache *cache)\n{\n\tstruct qlist_node *curr;\n\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tcurr = from->head;\n\tqlist_init(from);\n\twhile (curr) {\n\t\tstruct qlist_node *next = curr->next;\n\t\tstruct kmem_cache *obj_cache = qlink_to_cache(curr);\n\n\t\tif (obj_cache == cache)\n\t\t\tqlist_put(to, curr, obj_cache->size);\n\t\telse\n\t\t\tqlist_put(from, curr, obj_cache->size);\n\n\t\tcurr = next;\n\t}\n}\n\nstatic void __per_cpu_remove_cache(struct qlist_head *q, void *arg)\n{\n\tstruct kmem_cache *cache = arg;\n\tunsigned long flags;\n\tstruct cpu_shrink_qlist *sq;\n\n\tsq = this_cpu_ptr(&shrink_qlist);\n\traw_spin_lock_irqsave(&sq->lock, flags);\n\tqlist_move_cache(q, &sq->qlist, cache);\n\traw_spin_unlock_irqrestore(&sq->lock, flags);\n}\n\nstatic void per_cpu_remove_cache(void *arg)\n{\n\tstruct qlist_head *q;\n\n\tq = this_cpu_ptr(&cpu_quarantine);\n\t \n\tif (READ_ONCE(q->offline))\n\t\treturn;\n\t__per_cpu_remove_cache(q, arg);\n}\n\n \nvoid kasan_quarantine_remove_cache(struct kmem_cache *cache)\n{\n\tunsigned long flags, i;\n\tstruct qlist_head to_free = QLIST_INIT;\n\tint cpu;\n\tstruct cpu_shrink_qlist *sq;\n\n\t \n\ton_each_cpu(per_cpu_remove_cache, cache, 1);\n\n\tfor_each_online_cpu(cpu) {\n\t\tsq = per_cpu_ptr(&shrink_qlist, cpu);\n\t\traw_spin_lock_irqsave(&sq->lock, flags);\n\t\tqlist_move_cache(&sq->qlist, &to_free, cache);\n\t\traw_spin_unlock_irqrestore(&sq->lock, flags);\n\t}\n\tqlist_free_all(&to_free, cache);\n\n\traw_spin_lock_irqsave(&quarantine_lock, flags);\n\tfor (i = 0; i < QUARANTINE_BATCHES; i++) {\n\t\tif (qlist_empty(&global_quarantine[i]))\n\t\t\tcontinue;\n\t\tqlist_move_cache(&global_quarantine[i], &to_free, cache);\n\t\t \n\t\traw_spin_unlock_irqrestore(&quarantine_lock, flags);\n\t\tcond_resched();\n\t\traw_spin_lock_irqsave(&quarantine_lock, flags);\n\t}\n\traw_spin_unlock_irqrestore(&quarantine_lock, flags);\n\n\tqlist_free_all(&to_free, cache);\n\n\tsynchronize_srcu(&remove_cache_srcu);\n}\n\nstatic int kasan_cpu_online(unsigned int cpu)\n{\n\tthis_cpu_ptr(&cpu_quarantine)->offline = false;\n\treturn 0;\n}\n\nstatic int kasan_cpu_offline(unsigned int cpu)\n{\n\tstruct qlist_head *q;\n\n\tq = this_cpu_ptr(&cpu_quarantine);\n\t \n\tWRITE_ONCE(q->offline, true);\n\tbarrier();\n\tqlist_free_all(q, NULL);\n\treturn 0;\n}\n\nstatic int __init kasan_cpu_quarantine_init(void)\n{\n\tint ret = 0;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/kasan:online\",\n\t\t\t\tkasan_cpu_online, kasan_cpu_offline);\n\tif (ret < 0)\n\t\tpr_err(\"kasan cpu quarantine register failed [%d]\\n\", ret);\n\treturn ret;\n}\nlate_initcall(kasan_cpu_quarantine_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}