{
  "module_name": "report.c",
  "hash_id": "d11120cc83a51e880b60fd727708bc3cc20c99c42b56af20f9f60ec8afec2518",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/report.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <linux/bitops.h>\n#include <linux/ftrace.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/lockdep.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/stackdepot.h>\n#include <linux/stacktrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kasan.h>\n#include <linux/module.h>\n#include <linux/sched/task_stack.h>\n#include <linux/uaccess.h>\n#include <trace/events/error_report.h>\n\n#include <asm/sections.h>\n\n#include \"kasan.h\"\n#include \"../slab.h\"\n\nstatic unsigned long kasan_flags;\n\n#define KASAN_BIT_REPORTED\t0\n#define KASAN_BIT_MULTI_SHOT\t1\n\nenum kasan_arg_fault {\n\tKASAN_ARG_FAULT_DEFAULT,\n\tKASAN_ARG_FAULT_REPORT,\n\tKASAN_ARG_FAULT_PANIC,\n\tKASAN_ARG_FAULT_PANIC_ON_WRITE,\n};\n\nstatic enum kasan_arg_fault kasan_arg_fault __ro_after_init = KASAN_ARG_FAULT_DEFAULT;\n\n \nstatic int __init early_kasan_fault(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(arg, \"report\"))\n\t\tkasan_arg_fault = KASAN_ARG_FAULT_REPORT;\n\telse if (!strcmp(arg, \"panic\"))\n\t\tkasan_arg_fault = KASAN_ARG_FAULT_PANIC;\n\telse if (!strcmp(arg, \"panic_on_write\"))\n\t\tkasan_arg_fault = KASAN_ARG_FAULT_PANIC_ON_WRITE;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"kasan.fault\", early_kasan_fault);\n\nstatic int __init kasan_set_multi_shot(char *str)\n{\n\tset_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);\n\treturn 1;\n}\n__setup(\"kasan_multi_shot\", kasan_set_multi_shot);\n\n \nstatic bool report_suppressed_sw(void)\n{\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n\tif (current->kasan_depth)\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic void report_suppress_start(void)\n{\n#ifdef CONFIG_KASAN_HW_TAGS\n\t \n\tpreempt_disable();\n\thw_suppress_tag_checks_start();\n#else\n\tkasan_disable_current();\n#endif\n}\n\nstatic void report_suppress_stop(void)\n{\n#ifdef CONFIG_KASAN_HW_TAGS\n\thw_suppress_tag_checks_stop();\n\tpreempt_enable();\n#else\n\tkasan_enable_current();\n#endif\n}\n\n \nstatic bool report_enabled(void)\n{\n\tif (test_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags))\n\t\treturn true;\n\treturn !test_and_set_bit(KASAN_BIT_REPORTED, &kasan_flags);\n}\n\n#if IS_ENABLED(CONFIG_KASAN_KUNIT_TEST) || IS_ENABLED(CONFIG_KASAN_MODULE_TEST)\n\nbool kasan_save_enable_multi_shot(void)\n{\n\treturn test_and_set_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);\n}\nEXPORT_SYMBOL_GPL(kasan_save_enable_multi_shot);\n\nvoid kasan_restore_multi_shot(bool enabled)\n{\n\tif (!enabled)\n\t\tclear_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);\n}\nEXPORT_SYMBOL_GPL(kasan_restore_multi_shot);\n\n#endif\n\n#if IS_ENABLED(CONFIG_KASAN_KUNIT_TEST)\n\n \nstatic bool kasan_kunit_executing;\n\nvoid kasan_kunit_test_suite_start(void)\n{\n\tWRITE_ONCE(kasan_kunit_executing, true);\n}\nEXPORT_SYMBOL_GPL(kasan_kunit_test_suite_start);\n\nvoid kasan_kunit_test_suite_end(void)\n{\n\tWRITE_ONCE(kasan_kunit_executing, false);\n}\nEXPORT_SYMBOL_GPL(kasan_kunit_test_suite_end);\n\nstatic bool kasan_kunit_test_suite_executing(void)\n{\n\treturn READ_ONCE(kasan_kunit_executing);\n}\n\n#else  \n\nstatic inline bool kasan_kunit_test_suite_executing(void) { return false; }\n\n#endif  \n\n#if IS_ENABLED(CONFIG_KUNIT)\n\nstatic void fail_non_kasan_kunit_test(void)\n{\n\tstruct kunit *test;\n\n\tif (kasan_kunit_test_suite_executing())\n\t\treturn;\n\n\ttest = current->kunit_test;\n\tif (test)\n\t\tkunit_set_failure(test);\n}\n\n#else  \n\nstatic inline void fail_non_kasan_kunit_test(void) { }\n\n#endif  \n\nstatic DEFINE_SPINLOCK(report_lock);\n\nstatic void start_report(unsigned long *flags, bool sync)\n{\n\tfail_non_kasan_kunit_test();\n\t \n\tdisable_trace_on_warning();\n\t \n\tlockdep_off();\n\t \n\treport_suppress_start();\n\tspin_lock_irqsave(&report_lock, *flags);\n\tpr_err(\"==================================================================\\n\");\n}\n\nstatic void end_report(unsigned long *flags, const void *addr, bool is_write)\n{\n\tif (addr)\n\t\ttrace_error_report_end(ERROR_DETECTOR_KASAN,\n\t\t\t\t       (unsigned long)addr);\n\tpr_err(\"==================================================================\\n\");\n\tspin_unlock_irqrestore(&report_lock, *flags);\n\tif (!test_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags))\n\t\tcheck_panic_on_warn(\"KASAN\");\n\tswitch (kasan_arg_fault) {\n\tcase KASAN_ARG_FAULT_DEFAULT:\n\tcase KASAN_ARG_FAULT_REPORT:\n\t\tbreak;\n\tcase KASAN_ARG_FAULT_PANIC:\n\t\tpanic(\"kasan.fault=panic set ...\\n\");\n\t\tbreak;\n\tcase KASAN_ARG_FAULT_PANIC_ON_WRITE:\n\t\tif (is_write)\n\t\t\tpanic(\"kasan.fault=panic_on_write set ...\\n\");\n\t\tbreak;\n\t}\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tlockdep_on();\n\treport_suppress_stop();\n}\n\nstatic void print_error_description(struct kasan_report_info *info)\n{\n\tpr_err(\"BUG: KASAN: %s in %pS\\n\", info->bug_type, (void *)info->ip);\n\n\tif (info->type != KASAN_REPORT_ACCESS) {\n\t\tpr_err(\"Free of addr %px by task %s/%d\\n\",\n\t\t\tinfo->access_addr, current->comm, task_pid_nr(current));\n\t\treturn;\n\t}\n\n\tif (info->access_size)\n\t\tpr_err(\"%s of size %zu at addr %px by task %s/%d\\n\",\n\t\t\tinfo->is_write ? \"Write\" : \"Read\", info->access_size,\n\t\t\tinfo->access_addr, current->comm, task_pid_nr(current));\n\telse\n\t\tpr_err(\"%s at addr %px by task %s/%d\\n\",\n\t\t\tinfo->is_write ? \"Write\" : \"Read\",\n\t\t\tinfo->access_addr, current->comm, task_pid_nr(current));\n}\n\nstatic void print_track(struct kasan_track *track, const char *prefix)\n{\n\tpr_err(\"%s by task %u:\\n\", prefix, track->pid);\n\tif (track->stack)\n\t\tstack_depot_print(track->stack);\n\telse\n\t\tpr_err(\"(stack is not available)\\n\");\n}\n\nstatic inline struct page *addr_to_page(const void *addr)\n{\n\tif (virt_addr_valid(addr))\n\t\treturn virt_to_head_page(addr);\n\treturn NULL;\n}\n\nstatic void describe_object_addr(const void *addr, struct kasan_report_info *info)\n{\n\tunsigned long access_addr = (unsigned long)addr;\n\tunsigned long object_addr = (unsigned long)info->object;\n\tconst char *rel_type, *region_state = \"\";\n\tint rel_bytes;\n\n\tpr_err(\"The buggy address belongs to the object at %px\\n\"\n\t       \" which belongs to the cache %s of size %d\\n\",\n\t\tinfo->object, info->cache->name, info->cache->object_size);\n\n\tif (access_addr < object_addr) {\n\t\trel_type = \"to the left\";\n\t\trel_bytes = object_addr - access_addr;\n\t} else if (access_addr >= object_addr + info->alloc_size) {\n\t\trel_type = \"to the right\";\n\t\trel_bytes = access_addr - (object_addr + info->alloc_size);\n\t} else {\n\t\trel_type = \"inside\";\n\t\trel_bytes = access_addr - object_addr;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_KASAN_GENERIC)) {\n\t\tif (strcmp(info->bug_type, \"slab-out-of-bounds\") == 0)\n\t\t\tregion_state = \"allocated \";\n\t\telse if (strcmp(info->bug_type, \"slab-use-after-free\") == 0)\n\t\t\tregion_state = \"freed \";\n\t}\n\n\tpr_err(\"The buggy address is located %d bytes %s of\\n\"\n\t       \" %s%zu-byte region [%px, %px)\\n\",\n\t       rel_bytes, rel_type, region_state, info->alloc_size,\n\t       (void *)object_addr, (void *)(object_addr + info->alloc_size));\n}\n\nstatic void describe_object_stacks(struct kasan_report_info *info)\n{\n\tif (info->alloc_track.stack) {\n\t\tprint_track(&info->alloc_track, \"Allocated\");\n\t\tpr_err(\"\\n\");\n\t}\n\n\tif (info->free_track.stack) {\n\t\tprint_track(&info->free_track, \"Freed\");\n\t\tpr_err(\"\\n\");\n\t}\n\n\tkasan_print_aux_stacks(info->cache, info->object);\n}\n\nstatic void describe_object(const void *addr, struct kasan_report_info *info)\n{\n\tif (kasan_stack_collection_enabled())\n\t\tdescribe_object_stacks(info);\n\tdescribe_object_addr(addr, info);\n}\n\nstatic inline bool kernel_or_module_addr(const void *addr)\n{\n\tif (is_kernel((unsigned long)addr))\n\t\treturn true;\n\tif (is_module_address((unsigned long)addr))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool init_task_stack_addr(const void *addr)\n{\n\treturn addr >= (void *)&init_thread_union.stack &&\n\t\t(addr <= (void *)&init_thread_union.stack +\n\t\t\tsizeof(init_thread_union.stack));\n}\n\nstatic void print_address_description(void *addr, u8 tag,\n\t\t\t\t      struct kasan_report_info *info)\n{\n\tstruct page *page = addr_to_page(addr);\n\n\tdump_stack_lvl(KERN_ERR);\n\tpr_err(\"\\n\");\n\n\tif (info->cache && info->object) {\n\t\tdescribe_object(addr, info);\n\t\tpr_err(\"\\n\");\n\t}\n\n\tif (kernel_or_module_addr(addr) && !init_task_stack_addr(addr)) {\n\t\tpr_err(\"The buggy address belongs to the variable:\\n\");\n\t\tpr_err(\" %pS\\n\", addr);\n\t\tpr_err(\"\\n\");\n\t}\n\n\tif (object_is_on_stack(addr)) {\n\t\t \n\t\tkasan_print_address_stack_frame(addr);\n\t\tpr_err(\"\\n\");\n\t}\n\n\tif (is_vmalloc_addr(addr)) {\n\t\tstruct vm_struct *va = find_vm_area(addr);\n\n\t\tif (va) {\n\t\t\tpr_err(\"The buggy address belongs to the virtual mapping at\\n\"\n\t\t\t       \" [%px, %px) created by:\\n\"\n\t\t\t       \" %pS\\n\",\n\t\t\t       va->addr, va->addr + va->size, va->caller);\n\t\t\tpr_err(\"\\n\");\n\n\t\t\tpage = vmalloc_to_page(addr);\n\t\t}\n\t}\n\n\tif (page) {\n\t\tpr_err(\"The buggy address belongs to the physical page:\\n\");\n\t\tdump_page(page, \"kasan: bad access detected\");\n\t\tpr_err(\"\\n\");\n\t}\n}\n\nstatic bool meta_row_is_guilty(const void *row, const void *addr)\n{\n\treturn (row <= addr) && (addr < row + META_MEM_BYTES_PER_ROW);\n}\n\nstatic int meta_pointer_offset(const void *row, const void *addr)\n{\n\t \n\treturn 3 + (BITS_PER_LONG / 8) * 2 +\n\t\t(addr - row) / KASAN_GRANULE_SIZE * 3 + 1;\n}\n\nstatic void print_memory_metadata(const void *addr)\n{\n\tint i;\n\tvoid *row;\n\n\trow = (void *)round_down((unsigned long)addr, META_MEM_BYTES_PER_ROW)\n\t\t\t- META_ROWS_AROUND_ADDR * META_MEM_BYTES_PER_ROW;\n\n\tpr_err(\"Memory state around the buggy address:\\n\");\n\n\tfor (i = -META_ROWS_AROUND_ADDR; i <= META_ROWS_AROUND_ADDR; i++) {\n\t\tchar buffer[4 + (BITS_PER_LONG / 8) * 2];\n\t\tchar metadata[META_BYTES_PER_ROW];\n\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t(i == 0) ? \">%px: \" : \" %px: \", row);\n\n\t\t \n\t\tkasan_metadata_fetch_row(&metadata[0], row);\n\n\t\tprint_hex_dump(KERN_ERR, buffer,\n\t\t\tDUMP_PREFIX_NONE, META_BYTES_PER_ROW, 1,\n\t\t\tmetadata, META_BYTES_PER_ROW, 0);\n\n\t\tif (meta_row_is_guilty(row, addr))\n\t\t\tpr_err(\"%*c\\n\", meta_pointer_offset(row, addr), '^');\n\n\t\trow += META_MEM_BYTES_PER_ROW;\n\t}\n}\n\nstatic void print_report(struct kasan_report_info *info)\n{\n\tvoid *addr = kasan_reset_tag((void *)info->access_addr);\n\tu8 tag = get_tag((void *)info->access_addr);\n\n\tprint_error_description(info);\n\tif (addr_has_metadata(addr))\n\t\tkasan_print_tags(tag, info->first_bad_addr);\n\tpr_err(\"\\n\");\n\n\tif (addr_has_metadata(addr)) {\n\t\tprint_address_description(addr, tag, info);\n\t\tprint_memory_metadata(info->first_bad_addr);\n\t} else {\n\t\tdump_stack_lvl(KERN_ERR);\n\t}\n}\n\nstatic void complete_report_info(struct kasan_report_info *info)\n{\n\tvoid *addr = kasan_reset_tag((void *)info->access_addr);\n\tstruct slab *slab;\n\n\tif (info->type == KASAN_REPORT_ACCESS)\n\t\tinfo->first_bad_addr = kasan_find_first_bad_addr(\n\t\t\t\t\t(void *)info->access_addr, info->access_size);\n\telse\n\t\tinfo->first_bad_addr = addr;\n\n\tslab = kasan_addr_to_slab(addr);\n\tif (slab) {\n\t\tinfo->cache = slab->slab_cache;\n\t\tinfo->object = nearest_obj(info->cache, slab, addr);\n\n\t\t \n\t\tinfo->alloc_size = kasan_get_alloc_size(info->object, info->cache);\n\t\t \n\t\tif (!info->alloc_size)\n\t\t\tinfo->alloc_size = info->cache->object_size;\n\t} else\n\t\tinfo->cache = info->object = NULL;\n\n\tswitch (info->type) {\n\tcase KASAN_REPORT_INVALID_FREE:\n\t\tinfo->bug_type = \"invalid-free\";\n\t\tbreak;\n\tcase KASAN_REPORT_DOUBLE_FREE:\n\t\tinfo->bug_type = \"double-free\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tkasan_complete_mode_report_info(info);\n}\n\nvoid kasan_report_invalid_free(void *ptr, unsigned long ip, enum kasan_report_type type)\n{\n\tunsigned long flags;\n\tstruct kasan_report_info info;\n\n\t \n\tif (unlikely(!report_enabled()))\n\t\treturn;\n\n\tstart_report(&flags, true);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = type;\n\tinfo.access_addr = ptr;\n\tinfo.access_size = 0;\n\tinfo.is_write = false;\n\tinfo.ip = ip;\n\n\tcomplete_report_info(&info);\n\n\tprint_report(&info);\n\n\t \n\tend_report(&flags, ptr, true);\n}\n\n \nbool kasan_report(const void *addr, size_t size, bool is_write,\n\t\t\tunsigned long ip)\n{\n\tbool ret = true;\n\tunsigned long ua_flags = user_access_save();\n\tunsigned long irq_flags;\n\tstruct kasan_report_info info;\n\n\tif (unlikely(report_suppressed_sw()) || unlikely(!report_enabled())) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tstart_report(&irq_flags, true);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = KASAN_REPORT_ACCESS;\n\tinfo.access_addr = addr;\n\tinfo.access_size = size;\n\tinfo.is_write = is_write;\n\tinfo.ip = ip;\n\n\tcomplete_report_info(&info);\n\n\tprint_report(&info);\n\n\tend_report(&irq_flags, (void *)addr, is_write);\n\nout:\n\tuser_access_restore(ua_flags);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_KASAN_HW_TAGS\nvoid kasan_report_async(void)\n{\n\tunsigned long flags;\n\n\t \n\tif (unlikely(!report_enabled()))\n\t\treturn;\n\n\tstart_report(&flags, false);\n\tpr_err(\"BUG: KASAN: invalid-access\\n\");\n\tpr_err(\"Asynchronous fault: no details available\\n\");\n\tpr_err(\"\\n\");\n\tdump_stack_lvl(KERN_ERR);\n\t \n\tend_report(&flags, NULL, true);\n}\n#endif  \n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n \nvoid kasan_non_canonical_hook(unsigned long addr)\n{\n\tunsigned long orig_addr;\n\tconst char *bug_type;\n\n\tif (addr < KASAN_SHADOW_OFFSET)\n\t\treturn;\n\n\torig_addr = (addr - KASAN_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT;\n\t \n\tif (orig_addr < PAGE_SIZE)\n\t\tbug_type = \"null-ptr-deref\";\n\telse if (orig_addr < TASK_SIZE)\n\t\tbug_type = \"probably user-memory-access\";\n\telse\n\t\tbug_type = \"maybe wild-memory-access\";\n\tpr_alert(\"KASAN: %s in range [0x%016lx-0x%016lx]\\n\", bug_type,\n\t\t orig_addr, orig_addr + KASAN_GRANULE_SIZE - 1);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}