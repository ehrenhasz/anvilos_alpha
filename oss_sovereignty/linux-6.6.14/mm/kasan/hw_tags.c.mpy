{
  "module_name": "hw_tags.c",
  "hash_id": "f57418f0d6754d95f42fd871316a08752db3d58e524d735dd8fdb87dc003e1e9",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/hw_tags.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kasan: \" fmt\n\n#include <linux/init.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/static_key.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"kasan.h\"\n\nenum kasan_arg {\n\tKASAN_ARG_DEFAULT,\n\tKASAN_ARG_OFF,\n\tKASAN_ARG_ON,\n};\n\nenum kasan_arg_mode {\n\tKASAN_ARG_MODE_DEFAULT,\n\tKASAN_ARG_MODE_SYNC,\n\tKASAN_ARG_MODE_ASYNC,\n\tKASAN_ARG_MODE_ASYMM,\n};\n\nenum kasan_arg_vmalloc {\n\tKASAN_ARG_VMALLOC_DEFAULT,\n\tKASAN_ARG_VMALLOC_OFF,\n\tKASAN_ARG_VMALLOC_ON,\n};\n\nstatic enum kasan_arg kasan_arg __ro_after_init;\nstatic enum kasan_arg_mode kasan_arg_mode __ro_after_init;\nstatic enum kasan_arg_vmalloc kasan_arg_vmalloc __initdata;\n\n \nDEFINE_STATIC_KEY_FALSE(kasan_flag_enabled);\nEXPORT_SYMBOL(kasan_flag_enabled);\n\n \nenum kasan_mode kasan_mode __ro_after_init;\nEXPORT_SYMBOL_GPL(kasan_mode);\n\n \nDEFINE_STATIC_KEY_TRUE(kasan_flag_vmalloc);\n\n#define PAGE_ALLOC_SAMPLE_DEFAULT\t1\n#define PAGE_ALLOC_SAMPLE_ORDER_DEFAULT\t3\n\n \nunsigned long kasan_page_alloc_sample = PAGE_ALLOC_SAMPLE_DEFAULT;\n\n \nunsigned int kasan_page_alloc_sample_order = PAGE_ALLOC_SAMPLE_ORDER_DEFAULT;\n\nDEFINE_PER_CPU(long, kasan_page_alloc_skip);\n\n \nstatic int __init early_kasan_flag(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(arg, \"off\"))\n\t\tkasan_arg = KASAN_ARG_OFF;\n\telse if (!strcmp(arg, \"on\"))\n\t\tkasan_arg = KASAN_ARG_ON;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"kasan\", early_kasan_flag);\n\n \nstatic int __init early_kasan_mode(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(arg, \"sync\"))\n\t\tkasan_arg_mode = KASAN_ARG_MODE_SYNC;\n\telse if (!strcmp(arg, \"async\"))\n\t\tkasan_arg_mode = KASAN_ARG_MODE_ASYNC;\n\telse if (!strcmp(arg, \"asymm\"))\n\t\tkasan_arg_mode = KASAN_ARG_MODE_ASYMM;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"kasan.mode\", early_kasan_mode);\n\n \nstatic int __init early_kasan_flag_vmalloc(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(arg, \"off\"))\n\t\tkasan_arg_vmalloc = KASAN_ARG_VMALLOC_OFF;\n\telse if (!strcmp(arg, \"on\"))\n\t\tkasan_arg_vmalloc = KASAN_ARG_VMALLOC_ON;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"kasan.vmalloc\", early_kasan_flag_vmalloc);\n\nstatic inline const char *kasan_mode_info(void)\n{\n\tif (kasan_mode == KASAN_MODE_ASYNC)\n\t\treturn \"async\";\n\telse if (kasan_mode == KASAN_MODE_ASYMM)\n\t\treturn \"asymm\";\n\telse\n\t\treturn \"sync\";\n}\n\n \nstatic int __init early_kasan_flag_page_alloc_sample(char *arg)\n{\n\tint rv;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\trv = kstrtoul(arg, 0, &kasan_page_alloc_sample);\n\tif (rv)\n\t\treturn rv;\n\n\tif (!kasan_page_alloc_sample || kasan_page_alloc_sample > LONG_MAX) {\n\t\tkasan_page_alloc_sample = PAGE_ALLOC_SAMPLE_DEFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nearly_param(\"kasan.page_alloc.sample\", early_kasan_flag_page_alloc_sample);\n\n \nstatic int __init early_kasan_flag_page_alloc_sample_order(char *arg)\n{\n\tint rv;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\trv = kstrtouint(arg, 0, &kasan_page_alloc_sample_order);\n\tif (rv)\n\t\treturn rv;\n\n\tif (kasan_page_alloc_sample_order > INT_MAX) {\n\t\tkasan_page_alloc_sample_order = PAGE_ALLOC_SAMPLE_ORDER_DEFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nearly_param(\"kasan.page_alloc.sample.order\", early_kasan_flag_page_alloc_sample_order);\n\n \nvoid kasan_init_hw_tags_cpu(void)\n{\n\t \n\n\t \n\tif (kasan_arg == KASAN_ARG_OFF)\n\t\treturn;\n\n\t \n\tkasan_enable_hw_tags();\n}\n\n \nvoid __init kasan_init_hw_tags(void)\n{\n\t \n\tif (!system_supports_mte())\n\t\treturn;\n\n\t \n\tif (kasan_arg == KASAN_ARG_OFF)\n\t\treturn;\n\n\tswitch (kasan_arg_mode) {\n\tcase KASAN_ARG_MODE_DEFAULT:\n\t\t \n\t\tbreak;\n\tcase KASAN_ARG_MODE_SYNC:\n\t\tkasan_mode = KASAN_MODE_SYNC;\n\t\tbreak;\n\tcase KASAN_ARG_MODE_ASYNC:\n\t\tkasan_mode = KASAN_MODE_ASYNC;\n\t\tbreak;\n\tcase KASAN_ARG_MODE_ASYMM:\n\t\tkasan_mode = KASAN_MODE_ASYMM;\n\t\tbreak;\n\t}\n\n\tswitch (kasan_arg_vmalloc) {\n\tcase KASAN_ARG_VMALLOC_DEFAULT:\n\t\t \n\t\tbreak;\n\tcase KASAN_ARG_VMALLOC_OFF:\n\t\tstatic_branch_disable(&kasan_flag_vmalloc);\n\t\tbreak;\n\tcase KASAN_ARG_VMALLOC_ON:\n\t\tstatic_branch_enable(&kasan_flag_vmalloc);\n\t\tbreak;\n\t}\n\n\tkasan_init_tags();\n\n\t \n\tstatic_branch_enable(&kasan_flag_enabled);\n\n\tpr_info(\"KernelAddressSanitizer initialized (hw-tags, mode=%s, vmalloc=%s, stacktrace=%s)\\n\",\n\t\tkasan_mode_info(),\n\t\tkasan_vmalloc_enabled() ? \"on\" : \"off\",\n\t\tkasan_stack_collection_enabled() ? \"on\" : \"off\");\n}\n\n#ifdef CONFIG_KASAN_VMALLOC\n\nstatic void unpoison_vmalloc_pages(const void *addr, u8 tag)\n{\n\tstruct vm_struct *area;\n\tint i;\n\n\t \n\tarea = find_vm_area((void *)addr);\n\tif (WARN_ON(!area))\n\t\treturn;\n\n\tfor (i = 0; i < area->nr_pages; i++) {\n\t\tstruct page *page = area->pages[i];\n\n\t\tpage_kasan_tag_set(page, tag);\n\t}\n}\n\nstatic void init_vmalloc_pages(const void *start, unsigned long size)\n{\n\tconst void *addr;\n\n\tfor (addr = start; addr < start + size; addr += PAGE_SIZE) {\n\t\tstruct page *page = vmalloc_to_page(addr);\n\n\t\tclear_highpage_kasan_tagged(page);\n\t}\n}\n\nvoid *__kasan_unpoison_vmalloc(const void *start, unsigned long size,\n\t\t\t\tkasan_vmalloc_flags_t flags)\n{\n\tu8 tag;\n\tunsigned long redzone_start, redzone_size;\n\n\tif (!kasan_vmalloc_enabled()) {\n\t\tif (flags & KASAN_VMALLOC_INIT)\n\t\t\tinit_vmalloc_pages(start, size);\n\t\treturn (void *)start;\n\t}\n\n\t \n\tif (!(flags & KASAN_VMALLOC_VM_ALLOC)) {\n\t\tWARN_ON(flags & KASAN_VMALLOC_INIT);\n\t\treturn (void *)start;\n\t}\n\n\t \n\tif (!(flags & KASAN_VMALLOC_PROT_NORMAL)) {\n\t\tWARN_ON(flags & KASAN_VMALLOC_INIT);\n\t\treturn (void *)start;\n\t}\n\n\ttag = kasan_random_tag();\n\tstart = set_tag(start, tag);\n\n\t \n\tkasan_unpoison(start, size, flags & KASAN_VMALLOC_INIT);\n\n\t \n\tredzone_start = round_up((unsigned long)start + size,\n\t\t\t\t KASAN_GRANULE_SIZE);\n\tredzone_size = round_up(redzone_start, PAGE_SIZE) - redzone_start;\n\tkasan_poison((void *)redzone_start, redzone_size, KASAN_TAG_INVALID,\n\t\t     flags & KASAN_VMALLOC_INIT);\n\n\t \n\tunpoison_vmalloc_pages(start, tag);\n\n\treturn (void *)start;\n}\n\nvoid __kasan_poison_vmalloc(const void *start, unsigned long size)\n{\n\t \n}\n\n#endif\n\nvoid kasan_enable_hw_tags(void)\n{\n\tif (kasan_arg_mode == KASAN_ARG_MODE_ASYNC)\n\t\thw_enable_tag_checks_async();\n\telse if (kasan_arg_mode == KASAN_ARG_MODE_ASYMM)\n\t\thw_enable_tag_checks_asymm();\n\telse\n\t\thw_enable_tag_checks_sync();\n}\n\n#if IS_ENABLED(CONFIG_KASAN_KUNIT_TEST)\n\nEXPORT_SYMBOL_GPL(kasan_enable_hw_tags);\n\nvoid kasan_force_async_fault(void)\n{\n\thw_force_async_tag_fault();\n}\nEXPORT_SYMBOL_GPL(kasan_force_async_fault);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}