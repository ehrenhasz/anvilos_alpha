{
  "module_name": "tags.c",
  "hash_id": "986265aaa8d8b8656b68f699c95c798f3fbc852104cabe63a28d6dd35c7c9c30",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/tags.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/init.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/memblock.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/static_key.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"kasan.h\"\n#include \"../slab.h\"\n\n#define KASAN_STACK_RING_SIZE_DEFAULT (32 << 10)\n\nenum kasan_arg_stacktrace {\n\tKASAN_ARG_STACKTRACE_DEFAULT,\n\tKASAN_ARG_STACKTRACE_OFF,\n\tKASAN_ARG_STACKTRACE_ON,\n};\n\nstatic enum kasan_arg_stacktrace kasan_arg_stacktrace __initdata;\n\n \nDEFINE_STATIC_KEY_TRUE(kasan_flag_stacktrace);\n\n \n#define STACK_RING_BUSY_PTR ((void *)1)\n\nstruct kasan_stack_ring stack_ring = {\n\t.lock = __RW_LOCK_UNLOCKED(stack_ring.lock)\n};\n\n \nstatic int __init early_kasan_flag_stacktrace(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(arg, \"off\"))\n\t\tkasan_arg_stacktrace = KASAN_ARG_STACKTRACE_OFF;\n\telse if (!strcmp(arg, \"on\"))\n\t\tkasan_arg_stacktrace = KASAN_ARG_STACKTRACE_ON;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nearly_param(\"kasan.stacktrace\", early_kasan_flag_stacktrace);\n\n \nstatic int __init early_kasan_flag_stack_ring_size(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\treturn kstrtoul(arg, 0, &stack_ring.size);\n}\nearly_param(\"kasan.stack_ring_size\", early_kasan_flag_stack_ring_size);\n\nvoid __init kasan_init_tags(void)\n{\n\tswitch (kasan_arg_stacktrace) {\n\tcase KASAN_ARG_STACKTRACE_DEFAULT:\n\t\t \n\t\tbreak;\n\tcase KASAN_ARG_STACKTRACE_OFF:\n\t\tstatic_branch_disable(&kasan_flag_stacktrace);\n\t\tbreak;\n\tcase KASAN_ARG_STACKTRACE_ON:\n\t\tstatic_branch_enable(&kasan_flag_stacktrace);\n\t\tbreak;\n\t}\n\n\tif (kasan_stack_collection_enabled()) {\n\t\tif (!stack_ring.size)\n\t\t\tstack_ring.size = KASAN_STACK_RING_SIZE_DEFAULT;\n\t\tstack_ring.entries = memblock_alloc(\n\t\t\tsizeof(stack_ring.entries[0]) * stack_ring.size,\n\t\t\tSMP_CACHE_BYTES);\n\t\tif (WARN_ON(!stack_ring.entries))\n\t\t\tstatic_branch_disable(&kasan_flag_stacktrace);\n\t}\n}\n\nstatic void save_stack_info(struct kmem_cache *cache, void *object,\n\t\t\tgfp_t gfp_flags, bool is_free)\n{\n\tunsigned long flags;\n\tdepot_stack_handle_t stack;\n\tu64 pos;\n\tstruct kasan_stack_ring_entry *entry;\n\tvoid *old_ptr;\n\n\tstack = kasan_save_stack(gfp_flags, true);\n\n\t \n\tread_lock_irqsave(&stack_ring.lock, flags);\n\nnext:\n\tpos = atomic64_fetch_add(1, &stack_ring.pos);\n\tentry = &stack_ring.entries[pos % stack_ring.size];\n\n\t \n\told_ptr = READ_ONCE(entry->ptr);\n\tif (old_ptr == STACK_RING_BUSY_PTR)\n\t\tgoto next;  \n\tif (!try_cmpxchg(&entry->ptr, &old_ptr, STACK_RING_BUSY_PTR))\n\t\tgoto next;  \n\n\tWRITE_ONCE(entry->size, cache->object_size);\n\tWRITE_ONCE(entry->pid, current->pid);\n\tWRITE_ONCE(entry->stack, stack);\n\tWRITE_ONCE(entry->is_free, is_free);\n\n\t \n\tsmp_store_release(&entry->ptr, (s64)object);\n\n\tread_unlock_irqrestore(&stack_ring.lock, flags);\n}\n\nvoid kasan_save_alloc_info(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tsave_stack_info(cache, object, flags, false);\n}\n\nvoid kasan_save_free_info(struct kmem_cache *cache, void *object)\n{\n\tsave_stack_info(cache, object, 0, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}