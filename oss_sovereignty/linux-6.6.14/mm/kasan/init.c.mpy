{
  "module_name": "init.c",
  "hash_id": "02c6e67b713ea1e760e66441b78cf77689e13de961ac027742d6ba0a7579e33a",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/init.c",
  "human_readable_source": "\n \n\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/slab.h>\n\n#include <asm/page.h>\n#include <asm/pgalloc.h>\n\n#include \"kasan.h\"\n\n \nunsigned char kasan_early_shadow_page[PAGE_SIZE] __page_aligned_bss;\n\n#if CONFIG_PGTABLE_LEVELS > 4\np4d_t kasan_early_shadow_p4d[MAX_PTRS_PER_P4D] __page_aligned_bss;\nstatic inline bool kasan_p4d_table(pgd_t pgd)\n{\n\treturn pgd_page(pgd) == virt_to_page(lm_alias(kasan_early_shadow_p4d));\n}\n#else\nstatic inline bool kasan_p4d_table(pgd_t pgd)\n{\n\treturn false;\n}\n#endif\n#if CONFIG_PGTABLE_LEVELS > 3\npud_t kasan_early_shadow_pud[MAX_PTRS_PER_PUD] __page_aligned_bss;\nstatic inline bool kasan_pud_table(p4d_t p4d)\n{\n\treturn p4d_page(p4d) == virt_to_page(lm_alias(kasan_early_shadow_pud));\n}\n#else\nstatic inline bool kasan_pud_table(p4d_t p4d)\n{\n\treturn false;\n}\n#endif\n#if CONFIG_PGTABLE_LEVELS > 2\npmd_t kasan_early_shadow_pmd[MAX_PTRS_PER_PMD] __page_aligned_bss;\nstatic inline bool kasan_pmd_table(pud_t pud)\n{\n\treturn pud_page(pud) == virt_to_page(lm_alias(kasan_early_shadow_pmd));\n}\n#else\nstatic inline bool kasan_pmd_table(pud_t pud)\n{\n\treturn false;\n}\n#endif\npte_t kasan_early_shadow_pte[MAX_PTRS_PER_PTE + PTE_HWTABLE_PTRS]\n\t__page_aligned_bss;\n\nstatic inline bool kasan_pte_table(pmd_t pmd)\n{\n\treturn pmd_page(pmd) == virt_to_page(lm_alias(kasan_early_shadow_pte));\n}\n\nstatic inline bool kasan_early_shadow_page_entry(pte_t pte)\n{\n\treturn pte_page(pte) == virt_to_page(lm_alias(kasan_early_shadow_page));\n}\n\nstatic __init void *early_alloc(size_t size, int node)\n{\n\tvoid *ptr = memblock_alloc_try_nid(size, size, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t   MEMBLOCK_ALLOC_ACCESSIBLE, node);\n\n\tif (!ptr)\n\t\tpanic(\"%s: Failed to allocate %zu bytes align=%zx nid=%d from=%llx\\n\",\n\t\t      __func__, size, size, node, (u64)__pa(MAX_DMA_ADDRESS));\n\n\treturn ptr;\n}\n\nstatic void __ref zero_pte_populate(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpte_t *pte = pte_offset_kernel(pmd, addr);\n\tpte_t zero_pte;\n\n\tzero_pte = pfn_pte(PFN_DOWN(__pa_symbol(kasan_early_shadow_page)),\n\t\t\t\tPAGE_KERNEL);\n\tzero_pte = pte_wrprotect(zero_pte);\n\n\twhile (addr + PAGE_SIZE <= end) {\n\t\tset_pte_at(&init_mm, addr, pte, zero_pte);\n\t\taddr += PAGE_SIZE;\n\t\tpte = pte_offset_kernel(pmd, addr);\n\t}\n}\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}\n\nvoid __weak __meminit pmd_init(void *addr)\n{\n}\n\nstatic int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpud_t *pud = pud_offset(p4d, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, PUD_SIZE) && end - addr >= PUD_SIZE) {\n\t\t\tpmd_t *pmd;\n\n\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_none(*pud)) {\n\t\t\tpmd_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pmd_alloc(&init_mm, pud, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\t\tpmd_init(p);\n\t\t\t\tpud_populate(&init_mm, pud, p);\n\t\t\t}\n\t\t}\n\t\tzero_pmd_populate(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn 0;\n}\n\nvoid __weak __meminit pud_init(void *addr)\n{\n}\n\nstatic int __ref zero_p4d_populate(pgd_t *pgd, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, P4D_SIZE) && end - addr >= P4D_SIZE) {\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\n\t\t\tp4d_populate(&init_mm, p4d,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pud));\n\t\t\tpud = pud_offset(p4d, addr);\n\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (p4d_none(*p4d)) {\n\t\t\tpud_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pud_alloc(&init_mm, p4d, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\t\tpud_init(p);\n\t\t\t\tp4d_populate(&init_mm, p4d, p);\n\t\t\t}\n\t\t}\n\t\tzero_pud_populate(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn 0;\n}\n\n \nint __ref kasan_populate_early_shadow(const void *shadow_start,\n\t\t\t\t\tconst void *shadow_end)\n{\n\tunsigned long addr = (unsigned long)shadow_start;\n\tunsigned long end = (unsigned long)shadow_end;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PGDIR_SIZE) && end - addr >= PGDIR_SIZE) {\n\t\t\tp4d_t *p4d;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\n\t\t\t \n\t\t\tpgd_populate(&init_mm, pgd,\n\t\t\t\t\tlm_alias(kasan_early_shadow_p4d));\n\t\t\tp4d = p4d_offset(pgd, addr);\n\t\t\tp4d_populate(&init_mm, p4d,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pud));\n\t\t\tpud = pud_offset(p4d, addr);\n\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\tlm_alias(kasan_early_shadow_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pgd_none(*pgd)) {\n\t\t\tp4d_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = p4d_alloc(&init_mm, pgd, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tpgd_populate(&init_mm, pgd,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_p4d_populate(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn 0;\n}\n\nstatic void kasan_free_pte(pte_t *pte_start, pmd_t *pmd)\n{\n\tpte_t *pte;\n\tint i;\n\n\tfor (i = 0; i < PTRS_PER_PTE; i++) {\n\t\tpte = pte_start + i;\n\t\tif (!pte_none(ptep_get(pte)))\n\t\t\treturn;\n\t}\n\n\tpte_free_kernel(&init_mm, (pte_t *)page_to_virt(pmd_page(*pmd)));\n\tpmd_clear(pmd);\n}\n\nstatic void kasan_free_pmd(pmd_t *pmd_start, pud_t *pud)\n{\n\tpmd_t *pmd;\n\tint i;\n\n\tfor (i = 0; i < PTRS_PER_PMD; i++) {\n\t\tpmd = pmd_start + i;\n\t\tif (!pmd_none(*pmd))\n\t\t\treturn;\n\t}\n\n\tpmd_free(&init_mm, (pmd_t *)page_to_virt(pud_page(*pud)));\n\tpud_clear(pud);\n}\n\nstatic void kasan_free_pud(pud_t *pud_start, p4d_t *p4d)\n{\n\tpud_t *pud;\n\tint i;\n\n\tfor (i = 0; i < PTRS_PER_PUD; i++) {\n\t\tpud = pud_start + i;\n\t\tif (!pud_none(*pud))\n\t\t\treturn;\n\t}\n\n\tpud_free(&init_mm, (pud_t *)page_to_virt(p4d_page(*p4d)));\n\tp4d_clear(p4d);\n}\n\nstatic void kasan_free_p4d(p4d_t *p4d_start, pgd_t *pgd)\n{\n\tp4d_t *p4d;\n\tint i;\n\n\tfor (i = 0; i < PTRS_PER_P4D; i++) {\n\t\tp4d = p4d_start + i;\n\t\tif (!p4d_none(*p4d))\n\t\t\treturn;\n\t}\n\n\tp4d_free(&init_mm, (p4d_t *)page_to_virt(pgd_page(*pgd)));\n\tpgd_clear(pgd);\n}\n\nstatic void kasan_remove_pte_table(pte_t *pte, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tunsigned long next;\n\tpte_t ptent;\n\n\tfor (; addr < end; addr = next, pte++) {\n\t\tnext = (addr + PAGE_SIZE) & PAGE_MASK;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tptent = ptep_get(pte);\n\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!kasan_early_shadow_page_entry(ptent)))\n\t\t\tcontinue;\n\t\tpte_clear(&init_mm, addr, pte);\n\t}\n}\n\nstatic void kasan_remove_pmd_table(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tunsigned long next;\n\n\tfor (; addr < end; addr = next, pmd++) {\n\t\tpte_t *pte;\n\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (!pmd_present(*pmd))\n\t\t\tcontinue;\n\n\t\tif (kasan_pte_table(*pmd)) {\n\t\t\tif (IS_ALIGNED(addr, PMD_SIZE) &&\n\t\t\t    IS_ALIGNED(next, PMD_SIZE)) {\n\t\t\t\tpmd_clear(pmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpte = pte_offset_kernel(pmd, addr);\n\t\tkasan_remove_pte_table(pte, addr, next);\n\t\tkasan_free_pte(pte_offset_kernel(pmd, 0), pmd);\n\t}\n}\n\nstatic void kasan_remove_pud_table(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tunsigned long next;\n\n\tfor (; addr < end; addr = next, pud++) {\n\t\tpmd_t *pmd, *pmd_base;\n\n\t\tnext = pud_addr_end(addr, end);\n\n\t\tif (!pud_present(*pud))\n\t\t\tcontinue;\n\n\t\tif (kasan_pmd_table(*pud)) {\n\t\t\tif (IS_ALIGNED(addr, PUD_SIZE) &&\n\t\t\t    IS_ALIGNED(next, PUD_SIZE)) {\n\t\t\t\tpud_clear(pud);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpmd = pmd_offset(pud, addr);\n\t\tpmd_base = pmd_offset(pud, 0);\n\t\tkasan_remove_pmd_table(pmd, addr, next);\n\t\tkasan_free_pmd(pmd_base, pud);\n\t}\n}\n\nstatic void kasan_remove_p4d_table(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tunsigned long next;\n\n\tfor (; addr < end; addr = next, p4d++) {\n\t\tpud_t *pud;\n\n\t\tnext = p4d_addr_end(addr, end);\n\n\t\tif (!p4d_present(*p4d))\n\t\t\tcontinue;\n\n\t\tif (kasan_pud_table(*p4d)) {\n\t\t\tif (IS_ALIGNED(addr, P4D_SIZE) &&\n\t\t\t    IS_ALIGNED(next, P4D_SIZE)) {\n\t\t\t\tp4d_clear(p4d);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpud = pud_offset(p4d, addr);\n\t\tkasan_remove_pud_table(pud, addr, next);\n\t\tkasan_free_pud(pud_offset(p4d, 0), p4d);\n\t}\n}\n\nvoid kasan_remove_zero_shadow(void *start, unsigned long size)\n{\n\tunsigned long addr, end, next;\n\tpgd_t *pgd;\n\n\taddr = (unsigned long)kasan_mem_to_shadow(start);\n\tend = addr + (size >> KASAN_SHADOW_SCALE_SHIFT);\n\n\tif (WARN_ON((unsigned long)start % KASAN_MEMORY_PER_SHADOW_PAGE) ||\n\t    WARN_ON(size % KASAN_MEMORY_PER_SHADOW_PAGE))\n\t\treturn;\n\n\tfor (; addr < end; addr = next) {\n\t\tp4d_t *p4d;\n\n\t\tnext = pgd_addr_end(addr, end);\n\n\t\tpgd = pgd_offset_k(addr);\n\t\tif (!pgd_present(*pgd))\n\t\t\tcontinue;\n\n\t\tif (kasan_p4d_table(*pgd)) {\n\t\t\tif (IS_ALIGNED(addr, PGDIR_SIZE) &&\n\t\t\t    IS_ALIGNED(next, PGDIR_SIZE)) {\n\t\t\t\tpgd_clear(pgd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tp4d = p4d_offset(pgd, addr);\n\t\tkasan_remove_p4d_table(p4d, addr, next);\n\t\tkasan_free_p4d(p4d_offset(pgd, 0), pgd);\n\t}\n}\n\nint kasan_add_zero_shadow(void *start, unsigned long size)\n{\n\tint ret;\n\tvoid *shadow_start, *shadow_end;\n\n\tshadow_start = kasan_mem_to_shadow(start);\n\tshadow_end = shadow_start + (size >> KASAN_SHADOW_SCALE_SHIFT);\n\n\tif (WARN_ON((unsigned long)start % KASAN_MEMORY_PER_SHADOW_PAGE) ||\n\t    WARN_ON(size % KASAN_MEMORY_PER_SHADOW_PAGE))\n\t\treturn -EINVAL;\n\n\tret = kasan_populate_early_shadow(shadow_start, shadow_end);\n\tif (ret)\n\t\tkasan_remove_zero_shadow(start, size);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}