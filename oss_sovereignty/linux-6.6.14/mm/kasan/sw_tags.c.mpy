{
  "module_name": "sw_tags.c",
  "hash_id": "a51a575097653bde508c386d0f03e64b436d1c682090961d4d0fbe6cb102ac16",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/sw_tags.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kasan: \" fmt\n\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/kmemleak.h>\n#include <linux/linkage.h>\n#include <linux/memblock.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/stacktrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n#include <linux/bug.h>\n\n#include \"kasan.h\"\n#include \"../slab.h\"\n\nstatic DEFINE_PER_CPU(u32, prng_state);\n\nvoid __init kasan_init_sw_tags(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(prng_state, cpu) = (u32)get_cycles();\n\n\tkasan_init_tags();\n\n\tpr_info(\"KernelAddressSanitizer initialized (sw-tags, stacktrace=%s)\\n\",\n\t\tkasan_stack_collection_enabled() ? \"on\" : \"off\");\n}\n\n \nu8 kasan_random_tag(void)\n{\n\tu32 state = this_cpu_read(prng_state);\n\n\tstate = 1664525 * state + 1013904223;\n\tthis_cpu_write(prng_state, state);\n\n\treturn (u8)(state % (KASAN_TAG_MAX + 1));\n}\n\nbool kasan_check_range(const void *addr, size_t size, bool write,\n\t\t\tunsigned long ret_ip)\n{\n\tu8 tag;\n\tu8 *shadow_first, *shadow_last, *shadow;\n\tvoid *untagged_addr;\n\n\tif (unlikely(size == 0))\n\t\treturn true;\n\n\tif (unlikely(addr + size < addr))\n\t\treturn !kasan_report(addr, size, write, ret_ip);\n\n\ttag = get_tag((const void *)addr);\n\n\t \n\tif (tag == KASAN_TAG_KERNEL)\n\t\treturn true;\n\n\tuntagged_addr = kasan_reset_tag((const void *)addr);\n\tif (unlikely(!addr_has_metadata(untagged_addr)))\n\t\treturn !kasan_report(addr, size, write, ret_ip);\n\tshadow_first = kasan_mem_to_shadow(untagged_addr);\n\tshadow_last = kasan_mem_to_shadow(untagged_addr + size - 1);\n\tfor (shadow = shadow_first; shadow <= shadow_last; shadow++) {\n\t\tif (*shadow != tag) {\n\t\t\treturn !kasan_report(addr, size, write, ret_ip);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool kasan_byte_accessible(const void *addr)\n{\n\tu8 tag = get_tag(addr);\n\tvoid *untagged_addr = kasan_reset_tag(addr);\n\tu8 shadow_byte;\n\n\tif (!addr_has_metadata(untagged_addr))\n\t\treturn false;\n\n\tshadow_byte = READ_ONCE(*(u8 *)kasan_mem_to_shadow(untagged_addr));\n\treturn tag == KASAN_TAG_KERNEL || tag == shadow_byte;\n}\n\n#define DEFINE_HWASAN_LOAD_STORE(size)\t\t\t\t\t\\\n\tvoid __hwasan_load##size##_noabort(void *addr)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tkasan_check_range(addr, size, false, _RET_IP_);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tEXPORT_SYMBOL(__hwasan_load##size##_noabort);\t\t\t\\\n\tvoid __hwasan_store##size##_noabort(void *addr)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tkasan_check_range(addr, size, true, _RET_IP_);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tEXPORT_SYMBOL(__hwasan_store##size##_noabort)\n\nDEFINE_HWASAN_LOAD_STORE(1);\nDEFINE_HWASAN_LOAD_STORE(2);\nDEFINE_HWASAN_LOAD_STORE(4);\nDEFINE_HWASAN_LOAD_STORE(8);\nDEFINE_HWASAN_LOAD_STORE(16);\n\nvoid __hwasan_loadN_noabort(void *addr, ssize_t size)\n{\n\tkasan_check_range(addr, size, false, _RET_IP_);\n}\nEXPORT_SYMBOL(__hwasan_loadN_noabort);\n\nvoid __hwasan_storeN_noabort(void *addr, ssize_t size)\n{\n\tkasan_check_range(addr, size, true, _RET_IP_);\n}\nEXPORT_SYMBOL(__hwasan_storeN_noabort);\n\nvoid __hwasan_tag_memory(void *addr, u8 tag, ssize_t size)\n{\n\tkasan_poison(addr, size, tag, false);\n}\nEXPORT_SYMBOL(__hwasan_tag_memory);\n\nvoid kasan_tag_mismatch(void *addr, unsigned long access_info,\n\t\t\tunsigned long ret_ip)\n{\n\tkasan_report(addr, 1 << (access_info & 0xf), access_info & 0x10,\n\t\t     ret_ip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}