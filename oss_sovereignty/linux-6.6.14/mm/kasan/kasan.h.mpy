{
  "module_name": "kasan.h",
  "hash_id": "ddb3483dc48a85598228e94e8333f88d346674c903e31b7da68e93e75534e833",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/kasan.h",
  "human_readable_source": " \n#ifndef __MM_KASAN_KASAN_H\n#define __MM_KASAN_KASAN_H\n\n#include <linux/atomic.h>\n#include <linux/kasan.h>\n#include <linux/kasan-tags.h>\n#include <linux/kfence.h>\n#include <linux/stackdepot.h>\n\n#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)\n\n#include <linux/static_key.h>\n\nDECLARE_STATIC_KEY_TRUE(kasan_flag_stacktrace);\n\nstatic inline bool kasan_stack_collection_enabled(void)\n{\n\treturn static_branch_unlikely(&kasan_flag_stacktrace);\n}\n\n#else  \n\nstatic inline bool kasan_stack_collection_enabled(void)\n{\n\treturn true;\n}\n\n#endif  \n\n#ifdef CONFIG_KASAN_HW_TAGS\n\n#include \"../slab.h\"\n\nDECLARE_STATIC_KEY_TRUE(kasan_flag_vmalloc);\n\nenum kasan_mode {\n\tKASAN_MODE_SYNC,\n\tKASAN_MODE_ASYNC,\n\tKASAN_MODE_ASYMM,\n};\n\nextern enum kasan_mode kasan_mode __ro_after_init;\n\nextern unsigned long kasan_page_alloc_sample;\nextern unsigned int kasan_page_alloc_sample_order;\nDECLARE_PER_CPU(long, kasan_page_alloc_skip);\n\nstatic inline bool kasan_vmalloc_enabled(void)\n{\n\treturn static_branch_likely(&kasan_flag_vmalloc);\n}\n\nstatic inline bool kasan_async_fault_possible(void)\n{\n\treturn kasan_mode == KASAN_MODE_ASYNC || kasan_mode == KASAN_MODE_ASYMM;\n}\n\nstatic inline bool kasan_sync_fault_possible(void)\n{\n\treturn kasan_mode == KASAN_MODE_SYNC || kasan_mode == KASAN_MODE_ASYMM;\n}\n\nstatic inline bool kasan_sample_page_alloc(unsigned int order)\n{\n\t \n\tif (kasan_page_alloc_sample == 1)\n\t\treturn true;\n\n\tif (order < kasan_page_alloc_sample_order)\n\t\treturn true;\n\n\tif (this_cpu_dec_return(kasan_page_alloc_skip) < 0) {\n\t\tthis_cpu_write(kasan_page_alloc_skip,\n\t\t\t       kasan_page_alloc_sample - 1);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#else  \n\nstatic inline bool kasan_async_fault_possible(void)\n{\n\treturn false;\n}\n\nstatic inline bool kasan_sync_fault_possible(void)\n{\n\treturn true;\n}\n\nstatic inline bool kasan_sample_page_alloc(unsigned int order)\n{\n\treturn true;\n}\n\n#endif  \n\n#ifdef CONFIG_KASAN_GENERIC\n\n \nstatic inline bool kasan_requires_meta(void)\n{\n\t \n\treturn kasan_stack_collection_enabled();\n}\n\n#else  \n\n \nstatic inline bool kasan_requires_meta(void)\n{\n\treturn false;\n}\n\n#endif  \n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n#define KASAN_GRANULE_SIZE\t(1UL << KASAN_SHADOW_SCALE_SHIFT)\n#else\n#include <asm/mte-kasan.h>\n#define KASAN_GRANULE_SIZE\tMTE_GRANULE_SIZE\n#endif\n\n#define KASAN_GRANULE_MASK\t(KASAN_GRANULE_SIZE - 1)\n\n#define KASAN_MEMORY_PER_SHADOW_PAGE\t(KASAN_GRANULE_SIZE << PAGE_SHIFT)\n\n#ifdef CONFIG_KASAN_GENERIC\n#define KASAN_PAGE_FREE\t\t0xFF   \n#define KASAN_PAGE_REDZONE\t0xFE   \n#define KASAN_SLAB_REDZONE\t0xFC   \n#define KASAN_SLAB_FREE\t\t0xFB   \n#define KASAN_VMALLOC_INVALID\t0xF8   \n#else\n#define KASAN_PAGE_FREE\t\tKASAN_TAG_INVALID\n#define KASAN_PAGE_REDZONE\tKASAN_TAG_INVALID\n#define KASAN_SLAB_REDZONE\tKASAN_TAG_INVALID\n#define KASAN_SLAB_FREE\t\tKASAN_TAG_INVALID\n#define KASAN_VMALLOC_INVALID\tKASAN_TAG_INVALID  \n#endif\n\n#ifdef CONFIG_KASAN_GENERIC\n\n#define KASAN_SLAB_FREETRACK\t0xFA   \n#define KASAN_GLOBAL_REDZONE\t0xF9   \n\n \n#define KASAN_STACK_LEFT\t0xF1\n#define KASAN_STACK_MID\t\t0xF2\n#define KASAN_STACK_RIGHT\t0xF3\n#define KASAN_STACK_PARTIAL\t0xF4\n\n \n#define KASAN_ALLOCA_LEFT\t0xCA\n#define KASAN_ALLOCA_RIGHT\t0xCB\n\n \n#define KASAN_ALLOCA_REDZONE_SIZE\t32\n\n \n#define KASAN_CURRENT_STACK_FRAME_MAGIC 0x41B58AB3\n\n \n#ifndef KASAN_ABI_VERSION\n#define KASAN_ABI_VERSION 1\n#endif\n\n#endif  \n\n \n#define META_BYTES_PER_BLOCK 1\n#define META_BLOCKS_PER_ROW 16\n#define META_BYTES_PER_ROW (META_BLOCKS_PER_ROW * META_BYTES_PER_BLOCK)\n#define META_MEM_BYTES_PER_ROW (META_BYTES_PER_ROW * KASAN_GRANULE_SIZE)\n#define META_ROWS_AROUND_ADDR 2\n\n#define KASAN_STACK_DEPTH 64\n\nstruct kasan_track {\n\tu32 pid;\n\tdepot_stack_handle_t stack;\n};\n\nenum kasan_report_type {\n\tKASAN_REPORT_ACCESS,\n\tKASAN_REPORT_INVALID_FREE,\n\tKASAN_REPORT_DOUBLE_FREE,\n};\n\nstruct kasan_report_info {\n\t \n\tenum kasan_report_type type;\n\tconst void *access_addr;\n\tsize_t access_size;\n\tbool is_write;\n\tunsigned long ip;\n\n\t \n\tconst void *first_bad_addr;\n\tstruct kmem_cache *cache;\n\tvoid *object;\n\tsize_t alloc_size;\n\n\t \n\tconst char *bug_type;\n\tstruct kasan_track alloc_track;\n\tstruct kasan_track free_track;\n};\n\n \nstruct kasan_source_location {\n\tconst char *filename;\n\tint line_no;\n\tint column_no;\n};\n\n \nstruct kasan_global {\n\tconst void *beg;\t\t \n\tsize_t size;\t\t\t \n\tsize_t size_with_redzone;\t \n\tconst void *name;\n\tconst void *module_name;\t \n\tunsigned long has_dynamic_init;\t \n#if KASAN_ABI_VERSION >= 4\n\tstruct kasan_source_location *location;\n#endif\n#if KASAN_ABI_VERSION >= 5\n\tchar *odr_indicator;\n#endif\n};\n\n \n\n#ifdef CONFIG_KASAN_GENERIC\n\nstruct kasan_alloc_meta {\n\tstruct kasan_track alloc_track;\n\t \n\tdepot_stack_handle_t aux_stack[2];\n};\n\nstruct qlist_node {\n\tstruct qlist_node *next;\n};\n\n \n#define KASAN_NO_FREE_META INT_MAX\n\n \nstruct kasan_free_meta {\n\tstruct qlist_node quarantine_link;\n\tstruct kasan_track free_track;\n};\n\n#endif  \n\n#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)\n\nstruct kasan_stack_ring_entry {\n\tvoid *ptr;\n\tsize_t size;\n\tu32 pid;\n\tdepot_stack_handle_t stack;\n\tbool is_free;\n};\n\nstruct kasan_stack_ring {\n\trwlock_t lock;\n\tsize_t size;\n\tatomic64_t pos;\n\tstruct kasan_stack_ring_entry *entries;\n};\n\n#endif  \n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\n\n#ifndef kasan_shadow_to_mem\nstatic inline const void *kasan_shadow_to_mem(const void *shadow_addr)\n{\n\treturn (void *)(((unsigned long)shadow_addr - KASAN_SHADOW_OFFSET)\n\t\t<< KASAN_SHADOW_SCALE_SHIFT);\n}\n#endif\n\n#ifndef addr_has_metadata\nstatic __always_inline bool addr_has_metadata(const void *addr)\n{\n\treturn (kasan_reset_tag(addr) >=\n\t\tkasan_shadow_to_mem((void *)KASAN_SHADOW_START));\n}\n#endif\n\n \nbool kasan_check_range(const void *addr, size_t size, bool write,\n\t\t\t\tunsigned long ret_ip);\n\n#else  \n\nstatic __always_inline bool addr_has_metadata(const void *addr)\n{\n\treturn (is_vmalloc_addr(addr) || virt_addr_valid(addr));\n}\n\n#endif  \n\nconst void *kasan_find_first_bad_addr(const void *addr, size_t size);\nsize_t kasan_get_alloc_size(void *object, struct kmem_cache *cache);\nvoid kasan_complete_mode_report_info(struct kasan_report_info *info);\nvoid kasan_metadata_fetch_row(char *buffer, void *row);\n\n#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)\nvoid kasan_print_tags(u8 addr_tag, const void *addr);\n#else\nstatic inline void kasan_print_tags(u8 addr_tag, const void *addr) { }\n#endif\n\n#if defined(CONFIG_KASAN_STACK)\nvoid kasan_print_address_stack_frame(const void *addr);\n#else\nstatic inline void kasan_print_address_stack_frame(const void *addr) { }\n#endif\n\n#ifdef CONFIG_KASAN_GENERIC\nvoid kasan_print_aux_stacks(struct kmem_cache *cache, const void *object);\n#else\nstatic inline void kasan_print_aux_stacks(struct kmem_cache *cache, const void *object) { }\n#endif\n\nbool kasan_report(const void *addr, size_t size,\n\t\tbool is_write, unsigned long ip);\nvoid kasan_report_invalid_free(void *object, unsigned long ip, enum kasan_report_type type);\n\nstruct slab *kasan_addr_to_slab(const void *addr);\n\n#ifdef CONFIG_KASAN_GENERIC\nvoid kasan_init_cache_meta(struct kmem_cache *cache, unsigned int *size);\nvoid kasan_init_object_meta(struct kmem_cache *cache, const void *object);\nstruct kasan_alloc_meta *kasan_get_alloc_meta(struct kmem_cache *cache,\n\t\t\t\t\t\tconst void *object);\nstruct kasan_free_meta *kasan_get_free_meta(struct kmem_cache *cache,\n\t\t\t\t\t\tconst void *object);\n#else\nstatic inline void kasan_init_cache_meta(struct kmem_cache *cache, unsigned int *size) { }\nstatic inline void kasan_init_object_meta(struct kmem_cache *cache, const void *object) { }\n#endif\n\ndepot_stack_handle_t kasan_save_stack(gfp_t flags, bool can_alloc);\nvoid kasan_set_track(struct kasan_track *track, gfp_t flags);\nvoid kasan_save_alloc_info(struct kmem_cache *cache, void *object, gfp_t flags);\nvoid kasan_save_free_info(struct kmem_cache *cache, void *object);\n\n#if defined(CONFIG_KASAN_GENERIC) && \\\n\t(defined(CONFIG_SLAB) || defined(CONFIG_SLUB))\nbool kasan_quarantine_put(struct kmem_cache *cache, void *object);\nvoid kasan_quarantine_reduce(void);\nvoid kasan_quarantine_remove_cache(struct kmem_cache *cache);\n#else\nstatic inline bool kasan_quarantine_put(struct kmem_cache *cache, void *object) { return false; }\nstatic inline void kasan_quarantine_reduce(void) { }\nstatic inline void kasan_quarantine_remove_cache(struct kmem_cache *cache) { }\n#endif\n\n#ifndef arch_kasan_set_tag\nstatic inline const void *arch_kasan_set_tag(const void *addr, u8 tag)\n{\n\treturn addr;\n}\n#endif\n#ifndef arch_kasan_get_tag\n#define arch_kasan_get_tag(addr)\t0\n#endif\n\n#define set_tag(addr, tag)\t((void *)arch_kasan_set_tag((addr), (tag)))\n#define get_tag(addr)\t\tarch_kasan_get_tag(addr)\n\n#ifdef CONFIG_KASAN_HW_TAGS\n\n#define hw_enable_tag_checks_sync()\t\tarch_enable_tag_checks_sync()\n#define hw_enable_tag_checks_async()\t\tarch_enable_tag_checks_async()\n#define hw_enable_tag_checks_asymm()\t\tarch_enable_tag_checks_asymm()\n#define hw_suppress_tag_checks_start()\t\tarch_suppress_tag_checks_start()\n#define hw_suppress_tag_checks_stop()\t\tarch_suppress_tag_checks_stop()\n#define hw_force_async_tag_fault()\t\tarch_force_async_tag_fault()\n#define hw_get_random_tag()\t\t\tarch_get_random_tag()\n#define hw_get_mem_tag(addr)\t\t\tarch_get_mem_tag(addr)\n#define hw_set_mem_tag_range(addr, size, tag, init) \\\n\t\t\tarch_set_mem_tag_range((addr), (size), (tag), (init))\n\nvoid kasan_enable_hw_tags(void);\n\n#else  \n\nstatic inline void kasan_enable_hw_tags(void) { }\n\n#endif  \n\n#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)\nvoid __init kasan_init_tags(void);\n#endif  \n\n#if defined(CONFIG_KASAN_HW_TAGS) && IS_ENABLED(CONFIG_KASAN_KUNIT_TEST)\n\nvoid kasan_force_async_fault(void);\n\n#else  \n\nstatic inline void kasan_force_async_fault(void) { }\n\n#endif  \n\n#ifdef CONFIG_KASAN_SW_TAGS\nu8 kasan_random_tag(void);\n#elif defined(CONFIG_KASAN_HW_TAGS)\nstatic inline u8 kasan_random_tag(void) { return hw_get_random_tag(); }\n#else\nstatic inline u8 kasan_random_tag(void) { return 0; }\n#endif\n\n#ifdef CONFIG_KASAN_HW_TAGS\n\nstatic inline void kasan_poison(const void *addr, size_t size, u8 value, bool init)\n{\n\taddr = kasan_reset_tag(addr);\n\n\t \n\tif (is_kfence_address(addr))\n\t\treturn;\n\n\tif (WARN_ON((unsigned long)addr & KASAN_GRANULE_MASK))\n\t\treturn;\n\tif (WARN_ON(size & KASAN_GRANULE_MASK))\n\t\treturn;\n\n\thw_set_mem_tag_range((void *)addr, size, value, init);\n}\n\nstatic inline void kasan_unpoison(const void *addr, size_t size, bool init)\n{\n\tu8 tag = get_tag(addr);\n\n\taddr = kasan_reset_tag(addr);\n\n\t \n\tif (is_kfence_address(addr))\n\t\treturn;\n\n\tif (WARN_ON((unsigned long)addr & KASAN_GRANULE_MASK))\n\t\treturn;\n\tsize = round_up(size, KASAN_GRANULE_SIZE);\n\n\thw_set_mem_tag_range((void *)addr, size, tag, init);\n}\n\nstatic inline bool kasan_byte_accessible(const void *addr)\n{\n\tu8 ptr_tag = get_tag(addr);\n\tu8 mem_tag = hw_get_mem_tag((void *)addr);\n\n\treturn ptr_tag == KASAN_TAG_KERNEL || ptr_tag == mem_tag;\n}\n\n#else  \n\n \nvoid kasan_poison(const void *addr, size_t size, u8 value, bool init);\n\n \nvoid kasan_unpoison(const void *addr, size_t size, bool init);\n\nbool kasan_byte_accessible(const void *addr);\n\n#endif  \n\n#ifdef CONFIG_KASAN_GENERIC\n\n \nvoid kasan_poison_last_granule(const void *address, size_t size);\n\n#else  \n\nstatic inline void kasan_poison_last_granule(const void *address, size_t size) { }\n\n#endif  \n\n#ifndef kasan_arch_is_ready\nstatic inline bool kasan_arch_is_ready(void)\t{ return true; }\n#elif !defined(CONFIG_KASAN_GENERIC) || !defined(CONFIG_KASAN_OUTLINE)\n#error kasan_arch_is_ready only works in KASAN generic outline mode!\n#endif\n\n#if IS_ENABLED(CONFIG_KASAN_KUNIT_TEST)\n\nvoid kasan_kunit_test_suite_start(void);\nvoid kasan_kunit_test_suite_end(void);\n\n#else  \n\nstatic inline void kasan_kunit_test_suite_start(void) { }\nstatic inline void kasan_kunit_test_suite_end(void) { }\n\n#endif  \n\n#if IS_ENABLED(CONFIG_KASAN_KUNIT_TEST) || IS_ENABLED(CONFIG_KASAN_MODULE_TEST)\n\nbool kasan_save_enable_multi_shot(void);\nvoid kasan_restore_multi_shot(bool enabled);\n\n#endif\n\n \n\nasmlinkage void kasan_unpoison_task_stack_below(const void *watermark);\nvoid __asan_register_globals(void *globals, ssize_t size);\nvoid __asan_unregister_globals(void *globals, ssize_t size);\nvoid __asan_handle_no_return(void);\nvoid __asan_alloca_poison(void *, ssize_t size);\nvoid __asan_allocas_unpoison(void *stack_top, ssize_t stack_bottom);\n\nvoid __asan_load1(void *);\nvoid __asan_store1(void *);\nvoid __asan_load2(void *);\nvoid __asan_store2(void *);\nvoid __asan_load4(void *);\nvoid __asan_store4(void *);\nvoid __asan_load8(void *);\nvoid __asan_store8(void *);\nvoid __asan_load16(void *);\nvoid __asan_store16(void *);\nvoid __asan_loadN(void *, ssize_t size);\nvoid __asan_storeN(void *, ssize_t size);\n\nvoid __asan_load1_noabort(void *);\nvoid __asan_store1_noabort(void *);\nvoid __asan_load2_noabort(void *);\nvoid __asan_store2_noabort(void *);\nvoid __asan_load4_noabort(void *);\nvoid __asan_store4_noabort(void *);\nvoid __asan_load8_noabort(void *);\nvoid __asan_store8_noabort(void *);\nvoid __asan_load16_noabort(void *);\nvoid __asan_store16_noabort(void *);\nvoid __asan_loadN_noabort(void *, ssize_t size);\nvoid __asan_storeN_noabort(void *, ssize_t size);\n\nvoid __asan_report_load1_noabort(void *);\nvoid __asan_report_store1_noabort(void *);\nvoid __asan_report_load2_noabort(void *);\nvoid __asan_report_store2_noabort(void *);\nvoid __asan_report_load4_noabort(void *);\nvoid __asan_report_store4_noabort(void *);\nvoid __asan_report_load8_noabort(void *);\nvoid __asan_report_store8_noabort(void *);\nvoid __asan_report_load16_noabort(void *);\nvoid __asan_report_store16_noabort(void *);\nvoid __asan_report_load_n_noabort(void *, ssize_t size);\nvoid __asan_report_store_n_noabort(void *, ssize_t size);\n\nvoid __asan_set_shadow_00(const void *addr, ssize_t size);\nvoid __asan_set_shadow_f1(const void *addr, ssize_t size);\nvoid __asan_set_shadow_f2(const void *addr, ssize_t size);\nvoid __asan_set_shadow_f3(const void *addr, ssize_t size);\nvoid __asan_set_shadow_f5(const void *addr, ssize_t size);\nvoid __asan_set_shadow_f8(const void *addr, ssize_t size);\n\nvoid *__asan_memset(void *addr, int c, ssize_t len);\nvoid *__asan_memmove(void *dest, const void *src, ssize_t len);\nvoid *__asan_memcpy(void *dest, const void *src, ssize_t len);\n\nvoid __hwasan_load1_noabort(void *);\nvoid __hwasan_store1_noabort(void *);\nvoid __hwasan_load2_noabort(void *);\nvoid __hwasan_store2_noabort(void *);\nvoid __hwasan_load4_noabort(void *);\nvoid __hwasan_store4_noabort(void *);\nvoid __hwasan_load8_noabort(void *);\nvoid __hwasan_store8_noabort(void *);\nvoid __hwasan_load16_noabort(void *);\nvoid __hwasan_store16_noabort(void *);\nvoid __hwasan_loadN_noabort(void *, ssize_t size);\nvoid __hwasan_storeN_noabort(void *, ssize_t size);\n\nvoid __hwasan_tag_memory(void *, u8 tag, ssize_t size);\n\nvoid *__hwasan_memset(void *addr, int c, ssize_t len);\nvoid *__hwasan_memmove(void *dest, const void *src, ssize_t len);\nvoid *__hwasan_memcpy(void *dest, const void *src, ssize_t len);\n\nvoid kasan_tag_mismatch(void *addr, unsigned long access_info,\n\t\t\tunsigned long ret_ip);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}