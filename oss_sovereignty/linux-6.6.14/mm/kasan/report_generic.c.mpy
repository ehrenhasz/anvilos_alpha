{
  "module_name": "report_generic.c",
  "hash_id": "f9b32a82e569066d13c00fc9389697587519432c24998662dd099f9b4622fabd",
  "original_prompt": "Ingested from linux-6.6.14/mm/kasan/report_generic.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/ftrace.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/stackdepot.h>\n#include <linux/stacktrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kasan.h>\n#include <linux/module.h>\n\n#include <asm/sections.h>\n\n#include \"kasan.h\"\n#include \"../slab.h\"\n\nconst void *kasan_find_first_bad_addr(const void *addr, size_t size)\n{\n\tconst void *p = addr;\n\n\tif (!addr_has_metadata(p))\n\t\treturn p;\n\n\twhile (p < addr + size && !(*(u8 *)kasan_mem_to_shadow(p)))\n\t\tp += KASAN_GRANULE_SIZE;\n\n\treturn p;\n}\n\nsize_t kasan_get_alloc_size(void *object, struct kmem_cache *cache)\n{\n\tsize_t size = 0;\n\tu8 *shadow;\n\n\t \n\n\t \n\tshadow = (u8 *)kasan_mem_to_shadow(object);\n\twhile (size < cache->object_size) {\n\t\tif (*shadow == 0)\n\t\t\tsize += KASAN_GRANULE_SIZE;\n\t\telse if (*shadow >= 1 && *shadow <= KASAN_GRANULE_SIZE - 1)\n\t\t\treturn size + *shadow;\n\t\telse\n\t\t\treturn size;\n\t\tshadow++;\n\t}\n\n\treturn cache->object_size;\n}\n\nstatic const char *get_shadow_bug_type(struct kasan_report_info *info)\n{\n\tconst char *bug_type = \"unknown-crash\";\n\tu8 *shadow_addr;\n\n\tshadow_addr = (u8 *)kasan_mem_to_shadow(info->first_bad_addr);\n\n\t \n\tif (*shadow_addr > 0 && *shadow_addr <= KASAN_GRANULE_SIZE - 1)\n\t\tshadow_addr++;\n\n\tswitch (*shadow_addr) {\n\tcase 0 ... KASAN_GRANULE_SIZE - 1:\n\t\t \n\t\tbug_type = \"out-of-bounds\";\n\t\tbreak;\n\tcase KASAN_PAGE_REDZONE:\n\tcase KASAN_SLAB_REDZONE:\n\t\tbug_type = \"slab-out-of-bounds\";\n\t\tbreak;\n\tcase KASAN_GLOBAL_REDZONE:\n\t\tbug_type = \"global-out-of-bounds\";\n\t\tbreak;\n\tcase KASAN_STACK_LEFT:\n\tcase KASAN_STACK_MID:\n\tcase KASAN_STACK_RIGHT:\n\tcase KASAN_STACK_PARTIAL:\n\t\tbug_type = \"stack-out-of-bounds\";\n\t\tbreak;\n\tcase KASAN_PAGE_FREE:\n\t\tbug_type = \"use-after-free\";\n\t\tbreak;\n\tcase KASAN_SLAB_FREE:\n\tcase KASAN_SLAB_FREETRACK:\n\t\tbug_type = \"slab-use-after-free\";\n\t\tbreak;\n\tcase KASAN_ALLOCA_LEFT:\n\tcase KASAN_ALLOCA_RIGHT:\n\t\tbug_type = \"alloca-out-of-bounds\";\n\t\tbreak;\n\tcase KASAN_VMALLOC_INVALID:\n\t\tbug_type = \"vmalloc-out-of-bounds\";\n\t\tbreak;\n\t}\n\n\treturn bug_type;\n}\n\nstatic const char *get_wild_bug_type(struct kasan_report_info *info)\n{\n\tconst char *bug_type = \"unknown-crash\";\n\n\tif ((unsigned long)info->access_addr < PAGE_SIZE)\n\t\tbug_type = \"null-ptr-deref\";\n\telse if ((unsigned long)info->access_addr < TASK_SIZE)\n\t\tbug_type = \"user-memory-access\";\n\telse\n\t\tbug_type = \"wild-memory-access\";\n\n\treturn bug_type;\n}\n\nstatic const char *get_bug_type(struct kasan_report_info *info)\n{\n\t \n\tif (info->access_addr + info->access_size < info->access_addr)\n\t\treturn \"out-of-bounds\";\n\n\tif (addr_has_metadata(info->access_addr))\n\t\treturn get_shadow_bug_type(info);\n\treturn get_wild_bug_type(info);\n}\n\nvoid kasan_complete_mode_report_info(struct kasan_report_info *info)\n{\n\tstruct kasan_alloc_meta *alloc_meta;\n\tstruct kasan_free_meta *free_meta;\n\n\tif (!info->bug_type)\n\t\tinfo->bug_type = get_bug_type(info);\n\n\tif (!info->cache || !info->object)\n\t\treturn;\n\n\talloc_meta = kasan_get_alloc_meta(info->cache, info->object);\n\tif (alloc_meta)\n\t\tmemcpy(&info->alloc_track, &alloc_meta->alloc_track,\n\t\t       sizeof(info->alloc_track));\n\n\tif (*(u8 *)kasan_mem_to_shadow(info->object) == KASAN_SLAB_FREETRACK) {\n\t\t \n\t\tfree_meta = kasan_get_free_meta(info->cache, info->object);\n\t\tmemcpy(&info->free_track, &free_meta->free_track,\n\t\t       sizeof(info->free_track));\n\t}\n}\n\nvoid kasan_metadata_fetch_row(char *buffer, void *row)\n{\n\tmemcpy(buffer, kasan_mem_to_shadow(row), META_BYTES_PER_ROW);\n}\n\nvoid kasan_print_aux_stacks(struct kmem_cache *cache, const void *object)\n{\n\tstruct kasan_alloc_meta *alloc_meta;\n\n\talloc_meta = kasan_get_alloc_meta(cache, object);\n\tif (!alloc_meta)\n\t\treturn;\n\n\tif (alloc_meta->aux_stack[0]) {\n\t\tpr_err(\"Last potentially related work creation:\\n\");\n\t\tstack_depot_print(alloc_meta->aux_stack[0]);\n\t\tpr_err(\"\\n\");\n\t}\n\tif (alloc_meta->aux_stack[1]) {\n\t\tpr_err(\"Second to last potentially related work creation:\\n\");\n\t\tstack_depot_print(alloc_meta->aux_stack[1]);\n\t\tpr_err(\"\\n\");\n\t}\n}\n\n#ifdef CONFIG_KASAN_STACK\nstatic bool __must_check tokenize_frame_descr(const char **frame_descr,\n\t\t\t\t\t      char *token, size_t max_tok_len,\n\t\t\t\t\t      unsigned long *value)\n{\n\tconst char *sep = strchr(*frame_descr, ' ');\n\n\tif (sep == NULL)\n\t\tsep = *frame_descr + strlen(*frame_descr);\n\n\tif (token != NULL) {\n\t\tconst size_t tok_len = sep - *frame_descr;\n\n\t\tif (tok_len + 1 > max_tok_len) {\n\t\t\tpr_err(\"KASAN internal error: frame description too long: %s\\n\",\n\t\t\t       *frame_descr);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tstrscpy(token, *frame_descr, tok_len + 1);\n\t}\n\n\t \n\t*frame_descr = sep + 1;\n\n\tif (value != NULL && kstrtoul(token, 10, value)) {\n\t\tpr_err(\"KASAN internal error: not a valid number: %s\\n\", token);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void print_decoded_frame_descr(const char *frame_descr)\n{\n\t \n\n\tchar token[64];\n\tunsigned long num_objects;\n\n\tif (!tokenize_frame_descr(&frame_descr, token, sizeof(token),\n\t\t\t\t  &num_objects))\n\t\treturn;\n\n\tpr_err(\"\\n\");\n\tpr_err(\"This frame has %lu %s:\\n\", num_objects,\n\t       num_objects == 1 ? \"object\" : \"objects\");\n\n\twhile (num_objects--) {\n\t\tunsigned long offset;\n\t\tunsigned long size;\n\n\t\t \n\t\tif (!tokenize_frame_descr(&frame_descr, token, sizeof(token),\n\t\t\t\t\t  &offset))\n\t\t\treturn;\n\t\t \n\t\tif (!tokenize_frame_descr(&frame_descr, token, sizeof(token),\n\t\t\t\t\t  &size))\n\t\t\treturn;\n\t\t \n\t\tif (!tokenize_frame_descr(&frame_descr, NULL, 0, NULL))\n\t\t\treturn;\n\t\t \n\t\tif (!tokenize_frame_descr(&frame_descr, token, sizeof(token),\n\t\t\t\t\t  NULL))\n\t\t\treturn;\n\n\t\t \n\t\tstrreplace(token, ':', '\\0');\n\n\t\t \n\t\tpr_err(\" [%lu, %lu) '%s'\", offset, offset + size, token);\n\t}\n}\n\n \nstatic bool __must_check get_address_stack_frame_info(const void *addr,\n\t\t\t\t\t\t      unsigned long *offset,\n\t\t\t\t\t\t      const char **frame_descr,\n\t\t\t\t\t\t      const void **frame_pc)\n{\n\tunsigned long aligned_addr;\n\tunsigned long mem_ptr;\n\tconst u8 *shadow_bottom;\n\tconst u8 *shadow_ptr;\n\tconst unsigned long *frame;\n\n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_STACK_GROWSUP));\n\n\taligned_addr = round_down((unsigned long)addr, sizeof(long));\n\tmem_ptr = round_down(aligned_addr, KASAN_GRANULE_SIZE);\n\tshadow_ptr = kasan_mem_to_shadow((void *)aligned_addr);\n\tshadow_bottom = kasan_mem_to_shadow(end_of_stack(current));\n\n\twhile (shadow_ptr >= shadow_bottom && *shadow_ptr != KASAN_STACK_LEFT) {\n\t\tshadow_ptr--;\n\t\tmem_ptr -= KASAN_GRANULE_SIZE;\n\t}\n\n\twhile (shadow_ptr >= shadow_bottom && *shadow_ptr == KASAN_STACK_LEFT) {\n\t\tshadow_ptr--;\n\t\tmem_ptr -= KASAN_GRANULE_SIZE;\n\t}\n\n\tif (shadow_ptr < shadow_bottom)\n\t\treturn false;\n\n\tframe = (const unsigned long *)(mem_ptr + KASAN_GRANULE_SIZE);\n\tif (frame[0] != KASAN_CURRENT_STACK_FRAME_MAGIC) {\n\t\tpr_err(\"KASAN internal error: frame info validation failed; invalid marker: %lu\\n\",\n\t\t       frame[0]);\n\t\treturn false;\n\t}\n\n\t*offset = (unsigned long)addr - (unsigned long)frame;\n\t*frame_descr = (const char *)frame[1];\n\t*frame_pc = (void *)frame[2];\n\n\treturn true;\n}\n\nvoid kasan_print_address_stack_frame(const void *addr)\n{\n\tunsigned long offset;\n\tconst char *frame_descr;\n\tconst void *frame_pc;\n\n\tif (WARN_ON(!object_is_on_stack(addr)))\n\t\treturn;\n\n\tpr_err(\"The buggy address belongs to stack of task %s/%d\\n\",\n\t       current->comm, task_pid_nr(current));\n\n\tif (!get_address_stack_frame_info(addr, &offset, &frame_descr,\n\t\t\t\t\t  &frame_pc))\n\t\treturn;\n\n\tpr_err(\" and is located at offset %lu in frame:\\n\", offset);\n\tpr_err(\" %pS\\n\", frame_pc);\n\n\tif (!frame_descr)\n\t\treturn;\n\n\tprint_decoded_frame_descr(frame_descr);\n}\n#endif  \n\n#define DEFINE_ASAN_REPORT_LOAD(size)                     \\\nvoid __asan_report_load##size##_noabort(void *addr) \\\n{                                                         \\\n\tkasan_report(addr, size, false, _RET_IP_);\t  \\\n}                                                         \\\nEXPORT_SYMBOL(__asan_report_load##size##_noabort)\n\n#define DEFINE_ASAN_REPORT_STORE(size)                     \\\nvoid __asan_report_store##size##_noabort(void *addr) \\\n{                                                          \\\n\tkasan_report(addr, size, true, _RET_IP_);\t   \\\n}                                                          \\\nEXPORT_SYMBOL(__asan_report_store##size##_noabort)\n\nDEFINE_ASAN_REPORT_LOAD(1);\nDEFINE_ASAN_REPORT_LOAD(2);\nDEFINE_ASAN_REPORT_LOAD(4);\nDEFINE_ASAN_REPORT_LOAD(8);\nDEFINE_ASAN_REPORT_LOAD(16);\nDEFINE_ASAN_REPORT_STORE(1);\nDEFINE_ASAN_REPORT_STORE(2);\nDEFINE_ASAN_REPORT_STORE(4);\nDEFINE_ASAN_REPORT_STORE(8);\nDEFINE_ASAN_REPORT_STORE(16);\n\nvoid __asan_report_load_n_noabort(void *addr, ssize_t size)\n{\n\tkasan_report(addr, size, false, _RET_IP_);\n}\nEXPORT_SYMBOL(__asan_report_load_n_noabort);\n\nvoid __asan_report_store_n_noabort(void *addr, ssize_t size)\n{\n\tkasan_report(addr, size, true, _RET_IP_);\n}\nEXPORT_SYMBOL(__asan_report_store_n_noabort);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}