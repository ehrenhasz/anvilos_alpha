{
  "module_name": "swap_cgroup.c",
  "hash_id": "95d1dd0f5cb764781652695e4e5e9469b9eb34d7081573b2b150b2ef3365e959",
  "original_prompt": "Ingested from linux-6.6.14/mm/swap_cgroup.c",
  "human_readable_source": "\n#include <linux/swap_cgroup.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n\n#include <linux/swapops.h>  \n\nstatic DEFINE_MUTEX(swap_cgroup_mutex);\nstruct swap_cgroup_ctrl {\n\tstruct page **map;\n\tunsigned long length;\n\tspinlock_t\tlock;\n};\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstruct swap_cgroup {\n\tunsigned short\t\tid;\n};\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\n \n\n \nstatic int swap_cgroup_prepare(int type)\n{\n\tstruct page *page;\n\tstruct swap_cgroup_ctrl *ctrl;\n\tunsigned long idx, max;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\n\tfor (idx = 0; idx < ctrl->length; idx++) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tgoto not_enough_page;\n\t\tctrl->map[idx] = page;\n\n\t\tif (!(idx % SWAP_CLUSTER_MAX))\n\t\t\tcond_resched();\n\t}\n\treturn 0;\nnot_enough_page:\n\tmax = idx;\n\tfor (idx = 0; idx < max; idx++)\n\t\t__free_page(ctrl->map[idx]);\n\n\treturn -ENOMEM;\n}\n\nstatic struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}\n\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}\n\n \nunsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\n\t\t\t\t\tunsigned short old, unsigned short new)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned long flags;\n\tunsigned short retval;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tretval = sc->id;\n\tif (retval == old)\n\t\tsc->id = new;\n\telse\n\t\tretval = 0;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\treturn retval;\n}\n\n \nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}\n\n \nunsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}\n\nint swap_cgroup_swapon(int type, unsigned long max_pages)\n{\n\tvoid *array;\n\tunsigned long length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\n\tlength = DIV_ROUND_UP(max_pages, SC_PER_PAGE);\n\n\tarray = vcalloc(length, sizeof(void *));\n\tif (!array)\n\t\tgoto nomem;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl->length = length;\n\tctrl->map = array;\n\tspin_lock_init(&ctrl->lock);\n\tif (swap_cgroup_prepare(type)) {\n\t\t \n\t\tctrl->map = NULL;\n\t\tctrl->length = 0;\n\t\tmutex_unlock(&swap_cgroup_mutex);\n\t\tvfree(array);\n\t\tgoto nomem;\n\t}\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\treturn 0;\nnomem:\n\tpr_info(\"couldn't allocate enough memory for swap_cgroup\\n\");\n\tpr_info(\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\");\n\treturn -ENOMEM;\n}\n\nvoid swap_cgroup_swapoff(int type)\n{\n\tstruct page **map;\n\tunsigned long i, length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl = &swap_cgroup_ctrl[type];\n\tmap = ctrl->map;\n\tlength = ctrl->length;\n\tctrl->map = NULL;\n\tctrl->length = 0;\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\tif (map) {\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tstruct page *page = map[i];\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t\tif (!(i % SWAP_CLUSTER_MAX))\n\t\t\t\tcond_resched();\n\t\t}\n\t\tvfree(map);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}