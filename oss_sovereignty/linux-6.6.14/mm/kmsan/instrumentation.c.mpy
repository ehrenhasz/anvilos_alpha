{
  "module_name": "instrumentation.c",
  "hash_id": "0fb461cfcde8f328ed912fea6e741f9f3e84bab1ef71f833953b6d0dc76f8c9d",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/instrumentation.c",
  "human_readable_source": "\n \n\n#include \"kmsan.h\"\n#include <linux/gfp.h>\n#include <linux/kmsan_string.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n\nstatic inline bool is_bad_asm_addr(void *addr, uintptr_t size, bool is_store)\n{\n\tif ((u64)addr < TASK_SIZE)\n\t\treturn true;\n\tif (!kmsan_get_metadata(addr, KMSAN_META_SHADOW))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline struct shadow_origin_ptr\nget_shadow_origin_ptr(void *addr, u64 size, bool store)\n{\n\tunsigned long ua_flags = user_access_save();\n\tstruct shadow_origin_ptr ret;\n\n\tret = kmsan_get_shadow_origin_ptr(addr, size, store);\n\tuser_access_restore(ua_flags);\n\treturn ret;\n}\n\n \n\n \nstruct shadow_origin_ptr __msan_metadata_ptr_for_load_n(void *addr,\n\t\t\t\t\t\t\tuintptr_t size);\nstruct shadow_origin_ptr __msan_metadata_ptr_for_load_n(void *addr,\n\t\t\t\t\t\t\tuintptr_t size)\n{\n\treturn get_shadow_origin_ptr(addr, size,   false);\n}\nEXPORT_SYMBOL(__msan_metadata_ptr_for_load_n);\n\n \nstruct shadow_origin_ptr __msan_metadata_ptr_for_store_n(void *addr,\n\t\t\t\t\t\t\t uintptr_t size);\nstruct shadow_origin_ptr __msan_metadata_ptr_for_store_n(void *addr,\n\t\t\t\t\t\t\t uintptr_t size)\n{\n\treturn get_shadow_origin_ptr(addr, size,   true);\n}\nEXPORT_SYMBOL(__msan_metadata_ptr_for_store_n);\n\n \n#define DECLARE_METADATA_PTR_GETTER(size)                                  \\\n\tstruct shadow_origin_ptr __msan_metadata_ptr_for_load_##size(      \\\n\t\tvoid *addr);                                               \\\n\tstruct shadow_origin_ptr __msan_metadata_ptr_for_load_##size(      \\\n\t\tvoid *addr)                                                \\\n\t{                                                                  \\\n\t\treturn get_shadow_origin_ptr(addr, size,   false); \\\n\t}                                                                  \\\n\tEXPORT_SYMBOL(__msan_metadata_ptr_for_load_##size);                \\\n\tstruct shadow_origin_ptr __msan_metadata_ptr_for_store_##size(     \\\n\t\tvoid *addr);                                               \\\n\tstruct shadow_origin_ptr __msan_metadata_ptr_for_store_##size(     \\\n\t\tvoid *addr)                                                \\\n\t{                                                                  \\\n\t\treturn get_shadow_origin_ptr(addr, size,   true);  \\\n\t}                                                                  \\\n\tEXPORT_SYMBOL(__msan_metadata_ptr_for_store_##size)\n\nDECLARE_METADATA_PTR_GETTER(1);\nDECLARE_METADATA_PTR_GETTER(2);\nDECLARE_METADATA_PTR_GETTER(4);\nDECLARE_METADATA_PTR_GETTER(8);\n\n \nvoid __msan_instrument_asm_store(void *addr, uintptr_t size);\nvoid __msan_instrument_asm_store(void *addr, uintptr_t size)\n{\n\tunsigned long ua_flags;\n\n\tif (!kmsan_enabled)\n\t\treturn;\n\n\tua_flags = user_access_save();\n\t \n\tif (size > 512) {\n\t\tWARN_ONCE(1, \"assembly store size too big: %ld\\n\", size);\n\t\tsize = 8;\n\t}\n\tif (is_bad_asm_addr(addr, size,   true)) {\n\t\tuser_access_restore(ua_flags);\n\t\treturn;\n\t}\n\t \n\tkmsan_internal_unpoison_memory(addr, size,   false);\n\tuser_access_restore(ua_flags);\n}\nEXPORT_SYMBOL(__msan_instrument_asm_store);\n\n \nstatic inline void get_param0_metadata(u64 *shadow,\n\t\t\t\t       depot_stack_handle_t *origin)\n{\n\tstruct kmsan_ctx *ctx = kmsan_get_context();\n\n\t*shadow = *(u64 *)(ctx->cstate.param_tls);\n\t*origin = ctx->cstate.param_origin_tls[0];\n}\n\nstatic inline void set_retval_metadata(u64 shadow, depot_stack_handle_t origin)\n{\n\tstruct kmsan_ctx *ctx = kmsan_get_context();\n\n\t*(u64 *)(ctx->cstate.retval_tls) = shadow;\n\tctx->cstate.retval_origin_tls = origin;\n}\n\n \nvoid *__msan_memmove(void *dst, const void *src, uintptr_t n);\nvoid *__msan_memmove(void *dst, const void *src, uintptr_t n)\n{\n\tdepot_stack_handle_t origin;\n\tvoid *result;\n\tu64 shadow;\n\n\tget_param0_metadata(&shadow, &origin);\n\tresult = __memmove(dst, src, n);\n\tif (!n)\n\t\t \n\t\treturn result;\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn result;\n\n\tkmsan_enter_runtime();\n\tkmsan_internal_memmove_metadata(dst, (void *)src, n);\n\tkmsan_leave_runtime();\n\n\tset_retval_metadata(shadow, origin);\n\treturn result;\n}\nEXPORT_SYMBOL(__msan_memmove);\n\n \nvoid *__msan_memcpy(void *dst, const void *src, uintptr_t n);\nvoid *__msan_memcpy(void *dst, const void *src, uintptr_t n)\n{\n\tdepot_stack_handle_t origin;\n\tvoid *result;\n\tu64 shadow;\n\n\tget_param0_metadata(&shadow, &origin);\n\tresult = __memcpy(dst, src, n);\n\tif (!n)\n\t\t \n\t\treturn result;\n\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn result;\n\n\tkmsan_enter_runtime();\n\t \n\tkmsan_internal_memmove_metadata(dst, (void *)src, n);\n\tkmsan_leave_runtime();\n\n\tset_retval_metadata(shadow, origin);\n\treturn result;\n}\nEXPORT_SYMBOL(__msan_memcpy);\n\n \nvoid *__msan_memset(void *dst, int c, uintptr_t n);\nvoid *__msan_memset(void *dst, int c, uintptr_t n)\n{\n\tdepot_stack_handle_t origin;\n\tvoid *result;\n\tu64 shadow;\n\n\tget_param0_metadata(&shadow, &origin);\n\tresult = __memset(dst, c, n);\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn result;\n\n\tkmsan_enter_runtime();\n\t \n\tkmsan_internal_unpoison_memory(dst, n,   false);\n\tkmsan_leave_runtime();\n\n\tset_retval_metadata(shadow, origin);\n\treturn result;\n}\nEXPORT_SYMBOL(__msan_memset);\n\n \ndepot_stack_handle_t __msan_chain_origin(depot_stack_handle_t origin);\ndepot_stack_handle_t __msan_chain_origin(depot_stack_handle_t origin)\n{\n\tdepot_stack_handle_t ret = 0;\n\tunsigned long ua_flags;\n\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn ret;\n\n\tua_flags = user_access_save();\n\n\t \n\tkmsan_enter_runtime();\n\tret = kmsan_internal_chain_origin(origin);\n\tkmsan_leave_runtime();\n\tuser_access_restore(ua_flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(__msan_chain_origin);\n\n \nvoid __msan_poison_alloca(void *address, uintptr_t size, char *descr);\nvoid __msan_poison_alloca(void *address, uintptr_t size, char *descr)\n{\n\tdepot_stack_handle_t handle;\n\tunsigned long entries[4];\n\tunsigned long ua_flags;\n\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn;\n\n\tua_flags = user_access_save();\n\tentries[0] = KMSAN_ALLOCA_MAGIC_ORIGIN;\n\tentries[1] = (u64)descr;\n\tentries[2] = (u64)__builtin_return_address(0);\n\t \n\tif (IS_ENABLED(CONFIG_UNWINDER_FRAME_POINTER))\n\t\tentries[3] = (u64)__builtin_return_address(1);\n\telse\n\t\tentries[3] = 0;\n\n\t \n\tkmsan_enter_runtime();\n\thandle = stack_depot_save(entries, ARRAY_SIZE(entries), __GFP_HIGH);\n\tkmsan_leave_runtime();\n\n\tkmsan_internal_set_shadow_origin(address, size, -1, handle,\n\t\t\t\t\t   true);\n\tuser_access_restore(ua_flags);\n}\nEXPORT_SYMBOL(__msan_poison_alloca);\n\n \nvoid __msan_unpoison_alloca(void *address, uintptr_t size);\nvoid __msan_unpoison_alloca(void *address, uintptr_t size)\n{\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn;\n\n\tkmsan_enter_runtime();\n\tkmsan_internal_unpoison_memory(address, size,   true);\n\tkmsan_leave_runtime();\n}\nEXPORT_SYMBOL(__msan_unpoison_alloca);\n\n \nvoid __msan_warning(u32 origin);\nvoid __msan_warning(u32 origin)\n{\n\tif (!kmsan_enabled || kmsan_in_runtime())\n\t\treturn;\n\tkmsan_enter_runtime();\n\tkmsan_report(origin,   0,   0,\n\t\t       0,   0,   0,\n\t\t     REASON_ANY);\n\tkmsan_leave_runtime();\n}\nEXPORT_SYMBOL(__msan_warning);\n\n \nstruct kmsan_context_state *__msan_get_context_state(void);\nstruct kmsan_context_state *__msan_get_context_state(void)\n{\n\treturn &kmsan_get_context()->cstate;\n}\nEXPORT_SYMBOL(__msan_get_context_state);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}