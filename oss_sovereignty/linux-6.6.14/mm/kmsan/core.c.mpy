{
  "module_name": "core.c",
  "hash_id": "09c59fb60bd3f347ba39fe2ab6f01a573b98e7854b2775c649a3c4cf69cf51f4",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/core.c",
  "human_readable_source": "\n \n\n#include <asm/page.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kmsan_types.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mm_types.h>\n#include <linux/mmzone.h>\n#include <linux/percpu-defs.h>\n#include <linux/preempt.h>\n#include <linux/slab.h>\n#include <linux/stackdepot.h>\n#include <linux/stacktrace.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\n#include \"../slab.h\"\n#include \"kmsan.h\"\n\nbool kmsan_enabled __read_mostly;\n\n \nDEFINE_PER_CPU(struct kmsan_ctx, kmsan_percpu_ctx);\n\nvoid kmsan_internal_task_create(struct task_struct *task)\n{\n\tstruct kmsan_ctx *ctx = &task->kmsan_ctx;\n\tstruct thread_info *info = current_thread_info();\n\n\t__memset(ctx, 0, sizeof(*ctx));\n\tctx->allow_reporting = true;\n\tkmsan_internal_unpoison_memory(info, sizeof(*info), false);\n}\n\nvoid kmsan_internal_poison_memory(void *address, size_t size, gfp_t flags,\n\t\t\t\t  unsigned int poison_flags)\n{\n\tu32 extra_bits =\n\t\tkmsan_extra_bits(  0, poison_flags & KMSAN_POISON_FREE);\n\tbool checked = poison_flags & KMSAN_POISON_CHECK;\n\tdepot_stack_handle_t handle;\n\n\thandle = kmsan_save_stack_with_flags(flags, extra_bits);\n\tkmsan_internal_set_shadow_origin(address, size, -1, handle, checked);\n}\n\nvoid kmsan_internal_unpoison_memory(void *address, size_t size, bool checked)\n{\n\tkmsan_internal_set_shadow_origin(address, size, 0, 0, checked);\n}\n\ndepot_stack_handle_t kmsan_save_stack_with_flags(gfp_t flags,\n\t\t\t\t\t\t unsigned int extra)\n{\n\tunsigned long entries[KMSAN_STACK_DEPTH];\n\tunsigned int nr_entries;\n\tdepot_stack_handle_t handle;\n\n\tnr_entries = stack_trace_save(entries, KMSAN_STACK_DEPTH, 0);\n\n\t \n\tflags &= ~(__GFP_DIRECT_RECLAIM | __GFP_KSWAPD_RECLAIM);\n\n\thandle = __stack_depot_save(entries, nr_entries, flags, true);\n\treturn stack_depot_set_extra_bits(handle, extra);\n}\n\n \nvoid kmsan_internal_memmove_metadata(void *dst, void *src, size_t n)\n{\n\tdepot_stack_handle_t old_origin = 0, new_origin = 0;\n\tint src_slots, dst_slots, i, iter, step, skip_bits;\n\tdepot_stack_handle_t *origin_src, *origin_dst;\n\tvoid *shadow_src, *shadow_dst;\n\tu32 *align_shadow_src, shadow;\n\tbool backwards;\n\n\tshadow_dst = kmsan_get_metadata(dst, KMSAN_META_SHADOW);\n\tif (!shadow_dst)\n\t\treturn;\n\tKMSAN_WARN_ON(!kmsan_metadata_is_contiguous(dst, n));\n\n\tshadow_src = kmsan_get_metadata(src, KMSAN_META_SHADOW);\n\tif (!shadow_src) {\n\t\t \n\t\t__memset(shadow_dst, 0, n);\n\t\treturn;\n\t}\n\tKMSAN_WARN_ON(!kmsan_metadata_is_contiguous(src, n));\n\n\t__memmove(shadow_dst, shadow_src, n);\n\n\torigin_dst = kmsan_get_metadata(dst, KMSAN_META_ORIGIN);\n\torigin_src = kmsan_get_metadata(src, KMSAN_META_ORIGIN);\n\tKMSAN_WARN_ON(!origin_dst || !origin_src);\n\tsrc_slots = (ALIGN((u64)src + n, KMSAN_ORIGIN_SIZE) -\n\t\t     ALIGN_DOWN((u64)src, KMSAN_ORIGIN_SIZE)) /\n\t\t    KMSAN_ORIGIN_SIZE;\n\tdst_slots = (ALIGN((u64)dst + n, KMSAN_ORIGIN_SIZE) -\n\t\t     ALIGN_DOWN((u64)dst, KMSAN_ORIGIN_SIZE)) /\n\t\t    KMSAN_ORIGIN_SIZE;\n\tKMSAN_WARN_ON((src_slots < 1) || (dst_slots < 1));\n\tKMSAN_WARN_ON((src_slots - dst_slots > 1) ||\n\t\t      (dst_slots - src_slots < -1));\n\n\tbackwards = dst > src;\n\ti = backwards ? min(src_slots, dst_slots) - 1 : 0;\n\titer = backwards ? -1 : 1;\n\n\talign_shadow_src =\n\t\t(u32 *)ALIGN_DOWN((u64)shadow_src, KMSAN_ORIGIN_SIZE);\n\tfor (step = 0; step < min(src_slots, dst_slots); step++, i += iter) {\n\t\tKMSAN_WARN_ON(i < 0);\n\t\tshadow = align_shadow_src[i];\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tskip_bits = ((u64)src % KMSAN_ORIGIN_SIZE) * 8;\n\t\t\tshadow = (shadow >> skip_bits) << skip_bits;\n\t\t}\n\t\tif (i == src_slots - 1) {\n\t\t\t \n\t\t\tskip_bits = (((u64)src + n) % KMSAN_ORIGIN_SIZE) * 8;\n\t\t\tshadow = (shadow << skip_bits) >> skip_bits;\n\t\t}\n\t\t \n\t\tif (origin_src[i] && (origin_src[i] != old_origin) && shadow) {\n\t\t\told_origin = origin_src[i];\n\t\t\tnew_origin = kmsan_internal_chain_origin(old_origin);\n\t\t\t \n\t\t\tif (!new_origin)\n\t\t\t\tnew_origin = old_origin;\n\t\t}\n\t\tif (shadow)\n\t\t\torigin_dst[i] = new_origin;\n\t\telse\n\t\t\torigin_dst[i] = 0;\n\t}\n\t \n\tif (src_slots < dst_slots) {\n\t\tif (backwards) {\n\t\t\tshadow = align_shadow_src[src_slots - 1];\n\t\t\tskip_bits = (((u64)dst + n) % KMSAN_ORIGIN_SIZE) * 8;\n\t\t\tshadow = (shadow << skip_bits) >> skip_bits;\n\t\t\tif (shadow)\n\t\t\t\t \n\t\t\t\torigin_dst[dst_slots - 1] =\n\t\t\t\t\torigin_dst[dst_slots - 2];\n\t\t} else {\n\t\t\tshadow = align_shadow_src[0];\n\t\t\tskip_bits = ((u64)dst % KMSAN_ORIGIN_SIZE) * 8;\n\t\t\tshadow = (shadow >> skip_bits) << skip_bits;\n\t\t\tif (shadow)\n\t\t\t\torigin_dst[0] = origin_dst[1];\n\t\t}\n\t}\n}\n\ndepot_stack_handle_t kmsan_internal_chain_origin(depot_stack_handle_t id)\n{\n\tunsigned long entries[3];\n\tu32 extra_bits;\n\tint depth;\n\tbool uaf;\n\tdepot_stack_handle_t handle;\n\n\tif (!id)\n\t\treturn id;\n\t \n\tBUILD_BUG_ON(\n\t\t(1 << STACK_DEPOT_EXTRA_BITS) <= (KMSAN_MAX_ORIGIN_DEPTH << 1));\n\n\textra_bits = stack_depot_get_extra_bits(id);\n\tdepth = kmsan_depth_from_eb(extra_bits);\n\tuaf = kmsan_uaf_from_eb(extra_bits);\n\n\t \n\tif (depth == KMSAN_MAX_ORIGIN_DEPTH)\n\t\treturn id;\n\n\tdepth++;\n\textra_bits = kmsan_extra_bits(depth, uaf);\n\n\tentries[0] = KMSAN_CHAIN_MAGIC_ORIGIN;\n\tentries[1] = kmsan_save_stack_with_flags(__GFP_HIGH, 0);\n\tentries[2] = id;\n\t \n\tkmsan_internal_unpoison_memory(entries, sizeof(entries), false);\n\thandle = __stack_depot_save(entries, ARRAY_SIZE(entries), __GFP_HIGH,\n\t\t\t\t    true);\n\treturn stack_depot_set_extra_bits(handle, extra_bits);\n}\n\nvoid kmsan_internal_set_shadow_origin(void *addr, size_t size, int b,\n\t\t\t\t      u32 origin, bool checked)\n{\n\tu64 address = (u64)addr;\n\tvoid *shadow_start;\n\tu32 *origin_start;\n\tsize_t pad = 0;\n\n\tKMSAN_WARN_ON(!kmsan_metadata_is_contiguous(addr, size));\n\tshadow_start = kmsan_get_metadata(addr, KMSAN_META_SHADOW);\n\tif (!shadow_start) {\n\t\t \n\t\tif (checked) {\n\t\t\tpr_err(\"%s: not memsetting %ld bytes starting at %px, because the shadow is NULL\\n\",\n\t\t\t       __func__, size, addr);\n\t\t\tKMSAN_WARN_ON(true);\n\t\t}\n\t\treturn;\n\t}\n\t__memset(shadow_start, b, size);\n\n\tif (!IS_ALIGNED(address, KMSAN_ORIGIN_SIZE)) {\n\t\tpad = address % KMSAN_ORIGIN_SIZE;\n\t\taddress -= pad;\n\t\tsize += pad;\n\t}\n\tsize = ALIGN(size, KMSAN_ORIGIN_SIZE);\n\torigin_start =\n\t\t(u32 *)kmsan_get_metadata((void *)address, KMSAN_META_ORIGIN);\n\n\tfor (int i = 0; i < size / KMSAN_ORIGIN_SIZE; i++)\n\t\torigin_start[i] = origin;\n}\n\nstruct page *kmsan_vmalloc_to_page_or_null(void *vaddr)\n{\n\tstruct page *page;\n\n\tif (!kmsan_internal_is_vmalloc_addr(vaddr) &&\n\t    !kmsan_internal_is_module_addr(vaddr))\n\t\treturn NULL;\n\tpage = vmalloc_to_page(vaddr);\n\tif (pfn_valid(page_to_pfn(page)))\n\t\treturn page;\n\telse\n\t\treturn NULL;\n}\n\nvoid kmsan_internal_check_memory(void *addr, size_t size, const void *user_addr,\n\t\t\t\t int reason)\n{\n\tdepot_stack_handle_t cur_origin = 0, new_origin = 0;\n\tunsigned long addr64 = (unsigned long)addr;\n\tdepot_stack_handle_t *origin = NULL;\n\tunsigned char *shadow = NULL;\n\tint cur_off_start = -1;\n\tint chunk_size;\n\tsize_t pos = 0;\n\n\tif (!size)\n\t\treturn;\n\tKMSAN_WARN_ON(!kmsan_metadata_is_contiguous(addr, size));\n\twhile (pos < size) {\n\t\tchunk_size = min(size - pos,\n\t\t\t\t PAGE_SIZE - ((addr64 + pos) % PAGE_SIZE));\n\t\tshadow = kmsan_get_metadata((void *)(addr64 + pos),\n\t\t\t\t\t    KMSAN_META_SHADOW);\n\t\tif (!shadow) {\n\t\t\t \n\t\t\tif (cur_origin) {\n\t\t\t\tkmsan_enter_runtime();\n\t\t\t\tkmsan_report(cur_origin, addr, size,\n\t\t\t\t\t     cur_off_start, pos - 1, user_addr,\n\t\t\t\t\t     reason);\n\t\t\t\tkmsan_leave_runtime();\n\t\t\t}\n\t\t\tcur_origin = 0;\n\t\t\tcur_off_start = -1;\n\t\t\tpos += chunk_size;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < chunk_size; i++) {\n\t\t\tif (!shadow[i]) {\n\t\t\t\t \n\t\t\t\tif (cur_origin) {\n\t\t\t\t\tkmsan_enter_runtime();\n\t\t\t\t\tkmsan_report(cur_origin, addr, size,\n\t\t\t\t\t\t     cur_off_start, pos + i - 1,\n\t\t\t\t\t\t     user_addr, reason);\n\t\t\t\t\tkmsan_leave_runtime();\n\t\t\t\t}\n\t\t\t\tcur_origin = 0;\n\t\t\t\tcur_off_start = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\torigin = kmsan_get_metadata((void *)(addr64 + pos + i),\n\t\t\t\t\t\t    KMSAN_META_ORIGIN);\n\t\t\tKMSAN_WARN_ON(!origin);\n\t\t\tnew_origin = *origin;\n\t\t\t \n\t\t\tif (cur_origin != new_origin) {\n\t\t\t\tif (cur_origin) {\n\t\t\t\t\tkmsan_enter_runtime();\n\t\t\t\t\tkmsan_report(cur_origin, addr, size,\n\t\t\t\t\t\t     cur_off_start, pos + i - 1,\n\t\t\t\t\t\t     user_addr, reason);\n\t\t\t\t\tkmsan_leave_runtime();\n\t\t\t\t}\n\t\t\t\tcur_origin = new_origin;\n\t\t\t\tcur_off_start = pos + i;\n\t\t\t}\n\t\t}\n\t\tpos += chunk_size;\n\t}\n\tKMSAN_WARN_ON(pos != size);\n\tif (cur_origin) {\n\t\tkmsan_enter_runtime();\n\t\tkmsan_report(cur_origin, addr, size, cur_off_start, pos - 1,\n\t\t\t     user_addr, reason);\n\t\tkmsan_leave_runtime();\n\t}\n}\n\nbool kmsan_metadata_is_contiguous(void *addr, size_t size)\n{\n\tchar *cur_shadow = NULL, *next_shadow = NULL, *cur_origin = NULL,\n\t     *next_origin = NULL;\n\tu64 cur_addr = (u64)addr, next_addr = cur_addr + PAGE_SIZE;\n\tdepot_stack_handle_t *origin_p;\n\tbool all_untracked = false;\n\n\tif (!size)\n\t\treturn true;\n\n\t \n\tif (ALIGN_DOWN(cur_addr + size - 1, PAGE_SIZE) ==\n\t    ALIGN_DOWN(cur_addr, PAGE_SIZE))\n\t\treturn true;\n\n\tcur_shadow = kmsan_get_metadata((void *)cur_addr,   false);\n\tif (!cur_shadow)\n\t\tall_untracked = true;\n\tcur_origin = kmsan_get_metadata((void *)cur_addr,   true);\n\tif (all_untracked && cur_origin)\n\t\tgoto report;\n\n\tfor (; next_addr < (u64)addr + size;\n\t     cur_addr = next_addr, cur_shadow = next_shadow,\n\t     cur_origin = next_origin, next_addr += PAGE_SIZE) {\n\t\tnext_shadow = kmsan_get_metadata((void *)next_addr, false);\n\t\tnext_origin = kmsan_get_metadata((void *)next_addr, true);\n\t\tif (all_untracked) {\n\t\t\tif (next_shadow || next_origin)\n\t\t\t\tgoto report;\n\t\t\tif (!next_shadow && !next_origin)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (((u64)cur_shadow == ((u64)next_shadow - PAGE_SIZE)) &&\n\t\t    ((u64)cur_origin == ((u64)next_origin - PAGE_SIZE)))\n\t\t\tcontinue;\n\t\tgoto report;\n\t}\n\treturn true;\n\nreport:\n\tpr_err(\"%s: attempting to access two shadow page ranges.\\n\", __func__);\n\tpr_err(\"Access of size %ld at %px.\\n\", size, addr);\n\tpr_err(\"Addresses belonging to different ranges: %px and %px\\n\",\n\t       (void *)cur_addr, (void *)next_addr);\n\tpr_err(\"page[0].shadow: %px, page[1].shadow: %px\\n\", cur_shadow,\n\t       next_shadow);\n\tpr_err(\"page[0].origin: %px, page[1].origin: %px\\n\", cur_origin,\n\t       next_origin);\n\torigin_p = kmsan_get_metadata(addr, KMSAN_META_ORIGIN);\n\tif (origin_p) {\n\t\tpr_err(\"Origin: %08x\\n\", *origin_p);\n\t\tkmsan_print_origin(*origin_p);\n\t} else {\n\t\tpr_err(\"Origin: unavailable\\n\");\n\t}\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}