{
  "module_name": "report.c",
  "hash_id": "8ce95710c911fb6ed12f133cda888c251026d3eae5fdf16d31194e71a6b73f43",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/report.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/moduleparam.h>\n#include <linux/stackdepot.h>\n#include <linux/stacktrace.h>\n#include <linux/uaccess.h>\n\n#include \"kmsan.h\"\n\nstatic DEFINE_RAW_SPINLOCK(kmsan_report_lock);\n#define DESCR_SIZE 128\n \nstatic char report_local_descr[DESCR_SIZE];\nint panic_on_kmsan __read_mostly;\n\n#ifdef MODULE_PARAM_PREFIX\n#undef MODULE_PARAM_PREFIX\n#endif\n#define MODULE_PARAM_PREFIX \"kmsan.\"\nmodule_param_named(panic, panic_on_kmsan, int, 0);\n\n \nstatic int get_stack_skipnr(const unsigned long stack_entries[],\n\t\t\t    int num_entries)\n{\n\tint len, skip;\n\tchar buf[64];\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\",\n\t\t\t\t(void *)stack_entries[skip]);\n\n\t\t \n\t\tif ((strnstr(buf, \"__msan_\", len) == buf) ||\n\t\t    (strnstr(buf, \"kmsan_\", len) == buf))\n\t\t\tcontinue;\n\n\t\t \n\t\tbreak;\n\t}\n\n\treturn skip;\n}\n\n \nstatic char *pretty_descr(char *descr)\n{\n\tint pos = 0, len = strlen(descr);\n\n\tfor (int i = 0; i < len; i++) {\n\t\tif (descr[i] == '@')\n\t\t\tbreak;\n\t\tif (descr[i] == '-')\n\t\t\tcontinue;\n\t\treport_local_descr[pos] = descr[i];\n\t\tif (pos + 1 == DESCR_SIZE)\n\t\t\tbreak;\n\t\tpos++;\n\t}\n\treport_local_descr[pos] = 0;\n\treturn report_local_descr;\n}\n\nvoid kmsan_print_origin(depot_stack_handle_t origin)\n{\n\tunsigned long *entries = NULL, *chained_entries = NULL;\n\tunsigned int nr_entries, chained_nr_entries, skipnr;\n\tvoid *pc1 = NULL, *pc2 = NULL;\n\tdepot_stack_handle_t head;\n\tunsigned long magic;\n\tchar *descr = NULL;\n\tunsigned int depth;\n\n\tif (!origin)\n\t\treturn;\n\n\twhile (true) {\n\t\tnr_entries = stack_depot_fetch(origin, &entries);\n\t\tdepth = kmsan_depth_from_eb(stack_depot_get_extra_bits(origin));\n\t\tmagic = nr_entries ? entries[0] : 0;\n\t\tif ((nr_entries == 4) && (magic == KMSAN_ALLOCA_MAGIC_ORIGIN)) {\n\t\t\tdescr = (char *)entries[1];\n\t\t\tpc1 = (void *)entries[2];\n\t\t\tpc2 = (void *)entries[3];\n\t\t\tpr_err(\"Local variable %s created at:\\n\",\n\t\t\t       pretty_descr(descr));\n\t\t\tif (pc1)\n\t\t\t\tpr_err(\" %pSb\\n\", pc1);\n\t\t\tif (pc2)\n\t\t\t\tpr_err(\" %pSb\\n\", pc2);\n\t\t\tbreak;\n\t\t}\n\t\tif ((nr_entries == 3) && (magic == KMSAN_CHAIN_MAGIC_ORIGIN)) {\n\t\t\t \n\t\t\tif (depth == KMSAN_MAX_ORIGIN_DEPTH)\n\t\t\t\tpr_err(\"<Zero or more stacks not recorded to save memory>\\n\\n\");\n\t\t\thead = entries[1];\n\t\t\torigin = entries[2];\n\t\t\tpr_err(\"Uninit was stored to memory at:\\n\");\n\t\t\tchained_nr_entries =\n\t\t\t\tstack_depot_fetch(head, &chained_entries);\n\t\t\tkmsan_internal_unpoison_memory(\n\t\t\t\tchained_entries,\n\t\t\t\tchained_nr_entries * sizeof(*chained_entries),\n\t\t\t\t  false);\n\t\t\tskipnr = get_stack_skipnr(chained_entries,\n\t\t\t\t\t\t  chained_nr_entries);\n\t\t\tstack_trace_print(chained_entries + skipnr,\n\t\t\t\t\t  chained_nr_entries - skipnr, 0);\n\t\t\tpr_err(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tpr_err(\"Uninit was created at:\\n\");\n\t\tif (nr_entries) {\n\t\t\tskipnr = get_stack_skipnr(entries, nr_entries);\n\t\t\tstack_trace_print(entries + skipnr, nr_entries - skipnr,\n\t\t\t\t\t  0);\n\t\t} else {\n\t\t\tpr_err(\"(stack is not available)\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid kmsan_report(depot_stack_handle_t origin, void *address, int size,\n\t\t  int off_first, int off_last, const void *user_addr,\n\t\t  enum kmsan_bug_reason reason)\n{\n\tunsigned long stack_entries[KMSAN_STACK_DEPTH];\n\tint num_stack_entries, skipnr;\n\tchar *bug_type = NULL;\n\tunsigned long ua_flags;\n\tbool is_uaf;\n\n\tif (!kmsan_enabled)\n\t\treturn;\n\tif (!current->kmsan_ctx.allow_reporting)\n\t\treturn;\n\tif (!origin)\n\t\treturn;\n\n\tcurrent->kmsan_ctx.allow_reporting = false;\n\tua_flags = user_access_save();\n\traw_spin_lock(&kmsan_report_lock);\n\tpr_err(\"=====================================================\\n\");\n\tis_uaf = kmsan_uaf_from_eb(stack_depot_get_extra_bits(origin));\n\tswitch (reason) {\n\tcase REASON_ANY:\n\t\tbug_type = is_uaf ? \"use-after-free\" : \"uninit-value\";\n\t\tbreak;\n\tcase REASON_COPY_TO_USER:\n\t\tbug_type = is_uaf ? \"kernel-infoleak-after-free\" :\n\t\t\t\t    \"kernel-infoleak\";\n\t\tbreak;\n\tcase REASON_SUBMIT_URB:\n\t\tbug_type = is_uaf ? \"kernel-usb-infoleak-after-free\" :\n\t\t\t\t    \"kernel-usb-infoleak\";\n\t\tbreak;\n\t}\n\n\tnum_stack_entries =\n\t\tstack_trace_save(stack_entries, KMSAN_STACK_DEPTH, 1);\n\tskipnr = get_stack_skipnr(stack_entries, num_stack_entries);\n\n\tpr_err(\"BUG: KMSAN: %s in %pSb\\n\", bug_type,\n\t       (void *)stack_entries[skipnr]);\n\tstack_trace_print(stack_entries + skipnr, num_stack_entries - skipnr,\n\t\t\t  0);\n\tpr_err(\"\\n\");\n\n\tkmsan_print_origin(origin);\n\n\tif (size) {\n\t\tpr_err(\"\\n\");\n\t\tif (off_first == off_last)\n\t\t\tpr_err(\"Byte %d of %d is uninitialized\\n\", off_first,\n\t\t\t       size);\n\t\telse\n\t\t\tpr_err(\"Bytes %d-%d of %d are uninitialized\\n\",\n\t\t\t       off_first, off_last, size);\n\t}\n\tif (address)\n\t\tpr_err(\"Memory access of size %d starts at %px\\n\", size,\n\t\t       address);\n\tif (user_addr && reason == REASON_COPY_TO_USER)\n\t\tpr_err(\"Data copied to user address %px\\n\", user_addr);\n\tpr_err(\"\\n\");\n\tdump_stack_print_info(KERN_ERR);\n\tpr_err(\"=====================================================\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\traw_spin_unlock(&kmsan_report_lock);\n\tif (panic_on_kmsan)\n\t\tpanic(\"kmsan.panic set ...\\n\");\n\tuser_access_restore(ua_flags);\n\tcurrent->kmsan_ctx.allow_reporting = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}