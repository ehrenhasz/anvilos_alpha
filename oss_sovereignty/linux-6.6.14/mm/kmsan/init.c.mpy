{
  "module_name": "init.c",
  "hash_id": "a4c3171294738338dddc3e9ac950bd11d3a436f7b202cec4b23171ad6e61dc04",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/init.c",
  "human_readable_source": "\n \n\n#include \"kmsan.h\"\n\n#include <asm/sections.h>\n#include <linux/mm.h>\n#include <linux/memblock.h>\n\n#include \"../internal.h\"\n\n#define NUM_FUTURE_RANGES 128\nstruct start_end_pair {\n\tu64 start, end;\n};\n\nstatic struct start_end_pair start_end_pairs[NUM_FUTURE_RANGES] __initdata;\nstatic int future_index __initdata;\n\n \nstatic void __init kmsan_record_future_shadow_range(void *start, void *end)\n{\n\tu64 nstart = (u64)start, nend = (u64)end, cstart, cend;\n\tbool merged = false;\n\n\tKMSAN_WARN_ON(future_index == NUM_FUTURE_RANGES);\n\tKMSAN_WARN_ON((nstart >= nend) || !nstart || !nend);\n\tnstart = ALIGN_DOWN(nstart, PAGE_SIZE);\n\tnend = ALIGN(nend, PAGE_SIZE);\n\n\t \n\tfor (int i = 0; i < future_index; i++) {\n\t\tcstart = start_end_pairs[i].start;\n\t\tcend = start_end_pairs[i].end;\n\t\tif ((cstart < nstart && cend < nstart) ||\n\t\t    (cstart > nend && cend > nend))\n\t\t\t \n\t\t\tcontinue;\n\t\tstart_end_pairs[i].start = min(nstart, cstart);\n\t\tstart_end_pairs[i].end = max(nend, cend);\n\t\tmerged = true;\n\t\tbreak;\n\t}\n\tif (merged)\n\t\treturn;\n\tstart_end_pairs[future_index].start = nstart;\n\tstart_end_pairs[future_index].end = nend;\n\tfuture_index++;\n}\n\n \nvoid __init kmsan_init_shadow(void)\n{\n\tconst size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);\n\tphys_addr_t p_start, p_end;\n\tu64 loop;\n\tint nid;\n\n\tfor_each_reserved_mem_range(loop, &p_start, &p_end)\n\t\tkmsan_record_future_shadow_range(phys_to_virt(p_start),\n\t\t\t\t\t\t phys_to_virt(p_end));\n\t \n\tkmsan_record_future_shadow_range(_sdata, _edata);\n\n\tfor_each_online_node(nid)\n\t\tkmsan_record_future_shadow_range(\n\t\t\tNODE_DATA(nid), (char *)NODE_DATA(nid) + nd_size);\n\n\tfor (int i = 0; i < future_index; i++)\n\t\tkmsan_init_alloc_meta_for_range(\n\t\t\t(void *)start_end_pairs[i].start,\n\t\t\t(void *)start_end_pairs[i].end);\n}\n\nstruct metadata_page_pair {\n\tstruct page *shadow, *origin;\n};\nstatic struct metadata_page_pair held_back[MAX_ORDER + 1] __initdata;\n\n \nbool kmsan_memblock_free_pages(struct page *page, unsigned int order)\n{\n\tstruct page *shadow, *origin;\n\n\tif (!held_back[order].shadow) {\n\t\theld_back[order].shadow = page;\n\t\treturn false;\n\t}\n\tif (!held_back[order].origin) {\n\t\theld_back[order].origin = page;\n\t\treturn false;\n\t}\n\tshadow = held_back[order].shadow;\n\torigin = held_back[order].origin;\n\tkmsan_setup_meta(page, shadow, origin, order);\n\n\theld_back[order].shadow = NULL;\n\theld_back[order].origin = NULL;\n\treturn true;\n}\n\n#define MAX_BLOCKS 8\nstruct smallstack {\n\tstruct page *items[MAX_BLOCKS];\n\tint index;\n\tint order;\n};\n\nstatic struct smallstack collect = {\n\t.index = 0,\n\t.order = MAX_ORDER,\n};\n\nstatic void smallstack_push(struct smallstack *stack, struct page *pages)\n{\n\tKMSAN_WARN_ON(stack->index == MAX_BLOCKS);\n\tstack->items[stack->index] = pages;\n\tstack->index++;\n}\n#undef MAX_BLOCKS\n\nstatic struct page *smallstack_pop(struct smallstack *stack)\n{\n\tstruct page *ret;\n\n\tKMSAN_WARN_ON(stack->index == 0);\n\tstack->index--;\n\tret = stack->items[stack->index];\n\tstack->items[stack->index] = NULL;\n\treturn ret;\n}\n\nstatic void do_collection(void)\n{\n\tstruct page *page, *shadow, *origin;\n\n\twhile (collect.index >= 3) {\n\t\tpage = smallstack_pop(&collect);\n\t\tshadow = smallstack_pop(&collect);\n\t\torigin = smallstack_pop(&collect);\n\t\tkmsan_setup_meta(page, shadow, origin, collect.order);\n\t\t__free_pages_core(page, collect.order);\n\t}\n}\n\nstatic void collect_split(void)\n{\n\tstruct smallstack tmp = {\n\t\t.order = collect.order - 1,\n\t\t.index = 0,\n\t};\n\tstruct page *page;\n\n\tif (!collect.order)\n\t\treturn;\n\twhile (collect.index) {\n\t\tpage = smallstack_pop(&collect);\n\t\tsmallstack_push(&tmp, &page[0]);\n\t\tsmallstack_push(&tmp, &page[1 << tmp.order]);\n\t}\n\t__memcpy(&collect, &tmp, sizeof(tmp));\n}\n\n \nstatic void kmsan_memblock_discard(void)\n{\n\t \n\tcollect.order = MAX_ORDER;\n\tfor (int i = MAX_ORDER; i >= 0; i--) {\n\t\tif (held_back[i].shadow)\n\t\t\tsmallstack_push(&collect, held_back[i].shadow);\n\t\tif (held_back[i].origin)\n\t\t\tsmallstack_push(&collect, held_back[i].origin);\n\t\theld_back[i].shadow = NULL;\n\t\theld_back[i].origin = NULL;\n\t\tdo_collection();\n\t\tcollect_split();\n\t}\n}\n\nvoid __init kmsan_init_runtime(void)\n{\n\t \n\tkmsan_internal_task_create(current);\n\tkmsan_memblock_discard();\n\tpr_info(\"Starting KernelMemorySanitizer\\n\");\n\tpr_info(\"ATTENTION: KMSAN is a debugging tool! Do not use it on production machines!\\n\");\n\tkmsan_enabled = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}