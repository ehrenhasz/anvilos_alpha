{
  "module_name": "kmsan_test.c",
  "hash_id": "302086af12036ca5852ddcd17da621f6e048a02508971d917a814db007b5b4d7",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/kmsan_test.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include \"kmsan.h\"\n\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kmsan.h>\n#include <linux/mm.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/tracepoint.h>\n#include <linux/vmalloc.h>\n#include <trace/events/printk.h>\n\nstatic DEFINE_PER_CPU(int, per_cpu_var);\n\n \nstatic struct {\n\tspinlock_t lock;\n\tbool available;\n\tbool ignore;  \n\tchar header[256];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n \nstatic void probe_console(void *ignore, const char *buf, size_t len)\n{\n\tunsigned long flags;\n\n\tif (observed.ignore)\n\t\treturn;\n\tspin_lock_irqsave(&observed.lock, flags);\n\n\tif (strnstr(buf, \"BUG: KMSAN: \", len)) {\n\t\t \n\t\tstrscpy(observed.header, buf,\n\t\t\tmin(len + 1, sizeof(observed.header)));\n\t\tWRITE_ONCE(observed.available, true);\n\t\tobserved.ignore = true;\n\t}\n\tspin_unlock_irqrestore(&observed.lock, flags);\n}\n\n \nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.available);\n}\n\n \nstruct expect_report {\n\tconst char *error_type;  \n\t \n\tconst char *symbol;\n};\n\n \nstatic bool report_matches(const struct expect_report *r)\n{\n\ttypeof(observed.header) expected_header;\n\tunsigned long flags;\n\tbool ret = false;\n\tconst char *end;\n\tchar *cur;\n\n\t \n\tif (!report_available() || !r->symbol)\n\t\treturn (!report_available() && !r->symbol);\n\n\t \n\n\t \n\tcur = expected_header;\n\tend = &expected_header[sizeof(expected_header) - 1];\n\n\tcur += scnprintf(cur, end - cur, \"BUG: KMSAN: %s\", r->error_type);\n\n\tscnprintf(cur, end - cur, \" in %s\", r->symbol);\n\t \n\tcur = strchr(expected_header, '+');\n\tif (cur)\n\t\t*cur = '\\0';\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tif (!report_available())\n\t\tgoto out;  \n\n\t \n\tret = strstr(observed.header, expected_header);\nout:\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\n\treturn ret;\n}\n\n \n\n \nstatic noinline void check_true(char *arg)\n{\n\tpr_info(\"%s is true\\n\", arg);\n}\n\nstatic noinline void check_false(char *arg)\n{\n\tpr_info(\"%s is false\\n\", arg);\n}\n\n#define USE(x)                           \\\n\tdo {                             \\\n\t\tif (x)                   \\\n\t\t\tcheck_true(#x);  \\\n\t\telse                     \\\n\t\t\tcheck_false(#x); \\\n\t} while (0)\n\n#define EXPECTATION_ETYPE_FN(e, reason, fn) \\\n\tstruct expect_report e = {          \\\n\t\t.error_type = reason,       \\\n\t\t.symbol = fn,               \\\n\t}\n\n#define EXPECTATION_NO_REPORT(e) EXPECTATION_ETYPE_FN(e, NULL, NULL)\n#define EXPECTATION_UNINIT_VALUE_FN(e, fn) \\\n\tEXPECTATION_ETYPE_FN(e, \"uninit-value\", fn)\n#define EXPECTATION_UNINIT_VALUE(e) EXPECTATION_UNINIT_VALUE_FN(e, __func__)\n#define EXPECTATION_USE_AFTER_FREE(e) \\\n\tEXPECTATION_ETYPE_FN(e, \"use-after-free\", __func__)\n\n \nstatic void test_uninit_kmalloc(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE(expect);\n\tint *ptr;\n\n\tkunit_info(test, \"uninitialized kmalloc test (UMR report)\\n\");\n\tptr = kmalloc(sizeof(*ptr), GFP_KERNEL);\n\tUSE(*ptr);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_init_kmalloc(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tint *ptr;\n\n\tkunit_info(test, \"initialized kmalloc test (no reports)\\n\");\n\tptr = kmalloc(sizeof(*ptr), GFP_KERNEL);\n\tmemset(ptr, 0, sizeof(*ptr));\n\tUSE(*ptr);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_init_kzalloc(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tint *ptr;\n\n\tkunit_info(test, \"initialized kzalloc test (no reports)\\n\");\n\tptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\tUSE(*ptr);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_uninit_stack_var(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE(expect);\n\tvolatile int cond;\n\n\tkunit_info(test, \"uninitialized stack variable (UMR report)\\n\");\n\tUSE(cond);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_init_stack_var(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tvolatile int cond = 1;\n\n\tkunit_info(test, \"initialized stack variable (no reports)\\n\");\n\tUSE(cond);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\nstatic noinline void two_param_fn_2(int arg1, int arg2)\n{\n\tUSE(arg1);\n\tUSE(arg2);\n}\n\nstatic noinline void one_param_fn(int arg)\n{\n\ttwo_param_fn_2(arg, arg);\n\tUSE(arg);\n}\n\nstatic noinline void two_param_fn(int arg1, int arg2)\n{\n\tint init = 0;\n\n\tone_param_fn(init);\n\tUSE(arg1);\n\tUSE(arg2);\n}\n\nstatic void test_params(struct kunit *test)\n{\n#ifdef CONFIG_KMSAN_CHECK_PARAM_RETVAL\n\t \n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_params\");\n#else\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"two_param_fn\");\n#endif\n\tvolatile int uninit, init = 1;\n\n\tkunit_info(test,\n\t\t   \"uninit passed through a function parameter (UMR report)\\n\");\n\ttwo_param_fn(uninit, init);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\nstatic int signed_sum3(int a, int b, int c)\n{\n\treturn a + b + c;\n}\n\n \nstatic void test_uninit_multiple_params(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE(expect);\n\tvolatile char b = 3, c;\n\tvolatile int a;\n\n\tkunit_info(test, \"uninitialized local passed to fn (UMR report)\\n\");\n\tUSE(signed_sum3(a, b, c));\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic noinline void do_uninit_local_array(char *array, int start, int stop)\n{\n\tvolatile char uninit;\n\n\tfor (int i = start; i < stop; i++)\n\t\tarray[i] = uninit;\n}\n\n \nstatic void test_uninit_kmsan_check_memory(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_uninit_kmsan_check_memory\");\n\tvolatile char local_array[8];\n\n\tkunit_info(\n\t\ttest,\n\t\t\"kmsan_check_memory() called on uninit local (UMR report)\\n\");\n\tdo_uninit_local_array((char *)local_array, 5, 7);\n\n\tkmsan_check_memory((char *)local_array, 8);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_init_kmsan_vmap_vunmap(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tconst int npages = 2;\n\tstruct page **pages;\n\tvoid *vbuf;\n\n\tkunit_info(test, \"pages initialized via vmap (no reports)\\n\");\n\n\tpages = kmalloc_array(npages, sizeof(*pages), GFP_KERNEL);\n\tfor (int i = 0; i < npages; i++)\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\tvbuf = vmap(pages, npages, VM_MAP, PAGE_KERNEL);\n\tmemset(vbuf, 0xfe, npages * PAGE_SIZE);\n\tfor (int i = 0; i < npages; i++)\n\t\tkmsan_check_memory(page_address(pages[i]), PAGE_SIZE);\n\n\tif (vbuf)\n\t\tvunmap(vbuf);\n\tfor (int i = 0; i < npages; i++) {\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\t}\n\tkfree(pages);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_init_vmalloc(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tint npages = 8;\n\tchar *buf;\n\n\tkunit_info(test, \"vmalloc buffer can be initialized (no reports)\\n\");\n\tbuf = vmalloc(PAGE_SIZE * npages);\n\tbuf[0] = 1;\n\tmemset(buf, 0xfe, PAGE_SIZE * npages);\n\tUSE(buf[0]);\n\tfor (int i = 0; i < npages; i++)\n\t\tkmsan_check_memory(&buf[PAGE_SIZE * i], PAGE_SIZE);\n\tvfree(buf);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_uaf(struct kunit *test)\n{\n\tEXPECTATION_USE_AFTER_FREE(expect);\n\tvolatile int value;\n\tvolatile int *var;\n\n\tkunit_info(test, \"use-after-free in kmalloc-ed buffer (UMR report)\\n\");\n\tvar = kmalloc(80, GFP_KERNEL);\n\tvar[3] = 0xfeedface;\n\tkfree((int *)var);\n\t \n\tvalue = var[3];\n\tUSE(value);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_percpu_propagate(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE(expect);\n\tvolatile int uninit, check;\n\n\tkunit_info(test,\n\t\t   \"uninit local stored to per_cpu memory (UMR report)\\n\");\n\n\tthis_cpu_write(per_cpu_var, uninit);\n\tcheck = this_cpu_read(per_cpu_var);\n\tUSE(check);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_printk(struct kunit *test)\n{\n#ifdef CONFIG_KMSAN_CHECK_PARAM_RETVAL\n\t \n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_printk\");\n#else\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"number\");\n#endif\n\tvolatile int uninit;\n\n\tkunit_info(test, \"uninit local passed to pr_info() (UMR report)\\n\");\n\tpr_info(\"%px contains %d\\n\", &uninit, uninit);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \n#define DO_NOT_OPTIMIZE(var) barrier()\n\n \nstatic void test_init_memcpy(struct kunit *test)\n{\n\tEXPECTATION_NO_REPORT(expect);\n\tvolatile int src;\n\tvolatile int dst = 0;\n\n\tDO_NOT_OPTIMIZE(src);\n\tsrc = 1;\n\tkunit_info(\n\t\ttest,\n\t\t\"memcpy()ing aligned initialized src to aligned dst (no reports)\\n\");\n\tmemcpy((void *)&dst, (void *)&src, sizeof(src));\n\tkmsan_check_memory((void *)&dst, sizeof(dst));\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_memcpy_aligned_to_aligned(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_memcpy_aligned_to_aligned\");\n\tvolatile int uninit_src;\n\tvolatile int dst = 0;\n\n\tkunit_info(\n\t\ttest,\n\t\t\"memcpy()ing aligned uninit src to aligned dst (UMR report)\\n\");\n\tDO_NOT_OPTIMIZE(uninit_src);\n\tmemcpy((void *)&dst, (void *)&uninit_src, sizeof(uninit_src));\n\tkmsan_check_memory((void *)&dst, sizeof(dst));\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_memcpy_aligned_to_unaligned(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_memcpy_aligned_to_unaligned\");\n\tvolatile int uninit_src;\n\tvolatile char dst[8] = { 0 };\n\n\tkunit_info(\n\t\ttest,\n\t\t\"memcpy()ing aligned uninit src to unaligned dst (UMR report)\\n\");\n\tDO_NOT_OPTIMIZE(uninit_src);\n\tmemcpy((void *)&dst[1], (void *)&uninit_src, sizeof(uninit_src));\n\tkmsan_check_memory((void *)dst, 4);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_memcpy_aligned_to_unaligned2(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE_FN(expect,\n\t\t\t\t    \"test_memcpy_aligned_to_unaligned2\");\n\tvolatile int uninit_src;\n\tvolatile char dst[8] = { 0 };\n\n\tkunit_info(\n\t\ttest,\n\t\t\"memcpy()ing aligned uninit src to unaligned dst - part 2 (UMR report)\\n\");\n\tDO_NOT_OPTIMIZE(uninit_src);\n\tmemcpy((void *)&dst[1], (void *)&uninit_src, sizeof(uninit_src));\n\tkmsan_check_memory((void *)&dst[4], sizeof(uninit_src));\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \n#define DEFINE_TEST_MEMSETXX(size)                                          \\\n\tstatic void test_memset##size(struct kunit *test)                   \\\n\t{                                                                   \\\n\t\tEXPECTATION_NO_REPORT(expect);                              \\\n\t\tvolatile uint##size##_t uninit;                             \\\n                                                                            \\\n\t\tkunit_info(test,                                            \\\n\t\t\t   \"memset\" #size \"() should initialize memory\\n\"); \\\n\t\tDO_NOT_OPTIMIZE(uninit);                                    \\\n\t\tmemset##size((uint##size##_t *)&uninit, 0, 1);              \\\n\t\tkmsan_check_memory((void *)&uninit, sizeof(uninit));        \\\n\t\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));           \\\n\t}\n\nDEFINE_TEST_MEMSETXX(16)\nDEFINE_TEST_MEMSETXX(32)\nDEFINE_TEST_MEMSETXX(64)\n\nstatic noinline void fibonacci(int *array, int size, int start)\n{\n\tif (start < 2 || (start == size))\n\t\treturn;\n\tarray[start] = array[start - 1] + array[start - 2];\n\tfibonacci(array, size, start + 1);\n}\n\nstatic void test_long_origin_chain(struct kunit *test)\n{\n\tEXPECTATION_UNINIT_VALUE_FN(expect, \"test_long_origin_chain\");\n\t \n\tvolatile int accum[KMSAN_MAX_ORIGIN_DEPTH * 2 + 2];\n\tint last = ARRAY_SIZE(accum) - 1;\n\n\tkunit_info(\n\t\ttest,\n\t\t\"origin chain exceeding KMSAN_MAX_ORIGIN_DEPTH (UMR report)\\n\");\n\t \n\taccum[0] = 1;\n\tfibonacci((int *)accum, ARRAY_SIZE(accum), 2);\n\tkmsan_check_memory((void *)&accum[last], sizeof(int));\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\n \nstatic void test_stackdepot_roundtrip(struct kunit *test)\n{\n\tunsigned long src_entries[16], *dst_entries;\n\tunsigned int src_nentries, dst_nentries;\n\tEXPECTATION_NO_REPORT(expect);\n\tdepot_stack_handle_t handle;\n\n\tkunit_info(test, \"testing stackdepot roundtrip (no reports)\\n\");\n\n\tsrc_nentries =\n\t\tstack_trace_save(src_entries, ARRAY_SIZE(src_entries), 1);\n\thandle = stack_depot_save(src_entries, src_nentries, GFP_KERNEL);\n\tstack_depot_print(handle);\n\tdst_nentries = stack_depot_fetch(handle, &dst_entries);\n\tKUNIT_EXPECT_TRUE(test, src_nentries == dst_nentries);\n\n\tkmsan_check_memory((void *)dst_entries,\n\t\t\t   sizeof(*dst_entries) * dst_nentries);\n\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));\n}\n\nstatic struct kunit_case kmsan_test_cases[] = {\n\tKUNIT_CASE(test_uninit_kmalloc),\n\tKUNIT_CASE(test_init_kmalloc),\n\tKUNIT_CASE(test_init_kzalloc),\n\tKUNIT_CASE(test_uninit_stack_var),\n\tKUNIT_CASE(test_init_stack_var),\n\tKUNIT_CASE(test_params),\n\tKUNIT_CASE(test_uninit_multiple_params),\n\tKUNIT_CASE(test_uninit_kmsan_check_memory),\n\tKUNIT_CASE(test_init_kmsan_vmap_vunmap),\n\tKUNIT_CASE(test_init_vmalloc),\n\tKUNIT_CASE(test_uaf),\n\tKUNIT_CASE(test_percpu_propagate),\n\tKUNIT_CASE(test_printk),\n\tKUNIT_CASE(test_init_memcpy),\n\tKUNIT_CASE(test_memcpy_aligned_to_aligned),\n\tKUNIT_CASE(test_memcpy_aligned_to_unaligned),\n\tKUNIT_CASE(test_memcpy_aligned_to_unaligned2),\n\tKUNIT_CASE(test_memset16),\n\tKUNIT_CASE(test_memset32),\n\tKUNIT_CASE(test_memset64),\n\tKUNIT_CASE(test_long_origin_chain),\n\tKUNIT_CASE(test_stackdepot_roundtrip),\n\t{},\n};\n\n \n\nstatic int test_init(struct kunit *test)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tobserved.header[0] = '\\0';\n\tobserved.ignore = false;\n\tobserved.available = false;\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\n\treturn 0;\n}\n\nstatic void test_exit(struct kunit *test)\n{\n}\n\nstatic int kmsan_suite_init(struct kunit_suite *suite)\n{\n\tregister_trace_console(probe_console, NULL);\n\treturn 0;\n}\n\nstatic void kmsan_suite_exit(struct kunit_suite *suite)\n{\n\tunregister_trace_console(probe_console, NULL);\n\ttracepoint_synchronize_unregister();\n}\n\nstatic struct kunit_suite kmsan_test_suite = {\n\t.name = \"kmsan\",\n\t.test_cases = kmsan_test_cases,\n\t.init = test_init,\n\t.exit = test_exit,\n\t.suite_init = kmsan_suite_init,\n\t.suite_exit = kmsan_suite_exit,\n};\nkunit_test_suites(&kmsan_test_suite);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexander Potapenko <glider@google.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}