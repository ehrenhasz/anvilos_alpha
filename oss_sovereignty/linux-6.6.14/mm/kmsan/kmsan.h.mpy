{
  "module_name": "kmsan.h",
  "hash_id": "332c403b94226584e15bc2d9d815a1c740cb4d88bb527abfc5fd951fbbb7070d",
  "original_prompt": "Ingested from linux-6.6.14/mm/kmsan/kmsan.h",
  "human_readable_source": " \n \n\n#ifndef __MM_KMSAN_KMSAN_H\n#define __MM_KMSAN_KMSAN_H\n\n#include <asm/pgtable_64_types.h>\n#include <linux/irqflags.h>\n#include <linux/sched.h>\n#include <linux/stackdepot.h>\n#include <linux/stacktrace.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n\n#define KMSAN_ALLOCA_MAGIC_ORIGIN 0xabcd0100\n#define KMSAN_CHAIN_MAGIC_ORIGIN 0xabcd0200\n\n#define KMSAN_POISON_NOCHECK 0x0\n#define KMSAN_POISON_CHECK 0x1\n#define KMSAN_POISON_FREE 0x2\n\n#define KMSAN_ORIGIN_SIZE 4\n#define KMSAN_MAX_ORIGIN_DEPTH 7\n\n#define KMSAN_STACK_DEPTH 64\n\n#define KMSAN_META_SHADOW (false)\n#define KMSAN_META_ORIGIN (true)\n\nextern bool kmsan_enabled;\nextern int panic_on_kmsan;\n\n \n#define KMSAN_WARN_ON(cond)                                           \\\n\t({                                                            \\\n\t\tconst bool __cond = WARN_ON(cond);                    \\\n\t\tif (unlikely(__cond)) {                               \\\n\t\t\tWRITE_ONCE(kmsan_enabled, false);             \\\n\t\t\tif (panic_on_kmsan) {                         \\\n\t\t\t\t  \\\n\t\t\t\t               \\\n\t\t\t\tBUG();                                \\\n\t\t\t}                                             \\\n\t\t}                                                     \\\n\t\t__cond;                                               \\\n\t})\n\n \nstruct shadow_origin_ptr {\n\tvoid *shadow, *origin;\n};\n\nstruct shadow_origin_ptr kmsan_get_shadow_origin_ptr(void *addr, u64 size,\n\t\t\t\t\t\t     bool store);\nvoid *kmsan_get_metadata(void *addr, bool is_origin);\nvoid __init kmsan_init_alloc_meta_for_range(void *start, void *end);\n\nenum kmsan_bug_reason {\n\tREASON_ANY,\n\tREASON_COPY_TO_USER,\n\tREASON_SUBMIT_URB,\n};\n\nvoid kmsan_print_origin(depot_stack_handle_t origin);\n\n \nvoid kmsan_report(depot_stack_handle_t origin, void *address, int size,\n\t\t  int off_first, int off_last, const void *user_addr,\n\t\t  enum kmsan_bug_reason reason);\n\nDECLARE_PER_CPU(struct kmsan_ctx, kmsan_percpu_ctx);\n\nstatic __always_inline struct kmsan_ctx *kmsan_get_context(void)\n{\n\treturn in_task() ? &current->kmsan_ctx : raw_cpu_ptr(&kmsan_percpu_ctx);\n}\n\n \nstatic __always_inline bool kmsan_in_runtime(void)\n{\n\tif ((hardirq_count() >> HARDIRQ_SHIFT) > 1)\n\t\treturn true;\n\tif (in_nmi())\n\t\treturn true;\n\treturn kmsan_get_context()->kmsan_in_runtime;\n}\n\nstatic __always_inline void kmsan_enter_runtime(void)\n{\n\tstruct kmsan_ctx *ctx;\n\n\tctx = kmsan_get_context();\n\tKMSAN_WARN_ON(ctx->kmsan_in_runtime++);\n}\n\nstatic __always_inline void kmsan_leave_runtime(void)\n{\n\tstruct kmsan_ctx *ctx = kmsan_get_context();\n\n\tKMSAN_WARN_ON(--ctx->kmsan_in_runtime);\n}\n\ndepot_stack_handle_t kmsan_save_stack(void);\ndepot_stack_handle_t kmsan_save_stack_with_flags(gfp_t flags,\n\t\t\t\t\t\t unsigned int extra_bits);\n\n \nstatic __always_inline unsigned int kmsan_extra_bits(unsigned int depth,\n\t\t\t\t\t\t     bool uaf)\n{\n\treturn (depth << 1) | uaf;\n}\n\nstatic __always_inline bool kmsan_uaf_from_eb(unsigned int extra_bits)\n{\n\treturn extra_bits & 1;\n}\n\nstatic __always_inline unsigned int kmsan_depth_from_eb(unsigned int extra_bits)\n{\n\treturn extra_bits >> 1;\n}\n\n \nvoid kmsan_internal_memmove_metadata(void *dst, void *src, size_t n);\nvoid kmsan_internal_poison_memory(void *address, size_t size, gfp_t flags,\n\t\t\t\t  unsigned int poison_flags);\nvoid kmsan_internal_unpoison_memory(void *address, size_t size, bool checked);\nvoid kmsan_internal_set_shadow_origin(void *address, size_t size, int b,\n\t\t\t\t      u32 origin, bool checked);\ndepot_stack_handle_t kmsan_internal_chain_origin(depot_stack_handle_t id);\n\nvoid kmsan_internal_task_create(struct task_struct *task);\n\nbool kmsan_metadata_is_contiguous(void *addr, size_t size);\nvoid kmsan_internal_check_memory(void *addr, size_t size, const void *user_addr,\n\t\t\t\t int reason);\n\nstruct page *kmsan_vmalloc_to_page_or_null(void *vaddr);\nvoid kmsan_setup_meta(struct page *page, struct page *shadow,\n\t\t      struct page *origin, int order);\n\n \nstatic inline bool kmsan_internal_is_module_addr(void *vaddr)\n{\n\treturn ((u64)vaddr >= MODULES_VADDR) && ((u64)vaddr < MODULES_END);\n}\n\nstatic inline bool kmsan_internal_is_vmalloc_addr(void *addr)\n{\n\treturn ((u64)addr >= VMALLOC_START) && ((u64)addr < VMALLOC_END);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}