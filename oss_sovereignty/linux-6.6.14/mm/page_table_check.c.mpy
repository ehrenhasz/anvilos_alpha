{
  "module_name": "page_table_check.c",
  "hash_id": "8a1a21f35f0e7c376fd84619c4bfeac799f0487cfd2e0cf1dc04d44732d93003",
  "original_prompt": "Ingested from linux-6.6.14/mm/page_table_check.c",
  "human_readable_source": "\n\n \n#include <linux/kstrtox.h>\n#include <linux/mm.h>\n#include <linux/page_table_check.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt)\t\"page_table_check: \" fmt\n\nstruct page_table_check {\n\tatomic_t anon_map_count;\n\tatomic_t file_map_count;\n};\n\nstatic bool __page_table_check_enabled __initdata =\n\t\t\t\tIS_ENABLED(CONFIG_PAGE_TABLE_CHECK_ENFORCED);\n\nDEFINE_STATIC_KEY_TRUE(page_table_check_disabled);\nEXPORT_SYMBOL(page_table_check_disabled);\n\nstatic int __init early_page_table_check_param(char *buf)\n{\n\treturn kstrtobool(buf, &__page_table_check_enabled);\n}\n\nearly_param(\"page_table_check\", early_page_table_check_param);\n\nstatic bool __init need_page_table_check(void)\n{\n\treturn __page_table_check_enabled;\n}\n\nstatic void __init init_page_table_check(void)\n{\n\tif (!__page_table_check_enabled)\n\t\treturn;\n\tstatic_branch_disable(&page_table_check_disabled);\n}\n\nstruct page_ext_operations page_table_check_ops = {\n\t.size = sizeof(struct page_table_check),\n\t.need = need_page_table_check,\n\t.init = init_page_table_check,\n\t.need_shared_flags = false,\n};\n\nstatic struct page_table_check *get_page_table_check(struct page_ext *page_ext)\n{\n\tBUG_ON(!page_ext);\n\treturn page_ext_data(page_ext, &page_table_check_ops);\n}\n\n \nstatic void page_table_check_clear(unsigned long pfn, unsigned long pgcnt)\n{\n\tstruct page_ext *page_ext;\n\tstruct page *page;\n\tunsigned long i;\n\tbool anon;\n\n\tif (!pfn_valid(pfn))\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\tpage_ext = page_ext_get(page);\n\n\tBUG_ON(PageSlab(page));\n\tanon = PageAnon(page);\n\n\tfor (i = 0; i < pgcnt; i++) {\n\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);\n\n\t\tif (anon) {\n\t\t\tBUG_ON(atomic_read(&ptc->file_map_count));\n\t\t\tBUG_ON(atomic_dec_return(&ptc->anon_map_count) < 0);\n\t\t} else {\n\t\t\tBUG_ON(atomic_read(&ptc->anon_map_count));\n\t\t\tBUG_ON(atomic_dec_return(&ptc->file_map_count) < 0);\n\t\t}\n\t\tpage_ext = page_ext_next(page_ext);\n\t}\n\tpage_ext_put(page_ext);\n}\n\n \nstatic void page_table_check_set(unsigned long pfn, unsigned long pgcnt,\n\t\t\t\t bool rw)\n{\n\tstruct page_ext *page_ext;\n\tstruct page *page;\n\tunsigned long i;\n\tbool anon;\n\n\tif (!pfn_valid(pfn))\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\tpage_ext = page_ext_get(page);\n\n\tBUG_ON(PageSlab(page));\n\tanon = PageAnon(page);\n\n\tfor (i = 0; i < pgcnt; i++) {\n\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);\n\n\t\tif (anon) {\n\t\t\tBUG_ON(atomic_read(&ptc->file_map_count));\n\t\t\tBUG_ON(atomic_inc_return(&ptc->anon_map_count) > 1 && rw);\n\t\t} else {\n\t\t\tBUG_ON(atomic_read(&ptc->anon_map_count));\n\t\t\tBUG_ON(atomic_inc_return(&ptc->file_map_count) < 0);\n\t\t}\n\t\tpage_ext = page_ext_next(page_ext);\n\t}\n\tpage_ext_put(page_ext);\n}\n\n \nvoid __page_table_check_zero(struct page *page, unsigned int order)\n{\n\tstruct page_ext *page_ext;\n\tunsigned long i;\n\n\tBUG_ON(PageSlab(page));\n\n\tpage_ext = page_ext_get(page);\n\tBUG_ON(!page_ext);\n\tfor (i = 0; i < (1ul << order); i++) {\n\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);\n\n\t\tBUG_ON(atomic_read(&ptc->anon_map_count));\n\t\tBUG_ON(atomic_read(&ptc->file_map_count));\n\t\tpage_ext = page_ext_next(page_ext);\n\t}\n\tpage_ext_put(page_ext);\n}\n\nvoid __page_table_check_pte_clear(struct mm_struct *mm, pte_t pte)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\tif (pte_user_accessible_page(pte)) {\n\t\tpage_table_check_clear(pte_pfn(pte), PAGE_SIZE >> PAGE_SHIFT);\n\t}\n}\nEXPORT_SYMBOL(__page_table_check_pte_clear);\n\nvoid __page_table_check_pmd_clear(struct mm_struct *mm, pmd_t pmd)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\tif (pmd_user_accessible_page(pmd)) {\n\t\tpage_table_check_clear(pmd_pfn(pmd), PMD_SIZE >> PAGE_SHIFT);\n\t}\n}\nEXPORT_SYMBOL(__page_table_check_pmd_clear);\n\nvoid __page_table_check_pud_clear(struct mm_struct *mm, pud_t pud)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\tif (pud_user_accessible_page(pud)) {\n\t\tpage_table_check_clear(pud_pfn(pud), PUD_SIZE >> PAGE_SHIFT);\n\t}\n}\nEXPORT_SYMBOL(__page_table_check_pud_clear);\n\nvoid __page_table_check_ptes_set(struct mm_struct *mm, pte_t *ptep, pte_t pte,\n\t\tunsigned int nr)\n{\n\tunsigned int i;\n\n\tif (&init_mm == mm)\n\t\treturn;\n\n\tfor (i = 0; i < nr; i++)\n\t\t__page_table_check_pte_clear(mm, ptep_get(ptep + i));\n\tif (pte_user_accessible_page(pte))\n\t\tpage_table_check_set(pte_pfn(pte), nr, pte_write(pte));\n}\nEXPORT_SYMBOL(__page_table_check_ptes_set);\n\nvoid __page_table_check_pmd_set(struct mm_struct *mm, pmd_t *pmdp, pmd_t pmd)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\t__page_table_check_pmd_clear(mm, *pmdp);\n\tif (pmd_user_accessible_page(pmd)) {\n\t\tpage_table_check_set(pmd_pfn(pmd), PMD_SIZE >> PAGE_SHIFT,\n\t\t\t\t     pmd_write(pmd));\n\t}\n}\nEXPORT_SYMBOL(__page_table_check_pmd_set);\n\nvoid __page_table_check_pud_set(struct mm_struct *mm, pud_t *pudp, pud_t pud)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\t__page_table_check_pud_clear(mm, *pudp);\n\tif (pud_user_accessible_page(pud)) {\n\t\tpage_table_check_set(pud_pfn(pud), PUD_SIZE >> PAGE_SHIFT,\n\t\t\t\t     pud_write(pud));\n\t}\n}\nEXPORT_SYMBOL(__page_table_check_pud_set);\n\nvoid __page_table_check_pte_clear_range(struct mm_struct *mm,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tpmd_t pmd)\n{\n\tif (&init_mm == mm)\n\t\treturn;\n\n\tif (!pmd_bad(pmd) && !pmd_leaf(pmd)) {\n\t\tpte_t *ptep = pte_offset_map(&pmd, addr);\n\t\tunsigned long i;\n\n\t\tif (WARN_ON(!ptep))\n\t\t\treturn;\n\t\tfor (i = 0; i < PTRS_PER_PTE; i++) {\n\t\t\t__page_table_check_pte_clear(mm, ptep_get(ptep));\n\t\t\taddr += PAGE_SIZE;\n\t\t\tptep++;\n\t\t}\n\t\tpte_unmap(ptep - PTRS_PER_PTE);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}