{
  "module_name": "report.c",
  "hash_id": "98273018b397e3b045ac32e60c11f4fb7b5538dd0fdfaa2d3ea92d8636f43056",
  "original_prompt": "Ingested from linux-6.6.14/mm/kfence/report.c",
  "human_readable_source": "\n \n\n#include <linux/stdarg.h>\n\n#include <linux/kernel.h>\n#include <linux/lockdep.h>\n#include <linux/math.h>\n#include <linux/printk.h>\n#include <linux/sched/debug.h>\n#include <linux/seq_file.h>\n#include <linux/sprintf.h>\n#include <linux/stacktrace.h>\n#include <linux/string.h>\n#include <trace/events/error_report.h>\n\n#include <asm/kfence.h>\n\n#include \"kfence.h\"\n\n \n#ifndef ARCH_FUNC_PREFIX\n#define ARCH_FUNC_PREFIX \"\"\n#endif\n\n \n__printf(2, 3)\nstatic void seq_con_printf(struct seq_file *seq, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tif (seq)\n\t\tseq_vprintf(seq, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}\n\n \nstatic int get_stack_skipnr(const unsigned long stack_entries[], int num_entries,\n\t\t\t    const enum kfence_error_type *type)\n{\n\tchar buf[64];\n\tint skipnr, fallback = 0;\n\n\tif (type) {\n\t\t \n\t\tswitch (*type) {\n\t\tcase KFENCE_ERROR_UAF:\n\t\tcase KFENCE_ERROR_OOB:\n\t\tcase KFENCE_ERROR_INVALID:\n\t\t\t \n\t\t\treturn 0;\n\t\tcase KFENCE_ERROR_CORRUPTION:\n\t\tcase KFENCE_ERROR_INVALID_FREE:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (skipnr = 0; skipnr < num_entries; skipnr++) {\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skipnr]);\n\n\t\tif (str_has_prefix(buf, ARCH_FUNC_PREFIX \"kfence_\") ||\n\t\t    str_has_prefix(buf, ARCH_FUNC_PREFIX \"__kfence_\") ||\n\t\t    str_has_prefix(buf, ARCH_FUNC_PREFIX \"__kmem_cache_free\") ||\n\t\t    !strncmp(buf, ARCH_FUNC_PREFIX \"__slab_free\", len)) {\n\t\t\t \n\t\t\tfallback = skipnr + 1;\n\t\t}\n\n\t\t \n\t\tif (str_has_prefix(buf, ARCH_FUNC_PREFIX \"kfree\") ||\n\t\t    str_has_prefix(buf, ARCH_FUNC_PREFIX \"kmem_cache_free\") ||\n\t\t    str_has_prefix(buf, ARCH_FUNC_PREFIX \"__kmalloc\") ||\n\t\t    str_has_prefix(buf, ARCH_FUNC_PREFIX \"kmem_cache_alloc\"))\n\t\t\tgoto found;\n\t}\n\tif (fallback < num_entries)\n\t\treturn fallback;\nfound:\n\tskipnr++;\n\treturn skipnr < num_entries ? skipnr : 0;\n}\n\nstatic void kfence_print_stack(struct seq_file *seq, const struct kfence_metadata *meta,\n\t\t\t       bool show_alloc)\n{\n\tconst struct kfence_track *track = show_alloc ? &meta->alloc_track : &meta->free_track;\n\tu64 ts_sec = track->ts_nsec;\n\tunsigned long rem_nsec = do_div(ts_sec, NSEC_PER_SEC);\n\n\t \n\tseq_con_printf(seq, \"%s by task %d on cpu %d at %lu.%06lus:\\n\",\n\t\t       show_alloc ? \"allocated\" : \"freed\", track->pid,\n\t\t       track->cpu, (unsigned long)ts_sec, rem_nsec / 1000);\n\n\tif (track->num_stack_entries) {\n\t\t \n\t\tint i = get_stack_skipnr(track->stack_entries, track->num_stack_entries, NULL);\n\n\t\t \n\t\tfor (; i < track->num_stack_entries; i++)\n\t\t\tseq_con_printf(seq, \" %pS\\n\", (void *)track->stack_entries[i]);\n\t} else {\n\t\tseq_con_printf(seq, \" no %s stack\\n\", show_alloc ? \"allocation\" : \"deallocation\");\n\t}\n}\n\nvoid kfence_print_object(struct seq_file *seq, const struct kfence_metadata *meta)\n{\n\tconst int size = abs(meta->size);\n\tconst unsigned long start = meta->addr;\n\tconst struct kmem_cache *const cache = meta->cache;\n\n\tlockdep_assert_held(&meta->lock);\n\n\tif (meta->state == KFENCE_OBJECT_UNUSED) {\n\t\tseq_con_printf(seq, \"kfence-#%td unused\\n\", meta - kfence_metadata);\n\t\treturn;\n\t}\n\n\tseq_con_printf(seq, \"kfence-#%td: 0x%p-0x%p, size=%d, cache=%s\\n\\n\",\n\t\t       meta - kfence_metadata, (void *)start, (void *)(start + size - 1),\n\t\t       size, (cache && cache->name) ? cache->name : \"<destroyed>\");\n\n\tkfence_print_stack(seq, meta, true);\n\n\tif (meta->state == KFENCE_OBJECT_FREED) {\n\t\tseq_con_printf(seq, \"\\n\");\n\t\tkfence_print_stack(seq, meta, false);\n\t}\n}\n\n \nstatic void print_diff_canary(unsigned long address, size_t bytes_to_show,\n\t\t\t      const struct kfence_metadata *meta)\n{\n\tconst unsigned long show_until_addr = address + bytes_to_show;\n\tconst u8 *cur, *end;\n\n\t \n\tend = (const u8 *)(address < meta->addr ? min(show_until_addr, meta->addr)\n\t\t\t\t\t\t: min(show_until_addr, PAGE_ALIGN(address)));\n\n\tpr_cont(\"[\");\n\tfor (cur = (const u8 *)address; cur < end; cur++) {\n\t\tif (*cur == KFENCE_CANARY_PATTERN_U8(cur))\n\t\t\tpr_cont(\" .\");\n\t\telse if (no_hash_pointers)\n\t\t\tpr_cont(\" 0x%02x\", *cur);\n\t\telse  \n\t\t\tpr_cont(\" !\");\n\t}\n\tpr_cont(\" ]\");\n}\n\nstatic const char *get_access_type(bool is_write)\n{\n\treturn is_write ? \"write\" : \"read\";\n}\n\nvoid kfence_report_error(unsigned long address, bool is_write, struct pt_regs *regs,\n\t\t\t const struct kfence_metadata *meta, enum kfence_error_type type)\n{\n\tunsigned long stack_entries[KFENCE_STACK_DEPTH] = { 0 };\n\tconst ptrdiff_t object_index = meta ? meta - kfence_metadata : -1;\n\tint num_stack_entries;\n\tint skipnr = 0;\n\n\tif (regs) {\n\t\tnum_stack_entries = stack_trace_save_regs(regs, stack_entries, KFENCE_STACK_DEPTH, 0);\n\t} else {\n\t\tnum_stack_entries = stack_trace_save(stack_entries, KFENCE_STACK_DEPTH, 1);\n\t\tskipnr = get_stack_skipnr(stack_entries, num_stack_entries, &type);\n\t}\n\n\t \n\tif (WARN_ON(type != KFENCE_ERROR_INVALID && !meta))\n\t\treturn;\n\n\tif (meta)\n\t\tlockdep_assert_held(&meta->lock);\n\t \n\tlockdep_off();\n\n\tpr_err(\"==================================================================\\n\");\n\t \n\tswitch (type) {\n\tcase KFENCE_ERROR_OOB: {\n\t\tconst bool left_of_object = address < meta->addr;\n\n\t\tpr_err(\"BUG: KFENCE: out-of-bounds %s in %pS\\n\\n\", get_access_type(is_write),\n\t\t       (void *)stack_entries[skipnr]);\n\t\tpr_err(\"Out-of-bounds %s at 0x%p (%luB %s of kfence-#%td):\\n\",\n\t\t       get_access_type(is_write), (void *)address,\n\t\t       left_of_object ? meta->addr - address : address - meta->addr,\n\t\t       left_of_object ? \"left\" : \"right\", object_index);\n\t\tbreak;\n\t}\n\tcase KFENCE_ERROR_UAF:\n\t\tpr_err(\"BUG: KFENCE: use-after-free %s in %pS\\n\\n\", get_access_type(is_write),\n\t\t       (void *)stack_entries[skipnr]);\n\t\tpr_err(\"Use-after-free %s at 0x%p (in kfence-#%td):\\n\",\n\t\t       get_access_type(is_write), (void *)address, object_index);\n\t\tbreak;\n\tcase KFENCE_ERROR_CORRUPTION:\n\t\tpr_err(\"BUG: KFENCE: memory corruption in %pS\\n\\n\", (void *)stack_entries[skipnr]);\n\t\tpr_err(\"Corrupted memory at 0x%p \", (void *)address);\n\t\tprint_diff_canary(address, 16, meta);\n\t\tpr_cont(\" (in kfence-#%td):\\n\", object_index);\n\t\tbreak;\n\tcase KFENCE_ERROR_INVALID:\n\t\tpr_err(\"BUG: KFENCE: invalid %s in %pS\\n\\n\", get_access_type(is_write),\n\t\t       (void *)stack_entries[skipnr]);\n\t\tpr_err(\"Invalid %s at 0x%p:\\n\", get_access_type(is_write),\n\t\t       (void *)address);\n\t\tbreak;\n\tcase KFENCE_ERROR_INVALID_FREE:\n\t\tpr_err(\"BUG: KFENCE: invalid free in %pS\\n\\n\", (void *)stack_entries[skipnr]);\n\t\tpr_err(\"Invalid free of 0x%p (in kfence-#%td):\\n\", (void *)address,\n\t\t       object_index);\n\t\tbreak;\n\t}\n\n\t \n\tstack_trace_print(stack_entries + skipnr, num_stack_entries - skipnr, 0);\n\n\tif (meta) {\n\t\tpr_err(\"\\n\");\n\t\tkfence_print_object(NULL, meta);\n\t}\n\n\t \n\tpr_err(\"\\n\");\n\tif (no_hash_pointers && regs)\n\t\tshow_regs(regs);\n\telse\n\t\tdump_stack_print_info(KERN_ERR);\n\ttrace_error_report_end(ERROR_DETECTOR_KFENCE, address);\n\tpr_err(\"==================================================================\\n\");\n\n\tlockdep_on();\n\n\tcheck_panic_on_warn(\"KFENCE\");\n\n\t \n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_STILL_OK);\n}\n\n#ifdef CONFIG_PRINTK\nstatic void kfence_to_kp_stack(const struct kfence_track *track, void **kp_stack)\n{\n\tint i, j;\n\n\ti = get_stack_skipnr(track->stack_entries, track->num_stack_entries, NULL);\n\tfor (j = 0; i < track->num_stack_entries && j < KS_ADDRS_COUNT; ++i, ++j)\n\t\tkp_stack[j] = (void *)track->stack_entries[i];\n\tif (j < KS_ADDRS_COUNT)\n\t\tkp_stack[j] = NULL;\n}\n\nbool __kfence_obj_info(struct kmem_obj_info *kpp, void *object, struct slab *slab)\n{\n\tstruct kfence_metadata *meta = addr_to_metadata((unsigned long)object);\n\tunsigned long flags;\n\n\tif (!meta)\n\t\treturn false;\n\n\t \n\tkpp->kp_ptr = object;\n\n\t \n\tif (WARN_ON(meta->state == KFENCE_OBJECT_UNUSED))\n\t\treturn true;\n\n\traw_spin_lock_irqsave(&meta->lock, flags);\n\n\tkpp->kp_slab = slab;\n\tkpp->kp_slab_cache = meta->cache;\n\tkpp->kp_objp = (void *)meta->addr;\n\tkfence_to_kp_stack(&meta->alloc_track, kpp->kp_stack);\n\tif (meta->state == KFENCE_OBJECT_FREED)\n\t\tkfence_to_kp_stack(&meta->free_track, kpp->kp_free_stack);\n\t \n\tkpp->kp_ret = kpp->kp_stack[0];\n\n\traw_spin_unlock_irqrestore(&meta->lock, flags);\n\n\treturn true;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}