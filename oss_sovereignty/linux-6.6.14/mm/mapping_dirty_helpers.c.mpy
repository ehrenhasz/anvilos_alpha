{
  "module_name": "mapping_dirty_helpers.c",
  "hash_id": "16084dbb06fa3d6f14c5c0a01dbf2efb83861c8008e22592ad181d7e4ca2cccb",
  "original_prompt": "Ingested from linux-6.6.14/mm/mapping_dirty_helpers.c",
  "human_readable_source": "\n#include <linux/pagewalk.h>\n#include <linux/hugetlb.h>\n#include <linux/bitops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n \nstruct wp_walk {\n\tstruct mmu_notifier_range range;\n\tunsigned long tlbflush_start;\n\tunsigned long tlbflush_end;\n\tunsigned long total;\n};\n\n \nstatic int wp_pte(pte_t *pte, unsigned long addr, unsigned long end,\n\t\t  struct mm_walk *walk)\n{\n\tstruct wp_walk *wpwalk = walk->private;\n\tpte_t ptent = ptep_get(pte);\n\n\tif (pte_write(ptent)) {\n\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);\n\n\t\tptent = pte_wrprotect(old_pte);\n\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);\n\t\twpwalk->total++;\n\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);\n\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,\n\t\t\t\t\t   addr + PAGE_SIZE);\n\t}\n\n\treturn 0;\n}\n\n \nstruct clean_walk {\n\tstruct wp_walk base;\n\tpgoff_t bitmap_pgoff;\n\tunsigned long *bitmap;\n\tpgoff_t start;\n\tpgoff_t end;\n};\n\n#define to_clean_walk(_wpwalk) container_of(_wpwalk, struct clean_walk, base)\n\n \nstatic int clean_record_pte(pte_t *pte, unsigned long addr,\n\t\t\t    unsigned long end, struct mm_walk *walk)\n{\n\tstruct wp_walk *wpwalk = walk->private;\n\tstruct clean_walk *cwalk = to_clean_walk(wpwalk);\n\tpte_t ptent = ptep_get(pte);\n\n\tif (pte_dirty(ptent)) {\n\t\tpgoff_t pgoff = ((addr - walk->vma->vm_start) >> PAGE_SHIFT) +\n\t\t\twalk->vma->vm_pgoff - cwalk->bitmap_pgoff;\n\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);\n\n\t\tptent = pte_mkclean(old_pte);\n\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);\n\n\t\twpwalk->total++;\n\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);\n\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,\n\t\t\t\t\t   addr + PAGE_SIZE);\n\n\t\t__set_bit(pgoff, cwalk->bitmap);\n\t\tcwalk->start = min(cwalk->start, pgoff);\n\t\tcwalk->end = max(cwalk->end, pgoff + 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wp_clean_pmd_entry(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tpmd_t pmdval = pmdp_get_lockless(pmd);\n\n\t \n\tif (pmd_trans_huge(pmdval) || pmd_devmap(pmdval)) {\n\t\tWARN_ON(pmd_write(pmdval) || pmd_dirty(pmdval));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n\treturn 0;\n}\n\n \nstatic int wp_clean_pud_entry(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD\n\tpud_t pudval = READ_ONCE(*pud);\n\n\t \n\tif (pud_trans_huge(pudval) || pud_devmap(pudval)) {\n\t\tWARN_ON(pud_write(pudval) || pud_dirty(pudval));\n\t\twalk->action = ACTION_CONTINUE;\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic int wp_clean_pre_vma(unsigned long start, unsigned long end,\n\t\t\t    struct mm_walk *walk)\n{\n\tstruct wp_walk *wpwalk = walk->private;\n\n\twpwalk->tlbflush_start = end;\n\twpwalk->tlbflush_end = start;\n\n\tmmu_notifier_range_init(&wpwalk->range, MMU_NOTIFY_PROTECTION_PAGE, 0,\n\t\t\t\twalk->mm, start, end);\n\tmmu_notifier_invalidate_range_start(&wpwalk->range);\n\tflush_cache_range(walk->vma, start, end);\n\n\t \n\tinc_tlb_flush_pending(walk->mm);\n\n\treturn 0;\n}\n\n \nstatic void wp_clean_post_vma(struct mm_walk *walk)\n{\n\tstruct wp_walk *wpwalk = walk->private;\n\n\tif (mm_tlb_flush_nested(walk->mm))\n\t\tflush_tlb_range(walk->vma, wpwalk->range.start,\n\t\t\t\twpwalk->range.end);\n\telse if (wpwalk->tlbflush_end > wpwalk->tlbflush_start)\n\t\tflush_tlb_range(walk->vma, wpwalk->tlbflush_start,\n\t\t\t\twpwalk->tlbflush_end);\n\n\tmmu_notifier_invalidate_range_end(&wpwalk->range);\n\tdec_tlb_flush_pending(walk->mm);\n}\n\n \nstatic int wp_clean_test_walk(unsigned long start, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tunsigned long vm_flags = READ_ONCE(walk->vma->vm_flags);\n\n\t \n\tif ((vm_flags & (VM_SHARED | VM_MAYWRITE | VM_HUGETLB)) !=\n\t    (VM_SHARED | VM_MAYWRITE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct mm_walk_ops clean_walk_ops = {\n\t.pte_entry = clean_record_pte,\n\t.pmd_entry = wp_clean_pmd_entry,\n\t.pud_entry = wp_clean_pud_entry,\n\t.test_walk = wp_clean_test_walk,\n\t.pre_vma = wp_clean_pre_vma,\n\t.post_vma = wp_clean_post_vma\n};\n\nstatic const struct mm_walk_ops wp_walk_ops = {\n\t.pte_entry = wp_pte,\n\t.pmd_entry = wp_clean_pmd_entry,\n\t.pud_entry = wp_clean_pud_entry,\n\t.test_walk = wp_clean_test_walk,\n\t.pre_vma = wp_clean_pre_vma,\n\t.post_vma = wp_clean_post_vma\n};\n\n \nunsigned long wp_shared_mapping_range(struct address_space *mapping,\n\t\t\t\t      pgoff_t first_index, pgoff_t nr)\n{\n\tstruct wp_walk wpwalk = { .total = 0 };\n\n\ti_mmap_lock_read(mapping);\n\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &wp_walk_ops,\n\t\t\t\t  &wpwalk));\n\ti_mmap_unlock_read(mapping);\n\n\treturn wpwalk.total;\n}\nEXPORT_SYMBOL_GPL(wp_shared_mapping_range);\n\n \nunsigned long clean_record_shared_mapping_range(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t first_index, pgoff_t nr,\n\t\t\t\t\t\tpgoff_t bitmap_pgoff,\n\t\t\t\t\t\tunsigned long *bitmap,\n\t\t\t\t\t\tpgoff_t *start,\n\t\t\t\t\t\tpgoff_t *end)\n{\n\tbool none_set = (*start >= *end);\n\tstruct clean_walk cwalk = {\n\t\t.base = { .total = 0 },\n\t\t.bitmap_pgoff = bitmap_pgoff,\n\t\t.bitmap = bitmap,\n\t\t.start = none_set ? nr : *start,\n\t\t.end = none_set ? 0 : *end,\n\t};\n\n\ti_mmap_lock_read(mapping);\n\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &clean_walk_ops,\n\t\t\t\t  &cwalk.base));\n\ti_mmap_unlock_read(mapping);\n\n\t*start = cwalk.start;\n\t*end = cwalk.end;\n\n\treturn cwalk.base.total;\n}\nEXPORT_SYMBOL_GPL(clean_record_shared_mapping_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}