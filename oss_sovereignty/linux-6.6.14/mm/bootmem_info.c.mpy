{
  "module_name": "bootmem_info.c",
  "hash_id": "9cdcae886df05c2676c6059f223a56b2e0c941e8197c6356bc9dd26af977f8c4",
  "original_prompt": "Ingested from linux-6.6.14/mm/bootmem_info.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/bootmem_info.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n\nvoid get_page_bootmem(unsigned long info, struct page *page, unsigned long type)\n{\n\tpage->index = type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type = page->index;\n\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->index = 0;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tkmemleak_free_part(page_to_virt(page), PAGE_SIZE);\n\t\tfree_reserved_page(page);\n\t}\n}\n\n#ifndef CONFIG_SPARSEMEM_VMEMMAP\nstatic void __init register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\tstruct mem_section_usage *usage;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\t \n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\t \n\tpage = virt_to_page(memmap);\n\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;\n\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\n\n\t \n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, SECTION_INFO);\n\n\tusage = ms->usage;\n\tpage = virt_to_page(usage);\n\n\tmapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n\n}\n#else  \nstatic void __init register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\tstruct mem_section_usage *usage;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\n\n\tusage = ms->usage;\n\tpage = virt_to_page(usage);\n\n\tmapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}\n#endif  \n\nvoid __init register_page_bootmem_info_node(struct pglist_data *pgdat)\n{\n\tunsigned long i, pfn, end_pfn, nr_pages;\n\tint node = pgdat->node_id;\n\tstruct page *page;\n\n\tnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\n\tpage = virt_to_page(pgdat);\n\n\tfor (i = 0; i < nr_pages; i++, page++)\n\t\tget_page_bootmem(node, page, NODE_INFO);\n\n\tpfn = pgdat->node_start_pfn;\n\tend_pfn = pgdat_end_pfn(pgdat);\n\n\t \n\tfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\t \n\t\tif (pfn_valid(pfn) && (early_pfn_to_nid(pfn) == node))\n\t\t\tregister_page_bootmem_info_section(pfn);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}