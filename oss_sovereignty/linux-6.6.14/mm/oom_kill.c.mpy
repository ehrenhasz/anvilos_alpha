{
  "module_name": "oom_kill.c",
  "hash_id": "6cf2674394876589445291300a7e3e4089ece4ba1fdc71e5b141f6119502239e",
  "original_prompt": "Ingested from linux-6.6.14/mm/oom_kill.c",
  "human_readable_source": "\n \n\n#include <linux/oom.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/timex.h>\n#include <linux/jiffies.h>\n#include <linux/cpuset.h>\n#include <linux/export.h>\n#include <linux/notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/ftrace.h>\n#include <linux/ratelimit.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/mmu_notifier.h>\n\n#include <asm/tlb.h>\n#include \"internal.h\"\n#include \"slab.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/oom.h>\n\nstatic int sysctl_panic_on_oom;\nstatic int sysctl_oom_kill_allocating_task;\nstatic int sysctl_oom_dump_tasks = 1;\n\n \nDEFINE_MUTEX(oom_lock);\n \nDEFINE_MUTEX(oom_adj_mutex);\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}\n\n#ifdef CONFIG_NUMA\n \nstatic bool oom_cpuset_eligible(struct task_struct *start,\n\t\t\t\tstruct oom_control *oc)\n{\n\tstruct task_struct *tsk;\n\tbool ret = false;\n\tconst nodemask_t *mask = oc->nodemask;\n\n\trcu_read_lock();\n\tfor_each_thread(start, tsk) {\n\t\tif (mask) {\n\t\t\t \n\t\t\tret = mempolicy_in_oom_domain(tsk, mask);\n\t\t} else {\n\t\t\t \n\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n#else\nstatic bool oom_cpuset_eligible(struct task_struct *tsk, struct oom_control *oc)\n{\n\treturn true;\n}\n#endif  \n\n \nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}\n\n \nstatic inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}\n\n \nstatic bool oom_unkillable_task(struct task_struct *p)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool should_dump_unreclaim_slab(void)\n{\n\tunsigned long nr_lru;\n\n\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +\n\t\t global_node_page_state(NR_INACTIVE_ANON) +\n\t\t global_node_page_state(NR_ACTIVE_FILE) +\n\t\t global_node_page_state(NR_INACTIVE_FILE) +\n\t\t global_node_page_state(NR_ISOLATED_ANON) +\n\t\t global_node_page_state(NR_ISOLATED_FILE) +\n\t\t global_node_page_state(NR_UNEVICTABLE);\n\n\treturn (global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B) > nr_lru);\n}\n\n \nlong oom_badness(struct task_struct *p, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p))\n\t\treturn LONG_MIN;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn LONG_MIN;\n\n\t \n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn LONG_MIN;\n\t}\n\n\t \n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t \n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\treturn points;\n}\n\nstatic const char * const oom_constraint_text[] = {\n\t[CONSTRAINT_NONE] = \"CONSTRAINT_NONE\",\n\t[CONSTRAINT_CPUSET] = \"CONSTRAINT_CPUSET\",\n\t[CONSTRAINT_MEMORY_POLICY] = \"CONSTRAINT_MEMORY_POLICY\",\n\t[CONSTRAINT_MEMCG] = \"CONSTRAINT_MEMCG\",\n};\n\n \nstatic enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type highest_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\n\t \n\toc->totalpages = totalram_pages() + total_swap_pages;\n\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\t \n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\n\t \n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_present_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\n\t \n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thighest_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_present_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}\n\nstatic int oom_evaluate_task(struct task_struct *task, void *arg)\n{\n\tstruct oom_control *oc = arg;\n\tlong points;\n\n\tif (oom_unkillable_task(task))\n\t\tgoto next;\n\n\t \n\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(task, oc))\n\t\tgoto next;\n\n\t \n\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {\n\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))\n\t\t\tgoto next;\n\t\tgoto abort;\n\t}\n\n\t \n\tif (oom_task_origin(task)) {\n\t\tpoints = LONG_MAX;\n\t\tgoto select;\n\t}\n\n\tpoints = oom_badness(task, oc->totalpages);\n\tif (points == LONG_MIN || points < oc->chosen_points)\n\t\tgoto next;\n\nselect:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\tget_task_struct(task);\n\toc->chosen = task;\n\toc->chosen_points = points;\nnext:\n\treturn 0;\nabort:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\toc->chosen = (void *)-1UL;\n\treturn 1;\n}\n\n \nstatic void select_bad_process(struct oom_control *oc)\n{\n\toc->chosen_points = LONG_MIN;\n\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tif (oom_evaluate_task(p, oc))\n\t\t\t\tbreak;\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic int dump_task(struct task_struct *p, void *arg)\n{\n\tstruct oom_control *oc = arg;\n\tstruct task_struct *task;\n\n\tif (oom_unkillable_task(p))\n\t\treturn 0;\n\n\t \n\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(p, oc))\n\t\treturn 0;\n\n\ttask = find_lock_task_mm(p);\n\tif (!task) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\",\n\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),\n\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\n\t\tmm_pgtables_bytes(task->mm),\n\t\tget_mm_counter(task->mm, MM_SWAPENTS),\n\t\ttask->signal->oom_score_adj, task->comm);\n\ttask_unlock(task);\n\n\treturn 0;\n}\n\n \nstatic void dump_tasks(struct oom_control *oc)\n{\n\tpr_info(\"Tasks state (memory values in pages):\\n\");\n\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\");\n\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, dump_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tdump_task(p, oc);\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void dump_oom_summary(struct oom_control *oc, struct task_struct *victim)\n{\n\t \n\tpr_info(\"oom-kill:constraint=%s,nodemask=%*pbl\",\n\t\t\toom_constraint_text[oc->constraint],\n\t\t\tnodemask_pr_args(oc->nodemask));\n\tcpuset_print_current_mems_allowed();\n\tmem_cgroup_print_oom_context(oc->memcg, victim);\n\tpr_cont(\",task=%s,pid=%d,uid=%d\\n\", victim->comm, victim->pid,\n\t\tfrom_kuid(&init_user_ns, task_uid(victim)));\n}\n\nstatic void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask, oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_meminfo(oc->memcg);\n\telse {\n\t\t__show_mem(SHOW_MEM_FILTER_NODES, oc->nodemask, gfp_zone(oc->gfp_mask));\n\t\tif (should_dump_unreclaim_slab())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc);\n\tif (p)\n\t\tdump_oom_summary(oc, p);\n}\n\n \nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);\n\nstatic bool oom_killer_disabled __read_mostly;\n\n \nbool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}\n\n#ifdef CONFIG_MMU\n \nstatic struct task_struct *oom_reaper_th;\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_reaper_wait);\nstatic struct task_struct *oom_reaper_list;\nstatic DEFINE_SPINLOCK(oom_reaper_lock);\n\nstatic bool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tVMA_ITERATOR(vmi, mm, 0);\n\n\t \n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor_each_vma(vmi, vma) {\n\t\tif (vma->vm_flags & (VM_HUGETLB|VM_PFNMAP))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tstruct mmu_notifier_range range;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0,\n\t\t\t\t\t\tmm, vma->vm_start,\n\t\t\t\t\t\tvma->vm_end);\n\t\t\ttlb_gather_mmu(&tlb, mm);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(&range)) {\n\t\t\t\ttlb_finish_mmu(&tlb);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, range.start, range.end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(&range);\n\t\t\ttlb_finish_mmu(&tlb);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tbool ret = true;\n\n\tif (!mmap_read_trylock(mm)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\treturn false;\n\t}\n\n\t \n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t \n\tret = __oom_reap_task_mm(mm);\n\tif (!ret)\n\t\tgoto out_finish;\n\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\nout_finish:\n\ttrace_finish_task_reaping(tsk->pid);\nout_unlock:\n\tmmap_read_unlock(mm);\n\n\treturn ret;\n}\n\n#define MAX_OOM_REAP_RETRIES 10\nstatic void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t \n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tsched_show_task(tsk);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t \n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t \n\tput_task_struct(tsk);\n}\n\nstatic int oom_reaper(void *unused)\n{\n\tset_freezable();\n\n\twhile (true) {\n\t\tstruct task_struct *tsk = NULL;\n\n\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);\n\t\tspin_lock_irq(&oom_reaper_lock);\n\t\tif (oom_reaper_list != NULL) {\n\t\t\ttsk = oom_reaper_list;\n\t\t\toom_reaper_list = tsk->oom_reaper_list;\n\t\t}\n\t\tspin_unlock_irq(&oom_reaper_lock);\n\n\t\tif (tsk)\n\t\t\toom_reap_task(tsk);\n\t}\n\n\treturn 0;\n}\n\nstatic void wake_oom_reaper(struct timer_list *timer)\n{\n\tstruct task_struct *tsk = container_of(timer, struct task_struct,\n\t\t\toom_reaper_timer);\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\tunsigned long flags;\n\n\t \n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tput_task_struct(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&oom_reaper_lock, flags);\n\ttsk->oom_reaper_list = oom_reaper_list;\n\toom_reaper_list = tsk;\n\tspin_unlock_irqrestore(&oom_reaper_lock, flags);\n\ttrace_wake_reaper(tsk->pid);\n\twake_up(&oom_reaper_wait);\n}\n\n \n#define OOM_REAPER_DELAY (2*HZ)\nstatic void queue_oom_reaper(struct task_struct *tsk)\n{\n\t \n\tif (test_and_set_bit(MMF_OOM_REAP_QUEUED, &tsk->signal->oom_mm->flags))\n\t\treturn;\n\n\tget_task_struct(tsk);\n\ttimer_setup(&tsk->oom_reaper_timer, wake_oom_reaper, 0);\n\ttsk->oom_reaper_timer.expires = jiffies + OOM_REAPER_DELAY;\n\tadd_timer(&tsk->oom_reaper_timer);\n}\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table vm_oom_kill_table[] = {\n\t{\n\t\t.procname\t= \"panic_on_oom\",\n\t\t.data\t\t= &sysctl_panic_on_oom,\n\t\t.maxlen\t\t= sizeof(sysctl_panic_on_oom),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"oom_kill_allocating_task\",\n\t\t.data\t\t= &sysctl_oom_kill_allocating_task,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_kill_allocating_task),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"oom_dump_tasks\",\n\t\t.data\t\t= &sysctl_oom_dump_tasks,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_dump_tasks),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{}\n};\n#endif\n\nstatic int __init oom_init(void)\n{\n\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");\n#ifdef CONFIG_SYSCTL\n\tregister_sysctl_init(\"vm\", vm_oom_kill_table);\n#endif\n\treturn 0;\n}\nsubsys_initcall(oom_init)\n#else\nstatic inline void queue_oom_reaper(struct task_struct *tsk)\n{\n}\n#endif  \n\n \nstatic void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t \n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t \n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm))\n\t\tmmgrab(tsk->signal->oom_mm);\n\n\t \n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}\n\n \nvoid exit_oom_victim(void)\n{\n\tclear_thread_flag(TIF_MEMDIE);\n\n\tif (!atomic_dec_return(&oom_victims))\n\t\twake_up_all(&oom_victims_wait);\n}\n\n \nvoid oom_killer_enable(void)\n{\n\toom_killer_disabled = false;\n\tpr_info(\"OOM killer enabled.\\n\");\n}\n\n \nbool oom_killer_disable(signed long timeout)\n{\n\tsigned long ret;\n\n\t \n\tif (mutex_lock_killable(&oom_lock))\n\t\treturn false;\n\toom_killer_disabled = true;\n\tmutex_unlock(&oom_lock);\n\n\tret = wait_event_interruptible_timeout(oom_victims_wait,\n\t\t\t!atomic_read(&oom_victims), timeout);\n\tif (ret <= 0) {\n\t\toom_killer_enable();\n\t\treturn false;\n\t}\n\tpr_info(\"OOM killer disabled.\\n\");\n\n\treturn true;\n}\n\nstatic inline bool __task_will_free_mem(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\n\t \n\tif (sig->core_state)\n\t\treturn false;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\treturn true;\n\n\tif (thread_group_empty(task) && (task->flags & PF_EXITING))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t \n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t \n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t \n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void __oom_kill_process(struct task_struct *victim, const char *message)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tpr_info(\"%s: OOM victim %d (%s) is already exiting. Skip killing the task\\n\",\n\t\t\tmessage, task_pid_nr(victim), victim->comm);\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t \n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t \n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t \n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"%s: Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB, UID:%u pgtables:%lukB oom_score_adj:%hd\\n\",\n\t\tmessage, task_pid_nr(victim), victim->comm, K(mm->total_vm),\n\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)),\n\t\tfrom_kuid(&init_user_ns, task_uid(victim)),\n\t\tmm_pgtables_bytes(mm) >> 10, victim->signal->oom_score_adj);\n\ttask_unlock(victim);\n\n\t \n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\tqueue_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}\n\n \nstatic int oom_kill_memcg_member(struct task_struct *task, void *message)\n{\n\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN &&\n\t    !is_global_init(task)) {\n\t\tget_task_struct(task);\n\t\t__oom_kill_process(task, message);\n\t}\n\treturn 0;\n}\n\nstatic void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *victim = oc->chosen;\n\tstruct mem_cgroup *oom_group;\n\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\t \n\ttask_lock(victim);\n\tif (task_will_free_mem(victim)) {\n\t\tmark_oom_victim(victim);\n\t\tqueue_oom_reaper(victim);\n\t\ttask_unlock(victim);\n\t\tput_task_struct(victim);\n\t\treturn;\n\t}\n\ttask_unlock(victim);\n\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, victim);\n\n\t \n\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);\n\n\t__oom_kill_process(victim, message);\n\n\t \n\tif (oom_group) {\n\t\tmemcg_memory_event(oom_group, MEMCG_OOM_GROUP_KILL);\n\t\tmem_cgroup_print_oom_group(oom_group);\n\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member,\n\t\t\t\t      (void *)message);\n\t\tmem_cgroup_put(oom_group);\n\t}\n}\n\n \nstatic void check_panic_on_oom(struct oom_control *oc)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t \n\t\tif (oc->constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t \n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}\n\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nint register_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&oom_notify_list, nb);\n}\nEXPORT_SYMBOL_GPL(register_oom_notifier);\n\nint unregister_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_oom_notifier);\n\n \nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0 && !is_sysrq_oom(oc))\n\t\t\t \n\t\t\treturn true;\n\t}\n\n\t \n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\tqueue_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t \n\tif (!(oc->gfp_mask & __GFP_FS) && !is_memcg_oom(oc))\n\t\treturn true;\n\n\t \n\toc->constraint = constrained_alloc(oc);\n\tif (oc->constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current) &&\n\t    oom_cpuset_eligible(current, oc) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t \n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t \n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}\n\n \nvoid pagefault_out_of_memory(void)\n{\n\tstatic DEFINE_RATELIMIT_STATE(pfoom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (mem_cgroup_oom_synchronize(true))\n\t\treturn;\n\n\tif (fatal_signal_pending(current))\n\t\treturn;\n\n\tif (__ratelimit(&pfoom_rs))\n\t\tpr_warn(\"Huh VM_FAULT_OOM leaked out to the #PF handler. Retrying PF\\n\");\n}\n\nSYSCALL_DEFINE2(process_mrelease, int, pidfd, unsigned int, flags)\n{\n#ifdef CONFIG_MMU\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tstruct task_struct *p;\n\tunsigned int f_flags;\n\tbool reap = false;\n\tlong ret = 0;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\ttask = pidfd_get_task(pidfd, &f_flags);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\t \n\tp = find_lock_task_mm(task);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto put_task;\n\t}\n\n\tmm = p->mm;\n\tmmgrab(mm);\n\n\tif (task_will_free_mem(p))\n\t\treap = true;\n\telse {\n\t\t \n\t\tif (!test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\t\tret = -EINVAL;\n\t}\n\ttask_unlock(p);\n\n\tif (!reap)\n\t\tgoto drop_mm;\n\n\tif (mmap_read_lock_killable(mm)) {\n\t\tret = -EINTR;\n\t\tgoto drop_mm;\n\t}\n\t \n\tif (!test_bit(MMF_OOM_SKIP, &mm->flags) && !__oom_reap_task_mm(mm))\n\t\tret = -EAGAIN;\n\tmmap_read_unlock(mm);\n\ndrop_mm:\n\tmmdrop(mm);\nput_task:\n\tput_task_struct(task);\n\treturn ret;\n#else\n\treturn -ENOSYS;\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}