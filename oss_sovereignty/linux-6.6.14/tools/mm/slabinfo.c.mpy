{
  "module_name": "slabinfo.c",
  "hash_id": "2d001976860edb55cbf07d22395e3d265525e6271af4a0c68e16516e4b39c45d",
  "original_prompt": "Ingested from linux-6.6.14/tools/mm/slabinfo.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <getopt.h>\n#include <regex.h>\n#include <errno.h>\n\n#define MAX_SLABS 500\n#define MAX_ALIASES 500\n#define MAX_NODES 1024\n\nstruct slabinfo {\n\tchar *name;\n\tint alias;\n\tint refs;\n\tint aliases, align, cache_dma, cpu_slabs, destroy_by_rcu;\n\tunsigned int hwcache_align, object_size, objs_per_slab;\n\tunsigned int sanity_checks, slab_size, store_user, trace;\n\tint order, poison, reclaim_account, red_zone;\n\tunsigned long partial, objects, slabs, objects_partial, objects_total;\n\tunsigned long alloc_fastpath, alloc_slowpath;\n\tunsigned long free_fastpath, free_slowpath;\n\tunsigned long free_frozen, free_add_partial, free_remove_partial;\n\tunsigned long alloc_from_partial, alloc_slab, free_slab, alloc_refill;\n\tunsigned long cpuslab_flush, deactivate_full, deactivate_empty;\n\tunsigned long deactivate_to_head, deactivate_to_tail;\n\tunsigned long deactivate_remote_frees, order_fallback;\n\tunsigned long cmpxchg_double_cpu_fail, cmpxchg_double_fail;\n\tunsigned long alloc_node_mismatch, deactivate_bypass;\n\tunsigned long cpu_partial_alloc, cpu_partial_free;\n\tint numa[MAX_NODES];\n\tint numa_partial[MAX_NODES];\n} slabinfo[MAX_SLABS];\n\nstruct aliasinfo {\n\tchar *name;\n\tchar *ref;\n\tstruct slabinfo *slab;\n} aliasinfo[MAX_ALIASES];\n\nint slabs;\nint actual_slabs;\nint aliases;\nint alias_targets;\nint highest_node;\n\nchar buffer[4096];\n\nint show_empty;\nint show_report;\nint show_alias;\nint show_slab;\nint skip_zero = 1;\nint show_numa;\nint show_track;\nint show_first_alias;\nint validate;\nint shrink;\nint show_inverted;\nint show_single_ref;\nint show_totals;\nint sort_size;\nint sort_active;\nint set_debug;\nint show_ops;\nint sort_partial;\nint show_activity;\nint output_lines = -1;\nint sort_loss;\nint extended_totals;\nint show_bytes;\nint unreclaim_only;\n\n \nint sanity;\nint redzone;\nint poison;\nint tracking;\nint tracing;\n\nint page_size;\n\nregex_t pattern;\n\nstatic void fatal(const char *x, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, x);\n\tvfprintf(stderr, x, ap);\n\tva_end(ap);\n\texit(EXIT_FAILURE);\n}\n\nstatic void usage(void)\n{\n\tprintf(\"slabinfo 4/15/2011. (c) 2007 sgi/(c) 2011 Linux Foundation.\\n\\n\"\n\t\t\"slabinfo [-aABDefhilLnoPrsStTUvXz1] [N=K] [-dafzput] [slab-regexp]\\n\"\n\t\t\"-a|--aliases           Show aliases\\n\"\n\t\t\"-A|--activity          Most active slabs first\\n\"\n\t\t\"-B|--Bytes             Show size in bytes\\n\"\n\t\t\"-D|--display-active    Switch line format to activity\\n\"\n\t\t\"-e|--empty             Show empty slabs\\n\"\n\t\t\"-f|--first-alias       Show first alias\\n\"\n\t\t\"-h|--help              Show usage information\\n\"\n\t\t\"-i|--inverted          Inverted list\\n\"\n\t\t\"-l|--slabs             Show slabs\\n\"\n\t\t\"-L|--Loss              Sort by loss\\n\"\n\t\t\"-n|--numa              Show NUMA information\\n\"\n\t\t\"-N|--lines=K           Show the first K slabs\\n\"\n\t\t\"-o|--ops               Show kmem_cache_ops\\n\"\n\t\t\"-P|--partial           Sort by number of partial slabs\\n\"\n\t\t\"-r|--report            Detailed report on single slabs\\n\"\n\t\t\"-s|--shrink            Shrink slabs\\n\"\n\t\t\"-S|--Size              Sort by size\\n\"\n\t\t\"-t|--tracking          Show alloc/free information\\n\"\n\t\t\"-T|--Totals            Show summary information\\n\"\n\t\t\"-U|--Unreclaim         Show unreclaimable slabs only\\n\"\n\t\t\"-v|--validate          Validate slabs\\n\"\n\t\t\"-X|--Xtotals           Show extended summary information\\n\"\n\t\t\"-z|--zero              Include empty slabs\\n\"\n\t\t\"-1|--1ref              Single reference\\n\"\n\n\t\t\"\\n\"\n\t\t\"-d  | --debug          Switch off all debug options\\n\"\n\t\t\"-da | --debug=a        Switch on all debug options (--debug=FZPU)\\n\"\n\n\t\t\"\\n\"\n\t\t\"-d[afzput] | --debug=[afzput]\\n\"\n\t\t\"    f | F              Sanity Checks (SLAB_CONSISTENCY_CHECKS)\\n\"\n\t\t\"    z | Z              Redzoning\\n\"\n\t\t\"    p | P              Poisoning\\n\"\n\t\t\"    u | U              Tracking\\n\"\n\t\t\"    t | T              Tracing\\n\"\n\n\t\t\"\\nSorting options (--Loss, --Size, --Partial) are mutually exclusive\\n\"\n\t);\n}\n\nstatic unsigned long read_obj(const char *name)\n{\n\tFILE *f = fopen(name, \"r\");\n\n\tif (!f) {\n\t\tbuffer[0] = 0;\n\t\tif (errno == EACCES)\n\t\t\tfatal(\"%s, Try using superuser\\n\", strerror(errno));\n\t} else {\n\t\tif (!fgets(buffer, sizeof(buffer), f))\n\t\t\tbuffer[0] = 0;\n\t\tfclose(f);\n\t\tif (buffer[strlen(buffer)] == '\\n')\n\t\t\tbuffer[strlen(buffer)] = 0;\n\t}\n\treturn strlen(buffer);\n}\n\n\n \nstatic unsigned long get_obj(const char *name)\n{\n\tif (!read_obj(name))\n\t\treturn 0;\n\n\treturn atol(buffer);\n}\n\nstatic unsigned long get_obj_and_str(const char *name, char **x)\n{\n\tunsigned long result = 0;\n\tchar *p;\n\n\t*x = NULL;\n\n\tif (!read_obj(name)) {\n\t\tx = NULL;\n\t\treturn 0;\n\t}\n\tresult = strtoul(buffer, &p, 10);\n\twhile (*p == ' ')\n\t\tp++;\n\tif (*p)\n\t\t*x = strdup(p);\n\treturn result;\n}\n\nstatic void set_obj(struct slabinfo *s, const char *name, int n)\n{\n\tchar x[100];\n\tFILE *f;\n\n\tsnprintf(x, 100, \"%s/%s\", s->name, name);\n\tf = fopen(x, \"w\");\n\tif (!f)\n\t\tfatal(\"Cannot write to %s\\n\", x);\n\n\tfprintf(f, \"%d\\n\", n);\n\tfclose(f);\n}\n\nstatic unsigned long read_slab_obj(struct slabinfo *s, const char *name)\n{\n\tchar x[100];\n\tFILE *f;\n\tsize_t l;\n\n\tsnprintf(x, 100, \"%s/%s\", s->name, name);\n\tf = fopen(x, \"r\");\n\tif (!f) {\n\t\tbuffer[0] = 0;\n\t\tl = 0;\n\t} else {\n\t\tl = fread(buffer, 1, sizeof(buffer), f);\n\t\tbuffer[l] = 0;\n\t\tfclose(f);\n\t}\n\treturn l;\n}\n\nstatic unsigned long read_debug_slab_obj(struct slabinfo *s, const char *name)\n{\n\tchar x[128];\n\tFILE *f;\n\tsize_t l;\n\n\tsnprintf(x, 128, \"/sys/kernel/debug/slab/%s/%s\", s->name, name);\n\tf = fopen(x, \"r\");\n\tif (!f) {\n\t\tbuffer[0] = 0;\n\t\tl = 0;\n\t} else {\n\t\tl = fread(buffer, 1, sizeof(buffer), f);\n\t\tbuffer[l] = 0;\n\t\tfclose(f);\n\t}\n\treturn l;\n}\n\n \nstatic int store_size(char *buffer, unsigned long value)\n{\n\tunsigned long divisor = 1;\n\tchar trailer = 0;\n\tint n;\n\n\tif (!show_bytes) {\n\t\tif (value > 1000000000UL) {\n\t\t\tdivisor = 100000000UL;\n\t\t\ttrailer = 'G';\n\t\t} else if (value > 1000000UL) {\n\t\t\tdivisor = 100000UL;\n\t\t\ttrailer = 'M';\n\t\t} else if (value > 1000UL) {\n\t\t\tdivisor = 100;\n\t\t\ttrailer = 'K';\n\t\t}\n\t}\n\n\tvalue /= divisor;\n\tn = sprintf(buffer, \"%ld\",value);\n\tif (trailer) {\n\t\tbuffer[n] = trailer;\n\t\tn++;\n\t\tbuffer[n] = 0;\n\t}\n\tif (divisor != 1) {\n\t\tmemmove(buffer + n - 2, buffer + n - 3, 4);\n\t\tbuffer[n-2] = '.';\n\t\tn++;\n\t}\n\treturn n;\n}\n\nstatic void decode_numa_list(int *numa, char *t)\n{\n\tint node;\n\tint nr;\n\n\tmemset(numa, 0, MAX_NODES * sizeof(int));\n\n\tif (!t)\n\t\treturn;\n\n\twhile (*t == 'N') {\n\t\tt++;\n\t\tnode = strtoul(t, &t, 10);\n\t\tif (*t == '=') {\n\t\t\tt++;\n\t\t\tnr = strtoul(t, &t, 10);\n\t\t\tnuma[node] = nr;\n\t\t\tif (node > highest_node)\n\t\t\t\thighest_node = node;\n\t\t}\n\t\twhile (*t == ' ')\n\t\t\tt++;\n\t}\n}\n\nstatic void slab_validate(struct slabinfo *s)\n{\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tset_obj(s, \"validate\", 1);\n}\n\nstatic void slab_shrink(struct slabinfo *s)\n{\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tset_obj(s, \"shrink\", 1);\n}\n\nint line = 0;\n\nstatic void first_line(void)\n{\n\tif (show_activity)\n\t\tprintf(\"Name                   Objects      Alloc       Free\"\n\t\t\t\"   %%Fast Fallb O CmpX   UL\\n\");\n\telse\n\t\tprintf(\"Name                   Objects Objsize           %s \"\n\t\t\t\"Slabs/Part/Cpu  O/S O %%Fr %%Ef Flg\\n\",\n\t\t\tsort_loss ? \" Loss\" : \"Space\");\n}\n\n \nstatic struct aliasinfo *find_one_alias(struct slabinfo *find)\n{\n\tstruct aliasinfo *a;\n\tstruct aliasinfo *best = NULL;\n\n\tfor(a = aliasinfo;a < aliasinfo + aliases; a++) {\n\t\tif (a->slab == find &&\n\t\t\t(!best || strlen(best->name) < strlen(a->name))) {\n\t\t\t\tbest = a;\n\t\t\t\tif (strncmp(a->name,\"kmall\", 5) == 0)\n\t\t\t\t\treturn best;\n\t\t\t}\n\t}\n\treturn best;\n}\n\nstatic unsigned long slab_size(struct slabinfo *s)\n{\n\treturn \ts->slabs * (page_size << s->order);\n}\n\nstatic unsigned long slab_activity(struct slabinfo *s)\n{\n\treturn \ts->alloc_fastpath + s->free_fastpath +\n\t\ts->alloc_slowpath + s->free_slowpath;\n}\n\nstatic unsigned long slab_waste(struct slabinfo *s)\n{\n\treturn\tslab_size(s) - s->objects * s->object_size;\n}\n\nstatic void slab_numa(struct slabinfo *s, int mode)\n{\n\tint node;\n\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tif (!highest_node) {\n\t\tprintf(\"\\n%s: No NUMA information available.\\n\", s->name);\n\t\treturn;\n\t}\n\n\tif (skip_zero && !s->slabs)\n\t\treturn;\n\n\tif (!line) {\n\t\tprintf(\"\\n%-21s:\", mode ? \"NUMA nodes\" : \"Slab\");\n\t\tfor(node = 0; node <= highest_node; node++)\n\t\t\tprintf(\" %4d\", node);\n\t\tprintf(\"\\n----------------------\");\n\t\tfor(node = 0; node <= highest_node; node++)\n\t\t\tprintf(\"-----\");\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"%-21s \", mode ? \"All slabs\" : s->name);\n\tfor(node = 0; node <= highest_node; node++) {\n\t\tchar b[20];\n\n\t\tstore_size(b, s->numa[node]);\n\t\tprintf(\" %4s\", b);\n\t}\n\tprintf(\"\\n\");\n\tif (mode) {\n\t\tprintf(\"%-21s \", \"Partial slabs\");\n\t\tfor(node = 0; node <= highest_node; node++) {\n\t\t\tchar b[20];\n\n\t\t\tstore_size(b, s->numa_partial[node]);\n\t\t\tprintf(\" %4s\", b);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tline++;\n}\n\nstatic void show_tracking(struct slabinfo *s)\n{\n\tprintf(\"\\n%s: Kernel object allocation\\n\", s->name);\n\tprintf(\"-----------------------------------------------------------------------\\n\");\n\tif (read_debug_slab_obj(s, \"alloc_traces\"))\n\t\tprintf(\"%s\", buffer);\n\telse if (read_slab_obj(s, \"alloc_calls\"))\n\t\tprintf(\"%s\", buffer);\n\telse\n\t\tprintf(\"No Data\\n\");\n\n\tprintf(\"\\n%s: Kernel object freeing\\n\", s->name);\n\tprintf(\"------------------------------------------------------------------------\\n\");\n\tif (read_debug_slab_obj(s, \"free_traces\"))\n\t\tprintf(\"%s\", buffer);\n\telse if (read_slab_obj(s, \"free_calls\"))\n\t\tprintf(\"%s\", buffer);\n\telse\n\t\tprintf(\"No Data\\n\");\n\n}\n\nstatic void ops(struct slabinfo *s)\n{\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tif (read_slab_obj(s, \"ops\")) {\n\t\tprintf(\"\\n%s: kmem_cache operations\\n\", s->name);\n\t\tprintf(\"--------------------------------------------\\n\");\n\t\tprintf(\"%s\", buffer);\n\t} else\n\t\tprintf(\"\\n%s has no kmem_cache operations\\n\", s->name);\n}\n\nstatic const char *onoff(int x)\n{\n\tif (x)\n\t\treturn \"On \";\n\treturn \"Off\";\n}\n\nstatic void slab_stats(struct slabinfo *s)\n{\n\tunsigned long total_alloc;\n\tunsigned long total_free;\n\tunsigned long total;\n\n\tif (!s->alloc_slab)\n\t\treturn;\n\n\ttotal_alloc = s->alloc_fastpath + s->alloc_slowpath;\n\ttotal_free = s->free_fastpath + s->free_slowpath;\n\n\tif (!total_alloc)\n\t\treturn;\n\n\tprintf(\"\\n\");\n\tprintf(\"Slab Perf Counter       Alloc     Free %%Al %%Fr\\n\");\n\tprintf(\"--------------------------------------------------\\n\");\n\tprintf(\"Fastpath             %8lu %8lu %3lu %3lu\\n\",\n\t\ts->alloc_fastpath, s->free_fastpath,\n\t\ts->alloc_fastpath * 100 / total_alloc,\n\t\ttotal_free ? s->free_fastpath * 100 / total_free : 0);\n\tprintf(\"Slowpath             %8lu %8lu %3lu %3lu\\n\",\n\t\ttotal_alloc - s->alloc_fastpath, s->free_slowpath,\n\t\t(total_alloc - s->alloc_fastpath) * 100 / total_alloc,\n\t\ttotal_free ? s->free_slowpath * 100 / total_free : 0);\n\tprintf(\"Page Alloc           %8lu %8lu %3lu %3lu\\n\",\n\t\ts->alloc_slab, s->free_slab,\n\t\ts->alloc_slab * 100 / total_alloc,\n\t\ttotal_free ? s->free_slab * 100 / total_free : 0);\n\tprintf(\"Add partial          %8lu %8lu %3lu %3lu\\n\",\n\t\ts->deactivate_to_head + s->deactivate_to_tail,\n\t\ts->free_add_partial,\n\t\t(s->deactivate_to_head + s->deactivate_to_tail) * 100 / total_alloc,\n\t\ttotal_free ? s->free_add_partial * 100 / total_free : 0);\n\tprintf(\"Remove partial       %8lu %8lu %3lu %3lu\\n\",\n\t\ts->alloc_from_partial, s->free_remove_partial,\n\t\ts->alloc_from_partial * 100 / total_alloc,\n\t\ttotal_free ? s->free_remove_partial * 100 / total_free : 0);\n\n\tprintf(\"Cpu partial list     %8lu %8lu %3lu %3lu\\n\",\n\t\ts->cpu_partial_alloc, s->cpu_partial_free,\n\t\ts->cpu_partial_alloc * 100 / total_alloc,\n\t\ttotal_free ? s->cpu_partial_free * 100 / total_free : 0);\n\n\tprintf(\"RemoteObj/SlabFrozen %8lu %8lu %3lu %3lu\\n\",\n\t\ts->deactivate_remote_frees, s->free_frozen,\n\t\ts->deactivate_remote_frees * 100 / total_alloc,\n\t\ttotal_free ? s->free_frozen * 100 / total_free : 0);\n\n\tprintf(\"Total                %8lu %8lu\\n\\n\", total_alloc, total_free);\n\n\tif (s->cpuslab_flush)\n\t\tprintf(\"Flushes %8lu\\n\", s->cpuslab_flush);\n\n\ttotal = s->deactivate_full + s->deactivate_empty +\n\t\t\ts->deactivate_to_head + s->deactivate_to_tail + s->deactivate_bypass;\n\n\tif (total) {\n\t\tprintf(\"\\nSlab Deactivation             Occurrences %%\\n\");\n\t\tprintf(\"-------------------------------------------------\\n\");\n\t\tprintf(\"Slab full                     %7lu  %3lu%%\\n\",\n\t\t\ts->deactivate_full, (s->deactivate_full * 100) / total);\n\t\tprintf(\"Slab empty                    %7lu  %3lu%%\\n\",\n\t\t\ts->deactivate_empty, (s->deactivate_empty * 100) / total);\n\t\tprintf(\"Moved to head of partial list %7lu  %3lu%%\\n\",\n\t\t\ts->deactivate_to_head, (s->deactivate_to_head * 100) / total);\n\t\tprintf(\"Moved to tail of partial list %7lu  %3lu%%\\n\",\n\t\t\ts->deactivate_to_tail, (s->deactivate_to_tail * 100) / total);\n\t\tprintf(\"Deactivation bypass           %7lu  %3lu%%\\n\",\n\t\t\ts->deactivate_bypass, (s->deactivate_bypass * 100) / total);\n\t\tprintf(\"Refilled from foreign frees   %7lu  %3lu%%\\n\",\n\t\t\ts->alloc_refill, (s->alloc_refill * 100) / total);\n\t\tprintf(\"Node mismatch                 %7lu  %3lu%%\\n\",\n\t\t\ts->alloc_node_mismatch, (s->alloc_node_mismatch * 100) / total);\n\t}\n\n\tif (s->cmpxchg_double_fail || s->cmpxchg_double_cpu_fail) {\n\t\tprintf(\"\\nCmpxchg_double Looping\\n------------------------\\n\");\n\t\tprintf(\"Locked Cmpxchg Double redos   %lu\\nUnlocked Cmpxchg Double redos %lu\\n\",\n\t\t\ts->cmpxchg_double_fail, s->cmpxchg_double_cpu_fail);\n\t}\n}\n\nstatic void report(struct slabinfo *s)\n{\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tprintf(\"\\nSlabcache: %-15s  Aliases: %2d Order : %2d Objects: %lu\\n\",\n\t\ts->name, s->aliases, s->order, s->objects);\n\tif (s->hwcache_align)\n\t\tprintf(\"** Hardware cacheline aligned\\n\");\n\tif (s->cache_dma)\n\t\tprintf(\"** Memory is allocated in a special DMA zone\\n\");\n\tif (s->destroy_by_rcu)\n\t\tprintf(\"** Slabs are destroyed via RCU\\n\");\n\tif (s->reclaim_account)\n\t\tprintf(\"** Reclaim accounting active\\n\");\n\n\tprintf(\"\\nSizes (bytes)     Slabs              Debug                Memory\\n\");\n\tprintf(\"------------------------------------------------------------------------\\n\");\n\tprintf(\"Object : %7d  Total  : %7ld   Sanity Checks : %s  Total: %7ld\\n\",\n\t\t\ts->object_size, s->slabs, onoff(s->sanity_checks),\n\t\t\ts->slabs * (page_size << s->order));\n\tprintf(\"SlabObj: %7d  Full   : %7ld   Redzoning     : %s  Used : %7ld\\n\",\n\t\t\ts->slab_size, s->slabs - s->partial - s->cpu_slabs,\n\t\t\tonoff(s->red_zone), s->objects * s->object_size);\n\tprintf(\"SlabSiz: %7d  Partial: %7ld   Poisoning     : %s  Loss : %7ld\\n\",\n\t\t\tpage_size << s->order, s->partial, onoff(s->poison),\n\t\t\ts->slabs * (page_size << s->order) - s->objects * s->object_size);\n\tprintf(\"Loss   : %7d  CpuSlab: %7d   Tracking      : %s  Lalig: %7ld\\n\",\n\t\t\ts->slab_size - s->object_size, s->cpu_slabs, onoff(s->store_user),\n\t\t\t(s->slab_size - s->object_size) * s->objects);\n\tprintf(\"Align  : %7d  Objects: %7d   Tracing       : %s  Lpadd: %7ld\\n\",\n\t\t\ts->align, s->objs_per_slab, onoff(s->trace),\n\t\t\t((page_size << s->order) - s->objs_per_slab * s->slab_size) *\n\t\t\ts->slabs);\n\n\tops(s);\n\tshow_tracking(s);\n\tslab_numa(s, 1);\n\tslab_stats(s);\n}\n\nstatic void slabcache(struct slabinfo *s)\n{\n\tchar size_str[20];\n\tchar dist_str[40];\n\tchar flags[20];\n\tchar *p = flags;\n\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tif (unreclaim_only && s->reclaim_account)\n\t\treturn;\n\n\tif (actual_slabs == 1) {\n\t\treport(s);\n\t\treturn;\n\t}\n\n\tif (skip_zero && !show_empty && !s->slabs)\n\t\treturn;\n\n\tif (show_empty && s->slabs)\n\t\treturn;\n\n\tif (sort_loss == 0)\n\t\tstore_size(size_str, slab_size(s));\n\telse\n\t\tstore_size(size_str, slab_waste(s));\n\tsnprintf(dist_str, 40, \"%lu/%lu/%d\", s->slabs - s->cpu_slabs,\n\t\t\t\t\t\ts->partial, s->cpu_slabs);\n\n\tif (!line++)\n\t\tfirst_line();\n\n\tif (s->aliases)\n\t\t*p++ = '*';\n\tif (s->cache_dma)\n\t\t*p++ = 'd';\n\tif (s->hwcache_align)\n\t\t*p++ = 'A';\n\tif (s->poison)\n\t\t*p++ = 'P';\n\tif (s->reclaim_account)\n\t\t*p++ = 'a';\n\tif (s->red_zone)\n\t\t*p++ = 'Z';\n\tif (s->sanity_checks)\n\t\t*p++ = 'F';\n\tif (s->store_user)\n\t\t*p++ = 'U';\n\tif (s->trace)\n\t\t*p++ = 'T';\n\n\t*p = 0;\n\tif (show_activity) {\n\t\tunsigned long total_alloc;\n\t\tunsigned long total_free;\n\n\t\ttotal_alloc = s->alloc_fastpath + s->alloc_slowpath;\n\t\ttotal_free = s->free_fastpath + s->free_slowpath;\n\n\t\tprintf(\"%-21s %8ld %10ld %10ld %3ld %3ld %5ld %1d %4ld %4ld\\n\",\n\t\t\ts->name, s->objects,\n\t\t\ttotal_alloc, total_free,\n\t\t\ttotal_alloc ? (s->alloc_fastpath * 100 / total_alloc) : 0,\n\t\t\ttotal_free ? (s->free_fastpath * 100 / total_free) : 0,\n\t\t\ts->order_fallback, s->order, s->cmpxchg_double_fail,\n\t\t\ts->cmpxchg_double_cpu_fail);\n\t} else {\n\t\tprintf(\"%-21s %8ld %7d %15s %14s %4d %1d %3ld %3ld %s\\n\",\n\t\t\ts->name, s->objects, s->object_size, size_str, dist_str,\n\t\t\ts->objs_per_slab, s->order,\n\t\t\ts->slabs ? (s->partial * 100) / s->slabs : 100,\n\t\t\ts->slabs ? (s->objects * s->object_size * 100) /\n\t\t\t\t(s->slabs * (page_size << s->order)) : 100,\n\t\t\tflags);\n\t}\n}\n\n \nstatic int debug_opt_scan(char *opt)\n{\n\tif (!opt || !opt[0] || strcmp(opt, \"-\") == 0)\n\t\treturn 1;\n\n\tif (strcasecmp(opt, \"a\") == 0) {\n\t\tsanity = 1;\n\t\tpoison = 1;\n\t\tredzone = 1;\n\t\ttracking = 1;\n\t\treturn 1;\n\t}\n\n\tfor ( ; *opt; opt++)\n\t\tswitch (*opt) {\n\t\tcase 'F' : case 'f':\n\t\t\tif (sanity)\n\t\t\t\treturn 0;\n\t\t\tsanity = 1;\n\t\t\tbreak;\n\t\tcase 'P' : case 'p':\n\t\t\tif (poison)\n\t\t\t\treturn 0;\n\t\t\tpoison = 1;\n\t\t\tbreak;\n\n\t\tcase 'Z' : case 'z':\n\t\t\tif (redzone)\n\t\t\t\treturn 0;\n\t\t\tredzone = 1;\n\t\t\tbreak;\n\n\t\tcase 'U' : case 'u':\n\t\t\tif (tracking)\n\t\t\t\treturn 0;\n\t\t\ttracking = 1;\n\t\t\tbreak;\n\n\t\tcase 'T' : case 't':\n\t\t\tif (tracing)\n\t\t\t\treturn 0;\n\t\t\ttracing = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}\n\nstatic int slab_empty(struct slabinfo *s)\n{\n\tif (s->objects > 0)\n\t\treturn 0;\n\n\t \n\tif (s->slabs != 0)\n\t\tset_obj(s, \"shrink\", 1);\n\n\treturn 1;\n}\n\nstatic void slab_debug(struct slabinfo *s)\n{\n\tif (strcmp(s->name, \"*\") == 0)\n\t\treturn;\n\n\tif (sanity && !s->sanity_checks) {\n\t\tset_obj(s, \"sanity_checks\", 1);\n\t}\n\tif (!sanity && s->sanity_checks) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"sanity_checks\", 0);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot disable sanity checks\\n\", s->name);\n\t}\n\tif (redzone && !s->red_zone) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"red_zone\", 1);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot enable redzoning\\n\", s->name);\n\t}\n\tif (!redzone && s->red_zone) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"red_zone\", 0);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot disable redzoning\\n\", s->name);\n\t}\n\tif (poison && !s->poison) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"poison\", 1);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot enable poisoning\\n\", s->name);\n\t}\n\tif (!poison && s->poison) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"poison\", 0);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot disable poisoning\\n\", s->name);\n\t}\n\tif (tracking && !s->store_user) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"store_user\", 1);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot enable tracking\\n\", s->name);\n\t}\n\tif (!tracking && s->store_user) {\n\t\tif (slab_empty(s))\n\t\t\tset_obj(s, \"store_user\", 0);\n\t\telse\n\t\t\tfprintf(stderr, \"%s not empty cannot disable tracking\\n\", s->name);\n\t}\n\tif (tracing && !s->trace) {\n\t\tif (slabs == 1)\n\t\t\tset_obj(s, \"trace\", 1);\n\t\telse\n\t\t\tfprintf(stderr, \"%s can only enable trace for one slab at a time\\n\", s->name);\n\t}\n\tif (!tracing && s->trace)\n\t\tset_obj(s, \"trace\", 1);\n}\n\nstatic void totals(void)\n{\n\tstruct slabinfo *s;\n\n\tint used_slabs = 0;\n\tchar b1[20], b2[20], b3[20], b4[20];\n\tunsigned long long max = 1ULL << 63;\n\n\t \n\tunsigned long long min_objsize = max, max_objsize = 0, avg_objsize;\n\n\t \n\tunsigned long long min_partial = max, max_partial = 0,\n\t\t\t\tavg_partial, total_partial = 0;\n\n\t \n\tunsigned long long min_slabs = max, max_slabs = 0,\n\t\t\t\tavg_slabs, total_slabs = 0;\n\n\t \n\tunsigned long long min_size = max, max_size = 0,\n\t\t\t\tavg_size, total_size = 0;\n\n\t \n\tunsigned long long min_used = max, max_used = 0,\n\t\t\t\tavg_used, total_used = 0;\n\n\t \n\tunsigned long long min_waste = max, max_waste = 0,\n\t\t\t\tavg_waste, total_waste = 0;\n\t \n\tunsigned long long min_objects = max, max_objects = 0,\n\t\t\t\tavg_objects, total_objects = 0;\n\t \n\tunsigned long long min_objwaste = max,\n\t\t\t\tmax_objwaste = 0, avg_objwaste,\n\t\t\t\ttotal_objwaste = 0;\n\n\t \n\tunsigned long long min_memobj = max,\n\t\t\t\tmax_memobj = 0, avg_memobj,\n\t\t\t\ttotal_objsize = 0;\n\n\t \n\tunsigned long min_ppart = 100, max_ppart = 0,\n\t\t\t\tavg_ppart, total_ppart = 0;\n\n\t \n\tunsigned long min_partobj = max, max_partobj = 0,\n\t\t\t\tavg_partobj, total_partobj = 0;\n\n\t \n\tunsigned long min_ppartobj = 100, max_ppartobj = 0,\n\t\t\t\tavg_ppartobj, total_ppartobj = 0;\n\n\n\tfor (s = slabinfo; s < slabinfo + slabs; s++) {\n\t\tunsigned long long size;\n\t\tunsigned long used;\n\t\tunsigned long long wasted;\n\t\tunsigned long long objwaste;\n\t\tunsigned long percentage_partial_slabs;\n\t\tunsigned long percentage_partial_objs;\n\n\t\tif (!s->slabs || !s->objects)\n\t\t\tcontinue;\n\n\t\tused_slabs++;\n\n\t\tsize = slab_size(s);\n\t\tused = s->objects * s->object_size;\n\t\twasted = size - used;\n\t\tobjwaste = s->slab_size - s->object_size;\n\n\t\tpercentage_partial_slabs = s->partial * 100 / s->slabs;\n\t\tif (percentage_partial_slabs > 100)\n\t\t\tpercentage_partial_slabs = 100;\n\n\t\tpercentage_partial_objs = s->objects_partial * 100\n\t\t\t\t\t\t\t/ s->objects;\n\n\t\tif (percentage_partial_objs > 100)\n\t\t\tpercentage_partial_objs = 100;\n\n\t\tif (s->object_size < min_objsize)\n\t\t\tmin_objsize = s->object_size;\n\t\tif (s->partial < min_partial)\n\t\t\tmin_partial = s->partial;\n\t\tif (s->slabs < min_slabs)\n\t\t\tmin_slabs = s->slabs;\n\t\tif (size < min_size)\n\t\t\tmin_size = size;\n\t\tif (wasted < min_waste)\n\t\t\tmin_waste = wasted;\n\t\tif (objwaste < min_objwaste)\n\t\t\tmin_objwaste = objwaste;\n\t\tif (s->objects < min_objects)\n\t\t\tmin_objects = s->objects;\n\t\tif (used < min_used)\n\t\t\tmin_used = used;\n\t\tif (s->objects_partial < min_partobj)\n\t\t\tmin_partobj = s->objects_partial;\n\t\tif (percentage_partial_slabs < min_ppart)\n\t\t\tmin_ppart = percentage_partial_slabs;\n\t\tif (percentage_partial_objs < min_ppartobj)\n\t\t\tmin_ppartobj = percentage_partial_objs;\n\t\tif (s->slab_size < min_memobj)\n\t\t\tmin_memobj = s->slab_size;\n\n\t\tif (s->object_size > max_objsize)\n\t\t\tmax_objsize = s->object_size;\n\t\tif (s->partial > max_partial)\n\t\t\tmax_partial = s->partial;\n\t\tif (s->slabs > max_slabs)\n\t\t\tmax_slabs = s->slabs;\n\t\tif (size > max_size)\n\t\t\tmax_size = size;\n\t\tif (wasted > max_waste)\n\t\t\tmax_waste = wasted;\n\t\tif (objwaste > max_objwaste)\n\t\t\tmax_objwaste = objwaste;\n\t\tif (s->objects > max_objects)\n\t\t\tmax_objects = s->objects;\n\t\tif (used > max_used)\n\t\t\tmax_used = used;\n\t\tif (s->objects_partial > max_partobj)\n\t\t\tmax_partobj = s->objects_partial;\n\t\tif (percentage_partial_slabs > max_ppart)\n\t\t\tmax_ppart = percentage_partial_slabs;\n\t\tif (percentage_partial_objs > max_ppartobj)\n\t\t\tmax_ppartobj = percentage_partial_objs;\n\t\tif (s->slab_size > max_memobj)\n\t\t\tmax_memobj = s->slab_size;\n\n\t\ttotal_partial += s->partial;\n\t\ttotal_slabs += s->slabs;\n\t\ttotal_size += size;\n\t\ttotal_waste += wasted;\n\n\t\ttotal_objects += s->objects;\n\t\ttotal_used += used;\n\t\ttotal_partobj += s->objects_partial;\n\t\ttotal_ppart += percentage_partial_slabs;\n\t\ttotal_ppartobj += percentage_partial_objs;\n\n\t\ttotal_objwaste += s->objects * objwaste;\n\t\ttotal_objsize += s->objects * s->slab_size;\n\t}\n\n\tif (!total_objects) {\n\t\tprintf(\"No objects\\n\");\n\t\treturn;\n\t}\n\tif (!used_slabs) {\n\t\tprintf(\"No slabs\\n\");\n\t\treturn;\n\t}\n\n\t \n\tavg_partial = total_partial / used_slabs;\n\tavg_slabs = total_slabs / used_slabs;\n\tavg_size = total_size / used_slabs;\n\tavg_waste = total_waste / used_slabs;\n\n\tavg_objects = total_objects / used_slabs;\n\tavg_used = total_used / used_slabs;\n\tavg_partobj = total_partobj / used_slabs;\n\tavg_ppart = total_ppart / used_slabs;\n\tavg_ppartobj = total_ppartobj / used_slabs;\n\n\t \n\tavg_objsize = total_used / total_objects;\n\tavg_objwaste = total_objwaste / total_objects;\n\tavg_partobj = total_partobj * 100 / total_objects;\n\tavg_memobj = total_objsize / total_objects;\n\n\tprintf(\"Slabcache Totals\\n\");\n\tprintf(\"----------------\\n\");\n\tprintf(\"Slabcaches : %15d   Aliases  : %11d->%-3d  Active:    %3d\\n\",\n\t\t\tslabs, aliases, alias_targets, used_slabs);\n\n\tstore_size(b1, total_size);store_size(b2, total_waste);\n\tstore_size(b3, total_waste * 100 / total_used);\n\tprintf(\"Memory used: %15s   # Loss   : %15s   MRatio:%6s%%\\n\", b1, b2, b3);\n\n\tstore_size(b1, total_objects);store_size(b2, total_partobj);\n\tstore_size(b3, total_partobj * 100 / total_objects);\n\tprintf(\"# Objects  : %15s   # PartObj: %15s   ORatio:%6s%%\\n\", b1, b2, b3);\n\n\tprintf(\"\\n\");\n\tprintf(\"Per Cache         Average              \"\n\t\t\"Min              Max            Total\\n\");\n\tprintf(\"---------------------------------------\"\n\t\t\"-------------------------------------\\n\");\n\n\tstore_size(b1, avg_objects);store_size(b2, min_objects);\n\tstore_size(b3, max_objects);store_size(b4, total_objects);\n\tprintf(\"#Objects  %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_slabs);store_size(b2, min_slabs);\n\tstore_size(b3, max_slabs);store_size(b4, total_slabs);\n\tprintf(\"#Slabs    %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_partial);store_size(b2, min_partial);\n\tstore_size(b3, max_partial);store_size(b4, total_partial);\n\tprintf(\"#PartSlab %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\tstore_size(b1, avg_ppart);store_size(b2, min_ppart);\n\tstore_size(b3, max_ppart);\n\tstore_size(b4, total_partial * 100  / total_slabs);\n\tprintf(\"%%PartSlab%15s%% %15s%% %15s%% %15s%%\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_partobj);store_size(b2, min_partobj);\n\tstore_size(b3, max_partobj);\n\tstore_size(b4, total_partobj);\n\tprintf(\"PartObjs  %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_ppartobj);store_size(b2, min_ppartobj);\n\tstore_size(b3, max_ppartobj);\n\tstore_size(b4, total_partobj * 100 / total_objects);\n\tprintf(\"%% PartObj%15s%% %15s%% %15s%% %15s%%\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_size);store_size(b2, min_size);\n\tstore_size(b3, max_size);store_size(b4, total_size);\n\tprintf(\"Memory    %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_used);store_size(b2, min_used);\n\tstore_size(b3, max_used);store_size(b4, total_used);\n\tprintf(\"Used      %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tstore_size(b1, avg_waste);store_size(b2, min_waste);\n\tstore_size(b3, max_waste);store_size(b4, total_waste);\n\tprintf(\"Loss      %15s  %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3,\tb4);\n\n\tprintf(\"\\n\");\n\tprintf(\"Per Object        Average              \"\n\t\t\"Min              Max\\n\");\n\tprintf(\"---------------------------------------\"\n\t\t\"--------------------\\n\");\n\n\tstore_size(b1, avg_memobj);store_size(b2, min_memobj);\n\tstore_size(b3, max_memobj);\n\tprintf(\"Memory    %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3);\n\tstore_size(b1, avg_objsize);store_size(b2, min_objsize);\n\tstore_size(b3, max_objsize);\n\tprintf(\"User      %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3);\n\n\tstore_size(b1, avg_objwaste);store_size(b2, min_objwaste);\n\tstore_size(b3, max_objwaste);\n\tprintf(\"Loss      %15s  %15s  %15s\\n\",\n\t\t\tb1,\tb2,\tb3);\n}\n\nstatic void sort_slabs(void)\n{\n\tstruct slabinfo *s1,*s2;\n\n\tfor (s1 = slabinfo; s1 < slabinfo + slabs; s1++) {\n\t\tfor (s2 = s1 + 1; s2 < slabinfo + slabs; s2++) {\n\t\t\tint result;\n\n\t\t\tif (sort_size) {\n\t\t\t\tif (slab_size(s1) == slab_size(s2))\n\t\t\t\t\tresult = strcasecmp(s1->name, s2->name);\n\t\t\t\telse\n\t\t\t\t\tresult = slab_size(s1) < slab_size(s2);\n\t\t\t} else if (sort_active) {\n\t\t\t\tif (slab_activity(s1) == slab_activity(s2))\n\t\t\t\t\tresult = strcasecmp(s1->name, s2->name);\n\t\t\t\telse\n\t\t\t\t\tresult = slab_activity(s1) < slab_activity(s2);\n\t\t\t} else if (sort_loss) {\n\t\t\t\tif (slab_waste(s1) == slab_waste(s2))\n\t\t\t\t\tresult = strcasecmp(s1->name, s2->name);\n\t\t\t\telse\n\t\t\t\t\tresult = slab_waste(s1) < slab_waste(s2);\n\t\t\t} else if (sort_partial) {\n\t\t\t\tif (s1->partial == s2->partial)\n\t\t\t\t\tresult = strcasecmp(s1->name, s2->name);\n\t\t\t\telse\n\t\t\t\t\tresult = s1->partial < s2->partial;\n\t\t\t} else\n\t\t\t\tresult = strcasecmp(s1->name, s2->name);\n\n\t\t\tif (show_inverted)\n\t\t\t\tresult = -result;\n\n\t\t\tif (result > 0) {\n\t\t\t\tstruct slabinfo t;\n\n\t\t\t\tmemcpy(&t, s1, sizeof(struct slabinfo));\n\t\t\t\tmemcpy(s1, s2, sizeof(struct slabinfo));\n\t\t\t\tmemcpy(s2, &t, sizeof(struct slabinfo));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void sort_aliases(void)\n{\n\tstruct aliasinfo *a1,*a2;\n\n\tfor (a1 = aliasinfo; a1 < aliasinfo + aliases; a1++) {\n\t\tfor (a2 = a1 + 1; a2 < aliasinfo + aliases; a2++) {\n\t\t\tchar *n1, *n2;\n\n\t\t\tn1 = a1->name;\n\t\t\tn2 = a2->name;\n\t\t\tif (show_alias && !show_inverted) {\n\t\t\t\tn1 = a1->ref;\n\t\t\t\tn2 = a2->ref;\n\t\t\t}\n\t\t\tif (strcasecmp(n1, n2) > 0) {\n\t\t\t\tstruct aliasinfo t;\n\n\t\t\t\tmemcpy(&t, a1, sizeof(struct aliasinfo));\n\t\t\t\tmemcpy(a1, a2, sizeof(struct aliasinfo));\n\t\t\t\tmemcpy(a2, &t, sizeof(struct aliasinfo));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void link_slabs(void)\n{\n\tstruct aliasinfo *a;\n\tstruct slabinfo *s;\n\n\tfor (a = aliasinfo; a < aliasinfo + aliases; a++) {\n\n\t\tfor (s = slabinfo; s < slabinfo + slabs; s++)\n\t\t\tif (strcmp(a->ref, s->name) == 0) {\n\t\t\t\ta->slab = s;\n\t\t\t\ts->refs++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (s == slabinfo + slabs)\n\t\t\tfatal(\"Unresolved alias %s\\n\", a->ref);\n\t}\n}\n\nstatic void alias(void)\n{\n\tstruct aliasinfo *a;\n\tchar *active = NULL;\n\n\tsort_aliases();\n\tlink_slabs();\n\n\tfor(a = aliasinfo; a < aliasinfo + aliases; a++) {\n\n\t\tif (!show_single_ref && a->slab->refs == 1)\n\t\t\tcontinue;\n\n\t\tif (!show_inverted) {\n\t\t\tif (active) {\n\t\t\t\tif (strcmp(a->slab->name, active) == 0) {\n\t\t\t\t\tprintf(\" %s\", a->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n%-12s <- %s\", a->slab->name, a->name);\n\t\t\tactive = a->slab->name;\n\t\t}\n\t\telse\n\t\t\tprintf(\"%-15s -> %s\\n\", a->name, a->slab->name);\n\t}\n\tif (active)\n\t\tprintf(\"\\n\");\n}\n\n\nstatic void rename_slabs(void)\n{\n\tstruct slabinfo *s;\n\tstruct aliasinfo *a;\n\n\tfor (s = slabinfo; s < slabinfo + slabs; s++) {\n\t\tif (*s->name != ':')\n\t\t\tcontinue;\n\n\t\tif (s->refs > 1 && !show_first_alias)\n\t\t\tcontinue;\n\n\t\ta = find_one_alias(s);\n\n\t\tif (a)\n\t\t\ts->name = a->name;\n\t\telse {\n\t\t\ts->name = \"*\";\n\t\t\tactual_slabs--;\n\t\t}\n\t}\n}\n\nstatic int slab_mismatch(char *slab)\n{\n\treturn regexec(&pattern, slab, 0, NULL, 0);\n}\n\nstatic void read_slab_dir(void)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tstruct slabinfo *slab = slabinfo;\n\tstruct aliasinfo *alias = aliasinfo;\n\tchar *p;\n\tchar *t;\n\tint count;\n\n\tif (chdir(\"/sys/kernel/slab\") && chdir(\"/sys/slab\"))\n\t\tfatal(\"SYSFS support for SLUB not active\\n\");\n\n\tdir = opendir(\".\");\n\twhile ((de = readdir(dir))) {\n\t\tif (de->d_name[0] == '.' ||\n\t\t\t(de->d_name[0] != ':' && slab_mismatch(de->d_name)))\n\t\t\t\tcontinue;\n\t\tswitch (de->d_type) {\n\t\t   case DT_LNK:\n\t\t\talias->name = strdup(de->d_name);\n\t\t\tcount = readlink(de->d_name, buffer, sizeof(buffer)-1);\n\n\t\t\tif (count < 0)\n\t\t\t\tfatal(\"Cannot read symlink %s\\n\", de->d_name);\n\n\t\t\tbuffer[count] = 0;\n\t\t\tp = buffer + count;\n\t\t\twhile (p > buffer && p[-1] != '/')\n\t\t\t\tp--;\n\t\t\talias->ref = strdup(p);\n\t\t\talias++;\n\t\t\tbreak;\n\t\t   case DT_DIR:\n\t\t\tif (chdir(de->d_name))\n\t\t\t\tfatal(\"Unable to access slab %s\\n\", slab->name);\n\t\t\tslab->name = strdup(de->d_name);\n\t\t\tslab->alias = 0;\n\t\t\tslab->refs = 0;\n\t\t\tslab->aliases = get_obj(\"aliases\");\n\t\t\tslab->align = get_obj(\"align\");\n\t\t\tslab->cache_dma = get_obj(\"cache_dma\");\n\t\t\tslab->cpu_slabs = get_obj(\"cpu_slabs\");\n\t\t\tslab->destroy_by_rcu = get_obj(\"destroy_by_rcu\");\n\t\t\tslab->hwcache_align = get_obj(\"hwcache_align\");\n\t\t\tslab->object_size = get_obj(\"object_size\");\n\t\t\tslab->objects = get_obj(\"objects\");\n\t\t\tslab->objects_partial = get_obj(\"objects_partial\");\n\t\t\tslab->objects_total = get_obj(\"objects_total\");\n\t\t\tslab->objs_per_slab = get_obj(\"objs_per_slab\");\n\t\t\tslab->order = get_obj(\"order\");\n\t\t\tslab->partial = get_obj(\"partial\");\n\t\t\tslab->partial = get_obj_and_str(\"partial\", &t);\n\t\t\tdecode_numa_list(slab->numa_partial, t);\n\t\t\tfree(t);\n\t\t\tslab->poison = get_obj(\"poison\");\n\t\t\tslab->reclaim_account = get_obj(\"reclaim_account\");\n\t\t\tslab->red_zone = get_obj(\"red_zone\");\n\t\t\tslab->sanity_checks = get_obj(\"sanity_checks\");\n\t\t\tslab->slab_size = get_obj(\"slab_size\");\n\t\t\tslab->slabs = get_obj_and_str(\"slabs\", &t);\n\t\t\tdecode_numa_list(slab->numa, t);\n\t\t\tfree(t);\n\t\t\tslab->store_user = get_obj(\"store_user\");\n\t\t\tslab->trace = get_obj(\"trace\");\n\t\t\tslab->alloc_fastpath = get_obj(\"alloc_fastpath\");\n\t\t\tslab->alloc_slowpath = get_obj(\"alloc_slowpath\");\n\t\t\tslab->free_fastpath = get_obj(\"free_fastpath\");\n\t\t\tslab->free_slowpath = get_obj(\"free_slowpath\");\n\t\t\tslab->free_frozen= get_obj(\"free_frozen\");\n\t\t\tslab->free_add_partial = get_obj(\"free_add_partial\");\n\t\t\tslab->free_remove_partial = get_obj(\"free_remove_partial\");\n\t\t\tslab->alloc_from_partial = get_obj(\"alloc_from_partial\");\n\t\t\tslab->alloc_slab = get_obj(\"alloc_slab\");\n\t\t\tslab->alloc_refill = get_obj(\"alloc_refill\");\n\t\t\tslab->free_slab = get_obj(\"free_slab\");\n\t\t\tslab->cpuslab_flush = get_obj(\"cpuslab_flush\");\n\t\t\tslab->deactivate_full = get_obj(\"deactivate_full\");\n\t\t\tslab->deactivate_empty = get_obj(\"deactivate_empty\");\n\t\t\tslab->deactivate_to_head = get_obj(\"deactivate_to_head\");\n\t\t\tslab->deactivate_to_tail = get_obj(\"deactivate_to_tail\");\n\t\t\tslab->deactivate_remote_frees = get_obj(\"deactivate_remote_frees\");\n\t\t\tslab->order_fallback = get_obj(\"order_fallback\");\n\t\t\tslab->cmpxchg_double_cpu_fail = get_obj(\"cmpxchg_double_cpu_fail\");\n\t\t\tslab->cmpxchg_double_fail = get_obj(\"cmpxchg_double_fail\");\n\t\t\tslab->cpu_partial_alloc = get_obj(\"cpu_partial_alloc\");\n\t\t\tslab->cpu_partial_free = get_obj(\"cpu_partial_free\");\n\t\t\tslab->alloc_node_mismatch = get_obj(\"alloc_node_mismatch\");\n\t\t\tslab->deactivate_bypass = get_obj(\"deactivate_bypass\");\n\t\t\tchdir(\"..\");\n\t\t\tif (slab->name[0] == ':')\n\t\t\t\talias_targets++;\n\t\t\tslab++;\n\t\t\tbreak;\n\t\t   default :\n\t\t\tfatal(\"Unknown file type %lx\\n\", de->d_type);\n\t\t}\n\t}\n\tclosedir(dir);\n\tslabs = slab - slabinfo;\n\tactual_slabs = slabs;\n\taliases = alias - aliasinfo;\n\tif (slabs > MAX_SLABS)\n\t\tfatal(\"Too many slabs\\n\");\n\tif (aliases > MAX_ALIASES)\n\t\tfatal(\"Too many aliases\\n\");\n}\n\nstatic void output_slabs(void)\n{\n\tstruct slabinfo *slab;\n\tint lines = output_lines;\n\n\tfor (slab = slabinfo; (slab < slabinfo + slabs) &&\n\t\t\tlines != 0; slab++) {\n\n\t\tif (slab->alias)\n\t\t\tcontinue;\n\n\t\tif (lines != -1)\n\t\t\tlines--;\n\n\t\tif (show_numa)\n\t\t\tslab_numa(slab, 0);\n\t\telse if (show_track)\n\t\t\tshow_tracking(slab);\n\t\telse if (validate)\n\t\t\tslab_validate(slab);\n\t\telse if (shrink)\n\t\t\tslab_shrink(slab);\n\t\telse if (set_debug)\n\t\t\tslab_debug(slab);\n\t\telse if (show_ops)\n\t\t\tops(slab);\n\t\telse if (show_slab)\n\t\t\tslabcache(slab);\n\t\telse if (show_report)\n\t\t\treport(slab);\n\t}\n}\n\nstatic void _xtotals(char *heading, char *underline,\n\t\t     int loss, int size, int partial)\n{\n\tprintf(\"%s%s\", heading, underline);\n\tline = 0;\n\tsort_loss = loss;\n\tsort_size = size;\n\tsort_partial = partial;\n\tsort_slabs();\n\toutput_slabs();\n}\n\nstatic void xtotals(void)\n{\n\tchar *heading, *underline;\n\n\ttotals();\n\n\tlink_slabs();\n\trename_slabs();\n\n\theading = \"\\nSlabs sorted by size\\n\";\n\tunderline = \"--------------------\\n\";\n\t_xtotals(heading, underline, 0, 1, 0);\n\n\theading = \"\\nSlabs sorted by loss\\n\";\n\tunderline = \"--------------------\\n\";\n\t_xtotals(heading, underline, 1, 0, 0);\n\n\theading = \"\\nSlabs sorted by number of partial slabs\\n\";\n\tunderline = \"---------------------------------------\\n\";\n\t_xtotals(heading, underline, 0, 0, 1);\n\n\tprintf(\"\\n\");\n}\n\nstruct option opts[] = {\n\t{ \"aliases\", no_argument, NULL, 'a' },\n\t{ \"activity\", no_argument, NULL, 'A' },\n\t{ \"Bytes\", no_argument, NULL, 'B'},\n\t{ \"debug\", optional_argument, NULL, 'd' },\n\t{ \"display-activity\", no_argument, NULL, 'D' },\n\t{ \"empty\", no_argument, NULL, 'e' },\n\t{ \"first-alias\", no_argument, NULL, 'f' },\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"inverted\", no_argument, NULL, 'i'},\n\t{ \"slabs\", no_argument, NULL, 'l' },\n\t{ \"Loss\", no_argument, NULL, 'L'},\n\t{ \"numa\", no_argument, NULL, 'n' },\n\t{ \"lines\", required_argument, NULL, 'N'},\n\t{ \"ops\", no_argument, NULL, 'o' },\n\t{ \"partial\", no_argument, NULL, 'p'},\n\t{ \"report\", no_argument, NULL, 'r' },\n\t{ \"shrink\", no_argument, NULL, 's' },\n\t{ \"Size\", no_argument, NULL, 'S'},\n\t{ \"tracking\", no_argument, NULL, 't'},\n\t{ \"Totals\", no_argument, NULL, 'T'},\n\t{ \"Unreclaim\", no_argument, NULL, 'U'},\n\t{ \"validate\", no_argument, NULL, 'v' },\n\t{ \"Xtotals\", no_argument, NULL, 'X'},\n\t{ \"zero\", no_argument, NULL, 'z' },\n\t{ \"1ref\", no_argument, NULL, '1'},\n\t{ NULL, 0, NULL, 0 }\n};\n\nint main(int argc, char *argv[])\n{\n\tint c;\n\tint err;\n\tchar *pattern_source;\n\n\tpage_size = getpagesize();\n\n\twhile ((c = getopt_long(argc, argv, \"aABd::DefhilLnN:oPrsStTUvXz1\",\n\t\t\t\t\t\topts, NULL)) != -1)\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tshow_alias = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsort_active = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tshow_bytes = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debug = 1;\n\t\t\tif (!debug_opt_scan(optarg))\n\t\t\t\tfatal(\"Invalid debug option '%s'\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tshow_activity = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tshow_empty = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tshow_first_alias = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'i':\n\t\t\tshow_inverted = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_slab = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tsort_loss = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tshow_numa = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (optarg) {\n\t\t\t\toutput_lines = atoi(optarg);\n\t\t\t\tif (output_lines < 1)\n\t\t\t\t\toutput_lines = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tshow_ops = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tshow_report = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsort_partial = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tshrink = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsort_size = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tshow_track = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tshow_totals = 1;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tunreclaim_only = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvalidate = 1;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (output_lines == -1)\n\t\t\t\toutput_lines = 1;\n\t\t\textended_totals = 1;\n\t\t\tshow_bytes = 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tskip_zero = 0;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tshow_single_ref = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: Invalid option '%c'\\n\", argv[0], optopt);\n\n\t}\n\n\tif (!show_slab && !show_alias && !show_track && !show_report\n\t\t&& !validate && !shrink && !set_debug && !show_ops)\n\t\t\tshow_slab = 1;\n\n\tif (argc > optind)\n\t\tpattern_source = argv[optind];\n\telse\n\t\tpattern_source = \".*\";\n\n\terr = regcomp(&pattern, pattern_source, REG_ICASE|REG_NOSUB);\n\tif (err)\n\t\tfatal(\"%s: Invalid pattern '%s' code %d\\n\",\n\t\t\targv[0], pattern_source, err);\n\tread_slab_dir();\n\tif (show_alias) {\n\t\talias();\n\t} else if (extended_totals) {\n\t\txtotals();\n\t} else if (show_totals) {\n\t\ttotals();\n\t} else {\n\t\tlink_slabs();\n\t\trename_slabs();\n\t\tsort_slabs();\n\t\toutput_slabs();\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}