{
  "module_name": "page_owner_sort.c",
  "hash_id": "a07de18d282046050f15a26836f6b4a927f7191a41e7163762ffadecf06cac7a",
  "original_prompt": "Ingested from linux-6.6.14/tools/mm/page_owner_sort.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <regex.h>\n#include <errno.h>\n#include <linux/types.h>\n#include <getopt.h>\n\n#define bool int\n#define true 1\n#define false 0\n#define TASK_COMM_LEN 16\n\nstruct block_list {\n\tchar *txt;\n\tchar *comm; \n\tchar *stacktrace;\n\t__u64 ts_nsec;\n\t__u64 free_ts_nsec;\n\tint len;\n\tint num;\n\tint page_num;\n\tpid_t pid;\n\tpid_t tgid;\n\tint allocator;\n};\nenum FILTER_BIT {\n\tFILTER_UNRELEASE = 1<<1,\n\tFILTER_PID = 1<<2,\n\tFILTER_TGID = 1<<3,\n\tFILTER_COMM = 1<<4\n};\nenum CULL_BIT {\n\tCULL_UNRELEASE = 1<<1,\n\tCULL_PID = 1<<2,\n\tCULL_TGID = 1<<3,\n\tCULL_COMM = 1<<4,\n\tCULL_STACKTRACE = 1<<5,\n\tCULL_ALLOCATOR = 1<<6\n};\nenum ALLOCATOR_BIT {\n\tALLOCATOR_CMA = 1<<1,\n\tALLOCATOR_SLAB = 1<<2,\n\tALLOCATOR_VMALLOC = 1<<3,\n\tALLOCATOR_OTHERS = 1<<4\n};\nenum ARG_TYPE {\n\tARG_TXT, ARG_COMM, ARG_STACKTRACE, ARG_ALLOC_TS, ARG_FREE_TS,\n\tARG_CULL_TIME, ARG_PAGE_NUM, ARG_PID, ARG_TGID, ARG_UNKNOWN, ARG_FREE,\n\tARG_ALLOCATOR\n};\nenum SORT_ORDER {\n\tSORT_ASC = 1,\n\tSORT_DESC = -1,\n};\nstruct filter_condition {\n\tpid_t *pids;\n\tpid_t *tgids;\n\tchar **comms;\n\tint pids_size;\n\tint tgids_size;\n\tint comms_size;\n};\nstruct sort_condition {\n\tint (**cmps)(const void *, const void *);\n\tint *signs;\n\tint size;\n};\nstatic struct filter_condition fc;\nstatic struct sort_condition sc;\nstatic regex_t order_pattern;\nstatic regex_t pid_pattern;\nstatic regex_t tgid_pattern;\nstatic regex_t comm_pattern;\nstatic regex_t ts_nsec_pattern;\nstatic regex_t free_ts_nsec_pattern;\nstatic struct block_list *list;\nstatic int list_size;\nstatic int max_size;\nstatic int cull;\nstatic int filter;\nstatic bool debug_on;\n\nstatic void set_single_cmp(int (*cmp)(const void *, const void *), int sign);\n\nint read_block(char *buf, char *ext_buf, int buf_size, FILE *fin)\n{\n\tchar *curr = buf, *const buf_end = buf + buf_size;\n\n\twhile (buf_end - curr > 1 && fgets(curr, buf_end - curr, fin)) {\n\t\tif (*curr == '\\n') {  \n\t\t\treturn curr - buf;\n\t\t}\n\t\tif (!strncmp(curr, \"PFN\", 3)) {\n\t\t\tstrcpy(ext_buf, curr);\n\t\t\tcontinue;\n\t\t}\n\t\tcurr += strlen(curr);\n\t}\n\n\treturn -1;  \n}\n\nstatic int compare_txt(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn strcmp(l1->txt, l2->txt);\n}\n\nstatic int compare_stacktrace(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn strcmp(l1->stacktrace, l2->stacktrace);\n}\n\nstatic int compare_num(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->num - l2->num;\n}\n\nstatic int compare_page_num(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->page_num - l2->page_num;\n}\n\nstatic int compare_pid(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->pid - l2->pid;\n}\n\nstatic int compare_tgid(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->tgid - l2->tgid;\n}\n\nstatic int compare_allocator(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->allocator - l2->allocator;\n}\n\nstatic int compare_comm(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn strcmp(l1->comm, l2->comm);\n}\n\nstatic int compare_ts(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->ts_nsec < l2->ts_nsec ? -1 : 1;\n}\n\nstatic int compare_free_ts(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\treturn l1->free_ts_nsec < l2->free_ts_nsec ? -1 : 1;\n}\n\nstatic int compare_release(const void *p1, const void *p2)\n{\n\tconst struct block_list *l1 = p1, *l2 = p2;\n\n\tif (!l1->free_ts_nsec && !l2->free_ts_nsec)\n\t\treturn 0;\n\tif (l1->free_ts_nsec && l2->free_ts_nsec)\n\t\treturn 0;\n\treturn l1->free_ts_nsec ? 1 : -1;\n}\n\nstatic int compare_cull_condition(const void *p1, const void *p2)\n{\n\tif (cull == 0)\n\t\treturn compare_txt(p1, p2);\n\tif ((cull & CULL_STACKTRACE) && compare_stacktrace(p1, p2))\n\t\treturn compare_stacktrace(p1, p2);\n\tif ((cull & CULL_PID) && compare_pid(p1, p2))\n\t\treturn compare_pid(p1, p2);\n\tif ((cull & CULL_TGID) && compare_tgid(p1, p2))\n\t\treturn compare_tgid(p1, p2);\n\tif ((cull & CULL_COMM) && compare_comm(p1, p2))\n\t\treturn compare_comm(p1, p2);\n\tif ((cull & CULL_UNRELEASE) && compare_release(p1, p2))\n\t\treturn compare_release(p1, p2);\n\tif ((cull & CULL_ALLOCATOR) && compare_allocator(p1, p2))\n\t\treturn compare_allocator(p1, p2);\n\treturn 0;\n}\n\nstatic int compare_sort_condition(const void *p1, const void *p2)\n{\n\tint cmp = 0;\n\n\tfor (int i = 0; i < sc.size; ++i)\n\t\tif (cmp == 0)\n\t\t\tcmp = sc.signs[i] * sc.cmps[i](p1, p2);\n\treturn cmp;\n}\n\nstatic int search_pattern(regex_t *pattern, char *pattern_str, char *buf)\n{\n\tint err, val_len;\n\tregmatch_t pmatch[2];\n\n\terr = regexec(pattern, buf, 2, pmatch, REG_NOTBOL);\n\tif (err != 0 || pmatch[1].rm_so == -1) {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"no matching pattern in %s\\n\", buf);\n\t\treturn -1;\n\t}\n\tval_len = pmatch[1].rm_eo - pmatch[1].rm_so;\n\n\tmemcpy(pattern_str, buf + pmatch[1].rm_so, val_len);\n\n\treturn 0;\n}\n\nstatic bool check_regcomp(regex_t *pattern, const char *regex)\n{\n\tint err;\n\n\terr = regcomp(pattern, regex, REG_EXTENDED | REG_NEWLINE);\n\tif (err != 0 || pattern->re_nsub != 1) {\n\t\tfprintf(stderr, \"Invalid pattern %s code %d\\n\", regex, err);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic char **explode(char sep, const char *str, int *size)\n{\n\tint count = 0, len = strlen(str);\n\tint lastindex = -1, j = 0;\n\n\tfor (int i = 0; i < len; i++)\n\t\tif (str[i] == sep)\n\t\t\tcount++;\n\tchar **ret = calloc(++count, sizeof(char *));\n\n\tfor (int i = 0; i < len; i++) {\n\t\tif (str[i] == sep) {\n\t\t\tret[j] = calloc(i - lastindex, sizeof(char));\n\t\t\tmemcpy(ret[j++], str + lastindex + 1, i - lastindex - 1);\n\t\t\tlastindex = i;\n\t\t}\n\t}\n\tif (lastindex <= len - 1) {\n\t\tret[j] = calloc(len - lastindex, sizeof(char));\n\t\tmemcpy(ret[j++], str + lastindex + 1, strlen(str) - 1 - lastindex);\n\t}\n\t*size = j;\n\treturn ret;\n}\n\nstatic void free_explode(char **arr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}\n\n# define FIELD_BUFF 25\n\nstatic int get_page_num(char *buf)\n{\n\tint order_val;\n\tchar order_str[FIELD_BUFF] = {0};\n\tchar *endptr;\n\n\tsearch_pattern(&order_pattern, order_str, buf);\n\terrno = 0;\n\torder_val = strtol(order_str, &endptr, 10);\n\tif (order_val > 64 || errno != 0 || endptr == order_str || *endptr != '\\0') {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong order in follow buf:\\n%s\\n\", buf);\n\t\treturn 0;\n\t}\n\n\treturn 1 << order_val;\n}\n\nstatic pid_t get_pid(char *buf)\n{\n\tpid_t pid;\n\tchar pid_str[FIELD_BUFF] = {0};\n\tchar *endptr;\n\n\tsearch_pattern(&pid_pattern, pid_str, buf);\n\terrno = 0;\n\tpid = strtol(pid_str, &endptr, 10);\n\tif (errno != 0 || endptr == pid_str || *endptr != '\\0') {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong/invalid pid in follow buf:\\n%s\\n\", buf);\n\t\treturn -1;\n\t}\n\n\treturn pid;\n\n}\n\nstatic pid_t get_tgid(char *buf)\n{\n\tpid_t tgid;\n\tchar tgid_str[FIELD_BUFF] = {0};\n\tchar *endptr;\n\n\tsearch_pattern(&tgid_pattern, tgid_str, buf);\n\terrno = 0;\n\ttgid = strtol(tgid_str, &endptr, 10);\n\tif (errno != 0 || endptr == tgid_str || *endptr != '\\0') {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong/invalid tgid in follow buf:\\n%s\\n\", buf);\n\t\treturn -1;\n\t}\n\n\treturn tgid;\n\n}\n\nstatic __u64 get_ts_nsec(char *buf)\n{\n\t__u64 ts_nsec;\n\tchar ts_nsec_str[FIELD_BUFF] = {0};\n\tchar *endptr;\n\n\tsearch_pattern(&ts_nsec_pattern, ts_nsec_str, buf);\n\terrno = 0;\n\tts_nsec = strtoull(ts_nsec_str, &endptr, 10);\n\tif (errno != 0 || endptr == ts_nsec_str || *endptr != '\\0') {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong ts_nsec in follow buf:\\n%s\\n\", buf);\n\t\treturn -1;\n\t}\n\n\treturn ts_nsec;\n}\n\nstatic __u64 get_free_ts_nsec(char *buf)\n{\n\t__u64 free_ts_nsec;\n\tchar free_ts_nsec_str[FIELD_BUFF] = {0};\n\tchar *endptr;\n\n\tsearch_pattern(&free_ts_nsec_pattern, free_ts_nsec_str, buf);\n\terrno = 0;\n\tfree_ts_nsec = strtoull(free_ts_nsec_str, &endptr, 10);\n\tif (errno != 0 || endptr == free_ts_nsec_str || *endptr != '\\0') {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong free_ts_nsec in follow buf:\\n%s\\n\", buf);\n\t\treturn -1;\n\t}\n\n\treturn free_ts_nsec;\n}\n\nstatic char *get_comm(char *buf)\n{\n\tchar *comm_str = malloc(TASK_COMM_LEN);\n\n\tmemset(comm_str, 0, TASK_COMM_LEN);\n\n\tsearch_pattern(&comm_pattern, comm_str, buf);\n\terrno = 0;\n\tif (errno != 0) {\n\t\tif (debug_on)\n\t\t\tfprintf(stderr, \"wrong comm in follow buf:\\n%s\\n\", buf);\n\t\treturn NULL;\n\t}\n\n\treturn comm_str;\n}\n\nstatic int get_arg_type(const char *arg)\n{\n\tif (!strcmp(arg, \"pid\") || !strcmp(arg, \"p\"))\n\t\treturn ARG_PID;\n\telse if (!strcmp(arg, \"tgid\") || !strcmp(arg, \"tg\"))\n\t\treturn ARG_TGID;\n\telse if (!strcmp(arg, \"name\") || !strcmp(arg, \"n\"))\n\t\treturn  ARG_COMM;\n\telse if (!strcmp(arg, \"stacktrace\") || !strcmp(arg, \"st\"))\n\t\treturn ARG_STACKTRACE;\n\telse if (!strcmp(arg, \"free\") || !strcmp(arg, \"f\"))\n\t\treturn ARG_FREE;\n\telse if (!strcmp(arg, \"txt\") || !strcmp(arg, \"T\"))\n\t\treturn ARG_TXT;\n\telse if (!strcmp(arg, \"free_ts\") || !strcmp(arg, \"ft\"))\n\t\treturn ARG_FREE_TS;\n\telse if (!strcmp(arg, \"alloc_ts\") || !strcmp(arg, \"at\"))\n\t\treturn ARG_ALLOC_TS;\n\telse if (!strcmp(arg, \"allocator\") || !strcmp(arg, \"ator\"))\n\t\treturn ARG_ALLOCATOR;\n\telse {\n\t\treturn ARG_UNKNOWN;\n\t}\n}\n\nstatic int get_allocator(const char *buf, const char *migrate_info)\n{\n\tchar *tmp, *first_line, *second_line;\n\tint allocator = 0;\n\n\tif (strstr(migrate_info, \"CMA\"))\n\t\tallocator |= ALLOCATOR_CMA;\n\tif (strstr(migrate_info, \"slab\"))\n\t\tallocator |= ALLOCATOR_SLAB;\n\ttmp = strstr(buf, \"__vmalloc_node_range\");\n\tif (tmp) {\n\t\tsecond_line = tmp;\n\t\twhile (*tmp != '\\n')\n\t\t\ttmp--;\n\t\ttmp--;\n\t\twhile (*tmp != '\\n')\n\t\t\ttmp--;\n\t\tfirst_line = ++tmp;\n\t\ttmp = strstr(tmp, \"alloc_pages\");\n\t\tif (tmp && first_line <= tmp && tmp < second_line)\n\t\t\tallocator |= ALLOCATOR_VMALLOC;\n\t}\n\tif (allocator == 0)\n\t\tallocator = ALLOCATOR_OTHERS;\n\treturn allocator;\n}\n\nstatic bool match_num_list(int num, int *list, int list_size)\n{\n\tfor (int i = 0; i < list_size; ++i)\n\t\tif (list[i] == num)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool match_str_list(const char *str, char **list, int list_size)\n{\n\tfor (int i = 0; i < list_size; ++i)\n\t\tif (!strcmp(list[i], str))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool is_need(char *buf)\n{\n\t__u64 ts_nsec, free_ts_nsec;\n\n\tts_nsec = get_ts_nsec(buf);\n\tfree_ts_nsec = get_free_ts_nsec(buf);\n\n\tif ((filter & FILTER_UNRELEASE) && free_ts_nsec != 0 && ts_nsec < free_ts_nsec)\n\t\treturn false;\n\tif ((filter & FILTER_PID) && !match_num_list(get_pid(buf), fc.pids, fc.pids_size))\n\t\treturn false;\n\tif ((filter & FILTER_TGID) &&\n\t\t!match_num_list(get_tgid(buf), fc.tgids, fc.tgids_size))\n\t\treturn false;\n\n\tchar *comm = get_comm(buf);\n\n\tif ((filter & FILTER_COMM) &&\n\t!match_str_list(comm, fc.comms, fc.comms_size)) {\n\t\tfree(comm);\n\t\treturn false;\n\t}\n\tfree(comm);\n\treturn true;\n}\n\nstatic bool add_list(char *buf, int len, char *ext_buf)\n{\n\tif (list_size != 0 &&\n\t\tlen == list[list_size-1].len &&\n\t\tmemcmp(buf, list[list_size-1].txt, len) == 0) {\n\t\tlist[list_size-1].num++;\n\t\tlist[list_size-1].page_num += get_page_num(buf);\n\t\treturn true;\n\t}\n\tif (list_size == max_size) {\n\t\tfprintf(stderr, \"max_size too small??\\n\");\n\t\treturn false;\n\t}\n\tif (!is_need(buf))\n\t\treturn true;\n\tlist[list_size].pid = get_pid(buf);\n\tlist[list_size].tgid = get_tgid(buf);\n\tlist[list_size].comm = get_comm(buf);\n\tlist[list_size].txt = malloc(len+1);\n\tif (!list[list_size].txt) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\treturn false;\n\t}\n\tmemcpy(list[list_size].txt, buf, len);\n\tlist[list_size].txt[len] = 0;\n\tlist[list_size].len = len;\n\tlist[list_size].num = 1;\n\tlist[list_size].page_num = get_page_num(buf);\n\n\tlist[list_size].stacktrace = strchr(list[list_size].txt, '\\n') ?: \"\";\n\tif (*list[list_size].stacktrace == '\\n')\n\t\tlist[list_size].stacktrace++;\n\tlist[list_size].ts_nsec = get_ts_nsec(buf);\n\tlist[list_size].free_ts_nsec = get_free_ts_nsec(buf);\n\tlist[list_size].allocator = get_allocator(buf, ext_buf);\n\tlist_size++;\n\tif (list_size % 1000 == 0) {\n\t\tprintf(\"loaded %d\\r\", list_size);\n\t\tfflush(stdout);\n\t}\n\treturn true;\n}\n\nstatic bool parse_cull_args(const char *arg_str)\n{\n\tint size = 0;\n\tchar **args = explode(',', arg_str, &size);\n\n\tfor (int i = 0; i < size; ++i) {\n\t\tint arg_type = get_arg_type(args[i]);\n\n\t\tif (arg_type == ARG_PID)\n\t\t\tcull |= CULL_PID;\n\t\telse if (arg_type == ARG_TGID)\n\t\t\tcull |= CULL_TGID;\n\t\telse if (arg_type == ARG_COMM)\n\t\t\tcull |= CULL_COMM;\n\t\telse if (arg_type == ARG_STACKTRACE)\n\t\t\tcull |= CULL_STACKTRACE;\n\t\telse if (arg_type == ARG_FREE)\n\t\t\tcull |= CULL_UNRELEASE;\n\t\telse if (arg_type == ARG_ALLOCATOR)\n\t\t\tcull |= CULL_ALLOCATOR;\n\t\telse {\n\t\t\tfree_explode(args, size);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree_explode(args, size);\n\tif (sc.size == 0)\n\t\tset_single_cmp(compare_num, SORT_DESC);\n\treturn true;\n}\n\nstatic void set_single_cmp(int (*cmp)(const void *, const void *), int sign)\n{\n\tif (sc.signs == NULL || sc.size < 1)\n\t\tsc.signs = calloc(1, sizeof(int));\n\tsc.signs[0] = sign;\n\tif (sc.cmps == NULL || sc.size < 1)\n\t\tsc.cmps = calloc(1, sizeof(int *));\n\tsc.cmps[0] = cmp;\n\tsc.size = 1;\n}\n\nstatic bool parse_sort_args(const char *arg_str)\n{\n\tint size = 0;\n\n\tif (sc.size != 0) {  \n\t\tfree(sc.signs);\n\t\tfree(sc.cmps);\n\t\tsize = 0;\n\t}\n\n\tchar **args = explode(',', arg_str, &size);\n\n\tsc.signs = calloc(size, sizeof(int));\n\tsc.cmps = calloc(size, sizeof(int *));\n\tfor (int i = 0; i < size; ++i) {\n\t\tint offset = 0;\n\n\t\tsc.signs[i] = SORT_ASC;\n\t\tif (args[i][0] == '-' || args[i][0] == '+') {\n\t\t\tif (args[i][0] == '-')\n\t\t\t\tsc.signs[i] = SORT_DESC;\n\t\t\toffset = 1;\n\t\t}\n\n\t\tint arg_type = get_arg_type(args[i]+offset);\n\n\t\tif (arg_type == ARG_PID)\n\t\t\tsc.cmps[i] = compare_pid;\n\t\telse if (arg_type == ARG_TGID)\n\t\t\tsc.cmps[i] = compare_tgid;\n\t\telse if (arg_type == ARG_COMM)\n\t\t\tsc.cmps[i] = compare_comm;\n\t\telse if (arg_type == ARG_STACKTRACE)\n\t\t\tsc.cmps[i] = compare_stacktrace;\n\t\telse if (arg_type == ARG_ALLOC_TS)\n\t\t\tsc.cmps[i] = compare_ts;\n\t\telse if (arg_type == ARG_FREE_TS)\n\t\t\tsc.cmps[i] = compare_free_ts;\n\t\telse if (arg_type == ARG_TXT)\n\t\t\tsc.cmps[i] = compare_txt;\n\t\telse if (arg_type == ARG_ALLOCATOR)\n\t\t\tsc.cmps[i] = compare_allocator;\n\t\telse {\n\t\t\tfree_explode(args, size);\n\t\t\tsc.size = 0;\n\t\t\treturn false;\n\t\t}\n\t}\n\tsc.size = size;\n\tfree_explode(args, size);\n\treturn true;\n}\n\nstatic int *parse_nums_list(char *arg_str, int *list_size)\n{\n\tint size = 0;\n\tchar **args = explode(',', arg_str, &size);\n\tint *list = calloc(size, sizeof(int));\n\n\terrno = 0;\n\tfor (int i = 0; i < size; ++i) {\n\t\tchar *endptr = NULL;\n\n\t\tlist[i] = strtol(args[i], &endptr, 10);\n\t\tif (errno != 0 || endptr == args[i] || *endptr != '\\0') {\n\t\t\tfree(list);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t*list_size = size;\n\tfree_explode(args, size);\n\treturn list;\n}\n\nstatic void print_allocator(FILE *out, int allocator)\n{\n\tfprintf(out, \"allocated by \");\n\tif (allocator & ALLOCATOR_CMA)\n\t\tfprintf(out, \"CMA \");\n\tif (allocator & ALLOCATOR_SLAB)\n\t\tfprintf(out, \"SLAB \");\n\tif (allocator & ALLOCATOR_VMALLOC)\n\t\tfprintf(out, \"VMALLOC \");\n\tif (allocator & ALLOCATOR_OTHERS)\n\t\tfprintf(out, \"OTHERS \");\n}\n\n#define BUF_SIZE\t(128 * 1024)\n\nstatic void usage(void)\n{\n\tprintf(\"Usage: ./page_owner_sort [OPTIONS] <input> <output>\\n\"\n\t\t\"-m\\t\\tSort by total memory.\\n\"\n\t\t\"-s\\t\\tSort by the stack trace.\\n\"\n\t\t\"-t\\t\\tSort by times (default).\\n\"\n\t\t\"-p\\t\\tSort by pid.\\n\"\n\t\t\"-P\\t\\tSort by tgid.\\n\"\n\t\t\"-n\\t\\tSort by task command name.\\n\"\n\t\t\"-a\\t\\tSort by memory allocate time.\\n\"\n\t\t\"-r\\t\\tSort by memory release time.\\n\"\n\t\t\"-f\\t\\tFilter out the information of blocks whose memory has been released.\\n\"\n\t\t\"-d\\t\\tPrint debug information.\\n\"\n\t\t\"--pid <pidlist>\\tSelect by pid. This selects the information of blocks whose process ID numbers appear in <pidlist>.\\n\"\n\t\t\"--tgid <tgidlist>\\tSelect by tgid. This selects the information of blocks whose Thread Group ID numbers appear in <tgidlist>.\\n\"\n\t\t\"--name <cmdlist>\\n\\t\\tSelect by command name. This selects the information of blocks whose command name appears in <cmdlist>.\\n\"\n\t\t\"--cull <rules>\\tCull by user-defined rules.<rules> is a single argument in the form of a comma-separated list with some common fields predefined\\n\"\n\t\t\"--sort <order>\\tSpecify sort order as: [+|-]key[,[+|-]key[,...]]\\n\"\n\t);\n}\n\nint main(int argc, char **argv)\n{\n\tFILE *fin, *fout;\n\tchar *buf, *ext_buf;\n\tint i, count;\n\tstruct stat st;\n\tint opt;\n\tstruct option longopts[] = {\n\t\t{ \"pid\", required_argument, NULL, 1 },\n\t\t{ \"tgid\", required_argument, NULL, 2 },\n\t\t{ \"name\", required_argument, NULL, 3 },\n\t\t{ \"cull\",  required_argument, NULL, 4 },\n\t\t{ \"sort\",  required_argument, NULL, 5 },\n\t\t{ 0, 0, 0, 0},\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"adfmnprstP\", longopts, NULL)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tset_single_cmp(compare_ts, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug_on = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfilter = filter | FILTER_UNRELEASE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tset_single_cmp(compare_page_num, SORT_DESC);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tset_single_cmp(compare_pid, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tset_single_cmp(compare_free_ts, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tset_single_cmp(compare_stacktrace, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_single_cmp(compare_num, SORT_DESC);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tset_single_cmp(compare_tgid, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tset_single_cmp(compare_comm, SORT_ASC);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfilter = filter | FILTER_PID;\n\t\t\tfc.pids = parse_nums_list(optarg, &fc.pids_size);\n\t\t\tif (fc.pids == NULL) {\n\t\t\t\tfprintf(stderr, \"wrong/invalid pid in from the command line:%s\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfilter = filter | FILTER_TGID;\n\t\t\tfc.tgids = parse_nums_list(optarg, &fc.tgids_size);\n\t\t\tif (fc.tgids == NULL) {\n\t\t\t\tfprintf(stderr, \"wrong/invalid tgid in from the command line:%s\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfilter = filter | FILTER_COMM;\n\t\t\tfc.comms = explode(',', optarg, &fc.comms_size);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (!parse_cull_args(optarg)) {\n\t\t\t\tfprintf(stderr, \"wrong argument after --cull option:%s\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (!parse_sort_args(optarg)) {\n\t\t\t\tfprintf(stderr, \"wrong argument after --sort option:%s\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(1);\n\t\t}\n\n\tif (optind >= (argc - 1)) {\n\t\tusage();\n\t\texit(1);\n\t}\n\n\tfin = fopen(argv[optind], \"r\");\n\tfout = fopen(argv[optind + 1], \"w\");\n\tif (!fin || !fout) {\n\t\tusage();\n\t\tperror(\"open: \");\n\t\texit(1);\n\t}\n\n\tif (!check_regcomp(&order_pattern, \"order\\\\s*([0-9]*),\"))\n\t\tgoto out_order;\n\tif (!check_regcomp(&pid_pattern, \"pid\\\\s*([0-9]*),\"))\n\t\tgoto out_pid;\n\tif (!check_regcomp(&tgid_pattern, \"tgid\\\\s*([0-9]*) \"))\n\t\tgoto out_tgid;\n\tif (!check_regcomp(&comm_pattern, \"tgid\\\\s*[0-9]*\\\\s*\\\\((.*)\\\\),\\\\s*ts\"))\n\t\tgoto out_comm;\n\tif (!check_regcomp(&ts_nsec_pattern, \"ts\\\\s*([0-9]*)\\\\s*ns,\"))\n\t\tgoto out_ts;\n\tif (!check_regcomp(&free_ts_nsec_pattern, \"free_ts\\\\s*([0-9]*)\\\\s*ns\"))\n\t\tgoto out_free_ts;\n\n\tfstat(fileno(fin), &st);\n\tmax_size = st.st_size / 100;  \n\n\tlist = malloc(max_size * sizeof(*list));\n\tbuf = malloc(BUF_SIZE);\n\text_buf = malloc(BUF_SIZE);\n\tif (!list || !buf || !ext_buf) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto out_free;\n\t}\n\n\tfor ( ; ; ) {\n\t\tint buf_len = read_block(buf, ext_buf, BUF_SIZE, fin);\n\n\t\tif (buf_len < 0)\n\t\t\tbreak;\n\t\tif (!add_list(buf, buf_len, ext_buf))\n\t\t\tgoto out_free;\n\t}\n\n\tprintf(\"loaded %d\\n\", list_size);\n\n\tprintf(\"sorting ....\\n\");\n\n\tqsort(list, list_size, sizeof(list[0]), compare_cull_condition);\n\n\tprintf(\"culling\\n\");\n\n\tfor (i = count = 0; i < list_size; i++) {\n\t\tif (count == 0 ||\n\t\t    compare_cull_condition((void *)(&list[count-1]), (void *)(&list[i])) != 0) {\n\t\t\tlist[count++] = list[i];\n\t\t} else {\n\t\t\tlist[count-1].num += list[i].num;\n\t\t\tlist[count-1].page_num += list[i].page_num;\n\t\t}\n\t}\n\n\tqsort(list, count, sizeof(list[0]), compare_sort_condition);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (cull == 0) {\n\t\t\tfprintf(fout, \"%d times, %d pages, \", list[i].num, list[i].page_num);\n\t\t\tprint_allocator(fout, list[i].allocator);\n\t\t\tfprintf(fout, \":\\n%s\\n\", list[i].txt);\n\t\t}\n\t\telse {\n\t\t\tfprintf(fout, \"%d times, %d pages\",\n\t\t\t\t\tlist[i].num, list[i].page_num);\n\t\t\tif (cull & CULL_PID || filter & FILTER_PID)\n\t\t\t\tfprintf(fout, \", PID %d\", list[i].pid);\n\t\t\tif (cull & CULL_TGID || filter & FILTER_TGID)\n\t\t\t\tfprintf(fout, \", TGID %d\", list[i].tgid);\n\t\t\tif (cull & CULL_COMM || filter & FILTER_COMM)\n\t\t\t\tfprintf(fout, \", task_comm_name: %s\", list[i].comm);\n\t\t\tif (cull & CULL_ALLOCATOR) {\n\t\t\t\tfprintf(fout, \", \");\n\t\t\t\tprint_allocator(fout, list[i].allocator);\n\t\t\t}\n\t\t\tif (cull & CULL_UNRELEASE)\n\t\t\t\tfprintf(fout, \" (%s)\",\n\t\t\t\t\t\tlist[i].free_ts_nsec ? \"UNRELEASED\" : \"RELEASED\");\n\t\t\tif (cull & CULL_STACKTRACE)\n\t\t\t\tfprintf(fout, \":\\n%s\", list[i].stacktrace);\n\t\t\tfprintf(fout, \"\\n\");\n\t\t}\n\t}\n\nout_free:\n\tif (ext_buf)\n\t\tfree(ext_buf);\n\tif (buf)\n\t\tfree(buf);\n\tif (list)\n\t\tfree(list);\nout_free_ts:\n\tregfree(&free_ts_nsec_pattern);\nout_ts:\n\tregfree(&ts_nsec_pattern);\nout_comm:\n\tregfree(&comm_pattern);\nout_tgid:\n\tregfree(&tgid_pattern);\nout_pid:\n\tregfree(&pid_pattern);\nout_order:\n\tregfree(&order_pattern);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}