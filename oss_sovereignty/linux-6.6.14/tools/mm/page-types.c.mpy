{
  "module_name": "page-types.c",
  "hash_id": "fd9edc7b6778857d282706e98a97da29b7fa319ea55366fa8a5d7c1564fb9030",
  "original_prompt": "Ingested from linux-6.6.14/tools/mm/page-types.c",
  "human_readable_source": "\n \n\n#define _FILE_OFFSET_BITS 64\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <string.h>\n#include <getopt.h>\n#include <limits.h>\n#include <assert.h>\n#include <ftw.h>\n#include <time.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/fcntl.h>\n#include <sys/mount.h>\n#include <sys/statfs.h>\n#include <sys/mman.h>\n#include \"../../include/uapi/linux/magic.h\"\n#include \"../../include/uapi/linux/kernel-page-flags.h\"\n#include <api/fs/fs.h>\n\n#ifndef MAX_PATH\n# define MAX_PATH 256\n#endif\n\n#ifndef STR\n# define _STR(x) #x\n# define STR(x) _STR(x)\n#endif\n\n \n\n#define PM_ENTRY_BYTES\t\t8\n#define PM_PFRAME_BITS\t\t55\n#define PM_PFRAME_MASK\t\t((1LL << PM_PFRAME_BITS) - 1)\n#define PM_PFRAME(x)\t\t((x) & PM_PFRAME_MASK)\n#define MAX_SWAPFILES_SHIFT\t5\n#define PM_SWAP_OFFSET(x)\t(((x) & PM_PFRAME_MASK) >> MAX_SWAPFILES_SHIFT)\n#define PM_SOFT_DIRTY\t\t(1ULL << 55)\n#define PM_MMAP_EXCLUSIVE\t(1ULL << 56)\n#define PM_FILE\t\t\t(1ULL << 61)\n#define PM_SWAP\t\t\t(1ULL << 62)\n#define PM_PRESENT\t\t(1ULL << 63)\n\n \n\n#define KPF_BYTES\t\t8\n#define PROC_KPAGEFLAGS\t\t\"/proc/kpageflags\"\n#define PROC_KPAGECOUNT\t\t\"/proc/kpagecount\"\n#define PROC_KPAGECGROUP\t\"/proc/kpagecgroup\"\n\n#define SYS_KERNEL_MM_PAGE_IDLE \"/sys/kernel/mm/page_idle/bitmap\"\n\n \n#define KPF_RESERVED\t\t32\n#define KPF_MLOCKED\t\t33\n#define KPF_MAPPEDTODISK\t34\n#define KPF_PRIVATE\t\t35\n#define KPF_PRIVATE_2\t\t36\n#define KPF_OWNER_PRIVATE\t37\n#define KPF_ARCH\t\t38\n#define KPF_UNCACHED\t\t39\n#define KPF_SOFTDIRTY\t\t40\n#define KPF_ARCH_2\t\t41\n\n \n#define KPF_ANON_EXCLUSIVE\t47\n#define KPF_READAHEAD\t\t48\n#define KPF_SLUB_FROZEN\t\t50\n#define KPF_SLUB_DEBUG\t\t51\n#define KPF_FILE\t\t61\n#define KPF_SWAP\t\t62\n#define KPF_MMAP_EXCLUSIVE\t63\n\n#define KPF_ALL_BITS\t\t((uint64_t)~0ULL)\n#define KPF_HACKERS_BITS\t(0xffffULL << 32)\n#define KPF_OVERLOADED_BITS\t(0xffffULL << 48)\n#define BIT(name)\t\t(1ULL << KPF_##name)\n#define BITS_COMPOUND\t\t(BIT(COMPOUND_HEAD) | BIT(COMPOUND_TAIL))\n\nstatic const char * const page_flag_names[] = {\n\t[KPF_LOCKED]\t\t= \"L:locked\",\n\t[KPF_ERROR]\t\t= \"E:error\",\n\t[KPF_REFERENCED]\t= \"R:referenced\",\n\t[KPF_UPTODATE]\t\t= \"U:uptodate\",\n\t[KPF_DIRTY]\t\t= \"D:dirty\",\n\t[KPF_LRU]\t\t= \"l:lru\",\n\t[KPF_ACTIVE]\t\t= \"A:active\",\n\t[KPF_SLAB]\t\t= \"S:slab\",\n\t[KPF_WRITEBACK]\t\t= \"W:writeback\",\n\t[KPF_RECLAIM]\t\t= \"I:reclaim\",\n\t[KPF_BUDDY]\t\t= \"B:buddy\",\n\n\t[KPF_MMAP]\t\t= \"M:mmap\",\n\t[KPF_ANON]\t\t= \"a:anonymous\",\n\t[KPF_SWAPCACHE]\t\t= \"s:swapcache\",\n\t[KPF_SWAPBACKED]\t= \"b:swapbacked\",\n\t[KPF_COMPOUND_HEAD]\t= \"H:compound_head\",\n\t[KPF_COMPOUND_TAIL]\t= \"T:compound_tail\",\n\t[KPF_HUGE]\t\t= \"G:huge\",\n\t[KPF_UNEVICTABLE]\t= \"u:unevictable\",\n\t[KPF_HWPOISON]\t\t= \"X:hwpoison\",\n\t[KPF_NOPAGE]\t\t= \"n:nopage\",\n\t[KPF_KSM]\t\t= \"x:ksm\",\n\t[KPF_THP]\t\t= \"t:thp\",\n\t[KPF_OFFLINE]\t\t= \"o:offline\",\n\t[KPF_PGTABLE]\t\t= \"g:pgtable\",\n\t[KPF_ZERO_PAGE]\t\t= \"z:zero_page\",\n\t[KPF_IDLE]              = \"i:idle_page\",\n\n\t[KPF_RESERVED]\t\t= \"r:reserved\",\n\t[KPF_MLOCKED]\t\t= \"m:mlocked\",\n\t[KPF_MAPPEDTODISK]\t= \"d:mappedtodisk\",\n\t[KPF_PRIVATE]\t\t= \"P:private\",\n\t[KPF_PRIVATE_2]\t\t= \"p:private_2\",\n\t[KPF_OWNER_PRIVATE]\t= \"O:owner_private\",\n\t[KPF_ARCH]\t\t= \"h:arch\",\n\t[KPF_UNCACHED]\t\t= \"c:uncached\",\n\t[KPF_SOFTDIRTY]\t\t= \"f:softdirty\",\n\t[KPF_ARCH_2]\t\t= \"H:arch_2\",\n\n\t[KPF_ANON_EXCLUSIVE]\t= \"d:anon_exclusive\",\n\t[KPF_READAHEAD]\t\t= \"I:readahead\",\n\t[KPF_SLUB_FROZEN]\t= \"A:slub_frozen\",\n\t[KPF_SLUB_DEBUG]\t= \"E:slub_debug\",\n\n\t[KPF_FILE]\t\t= \"F:file\",\n\t[KPF_SWAP]\t\t= \"w:swap\",\n\t[KPF_MMAP_EXCLUSIVE]\t= \"1:mmap_exclusive\",\n};\n\n\n \n\nstatic int\t\topt_raw;\t \nstatic int\t\topt_list;\t \nstatic int\t\topt_mark_idle;\t \nstatic int\t\topt_no_summary;\t \nstatic pid_t\t\topt_pid;\t \nconst char\t\t*opt_file;\t \nstatic uint64_t\t\topt_cgroup;\t \nstatic int\t\topt_list_cgroup; \nstatic int\t\topt_list_mapcnt; \nstatic const char\t*opt_kpageflags; \n\n#define MAX_ADDR_RANGES\t1024\nstatic int\t\tnr_addr_ranges;\nstatic unsigned long\topt_offset[MAX_ADDR_RANGES];\nstatic unsigned long\topt_size[MAX_ADDR_RANGES];\n\n#define MAX_VMAS\t10240\nstatic int\t\tnr_vmas;\nstatic unsigned long\tpg_start[MAX_VMAS];\nstatic unsigned long\tpg_end[MAX_VMAS];\n\n#define MAX_BIT_FILTERS\t64\nstatic int\t\tnr_bit_filters;\nstatic uint64_t\t\topt_mask[MAX_BIT_FILTERS];\nstatic uint64_t\t\topt_bits[MAX_BIT_FILTERS];\n\nstatic int\t\tpage_size;\n\nstatic int\t\tpagemap_fd;\nstatic int\t\tkpageflags_fd;\nstatic int\t\tkpagecount_fd = -1;\nstatic int\t\tkpagecgroup_fd = -1;\nstatic int\t\tpage_idle_fd = -1;\n\nstatic int\t\topt_hwpoison;\nstatic int\t\topt_unpoison;\n\nstatic const char\t*hwpoison_debug_fs;\nstatic int\t\thwpoison_inject_fd;\nstatic int\t\thwpoison_forget_fd;\n\n#define HASH_SHIFT\t13\n#define HASH_SIZE\t(1 << HASH_SHIFT)\n#define HASH_MASK\t(HASH_SIZE - 1)\n#define HASH_KEY(flags)\t(flags & HASH_MASK)\n\nstatic unsigned long\ttotal_pages;\nstatic unsigned long\tnr_pages[HASH_SIZE];\nstatic uint64_t\t\tpage_flags[HASH_SIZE];\n\n\n \n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n\n#define min_t(type, x, y) ({\t\t\t\\\n\ttype __min1 = (x);\t\t\t\\\n\ttype __min2 = (y);\t\t\t\\\n\t__min1 < __min2 ? __min1 : __min2; })\n\n#define max_t(type, x, y) ({\t\t\t\\\n\ttype __max1 = (x);\t\t\t\\\n\ttype __max2 = (y);\t\t\t\\\n\t__max1 > __max2 ? __max1 : __max2; })\n\nstatic unsigned long pages2mb(unsigned long pages)\n{\n\treturn (pages * page_size) >> 20;\n}\n\nstatic void fatal(const char *x, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, x);\n\tvfprintf(stderr, x, ap);\n\tva_end(ap);\n\texit(EXIT_FAILURE);\n}\n\nstatic int checked_open(const char *pathname, int flags)\n{\n\tint fd = open(pathname, flags);\n\n\tif (fd < 0) {\n\t\tperror(pathname);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn fd;\n}\n\n \n\nstatic unsigned long do_u64_read(int fd, const char *name,\n\t\t\t\t uint64_t *buf,\n\t\t\t\t unsigned long index,\n\t\t\t\t unsigned long count)\n{\n\tlong bytes;\n\n\tif (index > ULONG_MAX / 8)\n\t\tfatal(\"index overflow: %lu\\n\", index);\n\n\tbytes = pread(fd, buf, count * 8, (off_t)index * 8);\n\tif (bytes < 0) {\n\t\tperror(name);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (bytes % 8)\n\t\tfatal(\"partial read: %lu bytes\\n\", bytes);\n\n\treturn bytes / 8;\n}\n\nstatic unsigned long kpageflags_read(uint64_t *buf,\n\t\t\t\t     unsigned long index,\n\t\t\t\t     unsigned long pages)\n{\n\treturn do_u64_read(kpageflags_fd, opt_kpageflags, buf, index, pages);\n}\n\nstatic unsigned long kpagecgroup_read(uint64_t *buf,\n\t\t\t\t      unsigned long index,\n\t\t\t\t      unsigned long pages)\n{\n\tif (kpagecgroup_fd < 0)\n\t\treturn pages;\n\n\treturn do_u64_read(kpagecgroup_fd, opt_kpageflags, buf, index, pages);\n}\n\nstatic unsigned long kpagecount_read(uint64_t *buf,\n\t\t\t\t     unsigned long index,\n\t\t\t\t     unsigned long pages)\n{\n\treturn kpagecount_fd < 0 ? pages :\n\t\tdo_u64_read(kpagecount_fd, PROC_KPAGECOUNT,\n\t\t\t    buf, index, pages);\n}\n\nstatic unsigned long pagemap_read(uint64_t *buf,\n\t\t\t\t  unsigned long index,\n\t\t\t\t  unsigned long pages)\n{\n\treturn do_u64_read(pagemap_fd, \"/proc/pid/pagemap\", buf, index, pages);\n}\n\nstatic unsigned long pagemap_pfn(uint64_t val)\n{\n\tunsigned long pfn;\n\n\tif (val & PM_PRESENT)\n\t\tpfn = PM_PFRAME(val);\n\telse\n\t\tpfn = 0;\n\n\treturn pfn;\n}\n\nstatic unsigned long pagemap_swap_offset(uint64_t val)\n{\n\treturn val & PM_SWAP ? PM_SWAP_OFFSET(val) : 0;\n}\n\n \n\nstatic char *page_flag_name(uint64_t flags)\n{\n\tstatic char buf[65];\n\tint present;\n\tsize_t i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(page_flag_names); i++) {\n\t\tpresent = (flags >> i) & 1;\n\t\tif (!page_flag_names[i]) {\n\t\t\tif (present)\n\t\t\t\tfatal(\"unknown flag bit %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[j++] = present ? page_flag_names[i][0] : '_';\n\t}\n\n\treturn buf;\n}\n\nstatic char *page_flag_longname(uint64_t flags)\n{\n\tstatic char buf[1024];\n\tsize_t i, n;\n\n\tfor (i = 0, n = 0; i < ARRAY_SIZE(page_flag_names); i++) {\n\t\tif (!page_flag_names[i])\n\t\t\tcontinue;\n\t\tif ((flags >> i) & 1)\n\t\t\tn += snprintf(buf + n, sizeof(buf) - n, \"%s,\",\n\t\t\t\t\tpage_flag_names[i] + 2);\n\t}\n\tif (n)\n\t\tn--;\n\tbuf[n] = '\\0';\n\n\treturn buf;\n}\n\n\n \n\nstatic void show_page_range(unsigned long voffset, unsigned long offset,\n\t\t\t    unsigned long size, uint64_t flags,\n\t\t\t    uint64_t cgroup, uint64_t mapcnt)\n{\n\tstatic uint64_t      flags0;\n\tstatic uint64_t\t     cgroup0;\n\tstatic uint64_t      mapcnt0;\n\tstatic unsigned long voff;\n\tstatic unsigned long index;\n\tstatic unsigned long count;\n\n\tif (flags == flags0 && cgroup == cgroup0 && mapcnt == mapcnt0 &&\n\t    offset == index + count && size && voffset == voff + count) {\n\t\tcount += size;\n\t\treturn;\n\t}\n\n\tif (count) {\n\t\tif (opt_pid)\n\t\t\tprintf(\"%lx\\t\", voff);\n\t\tif (opt_file)\n\t\t\tprintf(\"%lx\\t\", voff);\n\t\tif (opt_list_cgroup)\n\t\t\tprintf(\"@%llu\\t\", (unsigned long long)cgroup0);\n\t\tif (opt_list_mapcnt)\n\t\t\tprintf(\"%lu\\t\", mapcnt0);\n\t\tprintf(\"%lx\\t%lx\\t%s\\n\",\n\t\t\t\tindex, count, page_flag_name(flags0));\n\t}\n\n\tflags0 = flags;\n\tcgroup0 = cgroup;\n\tmapcnt0 = mapcnt;\n\tindex  = offset;\n\tvoff   = voffset;\n\tcount  = size;\n}\n\nstatic void flush_page_range(void)\n{\n\tshow_page_range(0, 0, 0, 0, 0, 0);\n}\n\nstatic void show_page(unsigned long voffset, unsigned long offset,\n\t\t      uint64_t flags, uint64_t cgroup, uint64_t mapcnt)\n{\n\tif (opt_pid)\n\t\tprintf(\"%lx\\t\", voffset);\n\tif (opt_file)\n\t\tprintf(\"%lx\\t\", voffset);\n\tif (opt_list_cgroup)\n\t\tprintf(\"@%llu\\t\", (unsigned long long)cgroup);\n\tif (opt_list_mapcnt)\n\t\tprintf(\"%lu\\t\", mapcnt);\n\n\tprintf(\"%lx\\t%s\\n\", offset, page_flag_name(flags));\n}\n\nstatic void show_summary(void)\n{\n\tsize_t i;\n\n\tprintf(\"             flags\\tpage-count       MB\"\n\t\t\"  symbolic-flags\\t\\t\\tlong-symbolic-flags\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(nr_pages); i++) {\n\t\tif (nr_pages[i])\n\t\t\tprintf(\"0x%016llx\\t%10lu %8lu  %s\\t%s\\n\",\n\t\t\t\t(unsigned long long)page_flags[i],\n\t\t\t\tnr_pages[i],\n\t\t\t\tpages2mb(nr_pages[i]),\n\t\t\t\tpage_flag_name(page_flags[i]),\n\t\t\t\tpage_flag_longname(page_flags[i]));\n\t}\n\n\tprintf(\"             total\\t%10lu %8lu\\n\",\n\t\t\ttotal_pages, pages2mb(total_pages));\n}\n\n\n \n\nstatic int bit_mask_ok(uint64_t flags)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_bit_filters; i++) {\n\t\tif (opt_bits[i] == KPF_ALL_BITS) {\n\t\t\tif ((flags & opt_mask[i]) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif ((flags & opt_mask[i]) != opt_bits[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic uint64_t expand_overloaded_flags(uint64_t flags, uint64_t pme)\n{\n\t \n\tif ((flags & BIT(ANON)) && (flags & BIT(MAPPEDTODISK)))\n\t\tflags ^= BIT(MAPPEDTODISK) | BIT(ANON_EXCLUSIVE);\n\n\t \n\tif (flags & BIT(SLAB)) {\n\t\tif (flags & BIT(ACTIVE))\n\t\t\tflags ^= BIT(ACTIVE) | BIT(SLUB_FROZEN);\n\t\tif (flags & BIT(ERROR))\n\t\t\tflags ^= BIT(ERROR) | BIT(SLUB_DEBUG);\n\t}\n\n\t \n\tif ((flags & (BIT(RECLAIM) | BIT(WRITEBACK))) == BIT(RECLAIM))\n\t\tflags ^= BIT(RECLAIM) | BIT(READAHEAD);\n\n\tif (pme & PM_SOFT_DIRTY)\n\t\tflags |= BIT(SOFTDIRTY);\n\tif (pme & PM_FILE)\n\t\tflags |= BIT(FILE);\n\tif (pme & PM_SWAP)\n\t\tflags |= BIT(SWAP);\n\tif (pme & PM_MMAP_EXCLUSIVE)\n\t\tflags |= BIT(MMAP_EXCLUSIVE);\n\n\treturn flags;\n}\n\nstatic uint64_t well_known_flags(uint64_t flags)\n{\n\t \n\tflags &= ~KPF_HACKERS_BITS;\n\n\t \n\tif ((flags & BITS_COMPOUND) && !(flags & BIT(HUGE)))\n\t\tflags &= ~BITS_COMPOUND;\n\n\treturn flags;\n}\n\nstatic uint64_t kpageflags_flags(uint64_t flags, uint64_t pme)\n{\n\tif (opt_raw)\n\t\tflags = expand_overloaded_flags(flags, pme);\n\telse\n\t\tflags = well_known_flags(flags);\n\n\treturn flags;\n}\n\n \n\nstatic void prepare_hwpoison_fd(void)\n{\n\tchar buf[MAX_PATH + 1];\n\n\thwpoison_debug_fs = debugfs__mount();\n\tif (!hwpoison_debug_fs) {\n\t\tperror(\"mount debugfs\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (opt_hwpoison && !hwpoison_inject_fd) {\n\t\tsnprintf(buf, MAX_PATH, \"%s/hwpoison/corrupt-pfn\",\n\t\t\thwpoison_debug_fs);\n\t\thwpoison_inject_fd = checked_open(buf, O_WRONLY);\n\t}\n\n\tif (opt_unpoison && !hwpoison_forget_fd) {\n\t\tsnprintf(buf, MAX_PATH, \"%s/hwpoison/unpoison-pfn\",\n\t\t\thwpoison_debug_fs);\n\t\thwpoison_forget_fd = checked_open(buf, O_WRONLY);\n\t}\n}\n\nstatic int hwpoison_page(unsigned long offset)\n{\n\tchar buf[100];\n\tint len;\n\n\tlen = sprintf(buf, \"0x%lx\\n\", offset);\n\tlen = write(hwpoison_inject_fd, buf, len);\n\tif (len < 0) {\n\t\tperror(\"hwpoison inject\");\n\t\treturn len;\n\t}\n\treturn 0;\n}\n\nstatic int unpoison_page(unsigned long offset)\n{\n\tchar buf[100];\n\tint len;\n\n\tlen = sprintf(buf, \"0x%lx\\n\", offset);\n\tlen = write(hwpoison_forget_fd, buf, len);\n\tif (len < 0) {\n\t\tperror(\"hwpoison forget\");\n\t\treturn len;\n\t}\n\treturn 0;\n}\n\nstatic int mark_page_idle(unsigned long offset)\n{\n\tstatic unsigned long off;\n\tstatic uint64_t buf;\n\tint len;\n\n\tif ((offset / 64 == off / 64) || buf == 0) {\n\t\tbuf |= 1UL << (offset % 64);\n\t\toff = offset;\n\t\treturn 0;\n\t}\n\n\tlen = pwrite(page_idle_fd, &buf, 8, 8 * (off / 64));\n\tif (len < 0) {\n\t\tperror(\"mark page idle\");\n\t\treturn len;\n\t}\n\n\tbuf = 1UL << (offset % 64);\n\toff = offset;\n\n\treturn 0;\n}\n\n \n\nstatic size_t hash_slot(uint64_t flags)\n{\n\tsize_t k = HASH_KEY(flags);\n\tsize_t i;\n\n\t \n\tif (flags == 0)\n\t\treturn 0;\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(page_flags); i++, k++) {\n\t\tif (!k || k >= ARRAY_SIZE(page_flags))\n\t\t\tk = 1;\n\t\tif (page_flags[k] == 0) {\n\t\t\tpage_flags[k] = flags;\n\t\t\treturn k;\n\t\t}\n\t\tif (page_flags[k] == flags)\n\t\t\treturn k;\n\t}\n\n\tfatal(\"hash table full: bump up HASH_SHIFT?\\n\");\n\texit(EXIT_FAILURE);\n}\n\nstatic void add_page(unsigned long voffset, unsigned long offset,\n\t\t     uint64_t flags, uint64_t cgroup, uint64_t mapcnt,\n\t\t     uint64_t pme)\n{\n\tflags = kpageflags_flags(flags, pme);\n\n\tif (!bit_mask_ok(flags))\n\t\treturn;\n\n\tif (opt_cgroup && cgroup != (uint64_t)opt_cgroup)\n\t\treturn;\n\n\tif (opt_hwpoison)\n\t\thwpoison_page(offset);\n\tif (opt_unpoison)\n\t\tunpoison_page(offset);\n\n\tif (opt_mark_idle)\n\t\tmark_page_idle(offset);\n\n\tif (opt_list == 1)\n\t\tshow_page_range(voffset, offset, 1, flags, cgroup, mapcnt);\n\telse if (opt_list == 2)\n\t\tshow_page(voffset, offset, flags, cgroup, mapcnt);\n\n\tnr_pages[hash_slot(flags)]++;\n\ttotal_pages++;\n}\n\n#define KPAGEFLAGS_BATCH\t(64 << 10)\t \nstatic void walk_pfn(unsigned long voffset,\n\t\t     unsigned long index,\n\t\t     unsigned long count,\n\t\t     uint64_t pme)\n{\n\tuint64_t buf[KPAGEFLAGS_BATCH];\n\tuint64_t cgi[KPAGEFLAGS_BATCH];\n\tuint64_t cnt[KPAGEFLAGS_BATCH];\n\tunsigned long batch;\n\tunsigned long pages;\n\tunsigned long i;\n\n\t \n\tif (count == 1)\n\t\tcgi[0] = 0;\n\telse\n\t\tmemset(cgi, 0, sizeof cgi);\n\n\twhile (count) {\n\t\tbatch = min_t(unsigned long, count, KPAGEFLAGS_BATCH);\n\t\tpages = kpageflags_read(buf, index, batch);\n\t\tif (pages == 0)\n\t\t\tbreak;\n\n\t\tif (kpagecgroup_read(cgi, index, pages) != pages)\n\t\t\tfatal(\"kpagecgroup returned fewer pages than expected\");\n\n\t\tif (kpagecount_read(cnt, index, pages) != pages)\n\t\t\tfatal(\"kpagecount returned fewer pages than expected\");\n\n\t\tfor (i = 0; i < pages; i++)\n\t\t\tadd_page(voffset + i, index + i,\n\t\t\t\t buf[i], cgi[i], cnt[i], pme);\n\n\t\tindex += pages;\n\t\tcount -= pages;\n\t}\n}\n\nstatic void walk_swap(unsigned long voffset, uint64_t pme)\n{\n\tuint64_t flags = kpageflags_flags(0, pme);\n\n\tif (!bit_mask_ok(flags))\n\t\treturn;\n\n\tif (opt_cgroup)\n\t\treturn;\n\n\tif (opt_list == 1)\n\t\tshow_page_range(voffset, pagemap_swap_offset(pme),\n\t\t\t\t1, flags, 0, 0);\n\telse if (opt_list == 2)\n\t\tshow_page(voffset, pagemap_swap_offset(pme), flags, 0, 0);\n\n\tnr_pages[hash_slot(flags)]++;\n\ttotal_pages++;\n}\n\n#define PAGEMAP_BATCH\t(64 << 10)\nstatic void walk_vma(unsigned long index, unsigned long count)\n{\n\tuint64_t buf[PAGEMAP_BATCH];\n\tunsigned long batch;\n\tunsigned long pages;\n\tunsigned long pfn;\n\tunsigned long i;\n\n\twhile (count) {\n\t\tbatch = min_t(unsigned long, count, PAGEMAP_BATCH);\n\t\tpages = pagemap_read(buf, index, batch);\n\t\tif (pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < pages; i++) {\n\t\t\tpfn = pagemap_pfn(buf[i]);\n\t\t\tif (pfn)\n\t\t\t\twalk_pfn(index + i, pfn, 1, buf[i]);\n\t\t\tif (buf[i] & PM_SWAP)\n\t\t\t\twalk_swap(index + i, buf[i]);\n\t\t}\n\n\t\tindex += pages;\n\t\tcount -= pages;\n\t}\n}\n\nstatic void walk_task(unsigned long index, unsigned long count)\n{\n\tconst unsigned long end = index + count;\n\tunsigned long start;\n\tint i = 0;\n\n\twhile (index < end) {\n\n\t\twhile (pg_end[i] <= index)\n\t\t\tif (++i >= nr_vmas)\n\t\t\t\treturn;\n\t\tif (pg_start[i] >= end)\n\t\t\treturn;\n\n\t\tstart = max_t(unsigned long, pg_start[i], index);\n\t\tindex = min_t(unsigned long, pg_end[i], end);\n\n\t\tassert(start < index);\n\t\twalk_vma(start, index - start);\n\t}\n}\n\nstatic void add_addr_range(unsigned long offset, unsigned long size)\n{\n\tif (nr_addr_ranges >= MAX_ADDR_RANGES)\n\t\tfatal(\"too many addr ranges\\n\");\n\n\topt_offset[nr_addr_ranges] = offset;\n\topt_size[nr_addr_ranges] = min_t(unsigned long, size, ULONG_MAX-offset);\n\tnr_addr_ranges++;\n}\n\nstatic void walk_addr_ranges(void)\n{\n\tint i;\n\n\tkpageflags_fd = checked_open(opt_kpageflags, O_RDONLY);\n\n\tif (!nr_addr_ranges)\n\t\tadd_addr_range(0, ULONG_MAX);\n\n\tfor (i = 0; i < nr_addr_ranges; i++)\n\t\tif (!opt_pid)\n\t\t\twalk_pfn(opt_offset[i], opt_offset[i], opt_size[i], 0);\n\t\telse\n\t\t\twalk_task(opt_offset[i], opt_size[i]);\n\n\tif (opt_mark_idle)\n\t\tmark_page_idle(0);\n\n\tclose(kpageflags_fd);\n}\n\n\n \n\nstatic const char *page_flag_type(uint64_t flag)\n{\n\tif (flag & KPF_HACKERS_BITS)\n\t\treturn \"(r)\";\n\tif (flag & KPF_OVERLOADED_BITS)\n\t\treturn \"(o)\";\n\treturn \"   \";\n}\n\nstatic void usage(void)\n{\n\tsize_t i, j;\n\n\tprintf(\n\"page-types [options]\\n\"\n\"            -r|--raw                   Raw mode, for kernel developers\\n\"\n\"            -d|--describe flags        Describe flags\\n\"\n\"            -a|--addr    addr-spec     Walk a range of pages\\n\"\n\"            -b|--bits    bits-spec     Walk pages with specified bits\\n\"\n\"            -c|--cgroup  path|@inode   Walk pages within memory cgroup\\n\"\n\"            -p|--pid     pid           Walk process address space\\n\"\n\"            -f|--file    filename      Walk file address space\\n\"\n\"            -i|--mark-idle             Mark pages idle\\n\"\n\"            -l|--list                  Show page details in ranges\\n\"\n\"            -L|--list-each             Show page details one by one\\n\"\n\"            -C|--list-cgroup           Show cgroup inode for pages\\n\"\n\"            -M|--list-mapcnt           Show page map count\\n\"\n\"            -N|--no-summary            Don't show summary info\\n\"\n\"            -X|--hwpoison              hwpoison pages\\n\"\n\"            -x|--unpoison              unpoison pages\\n\"\n\"            -F|--kpageflags filename   kpageflags file to parse\\n\"\n\"            -h|--help                  Show this usage message\\n\"\n\"flags:\\n\"\n\"            0x10                       bitfield format, e.g.\\n\"\n\"            anon                       bit-name, e.g.\\n\"\n\"            0x10,anon                  comma-separated list, e.g.\\n\"\n\"addr-spec:\\n\"\n\"            N                          one page at offset N (unit: pages)\\n\"\n\"            N+M                        pages range from N to N+M-1\\n\"\n\"            N,M                        pages range from N to M-1\\n\"\n\"            N,                         pages range from N to end\\n\"\n\"            ,M                         pages range from 0 to M-1\\n\"\n\"bits-spec:\\n\"\n\"            bit1,bit2                  (flags & (bit1|bit2)) != 0\\n\"\n\"            bit1,bit2=bit1             (flags & (bit1|bit2)) == bit1\\n\"\n\"            bit1,~bit2                 (flags & (bit1|bit2)) == bit1\\n\"\n\"            =bit1,bit2                 flags == (bit1|bit2)\\n\"\n\"bit-names:\\n\"\n\t);\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(page_flag_names); i++) {\n\t\tif (!page_flag_names[i])\n\t\t\tcontinue;\n\t\tprintf(\"%16s%s\", page_flag_names[i] + 2,\n\t\t\t\t page_flag_type(1ULL << i));\n\t\tif (++j > 3) {\n\t\t\tj = 0;\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\tprintf(\"\\n                                   \"\n\t\t\"(r) raw mode bits  (o) overloaded bits\\n\");\n}\n\nstatic unsigned long long parse_number(const char *str)\n{\n\tunsigned long long n;\n\n\tn = strtoll(str, NULL, 0);\n\n\tif (n == 0 && str[0] != '0')\n\t\tfatal(\"invalid name or number: %s\\n\", str);\n\n\treturn n;\n}\n\nstatic void parse_pid(const char *str)\n{\n\tFILE *file;\n\tchar buf[5000];\n\n\topt_pid = parse_number(str);\n\n\tsprintf(buf, \"/proc/%d/pagemap\", opt_pid);\n\tpagemap_fd = checked_open(buf, O_RDONLY);\n\n\tsprintf(buf, \"/proc/%d/maps\", opt_pid);\n\tfile = fopen(buf, \"r\");\n\tif (!file) {\n\t\tperror(buf);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile (fgets(buf, sizeof(buf), file) != NULL) {\n\t\tunsigned long vm_start;\n\t\tunsigned long vm_end;\n\t\tunsigned long long pgoff;\n\t\tint major, minor;\n\t\tchar r, w, x, s;\n\t\tunsigned long ino;\n\t\tint n;\n\n\t\tn = sscanf(buf, \"%lx-%lx %c%c%c%c %llx %x:%x %lu\",\n\t\t\t   &vm_start,\n\t\t\t   &vm_end,\n\t\t\t   &r, &w, &x, &s,\n\t\t\t   &pgoff,\n\t\t\t   &major, &minor,\n\t\t\t   &ino);\n\t\tif (n < 10) {\n\t\t\tfprintf(stderr, \"unexpected line: %s\\n\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tpg_start[nr_vmas] = vm_start / page_size;\n\t\tpg_end[nr_vmas] = vm_end / page_size;\n\t\tif (++nr_vmas >= MAX_VMAS) {\n\t\t\tfprintf(stderr, \"too many VMAs\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(file);\n}\n\nstatic void show_file(const char *name, const struct stat *st)\n{\n\tunsigned long long size = st->st_size;\n\tchar atime[64], mtime[64];\n\tlong now = time(NULL);\n\n\tprintf(\"%s\\tInode: %u\\tSize: %llu (%llu pages)\\n\",\n\t\t\tname, (unsigned)st->st_ino,\n\t\t\tsize, (size + page_size - 1) / page_size);\n\n\tstrftime(atime, sizeof(atime), \"%c\", localtime(&st->st_atime));\n\tstrftime(mtime, sizeof(mtime), \"%c\", localtime(&st->st_mtime));\n\n\tprintf(\"Modify: %s (%ld seconds ago)\\nAccess: %s (%ld seconds ago)\\n\",\n\t\t\tmtime, now - st->st_mtime,\n\t\t\tatime, now - st->st_atime);\n}\n\nstatic sigjmp_buf sigbus_jmp;\n\nstatic void * volatile sigbus_addr;\n\nstatic void sigbus_handler(int sig, siginfo_t *info, void *ucontex)\n{\n\t(void)sig;\n\t(void)ucontex;\n\tsigbus_addr = info ? info->si_addr : NULL;\n\tsiglongjmp(sigbus_jmp, 1);\n}\n\nstatic struct sigaction sigbus_action = {\n\t.sa_sigaction = sigbus_handler,\n\t.sa_flags = SA_SIGINFO,\n};\n\nstatic void walk_file_range(const char *name, int fd,\n\t\t\t    unsigned long off, unsigned long end)\n{\n\tuint8_t vec[PAGEMAP_BATCH];\n\tuint64_t buf[PAGEMAP_BATCH], flags;\n\tuint64_t cgroup = 0;\n\tuint64_t mapcnt = 0;\n\tunsigned long nr_pages, pfn, i;\n\tssize_t len;\n\tvoid *ptr;\n\tint first = 1;\n\n\tfor (; off < end; off += len) {\n\t\tnr_pages = (end - off + page_size - 1) / page_size;\n\t\tif (nr_pages > PAGEMAP_BATCH)\n\t\t\tnr_pages = PAGEMAP_BATCH;\n\t\tlen = nr_pages * page_size;\n\n\t\tptr = mmap(NULL, len, PROT_READ, MAP_SHARED, fd, off);\n\t\tif (ptr == MAP_FAILED)\n\t\t\tfatal(\"mmap failed: %s\", name);\n\n\t\t \n\t\tif (mincore(ptr, len, vec))\n\t\t\tfatal(\"mincore failed: %s\", name);\n\n\t\t \n\t\tif (madvise(ptr, len, MADV_RANDOM))\n\t\t\tfatal(\"madvice failed: %s\", name);\n\n\t\tif (sigsetjmp(sigbus_jmp, 1)) {\n\t\t\tend = off + sigbus_addr ? sigbus_addr - ptr : 0;\n\t\t\tfprintf(stderr, \"got sigbus at offset %lld: %s\\n\",\n\t\t\t\t\t(long long)end, name);\n\t\t\tgoto got_sigbus;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < nr_pages ; i++) {\n\t\t\tif (vec[i] & 1)\n\t\t\t\t(void)*(volatile int *)(ptr + i * page_size);\n\t\t}\ngot_sigbus:\n\n\t\t \n\t\tif (madvise(ptr, len, MADV_SEQUENTIAL))\n\t\t\tfatal(\"madvice failed: %s\", name);\n\n\t\tif (pagemap_read(buf, (unsigned long)ptr / page_size,\n\t\t\t\t\tnr_pages) != nr_pages)\n\t\t\tfatal(\"cannot read pagemap\");\n\n\t\tmunmap(ptr, len);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tpfn = pagemap_pfn(buf[i]);\n\t\t\tif (!pfn)\n\t\t\t\tcontinue;\n\t\t\tif (!kpageflags_read(&flags, pfn, 1))\n\t\t\t\tcontinue;\n\t\t\tif (!kpagecgroup_read(&cgroup, pfn, 1))\n\t\t\t\tfatal(\"kpagecgroup_read failed\");\n\t\t\tif (!kpagecount_read(&mapcnt, pfn, 1))\n\t\t\t\tfatal(\"kpagecount_read failed\");\n\t\t\tif (first && opt_list) {\n\t\t\t\tfirst = 0;\n\t\t\t\tflush_page_range();\n\t\t\t}\n\t\t\tadd_page(off / page_size + i, pfn,\n\t\t\t\t flags, cgroup, mapcnt, buf[i]);\n\t\t}\n\t}\n}\n\nstatic void walk_file(const char *name, const struct stat *st)\n{\n\tint i;\n\tint fd;\n\n\tfd = checked_open(name, O_RDONLY|O_NOATIME|O_NOFOLLOW);\n\n\tif (!nr_addr_ranges)\n\t\tadd_addr_range(0, st->st_size / page_size);\n\n\tfor (i = 0; i < nr_addr_ranges; i++)\n\t\twalk_file_range(name, fd, opt_offset[i] * page_size,\n\t\t\t\t(opt_offset[i] + opt_size[i]) * page_size);\n\n\tclose(fd);\n}\n\nint walk_tree(const char *name, const struct stat *st, int type, struct FTW *f)\n{\n\t(void)f;\n\tswitch (type) {\n\tcase FTW_F:\n\t\tif (S_ISREG(st->st_mode))\n\t\t\twalk_file(name, st);\n\t\tbreak;\n\tcase FTW_DNR:\n\t\tfprintf(stderr, \"cannot read dir: %s\\n\", name);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct stat st;\n\nstatic void walk_page_cache(void)\n{\n\tkpageflags_fd = checked_open(opt_kpageflags, O_RDONLY);\n\tpagemap_fd = checked_open(\"/proc/self/pagemap\", O_RDONLY);\n\tsigaction(SIGBUS, &sigbus_action, NULL);\n\n\tif (stat(opt_file, &st))\n\t\tfatal(\"stat failed: %s\\n\", opt_file);\n\n\tif (S_ISREG(st.st_mode)) {\n\t\twalk_file(opt_file, &st);\n\t} else if (S_ISDIR(st.st_mode)) {\n\t\t \n\t\tif (nftw(opt_file, walk_tree, 64, FTW_MOUNT | FTW_PHYS) < 0)\n\t\t\tfatal(\"nftw failed: %s\\n\", opt_file);\n\t} else\n\t\tfatal(\"unhandled file type: %s\\n\", opt_file);\n\n\tclose(kpageflags_fd);\n\tclose(pagemap_fd);\n\tsignal(SIGBUS, SIG_DFL);\n}\n\nstatic void parse_file(const char *name)\n{\n\topt_file = name;\n}\n\nstatic void parse_cgroup(const char *path)\n{\n\tif (path[0] == '@') {\n\t\topt_cgroup = parse_number(path + 1);\n\t\treturn;\n\t}\n\n\tstruct stat st;\n\n\tif (stat(path, &st))\n\t\tfatal(\"stat failed: %s: %m\\n\", path);\n\n\tif (!S_ISDIR(st.st_mode))\n\t\tfatal(\"cgroup supposed to be a directory: %s\\n\", path);\n\n\topt_cgroup = st.st_ino;\n}\n\nstatic void parse_addr_range(const char *optarg)\n{\n\tunsigned long offset;\n\tunsigned long size;\n\tchar *p;\n\n\tp = strchr(optarg, ',');\n\tif (!p)\n\t\tp = strchr(optarg, '+');\n\n\tif (p == optarg) {\n\t\toffset = 0;\n\t\tsize   = parse_number(p + 1);\n\t} else if (p) {\n\t\toffset = parse_number(optarg);\n\t\tif (p[1] == '\\0')\n\t\t\tsize = ULONG_MAX;\n\t\telse {\n\t\t\tsize = parse_number(p + 1);\n\t\t\tif (*p == ',') {\n\t\t\t\tif (size < offset)\n\t\t\t\t\tfatal(\"invalid range: %lu,%lu\\n\",\n\t\t\t\t\t\t\toffset, size);\n\t\t\t\tsize -= offset;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toffset = parse_number(optarg);\n\t\tsize   = 1;\n\t}\n\n\tadd_addr_range(offset, size);\n}\n\nstatic void add_bits_filter(uint64_t mask, uint64_t bits)\n{\n\tif (nr_bit_filters >= MAX_BIT_FILTERS)\n\t\tfatal(\"too much bit filters\\n\");\n\n\topt_mask[nr_bit_filters] = mask;\n\topt_bits[nr_bit_filters] = bits;\n\tnr_bit_filters++;\n}\n\nstatic uint64_t parse_flag_name(const char *str, int len)\n{\n\tsize_t i;\n\n\tif (!*str || !len)\n\t\treturn 0;\n\n\tif (len <= 8 && !strncmp(str, \"compound\", len))\n\t\treturn BITS_COMPOUND;\n\n\tfor (i = 0; i < ARRAY_SIZE(page_flag_names); i++) {\n\t\tif (!page_flag_names[i])\n\t\t\tcontinue;\n\t\tif (!strncmp(str, page_flag_names[i] + 2, len))\n\t\t\treturn 1ULL << i;\n\t}\n\n\treturn parse_number(str);\n}\n\nstatic uint64_t parse_flag_names(const char *str, int all)\n{\n\tconst char *p    = str;\n\tuint64_t   flags = 0;\n\n\twhile (1) {\n\t\tif (*p == ',' || *p == '=' || *p == '\\0') {\n\t\t\tif ((*str != '~') || (*str == '~' && all && *++str))\n\t\t\t\tflags |= parse_flag_name(str, p - str);\n\t\t\tif (*p != ',')\n\t\t\t\tbreak;\n\t\t\tstr = p + 1;\n\t\t}\n\t\tp++;\n\t}\n\n\treturn flags;\n}\n\nstatic void parse_bits_mask(const char *optarg)\n{\n\tuint64_t mask;\n\tuint64_t bits;\n\tconst char *p;\n\n\tp = strchr(optarg, '=');\n\tif (p == optarg) {\n\t\tmask = KPF_ALL_BITS;\n\t\tbits = parse_flag_names(p + 1, 0);\n\t} else if (p) {\n\t\tmask = parse_flag_names(optarg, 0);\n\t\tbits = parse_flag_names(p + 1, 0);\n\t} else if (strchr(optarg, '~')) {\n\t\tmask = parse_flag_names(optarg, 1);\n\t\tbits = parse_flag_names(optarg, 0);\n\t} else {\n\t\tmask = parse_flag_names(optarg, 0);\n\t\tbits = KPF_ALL_BITS;\n\t}\n\n\tadd_bits_filter(mask, bits);\n}\n\nstatic void parse_kpageflags(const char *name)\n{\n\topt_kpageflags = name;\n}\n\nstatic void describe_flags(const char *optarg)\n{\n\tuint64_t flags = parse_flag_names(optarg, 0);\n\n\tprintf(\"0x%016llx\\t%s\\t%s\\n\",\n\t\t(unsigned long long)flags,\n\t\tpage_flag_name(flags),\n\t\tpage_flag_longname(flags));\n}\n\nstatic const struct option opts[] = {\n\t{ \"raw\"       , 0, NULL, 'r' },\n\t{ \"pid\"       , 1, NULL, 'p' },\n\t{ \"file\"      , 1, NULL, 'f' },\n\t{ \"addr\"      , 1, NULL, 'a' },\n\t{ \"bits\"      , 1, NULL, 'b' },\n\t{ \"cgroup\"    , 1, NULL, 'c' },\n\t{ \"describe\"  , 1, NULL, 'd' },\n\t{ \"mark-idle\" , 0, NULL, 'i' },\n\t{ \"list\"      , 0, NULL, 'l' },\n\t{ \"list-each\" , 0, NULL, 'L' },\n\t{ \"list-cgroup\", 0, NULL, 'C' },\n\t{ \"list-mapcnt\", 0, NULL, 'M' },\n\t{ \"no-summary\", 0, NULL, 'N' },\n\t{ \"hwpoison\"  , 0, NULL, 'X' },\n\t{ \"unpoison\"  , 0, NULL, 'x' },\n\t{ \"kpageflags\", 0, NULL, 'F' },\n\t{ \"help\"      , 0, NULL, 'h' },\n\t{ NULL        , 0, NULL, 0 }\n};\n\nint main(int argc, char *argv[])\n{\n\tint c;\n\n\tpage_size = getpagesize();\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"rp:f:a:b:d:c:CilLMNXxF:h\",\n\t\t\t\topts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\topt_raw = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparse_pid(optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tparse_file(optarg);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tparse_addr_range(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tparse_bits_mask(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tparse_cgroup(optarg);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\topt_list_cgroup = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdescribe_flags(optarg);\n\t\t\texit(0);\n\t\tcase 'i':\n\t\t\topt_mark_idle = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\topt_list = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\topt_list = 2;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\topt_list_mapcnt = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\topt_no_summary = 1;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\topt_hwpoison = 1;\n\t\t\tprepare_hwpoison_fd();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\topt_unpoison = 1;\n\t\t\tprepare_hwpoison_fd();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tparse_kpageflags(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!opt_kpageflags)\n\t\topt_kpageflags = PROC_KPAGEFLAGS;\n\n\tif (opt_cgroup || opt_list_cgroup)\n\t\tkpagecgroup_fd = checked_open(PROC_KPAGECGROUP, O_RDONLY);\n\n\tif (opt_list && opt_list_mapcnt)\n\t\tkpagecount_fd = checked_open(PROC_KPAGECOUNT, O_RDONLY);\n\n\tif (opt_mark_idle)\n\t\tpage_idle_fd = checked_open(SYS_KERNEL_MM_PAGE_IDLE, O_RDWR);\n\n\tif (opt_list && opt_pid)\n\t\tprintf(\"voffset\\t\");\n\tif (opt_list && opt_file)\n\t\tprintf(\"foffset\\t\");\n\tif (opt_list && opt_list_cgroup)\n\t\tprintf(\"cgroup\\t\");\n\tif (opt_list && opt_list_mapcnt)\n\t\tprintf(\"map-cnt\\t\");\n\n\tif (opt_list == 1)\n\t\tprintf(\"offset\\tlen\\tflags\\n\");\n\tif (opt_list == 2)\n\t\tprintf(\"offset\\tflags\\n\");\n\n\tif (opt_file)\n\t\twalk_page_cache();\n\telse\n\t\twalk_addr_ranges();\n\n\tif (opt_list == 1)\n\t\tflush_page_range();\n\n\tif (opt_no_summary)\n\t\treturn 0;\n\n\tif (opt_list)\n\t\tprintf(\"\\n\\n\");\n\n\tif (opt_file) {\n\t\tshow_file(opt_file, &st);\n\t\tprintf(\"\\n\");\n\t}\n\n\tshow_summary();\n\n\tif (opt_list_mapcnt)\n\t\tclose(kpagecount_fd);\n\n\tif (page_idle_fd >= 0)\n\t\tclose(page_idle_fd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}