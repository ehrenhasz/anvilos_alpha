{
  "module_name": "commands.c",
  "hash_id": "a9323792a0cbe4b370fb22e9c1a71c6d5a882c5dd9caa7e7e60f7edc05cc723c",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/thermal/commands.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <thermal.h>\n#include \"thermal_nl.h\"\n\nstatic struct nla_policy thermal_genl_policy[THERMAL_GENL_ATTR_MAX + 1] = {\n\t \n\t[THERMAL_GENL_ATTR_TZ]                  = { .type = NLA_NESTED },\n\t[THERMAL_GENL_ATTR_TZ_ID]               = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_TEMP]             = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_TRIP]             = { .type = NLA_NESTED },\n\t[THERMAL_GENL_ATTR_TZ_TRIP_ID]          = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_TRIP_TEMP]        = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_TRIP_TYPE]        = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_TRIP_HYST]        = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_MODE]             = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_CDEV_WEIGHT]      = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_TZ_NAME]             = { .type = NLA_STRING },\n\n\t \n\t[THERMAL_GENL_ATTR_TZ_GOV]              = { .type = NLA_NESTED },\n\t[THERMAL_GENL_ATTR_TZ_GOV_NAME]         = { .type = NLA_STRING },\n\n\t \n\t[THERMAL_GENL_ATTR_CDEV]                = { .type = NLA_NESTED },\n\t[THERMAL_GENL_ATTR_CDEV_ID]             = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_CDEV_CUR_STATE]      = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_CDEV_MAX_STATE]      = { .type = NLA_U32 },\n\t[THERMAL_GENL_ATTR_CDEV_NAME]           = { .type = NLA_STRING },\n};\n\nstatic int parse_tz_get(struct genl_info *info, struct thermal_zone **tz)\n{\n\tstruct nlattr *attr;\n\tstruct thermal_zone *__tz = NULL;\n\tsize_t size = 0;\n\tint rem;\n\n\tnla_for_each_nested(attr, info->attrs[THERMAL_GENL_ATTR_TZ], rem) {\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_ID) {\n\n\t\t\tsize++;\n\n\t\t\t__tz = realloc(__tz, sizeof(*__tz) * (size + 2));\n\t\t\tif (!__tz)\n\t\t\t\treturn THERMAL_ERROR;\n\n\t\t\t__tz[size - 1].id = nla_get_u32(attr);\n\t\t}\n\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_NAME)\n\t\t\tnla_strlcpy(__tz[size - 1].name, attr,\n\t\t\t\t    THERMAL_NAME_LENGTH);\n\t}\n\n\tif (__tz)\n\t\t__tz[size].id = -1;\n\n\t*tz = __tz;\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int parse_cdev_get(struct genl_info *info, struct thermal_cdev **cdev)\n{\n\tstruct nlattr *attr;\n\tstruct thermal_cdev *__cdev = NULL;\n\tsize_t size = 0;\n\tint rem;\n\n\tnla_for_each_nested(attr, info->attrs[THERMAL_GENL_ATTR_CDEV], rem) {\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_CDEV_ID) {\n\n\t\t\tsize++;\n\n\t\t\t__cdev = realloc(__cdev, sizeof(*__cdev) * (size + 2));\n\t\t\tif (!__cdev)\n\t\t\t\treturn THERMAL_ERROR;\n\n\t\t\t__cdev[size - 1].id = nla_get_u32(attr);\n\t\t}\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_CDEV_NAME) {\n\t\t\tnla_strlcpy(__cdev[size - 1].name, attr,\n\t\t\t\t    THERMAL_NAME_LENGTH);\n\t\t}\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_CDEV_CUR_STATE)\n\t\t\t__cdev[size - 1].cur_state = nla_get_u32(attr);\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_CDEV_MAX_STATE)\n\t\t\t__cdev[size - 1].max_state = nla_get_u32(attr);\n\t}\n\n\tif (__cdev)\n\t\t__cdev[size].id = -1;\n\n\t*cdev = __cdev;\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int parse_tz_get_trip(struct genl_info *info, struct thermal_zone *tz)\n{\n\tstruct nlattr *attr;\n\tstruct thermal_trip *__tt = NULL;\n\tsize_t size = 0;\n\tint rem;\n\n\tnla_for_each_nested(attr, info->attrs[THERMAL_GENL_ATTR_TZ_TRIP], rem) {\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_TRIP_ID) {\n\n\t\t\tsize++;\n\n\t\t\t__tt = realloc(__tt, sizeof(*__tt) * (size + 2));\n\t\t\tif (!__tt)\n\t\t\t\treturn THERMAL_ERROR;\n\n\t\t\t__tt[size - 1].id = nla_get_u32(attr);\n\t\t}\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_TRIP_TYPE)\n\t\t\t__tt[size - 1].type = nla_get_u32(attr);\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_TRIP_TEMP)\n\t\t\t__tt[size - 1].temp = nla_get_u32(attr);\n\n\t\tif (nla_type(attr) == THERMAL_GENL_ATTR_TZ_TRIP_HYST)\n\t\t\t__tt[size - 1].hyst = nla_get_u32(attr);\n\t}\n\n\tif (__tt)\n\t\t__tt[size].id = -1;\n\n\ttz->trip = __tt;\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int parse_tz_get_temp(struct genl_info *info, struct thermal_zone *tz)\n{\n\tint id = -1;\n\n\tif (info->attrs[THERMAL_GENL_ATTR_TZ_ID])\n\t\tid = nla_get_u32(info->attrs[THERMAL_GENL_ATTR_TZ_ID]);\n\n\tif (tz->id != id)\n\t\treturn THERMAL_ERROR;\n\n\tif (info->attrs[THERMAL_GENL_ATTR_TZ_TEMP])\n\t\ttz->temp = nla_get_u32(info->attrs[THERMAL_GENL_ATTR_TZ_TEMP]);\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int parse_tz_get_gov(struct genl_info *info, struct thermal_zone *tz)\n{\n\tint id = -1;\n\n\tif (info->attrs[THERMAL_GENL_ATTR_TZ_ID])\n\t\tid = nla_get_u32(info->attrs[THERMAL_GENL_ATTR_TZ_ID]);\n\n\tif (tz->id != id)\n\t\treturn THERMAL_ERROR;\n\n\tif (info->attrs[THERMAL_GENL_ATTR_TZ_GOV_NAME]) {\n\t\tnla_strlcpy(tz->governor,\n\t\t\t    info->attrs[THERMAL_GENL_ATTR_TZ_GOV_NAME],\n\t\t\t    THERMAL_NAME_LENGTH);\n\t}\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int handle_netlink(struct nl_cache_ops *unused,\n\t\t\t  struct genl_cmd *cmd,\n\t\t\t  struct genl_info *info, void *arg)\n{\n\tint ret;\n\n\tswitch (cmd->c_id) {\n\n\tcase THERMAL_GENL_CMD_TZ_GET_ID:\n\t\tret = parse_tz_get(info, arg);\n\t\tbreak;\n\n\tcase THERMAL_GENL_CMD_CDEV_GET:\n\t\tret = parse_cdev_get(info, arg);\n\t\tbreak;\n\n\tcase THERMAL_GENL_CMD_TZ_GET_TEMP:\n\t\tret = parse_tz_get_temp(info, arg);\n\t\tbreak;\n\n\tcase THERMAL_GENL_CMD_TZ_GET_TRIP:\n\t\tret = parse_tz_get_trip(info, arg);\n\t\tbreak;\n\n\tcase THERMAL_GENL_CMD_TZ_GET_GOV:\n\t\tret = parse_tz_get_gov(info, arg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn THERMAL_ERROR;\n\t}\n\n\treturn ret;\n}\n\nstatic struct genl_cmd thermal_cmds[] = {\n\t{\n\t\t.c_id\t\t= THERMAL_GENL_CMD_TZ_GET_ID,\n\t\t.c_name\t\t= (char *)\"List thermal zones\",\n\t\t.c_msg_parser\t= handle_netlink,\n\t\t.c_maxattr\t= THERMAL_GENL_ATTR_MAX,\n\t\t.c_attr_policy\t= thermal_genl_policy,\n\t},\n\t{\n\t\t.c_id\t\t= THERMAL_GENL_CMD_TZ_GET_GOV,\n\t\t.c_name\t\t= (char *)\"Get governor\",\n\t\t.c_msg_parser\t= handle_netlink,\n\t\t.c_maxattr\t= THERMAL_GENL_ATTR_MAX,\n\t\t.c_attr_policy\t= thermal_genl_policy,\n\t},\n\t{\n\t\t.c_id\t\t= THERMAL_GENL_CMD_TZ_GET_TEMP,\n\t\t.c_name\t\t= (char *)\"Get thermal zone temperature\",\n\t\t.c_msg_parser\t= handle_netlink,\n\t\t.c_maxattr\t= THERMAL_GENL_ATTR_MAX,\n\t\t.c_attr_policy\t= thermal_genl_policy,\n\t},\n\t{\n\t\t.c_id\t\t= THERMAL_GENL_CMD_TZ_GET_TRIP,\n\t\t.c_name\t\t= (char *)\"Get thermal zone trip points\",\n\t\t.c_msg_parser\t= handle_netlink,\n\t\t.c_maxattr\t= THERMAL_GENL_ATTR_MAX,\n\t\t.c_attr_policy\t= thermal_genl_policy,\n\t},\n\t{\n\t\t.c_id\t\t= THERMAL_GENL_CMD_CDEV_GET,\n\t\t.c_name\t\t= (char *)\"Get cooling devices\",\n\t\t.c_msg_parser\t= handle_netlink,\n\t\t.c_maxattr\t= THERMAL_GENL_ATTR_MAX,\n\t\t.c_attr_policy\t= thermal_genl_policy,\n\t},\n};\n\nstatic struct genl_ops thermal_cmd_ops = {\n\t.o_name\t\t= (char *)\"thermal\",\n\t.o_cmds\t\t= thermal_cmds,\n\t.o_ncmds\t= ARRAY_SIZE(thermal_cmds),\n};\n\nstatic thermal_error_t thermal_genl_auto(struct thermal_handler *th, int id, int cmd,\n\t\t\t\t\t int flags, void *arg)\n{\n\tstruct nl_msg *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_alloc();\n\tif (!msg)\n\t\treturn THERMAL_ERROR;\n\n\thdr = genlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, thermal_cmd_ops.o_id,\n\t\t\t  0, flags, cmd, THERMAL_GENL_VERSION);\n\tif (!hdr)\n\t\treturn THERMAL_ERROR;\n\n\tif (id >= 0 && nla_put_u32(msg, THERMAL_GENL_ATTR_TZ_ID, id))\n\t\treturn THERMAL_ERROR;\n\n\tif (nl_send_msg(th->sk_cmd, th->cb_cmd, msg, genl_handle_msg, arg))\n\t\treturn THERMAL_ERROR;\n\n\tnlmsg_free(msg);\n\n\treturn THERMAL_SUCCESS;\n}\n\nthermal_error_t thermal_cmd_get_tz(struct thermal_handler *th, struct thermal_zone **tz)\n{\n\treturn thermal_genl_auto(th, -1, THERMAL_GENL_CMD_TZ_GET_ID,\n\t\t\t\t NLM_F_DUMP | NLM_F_ACK, tz);\n}\n\nthermal_error_t thermal_cmd_get_cdev(struct thermal_handler *th, struct thermal_cdev **tc)\n{\n\treturn thermal_genl_auto(th, -1, THERMAL_GENL_CMD_CDEV_GET,\n\t\t\t\t NLM_F_DUMP | NLM_F_ACK, tc);\n}\n\nthermal_error_t thermal_cmd_get_trip(struct thermal_handler *th, struct thermal_zone *tz)\n{\n\treturn thermal_genl_auto(th, tz->id, THERMAL_GENL_CMD_TZ_GET_TRIP,\n\t\t\t\t 0, tz);\n}\n\nthermal_error_t thermal_cmd_get_governor(struct thermal_handler *th, struct thermal_zone *tz)\n{\n\treturn thermal_genl_auto(th, tz->id, THERMAL_GENL_CMD_TZ_GET_GOV, 0, tz);\n}\n\nthermal_error_t thermal_cmd_get_temp(struct thermal_handler *th, struct thermal_zone *tz)\n{\n\treturn thermal_genl_auto(th, tz->id, THERMAL_GENL_CMD_TZ_GET_TEMP, 0, tz);\n}\n\nthermal_error_t thermal_cmd_exit(struct thermal_handler *th)\n{\n\tif (genl_unregister_family(&thermal_cmd_ops))\n\t\treturn THERMAL_ERROR;\n\n\tnl_thermal_disconnect(th->sk_cmd, th->cb_cmd);\n\n\treturn THERMAL_SUCCESS;\n}\n\nthermal_error_t thermal_cmd_init(struct thermal_handler *th)\n{\n\tint ret;\n\tint family;\n\n\tif (nl_thermal_connect(&th->sk_cmd, &th->cb_cmd))\n\t\treturn THERMAL_ERROR;\n\n\tret = genl_register_family(&thermal_cmd_ops);\n\tif (ret)\n\t\treturn THERMAL_ERROR;\n\n\tret = genl_ops_resolve(th->sk_cmd, &thermal_cmd_ops);\n\tif (ret)\n\t\treturn THERMAL_ERROR;\n\n\tfamily = genl_ctrl_resolve(th->sk_cmd, \"nlctrl\");\n\tif (family != GENL_ID_CTRL)\n\t\treturn THERMAL_ERROR;\n\n\treturn THERMAL_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}