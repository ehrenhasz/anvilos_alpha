{
  "module_name": "thermal_nl.c",
  "hash_id": "8ce6600c80c92720386c9069ff88246f53101b75368c87955766d936b47e7774",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/thermal/thermal_nl.c",
  "human_readable_source": "\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <thermal.h>\n#include \"thermal_nl.h\"\n\nstruct handler_args {\n\tconst char *group;\n\tint id;\n};\n\nstatic __thread int err;\nstatic __thread int done;\n\nstatic int nl_seq_check_handler(struct nl_msg *msg, void *arg)\n{\n\treturn NL_OK;\n}\n\nstatic int nl_error_handler(struct sockaddr_nl *nla, struct nlmsgerr *nl_err,\n\t\t\t    void *arg)\n{\n\tint *ret = arg;\n\n\tif (ret)\n\t\t*ret = nl_err->error;\n\n\treturn NL_STOP;\n}\n\nstatic int nl_finish_handler(struct nl_msg *msg, void *arg)\n{\n\tint *ret = arg;\n\n\tif (ret)\n\t\t*ret = 1;\n\n\treturn NL_OK;\n}\n\nstatic int nl_ack_handler(struct nl_msg *msg, void *arg)\n{\n\tint *ret = arg;\n\n\tif (ret)\n\t\t*ret = 1;\n\n\treturn NL_OK;\n}\n\nint nl_send_msg(struct nl_sock *sock, struct nl_cb *cb, struct nl_msg *msg,\n\t\tint (*rx_handler)(struct nl_msg *, void *), void *data)\n{\n\tif (!rx_handler)\n\t\treturn THERMAL_ERROR;\n\n\terr = nl_send_auto_complete(sock, msg);\n\tif (err < 0)\n\t\treturn err;\n\n\tnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, rx_handler, data);\n\n\terr = done = 0;\n\n\twhile (err == 0 && done == 0)\n\t\tnl_recvmsgs(sock, cb);\n\n\treturn err;\n}\n\nstatic int nl_family_handler(struct nl_msg *msg, void *arg)\n{\n\tstruct handler_args *grp = arg;\n\tstruct nlattr *tb[CTRL_ATTR_MAX + 1];\n\tstruct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));\n\tstruct nlattr *mcgrp;\n\tint rem_mcgrp;\n\n\tnla_parse(tb, CTRL_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\n\t\t  genlmsg_attrlen(gnlh, 0), NULL);\n\n\tif (!tb[CTRL_ATTR_MCAST_GROUPS])\n\t\treturn THERMAL_ERROR;\n\n\tnla_for_each_nested(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], rem_mcgrp) {\n\n\t\tstruct nlattr *tb_mcgrp[CTRL_ATTR_MCAST_GRP_MAX + 1];\n\n\t\tnla_parse(tb_mcgrp, CTRL_ATTR_MCAST_GRP_MAX,\n\t\t\t  nla_data(mcgrp), nla_len(mcgrp), NULL);\n\n\t\tif (!tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME] ||\n\t\t    !tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID])\n\t\t\tcontinue;\n\n\t\tif (strncmp(nla_data(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME]),\n\t\t\t    grp->group,\n\t\t\t    nla_len(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME])))\n\t\t\tcontinue;\n\n\t\tgrp->id = nla_get_u32(tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID]);\n\n\t\tbreak;\n\t}\n\n\treturn THERMAL_SUCCESS;\n}\n\nstatic int nl_get_multicast_id(struct nl_sock *sock, struct nl_cb *cb,\n\t\t\t       const char *family, const char *group)\n{\n\tstruct nl_msg *msg;\n\tint ret = 0, ctrlid;\n\tstruct handler_args grp = {\n\t\t.group = group,\n\t\t.id = -ENOENT,\n\t};\n\n\tmsg = nlmsg_alloc();\n\tif (!msg)\n\t\treturn THERMAL_ERROR;\n\n\tctrlid = genl_ctrl_resolve(sock, \"nlctrl\");\n\n\tgenlmsg_put(msg, 0, 0, ctrlid, 0, 0, CTRL_CMD_GETFAMILY, 0);\n\n\tnla_put_string(msg, CTRL_ATTR_FAMILY_NAME, family);\n\n\tret = nl_send_msg(sock, cb, msg, nl_family_handler, &grp);\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\tret = grp.id;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\nint nl_thermal_connect(struct nl_sock **nl_sock, struct nl_cb **nl_cb)\n{\n\tstruct nl_cb *cb;\n\tstruct nl_sock *sock;\n\n\tcb = nl_cb_alloc(NL_CB_DEFAULT);\n\tif (!cb)\n\t\treturn THERMAL_ERROR;\n\n\tsock = nl_socket_alloc();\n\tif (!sock)\n\t\tgoto out_cb_free;\n\n\tif (genl_connect(sock))\n\t\tgoto out_socket_free;\n\n\tif (nl_cb_err(cb, NL_CB_CUSTOM, nl_error_handler, &err) ||\n\t    nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, nl_finish_handler, &done) ||\n\t    nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, nl_ack_handler, &done) ||\n\t    nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, nl_seq_check_handler, &done))\n\t\treturn THERMAL_ERROR;\n\n\t*nl_sock = sock;\n\t*nl_cb = cb;\n\n\treturn THERMAL_SUCCESS;\n\nout_socket_free:\n\tnl_socket_free(sock);\nout_cb_free:\n\tnl_cb_put(cb);\n\treturn THERMAL_ERROR;\n}\n\nvoid nl_thermal_disconnect(struct nl_sock *nl_sock, struct nl_cb *nl_cb)\n{\n\tnl_close(nl_sock);\n\tnl_socket_free(nl_sock);\n\tnl_cb_put(nl_cb);\n}\n\nint nl_unsubscribe_thermal(struct nl_sock *nl_sock, struct nl_cb *nl_cb,\n\t\t\t   const char *group)\n{\n\tint mcid;\n\n\tmcid = nl_get_multicast_id(nl_sock, nl_cb, THERMAL_GENL_FAMILY_NAME,\n\t\t\t\t   group);\n\tif (mcid < 0)\n\t\treturn THERMAL_ERROR;\n\n\tif (nl_socket_drop_membership(nl_sock, mcid))\n\t\treturn THERMAL_ERROR;\n\n\treturn THERMAL_SUCCESS;\n}\n\nint nl_subscribe_thermal(struct nl_sock *nl_sock, struct nl_cb *nl_cb,\n\t\t\t const char *group)\n{\n\tint mcid;\n\n\tmcid = nl_get_multicast_id(nl_sock, nl_cb, THERMAL_GENL_FAMILY_NAME,\n\t\t\t\t   group);\n\tif (mcid < 0)\n\t\treturn THERMAL_ERROR;\n\n\tif (nl_socket_add_membership(nl_sock, mcid))\n\t\treturn THERMAL_ERROR;\n\n\treturn THERMAL_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}