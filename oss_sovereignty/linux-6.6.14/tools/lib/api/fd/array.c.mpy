{
  "module_name": "array.c",
  "hash_id": "ab2112c785077e30b818b8d0433b3f1e37b0dbd3cd50e8349f2f95879290e86b",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/api/fd/array.c",
  "human_readable_source": "\n \n#include \"array.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nvoid fdarray__init(struct fdarray *fda, int nr_autogrow)\n{\n\tfda->entries\t = NULL;\n\tfda->priv\t = NULL;\n\tfda->nr\t\t = fda->nr_alloc = 0;\n\tfda->nr_autogrow = nr_autogrow;\n}\n\nint fdarray__grow(struct fdarray *fda, int nr)\n{\n\tstruct priv *priv;\n\tint nr_alloc = fda->nr_alloc + nr;\n\tsize_t psize = sizeof(fda->priv[0]) * nr_alloc;\n\tsize_t size  = sizeof(struct pollfd) * nr_alloc;\n\tstruct pollfd *entries = realloc(fda->entries, size);\n\n\tif (entries == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv = realloc(fda->priv, psize);\n\tif (priv == NULL) {\n\t\tfree(entries);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&entries[fda->nr_alloc], 0, sizeof(struct pollfd) * nr);\n\tmemset(&priv[fda->nr_alloc], 0, sizeof(fda->priv[0]) * nr);\n\n\tfda->nr_alloc = nr_alloc;\n\tfda->entries  = entries;\n\tfda->priv     = priv;\n\treturn 0;\n}\n\nstruct fdarray *fdarray__new(int nr_alloc, int nr_autogrow)\n{\n\tstruct fdarray *fda = calloc(1, sizeof(*fda));\n\n\tif (fda != NULL) {\n\t\tif (fdarray__grow(fda, nr_alloc)) {\n\t\t\tfree(fda);\n\t\t\tfda = NULL;\n\t\t} else {\n\t\t\tfda->nr_autogrow = nr_autogrow;\n\t\t}\n\t}\n\n\treturn fda;\n}\n\nvoid fdarray__exit(struct fdarray *fda)\n{\n\tfree(fda->entries);\n\tfree(fda->priv);\n\tfdarray__init(fda, 0);\n}\n\nvoid fdarray__delete(struct fdarray *fda)\n{\n\tfdarray__exit(fda);\n\tfree(fda);\n}\n\nint fdarray__add(struct fdarray *fda, int fd, short revents, enum fdarray_flags flags)\n{\n\tint pos = fda->nr;\n\n\tif (fda->nr == fda->nr_alloc &&\n\t    fdarray__grow(fda, fda->nr_autogrow) < 0)\n\t\treturn -ENOMEM;\n\n\tfda->entries[fda->nr].fd     = fd;\n\tfda->entries[fda->nr].events = revents;\n\tfda->priv[fda->nr].flags = flags;\n\tfda->nr++;\n\treturn pos;\n}\n\nint fdarray__dup_entry_from(struct fdarray *fda, int pos, struct fdarray *from)\n{\n\tstruct pollfd *entry;\n\tint npos;\n\n\tif (pos >= from->nr)\n\t\treturn -EINVAL;\n\n\tentry = &from->entries[pos];\n\n\tnpos = fdarray__add(fda, entry->fd, entry->events, from->priv[pos].flags);\n\tif (npos >= 0)\n\t\tfda->priv[npos] = from->priv[pos];\n\n\treturn npos;\n}\n\nint fdarray__filter(struct fdarray *fda, short revents,\n\t\t    void (*entry_destructor)(struct fdarray *fda, int fd, void *arg),\n\t\t    void *arg)\n{\n\tint fd, nr = 0;\n\n\tif (fda->nr == 0)\n\t\treturn 0;\n\n\tfor (fd = 0; fd < fda->nr; ++fd) {\n\t\tif (!fda->entries[fd].events)\n\t\t\tcontinue;\n\n\t\tif (fda->entries[fd].revents & revents) {\n\t\t\tif (entry_destructor)\n\t\t\t\tentry_destructor(fda, fd, arg);\n\n\t\t\tfda->entries[fd].revents = fda->entries[fd].events = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(fda->priv[fd].flags & fdarray_flag__nonfilterable))\n\t\t\t++nr;\n\t}\n\n\treturn nr;\n}\n\nint fdarray__poll(struct fdarray *fda, int timeout)\n{\n\treturn poll(fda->entries, fda->nr, timeout);\n}\n\nint fdarray__fprintf(struct fdarray *fda, FILE *fp)\n{\n\tint fd, printed = fprintf(fp, \"%d [ \", fda->nr);\n\n\tfor (fd = 0; fd < fda->nr; ++fd)\n\t\tprinted += fprintf(fp, \"%s%d\", fd ? \", \" : \"\", fda->entries[fd].fd);\n\n\treturn printed + fprintf(fp, \" ]\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}