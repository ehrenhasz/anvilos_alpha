{
  "module_name": "io.h",
  "hash_id": "b8fcfdd2b5d72d1e7228593b5b95d9ddcc9abe0d27487a1135ec543f1c6dc943",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/api/io.h",
  "human_readable_source": " \n \n#ifndef __API_IO__\n#define __API_IO__\n\n#include <errno.h>\n#include <poll.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/types.h>\n\nstruct io {\n\t \n\tint fd;\n\t \n\tunsigned int buf_len;\n\t \n\tchar *buf;\n\t \n\tchar *end;\n\t \n\tchar *data;\n\t \n\tint timeout_ms;\n\t \n\tbool eof;\n};\n\nstatic inline void io__init(struct io *io, int fd,\n\t\t\t    char *buf, unsigned int buf_len)\n{\n\tio->fd = fd;\n\tio->buf_len = buf_len;\n\tio->buf = buf;\n\tio->end = buf;\n\tio->data = buf;\n\tio->timeout_ms = 0;\n\tio->eof = false;\n}\n\n \nstatic inline int io__get_char(struct io *io)\n{\n\tchar *ptr = io->data;\n\n\tif (io->eof)\n\t\treturn -1;\n\n\tif (ptr == io->end) {\n\t\tssize_t n;\n\n\t\tif (io->timeout_ms != 0) {\n\t\t\tstruct pollfd pfds[] = {\n\t\t\t\t{\n\t\t\t\t\t.fd = io->fd,\n\t\t\t\t\t.events = POLLIN,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tn = poll(pfds, 1, io->timeout_ms);\n\t\t\tif (n == 0)\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\tif (n > 0 && !(pfds[0].revents & POLLIN)) {\n\t\t\t\terrno = EIO;\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t\tif (n <= 0) {\n\t\t\t\tio->eof = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tn = read(io->fd, io->buf, io->buf_len);\n\n\t\tif (n <= 0) {\n\t\t\tio->eof = true;\n\t\t\treturn -1;\n\t\t}\n\t\tptr = &io->buf[0];\n\t\tio->end = &io->buf[n];\n\t}\n\tio->data = ptr + 1;\n\treturn *ptr;\n}\n\n \nstatic inline int io__get_hex(struct io *io, __u64 *hex)\n{\n\tbool first_read = true;\n\n\t*hex = 0;\n\twhile (true) {\n\t\tint ch = io__get_char(io);\n\n\t\tif (ch < 0)\n\t\t\treturn ch;\n\t\tif (ch >= '0' && ch <= '9')\n\t\t\t*hex = (*hex << 4) | (ch - '0');\n\t\telse if (ch >= 'a' && ch <= 'f')\n\t\t\t*hex = (*hex << 4) | (ch - 'a' + 10);\n\t\telse if (ch >= 'A' && ch <= 'F')\n\t\t\t*hex = (*hex << 4) | (ch - 'A' + 10);\n\t\telse if (first_read)\n\t\t\treturn -2;\n\t\telse\n\t\t\treturn ch;\n\t\tfirst_read = false;\n\t}\n}\n\n \nstatic inline int io__get_dec(struct io *io, __u64 *dec)\n{\n\tbool first_read = true;\n\n\t*dec = 0;\n\twhile (true) {\n\t\tint ch = io__get_char(io);\n\n\t\tif (ch < 0)\n\t\t\treturn ch;\n\t\tif (ch >= '0' && ch <= '9')\n\t\t\t*dec = (*dec * 10) + ch - '0';\n\t\telse if (first_read)\n\t\t\treturn -2;\n\t\telse\n\t\t\treturn ch;\n\t\tfirst_read = false;\n\t}\n}\n\n \nstatic inline ssize_t io__getline(struct io *io, char **line_out, size_t *line_len_out)\n{\n\tchar buf[128];\n\tint buf_pos = 0;\n\tchar *line = NULL, *temp;\n\tsize_t line_len = 0;\n\tint ch = 0;\n\n\t \n\tfree(*line_out);\n\twhile (ch != '\\n') {\n\t\tch = io__get_char(io);\n\n\t\tif (ch < 0)\n\t\t\tbreak;\n\n\t\tif (buf_pos == sizeof(buf)) {\n\t\t\ttemp = realloc(line, line_len + sizeof(buf));\n\t\t\tif (!temp)\n\t\t\t\tgoto err_out;\n\t\t\tline = temp;\n\t\t\tmemcpy(&line[line_len], buf, sizeof(buf));\n\t\t\tline_len += sizeof(buf);\n\t\t\tbuf_pos = 0;\n\t\t}\n\t\tbuf[buf_pos++] = (char)ch;\n\t}\n\ttemp = realloc(line, line_len + buf_pos + 1);\n\tif (!temp)\n\t\tgoto err_out;\n\tline = temp;\n\tmemcpy(&line[line_len], buf, buf_pos);\n\tline[line_len + buf_pos] = '\\0';\n\tline_len += buf_pos;\n\t*line_out = line;\n\t*line_len_out = line_len;\n\treturn line_len;\nerr_out:\n\tfree(line);\n\treturn -ENOMEM;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}