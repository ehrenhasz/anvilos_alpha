{
  "module_name": "fs.c",
  "hash_id": "65b142b66290c03a08d1e151730a4487edfd65e339f074dbf22e73678b6b6b18",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/api/fs/fs.c",
  "human_readable_source": "\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/mount.h>\n\n#include \"fs.h\"\n#include \"debug-internal.h\"\n\n#define _STR(x) #x\n#define STR(x) _STR(x)\n\n#ifndef SYSFS_MAGIC\n#define SYSFS_MAGIC            0x62656572\n#endif\n\n#ifndef PROC_SUPER_MAGIC\n#define PROC_SUPER_MAGIC       0x9fa0\n#endif\n\n#ifndef DEBUGFS_MAGIC\n#define DEBUGFS_MAGIC          0x64626720\n#endif\n\n#ifndef TRACEFS_MAGIC\n#define TRACEFS_MAGIC          0x74726163\n#endif\n\n#ifndef HUGETLBFS_MAGIC\n#define HUGETLBFS_MAGIC        0x958458f6\n#endif\n\n#ifndef BPF_FS_MAGIC\n#define BPF_FS_MAGIC           0xcafe4a11\n#endif\n\nstatic const char * const sysfs__known_mountpoints[] = {\n\t\"/sys\",\n\t0,\n};\n\nstatic const char * const procfs__known_mountpoints[] = {\n\t\"/proc\",\n\t0,\n};\n\n#ifndef DEBUGFS_DEFAULT_PATH\n#define DEBUGFS_DEFAULT_PATH \"/sys/kernel/debug\"\n#endif\n\nstatic const char * const debugfs__known_mountpoints[] = {\n\tDEBUGFS_DEFAULT_PATH,\n\t\"/debug\",\n\t0,\n};\n\n\n#ifndef TRACEFS_DEFAULT_PATH\n#define TRACEFS_DEFAULT_PATH \"/sys/kernel/tracing\"\n#endif\n\nstatic const char * const tracefs__known_mountpoints[] = {\n\tTRACEFS_DEFAULT_PATH,\n\t\"/sys/kernel/debug/tracing\",\n\t\"/tracing\",\n\t\"/trace\",\n\t0,\n};\n\nstatic const char * const hugetlbfs__known_mountpoints[] = {\n\t0,\n};\n\nstatic const char * const bpf_fs__known_mountpoints[] = {\n\t\"/sys/fs/bpf\",\n\t0,\n};\n\nstruct fs {\n\tconst char *\t\t const name;\n\tconst char * const *\t const mounts;\n\tchar\t\t\t*path;\n\tpthread_mutex_t\t\t mount_mutex;\n\tconst long\t\t magic;\n};\n\n#ifndef TRACEFS_MAGIC\n#define TRACEFS_MAGIC 0x74726163\n#endif\n\nstatic void fs__init_once(struct fs *fs);\nstatic const char *fs__mountpoint(const struct fs *fs);\nstatic const char *fs__mount(struct fs *fs);\n\n#define FS(lower_name, fs_name, upper_name)\t\t\\\nstatic struct fs fs__##lower_name = {\t\t\t\\\n\t.name = #fs_name,\t\t\t\t\\\n\t.mounts = lower_name##__known_mountpoints,\t\\\n\t.magic = upper_name##_MAGIC,\t\t\t\\\n\t.mount_mutex = PTHREAD_MUTEX_INITIALIZER,\t\\\n};\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\nstatic void lower_name##_init_once(void)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tstruct fs *fs = &fs__##lower_name;\t\t\\\n\t\t\t\t\t\t\t\\\n\tfs__init_once(fs);\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\nconst char *lower_name##__mountpoint(void)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tstatic pthread_once_t init_once = PTHREAD_ONCE_INIT;\t\\\n\tstruct fs *fs = &fs__##lower_name;\t\t\\\n\t\t\t\t\t\t\t\\\n\tpthread_once(&init_once, lower_name##_init_once);\t\\\n\treturn fs__mountpoint(fs);\t\t\t\\\n}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\nconst char *lower_name##__mount(void)\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\tconst char *mountpoint = lower_name##__mountpoint();\t\\\n\tstruct fs *fs = &fs__##lower_name;\t\t\\\n\t\t\t\t\t\t\t\\\n\tif (mountpoint)\t\t\t\t\t\\\n\t\treturn mountpoint;\t\t\t\\\n\t\t\t\t\t\t\t\\\n\treturn fs__mount(fs);\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\nbool lower_name##__configured(void)\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\treturn lower_name##__mountpoint() != NULL;\t\\\n}\n\nFS(sysfs, sysfs, SYSFS);\nFS(procfs, procfs, PROC_SUPER);\nFS(debugfs, debugfs, DEBUGFS);\nFS(tracefs, tracefs, TRACEFS);\nFS(hugetlbfs, hugetlbfs, HUGETLBFS);\nFS(bpf_fs, bpf, BPF_FS);\n\nstatic bool fs__read_mounts(struct fs *fs)\n{\n\tchar type[100];\n\tFILE *fp;\n\tchar path[PATH_MAX + 1];\n\n\tfp = fopen(\"/proc/mounts\", \"r\");\n\tif (fp == NULL)\n\t\treturn false;\n\n\twhile (fscanf(fp, \"%*s %\" STR(PATH_MAX) \"s %99s %*s %*d %*d\\n\",\n\t\t      path, type) == 2) {\n\n\t\tif (strcmp(type, fs->name) == 0) {\n\t\t\tfs->path = strdup(path);\n\t\t\tfclose(fp);\n\t\t\treturn fs->path != NULL;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn false;\n}\n\nstatic int fs__valid_mount(const char *fs, long magic)\n{\n\tstruct statfs st_fs;\n\n\tif (statfs(fs, &st_fs) < 0)\n\t\treturn -ENOENT;\n\telse if ((long)st_fs.f_type != magic)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic bool fs__check_mounts(struct fs *fs)\n{\n\tconst char * const *ptr;\n\n\tptr = fs->mounts;\n\twhile (*ptr) {\n\t\tif (fs__valid_mount(*ptr, fs->magic) == 0) {\n\t\t\tfs->path = strdup(*ptr);\n\t\t\tif (!fs->path)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn false;\n}\n\nstatic void mem_toupper(char *f, size_t len)\n{\n\twhile (len) {\n\t\t*f = toupper(*f);\n\t\tf++;\n\t\tlen--;\n\t}\n}\n\n \nstatic bool fs__env_override(struct fs *fs)\n{\n\tchar *override_path;\n\tsize_t name_len = strlen(fs->name);\n\t \n\tchar upper_name[name_len + 5 + 1];\n\n\tmemcpy(upper_name, fs->name, name_len);\n\tmem_toupper(upper_name, name_len);\n\tstrcpy(&upper_name[name_len], \"_PATH\");\n\n\toverride_path = getenv(upper_name);\n\tif (!override_path)\n\t\treturn false;\n\n\tfs->path = strdup(override_path);\n\tif (!fs->path)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void fs__init_once(struct fs *fs)\n{\n\tif (!fs__env_override(fs) &&\n\t    !fs__check_mounts(fs) &&\n\t    !fs__read_mounts(fs)) {\n\t\tassert(!fs->path);\n\t} else {\n\t\tassert(fs->path);\n\t}\n}\n\nstatic const char *fs__mountpoint(const struct fs *fs)\n{\n\treturn fs->path;\n}\n\nstatic const char *mount_overload(struct fs *fs)\n{\n\tsize_t name_len = strlen(fs->name);\n\t \n\tchar upper_name[5 + name_len + 12 + 1];\n\n\tsnprintf(upper_name, name_len, \"PERF_%s_ENVIRONMENT\", fs->name);\n\tmem_toupper(upper_name, name_len);\n\n\treturn getenv(upper_name) ?: *fs->mounts;\n}\n\nstatic const char *fs__mount(struct fs *fs)\n{\n\tconst char *mountpoint;\n\n\tpthread_mutex_lock(&fs->mount_mutex);\n\n\t \n\tmountpoint = fs__mountpoint(fs);\n\tif (mountpoint)\n\t\tgoto out;\n\n\tmountpoint = mount_overload(fs);\n\n\tif (mount(NULL, mountpoint, fs->name, 0, NULL) == 0 &&\n\t    fs__valid_mount(mountpoint, fs->magic) == 0) {\n\t\tfs->path = strdup(mountpoint);\n\t\tmountpoint = fs->path;\n\t}\nout:\n\tpthread_mutex_unlock(&fs->mount_mutex);\n\treturn mountpoint;\n}\n\nint filename__read_int(const char *filename, int *value)\n{\n\tchar line[64];\n\tint fd = open(filename, O_RDONLY), err = -1;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (read(fd, line, sizeof(line)) > 0) {\n\t\t*value = atoi(line);\n\t\terr = 0;\n\t}\n\n\tclose(fd);\n\treturn err;\n}\n\nstatic int filename__read_ull_base(const char *filename,\n\t\t\t\t   unsigned long long *value, int base)\n{\n\tchar line[64];\n\tint fd = open(filename, O_RDONLY), err = -1;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (read(fd, line, sizeof(line)) > 0) {\n\t\t*value = strtoull(line, NULL, base);\n\t\tif (*value != ULLONG_MAX)\n\t\t\terr = 0;\n\t}\n\n\tclose(fd);\n\treturn err;\n}\n\n \nint filename__read_xll(const char *filename, unsigned long long *value)\n{\n\treturn filename__read_ull_base(filename, value, 16);\n}\n\n \nint filename__read_ull(const char *filename, unsigned long long *value)\n{\n\treturn filename__read_ull_base(filename, value, 0);\n}\n\n#define STRERR_BUFSIZE  128      \n\nint filename__read_str(const char *filename, char **buf, size_t *sizep)\n{\n\tsize_t size = 0, alloc_size = 0;\n\tvoid *bf = NULL, *nbf;\n\tint fd, n, err = 0;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tdo {\n\t\tif (size == alloc_size) {\n\t\t\talloc_size += BUFSIZ;\n\t\t\tnbf = realloc(bf, alloc_size);\n\t\t\tif (!nbf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbf = nbf;\n\t\t}\n\n\t\tn = read(fd, bf + size, alloc_size - size);\n\t\tif (n < 0) {\n\t\t\tif (size) {\n\t\t\t\tpr_warn(\"read failed %d: %s\\n\", errno,\n\t\t\t\t\tstrerror_r(errno, sbuf, sizeof(sbuf)));\n\t\t\t\terr = 0;\n\t\t\t} else\n\t\t\t\terr = -errno;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tsize += n;\n\t} while (n > 0);\n\n\tif (!err) {\n\t\t*sizep = size;\n\t\t*buf   = bf;\n\t} else\n\t\tfree(bf);\n\n\tclose(fd);\n\treturn err;\n}\n\nint filename__write_int(const char *filename, int value)\n{\n\tint fd = open(filename, O_WRONLY), err = -1;\n\tchar buf[64];\n\n\tif (fd < 0)\n\t\treturn err;\n\n\tsprintf(buf, \"%d\", value);\n\tif (write(fd, buf, sizeof(buf)) == sizeof(buf))\n\t\terr = 0;\n\n\tclose(fd);\n\treturn err;\n}\n\nint procfs__read_str(const char *entry, char **buf, size_t *sizep)\n{\n\tchar path[PATH_MAX];\n\tconst char *procfs = procfs__mountpoint();\n\n\tif (!procfs)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", procfs, entry);\n\n\treturn filename__read_str(path, buf, sizep);\n}\n\nstatic int sysfs__read_ull_base(const char *entry,\n\t\t\t\tunsigned long long *value, int base)\n{\n\tchar path[PATH_MAX];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", sysfs, entry);\n\n\treturn filename__read_ull_base(path, value, base);\n}\n\nint sysfs__read_xll(const char *entry, unsigned long long *value)\n{\n\treturn sysfs__read_ull_base(entry, value, 16);\n}\n\nint sysfs__read_ull(const char *entry, unsigned long long *value)\n{\n\treturn sysfs__read_ull_base(entry, value, 0);\n}\n\nint sysfs__read_int(const char *entry, int *value)\n{\n\tchar path[PATH_MAX];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", sysfs, entry);\n\n\treturn filename__read_int(path, value);\n}\n\nint sysfs__read_str(const char *entry, char **buf, size_t *sizep)\n{\n\tchar path[PATH_MAX];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", sysfs, entry);\n\n\treturn filename__read_str(path, buf, sizep);\n}\n\nint sysfs__read_bool(const char *entry, bool *value)\n{\n\tchar *buf;\n\tsize_t size;\n\tint ret;\n\n\tret = sysfs__read_str(entry, &buf, &size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (buf[0]) {\n\tcase '1':\n\tcase 'y':\n\tcase 'Y':\n\t\t*value = true;\n\t\tbreak;\n\tcase '0':\n\tcase 'n':\n\tcase 'N':\n\t\t*value = false;\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t}\n\n\tfree(buf);\n\n\treturn ret;\n}\nint sysctl__read_int(const char *sysctl, int *value)\n{\n\tchar path[PATH_MAX];\n\tconst char *procfs = procfs__mountpoint();\n\n\tif (!procfs)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"%s/sys/%s\", procfs, sysctl);\n\n\treturn filename__read_int(path, value);\n}\n\nint sysfs__write_int(const char *entry, int value)\n{\n\tchar path[PATH_MAX];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn -1;\n\n\tif (snprintf(path, sizeof(path), \"%s/%s\", sysfs, entry) >= PATH_MAX)\n\t\treturn -1;\n\n\treturn filename__write_int(path, value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}