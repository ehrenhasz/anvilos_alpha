{
  "module_name": "find_bit.c",
  "hash_id": "b2c555bba98ab6a87c8252a05305d6af22ed5c64f91cf3d747be2d034cbb9f56",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/find_bit.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/kernel.h>\n\n \n#define FIND_FIRST_BIT(FETCH, MUNGE, size)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned long idx, val, sz = (size);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (idx = 0; idx * BITS_PER_LONG < sz; idx++) {\t\t\t\\\n\t\tval = (FETCH);\t\t\t\t\t\t\t\\\n\t\tif (val) {\t\t\t\t\t\t\t\\\n\t\t\tsz = min(idx * BITS_PER_LONG + __ffs(MUNGE(val)), sz);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tsz;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define FIND_NEXT_BIT(FETCH, MUNGE, size, start)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned long mask, idx, tmp, sz = (size), __start = (start);\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__start >= sz))\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tmask = MUNGE(BITMAP_FIRST_WORD_MASK(__start));\t\t\t\t\\\n\tidx = __start / BITS_PER_LONG;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (tmp = (FETCH) & mask; !tmp; tmp = (FETCH)) {\t\t\t\\\n\t\tif ((idx + 1) * BITS_PER_LONG >= sz)\t\t\t\t\\\n\t\t\tgoto out;\t\t\t\t\t\t\\\n\t\tidx++;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tsz = min(idx * BITS_PER_LONG + __ffs(MUNGE(tmp)), sz);\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\t\\\n\tsz;\t\t\t\t\t\t\t\t\t\\\n})\n\n#ifndef find_first_bit\n \nunsigned long _find_first_bit(const unsigned long *addr, unsigned long size)\n{\n\treturn FIND_FIRST_BIT(addr[idx],  , size);\n}\n#endif\n\n#ifndef find_first_and_bit\n \nunsigned long _find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t  const unsigned long *addr2,\n\t\t\t\t  unsigned long size)\n{\n\treturn FIND_FIRST_BIT(addr1[idx] & addr2[idx],  , size);\n}\n#endif\n\n#ifndef find_first_zero_bit\n \nunsigned long _find_first_zero_bit(const unsigned long *addr, unsigned long size)\n{\n\treturn FIND_FIRST_BIT(~addr[idx],  , size);\n}\n#endif\n\n#ifndef find_next_bit\nunsigned long _find_next_bit(const unsigned long *addr, unsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr[idx],  , nbits, start);\n}\n#endif\n\n#ifndef find_next_and_bit\nunsigned long _find_next_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr1[idx] & addr2[idx],  , nbits, start);\n}\n#endif\n\n#ifndef find_next_zero_bit\nunsigned long _find_next_zero_bit(const unsigned long *addr, unsigned long nbits,\n\t\t\t\t\t unsigned long start)\n{\n\treturn FIND_NEXT_BIT(~addr[idx],  , nbits, start);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}