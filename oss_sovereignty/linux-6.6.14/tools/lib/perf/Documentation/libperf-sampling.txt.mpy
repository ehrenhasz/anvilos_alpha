{
  "module_name": "libperf-sampling.txt",
  "hash_id": "5532a5cd8e2c992c9ffcb4a47712da856e734e157cce8ccc32d6f6d8bf4f7529",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/perf/Documentation/libperf-sampling.txt",
  "human_readable_source": "libperf-sampling(7)\n===================\n\nNAME\n----\nlibperf-sampling - sampling interface\n\n\nDESCRIPTION\n-----------\nThe sampling interface provides API to measure and get count for specific perf events.\n\nThe following test tries to explain count on `sampling.c` example.\n\nIt is by no means complete guide to sampling, but shows libperf basic API for sampling.\n\nThe `sampling.c` comes with libperf package and can be compiled and run like:\n\n[source,bash]\n--\n$ gcc -o sampling sampling.c -lperf\n$ sudo ./sampling\ncpu   0, pid      0, tid      0, ip     ffffffffad06c4e6, period                    1\ncpu   0, pid   4465, tid   4469, ip     ffffffffad118748, period             18322959\ncpu   0, pid      0, tid      0, ip     ffffffffad115722, period             33544846\ncpu   0, pid   4465, tid   4470, ip         7f84fe0cdad6, period             23687474\ncpu   0, pid      0, tid      0, ip     ffffffffad9e0349, period             34255790\ncpu   0, pid   4465, tid   4469, ip     ffffffffad136581, period             38664069\ncpu   0, pid      0, tid      0, ip     ffffffffad9e55e2, period             21922384\ncpu   0, pid   4465, tid   4470, ip         7f84fe0ebebf, period             17655175\n...\n--\n\nIt requires root access, because it uses hardware cycles event.\n\nThe `sampling.c` example profiles/samples all CPUs with hardware cycles, in a\nnutshell it:\n\n- creates events\n- adds them to the event list\n- opens and enables events through the event list\n- sleeps for 3 seconds\n- disables events\n- reads and displays recorded samples\n- destroys the event list\n\nThe first thing you need to do before using libperf is to call init function:\n\n[source,c]\n--\n 12 static int libperf_print(enum libperf_print_level level,\n 13                          const char *fmt, va_list ap)\n 14 {\n 15         return vfprintf(stderr, fmt, ap);\n 16 }\n\n 23 int main(int argc, char **argv)\n 24 {\n ...\n 40         libperf_init(libperf_print);\n--\n\nIt will setup the library and sets function for debug output from library.\n\nThe `libperf_print` callback will receive any message with its debug level,\ndefined as:\n\n[source,c]\n--\nenum libperf_print_level {\n        LIBPERF_ERR,\n        LIBPERF_WARN,\n        LIBPERF_INFO,\n        LIBPERF_DEBUG,\n        LIBPERF_DEBUG2,\n        LIBPERF_DEBUG3,\n};\n--\n\nOnce the setup is complete we start by defining cycles event using the `struct perf_event_attr`:\n\n[source,c]\n--\n 29         struct perf_event_attr attr = {\n 30                 .type        = PERF_TYPE_HARDWARE,\n 31                 .config      = PERF_COUNT_HW_CPU_CYCLES,\n 32                 .disabled    = 1,\n 33                 .freq        = 1,\n 34                 .sample_freq = 10,\n 35                 .sample_type = PERF_SAMPLE_IP|PERF_SAMPLE_TID|PERF_SAMPLE_CPU|PERF_SAMPLE_PERIOD,\n 36         };\n--\n\nNext step is to prepare CPUs map.\n\nIn this case we will monitor all the available CPUs:\n\n[source,c]\n--\n 42         cpus = perf_cpu_map__new(NULL);\n 43         if (!cpus) {\n 44                 fprintf(stderr, \"failed to create cpus\\n\");\n 45                 return -1;\n 46         }\n--\n\nNow we create libperf's event list, which will serve as holder for the cycles event:\n\n[source,c]\n--\n 48         evlist = perf_evlist__new();\n 49         if (!evlist) {\n 50                 fprintf(stderr, \"failed to create evlist\\n\");\n 51                 goto out_cpus;\n 52         }\n--\n\nWe create libperf's event for the cycles attribute we defined earlier and add it to the list:\n\n[source,c]\n--\n 54         evsel = perf_evsel__new(&attr);\n 55         if (!evsel) {\n 56                 fprintf(stderr, \"failed to create cycles\\n\");\n 57                 goto out_cpus;\n 58         }\n 59\n 60         perf_evlist__add(evlist, evsel);\n--\n\nConfigure event list with the cpus map and open event:\n\n[source,c]\n--\n 62         perf_evlist__set_maps(evlist, cpus, NULL);\n 63\n 64         err = perf_evlist__open(evlist);\n 65         if (err) {\n 66                 fprintf(stderr, \"failed to open evlist\\n\");\n 67                 goto out_evlist;\n 68         }\n--\n\nOnce the events list is open, we can create memory maps AKA perf ring buffers:\n\n[source,c]\n--\n 70         err = perf_evlist__mmap(evlist, 4);\n 71         if (err) {\n 72                 fprintf(stderr, \"failed to mmap evlist\\n\");\n 73                 goto out_evlist;\n 74         }\n--\n\nThe event is created as disabled (note the `disabled = 1` assignment above),\nso we need to enable the events list explicitly.\n\nFrom this moment the cycles event is sampling.\n\nWe will sleep for 3 seconds while the ring buffers get data from all CPUs, then we disable the events list.\n\n[source,c]\n--\n 76         perf_evlist__enable(evlist);\n 77         sleep(3);\n 78         perf_evlist__disable(evlist);\n--\n\nFollowing code walks through the ring buffers and reads stored events/samples:\n\n[source,c]\n--\n 80         perf_evlist__for_each_mmap(evlist, map, false) {\n 81                 if (perf_mmap__read_init(map) < 0)\n 82                         continue;\n 83\n 84                 while ((event = perf_mmap__read_event(map)) != NULL) {\n\n                            /* process event */\n\n108                         perf_mmap__consume(map);\n109                 }\n110                 perf_mmap__read_done(map);\n111         }\n\n--\n\nEach sample needs to get parsed:\n\n[source,c]\n--\n 85                         int cpu, pid, tid;\n 86                         __u64 ip, period, *array;\n 87                         union u64_swap u;\n 88\n 89                         array = event->sample.array;\n 90\n 91                         ip = *array;\n 92                         array++;\n 93\n 94                         u.val64 = *array;\n 95                         pid = u.val32[0];\n 96                         tid = u.val32[1];\n 97                         array++;\n 98\n 99                         u.val64 = *array;\n100                         cpu = u.val32[0];\n101                         array++;\n102\n103                         period = *array;\n104\n105                         fprintf(stdout, \"cpu %3d, pid %6d, tid %6d, ip %20llx, period %20llu\\n\",\n106                                 cpu, pid, tid, ip, period);\n--\n\nAnd finally cleanup.\n\nWe close the whole events list (both events) and remove it together with the threads map:\n\n[source,c]\n--\n113 out_evlist:\n114         perf_evlist__delete(evlist);\n115 out_cpus:\n116         perf_cpu_map__put(cpus);\n117         return err;\n118 }\n--\n\nREPORTING BUGS\n--------------\nReport bugs to <linux-perf-users@vger.kernel.org>.\n\nLICENSE\n-------\nlibperf is Free Software licensed under the GNU LGPL 2.1\n\nRESOURCES\n---------\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n\nSEE ALSO\n--------\nlibperf(3), libperf-counting(7)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}