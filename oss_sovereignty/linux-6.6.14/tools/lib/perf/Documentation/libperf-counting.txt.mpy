{
  "module_name": "libperf-counting.txt",
  "hash_id": "970d8bdfc3fb6fb18d3977b92ec9266e948e054fd1361fa4ae7e131af7e844fd",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/perf/Documentation/libperf-counting.txt",
  "human_readable_source": "libperf-counting(7)\n===================\n\nNAME\n----\nlibperf-counting - counting interface\n\nDESCRIPTION\n-----------\nThe counting interface provides API to measure and get count for specific perf events.\n\nThe following test tries to explain count on `counting.c` example.\n\nIt is by no means complete guide to counting, but shows libperf basic API for counting.\n\nThe `counting.c` comes with libperf package and can be compiled and run like:\n\n[source,bash]\n--\n$ gcc -o counting counting.c -lperf\n$ sudo ./counting\ncount 176792, enabled 176944, run 176944\ncount 176242, enabled 176242, run 176242\n--\n\nIt requires root access, because of the `PERF_COUNT_SW_CPU_CLOCK` event,\nwhich is available only for root.\n\nThe `counting.c` example monitors two events on the current process and displays\ntheir count, in a nutshell it:\n\n* creates events\n* adds them to the event list\n* opens and enables events through the event list\n* does some workload\n* disables events\n* reads and displays event counts\n* destroys the event list\n\nThe first thing you need to do before using libperf is to call init function:\n\n[source,c]\n--\n  8 static int libperf_print(enum libperf_print_level level,\n  9                          const char *fmt, va_list ap)\n 10 {\n 11         return vfprintf(stderr, fmt, ap);\n 12 }\n\n 14 int main(int argc, char **argv)\n 15 {\n ...\n 35         libperf_init(libperf_print);\n--\n\nIt will setup the library and sets function for debug output from library.\n\nThe `libperf_print` callback will receive any message with its debug level,\ndefined as:\n\n[source,c]\n--\nenum libperf_print_level {\n        LIBPERF_ERR,\n        LIBPERF_WARN,\n        LIBPERF_INFO,\n        LIBPERF_DEBUG,\n        LIBPERF_DEBUG2,\n        LIBPERF_DEBUG3,\n};\n--\n\nOnce the setup is complete we start by defining specific events using the `struct perf_event_attr`.\n\nWe create software events for cpu and task:\n\n[source,c]\n--\n 20         struct perf_event_attr attr1 = {\n 21                 .type        = PERF_TYPE_SOFTWARE,\n 22                 .config      = PERF_COUNT_SW_CPU_CLOCK,\n 23                 .read_format = PERF_FORMAT_TOTAL_TIME_ENABLED|PERF_FORMAT_TOTAL_TIME_RUNNING,\n 24                 .disabled    = 1,\n 25         };\n 26         struct perf_event_attr attr2 = {\n 27                 .type        = PERF_TYPE_SOFTWARE,\n 28                 .config      = PERF_COUNT_SW_TASK_CLOCK,\n 29                 .read_format = PERF_FORMAT_TOTAL_TIME_ENABLED|PERF_FORMAT_TOTAL_TIME_RUNNING,\n 30                 .disabled    = 1,\n 31         };\n--\n\nThe `read_format` setup tells perf to include timing details together with each count.\n\nNext step is to prepare threads map.\n\nIn this case we will monitor current process, so we create threads map with single pid (0):\n\n[source,c]\n--\n 37         threads = perf_thread_map__new_dummy();\n 38         if (!threads) {\n 39                 fprintf(stderr, \"failed to create threads\\n\");\n 40                 return -1;\n 41         }\n 42\n 43         perf_thread_map__set_pid(threads, 0, 0);\n--\n\nNow we create libperf's event list, which will serve as holder for the events we want:\n\n[source,c]\n--\n 45         evlist = perf_evlist__new();\n 46         if (!evlist) {\n 47                 fprintf(stderr, \"failed to create evlist\\n\");\n 48                 goto out_threads;\n 49         }\n--\n\nWe create libperf's events for the attributes we defined earlier and add them to the list:\n\n[source,c]\n--\n 51         evsel = perf_evsel__new(&attr1);\n 52         if (!evsel) {\n 53                 fprintf(stderr, \"failed to create evsel1\\n\");\n 54                 goto out_evlist;\n 55         }\n 56\n 57         perf_evlist__add(evlist, evsel);\n 58\n 59         evsel = perf_evsel__new(&attr2);\n 60         if (!evsel) {\n 61                 fprintf(stderr, \"failed to create evsel2\\n\");\n 62                 goto out_evlist;\n 63         }\n 64\n 65         perf_evlist__add(evlist, evsel);\n--\n\nConfigure event list with the thread map and open events:\n\n[source,c]\n--\n 67         perf_evlist__set_maps(evlist, NULL, threads);\n 68\n 69         err = perf_evlist__open(evlist);\n 70         if (err) {\n 71                 fprintf(stderr, \"failed to open evsel\\n\");\n 72                 goto out_evlist;\n 73         }\n--\n\nBoth events are created as disabled (note the `disabled = 1` assignment above),\nso we need to enable the whole list explicitly (both events).\n\nFrom this moment events are counting and we can do our workload.\n\nWhen we are done we disable the events list.\n\n[source,c]\n--\n 75         perf_evlist__enable(evlist);\n 76\n 77         while (count--);\n 78\n 79         perf_evlist__disable(evlist);\n--\n\nNow we need to get the counts from events, following code iterates through the\nevents list and read counts:\n\n[source,c]\n--\n 81         perf_evlist__for_each_evsel(evlist, evsel) {\n 82                 perf_evsel__read(evsel, 0, 0, &counts);\n 83                 fprintf(stdout, \"count %llu, enabled %llu, run %llu\\n\",\n 84                         counts.val, counts.ena, counts.run);\n 85         }\n--\n\nAnd finally cleanup.\n\nWe close the whole events list (both events) and remove it together with the threads map:\n\n[source,c]\n--\n 87         perf_evlist__close(evlist);\n 88\n 89 out_evlist:\n 90         perf_evlist__delete(evlist);\n 91 out_threads:\n 92         perf_thread_map__put(threads);\n 93         return err;\n 94 }\n--\n\nREPORTING BUGS\n--------------\nReport bugs to <linux-perf-users@vger.kernel.org>.\n\nLICENSE\n-------\nlibperf is Free Software licensed under the GNU LGPL 2.1\n\nRESOURCES\n---------\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n\nSEE ALSO\n--------\nlibperf(3), libperf-sampling(7)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}