{
  "module_name": "usdt.c",
  "hash_id": "e9824d2e1bd5d32f6d53bab3c2aa92d9b93b5ba51588e965f3a07a37b127353f",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/usdt.c",
  "human_readable_source": "\n \n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libelf.h>\n#include <gelf.h>\n#include <unistd.h>\n#include <linux/ptrace.h>\n#include <linux/kernel.h>\n\n \n#if defined(__riscv)\n#define rv_s8 s8\n#endif\n\n#include \"bpf.h\"\n#include \"libbpf.h\"\n#include \"libbpf_common.h\"\n#include \"libbpf_internal.h\"\n#include \"hashmap.h\"\n\n \n\n#define USDT_BASE_SEC \".stapsdt.base\"\n#define USDT_SEMA_SEC \".probes\"\n#define USDT_NOTE_SEC  \".note.stapsdt\"\n#define USDT_NOTE_TYPE 3\n#define USDT_NOTE_NAME \"stapsdt\"\n\n \nenum usdt_arg_type {\n\tUSDT_ARG_CONST,\n\tUSDT_ARG_REG,\n\tUSDT_ARG_REG_DEREF,\n};\n\n \nstruct usdt_arg_spec {\n\t__u64 val_off;\n\tenum usdt_arg_type arg_type;\n\tshort reg_off;\n\tbool arg_signed;\n\tchar arg_bitshift;\n};\n\n \n#define USDT_MAX_ARG_CNT 12\n\n \nstruct usdt_spec {\n\tstruct usdt_arg_spec args[USDT_MAX_ARG_CNT];\n\t__u64 usdt_cookie;\n\tshort arg_cnt;\n};\n\nstruct usdt_note {\n\tconst char *provider;\n\tconst char *name;\n\t \n\tconst char *args;\n\tlong loc_addr;\n\tlong base_addr;\n\tlong sema_addr;\n};\n\nstruct usdt_target {\n\tlong abs_ip;\n\tlong rel_ip;\n\tlong sema_off;\n\tstruct usdt_spec spec;\n\tconst char *spec_str;\n};\n\nstruct usdt_manager {\n\tstruct bpf_map *specs_map;\n\tstruct bpf_map *ip_to_spec_id_map;\n\n\tint *free_spec_ids;\n\tsize_t free_spec_cnt;\n\tsize_t next_free_spec_id;\n\n\tbool has_bpf_cookie;\n\tbool has_sema_refcnt;\n\tbool has_uprobe_multi;\n};\n\nstruct usdt_manager *usdt_manager_new(struct bpf_object *obj)\n{\n\tstatic const char *ref_ctr_sysfs_path = \"/sys/bus/event_source/devices/uprobe/format/ref_ctr_offset\";\n\tstruct usdt_manager *man;\n\tstruct bpf_map *specs_map, *ip_to_spec_id_map;\n\n\tspecs_map = bpf_object__find_map_by_name(obj, \"__bpf_usdt_specs\");\n\tip_to_spec_id_map = bpf_object__find_map_by_name(obj, \"__bpf_usdt_ip_to_spec_id\");\n\tif (!specs_map || !ip_to_spec_id_map) {\n\t\tpr_warn(\"usdt: failed to find USDT support BPF maps, did you forget to include bpf/usdt.bpf.h?\\n\");\n\t\treturn ERR_PTR(-ESRCH);\n\t}\n\n\tman = calloc(1, sizeof(*man));\n\tif (!man)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tman->specs_map = specs_map;\n\tman->ip_to_spec_id_map = ip_to_spec_id_map;\n\n\t \n\tman->has_bpf_cookie = kernel_supports(obj, FEAT_BPF_COOKIE);\n\n\t \n\tman->has_sema_refcnt = faccessat(AT_FDCWD, ref_ctr_sysfs_path, F_OK, AT_EACCESS) == 0;\n\n\t \n\tman->has_uprobe_multi = kernel_supports(obj, FEAT_UPROBE_MULTI_LINK);\n\treturn man;\n}\n\nvoid usdt_manager_free(struct usdt_manager *man)\n{\n\tif (IS_ERR_OR_NULL(man))\n\t\treturn;\n\n\tfree(man->free_spec_ids);\n\tfree(man);\n}\n\nstatic int sanity_check_usdt_elf(Elf *elf, const char *path)\n{\n\tGElf_Ehdr ehdr;\n\tint endianness;\n\n\tif (elf_kind(elf) != ELF_K_ELF) {\n\t\tpr_warn(\"usdt: unrecognized ELF kind %d for '%s'\\n\", elf_kind(elf), path);\n\t\treturn -EBADF;\n\t}\n\n\tswitch (gelf_getclass(elf)) {\n\tcase ELFCLASS64:\n\t\tif (sizeof(void *) != 8) {\n\t\t\tpr_warn(\"usdt: attaching to 64-bit ELF binary '%s' is not supported\\n\", path);\n\t\t\treturn -EBADF;\n\t\t}\n\t\tbreak;\n\tcase ELFCLASS32:\n\t\tif (sizeof(void *) != 4) {\n\t\t\tpr_warn(\"usdt: attaching to 32-bit ELF binary '%s' is not supported\\n\", path);\n\t\t\treturn -EBADF;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"usdt: unsupported ELF class for '%s'\\n\", path);\n\t\treturn -EBADF;\n\t}\n\n\tif (!gelf_getehdr(elf, &ehdr))\n\t\treturn -EINVAL;\n\n\tif (ehdr.e_type != ET_EXEC && ehdr.e_type != ET_DYN) {\n\t\tpr_warn(\"usdt: unsupported type of ELF binary '%s' (%d), only ET_EXEC and ET_DYN are supported\\n\",\n\t\t\tpath, ehdr.e_type);\n\t\treturn -EBADF;\n\t}\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tendianness = ELFDATA2LSB;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tendianness = ELFDATA2MSB;\n#else\n# error \"Unrecognized __BYTE_ORDER__\"\n#endif\n\tif (endianness != ehdr.e_ident[EI_DATA]) {\n\t\tpr_warn(\"usdt: ELF endianness mismatch for '%s'\\n\", path);\n\t\treturn -EBADF;\n\t}\n\n\treturn 0;\n}\n\nstatic int find_elf_sec_by_name(Elf *elf, const char *sec_name, GElf_Shdr *shdr, Elf_Scn **scn)\n{\n\tElf_Scn *sec = NULL;\n\tsize_t shstrndx;\n\n\tif (elf_getshdrstrndx(elf, &shstrndx))\n\t\treturn -EINVAL;\n\n\t \n\tif (!elf_rawdata(elf_getscn(elf, shstrndx), NULL))\n\t\treturn -EINVAL;\n\n\twhile ((sec = elf_nextscn(elf, sec)) != NULL) {\n\t\tchar *name;\n\n\t\tif (!gelf_getshdr(sec, shdr))\n\t\t\treturn -EINVAL;\n\n\t\tname = elf_strptr(elf, shstrndx, shdr->sh_name);\n\t\tif (name && strcmp(sec_name, name) == 0) {\n\t\t\t*scn = sec;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstruct elf_seg {\n\tlong start;\n\tlong end;\n\tlong offset;\n\tbool is_exec;\n};\n\nstatic int cmp_elf_segs(const void *_a, const void *_b)\n{\n\tconst struct elf_seg *a = _a;\n\tconst struct elf_seg *b = _b;\n\n\treturn a->start < b->start ? -1 : 1;\n}\n\nstatic int parse_elf_segs(Elf *elf, const char *path, struct elf_seg **segs, size_t *seg_cnt)\n{\n\tGElf_Phdr phdr;\n\tsize_t n;\n\tint i, err;\n\tstruct elf_seg *seg;\n\tvoid *tmp;\n\n\t*seg_cnt = 0;\n\n\tif (elf_getphdrnum(elf, &n)) {\n\t\terr = -errno;\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!gelf_getphdr(elf, i, &phdr)) {\n\t\t\terr = -errno;\n\t\t\treturn err;\n\t\t}\n\n\t\tpr_debug(\"usdt: discovered PHDR #%d in '%s': vaddr 0x%lx memsz 0x%lx offset 0x%lx type 0x%lx flags 0x%lx\\n\",\n\t\t\t i, path, (long)phdr.p_vaddr, (long)phdr.p_memsz, (long)phdr.p_offset,\n\t\t\t (long)phdr.p_type, (long)phdr.p_flags);\n\t\tif (phdr.p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\ttmp = libbpf_reallocarray(*segs, *seg_cnt + 1, sizeof(**segs));\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t*segs = tmp;\n\t\tseg = *segs + *seg_cnt;\n\t\t(*seg_cnt)++;\n\n\t\tseg->start = phdr.p_vaddr;\n\t\tseg->end = phdr.p_vaddr + phdr.p_memsz;\n\t\tseg->offset = phdr.p_offset;\n\t\tseg->is_exec = phdr.p_flags & PF_X;\n\t}\n\n\tif (*seg_cnt == 0) {\n\t\tpr_warn(\"usdt: failed to find PT_LOAD program headers in '%s'\\n\", path);\n\t\treturn -ESRCH;\n\t}\n\n\tqsort(*segs, *seg_cnt, sizeof(**segs), cmp_elf_segs);\n\treturn 0;\n}\n\nstatic int parse_vma_segs(int pid, const char *lib_path, struct elf_seg **segs, size_t *seg_cnt)\n{\n\tchar path[PATH_MAX], line[PATH_MAX], mode[16];\n\tsize_t seg_start, seg_end, seg_off;\n\tstruct elf_seg *seg;\n\tint tmp_pid, i, err;\n\tFILE *f;\n\n\t*seg_cnt = 0;\n\n\t \n\tif (sscanf(lib_path, \"/proc/%d/root%s\", &tmp_pid, path) == 2 && pid == tmp_pid)\n\t\tgoto proceed;\n\n\tif (!realpath(lib_path, path)) {\n\t\tpr_warn(\"usdt: failed to get absolute path of '%s' (err %d), using path as is...\\n\",\n\t\t\tlib_path, -errno);\n\t\tlibbpf_strlcpy(path, lib_path, sizeof(path));\n\t}\n\nproceed:\n\tsprintf(line, \"/proc/%d/maps\", pid);\n\tf = fopen(line, \"re\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tpr_warn(\"usdt: failed to open '%s' to get base addr of '%s': %d\\n\",\n\t\t\tline, lib_path, err);\n\t\treturn err;\n\t}\n\n\t \n\twhile (fscanf(f, \"%zx-%zx %s %zx %*s %*d%[^\\n]\\n\",\n\t\t      &seg_start, &seg_end, mode, &seg_off, line) == 5) {\n\t\tvoid *tmp;\n\n\t\t \n\t\ti = 0;\n\t\twhile (isblank(line[i]))\n\t\t\ti++;\n\t\tif (strcmp(line + i, path) != 0)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"usdt: discovered segment for lib '%s': addrs %zx-%zx mode %s offset %zx\\n\",\n\t\t\t path, seg_start, seg_end, mode, seg_off);\n\n\t\t \n\t\tif (mode[2] != 'x')\n\t\t\tcontinue;\n\n\t\ttmp = libbpf_reallocarray(*segs, *seg_cnt + 1, sizeof(**segs));\n\t\tif (!tmp) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t*segs = tmp;\n\t\tseg = *segs + *seg_cnt;\n\t\t*seg_cnt += 1;\n\n\t\tseg->start = seg_start;\n\t\tseg->end = seg_end;\n\t\tseg->offset = seg_off;\n\t\tseg->is_exec = true;\n\t}\n\n\tif (*seg_cnt == 0) {\n\t\tpr_warn(\"usdt: failed to find '%s' (resolved to '%s') within PID %d memory mappings\\n\",\n\t\t\tlib_path, path, pid);\n\t\terr = -ESRCH;\n\t\tgoto err_out;\n\t}\n\n\tqsort(*segs, *seg_cnt, sizeof(**segs), cmp_elf_segs);\n\terr = 0;\nerr_out:\n\tfclose(f);\n\treturn err;\n}\n\nstatic struct elf_seg *find_elf_seg(struct elf_seg *segs, size_t seg_cnt, long virtaddr)\n{\n\tstruct elf_seg *seg;\n\tint i;\n\n\t \n\tfor (i = 0, seg = segs; i < seg_cnt; i++, seg++) {\n\t\tif (seg->start <= virtaddr && virtaddr < seg->end)\n\t\t\treturn seg;\n\t}\n\treturn NULL;\n}\n\nstatic struct elf_seg *find_vma_seg(struct elf_seg *segs, size_t seg_cnt, long offset)\n{\n\tstruct elf_seg *seg;\n\tint i;\n\n\t \n\tfor (i = 0, seg = segs; i < seg_cnt; i++, seg++) {\n\t\tif (seg->offset <= offset && offset < seg->offset + (seg->end - seg->start))\n\t\t\treturn seg;\n\t}\n\treturn NULL;\n}\n\nstatic int parse_usdt_note(Elf *elf, const char *path, GElf_Nhdr *nhdr,\n\t\t\t   const char *data, size_t name_off, size_t desc_off,\n\t\t\t   struct usdt_note *usdt_note);\n\nstatic int parse_usdt_spec(struct usdt_spec *spec, const struct usdt_note *note, __u64 usdt_cookie);\n\nstatic int collect_usdt_targets(struct usdt_manager *man, Elf *elf, const char *path, pid_t pid,\n\t\t\t\tconst char *usdt_provider, const char *usdt_name, __u64 usdt_cookie,\n\t\t\t\tstruct usdt_target **out_targets, size_t *out_target_cnt)\n{\n\tsize_t off, name_off, desc_off, seg_cnt = 0, vma_seg_cnt = 0, target_cnt = 0;\n\tstruct elf_seg *segs = NULL, *vma_segs = NULL;\n\tstruct usdt_target *targets = NULL, *target;\n\tlong base_addr = 0;\n\tElf_Scn *notes_scn, *base_scn;\n\tGElf_Shdr base_shdr, notes_shdr;\n\tGElf_Ehdr ehdr;\n\tGElf_Nhdr nhdr;\n\tElf_Data *data;\n\tint err;\n\n\t*out_targets = NULL;\n\t*out_target_cnt = 0;\n\n\terr = find_elf_sec_by_name(elf, USDT_NOTE_SEC, &notes_shdr, &notes_scn);\n\tif (err) {\n\t\tpr_warn(\"usdt: no USDT notes section (%s) found in '%s'\\n\", USDT_NOTE_SEC, path);\n\t\treturn err;\n\t}\n\n\tif (notes_shdr.sh_type != SHT_NOTE || !gelf_getehdr(elf, &ehdr)) {\n\t\tpr_warn(\"usdt: invalid USDT notes section (%s) in '%s'\\n\", USDT_NOTE_SEC, path);\n\t\treturn -EINVAL;\n\t}\n\n\terr = parse_elf_segs(elf, path, &segs, &seg_cnt);\n\tif (err) {\n\t\tpr_warn(\"usdt: failed to process ELF program segments for '%s': %d\\n\", path, err);\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (find_elf_sec_by_name(elf, USDT_BASE_SEC, &base_shdr, &base_scn) == 0)\n\t\tbase_addr = base_shdr.sh_addr;\n\n\tdata = elf_getdata(notes_scn, 0);\n\toff = 0;\n\twhile ((off = gelf_getnote(data, off, &nhdr, &name_off, &desc_off)) > 0) {\n\t\tlong usdt_abs_ip, usdt_rel_ip, usdt_sema_off = 0;\n\t\tstruct usdt_note note;\n\t\tstruct elf_seg *seg = NULL;\n\t\tvoid *tmp;\n\n\t\terr = parse_usdt_note(elf, path, &nhdr, data->d_buf, name_off, desc_off, &note);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tif (strcmp(note.provider, usdt_provider) != 0 || strcmp(note.name, usdt_name) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tusdt_abs_ip = note.loc_addr;\n\t\tif (base_addr)\n\t\t\tusdt_abs_ip += base_addr - note.base_addr;\n\n\t\t \n\t\tseg = find_elf_seg(segs, seg_cnt, usdt_abs_ip);\n\t\tif (!seg) {\n\t\t\terr = -ESRCH;\n\t\t\tpr_warn(\"usdt: failed to find ELF program segment for '%s:%s' in '%s' at IP 0x%lx\\n\",\n\t\t\t\tusdt_provider, usdt_name, path, usdt_abs_ip);\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (!seg->is_exec) {\n\t\t\terr = -ESRCH;\n\t\t\tpr_warn(\"usdt: matched ELF binary '%s' segment [0x%lx, 0x%lx) for '%s:%s' at IP 0x%lx is not executable\\n\",\n\t\t\t\tpath, seg->start, seg->end, usdt_provider, usdt_name,\n\t\t\t\tusdt_abs_ip);\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\tusdt_rel_ip = usdt_abs_ip - seg->start + seg->offset;\n\n\t\tif (ehdr.e_type == ET_DYN && !man->has_bpf_cookie) {\n\t\t\t \n\t\t\tif (pid < 0) {\n\t\t\t\tpr_warn(\"usdt: attaching to shared libraries without specific PID is not supported on current kernel\\n\");\n\t\t\t\terr = -ENOTSUP;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (vma_seg_cnt == 0) {\n\t\t\t\terr = parse_vma_segs(pid, path, &vma_segs, &vma_seg_cnt);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_warn(\"usdt: failed to get memory segments in PID %d for shared library '%s': %d\\n\",\n\t\t\t\t\t\tpid, path, err);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseg = find_vma_seg(vma_segs, vma_seg_cnt, usdt_rel_ip);\n\t\t\tif (!seg) {\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpr_warn(\"usdt: failed to find shared lib memory segment for '%s:%s' in '%s' at relative IP 0x%lx\\n\",\n\t\t\t\t\tusdt_provider, usdt_name, path, usdt_rel_ip);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tusdt_abs_ip = seg->start - seg->offset + usdt_rel_ip;\n\t\t}\n\n\t\tpr_debug(\"usdt: probe for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved abs_ip 0x%lx rel_ip 0x%lx) args '%s' in segment [0x%lx, 0x%lx) at offset 0x%lx\\n\",\n\t\t\t usdt_provider, usdt_name, ehdr.e_type == ET_EXEC ? \"exec\" : \"lib \", path,\n\t\t\t note.loc_addr, note.base_addr, usdt_abs_ip, usdt_rel_ip, note.args,\n\t\t\t seg ? seg->start : 0, seg ? seg->end : 0, seg ? seg->offset : 0);\n\n\t\t \n\t\tif (note.sema_addr) {\n\t\t\tif (!man->has_sema_refcnt) {\n\t\t\t\tpr_warn(\"usdt: kernel doesn't support USDT semaphore refcounting for '%s:%s' in '%s'\\n\",\n\t\t\t\t\tusdt_provider, usdt_name, path);\n\t\t\t\terr = -ENOTSUP;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tseg = find_elf_seg(segs, seg_cnt, note.sema_addr);\n\t\t\tif (!seg) {\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpr_warn(\"usdt: failed to find ELF loadable segment with semaphore of '%s:%s' in '%s' at 0x%lx\\n\",\n\t\t\t\t\tusdt_provider, usdt_name, path, note.sema_addr);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (seg->is_exec) {\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpr_warn(\"usdt: matched ELF binary '%s' segment [0x%lx, 0x%lx] for semaphore of '%s:%s' at 0x%lx is executable\\n\",\n\t\t\t\t\tpath, seg->start, seg->end, usdt_provider, usdt_name,\n\t\t\t\t\tnote.sema_addr);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tusdt_sema_off = note.sema_addr - seg->start + seg->offset;\n\n\t\t\tpr_debug(\"usdt: sema  for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved 0x%lx) in segment [0x%lx, 0x%lx] at offset 0x%lx\\n\",\n\t\t\t\t usdt_provider, usdt_name, ehdr.e_type == ET_EXEC ? \"exec\" : \"lib \",\n\t\t\t\t path, note.sema_addr, note.base_addr, usdt_sema_off,\n\t\t\t\t seg->start, seg->end, seg->offset);\n\t\t}\n\n\t\t \n\t\ttmp = libbpf_reallocarray(targets, target_cnt + 1, sizeof(*targets));\n\t\tif (!tmp) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\ttargets = tmp;\n\n\t\ttarget = &targets[target_cnt];\n\t\tmemset(target, 0, sizeof(*target));\n\n\t\ttarget->abs_ip = usdt_abs_ip;\n\t\ttarget->rel_ip = usdt_rel_ip;\n\t\ttarget->sema_off = usdt_sema_off;\n\n\t\t \n\t\ttarget->spec_str = note.args;\n\n\t\terr = parse_usdt_spec(&target->spec, &note, usdt_cookie);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\ttarget_cnt++;\n\t}\n\n\t*out_targets = targets;\n\t*out_target_cnt = target_cnt;\n\terr = target_cnt;\n\nerr_out:\n\tfree(segs);\n\tfree(vma_segs);\n\tif (err < 0)\n\t\tfree(targets);\n\treturn err;\n}\n\nstruct bpf_link_usdt {\n\tstruct bpf_link link;\n\n\tstruct usdt_manager *usdt_man;\n\n\tsize_t spec_cnt;\n\tint *spec_ids;\n\n\tsize_t uprobe_cnt;\n\tstruct {\n\t\tlong abs_ip;\n\t\tstruct bpf_link *link;\n\t} *uprobes;\n\n\tstruct bpf_link *multi_link;\n};\n\nstatic int bpf_link_usdt_detach(struct bpf_link *link)\n{\n\tstruct bpf_link_usdt *usdt_link = container_of(link, struct bpf_link_usdt, link);\n\tstruct usdt_manager *man = usdt_link->usdt_man;\n\tint i;\n\n\tbpf_link__destroy(usdt_link->multi_link);\n\n\t \n\tfor (i = 0; i < usdt_link->uprobe_cnt; i++) {\n\t\t \n\t\tbpf_link__destroy(usdt_link->uprobes[i].link);\n\t\t \n\t\tif (!man->has_bpf_cookie) {\n\t\t\t \n\t\t\t(void)bpf_map_delete_elem(bpf_map__fd(man->ip_to_spec_id_map),\n\t\t\t\t\t\t  &usdt_link->uprobes[i].abs_ip);\n\t\t}\n\t}\n\n\t \n\tif (!man->free_spec_ids) {\n\t\t \n\t\tman->free_spec_ids = usdt_link->spec_ids;\n\t\tman->free_spec_cnt = usdt_link->spec_cnt;\n\t\tusdt_link->spec_ids = NULL;\n\t} else {\n\t\t \n\t\tsize_t new_cnt = man->free_spec_cnt + usdt_link->spec_cnt;\n\t\tint *new_free_ids;\n\n\t\tnew_free_ids = libbpf_reallocarray(man->free_spec_ids, new_cnt,\n\t\t\t\t\t\t   sizeof(*new_free_ids));\n\t\t \n\t\tif (new_free_ids || new_cnt == 0) {\n\t\t\tmemcpy(new_free_ids + man->free_spec_cnt, usdt_link->spec_ids,\n\t\t\t       usdt_link->spec_cnt * sizeof(*usdt_link->spec_ids));\n\t\t\tman->free_spec_ids = new_free_ids;\n\t\t\tman->free_spec_cnt = new_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void bpf_link_usdt_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_link_usdt *usdt_link = container_of(link, struct bpf_link_usdt, link);\n\n\tfree(usdt_link->spec_ids);\n\tfree(usdt_link->uprobes);\n\tfree(usdt_link);\n}\n\nstatic size_t specs_hash_fn(long key, void *ctx)\n{\n\treturn str_hash((char *)key);\n}\n\nstatic bool specs_equal_fn(long key1, long key2, void *ctx)\n{\n\treturn strcmp((char *)key1, (char *)key2) == 0;\n}\n\nstatic int allocate_spec_id(struct usdt_manager *man, struct hashmap *specs_hash,\n\t\t\t    struct bpf_link_usdt *link, struct usdt_target *target,\n\t\t\t    int *spec_id, bool *is_new)\n{\n\tlong tmp;\n\tvoid *new_ids;\n\tint err;\n\n\t \n\tif (hashmap__find(specs_hash, target->spec_str, &tmp)) {\n\t\t*spec_id = tmp;\n\t\t*is_new = false;\n\t\treturn 0;\n\t}\n\n\t \n\tnew_ids = libbpf_reallocarray(link->spec_ids, link->spec_cnt + 1, sizeof(*link->spec_ids));\n\tif (!new_ids)\n\t\treturn -ENOMEM;\n\tlink->spec_ids = new_ids;\n\n\t \n\tif (man->free_spec_cnt) {\n\t\t*spec_id = man->free_spec_ids[man->free_spec_cnt - 1];\n\n\t\t \n\t\terr = hashmap__add(specs_hash, target->spec_str, *spec_id);\n\t\tif (err)\n\t\t\t return err;\n\n\t\tman->free_spec_cnt--;\n\t} else {\n\t\t \n\t\tif (man->next_free_spec_id >= bpf_map__max_entries(man->specs_map))\n\t\t\treturn -E2BIG;\n\n\t\t*spec_id = man->next_free_spec_id;\n\n\t\t \n\t\terr = hashmap__add(specs_hash, target->spec_str, *spec_id);\n\t\tif (err)\n\t\t\t return err;\n\n\t\tman->next_free_spec_id++;\n\t}\n\n\t \n\tlink->spec_ids[link->spec_cnt] = *spec_id;\n\tlink->spec_cnt++;\n\t*is_new = true;\n\treturn 0;\n}\n\nstruct bpf_link *usdt_manager_attach_usdt(struct usdt_manager *man, const struct bpf_program *prog,\n\t\t\t\t\t  pid_t pid, const char *path,\n\t\t\t\t\t  const char *usdt_provider, const char *usdt_name,\n\t\t\t\t\t  __u64 usdt_cookie)\n{\n\tunsigned long *offsets = NULL, *ref_ctr_offsets = NULL;\n\tint i, err, spec_map_fd, ip_map_fd;\n\tLIBBPF_OPTS(bpf_uprobe_opts, opts);\n\tstruct hashmap *specs_hash = NULL;\n\tstruct bpf_link_usdt *link = NULL;\n\tstruct usdt_target *targets = NULL;\n\t__u64 *cookies = NULL;\n\tstruct elf_fd elf_fd;\n\tsize_t target_cnt;\n\n\tspec_map_fd = bpf_map__fd(man->specs_map);\n\tip_map_fd = bpf_map__fd(man->ip_to_spec_id_map);\n\n\terr = elf_open(path, &elf_fd);\n\tif (err)\n\t\treturn libbpf_err_ptr(err);\n\n\terr = sanity_check_usdt_elf(elf_fd.elf, path);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tif (pid < 0)\n\t\tpid = -1;\n\telse if (pid == 0)\n\t\tpid = getpid();\n\n\t \n\terr = collect_usdt_targets(man, elf_fd.elf, path, pid, usdt_provider, usdt_name,\n\t\t\t\t   usdt_cookie, &targets, &target_cnt);\n\tif (err <= 0) {\n\t\terr = (err == 0) ? -ENOENT : err;\n\t\tgoto err_out;\n\t}\n\n\tspecs_hash = hashmap__new(specs_hash_fn, specs_equal_fn, NULL);\n\tif (IS_ERR(specs_hash)) {\n\t\terr = PTR_ERR(specs_hash);\n\t\tgoto err_out;\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tlink->usdt_man = man;\n\tlink->link.detach = &bpf_link_usdt_detach;\n\tlink->link.dealloc = &bpf_link_usdt_dealloc;\n\n\tif (man->has_uprobe_multi) {\n\t\toffsets = calloc(target_cnt, sizeof(*offsets));\n\t\tcookies = calloc(target_cnt, sizeof(*cookies));\n\t\tref_ctr_offsets = calloc(target_cnt, sizeof(*ref_ctr_offsets));\n\n\t\tif (!offsets || !ref_ctr_offsets || !cookies) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tlink->uprobes = calloc(target_cnt, sizeof(*link->uprobes));\n\t\tif (!link->uprobes) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < target_cnt; i++) {\n\t\tstruct usdt_target *target = &targets[i];\n\t\tstruct bpf_link *uprobe_link;\n\t\tbool is_new;\n\t\tint spec_id;\n\n\t\t \n\t\terr = allocate_spec_id(man, specs_hash, link, target, &spec_id, &is_new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tif (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {\n\t\t\terr = -errno;\n\t\t\tpr_warn(\"usdt: failed to set USDT spec #%d for '%s:%s' in '%s': %d\\n\",\n\t\t\t\tspec_id, usdt_provider, usdt_name, path, err);\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (!man->has_bpf_cookie &&\n\t\t    bpf_map_update_elem(ip_map_fd, &target->abs_ip, &spec_id, BPF_NOEXIST)) {\n\t\t\terr = -errno;\n\t\t\tif (err == -EEXIST) {\n\t\t\t\tpr_warn(\"usdt: IP collision detected for spec #%d for '%s:%s' in '%s'\\n\",\n\t\t\t\t        spec_id, usdt_provider, usdt_name, path);\n\t\t\t} else {\n\t\t\t\tpr_warn(\"usdt: failed to map IP 0x%lx to spec #%d for '%s:%s' in '%s': %d\\n\",\n\t\t\t\t\ttarget->abs_ip, spec_id, usdt_provider, usdt_name,\n\t\t\t\t\tpath, err);\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (man->has_uprobe_multi) {\n\t\t\toffsets[i] = target->rel_ip;\n\t\t\tref_ctr_offsets[i] = target->sema_off;\n\t\t\tcookies[i] = spec_id;\n\t\t} else {\n\t\t\topts.ref_ctr_offset = target->sema_off;\n\t\t\topts.bpf_cookie = man->has_bpf_cookie ? spec_id : 0;\n\t\t\tuprobe_link = bpf_program__attach_uprobe_opts(prog, pid, path,\n\t\t\t\t\t\t\t\t      target->rel_ip, &opts);\n\t\t\terr = libbpf_get_error(uprobe_link);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"usdt: failed to attach uprobe #%d for '%s:%s' in '%s': %d\\n\",\n\t\t\t\t\ti, usdt_provider, usdt_name, path, err);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tlink->uprobes[i].link = uprobe_link;\n\t\t\tlink->uprobes[i].abs_ip = target->abs_ip;\n\t\t\tlink->uprobe_cnt++;\n\t\t}\n\t}\n\n\tif (man->has_uprobe_multi) {\n\t\tLIBBPF_OPTS(bpf_uprobe_multi_opts, opts_multi,\n\t\t\t.ref_ctr_offsets = ref_ctr_offsets,\n\t\t\t.offsets = offsets,\n\t\t\t.cookies = cookies,\n\t\t\t.cnt = target_cnt,\n\t\t);\n\n\t\tlink->multi_link = bpf_program__attach_uprobe_multi(prog, pid, path,\n\t\t\t\t\t\t\t\t    NULL, &opts_multi);\n\t\tif (!link->multi_link) {\n\t\t\terr = -errno;\n\t\t\tpr_warn(\"usdt: failed to attach uprobe multi for '%s:%s' in '%s': %d\\n\",\n\t\t\t\tusdt_provider, usdt_name, path, err);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tfree(offsets);\n\t\tfree(ref_ctr_offsets);\n\t\tfree(cookies);\n\t}\n\n\tfree(targets);\n\thashmap__free(specs_hash);\n\telf_close(&elf_fd);\n\treturn &link->link;\n\nerr_out:\n\tfree(offsets);\n\tfree(ref_ctr_offsets);\n\tfree(cookies);\n\n\tif (link)\n\t\tbpf_link__destroy(&link->link);\n\tfree(targets);\n\thashmap__free(specs_hash);\n\telf_close(&elf_fd);\n\treturn libbpf_err_ptr(err);\n}\n\n \nstatic int parse_usdt_note(Elf *elf, const char *path, GElf_Nhdr *nhdr,\n\t\t\t   const char *data, size_t name_off, size_t desc_off,\n\t\t\t   struct usdt_note *note)\n{\n\tconst char *provider, *name, *args;\n\tlong addrs[3];\n\tsize_t len;\n\n\t \n\tif (strncmp(data + name_off, USDT_NOTE_NAME, nhdr->n_namesz) != 0)\n\t\treturn -EINVAL;\n\tif (nhdr->n_type != USDT_NOTE_TYPE)\n\t\treturn -EINVAL;\n\n\t \n\tlen = nhdr->n_descsz;\n\tdata = data + desc_off;\n\n\t \n\tif (len < sizeof(addrs) + 3)\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(&addrs, data, sizeof(addrs));\n\n\t \n\tprovider = data + sizeof(addrs);\n\n\tname = (const char *)memchr(provider, '\\0', data + len - provider);\n\tif (!name)  \n\t\treturn -EINVAL;\n\tname++;\n\tif (name >= data + len || *name == '\\0')  \n\t\treturn -EINVAL;\n\n\targs = memchr(name, '\\0', data + len - name);\n\tif (!args)  \n\t\treturn -EINVAL;\n\t++args;\n\tif (args >= data + len)  \n\t\treturn -EINVAL;\n\n\tnote->provider = provider;\n\tnote->name = name;\n\tif (*args == '\\0' || *args == ':')\n\t\tnote->args = \"\";\n\telse\n\t\tnote->args = args;\n\tnote->loc_addr = addrs[0];\n\tnote->base_addr = addrs[1];\n\tnote->sema_addr = addrs[2];\n\n\treturn 0;\n}\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz);\n\nstatic int parse_usdt_spec(struct usdt_spec *spec, const struct usdt_note *note, __u64 usdt_cookie)\n{\n\tstruct usdt_arg_spec *arg;\n\tconst char *s;\n\tint arg_sz, len;\n\n\tspec->usdt_cookie = usdt_cookie;\n\tspec->arg_cnt = 0;\n\n\ts = note->args;\n\twhile (s[0]) {\n\t\tif (spec->arg_cnt >= USDT_MAX_ARG_CNT) {\n\t\t\tpr_warn(\"usdt: too many USDT arguments (> %d) for '%s:%s' with args spec '%s'\\n\",\n\t\t\t\tUSDT_MAX_ARG_CNT, note->provider, note->name, note->args);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\targ = &spec->args[spec->arg_cnt];\n\t\tlen = parse_usdt_arg(s, spec->arg_cnt, arg, &arg_sz);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\targ->arg_signed = arg_sz < 0;\n\t\tif (arg_sz < 0)\n\t\t\targ_sz = -arg_sz;\n\n\t\tswitch (arg_sz) {\n\t\tcase 1: case 2: case 4: case 8:\n\t\t\targ->arg_bitshift = 64 - arg_sz * 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"usdt: unsupported arg #%d (spec '%s') size: %d\\n\",\n\t\t\t\tspec->arg_cnt, s, arg_sz);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ts += len;\n\t\tspec->arg_cnt++;\n\t}\n\n\treturn 0;\n}\n\n \n\n#if defined(__x86_64__) || defined(__i386__)\n\nstatic int calc_pt_regs_off(const char *reg_name)\n{\n\tstatic struct {\n\t\tconst char *names[4];\n\t\tsize_t pt_regs_off;\n\t} reg_map[] = {\n#ifdef __x86_64__\n#define reg_off(reg64, reg32) offsetof(struct pt_regs, reg64)\n#else\n#define reg_off(reg64, reg32) offsetof(struct pt_regs, reg32)\n#endif\n\t\t{ {\"rip\", \"eip\", \"\", \"\"}, reg_off(rip, eip) },\n\t\t{ {\"rax\", \"eax\", \"ax\", \"al\"}, reg_off(rax, eax) },\n\t\t{ {\"rbx\", \"ebx\", \"bx\", \"bl\"}, reg_off(rbx, ebx) },\n\t\t{ {\"rcx\", \"ecx\", \"cx\", \"cl\"}, reg_off(rcx, ecx) },\n\t\t{ {\"rdx\", \"edx\", \"dx\", \"dl\"}, reg_off(rdx, edx) },\n\t\t{ {\"rsi\", \"esi\", \"si\", \"sil\"}, reg_off(rsi, esi) },\n\t\t{ {\"rdi\", \"edi\", \"di\", \"dil\"}, reg_off(rdi, edi) },\n\t\t{ {\"rbp\", \"ebp\", \"bp\", \"bpl\"}, reg_off(rbp, ebp) },\n\t\t{ {\"rsp\", \"esp\", \"sp\", \"spl\"}, reg_off(rsp, esp) },\n#undef reg_off\n#ifdef __x86_64__\n\t\t{ {\"r8\", \"r8d\", \"r8w\", \"r8b\"}, offsetof(struct pt_regs, r8) },\n\t\t{ {\"r9\", \"r9d\", \"r9w\", \"r9b\"}, offsetof(struct pt_regs, r9) },\n\t\t{ {\"r10\", \"r10d\", \"r10w\", \"r10b\"}, offsetof(struct pt_regs, r10) },\n\t\t{ {\"r11\", \"r11d\", \"r11w\", \"r11b\"}, offsetof(struct pt_regs, r11) },\n\t\t{ {\"r12\", \"r12d\", \"r12w\", \"r12b\"}, offsetof(struct pt_regs, r12) },\n\t\t{ {\"r13\", \"r13d\", \"r13w\", \"r13b\"}, offsetof(struct pt_regs, r13) },\n\t\t{ {\"r14\", \"r14d\", \"r14w\", \"r14b\"}, offsetof(struct pt_regs, r14) },\n\t\t{ {\"r15\", \"r15d\", \"r15w\", \"r15b\"}, offsetof(struct pt_regs, r15) },\n#endif\n\t};\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_map); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(reg_map[i].names); j++) {\n\t\t\tif (strcmp(reg_name, reg_map[i].names[j]) == 0)\n\t\t\t\treturn reg_map[i].pt_regs_off;\n\t\t}\n\t}\n\n\tpr_warn(\"usdt: unrecognized register '%s'\\n\", reg_name);\n\treturn -ENOENT;\n}\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tchar reg_name[16];\n\tint len, reg_off;\n\tlong off;\n\n\tif (sscanf(arg_str, \" %d @ %ld ( %%%15[^)] ) %n\", arg_sz, &off, reg_name, &len) == 3) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = off;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ ( %%%15[^)] ) %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ %%%15s %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG;\n\t\targ->val_off = 0;\n\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ $%ld %n\", arg_sz, &off, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_CONST;\n\t\targ->val_off = off;\n\t\targ->reg_off = 0;\n\t} else {\n\t\tpr_warn(\"usdt: unrecognized arg #%d spec '%s'\\n\", arg_num, arg_str);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#elif defined(__s390x__)\n\n \n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tunsigned int reg;\n\tint len;\n\tlong off;\n\n\tif (sscanf(arg_str, \" %d @ %ld ( %%r%u ) %n\", arg_sz, &off, &reg, &len) == 3) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = off;\n\t\tif (reg > 15) {\n\t\t\tpr_warn(\"usdt: unrecognized register '%%r%u'\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targ->reg_off = offsetof(user_pt_regs, gprs[reg]);\n\t} else if (sscanf(arg_str, \" %d @ %%r%u %n\", arg_sz, &reg, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG;\n\t\targ->val_off = 0;\n\t\tif (reg > 15) {\n\t\t\tpr_warn(\"usdt: unrecognized register '%%r%u'\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targ->reg_off = offsetof(user_pt_regs, gprs[reg]);\n\t} else if (sscanf(arg_str, \" %d @ %ld %n\", arg_sz, &off, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_CONST;\n\t\targ->val_off = off;\n\t\targ->reg_off = 0;\n\t} else {\n\t\tpr_warn(\"usdt: unrecognized arg #%d spec '%s'\\n\", arg_num, arg_str);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#elif defined(__aarch64__)\n\nstatic int calc_pt_regs_off(const char *reg_name)\n{\n\tint reg_num;\n\n\tif (sscanf(reg_name, \"x%d\", &reg_num) == 1) {\n\t\tif (reg_num >= 0 && reg_num < 31)\n\t\t\treturn offsetof(struct user_pt_regs, regs[reg_num]);\n\t} else if (strcmp(reg_name, \"sp\") == 0) {\n\t\treturn offsetof(struct user_pt_regs, sp);\n\t}\n\tpr_warn(\"usdt: unrecognized register '%s'\\n\", reg_name);\n\treturn -ENOENT;\n}\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tchar reg_name[16];\n\tint len, reg_off;\n\tlong off;\n\n\tif (sscanf(arg_str, \" %d @ \\[ %15[a-z0-9] , %ld ] %n\", arg_sz, reg_name, &off, &len) == 3) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = off;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ \\[ %15[a-z0-9] ] %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ %ld %n\", arg_sz, &off, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_CONST;\n\t\targ->val_off = off;\n\t\targ->reg_off = 0;\n\t} else if (sscanf(arg_str, \" %d @ %15[a-z0-9] %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else {\n\t\tpr_warn(\"usdt: unrecognized arg #%d spec '%s'\\n\", arg_num, arg_str);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#elif defined(__riscv)\n\nstatic int calc_pt_regs_off(const char *reg_name)\n{\n\tstatic struct {\n\t\tconst char *name;\n\t\tsize_t pt_regs_off;\n\t} reg_map[] = {\n\t\t{ \"ra\", offsetof(struct user_regs_struct, ra) },\n\t\t{ \"sp\", offsetof(struct user_regs_struct, sp) },\n\t\t{ \"gp\", offsetof(struct user_regs_struct, gp) },\n\t\t{ \"tp\", offsetof(struct user_regs_struct, tp) },\n\t\t{ \"a0\", offsetof(struct user_regs_struct, a0) },\n\t\t{ \"a1\", offsetof(struct user_regs_struct, a1) },\n\t\t{ \"a2\", offsetof(struct user_regs_struct, a2) },\n\t\t{ \"a3\", offsetof(struct user_regs_struct, a3) },\n\t\t{ \"a4\", offsetof(struct user_regs_struct, a4) },\n\t\t{ \"a5\", offsetof(struct user_regs_struct, a5) },\n\t\t{ \"a6\", offsetof(struct user_regs_struct, a6) },\n\t\t{ \"a7\", offsetof(struct user_regs_struct, a7) },\n\t\t{ \"s0\", offsetof(struct user_regs_struct, s0) },\n\t\t{ \"s1\", offsetof(struct user_regs_struct, s1) },\n\t\t{ \"s2\", offsetof(struct user_regs_struct, s2) },\n\t\t{ \"s3\", offsetof(struct user_regs_struct, s3) },\n\t\t{ \"s4\", offsetof(struct user_regs_struct, s4) },\n\t\t{ \"s5\", offsetof(struct user_regs_struct, s5) },\n\t\t{ \"s6\", offsetof(struct user_regs_struct, s6) },\n\t\t{ \"s7\", offsetof(struct user_regs_struct, s7) },\n\t\t{ \"s8\", offsetof(struct user_regs_struct, rv_s8) },\n\t\t{ \"s9\", offsetof(struct user_regs_struct, s9) },\n\t\t{ \"s10\", offsetof(struct user_regs_struct, s10) },\n\t\t{ \"s11\", offsetof(struct user_regs_struct, s11) },\n\t\t{ \"t0\", offsetof(struct user_regs_struct, t0) },\n\t\t{ \"t1\", offsetof(struct user_regs_struct, t1) },\n\t\t{ \"t2\", offsetof(struct user_regs_struct, t2) },\n\t\t{ \"t3\", offsetof(struct user_regs_struct, t3) },\n\t\t{ \"t4\", offsetof(struct user_regs_struct, t4) },\n\t\t{ \"t5\", offsetof(struct user_regs_struct, t5) },\n\t\t{ \"t6\", offsetof(struct user_regs_struct, t6) },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_map); i++) {\n\t\tif (strcmp(reg_name, reg_map[i].name) == 0)\n\t\t\treturn reg_map[i].pt_regs_off;\n\t}\n\n\tpr_warn(\"usdt: unrecognized register '%s'\\n\", reg_name);\n\treturn -ENOENT;\n}\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tchar reg_name[16];\n\tint len, reg_off;\n\tlong off;\n\n\tif (sscanf(arg_str, \" %d @ %ld ( %15[a-z0-9] ) %n\", arg_sz, &off, reg_name, &len) == 3) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = off;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ %ld %n\", arg_sz, &off, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_CONST;\n\t\targ->val_off = off;\n\t\targ->reg_off = 0;\n\t} else if (sscanf(arg_str, \" %d @ %15[a-z0-9] %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else {\n\t\tpr_warn(\"usdt: unrecognized arg #%d spec '%s'\\n\", arg_num, arg_str);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#elif defined(__arm__)\n\nstatic int calc_pt_regs_off(const char *reg_name)\n{\n\tstatic struct {\n\t\tconst char *name;\n\t\tsize_t pt_regs_off;\n\t} reg_map[] = {\n\t\t{ \"r0\", offsetof(struct pt_regs, uregs[0]) },\n\t\t{ \"r1\", offsetof(struct pt_regs, uregs[1]) },\n\t\t{ \"r2\", offsetof(struct pt_regs, uregs[2]) },\n\t\t{ \"r3\", offsetof(struct pt_regs, uregs[3]) },\n\t\t{ \"r4\", offsetof(struct pt_regs, uregs[4]) },\n\t\t{ \"r5\", offsetof(struct pt_regs, uregs[5]) },\n\t\t{ \"r6\", offsetof(struct pt_regs, uregs[6]) },\n\t\t{ \"r7\", offsetof(struct pt_regs, uregs[7]) },\n\t\t{ \"r8\", offsetof(struct pt_regs, uregs[8]) },\n\t\t{ \"r9\", offsetof(struct pt_regs, uregs[9]) },\n\t\t{ \"r10\", offsetof(struct pt_regs, uregs[10]) },\n\t\t{ \"fp\", offsetof(struct pt_regs, uregs[11]) },\n\t\t{ \"ip\", offsetof(struct pt_regs, uregs[12]) },\n\t\t{ \"sp\", offsetof(struct pt_regs, uregs[13]) },\n\t\t{ \"lr\", offsetof(struct pt_regs, uregs[14]) },\n\t\t{ \"pc\", offsetof(struct pt_regs, uregs[15]) },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_map); i++) {\n\t\tif (strcmp(reg_name, reg_map[i].name) == 0)\n\t\t\treturn reg_map[i].pt_regs_off;\n\t}\n\n\tpr_warn(\"usdt: unrecognized register '%s'\\n\", reg_name);\n\treturn -ENOENT;\n}\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tchar reg_name[16];\n\tint len, reg_off;\n\tlong off;\n\n\tif (sscanf(arg_str, \" %d @ \\[ %15[a-z0-9] , #%ld ] %n\",\n\t\t   arg_sz, reg_name, &off, &len) == 3) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = off;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ \\[ %15[a-z0-9] ] %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG_DEREF;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else if (sscanf(arg_str, \" %d @ #%ld %n\", arg_sz, &off, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_CONST;\n\t\targ->val_off = off;\n\t\targ->reg_off = 0;\n\t} else if (sscanf(arg_str, \" %d @ %15[a-z0-9] %n\", arg_sz, reg_name, &len) == 2) {\n\t\t \n\t\targ->arg_type = USDT_ARG_REG;\n\t\targ->val_off = 0;\n\t\treg_off = calc_pt_regs_off(reg_name);\n\t\tif (reg_off < 0)\n\t\t\treturn reg_off;\n\t\targ->reg_off = reg_off;\n\t} else {\n\t\tpr_warn(\"usdt: unrecognized arg #%d spec '%s'\\n\", arg_num, arg_str);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#else\n\nstatic int parse_usdt_arg(const char *arg_str, int arg_num, struct usdt_arg_spec *arg, int *arg_sz)\n{\n\tpr_warn(\"usdt: libbpf doesn't support USDTs on current architecture\\n\");\n\treturn -ENOTSUP;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}