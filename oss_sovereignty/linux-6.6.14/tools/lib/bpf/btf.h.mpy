{
  "module_name": "btf.h",
  "hash_id": "db4b9f196453cbce9e7a6dded1d68f9e311857420826c80cf1d7b4b642d3189b",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/btf.h",
  "human_readable_source": " \n \n \n\n#ifndef __LIBBPF_BTF_H\n#define __LIBBPF_BTF_H\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <linux/btf.h>\n#include <linux/types.h>\n\n#include \"libbpf_common.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BTF_ELF_SEC \".BTF\"\n#define BTF_EXT_ELF_SEC \".BTF.ext\"\n#define MAPS_ELF_SEC \".maps\"\n\nstruct btf;\nstruct btf_ext;\nstruct btf_type;\n\nstruct bpf_object;\n\nenum btf_endianness {\n\tBTF_LITTLE_ENDIAN = 0,\n\tBTF_BIG_ENDIAN = 1,\n};\n\n \nLIBBPF_API void btf__free(struct btf *btf);\n\n \nLIBBPF_API struct btf *btf__new(const void *data, __u32 size);\n\n \nLIBBPF_API struct btf *btf__new_split(const void *data, __u32 size, struct btf *base_btf);\n\n \nLIBBPF_API struct btf *btf__new_empty(void);\n\n \nLIBBPF_API struct btf *btf__new_empty_split(struct btf *base_btf);\n\nLIBBPF_API struct btf *btf__parse(const char *path, struct btf_ext **btf_ext);\nLIBBPF_API struct btf *btf__parse_split(const char *path, struct btf *base_btf);\nLIBBPF_API struct btf *btf__parse_elf(const char *path, struct btf_ext **btf_ext);\nLIBBPF_API struct btf *btf__parse_elf_split(const char *path, struct btf *base_btf);\nLIBBPF_API struct btf *btf__parse_raw(const char *path);\nLIBBPF_API struct btf *btf__parse_raw_split(const char *path, struct btf *base_btf);\n\nLIBBPF_API struct btf *btf__load_vmlinux_btf(void);\nLIBBPF_API struct btf *btf__load_module_btf(const char *module_name, struct btf *vmlinux_btf);\n\nLIBBPF_API struct btf *btf__load_from_kernel_by_id(__u32 id);\nLIBBPF_API struct btf *btf__load_from_kernel_by_id_split(__u32 id, struct btf *base_btf);\n\nLIBBPF_API int btf__load_into_kernel(struct btf *btf);\nLIBBPF_API __s32 btf__find_by_name(const struct btf *btf,\n\t\t\t\t   const char *type_name);\nLIBBPF_API __s32 btf__find_by_name_kind(const struct btf *btf,\n\t\t\t\t\tconst char *type_name, __u32 kind);\nLIBBPF_API __u32 btf__type_cnt(const struct btf *btf);\nLIBBPF_API const struct btf *btf__base_btf(const struct btf *btf);\nLIBBPF_API const struct btf_type *btf__type_by_id(const struct btf *btf,\n\t\t\t\t\t\t  __u32 id);\nLIBBPF_API size_t btf__pointer_size(const struct btf *btf);\nLIBBPF_API int btf__set_pointer_size(struct btf *btf, size_t ptr_sz);\nLIBBPF_API enum btf_endianness btf__endianness(const struct btf *btf);\nLIBBPF_API int btf__set_endianness(struct btf *btf, enum btf_endianness endian);\nLIBBPF_API __s64 btf__resolve_size(const struct btf *btf, __u32 type_id);\nLIBBPF_API int btf__resolve_type(const struct btf *btf, __u32 type_id);\nLIBBPF_API int btf__align_of(const struct btf *btf, __u32 id);\nLIBBPF_API int btf__fd(const struct btf *btf);\nLIBBPF_API void btf__set_fd(struct btf *btf, int fd);\nLIBBPF_API const void *btf__raw_data(const struct btf *btf, __u32 *size);\nLIBBPF_API const char *btf__name_by_offset(const struct btf *btf, __u32 offset);\nLIBBPF_API const char *btf__str_by_offset(const struct btf *btf, __u32 offset);\n\nLIBBPF_API struct btf_ext *btf_ext__new(const __u8 *data, __u32 size);\nLIBBPF_API void btf_ext__free(struct btf_ext *btf_ext);\nLIBBPF_API const void *btf_ext__raw_data(const struct btf_ext *btf_ext, __u32 *size);\n\nLIBBPF_API int btf__find_str(struct btf *btf, const char *s);\nLIBBPF_API int btf__add_str(struct btf *btf, const char *s);\nLIBBPF_API int btf__add_type(struct btf *btf, const struct btf *src_btf,\n\t\t\t     const struct btf_type *src_type);\n \nLIBBPF_API int btf__add_btf(struct btf *btf, const struct btf *src_btf);\n\nLIBBPF_API int btf__add_int(struct btf *btf, const char *name, size_t byte_sz, int encoding);\nLIBBPF_API int btf__add_float(struct btf *btf, const char *name, size_t byte_sz);\nLIBBPF_API int btf__add_ptr(struct btf *btf, int ref_type_id);\nLIBBPF_API int btf__add_array(struct btf *btf,\n\t\t\t      int index_type_id, int elem_type_id, __u32 nr_elems);\n \nLIBBPF_API int btf__add_struct(struct btf *btf, const char *name, __u32 sz);\nLIBBPF_API int btf__add_union(struct btf *btf, const char *name, __u32 sz);\nLIBBPF_API int btf__add_field(struct btf *btf, const char *name, int field_type_id,\n\t\t\t      __u32 bit_offset, __u32 bit_size);\n\n \nLIBBPF_API int btf__add_enum(struct btf *btf, const char *name, __u32 bytes_sz);\nLIBBPF_API int btf__add_enum_value(struct btf *btf, const char *name, __s64 value);\nLIBBPF_API int btf__add_enum64(struct btf *btf, const char *name, __u32 bytes_sz, bool is_signed);\nLIBBPF_API int btf__add_enum64_value(struct btf *btf, const char *name, __u64 value);\n\nenum btf_fwd_kind {\n\tBTF_FWD_STRUCT = 0,\n\tBTF_FWD_UNION = 1,\n\tBTF_FWD_ENUM = 2,\n};\n\nLIBBPF_API int btf__add_fwd(struct btf *btf, const char *name, enum btf_fwd_kind fwd_kind);\nLIBBPF_API int btf__add_typedef(struct btf *btf, const char *name, int ref_type_id);\nLIBBPF_API int btf__add_volatile(struct btf *btf, int ref_type_id);\nLIBBPF_API int btf__add_const(struct btf *btf, int ref_type_id);\nLIBBPF_API int btf__add_restrict(struct btf *btf, int ref_type_id);\nLIBBPF_API int btf__add_type_tag(struct btf *btf, const char *value, int ref_type_id);\n\n \nLIBBPF_API int btf__add_func(struct btf *btf, const char *name,\n\t\t\t     enum btf_func_linkage linkage, int proto_type_id);\nLIBBPF_API int btf__add_func_proto(struct btf *btf, int ret_type_id);\nLIBBPF_API int btf__add_func_param(struct btf *btf, const char *name, int type_id);\n\n \nLIBBPF_API int btf__add_var(struct btf *btf, const char *name, int linkage, int type_id);\nLIBBPF_API int btf__add_datasec(struct btf *btf, const char *name, __u32 byte_sz);\nLIBBPF_API int btf__add_datasec_var_info(struct btf *btf, int var_type_id,\n\t\t\t\t\t __u32 offset, __u32 byte_sz);\n\n \nLIBBPF_API int btf__add_decl_tag(struct btf *btf, const char *value, int ref_type_id,\n\t\t\t    int component_idx);\n\nstruct btf_dedup_opts {\n\tsize_t sz;\n\t \n\tstruct btf_ext *btf_ext;\n\t \n\tbool force_collisions;\n\tsize_t :0;\n};\n#define btf_dedup_opts__last_field force_collisions\n\nLIBBPF_API int btf__dedup(struct btf *btf, const struct btf_dedup_opts *opts);\n\nstruct btf_dump;\n\nstruct btf_dump_opts {\n\tsize_t sz;\n};\n#define btf_dump_opts__last_field sz\n\ntypedef void (*btf_dump_printf_fn_t)(void *ctx, const char *fmt, va_list args);\n\nLIBBPF_API struct btf_dump *btf_dump__new(const struct btf *btf,\n\t\t\t\t\t  btf_dump_printf_fn_t printf_fn,\n\t\t\t\t\t  void *ctx,\n\t\t\t\t\t  const struct btf_dump_opts *opts);\n\nLIBBPF_API void btf_dump__free(struct btf_dump *d);\n\nLIBBPF_API int btf_dump__dump_type(struct btf_dump *d, __u32 id);\n\nstruct btf_dump_emit_type_decl_opts {\n\t \n\tsize_t sz;\n\t \n\tconst char *field_name;\n\t \n\tint indent_level;\n\t \n\tbool strip_mods;\n\tsize_t :0;\n};\n#define btf_dump_emit_type_decl_opts__last_field strip_mods\n\nLIBBPF_API int\nbtf_dump__emit_type_decl(struct btf_dump *d, __u32 id,\n\t\t\t const struct btf_dump_emit_type_decl_opts *opts);\n\n\nstruct btf_dump_type_data_opts {\n\t \n\tsize_t sz;\n\tconst char *indent_str;\n\tint indent_level;\n\t \n\tbool compact;\t\t \n\tbool skip_names;\t \n\tbool emit_zeroes;\t \n\tsize_t :0;\n};\n#define btf_dump_type_data_opts__last_field emit_zeroes\n\nLIBBPF_API int\nbtf_dump__dump_type_data(struct btf_dump *d, __u32 id,\n\t\t\t const void *data, size_t data_sz,\n\t\t\t const struct btf_dump_type_data_opts *opts);\n\n \n#ifndef BTF_KIND_FUNC\n#define BTF_KIND_FUNC\t\t12\t \n#define BTF_KIND_FUNC_PROTO\t13\t \n#endif\n#ifndef BTF_KIND_VAR\n#define BTF_KIND_VAR\t\t14\t \n#define BTF_KIND_DATASEC\t15\t \n#endif\n#ifndef BTF_KIND_FLOAT\n#define BTF_KIND_FLOAT\t\t16\t \n#endif\n \n#define BTF_KIND_DECL_TAG\t17\t \n#define BTF_KIND_TYPE_TAG\t18\t \n#define BTF_KIND_ENUM64\t\t19\t \n\nstatic inline __u16 btf_kind(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info);\n}\n\nstatic inline __u16 btf_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}\n\nstatic inline bool btf_kflag(const struct btf_type *t)\n{\n\treturn BTF_INFO_KFLAG(t->info);\n}\n\nstatic inline bool btf_is_void(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_UNKN;\n}\n\nstatic inline bool btf_is_int(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_INT;\n}\n\nstatic inline bool btf_is_ptr(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_PTR;\n}\n\nstatic inline bool btf_is_array(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ARRAY;\n}\n\nstatic inline bool btf_is_struct(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_STRUCT;\n}\n\nstatic inline bool btf_is_union(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_UNION;\n}\n\nstatic inline bool btf_is_composite(const struct btf_type *t)\n{\n\t__u16 kind = btf_kind(t);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}\n\nstatic inline bool btf_is_enum(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ENUM;\n}\n\nstatic inline bool btf_is_enum64(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ENUM64;\n}\n\nstatic inline bool btf_is_fwd(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_FWD;\n}\n\nstatic inline bool btf_is_typedef(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_TYPEDEF;\n}\n\nstatic inline bool btf_is_volatile(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_VOLATILE;\n}\n\nstatic inline bool btf_is_const(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_CONST;\n}\n\nstatic inline bool btf_is_restrict(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_RESTRICT;\n}\n\nstatic inline bool btf_is_mod(const struct btf_type *t)\n{\n\t__u16 kind = btf_kind(t);\n\n\treturn kind == BTF_KIND_VOLATILE ||\n\t       kind == BTF_KIND_CONST ||\n\t       kind == BTF_KIND_RESTRICT ||\n\t       kind == BTF_KIND_TYPE_TAG;\n}\n\nstatic inline bool btf_is_func(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_FUNC;\n}\n\nstatic inline bool btf_is_func_proto(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_FUNC_PROTO;\n}\n\nstatic inline bool btf_is_var(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_VAR;\n}\n\nstatic inline bool btf_is_datasec(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_DATASEC;\n}\n\nstatic inline bool btf_is_float(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_FLOAT;\n}\n\nstatic inline bool btf_is_decl_tag(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_DECL_TAG;\n}\n\nstatic inline bool btf_is_type_tag(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_TYPE_TAG;\n}\n\nstatic inline bool btf_is_any_enum(const struct btf_type *t)\n{\n\treturn btf_is_enum(t) || btf_is_enum64(t);\n}\n\nstatic inline bool btf_kind_core_compat(const struct btf_type *t1,\n\t\t\t\t\tconst struct btf_type *t2)\n{\n\treturn btf_kind(t1) == btf_kind(t2) ||\n\t       (btf_is_any_enum(t1) && btf_is_any_enum(t2));\n}\n\nstatic inline __u8 btf_int_encoding(const struct btf_type *t)\n{\n\treturn BTF_INT_ENCODING(*(__u32 *)(t + 1));\n}\n\nstatic inline __u8 btf_int_offset(const struct btf_type *t)\n{\n\treturn BTF_INT_OFFSET(*(__u32 *)(t + 1));\n}\n\nstatic inline __u8 btf_int_bits(const struct btf_type *t)\n{\n\treturn BTF_INT_BITS(*(__u32 *)(t + 1));\n}\n\nstatic inline struct btf_array *btf_array(const struct btf_type *t)\n{\n\treturn (struct btf_array *)(t + 1);\n}\n\nstatic inline struct btf_enum *btf_enum(const struct btf_type *t)\n{\n\treturn (struct btf_enum *)(t + 1);\n}\n\nstruct btf_enum64;\n\nstatic inline struct btf_enum64 *btf_enum64(const struct btf_type *t)\n{\n\treturn (struct btf_enum64 *)(t + 1);\n}\n\nstatic inline __u64 btf_enum64_value(const struct btf_enum64 *e)\n{\n\t \n\tconst __u32 *e64 = (const __u32 *)e;\n\n\treturn ((__u64)e64[2] << 32) | e64[1];\n}\n\nstatic inline struct btf_member *btf_members(const struct btf_type *t)\n{\n\treturn (struct btf_member *)(t + 1);\n}\n\n \nstatic inline __u32 btf_member_bit_offset(const struct btf_type *t,\n\t\t\t\t\t  __u32 member_idx)\n{\n\tconst struct btf_member *m = btf_members(t) + member_idx;\n\tbool kflag = btf_kflag(t);\n\n\treturn kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;\n}\n \nstatic inline __u32 btf_member_bitfield_size(const struct btf_type *t,\n\t\t\t\t\t     __u32 member_idx)\n{\n\tconst struct btf_member *m = btf_members(t) + member_idx;\n\tbool kflag = btf_kflag(t);\n\n\treturn kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;\n}\n\nstatic inline struct btf_param *btf_params(const struct btf_type *t)\n{\n\treturn (struct btf_param *)(t + 1);\n}\n\nstatic inline struct btf_var *btf_var(const struct btf_type *t)\n{\n\treturn (struct btf_var *)(t + 1);\n}\n\nstatic inline struct btf_var_secinfo *\nbtf_var_secinfos(const struct btf_type *t)\n{\n\treturn (struct btf_var_secinfo *)(t + 1);\n}\n\nstruct btf_decl_tag;\nstatic inline struct btf_decl_tag *btf_decl_tag(const struct btf_type *t)\n{\n\treturn (struct btf_decl_tag *)(t + 1);\n}\n\n#ifdef __cplusplus\n}  \n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}