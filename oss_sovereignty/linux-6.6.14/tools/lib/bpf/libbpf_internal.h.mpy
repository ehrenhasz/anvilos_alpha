{
  "module_name": "libbpf_internal.h",
  "hash_id": "eb09797764b18fd032db536e8508496cc17223ad63a822773cc53b9a615295c3",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/libbpf_internal.h",
  "human_readable_source": " \n\n \n\n#ifndef __LIBBPF_LIBBPF_INTERNAL_H\n#define __LIBBPF_LIBBPF_INTERNAL_H\n\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <linux/err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <libelf.h>\n#include \"relo_core.h\"\n\n \n#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64\n\n \n#pragma GCC poison reallocarray\n\n#include \"libbpf.h\"\n#include \"btf.h\"\n\n#ifndef EM_BPF\n#define EM_BPF 247\n#endif\n\n#ifndef R_BPF_64_64\n#define R_BPF_64_64 1\n#endif\n#ifndef R_BPF_64_ABS64\n#define R_BPF_64_ABS64 2\n#endif\n#ifndef R_BPF_64_ABS32\n#define R_BPF_64_ABS32 3\n#endif\n#ifndef R_BPF_64_32\n#define R_BPF_64_32 10\n#endif\n\n#ifndef SHT_LLVM_ADDRSIG\n#define SHT_LLVM_ADDRSIG 0x6FFF4C03\n#endif\n\n \n#ifndef ELF_C_READ_MMAP\n#define ELF_C_READ_MMAP ELF_C_READ\n#endif\n\n \n#ifndef ELF64_ST_VISIBILITY\n#define ELF64_ST_VISIBILITY(o) ((o) & 0x03)\n#endif\n\n#define BTF_INFO_ENC(kind, kind_flag, vlen) \\\n\t((!!(kind_flag) << 31) | ((kind) << 24) | ((vlen) & BTF_MAX_VLEN))\n#define BTF_TYPE_ENC(name, info, size_or_type) (name), (info), (size_or_type)\n#define BTF_INT_ENC(encoding, bits_offset, nr_bits) \\\n\t((encoding) << 24 | (bits_offset) << 16 | (nr_bits))\n#define BTF_TYPE_INT_ENC(name, encoding, bits_offset, bits, sz) \\\n\tBTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_INT, 0, 0), sz), \\\n\tBTF_INT_ENC(encoding, bits_offset, bits)\n#define BTF_MEMBER_ENC(name, type, bits_offset) (name), (type), (bits_offset)\n#define BTF_PARAM_ENC(name, type) (name), (type)\n#define BTF_VAR_SECINFO_ENC(type, offset, size) (type), (offset), (size)\n#define BTF_TYPE_FLOAT_ENC(name, sz) \\\n\tBTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_FLOAT, 0, 0), sz)\n#define BTF_TYPE_DECL_TAG_ENC(value, type, component_idx) \\\n\tBTF_TYPE_ENC(value, BTF_INFO_ENC(BTF_KIND_DECL_TAG, 0, 0), type), (component_idx)\n#define BTF_TYPE_TYPE_TAG_ENC(value, type) \\\n\tBTF_TYPE_ENC(value, BTF_INFO_ENC(BTF_KIND_TYPE_TAG, 0, 0), type)\n\n#ifndef likely\n#define likely(x) __builtin_expect(!!(x), 1)\n#endif\n#ifndef unlikely\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#endif\n#ifndef min\n# define min(x, y) ((x) < (y) ? (x) : (y))\n#endif\n#ifndef max\n# define max(x, y) ((x) < (y) ? (y) : (x))\n#endif\n#ifndef offsetofend\n# define offsetofend(TYPE, FIELD) \\\n\t(offsetof(TYPE, FIELD) + sizeof(((TYPE *)0)->FIELD))\n#endif\n#ifndef __alias\n#define __alias(symbol) __attribute__((alias(#symbol)))\n#endif\n\n \n#define str_has_pfx(str, pfx) \\\n\t(strncmp(str, pfx, __builtin_constant_p(pfx) ? sizeof(pfx) - 1 : strlen(pfx)) == 0)\n\n \nstatic inline bool str_has_sfx(const char *str, const char *sfx)\n{\n\tsize_t str_len = strlen(str);\n\tsize_t sfx_len = strlen(sfx);\n\n\tif (sfx_len > str_len)\n\t\treturn false;\n\treturn strcmp(str + str_len - sfx_len, sfx) == 0;\n}\n\n \n#if defined(SHARED) && defined(__GNUC__) && __GNUC__ >= 10\n\n#define DEFAULT_VERSION(internal_name, api_name, version) \\\n\t__attribute__((symver(#api_name \"@@\" #version)))\n#define COMPAT_VERSION(internal_name, api_name, version) \\\n\t__attribute__((symver(#api_name \"@\" #version)))\n\n#elif defined(SHARED)\n\n#define COMPAT_VERSION(internal_name, api_name, version) \\\n\tasm(\".symver \" #internal_name \",\" #api_name \"@\" #version);\n#define DEFAULT_VERSION(internal_name, api_name, version) \\\n\tasm(\".symver \" #internal_name \",\" #api_name \"@@\" #version);\n\n#else  \n\n#define COMPAT_VERSION(internal_name, api_name, version)\n#define DEFAULT_VERSION(internal_name, api_name, version) \\\n\textern typeof(internal_name) api_name \\\n\t__attribute__((alias(#internal_name)));\n\n#endif\n\nextern void libbpf_print(enum libbpf_print_level level,\n\t\t\t const char *format, ...)\n\t__attribute__((format(printf, 2, 3)));\n\n#define __pr(level, fmt, ...)\t\\\ndo {\t\t\t\t\\\n\tlibbpf_print(level, \"libbpf: \" fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define pr_warn(fmt, ...)\t__pr(LIBBPF_WARN, fmt, ##__VA_ARGS__)\n#define pr_info(fmt, ...)\t__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)\n#define pr_debug(fmt, ...)\t__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)\n\n#ifndef __has_builtin\n#define __has_builtin(x) 0\n#endif\n\nstruct bpf_link {\n\tint (*detach)(struct bpf_link *link);\n\tvoid (*dealloc)(struct bpf_link *link);\n\tchar *pin_path;\t\t \n\tint fd;\t\t\t \n\tbool disconnected;\n};\n\n \nstatic inline void *libbpf_reallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tsize_t total;\n\n#if __has_builtin(__builtin_mul_overflow)\n\tif (unlikely(__builtin_mul_overflow(nmemb, size, &total)))\n\t\treturn NULL;\n#else\n\tif (size == 0 || nmemb > ULONG_MAX / size)\n\t\treturn NULL;\n\ttotal = nmemb * size;\n#endif\n\treturn realloc(ptr, total);\n}\n\n \nstatic inline void libbpf_strlcpy(char *dst, const char *src, size_t sz)\n{\n\tsize_t i;\n\n\tif (sz == 0)\n\t\treturn;\n\n\tsz--;\n\tfor (i = 0; i < sz && src[i]; i++)\n\t\tdst[i] = src[i];\n\tdst[i] = '\\0';\n}\n\n__u32 get_kernel_version(void);\n\nstruct btf;\nstruct btf_type;\n\nstruct btf_type *btf_type_by_id(const struct btf *btf, __u32 type_id);\nconst char *btf_kind_str(const struct btf_type *t);\nconst struct btf_type *skip_mods_and_typedefs(const struct btf *btf, __u32 id, __u32 *res_id);\n\nstatic inline enum btf_func_linkage btf_func_linkage(const struct btf_type *t)\n{\n\treturn (enum btf_func_linkage)(int)btf_vlen(t);\n}\n\nstatic inline __u32 btf_type_info(int kind, int vlen, int kflag)\n{\n\treturn (kflag << 31) | (kind << 24) | vlen;\n}\n\nenum map_def_parts {\n\tMAP_DEF_MAP_TYPE\t= 0x001,\n\tMAP_DEF_KEY_TYPE\t= 0x002,\n\tMAP_DEF_KEY_SIZE\t= 0x004,\n\tMAP_DEF_VALUE_TYPE\t= 0x008,\n\tMAP_DEF_VALUE_SIZE\t= 0x010,\n\tMAP_DEF_MAX_ENTRIES\t= 0x020,\n\tMAP_DEF_MAP_FLAGS\t= 0x040,\n\tMAP_DEF_NUMA_NODE\t= 0x080,\n\tMAP_DEF_PINNING\t\t= 0x100,\n\tMAP_DEF_INNER_MAP\t= 0x200,\n\tMAP_DEF_MAP_EXTRA\t= 0x400,\n\n\tMAP_DEF_ALL\t\t= 0x7ff,  \n};\n\nstruct btf_map_def {\n\tenum map_def_parts parts;\n\t__u32 map_type;\n\t__u32 key_type_id;\n\t__u32 key_size;\n\t__u32 value_type_id;\n\t__u32 value_size;\n\t__u32 max_entries;\n\t__u32 map_flags;\n\t__u32 numa_node;\n\t__u32 pinning;\n\t__u64 map_extra;\n};\n\nint parse_btf_map_def(const char *map_name, struct btf *btf,\n\t\t      const struct btf_type *def_t, bool strict,\n\t\t      struct btf_map_def *map_def, struct btf_map_def *inner_def);\n\nvoid *libbpf_add_mem(void **data, size_t *cap_cnt, size_t elem_sz,\n\t\t     size_t cur_cnt, size_t max_cnt, size_t add_cnt);\nint libbpf_ensure_mem(void **data, size_t *cap_cnt, size_t elem_sz, size_t need_cnt);\n\nstatic inline bool libbpf_is_mem_zeroed(const char *p, ssize_t len)\n{\n\twhile (len > 0) {\n\t\tif (*p)\n\t\t\treturn false;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn true;\n}\n\nstatic inline bool libbpf_validate_opts(const char *opts,\n\t\t\t\t\tsize_t opts_sz, size_t user_sz,\n\t\t\t\t\tconst char *type_name)\n{\n\tif (user_sz < sizeof(size_t)) {\n\t\tpr_warn(\"%s size (%zu) is too small\\n\", type_name, user_sz);\n\t\treturn false;\n\t}\n\tif (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {\n\t\tpr_warn(\"%s has non-zero extra bytes\\n\", type_name);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define OPTS_VALID(opts, type)\t\t\t\t\t\t      \\\n\t(!(opts) || libbpf_validate_opts((const char *)opts,\t\t      \\\n\t\t\t\t\t offsetofend(struct type,\t      \\\n\t\t\t\t\t\t     type##__last_field),     \\\n\t\t\t\t\t (opts)->sz, #type))\n#define OPTS_HAS(opts, field) \\\n\t((opts) && opts->sz >= offsetofend(typeof(*(opts)), field))\n#define OPTS_GET(opts, field, fallback_value) \\\n\t(OPTS_HAS(opts, field) ? (opts)->field : fallback_value)\n#define OPTS_SET(opts, field, value)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (OPTS_HAS(opts, field))\t\\\n\t\t\t(opts)->field = value;\t\\\n\t} while (0)\n\n#define OPTS_ZEROED(opts, last_nonzero_field)\t\t\t\t      \\\n({\t\t\t\t\t\t\t\t\t      \\\n\tssize_t __off = offsetofend(typeof(*(opts)), last_nonzero_field);     \\\n\t!(opts) || libbpf_is_mem_zeroed((const void *)opts + __off,\t      \\\n\t\t\t\t\t(opts)->sz - __off);\t\t      \\\n})\n\nenum kern_feature_id {\n\t \n\tFEAT_PROG_NAME,\n\t \n\tFEAT_GLOBAL_DATA,\n\t \n\tFEAT_BTF,\n\t \n\tFEAT_BTF_FUNC,\n\t \n\tFEAT_BTF_DATASEC,\n\t \n\tFEAT_BTF_GLOBAL_FUNC,\n\t \n\tFEAT_ARRAY_MMAP,\n\t \n\tFEAT_EXP_ATTACH_TYPE,\n\t \n\tFEAT_PROBE_READ_KERN,\n\t \n\tFEAT_PROG_BIND_MAP,\n\t \n\tFEAT_MODULE_BTF,\n\t \n\tFEAT_BTF_FLOAT,\n\t \n\tFEAT_PERF_LINK,\n\t \n\tFEAT_BTF_DECL_TAG,\n\t \n\tFEAT_BTF_TYPE_TAG,\n\t \n\tFEAT_MEMCG_ACCOUNT,\n\t \n\tFEAT_BPF_COOKIE,\n\t \n\tFEAT_BTF_ENUM64,\n\t \n\tFEAT_SYSCALL_WRAPPER,\n\t \n\tFEAT_UPROBE_MULTI_LINK,\n\t__FEAT_CNT,\n};\n\nint probe_memcg_account(void);\nbool kernel_supports(const struct bpf_object *obj, enum kern_feature_id feat_id);\nint bump_rlimit_memlock(void);\n\nint parse_cpu_mask_str(const char *s, bool **mask, int *mask_sz);\nint parse_cpu_mask_file(const char *fcpu, bool **mask, int *mask_sz);\nint libbpf__load_raw_btf(const char *raw_types, size_t types_len,\n\t\t\t const char *str_sec, size_t str_len);\nint btf_load_into_kernel(struct btf *btf, char *log_buf, size_t log_sz, __u32 log_level);\n\nstruct btf *btf_get_from_fd(int btf_fd, struct btf *base_btf);\nvoid btf_get_kernel_prefix_kind(enum bpf_attach_type attach_type,\n\t\t\t\tconst char **prefix, int *kind);\n\nstruct btf_ext_info {\n\t \n\tvoid *info;\n\t__u32 rec_size;\n\t__u32 len;\n\t \n\t__u32 *sec_idxs;\n\tint sec_cnt;\n};\n\n#define for_each_btf_ext_sec(seg, sec)\t\t\t\t\t\\\n\tfor (sec = (seg)->info;\t\t\t\t\t\t\\\n\t     (void *)sec < (seg)->info + (seg)->len;\t\t\t\\\n\t     sec = (void *)sec + sizeof(struct btf_ext_info_sec) +\t\\\n\t\t   (seg)->rec_size * sec->num_info)\n\n#define for_each_btf_ext_rec(seg, sec, i, rec)\t\t\t\t\\\n\tfor (i = 0, rec = (void *)&(sec)->data;\t\t\t\t\\\n\t     i < (sec)->num_info;\t\t\t\t\t\\\n\t     i++, rec = (void *)rec + (seg)->rec_size)\n\n \nstruct btf_ext_header {\n\t__u16\tmagic;\n\t__u8\tversion;\n\t__u8\tflags;\n\t__u32\thdr_len;\n\n\t \n\t__u32\tfunc_info_off;\n\t__u32\tfunc_info_len;\n\t__u32\tline_info_off;\n\t__u32\tline_info_len;\n\n\t \n\t__u32\tcore_relo_off;\n\t__u32\tcore_relo_len;\n};\n\nstruct btf_ext {\n\tunion {\n\t\tstruct btf_ext_header *hdr;\n\t\tvoid *data;\n\t};\n\tstruct btf_ext_info func_info;\n\tstruct btf_ext_info line_info;\n\tstruct btf_ext_info core_relo_info;\n\t__u32 data_size;\n};\n\nstruct btf_ext_info_sec {\n\t__u32\tsec_name_off;\n\t__u32\tnum_info;\n\t \n\t__u8\tdata[];\n};\n\n \nstruct bpf_func_info_min {\n\t__u32   insn_off;\n\t__u32   type_id;\n};\n\n \nstruct bpf_line_info_min {\n\t__u32\tinsn_off;\n\t__u32\tfile_name_off;\n\t__u32\tline_off;\n\t__u32\tline_col;\n};\n\n\ntypedef int (*type_id_visit_fn)(__u32 *type_id, void *ctx);\ntypedef int (*str_off_visit_fn)(__u32 *str_off, void *ctx);\nint btf_type_visit_type_ids(struct btf_type *t, type_id_visit_fn visit, void *ctx);\nint btf_type_visit_str_offs(struct btf_type *t, str_off_visit_fn visit, void *ctx);\nint btf_ext_visit_type_ids(struct btf_ext *btf_ext, type_id_visit_fn visit, void *ctx);\nint btf_ext_visit_str_offs(struct btf_ext *btf_ext, str_off_visit_fn visit, void *ctx);\n__s32 btf__find_by_name_kind_own(const struct btf *btf, const char *type_name,\n\t\t\t\t __u32 kind);\n\ntypedef int (*kallsyms_cb_t)(unsigned long long sym_addr, char sym_type,\n\t\t\t     const char *sym_name, void *ctx);\n\nint libbpf_kallsyms_parse(kallsyms_cb_t cb, void *arg);\n\n \nstatic inline int libbpf_err(int ret)\n{\n\tif (ret < 0)\n\t\terrno = -ret;\n\treturn ret;\n}\n\n \nstatic inline int libbpf_err_errno(int ret)\n{\n\t \n\treturn ret < 0 ? -errno : ret;\n}\n\n \nstatic inline void *libbpf_err_ptr(int err)\n{\n\t \n\terrno = -err;\n\treturn NULL;\n}\n\n \nstatic inline void *libbpf_ptr(void *ret)\n{\n\t \n\tif (IS_ERR(ret))\n\t\terrno = -PTR_ERR(ret);\n\n\treturn IS_ERR(ret) ? NULL : ret;\n}\n\nstatic inline bool str_is_empty(const char *s)\n{\n\treturn !s || !s[0];\n}\n\nstatic inline bool is_ldimm64_insn(struct bpf_insn *insn)\n{\n\treturn insn->code == (BPF_LD | BPF_IMM | BPF_DW);\n}\n\n \nstatic inline int ensure_good_fd(int fd)\n{\n\tint old_fd = fd, saved_errno;\n\n\tif (fd < 0)\n\t\treturn fd;\n\tif (fd < 3) {\n\t\tfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\t\tsaved_errno = errno;\n\t\tclose(old_fd);\n\t\terrno = saved_errno;\n\t\tif (fd < 0) {\n\t\t\tpr_warn(\"failed to dup FD %d to FD > 2: %d\\n\", old_fd, -saved_errno);\n\t\t\terrno = saved_errno;\n\t\t}\n\t}\n\treturn fd;\n}\n\n \nint bpf_core_add_cands(struct bpf_core_cand *local_cand,\n\t\t       size_t local_essent_len,\n\t\t       const struct btf *targ_btf,\n\t\t       const char *targ_btf_name,\n\t\t       int targ_start_id,\n\t\t       struct bpf_core_cand_list *cands);\nvoid bpf_core_free_cands(struct bpf_core_cand_list *cands);\n\nstruct usdt_manager *usdt_manager_new(struct bpf_object *obj);\nvoid usdt_manager_free(struct usdt_manager *man);\nstruct bpf_link * usdt_manager_attach_usdt(struct usdt_manager *man,\n\t\t\t\t\t   const struct bpf_program *prog,\n\t\t\t\t\t   pid_t pid, const char *path,\n\t\t\t\t\t   const char *usdt_provider, const char *usdt_name,\n\t\t\t\t\t   __u64 usdt_cookie);\n\nstatic inline bool is_pow_of_2(size_t x)\n{\n\treturn x && (x & (x - 1)) == 0;\n}\n\n#define PROG_LOAD_ATTEMPTS 5\nint sys_bpf_prog_load(union bpf_attr *attr, unsigned int size, int attempts);\n\nbool glob_match(const char *str, const char *pat);\n\nlong elf_find_func_offset(Elf *elf, const char *binary_path, const char *name);\nlong elf_find_func_offset_from_file(const char *binary_path, const char *name);\n\nstruct elf_fd {\n\tElf *elf;\n\tint fd;\n};\n\nint elf_open(const char *binary_path, struct elf_fd *elf_fd);\nvoid elf_close(struct elf_fd *elf_fd);\n\nint elf_resolve_syms_offsets(const char *binary_path, int cnt,\n\t\t\t     const char **syms, unsigned long **poffsets);\nint elf_resolve_pattern_offsets(const char *binary_path, const char *pattern,\n\t\t\t\t unsigned long **poffsets, size_t *pcnt);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}