{
  "module_name": "linker.c",
  "hash_id": "47e4723822b13fd5cc0f211832b6cf53c671fc595c8d3f5e4a25c1d0a7628861",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/linker.c",
  "human_readable_source": "\n \n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <elf.h>\n#include <libelf.h>\n#include <fcntl.h>\n#include \"libbpf.h\"\n#include \"btf.h\"\n#include \"libbpf_internal.h\"\n#include \"strset.h\"\n\n#define BTF_EXTERN_SEC \".extern\"\n\nstruct src_sec {\n\tconst char *sec_name;\n\t \n\tint id;\n\t \n\tint dst_id;\n\t \n\tint dst_off;\n\t \n\tbool skipped;\n\t \n\tbool ephemeral;\n\n\t \n\tsize_t sec_idx;\n\tElf_Scn *scn;\n\tElf64_Shdr *shdr;\n\tElf_Data *data;\n\n\t \n\tint sec_type_id;\n};\n\nstruct src_obj {\n\tconst char *filename;\n\tint fd;\n\tElf *elf;\n\t \n\tsize_t shstrs_sec_idx;\n\t \n\tsize_t symtab_sec_idx;\n\n\tstruct btf *btf;\n\tstruct btf_ext *btf_ext;\n\n\t \n\tstruct src_sec *secs;\n\tint sec_cnt;\n\n\t \n\tint *sym_map;\n\t \n\tint *btf_type_map;\n};\n\n \nstruct btf_ext_sec_data {\n\tsize_t rec_cnt;\n\t__u32 rec_sz;\n\tvoid *recs;\n};\n\nstruct glob_sym {\n\t \n\tint sym_idx;\n\t \n\tint sec_id;\n\t \n\tint name_off;\n\t \n\tint btf_id;\n\t \n\tint underlying_btf_id;\n\t \n\tint var_idx;\n\n\t \n\tbool is_extern;\n\t \n\tbool is_weak;\n};\n\nstruct dst_sec {\n\tchar *sec_name;\n\t \n\tint id;\n\n\tbool ephemeral;\n\n\t \n\tsize_t sec_idx;\n\tElf_Scn *scn;\n\tElf64_Shdr *shdr;\n\tElf_Data *data;\n\n\t \n\tint sec_sz;\n\t \n\tvoid *raw_data;\n\n\t \n\tint sec_sym_idx;\n\n\t \n\tbool has_btf;\n\tint sec_var_cnt;\n\tstruct btf_var_secinfo *sec_vars;\n\n\t \n\tstruct btf_ext_sec_data func_info;\n\tstruct btf_ext_sec_data line_info;\n\tstruct btf_ext_sec_data core_relo_info;\n};\n\nstruct bpf_linker {\n\tchar *filename;\n\tint fd;\n\tElf *elf;\n\tElf64_Ehdr *elf_hdr;\n\n\t \n\tstruct dst_sec *secs;\n\tint sec_cnt;\n\n\tstruct strset *strtab_strs;  \n\tsize_t strtab_sec_idx;  \n\tsize_t symtab_sec_idx;  \n\n\tstruct btf *btf;\n\tstruct btf_ext *btf_ext;\n\n\t \n\tint glob_sym_cnt;\n\tstruct glob_sym *glob_syms;\n};\n\n#define pr_warn_elf(fmt, ...)\t\t\t\t\t\t\t\t\t\\\n\tlibbpf_print(LIBBPF_WARN, \"libbpf: \" fmt \": %s\\n\", ##__VA_ARGS__, elf_errmsg(-1))\n\nstatic int init_output_elf(struct bpf_linker *linker, const char *file);\n\nstatic int linker_load_obj_file(struct bpf_linker *linker, const char *filename,\n\t\t\t\tconst struct bpf_linker_file_opts *opts,\n\t\t\t\tstruct src_obj *obj);\nstatic int linker_sanity_check_elf(struct src_obj *obj);\nstatic int linker_sanity_check_elf_symtab(struct src_obj *obj, struct src_sec *sec);\nstatic int linker_sanity_check_elf_relos(struct src_obj *obj, struct src_sec *sec);\nstatic int linker_sanity_check_btf(struct src_obj *obj);\nstatic int linker_sanity_check_btf_ext(struct src_obj *obj);\nstatic int linker_fixup_btf(struct src_obj *obj);\nstatic int linker_append_sec_data(struct bpf_linker *linker, struct src_obj *obj);\nstatic int linker_append_elf_syms(struct bpf_linker *linker, struct src_obj *obj);\nstatic int linker_append_elf_sym(struct bpf_linker *linker, struct src_obj *obj,\n\t\t\t\t Elf64_Sym *sym, const char *sym_name, int src_sym_idx);\nstatic int linker_append_elf_relos(struct bpf_linker *linker, struct src_obj *obj);\nstatic int linker_append_btf(struct bpf_linker *linker, struct src_obj *obj);\nstatic int linker_append_btf_ext(struct bpf_linker *linker, struct src_obj *obj);\n\nstatic int finalize_btf(struct bpf_linker *linker);\nstatic int finalize_btf_ext(struct bpf_linker *linker);\n\nvoid bpf_linker__free(struct bpf_linker *linker)\n{\n\tint i;\n\n\tif (!linker)\n\t\treturn;\n\n\tfree(linker->filename);\n\n\tif (linker->elf)\n\t\telf_end(linker->elf);\n\n\tif (linker->fd >= 0)\n\t\tclose(linker->fd);\n\n\tstrset__free(linker->strtab_strs);\n\n\tbtf__free(linker->btf);\n\tbtf_ext__free(linker->btf_ext);\n\n\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\tfree(sec->sec_name);\n\t\tfree(sec->raw_data);\n\t\tfree(sec->sec_vars);\n\n\t\tfree(sec->func_info.recs);\n\t\tfree(sec->line_info.recs);\n\t\tfree(sec->core_relo_info.recs);\n\t}\n\tfree(linker->secs);\n\n\tfree(linker->glob_syms);\n\tfree(linker);\n}\n\nstruct bpf_linker *bpf_linker__new(const char *filename, struct bpf_linker_opts *opts)\n{\n\tstruct bpf_linker *linker;\n\tint err;\n\n\tif (!OPTS_VALID(opts, bpf_linker_opts))\n\t\treturn errno = EINVAL, NULL;\n\n\tif (elf_version(EV_CURRENT) == EV_NONE) {\n\t\tpr_warn_elf(\"libelf initialization failed\");\n\t\treturn errno = EINVAL, NULL;\n\t}\n\n\tlinker = calloc(1, sizeof(*linker));\n\tif (!linker)\n\t\treturn errno = ENOMEM, NULL;\n\n\tlinker->fd = -1;\n\n\terr = init_output_elf(linker, filename);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn linker;\n\nerr_out:\n\tbpf_linker__free(linker);\n\treturn errno = -err, NULL;\n}\n\nstatic struct dst_sec *add_dst_sec(struct bpf_linker *linker, const char *sec_name)\n{\n\tstruct dst_sec *secs = linker->secs, *sec;\n\tsize_t new_cnt = linker->sec_cnt ? linker->sec_cnt + 1 : 2;\n\n\tsecs = libbpf_reallocarray(secs, new_cnt, sizeof(*secs));\n\tif (!secs)\n\t\treturn NULL;\n\n\t \n\tmemset(secs + linker->sec_cnt, 0, (new_cnt - linker->sec_cnt) * sizeof(*secs));\n\n\tlinker->secs = secs;\n\tlinker->sec_cnt = new_cnt;\n\n\tsec = &linker->secs[new_cnt - 1];\n\tsec->id = new_cnt - 1;\n\tsec->sec_name = strdup(sec_name);\n\tif (!sec->sec_name)\n\t\treturn NULL;\n\n\treturn sec;\n}\n\nstatic Elf64_Sym *add_new_sym(struct bpf_linker *linker, size_t *sym_idx)\n{\n\tstruct dst_sec *symtab = &linker->secs[linker->symtab_sec_idx];\n\tElf64_Sym *syms, *sym;\n\tsize_t sym_cnt = symtab->sec_sz / sizeof(*sym);\n\n\tsyms = libbpf_reallocarray(symtab->raw_data, sym_cnt + 1, sizeof(*sym));\n\tif (!syms)\n\t\treturn NULL;\n\n\tsym = &syms[sym_cnt];\n\tmemset(sym, 0, sizeof(*sym));\n\n\tsymtab->raw_data = syms;\n\tsymtab->sec_sz += sizeof(*sym);\n\tsymtab->shdr->sh_size += sizeof(*sym);\n\tsymtab->data->d_size += sizeof(*sym);\n\n\tif (sym_idx)\n\t\t*sym_idx = sym_cnt;\n\n\treturn sym;\n}\n\nstatic int init_output_elf(struct bpf_linker *linker, const char *file)\n{\n\tint err, str_off;\n\tElf64_Sym *init_sym;\n\tstruct dst_sec *sec;\n\n\tlinker->filename = strdup(file);\n\tif (!linker->filename)\n\t\treturn -ENOMEM;\n\n\tlinker->fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0644);\n\tif (linker->fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to create '%s': %d\\n\", file, err);\n\t\treturn err;\n\t}\n\n\tlinker->elf = elf_begin(linker->fd, ELF_C_WRITE, NULL);\n\tif (!linker->elf) {\n\t\tpr_warn_elf(\"failed to create ELF object\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlinker->elf_hdr = elf64_newehdr(linker->elf);\n\tif (!linker->elf_hdr) {\n\t\tpr_warn_elf(\"failed to create ELF header\");\n\t\treturn -EINVAL;\n\t}\n\n\tlinker->elf_hdr->e_machine = EM_BPF;\n\tlinker->elf_hdr->e_type = ET_REL;\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tlinker->elf_hdr->e_ident[EI_DATA] = ELFDATA2LSB;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tlinker->elf_hdr->e_ident[EI_DATA] = ELFDATA2MSB;\n#else\n#error \"Unknown __BYTE_ORDER__\"\n#endif\n\n\t \n\t \n\tlinker->strtab_strs = strset__new(INT_MAX, \"\", sizeof(\"\"));\n\tif (libbpf_get_error(linker->strtab_strs))\n\t\treturn libbpf_get_error(linker->strtab_strs);\n\n\tsec = add_dst_sec(linker, \".strtab\");\n\tif (!sec)\n\t\treturn -ENOMEM;\n\n\tsec->scn = elf_newscn(linker->elf);\n\tif (!sec->scn) {\n\t\tpr_warn_elf(\"failed to create STRTAB section\");\n\t\treturn -EINVAL;\n\t}\n\n\tsec->shdr = elf64_getshdr(sec->scn);\n\tif (!sec->shdr)\n\t\treturn -EINVAL;\n\n\tsec->data = elf_newdata(sec->scn);\n\tif (!sec->data) {\n\t\tpr_warn_elf(\"failed to create STRTAB data\");\n\t\treturn -EINVAL;\n\t}\n\n\tstr_off = strset__add_str(linker->strtab_strs, sec->sec_name);\n\tif (str_off < 0)\n\t\treturn str_off;\n\n\tsec->sec_idx = elf_ndxscn(sec->scn);\n\tlinker->elf_hdr->e_shstrndx = sec->sec_idx;\n\tlinker->strtab_sec_idx = sec->sec_idx;\n\n\tsec->shdr->sh_name = str_off;\n\tsec->shdr->sh_type = SHT_STRTAB;\n\tsec->shdr->sh_flags = SHF_STRINGS;\n\tsec->shdr->sh_offset = 0;\n\tsec->shdr->sh_link = 0;\n\tsec->shdr->sh_info = 0;\n\tsec->shdr->sh_addralign = 1;\n\tsec->shdr->sh_size = sec->sec_sz = 0;\n\tsec->shdr->sh_entsize = 0;\n\n\t \n\tsec = add_dst_sec(linker, \".symtab\");\n\tif (!sec)\n\t\treturn -ENOMEM;\n\n\tsec->scn = elf_newscn(linker->elf);\n\tif (!sec->scn) {\n\t\tpr_warn_elf(\"failed to create SYMTAB section\");\n\t\treturn -EINVAL;\n\t}\n\n\tsec->shdr = elf64_getshdr(sec->scn);\n\tif (!sec->shdr)\n\t\treturn -EINVAL;\n\n\tsec->data = elf_newdata(sec->scn);\n\tif (!sec->data) {\n\t\tpr_warn_elf(\"failed to create SYMTAB data\");\n\t\treturn -EINVAL;\n\t}\n\n\tstr_off = strset__add_str(linker->strtab_strs, sec->sec_name);\n\tif (str_off < 0)\n\t\treturn str_off;\n\n\tsec->sec_idx = elf_ndxscn(sec->scn);\n\tlinker->symtab_sec_idx = sec->sec_idx;\n\n\tsec->shdr->sh_name = str_off;\n\tsec->shdr->sh_type = SHT_SYMTAB;\n\tsec->shdr->sh_flags = 0;\n\tsec->shdr->sh_offset = 0;\n\tsec->shdr->sh_link = linker->strtab_sec_idx;\n\t \n\tsec->shdr->sh_info = 0;\n\tsec->shdr->sh_addralign = 8;\n\tsec->shdr->sh_entsize = sizeof(Elf64_Sym);\n\n\t \n\tlinker->btf = btf__new_empty();\n\terr = libbpf_get_error(linker->btf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tinit_sym = add_new_sym(linker, NULL);\n\tif (!init_sym)\n\t\treturn -EINVAL;\n\n\tinit_sym->st_name = 0;\n\tinit_sym->st_info = 0;\n\tinit_sym->st_other = 0;\n\tinit_sym->st_shndx = SHN_UNDEF;\n\tinit_sym->st_value = 0;\n\tinit_sym->st_size = 0;\n\n\treturn 0;\n}\n\nint bpf_linker__add_file(struct bpf_linker *linker, const char *filename,\n\t\t\t const struct bpf_linker_file_opts *opts)\n{\n\tstruct src_obj obj = {};\n\tint err = 0;\n\n\tif (!OPTS_VALID(opts, bpf_linker_file_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (!linker->elf)\n\t\treturn libbpf_err(-EINVAL);\n\n\terr = err ?: linker_load_obj_file(linker, filename, opts, &obj);\n\terr = err ?: linker_append_sec_data(linker, &obj);\n\terr = err ?: linker_append_elf_syms(linker, &obj);\n\terr = err ?: linker_append_elf_relos(linker, &obj);\n\terr = err ?: linker_append_btf(linker, &obj);\n\terr = err ?: linker_append_btf_ext(linker, &obj);\n\n\t \n\tfree(obj.btf_type_map);\n\tbtf__free(obj.btf);\n\tbtf_ext__free(obj.btf_ext);\n\tfree(obj.secs);\n\tfree(obj.sym_map);\n\tif (obj.elf)\n\t\telf_end(obj.elf);\n\tif (obj.fd >= 0)\n\t\tclose(obj.fd);\n\n\treturn libbpf_err(err);\n}\n\nstatic bool is_dwarf_sec_name(const char *name)\n{\n\t \n\treturn strncmp(name, \".debug_\", sizeof(\".debug_\") - 1) == 0;\n}\n\nstatic bool is_ignored_sec(struct src_sec *sec)\n{\n\tElf64_Shdr *shdr = sec->shdr;\n\tconst char *name = sec->sec_name;\n\n\t \n\tif (shdr->sh_type == SHT_STRTAB)\n\t\treturn true;\n\n\t \n\tif (shdr->sh_type == SHT_LLVM_ADDRSIG)\n\t\treturn true;\n\n\t \n\tif (shdr->sh_type == SHT_PROGBITS && shdr->sh_size == 0 &&\n\t    strcmp(sec->sec_name, \".text\") == 0)\n\t\treturn true;\n\n\t \n\tif (is_dwarf_sec_name(sec->sec_name))\n\t\treturn true;\n\n\tif (strncmp(name, \".rel\", sizeof(\".rel\") - 1) == 0) {\n\t\tname += sizeof(\".rel\") - 1;\n\t\t \n\t\tif (is_dwarf_sec_name(name))\n\t\t\treturn true;\n\n\t\t \n\t\tif (strcmp(name, BTF_ELF_SEC) == 0 ||\n\t\t    strcmp(name, BTF_EXT_ELF_SEC) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct src_sec *add_src_sec(struct src_obj *obj, const char *sec_name)\n{\n\tstruct src_sec *secs = obj->secs, *sec;\n\tsize_t new_cnt = obj->sec_cnt ? obj->sec_cnt + 1 : 2;\n\n\tsecs = libbpf_reallocarray(secs, new_cnt, sizeof(*secs));\n\tif (!secs)\n\t\treturn NULL;\n\n\t \n\tmemset(secs + obj->sec_cnt, 0, (new_cnt - obj->sec_cnt) * sizeof(*secs));\n\n\tobj->secs = secs;\n\tobj->sec_cnt = new_cnt;\n\n\tsec = &obj->secs[new_cnt - 1];\n\tsec->id = new_cnt - 1;\n\tsec->sec_name = sec_name;\n\n\treturn sec;\n}\n\nstatic int linker_load_obj_file(struct bpf_linker *linker, const char *filename,\n\t\t\t\tconst struct bpf_linker_file_opts *opts,\n\t\t\t\tstruct src_obj *obj)\n{\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tconst int host_endianness = ELFDATA2LSB;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tconst int host_endianness = ELFDATA2MSB;\n#else\n#error \"Unknown __BYTE_ORDER__\"\n#endif\n\tint err = 0;\n\tElf_Scn *scn;\n\tElf_Data *data;\n\tElf64_Ehdr *ehdr;\n\tElf64_Shdr *shdr;\n\tstruct src_sec *sec;\n\n\tpr_debug(\"linker: adding object file '%s'...\\n\", filename);\n\n\tobj->filename = filename;\n\n\tobj->fd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (obj->fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to open file '%s': %d\\n\", filename, err);\n\t\treturn err;\n\t}\n\tobj->elf = elf_begin(obj->fd, ELF_C_READ_MMAP, NULL);\n\tif (!obj->elf) {\n\t\terr = -errno;\n\t\tpr_warn_elf(\"failed to parse ELF file '%s'\", filename);\n\t\treturn err;\n\t}\n\n\t \n\tehdr = elf64_getehdr(obj->elf);\n\tif (!ehdr) {\n\t\terr = -errno;\n\t\tpr_warn_elf(\"failed to get ELF header for %s\", filename);\n\t\treturn err;\n\t}\n\tif (ehdr->e_ident[EI_DATA] != host_endianness) {\n\t\terr = -EOPNOTSUPP;\n\t\tpr_warn_elf(\"unsupported byte order of ELF file %s\", filename);\n\t\treturn err;\n\t}\n\tif (ehdr->e_type != ET_REL\n\t    || ehdr->e_machine != EM_BPF\n\t    || ehdr->e_ident[EI_CLASS] != ELFCLASS64) {\n\t\terr = -EOPNOTSUPP;\n\t\tpr_warn_elf(\"unsupported kind of ELF file %s\", filename);\n\t\treturn err;\n\t}\n\n\tif (elf_getshdrstrndx(obj->elf, &obj->shstrs_sec_idx)) {\n\t\terr = -errno;\n\t\tpr_warn_elf(\"failed to get SHSTRTAB section index for %s\", filename);\n\t\treturn err;\n\t}\n\n\tscn = NULL;\n\twhile ((scn = elf_nextscn(obj->elf, scn)) != NULL) {\n\t\tsize_t sec_idx = elf_ndxscn(scn);\n\t\tconst char *sec_name;\n\n\t\tshdr = elf64_getshdr(scn);\n\t\tif (!shdr) {\n\t\t\terr = -errno;\n\t\t\tpr_warn_elf(\"failed to get section #%zu header for %s\",\n\t\t\t\t    sec_idx, filename);\n\t\t\treturn err;\n\t\t}\n\n\t\tsec_name = elf_strptr(obj->elf, obj->shstrs_sec_idx, shdr->sh_name);\n\t\tif (!sec_name) {\n\t\t\terr = -errno;\n\t\t\tpr_warn_elf(\"failed to get section #%zu name for %s\",\n\t\t\t\t    sec_idx, filename);\n\t\t\treturn err;\n\t\t}\n\n\t\tdata = elf_getdata(scn, 0);\n\t\tif (!data) {\n\t\t\terr = -errno;\n\t\t\tpr_warn_elf(\"failed to get section #%zu (%s) data from %s\",\n\t\t\t\t    sec_idx, sec_name, filename);\n\t\t\treturn err;\n\t\t}\n\n\t\tsec = add_src_sec(obj, sec_name);\n\t\tif (!sec)\n\t\t\treturn -ENOMEM;\n\n\t\tsec->scn = scn;\n\t\tsec->shdr = shdr;\n\t\tsec->data = data;\n\t\tsec->sec_idx = elf_ndxscn(scn);\n\n\t\tif (is_ignored_sec(sec)) {\n\t\t\tsec->skipped = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (shdr->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\t\tif (obj->symtab_sec_idx) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tpr_warn(\"multiple SYMTAB sections found, not supported\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tobj->symtab_sec_idx = sec_idx;\n\t\t\tbreak;\n\t\tcase SHT_STRTAB:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SHT_PROGBITS:\n\t\t\tif (strcmp(sec_name, BTF_ELF_SEC) == 0) {\n\t\t\t\tobj->btf = btf__new(data->d_buf, shdr->sh_size);\n\t\t\t\terr = libbpf_get_error(obj->btf);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_warn(\"failed to parse .BTF from %s: %d\\n\", filename, err);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tsec->skipped = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(sec_name, BTF_EXT_ELF_SEC) == 0) {\n\t\t\t\tobj->btf_ext = btf_ext__new(data->d_buf, shdr->sh_size);\n\t\t\t\terr = libbpf_get_error(obj->btf_ext);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_warn(\"failed to parse .BTF.ext from '%s': %d\\n\", filename, err);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tsec->skipped = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tbreak;\n\t\tcase SHT_NOBITS:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SHT_REL:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unrecognized section #%zu (%s) in %s\\n\",\n\t\t\t\tsec_idx, sec_name, filename);\n\t\t\terr = -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = err ?: linker_sanity_check_elf(obj);\n\terr = err ?: linker_sanity_check_btf(obj);\n\terr = err ?: linker_sanity_check_btf_ext(obj);\n\terr = err ?: linker_fixup_btf(obj);\n\n\treturn err;\n}\n\nstatic int linker_sanity_check_elf(struct src_obj *obj)\n{\n\tstruct src_sec *sec;\n\tint i, err;\n\n\tif (!obj->symtab_sec_idx) {\n\t\tpr_warn(\"ELF is missing SYMTAB section in %s\\n\", obj->filename);\n\t\treturn -EINVAL;\n\t}\n\tif (!obj->shstrs_sec_idx) {\n\t\tpr_warn(\"ELF is missing section headers STRTAB section in %s\\n\", obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i < obj->sec_cnt; i++) {\n\t\tsec = &obj->secs[i];\n\n\t\tif (sec->sec_name[0] == '\\0') {\n\t\t\tpr_warn(\"ELF section #%zu has empty name in %s\\n\", sec->sec_idx, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sec->shdr->sh_addralign && !is_pow_of_2(sec->shdr->sh_addralign))\n\t\t\treturn -EINVAL;\n\t\tif (sec->shdr->sh_addralign != sec->data->d_align)\n\t\t\treturn -EINVAL;\n\n\t\tif (sec->shdr->sh_size != sec->data->d_size)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sec->shdr->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\t\terr = linker_sanity_check_elf_symtab(obj, sec);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase SHT_STRTAB:\n\t\t\tbreak;\n\t\tcase SHT_PROGBITS:\n\t\t\tif (sec->shdr->sh_flags & SHF_EXECINSTR) {\n\t\t\t\tif (sec->shdr->sh_size % sizeof(struct bpf_insn) != 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SHT_NOBITS:\n\t\t\tbreak;\n\t\tcase SHT_REL:\n\t\t\terr = linker_sanity_check_elf_relos(obj, sec);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase SHT_LLVM_ADDRSIG:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"ELF section #%zu (%s) has unrecognized type %zu in %s\\n\",\n\t\t\t\tsec->sec_idx, sec->sec_name, (size_t)sec->shdr->sh_type, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int linker_sanity_check_elf_symtab(struct src_obj *obj, struct src_sec *sec)\n{\n\tstruct src_sec *link_sec;\n\tElf64_Sym *sym;\n\tint i, n;\n\n\tif (sec->shdr->sh_entsize != sizeof(Elf64_Sym))\n\t\treturn -EINVAL;\n\tif (sec->shdr->sh_size % sec->shdr->sh_entsize != 0)\n\t\treturn -EINVAL;\n\n\tif (!sec->shdr->sh_link || sec->shdr->sh_link >= obj->sec_cnt) {\n\t\tpr_warn(\"ELF SYMTAB section #%zu points to missing STRTAB section #%zu in %s\\n\",\n\t\t\tsec->sec_idx, (size_t)sec->shdr->sh_link, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\tlink_sec = &obj->secs[sec->shdr->sh_link];\n\tif (link_sec->shdr->sh_type != SHT_STRTAB) {\n\t\tpr_warn(\"ELF SYMTAB section #%zu points to invalid STRTAB section #%zu in %s\\n\",\n\t\t\tsec->sec_idx, (size_t)sec->shdr->sh_link, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\tn = sec->shdr->sh_size / sec->shdr->sh_entsize;\n\tsym = sec->data->d_buf;\n\tfor (i = 0; i < n; i++, sym++) {\n\t\tint sym_type = ELF64_ST_TYPE(sym->st_info);\n\t\tint sym_bind = ELF64_ST_BIND(sym->st_info);\n\t\tint sym_vis = ELF64_ST_VISIBILITY(sym->st_other);\n\n\t\tif (i == 0) {\n\t\t\tif (sym->st_name != 0 || sym->st_info != 0\n\t\t\t    || sym->st_other != 0 || sym->st_shndx != 0\n\t\t\t    || sym->st_value != 0 || sym->st_size != 0) {\n\t\t\t\tpr_warn(\"ELF sym #0 is invalid in %s\\n\", obj->filename);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sym_bind != STB_LOCAL && sym_bind != STB_GLOBAL && sym_bind != STB_WEAK) {\n\t\t\tpr_warn(\"ELF sym #%d in section #%zu has unsupported symbol binding %d\\n\",\n\t\t\t\ti, sec->sec_idx, sym_bind);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sym_vis != STV_DEFAULT && sym_vis != STV_HIDDEN) {\n\t\t\tpr_warn(\"ELF sym #%d in section #%zu has unsupported symbol visibility %d\\n\",\n\t\t\t\ti, sec->sec_idx, sym_vis);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sym->st_shndx == 0) {\n\t\t\tif (sym_type != STT_NOTYPE || sym_bind == STB_LOCAL\n\t\t\t    || sym->st_value != 0 || sym->st_size != 0) {\n\t\t\t\tpr_warn(\"ELF sym #%d is invalid extern symbol in %s\\n\",\n\t\t\t\t\ti, obj->filename);\n\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sym->st_shndx < SHN_LORESERVE && sym->st_shndx >= obj->sec_cnt) {\n\t\t\tpr_warn(\"ELF sym #%d in section #%zu points to missing section #%zu in %s\\n\",\n\t\t\t\ti, sec->sec_idx, (size_t)sym->st_shndx, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sym_type == STT_SECTION) {\n\t\t\tif (sym->st_value != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int linker_sanity_check_elf_relos(struct src_obj *obj, struct src_sec *sec)\n{\n\tstruct src_sec *link_sec, *sym_sec;\n\tElf64_Rel *relo;\n\tint i, n;\n\n\tif (sec->shdr->sh_entsize != sizeof(Elf64_Rel))\n\t\treturn -EINVAL;\n\tif (sec->shdr->sh_size % sec->shdr->sh_entsize != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (sec->shdr->sh_link != obj->symtab_sec_idx) {\n\t\tpr_warn(\"ELF relo section #%zu points to invalid SYMTAB section #%zu in %s\\n\",\n\t\t\tsec->sec_idx, (size_t)sec->shdr->sh_link, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!sec->shdr->sh_info || sec->shdr->sh_info >= obj->sec_cnt) {\n\t\tpr_warn(\"ELF relo section #%zu points to missing section #%zu in %s\\n\",\n\t\t\tsec->sec_idx, (size_t)sec->shdr->sh_info, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\tlink_sec = &obj->secs[sec->shdr->sh_info];\n\n\t \n\tif (strncmp(sec->sec_name, \".rel\", sizeof(\".rel\") - 1) != 0\n\t    || strcmp(sec->sec_name + sizeof(\".rel\") - 1, link_sec->sec_name) != 0) {\n\t\tpr_warn(\"ELF relo section #%zu name has invalid name in %s\\n\",\n\t\t\tsec->sec_idx, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (link_sec->skipped)\n\t\treturn 0;\n\n\t \n\tif (link_sec->shdr->sh_type != SHT_PROGBITS && link_sec->shdr->sh_type != SHT_NOBITS) {\n\t\tpr_warn(\"ELF relo section #%zu points to invalid section #%zu in %s\\n\",\n\t\t\tsec->sec_idx, (size_t)sec->shdr->sh_info, obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tn = sec->shdr->sh_size / sec->shdr->sh_entsize;\n\trelo = sec->data->d_buf;\n\tsym_sec = &obj->secs[obj->symtab_sec_idx];\n\tfor (i = 0; i < n; i++, relo++) {\n\t\tsize_t sym_idx = ELF64_R_SYM(relo->r_info);\n\t\tsize_t sym_type = ELF64_R_TYPE(relo->r_info);\n\n\t\tif (sym_type != R_BPF_64_64 && sym_type != R_BPF_64_32 &&\n\t\t    sym_type != R_BPF_64_ABS64 && sym_type != R_BPF_64_ABS32) {\n\t\t\tpr_warn(\"ELF relo #%d in section #%zu has unexpected type %zu in %s\\n\",\n\t\t\t\ti, sec->sec_idx, sym_type, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!sym_idx || sym_idx * sizeof(Elf64_Sym) >= sym_sec->shdr->sh_size) {\n\t\t\tpr_warn(\"ELF relo #%d in section #%zu points to invalid symbol #%zu in %s\\n\",\n\t\t\t\ti, sec->sec_idx, sym_idx, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (link_sec->shdr->sh_flags & SHF_EXECINSTR) {\n\t\t\tif (relo->r_offset % sizeof(struct bpf_insn) != 0) {\n\t\t\t\tpr_warn(\"ELF relo #%d in section #%zu points to missing symbol #%zu in %s\\n\",\n\t\t\t\t\ti, sec->sec_idx, sym_idx, obj->filename);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_btf_type_id(__u32 *type_id, void *ctx)\n{\n\tstruct btf *btf = ctx;\n\n\tif (*type_id >= btf__type_cnt(btf))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int check_btf_str_off(__u32 *str_off, void *ctx)\n{\n\tstruct btf *btf = ctx;\n\tconst char *s;\n\n\ts = btf__str_by_offset(btf, *str_off);\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int linker_sanity_check_btf(struct src_obj *obj)\n{\n\tstruct btf_type *t;\n\tint i, n, err = 0;\n\n\tif (!obj->btf)\n\t\treturn 0;\n\n\tn = btf__type_cnt(obj->btf);\n\tfor (i = 1; i < n; i++) {\n\t\tt = btf_type_by_id(obj->btf, i);\n\n\t\terr = err ?: btf_type_visit_type_ids(t, check_btf_type_id, obj->btf);\n\t\terr = err ?: btf_type_visit_str_offs(t, check_btf_str_off, obj->btf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int linker_sanity_check_btf_ext(struct src_obj *obj)\n{\n\tint err = 0;\n\n\tif (!obj->btf_ext)\n\t\treturn 0;\n\n\t \n\tif (!obj->btf)\n\t\treturn -EINVAL;\n\n\terr = err ?: btf_ext_visit_type_ids(obj->btf_ext, check_btf_type_id, obj->btf);\n\terr = err ?: btf_ext_visit_str_offs(obj->btf_ext, check_btf_str_off, obj->btf);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int init_sec(struct bpf_linker *linker, struct dst_sec *dst_sec, struct src_sec *src_sec)\n{\n\tElf_Scn *scn;\n\tElf_Data *data;\n\tElf64_Shdr *shdr;\n\tint name_off;\n\n\tdst_sec->sec_sz = 0;\n\tdst_sec->sec_idx = 0;\n\tdst_sec->ephemeral = src_sec->ephemeral;\n\n\t \n\tif (src_sec->ephemeral)\n\t\treturn 0;\n\n\tscn = elf_newscn(linker->elf);\n\tif (!scn)\n\t\treturn -ENOMEM;\n\tdata = elf_newdata(scn);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tshdr = elf64_getshdr(scn);\n\tif (!shdr)\n\t\treturn -ENOMEM;\n\n\tdst_sec->scn = scn;\n\tdst_sec->shdr = shdr;\n\tdst_sec->data = data;\n\tdst_sec->sec_idx = elf_ndxscn(scn);\n\n\tname_off = strset__add_str(linker->strtab_strs, src_sec->sec_name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tshdr->sh_name = name_off;\n\tshdr->sh_type = src_sec->shdr->sh_type;\n\tshdr->sh_flags = src_sec->shdr->sh_flags;\n\tshdr->sh_size = 0;\n\t \n\tshdr->sh_link = 0;\n\tshdr->sh_info = 0;\n\tshdr->sh_addralign = src_sec->shdr->sh_addralign;\n\tshdr->sh_entsize = src_sec->shdr->sh_entsize;\n\n\tdata->d_type = src_sec->data->d_type;\n\tdata->d_size = 0;\n\tdata->d_buf = NULL;\n\tdata->d_align = src_sec->data->d_align;\n\tdata->d_off = 0;\n\n\treturn 0;\n}\n\nstatic struct dst_sec *find_dst_sec_by_name(struct bpf_linker *linker, const char *sec_name)\n{\n\tstruct dst_sec *sec;\n\tint i;\n\n\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\tsec = &linker->secs[i];\n\n\t\tif (strcmp(sec->sec_name, sec_name) == 0)\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool secs_match(struct dst_sec *dst, struct src_sec *src)\n{\n\tif (dst->ephemeral || src->ephemeral)\n\t\treturn true;\n\n\tif (dst->shdr->sh_type != src->shdr->sh_type) {\n\t\tpr_warn(\"sec %s types mismatch\\n\", dst->sec_name);\n\t\treturn false;\n\t}\n\tif (dst->shdr->sh_flags != src->shdr->sh_flags) {\n\t\tpr_warn(\"sec %s flags mismatch\\n\", dst->sec_name);\n\t\treturn false;\n\t}\n\tif (dst->shdr->sh_entsize != src->shdr->sh_entsize) {\n\t\tpr_warn(\"sec %s entsize mismatch\\n\", dst->sec_name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool sec_content_is_same(struct dst_sec *dst_sec, struct src_sec *src_sec)\n{\n\tif (dst_sec->sec_sz != src_sec->shdr->sh_size)\n\t\treturn false;\n\tif (memcmp(dst_sec->raw_data, src_sec->data->d_buf, dst_sec->sec_sz) != 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int extend_sec(struct bpf_linker *linker, struct dst_sec *dst, struct src_sec *src)\n{\n\tvoid *tmp;\n\tsize_t dst_align, src_align;\n\tsize_t dst_align_sz, dst_final_sz;\n\tint err;\n\n\t \n\tif (src->ephemeral)\n\t\treturn 0;\n\n\t \n\tif (dst->ephemeral) {\n\t\terr = init_sec(linker, dst, src);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdst_align = dst->shdr->sh_addralign;\n\tsrc_align = src->shdr->sh_addralign;\n\tif (dst_align == 0)\n\t\tdst_align = 1;\n\tif (dst_align < src_align)\n\t\tdst_align = src_align;\n\n\tdst_align_sz = (dst->sec_sz + dst_align - 1) / dst_align * dst_align;\n\n\t \n\tdst_final_sz = dst_align_sz + src->shdr->sh_size;\n\n\tif (src->shdr->sh_type != SHT_NOBITS) {\n\t\ttmp = realloc(dst->raw_data, dst_final_sz);\n\t\t \n\t\tif (!tmp && dst_align_sz > 0)\n\t\t\treturn -ENOMEM;\n\t\tdst->raw_data = tmp;\n\n\t\t \n\t\tmemset(dst->raw_data + dst->sec_sz, 0, dst_align_sz - dst->sec_sz);\n\t\t \n\t\tmemcpy(dst->raw_data + dst_align_sz, src->data->d_buf, src->shdr->sh_size);\n\t}\n\n\tdst->sec_sz = dst_final_sz;\n\tdst->shdr->sh_size = dst_final_sz;\n\tdst->data->d_size = dst_final_sz;\n\n\tdst->shdr->sh_addralign = dst_align;\n\tdst->data->d_align = dst_align;\n\n\tsrc->dst_off = dst_align_sz;\n\n\treturn 0;\n}\n\nstatic bool is_data_sec(struct src_sec *sec)\n{\n\tif (!sec || sec->skipped)\n\t\treturn false;\n\t \n\tif (sec->ephemeral)\n\t\treturn true;\n\treturn sec->shdr->sh_type == SHT_PROGBITS || sec->shdr->sh_type == SHT_NOBITS;\n}\n\nstatic bool is_relo_sec(struct src_sec *sec)\n{\n\tif (!sec || sec->skipped || sec->ephemeral)\n\t\treturn false;\n\treturn sec->shdr->sh_type == SHT_REL;\n}\n\nstatic int linker_append_sec_data(struct bpf_linker *linker, struct src_obj *obj)\n{\n\tint i, err;\n\n\tfor (i = 1; i < obj->sec_cnt; i++) {\n\t\tstruct src_sec *src_sec;\n\t\tstruct dst_sec *dst_sec;\n\n\t\tsrc_sec = &obj->secs[i];\n\t\tif (!is_data_sec(src_sec))\n\t\t\tcontinue;\n\n\t\tdst_sec = find_dst_sec_by_name(linker, src_sec->sec_name);\n\t\tif (!dst_sec) {\n\t\t\tdst_sec = add_dst_sec(linker, src_sec->sec_name);\n\t\t\tif (!dst_sec)\n\t\t\t\treturn -ENOMEM;\n\t\t\terr = init_sec(linker, dst_sec, src_sec);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"failed to init section '%s'\\n\", src_sec->sec_name);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!secs_match(dst_sec, src_sec)) {\n\t\t\t\tpr_warn(\"ELF sections %s are incompatible\\n\", src_sec->sec_name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (strcmp(src_sec->sec_name, \"license\") == 0\n\t\t\t    || strcmp(src_sec->sec_name, \"version\") == 0) {\n\t\t\t\tif (!sec_content_is_same(dst_sec, src_sec)) {\n\t\t\t\t\tpr_warn(\"non-identical contents of section '%s' are not supported\\n\", src_sec->sec_name);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tsrc_sec->skipped = true;\n\t\t\t\tsrc_sec->dst_id = dst_sec->id;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tsrc_sec->dst_id = dst_sec->id;\n\n\t\terr = extend_sec(linker, dst_sec, src_sec);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int linker_append_elf_syms(struct bpf_linker *linker, struct src_obj *obj)\n{\n\tstruct src_sec *symtab = &obj->secs[obj->symtab_sec_idx];\n\tElf64_Sym *sym = symtab->data->d_buf;\n\tint i, n = symtab->shdr->sh_size / symtab->shdr->sh_entsize, err;\n\tint str_sec_idx = symtab->shdr->sh_link;\n\tconst char *sym_name;\n\n\tobj->sym_map = calloc(n + 1, sizeof(*obj->sym_map));\n\tif (!obj->sym_map)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++, sym++) {\n\t\t \n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tsym_name = elf_strptr(obj->elf, str_sec_idx, sym->st_name);\n\t\tif (!sym_name) {\n\t\t\tpr_warn(\"can't fetch symbol name for symbol #%d in '%s'\\n\", i, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = linker_append_elf_sym(linker, obj, sym, sym_name, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic Elf64_Sym *get_sym_by_idx(struct bpf_linker *linker, size_t sym_idx)\n{\n\tstruct dst_sec *symtab = &linker->secs[linker->symtab_sec_idx];\n\tElf64_Sym *syms = symtab->raw_data;\n\n\treturn &syms[sym_idx];\n}\n\nstatic struct glob_sym *find_glob_sym(struct bpf_linker *linker, const char *sym_name)\n{\n\tstruct glob_sym *glob_sym;\n\tconst char *name;\n\tint i;\n\n\tfor (i = 0; i < linker->glob_sym_cnt; i++) {\n\t\tglob_sym = &linker->glob_syms[i];\n\t\tname = strset__data(linker->strtab_strs) + glob_sym->name_off;\n\n\t\tif (strcmp(name, sym_name) == 0)\n\t\t\treturn glob_sym;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct glob_sym *add_glob_sym(struct bpf_linker *linker)\n{\n\tstruct glob_sym *syms, *sym;\n\n\tsyms = libbpf_reallocarray(linker->glob_syms, linker->glob_sym_cnt + 1,\n\t\t\t\t   sizeof(*linker->glob_syms));\n\tif (!syms)\n\t\treturn NULL;\n\n\tsym = &syms[linker->glob_sym_cnt];\n\tmemset(sym, 0, sizeof(*sym));\n\tsym->var_idx = -1;\n\n\tlinker->glob_syms = syms;\n\tlinker->glob_sym_cnt++;\n\n\treturn sym;\n}\n\nstatic bool glob_sym_btf_matches(const char *sym_name, bool exact,\n\t\t\t\t const struct btf *btf1, __u32 id1,\n\t\t\t\t const struct btf *btf2, __u32 id2)\n{\n\tconst struct btf_type *t1, *t2;\n\tbool is_static1, is_static2;\n\tconst char *n1, *n2;\n\tint i, n;\n\nrecur:\n\tn1 = n2 = NULL;\n\tt1 = skip_mods_and_typedefs(btf1, id1, &id1);\n\tt2 = skip_mods_and_typedefs(btf2, id2, &id2);\n\n\t \n\tif (!exact && btf_is_fwd(t1) != btf_is_fwd(t2)) {\n\t\tn1 = btf__str_by_offset(btf1, t1->name_off);\n\t\tn2 = btf__str_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(n1, n2) != 0) {\n\t\t\tpr_warn(\"global '%s': incompatible forward declaration names '%s' and '%s'\\n\",\n\t\t\t\tsym_name, n1, n2);\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tif (btf_is_fwd(t1)) {\n\t\t\tif (btf_kflag(t1) && btf_is_union(t2))\n\t\t\t\treturn true;\n\t\t\tif (!btf_kflag(t1) && btf_is_struct(t2))\n\t\t\t\treturn true;\n\t\t\tpr_warn(\"global '%s': incompatible %s forward declaration and concrete kind %s\\n\",\n\t\t\t\tsym_name, btf_kflag(t1) ? \"union\" : \"struct\", btf_kind_str(t2));\n\t\t} else {\n\t\t\tif (btf_kflag(t2) && btf_is_union(t1))\n\t\t\t\treturn true;\n\t\t\tif (!btf_kflag(t2) && btf_is_struct(t1))\n\t\t\t\treturn true;\n\t\t\tpr_warn(\"global '%s': incompatible %s forward declaration and concrete kind %s\\n\",\n\t\t\t\tsym_name, btf_kflag(t2) ? \"union\" : \"struct\", btf_kind_str(t1));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (btf_kind(t1) != btf_kind(t2)) {\n\t\tpr_warn(\"global '%s': incompatible BTF kinds %s and %s\\n\",\n\t\t\tsym_name, btf_kind_str(t1), btf_kind_str(t2));\n\t\treturn false;\n\t}\n\n\tswitch (btf_kind(t1)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_VAR:\n\t\tn1 = btf__str_by_offset(btf1, t1->name_off);\n\t\tn2 = btf__str_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(n1, n2) != 0) {\n\t\t\tpr_warn(\"global '%s': incompatible %s names '%s' and '%s'\\n\",\n\t\t\t\tsym_name, btf_kind_str(t1), n1, n2);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (btf_kind(t1)) {\n\tcase BTF_KIND_UNKN:  \n\tcase BTF_KIND_FWD:\n\t\treturn true;\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\t \n\t\tif (t1->size != t2->size) {\n\t\t\tpr_warn(\"global '%s': incompatible %s '%s' size %u and %u\\n\",\n\t\t\t\tsym_name, btf_kind_str(t1), n1, t1->size, t2->size);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tcase BTF_KIND_PTR:\n\t\t \n\t\texact = false;\n\t\tid1 = t1->type;\n\t\tid2 = t2->type;\n\t\tgoto recur;\n\tcase BTF_KIND_ARRAY:\n\t\t \n\t\tid1 = btf_array(t1)->type;\n\t\tid2 = btf_array(t2)->type;\n\t\tgoto recur;\n\tcase BTF_KIND_FUNC:\n\t\t \n\t\tis_static1 = btf_func_linkage(t1) == BTF_FUNC_STATIC;\n\t\tis_static2 = btf_func_linkage(t2) == BTF_FUNC_STATIC;\n\t\tif (is_static1 != is_static2) {\n\t\t\tpr_warn(\"global '%s': incompatible func '%s' linkage\\n\", sym_name, n1);\n\t\t\treturn false;\n\t\t}\n\n\t\tid1 = t1->type;\n\t\tid2 = t2->type;\n\t\tgoto recur;\n\tcase BTF_KIND_VAR:\n\t\t \n\t\tis_static1 = btf_var(t1)->linkage == BTF_VAR_STATIC;\n\t\tis_static2 = btf_var(t2)->linkage == BTF_VAR_STATIC;\n\t\tif (is_static1 != is_static2) {\n\t\t\tpr_warn(\"global '%s': incompatible var '%s' linkage\\n\", sym_name, n1);\n\t\t\treturn false;\n\t\t}\n\n\t\tid1 = t1->type;\n\t\tid2 = t2->type;\n\t\tgoto recur;\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m1, *m2;\n\n\t\tif (!exact)\n\t\t\treturn true;\n\n\t\tif (btf_vlen(t1) != btf_vlen(t2)) {\n\t\t\tpr_warn(\"global '%s': incompatible number of %s fields %u and %u\\n\",\n\t\t\t\tsym_name, btf_kind_str(t1), btf_vlen(t1), btf_vlen(t2));\n\t\t\treturn false;\n\t\t}\n\n\t\tn = btf_vlen(t1);\n\t\tm1 = btf_members(t1);\n\t\tm2 = btf_members(t2);\n\t\tfor (i = 0; i < n; i++, m1++, m2++) {\n\t\t\tn1 = btf__str_by_offset(btf1, m1->name_off);\n\t\t\tn2 = btf__str_by_offset(btf2, m2->name_off);\n\t\t\tif (strcmp(n1, n2) != 0) {\n\t\t\t\tpr_warn(\"global '%s': incompatible field #%d names '%s' and '%s'\\n\",\n\t\t\t\t\tsym_name, i, n1, n2);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (m1->offset != m2->offset) {\n\t\t\t\tpr_warn(\"global '%s': incompatible field #%d ('%s') offsets\\n\",\n\t\t\t\t\tsym_name, i, n1);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!glob_sym_btf_matches(sym_name, exact, btf1, m1->type, btf2, m2->type))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *m1, *m2;\n\n\t\tif (btf_vlen(t1) != btf_vlen(t2)) {\n\t\t\tpr_warn(\"global '%s': incompatible number of %s params %u and %u\\n\",\n\t\t\t\tsym_name, btf_kind_str(t1), btf_vlen(t1), btf_vlen(t2));\n\t\t\treturn false;\n\t\t}\n\n\t\tn = btf_vlen(t1);\n\t\tm1 = btf_params(t1);\n\t\tm2 = btf_params(t2);\n\t\tfor (i = 0; i < n; i++, m1++, m2++) {\n\t\t\t \n\t\t\tif (!glob_sym_btf_matches(sym_name, exact, btf1, m1->type, btf2, m2->type))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tid1 = t1->type;\n\t\tid2 = t2->type;\n\t\tgoto recur;\n\t}\n\n\t \n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t \n\tcase BTF_KIND_DATASEC:\n\tdefault:\n\t\tpr_warn(\"global '%s': unsupported BTF kind %s\\n\",\n\t\t\tsym_name, btf_kind_str(t1));\n\t\treturn false;\n\t}\n}\n\nstatic bool map_defs_match(const char *sym_name,\n\t\t\t   const struct btf *main_btf,\n\t\t\t   const struct btf_map_def *main_def,\n\t\t\t   const struct btf_map_def *main_inner_def,\n\t\t\t   const struct btf *extra_btf,\n\t\t\t   const struct btf_map_def *extra_def,\n\t\t\t   const struct btf_map_def *extra_inner_def)\n{\n\tconst char *reason;\n\n\tif (main_def->map_type != extra_def->map_type) {\n\t\treason = \"type\";\n\t\tgoto mismatch;\n\t}\n\n\t \n\tif (main_def->key_size != extra_def->key_size) {\n\t\treason = \"key_size\";\n\t\tgoto mismatch;\n\t}\n\tif (!!main_def->key_type_id != !!extra_def->key_type_id) {\n\t\treason = \"key type\";\n\t\tgoto mismatch;\n\t}\n\tif ((main_def->parts & MAP_DEF_KEY_TYPE)\n\t     && !glob_sym_btf_matches(sym_name, true  ,\n\t\t\t\t      main_btf, main_def->key_type_id,\n\t\t\t\t      extra_btf, extra_def->key_type_id)) {\n\t\treason = \"key type\";\n\t\tgoto mismatch;\n\t}\n\n\t \n\tif (main_def->value_size != extra_def->value_size) {\n\t\treason = \"value_size\";\n\t\tgoto mismatch;\n\t}\n\tif (!!main_def->value_type_id != !!extra_def->value_type_id) {\n\t\treason = \"value type\";\n\t\tgoto mismatch;\n\t}\n\tif ((main_def->parts & MAP_DEF_VALUE_TYPE)\n\t     && !glob_sym_btf_matches(sym_name, true  ,\n\t\t\t\t      main_btf, main_def->value_type_id,\n\t\t\t\t      extra_btf, extra_def->value_type_id)) {\n\t\treason = \"key type\";\n\t\tgoto mismatch;\n\t}\n\n\tif (main_def->max_entries != extra_def->max_entries) {\n\t\treason = \"max_entries\";\n\t\tgoto mismatch;\n\t}\n\tif (main_def->map_flags != extra_def->map_flags) {\n\t\treason = \"map_flags\";\n\t\tgoto mismatch;\n\t}\n\tif (main_def->numa_node != extra_def->numa_node) {\n\t\treason = \"numa_node\";\n\t\tgoto mismatch;\n\t}\n\tif (main_def->pinning != extra_def->pinning) {\n\t\treason = \"pinning\";\n\t\tgoto mismatch;\n\t}\n\n\tif ((main_def->parts & MAP_DEF_INNER_MAP) != (extra_def->parts & MAP_DEF_INNER_MAP)) {\n\t\treason = \"inner map\";\n\t\tgoto mismatch;\n\t}\n\n\tif (main_def->parts & MAP_DEF_INNER_MAP) {\n\t\tchar inner_map_name[128];\n\n\t\tsnprintf(inner_map_name, sizeof(inner_map_name), \"%s.inner\", sym_name);\n\n\t\treturn map_defs_match(inner_map_name,\n\t\t\t\t      main_btf, main_inner_def, NULL,\n\t\t\t\t      extra_btf, extra_inner_def, NULL);\n\t}\n\n\treturn true;\n\nmismatch:\n\tpr_warn(\"global '%s': map %s mismatch\\n\", sym_name, reason);\n\treturn false;\n}\n\nstatic bool glob_map_defs_match(const char *sym_name,\n\t\t\t\tstruct bpf_linker *linker, struct glob_sym *glob_sym,\n\t\t\t\tstruct src_obj *obj, Elf64_Sym *sym, int btf_id)\n{\n\tstruct btf_map_def dst_def = {}, dst_inner_def = {};\n\tstruct btf_map_def src_def = {}, src_inner_def = {};\n\tconst struct btf_type *t;\n\tint err;\n\n\tt = btf__type_by_id(obj->btf, btf_id);\n\tif (!btf_is_var(t)) {\n\t\tpr_warn(\"global '%s': invalid map definition type [%d]\\n\", sym_name, btf_id);\n\t\treturn false;\n\t}\n\tt = skip_mods_and_typedefs(obj->btf, t->type, NULL);\n\n\terr = parse_btf_map_def(sym_name, obj->btf, t, true  , &src_def, &src_inner_def);\n\tif (err) {\n\t\tpr_warn(\"global '%s': invalid map definition\\n\", sym_name);\n\t\treturn false;\n\t}\n\n\t \n\tt = btf__type_by_id(linker->btf, glob_sym->btf_id);\n\tt = skip_mods_and_typedefs(linker->btf, t->type, NULL);\n\terr = parse_btf_map_def(sym_name, linker->btf, t, true  , &dst_def, &dst_inner_def);\n\tif (err) {\n\t\t \n\t\tpr_warn(\"global '%s': invalid dst map definition\\n\", sym_name);\n\t\treturn false;\n\t}\n\n\t \n\treturn map_defs_match(sym_name, linker->btf, &dst_def, &dst_inner_def,\n\t\t\t      obj->btf, &src_def, &src_inner_def);\n}\n\nstatic bool glob_syms_match(const char *sym_name,\n\t\t\t    struct bpf_linker *linker, struct glob_sym *glob_sym,\n\t\t\t    struct src_obj *obj, Elf64_Sym *sym, size_t sym_idx, int btf_id)\n{\n\tconst struct btf_type *src_t;\n\n\t \n\tif (!glob_sym->btf_id || !btf_id) {\n\t\tpr_warn(\"BTF info is missing for global symbol '%s'\\n\", sym_name);\n\t\treturn false;\n\t}\n\n\tsrc_t = btf__type_by_id(obj->btf, btf_id);\n\tif (!btf_is_var(src_t) && !btf_is_func(src_t)) {\n\t\tpr_warn(\"only extern variables and functions are supported, but got '%s' for '%s'\\n\",\n\t\t\tbtf_kind_str(src_t), sym_name);\n\t\treturn false;\n\t}\n\n\t \n\tif (glob_sym->sec_id && strcmp(linker->secs[glob_sym->sec_id].sec_name, MAPS_ELF_SEC) == 0)\n\t\treturn glob_map_defs_match(sym_name, linker, glob_sym, obj, sym, btf_id);\n\n\tif (!glob_sym_btf_matches(sym_name, true  ,\n\t\t\t\t  linker->btf, glob_sym->btf_id, obj->btf, btf_id))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool btf_is_non_static(const struct btf_type *t)\n{\n\treturn (btf_is_var(t) && btf_var(t)->linkage != BTF_VAR_STATIC)\n\t       || (btf_is_func(t) && btf_func_linkage(t) != BTF_FUNC_STATIC);\n}\n\nstatic int find_glob_sym_btf(struct src_obj *obj, Elf64_Sym *sym, const char *sym_name,\n\t\t\t     int *out_btf_sec_id, int *out_btf_id)\n{\n\tint i, j, n, m, btf_id = 0;\n\tconst struct btf_type *t;\n\tconst struct btf_var_secinfo *vi;\n\tconst char *name;\n\n\tif (!obj->btf) {\n\t\tpr_warn(\"failed to find BTF info for object '%s'\\n\", obj->filename);\n\t\treturn -EINVAL;\n\t}\n\n\tn = btf__type_cnt(obj->btf);\n\tfor (i = 1; i < n; i++) {\n\t\tt = btf__type_by_id(obj->btf, i);\n\n\t\t \n\t\tif (btf_is_non_static(t)) {\n\t\t\tname = btf__str_by_offset(obj->btf, t->name_off);\n\t\t\tif (strcmp(name, sym_name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tbtf_id = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!btf_is_datasec(t))\n\t\t\tcontinue;\n\n\t\tvi = btf_var_secinfos(t);\n\t\tfor (j = 0, m = btf_vlen(t); j < m; j++, vi++) {\n\t\t\tt = btf__type_by_id(obj->btf, vi->type);\n\t\t\tname = btf__str_by_offset(obj->btf, t->name_off);\n\n\t\t\tif (strcmp(name, sym_name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (btf_is_var(t) && btf_var(t)->linkage == BTF_VAR_STATIC)\n\t\t\t\tcontinue;\n\t\t\tif (btf_is_func(t) && btf_func_linkage(t) == BTF_FUNC_STATIC)\n\t\t\t\tcontinue;\n\n\t\t\tif (btf_id && btf_id != vi->type) {\n\t\t\t\tpr_warn(\"global/extern '%s' BTF is ambiguous: both types #%d and #%u match\\n\",\n\t\t\t\t\tsym_name, btf_id, vi->type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*out_btf_sec_id = i;\n\t\t\t*out_btf_id = vi->type;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (btf_id) {\n\t\t*out_btf_sec_id = 0;\n\t\t*out_btf_id = btf_id;\n\t\treturn 0;\n\t}\n\n\tpr_warn(\"failed to find BTF info for global/extern symbol '%s'\\n\", sym_name);\n\treturn -ENOENT;\n}\n\nstatic struct src_sec *find_src_sec_by_name(struct src_obj *obj, const char *sec_name)\n{\n\tstruct src_sec *sec;\n\tint i;\n\n\tfor (i = 1; i < obj->sec_cnt; i++) {\n\t\tsec = &obj->secs[i];\n\n\t\tif (strcmp(sec->sec_name, sec_name) == 0)\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;\n}\n\nstatic int complete_extern_btf_info(struct btf *dst_btf, int dst_id,\n\t\t\t\t    struct btf *src_btf, int src_id)\n{\n\tstruct btf_type *dst_t = btf_type_by_id(dst_btf, dst_id);\n\tstruct btf_type *src_t = btf_type_by_id(src_btf, src_id);\n\tstruct btf_param *src_p, *dst_p;\n\tconst char *s;\n\tint i, n, off;\n\n\t \n\tif (btf_is_var(dst_t)) {\n\t\tbtf_var(dst_t)->linkage = BTF_VAR_GLOBAL_ALLOCATED;\n\t\treturn 0;\n\t}\n\n\tdst_t->info = btf_type_info(BTF_KIND_FUNC, BTF_FUNC_GLOBAL, 0);\n\n\t \n\tsrc_t = btf_type_by_id(src_btf, src_t->type);\n\tdst_t = btf_type_by_id(dst_btf, dst_t->type);\n\n\t \n\tsrc_p = btf_params(src_t);\n\tdst_p = btf_params(dst_t);\n\tfor (i = 0, n = btf_vlen(dst_t); i < n; i++, src_p++, dst_p++) {\n\t\tif (!src_p->name_off)\n\t\t\tcontinue;\n\n\t\t \n\t\ts = btf__str_by_offset(src_btf, src_p->name_off);\n\t\toff = btf__add_str(dst_btf, s);\n\t\tif (off < 0)\n\t\t\treturn off;\n\t\tdst_p->name_off = off;\n\t}\n\treturn 0;\n}\n\nstatic void sym_update_bind(Elf64_Sym *sym, int sym_bind)\n{\n\tsym->st_info = ELF64_ST_INFO(sym_bind, ELF64_ST_TYPE(sym->st_info));\n}\n\nstatic void sym_update_type(Elf64_Sym *sym, int sym_type)\n{\n\tsym->st_info = ELF64_ST_INFO(ELF64_ST_BIND(sym->st_info), sym_type);\n}\n\nstatic void sym_update_visibility(Elf64_Sym *sym, int sym_vis)\n{\n\t \n\tsym->st_other &= ~0x03;\n\tsym->st_other |= sym_vis;\n}\n\nstatic int linker_append_elf_sym(struct bpf_linker *linker, struct src_obj *obj,\n\t\t\t\t Elf64_Sym *sym, const char *sym_name, int src_sym_idx)\n{\n\tstruct src_sec *src_sec = NULL;\n\tstruct dst_sec *dst_sec = NULL;\n\tstruct glob_sym *glob_sym = NULL;\n\tint name_off, sym_type, sym_bind, sym_vis, err;\n\tint btf_sec_id = 0, btf_id = 0;\n\tsize_t dst_sym_idx;\n\tElf64_Sym *dst_sym;\n\tbool sym_is_extern;\n\n\tsym_type = ELF64_ST_TYPE(sym->st_info);\n\tsym_bind = ELF64_ST_BIND(sym->st_info);\n\tsym_vis = ELF64_ST_VISIBILITY(sym->st_other);\n\tsym_is_extern = sym->st_shndx == SHN_UNDEF;\n\n\tif (sym_is_extern) {\n\t\tif (!obj->btf) {\n\t\t\tpr_warn(\"externs without BTF info are not supported\\n\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else if (sym->st_shndx < SHN_LORESERVE) {\n\t\tsrc_sec = &obj->secs[sym->st_shndx];\n\t\tif (src_sec->skipped)\n\t\t\treturn 0;\n\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\n\t\t \n\t\tif (sym_type == STT_SECTION && dst_sec->sec_sym_idx) {\n\t\t\tobj->sym_map[src_sym_idx] = dst_sec->sec_sym_idx;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (sym_bind == STB_LOCAL)\n\t\tgoto add_sym;\n\n\t \n\terr = find_glob_sym_btf(obj, sym, sym_name, &btf_sec_id, &btf_id);\n\tif (err)\n\t\treturn err;\n\n\tif (sym_is_extern && btf_sec_id) {\n\t\tconst char *sec_name = NULL;\n\t\tconst struct btf_type *t;\n\n\t\tt = btf__type_by_id(obj->btf, btf_sec_id);\n\t\tsec_name = btf__str_by_offset(obj->btf, t->name_off);\n\n\t\t \n\t\tif (strcmp(sec_name, BTF_EXTERN_SEC) != 0) {\n\t\t\tsrc_sec = find_src_sec_by_name(obj, sec_name);\n\t\t\tif (!src_sec) {\n\t\t\t\tpr_warn(\"failed to find matching ELF sec '%s'\\n\", sec_name);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\t\t}\n\t}\n\n\tglob_sym = find_glob_sym(linker, sym_name);\n\tif (glob_sym) {\n\t\t \n\t\tobj->sym_map[src_sym_idx] = glob_sym->sym_idx;\n\n\t\t \n\t\tif (!sym_is_extern && !glob_sym->is_extern\n\t\t    && !glob_sym->is_weak && sym_bind != STB_WEAK) {\n\t\t\tpr_warn(\"conflicting non-weak symbol #%d (%s) definition in '%s'\\n\",\n\t\t\t\tsrc_sym_idx, sym_name, obj->filename);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!glob_syms_match(sym_name, linker, glob_sym, obj, sym, src_sym_idx, btf_id))\n\t\t\treturn -EINVAL;\n\n\t\tdst_sym = get_sym_by_idx(linker, glob_sym->sym_idx);\n\n\t\t \n\t\tif (sym_bind == STB_GLOBAL) {\n\t\t\t \n\t\t\tsym_update_bind(dst_sym, STB_GLOBAL);\n\t\t\tglob_sym->is_weak = false;\n\t\t}\n\n\t\t \n\t\tif (sym_vis > ELF64_ST_VISIBILITY(dst_sym->st_other))\n\t\t\tsym_update_visibility(dst_sym, sym_vis);\n\n\t\t \n\t\tif (sym_is_extern)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!glob_sym->is_extern && sym_bind == STB_WEAK)\n\t\t\treturn 0;\n\n\t\t \n\t\tsym_update_type(dst_sym, sym_type);\n\t\tdst_sym->st_shndx = dst_sec->sec_idx;\n\t\tdst_sym->st_value = src_sec->dst_off + sym->st_value;\n\t\tdst_sym->st_size = sym->st_size;\n\n\t\t \n\t\tglob_sym->sec_id = dst_sec->id;\n\t\tglob_sym->is_extern = false;\n\n\t\tif (complete_extern_btf_info(linker->btf, glob_sym->btf_id,\n\t\t\t\t\t     obj->btf, btf_id))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tglob_sym->underlying_btf_id = 0;\n\n\t\tobj->sym_map[src_sym_idx] = glob_sym->sym_idx;\n\t\treturn 0;\n\t}\n\nadd_sym:\n\tname_off = strset__add_str(linker->strtab_strs, sym_name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tdst_sym = add_new_sym(linker, &dst_sym_idx);\n\tif (!dst_sym)\n\t\treturn -ENOMEM;\n\n\tdst_sym->st_name = name_off;\n\tdst_sym->st_info = sym->st_info;\n\tdst_sym->st_other = sym->st_other;\n\tdst_sym->st_shndx = dst_sec ? dst_sec->sec_idx : sym->st_shndx;\n\tdst_sym->st_value = (src_sec ? src_sec->dst_off : 0) + sym->st_value;\n\tdst_sym->st_size = sym->st_size;\n\n\tobj->sym_map[src_sym_idx] = dst_sym_idx;\n\n\tif (sym_type == STT_SECTION && dst_sym) {\n\t\tdst_sec->sec_sym_idx = dst_sym_idx;\n\t\tdst_sym->st_value = 0;\n\t}\n\n\tif (sym_bind != STB_LOCAL) {\n\t\tglob_sym = add_glob_sym(linker);\n\t\tif (!glob_sym)\n\t\t\treturn -ENOMEM;\n\n\t\tglob_sym->sym_idx = dst_sym_idx;\n\t\t \n\t\tglob_sym->sec_id = dst_sec ? dst_sec->id : 0;\n\t\tglob_sym->name_off = name_off;\n\t\t \n\t\tglob_sym->btf_id = 0;\n\t\tglob_sym->is_extern = sym_is_extern;\n\t\tglob_sym->is_weak = sym_bind == STB_WEAK;\n\t}\n\n\treturn 0;\n}\n\nstatic int linker_append_elf_relos(struct bpf_linker *linker, struct src_obj *obj)\n{\n\tstruct src_sec *src_symtab = &obj->secs[obj->symtab_sec_idx];\n\tint i, err;\n\n\tfor (i = 1; i < obj->sec_cnt; i++) {\n\t\tstruct src_sec *src_sec, *src_linked_sec;\n\t\tstruct dst_sec *dst_sec, *dst_linked_sec;\n\t\tElf64_Rel *src_rel, *dst_rel;\n\t\tint j, n;\n\n\t\tsrc_sec = &obj->secs[i];\n\t\tif (!is_relo_sec(src_sec))\n\t\t\tcontinue;\n\n\t\t \n\t\tsrc_linked_sec = &obj->secs[src_sec->shdr->sh_info];\n\t\tif (src_linked_sec->skipped)\n\t\t\tcontinue;\n\n\t\tdst_sec = find_dst_sec_by_name(linker, src_sec->sec_name);\n\t\tif (!dst_sec) {\n\t\t\tdst_sec = add_dst_sec(linker, src_sec->sec_name);\n\t\t\tif (!dst_sec)\n\t\t\t\treturn -ENOMEM;\n\t\t\terr = init_sec(linker, dst_sec, src_sec);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"failed to init section '%s'\\n\", src_sec->sec_name);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (!secs_match(dst_sec, src_sec)) {\n\t\t\tpr_warn(\"sections %s are not compatible\\n\", src_sec->sec_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tdst_sec->shdr->sh_link = linker->symtab_sec_idx;\n\n\t\t \n\t\tdst_linked_sec = &linker->secs[src_linked_sec->dst_id];\n\t\tdst_sec->shdr->sh_info = dst_linked_sec->sec_idx;\n\n\t\tsrc_sec->dst_id = dst_sec->id;\n\t\terr = extend_sec(linker, dst_sec, src_sec);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsrc_rel = src_sec->data->d_buf;\n\t\tdst_rel = dst_sec->raw_data + src_sec->dst_off;\n\t\tn = src_sec->shdr->sh_size / src_sec->shdr->sh_entsize;\n\t\tfor (j = 0; j < n; j++, src_rel++, dst_rel++) {\n\t\t\tsize_t src_sym_idx, dst_sym_idx, sym_type;\n\t\t\tElf64_Sym *src_sym;\n\n\t\t\tsrc_sym_idx = ELF64_R_SYM(src_rel->r_info);\n\t\t\tsrc_sym = src_symtab->data->d_buf + sizeof(*src_sym) * src_sym_idx;\n\n\t\t\tdst_sym_idx = obj->sym_map[src_sym_idx];\n\t\t\tdst_rel->r_offset += src_linked_sec->dst_off;\n\t\t\tsym_type = ELF64_R_TYPE(src_rel->r_info);\n\t\t\tdst_rel->r_info = ELF64_R_INFO(dst_sym_idx, sym_type);\n\n\t\t\tif (ELF64_ST_TYPE(src_sym->st_info) == STT_SECTION) {\n\t\t\t\tstruct src_sec *sec = &obj->secs[src_sym->st_shndx];\n\t\t\t\tstruct bpf_insn *insn;\n\n\t\t\t\tif (src_linked_sec->shdr->sh_flags & SHF_EXECINSTR) {\n\t\t\t\t\t \n\t\t\t\t\tinsn = dst_linked_sec->raw_data + dst_rel->r_offset;\n\t\t\t\t\tif (insn->code == (BPF_JMP | BPF_CALL))\n\t\t\t\t\t\tinsn->imm += sec->dst_off / sizeof(struct bpf_insn);\n\t\t\t\t\telse\n\t\t\t\t\t\tinsn->imm += sec->dst_off;\n\t\t\t\t} else {\n\t\t\t\t\tpr_warn(\"relocation against STT_SECTION in non-exec section is not supported!\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic Elf64_Sym *find_sym_by_name(struct src_obj *obj, size_t sec_idx,\n\t\t\t\t   int sym_type, const char *sym_name)\n{\n\tstruct src_sec *symtab = &obj->secs[obj->symtab_sec_idx];\n\tElf64_Sym *sym = symtab->data->d_buf;\n\tint i, n = symtab->shdr->sh_size / symtab->shdr->sh_entsize;\n\tint str_sec_idx = symtab->shdr->sh_link;\n\tconst char *name;\n\n\tfor (i = 0; i < n; i++, sym++) {\n\t\tif (sym->st_shndx != sec_idx)\n\t\t\tcontinue;\n\t\tif (ELF64_ST_TYPE(sym->st_info) != sym_type)\n\t\t\tcontinue;\n\n\t\tname = elf_strptr(obj->elf, str_sec_idx, sym->st_name);\n\t\tif (!name)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(sym_name, name) != 0)\n\t\t\tcontinue;\n\n\t\treturn sym;\n\t}\n\n\treturn NULL;\n}\n\nstatic int linker_fixup_btf(struct src_obj *obj)\n{\n\tconst char *sec_name;\n\tstruct src_sec *sec;\n\tint i, j, n, m;\n\n\tif (!obj->btf)\n\t\treturn 0;\n\n\tn = btf__type_cnt(obj->btf);\n\tfor (i = 1; i < n; i++) {\n\t\tstruct btf_var_secinfo *vi;\n\t\tstruct btf_type *t;\n\n\t\tt = btf_type_by_id(obj->btf, i);\n\t\tif (btf_kind(t) != BTF_KIND_DATASEC)\n\t\t\tcontinue;\n\n\t\tsec_name = btf__str_by_offset(obj->btf, t->name_off);\n\t\tsec = find_src_sec_by_name(obj, sec_name);\n\t\tif (sec) {\n\t\t\t \n\t\t\tif (sec->shdr)\n\t\t\t\tt->size = sec->shdr->sh_size;\n\t\t} else {\n\t\t\t \n\t\t\tif (strcmp(sec_name, BTF_EXTERN_SEC) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tsec = add_src_sec(obj, sec_name);\n\t\t\tif (!sec)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsec->ephemeral = true;\n\t\t\tsec->sec_idx = 0;  \n\t\t}\n\n\t\t \n\t\tsec->sec_type_id = i;\n\n\t\t \n\t\tvi = btf_var_secinfos(t);\n\t\tfor (j = 0, m = btf_vlen(t); j < m; j++, vi++) {\n\t\t\tconst struct btf_type *vt = btf__type_by_id(obj->btf, vi->type);\n\t\t\tconst char *var_name = btf__str_by_offset(obj->btf, vt->name_off);\n\t\t\tint var_linkage = btf_var(vt)->linkage;\n\t\t\tElf64_Sym *sym;\n\n\t\t\t \n\t\t\tif (var_linkage != BTF_VAR_GLOBAL_ALLOCATED)\n\t\t\t\tcontinue;\n\n\t\t\tsym = find_sym_by_name(obj, sec->sec_idx, STT_OBJECT, var_name);\n\t\t\tif (!sym) {\n\t\t\t\tpr_warn(\"failed to find symbol for variable '%s' in section '%s'\\n\", var_name, sec_name);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tvi->offset = sym->st_value;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int remap_type_id(__u32 *type_id, void *ctx)\n{\n\tint *id_map = ctx;\n\tint new_id = id_map[*type_id];\n\n\t \n\tif (new_id == 0 && *type_id != 0) {\n\t\tpr_warn(\"failed to find new ID mapping for original BTF type ID %u\\n\", *type_id);\n\t\treturn -EINVAL;\n\t}\n\n\t*type_id = id_map[*type_id];\n\n\treturn 0;\n}\n\nstatic int linker_append_btf(struct bpf_linker *linker, struct src_obj *obj)\n{\n\tconst struct btf_type *t;\n\tint i, j, n, start_id, id;\n\tconst char *name;\n\n\tif (!obj->btf)\n\t\treturn 0;\n\n\tstart_id = btf__type_cnt(linker->btf);\n\tn = btf__type_cnt(obj->btf);\n\n\tobj->btf_type_map = calloc(n + 1, sizeof(int));\n\tif (!obj->btf_type_map)\n\t\treturn -ENOMEM;\n\n\tfor (i = 1; i < n; i++) {\n\t\tstruct glob_sym *glob_sym = NULL;\n\n\t\tt = btf__type_by_id(obj->btf, i);\n\n\t\t \n\t\tif (btf_kind(t) == BTF_KIND_DATASEC)\n\t\t\tcontinue;\n\n\t\tif (btf_is_non_static(t)) {\n\t\t\t \n\t\t\tname = btf__str_by_offset(obj->btf, t->name_off);\n\t\t\tglob_sym = find_glob_sym(linker, name);\n\n\t\t\t \n\t\t\tif (!glob_sym)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (glob_sym->underlying_btf_id == 0)\n\t\t\t\tglob_sym->underlying_btf_id = -t->type;\n\n\t\t\t \n\t\t\tif (glob_sym->btf_id) {\n\t\t\t\t \n\t\t\t\tobj->btf_type_map[i] = glob_sym->btf_id;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tid = btf__add_type(linker->btf, obj->btf, t);\n\t\tif (id < 0) {\n\t\t\tpr_warn(\"failed to append BTF type #%d from file '%s'\\n\", i, obj->filename);\n\t\t\treturn id;\n\t\t}\n\n\t\tobj->btf_type_map[i] = id;\n\n\t\t \n\t\tif (glob_sym) {\n\t\t\tglob_sym->btf_id = id;\n\t\t\tglob_sym->underlying_btf_id = -t->type;\n\t\t}\n\t}\n\n\t \n\tn = btf__type_cnt(linker->btf);\n\tfor (i = start_id; i < n; i++) {\n\t\tstruct btf_type *dst_t = btf_type_by_id(linker->btf, i);\n\n\t\tif (btf_type_visit_type_ids(dst_t, remap_type_id, obj->btf_type_map))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < linker->glob_sym_cnt; i++) {\n\t\tstruct glob_sym *glob_sym = &linker->glob_syms[i];\n\t\tstruct btf_type *glob_t;\n\n\t\tif (glob_sym->underlying_btf_id >= 0)\n\t\t\tcontinue;\n\n\t\tglob_sym->underlying_btf_id = obj->btf_type_map[-glob_sym->underlying_btf_id];\n\n\t\tglob_t = btf_type_by_id(linker->btf, glob_sym->btf_id);\n\t\tglob_t->type = glob_sym->underlying_btf_id;\n\t}\n\n\t \n\tfor (i = 1; i < obj->sec_cnt; i++) {\n\t\tstruct src_sec *src_sec;\n\t\tstruct dst_sec *dst_sec;\n\t\tconst struct btf_var_secinfo *src_var;\n\t\tstruct btf_var_secinfo *dst_var;\n\n\t\tsrc_sec = &obj->secs[i];\n\t\tif (!src_sec->sec_type_id || src_sec->skipped)\n\t\t\tcontinue;\n\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\n\t\t \n\t\tdst_sec->has_btf = true;\n\n\t\tt = btf__type_by_id(obj->btf, src_sec->sec_type_id);\n\t\tsrc_var = btf_var_secinfos(t);\n\t\tn = btf_vlen(t);\n\t\tfor (j = 0; j < n; j++, src_var++) {\n\t\t\tvoid *sec_vars = dst_sec->sec_vars;\n\t\t\tint new_id = obj->btf_type_map[src_var->type];\n\t\t\tstruct glob_sym *glob_sym = NULL;\n\n\t\t\tt = btf_type_by_id(linker->btf, new_id);\n\t\t\tif (btf_is_non_static(t)) {\n\t\t\t\tname = btf__str_by_offset(linker->btf, t->name_off);\n\t\t\t\tglob_sym = find_glob_sym(linker, name);\n\t\t\t\tif (glob_sym->sec_id != dst_sec->id) {\n\t\t\t\t\tpr_warn(\"global '%s': section mismatch %d vs %d\\n\",\n\t\t\t\t\t\tname, glob_sym->sec_id, dst_sec->id);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (glob_sym && glob_sym->var_idx >= 0) {\n\t\t\t\t__s64 sz;\n\n\t\t\t\tdst_var = &dst_sec->sec_vars[glob_sym->var_idx];\n\t\t\t\t \n\t\t\t\tsz = btf__resolve_size(linker->btf, glob_sym->underlying_btf_id);\n\t\t\t\tif (sz < 0) {\n\t\t\t\t\tpr_warn(\"global '%s': failed to resolve size of underlying type: %d\\n\",\n\t\t\t\t\t\tname, (int)sz);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdst_var->size = sz;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsec_vars = libbpf_reallocarray(sec_vars,\n\t\t\t\t\t\t       dst_sec->sec_var_cnt + 1,\n\t\t\t\t\t\t       sizeof(*dst_sec->sec_vars));\n\t\t\tif (!sec_vars)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdst_sec->sec_vars = sec_vars;\n\t\t\tdst_sec->sec_var_cnt++;\n\n\t\t\tdst_var = &dst_sec->sec_vars[dst_sec->sec_var_cnt - 1];\n\t\t\tdst_var->type = obj->btf_type_map[src_var->type];\n\t\t\tdst_var->size = src_var->size;\n\t\t\tdst_var->offset = src_sec->dst_off + src_var->offset;\n\n\t\t\tif (glob_sym)\n\t\t\t\tglob_sym->var_idx = dst_sec->sec_var_cnt - 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void *add_btf_ext_rec(struct btf_ext_sec_data *ext_data, const void *src_rec)\n{\n\tvoid *tmp;\n\n\ttmp = libbpf_reallocarray(ext_data->recs, ext_data->rec_cnt + 1, ext_data->rec_sz);\n\tif (!tmp)\n\t\treturn NULL;\n\text_data->recs = tmp;\n\n\ttmp += ext_data->rec_cnt * ext_data->rec_sz;\n\tmemcpy(tmp, src_rec, ext_data->rec_sz);\n\n\text_data->rec_cnt++;\n\n\treturn tmp;\n}\n\nstatic int linker_append_btf_ext(struct bpf_linker *linker, struct src_obj *obj)\n{\n\tconst struct btf_ext_info_sec *ext_sec;\n\tconst char *sec_name, *s;\n\tstruct src_sec *src_sec;\n\tstruct dst_sec *dst_sec;\n\tint rec_sz, str_off, i;\n\n\tif (!obj->btf_ext)\n\t\treturn 0;\n\n\trec_sz = obj->btf_ext->func_info.rec_size;\n\tfor_each_btf_ext_sec(&obj->btf_ext->func_info, ext_sec) {\n\t\tstruct bpf_func_info_min *src_rec, *dst_rec;\n\n\t\tsec_name = btf__name_by_offset(obj->btf, ext_sec->sec_name_off);\n\t\tsrc_sec = find_src_sec_by_name(obj, sec_name);\n\t\tif (!src_sec) {\n\t\t\tpr_warn(\"can't find section '%s' referenced from .BTF.ext\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\n\t\tif (dst_sec->func_info.rec_sz == 0)\n\t\t\tdst_sec->func_info.rec_sz = rec_sz;\n\t\tif (dst_sec->func_info.rec_sz != rec_sz) {\n\t\t\tpr_warn(\"incompatible .BTF.ext record sizes for section '%s'\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor_each_btf_ext_rec(&obj->btf_ext->func_info, ext_sec, i, src_rec) {\n\t\t\tdst_rec = add_btf_ext_rec(&dst_sec->func_info, src_rec);\n\t\t\tif (!dst_rec)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdst_rec->insn_off += src_sec->dst_off;\n\t\t\tdst_rec->type_id = obj->btf_type_map[dst_rec->type_id];\n\t\t}\n\t}\n\n\trec_sz = obj->btf_ext->line_info.rec_size;\n\tfor_each_btf_ext_sec(&obj->btf_ext->line_info, ext_sec) {\n\t\tstruct bpf_line_info_min *src_rec, *dst_rec;\n\n\t\tsec_name = btf__name_by_offset(obj->btf, ext_sec->sec_name_off);\n\t\tsrc_sec = find_src_sec_by_name(obj, sec_name);\n\t\tif (!src_sec) {\n\t\t\tpr_warn(\"can't find section '%s' referenced from .BTF.ext\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\n\t\tif (dst_sec->line_info.rec_sz == 0)\n\t\t\tdst_sec->line_info.rec_sz = rec_sz;\n\t\tif (dst_sec->line_info.rec_sz != rec_sz) {\n\t\t\tpr_warn(\"incompatible .BTF.ext record sizes for section '%s'\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor_each_btf_ext_rec(&obj->btf_ext->line_info, ext_sec, i, src_rec) {\n\t\t\tdst_rec = add_btf_ext_rec(&dst_sec->line_info, src_rec);\n\t\t\tif (!dst_rec)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdst_rec->insn_off += src_sec->dst_off;\n\n\t\t\ts = btf__str_by_offset(obj->btf, src_rec->file_name_off);\n\t\t\tstr_off = btf__add_str(linker->btf, s);\n\t\t\tif (str_off < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_rec->file_name_off = str_off;\n\n\t\t\ts = btf__str_by_offset(obj->btf, src_rec->line_off);\n\t\t\tstr_off = btf__add_str(linker->btf, s);\n\t\t\tif (str_off < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_rec->line_off = str_off;\n\n\t\t\t \n\t\t}\n\t}\n\n\trec_sz = obj->btf_ext->core_relo_info.rec_size;\n\tfor_each_btf_ext_sec(&obj->btf_ext->core_relo_info, ext_sec) {\n\t\tstruct bpf_core_relo *src_rec, *dst_rec;\n\n\t\tsec_name = btf__name_by_offset(obj->btf, ext_sec->sec_name_off);\n\t\tsrc_sec = find_src_sec_by_name(obj, sec_name);\n\t\tif (!src_sec) {\n\t\t\tpr_warn(\"can't find section '%s' referenced from .BTF.ext\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdst_sec = &linker->secs[src_sec->dst_id];\n\n\t\tif (dst_sec->core_relo_info.rec_sz == 0)\n\t\t\tdst_sec->core_relo_info.rec_sz = rec_sz;\n\t\tif (dst_sec->core_relo_info.rec_sz != rec_sz) {\n\t\t\tpr_warn(\"incompatible .BTF.ext record sizes for section '%s'\\n\", sec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor_each_btf_ext_rec(&obj->btf_ext->core_relo_info, ext_sec, i, src_rec) {\n\t\t\tdst_rec = add_btf_ext_rec(&dst_sec->core_relo_info, src_rec);\n\t\t\tif (!dst_rec)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdst_rec->insn_off += src_sec->dst_off;\n\t\t\tdst_rec->type_id = obj->btf_type_map[dst_rec->type_id];\n\n\t\t\ts = btf__str_by_offset(obj->btf, src_rec->access_str_off);\n\t\t\tstr_off = btf__add_str(linker->btf, s);\n\t\t\tif (str_off < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_rec->access_str_off = str_off;\n\n\t\t\t \n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint bpf_linker__finalize(struct bpf_linker *linker)\n{\n\tstruct dst_sec *sec;\n\tsize_t strs_sz;\n\tconst void *strs;\n\tint err, i;\n\n\tif (!linker->elf)\n\t\treturn libbpf_err(-EINVAL);\n\n\terr = finalize_btf(linker);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\t \n\tstrs_sz = strset__data_size(linker->strtab_strs);\n\tstrs = strset__data(linker->strtab_strs);\n\n\tsec = &linker->secs[linker->strtab_sec_idx];\n\tsec->data->d_align = 1;\n\tsec->data->d_off = 0LL;\n\tsec->data->d_buf = (void *)strs;\n\tsec->data->d_type = ELF_T_BYTE;\n\tsec->data->d_size = strs_sz;\n\tsec->shdr->sh_size = strs_sz;\n\n\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\tsec = &linker->secs[i];\n\n\t\t \n\t\tif (sec->sec_idx == linker->strtab_sec_idx)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!sec->scn)\n\t\t\tcontinue;\n\n\t\tsec->data->d_buf = sec->raw_data;\n\t}\n\n\t \n\tif (elf_update(linker->elf, ELF_C_NULL) < 0) {\n\t\terr = -errno;\n\t\tpr_warn_elf(\"failed to finalize ELF layout\");\n\t\treturn libbpf_err(err);\n\t}\n\n\t \n\tif (elf_update(linker->elf, ELF_C_WRITE) < 0) {\n\t\terr = -errno;\n\t\tpr_warn_elf(\"failed to write ELF contents\");\n\t\treturn libbpf_err(err);\n\t}\n\n\telf_end(linker->elf);\n\tclose(linker->fd);\n\n\tlinker->elf = NULL;\n\tlinker->fd = -1;\n\n\treturn 0;\n}\n\nstatic int emit_elf_data_sec(struct bpf_linker *linker, const char *sec_name,\n\t\t\t     size_t align, const void *raw_data, size_t raw_sz)\n{\n\tElf_Scn *scn;\n\tElf_Data *data;\n\tElf64_Shdr *shdr;\n\tint name_off;\n\n\tname_off = strset__add_str(linker->strtab_strs, sec_name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tscn = elf_newscn(linker->elf);\n\tif (!scn)\n\t\treturn -ENOMEM;\n\tdata = elf_newdata(scn);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tshdr = elf64_getshdr(scn);\n\tif (!shdr)\n\t\treturn -EINVAL;\n\n\tshdr->sh_name = name_off;\n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_flags = 0;\n\tshdr->sh_size = raw_sz;\n\tshdr->sh_link = 0;\n\tshdr->sh_info = 0;\n\tshdr->sh_addralign = align;\n\tshdr->sh_entsize = 0;\n\n\tdata->d_type = ELF_T_BYTE;\n\tdata->d_size = raw_sz;\n\tdata->d_buf = (void *)raw_data;\n\tdata->d_align = align;\n\tdata->d_off = 0;\n\n\treturn 0;\n}\n\nstatic int finalize_btf(struct bpf_linker *linker)\n{\n\tLIBBPF_OPTS(btf_dedup_opts, opts);\n\tstruct btf *btf = linker->btf;\n\tconst void *raw_data;\n\tint i, j, id, err;\n\t__u32 raw_sz;\n\n\t \n\tif (btf__type_cnt(linker->btf) == 1)\n\t\treturn 0;\n\n\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\tif (!sec->has_btf)\n\t\t\tcontinue;\n\n\t\tid = btf__add_datasec(btf, sec->sec_name, sec->sec_sz);\n\t\tif (id < 0) {\n\t\t\tpr_warn(\"failed to add consolidated BTF type for datasec '%s': %d\\n\",\n\t\t\t\tsec->sec_name, id);\n\t\t\treturn id;\n\t\t}\n\n\t\tfor (j = 0; j < sec->sec_var_cnt; j++) {\n\t\t\tstruct btf_var_secinfo *vi = &sec->sec_vars[j];\n\n\t\t\tif (btf__add_datasec_var_info(btf, vi->type, vi->offset, vi->size))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = finalize_btf_ext(linker);\n\tif (err) {\n\t\tpr_warn(\".BTF.ext generation failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\topts.btf_ext = linker->btf_ext;\n\terr = btf__dedup(linker->btf, &opts);\n\tif (err) {\n\t\tpr_warn(\"BTF dedup failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\traw_data = btf__raw_data(linker->btf, &raw_sz);\n\tif (!raw_data)\n\t\treturn -ENOMEM;\n\n\terr = emit_elf_data_sec(linker, BTF_ELF_SEC, 8, raw_data, raw_sz);\n\tif (err) {\n\t\tpr_warn(\"failed to write out .BTF ELF section: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (linker->btf_ext) {\n\t\traw_data = btf_ext__get_raw_data(linker->btf_ext, &raw_sz);\n\t\tif (!raw_data)\n\t\t\treturn -ENOMEM;\n\n\t\terr = emit_elf_data_sec(linker, BTF_EXT_ELF_SEC, 8, raw_data, raw_sz);\n\t\tif (err) {\n\t\t\tpr_warn(\"failed to write out .BTF.ext ELF section: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emit_btf_ext_data(struct bpf_linker *linker, void *output,\n\t\t\t     const char *sec_name, struct btf_ext_sec_data *sec_data)\n{\n\tstruct btf_ext_info_sec *sec_info;\n\tvoid *cur = output;\n\tint str_off;\n\tsize_t sz;\n\n\tif (!sec_data->rec_cnt)\n\t\treturn 0;\n\n\tstr_off = btf__add_str(linker->btf, sec_name);\n\tif (str_off < 0)\n\t\treturn -ENOMEM;\n\n\tsec_info = cur;\n\tsec_info->sec_name_off = str_off;\n\tsec_info->num_info = sec_data->rec_cnt;\n\tcur += sizeof(struct btf_ext_info_sec);\n\n\tsz = sec_data->rec_cnt * sec_data->rec_sz;\n\tmemcpy(cur, sec_data->recs, sz);\n\tcur += sz;\n\n\treturn cur - output;\n}\n\nstatic int finalize_btf_ext(struct bpf_linker *linker)\n{\n\tsize_t funcs_sz = 0, lines_sz = 0, core_relos_sz = 0, total_sz = 0;\n\tsize_t func_rec_sz = 0, line_rec_sz = 0, core_relo_rec_sz = 0;\n\tstruct btf_ext_header *hdr;\n\tvoid *data, *cur;\n\tint i, err, sz;\n\n\t \n\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\tif (sec->func_info.rec_cnt) {\n\t\t\tif (func_rec_sz == 0)\n\t\t\t\tfunc_rec_sz = sec->func_info.rec_sz;\n\t\t\tif (func_rec_sz != sec->func_info.rec_sz) {\n\t\t\t\tpr_warn(\"mismatch in func_info record size %zu != %u\\n\",\n\t\t\t\t\tfunc_rec_sz, sec->func_info.rec_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfuncs_sz += sizeof(struct btf_ext_info_sec) + func_rec_sz * sec->func_info.rec_cnt;\n\t\t}\n\t\tif (sec->line_info.rec_cnt) {\n\t\t\tif (line_rec_sz == 0)\n\t\t\t\tline_rec_sz = sec->line_info.rec_sz;\n\t\t\tif (line_rec_sz != sec->line_info.rec_sz) {\n\t\t\t\tpr_warn(\"mismatch in line_info record size %zu != %u\\n\",\n\t\t\t\t\tline_rec_sz, sec->line_info.rec_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlines_sz += sizeof(struct btf_ext_info_sec) + line_rec_sz * sec->line_info.rec_cnt;\n\t\t}\n\t\tif (sec->core_relo_info.rec_cnt) {\n\t\t\tif (core_relo_rec_sz == 0)\n\t\t\t\tcore_relo_rec_sz = sec->core_relo_info.rec_sz;\n\t\t\tif (core_relo_rec_sz != sec->core_relo_info.rec_sz) {\n\t\t\t\tpr_warn(\"mismatch in core_relo_info record size %zu != %u\\n\",\n\t\t\t\t\tcore_relo_rec_sz, sec->core_relo_info.rec_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcore_relos_sz += sizeof(struct btf_ext_info_sec) + core_relo_rec_sz * sec->core_relo_info.rec_cnt;\n\t\t}\n\t}\n\n\tif (!funcs_sz && !lines_sz && !core_relos_sz)\n\t\treturn 0;\n\n\ttotal_sz += sizeof(struct btf_ext_header);\n\tif (funcs_sz) {\n\t\tfuncs_sz += sizeof(__u32);  \n\t\ttotal_sz += funcs_sz;\n\t}\n\tif (lines_sz) {\n\t\tlines_sz += sizeof(__u32);  \n\t\ttotal_sz += lines_sz;\n\t}\n\tif (core_relos_sz) {\n\t\tcore_relos_sz += sizeof(__u32);  \n\t\ttotal_sz += core_relos_sz;\n\t}\n\n\tcur = data = calloc(1, total_sz);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\thdr = cur;\n\thdr->magic = BTF_MAGIC;\n\thdr->version = BTF_VERSION;\n\thdr->flags = 0;\n\thdr->hdr_len = sizeof(struct btf_ext_header);\n\tcur += sizeof(struct btf_ext_header);\n\n\t \n\thdr->func_info_off = 0;\n\thdr->func_info_len = funcs_sz;\n\thdr->line_info_off = funcs_sz;\n\thdr->line_info_len = lines_sz;\n\thdr->core_relo_off = funcs_sz + lines_sz;\n\thdr->core_relo_len = core_relos_sz;\n\n\tif (funcs_sz) {\n\t\t*(__u32 *)cur = func_rec_sz;\n\t\tcur += sizeof(__u32);\n\n\t\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\t\tsz = emit_btf_ext_data(linker, cur, sec->sec_name, &sec->func_info);\n\t\t\tif (sz < 0) {\n\t\t\t\terr = sz;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcur += sz;\n\t\t}\n\t}\n\n\tif (lines_sz) {\n\t\t*(__u32 *)cur = line_rec_sz;\n\t\tcur += sizeof(__u32);\n\n\t\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\t\tsz = emit_btf_ext_data(linker, cur, sec->sec_name, &sec->line_info);\n\t\t\tif (sz < 0) {\n\t\t\t\terr = sz;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcur += sz;\n\t\t}\n\t}\n\n\tif (core_relos_sz) {\n\t\t*(__u32 *)cur = core_relo_rec_sz;\n\t\tcur += sizeof(__u32);\n\n\t\tfor (i = 1; i < linker->sec_cnt; i++) {\n\t\t\tstruct dst_sec *sec = &linker->secs[i];\n\n\t\t\tsz = emit_btf_ext_data(linker, cur, sec->sec_name, &sec->core_relo_info);\n\t\t\tif (sz < 0) {\n\t\t\t\terr = sz;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcur += sz;\n\t\t}\n\t}\n\n\tlinker->btf_ext = btf_ext__new(data, total_sz);\n\terr = libbpf_get_error(linker->btf_ext);\n\tif (err) {\n\t\tlinker->btf_ext = NULL;\n\t\tpr_warn(\"failed to parse final .BTF.ext data: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tfree(data);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}