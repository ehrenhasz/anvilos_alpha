{
  "module_name": "nlattr.h",
  "hash_id": "7d773a2eae482de9c98376cc2e7fe52d8af87f28e3e21b0be885e15e609b5a7c",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/nlattr.h",
  "human_readable_source": " \n\n \n\n#ifndef __LIBBPF_NLATTR_H\n#define __LIBBPF_NLATTR_H\n\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n\n \n#define __LINUX_NETLINK_H\n\n \nenum {\n\tLIBBPF_NLA_UNSPEC,\t \n\tLIBBPF_NLA_U8,\t\t \n\tLIBBPF_NLA_U16,\t\t \n\tLIBBPF_NLA_U32,\t\t \n\tLIBBPF_NLA_U64,\t\t \n\tLIBBPF_NLA_STRING,\t \n\tLIBBPF_NLA_FLAG,\t \n\tLIBBPF_NLA_MSECS,\t \n\tLIBBPF_NLA_NESTED,\t \n\t__LIBBPF_NLA_TYPE_MAX,\n};\n\n#define LIBBPF_NLA_TYPE_MAX (__LIBBPF_NLA_TYPE_MAX - 1)\n\n \nstruct libbpf_nla_policy {\n\t \n\tuint16_t\ttype;\n\n\t \n\tuint16_t\tminlen;\n\n\t \n\tuint16_t\tmaxlen;\n};\n\nstruct libbpf_nla_req {\n\tstruct nlmsghdr nh;\n\tunion {\n\t\tstruct ifinfomsg ifinfo;\n\t\tstruct tcmsg tc;\n\t\tstruct genlmsghdr gnl;\n\t};\n\tchar buf[128];\n};\n\n \n#define libbpf_nla_for_each_attr(pos, head, len, rem) \\\n\tfor (pos = head, rem = len; \\\n\t     nla_ok(pos, rem); \\\n\t     pos = nla_next(pos, &(rem)))\n\n \nstatic inline void *libbpf_nla_data(const struct nlattr *nla)\n{\n\treturn (void *)nla + NLA_HDRLEN;\n}\n\nstatic inline uint8_t libbpf_nla_getattr_u8(const struct nlattr *nla)\n{\n\treturn *(uint8_t *)libbpf_nla_data(nla);\n}\n\nstatic inline uint16_t libbpf_nla_getattr_u16(const struct nlattr *nla)\n{\n\treturn *(uint16_t *)libbpf_nla_data(nla);\n}\n\nstatic inline uint32_t libbpf_nla_getattr_u32(const struct nlattr *nla)\n{\n\treturn *(uint32_t *)libbpf_nla_data(nla);\n}\n\nstatic inline uint64_t libbpf_nla_getattr_u64(const struct nlattr *nla)\n{\n\treturn *(uint64_t *)libbpf_nla_data(nla);\n}\n\nstatic inline const char *libbpf_nla_getattr_str(const struct nlattr *nla)\n{\n\treturn (const char *)libbpf_nla_data(nla);\n}\n\n \nstatic inline int libbpf_nla_len(const struct nlattr *nla)\n{\n\treturn nla->nla_len - NLA_HDRLEN;\n}\n\nint libbpf_nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head,\n\t\t     int len, struct libbpf_nla_policy *policy);\nint libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,\n\t\t\t    struct nlattr *nla,\n\t\t\t    struct libbpf_nla_policy *policy);\n\nint libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);\n\nstatic inline struct nlattr *nla_data(struct nlattr *nla)\n{\n\treturn (struct nlattr *)((void *)nla + NLA_HDRLEN);\n}\n\nstatic inline struct nlattr *req_tail(struct libbpf_nla_req *req)\n{\n\treturn (struct nlattr *)((void *)req + NLMSG_ALIGN(req->nh.nlmsg_len));\n}\n\nstatic inline int nlattr_add(struct libbpf_nla_req *req, int type,\n\t\t\t     const void *data, int len)\n{\n\tstruct nlattr *nla;\n\n\tif (NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(NLA_HDRLEN + len) > sizeof(*req))\n\t\treturn -EMSGSIZE;\n\tif (!!data != !!len)\n\t\treturn -EINVAL;\n\n\tnla = req_tail(req);\n\tnla->nla_type = type;\n\tnla->nla_len = NLA_HDRLEN + len;\n\tif (data)\n\t\tmemcpy(nla_data(nla), data, len);\n\treq->nh.nlmsg_len = NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(nla->nla_len);\n\treturn 0;\n}\n\nstatic inline struct nlattr *nlattr_begin_nested(struct libbpf_nla_req *req, int type)\n{\n\tstruct nlattr *tail;\n\n\ttail = req_tail(req);\n\tif (nlattr_add(req, type | NLA_F_NESTED, NULL, 0))\n\t\treturn NULL;\n\treturn tail;\n}\n\nstatic inline void nlattr_end_nested(struct libbpf_nla_req *req,\n\t\t\t\t     struct nlattr *tail)\n{\n\ttail->nla_len = (void *)req_tail(req) - (void *)tail;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}