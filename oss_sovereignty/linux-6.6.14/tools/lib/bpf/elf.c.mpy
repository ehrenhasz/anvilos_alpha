{
  "module_name": "elf.c",
  "hash_id": "34135a46f366d4cbb24860a6c355b4a7195e44d04d63c3163332d6844424b327",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/elf.c",
  "human_readable_source": "\n\n#include <libelf.h>\n#include <gelf.h>\n#include <fcntl.h>\n#include <linux/kernel.h>\n\n#include \"libbpf_internal.h\"\n#include \"str_error.h\"\n\n#define STRERR_BUFSIZE  128\n\nint elf_open(const char *binary_path, struct elf_fd *elf_fd)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tint fd, ret;\n\tElf *elf;\n\n\tif (elf_version(EV_CURRENT) == EV_NONE) {\n\t\tpr_warn(\"elf: failed to init libelf for %s\\n\", binary_path);\n\t\treturn -LIBBPF_ERRNO__LIBELF;\n\t}\n\tfd = open(binary_path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tret = -errno;\n\t\tpr_warn(\"elf: failed to open %s: %s\\n\", binary_path,\n\t\t\tlibbpf_strerror_r(ret, errmsg, sizeof(errmsg)));\n\t\treturn ret;\n\t}\n\telf = elf_begin(fd, ELF_C_READ_MMAP, NULL);\n\tif (!elf) {\n\t\tpr_warn(\"elf: could not read elf from %s: %s\\n\", binary_path, elf_errmsg(-1));\n\t\tclose(fd);\n\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t}\n\telf_fd->fd = fd;\n\telf_fd->elf = elf;\n\treturn 0;\n}\n\nvoid elf_close(struct elf_fd *elf_fd)\n{\n\tif (!elf_fd)\n\t\treturn;\n\telf_end(elf_fd->elf);\n\tclose(elf_fd->fd);\n}\n\n \nstatic Elf_Scn *elf_find_next_scn_by_type(Elf *elf, int sh_type, Elf_Scn *scn)\n{\n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tGElf_Shdr sh;\n\n\t\tif (!gelf_getshdr(scn, &sh))\n\t\t\tcontinue;\n\t\tif (sh.sh_type == sh_type)\n\t\t\treturn scn;\n\t}\n\treturn NULL;\n}\n\nstruct elf_sym {\n\tconst char *name;\n\tGElf_Sym sym;\n\tGElf_Shdr sh;\n};\n\nstruct elf_sym_iter {\n\tElf *elf;\n\tElf_Data *syms;\n\tsize_t nr_syms;\n\tsize_t strtabidx;\n\tsize_t next_sym_idx;\n\tstruct elf_sym sym;\n\tint st_type;\n};\n\nstatic int elf_sym_iter_new(struct elf_sym_iter *iter,\n\t\t\t    Elf *elf, const char *binary_path,\n\t\t\t    int sh_type, int st_type)\n{\n\tElf_Scn *scn = NULL;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr sh;\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tif (!gelf_getehdr(elf, &ehdr)) {\n\t\tpr_warn(\"elf: failed to get ehdr from %s: %s\\n\", binary_path, elf_errmsg(-1));\n\t\treturn -EINVAL;\n\t}\n\n\tscn = elf_find_next_scn_by_type(elf, sh_type, NULL);\n\tif (!scn) {\n\t\tpr_debug(\"elf: failed to find symbol table ELF sections in '%s'\\n\",\n\t\t\t binary_path);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!gelf_getshdr(scn, &sh))\n\t\treturn -EINVAL;\n\n\titer->strtabidx = sh.sh_link;\n\titer->syms = elf_getdata(scn, 0);\n\tif (!iter->syms) {\n\t\tpr_warn(\"elf: failed to get symbols for symtab section in '%s': %s\\n\",\n\t\t\tbinary_path, elf_errmsg(-1));\n\t\treturn -EINVAL;\n\t}\n\titer->nr_syms = iter->syms->d_size / sh.sh_entsize;\n\titer->elf = elf;\n\titer->st_type = st_type;\n\treturn 0;\n}\n\nstatic struct elf_sym *elf_sym_iter_next(struct elf_sym_iter *iter)\n{\n\tstruct elf_sym *ret = &iter->sym;\n\tGElf_Sym *sym = &ret->sym;\n\tconst char *name = NULL;\n\tElf_Scn *sym_scn;\n\tsize_t idx;\n\n\tfor (idx = iter->next_sym_idx; idx < iter->nr_syms; idx++) {\n\t\tif (!gelf_getsym(iter->syms, idx, sym))\n\t\t\tcontinue;\n\t\tif (GELF_ST_TYPE(sym->st_info) != iter->st_type)\n\t\t\tcontinue;\n\t\tname = elf_strptr(iter->elf, iter->strtabidx, sym->st_name);\n\t\tif (!name)\n\t\t\tcontinue;\n\t\tsym_scn = elf_getscn(iter->elf, sym->st_shndx);\n\t\tif (!sym_scn)\n\t\t\tcontinue;\n\t\tif (!gelf_getshdr(sym_scn, &ret->sh))\n\t\t\tcontinue;\n\n\t\titer->next_sym_idx = idx + 1;\n\t\tret->name = name;\n\t\treturn ret;\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic unsigned long elf_sym_offset(struct elf_sym *sym)\n{\n\treturn sym->sym.st_value - sym->sh.sh_addr + sym->sh.sh_offset;\n}\n\n \nlong elf_find_func_offset(Elf *elf, const char *binary_path, const char *name)\n{\n\tint i, sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };\n\tbool is_shared_lib, is_name_qualified;\n\tlong ret = -ENOENT;\n\tsize_t name_len;\n\tGElf_Ehdr ehdr;\n\n\tif (!gelf_getehdr(elf, &ehdr)) {\n\t\tpr_warn(\"elf: failed to get ehdr from %s: %s\\n\", binary_path, elf_errmsg(-1));\n\t\tret = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tis_shared_lib = ehdr.e_type == ET_DYN;\n\n\tname_len = strlen(name);\n\t \n\tis_name_qualified = strstr(name, \"@@\") != NULL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sh_types); i++) {\n\t\tstruct elf_sym_iter iter;\n\t\tstruct elf_sym *sym;\n\t\tint last_bind = -1;\n\t\tint cur_bind;\n\n\t\tret = elf_sym_iter_new(&iter, elf, binary_path, sh_types[i], STT_FUNC);\n\t\tif (ret == -ENOENT)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\twhile ((sym = elf_sym_iter_next(&iter))) {\n\t\t\t \n\t\t\tif (strncmp(sym->name, name, name_len) != 0)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!is_name_qualified && sym->name[name_len] != '\\0' && sym->name[name_len] != '@')\n\t\t\t\tcontinue;\n\n\t\t\tcur_bind = GELF_ST_BIND(sym->sym.st_info);\n\n\t\t\tif (ret > 0) {\n\t\t\t\t \n\t\t\t\tif (last_bind != STB_WEAK && cur_bind != STB_WEAK) {\n\t\t\t\t\t \n\t\t\t\t\tpr_warn(\"elf: ambiguous match for '%s', '%s' in '%s'\\n\",\n\t\t\t\t\t\tsym->name, name, binary_path);\n\t\t\t\t\tret = -LIBBPF_ERRNO__FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (cur_bind == STB_WEAK) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = elf_sym_offset(sym);\n\t\t\tlast_bind = cur_bind;\n\t\t}\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret > 0) {\n\t\tpr_debug(\"elf: symbol address match for '%s' in '%s': 0x%lx\\n\", name, binary_path,\n\t\t\t ret);\n\t} else {\n\t\tif (ret == 0) {\n\t\t\tpr_warn(\"elf: '%s' is 0 in symtab for '%s': %s\\n\", name, binary_path,\n\t\t\t\tis_shared_lib ? \"should not be 0 in a shared library\" :\n\t\t\t\t\t\t\"try using shared library path instead\");\n\t\t\tret = -ENOENT;\n\t\t} else {\n\t\t\tpr_warn(\"elf: failed to find symbol '%s' in '%s'\\n\", name, binary_path);\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\n \nlong elf_find_func_offset_from_file(const char *binary_path, const char *name)\n{\n\tstruct elf_fd elf_fd;\n\tlong ret = -ENOENT;\n\n\tret = elf_open(binary_path, &elf_fd);\n\tif (ret)\n\t\treturn ret;\n\tret = elf_find_func_offset(elf_fd.elf, binary_path, name);\n\telf_close(&elf_fd);\n\treturn ret;\n}\n\nstruct symbol {\n\tconst char *name;\n\tint bind;\n\tint idx;\n};\n\nstatic int symbol_cmp(const void *a, const void *b)\n{\n\tconst struct symbol *sym_a = a;\n\tconst struct symbol *sym_b = b;\n\n\treturn strcmp(sym_a->name, sym_b->name);\n}\n\n \nint elf_resolve_syms_offsets(const char *binary_path, int cnt,\n\t\t\t     const char **syms, unsigned long **poffsets)\n{\n\tint sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };\n\tint err = 0, i, cnt_done = 0;\n\tunsigned long *offsets;\n\tstruct symbol *symbols;\n\tstruct elf_fd elf_fd;\n\n\terr = elf_open(binary_path, &elf_fd);\n\tif (err)\n\t\treturn err;\n\n\toffsets = calloc(cnt, sizeof(*offsets));\n\tsymbols = calloc(cnt, sizeof(*symbols));\n\n\tif (!offsets || !symbols) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tsymbols[i].name = syms[i];\n\t\tsymbols[i].idx = i;\n\t}\n\n\tqsort(symbols, cnt, sizeof(*symbols), symbol_cmp);\n\n\tfor (i = 0; i < ARRAY_SIZE(sh_types); i++) {\n\t\tstruct elf_sym_iter iter;\n\t\tstruct elf_sym *sym;\n\n\t\terr = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], STT_FUNC);\n\t\tif (err == -ENOENT)\n\t\t\tcontinue;\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twhile ((sym = elf_sym_iter_next(&iter))) {\n\t\t\tunsigned long sym_offset = elf_sym_offset(sym);\n\t\t\tint bind = GELF_ST_BIND(sym->sym.st_info);\n\t\t\tstruct symbol *found, tmp = {\n\t\t\t\t.name = sym->name,\n\t\t\t};\n\t\t\tunsigned long *offset;\n\n\t\t\tfound = bsearch(&tmp, symbols, cnt, sizeof(*symbols), symbol_cmp);\n\t\t\tif (!found)\n\t\t\t\tcontinue;\n\n\t\t\toffset = &offsets[found->idx];\n\t\t\tif (*offset > 0) {\n\t\t\t\t \n\t\t\t\tif (*offset == sym_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (found->bind != STB_WEAK && bind != STB_WEAK) {\n\t\t\t\t\t \n\t\t\t\t\tpr_warn(\"elf: ambiguous match found '%s@%lu' in '%s' previous offset %lu\\n\",\n\t\t\t\t\t\tsym->name, sym_offset, binary_path, *offset);\n\t\t\t\t\terr = -ESRCH;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (bind == STB_WEAK) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcnt_done++;\n\t\t\t}\n\t\t\t*offset = sym_offset;\n\t\t\tfound->bind = bind;\n\t\t}\n\t}\n\n\tif (cnt != cnt_done) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t*poffsets = offsets;\n\nout:\n\tfree(symbols);\n\tif (err)\n\t\tfree(offsets);\n\telf_close(&elf_fd);\n\treturn err;\n}\n\n \nint elf_resolve_pattern_offsets(const char *binary_path, const char *pattern,\n\t\t\t\tunsigned long **poffsets, size_t *pcnt)\n{\n\tint sh_types[2] = { SHT_SYMTAB, SHT_DYNSYM };\n\tunsigned long *offsets = NULL;\n\tsize_t cap = 0, cnt = 0;\n\tstruct elf_fd elf_fd;\n\tint err = 0, i;\n\n\terr = elf_open(binary_path, &elf_fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(sh_types); i++) {\n\t\tstruct elf_sym_iter iter;\n\t\tstruct elf_sym *sym;\n\n\t\terr = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], STT_FUNC);\n\t\tif (err == -ENOENT)\n\t\t\tcontinue;\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twhile ((sym = elf_sym_iter_next(&iter))) {\n\t\t\tif (!glob_match(sym->name, pattern))\n\t\t\t\tcontinue;\n\n\t\t\terr = libbpf_ensure_mem((void **) &offsets, &cap, sizeof(*offsets),\n\t\t\t\t\t\tcnt + 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\toffsets[cnt++] = elf_sym_offset(sym);\n\t\t}\n\n\t\t \n\t\tif (cnt)\n\t\t\tbreak;\n\t}\n\n\tif (cnt) {\n\t\t*poffsets = offsets;\n\t\t*pcnt = cnt;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\nout:\n\tif (err)\n\t\tfree(offsets);\n\telf_close(&elf_fd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}