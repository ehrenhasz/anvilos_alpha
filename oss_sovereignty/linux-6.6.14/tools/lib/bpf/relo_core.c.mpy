{
  "module_name": "relo_core.c",
  "hash_id": "95e1009fe7765ae81447ae7a28b547817ba8672e8df099e5f766986822c2df3d",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/relo_core.c",
  "human_readable_source": "\n \n\n#ifdef __KERNEL__\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/string.h>\n#include <linux/bpf_verifier.h>\n#include \"relo_core.h\"\n\nstatic const char *btf_kind_str(const struct btf_type *t)\n{\n\treturn btf_type_str(t);\n}\n\nstatic bool is_ldimm64_insn(struct bpf_insn *insn)\n{\n\treturn insn->code == (BPF_LD | BPF_IMM | BPF_DW);\n}\n\nstatic const struct btf_type *\nskip_mods_and_typedefs(const struct btf *btf, u32 id, u32 *res_id)\n{\n\treturn btf_type_skip_modifiers(btf, id, res_id);\n}\n\nstatic const char *btf__name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_name_by_offset(btf, offset);\n}\n\nstatic s64 btf__resolve_size(const struct btf *btf, u32 type_id)\n{\n\tconst struct btf_type *t;\n\tint size;\n\n\tt = btf_type_by_id(btf, type_id);\n\tt = btf_resolve_size(btf, t, &size);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\treturn size;\n}\n\nenum libbpf_print_level {\n\tLIBBPF_WARN,\n\tLIBBPF_INFO,\n\tLIBBPF_DEBUG,\n};\n\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n#define pr_warn(fmt, log, ...)\tbpf_log((void *)log, fmt, \"\", ##__VA_ARGS__)\n#define pr_info(fmt, log, ...)\tbpf_log((void *)log, fmt, \"\", ##__VA_ARGS__)\n#define pr_debug(fmt, log, ...)\tbpf_log((void *)log, fmt, \"\", ##__VA_ARGS__)\n#define libbpf_print(level, fmt, ...)\tbpf_log((void *)prog_name, fmt, ##__VA_ARGS__)\n#else\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n#include <linux/err.h>\n\n#include \"libbpf.h\"\n#include \"bpf.h\"\n#include \"btf.h\"\n#include \"str_error.h\"\n#include \"libbpf_internal.h\"\n#endif\n\nstatic bool is_flex_arr(const struct btf *btf,\n\t\t\tconst struct bpf_core_accessor *acc,\n\t\t\tconst struct btf_array *arr)\n{\n\tconst struct btf_type *t;\n\n\t \n\tif (!acc->name || arr->nelems > 0)\n\t\treturn false;\n\n\t \n\tt = btf_type_by_id(btf, acc->type_id);\n\treturn acc->idx == btf_vlen(t) - 1;\n}\n\nstatic const char *core_relo_kind_str(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_CORE_FIELD_BYTE_OFFSET: return \"byte_off\";\n\tcase BPF_CORE_FIELD_BYTE_SIZE: return \"byte_sz\";\n\tcase BPF_CORE_FIELD_EXISTS: return \"field_exists\";\n\tcase BPF_CORE_FIELD_SIGNED: return \"signed\";\n\tcase BPF_CORE_FIELD_LSHIFT_U64: return \"lshift_u64\";\n\tcase BPF_CORE_FIELD_RSHIFT_U64: return \"rshift_u64\";\n\tcase BPF_CORE_TYPE_ID_LOCAL: return \"local_type_id\";\n\tcase BPF_CORE_TYPE_ID_TARGET: return \"target_type_id\";\n\tcase BPF_CORE_TYPE_EXISTS: return \"type_exists\";\n\tcase BPF_CORE_TYPE_MATCHES: return \"type_matches\";\n\tcase BPF_CORE_TYPE_SIZE: return \"type_size\";\n\tcase BPF_CORE_ENUMVAL_EXISTS: return \"enumval_exists\";\n\tcase BPF_CORE_ENUMVAL_VALUE: return \"enumval_value\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nstatic bool core_relo_is_field_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_CORE_FIELD_BYTE_OFFSET:\n\tcase BPF_CORE_FIELD_BYTE_SIZE:\n\tcase BPF_CORE_FIELD_EXISTS:\n\tcase BPF_CORE_FIELD_SIGNED:\n\tcase BPF_CORE_FIELD_LSHIFT_U64:\n\tcase BPF_CORE_FIELD_RSHIFT_U64:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool core_relo_is_type_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_CORE_TYPE_ID_LOCAL:\n\tcase BPF_CORE_TYPE_ID_TARGET:\n\tcase BPF_CORE_TYPE_EXISTS:\n\tcase BPF_CORE_TYPE_MATCHES:\n\tcase BPF_CORE_TYPE_SIZE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool core_relo_is_enumval_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_CORE_ENUMVAL_EXISTS:\n\tcase BPF_CORE_ENUMVAL_VALUE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint __bpf_core_types_are_compat(const struct btf *local_btf, __u32 local_id,\n\t\t\t\tconst struct btf *targ_btf, __u32 targ_id, int level)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\tint depth = 32;  \n\n\t \n\tlocal_type = btf_type_by_id(local_btf, local_id);\n\ttarg_type = btf_type_by_id(targ_btf, targ_id);\n\tif (!btf_kind_core_compat(local_type, targ_type))\n\t\treturn 0;\n\nrecur:\n\tdepth--;\n\tif (depth < 0)\n\t\treturn -EINVAL;\n\n\tlocal_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!local_type || !targ_type)\n\t\treturn -EINVAL;\n\n\tif (!btf_kind_core_compat(local_type, targ_type))\n\t\treturn 0;\n\n\tswitch (btf_kind(local_type)) {\n\tcase BTF_KIND_UNKN:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_ENUM64:\n\t\treturn 1;\n\tcase BTF_KIND_INT:\n\t\t \n\t\treturn btf_int_offset(local_type) == 0 && btf_int_offset(targ_type) == 0;\n\tcase BTF_KIND_PTR:\n\t\tlocal_id = local_type->type;\n\t\ttarg_id = targ_type->type;\n\t\tgoto recur;\n\tcase BTF_KIND_ARRAY:\n\t\tlocal_id = btf_array(local_type)->type;\n\t\ttarg_id = btf_array(targ_type)->type;\n\t\tgoto recur;\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *local_p = btf_params(local_type);\n\t\tstruct btf_param *targ_p = btf_params(targ_type);\n\t\t__u16 local_vlen = btf_vlen(local_type);\n\t\t__u16 targ_vlen = btf_vlen(targ_type);\n\t\tint i, err;\n\n\t\tif (local_vlen != targ_vlen)\n\t\t\treturn 0;\n\n\t\tfor (i = 0; i < local_vlen; i++, local_p++, targ_p++) {\n\t\t\tif (level <= 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tskip_mods_and_typedefs(local_btf, local_p->type, &local_id);\n\t\t\tskip_mods_and_typedefs(targ_btf, targ_p->type, &targ_id);\n\t\t\terr = __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id,\n\t\t\t\t\t\t\t  level - 1);\n\t\t\tif (err <= 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tskip_mods_and_typedefs(local_btf, local_type->type, &local_id);\n\t\tskip_mods_and_typedefs(targ_btf, targ_type->type, &targ_id);\n\t\tgoto recur;\n\t}\n\tdefault:\n\t\tpr_warn(\"unexpected kind %s relocated, local [%d], target [%d]\\n\",\n\t\t\tbtf_kind_str(local_type), local_id, targ_id);\n\t\treturn 0;\n\t}\n}\n\n \nint bpf_core_parse_spec(const char *prog_name, const struct btf *btf,\n\t\t\tconst struct bpf_core_relo *relo,\n\t\t\tstruct bpf_core_spec *spec)\n{\n\tint access_idx, parsed_len, i;\n\tstruct bpf_core_accessor *acc;\n\tconst struct btf_type *t;\n\tconst char *name, *spec_str;\n\t__u32 id, name_off;\n\t__s64 sz;\n\n\tspec_str = btf__name_by_offset(btf, relo->access_str_off);\n\tif (str_is_empty(spec_str) || *spec_str == ':')\n\t\treturn -EINVAL;\n\n\tmemset(spec, 0, sizeof(*spec));\n\tspec->btf = btf;\n\tspec->root_type_id = relo->type_id;\n\tspec->relo_kind = relo->kind;\n\n\t \n\tif (core_relo_is_type_based(relo->kind)) {\n\t\tif (strcmp(spec_str, \"0\"))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\twhile (*spec_str) {\n\t\tif (*spec_str == ':')\n\t\t\t++spec_str;\n\t\tif (sscanf(spec_str, \"%d%n\", &access_idx, &parsed_len) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\treturn -E2BIG;\n\t\tspec_str += parsed_len;\n\t\tspec->raw_spec[spec->raw_len++] = access_idx;\n\t}\n\n\tif (spec->raw_len == 0)\n\t\treturn -EINVAL;\n\n\tt = skip_mods_and_typedefs(btf, relo->type_id, &id);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\taccess_idx = spec->raw_spec[0];\n\tacc = &spec->spec[0];\n\tacc->type_id = id;\n\tacc->idx = access_idx;\n\tspec->len++;\n\n\tif (core_relo_is_enumval_based(relo->kind)) {\n\t\tif (!btf_is_any_enum(t) || spec->raw_len > 1 || access_idx >= btf_vlen(t))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tname_off = btf_is_enum(t) ? btf_enum(t)[access_idx].name_off\n\t\t\t\t\t  : btf_enum64(t)[access_idx].name_off;\n\t\tacc->name = btf__name_by_offset(btf, name_off);\n\t\treturn 0;\n\t}\n\n\tif (!core_relo_is_field_based(relo->kind))\n\t\treturn -EINVAL;\n\n\tsz = btf__resolve_size(btf, id);\n\tif (sz < 0)\n\t\treturn sz;\n\tspec->bit_offset = access_idx * sz * 8;\n\n\tfor (i = 1; i < spec->raw_len; i++) {\n\t\tt = skip_mods_and_typedefs(btf, id, &id);\n\t\tif (!t)\n\t\t\treturn -EINVAL;\n\n\t\taccess_idx = spec->raw_spec[i];\n\t\tacc = &spec->spec[spec->len];\n\n\t\tif (btf_is_composite(t)) {\n\t\t\tconst struct btf_member *m;\n\t\t\t__u32 bit_offset;\n\n\t\t\tif (access_idx >= btf_vlen(t))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbit_offset = btf_member_bit_offset(t, access_idx);\n\t\t\tspec->bit_offset += bit_offset;\n\n\t\t\tm = btf_members(t) + access_idx;\n\t\t\tif (m->name_off) {\n\t\t\t\tname = btf__name_by_offset(btf, m->name_off);\n\t\t\t\tif (str_is_empty(name))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tacc->type_id = id;\n\t\t\t\tacc->idx = access_idx;\n\t\t\t\tacc->name = name;\n\t\t\t\tspec->len++;\n\t\t\t}\n\n\t\t\tid = m->type;\n\t\t} else if (btf_is_array(t)) {\n\t\t\tconst struct btf_array *a = btf_array(t);\n\t\t\tbool flex;\n\n\t\t\tt = skip_mods_and_typedefs(btf, a->type, &id);\n\t\t\tif (!t)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tflex = is_flex_arr(btf, acc - 1, a);\n\t\t\tif (!flex && access_idx >= a->nelems)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tspec->spec[spec->len].type_id = id;\n\t\t\tspec->spec[spec->len].idx = access_idx;\n\t\t\tspec->len++;\n\n\t\t\tsz = btf__resolve_size(btf, id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn sz;\n\t\t\tspec->bit_offset += access_idx * sz * 8;\n\t\t} else {\n\t\t\tpr_warn(\"prog '%s': relo for [%u] %s (at idx %d) captures type [%d] of unexpected kind %s\\n\",\n\t\t\t\tprog_name, relo->type_id, spec_str, i, id, btf_kind_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bpf_core_fields_are_compat(const struct btf *local_btf,\n\t\t\t\t      __u32 local_id,\n\t\t\t\t      const struct btf *targ_btf,\n\t\t\t\t      __u32 targ_id)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\nrecur:\n\tlocal_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!local_type || !targ_type)\n\t\treturn -EINVAL;\n\n\tif (btf_is_composite(local_type) && btf_is_composite(targ_type))\n\t\treturn 1;\n\tif (!btf_kind_core_compat(local_type, targ_type))\n\t\treturn 0;\n\n\tswitch (btf_kind(local_type)) {\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_FLOAT:\n\t\treturn 1;\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_ENUM64:\n\tcase BTF_KIND_ENUM: {\n\t\tconst char *local_name, *targ_name;\n\t\tsize_t local_len, targ_len;\n\n\t\tlocal_name = btf__name_by_offset(local_btf,\n\t\t\t\t\t\t local_type->name_off);\n\t\ttarg_name = btf__name_by_offset(targ_btf, targ_type->name_off);\n\t\tlocal_len = bpf_core_essential_name_len(local_name);\n\t\ttarg_len = bpf_core_essential_name_len(targ_name);\n\t\t \n\t\treturn local_len == 0 || targ_len == 0 ||\n\t\t       (local_len == targ_len &&\n\t\t\tstrncmp(local_name, targ_name, local_len) == 0);\n\t}\n\tcase BTF_KIND_INT:\n\t\t \n\t\treturn btf_int_offset(local_type) == 0 &&\n\t\t       btf_int_offset(targ_type) == 0;\n\tcase BTF_KIND_ARRAY:\n\t\tlocal_id = btf_array(local_type)->type;\n\t\ttarg_id = btf_array(targ_type)->type;\n\t\tgoto recur;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int bpf_core_match_member(const struct btf *local_btf,\n\t\t\t\t const struct bpf_core_accessor *local_acc,\n\t\t\t\t const struct btf *targ_btf,\n\t\t\t\t __u32 targ_id,\n\t\t\t\t struct bpf_core_spec *spec,\n\t\t\t\t __u32 *next_targ_id)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\tconst struct btf_member *local_member, *m;\n\tconst char *local_name, *targ_name;\n\t__u32 local_id;\n\tint i, n, found;\n\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!targ_type)\n\t\treturn -EINVAL;\n\tif (!btf_is_composite(targ_type))\n\t\treturn 0;\n\n\tlocal_id = local_acc->type_id;\n\tlocal_type = btf_type_by_id(local_btf, local_id);\n\tlocal_member = btf_members(local_type) + local_acc->idx;\n\tlocal_name = btf__name_by_offset(local_btf, local_member->name_off);\n\n\tn = btf_vlen(targ_type);\n\tm = btf_members(targ_type);\n\tfor (i = 0; i < n; i++, m++) {\n\t\t__u32 bit_offset;\n\n\t\tbit_offset = btf_member_bit_offset(targ_type, i);\n\n\t\t \n\t\tif (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\treturn -E2BIG;\n\n\t\t \n\t\tspec->bit_offset += bit_offset;\n\t\tspec->raw_spec[spec->raw_len++] = i;\n\n\t\ttarg_name = btf__name_by_offset(targ_btf, m->name_off);\n\t\tif (str_is_empty(targ_name)) {\n\t\t\t \n\t\t\tfound = bpf_core_match_member(local_btf, local_acc,\n\t\t\t\t\t\t      targ_btf, m->type,\n\t\t\t\t\t\t      spec, next_targ_id);\n\t\t\tif (found)  \n\t\t\t\treturn found;\n\t\t} else if (strcmp(local_name, targ_name) == 0) {\n\t\t\t \n\t\t\tstruct bpf_core_accessor *targ_acc;\n\n\t\t\ttarg_acc = &spec->spec[spec->len++];\n\t\t\ttarg_acc->type_id = targ_id;\n\t\t\ttarg_acc->idx = i;\n\t\t\ttarg_acc->name = targ_name;\n\n\t\t\t*next_targ_id = m->type;\n\t\t\tfound = bpf_core_fields_are_compat(local_btf,\n\t\t\t\t\t\t\t   local_member->type,\n\t\t\t\t\t\t\t   targ_btf, m->type);\n\t\t\tif (!found)\n\t\t\t\tspec->len--;  \n\t\t\treturn found;\n\t\t}\n\t\t \n\t\tspec->bit_offset -= bit_offset;\n\t\tspec->raw_len--;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bpf_core_spec_match(struct bpf_core_spec *local_spec,\n\t\t\t       const struct btf *targ_btf, __u32 targ_id,\n\t\t\t       struct bpf_core_spec *targ_spec)\n{\n\tconst struct btf_type *targ_type;\n\tconst struct bpf_core_accessor *local_acc;\n\tstruct bpf_core_accessor *targ_acc;\n\tint i, sz, matched;\n\t__u32 name_off;\n\n\tmemset(targ_spec, 0, sizeof(*targ_spec));\n\ttarg_spec->btf = targ_btf;\n\ttarg_spec->root_type_id = targ_id;\n\ttarg_spec->relo_kind = local_spec->relo_kind;\n\n\tif (core_relo_is_type_based(local_spec->relo_kind)) {\n\t\tif (local_spec->relo_kind == BPF_CORE_TYPE_MATCHES)\n\t\t\treturn bpf_core_types_match(local_spec->btf,\n\t\t\t\t\t\t    local_spec->root_type_id,\n\t\t\t\t\t\t    targ_btf, targ_id);\n\t\telse\n\t\t\treturn bpf_core_types_are_compat(local_spec->btf,\n\t\t\t\t\t\t\t local_spec->root_type_id,\n\t\t\t\t\t\t\t targ_btf, targ_id);\n\t}\n\n\tlocal_acc = &local_spec->spec[0];\n\ttarg_acc = &targ_spec->spec[0];\n\n\tif (core_relo_is_enumval_based(local_spec->relo_kind)) {\n\t\tsize_t local_essent_len, targ_essent_len;\n\t\tconst char *targ_name;\n\n\t\t \n\t\ttarg_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);\n\t\tif (!btf_is_any_enum(targ_type))\n\t\t\treturn 0;\n\n\t\tlocal_essent_len = bpf_core_essential_name_len(local_acc->name);\n\n\t\tfor (i = 0; i < btf_vlen(targ_type); i++) {\n\t\t\tif (btf_is_enum(targ_type))\n\t\t\t\tname_off = btf_enum(targ_type)[i].name_off;\n\t\t\telse\n\t\t\t\tname_off = btf_enum64(targ_type)[i].name_off;\n\n\t\t\ttarg_name = btf__name_by_offset(targ_spec->btf, name_off);\n\t\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\t\tif (targ_essent_len != local_essent_len)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(local_acc->name, targ_name, local_essent_len) == 0) {\n\t\t\t\ttarg_acc->type_id = targ_id;\n\t\t\t\ttarg_acc->idx = i;\n\t\t\t\ttarg_acc->name = targ_name;\n\t\t\t\ttarg_spec->len++;\n\t\t\t\ttarg_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;\n\t\t\t\ttarg_spec->raw_len++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!core_relo_is_field_based(local_spec->relo_kind))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < local_spec->len; i++, local_acc++, targ_acc++) {\n\t\ttarg_type = skip_mods_and_typedefs(targ_spec->btf, targ_id,\n\t\t\t\t\t\t   &targ_id);\n\t\tif (!targ_type)\n\t\t\treturn -EINVAL;\n\n\t\tif (local_acc->name) {\n\t\t\tmatched = bpf_core_match_member(local_spec->btf,\n\t\t\t\t\t\t\tlocal_acc,\n\t\t\t\t\t\t\ttarg_btf, targ_id,\n\t\t\t\t\t\t\ttarg_spec, &targ_id);\n\t\t\tif (matched <= 0)\n\t\t\t\treturn matched;\n\t\t} else {\n\t\t\t \n\t\t\tif (i > 0) {\n\t\t\t\tconst struct btf_array *a;\n\t\t\t\tbool flex;\n\n\t\t\t\tif (!btf_is_array(targ_type))\n\t\t\t\t\treturn 0;\n\n\t\t\t\ta = btf_array(targ_type);\n\t\t\t\tflex = is_flex_arr(targ_btf, targ_acc - 1, a);\n\t\t\t\tif (!flex && local_acc->idx >= a->nelems)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!skip_mods_and_typedefs(targ_btf, a->type,\n\t\t\t\t\t\t\t    &targ_id))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (targ_spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\t\treturn -E2BIG;\n\n\t\t\ttarg_acc->type_id = targ_id;\n\t\t\ttarg_acc->idx = local_acc->idx;\n\t\t\ttarg_acc->name = NULL;\n\t\t\ttarg_spec->len++;\n\t\t\ttarg_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;\n\t\t\ttarg_spec->raw_len++;\n\n\t\t\tsz = btf__resolve_size(targ_btf, targ_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn sz;\n\t\t\ttarg_spec->bit_offset += local_acc->idx * sz * 8;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int bpf_core_calc_field_relo(const char *prog_name,\n\t\t\t\t    const struct bpf_core_relo *relo,\n\t\t\t\t    const struct bpf_core_spec *spec,\n\t\t\t\t    __u64 *val, __u32 *field_sz, __u32 *type_id,\n\t\t\t\t    bool *validate)\n{\n\tconst struct bpf_core_accessor *acc;\n\tconst struct btf_type *t;\n\t__u32 byte_off, byte_sz, bit_off, bit_sz, field_type_id;\n\tconst struct btf_member *m;\n\tconst struct btf_type *mt;\n\tbool bitfield;\n\t__s64 sz;\n\n\t*field_sz = 0;\n\n\tif (relo->kind == BPF_CORE_FIELD_EXISTS) {\n\t\t*val = spec ? 1 : 0;\n\t\treturn 0;\n\t}\n\n\tif (!spec)\n\t\treturn -EUCLEAN;  \n\n\tacc = &spec->spec[spec->len - 1];\n\tt = btf_type_by_id(spec->btf, acc->type_id);\n\n\t \n\tif (!acc->name) {\n\t\tif (relo->kind == BPF_CORE_FIELD_BYTE_OFFSET) {\n\t\t\t*val = spec->bit_offset / 8;\n\t\t\t \n\t\t\tsz = btf__resolve_size(spec->btf, acc->type_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t*field_sz = sz;\n\t\t\t*type_id = acc->type_id;\n\t\t} else if (relo->kind == BPF_CORE_FIELD_BYTE_SIZE) {\n\t\t\tsz = btf__resolve_size(spec->btf, acc->type_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t*val = sz;\n\t\t} else {\n\t\t\tpr_warn(\"prog '%s': relo %d at insn #%d can't be applied to array access\\n\",\n\t\t\t\tprog_name, relo->kind, relo->insn_off / 8);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (validate)\n\t\t\t*validate = true;\n\t\treturn 0;\n\t}\n\n\tm = btf_members(t) + acc->idx;\n\tmt = skip_mods_and_typedefs(spec->btf, m->type, &field_type_id);\n\tbit_off = spec->bit_offset;\n\tbit_sz = btf_member_bitfield_size(t, acc->idx);\n\n\tbitfield = bit_sz > 0;\n\tif (bitfield) {\n\t\tbyte_sz = mt->size;\n\t\tbyte_off = bit_off / 8 / byte_sz * byte_sz;\n\t\t \n\t\twhile (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {\n\t\t\tif (byte_sz >= 8) {\n\t\t\t\t \n\t\t\t\tpr_warn(\"prog '%s': relo %d at insn #%d can't be satisfied for bitfield\\n\",\n\t\t\t\t\tprog_name, relo->kind, relo->insn_off / 8);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t\tbyte_sz *= 2;\n\t\t\tbyte_off = bit_off / 8 / byte_sz * byte_sz;\n\t\t}\n\t} else {\n\t\tsz = btf__resolve_size(spec->btf, field_type_id);\n\t\tif (sz < 0)\n\t\t\treturn -EINVAL;\n\t\tbyte_sz = sz;\n\t\tbyte_off = spec->bit_offset / 8;\n\t\tbit_sz = byte_sz * 8;\n\t}\n\n\t \n\tif (validate)\n\t\t*validate = !bitfield;\n\n\tswitch (relo->kind) {\n\tcase BPF_CORE_FIELD_BYTE_OFFSET:\n\t\t*val = byte_off;\n\t\tif (!bitfield) {\n\t\t\t*field_sz = byte_sz;\n\t\t\t*type_id = field_type_id;\n\t\t}\n\t\tbreak;\n\tcase BPF_CORE_FIELD_BYTE_SIZE:\n\t\t*val = byte_sz;\n\t\tbreak;\n\tcase BPF_CORE_FIELD_SIGNED:\n\t\t*val = (btf_is_any_enum(mt) && BTF_INFO_KFLAG(mt->info)) ||\n\t\t       (btf_is_int(mt) && (btf_int_encoding(mt) & BTF_INT_SIGNED));\n\t\tif (validate)\n\t\t\t*validate = true;  \n\t\tbreak;\n\tcase BPF_CORE_FIELD_LSHIFT_U64:\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\t\t*val = 64 - (bit_off + bit_sz - byte_off  * 8);\n#else\n\t\t*val = (8 - byte_sz) * 8 + (bit_off - byte_off * 8);\n#endif\n\t\tbreak;\n\tcase BPF_CORE_FIELD_RSHIFT_U64:\n\t\t*val = 64 - bit_sz;\n\t\tif (validate)\n\t\t\t*validate = true;  \n\t\tbreak;\n\tcase BPF_CORE_FIELD_EXISTS:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_core_calc_type_relo(const struct bpf_core_relo *relo,\n\t\t\t\t   const struct bpf_core_spec *spec,\n\t\t\t\t   __u64 *val, bool *validate)\n{\n\t__s64 sz;\n\n\t \n\tif (validate)\n\t\t*validate = true;\n\n\t \n\tif (!spec) {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\n\tswitch (relo->kind) {\n\tcase BPF_CORE_TYPE_ID_TARGET:\n\t\t*val = spec->root_type_id;\n\t\t \n\t\tif (validate)\n\t\t\t*validate = false;\n\t\tbreak;\n\tcase BPF_CORE_TYPE_EXISTS:\n\tcase BPF_CORE_TYPE_MATCHES:\n\t\t*val = 1;\n\t\tbreak;\n\tcase BPF_CORE_TYPE_SIZE:\n\t\tsz = btf__resolve_size(spec->btf, spec->root_type_id);\n\t\tif (sz < 0)\n\t\t\treturn -EINVAL;\n\t\t*val = sz;\n\t\tbreak;\n\tcase BPF_CORE_TYPE_ID_LOCAL:\n\t \n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_core_calc_enumval_relo(const struct bpf_core_relo *relo,\n\t\t\t\t      const struct bpf_core_spec *spec,\n\t\t\t\t      __u64 *val)\n{\n\tconst struct btf_type *t;\n\n\tswitch (relo->kind) {\n\tcase BPF_CORE_ENUMVAL_EXISTS:\n\t\t*val = spec ? 1 : 0;\n\t\tbreak;\n\tcase BPF_CORE_ENUMVAL_VALUE:\n\t\tif (!spec)\n\t\t\treturn -EUCLEAN;  \n\t\tt = btf_type_by_id(spec->btf, spec->spec[0].type_id);\n\t\tif (btf_is_enum(t))\n\t\t\t*val = btf_enum(t)[spec->spec[0].idx].val;\n\t\telse\n\t\t\t*val = btf_enum64_value(btf_enum64(t) + spec->spec[0].idx);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bpf_core_calc_relo(const char *prog_name,\n\t\t\t      const struct bpf_core_relo *relo,\n\t\t\t      int relo_idx,\n\t\t\t      const struct bpf_core_spec *local_spec,\n\t\t\t      const struct bpf_core_spec *targ_spec,\n\t\t\t      struct bpf_core_relo_res *res)\n{\n\tint err = -EOPNOTSUPP;\n\n\tres->orig_val = 0;\n\tres->new_val = 0;\n\tres->poison = false;\n\tres->validate = true;\n\tres->fail_memsz_adjust = false;\n\tres->orig_sz = res->new_sz = 0;\n\tres->orig_type_id = res->new_type_id = 0;\n\n\tif (core_relo_is_field_based(relo->kind)) {\n\t\terr = bpf_core_calc_field_relo(prog_name, relo, local_spec,\n\t\t\t\t\t       &res->orig_val, &res->orig_sz,\n\t\t\t\t\t       &res->orig_type_id, &res->validate);\n\t\terr = err ?: bpf_core_calc_field_relo(prog_name, relo, targ_spec,\n\t\t\t\t\t\t      &res->new_val, &res->new_sz,\n\t\t\t\t\t\t      &res->new_type_id, NULL);\n\t\tif (err)\n\t\t\tgoto done;\n\t\t \n\t\tres->fail_memsz_adjust = false;\n\t\tif (res->orig_sz != res->new_sz) {\n\t\t\tconst struct btf_type *orig_t, *new_t;\n\n\t\t\torig_t = btf_type_by_id(local_spec->btf, res->orig_type_id);\n\t\t\tnew_t = btf_type_by_id(targ_spec->btf, res->new_type_id);\n\n\t\t\t \n\t\t\tif (btf_is_ptr(orig_t) && btf_is_ptr(new_t))\n\t\t\t\tgoto done;\n\t\t\tif (btf_is_int(orig_t) && btf_is_int(new_t) &&\n\t\t\t    btf_int_encoding(orig_t) != BTF_INT_SIGNED &&\n\t\t\t    btf_int_encoding(new_t) != BTF_INT_SIGNED)\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tres->fail_memsz_adjust = true;\n\t\t}\n\t} else if (core_relo_is_type_based(relo->kind)) {\n\t\terr = bpf_core_calc_type_relo(relo, local_spec, &res->orig_val, &res->validate);\n\t\terr = err ?: bpf_core_calc_type_relo(relo, targ_spec, &res->new_val, NULL);\n\t} else if (core_relo_is_enumval_based(relo->kind)) {\n\t\terr = bpf_core_calc_enumval_relo(relo, local_spec, &res->orig_val);\n\t\terr = err ?: bpf_core_calc_enumval_relo(relo, targ_spec, &res->new_val);\n\t}\n\ndone:\n\tif (err == -EUCLEAN) {\n\t\t \n\t\tres->poison = true;\n\t\terr = 0;\n\t} else if (err == -EOPNOTSUPP) {\n\t\t \n\t\tpr_warn(\"prog '%s': relo #%d: unrecognized CO-RE relocation %s (%d) at insn #%d\\n\",\n\t\t\tprog_name, relo_idx, core_relo_kind_str(relo->kind),\n\t\t\trelo->kind, relo->insn_off / 8);\n\t}\n\n\treturn err;\n}\n\n \nstatic void bpf_core_poison_insn(const char *prog_name, int relo_idx,\n\t\t\t\t int insn_idx, struct bpf_insn *insn)\n{\n\tpr_debug(\"prog '%s': relo #%d: substituting insn #%d w/ invalid insn\\n\",\n\t\t prog_name, relo_idx, insn_idx);\n\tinsn->code = BPF_JMP | BPF_CALL;\n\tinsn->dst_reg = 0;\n\tinsn->src_reg = 0;\n\tinsn->off = 0;\n\t \n\tinsn->imm = 195896080;  \n}\n\nstatic int insn_bpf_size_to_bytes(struct bpf_insn *insn)\n{\n\tswitch (BPF_SIZE(insn->code)) {\n\tcase BPF_DW: return 8;\n\tcase BPF_W: return 4;\n\tcase BPF_H: return 2;\n\tcase BPF_B: return 1;\n\tdefault: return -1;\n\t}\n}\n\nstatic int insn_bytes_to_bpf_size(__u32 sz)\n{\n\tswitch (sz) {\n\tcase 8: return BPF_DW;\n\tcase 4: return BPF_W;\n\tcase 2: return BPF_H;\n\tcase 1: return BPF_B;\n\tdefault: return -1;\n\t}\n}\n\n \nint bpf_core_patch_insn(const char *prog_name, struct bpf_insn *insn,\n\t\t\tint insn_idx, const struct bpf_core_relo *relo,\n\t\t\tint relo_idx, const struct bpf_core_relo_res *res)\n{\n\t__u64 orig_val, new_val;\n\t__u8 class;\n\n\tclass = BPF_CLASS(insn->code);\n\n\tif (res->poison) {\npoison:\n\t\t \n\t\tif (is_ldimm64_insn(insn))\n\t\t\tbpf_core_poison_insn(prog_name, relo_idx, insn_idx + 1, insn + 1);\n\t\tbpf_core_poison_insn(prog_name, relo_idx, insn_idx, insn);\n\t\treturn 0;\n\t}\n\n\torig_val = res->orig_val;\n\tnew_val = res->new_val;\n\n\tswitch (class) {\n\tcase BPF_ALU:\n\tcase BPF_ALU64:\n\t\tif (BPF_SRC(insn->code) != BPF_K)\n\t\t\treturn -EINVAL;\n\t\tif (res->validate && insn->imm != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (ALU/ALU64) value: got %u, exp %llu -> %llu\\n\",\n\t\t\t\tprog_name, relo_idx,\n\t\t\t\tinsn_idx, insn->imm, (unsigned long long)orig_val,\n\t\t\t\t(unsigned long long)new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\torig_val = insn->imm;\n\t\tinsn->imm = new_val;\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (ALU/ALU64) imm %llu -> %llu\\n\",\n\t\t\t prog_name, relo_idx, insn_idx,\n\t\t\t (unsigned long long)orig_val, (unsigned long long)new_val);\n\t\tbreak;\n\tcase BPF_LDX:\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tif (res->validate && insn->off != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (LDX/ST/STX) value: got %u, exp %llu -> %llu\\n\",\n\t\t\t\tprog_name, relo_idx, insn_idx, insn->off, (unsigned long long)orig_val,\n\t\t\t\t(unsigned long long)new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (new_val > SHRT_MAX) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) value too big: %llu\\n\",\n\t\t\t\tprog_name, relo_idx, insn_idx, (unsigned long long)new_val);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tif (res->fail_memsz_adjust) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) accesses field incorrectly. \"\n\t\t\t\t\"Make sure you are accessing pointers, unsigned integers, or fields of matching type and size.\\n\",\n\t\t\t\tprog_name, relo_idx, insn_idx);\n\t\t\tgoto poison;\n\t\t}\n\n\t\torig_val = insn->off;\n\t\tinsn->off = new_val;\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %llu -> %llu\\n\",\n\t\t\t prog_name, relo_idx, insn_idx, (unsigned long long)orig_val,\n\t\t\t (unsigned long long)new_val);\n\n\t\tif (res->new_sz != res->orig_sz) {\n\t\t\tint insn_bytes_sz, insn_bpf_sz;\n\n\t\t\tinsn_bytes_sz = insn_bpf_size_to_bytes(insn);\n\t\t\tif (insn_bytes_sz != res->orig_sz) {\n\t\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) unexpected mem size: got %d, exp %u\\n\",\n\t\t\t\t\tprog_name, relo_idx, insn_idx, insn_bytes_sz, res->orig_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinsn_bpf_sz = insn_bytes_to_bpf_size(res->new_sz);\n\t\t\tif (insn_bpf_sz < 0) {\n\t\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) invalid new mem size: %u\\n\",\n\t\t\t\t\tprog_name, relo_idx, insn_idx, res->new_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinsn->code = BPF_MODE(insn->code) | insn_bpf_sz | BPF_CLASS(insn->code);\n\t\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) mem_sz %u -> %u\\n\",\n\t\t\t\t prog_name, relo_idx, insn_idx, res->orig_sz, res->new_sz);\n\t\t}\n\t\tbreak;\n\tcase BPF_LD: {\n\t\t__u64 imm;\n\n\t\tif (!is_ldimm64_insn(insn) ||\n\t\t    insn[0].src_reg != 0 || insn[0].off != 0 ||\n\t\t    insn[1].code != 0 || insn[1].dst_reg != 0 ||\n\t\t    insn[1].src_reg != 0 || insn[1].off != 0) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDIMM64) has unexpected form\\n\",\n\t\t\t\tprog_name, relo_idx, insn_idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\timm = (__u32)insn[0].imm | ((__u64)insn[1].imm << 32);\n\t\tif (res->validate && imm != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (LDIMM64) value: got %llu, exp %llu -> %llu\\n\",\n\t\t\t\tprog_name, relo_idx,\n\t\t\t\tinsn_idx, (unsigned long long)imm,\n\t\t\t\t(unsigned long long)orig_val, (unsigned long long)new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn[0].imm = new_val;\n\t\tinsn[1].imm = new_val >> 32;\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\\n\",\n\t\t\t prog_name, relo_idx, insn_idx,\n\t\t\t (unsigned long long)imm, (unsigned long long)new_val);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_warn(\"prog '%s': relo #%d: trying to relocate unrecognized insn #%d, code:0x%x, src:0x%x, dst:0x%x, off:0x%x, imm:0x%x\\n\",\n\t\t\tprog_name, relo_idx, insn_idx, insn->code,\n\t\t\tinsn->src_reg, insn->dst_reg, insn->off, insn->imm);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint bpf_core_format_spec(char *buf, size_t buf_sz, const struct bpf_core_spec *spec)\n{\n\tconst struct btf_type *t;\n\tconst char *s;\n\t__u32 type_id;\n\tint i, len = 0;\n\n#define append_buf(fmt, args...)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\t\tint r;\t\t\t\t\t\t\\\n\t\tr = snprintf(buf, buf_sz, fmt, ##args);\t\t\\\n\t\tlen += r;\t\t\t\t\t\\\n\t\tif (r >= buf_sz)\t\t\t\t\\\n\t\t\tr = buf_sz;\t\t\t\t\\\n\t\tbuf += r;\t\t\t\t\t\\\n\t\tbuf_sz -= r;\t\t\t\t\t\\\n\t})\n\n\ttype_id = spec->root_type_id;\n\tt = btf_type_by_id(spec->btf, type_id);\n\ts = btf__name_by_offset(spec->btf, t->name_off);\n\n\tappend_buf(\"<%s> [%u] %s %s\",\n\t\t   core_relo_kind_str(spec->relo_kind),\n\t\t   type_id, btf_kind_str(t), str_is_empty(s) ? \"<anon>\" : s);\n\n\tif (core_relo_is_type_based(spec->relo_kind))\n\t\treturn len;\n\n\tif (core_relo_is_enumval_based(spec->relo_kind)) {\n\t\tt = skip_mods_and_typedefs(spec->btf, type_id, NULL);\n\t\tif (btf_is_enum(t)) {\n\t\t\tconst struct btf_enum *e;\n\t\t\tconst char *fmt_str;\n\n\t\t\te = btf_enum(t) + spec->raw_spec[0];\n\t\t\ts = btf__name_by_offset(spec->btf, e->name_off);\n\t\t\tfmt_str = BTF_INFO_KFLAG(t->info) ? \"::%s = %d\" : \"::%s = %u\";\n\t\t\tappend_buf(fmt_str, s, e->val);\n\t\t} else {\n\t\t\tconst struct btf_enum64 *e;\n\t\t\tconst char *fmt_str;\n\n\t\t\te = btf_enum64(t) + spec->raw_spec[0];\n\t\t\ts = btf__name_by_offset(spec->btf, e->name_off);\n\t\t\tfmt_str = BTF_INFO_KFLAG(t->info) ? \"::%s = %lld\" : \"::%s = %llu\";\n\t\t\tappend_buf(fmt_str, s, (unsigned long long)btf_enum64_value(e));\n\t\t}\n\t\treturn len;\n\t}\n\n\tif (core_relo_is_field_based(spec->relo_kind)) {\n\t\tfor (i = 0; i < spec->len; i++) {\n\t\t\tif (spec->spec[i].name)\n\t\t\t\tappend_buf(\".%s\", spec->spec[i].name);\n\t\t\telse if (i > 0 || spec->spec[i].idx > 0)\n\t\t\t\tappend_buf(\"[%u]\", spec->spec[i].idx);\n\t\t}\n\n\t\tappend_buf(\" (\");\n\t\tfor (i = 0; i < spec->raw_len; i++)\n\t\t\tappend_buf(\"%s%d\", i == 0 ? \"\" : \":\", spec->raw_spec[i]);\n\n\t\tif (spec->bit_offset % 8)\n\t\t\tappend_buf(\" @ offset %u.%u)\", spec->bit_offset / 8, spec->bit_offset % 8);\n\t\telse\n\t\t\tappend_buf(\" @ offset %u)\", spec->bit_offset / 8);\n\t\treturn len;\n\t}\n\n\treturn len;\n#undef append_buf\n}\n\n \nint bpf_core_calc_relo_insn(const char *prog_name,\n\t\t\t    const struct bpf_core_relo *relo,\n\t\t\t    int relo_idx,\n\t\t\t    const struct btf *local_btf,\n\t\t\t    struct bpf_core_cand_list *cands,\n\t\t\t    struct bpf_core_spec *specs_scratch,\n\t\t\t    struct bpf_core_relo_res *targ_res)\n{\n\tstruct bpf_core_spec *local_spec = &specs_scratch[0];\n\tstruct bpf_core_spec *cand_spec = &specs_scratch[1];\n\tstruct bpf_core_spec *targ_spec = &specs_scratch[2];\n\tstruct bpf_core_relo_res cand_res;\n\tconst struct btf_type *local_type;\n\tconst char *local_name;\n\t__u32 local_id;\n\tchar spec_buf[256];\n\tint i, j, err;\n\n\tlocal_id = relo->type_id;\n\tlocal_type = btf_type_by_id(local_btf, local_id);\n\tlocal_name = btf__name_by_offset(local_btf, local_type->name_off);\n\tif (!local_name)\n\t\treturn -EINVAL;\n\n\terr = bpf_core_parse_spec(prog_name, local_btf, relo, local_spec);\n\tif (err) {\n\t\tconst char *spec_str;\n\n\t\tspec_str = btf__name_by_offset(local_btf, relo->access_str_off);\n\t\tpr_warn(\"prog '%s': relo #%d: parsing [%d] %s %s + %s failed: %d\\n\",\n\t\t\tprog_name, relo_idx, local_id, btf_kind_str(local_type),\n\t\t\tstr_is_empty(local_name) ? \"<anon>\" : local_name,\n\t\t\tspec_str ?: \"<?>\", err);\n\t\treturn -EINVAL;\n\t}\n\n\tbpf_core_format_spec(spec_buf, sizeof(spec_buf), local_spec);\n\tpr_debug(\"prog '%s': relo #%d: %s\\n\", prog_name, relo_idx, spec_buf);\n\n\t \n\tif (relo->kind == BPF_CORE_TYPE_ID_LOCAL) {\n\t\t \n\t\tmemset(targ_res, 0, sizeof(*targ_res));\n\t\ttarg_res->validate = false;\n\t\ttarg_res->poison = false;\n\t\ttarg_res->orig_val = local_spec->root_type_id;\n\t\ttarg_res->new_val = local_spec->root_type_id;\n\t\treturn 0;\n\t}\n\n\t \n\tif (str_is_empty(local_name)) {\n\t\tpr_warn(\"prog '%s': relo #%d: <%s> (%d) relocation doesn't support anonymous types\\n\",\n\t\t\tprog_name, relo_idx, core_relo_kind_str(relo->kind), relo->kind);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (i = 0, j = 0; i < cands->len; i++) {\n\t\terr = bpf_core_spec_match(local_spec, cands->cands[i].btf,\n\t\t\t\t\t  cands->cands[i].id, cand_spec);\n\t\tif (err < 0) {\n\t\t\tbpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);\n\t\t\tpr_warn(\"prog '%s': relo #%d: error matching candidate #%d %s: %d\\n \",\n\t\t\t\tprog_name, relo_idx, i, spec_buf, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tbpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);\n\t\tpr_debug(\"prog '%s': relo #%d: %s candidate #%d %s\\n\", prog_name,\n\t\t\t relo_idx, err == 0 ? \"non-matching\" : \"matching\", i, spec_buf);\n\n\t\tif (err == 0)\n\t\t\tcontinue;\n\n\t\terr = bpf_core_calc_relo(prog_name, relo, relo_idx, local_spec, cand_spec, &cand_res);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (j == 0) {\n\t\t\t*targ_res = cand_res;\n\t\t\t*targ_spec = *cand_spec;\n\t\t} else if (cand_spec->bit_offset != targ_spec->bit_offset) {\n\t\t\t \n\t\t\tpr_warn(\"prog '%s': relo #%d: field offset ambiguity: %u != %u\\n\",\n\t\t\t\tprog_name, relo_idx, cand_spec->bit_offset,\n\t\t\t\ttarg_spec->bit_offset);\n\t\t\treturn -EINVAL;\n\t\t} else if (cand_res.poison != targ_res->poison ||\n\t\t\t   cand_res.new_val != targ_res->new_val) {\n\t\t\t \n\t\t\tpr_warn(\"prog '%s': relo #%d: relocation decision ambiguity: %s %llu != %s %llu\\n\",\n\t\t\t\tprog_name, relo_idx,\n\t\t\t\tcand_res.poison ? \"failure\" : \"success\",\n\t\t\t\t(unsigned long long)cand_res.new_val,\n\t\t\t\ttarg_res->poison ? \"failure\" : \"success\",\n\t\t\t\t(unsigned long long)targ_res->new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcands->cands[j++] = cands->cands[i];\n\t}\n\n\t \n\tif (j > 0)\n\t\tcands->len = j;\n\n\t \n\tif (j == 0) {\n\t\tpr_debug(\"prog '%s': relo #%d: no matching targets found\\n\",\n\t\t\t prog_name, relo_idx);\n\n\t\t \n\t\terr = bpf_core_calc_relo(prog_name, relo, relo_idx, local_spec, NULL, targ_res);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool bpf_core_names_match(const struct btf *local_btf, size_t local_name_off,\n\t\t\t\t const struct btf *targ_btf, size_t targ_name_off)\n{\n\tconst char *local_n, *targ_n;\n\tsize_t local_len, targ_len;\n\n\tlocal_n = btf__name_by_offset(local_btf, local_name_off);\n\ttarg_n = btf__name_by_offset(targ_btf, targ_name_off);\n\n\tif (str_is_empty(targ_n))\n\t\treturn str_is_empty(local_n);\n\n\ttarg_len = bpf_core_essential_name_len(targ_n);\n\tlocal_len = bpf_core_essential_name_len(local_n);\n\n\treturn targ_len == local_len && strncmp(local_n, targ_n, local_len) == 0;\n}\n\nstatic int bpf_core_enums_match(const struct btf *local_btf, const struct btf_type *local_t,\n\t\t\t\tconst struct btf *targ_btf, const struct btf_type *targ_t)\n{\n\t__u16 local_vlen = btf_vlen(local_t);\n\t__u16 targ_vlen = btf_vlen(targ_t);\n\tint i, j;\n\n\tif (local_t->size != targ_t->size)\n\t\treturn 0;\n\n\tif (local_vlen > targ_vlen)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < local_vlen; i++) {\n\t\tbool matched = false;\n\t\t__u32 local_n_off, targ_n_off;\n\n\t\tlocal_n_off = btf_is_enum(local_t) ? btf_enum(local_t)[i].name_off :\n\t\t\t\t\t\t     btf_enum64(local_t)[i].name_off;\n\n\t\tfor (j = 0; j < targ_vlen; j++) {\n\t\t\ttarg_n_off = btf_is_enum(targ_t) ? btf_enum(targ_t)[j].name_off :\n\t\t\t\t\t\t\t   btf_enum64(targ_t)[j].name_off;\n\n\t\t\tif (bpf_core_names_match(local_btf, local_n_off, targ_btf, targ_n_off)) {\n\t\t\t\tmatched = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int bpf_core_composites_match(const struct btf *local_btf, const struct btf_type *local_t,\n\t\t\t\t     const struct btf *targ_btf, const struct btf_type *targ_t,\n\t\t\t\t     bool behind_ptr, int level)\n{\n\tconst struct btf_member *local_m = btf_members(local_t);\n\t__u16 local_vlen = btf_vlen(local_t);\n\t__u16 targ_vlen = btf_vlen(targ_t);\n\tint i, j, err;\n\n\tif (local_vlen > targ_vlen)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < local_vlen; i++, local_m++) {\n\t\tconst struct btf_member *targ_m = btf_members(targ_t);\n\t\tbool matched = false;\n\n\t\tfor (j = 0; j < targ_vlen; j++, targ_m++) {\n\t\t\tif (!bpf_core_names_match(local_btf, local_m->name_off,\n\t\t\t\t\t\t  targ_btf, targ_m->name_off))\n\t\t\t\tcontinue;\n\n\t\t\terr = __bpf_core_types_match(local_btf, local_m->type, targ_btf,\n\t\t\t\t\t\t     targ_m->type, behind_ptr, level - 1);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err > 0) {\n\t\t\t\tmatched = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint __bpf_core_types_match(const struct btf *local_btf, __u32 local_id, const struct btf *targ_btf,\n\t\t\t   __u32 targ_id, bool behind_ptr, int level)\n{\n\tconst struct btf_type *local_t, *targ_t;\n\tint depth = 32;  \n\t__u16 local_k, targ_k;\n\n\tif (level <= 0)\n\t\treturn -EINVAL;\n\nrecur:\n\tdepth--;\n\tif (depth < 0)\n\t\treturn -EINVAL;\n\n\tlocal_t = skip_mods_and_typedefs(local_btf, local_id, &local_id);\n\ttarg_t = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!local_t || !targ_t)\n\t\treturn -EINVAL;\n\n\t \n\tif (!bpf_core_names_match(local_btf, local_t->name_off, targ_btf, targ_t->name_off))\n\t\treturn 0;\n\n\tlocal_k = btf_kind(local_t);\n\ttarg_k = btf_kind(targ_t);\n\n\tswitch (local_k) {\n\tcase BTF_KIND_UNKN:\n\t\treturn local_k == targ_k;\n\tcase BTF_KIND_FWD: {\n\t\tbool local_f = BTF_INFO_KFLAG(local_t->info);\n\n\t\tif (behind_ptr) {\n\t\t\tif (local_k == targ_k)\n\t\t\t\treturn local_f == BTF_INFO_KFLAG(targ_t->info);\n\n\t\t\t \n\t\t\treturn (targ_k == BTF_KIND_STRUCT && !local_f) ||\n\t\t\t       (targ_k == BTF_KIND_UNION && local_f);\n\t\t} else {\n\t\t\tif (local_k != targ_k)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\treturn local_f == BTF_INFO_KFLAG(targ_t->info);\n\t\t}\n\t}\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\tif (!btf_is_any_enum(targ_t))\n\t\t\treturn 0;\n\n\t\treturn bpf_core_enums_match(local_btf, local_t, targ_btf, targ_t);\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tif (behind_ptr) {\n\t\t\tbool targ_f = BTF_INFO_KFLAG(targ_t->info);\n\n\t\t\tif (local_k == targ_k)\n\t\t\t\treturn 1;\n\n\t\t\tif (targ_k != BTF_KIND_FWD)\n\t\t\t\treturn 0;\n\n\t\t\treturn (local_k == BTF_KIND_UNION) == targ_f;\n\t\t} else {\n\t\t\tif (local_k != targ_k)\n\t\t\t\treturn 0;\n\n\t\t\treturn bpf_core_composites_match(local_btf, local_t, targ_btf, targ_t,\n\t\t\t\t\t\t\t behind_ptr, level);\n\t\t}\n\tcase BTF_KIND_INT: {\n\t\t__u8 local_sgn;\n\t\t__u8 targ_sgn;\n\n\t\tif (local_k != targ_k)\n\t\t\treturn 0;\n\n\t\tlocal_sgn = btf_int_encoding(local_t) & BTF_INT_SIGNED;\n\t\ttarg_sgn = btf_int_encoding(targ_t) & BTF_INT_SIGNED;\n\n\t\treturn local_t->size == targ_t->size && local_sgn == targ_sgn;\n\t}\n\tcase BTF_KIND_PTR:\n\t\tif (local_k != targ_k)\n\t\t\treturn 0;\n\n\t\tbehind_ptr = true;\n\n\t\tlocal_id = local_t->type;\n\t\ttarg_id = targ_t->type;\n\t\tgoto recur;\n\tcase BTF_KIND_ARRAY: {\n\t\tconst struct btf_array *local_array = btf_array(local_t);\n\t\tconst struct btf_array *targ_array = btf_array(targ_t);\n\n\t\tif (local_k != targ_k)\n\t\t\treturn 0;\n\n\t\tif (local_array->nelems != targ_array->nelems)\n\t\t\treturn 0;\n\n\t\tlocal_id = local_array->type;\n\t\ttarg_id = targ_array->type;\n\t\tgoto recur;\n\t}\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *local_p = btf_params(local_t);\n\t\tstruct btf_param *targ_p = btf_params(targ_t);\n\t\t__u16 local_vlen = btf_vlen(local_t);\n\t\t__u16 targ_vlen = btf_vlen(targ_t);\n\t\tint i, err;\n\n\t\tif (local_k != targ_k)\n\t\t\treturn 0;\n\n\t\tif (local_vlen != targ_vlen)\n\t\t\treturn 0;\n\n\t\tfor (i = 0; i < local_vlen; i++, local_p++, targ_p++) {\n\t\t\terr = __bpf_core_types_match(local_btf, local_p->type, targ_btf,\n\t\t\t\t\t\t     targ_p->type, behind_ptr, level - 1);\n\t\t\tif (err <= 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tlocal_id = local_t->type;\n\t\ttarg_id = targ_t->type;\n\t\tgoto recur;\n\t}\n\tdefault:\n\t\tpr_warn(\"unexpected kind %s relocated, local [%d], target [%d]\\n\",\n\t\t\tbtf_kind_str(local_t), local_id, targ_id);\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}