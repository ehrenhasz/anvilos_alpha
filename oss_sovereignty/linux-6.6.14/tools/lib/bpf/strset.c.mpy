{
  "module_name": "strset.c",
  "hash_id": "df411190400b1dbd4bf4246aa4c7b06363a9df9b6cf8d431709e131e7057d41b",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/strset.c",
  "human_readable_source": "\n \n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <linux/err.h>\n#include \"hashmap.h\"\n#include \"libbpf_internal.h\"\n#include \"strset.h\"\n\nstruct strset {\n\tvoid *strs_data;\n\tsize_t strs_data_len;\n\tsize_t strs_data_cap;\n\tsize_t strs_data_max_len;\n\n\t \n\tstruct hashmap *strs_hash;\n};\n\nstatic size_t strset_hash_fn(long key, void *ctx)\n{\n\tconst struct strset *s = ctx;\n\tconst char *str = s->strs_data + key;\n\n\treturn str_hash(str);\n}\n\nstatic bool strset_equal_fn(long key1, long key2, void *ctx)\n{\n\tconst struct strset *s = ctx;\n\tconst char *str1 = s->strs_data + key1;\n\tconst char *str2 = s->strs_data + key2;\n\n\treturn strcmp(str1, str2) == 0;\n}\n\nstruct strset *strset__new(size_t max_data_sz, const char *init_data, size_t init_data_sz)\n{\n\tstruct strset *set = calloc(1, sizeof(*set));\n\tstruct hashmap *hash;\n\tint err = -ENOMEM;\n\n\tif (!set)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thash = hashmap__new(strset_hash_fn, strset_equal_fn, set);\n\tif (IS_ERR(hash))\n\t\tgoto err_out;\n\n\tset->strs_data_max_len = max_data_sz;\n\tset->strs_hash = hash;\n\n\tif (init_data) {\n\t\tlong off;\n\n\t\tset->strs_data = malloc(init_data_sz);\n\t\tif (!set->strs_data)\n\t\t\tgoto err_out;\n\n\t\tmemcpy(set->strs_data, init_data, init_data_sz);\n\t\tset->strs_data_len = init_data_sz;\n\t\tset->strs_data_cap = init_data_sz;\n\n\t\tfor (off = 0; off < set->strs_data_len; off += strlen(set->strs_data + off) + 1) {\n\t\t\t \n\t\t\terr = hashmap__add(hash, off, off);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tcontinue;  \n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\treturn set;\nerr_out:\n\tstrset__free(set);\n\treturn ERR_PTR(err);\n}\n\nvoid strset__free(struct strset *set)\n{\n\tif (IS_ERR_OR_NULL(set))\n\t\treturn;\n\n\thashmap__free(set->strs_hash);\n\tfree(set->strs_data);\n\tfree(set);\n}\n\nsize_t strset__data_size(const struct strset *set)\n{\n\treturn set->strs_data_len;\n}\n\nconst char *strset__data(const struct strset *set)\n{\n\treturn set->strs_data;\n}\n\nstatic void *strset_add_str_mem(struct strset *set, size_t add_sz)\n{\n\treturn libbpf_add_mem(&set->strs_data, &set->strs_data_cap, 1,\n\t\t\t      set->strs_data_len, set->strs_data_max_len, add_sz);\n}\n\n \nint strset__find_str(struct strset *set, const char *s)\n{\n\tlong old_off, new_off, len;\n\tvoid *p;\n\n\t \n\tlen = strlen(s) + 1;\n\tp = strset_add_str_mem(set, len);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tnew_off = set->strs_data_len;\n\tmemcpy(p, s, len);\n\n\tif (hashmap__find(set->strs_hash, new_off, &old_off))\n\t\treturn old_off;\n\n\treturn -ENOENT;\n}\n\n \nint strset__add_str(struct strset *set, const char *s)\n{\n\tlong old_off, new_off, len;\n\tvoid *p;\n\tint err;\n\n\t \n\tlen = strlen(s) + 1;\n\tp = strset_add_str_mem(set, len);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tnew_off = set->strs_data_len;\n\tmemcpy(p, s, len);\n\n\t \n\terr = hashmap__insert(set->strs_hash, new_off, new_off,\n\t\t\t      HASHMAP_ADD, &old_off, NULL);\n\tif (err == -EEXIST)\n\t\treturn old_off;  \n\tif (err)\n\t\treturn err;\n\n\tset->strs_data_len += len;  \n\treturn new_off;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}