{
  "module_name": "skel_internal.h",
  "hash_id": "912f1c7b89b5e9cdfd578c7291cedbdeef071a418755fabbb45b348332e86f4b",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/skel_internal.h",
  "human_readable_source": " \n \n#ifndef __SKEL_INTERNAL_H\n#define __SKEL_INTERNAL_H\n\n#ifdef __KERNEL__\n#include <linux/fdtable.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#else\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include \"bpf.h\"\n#endif\n\n#ifndef __NR_bpf\n# if defined(__mips__) && defined(_ABIO32)\n#  define __NR_bpf 4355\n# elif defined(__mips__) && defined(_ABIN32)\n#  define __NR_bpf 6319\n# elif defined(__mips__) && defined(_ABI64)\n#  define __NR_bpf 5315\n# endif\n#endif\n\n \nstruct bpf_map_desc {\n\t \n\tint map_fd;\n\t \n\t__u32 max_entries;\n\t__aligned_u64 initial_value;\n};\nstruct bpf_prog_desc {\n\tint prog_fd;\n};\n\nenum {\n\tBPF_SKEL_KERNEL = (1ULL << 0),\n};\n\nstruct bpf_loader_ctx {\n\t__u32 sz;\n\t__u32 flags;\n\t__u32 log_level;\n\t__u32 log_size;\n\t__u64 log_buf;\n};\n\nstruct bpf_load_and_run_opts {\n\tstruct bpf_loader_ctx *ctx;\n\tconst void *data;\n\tconst void *insns;\n\t__u32 data_sz;\n\t__u32 insns_sz;\n\tconst char *errstr;\n};\n\nlong kern_sys_bpf(__u32 cmd, void *attr, __u32 attr_size);\n\nstatic inline int skel_sys_bpf(enum bpf_cmd cmd, union bpf_attr *attr,\n\t\t\t  unsigned int size)\n{\n#ifdef __KERNEL__\n\treturn kern_sys_bpf(cmd, attr, size);\n#else\n\treturn syscall(__NR_bpf, cmd, attr, size);\n#endif\n}\n\n#ifdef __KERNEL__\nstatic inline int close(int fd)\n{\n\treturn close_fd(fd);\n}\n\nstatic inline void *skel_alloc(size_t size)\n{\n\tstruct bpf_loader_ctx *ctx = kzalloc(size, GFP_KERNEL);\n\n\tif (!ctx)\n\t\treturn NULL;\n\tctx->flags |= BPF_SKEL_KERNEL;\n\treturn ctx;\n}\n\nstatic inline void skel_free(const void *p)\n{\n\tkfree(p);\n}\n\n \nstatic inline void skel_free_map_data(void *p, __u64 addr, size_t sz)\n{\n\tif (addr != ~0ULL)\n\t\tkvfree(p);\n\t \n}\n\nstatic inline void *skel_prep_map_data(const void *val, size_t mmap_sz, size_t val_sz)\n{\n\tvoid *addr;\n\n\taddr = kvmalloc(val_sz, GFP_KERNEL);\n\tif (!addr)\n\t\treturn NULL;\n\tmemcpy(addr, val, val_sz);\n\treturn addr;\n}\n\nstatic inline void *skel_finalize_map_data(__u64 *init_val, size_t mmap_sz, int flags, int fd)\n{\n\tstruct bpf_map *map;\n\tvoid *addr = NULL;\n\n\tkvfree((void *) (long) *init_val);\n\t*init_val = ~0ULL;\n\n\t \n\tmap = bpf_map_get(fd);\n\tif (IS_ERR(map))\n\t\treturn NULL;\n\tif (map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\tgoto out;\n\taddr = ((struct bpf_array *)map)->value;\n\t \nout:\n\tbpf_map_put(map);\n\treturn addr;\n}\n\n#else\n\nstatic inline void *skel_alloc(size_t size)\n{\n\treturn calloc(1, size);\n}\n\nstatic inline void skel_free(void *p)\n{\n\tfree(p);\n}\n\nstatic inline void skel_free_map_data(void *p, __u64 addr, size_t sz)\n{\n\tmunmap(p, sz);\n}\n\nstatic inline void *skel_prep_map_data(const void *val, size_t mmap_sz, size_t val_sz)\n{\n\tvoid *addr;\n\n\taddr = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE,\n\t\t    MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tif (addr == (void *) -1)\n\t\treturn NULL;\n\tmemcpy(addr, val, val_sz);\n\treturn addr;\n}\n\nstatic inline void *skel_finalize_map_data(__u64 *init_val, size_t mmap_sz, int flags, int fd)\n{\n\tvoid *addr;\n\n\taddr = mmap((void *) (long) *init_val, mmap_sz, flags, MAP_SHARED | MAP_FIXED, fd, 0);\n\tif (addr == (void *) -1)\n\t\treturn NULL;\n\treturn addr;\n}\n#endif\n\nstatic inline int skel_closenz(int fd)\n{\n\tif (fd > 0)\n\t\treturn close(fd);\n\treturn -EINVAL;\n}\n\n#ifndef offsetofend\n#define offsetofend(TYPE, MEMBER) \\\n\t(offsetof(TYPE, MEMBER)\t+ sizeof((((TYPE *)0)->MEMBER)))\n#endif\n\nstatic inline int skel_map_create(enum bpf_map_type map_type,\n\t\t\t\t  const char *map_name,\n\t\t\t\t  __u32 key_size,\n\t\t\t\t  __u32 value_size,\n\t\t\t\t  __u32 max_entries)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, map_extra);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\n\tattr.map_type = map_type;\n\tstrncpy(attr.map_name, map_name, sizeof(attr.map_name));\n\tattr.key_size = key_size;\n\tattr.value_size = value_size;\n\tattr.max_entries = max_entries;\n\n\treturn skel_sys_bpf(BPF_MAP_CREATE, &attr, attr_sz);\n}\n\nstatic inline int skel_map_update_elem(int fd, const void *key,\n\t\t\t\t       const void *value, __u64 flags)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, flags);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\tattr.map_fd = fd;\n\tattr.key = (long) key;\n\tattr.value = (long) value;\n\tattr.flags = flags;\n\n\treturn skel_sys_bpf(BPF_MAP_UPDATE_ELEM, &attr, attr_sz);\n}\n\nstatic inline int skel_map_delete_elem(int fd, const void *key)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, flags);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\tattr.map_fd = fd;\n\tattr.key = (long)key;\n\n\treturn skel_sys_bpf(BPF_MAP_DELETE_ELEM, &attr, attr_sz);\n}\n\nstatic inline int skel_map_get_fd_by_id(__u32 id)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, flags);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\tattr.map_id = id;\n\n\treturn skel_sys_bpf(BPF_MAP_GET_FD_BY_ID, &attr, attr_sz);\n}\n\nstatic inline int skel_raw_tracepoint_open(const char *name, int prog_fd)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, raw_tracepoint.prog_fd);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\tattr.raw_tracepoint.name = (long) name;\n\tattr.raw_tracepoint.prog_fd = prog_fd;\n\n\treturn skel_sys_bpf(BPF_RAW_TRACEPOINT_OPEN, &attr, attr_sz);\n}\n\nstatic inline int skel_link_create(int prog_fd, int target_fd,\n\t\t\t\t   enum bpf_attach_type attach_type)\n{\n\tconst size_t attr_sz = offsetofend(union bpf_attr, link_create.iter_info_len);\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, attr_sz);\n\tattr.link_create.prog_fd = prog_fd;\n\tattr.link_create.target_fd = target_fd;\n\tattr.link_create.attach_type = attach_type;\n\n\treturn skel_sys_bpf(BPF_LINK_CREATE, &attr, attr_sz);\n}\n\n#ifdef __KERNEL__\n#define set_err\n#else\n#define set_err err = -errno\n#endif\n\nstatic inline int bpf_load_and_run(struct bpf_load_and_run_opts *opts)\n{\n\tconst size_t prog_load_attr_sz = offsetofend(union bpf_attr, fd_array);\n\tconst size_t test_run_attr_sz = offsetofend(union bpf_attr, test);\n\tint map_fd = -1, prog_fd = -1, key = 0, err;\n\tunion bpf_attr attr;\n\n\terr = map_fd = skel_map_create(BPF_MAP_TYPE_ARRAY, \"__loader.map\", 4, opts->data_sz, 1);\n\tif (map_fd < 0) {\n\t\topts->errstr = \"failed to create loader map\";\n\t\tset_err;\n\t\tgoto out;\n\t}\n\n\terr = skel_map_update_elem(map_fd, &key, opts->data, 0);\n\tif (err < 0) {\n\t\topts->errstr = \"failed to update loader map\";\n\t\tset_err;\n\t\tgoto out;\n\t}\n\n\tmemset(&attr, 0, prog_load_attr_sz);\n\tattr.prog_type = BPF_PROG_TYPE_SYSCALL;\n\tattr.insns = (long) opts->insns;\n\tattr.insn_cnt = opts->insns_sz / sizeof(struct bpf_insn);\n\tattr.license = (long) \"Dual BSD/GPL\";\n\tmemcpy(attr.prog_name, \"__loader.prog\", sizeof(\"__loader.prog\"));\n\tattr.fd_array = (long) &map_fd;\n\tattr.log_level = opts->ctx->log_level;\n\tattr.log_size = opts->ctx->log_size;\n\tattr.log_buf = opts->ctx->log_buf;\n\tattr.prog_flags = BPF_F_SLEEPABLE;\n\terr = prog_fd = skel_sys_bpf(BPF_PROG_LOAD, &attr, prog_load_attr_sz);\n\tif (prog_fd < 0) {\n\t\topts->errstr = \"failed to load loader prog\";\n\t\tset_err;\n\t\tgoto out;\n\t}\n\n\tmemset(&attr, 0, test_run_attr_sz);\n\tattr.test.prog_fd = prog_fd;\n\tattr.test.ctx_in = (long) opts->ctx;\n\tattr.test.ctx_size_in = opts->ctx->sz;\n\terr = skel_sys_bpf(BPF_PROG_RUN, &attr, test_run_attr_sz);\n\tif (err < 0 || (int)attr.test.retval < 0) {\n\t\topts->errstr = \"failed to execute loader prog\";\n\t\tif (err < 0) {\n\t\t\tset_err;\n\t\t} else {\n\t\t\terr = (int)attr.test.retval;\n#ifndef __KERNEL__\n\t\t\terrno = -err;\n#endif\n\t\t}\n\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\tif (map_fd >= 0)\n\t\tclose(map_fd);\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\treturn err;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}