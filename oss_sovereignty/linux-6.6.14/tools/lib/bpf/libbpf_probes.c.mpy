{
  "module_name": "libbpf_probes.c",
  "hash_id": "4b5e3d240ece9b2c12b563e9c38edd827844e0fbe5df92a85fb69b3b333b0929",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/libbpf_probes.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <net/if.h>\n#include <sys/utsname.h>\n\n#include <linux/btf.h>\n#include <linux/filter.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n\n#include \"bpf.h\"\n#include \"libbpf.h\"\n#include \"libbpf_internal.h\"\n\n \nstatic __u32 get_ubuntu_kernel_version(void)\n{\n\tconst char *ubuntu_kver_file = \"/proc/version_signature\";\n\t__u32 major, minor, patch;\n\tint ret;\n\tFILE *f;\n\n\tif (faccessat(AT_FDCWD, ubuntu_kver_file, R_OK, AT_EACCESS) != 0)\n\t\treturn 0;\n\n\tf = fopen(ubuntu_kver_file, \"re\");\n\tif (!f)\n\t\treturn 0;\n\n\tret = fscanf(f, \"%*s %*s %u.%u.%u\\n\", &major, &minor, &patch);\n\tfclose(f);\n\tif (ret != 3)\n\t\treturn 0;\n\n\treturn KERNEL_VERSION(major, minor, patch);\n}\n\n \nstatic __u32 get_debian_kernel_version(struct utsname *info)\n{\n\t__u32 major, minor, patch;\n\tchar *p;\n\n\tp = strstr(info->version, \"Debian \");\n\tif (!p) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (sscanf(p, \"Debian %u.%u.%u\", &major, &minor, &patch) != 3)\n\t\treturn 0;\n\n\treturn KERNEL_VERSION(major, minor, patch);\n}\n\n__u32 get_kernel_version(void)\n{\n\t__u32 major, minor, patch, version;\n\tstruct utsname info;\n\n\t \n\tversion = get_ubuntu_kernel_version();\n\tif (version != 0)\n\t\treturn version;\n\n\tuname(&info);\n\n\t \n\tversion = get_debian_kernel_version(&info);\n\tif (version != 0)\n\t\treturn version;\n\n\tif (sscanf(info.release, \"%u.%u.%u\", &major, &minor, &patch) != 3)\n\t\treturn 0;\n\n\treturn KERNEL_VERSION(major, minor, patch);\n}\n\nstatic int probe_prog_load(enum bpf_prog_type prog_type,\n\t\t\t   const struct bpf_insn *insns, size_t insns_cnt,\n\t\t\t   char *log_buf, size_t log_buf_sz)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.log_buf = log_buf,\n\t\t.log_size = log_buf_sz,\n\t\t.log_level = log_buf ? 1 : 0,\n\t);\n\tint fd, err, exp_err = 0;\n\tconst char *exp_msg = NULL;\n\tchar buf[4096];\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\topts.expected_attach_type = BPF_CGROUP_INET4_CONNECT;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\topts.expected_attach_type = BPF_CGROUP_GETSOCKOPT;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\topts.expected_attach_type = BPF_SK_LOOKUP;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_KPROBE:\n\t\topts.kern_version = get_kernel_version();\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\topts.expected_attach_type = BPF_LIRC_MODE2;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_LSM:\n\t\topts.log_buf = buf;\n\t\topts.log_size = sizeof(buf);\n\t\topts.log_level = 1;\n\t\tif (prog_type == BPF_PROG_TYPE_TRACING)\n\t\t\topts.expected_attach_type = BPF_TRACE_FENTRY;\n\t\telse\n\t\t\topts.expected_attach_type = BPF_MODIFY_RETURN;\n\t\topts.attach_btf_id = 1;\n\n\t\texp_err = -EINVAL;\n\t\texp_msg = \"attach_btf_id 1 is not a function\";\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\topts.log_buf = buf;\n\t\topts.log_size = sizeof(buf);\n\t\topts.log_level = 1;\n\t\topts.attach_btf_id = 1;\n\n\t\texp_err = -EINVAL;\n\t\texp_msg = \"Cannot replace kernel functions\";\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SYSCALL:\n\t\topts.prog_flags = BPF_F_SLEEPABLE;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\texp_err = -524;  \n\t\tbreak;\n\tcase BPF_PROG_TYPE_UNSPEC:\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\t\tbreak;\n\tcase BPF_PROG_TYPE_NETFILTER:\n\t\topts.expected_attach_type = BPF_NETFILTER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfd = bpf_prog_load(prog_type, NULL, \"GPL\", insns, insns_cnt, &opts);\n\terr = -errno;\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (exp_err) {\n\t\tif (fd >= 0 || err != exp_err)\n\t\t\treturn 0;\n\t\tif (exp_msg && !strstr(buf, exp_msg))\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\treturn fd >= 0 ? 1 : 0;\n}\n\nint libbpf_probe_bpf_prog_type(enum bpf_prog_type prog_type, const void *opts)\n{\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN()\n\t};\n\tconst size_t insn_cnt = ARRAY_SIZE(insns);\n\tint ret;\n\n\tif (opts)\n\t\treturn libbpf_err(-EINVAL);\n\n\tret = probe_prog_load(prog_type, insns, insn_cnt, NULL, 0);\n\treturn libbpf_err(ret);\n}\n\nint libbpf__load_raw_btf(const char *raw_types, size_t types_len,\n\t\t\t const char *str_sec, size_t str_len)\n{\n\tstruct btf_header hdr = {\n\t\t.magic = BTF_MAGIC,\n\t\t.version = BTF_VERSION,\n\t\t.hdr_len = sizeof(struct btf_header),\n\t\t.type_len = types_len,\n\t\t.str_off = types_len,\n\t\t.str_len = str_len,\n\t};\n\tint btf_fd, btf_len;\n\t__u8 *raw_btf;\n\n\tbtf_len = hdr.hdr_len + hdr.type_len + hdr.str_len;\n\traw_btf = malloc(btf_len);\n\tif (!raw_btf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(raw_btf, &hdr, sizeof(hdr));\n\tmemcpy(raw_btf + hdr.hdr_len, raw_types, hdr.type_len);\n\tmemcpy(raw_btf + hdr.hdr_len + hdr.type_len, str_sec, hdr.str_len);\n\n\tbtf_fd = bpf_btf_load(raw_btf, btf_len, NULL);\n\n\tfree(raw_btf);\n\treturn btf_fd;\n}\n\nstatic int load_local_storage_btf(void)\n{\n\tconst char strs[] = \"\\0bpf_spin_lock\\0val\\0cnt\\0l\";\n\t \n\t__u32 types[] = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),   \n\t\t                        \n\t\tBTF_TYPE_ENC(1, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\n\t\tBTF_MEMBER_ENC(15, 1, 0),  \n\t\t                                  \n\t\tBTF_TYPE_ENC(15, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(19, 1, 0),  \n\t\tBTF_MEMBER_ENC(23, 2, 32), \n\t};\n\n\treturn libbpf__load_raw_btf((char *)types, sizeof(types),\n\t\t\t\t     strs, sizeof(strs));\n}\n\nstatic int probe_map_create(enum bpf_map_type map_type)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tint key_size, value_size, max_entries;\n\t__u32 btf_key_type_id = 0, btf_value_type_id = 0;\n\tint fd = -1, btf_fd = -1, fd_inner = -1, exp_err = 0, err = 0;\n\n\tkey_size\t= sizeof(__u32);\n\tvalue_size\t= sizeof(__u32);\n\tmax_entries\t= 1;\n\n\tswitch (map_type) {\n\tcase BPF_MAP_TYPE_STACK_TRACE:\n\t\tvalue_size\t= sizeof(__u64);\n\t\tbreak;\n\tcase BPF_MAP_TYPE_LPM_TRIE:\n\t\tkey_size\t= sizeof(__u64);\n\t\tvalue_size\t= sizeof(__u64);\n\t\topts.map_flags\t= BPF_F_NO_PREALLOC;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_CGROUP_STORAGE:\n\tcase BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE:\n\t\tkey_size\t= sizeof(struct bpf_cgroup_storage_key);\n\t\tvalue_size\t= sizeof(__u64);\n\t\tmax_entries\t= 0;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_QUEUE:\n\tcase BPF_MAP_TYPE_STACK:\n\t\tkey_size\t= 0;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_SK_STORAGE:\n\tcase BPF_MAP_TYPE_INODE_STORAGE:\n\tcase BPF_MAP_TYPE_TASK_STORAGE:\n\tcase BPF_MAP_TYPE_CGRP_STORAGE:\n\t\tbtf_key_type_id = 1;\n\t\tbtf_value_type_id = 3;\n\t\tvalue_size = 8;\n\t\tmax_entries = 0;\n\t\topts.map_flags = BPF_F_NO_PREALLOC;\n\t\tbtf_fd = load_local_storage_btf();\n\t\tif (btf_fd < 0)\n\t\t\treturn btf_fd;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_RINGBUF:\n\tcase BPF_MAP_TYPE_USER_RINGBUF:\n\t\tkey_size = 0;\n\t\tvalue_size = 0;\n\t\tmax_entries = sysconf(_SC_PAGE_SIZE);\n\t\tbreak;\n\tcase BPF_MAP_TYPE_STRUCT_OPS:\n\t\t \n\t\topts.btf_vmlinux_value_type_id = 1;\n\t\texp_err = -524;  \n\t\tbreak;\n\tcase BPF_MAP_TYPE_BLOOM_FILTER:\n\t\tkey_size = 0;\n\t\tmax_entries = 1;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_HASH:\n\tcase BPF_MAP_TYPE_ARRAY:\n\tcase BPF_MAP_TYPE_PROG_ARRAY:\n\tcase BPF_MAP_TYPE_PERF_EVENT_ARRAY:\n\tcase BPF_MAP_TYPE_PERCPU_HASH:\n\tcase BPF_MAP_TYPE_PERCPU_ARRAY:\n\tcase BPF_MAP_TYPE_CGROUP_ARRAY:\n\tcase BPF_MAP_TYPE_LRU_HASH:\n\tcase BPF_MAP_TYPE_LRU_PERCPU_HASH:\n\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\tcase BPF_MAP_TYPE_DEVMAP:\n\tcase BPF_MAP_TYPE_DEVMAP_HASH:\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\tcase BPF_MAP_TYPE_CPUMAP:\n\tcase BPF_MAP_TYPE_XSKMAP:\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\tcase BPF_MAP_TYPE_REUSEPORT_SOCKARRAY:\n\t\tbreak;\n\tcase BPF_MAP_TYPE_UNSPEC:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||\n\t    map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\tfd_inner = bpf_map_create(BPF_MAP_TYPE_HASH, NULL,\n\t\t\t\t\t  sizeof(__u32), sizeof(__u32), 1, NULL);\n\t\tif (fd_inner < 0)\n\t\t\tgoto cleanup;\n\n\t\topts.inner_map_fd = fd_inner;\n\t}\n\n\tif (btf_fd >= 0) {\n\t\topts.btf_fd = btf_fd;\n\t\topts.btf_key_type_id = btf_key_type_id;\n\t\topts.btf_value_type_id = btf_value_type_id;\n\t}\n\n\tfd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries, &opts);\n\terr = -errno;\n\ncleanup:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (fd_inner >= 0)\n\t\tclose(fd_inner);\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n\n\tif (exp_err)\n\t\treturn fd < 0 && err == exp_err ? 1 : 0;\n\telse\n\t\treturn fd >= 0 ? 1 : 0;\n}\n\nint libbpf_probe_bpf_map_type(enum bpf_map_type map_type, const void *opts)\n{\n\tint ret;\n\n\tif (opts)\n\t\treturn libbpf_err(-EINVAL);\n\n\tret = probe_map_create(map_type);\n\treturn libbpf_err(ret);\n}\n\nint libbpf_probe_bpf_helper(enum bpf_prog_type prog_type, enum bpf_func_id helper_id,\n\t\t\t    const void *opts)\n{\n\tstruct bpf_insn insns[] = {\n\t\tBPF_EMIT_CALL((__u32)helper_id),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tconst size_t insn_cnt = ARRAY_SIZE(insns);\n\tchar buf[4096];\n\tint ret;\n\n\tif (opts)\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_EXT:\n\tcase BPF_PROG_TYPE_LSM:\n\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbuf[0] = '\\0';\n\tret = probe_prog_load(prog_type, insns, insn_cnt, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\n\t \n\tif (ret == 0 && (strstr(buf, \"invalid func \") || strstr(buf, \"unknown func \")))\n\t\treturn 0;\n\treturn 1;  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}