{
  "module_name": "btf.c",
  "hash_id": "64b0900ec438b3567973a6fdeaae10831f12c1e685803e5ba7444550a5ab07cb",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/btf.c",
  "human_readable_source": "\n \n\n#include <byteswap.h>\n#include <endian.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <gelf.h>\n#include \"btf.h\"\n#include \"bpf.h\"\n#include \"libbpf.h\"\n#include \"libbpf_internal.h\"\n#include \"hashmap.h\"\n#include \"strset.h\"\n\n#define BTF_MAX_NR_TYPES 0x7fffffffU\n#define BTF_MAX_STR_OFFSET 0x7fffffffU\n\nstatic struct btf_type btf_void;\n\nstruct btf {\n\t \n\tvoid *raw_data;\n\t \n\tvoid *raw_data_swapped;\n\t__u32 raw_size;\n\t \n\tbool swapped_endian;\n\n\t \n\tstruct btf_header *hdr;\n\n\tvoid *types_data;\n\tsize_t types_data_cap;  \n\n\t \n\t__u32 *type_offs;\n\tsize_t type_offs_cap;\n\t \n\t__u32 nr_types;\n\t \n\tstruct btf *base_btf;\n\t \n\tint start_id;\n\t \n\tint start_str_off;\n\n\t \n\tvoid *strs_data;\n\t \n\tstruct strset *strs_set;\n\t \n\tbool strs_deduped;\n\n\t \n\tint fd;\n\n\t \n\tint ptr_sz;\n};\n\nstatic inline __u64 ptr_to_u64(const void *ptr)\n{\n\treturn (__u64) (unsigned long) ptr;\n}\n\n \nvoid *libbpf_add_mem(void **data, size_t *cap_cnt, size_t elem_sz,\n\t\t     size_t cur_cnt, size_t max_cnt, size_t add_cnt)\n{\n\tsize_t new_cnt;\n\tvoid *new_data;\n\n\tif (cur_cnt + add_cnt <= *cap_cnt)\n\t\treturn *data + cur_cnt * elem_sz;\n\n\t \n\tif (cur_cnt + add_cnt > max_cnt)\n\t\treturn NULL;\n\n\tnew_cnt = *cap_cnt;\n\tnew_cnt += new_cnt / 4;\t\t   \n\tif (new_cnt < 16)\t\t   \n\t\tnew_cnt = 16;\n\tif (new_cnt > max_cnt)\t\t   \n\t\tnew_cnt = max_cnt;\n\tif (new_cnt < cur_cnt + add_cnt)   \n\t\tnew_cnt = cur_cnt + add_cnt;\n\n\tnew_data = libbpf_reallocarray(*data, new_cnt, elem_sz);\n\tif (!new_data)\n\t\treturn NULL;\n\n\t \n\tmemset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);\n\n\t*data = new_data;\n\t*cap_cnt = new_cnt;\n\treturn new_data + cur_cnt * elem_sz;\n}\n\n \nint libbpf_ensure_mem(void **data, size_t *cap_cnt, size_t elem_sz, size_t need_cnt)\n{\n\tvoid *p;\n\n\tif (need_cnt <= *cap_cnt)\n\t\treturn 0;\n\n\tp = libbpf_add_mem(data, cap_cnt, elem_sz, *cap_cnt, SIZE_MAX, need_cnt - *cap_cnt);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void *btf_add_type_offs_mem(struct btf *btf, size_t add_cnt)\n{\n\treturn libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),\n\t\t\t      btf->nr_types, BTF_MAX_NR_TYPES, add_cnt);\n}\n\nstatic int btf_add_type_idx_entry(struct btf *btf, __u32 type_off)\n{\n\t__u32 *p;\n\n\tp = btf_add_type_offs_mem(btf, 1);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t*p = type_off;\n\treturn 0;\n}\n\nstatic void btf_bswap_hdr(struct btf_header *h)\n{\n\th->magic = bswap_16(h->magic);\n\th->hdr_len = bswap_32(h->hdr_len);\n\th->type_off = bswap_32(h->type_off);\n\th->type_len = bswap_32(h->type_len);\n\th->str_off = bswap_32(h->str_off);\n\th->str_len = bswap_32(h->str_len);\n}\n\nstatic int btf_parse_hdr(struct btf *btf)\n{\n\tstruct btf_header *hdr = btf->hdr;\n\t__u32 meta_left;\n\n\tif (btf->raw_size < sizeof(struct btf_header)) {\n\t\tpr_debug(\"BTF header not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->magic == bswap_16(BTF_MAGIC)) {\n\t\tbtf->swapped_endian = true;\n\t\tif (bswap_32(hdr->hdr_len) != sizeof(struct btf_header)) {\n\t\t\tpr_warn(\"Can't load BTF with non-native endianness due to unsupported header length %u\\n\",\n\t\t\t\tbswap_32(hdr->hdr_len));\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tbtf_bswap_hdr(hdr);\n\t} else if (hdr->magic != BTF_MAGIC) {\n\t\tpr_debug(\"Invalid BTF magic: %x\\n\", hdr->magic);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf->raw_size < hdr->hdr_len) {\n\t\tpr_debug(\"BTF header len %u larger than data size %u\\n\",\n\t\t\t hdr->hdr_len, btf->raw_size);\n\t\treturn -EINVAL;\n\t}\n\n\tmeta_left = btf->raw_size - hdr->hdr_len;\n\tif (meta_left < (long long)hdr->str_off + hdr->str_len) {\n\t\tpr_debug(\"Invalid BTF total size: %u\\n\", btf->raw_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((long long)hdr->type_off + hdr->type_len > hdr->str_off) {\n\t\tpr_debug(\"Invalid BTF data sections layout: type data at %u + %u, strings data at %u + %u\\n\",\n\t\t\t hdr->type_off, hdr->type_len, hdr->str_off, hdr->str_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->type_off % 4) {\n\t\tpr_debug(\"BTF type section is not aligned to 4 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_parse_str_sec(struct btf *btf)\n{\n\tconst struct btf_header *hdr = btf->hdr;\n\tconst char *start = btf->strs_data;\n\tconst char *end = start + btf->hdr->str_len;\n\n\tif (btf->base_btf && hdr->str_len == 0)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_STR_OFFSET || end[-1]) {\n\t\tpr_debug(\"Invalid BTF string section\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tpr_debug(\"Invalid BTF string section\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int btf_type_size(const struct btf_type *t)\n{\n\tconst int base_size = sizeof(struct btf_type);\n\t__u16 vlen = btf_vlen(t);\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn base_size;\n\tcase BTF_KIND_INT:\n\t\treturn base_size + sizeof(__u32);\n\tcase BTF_KIND_ENUM:\n\t\treturn base_size + vlen * sizeof(struct btf_enum);\n\tcase BTF_KIND_ENUM64:\n\t\treturn base_size + vlen * sizeof(struct btf_enum64);\n\tcase BTF_KIND_ARRAY:\n\t\treturn base_size + sizeof(struct btf_array);\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\treturn base_size + vlen * sizeof(struct btf_member);\n\tcase BTF_KIND_FUNC_PROTO:\n\t\treturn base_size + vlen * sizeof(struct btf_param);\n\tcase BTF_KIND_VAR:\n\t\treturn base_size + sizeof(struct btf_var);\n\tcase BTF_KIND_DATASEC:\n\t\treturn base_size + vlen * sizeof(struct btf_var_secinfo);\n\tcase BTF_KIND_DECL_TAG:\n\t\treturn base_size + sizeof(struct btf_decl_tag);\n\tdefault:\n\t\tpr_debug(\"Unsupported BTF_KIND:%u\\n\", btf_kind(t));\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void btf_bswap_type_base(struct btf_type *t)\n{\n\tt->name_off = bswap_32(t->name_off);\n\tt->info = bswap_32(t->info);\n\tt->type = bswap_32(t->type);\n}\n\nstatic int btf_bswap_type_rest(struct btf_type *t)\n{\n\tstruct btf_var_secinfo *v;\n\tstruct btf_enum64 *e64;\n\tstruct btf_member *m;\n\tstruct btf_array *a;\n\tstruct btf_param *p;\n\tstruct btf_enum *e;\n\t__u16 vlen = btf_vlen(t);\n\tint i;\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn 0;\n\tcase BTF_KIND_INT:\n\t\t*(__u32 *)(t + 1) = bswap_32(*(__u32 *)(t + 1));\n\t\treturn 0;\n\tcase BTF_KIND_ENUM:\n\t\tfor (i = 0, e = btf_enum(t); i < vlen; i++, e++) {\n\t\t\te->name_off = bswap_32(e->name_off);\n\t\t\te->val = bswap_32(e->val);\n\t\t}\n\t\treturn 0;\n\tcase BTF_KIND_ENUM64:\n\t\tfor (i = 0, e64 = btf_enum64(t); i < vlen; i++, e64++) {\n\t\t\te64->name_off = bswap_32(e64->name_off);\n\t\t\te64->val_lo32 = bswap_32(e64->val_lo32);\n\t\t\te64->val_hi32 = bswap_32(e64->val_hi32);\n\t\t}\n\t\treturn 0;\n\tcase BTF_KIND_ARRAY:\n\t\ta = btf_array(t);\n\t\ta->type = bswap_32(a->type);\n\t\ta->index_type = bswap_32(a->index_type);\n\t\ta->nelems = bswap_32(a->nelems);\n\t\treturn 0;\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tfor (i = 0, m = btf_members(t); i < vlen; i++, m++) {\n\t\t\tm->name_off = bswap_32(m->name_off);\n\t\t\tm->type = bswap_32(m->type);\n\t\t\tm->offset = bswap_32(m->offset);\n\t\t}\n\t\treturn 0;\n\tcase BTF_KIND_FUNC_PROTO:\n\t\tfor (i = 0, p = btf_params(t); i < vlen; i++, p++) {\n\t\t\tp->name_off = bswap_32(p->name_off);\n\t\t\tp->type = bswap_32(p->type);\n\t\t}\n\t\treturn 0;\n\tcase BTF_KIND_VAR:\n\t\tbtf_var(t)->linkage = bswap_32(btf_var(t)->linkage);\n\t\treturn 0;\n\tcase BTF_KIND_DATASEC:\n\t\tfor (i = 0, v = btf_var_secinfos(t); i < vlen; i++, v++) {\n\t\t\tv->type = bswap_32(v->type);\n\t\t\tv->offset = bswap_32(v->offset);\n\t\t\tv->size = bswap_32(v->size);\n\t\t}\n\t\treturn 0;\n\tcase BTF_KIND_DECL_TAG:\n\t\tbtf_decl_tag(t)->component_idx = bswap_32(btf_decl_tag(t)->component_idx);\n\t\treturn 0;\n\tdefault:\n\t\tpr_debug(\"Unsupported BTF_KIND:%u\\n\", btf_kind(t));\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int btf_parse_type_sec(struct btf *btf)\n{\n\tstruct btf_header *hdr = btf->hdr;\n\tvoid *next_type = btf->types_data;\n\tvoid *end_type = next_type + hdr->type_len;\n\tint err, type_size;\n\n\twhile (next_type + sizeof(struct btf_type) <= end_type) {\n\t\tif (btf->swapped_endian)\n\t\t\tbtf_bswap_type_base(next_type);\n\n\t\ttype_size = btf_type_size(next_type);\n\t\tif (type_size < 0)\n\t\t\treturn type_size;\n\t\tif (next_type + type_size > end_type) {\n\t\t\tpr_warn(\"BTF type [%d] is malformed\\n\", btf->start_id + btf->nr_types);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf->swapped_endian && btf_bswap_type_rest(next_type))\n\t\t\treturn -EINVAL;\n\n\t\terr = btf_add_type_idx_entry(btf, next_type - btf->types_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnext_type += type_size;\n\t\tbtf->nr_types++;\n\t}\n\n\tif (next_type != end_type) {\n\t\tpr_warn(\"BTF types data is malformed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n__u32 btf__type_cnt(const struct btf *btf)\n{\n\treturn btf->start_id + btf->nr_types;\n}\n\nconst struct btf *btf__base_btf(const struct btf *btf)\n{\n\treturn btf->base_btf;\n}\n\n \nstruct btf_type *btf_type_by_id(const struct btf *btf, __u32 type_id)\n{\n\tif (type_id == 0)\n\t\treturn &btf_void;\n\tif (type_id < btf->start_id)\n\t\treturn btf_type_by_id(btf->base_btf, type_id);\n\treturn btf->types_data + btf->type_offs[type_id - btf->start_id];\n}\n\nconst struct btf_type *btf__type_by_id(const struct btf *btf, __u32 type_id)\n{\n\tif (type_id >= btf->start_id + btf->nr_types)\n\t\treturn errno = EINVAL, NULL;\n\treturn btf_type_by_id((struct btf *)btf, type_id);\n}\n\nstatic int determine_ptr_size(const struct btf *btf)\n{\n\tstatic const char * const long_aliases[] = {\n\t\t\"long\",\n\t\t\"long int\",\n\t\t\"int long\",\n\t\t\"unsigned long\",\n\t\t\"long unsigned\",\n\t\t\"unsigned long int\",\n\t\t\"unsigned int long\",\n\t\t\"long unsigned int\",\n\t\t\"long int unsigned\",\n\t\t\"int unsigned long\",\n\t\t\"int long unsigned\",\n\t};\n\tconst struct btf_type *t;\n\tconst char *name;\n\tint i, j, n;\n\n\tif (btf->base_btf && btf->base_btf->ptr_sz > 0)\n\t\treturn btf->base_btf->ptr_sz;\n\n\tn = btf__type_cnt(btf);\n\tfor (i = 1; i < n; i++) {\n\t\tt = btf__type_by_id(btf, i);\n\t\tif (!btf_is_int(t))\n\t\t\tcontinue;\n\n\t\tif (t->size != 4 && t->size != 8)\n\t\t\tcontinue;\n\n\t\tname = btf__name_by_offset(btf, t->name_off);\n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(long_aliases); j++) {\n\t\t\tif (strcmp(name, long_aliases[j]) == 0)\n\t\t\t\treturn t->size;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic size_t btf_ptr_sz(const struct btf *btf)\n{\n\tif (!btf->ptr_sz)\n\t\t((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);\n\treturn btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;\n}\n\n \nsize_t btf__pointer_size(const struct btf *btf)\n{\n\tif (!btf->ptr_sz)\n\t\t((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);\n\n\tif (btf->ptr_sz < 0)\n\t\t \n\t\treturn 0;\n\n\treturn btf->ptr_sz;\n}\n\n \nint btf__set_pointer_size(struct btf *btf, size_t ptr_sz)\n{\n\tif (ptr_sz != 4 && ptr_sz != 8)\n\t\treturn libbpf_err(-EINVAL);\n\tbtf->ptr_sz = ptr_sz;\n\treturn 0;\n}\n\nstatic bool is_host_big_endian(void)\n{\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\treturn false;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\treturn true;\n#else\n# error \"Unrecognized __BYTE_ORDER__\"\n#endif\n}\n\nenum btf_endianness btf__endianness(const struct btf *btf)\n{\n\tif (is_host_big_endian())\n\t\treturn btf->swapped_endian ? BTF_LITTLE_ENDIAN : BTF_BIG_ENDIAN;\n\telse\n\t\treturn btf->swapped_endian ? BTF_BIG_ENDIAN : BTF_LITTLE_ENDIAN;\n}\n\nint btf__set_endianness(struct btf *btf, enum btf_endianness endian)\n{\n\tif (endian != BTF_LITTLE_ENDIAN && endian != BTF_BIG_ENDIAN)\n\t\treturn libbpf_err(-EINVAL);\n\n\tbtf->swapped_endian = is_host_big_endian() != (endian == BTF_BIG_ENDIAN);\n\tif (!btf->swapped_endian) {\n\t\tfree(btf->raw_data_swapped);\n\t\tbtf->raw_data_swapped = NULL;\n\t}\n\treturn 0;\n}\n\nstatic bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void || btf_is_fwd(t);\n}\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}\n\n#define MAX_RESOLVE_DEPTH 32\n\n__s64 btf__resolve_size(const struct btf *btf, __u32 type_id)\n{\n\tconst struct btf_array *array;\n\tconst struct btf_type *t;\n\t__u32 nelems = 1;\n\t__s64 size = -1;\n\tint i;\n\n\tt = btf__type_by_id(btf, type_id);\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH && !btf_type_is_void_or_null(t); i++) {\n\t\tswitch (btf_kind(t)) {\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_ENUM64:\n\t\tcase BTF_KIND_DATASEC:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = t->size;\n\t\t\tgoto done;\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = btf_ptr_sz(btf);\n\t\t\tgoto done;\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_VAR:\n\t\tcase BTF_KIND_DECL_TAG:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\ttype_id = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tarray = btf_array(t);\n\t\t\tif (nelems && array->nelems > UINT32_MAX / nelems)\n\t\t\t\treturn libbpf_err(-E2BIG);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype_id = array->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn libbpf_err(-EINVAL);\n\t\t}\n\n\t\tt = btf__type_by_id(btf, type_id);\n\t}\n\ndone:\n\tif (size < 0)\n\t\treturn libbpf_err(-EINVAL);\n\tif (nelems && size > UINT32_MAX / nelems)\n\t\treturn libbpf_err(-E2BIG);\n\n\treturn nelems * size;\n}\n\nint btf__align_of(const struct btf *btf, __u32 id)\n{\n\tconst struct btf_type *t = btf__type_by_id(btf, id);\n\t__u16 kind = btf_kind(t);\n\n\tswitch (kind) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\tcase BTF_KIND_FLOAT:\n\t\treturn min(btf_ptr_sz(btf), (size_t)t->size);\n\tcase BTF_KIND_PTR:\n\t\treturn btf_ptr_sz(btf);\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn btf__align_of(btf, t->type);\n\tcase BTF_KIND_ARRAY:\n\t\treturn btf__align_of(btf, btf_array(t)->type);\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m = btf_members(t);\n\t\t__u16 vlen = btf_vlen(t);\n\t\tint i, max_align = 1, align;\n\n\t\tfor (i = 0; i < vlen; i++, m++) {\n\t\t\talign = btf__align_of(btf, m->type);\n\t\t\tif (align <= 0)\n\t\t\t\treturn libbpf_err(align);\n\t\t\tmax_align = max(max_align, align);\n\n\t\t\t \n\t\t\tif (btf_member_bitfield_size(t, i) == 0 &&\n\t\t\t    (m->offset % (8 * align)) != 0)\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif ((t->size % max_align) != 0)\n\t\t\treturn 1;\n\n\t\treturn max_align;\n\t}\n\tdefault:\n\t\tpr_warn(\"unsupported BTF_KIND:%u\\n\", btf_kind(t));\n\t\treturn errno = EINVAL, 0;\n\t}\n}\n\nint btf__resolve_type(const struct btf *btf, __u32 type_id)\n{\n\tconst struct btf_type *t;\n\tint depth = 0;\n\n\tt = btf__type_by_id(btf, type_id);\n\twhile (depth < MAX_RESOLVE_DEPTH &&\n\t       !btf_type_is_void_or_null(t) &&\n\t       (btf_is_mod(t) || btf_is_typedef(t) || btf_is_var(t))) {\n\t\ttype_id = t->type;\n\t\tt = btf__type_by_id(btf, type_id);\n\t\tdepth++;\n\t}\n\n\tif (depth == MAX_RESOLVE_DEPTH || btf_type_is_void_or_null(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\treturn type_id;\n}\n\n__s32 btf__find_by_name(const struct btf *btf, const char *type_name)\n{\n\t__u32 i, nr_types = btf__type_cnt(btf);\n\n\tif (!strcmp(type_name, \"void\"))\n\t\treturn 0;\n\n\tfor (i = 1; i < nr_types; i++) {\n\t\tconst struct btf_type *t = btf__type_by_id(btf, i);\n\t\tconst char *name = btf__name_by_offset(btf, t->name_off);\n\n\t\tif (name && !strcmp(type_name, name))\n\t\t\treturn i;\n\t}\n\n\treturn libbpf_err(-ENOENT);\n}\n\nstatic __s32 btf_find_by_name_kind(const struct btf *btf, int start_id,\n\t\t\t\t   const char *type_name, __u32 kind)\n{\n\t__u32 i, nr_types = btf__type_cnt(btf);\n\n\tif (kind == BTF_KIND_UNKN || !strcmp(type_name, \"void\"))\n\t\treturn 0;\n\n\tfor (i = start_id; i < nr_types; i++) {\n\t\tconst struct btf_type *t = btf__type_by_id(btf, i);\n\t\tconst char *name;\n\n\t\tif (btf_kind(t) != kind)\n\t\t\tcontinue;\n\t\tname = btf__name_by_offset(btf, t->name_off);\n\t\tif (name && !strcmp(type_name, name))\n\t\t\treturn i;\n\t}\n\n\treturn libbpf_err(-ENOENT);\n}\n\n__s32 btf__find_by_name_kind_own(const struct btf *btf, const char *type_name,\n\t\t\t\t __u32 kind)\n{\n\treturn btf_find_by_name_kind(btf, btf->start_id, type_name, kind);\n}\n\n__s32 btf__find_by_name_kind(const struct btf *btf, const char *type_name,\n\t\t\t     __u32 kind)\n{\n\treturn btf_find_by_name_kind(btf, 1, type_name, kind);\n}\n\nstatic bool btf_is_modifiable(const struct btf *btf)\n{\n\treturn (void *)btf->hdr != btf->raw_data;\n}\n\nvoid btf__free(struct btf *btf)\n{\n\tif (IS_ERR_OR_NULL(btf))\n\t\treturn;\n\n\tif (btf->fd >= 0)\n\t\tclose(btf->fd);\n\n\tif (btf_is_modifiable(btf)) {\n\t\t \n\t\tfree(btf->hdr);\n\t\tfree(btf->types_data);\n\t\tstrset__free(btf->strs_set);\n\t}\n\tfree(btf->raw_data);\n\tfree(btf->raw_data_swapped);\n\tfree(btf->type_offs);\n\tfree(btf);\n}\n\nstatic struct btf *btf_new_empty(struct btf *base_btf)\n{\n\tstruct btf *btf;\n\n\tbtf = calloc(1, sizeof(*btf));\n\tif (!btf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbtf->nr_types = 0;\n\tbtf->start_id = 1;\n\tbtf->start_str_off = 0;\n\tbtf->fd = -1;\n\tbtf->ptr_sz = sizeof(void *);\n\tbtf->swapped_endian = false;\n\n\tif (base_btf) {\n\t\tbtf->base_btf = base_btf;\n\t\tbtf->start_id = btf__type_cnt(base_btf);\n\t\tbtf->start_str_off = base_btf->hdr->str_len;\n\t}\n\n\t \n\tbtf->raw_size = sizeof(struct btf_header) + (base_btf ? 0 : 1);\n\tbtf->raw_data = calloc(1, btf->raw_size);\n\tif (!btf->raw_data) {\n\t\tfree(btf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tbtf->hdr = btf->raw_data;\n\tbtf->hdr->hdr_len = sizeof(struct btf_header);\n\tbtf->hdr->magic = BTF_MAGIC;\n\tbtf->hdr->version = BTF_VERSION;\n\n\tbtf->types_data = btf->raw_data + btf->hdr->hdr_len;\n\tbtf->strs_data = btf->raw_data + btf->hdr->hdr_len;\n\tbtf->hdr->str_len = base_btf ? 0 : 1;  \n\n\treturn btf;\n}\n\nstruct btf *btf__new_empty(void)\n{\n\treturn libbpf_ptr(btf_new_empty(NULL));\n}\n\nstruct btf *btf__new_empty_split(struct btf *base_btf)\n{\n\treturn libbpf_ptr(btf_new_empty(base_btf));\n}\n\nstatic struct btf *btf_new(const void *data, __u32 size, struct btf *base_btf)\n{\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = calloc(1, sizeof(struct btf));\n\tif (!btf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbtf->nr_types = 0;\n\tbtf->start_id = 1;\n\tbtf->start_str_off = 0;\n\tbtf->fd = -1;\n\n\tif (base_btf) {\n\t\tbtf->base_btf = base_btf;\n\t\tbtf->start_id = btf__type_cnt(base_btf);\n\t\tbtf->start_str_off = base_btf->hdr->str_len;\n\t}\n\n\tbtf->raw_data = malloc(size);\n\tif (!btf->raw_data) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tmemcpy(btf->raw_data, data, size);\n\tbtf->raw_size = size;\n\n\tbtf->hdr = btf->raw_data;\n\terr = btf_parse_hdr(btf);\n\tif (err)\n\t\tgoto done;\n\n\tbtf->strs_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->str_off;\n\tbtf->types_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->type_off;\n\n\terr = btf_parse_str_sec(btf);\n\terr = err ?: btf_parse_type_sec(btf);\n\tif (err)\n\t\tgoto done;\n\ndone:\n\tif (err) {\n\t\tbtf__free(btf);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn btf;\n}\n\nstruct btf *btf__new(const void *data, __u32 size)\n{\n\treturn libbpf_ptr(btf_new(data, size, NULL));\n}\n\nstatic struct btf *btf_parse_elf(const char *path, struct btf *base_btf,\n\t\t\t\t struct btf_ext **btf_ext)\n{\n\tElf_Data *btf_data = NULL, *btf_ext_data = NULL;\n\tint err = 0, fd = -1, idx = 0;\n\tstruct btf *btf = NULL;\n\tElf_Scn *scn = NULL;\n\tElf *elf = NULL;\n\tGElf_Ehdr ehdr;\n\tsize_t shstrndx;\n\n\tif (elf_version(EV_CURRENT) == EV_NONE) {\n\t\tpr_warn(\"failed to init libelf for %s\\n\", path);\n\t\treturn ERR_PTR(-LIBBPF_ERRNO__LIBELF);\n\t}\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to open %s: %s\\n\", path, strerror(errno));\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = -LIBBPF_ERRNO__FORMAT;\n\n\telf = elf_begin(fd, ELF_C_READ, NULL);\n\tif (!elf) {\n\t\tpr_warn(\"failed to open %s as ELF file\\n\", path);\n\t\tgoto done;\n\t}\n\tif (!gelf_getehdr(elf, &ehdr)) {\n\t\tpr_warn(\"failed to get EHDR from %s\\n\", path);\n\t\tgoto done;\n\t}\n\n\tif (elf_getshdrstrndx(elf, &shstrndx)) {\n\t\tpr_warn(\"failed to get section names section index for %s\\n\",\n\t\t\tpath);\n\t\tgoto done;\n\t}\n\n\tif (!elf_rawdata(elf_getscn(elf, shstrndx), NULL)) {\n\t\tpr_warn(\"failed to get e_shstrndx from %s\\n\", path);\n\t\tgoto done;\n\t}\n\n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tGElf_Shdr sh;\n\t\tchar *name;\n\n\t\tidx++;\n\t\tif (gelf_getshdr(scn, &sh) != &sh) {\n\t\t\tpr_warn(\"failed to get section(%d) header from %s\\n\",\n\t\t\t\tidx, path);\n\t\t\tgoto done;\n\t\t}\n\t\tname = elf_strptr(elf, shstrndx, sh.sh_name);\n\t\tif (!name) {\n\t\t\tpr_warn(\"failed to get section(%d) name from %s\\n\",\n\t\t\t\tidx, path);\n\t\t\tgoto done;\n\t\t}\n\t\tif (strcmp(name, BTF_ELF_SEC) == 0) {\n\t\t\tbtf_data = elf_getdata(scn, 0);\n\t\t\tif (!btf_data) {\n\t\t\t\tpr_warn(\"failed to get section(%d, %s) data from %s\\n\",\n\t\t\t\t\tidx, name, path);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (btf_ext && strcmp(name, BTF_EXT_ELF_SEC) == 0) {\n\t\t\tbtf_ext_data = elf_getdata(scn, 0);\n\t\t\tif (!btf_ext_data) {\n\t\t\t\tpr_warn(\"failed to get section(%d, %s) data from %s\\n\",\n\t\t\t\t\tidx, name, path);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!btf_data) {\n\t\tpr_warn(\"failed to find '%s' ELF section in %s\\n\", BTF_ELF_SEC, path);\n\t\terr = -ENODATA;\n\t\tgoto done;\n\t}\n\tbtf = btf_new(btf_data->d_buf, btf_data->d_size, base_btf);\n\terr = libbpf_get_error(btf);\n\tif (err)\n\t\tgoto done;\n\n\tswitch (gelf_getclass(elf)) {\n\tcase ELFCLASS32:\n\t\tbtf__set_pointer_size(btf, 4);\n\t\tbreak;\n\tcase ELFCLASS64:\n\t\tbtf__set_pointer_size(btf, 8);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"failed to get ELF class (bitness) for %s\\n\", path);\n\t\tbreak;\n\t}\n\n\tif (btf_ext && btf_ext_data) {\n\t\t*btf_ext = btf_ext__new(btf_ext_data->d_buf, btf_ext_data->d_size);\n\t\terr = libbpf_get_error(*btf_ext);\n\t\tif (err)\n\t\t\tgoto done;\n\t} else if (btf_ext) {\n\t\t*btf_ext = NULL;\n\t}\ndone:\n\tif (elf)\n\t\telf_end(elf);\n\tclose(fd);\n\n\tif (!err)\n\t\treturn btf;\n\n\tif (btf_ext)\n\t\tbtf_ext__free(*btf_ext);\n\tbtf__free(btf);\n\n\treturn ERR_PTR(err);\n}\n\nstruct btf *btf__parse_elf(const char *path, struct btf_ext **btf_ext)\n{\n\treturn libbpf_ptr(btf_parse_elf(path, NULL, btf_ext));\n}\n\nstruct btf *btf__parse_elf_split(const char *path, struct btf *base_btf)\n{\n\treturn libbpf_ptr(btf_parse_elf(path, base_btf, NULL));\n}\n\nstatic struct btf *btf_parse_raw(const char *path, struct btf *base_btf)\n{\n\tstruct btf *btf = NULL;\n\tvoid *data = NULL;\n\tFILE *f = NULL;\n\t__u16 magic;\n\tint err = 0;\n\tlong sz;\n\n\tf = fopen(path, \"rbe\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (fread(&magic, 1, sizeof(magic), f) < sizeof(magic)) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tif (magic != BTF_MAGIC && magic != bswap_16(BTF_MAGIC)) {\n\t\t \n\t\terr = -EPROTO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (fseek(f, 0, SEEK_END)) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\tsz = ftell(f);\n\tif (sz < 0) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\t \n\tif (fseek(f, 0, SEEK_SET)) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\n\t \n\tdata = malloc(sz);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tif (fread(data, 1, sz, f) < sz) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tbtf = btf_new(data, sz, base_btf);\n\nerr_out:\n\tfree(data);\n\tif (f)\n\t\tfclose(f);\n\treturn err ? ERR_PTR(err) : btf;\n}\n\nstruct btf *btf__parse_raw(const char *path)\n{\n\treturn libbpf_ptr(btf_parse_raw(path, NULL));\n}\n\nstruct btf *btf__parse_raw_split(const char *path, struct btf *base_btf)\n{\n\treturn libbpf_ptr(btf_parse_raw(path, base_btf));\n}\n\nstatic struct btf *btf_parse(const char *path, struct btf *base_btf, struct btf_ext **btf_ext)\n{\n\tstruct btf *btf;\n\tint err;\n\n\tif (btf_ext)\n\t\t*btf_ext = NULL;\n\n\tbtf = btf_parse_raw(path, base_btf);\n\terr = libbpf_get_error(btf);\n\tif (!err)\n\t\treturn btf;\n\tif (err != -EPROTO)\n\t\treturn ERR_PTR(err);\n\treturn btf_parse_elf(path, base_btf, btf_ext);\n}\n\nstruct btf *btf__parse(const char *path, struct btf_ext **btf_ext)\n{\n\treturn libbpf_ptr(btf_parse(path, NULL, btf_ext));\n}\n\nstruct btf *btf__parse_split(const char *path, struct btf *base_btf)\n{\n\treturn libbpf_ptr(btf_parse(path, base_btf, NULL));\n}\n\nstatic void *btf_get_raw_data(const struct btf *btf, __u32 *size, bool swap_endian);\n\nint btf_load_into_kernel(struct btf *btf, char *log_buf, size_t log_sz, __u32 log_level)\n{\n\tLIBBPF_OPTS(bpf_btf_load_opts, opts);\n\t__u32 buf_sz = 0, raw_size;\n\tchar *buf = NULL, *tmp;\n\tvoid *raw_data;\n\tint err = 0;\n\n\tif (btf->fd >= 0)\n\t\treturn libbpf_err(-EEXIST);\n\tif (log_sz && !log_buf)\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\traw_data = btf_get_raw_data(btf, &raw_size, false);\n\tif (!raw_data) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tbtf->raw_size = raw_size;\n\tbtf->raw_data = raw_data;\n\nretry_load:\n\t \n\tif (log_level) {\n\t\t \n\t\tif (!log_buf) {\n\t\t\tbuf_sz = max((__u32)BPF_LOG_BUF_SIZE, buf_sz * 2);\n\t\t\ttmp = realloc(buf, buf_sz);\n\t\t\tif (!tmp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbuf = tmp;\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\n\t\topts.log_buf = log_buf ? log_buf : buf;\n\t\topts.log_size = log_buf ? log_sz : buf_sz;\n\t\topts.log_level = log_level;\n\t}\n\n\tbtf->fd = bpf_btf_load(raw_data, raw_size, &opts);\n\tif (btf->fd < 0) {\n\t\t \n\t\tif (log_level == 0) {\n\t\t\tlog_level = 1;\n\t\t\tgoto retry_load;\n\t\t}\n\t\t \n\t\tif (!log_buf && errno == ENOSPC && buf_sz <= UINT_MAX / 2)\n\t\t\tgoto retry_load;\n\n\t\terr = -errno;\n\t\tpr_warn(\"BTF loading error: %d\\n\", err);\n\t\t \n\t\tif (!log_buf && buf[0])\n\t\t\tpr_warn(\"-- BEGIN BTF LOAD LOG ---\\n%s\\n-- END BTF LOAD LOG --\\n\", buf);\n\t}\n\ndone:\n\tfree(buf);\n\treturn libbpf_err(err);\n}\n\nint btf__load_into_kernel(struct btf *btf)\n{\n\treturn btf_load_into_kernel(btf, NULL, 0, 0);\n}\n\nint btf__fd(const struct btf *btf)\n{\n\treturn btf->fd;\n}\n\nvoid btf__set_fd(struct btf *btf, int fd)\n{\n\tbtf->fd = fd;\n}\n\nstatic const void *btf_strs_data(const struct btf *btf)\n{\n\treturn btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);\n}\n\nstatic void *btf_get_raw_data(const struct btf *btf, __u32 *size, bool swap_endian)\n{\n\tstruct btf_header *hdr = btf->hdr;\n\tstruct btf_type *t;\n\tvoid *data, *p;\n\t__u32 data_sz;\n\tint i;\n\n\tdata = swap_endian ? btf->raw_data_swapped : btf->raw_data;\n\tif (data) {\n\t\t*size = btf->raw_size;\n\t\treturn data;\n\t}\n\n\tdata_sz = hdr->hdr_len + hdr->type_len + hdr->str_len;\n\tdata = calloc(1, data_sz);\n\tif (!data)\n\t\treturn NULL;\n\tp = data;\n\n\tmemcpy(p, hdr, hdr->hdr_len);\n\tif (swap_endian)\n\t\tbtf_bswap_hdr(p);\n\tp += hdr->hdr_len;\n\n\tmemcpy(p, btf->types_data, hdr->type_len);\n\tif (swap_endian) {\n\t\tfor (i = 0; i < btf->nr_types; i++) {\n\t\t\tt = p + btf->type_offs[i];\n\t\t\t \n\t\t\tif (btf_bswap_type_rest(t))\n\t\t\t\tgoto err_out;\n\t\t\tbtf_bswap_type_base(t);\n\t\t}\n\t}\n\tp += hdr->type_len;\n\n\tmemcpy(p, btf_strs_data(btf), hdr->str_len);\n\tp += hdr->str_len;\n\n\t*size = data_sz;\n\treturn data;\nerr_out:\n\tfree(data);\n\treturn NULL;\n}\n\nconst void *btf__raw_data(const struct btf *btf_ro, __u32 *size)\n{\n\tstruct btf *btf = (struct btf *)btf_ro;\n\t__u32 data_sz;\n\tvoid *data;\n\n\tdata = btf_get_raw_data(btf, &data_sz, btf->swapped_endian);\n\tif (!data)\n\t\treturn errno = ENOMEM, NULL;\n\n\tbtf->raw_size = data_sz;\n\tif (btf->swapped_endian)\n\t\tbtf->raw_data_swapped = data;\n\telse\n\t\tbtf->raw_data = data;\n\t*size = data_sz;\n\treturn data;\n}\n\n__attribute__((alias(\"btf__raw_data\")))\nconst void *btf__get_raw_data(const struct btf *btf, __u32 *size);\n\nconst char *btf__str_by_offset(const struct btf *btf, __u32 offset)\n{\n\tif (offset < btf->start_str_off)\n\t\treturn btf__str_by_offset(btf->base_btf, offset);\n\telse if (offset - btf->start_str_off < btf->hdr->str_len)\n\t\treturn btf_strs_data(btf) + (offset - btf->start_str_off);\n\telse\n\t\treturn errno = EINVAL, NULL;\n}\n\nconst char *btf__name_by_offset(const struct btf *btf, __u32 offset)\n{\n\treturn btf__str_by_offset(btf, offset);\n}\n\nstruct btf *btf_get_from_fd(int btf_fd, struct btf *base_btf)\n{\n\tstruct bpf_btf_info btf_info;\n\t__u32 len = sizeof(btf_info);\n\t__u32 last_size;\n\tstruct btf *btf;\n\tvoid *ptr;\n\tint err;\n\n\t \n\tlast_size = 4096;\n\tptr = malloc(last_size);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(&btf_info, 0, sizeof(btf_info));\n\tbtf_info.btf = ptr_to_u64(ptr);\n\tbtf_info.btf_size = last_size;\n\terr = bpf_btf_get_info_by_fd(btf_fd, &btf_info, &len);\n\n\tif (!err && btf_info.btf_size > last_size) {\n\t\tvoid *temp_ptr;\n\n\t\tlast_size = btf_info.btf_size;\n\t\ttemp_ptr = realloc(ptr, last_size);\n\t\tif (!temp_ptr) {\n\t\t\tbtf = ERR_PTR(-ENOMEM);\n\t\t\tgoto exit_free;\n\t\t}\n\t\tptr = temp_ptr;\n\n\t\tlen = sizeof(btf_info);\n\t\tmemset(&btf_info, 0, sizeof(btf_info));\n\t\tbtf_info.btf = ptr_to_u64(ptr);\n\t\tbtf_info.btf_size = last_size;\n\n\t\terr = bpf_btf_get_info_by_fd(btf_fd, &btf_info, &len);\n\t}\n\n\tif (err || btf_info.btf_size > last_size) {\n\t\tbtf = err ? ERR_PTR(-errno) : ERR_PTR(-E2BIG);\n\t\tgoto exit_free;\n\t}\n\n\tbtf = btf_new(ptr, btf_info.btf_size, base_btf);\n\nexit_free:\n\tfree(ptr);\n\treturn btf;\n}\n\nstruct btf *btf__load_from_kernel_by_id_split(__u32 id, struct btf *base_btf)\n{\n\tstruct btf *btf;\n\tint btf_fd;\n\n\tbtf_fd = bpf_btf_get_fd_by_id(id);\n\tif (btf_fd < 0)\n\t\treturn libbpf_err_ptr(-errno);\n\n\tbtf = btf_get_from_fd(btf_fd, base_btf);\n\tclose(btf_fd);\n\n\treturn libbpf_ptr(btf);\n}\n\nstruct btf *btf__load_from_kernel_by_id(__u32 id)\n{\n\treturn btf__load_from_kernel_by_id_split(id, NULL);\n}\n\nstatic void btf_invalidate_raw_data(struct btf *btf)\n{\n\tif (btf->raw_data) {\n\t\tfree(btf->raw_data);\n\t\tbtf->raw_data = NULL;\n\t}\n\tif (btf->raw_data_swapped) {\n\t\tfree(btf->raw_data_swapped);\n\t\tbtf->raw_data_swapped = NULL;\n\t}\n}\n\n \nstatic int btf_ensure_modifiable(struct btf *btf)\n{\n\tvoid *hdr, *types;\n\tstruct strset *set = NULL;\n\tint err = -ENOMEM;\n\n\tif (btf_is_modifiable(btf)) {\n\t\t \n\t\tbtf_invalidate_raw_data(btf);\n\t\treturn 0;\n\t}\n\n\t \n\thdr = malloc(btf->hdr->hdr_len);\n\ttypes = malloc(btf->hdr->type_len);\n\tif (!hdr || !types)\n\t\tgoto err_out;\n\n\tmemcpy(hdr, btf->hdr, btf->hdr->hdr_len);\n\tmemcpy(types, btf->types_data, btf->hdr->type_len);\n\n\t \n\tset = strset__new(BTF_MAX_STR_OFFSET, btf->strs_data, btf->hdr->str_len);\n\tif (IS_ERR(set)) {\n\t\terr = PTR_ERR(set);\n\t\tgoto err_out;\n\t}\n\n\t \n\tbtf->hdr = hdr;\n\tbtf->types_data = types;\n\tbtf->types_data_cap = btf->hdr->type_len;\n\tbtf->strs_data = NULL;\n\tbtf->strs_set = set;\n\t \n\tif (btf->hdr->str_len == 0)\n\t\tbtf->strs_deduped = true;\n\tif (!btf->base_btf && btf->hdr->str_len == 1)\n\t\tbtf->strs_deduped = true;\n\n\t \n\tbtf_invalidate_raw_data(btf);\n\n\treturn 0;\n\nerr_out:\n\tstrset__free(set);\n\tfree(hdr);\n\tfree(types);\n\treturn err;\n}\n\n \nint btf__find_str(struct btf *btf, const char *s)\n{\n\tint off;\n\n\tif (btf->base_btf) {\n\t\toff = btf__find_str(btf->base_btf, s);\n\t\tif (off != -ENOENT)\n\t\t\treturn off;\n\t}\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\toff = strset__find_str(btf->strs_set, s);\n\tif (off < 0)\n\t\treturn libbpf_err(off);\n\n\treturn btf->start_str_off + off;\n}\n\n \nint btf__add_str(struct btf *btf, const char *s)\n{\n\tint off;\n\n\tif (btf->base_btf) {\n\t\toff = btf__find_str(btf->base_btf, s);\n\t\tif (off != -ENOENT)\n\t\t\treturn off;\n\t}\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\toff = strset__add_str(btf->strs_set, s);\n\tif (off < 0)\n\t\treturn libbpf_err(off);\n\n\tbtf->hdr->str_len = strset__data_size(btf->strs_set);\n\n\treturn btf->start_str_off + off;\n}\n\nstatic void *btf_add_type_mem(struct btf *btf, size_t add_sz)\n{\n\treturn libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,\n\t\t\t      btf->hdr->type_len, UINT_MAX, add_sz);\n}\n\nstatic void btf_type_inc_vlen(struct btf_type *t)\n{\n\tt->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));\n}\n\nstatic int btf_commit_type(struct btf *btf, int data_sz)\n{\n\tint err;\n\n\terr = btf_add_type_idx_entry(btf, btf->hdr->type_len);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\tbtf->hdr->type_len += data_sz;\n\tbtf->hdr->str_off += data_sz;\n\tbtf->nr_types++;\n\treturn btf->start_id + btf->nr_types - 1;\n}\n\nstruct btf_pipe {\n\tconst struct btf *src;\n\tstruct btf *dst;\n\tstruct hashmap *str_off_map;  \n};\n\nstatic int btf_rewrite_str(__u32 *str_off, void *ctx)\n{\n\tstruct btf_pipe *p = ctx;\n\tlong mapped_off;\n\tint off, err;\n\n\tif (!*str_off)  \n\t\treturn 0;\n\n\tif (p->str_off_map &&\n\t    hashmap__find(p->str_off_map, *str_off, &mapped_off)) {\n\t\t*str_off = mapped_off;\n\t\treturn 0;\n\t}\n\n\toff = btf__add_str(p->dst, btf__str_by_offset(p->src, *str_off));\n\tif (off < 0)\n\t\treturn off;\n\n\t \n\tif (p->str_off_map) {\n\t\terr = hashmap__append(p->str_off_map, *str_off, off);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t*str_off = off;\n\treturn 0;\n}\n\nint btf__add_type(struct btf *btf, const struct btf *src_btf, const struct btf_type *src_type)\n{\n\tstruct btf_pipe p = { .src = src_btf, .dst = btf };\n\tstruct btf_type *t;\n\tint sz, err;\n\n\tsz = btf_type_size(src_type);\n\tif (sz < 0)\n\t\treturn libbpf_err(sz);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tmemcpy(t, src_type, sz);\n\n\terr = btf_type_visit_str_offs(t, btf_rewrite_str, &p);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\treturn btf_commit_type(btf, sz);\n}\n\nstatic int btf_rewrite_type_ids(__u32 *type_id, void *ctx)\n{\n\tstruct btf *btf = ctx;\n\n\tif (!*type_id)  \n\t\treturn 0;\n\n\t \n\t*type_id += btf->start_id + btf->nr_types - 1;\n\treturn 0;\n}\n\nstatic size_t btf_dedup_identity_hash_fn(long key, void *ctx);\nstatic bool btf_dedup_equal_fn(long k1, long k2, void *ctx);\n\nint btf__add_btf(struct btf *btf, const struct btf *src_btf)\n{\n\tstruct btf_pipe p = { .src = src_btf, .dst = btf };\n\tint data_sz, sz, cnt, i, err, old_strs_len;\n\t__u32 *off;\n\tvoid *t;\n\n\t \n\tif (src_btf->base_btf)\n\t\treturn libbpf_err(-ENOTSUP);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\told_strs_len = btf->hdr->str_len;\n\n\tdata_sz = src_btf->hdr->type_len;\n\tcnt = btf__type_cnt(src_btf) - 1;\n\n\t \n\tt = btf_add_type_mem(btf, data_sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\toff = btf_add_type_offs_mem(btf, cnt);\n\tif (!off)\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\tp.str_off_map = hashmap__new(btf_dedup_identity_hash_fn, btf_dedup_equal_fn, NULL);\n\tif (IS_ERR(p.str_off_map))\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\tmemcpy(t, src_btf->types_data, data_sz);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tsz = btf_type_size(t);\n\t\tif (sz < 0) {\n\t\t\t \n\t\t\terr = sz;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\t*off = t - btf->types_data;\n\n\t\t \n\t\terr = btf_type_visit_str_offs(t, btf_rewrite_str, &p);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t \n\t\terr = btf_type_visit_type_ids(t, btf_rewrite_type_ids, btf);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t \n\t\tt += sz;\n\t\toff++;\n\t}\n\n\t \n\tbtf->hdr->type_len += data_sz;\n\tbtf->hdr->str_off += data_sz;\n\tbtf->nr_types += cnt;\n\n\thashmap__free(p.str_off_map);\n\n\t \n\treturn btf->start_id + btf->nr_types - cnt;\nerr_out:\n\t \n\tmemset(btf->types_data + btf->hdr->type_len, 0, data_sz);\n\tmemset(btf->strs_data + old_strs_len, 0, btf->hdr->str_len - old_strs_len);\n\n\t \n\tbtf->hdr->str_len = old_strs_len;\n\n\thashmap__free(p.str_off_map);\n\n\treturn libbpf_err(err);\n}\n\n \nint btf__add_int(struct btf *btf, const char *name, size_t byte_sz, int encoding)\n{\n\tstruct btf_type *t;\n\tint sz, name_off;\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\t \n\tif (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 16)\n\t\treturn libbpf_err(-EINVAL);\n\tif (encoding & ~(BTF_INT_SIGNED | BTF_INT_CHAR | BTF_INT_BOOL))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type) + sizeof(int);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tt->name_off = name_off;\n\tt->info = btf_type_info(BTF_KIND_INT, 0, 0);\n\tt->size = byte_sz;\n\t \n\t*(__u32 *)(t + 1) = (encoding << 24) | (byte_sz * 8);\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_float(struct btf *btf, const char *name, size_t byte_sz)\n{\n\tstruct btf_type *t;\n\tint sz, name_off;\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (byte_sz != 2 && byte_sz != 4 && byte_sz != 8 && byte_sz != 12 &&\n\t    byte_sz != 16)\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tt->name_off = name_off;\n\tt->info = btf_type_info(BTF_KIND_FLOAT, 0, 0);\n\tt->size = byte_sz;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nstatic int validate_type_id(int id)\n{\n\tif (id < 0 || id > BTF_MAX_NR_TYPES)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int btf_add_ref_kind(struct btf *btf, int kind, const char *name, int ref_type_id)\n{\n\tstruct btf_type *t;\n\tint sz, name_off = 0;\n\n\tif (validate_type_id(ref_type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tif (name && name[0]) {\n\t\tname_off = btf__add_str(btf, name);\n\t\tif (name_off < 0)\n\t\t\treturn name_off;\n\t}\n\n\tt->name_off = name_off;\n\tt->info = btf_type_info(kind, 0, 0);\n\tt->type = ref_type_id;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_ptr(struct btf *btf, int ref_type_id)\n{\n\treturn btf_add_ref_kind(btf, BTF_KIND_PTR, NULL, ref_type_id);\n}\n\n \nint btf__add_array(struct btf *btf, int index_type_id, int elem_type_id, __u32 nr_elems)\n{\n\tstruct btf_type *t;\n\tstruct btf_array *a;\n\tint sz;\n\n\tif (validate_type_id(index_type_id) || validate_type_id(elem_type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type) + sizeof(struct btf_array);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tt->name_off = 0;\n\tt->info = btf_type_info(BTF_KIND_ARRAY, 0, 0);\n\tt->size = 0;\n\n\ta = btf_array(t);\n\ta->type = elem_type_id;\n\ta->index_type = index_type_id;\n\ta->nelems = nr_elems;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nstatic int btf_add_composite(struct btf *btf, int kind, const char *name, __u32 bytes_sz)\n{\n\tstruct btf_type *t;\n\tint sz, name_off = 0;\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tif (name && name[0]) {\n\t\tname_off = btf__add_str(btf, name);\n\t\tif (name_off < 0)\n\t\t\treturn name_off;\n\t}\n\n\t \n\tt->name_off = name_off;\n\tt->info = btf_type_info(kind, 0, 0);\n\tt->size = bytes_sz;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_struct(struct btf *btf, const char *name, __u32 byte_sz)\n{\n\treturn btf_add_composite(btf, BTF_KIND_STRUCT, name, byte_sz);\n}\n\n \nint btf__add_union(struct btf *btf, const char *name, __u32 byte_sz)\n{\n\treturn btf_add_composite(btf, BTF_KIND_UNION, name, byte_sz);\n}\n\nstatic struct btf_type *btf_last_type(struct btf *btf)\n{\n\treturn btf_type_by_id(btf, btf__type_cnt(btf) - 1);\n}\n\n \nint btf__add_field(struct btf *btf, const char *name, int type_id,\n\t\t   __u32 bit_offset, __u32 bit_size)\n{\n\tstruct btf_type *t;\n\tstruct btf_member *m;\n\tbool is_bitfield;\n\tint sz, name_off = 0;\n\n\t \n\tif (btf->nr_types == 0)\n\t\treturn libbpf_err(-EINVAL);\n\tt = btf_last_type(btf);\n\tif (!btf_is_composite(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (validate_type_id(type_id))\n\t\treturn libbpf_err(-EINVAL);\n\t \n\tis_bitfield = bit_size || (bit_offset % 8 != 0);\n\tif (is_bitfield && (bit_size == 0 || bit_size > 255 || bit_offset > 0xffffff))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_is_union(t) && bit_offset)\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_member);\n\tm = btf_add_type_mem(btf, sz);\n\tif (!m)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tif (name && name[0]) {\n\t\tname_off = btf__add_str(btf, name);\n\t\tif (name_off < 0)\n\t\t\treturn name_off;\n\t}\n\n\tm->name_off = name_off;\n\tm->type = type_id;\n\tm->offset = bit_offset | (bit_size << 24);\n\n\t \n\tt = btf_last_type(btf);\n\t \n\tt->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, is_bitfield || btf_kflag(t));\n\n\tbtf->hdr->type_len += sz;\n\tbtf->hdr->str_off += sz;\n\treturn 0;\n}\n\nstatic int btf_add_enum_common(struct btf *btf, const char *name, __u32 byte_sz,\n\t\t\t       bool is_signed, __u8 kind)\n{\n\tstruct btf_type *t;\n\tint sz, name_off = 0;\n\n\t \n\tif (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 8)\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tif (name && name[0]) {\n\t\tname_off = btf__add_str(btf, name);\n\t\tif (name_off < 0)\n\t\t\treturn name_off;\n\t}\n\n\t \n\tt->name_off = name_off;\n\tt->info = btf_type_info(kind, 0, is_signed);\n\tt->size = byte_sz;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_enum(struct btf *btf, const char *name, __u32 byte_sz)\n{\n\t \n\treturn btf_add_enum_common(btf, name, byte_sz, false, BTF_KIND_ENUM);\n}\n\n \nint btf__add_enum_value(struct btf *btf, const char *name, __s64 value)\n{\n\tstruct btf_type *t;\n\tstruct btf_enum *v;\n\tint sz, name_off;\n\n\t \n\tif (btf->nr_types == 0)\n\t\treturn libbpf_err(-EINVAL);\n\tt = btf_last_type(btf);\n\tif (!btf_is_enum(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\tif (value < INT_MIN || value > UINT_MAX)\n\t\treturn libbpf_err(-E2BIG);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_enum);\n\tv = btf_add_type_mem(btf, sz);\n\tif (!v)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tv->name_off = name_off;\n\tv->val = value;\n\n\t \n\tt = btf_last_type(btf);\n\tbtf_type_inc_vlen(t);\n\n\t \n\tif (value < 0)\n\t\tt->info = btf_type_info(btf_kind(t), btf_vlen(t), true);\n\n\tbtf->hdr->type_len += sz;\n\tbtf->hdr->str_off += sz;\n\treturn 0;\n}\n\n \nint btf__add_enum64(struct btf *btf, const char *name, __u32 byte_sz,\n\t\t    bool is_signed)\n{\n\treturn btf_add_enum_common(btf, name, byte_sz, is_signed,\n\t\t\t\t   BTF_KIND_ENUM64);\n}\n\n \nint btf__add_enum64_value(struct btf *btf, const char *name, __u64 value)\n{\n\tstruct btf_enum64 *v;\n\tstruct btf_type *t;\n\tint sz, name_off;\n\n\t \n\tif (btf->nr_types == 0)\n\t\treturn libbpf_err(-EINVAL);\n\tt = btf_last_type(btf);\n\tif (!btf_is_enum64(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_enum64);\n\tv = btf_add_type_mem(btf, sz);\n\tif (!v)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tv->name_off = name_off;\n\tv->val_lo32 = (__u32)value;\n\tv->val_hi32 = value >> 32;\n\n\t \n\tt = btf_last_type(btf);\n\tbtf_type_inc_vlen(t);\n\n\tbtf->hdr->type_len += sz;\n\tbtf->hdr->str_off += sz;\n\treturn 0;\n}\n\n \nint btf__add_fwd(struct btf *btf, const char *name, enum btf_fwd_kind fwd_kind)\n{\n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\tswitch (fwd_kind) {\n\tcase BTF_FWD_STRUCT:\n\tcase BTF_FWD_UNION: {\n\t\tstruct btf_type *t;\n\t\tint id;\n\n\t\tid = btf_add_ref_kind(btf, BTF_KIND_FWD, name, 0);\n\t\tif (id <= 0)\n\t\t\treturn id;\n\t\tt = btf_type_by_id(btf, id);\n\t\tt->info = btf_type_info(BTF_KIND_FWD, 0, fwd_kind == BTF_FWD_UNION);\n\t\treturn id;\n\t}\n\tcase BTF_FWD_ENUM:\n\t\t \n\t\treturn btf__add_enum(btf, name, sizeof(int));\n\tdefault:\n\t\treturn libbpf_err(-EINVAL);\n\t}\n}\n\n \nint btf__add_typedef(struct btf *btf, const char *name, int ref_type_id)\n{\n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\treturn btf_add_ref_kind(btf, BTF_KIND_TYPEDEF, name, ref_type_id);\n}\n\n \nint btf__add_volatile(struct btf *btf, int ref_type_id)\n{\n\treturn btf_add_ref_kind(btf, BTF_KIND_VOLATILE, NULL, ref_type_id);\n}\n\n \nint btf__add_const(struct btf *btf, int ref_type_id)\n{\n\treturn btf_add_ref_kind(btf, BTF_KIND_CONST, NULL, ref_type_id);\n}\n\n \nint btf__add_restrict(struct btf *btf, int ref_type_id)\n{\n\treturn btf_add_ref_kind(btf, BTF_KIND_RESTRICT, NULL, ref_type_id);\n}\n\n \nint btf__add_type_tag(struct btf *btf, const char *value, int ref_type_id)\n{\n\tif (!value || !value[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\treturn btf_add_ref_kind(btf, BTF_KIND_TYPE_TAG, value, ref_type_id);\n}\n\n \nint btf__add_func(struct btf *btf, const char *name,\n\t\t  enum btf_func_linkage linkage, int proto_type_id)\n{\n\tint id;\n\n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\tif (linkage != BTF_FUNC_STATIC && linkage != BTF_FUNC_GLOBAL &&\n\t    linkage != BTF_FUNC_EXTERN)\n\t\treturn libbpf_err(-EINVAL);\n\n\tid = btf_add_ref_kind(btf, BTF_KIND_FUNC, name, proto_type_id);\n\tif (id > 0) {\n\t\tstruct btf_type *t = btf_type_by_id(btf, id);\n\n\t\tt->info = btf_type_info(BTF_KIND_FUNC, linkage, 0);\n\t}\n\treturn libbpf_err(id);\n}\n\n \nint btf__add_func_proto(struct btf *btf, int ret_type_id)\n{\n\tstruct btf_type *t;\n\tint sz;\n\n\tif (validate_type_id(ret_type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\t \n\tt->name_off = 0;\n\tt->info = btf_type_info(BTF_KIND_FUNC_PROTO, 0, 0);\n\tt->type = ret_type_id;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_func_param(struct btf *btf, const char *name, int type_id)\n{\n\tstruct btf_type *t;\n\tstruct btf_param *p;\n\tint sz, name_off = 0;\n\n\tif (validate_type_id(type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf->nr_types == 0)\n\t\treturn libbpf_err(-EINVAL);\n\tt = btf_last_type(btf);\n\tif (!btf_is_func_proto(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_param);\n\tp = btf_add_type_mem(btf, sz);\n\tif (!p)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tif (name && name[0]) {\n\t\tname_off = btf__add_str(btf, name);\n\t\tif (name_off < 0)\n\t\t\treturn name_off;\n\t}\n\n\tp->name_off = name_off;\n\tp->type = type_id;\n\n\t \n\tt = btf_last_type(btf);\n\tbtf_type_inc_vlen(t);\n\n\tbtf->hdr->type_len += sz;\n\tbtf->hdr->str_off += sz;\n\treturn 0;\n}\n\n \nint btf__add_var(struct btf *btf, const char *name, int linkage, int type_id)\n{\n\tstruct btf_type *t;\n\tstruct btf_var *v;\n\tint sz, name_off;\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\tif (linkage != BTF_VAR_STATIC && linkage != BTF_VAR_GLOBAL_ALLOCATED &&\n\t    linkage != BTF_VAR_GLOBAL_EXTERN)\n\t\treturn libbpf_err(-EINVAL);\n\tif (validate_type_id(type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type) + sizeof(struct btf_var);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\tt->name_off = name_off;\n\tt->info = btf_type_info(BTF_KIND_VAR, 0, 0);\n\tt->type = type_id;\n\n\tv = btf_var(t);\n\tv->linkage = linkage;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_datasec(struct btf *btf, const char *name, __u32 byte_sz)\n{\n\tstruct btf_type *t;\n\tint sz, name_off;\n\n\t \n\tif (!name || !name[0])\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tname_off = btf__add_str(btf, name);\n\tif (name_off < 0)\n\t\treturn name_off;\n\n\t \n\tt->name_off = name_off;\n\tt->info = btf_type_info(BTF_KIND_DATASEC, 0, 0);\n\tt->size = byte_sz;\n\n\treturn btf_commit_type(btf, sz);\n}\n\n \nint btf__add_datasec_var_info(struct btf *btf, int var_type_id, __u32 offset, __u32 byte_sz)\n{\n\tstruct btf_type *t;\n\tstruct btf_var_secinfo *v;\n\tint sz;\n\n\t \n\tif (btf->nr_types == 0)\n\t\treturn libbpf_err(-EINVAL);\n\tt = btf_last_type(btf);\n\tif (!btf_is_datasec(t))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (validate_type_id(var_type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_var_secinfo);\n\tv = btf_add_type_mem(btf, sz);\n\tif (!v)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tv->type = var_type_id;\n\tv->offset = offset;\n\tv->size = byte_sz;\n\n\t \n\tt = btf_last_type(btf);\n\tbtf_type_inc_vlen(t);\n\n\tbtf->hdr->type_len += sz;\n\tbtf->hdr->str_off += sz;\n\treturn 0;\n}\n\n \nint btf__add_decl_tag(struct btf *btf, const char *value, int ref_type_id,\n\t\t int component_idx)\n{\n\tstruct btf_type *t;\n\tint sz, value_off;\n\n\tif (!value || !value[0] || component_idx < -1)\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (validate_type_id(ref_type_id))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (btf_ensure_modifiable(btf))\n\t\treturn libbpf_err(-ENOMEM);\n\n\tsz = sizeof(struct btf_type) + sizeof(struct btf_decl_tag);\n\tt = btf_add_type_mem(btf, sz);\n\tif (!t)\n\t\treturn libbpf_err(-ENOMEM);\n\n\tvalue_off = btf__add_str(btf, value);\n\tif (value_off < 0)\n\t\treturn value_off;\n\n\tt->name_off = value_off;\n\tt->info = btf_type_info(BTF_KIND_DECL_TAG, 0, false);\n\tt->type = ref_type_id;\n\tbtf_decl_tag(t)->component_idx = component_idx;\n\n\treturn btf_commit_type(btf, sz);\n}\n\nstruct btf_ext_sec_setup_param {\n\t__u32 off;\n\t__u32 len;\n\t__u32 min_rec_size;\n\tstruct btf_ext_info *ext_info;\n\tconst char *desc;\n};\n\nstatic int btf_ext_setup_info(struct btf_ext *btf_ext,\n\t\t\t      struct btf_ext_sec_setup_param *ext_sec)\n{\n\tconst struct btf_ext_info_sec *sinfo;\n\tstruct btf_ext_info *ext_info;\n\t__u32 info_left, record_size;\n\tsize_t sec_cnt = 0;\n\t \n\tvoid *info;\n\n\tif (ext_sec->len == 0)\n\t\treturn 0;\n\n\tif (ext_sec->off & 0x03) {\n\t\tpr_debug(\".BTF.ext %s section is not aligned to 4 bytes\\n\",\n\t\t     ext_sec->desc);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = btf_ext->data + btf_ext->hdr->hdr_len + ext_sec->off;\n\tinfo_left = ext_sec->len;\n\n\tif (btf_ext->data + btf_ext->data_size < info + ext_sec->len) {\n\t\tpr_debug(\"%s section (off:%u len:%u) is beyond the end of the ELF section .BTF.ext\\n\",\n\t\t\t ext_sec->desc, ext_sec->off, ext_sec->len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info_left < sizeof(__u32)) {\n\t\tpr_debug(\".BTF.ext %s record size not found\\n\", ext_sec->desc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trecord_size = *(__u32 *)info;\n\tif (record_size < ext_sec->min_rec_size ||\n\t    record_size & 0x03) {\n\t\tpr_debug(\"%s section in .BTF.ext has invalid record size %u\\n\",\n\t\t\t ext_sec->desc, record_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsinfo = info + sizeof(__u32);\n\tinfo_left -= sizeof(__u32);\n\n\t \n\tif (!info_left) {\n\t\tpr_debug(\"%s section in .BTF.ext has no records\", ext_sec->desc);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (info_left) {\n\t\tunsigned int sec_hdrlen = sizeof(struct btf_ext_info_sec);\n\t\t__u64 total_record_size;\n\t\t__u32 num_records;\n\n\t\tif (info_left < sec_hdrlen) {\n\t\t\tpr_debug(\"%s section header is not found in .BTF.ext\\n\",\n\t\t\t     ext_sec->desc);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_records = sinfo->num_info;\n\t\tif (num_records == 0) {\n\t\t\tpr_debug(\"%s section has incorrect num_records in .BTF.ext\\n\",\n\t\t\t     ext_sec->desc);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttotal_record_size = sec_hdrlen + (__u64)num_records * record_size;\n\t\tif (info_left < total_record_size) {\n\t\t\tpr_debug(\"%s section has incorrect num_records in .BTF.ext\\n\",\n\t\t\t     ext_sec->desc);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo_left -= total_record_size;\n\t\tsinfo = (void *)sinfo + total_record_size;\n\t\tsec_cnt++;\n\t}\n\n\text_info = ext_sec->ext_info;\n\text_info->len = ext_sec->len - sizeof(__u32);\n\text_info->rec_size = record_size;\n\text_info->info = info + sizeof(__u32);\n\text_info->sec_cnt = sec_cnt;\n\n\treturn 0;\n}\n\nstatic int btf_ext_setup_func_info(struct btf_ext *btf_ext)\n{\n\tstruct btf_ext_sec_setup_param param = {\n\t\t.off = btf_ext->hdr->func_info_off,\n\t\t.len = btf_ext->hdr->func_info_len,\n\t\t.min_rec_size = sizeof(struct bpf_func_info_min),\n\t\t.ext_info = &btf_ext->func_info,\n\t\t.desc = \"func_info\"\n\t};\n\n\treturn btf_ext_setup_info(btf_ext, &param);\n}\n\nstatic int btf_ext_setup_line_info(struct btf_ext *btf_ext)\n{\n\tstruct btf_ext_sec_setup_param param = {\n\t\t.off = btf_ext->hdr->line_info_off,\n\t\t.len = btf_ext->hdr->line_info_len,\n\t\t.min_rec_size = sizeof(struct bpf_line_info_min),\n\t\t.ext_info = &btf_ext->line_info,\n\t\t.desc = \"line_info\",\n\t};\n\n\treturn btf_ext_setup_info(btf_ext, &param);\n}\n\nstatic int btf_ext_setup_core_relos(struct btf_ext *btf_ext)\n{\n\tstruct btf_ext_sec_setup_param param = {\n\t\t.off = btf_ext->hdr->core_relo_off,\n\t\t.len = btf_ext->hdr->core_relo_len,\n\t\t.min_rec_size = sizeof(struct bpf_core_relo),\n\t\t.ext_info = &btf_ext->core_relo_info,\n\t\t.desc = \"core_relo\",\n\t};\n\n\treturn btf_ext_setup_info(btf_ext, &param);\n}\n\nstatic int btf_ext_parse_hdr(__u8 *data, __u32 data_size)\n{\n\tconst struct btf_ext_header *hdr = (struct btf_ext_header *)data;\n\n\tif (data_size < offsetofend(struct btf_ext_header, hdr_len) ||\n\t    data_size < hdr->hdr_len) {\n\t\tpr_debug(\"BTF.ext header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->magic == bswap_16(BTF_MAGIC)) {\n\t\tpr_warn(\"BTF.ext in non-native endianness is not supported\\n\");\n\t\treturn -ENOTSUP;\n\t} else if (hdr->magic != BTF_MAGIC) {\n\t\tpr_debug(\"Invalid BTF.ext magic:%x\\n\", hdr->magic);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tpr_debug(\"Unsupported BTF.ext version:%u\\n\", hdr->version);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (hdr->flags) {\n\t\tpr_debug(\"Unsupported BTF.ext flags:%x\\n\", hdr->flags);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (data_size == hdr->hdr_len) {\n\t\tpr_debug(\"BTF.ext has no data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid btf_ext__free(struct btf_ext *btf_ext)\n{\n\tif (IS_ERR_OR_NULL(btf_ext))\n\t\treturn;\n\tfree(btf_ext->func_info.sec_idxs);\n\tfree(btf_ext->line_info.sec_idxs);\n\tfree(btf_ext->core_relo_info.sec_idxs);\n\tfree(btf_ext->data);\n\tfree(btf_ext);\n}\n\nstruct btf_ext *btf_ext__new(const __u8 *data, __u32 size)\n{\n\tstruct btf_ext *btf_ext;\n\tint err;\n\n\tbtf_ext = calloc(1, sizeof(struct btf_ext));\n\tif (!btf_ext)\n\t\treturn libbpf_err_ptr(-ENOMEM);\n\n\tbtf_ext->data_size = size;\n\tbtf_ext->data = malloc(size);\n\tif (!btf_ext->data) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tmemcpy(btf_ext->data, data, size);\n\n\terr = btf_ext_parse_hdr(btf_ext->data, size);\n\tif (err)\n\t\tgoto done;\n\n\tif (btf_ext->hdr->hdr_len < offsetofend(struct btf_ext_header, line_info_len)) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = btf_ext_setup_func_info(btf_ext);\n\tif (err)\n\t\tgoto done;\n\n\terr = btf_ext_setup_line_info(btf_ext);\n\tif (err)\n\t\tgoto done;\n\n\tif (btf_ext->hdr->hdr_len < offsetofend(struct btf_ext_header, core_relo_len))\n\t\tgoto done;  \n\n\terr = btf_ext_setup_core_relos(btf_ext);\n\tif (err)\n\t\tgoto done;\n\ndone:\n\tif (err) {\n\t\tbtf_ext__free(btf_ext);\n\t\treturn libbpf_err_ptr(err);\n\t}\n\n\treturn btf_ext;\n}\n\nconst void *btf_ext__get_raw_data(const struct btf_ext *btf_ext, __u32 *size)\n{\n\t*size = btf_ext->data_size;\n\treturn btf_ext->data;\n}\n\nstruct btf_dedup;\n\nstatic struct btf_dedup *btf_dedup_new(struct btf *btf, const struct btf_dedup_opts *opts);\nstatic void btf_dedup_free(struct btf_dedup *d);\nstatic int btf_dedup_prep(struct btf_dedup *d);\nstatic int btf_dedup_strings(struct btf_dedup *d);\nstatic int btf_dedup_prim_types(struct btf_dedup *d);\nstatic int btf_dedup_struct_types(struct btf_dedup *d);\nstatic int btf_dedup_ref_types(struct btf_dedup *d);\nstatic int btf_dedup_resolve_fwds(struct btf_dedup *d);\nstatic int btf_dedup_compact_types(struct btf_dedup *d);\nstatic int btf_dedup_remap_types(struct btf_dedup *d);\n\n \nint btf__dedup(struct btf *btf, const struct btf_dedup_opts *opts)\n{\n\tstruct btf_dedup *d;\n\tint err;\n\n\tif (!OPTS_VALID(opts, btf_dedup_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\td = btf_dedup_new(btf, opts);\n\tif (IS_ERR(d)) {\n\t\tpr_debug(\"btf_dedup_new failed: %ld\", PTR_ERR(d));\n\t\treturn libbpf_err(-EINVAL);\n\t}\n\n\tif (btf_ensure_modifiable(btf)) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\terr = btf_dedup_prep(d);\n\tif (err) {\n\t\tpr_debug(\"btf_dedup_prep failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_strings(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_strings failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_prim_types(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_prim_types failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_struct_types(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_struct_types failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_resolve_fwds(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_resolve_fwds failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_ref_types(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_ref_types failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_compact_types(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_compact_types failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\terr = btf_dedup_remap_types(d);\n\tif (err < 0) {\n\t\tpr_debug(\"btf_dedup_remap_types failed:%d\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tbtf_dedup_free(d);\n\treturn libbpf_err(err);\n}\n\n#define BTF_UNPROCESSED_ID ((__u32)-1)\n#define BTF_IN_PROGRESS_ID ((__u32)-2)\n\nstruct btf_dedup {\n\t \n\tstruct btf *btf;\n\t \n\tstruct btf_ext *btf_ext;\n\t \n\tstruct hashmap *dedup_table;\n\t \n\t__u32 *map;\n\t \n\t__u32 *hypot_map;\n\t__u32 *hypot_list;\n\tsize_t hypot_cnt;\n\tsize_t hypot_cap;\n\t \n\tbool hypot_adjust_canon;\n\t \n\tstruct btf_dedup_opts opts;\n\t \n\tstruct strset *strs_set;\n};\n\nstatic long hash_combine(long h, long value)\n{\n\treturn h * 31 + value;\n}\n\n#define for_each_dedup_cand(d, node, hash) \\\n\thashmap__for_each_key_entry(d->dedup_table, node, hash)\n\nstatic int btf_dedup_table_add(struct btf_dedup *d, long hash, __u32 type_id)\n{\n\treturn hashmap__append(d->dedup_table, hash, type_id);\n}\n\nstatic int btf_dedup_hypot_map_add(struct btf_dedup *d,\n\t\t\t\t   __u32 from_id, __u32 to_id)\n{\n\tif (d->hypot_cnt == d->hypot_cap) {\n\t\t__u32 *new_list;\n\n\t\td->hypot_cap += max((size_t)16, d->hypot_cap / 2);\n\t\tnew_list = libbpf_reallocarray(d->hypot_list, d->hypot_cap, sizeof(__u32));\n\t\tif (!new_list)\n\t\t\treturn -ENOMEM;\n\t\td->hypot_list = new_list;\n\t}\n\td->hypot_list[d->hypot_cnt++] = from_id;\n\td->hypot_map[from_id] = to_id;\n\treturn 0;\n}\n\nstatic void btf_dedup_clear_hypot_map(struct btf_dedup *d)\n{\n\tint i;\n\n\tfor (i = 0; i < d->hypot_cnt; i++)\n\t\td->hypot_map[d->hypot_list[i]] = BTF_UNPROCESSED_ID;\n\td->hypot_cnt = 0;\n\td->hypot_adjust_canon = false;\n}\n\nstatic void btf_dedup_free(struct btf_dedup *d)\n{\n\thashmap__free(d->dedup_table);\n\td->dedup_table = NULL;\n\n\tfree(d->map);\n\td->map = NULL;\n\n\tfree(d->hypot_map);\n\td->hypot_map = NULL;\n\n\tfree(d->hypot_list);\n\td->hypot_list = NULL;\n\n\tfree(d);\n}\n\nstatic size_t btf_dedup_identity_hash_fn(long key, void *ctx)\n{\n\treturn key;\n}\n\nstatic size_t btf_dedup_collision_hash_fn(long key, void *ctx)\n{\n\treturn 0;\n}\n\nstatic bool btf_dedup_equal_fn(long k1, long k2, void *ctx)\n{\n\treturn k1 == k2;\n}\n\nstatic struct btf_dedup *btf_dedup_new(struct btf *btf, const struct btf_dedup_opts *opts)\n{\n\tstruct btf_dedup *d = calloc(1, sizeof(struct btf_dedup));\n\thashmap_hash_fn hash_fn = btf_dedup_identity_hash_fn;\n\tint i, err = 0, type_cnt;\n\n\tif (!d)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (OPTS_GET(opts, force_collisions, false))\n\t\thash_fn = btf_dedup_collision_hash_fn;\n\n\td->btf = btf;\n\td->btf_ext = OPTS_GET(opts, btf_ext, NULL);\n\n\td->dedup_table = hashmap__new(hash_fn, btf_dedup_equal_fn, NULL);\n\tif (IS_ERR(d->dedup_table)) {\n\t\terr = PTR_ERR(d->dedup_table);\n\t\td->dedup_table = NULL;\n\t\tgoto done;\n\t}\n\n\ttype_cnt = btf__type_cnt(btf);\n\td->map = malloc(sizeof(__u32) * type_cnt);\n\tif (!d->map) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\t \n\td->map[0] = 0;\n\tfor (i = 1; i < type_cnt; i++) {\n\t\tstruct btf_type *t = btf_type_by_id(d->btf, i);\n\n\t\t \n\t\tif (btf_is_var(t) || btf_is_datasec(t))\n\t\t\td->map[i] = i;\n\t\telse\n\t\t\td->map[i] = BTF_UNPROCESSED_ID;\n\t}\n\n\td->hypot_map = malloc(sizeof(__u32) * type_cnt);\n\tif (!d->hypot_map) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tfor (i = 0; i < type_cnt; i++)\n\t\td->hypot_map[i] = BTF_UNPROCESSED_ID;\n\ndone:\n\tif (err) {\n\t\tbtf_dedup_free(d);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn d;\n}\n\n \nstatic int btf_for_each_str_off(struct btf_dedup *d, str_off_visit_fn fn, void *ctx)\n{\n\tint i, r;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\tstruct btf_type *t = btf_type_by_id(d->btf, d->btf->start_id + i);\n\n\t\tr = btf_type_visit_str_offs(t, fn, ctx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (!d->btf_ext)\n\t\treturn 0;\n\n\tr = btf_ext_visit_str_offs(d->btf_ext, fn, ctx);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int strs_dedup_remap_str_off(__u32 *str_off_ptr, void *ctx)\n{\n\tstruct btf_dedup *d = ctx;\n\t__u32 str_off = *str_off_ptr;\n\tconst char *s;\n\tint off, err;\n\n\t \n\tif (str_off == 0 || str_off < d->btf->start_str_off)\n\t\treturn 0;\n\n\ts = btf__str_by_offset(d->btf, str_off);\n\tif (d->btf->base_btf) {\n\t\terr = btf__find_str(d->btf->base_btf, s);\n\t\tif (err >= 0) {\n\t\t\t*str_off_ptr = err;\n\t\t\treturn 0;\n\t\t}\n\t\tif (err != -ENOENT)\n\t\t\treturn err;\n\t}\n\n\toff = strset__add_str(d->strs_set, s);\n\tif (off < 0)\n\t\treturn off;\n\n\t*str_off_ptr = d->btf->start_str_off + off;\n\treturn 0;\n}\n\n \nstatic int btf_dedup_strings(struct btf_dedup *d)\n{\n\tint err;\n\n\tif (d->btf->strs_deduped)\n\t\treturn 0;\n\n\td->strs_set = strset__new(BTF_MAX_STR_OFFSET, NULL, 0);\n\tif (IS_ERR(d->strs_set)) {\n\t\terr = PTR_ERR(d->strs_set);\n\t\tgoto err_out;\n\t}\n\n\tif (!d->btf->base_btf) {\n\t\t \n\t\terr = strset__add_str(d->strs_set, \"\");\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\terr = btf_for_each_str_off(d, strs_dedup_remap_str_off, d);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tstrset__free(d->btf->strs_set);\n\td->btf->hdr->str_len = strset__data_size(d->strs_set);\n\td->btf->strs_set = d->strs_set;\n\td->strs_set = NULL;\n\td->btf->strs_deduped = true;\n\treturn 0;\n\nerr_out:\n\tstrset__free(d->strs_set);\n\td->strs_set = NULL;\n\n\treturn err;\n}\n\nstatic long btf_hash_common(struct btf_type *t)\n{\n\tlong h;\n\n\th = hash_combine(0, t->name_off);\n\th = hash_combine(h, t->info);\n\th = hash_combine(h, t->size);\n\treturn h;\n}\n\nstatic bool btf_equal_common(struct btf_type *t1, struct btf_type *t2)\n{\n\treturn t1->name_off == t2->name_off &&\n\t       t1->info == t2->info &&\n\t       t1->size == t2->size;\n}\n\n \nstatic long btf_hash_int_decl_tag(struct btf_type *t)\n{\n\t__u32 info = *(__u32 *)(t + 1);\n\tlong h;\n\n\th = btf_hash_common(t);\n\th = hash_combine(h, info);\n\treturn h;\n}\n\n \nstatic bool btf_equal_int_tag(struct btf_type *t1, struct btf_type *t2)\n{\n\t__u32 info1, info2;\n\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\tinfo1 = *(__u32 *)(t1 + 1);\n\tinfo2 = *(__u32 *)(t2 + 1);\n\treturn info1 == info2;\n}\n\n \nstatic long btf_hash_enum(struct btf_type *t)\n{\n\tlong h;\n\n\t \n\th = hash_combine(0, t->name_off);\n\treturn h;\n}\n\nstatic bool btf_equal_enum_members(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_enum *m1, *m2;\n\t__u16 vlen;\n\tint i;\n\n\tvlen = btf_vlen(t1);\n\tm1 = btf_enum(t1);\n\tm2 = btf_enum(t2);\n\tfor (i = 0; i < vlen; i++) {\n\t\tif (m1->name_off != m2->name_off || m1->val != m2->val)\n\t\t\treturn false;\n\t\tm1++;\n\t\tm2++;\n\t}\n\treturn true;\n}\n\nstatic bool btf_equal_enum64_members(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_enum64 *m1, *m2;\n\t__u16 vlen;\n\tint i;\n\n\tvlen = btf_vlen(t1);\n\tm1 = btf_enum64(t1);\n\tm2 = btf_enum64(t2);\n\tfor (i = 0; i < vlen; i++) {\n\t\tif (m1->name_off != m2->name_off || m1->val_lo32 != m2->val_lo32 ||\n\t\t    m1->val_hi32 != m2->val_hi32)\n\t\t\treturn false;\n\t\tm1++;\n\t\tm2++;\n\t}\n\treturn true;\n}\n\n \nstatic bool btf_equal_enum(struct btf_type *t1, struct btf_type *t2)\n{\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\n\t \n\tif (btf_kind(t1) == BTF_KIND_ENUM)\n\t\treturn btf_equal_enum_members(t1, t2);\n\telse\n\t\treturn btf_equal_enum64_members(t1, t2);\n}\n\nstatic inline bool btf_is_enum_fwd(struct btf_type *t)\n{\n\treturn btf_is_any_enum(t) && btf_vlen(t) == 0;\n}\n\nstatic bool btf_compat_enum(struct btf_type *t1, struct btf_type *t2)\n{\n\tif (!btf_is_enum_fwd(t1) && !btf_is_enum_fwd(t2))\n\t\treturn btf_equal_enum(t1, t2);\n\t \n\treturn t1->name_off == t2->name_off &&\n\t       btf_is_any_enum(t1) && btf_is_any_enum(t2);\n}\n\n \nstatic long btf_hash_struct(struct btf_type *t)\n{\n\tconst struct btf_member *member = btf_members(t);\n\t__u32 vlen = btf_vlen(t);\n\tlong h = btf_hash_common(t);\n\tint i;\n\n\tfor (i = 0; i < vlen; i++) {\n\t\th = hash_combine(h, member->name_off);\n\t\th = hash_combine(h, member->offset);\n\t\t \n\t\tmember++;\n\t}\n\treturn h;\n}\n\n \nstatic bool btf_shallow_equal_struct(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_member *m1, *m2;\n\t__u16 vlen;\n\tint i;\n\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\n\tvlen = btf_vlen(t1);\n\tm1 = btf_members(t1);\n\tm2 = btf_members(t2);\n\tfor (i = 0; i < vlen; i++) {\n\t\tif (m1->name_off != m2->name_off || m1->offset != m2->offset)\n\t\t\treturn false;\n\t\tm1++;\n\t\tm2++;\n\t}\n\treturn true;\n}\n\n \nstatic long btf_hash_array(struct btf_type *t)\n{\n\tconst struct btf_array *info = btf_array(t);\n\tlong h = btf_hash_common(t);\n\n\th = hash_combine(h, info->type);\n\th = hash_combine(h, info->index_type);\n\th = hash_combine(h, info->nelems);\n\treturn h;\n}\n\n \nstatic bool btf_equal_array(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_array *info1, *info2;\n\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\n\tinfo1 = btf_array(t1);\n\tinfo2 = btf_array(t2);\n\treturn info1->type == info2->type &&\n\t       info1->index_type == info2->index_type &&\n\t       info1->nelems == info2->nelems;\n}\n\n \nstatic bool btf_compat_array(struct btf_type *t1, struct btf_type *t2)\n{\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\n\treturn btf_array(t1)->nelems == btf_array(t2)->nelems;\n}\n\n \nstatic long btf_hash_fnproto(struct btf_type *t)\n{\n\tconst struct btf_param *member = btf_params(t);\n\t__u16 vlen = btf_vlen(t);\n\tlong h = btf_hash_common(t);\n\tint i;\n\n\tfor (i = 0; i < vlen; i++) {\n\t\th = hash_combine(h, member->name_off);\n\t\th = hash_combine(h, member->type);\n\t\tmember++;\n\t}\n\treturn h;\n}\n\n \nstatic bool btf_equal_fnproto(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_param *m1, *m2;\n\t__u16 vlen;\n\tint i;\n\n\tif (!btf_equal_common(t1, t2))\n\t\treturn false;\n\n\tvlen = btf_vlen(t1);\n\tm1 = btf_params(t1);\n\tm2 = btf_params(t2);\n\tfor (i = 0; i < vlen; i++) {\n\t\tif (m1->name_off != m2->name_off || m1->type != m2->type)\n\t\t\treturn false;\n\t\tm1++;\n\t\tm2++;\n\t}\n\treturn true;\n}\n\n \nstatic bool btf_compat_fnproto(struct btf_type *t1, struct btf_type *t2)\n{\n\tconst struct btf_param *m1, *m2;\n\t__u16 vlen;\n\tint i;\n\n\t \n\tif (t1->name_off != t2->name_off || t1->info != t2->info)\n\t\treturn false;\n\n\tvlen = btf_vlen(t1);\n\tm1 = btf_params(t1);\n\tm2 = btf_params(t2);\n\tfor (i = 0; i < vlen; i++) {\n\t\tif (m1->name_off != m2->name_off)\n\t\t\treturn false;\n\t\tm1++;\n\t\tm2++;\n\t}\n\treturn true;\n}\n\n \nstatic int btf_dedup_prep(struct btf_dedup *d)\n{\n\tstruct btf_type *t;\n\tint type_id;\n\tlong h;\n\n\tif (!d->btf->base_btf)\n\t\treturn 0;\n\n\tfor (type_id = 1; type_id < d->btf->start_id; type_id++) {\n\t\tt = btf_type_by_id(d->btf, type_id);\n\n\t\t \n\t\td->map[type_id] = type_id;\n\n\t\tswitch (btf_kind(t)) {\n\t\tcase BTF_KIND_VAR:\n\t\tcase BTF_KIND_DATASEC:\n\t\t\t \n\t\t\tcontinue;\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_PTR:\n\t\tcase BTF_KIND_FWD:\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_FUNC:\n\t\tcase BTF_KIND_FLOAT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\th = btf_hash_common(t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_DECL_TAG:\n\t\t\th = btf_hash_int_decl_tag(t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_ENUM64:\n\t\t\th = btf_hash_enum(t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\t\th = btf_hash_struct(t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\th = btf_hash_array(t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_FUNC_PROTO:\n\t\t\th = btf_hash_fnproto(t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"unknown kind %d for type [%d]\\n\", btf_kind(t), type_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_dedup_table_add(d, h, type_id))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int btf_dedup_prim_type(struct btf_dedup *d, __u32 type_id)\n{\n\tstruct btf_type *t = btf_type_by_id(d->btf, type_id);\n\tstruct hashmap_entry *hash_entry;\n\tstruct btf_type *cand;\n\t \n\t__u32 new_id = type_id;\n\t__u32 cand_id;\n\tlong h;\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_ARRAY:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_FUNC_PROTO:\n\tcase BTF_KIND_VAR:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_DECL_TAG:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn 0;\n\n\tcase BTF_KIND_INT:\n\t\th = btf_hash_int_decl_tag(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_int_tag(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\th = btf_hash_enum(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_enum(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (btf_compat_enum(t, cand)) {\n\t\t\t\tif (btf_is_enum_fwd(t)) {\n\t\t\t\t\t \n\t\t\t\t\tnew_id = cand_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\td->map[cand_id] = type_id;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_FLOAT:\n\t\th = btf_hash_common(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_common(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\td->map[type_id] = new_id;\n\tif (type_id == new_id && btf_dedup_table_add(d, h, type_id))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int btf_dedup_prim_types(struct btf_dedup *d)\n{\n\tint i, err;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\terr = btf_dedup_prim_type(d, d->btf->start_id + i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic inline bool is_type_mapped(struct btf_dedup *d, uint32_t type_id)\n{\n\treturn d->map[type_id] <= BTF_MAX_NR_TYPES;\n}\n\n \nstatic inline __u32 resolve_type_id(struct btf_dedup *d, __u32 type_id)\n{\n\twhile (is_type_mapped(d, type_id) && d->map[type_id] != type_id)\n\t\ttype_id = d->map[type_id];\n\treturn type_id;\n}\n\n \nstatic uint32_t resolve_fwd_id(struct btf_dedup *d, uint32_t type_id)\n{\n\t__u32 orig_type_id = type_id;\n\n\tif (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))\n\t\treturn type_id;\n\n\twhile (is_type_mapped(d, type_id) && d->map[type_id] != type_id)\n\t\ttype_id = d->map[type_id];\n\n\tif (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))\n\t\treturn type_id;\n\n\treturn orig_type_id;\n}\n\n\nstatic inline __u16 btf_fwd_kind(struct btf_type *t)\n{\n\treturn btf_kflag(t) ? BTF_KIND_UNION : BTF_KIND_STRUCT;\n}\n\n \nstatic bool btf_dedup_identical_arrays(struct btf_dedup *d, __u32 id1, __u32 id2)\n{\n\tstruct btf_type *t1, *t2;\n\n\tt1 = btf_type_by_id(d->btf, id1);\n\tt2 = btf_type_by_id(d->btf, id2);\n\tif (!btf_is_array(t1) || !btf_is_array(t2))\n\t\treturn false;\n\n\treturn btf_equal_array(t1, t2);\n}\n\n \nstatic bool btf_dedup_identical_structs(struct btf_dedup *d, __u32 id1, __u32 id2)\n{\n\tconst struct btf_member *m1, *m2;\n\tstruct btf_type *t1, *t2;\n\tint n, i;\n\n\tt1 = btf_type_by_id(d->btf, id1);\n\tt2 = btf_type_by_id(d->btf, id2);\n\n\tif (!btf_is_composite(t1) || btf_kind(t1) != btf_kind(t2))\n\t\treturn false;\n\n\tif (!btf_shallow_equal_struct(t1, t2))\n\t\treturn false;\n\n\tm1 = btf_members(t1);\n\tm2 = btf_members(t2);\n\tfor (i = 0, n = btf_vlen(t1); i < n; i++, m1++, m2++) {\n\t\tif (m1->type != m2->type &&\n\t\t    !btf_dedup_identical_arrays(d, m1->type, m2->type) &&\n\t\t    !btf_dedup_identical_structs(d, m1->type, m2->type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int btf_dedup_is_equiv(struct btf_dedup *d, __u32 cand_id,\n\t\t\t      __u32 canon_id)\n{\n\tstruct btf_type *cand_type;\n\tstruct btf_type *canon_type;\n\t__u32 hypot_type_id;\n\t__u16 cand_kind;\n\t__u16 canon_kind;\n\tint i, eq;\n\n\t \n\tif (resolve_type_id(d, cand_id) == resolve_type_id(d, canon_id))\n\t\treturn 1;\n\n\tcanon_id = resolve_fwd_id(d, canon_id);\n\n\thypot_type_id = d->hypot_map[canon_id];\n\tif (hypot_type_id <= BTF_MAX_NR_TYPES) {\n\t\tif (hypot_type_id == cand_id)\n\t\t\treturn 1;\n\t\t \n\t\tif (btf_dedup_identical_arrays(d, hypot_type_id, cand_id))\n\t\t\treturn 1;\n\t\t \n\t\tif (btf_dedup_identical_structs(d, hypot_type_id, cand_id))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (btf_dedup_hypot_map_add(d, canon_id, cand_id))\n\t\treturn -ENOMEM;\n\n\tcand_type = btf_type_by_id(d->btf, cand_id);\n\tcanon_type = btf_type_by_id(d->btf, canon_id);\n\tcand_kind = btf_kind(cand_type);\n\tcanon_kind = btf_kind(canon_type);\n\n\tif (cand_type->name_off != canon_type->name_off)\n\t\treturn 0;\n\n\t \n\tif ((cand_kind == BTF_KIND_FWD || canon_kind == BTF_KIND_FWD)\n\t    && cand_kind != canon_kind) {\n\t\t__u16 real_kind;\n\t\t__u16 fwd_kind;\n\n\t\tif (cand_kind == BTF_KIND_FWD) {\n\t\t\treal_kind = canon_kind;\n\t\t\tfwd_kind = btf_fwd_kind(cand_type);\n\t\t} else {\n\t\t\treal_kind = cand_kind;\n\t\t\tfwd_kind = btf_fwd_kind(canon_type);\n\t\t\t \n\t\t\tif (fwd_kind == real_kind && canon_id < d->btf->start_id)\n\t\t\t\td->hypot_adjust_canon = true;\n\t\t}\n\t\treturn fwd_kind == real_kind;\n\t}\n\n\tif (cand_kind != canon_kind)\n\t\treturn 0;\n\n\tswitch (cand_kind) {\n\tcase BTF_KIND_INT:\n\t\treturn btf_equal_int_tag(cand_type, canon_type);\n\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\treturn btf_compat_enum(cand_type, canon_type);\n\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_FLOAT:\n\t\treturn btf_equal_common(cand_type, canon_type);\n\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_TYPE_TAG:\n\t\tif (cand_type->info != canon_type->info)\n\t\t\treturn 0;\n\t\treturn btf_dedup_is_equiv(d, cand_type->type, canon_type->type);\n\n\tcase BTF_KIND_ARRAY: {\n\t\tconst struct btf_array *cand_arr, *canon_arr;\n\n\t\tif (!btf_compat_array(cand_type, canon_type))\n\t\t\treturn 0;\n\t\tcand_arr = btf_array(cand_type);\n\t\tcanon_arr = btf_array(canon_type);\n\t\teq = btf_dedup_is_equiv(d, cand_arr->index_type, canon_arr->index_type);\n\t\tif (eq <= 0)\n\t\t\treturn eq;\n\t\treturn btf_dedup_is_equiv(d, cand_arr->type, canon_arr->type);\n\t}\n\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *cand_m, *canon_m;\n\t\t__u16 vlen;\n\n\t\tif (!btf_shallow_equal_struct(cand_type, canon_type))\n\t\t\treturn 0;\n\t\tvlen = btf_vlen(cand_type);\n\t\tcand_m = btf_members(cand_type);\n\t\tcanon_m = btf_members(canon_type);\n\t\tfor (i = 0; i < vlen; i++) {\n\t\t\teq = btf_dedup_is_equiv(d, cand_m->type, canon_m->type);\n\t\t\tif (eq <= 0)\n\t\t\t\treturn eq;\n\t\t\tcand_m++;\n\t\t\tcanon_m++;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *cand_p, *canon_p;\n\t\t__u16 vlen;\n\n\t\tif (!btf_compat_fnproto(cand_type, canon_type))\n\t\t\treturn 0;\n\t\teq = btf_dedup_is_equiv(d, cand_type->type, canon_type->type);\n\t\tif (eq <= 0)\n\t\t\treturn eq;\n\t\tvlen = btf_vlen(cand_type);\n\t\tcand_p = btf_params(cand_type);\n\t\tcanon_p = btf_params(canon_type);\n\t\tfor (i = 0; i < vlen; i++) {\n\t\t\teq = btf_dedup_is_equiv(d, cand_p->type, canon_p->type);\n\t\t\tif (eq <= 0)\n\t\t\t\treturn eq;\n\t\t\tcand_p++;\n\t\t\tcanon_p++;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void btf_dedup_merge_hypot_map(struct btf_dedup *d)\n{\n\t__u32 canon_type_id, targ_type_id;\n\t__u16 t_kind, c_kind;\n\t__u32 t_id, c_id;\n\tint i;\n\n\tfor (i = 0; i < d->hypot_cnt; i++) {\n\t\tcanon_type_id = d->hypot_list[i];\n\t\ttarg_type_id = d->hypot_map[canon_type_id];\n\t\tt_id = resolve_type_id(d, targ_type_id);\n\t\tc_id = resolve_type_id(d, canon_type_id);\n\t\tt_kind = btf_kind(btf__type_by_id(d->btf, t_id));\n\t\tc_kind = btf_kind(btf__type_by_id(d->btf, c_id));\n\t\t \n\n\t\t \n\t\tif (t_kind != BTF_KIND_FWD && c_kind == BTF_KIND_FWD)\n\t\t\td->map[c_id] = t_id;\n\n\t\t \n\t\tif (d->hypot_adjust_canon)\n\t\t\tcontinue;\n\n\t\tif (t_kind == BTF_KIND_FWD && c_kind != BTF_KIND_FWD)\n\t\t\td->map[t_id] = c_id;\n\n\t\tif ((t_kind == BTF_KIND_STRUCT || t_kind == BTF_KIND_UNION) &&\n\t\t    c_kind != BTF_KIND_FWD &&\n\t\t    is_type_mapped(d, c_id) &&\n\t\t    !is_type_mapped(d, t_id)) {\n\t\t\t \n\t\t\td->map[t_id] = c_id;\n\t\t}\n\t}\n}\n\n \nstatic int btf_dedup_struct_type(struct btf_dedup *d, __u32 type_id)\n{\n\tstruct btf_type *cand_type, *t;\n\tstruct hashmap_entry *hash_entry;\n\t \n\t__u32 new_id = type_id;\n\t__u16 kind;\n\tlong h;\n\n\t \n\tif (d->map[type_id] <= BTF_MAX_NR_TYPES)\n\t\treturn 0;\n\n\tt = btf_type_by_id(d->btf, type_id);\n\tkind = btf_kind(t);\n\n\tif (kind != BTF_KIND_STRUCT && kind != BTF_KIND_UNION)\n\t\treturn 0;\n\n\th = btf_hash_struct(t);\n\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t__u32 cand_id = hash_entry->value;\n\t\tint eq;\n\n\t\t \n\t\tcand_type = btf_type_by_id(d->btf, cand_id);\n\t\tif (!btf_shallow_equal_struct(t, cand_type))\n\t\t\tcontinue;\n\n\t\tbtf_dedup_clear_hypot_map(d);\n\t\teq = btf_dedup_is_equiv(d, type_id, cand_id);\n\t\tif (eq < 0)\n\t\t\treturn eq;\n\t\tif (!eq)\n\t\t\tcontinue;\n\t\tbtf_dedup_merge_hypot_map(d);\n\t\tif (d->hypot_adjust_canon)  \n\t\t\tcontinue;\n\t\tnew_id = cand_id;\n\t\tbreak;\n\t}\n\n\td->map[type_id] = new_id;\n\tif (type_id == new_id && btf_dedup_table_add(d, h, type_id))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int btf_dedup_struct_types(struct btf_dedup *d)\n{\n\tint i, err;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\terr = btf_dedup_struct_type(d, d->btf->start_id + i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int btf_dedup_ref_type(struct btf_dedup *d, __u32 type_id)\n{\n\tstruct hashmap_entry *hash_entry;\n\t__u32 new_id = type_id, cand_id;\n\tstruct btf_type *t, *cand;\n\t \n\tint ref_type_id;\n\tlong h;\n\n\tif (d->map[type_id] == BTF_IN_PROGRESS_ID)\n\t\treturn -ELOOP;\n\tif (d->map[type_id] <= BTF_MAX_NR_TYPES)\n\t\treturn resolve_type_id(d, type_id);\n\n\tt = btf_type_by_id(d->btf, type_id);\n\td->map[type_id] = BTF_IN_PROGRESS_ID;\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_TYPE_TAG:\n\t\tref_type_id = btf_dedup_ref_type(d, t->type);\n\t\tif (ref_type_id < 0)\n\t\t\treturn ref_type_id;\n\t\tt->type = ref_type_id;\n\n\t\th = btf_hash_common(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_common(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BTF_KIND_DECL_TAG:\n\t\tref_type_id = btf_dedup_ref_type(d, t->type);\n\t\tif (ref_type_id < 0)\n\t\t\treturn ref_type_id;\n\t\tt->type = ref_type_id;\n\n\t\th = btf_hash_int_decl_tag(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_int_tag(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BTF_KIND_ARRAY: {\n\t\tstruct btf_array *info = btf_array(t);\n\n\t\tref_type_id = btf_dedup_ref_type(d, info->type);\n\t\tif (ref_type_id < 0)\n\t\t\treturn ref_type_id;\n\t\tinfo->type = ref_type_id;\n\n\t\tref_type_id = btf_dedup_ref_type(d, info->index_type);\n\t\tif (ref_type_id < 0)\n\t\t\treturn ref_type_id;\n\t\tinfo->index_type = ref_type_id;\n\n\t\th = btf_hash_array(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_array(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *param;\n\t\t__u16 vlen;\n\t\tint i;\n\n\t\tref_type_id = btf_dedup_ref_type(d, t->type);\n\t\tif (ref_type_id < 0)\n\t\t\treturn ref_type_id;\n\t\tt->type = ref_type_id;\n\n\t\tvlen = btf_vlen(t);\n\t\tparam = btf_params(t);\n\t\tfor (i = 0; i < vlen; i++) {\n\t\t\tref_type_id = btf_dedup_ref_type(d, param->type);\n\t\t\tif (ref_type_id < 0)\n\t\t\t\treturn ref_type_id;\n\t\t\tparam->type = ref_type_id;\n\t\t\tparam++;\n\t\t}\n\n\t\th = btf_hash_fnproto(t);\n\t\tfor_each_dedup_cand(d, hash_entry, h) {\n\t\t\tcand_id = hash_entry->value;\n\t\t\tcand = btf_type_by_id(d->btf, cand_id);\n\t\t\tif (btf_equal_fnproto(t, cand)) {\n\t\t\t\tnew_id = cand_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\td->map[type_id] = new_id;\n\tif (type_id == new_id && btf_dedup_table_add(d, h, type_id))\n\t\treturn -ENOMEM;\n\n\treturn new_id;\n}\n\nstatic int btf_dedup_ref_types(struct btf_dedup *d)\n{\n\tint i, err;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\terr = btf_dedup_ref_type(d, d->btf->start_id + i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\thashmap__free(d->dedup_table);\n\td->dedup_table = NULL;\n\treturn 0;\n}\n\n \nstatic int btf_dedup_fill_unique_names_map(struct btf_dedup *d, struct hashmap *names_map)\n{\n\t__u32 nr_types = btf__type_cnt(d->btf);\n\tstruct btf_type *t;\n\t__u32 type_id;\n\t__u16 kind;\n\tint err;\n\n\t \n\tfor (type_id = 1; type_id < nr_types; ++type_id) {\n\t\tt = btf_type_by_id(d->btf, type_id);\n\t\tkind = btf_kind(t);\n\n\t\tif (kind != BTF_KIND_STRUCT && kind != BTF_KIND_UNION)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (type_id != d->map[type_id])\n\t\t\tcontinue;\n\n\t\terr = hashmap__add(names_map, t->name_off, type_id);\n\t\tif (err == -EEXIST)\n\t\t\terr = hashmap__set(names_map, t->name_off, 0, NULL, NULL);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_dedup_resolve_fwd(struct btf_dedup *d, struct hashmap *names_map, __u32 type_id)\n{\n\tstruct btf_type *t = btf_type_by_id(d->btf, type_id);\n\tenum btf_fwd_kind fwd_kind = btf_kflag(t);\n\t__u16 cand_kind, kind = btf_kind(t);\n\tstruct btf_type *cand_t;\n\tuintptr_t cand_id;\n\n\tif (kind != BTF_KIND_FWD)\n\t\treturn 0;\n\n\t \n\tif (type_id != d->map[type_id])\n\t\treturn 0;\n\n\tif (!hashmap__find(names_map, t->name_off, &cand_id))\n\t\treturn 0;\n\n\t \n\tif (!cand_id)\n\t\treturn 0;\n\n\tcand_t = btf_type_by_id(d->btf, cand_id);\n\tcand_kind = btf_kind(cand_t);\n\tif ((cand_kind == BTF_KIND_STRUCT && fwd_kind != BTF_FWD_STRUCT) ||\n\t    (cand_kind == BTF_KIND_UNION && fwd_kind != BTF_FWD_UNION))\n\t\treturn 0;\n\n\td->map[type_id] = cand_id;\n\n\treturn 0;\n}\n\n \nstatic int btf_dedup_resolve_fwds(struct btf_dedup *d)\n{\n\tint i, err;\n\tstruct hashmap *names_map;\n\n\tnames_map = hashmap__new(btf_dedup_identity_hash_fn, btf_dedup_equal_fn, NULL);\n\tif (IS_ERR(names_map))\n\t\treturn PTR_ERR(names_map);\n\n\terr = btf_dedup_fill_unique_names_map(d, names_map);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\terr = btf_dedup_resolve_fwd(d, names_map, d->btf->start_id + i);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\nexit:\n\thashmap__free(names_map);\n\treturn err;\n}\n\n \nstatic int btf_dedup_compact_types(struct btf_dedup *d)\n{\n\t__u32 *new_offs;\n\t__u32 next_type_id = d->btf->start_id;\n\tconst struct btf_type *t;\n\tvoid *p;\n\tint i, id, len;\n\n\t \n\td->hypot_map[0] = 0;\n\t \n\tfor (id = 1; id < d->btf->start_id; id++)\n\t\td->hypot_map[id] = id;\n\tfor (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++)\n\t\td->hypot_map[id] = BTF_UNPROCESSED_ID;\n\n\tp = d->btf->types_data;\n\n\tfor (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++) {\n\t\tif (d->map[id] != id)\n\t\t\tcontinue;\n\n\t\tt = btf__type_by_id(d->btf, id);\n\t\tlen = btf_type_size(t);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tmemmove(p, t, len);\n\t\td->hypot_map[id] = next_type_id;\n\t\td->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;\n\t\tp += len;\n\t\tnext_type_id++;\n\t}\n\n\t \n\td->btf->nr_types = next_type_id - d->btf->start_id;\n\td->btf->type_offs_cap = d->btf->nr_types;\n\td->btf->hdr->type_len = p - d->btf->types_data;\n\tnew_offs = libbpf_reallocarray(d->btf->type_offs, d->btf->type_offs_cap,\n\t\t\t\t       sizeof(*new_offs));\n\tif (d->btf->type_offs_cap && !new_offs)\n\t\treturn -ENOMEM;\n\td->btf->type_offs = new_offs;\n\td->btf->hdr->str_off = d->btf->hdr->type_len;\n\td->btf->raw_size = d->btf->hdr->hdr_len + d->btf->hdr->type_len + d->btf->hdr->str_len;\n\treturn 0;\n}\n\n \nstatic int btf_dedup_remap_type_id(__u32 *type_id, void *ctx)\n{\n\tstruct btf_dedup *d = ctx;\n\t__u32 resolved_type_id, new_type_id;\n\n\tresolved_type_id = resolve_type_id(d, *type_id);\n\tnew_type_id = d->hypot_map[resolved_type_id];\n\tif (new_type_id > BTF_MAX_NR_TYPES)\n\t\treturn -EINVAL;\n\n\t*type_id = new_type_id;\n\treturn 0;\n}\n\n \nstatic int btf_dedup_remap_types(struct btf_dedup *d)\n{\n\tint i, r;\n\n\tfor (i = 0; i < d->btf->nr_types; i++) {\n\t\tstruct btf_type *t = btf_type_by_id(d->btf, d->btf->start_id + i);\n\n\t\tr = btf_type_visit_type_ids(t, btf_dedup_remap_type_id, d);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (!d->btf_ext)\n\t\treturn 0;\n\n\tr = btf_ext_visit_type_ids(d->btf_ext, btf_dedup_remap_type_id, d);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstruct btf *btf__load_vmlinux_btf(void)\n{\n\tconst char *locations[] = {\n\t\t \n\t\t\"/sys/kernel/btf/vmlinux\",\n\t\t \n\t\t\"/boot/vmlinux-%1$s\",\n\t\t\"/lib/modules/%1$s/vmlinux-%1$s\",\n\t\t\"/lib/modules/%1$s/build/vmlinux\",\n\t\t\"/usr/lib/modules/%1$s/kernel/vmlinux\",\n\t\t\"/usr/lib/debug/boot/vmlinux-%1$s\",\n\t\t\"/usr/lib/debug/boot/vmlinux-%1$s.debug\",\n\t\t\"/usr/lib/debug/lib/modules/%1$s/vmlinux\",\n\t};\n\tchar path[PATH_MAX + 1];\n\tstruct utsname buf;\n\tstruct btf *btf;\n\tint i, err;\n\n\tuname(&buf);\n\n\tfor (i = 0; i < ARRAY_SIZE(locations); i++) {\n\t\tsnprintf(path, PATH_MAX, locations[i], buf.release);\n\n\t\tif (faccessat(AT_FDCWD, path, R_OK, AT_EACCESS))\n\t\t\tcontinue;\n\n\t\tbtf = btf__parse(path, NULL);\n\t\terr = libbpf_get_error(btf);\n\t\tpr_debug(\"loading kernel BTF '%s': %d\\n\", path, err);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\treturn btf;\n\t}\n\n\tpr_warn(\"failed to find valid kernel BTF\\n\");\n\treturn libbpf_err_ptr(-ESRCH);\n}\n\nstruct btf *libbpf_find_kernel_btf(void) __attribute__((alias(\"btf__load_vmlinux_btf\")));\n\nstruct btf *btf__load_module_btf(const char *module_name, struct btf *vmlinux_btf)\n{\n\tchar path[80];\n\n\tsnprintf(path, sizeof(path), \"/sys/kernel/btf/%s\", module_name);\n\treturn btf__parse_split(path, vmlinux_btf);\n}\n\nint btf_type_visit_type_ids(struct btf_type *t, type_id_visit_fn visit, void *ctx)\n{\n\tint i, n, err;\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\treturn 0;\n\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_VAR:\n\tcase BTF_KIND_DECL_TAG:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn visit(&t->type, ctx);\n\n\tcase BTF_KIND_ARRAY: {\n\t\tstruct btf_array *a = btf_array(t);\n\n\t\terr = visit(&a->type, ctx);\n\t\terr = err ?: visit(&a->index_type, ctx);\n\t\treturn err;\n\t}\n\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tstruct btf_member *m = btf_members(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->type, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *m = btf_params(t);\n\n\t\terr = visit(&t->type, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->type, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcase BTF_KIND_DATASEC: {\n\t\tstruct btf_var_secinfo *m = btf_var_secinfos(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->type, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint btf_type_visit_str_offs(struct btf_type *t, str_off_visit_fn visit, void *ctx)\n{\n\tint i, n, err;\n\n\terr = visit(&t->name_off, ctx);\n\tif (err)\n\t\treturn err;\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tstruct btf_member *m = btf_members(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->name_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM: {\n\t\tstruct btf_enum *m = btf_enum(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->name_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM64: {\n\t\tstruct btf_enum64 *m = btf_enum64(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->name_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *m = btf_params(t);\n\n\t\tfor (i = 0, n = btf_vlen(t); i < n; i++, m++) {\n\t\t\terr = visit(&m->name_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint btf_ext_visit_type_ids(struct btf_ext *btf_ext, type_id_visit_fn visit, void *ctx)\n{\n\tconst struct btf_ext_info *seg;\n\tstruct btf_ext_info_sec *sec;\n\tint i, err;\n\n\tseg = &btf_ext->func_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tstruct bpf_func_info_min *rec;\n\n\t\tfor_each_btf_ext_rec(seg, sec, i, rec) {\n\t\t\terr = visit(&rec->type_id, ctx);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tseg = &btf_ext->core_relo_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tstruct bpf_core_relo *rec;\n\n\t\tfor_each_btf_ext_rec(seg, sec, i, rec) {\n\t\t\terr = visit(&rec->type_id, ctx);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint btf_ext_visit_str_offs(struct btf_ext *btf_ext, str_off_visit_fn visit, void *ctx)\n{\n\tconst struct btf_ext_info *seg;\n\tstruct btf_ext_info_sec *sec;\n\tint i, err;\n\n\tseg = &btf_ext->func_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\terr = visit(&sec->sec_name_off, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tseg = &btf_ext->line_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tstruct bpf_line_info_min *rec;\n\n\t\terr = visit(&sec->sec_name_off, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor_each_btf_ext_rec(seg, sec, i, rec) {\n\t\t\terr = visit(&rec->file_name_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = visit(&rec->line_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tseg = &btf_ext->core_relo_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tstruct bpf_core_relo *rec;\n\n\t\terr = visit(&sec->sec_name_off, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor_each_btf_ext_rec(seg, sec, i, rec) {\n\t\t\terr = visit(&rec->access_str_off, ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}