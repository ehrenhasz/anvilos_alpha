{
  "module_name": "netlink.c",
  "hash_id": "30479a7fbfe90a85bf6ec0ec6817dd50bd88e683e6eb1c9c073c2b3bd7a0000e",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/netlink.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <memory.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/pkt_cls.h>\n#include <linux/rtnetlink.h>\n#include <linux/netdev.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <time.h>\n\n#include \"bpf.h\"\n#include \"libbpf.h\"\n#include \"libbpf_internal.h\"\n#include \"nlattr.h\"\n\n#ifndef SOL_NETLINK\n#define SOL_NETLINK 270\n#endif\n\ntypedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);\n\ntypedef int (*__dump_nlmsg_t)(struct nlmsghdr *nlmsg, libbpf_dump_nlmsg_t,\n\t\t\t      void *cookie);\n\nstruct xdp_link_info {\n\t__u32 prog_id;\n\t__u32 drv_prog_id;\n\t__u32 hw_prog_id;\n\t__u32 skb_prog_id;\n\t__u8 attach_mode;\n};\n\nstruct xdp_id_md {\n\tint ifindex;\n\t__u32 flags;\n\tstruct xdp_link_info info;\n\t__u64 feature_flags;\n};\n\nstruct xdp_features_md {\n\tint ifindex;\n\t__u32 xdp_zc_max_segs;\n\t__u64 flags;\n};\n\nstatic int libbpf_netlink_open(__u32 *nl_pid, int proto)\n{\n\tstruct sockaddr_nl sa;\n\tsocklen_t addrlen;\n\tint one = 1, ret;\n\tint sock;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.nl_family = AF_NETLINK;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, proto);\n\tif (sock < 0)\n\t\treturn -errno;\n\n\tif (setsockopt(sock, SOL_NETLINK, NETLINK_EXT_ACK,\n\t\t       &one, sizeof(one)) < 0) {\n\t\tpr_warn(\"Netlink error reporting not supported\\n\");\n\t}\n\n\tif (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\n\taddrlen = sizeof(sa);\n\tif (getsockname(sock, (struct sockaddr *)&sa, &addrlen) < 0) {\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\n\tif (addrlen != sizeof(sa)) {\n\t\tret = -LIBBPF_ERRNO__INTERNAL;\n\t\tgoto cleanup;\n\t}\n\n\t*nl_pid = sa.nl_pid;\n\treturn sock;\n\ncleanup:\n\tclose(sock);\n\treturn ret;\n}\n\nstatic void libbpf_netlink_close(int sock)\n{\n\tclose(sock);\n}\n\nenum {\n\tNL_CONT,\n\tNL_NEXT,\n\tNL_DONE,\n};\n\nstatic int netlink_recvmsg(int sock, struct msghdr *mhdr, int flags)\n{\n\tint len;\n\n\tdo {\n\t\tlen = recvmsg(sock, mhdr, flags);\n\t} while (len < 0 && (errno == EINTR || errno == EAGAIN));\n\n\tif (len < 0)\n\t\treturn -errno;\n\treturn len;\n}\n\nstatic int alloc_iov(struct iovec *iov, int len)\n{\n\tvoid *nbuf;\n\n\tnbuf = realloc(iov->iov_base, len);\n\tif (!nbuf)\n\t\treturn -ENOMEM;\n\n\tiov->iov_base = nbuf;\n\tiov->iov_len = len;\n\treturn 0;\n}\n\nstatic int libbpf_netlink_recv(int sock, __u32 nl_pid, int seq,\n\t\t\t       __dump_nlmsg_t _fn, libbpf_dump_nlmsg_t fn,\n\t\t\t       void *cookie)\n{\n\tstruct iovec iov = {};\n\tstruct msghdr mhdr = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tbool multipart = true;\n\tstruct nlmsgerr *err;\n\tstruct nlmsghdr *nh;\n\tint len, ret;\n\n\tret = alloc_iov(&iov, 4096);\n\tif (ret)\n\t\tgoto done;\n\n\twhile (multipart) {\nstart:\n\t\tmultipart = false;\n\t\tlen = netlink_recvmsg(sock, &mhdr, MSG_PEEK | MSG_TRUNC);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (len > iov.iov_len) {\n\t\t\tret = alloc_iov(&iov, len);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tlen = netlink_recvmsg(sock, &mhdr, 0);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tfor (nh = (struct nlmsghdr *)iov.iov_base; NLMSG_OK(nh, len);\n\t\t     nh = NLMSG_NEXT(nh, len)) {\n\t\t\tif (nh->nlmsg_pid != nl_pid) {\n\t\t\t\tret = -LIBBPF_ERRNO__WRNGPID;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (nh->nlmsg_seq != seq) {\n\t\t\t\tret = -LIBBPF_ERRNO__INVSEQ;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (nh->nlmsg_flags & NLM_F_MULTI)\n\t\t\t\tmultipart = true;\n\t\t\tswitch (nh->nlmsg_type) {\n\t\t\tcase NLMSG_ERROR:\n\t\t\t\terr = (struct nlmsgerr *)NLMSG_DATA(nh);\n\t\t\t\tif (!err->error)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = err->error;\n\t\t\t\tlibbpf_nla_dump_errormsg(nh);\n\t\t\t\tgoto done;\n\t\t\tcase NLMSG_DONE:\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_fn) {\n\t\t\t\tret = _fn(nh, fn, cookie);\n\t\t\t\tswitch (ret) {\n\t\t\t\tcase NL_CONT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase NL_NEXT:\n\t\t\t\t\tgoto start;\n\t\t\t\tcase NL_DONE:\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tfree(iov.iov_base);\n\treturn ret;\n}\n\nstatic int libbpf_netlink_send_recv(struct libbpf_nla_req *req,\n\t\t\t\t    int proto, __dump_nlmsg_t parse_msg,\n\t\t\t\t    libbpf_dump_nlmsg_t parse_attr,\n\t\t\t\t    void *cookie)\n{\n\t__u32 nl_pid = 0;\n\tint sock, ret;\n\n\tsock = libbpf_netlink_open(&nl_pid, proto);\n\tif (sock < 0)\n\t\treturn sock;\n\n\treq->nh.nlmsg_pid = 0;\n\treq->nh.nlmsg_seq = time(NULL);\n\n\tif (send(sock, req, req->nh.nlmsg_len, 0) < 0) {\n\t\tret = -errno;\n\t\tgoto out;\n\t}\n\n\tret = libbpf_netlink_recv(sock, nl_pid, req->nh.nlmsg_seq,\n\t\t\t\t  parse_msg, parse_attr, cookie);\nout:\n\tlibbpf_netlink_close(sock);\n\treturn ret;\n}\n\nstatic int parse_genl_family_id(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,\n\t\t\t\tvoid *cookie)\n{\n\tstruct genlmsghdr *gnl = NLMSG_DATA(nh);\n\tstruct nlattr *na = (struct nlattr *)((void *)gnl + GENL_HDRLEN);\n\tstruct nlattr *tb[CTRL_ATTR_FAMILY_ID + 1];\n\t__u16 *id = cookie;\n\n\tlibbpf_nla_parse(tb, CTRL_ATTR_FAMILY_ID, na,\n\t\t\t NLMSG_PAYLOAD(nh, sizeof(*gnl)), NULL);\n\tif (!tb[CTRL_ATTR_FAMILY_ID])\n\t\treturn NL_CONT;\n\n\t*id = libbpf_nla_getattr_u16(tb[CTRL_ATTR_FAMILY_ID]);\n\treturn NL_DONE;\n}\n\nstatic int libbpf_netlink_resolve_genl_family_id(const char *name,\n\t\t\t\t\t\t __u16 len, __u16 *id)\n{\n\tstruct libbpf_nla_req req = {\n\t\t.nh.nlmsg_len\t= NLMSG_LENGTH(GENL_HDRLEN),\n\t\t.nh.nlmsg_type\t= GENL_ID_CTRL,\n\t\t.nh.nlmsg_flags\t= NLM_F_REQUEST,\n\t\t.gnl.cmd\t= CTRL_CMD_GETFAMILY,\n\t\t.gnl.version\t= 2,\n\t};\n\tint err;\n\n\terr = nlattr_add(&req, CTRL_ATTR_FAMILY_NAME, name, len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn libbpf_netlink_send_recv(&req, NETLINK_GENERIC,\n\t\t\t\t\tparse_genl_family_id, NULL, id);\n}\n\nstatic int __bpf_set_link_xdp_fd_replace(int ifindex, int fd, int old_fd,\n\t\t\t\t\t __u32 flags)\n{\n\tstruct nlattr *nla;\n\tint ret;\n\tstruct libbpf_nla_req req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len      = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.nh.nlmsg_flags    = NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_type     = RTM_SETLINK;\n\treq.ifinfo.ifi_family = AF_UNSPEC;\n\treq.ifinfo.ifi_index  = ifindex;\n\n\tnla = nlattr_begin_nested(&req, IFLA_XDP);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\tret = nlattr_add(&req, IFLA_XDP_FD, &fd, sizeof(fd));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags) {\n\t\tret = nlattr_add(&req, IFLA_XDP_FLAGS, &flags, sizeof(flags));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (flags & XDP_FLAGS_REPLACE) {\n\t\tret = nlattr_add(&req, IFLA_XDP_EXPECTED_FD, &old_fd,\n\t\t\t\t sizeof(old_fd));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tnlattr_end_nested(&req, nla);\n\n\treturn libbpf_netlink_send_recv(&req, NETLINK_ROUTE, NULL, NULL, NULL);\n}\n\nint bpf_xdp_attach(int ifindex, int prog_fd, __u32 flags, const struct bpf_xdp_attach_opts *opts)\n{\n\tint old_prog_fd, err;\n\n\tif (!OPTS_VALID(opts, bpf_xdp_attach_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\told_prog_fd = OPTS_GET(opts, old_prog_fd, 0);\n\tif (old_prog_fd)\n\t\tflags |= XDP_FLAGS_REPLACE;\n\telse\n\t\told_prog_fd = -1;\n\n\terr = __bpf_set_link_xdp_fd_replace(ifindex, prog_fd, old_prog_fd, flags);\n\treturn libbpf_err(err);\n}\n\nint bpf_xdp_detach(int ifindex, __u32 flags, const struct bpf_xdp_attach_opts *opts)\n{\n\treturn bpf_xdp_attach(ifindex, -1, flags, opts);\n}\n\nstatic int __dump_link_nlmsg(struct nlmsghdr *nlh,\n\t\t\t     libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1], *attr;\n\tstruct ifinfomsg *ifi = NLMSG_DATA(nlh);\n\tint len;\n\n\tlen = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\tattr = (struct nlattr *) ((void *) ifi + NLMSG_ALIGN(sizeof(*ifi)));\n\n\tif (libbpf_nla_parse(tb, IFLA_MAX, attr, len, NULL) != 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\treturn dump_link_nlmsg(cookie, ifi, tb);\n}\n\nstatic int get_xdp_info(void *cookie, void *msg, struct nlattr **tb)\n{\n\tstruct nlattr *xdp_tb[IFLA_XDP_MAX + 1];\n\tstruct xdp_id_md *xdp_id = cookie;\n\tstruct ifinfomsg *ifinfo = msg;\n\tint ret;\n\n\tif (xdp_id->ifindex && xdp_id->ifindex != ifinfo->ifi_index)\n\t\treturn 0;\n\n\tif (!tb[IFLA_XDP])\n\t\treturn 0;\n\n\tret = libbpf_nla_parse_nested(xdp_tb, IFLA_XDP_MAX, tb[IFLA_XDP], NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!xdp_tb[IFLA_XDP_ATTACHED])\n\t\treturn 0;\n\n\txdp_id->info.attach_mode = libbpf_nla_getattr_u8(\n\t\txdp_tb[IFLA_XDP_ATTACHED]);\n\n\tif (xdp_id->info.attach_mode == XDP_ATTACHED_NONE)\n\t\treturn 0;\n\n\tif (xdp_tb[IFLA_XDP_PROG_ID])\n\t\txdp_id->info.prog_id = libbpf_nla_getattr_u32(\n\t\t\txdp_tb[IFLA_XDP_PROG_ID]);\n\n\tif (xdp_tb[IFLA_XDP_SKB_PROG_ID])\n\t\txdp_id->info.skb_prog_id = libbpf_nla_getattr_u32(\n\t\t\txdp_tb[IFLA_XDP_SKB_PROG_ID]);\n\n\tif (xdp_tb[IFLA_XDP_DRV_PROG_ID])\n\t\txdp_id->info.drv_prog_id = libbpf_nla_getattr_u32(\n\t\t\txdp_tb[IFLA_XDP_DRV_PROG_ID]);\n\n\tif (xdp_tb[IFLA_XDP_HW_PROG_ID])\n\t\txdp_id->info.hw_prog_id = libbpf_nla_getattr_u32(\n\t\t\txdp_tb[IFLA_XDP_HW_PROG_ID]);\n\n\treturn 0;\n}\n\nstatic int parse_xdp_features(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,\n\t\t\t      void *cookie)\n{\n\tstruct genlmsghdr *gnl = NLMSG_DATA(nh);\n\tstruct nlattr *na = (struct nlattr *)((void *)gnl + GENL_HDRLEN);\n\tstruct nlattr *tb[NETDEV_CMD_MAX + 1];\n\tstruct xdp_features_md *md = cookie;\n\t__u32 ifindex;\n\n\tlibbpf_nla_parse(tb, NETDEV_CMD_MAX, na,\n\t\t\t NLMSG_PAYLOAD(nh, sizeof(*gnl)), NULL);\n\n\tif (!tb[NETDEV_A_DEV_IFINDEX] || !tb[NETDEV_A_DEV_XDP_FEATURES])\n\t\treturn NL_CONT;\n\n\tifindex = libbpf_nla_getattr_u32(tb[NETDEV_A_DEV_IFINDEX]);\n\tif (ifindex != md->ifindex)\n\t\treturn NL_CONT;\n\n\tmd->flags = libbpf_nla_getattr_u64(tb[NETDEV_A_DEV_XDP_FEATURES]);\n\tif (tb[NETDEV_A_DEV_XDP_ZC_MAX_SEGS])\n\t\tmd->xdp_zc_max_segs =\n\t\t\tlibbpf_nla_getattr_u32(tb[NETDEV_A_DEV_XDP_ZC_MAX_SEGS]);\n\treturn NL_DONE;\n}\n\nint bpf_xdp_query(int ifindex, int xdp_flags, struct bpf_xdp_query_opts *opts)\n{\n\tstruct libbpf_nla_req req = {\n\t\t.nh.nlmsg_len      = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.nh.nlmsg_type     = RTM_GETLINK,\n\t\t.nh.nlmsg_flags    = NLM_F_DUMP | NLM_F_REQUEST,\n\t\t.ifinfo.ifi_family = AF_PACKET,\n\t};\n\tstruct xdp_id_md xdp_id = {};\n\tstruct xdp_features_md md = {\n\t\t.ifindex = ifindex,\n\t};\n\t__u16 id;\n\tint err;\n\n\tif (!OPTS_VALID(opts, bpf_xdp_query_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\tif (xdp_flags & ~XDP_FLAGS_MASK)\n\t\treturn libbpf_err(-EINVAL);\n\n\t \n\txdp_flags &= XDP_FLAGS_SKB_MODE | XDP_FLAGS_DRV_MODE | XDP_FLAGS_HW_MODE;\n\tif (xdp_flags & (xdp_flags - 1))\n\t\treturn libbpf_err(-EINVAL);\n\n\txdp_id.ifindex = ifindex;\n\txdp_id.flags = xdp_flags;\n\n\terr = libbpf_netlink_send_recv(&req, NETLINK_ROUTE, __dump_link_nlmsg,\n\t\t\t\t       get_xdp_info, &xdp_id);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\tOPTS_SET(opts, prog_id, xdp_id.info.prog_id);\n\tOPTS_SET(opts, drv_prog_id, xdp_id.info.drv_prog_id);\n\tOPTS_SET(opts, hw_prog_id, xdp_id.info.hw_prog_id);\n\tOPTS_SET(opts, skb_prog_id, xdp_id.info.skb_prog_id);\n\tOPTS_SET(opts, attach_mode, xdp_id.info.attach_mode);\n\n\tif (!OPTS_HAS(opts, feature_flags))\n\t\treturn 0;\n\n\terr = libbpf_netlink_resolve_genl_family_id(\"netdev\", sizeof(\"netdev\"), &id);\n\tif (err < 0) {\n\t\tif (err == -ENOENT) {\n\t\t\topts->feature_flags = 0;\n\t\t\tgoto skip_feature_flags;\n\t\t}\n\t\treturn libbpf_err(err);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\n\treq.nh.nlmsg_flags = NLM_F_REQUEST;\n\treq.nh.nlmsg_type = id;\n\treq.gnl.cmd = NETDEV_CMD_DEV_GET;\n\treq.gnl.version = 2;\n\n\terr = nlattr_add(&req, NETDEV_A_DEV_IFINDEX, &ifindex, sizeof(ifindex));\n\tif (err < 0)\n\t\treturn libbpf_err(err);\n\n\terr = libbpf_netlink_send_recv(&req, NETLINK_GENERIC,\n\t\t\t\t       parse_xdp_features, NULL, &md);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\topts->feature_flags = md.flags;\n\topts->xdp_zc_max_segs = md.xdp_zc_max_segs;\n\nskip_feature_flags:\n\treturn 0;\n}\n\nint bpf_xdp_query_id(int ifindex, int flags, __u32 *prog_id)\n{\n\tLIBBPF_OPTS(bpf_xdp_query_opts, opts);\n\tint ret;\n\n\tret = bpf_xdp_query(ifindex, flags, &opts);\n\tif (ret)\n\t\treturn libbpf_err(ret);\n\n\tflags &= XDP_FLAGS_MODES;\n\n\tif (opts.attach_mode != XDP_ATTACHED_MULTI && !flags)\n\t\t*prog_id = opts.prog_id;\n\telse if (flags & XDP_FLAGS_DRV_MODE)\n\t\t*prog_id = opts.drv_prog_id;\n\telse if (flags & XDP_FLAGS_HW_MODE)\n\t\t*prog_id = opts.hw_prog_id;\n\telse if (flags & XDP_FLAGS_SKB_MODE)\n\t\t*prog_id = opts.skb_prog_id;\n\telse\n\t\t*prog_id = 0;\n\n\treturn 0;\n}\n\n\ntypedef int (*qdisc_config_t)(struct libbpf_nla_req *req);\n\nstatic int clsact_config(struct libbpf_nla_req *req)\n{\n\treq->tc.tcm_parent = TC_H_CLSACT;\n\treq->tc.tcm_handle = TC_H_MAKE(TC_H_CLSACT, 0);\n\n\treturn nlattr_add(req, TCA_KIND, \"clsact\", sizeof(\"clsact\"));\n}\n\nstatic int attach_point_to_config(struct bpf_tc_hook *hook,\n\t\t\t\t  qdisc_config_t *config)\n{\n\tswitch (OPTS_GET(hook, attach_point, 0)) {\n\tcase BPF_TC_INGRESS:\n\tcase BPF_TC_EGRESS:\n\tcase BPF_TC_INGRESS | BPF_TC_EGRESS:\n\t\tif (OPTS_GET(hook, parent, 0))\n\t\t\treturn -EINVAL;\n\t\t*config = &clsact_config;\n\t\treturn 0;\n\tcase BPF_TC_CUSTOM:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tc_get_tcm_parent(enum bpf_tc_attach_point attach_point,\n\t\t\t     __u32 *parent)\n{\n\tswitch (attach_point) {\n\tcase BPF_TC_INGRESS:\n\tcase BPF_TC_EGRESS:\n\t\tif (*parent)\n\t\t\treturn -EINVAL;\n\t\t*parent = TC_H_MAKE(TC_H_CLSACT,\n\t\t\t\t    attach_point == BPF_TC_INGRESS ?\n\t\t\t\t    TC_H_MIN_INGRESS : TC_H_MIN_EGRESS);\n\t\tbreak;\n\tcase BPF_TC_CUSTOM:\n\t\tif (!*parent)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tc_qdisc_modify(struct bpf_tc_hook *hook, int cmd, int flags)\n{\n\tqdisc_config_t config;\n\tint ret;\n\tstruct libbpf_nla_req req;\n\n\tret = attach_point_to_config(hook, &config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;\n\treq.nh.nlmsg_type  = cmd;\n\treq.tc.tcm_family  = AF_UNSPEC;\n\treq.tc.tcm_ifindex = OPTS_GET(hook, ifindex, 0);\n\n\tret = config(&req);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn libbpf_netlink_send_recv(&req, NETLINK_ROUTE, NULL, NULL, NULL);\n}\n\nstatic int tc_qdisc_create_excl(struct bpf_tc_hook *hook)\n{\n\treturn tc_qdisc_modify(hook, RTM_NEWQDISC, NLM_F_CREATE | NLM_F_EXCL);\n}\n\nstatic int tc_qdisc_delete(struct bpf_tc_hook *hook)\n{\n\treturn tc_qdisc_modify(hook, RTM_DELQDISC, 0);\n}\n\nint bpf_tc_hook_create(struct bpf_tc_hook *hook)\n{\n\tint ret;\n\n\tif (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||\n\t    OPTS_GET(hook, ifindex, 0) <= 0)\n\t\treturn libbpf_err(-EINVAL);\n\n\tret = tc_qdisc_create_excl(hook);\n\treturn libbpf_err(ret);\n}\n\nstatic int __bpf_tc_detach(const struct bpf_tc_hook *hook,\n\t\t\t   const struct bpf_tc_opts *opts,\n\t\t\t   const bool flush);\n\nint bpf_tc_hook_destroy(struct bpf_tc_hook *hook)\n{\n\tif (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||\n\t    OPTS_GET(hook, ifindex, 0) <= 0)\n\t\treturn libbpf_err(-EINVAL);\n\n\tswitch (OPTS_GET(hook, attach_point, 0)) {\n\tcase BPF_TC_INGRESS:\n\tcase BPF_TC_EGRESS:\n\t\treturn libbpf_err(__bpf_tc_detach(hook, NULL, true));\n\tcase BPF_TC_INGRESS | BPF_TC_EGRESS:\n\t\treturn libbpf_err(tc_qdisc_delete(hook));\n\tcase BPF_TC_CUSTOM:\n\t\treturn libbpf_err(-EOPNOTSUPP);\n\tdefault:\n\t\treturn libbpf_err(-EINVAL);\n\t}\n}\n\nstruct bpf_cb_ctx {\n\tstruct bpf_tc_opts *opts;\n\tbool processed;\n};\n\nstatic int __get_tc_info(void *cookie, struct tcmsg *tc, struct nlattr **tb,\n\t\t\t bool unicast)\n{\n\tstruct nlattr *tbb[TCA_BPF_MAX + 1];\n\tstruct bpf_cb_ctx *info = cookie;\n\n\tif (!info || !info->opts)\n\t\treturn -EINVAL;\n\tif (unicast && info->processed)\n\t\treturn -EINVAL;\n\tif (!tb[TCA_OPTIONS])\n\t\treturn NL_CONT;\n\n\tlibbpf_nla_parse_nested(tbb, TCA_BPF_MAX, tb[TCA_OPTIONS], NULL);\n\tif (!tbb[TCA_BPF_ID])\n\t\treturn -EINVAL;\n\n\tOPTS_SET(info->opts, prog_id, libbpf_nla_getattr_u32(tbb[TCA_BPF_ID]));\n\tOPTS_SET(info->opts, handle, tc->tcm_handle);\n\tOPTS_SET(info->opts, priority, TC_H_MAJ(tc->tcm_info) >> 16);\n\n\tinfo->processed = true;\n\treturn unicast ? NL_NEXT : NL_DONE;\n}\n\nstatic int get_tc_info(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,\n\t\t       void *cookie)\n{\n\tstruct tcmsg *tc = NLMSG_DATA(nh);\n\tstruct nlattr *tb[TCA_MAX + 1];\n\n\tlibbpf_nla_parse(tb, TCA_MAX,\n\t\t\t (struct nlattr *)((void *)tc + NLMSG_ALIGN(sizeof(*tc))),\n\t\t\t NLMSG_PAYLOAD(nh, sizeof(*tc)), NULL);\n\tif (!tb[TCA_KIND])\n\t\treturn NL_CONT;\n\treturn __get_tc_info(cookie, tc, tb, nh->nlmsg_flags & NLM_F_ECHO);\n}\n\nstatic int tc_add_fd_and_name(struct libbpf_nla_req *req, int fd)\n{\n\tstruct bpf_prog_info info;\n\t__u32 info_len = sizeof(info);\n\tchar name[256];\n\tint len, ret;\n\n\tmemset(&info, 0, info_len);\n\tret = bpf_prog_get_info_by_fd(fd, &info, &info_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nlattr_add(req, TCA_BPF_FD, &fd, sizeof(fd));\n\tif (ret < 0)\n\t\treturn ret;\n\tlen = snprintf(name, sizeof(name), \"%s:[%u]\", info.name, info.id);\n\tif (len < 0)\n\t\treturn -errno;\n\tif (len >= sizeof(name))\n\t\treturn -ENAMETOOLONG;\n\treturn nlattr_add(req, TCA_BPF_NAME, name, len + 1);\n}\n\nint bpf_tc_attach(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)\n{\n\t__u32 protocol, bpf_flags, handle, priority, parent, prog_id, flags;\n\tint ret, ifindex, attach_point, prog_fd;\n\tstruct bpf_cb_ctx info = {};\n\tstruct libbpf_nla_req req;\n\tstruct nlattr *nla;\n\n\tif (!hook || !opts ||\n\t    !OPTS_VALID(hook, bpf_tc_hook) ||\n\t    !OPTS_VALID(opts, bpf_tc_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\tifindex      = OPTS_GET(hook, ifindex, 0);\n\tparent       = OPTS_GET(hook, parent, 0);\n\tattach_point = OPTS_GET(hook, attach_point, 0);\n\n\thandle       = OPTS_GET(opts, handle, 0);\n\tpriority     = OPTS_GET(opts, priority, 0);\n\tprog_fd      = OPTS_GET(opts, prog_fd, 0);\n\tprog_id      = OPTS_GET(opts, prog_id, 0);\n\tflags        = OPTS_GET(opts, flags, 0);\n\n\tif (ifindex <= 0 || !prog_fd || prog_id)\n\t\treturn libbpf_err(-EINVAL);\n\tif (priority > UINT16_MAX)\n\t\treturn libbpf_err(-EINVAL);\n\tif (flags & ~BPF_TC_F_REPLACE)\n\t\treturn libbpf_err(-EINVAL);\n\n\tflags = (flags & BPF_TC_F_REPLACE) ? NLM_F_REPLACE : NLM_F_EXCL;\n\tprotocol = ETH_P_ALL;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE |\n\t\t\t     NLM_F_ECHO | flags;\n\treq.nh.nlmsg_type  = RTM_NEWTFILTER;\n\treq.tc.tcm_family  = AF_UNSPEC;\n\treq.tc.tcm_ifindex = ifindex;\n\treq.tc.tcm_handle  = handle;\n\treq.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));\n\n\tret = tc_get_tcm_parent(attach_point, &parent);\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\treq.tc.tcm_parent = parent;\n\n\tret = nlattr_add(&req, TCA_KIND, \"bpf\", sizeof(\"bpf\"));\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\tnla = nlattr_begin_nested(&req, TCA_OPTIONS);\n\tif (!nla)\n\t\treturn libbpf_err(-EMSGSIZE);\n\tret = tc_add_fd_and_name(&req, prog_fd);\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\tbpf_flags = TCA_BPF_FLAG_ACT_DIRECT;\n\tret = nlattr_add(&req, TCA_BPF_FLAGS, &bpf_flags, sizeof(bpf_flags));\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\tnlattr_end_nested(&req, nla);\n\n\tinfo.opts = opts;\n\n\tret = libbpf_netlink_send_recv(&req, NETLINK_ROUTE, get_tc_info, NULL,\n\t\t\t\t       &info);\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\tif (!info.processed)\n\t\treturn libbpf_err(-ENOENT);\n\treturn ret;\n}\n\nstatic int __bpf_tc_detach(const struct bpf_tc_hook *hook,\n\t\t\t   const struct bpf_tc_opts *opts,\n\t\t\t   const bool flush)\n{\n\t__u32 protocol = 0, handle, priority, parent, prog_id, flags;\n\tint ret, ifindex, attach_point, prog_fd;\n\tstruct libbpf_nla_req req;\n\n\tif (!hook ||\n\t    !OPTS_VALID(hook, bpf_tc_hook) ||\n\t    !OPTS_VALID(opts, bpf_tc_opts))\n\t\treturn -EINVAL;\n\n\tifindex      = OPTS_GET(hook, ifindex, 0);\n\tparent       = OPTS_GET(hook, parent, 0);\n\tattach_point = OPTS_GET(hook, attach_point, 0);\n\n\thandle       = OPTS_GET(opts, handle, 0);\n\tpriority     = OPTS_GET(opts, priority, 0);\n\tprog_fd      = OPTS_GET(opts, prog_fd, 0);\n\tprog_id      = OPTS_GET(opts, prog_id, 0);\n\tflags        = OPTS_GET(opts, flags, 0);\n\n\tif (ifindex <= 0 || flags || prog_fd || prog_id)\n\t\treturn -EINVAL;\n\tif (priority > UINT16_MAX)\n\t\treturn -EINVAL;\n\tif (!flush) {\n\t\tif (!handle || !priority)\n\t\t\treturn -EINVAL;\n\t\tprotocol = ETH_P_ALL;\n\t} else {\n\t\tif (handle || priority)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_type  = RTM_DELTFILTER;\n\treq.tc.tcm_family  = AF_UNSPEC;\n\treq.tc.tcm_ifindex = ifindex;\n\tif (!flush) {\n\t\treq.tc.tcm_handle = handle;\n\t\treq.tc.tcm_info   = TC_H_MAKE(priority << 16, htons(protocol));\n\t}\n\n\tret = tc_get_tcm_parent(attach_point, &parent);\n\tif (ret < 0)\n\t\treturn ret;\n\treq.tc.tcm_parent = parent;\n\n\tif (!flush) {\n\t\tret = nlattr_add(&req, TCA_KIND, \"bpf\", sizeof(\"bpf\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn libbpf_netlink_send_recv(&req, NETLINK_ROUTE, NULL, NULL, NULL);\n}\n\nint bpf_tc_detach(const struct bpf_tc_hook *hook,\n\t\t  const struct bpf_tc_opts *opts)\n{\n\tint ret;\n\n\tif (!opts)\n\t\treturn libbpf_err(-EINVAL);\n\n\tret = __bpf_tc_detach(hook, opts, false);\n\treturn libbpf_err(ret);\n}\n\nint bpf_tc_query(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)\n{\n\t__u32 protocol, handle, priority, parent, prog_id, flags;\n\tint ret, ifindex, attach_point, prog_fd;\n\tstruct bpf_cb_ctx info = {};\n\tstruct libbpf_nla_req req;\n\n\tif (!hook || !opts ||\n\t    !OPTS_VALID(hook, bpf_tc_hook) ||\n\t    !OPTS_VALID(opts, bpf_tc_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\tifindex      = OPTS_GET(hook, ifindex, 0);\n\tparent       = OPTS_GET(hook, parent, 0);\n\tattach_point = OPTS_GET(hook, attach_point, 0);\n\n\thandle       = OPTS_GET(opts, handle, 0);\n\tpriority     = OPTS_GET(opts, priority, 0);\n\tprog_fd      = OPTS_GET(opts, prog_fd, 0);\n\tprog_id      = OPTS_GET(opts, prog_id, 0);\n\tflags        = OPTS_GET(opts, flags, 0);\n\n\tif (ifindex <= 0 || flags || prog_fd || prog_id ||\n\t    !handle || !priority)\n\t\treturn libbpf_err(-EINVAL);\n\tif (priority > UINT16_MAX)\n\t\treturn libbpf_err(-EINVAL);\n\n\tprotocol = ETH_P_ALL;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST;\n\treq.nh.nlmsg_type  = RTM_GETTFILTER;\n\treq.tc.tcm_family  = AF_UNSPEC;\n\treq.tc.tcm_ifindex = ifindex;\n\treq.tc.tcm_handle  = handle;\n\treq.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));\n\n\tret = tc_get_tcm_parent(attach_point, &parent);\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\treq.tc.tcm_parent = parent;\n\n\tret = nlattr_add(&req, TCA_KIND, \"bpf\", sizeof(\"bpf\"));\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\n\tinfo.opts = opts;\n\n\tret = libbpf_netlink_send_recv(&req, NETLINK_ROUTE, get_tc_info, NULL,\n\t\t\t\t       &info);\n\tif (ret < 0)\n\t\treturn libbpf_err(ret);\n\tif (!info.processed)\n\t\treturn libbpf_err(-ENOENT);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}