{
  "module_name": "zip.c",
  "hash_id": "b96be261d4053f7ef7ddb207fa0a8f9301702191a6290b95ea9ee717f337bc18",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/zip.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#include \"libbpf_internal.h\"\n#include \"zip.h\"\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpacked\"\n#pragma GCC diagnostic ignored \"-Wattributes\"\n\n \n\n#define END_OF_CD_RECORD_MAGIC 0x06054b50\n\n \nstruct end_of_cd_record {\n\t \n\t__u32 magic;\n\n\t \n\t__u16 this_disk;\n\n\t \n\t__u16 cd_disk;\n\n\t \n\t__u16 cd_records;\n\n\t \n\t__u16 cd_records_total;\n\n\t \n\t__u32 cd_size;\n\n\t \n\t__u32 cd_offset;\n\n\t \n\t__u16 comment_length;\n\n\t \n\t \n} __attribute__((packed));\n\n#define CD_FILE_HEADER_MAGIC 0x02014b50\n#define FLAG_ENCRYPTED (1 << 0)\n#define FLAG_HAS_DATA_DESCRIPTOR (1 << 3)\n\n \nstruct cd_file_header {\n\t \n\t__u32 magic;\n\t__u16 version;\n\t \n\t__u16 min_version;\n\t__u16 flags;\n\t__u16 compression;\n\t__u16 last_modified_time;\n\t__u16 last_modified_date;\n\t__u32 crc;\n\t__u32 compressed_size;\n\t__u32 uncompressed_size;\n\t__u16 file_name_length;\n\t__u16 extra_field_length;\n\t__u16 file_comment_length;\n\t \n\t__u16 disk;\n\t__u16 internal_attributes;\n\t__u32 external_attributes;\n\t \n\t__u32 offset;\n} __attribute__((packed));\n\n#define LOCAL_FILE_HEADER_MAGIC 0x04034b50\n\n \nstruct local_file_header {\n\t \n\t__u32 magic;\n\t \n\t__u16 min_version;\n\t__u16 flags;\n\t__u16 compression;\n\t__u16 last_modified_time;\n\t__u16 last_modified_date;\n\t__u32 crc;\n\t__u32 compressed_size;\n\t__u32 uncompressed_size;\n\t__u16 file_name_length;\n\t__u16 extra_field_length;\n} __attribute__((packed));\n\n#pragma GCC diagnostic pop\n\nstruct zip_archive {\n\tvoid *data;\n\t__u32 size;\n\t__u32 cd_offset;\n\t__u32 cd_records;\n};\n\nstatic void *check_access(struct zip_archive *archive, __u32 offset, __u32 size)\n{\n\tif (offset + size > archive->size || offset > offset + size)\n\t\treturn NULL;\n\n\treturn archive->data + offset;\n}\n\n \nstatic int try_parse_end_of_cd(struct zip_archive *archive, __u32 offset)\n{\n\t__u16 comment_length, cd_records;\n\tstruct end_of_cd_record *eocd;\n\t__u32 cd_offset, cd_size;\n\n\teocd = check_access(archive, offset, sizeof(*eocd));\n\tif (!eocd || eocd->magic != END_OF_CD_RECORD_MAGIC)\n\t\treturn -EINVAL;\n\n\tcomment_length = eocd->comment_length;\n\tif (offset + sizeof(*eocd) + comment_length != archive->size)\n\t\treturn -EINVAL;\n\n\tcd_records = eocd->cd_records;\n\tif (eocd->this_disk != 0 || eocd->cd_disk != 0 || eocd->cd_records_total != cd_records)\n\t\t \n\t\treturn -ENOTSUP;\n\n\tcd_offset = eocd->cd_offset;\n\tcd_size = eocd->cd_size;\n\tif (!check_access(archive, cd_offset, cd_size))\n\t\treturn -EINVAL;\n\n\tarchive->cd_offset = cd_offset;\n\tarchive->cd_records = cd_records;\n\treturn 0;\n}\n\nstatic int find_cd(struct zip_archive *archive)\n{\n\tint64_t limit, offset;\n\tint rc = -EINVAL;\n\n\tif (archive->size <= sizeof(struct end_of_cd_record))\n\t\treturn -EINVAL;\n\n\t \n\toffset = archive->size - sizeof(struct end_of_cd_record);\n\tlimit = (int64_t)offset - (1 << 16);\n\n\tfor (; offset >= 0 && offset > limit && rc != 0; offset--) {\n\t\trc = try_parse_end_of_cd(archive, offset);\n\t\tif (rc == -ENOTSUP)\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstruct zip_archive *zip_archive_open(const char *path)\n{\n\tstruct zip_archive *archive;\n\tint err, fd;\n\toff_t size;\n\tvoid *data;\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn ERR_PTR(-errno);\n\n\tsize = lseek(fd, 0, SEEK_END);\n\tif (size == (off_t)-1 || size > UINT32_MAX) {\n\t\tclose(fd);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdata = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\terr = -errno;\n\tclose(fd);\n\n\tif (data == MAP_FAILED)\n\t\treturn ERR_PTR(err);\n\n\tarchive = malloc(sizeof(*archive));\n\tif (!archive) {\n\t\tmunmap(data, size);\n\t\treturn ERR_PTR(-ENOMEM);\n\t};\n\n\tarchive->data = data;\n\tarchive->size = size;\n\n\terr = find_cd(archive);\n\tif (err) {\n\t\tmunmap(data, size);\n\t\tfree(archive);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn archive;\n}\n\nvoid zip_archive_close(struct zip_archive *archive)\n{\n\tmunmap(archive->data, archive->size);\n\tfree(archive);\n}\n\nstatic struct local_file_header *local_file_header_at_offset(struct zip_archive *archive,\n\t\t\t\t\t\t\t     __u32 offset)\n{\n\tstruct local_file_header *lfh;\n\n\tlfh = check_access(archive, offset, sizeof(*lfh));\n\tif (!lfh || lfh->magic != LOCAL_FILE_HEADER_MAGIC)\n\t\treturn NULL;\n\n\treturn lfh;\n}\n\nstatic int get_entry_at_offset(struct zip_archive *archive, __u32 offset, struct zip_entry *out)\n{\n\tstruct local_file_header *lfh;\n\t__u32 compressed_size;\n\tconst char *name;\n\tvoid *data;\n\n\tlfh = local_file_header_at_offset(archive, offset);\n\tif (!lfh)\n\t\treturn -EINVAL;\n\n\toffset += sizeof(*lfh);\n\tif ((lfh->flags & FLAG_ENCRYPTED) || (lfh->flags & FLAG_HAS_DATA_DESCRIPTOR))\n\t\treturn -EINVAL;\n\n\tname = check_access(archive, offset, lfh->file_name_length);\n\tif (!name)\n\t\treturn -EINVAL;\n\n\toffset += lfh->file_name_length;\n\tif (!check_access(archive, offset, lfh->extra_field_length))\n\t\treturn -EINVAL;\n\n\toffset += lfh->extra_field_length;\n\tcompressed_size = lfh->compressed_size;\n\tdata = check_access(archive, offset, compressed_size);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tout->compression = lfh->compression;\n\tout->name_length = lfh->file_name_length;\n\tout->name = name;\n\tout->data = data;\n\tout->data_length = compressed_size;\n\tout->data_offset = offset;\n\n\treturn 0;\n}\n\nint zip_archive_find_entry(struct zip_archive *archive, const char *file_name,\n\t\t\t   struct zip_entry *out)\n{\n\tsize_t file_name_length = strlen(file_name);\n\t__u32 i, offset = archive->cd_offset;\n\n\tfor (i = 0; i < archive->cd_records; ++i) {\n\t\t__u16 cdfh_name_length, cdfh_flags;\n\t\tstruct cd_file_header *cdfh;\n\t\tconst char *cdfh_name;\n\n\t\tcdfh = check_access(archive, offset, sizeof(*cdfh));\n\t\tif (!cdfh || cdfh->magic != CD_FILE_HEADER_MAGIC)\n\t\t\treturn -EINVAL;\n\n\t\toffset += sizeof(*cdfh);\n\t\tcdfh_name_length = cdfh->file_name_length;\n\t\tcdfh_name = check_access(archive, offset, cdfh_name_length);\n\t\tif (!cdfh_name)\n\t\t\treturn -EINVAL;\n\n\t\tcdfh_flags = cdfh->flags;\n\t\tif ((cdfh_flags & FLAG_ENCRYPTED) == 0 &&\n\t\t    (cdfh_flags & FLAG_HAS_DATA_DESCRIPTOR) == 0 &&\n\t\t    file_name_length == cdfh_name_length &&\n\t\t    memcmp(file_name, archive->data + offset, file_name_length) == 0) {\n\t\t\treturn get_entry_at_offset(archive, cdfh->offset, out);\n\t\t}\n\n\t\toffset += cdfh_name_length;\n\t\toffset += cdfh->extra_field_length;\n\t\toffset += cdfh->file_comment_length;\n\t}\n\n\treturn -ENOENT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}