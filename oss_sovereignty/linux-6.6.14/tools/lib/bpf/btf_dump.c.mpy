{
  "module_name": "btf_dump.c",
  "hash_id": "c8b7a3b902dca66be35a61ef525521f5f015e0bdf24fb5bdec2e082bd9b4c23b",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/btf_dump.c",
  "human_readable_source": "\n\n \n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <endian.h>\n#include <errno.h>\n#include <limits.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/kernel.h>\n#include \"btf.h\"\n#include \"hashmap.h\"\n#include \"libbpf.h\"\n#include \"libbpf_internal.h\"\n\nstatic const char PREFIXES[] = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\nstatic const size_t PREFIX_CNT = sizeof(PREFIXES) - 1;\n\nstatic const char *pfx(int lvl)\n{\n\treturn lvl >= PREFIX_CNT ? PREFIXES : &PREFIXES[PREFIX_CNT - lvl];\n}\n\nenum btf_dump_type_order_state {\n\tNOT_ORDERED,\n\tORDERING,\n\tORDERED,\n};\n\nenum btf_dump_type_emit_state {\n\tNOT_EMITTED,\n\tEMITTING,\n\tEMITTED,\n};\n\n \nstruct btf_dump_type_aux_state {\n\t \n\tenum btf_dump_type_order_state order_state: 2;\n\t \n\tenum btf_dump_type_emit_state emit_state: 2;\n\t \n\t__u8 fwd_emitted: 1;\n\t \n\t__u8 name_resolved: 1;\n\t \n\t__u8 referenced: 1;\n};\n\n \n#define BTF_DATA_INDENT_STR_LEN\t\t\t32\n\n \nstruct btf_dump_data {\n\tconst void *data_end;\t\t \n\tbool compact;\n\tbool skip_names;\n\tbool emit_zeroes;\n\t__u8 indent_lvl;\t \n\tchar indent_str[BTF_DATA_INDENT_STR_LEN];\n\t \n\tint depth;\n\tbool is_array_member;\n\tbool is_array_terminated;\n\tbool is_array_char;\n};\n\nstruct btf_dump {\n\tconst struct btf *btf;\n\tbtf_dump_printf_fn_t printf_fn;\n\tvoid *cb_ctx;\n\tint ptr_sz;\n\tbool strip_mods;\n\tbool skip_anon_defs;\n\tint last_id;\n\n\t \n\tstruct btf_dump_type_aux_state *type_states;\n\tsize_t type_states_cap;\n\t \n\tconst char **cached_names;\n\tsize_t cached_names_cap;\n\n\t \n\t__u32 *emit_queue;\n\tint emit_queue_cap;\n\tint emit_queue_cnt;\n\n\t \n\t__u32 *decl_stack;\n\tint decl_stack_cap;\n\tint decl_stack_cnt;\n\n\t \n\tstruct hashmap *type_names;\n\t \n\tstruct hashmap *ident_names;\n\t \n\tstruct btf_dump_data *typed_dump;\n};\n\nstatic size_t str_hash_fn(long key, void *ctx)\n{\n\treturn str_hash((void *)key);\n}\n\nstatic bool str_equal_fn(long a, long b, void *ctx)\n{\n\treturn strcmp((void *)a, (void *)b) == 0;\n}\n\nstatic const char *btf_name_of(const struct btf_dump *d, __u32 name_off)\n{\n\treturn btf__name_by_offset(d->btf, name_off);\n}\n\nstatic void btf_dump_printf(const struct btf_dump *d, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\td->printf_fn(d->cb_ctx, fmt, args);\n\tva_end(args);\n}\n\nstatic int btf_dump_mark_referenced(struct btf_dump *d);\nstatic int btf_dump_resize(struct btf_dump *d);\n\nstruct btf_dump *btf_dump__new(const struct btf *btf,\n\t\t\t       btf_dump_printf_fn_t printf_fn,\n\t\t\t       void *ctx,\n\t\t\t       const struct btf_dump_opts *opts)\n{\n\tstruct btf_dump *d;\n\tint err;\n\n\tif (!OPTS_VALID(opts, btf_dump_opts))\n\t\treturn libbpf_err_ptr(-EINVAL);\n\n\tif (!printf_fn)\n\t\treturn libbpf_err_ptr(-EINVAL);\n\n\td = calloc(1, sizeof(struct btf_dump));\n\tif (!d)\n\t\treturn libbpf_err_ptr(-ENOMEM);\n\n\td->btf = btf;\n\td->printf_fn = printf_fn;\n\td->cb_ctx = ctx;\n\td->ptr_sz = btf__pointer_size(btf) ? : sizeof(void *);\n\n\td->type_names = hashmap__new(str_hash_fn, str_equal_fn, NULL);\n\tif (IS_ERR(d->type_names)) {\n\t\terr = PTR_ERR(d->type_names);\n\t\td->type_names = NULL;\n\t\tgoto err;\n\t}\n\td->ident_names = hashmap__new(str_hash_fn, str_equal_fn, NULL);\n\tif (IS_ERR(d->ident_names)) {\n\t\terr = PTR_ERR(d->ident_names);\n\t\td->ident_names = NULL;\n\t\tgoto err;\n\t}\n\n\terr = btf_dump_resize(d);\n\tif (err)\n\t\tgoto err;\n\n\treturn d;\nerr:\n\tbtf_dump__free(d);\n\treturn libbpf_err_ptr(err);\n}\n\nstatic int btf_dump_resize(struct btf_dump *d)\n{\n\tint err, last_id = btf__type_cnt(d->btf) - 1;\n\n\tif (last_id <= d->last_id)\n\t\treturn 0;\n\n\tif (libbpf_ensure_mem((void **)&d->type_states, &d->type_states_cap,\n\t\t\t      sizeof(*d->type_states), last_id + 1))\n\t\treturn -ENOMEM;\n\tif (libbpf_ensure_mem((void **)&d->cached_names, &d->cached_names_cap,\n\t\t\t      sizeof(*d->cached_names), last_id + 1))\n\t\treturn -ENOMEM;\n\n\tif (d->last_id == 0) {\n\t\t \n\t\td->type_states[0].order_state = ORDERED;\n\t\td->type_states[0].emit_state = EMITTED;\n\t}\n\n\t \n\terr = btf_dump_mark_referenced(d);\n\tif (err)\n\t\treturn err;\n\n\td->last_id = last_id;\n\treturn 0;\n}\n\nstatic void btf_dump_free_names(struct hashmap *map)\n{\n\tsize_t bkt;\n\tstruct hashmap_entry *cur;\n\n\thashmap__for_each_entry(map, cur, bkt)\n\t\tfree((void *)cur->pkey);\n\n\thashmap__free(map);\n}\n\nvoid btf_dump__free(struct btf_dump *d)\n{\n\tint i;\n\n\tif (IS_ERR_OR_NULL(d))\n\t\treturn;\n\n\tfree(d->type_states);\n\tif (d->cached_names) {\n\t\t \n\t\tfor (i = 0; i <= d->last_id; i++) {\n\t\t\tif (d->cached_names[i])\n\t\t\t\tfree((void *)d->cached_names[i]);\n\t\t}\n\t}\n\tfree(d->cached_names);\n\tfree(d->emit_queue);\n\tfree(d->decl_stack);\n\tbtf_dump_free_names(d->type_names);\n\tbtf_dump_free_names(d->ident_names);\n\n\tfree(d);\n}\n\nstatic int btf_dump_order_type(struct btf_dump *d, __u32 id, bool through_ptr);\nstatic void btf_dump_emit_type(struct btf_dump *d, __u32 id, __u32 cont_id);\n\n \nint btf_dump__dump_type(struct btf_dump *d, __u32 id)\n{\n\tint err, i;\n\n\tif (id >= btf__type_cnt(d->btf))\n\t\treturn libbpf_err(-EINVAL);\n\n\terr = btf_dump_resize(d);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\td->emit_queue_cnt = 0;\n\terr = btf_dump_order_type(d, id, false);\n\tif (err < 0)\n\t\treturn libbpf_err(err);\n\n\tfor (i = 0; i < d->emit_queue_cnt; i++)\n\t\tbtf_dump_emit_type(d, d->emit_queue[i], 0  );\n\n\treturn 0;\n}\n\n \nstatic int btf_dump_mark_referenced(struct btf_dump *d)\n{\n\tint i, j, n = btf__type_cnt(d->btf);\n\tconst struct btf_type *t;\n\t__u16 vlen;\n\n\tfor (i = d->last_id + 1; i < n; i++) {\n\t\tt = btf__type_by_id(d->btf, i);\n\t\tvlen = btf_vlen(t);\n\n\t\tswitch (btf_kind(t)) {\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_ENUM64:\n\t\tcase BTF_KIND_FWD:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_PTR:\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_FUNC:\n\t\tcase BTF_KIND_VAR:\n\t\tcase BTF_KIND_DECL_TAG:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\td->type_states[t->type].referenced = 1;\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY: {\n\t\t\tconst struct btf_array *a = btf_array(t);\n\n\t\t\td->type_states[a->index_type].referenced = 1;\n\t\t\td->type_states[a->type].referenced = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION: {\n\t\t\tconst struct btf_member *m = btf_members(t);\n\n\t\t\tfor (j = 0; j < vlen; j++, m++)\n\t\t\t\td->type_states[m->type].referenced = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase BTF_KIND_FUNC_PROTO: {\n\t\t\tconst struct btf_param *p = btf_params(t);\n\n\t\t\tfor (j = 0; j < vlen; j++, p++)\n\t\t\t\td->type_states[p->type].referenced = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase BTF_KIND_DATASEC: {\n\t\t\tconst struct btf_var_secinfo *v = btf_var_secinfos(t);\n\n\t\t\tfor (j = 0; j < vlen; j++, v++)\n\t\t\t\td->type_states[v->type].referenced = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int btf_dump_add_emit_queue_id(struct btf_dump *d, __u32 id)\n{\n\t__u32 *new_queue;\n\tsize_t new_cap;\n\n\tif (d->emit_queue_cnt >= d->emit_queue_cap) {\n\t\tnew_cap = max(16, d->emit_queue_cap * 3 / 2);\n\t\tnew_queue = libbpf_reallocarray(d->emit_queue, new_cap, sizeof(new_queue[0]));\n\t\tif (!new_queue)\n\t\t\treturn -ENOMEM;\n\t\td->emit_queue = new_queue;\n\t\td->emit_queue_cap = new_cap;\n\t}\n\n\td->emit_queue[d->emit_queue_cnt++] = id;\n\treturn 0;\n}\n\n \nstatic int btf_dump_order_type(struct btf_dump *d, __u32 id, bool through_ptr)\n{\n\t \n\tstruct btf_dump_type_aux_state *tstate = &d->type_states[id];\n\tconst struct btf_type *t;\n\t__u16 vlen;\n\tint err, i;\n\n\t \n\tif (tstate->order_state == ORDERED)\n\t\treturn 1;\n\n\tt = btf__type_by_id(d->btf, id);\n\n\tif (tstate->order_state == ORDERING) {\n\t\t \n\t\tif (btf_is_composite(t) && through_ptr && t->name_off != 0)\n\t\t\treturn 0;\n\t\tpr_warn(\"unsatisfiable type cycle, id:[%u]\\n\", id);\n\t\treturn -ELOOP;\n\t}\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\t\ttstate->order_state = ORDERED;\n\t\treturn 0;\n\n\tcase BTF_KIND_PTR:\n\t\terr = btf_dump_order_type(d, t->type, true);\n\t\ttstate->order_state = ORDERED;\n\t\treturn err;\n\n\tcase BTF_KIND_ARRAY:\n\t\treturn btf_dump_order_type(d, btf_array(t)->type, false);\n\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m = btf_members(t);\n\t\t \n\t\tif (through_ptr && t->name_off != 0)\n\t\t\treturn 0;\n\n\t\ttstate->order_state = ORDERING;\n\n\t\tvlen = btf_vlen(t);\n\t\tfor (i = 0; i < vlen; i++, m++) {\n\t\t\terr = btf_dump_order_type(d, m->type, false);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (t->name_off != 0) {\n\t\t\terr = btf_dump_add_emit_queue_id(d, id);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\ttstate->order_state = ORDERED;\n\t\treturn 1;\n\t}\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\tcase BTF_KIND_FWD:\n\t\t \n\t\tif (t->name_off != 0 || !tstate->referenced) {\n\t\t\terr = btf_dump_add_emit_queue_id(d, id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\ttstate->order_state = ORDERED;\n\t\treturn 1;\n\n\tcase BTF_KIND_TYPEDEF: {\n\t\tint is_strong;\n\n\t\tis_strong = btf_dump_order_type(d, t->type, through_ptr);\n\t\tif (is_strong < 0)\n\t\t\treturn is_strong;\n\n\t\t \n\t\tif (through_ptr && !is_strong)\n\t\t\treturn 0;\n\n\t\t \n\t\terr = btf_dump_add_emit_queue_id(d, id);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\td->type_states[id].order_state = ORDERED;\n\t\treturn 1;\n\t}\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn btf_dump_order_type(d, t->type, through_ptr);\n\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *p = btf_params(t);\n\t\tbool is_strong;\n\n\t\terr = btf_dump_order_type(d, t->type, through_ptr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tis_strong = err > 0;\n\n\t\tvlen = btf_vlen(t);\n\t\tfor (i = 0; i < vlen; i++, p++) {\n\t\t\terr = btf_dump_order_type(d, p->type, through_ptr);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err > 0)\n\t\t\t\tis_strong = true;\n\t\t}\n\t\treturn is_strong;\n\t}\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_VAR:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_DECL_TAG:\n\t\td->type_states[id].order_state = ORDERED;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void btf_dump_emit_missing_aliases(struct btf_dump *d, __u32 id,\n\t\t\t\t\t  const struct btf_type *t);\n\nstatic void btf_dump_emit_struct_fwd(struct btf_dump *d, __u32 id,\n\t\t\t\t     const struct btf_type *t);\nstatic void btf_dump_emit_struct_def(struct btf_dump *d, __u32 id,\n\t\t\t\t     const struct btf_type *t, int lvl);\n\nstatic void btf_dump_emit_enum_fwd(struct btf_dump *d, __u32 id,\n\t\t\t\t   const struct btf_type *t);\nstatic void btf_dump_emit_enum_def(struct btf_dump *d, __u32 id,\n\t\t\t\t   const struct btf_type *t, int lvl);\n\nstatic void btf_dump_emit_fwd_def(struct btf_dump *d, __u32 id,\n\t\t\t\t  const struct btf_type *t);\n\nstatic void btf_dump_emit_typedef_def(struct btf_dump *d, __u32 id,\n\t\t\t\t      const struct btf_type *t, int lvl);\n\n \nstruct id_stack {\n\tconst __u32 *ids;\n\tint cnt;\n};\n\nstatic void btf_dump_emit_type_decl(struct btf_dump *d, __u32 id,\n\t\t\t\t    const char *fname, int lvl);\nstatic void btf_dump_emit_type_chain(struct btf_dump *d,\n\t\t\t\t     struct id_stack *decl_stack,\n\t\t\t\t     const char *fname, int lvl);\n\nstatic const char *btf_dump_type_name(struct btf_dump *d, __u32 id);\nstatic const char *btf_dump_ident_name(struct btf_dump *d, __u32 id);\nstatic size_t btf_dump_name_dups(struct btf_dump *d, struct hashmap *name_map,\n\t\t\t\t const char *orig_name);\n\nstatic bool btf_dump_is_blacklisted(struct btf_dump *d, __u32 id)\n{\n\tconst struct btf_type *t = btf__type_by_id(d->btf, id);\n\n\t \n\tif (t->name_off == 0)\n\t\treturn false;\n\treturn strcmp(btf_name_of(d, t->name_off), \"__builtin_va_list\") == 0;\n}\n\n \nstatic void btf_dump_emit_type(struct btf_dump *d, __u32 id, __u32 cont_id)\n{\n\tstruct btf_dump_type_aux_state *tstate = &d->type_states[id];\n\tbool top_level_def = cont_id == 0;\n\tconst struct btf_type *t;\n\t__u16 kind;\n\n\tif (tstate->emit_state == EMITTED)\n\t\treturn;\n\n\tt = btf__type_by_id(d->btf, id);\n\tkind = btf_kind(t);\n\n\tif (tstate->emit_state == EMITTING) {\n\t\tif (tstate->fwd_emitted)\n\t\t\treturn;\n\n\t\tswitch (kind) {\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\t\t \n\t\t\tif (id == cont_id)\n\t\t\t\treturn;\n\t\t\tif (t->name_off == 0) {\n\t\t\t\tpr_warn(\"anonymous struct/union loop, id:[%u]\\n\",\n\t\t\t\t\tid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbtf_dump_emit_struct_fwd(d, id, t);\n\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t\ttstate->fwd_emitted = 1;\n\t\t\tbreak;\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\t \n\t\t\tif (!btf_dump_is_blacklisted(d, id)) {\n\t\t\t\tbtf_dump_emit_typedef_def(d, id, t, 0);\n\t\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t\t}\n\t\t\ttstate->fwd_emitted = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (kind) {\n\tcase BTF_KIND_INT:\n\t\t \n\t\tbtf_dump_emit_missing_aliases(d, id, t);\n\n\t\ttstate->emit_state = EMITTED;\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\tif (top_level_def) {\n\t\t\tbtf_dump_emit_enum_def(d, id, t, 0);\n\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t}\n\t\ttstate->emit_state = EMITTED;\n\t\tbreak;\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\tbtf_dump_emit_type(d, t->type, cont_id);\n\t\tbreak;\n\tcase BTF_KIND_ARRAY:\n\t\tbtf_dump_emit_type(d, btf_array(t)->type, cont_id);\n\t\tbreak;\n\tcase BTF_KIND_FWD:\n\t\tbtf_dump_emit_fwd_def(d, id, t);\n\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\ttstate->emit_state = EMITTED;\n\t\tbreak;\n\tcase BTF_KIND_TYPEDEF:\n\t\ttstate->emit_state = EMITTING;\n\t\tbtf_dump_emit_type(d, t->type, id);\n\t\t \n\t\tif (!tstate->fwd_emitted && !btf_dump_is_blacklisted(d, id)) {\n\t\t\tbtf_dump_emit_typedef_def(d, id, t, 0);\n\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t}\n\t\ttstate->emit_state = EMITTED;\n\t\tbreak;\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\ttstate->emit_state = EMITTING;\n\t\t \n\t\tif (top_level_def || t->name_off == 0) {\n\t\t\tconst struct btf_member *m = btf_members(t);\n\t\t\t__u16 vlen = btf_vlen(t);\n\t\t\tint i, new_cont_id;\n\n\t\t\tnew_cont_id = t->name_off == 0 ? cont_id : id;\n\t\t\tfor (i = 0; i < vlen; i++, m++)\n\t\t\t\tbtf_dump_emit_type(d, m->type, new_cont_id);\n\t\t} else if (!tstate->fwd_emitted && id != cont_id) {\n\t\t\tbtf_dump_emit_struct_fwd(d, id, t);\n\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t\ttstate->fwd_emitted = 1;\n\t\t}\n\n\t\tif (top_level_def) {\n\t\t\tbtf_dump_emit_struct_def(d, id, t, 0);\n\t\t\tbtf_dump_printf(d, \";\\n\\n\");\n\t\t\ttstate->emit_state = EMITTED;\n\t\t} else {\n\t\t\ttstate->emit_state = NOT_EMITTED;\n\t\t}\n\t\tbreak;\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *p = btf_params(t);\n\t\t__u16 n = btf_vlen(t);\n\t\tint i;\n\n\t\tbtf_dump_emit_type(d, t->type, cont_id);\n\t\tfor (i = 0; i < n; i++, p++)\n\t\t\tbtf_dump_emit_type(d, p->type, cont_id);\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool btf_is_struct_packed(const struct btf *btf, __u32 id,\n\t\t\t\t const struct btf_type *t)\n{\n\tconst struct btf_member *m;\n\tint max_align = 1, align, i, bit_sz;\n\t__u16 vlen;\n\n\tm = btf_members(t);\n\tvlen = btf_vlen(t);\n\t \n\tfor (i = 0; i < vlen; i++, m++) {\n\t\talign = btf__align_of(btf, m->type);\n\t\tbit_sz = btf_member_bitfield_size(t, i);\n\t\tif (align && bit_sz == 0 && m->offset % (8 * align) != 0)\n\t\t\treturn true;\n\t\tmax_align = max(align, max_align);\n\t}\n\t \n\tif (t->size % max_align != 0)\n\t\treturn true;\n\t \n\treturn false;\n}\n\nstatic void btf_dump_emit_bit_padding(const struct btf_dump *d,\n\t\t\t\t      int cur_off, int next_off, int next_align,\n\t\t\t\t      bool in_bitfield, int lvl)\n{\n\tconst struct {\n\t\tconst char *name;\n\t\tint bits;\n\t} pads[] = {\n\t\t{\"long\", d->ptr_sz * 8}, {\"int\", 32}, {\"short\", 16}, {\"char\", 8}\n\t};\n\tint new_off, pad_bits, bits, i;\n\tconst char *pad_type;\n\n\tif (cur_off >= next_off)\n\t\treturn;  \n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pads); i++) {\n\t\tpad_bits = pads[i].bits;\n\t\tpad_type = pads[i].name;\n\n\t\tnew_off = roundup(cur_off, pad_bits);\n\t\tif (new_off <= next_off)\n\t\t\tbreak;\n\t}\n\n\tif (new_off > cur_off && new_off <= next_off) {\n\t\t \n\t\tif (in_bitfield ||\n\t\t    (new_off == next_off && roundup(cur_off, next_align * 8) != new_off) ||\n\t\t    (new_off != next_off && next_off - new_off <= new_off - cur_off))\n\t\t\t \n\t\t\tbtf_dump_printf(d, \"\\n%s%s: %d;\", pfx(lvl), pad_type,\n\t\t\t\t\tin_bitfield ? new_off - cur_off : 0);\n\t\tcur_off = new_off;\n\t}\n\n\t \n\twhile (cur_off != next_off) {\n\t\tbits = min(next_off - cur_off, pad_bits);\n\t\tif (bits == pad_bits) {\n\t\t\tbtf_dump_printf(d, \"\\n%s%s: %d;\", pfx(lvl), pad_type, pad_bits);\n\t\t\tcur_off += bits;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (i = ARRAY_SIZE(pads) - 1; i >= 0; i--) {\n\t\t\tpad_type = pads[i].name;\n\t\t\tpad_bits = pads[i].bits;\n\t\t\tif (pad_bits < bits)\n\t\t\t\tcontinue;\n\n\t\t\tbtf_dump_printf(d, \"\\n%s%s: %d;\", pfx(lvl), pad_type, bits);\n\t\t\tcur_off += bits;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void btf_dump_emit_struct_fwd(struct btf_dump *d, __u32 id,\n\t\t\t\t     const struct btf_type *t)\n{\n\tbtf_dump_printf(d, \"%s%s%s\",\n\t\t\tbtf_is_struct(t) ? \"struct\" : \"union\",\n\t\t\tt->name_off ? \" \" : \"\",\n\t\t\tbtf_dump_type_name(d, id));\n}\n\nstatic void btf_dump_emit_struct_def(struct btf_dump *d,\n\t\t\t\t     __u32 id,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     int lvl)\n{\n\tconst struct btf_member *m = btf_members(t);\n\tbool is_struct = btf_is_struct(t);\n\tbool packed, prev_bitfield = false;\n\tint align, i, off = 0;\n\t__u16 vlen = btf_vlen(t);\n\n\talign = btf__align_of(d->btf, id);\n\tpacked = is_struct ? btf_is_struct_packed(d->btf, id, t) : 0;\n\n\tbtf_dump_printf(d, \"%s%s%s {\",\n\t\t\tis_struct ? \"struct\" : \"union\",\n\t\t\tt->name_off ? \" \" : \"\",\n\t\t\tbtf_dump_type_name(d, id));\n\n\tfor (i = 0; i < vlen; i++, m++) {\n\t\tconst char *fname;\n\t\tint m_off, m_sz, m_align;\n\t\tbool in_bitfield;\n\n\t\tfname = btf_name_of(d, m->name_off);\n\t\tm_sz = btf_member_bitfield_size(t, i);\n\t\tm_off = btf_member_bit_offset(t, i);\n\t\tm_align = packed ? 1 : btf__align_of(d->btf, m->type);\n\n\t\tin_bitfield = prev_bitfield && m_sz != 0;\n\n\t\tbtf_dump_emit_bit_padding(d, off, m_off, m_align, in_bitfield, lvl + 1);\n\t\tbtf_dump_printf(d, \"\\n%s\", pfx(lvl + 1));\n\t\tbtf_dump_emit_type_decl(d, m->type, fname, lvl + 1);\n\n\t\tif (m_sz) {\n\t\t\tbtf_dump_printf(d, \": %d\", m_sz);\n\t\t\toff = m_off + m_sz;\n\t\t\tprev_bitfield = true;\n\t\t} else {\n\t\t\tm_sz = max((__s64)0, btf__resolve_size(d->btf, m->type));\n\t\t\toff = m_off + m_sz * 8;\n\t\t\tprev_bitfield = false;\n\t\t}\n\n\t\tbtf_dump_printf(d, \";\");\n\t}\n\n\t \n\tif (is_struct)\n\t\tbtf_dump_emit_bit_padding(d, off, t->size * 8, align, false, lvl + 1);\n\n\t \n\tif (vlen || t->size) {\n\t\tbtf_dump_printf(d, \"\\n\");\n\t\tbtf_dump_printf(d, \"%s}\", pfx(lvl));\n\t} else {\n\t\tbtf_dump_printf(d, \"}\");\n\t}\n\tif (packed)\n\t\tbtf_dump_printf(d, \" __attribute__((packed))\");\n}\n\nstatic const char *missing_base_types[][2] = {\n\t \n\t{ \"__Poly8_t\",\t\t\"unsigned char\" },\n\t{ \"__Poly16_t\",\t\t\"unsigned short\" },\n\t{ \"__Poly64_t\",\t\t\"unsigned long long\" },\n\t{ \"__Poly128_t\",\t\"unsigned __int128\" },\n};\n\nstatic void btf_dump_emit_missing_aliases(struct btf_dump *d, __u32 id,\n\t\t\t\t\t  const struct btf_type *t)\n{\n\tconst char *name = btf_dump_type_name(d, id);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(missing_base_types); i++) {\n\t\tif (strcmp(name, missing_base_types[i][0]) == 0) {\n\t\t\tbtf_dump_printf(d, \"typedef %s %s;\\n\\n\",\n\t\t\t\t\tmissing_base_types[i][1], name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void btf_dump_emit_enum_fwd(struct btf_dump *d, __u32 id,\n\t\t\t\t   const struct btf_type *t)\n{\n\tbtf_dump_printf(d, \"enum %s\", btf_dump_type_name(d, id));\n}\n\nstatic void btf_dump_emit_enum32_val(struct btf_dump *d,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     int lvl, __u16 vlen)\n{\n\tconst struct btf_enum *v = btf_enum(t);\n\tbool is_signed = btf_kflag(t);\n\tconst char *fmt_str;\n\tconst char *name;\n\tsize_t dup_cnt;\n\tint i;\n\n\tfor (i = 0; i < vlen; i++, v++) {\n\t\tname = btf_name_of(d, v->name_off);\n\t\t \n\t\tdup_cnt = btf_dump_name_dups(d, d->ident_names, name);\n\t\tif (dup_cnt > 1) {\n\t\t\tfmt_str = is_signed ? \"\\n%s%s___%zd = %d,\" : \"\\n%s%s___%zd = %u,\";\n\t\t\tbtf_dump_printf(d, fmt_str, pfx(lvl + 1), name, dup_cnt, v->val);\n\t\t} else {\n\t\t\tfmt_str = is_signed ? \"\\n%s%s = %d,\" : \"\\n%s%s = %u,\";\n\t\t\tbtf_dump_printf(d, fmt_str, pfx(lvl + 1), name, v->val);\n\t\t}\n\t}\n}\n\nstatic void btf_dump_emit_enum64_val(struct btf_dump *d,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     int lvl, __u16 vlen)\n{\n\tconst struct btf_enum64 *v = btf_enum64(t);\n\tbool is_signed = btf_kflag(t);\n\tconst char *fmt_str;\n\tconst char *name;\n\tsize_t dup_cnt;\n\t__u64 val;\n\tint i;\n\n\tfor (i = 0; i < vlen; i++, v++) {\n\t\tname = btf_name_of(d, v->name_off);\n\t\tdup_cnt = btf_dump_name_dups(d, d->ident_names, name);\n\t\tval = btf_enum64_value(v);\n\t\tif (dup_cnt > 1) {\n\t\t\tfmt_str = is_signed ? \"\\n%s%s___%zd = %lldLL,\"\n\t\t\t\t\t    : \"\\n%s%s___%zd = %lluULL,\";\n\t\t\tbtf_dump_printf(d, fmt_str,\n\t\t\t\t\tpfx(lvl + 1), name, dup_cnt,\n\t\t\t\t\t(unsigned long long)val);\n\t\t} else {\n\t\t\tfmt_str = is_signed ? \"\\n%s%s = %lldLL,\"\n\t\t\t\t\t    : \"\\n%s%s = %lluULL,\";\n\t\t\tbtf_dump_printf(d, fmt_str,\n\t\t\t\t\tpfx(lvl + 1), name,\n\t\t\t\t\t(unsigned long long)val);\n\t\t}\n\t}\n}\nstatic void btf_dump_emit_enum_def(struct btf_dump *d, __u32 id,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   int lvl)\n{\n\t__u16 vlen = btf_vlen(t);\n\n\tbtf_dump_printf(d, \"enum%s%s\",\n\t\t\tt->name_off ? \" \" : \"\",\n\t\t\tbtf_dump_type_name(d, id));\n\n\tif (!vlen)\n\t\treturn;\n\n\tbtf_dump_printf(d, \" {\");\n\tif (btf_is_enum(t))\n\t\tbtf_dump_emit_enum32_val(d, t, lvl, vlen);\n\telse\n\t\tbtf_dump_emit_enum64_val(d, t, lvl, vlen);\n\tbtf_dump_printf(d, \"\\n%s}\", pfx(lvl));\n\n\t \n\tif (t->size == 1) {\n\t\t \n\t\tbtf_dump_printf(d, \" __attribute__((mode(byte)))\");\n\t} else if (t->size == 8 && d->ptr_sz == 8) {\n\t\t \n\t\tbool needs_word_mode;\n\n\t\tif (btf_is_enum(t)) {\n\t\t\t \n\t\t\tneeds_word_mode = true;\n\t\t} else {\n\t\t\t \n\t\t\tint i;\n\n\t\t\tneeds_word_mode = true;\n\t\t\tfor (i = 0; i < vlen; i++) {\n\t\t\t\tif (btf_enum64(t)[i].val_hi32 != 0) {\n\t\t\t\t\tneeds_word_mode = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needs_word_mode)\n\t\t\tbtf_dump_printf(d, \" __attribute__((mode(word)))\");\n\t}\n\n}\n\nstatic void btf_dump_emit_fwd_def(struct btf_dump *d, __u32 id,\n\t\t\t\t  const struct btf_type *t)\n{\n\tconst char *name = btf_dump_type_name(d, id);\n\n\tif (btf_kflag(t))\n\t\tbtf_dump_printf(d, \"union %s\", name);\n\telse\n\t\tbtf_dump_printf(d, \"struct %s\", name);\n}\n\nstatic void btf_dump_emit_typedef_def(struct btf_dump *d, __u32 id,\n\t\t\t\t     const struct btf_type *t, int lvl)\n{\n\tconst char *name = btf_dump_ident_name(d, id);\n\n\t \n\tif (t->type == 0 && strcmp(name, \"__gnuc_va_list\") == 0) {\n\t\tbtf_dump_printf(d, \"typedef __builtin_va_list __gnuc_va_list\");\n\t\treturn;\n\t}\n\n\tbtf_dump_printf(d, \"typedef \");\n\tbtf_dump_emit_type_decl(d, t->type, name, lvl);\n}\n\nstatic int btf_dump_push_decl_stack_id(struct btf_dump *d, __u32 id)\n{\n\t__u32 *new_stack;\n\tsize_t new_cap;\n\n\tif (d->decl_stack_cnt >= d->decl_stack_cap) {\n\t\tnew_cap = max(16, d->decl_stack_cap * 3 / 2);\n\t\tnew_stack = libbpf_reallocarray(d->decl_stack, new_cap, sizeof(new_stack[0]));\n\t\tif (!new_stack)\n\t\t\treturn -ENOMEM;\n\t\td->decl_stack = new_stack;\n\t\td->decl_stack_cap = new_cap;\n\t}\n\n\td->decl_stack[d->decl_stack_cnt++] = id;\n\n\treturn 0;\n}\n\n \nint btf_dump__emit_type_decl(struct btf_dump *d, __u32 id,\n\t\t\t     const struct btf_dump_emit_type_decl_opts *opts)\n{\n\tconst char *fname;\n\tint lvl, err;\n\n\tif (!OPTS_VALID(opts, btf_dump_emit_type_decl_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\terr = btf_dump_resize(d);\n\tif (err)\n\t\treturn libbpf_err(err);\n\n\tfname = OPTS_GET(opts, field_name, \"\");\n\tlvl = OPTS_GET(opts, indent_level, 0);\n\td->strip_mods = OPTS_GET(opts, strip_mods, false);\n\tbtf_dump_emit_type_decl(d, id, fname, lvl);\n\td->strip_mods = false;\n\treturn 0;\n}\n\nstatic void btf_dump_emit_type_decl(struct btf_dump *d, __u32 id,\n\t\t\t\t    const char *fname, int lvl)\n{\n\tstruct id_stack decl_stack;\n\tconst struct btf_type *t;\n\tint err, stack_start;\n\n\tstack_start = d->decl_stack_cnt;\n\tfor (;;) {\n\t\tt = btf__type_by_id(d->btf, id);\n\t\tif (d->strip_mods && btf_is_mod(t))\n\t\t\tgoto skip_mod;\n\n\t\terr = btf_dump_push_decl_stack_id(d, id);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tpr_warn(\"not enough memory for decl stack:%d\", err);\n\t\t\td->decl_stack_cnt = stack_start;\n\t\t\treturn;\n\t\t}\nskip_mod:\n\t\t \n\t\tif (id == 0)\n\t\t\tbreak;\n\n\t\tswitch (btf_kind(t)) {\n\t\tcase BTF_KIND_PTR:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_FUNC_PROTO:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tid = btf_array(t)->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_ENUM64:\n\t\tcase BTF_KIND_FWD:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tpr_warn(\"unexpected type in decl chain, kind:%u, id:[%u]\\n\",\n\t\t\t\tbtf_kind(t), id);\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\t \n\tdecl_stack.ids = d->decl_stack + stack_start;\n\tdecl_stack.cnt = d->decl_stack_cnt - stack_start;\n\tbtf_dump_emit_type_chain(d, &decl_stack, fname, lvl);\n\t \n\td->decl_stack_cnt = stack_start;\n}\n\nstatic void btf_dump_emit_mods(struct btf_dump *d, struct id_stack *decl_stack)\n{\n\tconst struct btf_type *t;\n\t__u32 id;\n\n\twhile (decl_stack->cnt) {\n\t\tid = decl_stack->ids[decl_stack->cnt - 1];\n\t\tt = btf__type_by_id(d->btf, id);\n\n\t\tswitch (btf_kind(t)) {\n\t\tcase BTF_KIND_VOLATILE:\n\t\t\tbtf_dump_printf(d, \"volatile \");\n\t\t\tbreak;\n\t\tcase BTF_KIND_CONST:\n\t\t\tbtf_dump_printf(d, \"const \");\n\t\t\tbreak;\n\t\tcase BTF_KIND_RESTRICT:\n\t\t\tbtf_dump_printf(d, \"restrict \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tdecl_stack->cnt--;\n\t}\n}\n\nstatic void btf_dump_drop_mods(struct btf_dump *d, struct id_stack *decl_stack)\n{\n\tconst struct btf_type *t;\n\t__u32 id;\n\n\twhile (decl_stack->cnt) {\n\t\tid = decl_stack->ids[decl_stack->cnt - 1];\n\t\tt = btf__type_by_id(d->btf, id);\n\t\tif (!btf_is_mod(t))\n\t\t\treturn;\n\t\tdecl_stack->cnt--;\n\t}\n}\n\nstatic void btf_dump_emit_name(const struct btf_dump *d,\n\t\t\t       const char *name, bool last_was_ptr)\n{\n\tbool separate = name[0] && !last_was_ptr;\n\n\tbtf_dump_printf(d, \"%s%s\", separate ? \" \" : \"\", name);\n}\n\nstatic void btf_dump_emit_type_chain(struct btf_dump *d,\n\t\t\t\t     struct id_stack *decls,\n\t\t\t\t     const char *fname, int lvl)\n{\n\t \n\tbool last_was_ptr = true;\n\tconst struct btf_type *t;\n\tconst char *name;\n\t__u16 kind;\n\t__u32 id;\n\n\twhile (decls->cnt) {\n\t\tid = decls->ids[--decls->cnt];\n\t\tif (id == 0) {\n\t\t\t \n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\tbtf_dump_printf(d, \"void\");\n\t\t\tlast_was_ptr = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tt = btf__type_by_id(d->btf, id);\n\t\tkind = btf_kind(t);\n\n\t\tswitch (kind) {\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\tname = btf_name_of(d, t->name_off);\n\t\t\tbtf_dump_printf(d, \"%s\", name);\n\t\t\tbreak;\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\t \n\t\t\tif (t->name_off == 0 && !d->skip_anon_defs)\n\t\t\t\tbtf_dump_emit_struct_def(d, id, t, lvl);\n\t\t\telse\n\t\t\t\tbtf_dump_emit_struct_fwd(d, id, t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_ENUM64:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\t \n\t\t\tif (t->name_off == 0 && !d->skip_anon_defs)\n\t\t\t\tbtf_dump_emit_enum_def(d, id, t, lvl);\n\t\t\telse\n\t\t\t\tbtf_dump_emit_enum_fwd(d, id, t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_FWD:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\tbtf_dump_emit_fwd_def(d, id, t);\n\t\t\tbreak;\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\tbtf_dump_printf(d, \"%s\", btf_dump_ident_name(d, id));\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tbtf_dump_printf(d, \"%s\", last_was_ptr ? \"*\" : \" *\");\n\t\t\tbreak;\n\t\tcase BTF_KIND_VOLATILE:\n\t\t\tbtf_dump_printf(d, \" volatile\");\n\t\t\tbreak;\n\t\tcase BTF_KIND_CONST:\n\t\t\tbtf_dump_printf(d, \" const\");\n\t\t\tbreak;\n\t\tcase BTF_KIND_RESTRICT:\n\t\t\tbtf_dump_printf(d, \" restrict\");\n\t\t\tbreak;\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tbtf_dump_emit_mods(d, decls);\n\t\t\tname = btf_name_of(d, t->name_off);\n\t\t\tbtf_dump_printf(d, \" __attribute__((btf_type_tag(\\\"%s\\\")))\", name);\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY: {\n\t\t\tconst struct btf_array *a = btf_array(t);\n\t\t\tconst struct btf_type *next_t;\n\t\t\t__u32 next_id;\n\t\t\tbool multidim;\n\t\t\t \n\t\t\tbtf_dump_drop_mods(d, decls);\n\n\t\t\tif (decls->cnt == 0) {\n\t\t\t\tbtf_dump_emit_name(d, fname, last_was_ptr);\n\t\t\t\tbtf_dump_printf(d, \"[%u]\", a->nelems);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnext_id = decls->ids[decls->cnt - 1];\n\t\t\tnext_t = btf__type_by_id(d->btf, next_id);\n\t\t\tmultidim = btf_is_array(next_t);\n\t\t\t \n\t\t\tif (fname[0] && !last_was_ptr)\n\t\t\t\tbtf_dump_printf(d, \" \");\n\t\t\t \n\t\t\tif (!multidim)\n\t\t\t\tbtf_dump_printf(d, \"(\");\n\t\t\tbtf_dump_emit_type_chain(d, decls, fname, lvl);\n\t\t\tif (!multidim)\n\t\t\t\tbtf_dump_printf(d, \")\");\n\t\t\tbtf_dump_printf(d, \"[%u]\", a->nelems);\n\t\t\treturn;\n\t\t}\n\t\tcase BTF_KIND_FUNC_PROTO: {\n\t\t\tconst struct btf_param *p = btf_params(t);\n\t\t\t__u16 vlen = btf_vlen(t);\n\t\t\tint i;\n\n\t\t\t \n\t\t\tbtf_dump_drop_mods(d, decls);\n\t\t\tif (decls->cnt) {\n\t\t\t\tbtf_dump_printf(d, \" (\");\n\t\t\t\tbtf_dump_emit_type_chain(d, decls, fname, lvl);\n\t\t\t\tbtf_dump_printf(d, \")\");\n\t\t\t} else {\n\t\t\t\tbtf_dump_emit_name(d, fname, last_was_ptr);\n\t\t\t}\n\t\t\tbtf_dump_printf(d, \"(\");\n\t\t\t \n\t\t\tif (vlen == 1 && p->type == 0) {\n\t\t\t\tbtf_dump_printf(d, \")\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < vlen; i++, p++) {\n\t\t\t\tif (i > 0)\n\t\t\t\t\tbtf_dump_printf(d, \", \");\n\n\t\t\t\t \n\t\t\t\tif (i == vlen - 1 && p->type == 0) {\n\t\t\t\t\tbtf_dump_printf(d, \"...\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tname = btf_name_of(d, p->name_off);\n\t\t\t\tbtf_dump_emit_type_decl(d, p->type, name, lvl);\n\t\t\t}\n\n\t\t\tbtf_dump_printf(d, \")\");\n\t\t\treturn;\n\t\t}\n\t\tdefault:\n\t\t\tpr_warn(\"unexpected type in decl chain, kind:%u, id:[%u]\\n\",\n\t\t\t\tkind, id);\n\t\t\treturn;\n\t\t}\n\n\t\tlast_was_ptr = kind == BTF_KIND_PTR;\n\t}\n\n\tbtf_dump_emit_name(d, fname, last_was_ptr);\n}\n\n \nstatic void btf_dump_emit_type_cast(struct btf_dump *d, __u32 id,\n\t\t\t\t    bool top_level)\n{\n\tconst struct btf_type *t;\n\n\t \n\tif (d->typed_dump->is_array_member)\n\t\treturn;\n\n\t \n\tt = btf__type_by_id(d->btf, id);\n\tif (btf_is_var(t) || btf_is_datasec(t))\n\t\treturn;\n\n\tif (top_level)\n\t\tbtf_dump_printf(d, \"(\");\n\n\td->skip_anon_defs = true;\n\td->strip_mods = true;\n\tbtf_dump_emit_type_decl(d, id, \"\", 0);\n\td->strip_mods = false;\n\td->skip_anon_defs = false;\n\n\tif (top_level)\n\t\tbtf_dump_printf(d, \")\");\n}\n\n \nstatic size_t btf_dump_name_dups(struct btf_dump *d, struct hashmap *name_map,\n\t\t\t\t const char *orig_name)\n{\n\tchar *old_name, *new_name;\n\tsize_t dup_cnt = 0;\n\tint err;\n\n\tnew_name = strdup(orig_name);\n\tif (!new_name)\n\t\treturn 1;\n\n\t(void)hashmap__find(name_map, orig_name, &dup_cnt);\n\tdup_cnt++;\n\n\terr = hashmap__set(name_map, new_name, dup_cnt, &old_name, NULL);\n\tif (err)\n\t\tfree(new_name);\n\n\tfree(old_name);\n\n\treturn dup_cnt;\n}\n\nstatic const char *btf_dump_resolve_name(struct btf_dump *d, __u32 id,\n\t\t\t\t\t struct hashmap *name_map)\n{\n\tstruct btf_dump_type_aux_state *s = &d->type_states[id];\n\tconst struct btf_type *t = btf__type_by_id(d->btf, id);\n\tconst char *orig_name = btf_name_of(d, t->name_off);\n\tconst char **cached_name = &d->cached_names[id];\n\tsize_t dup_cnt;\n\n\tif (t->name_off == 0)\n\t\treturn \"\";\n\n\tif (s->name_resolved)\n\t\treturn *cached_name ? *cached_name : orig_name;\n\n\tif (btf_is_fwd(t) || (btf_is_enum(t) && btf_vlen(t) == 0)) {\n\t\ts->name_resolved = 1;\n\t\treturn orig_name;\n\t}\n\n\tdup_cnt = btf_dump_name_dups(d, name_map, orig_name);\n\tif (dup_cnt > 1) {\n\t\tconst size_t max_len = 256;\n\t\tchar new_name[max_len];\n\n\t\tsnprintf(new_name, max_len, \"%s___%zu\", orig_name, dup_cnt);\n\t\t*cached_name = strdup(new_name);\n\t}\n\n\ts->name_resolved = 1;\n\treturn *cached_name ? *cached_name : orig_name;\n}\n\nstatic const char *btf_dump_type_name(struct btf_dump *d, __u32 id)\n{\n\treturn btf_dump_resolve_name(d, id, d->type_names);\n}\n\nstatic const char *btf_dump_ident_name(struct btf_dump *d, __u32 id)\n{\n\treturn btf_dump_resolve_name(d, id, d->ident_names);\n}\n\nstatic int btf_dump_dump_type_data(struct btf_dump *d,\n\t\t\t\t   const char *fname,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   __u32 id,\n\t\t\t\t   const void *data,\n\t\t\t\t   __u8 bits_offset,\n\t\t\t\t   __u8 bit_sz);\n\nstatic const char *btf_dump_data_newline(struct btf_dump *d)\n{\n\treturn d->typed_dump->compact || d->typed_dump->depth == 0 ? \"\" : \"\\n\";\n}\n\nstatic const char *btf_dump_data_delim(struct btf_dump *d)\n{\n\treturn d->typed_dump->depth == 0 ? \"\" : \",\";\n}\n\nstatic void btf_dump_data_pfx(struct btf_dump *d)\n{\n\tint i, lvl = d->typed_dump->indent_lvl + d->typed_dump->depth;\n\n\tif (d->typed_dump->compact)\n\t\treturn;\n\n\tfor (i = 0; i < lvl; i++)\n\t\tbtf_dump_printf(d, \"%s\", d->typed_dump->indent_str);\n}\n\n \n#define btf_dump_type_values(d, fmt, ...)\t\t\t\t\\\n\tbtf_dump_printf(d, fmt \"%s%s\",\t\t\t\t\t\\\n\t\t\t##__VA_ARGS__,\t\t\t\t\t\\\n\t\t\tbtf_dump_data_delim(d),\t\t\t\t\\\n\t\t\tbtf_dump_data_newline(d))\n\nstatic int btf_dump_unsupported_data(struct btf_dump *d,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     __u32 id)\n{\n\tbtf_dump_printf(d, \"<unsupported kind:%u>\", btf_kind(t));\n\treturn -ENOTSUP;\n}\n\nstatic int btf_dump_get_bitfield_value(struct btf_dump *d,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       const void *data,\n\t\t\t\t       __u8 bits_offset,\n\t\t\t\t       __u8 bit_sz,\n\t\t\t\t       __u64 *value)\n{\n\t__u16 left_shift_bits, right_shift_bits;\n\tconst __u8 *bytes = data;\n\t__u8 nr_copy_bits;\n\t__u64 num = 0;\n\tint i;\n\n\t \n\tif (t->size > 8) {\n\t\tpr_warn(\"unexpected bitfield size %d\\n\", t->size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tfor (i = t->size - 1; i >= 0; i--)\n\t\tnum = num * 256 + bytes[i];\n\tnr_copy_bits = bit_sz + bits_offset;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tfor (i = 0; i < t->size; i++)\n\t\tnum = num * 256 + bytes[i];\n\tnr_copy_bits = t->size * 8 - bits_offset;\n#else\n# error \"Unrecognized __BYTE_ORDER__\"\n#endif\n\tleft_shift_bits = 64 - nr_copy_bits;\n\tright_shift_bits = 64 - bit_sz;\n\n\t*value = (num << left_shift_bits) >> right_shift_bits;\n\n\treturn 0;\n}\n\nstatic int btf_dump_bitfield_check_zero(struct btf_dump *d,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tconst void *data,\n\t\t\t\t\t__u8 bits_offset,\n\t\t\t\t\t__u8 bit_sz)\n{\n\t__u64 check_num;\n\tint err;\n\n\terr = btf_dump_get_bitfield_value(d, t, data, bits_offset, bit_sz, &check_num);\n\tif (err)\n\t\treturn err;\n\tif (check_num == 0)\n\t\treturn -ENODATA;\n\treturn 0;\n}\n\nstatic int btf_dump_bitfield_data(struct btf_dump *d,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  const void *data,\n\t\t\t\t  __u8 bits_offset,\n\t\t\t\t  __u8 bit_sz)\n{\n\t__u64 print_num;\n\tint err;\n\n\terr = btf_dump_get_bitfield_value(d, t, data, bits_offset, bit_sz, &print_num);\n\tif (err)\n\t\treturn err;\n\n\tbtf_dump_type_values(d, \"0x%llx\", (unsigned long long)print_num);\n\n\treturn 0;\n}\n\n \nstatic int btf_dump_base_type_check_zero(struct btf_dump *d,\n\t\t\t\t\t const struct btf_type *t,\n\t\t\t\t\t __u32 id,\n\t\t\t\t\t const void *data)\n{\n\tstatic __u8 bytecmp[16] = {};\n\tint nr_bytes;\n\n\t \n\tif (btf_kind(t) == BTF_KIND_PTR)\n\t\tnr_bytes = d->ptr_sz;\n\telse\n\t\tnr_bytes = t->size;\n\n\tif (nr_bytes < 1 || nr_bytes > 16) {\n\t\tpr_warn(\"unexpected size %d for id [%u]\\n\", nr_bytes, id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(data, bytecmp, nr_bytes) == 0)\n\t\treturn -ENODATA;\n\treturn 0;\n}\n\nstatic bool ptr_is_aligned(const struct btf *btf, __u32 type_id,\n\t\t\t   const void *data)\n{\n\tint alignment = btf__align_of(btf, type_id);\n\n\tif (alignment == 0)\n\t\treturn false;\n\n\treturn ((uintptr_t)data) % alignment == 0;\n}\n\nstatic int btf_dump_int_data(struct btf_dump *d,\n\t\t\t     const struct btf_type *t,\n\t\t\t     __u32 type_id,\n\t\t\t     const void *data,\n\t\t\t     __u8 bits_offset)\n{\n\t__u8 encoding = btf_int_encoding(t);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tchar buf[16] __attribute__((aligned(16)));\n\tint sz = t->size;\n\n\tif (sz == 0 || sz > sizeof(buf)) {\n\t\tpr_warn(\"unexpected size %d for id [%u]\\n\", sz, type_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ptr_is_aligned(d->btf, type_id, data)) {\n\t\tmemcpy(buf, data, sz);\n\t\tdata = buf;\n\t}\n\n\tswitch (sz) {\n\tcase 16: {\n\t\tconst __u64 *ints = data;\n\t\t__u64 lsi, msi;\n\n\t\t \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\t\tlsi = ints[0];\n\t\tmsi = ints[1];\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\t\tlsi = ints[1];\n\t\tmsi = ints[0];\n#else\n# error \"Unrecognized __BYTE_ORDER__\"\n#endif\n\t\tif (msi == 0)\n\t\t\tbtf_dump_type_values(d, \"0x%llx\", (unsigned long long)lsi);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"0x%llx%016llx\", (unsigned long long)msi,\n\t\t\t\t\t     (unsigned long long)lsi);\n\t\tbreak;\n\t}\n\tcase 8:\n\t\tif (sign)\n\t\t\tbtf_dump_type_values(d, \"%lld\", *(long long *)data);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"%llu\", *(unsigned long long *)data);\n\t\tbreak;\n\tcase 4:\n\t\tif (sign)\n\t\t\tbtf_dump_type_values(d, \"%d\", *(__s32 *)data);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"%u\", *(__u32 *)data);\n\t\tbreak;\n\tcase 2:\n\t\tif (sign)\n\t\t\tbtf_dump_type_values(d, \"%d\", *(__s16 *)data);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"%u\", *(__u16 *)data);\n\t\tbreak;\n\tcase 1:\n\t\tif (d->typed_dump->is_array_char) {\n\t\t\t \n\t\t\tif (d->typed_dump->is_array_terminated)\n\t\t\t\tbreak;\n\t\t\tif (*(char *)data == '\\0') {\n\t\t\t\td->typed_dump->is_array_terminated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isprint(*(char *)data)) {\n\t\t\t\tbtf_dump_type_values(d, \"'%c'\", *(char *)data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sign)\n\t\t\tbtf_dump_type_values(d, \"%d\", *(__s8 *)data);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"%u\", *(__u8 *)data);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unexpected sz %d for id [%u]\\n\", sz, type_id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nunion float_data {\n\tlong double ld;\n\tdouble d;\n\tfloat f;\n};\n\nstatic int btf_dump_float_data(struct btf_dump *d,\n\t\t\t       const struct btf_type *t,\n\t\t\t       __u32 type_id,\n\t\t\t       const void *data)\n{\n\tconst union float_data *flp = data;\n\tunion float_data fl;\n\tint sz = t->size;\n\n\t \n\tif (!ptr_is_aligned(d->btf, type_id, data)) {\n\t\tmemcpy(&fl, data, sz);\n\t\tflp = &fl;\n\t}\n\n\tswitch (sz) {\n\tcase 16:\n\t\tbtf_dump_type_values(d, \"%Lf\", flp->ld);\n\t\tbreak;\n\tcase 8:\n\t\tbtf_dump_type_values(d, \"%lf\", flp->d);\n\t\tbreak;\n\tcase 4:\n\t\tbtf_dump_type_values(d, \"%f\", flp->f);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unexpected size %d for id [%u]\\n\", sz, type_id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int btf_dump_var_data(struct btf_dump *d,\n\t\t\t     const struct btf_type *v,\n\t\t\t     __u32 id,\n\t\t\t     const void *data)\n{\n\tenum btf_func_linkage linkage = btf_var(v)->linkage;\n\tconst struct btf_type *t;\n\tconst char *l;\n\t__u32 type_id;\n\n\tswitch (linkage) {\n\tcase BTF_FUNC_STATIC:\n\t\tl = \"static \";\n\t\tbreak;\n\tcase BTF_FUNC_EXTERN:\n\t\tl = \"extern \";\n\t\tbreak;\n\tcase BTF_FUNC_GLOBAL:\n\tdefault:\n\t\tl = \"\";\n\t\tbreak;\n\t}\n\n\t \n\tbtf_dump_printf(d, \"%s\", l);\n\ttype_id = v->type;\n\tt = btf__type_by_id(d->btf, type_id);\n\tbtf_dump_emit_type_cast(d, type_id, false);\n\tbtf_dump_printf(d, \" %s = \", btf_name_of(d, v->name_off));\n\treturn btf_dump_dump_type_data(d, NULL, t, type_id, data, 0, 0);\n}\n\nstatic int btf_dump_array_data(struct btf_dump *d,\n\t\t\t       const struct btf_type *t,\n\t\t\t       __u32 id,\n\t\t\t       const void *data)\n{\n\tconst struct btf_array *array = btf_array(t);\n\tconst struct btf_type *elem_type;\n\t__u32 i, elem_type_id;\n\t__s64 elem_size;\n\tbool is_array_member;\n\n\telem_type_id = array->type;\n\telem_type = skip_mods_and_typedefs(d->btf, elem_type_id, NULL);\n\telem_size = btf__resolve_size(d->btf, elem_type_id);\n\tif (elem_size <= 0) {\n\t\tpr_warn(\"unexpected elem size %zd for array type [%u]\\n\",\n\t\t\t(ssize_t)elem_size, id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_is_int(elem_type)) {\n\t\t \n\t\tif (elem_size == 1)\n\t\t\td->typed_dump->is_array_char = true;\n\t}\n\n\t \n\td->typed_dump->depth++;\n\tbtf_dump_printf(d, \"[%s\", btf_dump_data_newline(d));\n\n\t \n\tis_array_member = d->typed_dump->is_array_member;\n\td->typed_dump->is_array_member = true;\n\tfor (i = 0; i < array->nelems; i++, data += elem_size) {\n\t\tif (d->typed_dump->is_array_terminated)\n\t\t\tbreak;\n\t\tbtf_dump_dump_type_data(d, NULL, elem_type, elem_type_id, data, 0, 0);\n\t}\n\td->typed_dump->is_array_member = is_array_member;\n\td->typed_dump->depth--;\n\tbtf_dump_data_pfx(d);\n\tbtf_dump_type_values(d, \"]\");\n\n\treturn 0;\n}\n\nstatic int btf_dump_struct_data(struct btf_dump *d,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\t__u32 id,\n\t\t\t\tconst void *data)\n{\n\tconst struct btf_member *m = btf_members(t);\n\t__u16 n = btf_vlen(t);\n\tint i, err = 0;\n\n\t \n\td->typed_dump->depth++;\n\tbtf_dump_printf(d, \"{%s\", btf_dump_data_newline(d));\n\n\tfor (i = 0; i < n; i++, m++) {\n\t\tconst struct btf_type *mtype;\n\t\tconst char *mname;\n\t\t__u32 moffset;\n\t\t__u8 bit_sz;\n\n\t\tmtype = btf__type_by_id(d->btf, m->type);\n\t\tmname = btf_name_of(d, m->name_off);\n\t\tmoffset = btf_member_bit_offset(t, i);\n\n\t\tbit_sz = btf_member_bitfield_size(t, i);\n\t\terr = btf_dump_dump_type_data(d, mname, mtype, m->type, data + moffset / 8,\n\t\t\t\t\t      moffset % 8, bit_sz);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\td->typed_dump->depth--;\n\tbtf_dump_data_pfx(d);\n\tbtf_dump_type_values(d, \"}\");\n\treturn err;\n}\n\nunion ptr_data {\n\tunsigned int p;\n\tunsigned long long lp;\n};\n\nstatic int btf_dump_ptr_data(struct btf_dump *d,\n\t\t\t      const struct btf_type *t,\n\t\t\t      __u32 id,\n\t\t\t      const void *data)\n{\n\tif (ptr_is_aligned(d->btf, id, data) && d->ptr_sz == sizeof(void *)) {\n\t\tbtf_dump_type_values(d, \"%p\", *(void **)data);\n\t} else {\n\t\tunion ptr_data pt;\n\n\t\tmemcpy(&pt, data, d->ptr_sz);\n\t\tif (d->ptr_sz == 4)\n\t\t\tbtf_dump_type_values(d, \"0x%x\", pt.p);\n\t\telse\n\t\t\tbtf_dump_type_values(d, \"0x%llx\", pt.lp);\n\t}\n\treturn 0;\n}\n\nstatic int btf_dump_get_enum_value(struct btf_dump *d,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   const void *data,\n\t\t\t\t   __u32 id,\n\t\t\t\t   __s64 *value)\n{\n\tbool is_signed = btf_kflag(t);\n\n\tif (!ptr_is_aligned(d->btf, id, data)) {\n\t\t__u64 val;\n\t\tint err;\n\n\t\terr = btf_dump_get_bitfield_value(d, t, data, 0, 0, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*value = (__s64)val;\n\t\treturn 0;\n\t}\n\n\tswitch (t->size) {\n\tcase 8:\n\t\t*value = *(__s64 *)data;\n\t\treturn 0;\n\tcase 4:\n\t\t*value = is_signed ? (__s64)*(__s32 *)data : *(__u32 *)data;\n\t\treturn 0;\n\tcase 2:\n\t\t*value = is_signed ? *(__s16 *)data : *(__u16 *)data;\n\t\treturn 0;\n\tcase 1:\n\t\t*value = is_signed ? *(__s8 *)data : *(__u8 *)data;\n\t\treturn 0;\n\tdefault:\n\t\tpr_warn(\"unexpected size %d for enum, id:[%u]\\n\", t->size, id);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int btf_dump_enum_data(struct btf_dump *d,\n\t\t\t      const struct btf_type *t,\n\t\t\t      __u32 id,\n\t\t\t      const void *data)\n{\n\tbool is_signed;\n\t__s64 value;\n\tint i, err;\n\n\terr = btf_dump_get_enum_value(d, t, data, id, &value);\n\tif (err)\n\t\treturn err;\n\n\tis_signed = btf_kflag(t);\n\tif (btf_is_enum(t)) {\n\t\tconst struct btf_enum *e;\n\n\t\tfor (i = 0, e = btf_enum(t); i < btf_vlen(t); i++, e++) {\n\t\t\tif (value != e->val)\n\t\t\t\tcontinue;\n\t\t\tbtf_dump_type_values(d, \"%s\", btf_name_of(d, e->name_off));\n\t\t\treturn 0;\n\t\t}\n\n\t\tbtf_dump_type_values(d, is_signed ? \"%d\" : \"%u\", value);\n\t} else {\n\t\tconst struct btf_enum64 *e;\n\n\t\tfor (i = 0, e = btf_enum64(t); i < btf_vlen(t); i++, e++) {\n\t\t\tif (value != btf_enum64_value(e))\n\t\t\t\tcontinue;\n\t\t\tbtf_dump_type_values(d, \"%s\", btf_name_of(d, e->name_off));\n\t\t\treturn 0;\n\t\t}\n\n\t\tbtf_dump_type_values(d, is_signed ? \"%lldLL\" : \"%lluULL\",\n\t\t\t\t     (unsigned long long)value);\n\t}\n\treturn 0;\n}\n\nstatic int btf_dump_datasec_data(struct btf_dump *d,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t __u32 id,\n\t\t\t\t const void *data)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tconst struct btf_type *var;\n\t__u32 i;\n\tint err;\n\n\tbtf_dump_type_values(d, \"SEC(\\\"%s\\\") \", btf_name_of(d, t->name_off));\n\n\tfor (i = 0, vsi = btf_var_secinfos(t); i < btf_vlen(t); i++, vsi++) {\n\t\tvar = btf__type_by_id(d->btf, vsi->type);\n\t\terr = btf_dump_dump_type_data(d, NULL, var, vsi->type, data + vsi->offset, 0, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbtf_dump_printf(d, \";\");\n\t}\n\treturn 0;\n}\n\n \nstatic int btf_dump_type_data_check_overflow(struct btf_dump *d,\n\t\t\t\t\t     const struct btf_type *t,\n\t\t\t\t\t     __u32 id,\n\t\t\t\t\t     const void *data,\n\t\t\t\t\t     __u8 bits_offset,\n\t\t\t\t\t     __u8 bit_sz)\n{\n\t__s64 size;\n\n\tif (bit_sz) {\n\t\t \n\t\t__u8 nr_bytes = (bits_offset + bit_sz + 7) / 8;\n\n\t\t \n\t\treturn data + nr_bytes > d->typed_dump->data_end ? -E2BIG : nr_bytes;\n\t}\n\n\tsize = btf__resolve_size(d->btf, id);\n\n\tif (size < 0 || size >= INT_MAX) {\n\t\tpr_warn(\"unexpected size [%zu] for id [%u]\\n\",\n\t\t\t(size_t)size, id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tt = skip_mods_and_typedefs(d->btf, id, NULL);\n\tif (!t) {\n\t\tpr_warn(\"unexpected error skipping mods/typedefs for id [%u]\\n\",\n\t\t\tid);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\tif (data + bits_offset / 8 + size > d->typed_dump->data_end)\n\t\t\treturn -E2BIG;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (int)size;\n}\n\nstatic int btf_dump_type_data_check_zero(struct btf_dump *d,\n\t\t\t\t\t const struct btf_type *t,\n\t\t\t\t\t __u32 id,\n\t\t\t\t\t const void *data,\n\t\t\t\t\t __u8 bits_offset,\n\t\t\t\t\t __u8 bit_sz)\n{\n\t__s64 value;\n\tint i, err;\n\n\t \n\tif (d->typed_dump->emit_zeroes || d->typed_dump->depth == 0 ||\n\t    (d->typed_dump->is_array_member &&\n\t     !d->typed_dump->is_array_char))\n\t\treturn 0;\n\n\tt = skip_mods_and_typedefs(d->btf, id, NULL);\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_INT:\n\t\tif (bit_sz)\n\t\t\treturn btf_dump_bitfield_check_zero(d, t, data, bits_offset, bit_sz);\n\t\treturn btf_dump_base_type_check_zero(d, t, id, data);\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_PTR:\n\t\treturn btf_dump_base_type_check_zero(d, t, id, data);\n\tcase BTF_KIND_ARRAY: {\n\t\tconst struct btf_array *array = btf_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\t__u32 elem_type_id, elem_size;\n\t\tbool ischar;\n\n\t\telem_type_id = array->type;\n\t\telem_size = btf__resolve_size(d->btf, elem_type_id);\n\t\telem_type = skip_mods_and_typedefs(d->btf, elem_type_id, NULL);\n\n\t\tischar = btf_is_int(elem_type) && elem_size == 1;\n\n\t\t \n\t\tfor (i = 0; i < array->nelems; i++) {\n\t\t\tif (i == 0 && ischar && *(char *)data == 0)\n\t\t\t\treturn -ENODATA;\n\t\t\terr = btf_dump_type_data_check_zero(d, elem_type,\n\t\t\t\t\t\t\t    elem_type_id,\n\t\t\t\t\t\t\t    data +\n\t\t\t\t\t\t\t    (i * elem_size),\n\t\t\t\t\t\t\t    bits_offset, 0);\n\t\t\tif (err != -ENODATA)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn -ENODATA;\n\t}\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m = btf_members(t);\n\t\t__u16 n = btf_vlen(t);\n\n\t\t \n\t\tfor (i = 0; i < n; i++, m++) {\n\t\t\tconst struct btf_type *mtype;\n\t\t\t__u32 moffset;\n\n\t\t\tmtype = btf__type_by_id(d->btf, m->type);\n\t\t\tmoffset = btf_member_bit_offset(t, i);\n\n\t\t\t \n\t\t\tbit_sz = btf_member_bitfield_size(t, i);\n\t\t\terr = btf_dump_type_data_check_zero(d, mtype, m->type, data + moffset / 8,\n\t\t\t\t\t\t\t    moffset % 8, bit_sz);\n\t\t\tif (err != ENODATA)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn -ENODATA;\n\t}\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\terr = btf_dump_get_enum_value(d, t, data, id, &value);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value == 0)\n\t\t\treturn -ENODATA;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int btf_dump_dump_type_data(struct btf_dump *d,\n\t\t\t\t   const char *fname,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   __u32 id,\n\t\t\t\t   const void *data,\n\t\t\t\t   __u8 bits_offset,\n\t\t\t\t   __u8 bit_sz)\n{\n\tint size, err = 0;\n\n\tsize = btf_dump_type_data_check_overflow(d, t, id, data, bits_offset, bit_sz);\n\tif (size < 0)\n\t\treturn size;\n\terr = btf_dump_type_data_check_zero(d, t, id, data, bits_offset, bit_sz);\n\tif (err) {\n\t\t \n\t\tif (err == -ENODATA)\n\t\t\treturn size;\n\t\treturn err;\n\t}\n\tbtf_dump_data_pfx(d);\n\n\tif (!d->typed_dump->skip_names) {\n\t\tif (fname && strlen(fname) > 0)\n\t\t\tbtf_dump_printf(d, \".%s = \", fname);\n\t\tbtf_dump_emit_type_cast(d, id, true);\n\t}\n\n\tt = skip_mods_and_typedefs(d->btf, id, NULL);\n\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_UNKN:\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_FUNC_PROTO:\n\tcase BTF_KIND_DECL_TAG:\n\t\terr = btf_dump_unsupported_data(d, t, id);\n\t\tbreak;\n\tcase BTF_KIND_INT:\n\t\tif (bit_sz)\n\t\t\terr = btf_dump_bitfield_data(d, t, data, bits_offset, bit_sz);\n\t\telse\n\t\t\terr = btf_dump_int_data(d, t, id, data, bits_offset);\n\t\tbreak;\n\tcase BTF_KIND_FLOAT:\n\t\terr = btf_dump_float_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_PTR:\n\t\terr = btf_dump_ptr_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_ARRAY:\n\t\terr = btf_dump_array_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\terr = btf_dump_struct_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\t \n\t\tif (bit_sz) {\n\t\t\t__u64 print_num;\n\t\t\t__s64 enum_val;\n\n\t\t\terr = btf_dump_get_bitfield_value(d, t, data, bits_offset, bit_sz,\n\t\t\t\t\t\t\t  &print_num);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tenum_val = (__s64)print_num;\n\t\t\terr = btf_dump_enum_data(d, t, id, &enum_val);\n\t\t} else\n\t\t\terr = btf_dump_enum_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_VAR:\n\t\terr = btf_dump_var_data(d, t, id, data);\n\t\tbreak;\n\tcase BTF_KIND_DATASEC:\n\t\terr = btf_dump_datasec_data(d, t, id, data);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unexpected kind [%u] for id [%u]\\n\",\n\t\t\tBTF_INFO_KIND(t->info), id);\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\treturn size;\n}\n\nint btf_dump__dump_type_data(struct btf_dump *d, __u32 id,\n\t\t\t     const void *data, size_t data_sz,\n\t\t\t     const struct btf_dump_type_data_opts *opts)\n{\n\tstruct btf_dump_data typed_dump = {};\n\tconst struct btf_type *t;\n\tint ret;\n\n\tif (!OPTS_VALID(opts, btf_dump_type_data_opts))\n\t\treturn libbpf_err(-EINVAL);\n\n\tt = btf__type_by_id(d->btf, id);\n\tif (!t)\n\t\treturn libbpf_err(-ENOENT);\n\n\td->typed_dump = &typed_dump;\n\td->typed_dump->data_end = data + data_sz;\n\td->typed_dump->indent_lvl = OPTS_GET(opts, indent_level, 0);\n\n\t \n\tif (!OPTS_GET(opts, indent_str, NULL))\n\t\td->typed_dump->indent_str[0] = '\\t';\n\telse\n\t\tlibbpf_strlcpy(d->typed_dump->indent_str, opts->indent_str,\n\t\t\t       sizeof(d->typed_dump->indent_str));\n\n\td->typed_dump->compact = OPTS_GET(opts, compact, false);\n\td->typed_dump->skip_names = OPTS_GET(opts, skip_names, false);\n\td->typed_dump->emit_zeroes = OPTS_GET(opts, emit_zeroes, false);\n\n\tret = btf_dump_dump_type_data(d, NULL, t, id, data, 0, 0);\n\n\td->typed_dump = NULL;\n\n\treturn libbpf_err(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}