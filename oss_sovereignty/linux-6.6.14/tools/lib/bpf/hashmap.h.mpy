{
  "module_name": "hashmap.h",
  "hash_id": "9a2834971035ae6d7e473d1cf8be1bc94001cdb3d9d7cf52c9db302e9b171b5c",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/hashmap.h",
  "human_readable_source": " \n\n \n#ifndef __LIBBPF_HASHMAP_H\n#define __LIBBPF_HASHMAP_H\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <limits.h>\n\nstatic inline size_t hash_bits(size_t h, int bits)\n{\n\t \n\tif (bits == 0)\n\t\treturn 0;\n\n#if (__SIZEOF_SIZE_T__ == __SIZEOF_LONG_LONG__)\n\t \n\treturn (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);\n#elif (__SIZEOF_SIZE_T__ <= __SIZEOF_LONG__)\n\treturn (h * 2654435769lu) >> (__SIZEOF_LONG__ * 8 - bits);\n#else\n#\terror \"Unsupported size_t size\"\n#endif\n}\n\n \nstatic inline size_t str_hash(const char *s)\n{\n\tsize_t h = 0;\n\n\twhile (*s) {\n\t\th = h * 31 + *s;\n\t\ts++;\n\t}\n\treturn h;\n}\n\ntypedef size_t (*hashmap_hash_fn)(long key, void *ctx);\ntypedef bool (*hashmap_equal_fn)(long key1, long key2, void *ctx);\n\n \nstruct hashmap_entry {\n\tunion {\n\t\tlong key;\n\t\tconst void *pkey;\n\t};\n\tunion {\n\t\tlong value;\n\t\tvoid *pvalue;\n\t};\n\tstruct hashmap_entry *next;\n};\n\nstruct hashmap {\n\thashmap_hash_fn hash_fn;\n\thashmap_equal_fn equal_fn;\n\tvoid *ctx;\n\n\tstruct hashmap_entry **buckets;\n\tsize_t cap;\n\tsize_t cap_bits;\n\tsize_t sz;\n};\n\nvoid hashmap__init(struct hashmap *map, hashmap_hash_fn hash_fn,\n\t\t   hashmap_equal_fn equal_fn, void *ctx);\nstruct hashmap *hashmap__new(hashmap_hash_fn hash_fn,\n\t\t\t     hashmap_equal_fn equal_fn,\n\t\t\t     void *ctx);\nvoid hashmap__clear(struct hashmap *map);\nvoid hashmap__free(struct hashmap *map);\n\nsize_t hashmap__size(const struct hashmap *map);\nsize_t hashmap__capacity(const struct hashmap *map);\n\n \nenum hashmap_insert_strategy {\n\tHASHMAP_ADD,\n\tHASHMAP_SET,\n\tHASHMAP_UPDATE,\n\tHASHMAP_APPEND,\n};\n\n#define hashmap_cast_ptr(p) ({\t\t\t\t\t\t\t\t\\\n\t_Static_assert((__builtin_constant_p((p)) ? (p) == NULL : 0) ||\t\t\t\\\n\t\t\t\tsizeof(*(p)) == sizeof(long),\t\t\t\t\\\n\t\t       #p \" pointee should be a long-sized integer or a pointer\");\t\\\n\t(long *)(p);\t\t\t\t\t\t\t\t\t\\\n})\n\n \nint hashmap_insert(struct hashmap *map, long key, long value,\n\t\t   enum hashmap_insert_strategy strategy,\n\t\t   long *old_key, long *old_value);\n\n#define hashmap__insert(map, key, value, strategy, old_key, old_value) \\\n\thashmap_insert((map), (long)(key), (long)(value), (strategy),  \\\n\t\t       hashmap_cast_ptr(old_key),\t\t       \\\n\t\t       hashmap_cast_ptr(old_value))\n\n#define hashmap__add(map, key, value) \\\n\thashmap__insert((map), (key), (value), HASHMAP_ADD, NULL, NULL)\n\n#define hashmap__set(map, key, value, old_key, old_value) \\\n\thashmap__insert((map), (key), (value), HASHMAP_SET, (old_key), (old_value))\n\n#define hashmap__update(map, key, value, old_key, old_value) \\\n\thashmap__insert((map), (key), (value), HASHMAP_UPDATE, (old_key), (old_value))\n\n#define hashmap__append(map, key, value) \\\n\thashmap__insert((map), (key), (value), HASHMAP_APPEND, NULL, NULL)\n\nbool hashmap_delete(struct hashmap *map, long key, long *old_key, long *old_value);\n\n#define hashmap__delete(map, key, old_key, old_value)\t\t       \\\n\thashmap_delete((map), (long)(key),\t\t\t       \\\n\t\t       hashmap_cast_ptr(old_key),\t\t       \\\n\t\t       hashmap_cast_ptr(old_value))\n\nbool hashmap_find(const struct hashmap *map, long key, long *value);\n\n#define hashmap__find(map, key, value) \\\n\thashmap_find((map), (long)(key), hashmap_cast_ptr(value))\n\n \n#define hashmap__for_each_entry(map, cur, bkt)\t\t\t\t    \\\n\tfor (bkt = 0; bkt < map->cap; bkt++)\t\t\t\t    \\\n\t\tfor (cur = map->buckets[bkt]; cur; cur = cur->next)\n\n \n#define hashmap__for_each_entry_safe(map, cur, tmp, bkt)\t\t    \\\n\tfor (bkt = 0; bkt < map->cap; bkt++)\t\t\t\t    \\\n\t\tfor (cur = map->buckets[bkt];\t\t\t\t    \\\n\t\t     cur && ({tmp = cur->next; true; });\t\t    \\\n\t\t     cur = tmp)\n\n \n#define hashmap__for_each_key_entry(map, cur, _key)\t\t\t    \\\n\tfor (cur = map->buckets\t\t\t\t\t\t    \\\n\t\t     ? map->buckets[hash_bits(map->hash_fn((_key), map->ctx), map->cap_bits)] \\\n\t\t     : NULL;\t\t\t\t\t\t    \\\n\t     cur;\t\t\t\t\t\t\t    \\\n\t     cur = cur->next)\t\t\t\t\t\t    \\\n\t\tif (map->equal_fn(cur->key, (_key), map->ctx))\n\n#define hashmap__for_each_key_entry_safe(map, cur, tmp, _key)\t\t    \\\n\tfor (cur = map->buckets\t\t\t\t\t\t    \\\n\t\t     ? map->buckets[hash_bits(map->hash_fn((_key), map->ctx), map->cap_bits)] \\\n\t\t     : NULL;\t\t\t\t\t\t    \\\n\t     cur && ({ tmp = cur->next; true; });\t\t\t    \\\n\t     cur = tmp)\t\t\t\t\t\t\t    \\\n\t\tif (map->equal_fn(cur->key, (_key), map->ctx))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}