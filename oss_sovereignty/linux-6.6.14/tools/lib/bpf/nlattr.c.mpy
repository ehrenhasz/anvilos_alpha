{
  "module_name": "nlattr.c",
  "hash_id": "a90bb84cc1316a91c3f58e23c9b8fa12864ff16b836a3fe513f4f0c7f45afa45",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bpf/nlattr.c",
  "human_readable_source": "\n\n \n\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <linux/rtnetlink.h>\n#include \"nlattr.h\"\n#include \"libbpf_internal.h\"\n\nstatic uint16_t nla_attr_minlen[LIBBPF_NLA_TYPE_MAX+1] = {\n\t[LIBBPF_NLA_U8]\t\t= sizeof(uint8_t),\n\t[LIBBPF_NLA_U16]\t= sizeof(uint16_t),\n\t[LIBBPF_NLA_U32]\t= sizeof(uint32_t),\n\t[LIBBPF_NLA_U64]\t= sizeof(uint64_t),\n\t[LIBBPF_NLA_STRING]\t= 1,\n\t[LIBBPF_NLA_FLAG]\t= 0,\n};\n\nstatic struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tint totlen = NLA_ALIGN(nla->nla_len);\n\n\t*remaining -= totlen;\n\treturn (struct nlattr *)((void *)nla + totlen);\n}\n\nstatic int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= (int)sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}\n\nstatic int nla_type(const struct nlattr *nla)\n{\n\treturn nla->nla_type & NLA_TYPE_MASK;\n}\n\nstatic int validate_nla(struct nlattr *nla, int maxtype,\n\t\t\tstruct libbpf_nla_policy *policy)\n{\n\tstruct libbpf_nla_policy *pt;\n\tunsigned int minlen = 0;\n\tint type = nla_type(nla);\n\n\tif (type < 0 || type > maxtype)\n\t\treturn 0;\n\n\tpt = &policy[type];\n\n\tif (pt->type > LIBBPF_NLA_TYPE_MAX)\n\t\treturn 0;\n\n\tif (pt->minlen)\n\t\tminlen = pt->minlen;\n\telse if (pt->type != LIBBPF_NLA_UNSPEC)\n\t\tminlen = nla_attr_minlen[pt->type];\n\n\tif (libbpf_nla_len(nla) < minlen)\n\t\treturn -1;\n\n\tif (pt->maxlen && libbpf_nla_len(nla) > pt->maxlen)\n\t\treturn -1;\n\n\tif (pt->type == LIBBPF_NLA_STRING) {\n\t\tchar *data = libbpf_nla_data(nla);\n\n\t\tif (data[libbpf_nla_len(nla) - 1] != '\\0')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int nlmsg_len(const struct nlmsghdr *nlh)\n{\n\treturn nlh->nlmsg_len - NLMSG_HDRLEN;\n}\n\n \nint libbpf_nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head,\n\t\t     int len, struct libbpf_nla_policy *policy)\n{\n\tstruct nlattr *nla;\n\tint rem, err;\n\n\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\n\tlibbpf_nla_for_each_attr(nla, head, len, rem) {\n\t\tint type = nla_type(nla);\n\n\t\tif (type > maxtype)\n\t\t\tcontinue;\n\n\t\tif (policy) {\n\t\t\terr = validate_nla(nla, maxtype, policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t}\n\n\t\tif (tb[type])\n\t\t\tpr_warn(\"Attribute of type %#x found multiple times in message, \"\n\t\t\t\t\"previous attribute is being ignored.\\n\", type);\n\n\t\ttb[type] = nla;\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\n \nint libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,\n\t\t\t    struct nlattr *nla,\n\t\t\t    struct libbpf_nla_policy *policy)\n{\n\treturn libbpf_nla_parse(tb, maxtype, libbpf_nla_data(nla),\n\t\t\t\tlibbpf_nla_len(nla), policy);\n}\n\n \nint libbpf_nla_dump_errormsg(struct nlmsghdr *nlh)\n{\n\tstruct libbpf_nla_policy extack_policy[NLMSGERR_ATTR_MAX + 1] = {\n\t\t[NLMSGERR_ATTR_MSG]\t= { .type = LIBBPF_NLA_STRING },\n\t\t[NLMSGERR_ATTR_OFFS]\t= { .type = LIBBPF_NLA_U32 },\n\t};\n\tstruct nlattr *tb[NLMSGERR_ATTR_MAX + 1], *attr;\n\tstruct nlmsgerr *err;\n\tchar *errmsg = NULL;\n\tint hlen, alen;\n\n\t \n\tif (!(nlh->nlmsg_flags & NLM_F_ACK_TLVS))\n\t\treturn 0;\n\n\terr = (struct nlmsgerr *)NLMSG_DATA(nlh);\n\thlen = sizeof(*err);\n\n\t \n\tif (!(nlh->nlmsg_flags & NLM_F_CAPPED))\n\t\thlen += nlmsg_len(&err->msg);\n\n\tattr = (struct nlattr *) ((void *) err + hlen);\n\talen = (void *)nlh + nlh->nlmsg_len - (void *)attr;\n\n\tif (libbpf_nla_parse(tb, NLMSGERR_ATTR_MAX, attr, alen,\n\t\t\t     extack_policy) != 0) {\n\t\tpr_warn(\"Failed to parse extended error attributes\\n\");\n\t\treturn 0;\n\t}\n\n\tif (tb[NLMSGERR_ATTR_MSG])\n\t\terrmsg = (char *) libbpf_nla_data(tb[NLMSGERR_ATTR_MSG]);\n\n\tpr_warn(\"Kernel error message: %s\\n\", errmsg);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}