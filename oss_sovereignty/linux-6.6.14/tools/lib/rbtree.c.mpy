{
  "module_name": "rbtree.c",
  "hash_id": "8bcb6715d9ae08a2d031c4e94d15911072369d1ea0649a64a69a8d2b3c1ea03d",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/rbtree.c",
  "human_readable_source": "\n \n\n#include <linux/rbtree_augmented.h>\n#include <linux/export.h>\n\n \n\n \n\nstatic inline void rb_set_black(struct rb_node *rb)\n{\n\trb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red)\n{\n\treturn (struct rb_node *)red->__rb_parent_color;\n}\n\n \nstatic inline void\n__rb_rotate_set_parents(struct rb_node *old, struct rb_node *new,\n\t\t\tstruct rb_root *root, int color)\n{\n\tstruct rb_node *parent = rb_parent(old);\n\tnew->__rb_parent_color = old->__rb_parent_color;\n\trb_set_parent_color(old, new, color);\n\t__rb_change_child(old, new, parent, root);\n}\n\nstatic __always_inline void\n__rb_insert(struct rb_node *node, struct rb_root *root,\n\t    void (*augment_rotate)(struct rb_node *old, struct rb_node *new))\n{\n\tstruct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n\twhile (true) {\n\t\t \n\t\tif (unlikely(!parent)) {\n\t\t\t \n\t\t\trb_set_parent_color(node, NULL, RB_BLACK);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif(rb_is_black(parent))\n\t\t\tbreak;\n\n\t\tgparent = rb_red_parent(parent);\n\n\t\ttmp = gparent->rb_right;\n\t\tif (parent != tmp) {\t \n\t\t\tif (tmp && rb_is_red(tmp)) {\n\t\t\t\t \n\t\t\t\trb_set_parent_color(tmp, gparent, RB_BLACK);\n\t\t\t\trb_set_parent_color(parent, gparent, RB_BLACK);\n\t\t\t\tnode = gparent;\n\t\t\t\tparent = rb_parent(node);\n\t\t\t\trb_set_parent_color(node, parent, RB_RED);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmp = parent->rb_right;\n\t\t\tif (node == tmp) {\n\t\t\t\t \n\t\t\t\ttmp = node->rb_left;\n\t\t\t\tWRITE_ONCE(parent->rb_right, tmp);\n\t\t\t\tWRITE_ONCE(node->rb_left, parent);\n\t\t\t\tif (tmp)\n\t\t\t\t\trb_set_parent_color(tmp, parent,\n\t\t\t\t\t\t\t    RB_BLACK);\n\t\t\t\trb_set_parent_color(parent, node, RB_RED);\n\t\t\t\taugment_rotate(parent, node);\n\t\t\t\tparent = node;\n\t\t\t\ttmp = node->rb_right;\n\t\t\t}\n\n\t\t\t \n\t\t\tWRITE_ONCE(gparent->rb_left, tmp);  \n\t\t\tWRITE_ONCE(parent->rb_right, gparent);\n\t\t\tif (tmp)\n\t\t\t\trb_set_parent_color(tmp, gparent, RB_BLACK);\n\t\t\t__rb_rotate_set_parents(gparent, parent, root, RB_RED);\n\t\t\taugment_rotate(gparent, parent);\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttmp = gparent->rb_left;\n\t\t\tif (tmp && rb_is_red(tmp)) {\n\t\t\t\t \n\t\t\t\trb_set_parent_color(tmp, gparent, RB_BLACK);\n\t\t\t\trb_set_parent_color(parent, gparent, RB_BLACK);\n\t\t\t\tnode = gparent;\n\t\t\t\tparent = rb_parent(node);\n\t\t\t\trb_set_parent_color(node, parent, RB_RED);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmp = parent->rb_left;\n\t\t\tif (node == tmp) {\n\t\t\t\t \n\t\t\t\ttmp = node->rb_right;\n\t\t\t\tWRITE_ONCE(parent->rb_left, tmp);\n\t\t\t\tWRITE_ONCE(node->rb_right, parent);\n\t\t\t\tif (tmp)\n\t\t\t\t\trb_set_parent_color(tmp, parent,\n\t\t\t\t\t\t\t    RB_BLACK);\n\t\t\t\trb_set_parent_color(parent, node, RB_RED);\n\t\t\t\taugment_rotate(parent, node);\n\t\t\t\tparent = node;\n\t\t\t\ttmp = node->rb_left;\n\t\t\t}\n\n\t\t\t \n\t\t\tWRITE_ONCE(gparent->rb_right, tmp);  \n\t\t\tWRITE_ONCE(parent->rb_left, gparent);\n\t\t\tif (tmp)\n\t\t\t\trb_set_parent_color(tmp, gparent, RB_BLACK);\n\t\t\t__rb_rotate_set_parents(gparent, parent, root, RB_RED);\n\t\t\taugment_rotate(gparent, parent);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic __always_inline void\n____rb_erase_color(struct rb_node *parent, struct rb_root *root,\n\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\n{\n\tstruct rb_node *node = NULL, *sibling, *tmp1, *tmp2;\n\n\twhile (true) {\n\t\t \n\t\tsibling = parent->rb_right;\n\t\tif (node != sibling) {\t \n\t\t\tif (rb_is_red(sibling)) {\n\t\t\t\t \n\t\t\t\ttmp1 = sibling->rb_left;\n\t\t\t\tWRITE_ONCE(parent->rb_right, tmp1);\n\t\t\t\tWRITE_ONCE(sibling->rb_left, parent);\n\t\t\t\trb_set_parent_color(tmp1, parent, RB_BLACK);\n\t\t\t\t__rb_rotate_set_parents(parent, sibling, root,\n\t\t\t\t\t\t\tRB_RED);\n\t\t\t\taugment_rotate(parent, sibling);\n\t\t\t\tsibling = tmp1;\n\t\t\t}\n\t\t\ttmp1 = sibling->rb_right;\n\t\t\tif (!tmp1 || rb_is_black(tmp1)) {\n\t\t\t\ttmp2 = sibling->rb_left;\n\t\t\t\tif (!tmp2 || rb_is_black(tmp2)) {\n\t\t\t\t\t \n\t\t\t\t\trb_set_parent_color(sibling, parent,\n\t\t\t\t\t\t\t    RB_RED);\n\t\t\t\t\tif (rb_is_red(parent))\n\t\t\t\t\t\trb_set_black(parent);\n\t\t\t\t\telse {\n\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\tparent = rb_parent(node);\n\t\t\t\t\t\tif (parent)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ttmp1 = tmp2->rb_right;\n\t\t\t\tWRITE_ONCE(sibling->rb_left, tmp1);\n\t\t\t\tWRITE_ONCE(tmp2->rb_right, sibling);\n\t\t\t\tWRITE_ONCE(parent->rb_right, tmp2);\n\t\t\t\tif (tmp1)\n\t\t\t\t\trb_set_parent_color(tmp1, sibling,\n\t\t\t\t\t\t\t    RB_BLACK);\n\t\t\t\taugment_rotate(sibling, tmp2);\n\t\t\t\ttmp1 = sibling;\n\t\t\t\tsibling = tmp2;\n\t\t\t}\n\t\t\t \n\t\t\ttmp2 = sibling->rb_left;\n\t\t\tWRITE_ONCE(parent->rb_right, tmp2);\n\t\t\tWRITE_ONCE(sibling->rb_left, parent);\n\t\t\trb_set_parent_color(tmp1, sibling, RB_BLACK);\n\t\t\tif (tmp2)\n\t\t\t\trb_set_parent(tmp2, parent);\n\t\t\t__rb_rotate_set_parents(parent, sibling, root,\n\t\t\t\t\t\tRB_BLACK);\n\t\t\taugment_rotate(parent, sibling);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tsibling = parent->rb_left;\n\t\t\tif (rb_is_red(sibling)) {\n\t\t\t\t \n\t\t\t\ttmp1 = sibling->rb_right;\n\t\t\t\tWRITE_ONCE(parent->rb_left, tmp1);\n\t\t\t\tWRITE_ONCE(sibling->rb_right, parent);\n\t\t\t\trb_set_parent_color(tmp1, parent, RB_BLACK);\n\t\t\t\t__rb_rotate_set_parents(parent, sibling, root,\n\t\t\t\t\t\t\tRB_RED);\n\t\t\t\taugment_rotate(parent, sibling);\n\t\t\t\tsibling = tmp1;\n\t\t\t}\n\t\t\ttmp1 = sibling->rb_left;\n\t\t\tif (!tmp1 || rb_is_black(tmp1)) {\n\t\t\t\ttmp2 = sibling->rb_right;\n\t\t\t\tif (!tmp2 || rb_is_black(tmp2)) {\n\t\t\t\t\t \n\t\t\t\t\trb_set_parent_color(sibling, parent,\n\t\t\t\t\t\t\t    RB_RED);\n\t\t\t\t\tif (rb_is_red(parent))\n\t\t\t\t\t\trb_set_black(parent);\n\t\t\t\t\telse {\n\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\tparent = rb_parent(node);\n\t\t\t\t\t\tif (parent)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ttmp1 = tmp2->rb_left;\n\t\t\t\tWRITE_ONCE(sibling->rb_right, tmp1);\n\t\t\t\tWRITE_ONCE(tmp2->rb_left, sibling);\n\t\t\t\tWRITE_ONCE(parent->rb_left, tmp2);\n\t\t\t\tif (tmp1)\n\t\t\t\t\trb_set_parent_color(tmp1, sibling,\n\t\t\t\t\t\t\t    RB_BLACK);\n\t\t\t\taugment_rotate(sibling, tmp2);\n\t\t\t\ttmp1 = sibling;\n\t\t\t\tsibling = tmp2;\n\t\t\t}\n\t\t\t \n\t\t\ttmp2 = sibling->rb_right;\n\t\t\tWRITE_ONCE(parent->rb_left, tmp2);\n\t\t\tWRITE_ONCE(sibling->rb_right, parent);\n\t\t\trb_set_parent_color(tmp1, sibling, RB_BLACK);\n\t\t\tif (tmp2)\n\t\t\t\trb_set_parent(tmp2, parent);\n\t\t\t__rb_rotate_set_parents(parent, sibling, root,\n\t\t\t\t\t\tRB_BLACK);\n\t\t\taugment_rotate(parent, sibling);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid __rb_erase_color(struct rb_node *parent, struct rb_root *root,\n\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\n{\n\t____rb_erase_color(parent, root, augment_rotate);\n}\n\n \n\nstatic inline void dummy_propagate(struct rb_node *node, struct rb_node *stop) {}\nstatic inline void dummy_copy(struct rb_node *old, struct rb_node *new) {}\nstatic inline void dummy_rotate(struct rb_node *old, struct rb_node *new) {}\n\nstatic const struct rb_augment_callbacks dummy_callbacks = {\n\t.propagate = dummy_propagate,\n\t.copy = dummy_copy,\n\t.rotate = dummy_rotate\n};\n\nvoid rb_insert_color(struct rb_node *node, struct rb_root *root)\n{\n\t__rb_insert(node, root, dummy_rotate);\n}\n\nvoid rb_erase(struct rb_node *node, struct rb_root *root)\n{\n\tstruct rb_node *rebalance;\n\trebalance = __rb_erase_augmented(node, root, &dummy_callbacks);\n\tif (rebalance)\n\t\t____rb_erase_color(rebalance, root, dummy_rotate);\n}\n\n \n\nvoid __rb_insert_augmented(struct rb_node *node, struct rb_root *root,\n\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\n{\n\t__rb_insert(node, root, augment_rotate);\n}\n\n \nstruct rb_node *rb_first(const struct rb_root *root)\n{\n\tstruct rb_node\t*n;\n\n\tn = root->rb_node;\n\tif (!n)\n\t\treturn NULL;\n\twhile (n->rb_left)\n\t\tn = n->rb_left;\n\treturn n;\n}\n\nstruct rb_node *rb_last(const struct rb_root *root)\n{\n\tstruct rb_node\t*n;\n\n\tn = root->rb_node;\n\tif (!n)\n\t\treturn NULL;\n\twhile (n->rb_right)\n\t\tn = n->rb_right;\n\treturn n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node)\n{\n\tstruct rb_node *parent;\n\n\tif (RB_EMPTY_NODE(node))\n\t\treturn NULL;\n\n\t \n\tif (node->rb_right) {\n\t\tnode = node->rb_right;\n\t\twhile (node->rb_left)\n\t\t\tnode = node->rb_left;\n\t\treturn (struct rb_node *)node;\n\t}\n\n\t \n\twhile ((parent = rb_parent(node)) && node == parent->rb_right)\n\t\tnode = parent;\n\n\treturn parent;\n}\n\nstruct rb_node *rb_prev(const struct rb_node *node)\n{\n\tstruct rb_node *parent;\n\n\tif (RB_EMPTY_NODE(node))\n\t\treturn NULL;\n\n\t \n\tif (node->rb_left) {\n\t\tnode = node->rb_left;\n\t\twhile (node->rb_right)\n\t\t\tnode = node->rb_right;\n\t\treturn (struct rb_node *)node;\n\t}\n\n\t \n\twhile ((parent = rb_parent(node)) && node == parent->rb_left)\n\t\tnode = parent;\n\n\treturn parent;\n}\n\nvoid rb_replace_node(struct rb_node *victim, struct rb_node *new,\n\t\t     struct rb_root *root)\n{\n\tstruct rb_node *parent = rb_parent(victim);\n\n\t \n\t*new = *victim;\n\n\t \n\tif (victim->rb_left)\n\t\trb_set_parent(victim->rb_left, new);\n\tif (victim->rb_right)\n\t\trb_set_parent(victim->rb_right, new);\n\t__rb_change_child(victim, new, parent, root);\n}\n\nstatic struct rb_node *rb_left_deepest_node(const struct rb_node *node)\n{\n\tfor (;;) {\n\t\tif (node->rb_left)\n\t\t\tnode = node->rb_left;\n\t\telse if (node->rb_right)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn (struct rb_node *)node;\n\t}\n}\n\nstruct rb_node *rb_next_postorder(const struct rb_node *node)\n{\n\tconst struct rb_node *parent;\n\tif (!node)\n\t\treturn NULL;\n\tparent = rb_parent(node);\n\n\t \n\tif (parent && node == parent->rb_left && parent->rb_right) {\n\t\t \n\t\treturn rb_left_deepest_node(parent->rb_right);\n\t} else\n\t\t \n\t\treturn (struct rb_node *)parent;\n}\n\nstruct rb_node *rb_first_postorder(const struct rb_root *root)\n{\n\tif (!root->rb_node)\n\t\treturn NULL;\n\n\treturn rb_left_deepest_node(root->rb_node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}