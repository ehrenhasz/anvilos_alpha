{
  "module_name": "help.c",
  "hash_id": "4da604815df1c00e35b13e3c723ce0d0373927d8216592687aadf1770451e6de",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/subcmd/help.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/string.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include \"subcmd-util.h\"\n#include \"help.h\"\n#include \"exec-cmd.h\"\n\nvoid add_cmdname(struct cmdnames *cmds, const char *name, size_t len)\n{\n\tstruct cmdname *ent = malloc(sizeof(*ent) + len + 1);\n\tif (!ent)\n\t\treturn;\n\n\tent->len = len;\n\tmemcpy(ent->name, name, len);\n\tent->name[len] = 0;\n\n\tALLOC_GROW(cmds->names, cmds->cnt + 1, cmds->alloc);\n\tcmds->names[cmds->cnt++] = ent;\n}\n\nvoid clean_cmdnames(struct cmdnames *cmds)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < cmds->cnt; ++i)\n\t\tzfree(&cmds->names[i]);\n\tzfree(&cmds->names);\n\tcmds->cnt = 0;\n\tcmds->alloc = 0;\n}\n\nint cmdname_compare(const void *a_, const void *b_)\n{\n\tstruct cmdname *a = *(struct cmdname **)a_;\n\tstruct cmdname *b = *(struct cmdname **)b_;\n\treturn strcmp(a->name, b->name);\n}\n\nvoid uniq(struct cmdnames *cmds)\n{\n\tunsigned int i, j;\n\n\tif (!cmds->cnt)\n\t\treturn;\n\n\tfor (i = j = 1; i < cmds->cnt; i++)\n\t\tif (strcmp(cmds->names[i]->name, cmds->names[i-1]->name))\n\t\t\tcmds->names[j++] = cmds->names[i];\n\n\tcmds->cnt = j;\n}\n\nvoid exclude_cmds(struct cmdnames *cmds, struct cmdnames *excludes)\n{\n\tsize_t ci, cj, ei;\n\tint cmp;\n\n\tci = cj = ei = 0;\n\twhile (ci < cmds->cnt && ei < excludes->cnt) {\n\t\tcmp = strcmp(cmds->names[ci]->name, excludes->names[ei]->name);\n\t\tif (cmp < 0) {\n\t\t\tif (ci == cj) {\n\t\t\t\tci++;\n\t\t\t\tcj++;\n\t\t\t} else {\n\t\t\t\tzfree(&cmds->names[cj]);\n\t\t\t\tcmds->names[cj++] = cmds->names[ci++];\n\t\t\t}\n\t\t} else if (cmp == 0) {\n\t\t\tci++;\n\t\t\tei++;\n\t\t} else if (cmp > 0) {\n\t\t\tei++;\n\t\t}\n\t}\n\tif (ci != cj) {\n\t\twhile (ci < cmds->cnt) {\n\t\t\tzfree(&cmds->names[cj]);\n\t\t\tcmds->names[cj++] = cmds->names[ci++];\n\t\t}\n\t}\n\tfor (ci = cj; ci < cmds->cnt; ci++)\n\t\tzfree(&cmds->names[ci]);\n\tcmds->cnt = cj;\n}\n\nstatic void get_term_dimensions(struct winsize *ws)\n{\n\tchar *s = getenv(\"LINES\");\n\n\tif (s != NULL) {\n\t\tws->ws_row = atoi(s);\n\t\ts = getenv(\"COLUMNS\");\n\t\tif (s != NULL) {\n\t\t\tws->ws_col = atoi(s);\n\t\t\tif (ws->ws_row && ws->ws_col)\n\t\t\t\treturn;\n\t\t}\n\t}\n#ifdef TIOCGWINSZ\n\tif (ioctl(1, TIOCGWINSZ, ws) == 0 &&\n\t    ws->ws_row && ws->ws_col)\n\t\treturn;\n#endif\n\tws->ws_row = 25;\n\tws->ws_col = 80;\n}\n\nstatic void pretty_print_string_list(struct cmdnames *cmds, int longest)\n{\n\tint cols = 1, rows;\n\tint space = longest + 1;  \n\tstruct winsize win;\n\tint max_cols;\n\tint i, j;\n\n\tget_term_dimensions(&win);\n\tmax_cols = win.ws_col - 1;  \n\n\tif (space < max_cols)\n\t\tcols = max_cols / space;\n\trows = (cmds->cnt + cols - 1) / cols;\n\n\tfor (i = 0; i < rows; i++) {\n\t\tprintf(\"  \");\n\n\t\tfor (j = 0; j < cols; j++) {\n\t\t\tunsigned int n = j * rows + i;\n\t\t\tunsigned int size = space;\n\n\t\t\tif (n >= cmds->cnt)\n\t\t\t\tbreak;\n\t\t\tif (j == cols-1 || n + rows >= cmds->cnt)\n\t\t\t\tsize = 1;\n\t\t\tprintf(\"%-*s\", size, cmds->names[n]->name);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n\nstatic int is_executable(const char *name)\n{\n\tstruct stat st;\n\n\tif (stat(name, &st) ||  \n\t    !S_ISREG(st.st_mode))\n\t\treturn 0;\n\n\treturn st.st_mode & S_IXUSR;\n}\n\nstatic int has_extension(const char *filename, const char *ext)\n{\n\tsize_t len = strlen(filename);\n\tsize_t extlen = strlen(ext);\n\n\treturn len > extlen && !memcmp(filename + len - extlen, ext, extlen);\n}\n\nstatic void list_commands_in_dir(struct cmdnames *cmds,\n\t\t\t\t\t const char *path,\n\t\t\t\t\t const char *prefix)\n{\n\tint prefix_len;\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\tchar *buf = NULL;\n\n\tif (!dir)\n\t\treturn;\n\tif (!prefix)\n\t\tprefix = \"perf-\";\n\tprefix_len = strlen(prefix);\n\n\tastrcatf(&buf, \"%s/\", path);\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tint entlen;\n\n\t\tif (!strstarts(de->d_name, prefix))\n\t\t\tcontinue;\n\n\t\tastrcat(&buf, de->d_name);\n\t\tif (!is_executable(buf))\n\t\t\tcontinue;\n\n\t\tentlen = strlen(de->d_name) - prefix_len;\n\t\tif (has_extension(de->d_name, \".exe\"))\n\t\t\tentlen -= 4;\n\n\t\tadd_cmdname(cmds, de->d_name + prefix_len, entlen);\n\t}\n\tclosedir(dir);\n\tfree(buf);\n}\n\nvoid load_command_list(const char *prefix,\n\t\tstruct cmdnames *main_cmds,\n\t\tstruct cmdnames *other_cmds)\n{\n\tconst char *env_path = getenv(\"PATH\");\n\tchar *exec_path = get_argv_exec_path();\n\n\tif (exec_path) {\n\t\tlist_commands_in_dir(main_cmds, exec_path, prefix);\n\t\tqsort(main_cmds->names, main_cmds->cnt,\n\t\t      sizeof(*main_cmds->names), cmdname_compare);\n\t\tuniq(main_cmds);\n\t}\n\n\tif (env_path) {\n\t\tchar *paths, *path, *colon;\n\t\tpath = paths = strdup(env_path);\n\t\twhile (1) {\n\t\t\tif ((colon = strchr(path, ':')))\n\t\t\t\t*colon = 0;\n\t\t\tif (!exec_path || strcmp(path, exec_path))\n\t\t\t\tlist_commands_in_dir(other_cmds, path, prefix);\n\n\t\t\tif (!colon)\n\t\t\t\tbreak;\n\t\t\tpath = colon + 1;\n\t\t}\n\t\tfree(paths);\n\n\t\tqsort(other_cmds->names, other_cmds->cnt,\n\t\t      sizeof(*other_cmds->names), cmdname_compare);\n\t\tuniq(other_cmds);\n\t}\n\tfree(exec_path);\n\texclude_cmds(other_cmds, main_cmds);\n}\n\nvoid list_commands(const char *title, struct cmdnames *main_cmds,\n\t\t   struct cmdnames *other_cmds)\n{\n\tunsigned int i, longest = 0;\n\n\tfor (i = 0; i < main_cmds->cnt; i++)\n\t\tif (longest < main_cmds->names[i]->len)\n\t\t\tlongest = main_cmds->names[i]->len;\n\tfor (i = 0; i < other_cmds->cnt; i++)\n\t\tif (longest < other_cmds->names[i]->len)\n\t\t\tlongest = other_cmds->names[i]->len;\n\n\tif (main_cmds->cnt) {\n\t\tchar *exec_path = get_argv_exec_path();\n\t\tprintf(\"available %s in '%s'\\n\", title, exec_path);\n\t\tprintf(\"----------------\");\n\t\tmput_char('-', strlen(title) + strlen(exec_path));\n\t\tputchar('\\n');\n\t\tpretty_print_string_list(main_cmds, longest);\n\t\tputchar('\\n');\n\t\tfree(exec_path);\n\t}\n\n\tif (other_cmds->cnt) {\n\t\tprintf(\"%s available from elsewhere on your $PATH\\n\", title);\n\t\tprintf(\"---------------------------------------\");\n\t\tmput_char('-', strlen(title));\n\t\tputchar('\\n');\n\t\tpretty_print_string_list(other_cmds, longest);\n\t\tputchar('\\n');\n\t}\n}\n\nint is_in_cmdlist(struct cmdnames *c, const char *s)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < c->cnt; i++)\n\t\tif (!strcmp(s, c->names[i]->name))\n\t\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}