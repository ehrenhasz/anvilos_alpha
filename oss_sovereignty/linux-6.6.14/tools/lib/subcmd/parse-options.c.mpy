{
  "module_name": "parse-options.c",
  "hash_id": "f2c1eaabe5665e470b359b06c852184e0cdd2034693c29c0d40bc4e4eb2b834f",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/subcmd/parse-options.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <ctype.h>\n#include \"subcmd-util.h\"\n#include \"parse-options.h\"\n#include \"subcmd-config.h\"\n#include \"pager.h\"\n\n#define OPT_SHORT 1\n#define OPT_UNSET 2\n\nchar *error_buf;\n\nstatic int opterror(const struct option *opt, const char *reason, int flags)\n{\n\tif (flags & OPT_SHORT)\n\t\tfprintf(stderr, \" Error: switch `%c' %s\", opt->short_name, reason);\n\telse if (flags & OPT_UNSET)\n\t\tfprintf(stderr, \" Error: option `no-%s' %s\", opt->long_name, reason);\n\telse\n\t\tfprintf(stderr, \" Error: option `%s' %s\", opt->long_name, reason);\n\n\treturn -1;\n}\n\nstatic const char *skip_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\nstatic void optwarning(const struct option *opt, const char *reason, int flags)\n{\n\tif (flags & OPT_SHORT)\n\t\tfprintf(stderr, \" Warning: switch `%c' %s\", opt->short_name, reason);\n\telse if (flags & OPT_UNSET)\n\t\tfprintf(stderr, \" Warning: option `no-%s' %s\", opt->long_name, reason);\n\telse\n\t\tfprintf(stderr, \" Warning: option `%s' %s\", opt->long_name, reason);\n}\n\nstatic int get_arg(struct parse_opt_ctx_t *p, const struct option *opt,\n\t\t   int flags, const char **arg)\n{\n\tconst char *res;\n\n\tif (p->opt) {\n\t\tres = p->opt;\n\t\tp->opt = NULL;\n\t} else if ((opt->flags & PARSE_OPT_LASTARG_DEFAULT) && (p->argc == 1 ||\n\t\t    **(p->argv + 1) == '-')) {\n\t\tres = (const char *)opt->defval;\n\t} else if (p->argc > 1) {\n\t\tp->argc--;\n\t\tres = *++p->argv;\n\t} else\n\t\treturn opterror(opt, \"requires a value\", flags);\n\tif (arg)\n\t\t*arg = res;\n\treturn 0;\n}\n\nstatic int get_value(struct parse_opt_ctx_t *p,\n\t\t     const struct option *opt, int flags)\n{\n\tconst char *s, *arg = NULL;\n\tconst int unset = flags & OPT_UNSET;\n\tint err;\n\n\tif (unset && p->opt)\n\t\treturn opterror(opt, \"takes no value\", flags);\n\tif (unset && (opt->flags & PARSE_OPT_NONEG))\n\t\treturn opterror(opt, \"isn't available\", flags);\n\tif (opt->flags & PARSE_OPT_DISABLED)\n\t\treturn opterror(opt, \"is not usable\", flags);\n\n\tif (opt->flags & PARSE_OPT_EXCLUSIVE) {\n\t\tif (p->excl_opt && p->excl_opt != opt) {\n\t\t\tchar msg[128];\n\n\t\t\tif (((flags & OPT_SHORT) && p->excl_opt->short_name) ||\n\t\t\t    p->excl_opt->long_name == NULL) {\n\t\t\t\tsnprintf(msg, sizeof(msg), \"cannot be used with switch `%c'\",\n\t\t\t\t\t p->excl_opt->short_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(msg, sizeof(msg), \"cannot be used with %s\",\n\t\t\t\t\t p->excl_opt->long_name);\n\t\t\t}\n\t\t\topterror(opt, msg, flags);\n\t\t\treturn -3;\n\t\t}\n\t\tp->excl_opt = opt;\n\t}\n\tif (!(flags & OPT_SHORT) && p->opt) {\n\t\tswitch (opt->type) {\n\t\tcase OPTION_CALLBACK:\n\t\t\tif (!(opt->flags & PARSE_OPT_NOARG))\n\t\t\t\tbreak;\n\t\t\t \n\t\tcase OPTION_BOOLEAN:\n\t\tcase OPTION_INCR:\n\t\tcase OPTION_BIT:\n\t\tcase OPTION_SET_UINT:\n\t\tcase OPTION_SET_PTR:\n\t\t\treturn opterror(opt, \"takes no value\", flags);\n\t\tcase OPTION_END:\n\t\tcase OPTION_ARGUMENT:\n\t\tcase OPTION_GROUP:\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_INTEGER:\n\t\tcase OPTION_UINTEGER:\n\t\tcase OPTION_LONG:\n\t\tcase OPTION_ULONG:\n\t\tcase OPTION_U64:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt->flags & PARSE_OPT_NOBUILD) {\n\t\tchar reason[128];\n\t\tbool noarg = false;\n\n\t\terr = snprintf(reason, sizeof(reason),\n\t\t\t\topt->flags & PARSE_OPT_CANSKIP ?\n\t\t\t\t\t\"is being ignored because %s \" :\n\t\t\t\t\t\"is not available because %s\",\n\t\t\t\topt->build_opt);\n\t\treason[sizeof(reason) - 1] = '\\0';\n\n\t\tif (err < 0)\n\t\t\tstrncpy(reason, opt->flags & PARSE_OPT_CANSKIP ?\n\t\t\t\t\t\"is being ignored\" :\n\t\t\t\t\t\"is not available\",\n\t\t\t\t\tsizeof(reason));\n\n\t\tif (!(opt->flags & PARSE_OPT_CANSKIP))\n\t\t\treturn opterror(opt, reason, flags);\n\n\t\terr = 0;\n\t\tif (unset)\n\t\t\tnoarg = true;\n\t\tif (opt->flags & PARSE_OPT_NOARG)\n\t\t\tnoarg = true;\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\tnoarg = true;\n\n\t\tswitch (opt->type) {\n\t\tcase OPTION_BOOLEAN:\n\t\tcase OPTION_INCR:\n\t\tcase OPTION_BIT:\n\t\tcase OPTION_SET_UINT:\n\t\tcase OPTION_SET_PTR:\n\t\tcase OPTION_END:\n\t\tcase OPTION_ARGUMENT:\n\t\tcase OPTION_GROUP:\n\t\t\tnoarg = true;\n\t\t\tbreak;\n\t\tcase OPTION_CALLBACK:\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_INTEGER:\n\t\tcase OPTION_UINTEGER:\n\t\tcase OPTION_LONG:\n\t\tcase OPTION_ULONG:\n\t\tcase OPTION_U64:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!noarg)\n\t\t\terr = get_arg(p, opt, flags, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\toptwarning(opt, reason, flags);\n\t\treturn 0;\n\t}\n\n\tswitch (opt->type) {\n\tcase OPTION_BIT:\n\t\tif (unset)\n\t\t\t*(int *)opt->value &= ~opt->defval;\n\t\telse\n\t\t\t*(int *)opt->value |= opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_BOOLEAN:\n\t\t*(bool *)opt->value = unset ? false : true;\n\t\tif (opt->set)\n\t\t\t*(bool *)opt->set = true;\n\t\treturn 0;\n\n\tcase OPTION_INCR:\n\t\t*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;\n\t\treturn 0;\n\n\tcase OPTION_SET_UINT:\n\t\t*(unsigned int *)opt->value = unset ? 0 : opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_SET_PTR:\n\t\t*(void **)opt->value = unset ? NULL : (void *)opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_STRING:\n\t\terr = 0;\n\t\tif (unset)\n\t\t\t*(const char **)opt->value = NULL;\n\t\telse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\t*(const char **)opt->value = (const char *)opt->defval;\n\t\telse\n\t\t\terr = get_arg(p, opt, flags, (const char **)opt->value);\n\n\t\tif (opt->set)\n\t\t\t*(bool *)opt->set = true;\n\n\t\t \n\t\tif (opt->flags & PARSE_OPT_NOEMPTY) {\n\t\t\tconst char *val = *(const char **)opt->value;\n\n\t\t\tif (!val)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (val[0] == '\\0') {\n\t\t\t\t*(const char **)opt->value = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\treturn err;\n\n\tcase OPTION_CALLBACK:\n\t\tif (opt->set)\n\t\t\t*(bool *)opt->set = true;\n\n\t\tif (unset)\n\t\t\treturn (*opt->callback)(opt, NULL, 1) ? (-1) : 0;\n\t\tif (opt->flags & PARSE_OPT_NOARG)\n\t\t\treturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\treturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\treturn (*opt->callback)(opt, arg, 0) ? (-1) : 0;\n\n\tcase OPTION_INTEGER:\n\t\tif (unset) {\n\t\t\t*(int *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(int *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\t*(int *)opt->value = strtol(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tcase OPTION_UINTEGER:\n\t\tif (unset) {\n\t\t\t*(unsigned int *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(unsigned int *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\tif (arg[0] == '-')\n\t\t\treturn opterror(opt, \"expects an unsigned numerical value\", flags);\n\t\t*(unsigned int *)opt->value = strtol(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tcase OPTION_LONG:\n\t\tif (unset) {\n\t\t\t*(long *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(long *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\t*(long *)opt->value = strtol(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tcase OPTION_ULONG:\n\t\tif (unset) {\n\t\t\t*(unsigned long *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(unsigned long *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\t*(unsigned long *)opt->value = strtoul(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tcase OPTION_U64:\n\t\tif (unset) {\n\t\t\t*(u64 *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(u64 *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\tif (arg[0] == '-')\n\t\t\treturn opterror(opt, \"expects an unsigned numerical value\", flags);\n\t\t*(u64 *)opt->value = strtoull(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tcase OPTION_END:\n\tcase OPTION_ARGUMENT:\n\tcase OPTION_GROUP:\n\tdefault:\n\t\tdie(\"should not happen, someone must be hit on the forehead\");\n\t}\n}\n\nstatic int parse_short_opt(struct parse_opt_ctx_t *p, const struct option *options)\n{\nretry:\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (options->short_name == *p->opt) {\n\t\t\tp->opt = p->opt[1] ? p->opt + 1 : NULL;\n\t\t\treturn get_value(p, options, OPT_SHORT);\n\t\t}\n\t}\n\n\tif (options->parent) {\n\t\toptions = options->parent;\n\t\tgoto retry;\n\t}\n\n\treturn -2;\n}\n\nstatic int parse_long_opt(struct parse_opt_ctx_t *p, const char *arg,\n                          const struct option *options)\n{\n\tconst char *arg_end = strchr(arg, '=');\n\tconst struct option *abbrev_option = NULL, *ambiguous_option = NULL;\n\tint abbrev_flags = 0, ambiguous_flags = 0;\n\n\tif (!arg_end)\n\t\targ_end = arg + strlen(arg);\n\nretry:\n\tfor (; options->type != OPTION_END; options++) {\n\t\tconst char *rest;\n\t\tint flags = 0;\n\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\n\t\trest = skip_prefix(arg, options->long_name);\n\t\tif (options->type == OPTION_ARGUMENT) {\n\t\t\tif (!rest)\n\t\t\t\tcontinue;\n\t\t\tif (*rest == '=')\n\t\t\t\treturn opterror(options, \"takes no value\", flags);\n\t\t\tif (*rest)\n\t\t\t\tcontinue;\n\t\t\tp->out[p->cpidx++] = arg - 2;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!rest) {\n\t\t\tif (strstarts(options->long_name, \"no-\")) {\n\t\t\t\t \n\t\t\t\trest = skip_prefix(arg, options->long_name + 3);\n\t\t\t\tif (rest) {\n\t\t\t\t\tflags |= OPT_UNSET;\n\t\t\t\t\tgoto match;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (strstarts(options->long_name + 3, arg)) {\n\t\t\t\t\tflags |= OPT_UNSET;\n\t\t\t\t\tgoto is_abbreviated;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (!strncmp(options->long_name, arg, arg_end - arg)) {\nis_abbreviated:\n\t\t\t\tif (abbrev_option) {\n\t\t\t\t\t \n\t\t\t\t\tambiguous_option = abbrev_option;\n\t\t\t\t\tambiguous_flags = abbrev_flags;\n\t\t\t\t}\n\t\t\t\tif (!(flags & OPT_UNSET) && *arg_end)\n\t\t\t\t\tp->opt = arg_end + 1;\n\t\t\t\tabbrev_option = options;\n\t\t\t\tabbrev_flags = flags;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (strstarts(\"no-\", arg)) {\n\t\t\t\tflags |= OPT_UNSET;\n\t\t\t\tgoto is_abbreviated;\n\t\t\t}\n\t\t\t \n\t\t\tif (strncmp(arg, \"no-\", 3))\n\t\t\t\tcontinue;\n\t\t\tflags |= OPT_UNSET;\n\t\t\trest = skip_prefix(arg + 3, options->long_name);\n\t\t\t \n\t\t\tif (!rest && strstarts(options->long_name, arg + 3))\n\t\t\t\tgoto is_abbreviated;\n\t\t\tif (!rest)\n\t\t\t\tcontinue;\n\t\t}\nmatch:\n\t\tif (*rest) {\n\t\t\tif (*rest != '=')\n\t\t\t\tcontinue;\n\t\t\tp->opt = rest + 1;\n\t\t}\n\t\treturn get_value(p, options, flags);\n\t}\n\n\tif (ambiguous_option) {\n\t\t fprintf(stderr,\n\t\t\t \" Error: Ambiguous option: %s (could be --%s%s or --%s%s)\\n\",\n\t\t\t arg,\n\t\t\t (ambiguous_flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\t ambiguous_option->long_name,\n\t\t\t (abbrev_flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\t abbrev_option->long_name);\n\t\t return -1;\n\t}\n\tif (abbrev_option)\n\t\treturn get_value(p, abbrev_option, abbrev_flags);\n\n\tif (options->parent) {\n\t\toptions = options->parent;\n\t\tgoto retry;\n\t}\n\n\treturn -2;\n}\n\nstatic void check_typos(const char *arg, const struct option *options)\n{\n\tif (strlen(arg) < 3)\n\t\treturn;\n\n\tif (strstarts(arg, \"no-\")) {\n\t\tfprintf(stderr, \" Error: did you mean `--%s` (with two dashes ?)\\n\", arg);\n\t\texit(129);\n\t}\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\t\tif (strstarts(options->long_name, arg)) {\n\t\t\tfprintf(stderr, \" Error: did you mean `--%s` (with two dashes ?)\\n\", arg);\n\t\t\texit(129);\n\t\t}\n\t}\n}\n\nstatic void parse_options_start(struct parse_opt_ctx_t *ctx,\n\t\t\t\tint argc, const char **argv, int flags)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->argc = argc - 1;\n\tctx->argv = argv + 1;\n\tctx->out  = argv;\n\tctx->cpidx = ((flags & PARSE_OPT_KEEP_ARGV0) != 0);\n\tctx->flags = flags;\n\tif ((flags & PARSE_OPT_KEEP_UNKNOWN) &&\n\t    (flags & PARSE_OPT_STOP_AT_NON_OPTION))\n\t\tdie(\"STOP_AT_NON_OPTION and KEEP_UNKNOWN don't go together\");\n}\n\nstatic int usage_with_options_internal(const char * const *,\n\t\t\t\t       const struct option *, int,\n\t\t\t\t       struct parse_opt_ctx_t *);\n\nstatic int parse_options_step(struct parse_opt_ctx_t *ctx,\n\t\t\t      const struct option *options,\n\t\t\t      const char * const usagestr[])\n{\n\tint internal_help = !(ctx->flags & PARSE_OPT_NO_INTERNAL_HELP);\n\tint excl_short_opt = 1;\n\tconst char *arg;\n\n\t \n\tctx->opt = NULL;\n\n\tfor (; ctx->argc; ctx->argc--, ctx->argv++) {\n\t\targ = ctx->argv[0];\n\t\tif (*arg != '-' || !arg[1]) {\n\t\t\tif (ctx->flags & PARSE_OPT_STOP_AT_NON_OPTION)\n\t\t\t\tbreak;\n\t\t\tctx->out[ctx->cpidx++] = ctx->argv[0];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arg[1] != '-') {\n\t\t\tctx->opt = ++arg;\n\t\t\tif (internal_help && *ctx->opt == 'h') {\n\t\t\t\treturn usage_with_options_internal(usagestr, options, 0, ctx);\n\t\t\t}\n\t\t\tswitch (parse_short_opt(ctx, options)) {\n\t\t\tcase -1:\n\t\t\t\treturn parse_options_usage(usagestr, options, arg, 1);\n\t\t\tcase -2:\n\t\t\t\tgoto unknown;\n\t\t\tcase -3:\n\t\t\t\tgoto exclusive;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ctx->opt)\n\t\t\t\tcheck_typos(arg, options);\n\t\t\twhile (ctx->opt) {\n\t\t\t\tif (internal_help && *ctx->opt == 'h')\n\t\t\t\t\treturn usage_with_options_internal(usagestr, options, 0, ctx);\n\t\t\t\targ = ctx->opt;\n\t\t\t\tswitch (parse_short_opt(ctx, options)) {\n\t\t\t\tcase -1:\n\t\t\t\t\treturn parse_options_usage(usagestr, options, arg, 1);\n\t\t\t\tcase -2:\n\t\t\t\t\t \n\t\t\t\t\tctx->argv[0] = strdup(ctx->opt - 1);\n\t\t\t\t\t*(char *)ctx->argv[0] = '-';\n\t\t\t\t\tgoto unknown;\n\t\t\t\tcase -3:\n\t\t\t\t\tgoto exclusive;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!arg[2]) {  \n\t\t\tif (!(ctx->flags & PARSE_OPT_KEEP_DASHDASH)) {\n\t\t\t\tctx->argc--;\n\t\t\t\tctx->argv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\targ += 2;\n\t\tif (internal_help && !strcmp(arg, \"help-all\"))\n\t\t\treturn usage_with_options_internal(usagestr, options, 1, ctx);\n\t\tif (internal_help && !strcmp(arg, \"help\"))\n\t\t\treturn usage_with_options_internal(usagestr, options, 0, ctx);\n\t\tif (!strcmp(arg, \"list-opts\"))\n\t\t\treturn PARSE_OPT_LIST_OPTS;\n\t\tif (!strcmp(arg, \"list-cmds\"))\n\t\t\treturn PARSE_OPT_LIST_SUBCMDS;\n\t\tswitch (parse_long_opt(ctx, arg, options)) {\n\t\tcase -1:\n\t\t\treturn parse_options_usage(usagestr, options, arg, 0);\n\t\tcase -2:\n\t\t\tgoto unknown;\n\t\tcase -3:\n\t\t\texcl_short_opt = 0;\n\t\t\tgoto exclusive;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tcontinue;\nunknown:\n\t\tif (!(ctx->flags & PARSE_OPT_KEEP_UNKNOWN))\n\t\t\treturn PARSE_OPT_UNKNOWN;\n\t\tctx->out[ctx->cpidx++] = ctx->argv[0];\n\t\tctx->opt = NULL;\n\t}\n\treturn PARSE_OPT_DONE;\n\nexclusive:\n\tparse_options_usage(usagestr, options, arg, excl_short_opt);\n\tif ((excl_short_opt && ctx->excl_opt->short_name) ||\n\t    ctx->excl_opt->long_name == NULL) {\n\t\tchar opt = ctx->excl_opt->short_name;\n\t\tparse_options_usage(NULL, options, &opt, 1);\n\t} else {\n\t\tparse_options_usage(NULL, options, ctx->excl_opt->long_name, 0);\n\t}\n\treturn PARSE_OPT_HELP;\n}\n\nstatic int parse_options_end(struct parse_opt_ctx_t *ctx)\n{\n\tmemmove(ctx->out + ctx->cpidx, ctx->argv, ctx->argc * sizeof(*ctx->out));\n\tctx->out[ctx->cpidx + ctx->argc] = NULL;\n\treturn ctx->cpidx + ctx->argc;\n}\n\nint parse_options_subcommand(int argc, const char **argv, const struct option *options,\n\t\t\tconst char *const subcommands[], const char *usagestr[], int flags)\n{\n\tstruct parse_opt_ctx_t ctx;\n\n\t \n\tif (subcommands && !usagestr[0]) {\n\t\tchar *buf = NULL;\n\n\t\tastrcatf(&buf, \"%s %s [<options>] {\", subcmd_config.exec_name, argv[0]);\n\n\t\tfor (int i = 0; subcommands[i]; i++) {\n\t\t\tif (i)\n\t\t\t\tastrcat(&buf, \"|\");\n\t\t\tastrcat(&buf, subcommands[i]);\n\t\t}\n\t\tastrcat(&buf, \"}\");\n\n\t\tusagestr[0] = buf;\n\t}\n\n\tparse_options_start(&ctx, argc, argv, flags);\n\tswitch (parse_options_step(&ctx, options, usagestr)) {\n\tcase PARSE_OPT_HELP:\n\t\texit(129);\n\tcase PARSE_OPT_DONE:\n\t\tbreak;\n\tcase PARSE_OPT_LIST_OPTS:\n\t\twhile (options->type != OPTION_END) {\n\t\t\tif (options->long_name)\n\t\t\t\tprintf(\"--%s \", options->long_name);\n\t\t\toptions++;\n\t\t}\n\t\tputchar('\\n');\n\t\texit(130);\n\tcase PARSE_OPT_LIST_SUBCMDS:\n\t\tif (subcommands) {\n\t\t\tfor (int i = 0; subcommands[i]; i++)\n\t\t\t\tprintf(\"%s \", subcommands[i]);\n\t\t}\n\t\tputchar('\\n');\n\t\texit(130);\n\tdefault:  \n\t\tif (ctx.argv[0][1] == '-')\n\t\t\tastrcatf(&error_buf, \"unknown option `%s'\",\n\t\t\t\t ctx.argv[0] + 2);\n\t\telse\n\t\t\tastrcatf(&error_buf, \"unknown switch `%c'\", *ctx.opt);\n\t\tusage_with_options(usagestr, options);\n\t}\n\n\treturn parse_options_end(&ctx);\n}\n\nint parse_options(int argc, const char **argv, const struct option *options,\n\t\t  const char * const usagestr[], int flags)\n{\n\treturn parse_options_subcommand(argc, argv, options, NULL,\n\t\t\t\t\t(const char **) usagestr, flags);\n}\n\n#define USAGE_OPTS_WIDTH 24\n#define USAGE_GAP         2\n\nstatic void print_option_help(const struct option *opts, int full)\n{\n\tsize_t pos;\n\tint pad;\n\n\tif (opts->type == OPTION_GROUP) {\n\t\tfputc('\\n', stderr);\n\t\tif (*opts->help)\n\t\t\tfprintf(stderr, \"%s\\n\", opts->help);\n\t\treturn;\n\t}\n\tif (!full && (opts->flags & PARSE_OPT_HIDDEN))\n\t\treturn;\n\tif (opts->flags & PARSE_OPT_DISABLED)\n\t\treturn;\n\n\tpos = fprintf(stderr, \"    \");\n\tif (opts->short_name)\n\t\tpos += fprintf(stderr, \"-%c\", opts->short_name);\n\telse\n\t\tpos += fprintf(stderr, \"    \");\n\n\tif (opts->long_name && opts->short_name)\n\t\tpos += fprintf(stderr, \", \");\n\tif (opts->long_name)\n\t\tpos += fprintf(stderr, \"--%s\", opts->long_name);\n\n\tswitch (opts->type) {\n\tcase OPTION_ARGUMENT:\n\t\tbreak;\n\tcase OPTION_LONG:\n\tcase OPTION_ULONG:\n\tcase OPTION_U64:\n\tcase OPTION_INTEGER:\n\tcase OPTION_UINTEGER:\n\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\tif (opts->long_name)\n\t\t\t\tpos += fprintf(stderr, \"[=<n>]\");\n\t\t\telse\n\t\t\t\tpos += fprintf(stderr, \"[<n>]\");\n\t\telse\n\t\t\tpos += fprintf(stderr, \" <n>\");\n\t\tbreak;\n\tcase OPTION_CALLBACK:\n\t\tif (opts->flags & PARSE_OPT_NOARG)\n\t\t\tbreak;\n\t\t \n\tcase OPTION_STRING:\n\t\tif (opts->argh) {\n\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\tif (opts->long_name)\n\t\t\t\t\tpos += fprintf(stderr, \"[=<%s>]\", opts->argh);\n\t\t\t\telse\n\t\t\t\t\tpos += fprintf(stderr, \"[<%s>]\", opts->argh);\n\t\t\telse\n\t\t\t\tpos += fprintf(stderr, \" <%s>\", opts->argh);\n\t\t} else {\n\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\tif (opts->long_name)\n\t\t\t\t\tpos += fprintf(stderr, \"[=...]\");\n\t\t\t\telse\n\t\t\t\t\tpos += fprintf(stderr, \"[...]\");\n\t\t\telse\n\t\t\t\tpos += fprintf(stderr, \" ...\");\n\t\t}\n\t\tbreak;\n\tdefault:  \n\tcase OPTION_END:\n\tcase OPTION_GROUP:\n\tcase OPTION_BIT:\n\tcase OPTION_BOOLEAN:\n\tcase OPTION_INCR:\n\tcase OPTION_SET_UINT:\n\tcase OPTION_SET_PTR:\n\t\tbreak;\n\t}\n\n\tif (pos <= USAGE_OPTS_WIDTH)\n\t\tpad = USAGE_OPTS_WIDTH - pos;\n\telse {\n\t\tfputc('\\n', stderr);\n\t\tpad = USAGE_OPTS_WIDTH;\n\t}\n\tfprintf(stderr, \"%*s%s\\n\", pad + USAGE_GAP, \"\", opts->help);\n\tif (opts->flags & PARSE_OPT_NOBUILD)\n\t\tfprintf(stderr, \"%*s(not built-in because %s)\\n\",\n\t\t\tUSAGE_OPTS_WIDTH + USAGE_GAP, \"\",\n\t\t\topts->build_opt);\n}\n\nstatic int option__cmp(const void *va, const void *vb)\n{\n\tconst struct option *a = va, *b = vb;\n\tint sa = tolower(a->short_name), sb = tolower(b->short_name), ret;\n\n\tif (sa == 0)\n\t\tsa = 'z' + 1;\n\tif (sb == 0)\n\t\tsb = 'z' + 1;\n\n\tret = sa - sb;\n\n\tif (ret == 0) {\n\t\tconst char *la = a->long_name ?: \"\",\n\t\t\t   *lb = b->long_name ?: \"\";\n\t\tret = strcmp(la, lb);\n\t}\n\n\treturn ret;\n}\n\nstatic struct option *options__order(const struct option *opts)\n{\n\tint nr_opts = 0, nr_group = 0, len;\n\tconst struct option *o = opts;\n\tstruct option *opt, *ordered, *group;\n\n\tfor (o = opts; o->type != OPTION_END; o++)\n\t\t++nr_opts;\n\n\tlen = sizeof(*o) * (nr_opts + 1);\n\tordered = malloc(len);\n\tif (!ordered)\n\t\tgoto out;\n\tmemcpy(ordered, opts, len);\n\n\t \n\tfor (opt = group = ordered; opt->type != OPTION_END; opt++) {\n\t\tif (opt->type == OPTION_GROUP) {\n\t\t\tqsort(group, nr_group, sizeof(*opt), option__cmp);\n\t\t\tgroup = opt + 1;\n\t\t\tnr_group = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tnr_group++;\n\t}\n\tqsort(group, nr_group, sizeof(*opt), option__cmp);\n\nout:\n\treturn ordered;\n}\n\nstatic bool option__in_argv(const struct option *opt, const struct parse_opt_ctx_t *ctx)\n{\n\tint i;\n\n\tfor (i = 1; i < ctx->argc; ++i) {\n\t\tconst char *arg = ctx->argv[i];\n\n\t\tif (arg[0] != '-') {\n\t\t\tif (arg[1] == '\\0') {\n\t\t\t\tif (arg[0] == opt->short_name)\n\t\t\t\t\treturn true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (opt->long_name && strcmp(opt->long_name, arg) == 0)\n\t\t\t\treturn true;\n\n\t\t\tif (opt->help && strcasestr(opt->help, arg) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arg[1] == opt->short_name ||\n\t\t    (arg[1] == '-' && opt->long_name && strcmp(opt->long_name, arg + 2) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int usage_with_options_internal(const char * const *usagestr,\n\t\t\t\t       const struct option *opts, int full,\n\t\t\t\t       struct parse_opt_ctx_t *ctx)\n{\n\tstruct option *ordered;\n\n\tif (!usagestr)\n\t\treturn PARSE_OPT_HELP;\n\n\tsetup_pager();\n\n\tif (error_buf) {\n\t\tfprintf(stderr, \"  Error: %s\\n\", error_buf);\n\t\tzfree(&error_buf);\n\t}\n\n\tfprintf(stderr, \"\\n Usage: %s\\n\", *usagestr++);\n\twhile (*usagestr && **usagestr)\n\t\tfprintf(stderr, \"    or: %s\\n\", *usagestr++);\n\twhile (*usagestr) {\n\t\tfprintf(stderr, \"%s%s\\n\",\n\t\t\t\t**usagestr ? \"    \" : \"\",\n\t\t\t\t*usagestr);\n\t\tusagestr++;\n\t}\n\n\tif (opts->type != OPTION_GROUP)\n\t\tfputc('\\n', stderr);\n\n\tordered = options__order(opts);\n\tif (ordered)\n\t\topts = ordered;\n\n\tfor (  ; opts->type != OPTION_END; opts++) {\n\t\tif (ctx && ctx->argc > 1 && !option__in_argv(opts, ctx))\n\t\t\tcontinue;\n\t\tprint_option_help(opts, full);\n\t}\n\n\tfputc('\\n', stderr);\n\n\tfree(ordered);\n\n\treturn PARSE_OPT_HELP;\n}\n\nvoid usage_with_options(const char * const *usagestr,\n\t\t\tconst struct option *opts)\n{\n\tusage_with_options_internal(usagestr, opts, 0, NULL);\n\texit(129);\n}\n\nvoid usage_with_options_msg(const char * const *usagestr,\n\t\t\t    const struct option *opts, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *tmp = error_buf;\n\n\tva_start(ap, fmt);\n\tif (vasprintf(&error_buf, fmt, ap) == -1)\n\t\tdie(\"vasprintf failed\");\n\tva_end(ap);\n\n\tfree(tmp);\n\n\tusage_with_options_internal(usagestr, opts, 0, NULL);\n\texit(129);\n}\n\nint parse_options_usage(const char * const *usagestr,\n\t\t\tconst struct option *opts,\n\t\t\tconst char *optstr, bool short_opt)\n{\n\tif (!usagestr)\n\t\tgoto opt;\n\n\tfprintf(stderr, \"\\n Usage: %s\\n\", *usagestr++);\n\twhile (*usagestr && **usagestr)\n\t\tfprintf(stderr, \"    or: %s\\n\", *usagestr++);\n\twhile (*usagestr) {\n\t\tfprintf(stderr, \"%s%s\\n\",\n\t\t\t\t**usagestr ? \"    \" : \"\",\n\t\t\t\t*usagestr);\n\t\tusagestr++;\n\t}\n\tfputc('\\n', stderr);\n\nopt:\n\tfor (  ; opts->type != OPTION_END; opts++) {\n\t\tif (short_opt) {\n\t\t\tif (opts->short_name == *optstr) {\n\t\t\t\tprint_option_help(opts, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (opts->long_name == NULL)\n\t\t\tcontinue;\n\n\t\tif (strstarts(opts->long_name, optstr))\n\t\t\tprint_option_help(opts, 0);\n\t\tif (strstarts(\"no-\", optstr) &&\n\t\t    strstarts(opts->long_name, optstr + 3))\n\t\t\tprint_option_help(opts, 0);\n\t}\n\n\treturn PARSE_OPT_HELP;\n}\n\n\nint parse_opt_verbosity_cb(const struct option *opt,\n\t\t\t   const char *arg __maybe_unused,\n\t\t\t   int unset)\n{\n\tint *target = opt->value;\n\n\tif (unset)\n\t\t \n\t\t*target = 0;\n\telse if (opt->short_name == 'v') {\n\t\tif (*target >= 0)\n\t\t\t(*target)++;\n\t\telse\n\t\t\t*target = 1;\n\t} else {\n\t\tif (*target <= 0)\n\t\t\t(*target)--;\n\t\telse\n\t\t\t*target = -1;\n\t}\n\treturn 0;\n}\n\nstatic struct option *\nfind_option(struct option *opts, int shortopt, const char *longopt)\n{\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tif ((shortopt && opts->short_name == shortopt) ||\n\t\t    (opts->long_name && longopt &&\n\t\t     !strcmp(opts->long_name, longopt)))\n\t\t\treturn opts;\n\t}\n\treturn NULL;\n}\n\nvoid set_option_flag(struct option *opts, int shortopt, const char *longopt,\n\t\t     int flag)\n{\n\tstruct option *opt = find_option(opts, shortopt, longopt);\n\n\tif (opt)\n\t\topt->flags |= flag;\n\treturn;\n}\n\nvoid set_option_nobuild(struct option *opts, int shortopt,\n\t\t\tconst char *longopt,\n\t\t\tconst char *build_opt,\n\t\t\tbool can_skip)\n{\n\tstruct option *opt = find_option(opts, shortopt, longopt);\n\n\tif (!opt)\n\t\treturn;\n\n\topt->flags |= PARSE_OPT_NOBUILD;\n\topt->flags |= can_skip ? PARSE_OPT_CANSKIP : 0;\n\topt->build_opt = build_opt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}