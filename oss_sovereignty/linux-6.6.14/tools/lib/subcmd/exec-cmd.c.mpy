{
  "module_name": "exec-cmd.c",
  "hash_id": "23e25a976bdc7ed07a8246688de5620f1667a75d785e27352415eef21a778919",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/subcmd/exec-cmd.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"subcmd-util.h\"\n#include \"exec-cmd.h\"\n#include \"subcmd-config.h\"\n\n#define MAX_ARGS\t32\n#define PATH_MAX\t4096\n\nstatic const char *argv_exec_path;\nstatic const char *argv0_path;\n\nvoid exec_cmd_init(const char *exec_name, const char *prefix,\n\t\t   const char *exec_path, const char *exec_path_env)\n{\n\tsubcmd_config.exec_name\t\t= exec_name;\n\tsubcmd_config.prefix\t\t= prefix;\n\tsubcmd_config.exec_path\t\t= exec_path;\n\tsubcmd_config.exec_path_env\t= exec_path_env;\n\n\t \n\tsetenv(\"PREFIX\", prefix, 1);\n}\n\n#define is_dir_sep(c) ((c) == '/')\n\nstatic int is_absolute_path(const char *path)\n{\n\treturn path[0] == '/';\n}\n\nstatic const char *get_pwd_cwd(char *buf, size_t sz)\n{\n\tchar *pwd;\n\tstruct stat cwd_stat, pwd_stat;\n\tif (getcwd(buf, sz) == NULL)\n\t\treturn NULL;\n\tpwd = getenv(\"PWD\");\n\tif (pwd && strcmp(pwd, buf)) {\n\t\tstat(buf, &cwd_stat);\n\t\tif (!stat(pwd, &pwd_stat) &&\n\t\t    pwd_stat.st_dev == cwd_stat.st_dev &&\n\t\t    pwd_stat.st_ino == cwd_stat.st_ino) {\n\t\t\tstrlcpy(buf, pwd, sz);\n\t\t}\n\t}\n\treturn buf;\n}\n\nstatic const char *make_nonrelative_path(char *buf, size_t sz, const char *path)\n{\n\tif (is_absolute_path(path)) {\n\t\tif (strlcpy(buf, path, sz) >= sz)\n\t\t\tdie(\"Too long path: %.*s\", 60, path);\n\t} else {\n\t\tconst char *cwd = get_pwd_cwd(buf, sz);\n\n\t\tif (!cwd)\n\t\t\tdie(\"Cannot determine the current working directory\");\n\n\t\tif (strlen(cwd) + strlen(path) + 2 >= sz)\n\t\t\tdie(\"Too long path: %.*s\", 60, path);\n\n\t\tstrcat(buf, \"/\");\n\t\tstrcat(buf, path);\n\t}\n\treturn buf;\n}\n\nchar *system_path(const char *path)\n{\n\tchar *buf = NULL;\n\n\tif (is_absolute_path(path))\n\t\treturn strdup(path);\n\n\tastrcatf(&buf, \"%s/%s\", subcmd_config.prefix, path);\n\n\treturn buf;\n}\n\nconst char *extract_argv0_path(const char *argv0)\n{\n\tconst char *slash;\n\n\tif (!argv0 || !*argv0)\n\t\treturn NULL;\n\tslash = argv0 + strlen(argv0);\n\n\twhile (argv0 <= slash && !is_dir_sep(*slash))\n\t\tslash--;\n\n\tif (slash >= argv0) {\n\t\targv0_path = strndup(argv0, slash - argv0);\n\t\treturn argv0_path ? slash + 1 : NULL;\n\t}\n\n\treturn argv0;\n}\n\nvoid set_argv_exec_path(const char *exec_path)\n{\n\targv_exec_path = exec_path;\n\t \n\tsetenv(subcmd_config.exec_path_env, exec_path, 1);\n}\n\n\n \nchar *get_argv_exec_path(void)\n{\n\tchar *env;\n\n\tif (argv_exec_path)\n\t\treturn strdup(argv_exec_path);\n\n\tenv = getenv(subcmd_config.exec_path_env);\n\tif (env && *env)\n\t\treturn strdup(env);\n\n\treturn system_path(subcmd_config.exec_path);\n}\n\nstatic void add_path(char **out, const char *path)\n{\n\tif (path && *path) {\n\t\tif (is_absolute_path(path))\n\t\t\tastrcat(out, path);\n\t\telse {\n\t\t\tchar buf[PATH_MAX];\n\n\t\t\tastrcat(out, make_nonrelative_path(buf, sizeof(buf), path));\n\t\t}\n\n\t\tastrcat(out, \":\");\n\t}\n}\n\nvoid setup_path(void)\n{\n\tconst char *old_path = getenv(\"PATH\");\n\tchar *new_path = NULL;\n\tchar *tmp = get_argv_exec_path();\n\n\tadd_path(&new_path, tmp);\n\tadd_path(&new_path, argv0_path);\n\tfree(tmp);\n\n\tif (old_path)\n\t\tastrcat(&new_path, old_path);\n\telse\n\t\tastrcat(&new_path, \"/usr/local/bin:/usr/bin:/bin\");\n\n\tsetenv(\"PATH\", new_path, 1);\n\n\tfree(new_path);\n}\n\nstatic const char **prepare_exec_cmd(const char **argv)\n{\n\tint argc;\n\tconst char **nargv;\n\n\tfor (argc = 0; argv[argc]; argc++)\n\t\t;  \n\tnargv = malloc(sizeof(*nargv) * (argc + 2));\n\n\tnargv[0] = subcmd_config.exec_name;\n\tfor (argc = 0; argv[argc]; argc++)\n\t\tnargv[argc + 1] = argv[argc];\n\tnargv[argc + 1] = NULL;\n\treturn nargv;\n}\n\nint execv_cmd(const char **argv) {\n\tconst char **nargv = prepare_exec_cmd(argv);\n\n\t \n\texecvp(subcmd_config.exec_name, (char **)nargv);\n\n\tfree(nargv);\n\treturn -1;\n}\n\n\nint execl_cmd(const char *cmd,...)\n{\n\tint argc;\n\tconst char *argv[MAX_ARGS + 1];\n\tconst char *arg;\n\tva_list param;\n\n\tva_start(param, cmd);\n\targv[0] = cmd;\n\targc = 1;\n\twhile (argc < MAX_ARGS) {\n\t\targ = argv[argc++] = va_arg(param, char *);\n\t\tif (!arg)\n\t\t\tbreak;\n\t}\n\tva_end(param);\n\tif (MAX_ARGS <= argc) {\n\t\tfprintf(stderr, \" Error: too many args to run %s\\n\", cmd);\n\t\treturn -1;\n\t}\n\n\targv[argc] = NULL;\n\treturn execv_cmd(argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}