{
  "module_name": "run-command.c",
  "hash_id": "85fe1d7ae33b49c4bc5bf38dd10dc397b507f321fc72dc06b0f1d6e88e3e30e7",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/subcmd/run-command.c",
  "human_readable_source": "\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <linux/string.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"subcmd-util.h\"\n#include \"run-command.h\"\n#include \"exec-cmd.h\"\n\n#define STRERR_BUFSIZE 128\n\nstatic inline void close_pair(int fd[2])\n{\n\tclose(fd[0]);\n\tclose(fd[1]);\n}\n\nstatic inline void dup_devnull(int to)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\tdup2(fd, to);\n\tclose(fd);\n}\n\nint start_command(struct child_process *cmd)\n{\n\tint need_in, need_out, need_err;\n\tint fdin[2], fdout[2], fderr[2];\n\tchar sbuf[STRERR_BUFSIZE];\n\n\t \n\n\tneed_in = !cmd->no_stdin && cmd->in < 0;\n\tif (need_in) {\n\t\tif (pipe(fdin) < 0) {\n\t\t\tif (cmd->out > 0)\n\t\t\t\tclose(cmd->out);\n\t\t\treturn -ERR_RUN_COMMAND_PIPE;\n\t\t}\n\t\tcmd->in = fdin[1];\n\t}\n\n\tneed_out = !cmd->no_stdout\n\t\t&& !cmd->stdout_to_stderr\n\t\t&& cmd->out < 0;\n\tif (need_out) {\n\t\tif (pipe(fdout) < 0) {\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\treturn -ERR_RUN_COMMAND_PIPE;\n\t\t}\n\t\tcmd->out = fdout[0];\n\t}\n\n\tneed_err = !cmd->no_stderr && cmd->err < 0;\n\tif (need_err) {\n\t\tif (pipe(fderr) < 0) {\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\tif (need_out)\n\t\t\t\tclose_pair(fdout);\n\t\t\telse if (cmd->out)\n\t\t\t\tclose(cmd->out);\n\t\t\treturn -ERR_RUN_COMMAND_PIPE;\n\t\t}\n\t\tcmd->err = fderr[0];\n\t}\n\n\tfflush(NULL);\n\tcmd->pid = fork();\n\tif (!cmd->pid) {\n\t\tif (cmd->no_stdin)\n\t\t\tdup_devnull(0);\n\t\telse if (need_in) {\n\t\t\tdup2(fdin[0], 0);\n\t\t\tclose_pair(fdin);\n\t\t} else if (cmd->in) {\n\t\t\tdup2(cmd->in, 0);\n\t\t\tclose(cmd->in);\n\t\t}\n\n\t\tif (cmd->no_stderr)\n\t\t\tdup_devnull(2);\n\t\telse if (need_err) {\n\t\t\tdup2(fderr[1], 2);\n\t\t\tclose_pair(fderr);\n\t\t}\n\n\t\tif (cmd->no_stdout)\n\t\t\tdup_devnull(1);\n\t\telse if (cmd->stdout_to_stderr)\n\t\t\tdup2(2, 1);\n\t\telse if (need_out) {\n\t\t\tdup2(fdout[1], 1);\n\t\t\tclose_pair(fdout);\n\t\t} else if (cmd->out > 1) {\n\t\t\tdup2(cmd->out, 1);\n\t\t\tclose(cmd->out);\n\t\t}\n\n\t\tif (cmd->dir && chdir(cmd->dir))\n\t\t\tdie(\"exec %s: cd to %s failed (%s)\", cmd->argv[0],\n\t\t\t    cmd->dir, str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\tif (cmd->env) {\n\t\t\tfor (; *cmd->env; cmd->env++) {\n\t\t\t\tif (strchr(*cmd->env, '='))\n\t\t\t\t\tputenv((char*)*cmd->env);\n\t\t\t\telse\n\t\t\t\t\tunsetenv(*cmd->env);\n\t\t\t}\n\t\t}\n\t\tif (cmd->preexec_cb)\n\t\t\tcmd->preexec_cb();\n\t\tif (cmd->exec_cmd) {\n\t\t\texecv_cmd(cmd->argv);\n\t\t} else {\n\t\t\texecvp(cmd->argv[0], (char *const*) cmd->argv);\n\t\t}\n\t\texit(127);\n\t}\n\n\tif (cmd->pid < 0) {\n\t\tint err = errno;\n\t\tif (need_in)\n\t\t\tclose_pair(fdin);\n\t\telse if (cmd->in)\n\t\t\tclose(cmd->in);\n\t\tif (need_out)\n\t\t\tclose_pair(fdout);\n\t\telse if (cmd->out)\n\t\t\tclose(cmd->out);\n\t\tif (need_err)\n\t\t\tclose_pair(fderr);\n\t\treturn err == ENOENT ?\n\t\t\t-ERR_RUN_COMMAND_EXEC :\n\t\t\t-ERR_RUN_COMMAND_FORK;\n\t}\n\n\tif (need_in)\n\t\tclose(fdin[0]);\n\telse if (cmd->in)\n\t\tclose(cmd->in);\n\n\tif (need_out)\n\t\tclose(fdout[1]);\n\telse if (cmd->out)\n\t\tclose(cmd->out);\n\n\tif (need_err)\n\t\tclose(fderr[1]);\n\n\treturn 0;\n}\n\nstatic int wait_or_whine(pid_t pid)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tfor (;;) {\n\t\tint status, code;\n\t\tpid_t waiting = waitpid(pid, &status, 0);\n\n\t\tif (waiting < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \" Error: waitpid failed (%s)\",\n\t\t\t\tstr_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t\treturn -ERR_RUN_COMMAND_WAITPID;\n\t\t}\n\t\tif (waiting != pid)\n\t\t\treturn -ERR_RUN_COMMAND_WAITPID_WRONG_PID;\n\t\tif (WIFSIGNALED(status))\n\t\t\treturn -ERR_RUN_COMMAND_WAITPID_SIGNAL;\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn -ERR_RUN_COMMAND_WAITPID_NOEXIT;\n\t\tcode = WEXITSTATUS(status);\n\t\tswitch (code) {\n\t\tcase 127:\n\t\t\treturn -ERR_RUN_COMMAND_EXEC;\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -code;\n\t\t}\n\t}\n}\n\nint finish_command(struct child_process *cmd)\n{\n\treturn wait_or_whine(cmd->pid);\n}\n\nint run_command(struct child_process *cmd)\n{\n\tint code = start_command(cmd);\n\tif (code)\n\t\treturn code;\n\treturn finish_command(cmd);\n}\n\nstatic void prepare_run_command_v_opt(struct child_process *cmd,\n\t\t\t\t      const char **argv,\n\t\t\t\t      int opt)\n{\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->argv = argv;\n\tcmd->no_stdin = opt & RUN_COMMAND_NO_STDIN ? 1 : 0;\n\tcmd->exec_cmd = opt & RUN_EXEC_CMD ? 1 : 0;\n\tcmd->stdout_to_stderr = opt & RUN_COMMAND_STDOUT_TO_STDERR ? 1 : 0;\n}\n\nint run_command_v_opt(const char **argv, int opt)\n{\n\tstruct child_process cmd;\n\tprepare_run_command_v_opt(&cmd, argv, opt);\n\treturn run_command(&cmd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}