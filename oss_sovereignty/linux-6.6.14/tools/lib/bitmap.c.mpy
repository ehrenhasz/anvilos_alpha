{
  "module_name": "bitmap.c",
  "hash_id": "39aabc7f47f2f432e73e4a370988686a2f91644ec15452e8318c8283d814ae8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/bitmap.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n\nunsigned int __bitmap_weight(const unsigned long *bitmap, int bits)\n{\n\tunsigned int k, w = 0, lim = bits/BITS_PER_LONG;\n\n\tfor (k = 0; k < lim; k++)\n\t\tw += hweight_long(bitmap[k]);\n\n\tif (bits % BITS_PER_LONG)\n\t\tw += hweight_long(bitmap[k] & BITMAP_LAST_WORD_MASK(bits));\n\n\treturn w;\n}\n\nvoid __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, int bits)\n{\n\tint k;\n\tint nr = BITS_TO_LONGS(bits);\n\n\tfor (k = 0; k < nr; k++)\n\t\tdst[k] = bitmap1[k] | bitmap2[k];\n}\n\nsize_t bitmap_scnprintf(unsigned long *bitmap, unsigned int nbits,\n\t\t\tchar *buf, size_t size)\n{\n\t \n\tunsigned int cur, rbot, rtop;\n\tbool first = true;\n\tsize_t ret = 0;\n\n\trbot = cur = find_first_bit(bitmap, nbits);\n\twhile (cur < nbits) {\n\t\trtop = cur;\n\t\tcur = find_next_bit(bitmap, nbits, cur + 1);\n\t\tif (cur < nbits && cur <= rtop + 1)\n\t\t\tcontinue;\n\n\t\tif (!first)\n\t\t\tret += scnprintf(buf + ret, size - ret, \",\");\n\n\t\tfirst = false;\n\n\t\tret += scnprintf(buf + ret, size - ret, \"%d\", rbot);\n\t\tif (rbot < rtop)\n\t\t\tret += scnprintf(buf + ret, size - ret, \"-%d\", rtop);\n\n\t\trbot = cur;\n\t}\n\treturn ret;\n}\n\nbool __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k;\n\tunsigned int lim = bits/BITS_PER_LONG;\n\tunsigned long result = 0;\n\n\tfor (k = 0; k < lim; k++)\n\t\tresult |= (dst[k] = bitmap1[k] & bitmap2[k]);\n\tif (bits % BITS_PER_LONG)\n\t\tresult |= (dst[k] = bitmap1[k] & bitmap2[k] &\n\t\t\t   BITMAP_LAST_WORD_MASK(bits));\n\treturn result != 0;\n}\n\nbool __bitmap_equal(const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k, lim = bits/BITS_PER_LONG;\n\tfor (k = 0; k < lim; ++k)\n\t\tif (bitmap1[k] != bitmap2[k])\n\t\t\treturn false;\n\n\tif (bits % BITS_PER_LONG)\n\t\tif ((bitmap1[k] ^ bitmap2[k]) & BITMAP_LAST_WORD_MASK(bits))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool __bitmap_intersects(const unsigned long *bitmap1,\n\t\t\t const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k, lim = bits/BITS_PER_LONG;\n\tfor (k = 0; k < lim; ++k)\n\t\tif (bitmap1[k] & bitmap2[k])\n\t\t\treturn true;\n\n\tif (bits % BITS_PER_LONG)\n\t\tif ((bitmap1[k] & bitmap2[k]) & BITMAP_LAST_WORD_MASK(bits))\n\t\t\treturn true;\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}