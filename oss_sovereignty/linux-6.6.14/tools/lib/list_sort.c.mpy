{
  "module_name": "list_sort.c",
  "hash_id": "109a92a6b5d2b383e0123ed11ecf2cc3890d2e49609d0418ccbbc7aa1d9371b7",
  "original_prompt": "Ingested from linux-6.6.14/tools/lib/list_sort.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/list_sort.h>\n#include <linux/list.h>\n\n \n__attribute__((nonnull(2,3,4)))\nstatic struct list_head *merge(void *priv, list_cmp_func_t cmp,\n\t\t\t\tstruct list_head *a, struct list_head *b)\n{\n\tstruct list_head *head, **tail = &head;\n\n\tfor (;;) {\n\t\t \n\t\tif (cmp(priv, a, b) <= 0) {\n\t\t\t*tail = a;\n\t\t\ttail = &a->next;\n\t\t\ta = a->next;\n\t\t\tif (!a) {\n\t\t\t\t*tail = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t*tail = b;\n\t\t\ttail = &b->next;\n\t\t\tb = b->next;\n\t\t\tif (!b) {\n\t\t\t\t*tail = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn head;\n}\n\n \n__attribute__((nonnull(2,3,4,5)))\nstatic void merge_final(void *priv, list_cmp_func_t cmp, struct list_head *head,\n\t\t\tstruct list_head *a, struct list_head *b)\n{\n\tstruct list_head *tail = head;\n\tu8 count = 0;\n\n\tfor (;;) {\n\t\t \n\t\tif (cmp(priv, a, b) <= 0) {\n\t\t\ttail->next = a;\n\t\t\ta->prev = tail;\n\t\t\ttail = a;\n\t\t\ta = a->next;\n\t\t\tif (!a)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\ttail->next = b;\n\t\t\tb->prev = tail;\n\t\t\ttail = b;\n\t\t\tb = b->next;\n\t\t\tif (!b) {\n\t\t\t\tb = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttail->next = b;\n\tdo {\n\t\t \n\t\tif (unlikely(!++count))\n\t\t\tcmp(priv, b, b);\n\t\tb->prev = tail;\n\t\ttail = b;\n\t\tb = b->next;\n\t} while (b);\n\n\t \n\ttail->next = head;\n\thead->prev = tail;\n}\n\n \n__attribute__((nonnull(2,3)))\nvoid list_sort(void *priv, struct list_head *head, list_cmp_func_t cmp)\n{\n\tstruct list_head *list = head->next, *pending = NULL;\n\tsize_t count = 0;\t \n\n\tif (list == head->prev)\t \n\t\treturn;\n\n\t \n\thead->prev->next = NULL;\n\n\t \n\tdo {\n\t\tsize_t bits;\n\t\tstruct list_head **tail = &pending;\n\n\t\t \n\t\tfor (bits = count; bits & 1; bits >>= 1)\n\t\t\ttail = &(*tail)->prev;\n\t\t \n\t\tif (likely(bits)) {\n\t\t\tstruct list_head *a = *tail, *b = a->prev;\n\n\t\t\ta = merge(priv, cmp, b, a);\n\t\t\t \n\t\t\ta->prev = b->prev;\n\t\t\t*tail = a;\n\t\t}\n\n\t\t \n\t\tlist->prev = pending;\n\t\tpending = list;\n\t\tlist = list->next;\n\t\tpending->next = NULL;\n\t\tcount++;\n\t} while (list);\n\n\t \n\tlist = pending;\n\tpending = pending->prev;\n\tfor (;;) {\n\t\tstruct list_head *next = pending->prev;\n\n\t\tif (!next)\n\t\t\tbreak;\n\t\tlist = merge(priv, cmp, pending, list);\n\t\tpending = next;\n\t}\n\t \n\tmerge_final(priv, cmp, head, pending, list);\n}\nEXPORT_SYMBOL(list_sort);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}