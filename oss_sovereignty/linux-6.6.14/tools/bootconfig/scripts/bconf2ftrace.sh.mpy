{
  "module_name": "bconf2ftrace.sh",
  "hash_id": "2559205373f2046a488b763c23415e83445cdbbd713154a2dbac300e7e61a9fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/bootconfig/scripts/bconf2ftrace.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n\nusage() {\n\techo \"Ftrace boottime trace test tool\"\n\techo \"Usage: $0 [--apply|--init] [--debug] BOOTCONFIG-FILE\"\n\techo \"    --apply: Test actual apply to tracefs (need sudo)\"\n\techo \"    --init:  Initialize ftrace before applying (imply --apply)\"\n\texit 1\n}\n\n[ $# -eq 0 ] && usage\n\nBCONF=\nDEBUG=\nAPPLY=\nINIT=\nwhile [ x\"$1\" != x ]; do\n\tcase \"$1\" in\n\t\"--debug\")\n\t\tDEBUG=$1;;\n\t\"--apply\")\n\t\tAPPLY=$1;;\n\t\"--init\")\n\t\tAPPLY=$1\n\t\tINIT=$1;;\n\t*)\n\t\t[ ! -f $1 ] && usage\n\t\tBCONF=$1;;\n\tesac\n\tshift 1\ndone\n\nif [ x\"$APPLY\" != x ]; then\n\tif [ `id -u` -ne 0 ]; then\n\t\techo \"This must be run by root user. Try sudo.\" 1>&2\n\t\texec sudo $0 $DEBUG $APPLY $BCONF\n\tfi\nfi\n\nrun_cmd() { # command\n\techo \"$*\"\n\tif [ x\"$APPLY\" != x ]; then # apply command\n\t\teval $*\n\tfi\n}\n\nif [ x\"$DEBUG\" != x ]; then\n\tset -x\nfi\n\nTRACEFS=`grep -m 1 -w tracefs /proc/mounts | cut -f 2 -d \" \"`\nif [ -z \"$TRACEFS\" ]; then\n\tif ! grep -wq debugfs /proc/mounts; then\n\t\techo \"Error: No tracefs/debugfs was mounted.\" 1>&2\n\t\texit 1\n\tfi\n\tTRACEFS=`grep -m 1 -w debugfs /proc/mounts | cut -f 2 -d \" \"`/tracing\n\tif [ ! -d $TRACEFS ]; then\n\t\techo \"Error: ftrace is not enabled on this kernel.\" 1>&2\n\t\texit 1\n\tfi\nfi\n\nif [ x\"$INIT\" != x ]; then\n\t. `dirname $0`/ftrace.sh\n\t(cd $TRACEFS; initialize_ftrace)\nfi\n\n. `dirname $0`/xbc.sh\n\n######## main #########\nset -e\n\nxbc_init $BCONF\n\nset_value_of() { # key file\n\tif xbc_has_key $1; then\n\t\tval=`xbc_get_val $1 1`\n\t\trun_cmd \"echo '$val' >> $2\"\n\tfi\n}\n\nset_array_of() { # key file\n\tif xbc_has_key $1; then\n\t\txbc_get_val $1 | while read line; do\n\t\t\trun_cmd \"echo '$line' >> $2\"\n\t\tdone\n\tfi\n}\n\ncompose_synth() { # event_name branch\n\techo -n \"$1 \"\n\txbc_get_val $2 | while read field; do echo -n \"$field; \"; done\n}\n\nprint_hist_array() { # prefix key\n\t__sep=\"=\"\n\tif xbc_has_key ${1}.${2}; then\n\t\techo -n \":$2\"\n\t\txbc_get_val ${1}.${2} | while read field; do\n\t\t\techo -n \"$__sep$field\"; __sep=\",\"\n\t\tdone\n\tfi\n}\n\nprint_hist_action_array() { # prefix key\n\t__sep=\"(\"\n\techo -n \".$2\"\n\txbc_get_val ${1}.${2} | while read field; do\n\t\techo -n \"$__sep$field\"; __sep=\",\"\n\tdone\n\techo -n \")\"\n}\n\nprint_hist_one_action() { # prefix handler param\n\techo -n \":${2}(\"`xbc_get_val ${1}.${3}`\")\"\n\tif xbc_has_key \"${1}.trace\"; then\n\t\tprint_hist_action_array ${1} \"trace\"\n\telif xbc_has_key \"${1}.save\"; then\n\t\tprint_hist_action_array ${1} \"save\"\n\telif xbc_has_key \"${1}.snapshot\"; then\n\t\techo -n \".snapshot()\"\n\tfi\n}\n\nprint_hist_actions() { # prefix handler param\n\tfor __hdr in `xbc_subkeys ${1}.${2} 1 \".[0-9]\"`; do\n\t\tprint_hist_one_action ${1}.${2}.$__hdr ${2} ${3}\n\tdone\n\tif xbc_has_key ${1}.${2}.${3} ; then\n\t\tprint_hist_one_action ${1}.${2} ${2} ${3}\n\tfi\n}\n\nprint_hist_var() { # prefix varname\n\techo -n \":${2}=\"`xbc_get_val ${1}.var.${2} | tr -d [:space:]`\n}\n\nprint_one_histogram() { # prefix\n\techo -n \"hist\"\n\tprint_hist_array $1 \"keys\"\n\tprint_hist_array $1 \"values\"\n\tprint_hist_array $1 \"sort\"\n\tif xbc_has_key \"${1}.size\"; then\n\t\techo -n \":size=\"`xbc_get_val ${1}.size`\n\tfi\n\tif xbc_has_key \"${1}.name\"; then\n\t\techo -n \":name=\"`xbc_get_val ${1}.name`\n\tfi\n\tfor __var in `xbc_subkeys \"${1}.var\" 1`; do\n\t\tprint_hist_var ${1} ${__var}\n\tdone\n\tif xbc_has_key \"${1}.pause\"; then\n\t\techo -n \":pause\"\n\telif xbc_has_key \"${1}.continue\"; then\n\t\techo -n \":continue\"\n\telif xbc_has_key \"${1}.clear\"; then\n\t\techo -n \":clear\"\n\tfi\n\tprint_hist_actions ${1} \"onmax\" \"var\"\n\tprint_hist_actions ${1} \"onchange\" \"var\"\n\tprint_hist_actions ${1} \"onmatch\" \"event\"\n\n\tif xbc_has_key \"${1}.filter\"; then\n\t\techo -n \" if \"`xbc_get_val ${1}.filter`\n\tfi\n}\n\nsetup_one_histogram() { # prefix trigger-file\n\trun_cmd \"echo '`print_one_histogram ${1}`' >> ${2}\"\n}\n\nsetup_histograms() { # prefix trigger-file\n\tfor __hist in `xbc_subkeys ${1} 1 \".[0-9]\"`; do\n\t\tsetup_one_histogram ${1}.$__hist ${2}\n\tdone\n\tif xbc_has_key ${1}.keys; then\n\t\tsetup_one_histogram ${1} ${2}\n\tfi\n}\n\nsetup_event() { # prefix group event [instance]\n\tbranch=$1.$2.$3\n\tif [ \"$4\" ]; then\n\t\teventdir=\"$TRACEFS/instances/$4/events/$2/$3\"\n\telse\n\t\teventdir=\"$TRACEFS/events/$2/$3\"\n\tfi\n\t# group enable\n\tif [ \"$3\" = \"enable\" ]; then\n\t\trun_cmd \"echo 1 > ${eventdir}\"\n\t\treturn\n\tfi\n\n\tcase $2 in\n\tkprobes)\n\t\txbc_get_val ${branch}.probes | while read line; do\n\t\t\trun_cmd \"echo 'p:kprobes/$3 $line' >> $TRACEFS/kprobe_events\"\n\t\tdone\n\t\t;;\n\tsynthetic)\n\t\trun_cmd \"echo '`compose_synth $3 ${branch}.fields`' >> $TRACEFS/synthetic_events\"\n\t\t;;\n\tesac\n\n\tset_value_of ${branch}.filter ${eventdir}/filter\n\tset_array_of ${branch}.actions ${eventdir}/trigger\n\n\tsetup_histograms ${branch}.hist ${eventdir}/trigger\n\n\tif xbc_has_key ${branch}.enable; then\n\t\trun_cmd \"echo 1 > ${eventdir}/enable\"\n\tfi\n}\n\nsetup_events() { # prefix(\"ftrace\" or \"ftrace.instance.INSTANCE\") [instance]\n\tprefix=\"${1}.event\"\n\tif xbc_has_branch ${1}.event; then\n\t\tfor grpev in `xbc_subkeys ${1}.event 2`; do\n\t\t\tsetup_event $prefix ${grpev%.*} ${grpev#*.} $2\n\t\tdone\n\tfi\n\tif xbc_has_branch ${1}.event.enable; then\n\t\tif [ \"$2\" ]; then\n\t\t\trun_cmd \"echo 1 > $TRACEFS/instances/$2/events/enable\"\n\t\telse\n\t\t\trun_cmd \"echo 1 > $TRACEFS/events/enable\"\n\t\tfi\n\tfi\n}\n\nsize2kb() { # size[KB|MB]\n\tcase $1 in\n\t*KB)\n\t\techo ${1%KB};;\n\t*MB)\n\t\texpr ${1%MB} \\* 1024;;\n\t*)\n\t\texpr $1 / 1024 ;;\n\tesac\n}\n\nsetup_instance() { # [instance]\n\tif [ \"$1\" ]; then\n\t\tinstance=\"ftrace.instance.${1}\"\n\t\tinstancedir=$TRACEFS/instances/$1\n\telse\n\t\tinstance=\"ftrace\"\n\t\tinstancedir=$TRACEFS\n\tfi\n\n\tset_array_of ${instance}.options ${instancedir}/trace_options\n\tset_value_of ${instance}.trace_clock ${instancedir}/trace_clock\n\tset_value_of ${instance}.cpumask ${instancedir}/tracing_cpumask\n\tset_value_of ${instance}.tracing_on ${instancedir}/tracing_on\n\tset_value_of ${instance}.tracer ${instancedir}/current_tracer\n\tset_array_of ${instance}.ftrace.filters \\\n\t\t${instancedir}/set_ftrace_filter\n\tset_array_of ${instance}.ftrace.notrace \\\n\t\t${instancedir}/set_ftrace_notrace\n\n\tif xbc_has_key ${instance}.alloc_snapshot; then\n\t\trun_cmd \"echo 1 > ${instancedir}/snapshot\"\n\tfi\n\n\tif xbc_has_key ${instance}.buffer_size; then\n\t\tsize=`xbc_get_val ${instance}.buffer_size 1`\n\t\tsize=`eval size2kb $size`\n\t\trun_cmd \"echo $size >> ${instancedir}/buffer_size_kb\"\n\tfi\n\n\tsetup_events ${instance} $1\n\tset_array_of ${instance}.events ${instancedir}/set_event\n}\n\n# ftrace global configs (kernel.*)\nif xbc_has_key \"kernel.dump_on_oops\"; then\n\tdump_mode=`xbc_get_val \"kernel.dump_on_oops\" 1`\n\t[ \"$dump_mode\" ] && dump_mode=`eval echo $dump_mode` || dump_mode=1\n\trun_cmd \"echo \\\"$dump_mode\\\" > /proc/sys/kernel/ftrace_dump_on_oops\"\nfi\n\nset_value_of kernel.fgraph_max_depth $TRACEFS/max_graph_depth\nset_array_of kernel.fgraph_filters $TRACEFS/set_graph_function\nset_array_of kernel.fgraph_notraces $TRACEFS/set_graph_notrace\n\n# Per-instance/per-event configs\nif ! xbc_has_branch \"ftrace\" ; then\n\texit 0\nfi\n\nsetup_instance # root instance\n\nif xbc_has_branch \"ftrace.instance\"; then\n\tfor i in `xbc_subkeys \"ftrace.instance\" 1`; do\n\t\trun_cmd \"mkdir -p $TRACEFS/instances/$i\"\n\t\tsetup_instance $i\n\tdone\nfi\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}