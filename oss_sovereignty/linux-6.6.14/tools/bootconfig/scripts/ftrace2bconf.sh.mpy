{
  "module_name": "ftrace2bconf.sh",
  "hash_id": "dd2bfb371fa7326211ff657ca78495d12d849463f513508a7c0a97ad4fd1c098",
  "original_prompt": "Ingested from linux-6.6.14/tools/bootconfig/scripts/ftrace2bconf.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n\nusage() {\n\techo \"Dump boot-time tracing bootconfig from ftrace\"\n\techo \"Usage: $0 [--debug] [ > BOOTCONFIG-FILE]\"\n\texit 1\n}\n\nDEBUG=\nwhile [ x\"$1\" != x ]; do\n\tcase \"$1\" in\n\t\"--debug\")\n\t\tDEBUG=$1;;\n\t-*)\n\t\tusage\n\t\t;;\n\tesac\n\tshift 1\ndone\n\nif [ x\"$DEBUG\" != x ]; then\n\tset -x\nfi\n\nTRACEFS=`grep -m 1 -w tracefs /proc/mounts | cut -f 2 -d \" \"`\nif [ -z \"$TRACEFS\" ]; then\n\tif ! grep -wq debugfs /proc/mounts; then\n\t\techo \"Error: No tracefs/debugfs was mounted.\"\n\t\texit 1\n\tfi\n\tTRACEFS=`grep -m 1 -w debugfs /proc/mounts | cut -f 2 -d \" \"`/tracing\n\tif [ ! -d $TRACEFS ]; then\n\t\techo \"Error: ftrace is not enabled on this kernel.\" 1>&2\n\t\texit 1\n\tfi\nfi\n\n######## main #########\n\nset -e\n\nemit_kv() { # key =|+= value\n\techo \"$@\"\n}\n\nglobal_options() {\n\tval=`cat $TRACEFS/max_graph_depth`\n\t[ $val != 0 ] && emit_kv kernel.fgraph_max_depth = $val\n\tif grep -qv \"^#\" $TRACEFS/set_graph_function $TRACEFS/set_graph_notrace ; then\n\t\tcat 1>&2 << EOF\n# WARN: kernel.fgraph_filters and kernel.fgraph_notrace are not supported, since the wild card expression was expanded and lost from memory.\nEOF\n\tfi\n}\n\nkprobe_event_options() {\n\tcat $TRACEFS/kprobe_events | while read p args; do\n\t\tcase $p in\n\t\tr*)\n\t\tcat 1>&2 << EOF\n# WARN: A return probe found but it is not supported by bootconfig. Skip it.\nEOF\n\t\tcontinue;;\n\t\tesac\n\t\tp=${p#*:}\n\t\tevent=${p#*/}\n\t\tgroup=${p%/*}\n\t\tif [ $group != \"kprobes\" ]; then\n\t\t\tcat 1>&2 << EOF\n# WARN: kprobes group name $group is changed to \"kprobes\" for bootconfig.\nEOF\n\t\tfi\n\t\temit_kv $PREFIX.event.kprobes.$event.probes += $args\n\tdone\n}\n\nsynth_event_options() {\n\tcat $TRACEFS/synthetic_events | while read event fields; do\n\t\temit_kv $PREFIX.event.synthetic.$event.fields = `echo $fields | sed \"s/;/,/g\"`\n\tdone\n}\n\n# Variables resolver\nDEFINED_VARS=\nUNRESOLVED_EVENTS=\n\ndefined_vars() { # event-dir\n\tgrep \"^hist\" $1/trigger | grep -o ':[a-zA-Z0-9]*='\n}\nreferred_vars() {\n\tgrep \"^hist\" $1/trigger | grep -o '$[a-zA-Z0-9]*'\n}\n\nevent_is_enabled() { # enable-file\n\ttest -f $1 && grep -q \"1\" $1\n}\n\nper_event_options() { # event-dir\n\tevdir=$1\n\t# Check the special event which has no filter and no trigger\n\t[ ! -f $evdir/filter ] && return\n\n\tif grep -q \"^hist:\" $evdir/trigger; then\n\t\t# hist action can refer the undefined variables\n\t\t__vars=`defined_vars $evdir`\n\t\tfor v in `referred_vars $evdir`; do\n\t\t\tif echo $DEFINED_VARS $__vars | grep -vqw ${v#$}; then\n\t\t\t\t# $v is not defined yet, defer it\n\t\t\t\tUNRESOLVED_EVENTS=\"$UNRESOLVED_EVENTS $evdir\"\n\t\t\t\treturn;\n\t\t\tfi\n\t\tdone\n\t\tDEFINED_VARS=\"$DEFINED_VARS \"`defined_vars $evdir`\n\tfi\n\tgrep -v \"^#\" $evdir/trigger | while read action active; do\n\t\temit_kv $PREFIX.event.$group.$event.actions += \\'$action\\'\n\tdone\n\n\tif [ $GROUP_ENABLED -eq 0 ] && event_is_enabled $evdir/enable; then\n\t\temit_kv $PREFIX.event.$group.$event.enable\n\tfi\n\tval=`cat $evdir/filter`\n\tif [ \"$val\" != \"none\" ]; then\n\t\temit_kv $PREFIX.event.$group.$event.filter = \"$val\"\n\tfi\n}\n\nretry_unresolved() {\n\tunresolved=$UNRESOLVED_EVENTS\n\tUNRESOLVED_EVENTS=\n\tfor evdir in $unresolved; do\n\t\tevent=${evdir##*/}\n\t\tgroup=${evdir%/*}; group=${group##*/}\n\t\tper_event_options $evdir\n\tdone\n}\n\nevent_options() {\n\t# PREFIX and INSTANCE must be set\n\tif [ $PREFIX = \"ftrace\" ]; then\n\t\t# define the dynamic events\n\t\tkprobe_event_options\n\t\tsynth_event_options\n\tfi\n\tALL_ENABLED=0\n\tif event_is_enabled $INSTANCE/events/enable; then\n\t\temit_kv $PREFIX.event.enable\n\t\tALL_ENABLED=1\n\tfi\n\tfor group in `ls $INSTANCE/events/` ; do\n\t\t[ ! -d $INSTANCE/events/$group ] && continue\n\t\tGROUP_ENABLED=$ALL_ENABLED\n\t\tif [ $ALL_ENABLED -eq 0 ] && \\\n\t\t   event_is_enabled $INSTANCE/events/$group/enable ;then\n\t\t\temit_kv $PREFIX.event.$group.enable\n\t\t\tGROUP_ENABLED=1\n\t\tfi\n\t\tfor event in `ls $INSTANCE/events/$group/` ;do\n\t\t\t[ ! -d $INSTANCE/events/$group/$event ] && continue\n\t\t\tper_event_options $INSTANCE/events/$group/$event\n\t\tdone\n\tdone\n\tretry=0\n\twhile [ $retry -lt 3 ]; do\n\t\tretry_unresolved\n\t\tretry=$((retry + 1))\n\tdone\n\tif [ \"$UNRESOLVED_EVENTS\" ]; then\n\t\tcat 1>&2 << EOF\n! ERROR: hist triggers in $UNRESOLVED_EVENTS use some undefined variables.\nEOF\n\tfi\n}\n\nis_default_trace_option() { # option\ngrep -qw $1 << EOF\nprint-parent\nnosym-offset\nnosym-addr\nnoverbose\nnoraw\nnohex\nnobin\nnoblock\ntrace_printk\nannotate\nnouserstacktrace\nnosym-userobj\nnoprintk-msg-only\ncontext-info\nnolatency-format\nrecord-cmd\nnorecord-tgid\noverwrite\nnodisable_on_free\nirq-info\nmarkers\nnoevent-fork\nnopause-on-trace\nfunction-trace\nnofunction-fork\nnodisplay-graph\nnostacktrace\nnotest_nop_accept\nnotest_nop_refuse\nEOF\n}\n\ninstance_options() { # [instance-name]\n\tif [ $# -eq 0 ]; then\n\t\tPREFIX=\"ftrace\"\n\t\tINSTANCE=$TRACEFS\n\telse\n\t\tPREFIX=\"ftrace.instance.$1\"\n\t\tINSTANCE=$TRACEFS/instances/$1\n\tfi\n\tval=\n\tfor i in `cat $INSTANCE/trace_options`; do\n\t\tis_default_trace_option $i && continue\n\t\tval=\"$val, $i\"\n\tdone\n\t[ \"$val\" ] && emit_kv $PREFIX.options = \"${val#,}\"\n\tval=\"local\"\n\tfor i in `cat $INSTANCE/trace_clock` ; do\n\t\t[ \"${i#*]}\" ] && continue\n\t\ti=${i%]}; val=${i#[}\n\tdone\n\t[ $val != \"local\" ] && emit_kv $PREFIX.trace_clock = $val\n\tval=`cat $INSTANCE/buffer_size_kb`\n\tif echo $val | grep -vq \"expanded\" ; then\n\t\temit_kv $PREFIX.buffer_size = $val\"KB\"\n\tfi\n\tif grep -q \"is allocated\" $INSTANCE/snapshot ; then\n\t\temit_kv $PREFIX.alloc_snapshot\n\tfi\n\tval=`cat $INSTANCE/tracing_cpumask`\n\tif [ `echo $val | sed -e s/f//g`x != x ]; then\n\t\temit_kv $PREFIX.cpumask = $val\n\tfi\n\tval=`cat $INSTANCE/tracing_on`\n\tif [ \"$val\" = \"0\" ]; then\n\t\temit_kv $PREFIX.tracing_on = 0\n\tfi\n\n\tval=`cat $INSTANCE/current_tracer`\n\t[ $val != nop ] && emit_kv $PREFIX.tracer = $val\n\tif grep -qv \"^#\" $INSTANCE/set_ftrace_filter $INSTANCE/set_ftrace_notrace; then\n\t\tcat 1>&2 << EOF\n# WARN: kernel.ftrace.filters and kernel.ftrace.notrace are not supported, since the wild card expression was expanded and lost from memory.\nEOF\n\tfi\n\tevent_options\n}\n\nglobal_options\ninstance_options\nfor i in `ls $TRACEFS/instances` ; do\n\tinstance_options $i\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}