{
  "module_name": "main.c",
  "hash_id": "04a2cf319aeadb744f45f276af09c7bd58b1a80ebe01617463fa81c65e530189",
  "original_prompt": "Ingested from linux-6.6.14/tools/bootconfig/main.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <endian.h>\n\n#include <linux/bootconfig.h>\n\n#define pr_err(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)\n\nstatic int xbc_show_value(struct xbc_node *node, bool semicolon)\n{\n\tconst char *val, *eol;\n\tchar q;\n\tint i = 0;\n\n\teol = semicolon ? \";\\n\" : \"\\n\";\n\txbc_array_for_each_value(node, val) {\n\t\tif (strchr(val, '\"'))\n\t\t\tq = '\\'';\n\t\telse\n\t\t\tq = '\"';\n\t\tprintf(\"%c%s%c%s\", q, val, q, xbc_node_is_array(node) ? \", \" : eol);\n\t\ti++;\n\t}\n\treturn i;\n}\n\nstatic void xbc_show_compact_tree(void)\n{\n\tstruct xbc_node *node, *cnode = NULL, *vnode;\n\tint depth = 0, i;\n\n\tnode = xbc_root_node();\n\twhile (node && xbc_node_is_key(node)) {\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tprintf(\"\\t\");\n\t\tif (!cnode)\n\t\t\tcnode = xbc_node_get_child(node);\n\t\twhile (cnode && xbc_node_is_key(cnode) && !cnode->next) {\n\t\t\tvnode = xbc_node_get_child(cnode);\n\t\t\t \n\t\t\tif (vnode && xbc_node_is_value(vnode) && vnode->next)\n\t\t\t\tbreak;\n\t\t\tprintf(\"%s.\", xbc_node_get_data(node));\n\t\t\tnode = cnode;\n\t\t\tcnode = vnode;\n\t\t}\n\t\tif (cnode && xbc_node_is_key(cnode)) {\n\t\t\tprintf(\"%s {\\n\", xbc_node_get_data(node));\n\t\t\tdepth++;\n\t\t\tnode = cnode;\n\t\t\tcnode = NULL;\n\t\t\tcontinue;\n\t\t} else if (cnode && xbc_node_is_value(cnode)) {\n\t\t\tprintf(\"%s = \", xbc_node_get_data(node));\n\t\t\txbc_show_value(cnode, true);\n\t\t\t \n\t\t\tif (cnode->next) {\n\t\t\t\tcnode = xbc_node_get_next(cnode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"%s;\\n\", xbc_node_get_data(node));\n\t\t}\n\t\tcnode = NULL;\n\n\t\tif (node->next) {\n\t\t\tnode = xbc_node_get_next(node);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (!node->next) {\n\t\t\tnode = xbc_node_get_parent(node);\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tif (!xbc_node_get_child(node)->next)\n\t\t\t\tcontinue;\n\t\t\tif (depth) {\n\t\t\t\tdepth--;\n\t\t\t\tfor (i = 0; i < depth; i++)\n\t\t\t\t\tprintf(\"\\t\");\n\t\t\t\tprintf(\"}\\n\");\n\t\t\t}\n\t\t}\n\t\tnode = xbc_node_get_next(node);\n\t}\n}\n\nstatic void xbc_show_list(void)\n{\n\tchar key[XBC_KEYLEN_MAX];\n\tstruct xbc_node *leaf;\n\tconst char *val;\n\tint ret;\n\n\txbc_for_each_key_value(leaf, val) {\n\t\tret = xbc_node_compose_key(leaf, key, XBC_KEYLEN_MAX);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to compose key %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%s = \", key);\n\t\tif (!val || val[0] == '\\0') {\n\t\t\tprintf(\"\\\"\\\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\txbc_show_value(xbc_node_get_child(leaf), false);\n\t}\n}\n\n#define PAGE_SIZE\t4096\n\nstatic int load_xbc_fd(int fd, char **buf, int size)\n{\n\tint ret;\n\n\t*buf = malloc(size + 1);\n\tif (!*buf)\n\t\treturn -ENOMEM;\n\n\tret = read(fd, *buf, size);\n\tif (ret < 0)\n\t\treturn -errno;\n\t(*buf)[size] = '\\0';\n\n\treturn ret;\n}\n\n \nstatic int load_xbc_file(const char *path, char **buf)\n{\n\tstruct stat stat;\n\tint fd, ret;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\tret = fstat(fd, &stat);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tret = load_xbc_fd(fd, buf, stat.st_size);\n\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int pr_errno(const char *msg, int err)\n{\n\tpr_err(\"%s: %d\\n\", msg, err);\n\treturn err;\n}\n\nstatic int load_xbc_from_initrd(int fd, char **buf)\n{\n\tstruct stat stat;\n\tint ret;\n\tuint32_t size = 0, csum = 0, rcsum;\n\tchar magic[BOOTCONFIG_MAGIC_LEN];\n\tconst char *msg;\n\n\tret = fstat(fd, &stat);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tif (stat.st_size < 8 + BOOTCONFIG_MAGIC_LEN)\n\t\treturn 0;\n\n\tif (lseek(fd, -BOOTCONFIG_MAGIC_LEN, SEEK_END) < 0)\n\t\treturn pr_errno(\"Failed to lseek for magic\", -errno);\n\n\tif (read(fd, magic, BOOTCONFIG_MAGIC_LEN) < 0)\n\t\treturn pr_errno(\"Failed to read\", -errno);\n\n\t \n\tif (memcmp(magic, BOOTCONFIG_MAGIC, BOOTCONFIG_MAGIC_LEN) != 0)\n\t\treturn 0;\n\n\tif (lseek(fd, -(8 + BOOTCONFIG_MAGIC_LEN), SEEK_END) < 0)\n\t\treturn pr_errno(\"Failed to lseek for size\", -errno);\n\n\tif (read(fd, &size, sizeof(uint32_t)) < 0)\n\t\treturn pr_errno(\"Failed to read size\", -errno);\n\tsize = le32toh(size);\n\n\tif (read(fd, &csum, sizeof(uint32_t)) < 0)\n\t\treturn pr_errno(\"Failed to read checksum\", -errno);\n\tcsum = le32toh(csum);\n\n\t \n\tif (stat.st_size < size + 8 + BOOTCONFIG_MAGIC_LEN) {\n\t\tpr_err(\"bootconfig size is too big\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\tif (lseek(fd, stat.st_size - (size + 8 + BOOTCONFIG_MAGIC_LEN),\n\t\t  SEEK_SET) < 0)\n\t\treturn pr_errno(\"Failed to lseek\", -errno);\n\n\tret = load_xbc_fd(fd, buf, size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\trcsum = xbc_calc_checksum(*buf, size);\n\tif (csum != rcsum) {\n\t\tpr_err(\"checksum error: %d != %d\\n\", csum, rcsum);\n\t\treturn -EINVAL;\n\t}\n\n\tret = xbc_init(*buf, size, &msg, NULL);\n\t \n\tif (ret < 0) {\n\t\tpr_err(\"parse error: %s.\\n\", msg);\n\t\treturn ret;\n\t}\n\n\treturn size;\n}\n\nstatic void show_xbc_error(const char *data, const char *msg, int pos)\n{\n\tint lin = 1, col, i;\n\n\tif (pos < 0) {\n\t\tpr_err(\"Error: %s.\\n\", msg);\n\t\treturn;\n\t}\n\n\t \n\tcol = pos + 1;\n\tfor (i = 0; i < pos; i++) {\n\t\tif (data[i] == '\\n') {\n\t\t\tlin++;\n\t\t\tcol = pos - i;\n\t\t}\n\t}\n\tpr_err(\"Parse Error: %s at %d:%d\\n\", msg, lin, col);\n\n}\n\nstatic int init_xbc_with_error(char *buf, int len)\n{\n\tchar *copy = strdup(buf);\n\tconst char *msg;\n\tint ret, pos;\n\n\tif (!copy)\n\t\treturn -ENOMEM;\n\n\tret = xbc_init(buf, len, &msg, &pos);\n\tif (ret < 0)\n\t\tshow_xbc_error(copy, msg, pos);\n\tfree(copy);\n\n\treturn ret;\n}\n\nstatic int show_xbc(const char *path, bool list)\n{\n\tint ret, fd;\n\tchar *buf = NULL;\n\tstruct stat st;\n\n\tret = stat(path, &st);\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to stat %s: %d\\n\", path, ret);\n\t\treturn ret;\n\t}\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to open initrd %s: %d\\n\", path, ret);\n\t\treturn ret;\n\t}\n\n\tret = load_xbc_from_initrd(fd, &buf);\n\tclose(fd);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to load a boot config from initrd: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\t \n\tif (ret == 0 && st.st_size <= XBC_DATA_MAX) {\n\t\tret = load_xbc_file(path, &buf);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to load a boot config: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (init_xbc_with_error(buf, ret) < 0)\n\t\t\tgoto out;\n\t}\n\tif (list)\n\t\txbc_show_list();\n\telse\n\t\txbc_show_compact_tree();\n\tret = 0;\nout:\n\tfree(buf);\n\n\treturn ret;\n}\n\nstatic int delete_xbc(const char *path)\n{\n\tstruct stat stat;\n\tint ret = 0, fd, size;\n\tchar *buf = NULL;\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to open initrd %s: %d\\n\", path, ret);\n\t\treturn ret;\n\t}\n\n\tsize = load_xbc_from_initrd(fd, &buf);\n\tif (size < 0) {\n\t\tret = size;\n\t\tpr_err(\"Failed to load a boot config from initrd: %d\\n\", ret);\n\t} else if (size > 0) {\n\t\tret = fstat(fd, &stat);\n\t\tif (!ret)\n\t\t\tret = ftruncate(fd, stat.st_size\n\t\t\t\t\t- size - 8 - BOOTCONFIG_MAGIC_LEN);\n\t\tif (ret)\n\t\t\tret = -errno;\n\t}  \n\n\tclose(fd);\n\tfree(buf);\n\n\treturn ret;\n}\n\nstatic int apply_xbc(const char *path, const char *xbc_path)\n{\n\tchar *buf, *data, *p;\n\tsize_t total_size;\n\tstruct stat stat;\n\tconst char *msg;\n\tuint32_t size, csum;\n\tint pos, pad;\n\tint ret, fd;\n\n\tret = load_xbc_file(xbc_path, &buf);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to load %s : %d\\n\", xbc_path, ret);\n\t\treturn ret;\n\t}\n\tsize = strlen(buf) + 1;\n\tcsum = xbc_calc_checksum(buf, size);\n\n\t \n\tdata = calloc(size + BOOTCONFIG_ALIGN +\n\t\t      sizeof(uint32_t) + sizeof(uint32_t) + BOOTCONFIG_MAGIC_LEN, 1);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tmemcpy(data, buf, size);\n\n\t \n\tret = xbc_init(buf, size, &msg, &pos);\n\tif (ret < 0) {\n\t\tshow_xbc_error(data, msg, pos);\n\t\tfree(data);\n\t\tfree(buf);\n\n\t\treturn ret;\n\t}\n\tprintf(\"Apply %s to %s\\n\", xbc_path, path);\n\txbc_get_info(&ret, NULL);\n\tprintf(\"\\tNumber of nodes: %d\\n\", ret);\n\tprintf(\"\\tSize: %u bytes\\n\", (unsigned int)size);\n\tprintf(\"\\tChecksum: %d\\n\", (unsigned int)csum);\n\n\t \n\txbc_exit();\n\tfree(buf);\n\n\t \n\tret = delete_xbc(path);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to delete previous boot config: %d\\n\", ret);\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\n\t \n\tfd = open(path, O_RDWR | O_APPEND);\n\tif (fd < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to open %s: %d\\n\", path, ret);\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t \n\tif (fstat(fd, &stat) < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to get the size of %s\\n\", path);\n\t\tgoto out;\n\t}\n\n\t \n\ttotal_size = stat.st_size + size + sizeof(uint32_t) * 2 + BOOTCONFIG_MAGIC_LEN;\n\tpad = ((total_size + BOOTCONFIG_ALIGN - 1) & (~BOOTCONFIG_ALIGN_MASK)) - total_size;\n\tsize += pad;\n\n\t \n\tp = data + size;\n\t*(uint32_t *)p = htole32(size);\n\tp += sizeof(uint32_t);\n\n\t*(uint32_t *)p = htole32(csum);\n\tp += sizeof(uint32_t);\n\n\tmemcpy(p, BOOTCONFIG_MAGIC, BOOTCONFIG_MAGIC_LEN);\n\tp += BOOTCONFIG_MAGIC_LEN;\n\n\ttotal_size = p - data;\n\n\tret = write(fd, data, total_size);\n\tif (ret < total_size) {\n\t\tif (ret < 0)\n\t\t\tret = -errno;\n\t\tpr_err(\"Failed to apply a boot config: %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tgoto out_rollback;\n\t} else\n\t\tret = 0;\n\nout:\n\tclose(fd);\n\tfree(data);\n\n\treturn ret;\n\nout_rollback:\n\t \n\tif (ret >= 0)\n\t\tret = -ENOSPC;\n\tif (ftruncate(fd, stat.st_size) < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"Failed to rollback the write error: %d\\n\", ret);\n\t\tpr_err(\"The initrd %s may be corrupted. Recommend to rebuild.\\n\", path);\n\t}\n\tgoto out;\n}\n\nstatic int usage(void)\n{\n\tprintf(\"Usage: bootconfig [OPTIONS] <INITRD>\\n\"\n\t\t\"Or     bootconfig <CONFIG>\\n\"\n\t\t\" Apply, delete or show boot config to initrd.\\n\"\n\t\t\" Options:\\n\"\n\t\t\"\t\t-a <config>: Apply boot config to initrd\\n\"\n\t\t\"\t\t-d : Delete boot config file from initrd\\n\"\n\t\t\"\t\t-l : list boot config in initrd or file\\n\\n\"\n\t\t\" If no option is given, show the bootconfig in the given file.\\n\");\n\treturn -1;\n}\n\nint main(int argc, char **argv)\n{\n\tchar *path = NULL;\n\tchar *apply = NULL;\n\tbool delete = false, list = false;\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"hda:l\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tdelete = true;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tapply = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\treturn usage();\n\t\t}\n\t}\n\n\tif ((apply && delete) || (delete && list) || (apply && list)) {\n\t\tpr_err(\"Error: You can give one of -a, -d or -l at once.\\n\");\n\t\treturn usage();\n\t}\n\n\tif (optind >= argc) {\n\t\tpr_err(\"Error: No initrd is specified.\\n\");\n\t\treturn usage();\n\t}\n\n\tpath = argv[optind];\n\n\tif (apply)\n\t\treturn apply_xbc(path, apply);\n\telse if (delete)\n\t\treturn delete_xbc(path);\n\n\treturn show_xbc(path, list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}