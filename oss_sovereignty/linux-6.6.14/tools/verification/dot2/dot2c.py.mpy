{
  "module_name": "dot2c.py",
  "hash_id": "89c8c970ef260c47fa25f203af2e09765f1138867394cad7ae29297d2035a257",
  "original_prompt": "Ingested from linux-6.6.14/tools/verification/dot2/dot2c.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>\n#\n# dot2c: parse an automata in dot file digraph format into a C\n#\n# This program was written in the development of this paper:\n#  de Oliveira, D. B. and Cucinotta, T. and de Oliveira, R. S.\n#  \"Efficient Formal Verification for the Linux Kernel.\" International\n#  Conference on Software Engineering and Formal Methods. Springer, Cham, 2019.\n#\n# For further information, see:\n#   Documentation/trace/rv/deterministic_automata.rst\n\nfrom dot2.automata import Automata\n\nclass Dot2c(Automata):\n    enum_suffix = \"\"\n    enum_states_def = \"states\"\n    enum_events_def = \"events\"\n    struct_automaton_def = \"automaton\"\n    var_automaton_def = \"aut\"\n\n    def __init__(self, file_path):\n        super().__init__(file_path)\n        self.line_length = 100\n\n    def __buff_to_string(self, buff):\n        string = \"\"\n\n        for line in buff:\n            string = string + line + \"\\n\"\n\n        # cut off the last \\n\n        return string[:-1]\n\n    def __get_enum_states_content(self):\n        buff = []\n        buff.append(\"\\t%s%s = 0,\" % (self.initial_state, self.enum_suffix))\n        for state in self.states:\n            if state != self.initial_state:\n                buff.append(\"\\t%s%s,\" % (state, self.enum_suffix))\n        buff.append(\"\\tstate_max%s\" % (self.enum_suffix))\n\n        return buff\n\n    def get_enum_states_string(self):\n        buff = self.__get_enum_states_content()\n        return self.__buff_to_string(buff)\n\n    def format_states_enum(self):\n        buff = []\n        buff.append(\"enum %s {\" % self.enum_states_def)\n        buff.append(self.get_enum_states_string())\n        buff.append(\"};\\n\")\n\n        return buff\n\n    def __get_enum_events_content(self):\n        buff = []\n        first = True\n        for event in self.events:\n            if first:\n                buff.append(\"\\t%s%s = 0,\" % (event, self.enum_suffix))\n                first = False\n            else:\n                buff.append(\"\\t%s%s,\" % (event, self.enum_suffix))\n\n        buff.append(\"\\tevent_max%s\" % self.enum_suffix)\n\n        return buff\n\n    def get_enum_events_string(self):\n        buff = self.__get_enum_events_content()\n        return self.__buff_to_string(buff)\n\n    def format_events_enum(self):\n        buff = []\n        buff.append(\"enum %s {\" % self.enum_events_def)\n        buff.append(self.get_enum_events_string())\n        buff.append(\"};\\n\")\n\n        return buff\n\n    def get_minimun_type(self):\n        min_type = \"unsigned char\"\n\n        if self.states.__len__() > 255:\n            min_type = \"unsigned short\"\n\n        if self.states.__len__() > 65535:\n            min_type = \"unsigned int\"\n\n        if self.states.__len__() > 1000000:\n            raise Exception(\"Too many states: %d\" % self.states.__len__())\n\n        return min_type\n\n    def format_automaton_definition(self):\n        min_type = self.get_minimun_type()\n        buff = []\n        buff.append(\"struct %s {\" % self.struct_automaton_def)\n        buff.append(\"\\tchar *state_names[state_max%s];\" % (self.enum_suffix))\n        buff.append(\"\\tchar *event_names[event_max%s];\" % (self.enum_suffix))\n        buff.append(\"\\t%s function[state_max%s][event_max%s];\" % (min_type, self.enum_suffix, self.enum_suffix))\n        buff.append(\"\\t%s initial_state;\" % min_type)\n        buff.append(\"\\tbool final_states[state_max%s];\" % (self.enum_suffix))\n        buff.append(\"};\\n\")\n        return buff\n\n    def format_aut_init_header(self):\n        buff = []\n        buff.append(\"static const struct %s %s = {\" % (self.struct_automaton_def, self.var_automaton_def))\n        return buff\n\n    def __get_string_vector_per_line_content(self, buff):\n        first = True\n        string = \"\"\n        for entry in buff:\n            if first:\n                string = string + \"\\t\\t\\\"\" + entry\n                first = False;\n            else:\n                string = string + \"\\\",\\n\\t\\t\\\"\" + entry\n        string = string + \"\\\"\"\n\n        return string\n\n    def get_aut_init_events_string(self):\n        return self.__get_string_vector_per_line_content(self.events)\n\n    def get_aut_init_states_string(self):\n        return self.__get_string_vector_per_line_content(self.states)\n\n    def format_aut_init_events_string(self):\n        buff = []\n        buff.append(\"\\t.event_names = {\")\n        buff.append(self.get_aut_init_events_string())\n        buff.append(\"\\t},\")\n        return buff\n\n    def format_aut_init_states_string(self):\n        buff = []\n        buff.append(\"\\t.state_names = {\")\n        buff.append(self.get_aut_init_states_string())\n        buff.append(\"\\t},\")\n\n        return buff\n\n    def __get_max_strlen_of_states(self):\n        max_state_name = max(self.states, key = len).__len__()\n        return max(max_state_name, self.invalid_state_str.__len__())\n\n    def __get_state_string_length(self):\n        maxlen = self.__get_max_strlen_of_states() + self.enum_suffix.__len__()\n        return \"%\" + str(maxlen) + \"s\"\n\n    def get_aut_init_function(self):\n        nr_states = self.states.__len__()\n        nr_events = self.events.__len__()\n        buff = []\n\n        strformat = self.__get_state_string_length()\n\n        for x in range(nr_states):\n            line = \"\\t\\t{ \"\n            for y in range(nr_events):\n                next_state = self.function[x][y]\n                if next_state != self.invalid_state_str:\n                    next_state = self.function[x][y] + self.enum_suffix\n\n                if y != nr_events-1:\n                    line = line + strformat % next_state + \", \"\n                else:\n                    line = line + strformat % next_state + \" },\"\n            buff.append(line)\n\n        return self.__buff_to_string(buff)\n\n    def format_aut_init_function(self):\n        buff = []\n        buff.append(\"\\t.function = {\")\n        buff.append(self.get_aut_init_function())\n        buff.append(\"\\t},\")\n\n        return buff\n\n    def get_aut_init_initial_state(self):\n        return self.initial_state\n\n    def format_aut_init_initial_state(self):\n        buff = []\n        initial_state = self.get_aut_init_initial_state()\n        buff.append(\"\\t.initial_state = \" + initial_state + self.enum_suffix + \",\")\n\n        return buff\n\n    def get_aut_init_final_states(self):\n        line = \"\"\n        first = True\n        for state in self.states:\n            if first == False:\n                line = line + ', '\n            else:\n                first = False\n\n            if self.final_states.__contains__(state):\n                line = line + '1'\n            else:\n                line = line + '0'\n        return line\n\n    def format_aut_init_final_states(self):\n       buff = []\n       buff.append(\"\\t.final_states = { %s },\" % self.get_aut_init_final_states())\n\n       return buff\n\n    def __get_automaton_initialization_footer_string(self):\n        footer = \"};\\n\"\n        return footer\n\n    def format_aut_init_footer(self):\n        buff = []\n        buff.append(self.__get_automaton_initialization_footer_string())\n\n        return buff\n\n    def format_invalid_state(self):\n        buff = []\n        buff.append(\"#define %s state_max%s\\n\" % (self.invalid_state_str, self.enum_suffix))\n\n        return buff\n\n    def format_model(self):\n        buff = []\n        buff += self.format_states_enum()\n        buff += self.format_invalid_state()\n        buff += self.format_events_enum()\n        buff += self.format_automaton_definition()\n        buff += self.format_aut_init_header()\n        buff += self.format_aut_init_states_string()\n        buff += self.format_aut_init_events_string()\n        buff += self.format_aut_init_function()\n        buff += self.format_aut_init_initial_state()\n        buff += self.format_aut_init_final_states()\n        buff += self.format_aut_init_footer()\n\n        return buff\n\n    def print_model_classic(self):\n        buff = self.format_model()\n        print(self.__buff_to_string(buff))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}