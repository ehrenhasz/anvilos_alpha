{
  "module_name": "dot2k.py",
  "hash_id": "987c961808b79f712ab1c77c86f82bcb48461a2870f3d9e0a1d4d78f4781961a",
  "original_prompt": "Ingested from linux-6.6.14/tools/verification/dot2/dot2k.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>\n#\n# dot2k: transform dot files into a monitor for the Linux kernel.\n#\n# For further information, see:\n#   Documentation/trace/rv/da_monitor_synthesis.rst\n\nfrom dot2.dot2c import Dot2c\nimport platform\nimport os\n\nclass dot2k(Dot2c):\n    monitor_types = { \"global\" : 1, \"per_cpu\" : 2, \"per_task\" : 3 }\n    monitor_templates_dir = \"dot2k/rv_templates/\"\n    monitor_type = \"per_cpu\"\n\n    def __init__(self, file_path, MonitorType):\n        super().__init__(file_path)\n\n        self.monitor_type = self.monitor_types.get(MonitorType)\n        if self.monitor_type == None:\n            raise Exception(\"Unknown monitor type: %s\" % MonitorType)\n\n        self.monitor_type = MonitorType\n        self.__fill_rv_templates_dir()\n        self.main_c = self.__open_file(self.monitor_templates_dir + \"main_\" + MonitorType + \".c\")\n        self.enum_suffix = \"_%s\" % self.name\n\n    def __fill_rv_templates_dir(self):\n\n        if os.path.exists(self.monitor_templates_dir) == True:\n            return\n\n        if platform.system() != \"Linux\":\n            raise Exception(\"I can only run on Linux.\")\n\n        kernel_path = \"/lib/modules/%s/build/tools/verification/dot2/dot2k_templates/\" % (platform.release())\n\n        if os.path.exists(kernel_path) == True:\n            self.monitor_templates_dir = kernel_path\n            return\n\n        if os.path.exists(\"/usr/share/dot2/dot2k_templates/\") == True:\n            self.monitor_templates_dir = \"/usr/share/dot2/dot2k_templates/\"\n            return\n\n        raise Exception(\"Could not find the template directory, do you have the kernel source installed?\")\n\n\n    def __open_file(self, path):\n        try:\n            fd = open(path)\n        except OSError:\n            raise Exception(\"Cannot open the file: %s\" % path)\n\n        content = fd.read()\n\n        return content\n\n    def __buff_to_string(self, buff):\n        string = \"\"\n\n        for line in buff:\n            string = string + line + \"\\n\"\n\n        # cut off the last \\n\n        return string[:-1]\n\n    def fill_tracepoint_handlers_skel(self):\n        buff = []\n        for event in self.events:\n            buff.append(\"static void handle_%s(void *data, /* XXX: fill header */)\" % event)\n            buff.append(\"{\")\n            if self.monitor_type == \"per_task\":\n                buff.append(\"\\tstruct task_struct *p = /* XXX: how do I get p? */;\");\n                buff.append(\"\\tda_handle_event_%s(p, %s%s);\" % (self.name, event, self.enum_suffix));\n            else:\n                buff.append(\"\\tda_handle_event_%s(%s%s);\" % (self.name, event, self.enum_suffix));\n            buff.append(\"}\")\n            buff.append(\"\")\n        return self.__buff_to_string(buff)\n\n    def fill_tracepoint_attach_probe(self):\n        buff = []\n        for event in self.events:\n            buff.append(\"\\trv_attach_trace_probe(\\\"%s\\\", /* XXX: tracepoint */, handle_%s);\" % (self.name, event))\n        return self.__buff_to_string(buff)\n\n    def fill_tracepoint_detach_helper(self):\n        buff = []\n        for event in self.events:\n            buff.append(\"\\trv_detach_trace_probe(\\\"%s\\\", /* XXX: tracepoint */, handle_%s);\" % (self.name, event))\n        return self.__buff_to_string(buff)\n\n    def fill_main_c(self):\n        main_c = self.main_c\n        min_type = self.get_minimun_type()\n        nr_events = self.events.__len__()\n        tracepoint_handlers = self.fill_tracepoint_handlers_skel()\n        tracepoint_attach = self.fill_tracepoint_attach_probe()\n        tracepoint_detach = self.fill_tracepoint_detach_helper()\n\n        main_c = main_c.replace(\"MIN_TYPE\", min_type)\n        main_c = main_c.replace(\"MODEL_NAME\", self.name)\n        main_c = main_c.replace(\"NR_EVENTS\", str(nr_events))\n        main_c = main_c.replace(\"TRACEPOINT_HANDLERS_SKEL\", tracepoint_handlers)\n        main_c = main_c.replace(\"TRACEPOINT_ATTACH\", tracepoint_attach)\n        main_c = main_c.replace(\"TRACEPOINT_DETACH\", tracepoint_detach)\n\n        return main_c\n\n    def fill_model_h_header(self):\n        buff = []\n        buff.append(\"/*\")\n        buff.append(\" * Automatically generated C representation of %s automaton\" % (self.name))\n        buff.append(\" * For further information about this format, see kernel documentation:\")\n        buff.append(\" *   Documentation/trace/rv/deterministic_automata.rst\")\n        buff.append(\" */\")\n        buff.append(\"\")\n\n        return buff\n\n    def fill_model_h(self):\n        #\n        # Adjust the definition names\n        #\n        self.enum_states_def = \"states_%s\" % self.name\n        self.enum_events_def = \"events_%s\" % self.name\n        self.struct_automaton_def = \"automaton_%s\" % self.name\n        self.var_automaton_def = \"automaton_%s\" % self.name\n\n        buff = self.fill_model_h_header()\n        buff += self.format_model()\n\n        return self.__buff_to_string(buff)\n\n    def __create_directory(self):\n        try:\n            os.mkdir(self.name)\n        except FileExistsError:\n            return\n        except:\n            print(\"Fail creating the output dir: %s\" % self.name)\n\n    def __create_file(self, file_name, content):\n        path = \"%s/%s\" % (self.name, file_name)\n        try:\n            file = open(path, 'w')\n        except FileExistsError:\n            return\n        except:\n            print(\"Fail creating file: %s\" % path)\n\n        file.write(content)\n\n        file.close()\n\n    def __get_main_name(self):\n        path = \"%s/%s\" % (self.name, \"main.c\")\n        if os.path.exists(path) == False:\n           return \"main.c\"\n        return \"__main.c\"\n\n    def print_files(self):\n        main_c = self.fill_main_c()\n        model_h = self.fill_model_h()\n\n        self.__create_directory()\n\n        path = \"%s.c\" % self.name\n        self.__create_file(path, main_c)\n\n        path = \"%s.h\" % self.name\n        self.__create_file(path, model_h)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}