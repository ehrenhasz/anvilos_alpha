{
  "module_name": "automata.py",
  "hash_id": "9e8962a849d0d6787bab3270ffa0f80c435ca1e0c233c9d42a475e55a1528fbc",
  "original_prompt": "Ingested from linux-6.6.14/tools/verification/dot2/automata.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>\n#\n# Automata object: parse an automata in dot file digraph format into a python object\n#\n# For further information, see:\n#   Documentation/trace/rv/deterministic_automata.rst\n\nimport ntpath\n\nclass Automata:\n    \"\"\"Automata class: Reads a dot file and part it as an automata.\n\n    Attributes:\n        dot_file: A dot file with an state_automaton definition.\n    \"\"\"\n\n    invalid_state_str = \"INVALID_STATE\"\n\n    def __init__(self, file_path):\n        self.__dot_path = file_path\n        self.name = self.__get_model_name()\n        self.__dot_lines = self.__open_dot()\n        self.states, self.initial_state, self.final_states = self.__get_state_variables()\n        self.events = self.__get_event_variables()\n        self.function = self.__create_matrix()\n\n    def __get_model_name(self):\n        basename = ntpath.basename(self.__dot_path)\n        if basename.endswith(\".dot\") == False:\n            print(\"not a dot file\")\n            raise Exception(\"not a dot file: %s\" % self.__dot_path)\n\n        model_name = basename[0:-4]\n        if model_name.__len__() == 0:\n            raise Exception(\"not a dot file: %s\" % self.__dot_path)\n\n        return model_name\n\n    def __open_dot(self):\n        cursor = 0\n        dot_lines = []\n        try:\n            dot_file = open(self.__dot_path)\n        except:\n            raise Exception(\"Cannot open the file: %s\" % self.__dot_path)\n\n        dot_lines = dot_file.read().splitlines()\n        dot_file.close()\n\n        # checking the first line:\n        line = dot_lines[cursor].split()\n\n        if (line[0] != \"digraph\") and (line[1] != \"state_automaton\"):\n            raise Exception(\"Not a valid .dot format: %s\" % self.__dot_path)\n        else:\n            cursor += 1\n        return dot_lines\n\n    def __get_cursor_begin_states(self):\n        cursor = 0\n        while self.__dot_lines[cursor].split()[0] != \"{node\":\n            cursor += 1\n        return cursor\n\n    def __get_cursor_begin_events(self):\n        cursor = 0\n        while self.__dot_lines[cursor].split()[0] != \"{node\":\n           cursor += 1\n        while self.__dot_lines[cursor].split()[0] == \"{node\":\n           cursor += 1\n        # skip initial state transition\n        cursor += 1\n        return cursor\n\n    def __get_state_variables(self):\n        # wait for node declaration\n        states = []\n        final_states = []\n\n        has_final_states = False\n        cursor = self.__get_cursor_begin_states()\n\n        # process nodes\n        while self.__dot_lines[cursor].split()[0] == \"{node\":\n            line = self.__dot_lines[cursor].split()\n            raw_state = line[-1]\n\n            #  \"enabled_fired\"}; -> enabled_fired\n            state = raw_state.replace('\"', '').replace('};', '').replace(',','_')\n            if state[0:7] == \"__init_\":\n                initial_state = state[7:]\n            else:\n                states.append(state)\n                if self.__dot_lines[cursor].__contains__(\"doublecircle\") == True:\n                    final_states.append(state)\n                    has_final_states = True\n\n                if self.__dot_lines[cursor].__contains__(\"ellipse\") == True:\n                    final_states.append(state)\n                    has_final_states = True\n\n            cursor += 1\n\n        states = sorted(set(states))\n        states.remove(initial_state)\n\n        # Insert the initial state at the bein og the states\n        states.insert(0, initial_state)\n\n        if has_final_states == False:\n            final_states.append(initial_state)\n\n        return states, initial_state, final_states\n\n    def __get_event_variables(self):\n        # here we are at the begin of transitions, take a note, we will return later.\n        cursor = self.__get_cursor_begin_events()\n\n        events = []\n        while self.__dot_lines[cursor][1] == '\"':\n            # transitions have the format:\n            # \"all_fired\" -> \"both_fired\" [ label = \"disable_irq\" ];\n            #  ------------ event is here ------------^^^^^\n            if self.__dot_lines[cursor].split()[1] == \"->\":\n                line = self.__dot_lines[cursor].split()\n                event = line[-2].replace('\"','')\n\n                # when a transition has more than one lables, they are like this\n                # \"local_irq_enable\\nhw_local_irq_enable_n\"\n                # so split them.\n\n                event = event.replace(\"\\\\n\", \" \")\n                for i in event.split():\n                    events.append(i)\n            cursor += 1\n\n        return sorted(set(events))\n\n    def __create_matrix(self):\n        # transform the array into a dictionary\n        events = self.events\n        states = self.states\n        events_dict = {}\n        states_dict = {}\n        nr_event = 0\n        for event in events:\n            events_dict[event] = nr_event\n            nr_event += 1\n\n        nr_state = 0\n        for state in states:\n            states_dict[state] = nr_state\n            nr_state += 1\n\n        # declare the matrix....\n        matrix = [[ self.invalid_state_str for x in range(nr_event)] for y in range(nr_state)]\n\n        # and we are back! Let's fill the matrix\n        cursor = self.__get_cursor_begin_events()\n\n        while self.__dot_lines[cursor][1] == '\"':\n            if self.__dot_lines[cursor].split()[1] == \"->\":\n                line = self.__dot_lines[cursor].split()\n                origin_state = line[0].replace('\"','').replace(',','_')\n                dest_state = line[2].replace('\"','').replace(',','_')\n                possible_events = line[-2].replace('\"','').replace(\"\\\\n\", \" \")\n                for event in possible_events.split():\n                    matrix[states_dict[origin_state]][events_dict[event]] = dest_state\n            cursor += 1\n\n        return matrix\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}