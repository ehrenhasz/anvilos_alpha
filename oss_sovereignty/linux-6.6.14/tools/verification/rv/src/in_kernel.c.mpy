{
  "module_name": "in_kernel.c",
  "hash_id": "66c4db4db964e4b27ca299be6167080ab97debe13e549fab1e86004be8c5da50",
  "original_prompt": "Ingested from linux-6.6.14/tools/verification/rv/src/in_kernel.c",
  "human_readable_source": "\n \n#include <getopt.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n\n#include <trace.h>\n#include <utils.h>\n#include <rv.h>\n\nstatic int config_has_id;\nstatic int config_my_pid;\nstatic int config_trace;\n\nstatic char *config_initial_reactor;\nstatic char *config_reactor;\n\n \nstatic int __ikm_read_enable(char *monitor_name)\n{\n\tchar path[MAX_PATH];\n\tlong long enabled;\n\tint retval;\n\n\tsnprintf(path, MAX_PATH, \"rv/monitors/%s/enable\", monitor_name);\n\n\tretval = tracefs_instance_file_read_number(NULL, path, &enabled);\n\tif (retval < 0)\n\t\treturn -1;\n\n\treturn enabled;\n}\n\n \nstatic int ikm_read_enable(char *monitor_name)\n{\n\tint enabled;\n\n\tenabled = __ikm_read_enable(monitor_name);\n\tif (enabled < 0) {\n\t\terr_msg(\"ikm: fail read enabled: %d\\n\", enabled);\n\t\treturn -1;\n\t}\n\n\tdebug_msg(\"ikm: read enabled: %d\\n\", enabled);\n\n\treturn enabled;\n}\n\n \nstatic int ikm_write_enable(char *monitor_name, char *enable_disable)\n{\n\tchar path[MAX_PATH];\n\tint retval;\n\n\tdebug_msg(\"ikm: writing enabled: %s\\n\", enable_disable);\n\n\tsnprintf(path, MAX_PATH, \"rv/monitors/%s/enable\", monitor_name);\n\tretval = tracefs_instance_file_write(NULL, path, enable_disable);\n\tif (retval < strlen(enable_disable)) {\n\t\terr_msg(\"ikm: writing enabled: %s\\n\", enable_disable);\n\t\treturn -1;\n\t}\n\n\treturn retval;\n}\n\n \nstatic int ikm_enable(char *monitor_name)\n{\n\treturn ikm_write_enable(monitor_name, \"1\");\n}\n\n \nstatic int ikm_disable(char *monitor_name)\n{\n\treturn ikm_write_enable(monitor_name, \"0\");\n}\n\n \nstatic char *ikm_read_desc(char *monitor_name)\n{\n\tchar path[MAX_PATH];\n\tchar *desc;\n\n\tsnprintf(path, MAX_PATH, \"rv/monitors/%s/desc\", monitor_name);\n\tdesc = tracefs_instance_file_read(NULL, path, NULL);\n\tif (!desc) {\n\t\terr_msg(\"ikm: error reading monitor %s desc\\n\", monitor_name);\n\t\treturn NULL;\n\t}\n\n\t*strstr(desc, \"\\n\") = '\\0';\n\n\treturn desc;\n}\n\n \nstatic int ikm_fill_monitor_definition(char *name, struct monitor *ikm)\n{\n\tint enabled;\n\tchar *desc;\n\n\tenabled = ikm_read_enable(name);\n\tif (enabled < 0) {\n\t\terr_msg(\"ikm: monitor %s fail to read enable file, bug?\\n\", name);\n\t\treturn -1;\n\t}\n\n\tdesc = ikm_read_desc(name);\n\tif (!desc) {\n\t\terr_msg(\"ikm: monitor %s does not have desc file, bug?\\n\", name);\n\t\treturn -1;\n\t}\n\n\tstrncpy(ikm->name, name, MAX_DA_NAME_LEN);\n\tikm->enabled = enabled;\n\tstrncpy(ikm->desc, desc, MAX_DESCRIPTION);\n\n\tfree(desc);\n\n\treturn 0;\n}\n\n \nstatic int ikm_write_reactor(char *monitor_name, char *reactor)\n{\n\tchar path[MAX_PATH];\n\tint retval;\n\n\tsnprintf(path, MAX_PATH, \"rv/monitors/%s/reactors\", monitor_name);\n\tretval = tracefs_instance_file_write(NULL, path, reactor);\n\tdebug_msg(\"ikm: write \\\"%s\\\" reactors: %d\\n\", reactor, retval);\n\n\treturn retval;\n}\n\n \nstatic char *ikm_read_reactor(char *monitor_name)\n{\n\tchar path[MAX_PATH];\n\tchar *reactors;\n\n\tsnprintf(path, MAX_PATH, \"rv/monitors/%s/reactors\", monitor_name);\n\treactors = tracefs_instance_file_read(NULL, path, NULL);\n\tif (!reactors) {\n\t\terr_msg(\"ikm: fail reading monitor's %s reactors file\\n\", monitor_name);\n\t\treturn NULL;\n\t}\n\n\treturn reactors;\n}\n\n \nstatic char *ikm_get_current_reactor(char *monitor_name)\n{\n\tchar *reactors = ikm_read_reactor(monitor_name);\n\tchar *start;\n\tchar *end;\n\tchar *curr_reactor;\n\n\tif (!reactors)\n\t\treturn NULL;\n\n\tstart = strstr(reactors, \"[\");\n\tif (!start)\n\t\tgoto out_free;\n\n\tstart++;\n\n\tend = strstr(start, \"]\");\n\tif (!end)\n\t\tgoto out_free;\n\n\t*end = '\\0';\n\n\tcurr_reactor = calloc(strlen(start) + 1, sizeof(char));\n\tif (!curr_reactor)\n\t\tgoto out_free;\n\n\tstrncpy(curr_reactor, start, strlen(start));\n\tdebug_msg(\"ikm: read current reactor %s\\n\", curr_reactor);\n\nout_free:\n\tfree(reactors);\n\n\treturn curr_reactor;\n}\n\nstatic int ikm_has_id(char *monitor_name)\n{\n\tchar path[MAX_PATH];\n\tchar *format;\n\tint has_id;\n\n\tsnprintf(path, MAX_PATH, \"events/rv/event_%s/format\", monitor_name);\n\tformat = tracefs_instance_file_read(NULL, path, NULL);\n\tif (!format) {\n\t\terr_msg(\"ikm: fail reading monitor's %s format event file\\n\", monitor_name);\n\t\treturn -1;\n\t}\n\n\t \n\thas_id = !!strstr(format, \"REC->id\");\n\n\tdebug_msg(\"ikm: monitor %s has id: %s\\n\", monitor_name, has_id ? \"yes\" : \"no\");\n\n\tfree(format);\n\n\treturn has_id;\n}\n\n \nint ikm_list_monitors(void)\n{\n\tchar *available_monitors;\n\tstruct monitor ikm;\n\tchar *curr, *next;\n\tint retval;\n\n\tavailable_monitors = tracefs_instance_file_read(NULL, \"rv/available_monitors\", NULL);\n\n\tif (!available_monitors) {\n\t\terr_msg(\"ikm: available monitors is not available, is CONFIG_RV enabled?\\n\");\n\t\treturn -1;\n\t}\n\n\tcurr = available_monitors;\n\tdo {\n\t\tnext = strstr(curr, \"\\n\");\n\t\t*next = '\\0';\n\n\t\tretval = ikm_fill_monitor_definition(curr, &ikm);\n\t\tif (retval)\n\t\t\terr_msg(\"ikm: error reading %d in kernel monitor, skipping\\n\", curr);\n\n\t\tprintf(\"%-24s %s %s\\n\", ikm.name, ikm.desc, ikm.enabled ? \"[ON]\" : \"[OFF]\");\n\t\tcurr = ++next;\n\n\t} while (strlen(curr));\n\n\tfree(available_monitors);\n\n\treturn 0;\n}\n\nstatic void ikm_print_header(struct trace_seq *s)\n{\n\ttrace_seq_printf(s, \"%16s-%-8s %5s %5s \", \"<TASK>\", \"PID\", \"[CPU]\", \"TYPE\");\n\tif (config_has_id)\n\t\ttrace_seq_printf(s, \"%8s \", \"ID\");\n\n\ttrace_seq_printf(s, \"%24s x %-24s -> %-24s %s\\n\",\n\t\t\t \"STATE\",\n\t\t\t \"EVENT\",\n\t\t\t \"NEXT_STATE\",\n\t\t\t \"FINAL\");\n\n\ttrace_seq_printf(s, \"%16s %-8s %5s %5s \", \" | \", \" | \", \" | \", \" | \");\n\n\tif (config_has_id)\n\t\ttrace_seq_printf(s, \"%8s \", \" | \");\n\n\ttrace_seq_printf(s, \"%24s   %-24s    %-24s %s\\n\",\n\t\t\t \" | \",\n\t\t\t \" | \",\n\t\t\t \" | \",\n\t\t\t \"|\");\n\n}\n\n \nstatic int\nikm_event_handler(struct trace_seq *s, struct tep_record *record,\n\t\t  struct tep_event *trace_event, void *context)\n{\n\t \n\tchar *state, *event, *next_state;\n\tunsigned long long final_state;\n\tunsigned long long pid;\n\tunsigned long long id;\n\tint cpu = record->cpu;\n\tint val;\n\n\tif (config_has_id)\n\t\ttep_get_field_val(s, trace_event, \"id\", record, &id, 1);\n\n\ttep_get_common_field_val(s, trace_event, \"common_pid\", record, &pid, 1);\n\n\tif (config_has_id && (config_my_pid == id))\n\t\treturn 0;\n\telse if (config_my_pid && (config_my_pid == pid))\n\t\treturn 0;\n\n\ttep_print_event(trace_event->tep, s, record, \"%16s-%-8d \", TEP_PRINT_COMM, TEP_PRINT_PID);\n\n\ttrace_seq_printf(s, \"[%.3d] event \", cpu);\n\n\tif (config_has_id)\n\t\ttrace_seq_printf(s, \"%8llu \", id);\n\n\tstate = tep_get_field_raw(s, trace_event, \"state\", record, &val, 0);\n\tevent = tep_get_field_raw(s, trace_event, \"event\", record, &val, 0);\n\tnext_state = tep_get_field_raw(s, trace_event, \"next_state\", record, &val, 0);\n\ttep_get_field_val(s, trace_event, \"final_state\", record, &final_state, 1);\n\n\ttrace_seq_printf(s, \"%24s x %-24s -> %-24s %s\\n\",\n\t\t\t state,\n\t\t\t event,\n\t\t\t next_state,\n\t\t\t final_state ? \"Y\" : \"N\");\n\n\ttrace_seq_do_printf(s);\n\ttrace_seq_reset(s);\n\n\treturn 0;\n}\n\n \nstatic int\nikm_error_handler(struct trace_seq *s, struct tep_record *record,\n\t\t  struct tep_event *trace_event, void *context)\n{\n\tunsigned long long pid, id;\n\tint cpu = record->cpu;\n\tchar *state, *event;\n\tint val;\n\n\tif (config_has_id)\n\t\ttep_get_field_val(s, trace_event, \"id\", record, &id, 1);\n\n\ttep_get_common_field_val(s, trace_event, \"common_pid\", record, &pid, 1);\n\n\tif (config_has_id && config_my_pid == id)\n\t\treturn 0;\n\telse if (config_my_pid == pid)\n\t\treturn 0;\n\n\ttrace_seq_printf(s, \"%8lld [%03d] error \", pid, cpu);\n\n\tif (config_has_id)\n\t\ttrace_seq_printf(s, \"%8llu \", id);\n\n\tstate = tep_get_field_raw(s, trace_event, \"state\", record, &val, 0);\n\tevent = tep_get_field_raw(s, trace_event, \"event\", record, &val, 0);\n\n\ttrace_seq_printf(s, \"%24s x %s\\n\", state, event);\n\n\ttrace_seq_do_printf(s);\n\ttrace_seq_reset(s);\n\n\treturn 0;\n}\n\n \nstatic struct trace_instance *ikm_setup_trace_instance(char *monitor_name)\n{\n\tchar event[MAX_DA_NAME_LEN + 7];  \n\tstruct trace_instance *inst;\n\tint retval;\n\n\tif (!config_trace)\n\t\treturn NULL;\n\n\tconfig_has_id = ikm_has_id(monitor_name);\n\tif (config_has_id < 0) {\n\t\terr_msg(\"ikm: failed to read monitor %s event format\\n\", monitor_name);\n\t\tgoto out_err;\n\t}\n\n\t \n\tinst = calloc(1, sizeof(*inst));\n\tif (!inst) {\n\t\terr_msg(\"ikm: failed to allocate trace instance\");\n\t\tgoto out_err;\n\t}\n\n\tretval = trace_instance_init(inst, monitor_name);\n\tif (retval)\n\t\tgoto out_free;\n\n\t \n\tsnprintf(event, sizeof(event), \"event_%s\", monitor_name);\n\tretval = tracefs_event_enable(inst->inst, \"rv\",  event);\n\tif (retval)\n\t\tgoto out_inst;\n\n\ttep_register_event_handler(inst->tep, -1, \"rv\", event,\n\t\t\t\t   ikm_event_handler, NULL);\n\n\tsnprintf(event, sizeof(event), \"error_%s\", monitor_name);\n\tretval = tracefs_event_enable(inst->inst, \"rv\", event);\n\tif (retval)\n\t\tgoto out_inst;\n\n\ttep_register_event_handler(inst->tep, -1, \"rv\", event,\n\t\t\t\t   ikm_error_handler, NULL);\n\n\t \n\ttracefs_trace_on(inst->inst);\n\n\treturn inst;\n\nout_inst:\n\ttrace_instance_destroy(inst);\nout_free:\n\tfree(inst);\nout_err:\n\treturn NULL;\n}\n\n \nstatic void ikm_destroy_trace_instance(struct trace_instance *inst)\n{\n\tif (!inst)\n\t\treturn;\n\n\ttrace_instance_destroy(inst);\n\tfree(inst);\n}\n\n \nstatic void ikm_usage_print_reactors(void)\n{\n\tchar *reactors = tracefs_instance_file_read(NULL, \"rv/available_reactors\", NULL);\n\tchar *start, *end;\n\n\tif (!reactors)\n\t\treturn;\n\n\tfprintf(stderr, \"  available reactors:\");\n\n\tstart = reactors;\n\tend = strstr(start, \"\\n\");\n\n\twhile (end) {\n\t\t*end = '\\0';\n\n\t\tfprintf(stderr, \" %s\", start);\n\n\t\tstart = ++end;\n\t\tend = strstr(start, \"\\n\");\n\t}\n\n\tfprintf(stderr, \"\\n\");\n}\n \nstatic void ikm_usage(int exit_val, char *monitor_name, const char *fmt, ...)\n{\n\n\tchar message[1024];\n\tva_list ap;\n\tint i;\n\n\tstatic const char *const usage[] = {\n\t\t\"\",\n\t\t\"\t-h/--help: print this menu and the reactor list\",\n\t\t\"\t-r/--reactor 'reactor': enables the 'reactor'\",\n\t\t\"\t-s/--self: when tracing (-t), also trace rv command\",\n\t\t\"\t-t/--trace: trace monitor's event\",\n\t\t\"\t-v/--verbose: print debug messages\",\n\t\t\"\",\n\t\tNULL,\n\t};\n\n\tva_start(ap, fmt);\n\tvsnprintf(message, sizeof(message), fmt, ap);\n\tva_end(ap);\n\n\tfprintf(stderr, \"  %s\\n\", message);\n\n\tfprintf(stderr, \"\\n  usage: rv mon %s [-h] [-q] [-r reactor] [-s] [-v]\", monitor_name);\n\n\tfor (i = 0; usage[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", usage[i]);\n\n\tikm_usage_print_reactors();\n\texit(exit_val);\n}\n\n \nstatic int parse_arguments(char *monitor_name, int argc, char **argv)\n{\n\tint c, retval;\n\n\tconfig_my_pid = getpid();\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"help\",\t\tno_argument,\t\t0, 'h'},\n\t\t\t{\"reactor\",\t\trequired_argument,\t0, 'r'},\n\t\t\t{\"self\",\t\tno_argument,\t\t0, 's'},\n\t\t\t{\"trace\",\t\tno_argument,\t\t0, 't'},\n\t\t\t{\"verbose\",\t\tno_argument,\t\t0, 'v'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\t \n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"hr:stv\", long_options, &option_index);\n\n\t\t \n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tikm_usage(0, monitor_name, \"help:\");\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tconfig_reactor = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tconfig_my_pid = 0;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tconfig_trace = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tconfig_debug = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (config_reactor) {\n\t\tconfig_initial_reactor = ikm_get_current_reactor(monitor_name);\n\t\tif (!config_initial_reactor)\n\t\t\tikm_usage(1, monitor_name,\n\t\t\t\t  \"ikm: failed to read current reactor, are reactors enabled?\");\n\n\t\tretval = ikm_write_reactor(monitor_name, config_reactor);\n\t\tif (retval <= 0)\n\t\t\tikm_usage(1, monitor_name,\n\t\t\t\t  \"ikm: failed to set %s reactor, is it available?\",\n\t\t\t\t  config_reactor);\n\t}\n\n\tdebug_msg(\"ikm: my pid is %d\\n\", config_my_pid);\n\n\treturn 0;\n}\n\n \nint ikm_run_monitor(char *monitor_name, int argc, char **argv)\n{\n\tstruct trace_instance *inst = NULL;\n\tint retval;\n\n\t \n\tretval = __ikm_read_enable(monitor_name);\n\tif (retval < 0)\n\t\treturn 0;\n\n\tif (retval) {\n\t\terr_msg(\"ikm: monitor %s (in-kernel) is already enabled\\n\", monitor_name);\n\t\treturn -1;\n\t}\n\n\t \n\tretval = parse_arguments(monitor_name, argc, argv);\n\tif (retval)\n\t\tikm_usage(1, monitor_name, \"ikm: failed parsing arguments\");\n\n\tif (config_trace) {\n\t\tinst = ikm_setup_trace_instance(monitor_name);\n\t\tif (!inst)\n\t\t\treturn -1;\n\t}\n\n\tretval = ikm_enable(monitor_name);\n\tif (retval < 0)\n\t\tgoto out_free_instance;\n\n\tif (config_trace)\n\t\tikm_print_header(inst->seq);\n\n\twhile (!should_stop()) {\n\t\tif (config_trace) {\n\t\t\tretval = tracefs_iterate_raw_events(inst->tep,\n\t\t\t\t\t\t\t    inst->inst,\n\t\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t\t    0,\n\t\t\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t\t\t    inst);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"ikm: error reading trace buffer\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsleep(1);\n\t}\n\n\tikm_disable(monitor_name);\n\tikm_destroy_trace_instance(inst);\n\n\tif (config_reactor && config_initial_reactor)\n\t\tikm_write_reactor(monitor_name, config_initial_reactor);\n\n\treturn 1;\n\nout_free_instance:\n\tikm_destroy_trace_instance(inst);\n\tif (config_reactor && config_initial_reactor)\n\t\tikm_write_reactor(monitor_name, config_initial_reactor);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}