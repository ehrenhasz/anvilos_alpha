{
  "module_name": "print-cert-tbs-hash.sh",
  "hash_id": "0fba4a188e02ca8a87594134e9a033e8d565d67a047300a11b00a16ac50dfbef",
  "original_prompt": "Ingested from linux-6.6.14/tools/certs/print-cert-tbs-hash.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright \u00a9 2020, Microsoft Corporation. All rights reserved.\n#\n# Author: Micka\u00ebl Sala\u00fcn <mic@linux.microsoft.com>\n#\n# Compute and print the To Be Signed (TBS) hash of a certificate.  This is used\n# as description of keys in the blacklist keyring to identify certificates.\n# This output should be redirected, without newline, in a file (hash0.txt) and\n# signed to create a PKCS#7 file (hash0.p7s).  Both of these files can then be\n# loaded in the kernel with.\n#\n# Exemple on a workstation:\n# ./print-cert-tbs-hash.sh certificate-to-invalidate.pem > hash0.txt\n# openssl smime -sign -in hash0.txt -inkey builtin-private-key.pem \\\n#               -signer builtin-certificate.pem -certfile certificate-chain.pem \\\n#               -noattr -binary -outform DER -out hash0.p7s\n#\n# Exemple on a managed system:\n# keyctl padd blacklist \"$(< hash0.txt)\" %:.blacklist < hash0.p7s\n\nset -u -e -o pipefail\n\nCERT=\"${1:-}\"\nBASENAME=\"$(basename -- \"${BASH_SOURCE[0]}\")\"\n\nif [ $# -ne 1 ] || [ ! -f \"${CERT}\" ]; then\n\techo \"usage: ${BASENAME} <certificate>\" >&2\n\texit 1\nfi\n\n# Checks that it is indeed a certificate (PEM or DER encoded) and exclude the\n# optional PEM text header.\nif ! PEM=\"$(openssl x509 -inform DER -in \"${CERT}\" 2>/dev/null || openssl x509 -in \"${CERT}\")\"; then\n\techo \"ERROR: Failed to parse certificate\" >&2\n\texit 1\nfi\n\n# TBSCertificate starts at the second entry.\n# Cf. https://tools.ietf.org/html/rfc3280#section-4.1\n#\n# Exemple of first lines printed by openssl asn1parse:\n#    0:d=0  hl=4 l= 763 cons: SEQUENCE\n#    4:d=1  hl=4 l= 483 cons: SEQUENCE\n#    8:d=2  hl=2 l=   3 cons: cont [ 0 ]\n#   10:d=3  hl=2 l=   1 prim: INTEGER           :02\n#   13:d=2  hl=2 l=  20 prim: INTEGER           :3CEB2CB8818D968AC00EEFE195F0DF9665328B7B\n#   35:d=2  hl=2 l=  13 cons: SEQUENCE\n#   37:d=3  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption\nRANGE_AND_DIGEST_RE='\n2s/^\\s*\\([0-9]\\+\\):d=\\s*[0-9]\\+\\s\\+hl=\\s*[0-9]\\+\\s\\+l=\\s*\\([0-9]\\+\\)\\s\\+cons:\\s*SEQUENCE\\s*$/\\1 \\2/p;\n7s/^\\s*[0-9]\\+:d=\\s*[0-9]\\+\\s\\+hl=\\s*[0-9]\\+\\s\\+l=\\s*[0-9]\\+\\s\\+prim:\\s*OBJECT\\s*:\\(.*\\)$/\\1/p;\n'\n\nRANGE_AND_DIGEST=($(echo \"${PEM}\" | \\\n\topenssl asn1parse -in - | \\\n\tsed -n -e \"${RANGE_AND_DIGEST_RE}\"))\n\nif [ \"${#RANGE_AND_DIGEST[@]}\" != 3 ]; then\n\techo \"ERROR: Failed to parse TBSCertificate.\" >&2\n\texit 1\nfi\n\nOFFSET=\"${RANGE_AND_DIGEST[0]}\"\nEND=\"$(( OFFSET + RANGE_AND_DIGEST[1] ))\"\nDIGEST=\"${RANGE_AND_DIGEST[2]}\"\n\n# The signature hash algorithm is used by Linux to blacklist certificates.\n# Cf. crypto/asymmetric_keys/x509_cert_parser.c:x509_note_pkey_algo()\nDIGEST_MATCH=\"\"\nwhile read -r DIGEST_ITEM; do\n\tif [ -z \"${DIGEST_ITEM}\" ]; then\n\t\tbreak\n\tfi\n\tif echo \"${DIGEST}\" | grep -qiF \"${DIGEST_ITEM}\"; then\n\t\tDIGEST_MATCH=\"${DIGEST_ITEM}\"\n\t\tbreak\n\tfi\ndone < <(openssl list -digest-commands | tr ' ' '\\n' | sort -ur)\n\nif [ -z \"${DIGEST_MATCH}\" ]; then\n\techo \"ERROR: Unknown digest algorithm: ${DIGEST}\" >&2\n\texit 1\nfi\n\necho \"${PEM}\" | \\\n\topenssl x509 -in - -outform DER | \\\n\tdd \"bs=1\" \"skip=${OFFSET}\" \"count=${END}\" \"status=none\" | \\\n\topenssl dgst \"-${DIGEST_MATCH}\" - | \\\n\tawk '{printf \"tbs:\" $2}'\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}