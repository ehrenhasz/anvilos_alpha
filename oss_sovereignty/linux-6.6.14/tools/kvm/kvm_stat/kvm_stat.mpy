{
  "module_name": "kvm_stat",
  "hash_id": "545c866692db69df6642993d75baebd877db3317e6a2197543cd6731be37b0d3",
  "original_prompt": "Ingested from linux-6.6.14/tools/kvm/kvm_stat/kvm_stat",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# top-like utility for displaying kvm statistics\n#\n# Copyright 2006-2008 Qumranet Technologies\n# Copyright 2008-2011 Red Hat, Inc.\n#\n# Authors:\n#  Avi Kivity <avi@redhat.com>\n#\n\"\"\"The kvm_stat module outputs statistics about running KVM VMs\n\nThree different ways of output formatting are available:\n- as a top-like text ui\n- in a key -> value format\n- in an all keys, all values format\n\nThe data is sampled from the KVM's debugfs entries and its perf events.\n\"\"\"\nfrom __future__ import print_function\n\nimport curses\nimport sys\nimport locale\nimport os\nimport time\nimport argparse\nimport ctypes\nimport fcntl\nimport resource\nimport struct\nimport re\nimport subprocess\nimport signal\nfrom collections import defaultdict, namedtuple\nfrom functools import reduce\nfrom datetime import datetime\n\nVMX_EXIT_REASONS = {\n    'EXCEPTION_NMI':        0,\n    'EXTERNAL_INTERRUPT':   1,\n    'TRIPLE_FAULT':         2,\n    'INIT_SIGNAL':          3,\n    'SIPI_SIGNAL':          4,\n    'INTERRUPT_WINDOW':     7,\n    'NMI_WINDOW':           8,\n    'TASK_SWITCH':          9,\n    'CPUID':                10,\n    'HLT':                  12,\n    'INVD':                 13,\n    'INVLPG':               14,\n    'RDPMC':                15,\n    'RDTSC':                16,\n    'VMCALL':               18,\n    'VMCLEAR':              19,\n    'VMLAUNCH':             20,\n    'VMPTRLD':              21,\n    'VMPTRST':              22,\n    'VMREAD':               23,\n    'VMRESUME':             24,\n    'VMWRITE':              25,\n    'VMOFF':                26,\n    'VMON':                 27,\n    'CR_ACCESS':            28,\n    'DR_ACCESS':            29,\n    'IO_INSTRUCTION':       30,\n    'MSR_READ':             31,\n    'MSR_WRITE':            32,\n    'INVALID_STATE':        33,\n    'MSR_LOAD_FAIL':        34,\n    'MWAIT_INSTRUCTION':    36,\n    'MONITOR_TRAP_FLAG':    37,\n    'MONITOR_INSTRUCTION':  39,\n    'PAUSE_INSTRUCTION':    40,\n    'MCE_DURING_VMENTRY':   41,\n    'TPR_BELOW_THRESHOLD':  43,\n    'APIC_ACCESS':          44,\n    'EOI_INDUCED':          45,\n    'GDTR_IDTR':            46,\n    'LDTR_TR':              47,\n    'EPT_VIOLATION':        48,\n    'EPT_MISCONFIG':        49,\n    'INVEPT':               50,\n    'RDTSCP':               51,\n    'PREEMPTION_TIMER':     52,\n    'INVVPID':              53,\n    'WBINVD':               54,\n    'XSETBV':               55,\n    'APIC_WRITE':           56,\n    'RDRAND':               57,\n    'INVPCID':              58,\n    'VMFUNC':               59,\n    'ENCLS':                60,\n    'RDSEED':               61,\n    'PML_FULL':             62,\n    'XSAVES':               63,\n    'XRSTORS':              64,\n    'UMWAIT':               67,\n    'TPAUSE':               68,\n    'BUS_LOCK':             74,\n    'NOTIFY':               75,\n}\n\nSVM_EXIT_REASONS = {\n    'READ_CR0':       0x000,\n    'READ_CR2':       0x002,\n    'READ_CR3':       0x003,\n    'READ_CR4':       0x004,\n    'READ_CR8':       0x008,\n    'WRITE_CR0':      0x010,\n    'WRITE_CR2':      0x012,\n    'WRITE_CR3':      0x013,\n    'WRITE_CR4':      0x014,\n    'WRITE_CR8':      0x018,\n    'READ_DR0':       0x020,\n    'READ_DR1':       0x021,\n    'READ_DR2':       0x022,\n    'READ_DR3':       0x023,\n    'READ_DR4':       0x024,\n    'READ_DR5':       0x025,\n    'READ_DR6':       0x026,\n    'READ_DR7':       0x027,\n    'WRITE_DR0':      0x030,\n    'WRITE_DR1':      0x031,\n    'WRITE_DR2':      0x032,\n    'WRITE_DR3':      0x033,\n    'WRITE_DR4':      0x034,\n    'WRITE_DR5':      0x035,\n    'WRITE_DR6':      0x036,\n    'WRITE_DR7':      0x037,\n    'EXCP_BASE':      0x040,\n    'LAST_EXCP':      0x05f,\n    'INTR':           0x060,\n    'NMI':            0x061,\n    'SMI':            0x062,\n    'INIT':           0x063,\n    'VINTR':          0x064,\n    'CR0_SEL_WRITE':  0x065,\n    'IDTR_READ':      0x066,\n    'GDTR_READ':      0x067,\n    'LDTR_READ':      0x068,\n    'TR_READ':        0x069,\n    'IDTR_WRITE':     0x06a,\n    'GDTR_WRITE':     0x06b,\n    'LDTR_WRITE':     0x06c,\n    'TR_WRITE':       0x06d,\n    'RDTSC':          0x06e,\n    'RDPMC':          0x06f,\n    'PUSHF':          0x070,\n    'POPF':           0x071,\n    'CPUID':          0x072,\n    'RSM':            0x073,\n    'IRET':           0x074,\n    'SWINT':          0x075,\n    'INVD':           0x076,\n    'PAUSE':          0x077,\n    'HLT':            0x078,\n    'INVLPG':         0x079,\n    'INVLPGA':        0x07a,\n    'IOIO':           0x07b,\n    'MSR':            0x07c,\n    'TASK_SWITCH':    0x07d,\n    'FERR_FREEZE':    0x07e,\n    'SHUTDOWN':       0x07f,\n    'VMRUN':          0x080,\n    'VMMCALL':        0x081,\n    'VMLOAD':         0x082,\n    'VMSAVE':         0x083,\n    'STGI':           0x084,\n    'CLGI':           0x085,\n    'SKINIT':         0x086,\n    'RDTSCP':         0x087,\n    'ICEBP':          0x088,\n    'WBINVD':         0x089,\n    'MONITOR':        0x08a,\n    'MWAIT':          0x08b,\n    'MWAIT_COND':     0x08c,\n    'XSETBV':         0x08d,\n    'RDPRU':          0x08e,\n    'EFER_WRITE_TRAP':           0x08f,\n    'CR0_WRITE_TRAP':            0x090,\n    'CR1_WRITE_TRAP':            0x091,\n    'CR2_WRITE_TRAP':            0x092,\n    'CR3_WRITE_TRAP':            0x093,\n    'CR4_WRITE_TRAP':            0x094,\n    'CR5_WRITE_TRAP':            0x095,\n    'CR6_WRITE_TRAP':            0x096,\n    'CR7_WRITE_TRAP':            0x097,\n    'CR8_WRITE_TRAP':            0x098,\n    'CR9_WRITE_TRAP':            0x099,\n    'CR10_WRITE_TRAP':           0x09a,\n    'CR11_WRITE_TRAP':           0x09b,\n    'CR12_WRITE_TRAP':           0x09c,\n    'CR13_WRITE_TRAP':           0x09d,\n    'CR14_WRITE_TRAP':           0x09e,\n    'CR15_WRITE_TRAP':           0x09f,\n    'INVPCID':        0x0a2,\n    'NPF':            0x400,\n    'AVIC_INCOMPLETE_IPI':       0x401,\n    'AVIC_UNACCELERATED_ACCESS': 0x402,\n    'VMGEXIT':        0x403,\n}\n\n# EC definition of HSR (from arch/arm64/include/asm/esr.h)\nAARCH64_EXIT_REASONS = {\n    'UNKNOWN':      0x00,\n    'WFx':          0x01,\n    'CP15_32':      0x03,\n    'CP15_64':      0x04,\n    'CP14_MR':      0x05,\n    'CP14_LS':      0x06,\n    'FP_ASIMD':     0x07,\n    'CP10_ID':      0x08,\n    'PAC':          0x09,\n    'CP14_64':      0x0C,\n    'BTI':          0x0D,\n    'ILL':          0x0E,\n    'SVC32':        0x11,\n    'HVC32':        0x12,\n    'SMC32':        0x13,\n    'SVC64':        0x15,\n    'HVC64':        0x16,\n    'SMC64':        0x17,\n    'SYS64':        0x18,\n    'SVE':          0x19,\n    'ERET':         0x1A,\n    'FPAC':         0x1C,\n    'SME':          0x1D,\n    'IMP_DEF':      0x1F,\n    'IABT_LOW':     0x20,\n    'IABT_CUR':     0x21,\n    'PC_ALIGN':     0x22,\n    'DABT_LOW':     0x24,\n    'DABT_CUR':     0x25,\n    'SP_ALIGN':     0x26,\n    'FP_EXC32':     0x28,\n    'FP_EXC64':     0x2C,\n    'SERROR':       0x2F,\n    'BREAKPT_LOW':  0x30,\n    'BREAKPT_CUR':  0x31,\n    'SOFTSTP_LOW':  0x32,\n    'SOFTSTP_CUR':  0x33,\n    'WATCHPT_LOW':  0x34,\n    'WATCHPT_CUR':  0x35,\n    'BKPT32':       0x38,\n    'VECTOR32':     0x3A,\n    'BRK64':        0x3C,\n}\n\n# From include/uapi/linux/kvm.h, KVM_EXIT_xxx\nUSERSPACE_EXIT_REASONS = {\n    'UNKNOWN':          0,\n    'EXCEPTION':        1,\n    'IO':               2,\n    'HYPERCALL':        3,\n    'DEBUG':            4,\n    'HLT':              5,\n    'MMIO':             6,\n    'IRQ_WINDOW_OPEN':  7,\n    'SHUTDOWN':         8,\n    'FAIL_ENTRY':       9,\n    'INTR':             10,\n    'SET_TPR':          11,\n    'TPR_ACCESS':       12,\n    'S390_SIEIC':       13,\n    'S390_RESET':       14,\n    'DCR':              15,\n    'NMI':              16,\n    'INTERNAL_ERROR':   17,\n    'OSI':              18,\n    'PAPR_HCALL':       19,\n    'S390_UCONTROL':    20,\n    'WATCHDOG':         21,\n    'S390_TSCH':        22,\n    'EPR':              23,\n    'SYSTEM_EVENT':     24,\n    'S390_STSI':        25,\n    'IOAPIC_EOI':       26,\n    'HYPERV':           27,\n    'ARM_NISV':         28,\n    'X86_RDMSR':        29,\n    'X86_WRMSR':        30,\n    'DIRTY_RING_FULL':  31,\n    'AP_RESET_HOLD':    32,\n    'X86_BUS_LOCK':     33,\n    'XEN':              34,\n    'RISCV_SBI':        35,\n    'RISCV_CSR':        36,\n    'NOTIFY':           37,\n}\n\nIOCTL_NUMBERS = {\n    'SET_FILTER':  0x40082406,\n    'ENABLE':      0x00002400,\n    'DISABLE':     0x00002401,\n    'RESET':       0x00002403,\n}\n\nsignal_received = False\n\nENCODING = locale.getpreferredencoding(False)\nTRACE_FILTER = re.compile(r'^[^\\(]*$')\n\n\nclass Arch(object):\n    \"\"\"Encapsulates global architecture specific data.\n\n    Contains the performance event open syscall and ioctl numbers, as\n    well as the VM exit reasons for the architecture it runs on.\n\n    \"\"\"\n    @staticmethod\n    def get_arch():\n        machine = os.uname()[4]\n\n        if machine.startswith('ppc'):\n            return ArchPPC()\n        elif machine.startswith('aarch64'):\n            return ArchA64()\n        elif machine.startswith('s390'):\n            return ArchS390()\n        else:\n            # X86_64\n            for line in open('/proc/cpuinfo'):\n                if not line.startswith('flags'):\n                    continue\n\n                flags = line.split()\n                if 'vmx' in flags:\n                    return ArchX86(VMX_EXIT_REASONS)\n                if 'svm' in flags:\n                    return ArchX86(SVM_EXIT_REASONS)\n                return\n\n    def tracepoint_is_child(self, field):\n        if (TRACE_FILTER.match(field)):\n            return None\n        return field.split('(', 1)[0]\n\n\nclass ArchX86(Arch):\n    def __init__(self, exit_reasons):\n        self.sc_perf_evt_open = 298\n        self.ioctl_numbers = IOCTL_NUMBERS\n        self.exit_reason_field = 'exit_reason'\n        self.exit_reasons = exit_reasons\n\n    def debugfs_is_child(self, field):\n        \"\"\" Returns name of parent if 'field' is a child, None otherwise \"\"\"\n        return None\n\n\nclass ArchPPC(Arch):\n    def __init__(self):\n        self.sc_perf_evt_open = 319\n        self.ioctl_numbers = IOCTL_NUMBERS\n        self.ioctl_numbers['ENABLE'] = 0x20002400\n        self.ioctl_numbers['DISABLE'] = 0x20002401\n        self.ioctl_numbers['RESET'] = 0x20002403\n\n        # PPC comes in 32 and 64 bit and some generated ioctl\n        # numbers depend on the wordsize.\n        char_ptr_size = ctypes.sizeof(ctypes.c_char_p)\n        self.ioctl_numbers['SET_FILTER'] = 0x80002406 | char_ptr_size << 16\n        self.exit_reason_field = 'exit_nr'\n        self.exit_reasons = {}\n\n    def debugfs_is_child(self, field):\n        \"\"\" Returns name of parent if 'field' is a child, None otherwise \"\"\"\n        return None\n\n\nclass ArchA64(Arch):\n    def __init__(self):\n        self.sc_perf_evt_open = 241\n        self.ioctl_numbers = IOCTL_NUMBERS\n        self.exit_reason_field = 'esr_ec'\n        self.exit_reasons = AARCH64_EXIT_REASONS\n\n    def debugfs_is_child(self, field):\n        \"\"\" Returns name of parent if 'field' is a child, None otherwise \"\"\"\n        return None\n\n\nclass ArchS390(Arch):\n    def __init__(self):\n        self.sc_perf_evt_open = 331\n        self.ioctl_numbers = IOCTL_NUMBERS\n        self.exit_reason_field = None\n        self.exit_reasons = None\n\n    def debugfs_is_child(self, field):\n        \"\"\" Returns name of parent if 'field' is a child, None otherwise \"\"\"\n        if field.startswith('instruction_'):\n            return 'exit_instruction'\n\n\nARCH = Arch.get_arch()\n\n\nclass perf_event_attr(ctypes.Structure):\n    \"\"\"Struct that holds the necessary data to set up a trace event.\n\n    For an extensive explanation see perf_event_open(2) and\n    include/uapi/linux/perf_event.h, struct perf_event_attr\n\n    All fields that are not initialized in the constructor are 0.\n\n    \"\"\"\n    _fields_ = [('type', ctypes.c_uint32),\n                ('size', ctypes.c_uint32),\n                ('config', ctypes.c_uint64),\n                ('sample_freq', ctypes.c_uint64),\n                ('sample_type', ctypes.c_uint64),\n                ('read_format', ctypes.c_uint64),\n                ('flags', ctypes.c_uint64),\n                ('wakeup_events', ctypes.c_uint32),\n                ('bp_type', ctypes.c_uint32),\n                ('bp_addr', ctypes.c_uint64),\n                ('bp_len', ctypes.c_uint64),\n                ]\n\n    def __init__(self):\n        super(self.__class__, self).__init__()\n        self.type = PERF_TYPE_TRACEPOINT\n        self.size = ctypes.sizeof(self)\n        self.read_format = PERF_FORMAT_GROUP\n\n\nPERF_TYPE_TRACEPOINT = 2\nPERF_FORMAT_GROUP = 1 << 3\n\n\nclass Group(object):\n    \"\"\"Represents a perf event group.\"\"\"\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        self.events.append(event)\n\n    def read(self):\n        \"\"\"Returns a dict with 'event name: value' for all events in the\n        group.\n\n        Values are read by reading from the file descriptor of the\n        event that is the group leader. See perf_event_open(2) for\n        details.\n\n        Read format for the used event configuration is:\n        struct read_format {\n            u64 nr; /* The number of events */\n            struct {\n                u64 value; /* The value of the event */\n            } values[nr];\n        };\n\n        \"\"\"\n        length = 8 * (1 + len(self.events))\n        read_format = 'xxxxxxxx' + 'Q' * len(self.events)\n        return dict(zip([event.name for event in self.events],\n                        struct.unpack(read_format,\n                                      os.read(self.events[0].fd, length))))\n\n\nclass Event(object):\n    \"\"\"Represents a performance event and manages its life cycle.\"\"\"\n    def __init__(self, name, group, trace_cpu, trace_pid, trace_point,\n                 trace_filter, trace_set='kvm'):\n        self.libc = ctypes.CDLL('libc.so.6', use_errno=True)\n        self.syscall = self.libc.syscall\n        self.name = name\n        self.fd = None\n        self._setup_event(group, trace_cpu, trace_pid, trace_point,\n                          trace_filter, trace_set)\n\n    def __del__(self):\n        \"\"\"Closes the event's file descriptor.\n\n        As no python file object was created for the file descriptor,\n        python will not reference count the descriptor and will not\n        close it itself automatically, so we do it.\n\n        \"\"\"\n        if self.fd:\n            os.close(self.fd)\n\n    def _perf_event_open(self, attr, pid, cpu, group_fd, flags):\n        \"\"\"Wrapper for the sys_perf_evt_open() syscall.\n\n        Used to set up performance events, returns a file descriptor or -1\n        on error.\n\n        Attributes are:\n        - syscall number\n        - struct perf_event_attr *\n        - pid or -1 to monitor all pids\n        - cpu number or -1 to monitor all cpus\n        - The file descriptor of the group leader or -1 to create a group.\n        - flags\n\n        \"\"\"\n        return self.syscall(ARCH.sc_perf_evt_open, ctypes.pointer(attr),\n                            ctypes.c_int(pid), ctypes.c_int(cpu),\n                            ctypes.c_int(group_fd), ctypes.c_long(flags))\n\n    def _setup_event_attribute(self, trace_set, trace_point):\n        \"\"\"Returns an initialized ctype perf_event_attr struct.\"\"\"\n\n        id_path = os.path.join(PATH_DEBUGFS_TRACING, 'events', trace_set,\n                               trace_point, 'id')\n\n        event_attr = perf_event_attr()\n        event_attr.config = int(open(id_path).read())\n        return event_attr\n\n    def _setup_event(self, group, trace_cpu, trace_pid, trace_point,\n                     trace_filter, trace_set):\n        \"\"\"Sets up the perf event in Linux.\n\n        Issues the syscall to register the event in the kernel and\n        then sets the optional filter.\n\n        \"\"\"\n\n        event_attr = self._setup_event_attribute(trace_set, trace_point)\n\n        # First event will be group leader.\n        group_leader = -1\n\n        # All others have to pass the leader's descriptor instead.\n        if group.events:\n            group_leader = group.events[0].fd\n\n        fd = self._perf_event_open(event_attr, trace_pid,\n                                   trace_cpu, group_leader, 0)\n        if fd == -1:\n            err = ctypes.get_errno()\n            raise OSError(err, os.strerror(err),\n                          'while calling sys_perf_event_open().')\n\n        if trace_filter:\n            fcntl.ioctl(fd, ARCH.ioctl_numbers['SET_FILTER'],\n                        trace_filter)\n\n        self.fd = fd\n\n    def enable(self):\n        \"\"\"Enables the trace event in the kernel.\n\n        Enabling the group leader makes reading counters from it and the\n        events under it possible.\n\n        \"\"\"\n        fcntl.ioctl(self.fd, ARCH.ioctl_numbers['ENABLE'], 0)\n\n    def disable(self):\n        \"\"\"Disables the trace event in the kernel.\n\n        Disabling the group leader makes reading all counters under it\n        impossible.\n\n        \"\"\"\n        fcntl.ioctl(self.fd, ARCH.ioctl_numbers['DISABLE'], 0)\n\n    def reset(self):\n        \"\"\"Resets the count of the trace event in the kernel.\"\"\"\n        fcntl.ioctl(self.fd, ARCH.ioctl_numbers['RESET'], 0)\n\n\nclass Provider(object):\n    \"\"\"Encapsulates functionalities used by all providers.\"\"\"\n    def __init__(self, pid):\n        self.child_events = False\n        self.pid = pid\n\n    @staticmethod\n    def is_field_wanted(fields_filter, field):\n        \"\"\"Indicate whether field is valid according to fields_filter.\"\"\"\n        if not fields_filter:\n            return True\n        return re.match(fields_filter, field) is not None\n\n    @staticmethod\n    def walkdir(path):\n        \"\"\"Returns os.walk() data for specified directory.\n\n        As it is only a wrapper it returns the same 3-tuple of (dirpath,\n        dirnames, filenames).\n        \"\"\"\n        return next(os.walk(path))\n\n\nclass TracepointProvider(Provider):\n    \"\"\"Data provider for the stats class.\n\n    Manages the events/groups from which it acquires its data.\n\n    \"\"\"\n    def __init__(self, pid, fields_filter):\n        self.group_leaders = []\n        self.filters = self._get_filters()\n        self.update_fields(fields_filter)\n        super(TracepointProvider, self).__init__(pid)\n\n    @staticmethod\n    def _get_filters():\n        \"\"\"Returns a dict of trace events, their filter ids and\n        the values that can be filtered.\n\n        Trace events can be filtered for special values by setting a\n        filter string via an ioctl. The string normally has the format\n        identifier==value. For each filter a new event will be created, to\n        be able to distinguish the events.\n\n        \"\"\"\n        filters = {}\n        filters['kvm_userspace_exit'] = ('reason', USERSPACE_EXIT_REASONS)\n        if ARCH.exit_reason_field and ARCH.exit_reasons:\n            filters['kvm_exit'] = (ARCH.exit_reason_field, ARCH.exit_reasons)\n        return filters\n\n    def _get_available_fields(self):\n        \"\"\"Returns a list of available events of format 'event name(filter\n        name)'.\n\n        All available events have directories under\n        /sys/kernel/tracing/events/ which export information\n        about the specific event. Therefore, listing the dirs gives us\n        a list of all available events.\n\n        Some events like the vm exit reasons can be filtered for\n        specific values. To take account for that, the routine below\n        creates special fields with the following format:\n        event name(filter name)\n\n        \"\"\"\n        path = os.path.join(PATH_DEBUGFS_TRACING, 'events', 'kvm')\n        fields = self.walkdir(path)[1]\n        extra = []\n        for field in fields:\n            if field in self.filters:\n                filter_name_, filter_dicts = self.filters[field]\n                for name in filter_dicts:\n                    extra.append(field + '(' + name + ')')\n        fields += extra\n        return fields\n\n    def update_fields(self, fields_filter):\n        \"\"\"Refresh fields, applying fields_filter\"\"\"\n        self.fields = [field for field in self._get_available_fields()\n                       if self.is_field_wanted(fields_filter, field)]\n        # add parents for child fields - otherwise we won't see any output!\n        for field in self._fields:\n            parent = ARCH.tracepoint_is_child(field)\n            if (parent and parent not in self._fields):\n                self.fields.append(parent)\n\n    @staticmethod\n    def _get_online_cpus():\n        \"\"\"Returns a list of cpu id integers.\"\"\"\n        def parse_int_list(list_string):\n            \"\"\"Returns an int list from a string of comma separated integers and\n            integer ranges.\"\"\"\n            integers = []\n            members = list_string.split(',')\n\n            for member in members:\n                if '-' not in member:\n                    integers.append(int(member))\n                else:\n                    int_range = member.split('-')\n                    integers.extend(range(int(int_range[0]),\n                                          int(int_range[1]) + 1))\n\n            return integers\n\n        with open('/sys/devices/system/cpu/online') as cpu_list:\n            cpu_string = cpu_list.readline()\n            return parse_int_list(cpu_string)\n\n    def _setup_traces(self):\n        \"\"\"Creates all event and group objects needed to be able to retrieve\n        data.\"\"\"\n        fields = self._get_available_fields()\n        if self._pid > 0:\n            # Fetch list of all threads of the monitored pid, as qemu\n            # starts a thread for each vcpu.\n            path = os.path.join('/proc', str(self._pid), 'task')\n            groupids = self.walkdir(path)[1]\n        else:\n            groupids = self._get_online_cpus()\n\n        # The constant is needed as a buffer for python libs, std\n        # streams and other files that the script opens.\n        newlim = len(groupids) * len(fields) + 50\n        try:\n            softlim_, hardlim = resource.getrlimit(resource.RLIMIT_NOFILE)\n\n            if hardlim < newlim:\n                # Now we need CAP_SYS_RESOURCE, to increase the hard limit.\n                resource.setrlimit(resource.RLIMIT_NOFILE, (newlim, newlim))\n            else:\n                # Raising the soft limit is sufficient.\n                resource.setrlimit(resource.RLIMIT_NOFILE, (newlim, hardlim))\n\n        except ValueError:\n            sys.exit(\"NOFILE rlimit could not be raised to {0}\".format(newlim))\n\n        for groupid in groupids:\n            group = Group()\n            for name in fields:\n                tracepoint = name\n                tracefilter = None\n                match = re.match(r'(.*)\\((.*)\\)', name)\n                if match:\n                    tracepoint, sub = match.groups()\n                    tracefilter = ('%s==%d\\0' %\n                                   (self.filters[tracepoint][0],\n                                    self.filters[tracepoint][1][sub]))\n\n                # From perf_event_open(2):\n                # pid > 0 and cpu == -1\n                # This measures the specified process/thread on any CPU.\n                #\n                # pid == -1 and cpu >= 0\n                # This measures all processes/threads on the specified CPU.\n                trace_cpu = groupid if self._pid == 0 else -1\n                trace_pid = int(groupid) if self._pid != 0 else -1\n\n                group.add_event(Event(name=name,\n                                      group=group,\n                                      trace_cpu=trace_cpu,\n                                      trace_pid=trace_pid,\n                                      trace_point=tracepoint,\n                                      trace_filter=tracefilter))\n\n            self.group_leaders.append(group)\n\n    @property\n    def fields(self):\n        return self._fields\n\n    @fields.setter\n    def fields(self, fields):\n        \"\"\"Enables/disables the (un)wanted events\"\"\"\n        self._fields = fields\n        for group in self.group_leaders:\n            for index, event in enumerate(group.events):\n                if event.name in fields:\n                    event.reset()\n                    event.enable()\n                else:\n                    # Do not disable the group leader.\n                    # It would disable all of its events.\n                    if index != 0:\n                        event.disable()\n\n    @property\n    def pid(self):\n        return self._pid\n\n    @pid.setter\n    def pid(self, pid):\n        \"\"\"Changes the monitored pid by setting new traces.\"\"\"\n        self._pid = pid\n        # The garbage collector will get rid of all Event/Group\n        # objects and open files after removing the references.\n        self.group_leaders = []\n        self._setup_traces()\n        self.fields = self._fields\n\n    def read(self, by_guest=0):\n        \"\"\"Returns 'event name: current value' for all enabled events.\"\"\"\n        ret = defaultdict(int)\n        for group in self.group_leaders:\n            for name, val in group.read().items():\n                if name not in self._fields:\n                    continue\n                parent = ARCH.tracepoint_is_child(name)\n                if parent:\n                    name += ' ' + parent\n                ret[name] += val\n        return ret\n\n    def reset(self):\n        \"\"\"Reset all field counters\"\"\"\n        for group in self.group_leaders:\n            for event in group.events:\n                event.reset()\n\n\nclass DebugfsProvider(Provider):\n    \"\"\"Provides data from the files that KVM creates in the kvm debugfs\n    folder.\"\"\"\n    def __init__(self, pid, fields_filter, include_past):\n        self.update_fields(fields_filter)\n        self._baseline = {}\n        self.do_read = True\n        self.paths = []\n        super(DebugfsProvider, self).__init__(pid)\n        if include_past:\n            self._restore()\n\n    def _get_available_fields(self):\n        \"\"\"\"Returns a list of available fields.\n\n        The fields are all available KVM debugfs files\n\n        \"\"\"\n        exempt_list = ['halt_poll_fail_ns', 'halt_poll_success_ns', 'halt_wait_ns']\n        fields = [field for field in self.walkdir(PATH_DEBUGFS_KVM)[2]\n                  if field not in exempt_list]\n\n        return fields\n\n    def update_fields(self, fields_filter):\n        \"\"\"Refresh fields, applying fields_filter\"\"\"\n        self._fields = [field for field in self._get_available_fields()\n                        if self.is_field_wanted(fields_filter, field)]\n        # add parents for child fields - otherwise we won't see any output!\n        for field in self._fields:\n            parent = ARCH.debugfs_is_child(field)\n            if (parent and parent not in self._fields):\n                self.fields.append(parent)\n\n    @property\n    def fields(self):\n        return self._fields\n\n    @fields.setter\n    def fields(self, fields):\n        self._fields = fields\n        self.reset()\n\n    @property\n    def pid(self):\n        return self._pid\n\n    @pid.setter\n    def pid(self, pid):\n        self._pid = pid\n        if pid != 0:\n            vms = self.walkdir(PATH_DEBUGFS_KVM)[1]\n            if len(vms) == 0:\n                self.do_read = False\n\n            self.paths = list(filter(lambda x: \"{}-\".format(pid) in x, vms))\n\n        else:\n            self.paths = []\n            self.do_read = True\n\n    def _verify_paths(self):\n        \"\"\"Remove invalid paths\"\"\"\n        for path in self.paths:\n            if not os.path.exists(os.path.join(PATH_DEBUGFS_KVM, path)):\n                self.paths.remove(path)\n                continue\n\n    def read(self, reset=0, by_guest=0):\n        \"\"\"Returns a dict with format:'file name / field -> current value'.\n\n        Parameter 'reset':\n          0   plain read\n          1   reset field counts to 0\n          2   restore the original field counts\n\n        \"\"\"\n        results = {}\n\n        # If no debugfs filtering support is available, then don't read.\n        if not self.do_read:\n            return results\n        self._verify_paths()\n\n        paths = self.paths\n        if self._pid == 0:\n            paths = []\n            for entry in os.walk(PATH_DEBUGFS_KVM):\n                for dir in entry[1]:\n                    paths.append(dir)\n        for path in paths:\n            for field in self._fields:\n                value = self._read_field(field, path)\n                key = path + field\n                if reset == 1:\n                    self._baseline[key] = value\n                if reset == 2:\n                    self._baseline[key] = 0\n                if self._baseline.get(key, -1) == -1:\n                    self._baseline[key] = value\n                parent = ARCH.debugfs_is_child(field)\n                if parent:\n                    field = field + ' ' + parent\n                else:\n                    if by_guest:\n                        field = key.split('-')[0]    # set 'field' to 'pid'\n                increment = value - self._baseline.get(key, 0)\n                if field in results:\n                    results[field] += increment\n                else:\n                    results[field] = increment\n\n        return results\n\n    def _read_field(self, field, path):\n        \"\"\"Returns the value of a single field from a specific VM.\"\"\"\n        try:\n            return int(open(os.path.join(PATH_DEBUGFS_KVM,\n                                         path,\n                                         field))\n                       .read())\n        except IOError:\n            return 0\n\n    def reset(self):\n        \"\"\"Reset field counters\"\"\"\n        self._baseline = {}\n        self.read(1)\n\n    def _restore(self):\n        \"\"\"Reset field counters\"\"\"\n        self._baseline = {}\n        self.read(2)\n\n\nEventStat = namedtuple('EventStat', ['value', 'delta'])\n\n\nclass Stats(object):\n    \"\"\"Manages the data providers and the data they provide.\n\n    It is used to set filters on the provider's data and collect all\n    provider data.\n\n    \"\"\"\n    def __init__(self, options):\n        self.providers = self._get_providers(options)\n        self._pid_filter = options.pid\n        self._fields_filter = options.fields\n        self.values = {}\n        self._child_events = False\n\n    def _get_providers(self, options):\n        \"\"\"Returns a list of data providers depending on the passed options.\"\"\"\n        providers = []\n\n        if options.debugfs:\n            providers.append(DebugfsProvider(options.pid, options.fields,\n                                             options.debugfs_include_past))\n        if options.tracepoints or not providers:\n            providers.append(TracepointProvider(options.pid, options.fields))\n\n        return providers\n\n    def _update_provider_filters(self):\n        \"\"\"Propagates fields filters to providers.\"\"\"\n        # As we reset the counters when updating the fields we can\n        # also clear the cache of old values.\n        self.values = {}\n        for provider in self.providers:\n            provider.update_fields(self._fields_filter)\n\n    def reset(self):\n        self.values = {}\n        for provider in self.providers:\n            provider.reset()\n\n    @property\n    def fields_filter(self):\n        return self._fields_filter\n\n    @fields_filter.setter\n    def fields_filter(self, fields_filter):\n        if fields_filter != self._fields_filter:\n            self._fields_filter = fields_filter\n            self._update_provider_filters()\n\n    @property\n    def pid_filter(self):\n        return self._pid_filter\n\n    @pid_filter.setter\n    def pid_filter(self, pid):\n        if pid != self._pid_filter:\n            self._pid_filter = pid\n            self.values = {}\n            for provider in self.providers:\n                provider.pid = self._pid_filter\n\n    @property\n    def child_events(self):\n        return self._child_events\n\n    @child_events.setter\n    def child_events(self, val):\n        self._child_events = val\n        for provider in self.providers:\n            provider.child_events = val\n\n    def get(self, by_guest=0):\n        \"\"\"Returns a dict with field -> (value, delta to last value) of all\n        provider data.\n        Key formats:\n          * plain: 'key' is event name\n          * child-parent: 'key' is in format '<child> <parent>'\n          * pid: 'key' is the pid of the guest, and the record contains the\n               aggregated event data\n        These formats are generated by the providers, and handled in class TUI.\n        \"\"\"\n        for provider in self.providers:\n            new = provider.read(by_guest=by_guest)\n            for key in new:\n                oldval = self.values.get(key, EventStat(0, 0)).value\n                newval = new.get(key, 0)\n                newdelta = newval - oldval\n                self.values[key] = EventStat(newval, newdelta)\n        return self.values\n\n    def toggle_display_guests(self, to_pid):\n        \"\"\"Toggle between collection of stats by individual event and by\n        guest pid\n\n        Events reported by DebugfsProvider change when switching to/from\n        reading by guest values. Hence we have to remove the excess event\n        names from self.values.\n\n        \"\"\"\n        if any(isinstance(ins, TracepointProvider) for ins in self.providers):\n            return 1\n        if to_pid:\n            for provider in self.providers:\n                if isinstance(provider, DebugfsProvider):\n                    for key in provider.fields:\n                        if key in self.values.keys():\n                            del self.values[key]\n        else:\n            oldvals = self.values.copy()\n            for key in oldvals:\n                if key.isdigit():\n                    del self.values[key]\n        # Update oldval (see get())\n        self.get(to_pid)\n        return 0\n\n\nDELAY_DEFAULT = 3.0\nMAX_GUEST_NAME_LEN = 48\nMAX_REGEX_LEN = 44\nSORT_DEFAULT = 0\nMIN_DELAY = 0.1\nMAX_DELAY = 25.5\n\n\nclass Tui(object):\n    \"\"\"Instruments curses to draw a nice text ui.\"\"\"\n    def __init__(self, stats, opts):\n        self.stats = stats\n        self.screen = None\n        self._delay_initial = 0.25\n        self._delay_regular = opts.set_delay\n        self._sorting = SORT_DEFAULT\n        self._display_guests = 0\n\n    def __enter__(self):\n        \"\"\"Initialises curses for later use.  Based on curses.wrapper\n           implementation from the Python standard library.\"\"\"\n        self.screen = curses.initscr()\n        curses.noecho()\n        curses.cbreak()\n\n        # The try/catch works around a minor bit of\n        # over-conscientiousness in the curses module, the error\n        # return from C start_color() is ignorable.\n        try:\n            curses.start_color()\n        except curses.error:\n            pass\n\n        # Hide cursor in extra statement as some monochrome terminals\n        # might support hiding but not colors.\n        try:\n            curses.curs_set(0)\n        except curses.error:\n            pass\n\n        curses.use_default_colors()\n        return self\n\n    def __exit__(self, *exception):\n        \"\"\"Resets the terminal to its normal state.  Based on curses.wrapper\n           implementation from the Python standard library.\"\"\"\n        if self.screen:\n            self.screen.keypad(0)\n            curses.echo()\n            curses.nocbreak()\n            curses.endwin()\n\n    @staticmethod\n    def get_all_gnames():\n        \"\"\"Returns a list of (pid, gname) tuples of all running guests\"\"\"\n        res = []\n        try:\n            child = subprocess.Popen(['ps', '-A', '--format', 'pid,args'],\n                                     stdout=subprocess.PIPE)\n        except:\n            raise Exception\n        for line in child.stdout:\n            line = line.decode(ENCODING).lstrip().split(' ', 1)\n            # perform a sanity check before calling the more expensive\n            # function to possibly extract the guest name\n            if ' -name ' in line[1]:\n                res.append((line[0], Tui.get_gname_from_pid(line[0])))\n        child.stdout.close()\n\n        return res\n\n    def _print_all_gnames(self, row):\n        \"\"\"Print a list of all running guests along with their pids.\"\"\"\n        self.screen.addstr(row, 2, '%8s  %-60s' %\n                           ('Pid', 'Guest Name (fuzzy list, might be '\n                            'inaccurate!)'),\n                           curses.A_UNDERLINE)\n        row += 1\n        try:\n            for line in self.get_all_gnames():\n                self.screen.addstr(row, 2, '%8s  %-60s' % (line[0], line[1]))\n                row += 1\n                if row >= self.screen.getmaxyx()[0]:\n                    break\n        except Exception:\n            self.screen.addstr(row + 1, 2, 'Not available')\n\n    @staticmethod\n    def get_pid_from_gname(gname):\n        \"\"\"Fuzzy function to convert guest name to QEMU process pid.\n\n        Returns a list of potential pids, can be empty if no match found.\n        Throws an exception on processing errors.\n\n        \"\"\"\n        pids = []\n        for line in Tui.get_all_gnames():\n            if gname == line[1]:\n                pids.append(int(line[0]))\n\n        return pids\n\n    @staticmethod\n    def get_gname_from_pid(pid):\n        \"\"\"Returns the guest name for a QEMU process pid.\n\n        Extracts the guest name from the QEMU comma line by processing the\n        '-name' option. Will also handle names specified out of sequence.\n\n        \"\"\"\n        name = ''\n        try:\n            line = open('/proc/{}/cmdline'\n                        .format(pid), 'r').read().split('\\0')\n            parms = line[line.index('-name') + 1].split(',')\n            while '' in parms:\n                # commas are escaped (i.e. ',,'), hence e.g. 'foo,bar' results\n                # in # ['foo', '', 'bar'], which we revert here\n                idx = parms.index('')\n                parms[idx - 1] += ',' + parms[idx + 1]\n                del parms[idx:idx+2]\n            # the '-name' switch allows for two ways to specify the guest name,\n            # where the plain name overrides the name specified via 'guest='\n            for arg in parms:\n                if '=' not in arg:\n                    name = arg\n                    break\n                if arg[:6] == 'guest=':\n                    name = arg[6:]\n        except (ValueError, IOError, IndexError):\n            pass\n\n        return name\n\n    def _update_pid(self, pid):\n        \"\"\"Propagates pid selection to stats object.\"\"\"\n        self.screen.addstr(4, 1, 'Updating pid filter...')\n        self.screen.refresh()\n        self.stats.pid_filter = pid\n\n    def _refresh_header(self, pid=None):\n        \"\"\"Refreshes the header.\"\"\"\n        if pid is None:\n            pid = self.stats.pid_filter\n        self.screen.erase()\n        gname = self.get_gname_from_pid(pid)\n        self._gname = gname\n        if gname:\n            gname = ('({})'.format(gname[:MAX_GUEST_NAME_LEN] + '...'\n                                   if len(gname) > MAX_GUEST_NAME_LEN\n                                   else gname))\n        if pid > 0:\n            self._headline = 'kvm statistics - pid {0} {1}'.format(pid, gname)\n        else:\n            self._headline = 'kvm statistics - summary'\n        self.screen.addstr(0, 0, self._headline, curses.A_BOLD)\n        if self.stats.fields_filter:\n            regex = self.stats.fields_filter\n            if len(regex) > MAX_REGEX_LEN:\n                regex = regex[:MAX_REGEX_LEN] + '...'\n            self.screen.addstr(1, 17, 'regex filter: {0}'.format(regex))\n        if self._display_guests:\n            col_name = 'Guest Name'\n        else:\n            col_name = 'Event'\n        self.screen.addstr(2, 1, '%-40s %10s%7s %8s' %\n                           (col_name, 'Total', '%Total', 'CurAvg/s'),\n                           curses.A_STANDOUT)\n        self.screen.addstr(4, 1, 'Collecting data...')\n        self.screen.refresh()\n\n    def _refresh_body(self, sleeptime):\n        def insert_child(sorted_items, child, values, parent):\n            num = len(sorted_items)\n            for i in range(0, num):\n                # only add child if parent is present\n                if parent.startswith(sorted_items[i][0]):\n                    sorted_items.insert(i + 1, ('  ' + child, values))\n\n        def get_sorted_events(self, stats):\n            \"\"\" separate parent and child events \"\"\"\n            if self._sorting == SORT_DEFAULT:\n                def sortkey(pair):\n                    # sort by (delta value, overall value)\n                    v = pair[1]\n                    return (v.delta, v.value)\n            else:\n                def sortkey(pair):\n                    # sort by overall value\n                    v = pair[1]\n                    return v.value\n\n            childs = []\n            sorted_items = []\n            # we can't rule out child events to appear prior to parents even\n            # when sorted - separate out all children first, and add in later\n            for key, values in sorted(stats.items(), key=sortkey,\n                                      reverse=True):\n                if values == (0, 0):\n                    continue\n                if key.find(' ') != -1:\n                    if not self.stats.child_events:\n                        continue\n                    childs.insert(0, (key, values))\n                else:\n                    sorted_items.append((key, values))\n            if self.stats.child_events:\n                for key, values in childs:\n                    (child, parent) = key.split(' ')\n                    insert_child(sorted_items, child, values, parent)\n\n            return sorted_items\n\n        if not self._is_running_guest(self.stats.pid_filter):\n            if self._gname:\n                try:  # ...to identify the guest by name in case it's back\n                    pids = self.get_pid_from_gname(self._gname)\n                    if len(pids) == 1:\n                        self._refresh_header(pids[0])\n                        self._update_pid(pids[0])\n                        return\n                except:\n                    pass\n            self._display_guest_dead()\n            # leave final data on screen\n            return\n        row = 3\n        self.screen.move(row, 0)\n        self.screen.clrtobot()\n        stats = self.stats.get(self._display_guests)\n        total = 0.\n        ctotal = 0.\n        for key, values in stats.items():\n            if self._display_guests:\n                if self.get_gname_from_pid(key):\n                    total += values.value\n                continue\n            if not key.find(' ') != -1:\n                total += values.value\n            else:\n                ctotal += values.value\n        if total == 0.:\n            # we don't have any fields, or all non-child events are filtered\n            total = ctotal\n\n        # print events\n        tavg = 0\n        tcur = 0\n        guest_removed = False\n        for key, values in get_sorted_events(self, stats):\n            if row >= self.screen.getmaxyx()[0] - 1 or values == (0, 0):\n                break\n            if self._display_guests:\n                key = self.get_gname_from_pid(key)\n                if not key:\n                    continue\n            cur = int(round(values.delta / sleeptime)) if values.delta else 0\n            if cur < 0:\n                guest_removed = True\n                continue\n            if key[0] != ' ':\n                if values.delta:\n                    tcur += values.delta\n                ptotal = values.value\n                ltotal = total\n            else:\n                ltotal = ptotal\n            self.screen.addstr(row, 1, '%-40s %10d%7.1f %8s' % (key,\n                               values.value,\n                               values.value * 100 / float(ltotal), cur))\n            row += 1\n        if row == 3:\n            if guest_removed:\n                self.screen.addstr(4, 1, 'Guest removed, updating...')\n            else:\n                self.screen.addstr(4, 1, 'No matching events reported yet')\n        if row > 4:\n            tavg = int(round(tcur / sleeptime)) if tcur > 0 else ''\n            self.screen.addstr(row, 1, '%-40s %10d        %8s' %\n                               ('Total', total, tavg), curses.A_BOLD)\n        self.screen.refresh()\n\n    def _display_guest_dead(self):\n        marker = '   Guest is DEAD   '\n        y = min(len(self._headline), 80 - len(marker))\n        self.screen.addstr(0, y, marker, curses.A_BLINK | curses.A_STANDOUT)\n\n    def _show_msg(self, text):\n        \"\"\"Display message centered text and exit on key press\"\"\"\n        hint = 'Press any key to continue'\n        curses.cbreak()\n        self.screen.erase()\n        (x, term_width) = self.screen.getmaxyx()\n        row = 2\n        for line in text:\n            start = (term_width - len(line)) // 2\n            self.screen.addstr(row, start, line)\n            row += 1\n        self.screen.addstr(row + 1, (term_width - len(hint)) // 2, hint,\n                           curses.A_STANDOUT)\n        self.screen.getkey()\n\n    def _show_help_interactive(self):\n        \"\"\"Display help with list of interactive commands\"\"\"\n        msg = ('   b     toggle events by guests (debugfs only, honors'\n               ' filters)',\n               '   c     clear filter',\n               '   f     filter by regular expression',\n               '   g     filter by guest name/PID',\n               '   h     display interactive commands reference',\n               '   o     toggle sorting order (Total vs CurAvg/s)',\n               '   p     filter by guest name/PID',\n               '   q     quit',\n               '   r     reset stats',\n               '   s     set delay between refreshs (value range: '\n               '%s-%s secs)' % (MIN_DELAY, MAX_DELAY),\n               '   x     toggle reporting of stats for individual child trace'\n               ' events',\n               'Any other key refreshes statistics immediately')\n        curses.cbreak()\n        self.screen.erase()\n        self.screen.addstr(0, 0, \"Interactive commands reference\",\n                           curses.A_BOLD)\n        self.screen.addstr(2, 0, \"Press any key to exit\", curses.A_STANDOUT)\n        row = 4\n        for line in msg:\n            self.screen.addstr(row, 0, line)\n            row += 1\n        self.screen.getkey()\n        self._refresh_header()\n\n    def _show_filter_selection(self):\n        \"\"\"Draws filter selection mask.\n\n        Asks for a valid regex and sets the fields filter accordingly.\n\n        \"\"\"\n        msg = ''\n        while True:\n            self.screen.erase()\n            self.screen.addstr(0, 0,\n                               \"Show statistics for events matching a regex.\",\n                               curses.A_BOLD)\n            self.screen.addstr(2, 0,\n                               \"Current regex: {0}\"\n                               .format(self.stats.fields_filter))\n            self.screen.addstr(5, 0, msg)\n            self.screen.addstr(3, 0, \"New regex: \")\n            curses.echo()\n            regex = self.screen.getstr().decode(ENCODING)\n            curses.noecho()\n            if len(regex) == 0:\n                self.stats.fields_filter = ''\n                self._refresh_header()\n                return\n            try:\n                re.compile(regex)\n                self.stats.fields_filter = regex\n                self._refresh_header()\n                return\n            except re.error:\n                msg = '\"' + regex + '\": Not a valid regular expression'\n                continue\n\n    def _show_set_update_interval(self):\n        \"\"\"Draws update interval selection mask.\"\"\"\n        msg = ''\n        while True:\n            self.screen.erase()\n            self.screen.addstr(0, 0, 'Set update interval (defaults to %.1fs).'\n                               % DELAY_DEFAULT, curses.A_BOLD)\n            self.screen.addstr(4, 0, msg)\n            self.screen.addstr(2, 0, 'Change delay from %.1fs to ' %\n                               self._delay_regular)\n            curses.echo()\n            val = self.screen.getstr().decode(ENCODING)\n            curses.noecho()\n\n            try:\n                if len(val) > 0:\n                    delay = float(val)\n                    err = is_delay_valid(delay)\n                    if err is not None:\n                        msg = err\n                        continue\n                else:\n                    delay = DELAY_DEFAULT\n                self._delay_regular = delay\n                break\n\n            except ValueError:\n                msg = '\"' + str(val) + '\": Invalid value'\n        self._refresh_header()\n\n    def _is_running_guest(self, pid):\n        \"\"\"Check if pid is still a running process.\"\"\"\n        if not pid:\n            return True\n        return os.path.isdir(os.path.join('/proc/', str(pid)))\n\n    def _show_vm_selection_by_guest(self):\n        \"\"\"Draws guest selection mask.\n\n        Asks for a guest name or pid until a valid guest name or '' is entered.\n\n        \"\"\"\n        msg = ''\n        while True:\n            self.screen.erase()\n            self.screen.addstr(0, 0,\n                               'Show statistics for specific guest or pid.',\n                               curses.A_BOLD)\n            self.screen.addstr(1, 0,\n                               'This might limit the shown data to the trace '\n                               'statistics.')\n            self.screen.addstr(5, 0, msg)\n            self._print_all_gnames(7)\n            curses.echo()\n            curses.curs_set(1)\n            self.screen.addstr(3, 0, \"Guest or pid [ENTER exits]: \")\n            guest = self.screen.getstr().decode(ENCODING)\n            curses.noecho()\n\n            pid = 0\n            if not guest or guest == '0':\n                break\n            if guest.isdigit():\n                if not self._is_running_guest(guest):\n                    msg = '\"' + guest + '\": Not a running process'\n                    continue\n                pid = int(guest)\n                break\n            pids = []\n            try:\n                pids = self.get_pid_from_gname(guest)\n            except:\n                msg = '\"' + guest + '\": Internal error while searching, ' \\\n                      'use pid filter instead'\n                continue\n            if len(pids) == 0:\n                msg = '\"' + guest + '\": Not an active guest'\n                continue\n            if len(pids) > 1:\n                msg = '\"' + guest + '\": Multiple matches found, use pid ' \\\n                      'filter instead'\n                continue\n            pid = pids[0]\n            break\n        curses.curs_set(0)\n        self._refresh_header(pid)\n        self._update_pid(pid)\n\n    def show_stats(self):\n        \"\"\"Refreshes the screen and processes user input.\"\"\"\n        sleeptime = self._delay_initial\n        self._refresh_header()\n        start = 0.0  # result based on init value never appears on screen\n        while True:\n            self._refresh_body(time.time() - start)\n            curses.halfdelay(int(sleeptime * 10))\n            start = time.time()\n            sleeptime = self._delay_regular\n            try:\n                char = self.screen.getkey()\n                if char == 'b':\n                    self._display_guests = not self._display_guests\n                    if self.stats.toggle_display_guests(self._display_guests):\n                        self._show_msg(['Command not available with '\n                                        'tracepoints enabled', 'Restart with '\n                                        'debugfs only (see option \\'-d\\') and '\n                                        'try again!'])\n                        self._display_guests = not self._display_guests\n                    self._refresh_header()\n                if char == 'c':\n                    self.stats.fields_filter = ''\n                    self._refresh_header(0)\n                    self._update_pid(0)\n                if char == 'f':\n                    curses.curs_set(1)\n                    self._show_filter_selection()\n                    curses.curs_set(0)\n                    sleeptime = self._delay_initial\n                if char == 'g' or char == 'p':\n                    self._show_vm_selection_by_guest()\n                    sleeptime = self._delay_initial\n                if char == 'h':\n                    self._show_help_interactive()\n                if char == 'o':\n                    self._sorting = not self._sorting\n                if char == 'q':\n                    break\n                if char == 'r':\n                    self.stats.reset()\n                if char == 's':\n                    curses.curs_set(1)\n                    self._show_set_update_interval()\n                    curses.curs_set(0)\n                    sleeptime = self._delay_initial\n                if char == 'x':\n                    self.stats.child_events = not self.stats.child_events\n            except KeyboardInterrupt:\n                break\n            except curses.error:\n                continue\n\n\ndef batch(stats):\n    \"\"\"Prints statistics in a key, value format.\"\"\"\n    try:\n        s = stats.get()\n        time.sleep(1)\n        s = stats.get()\n        for key, values in sorted(s.items()):\n            print('%-42s%10d%10d' % (key.split(' ')[0], values.value,\n                  values.delta))\n    except KeyboardInterrupt:\n        pass\n\n\nclass StdFormat(object):\n    def __init__(self, keys):\n        self._banner = ''\n        for key in keys:\n            self._banner += key.split(' ')[0] + ' '\n\n    def get_banner(self):\n        return self._banner\n\n    def get_statline(self, keys, s):\n        res = ''\n        for key in keys:\n            res += ' %9d' % s[key].delta\n        return res\n\n\nclass CSVFormat(object):\n    def __init__(self, keys):\n        self._banner = 'timestamp'\n        self._banner += reduce(lambda res, key: \"{},{!s}\".format(res,\n                               key.split(' ')[0]), keys, '')\n\n    def get_banner(self):\n        return self._banner\n\n    def get_statline(self, keys, s):\n        return reduce(lambda res, key: \"{},{!s}\".format(res, s[key].delta),\n                      keys, '')\n\n\ndef log(stats, opts, frmt, keys):\n    \"\"\"Prints statistics as reiterating key block, multiple value blocks.\"\"\"\n    global signal_received\n    line = 0\n    banner_repeat = 20\n    f = None\n\n    def do_banner(opts):\n        nonlocal f\n        if opts.log_to_file:\n            if not f:\n                try:\n                     f = open(opts.log_to_file, 'a')\n                except (IOError, OSError):\n                    sys.exit(\"Error: Could not open file: %s\" %\n                             opts.log_to_file)\n                if isinstance(frmt, CSVFormat) and f.tell() != 0:\n                    return\n        print(frmt.get_banner(), file=f or sys.stdout)\n\n    def do_statline(opts, values):\n        statline = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") + \\\n                   frmt.get_statline(keys, values)\n        print(statline, file=f or sys.stdout)\n\n    do_banner(opts)\n    banner_printed = True\n    while True:\n        try:\n            time.sleep(opts.set_delay)\n            if signal_received:\n                banner_printed = True\n                line = 0\n                f.close()\n                do_banner(opts)\n                signal_received = False\n            if (line % banner_repeat == 0 and not banner_printed and\n                not (opts.log_to_file and isinstance(frmt, CSVFormat))):\n                do_banner(opts)\n                banner_printed = True\n            values = stats.get()\n            if (not opts.skip_zero_records or\n                any(values[k].delta != 0 for k in keys)):\n                do_statline(opts, values)\n                line += 1\n                banner_printed = False\n        except KeyboardInterrupt:\n            break\n\n    if opts.log_to_file:\n        f.close()\n\n\ndef handle_signal(sig, frame):\n    global signal_received\n\n    signal_received = True\n\n    return\n\n\ndef is_delay_valid(delay):\n    \"\"\"Verify delay is in valid value range.\"\"\"\n    msg = None\n    if delay < MIN_DELAY:\n        msg = '\"' + str(delay) + '\": Delay must be >=%s' % MIN_DELAY\n    if delay > MAX_DELAY:\n        msg = '\"' + str(delay) + '\": Delay must be <=%s' % MAX_DELAY\n    return msg\n\n\ndef get_options():\n    \"\"\"Returns processed program arguments.\"\"\"\n    description_text = \"\"\"\nThis script displays various statistics about VMs running under KVM.\nThe statistics are gathered from the KVM debugfs entries and / or the\ncurrently available perf traces.\n\nThe monitoring takes additional cpu cycles and might affect the VM's\nperformance.\n\nRequirements:\n- Access to:\n    %s\n    %s/events/*\n    /proc/pid/task\n- /proc/sys/kernel/perf_event_paranoid < 1 if user has no\n  CAP_SYS_ADMIN and perf events are used.\n- CAP_SYS_RESOURCE if the hard limit is not high enough to allow\n  the large number of files that are possibly opened.\n\nInteractive Commands:\n   b     toggle events by guests (debugfs only, honors filters)\n   c     clear filter\n   f     filter by regular expression\n   g     filter by guest name\n   h     display interactive commands reference\n   o     toggle sorting order (Total vs CurAvg/s)\n   p     filter by PID\n   q     quit\n   r     reset stats\n   s     set update interval (value range: 0.1-25.5 secs)\n   x     toggle reporting of stats for individual child trace events\nPress any other key to refresh statistics immediately.\n\"\"\" % (PATH_DEBUGFS_KVM, PATH_DEBUGFS_TRACING)\n\n    class Guest_to_pid(argparse.Action):\n        def __call__(self, parser, namespace, values, option_string=None):\n            try:\n                pids = Tui.get_pid_from_gname(values)\n            except:\n                sys.exit('Error while searching for guest \"{}\". Use \"-p\" to '\n                         'specify a pid instead?'.format(values))\n            if len(pids) == 0:\n                sys.exit('Error: No guest by the name \"{}\" found'\n                         .format(values))\n            if len(pids) > 1:\n                sys.exit('Error: Multiple processes found (pids: {}). Use \"-p\"'\n                         ' to specify the desired pid'\n                         .format(\" \".join(map(str, pids))))\n            namespace.pid = pids[0]\n\n    argparser = argparse.ArgumentParser(description=description_text,\n                                        formatter_class=argparse\n                                        .RawTextHelpFormatter)\n    argparser.add_argument('-1', '--once', '--batch',\n                           action='store_true',\n                           default=False,\n                           help='run in batch mode for one second',\n                           )\n    argparser.add_argument('-c', '--csv',\n                           action='store_true',\n                           default=False,\n                           help='log in csv format - requires option -l/-L',\n                           )\n    argparser.add_argument('-d', '--debugfs',\n                           action='store_true',\n                           default=False,\n                           help='retrieve statistics from debugfs',\n                           )\n    argparser.add_argument('-f', '--fields',\n                           default='',\n                           help='''fields to display (regex)\n\"-f help\" for a list of available events''',\n                           )\n    argparser.add_argument('-g', '--guest',\n                           type=str,\n                           help='restrict statistics to guest by name',\n                           action=Guest_to_pid,\n                           )\n    argparser.add_argument('-i', '--debugfs-include-past',\n                           action='store_true',\n                           default=False,\n                           help='include all available data on past events for'\n                                ' debugfs',\n                           )\n    argparser.add_argument('-l', '--log',\n                           action='store_true',\n                           default=False,\n                           help='run in logging mode (like vmstat)',\n                           )\n    argparser.add_argument('-L', '--log-to-file',\n                           type=str,\n                           metavar='FILE',\n                           help=\"like '--log', but logging to a file\"\n                           )\n    argparser.add_argument('-p', '--pid',\n                           type=int,\n                           default=0,\n                           help='restrict statistics to pid',\n                           )\n    argparser.add_argument('-s', '--set-delay',\n                           type=float,\n                           default=DELAY_DEFAULT,\n                           metavar='DELAY',\n                           help='set delay between refreshs (value range: '\n                                '%s-%s secs)' % (MIN_DELAY, MAX_DELAY),\n                           )\n    argparser.add_argument('-t', '--tracepoints',\n                           action='store_true',\n                           default=False,\n                           help='retrieve statistics from tracepoints',\n                           )\n    argparser.add_argument('-z', '--skip-zero-records',\n                           action='store_true',\n                           default=False,\n                           help='omit records with all zeros in logging mode',\n                           )\n    options = argparser.parse_args()\n    if options.csv and not (options.log or options.log_to_file):\n        sys.exit('Error: Option -c/--csv requires -l/--log')\n    if options.skip_zero_records and not (options.log or options.log_to_file):\n        sys.exit('Error: Option -z/--skip-zero-records requires -l/-L')\n    try:\n        # verify that we were passed a valid regex up front\n        re.compile(options.fields)\n    except re.error:\n        sys.exit('Error: \"' + options.fields + '\" is not a valid regular '\n                 'expression')\n\n    return options\n\n\ndef check_access(options):\n    \"\"\"Exits if the current user can't access all needed directories.\"\"\"\n    if not os.path.exists(PATH_DEBUGFS_TRACING) and (options.tracepoints or\n                                                     not options.debugfs):\n        sys.stderr.write(\"Please enable CONFIG_TRACING in your kernel \"\n                         \"when using the option -t (default).\\n\"\n                         \"If it is enabled, make {0} readable by the \"\n                         \"current user.\\n\"\n                         .format(PATH_DEBUGFS_TRACING))\n        if options.tracepoints:\n            sys.exit(1)\n\n        sys.stderr.write(\"Falling back to debugfs statistics!\\n\")\n        options.debugfs = True\n        time.sleep(5)\n\n    return options\n\n\ndef assign_globals():\n    global PATH_DEBUGFS_KVM\n    global PATH_DEBUGFS_TRACING\n\n    debugfs = ''\n    for line in open('/proc/mounts'):\n        if line.split(' ')[2] == 'debugfs':\n            debugfs = line.split(' ')[1]\n            break\n    if debugfs == '':\n        sys.stderr.write(\"Please make sure that CONFIG_DEBUG_FS is enabled in \"\n                         \"your kernel, mounted and\\nreadable by the current \"\n                         \"user:\\n\"\n                         \"('mount -t debugfs debugfs /sys/kernel/debug')\\n\")\n        sys.exit(1)\n\n    PATH_DEBUGFS_KVM = os.path.join(debugfs, 'kvm')\n    PATH_DEBUGFS_TRACING = os.path.join(debugfs, 'tracing')\n\n    if not os.path.exists(PATH_DEBUGFS_KVM):\n        sys.stderr.write(\"Please make sure that CONFIG_KVM is enabled in \"\n                         \"your kernel and that the modules are loaded.\\n\")\n        sys.exit(1)\n\n\ndef main():\n    assign_globals()\n    options = get_options()\n    options = check_access(options)\n\n    if (options.pid > 0 and\n        not os.path.isdir(os.path.join('/proc/',\n                                       str(options.pid)))):\n        sys.stderr.write('Did you use a (unsupported) tid instead of a pid?\\n')\n        sys.exit('Specified pid does not exist.')\n\n    err = is_delay_valid(options.set_delay)\n    if err is not None:\n        sys.exit('Error: ' + err)\n\n    stats = Stats(options)\n\n    if options.fields == 'help':\n        stats.fields_filter = None\n        event_list = []\n        for key in stats.get().keys():\n            event_list.append(key.split('(', 1)[0])\n        sys.stdout.write('  ' + '\\n  '.join(sorted(set(event_list))) + '\\n')\n        sys.exit(0)\n\n    if options.log or options.log_to_file:\n        if options.log_to_file:\n            signal.signal(signal.SIGHUP, handle_signal)\n        keys = sorted(stats.get().keys())\n        if options.csv:\n            frmt = CSVFormat(keys)\n        else:\n            frmt = StdFormat(keys)\n        log(stats, options, frmt, keys)\n    elif not options.once:\n        with Tui(stats, options) as tui:\n            tui.show_stats()\n    else:\n        batch(stats)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}