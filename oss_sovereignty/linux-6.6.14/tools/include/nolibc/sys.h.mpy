{
  "module_name": "sys.h",
  "hash_id": "4e6e41c584c6dfec6fc1a8dc21bd79f0fe37e630605782ec2f5b6f0e025535c1",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/nolibc/sys.h",
  "human_readable_source": " \n \n\n#ifndef _NOLIBC_SYS_H\n#define _NOLIBC_SYS_H\n\n#include <stdarg.h>\n#include \"std.h\"\n\n \n#include <asm/unistd.h>\n#include <asm/signal.h>   \n#include <asm/ioctls.h>\n#include <asm/mman.h>\n#include <linux/fs.h>\n#include <linux/loop.h>\n#include <linux/time.h>\n#include <linux/auxvec.h>\n#include <linux/fcntl.h>  \n#include <linux/stat.h>   \n#include <linux/prctl.h>\n\n#include \"arch.h\"\n#include \"errno.h\"\n#include \"types.h\"\n\n\n \n\n#define __sysret(arg)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(arg) __sysret_arg = (arg);\t\t\t\t\\\n\t(__sysret_arg < 0)                               \t\\\n\t\t? (({ SET_ERRNO(-__sysret_arg); }), -1)   \\\n\t\t: __sysret_arg;                           \\\n})\n\n\n \n\n\n \n\nstatic __attribute__((unused))\nvoid *sys_brk(void *addr)\n{\n\treturn (void *)my_syscall1(__NR_brk, addr);\n}\n\nstatic __attribute__((unused))\nint brk(void *addr)\n{\n\tvoid *ret = sys_brk(addr);\n\n\tif (!ret) {\n\t\tSET_ERRNO(ENOMEM);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic __attribute__((unused))\nvoid *sbrk(intptr_t inc)\n{\n\t \n\tvoid *ret = sys_brk(0);\n\n\tif (ret && sys_brk(ret + inc) == ret + inc)\n\t\treturn ret + inc;\n\n\tSET_ERRNO(ENOMEM);\n\treturn (void *)-1;\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_chdir(const char *path)\n{\n\treturn my_syscall1(__NR_chdir, path);\n}\n\nstatic __attribute__((unused))\nint chdir(const char *path)\n{\n\treturn __sysret(sys_chdir(path));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_chmod(const char *path, mode_t mode)\n{\n#ifdef __NR_fchmodat\n\treturn my_syscall4(__NR_fchmodat, AT_FDCWD, path, mode, 0);\n#elif defined(__NR_chmod)\n\treturn my_syscall2(__NR_chmod, path, mode);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint chmod(const char *path, mode_t mode)\n{\n\treturn __sysret(sys_chmod(path, mode));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_chown(const char *path, uid_t owner, gid_t group)\n{\n#ifdef __NR_fchownat\n\treturn my_syscall5(__NR_fchownat, AT_FDCWD, path, owner, group, 0);\n#elif defined(__NR_chown)\n\treturn my_syscall3(__NR_chown, path, owner, group);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint chown(const char *path, uid_t owner, gid_t group)\n{\n\treturn __sysret(sys_chown(path, owner, group));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_chroot(const char *path)\n{\n\treturn my_syscall1(__NR_chroot, path);\n}\n\nstatic __attribute__((unused))\nint chroot(const char *path)\n{\n\treturn __sysret(sys_chroot(path));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_close(int fd)\n{\n\treturn my_syscall1(__NR_close, fd);\n}\n\nstatic __attribute__((unused))\nint close(int fd)\n{\n\treturn __sysret(sys_close(fd));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_dup(int fd)\n{\n\treturn my_syscall1(__NR_dup, fd);\n}\n\nstatic __attribute__((unused))\nint dup(int fd)\n{\n\treturn __sysret(sys_dup(fd));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_dup2(int old, int new)\n{\n#ifdef __NR_dup3\n\treturn my_syscall3(__NR_dup3, old, new, 0);\n#elif defined(__NR_dup2)\n\treturn my_syscall2(__NR_dup2, old, new);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint dup2(int old, int new)\n{\n\treturn __sysret(sys_dup2(old, new));\n}\n\n\n \n\n#ifdef __NR_dup3\nstatic __attribute__((unused))\nint sys_dup3(int old, int new, int flags)\n{\n\treturn my_syscall3(__NR_dup3, old, new, flags);\n}\n\nstatic __attribute__((unused))\nint dup3(int old, int new, int flags)\n{\n\treturn __sysret(sys_dup3(old, new, flags));\n}\n#endif\n\n\n \n\nstatic __attribute__((unused))\nint sys_execve(const char *filename, char *const argv[], char *const envp[])\n{\n\treturn my_syscall3(__NR_execve, filename, argv, envp);\n}\n\nstatic __attribute__((unused))\nint execve(const char *filename, char *const argv[], char *const envp[])\n{\n\treturn __sysret(sys_execve(filename, argv, envp));\n}\n\n\n \n\nstatic __attribute__((noreturn,unused))\nvoid sys_exit(int status)\n{\n\tmy_syscall1(__NR_exit, status & 255);\n\twhile(1);  \n}\n\nstatic __attribute__((noreturn,unused))\nvoid exit(int status)\n{\n\tsys_exit(status);\n}\n\n\n \n\n#ifndef sys_fork\nstatic __attribute__((unused))\npid_t sys_fork(void)\n{\n#ifdef __NR_clone\n\t \n\treturn my_syscall5(__NR_clone, SIGCHLD, 0, 0, 0, 0);\n#elif defined(__NR_fork)\n\treturn my_syscall0(__NR_fork);\n#else\n\treturn -ENOSYS;\n#endif\n}\n#endif\n\nstatic __attribute__((unused))\npid_t fork(void)\n{\n\treturn __sysret(sys_fork());\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_fsync(int fd)\n{\n\treturn my_syscall1(__NR_fsync, fd);\n}\n\nstatic __attribute__((unused))\nint fsync(int fd)\n{\n\treturn __sysret(sys_fsync(fd));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_getdents64(int fd, struct linux_dirent64 *dirp, int count)\n{\n\treturn my_syscall3(__NR_getdents64, fd, dirp, count);\n}\n\nstatic __attribute__((unused))\nint getdents64(int fd, struct linux_dirent64 *dirp, int count)\n{\n\treturn __sysret(sys_getdents64(fd, dirp, count));\n}\n\n\n \n\nstatic __attribute__((unused))\nuid_t sys_geteuid(void)\n{\n#ifdef __NR_geteuid32\n\treturn my_syscall0(__NR_geteuid32);\n#else\n\treturn my_syscall0(__NR_geteuid);\n#endif\n}\n\nstatic __attribute__((unused))\nuid_t geteuid(void)\n{\n\treturn sys_geteuid();\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_getpgid(pid_t pid)\n{\n\treturn my_syscall1(__NR_getpgid, pid);\n}\n\nstatic __attribute__((unused))\npid_t getpgid(pid_t pid)\n{\n\treturn __sysret(sys_getpgid(pid));\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_getpgrp(void)\n{\n\treturn sys_getpgid(0);\n}\n\nstatic __attribute__((unused))\npid_t getpgrp(void)\n{\n\treturn sys_getpgrp();\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_getpid(void)\n{\n\treturn my_syscall0(__NR_getpid);\n}\n\nstatic __attribute__((unused))\npid_t getpid(void)\n{\n\treturn sys_getpid();\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_getppid(void)\n{\n\treturn my_syscall0(__NR_getppid);\n}\n\nstatic __attribute__((unused))\npid_t getppid(void)\n{\n\treturn sys_getppid();\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_gettid(void)\n{\n\treturn my_syscall0(__NR_gettid);\n}\n\nstatic __attribute__((unused))\npid_t gettid(void)\n{\n\treturn sys_gettid();\n}\n\nstatic unsigned long getauxval(unsigned long key);\n\n \n\nstatic __attribute__((unused))\nint getpagesize(void)\n{\n\treturn __sysret((int)getauxval(AT_PAGESZ) ?: -ENOENT);\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_gettimeofday(struct timeval *tv, struct timezone *tz)\n{\n#ifdef __NR_gettimeofday\n\treturn my_syscall2(__NR_gettimeofday, tv, tz);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint gettimeofday(struct timeval *tv, struct timezone *tz)\n{\n\treturn __sysret(sys_gettimeofday(tv, tz));\n}\n\n\n \n\nstatic __attribute__((unused))\nuid_t sys_getuid(void)\n{\n#ifdef __NR_getuid32\n\treturn my_syscall0(__NR_getuid32);\n#else\n\treturn my_syscall0(__NR_getuid);\n#endif\n}\n\nstatic __attribute__((unused))\nuid_t getuid(void)\n{\n\treturn sys_getuid();\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_ioctl(int fd, unsigned long req, void *value)\n{\n\treturn my_syscall3(__NR_ioctl, fd, req, value);\n}\n\nstatic __attribute__((unused))\nint ioctl(int fd, unsigned long req, void *value)\n{\n\treturn __sysret(sys_ioctl(fd, req, value));\n}\n\n \n\nstatic __attribute__((unused))\nint sys_kill(pid_t pid, int signal)\n{\n\treturn my_syscall2(__NR_kill, pid, signal);\n}\n\nstatic __attribute__((unused))\nint kill(pid_t pid, int signal)\n{\n\treturn __sysret(sys_kill(pid, signal));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_link(const char *old, const char *new)\n{\n#ifdef __NR_linkat\n\treturn my_syscall5(__NR_linkat, AT_FDCWD, old, AT_FDCWD, new, 0);\n#elif defined(__NR_link)\n\treturn my_syscall2(__NR_link, old, new);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint link(const char *old, const char *new)\n{\n\treturn __sysret(sys_link(old, new));\n}\n\n\n \n\nstatic __attribute__((unused))\noff_t sys_lseek(int fd, off_t offset, int whence)\n{\n#ifdef __NR_lseek\n\treturn my_syscall3(__NR_lseek, fd, offset, whence);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\noff_t lseek(int fd, off_t offset, int whence)\n{\n\treturn __sysret(sys_lseek(fd, offset, whence));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_mkdir(const char *path, mode_t mode)\n{\n#ifdef __NR_mkdirat\n\treturn my_syscall3(__NR_mkdirat, AT_FDCWD, path, mode);\n#elif defined(__NR_mkdir)\n\treturn my_syscall2(__NR_mkdir, path, mode);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint mkdir(const char *path, mode_t mode)\n{\n\treturn __sysret(sys_mkdir(path, mode));\n}\n\n \n\nstatic __attribute__((unused))\nint sys_rmdir(const char *path)\n{\n#ifdef __NR_rmdir\n\treturn my_syscall1(__NR_rmdir, path);\n#elif defined(__NR_unlinkat)\n\treturn my_syscall3(__NR_unlinkat, AT_FDCWD, path, AT_REMOVEDIR);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint rmdir(const char *path)\n{\n\treturn __sysret(sys_rmdir(path));\n}\n\n\n \n\nstatic __attribute__((unused))\nlong sys_mknod(const char *path, mode_t mode, dev_t dev)\n{\n#ifdef __NR_mknodat\n\treturn my_syscall4(__NR_mknodat, AT_FDCWD, path, mode, dev);\n#elif defined(__NR_mknod)\n\treturn my_syscall3(__NR_mknod, path, mode, dev);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint mknod(const char *path, mode_t mode, dev_t dev)\n{\n\treturn __sysret(sys_mknod(path, mode, dev));\n}\n\n#ifndef sys_mmap\nstatic __attribute__((unused))\nvoid *sys_mmap(void *addr, size_t length, int prot, int flags, int fd,\n\t       off_t offset)\n{\n\tint n;\n\n#if defined(__NR_mmap2)\n\tn = __NR_mmap2;\n\toffset >>= 12;\n#else\n\tn = __NR_mmap;\n#endif\n\n\treturn (void *)my_syscall6(n, addr, length, prot, flags, fd, offset);\n}\n#endif\n\n \n\nstatic __attribute__((unused))\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\n{\n\tvoid *ret = sys_mmap(addr, length, prot, flags, fd, offset);\n\n\tif ((unsigned long)ret >= -4095UL) {\n\t\tSET_ERRNO(-(long)ret);\n\t\tret = MAP_FAILED;\n\t}\n\treturn ret;\n}\n\nstatic __attribute__((unused))\nint sys_munmap(void *addr, size_t length)\n{\n\treturn my_syscall2(__NR_munmap, addr, length);\n}\n\nstatic __attribute__((unused))\nint munmap(void *addr, size_t length)\n{\n\treturn __sysret(sys_munmap(addr, length));\n}\n\n \nstatic __attribute__((unused))\nint sys_mount(const char *src, const char *tgt, const char *fst,\n                     unsigned long flags, const void *data)\n{\n\treturn my_syscall5(__NR_mount, src, tgt, fst, flags, data);\n}\n\nstatic __attribute__((unused))\nint mount(const char *src, const char *tgt,\n          const char *fst, unsigned long flags,\n          const void *data)\n{\n\treturn __sysret(sys_mount(src, tgt, fst, flags, data));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_open(const char *path, int flags, mode_t mode)\n{\n#ifdef __NR_openat\n\treturn my_syscall4(__NR_openat, AT_FDCWD, path, flags, mode);\n#elif defined(__NR_open)\n\treturn my_syscall3(__NR_open, path, flags, mode);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint open(const char *path, int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list args;\n\n\t\tva_start(args, flags);\n\t\tmode = va_arg(args, int);\n\t\tva_end(args);\n\t}\n\n\treturn __sysret(sys_open(path, flags, mode));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_pipe2(int pipefd[2], int flags)\n{\n\treturn my_syscall2(__NR_pipe2, pipefd, flags);\n}\n\nstatic __attribute__((unused))\nint pipe2(int pipefd[2], int flags)\n{\n\treturn __sysret(sys_pipe2(pipefd, flags));\n}\n\nstatic __attribute__((unused))\nint pipe(int pipefd[2])\n{\n\treturn pipe2(pipefd, 0);\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t          unsigned long arg4, unsigned long arg5)\n{\n\treturn my_syscall5(__NR_prctl, option, arg2, arg3, arg4, arg5);\n}\n\nstatic __attribute__((unused))\nint prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t      unsigned long arg4, unsigned long arg5)\n{\n\treturn __sysret(sys_prctl(option, arg2, arg3, arg4, arg5));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_pivot_root(const char *new, const char *old)\n{\n\treturn my_syscall2(__NR_pivot_root, new, old);\n}\n\nstatic __attribute__((unused))\nint pivot_root(const char *new, const char *old)\n{\n\treturn __sysret(sys_pivot_root(new, old));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_poll(struct pollfd *fds, int nfds, int timeout)\n{\n#if defined(__NR_ppoll)\n\tstruct timespec t;\n\n\tif (timeout >= 0) {\n\t\tt.tv_sec  = timeout / 1000;\n\t\tt.tv_nsec = (timeout % 1000) * 1000000;\n\t}\n\treturn my_syscall5(__NR_ppoll, fds, nfds, (timeout >= 0) ? &t : NULL, NULL, 0);\n#elif defined(__NR_poll)\n\treturn my_syscall3(__NR_poll, fds, nfds, timeout);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint poll(struct pollfd *fds, int nfds, int timeout)\n{\n\treturn __sysret(sys_poll(fds, nfds, timeout));\n}\n\n\n \n\nstatic __attribute__((unused))\nssize_t sys_read(int fd, void *buf, size_t count)\n{\n\treturn my_syscall3(__NR_read, fd, buf, count);\n}\n\nstatic __attribute__((unused))\nssize_t read(int fd, void *buf, size_t count)\n{\n\treturn __sysret(sys_read(fd, buf, count));\n}\n\n\n \n\nstatic __attribute__((unused))\nssize_t sys_reboot(int magic1, int magic2, int cmd, void *arg)\n{\n\treturn my_syscall4(__NR_reboot, magic1, magic2, cmd, arg);\n}\n\nstatic __attribute__((unused))\nint reboot(int cmd)\n{\n\treturn __sysret(sys_reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, 0));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_sched_yield(void)\n{\n\treturn my_syscall0(__NR_sched_yield);\n}\n\nstatic __attribute__((unused))\nint sched_yield(void)\n{\n\treturn __sysret(sys_sched_yield());\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_select(int nfds, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *timeout)\n{\n#if defined(__ARCH_WANT_SYS_OLD_SELECT) && !defined(__NR__newselect)\n\tstruct sel_arg_struct {\n\t\tunsigned long n;\n\t\tfd_set *r, *w, *e;\n\t\tstruct timeval *t;\n\t} arg = { .n = nfds, .r = rfds, .w = wfds, .e = efds, .t = timeout };\n\treturn my_syscall1(__NR_select, &arg);\n#elif defined(__ARCH_WANT_SYS_PSELECT6) && defined(__NR_pselect6)\n\tstruct timespec t;\n\n\tif (timeout) {\n\t\tt.tv_sec  = timeout->tv_sec;\n\t\tt.tv_nsec = timeout->tv_usec * 1000;\n\t}\n\treturn my_syscall6(__NR_pselect6, nfds, rfds, wfds, efds, timeout ? &t : NULL, NULL);\n#elif defined(__NR__newselect) || defined(__NR_select)\n#ifndef __NR__newselect\n#define __NR__newselect __NR_select\n#endif\n\treturn my_syscall5(__NR__newselect, nfds, rfds, wfds, efds, timeout);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint select(int nfds, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *timeout)\n{\n\treturn __sysret(sys_select(nfds, rfds, wfds, efds, timeout));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_setpgid(pid_t pid, pid_t pgid)\n{\n\treturn my_syscall2(__NR_setpgid, pid, pgid);\n}\n\nstatic __attribute__((unused))\nint setpgid(pid_t pid, pid_t pgid)\n{\n\treturn __sysret(sys_setpgid(pid, pgid));\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_setsid(void)\n{\n\treturn my_syscall0(__NR_setsid);\n}\n\nstatic __attribute__((unused))\npid_t setsid(void)\n{\n\treturn __sysret(sys_setsid());\n}\n\n \n\nstatic __attribute__((unused))\nint sys_statx(int fd, const char *path, int flags, unsigned int mask, struct statx *buf)\n{\n#ifdef __NR_statx\n\treturn my_syscall5(__NR_statx, fd, path, flags, mask, buf);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint statx(int fd, const char *path, int flags, unsigned int mask, struct statx *buf)\n{\n\treturn __sysret(sys_statx(fd, path, flags, mask, buf));\n}\n\n\nstatic __attribute__((unused))\nint stat(const char *path, struct stat *buf)\n{\n\tstruct statx statx;\n\tlong ret;\n\n\tret = __sysret(sys_statx(AT_FDCWD, path, AT_NO_AUTOMOUNT, STATX_BASIC_STATS, &statx));\n\tif (ret == -1)\n\t\treturn ret;\n\n\tbuf->st_dev          = ((statx.stx_dev_minor & 0xff)\n\t\t\t       | (statx.stx_dev_major << 8)\n\t\t\t       | ((statx.stx_dev_minor & ~0xff) << 12));\n\tbuf->st_ino          = statx.stx_ino;\n\tbuf->st_mode         = statx.stx_mode;\n\tbuf->st_nlink        = statx.stx_nlink;\n\tbuf->st_uid          = statx.stx_uid;\n\tbuf->st_gid          = statx.stx_gid;\n\tbuf->st_rdev         = ((statx.stx_rdev_minor & 0xff)\n\t\t\t       | (statx.stx_rdev_major << 8)\n\t\t\t       | ((statx.stx_rdev_minor & ~0xff) << 12));\n\tbuf->st_size         = statx.stx_size;\n\tbuf->st_blksize      = statx.stx_blksize;\n\tbuf->st_blocks       = statx.stx_blocks;\n\tbuf->st_atim.tv_sec  = statx.stx_atime.tv_sec;\n\tbuf->st_atim.tv_nsec = statx.stx_atime.tv_nsec;\n\tbuf->st_mtim.tv_sec  = statx.stx_mtime.tv_sec;\n\tbuf->st_mtim.tv_nsec = statx.stx_mtime.tv_nsec;\n\tbuf->st_ctim.tv_sec  = statx.stx_ctime.tv_sec;\n\tbuf->st_ctim.tv_nsec = statx.stx_ctime.tv_nsec;\n\n\treturn 0;\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_symlink(const char *old, const char *new)\n{\n#ifdef __NR_symlinkat\n\treturn my_syscall3(__NR_symlinkat, old, AT_FDCWD, new);\n#elif defined(__NR_symlink)\n\treturn my_syscall2(__NR_symlink, old, new);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint symlink(const char *old, const char *new)\n{\n\treturn __sysret(sys_symlink(old, new));\n}\n\n\n \n\nstatic __attribute__((unused))\nmode_t sys_umask(mode_t mode)\n{\n\treturn my_syscall1(__NR_umask, mode);\n}\n\nstatic __attribute__((unused))\nmode_t umask(mode_t mode)\n{\n\treturn sys_umask(mode);\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_umount2(const char *path, int flags)\n{\n\treturn my_syscall2(__NR_umount2, path, flags);\n}\n\nstatic __attribute__((unused))\nint umount2(const char *path, int flags)\n{\n\treturn __sysret(sys_umount2(path, flags));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_unlink(const char *path)\n{\n#ifdef __NR_unlinkat\n\treturn my_syscall3(__NR_unlinkat, AT_FDCWD, path, 0);\n#elif defined(__NR_unlink)\n\treturn my_syscall1(__NR_unlink, path);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\nint unlink(const char *path)\n{\n\treturn __sysret(sys_unlink(path));\n}\n\n\n \n\nstatic __attribute__((unused))\npid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage)\n{\n#ifdef __NR_wait4\n\treturn my_syscall4(__NR_wait4, pid, status, options, rusage);\n#else\n\treturn -ENOSYS;\n#endif\n}\n\nstatic __attribute__((unused))\npid_t wait(int *status)\n{\n\treturn __sysret(sys_wait4(-1, status, 0, NULL));\n}\n\nstatic __attribute__((unused))\npid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage)\n{\n\treturn __sysret(sys_wait4(pid, status, options, rusage));\n}\n\n\nstatic __attribute__((unused))\npid_t waitpid(pid_t pid, int *status, int options)\n{\n\treturn __sysret(sys_wait4(pid, status, options, NULL));\n}\n\n\n \n\nstatic __attribute__((unused))\nssize_t sys_write(int fd, const void *buf, size_t count)\n{\n\treturn my_syscall3(__NR_write, fd, buf, count);\n}\n\nstatic __attribute__((unused))\nssize_t write(int fd, const void *buf, size_t count)\n{\n\treturn __sysret(sys_write(fd, buf, count));\n}\n\n\n \n\nstatic __attribute__((unused))\nint sys_memfd_create(const char *name, unsigned int flags)\n{\n\treturn my_syscall2(__NR_memfd_create, name, flags);\n}\n\nstatic __attribute__((unused))\nint memfd_create(const char *name, unsigned int flags)\n{\n\treturn __sysret(sys_memfd_create(name, flags));\n}\n\n \n#include \"nolibc.h\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}