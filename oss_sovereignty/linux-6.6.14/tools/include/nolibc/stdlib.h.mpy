{
  "module_name": "stdlib.h",
  "hash_id": "beb6dca5fb2bf7333c7e28500c9f9a82e1c0c0b919ae2f925e5ed9410945634b",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/nolibc/stdlib.h",
  "human_readable_source": " \n \n\n#ifndef _NOLIBC_STDLIB_H\n#define _NOLIBC_STDLIB_H\n\n#include \"std.h\"\n#include \"arch.h\"\n#include \"types.h\"\n#include \"sys.h\"\n#include \"string.h\"\n#include <linux/auxvec.h>\n\nstruct nolibc_heap {\n\tsize_t\tlen;\n\tchar\tuser_p[] __attribute__((__aligned__));\n};\n\n \nstatic __attribute__((unused)) char itoa_buffer[21];\n\n \n\n \n__attribute__((weak,unused,noreturn,section(\".text.nolibc_abort\")))\nvoid abort(void)\n{\n\tsys_kill(sys_getpid(), SIGABRT);\n\tfor (;;);\n}\n\nstatic __attribute__((unused))\nlong atol(const char *s)\n{\n\tunsigned long ret = 0;\n\tunsigned long d;\n\tint neg = 0;\n\n\tif (*s == '-') {\n\t\tneg = 1;\n\t\ts++;\n\t}\n\n\twhile (1) {\n\t\td = (*s++) - '0';\n\t\tif (d > 9)\n\t\t\tbreak;\n\t\tret *= 10;\n\t\tret += d;\n\t}\n\n\treturn neg ? -ret : ret;\n}\n\nstatic __attribute__((unused))\nint atoi(const char *s)\n{\n\treturn atol(s);\n}\n\nstatic __attribute__((unused))\nvoid free(void *ptr)\n{\n\tstruct nolibc_heap *heap;\n\n\tif (!ptr)\n\t\treturn;\n\n\theap = container_of(ptr, struct nolibc_heap, user_p);\n\tmunmap(heap, heap->len);\n}\n\n \nstatic __attribute__((unused))\nchar *getenv(const char *name)\n{\n\tint idx, i;\n\n\tif (environ) {\n\t\tfor (idx = 0; environ[idx]; idx++) {\n\t\t\tfor (i = 0; name[i] && name[i] == environ[idx][i];)\n\t\t\t\ti++;\n\t\t\tif (!name[i] && environ[idx][i] == '=')\n\t\t\t\treturn &environ[idx][i+1];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic __attribute__((unused))\nunsigned long getauxval(unsigned long type)\n{\n\tconst unsigned long *auxv = _auxv;\n\tunsigned long ret;\n\n\tif (!auxv)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tif (!auxv[0] && !auxv[1]) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (auxv[0] == type) {\n\t\t\tret = auxv[1];\n\t\t\tbreak;\n\t\t}\n\n\t\tauxv += 2;\n\t}\n\n\treturn ret;\n}\n\nstatic __attribute__((unused))\nvoid *malloc(size_t len)\n{\n\tstruct nolibc_heap *heap;\n\n\t \n\tlen  = sizeof(*heap) + len;\n\tlen  = (len + 4095UL) & -4096UL;\n\theap = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE,\n\t\t    -1, 0);\n\tif (__builtin_expect(heap == MAP_FAILED, 0))\n\t\treturn NULL;\n\n\theap->len = len;\n\treturn heap->user_p;\n}\n\nstatic __attribute__((unused))\nvoid *calloc(size_t size, size_t nmemb)\n{\n\tsize_t x = size * nmemb;\n\n\tif (__builtin_expect(size && ((x / size) != nmemb), 0)) {\n\t\tSET_ERRNO(ENOMEM);\n\t\treturn NULL;\n\t}\n\n\t \n\treturn malloc(x);\n}\n\nstatic __attribute__((unused))\nvoid *realloc(void *old_ptr, size_t new_size)\n{\n\tstruct nolibc_heap *heap;\n\tsize_t user_p_len;\n\tvoid *ret;\n\n\tif (!old_ptr)\n\t\treturn malloc(new_size);\n\n\theap = container_of(old_ptr, struct nolibc_heap, user_p);\n\tuser_p_len = heap->len - sizeof(*heap);\n\t \n\tif (user_p_len >= new_size)\n\t\treturn old_ptr;\n\n\tret = malloc(new_size);\n\tif (__builtin_expect(!ret, 0))\n\t\treturn NULL;\n\n\tmemcpy(ret, heap->user_p, heap->len);\n\tmunmap(heap, heap->len);\n\treturn ret;\n}\n\n \nstatic __attribute__((unused))\nint utoh_r(unsigned long in, char *buffer)\n{\n\tsigned char pos = (~0UL > 0xfffffffful) ? 60 : 28;\n\tint digits = 0;\n\tint dig;\n\n\tdo {\n\t\tdig = in >> pos;\n\t\tin -= (uint64_t)dig << pos;\n\t\tpos -= 4;\n\t\tif (dig || digits || pos < 0) {\n\t\t\tif (dig > 9)\n\t\t\t\tdig += 'a' - '0' - 10;\n\t\t\tbuffer[digits++] = '0' + dig;\n\t\t}\n\t} while (pos >= 0);\n\n\tbuffer[digits] = 0;\n\treturn digits;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *utoh(unsigned long in)\n{\n\tutoh_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __attribute__((unused))\nint utoa_r(unsigned long in, char *buffer)\n{\n\tunsigned long lim;\n\tint digits = 0;\n\tint pos = (~0UL > 0xfffffffful) ? 19 : 9;\n\tint dig;\n\n\tdo {\n\t\tfor (dig = 0, lim = 1; dig < pos; dig++)\n\t\t\tlim *= 10;\n\n\t\tif (digits || in >= lim || !pos) {\n\t\t\tfor (dig = 0; in >= lim; dig++)\n\t\t\t\tin -= lim;\n\t\t\tbuffer[digits++] = '0' + dig;\n\t\t}\n\t} while (pos--);\n\n\tbuffer[digits] = 0;\n\treturn digits;\n}\n\n \nstatic __attribute__((unused))\nint itoa_r(long in, char *buffer)\n{\n\tchar *ptr = buffer;\n\tint len = 0;\n\n\tif (in < 0) {\n\t\tin = -in;\n\t\t*(ptr++) = '-';\n\t\tlen++;\n\t}\n\tlen += utoa_r(in, ptr);\n\treturn len;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *ltoa_r(long in, char *buffer)\n{\n\titoa_r(in, buffer);\n\treturn buffer;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *itoa(long in)\n{\n\titoa_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *ltoa(long in)\n{\n\titoa_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *utoa(unsigned long in)\n{\n\tutoa_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __attribute__((unused))\nint u64toh_r(uint64_t in, char *buffer)\n{\n\tsigned char pos = 60;\n\tint digits = 0;\n\tint dig;\n\n\tdo {\n\t\tif (sizeof(long) >= 8) {\n\t\t\tdig = (in >> pos) & 0xF;\n\t\t} else {\n\t\t\t \n\t\t\tuint32_t d = (pos >= 32) ? (in >> 32) : in;\n\t\t\tdig = (d >> (pos & 31)) & 0xF;\n\t\t}\n\t\tif (dig > 9)\n\t\t\tdig += 'a' - '0' - 10;\n\t\tpos -= 4;\n\t\tif (dig || digits || pos < 0)\n\t\t\tbuffer[digits++] = '0' + dig;\n\t} while (pos >= 0);\n\n\tbuffer[digits] = 0;\n\treturn digits;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *u64toh(uint64_t in)\n{\n\tu64toh_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __attribute__((unused))\nint u64toa_r(uint64_t in, char *buffer)\n{\n\tunsigned long long lim;\n\tint digits = 0;\n\tint pos = 19;  \n\tint dig;\n\n\tdo {\n\t\tfor (dig = 0, lim = 1; dig < pos; dig++)\n\t\t\tlim *= 10;\n\n\t\tif (digits || in >= lim || !pos) {\n\t\t\tfor (dig = 0; in >= lim; dig++)\n\t\t\t\tin -= lim;\n\t\t\tbuffer[digits++] = '0' + dig;\n\t\t}\n\t} while (pos--);\n\n\tbuffer[digits] = 0;\n\treturn digits;\n}\n\n \nstatic __attribute__((unused))\nint i64toa_r(int64_t in, char *buffer)\n{\n\tchar *ptr = buffer;\n\tint len = 0;\n\n\tif (in < 0) {\n\t\tin = -in;\n\t\t*(ptr++) = '-';\n\t\tlen++;\n\t}\n\tlen += u64toa_r(in, ptr);\n\treturn len;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *i64toa(int64_t in)\n{\n\ti64toa_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \nstatic __inline__ __attribute__((unused))\nchar *u64toa(uint64_t in)\n{\n\tu64toa_r(in, itoa_buffer);\n\treturn itoa_buffer;\n}\n\n \n#include \"nolibc.h\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}