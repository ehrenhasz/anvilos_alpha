{
  "module_name": "types.h",
  "hash_id": "824b68cd9e9e7a8cc9747a1a520d25b483f58e2a4d4dc25df7057889610c71f7",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/nolibc/types.h",
  "human_readable_source": " \n \n\n#ifndef _NOLIBC_TYPES_H\n#define _NOLIBC_TYPES_H\n\n#include \"std.h\"\n#include <linux/mman.h>\n#include <linux/reboot.h>  \n#include <linux/stat.h>\n#include <linux/time.h>\n\n\n \n\n \n#if !defined(S_IFMT)\n#define S_IFDIR        0040000\n#define S_IFCHR        0020000\n#define S_IFBLK        0060000\n#define S_IFREG        0100000\n#define S_IFIFO        0010000\n#define S_IFLNK        0120000\n#define S_IFSOCK       0140000\n#define S_IFMT         0170000\n\n#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(mode)  (((mode) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(mode)  (((mode) & S_IFMT) == S_IFBLK)\n#define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)\n#define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)\n#define S_ISLNK(mode)  (((mode) & S_IFMT) == S_IFLNK)\n#define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)\n\n#define S_IRWXU 00700\n#define S_IRUSR 00400\n#define S_IWUSR 00200\n#define S_IXUSR 00100\n\n#define S_IRWXG 00070\n#define S_IRGRP 00040\n#define S_IWGRP 00020\n#define S_IXGRP 00010\n\n#define S_IRWXO 00007\n#define S_IROTH 00004\n#define S_IWOTH 00002\n#define S_IXOTH 00001\n#endif\n\n \n#define DT_UNKNOWN     0x0\n#define DT_FIFO        0x1\n#define DT_CHR         0x2\n#define DT_DIR         0x4\n#define DT_BLK         0x6\n#define DT_REG         0x8\n#define DT_LNK         0xa\n#define DT_SOCK        0xc\n\n \n#ifndef FD_SETSIZE\n#define FD_SETSIZE     256\n#endif\n\n \n#ifndef PATH_MAX\n#define PATH_MAX       4096\n#endif\n\n#ifndef MAXPATHLEN\n#define MAXPATHLEN     (PATH_MAX)\n#endif\n\n \n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n \n#define SEEK_SET       0\n#define SEEK_CUR       1\n#define SEEK_END       2\n\n \n#define RB_AUTOBOOT     LINUX_REBOOT_CMD_RESTART\n#define RB_HALT_SYSTEM  LINUX_REBOOT_CMD_HALT\n#define RB_ENABLE_CAD   LINUX_REBOOT_CMD_CAD_ON\n#define RB_DISABLE_CAD  LINUX_REBOOT_CMD_CAD_OFF\n#define RB_POWER_OFF    LINUX_REBOOT_CMD_POWER_OFF\n#define RB_SW_SUSPEND   LINUX_REBOOT_CMD_SW_SUSPEND\n#define RB_KEXEC        LINUX_REBOOT_CMD_KEXEC\n\n \n#define WEXITSTATUS(status) (((status) & 0xff00) >> 8)\n#define WIFEXITED(status)   (((status) & 0x7f) == 0)\n#define WTERMSIG(status)    ((status) & 0x7f)\n#define WIFSIGNALED(status) ((status) - 1 < 0xff)\n\n \n#define WNOHANG      1\n\n \n#define EXIT_SUCCESS 0\n#define EXIT_FAILURE 1\n\n#define FD_SETIDXMASK (8 * sizeof(unsigned long))\n#define FD_SETBITMASK (8 * sizeof(unsigned long)-1)\n\n \ntypedef struct {\n\tunsigned long fds[(FD_SETSIZE + FD_SETBITMASK) / FD_SETIDXMASK];\n} fd_set;\n\n#define FD_CLR(fd, set) do {\t\t\t\t\t\t\\\n\t\tfd_set *__set = (set);\t\t\t\t\t\\\n\t\tint __fd = (fd);\t\t\t\t\t\\\n\t\tif (__fd >= 0)\t\t\t\t\t\t\\\n\t\t\t__set->fds[__fd / FD_SETIDXMASK] &=\t\t\\\n\t\t\t\t~(1U << (__fd & FX_SETBITMASK));\t\\\n\t} while (0)\n\n#define FD_SET(fd, set) do {\t\t\t\t\t\t\\\n\t\tfd_set *__set = (set);\t\t\t\t\t\\\n\t\tint __fd = (fd);\t\t\t\t\t\\\n\t\tif (__fd >= 0)\t\t\t\t\t\t\\\n\t\t\t__set->fds[__fd / FD_SETIDXMASK] |=\t\t\\\n\t\t\t\t1 << (__fd & FD_SETBITMASK);\t\t\\\n\t} while (0)\n\n#define FD_ISSET(fd, set) ({\t\t\t\t\t\t\\\n\t\t\tfd_set *__set = (set);\t\t\t\t\\\n\t\t\tint __fd = (fd);\t\t\t\t\\\n\t\tint __r = 0;\t\t\t\t\t\t\\\n\t\tif (__fd >= 0)\t\t\t\t\t\t\\\n\t\t\t__r = !!(__set->fds[__fd / FD_SETIDXMASK] &\t\\\n1U << (__fd & FD_SET_BITMASK));\t\t\t\t\t\t\\\n\t\t__r;\t\t\t\t\t\t\t\\\n\t})\n\n#define FD_ZERO(set) do {\t\t\t\t\t\t\\\n\t\tfd_set *__set = (set);\t\t\t\t\t\\\n\t\tint __idx;\t\t\t\t\t\t\\\n\t\tint __size = (FD_SETSIZE+FD_SETBITMASK) / FD_SETIDXMASK;\\\n\t\tfor (__idx = 0; __idx < __size; __idx++)\t\t\\\n\t\t\t__set->fds[__idx] = 0;\t\t\t\t\\\n\t} while (0)\n\n \n#define POLLIN          0x0001\n#define POLLPRI         0x0002\n#define POLLOUT         0x0004\n#define POLLERR         0x0008\n#define POLLHUP         0x0010\n#define POLLNVAL        0x0020\n\nstruct pollfd {\n\tint fd;\n\tshort int events;\n\tshort int revents;\n};\n\n \nstruct linux_dirent64 {\n\tuint64_t       d_ino;\n\tint64_t        d_off;\n\tunsigned short d_reclen;\n\tunsigned char  d_type;\n\tchar           d_name[];\n};\n\n \nstruct rusage {\n\tstruct timeval ru_utime;\n\tstruct timeval ru_stime;\n\tlong   ru_maxrss;\n\tlong   ru_ixrss;\n\tlong   ru_idrss;\n\tlong   ru_isrss;\n\tlong   ru_minflt;\n\tlong   ru_majflt;\n\tlong   ru_nswap;\n\tlong   ru_inblock;\n\tlong   ru_oublock;\n\tlong   ru_msgsnd;\n\tlong   ru_msgrcv;\n\tlong   ru_nsignals;\n\tlong   ru_nvcsw;\n\tlong   ru_nivcsw;\n};\n\n \nstruct stat {\n\tdev_t     st_dev;      \n\tino_t     st_ino;      \n\tmode_t    st_mode;     \n\tnlink_t   st_nlink;    \n\tuid_t     st_uid;      \n\tgid_t     st_gid;      \n\tdev_t     st_rdev;     \n\toff_t     st_size;     \n\tblksize_t st_blksize;  \n\tblkcnt_t  st_blocks;   \n\tunion { time_t st_atime; struct timespec st_atim; };  \n\tunion { time_t st_mtime; struct timespec st_mtim; };  \n\tunion { time_t st_ctime; struct timespec st_ctim; };  \n};\n\n \n#define makedev(major, minor) ((dev_t)((((major) & 0xfff) << 8) | ((minor) & 0xff)))\n#define major(dev) ((unsigned int)(((dev) >> 8) & 0xfff))\n#define minor(dev) ((unsigned int)(((dev) & 0xff))\n\n#ifndef offsetof\n#define offsetof(TYPE, FIELD) ((size_t) &((TYPE *)0)->FIELD)\n#endif\n\n#ifndef container_of\n#define container_of(PTR, TYPE, FIELD) ({\t\t\t\\\n\t__typeof__(((TYPE *)0)->FIELD) *__FIELD_PTR = (PTR);\t\\\n\t(TYPE *)((char *) __FIELD_PTR - offsetof(TYPE, FIELD));\t\\\n})\n#endif\n\n \n#include \"nolibc.h\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}