{
  "module_name": "stdio.h",
  "hash_id": "1e29aee30ae29c48fad4fdee86d0ad4b013e0282db8d3d6bcf32c42b80d78cd4",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/nolibc/stdio.h",
  "human_readable_source": " \n \n\n#ifndef _NOLIBC_STDIO_H\n#define _NOLIBC_STDIO_H\n\n#include <stdarg.h>\n\n#include \"std.h\"\n#include \"arch.h\"\n#include \"errno.h\"\n#include \"types.h\"\n#include \"sys.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n\n#ifndef EOF\n#define EOF (-1)\n#endif\n\n \n#define _IOFBF 0\t \n#define _IOLBF 1\t \n#define _IONBF 2\t \n\n \ntypedef struct FILE {\n\tchar dummy[1];\n} FILE;\n\nstatic __attribute__((unused)) FILE* const stdin  = (FILE*)(intptr_t)~STDIN_FILENO;\nstatic __attribute__((unused)) FILE* const stdout = (FILE*)(intptr_t)~STDOUT_FILENO;\nstatic __attribute__((unused)) FILE* const stderr = (FILE*)(intptr_t)~STDERR_FILENO;\n\n \nstatic __attribute__((unused))\nFILE *fdopen(int fd, const char *mode __attribute__((unused)))\n{\n\tif (fd < 0) {\n\t\tSET_ERRNO(EBADF);\n\t\treturn NULL;\n\t}\n\treturn (FILE*)(intptr_t)~fd;\n}\n\n \nstatic __attribute__((unused))\nint fileno(FILE *stream)\n{\n\tintptr_t i = (intptr_t)stream;\n\n\tif (i >= 0) {\n\t\tSET_ERRNO(EBADF);\n\t\treturn -1;\n\t}\n\treturn ~i;\n}\n\n \nstatic __attribute__((unused))\nint fflush(FILE *stream)\n{\n\tintptr_t i = (intptr_t)stream;\n\n\t \n\tif (i > 0) {\n\t\tSET_ERRNO(EBADF);\n\t\treturn -1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic __attribute__((unused))\nint fclose(FILE *stream)\n{\n\tintptr_t i = (intptr_t)stream;\n\n\tif (i >= 0) {\n\t\tSET_ERRNO(EBADF);\n\t\treturn -1;\n\t}\n\n\tif (close(~i))\n\t\treturn EOF;\n\n\treturn 0;\n}\n\n \n\n#define getc(stream) fgetc(stream)\n\nstatic __attribute__((unused))\nint fgetc(FILE* stream)\n{\n\tunsigned char ch;\n\n\tif (read(fileno(stream), &ch, 1) <= 0)\n\t\treturn EOF;\n\treturn ch;\n}\n\nstatic __attribute__((unused))\nint getchar(void)\n{\n\treturn fgetc(stdin);\n}\n\n\n \n\n#define putc(c, stream) fputc(c, stream)\n\nstatic __attribute__((unused))\nint fputc(int c, FILE* stream)\n{\n\tunsigned char ch = c;\n\n\tif (write(fileno(stream), &ch, 1) <= 0)\n\t\treturn EOF;\n\treturn ch;\n}\n\nstatic __attribute__((unused))\nint putchar(int c)\n{\n\treturn fputc(c, stdout);\n}\n\n\n \n\n \nstatic __attribute__((unused))\nint _fwrite(const void *buf, size_t size, FILE *stream)\n{\n\tssize_t ret;\n\tint fd = fileno(stream);\n\n\twhile (size) {\n\t\tret = write(fd, buf, size);\n\t\tif (ret <= 0)\n\t\t\treturn EOF;\n\t\tsize -= ret;\n\t\tbuf += ret;\n\t}\n\treturn 0;\n}\n\nstatic __attribute__((unused))\nsize_t fwrite(const void *s, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t written;\n\n\tfor (written = 0; written < nmemb; written++) {\n\t\tif (_fwrite(s, size, stream) != 0)\n\t\t\tbreak;\n\t\ts += size;\n\t}\n\treturn written;\n}\n\nstatic __attribute__((unused))\nint fputs(const char *s, FILE *stream)\n{\n\treturn _fwrite(s, strlen(s), stream);\n}\n\nstatic __attribute__((unused))\nint puts(const char *s)\n{\n\tif (fputs(s, stdout) == EOF)\n\t\treturn EOF;\n\treturn putchar('\\n');\n}\n\n\n \nstatic __attribute__((unused))\nchar *fgets(char *s, int size, FILE *stream)\n{\n\tint ofs;\n\tint c;\n\n\tfor (ofs = 0; ofs + 1 < size;) {\n\t\tc = fgetc(stream);\n\t\tif (c == EOF)\n\t\t\tbreak;\n\t\ts[ofs++] = c;\n\t\tif (c == '\\n')\n\t\t\tbreak;\n\t}\n\tif (ofs < size)\n\t\ts[ofs] = 0;\n\treturn ofs ? s : NULL;\n}\n\n\n \nstatic __attribute__((unused))\nint vfprintf(FILE *stream, const char *fmt, va_list args)\n{\n\tchar escape, lpref, c;\n\tunsigned long long v;\n\tunsigned int written;\n\tsize_t len, ofs;\n\tchar tmpbuf[21];\n\tconst char *outstr;\n\n\twritten = ofs = escape = lpref = 0;\n\twhile (1) {\n\t\tc = fmt[ofs++];\n\n\t\tif (escape) {\n\t\t\t \n\t\t\tescape = 0;\n\t\t\tif (c == 'c' || c == 'd' || c == 'u' || c == 'x' || c == 'p') {\n\t\t\t\tchar *out = tmpbuf;\n\n\t\t\t\tif (c == 'p')\n\t\t\t\t\tv = va_arg(args, unsigned long);\n\t\t\t\telse if (lpref) {\n\t\t\t\t\tif (lpref > 1)\n\t\t\t\t\t\tv = va_arg(args, unsigned long long);\n\t\t\t\t\telse\n\t\t\t\t\t\tv = va_arg(args, unsigned long);\n\t\t\t\t} else\n\t\t\t\t\tv = va_arg(args, unsigned int);\n\n\t\t\t\tif (c == 'd') {\n\t\t\t\t\t \n\t\t\t\t\tif (lpref == 0)\n\t\t\t\t\t\tv = (long long)(int)v;\n\t\t\t\t\telse if (lpref == 1)\n\t\t\t\t\t\tv = (long long)(long)v;\n\t\t\t\t}\n\n\t\t\t\tswitch (c) {\n\t\t\t\tcase 'c':\n\t\t\t\t\tout[0] = v;\n\t\t\t\t\tout[1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\ti64toa_r(v, out);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tu64toa_r(v, out);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\t*(out++) = '0';\n\t\t\t\t\t*(out++) = 'x';\n\t\t\t\t\t \n\t\t\t\tdefault:  \n\t\t\t\t\tu64toh_r(v, out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toutstr = tmpbuf;\n\t\t\t}\n\t\t\telse if (c == 's') {\n\t\t\t\toutstr = va_arg(args, char *);\n\t\t\t\tif (!outstr)\n\t\t\t\t\toutstr=\"(null)\";\n\t\t\t}\n\t\t\telse if (c == '%') {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (c == 'l') {\n\t\t\t\t\t \n\t\t\t\t\tlpref++;\n\t\t\t\t}\n\t\t\t\tescape = 1;\n\t\t\t\tgoto do_escape;\n\t\t\t}\n\t\t\tlen = strlen(outstr);\n\t\t\tgoto flush_str;\n\t\t}\n\n\t\t \n\t\tif (c == 0 || c == '%') {\n\t\t\t \n\t\t\tescape = 1;\n\t\t\tlpref = 0;\n\t\t\toutstr = fmt;\n\t\t\tlen = ofs - 1;\n\t\tflush_str:\n\t\t\tif (_fwrite(outstr, len, stream) != 0)\n\t\t\t\tbreak;\n\n\t\t\twritten += len;\n\t\tdo_escape:\n\t\t\tif (c == 0)\n\t\t\t\tbreak;\n\t\t\tfmt += ofs;\n\t\t\tofs = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t}\n\treturn written;\n}\n\nstatic __attribute__((unused))\nint vprintf(const char *fmt, va_list args)\n{\n\treturn vfprintf(stdout, fmt, args);\n}\n\nstatic __attribute__((unused, format(printf, 2, 3)))\nint fprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vfprintf(stream, fmt, args);\n\tva_end(args);\n\treturn ret;\n}\n\nstatic __attribute__((unused, format(printf, 1, 2)))\nint printf(const char *fmt, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vfprintf(stdout, fmt, args);\n\tva_end(args);\n\treturn ret;\n}\n\nstatic __attribute__((unused))\nvoid perror(const char *msg)\n{\n\tfprintf(stderr, \"%s%serrno=%d\\n\", (msg && *msg) ? msg : \"\", (msg && *msg) ? \": \" : \"\", errno);\n}\n\nstatic __attribute__((unused))\nint setvbuf(FILE *stream __attribute__((unused)),\n\t    char *buf __attribute__((unused)),\n\t    int mode,\n\t    size_t size __attribute__((unused)))\n{\n\t \n\tswitch (mode) {\n\tcase _IOFBF:\n\tcase _IOLBF:\n\tcase _IONBF:\n\t\tbreak;\n\tdefault:\n\t\treturn EOF;\n\t}\n\n\treturn 0;\n}\n\n \n#include \"nolibc.h\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}