{
  "module_name": "drm.h",
  "hash_id": "7ddfc279572d870086c3193bfbba7571c793cd66fb5983cec2885025fcb590f4",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/uapi/drm/drm.h",
  "human_readable_source": " \n\n \n\n#ifndef _DRM_H_\n#define _DRM_H_\n\n#if defined(__KERNEL__)\n\n#include <linux/types.h>\n#include <asm/ioctl.h>\ntypedef unsigned int drm_handle_t;\n\n#elif defined(__linux__)\n\n#include <linux/types.h>\n#include <asm/ioctl.h>\ntypedef unsigned int drm_handle_t;\n\n#else  \n\n#include <stdint.h>\n#include <sys/ioccom.h>\n#include <sys/types.h>\ntypedef int8_t   __s8;\ntypedef uint8_t  __u8;\ntypedef int16_t  __s16;\ntypedef uint16_t __u16;\ntypedef int32_t  __s32;\ntypedef uint32_t __u32;\ntypedef int64_t  __s64;\ntypedef uint64_t __u64;\ntypedef size_t   __kernel_size_t;\ntypedef unsigned long drm_handle_t;\n\n#endif\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#define DRM_NAME\t\"drm\"\t   \n#define DRM_MIN_ORDER\t5\t   \n#define DRM_MAX_ORDER\t22\t   \n#define DRM_RAM_PERCENT 10\t   \n\n#define _DRM_LOCK_HELD\t0x80000000U  \n#define _DRM_LOCK_CONT\t0x40000000U  \n#define _DRM_LOCK_IS_HELD(lock)\t   ((lock) & _DRM_LOCK_HELD)\n#define _DRM_LOCK_IS_CONT(lock)\t   ((lock) & _DRM_LOCK_CONT)\n#define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))\n\ntypedef unsigned int drm_context_t;\ntypedef unsigned int drm_drawable_t;\ntypedef unsigned int drm_magic_t;\n\n \nstruct drm_clip_rect {\n\tunsigned short x1;\n\tunsigned short y1;\n\tunsigned short x2;\n\tunsigned short y2;\n};\n\n \nstruct drm_drawable_info {\n\tunsigned int num_rects;\n\tstruct drm_clip_rect *rects;\n};\n\n \nstruct drm_tex_region {\n\tunsigned char next;\n\tunsigned char prev;\n\tunsigned char in_use;\n\tunsigned char padding;\n\tunsigned int age;\n};\n\n \nstruct drm_hw_lock {\n\t__volatile__ unsigned int lock;\t\t \n\tchar padding[60];\t\t\t \n};\n\n \nstruct drm_version {\n\tint version_major;\t   \n\tint version_minor;\t   \n\tint version_patchlevel;\t   \n\t__kernel_size_t name_len;\t   \n\tchar __user *name;\t   \n\t__kernel_size_t date_len;\t   \n\tchar __user *date;\t   \n\t__kernel_size_t desc_len;\t   \n\tchar __user *desc;\t   \n};\n\n \nstruct drm_unique {\n\t__kernel_size_t unique_len;\t   \n\tchar __user *unique;\t   \n};\n\nstruct drm_list {\n\tint count;\t\t   \n\tstruct drm_version __user *version;\n};\n\nstruct drm_block {\n\tint unused;\n};\n\n \nstruct drm_control {\n\tenum {\n\t\tDRM_ADD_COMMAND,\n\t\tDRM_RM_COMMAND,\n\t\tDRM_INST_HANDLER,\n\t\tDRM_UNINST_HANDLER\n\t} func;\n\tint irq;\n};\n\n \nenum drm_map_type {\n\t_DRM_FRAME_BUFFER = 0,\t   \n\t_DRM_REGISTERS = 1,\t   \n\t_DRM_SHM = 2,\t\t   \n\t_DRM_AGP = 3,\t\t   \n\t_DRM_SCATTER_GATHER = 4,   \n\t_DRM_CONSISTENT = 5\t   \n};\n\n \nenum drm_map_flags {\n\t_DRM_RESTRICTED = 0x01,\t      \n\t_DRM_READ_ONLY = 0x02,\n\t_DRM_LOCKED = 0x04,\t      \n\t_DRM_KERNEL = 0x08,\t      \n\t_DRM_WRITE_COMBINING = 0x10,  \n\t_DRM_CONTAINS_LOCK = 0x20,    \n\t_DRM_REMOVABLE = 0x40,\t      \n\t_DRM_DRIVER = 0x80\t      \n};\n\nstruct drm_ctx_priv_map {\n\tunsigned int ctx_id;\t  \n\tvoid *handle;\t\t  \n};\n\n \nstruct drm_map {\n\tunsigned long offset;\t  \n\tunsigned long size;\t  \n\tenum drm_map_type type;\t  \n\tenum drm_map_flags flags;\t  \n\tvoid *handle;\t\t  \n\t\t\t\t  \n\tint mtrr;\t\t  \n\t \n};\n\n \nstruct drm_client {\n\tint idx;\t\t \n\tint auth;\t\t \n\tunsigned long pid;\t \n\tunsigned long uid;\t \n\tunsigned long magic;\t \n\tunsigned long iocs;\t \n};\n\nenum drm_stat_type {\n\t_DRM_STAT_LOCK,\n\t_DRM_STAT_OPENS,\n\t_DRM_STAT_CLOSES,\n\t_DRM_STAT_IOCTLS,\n\t_DRM_STAT_LOCKS,\n\t_DRM_STAT_UNLOCKS,\n\t_DRM_STAT_VALUE,\t \n\t_DRM_STAT_BYTE,\t\t \n\t_DRM_STAT_COUNT,\t \n\n\t_DRM_STAT_IRQ,\t\t \n\t_DRM_STAT_PRIMARY,\t \n\t_DRM_STAT_SECONDARY,\t \n\t_DRM_STAT_DMA,\t\t \n\t_DRM_STAT_SPECIAL,\t \n\t_DRM_STAT_MISSED\t \n\t     \n};\n\n \nstruct drm_stats {\n\tunsigned long count;\n\tstruct {\n\t\tunsigned long value;\n\t\tenum drm_stat_type type;\n\t} data[15];\n};\n\n \nenum drm_lock_flags {\n\t_DRM_LOCK_READY = 0x01,\t      \n\t_DRM_LOCK_QUIESCENT = 0x02,   \n\t_DRM_LOCK_FLUSH = 0x04,\t      \n\t_DRM_LOCK_FLUSH_ALL = 0x08,   \n\t \n\t_DRM_HALT_ALL_QUEUES = 0x10,  \n\t_DRM_HALT_CUR_QUEUES = 0x20   \n};\n\n \nstruct drm_lock {\n\tint context;\n\tenum drm_lock_flags flags;\n};\n\n \nenum drm_dma_flags {\n\t \n\t_DRM_DMA_BLOCK = 0x01,\t       \n\t_DRM_DMA_WHILE_LOCKED = 0x02,  \n\t_DRM_DMA_PRIORITY = 0x04,      \n\n\t \n\t_DRM_DMA_WAIT = 0x10,\t       \n\t_DRM_DMA_SMALLER_OK = 0x20,    \n\t_DRM_DMA_LARGER_OK = 0x40      \n};\n\n \nstruct drm_buf_desc {\n\tint count;\t\t  \n\tint size;\t\t  \n\tint low_mark;\t\t  \n\tint high_mark;\t\t  \n\tenum {\n\t\t_DRM_PAGE_ALIGN = 0x01,\t \n\t\t_DRM_AGP_BUFFER = 0x02,\t \n\t\t_DRM_SG_BUFFER = 0x04,\t \n\t\t_DRM_FB_BUFFER = 0x08,\t \n\t\t_DRM_PCI_BUFFER_RO = 0x10  \n\t} flags;\n\tunsigned long agp_start;  \n};\n\n \nstruct drm_buf_info {\n\tint count;\t\t \n\tstruct drm_buf_desc __user *list;\n};\n\n \nstruct drm_buf_free {\n\tint count;\n\tint __user *list;\n};\n\n \nstruct drm_buf_pub {\n\tint idx;\t\t        \n\tint total;\t\t        \n\tint used;\t\t        \n\tvoid __user *address;\t        \n};\n\n \nstruct drm_buf_map {\n\tint count;\t\t \n#ifdef __cplusplus\n\tvoid __user *virt;\n#else\n\tvoid __user *virtual;\t\t \n#endif\n\tstruct drm_buf_pub __user *list;\t \n};\n\n \nstruct drm_dma {\n\tint context;\t\t\t   \n\tint send_count;\t\t\t   \n\tint __user *send_indices;\t   \n\tint __user *send_sizes;\t\t   \n\tenum drm_dma_flags flags;\t   \n\tint request_count;\t\t   \n\tint request_size;\t\t   \n\tint __user *request_indices;\t   \n\tint __user *request_sizes;\n\tint granted_count;\t\t   \n};\n\nenum drm_ctx_flags {\n\t_DRM_CONTEXT_PRESERVED = 0x01,\n\t_DRM_CONTEXT_2DONLY = 0x02\n};\n\n \nstruct drm_ctx {\n\tdrm_context_t handle;\n\tenum drm_ctx_flags flags;\n};\n\n \nstruct drm_ctx_res {\n\tint count;\n\tstruct drm_ctx __user *contexts;\n};\n\n \nstruct drm_draw {\n\tdrm_drawable_t handle;\n};\n\n \ntypedef enum {\n\tDRM_DRAWABLE_CLIPRECTS\n} drm_drawable_info_type_t;\n\nstruct drm_update_draw {\n\tdrm_drawable_t handle;\n\tunsigned int type;\n\tunsigned int num;\n\tunsigned long long data;\n};\n\n \nstruct drm_auth {\n\tdrm_magic_t magic;\n};\n\n \nstruct drm_irq_busid {\n\tint irq;\t \n\tint busnum;\t \n\tint devnum;\t \n\tint funcnum;\t \n};\n\nenum drm_vblank_seq_type {\n\t_DRM_VBLANK_ABSOLUTE = 0x0,\t \n\t_DRM_VBLANK_RELATIVE = 0x1,\t \n\t \n\t_DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,\n\t_DRM_VBLANK_EVENT = 0x4000000,    \n\t_DRM_VBLANK_FLIP = 0x8000000,    \n\t_DRM_VBLANK_NEXTONMISS = 0x10000000,\t \n\t_DRM_VBLANK_SECONDARY = 0x20000000,\t \n\t_DRM_VBLANK_SIGNAL = 0x40000000\t \n};\n#define _DRM_VBLANK_HIGH_CRTC_SHIFT 1\n\n#define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)\n#define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_EVENT | _DRM_VBLANK_SIGNAL | \\\n\t\t\t\t_DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS)\n\nstruct drm_wait_vblank_request {\n\tenum drm_vblank_seq_type type;\n\tunsigned int sequence;\n\tunsigned long signal;\n};\n\nstruct drm_wait_vblank_reply {\n\tenum drm_vblank_seq_type type;\n\tunsigned int sequence;\n\tlong tval_sec;\n\tlong tval_usec;\n};\n\n \nunion drm_wait_vblank {\n\tstruct drm_wait_vblank_request request;\n\tstruct drm_wait_vblank_reply reply;\n};\n\n#define _DRM_PRE_MODESET 1\n#define _DRM_POST_MODESET 2\n\n \nstruct drm_modeset_ctl {\n\t__u32 crtc;\n\t__u32 cmd;\n};\n\n \nstruct drm_agp_mode {\n\tunsigned long mode;\t \n};\n\n \nstruct drm_agp_buffer {\n\tunsigned long size;\t \n\tunsigned long handle;\t \n\tunsigned long type;\t \n\tunsigned long physical;\t \n};\n\n \nstruct drm_agp_binding {\n\tunsigned long handle;\t \n\tunsigned long offset;\t \n};\n\n \nstruct drm_agp_info {\n\tint agp_version_major;\n\tint agp_version_minor;\n\tunsigned long mode;\n\tunsigned long aperture_base;\t \n\tunsigned long aperture_size;\t \n\tunsigned long memory_allowed;\t \n\tunsigned long memory_used;\n\n\t \n\tunsigned short id_vendor;\n\tunsigned short id_device;\n};\n\n \nstruct drm_scatter_gather {\n\tunsigned long size;\t \n\tunsigned long handle;\t \n};\n\n \nstruct drm_set_version {\n\tint drm_di_major;\n\tint drm_di_minor;\n\tint drm_dd_major;\n\tint drm_dd_minor;\n};\n\n \nstruct drm_gem_close {\n\t \n\t__u32 handle;\n\t__u32 pad;\n};\n\n \nstruct drm_gem_flink {\n\t \n\t__u32 handle;\n\n\t \n\t__u32 name;\n};\n\n \nstruct drm_gem_open {\n\t \n\t__u32 name;\n\n\t \n\t__u32 handle;\n\n\t \n\t__u64 size;\n};\n\n \n#define DRM_CAP_DUMB_BUFFER\t\t0x1\n \n#define DRM_CAP_VBLANK_HIGH_CRTC\t0x2\n \n#define DRM_CAP_DUMB_PREFERRED_DEPTH\t0x3\n \n#define DRM_CAP_DUMB_PREFER_SHADOW\t0x4\n \n#define DRM_CAP_PRIME\t\t\t0x5\n \n#define  DRM_PRIME_CAP_IMPORT\t\t0x1\n \n#define  DRM_PRIME_CAP_EXPORT\t\t0x2\n \n#define DRM_CAP_TIMESTAMP_MONOTONIC\t0x6\n \n#define DRM_CAP_ASYNC_PAGE_FLIP\t\t0x7\n \n#define DRM_CAP_CURSOR_WIDTH\t\t0x8\n \n#define DRM_CAP_CURSOR_HEIGHT\t\t0x9\n \n#define DRM_CAP_ADDFB2_MODIFIERS\t0x10\n \n#define DRM_CAP_PAGE_FLIP_TARGET\t0x11\n \n#define DRM_CAP_CRTC_IN_VBLANK_EVENT\t0x12\n \n#define DRM_CAP_SYNCOBJ\t\t0x13\n \n#define DRM_CAP_SYNCOBJ_TIMELINE\t0x14\n\n \nstruct drm_get_cap {\n\t__u64 capability;\n\t__u64 value;\n};\n\n \n#define DRM_CLIENT_CAP_STEREO_3D\t1\n\n \n#define DRM_CLIENT_CAP_UNIVERSAL_PLANES  2\n\n \n#define DRM_CLIENT_CAP_ATOMIC\t3\n\n \n#define DRM_CLIENT_CAP_ASPECT_RATIO    4\n\n \n#define DRM_CLIENT_CAP_WRITEBACK_CONNECTORS\t5\n\n \nstruct drm_set_client_cap {\n\t__u64 capability;\n\t__u64 value;\n};\n\n#define DRM_RDWR O_RDWR\n#define DRM_CLOEXEC O_CLOEXEC\nstruct drm_prime_handle {\n\t__u32 handle;\n\n\t \n\t__u32 flags;\n\n\t \n\t__s32 fd;\n};\n\nstruct drm_syncobj_create {\n\t__u32 handle;\n#define DRM_SYNCOBJ_CREATE_SIGNALED (1 << 0)\n\t__u32 flags;\n};\n\nstruct drm_syncobj_destroy {\n\t__u32 handle;\n\t__u32 pad;\n};\n\n#define DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE (1 << 0)\n#define DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE (1 << 0)\nstruct drm_syncobj_handle {\n\t__u32 handle;\n\t__u32 flags;\n\n\t__s32 fd;\n\t__u32 pad;\n};\n\nstruct drm_syncobj_transfer {\n\t__u32 src_handle;\n\t__u32 dst_handle;\n\t__u64 src_point;\n\t__u64 dst_point;\n\t__u32 flags;\n\t__u32 pad;\n};\n\n#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL (1 << 0)\n#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT (1 << 1)\n#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE (1 << 2)  \nstruct drm_syncobj_wait {\n\t__u64 handles;\n\t \n\t__s64 timeout_nsec;\n\t__u32 count_handles;\n\t__u32 flags;\n\t__u32 first_signaled;  \n\t__u32 pad;\n};\n\nstruct drm_syncobj_timeline_wait {\n\t__u64 handles;\n\t \n\t__u64 points;\n\t \n\t__s64 timeout_nsec;\n\t__u32 count_handles;\n\t__u32 flags;\n\t__u32 first_signaled;  \n\t__u32 pad;\n};\n\n \nstruct drm_syncobj_eventfd {\n\t__u32 handle;\n\t__u32 flags;\n\t__u64 point;\n\t__s32 fd;\n\t__u32 pad;\n};\n\n\nstruct drm_syncobj_array {\n\t__u64 handles;\n\t__u32 count_handles;\n\t__u32 pad;\n};\n\n#define DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED (1 << 0)  \nstruct drm_syncobj_timeline_array {\n\t__u64 handles;\n\t__u64 points;\n\t__u32 count_handles;\n\t__u32 flags;\n};\n\n\n \nstruct drm_crtc_get_sequence {\n\t__u32 crtc_id;\t\t \n\t__u32 active;\t\t \n\t__u64 sequence;\t\t \n\t__s64 sequence_ns;\t \n};\n\n \n#define DRM_CRTC_SEQUENCE_RELATIVE\t\t0x00000001\t \n#define DRM_CRTC_SEQUENCE_NEXT_ON_MISS\t\t0x00000002\t \n\nstruct drm_crtc_queue_sequence {\n\t__u32 crtc_id;\n\t__u32 flags;\n\t__u64 sequence;\t\t \n\t__u64 user_data;\t \n};\n\n#if defined(__cplusplus)\n}\n#endif\n\n#include \"drm_mode.h\"\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#define DRM_IOCTL_BASE\t\t\t'd'\n#define DRM_IO(nr)\t\t\t_IO(DRM_IOCTL_BASE,nr)\n#define DRM_IOR(nr,type)\t\t_IOR(DRM_IOCTL_BASE,nr,type)\n#define DRM_IOW(nr,type)\t\t_IOW(DRM_IOCTL_BASE,nr,type)\n#define DRM_IOWR(nr,type)\t\t_IOWR(DRM_IOCTL_BASE,nr,type)\n\n#define DRM_IOCTL_VERSION\t\tDRM_IOWR(0x00, struct drm_version)\n#define DRM_IOCTL_GET_UNIQUE\t\tDRM_IOWR(0x01, struct drm_unique)\n#define DRM_IOCTL_GET_MAGIC\t\tDRM_IOR( 0x02, struct drm_auth)\n#define DRM_IOCTL_IRQ_BUSID\t\tDRM_IOWR(0x03, struct drm_irq_busid)\n#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)\n#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)\n#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)\n#define DRM_IOCTL_SET_VERSION\t\tDRM_IOWR(0x07, struct drm_set_version)\n#define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)\n \n#define DRM_IOCTL_GEM_CLOSE\t\tDRM_IOW (0x09, struct drm_gem_close)\n#define DRM_IOCTL_GEM_FLINK\t\tDRM_IOWR(0x0a, struct drm_gem_flink)\n#define DRM_IOCTL_GEM_OPEN\t\tDRM_IOWR(0x0b, struct drm_gem_open)\n#define DRM_IOCTL_GET_CAP\t\tDRM_IOWR(0x0c, struct drm_get_cap)\n#define DRM_IOCTL_SET_CLIENT_CAP\tDRM_IOW( 0x0d, struct drm_set_client_cap)\n\n#define DRM_IOCTL_SET_UNIQUE\t\tDRM_IOW( 0x10, struct drm_unique)\n#define DRM_IOCTL_AUTH_MAGIC\t\tDRM_IOW( 0x11, struct drm_auth)\n#define DRM_IOCTL_BLOCK\t\t\tDRM_IOWR(0x12, struct drm_block)\n#define DRM_IOCTL_UNBLOCK\t\tDRM_IOWR(0x13, struct drm_block)\n#define DRM_IOCTL_CONTROL\t\tDRM_IOW( 0x14, struct drm_control)\n#define DRM_IOCTL_ADD_MAP\t\tDRM_IOWR(0x15, struct drm_map)\n#define DRM_IOCTL_ADD_BUFS\t\tDRM_IOWR(0x16, struct drm_buf_desc)\n#define DRM_IOCTL_MARK_BUFS\t\tDRM_IOW( 0x17, struct drm_buf_desc)\n#define DRM_IOCTL_INFO_BUFS\t\tDRM_IOWR(0x18, struct drm_buf_info)\n#define DRM_IOCTL_MAP_BUFS\t\tDRM_IOWR(0x19, struct drm_buf_map)\n#define DRM_IOCTL_FREE_BUFS\t\tDRM_IOW( 0x1a, struct drm_buf_free)\n\n#define DRM_IOCTL_RM_MAP\t\tDRM_IOW( 0x1b, struct drm_map)\n\n#define DRM_IOCTL_SET_SAREA_CTX\t\tDRM_IOW( 0x1c, struct drm_ctx_priv_map)\n#define DRM_IOCTL_GET_SAREA_CTX \tDRM_IOWR(0x1d, struct drm_ctx_priv_map)\n\n#define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)\n#define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)\n\n#define DRM_IOCTL_ADD_CTX\t\tDRM_IOWR(0x20, struct drm_ctx)\n#define DRM_IOCTL_RM_CTX\t\tDRM_IOWR(0x21, struct drm_ctx)\n#define DRM_IOCTL_MOD_CTX\t\tDRM_IOW( 0x22, struct drm_ctx)\n#define DRM_IOCTL_GET_CTX\t\tDRM_IOWR(0x23, struct drm_ctx)\n#define DRM_IOCTL_SWITCH_CTX\t\tDRM_IOW( 0x24, struct drm_ctx)\n#define DRM_IOCTL_NEW_CTX\t\tDRM_IOW( 0x25, struct drm_ctx)\n#define DRM_IOCTL_RES_CTX\t\tDRM_IOWR(0x26, struct drm_ctx_res)\n#define DRM_IOCTL_ADD_DRAW\t\tDRM_IOWR(0x27, struct drm_draw)\n#define DRM_IOCTL_RM_DRAW\t\tDRM_IOWR(0x28, struct drm_draw)\n#define DRM_IOCTL_DMA\t\t\tDRM_IOWR(0x29, struct drm_dma)\n#define DRM_IOCTL_LOCK\t\t\tDRM_IOW( 0x2a, struct drm_lock)\n#define DRM_IOCTL_UNLOCK\t\tDRM_IOW( 0x2b, struct drm_lock)\n#define DRM_IOCTL_FINISH\t\tDRM_IOW( 0x2c, struct drm_lock)\n\n \n#define DRM_IOCTL_PRIME_HANDLE_TO_FD    DRM_IOWR(0x2d, struct drm_prime_handle)\n \n#define DRM_IOCTL_PRIME_FD_TO_HANDLE    DRM_IOWR(0x2e, struct drm_prime_handle)\n\n#define DRM_IOCTL_AGP_ACQUIRE\t\tDRM_IO(  0x30)\n#define DRM_IOCTL_AGP_RELEASE\t\tDRM_IO(  0x31)\n#define DRM_IOCTL_AGP_ENABLE\t\tDRM_IOW( 0x32, struct drm_agp_mode)\n#define DRM_IOCTL_AGP_INFO\t\tDRM_IOR( 0x33, struct drm_agp_info)\n#define DRM_IOCTL_AGP_ALLOC\t\tDRM_IOWR(0x34, struct drm_agp_buffer)\n#define DRM_IOCTL_AGP_FREE\t\tDRM_IOW( 0x35, struct drm_agp_buffer)\n#define DRM_IOCTL_AGP_BIND\t\tDRM_IOW( 0x36, struct drm_agp_binding)\n#define DRM_IOCTL_AGP_UNBIND\t\tDRM_IOW( 0x37, struct drm_agp_binding)\n\n#define DRM_IOCTL_SG_ALLOC\t\tDRM_IOWR(0x38, struct drm_scatter_gather)\n#define DRM_IOCTL_SG_FREE\t\tDRM_IOW( 0x39, struct drm_scatter_gather)\n\n#define DRM_IOCTL_WAIT_VBLANK\t\tDRM_IOWR(0x3a, union drm_wait_vblank)\n\n#define DRM_IOCTL_CRTC_GET_SEQUENCE\tDRM_IOWR(0x3b, struct drm_crtc_get_sequence)\n#define DRM_IOCTL_CRTC_QUEUE_SEQUENCE\tDRM_IOWR(0x3c, struct drm_crtc_queue_sequence)\n\n#define DRM_IOCTL_UPDATE_DRAW\t\tDRM_IOW(0x3f, struct drm_update_draw)\n\n#define DRM_IOCTL_MODE_GETRESOURCES\tDRM_IOWR(0xA0, struct drm_mode_card_res)\n#define DRM_IOCTL_MODE_GETCRTC\t\tDRM_IOWR(0xA1, struct drm_mode_crtc)\n#define DRM_IOCTL_MODE_SETCRTC\t\tDRM_IOWR(0xA2, struct drm_mode_crtc)\n#define DRM_IOCTL_MODE_CURSOR\t\tDRM_IOWR(0xA3, struct drm_mode_cursor)\n#define DRM_IOCTL_MODE_GETGAMMA\t\tDRM_IOWR(0xA4, struct drm_mode_crtc_lut)\n#define DRM_IOCTL_MODE_SETGAMMA\t\tDRM_IOWR(0xA5, struct drm_mode_crtc_lut)\n#define DRM_IOCTL_MODE_GETENCODER\tDRM_IOWR(0xA6, struct drm_mode_get_encoder)\n#define DRM_IOCTL_MODE_GETCONNECTOR\tDRM_IOWR(0xA7, struct drm_mode_get_connector)\n#define DRM_IOCTL_MODE_ATTACHMODE\tDRM_IOWR(0xA8, struct drm_mode_mode_cmd)  \n#define DRM_IOCTL_MODE_DETACHMODE\tDRM_IOWR(0xA9, struct drm_mode_mode_cmd)  \n\n#define DRM_IOCTL_MODE_GETPROPERTY\tDRM_IOWR(0xAA, struct drm_mode_get_property)\n#define DRM_IOCTL_MODE_SETPROPERTY\tDRM_IOWR(0xAB, struct drm_mode_connector_set_property)\n#define DRM_IOCTL_MODE_GETPROPBLOB\tDRM_IOWR(0xAC, struct drm_mode_get_blob)\n#define DRM_IOCTL_MODE_GETFB\t\tDRM_IOWR(0xAD, struct drm_mode_fb_cmd)\n#define DRM_IOCTL_MODE_ADDFB\t\tDRM_IOWR(0xAE, struct drm_mode_fb_cmd)\n \n#define DRM_IOCTL_MODE_RMFB\t\tDRM_IOWR(0xAF, unsigned int)\n#define DRM_IOCTL_MODE_PAGE_FLIP\tDRM_IOWR(0xB0, struct drm_mode_crtc_page_flip)\n#define DRM_IOCTL_MODE_DIRTYFB\t\tDRM_IOWR(0xB1, struct drm_mode_fb_dirty_cmd)\n\n#define DRM_IOCTL_MODE_CREATE_DUMB DRM_IOWR(0xB2, struct drm_mode_create_dumb)\n#define DRM_IOCTL_MODE_MAP_DUMB    DRM_IOWR(0xB3, struct drm_mode_map_dumb)\n#define DRM_IOCTL_MODE_DESTROY_DUMB    DRM_IOWR(0xB4, struct drm_mode_destroy_dumb)\n#define DRM_IOCTL_MODE_GETPLANERESOURCES DRM_IOWR(0xB5, struct drm_mode_get_plane_res)\n#define DRM_IOCTL_MODE_GETPLANE\tDRM_IOWR(0xB6, struct drm_mode_get_plane)\n#define DRM_IOCTL_MODE_SETPLANE\tDRM_IOWR(0xB7, struct drm_mode_set_plane)\n#define DRM_IOCTL_MODE_ADDFB2\t\tDRM_IOWR(0xB8, struct drm_mode_fb_cmd2)\n#define DRM_IOCTL_MODE_OBJ_GETPROPERTIES\tDRM_IOWR(0xB9, struct drm_mode_obj_get_properties)\n#define DRM_IOCTL_MODE_OBJ_SETPROPERTY\tDRM_IOWR(0xBA, struct drm_mode_obj_set_property)\n#define DRM_IOCTL_MODE_CURSOR2\t\tDRM_IOWR(0xBB, struct drm_mode_cursor2)\n#define DRM_IOCTL_MODE_ATOMIC\t\tDRM_IOWR(0xBC, struct drm_mode_atomic)\n#define DRM_IOCTL_MODE_CREATEPROPBLOB\tDRM_IOWR(0xBD, struct drm_mode_create_blob)\n#define DRM_IOCTL_MODE_DESTROYPROPBLOB\tDRM_IOWR(0xBE, struct drm_mode_destroy_blob)\n\n#define DRM_IOCTL_SYNCOBJ_CREATE\tDRM_IOWR(0xBF, struct drm_syncobj_create)\n#define DRM_IOCTL_SYNCOBJ_DESTROY\tDRM_IOWR(0xC0, struct drm_syncobj_destroy)\n#define DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD\tDRM_IOWR(0xC1, struct drm_syncobj_handle)\n#define DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE\tDRM_IOWR(0xC2, struct drm_syncobj_handle)\n#define DRM_IOCTL_SYNCOBJ_WAIT\t\tDRM_IOWR(0xC3, struct drm_syncobj_wait)\n#define DRM_IOCTL_SYNCOBJ_RESET\t\tDRM_IOWR(0xC4, struct drm_syncobj_array)\n#define DRM_IOCTL_SYNCOBJ_SIGNAL\tDRM_IOWR(0xC5, struct drm_syncobj_array)\n\n#define DRM_IOCTL_MODE_CREATE_LEASE\tDRM_IOWR(0xC6, struct drm_mode_create_lease)\n#define DRM_IOCTL_MODE_LIST_LESSEES\tDRM_IOWR(0xC7, struct drm_mode_list_lessees)\n#define DRM_IOCTL_MODE_GET_LEASE\tDRM_IOWR(0xC8, struct drm_mode_get_lease)\n#define DRM_IOCTL_MODE_REVOKE_LEASE\tDRM_IOWR(0xC9, struct drm_mode_revoke_lease)\n\n#define DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT\tDRM_IOWR(0xCA, struct drm_syncobj_timeline_wait)\n#define DRM_IOCTL_SYNCOBJ_QUERY\t\tDRM_IOWR(0xCB, struct drm_syncobj_timeline_array)\n#define DRM_IOCTL_SYNCOBJ_TRANSFER\tDRM_IOWR(0xCC, struct drm_syncobj_transfer)\n#define DRM_IOCTL_SYNCOBJ_TIMELINE_SIGNAL\tDRM_IOWR(0xCD, struct drm_syncobj_timeline_array)\n\n \n#define DRM_IOCTL_MODE_GETFB2\t\tDRM_IOWR(0xCE, struct drm_mode_fb_cmd2)\n\n#define DRM_IOCTL_SYNCOBJ_EVENTFD\tDRM_IOWR(0xCF, struct drm_syncobj_eventfd)\n\n \n#define DRM_COMMAND_BASE                0x40\n#define DRM_COMMAND_END\t\t\t0xA0\n\n \nstruct drm_event {\n\t__u32 type;\n\t__u32 length;\n};\n\n \n#define DRM_EVENT_VBLANK 0x01\n \n#define DRM_EVENT_FLIP_COMPLETE 0x02\n \n#define DRM_EVENT_CRTC_SEQUENCE\t0x03\n\nstruct drm_event_vblank {\n\tstruct drm_event base;\n\t__u64 user_data;\n\t__u32 tv_sec;\n\t__u32 tv_usec;\n\t__u32 sequence;\n\t__u32 crtc_id;  \n};\n\n \nstruct drm_event_crtc_sequence {\n\tstruct drm_event\tbase;\n\t__u64\t\t\tuser_data;\n\t__s64\t\t\ttime_ns;\n\t__u64\t\t\tsequence;\n};\n\n \n#ifndef __KERNEL__\ntypedef struct drm_clip_rect drm_clip_rect_t;\ntypedef struct drm_drawable_info drm_drawable_info_t;\ntypedef struct drm_tex_region drm_tex_region_t;\ntypedef struct drm_hw_lock drm_hw_lock_t;\ntypedef struct drm_version drm_version_t;\ntypedef struct drm_unique drm_unique_t;\ntypedef struct drm_list drm_list_t;\ntypedef struct drm_block drm_block_t;\ntypedef struct drm_control drm_control_t;\ntypedef enum drm_map_type drm_map_type_t;\ntypedef enum drm_map_flags drm_map_flags_t;\ntypedef struct drm_ctx_priv_map drm_ctx_priv_map_t;\ntypedef struct drm_map drm_map_t;\ntypedef struct drm_client drm_client_t;\ntypedef enum drm_stat_type drm_stat_type_t;\ntypedef struct drm_stats drm_stats_t;\ntypedef enum drm_lock_flags drm_lock_flags_t;\ntypedef struct drm_lock drm_lock_t;\ntypedef enum drm_dma_flags drm_dma_flags_t;\ntypedef struct drm_buf_desc drm_buf_desc_t;\ntypedef struct drm_buf_info drm_buf_info_t;\ntypedef struct drm_buf_free drm_buf_free_t;\ntypedef struct drm_buf_pub drm_buf_pub_t;\ntypedef struct drm_buf_map drm_buf_map_t;\ntypedef struct drm_dma drm_dma_t;\ntypedef union drm_wait_vblank drm_wait_vblank_t;\ntypedef struct drm_agp_mode drm_agp_mode_t;\ntypedef enum drm_ctx_flags drm_ctx_flags_t;\ntypedef struct drm_ctx drm_ctx_t;\ntypedef struct drm_ctx_res drm_ctx_res_t;\ntypedef struct drm_draw drm_draw_t;\ntypedef struct drm_update_draw drm_update_draw_t;\ntypedef struct drm_auth drm_auth_t;\ntypedef struct drm_irq_busid drm_irq_busid_t;\ntypedef enum drm_vblank_seq_type drm_vblank_seq_type_t;\n\ntypedef struct drm_agp_buffer drm_agp_buffer_t;\ntypedef struct drm_agp_binding drm_agp_binding_t;\ntypedef struct drm_agp_info drm_agp_info_t;\ntypedef struct drm_scatter_gather drm_scatter_gather_t;\ntypedef struct drm_set_version drm_set_version_t;\n#endif\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}