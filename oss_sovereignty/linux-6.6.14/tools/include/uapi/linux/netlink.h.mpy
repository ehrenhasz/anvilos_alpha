{
  "module_name": "netlink.h",
  "hash_id": "7fc362f686421bf68eab8f2f0f84ad7a1a5f992defc3f4a10c57cab43e5e0500",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/uapi/linux/netlink.h",
  "human_readable_source": " \n#ifndef _UAPI__LINUX_NETLINK_H\n#define _UAPI__LINUX_NETLINK_H\n\n#include <linux/kernel.h>\n#include <linux/socket.h>  \n#include <linux/types.h>\n\n#define NETLINK_ROUTE\t\t0\t \n#define NETLINK_UNUSED\t\t1\t \n#define NETLINK_USERSOCK\t2\t \n#define NETLINK_FIREWALL\t3\t \n#define NETLINK_SOCK_DIAG\t4\t \n#define NETLINK_NFLOG\t\t5\t \n#define NETLINK_XFRM\t\t6\t \n#define NETLINK_SELINUX\t\t7\t \n#define NETLINK_ISCSI\t\t8\t \n#define NETLINK_AUDIT\t\t9\t \n#define NETLINK_FIB_LOOKUP\t10\t\n#define NETLINK_CONNECTOR\t11\n#define NETLINK_NETFILTER\t12\t \n#define NETLINK_IP6_FW\t\t13\n#define NETLINK_DNRTMSG\t\t14\t \n#define NETLINK_KOBJECT_UEVENT\t15\t \n#define NETLINK_GENERIC\t\t16\n \n#define NETLINK_SCSITRANSPORT\t18\t \n#define NETLINK_ECRYPTFS\t19\n#define NETLINK_RDMA\t\t20\n#define NETLINK_CRYPTO\t\t21\t \n#define NETLINK_SMC\t\t22\t \n\n#define NETLINK_INET_DIAG\tNETLINK_SOCK_DIAG\n\n#define MAX_LINKS 32\t\t\n\nstruct sockaddr_nl {\n\t__kernel_sa_family_t\tnl_family;\t \n\tunsigned short\tnl_pad;\t\t \n\t__u32\t\tnl_pid;\t\t \n       \t__u32\t\tnl_groups;\t \n};\n\nstruct nlmsghdr {\n\t__u32\t\tnlmsg_len;\t \n\t__u16\t\tnlmsg_type;\t \n\t__u16\t\tnlmsg_flags;\t \n\t__u32\t\tnlmsg_seq;\t \n\t__u32\t\tnlmsg_pid;\t \n};\n\n \n\n#define NLM_F_REQUEST\t\t0x01\t \n#define NLM_F_MULTI\t\t0x02\t \n#define NLM_F_ACK\t\t0x04\t \n#define NLM_F_ECHO\t\t0x08\t \n#define NLM_F_DUMP_INTR\t\t0x10\t \n#define NLM_F_DUMP_FILTERED\t0x20\t \n\n \n#define NLM_F_ROOT\t0x100\t \n#define NLM_F_MATCH\t0x200\t \n#define NLM_F_ATOMIC\t0x400\t \n#define NLM_F_DUMP\t(NLM_F_ROOT|NLM_F_MATCH)\n\n \n#define NLM_F_REPLACE\t0x100\t \n#define NLM_F_EXCL\t0x200\t \n#define NLM_F_CREATE\t0x400\t \n#define NLM_F_APPEND\t0x800\t \n\n \n#define NLM_F_NONREC\t0x100\t \n\n \n#define NLM_F_CAPPED\t0x100\t \n#define NLM_F_ACK_TLVS\t0x200\t \n\n \n\n#define NLMSG_ALIGNTO\t4U\n#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )\n#define NLMSG_HDRLEN\t ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))\n#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)\n#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))\n#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))\n#define NLMSG_NEXT(nlh,len)\t ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \\\n\t\t\t\t  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))\n#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \\\n\t\t\t   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \\\n\t\t\t   (nlh)->nlmsg_len <= (len))\n#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))\n\n#define NLMSG_NOOP\t\t0x1\t \n#define NLMSG_ERROR\t\t0x2\t \n#define NLMSG_DONE\t\t0x3\t \n#define NLMSG_OVERRUN\t\t0x4\t \n\n#define NLMSG_MIN_TYPE\t\t0x10\t \n\nstruct nlmsgerr {\n\tint\t\terror;\n\tstruct nlmsghdr msg;\n\t \n\t \n};\n\n \nenum nlmsgerr_attrs {\n\tNLMSGERR_ATTR_UNUSED,\n\tNLMSGERR_ATTR_MSG,\n\tNLMSGERR_ATTR_OFFS,\n\tNLMSGERR_ATTR_COOKIE,\n\n\t__NLMSGERR_ATTR_MAX,\n\tNLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1\n};\n\n#define NETLINK_ADD_MEMBERSHIP\t\t1\n#define NETLINK_DROP_MEMBERSHIP\t\t2\n#define NETLINK_PKTINFO\t\t\t3\n#define NETLINK_BROADCAST_ERROR\t\t4\n#define NETLINK_NO_ENOBUFS\t\t5\n#ifndef __KERNEL__\n#define NETLINK_RX_RING\t\t\t6\n#define NETLINK_TX_RING\t\t\t7\n#endif\n#define NETLINK_LISTEN_ALL_NSID\t\t8\n#define NETLINK_LIST_MEMBERSHIPS\t9\n#define NETLINK_CAP_ACK\t\t\t10\n#define NETLINK_EXT_ACK\t\t\t11\n#define NETLINK_GET_STRICT_CHK\t\t12\n\nstruct nl_pktinfo {\n\t__u32\tgroup;\n};\n\nstruct nl_mmap_req {\n\tunsigned int\tnm_block_size;\n\tunsigned int\tnm_block_nr;\n\tunsigned int\tnm_frame_size;\n\tunsigned int\tnm_frame_nr;\n};\n\nstruct nl_mmap_hdr {\n\tunsigned int\tnm_status;\n\tunsigned int\tnm_len;\n\t__u32\t\tnm_group;\n\t \n\t__u32\t\tnm_pid;\n\t__u32\t\tnm_uid;\n\t__u32\t\tnm_gid;\n};\n\n#ifndef __KERNEL__\nenum nl_mmap_status {\n\tNL_MMAP_STATUS_UNUSED,\n\tNL_MMAP_STATUS_RESERVED,\n\tNL_MMAP_STATUS_VALID,\n\tNL_MMAP_STATUS_COPY,\n\tNL_MMAP_STATUS_SKIP,\n};\n\n#define NL_MMAP_MSG_ALIGNMENT\t\tNLMSG_ALIGNTO\n#define NL_MMAP_MSG_ALIGN(sz)\t\t__ALIGN_KERNEL(sz, NL_MMAP_MSG_ALIGNMENT)\n#define NL_MMAP_HDRLEN\t\t\tNL_MMAP_MSG_ALIGN(sizeof(struct nl_mmap_hdr))\n#endif\n\n#define NET_MAJOR 36\t\t \n\nenum {\n\tNETLINK_UNCONNECTED = 0,\n\tNETLINK_CONNECTED,\n};\n\n \n\nstruct nlattr {\n\t__u16           nla_len;\n\t__u16           nla_type;\n};\n\n \n#define NLA_F_NESTED\t\t(1 << 15)\n#define NLA_F_NET_BYTEORDER\t(1 << 14)\n#define NLA_TYPE_MASK\t\t~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)\n\n#define NLA_ALIGNTO\t\t4\n#define NLA_ALIGN(len)\t\t(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))\n#define NLA_HDRLEN\t\t((int) NLA_ALIGN(sizeof(struct nlattr)))\n\n \nstruct nla_bitfield32 {\n\t__u32 value;\n\t__u32 selector;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}