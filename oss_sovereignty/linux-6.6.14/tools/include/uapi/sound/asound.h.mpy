{
  "module_name": "asound.h",
  "hash_id": "f7eb3856c7f4839e46adce4c20033094effdecb716b57fabf7e24bb617f59bf0",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/uapi/sound/asound.h",
  "human_readable_source": " \n \n\n#ifndef _UAPI__SOUND_ASOUND_H\n#define _UAPI__SOUND_ASOUND_H\n\n#if defined(__KERNEL__) || defined(__linux__)\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#else\n#include <endian.h>\n#include <sys/ioctl.h>\n#endif\n\n#ifndef __KERNEL__\n#include <stdlib.h>\n#include <time.h>\n#endif\n\n \n\n#define SNDRV_PROTOCOL_VERSION(major, minor, subminor) (((major)<<16)|((minor)<<8)|(subminor))\n#define SNDRV_PROTOCOL_MAJOR(version) (((version)>>16)&0xffff)\n#define SNDRV_PROTOCOL_MINOR(version) (((version)>>8)&0xff)\n#define SNDRV_PROTOCOL_MICRO(version) ((version)&0xff)\n#define SNDRV_PROTOCOL_INCOMPATIBLE(kversion, uversion) \\\n\t(SNDRV_PROTOCOL_MAJOR(kversion) != SNDRV_PROTOCOL_MAJOR(uversion) || \\\n\t (SNDRV_PROTOCOL_MAJOR(kversion) == SNDRV_PROTOCOL_MAJOR(uversion) && \\\n\t   SNDRV_PROTOCOL_MINOR(kversion) != SNDRV_PROTOCOL_MINOR(uversion)))\n\n \n\n#define AES_IEC958_STATUS_SIZE\t\t24\n\nstruct snd_aes_iec958 {\n\tunsigned char status[AES_IEC958_STATUS_SIZE];  \n\tunsigned char subcode[147];\t \n\tunsigned char pad;\t\t \n\tunsigned char dig_subframe[4];\t \n};\n\n \n\nstruct snd_cea_861_aud_if {\n\tunsigned char db1_ct_cc;  \n\tunsigned char db2_sf_ss;  \n\tunsigned char db3;  \n\tunsigned char db4_ca;  \n\tunsigned char db5_dminh_lsv;  \n};\n\n \n\n#define SNDRV_HWDEP_VERSION\t\tSNDRV_PROTOCOL_VERSION(1, 0, 1)\n\nenum {\n\tSNDRV_HWDEP_IFACE_OPL2 = 0,\n\tSNDRV_HWDEP_IFACE_OPL3,\n\tSNDRV_HWDEP_IFACE_OPL4,\n\tSNDRV_HWDEP_IFACE_SB16CSP,\t \n\tSNDRV_HWDEP_IFACE_EMU10K1,\t \n\tSNDRV_HWDEP_IFACE_YSS225,\t \n\tSNDRV_HWDEP_IFACE_ICS2115,\t \n\tSNDRV_HWDEP_IFACE_SSCAPE,\t \n\tSNDRV_HWDEP_IFACE_VX,\t\t \n\tSNDRV_HWDEP_IFACE_MIXART,\t \n\tSNDRV_HWDEP_IFACE_USX2Y,\t \n\tSNDRV_HWDEP_IFACE_EMUX_WAVETABLE,  \n\tSNDRV_HWDEP_IFACE_BLUETOOTH,\t \n\tSNDRV_HWDEP_IFACE_USX2Y_PCM,\t \n\tSNDRV_HWDEP_IFACE_PCXHR,\t \n\tSNDRV_HWDEP_IFACE_SB_RC,\t \n\tSNDRV_HWDEP_IFACE_HDA,\t\t \n\tSNDRV_HWDEP_IFACE_USB_STREAM,\t \n\tSNDRV_HWDEP_IFACE_FW_DICE,\t \n\tSNDRV_HWDEP_IFACE_FW_FIREWORKS,\t \n\tSNDRV_HWDEP_IFACE_FW_BEBOB,\t \n\tSNDRV_HWDEP_IFACE_FW_OXFW,\t \n\tSNDRV_HWDEP_IFACE_FW_DIGI00X,\t \n\tSNDRV_HWDEP_IFACE_FW_TASCAM,\t \n\tSNDRV_HWDEP_IFACE_LINE6,\t \n\tSNDRV_HWDEP_IFACE_FW_MOTU,\t \n\tSNDRV_HWDEP_IFACE_FW_FIREFACE,\t \n\n\t \n\tSNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_FW_FIREFACE\n};\n\nstruct snd_hwdep_info {\n\tunsigned int device;\t\t \n\tint card;\t\t\t \n\tunsigned char id[64];\t\t \n\tunsigned char name[80];\t\t \n\tint iface;\t\t\t \n\tunsigned char reserved[64];\t \n};\n\n \nstruct snd_hwdep_dsp_status {\n\tunsigned int version;\t\t \n\tunsigned char id[32];\t\t \n\tunsigned int num_dsps;\t\t \n\tunsigned int dsp_loaded;\t \n\tunsigned int chip_ready;\t \n\tunsigned char reserved[16];\t \n};\n\nstruct snd_hwdep_dsp_image {\n\tunsigned int index;\t\t \n\tunsigned char name[64];\t\t \n\tunsigned char __user *image;\t \n\tsize_t length;\t\t\t \n\tunsigned long driver_data;\t \n};\n\n#define SNDRV_HWDEP_IOCTL_PVERSION\t_IOR ('H', 0x00, int)\n#define SNDRV_HWDEP_IOCTL_INFO\t\t_IOR ('H', 0x01, struct snd_hwdep_info)\n#define SNDRV_HWDEP_IOCTL_DSP_STATUS\t_IOR('H', 0x02, struct snd_hwdep_dsp_status)\n#define SNDRV_HWDEP_IOCTL_DSP_LOAD\t_IOW('H', 0x03, struct snd_hwdep_dsp_image)\n\n \n\n#define SNDRV_PCM_VERSION\t\tSNDRV_PROTOCOL_VERSION(2, 0, 15)\n\ntypedef unsigned long snd_pcm_uframes_t;\ntypedef signed long snd_pcm_sframes_t;\n\nenum {\n\tSNDRV_PCM_CLASS_GENERIC = 0,\t \n\tSNDRV_PCM_CLASS_MULTI,\t\t \n\tSNDRV_PCM_CLASS_MODEM,\t\t \n\tSNDRV_PCM_CLASS_DIGITIZER,\t \n\t \n\tSNDRV_PCM_CLASS_LAST = SNDRV_PCM_CLASS_DIGITIZER,\n};\n\nenum {\n\tSNDRV_PCM_SUBCLASS_GENERIC_MIX = 0,  \n\tSNDRV_PCM_SUBCLASS_MULTI_MIX,\t \n\t \n\tSNDRV_PCM_SUBCLASS_LAST = SNDRV_PCM_SUBCLASS_MULTI_MIX,\n};\n\nenum {\n\tSNDRV_PCM_STREAM_PLAYBACK = 0,\n\tSNDRV_PCM_STREAM_CAPTURE,\n\tSNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,\n};\n\ntypedef int __bitwise snd_pcm_access_t;\n#define\tSNDRV_PCM_ACCESS_MMAP_INTERLEAVED\t((__force snd_pcm_access_t) 0)  \n#define\tSNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED\t((__force snd_pcm_access_t) 1)  \n#define\tSNDRV_PCM_ACCESS_MMAP_COMPLEX\t\t((__force snd_pcm_access_t) 2)  \n#define\tSNDRV_PCM_ACCESS_RW_INTERLEAVED\t\t((__force snd_pcm_access_t) 3)  \n#define\tSNDRV_PCM_ACCESS_RW_NONINTERLEAVED\t((__force snd_pcm_access_t) 4)  \n#define\tSNDRV_PCM_ACCESS_LAST\t\tSNDRV_PCM_ACCESS_RW_NONINTERLEAVED\n\ntypedef int __bitwise snd_pcm_format_t;\n#define\tSNDRV_PCM_FORMAT_S8\t((__force snd_pcm_format_t) 0)\n#define\tSNDRV_PCM_FORMAT_U8\t((__force snd_pcm_format_t) 1)\n#define\tSNDRV_PCM_FORMAT_S16_LE\t((__force snd_pcm_format_t) 2)\n#define\tSNDRV_PCM_FORMAT_S16_BE\t((__force snd_pcm_format_t) 3)\n#define\tSNDRV_PCM_FORMAT_U16_LE\t((__force snd_pcm_format_t) 4)\n#define\tSNDRV_PCM_FORMAT_U16_BE\t((__force snd_pcm_format_t) 5)\n#define\tSNDRV_PCM_FORMAT_S24_LE\t((__force snd_pcm_format_t) 6)  \n#define\tSNDRV_PCM_FORMAT_S24_BE\t((__force snd_pcm_format_t) 7)  \n#define\tSNDRV_PCM_FORMAT_U24_LE\t((__force snd_pcm_format_t) 8)  \n#define\tSNDRV_PCM_FORMAT_U24_BE\t((__force snd_pcm_format_t) 9)  \n \n#define\tSNDRV_PCM_FORMAT_S32_LE\t((__force snd_pcm_format_t) 10)\n#define\tSNDRV_PCM_FORMAT_S32_BE\t((__force snd_pcm_format_t) 11)\n#define\tSNDRV_PCM_FORMAT_U32_LE\t((__force snd_pcm_format_t) 12)\n#define\tSNDRV_PCM_FORMAT_U32_BE\t((__force snd_pcm_format_t) 13)\n#define\tSNDRV_PCM_FORMAT_FLOAT_LE\t((__force snd_pcm_format_t) 14)  \n#define\tSNDRV_PCM_FORMAT_FLOAT_BE\t((__force snd_pcm_format_t) 15)  \n#define\tSNDRV_PCM_FORMAT_FLOAT64_LE\t((__force snd_pcm_format_t) 16)  \n#define\tSNDRV_PCM_FORMAT_FLOAT64_BE\t((__force snd_pcm_format_t) 17)  \n#define\tSNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE ((__force snd_pcm_format_t) 18)  \n#define\tSNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE ((__force snd_pcm_format_t) 19)  \n#define\tSNDRV_PCM_FORMAT_MU_LAW\t\t((__force snd_pcm_format_t) 20)\n#define\tSNDRV_PCM_FORMAT_A_LAW\t\t((__force snd_pcm_format_t) 21)\n#define\tSNDRV_PCM_FORMAT_IMA_ADPCM\t((__force snd_pcm_format_t) 22)\n#define\tSNDRV_PCM_FORMAT_MPEG\t\t((__force snd_pcm_format_t) 23)\n#define\tSNDRV_PCM_FORMAT_GSM\t\t((__force snd_pcm_format_t) 24)\n#define\tSNDRV_PCM_FORMAT_S20_LE\t((__force snd_pcm_format_t) 25)  \n#define\tSNDRV_PCM_FORMAT_S20_BE\t((__force snd_pcm_format_t) 26)  \n#define\tSNDRV_PCM_FORMAT_U20_LE\t((__force snd_pcm_format_t) 27)  \n#define\tSNDRV_PCM_FORMAT_U20_BE\t((__force snd_pcm_format_t) 28)  \n \n#define\tSNDRV_PCM_FORMAT_SPECIAL\t((__force snd_pcm_format_t) 31)\n#define\tSNDRV_PCM_FORMAT_S24_3LE\t((__force snd_pcm_format_t) 32)\t \n#define\tSNDRV_PCM_FORMAT_S24_3BE\t((__force snd_pcm_format_t) 33)\t \n#define\tSNDRV_PCM_FORMAT_U24_3LE\t((__force snd_pcm_format_t) 34)\t \n#define\tSNDRV_PCM_FORMAT_U24_3BE\t((__force snd_pcm_format_t) 35)\t \n#define\tSNDRV_PCM_FORMAT_S20_3LE\t((__force snd_pcm_format_t) 36)\t \n#define\tSNDRV_PCM_FORMAT_S20_3BE\t((__force snd_pcm_format_t) 37)\t \n#define\tSNDRV_PCM_FORMAT_U20_3LE\t((__force snd_pcm_format_t) 38)\t \n#define\tSNDRV_PCM_FORMAT_U20_3BE\t((__force snd_pcm_format_t) 39)\t \n#define\tSNDRV_PCM_FORMAT_S18_3LE\t((__force snd_pcm_format_t) 40)\t \n#define\tSNDRV_PCM_FORMAT_S18_3BE\t((__force snd_pcm_format_t) 41)\t \n#define\tSNDRV_PCM_FORMAT_U18_3LE\t((__force snd_pcm_format_t) 42)\t \n#define\tSNDRV_PCM_FORMAT_U18_3BE\t((__force snd_pcm_format_t) 43)\t \n#define\tSNDRV_PCM_FORMAT_G723_24\t((__force snd_pcm_format_t) 44)  \n#define\tSNDRV_PCM_FORMAT_G723_24_1B\t((__force snd_pcm_format_t) 45)  \n#define\tSNDRV_PCM_FORMAT_G723_40\t((__force snd_pcm_format_t) 46)  \n#define\tSNDRV_PCM_FORMAT_G723_40_1B\t((__force snd_pcm_format_t) 47)  \n#define\tSNDRV_PCM_FORMAT_DSD_U8\t\t((__force snd_pcm_format_t) 48)  \n#define\tSNDRV_PCM_FORMAT_DSD_U16_LE\t((__force snd_pcm_format_t) 49)  \n#define\tSNDRV_PCM_FORMAT_DSD_U32_LE\t((__force snd_pcm_format_t) 50)  \n#define\tSNDRV_PCM_FORMAT_DSD_U16_BE\t((__force snd_pcm_format_t) 51)  \n#define\tSNDRV_PCM_FORMAT_DSD_U32_BE\t((__force snd_pcm_format_t) 52)  \n#define\tSNDRV_PCM_FORMAT_LAST\t\tSNDRV_PCM_FORMAT_DSD_U32_BE\n#define\tSNDRV_PCM_FORMAT_FIRST\t\tSNDRV_PCM_FORMAT_S8\n\n#ifdef SNDRV_LITTLE_ENDIAN\n#define\tSNDRV_PCM_FORMAT_S16\t\tSNDRV_PCM_FORMAT_S16_LE\n#define\tSNDRV_PCM_FORMAT_U16\t\tSNDRV_PCM_FORMAT_U16_LE\n#define\tSNDRV_PCM_FORMAT_S24\t\tSNDRV_PCM_FORMAT_S24_LE\n#define\tSNDRV_PCM_FORMAT_U24\t\tSNDRV_PCM_FORMAT_U24_LE\n#define\tSNDRV_PCM_FORMAT_S32\t\tSNDRV_PCM_FORMAT_S32_LE\n#define\tSNDRV_PCM_FORMAT_U32\t\tSNDRV_PCM_FORMAT_U32_LE\n#define\tSNDRV_PCM_FORMAT_FLOAT\t\tSNDRV_PCM_FORMAT_FLOAT_LE\n#define\tSNDRV_PCM_FORMAT_FLOAT64\tSNDRV_PCM_FORMAT_FLOAT64_LE\n#define\tSNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE\n#define\tSNDRV_PCM_FORMAT_S20\t\tSNDRV_PCM_FORMAT_S20_LE\n#define\tSNDRV_PCM_FORMAT_U20\t\tSNDRV_PCM_FORMAT_U20_LE\n#endif\n#ifdef SNDRV_BIG_ENDIAN\n#define\tSNDRV_PCM_FORMAT_S16\t\tSNDRV_PCM_FORMAT_S16_BE\n#define\tSNDRV_PCM_FORMAT_U16\t\tSNDRV_PCM_FORMAT_U16_BE\n#define\tSNDRV_PCM_FORMAT_S24\t\tSNDRV_PCM_FORMAT_S24_BE\n#define\tSNDRV_PCM_FORMAT_U24\t\tSNDRV_PCM_FORMAT_U24_BE\n#define\tSNDRV_PCM_FORMAT_S32\t\tSNDRV_PCM_FORMAT_S32_BE\n#define\tSNDRV_PCM_FORMAT_U32\t\tSNDRV_PCM_FORMAT_U32_BE\n#define\tSNDRV_PCM_FORMAT_FLOAT\t\tSNDRV_PCM_FORMAT_FLOAT_BE\n#define\tSNDRV_PCM_FORMAT_FLOAT64\tSNDRV_PCM_FORMAT_FLOAT64_BE\n#define\tSNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE\n#define\tSNDRV_PCM_FORMAT_S20\t\tSNDRV_PCM_FORMAT_S20_BE\n#define\tSNDRV_PCM_FORMAT_U20\t\tSNDRV_PCM_FORMAT_U20_BE\n#endif\n\ntypedef int __bitwise snd_pcm_subformat_t;\n#define\tSNDRV_PCM_SUBFORMAT_STD\t\t((__force snd_pcm_subformat_t) 0)\n#define\tSNDRV_PCM_SUBFORMAT_LAST\tSNDRV_PCM_SUBFORMAT_STD\n\n#define SNDRV_PCM_INFO_MMAP\t\t0x00000001\t \n#define SNDRV_PCM_INFO_MMAP_VALID\t0x00000002\t \n#define SNDRV_PCM_INFO_DOUBLE\t\t0x00000004\t \n#define SNDRV_PCM_INFO_BATCH\t\t0x00000010\t \n#define SNDRV_PCM_INFO_SYNC_APPLPTR\t0x00000020\t \n#define SNDRV_PCM_INFO_PERFECT_DRAIN\t0x00000040\t \n#define SNDRV_PCM_INFO_INTERLEAVED\t0x00000100\t \n#define SNDRV_PCM_INFO_NONINTERLEAVED\t0x00000200\t \n#define SNDRV_PCM_INFO_COMPLEX\t\t0x00000400\t \n#define SNDRV_PCM_INFO_BLOCK_TRANSFER\t0x00010000\t \n#define SNDRV_PCM_INFO_OVERRANGE\t0x00020000\t \n#define SNDRV_PCM_INFO_RESUME\t\t0x00040000\t \n#define SNDRV_PCM_INFO_PAUSE\t\t0x00080000\t \n#define SNDRV_PCM_INFO_HALF_DUPLEX\t0x00100000\t \n#define SNDRV_PCM_INFO_JOINT_DUPLEX\t0x00200000\t \n#define SNDRV_PCM_INFO_SYNC_START\t0x00400000\t \n#define SNDRV_PCM_INFO_NO_PERIOD_WAKEUP\t0x00800000\t \n#define SNDRV_PCM_INFO_HAS_WALL_CLOCK   0x01000000       \n#define SNDRV_PCM_INFO_HAS_LINK_ATIME              0x01000000   \n#define SNDRV_PCM_INFO_HAS_LINK_ABSOLUTE_ATIME     0x02000000   \n#define SNDRV_PCM_INFO_HAS_LINK_ESTIMATED_ATIME    0x04000000   \n#define SNDRV_PCM_INFO_HAS_LINK_SYNCHRONIZED_ATIME 0x08000000   \n#define SNDRV_PCM_INFO_EXPLICIT_SYNC\t0x10000000\t \n#define SNDRV_PCM_INFO_NO_REWINDS\t0x20000000\t \n#define SNDRV_PCM_INFO_DRAIN_TRIGGER\t0x40000000\t\t \n#define SNDRV_PCM_INFO_FIFO_IN_FRAMES\t0x80000000\t \n\n#if (__BITS_PER_LONG == 32 && defined(__USE_TIME_BITS64)) || defined __KERNEL__\n#define __SND_STRUCT_TIME64\n#endif\n\ntypedef int __bitwise snd_pcm_state_t;\n#define\tSNDRV_PCM_STATE_OPEN\t\t((__force snd_pcm_state_t) 0)  \n#define\tSNDRV_PCM_STATE_SETUP\t\t((__force snd_pcm_state_t) 1)  \n#define\tSNDRV_PCM_STATE_PREPARED\t((__force snd_pcm_state_t) 2)  \n#define\tSNDRV_PCM_STATE_RUNNING\t\t((__force snd_pcm_state_t) 3)  \n#define\tSNDRV_PCM_STATE_XRUN\t\t((__force snd_pcm_state_t) 4)  \n#define\tSNDRV_PCM_STATE_DRAINING\t((__force snd_pcm_state_t) 5)  \n#define\tSNDRV_PCM_STATE_PAUSED\t\t((__force snd_pcm_state_t) 6)  \n#define\tSNDRV_PCM_STATE_SUSPENDED\t((__force snd_pcm_state_t) 7)  \n#define\tSNDRV_PCM_STATE_DISCONNECTED\t((__force snd_pcm_state_t) 8)  \n#define\tSNDRV_PCM_STATE_LAST\t\tSNDRV_PCM_STATE_DISCONNECTED\n\nenum {\n\tSNDRV_PCM_MMAP_OFFSET_DATA = 0x00000000,\n\tSNDRV_PCM_MMAP_OFFSET_STATUS_OLD = 0x80000000,\n\tSNDRV_PCM_MMAP_OFFSET_CONTROL_OLD = 0x81000000,\n\tSNDRV_PCM_MMAP_OFFSET_STATUS_NEW = 0x82000000,\n\tSNDRV_PCM_MMAP_OFFSET_CONTROL_NEW = 0x83000000,\n#ifdef __SND_STRUCT_TIME64\n\tSNDRV_PCM_MMAP_OFFSET_STATUS = SNDRV_PCM_MMAP_OFFSET_STATUS_NEW,\n\tSNDRV_PCM_MMAP_OFFSET_CONTROL = SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW,\n#else\n\tSNDRV_PCM_MMAP_OFFSET_STATUS = SNDRV_PCM_MMAP_OFFSET_STATUS_OLD,\n\tSNDRV_PCM_MMAP_OFFSET_CONTROL = SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD,\n#endif\n};\n\nunion snd_pcm_sync_id {\n\tunsigned char id[16];\n\tunsigned short id16[8];\n\tunsigned int id32[4];\n};\n\nstruct snd_pcm_info {\n\tunsigned int device;\t\t \n\tunsigned int subdevice;\t\t \n\tint stream;\t\t\t \n\tint card;\t\t\t \n\tunsigned char id[64];\t\t \n\tunsigned char name[80];\t\t \n\tunsigned char subname[32];\t \n\tint dev_class;\t\t\t \n\tint dev_subclass;\t\t \n\tunsigned int subdevices_count;\n\tunsigned int subdevices_avail;\n\tunion snd_pcm_sync_id sync;\t \n\tunsigned char reserved[64];\t \n};\n\ntypedef int snd_pcm_hw_param_t;\n#define\tSNDRV_PCM_HW_PARAM_ACCESS\t0\t \n#define\tSNDRV_PCM_HW_PARAM_FORMAT\t1\t \n#define\tSNDRV_PCM_HW_PARAM_SUBFORMAT\t2\t \n#define\tSNDRV_PCM_HW_PARAM_FIRST_MASK\tSNDRV_PCM_HW_PARAM_ACCESS\n#define\tSNDRV_PCM_HW_PARAM_LAST_MASK\tSNDRV_PCM_HW_PARAM_SUBFORMAT\n\n#define\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS\t8\t \n#define\tSNDRV_PCM_HW_PARAM_FRAME_BITS\t9\t \n#define\tSNDRV_PCM_HW_PARAM_CHANNELS\t10\t \n#define\tSNDRV_PCM_HW_PARAM_RATE\t\t11\t \n#define\tSNDRV_PCM_HW_PARAM_PERIOD_TIME\t12\t \n#define\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE\t13\t \n#define\tSNDRV_PCM_HW_PARAM_PERIOD_BYTES\t14\t \n#define\tSNDRV_PCM_HW_PARAM_PERIODS\t15\t \n#define\tSNDRV_PCM_HW_PARAM_BUFFER_TIME\t16\t \n#define\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE\t17\t \n#define\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES\t18\t \n#define\tSNDRV_PCM_HW_PARAM_TICK_TIME\t19\t \n#define\tSNDRV_PCM_HW_PARAM_FIRST_INTERVAL\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS\n#define\tSNDRV_PCM_HW_PARAM_LAST_INTERVAL\tSNDRV_PCM_HW_PARAM_TICK_TIME\n\n#define SNDRV_PCM_HW_PARAMS_NORESAMPLE\t(1<<0)\t \n#define SNDRV_PCM_HW_PARAMS_EXPORT_BUFFER\t(1<<1)\t \n#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP\t(1<<2)\t \n#define SNDRV_PCM_HW_PARAMS_NO_DRAIN_SILENCE\t(1<<3)\t \n\nstruct snd_interval {\n\tunsigned int min, max;\n\tunsigned int openmin:1,\n\t\t     openmax:1,\n\t\t     integer:1,\n\t\t     empty:1;\n};\n\n#define SNDRV_MASK_MAX\t256\n\nstruct snd_mask {\n\t__u32 bits[(SNDRV_MASK_MAX+31)/32];\n};\n\nstruct snd_pcm_hw_params {\n\tunsigned int flags;\n\tstruct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK -\n\t\t\t       SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];\n\tstruct snd_mask mres[5];\t \n\tstruct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -\n\t\t\t\t        SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];\n\tstruct snd_interval ires[9];\t \n\tunsigned int rmask;\t\t \n\tunsigned int cmask;\t\t \n\tunsigned int info;\t\t \n\tunsigned int msbits;\t\t \n\tunsigned int rate_num;\t\t \n\tunsigned int rate_den;\t\t \n\tsnd_pcm_uframes_t fifo_size;\t \n\tunsigned char reserved[64];\t \n};\n\nenum {\n\tSNDRV_PCM_TSTAMP_NONE = 0,\n\tSNDRV_PCM_TSTAMP_ENABLE,\n\tSNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE,\n};\n\nstruct snd_pcm_sw_params {\n\tint tstamp_mode;\t\t\t \n\tunsigned int period_step;\n\tunsigned int sleep_min;\t\t\t \n\tsnd_pcm_uframes_t avail_min;\t\t \n\tsnd_pcm_uframes_t xfer_align;\t\t \n\tsnd_pcm_uframes_t start_threshold;\t \n\t \n\tsnd_pcm_uframes_t stop_threshold;\t \n\tsnd_pcm_uframes_t silence_threshold;\t \n\tsnd_pcm_uframes_t silence_size;\t\t \n\tsnd_pcm_uframes_t boundary;\t\t \n\tunsigned int proto;\t\t\t \n\tunsigned int tstamp_type;\t\t \n\tunsigned char reserved[56];\t\t \n};\n\nstruct snd_pcm_channel_info {\n\tunsigned int channel;\n\t__kernel_off_t offset;\t\t \n\tunsigned int first;\t\t \n\tunsigned int step;\t\t \n};\n\nenum {\n\t \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,\n\n\t \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,            \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,\t            \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,\t    \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,     \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,  \n\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LAST = SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED\n};\n\n#ifndef __KERNEL__\n \ntypedef struct { unsigned char pad[sizeof(time_t) - sizeof(int)]; } __time_pad;\n\nstruct snd_pcm_status {\n\tsnd_pcm_state_t state;\t\t \n\t__time_pad pad1;\t\t \n\tstruct timespec trigger_tstamp;\t \n\tstruct timespec tstamp;\t\t \n\tsnd_pcm_uframes_t appl_ptr;\t \n\tsnd_pcm_uframes_t hw_ptr;\t \n\tsnd_pcm_sframes_t delay;\t \n\tsnd_pcm_uframes_t avail;\t \n\tsnd_pcm_uframes_t avail_max;\t \n\tsnd_pcm_uframes_t overrange;\t \n\tsnd_pcm_state_t suspended_state;  \n\t__u32 audio_tstamp_data;\t  \n\tstruct timespec audio_tstamp;\t \n\tstruct timespec driver_tstamp;\t \n\t__u32 audio_tstamp_accuracy;\t \n\tunsigned char reserved[52-2*sizeof(struct timespec)];  \n};\n#endif\n\n \n#ifdef __SND_STRUCT_TIME64\n#define __snd_pcm_mmap_status64\t\tsnd_pcm_mmap_status\n#define __snd_pcm_mmap_control64\tsnd_pcm_mmap_control\n#define __snd_pcm_sync_ptr64\t\tsnd_pcm_sync_ptr\n#ifdef __KERNEL__\n#define __snd_timespec64\t\t__kernel_timespec\n#else\n#define __snd_timespec64\t\ttimespec\n#endif\nstruct __snd_timespec {\n\t__s32 tv_sec;\n\t__s32 tv_nsec;\n};\n#else\n#define __snd_pcm_mmap_status\t\tsnd_pcm_mmap_status\n#define __snd_pcm_mmap_control\t\tsnd_pcm_mmap_control\n#define __snd_pcm_sync_ptr\t\tsnd_pcm_sync_ptr\n#define __snd_timespec\t\t\ttimespec\nstruct __snd_timespec64 {\n\t__s64 tv_sec;\n\t__s64 tv_nsec;\n};\n\n#endif\n\nstruct __snd_pcm_mmap_status {\n\tsnd_pcm_state_t state;\t\t \n\tint pad1;\t\t\t \n\tsnd_pcm_uframes_t hw_ptr;\t \n\tstruct __snd_timespec tstamp;\t \n\tsnd_pcm_state_t suspended_state;  \n\tstruct __snd_timespec audio_tstamp;  \n};\n\nstruct __snd_pcm_mmap_control {\n\tsnd_pcm_uframes_t appl_ptr;\t \n\tsnd_pcm_uframes_t avail_min;\t \n};\n\n#define SNDRV_PCM_SYNC_PTR_HWSYNC\t(1<<0)\t \n#define SNDRV_PCM_SYNC_PTR_APPL\t\t(1<<1)\t \n#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN\t(1<<2)\t \n\nstruct __snd_pcm_sync_ptr {\n\tunsigned int flags;\n\tunion {\n\t\tstruct __snd_pcm_mmap_status status;\n\t\tunsigned char reserved[64];\n\t} s;\n\tunion {\n\t\tstruct __snd_pcm_mmap_control control;\n\t\tunsigned char reserved[64];\n\t} c;\n};\n\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : defined(__BIG_ENDIAN)\ntypedef char __pad_before_uframe[sizeof(__u64) - sizeof(snd_pcm_uframes_t)];\ntypedef char __pad_after_uframe[0];\n#endif\n\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : defined(__LITTLE_ENDIAN)\ntypedef char __pad_before_uframe[0];\ntypedef char __pad_after_uframe[sizeof(__u64) - sizeof(snd_pcm_uframes_t)];\n#endif\n\nstruct __snd_pcm_mmap_status64 {\n\tsnd_pcm_state_t state;\t\t \n\t__u32 pad1;\t\t\t \n\t__pad_before_uframe __pad1;\n\tsnd_pcm_uframes_t hw_ptr;\t \n\t__pad_after_uframe __pad2;\n\tstruct __snd_timespec64 tstamp;\t \n\tsnd_pcm_state_t suspended_state; \n\t__u32 pad3;\t\t\t \n\tstruct __snd_timespec64 audio_tstamp;  \n};\n\nstruct __snd_pcm_mmap_control64 {\n\t__pad_before_uframe __pad1;\n\tsnd_pcm_uframes_t appl_ptr;\t  \n\t__pad_before_uframe __pad2;\t  \n\t\t\t\t\t  \n\n\t__pad_before_uframe __pad3;\n\tsnd_pcm_uframes_t  avail_min;\t  \n\t__pad_after_uframe __pad4;\n};\n\nstruct __snd_pcm_sync_ptr64 {\n\t__u32 flags;\n\t__u32 pad1;\n\tunion {\n\t\tstruct __snd_pcm_mmap_status64 status;\n\t\tunsigned char reserved[64];\n\t} s;\n\tunion {\n\t\tstruct __snd_pcm_mmap_control64 control;\n\t\tunsigned char reserved[64];\n\t} c;\n};\n\nstruct snd_xferi {\n\tsnd_pcm_sframes_t result;\n\tvoid __user *buf;\n\tsnd_pcm_uframes_t frames;\n};\n\nstruct snd_xfern {\n\tsnd_pcm_sframes_t result;\n\tvoid __user * __user *bufs;\n\tsnd_pcm_uframes_t frames;\n};\n\nenum {\n\tSNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,\t \n\tSNDRV_PCM_TSTAMP_TYPE_MONOTONIC,\t \n\tSNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,     \n\tSNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,\n};\n\n \nenum {\n\tSNDRV_CHMAP_UNKNOWN = 0,\n\tSNDRV_CHMAP_NA,\t\t \n\tSNDRV_CHMAP_MONO,\t \n\t \n\tSNDRV_CHMAP_FL,\t\t \n\tSNDRV_CHMAP_FR,\t\t \n\tSNDRV_CHMAP_RL,\t\t \n\tSNDRV_CHMAP_RR,\t\t \n\tSNDRV_CHMAP_FC,\t\t \n\tSNDRV_CHMAP_LFE,\t \n\tSNDRV_CHMAP_SL,\t\t \n\tSNDRV_CHMAP_SR,\t\t \n\tSNDRV_CHMAP_RC,\t\t \n\t \n\tSNDRV_CHMAP_FLC,\t \n\tSNDRV_CHMAP_FRC,\t \n\tSNDRV_CHMAP_RLC,\t \n\tSNDRV_CHMAP_RRC,\t \n\tSNDRV_CHMAP_FLW,\t \n\tSNDRV_CHMAP_FRW,\t \n\tSNDRV_CHMAP_FLH,\t \n\tSNDRV_CHMAP_FCH,\t \n\tSNDRV_CHMAP_FRH,\t \n\tSNDRV_CHMAP_TC,\t\t \n\tSNDRV_CHMAP_TFL,\t \n\tSNDRV_CHMAP_TFR,\t \n\tSNDRV_CHMAP_TFC,\t \n\tSNDRV_CHMAP_TRL,\t \n\tSNDRV_CHMAP_TRR,\t \n\tSNDRV_CHMAP_TRC,\t \n\t \n\tSNDRV_CHMAP_TFLC,\t \n\tSNDRV_CHMAP_TFRC,\t \n\tSNDRV_CHMAP_TSL,\t \n\tSNDRV_CHMAP_TSR,\t \n\tSNDRV_CHMAP_LLFE,\t \n\tSNDRV_CHMAP_RLFE,\t \n\tSNDRV_CHMAP_BC,\t\t \n\tSNDRV_CHMAP_BLC,\t \n\tSNDRV_CHMAP_BRC,\t \n\tSNDRV_CHMAP_LAST = SNDRV_CHMAP_BRC,\n};\n\n#define SNDRV_CHMAP_POSITION_MASK\t0xffff\n#define SNDRV_CHMAP_PHASE_INVERSE\t(0x01 << 16)\n#define SNDRV_CHMAP_DRIVER_SPEC\t\t(0x02 << 16)\n\n#define SNDRV_PCM_IOCTL_PVERSION\t_IOR('A', 0x00, int)\n#define SNDRV_PCM_IOCTL_INFO\t\t_IOR('A', 0x01, struct snd_pcm_info)\n#define SNDRV_PCM_IOCTL_TSTAMP\t\t_IOW('A', 0x02, int)\n#define SNDRV_PCM_IOCTL_TTSTAMP\t\t_IOW('A', 0x03, int)\n#define SNDRV_PCM_IOCTL_USER_PVERSION\t_IOW('A', 0x04, int)\n#define SNDRV_PCM_IOCTL_HW_REFINE\t_IOWR('A', 0x10, struct snd_pcm_hw_params)\n#define SNDRV_PCM_IOCTL_HW_PARAMS\t_IOWR('A', 0x11, struct snd_pcm_hw_params)\n#define SNDRV_PCM_IOCTL_HW_FREE\t\t_IO('A', 0x12)\n#define SNDRV_PCM_IOCTL_SW_PARAMS\t_IOWR('A', 0x13, struct snd_pcm_sw_params)\n#define SNDRV_PCM_IOCTL_STATUS\t\t_IOR('A', 0x20, struct snd_pcm_status)\n#define SNDRV_PCM_IOCTL_DELAY\t\t_IOR('A', 0x21, snd_pcm_sframes_t)\n#define SNDRV_PCM_IOCTL_HWSYNC\t\t_IO('A', 0x22)\n#define __SNDRV_PCM_IOCTL_SYNC_PTR\t_IOWR('A', 0x23, struct __snd_pcm_sync_ptr)\n#define __SNDRV_PCM_IOCTL_SYNC_PTR64\t_IOWR('A', 0x23, struct __snd_pcm_sync_ptr64)\n#define SNDRV_PCM_IOCTL_SYNC_PTR\t_IOWR('A', 0x23, struct snd_pcm_sync_ptr)\n#define SNDRV_PCM_IOCTL_STATUS_EXT\t_IOWR('A', 0x24, struct snd_pcm_status)\n#define SNDRV_PCM_IOCTL_CHANNEL_INFO\t_IOR('A', 0x32, struct snd_pcm_channel_info)\n#define SNDRV_PCM_IOCTL_PREPARE\t\t_IO('A', 0x40)\n#define SNDRV_PCM_IOCTL_RESET\t\t_IO('A', 0x41)\n#define SNDRV_PCM_IOCTL_START\t\t_IO('A', 0x42)\n#define SNDRV_PCM_IOCTL_DROP\t\t_IO('A', 0x43)\n#define SNDRV_PCM_IOCTL_DRAIN\t\t_IO('A', 0x44)\n#define SNDRV_PCM_IOCTL_PAUSE\t\t_IOW('A', 0x45, int)\n#define SNDRV_PCM_IOCTL_REWIND\t\t_IOW('A', 0x46, snd_pcm_uframes_t)\n#define SNDRV_PCM_IOCTL_RESUME\t\t_IO('A', 0x47)\n#define SNDRV_PCM_IOCTL_XRUN\t\t_IO('A', 0x48)\n#define SNDRV_PCM_IOCTL_FORWARD\t\t_IOW('A', 0x49, snd_pcm_uframes_t)\n#define SNDRV_PCM_IOCTL_WRITEI_FRAMES\t_IOW('A', 0x50, struct snd_xferi)\n#define SNDRV_PCM_IOCTL_READI_FRAMES\t_IOR('A', 0x51, struct snd_xferi)\n#define SNDRV_PCM_IOCTL_WRITEN_FRAMES\t_IOW('A', 0x52, struct snd_xfern)\n#define SNDRV_PCM_IOCTL_READN_FRAMES\t_IOR('A', 0x53, struct snd_xfern)\n#define SNDRV_PCM_IOCTL_LINK\t\t_IOW('A', 0x60, int)\n#define SNDRV_PCM_IOCTL_UNLINK\t\t_IO('A', 0x61)\n\n \n\n \n\n#define SNDRV_RAWMIDI_VERSION\t\tSNDRV_PROTOCOL_VERSION(2, 0, 4)\n\nenum {\n\tSNDRV_RAWMIDI_STREAM_OUTPUT = 0,\n\tSNDRV_RAWMIDI_STREAM_INPUT,\n\tSNDRV_RAWMIDI_STREAM_LAST = SNDRV_RAWMIDI_STREAM_INPUT,\n};\n\n#define SNDRV_RAWMIDI_INFO_OUTPUT\t\t0x00000001\n#define SNDRV_RAWMIDI_INFO_INPUT\t\t0x00000002\n#define SNDRV_RAWMIDI_INFO_DUPLEX\t\t0x00000004\n#define SNDRV_RAWMIDI_INFO_UMP\t\t\t0x00000008\n\nstruct snd_rawmidi_info {\n\tunsigned int device;\t\t \n\tunsigned int subdevice;\t\t \n\tint stream;\t\t\t \n\tint card;\t\t\t \n\tunsigned int flags;\t\t \n\tunsigned char id[64];\t\t \n\tunsigned char name[80];\t\t \n\tunsigned char subname[32];\t \n\tunsigned int subdevices_count;\n\tunsigned int subdevices_avail;\n\tunsigned char reserved[64];\t \n};\n\n#define SNDRV_RAWMIDI_MODE_FRAMING_MASK\t\t(7<<0)\n#define SNDRV_RAWMIDI_MODE_FRAMING_SHIFT\t0\n#define SNDRV_RAWMIDI_MODE_FRAMING_NONE\t\t(0<<0)\n#define SNDRV_RAWMIDI_MODE_FRAMING_TSTAMP\t(1<<0)\n#define SNDRV_RAWMIDI_MODE_CLOCK_MASK\t\t(7<<3)\n#define SNDRV_RAWMIDI_MODE_CLOCK_SHIFT\t\t3\n#define SNDRV_RAWMIDI_MODE_CLOCK_NONE\t\t(0<<3)\n#define SNDRV_RAWMIDI_MODE_CLOCK_REALTIME\t(1<<3)\n#define SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC\t(2<<3)\n#define SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC_RAW\t(3<<3)\n\n#define SNDRV_RAWMIDI_FRAMING_DATA_LENGTH 16\n\nstruct snd_rawmidi_framing_tstamp {\n\t \n\t__u8 frame_type;\n\t__u8 length;  \n\t__u8 reserved[2];\n\t__u32 tv_nsec;\t\t \n\t__u64 tv_sec;\t\t \n\t__u8 data[SNDRV_RAWMIDI_FRAMING_DATA_LENGTH];\n} __packed;\n\nstruct snd_rawmidi_params {\n\tint stream;\n\tsize_t buffer_size;\t\t \n\tsize_t avail_min;\t\t \n\tunsigned int no_active_sensing: 1;  \n\tunsigned int mode;\t\t \n\tunsigned char reserved[12];\t \n};\n\n#ifndef __KERNEL__\nstruct snd_rawmidi_status {\n\tint stream;\n\t__time_pad pad1;\n\tstruct timespec tstamp;\t\t \n\tsize_t avail;\t\t\t \n\tsize_t xruns;\t\t\t \n\tunsigned char reserved[16];\t \n};\n#endif\n\n \n#define SNDRV_UMP_EP_INFO_STATIC_BLOCKS\t\t0x01\n\n \n#define SNDRV_UMP_EP_INFO_PROTO_MIDI_MASK\t0x0300\n#define SNDRV_UMP_EP_INFO_PROTO_MIDI1\t\t0x0100  \n#define SNDRV_UMP_EP_INFO_PROTO_MIDI2\t\t0x0200  \n#define SNDRV_UMP_EP_INFO_PROTO_JRTS_MASK\t0x0003\n#define SNDRV_UMP_EP_INFO_PROTO_JRTS_TX\t\t0x0001  \n#define SNDRV_UMP_EP_INFO_PROTO_JRTS_RX\t\t0x0002  \n\n \nstruct snd_ump_endpoint_info {\n\tint card;\t\t\t \n\tint device;\t\t\t \n\tunsigned int flags;\t\t \n\tunsigned int protocol_caps;\t \n\tunsigned int protocol;\t\t \n\tunsigned int num_blocks;\t \n\tunsigned short version;\t\t \n\tunsigned short family_id;\t \n\tunsigned short model_id;\t \n\tunsigned int manufacturer_id;\t \n\tunsigned char sw_revision[4];\t \n\tunsigned short padding;\n\tunsigned char name[128];\t \n\tunsigned char product_id[128];\t \n\tunsigned char reserved[32];\n} __packed;\n\n \n#define SNDRV_UMP_DIR_INPUT\t\t0x01\n#define SNDRV_UMP_DIR_OUTPUT\t\t0x02\n#define SNDRV_UMP_DIR_BIDIRECTION\t0x03\n\n \n#define SNDRV_UMP_BLOCK_IS_MIDI1\t(1U << 0)  \n#define SNDRV_UMP_BLOCK_IS_LOWSPEED\t(1U << 1)  \n\n \n#define SNDRV_UMP_BLOCK_UI_HINT_UNKNOWN\t\t0x00\n#define SNDRV_UMP_BLOCK_UI_HINT_RECEIVER\t0x01\n#define SNDRV_UMP_BLOCK_UI_HINT_SENDER\t\t0x02\n#define SNDRV_UMP_BLOCK_UI_HINT_BOTH\t\t0x03\n\n \n#define SNDRV_UMP_MAX_GROUPS\t\t16\n#define SNDRV_UMP_MAX_BLOCKS\t\t32\n\n \nstruct snd_ump_block_info {\n\tint card;\t\t\t \n\tint device;\t\t\t \n\tunsigned char block_id;\t\t \n\tunsigned char direction;\t \n\tunsigned char active;\t\t \n\tunsigned char first_group;\t \n\tunsigned char num_groups;\t \n\tunsigned char midi_ci_version;\t \n\tunsigned char sysex8_streams;\t \n\tunsigned char ui_hint;\t\t \n\tunsigned int flags;\t\t \n\tunsigned char name[128];\t \n\tunsigned char reserved[32];\n} __packed;\n\n#define SNDRV_RAWMIDI_IOCTL_PVERSION\t_IOR('W', 0x00, int)\n#define SNDRV_RAWMIDI_IOCTL_INFO\t_IOR('W', 0x01, struct snd_rawmidi_info)\n#define SNDRV_RAWMIDI_IOCTL_USER_PVERSION _IOW('W', 0x02, int)\n#define SNDRV_RAWMIDI_IOCTL_PARAMS\t_IOWR('W', 0x10, struct snd_rawmidi_params)\n#define SNDRV_RAWMIDI_IOCTL_STATUS\t_IOWR('W', 0x20, struct snd_rawmidi_status)\n#define SNDRV_RAWMIDI_IOCTL_DROP\t_IOW('W', 0x30, int)\n#define SNDRV_RAWMIDI_IOCTL_DRAIN\t_IOW('W', 0x31, int)\n \n#define SNDRV_UMP_IOCTL_ENDPOINT_INFO\t_IOR('W', 0x40, struct snd_ump_endpoint_info)\n#define SNDRV_UMP_IOCTL_BLOCK_INFO\t_IOR('W', 0x41, struct snd_ump_block_info)\n\n \n\n#define SNDRV_TIMER_VERSION\t\tSNDRV_PROTOCOL_VERSION(2, 0, 7)\n\nenum {\n\tSNDRV_TIMER_CLASS_NONE = -1,\n\tSNDRV_TIMER_CLASS_SLAVE = 0,\n\tSNDRV_TIMER_CLASS_GLOBAL,\n\tSNDRV_TIMER_CLASS_CARD,\n\tSNDRV_TIMER_CLASS_PCM,\n\tSNDRV_TIMER_CLASS_LAST = SNDRV_TIMER_CLASS_PCM,\n};\n\n \nenum {\n\tSNDRV_TIMER_SCLASS_NONE = 0,\n\tSNDRV_TIMER_SCLASS_APPLICATION,\n\tSNDRV_TIMER_SCLASS_SEQUENCER,\t\t \n\tSNDRV_TIMER_SCLASS_OSS_SEQUENCER,\t \n\tSNDRV_TIMER_SCLASS_LAST = SNDRV_TIMER_SCLASS_OSS_SEQUENCER,\n};\n\n \n#define SNDRV_TIMER_GLOBAL_SYSTEM\t0\n#define SNDRV_TIMER_GLOBAL_RTC\t\t1\t \n#define SNDRV_TIMER_GLOBAL_HPET\t\t2\n#define SNDRV_TIMER_GLOBAL_HRTIMER\t3\n\n \n#define SNDRV_TIMER_FLG_SLAVE\t\t(1<<0)\t \n\nstruct snd_timer_id {\n\tint dev_class;\n\tint dev_sclass;\n\tint card;\n\tint device;\n\tint subdevice;\n};\n\nstruct snd_timer_ginfo {\n\tstruct snd_timer_id tid;\t \n\tunsigned int flags;\t\t \n\tint card;\t\t\t \n\tunsigned char id[64];\t\t \n\tunsigned char name[80];\t\t \n\tunsigned long reserved0;\t \n\tunsigned long resolution;\t \n\tunsigned long resolution_min;\t \n\tunsigned long resolution_max;\t \n\tunsigned int clients;\t\t \n\tunsigned char reserved[32];\n};\n\nstruct snd_timer_gparams {\n\tstruct snd_timer_id tid;\t \n\tunsigned long period_num;\t \n\tunsigned long period_den;\t \n\tunsigned char reserved[32];\n};\n\nstruct snd_timer_gstatus {\n\tstruct snd_timer_id tid;\t \n\tunsigned long resolution;\t \n\tunsigned long resolution_num;\t \n\tunsigned long resolution_den;\t \n\tunsigned char reserved[32];\n};\n\nstruct snd_timer_select {\n\tstruct snd_timer_id id;\t \n\tunsigned char reserved[32];\t \n};\n\nstruct snd_timer_info {\n\tunsigned int flags;\t\t \n\tint card;\t\t\t \n\tunsigned char id[64];\t\t \n\tunsigned char name[80];\t\t \n\tunsigned long reserved0;\t \n\tunsigned long resolution;\t \n\tunsigned char reserved[64];\t \n};\n\n#define SNDRV_TIMER_PSFLG_AUTO\t\t(1<<0)\t \n#define SNDRV_TIMER_PSFLG_EXCLUSIVE\t(1<<1)\t \n#define SNDRV_TIMER_PSFLG_EARLY_EVENT\t(1<<2)\t \n\nstruct snd_timer_params {\n\tunsigned int flags;\t\t \n\tunsigned int ticks;\t\t \n\tunsigned int queue_size;\t \n\tunsigned int reserved0;\t\t \n\tunsigned int filter;\t\t \n\tunsigned char reserved[60];\t \n};\n\n#ifndef __KERNEL__\nstruct snd_timer_status {\n\tstruct timespec tstamp;\t\t \n\tunsigned int resolution;\t \n\tunsigned int lost;\t\t \n\tunsigned int overrun;\t\t \n\tunsigned int queue;\t\t \n\tunsigned char reserved[64];\t \n};\n#endif\n\n#define SNDRV_TIMER_IOCTL_PVERSION\t_IOR('T', 0x00, int)\n#define SNDRV_TIMER_IOCTL_NEXT_DEVICE\t_IOWR('T', 0x01, struct snd_timer_id)\n#define SNDRV_TIMER_IOCTL_TREAD_OLD\t_IOW('T', 0x02, int)\n#define SNDRV_TIMER_IOCTL_GINFO\t\t_IOWR('T', 0x03, struct snd_timer_ginfo)\n#define SNDRV_TIMER_IOCTL_GPARAMS\t_IOW('T', 0x04, struct snd_timer_gparams)\n#define SNDRV_TIMER_IOCTL_GSTATUS\t_IOWR('T', 0x05, struct snd_timer_gstatus)\n#define SNDRV_TIMER_IOCTL_SELECT\t_IOW('T', 0x10, struct snd_timer_select)\n#define SNDRV_TIMER_IOCTL_INFO\t\t_IOR('T', 0x11, struct snd_timer_info)\n#define SNDRV_TIMER_IOCTL_PARAMS\t_IOW('T', 0x12, struct snd_timer_params)\n#define SNDRV_TIMER_IOCTL_STATUS\t_IOR('T', 0x14, struct snd_timer_status)\n \n#define SNDRV_TIMER_IOCTL_START\t\t_IO('T', 0xa0)\n#define SNDRV_TIMER_IOCTL_STOP\t\t_IO('T', 0xa1)\n#define SNDRV_TIMER_IOCTL_CONTINUE\t_IO('T', 0xa2)\n#define SNDRV_TIMER_IOCTL_PAUSE\t\t_IO('T', 0xa3)\n#define SNDRV_TIMER_IOCTL_TREAD64\t_IOW('T', 0xa4, int)\n\n#if __BITS_PER_LONG == 64\n#define SNDRV_TIMER_IOCTL_TREAD SNDRV_TIMER_IOCTL_TREAD_OLD\n#else\n#define SNDRV_TIMER_IOCTL_TREAD ((sizeof(__kernel_long_t) >= sizeof(time_t)) ? \\\n\t\t\t\t SNDRV_TIMER_IOCTL_TREAD_OLD : \\\n\t\t\t\t SNDRV_TIMER_IOCTL_TREAD64)\n#endif\n\nstruct snd_timer_read {\n\tunsigned int resolution;\n\tunsigned int ticks;\n};\n\nenum {\n\tSNDRV_TIMER_EVENT_RESOLUTION = 0,\t \n\tSNDRV_TIMER_EVENT_TICK,\t\t\t \n\tSNDRV_TIMER_EVENT_START,\t\t \n\tSNDRV_TIMER_EVENT_STOP,\t\t\t \n\tSNDRV_TIMER_EVENT_CONTINUE,\t\t \n\tSNDRV_TIMER_EVENT_PAUSE,\t\t \n\tSNDRV_TIMER_EVENT_EARLY,\t\t \n\tSNDRV_TIMER_EVENT_SUSPEND,\t\t \n\tSNDRV_TIMER_EVENT_RESUME,\t\t \n\t \n\tSNDRV_TIMER_EVENT_MSTART = SNDRV_TIMER_EVENT_START + 10,\n\tSNDRV_TIMER_EVENT_MSTOP = SNDRV_TIMER_EVENT_STOP + 10,\n\tSNDRV_TIMER_EVENT_MCONTINUE = SNDRV_TIMER_EVENT_CONTINUE + 10,\n\tSNDRV_TIMER_EVENT_MPAUSE = SNDRV_TIMER_EVENT_PAUSE + 10,\n\tSNDRV_TIMER_EVENT_MSUSPEND = SNDRV_TIMER_EVENT_SUSPEND + 10,\n\tSNDRV_TIMER_EVENT_MRESUME = SNDRV_TIMER_EVENT_RESUME + 10,\n};\n\n#ifndef __KERNEL__\nstruct snd_timer_tread {\n\tint event;\n\t__time_pad pad1;\n\tstruct timespec tstamp;\n\tunsigned int val;\n\t__time_pad pad2;\n};\n#endif\n\n \n\n#define SNDRV_CTL_VERSION\t\tSNDRV_PROTOCOL_VERSION(2, 0, 9)\n\nstruct snd_ctl_card_info {\n\tint card;\t\t\t \n\tint pad;\t\t\t \n\tunsigned char id[16];\t\t \n\tunsigned char driver[16];\t \n\tunsigned char name[32];\t\t \n\tunsigned char longname[80];\t \n\tunsigned char reserved_[16];\t \n\tunsigned char mixername[80];\t \n\tunsigned char components[128];\t \n};\n\ntypedef int __bitwise snd_ctl_elem_type_t;\n#define\tSNDRV_CTL_ELEM_TYPE_NONE\t((__force snd_ctl_elem_type_t) 0)  \n#define\tSNDRV_CTL_ELEM_TYPE_BOOLEAN\t((__force snd_ctl_elem_type_t) 1)  \n#define\tSNDRV_CTL_ELEM_TYPE_INTEGER\t((__force snd_ctl_elem_type_t) 2)  \n#define\tSNDRV_CTL_ELEM_TYPE_ENUMERATED\t((__force snd_ctl_elem_type_t) 3)  \n#define\tSNDRV_CTL_ELEM_TYPE_BYTES\t((__force snd_ctl_elem_type_t) 4)  \n#define\tSNDRV_CTL_ELEM_TYPE_IEC958\t((__force snd_ctl_elem_type_t) 5)  \n#define\tSNDRV_CTL_ELEM_TYPE_INTEGER64\t((__force snd_ctl_elem_type_t) 6)  \n#define\tSNDRV_CTL_ELEM_TYPE_LAST\tSNDRV_CTL_ELEM_TYPE_INTEGER64\n\ntypedef int __bitwise snd_ctl_elem_iface_t;\n#define\tSNDRV_CTL_ELEM_IFACE_CARD\t((__force snd_ctl_elem_iface_t) 0)  \n#define\tSNDRV_CTL_ELEM_IFACE_HWDEP\t((__force snd_ctl_elem_iface_t) 1)  \n#define\tSNDRV_CTL_ELEM_IFACE_MIXER\t((__force snd_ctl_elem_iface_t) 2)  \n#define\tSNDRV_CTL_ELEM_IFACE_PCM\t((__force snd_ctl_elem_iface_t) 3)  \n#define\tSNDRV_CTL_ELEM_IFACE_RAWMIDI\t((__force snd_ctl_elem_iface_t) 4)  \n#define\tSNDRV_CTL_ELEM_IFACE_TIMER\t((__force snd_ctl_elem_iface_t) 5)  \n#define\tSNDRV_CTL_ELEM_IFACE_SEQUENCER\t((__force snd_ctl_elem_iface_t) 6)  \n#define\tSNDRV_CTL_ELEM_IFACE_LAST\tSNDRV_CTL_ELEM_IFACE_SEQUENCER\n\n#define SNDRV_CTL_ELEM_ACCESS_READ\t\t(1<<0)\n#define SNDRV_CTL_ELEM_ACCESS_WRITE\t\t(1<<1)\n#define SNDRV_CTL_ELEM_ACCESS_READWRITE\t\t(SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)\n#define SNDRV_CTL_ELEM_ACCESS_VOLATILE\t\t(1<<2)\t \n \n#define SNDRV_CTL_ELEM_ACCESS_TLV_READ\t\t(1<<4)\t \n#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE\t\t(1<<5)\t \n#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE\t(SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND\t(1<<6)\t \n#define SNDRV_CTL_ELEM_ACCESS_INACTIVE\t\t(1<<8)\t \n#define SNDRV_CTL_ELEM_ACCESS_LOCK\t\t(1<<9)\t \n#define SNDRV_CTL_ELEM_ACCESS_OWNER\t\t(1<<10)\t \n#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK\t(1<<28)\t \n#define SNDRV_CTL_ELEM_ACCESS_USER\t\t(1<<29)  \n \n\n \n#define SNDRV_CTL_POWER_D0\t\t0x0000\t \n#define SNDRV_CTL_POWER_D1\t\t0x0100\t \n#define SNDRV_CTL_POWER_D2\t\t0x0200\t \n#define SNDRV_CTL_POWER_D3\t\t0x0300\t \n#define SNDRV_CTL_POWER_D3hot\t\t(SNDRV_CTL_POWER_D3|0x0000)\t \n#define SNDRV_CTL_POWER_D3cold\t\t(SNDRV_CTL_POWER_D3|0x0001)\t \n\n#define SNDRV_CTL_ELEM_ID_NAME_MAXLEN\t44\n\nstruct snd_ctl_elem_id {\n\tunsigned int numid;\t\t \n\tsnd_ctl_elem_iface_t iface;\t \n\tunsigned int device;\t\t \n\tunsigned int subdevice;\t\t \n\tunsigned char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\t\t \n\tunsigned int index;\t\t \n};\n\nstruct snd_ctl_elem_list {\n\tunsigned int offset;\t\t \n\tunsigned int space;\t\t \n\tunsigned int used;\t\t \n\tunsigned int count;\t\t \n\tstruct snd_ctl_elem_id __user *pids;  \n\tunsigned char reserved[50];\n};\n\nstruct snd_ctl_elem_info {\n\tstruct snd_ctl_elem_id id;\t \n\tsnd_ctl_elem_type_t type;\t \n\tunsigned int access;\t\t \n\tunsigned int count;\t\t \n\t__kernel_pid_t owner;\t\t \n\tunion {\n\t\tstruct {\n\t\t\tlong min;\t\t \n\t\t\tlong max;\t\t \n\t\t\tlong step;\t\t \n\t\t} integer;\n\t\tstruct {\n\t\t\tlong long min;\t\t \n\t\t\tlong long max;\t\t \n\t\t\tlong long step;\t\t \n\t\t} integer64;\n\t\tstruct {\n\t\t\tunsigned int items;\t \n\t\t\tunsigned int item;\t \n\t\t\tchar name[64];\t\t \n\t\t\t__u64 names_ptr;\t \n\t\t\tunsigned int names_length;\n\t\t} enumerated;\n\t\tunsigned char reserved[128];\n\t} value;\n\tunsigned char reserved[64];\n};\n\nstruct snd_ctl_elem_value {\n\tstruct snd_ctl_elem_id id;\t \n\tunsigned int indirect: 1;\t \n\tunion {\n\t\tunion {\n\t\t\tlong value[128];\n\t\t\tlong *value_ptr;\t \n\t\t} integer;\n\t\tunion {\n\t\t\tlong long value[64];\n\t\t\tlong long *value_ptr;\t \n\t\t} integer64;\n\t\tunion {\n\t\t\tunsigned int item[128];\n\t\t\tunsigned int *item_ptr;\t \n\t\t} enumerated;\n\t\tunion {\n\t\t\tunsigned char data[512];\n\t\t\tunsigned char *data_ptr;\t \n\t\t} bytes;\n\t\tstruct snd_aes_iec958 iec958;\n\t} value;\t\t \n\tunsigned char reserved[128];\n};\n\nstruct snd_ctl_tlv {\n\tunsigned int numid;\t \n\tunsigned int length;\t \n\tunsigned int tlv[];\t \n};\n\n#define SNDRV_CTL_IOCTL_PVERSION\t_IOR('U', 0x00, int)\n#define SNDRV_CTL_IOCTL_CARD_INFO\t_IOR('U', 0x01, struct snd_ctl_card_info)\n#define SNDRV_CTL_IOCTL_ELEM_LIST\t_IOWR('U', 0x10, struct snd_ctl_elem_list)\n#define SNDRV_CTL_IOCTL_ELEM_INFO\t_IOWR('U', 0x11, struct snd_ctl_elem_info)\n#define SNDRV_CTL_IOCTL_ELEM_READ\t_IOWR('U', 0x12, struct snd_ctl_elem_value)\n#define SNDRV_CTL_IOCTL_ELEM_WRITE\t_IOWR('U', 0x13, struct snd_ctl_elem_value)\n#define SNDRV_CTL_IOCTL_ELEM_LOCK\t_IOW('U', 0x14, struct snd_ctl_elem_id)\n#define SNDRV_CTL_IOCTL_ELEM_UNLOCK\t_IOW('U', 0x15, struct snd_ctl_elem_id)\n#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)\n#define SNDRV_CTL_IOCTL_ELEM_ADD\t_IOWR('U', 0x17, struct snd_ctl_elem_info)\n#define SNDRV_CTL_IOCTL_ELEM_REPLACE\t_IOWR('U', 0x18, struct snd_ctl_elem_info)\n#define SNDRV_CTL_IOCTL_ELEM_REMOVE\t_IOWR('U', 0x19, struct snd_ctl_elem_id)\n#define SNDRV_CTL_IOCTL_TLV_READ\t_IOWR('U', 0x1a, struct snd_ctl_tlv)\n#define SNDRV_CTL_IOCTL_TLV_WRITE\t_IOWR('U', 0x1b, struct snd_ctl_tlv)\n#define SNDRV_CTL_IOCTL_TLV_COMMAND\t_IOWR('U', 0x1c, struct snd_ctl_tlv)\n#define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR('U', 0x20, int)\n#define SNDRV_CTL_IOCTL_HWDEP_INFO\t_IOR('U', 0x21, struct snd_hwdep_info)\n#define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE\t_IOR('U', 0x30, int)\n#define SNDRV_CTL_IOCTL_PCM_INFO\t_IOWR('U', 0x31, struct snd_pcm_info)\n#define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW('U', 0x32, int)\n#define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR('U', 0x40, int)\n#define SNDRV_CTL_IOCTL_RAWMIDI_INFO\t_IOWR('U', 0x41, struct snd_rawmidi_info)\n#define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW('U', 0x42, int)\n#define SNDRV_CTL_IOCTL_UMP_NEXT_DEVICE\t_IOWR('U', 0x43, int)\n#define SNDRV_CTL_IOCTL_UMP_ENDPOINT_INFO _IOWR('U', 0x44, struct snd_ump_endpoint_info)\n#define SNDRV_CTL_IOCTL_UMP_BLOCK_INFO\t_IOWR('U', 0x45, struct snd_ump_block_info)\n#define SNDRV_CTL_IOCTL_POWER\t\t_IOWR('U', 0xd0, int)\n#define SNDRV_CTL_IOCTL_POWER_STATE\t_IOR('U', 0xd1, int)\n\n \n\nenum sndrv_ctl_event_type {\n\tSNDRV_CTL_EVENT_ELEM = 0,\n\tSNDRV_CTL_EVENT_LAST = SNDRV_CTL_EVENT_ELEM,\n};\n\n#define SNDRV_CTL_EVENT_MASK_VALUE\t(1<<0)\t \n#define SNDRV_CTL_EVENT_MASK_INFO\t(1<<1)\t \n#define SNDRV_CTL_EVENT_MASK_ADD\t(1<<2)\t \n#define SNDRV_CTL_EVENT_MASK_TLV\t(1<<3)\t \n#define SNDRV_CTL_EVENT_MASK_REMOVE\t(~0U)\t \n\nstruct snd_ctl_event {\n\tint type;\t \n\tunion {\n\t\tstruct {\n\t\t\tunsigned int mask;\n\t\t\tstruct snd_ctl_elem_id id;\n\t\t} elem;\n\t\tunsigned char data8[60];\n\t} data;\n};\n\n \n\n#define SNDRV_CTL_NAME_NONE\t\t\t\t\"\"\n#define SNDRV_CTL_NAME_PLAYBACK\t\t\t\t\"Playback \"\n#define SNDRV_CTL_NAME_CAPTURE\t\t\t\t\"Capture \"\n\n#define SNDRV_CTL_NAME_IEC958_NONE\t\t\t\"\"\n#define SNDRV_CTL_NAME_IEC958_SWITCH\t\t\t\"Switch\"\n#define SNDRV_CTL_NAME_IEC958_VOLUME\t\t\t\"Volume\"\n#define SNDRV_CTL_NAME_IEC958_DEFAULT\t\t\t\"Default\"\n#define SNDRV_CTL_NAME_IEC958_MASK\t\t\t\"Mask\"\n#define SNDRV_CTL_NAME_IEC958_CON_MASK\t\t\t\"Con Mask\"\n#define SNDRV_CTL_NAME_IEC958_PRO_MASK\t\t\t\"Pro Mask\"\n#define SNDRV_CTL_NAME_IEC958_PCM_STREAM\t\t\"PCM Stream\"\n#define SNDRV_CTL_NAME_IEC958(expl,direction,what)\t\"IEC958 \" expl SNDRV_CTL_NAME_##direction SNDRV_CTL_NAME_IEC958_##what\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}