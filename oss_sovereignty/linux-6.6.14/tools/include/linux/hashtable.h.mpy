{
  "module_name": "hashtable.h",
  "hash_id": "3a11730f3d871d8dd8bd9445f556576d2e0668ec9eb59f327c7ce33169bc4308",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/hashtable.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_HASHTABLE_H\n#define _LINUX_HASHTABLE_H\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n\n#define DEFINE_HASHTABLE(name, bits)\t\t\t\t\t\t\\\n\tstruct hlist_head name[1 << (bits)] =\t\t\t\t\t\\\n\t\t\t{ [0 ... ((1 << (bits)) - 1)] = HLIST_HEAD_INIT }\n\n#define DECLARE_HASHTABLE(name, bits)                                   \t\\\n\tstruct hlist_head name[1 << (bits)]\n\n#define HASH_SIZE(name) (ARRAY_SIZE(name))\n#define HASH_BITS(name) ilog2(HASH_SIZE(name))\n\n \n#define hash_min(val, bits)\t\t\t\t\t\t\t\\\n\t(sizeof(val) <= 4 ? hash_32(val, bits) : hash_long(val, bits))\n\nstatic inline void __hash_init(struct hlist_head *ht, unsigned int sz)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sz; i++)\n\t\tINIT_HLIST_HEAD(&ht[i]);\n}\n\n \n#define hash_init(hashtable) __hash_init(hashtable, HASH_SIZE(hashtable))\n\n \n#define hash_add(hashtable, node, key)\t\t\t\t\t\t\\\n\thlist_add_head(node, &hashtable[hash_min(key, HASH_BITS(hashtable))])\n\n \nstatic inline bool hash_hashed(struct hlist_node *node)\n{\n\treturn !hlist_unhashed(node);\n}\n\nstatic inline bool __hash_empty(struct hlist_head *ht, unsigned int sz)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sz; i++)\n\t\tif (!hlist_empty(&ht[i]))\n\t\t\treturn false;\n\n\treturn true;\n}\n\n \n#define hash_empty(hashtable) __hash_empty(hashtable, HASH_SIZE(hashtable))\n\n \nstatic inline void hash_del(struct hlist_node *node)\n{\n\thlist_del_init(node);\n}\n\n \n#define hash_for_each(name, bkt, obj, member)\t\t\t\t\\\n\tfor ((bkt) = 0, obj = NULL; obj == NULL && (bkt) < HASH_SIZE(name);\\\n\t\t\t(bkt)++)\\\n\t\thlist_for_each_entry(obj, &name[bkt], member)\n\n \n#define hash_for_each_safe(name, bkt, tmp, obj, member)\t\t\t\\\n\tfor ((bkt) = 0, obj = NULL; obj == NULL && (bkt) < HASH_SIZE(name);\\\n\t\t\t(bkt)++)\\\n\t\thlist_for_each_entry_safe(obj, tmp, &name[bkt], member)\n\n \n#define hash_for_each_possible(name, obj, member, key)\t\t\t\\\n\thlist_for_each_entry(obj, &name[hash_min(key, HASH_BITS(name))], member)\n\n \n#define hash_for_each_possible_safe(name, obj, tmp, member, key)\t\\\n\thlist_for_each_entry_safe(obj, tmp,\\\n\t\t&name[hash_min(key, HASH_BITS(name))], member)\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}