{
  "module_name": "jhash.h",
  "hash_id": "2fc0e57a74926dbc6cc370f12e3ff089dfe31e2766767501a85ab2044e56dc49",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/jhash.h",
  "human_readable_source": "#ifndef _LINUX_JHASH_H\n#define _LINUX_JHASH_H\n\n \n#include <linux/bitops.h>\n#include <linux/unaligned/packed_struct.h>\n\n \n#define jhash_size(n)   ((u32)1<<(n))\n \n#define jhash_mask(n)   (jhash_size(n)-1)\n\n \n#define __jhash_mix(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\ta -= c;  a ^= rol32(c, 4);  c += b;\t\\\n\tb -= a;  b ^= rol32(a, 6);  a += c;\t\\\n\tc -= b;  c ^= rol32(b, 8);  b += a;\t\\\n\ta -= c;  a ^= rol32(c, 16); c += b;\t\\\n\tb -= a;  b ^= rol32(a, 19); a += c;\t\\\n\tc -= b;  c ^= rol32(b, 4);  b += a;\t\\\n}\n\n \n#define __jhash_final(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\tc ^= b; c -= rol32(b, 14);\t\t\\\n\ta ^= c; a -= rol32(c, 11);\t\t\\\n\tb ^= a; b -= rol32(a, 25);\t\t\\\n\tc ^= b; c -= rol32(b, 16);\t\t\\\n\ta ^= c; a -= rol32(c, 4);\t\t\\\n\tb ^= a; b -= rol32(a, 14);\t\t\\\n\tc ^= b; c -= rol32(b, 24);\t\t\\\n}\n\n \n#define JHASH_INITVAL\t\t0xdeadbeef\n\n \nstatic inline u32 jhash(const void *key, u32 length, u32 initval)\n{\n\tu32 a, b, c;\n\tconst u8 *k = key;\n\n\t \n\ta = b = c = JHASH_INITVAL + length + initval;\n\n\t \n\twhile (length > 12) {\n\t\ta += __get_unaligned_cpu32(k);\n\t\tb += __get_unaligned_cpu32(k + 4);\n\t\tc += __get_unaligned_cpu32(k + 8);\n\t\t__jhash_mix(a, b, c);\n\t\tlength -= 12;\n\t\tk += 12;\n\t}\n\t \n\t \n\tswitch (length) {\n\tcase 12: c += (u32)k[11]<<24;\n\tcase 11: c += (u32)k[10]<<16;\n\tcase 10: c += (u32)k[9]<<8;\n\tcase 9:  c += k[8];\n\tcase 8:  b += (u32)k[7]<<24;\n\tcase 7:  b += (u32)k[6]<<16;\n\tcase 6:  b += (u32)k[5]<<8;\n\tcase 5:  b += k[4];\n\tcase 4:  a += (u32)k[3]<<24;\n\tcase 3:  a += (u32)k[2]<<16;\n\tcase 2:  a += (u32)k[1]<<8;\n\tcase 1:  a += k[0];\n\t\t __jhash_final(a, b, c);\n\tcase 0:  \n\t\tbreak;\n\t}\n\n\treturn c;\n}\n\n \nstatic inline u32 jhash2(const u32 *k, u32 length, u32 initval)\n{\n\tu32 a, b, c;\n\n\t \n\ta = b = c = JHASH_INITVAL + (length<<2) + initval;\n\n\t \n\twhile (length > 3) {\n\t\ta += k[0];\n\t\tb += k[1];\n\t\tc += k[2];\n\t\t__jhash_mix(a, b, c);\n\t\tlength -= 3;\n\t\tk += 3;\n\t}\n\n\t \n\tswitch (length) {\n\tcase 3: c += k[2];\n\tcase 2: b += k[1];\n\tcase 1: a += k[0];\n\t\t__jhash_final(a, b, c);\n\tcase 0:\t \n\t\tbreak;\n\t}\n\n\treturn c;\n}\n\n\n \nstatic inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)\n{\n\ta += initval;\n\tb += initval;\n\tc += initval;\n\n\t__jhash_final(a, b, c);\n\n\treturn c;\n}\n\nstatic inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)\n{\n\treturn __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 << 2));\n}\n\nstatic inline u32 jhash_2words(u32 a, u32 b, u32 initval)\n{\n\treturn __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n}\n\nstatic inline u32 jhash_1word(u32 a, u32 initval)\n{\n\treturn __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 << 2));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}