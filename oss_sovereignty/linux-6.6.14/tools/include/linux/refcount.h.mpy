{
  "module_name": "refcount.h",
  "hash_id": "9ab953eb58352a45067e8c7305a6cc0c346d8eaca29cb92c60d5b635fa10130c",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/refcount.h",
  "human_readable_source": " \n#ifndef _TOOLS_LINUX_REFCOUNT_H\n#define _TOOLS_LINUX_REFCOUNT_H\n\n \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#ifdef NDEBUG\n#define REFCOUNT_WARN(cond, str) (void)(cond)\n#define __refcount_check\n#else\n#define REFCOUNT_WARN(cond, str) BUG_ON(cond)\n#define __refcount_check\t__must_check\n#endif\n\ntypedef struct refcount_struct {\n\tatomic_t refs;\n} refcount_t;\n\n#define REFCOUNT_INIT(n)\t{ .refs = ATOMIC_INIT(n), }\n\nstatic inline void refcount_set(refcount_t *r, unsigned int n)\n{\n\tatomic_set(&r->refs, n);\n}\n\nstatic inline unsigned int refcount_read(const refcount_t *r)\n{\n\treturn atomic_read(&r->refs);\n}\n\n \nstatic inline __refcount_check\nbool refcount_inc_not_zero(refcount_t *r)\n{\n\tunsigned int old, new, val = atomic_read(&r->refs);\n\n\tfor (;;) {\n\t\tnew = val + 1;\n\n\t\tif (!val)\n\t\t\treturn false;\n\n\t\tif (unlikely(!new))\n\t\t\treturn true;\n\n\t\told = atomic_cmpxchg_relaxed(&r->refs, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\n\tREFCOUNT_WARN(new == UINT_MAX, \"refcount_t: saturated; leaking memory.\\n\");\n\n\treturn true;\n}\n\n \nstatic inline void refcount_inc(refcount_t *r)\n{\n\tREFCOUNT_WARN(!refcount_inc_not_zero(r), \"refcount_t: increment on 0; use-after-free.\\n\");\n}\n\n \nstatic inline __refcount_check\nbool refcount_sub_and_test(unsigned int i, refcount_t *r)\n{\n\tunsigned int old, new, val = atomic_read(&r->refs);\n\n\tfor (;;) {\n\t\tif (unlikely(val == UINT_MAX))\n\t\t\treturn false;\n\n\t\tnew = val - i;\n\t\tif (new > val) {\n\t\t\tREFCOUNT_WARN(new > val, \"refcount_t: underflow; use-after-free.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\told = atomic_cmpxchg_release(&r->refs, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\n\treturn !new;\n}\n\nstatic inline __refcount_check\nbool refcount_dec_and_test(refcount_t *r)\n{\n\treturn refcount_sub_and_test(1, r);\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}