{
  "module_name": "rbtree.h",
  "hash_id": "a1b9e718f4a18d47997efacbde64708f3fdb3a98a9086ff56845ae7d2f20e617",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/rbtree.h",
  "human_readable_source": " \n \n\n#ifndef __TOOLS_LINUX_PERF_RBTREE_H\n#define __TOOLS_LINUX_PERF_RBTREE_H\n\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstruct rb_node {\n\tunsigned long  __rb_parent_color;\n\tstruct rb_node *rb_right;\n\tstruct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n     \n\nstruct rb_root {\n\tstruct rb_node *rb_node;\n};\n\n#define rb_parent(r)   ((struct rb_node *)((r)->__rb_parent_color & ~3))\n\n#define RB_ROOT\t(struct rb_root) { NULL, }\n#define\trb_entry(ptr, type, member) container_of(ptr, type, member)\n\n#define RB_EMPTY_ROOT(root)  (READ_ONCE((root)->rb_node) == NULL)\n\n \n#define RB_EMPTY_NODE(node)  \\\n\t((node)->__rb_parent_color == (unsigned long)(node))\n#define RB_CLEAR_NODE(node)  \\\n\t((node)->__rb_parent_color = (unsigned long)(node))\n\n\nextern void rb_insert_color(struct rb_node *, struct rb_root *);\nextern void rb_erase(struct rb_node *, struct rb_root *);\n\n\n \nextern struct rb_node *rb_next(const struct rb_node *);\nextern struct rb_node *rb_prev(const struct rb_node *);\nextern struct rb_node *rb_first(const struct rb_root *);\nextern struct rb_node *rb_last(const struct rb_root *);\n\n \nextern struct rb_node *rb_first_postorder(const struct rb_root *);\nextern struct rb_node *rb_next_postorder(const struct rb_node *);\n\n \nextern void rb_replace_node(struct rb_node *victim, struct rb_node *new,\n\t\t\t    struct rb_root *root);\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent,\n\t\t\t\tstruct rb_node **rb_link)\n{\n\tnode->__rb_parent_color = (unsigned long)parent;\n\tnode->rb_left = node->rb_right = NULL;\n\n\t*rb_link = node;\n}\n\n#define rb_entry_safe(ptr, type, member) \\\n\t({ typeof(ptr) ____ptr = (ptr); \\\n\t   ____ptr ? rb_entry(____ptr, type, member) : NULL; \\\n\t})\n\n \n#define rbtree_postorder_for_each_entry_safe(pos, n, root, field) \\\n\tfor (pos = rb_entry_safe(rb_first_postorder(root), typeof(*pos), field); \\\n\t     pos && ({ n = rb_entry_safe(rb_next_postorder(&pos->field), \\\n\t\t\ttypeof(*pos), field); 1; }); \\\n\t     pos = n)\n\nstatic inline void rb_erase_init(struct rb_node *n, struct rb_root *root)\n{\n\trb_erase(n, root);\n\tRB_CLEAR_NODE(n);\n}\n\n \nstruct rb_root_cached {\n\tstruct rb_root rb_root;\n\tstruct rb_node *rb_leftmost;\n};\n\n#define RB_ROOT_CACHED (struct rb_root_cached) { {NULL, }, NULL }\n\n \n#define rb_first_cached(root) (root)->rb_leftmost\n\nstatic inline void rb_insert_color_cached(struct rb_node *node,\n\t\t\t\t\t  struct rb_root_cached *root,\n\t\t\t\t\t  bool leftmost)\n{\n\tif (leftmost)\n\t\troot->rb_leftmost = node;\n\trb_insert_color(node, &root->rb_root);\n}\n\nstatic inline void rb_erase_cached(struct rb_node *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\tif (root->rb_leftmost == node)\n\t\troot->rb_leftmost = rb_next(node);\n\trb_erase(node, &root->rb_root);\n}\n\nstatic inline void rb_replace_node_cached(struct rb_node *victim,\n\t\t\t\t\t  struct rb_node *new,\n\t\t\t\t\t  struct rb_root_cached *root)\n{\n\tif (root->rb_leftmost == victim)\n\t\troot->rb_leftmost = new;\n\trb_replace_node(victim, new, &root->rb_root);\n}\n\n \n\n \nstatic __always_inline void\nrb_add_cached(struct rb_node *node, struct rb_root_cached *tree,\n\t      bool (*less)(struct rb_node *, const struct rb_node *))\n{\n\tstruct rb_node **link = &tree->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tbool leftmost = true;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tif (less(node, parent)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, link);\n\trb_insert_color_cached(node, tree, leftmost);\n}\n\n \nstatic __always_inline void\nrb_add(struct rb_node *node, struct rb_root *tree,\n       bool (*less)(struct rb_node *, const struct rb_node *))\n{\n\tstruct rb_node **link = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tif (less(node, parent))\n\t\t\tlink = &parent->rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_right;\n\t}\n\n\trb_link_node(node, parent, link);\n\trb_insert_color(node, tree);\n}\n\n \nstatic __always_inline struct rb_node *\nrb_find_add(struct rb_node *node, struct rb_root *tree,\n\t    int (*cmp)(struct rb_node *, const struct rb_node *))\n{\n\tstruct rb_node **link = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint c;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tc = cmp(node, parent);\n\n\t\tif (c < 0)\n\t\t\tlink = &parent->rb_left;\n\t\telse if (c > 0)\n\t\t\tlink = &parent->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, link);\n\trb_insert_color(node, tree);\n\treturn NULL;\n}\n\n \nstatic __always_inline struct rb_node *\nrb_find(const void *key, const struct rb_root *tree,\n\tint (*cmp)(const void *key, const struct rb_node *))\n{\n\tstruct rb_node *node = tree->rb_node;\n\n\twhile (node) {\n\t\tint c = cmp(key, node);\n\n\t\tif (c < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (c > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic __always_inline struct rb_node *\nrb_find_first(const void *key, const struct rb_root *tree,\n\t      int (*cmp)(const void *key, const struct rb_node *))\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct rb_node *match = NULL;\n\n\twhile (node) {\n\t\tint c = cmp(key, node);\n\n\t\tif (c <= 0) {\n\t\t\tif (!c)\n\t\t\t\tmatch = node;\n\t\t\tnode = node->rb_left;\n\t\t} else if (c > 0) {\n\t\t\tnode = node->rb_right;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n \nstatic __always_inline struct rb_node *\nrb_next_match(const void *key, struct rb_node *node,\n\t      int (*cmp)(const void *key, const struct rb_node *))\n{\n\tnode = rb_next(node);\n\tif (node && cmp(key, node))\n\t\tnode = NULL;\n\treturn node;\n}\n\n \n#define rb_for_each(node, key, tree, cmp) \\\n\tfor ((node) = rb_find_first((key), (tree), (cmp)); \\\n\t     (node); (node) = rb_next_match((key), (node), (cmp)))\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}