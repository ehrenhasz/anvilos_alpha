{
  "module_name": "find.h",
  "hash_id": "d84abd6d3d65bdcfbba97ccf06a52ddb1804a725e64138f241a4e3cdbb2d1896",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/find.h",
  "human_readable_source": " \n#ifndef _TOOLS_LINUX_FIND_H_\n#define _TOOLS_LINUX_FIND_H_\n\n#ifndef _TOOLS_LINUX_BITMAP_H\n#error tools: only <linux/bitmap.h> can be included directly\n#endif\n\n#include <linux/bitops.h>\n\nunsigned long _find_next_bit(const unsigned long *addr1, unsigned long nbits,\n\t\t\t\tunsigned long start);\nunsigned long _find_next_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start);\nunsigned long _find_next_zero_bit(const unsigned long *addr, unsigned long nbits,\n\t\t\t\t\t unsigned long start);\nextern unsigned long _find_first_bit(const unsigned long *addr, unsigned long size);\nextern unsigned long _find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t\t const unsigned long *addr2, unsigned long size);\nextern unsigned long _find_first_zero_bit(const unsigned long *addr, unsigned long size);\n\n#ifndef find_next_bit\n \nstatic inline\nunsigned long find_next_bit(const unsigned long *addr, unsigned long size,\n\t\t\t    unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_bit(addr, size, offset);\n}\n#endif\n\n#ifndef find_next_and_bit\n \nstatic inline\nunsigned long find_next_and_bit(const unsigned long *addr1,\n\t\tconst unsigned long *addr2, unsigned long size,\n\t\tunsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr1 & *addr2 & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_and_bit(addr1, addr2, size, offset);\n}\n#endif\n\n#ifndef find_next_zero_bit\n \nstatic inline\nunsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\t\t\t\t unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr | ~GENMASK(size - 1, offset);\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_next_zero_bit(addr, size, offset);\n}\n#endif\n\n#ifndef find_first_bit\n \nstatic inline\nunsigned long find_first_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr & GENMASK(size - 1, 0);\n\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_first_bit(addr, size);\n}\n#endif\n\n#ifndef find_first_and_bit\n \nstatic inline\nunsigned long find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t const unsigned long *addr2,\n\t\t\t\t unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr1 & *addr2 & GENMASK(size - 1, 0);\n\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_first_and_bit(addr1, addr2, size);\n}\n#endif\n\n#ifndef find_first_zero_bit\n \nstatic inline\nunsigned long find_first_zero_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr | ~GENMASK(size - 1, 0);\n\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_first_zero_bit(addr, size);\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}