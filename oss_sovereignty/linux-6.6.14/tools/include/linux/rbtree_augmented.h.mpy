{
  "module_name": "rbtree_augmented.h",
  "hash_id": "c9369291224a49f5ebab79bb81ae31f7c4eef8e8309fe22bb258dbacc5eb963c",
  "original_prompt": "Ingested from linux-6.6.14/tools/include/linux/rbtree_augmented.h",
  "human_readable_source": " \n \n\n#ifndef _TOOLS_LINUX_RBTREE_AUGMENTED_H\n#define _TOOLS_LINUX_RBTREE_AUGMENTED_H\n\n#include <linux/compiler.h>\n#include <linux/rbtree.h>\n\n \n\nstruct rb_augment_callbacks {\n\tvoid (*propagate)(struct rb_node *node, struct rb_node *stop);\n\tvoid (*copy)(struct rb_node *old, struct rb_node *new);\n\tvoid (*rotate)(struct rb_node *old, struct rb_node *new);\n};\n\nextern void __rb_insert_augmented(struct rb_node *node, struct rb_root *root,\n\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new));\n\n \nstatic inline void\nrb_insert_augmented(struct rb_node *node, struct rb_root *root,\n\t\t    const struct rb_augment_callbacks *augment)\n{\n\t__rb_insert_augmented(node, root, augment->rotate);\n}\n\nstatic inline void\nrb_insert_augmented_cached(struct rb_node *node,\n\t\t\t   struct rb_root_cached *root, bool newleft,\n\t\t\t   const struct rb_augment_callbacks *augment)\n{\n\tif (newleft)\n\t\troot->rb_leftmost = node;\n\trb_insert_augmented(node, &root->rb_root, augment);\n}\n\n \n\n#define RB_DECLARE_CALLBACKS(RBSTATIC, RBNAME,\t\t\t\t\\\n\t\t\t     RBSTRUCT, RBFIELD, RBAUGMENTED, RBCOMPUTE)\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nRBNAME ## _propagate(struct rb_node *rb, struct rb_node *stop)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\twhile (rb != stop) {\t\t\t\t\t\t\\\n\t\tRBSTRUCT *node = rb_entry(rb, RBSTRUCT, RBFIELD);\t\\\n\t\tif (RBCOMPUTE(node, true))\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\trb = rb_parent(&node->RBFIELD);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nRBNAME ## _copy(struct rb_node *rb_old, struct rb_node *rb_new)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tRBSTRUCT *old = rb_entry(rb_old, RBSTRUCT, RBFIELD);\t\t\\\n\tRBSTRUCT *new = rb_entry(rb_new, RBSTRUCT, RBFIELD);\t\t\\\n\tnew->RBAUGMENTED = old->RBAUGMENTED;\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void\t\t\t\t\t\t\t\t\\\nRBNAME ## _rotate(struct rb_node *rb_old, struct rb_node *rb_new)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tRBSTRUCT *old = rb_entry(rb_old, RBSTRUCT, RBFIELD);\t\t\\\n\tRBSTRUCT *new = rb_entry(rb_new, RBSTRUCT, RBFIELD);\t\t\\\n\tnew->RBAUGMENTED = old->RBAUGMENTED;\t\t\t\t\\\n\tRBCOMPUTE(old, false);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nRBSTATIC const struct rb_augment_callbacks RBNAME = {\t\t\t\\\n\t.propagate = RBNAME ## _propagate,\t\t\t\t\\\n\t.copy = RBNAME ## _copy,\t\t\t\t\t\\\n\t.rotate = RBNAME ## _rotate\t\t\t\t\t\\\n};\n\n \n\n#define RB_DECLARE_CALLBACKS_MAX(RBSTATIC, RBNAME, RBSTRUCT, RBFIELD,\t      \\\n\t\t\t\t RBTYPE, RBAUGMENTED, RBCOMPUTE)\t      \\\nstatic inline bool RBNAME ## _compute_max(RBSTRUCT *node, bool exit)\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tRBSTRUCT *child;\t\t\t\t\t\t      \\\n\tRBTYPE max = RBCOMPUTE(node);\t\t\t\t\t      \\\n\tif (node->RBFIELD.rb_left) {\t\t\t\t\t      \\\n\t\tchild = rb_entry(node->RBFIELD.rb_left, RBSTRUCT, RBFIELD);   \\\n\t\tif (child->RBAUGMENTED > max)\t\t\t\t      \\\n\t\t\tmax = child->RBAUGMENTED;\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\tif (node->RBFIELD.rb_right) {\t\t\t\t\t      \\\n\t\tchild = rb_entry(node->RBFIELD.rb_right, RBSTRUCT, RBFIELD);  \\\n\t\tif (child->RBAUGMENTED > max)\t\t\t\t      \\\n\t\t\tmax = child->RBAUGMENTED;\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\tif (exit && node->RBAUGMENTED == max)\t\t\t\t      \\\n\t\treturn true;\t\t\t\t\t\t      \\\n\tnode->RBAUGMENTED = max;\t\t\t\t\t      \\\n\treturn false;\t\t\t\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\nRB_DECLARE_CALLBACKS(RBSTATIC, RBNAME,\t\t\t\t\t      \\\n\t\t     RBSTRUCT, RBFIELD, RBAUGMENTED, RBNAME ## _compute_max)\n\n\n#define\tRB_RED\t\t0\n#define\tRB_BLACK\t1\n\n#define __rb_parent(pc)    ((struct rb_node *)(pc & ~3))\n\n#define __rb_color(pc)     ((pc) & 1)\n#define __rb_is_black(pc)  __rb_color(pc)\n#define __rb_is_red(pc)    (!__rb_color(pc))\n#define rb_color(rb)       __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)      __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)    __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)\n{\n\trb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb,\n\t\t\t\t       struct rb_node *p, int color)\n{\n\trb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void\n__rb_change_child(struct rb_node *old, struct rb_node *new,\n\t\t  struct rb_node *parent, struct rb_root *root)\n{\n\tif (parent) {\n\t\tif (parent->rb_left == old)\n\t\t\tWRITE_ONCE(parent->rb_left, new);\n\t\telse\n\t\t\tWRITE_ONCE(parent->rb_right, new);\n\t} else\n\t\tWRITE_ONCE(root->rb_node, new);\n}\n\nextern void __rb_erase_color(struct rb_node *parent, struct rb_root *root,\n\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new));\n\nstatic __always_inline struct rb_node *\n__rb_erase_augmented(struct rb_node *node, struct rb_root *root,\n\t\t     const struct rb_augment_callbacks *augment)\n{\n\tstruct rb_node *child = node->rb_right;\n\tstruct rb_node *tmp = node->rb_left;\n\tstruct rb_node *parent, *rebalance;\n\tunsigned long pc;\n\n\tif (!tmp) {\n\t\t \n\t\tpc = node->__rb_parent_color;\n\t\tparent = __rb_parent(pc);\n\t\t__rb_change_child(node, child, parent, root);\n\t\tif (child) {\n\t\t\tchild->__rb_parent_color = pc;\n\t\t\trebalance = NULL;\n\t\t} else\n\t\t\trebalance = __rb_is_black(pc) ? parent : NULL;\n\t\ttmp = parent;\n\t} else if (!child) {\n\t\t \n\t\ttmp->__rb_parent_color = pc = node->__rb_parent_color;\n\t\tparent = __rb_parent(pc);\n\t\t__rb_change_child(node, tmp, parent, root);\n\t\trebalance = NULL;\n\t\ttmp = parent;\n\t} else {\n\t\tstruct rb_node *successor = child, *child2;\n\n\t\ttmp = child->rb_left;\n\t\tif (!tmp) {\n\t\t\t \n\t\t\tparent = successor;\n\t\t\tchild2 = successor->rb_right;\n\n\t\t\taugment->copy(node, successor);\n\t\t} else {\n\t\t\t \n\t\t\tdo {\n\t\t\t\tparent = successor;\n\t\t\t\tsuccessor = tmp;\n\t\t\t\ttmp = tmp->rb_left;\n\t\t\t} while (tmp);\n\t\t\tchild2 = successor->rb_right;\n\t\t\tWRITE_ONCE(parent->rb_left, child2);\n\t\t\tWRITE_ONCE(successor->rb_right, child);\n\t\t\trb_set_parent(child, successor);\n\n\t\t\taugment->copy(node, successor);\n\t\t\taugment->propagate(parent, successor);\n\t\t}\n\n\t\ttmp = node->rb_left;\n\t\tWRITE_ONCE(successor->rb_left, tmp);\n\t\trb_set_parent(tmp, successor);\n\n\t\tpc = node->__rb_parent_color;\n\t\ttmp = __rb_parent(pc);\n\t\t__rb_change_child(node, successor, tmp, root);\n\n\t\tif (child2) {\n\t\t\tsuccessor->__rb_parent_color = pc;\n\t\t\trb_set_parent_color(child2, parent, RB_BLACK);\n\t\t\trebalance = NULL;\n\t\t} else {\n\t\t\tunsigned long pc2 = successor->__rb_parent_color;\n\t\t\tsuccessor->__rb_parent_color = pc;\n\t\t\trebalance = __rb_is_black(pc2) ? parent : NULL;\n\t\t}\n\t\ttmp = successor;\n\t}\n\n\taugment->propagate(tmp, NULL);\n\treturn rebalance;\n}\n\nstatic __always_inline void\nrb_erase_augmented(struct rb_node *node, struct rb_root *root,\n\t\t   const struct rb_augment_callbacks *augment)\n{\n\tstruct rb_node *rebalance = __rb_erase_augmented(node, root, augment);\n\tif (rebalance)\n\t\t__rb_erase_color(rebalance, root, augment->rotate);\n}\n\nstatic __always_inline void\nrb_erase_augmented_cached(struct rb_node *node, struct rb_root_cached *root,\n\t\t\t  const struct rb_augment_callbacks *augment)\n{\n\tif (root->rb_leftmost == node)\n\t\troot->rb_leftmost = rb_next(node);\n\trb_erase_augmented(node, &root->rb_root, augment);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}