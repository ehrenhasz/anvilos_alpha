{
  "module_name": "runqslower.bpf.c",
  "hash_id": "fb720cb0852de674a05bd00c1ec56bf5e09010d4ed50d77c0c0f619dd2f55e68",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/runqslower/runqslower.bpf.c",
  "human_readable_source": "\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"runqslower.h\"\n\n#define TASK_RUNNING 0\n#define BPF_F_CURRENT_CPU 0xffffffffULL\n\nconst volatile __u64 min_us = 0;\nconst volatile pid_t targ_pid = 0;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, u64);\n} start SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n\n \n__always_inline\nstatic int trace_enqueue(struct task_struct *t)\n{\n\tu32 pid = t->pid;\n\tu64 *ptr;\n\n\tif (!pid || (targ_pid && targ_pid != pid))\n\t\treturn 0;\n\n\tptr = bpf_task_storage_get(&start, t, 0,\n\t\t\t\t   BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!ptr)\n\t\treturn 0;\n\n\t*ptr = bpf_ktime_get_ns();\n\treturn 0;\n}\n\nSEC(\"tp_btf/sched_wakeup\")\nint handle__sched_wakeup(u64 *ctx)\n{\n\t \n\tstruct task_struct *p = (void *)ctx[0];\n\n\treturn trace_enqueue(p);\n}\n\nSEC(\"tp_btf/sched_wakeup_new\")\nint handle__sched_wakeup_new(u64 *ctx)\n{\n\t \n\tstruct task_struct *p = (void *)ctx[0];\n\n\treturn trace_enqueue(p);\n}\n\nSEC(\"tp_btf/sched_switch\")\nint handle__sched_switch(u64 *ctx)\n{\n\t \n\tstruct task_struct *prev = (struct task_struct *)ctx[1];\n\tstruct task_struct *next = (struct task_struct *)ctx[2];\n\tstruct runq_event event = {};\n\tu64 *tsp, delta_us;\n\tlong state;\n\tu32 pid;\n\n\t \n\tif (prev->__state == TASK_RUNNING)\n\t\ttrace_enqueue(prev);\n\n\tpid = next->pid;\n\n\t \n\tif (!pid || (targ_pid && targ_pid != pid))\n\t\treturn 0;\n\n\t \n\ttsp = bpf_task_storage_get(&start, next, 0, 0);\n\tif (!tsp)\n\t\treturn 0;    \n\n\tdelta_us = (bpf_ktime_get_ns() - *tsp) / 1000;\n\tif (min_us && delta_us <= min_us)\n\t\treturn 0;\n\n\tevent.pid = pid;\n\tevent.delta_us = delta_us;\n\tbpf_get_current_comm(&event.task, sizeof(event.task));\n\n\t \n\tbpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,\n\t\t\t      &event, sizeof(event));\n\n\tbpf_task_storage_delete(&start, next);\n\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}