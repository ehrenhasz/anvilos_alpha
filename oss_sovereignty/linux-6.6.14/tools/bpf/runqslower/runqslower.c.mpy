{
  "module_name": "runqslower.c",
  "hash_id": "9600b281f27e588d258af7ac7cc45fbdcd39ae74a02491b3890cff7ff9d3c079",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/runqslower/runqslower.c",
  "human_readable_source": "\n\n#include <argp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n#include \"runqslower.h\"\n#include \"runqslower.skel.h\"\n\nstruct env {\n\tpid_t pid;\n\t__u64 min_us;\n\tbool verbose;\n} env = {\n\t.min_us = 10000,\n};\n\nconst char *argp_program_version = \"runqslower 0.1\";\nconst char *argp_program_bug_address = \"<bpf@vger.kernel.org>\";\nconst char argp_program_doc[] =\n\"runqslower    Trace long process scheduling delays.\\n\"\n\"              For Linux, uses eBPF, BPF CO-RE, libbpf, BTF.\\n\"\n\"\\n\"\n\"This script traces high scheduling delays between tasks being\\n\"\n\"ready to run and them running on CPU after that.\\n\"\n\"\\n\"\n\"USAGE: runqslower [-p PID] [min_us]\\n\"\n\"\\n\"\n\"EXAMPLES:\\n\"\n\"    runqslower         # trace run queue latency higher than 10000 us (default)\\n\"\n\"    runqslower 1000    # trace run queue latency higher than 1000 us\\n\"\n\"    runqslower -p 123  # trace pid 123 only\\n\";\n\nstatic const struct argp_option opts[] = {\n\t{ \"pid\", 'p', \"PID\", 0, \"Process PID to trace\"},\n\t{ \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tstatic int pos_args;\n\tint pid;\n\tlong long min_us;\n\n\tswitch (key) {\n\tcase 'v':\n\t\tenv.verbose = true;\n\t\tbreak;\n\tcase 'p':\n\t\terrno = 0;\n\t\tpid = strtol(arg, NULL, 10);\n\t\tif (errno || pid <= 0) {\n\t\t\tfprintf(stderr, \"Invalid PID: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tenv.pid = pid;\n\t\tbreak;\n\tcase ARGP_KEY_ARG:\n\t\tif (pos_args++) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Unrecognized positional argument: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\terrno = 0;\n\t\tmin_us = strtoll(arg, NULL, 10);\n\t\tif (errno || min_us <= 0) {\n\t\t\tfprintf(stderr, \"Invalid delay (in us): %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tenv.min_us = min_us;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nint libbpf_print_fn(enum libbpf_print_level level,\n\t\t    const char *format, va_list args)\n{\n\tif (level == LIBBPF_DEBUG && !env.verbose)\n\t\treturn 0;\n\treturn vfprintf(stderr, format, args);\n}\n\nvoid handle_event(void *ctx, int cpu, void *data, __u32 data_sz)\n{\n\tconst struct runq_event *e = data;\n\tstruct tm *tm;\n\tchar ts[32];\n\ttime_t t;\n\n\ttime(&t);\n\ttm = localtime(&t);\n\tstrftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\n\tprintf(\"%-8s %-16s %-6d %14llu\\n\", ts, e->task, e->pid, e->delta_us);\n}\n\nvoid handle_lost_events(void *ctx, int cpu, __u64 lost_cnt)\n{\n\tprintf(\"Lost %llu events on CPU #%d!\\n\", lost_cnt, cpu);\n}\n\nint main(int argc, char **argv)\n{\n\tstatic const struct argp argp = {\n\t\t.options = opts,\n\t\t.parser = parse_arg,\n\t\t.doc = argp_program_doc,\n\t};\n\tstruct perf_buffer *pb = NULL;\n\tstruct runqslower_bpf *obj;\n\tint err;\n\n\terr = argp_parse(&argp, argc, argv, 0, NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tlibbpf_set_print(libbpf_print_fn);\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tobj = runqslower_bpf__open();\n\tif (!obj) {\n\t\tfprintf(stderr, \"failed to open and/or load BPF object\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tobj->rodata->targ_pid = env.pid;\n\tobj->rodata->min_us = env.min_us;\n\n\terr = runqslower_bpf__load(obj);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to load BPF object: %d\\n\", err);\n\t\tgoto cleanup;\n\t}\n\n\terr = runqslower_bpf__attach(obj);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to attach BPF programs\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tprintf(\"Tracing run queue latency higher than %llu us\\n\", env.min_us);\n\tprintf(\"%-8s %-16s %-6s %14s\\n\", \"TIME\", \"COMM\", \"PID\", \"LAT(us)\");\n\n\tpb = perf_buffer__new(bpf_map__fd(obj->maps.events), 64,\n\t\t\t      handle_event, handle_lost_events, NULL, NULL);\n\terr = libbpf_get_error(pb);\n\tif (err) {\n\t\tpb = NULL;\n\t\tfprintf(stderr, \"failed to open perf buffer: %d\\n\", err);\n\t\tgoto cleanup;\n\t}\n\n\twhile ((err = perf_buffer__poll(pb, 100)) >= 0)\n\t\t;\n\tprintf(\"Error polling perf buffer: %d\\n\", err);\n\ncleanup:\n\tperf_buffer__free(pb);\n\trunqslower_bpf__destroy(obj);\n\n\treturn err != 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}