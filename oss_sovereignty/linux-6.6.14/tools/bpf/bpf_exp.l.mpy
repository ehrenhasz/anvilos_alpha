{
  "module_name": "bpf_exp.l",
  "hash_id": "c35ee4acf9c5bafcb7b879de0af1a867d6f82fda33cb45b1f12b1ed8dce5cdde",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpf_exp.l",
  "human_readable_source": "/*\n * BPF asm code lexer\n *\n * This program is free software; you can distribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * Syntax kept close to:\n *\n * Steven McCanne and Van Jacobson. 1993. The BSD packet filter: a new\n * architecture for user-level packet capture. In Proceedings of the\n * USENIX Winter 1993 Conference Proceedings on USENIX Winter 1993\n * Conference Proceedings (USENIX'93). USENIX Association, Berkeley,\n * CA, USA, 2-2.\n *\n * Copyright 2013 Daniel Borkmann <borkmann@redhat.com>\n * Licensed under the GNU General Public License, version 2.0 (GPLv2)\n */\n\n%{\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <linux/filter.h>\n\n#include \"bpf_exp.yacc.h\"\n\nextern void yyerror(const char *str);\n\n%}\n\n%option align\n%option ecs\n\n%option nounput\n%option noreject\n%option noinput\n%option noyywrap\n\n%option 8bit\n%option caseless\n%option yylineno\n\n%%\n\n\"ldb\"\t\t{ return OP_LDB; }\n\"ldh\"\t\t{ return OP_LDH; }\n\"ld\"\t\t{ return OP_LD; }\n\"ldi\"\t\t{ return OP_LDI; }\n\"ldx\"\t\t{ return OP_LDX; }\n\"ldxi\"\t\t{ return OP_LDXI; }\n\"ldxb\"\t\t{ return OP_LDXB; }\n\"st\"\t\t{ return OP_ST; }\n\"stx\"\t\t{ return OP_STX; }\n\"jmp\"\t\t{ return OP_JMP; }\n\"ja\"\t\t{ return OP_JMP; }\n\"jeq\"\t\t{ return OP_JEQ; }\n\"jneq\"\t\t{ return OP_JNEQ; }\n\"jne\"\t\t{ return OP_JNEQ; }\n\"jlt\"\t\t{ return OP_JLT; }\n\"jle\"\t\t{ return OP_JLE; }\n\"jgt\"\t\t{ return OP_JGT; }\n\"jge\"\t\t{ return OP_JGE; }\n\"jset\"\t\t{ return OP_JSET; }\n\"add\"\t\t{ return OP_ADD; }\n\"sub\"\t\t{ return OP_SUB; }\n\"mul\"\t\t{ return OP_MUL; }\n\"div\"\t\t{ return OP_DIV; }\n\"mod\"\t\t{ return OP_MOD; }\n\"neg\"\t\t{ return OP_NEG; }\n\"and\"\t\t{ return OP_AND; }\n\"xor\"\t\t{ return OP_XOR; }\n\"or\"\t\t{ return OP_OR; }\n\"lsh\"\t\t{ return OP_LSH; }\n\"rsh\"\t\t{ return OP_RSH; }\n\"ret\"\t\t{ return OP_RET; }\n\"tax\"\t\t{ return OP_TAX; }\n\"txa\"\t\t{ return OP_TXA; }\n\n\"#\"?(\"len\")\t{ return K_PKT_LEN; }\n\n\"#\"?(\"proto\")\t{\n\t\tyylval.number = SKF_AD_PROTOCOL;\n\t\treturn extension;\n\t}\n\"#\"?(\"type\")\t{\n\t\tyylval.number = SKF_AD_PKTTYPE;\n\t\treturn extension;\n\t}\n\"#\"?(\"poff\")\t{\n\t\tyylval.number = SKF_AD_PAY_OFFSET;\n\t\treturn extension;\n\t}\n\"#\"?(\"ifidx\")\t{\n\t\tyylval.number = SKF_AD_IFINDEX;\n\t\treturn extension;\n\t}\n\"#\"?(\"nla\")\t{\n\t\tyylval.number = SKF_AD_NLATTR;\n\t\treturn extension;\n\t}\n\"#\"?(\"nlan\")\t{\n\t\tyylval.number = SKF_AD_NLATTR_NEST;\n\t\treturn extension;\n\t}\n\"#\"?(\"mark\")\t{\n\t\tyylval.number = SKF_AD_MARK;\n\t\treturn extension;\n\t}\n\"#\"?(\"queue\")\t{\n\t\tyylval.number = SKF_AD_QUEUE;\n\t\treturn extension;\n\t}\n\"#\"?(\"hatype\")\t{\n\t\tyylval.number = SKF_AD_HATYPE;\n\t\treturn extension;\n\t}\n\"#\"?(\"rxhash\")\t{\n\t\tyylval.number = SKF_AD_RXHASH;\n\t\treturn extension;\n\t}\n\"#\"?(\"cpu\")\t{\n\t\tyylval.number = SKF_AD_CPU;\n\t\treturn extension;\n\t}\n\"#\"?(\"vlan_tci\") {\n\t\tyylval.number = SKF_AD_VLAN_TAG;\n\t\treturn extension;\n\t}\n\"#\"?(\"vlan_pr\")\t{\n\t\tyylval.number = SKF_AD_VLAN_TAG_PRESENT;\n\t\treturn extension;\n\t}\n\"#\"?(\"vlan_avail\") {\n\t\tyylval.number = SKF_AD_VLAN_TAG_PRESENT;\n\t\treturn extension;\n\t}\n\"#\"?(\"vlan_tpid\") {\n\t\tyylval.number = SKF_AD_VLAN_TPID;\n\t\treturn extension;\n\t}\n\"#\"?(\"rand\")\t{\n\t\tyylval.number = SKF_AD_RANDOM;\n\t\treturn extension;\n\t}\n\n\":\"\t\t{ return ':'; }\n\",\"\t\t{ return ','; }\n\"#\"\t\t{ return '#'; }\n\"%\"\t\t{ return '%'; }\n\"[\"\t\t{ return '['; }\n\"]\"\t\t{ return ']'; }\n\"(\"\t\t{ return '('; }\n\")\"\t\t{ return ')'; }\n\"x\"\t\t{ return 'x'; }\n\"a\"\t\t{ return 'a'; }\n\"+\"\t\t{ return '+'; }\n\"M\"\t\t{ return 'M'; }\n\"*\"\t\t{ return '*'; }\n\"&\"\t\t{ return '&'; }\n\n([0][x][a-fA-F0-9]+) {\n\t\t\tyylval.number = strtoul(yytext, NULL, 16);\n\t\t\treturn number;\n\t\t}\n([0][b][0-1]+)\t{\n\t\t\tyylval.number = strtol(yytext + 2, NULL, 2);\n\t\t\treturn number;\n\t\t}\n(([0])|([-+]?[1-9][0-9]*)) {\n\t\t\tyylval.number = strtol(yytext, NULL, 10);\n\t\t\treturn number;\n\t\t}\n([0][0-7]+)\t{\n\t\t\tyylval.number = strtol(yytext + 1, NULL, 8);\n\t\t\treturn number;\n\t\t}\n[a-zA-Z_][a-zA-Z0-9_]+ {\n\t\t\tyylval.label = strdup(yytext);\n\t\t\treturn label;\n\t\t}\n\n\"/*\"([^\\*]|\\*[^/])*\"*/\"\t\t{ /* NOP */ }\n\";\"[^\\n]*\t\t\t{ /* NOP */ }\n^#.*\t\t\t\t{ /* NOP */ }\n[ \\t]+\t\t\t\t{ /* NOP */ }\n[ \\n]+\t\t\t\t{ /* NOP */ }\n\n.\t\t{\n\t\t\tprintf(\"unknown character \\'%s\\'\", yytext);\n\t\t\tyyerror(\"lex unknown character\");\n\t\t}\n\n%%\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}