{
  "module_name": "main.c",
  "hash_id": "64a387019476019430b68b74eca64f0f0f1b2ff0d10006bad5b65e410e7dfc52",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/resolve_btfids/main.c",
  "human_readable_source": "\n\n \n\n#define  _GNU_SOURCE\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <libelf.h>\n#include <gelf.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <linux/rbtree.h>\n#include <linux/zalloc.h>\n#include <linux/err.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#include <subcmd/parse-options.h>\n\n#define BTF_IDS_SECTION\t\".BTF_ids\"\n#define BTF_ID\t\t\"__BTF_ID__\"\n\n#define BTF_STRUCT\t\"struct\"\n#define BTF_UNION\t\"union\"\n#define BTF_TYPEDEF\t\"typedef\"\n#define BTF_FUNC\t\"func\"\n#define BTF_SET\t\t\"set\"\n#define BTF_SET8\t\"set8\"\n\n#define ADDR_CNT\t100\n\nstruct btf_id {\n\tstruct rb_node\t rb_node;\n\tchar\t\t*name;\n\tunion {\n\t\tint\t id;\n\t\tint\t cnt;\n\t};\n\tint\t\t addr_cnt;\n\tbool\t\t is_set;\n\tbool\t\t is_set8;\n\tElf64_Addr\t addr[ADDR_CNT];\n};\n\nstruct object {\n\tconst char *path;\n\tconst char *btf;\n\tconst char *base_btf_path;\n\n\tstruct {\n\t\tint\t\t fd;\n\t\tElf\t\t*elf;\n\t\tElf_Data\t*symbols;\n\t\tElf_Data\t*idlist;\n\t\tint\t\t symbols_shndx;\n\t\tint\t\t idlist_shndx;\n\t\tsize_t\t\t strtabidx;\n\t\tunsigned long\t idlist_addr;\n\t} efile;\n\n\tstruct rb_root\tsets;\n\tstruct rb_root\tstructs;\n\tstruct rb_root\tunions;\n\tstruct rb_root\ttypedefs;\n\tstruct rb_root\tfuncs;\n\n\tint nr_funcs;\n\tint nr_structs;\n\tint nr_unions;\n\tint nr_typedefs;\n};\n\nstatic int verbose;\n\nstatic int eprintf(int level, int var, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret = 0;\n\n\tif (var >= level) {\n\t\tva_start(args, fmt);\n\t\tret = vfprintf(stderr, fmt, args);\n\t\tva_end(args);\n\t}\n\treturn ret;\n}\n\n#ifndef pr_fmt\n#define pr_fmt(fmt) fmt\n#endif\n\n#define pr_debug(fmt, ...) \\\n\teprintf(1, verbose, pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_debugN(n, fmt, ...) \\\n\teprintf(n, verbose, pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_debug2(fmt, ...) pr_debugN(2, pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_err(fmt, ...) \\\n\teprintf(0, verbose, pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_info(fmt, ...) \\\n\teprintf(0, verbose, pr_fmt(fmt), ##__VA_ARGS__)\n\nstatic bool is_btf_id(const char *name)\n{\n\treturn name && !strncmp(name, BTF_ID, sizeof(BTF_ID) - 1);\n}\n\nstatic struct btf_id *btf_id__find(struct rb_root *root, const char *name)\n{\n\tstruct rb_node *p = root->rb_node;\n\tstruct btf_id *id;\n\tint cmp;\n\n\twhile (p) {\n\t\tid = rb_entry(p, struct btf_id, rb_node);\n\t\tcmp = strcmp(id->name, name);\n\t\tif (cmp < 0)\n\t\t\tp = p->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn id;\n\t}\n\treturn NULL;\n}\n\nstatic struct btf_id *\nbtf_id__add(struct rb_root *root, char *name, bool unique)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btf_id *id;\n\tint cmp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tid = rb_entry(parent, struct btf_id, rb_node);\n\t\tcmp = strcmp(id->name, name);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn unique ? NULL : id;\n\t}\n\n\tid = zalloc(sizeof(*id));\n\tif (id) {\n\t\tpr_debug(\"adding symbol %s\\n\", name);\n\t\tid->name = name;\n\t\trb_link_node(&id->rb_node, parent, p);\n\t\trb_insert_color(&id->rb_node, root);\n\t}\n\treturn id;\n}\n\nstatic char *get_id(const char *prefix_end)\n{\n\t \n\tint len = strlen(prefix_end);\n\tint pos = sizeof(\"__\") - 1;\n\tchar *p, *id;\n\n\tif (pos >= len)\n\t\treturn NULL;\n\n\tid = strdup(prefix_end + pos);\n\tif (id) {\n\t\t \n\t\tp = strrchr(id, '_');\n\t\tp--;\n\t\tif (*p != '_') {\n\t\t\tfree(id);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\treturn id;\n}\n\nstatic struct btf_id *add_set(struct object *obj, char *name, bool is_set8)\n{\n\t \n\tchar *id = name + (is_set8 ? sizeof(BTF_SET8 \"__\") : sizeof(BTF_SET \"__\")) - 1;\n\tint len = strlen(name);\n\n\tif (id >= name + len) {\n\t\tpr_err(\"FAILED to parse set name: %s\\n\", name);\n\t\treturn NULL;\n\t}\n\n\treturn btf_id__add(&obj->sets, id, true);\n}\n\nstatic struct btf_id *add_symbol(struct rb_root *root, char *name, size_t size)\n{\n\tchar *id;\n\n\tid = get_id(name + size);\n\tif (!id) {\n\t\tpr_err(\"FAILED to parse symbol name: %s\\n\", name);\n\t\treturn NULL;\n\t}\n\n\treturn btf_id__add(root, id, false);\n}\n\n \n#ifndef SHF_COMPRESSED\n#define SHF_COMPRESSED (1 << 11)  \n#endif\n\n \nstatic int compressed_section_fix(Elf *elf, Elf_Scn *scn, GElf_Shdr *sh)\n{\n\tint expected = gelf_getclass(elf) == ELFCLASS32 ? 4 : 8;\n\n\tif (!(sh->sh_flags & SHF_COMPRESSED))\n\t\treturn 0;\n\n\tif (sh->sh_addralign == expected)\n\t\treturn 0;\n\n\tpr_debug2(\" - fixing wrong alignment sh_addralign %u, expected %u\\n\",\n\t\t  sh->sh_addralign, expected);\n\n\tsh->sh_addralign = expected;\n\n\tif (gelf_update_shdr(scn, sh) == 0) {\n\t\tpr_err(\"FAILED cannot update section header: %s\\n\",\n\t\t\telf_errmsg(-1));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int elf_collect(struct object *obj)\n{\n\tElf_Scn *scn = NULL;\n\tsize_t shdrstrndx;\n\tint idx = 0;\n\tElf *elf;\n\tint fd;\n\n\tfd = open(obj->path, O_RDWR, 0666);\n\tif (fd == -1) {\n\t\tpr_err(\"FAILED cannot open %s: %s\\n\",\n\t\t\tobj->path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\telf_version(EV_CURRENT);\n\n\telf = elf_begin(fd, ELF_C_RDWR_MMAP, NULL);\n\tif (!elf) {\n\t\tclose(fd);\n\t\tpr_err(\"FAILED cannot create ELF descriptor: %s\\n\",\n\t\t\telf_errmsg(-1));\n\t\treturn -1;\n\t}\n\n\tobj->efile.fd  = fd;\n\tobj->efile.elf = elf;\n\n\telf_flagelf(elf, ELF_C_SET, ELF_F_LAYOUT);\n\n\tif (elf_getshdrstrndx(elf, &shdrstrndx) != 0) {\n\t\tpr_err(\"FAILED cannot get shdr str ndx\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tElf_Data *data;\n\t\tGElf_Shdr sh;\n\t\tchar *name;\n\n\t\tidx++;\n\t\tif (gelf_getshdr(scn, &sh) != &sh) {\n\t\t\tpr_err(\"FAILED get section(%d) header\\n\", idx);\n\t\t\treturn -1;\n\t\t}\n\n\t\tname = elf_strptr(elf, shdrstrndx, sh.sh_name);\n\t\tif (!name) {\n\t\t\tpr_err(\"FAILED get section(%d) name\\n\", idx);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = elf_getdata(scn, 0);\n\t\tif (!data) {\n\t\t\tpr_err(\"FAILED to get section(%d) data from %s\\n\",\n\t\t\t\tidx, name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug2(\"section(%d) %s, size %ld, link %d, flags %lx, type=%d\\n\",\n\t\t\t  idx, name, (unsigned long) data->d_size,\n\t\t\t  (int) sh.sh_link, (unsigned long) sh.sh_flags,\n\t\t\t  (int) sh.sh_type);\n\n\t\tif (sh.sh_type == SHT_SYMTAB) {\n\t\t\tobj->efile.symbols       = data;\n\t\t\tobj->efile.symbols_shndx = idx;\n\t\t\tobj->efile.strtabidx     = sh.sh_link;\n\t\t} else if (!strcmp(name, BTF_IDS_SECTION)) {\n\t\t\tobj->efile.idlist       = data;\n\t\t\tobj->efile.idlist_shndx = idx;\n\t\t\tobj->efile.idlist_addr  = sh.sh_addr;\n\t\t}\n\n\t\tif (compressed_section_fix(elf, scn, &sh))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int symbols_collect(struct object *obj)\n{\n\tElf_Scn *scn = NULL;\n\tint n, i;\n\tGElf_Shdr sh;\n\tchar *name;\n\n\tscn = elf_getscn(obj->efile.elf, obj->efile.symbols_shndx);\n\tif (!scn)\n\t\treturn -1;\n\n\tif (gelf_getshdr(scn, &sh) != &sh)\n\t\treturn -1;\n\n\tn = sh.sh_size / sh.sh_entsize;\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tchar *prefix;\n\t\tstruct btf_id *id;\n\t\tGElf_Sym sym;\n\n\t\tif (!gelf_getsym(obj->efile.symbols, i, &sym))\n\t\t\treturn -1;\n\n\t\tif (sym.st_shndx != obj->efile.idlist_shndx)\n\t\t\tcontinue;\n\n\t\tname = elf_strptr(obj->efile.elf, obj->efile.strtabidx,\n\t\t\t\t  sym.st_name);\n\n\t\tif (!is_btf_id(name))\n\t\t\tcontinue;\n\n\t\t \n\t\tprefix = name + sizeof(BTF_ID) - 1;\n\n\t\t \n\t\tif (!strncmp(prefix, BTF_STRUCT, sizeof(BTF_STRUCT) - 1)) {\n\t\t\tobj->nr_structs++;\n\t\t\tid = add_symbol(&obj->structs, prefix, sizeof(BTF_STRUCT) - 1);\n\t\t \n\t\t} else if (!strncmp(prefix, BTF_UNION, sizeof(BTF_UNION) - 1)) {\n\t\t\tobj->nr_unions++;\n\t\t\tid = add_symbol(&obj->unions, prefix, sizeof(BTF_UNION) - 1);\n\t\t \n\t\t} else if (!strncmp(prefix, BTF_TYPEDEF, sizeof(BTF_TYPEDEF) - 1)) {\n\t\t\tobj->nr_typedefs++;\n\t\t\tid = add_symbol(&obj->typedefs, prefix, sizeof(BTF_TYPEDEF) - 1);\n\t\t \n\t\t} else if (!strncmp(prefix, BTF_FUNC, sizeof(BTF_FUNC) - 1)) {\n\t\t\tobj->nr_funcs++;\n\t\t\tid = add_symbol(&obj->funcs, prefix, sizeof(BTF_FUNC) - 1);\n\t\t \n\t\t} else if (!strncmp(prefix, BTF_SET8, sizeof(BTF_SET8) - 1)) {\n\t\t\tid = add_set(obj, prefix, true);\n\t\t\t \n\t\t\tif (id) {\n\t\t\t\tid->cnt = sym.st_size / sizeof(uint64_t) - 1;\n\t\t\t\tid->is_set8 = true;\n\t\t\t}\n\t\t \n\t\t} else if (!strncmp(prefix, BTF_SET, sizeof(BTF_SET) - 1)) {\n\t\t\tid = add_set(obj, prefix, false);\n\t\t\t \n\t\t\tif (id) {\n\t\t\t\tid->cnt = sym.st_size / sizeof(int) - 1;\n\t\t\t\tid->is_set = true;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"FAILED unsupported prefix %s\\n\", prefix);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!id)\n\t\t\treturn -ENOMEM;\n\n\t\tif (id->addr_cnt >= ADDR_CNT) {\n\t\t\tpr_err(\"FAILED symbol %s crossed the number of allowed lists\\n\",\n\t\t\t\tid->name);\n\t\t\treturn -1;\n\t\t}\n\t\tid->addr[id->addr_cnt++] = sym.st_value;\n\t}\n\n\treturn 0;\n}\n\nstatic int symbols_resolve(struct object *obj)\n{\n\tint nr_typedefs = obj->nr_typedefs;\n\tint nr_structs  = obj->nr_structs;\n\tint nr_unions   = obj->nr_unions;\n\tint nr_funcs    = obj->nr_funcs;\n\tstruct btf *base_btf = NULL;\n\tint err, type_id;\n\tstruct btf *btf;\n\t__u32 nr_types;\n\n\tif (obj->base_btf_path) {\n\t\tbase_btf = btf__parse(obj->base_btf_path, NULL);\n\t\terr = libbpf_get_error(base_btf);\n\t\tif (err) {\n\t\t\tpr_err(\"FAILED: load base BTF from %s: %s\\n\",\n\t\t\t       obj->base_btf_path, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbtf = btf__parse_split(obj->btf ?: obj->path, base_btf);\n\terr = libbpf_get_error(btf);\n\tif (err) {\n\t\tpr_err(\"FAILED: load BTF from %s: %s\\n\",\n\t\t\tobj->btf ?: obj->path, strerror(-err));\n\t\tgoto out;\n\t}\n\n\terr = -1;\n\tnr_types = btf__type_cnt(btf);\n\n\t \n\tfor (type_id = 1; type_id < nr_types; type_id++) {\n\t\tconst struct btf_type *type;\n\t\tstruct rb_root *root;\n\t\tstruct btf_id *id;\n\t\tconst char *str;\n\t\tint *nr;\n\n\t\ttype = btf__type_by_id(btf, type_id);\n\t\tif (!type) {\n\t\t\tpr_err(\"FAILED: malformed BTF, can't resolve type for ID %d\\n\",\n\t\t\t\ttype_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (btf_is_func(type) && nr_funcs) {\n\t\t\tnr   = &nr_funcs;\n\t\t\troot = &obj->funcs;\n\t\t} else if (btf_is_struct(type) && nr_structs) {\n\t\t\tnr   = &nr_structs;\n\t\t\troot = &obj->structs;\n\t\t} else if (btf_is_union(type) && nr_unions) {\n\t\t\tnr   = &nr_unions;\n\t\t\troot = &obj->unions;\n\t\t} else if (btf_is_typedef(type) && nr_typedefs) {\n\t\t\tnr   = &nr_typedefs;\n\t\t\troot = &obj->typedefs;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tstr = btf__name_by_offset(btf, type->name_off);\n\t\tif (!str) {\n\t\t\tpr_err(\"FAILED: malformed BTF, can't resolve name for ID %d\\n\",\n\t\t\t\ttype_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tid = btf_id__find(root, str);\n\t\tif (id) {\n\t\t\tif (id->id) {\n\t\t\t\tpr_info(\"WARN: multiple IDs found for '%s': %d, %d - using %d\\n\",\n\t\t\t\t\tstr, id->id, type_id, id->id);\n\t\t\t} else {\n\t\t\t\tid->id = type_id;\n\t\t\t\t(*nr)--;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\tbtf__free(base_btf);\n\tbtf__free(btf);\n\treturn err;\n}\n\nstatic int id_patch(struct object *obj, struct btf_id *id)\n{\n\tElf_Data *data = obj->efile.idlist;\n\tint *ptr = data->d_buf;\n\tint i;\n\n\t \n\tif (!id->id && !id->is_set && !id->is_set8)\n\t\tpr_err(\"WARN: resolve_btfids: unresolved symbol %s\\n\", id->name);\n\n\tfor (i = 0; i < id->addr_cnt; i++) {\n\t\tunsigned long addr = id->addr[i];\n\t\tunsigned long idx = addr - obj->efile.idlist_addr;\n\n\t\tpr_debug(\"patching addr %5lu: ID %7d [%s]\\n\",\n\t\t\t idx, id->id, id->name);\n\n\t\tif (idx >= data->d_size) {\n\t\t\tpr_err(\"FAILED patching index %lu out of bounds %lu\\n\",\n\t\t\t\tidx, data->d_size);\n\t\t\treturn -1;\n\t\t}\n\n\t\tidx = idx / sizeof(int);\n\t\tptr[idx] = id->id;\n\t}\n\n\treturn 0;\n}\n\nstatic int __symbols_patch(struct object *obj, struct rb_root *root)\n{\n\tstruct rb_node *next;\n\tstruct btf_id *id;\n\n\tnext = rb_first(root);\n\twhile (next) {\n\t\tid = rb_entry(next, struct btf_id, rb_node);\n\n\t\tif (id_patch(obj, id))\n\t\t\treturn -1;\n\n\t\tnext = rb_next(next);\n\t}\n\treturn 0;\n}\n\nstatic int cmp_id(const void *pa, const void *pb)\n{\n\tconst int *a = pa, *b = pb;\n\n\treturn *a - *b;\n}\n\nstatic int sets_patch(struct object *obj)\n{\n\tElf_Data *data = obj->efile.idlist;\n\tint *ptr = data->d_buf;\n\tstruct rb_node *next;\n\n\tnext = rb_first(&obj->sets);\n\twhile (next) {\n\t\tunsigned long addr, idx;\n\t\tstruct btf_id *id;\n\t\tint *base;\n\t\tint cnt;\n\n\t\tid   = rb_entry(next, struct btf_id, rb_node);\n\t\taddr = id->addr[0];\n\t\tidx  = addr - obj->efile.idlist_addr;\n\n\t\t \n\t\tif (id->addr_cnt != 1) {\n\t\t\tpr_err(\"FAILED malformed data for set '%s'\\n\",\n\t\t\t\tid->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tidx = idx / sizeof(int);\n\t\tbase = &ptr[idx] + (id->is_set8 ? 2 : 1);\n\t\tcnt = ptr[idx];\n\n\t\tpr_debug(\"sorting  addr %5lu: cnt %6d [%s]\\n\",\n\t\t\t (idx + 1) * sizeof(int), cnt, id->name);\n\n\t\tqsort(base, cnt, id->is_set8 ? sizeof(uint64_t) : sizeof(int), cmp_id);\n\n\t\tnext = rb_next(next);\n\t}\n\treturn 0;\n}\n\nstatic int symbols_patch(struct object *obj)\n{\n\tint err;\n\n\tif (__symbols_patch(obj, &obj->structs)  ||\n\t    __symbols_patch(obj, &obj->unions)   ||\n\t    __symbols_patch(obj, &obj->typedefs) ||\n\t    __symbols_patch(obj, &obj->funcs)    ||\n\t    __symbols_patch(obj, &obj->sets))\n\t\treturn -1;\n\n\tif (sets_patch(obj))\n\t\treturn -1;\n\n\t \n\tobj->efile.idlist->d_type = ELF_T_WORD;\n\n\telf_flagdata(obj->efile.idlist, ELF_C_SET, ELF_F_DIRTY);\n\n\terr = elf_update(obj->efile.elf, ELF_C_WRITE);\n\tif (err < 0) {\n\t\tpr_err(\"FAILED elf_update(WRITE): %s\\n\",\n\t\t\telf_errmsg(-1));\n\t}\n\n\tpr_debug(\"update %s for %s\\n\",\n\t\t err >= 0 ? \"ok\" : \"failed\", obj->path);\n\treturn err < 0 ? -1 : 0;\n}\n\nstatic const char * const resolve_btfids_usage[] = {\n\t\"resolve_btfids [<options>] <ELF object>\",\n\tNULL\n};\n\nint main(int argc, const char **argv)\n{\n\tstruct object obj = {\n\t\t.efile = {\n\t\t\t.idlist_shndx  = -1,\n\t\t\t.symbols_shndx = -1,\n\t\t},\n\t\t.structs  = RB_ROOT,\n\t\t.unions   = RB_ROOT,\n\t\t.typedefs = RB_ROOT,\n\t\t.funcs    = RB_ROOT,\n\t\t.sets     = RB_ROOT,\n\t};\n\tstruct option btfid_options[] = {\n\t\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t\t \"be more verbose (show errors, etc)\"),\n\t\tOPT_STRING(0, \"btf\", &obj.btf, \"BTF data\",\n\t\t\t   \"BTF data\"),\n\t\tOPT_STRING('b', \"btf_base\", &obj.base_btf_path, \"file\",\n\t\t\t   \"path of file providing base BTF\"),\n\t\tOPT_END()\n\t};\n\tint err = -1;\n\n\targc = parse_options(argc, argv, btfid_options, resolve_btfids_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\tif (argc != 1)\n\t\tusage_with_options(resolve_btfids_usage, btfid_options);\n\n\tobj.path = argv[0];\n\n\tif (elf_collect(&obj))\n\t\tgoto out;\n\n\t \n\tif (obj.efile.idlist_shndx == -1 ||\n\t    obj.efile.symbols_shndx == -1) {\n\t\tpr_debug(\"Cannot find .BTF_ids or symbols sections, nothing to do\\n\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (symbols_collect(&obj))\n\t\tgoto out;\n\n\tif (symbols_resolve(&obj))\n\t\tgoto out;\n\n\tif (symbols_patch(&obj))\n\t\tgoto out;\n\n\terr = 0;\nout:\n\tif (obj.efile.elf) {\n\t\telf_end(obj.efile.elf);\n\t\tclose(obj.efile.fd);\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}