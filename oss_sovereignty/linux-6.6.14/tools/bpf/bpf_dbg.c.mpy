{
  "module_name": "bpf_dbg.c",
  "hash_id": "2157001ea45151425534ce21d9ad9bc6021a1ad5450edd8aaf323158b70579af",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpf_dbg.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <setjmp.h>\n#include <linux/filter.h>\n#include <linux/if_packet.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <arpa/inet.h>\n#include <net/ethernet.h>\n\n#define TCPDUMP_MAGIC\t0xa1b2c3d4\n\n#define BPF_LDX_B\t(BPF_LDX | BPF_B)\n#define BPF_LDX_W\t(BPF_LDX | BPF_W)\n#define BPF_JMP_JA\t(BPF_JMP | BPF_JA)\n#define BPF_JMP_JEQ\t(BPF_JMP | BPF_JEQ)\n#define BPF_JMP_JGT\t(BPF_JMP | BPF_JGT)\n#define BPF_JMP_JGE\t(BPF_JMP | BPF_JGE)\n#define BPF_JMP_JSET\t(BPF_JMP | BPF_JSET)\n#define BPF_ALU_ADD\t(BPF_ALU | BPF_ADD)\n#define BPF_ALU_SUB\t(BPF_ALU | BPF_SUB)\n#define BPF_ALU_MUL\t(BPF_ALU | BPF_MUL)\n#define BPF_ALU_DIV\t(BPF_ALU | BPF_DIV)\n#define BPF_ALU_MOD\t(BPF_ALU | BPF_MOD)\n#define BPF_ALU_NEG\t(BPF_ALU | BPF_NEG)\n#define BPF_ALU_AND\t(BPF_ALU | BPF_AND)\n#define BPF_ALU_OR\t(BPF_ALU | BPF_OR)\n#define BPF_ALU_XOR\t(BPF_ALU | BPF_XOR)\n#define BPF_ALU_LSH\t(BPF_ALU | BPF_LSH)\n#define BPF_ALU_RSH\t(BPF_ALU | BPF_RSH)\n#define BPF_MISC_TAX\t(BPF_MISC | BPF_TAX)\n#define BPF_MISC_TXA\t(BPF_MISC | BPF_TXA)\n#define BPF_LD_B\t(BPF_LD | BPF_B)\n#define BPF_LD_H\t(BPF_LD | BPF_H)\n#define BPF_LD_W\t(BPF_LD | BPF_W)\n\n#ifndef array_size\n# define array_size(x)\t(sizeof(x) / sizeof((x)[0]))\n#endif\n\n#ifndef __check_format_printf\n# define __check_format_printf(pos_fmtstr, pos_fmtargs) \\\n\t__attribute__ ((format (printf, (pos_fmtstr), (pos_fmtargs))))\n#endif\n\nenum {\n\tCMD_OK,\n\tCMD_ERR,\n\tCMD_EX,\n};\n\nstruct shell_cmd {\n\tconst char *name;\n\tint (*func)(char *args);\n};\n\nstruct pcap_filehdr {\n\tuint32_t magic;\n\tuint16_t version_major;\n\tuint16_t version_minor;\n\tint32_t  thiszone;\n\tuint32_t sigfigs;\n\tuint32_t snaplen;\n\tuint32_t linktype;\n};\n\nstruct pcap_timeval {\n\tint32_t tv_sec;\n\tint32_t tv_usec;\n};\n\nstruct pcap_pkthdr {\n\tstruct pcap_timeval ts;\n\tuint32_t caplen;\n\tuint32_t len;\n};\n\nstruct bpf_regs {\n\tuint32_t A;\n\tuint32_t X;\n\tuint32_t M[BPF_MEMWORDS];\n\tuint32_t R;\n\tbool     Rs;\n\tuint16_t Pc;\n};\n\nstatic struct sock_filter bpf_image[BPF_MAXINSNS + 1];\nstatic unsigned int bpf_prog_len;\n\nstatic int bpf_breakpoints[64];\nstatic struct bpf_regs bpf_regs[BPF_MAXINSNS + 1];\nstatic struct bpf_regs bpf_curr;\nstatic unsigned int bpf_regs_len;\n\nstatic int pcap_fd = -1;\nstatic unsigned int pcap_packet;\nstatic size_t pcap_map_size;\nstatic char *pcap_ptr_va_start, *pcap_ptr_va_curr;\n\nstatic const char * const op_table[] = {\n\t[BPF_ST]\t= \"st\",\n\t[BPF_STX]\t= \"stx\",\n\t[BPF_LD_B]\t= \"ldb\",\n\t[BPF_LD_H]\t= \"ldh\",\n\t[BPF_LD_W]\t= \"ld\",\n\t[BPF_LDX]\t= \"ldx\",\n\t[BPF_LDX_B]\t= \"ldxb\",\n\t[BPF_JMP_JA]\t= \"ja\",\n\t[BPF_JMP_JEQ]\t= \"jeq\",\n\t[BPF_JMP_JGT]\t= \"jgt\",\n\t[BPF_JMP_JGE]\t= \"jge\",\n\t[BPF_JMP_JSET]\t= \"jset\",\n\t[BPF_ALU_ADD]\t= \"add\",\n\t[BPF_ALU_SUB]\t= \"sub\",\n\t[BPF_ALU_MUL]\t= \"mul\",\n\t[BPF_ALU_DIV]\t= \"div\",\n\t[BPF_ALU_MOD]\t= \"mod\",\n\t[BPF_ALU_NEG]\t= \"neg\",\n\t[BPF_ALU_AND]\t= \"and\",\n\t[BPF_ALU_OR]\t= \"or\",\n\t[BPF_ALU_XOR]\t= \"xor\",\n\t[BPF_ALU_LSH]\t= \"lsh\",\n\t[BPF_ALU_RSH]\t= \"rsh\",\n\t[BPF_MISC_TAX]\t= \"tax\",\n\t[BPF_MISC_TXA]\t= \"txa\",\n\t[BPF_RET]\t= \"ret\",\n};\n\nstatic __check_format_printf(1, 2) int rl_printf(const char *fmt, ...)\n{\n\tint ret;\n\tva_list vl;\n\n\tva_start(vl, fmt);\n\tret = vfprintf(rl_outstream, fmt, vl);\n\tva_end(vl);\n\n\treturn ret;\n}\n\nstatic int matches(const char *cmd, const char *pattern)\n{\n\tint len = strlen(cmd);\n\n\tif (len > strlen(pattern))\n\t\treturn -1;\n\n\treturn memcmp(pattern, cmd, len);\n}\n\nstatic void hex_dump(const uint8_t *buf, size_t len)\n{\n\tint i;\n\n\trl_printf(\"%3u: \", 0);\n\tfor (i = 0; i < len; i++) {\n\t\tif (i && !(i % 16))\n\t\t\trl_printf(\"\\n%3u: \", i);\n\t\trl_printf(\"%02x \", buf[i]);\n\t}\n\trl_printf(\"\\n\");\n}\n\nstatic bool bpf_prog_loaded(void)\n{\n\tif (bpf_prog_len == 0)\n\t\trl_printf(\"no bpf program loaded!\\n\");\n\n\treturn bpf_prog_len > 0;\n}\n\nstatic void bpf_disasm(const struct sock_filter f, unsigned int i)\n{\n\tconst char *op, *fmt;\n\tint val = f.k;\n\tchar buf[256];\n\n\tswitch (f.code) {\n\tcase BPF_RET | BPF_K:\n\t\top = op_table[BPF_RET];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_RET | BPF_A:\n\t\top = op_table[BPF_RET];\n\t\tfmt = \"a\";\n\t\tbreak;\n\tcase BPF_RET | BPF_X:\n\t\top = op_table[BPF_RET];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_MISC_TAX:\n\t\top = op_table[BPF_MISC_TAX];\n\t\tfmt = \"\";\n\t\tbreak;\n\tcase BPF_MISC_TXA:\n\t\top = op_table[BPF_MISC_TXA];\n\t\tfmt = \"\";\n\t\tbreak;\n\tcase BPF_ST:\n\t\top = op_table[BPF_ST];\n\t\tfmt = \"M[%d]\";\n\t\tbreak;\n\tcase BPF_STX:\n\t\top = op_table[BPF_STX];\n\t\tfmt = \"M[%d]\";\n\t\tbreak;\n\tcase BPF_LD_W | BPF_ABS:\n\t\top = op_table[BPF_LD_W];\n\t\tfmt = \"[%d]\";\n\t\tbreak;\n\tcase BPF_LD_H | BPF_ABS:\n\t\top = op_table[BPF_LD_H];\n\t\tfmt = \"[%d]\";\n\t\tbreak;\n\tcase BPF_LD_B | BPF_ABS:\n\t\top = op_table[BPF_LD_B];\n\t\tfmt = \"[%d]\";\n\t\tbreak;\n\tcase BPF_LD_W | BPF_LEN:\n\t\top = op_table[BPF_LD_W];\n\t\tfmt = \"#len\";\n\t\tbreak;\n\tcase BPF_LD_W | BPF_IND:\n\t\top = op_table[BPF_LD_W];\n\t\tfmt = \"[x+%d]\";\n\t\tbreak;\n\tcase BPF_LD_H | BPF_IND:\n\t\top = op_table[BPF_LD_H];\n\t\tfmt = \"[x+%d]\";\n\t\tbreak;\n\tcase BPF_LD_B | BPF_IND:\n\t\top = op_table[BPF_LD_B];\n\t\tfmt = \"[x+%d]\";\n\t\tbreak;\n\tcase BPF_LD | BPF_IMM:\n\t\top = op_table[BPF_LD_W];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_LDX | BPF_IMM:\n\t\top = op_table[BPF_LDX];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_LDX_B | BPF_MSH:\n\t\top = op_table[BPF_LDX_B];\n\t\tfmt = \"4*([%d]&0xf)\";\n\t\tbreak;\n\tcase BPF_LD | BPF_MEM:\n\t\top = op_table[BPF_LD_W];\n\t\tfmt = \"M[%d]\";\n\t\tbreak;\n\tcase BPF_LDX | BPF_MEM:\n\t\top = op_table[BPF_LDX];\n\t\tfmt = \"M[%d]\";\n\t\tbreak;\n\tcase BPF_JMP_JA:\n\t\top = op_table[BPF_JMP_JA];\n\t\tfmt = \"%d\";\n\t\tval = i + 1 + f.k;\n\t\tbreak;\n\tcase BPF_JMP_JGT | BPF_X:\n\t\top = op_table[BPF_JMP_JGT];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_JMP_JGT | BPF_K:\n\t\top = op_table[BPF_JMP_JGT];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_JMP_JGE | BPF_X:\n\t\top = op_table[BPF_JMP_JGE];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_JMP_JGE | BPF_K:\n\t\top = op_table[BPF_JMP_JGE];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_JMP_JEQ | BPF_X:\n\t\top = op_table[BPF_JMP_JEQ];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_JMP_JEQ | BPF_K:\n\t\top = op_table[BPF_JMP_JEQ];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_JMP_JSET | BPF_X:\n\t\top = op_table[BPF_JMP_JSET];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_JMP_JSET | BPF_K:\n\t\top = op_table[BPF_JMP_JSET];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_ALU_NEG:\n\t\top = op_table[BPF_ALU_NEG];\n\t\tfmt = \"\";\n\t\tbreak;\n\tcase BPF_ALU_LSH | BPF_X:\n\t\top = op_table[BPF_ALU_LSH];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_LSH | BPF_K:\n\t\top = op_table[BPF_ALU_LSH];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_RSH | BPF_X:\n\t\top = op_table[BPF_ALU_RSH];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_RSH | BPF_K:\n\t\top = op_table[BPF_ALU_RSH];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_ADD | BPF_X:\n\t\top = op_table[BPF_ALU_ADD];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_ADD | BPF_K:\n\t\top = op_table[BPF_ALU_ADD];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_SUB | BPF_X:\n\t\top = op_table[BPF_ALU_SUB];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_SUB | BPF_K:\n\t\top = op_table[BPF_ALU_SUB];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_MUL | BPF_X:\n\t\top = op_table[BPF_ALU_MUL];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_MUL | BPF_K:\n\t\top = op_table[BPF_ALU_MUL];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_DIV | BPF_X:\n\t\top = op_table[BPF_ALU_DIV];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_DIV | BPF_K:\n\t\top = op_table[BPF_ALU_DIV];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_MOD | BPF_X:\n\t\top = op_table[BPF_ALU_MOD];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_MOD | BPF_K:\n\t\top = op_table[BPF_ALU_MOD];\n\t\tfmt = \"#%d\";\n\t\tbreak;\n\tcase BPF_ALU_AND | BPF_X:\n\t\top = op_table[BPF_ALU_AND];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_AND | BPF_K:\n\t\top = op_table[BPF_ALU_AND];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_ALU_OR | BPF_X:\n\t\top = op_table[BPF_ALU_OR];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_OR | BPF_K:\n\t\top = op_table[BPF_ALU_OR];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tcase BPF_ALU_XOR | BPF_X:\n\t\top = op_table[BPF_ALU_XOR];\n\t\tfmt = \"x\";\n\t\tbreak;\n\tcase BPF_ALU_XOR | BPF_K:\n\t\top = op_table[BPF_ALU_XOR];\n\t\tfmt = \"#%#x\";\n\t\tbreak;\n\tdefault:\n\t\top = \"nosup\";\n\t\tfmt = \"%#x\";\n\t\tval = f.code;\n\t\tbreak;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tsnprintf(buf, sizeof(buf), fmt, val);\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tif ((BPF_CLASS(f.code) == BPF_JMP && BPF_OP(f.code) != BPF_JA))\n\t\trl_printf(\"l%d:\\t%s %s, l%d, l%d\\n\", i, op, buf,\n\t\t\t  i + 1 + f.jt, i + 1 + f.jf);\n\telse\n\t\trl_printf(\"l%d:\\t%s %s\\n\", i, op, buf);\n}\n\nstatic void bpf_dump_curr(struct bpf_regs *r, struct sock_filter *f)\n{\n\tint i, m = 0;\n\n\trl_printf(\"pc:       [%u]\\n\", r->Pc);\n\trl_printf(\"code:     [%u] jt[%u] jf[%u] k[%u]\\n\",\n\t\t  f->code, f->jt, f->jf, f->k);\n\trl_printf(\"curr:     \");\n\tbpf_disasm(*f, r->Pc);\n\n\tif (f->jt || f->jf) {\n\t\trl_printf(\"jt:       \");\n\t\tbpf_disasm(*(f + f->jt + 1), r->Pc + f->jt + 1);\n\t\trl_printf(\"jf:       \");\n\t\tbpf_disasm(*(f + f->jf + 1), r->Pc + f->jf + 1);\n\t}\n\n\trl_printf(\"A:        [%#08x][%u]\\n\", r->A, r->A);\n\trl_printf(\"X:        [%#08x][%u]\\n\", r->X, r->X);\n\tif (r->Rs)\n\t\trl_printf(\"ret:      [%#08x][%u]!\\n\", r->R, r->R);\n\n\tfor (i = 0; i < BPF_MEMWORDS; i++) {\n\t\tif (r->M[i]) {\n\t\t\tm++;\n\t\t\trl_printf(\"M[%d]: [%#08x][%u]\\n\", i, r->M[i], r->M[i]);\n\t\t}\n\t}\n\tif (m == 0)\n\t\trl_printf(\"M[0,%d]:  [%#08x][%u]\\n\", BPF_MEMWORDS - 1, 0, 0);\n}\n\nstatic void bpf_dump_pkt(uint8_t *pkt, uint32_t pkt_caplen, uint32_t pkt_len)\n{\n\tif (pkt_caplen != pkt_len)\n\t\trl_printf(\"cap: %u, len: %u\\n\", pkt_caplen, pkt_len);\n\telse\n\t\trl_printf(\"len: %u\\n\", pkt_len);\n\n\thex_dump(pkt, pkt_caplen);\n}\n\nstatic void bpf_disasm_all(const struct sock_filter *f, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbpf_disasm(f[i], i);\n}\n\nstatic void bpf_dump_all(const struct sock_filter *f, unsigned int len)\n{\n\tunsigned int i;\n\n\trl_printf(\"/* { op, jt, jf, k }, */\\n\");\n\tfor (i = 0; i < len; i++)\n\t\trl_printf(\"{ %#04x, %2u, %2u, %#010x },\\n\",\n\t\t\t  f[i].code, f[i].jt, f[i].jf, f[i].k);\n}\n\nstatic bool bpf_runnable(struct sock_filter *f, unsigned int len)\n{\n\tint sock, ret, i;\n\tstruct sock_fprog bpf = {\n\t\t.filter = f,\n\t\t.len = len,\n\t};\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock < 0) {\n\t\trl_printf(\"cannot open socket!\\n\");\n\t\treturn false;\n\t}\n\tret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf));\n\tclose(sock);\n\tif (ret < 0) {\n\t\trl_printf(\"program not allowed to run by kernel!\\n\");\n\t\treturn false;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (BPF_CLASS(f[i].code) == BPF_LD &&\n\t\t    f[i].k > SKF_AD_OFF) {\n\t\t\trl_printf(\"extensions currently not supported!\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void bpf_reset_breakpoints(void)\n{\n\tint i;\n\n\tfor (i = 0; i < array_size(bpf_breakpoints); i++)\n\t\tbpf_breakpoints[i] = -1;\n}\n\nstatic void bpf_set_breakpoints(unsigned int where)\n{\n\tint i;\n\tbool set = false;\n\n\tfor (i = 0; i < array_size(bpf_breakpoints); i++) {\n\t\tif (bpf_breakpoints[i] == (int) where) {\n\t\t\trl_printf(\"breakpoint already set!\\n\");\n\t\t\tset = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bpf_breakpoints[i] == -1 && set == false) {\n\t\t\tbpf_breakpoints[i] = where;\n\t\t\tset = true;\n\t\t}\n\t}\n\n\tif (!set)\n\t\trl_printf(\"too many breakpoints set, reset first!\\n\");\n}\n\nstatic void bpf_dump_breakpoints(void)\n{\n\tint i;\n\n\trl_printf(\"breakpoints: \");\n\n\tfor (i = 0; i < array_size(bpf_breakpoints); i++) {\n\t\tif (bpf_breakpoints[i] < 0)\n\t\t\tcontinue;\n\t\trl_printf(\"%d \", bpf_breakpoints[i]);\n\t}\n\n\trl_printf(\"\\n\");\n}\n\nstatic void bpf_reset(void)\n{\n\tbpf_regs_len = 0;\n\n\tmemset(bpf_regs, 0, sizeof(bpf_regs));\n\tmemset(&bpf_curr, 0, sizeof(bpf_curr));\n}\n\nstatic void bpf_safe_regs(void)\n{\n\tmemcpy(&bpf_regs[bpf_regs_len++], &bpf_curr, sizeof(bpf_curr));\n}\n\nstatic bool bpf_restore_regs(int off)\n{\n\tunsigned int index = bpf_regs_len - 1 + off;\n\n\tif (index == 0) {\n\t\tbpf_reset();\n\t\treturn true;\n\t} else if (index < bpf_regs_len) {\n\t\tmemcpy(&bpf_curr, &bpf_regs[index], sizeof(bpf_curr));\n\t\tbpf_regs_len = index;\n\t\treturn true;\n\t} else {\n\t\trl_printf(\"reached bottom of register history stack!\\n\");\n\t\treturn false;\n\t}\n}\n\nstatic uint32_t extract_u32(uint8_t *pkt, uint32_t off)\n{\n\tuint32_t r;\n\n\tmemcpy(&r, &pkt[off], sizeof(r));\n\n\treturn ntohl(r);\n}\n\nstatic uint16_t extract_u16(uint8_t *pkt, uint32_t off)\n{\n\tuint16_t r;\n\n\tmemcpy(&r, &pkt[off], sizeof(r));\n\n\treturn ntohs(r);\n}\n\nstatic uint8_t extract_u8(uint8_t *pkt, uint32_t off)\n{\n\treturn pkt[off];\n}\n\nstatic void set_return(struct bpf_regs *r)\n{\n\tr->R = 0;\n\tr->Rs = true;\n}\n\nstatic void bpf_single_step(struct bpf_regs *r, struct sock_filter *f,\n\t\t\t    uint8_t *pkt, uint32_t pkt_caplen,\n\t\t\t    uint32_t pkt_len)\n{\n\tuint32_t K = f->k;\n\tint d;\n\n\tswitch (f->code) {\n\tcase BPF_RET | BPF_K:\n\t\tr->R = K;\n\t\tr->Rs = true;\n\t\tbreak;\n\tcase BPF_RET | BPF_A:\n\t\tr->R = r->A;\n\t\tr->Rs = true;\n\t\tbreak;\n\tcase BPF_RET | BPF_X:\n\t\tr->R = r->X;\n\t\tr->Rs = true;\n\t\tbreak;\n\tcase BPF_MISC_TAX:\n\t\tr->X = r->A;\n\t\tbreak;\n\tcase BPF_MISC_TXA:\n\t\tr->A = r->X;\n\t\tbreak;\n\tcase BPF_ST:\n\t\tr->M[K] = r->A;\n\t\tbreak;\n\tcase BPF_STX:\n\t\tr->M[K] = r->X;\n\t\tbreak;\n\tcase BPF_LD_W | BPF_ABS:\n\t\td = pkt_caplen - K;\n\t\tif (d >= sizeof(uint32_t))\n\t\t\tr->A = extract_u32(pkt, K);\n\t\telse\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LD_H | BPF_ABS:\n\t\td = pkt_caplen - K;\n\t\tif (d >= sizeof(uint16_t))\n\t\t\tr->A = extract_u16(pkt, K);\n\t\telse\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LD_B | BPF_ABS:\n\t\td = pkt_caplen - K;\n\t\tif (d >= sizeof(uint8_t))\n\t\t\tr->A = extract_u8(pkt, K);\n\t\telse\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LD_W | BPF_IND:\n\t\td = pkt_caplen - (r->X + K);\n\t\tif (d >= sizeof(uint32_t))\n\t\t\tr->A = extract_u32(pkt, r->X + K);\n\t\tbreak;\n\tcase BPF_LD_H | BPF_IND:\n\t\td = pkt_caplen - (r->X + K);\n\t\tif (d >= sizeof(uint16_t))\n\t\t\tr->A = extract_u16(pkt, r->X + K);\n\t\telse\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LD_B | BPF_IND:\n\t\td = pkt_caplen - (r->X + K);\n\t\tif (d >= sizeof(uint8_t))\n\t\t\tr->A = extract_u8(pkt, r->X + K);\n\t\telse\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LDX_B | BPF_MSH:\n\t\td = pkt_caplen - K;\n\t\tif (d >= sizeof(uint8_t)) {\n\t\t\tr->X = extract_u8(pkt, K);\n\t\t\tr->X = (r->X & 0xf) << 2;\n\t\t} else\n\t\t\tset_return(r);\n\t\tbreak;\n\tcase BPF_LD_W | BPF_LEN:\n\t\tr->A = pkt_len;\n\t\tbreak;\n\tcase BPF_LDX_W | BPF_LEN:\n\t\tr->A = pkt_len;\n\t\tbreak;\n\tcase BPF_LD | BPF_IMM:\n\t\tr->A = K;\n\t\tbreak;\n\tcase BPF_LDX | BPF_IMM:\n\t\tr->X = K;\n\t\tbreak;\n\tcase BPF_LD | BPF_MEM:\n\t\tr->A = r->M[K];\n\t\tbreak;\n\tcase BPF_LDX | BPF_MEM:\n\t\tr->X = r->M[K];\n\t\tbreak;\n\tcase BPF_JMP_JA:\n\t\tr->Pc += K;\n\t\tbreak;\n\tcase BPF_JMP_JGT | BPF_X:\n\t\tr->Pc += r->A > r->X ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JGT | BPF_K:\n\t\tr->Pc += r->A > K ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JGE | BPF_X:\n\t\tr->Pc += r->A >= r->X ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JGE | BPF_K:\n\t\tr->Pc += r->A >= K ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JEQ | BPF_X:\n\t\tr->Pc += r->A == r->X ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JEQ | BPF_K:\n\t\tr->Pc += r->A == K ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JSET | BPF_X:\n\t\tr->Pc += r->A & r->X ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_JMP_JSET | BPF_K:\n\t\tr->Pc += r->A & K ? f->jt : f->jf;\n\t\tbreak;\n\tcase BPF_ALU_NEG:\n\t\tr->A = -r->A;\n\t\tbreak;\n\tcase BPF_ALU_LSH | BPF_X:\n\t\tr->A <<= r->X;\n\t\tbreak;\n\tcase BPF_ALU_LSH | BPF_K:\n\t\tr->A <<= K;\n\t\tbreak;\n\tcase BPF_ALU_RSH | BPF_X:\n\t\tr->A >>= r->X;\n\t\tbreak;\n\tcase BPF_ALU_RSH | BPF_K:\n\t\tr->A >>= K;\n\t\tbreak;\n\tcase BPF_ALU_ADD | BPF_X:\n\t\tr->A += r->X;\n\t\tbreak;\n\tcase BPF_ALU_ADD | BPF_K:\n\t\tr->A += K;\n\t\tbreak;\n\tcase BPF_ALU_SUB | BPF_X:\n\t\tr->A -= r->X;\n\t\tbreak;\n\tcase BPF_ALU_SUB | BPF_K:\n\t\tr->A -= K;\n\t\tbreak;\n\tcase BPF_ALU_MUL | BPF_X:\n\t\tr->A *= r->X;\n\t\tbreak;\n\tcase BPF_ALU_MUL | BPF_K:\n\t\tr->A *= K;\n\t\tbreak;\n\tcase BPF_ALU_DIV | BPF_X:\n\tcase BPF_ALU_MOD | BPF_X:\n\t\tif (r->X == 0) {\n\t\t\tset_return(r);\n\t\t\tbreak;\n\t\t}\n\t\tgoto do_div;\n\tcase BPF_ALU_DIV | BPF_K:\n\tcase BPF_ALU_MOD | BPF_K:\n\t\tif (K == 0) {\n\t\t\tset_return(r);\n\t\t\tbreak;\n\t\t}\ndo_div:\n\t\tswitch (f->code) {\n\t\tcase BPF_ALU_DIV | BPF_X:\n\t\t\tr->A /= r->X;\n\t\t\tbreak;\n\t\tcase BPF_ALU_DIV | BPF_K:\n\t\t\tr->A /= K;\n\t\t\tbreak;\n\t\tcase BPF_ALU_MOD | BPF_X:\n\t\t\tr->A %= r->X;\n\t\t\tbreak;\n\t\tcase BPF_ALU_MOD | BPF_K:\n\t\t\tr->A %= K;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BPF_ALU_AND | BPF_X:\n\t\tr->A &= r->X;\n\t\tbreak;\n\tcase BPF_ALU_AND | BPF_K:\n\t\tr->A &= K;\n\t\tbreak;\n\tcase BPF_ALU_OR | BPF_X:\n\t\tr->A |= r->X;\n\t\tbreak;\n\tcase BPF_ALU_OR | BPF_K:\n\t\tr->A |= K;\n\t\tbreak;\n\tcase BPF_ALU_XOR | BPF_X:\n\t\tr->A ^= r->X;\n\t\tbreak;\n\tcase BPF_ALU_XOR | BPF_K:\n\t\tr->A ^= K;\n\t\tbreak;\n\t}\n}\n\nstatic bool bpf_pc_has_breakpoint(uint16_t pc)\n{\n\tint i;\n\n\tfor (i = 0; i < array_size(bpf_breakpoints); i++) {\n\t\tif (bpf_breakpoints[i] < 0)\n\t\t\tcontinue;\n\t\tif (bpf_breakpoints[i] == pc)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool bpf_handle_breakpoint(struct bpf_regs *r, struct sock_filter *f,\n\t\t\t\t  uint8_t *pkt, uint32_t pkt_caplen,\n\t\t\t\t  uint32_t pkt_len)\n{\n\trl_printf(\"-- register dump --\\n\");\n\tbpf_dump_curr(r, &f[r->Pc]);\n\trl_printf(\"-- packet dump --\\n\");\n\tbpf_dump_pkt(pkt, pkt_caplen, pkt_len);\n\trl_printf(\"(breakpoint)\\n\");\n\treturn true;\n}\n\nstatic int bpf_run_all(struct sock_filter *f, uint16_t bpf_len, uint8_t *pkt,\n\t\t       uint32_t pkt_caplen, uint32_t pkt_len)\n{\n\tbool stop = false;\n\n\twhile (bpf_curr.Rs == false && stop == false) {\n\t\tbpf_safe_regs();\n\n\t\tif (bpf_pc_has_breakpoint(bpf_curr.Pc))\n\t\t\tstop = bpf_handle_breakpoint(&bpf_curr, f, pkt,\n\t\t\t\t\t\t     pkt_caplen, pkt_len);\n\n\t\tbpf_single_step(&bpf_curr, &f[bpf_curr.Pc], pkt, pkt_caplen,\n\t\t\t\tpkt_len);\n\t\tbpf_curr.Pc++;\n\t}\n\n\treturn stop ? -1 : bpf_curr.R;\n}\n\nstatic int bpf_run_stepping(struct sock_filter *f, uint16_t bpf_len,\n\t\t\t    uint8_t *pkt, uint32_t pkt_caplen,\n\t\t\t    uint32_t pkt_len, int next)\n{\n\tbool stop = false;\n\tint i = 1;\n\n\twhile (!bpf_curr.Rs && !stop) {\n\t\tbpf_safe_regs();\n\n\t\tif (i++ == next)\n\t\t\tstop = bpf_handle_breakpoint(&bpf_curr, f, pkt,\n\t\t\t\t\t\t     pkt_caplen, pkt_len);\n\n\t\tbpf_single_step(&bpf_curr, &f[bpf_curr.Pc], pkt, pkt_caplen,\n\t\t\t\tpkt_len);\n\t\tbpf_curr.Pc++;\n\t}\n\n\treturn stop ? -1 : bpf_curr.R;\n}\n\nstatic bool pcap_loaded(void)\n{\n\tif (pcap_fd < 0)\n\t\trl_printf(\"no pcap file loaded!\\n\");\n\n\treturn pcap_fd >= 0;\n}\n\nstatic struct pcap_pkthdr *pcap_curr_pkt(void)\n{\n\treturn (void *) pcap_ptr_va_curr;\n}\n\nstatic bool pcap_next_pkt(void)\n{\n\tstruct pcap_pkthdr *hdr = pcap_curr_pkt();\n\n\tif (pcap_ptr_va_curr + sizeof(*hdr) -\n\t    pcap_ptr_va_start >= pcap_map_size)\n\t\treturn false;\n\tif (hdr->caplen == 0 || hdr->len == 0 || hdr->caplen > hdr->len)\n\t\treturn false;\n\tif (pcap_ptr_va_curr + sizeof(*hdr) + hdr->caplen -\n\t    pcap_ptr_va_start >= pcap_map_size)\n\t\treturn false;\n\n\tpcap_ptr_va_curr += (sizeof(*hdr) + hdr->caplen);\n\treturn true;\n}\n\nstatic void pcap_reset_pkt(void)\n{\n\tpcap_ptr_va_curr = pcap_ptr_va_start + sizeof(struct pcap_filehdr);\n}\n\nstatic int try_load_pcap(const char *file)\n{\n\tstruct pcap_filehdr *hdr;\n\tstruct stat sb;\n\tint ret;\n\n\tpcap_fd = open(file, O_RDONLY);\n\tif (pcap_fd < 0) {\n\t\trl_printf(\"cannot open pcap [%s]!\\n\", strerror(errno));\n\t\treturn CMD_ERR;\n\t}\n\n\tret = fstat(pcap_fd, &sb);\n\tif (ret < 0) {\n\t\trl_printf(\"cannot fstat pcap file!\\n\");\n\t\treturn CMD_ERR;\n\t}\n\n\tif (!S_ISREG(sb.st_mode)) {\n\t\trl_printf(\"not a regular pcap file, duh!\\n\");\n\t\treturn CMD_ERR;\n\t}\n\n\tpcap_map_size = sb.st_size;\n\tif (pcap_map_size <= sizeof(struct pcap_filehdr)) {\n\t\trl_printf(\"pcap file too small!\\n\");\n\t\treturn CMD_ERR;\n\t}\n\n\tpcap_ptr_va_start = mmap(NULL, pcap_map_size, PROT_READ,\n\t\t\t\t MAP_SHARED | MAP_LOCKED, pcap_fd, 0);\n\tif (pcap_ptr_va_start == MAP_FAILED) {\n\t\trl_printf(\"mmap of file failed!\");\n\t\treturn CMD_ERR;\n\t}\n\n\thdr = (void *) pcap_ptr_va_start;\n\tif (hdr->magic != TCPDUMP_MAGIC) {\n\t\trl_printf(\"wrong pcap magic!\\n\");\n\t\treturn CMD_ERR;\n\t}\n\n\tpcap_reset_pkt();\n\n\treturn CMD_OK;\n\n}\n\nstatic void try_close_pcap(void)\n{\n\tif (pcap_fd >= 0) {\n\t\tmunmap(pcap_ptr_va_start, pcap_map_size);\n\t\tclose(pcap_fd);\n\n\t\tpcap_ptr_va_start = pcap_ptr_va_curr = NULL;\n\t\tpcap_map_size = 0;\n\t\tpcap_packet = 0;\n\t\tpcap_fd = -1;\n\t}\n}\n\nstatic int cmd_load_bpf(char *bpf_string)\n{\n\tchar sp, *token, separator = ',';\n\tunsigned short bpf_len, i = 0;\n\tstruct sock_filter tmp;\n\n\tbpf_prog_len = 0;\n\tmemset(bpf_image, 0, sizeof(bpf_image));\n\n\tif (sscanf(bpf_string, \"%hu%c\", &bpf_len, &sp) != 2 ||\n\t    sp != separator || bpf_len > BPF_MAXINSNS || bpf_len == 0) {\n\t\trl_printf(\"syntax error in head length encoding!\\n\");\n\t\treturn CMD_ERR;\n\t}\n\n\ttoken = bpf_string;\n\twhile ((token = strchr(token, separator)) && (++token)[0]) {\n\t\tif (i >= bpf_len) {\n\t\t\trl_printf(\"program exceeds encoded length!\\n\");\n\t\t\treturn CMD_ERR;\n\t\t}\n\n\t\tif (sscanf(token, \"%hu %hhu %hhu %u,\",\n\t\t\t   &tmp.code, &tmp.jt, &tmp.jf, &tmp.k) != 4) {\n\t\t\trl_printf(\"syntax error at instruction %d!\\n\", i);\n\t\t\treturn CMD_ERR;\n\t\t}\n\n\t\tbpf_image[i].code = tmp.code;\n\t\tbpf_image[i].jt = tmp.jt;\n\t\tbpf_image[i].jf = tmp.jf;\n\t\tbpf_image[i].k = tmp.k;\n\n\t\ti++;\n\t}\n\n\tif (i != bpf_len) {\n\t\trl_printf(\"syntax error exceeding encoded length!\\n\");\n\t\treturn CMD_ERR;\n\t} else\n\t\tbpf_prog_len = bpf_len;\n\tif (!bpf_runnable(bpf_image, bpf_prog_len))\n\t\tbpf_prog_len = 0;\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_load_pcap(char *file)\n{\n\tchar *file_trim, *tmp;\n\n\tfile_trim = strtok_r(file, \" \", &tmp);\n\tif (file_trim == NULL)\n\t\treturn CMD_ERR;\n\n\ttry_close_pcap();\n\n\treturn try_load_pcap(file_trim);\n}\n\nstatic int cmd_load(char *arg)\n{\n\tchar *subcmd, *cont = NULL, *tmp = strdup(arg);\n\tint ret = CMD_OK;\n\n\tsubcmd = strtok_r(tmp, \" \", &cont);\n\tif (subcmd == NULL)\n\t\tgoto out;\n\tif (matches(subcmd, \"bpf\") == 0) {\n\t\tbpf_reset();\n\t\tbpf_reset_breakpoints();\n\n\t\tif (!cont)\n\t\t\tret = CMD_ERR;\n\t\telse\n\t\t\tret = cmd_load_bpf(cont);\n\t} else if (matches(subcmd, \"pcap\") == 0) {\n\t\tret = cmd_load_pcap(cont);\n\t} else {\nout:\n\t\trl_printf(\"bpf <code>:  load bpf code\\n\");\n\t\trl_printf(\"pcap <file>: load pcap file\\n\");\n\t\tret = CMD_ERR;\n\t}\n\n\tfree(tmp);\n\treturn ret;\n}\n\nstatic int cmd_step(char *num)\n{\n\tstruct pcap_pkthdr *hdr;\n\tint steps, ret;\n\n\tif (!bpf_prog_loaded() || !pcap_loaded())\n\t\treturn CMD_ERR;\n\n\tsteps = strtol(num, NULL, 10);\n\tif (steps == 0 || strlen(num) == 0)\n\t\tsteps = 1;\n\tif (steps < 0) {\n\t\tif (!bpf_restore_regs(steps))\n\t\t\treturn CMD_ERR;\n\t\tsteps = 1;\n\t}\n\n\thdr = pcap_curr_pkt();\n\tret = bpf_run_stepping(bpf_image, bpf_prog_len,\n\t\t\t       (uint8_t *) hdr + sizeof(*hdr),\n\t\t\t       hdr->caplen, hdr->len, steps);\n\tif (ret >= 0 || bpf_curr.Rs) {\n\t\tbpf_reset();\n\t\tif (!pcap_next_pkt()) {\n\t\t\trl_printf(\"(going back to first packet)\\n\");\n\t\t\tpcap_reset_pkt();\n\t\t} else {\n\t\t\trl_printf(\"(next packet)\\n\");\n\t\t}\n\t}\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_select(char *num)\n{\n\tunsigned int which, i;\n\tbool have_next = true;\n\n\tif (!pcap_loaded() || strlen(num) == 0)\n\t\treturn CMD_ERR;\n\n\twhich = strtoul(num, NULL, 10);\n\tif (which == 0) {\n\t\trl_printf(\"packet count starts with 1, clamping!\\n\");\n\t\twhich = 1;\n\t}\n\n\tpcap_reset_pkt();\n\tbpf_reset();\n\n\tfor (i = 0; i < which && (have_next = pcap_next_pkt()); i++)\n\t\t ;\n\tif (!have_next || pcap_curr_pkt() == NULL) {\n\t\trl_printf(\"no packet #%u available!\\n\", which);\n\t\tpcap_reset_pkt();\n\t\treturn CMD_ERR;\n\t}\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_breakpoint(char *subcmd)\n{\n\tif (!bpf_prog_loaded())\n\t\treturn CMD_ERR;\n\tif (strlen(subcmd) == 0)\n\t\tbpf_dump_breakpoints();\n\telse if (matches(subcmd, \"reset\") == 0)\n\t\tbpf_reset_breakpoints();\n\telse {\n\t\tunsigned int where = strtoul(subcmd, NULL, 10);\n\n\t\tif (where < bpf_prog_len) {\n\t\t\tbpf_set_breakpoints(where);\n\t\t\trl_printf(\"breakpoint at: \");\n\t\t\tbpf_disasm(bpf_image[where], where);\n\t\t}\n\t}\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_run(char *num)\n{\n\tstatic uint32_t pass, fail;\n\tbool has_limit = true;\n\tint pkts = 0, i = 0;\n\n\tif (!bpf_prog_loaded() || !pcap_loaded())\n\t\treturn CMD_ERR;\n\n\tpkts = strtol(num, NULL, 10);\n\tif (pkts == 0 || strlen(num) == 0)\n\t\thas_limit = false;\n\n\tdo {\n\t\tstruct pcap_pkthdr *hdr = pcap_curr_pkt();\n\t\tint ret = bpf_run_all(bpf_image, bpf_prog_len,\n\t\t\t\t      (uint8_t *) hdr + sizeof(*hdr),\n\t\t\t\t      hdr->caplen, hdr->len);\n\t\tif (ret > 0)\n\t\t\tpass++;\n\t\telse if (ret == 0)\n\t\t\tfail++;\n\t\telse\n\t\t\treturn CMD_OK;\n\t\tbpf_reset();\n\t} while (pcap_next_pkt() && (!has_limit || (++i < pkts)));\n\n\trl_printf(\"bpf passes:%u fails:%u\\n\", pass, fail);\n\n\tpcap_reset_pkt();\n\tbpf_reset();\n\n\tpass = fail = 0;\n\treturn CMD_OK;\n}\n\nstatic int cmd_disassemble(char *line_string)\n{\n\tbool single_line = false;\n\tunsigned long line;\n\n\tif (!bpf_prog_loaded())\n\t\treturn CMD_ERR;\n\tif (strlen(line_string) > 0 &&\n\t    (line = strtoul(line_string, NULL, 10)) < bpf_prog_len)\n\t\tsingle_line = true;\n\tif (single_line)\n\t\tbpf_disasm(bpf_image[line], line);\n\telse\n\t\tbpf_disasm_all(bpf_image, bpf_prog_len);\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_dump(char *dontcare)\n{\n\tif (!bpf_prog_loaded())\n\t\treturn CMD_ERR;\n\n\tbpf_dump_all(bpf_image, bpf_prog_len);\n\n\treturn CMD_OK;\n}\n\nstatic int cmd_quit(char *dontcare)\n{\n\treturn CMD_EX;\n}\n\nstatic const struct shell_cmd cmds[] = {\n\t{ .name = \"load\", .func = cmd_load },\n\t{ .name = \"select\", .func = cmd_select },\n\t{ .name = \"step\", .func = cmd_step },\n\t{ .name = \"run\", .func = cmd_run },\n\t{ .name = \"breakpoint\", .func = cmd_breakpoint },\n\t{ .name = \"disassemble\", .func = cmd_disassemble },\n\t{ .name = \"dump\", .func = cmd_dump },\n\t{ .name = \"quit\", .func = cmd_quit },\n};\n\nstatic int execf(char *arg)\n{\n\tchar *cmd, *cont, *tmp = strdup(arg);\n\tint i, ret = 0, len;\n\n\tcmd = strtok_r(tmp, \" \", &cont);\n\tif (cmd == NULL)\n\t\tgoto out;\n\tlen = strlen(cmd);\n\tfor (i = 0; i < array_size(cmds); i++) {\n\t\tif (len != strlen(cmds[i].name))\n\t\t\tcontinue;\n\t\tif (strncmp(cmds[i].name, cmd, len) == 0) {\n\t\t\tret = cmds[i].func(cont);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tfree(tmp);\n\treturn ret;\n}\n\nstatic char *shell_comp_gen(const char *buf, int state)\n{\n\tstatic int list_index, len;\n\n\tif (!state) {\n\t\tlist_index = 0;\n\t\tlen = strlen(buf);\n\t}\n\n\tfor (; list_index < array_size(cmds); ) {\n\t\tconst char *name = cmds[list_index].name;\n\n\t\tlist_index++;\n\t\tif (strncmp(name, buf, len) == 0)\n\t\t\treturn strdup(name);\n\t}\n\n\treturn NULL;\n}\n\nstatic char **shell_completion(const char *buf, int start, int end)\n{\n\tchar **matches = NULL;\n\n\tif (start == 0)\n\t\tmatches = rl_completion_matches(buf, shell_comp_gen);\n\n\treturn matches;\n}\n\nstatic void intr_shell(int sig)\n{\n\tif (rl_end)\n\t\trl_kill_line(-1, 0);\n\n\trl_crlf();\n\trl_refresh_line(0, 0);\n\trl_free_line_state();\n}\n\nstatic void init_shell(FILE *fin, FILE *fout)\n{\n\tchar file[128];\n\n\tsnprintf(file, sizeof(file), \"%s/.bpf_dbg_history\", getenv(\"HOME\"));\n\tread_history(file);\n\n\trl_instream = fin;\n\trl_outstream = fout;\n\n\trl_readline_name = \"bpf_dbg\";\n\trl_terminal_name = getenv(\"TERM\");\n\n\trl_catch_signals = 0;\n\trl_catch_sigwinch = 1;\n\n\trl_attempted_completion_function = shell_completion;\n\n\trl_bind_key('\\t', rl_complete);\n\n\trl_bind_key_in_map('\\t', rl_complete, emacs_meta_keymap);\n\trl_bind_key_in_map('\\033', rl_complete, emacs_meta_keymap);\n\n\tsnprintf(file, sizeof(file), \"%s/.bpf_dbg_init\", getenv(\"HOME\"));\n\trl_read_init_file(file);\n\n\trl_prep_terminal(0);\n\trl_set_signals();\n\n\tsignal(SIGINT, intr_shell);\n}\n\nstatic void exit_shell(FILE *fin, FILE *fout)\n{\n\tchar file[128];\n\n\tsnprintf(file, sizeof(file), \"%s/.bpf_dbg_history\", getenv(\"HOME\"));\n\twrite_history(file);\n\n\tclear_history();\n\trl_deprep_terminal();\n\n\ttry_close_pcap();\n\n\tif (fin != stdin)\n\t\tfclose(fin);\n\tif (fout != stdout)\n\t\tfclose(fout);\n}\n\nstatic int run_shell_loop(FILE *fin, FILE *fout)\n{\n\tchar *buf;\n\n\tinit_shell(fin, fout);\n\n\twhile ((buf = readline(\"> \")) != NULL) {\n\t\tint ret = execf(buf);\n\t\tif (ret == CMD_EX)\n\t\t\tbreak;\n\t\tif (ret == CMD_OK && strlen(buf) > 0)\n\t\t\tadd_history(buf);\n\n\t\tfree(buf);\n\t}\n\n\texit_shell(fin, fout);\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tFILE *fin = NULL, *fout = NULL;\n\n\tif (argc >= 2)\n\t\tfin = fopen(argv[1], \"r\");\n\tif (argc >= 3)\n\t\tfout = fopen(argv[2], \"w\");\n\n\treturn run_shell_loop(fin ? : stdin, fout ? : stdout);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}