{
  "module_name": "pid_iter.bpf.c",
  "hash_id": "b2c89e587ebaf0836c75e893deb9f72d25fcd9a16f813fdb0301694a88a43577",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/skeleton/pid_iter.bpf.c",
  "human_readable_source": "\n \n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_tracing.h>\n#include \"pid_iter.h\"\n\n \nenum bpf_obj_type {\n\tBPF_OBJ_UNKNOWN,\n\tBPF_OBJ_PROG,\n\tBPF_OBJ_MAP,\n\tBPF_OBJ_LINK,\n\tBPF_OBJ_BTF,\n};\n\nstruct bpf_perf_link___local {\n\tstruct bpf_link link;\n\tstruct file *perf_file;\n} __attribute__((preserve_access_index));\n\nstruct perf_event___local {\n\tu64 bpf_cookie;\n} __attribute__((preserve_access_index));\n\nenum bpf_link_type___local {\n\tBPF_LINK_TYPE_PERF_EVENT___local = 7,\n};\n\nextern const void bpf_link_fops __ksym;\nextern const void bpf_map_fops __ksym;\nextern const void bpf_prog_fops __ksym;\nextern const void btf_fops __ksym;\n\nconst volatile enum bpf_obj_type obj_type = BPF_OBJ_UNKNOWN;\n\nstatic __always_inline __u32 get_obj_id(void *ent, enum bpf_obj_type type)\n{\n\tswitch (type) {\n\tcase BPF_OBJ_PROG:\n\t\treturn BPF_CORE_READ((struct bpf_prog *)ent, aux, id);\n\tcase BPF_OBJ_MAP:\n\t\treturn BPF_CORE_READ((struct bpf_map *)ent, id);\n\tcase BPF_OBJ_BTF:\n\t\treturn BPF_CORE_READ((struct btf *)ent, id);\n\tcase BPF_OBJ_LINK:\n\t\treturn BPF_CORE_READ((struct bpf_link *)ent, id);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic __u64 get_bpf_cookie(struct bpf_link *link)\n{\n\tstruct bpf_perf_link___local *perf_link;\n\tstruct perf_event___local *event;\n\n\tperf_link = container_of(link, struct bpf_perf_link___local, link);\n\tevent = BPF_CORE_READ(perf_link, perf_file, private_data);\n\treturn BPF_CORE_READ(event, bpf_cookie);\n}\n\nSEC(\"iter/task_file\")\nint iter(struct bpf_iter__task_file *ctx)\n{\n\tstruct file *file = ctx->file;\n\tstruct task_struct *task = ctx->task;\n\tstruct pid_iter_entry e;\n\tconst void *fops;\n\n\tif (!file || !task)\n\t\treturn 0;\n\n\tswitch (obj_type) {\n\tcase BPF_OBJ_PROG:\n\t\tfops = &bpf_prog_fops;\n\t\tbreak;\n\tcase BPF_OBJ_MAP:\n\t\tfops = &bpf_map_fops;\n\t\tbreak;\n\tcase BPF_OBJ_BTF:\n\t\tfops = &btf_fops;\n\t\tbreak;\n\tcase BPF_OBJ_LINK:\n\t\tfops = &bpf_link_fops;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (file->f_op != fops)\n\t\treturn 0;\n\n\t__builtin_memset(&e, 0, sizeof(e));\n\te.pid = task->tgid;\n\te.id = get_obj_id(file->private_data, obj_type);\n\n\tif (obj_type == BPF_OBJ_LINK &&\n\t    bpf_core_enum_value_exists(enum bpf_link_type___local,\n\t\t\t\t       BPF_LINK_TYPE_PERF_EVENT___local)) {\n\t\tstruct bpf_link *link = (struct bpf_link *) file->private_data;\n\n\t\tif (link->type == bpf_core_enum_value(enum bpf_link_type___local,\n\t\t\t\t\t\t      BPF_LINK_TYPE_PERF_EVENT___local)) {\n\t\t\te.has_bpf_cookie = true;\n\t\t\te.bpf_cookie = get_bpf_cookie(link);\n\t\t}\n\t}\n\n\tbpf_probe_read_kernel_str(&e.comm, sizeof(e.comm),\n\t\t\t\t  task->group_leader->comm);\n\tbpf_seq_write(ctx->meta->seq, &e, sizeof(e));\n\n\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}