{
  "module_name": "profiler.bpf.c",
  "hash_id": "b53e04930579480b7f41fa5fa24a41e5c708df99fba0a49f3173a2ae715f9bd3",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/skeleton/profiler.bpf.c",
  "human_readable_source": "\n\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nstruct bpf_perf_event_value___local {\n\t__u64 counter;\n\t__u64 enabled;\n\t__u64 running;\n} __attribute__((preserve_access_index));\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(int));\n} events SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(struct bpf_perf_event_value___local));\n} fentry_readings SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(struct bpf_perf_event_value___local));\n} accum_readings SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(u64));\n} counts SEC(\".maps\");\n\nconst volatile __u32 num_cpu = 1;\nconst volatile __u32 num_metric = 1;\n#define MAX_NUM_MATRICS 4\n\nSEC(\"fentry/XXX\")\nint BPF_PROG(fentry_XXX)\n{\n\tstruct bpf_perf_event_value___local *ptrs[MAX_NUM_MATRICS];\n\tu32 key = bpf_get_smp_processor_id();\n\tu32 i;\n\n\t \n\tfor (i = 0; i < num_metric && i < MAX_NUM_MATRICS; i++) {\n\t\tu32 flag = i;\n\n\t\tptrs[i] = bpf_map_lookup_elem(&fentry_readings, &flag);\n\t\tif (!ptrs[i])\n\t\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < num_metric && i < MAX_NUM_MATRICS; i++) {\n\t\tstruct bpf_perf_event_value___local reading;\n\t\tint err;\n\n\t\terr = bpf_perf_event_read_value(&events, key, (void *)&reading,\n\t\t\t\t\t\tsizeof(reading));\n\t\tif (err)\n\t\t\treturn 0;\n\t\t*(ptrs[i]) = reading;\n\t\tkey += num_cpu;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void\nfexit_update_maps(u32 id, struct bpf_perf_event_value___local *after)\n{\n\tstruct bpf_perf_event_value___local *before, diff;\n\n\tbefore = bpf_map_lookup_elem(&fentry_readings, &id);\n\t \n\tif (before && before->counter) {\n\t\tstruct bpf_perf_event_value___local *accum;\n\n\t\tdiff.counter = after->counter - before->counter;\n\t\tdiff.enabled = after->enabled - before->enabled;\n\t\tdiff.running = after->running - before->running;\n\n\t\taccum = bpf_map_lookup_elem(&accum_readings, &id);\n\t\tif (accum) {\n\t\t\taccum->counter += diff.counter;\n\t\t\taccum->enabled += diff.enabled;\n\t\t\taccum->running += diff.running;\n\t\t}\n\t}\n}\n\nSEC(\"fexit/XXX\")\nint BPF_PROG(fexit_XXX)\n{\n\tstruct bpf_perf_event_value___local readings[MAX_NUM_MATRICS];\n\tu32 cpu = bpf_get_smp_processor_id();\n\tu32 i, zero = 0;\n\tint err;\n\tu64 *count;\n\n\t \n\tfor (i = 0; i < num_metric && i < MAX_NUM_MATRICS; i++) {\n\t\terr = bpf_perf_event_read_value(&events, cpu + i * num_cpu,\n\t\t\t\t\t\t(void *)(readings + i),\n\t\t\t\t\t\tsizeof(*readings));\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\tcount = bpf_map_lookup_elem(&counts, &zero);\n\tif (count) {\n\t\t*count += 1;\n\t\tfor (i = 0; i < num_metric && i < MAX_NUM_MATRICS; i++)\n\t\t\tfexit_update_maps(i, &readings[i]);\n\t}\n\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}