{
  "module_name": "netlink_dumper.c",
  "hash_id": "ab8abac224d99f72881cfda34b80fe0e38ae40780cfd1f3082f4f7996ec50850",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/netlink_dumper.c",
  "human_readable_source": "\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <bpf/libbpf.h>\n#include <linux/rtnetlink.h>\n#include <linux/tc_act/tc_bpf.h>\n\n#include \"bpf/nlattr.h\"\n#include \"main.h\"\n#include \"netlink_dumper.h\"\n\nstatic void xdp_dump_prog_id(struct nlattr **tb, int attr,\n\t\t\t     const char *mode,\n\t\t\t     bool new_json_object)\n{\n\tif (!tb[attr])\n\t\treturn;\n\n\tif (new_json_object)\n\t\tNET_START_OBJECT\n\tNET_DUMP_STR(\"mode\", \" %s\", mode);\n\tNET_DUMP_UINT(\"id\", \" id %u\", libbpf_nla_getattr_u32(tb[attr]))\n\tif (new_json_object)\n\t\tNET_END_OBJECT\n}\n\nstatic int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,\n\t\t\t   const char *name)\n{\n\tstruct nlattr *tb[IFLA_XDP_MAX + 1];\n\tunsigned char mode;\n\n\tif (libbpf_nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)\n\t\treturn -1;\n\n\tif (!tb[IFLA_XDP_ATTACHED])\n\t\treturn 0;\n\n\tmode = libbpf_nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);\n\tif (mode == XDP_ATTACHED_NONE)\n\t\treturn 0;\n\n\tNET_START_OBJECT;\n\tif (name)\n\t\tNET_DUMP_STR(\"devname\", \"%s\", name);\n\tNET_DUMP_UINT(\"ifindex\", \"(%d)\", ifindex);\n\n\tif (mode == XDP_ATTACHED_MULTI) {\n\t\tif (json_output) {\n\t\t\tjsonw_name(json_wtr, \"multi_attachments\");\n\t\t\tjsonw_start_array(json_wtr);\n\t\t}\n\t\txdp_dump_prog_id(tb, IFLA_XDP_SKB_PROG_ID, \"generic\", true);\n\t\txdp_dump_prog_id(tb, IFLA_XDP_DRV_PROG_ID, \"driver\", true);\n\t\txdp_dump_prog_id(tb, IFLA_XDP_HW_PROG_ID, \"offload\", true);\n\t\tif (json_output)\n\t\t\tjsonw_end_array(json_wtr);\n\t} else if (mode == XDP_ATTACHED_DRV) {\n\t\txdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, \"driver\", false);\n\t} else if (mode == XDP_ATTACHED_SKB) {\n\t\txdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, \"generic\", false);\n\t} else if (mode == XDP_ATTACHED_HW) {\n\t\txdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, \"offload\", false);\n\t}\n\n\tNET_END_OBJECT_FINAL;\n\treturn 0;\n}\n\nint do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb)\n{\n\tif (!tb[IFLA_XDP])\n\t\treturn 0;\n\n\treturn do_xdp_dump_one(tb[IFLA_XDP], ifinfo->ifi_index,\n\t\t\t       libbpf_nla_getattr_str(tb[IFLA_IFNAME]));\n}\n\nstatic int do_bpf_dump_one_act(struct nlattr *attr)\n{\n\tstruct nlattr *tb[TCA_ACT_BPF_MAX + 1];\n\n\tif (libbpf_nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\tif (!tb[TCA_ACT_BPF_PARMS])\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\tNET_START_OBJECT_NESTED2;\n\tif (tb[TCA_ACT_BPF_NAME])\n\t\tNET_DUMP_STR(\"name\", \"%s\",\n\t\t\t     libbpf_nla_getattr_str(tb[TCA_ACT_BPF_NAME]));\n\tif (tb[TCA_ACT_BPF_ID])\n\t\tNET_DUMP_UINT(\"id\", \" id %u\",\n\t\t\t      libbpf_nla_getattr_u32(tb[TCA_ACT_BPF_ID]));\n\tNET_END_OBJECT_NESTED;\n\treturn 0;\n}\n\nstatic int do_dump_one_act(struct nlattr *attr)\n{\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\n\tif (!attr)\n\t\treturn 0;\n\n\tif (libbpf_nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\tif (tb[TCA_ACT_KIND] &&\n\t    strcmp(libbpf_nla_data(tb[TCA_ACT_KIND]), \"bpf\") == 0)\n\t\treturn do_bpf_dump_one_act(tb[TCA_ACT_OPTIONS]);\n\n\treturn 0;\n}\n\nstatic int do_bpf_act_dump(struct nlattr *attr)\n{\n\tstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\n\tint act, ret;\n\n\tif (libbpf_nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\tNET_START_ARRAY(\"act\", \" %s [\");\n\tfor (act = 0; act <= TCA_ACT_MAX_PRIO; act++) {\n\t\tret = do_dump_one_act(tb[act]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tNET_END_ARRAY(\"] \");\n\n\treturn ret;\n}\n\nstatic int do_bpf_filter_dump(struct nlattr *attr)\n{\n\tstruct nlattr *tb[TCA_BPF_MAX + 1];\n\tint ret;\n\n\tif (libbpf_nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\tif (tb[TCA_BPF_NAME])\n\t\tNET_DUMP_STR(\"name\", \" %s\",\n\t\t\t     libbpf_nla_getattr_str(tb[TCA_BPF_NAME]));\n\tif (tb[TCA_BPF_ID])\n\t\tNET_DUMP_UINT(\"id\", \" id %u\",\n\t\t\t      libbpf_nla_getattr_u32(tb[TCA_BPF_ID]));\n\tif (tb[TCA_BPF_ACT]) {\n\t\tret = do_bpf_act_dump(tb[TCA_BPF_ACT]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind,\n\t\t   const char *devname, int ifindex)\n{\n\tint ret = 0;\n\n\tif (tb[TCA_OPTIONS] &&\n\t    strcmp(libbpf_nla_data(tb[TCA_KIND]), \"bpf\") == 0) {\n\t\tNET_START_OBJECT;\n\t\tif (devname[0] != '\\0')\n\t\t\tNET_DUMP_STR(\"devname\", \"%s\", devname);\n\t\tNET_DUMP_UINT(\"ifindex\", \"(%u)\", ifindex);\n\t\tNET_DUMP_STR(\"kind\", \" %s\", kind);\n\t\tret = do_bpf_filter_dump(tb[TCA_OPTIONS]);\n\t\tNET_END_OBJECT_FINAL;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}