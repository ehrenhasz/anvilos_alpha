{
  "module_name": "map_perf_ring.c",
  "hash_id": "2f88be4bc1e75f7ec92ad864731597d3c95db019509de4aec79c7526e3066a99",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/map_perf_ring.c",
  "human_readable_source": "\n \n \n#include <errno.h>\n#include <fcntl.h>\n#include <bpf/libbpf.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <linux/bpf.h>\n#include <linux/perf_event.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n\n#include <bpf/bpf.h>\n\n#include \"main.h\"\n\n#define MMAP_PAGE_CNT\t16\n\nstatic volatile bool stop;\n\nstruct perf_event_sample {\n\tstruct perf_event_header header;\n\t__u64 time;\n\t__u32 size;\n\tunsigned char data[];\n};\n\nstruct perf_event_lost {\n\tstruct perf_event_header header;\n\t__u64 id;\n\t__u64 lost;\n};\n\nstatic void int_exit(int signo)\n{\n\tfprintf(stderr, \"Stopping...\\n\");\n\tstop = true;\n}\n\nstruct event_pipe_ctx {\n\tbool all_cpus;\n\tint cpu;\n\tint idx;\n};\n\nstatic enum bpf_perf_event_ret\nprint_bpf_output(void *private_data, int cpu, struct perf_event_header *event)\n{\n\tstruct perf_event_sample *e = container_of(event,\n\t\t\t\t\t\t   struct perf_event_sample,\n\t\t\t\t\t\t   header);\n\tstruct perf_event_lost *lost = container_of(event,\n\t\t\t\t\t\t    struct perf_event_lost,\n\t\t\t\t\t\t    header);\n\tstruct event_pipe_ctx *ctx = private_data;\n\tint idx = ctx->all_cpus ? cpu : ctx->idx;\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_name(json_wtr, \"type\");\n\t\tjsonw_uint(json_wtr, e->header.type);\n\t\tjsonw_name(json_wtr, \"cpu\");\n\t\tjsonw_uint(json_wtr, cpu);\n\t\tjsonw_name(json_wtr, \"index\");\n\t\tjsonw_uint(json_wtr, idx);\n\t\tif (e->header.type == PERF_RECORD_SAMPLE) {\n\t\t\tjsonw_name(json_wtr, \"timestamp\");\n\t\t\tjsonw_uint(json_wtr, e->time);\n\t\t\tjsonw_name(json_wtr, \"data\");\n\t\t\tprint_data_json(e->data, e->size);\n\t\t} else if (e->header.type == PERF_RECORD_LOST) {\n\t\t\tjsonw_name(json_wtr, \"lost\");\n\t\t\tjsonw_start_object(json_wtr);\n\t\t\tjsonw_name(json_wtr, \"id\");\n\t\t\tjsonw_uint(json_wtr, lost->id);\n\t\t\tjsonw_name(json_wtr, \"count\");\n\t\t\tjsonw_uint(json_wtr, lost->lost);\n\t\t\tjsonw_end_object(json_wtr);\n\t\t}\n\t\tjsonw_end_object(json_wtr);\n\t} else {\n\t\tif (e->header.type == PERF_RECORD_SAMPLE) {\n\t\t\tprintf(\"== @%lld.%09lld CPU: %d index: %d =====\\n\",\n\t\t\t       e->time / 1000000000ULL, e->time % 1000000000ULL,\n\t\t\t       cpu, idx);\n\t\t\tfprint_hex(stdout, e->data, e->size, \" \");\n\t\t\tprintf(\"\\n\");\n\t\t} else if (e->header.type == PERF_RECORD_LOST) {\n\t\t\tprintf(\"lost %lld events\\n\", lost->lost);\n\t\t} else {\n\t\t\tprintf(\"unknown event type=%d size=%d\\n\",\n\t\t\t       e->header.type, e->header.size);\n\t\t}\n\t}\n\n\treturn LIBBPF_PERF_EVENT_CONT;\n}\n\nint do_event_pipe(int argc, char **argv)\n{\n\tstruct perf_event_attr perf_attr = {\n\t\t.sample_type = PERF_SAMPLE_RAW | PERF_SAMPLE_TIME,\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.config = PERF_COUNT_SW_BPF_OUTPUT,\n\t\t.sample_period = 1,\n\t\t.wakeup_events = 1,\n\t};\n\tstruct bpf_map_info map_info = {};\n\tLIBBPF_OPTS(perf_buffer_raw_opts, opts);\n\tstruct event_pipe_ctx ctx = {\n\t\t.all_cpus = true,\n\t\t.cpu = -1,\n\t\t.idx = -1,\n\t};\n\tstruct perf_buffer *pb;\n\t__u32 map_info_len;\n\tint err, map_fd;\n\n\tmap_info_len = sizeof(map_info);\n\tmap_fd = map_parse_fd_and_info(&argc, &argv, &map_info, &map_info_len);\n\tif (map_fd < 0)\n\t\treturn -1;\n\n\tif (map_info.type != BPF_MAP_TYPE_PERF_EVENT_ARRAY) {\n\t\tp_err(\"map is not a perf event array\");\n\t\tgoto err_close_map;\n\t}\n\n\twhile (argc) {\n\t\tif (argc < 2) {\n\t\t\tBAD_ARG();\n\t\t\tgoto err_close_map;\n\t\t}\n\n\t\tif (is_prefix(*argv, \"cpu\")) {\n\t\t\tchar *endptr;\n\n\t\t\tNEXT_ARG();\n\t\t\tctx.cpu = strtoul(*argv, &endptr, 0);\n\t\t\tif (*endptr) {\n\t\t\t\tp_err(\"can't parse %s as CPU ID\", *argv);\n\t\t\t\tgoto err_close_map;\n\t\t\t}\n\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"index\")) {\n\t\t\tchar *endptr;\n\n\t\t\tNEXT_ARG();\n\t\t\tctx.idx = strtoul(*argv, &endptr, 0);\n\t\t\tif (*endptr) {\n\t\t\t\tp_err(\"can't parse %s as index\", *argv);\n\t\t\t\tgoto err_close_map;\n\t\t\t}\n\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tBAD_ARG();\n\t\t\tgoto err_close_map;\n\t\t}\n\n\t\tctx.all_cpus = false;\n\t}\n\n\tif (!ctx.all_cpus) {\n\t\tif (ctx.idx == -1 || ctx.cpu == -1) {\n\t\t\tp_err(\"cpu and index must be specified together\");\n\t\t\tgoto err_close_map;\n\t\t}\n\t} else {\n\t\tctx.cpu = 0;\n\t\tctx.idx = 0;\n\t}\n\n\topts.cpu_cnt = ctx.all_cpus ? 0 : 1;\n\topts.cpus = &ctx.cpu;\n\topts.map_keys = &ctx.idx;\n\tpb = perf_buffer__new_raw(map_fd, MMAP_PAGE_CNT, &perf_attr,\n\t\t\t\t  print_bpf_output, &ctx, &opts);\n\tif (!pb) {\n\t\tp_err(\"failed to create perf buffer: %s (%d)\",\n\t\t      strerror(errno), errno);\n\t\tgoto err_close_map;\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGHUP, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\n\twhile (!stop) {\n\t\terr = perf_buffer__poll(pb, 200);\n\t\tif (err < 0 && err != -EINTR) {\n\t\t\tp_err(\"perf buffer polling failed: %s (%d)\",\n\t\t\t      strerror(errno), errno);\n\t\t\tgoto err_close_pb;\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tperf_buffer__free(pb);\n\tclose(map_fd);\n\n\treturn 0;\n\nerr_close_pb:\n\tperf_buffer__free(pb);\nerr_close_map:\n\tclose(map_fd);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}