{
  "module_name": "link.c",
  "hash_id": "c3c2a53701f600202b200c65d6fd7af68b8a59f8e7ba0175a18f05d926b6991f",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/link.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <linux/err.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_arp.h>\n#include <linux/perf_event.h>\n#include <net/if.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/hashmap.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n#include \"xlated_dumper.h\"\n\n#define PERF_HW_CACHE_LEN 128\n\nstatic struct hashmap *link_table;\nstatic struct dump_data dd;\n\nstatic const char *perf_type_name[PERF_TYPE_MAX] = {\n\t[PERF_TYPE_HARDWARE]\t\t\t= \"hardware\",\n\t[PERF_TYPE_SOFTWARE]\t\t\t= \"software\",\n\t[PERF_TYPE_TRACEPOINT]\t\t\t= \"tracepoint\",\n\t[PERF_TYPE_HW_CACHE]\t\t\t= \"hw-cache\",\n\t[PERF_TYPE_RAW]\t\t\t\t= \"raw\",\n\t[PERF_TYPE_BREAKPOINT]\t\t\t= \"breakpoint\",\n};\n\nconst char *event_symbols_hw[PERF_COUNT_HW_MAX] = {\n\t[PERF_COUNT_HW_CPU_CYCLES]\t\t= \"cpu-cycles\",\n\t[PERF_COUNT_HW_INSTRUCTIONS]\t\t= \"instructions\",\n\t[PERF_COUNT_HW_CACHE_REFERENCES]\t= \"cache-references\",\n\t[PERF_COUNT_HW_CACHE_MISSES]\t\t= \"cache-misses\",\n\t[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= \"branch-instructions\",\n\t[PERF_COUNT_HW_BRANCH_MISSES]\t\t= \"branch-misses\",\n\t[PERF_COUNT_HW_BUS_CYCLES]\t\t= \"bus-cycles\",\n\t[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]\t= \"stalled-cycles-frontend\",\n\t[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]\t= \"stalled-cycles-backend\",\n\t[PERF_COUNT_HW_REF_CPU_CYCLES]\t\t= \"ref-cycles\",\n};\n\nconst char *event_symbols_sw[PERF_COUNT_SW_MAX] = {\n\t[PERF_COUNT_SW_CPU_CLOCK]\t\t= \"cpu-clock\",\n\t[PERF_COUNT_SW_TASK_CLOCK]\t\t= \"task-clock\",\n\t[PERF_COUNT_SW_PAGE_FAULTS]\t\t= \"page-faults\",\n\t[PERF_COUNT_SW_CONTEXT_SWITCHES]\t= \"context-switches\",\n\t[PERF_COUNT_SW_CPU_MIGRATIONS]\t\t= \"cpu-migrations\",\n\t[PERF_COUNT_SW_PAGE_FAULTS_MIN]\t\t= \"minor-faults\",\n\t[PERF_COUNT_SW_PAGE_FAULTS_MAJ]\t\t= \"major-faults\",\n\t[PERF_COUNT_SW_ALIGNMENT_FAULTS]\t= \"alignment-faults\",\n\t[PERF_COUNT_SW_EMULATION_FAULTS]\t= \"emulation-faults\",\n\t[PERF_COUNT_SW_DUMMY]\t\t\t= \"dummy\",\n\t[PERF_COUNT_SW_BPF_OUTPUT]\t\t= \"bpf-output\",\n\t[PERF_COUNT_SW_CGROUP_SWITCHES]\t\t= \"cgroup-switches\",\n};\n\nconst char *evsel__hw_cache[PERF_COUNT_HW_CACHE_MAX] = {\n\t[PERF_COUNT_HW_CACHE_L1D]\t\t= \"L1-dcache\",\n\t[PERF_COUNT_HW_CACHE_L1I]\t\t= \"L1-icache\",\n\t[PERF_COUNT_HW_CACHE_LL]\t\t= \"LLC\",\n\t[PERF_COUNT_HW_CACHE_DTLB]\t\t= \"dTLB\",\n\t[PERF_COUNT_HW_CACHE_ITLB]\t\t= \"iTLB\",\n\t[PERF_COUNT_HW_CACHE_BPU]\t\t= \"branch\",\n\t[PERF_COUNT_HW_CACHE_NODE]\t\t= \"node\",\n};\n\nconst char *evsel__hw_cache_op[PERF_COUNT_HW_CACHE_OP_MAX] = {\n\t[PERF_COUNT_HW_CACHE_OP_READ]\t\t= \"load\",\n\t[PERF_COUNT_HW_CACHE_OP_WRITE]\t\t= \"store\",\n\t[PERF_COUNT_HW_CACHE_OP_PREFETCH]\t= \"prefetch\",\n};\n\nconst char *evsel__hw_cache_result[PERF_COUNT_HW_CACHE_RESULT_MAX] = {\n\t[PERF_COUNT_HW_CACHE_RESULT_ACCESS]\t= \"refs\",\n\t[PERF_COUNT_HW_CACHE_RESULT_MISS]\t= \"misses\",\n};\n\n#define perf_event_name(array, id) ({\t\t\t\\\n\tconst char *event_str = NULL;\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tif ((id) < ARRAY_SIZE(array))\t\t\t\\\n\t\tevent_str = array[id];\t\t\t\\\n\tevent_str;\t\t\t\t\t\\\n})\n\nstatic int link_parse_fd(int *argc, char ***argv)\n{\n\tint fd;\n\n\tif (is_prefix(**argv, \"id\")) {\n\t\tunsigned int id;\n\t\tchar *endptr;\n\n\t\tNEXT_ARGP();\n\n\t\tid = strtoul(**argv, &endptr, 0);\n\t\tif (*endptr) {\n\t\t\tp_err(\"can't parse %s as ID\", **argv);\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\tfd = bpf_link_get_fd_by_id(id);\n\t\tif (fd < 0)\n\t\t\tp_err(\"failed to get link with ID %d: %s\", id, strerror(errno));\n\t\treturn fd;\n\t} else if (is_prefix(**argv, \"pinned\")) {\n\t\tchar *path;\n\n\t\tNEXT_ARGP();\n\n\t\tpath = **argv;\n\t\tNEXT_ARGP();\n\n\t\treturn open_obj_pinned_any(path, BPF_OBJ_LINK);\n\t}\n\n\tp_err(\"expected 'id' or 'pinned', got: '%s'?\", **argv);\n\treturn -1;\n}\n\nstatic void\nshow_link_header_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tconst char *link_type_str;\n\n\tjsonw_uint_field(wtr, \"id\", info->id);\n\tlink_type_str = libbpf_bpf_link_type_str(info->type);\n\tif (link_type_str)\n\t\tjsonw_string_field(wtr, \"type\", link_type_str);\n\telse\n\t\tjsonw_uint_field(wtr, \"type\", info->type);\n\n\tjsonw_uint_field(json_wtr, \"prog_id\", info->prog_id);\n}\n\nstatic void show_link_attach_type_json(__u32 attach_type, json_writer_t *wtr)\n{\n\tconst char *attach_type_str;\n\n\tattach_type_str = libbpf_bpf_attach_type_str(attach_type);\n\tif (attach_type_str)\n\t\tjsonw_string_field(wtr, \"attach_type\", attach_type_str);\n\telse\n\t\tjsonw_uint_field(wtr, \"attach_type\", attach_type);\n}\n\nstatic void show_link_ifindex_json(__u32 ifindex, json_writer_t *wtr)\n{\n\tchar devname[IF_NAMESIZE] = \"(unknown)\";\n\n\tif (ifindex)\n\t\tif_indextoname(ifindex, devname);\n\telse\n\t\tsnprintf(devname, sizeof(devname), \"(detached)\");\n\tjsonw_string_field(wtr, \"devname\", devname);\n\tjsonw_uint_field(wtr, \"ifindex\", ifindex);\n}\n\nstatic bool is_iter_map_target(const char *target_name)\n{\n\treturn strcmp(target_name, \"bpf_map_elem\") == 0 ||\n\t       strcmp(target_name, \"bpf_sk_storage_map\") == 0;\n}\n\nstatic bool is_iter_cgroup_target(const char *target_name)\n{\n\treturn strcmp(target_name, \"cgroup\") == 0;\n}\n\nstatic const char *cgroup_order_string(__u32 order)\n{\n\tswitch (order) {\n\tcase BPF_CGROUP_ITER_ORDER_UNSPEC:\n\t\treturn \"order_unspec\";\n\tcase BPF_CGROUP_ITER_SELF_ONLY:\n\t\treturn \"self_only\";\n\tcase BPF_CGROUP_ITER_DESCENDANTS_PRE:\n\t\treturn \"descendants_pre\";\n\tcase BPF_CGROUP_ITER_DESCENDANTS_POST:\n\t\treturn \"descendants_post\";\n\tcase BPF_CGROUP_ITER_ANCESTORS_UP:\n\t\treturn \"ancestors_up\";\n\tdefault:  \n\t\treturn \"unknown\";\n\t}\n}\n\nstatic bool is_iter_task_target(const char *target_name)\n{\n\treturn strcmp(target_name, \"task\") == 0 ||\n\t\tstrcmp(target_name, \"task_file\") == 0 ||\n\t\tstrcmp(target_name, \"task_vma\") == 0;\n}\n\nstatic void show_iter_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tconst char *target_name = u64_to_ptr(info->iter.target_name);\n\n\tjsonw_string_field(wtr, \"target_name\", target_name);\n\n\tif (is_iter_map_target(target_name))\n\t\tjsonw_uint_field(wtr, \"map_id\", info->iter.map.map_id);\n\telse if (is_iter_task_target(target_name)) {\n\t\tif (info->iter.task.tid)\n\t\t\tjsonw_uint_field(wtr, \"tid\", info->iter.task.tid);\n\t\telse if (info->iter.task.pid)\n\t\t\tjsonw_uint_field(wtr, \"pid\", info->iter.task.pid);\n\t}\n\n\tif (is_iter_cgroup_target(target_name)) {\n\t\tjsonw_lluint_field(wtr, \"cgroup_id\", info->iter.cgroup.cgroup_id);\n\t\tjsonw_string_field(wtr, \"order\",\n\t\t\t\t   cgroup_order_string(info->iter.cgroup.order));\n\t}\n}\n\nvoid netfilter_dump_json(const struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tjsonw_uint_field(json_wtr, \"pf\",\n\t\t\t info->netfilter.pf);\n\tjsonw_uint_field(json_wtr, \"hook\",\n\t\t\t info->netfilter.hooknum);\n\tjsonw_int_field(json_wtr, \"prio\",\n\t\t\t info->netfilter.priority);\n\tjsonw_uint_field(json_wtr, \"flags\",\n\t\t\t info->netfilter.flags);\n}\n\nstatic int get_prog_info(int prog_id, struct bpf_prog_info *info)\n{\n\t__u32 len = sizeof(*info);\n\tint err, prog_fd;\n\n\tprog_fd = bpf_prog_get_fd_by_id(prog_id);\n\tif (prog_fd < 0)\n\t\treturn prog_fd;\n\n\tmemset(info, 0, sizeof(*info));\n\terr = bpf_prog_get_info_by_fd(prog_fd, info, &len);\n\tif (err)\n\t\tp_err(\"can't get prog info: %s\", strerror(errno));\n\tclose(prog_fd);\n\treturn err;\n}\n\nstatic int cmp_u64(const void *A, const void *B)\n{\n\tconst __u64 *a = A, *b = B;\n\n\treturn *a - *b;\n}\n\nstatic void\nshow_kprobe_multi_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\t__u32 i, j = 0;\n\t__u64 *addrs;\n\n\tjsonw_bool_field(json_wtr, \"retprobe\",\n\t\t\t info->kprobe_multi.flags & BPF_F_KPROBE_MULTI_RETURN);\n\tjsonw_uint_field(json_wtr, \"func_cnt\", info->kprobe_multi.count);\n\tjsonw_name(json_wtr, \"funcs\");\n\tjsonw_start_array(json_wtr);\n\taddrs = u64_to_ptr(info->kprobe_multi.addrs);\n\tqsort(addrs, info->kprobe_multi.count, sizeof(addrs[0]), cmp_u64);\n\n\t \n\tif (!dd.sym_count)\n\t\tkernel_syms_load(&dd);\n\tfor (i = 0; i < dd.sym_count; i++) {\n\t\tif (dd.sym_mapping[i].address != addrs[j])\n\t\t\tcontinue;\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_uint_field(json_wtr, \"addr\", dd.sym_mapping[i].address);\n\t\tjsonw_string_field(json_wtr, \"func\", dd.sym_mapping[i].name);\n\t\t \n\t\tif (dd.sym_mapping[i].module[0] == '\\0') {\n\t\t\tjsonw_name(json_wtr, \"module\");\n\t\t\tjsonw_null(json_wtr);\n\t\t} else {\n\t\t\tjsonw_string_field(json_wtr, \"module\", dd.sym_mapping[i].module);\n\t\t}\n\t\tjsonw_end_object(json_wtr);\n\t\tif (j++ == info->kprobe_multi.count)\n\t\t\tbreak;\n\t}\n\tjsonw_end_array(json_wtr);\n}\n\nstatic void\nshow_perf_event_kprobe_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tjsonw_bool_field(wtr, \"retprobe\", info->perf_event.type == BPF_PERF_EVENT_KRETPROBE);\n\tjsonw_uint_field(wtr, \"addr\", info->perf_event.kprobe.addr);\n\tjsonw_string_field(wtr, \"func\",\n\t\t\t   u64_to_ptr(info->perf_event.kprobe.func_name));\n\tjsonw_uint_field(wtr, \"offset\", info->perf_event.kprobe.offset);\n}\n\nstatic void\nshow_perf_event_uprobe_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tjsonw_bool_field(wtr, \"retprobe\", info->perf_event.type == BPF_PERF_EVENT_URETPROBE);\n\tjsonw_string_field(wtr, \"file\",\n\t\t\t   u64_to_ptr(info->perf_event.uprobe.file_name));\n\tjsonw_uint_field(wtr, \"offset\", info->perf_event.uprobe.offset);\n}\n\nstatic void\nshow_perf_event_tracepoint_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\tjsonw_string_field(wtr, \"tracepoint\",\n\t\t\t   u64_to_ptr(info->perf_event.tracepoint.tp_name));\n}\n\nstatic char *perf_config_hw_cache_str(__u64 config)\n{\n\tconst char *hw_cache, *result, *op;\n\tchar *str = malloc(PERF_HW_CACHE_LEN);\n\n\tif (!str) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn NULL;\n\t}\n\n\thw_cache = perf_event_name(evsel__hw_cache, config & 0xff);\n\tif (hw_cache)\n\t\tsnprintf(str, PERF_HW_CACHE_LEN, \"%s-\", hw_cache);\n\telse\n\t\tsnprintf(str, PERF_HW_CACHE_LEN, \"%lld-\", config & 0xff);\n\n\top = perf_event_name(evsel__hw_cache_op, (config >> 8) & 0xff);\n\tif (op)\n\t\tsnprintf(str + strlen(str), PERF_HW_CACHE_LEN - strlen(str),\n\t\t\t \"%s-\", op);\n\telse\n\t\tsnprintf(str + strlen(str), PERF_HW_CACHE_LEN - strlen(str),\n\t\t\t \"%lld-\", (config >> 8) & 0xff);\n\n\tresult = perf_event_name(evsel__hw_cache_result, config >> 16);\n\tif (result)\n\t\tsnprintf(str + strlen(str), PERF_HW_CACHE_LEN - strlen(str),\n\t\t\t \"%s\", result);\n\telse\n\t\tsnprintf(str + strlen(str), PERF_HW_CACHE_LEN - strlen(str),\n\t\t\t \"%lld\", config >> 16);\n\treturn str;\n}\n\nstatic const char *perf_config_str(__u32 type, __u64 config)\n{\n\tconst char *perf_config;\n\n\tswitch (type) {\n\tcase PERF_TYPE_HARDWARE:\n\t\tperf_config = perf_event_name(event_symbols_hw, config);\n\t\tbreak;\n\tcase PERF_TYPE_SOFTWARE:\n\t\tperf_config = perf_event_name(event_symbols_sw, config);\n\t\tbreak;\n\tcase PERF_TYPE_HW_CACHE:\n\t\tperf_config = perf_config_hw_cache_str(config);\n\t\tbreak;\n\tdefault:\n\t\tperf_config = NULL;\n\t\tbreak;\n\t}\n\treturn perf_config;\n}\n\nstatic void\nshow_perf_event_event_json(struct bpf_link_info *info, json_writer_t *wtr)\n{\n\t__u64 config = info->perf_event.event.config;\n\t__u32 type = info->perf_event.event.type;\n\tconst char *perf_type, *perf_config;\n\n\tperf_type = perf_event_name(perf_type_name, type);\n\tif (perf_type)\n\t\tjsonw_string_field(wtr, \"event_type\", perf_type);\n\telse\n\t\tjsonw_uint_field(wtr, \"event_type\", type);\n\n\tperf_config = perf_config_str(type, config);\n\tif (perf_config)\n\t\tjsonw_string_field(wtr, \"event_config\", perf_config);\n\telse\n\t\tjsonw_uint_field(wtr, \"event_config\", config);\n\n\tif (type == PERF_TYPE_HW_CACHE && perf_config)\n\t\tfree((void *)perf_config);\n}\n\nstatic int show_link_close_json(int fd, struct bpf_link_info *info)\n{\n\tstruct bpf_prog_info prog_info;\n\tconst char *prog_type_str;\n\tint err;\n\n\tjsonw_start_object(json_wtr);\n\n\tshow_link_header_json(info, json_wtr);\n\n\tswitch (info->type) {\n\tcase BPF_LINK_TYPE_RAW_TRACEPOINT:\n\t\tjsonw_string_field(json_wtr, \"tp_name\",\n\t\t\t\t   u64_to_ptr(info->raw_tracepoint.tp_name));\n\t\tbreak;\n\tcase BPF_LINK_TYPE_TRACING:\n\t\terr = get_prog_info(info->prog_id, &prog_info);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_info.type);\n\t\t \n\t\tif (prog_type_str)\n\t\t\tjsonw_string_field(json_wtr, \"prog_type\", prog_type_str);\n\t\telse\n\t\t\tjsonw_uint_field(json_wtr, \"prog_type\", prog_info.type);\n\n\t\tshow_link_attach_type_json(info->tracing.attach_type,\n\t\t\t\t\t   json_wtr);\n\t\tjsonw_uint_field(json_wtr, \"target_obj_id\", info->tracing.target_obj_id);\n\t\tjsonw_uint_field(json_wtr, \"target_btf_id\", info->tracing.target_btf_id);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_CGROUP:\n\t\tjsonw_lluint_field(json_wtr, \"cgroup_id\",\n\t\t\t\t   info->cgroup.cgroup_id);\n\t\tshow_link_attach_type_json(info->cgroup.attach_type, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_ITER:\n\t\tshow_iter_json(info, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_NETNS:\n\t\tjsonw_uint_field(json_wtr, \"netns_ino\",\n\t\t\t\t info->netns.netns_ino);\n\t\tshow_link_attach_type_json(info->netns.attach_type, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_NETFILTER:\n\t\tnetfilter_dump_json(info, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_TCX:\n\t\tshow_link_ifindex_json(info->tcx.ifindex, json_wtr);\n\t\tshow_link_attach_type_json(info->tcx.attach_type, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_XDP:\n\t\tshow_link_ifindex_json(info->xdp.ifindex, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_STRUCT_OPS:\n\t\tjsonw_uint_field(json_wtr, \"map_id\",\n\t\t\t\t info->struct_ops.map_id);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_KPROBE_MULTI:\n\t\tshow_kprobe_multi_json(info, json_wtr);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_PERF_EVENT:\n\t\tswitch (info->perf_event.type) {\n\t\tcase BPF_PERF_EVENT_EVENT:\n\t\t\tshow_perf_event_event_json(info, json_wtr);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_TRACEPOINT:\n\t\t\tshow_perf_event_tracepoint_json(info, json_wtr);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_KPROBE:\n\t\tcase BPF_PERF_EVENT_KRETPROBE:\n\t\t\tshow_perf_event_kprobe_json(info, json_wtr);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_UPROBE:\n\t\tcase BPF_PERF_EVENT_URETPROBE:\n\t\t\tshow_perf_event_uprobe_json(info, json_wtr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!hashmap__empty(link_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\tjsonw_name(json_wtr, \"pinned\");\n\t\tjsonw_start_array(json_wtr);\n\t\thashmap__for_each_key_entry(link_table, entry, info->id)\n\t\t\tjsonw_string(json_wtr, entry->pvalue);\n\t\tjsonw_end_array(json_wtr);\n\t}\n\n\temit_obj_refs_json(refs_table, info->id, json_wtr);\n\n\tjsonw_end_object(json_wtr);\n\n\treturn 0;\n}\n\nstatic void show_link_header_plain(struct bpf_link_info *info)\n{\n\tconst char *link_type_str;\n\n\tprintf(\"%u: \", info->id);\n\tlink_type_str = libbpf_bpf_link_type_str(info->type);\n\tif (link_type_str)\n\t\tprintf(\"%s  \", link_type_str);\n\telse\n\t\tprintf(\"type %u  \", info->type);\n\n\tif (info->type == BPF_LINK_TYPE_STRUCT_OPS)\n\t\tprintf(\"map %u  \", info->struct_ops.map_id);\n\telse\n\t\tprintf(\"prog %u  \", info->prog_id);\n}\n\nstatic void show_link_attach_type_plain(__u32 attach_type)\n{\n\tconst char *attach_type_str;\n\n\tattach_type_str = libbpf_bpf_attach_type_str(attach_type);\n\tif (attach_type_str)\n\t\tprintf(\"attach_type %s  \", attach_type_str);\n\telse\n\t\tprintf(\"attach_type %u  \", attach_type);\n}\n\nstatic void show_link_ifindex_plain(__u32 ifindex)\n{\n\tchar devname[IF_NAMESIZE * 2] = \"(unknown)\";\n\tchar tmpname[IF_NAMESIZE];\n\tchar *ret = NULL;\n\n\tif (ifindex)\n\t\tret = if_indextoname(ifindex, tmpname);\n\telse\n\t\tsnprintf(devname, sizeof(devname), \"(detached)\");\n\tif (ret)\n\t\tsnprintf(devname, sizeof(devname), \"%s(%d)\",\n\t\t\t tmpname, ifindex);\n\tprintf(\"ifindex %s  \", devname);\n}\n\nstatic void show_iter_plain(struct bpf_link_info *info)\n{\n\tconst char *target_name = u64_to_ptr(info->iter.target_name);\n\n\tprintf(\"target_name %s  \", target_name);\n\n\tif (is_iter_map_target(target_name))\n\t\tprintf(\"map_id %u  \", info->iter.map.map_id);\n\telse if (is_iter_task_target(target_name)) {\n\t\tif (info->iter.task.tid)\n\t\t\tprintf(\"tid %u \", info->iter.task.tid);\n\t\telse if (info->iter.task.pid)\n\t\t\tprintf(\"pid %u \", info->iter.task.pid);\n\t}\n\n\tif (is_iter_cgroup_target(target_name)) {\n\t\tprintf(\"cgroup_id %llu  \", info->iter.cgroup.cgroup_id);\n\t\tprintf(\"order %s  \",\n\t\t       cgroup_order_string(info->iter.cgroup.order));\n\t}\n}\n\nstatic const char * const pf2name[] = {\n\t[NFPROTO_INET] = \"inet\",\n\t[NFPROTO_IPV4] = \"ip\",\n\t[NFPROTO_ARP] = \"arp\",\n\t[NFPROTO_NETDEV] = \"netdev\",\n\t[NFPROTO_BRIDGE] = \"bridge\",\n\t[NFPROTO_IPV6] = \"ip6\",\n};\n\nstatic const char * const inethook2name[] = {\n\t[NF_INET_PRE_ROUTING] = \"prerouting\",\n\t[NF_INET_LOCAL_IN] = \"input\",\n\t[NF_INET_FORWARD] = \"forward\",\n\t[NF_INET_LOCAL_OUT] = \"output\",\n\t[NF_INET_POST_ROUTING] = \"postrouting\",\n};\n\nstatic const char * const arphook2name[] = {\n\t[NF_ARP_IN] = \"input\",\n\t[NF_ARP_OUT] = \"output\",\n};\n\nvoid netfilter_dump_plain(const struct bpf_link_info *info)\n{\n\tconst char *hookname = NULL, *pfname = NULL;\n\tunsigned int hook = info->netfilter.hooknum;\n\tunsigned int pf = info->netfilter.pf;\n\n\tif (pf < ARRAY_SIZE(pf2name))\n\t\tpfname = pf2name[pf];\n\n\tswitch (pf) {\n\tcase NFPROTO_BRIDGE:  \n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\tif (hook < ARRAY_SIZE(inethook2name))\n\t\t\thookname = inethook2name[hook];\n\t\tbreak;\n\tcase NFPROTO_ARP:\n\t\tif (hook < ARRAY_SIZE(arphook2name))\n\t\t\thookname = arphook2name[hook];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (pfname)\n\t\tprintf(\"\\n\\t%s\", pfname);\n\telse\n\t\tprintf(\"\\n\\tpf: %d\", pf);\n\n\tif (hookname)\n\t\tprintf(\" %s\", hookname);\n\telse\n\t\tprintf(\", hook %u,\", hook);\n\n\tprintf(\" prio %d\", info->netfilter.priority);\n\n\tif (info->netfilter.flags)\n\t\tprintf(\" flags 0x%x\", info->netfilter.flags);\n}\n\nstatic void show_kprobe_multi_plain(struct bpf_link_info *info)\n{\n\t__u32 i, j = 0;\n\t__u64 *addrs;\n\n\tif (!info->kprobe_multi.count)\n\t\treturn;\n\n\tif (info->kprobe_multi.flags & BPF_F_KPROBE_MULTI_RETURN)\n\t\tprintf(\"\\n\\tkretprobe.multi  \");\n\telse\n\t\tprintf(\"\\n\\tkprobe.multi  \");\n\tprintf(\"func_cnt %u  \", info->kprobe_multi.count);\n\taddrs = (__u64 *)u64_to_ptr(info->kprobe_multi.addrs);\n\tqsort(addrs, info->kprobe_multi.count, sizeof(__u64), cmp_u64);\n\n\t \n\tif (!dd.sym_count)\n\t\tkernel_syms_load(&dd);\n\tif (!dd.sym_count)\n\t\treturn;\n\n\tprintf(\"\\n\\t%-16s %s\", \"addr\", \"func [module]\");\n\tfor (i = 0; i < dd.sym_count; i++) {\n\t\tif (dd.sym_mapping[i].address != addrs[j])\n\t\t\tcontinue;\n\t\tprintf(\"\\n\\t%016lx %s\",\n\t\t       dd.sym_mapping[i].address, dd.sym_mapping[i].name);\n\t\tif (dd.sym_mapping[i].module[0] != '\\0')\n\t\t\tprintf(\" [%s]  \", dd.sym_mapping[i].module);\n\t\telse\n\t\t\tprintf(\"  \");\n\n\t\tif (j++ == info->kprobe_multi.count)\n\t\t\tbreak;\n\t}\n}\n\nstatic void show_perf_event_kprobe_plain(struct bpf_link_info *info)\n{\n\tconst char *buf;\n\n\tbuf = u64_to_ptr(info->perf_event.kprobe.func_name);\n\tif (buf[0] == '\\0' && !info->perf_event.kprobe.addr)\n\t\treturn;\n\n\tif (info->perf_event.type == BPF_PERF_EVENT_KRETPROBE)\n\t\tprintf(\"\\n\\tkretprobe \");\n\telse\n\t\tprintf(\"\\n\\tkprobe \");\n\tif (info->perf_event.kprobe.addr)\n\t\tprintf(\"%llx \", info->perf_event.kprobe.addr);\n\tprintf(\"%s\", buf);\n\tif (info->perf_event.kprobe.offset)\n\t\tprintf(\"+%#x\", info->perf_event.kprobe.offset);\n\tprintf(\"  \");\n}\n\nstatic void show_perf_event_uprobe_plain(struct bpf_link_info *info)\n{\n\tconst char *buf;\n\n\tbuf = u64_to_ptr(info->perf_event.uprobe.file_name);\n\tif (buf[0] == '\\0')\n\t\treturn;\n\n\tif (info->perf_event.type == BPF_PERF_EVENT_URETPROBE)\n\t\tprintf(\"\\n\\turetprobe \");\n\telse\n\t\tprintf(\"\\n\\tuprobe \");\n\tprintf(\"%s+%#x  \", buf, info->perf_event.uprobe.offset);\n}\n\nstatic void show_perf_event_tracepoint_plain(struct bpf_link_info *info)\n{\n\tconst char *buf;\n\n\tbuf = u64_to_ptr(info->perf_event.tracepoint.tp_name);\n\tif (buf[0] == '\\0')\n\t\treturn;\n\n\tprintf(\"\\n\\ttracepoint %s  \", buf);\n}\n\nstatic void show_perf_event_event_plain(struct bpf_link_info *info)\n{\n\t__u64 config = info->perf_event.event.config;\n\t__u32 type = info->perf_event.event.type;\n\tconst char *perf_type, *perf_config;\n\n\tprintf(\"\\n\\tevent \");\n\tperf_type = perf_event_name(perf_type_name, type);\n\tif (perf_type)\n\t\tprintf(\"%s:\", perf_type);\n\telse\n\t\tprintf(\"%u :\", type);\n\n\tperf_config = perf_config_str(type, config);\n\tif (perf_config)\n\t\tprintf(\"%s  \", perf_config);\n\telse\n\t\tprintf(\"%llu  \", config);\n\n\tif (type == PERF_TYPE_HW_CACHE && perf_config)\n\t\tfree((void *)perf_config);\n}\n\nstatic int show_link_close_plain(int fd, struct bpf_link_info *info)\n{\n\tstruct bpf_prog_info prog_info;\n\tconst char *prog_type_str;\n\tint err;\n\n\tshow_link_header_plain(info);\n\n\tswitch (info->type) {\n\tcase BPF_LINK_TYPE_RAW_TRACEPOINT:\n\t\tprintf(\"\\n\\ttp '%s'  \",\n\t\t       (const char *)u64_to_ptr(info->raw_tracepoint.tp_name));\n\t\tbreak;\n\tcase BPF_LINK_TYPE_TRACING:\n\t\terr = get_prog_info(info->prog_id, &prog_info);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_info.type);\n\t\t \n\t\tif (prog_type_str)\n\t\t\tprintf(\"\\n\\tprog_type %s  \", prog_type_str);\n\t\telse\n\t\t\tprintf(\"\\n\\tprog_type %u  \", prog_info.type);\n\n\t\tshow_link_attach_type_plain(info->tracing.attach_type);\n\t\tif (info->tracing.target_obj_id || info->tracing.target_btf_id)\n\t\t\tprintf(\"\\n\\ttarget_obj_id %u  target_btf_id %u  \",\n\t\t\t       info->tracing.target_obj_id,\n\t\t\t       info->tracing.target_btf_id);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_CGROUP:\n\t\tprintf(\"\\n\\tcgroup_id %zu  \", (size_t)info->cgroup.cgroup_id);\n\t\tshow_link_attach_type_plain(info->cgroup.attach_type);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_ITER:\n\t\tshow_iter_plain(info);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_NETNS:\n\t\tprintf(\"\\n\\tnetns_ino %u  \", info->netns.netns_ino);\n\t\tshow_link_attach_type_plain(info->netns.attach_type);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_NETFILTER:\n\t\tnetfilter_dump_plain(info);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_TCX:\n\t\tprintf(\"\\n\\t\");\n\t\tshow_link_ifindex_plain(info->tcx.ifindex);\n\t\tshow_link_attach_type_plain(info->tcx.attach_type);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_XDP:\n\t\tprintf(\"\\n\\t\");\n\t\tshow_link_ifindex_plain(info->xdp.ifindex);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_KPROBE_MULTI:\n\t\tshow_kprobe_multi_plain(info);\n\t\tbreak;\n\tcase BPF_LINK_TYPE_PERF_EVENT:\n\t\tswitch (info->perf_event.type) {\n\t\tcase BPF_PERF_EVENT_EVENT:\n\t\t\tshow_perf_event_event_plain(info);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_TRACEPOINT:\n\t\t\tshow_perf_event_tracepoint_plain(info);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_KPROBE:\n\t\tcase BPF_PERF_EVENT_KRETPROBE:\n\t\t\tshow_perf_event_kprobe_plain(info);\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_UPROBE:\n\t\tcase BPF_PERF_EVENT_URETPROBE:\n\t\t\tshow_perf_event_uprobe_plain(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!hashmap__empty(link_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\thashmap__for_each_key_entry(link_table, entry, info->id)\n\t\t\tprintf(\"\\n\\tpinned %s\", (char *)entry->pvalue);\n\t}\n\temit_obj_refs_plain(refs_table, info->id, \"\\n\\tpids \");\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nstatic int do_show_link(int fd)\n{\n\tstruct bpf_link_info info;\n\t__u32 len = sizeof(info);\n\t__u64 *addrs = NULL;\n\tchar buf[PATH_MAX];\n\tint count;\n\tint err;\n\n\tmemset(&info, 0, sizeof(info));\n\tbuf[0] = '\\0';\nagain:\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tif (err) {\n\t\tp_err(\"can't get link info: %s\",\n\t\t      strerror(errno));\n\t\tclose(fd);\n\t\treturn err;\n\t}\n\tif (info.type == BPF_LINK_TYPE_RAW_TRACEPOINT &&\n\t    !info.raw_tracepoint.tp_name) {\n\t\tinfo.raw_tracepoint.tp_name = ptr_to_u64(&buf);\n\t\tinfo.raw_tracepoint.tp_name_len = sizeof(buf);\n\t\tgoto again;\n\t}\n\tif (info.type == BPF_LINK_TYPE_ITER &&\n\t    !info.iter.target_name) {\n\t\tinfo.iter.target_name = ptr_to_u64(&buf);\n\t\tinfo.iter.target_name_len = sizeof(buf);\n\t\tgoto again;\n\t}\n\tif (info.type == BPF_LINK_TYPE_KPROBE_MULTI &&\n\t    !info.kprobe_multi.addrs) {\n\t\tcount = info.kprobe_multi.count;\n\t\tif (count) {\n\t\t\taddrs = calloc(count, sizeof(__u64));\n\t\t\tif (!addrs) {\n\t\t\t\tp_err(\"mem alloc failed\");\n\t\t\t\tclose(fd);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tinfo.kprobe_multi.addrs = ptr_to_u64(addrs);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (info.type == BPF_LINK_TYPE_PERF_EVENT) {\n\t\tswitch (info.perf_event.type) {\n\t\tcase BPF_PERF_EVENT_TRACEPOINT:\n\t\t\tif (!info.perf_event.tracepoint.tp_name) {\n\t\t\t\tinfo.perf_event.tracepoint.tp_name = ptr_to_u64(&buf);\n\t\t\t\tinfo.perf_event.tracepoint.name_len = sizeof(buf);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_KPROBE:\n\t\tcase BPF_PERF_EVENT_KRETPROBE:\n\t\t\tif (!info.perf_event.kprobe.func_name) {\n\t\t\t\tinfo.perf_event.kprobe.func_name = ptr_to_u64(&buf);\n\t\t\t\tinfo.perf_event.kprobe.name_len = sizeof(buf);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_PERF_EVENT_UPROBE:\n\t\tcase BPF_PERF_EVENT_URETPROBE:\n\t\t\tif (!info.perf_event.uprobe.file_name) {\n\t\t\t\tinfo.perf_event.uprobe.file_name = ptr_to_u64(&buf);\n\t\t\t\tinfo.perf_event.uprobe.name_len = sizeof(buf);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tshow_link_close_json(fd, &info);\n\telse\n\t\tshow_link_close_plain(fd, &info);\n\n\tif (addrs)\n\t\tfree(addrs);\n\tclose(fd);\n\treturn 0;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\t__u32 id = 0;\n\tint err, fd;\n\n\tif (show_pinned) {\n\t\tlink_table = hashmap__new(hash_fn_for_key_as_id,\n\t\t\t\t\t  equal_fn_for_key_as_id, NULL);\n\t\tif (IS_ERR(link_table)) {\n\t\t\tp_err(\"failed to create hashmap for pinned paths\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuild_pinned_obj_table(link_table, BPF_OBJ_LINK);\n\t}\n\tbuild_obj_refs_table(&refs_table, BPF_OBJ_LINK);\n\n\tif (argc == 2) {\n\t\tfd = link_parse_fd(&argc, &argv);\n\t\tif (fd < 0)\n\t\t\treturn fd;\n\t\tdo_show_link(fd);\n\t\tgoto out;\n\t}\n\n\tif (argc)\n\t\treturn BAD_ARG();\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\twhile (true) {\n\t\terr = bpf_link_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\tp_err(\"can't get next link: %s%s\", strerror(errno),\n\t\t\t      errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfd = bpf_link_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get link by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\terr = do_show_link(fd);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tdelete_obj_refs_table(refs_table);\n\n\tif (show_pinned)\n\t\tdelete_pinned_obj_table(link_table);\n\nout:\n\tif (dd.sym_count)\n\t\tkernel_syms_destroy(&dd);\n\treturn errno == ENOENT ? 0 : -1;\n}\n\nstatic int do_pin(int argc, char **argv)\n{\n\tint err;\n\n\terr = do_pin_any(argc, argv, link_parse_fd);\n\tif (!err && json_output)\n\t\tjsonw_null(json_wtr);\n\treturn err;\n}\n\nstatic int do_detach(int argc, char **argv)\n{\n\tint err, fd;\n\n\tif (argc != 2) {\n\t\tp_err(\"link specifier is invalid or missing\\n\");\n\t\treturn 1;\n\t}\n\n\tfd = link_parse_fd(&argc, &argv);\n\tif (fd < 0)\n\t\treturn 1;\n\n\terr = bpf_link_detach(fd);\n\tif (err)\n\t\terr = -errno;\n\tclose(fd);\n\tif (err) {\n\t\tp_err(\"failed link detach: %s\", strerror(-err));\n\t\treturn 1;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\treturn 0;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list }   [LINK]\\n\"\n\t\t\"       %1$s %2$s pin        LINK  FILE\\n\"\n\t\t\"       %1$s %2$s detach     LINK\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_LINK \"\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-f|--bpffs} | {-n|--nomount} }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"help\",\tdo_help },\n\t{ \"pin\",\tdo_pin },\n\t{ \"detach\",\tdo_detach },\n\t{ 0 }\n};\n\nint do_link(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}