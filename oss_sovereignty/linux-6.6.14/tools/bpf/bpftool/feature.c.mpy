{
  "module_name": "feature.c",
  "hash_id": "5f00ea796cc0aba81df5bd456cdae9def433cc0307a4a5de10eb3ea8b18883b4",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/feature.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <net/if.h>\n#ifdef USE_LIBCAP\n#include <sys/capability.h>\n#endif\n#include <sys/utsname.h>\n#include <sys/vfs.h>\n\n#include <linux/filter.h>\n#include <linux/limits.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <zlib.h>\n\n#include \"main.h\"\n\n#ifndef PROC_SUPER_MAGIC\n# define PROC_SUPER_MAGIC\t0x9fa0\n#endif\n\nenum probe_component {\n\tCOMPONENT_UNSPEC,\n\tCOMPONENT_KERNEL,\n\tCOMPONENT_DEVICE,\n};\n\n#define BPF_HELPER_MAKE_ENTRY(name)\t[BPF_FUNC_ ## name] = \"bpf_\" # name\nstatic const char * const helper_name[] = {\n\t__BPF_FUNC_MAPPER(BPF_HELPER_MAKE_ENTRY)\n};\n\n#undef BPF_HELPER_MAKE_ENTRY\n\nstatic bool full_mode;\n#ifdef USE_LIBCAP\nstatic bool run_as_unprivileged;\n#endif\n\n \n\nstatic bool grep(const char *buffer, const char *pattern)\n{\n\treturn !!strstr(buffer, pattern);\n}\n\nstatic bool check_procfs(void)\n{\n\tstruct statfs st_fs;\n\n\tif (statfs(\"/proc\", &st_fs) < 0)\n\t\treturn false;\n\tif ((unsigned long)st_fs.f_type != PROC_SUPER_MAGIC)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void uppercase(char *str, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len && str[i] != '\\0'; i++)\n\t\tstr[i] = toupper(str[i]);\n}\n\n \n\nstatic void\nprint_bool_feature(const char *feat_name, const char *plain_name,\n\t\t   const char *define_name, bool res, const char *define_prefix)\n{\n\tif (json_output)\n\t\tjsonw_bool_field(json_wtr, feat_name, res);\n\telse if (define_prefix)\n\t\tprintf(\"#define %s%sHAVE_%s\\n\", define_prefix,\n\t\t       res ? \"\" : \"NO_\", define_name);\n\telse\n\t\tprintf(\"%s is %savailable\\n\", plain_name, res ? \"\" : \"NOT \");\n}\n\nstatic void print_kernel_option(const char *name, const char *value,\n\t\t\t\tconst char *define_prefix)\n{\n\tchar *endptr;\n\tint res;\n\n\tif (json_output) {\n\t\tif (!value) {\n\t\t\tjsonw_null_field(json_wtr, name);\n\t\t\treturn;\n\t\t}\n\t\terrno = 0;\n\t\tres = strtol(value, &endptr, 0);\n\t\tif (!errno && *endptr == '\\n')\n\t\t\tjsonw_int_field(json_wtr, name, res);\n\t\telse\n\t\t\tjsonw_string_field(json_wtr, name, value);\n\t} else if (define_prefix) {\n\t\tif (value)\n\t\t\tprintf(\"#define %s%s %s\\n\", define_prefix,\n\t\t\t       name, value);\n\t\telse\n\t\t\tprintf(\"/* %s%s is not set */\\n\", define_prefix, name);\n\t} else {\n\t\tif (value)\n\t\t\tprintf(\"%s is set to %s\\n\", name, value);\n\t\telse\n\t\t\tprintf(\"%s is not set\\n\", name);\n\t}\n}\n\nstatic void\nprint_start_section(const char *json_title, const char *plain_title,\n\t\t    const char *define_comment, const char *define_prefix)\n{\n\tif (json_output) {\n\t\tjsonw_name(json_wtr, json_title);\n\t\tjsonw_start_object(json_wtr);\n\t} else if (define_prefix) {\n\t\tprintf(\"%s\\n\", define_comment);\n\t} else {\n\t\tprintf(\"%s\\n\", plain_title);\n\t}\n}\n\nstatic void print_end_section(void)\n{\n\tif (json_output)\n\t\tjsonw_end_object(json_wtr);\n\telse\n\t\tprintf(\"\\n\");\n}\n\n \n\nstatic int get_vendor_id(int ifindex)\n{\n\tchar ifname[IF_NAMESIZE], path[64], buf[8];\n\tssize_t len;\n\tint fd;\n\n\tif (!if_indextoname(ifindex, ifname))\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/device/vendor\", ifname);\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tlen = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tif (len < 0)\n\t\treturn -1;\n\tif (len >= (ssize_t)sizeof(buf))\n\t\treturn -1;\n\tbuf[len] = '\\0';\n\n\treturn strtol(buf, NULL, 0);\n}\n\nstatic long read_procfs(const char *path)\n{\n\tchar *endptr, *line = NULL;\n\tsize_t len = 0;\n\tFILE *fd;\n\tlong res;\n\n\tfd = fopen(path, \"r\");\n\tif (!fd)\n\t\treturn -1;\n\n\tres = getline(&line, &len, fd);\n\tfclose(fd);\n\tif (res < 0)\n\t\treturn -1;\n\n\terrno = 0;\n\tres = strtol(line, &endptr, 10);\n\tif (errno || *line == '\\0' || *endptr != '\\n')\n\t\tres = -1;\n\tfree(line);\n\n\treturn res;\n}\n\nstatic void probe_unprivileged_disabled(void)\n{\n\tlong res;\n\n\t \n\n\tres = read_procfs(\"/proc/sys/kernel/unprivileged_bpf_disabled\");\n\tif (json_output) {\n\t\tjsonw_int_field(json_wtr, \"unprivileged_bpf_disabled\", res);\n\t} else {\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tprintf(\"bpf() syscall for unprivileged users is enabled\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"bpf() syscall restricted to privileged users (without recovery)\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"bpf() syscall restricted to privileged users (admin can change)\\n\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tprintf(\"Unable to retrieve required privileges for bpf() syscall\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"bpf() syscall restriction has unknown value %ld\\n\", res);\n\t\t}\n\t}\n}\n\nstatic void probe_jit_enable(void)\n{\n\tlong res;\n\n\t \n\n\tres = read_procfs(\"/proc/sys/net/core/bpf_jit_enable\");\n\tif (json_output) {\n\t\tjsonw_int_field(json_wtr, \"bpf_jit_enable\", res);\n\t} else {\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tprintf(\"JIT compiler is disabled\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"JIT compiler is enabled\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"JIT compiler is enabled with debugging traces in kernel logs\\n\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tprintf(\"Unable to retrieve JIT-compiler status\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"JIT-compiler status has unknown value %ld\\n\",\n\t\t\t       res);\n\t\t}\n\t}\n}\n\nstatic void probe_jit_harden(void)\n{\n\tlong res;\n\n\t \n\n\tres = read_procfs(\"/proc/sys/net/core/bpf_jit_harden\");\n\tif (json_output) {\n\t\tjsonw_int_field(json_wtr, \"bpf_jit_harden\", res);\n\t} else {\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tprintf(\"JIT compiler hardening is disabled\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"JIT compiler hardening is enabled for unprivileged users\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"JIT compiler hardening is enabled for all users\\n\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tprintf(\"Unable to retrieve JIT hardening status\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"JIT hardening status has unknown value %ld\\n\",\n\t\t\t       res);\n\t\t}\n\t}\n}\n\nstatic void probe_jit_kallsyms(void)\n{\n\tlong res;\n\n\t \n\n\tres = read_procfs(\"/proc/sys/net/core/bpf_jit_kallsyms\");\n\tif (json_output) {\n\t\tjsonw_int_field(json_wtr, \"bpf_jit_kallsyms\", res);\n\t} else {\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tprintf(\"JIT compiler kallsyms exports are disabled\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"JIT compiler kallsyms exports are enabled for root\\n\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tprintf(\"Unable to retrieve JIT kallsyms export status\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"JIT kallsyms exports status has unknown value %ld\\n\", res);\n\t\t}\n\t}\n}\n\nstatic void probe_jit_limit(void)\n{\n\tlong res;\n\n\t \n\n\tres = read_procfs(\"/proc/sys/net/core/bpf_jit_limit\");\n\tif (json_output) {\n\t\tjsonw_int_field(json_wtr, \"bpf_jit_limit\", res);\n\t} else {\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tprintf(\"Unable to retrieve global memory limit for JIT compiler for unprivileged users\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Global memory limit for JIT compiler for unprivileged users is %ld bytes\\n\", res);\n\t\t}\n\t}\n}\n\nstatic bool read_next_kernel_config_option(gzFile file, char *buf, size_t n,\n\t\t\t\t\t   char **value)\n{\n\tchar *sep;\n\n\twhile (gzgets(file, buf, n)) {\n\t\tif (strncmp(buf, \"CONFIG_\", 7))\n\t\t\tcontinue;\n\n\t\tsep = strchr(buf, '=');\n\t\tif (!sep)\n\t\t\tcontinue;\n\n\t\t \n\t\tbuf[strlen(buf) - 1] = '\\0';\n\n\t\t \n\t\t*sep = '\\0';\n\t\tif (!sep[1])\n\t\t\tcontinue;\n\n\t\t*value = sep + 1;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void probe_kernel_image_config(const char *define_prefix)\n{\n\tstatic const struct {\n\t\tconst char * const name;\n\t\tbool macro_dump;\n\t} options[] = {\n\t\t \n\t\t{ \"CONFIG_BPF\", },\n\t\t \n\t\t{ \"CONFIG_BPF_SYSCALL\", },\n\t\t \n\t\t{ \"CONFIG_HAVE_EBPF_JIT\", },\n\t\t \n\t\t{ \"CONFIG_BPF_JIT\", },\n\t\t \n\t\t{ \"CONFIG_BPF_JIT_ALWAYS_ON\", },\n\t\t \n\t\t{ \"CONFIG_DEBUG_INFO_BTF\", },\n\t\t \n\t\t{ \"CONFIG_DEBUG_INFO_BTF_MODULES\", },\n\n\t\t \n\t\t{ \"CONFIG_CGROUPS\", },\n\t\t \n\t\t{ \"CONFIG_CGROUP_BPF\", },\n\t\t \n\t\t{ \"CONFIG_CGROUP_NET_CLASSID\", },\n\t\t \n\t\t{ \"CONFIG_SOCK_CGROUP_DATA\", },\n\n\t\t \n\t\t{ \"CONFIG_BPF_EVENTS\", },\n\t\t \n\t\t{ \"CONFIG_KPROBE_EVENTS\", },\n\t\t \n\t\t{ \"CONFIG_UPROBE_EVENTS\", },\n\t\t \n\t\t{ \"CONFIG_TRACING\", },\n\t\t \n\t\t{ \"CONFIG_FTRACE_SYSCALLS\", },\n\t\t \n\t\t{ \"CONFIG_FUNCTION_ERROR_INJECTION\", },\n\t\t \n\t\t{ \"CONFIG_BPF_KPROBE_OVERRIDE\", },\n\n\t\t \n\t\t{ \"CONFIG_NET\", },\n\t\t \n\t\t{ \"CONFIG_XDP_SOCKETS\", },\n\t\t \n\t\t{ \"CONFIG_LWTUNNEL_BPF\", },\n\t\t \n\t\t{ \"CONFIG_NET_ACT_BPF\", },\n\t\t \n\t\t{ \"CONFIG_NET_CLS_BPF\", },\n\t\t \n\t\t{ \"CONFIG_NET_CLS_ACT\", },\n\t\t \n\t\t{ \"CONFIG_NET_SCH_INGRESS\", },\n\t\t \n\t\t{ \"CONFIG_XFRM\", },\n\t\t \n\t\t{ \"CONFIG_IP_ROUTE_CLASSID\", },\n\t\t \n\t\t{ \"CONFIG_IPV6_SEG6_BPF\", },\n\t\t \n\t\t{ \"CONFIG_BPF_LIRC_MODE2\", },\n\t\t \n\t\t{ \"CONFIG_BPF_STREAM_PARSER\", },\n\t\t \n\t\t{ \"CONFIG_NETFILTER_XT_MATCH_BPF\", },\n\t\t \n\t\t{ \"CONFIG_BPFILTER\", },\n\t\t \n\t\t{ \"CONFIG_BPFILTER_UMH\", },\n\n\t\t \n\t\t{ \"CONFIG_TEST_BPF\", },\n\n\t\t \n\t\t \n\t\t{ \"CONFIG_HZ\", true, }\n\t};\n\tchar *values[ARRAY_SIZE(options)] = { };\n\tstruct utsname utsn;\n\tchar path[PATH_MAX];\n\tgzFile file = NULL;\n\tchar buf[4096];\n\tchar *value;\n\tsize_t i;\n\n\tif (!uname(&utsn)) {\n\t\tsnprintf(path, sizeof(path), \"/boot/config-%s\", utsn.release);\n\n\t\t \n\t\tfile = gzopen(path, \"r\");\n\t}\n\n\tif (!file) {\n\t\t \n\t\tfile = gzopen(\"/proc/config.gz\", \"r\");\n\t}\n\tif (!file) {\n\t\tp_info(\"skipping kernel config, can't open file: %s\",\n\t\t       strerror(errno));\n\t\tgoto end_parse;\n\t}\n\t \n\tif (!gzgets(file, buf, sizeof(buf)) ||\n\t    !gzgets(file, buf, sizeof(buf))) {\n\t\tp_info(\"skipping kernel config, can't read from file: %s\",\n\t\t       strerror(errno));\n\t\tgoto end_parse;\n\t}\n\tif (strcmp(buf, \"# Automatically generated file; DO NOT EDIT.\\n\")) {\n\t\tp_info(\"skipping kernel config, can't find correct file\");\n\t\tgoto end_parse;\n\t}\n\n\twhile (read_next_kernel_config_option(file, buf, sizeof(buf), &value)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(options); i++) {\n\t\t\tif ((define_prefix && !options[i].macro_dump) ||\n\t\t\t    values[i] || strcmp(buf, options[i].name))\n\t\t\t\tcontinue;\n\n\t\t\tvalues[i] = strdup(value);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(options); i++) {\n\t\tif (define_prefix && !options[i].macro_dump)\n\t\t\tcontinue;\n\t\tprint_kernel_option(options[i].name, values[i], define_prefix);\n\t\tfree(values[i]);\n\t}\n\nend_parse:\n\tif (file)\n\t\tgzclose(file);\n}\n\nstatic bool probe_bpf_syscall(const char *define_prefix)\n{\n\tbool res;\n\n\tbpf_prog_load(BPF_PROG_TYPE_UNSPEC, NULL, NULL, NULL, 0, NULL);\n\tres = (errno != ENOSYS);\n\n\tprint_bool_feature(\"have_bpf_syscall\",\n\t\t\t   \"bpf() syscall\",\n\t\t\t   \"BPF_SYSCALL\",\n\t\t\t   res, define_prefix);\n\n\treturn res;\n}\n\nstatic bool\nprobe_prog_load_ifindex(enum bpf_prog_type prog_type,\n\t\t\tconst struct bpf_insn *insns, size_t insns_cnt,\n\t\t\tchar *log_buf, size_t log_buf_sz,\n\t\t\t__u32 ifindex)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t    .log_buf = log_buf,\n\t\t    .log_size = log_buf_sz,\n\t\t    .log_level = log_buf ? 1 : 0,\n\t\t    .prog_ifindex = ifindex,\n\t\t   );\n\tint fd;\n\n\terrno = 0;\n\tfd = bpf_prog_load(prog_type, NULL, \"GPL\", insns, insns_cnt, &opts);\n\tif (fd >= 0)\n\t\tclose(fd);\n\n\treturn fd >= 0 && errno != EINVAL && errno != EOPNOTSUPP;\n}\n\nstatic bool probe_prog_type_ifindex(enum bpf_prog_type prog_type, __u32 ifindex)\n{\n\t \n\tstruct bpf_insn insns[2] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 2),\n\t\tBPF_EXIT_INSN()\n\t};\n\n\treturn probe_prog_load_ifindex(prog_type, insns, ARRAY_SIZE(insns),\n\t\t\t\t       NULL, 0, ifindex);\n}\n\nstatic void\nprobe_prog_type(enum bpf_prog_type prog_type, const char *prog_type_str,\n\t\tbool *supported_types, const char *define_prefix, __u32 ifindex)\n{\n\tchar feat_name[128], plain_desc[128], define_name[128];\n\tconst char *plain_comment = \"eBPF program_type \";\n\tsize_t maxlen;\n\tbool res;\n\n\tif (ifindex) {\n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_SCHED_CLS:\n\t\tcase BPF_PROG_TYPE_XDP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\tres = probe_prog_type_ifindex(prog_type, ifindex);\n\t} else {\n\t\tres = libbpf_probe_bpf_prog_type(prog_type, NULL) > 0;\n\t}\n\n#ifdef USE_LIBCAP\n\t \n\tif (run_as_unprivileged && errno == EPERM)\n\t\tres = false;\n#endif\n\n\tsupported_types[prog_type] |= res;\n\n\tmaxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;\n\tif (strlen(prog_type_str) > maxlen) {\n\t\tp_info(\"program type name too long\");\n\t\treturn;\n\t}\n\n\tsprintf(feat_name, \"have_%s_prog_type\", prog_type_str);\n\tsprintf(define_name, \"%s_prog_type\", prog_type_str);\n\tuppercase(define_name, sizeof(define_name));\n\tsprintf(plain_desc, \"%s%s\", plain_comment, prog_type_str);\n\tprint_bool_feature(feat_name, plain_desc, define_name, res,\n\t\t\t   define_prefix);\n}\n\nstatic bool probe_map_type_ifindex(enum bpf_map_type map_type, __u32 ifindex)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tint key_size, value_size, max_entries;\n\tint fd;\n\n\topts.map_ifindex = ifindex;\n\n\tkey_size = sizeof(__u32);\n\tvalue_size = sizeof(__u32);\n\tmax_entries = 1;\n\n\tfd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries,\n\t\t\t    &opts);\n\tif (fd >= 0)\n\t\tclose(fd);\n\n\treturn fd >= 0;\n}\n\nstatic void\nprobe_map_type(enum bpf_map_type map_type, char const *map_type_str,\n\t       const char *define_prefix, __u32 ifindex)\n{\n\tchar feat_name[128], plain_desc[128], define_name[128];\n\tconst char *plain_comment = \"eBPF map_type \";\n\tsize_t maxlen;\n\tbool res;\n\n\tif (ifindex) {\n\t\tswitch (map_type) {\n\t\tcase BPF_MAP_TYPE_HASH:\n\t\tcase BPF_MAP_TYPE_ARRAY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\tres = probe_map_type_ifindex(map_type, ifindex);\n\t} else {\n\t\tres = libbpf_probe_bpf_map_type(map_type, NULL) > 0;\n\t}\n\n\t \n\n\tmaxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;\n\tif (strlen(map_type_str) > maxlen) {\n\t\tp_info(\"map type name too long\");\n\t\treturn;\n\t}\n\n\tsprintf(feat_name, \"have_%s_map_type\", map_type_str);\n\tsprintf(define_name, \"%s_map_type\", map_type_str);\n\tuppercase(define_name, sizeof(define_name));\n\tsprintf(plain_desc, \"%s%s\", plain_comment, map_type_str);\n\tprint_bool_feature(feat_name, plain_desc, define_name, res,\n\t\t\t   define_prefix);\n}\n\nstatic bool\nprobe_helper_ifindex(enum bpf_func_id id, enum bpf_prog_type prog_type,\n\t\t     __u32 ifindex)\n{\n\tstruct bpf_insn insns[2] = {\n\t\tBPF_EMIT_CALL(id),\n\t\tBPF_EXIT_INSN()\n\t};\n\tchar buf[4096] = {};\n\tbool res;\n\n\tprobe_prog_load_ifindex(prog_type, insns, ARRAY_SIZE(insns), buf,\n\t\t\t\tsizeof(buf), ifindex);\n\tres = !grep(buf, \"invalid func \") && !grep(buf, \"unknown func \");\n\n\tswitch (get_vendor_id(ifindex)) {\n\tcase 0x19ee:  \n\t\tres = res && !grep(buf, \"not supported by FW\") &&\n\t\t\t!grep(buf, \"unsupported function id\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic bool\nprobe_helper_for_progtype(enum bpf_prog_type prog_type, bool supported_type,\n\t\t\t  const char *define_prefix, unsigned int id,\n\t\t\t  const char *ptype_name, __u32 ifindex)\n{\n\tbool res = false;\n\n\tif (supported_type) {\n\t\tif (ifindex)\n\t\t\tres = probe_helper_ifindex(id, prog_type, ifindex);\n\t\telse\n\t\t\tres = libbpf_probe_bpf_helper(prog_type, id, NULL) > 0;\n#ifdef USE_LIBCAP\n\t\t \n\t\tif (run_as_unprivileged && errno == EPERM)\n\t\t\tres = false;\n#endif\n\t}\n\n\tif (json_output) {\n\t\tif (res)\n\t\t\tjsonw_string(json_wtr, helper_name[id]);\n\t} else if (define_prefix) {\n\t\tprintf(\"#define %sBPF__PROG_TYPE_%s__HELPER_%s %s\\n\",\n\t\t       define_prefix, ptype_name, helper_name[id],\n\t\t       res ? \"1\" : \"0\");\n\t} else {\n\t\tif (res)\n\t\t\tprintf(\"\\n\\t- %s\", helper_name[id]);\n\t}\n\n\treturn res;\n}\n\nstatic void\nprobe_helpers_for_progtype(enum bpf_prog_type prog_type,\n\t\t\t   const char *prog_type_str, bool supported_type,\n\t\t\t   const char *define_prefix, __u32 ifindex)\n{\n\tchar feat_name[128];\n\tunsigned int id;\n\tbool probe_res = false;\n\n\tif (ifindex)\n\t\t \n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_SCHED_CLS:\n\t\tcase BPF_PROG_TYPE_XDP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\tif (json_output) {\n\t\tsprintf(feat_name, \"%s_available_helpers\", prog_type_str);\n\t\tjsonw_name(json_wtr, feat_name);\n\t\tjsonw_start_array(json_wtr);\n\t} else if (!define_prefix) {\n\t\tprintf(\"eBPF helpers supported for program type %s:\",\n\t\t       prog_type_str);\n\t}\n\n\tfor (id = 1; id < ARRAY_SIZE(helper_name); id++) {\n\t\t \n\t\tswitch (id) {\n\t\tcase BPF_FUNC_trace_printk:\n\t\tcase BPF_FUNC_trace_vprintk:\n\t\tcase BPF_FUNC_probe_write_user:\n\t\t\tif (!full_mode)\n\t\t\t\tcontinue;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tprobe_res |= probe_helper_for_progtype(prog_type, supported_type,\n\t\t\t\t\t\t  define_prefix, id, prog_type_str,\n\t\t\t\t\t\t  ifindex);\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\telse if (!define_prefix) {\n\t\tprintf(\"\\n\");\n\t\tif (!probe_res) {\n\t\t\tif (!supported_type)\n\t\t\t\tprintf(\"\\tProgram type not supported\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"\\tCould not determine which helpers are available\\n\");\n\t\t}\n\t}\n\n\n}\n\nstatic void\nprobe_misc_feature(struct bpf_insn *insns, size_t len,\n\t\t   const char *define_prefix, __u32 ifindex,\n\t\t   const char *feat_name, const char *plain_name,\n\t\t   const char *define_name)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.prog_ifindex = ifindex,\n\t);\n\tbool res;\n\tint fd;\n\n\terrno = 0;\n\tfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, \"GPL\",\n\t\t\t   insns, len, &opts);\n\tres = fd >= 0 || !errno;\n\n\tif (fd >= 0)\n\t\tclose(fd);\n\n\tprint_bool_feature(feat_name, plain_name, define_name, res,\n\t\t\t   define_prefix);\n}\n\n \nstatic void probe_large_insn_limit(const char *define_prefix, __u32 ifindex)\n{\n\tstruct bpf_insn insns[BPF_MAXINSNS + 1];\n\tint i;\n\n\tfor (i = 0; i < BPF_MAXINSNS; i++)\n\t\tinsns[i] = BPF_MOV64_IMM(BPF_REG_0, 1);\n\tinsns[BPF_MAXINSNS] = BPF_EXIT_INSN();\n\n\tprobe_misc_feature(insns, ARRAY_SIZE(insns),\n\t\t\t   define_prefix, ifindex,\n\t\t\t   \"have_large_insn_limit\",\n\t\t\t   \"Large program size limit\",\n\t\t\t   \"LARGE_INSN_LIMIT\");\n}\n\n \nstatic void\nprobe_bounded_loops(const char *define_prefix, __u32 ifindex)\n{\n\tstruct bpf_insn insns[4] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 10),\n\t\tBPF_ALU64_IMM(BPF_SUB, BPF_REG_0, 1),\n\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, -2),\n\t\tBPF_EXIT_INSN()\n\t};\n\n\tprobe_misc_feature(insns, ARRAY_SIZE(insns),\n\t\t\t   define_prefix, ifindex,\n\t\t\t   \"have_bounded_loops\",\n\t\t\t   \"Bounded loop support\",\n\t\t\t   \"BOUNDED_LOOPS\");\n}\n\n \nstatic void\nprobe_v2_isa_extension(const char *define_prefix, __u32 ifindex)\n{\n\tstruct bpf_insn insns[4] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_JMP_IMM(BPF_JLT, BPF_REG_0, 0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN()\n\t};\n\n\tprobe_misc_feature(insns, ARRAY_SIZE(insns),\n\t\t\t   define_prefix, ifindex,\n\t\t\t   \"have_v2_isa_extension\",\n\t\t\t   \"ISA extension v2\",\n\t\t\t   \"V2_ISA_EXTENSION\");\n}\n\n \nstatic void\nprobe_v3_isa_extension(const char *define_prefix, __u32 ifindex)\n{\n\tstruct bpf_insn insns[4] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_JMP32_IMM(BPF_JLT, BPF_REG_0, 0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN()\n\t};\n\n\tprobe_misc_feature(insns, ARRAY_SIZE(insns),\n\t\t\t   define_prefix, ifindex,\n\t\t\t   \"have_v3_isa_extension\",\n\t\t\t   \"ISA extension v3\",\n\t\t\t   \"V3_ISA_EXTENSION\");\n}\n\nstatic void\nsection_system_config(enum probe_component target, const char *define_prefix)\n{\n\tswitch (target) {\n\tcase COMPONENT_KERNEL:\n\tcase COMPONENT_UNSPEC:\n\t\tprint_start_section(\"system_config\",\n\t\t\t\t    \"Scanning system configuration...\",\n\t\t\t\t    \"/*** Misc kernel config items ***/\",\n\t\t\t\t    define_prefix);\n\t\tif (!define_prefix) {\n\t\t\tif (check_procfs()) {\n\t\t\t\tprobe_unprivileged_disabled();\n\t\t\t\tprobe_jit_enable();\n\t\t\t\tprobe_jit_harden();\n\t\t\t\tprobe_jit_kallsyms();\n\t\t\t\tprobe_jit_limit();\n\t\t\t} else {\n\t\t\t\tp_info(\"/* procfs not mounted, skipping related probes */\");\n\t\t\t}\n\t\t}\n\t\tprobe_kernel_image_config(define_prefix);\n\t\tprint_end_section();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool section_syscall_config(const char *define_prefix)\n{\n\tbool res;\n\n\tprint_start_section(\"syscall_config\",\n\t\t\t    \"Scanning system call availability...\",\n\t\t\t    \"/*** System call availability ***/\",\n\t\t\t    define_prefix);\n\tres = probe_bpf_syscall(define_prefix);\n\tprint_end_section();\n\n\treturn res;\n}\n\nstatic void\nsection_program_types(bool *supported_types, const char *define_prefix,\n\t\t      __u32 ifindex)\n{\n\tunsigned int prog_type = BPF_PROG_TYPE_UNSPEC;\n\tconst char *prog_type_str;\n\n\tprint_start_section(\"program_types\",\n\t\t\t    \"Scanning eBPF program types...\",\n\t\t\t    \"/*** eBPF program types ***/\",\n\t\t\t    define_prefix);\n\n\twhile (true) {\n\t\tprog_type++;\n\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_type);\n\t\t \n\t\tif (!prog_type_str)\n\t\t\tbreak;\n\n\t\tprobe_prog_type(prog_type, prog_type_str, supported_types, define_prefix,\n\t\t\t\tifindex);\n\t}\n\n\tprint_end_section();\n}\n\nstatic void section_map_types(const char *define_prefix, __u32 ifindex)\n{\n\tunsigned int map_type = BPF_MAP_TYPE_UNSPEC;\n\tconst char *map_type_str;\n\n\tprint_start_section(\"map_types\",\n\t\t\t    \"Scanning eBPF map types...\",\n\t\t\t    \"/*** eBPF map types ***/\",\n\t\t\t    define_prefix);\n\n\twhile (true) {\n\t\tmap_type++;\n\t\tmap_type_str = libbpf_bpf_map_type_str(map_type);\n\t\t \n\t\tif (!map_type_str)\n\t\t\tbreak;\n\n\t\tprobe_map_type(map_type, map_type_str, define_prefix, ifindex);\n\t}\n\n\tprint_end_section();\n}\n\nstatic void\nsection_helpers(bool *supported_types, const char *define_prefix, __u32 ifindex)\n{\n\tunsigned int prog_type = BPF_PROG_TYPE_UNSPEC;\n\tconst char *prog_type_str;\n\n\tprint_start_section(\"helpers\",\n\t\t\t    \"Scanning eBPF helper functions...\",\n\t\t\t    \"/*** eBPF helper functions ***/\",\n\t\t\t    define_prefix);\n\n\tif (define_prefix)\n\t\tprintf(\"/*\\n\"\n\t\t       \" * Use %sHAVE_PROG_TYPE_HELPER(prog_type_name, helper_name)\\n\"\n\t\t       \" * to determine if <helper_name> is available for <prog_type_name>,\\n\"\n\t\t       \" * e.g.\\n\"\n\t\t       \" *\t#if %sHAVE_PROG_TYPE_HELPER(xdp, bpf_redirect)\\n\"\n\t\t       \" *\t\t// do stuff with this helper\\n\"\n\t\t       \" *\t#elif\\n\"\n\t\t       \" *\t\t// use a workaround\\n\"\n\t\t       \" *\t#endif\\n\"\n\t\t       \" */\\n\"\n\t\t       \"#define %sHAVE_PROG_TYPE_HELPER(prog_type, helper)\t\\\\\\n\"\n\t\t       \"\t%sBPF__PROG_TYPE_ ## prog_type ## __HELPER_ ## helper\\n\",\n\t\t       define_prefix, define_prefix, define_prefix,\n\t\t       define_prefix);\n\twhile (true) {\n\t\tprog_type++;\n\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_type);\n\t\t \n\t\tif (!prog_type_str)\n\t\t\tbreak;\n\n\t\tprobe_helpers_for_progtype(prog_type, prog_type_str,\n\t\t\t\t\t   supported_types[prog_type],\n\t\t\t\t\t   define_prefix,\n\t\t\t\t\t   ifindex);\n\t}\n\n\tprint_end_section();\n}\n\nstatic void section_misc(const char *define_prefix, __u32 ifindex)\n{\n\tprint_start_section(\"misc\",\n\t\t\t    \"Scanning miscellaneous eBPF features...\",\n\t\t\t    \"/*** eBPF misc features ***/\",\n\t\t\t    define_prefix);\n\tprobe_large_insn_limit(define_prefix, ifindex);\n\tprobe_bounded_loops(define_prefix, ifindex);\n\tprobe_v2_isa_extension(define_prefix, ifindex);\n\tprobe_v3_isa_extension(define_prefix, ifindex);\n\tprint_end_section();\n}\n\n#ifdef USE_LIBCAP\n#define capability(c) { c, false, #c }\n#define capability_msg(a, i) a[i].set ? \"\" : a[i].name, a[i].set ? \"\" : \", \"\n#endif\n\nstatic int handle_perms(void)\n{\n#ifdef USE_LIBCAP\n\tstruct {\n\t\tcap_value_t cap;\n\t\tbool set;\n\t\tchar name[14];\t \n\t} bpf_caps[] = {\n\t\tcapability(CAP_SYS_ADMIN),\n#ifdef CAP_BPF\n\t\tcapability(CAP_BPF),\n\t\tcapability(CAP_NET_ADMIN),\n\t\tcapability(CAP_PERFMON),\n#endif\n\t};\n\tcap_value_t cap_list[ARRAY_SIZE(bpf_caps)];\n\tunsigned int i, nb_bpf_caps = 0;\n\tbool cap_sys_admin_only = true;\n\tcap_flag_value_t val;\n\tint res = -1;\n\tcap_t caps;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tp_err(\"failed to get capabilities for process: %s\",\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n#ifdef CAP_BPF\n\tif (CAP_IS_SUPPORTED(CAP_BPF))\n\t\tcap_sys_admin_only = false;\n#endif\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_caps); i++) {\n\t\tconst char *cap_name = bpf_caps[i].name;\n\t\tcap_value_t cap = bpf_caps[i].cap;\n\n\t\tif (cap_get_flag(caps, cap, CAP_EFFECTIVE, &val)) {\n\t\t\tp_err(\"bug: failed to retrieve %s status: %s\", cap_name,\n\t\t\t      strerror(errno));\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (val == CAP_SET) {\n\t\t\tbpf_caps[i].set = true;\n\t\t\tcap_list[nb_bpf_caps++] = cap;\n\t\t}\n\n\t\tif (cap_sys_admin_only)\n\t\t\t \n\t\t\tbreak;\n\t}\n\n\tif ((run_as_unprivileged && !nb_bpf_caps) ||\n\t    (!run_as_unprivileged && nb_bpf_caps == ARRAY_SIZE(bpf_caps)) ||\n\t    (!run_as_unprivileged && cap_sys_admin_only && nb_bpf_caps)) {\n\t\t \n\t\tres = 0;\n\t\tgoto exit_free;\n\t}\n\n\tif (!run_as_unprivileged) {\n\t\tif (cap_sys_admin_only)\n\t\t\tp_err(\"missing %s, required for full feature probing; run as root or use 'unprivileged'\",\n\t\t\t      bpf_caps[0].name);\n\t\telse\n\t\t\tp_err(\"missing %s%s%s%s%s%s%s%srequired for full feature probing; run as root or use 'unprivileged'\",\n\t\t\t      capability_msg(bpf_caps, 0),\n#ifdef CAP_BPF\n\t\t\t      capability_msg(bpf_caps, 1),\n\t\t\t      capability_msg(bpf_caps, 2),\n\t\t\t      capability_msg(bpf_caps, 3)\n#else\n\t\t\t\t\"\", \"\", \"\", \"\", \"\", \"\"\n#endif  \n\t\t\t\t);\n\t\tgoto exit_free;\n\t}\n\n\t \n\tif (cap_set_flag(caps, CAP_EFFECTIVE, nb_bpf_caps, cap_list,\n\t\t\t CAP_CLEAR)) {\n\t\tp_err(\"bug: failed to clear capabilities: %s\", strerror(errno));\n\t\tgoto exit_free;\n\t}\n\n\tif (cap_set_proc(caps)) {\n\t\tp_err(\"failed to drop capabilities: %s\", strerror(errno));\n\t\tgoto exit_free;\n\t}\n\n\tres = 0;\n\nexit_free:\n\tif (cap_free(caps) && !res) {\n\t\tp_err(\"failed to clear storage object for capabilities: %s\",\n\t\t      strerror(errno));\n\t\tres = -1;\n\t}\n\n\treturn res;\n#else\n\t \n\tif (geteuid()) {\n\t\tp_err(\"full feature probing requires root privileges\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n#endif  \n}\n\nstatic int do_probe(int argc, char **argv)\n{\n\tenum probe_component target = COMPONENT_UNSPEC;\n\tconst char *define_prefix = NULL;\n\tbool supported_types[128] = {};\n\t__u32 ifindex = 0;\n\tchar *ifname;\n\n\tset_max_rlimit();\n\n\twhile (argc) {\n\t\tif (is_prefix(*argv, \"kernel\")) {\n\t\t\tif (target != COMPONENT_UNSPEC) {\n\t\t\t\tp_err(\"component to probe already specified\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ttarget = COMPONENT_KERNEL;\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"dev\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (target != COMPONENT_UNSPEC || ifindex) {\n\t\t\t\tp_err(\"component to probe already specified\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\ttarget = COMPONENT_DEVICE;\n\t\t\tifname = GET_ARG();\n\t\t\tifindex = if_nametoindex(ifname);\n\t\t\tif (!ifindex) {\n\t\t\t\tp_err(\"unrecognized netdevice '%s': %s\", ifname,\n\t\t\t\t      strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (is_prefix(*argv, \"full\")) {\n\t\t\tfull_mode = true;\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"macros\") && !define_prefix) {\n\t\t\tdefine_prefix = \"\";\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"prefix\")) {\n\t\t\tif (!define_prefix) {\n\t\t\t\tp_err(\"'prefix' argument can only be use after 'macros'\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (strcmp(define_prefix, \"\")) {\n\t\t\t\tp_err(\"'prefix' already defined\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\t\t\tdefine_prefix = GET_ARG();\n\t\t} else if (is_prefix(*argv, \"unprivileged\")) {\n#ifdef USE_LIBCAP\n\t\t\trun_as_unprivileged = true;\n\t\t\tNEXT_ARG();\n#else\n\t\t\tp_err(\"unprivileged run not supported, recompile bpftool with libcap\");\n\t\t\treturn -1;\n#endif\n\t\t} else {\n\t\t\tp_err(\"expected no more arguments, 'kernel', 'dev', 'macros' or 'prefix', got: '%s'?\",\n\t\t\t      *argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (handle_perms())\n\t\treturn -1;\n\n\tif (json_output) {\n\t\tdefine_prefix = NULL;\n\t\tjsonw_start_object(json_wtr);\n\t}\n\n\tsection_system_config(target, define_prefix);\n\tif (!section_syscall_config(define_prefix))\n\t\t \n\t\tgoto exit_close_json;\n\tsection_program_types(supported_types, define_prefix, ifindex);\n\tsection_map_types(define_prefix, ifindex);\n\tsection_helpers(supported_types, define_prefix, ifindex);\n\tsection_misc(define_prefix, ifindex);\n\nexit_close_json:\n\tif (json_output)\n\t\t \n\t\tjsonw_end_object(json_wtr);\n\n\treturn 0;\n}\n\nstatic const char *get_helper_name(unsigned int id)\n{\n\tif (id >= ARRAY_SIZE(helper_name))\n\t\treturn NULL;\n\n\treturn helper_name[id];\n}\n\nstatic int do_list_builtins(int argc, char **argv)\n{\n\tconst char *(*get_name)(unsigned int id);\n\tunsigned int id = 0;\n\n\tif (argc < 1)\n\t\tusage();\n\n\tif (is_prefix(*argv, \"prog_types\")) {\n\t\tget_name = (const char *(*)(unsigned int))libbpf_bpf_prog_type_str;\n\t} else if (is_prefix(*argv, \"map_types\")) {\n\t\tget_name = (const char *(*)(unsigned int))libbpf_bpf_map_type_str;\n\t} else if (is_prefix(*argv, \"attach_types\")) {\n\t\tget_name = (const char *(*)(unsigned int))libbpf_bpf_attach_type_str;\n\t} else if (is_prefix(*argv, \"link_types\")) {\n\t\tget_name = (const char *(*)(unsigned int))libbpf_bpf_link_type_str;\n\t} else if (is_prefix(*argv, \"helpers\")) {\n\t\tget_name = get_helper_name;\n\t} else {\n\t\tp_err(\"expected 'prog_types', 'map_types', 'attach_types', 'link_types' or 'helpers', got: %s\", *argv);\n\t\treturn -1;\n\t}\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\t \n\n\twhile (true) {\n\t\tconst char *name;\n\n\t\tname = get_name(id++);\n\t\tif (!name)\n\t\t\tbreak;\n\t\tif (json_output)\n\t\t\tjsonw_string(json_wtr, name);\n\t\telse\n\t\t\tprintf(\"%s\\n\", name);\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\t \n\n\treturn 0;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s probe [COMPONENT] [full] [unprivileged] [macros [prefix PREFIX]]\\n\"\n\t\t\"       %1$s %2$s list_builtins GROUP\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       COMPONENT := { kernel | dev NAME }\\n\"\n\t\t\"       GROUP := { prog_types | map_types | attach_types | link_types | helpers }\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"probe\",\t\tdo_probe },\n\t{ \"list_builtins\",\tdo_list_builtins },\n\t{ \"help\",\t\tdo_help },\n\t{ 0 }\n};\n\nint do_feature(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}