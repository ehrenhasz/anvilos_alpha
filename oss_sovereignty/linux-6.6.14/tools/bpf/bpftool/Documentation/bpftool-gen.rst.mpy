{
  "module_name": "bpftool-gen.rst",
  "hash_id": "b54fad85349ea90b5877a15e3afb81739a4a6d1c2f528d15a168835434166f07",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/Documentation/bpftool-gen.rst",
  "human_readable_source": ".. SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n\n================\nbpftool-gen\n================\n-------------------------------------------------------------------------------\ntool for BPF code-generation\n-------------------------------------------------------------------------------\n\n:Manual section: 8\n\n.. include:: substitutions.rst\n\nSYNOPSIS\n========\n\n\t**bpftool** [*OPTIONS*] **gen** *COMMAND*\n\n\t*OPTIONS* := { |COMMON_OPTIONS| | { **-L** | **--use-loader** } }\n\n\t*COMMAND* := { **object** | **skeleton** | **help** }\n\nGEN COMMANDS\n=============\n\n|\t**bpftool** **gen object** *OUTPUT_FILE* *INPUT_FILE* [*INPUT_FILE*...]\n|\t**bpftool** **gen skeleton** *FILE* [**name** *OBJECT_NAME*]\n|\t**bpftool** **gen subskeleton** *FILE* [**name** *OBJECT_NAME*]\n|\t**bpftool** **gen min_core_btf** *INPUT* *OUTPUT* *OBJECT* [*OBJECT*...]\n|\t**bpftool** **gen help**\n\nDESCRIPTION\n===========\n\t**bpftool gen object** *OUTPUT_FILE* *INPUT_FILE* [*INPUT_FILE*...]\n\t\t  Statically link (combine) together one or more *INPUT_FILE*'s\n\t\t  into a single resulting *OUTPUT_FILE*. All the files involved\n\t\t  are BPF ELF object files.\n\n\t\t  The rules of BPF static linking are mostly the same as for\n\t\t  user-space object files, but in addition to combining data\n\t\t  and instruction sections, .BTF and .BTF.ext (if present in\n\t\t  any of the input files) data are combined together. .BTF\n\t\t  data is deduplicated, so all the common types across\n\t\t  *INPUT_FILE*'s will only be represented once in the resulting\n\t\t  BTF information.\n\n\t\t  BPF static linking allows to partition BPF source code into\n\t\t  individually compiled files that are then linked into\n\t\t  a single resulting BPF object file, which can be used to\n\t\t  generated BPF skeleton (with **gen skeleton** command) or\n\t\t  passed directly into **libbpf** (using **bpf_object__open()**\n\t\t  family of APIs).\n\n\t**bpftool gen skeleton** *FILE*\n\t\t  Generate BPF skeleton C header file for a given *FILE*.\n\n\t\t  BPF skeleton is an alternative interface to existing libbpf\n\t\t  APIs for working with BPF objects. Skeleton code is intended\n\t\t  to significantly shorten and simplify code to load and work\n\t\t  with BPF programs from userspace side. Generated code is\n\t\t  tailored to specific input BPF object *FILE*, reflecting its\n\t\t  structure by listing out available maps, program, variables,\n\t\t  etc. Skeleton eliminates the need to lookup mentioned\n\t\t  components by name. Instead, if skeleton instantiation\n\t\t  succeeds, they are populated in skeleton structure as valid\n\t\t  libbpf types (e.g., **struct bpf_map** pointer) and can be\n\t\t  passed to existing generic libbpf APIs.\n\n\t\t  In addition to simple and reliable access to maps and\n\t\t  programs, skeleton provides a storage for BPF links (**struct\n\t\t  bpf_link**) for each BPF program within BPF object. When\n\t\t  requested, supported BPF programs will be automatically\n\t\t  attached and resulting BPF links stored for further use by\n\t\t  user in pre-allocated fields in skeleton struct. For BPF\n\t\t  programs that can't be automatically attached by libbpf,\n\t\t  user can attach them manually, but store resulting BPF link\n\t\t  in per-program link field. All such set up links will be\n\t\t  automatically destroyed on BPF skeleton destruction. This\n\t\t  eliminates the need for users to manage links manually and\n\t\t  rely on libbpf support to detach programs and free up\n\t\t  resources.\n\n\t\t  Another facility provided by BPF skeleton is an interface to\n\t\t  global variables of all supported kinds: mutable, read-only,\n\t\t  as well as extern ones. This interface allows to pre-setup\n\t\t  initial values of variables before BPF object is loaded and\n\t\t  verified by kernel. For non-read-only variables, the same\n\t\t  interface can be used to fetch values of global variables on\n\t\t  userspace side, even if they are modified by BPF code.\n\n\t\t  During skeleton generation, contents of source BPF object\n\t\t  *FILE* is embedded within generated code and is thus not\n\t\t  necessary to keep around. This ensures skeleton and BPF\n\t\t  object file are matching 1-to-1 and always stay in sync.\n\t\t  Generated code is dual-licensed under LGPL-2.1 and\n\t\t  BSD-2-Clause licenses.\n\n\t\t  It is a design goal and guarantee that skeleton interfaces\n\t\t  are interoperable with generic libbpf APIs. User should\n\t\t  always be able to use skeleton API to create and load BPF\n\t\t  object, and later use libbpf APIs to keep working with\n\t\t  specific maps, programs, etc.\n\n\t\t  As part of skeleton, few custom functions are generated.\n\t\t  Each of them is prefixed with object name. Object name can\n\t\t  either be derived from object file name, i.e., if BPF object\n\t\t  file name is **example.o**, BPF object name will be\n\t\t  **example**. Object name can be also specified explicitly\n\t\t  through **name** *OBJECT_NAME* parameter. The following\n\t\t  custom functions are provided (assuming **example** as\n\t\t  the object name):\n\n\t\t  - **example__open** and **example__open_opts**.\n\t\t    These functions are used to instantiate skeleton. It\n\t\t    corresponds to libbpf's **bpf_object__open**\\ () API.\n\t\t    **_opts** variants accepts extra **bpf_object_open_opts**\n\t\t    options.\n\n\t\t  - **example__load**.\n\t\t    This function creates maps, loads and verifies BPF\n\t\t    programs, initializes global data maps. It corresponds to\n\t\t    libppf's **bpf_object__load**\\ () API.\n\n\t\t  - **example__open_and_load** combines **example__open** and\n\t\t    **example__load** invocations in one commonly used\n\t\t    operation.\n\n\t\t  - **example__attach** and **example__detach**\n\t\t    This pair of functions allow to attach and detach,\n\t\t    correspondingly, already loaded BPF object. Only BPF\n\t\t    programs of types supported by libbpf for auto-attachment\n\t\t    will be auto-attached and their corresponding BPF links\n\t\t    instantiated. For other BPF programs, user can manually\n\t\t    create a BPF link and assign it to corresponding fields in\n\t\t    skeleton struct. **example__detach** will detach both\n\t\t    links created automatically, as well as those populated by\n\t\t    user manually.\n\n\t\t  - **example__destroy**\n\t\t    Detach and unload BPF programs, free up all the resources\n\t\t    used by skeleton and BPF object.\n\n\t\t  If BPF object has global variables, corresponding structs\n\t\t  with memory layout corresponding to global data data section\n\t\t  layout will be created. Currently supported ones are: *.data*,\n\t\t  *.bss*, *.rodata*, and *.kconfig* structs/data sections.\n\t\t  These data sections/structs can be used to set up initial\n\t\t  values of variables, if set before **example__load**.\n\t\t  Afterwards, if target kernel supports memory-mapped BPF\n\t\t  arrays, same structs can be used to fetch and update\n\t\t  (non-read-only) data from userspace, with same simplicity\n\t\t  as for BPF side.\n\n\t**bpftool gen subskeleton** *FILE*\n\t\t  Generate BPF subskeleton C header file for a given *FILE*.\n\n\t\t  Subskeletons are similar to skeletons, except they do not own\n\t\t  the corresponding maps, programs, or global variables. They\n\t\t  require that the object file used to generate them is already\n\t\t  loaded into a *bpf_object* by some other means.\n\n\t\t  This functionality is useful when a library is included into a\n\t\t  larger BPF program. A subskeleton for the library would have\n\t\t  access to all objects and globals defined in it, without\n\t\t  having to know about the larger program.\n\n\t\t  Consequently, there are only two functions defined\n\t\t  for subskeletons:\n\n\t\t  - **example__open(bpf_object\\*)**\n\t\t    Instantiates a subskeleton from an already opened (but not\n\t\t    necessarily loaded) **bpf_object**.\n\n\t\t  - **example__destroy()**\n\t\t    Frees the storage for the subskeleton but *does not* unload\n\t\t    any BPF programs or maps.\n\n\t**bpftool** **gen min_core_btf** *INPUT* *OUTPUT* *OBJECT* [*OBJECT*...]\n\t\t  Generate a minimum BTF file as *OUTPUT*, derived from a given\n\t\t  *INPUT* BTF file, containing all needed BTF types so one, or\n\t\t  more, given eBPF objects CO-RE relocations may be satisfied.\n\n\t\t  When kernels aren't compiled with CONFIG_DEBUG_INFO_BTF,\n\t\t  libbpf, when loading an eBPF object, has to rely on external\n\t\t  BTF files to be able to calculate CO-RE relocations.\n\n\t\t  Usually, an external BTF file is built from existing kernel\n\t\t  DWARF data using pahole. It contains all the types used by\n\t\t  its respective kernel image and, because of that, is big.\n\n\t\t  The min_core_btf feature builds smaller BTF files, customized\n\t\t  to one or multiple eBPF objects, so they can be distributed\n\t\t  together with an eBPF CO-RE based application, turning the\n\t\t  application portable to different kernel versions.\n\n\t\t  Check examples bellow for more information how to use it.\n\n\t**bpftool gen help**\n\t\t  Print short help message.\n\nOPTIONS\n=======\n\t.. include:: common_options.rst\n\n\t-L, --use-loader\n\t\t  For skeletons, generate a \"light\" skeleton (also known as \"loader\"\n\t\t  skeleton). A light skeleton contains a loader eBPF program. It does\n\t\t  not use the majority of the libbpf infrastructure, and does not need\n\t\t  libelf.\n\nEXAMPLES\n========\n**$ cat example1.bpf.c**\n\n::\n\n  #include <stdbool.h>\n  #include <linux/ptrace.h>\n  #include <linux/bpf.h>\n  #include <bpf/bpf_helpers.h>\n\n  const volatile int param1 = 42;\n  bool global_flag = true;\n  struct { int x; } data = {};\n\n  SEC(\"raw_tp/sys_enter\")\n  int handle_sys_enter(struct pt_regs *ctx)\n  {\n  \tstatic long my_static_var;\n  \tif (global_flag)\n  \t\tmy_static_var++;\n  \telse\n  \t\tdata.x += param1;\n  \treturn 0;\n  }\n\n**$ cat example2.bpf.c**\n\n::\n\n  #include <linux/ptrace.h>\n  #include <linux/bpf.h>\n  #include <bpf/bpf_helpers.h>\n\n  struct {\n  \t__uint(type, BPF_MAP_TYPE_HASH);\n  \t__uint(max_entries, 128);\n  \t__type(key, int);\n  \t__type(value, long);\n  } my_map SEC(\".maps\");\n\n  SEC(\"raw_tp/sys_exit\")\n  int handle_sys_exit(struct pt_regs *ctx)\n  {\n  \tint zero = 0;\n  \tbpf_map_lookup_elem(&my_map, &zero);\n  \treturn 0;\n  }\n\nThis is example BPF application with two BPF programs and a mix of BPF maps\nand global variables. Source code is split across two source code files.\n\n**$ clang --target=bpf -g example1.bpf.c -o example1.bpf.o**\n\n**$ clang --target=bpf -g example2.bpf.c -o example2.bpf.o**\n\n**$ bpftool gen object example.bpf.o example1.bpf.o example2.bpf.o**\n\nThis set of commands compiles *example1.bpf.c* and *example2.bpf.c*\nindividually and then statically links respective object files into the final\nBPF ELF object file *example.bpf.o*.\n\n**$ bpftool gen skeleton example.bpf.o name example | tee example.skel.h**\n\n::\n\n  /* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n\n  /* THIS FILE IS AUTOGENERATED! */\n  #ifndef __EXAMPLE_SKEL_H__\n  #define __EXAMPLE_SKEL_H__\n\n  #include <stdlib.h>\n  #include <bpf/libbpf.h>\n\n  struct example {\n  \tstruct bpf_object_skeleton *skeleton;\n  \tstruct bpf_object *obj;\n  \tstruct {\n  \t\tstruct bpf_map *rodata;\n  \t\tstruct bpf_map *data;\n  \t\tstruct bpf_map *bss;\n  \t\tstruct bpf_map *my_map;\n  \t} maps;\n  \tstruct {\n  \t\tstruct bpf_program *handle_sys_enter;\n  \t\tstruct bpf_program *handle_sys_exit;\n  \t} progs;\n  \tstruct {\n  \t\tstruct bpf_link *handle_sys_enter;\n  \t\tstruct bpf_link *handle_sys_exit;\n  \t} links;\n  \tstruct example__bss {\n  \t\tstruct {\n  \t\t\tint x;\n  \t\t} data;\n  \t} *bss;\n  \tstruct example__data {\n  \t\t_Bool global_flag;\n  \t\tlong int handle_sys_enter_my_static_var;\n  \t} *data;\n  \tstruct example__rodata {\n  \t\tint param1;\n  \t} *rodata;\n  };\n\n  static void example__destroy(struct example *obj);\n  static inline struct example *example__open_opts(\n                const struct bpf_object_open_opts *opts);\n  static inline struct example *example__open();\n  static inline int example__load(struct example *obj);\n  static inline struct example *example__open_and_load();\n  static inline int example__attach(struct example *obj);\n  static inline void example__detach(struct example *obj);\n\n  #endif /* __EXAMPLE_SKEL_H__ */\n\n**$ cat example.c**\n\n::\n\n  #include \"example.skel.h\"\n\n  int main()\n  {\n  \tstruct example *skel;\n  \tint err = 0;\n\n  \tskel = example__open();\n  \tif (!skel)\n  \t\tgoto cleanup;\n\n  \tskel->rodata->param1 = 128;\n\n  \terr = example__load(skel);\n  \tif (err)\n  \t\tgoto cleanup;\n\n  \terr = example__attach(skel);\n  \tif (err)\n  \t\tgoto cleanup;\n\n  \t/* all libbpf APIs are usable */\n  \tprintf(\"my_map name: %s\\n\", bpf_map__name(skel->maps.my_map));\n  \tprintf(\"sys_enter prog FD: %d\\n\",\n  \t       bpf_program__fd(skel->progs.handle_sys_enter));\n\n  \t/* detach and re-attach sys_exit program */\n  \tbpf_link__destroy(skel->links.handle_sys_exit);\n  \tskel->links.handle_sys_exit =\n  \t\tbpf_program__attach(skel->progs.handle_sys_exit);\n\n  \tprintf(\"my_static_var: %ld\\n\",\n  \t       skel->bss->handle_sys_enter_my_static_var);\n\n  cleanup:\n  \texample__destroy(skel);\n  \treturn err;\n  }\n\n**# ./example**\n\n::\n\n  my_map name: my_map\n  sys_enter prog FD: 8\n  my_static_var: 7\n\nThis is a stripped-out version of skeleton generated for above example code.\n\nmin_core_btf\n------------\n\n**$ bpftool btf dump file 5.4.0-example.btf format raw**\n\n::\n\n  [1] INT 'long unsigned int' size=8 bits_offset=0 nr_bits=64 encoding=(none)\n  [2] CONST '(anon)' type_id=1\n  [3] VOLATILE '(anon)' type_id=1\n  [4] ARRAY '(anon)' type_id=1 index_type_id=21 nr_elems=2\n  [5] PTR '(anon)' type_id=8\n  [6] CONST '(anon)' type_id=5\n  [7] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=(none)\n  [8] CONST '(anon)' type_id=7\n  [9] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n  <long output>\n\n**$ bpftool btf dump file one.bpf.o format raw**\n\n::\n\n  [1] PTR '(anon)' type_id=2\n  [2] STRUCT 'trace_event_raw_sys_enter' size=64 vlen=4\n        'ent' type_id=3 bits_offset=0\n        'id' type_id=7 bits_offset=64\n        'args' type_id=9 bits_offset=128\n        '__data' type_id=12 bits_offset=512\n  [3] STRUCT 'trace_entry' size=8 vlen=4\n        'type' type_id=4 bits_offset=0\n        'flags' type_id=5 bits_offset=16\n        'preempt_count' type_id=5 bits_offset=24\n  <long output>\n\n**$ bpftool gen min_core_btf 5.4.0-example.btf 5.4.0-smaller.btf one.bpf.o**\n\n**$ bpftool btf dump file 5.4.0-smaller.btf format raw**\n\n::\n\n  [1] TYPEDEF 'pid_t' type_id=6\n  [2] STRUCT 'trace_event_raw_sys_enter' size=64 vlen=1\n        'args' type_id=4 bits_offset=128\n  [3] STRUCT 'task_struct' size=9216 vlen=2\n        'pid' type_id=1 bits_offset=17920\n        'real_parent' type_id=7 bits_offset=18048\n  [4] ARRAY '(anon)' type_id=5 index_type_id=8 nr_elems=6\n  [5] INT 'long unsigned int' size=8 bits_offset=0 nr_bits=64 encoding=(none)\n  [6] TYPEDEF '__kernel_pid_t' type_id=8\n  [7] PTR '(anon)' type_id=3\n  [8] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\n  <end>\n\nNow, the \"5.4.0-smaller.btf\" file may be used by libbpf as an external BTF file\nwhen loading the \"one.bpf.o\" object into the \"5.4.0-example\" kernel. Note that\nthe generated BTF file won't allow other eBPF objects to be loaded, just the\nones given to min_core_btf.\n\n::\n\n  LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = \"5.4.0-smaller.btf\");\n  struct bpf_object *obj;\n\n  obj = bpf_object__open_file(\"one.bpf.o\", &opts);\n\n  ...\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}