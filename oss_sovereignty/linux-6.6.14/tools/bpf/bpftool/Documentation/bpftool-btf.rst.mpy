{
  "module_name": "bpftool-btf.rst",
  "hash_id": "62034c6ce6460113330d18c959b90598fdcb7e220ee9cee011379e8841ce5ded",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/Documentation/bpftool-btf.rst",
  "human_readable_source": ".. SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n\n================\nbpftool-btf\n================\n-------------------------------------------------------------------------------\ntool for inspection of BTF data\n-------------------------------------------------------------------------------\n\n:Manual section: 8\n\n.. include:: substitutions.rst\n\nSYNOPSIS\n========\n\n\t**bpftool** [*OPTIONS*] **btf** *COMMAND*\n\n\t*OPTIONS* := { |COMMON_OPTIONS| | { **-B** | **--base-btf** } }\n\n\t*COMMANDS* := { **dump** | **help** }\n\nBTF COMMANDS\n=============\n\n|\t**bpftool** **btf** { **show** | **list** } [**id** *BTF_ID*]\n|\t**bpftool** **btf dump** *BTF_SRC* [**format** *FORMAT*]\n|\t**bpftool** **btf help**\n|\n|\t*BTF_SRC* := { **id** *BTF_ID* | **prog** *PROG* | **map** *MAP* [{**key** | **value** | **kv** | **all**}] | **file** *FILE* }\n|\t*FORMAT* := { **raw** | **c** }\n|\t*MAP* := { **id** *MAP_ID* | **pinned** *FILE* }\n|\t*PROG* := { **id** *PROG_ID* | **pinned** *FILE* | **tag** *PROG_TAG* }\n\nDESCRIPTION\n===========\n\t**bpftool btf { show | list }** [**id** *BTF_ID*]\n\t\t  Show information about loaded BTF objects. If a BTF ID is\n\t\t  specified, show information only about given BTF object,\n\t\t  otherwise list all BTF objects currently loaded on the\n\t\t  system.\n\n\t\t  Since Linux 5.8 bpftool is able to discover information about\n\t\t  processes that hold open file descriptors (FDs) against BTF\n\t\t  objects. On such kernels bpftool will automatically emit this\n\t\t  information as well.\n\n\t**bpftool btf dump** *BTF_SRC*\n\t\t  Dump BTF entries from a given *BTF_SRC*.\n\n\t\t  When **id** is specified, BTF object with that ID will be\n\t\t  loaded and all its BTF types emitted.\n\n\t\t  When **map** is provided, it's expected that map has\n\t\t  associated BTF object with BTF types describing key and\n\t\t  value. It's possible to select whether to dump only BTF\n\t\t  type(s) associated with key (**key**), value (**value**),\n\t\t  both key and value (**kv**), or all BTF types present in\n\t\t  associated BTF object (**all**). If not specified, **kv**\n\t\t  is assumed.\n\n\t\t  When **prog** is provided, it's expected that program has\n\t\t  associated BTF object with BTF types.\n\n\t\t  When specifying *FILE*, an ELF file is expected, containing\n\t\t  .BTF section with well-defined BTF binary format data,\n\t\t  typically produced by clang or pahole.\n\n\t\t  **format** option can be used to override default (raw)\n\t\t  output format. Raw (**raw**) or C-syntax (**c**) output\n\t\t  formats are supported.\n\n\t**bpftool btf help**\n\t\t  Print short help message.\n\nOPTIONS\n=======\n\t.. include:: common_options.rst\n\n\t-B, --base-btf *FILE*\n\t\t  Pass a base BTF object. Base BTF objects are typically used\n\t\t  with BTF objects for kernel modules. To avoid duplicating\n\t\t  all kernel symbols required by modules, BTF objects for\n\t\t  modules are \"split\", they are built incrementally on top of\n\t\t  the kernel (vmlinux) BTF object. So the base BTF reference\n\t\t  should usually point to the kernel BTF.\n\n\t\t  When the main BTF object to process (for example, the\n\t\t  module BTF to dump) is passed as a *FILE*, bpftool attempts\n\t\t  to autodetect the path for the base object, and passing\n\t\t  this option is optional. When the main BTF object is passed\n\t\t  through other handles, this option becomes necessary.\n\nEXAMPLES\n========\n**# bpftool btf dump id 1226**\n\n::\n\n  [1] PTR '(anon)' type_id=2\n  [2] STRUCT 'dummy_tracepoint_args' size=16 vlen=2\n          'pad' type_id=3 bits_offset=0\n          'sock' type_id=4 bits_offset=64\n  [3] INT 'long long unsigned int' size=8 bits_offset=0 nr_bits=64 encoding=(none)\n  [4] PTR '(anon)' type_id=5\n  [5] FWD 'sock' fwd_kind=union\n\nThis gives an example of default output for all supported BTF kinds.\n\n**$ cat prog.c**\n\n::\n\n  struct fwd_struct;\n\n  enum my_enum {\n          VAL1 = 3,\n          VAL2 = 7,\n  };\n\n  typedef struct my_struct my_struct_t;\n\n  struct my_struct {\n          const unsigned int const_int_field;\n          int bitfield_field: 4;\n          char arr_field[16];\n          const struct fwd_struct *restrict fwd_field;\n          enum my_enum enum_field;\n          volatile my_struct_t *typedef_ptr_field;\n  };\n\n  union my_union {\n          int a;\n          struct my_struct b;\n  };\n\n  struct my_struct struct_global_var __attribute__((section(\"data_sec\"))) = {\n          .bitfield_field = 3,\n          .enum_field = VAL1,\n  };\n  int global_var __attribute__((section(\"data_sec\"))) = 7;\n\n  __attribute__((noinline))\n  int my_func(union my_union *arg1, int arg2)\n  {\n          static int static_var __attribute__((section(\"data_sec\"))) = 123;\n          static_var++;\n          return static_var;\n  }\n\n**$ bpftool btf dump file prog.o**\n\n::\n\n  [1] PTR '(anon)' type_id=2\n  [2] UNION 'my_union' size=48 vlen=2\n          'a' type_id=3 bits_offset=0\n          'b' type_id=4 bits_offset=0\n  [3] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\n  [4] STRUCT 'my_struct' size=48 vlen=6\n          'const_int_field' type_id=5 bits_offset=0\n          'bitfield_field' type_id=3 bits_offset=32 bitfield_size=4\n          'arr_field' type_id=8 bits_offset=40\n          'fwd_field' type_id=10 bits_offset=192\n          'enum_field' type_id=14 bits_offset=256\n          'typedef_ptr_field' type_id=15 bits_offset=320\n  [5] CONST '(anon)' type_id=6\n  [6] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n  [7] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=SIGNED\n  [8] ARRAY '(anon)' type_id=7 index_type_id=9 nr_elems=16\n  [9] INT '__ARRAY_SIZE_TYPE__' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n  [10] RESTRICT '(anon)' type_id=11\n  [11] PTR '(anon)' type_id=12\n  [12] CONST '(anon)' type_id=13\n  [13] FWD 'fwd_struct' fwd_kind=union\n  [14] ENUM 'my_enum' size=4 vlen=2\n          'VAL1' val=3\n          'VAL2' val=7\n  [15] PTR '(anon)' type_id=16\n  [16] VOLATILE '(anon)' type_id=17\n  [17] TYPEDEF 'my_struct_t' type_id=4\n  [18] FUNC_PROTO '(anon)' ret_type_id=3 vlen=2\n          'arg1' type_id=1\n          'arg2' type_id=3\n  [19] FUNC 'my_func' type_id=18\n  [20] VAR 'struct_global_var' type_id=4, linkage=global-alloc\n  [21] VAR 'global_var' type_id=3, linkage=global-alloc\n  [22] VAR 'my_func.static_var' type_id=3, linkage=static\n  [23] DATASEC 'data_sec' size=0 vlen=3\n          type_id=20 offset=0 size=48\n          type_id=21 offset=0 size=4\n          type_id=22 offset=52 size=4\n\nThe following commands print BTF types associated with specified map's key,\nvalue, both key and value, and all BTF types, respectively. By default, both\nkey and value types will be printed.\n\n**# bpftool btf dump map id 123 key**\n\n::\n\n  [39] TYPEDEF 'u32' type_id=37\n\n**# bpftool btf dump map id 123 value**\n\n::\n\n  [86] PTR '(anon)' type_id=87\n\n**# bpftool btf dump map id 123 kv**\n\n::\n\n  [39] TYPEDEF 'u32' type_id=37\n  [86] PTR '(anon)' type_id=87\n\n**# bpftool btf dump map id 123 all**\n\n::\n\n  [1] PTR '(anon)' type_id=0\n  .\n  .\n  .\n  [2866] ARRAY '(anon)' type_id=52 index_type_id=51 nr_elems=4\n\nAll the standard ways to specify map or program are supported:\n\n**# bpftool btf dump map id 123**\n\n**# bpftool btf dump map pinned /sys/fs/bpf/map_name**\n\n**# bpftool btf dump prog id 456**\n\n**# bpftool btf dump prog tag b88e0a09b1d9759d**\n\n**# bpftool btf dump prog pinned /sys/fs/bpf/prog_name**\n\n|\n| **# bpftool btf dump file /sys/kernel/btf/i2c_smbus**\n| (or)\n| **# I2C_SMBUS_ID=$(bpftool btf show -p | jq '.[] | select(.name==\"i2c_smbus\").id')**\n| **# bpftool btf dump id ${I2C_SMBUS_ID} -B /sys/kernel/btf/vmlinux**\n\n::\n\n  [104848] STRUCT 'i2c_smbus_alert' size=40 vlen=2\n          'alert' type_id=393 bits_offset=0\n          'ara' type_id=56050 bits_offset=256\n  [104849] STRUCT 'alert_data' size=12 vlen=3\n          'addr' type_id=16 bits_offset=0\n          'type' type_id=56053 bits_offset=32\n          'data' type_id=7 bits_offset=64\n  [104850] PTR '(anon)' type_id=104848\n  [104851] PTR '(anon)' type_id=104849\n  [104852] FUNC 'i2c_register_spd' type_id=84745 linkage=static\n  [104853] FUNC 'smbalert_driver_init' type_id=1213 linkage=static\n  [104854] FUNC_PROTO '(anon)' ret_type_id=18 vlen=1\n          'ara' type_id=56050\n  [104855] FUNC 'i2c_handle_smbus_alert' type_id=104854 linkage=static\n  [104856] FUNC 'smbalert_remove' type_id=104854 linkage=static\n  [104857] FUNC_PROTO '(anon)' ret_type_id=18 vlen=2\n          'ara' type_id=56050\n          'id' type_id=56056\n  [104858] FUNC 'smbalert_probe' type_id=104857 linkage=static\n  [104859] FUNC 'smbalert_work' type_id=9695 linkage=static\n  [104860] FUNC 'smbus_alert' type_id=71367 linkage=static\n  [104861] FUNC 'smbus_do_alert' type_id=84827 linkage=static\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}