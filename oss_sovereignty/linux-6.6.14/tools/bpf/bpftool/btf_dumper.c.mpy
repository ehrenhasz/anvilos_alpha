{
  "module_name": "btf_dumper.c",
  "hash_id": "479191a0c2fb3dbd45922d5b4b59e7d6c7f1b76128ef9986b7a59fa23b210989",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/btf_dumper.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <stdio.h>  \n#include <string.h>\n#include <unistd.h>\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <bpf/btf.h>\n#include <bpf/bpf.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\n#define BITS_PER_BYTE_MASK (BITS_PER_BYTE - 1)\n#define BITS_PER_BYTE_MASKED(bits) ((bits) & BITS_PER_BYTE_MASK)\n#define BITS_ROUNDDOWN_BYTES(bits) ((bits) >> 3)\n#define BITS_ROUNDUP_BYTES(bits) \\\n\t(BITS_ROUNDDOWN_BYTES(bits) + !!BITS_PER_BYTE_MASKED(bits))\n\nstatic int btf_dumper_do_type(const struct btf_dumper *d, __u32 type_id,\n\t\t\t      __u8 bit_offset, const void *data);\n\nstatic int btf_dump_func(const struct btf *btf, char *func_sig,\n\t\t\t const struct btf_type *func_proto,\n\t\t\t const struct btf_type *func, int pos, int size);\n\nstatic int dump_prog_id_as_func_ptr(const struct btf_dumper *d,\n\t\t\t\t    const struct btf_type *func_proto,\n\t\t\t\t    __u32 prog_id)\n{\n\tconst struct btf_type *func_type;\n\tint prog_fd = -1, func_sig_len;\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tconst char *prog_name = NULL;\n\tstruct btf *prog_btf = NULL;\n\tstruct bpf_func_info finfo;\n\t__u32 finfo_rec_size;\n\tchar prog_str[1024];\n\tint err;\n\n\t \n\tfunc_sig_len = btf_dump_func(d->btf, prog_str, func_proto, NULL, 0,\n\t\t\t\t     sizeof(prog_str));\n\tif (func_sig_len == -1)\n\t\treturn -1;\n\n\tif (!prog_id)\n\t\tgoto print;\n\n\t \n\tprog_fd = bpf_prog_get_fd_by_id(prog_id);\n\tif (prog_fd < 0)\n\t\tgoto print;\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (err)\n\t\tgoto print;\n\n\tif (!info.btf_id || !info.nr_func_info)\n\t\tgoto print;\n\n\tfinfo_rec_size = info.func_info_rec_size;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.nr_func_info = 1;\n\tinfo.func_info_rec_size = finfo_rec_size;\n\tinfo.func_info = ptr_to_u64(&finfo);\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (err)\n\t\tgoto print;\n\n\tprog_btf = btf__load_from_kernel_by_id(info.btf_id);\n\tif (!prog_btf)\n\t\tgoto print;\n\tfunc_type = btf__type_by_id(prog_btf, finfo.type_id);\n\tif (!func_type || !btf_is_func(func_type))\n\t\tgoto print;\n\n\tprog_name = btf__name_by_offset(prog_btf, func_type->name_off);\n\nprint:\n\tif (!prog_id)\n\t\tsnprintf(&prog_str[func_sig_len],\n\t\t\t sizeof(prog_str) - func_sig_len, \" 0\");\n\telse if (prog_name)\n\t\tsnprintf(&prog_str[func_sig_len],\n\t\t\t sizeof(prog_str) - func_sig_len,\n\t\t\t \" %s/prog_id:%u\", prog_name, prog_id);\n\telse\n\t\tsnprintf(&prog_str[func_sig_len],\n\t\t\t sizeof(prog_str) - func_sig_len,\n\t\t\t \" <unknown_prog_name>/prog_id:%u\", prog_id);\n\n\tprog_str[sizeof(prog_str) - 1] = '\\0';\n\tjsonw_string(d->jw, prog_str);\n\tbtf__free(prog_btf);\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\treturn 0;\n}\n\nstatic void btf_dumper_ptr(const struct btf_dumper *d,\n\t\t\t   const struct btf_type *t,\n\t\t\t   const void *data)\n{\n\tunsigned long value = *(unsigned long *)data;\n\tconst struct btf_type *ptr_type;\n\t__s32 ptr_type_id;\n\n\tif (!d->prog_id_as_func_ptr || value > UINT32_MAX)\n\t\tgoto print_ptr_value;\n\n\tptr_type_id = btf__resolve_type(d->btf, t->type);\n\tif (ptr_type_id < 0)\n\t\tgoto print_ptr_value;\n\tptr_type = btf__type_by_id(d->btf, ptr_type_id);\n\tif (!ptr_type || !btf_is_func_proto(ptr_type))\n\t\tgoto print_ptr_value;\n\n\tif (!dump_prog_id_as_func_ptr(d, ptr_type, value))\n\t\treturn;\n\nprint_ptr_value:\n\tif (d->is_plain_text)\n\t\tjsonw_printf(d->jw, \"%p\", (void *)value);\n\telse\n\t\tjsonw_printf(d->jw, \"%lu\", value);\n}\n\nstatic int btf_dumper_modifier(const struct btf_dumper *d, __u32 type_id,\n\t\t\t       __u8 bit_offset, const void *data)\n{\n\tint actual_type_id;\n\n\tactual_type_id = btf__resolve_type(d->btf, type_id);\n\tif (actual_type_id < 0)\n\t\treturn actual_type_id;\n\n\treturn btf_dumper_do_type(d, actual_type_id, bit_offset, data);\n}\n\nstatic int btf_dumper_enum(const struct btf_dumper *d,\n\t\t\t    const struct btf_type *t,\n\t\t\t    const void *data)\n{\n\tconst struct btf_enum *enums = btf_enum(t);\n\t__s64 value;\n\t__u16 i;\n\n\tswitch (t->size) {\n\tcase 8:\n\t\tvalue = *(__s64 *)data;\n\t\tbreak;\n\tcase 4:\n\t\tvalue = *(__s32 *)data;\n\t\tbreak;\n\tcase 2:\n\t\tvalue = *(__s16 *)data;\n\t\tbreak;\n\tcase 1:\n\t\tvalue = *(__s8 *)data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < btf_vlen(t); i++) {\n\t\tif (value == enums[i].val) {\n\t\t\tjsonw_string(d->jw,\n\t\t\t\t     btf__name_by_offset(d->btf,\n\t\t\t\t\t\t\t enums[i].name_off));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjsonw_int(d->jw, value);\n\treturn 0;\n}\n\nstatic int btf_dumper_enum64(const struct btf_dumper *d,\n\t\t\t     const struct btf_type *t,\n\t\t\t     const void *data)\n{\n\tconst struct btf_enum64 *enums = btf_enum64(t);\n\t__u32 val_lo32, val_hi32;\n\t__u64 value;\n\t__u16 i;\n\n\tvalue = *(__u64 *)data;\n\tval_lo32 = (__u32)value;\n\tval_hi32 = value >> 32;\n\n\tfor (i = 0; i < btf_vlen(t); i++) {\n\t\tif (val_lo32 == enums[i].val_lo32 && val_hi32 == enums[i].val_hi32) {\n\t\t\tjsonw_string(d->jw,\n\t\t\t\t     btf__name_by_offset(d->btf,\n\t\t\t\t\t\t\t enums[i].name_off));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjsonw_int(d->jw, value);\n\treturn 0;\n}\n\nstatic bool is_str_array(const struct btf *btf, const struct btf_array *arr,\n\t\t\t const char *s)\n{\n\tconst struct btf_type *elem_type;\n\tconst char *end_s;\n\n\tif (!arr->nelems)\n\t\treturn false;\n\n\telem_type = btf__type_by_id(btf, arr->type);\n\t \n\twhile (elem_type && btf_is_mod(elem_type))\n\t\telem_type = btf__type_by_id(btf, elem_type->type);\n\n\tif (!elem_type || !btf_is_int(elem_type) || elem_type->size != 1)\n\t\treturn false;\n\n\tif (btf_int_encoding(elem_type) != BTF_INT_CHAR &&\n\t    strcmp(\"char\", btf__name_by_offset(btf, elem_type->name_off)))\n\t\treturn false;\n\n\tend_s = s + arr->nelems;\n\twhile (s < end_s) {\n\t\tif (!*s)\n\t\t\treturn true;\n\t\tif (*s <= 0x1f || *s >= 0x7f)\n\t\t\treturn false;\n\t\ts++;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic int btf_dumper_array(const struct btf_dumper *d, __u32 type_id,\n\t\t\t    const void *data)\n{\n\tconst struct btf_type *t = btf__type_by_id(d->btf, type_id);\n\tstruct btf_array *arr = (struct btf_array *)(t + 1);\n\tlong long elem_size;\n\tint ret = 0;\n\t__u32 i;\n\n\tif (is_str_array(d->btf, arr, data)) {\n\t\tjsonw_string(d->jw, data);\n\t\treturn 0;\n\t}\n\n\telem_size = btf__resolve_size(d->btf, arr->type);\n\tif (elem_size < 0)\n\t\treturn elem_size;\n\n\tjsonw_start_array(d->jw);\n\tfor (i = 0; i < arr->nelems; i++) {\n\t\tret = btf_dumper_do_type(d, arr->type, 0,\n\t\t\t\t\t data + i * elem_size);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tjsonw_end_array(d->jw);\n\treturn ret;\n}\n\nstatic void btf_int128_print(json_writer_t *jw, const void *data,\n\t\t\t     bool is_plain_text)\n{\n\t \n\t__u64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(__u64 *)data;\n\tlower_num = *(__u64 *)(data + 8);\n#else\n\tupper_num = *(__u64 *)(data + 8);\n\tlower_num = *(__u64 *)data;\n#endif\n\n\tif (is_plain_text) {\n\t\tif (upper_num == 0)\n\t\t\tjsonw_printf(jw, \"0x%llx\", lower_num);\n\t\telse\n\t\t\tjsonw_printf(jw, \"0x%llx%016llx\", upper_num, lower_num);\n\t} else {\n\t\tif (upper_num == 0)\n\t\t\tjsonw_printf(jw, \"\\\"0x%llx\\\"\", lower_num);\n\t\telse\n\t\t\tjsonw_printf(jw, \"\\\"0x%llx%016llx\\\"\", upper_num, lower_num);\n\t}\n}\n\nstatic void btf_int128_shift(__u64 *print_num, __u16 left_shift_bits,\n\t\t\t     __u16 right_shift_bits)\n{\n\t__u64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t \n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}\n\nstatic void btf_dumper_bitfield(__u32 nr_bits, __u8 bit_offset,\n\t\t\t\tconst void *data, json_writer_t *jw,\n\t\t\t\tbool is_plain_text)\n{\n\tint left_shift_bits, right_shift_bits;\n\t__u64 print_num[2] = {};\n\tint bytes_to_copy;\n\tint bits_to_copy;\n\n\tbits_to_copy = bit_offset + nr_bits;\n\tbytes_to_copy = BITS_ROUNDUP_BYTES(bits_to_copy);\n\n\tmemcpy(print_num, data, bytes_to_copy);\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tleft_shift_bits = bit_offset;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tleft_shift_bits = 128 - bits_to_copy;\n#else\n#error neither big nor little endian\n#endif\n\tright_shift_bits = 128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(jw, print_num, is_plain_text);\n}\n\n\nstatic void btf_dumper_int_bits(__u32 int_type, __u8 bit_offset,\n\t\t\t\tconst void *data, json_writer_t *jw,\n\t\t\t\tbool is_plain_text)\n{\n\tint nr_bits = BTF_INT_BITS(int_type);\n\tint total_bits_offset;\n\n\t \n\ttotal_bits_offset = bit_offset + BTF_INT_OFFSET(int_type);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbit_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_dumper_bitfield(nr_bits, bit_offset, data, jw,\n\t\t\t    is_plain_text);\n}\n\nstatic int btf_dumper_int(const struct btf_type *t, __u8 bit_offset,\n\t\t\t  const void *data, json_writer_t *jw,\n\t\t\t  bool is_plain_text)\n{\n\t__u32 *int_type;\n\t__u32 nr_bits;\n\n\tint_type = (__u32 *)(t + 1);\n\tnr_bits = BTF_INT_BITS(*int_type);\n\t \n\tif (bit_offset || BTF_INT_OFFSET(*int_type) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_dumper_int_bits(*int_type, bit_offset, data, jw,\n\t\t\t\t    is_plain_text);\n\t\treturn 0;\n\t}\n\n\tif (nr_bits == 128) {\n\t\tbtf_int128_print(jw, data, is_plain_text);\n\t\treturn 0;\n\t}\n\n\tswitch (BTF_INT_ENCODING(*int_type)) {\n\tcase 0:\n\t\tif (BTF_INT_BITS(*int_type) == 64)\n\t\t\tjsonw_printf(jw, \"%llu\", *(__u64 *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 32)\n\t\t\tjsonw_printf(jw, \"%u\", *(__u32 *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 16)\n\t\t\tjsonw_printf(jw, \"%hu\", *(__u16 *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 8)\n\t\t\tjsonw_printf(jw, \"%hhu\", *(__u8 *)data);\n\t\telse\n\t\t\tbtf_dumper_int_bits(*int_type, bit_offset, data, jw,\n\t\t\t\t\t    is_plain_text);\n\t\tbreak;\n\tcase BTF_INT_SIGNED:\n\t\tif (BTF_INT_BITS(*int_type) == 64)\n\t\t\tjsonw_printf(jw, \"%lld\", *(long long *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 32)\n\t\t\tjsonw_printf(jw, \"%d\", *(int *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 16)\n\t\t\tjsonw_printf(jw, \"%hd\", *(short *)data);\n\t\telse if (BTF_INT_BITS(*int_type) == 8)\n\t\t\tjsonw_printf(jw, \"%hhd\", *(char *)data);\n\t\telse\n\t\t\tbtf_dumper_int_bits(*int_type, bit_offset, data, jw,\n\t\t\t\t\t    is_plain_text);\n\t\tbreak;\n\tcase BTF_INT_CHAR:\n\t\tif (isprint(*(char *)data))\n\t\t\tjsonw_printf(jw, \"\\\"%c\\\"\", *(char *)data);\n\t\telse\n\t\t\tif (is_plain_text)\n\t\t\t\tjsonw_printf(jw, \"0x%hhx\", *(char *)data);\n\t\t\telse\n\t\t\t\tjsonw_printf(jw, \"\\\"\\\\u00%02hhx\\\"\",\n\t\t\t\t\t     *(char *)data);\n\t\tbreak;\n\tcase BTF_INT_BOOL:\n\t\tjsonw_bool(jw, *(bool *)data);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_dumper_struct(const struct btf_dumper *d, __u32 type_id,\n\t\t\t     const void *data)\n{\n\tconst struct btf_type *t;\n\tstruct btf_member *m;\n\tconst void *data_off;\n\tint kind_flag;\n\tint ret = 0;\n\tint i, vlen;\n\n\tt = btf__type_by_id(d->btf, type_id);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\tkind_flag = BTF_INFO_KFLAG(t->info);\n\tvlen = BTF_INFO_VLEN(t->info);\n\tjsonw_start_object(d->jw);\n\tm = (struct btf_member *)(t + 1);\n\n\tfor (i = 0; i < vlen; i++) {\n\t\t__u32 bit_offset = m[i].offset;\n\t\t__u32 bitfield_size = 0;\n\n\t\tif (kind_flag) {\n\t\t\tbitfield_size = BTF_MEMBER_BITFIELD_SIZE(bit_offset);\n\t\t\tbit_offset = BTF_MEMBER_BIT_OFFSET(bit_offset);\n\t\t}\n\n\t\tjsonw_name(d->jw, btf__name_by_offset(d->btf, m[i].name_off));\n\t\tdata_off = data + BITS_ROUNDDOWN_BYTES(bit_offset);\n\t\tif (bitfield_size) {\n\t\t\tbtf_dumper_bitfield(bitfield_size,\n\t\t\t\t\t    BITS_PER_BYTE_MASKED(bit_offset),\n\t\t\t\t\t    data_off, d->jw, d->is_plain_text);\n\t\t} else {\n\t\t\tret = btf_dumper_do_type(d, m[i].type,\n\t\t\t\t\t\t BITS_PER_BYTE_MASKED(bit_offset),\n\t\t\t\t\t\t data_off);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tjsonw_end_object(d->jw);\n\n\treturn ret;\n}\n\nstatic int btf_dumper_var(const struct btf_dumper *d, __u32 type_id,\n\t\t\t  __u8 bit_offset, const void *data)\n{\n\tconst struct btf_type *t = btf__type_by_id(d->btf, type_id);\n\tint ret;\n\n\tjsonw_start_object(d->jw);\n\tjsonw_name(d->jw, btf__name_by_offset(d->btf, t->name_off));\n\tret = btf_dumper_do_type(d, t->type, bit_offset, data);\n\tjsonw_end_object(d->jw);\n\n\treturn ret;\n}\n\nstatic int btf_dumper_datasec(const struct btf_dumper *d, __u32 type_id,\n\t\t\t      const void *data)\n{\n\tstruct btf_var_secinfo *vsi;\n\tconst struct btf_type *t;\n\tint ret = 0, i, vlen;\n\n\tt = btf__type_by_id(d->btf, type_id);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\tvlen = BTF_INFO_VLEN(t->info);\n\tvsi = (struct btf_var_secinfo *)(t + 1);\n\n\tjsonw_start_object(d->jw);\n\tjsonw_name(d->jw, btf__name_by_offset(d->btf, t->name_off));\n\tjsonw_start_array(d->jw);\n\tfor (i = 0; i < vlen; i++) {\n\t\tret = btf_dumper_do_type(d, vsi[i].type, 0, data + vsi[i].offset);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tjsonw_end_array(d->jw);\n\tjsonw_end_object(d->jw);\n\n\treturn ret;\n}\n\nstatic int btf_dumper_do_type(const struct btf_dumper *d, __u32 type_id,\n\t\t\t      __u8 bit_offset, const void *data)\n{\n\tconst struct btf_type *t = btf__type_by_id(d->btf, type_id);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\t\treturn btf_dumper_int(t, bit_offset, data, d->jw,\n\t\t\t\t     d->is_plain_text);\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\treturn btf_dumper_struct(d, type_id, data);\n\tcase BTF_KIND_ARRAY:\n\t\treturn btf_dumper_array(d, type_id, data);\n\tcase BTF_KIND_ENUM:\n\t\treturn btf_dumper_enum(d, t, data);\n\tcase BTF_KIND_ENUM64:\n\t\treturn btf_dumper_enum64(d, t, data);\n\tcase BTF_KIND_PTR:\n\t\tbtf_dumper_ptr(d, t, data);\n\t\treturn 0;\n\tcase BTF_KIND_UNKN:\n\t\tjsonw_printf(d->jw, \"(unknown)\");\n\t\treturn 0;\n\tcase BTF_KIND_FWD:\n\t\t \n\t\tjsonw_printf(d->jw, \"(fwd-kind-invalid)\");\n\t\treturn -EINVAL;\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn btf_dumper_modifier(d, type_id, bit_offset, data);\n\tcase BTF_KIND_VAR:\n\t\treturn btf_dumper_var(d, type_id, bit_offset, data);\n\tcase BTF_KIND_DATASEC:\n\t\treturn btf_dumper_datasec(d, type_id, data);\n\tdefault:\n\t\tjsonw_printf(d->jw, \"(unsupported-kind\");\n\t\treturn -EINVAL;\n\t}\n}\n\nint btf_dumper_type(const struct btf_dumper *d, __u32 type_id,\n\t\t    const void *data)\n{\n\treturn btf_dumper_do_type(d, type_id, 0, data);\n}\n\n#define BTF_PRINT_ARG(...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpos += snprintf(func_sig + pos, size - pos,\t\t\\\n\t\t\t\t__VA_ARGS__);\t\t\t\t\\\n\t\tif (pos >= size)\t\t\t\t\t\\\n\t\t\treturn -1;\t\t\t\t\t\\\n\t} while (0)\n#define BTF_PRINT_TYPE(type)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpos = __btf_dumper_type_only(btf, type, func_sig,\t\\\n\t\t\t\t\t     pos, size);\t\t\\\n\t\tif (pos == -1)\t\t\t\t\t\t\\\n\t\t\treturn -1;\t\t\t\t\t\\\n\t} while (0)\n\nstatic int __btf_dumper_type_only(const struct btf *btf, __u32 type_id,\n\t\t\t\t  char *func_sig, int pos, int size)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_array *array;\n\tconst struct btf_var *var;\n\tconst struct btf_type *t;\n\n\tif (!type_id) {\n\t\tBTF_PRINT_ARG(\"void \");\n\t\treturn pos;\n\t}\n\n\tt = btf__type_by_id(btf, type_id);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FLOAT:\n\t\tBTF_PRINT_ARG(\"%s \", btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_STRUCT:\n\t\tBTF_PRINT_ARG(\"struct %s \",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_UNION:\n\t\tBTF_PRINT_ARG(\"union %s \",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\tBTF_PRINT_ARG(\"enum %s \",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_ARRAY:\n\t\tarray = (struct btf_array *)(t + 1);\n\t\tBTF_PRINT_TYPE(array->type);\n\t\tBTF_PRINT_ARG(\"[%d]\", array->nelems);\n\t\tbreak;\n\tcase BTF_KIND_PTR:\n\t\tBTF_PRINT_TYPE(t->type);\n\t\tBTF_PRINT_ARG(\"* \");\n\t\tbreak;\n\tcase BTF_KIND_FWD:\n\t\tBTF_PRINT_ARG(\"%s %s \",\n\t\t\t      BTF_INFO_KFLAG(t->info) ? \"union\" : \"struct\",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_VOLATILE:\n\t\tBTF_PRINT_ARG(\"volatile \");\n\t\tBTF_PRINT_TYPE(t->type);\n\t\tbreak;\n\tcase BTF_KIND_CONST:\n\t\tBTF_PRINT_ARG(\"const \");\n\t\tBTF_PRINT_TYPE(t->type);\n\t\tbreak;\n\tcase BTF_KIND_RESTRICT:\n\t\tBTF_PRINT_ARG(\"restrict \");\n\t\tBTF_PRINT_TYPE(t->type);\n\t\tbreak;\n\tcase BTF_KIND_FUNC_PROTO:\n\t\tpos = btf_dump_func(btf, func_sig, t, NULL, pos, size);\n\t\tif (pos == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase BTF_KIND_FUNC:\n\t\tproto_type = btf__type_by_id(btf, t->type);\n\t\tpos = btf_dump_func(btf, func_sig, proto_type, t, pos, size);\n\t\tif (pos == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase BTF_KIND_VAR:\n\t\tvar = (struct btf_var *)(t + 1);\n\t\tif (var->linkage == BTF_VAR_STATIC)\n\t\t\tBTF_PRINT_ARG(\"static \");\n\t\tBTF_PRINT_TYPE(t->type);\n\t\tBTF_PRINT_ARG(\" %s\",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_DATASEC:\n\t\tBTF_PRINT_ARG(\"section (\\\"%s\\\") \",\n\t\t\t      btf__name_by_offset(btf, t->name_off));\n\t\tbreak;\n\tcase BTF_KIND_UNKN:\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn pos;\n}\n\nstatic int btf_dump_func(const struct btf *btf, char *func_sig,\n\t\t\t const struct btf_type *func_proto,\n\t\t\t const struct btf_type *func, int pos, int size)\n{\n\tint i, vlen;\n\n\tBTF_PRINT_TYPE(func_proto->type);\n\tif (func)\n\t\tBTF_PRINT_ARG(\"%s(\", btf__name_by_offset(btf, func->name_off));\n\telse\n\t\tBTF_PRINT_ARG(\"(\");\n\tvlen = BTF_INFO_VLEN(func_proto->info);\n\tfor (i = 0; i < vlen; i++) {\n\t\tstruct btf_param *arg = &((struct btf_param *)(func_proto + 1))[i];\n\n\t\tif (i)\n\t\t\tBTF_PRINT_ARG(\", \");\n\t\tif (arg->type) {\n\t\t\tBTF_PRINT_TYPE(arg->type);\n\t\t\tif (arg->name_off)\n\t\t\t\tBTF_PRINT_ARG(\"%s\",\n\t\t\t\t\t      btf__name_by_offset(btf, arg->name_off));\n\t\t\telse if (pos && func_sig[pos - 1] == ' ')\n\t\t\t\t \n\t\t\t\tfunc_sig[--pos] = '\\0';\n\t\t} else {\n\t\t\tBTF_PRINT_ARG(\"...\");\n\t\t}\n\t}\n\tBTF_PRINT_ARG(\")\");\n\n\treturn pos;\n}\n\nvoid btf_dumper_type_only(const struct btf *btf, __u32 type_id, char *func_sig,\n\t\t\t  int size)\n{\n\tint err;\n\n\tfunc_sig[0] = '\\0';\n\tif (!btf)\n\t\treturn;\n\n\terr = __btf_dumper_type_only(btf, type_id, func_sig, 0, size);\n\tif (err < 0)\n\t\tfunc_sig[0] = '\\0';\n}\n\nstatic const char *ltrim(const char *s)\n{\n\twhile (isspace(*s))\n\t\ts++;\n\n\treturn s;\n}\n\nvoid btf_dump_linfo_plain(const struct btf *btf,\n\t\t\t  const struct bpf_line_info *linfo,\n\t\t\t  const char *prefix, bool linum)\n{\n\tconst char *line = btf__name_by_offset(btf, linfo->line_off);\n\n\tif (!line)\n\t\treturn;\n\tline = ltrim(line);\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tif (linum) {\n\t\tconst char *file = btf__name_by_offset(btf, linfo->file_name_off);\n\n\t\t \n\t\tif (!file)\n\t\t\tfile = \"\";\n\n\t\tprintf(\"%s%s [file:%s line_num:%u line_col:%u]\\n\",\n\t\t       prefix, line, file,\n\t\t       BPF_LINE_INFO_LINE_NUM(linfo->line_col),\n\t\t       BPF_LINE_INFO_LINE_COL(linfo->line_col));\n\t} else {\n\t\tprintf(\"%s%s\\n\", prefix, line);\n\t}\n}\n\nvoid btf_dump_linfo_json(const struct btf *btf,\n\t\t\t const struct bpf_line_info *linfo, bool linum)\n{\n\tconst char *line = btf__name_by_offset(btf, linfo->line_off);\n\n\tif (line)\n\t\tjsonw_string_field(json_wtr, \"src\", ltrim(line));\n\n\tif (linum) {\n\t\tconst char *file = btf__name_by_offset(btf, linfo->file_name_off);\n\n\t\tif (file)\n\t\t\tjsonw_string_field(json_wtr, \"file\", file);\n\n\t\tif (BPF_LINE_INFO_LINE_NUM(linfo->line_col))\n\t\t\tjsonw_int_field(json_wtr, \"line_num\",\n\t\t\t\t\tBPF_LINE_INFO_LINE_NUM(linfo->line_col));\n\n\t\tif (BPF_LINE_INFO_LINE_COL(linfo->line_col))\n\t\t\tjsonw_int_field(json_wtr, \"line_col\",\n\t\t\t\t\tBPF_LINE_INFO_LINE_COL(linfo->line_col));\n\t}\n}\n\nstatic void dotlabel_puts(const char *s)\n{\n\tfor (; *s; ++s) {\n\t\tswitch (*s) {\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\tcase '{':\n\t\tcase '}':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase '|':\n\t\tcase ' ':\n\t\t\tputchar('\\\\');\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tputchar(*s);\n\t\t}\n\t}\n}\n\nstatic const char *shorten_path(const char *path)\n{\n\tconst unsigned int MAX_PATH_LEN = 32;\n\tsize_t len = strlen(path);\n\tconst char *shortpath;\n\n\tif (len <= MAX_PATH_LEN)\n\t\treturn path;\n\n\t \n\tshortpath = strchr(path + len - MAX_PATH_LEN, '/');\n\tif (shortpath) {\n\t\tif (shortpath < path + strlen(\"...\"))\n\t\t\t \n\t\t\treturn path;\n\t\treturn shortpath;\n\t}\n\n\t \n\t\t\tshortpath = strrchr(path, '/');\n\tif (shortpath)\n\t\treturn shortpath;\n\n\treturn path;\n}\n\nvoid btf_dump_linfo_dotlabel(const struct btf *btf,\n\t\t\t     const struct bpf_line_info *linfo, bool linum)\n{\n\tconst char *line = btf__name_by_offset(btf, linfo->line_off);\n\n\tif (!line || !strlen(line))\n\t\treturn;\n\tline = ltrim(line);\n\n\tif (linum) {\n\t\tconst char *file = btf__name_by_offset(btf, linfo->file_name_off);\n\t\tconst char *shortfile;\n\n\t\t \n\t\tif (!file)\n\t\t\tshortfile = \"\";\n\t\telse\n\t\t\tshortfile = shorten_path(file);\n\n\t\tprintf(\"; [%s\", shortfile > file ? \"...\" : \"\");\n\t\tdotlabel_puts(shortfile);\n\t\tprintf(\" line:%u col:%u]\\\\l\\\\\\n\",\n\t\t       BPF_LINE_INFO_LINE_NUM(linfo->line_col),\n\t\t       BPF_LINE_INFO_LINE_COL(linfo->line_col));\n\t}\n\n\tprintf(\"; \");\n\tdotlabel_puts(line);\n\tprintf(\"\\\\l\\\\\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}