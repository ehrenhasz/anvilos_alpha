{
  "module_name": "prog.c",
  "hash_id": "3b6f9af81fb6c0d039c1c4d6b5ae08137b4da41436ed1bcb04867827a76fb87c",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/prog.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <dirent.h>\n\n#include <linux/err.h>\n#include <linux/perf_event.h>\n#include <linux/sizes.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/hashmap.h>\n#include <bpf/libbpf.h>\n#include <bpf/libbpf_internal.h>\n#include <bpf/skel_internal.h>\n\n#include \"cfg.h\"\n#include \"main.h\"\n#include \"xlated_dumper.h\"\n\n#define BPF_METADATA_PREFIX \"bpf_metadata_\"\n#define BPF_METADATA_PREFIX_LEN (sizeof(BPF_METADATA_PREFIX) - 1)\n\nenum dump_mode {\n\tDUMP_JITED,\n\tDUMP_XLATED,\n};\n\nstatic const bool attach_types[] = {\n\t[BPF_SK_SKB_STREAM_PARSER] = true,\n\t[BPF_SK_SKB_STREAM_VERDICT] = true,\n\t[BPF_SK_SKB_VERDICT] = true,\n\t[BPF_SK_MSG_VERDICT] = true,\n\t[BPF_FLOW_DISSECTOR] = true,\n\t[__MAX_BPF_ATTACH_TYPE] = false,\n};\n\n \nstatic const char * const attach_type_strings[] = {\n\t[BPF_SK_SKB_STREAM_PARSER] = \"stream_parser\",\n\t[BPF_SK_SKB_STREAM_VERDICT] = \"stream_verdict\",\n\t[BPF_SK_SKB_VERDICT] = \"skb_verdict\",\n\t[BPF_SK_MSG_VERDICT] = \"msg_verdict\",\n\t[__MAX_BPF_ATTACH_TYPE] = NULL,\n};\n\nstatic struct hashmap *prog_table;\n\nstatic enum bpf_attach_type parse_attach_type(const char *str)\n{\n\tenum bpf_attach_type type;\n\n\tfor (type = 0; type < __MAX_BPF_ATTACH_TYPE; type++) {\n\t\tif (attach_types[type]) {\n\t\t\tconst char *attach_type_str;\n\n\t\t\tattach_type_str = libbpf_bpf_attach_type_str(type);\n\t\t\tif (!strcmp(str, attach_type_str))\n\t\t\t\treturn type;\n\t\t}\n\n\t\tif (attach_type_strings[type] &&\n\t\t    is_prefix(str, attach_type_strings[type]))\n\t\t\treturn type;\n\t}\n\n\treturn __MAX_BPF_ATTACH_TYPE;\n}\n\nstatic int prep_prog_info(struct bpf_prog_info *const info, enum dump_mode mode,\n\t\t\t  void **info_data, size_t *const info_data_sz)\n{\n\tstruct bpf_prog_info holder = {};\n\tsize_t needed = 0;\n\tvoid *ptr;\n\n\tif (mode == DUMP_JITED) {\n\t\tholder.jited_prog_len = info->jited_prog_len;\n\t\tneeded += info->jited_prog_len;\n\t} else {\n\t\tholder.xlated_prog_len = info->xlated_prog_len;\n\t\tneeded += info->xlated_prog_len;\n\t}\n\n\tholder.nr_jited_ksyms = info->nr_jited_ksyms;\n\tneeded += info->nr_jited_ksyms * sizeof(__u64);\n\n\tholder.nr_jited_func_lens = info->nr_jited_func_lens;\n\tneeded += info->nr_jited_func_lens * sizeof(__u32);\n\n\tholder.nr_func_info = info->nr_func_info;\n\tholder.func_info_rec_size = info->func_info_rec_size;\n\tneeded += info->nr_func_info * info->func_info_rec_size;\n\n\tholder.nr_line_info = info->nr_line_info;\n\tholder.line_info_rec_size = info->line_info_rec_size;\n\tneeded += info->nr_line_info * info->line_info_rec_size;\n\n\tholder.nr_jited_line_info = info->nr_jited_line_info;\n\tholder.jited_line_info_rec_size = info->jited_line_info_rec_size;\n\tneeded += info->nr_jited_line_info * info->jited_line_info_rec_size;\n\n\tif (needed > *info_data_sz) {\n\t\tptr = realloc(*info_data, needed);\n\t\tif (!ptr)\n\t\t\treturn -1;\n\n\t\t*info_data = ptr;\n\t\t*info_data_sz = needed;\n\t}\n\tptr = *info_data;\n\n\tif (mode == DUMP_JITED) {\n\t\tholder.jited_prog_insns = ptr_to_u64(ptr);\n\t\tptr += holder.jited_prog_len;\n\t} else {\n\t\tholder.xlated_prog_insns = ptr_to_u64(ptr);\n\t\tptr += holder.xlated_prog_len;\n\t}\n\n\tholder.jited_ksyms = ptr_to_u64(ptr);\n\tptr += holder.nr_jited_ksyms * sizeof(__u64);\n\n\tholder.jited_func_lens = ptr_to_u64(ptr);\n\tptr += holder.nr_jited_func_lens * sizeof(__u32);\n\n\tholder.func_info = ptr_to_u64(ptr);\n\tptr += holder.nr_func_info * holder.func_info_rec_size;\n\n\tholder.line_info = ptr_to_u64(ptr);\n\tptr += holder.nr_line_info * holder.line_info_rec_size;\n\n\tholder.jited_line_info = ptr_to_u64(ptr);\n\tptr += holder.nr_jited_line_info * holder.jited_line_info_rec_size;\n\n\t*info = holder;\n\treturn 0;\n}\n\nstatic void print_boot_time(__u64 nsecs, char *buf, unsigned int size)\n{\n\tstruct timespec real_time_ts, boot_time_ts;\n\ttime_t wallclock_secs;\n\tstruct tm load_tm;\n\n\tbuf[--size] = '\\0';\n\n\tif (clock_gettime(CLOCK_REALTIME, &real_time_ts) ||\n\t    clock_gettime(CLOCK_BOOTTIME, &boot_time_ts)) {\n\t\tperror(\"Can't read clocks\");\n\t\tsnprintf(buf, size, \"%llu\", nsecs / 1000000000);\n\t\treturn;\n\t}\n\n\twallclock_secs = (real_time_ts.tv_sec - boot_time_ts.tv_sec) +\n\t\t(real_time_ts.tv_nsec - boot_time_ts.tv_nsec + nsecs) /\n\t\t1000000000;\n\n\n\tif (!localtime_r(&wallclock_secs, &load_tm)) {\n\t\tsnprintf(buf, size, \"%llu\", nsecs / 1000000000);\n\t\treturn;\n\t}\n\n\tif (json_output)\n\t\tstrftime(buf, size, \"%s\", &load_tm);\n\telse\n\t\tstrftime(buf, size, \"%FT%T%z\", &load_tm);\n}\n\nstatic void show_prog_maps(int fd, __u32 num_maps)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 len = sizeof(info);\n\t__u32 map_ids[num_maps];\n\tunsigned int i;\n\tint err;\n\n\tinfo.nr_map_ids = num_maps;\n\tinfo.map_ids = ptr_to_u64(map_ids);\n\n\terr = bpf_prog_get_info_by_fd(fd, &info, &len);\n\tif (err || !info.nr_map_ids)\n\t\treturn;\n\n\tif (json_output) {\n\t\tjsonw_name(json_wtr, \"map_ids\");\n\t\tjsonw_start_array(json_wtr);\n\t\tfor (i = 0; i < info.nr_map_ids; i++)\n\t\t\tjsonw_uint(json_wtr, map_ids[i]);\n\t\tjsonw_end_array(json_wtr);\n\t} else {\n\t\tprintf(\"  map_ids \");\n\t\tfor (i = 0; i < info.nr_map_ids; i++)\n\t\t\tprintf(\"%u%s\", map_ids[i],\n\t\t\t       i == info.nr_map_ids - 1 ? \"\" : \",\");\n\t}\n}\n\nstatic void *find_metadata(int prog_fd, struct bpf_map_info *map_info)\n{\n\tstruct bpf_prog_info prog_info;\n\t__u32 prog_info_len;\n\t__u32 map_info_len;\n\tvoid *value = NULL;\n\t__u32 *map_ids;\n\tint nr_maps;\n\tint key = 0;\n\tint map_fd;\n\tint ret;\n\t__u32 i;\n\n\tmemset(&prog_info, 0, sizeof(prog_info));\n\tprog_info_len = sizeof(prog_info);\n\tret = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &prog_info_len);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (!prog_info.nr_map_ids)\n\t\treturn NULL;\n\n\tmap_ids = calloc(prog_info.nr_map_ids, sizeof(__u32));\n\tif (!map_ids)\n\t\treturn NULL;\n\n\tnr_maps = prog_info.nr_map_ids;\n\tmemset(&prog_info, 0, sizeof(prog_info));\n\tprog_info.nr_map_ids = nr_maps;\n\tprog_info.map_ids = ptr_to_u64(map_ids);\n\tprog_info_len = sizeof(prog_info);\n\n\tret = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &prog_info_len);\n\tif (ret)\n\t\tgoto free_map_ids;\n\n\tfor (i = 0; i < prog_info.nr_map_ids; i++) {\n\t\tmap_fd = bpf_map_get_fd_by_id(map_ids[i]);\n\t\tif (map_fd < 0)\n\t\t\tgoto free_map_ids;\n\n\t\tmemset(map_info, 0, sizeof(*map_info));\n\t\tmap_info_len = sizeof(*map_info);\n\t\tret = bpf_map_get_info_by_fd(map_fd, map_info, &map_info_len);\n\t\tif (ret < 0) {\n\t\t\tclose(map_fd);\n\t\t\tgoto free_map_ids;\n\t\t}\n\n\t\tif (map_info->type != BPF_MAP_TYPE_ARRAY ||\n\t\t    map_info->key_size != sizeof(int) ||\n\t\t    map_info->max_entries != 1 ||\n\t\t    !map_info->btf_value_type_id ||\n\t\t    !strstr(map_info->name, \".rodata\")) {\n\t\t\tclose(map_fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = malloc(map_info->value_size);\n\t\tif (!value) {\n\t\t\tclose(map_fd);\n\t\t\tgoto free_map_ids;\n\t\t}\n\n\t\tif (bpf_map_lookup_elem(map_fd, &key, value)) {\n\t\t\tclose(map_fd);\n\t\t\tfree(value);\n\t\t\tvalue = NULL;\n\t\t\tgoto free_map_ids;\n\t\t}\n\n\t\tclose(map_fd);\n\t\tbreak;\n\t}\n\nfree_map_ids:\n\tfree(map_ids);\n\treturn value;\n}\n\nstatic bool has_metadata_prefix(const char *s)\n{\n\treturn strncmp(s, BPF_METADATA_PREFIX, BPF_METADATA_PREFIX_LEN) == 0;\n}\n\nstatic void show_prog_metadata(int fd, __u32 num_maps)\n{\n\tconst struct btf_type *t_datasec, *t_var;\n\tstruct bpf_map_info map_info;\n\tstruct btf_var_secinfo *vsi;\n\tbool printed_header = false;\n\tunsigned int i, vlen;\n\tvoid *value = NULL;\n\tconst char *name;\n\tstruct btf *btf;\n\tint err;\n\n\tif (!num_maps)\n\t\treturn;\n\n\tmemset(&map_info, 0, sizeof(map_info));\n\tvalue = find_metadata(fd, &map_info);\n\tif (!value)\n\t\treturn;\n\n\tbtf = btf__load_from_kernel_by_id(map_info.btf_id);\n\tif (!btf)\n\t\tgoto out_free;\n\n\tt_datasec = btf__type_by_id(btf, map_info.btf_value_type_id);\n\tif (!btf_is_datasec(t_datasec))\n\t\tgoto out_free;\n\n\tvlen = btf_vlen(t_datasec);\n\tvsi = btf_var_secinfos(t_datasec);\n\n\t \n\n\tif (json_output) {\n\t\tstruct btf_dumper d = {\n\t\t\t.btf = btf,\n\t\t\t.jw = json_wtr,\n\t\t\t.is_plain_text = false,\n\t\t};\n\n\t\tfor (i = 0; i < vlen; i++, vsi++) {\n\t\t\tt_var = btf__type_by_id(btf, vsi->type);\n\t\t\tname = btf__name_by_offset(btf, t_var->name_off);\n\n\t\t\tif (!has_metadata_prefix(name))\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed_header) {\n\t\t\t\tjsonw_name(json_wtr, \"metadata\");\n\t\t\t\tjsonw_start_object(json_wtr);\n\t\t\t\tprinted_header = true;\n\t\t\t}\n\n\t\t\tjsonw_name(json_wtr, name + BPF_METADATA_PREFIX_LEN);\n\t\t\terr = btf_dumper_type(&d, t_var->type, value + vsi->offset);\n\t\t\tif (err) {\n\t\t\t\tp_err(\"btf dump failed: %d\", err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printed_header)\n\t\t\tjsonw_end_object(json_wtr);\n\t} else {\n\t\tjson_writer_t *btf_wtr;\n\t\tstruct btf_dumper d = {\n\t\t\t.btf = btf,\n\t\t\t.is_plain_text = true,\n\t\t};\n\n\t\tfor (i = 0; i < vlen; i++, vsi++) {\n\t\t\tt_var = btf__type_by_id(btf, vsi->type);\n\t\t\tname = btf__name_by_offset(btf, t_var->name_off);\n\n\t\t\tif (!has_metadata_prefix(name))\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed_header) {\n\t\t\t\tprintf(\"\\tmetadata:\");\n\n\t\t\t\tbtf_wtr = jsonw_new(stdout);\n\t\t\t\tif (!btf_wtr) {\n\t\t\t\t\tp_err(\"jsonw alloc failed\");\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\td.jw = btf_wtr,\n\n\t\t\t\tprinted_header = true;\n\t\t\t}\n\n\t\t\tprintf(\"\\n\\t\\t%s = \", name + BPF_METADATA_PREFIX_LEN);\n\n\t\t\tjsonw_reset(btf_wtr);\n\t\t\terr = btf_dumper_type(&d, t_var->type, value + vsi->offset);\n\t\t\tif (err) {\n\t\t\t\tp_err(\"btf dump failed: %d\", err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printed_header)\n\t\t\tjsonw_destroy(&btf_wtr);\n\t}\n\nout_free:\n\tbtf__free(btf);\n\tfree(value);\n}\n\nstatic void print_prog_header_json(struct bpf_prog_info *info, int fd)\n{\n\tconst char *prog_type_str;\n\tchar prog_name[MAX_PROG_FULL_NAME];\n\n\tjsonw_uint_field(json_wtr, \"id\", info->id);\n\tprog_type_str = libbpf_bpf_prog_type_str(info->type);\n\n\tif (prog_type_str)\n\t\tjsonw_string_field(json_wtr, \"type\", prog_type_str);\n\telse\n\t\tjsonw_uint_field(json_wtr, \"type\", info->type);\n\n\tif (*info->name) {\n\t\tget_prog_full_name(info, fd, prog_name, sizeof(prog_name));\n\t\tjsonw_string_field(json_wtr, \"name\", prog_name);\n\t}\n\n\tjsonw_name(json_wtr, \"tag\");\n\tjsonw_printf(json_wtr, \"\\\"\" BPF_TAG_FMT \"\\\"\",\n\t\t     info->tag[0], info->tag[1], info->tag[2], info->tag[3],\n\t\t     info->tag[4], info->tag[5], info->tag[6], info->tag[7]);\n\n\tjsonw_bool_field(json_wtr, \"gpl_compatible\", info->gpl_compatible);\n\tif (info->run_time_ns) {\n\t\tjsonw_uint_field(json_wtr, \"run_time_ns\", info->run_time_ns);\n\t\tjsonw_uint_field(json_wtr, \"run_cnt\", info->run_cnt);\n\t}\n\tif (info->recursion_misses)\n\t\tjsonw_uint_field(json_wtr, \"recursion_misses\", info->recursion_misses);\n}\n\nstatic void print_prog_json(struct bpf_prog_info *info, int fd)\n{\n\tchar *memlock;\n\n\tjsonw_start_object(json_wtr);\n\tprint_prog_header_json(info, fd);\n\tprint_dev_json(info->ifindex, info->netns_dev, info->netns_ino);\n\n\tif (info->load_time) {\n\t\tchar buf[32];\n\n\t\tprint_boot_time(info->load_time, buf, sizeof(buf));\n\n\t\t \n\t\tjsonw_name(json_wtr, \"loaded_at\");\n\t\tjsonw_printf(json_wtr, \"%s\", buf);\n\t\tjsonw_uint_field(json_wtr, \"uid\", info->created_by_uid);\n\t}\n\n\tjsonw_uint_field(json_wtr, \"bytes_xlated\", info->xlated_prog_len);\n\n\tif (info->jited_prog_len) {\n\t\tjsonw_bool_field(json_wtr, \"jited\", true);\n\t\tjsonw_uint_field(json_wtr, \"bytes_jited\", info->jited_prog_len);\n\t} else {\n\t\tjsonw_bool_field(json_wtr, \"jited\", false);\n\t}\n\n\tmemlock = get_fdinfo(fd, \"memlock\");\n\tif (memlock)\n\t\tjsonw_int_field(json_wtr, \"bytes_memlock\", atoll(memlock));\n\tfree(memlock);\n\n\tif (info->nr_map_ids)\n\t\tshow_prog_maps(fd, info->nr_map_ids);\n\n\tif (info->btf_id)\n\t\tjsonw_int_field(json_wtr, \"btf_id\", info->btf_id);\n\n\tif (!hashmap__empty(prog_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\tjsonw_name(json_wtr, \"pinned\");\n\t\tjsonw_start_array(json_wtr);\n\t\thashmap__for_each_key_entry(prog_table, entry, info->id)\n\t\t\tjsonw_string(json_wtr, entry->pvalue);\n\t\tjsonw_end_array(json_wtr);\n\t}\n\n\temit_obj_refs_json(refs_table, info->id, json_wtr);\n\n\tshow_prog_metadata(fd, info->nr_map_ids);\n\n\tjsonw_end_object(json_wtr);\n}\n\nstatic void print_prog_header_plain(struct bpf_prog_info *info, int fd)\n{\n\tconst char *prog_type_str;\n\tchar prog_name[MAX_PROG_FULL_NAME];\n\n\tprintf(\"%u: \", info->id);\n\tprog_type_str = libbpf_bpf_prog_type_str(info->type);\n\tif (prog_type_str)\n\t\tprintf(\"%s  \", prog_type_str);\n\telse\n\t\tprintf(\"type %u  \", info->type);\n\n\tif (*info->name) {\n\t\tget_prog_full_name(info, fd, prog_name, sizeof(prog_name));\n\t\tprintf(\"name %s  \", prog_name);\n\t}\n\n\tprintf(\"tag \");\n\tfprint_hex(stdout, info->tag, BPF_TAG_SIZE, \"\");\n\tprint_dev_plain(info->ifindex, info->netns_dev, info->netns_ino);\n\tprintf(\"%s\", info->gpl_compatible ? \"  gpl\" : \"\");\n\tif (info->run_time_ns)\n\t\tprintf(\" run_time_ns %lld run_cnt %lld\",\n\t\t       info->run_time_ns, info->run_cnt);\n\tif (info->recursion_misses)\n\t\tprintf(\" recursion_misses %lld\", info->recursion_misses);\n\tprintf(\"\\n\");\n}\n\nstatic void print_prog_plain(struct bpf_prog_info *info, int fd)\n{\n\tchar *memlock;\n\n\tprint_prog_header_plain(info, fd);\n\n\tif (info->load_time) {\n\t\tchar buf[32];\n\n\t\tprint_boot_time(info->load_time, buf, sizeof(buf));\n\n\t\t \n\t\tprintf(\"\\tloaded_at %s  uid %u\\n\", buf, info->created_by_uid);\n\t}\n\n\tprintf(\"\\txlated %uB\", info->xlated_prog_len);\n\n\tif (info->jited_prog_len)\n\t\tprintf(\"  jited %uB\", info->jited_prog_len);\n\telse\n\t\tprintf(\"  not jited\");\n\n\tmemlock = get_fdinfo(fd, \"memlock\");\n\tif (memlock)\n\t\tprintf(\"  memlock %sB\", memlock);\n\tfree(memlock);\n\n\tif (info->nr_map_ids)\n\t\tshow_prog_maps(fd, info->nr_map_ids);\n\n\tif (!hashmap__empty(prog_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\thashmap__for_each_key_entry(prog_table, entry, info->id)\n\t\t\tprintf(\"\\n\\tpinned %s\", (char *)entry->pvalue);\n\t}\n\n\tif (info->btf_id)\n\t\tprintf(\"\\n\\tbtf_id %d\", info->btf_id);\n\n\temit_obj_refs_plain(refs_table, info->id, \"\\n\\tpids \");\n\n\tprintf(\"\\n\");\n\n\tshow_prog_metadata(fd, info->nr_map_ids);\n}\n\nstatic int show_prog(int fd)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 len = sizeof(info);\n\tint err;\n\n\terr = bpf_prog_get_info_by_fd(fd, &info, &len);\n\tif (err) {\n\t\tp_err(\"can't get prog info: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (json_output)\n\t\tprint_prog_json(&info, fd);\n\telse\n\t\tprint_prog_plain(&info, fd);\n\n\treturn 0;\n}\n\nstatic int do_show_subset(int argc, char **argv)\n{\n\tint *fds = NULL;\n\tint nb_fds, i;\n\tint err = -1;\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = prog_parse_fds(&argc, &argv, &fds);\n\tif (nb_fds < 1)\n\t\tgoto exit_free;\n\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_start_array(json_wtr);\t \n\tfor (i = 0; i < nb_fds; i++) {\n\t\terr = show_prog(fds[i]);\n\t\tif (err) {\n\t\t\tfor (; i < nb_fds; i++)\n\t\t\t\tclose(fds[i]);\n\t\t\tbreak;\n\t\t}\n\t\tclose(fds[i]);\n\t}\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_end_array(json_wtr);\t \n\nexit_free:\n\tfree(fds);\n\treturn err;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\t__u32 id = 0;\n\tint err;\n\tint fd;\n\n\tif (show_pinned) {\n\t\tprog_table = hashmap__new(hash_fn_for_key_as_id,\n\t\t\t\t\t  equal_fn_for_key_as_id, NULL);\n\t\tif (IS_ERR(prog_table)) {\n\t\t\tp_err(\"failed to create hashmap for pinned paths\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuild_pinned_obj_table(prog_table, BPF_OBJ_PROG);\n\t}\n\tbuild_obj_refs_table(&refs_table, BPF_OBJ_PROG);\n\n\tif (argc == 2)\n\t\treturn do_show_subset(argc, argv);\n\n\tif (argc)\n\t\treturn BAD_ARG();\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\twhile (true) {\n\t\terr = bpf_prog_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_err(\"can't get next program: %s%s\", strerror(errno),\n\t\t\t      errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfd = bpf_prog_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get prog by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = show_prog(fd);\n\t\tclose(fd);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tdelete_obj_refs_table(refs_table);\n\n\tif (show_pinned)\n\t\tdelete_pinned_obj_table(prog_table);\n\n\treturn err;\n}\n\nstatic int\nprog_dump(struct bpf_prog_info *info, enum dump_mode mode,\n\t  char *filepath, bool opcodes, bool visual, bool linum)\n{\n\tstruct bpf_prog_linfo *prog_linfo = NULL;\n\tconst char *disasm_opt = NULL;\n\tstruct dump_data dd = {};\n\tvoid *func_info = NULL;\n\tstruct btf *btf = NULL;\n\tchar func_sig[1024];\n\tunsigned char *buf;\n\t__u32 member_len;\n\tint fd, err = -1;\n\tssize_t n;\n\n\tif (mode == DUMP_JITED) {\n\t\tif (info->jited_prog_len == 0 || !info->jited_prog_insns) {\n\t\t\tp_info(\"no instructions returned\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuf = u64_to_ptr(info->jited_prog_insns);\n\t\tmember_len = info->jited_prog_len;\n\t} else {\t \n\t\tif (info->xlated_prog_len == 0 || !info->xlated_prog_insns) {\n\t\t\tp_err(\"error retrieving insn dump: kernel.kptr_restrict set?\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuf = u64_to_ptr(info->xlated_prog_insns);\n\t\tmember_len = info->xlated_prog_len;\n\t}\n\n\tif (info->btf_id) {\n\t\tbtf = btf__load_from_kernel_by_id(info->btf_id);\n\t\tif (!btf) {\n\t\t\tp_err(\"failed to get btf\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfunc_info = u64_to_ptr(info->func_info);\n\n\tif (info->nr_line_info) {\n\t\tprog_linfo = bpf_prog_linfo__new(info);\n\t\tif (!prog_linfo)\n\t\t\tp_info(\"error in processing bpf_line_info.  continue without it.\");\n\t}\n\n\tif (filepath) {\n\t\tfd = open(filepath, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n\t\tif (fd < 0) {\n\t\t\tp_err(\"can't open file %s: %s\", filepath,\n\t\t\t      strerror(errno));\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tn = write(fd, buf, member_len);\n\t\tclose(fd);\n\t\tif (n != (ssize_t)member_len) {\n\t\t\tp_err(\"error writing output file: %s\",\n\t\t\t      n < 0 ? strerror(errno) : \"short write\");\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (json_output)\n\t\t\tjsonw_null(json_wtr);\n\t} else if (mode == DUMP_JITED) {\n\t\tconst char *name = NULL;\n\n\t\tif (info->ifindex) {\n\t\t\tname = ifindex_to_arch(info->ifindex, info->netns_dev,\n\t\t\t\t\t       info->netns_ino, &disasm_opt);\n\t\t\tif (!name)\n\t\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (info->nr_jited_func_lens && info->jited_func_lens) {\n\t\t\tstruct kernel_sym *sym = NULL;\n\t\t\tstruct bpf_func_info *record;\n\t\t\tchar sym_name[SYM_MAX_NAME];\n\t\t\tunsigned char *img = buf;\n\t\t\t__u64 *ksyms = NULL;\n\t\t\t__u32 *lens;\n\t\t\t__u32 i;\n\t\t\tif (info->nr_jited_ksyms) {\n\t\t\t\tkernel_syms_load(&dd);\n\t\t\t\tksyms = u64_to_ptr(info->jited_ksyms);\n\t\t\t}\n\n\t\t\tif (json_output)\n\t\t\t\tjsonw_start_array(json_wtr);\n\n\t\t\tlens = u64_to_ptr(info->jited_func_lens);\n\t\t\tfor (i = 0; i < info->nr_jited_func_lens; i++) {\n\t\t\t\tif (ksyms) {\n\t\t\t\t\tsym = kernel_syms_search(&dd, ksyms[i]);\n\t\t\t\t\tif (sym)\n\t\t\t\t\t\tsprintf(sym_name, \"%s\", sym->name);\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(sym_name, \"0x%016llx\", ksyms[i]);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(sym_name, \"unknown\");\n\t\t\t\t}\n\n\t\t\t\tif (func_info) {\n\t\t\t\t\trecord = func_info + i * info->func_info_rec_size;\n\t\t\t\t\tbtf_dumper_type_only(btf, record->type_id,\n\t\t\t\t\t\t\t     func_sig,\n\t\t\t\t\t\t\t     sizeof(func_sig));\n\t\t\t\t}\n\n\t\t\t\tif (json_output) {\n\t\t\t\t\tjsonw_start_object(json_wtr);\n\t\t\t\t\tif (func_info && func_sig[0] != '\\0') {\n\t\t\t\t\t\tjsonw_name(json_wtr, \"proto\");\n\t\t\t\t\t\tjsonw_string(json_wtr, func_sig);\n\t\t\t\t\t}\n\t\t\t\t\tjsonw_name(json_wtr, \"name\");\n\t\t\t\t\tjsonw_string(json_wtr, sym_name);\n\t\t\t\t\tjsonw_name(json_wtr, \"insns\");\n\t\t\t\t} else {\n\t\t\t\t\tif (func_info && func_sig[0] != '\\0')\n\t\t\t\t\t\tprintf(\"%s:\\n\", func_sig);\n\t\t\t\t\tprintf(\"%s:\\n\", sym_name);\n\t\t\t\t}\n\n\t\t\t\tif (disasm_print_insn(img, lens[i], opcodes,\n\t\t\t\t\t\t      name, disasm_opt, btf,\n\t\t\t\t\t\t      prog_linfo, ksyms[i], i,\n\t\t\t\t\t\t      linum))\n\t\t\t\t\tgoto exit_free;\n\n\t\t\t\timg += lens[i];\n\n\t\t\t\tif (json_output)\n\t\t\t\t\tjsonw_end_object(json_wtr);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\n\t\t\tif (json_output)\n\t\t\t\tjsonw_end_array(json_wtr);\n\t\t} else {\n\t\t\tif (disasm_print_insn(buf, member_len, opcodes, name,\n\t\t\t\t\t      disasm_opt, btf, NULL, 0, 0,\n\t\t\t\t\t      false))\n\t\t\t\tgoto exit_free;\n\t\t}\n\t} else {\n\t\tkernel_syms_load(&dd);\n\t\tdd.nr_jited_ksyms = info->nr_jited_ksyms;\n\t\tdd.jited_ksyms = u64_to_ptr(info->jited_ksyms);\n\t\tdd.btf = btf;\n\t\tdd.func_info = func_info;\n\t\tdd.finfo_rec_size = info->func_info_rec_size;\n\t\tdd.prog_linfo = prog_linfo;\n\n\t\tif (json_output)\n\t\t\tdump_xlated_json(&dd, buf, member_len, opcodes, linum);\n\t\telse if (visual)\n\t\t\tdump_xlated_cfg(&dd, buf, member_len, opcodes, linum);\n\t\telse\n\t\t\tdump_xlated_plain(&dd, buf, member_len, opcodes, linum);\n\t\tkernel_syms_destroy(&dd);\n\t}\n\n\terr = 0;\n\nexit_free:\n\tbtf__free(btf);\n\tbpf_prog_linfo__free(prog_linfo);\n\treturn err;\n}\n\nstatic int do_dump(int argc, char **argv)\n{\n\tstruct bpf_prog_info info;\n\t__u32 info_len = sizeof(info);\n\tsize_t info_data_sz = 0;\n\tvoid *info_data = NULL;\n\tchar *filepath = NULL;\n\tbool opcodes = false;\n\tbool visual = false;\n\tenum dump_mode mode;\n\tbool linum = false;\n\tint nb_fds, i = 0;\n\tint *fds = NULL;\n\tint err = -1;\n\n\tif (is_prefix(*argv, \"jited\")) {\n\t\tif (disasm_init())\n\t\t\treturn -1;\n\t\tmode = DUMP_JITED;\n\t} else if (is_prefix(*argv, \"xlated\")) {\n\t\tmode = DUMP_XLATED;\n\t} else {\n\t\tp_err(\"expected 'xlated' or 'jited', got: %s\", *argv);\n\t\treturn -1;\n\t}\n\tNEXT_ARG();\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = prog_parse_fds(&argc, &argv, &fds);\n\tif (nb_fds < 1)\n\t\tgoto exit_free;\n\n\twhile (argc) {\n\t\tif (is_prefix(*argv, \"file\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (!argc) {\n\t\t\t\tp_err(\"expected file path\");\n\t\t\t\tgoto exit_close;\n\t\t\t}\n\t\t\tif (nb_fds > 1) {\n\t\t\t\tp_err(\"several programs matched\");\n\t\t\t\tgoto exit_close;\n\t\t\t}\n\n\t\t\tfilepath = *argv;\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"opcodes\")) {\n\t\t\topcodes = true;\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"visual\")) {\n\t\t\tif (nb_fds > 1) {\n\t\t\t\tp_err(\"several programs matched\");\n\t\t\t\tgoto exit_close;\n\t\t\t}\n\n\t\t\tvisual = true;\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"linum\")) {\n\t\t\tlinum = true;\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tusage();\n\t\t\tgoto exit_close;\n\t\t}\n\t}\n\n\tif (filepath && (opcodes || visual || linum)) {\n\t\tp_err(\"'file' is not compatible with 'opcodes', 'visual', or 'linum'\");\n\t\tgoto exit_close;\n\t}\n\tif (json_output && visual) {\n\t\tp_err(\"'visual' is not compatible with JSON output\");\n\t\tgoto exit_close;\n\t}\n\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_start_array(json_wtr);\t \n\tfor (i = 0; i < nb_fds; i++) {\n\t\tmemset(&info, 0, sizeof(info));\n\n\t\terr = bpf_prog_get_info_by_fd(fds[i], &info, &info_len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get prog info: %s\", strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\terr = prep_prog_info(&info, mode, &info_data, &info_data_sz);\n\t\tif (err) {\n\t\t\tp_err(\"can't grow prog info_data\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = bpf_prog_get_info_by_fd(fds[i], &info, &info_len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get prog info: %s\", strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (json_output && nb_fds > 1) {\n\t\t\tjsonw_start_object(json_wtr);\t \n\t\t\tprint_prog_header_json(&info, fds[i]);\n\t\t\tjsonw_name(json_wtr, \"insns\");\n\t\t} else if (nb_fds > 1) {\n\t\t\tprint_prog_header_plain(&info, fds[i]);\n\t\t}\n\n\t\terr = prog_dump(&info, mode, filepath, opcodes, visual, linum);\n\n\t\tif (json_output && nb_fds > 1)\n\t\t\tjsonw_end_object(json_wtr);\t \n\t\telse if (i != nb_fds - 1 && nb_fds > 1)\n\t\t\tprintf(\"\\n\");\n\n\t\tif (err)\n\t\t\tbreak;\n\t\tclose(fds[i]);\n\t}\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_end_array(json_wtr);\t \n\nexit_close:\n\tfor (; i < nb_fds; i++)\n\t\tclose(fds[i]);\nexit_free:\n\tfree(info_data);\n\tfree(fds);\n\treturn err;\n}\n\nstatic int do_pin(int argc, char **argv)\n{\n\tint err;\n\n\terr = do_pin_any(argc, argv, prog_parse_fd);\n\tif (!err && json_output)\n\t\tjsonw_null(json_wtr);\n\treturn err;\n}\n\nstruct map_replace {\n\tint idx;\n\tint fd;\n\tchar *name;\n};\n\nstatic int map_replace_compar(const void *p1, const void *p2)\n{\n\tconst struct map_replace *a = p1, *b = p2;\n\n\treturn a->idx - b->idx;\n}\n\nstatic int parse_attach_detach_args(int argc, char **argv, int *progfd,\n\t\t\t\t    enum bpf_attach_type *attach_type,\n\t\t\t\t    int *mapfd)\n{\n\tif (!REQ_ARGS(3))\n\t\treturn -EINVAL;\n\n\t*progfd = prog_parse_fd(&argc, &argv);\n\tif (*progfd < 0)\n\t\treturn *progfd;\n\n\t*attach_type = parse_attach_type(*argv);\n\tif (*attach_type == __MAX_BPF_ATTACH_TYPE) {\n\t\tp_err(\"invalid attach/detach type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*attach_type == BPF_FLOW_DISSECTOR) {\n\t\t*mapfd = 0;\n\t\treturn 0;\n\t}\n\n\tNEXT_ARG();\n\tif (!REQ_ARGS(2))\n\t\treturn -EINVAL;\n\n\t*mapfd = map_parse_fd(&argc, &argv);\n\tif (*mapfd < 0)\n\t\treturn *mapfd;\n\n\treturn 0;\n}\n\nstatic int do_attach(int argc, char **argv)\n{\n\tenum bpf_attach_type attach_type;\n\tint err, progfd;\n\tint mapfd;\n\n\terr = parse_attach_detach_args(argc, argv,\n\t\t\t\t       &progfd, &attach_type, &mapfd);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_prog_attach(progfd, mapfd, attach_type, 0);\n\tif (err) {\n\t\tp_err(\"failed prog attach to map\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\treturn 0;\n}\n\nstatic int do_detach(int argc, char **argv)\n{\n\tenum bpf_attach_type attach_type;\n\tint err, progfd;\n\tint mapfd;\n\n\terr = parse_attach_detach_args(argc, argv,\n\t\t\t\t       &progfd, &attach_type, &mapfd);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_prog_detach2(progfd, mapfd, attach_type);\n\tif (err) {\n\t\tp_err(\"failed prog detach from map\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\treturn 0;\n}\n\nstatic int check_single_stdin(char *file_data_in, char *file_ctx_in)\n{\n\tif (file_data_in && file_ctx_in &&\n\t    !strcmp(file_data_in, \"-\") && !strcmp(file_ctx_in, \"-\")) {\n\t\tp_err(\"cannot use standard input for both data_in and ctx_in\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_run_data(const char *fname, void **data_ptr, unsigned int *size)\n{\n\tsize_t block_size = 256;\n\tsize_t buf_size = block_size;\n\tsize_t nb_read = 0;\n\tvoid *tmp;\n\tFILE *f;\n\n\tif (!fname) {\n\t\t*data_ptr = NULL;\n\t\t*size = 0;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(fname, \"-\"))\n\t\tf = stdin;\n\telse\n\t\tf = fopen(fname, \"r\");\n\tif (!f) {\n\t\tp_err(\"failed to open %s: %s\", fname, strerror(errno));\n\t\treturn -1;\n\t}\n\n\t*data_ptr = malloc(block_size);\n\tif (!*data_ptr) {\n\t\tp_err(\"failed to allocate memory for data_in/ctx_in: %s\",\n\t\t      strerror(errno));\n\t\tgoto err_fclose;\n\t}\n\n\twhile ((nb_read += fread(*data_ptr + nb_read, 1, block_size, f))) {\n\t\tif (feof(f))\n\t\t\tbreak;\n\t\tif (ferror(f)) {\n\t\t\tp_err(\"failed to read data_in/ctx_in from %s: %s\",\n\t\t\t      fname, strerror(errno));\n\t\t\tgoto err_free;\n\t\t}\n\t\tif (nb_read > buf_size - block_size) {\n\t\t\tif (buf_size == UINT32_MAX) {\n\t\t\t\tp_err(\"data_in/ctx_in is too long (max: %d)\",\n\t\t\t\t      UINT32_MAX);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t \n\t\t\tbuf_size *= 2;\n\t\t\ttmp = realloc(*data_ptr, buf_size);\n\t\t\tif (!tmp) {\n\t\t\t\tp_err(\"failed to reallocate data_in/ctx_in: %s\",\n\t\t\t\t      strerror(errno));\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t*data_ptr = tmp;\n\t\t}\n\t}\n\tif (f != stdin)\n\t\tfclose(f);\n\n\t*size = nb_read;\n\treturn 0;\n\nerr_free:\n\tfree(*data_ptr);\n\t*data_ptr = NULL;\nerr_fclose:\n\tif (f != stdin)\n\t\tfclose(f);\n\treturn -1;\n}\n\nstatic void hex_print(void *data, unsigned int size, FILE *f)\n{\n\tsize_t i, j;\n\tchar c;\n\n\tfor (i = 0; i < size; i += 16) {\n\t\t \n\t\tfprintf(f, \"%07zx\\t\", i);\n\n\t\t \n\t\tfor (j = i; j < i + 16 && j < size; j++)\n\t\t\tfprintf(f, \"%02x%s\", *(uint8_t *)(data + j),\n\t\t\t\tj % 2 ? \" \" : \"\");\n\t\tfor (; j < i + 16; j++)\n\t\t\tfprintf(f, \"  %s\", j % 2 ? \" \" : \"\");\n\n\t\t \n\t\tfprintf(f, \"| \");\n\t\tfor (j = i; j < i + 16 && j < size; j++) {\n\t\t\tc = *(char *)(data + j);\n\t\t\tif (c < ' ' || c > '~')\n\t\t\t\tc = '.';\n\t\t\tfprintf(f, \"%c%s\", c, j == i + 7 ? \" \" : \"\");\n\t\t}\n\n\t\tfprintf(f, \"\\n\");\n\t}\n}\n\nstatic int\nprint_run_output(void *data, unsigned int size, const char *fname,\n\t\t const char *json_key)\n{\n\tsize_t nb_written;\n\tFILE *f;\n\n\tif (!fname)\n\t\treturn 0;\n\n\tif (!strcmp(fname, \"-\")) {\n\t\tf = stdout;\n\t\tif (json_output) {\n\t\t\tjsonw_name(json_wtr, json_key);\n\t\t\tprint_data_json(data, size);\n\t\t} else {\n\t\t\thex_print(data, size, f);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tf = fopen(fname, \"w\");\n\tif (!f) {\n\t\tp_err(\"failed to open %s: %s\", fname, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tnb_written = fwrite(data, 1, size, f);\n\tfclose(f);\n\tif (nb_written != size) {\n\t\tp_err(\"failed to write output data/ctx: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int alloc_run_data(void **data_ptr, unsigned int size_out)\n{\n\t*data_ptr = calloc(size_out, 1);\n\tif (!*data_ptr) {\n\t\tp_err(\"failed to allocate memory for output data/ctx: %s\",\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_run(int argc, char **argv)\n{\n\tchar *data_fname_in = NULL, *data_fname_out = NULL;\n\tchar *ctx_fname_in = NULL, *ctx_fname_out = NULL;\n\tconst unsigned int default_size = SZ_32K;\n\tvoid *data_in = NULL, *data_out = NULL;\n\tvoid *ctx_in = NULL, *ctx_out = NULL;\n\tunsigned int repeat = 1;\n\tint fd, err;\n\tLIBBPF_OPTS(bpf_test_run_opts, test_attr);\n\n\tif (!REQ_ARGS(4))\n\t\treturn -1;\n\n\tfd = prog_parse_fd(&argc, &argv);\n\tif (fd < 0)\n\t\treturn -1;\n\n\twhile (argc) {\n\t\tif (detect_common_prefix(*argv, \"data_in\", \"data_out\",\n\t\t\t\t\t \"data_size_out\", NULL))\n\t\t\treturn -1;\n\t\tif (detect_common_prefix(*argv, \"ctx_in\", \"ctx_out\",\n\t\t\t\t\t \"ctx_size_out\", NULL))\n\t\t\treturn -1;\n\n\t\tif (is_prefix(*argv, \"data_in\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\tdata_fname_in = GET_ARG();\n\t\t\tif (check_single_stdin(data_fname_in, ctx_fname_in))\n\t\t\t\treturn -1;\n\t\t} else if (is_prefix(*argv, \"data_out\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\tdata_fname_out = GET_ARG();\n\t\t} else if (is_prefix(*argv, \"data_size_out\")) {\n\t\t\tchar *endptr;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\ttest_attr.data_size_out = strtoul(*argv, &endptr, 0);\n\t\t\tif (*endptr) {\n\t\t\t\tp_err(\"can't parse %s as output data size\",\n\t\t\t\t      *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"ctx_in\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\tctx_fname_in = GET_ARG();\n\t\t\tif (check_single_stdin(data_fname_in, ctx_fname_in))\n\t\t\t\treturn -1;\n\t\t} else if (is_prefix(*argv, \"ctx_out\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\tctx_fname_out = GET_ARG();\n\t\t} else if (is_prefix(*argv, \"ctx_size_out\")) {\n\t\t\tchar *endptr;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\ttest_attr.ctx_size_out = strtoul(*argv, &endptr, 0);\n\t\t\tif (*endptr) {\n\t\t\t\tp_err(\"can't parse %s as output context size\",\n\t\t\t\t      *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"repeat\")) {\n\t\t\tchar *endptr;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\treturn -1;\n\n\t\t\trepeat = strtoul(*argv, &endptr, 0);\n\t\t\tif (*endptr) {\n\t\t\t\tp_err(\"can't parse %s as repeat number\",\n\t\t\t\t      *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tp_err(\"expected no more arguments, 'data_in', 'data_out', 'data_size_out', 'ctx_in', 'ctx_out', 'ctx_size_out' or 'repeat', got: '%s'?\",\n\t\t\t      *argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\terr = get_run_data(data_fname_in, &data_in, &test_attr.data_size_in);\n\tif (err)\n\t\treturn -1;\n\n\tif (data_in) {\n\t\tif (!test_attr.data_size_out)\n\t\t\ttest_attr.data_size_out = default_size;\n\t\terr = alloc_run_data(&data_out, test_attr.data_size_out);\n\t\tif (err)\n\t\t\tgoto free_data_in;\n\t}\n\n\terr = get_run_data(ctx_fname_in, &ctx_in, &test_attr.ctx_size_in);\n\tif (err)\n\t\tgoto free_data_out;\n\n\tif (ctx_in) {\n\t\tif (!test_attr.ctx_size_out)\n\t\t\ttest_attr.ctx_size_out = default_size;\n\t\terr = alloc_run_data(&ctx_out, test_attr.ctx_size_out);\n\t\tif (err)\n\t\t\tgoto free_ctx_in;\n\t}\n\n\ttest_attr.repeat\t= repeat;\n\ttest_attr.data_in\t= data_in;\n\ttest_attr.data_out\t= data_out;\n\ttest_attr.ctx_in\t= ctx_in;\n\ttest_attr.ctx_out\t= ctx_out;\n\n\terr = bpf_prog_test_run_opts(fd, &test_attr);\n\tif (err) {\n\t\tp_err(\"failed to run program: %s\", strerror(errno));\n\t\tgoto free_ctx_out;\n\t}\n\n\terr = 0;\n\n\tif (json_output)\n\t\tjsonw_start_object(json_wtr);\t \n\n\t \n\tif (test_attr.data_size_out)\n\t\terr += print_run_output(test_attr.data_out,\n\t\t\t\t\ttest_attr.data_size_out,\n\t\t\t\t\tdata_fname_out, \"data_out\");\n\tif (test_attr.ctx_size_out)\n\t\terr += print_run_output(test_attr.ctx_out,\n\t\t\t\t\ttest_attr.ctx_size_out,\n\t\t\t\t\tctx_fname_out, \"ctx_out\");\n\n\tif (json_output) {\n\t\tjsonw_uint_field(json_wtr, \"retval\", test_attr.retval);\n\t\tjsonw_uint_field(json_wtr, \"duration\", test_attr.duration);\n\t\tjsonw_end_object(json_wtr);\t \n\t} else {\n\t\tfprintf(stdout, \"Return value: %u, duration%s: %uns\\n\",\n\t\t\ttest_attr.retval,\n\t\t\trepeat > 1 ? \" (average)\" : \"\", test_attr.duration);\n\t}\n\nfree_ctx_out:\n\tfree(ctx_out);\nfree_ctx_in:\n\tfree(ctx_in);\nfree_data_out:\n\tfree(data_out);\nfree_data_in:\n\tfree(data_in);\n\n\treturn err;\n}\n\nstatic int\nget_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,\n\t\t      enum bpf_attach_type *expected_attach_type)\n{\n\tlibbpf_print_fn_t print_backup;\n\tint ret;\n\n\tret = libbpf_prog_type_by_name(name, prog_type, expected_attach_type);\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\tprint_backup = libbpf_set_print(print_all_levels);\n\tret = libbpf_prog_type_by_name(name, prog_type, expected_attach_type);\n\tlibbpf_set_print(print_backup);\n\n\treturn ret;\n}\n\nstatic int\nauto_attach_program(struct bpf_program *prog, const char *path)\n{\n\tstruct bpf_link *link;\n\tint err;\n\n\tlink = bpf_program__attach(prog);\n\tif (!link) {\n\t\tp_info(\"Program %s does not support autoattach, falling back to pinning\",\n\t\t       bpf_program__name(prog));\n\t\treturn bpf_obj_pin(bpf_program__fd(prog), path);\n\t}\n\n\terr = bpf_link__pin(link, path);\n\tbpf_link__destroy(link);\n\treturn err;\n}\n\nstatic int\nauto_attach_programs(struct bpf_object *obj, const char *path)\n{\n\tstruct bpf_program *prog;\n\tchar buf[PATH_MAX];\n\tint err;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\terr = pathname_concat(buf, sizeof(buf), path, bpf_program__name(prog));\n\t\tif (err)\n\t\t\tgoto err_unpin_programs;\n\n\t\terr = auto_attach_program(prog, buf);\n\t\tif (err)\n\t\t\tgoto err_unpin_programs;\n\t}\n\n\treturn 0;\n\nerr_unpin_programs:\n\twhile ((prog = bpf_object__prev_program(obj, prog))) {\n\t\tif (pathname_concat(buf, sizeof(buf), path, bpf_program__name(prog)))\n\t\t\tcontinue;\n\n\t\tbpf_program__unpin(prog, buf);\n\t}\n\n\treturn err;\n}\n\nstatic int load_with_options(int argc, char **argv, bool first_prog_only)\n{\n\tenum bpf_prog_type common_prog_type = BPF_PROG_TYPE_UNSPEC;\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, open_opts,\n\t\t.relaxed_maps = relaxed_maps,\n\t);\n\tenum bpf_attach_type expected_attach_type;\n\tstruct map_replace *map_replace = NULL;\n\tstruct bpf_program *prog = NULL, *pos;\n\tunsigned int old_map_fds = 0;\n\tconst char *pinmaps = NULL;\n\t__u32 xdpmeta_ifindex = 0;\n\t__u32 offload_ifindex = 0;\n\tbool auto_attach = false;\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tconst char *pinfile;\n\tunsigned int i, j;\n\tconst char *file;\n\tint idx, err;\n\n\n\tif (!REQ_ARGS(2))\n\t\treturn -1;\n\tfile = GET_ARG();\n\tpinfile = GET_ARG();\n\n\twhile (argc) {\n\t\tif (is_prefix(*argv, \"type\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (common_prog_type != BPF_PROG_TYPE_UNSPEC) {\n\t\t\t\tp_err(\"program type already specified\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\terr = libbpf_prog_type_by_name(*argv, &common_prog_type,\n\t\t\t\t\t\t       &expected_attach_type);\n\t\t\tif (err < 0) {\n\t\t\t\t \n\t\t\t\tchar *type = malloc(strlen(*argv) + 2);\n\n\t\t\t\tif (!type) {\n\t\t\t\t\tp_err(\"mem alloc failed\");\n\t\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t\t}\n\t\t\t\t*type = 0;\n\t\t\t\tstrcat(type, *argv);\n\t\t\t\tstrcat(type, \"/\");\n\n\t\t\t\terr = get_prog_type_by_name(type, &common_prog_type,\n\t\t\t\t\t\t\t    &expected_attach_type);\n\t\t\t\tfree(type);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"map\")) {\n\t\t\tvoid *new_map_replace;\n\t\t\tchar *endptr, *name;\n\t\t\tint fd;\n\n\t\t\tNEXT_ARG();\n\n\t\t\tif (!REQ_ARGS(4))\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\tif (is_prefix(*argv, \"idx\")) {\n\t\t\t\tNEXT_ARG();\n\n\t\t\t\tidx = strtoul(*argv, &endptr, 0);\n\t\t\t\tif (*endptr) {\n\t\t\t\t\tp_err(\"can't parse %s as IDX\", *argv);\n\t\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t\t}\n\t\t\t\tname = NULL;\n\t\t\t} else if (is_prefix(*argv, \"name\")) {\n\t\t\t\tNEXT_ARG();\n\n\t\t\t\tname = *argv;\n\t\t\t\tidx = -1;\n\t\t\t} else {\n\t\t\t\tp_err(\"expected 'idx' or 'name', got: '%s'?\",\n\t\t\t\t      *argv);\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\n\t\t\tfd = map_parse_fd(&argc, &argv);\n\t\t\tif (fd < 0)\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\tnew_map_replace = libbpf_reallocarray(map_replace,\n\t\t\t\t\t\t\t      old_map_fds + 1,\n\t\t\t\t\t\t\t      sizeof(*map_replace));\n\t\t\tif (!new_map_replace) {\n\t\t\t\tp_err(\"mem alloc failed\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tmap_replace = new_map_replace;\n\n\t\t\tmap_replace[old_map_fds].idx = idx;\n\t\t\tmap_replace[old_map_fds].name = name;\n\t\t\tmap_replace[old_map_fds].fd = fd;\n\t\t\told_map_fds++;\n\t\t} else if (is_prefix(*argv, \"dev\")) {\n\t\t\tp_info(\"Warning: 'bpftool prog load [...] dev <ifname>' syntax is deprecated.\\n\"\n\t\t\t       \"Going further, please use 'offload_dev <ifname>' to offload program to device.\\n\"\n\t\t\t       \"For applications using XDP hints only, use 'xdpmeta_dev <ifname>'.\");\n\t\t\tgoto offload_dev;\n\t\t} else if (is_prefix(*argv, \"offload_dev\")) {\noffload_dev:\n\t\t\tNEXT_ARG();\n\n\t\t\tif (offload_ifindex) {\n\t\t\t\tp_err(\"offload_dev already specified\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t} else if (xdpmeta_ifindex) {\n\t\t\t\tp_err(\"xdpmeta_dev and offload_dev are mutually exclusive\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\toffload_ifindex = if_nametoindex(*argv);\n\t\t\tif (!offload_ifindex) {\n\t\t\t\tp_err(\"unrecognized netdevice '%s': %s\",\n\t\t\t\t      *argv, strerror(errno));\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"xdpmeta_dev\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (xdpmeta_ifindex) {\n\t\t\t\tp_err(\"xdpmeta_dev already specified\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t} else if (offload_ifindex) {\n\t\t\t\tp_err(\"xdpmeta_dev and offload_dev are mutually exclusive\");\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\txdpmeta_ifindex = if_nametoindex(*argv);\n\t\t\tif (!xdpmeta_ifindex) {\n\t\t\t\tp_err(\"unrecognized netdevice '%s': %s\",\n\t\t\t\t      *argv, strerror(errno));\n\t\t\t\tgoto err_free_reuse_maps;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"pinmaps\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (!REQ_ARGS(1))\n\t\t\t\tgoto err_free_reuse_maps;\n\n\t\t\tpinmaps = GET_ARG();\n\t\t} else if (is_prefix(*argv, \"autoattach\")) {\n\t\t\tauto_attach = true;\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tp_err(\"expected no more arguments, 'type', 'map' or 'dev', got: '%s'?\",\n\t\t\t      *argv);\n\t\t\tgoto err_free_reuse_maps;\n\t\t}\n\t}\n\n\tset_max_rlimit();\n\n\tif (verifier_logs)\n\t\t \n\t\topen_opts.kernel_log_level = 1 + 2 + 4;\n\n\tobj = bpf_object__open_file(file, &open_opts);\n\tif (!obj) {\n\t\tp_err(\"failed to open object file\");\n\t\tgoto err_free_reuse_maps;\n\t}\n\n\tbpf_object__for_each_program(pos, obj) {\n\t\tenum bpf_prog_type prog_type = common_prog_type;\n\n\t\tif (prog_type == BPF_PROG_TYPE_UNSPEC) {\n\t\t\tconst char *sec_name = bpf_program__section_name(pos);\n\n\t\t\terr = get_prog_type_by_name(sec_name, &prog_type,\n\t\t\t\t\t\t    &expected_attach_type);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_close_obj;\n\t\t}\n\n\t\tif (prog_type == BPF_PROG_TYPE_XDP && xdpmeta_ifindex) {\n\t\t\tbpf_program__set_flags(pos, BPF_F_XDP_DEV_BOUND_ONLY);\n\t\t\tbpf_program__set_ifindex(pos, xdpmeta_ifindex);\n\t\t} else {\n\t\t\tbpf_program__set_ifindex(pos, offload_ifindex);\n\t\t}\n\t\tif (bpf_program__type(pos) != prog_type)\n\t\t\tbpf_program__set_type(pos, prog_type);\n\t\tbpf_program__set_expected_attach_type(pos, expected_attach_type);\n\t}\n\n\tqsort(map_replace, old_map_fds, sizeof(*map_replace),\n\t      map_replace_compar);\n\n\t \n\tj = 0;\n\twhile (j < old_map_fds && map_replace[j].name) {\n\t\ti = 0;\n\t\tbpf_object__for_each_map(map, obj) {\n\t\t\tif (!strcmp(bpf_map__name(map), map_replace[j].name)) {\n\t\t\t\tmap_replace[j].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (map_replace[j].idx == -1) {\n\t\t\tp_err(\"unable to find map '%s'\", map_replace[j].name);\n\t\t\tgoto err_close_obj;\n\t\t}\n\t\tj++;\n\t}\n\t \n\tif (j)\n\t\tqsort(map_replace, old_map_fds, sizeof(*map_replace),\n\t\t      map_replace_compar);\n\n\t \n\tj = 0;\n\tidx = 0;\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (bpf_map__type(map) != BPF_MAP_TYPE_PERF_EVENT_ARRAY)\n\t\t\tbpf_map__set_ifindex(map, offload_ifindex);\n\n\t\tif (j < old_map_fds && idx == map_replace[j].idx) {\n\t\t\terr = bpf_map__reuse_fd(map, map_replace[j++].fd);\n\t\t\tif (err) {\n\t\t\t\tp_err(\"unable to set up map reuse: %d\", err);\n\t\t\t\tgoto err_close_obj;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (j < old_map_fds && map_replace[j].idx == idx) {\n\t\t\t\tp_err(\"replacement for map idx %d specified more than once\",\n\t\t\t\t      idx);\n\t\t\t\tgoto err_close_obj;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\tif (j < old_map_fds) {\n\t\tp_err(\"map idx '%d' not used\", map_replace[j].idx);\n\t\tgoto err_close_obj;\n\t}\n\n\terr = bpf_object__load(obj);\n\tif (err) {\n\t\tp_err(\"failed to load object file\");\n\t\tgoto err_close_obj;\n\t}\n\n\terr = mount_bpffs_for_pin(pinfile, !first_prog_only);\n\tif (err)\n\t\tgoto err_close_obj;\n\n\tif (first_prog_only) {\n\t\tprog = bpf_object__next_program(obj, NULL);\n\t\tif (!prog) {\n\t\t\tp_err(\"object file doesn't contain any bpf program\");\n\t\t\tgoto err_close_obj;\n\t\t}\n\n\t\tif (auto_attach)\n\t\t\terr = auto_attach_program(prog, pinfile);\n\t\telse\n\t\t\terr = bpf_obj_pin(bpf_program__fd(prog), pinfile);\n\t\tif (err) {\n\t\t\tp_err(\"failed to pin program %s\",\n\t\t\t      bpf_program__section_name(prog));\n\t\t\tgoto err_close_obj;\n\t\t}\n\t} else {\n\t\tif (auto_attach)\n\t\t\terr = auto_attach_programs(obj, pinfile);\n\t\telse\n\t\t\terr = bpf_object__pin_programs(obj, pinfile);\n\t\tif (err) {\n\t\t\tp_err(\"failed to pin all programs\");\n\t\t\tgoto err_close_obj;\n\t\t}\n\t}\n\n\tif (pinmaps) {\n\t\terr = bpf_object__pin_maps(obj, pinmaps);\n\t\tif (err) {\n\t\t\tp_err(\"failed to pin all maps\");\n\t\t\tgoto err_unpin;\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\tbpf_object__close(obj);\n\tfor (i = 0; i < old_map_fds; i++)\n\t\tclose(map_replace[i].fd);\n\tfree(map_replace);\n\n\treturn 0;\n\nerr_unpin:\n\tif (first_prog_only)\n\t\tunlink(pinfile);\n\telse\n\t\tbpf_object__unpin_programs(obj, pinfile);\nerr_close_obj:\n\tbpf_object__close(obj);\nerr_free_reuse_maps:\n\tfor (i = 0; i < old_map_fds; i++)\n\t\tclose(map_replace[i].fd);\n\tfree(map_replace);\n\treturn -1;\n}\n\nstatic int count_open_fds(void)\n{\n\tDIR *dp = opendir(\"/proc/self/fd\");\n\tstruct dirent *de;\n\tint cnt = -3;\n\n\tif (!dp)\n\t\treturn -1;\n\n\twhile ((de = readdir(dp)))\n\t\tcnt++;\n\n\tclosedir(dp);\n\treturn cnt;\n}\n\nstatic int try_loader(struct gen_loader_opts *gen)\n{\n\tstruct bpf_load_and_run_opts opts = {};\n\tstruct bpf_loader_ctx *ctx;\n\tint ctx_sz = sizeof(*ctx) + 64 * max(sizeof(struct bpf_map_desc),\n\t\t\t\t\t     sizeof(struct bpf_prog_desc));\n\tint log_buf_sz = (1u << 24) - 1;\n\tint err, fds_before, fd_delta;\n\tchar *log_buf = NULL;\n\n\tctx = alloca(ctx_sz);\n\tmemset(ctx, 0, ctx_sz);\n\tctx->sz = ctx_sz;\n\tif (verifier_logs) {\n\t\tctx->log_level = 1 + 2 + 4;\n\t\tctx->log_size = log_buf_sz;\n\t\tlog_buf = malloc(log_buf_sz);\n\t\tif (!log_buf)\n\t\t\treturn -ENOMEM;\n\t\tctx->log_buf = (long) log_buf;\n\t}\n\topts.ctx = ctx;\n\topts.data = gen->data;\n\topts.data_sz = gen->data_sz;\n\topts.insns = gen->insns;\n\topts.insns_sz = gen->insns_sz;\n\tfds_before = count_open_fds();\n\terr = bpf_load_and_run(&opts);\n\tfd_delta = count_open_fds() - fds_before;\n\tif (err < 0 || verifier_logs) {\n\t\tfprintf(stderr, \"err %d\\n%s\\n%s\", err, opts.errstr, log_buf);\n\t\tif (fd_delta && err < 0)\n\t\t\tfprintf(stderr, \"loader prog leaked %d FDs\\n\",\n\t\t\t\tfd_delta);\n\t}\n\tfree(log_buf);\n\treturn err;\n}\n\nstatic int do_loader(int argc, char **argv)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, open_opts);\n\tDECLARE_LIBBPF_OPTS(gen_loader_opts, gen);\n\tstruct bpf_object *obj;\n\tconst char *file;\n\tint err = 0;\n\n\tif (!REQ_ARGS(1))\n\t\treturn -1;\n\tfile = GET_ARG();\n\n\tif (verifier_logs)\n\t\t \n\t\topen_opts.kernel_log_level = 1 + 2 + 4;\n\n\tobj = bpf_object__open_file(file, &open_opts);\n\tif (!obj) {\n\t\tp_err(\"failed to open object file\");\n\t\tgoto err_close_obj;\n\t}\n\n\terr = bpf_object__gen_loader(obj, &gen);\n\tif (err)\n\t\tgoto err_close_obj;\n\n\terr = bpf_object__load(obj);\n\tif (err) {\n\t\tp_err(\"failed to load object file\");\n\t\tgoto err_close_obj;\n\t}\n\n\tif (verifier_logs) {\n\t\tstruct dump_data dd = {};\n\n\t\tkernel_syms_load(&dd);\n\t\tdump_xlated_plain(&dd, (void *)gen.insns, gen.insns_sz, false, false);\n\t\tkernel_syms_destroy(&dd);\n\t}\n\terr = try_loader(&gen);\nerr_close_obj:\n\tbpf_object__close(obj);\n\treturn err;\n}\n\nstatic int do_load(int argc, char **argv)\n{\n\tif (use_loader)\n\t\treturn do_loader(argc, argv);\n\treturn load_with_options(argc, argv, true);\n}\n\nstatic int do_loadall(int argc, char **argv)\n{\n\treturn load_with_options(argc, argv, false);\n}\n\n#ifdef BPFTOOL_WITHOUT_SKELETONS\n\nstatic int do_profile(int argc, char **argv)\n{\n\tp_err(\"bpftool prog profile command is not supported. Please build bpftool with clang >= 10.0.0\");\n\treturn 0;\n}\n\n#else  \n\n#include \"profiler.skel.h\"\n\nstruct profile_metric {\n\tconst char *name;\n\tstruct bpf_perf_event_value val;\n\tstruct perf_event_attr attr;\n\tbool selected;\n\n\t \n\tconst int ratio_metric;  \n\tconst char *ratio_desc;\n\tconst float ratio_mul;\n} metrics[] = {\n\t{\n\t\t.name = \"cycles\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HARDWARE,\n\t\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t\t\t.exclude_user = 1,\n\t\t},\n\t},\n\t{\n\t\t.name = \"instructions\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HARDWARE,\n\t\t\t.config = PERF_COUNT_HW_INSTRUCTIONS,\n\t\t\t.exclude_user = 1,\n\t\t},\n\t\t.ratio_metric = 1,\n\t\t.ratio_desc = \"insns per cycle\",\n\t\t.ratio_mul = 1.0,\n\t},\n\t{\n\t\t.name = \"l1d_loads\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t\t.config =\n\t\t\t\tPERF_COUNT_HW_CACHE_L1D |\n\t\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t\t(PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16),\n\t\t\t.exclude_user = 1,\n\t\t},\n\t},\n\t{\n\t\t.name = \"llc_misses\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t\t.config =\n\t\t\t\tPERF_COUNT_HW_CACHE_LL |\n\t\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t\t(PERF_COUNT_HW_CACHE_RESULT_MISS << 16),\n\t\t\t.exclude_user = 1\n\t\t},\n\t\t.ratio_metric = 2,\n\t\t.ratio_desc = \"LLC misses per million insns\",\n\t\t.ratio_mul = 1e6,\n\t},\n\t{\n\t\t.name = \"itlb_misses\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t\t.config =\n\t\t\t\tPERF_COUNT_HW_CACHE_ITLB |\n\t\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t\t(PERF_COUNT_HW_CACHE_RESULT_MISS << 16),\n\t\t\t.exclude_user = 1\n\t\t},\n\t\t.ratio_metric = 2,\n\t\t.ratio_desc = \"itlb misses per million insns\",\n\t\t.ratio_mul = 1e6,\n\t},\n\t{\n\t\t.name = \"dtlb_misses\",\n\t\t.attr = {\n\t\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t\t.config =\n\t\t\t\tPERF_COUNT_HW_CACHE_DTLB |\n\t\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t\t(PERF_COUNT_HW_CACHE_RESULT_MISS << 16),\n\t\t\t.exclude_user = 1\n\t\t},\n\t\t.ratio_metric = 2,\n\t\t.ratio_desc = \"dtlb misses per million insns\",\n\t\t.ratio_mul = 1e6,\n\t},\n};\n\nstatic __u64 profile_total_count;\n\n#define MAX_NUM_PROFILE_METRICS 4\n\nstatic int profile_parse_metrics(int argc, char **argv)\n{\n\tunsigned int metric_cnt;\n\tint selected_cnt = 0;\n\tunsigned int i;\n\n\tmetric_cnt = ARRAY_SIZE(metrics);\n\n\twhile (argc > 0) {\n\t\tfor (i = 0; i < metric_cnt; i++) {\n\t\t\tif (is_prefix(argv[0], metrics[i].name)) {\n\t\t\t\tif (!metrics[i].selected)\n\t\t\t\t\tselected_cnt++;\n\t\t\t\tmetrics[i].selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == metric_cnt) {\n\t\t\tp_err(\"unknown metric %s\", argv[0]);\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARG();\n\t}\n\tif (selected_cnt > MAX_NUM_PROFILE_METRICS) {\n\t\tp_err(\"too many (%d) metrics, please specify no more than %d metrics at at time\",\n\t\t      selected_cnt, MAX_NUM_PROFILE_METRICS);\n\t\treturn -1;\n\t}\n\treturn selected_cnt;\n}\n\nstatic void profile_read_values(struct profiler_bpf *obj)\n{\n\t__u32 m, cpu, num_cpu = obj->rodata->num_cpu;\n\tint reading_map_fd, count_map_fd;\n\t__u64 counts[num_cpu];\n\t__u32 key = 0;\n\tint err;\n\n\treading_map_fd = bpf_map__fd(obj->maps.accum_readings);\n\tcount_map_fd = bpf_map__fd(obj->maps.counts);\n\tif (reading_map_fd < 0 || count_map_fd < 0) {\n\t\tp_err(\"failed to get fd for map\");\n\t\treturn;\n\t}\n\n\terr = bpf_map_lookup_elem(count_map_fd, &key, counts);\n\tif (err) {\n\t\tp_err(\"failed to read count_map: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tprofile_total_count = 0;\n\tfor (cpu = 0; cpu < num_cpu; cpu++)\n\t\tprofile_total_count += counts[cpu];\n\n\tfor (m = 0; m < ARRAY_SIZE(metrics); m++) {\n\t\tstruct bpf_perf_event_value values[num_cpu];\n\n\t\tif (!metrics[m].selected)\n\t\t\tcontinue;\n\n\t\terr = bpf_map_lookup_elem(reading_map_fd, &key, values);\n\t\tif (err) {\n\t\t\tp_err(\"failed to read reading_map: %s\",\n\t\t\t      strerror(errno));\n\t\t\treturn;\n\t\t}\n\t\tfor (cpu = 0; cpu < num_cpu; cpu++) {\n\t\t\tmetrics[m].val.counter += values[cpu].counter;\n\t\t\tmetrics[m].val.enabled += values[cpu].enabled;\n\t\t\tmetrics[m].val.running += values[cpu].running;\n\t\t}\n\t\tkey++;\n\t}\n}\n\nstatic void profile_print_readings_json(void)\n{\n\t__u32 m;\n\n\tjsonw_start_array(json_wtr);\n\tfor (m = 0; m < ARRAY_SIZE(metrics); m++) {\n\t\tif (!metrics[m].selected)\n\t\t\tcontinue;\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_string_field(json_wtr, \"metric\", metrics[m].name);\n\t\tjsonw_lluint_field(json_wtr, \"run_cnt\", profile_total_count);\n\t\tjsonw_lluint_field(json_wtr, \"value\", metrics[m].val.counter);\n\t\tjsonw_lluint_field(json_wtr, \"enabled\", metrics[m].val.enabled);\n\t\tjsonw_lluint_field(json_wtr, \"running\", metrics[m].val.running);\n\n\t\tjsonw_end_object(json_wtr);\n\t}\n\tjsonw_end_array(json_wtr);\n}\n\nstatic void profile_print_readings_plain(void)\n{\n\t__u32 m;\n\n\tprintf(\"\\n%18llu %-20s\\n\", profile_total_count, \"run_cnt\");\n\tfor (m = 0; m < ARRAY_SIZE(metrics); m++) {\n\t\tstruct bpf_perf_event_value *val = &metrics[m].val;\n\t\tint r;\n\n\t\tif (!metrics[m].selected)\n\t\t\tcontinue;\n\t\tprintf(\"%18llu %-20s\", val->counter, metrics[m].name);\n\n\t\tr = metrics[m].ratio_metric - 1;\n\t\tif (r >= 0 && metrics[r].selected &&\n\t\t    metrics[r].val.counter > 0) {\n\t\t\tprintf(\"# %8.2f %-30s\",\n\t\t\t       val->counter * metrics[m].ratio_mul /\n\t\t\t       metrics[r].val.counter,\n\t\t\t       metrics[m].ratio_desc);\n\t\t} else {\n\t\t\tprintf(\"%-41s\", \"\");\n\t\t}\n\n\t\tif (val->enabled > val->running)\n\t\t\tprintf(\"(%4.2f%%)\",\n\t\t\t       val->running * 100.0 / val->enabled);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic void profile_print_readings(void)\n{\n\tif (json_output)\n\t\tprofile_print_readings_json();\n\telse\n\t\tprofile_print_readings_plain();\n}\n\nstatic char *profile_target_name(int tgt_fd)\n{\n\tstruct bpf_func_info func_info;\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tconst struct btf_type *t;\n\t__u32 func_info_rec_size;\n\tstruct btf *btf = NULL;\n\tchar *name = NULL;\n\tint err;\n\n\terr = bpf_prog_get_info_by_fd(tgt_fd, &info, &info_len);\n\tif (err) {\n\t\tp_err(\"failed to get info for prog FD %d\", tgt_fd);\n\t\tgoto out;\n\t}\n\n\tif (info.btf_id == 0) {\n\t\tp_err(\"prog FD %d doesn't have valid btf\", tgt_fd);\n\t\tgoto out;\n\t}\n\n\tfunc_info_rec_size = info.func_info_rec_size;\n\tif (info.nr_func_info == 0) {\n\t\tp_err(\"found 0 func_info for prog FD %d\", tgt_fd);\n\t\tgoto out;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.nr_func_info = 1;\n\tinfo.func_info_rec_size = func_info_rec_size;\n\tinfo.func_info = ptr_to_u64(&func_info);\n\n\terr = bpf_prog_get_info_by_fd(tgt_fd, &info, &info_len);\n\tif (err) {\n\t\tp_err(\"failed to get func_info for prog FD %d\", tgt_fd);\n\t\tgoto out;\n\t}\n\n\tbtf = btf__load_from_kernel_by_id(info.btf_id);\n\tif (!btf) {\n\t\tp_err(\"failed to load btf for prog FD %d\", tgt_fd);\n\t\tgoto out;\n\t}\n\n\tt = btf__type_by_id(btf, func_info.type_id);\n\tif (!t) {\n\t\tp_err(\"btf %d doesn't have type %d\",\n\t\t      info.btf_id, func_info.type_id);\n\t\tgoto out;\n\t}\n\tname = strdup(btf__name_by_offset(btf, t->name_off));\nout:\n\tbtf__free(btf);\n\treturn name;\n}\n\nstatic struct profiler_bpf *profile_obj;\nstatic int profile_tgt_fd = -1;\nstatic char *profile_tgt_name;\nstatic int *profile_perf_events;\nstatic int profile_perf_event_cnt;\n\nstatic void profile_close_perf_events(struct profiler_bpf *obj)\n{\n\tint i;\n\n\tfor (i = profile_perf_event_cnt - 1; i >= 0; i--)\n\t\tclose(profile_perf_events[i]);\n\n\tfree(profile_perf_events);\n\tprofile_perf_event_cnt = 0;\n}\n\nstatic int profile_open_perf_event(int mid, int cpu, int map_fd)\n{\n\tint pmu_fd;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &metrics[mid].attr,\n\t\t\t -1  , cpu, -1  , 0);\n\tif (pmu_fd < 0) {\n\t\tif (errno == ENODEV) {\n\t\t\tp_info(\"cpu %d may be offline, skip %s profiling.\",\n\t\t\t\tcpu, metrics[mid].name);\n\t\t\tprofile_perf_event_cnt++;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (bpf_map_update_elem(map_fd,\n\t\t\t\t&profile_perf_event_cnt,\n\t\t\t\t&pmu_fd, BPF_ANY) ||\n\t    ioctl(pmu_fd, PERF_EVENT_IOC_ENABLE, 0)) {\n\t\tclose(pmu_fd);\n\t\treturn -1;\n\t}\n\n\tprofile_perf_events[profile_perf_event_cnt++] = pmu_fd;\n\treturn 0;\n}\n\nstatic int profile_open_perf_events(struct profiler_bpf *obj)\n{\n\tunsigned int cpu, m;\n\tint map_fd;\n\n\tprofile_perf_events = calloc(\n\t\tsizeof(int), obj->rodata->num_cpu * obj->rodata->num_metric);\n\tif (!profile_perf_events) {\n\t\tp_err(\"failed to allocate memory for perf_event array: %s\",\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\tmap_fd = bpf_map__fd(obj->maps.events);\n\tif (map_fd < 0) {\n\t\tp_err(\"failed to get fd for events map\");\n\t\treturn -1;\n\t}\n\n\tfor (m = 0; m < ARRAY_SIZE(metrics); m++) {\n\t\tif (!metrics[m].selected)\n\t\t\tcontinue;\n\t\tfor (cpu = 0; cpu < obj->rodata->num_cpu; cpu++) {\n\t\t\tif (profile_open_perf_event(m, cpu, map_fd)) {\n\t\t\t\tp_err(\"failed to create event %s on cpu %d\",\n\t\t\t\t      metrics[m].name, cpu);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void profile_print_and_cleanup(void)\n{\n\tprofile_close_perf_events(profile_obj);\n\tprofile_read_values(profile_obj);\n\tprofile_print_readings();\n\tprofiler_bpf__destroy(profile_obj);\n\n\tclose(profile_tgt_fd);\n\tfree(profile_tgt_name);\n}\n\nstatic void int_exit(int signo)\n{\n\tprofile_print_and_cleanup();\n\texit(0);\n}\n\nstatic int do_profile(int argc, char **argv)\n{\n\tint num_metric, num_cpu, err = -1;\n\tstruct bpf_program *prog;\n\tunsigned long duration;\n\tchar *endptr;\n\n\t \n\tif (!REQ_ARGS(3))\n\t\treturn -EINVAL;\n\n\t \n\tprofile_tgt_fd = prog_parse_fd(&argc, &argv);\n\tif (profile_tgt_fd < 0) {\n\t\tp_err(\"failed to parse fd\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (argc > 2 && is_prefix(argv[0], \"duration\")) {\n\t\tNEXT_ARG();\n\t\tduration = strtoul(*argv, &endptr, 0);\n\t\tif (*endptr)\n\t\t\tusage();\n\t\tNEXT_ARG();\n\t} else {\n\t\tduration = UINT_MAX;\n\t}\n\n\tnum_metric = profile_parse_metrics(argc, argv);\n\tif (num_metric <= 0)\n\t\tgoto out;\n\n\tnum_cpu = libbpf_num_possible_cpus();\n\tif (num_cpu <= 0) {\n\t\tp_err(\"failed to identify number of CPUs\");\n\t\tgoto out;\n\t}\n\n\tprofile_obj = profiler_bpf__open();\n\tif (!profile_obj) {\n\t\tp_err(\"failed to open and/or load BPF object\");\n\t\tgoto out;\n\t}\n\n\tprofile_obj->rodata->num_cpu = num_cpu;\n\tprofile_obj->rodata->num_metric = num_metric;\n\n\t \n\tbpf_map__set_max_entries(profile_obj->maps.events, num_metric * num_cpu);\n\tbpf_map__set_max_entries(profile_obj->maps.fentry_readings, num_metric);\n\tbpf_map__set_max_entries(profile_obj->maps.accum_readings, num_metric);\n\tbpf_map__set_max_entries(profile_obj->maps.counts, 1);\n\n\t \n\tprofile_tgt_name = profile_target_name(profile_tgt_fd);\n\tif (!profile_tgt_name)\n\t\tgoto out;\n\n\tbpf_object__for_each_program(prog, profile_obj->obj) {\n\t\terr = bpf_program__set_attach_target(prog, profile_tgt_fd,\n\t\t\t\t\t\t     profile_tgt_name);\n\t\tif (err) {\n\t\t\tp_err(\"failed to set attach target\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tset_max_rlimit();\n\terr = profiler_bpf__load(profile_obj);\n\tif (err) {\n\t\tp_err(\"failed to load profile_obj\");\n\t\tgoto out;\n\t}\n\n\terr = profile_open_perf_events(profile_obj);\n\tif (err)\n\t\tgoto out;\n\n\terr = profiler_bpf__attach(profile_obj);\n\tif (err) {\n\t\tp_err(\"failed to attach profile_obj\");\n\t\tgoto out;\n\t}\n\tsignal(SIGINT, int_exit);\n\n\tsleep(duration);\n\tprofile_print_and_cleanup();\n\treturn 0;\n\nout:\n\tprofile_close_perf_events(profile_obj);\n\tif (profile_obj)\n\t\tprofiler_bpf__destroy(profile_obj);\n\tclose(profile_tgt_fd);\n\tfree(profile_tgt_name);\n\treturn err;\n}\n\n#endif  \n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list } [PROG]\\n\"\n\t\t\"       %1$s %2$s dump xlated PROG [{ file FILE | [opcodes] [linum] [visual] }]\\n\"\n\t\t\"       %1$s %2$s dump jited  PROG [{ file FILE | [opcodes] [linum] }]\\n\"\n\t\t\"       %1$s %2$s pin   PROG FILE\\n\"\n\t\t\"       %1$s %2$s { load | loadall } OBJ  PATH \\\\\\n\"\n\t\t\"                         [type TYPE] [{ offload_dev | xdpmeta_dev } NAME] \\\\\\n\"\n\t\t\"                         [map { idx IDX | name NAME } MAP]\\\\\\n\"\n\t\t\"                         [pinmaps MAP_DIR]\\n\"\n\t\t\"                         [autoattach]\\n\"\n\t\t\"       %1$s %2$s attach PROG ATTACH_TYPE [MAP]\\n\"\n\t\t\"       %1$s %2$s detach PROG ATTACH_TYPE [MAP]\\n\"\n\t\t\"       %1$s %2$s run PROG \\\\\\n\"\n\t\t\"                         data_in FILE \\\\\\n\"\n\t\t\"                         [data_out FILE [data_size_out L]] \\\\\\n\"\n\t\t\"                         [ctx_in FILE [ctx_out FILE [ctx_size_out M]]] \\\\\\n\"\n\t\t\"                         [repeat N]\\n\"\n\t\t\"       %1$s %2$s profile PROG [duration DURATION] METRICs\\n\"\n\t\t\"       %1$s %2$s tracelog\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_MAP \"\\n\"\n\t\t\"       \" HELP_SPEC_PROGRAM \"\\n\"\n\t\t\"       TYPE := { socket | kprobe | kretprobe | classifier | action |\\n\"\n\t\t\"                 tracepoint | raw_tracepoint | xdp | perf_event | cgroup/skb |\\n\"\n\t\t\"                 cgroup/sock | cgroup/dev | lwt_in | lwt_out | lwt_xmit |\\n\"\n\t\t\"                 lwt_seg6local | sockops | sk_skb | sk_msg | lirc_mode2 |\\n\"\n\t\t\"                 sk_reuseport | flow_dissector | cgroup/sysctl |\\n\"\n\t\t\"                 cgroup/bind4 | cgroup/bind6 | cgroup/post_bind4 |\\n\"\n\t\t\"                 cgroup/post_bind6 | cgroup/connect4 | cgroup/connect6 |\\n\"\n\t\t\"                 cgroup/getpeername4 | cgroup/getpeername6 |\\n\"\n\t\t\"                 cgroup/getsockname4 | cgroup/getsockname6 | cgroup/sendmsg4 |\\n\"\n\t\t\"                 cgroup/sendmsg6 | cgroup/recvmsg4 | cgroup/recvmsg6 |\\n\"\n\t\t\"                 cgroup/getsockopt | cgroup/setsockopt | cgroup/sock_release |\\n\"\n\t\t\"                 struct_ops | fentry | fexit | freplace | sk_lookup }\\n\"\n\t\t\"       ATTACH_TYPE := { sk_msg_verdict | sk_skb_verdict | sk_skb_stream_verdict |\\n\"\n\t\t\"                        sk_skb_stream_parser | flow_dissector }\\n\"\n\t\t\"       METRIC := { cycles | instructions | l1d_loads | llc_misses | itlb_misses | dtlb_misses }\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-f|--bpffs} | {-m|--mapcompat} | {-n|--nomount} |\\n\"\n\t\t\"                    {-L|--use-loader} }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"help\",\tdo_help },\n\t{ \"dump\",\tdo_dump },\n\t{ \"pin\",\tdo_pin },\n\t{ \"load\",\tdo_load },\n\t{ \"loadall\",\tdo_loadall },\n\t{ \"attach\",\tdo_attach },\n\t{ \"detach\",\tdo_detach },\n\t{ \"tracelog\",\tdo_tracelog },\n\t{ \"run\",\tdo_run },\n\t{ \"profile\",\tdo_profile },\n\t{ 0 }\n};\n\nint do_prog(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}