{
  "module_name": "common.c",
  "hash_id": "94c5f3bd0d28c291003bec578c0e1f3423236ee207be06af488d545e9c674e8a",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/common.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <ftw.h>\n#include <libgen.h>\n#include <mntent.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <net/if.h>\n#include <sys/mount.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n\n#include <linux/filter.h>\n#include <linux/limits.h>\n#include <linux/magic.h>\n#include <linux/unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/hashmap.h>\n#include <bpf/libbpf.h>  \n#include <bpf/btf.h>\n\n#include \"main.h\"\n\n#ifndef BPF_FS_MAGIC\n#define BPF_FS_MAGIC\t\t0xcafe4a11\n#endif\n\nvoid p_err(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_name(json_wtr, \"error\");\n\t\tjsonw_vprintf_enquote(json_wtr, fmt, ap);\n\t\tjsonw_end_object(json_wtr);\n\t} else {\n\t\tfprintf(stderr, \"Error: \");\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tva_end(ap);\n}\n\nvoid p_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (json_output)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nstatic bool is_bpffs(const char *path)\n{\n\tstruct statfs st_fs;\n\n\tif (statfs(path, &st_fs) < 0)\n\t\treturn false;\n\n\treturn (unsigned long)st_fs.f_type == BPF_FS_MAGIC;\n}\n\n \nstatic bool known_to_need_rlimit(void)\n{\n\tstruct rlimit rlim_init, rlim_cur_zero = {};\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tsize_t insn_cnt = ARRAY_SIZE(insns);\n\tunion bpf_attr attr;\n\tint prog_fd, err;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insns = ptr_to_u64(insns);\n\tattr.insn_cnt = insn_cnt;\n\tattr.license = ptr_to_u64(\"GPL\");\n\n\tif (getrlimit(RLIMIT_MEMLOCK, &rlim_init))\n\t\treturn false;\n\n\t \n\trlim_cur_zero.rlim_max = rlim_init.rlim_max;\n\tif (setrlimit(RLIMIT_MEMLOCK, &rlim_cur_zero))\n\t\treturn false;\n\n\t \n\tprog_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\n\terr = errno;\n\n\t \n\tsetrlimit(RLIMIT_MEMLOCK, &rlim_init);\n\n\tif (prog_fd < 0)\n\t\treturn err == EPERM;\n\n\tclose(prog_fd);\n\treturn false;\n}\n\nvoid set_max_rlimit(void)\n{\n\tstruct rlimit rinf = { RLIM_INFINITY, RLIM_INFINITY };\n\n\tif (known_to_need_rlimit())\n\t\tsetrlimit(RLIMIT_MEMLOCK, &rinf);\n}\n\nstatic int\nmnt_fs(const char *target, const char *type, char *buff, size_t bufflen)\n{\n\tbool bind_done = false;\n\n\twhile (mount(\"\", target, \"none\", MS_PRIVATE | MS_REC, NULL)) {\n\t\tif (errno != EINVAL || bind_done) {\n\t\t\tsnprintf(buff, bufflen,\n\t\t\t\t \"mount --make-private %s failed: %s\",\n\t\t\t\t target, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mount(target, target, \"none\", MS_BIND, NULL)) {\n\t\t\tsnprintf(buff, bufflen,\n\t\t\t\t \"mount --bind %s %s failed: %s\",\n\t\t\t\t target, target, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tbind_done = true;\n\t}\n\n\tif (mount(type, target, type, 0, \"mode=0700\")) {\n\t\tsnprintf(buff, bufflen, \"mount -t %s %s %s failed: %s\",\n\t\t\t type, type, target, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint mount_tracefs(const char *target)\n{\n\tchar err_str[ERR_MAX_LEN];\n\tint err;\n\n\terr = mnt_fs(target, \"tracefs\", err_str, ERR_MAX_LEN);\n\tif (err) {\n\t\terr_str[ERR_MAX_LEN - 1] = '\\0';\n\t\tp_err(\"can't mount tracefs: %s\", err_str);\n\t}\n\n\treturn err;\n}\n\nint open_obj_pinned(const char *path, bool quiet)\n{\n\tchar *pname;\n\tint fd = -1;\n\n\tpname = strdup(path);\n\tif (!pname) {\n\t\tif (!quiet)\n\t\t\tp_err(\"mem alloc failed\");\n\t\tgoto out_ret;\n\t}\n\n\tfd = bpf_obj_get(pname);\n\tif (fd < 0) {\n\t\tif (!quiet)\n\t\t\tp_err(\"bpf obj get (%s): %s\", pname,\n\t\t\t      errno == EACCES && !is_bpffs(dirname(pname)) ?\n\t\t\t    \"directory not in bpf file system (bpffs)\" :\n\t\t\t    strerror(errno));\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tfree(pname);\nout_ret:\n\treturn fd;\n}\n\nint open_obj_pinned_any(const char *path, enum bpf_obj_type exp_type)\n{\n\tenum bpf_obj_type type;\n\tint fd;\n\n\tfd = open_obj_pinned(path, false);\n\tif (fd < 0)\n\t\treturn -1;\n\n\ttype = get_fd_type(fd);\n\tif (type < 0) {\n\t\tclose(fd);\n\t\treturn type;\n\t}\n\tif (type != exp_type) {\n\t\tp_err(\"incorrect object type: %s\", get_fd_type_name(type));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nint mount_bpffs_for_pin(const char *name, bool is_dir)\n{\n\tchar err_str[ERR_MAX_LEN];\n\tchar *file;\n\tchar *dir;\n\tint err = 0;\n\n\tif (is_dir && is_bpffs(name))\n\t\treturn err;\n\n\tfile = malloc(strlen(name) + 1);\n\tif (!file) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\n\tstrcpy(file, name);\n\tdir = dirname(file);\n\n\tif (is_bpffs(dir))\n\t\t \n\t\tgoto out_free;\n\n\tif (block_mount) {\n\t\tp_err(\"no BPF file system found, not mounting it due to --nomount option\");\n\t\terr = -1;\n\t\tgoto out_free;\n\t}\n\n\terr = mnt_fs(dir, \"bpf\", err_str, ERR_MAX_LEN);\n\tif (err) {\n\t\terr_str[ERR_MAX_LEN - 1] = '\\0';\n\t\tp_err(\"can't mount BPF file system to pin the object (%s): %s\",\n\t\t      name, err_str);\n\t}\n\nout_free:\n\tfree(file);\n\treturn err;\n}\n\nint do_pin_fd(int fd, const char *name)\n{\n\tint err;\n\n\terr = mount_bpffs_for_pin(name, false);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_obj_pin(fd, name);\n\tif (err)\n\t\tp_err(\"can't pin the object (%s): %s\", name, strerror(errno));\n\n\treturn err;\n}\n\nint do_pin_any(int argc, char **argv, int (*get_fd)(int *, char ***))\n{\n\tint err;\n\tint fd;\n\n\tif (!REQ_ARGS(3))\n\t\treturn -EINVAL;\n\n\tfd = get_fd(&argc, &argv);\n\tif (fd < 0)\n\t\treturn fd;\n\n\terr = do_pin_fd(fd, *argv);\n\n\tclose(fd);\n\treturn err;\n}\n\nconst char *get_fd_type_name(enum bpf_obj_type type)\n{\n\tstatic const char * const names[] = {\n\t\t[BPF_OBJ_UNKNOWN]\t= \"unknown\",\n\t\t[BPF_OBJ_PROG]\t\t= \"prog\",\n\t\t[BPF_OBJ_MAP]\t\t= \"map\",\n\t\t[BPF_OBJ_LINK]\t\t= \"link\",\n\t};\n\n\tif (type < 0 || type >= ARRAY_SIZE(names) || !names[type])\n\t\treturn names[BPF_OBJ_UNKNOWN];\n\n\treturn names[type];\n}\n\nvoid get_prog_full_name(const struct bpf_prog_info *prog_info, int prog_fd,\n\t\t\tchar *name_buff, size_t buff_len)\n{\n\tconst char *prog_name = prog_info->name;\n\tconst struct btf_type *func_type;\n\tconst struct bpf_func_info finfo = {};\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tstruct btf *prog_btf = NULL;\n\n\tif (buff_len <= BPF_OBJ_NAME_LEN ||\n\t    strlen(prog_info->name) < BPF_OBJ_NAME_LEN - 1)\n\t\tgoto copy_name;\n\n\tif (!prog_info->btf_id || prog_info->nr_func_info == 0)\n\t\tgoto copy_name;\n\n\tinfo.nr_func_info = 1;\n\tinfo.func_info_rec_size = prog_info->func_info_rec_size;\n\tif (info.func_info_rec_size > sizeof(finfo))\n\t\tinfo.func_info_rec_size = sizeof(finfo);\n\tinfo.func_info = ptr_to_u64(&finfo);\n\n\tif (bpf_prog_get_info_by_fd(prog_fd, &info, &info_len))\n\t\tgoto copy_name;\n\n\tprog_btf = btf__load_from_kernel_by_id(info.btf_id);\n\tif (!prog_btf)\n\t\tgoto copy_name;\n\n\tfunc_type = btf__type_by_id(prog_btf, finfo.type_id);\n\tif (!func_type || !btf_is_func(func_type))\n\t\tgoto copy_name;\n\n\tprog_name = btf__name_by_offset(prog_btf, func_type->name_off);\n\ncopy_name:\n\tsnprintf(name_buff, buff_len, \"%s\", prog_name);\n\n\tif (prog_btf)\n\t\tbtf__free(prog_btf);\n}\n\nint get_fd_type(int fd)\n{\n\tchar path[PATH_MAX];\n\tchar buf[512];\n\tssize_t n;\n\n\tsnprintf(path, sizeof(path), \"/proc/self/fd/%d\", fd);\n\n\tn = readlink(path, buf, sizeof(buf));\n\tif (n < 0) {\n\t\tp_err(\"can't read link type: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (n == sizeof(path)) {\n\t\tp_err(\"can't read link type: path too long!\");\n\t\treturn -1;\n\t}\n\n\tif (strstr(buf, \"bpf-map\"))\n\t\treturn BPF_OBJ_MAP;\n\telse if (strstr(buf, \"bpf-prog\"))\n\t\treturn BPF_OBJ_PROG;\n\telse if (strstr(buf, \"bpf-link\"))\n\t\treturn BPF_OBJ_LINK;\n\n\treturn BPF_OBJ_UNKNOWN;\n}\n\nchar *get_fdinfo(int fd, const char *key)\n{\n\tchar path[PATH_MAX];\n\tchar *line = NULL;\n\tsize_t line_n = 0;\n\tssize_t n;\n\tFILE *fdi;\n\n\tsnprintf(path, sizeof(path), \"/proc/self/fdinfo/%d\", fd);\n\n\tfdi = fopen(path, \"r\");\n\tif (!fdi)\n\t\treturn NULL;\n\n\twhile ((n = getline(&line, &line_n, fdi)) > 0) {\n\t\tchar *value;\n\t\tint len;\n\n\t\tif (!strstr(line, key))\n\t\t\tcontinue;\n\n\t\tfclose(fdi);\n\n\t\tvalue = strchr(line, '\\t');\n\t\tif (!value || !value[1]) {\n\t\t\tfree(line);\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue++;\n\n\t\tlen = strlen(value);\n\t\tmemmove(line, value, len);\n\t\tline[len - 1] = '\\0';\n\n\t\treturn line;\n\t}\n\n\tfree(line);\n\tfclose(fdi);\n\treturn NULL;\n}\n\nvoid print_data_json(uint8_t *data, size_t len)\n{\n\tunsigned int i;\n\n\tjsonw_start_array(json_wtr);\n\tfor (i = 0; i < len; i++)\n\t\tjsonw_printf(json_wtr, \"%d\", data[i]);\n\tjsonw_end_array(json_wtr);\n}\n\nvoid print_hex_data_json(uint8_t *data, size_t len)\n{\n\tunsigned int i;\n\n\tjsonw_start_array(json_wtr);\n\tfor (i = 0; i < len; i++)\n\t\tjsonw_printf(json_wtr, \"\\\"0x%02hhx\\\"\", data[i]);\n\tjsonw_end_array(json_wtr);\n}\n\n \nstatic struct hashmap *build_fn_table;\nstatic enum bpf_obj_type build_fn_type;\n\nstatic int do_build_table_cb(const char *fpath, const struct stat *sb,\n\t\t\t     int typeflag, struct FTW *ftwbuf)\n{\n\tstruct bpf_prog_info pinned_info;\n\t__u32 len = sizeof(pinned_info);\n\tenum bpf_obj_type objtype;\n\tint fd, err = 0;\n\tchar *path;\n\n\tif (typeflag != FTW_F)\n\t\tgoto out_ret;\n\n\tfd = open_obj_pinned(fpath, true);\n\tif (fd < 0)\n\t\tgoto out_ret;\n\n\tobjtype = get_fd_type(fd);\n\tif (objtype != build_fn_type)\n\t\tgoto out_close;\n\n\tmemset(&pinned_info, 0, sizeof(pinned_info));\n\tif (bpf_prog_get_info_by_fd(fd, &pinned_info, &len))\n\t\tgoto out_close;\n\n\tpath = strdup(fpath);\n\tif (!path) {\n\t\terr = -1;\n\t\tgoto out_close;\n\t}\n\n\terr = hashmap__append(build_fn_table, pinned_info.id, path);\n\tif (err) {\n\t\tp_err(\"failed to append entry to hashmap for ID %u, path '%s': %s\",\n\t\t      pinned_info.id, path, strerror(errno));\n\t\tfree(path);\n\t\tgoto out_close;\n\t}\n\nout_close:\n\tclose(fd);\nout_ret:\n\treturn err;\n}\n\nint build_pinned_obj_table(struct hashmap *tab,\n\t\t\t   enum bpf_obj_type type)\n{\n\tstruct mntent *mntent = NULL;\n\tFILE *mntfile = NULL;\n\tint flags = FTW_PHYS;\n\tint nopenfd = 16;\n\tint err = 0;\n\n\tmntfile = setmntent(\"/proc/mounts\", \"r\");\n\tif (!mntfile)\n\t\treturn -1;\n\n\tbuild_fn_table = tab;\n\tbuild_fn_type = type;\n\n\twhile ((mntent = getmntent(mntfile))) {\n\t\tchar *path = mntent->mnt_dir;\n\n\t\tif (strncmp(mntent->mnt_type, \"bpf\", 3) != 0)\n\t\t\tcontinue;\n\t\terr = nftw(path, do_build_table_cb, nopenfd, flags);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tfclose(mntfile);\n\treturn err;\n}\n\nvoid delete_pinned_obj_table(struct hashmap *map)\n{\n\tstruct hashmap_entry *entry;\n\tsize_t bkt;\n\n\tif (!map)\n\t\treturn;\n\n\thashmap__for_each_entry(map, entry, bkt)\n\t\tfree(entry->pvalue);\n\n\thashmap__free(map);\n}\n\nunsigned int get_page_size(void)\n{\n\tstatic int result;\n\n\tif (!result)\n\t\tresult = getpagesize();\n\treturn result;\n}\n\nunsigned int get_possible_cpus(void)\n{\n\tint cpus = libbpf_num_possible_cpus();\n\n\tif (cpus < 0) {\n\t\tp_err(\"Can't get # of possible cpus: %s\", strerror(-cpus));\n\t\texit(-1);\n\t}\n\treturn cpus;\n}\n\nstatic char *\nifindex_to_name_ns(__u32 ifindex, __u32 ns_dev, __u32 ns_ino, char *buf)\n{\n\tstruct stat st;\n\tint err;\n\n\terr = stat(\"/proc/self/ns/net\", &st);\n\tif (err) {\n\t\tp_err(\"Can't stat /proc/self: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (st.st_dev != ns_dev || st.st_ino != ns_ino)\n\t\treturn NULL;\n\n\treturn if_indextoname(ifindex, buf);\n}\n\nstatic int read_sysfs_hex_int(char *path)\n{\n\tchar vendor_id_buf[8];\n\tint len;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tp_err(\"Can't open %s: %s\", path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = read(fd, vendor_id_buf, sizeof(vendor_id_buf));\n\tclose(fd);\n\tif (len < 0) {\n\t\tp_err(\"Can't read %s: %s\", path, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (len >= (int)sizeof(vendor_id_buf)) {\n\t\tp_err(\"Value in %s too long\", path);\n\t\treturn -1;\n\t}\n\n\tvendor_id_buf[len] = 0;\n\n\treturn strtol(vendor_id_buf, NULL, 0);\n}\n\nstatic int read_sysfs_netdev_hex_int(char *devname, const char *entry_name)\n{\n\tchar full_path[64];\n\n\tsnprintf(full_path, sizeof(full_path), \"/sys/class/net/%s/device/%s\",\n\t\t devname, entry_name);\n\n\treturn read_sysfs_hex_int(full_path);\n}\n\nconst char *\nifindex_to_arch(__u32 ifindex, __u64 ns_dev, __u64 ns_ino, const char **opt)\n{\n\t__maybe_unused int device_id;\n\tchar devname[IF_NAMESIZE];\n\tint vendor_id;\n\n\tif (!ifindex_to_name_ns(ifindex, ns_dev, ns_ino, devname)) {\n\t\tp_err(\"Can't get net device name for ifindex %d: %s\", ifindex,\n\t\t      strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tvendor_id = read_sysfs_netdev_hex_int(devname, \"vendor\");\n\tif (vendor_id < 0) {\n\t\tp_err(\"Can't get device vendor id for %s\", devname);\n\t\treturn NULL;\n\t}\n\n\tswitch (vendor_id) {\n#ifdef HAVE_LIBBFD_SUPPORT\n\tcase 0x19ee:\n\t\tdevice_id = read_sysfs_netdev_hex_int(devname, \"device\");\n\t\tif (device_id != 0x4000 &&\n\t\t    device_id != 0x6000 &&\n\t\t    device_id != 0x6003)\n\t\t\tp_info(\"Unknown NFP device ID, assuming it is NFP-6xxx arch\");\n\t\t*opt = \"ctx4\";\n\t\treturn \"NFP-6xxx\";\n#endif  \n\t \n\tdefault:\n\t\tp_err(\"Can't get arch name for device vendor id 0x%04x\",\n\t\t      vendor_id);\n\t\treturn NULL;\n\t}\n}\n\nvoid print_dev_plain(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)\n{\n\tchar name[IF_NAMESIZE];\n\n\tif (!ifindex)\n\t\treturn;\n\n\tprintf(\"  offloaded_to \");\n\tif (ifindex_to_name_ns(ifindex, ns_dev, ns_inode, name))\n\t\tprintf(\"%s\", name);\n\telse\n\t\tprintf(\"ifindex %u ns_dev %llu ns_ino %llu\",\n\t\t       ifindex, ns_dev, ns_inode);\n}\n\nvoid print_dev_json(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)\n{\n\tchar name[IF_NAMESIZE];\n\n\tif (!ifindex)\n\t\treturn;\n\n\tjsonw_name(json_wtr, \"dev\");\n\tjsonw_start_object(json_wtr);\n\tjsonw_uint_field(json_wtr, \"ifindex\", ifindex);\n\tjsonw_uint_field(json_wtr, \"ns_dev\", ns_dev);\n\tjsonw_uint_field(json_wtr, \"ns_inode\", ns_inode);\n\tif (ifindex_to_name_ns(ifindex, ns_dev, ns_inode, name))\n\t\tjsonw_string_field(json_wtr, \"ifname\", name);\n\tjsonw_end_object(json_wtr);\n}\n\nint parse_u32_arg(int *argc, char ***argv, __u32 *val, const char *what)\n{\n\tchar *endptr;\n\n\tNEXT_ARGP();\n\n\tif (*val) {\n\t\tp_err(\"%s already specified\", what);\n\t\treturn -1;\n\t}\n\n\t*val = strtoul(**argv, &endptr, 0);\n\tif (*endptr) {\n\t\tp_err(\"can't parse %s as %s\", **argv, what);\n\t\treturn -1;\n\t}\n\tNEXT_ARGP();\n\n\treturn 0;\n}\n\nint __printf(2, 0)\nprint_all_levels(__maybe_unused enum libbpf_print_level level,\n\t\t const char *format, va_list args)\n{\n\treturn vfprintf(stderr, format, args);\n}\n\nstatic int prog_fd_by_nametag(void *nametag, int **fds, bool tag)\n{\n\tchar prog_name[MAX_PROG_FULL_NAME];\n\tunsigned int id = 0;\n\tint fd, nb_fds = 0;\n\tvoid *tmp;\n\tint err;\n\n\twhile (true) {\n\t\tstruct bpf_prog_info info = {};\n\t\t__u32 len = sizeof(info);\n\n\t\terr = bpf_prog_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno != ENOENT) {\n\t\t\t\tp_err(\"%s\", strerror(errno));\n\t\t\t\tgoto err_close_fds;\n\t\t\t}\n\t\t\treturn nb_fds;\n\t\t}\n\n\t\tfd = bpf_prog_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tp_err(\"can't get prog by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tgoto err_close_fds;\n\t\t}\n\n\t\terr = bpf_prog_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get prog info (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tgoto err_close_fd;\n\t\t}\n\n\t\tif (tag && memcmp(nametag, info.tag, BPF_TAG_SIZE)) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!tag) {\n\t\t\tget_prog_full_name(&info, fd, prog_name,\n\t\t\t\t\t   sizeof(prog_name));\n\t\t\tif (strncmp(nametag, prog_name, sizeof(prog_name))) {\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_fds > 0) {\n\t\t\ttmp = realloc(*fds, (nb_fds + 1) * sizeof(int));\n\t\t\tif (!tmp) {\n\t\t\t\tp_err(\"failed to realloc\");\n\t\t\t\tgoto err_close_fd;\n\t\t\t}\n\t\t\t*fds = tmp;\n\t\t}\n\t\t(*fds)[nb_fds++] = fd;\n\t}\n\nerr_close_fd:\n\tclose(fd);\nerr_close_fds:\n\twhile (--nb_fds >= 0)\n\t\tclose((*fds)[nb_fds]);\n\treturn -1;\n}\n\nint prog_parse_fds(int *argc, char ***argv, int **fds)\n{\n\tif (is_prefix(**argv, \"id\")) {\n\t\tunsigned int id;\n\t\tchar *endptr;\n\n\t\tNEXT_ARGP();\n\n\t\tid = strtoul(**argv, &endptr, 0);\n\t\tif (*endptr) {\n\t\t\tp_err(\"can't parse %s as ID\", **argv);\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\t(*fds)[0] = bpf_prog_get_fd_by_id(id);\n\t\tif ((*fds)[0] < 0) {\n\t\t\tp_err(\"get by id (%u): %s\", id, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t} else if (is_prefix(**argv, \"tag\")) {\n\t\tunsigned char tag[BPF_TAG_SIZE];\n\n\t\tNEXT_ARGP();\n\n\t\tif (sscanf(**argv, BPF_TAG_FMT, tag, tag + 1, tag + 2,\n\t\t\t   tag + 3, tag + 4, tag + 5, tag + 6, tag + 7)\n\t\t    != BPF_TAG_SIZE) {\n\t\t\tp_err(\"can't parse tag\");\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\treturn prog_fd_by_nametag(tag, fds, true);\n\t} else if (is_prefix(**argv, \"name\")) {\n\t\tchar *name;\n\n\t\tNEXT_ARGP();\n\n\t\tname = **argv;\n\t\tif (strlen(name) > MAX_PROG_FULL_NAME - 1) {\n\t\t\tp_err(\"can't parse name\");\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\treturn prog_fd_by_nametag(name, fds, false);\n\t} else if (is_prefix(**argv, \"pinned\")) {\n\t\tchar *path;\n\n\t\tNEXT_ARGP();\n\n\t\tpath = **argv;\n\t\tNEXT_ARGP();\n\n\t\t(*fds)[0] = open_obj_pinned_any(path, BPF_OBJ_PROG);\n\t\tif ((*fds)[0] < 0)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\n\tp_err(\"expected 'id', 'tag', 'name' or 'pinned', got: '%s'?\", **argv);\n\treturn -1;\n}\n\nint prog_parse_fd(int *argc, char ***argv)\n{\n\tint *fds = NULL;\n\tint nb_fds, fd;\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = prog_parse_fds(argc, argv, &fds);\n\tif (nb_fds != 1) {\n\t\tif (nb_fds > 1) {\n\t\t\tp_err(\"several programs match this handle\");\n\t\t\twhile (nb_fds--)\n\t\t\t\tclose(fds[nb_fds]);\n\t\t}\n\t\tfd = -1;\n\t\tgoto exit_free;\n\t}\n\n\tfd = fds[0];\nexit_free:\n\tfree(fds);\n\treturn fd;\n}\n\nstatic int map_fd_by_name(char *name, int **fds)\n{\n\tunsigned int id = 0;\n\tint fd, nb_fds = 0;\n\tvoid *tmp;\n\tint err;\n\n\twhile (true) {\n\t\tstruct bpf_map_info info = {};\n\t\t__u32 len = sizeof(info);\n\n\t\terr = bpf_map_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno != ENOENT) {\n\t\t\t\tp_err(\"%s\", strerror(errno));\n\t\t\t\tgoto err_close_fds;\n\t\t\t}\n\t\t\treturn nb_fds;\n\t\t}\n\n\t\tfd = bpf_map_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tp_err(\"can't get map by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tgoto err_close_fds;\n\t\t}\n\n\t\terr = bpf_map_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get map info (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tgoto err_close_fd;\n\t\t}\n\n\t\tif (strncmp(name, info.name, BPF_OBJ_NAME_LEN)) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nb_fds > 0) {\n\t\t\ttmp = realloc(*fds, (nb_fds + 1) * sizeof(int));\n\t\t\tif (!tmp) {\n\t\t\t\tp_err(\"failed to realloc\");\n\t\t\t\tgoto err_close_fd;\n\t\t\t}\n\t\t\t*fds = tmp;\n\t\t}\n\t\t(*fds)[nb_fds++] = fd;\n\t}\n\nerr_close_fd:\n\tclose(fd);\nerr_close_fds:\n\twhile (--nb_fds >= 0)\n\t\tclose((*fds)[nb_fds]);\n\treturn -1;\n}\n\nint map_parse_fds(int *argc, char ***argv, int **fds)\n{\n\tif (is_prefix(**argv, \"id\")) {\n\t\tunsigned int id;\n\t\tchar *endptr;\n\n\t\tNEXT_ARGP();\n\n\t\tid = strtoul(**argv, &endptr, 0);\n\t\tif (*endptr) {\n\t\t\tp_err(\"can't parse %s as ID\", **argv);\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\t(*fds)[0] = bpf_map_get_fd_by_id(id);\n\t\tif ((*fds)[0] < 0) {\n\t\t\tp_err(\"get map by id (%u): %s\", id, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t} else if (is_prefix(**argv, \"name\")) {\n\t\tchar *name;\n\n\t\tNEXT_ARGP();\n\n\t\tname = **argv;\n\t\tif (strlen(name) > BPF_OBJ_NAME_LEN - 1) {\n\t\t\tp_err(\"can't parse name\");\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARGP();\n\n\t\treturn map_fd_by_name(name, fds);\n\t} else if (is_prefix(**argv, \"pinned\")) {\n\t\tchar *path;\n\n\t\tNEXT_ARGP();\n\n\t\tpath = **argv;\n\t\tNEXT_ARGP();\n\n\t\t(*fds)[0] = open_obj_pinned_any(path, BPF_OBJ_MAP);\n\t\tif ((*fds)[0] < 0)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\n\tp_err(\"expected 'id', 'name' or 'pinned', got: '%s'?\", **argv);\n\treturn -1;\n}\n\nint map_parse_fd(int *argc, char ***argv)\n{\n\tint *fds = NULL;\n\tint nb_fds, fd;\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = map_parse_fds(argc, argv, &fds);\n\tif (nb_fds != 1) {\n\t\tif (nb_fds > 1) {\n\t\t\tp_err(\"several maps match this handle\");\n\t\t\twhile (nb_fds--)\n\t\t\t\tclose(fds[nb_fds]);\n\t\t}\n\t\tfd = -1;\n\t\tgoto exit_free;\n\t}\n\n\tfd = fds[0];\nexit_free:\n\tfree(fds);\n\treturn fd;\n}\n\nint map_parse_fd_and_info(int *argc, char ***argv, struct bpf_map_info *info,\n\t\t\t  __u32 *info_len)\n{\n\tint err;\n\tint fd;\n\n\tfd = map_parse_fd(argc, argv);\n\tif (fd < 0)\n\t\treturn -1;\n\n\terr = bpf_map_get_info_by_fd(fd, info, info_len);\n\tif (err) {\n\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\tclose(fd);\n\t\treturn err;\n\t}\n\n\treturn fd;\n}\n\nsize_t hash_fn_for_key_as_id(long key, void *ctx)\n{\n\treturn key;\n}\n\nbool equal_fn_for_key_as_id(long k1, long k2, void *ctx)\n{\n\treturn k1 == k2;\n}\n\nconst char *bpf_attach_type_input_str(enum bpf_attach_type t)\n{\n\tswitch (t) {\n\tcase BPF_CGROUP_INET_INGRESS:\t\treturn \"ingress\";\n\tcase BPF_CGROUP_INET_EGRESS:\t\treturn \"egress\";\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\treturn \"sock_create\";\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\treturn \"sock_release\";\n\tcase BPF_CGROUP_SOCK_OPS:\t\treturn \"sock_ops\";\n\tcase BPF_CGROUP_DEVICE:\t\t\treturn \"device\";\n\tcase BPF_CGROUP_INET4_BIND:\t\treturn \"bind4\";\n\tcase BPF_CGROUP_INET6_BIND:\t\treturn \"bind6\";\n\tcase BPF_CGROUP_INET4_CONNECT:\t\treturn \"connect4\";\n\tcase BPF_CGROUP_INET6_CONNECT:\t\treturn \"connect6\";\n\tcase BPF_CGROUP_INET4_POST_BIND:\treturn \"post_bind4\";\n\tcase BPF_CGROUP_INET6_POST_BIND:\treturn \"post_bind6\";\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\treturn \"getpeername4\";\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\treturn \"getpeername6\";\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\treturn \"getsockname4\";\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\treturn \"getsockname6\";\n\tcase BPF_CGROUP_UDP4_SENDMSG:\t\treturn \"sendmsg4\";\n\tcase BPF_CGROUP_UDP6_SENDMSG:\t\treturn \"sendmsg6\";\n\tcase BPF_CGROUP_SYSCTL:\t\t\treturn \"sysctl\";\n\tcase BPF_CGROUP_UDP4_RECVMSG:\t\treturn \"recvmsg4\";\n\tcase BPF_CGROUP_UDP6_RECVMSG:\t\treturn \"recvmsg6\";\n\tcase BPF_CGROUP_GETSOCKOPT:\t\treturn \"getsockopt\";\n\tcase BPF_CGROUP_SETSOCKOPT:\t\treturn \"setsockopt\";\n\tcase BPF_TRACE_RAW_TP:\t\t\treturn \"raw_tp\";\n\tcase BPF_TRACE_FENTRY:\t\t\treturn \"fentry\";\n\tcase BPF_TRACE_FEXIT:\t\t\treturn \"fexit\";\n\tcase BPF_MODIFY_RETURN:\t\t\treturn \"mod_ret\";\n\tcase BPF_SK_REUSEPORT_SELECT:\t\treturn \"sk_skb_reuseport_select\";\n\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:\treturn \"sk_skb_reuseport_select_or_migrate\";\n\tdefault:\treturn libbpf_bpf_attach_type_str(t);\n\t}\n}\n\nint pathname_concat(char *buf, int buf_sz, const char *path,\n\t\t    const char *name)\n{\n\tint len;\n\n\tlen = snprintf(buf, buf_sz, \"%s/%s\", path, name);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len >= buf_sz)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}