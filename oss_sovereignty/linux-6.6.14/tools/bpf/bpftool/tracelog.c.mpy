{
  "module_name": "tracelog.c",
  "hash_id": "c6ca44bb889b1689fcabc76fe6293086d94f2a171a853e03eb3048d7ea9e0678",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/tracelog.c",
  "human_readable_source": "\n \n \n\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/magic.h>\n#include <fcntl.h>\n#include <sys/vfs.h>\n\n#include \"main.h\"\n\n#ifndef TRACEFS_MAGIC\n# define TRACEFS_MAGIC\t0x74726163\n#endif\n\n#define _textify(x)\t#x\n#define textify(x)\t_textify(x)\n\nFILE *trace_pipe_fd;\nchar *buff;\n\nstatic int validate_tracefs_mnt(const char *mnt, unsigned long magic)\n{\n\tstruct statfs st_fs;\n\n\tif (statfs(mnt, &st_fs) < 0)\n\t\treturn -ENOENT;\n\tif ((unsigned long)st_fs.f_type != magic)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic bool\nfind_tracefs_mnt_single(unsigned long magic, char *mnt, const char *mntpt)\n{\n\tsize_t src_len;\n\n\tif (validate_tracefs_mnt(mntpt, magic))\n\t\treturn false;\n\n\tsrc_len = strlen(mntpt);\n\tif (src_len + 1 >= PATH_MAX) {\n\t\tp_err(\"tracefs mount point name too long\");\n\t\treturn false;\n\t}\n\n\tstrcpy(mnt, mntpt);\n\treturn true;\n}\n\nstatic bool get_tracefs_pipe(char *mnt)\n{\n\tstatic const char * const known_mnts[] = {\n\t\t\"/sys/kernel/debug/tracing\",\n\t\t\"/sys/kernel/tracing\",\n\t\t\"/tracing\",\n\t\t\"/trace\",\n\t};\n\tconst char *pipe_name = \"/trace_pipe\";\n\tconst char *fstype = \"tracefs\";\n\tchar type[100], format[32];\n\tconst char * const *ptr;\n\tbool found = false;\n\tFILE *fp;\n\n\tfor (ptr = known_mnts; ptr < known_mnts + ARRAY_SIZE(known_mnts); ptr++)\n\t\tif (find_tracefs_mnt_single(TRACEFS_MAGIC, mnt, *ptr))\n\t\t\tgoto exit_found;\n\n\tfp = fopen(\"/proc/mounts\", \"r\");\n\tif (!fp)\n\t\treturn false;\n\n\t \n\tsnprintf(format, sizeof(format), \"%%*s %%%zds %%99s %%*s %%*d %%*d\\\\n\",\n\t\t PATH_MAX - strlen(pipe_name) - 1);\n\twhile (fscanf(fp, format, mnt, type) == 2)\n\t\tif (strcmp(type, fstype) == 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\tfclose(fp);\n\n\t \n\tif (found && validate_tracefs_mnt(mnt, TRACEFS_MAGIC))\n\t\tgoto exit_found;\n\n\tif (block_mount)\n\t\treturn false;\n\n\tp_info(\"could not find tracefs, attempting to mount it now\");\n\t \n\tstrcpy(mnt, known_mnts[1]);\n\tif (mount_tracefs(mnt))\n\t\treturn false;\n\nexit_found:\n\tstrcat(mnt, pipe_name);\n\treturn true;\n}\n\nstatic void exit_tracelog(int signum)\n{\n\tfclose(trace_pipe_fd);\n\tfree(buff);\n\n\tif (json_output) {\n\t\tjsonw_end_array(json_wtr);\n\t\tjsonw_destroy(&json_wtr);\n\t}\n\n\texit(0);\n}\n\nint do_tracelog(int argc, char **argv)\n{\n\tconst struct sigaction act = {\n\t\t.sa_handler = exit_tracelog\n\t};\n\tchar trace_pipe[PATH_MAX];\n\tsize_t buff_len = 0;\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\n\tif (!get_tracefs_pipe(trace_pipe))\n\t\treturn -1;\n\n\ttrace_pipe_fd = fopen(trace_pipe, \"r\");\n\tif (!trace_pipe_fd) {\n\t\tp_err(\"could not open trace pipe: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tsigaction(SIGHUP, &act, NULL);\n\tsigaction(SIGINT, &act, NULL);\n\tsigaction(SIGTERM, &act, NULL);\n\twhile (1) {\n\t\tssize_t ret;\n\n\t\tret = getline(&buff, &buff_len, trace_pipe_fd);\n\t\tif (ret <= 0) {\n\t\t\tp_err(\"failed to read content from trace pipe: %s\",\n\t\t\t      strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_string(json_wtr, buff);\n\t\telse\n\t\t\tprintf(\"%s\", buff);\n\t}\n\n\tfclose(trace_pipe_fd);\n\tfree(buff);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}