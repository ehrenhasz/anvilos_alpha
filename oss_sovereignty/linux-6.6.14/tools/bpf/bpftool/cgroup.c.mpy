{
  "module_name": "cgroup.c",
  "hash_id": "e19a5789417059f70bf6514e96af98c420b9064458c88a6d3b6ae0e896f5a209",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/cgroup.c",
  "human_readable_source": "\n\n\n\n#define _XOPEN_SOURCE 500\n#include <errno.h>\n#include <fcntl.h>\n#include <ftw.h>\n#include <mntent.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n\n#include \"main.h\"\n\n#define HELP_SPEC_ATTACH_FLAGS\t\t\t\t\t\t\\\n\t\"ATTACH_FLAGS := { multi | override }\"\n\n#define HELP_SPEC_ATTACH_TYPES\t\t\t\t\t\t\\\n\t\"       ATTACH_TYPE := { cgroup_inet_ingress | cgroup_inet_egress |\\n\" \\\n\t\"                        cgroup_inet_sock_create | cgroup_sock_ops |\\n\" \\\n\t\"                        cgroup_device | cgroup_inet4_bind |\\n\" \\\n\t\"                        cgroup_inet6_bind | cgroup_inet4_post_bind |\\n\" \\\n\t\"                        cgroup_inet6_post_bind | cgroup_inet4_connect |\\n\" \\\n\t\"                        cgroup_inet6_connect | cgroup_inet4_getpeername |\\n\" \\\n\t\"                        cgroup_inet6_getpeername | cgroup_inet4_getsockname |\\n\" \\\n\t\"                        cgroup_inet6_getsockname | cgroup_udp4_sendmsg |\\n\" \\\n\t\"                        cgroup_udp6_sendmsg | cgroup_udp4_recvmsg |\\n\" \\\n\t\"                        cgroup_udp6_recvmsg | cgroup_sysctl |\\n\" \\\n\t\"                        cgroup_getsockopt | cgroup_setsockopt |\\n\" \\\n\t\"                        cgroup_inet_sock_release }\"\n\nstatic unsigned int query_flags;\nstatic struct btf *btf_vmlinux;\nstatic __u32 btf_vmlinux_id;\n\nstatic enum bpf_attach_type parse_attach_type(const char *str)\n{\n\tconst char *attach_type_str;\n\tenum bpf_attach_type type;\n\n\tfor (type = 0; ; type++) {\n\t\tattach_type_str = libbpf_bpf_attach_type_str(type);\n\t\tif (!attach_type_str)\n\t\t\tbreak;\n\t\tif (!strcmp(str, attach_type_str))\n\t\t\treturn type;\n\t}\n\n\t \n\tfor (type = 0; ; type++) {\n\t\tattach_type_str = bpf_attach_type_input_str(type);\n\t\tif (!attach_type_str)\n\t\t\tbreak;\n\t\tif (is_prefix(str, attach_type_str))\n\t\t\treturn type;\n\t}\n\n\treturn __MAX_BPF_ATTACH_TYPE;\n}\n\nstatic void guess_vmlinux_btf_id(__u32 attach_btf_obj_id)\n{\n\tstruct bpf_btf_info btf_info = {};\n\t__u32 btf_len = sizeof(btf_info);\n\tchar name[16] = {};\n\tint err;\n\tint fd;\n\n\tbtf_info.name = ptr_to_u64(name);\n\tbtf_info.name_len = sizeof(name);\n\n\tfd = bpf_btf_get_fd_by_id(attach_btf_obj_id);\n\tif (fd < 0)\n\t\treturn;\n\n\terr = bpf_btf_get_info_by_fd(fd, &btf_info, &btf_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (btf_info.kernel_btf && strncmp(name, \"vmlinux\", sizeof(name)) == 0)\n\t\tbtf_vmlinux_id = btf_info.id;\n\nout:\n\tclose(fd);\n}\n\nstatic int show_bpf_prog(int id, enum bpf_attach_type attach_type,\n\t\t\t const char *attach_flags_str,\n\t\t\t int level)\n{\n\tchar prog_name[MAX_PROG_FULL_NAME];\n\tconst char *attach_btf_name = NULL;\n\tstruct bpf_prog_info info = {};\n\tconst char *attach_type_str;\n\t__u32 info_len = sizeof(info);\n\tint prog_fd;\n\n\tprog_fd = bpf_prog_get_fd_by_id(id);\n\tif (prog_fd < 0)\n\t\treturn -1;\n\n\tif (bpf_prog_get_info_by_fd(prog_fd, &info, &info_len)) {\n\t\tclose(prog_fd);\n\t\treturn -1;\n\t}\n\n\tattach_type_str = libbpf_bpf_attach_type_str(attach_type);\n\n\tif (btf_vmlinux) {\n\t\tif (!btf_vmlinux_id)\n\t\t\tguess_vmlinux_btf_id(info.attach_btf_obj_id);\n\n\t\tif (btf_vmlinux_id == info.attach_btf_obj_id &&\n\t\t    info.attach_btf_id < btf__type_cnt(btf_vmlinux)) {\n\t\t\tconst struct btf_type *t =\n\t\t\t\tbtf__type_by_id(btf_vmlinux, info.attach_btf_id);\n\t\t\tattach_btf_name =\n\t\t\t\tbtf__name_by_offset(btf_vmlinux, t->name_off);\n\t\t}\n\t}\n\n\tget_prog_full_name(&info, prog_fd, prog_name, sizeof(prog_name));\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_uint_field(json_wtr, \"id\", info.id);\n\t\tif (attach_type_str)\n\t\t\tjsonw_string_field(json_wtr, \"attach_type\", attach_type_str);\n\t\telse\n\t\t\tjsonw_uint_field(json_wtr, \"attach_type\", attach_type);\n\t\tif (!(query_flags & BPF_F_QUERY_EFFECTIVE))\n\t\t\tjsonw_string_field(json_wtr, \"attach_flags\", attach_flags_str);\n\t\tjsonw_string_field(json_wtr, \"name\", prog_name);\n\t\tif (attach_btf_name)\n\t\t\tjsonw_string_field(json_wtr, \"attach_btf_name\", attach_btf_name);\n\t\tjsonw_uint_field(json_wtr, \"attach_btf_obj_id\", info.attach_btf_obj_id);\n\t\tjsonw_uint_field(json_wtr, \"attach_btf_id\", info.attach_btf_id);\n\t\tjsonw_end_object(json_wtr);\n\t} else {\n\t\tprintf(\"%s%-8u \", level ? \"    \" : \"\", info.id);\n\t\tif (attach_type_str)\n\t\t\tprintf(\"%-15s\", attach_type_str);\n\t\telse\n\t\t\tprintf(\"type %-10u\", attach_type);\n\t\tif (query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\t\tprintf(\" %-15s\", prog_name);\n\t\telse\n\t\t\tprintf(\" %-15s %-15s\", attach_flags_str, prog_name);\n\t\tif (attach_btf_name)\n\t\t\tprintf(\" %-15s\", attach_btf_name);\n\t\telse if (info.attach_btf_id)\n\t\t\tprintf(\" attach_btf_obj_id=%d attach_btf_id=%d\",\n\t\t\t       info.attach_btf_obj_id, info.attach_btf_id);\n\t\tprintf(\"\\n\");\n\t}\n\n\tclose(prog_fd);\n\treturn 0;\n}\n\nstatic int count_attached_bpf_progs(int cgroup_fd, enum bpf_attach_type type)\n{\n\t__u32 prog_cnt = 0;\n\tint ret;\n\n\tret = bpf_prog_query(cgroup_fd, type, query_flags, NULL,\n\t\t\t     NULL, &prog_cnt);\n\tif (ret)\n\t\treturn -1;\n\n\treturn prog_cnt;\n}\n\nstatic int cgroup_has_attached_progs(int cgroup_fd)\n{\n\tenum bpf_attach_type type;\n\tbool no_prog = true;\n\n\tfor (type = 0; type < __MAX_BPF_ATTACH_TYPE; type++) {\n\t\tint count = count_attached_bpf_progs(cgroup_fd, type);\n\n\t\tif (count < 0 && errno != EINVAL)\n\t\t\treturn -1;\n\n\t\tif (count > 0) {\n\t\t\tno_prog = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn no_prog ? 0 : 1;\n}\n\nstatic int show_effective_bpf_progs(int cgroup_fd, enum bpf_attach_type type,\n\t\t\t\t    int level)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, p);\n\t__u32 prog_ids[1024] = {0};\n\t__u32 iter;\n\tint ret;\n\n\tp.query_flags = query_flags;\n\tp.prog_cnt = ARRAY_SIZE(prog_ids);\n\tp.prog_ids = prog_ids;\n\n\tret = bpf_prog_query_opts(cgroup_fd, type, &p);\n\tif (ret)\n\t\treturn ret;\n\n\tif (p.prog_cnt == 0)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < p.prog_cnt; iter++)\n\t\tshow_bpf_prog(prog_ids[iter], type, NULL, level);\n\n\treturn 0;\n}\n\nstatic int show_attached_bpf_progs(int cgroup_fd, enum bpf_attach_type type,\n\t\t\t\t   int level)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, p);\n\t__u32 prog_attach_flags[1024] = {0};\n\tconst char *attach_flags_str;\n\t__u32 prog_ids[1024] = {0};\n\tchar buf[32];\n\t__u32 iter;\n\tint ret;\n\n\tp.query_flags = query_flags;\n\tp.prog_cnt = ARRAY_SIZE(prog_ids);\n\tp.prog_ids = prog_ids;\n\tp.prog_attach_flags = prog_attach_flags;\n\n\tret = bpf_prog_query_opts(cgroup_fd, type, &p);\n\tif (ret)\n\t\treturn ret;\n\n\tif (p.prog_cnt == 0)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < p.prog_cnt; iter++) {\n\t\t__u32 attach_flags;\n\n\t\tattach_flags = prog_attach_flags[iter] ?: p.attach_flags;\n\n\t\tswitch (attach_flags) {\n\t\tcase BPF_F_ALLOW_MULTI:\n\t\t\tattach_flags_str = \"multi\";\n\t\t\tbreak;\n\t\tcase BPF_F_ALLOW_OVERRIDE:\n\t\t\tattach_flags_str = \"override\";\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tattach_flags_str = \"\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buf, sizeof(buf), \"unknown(%x)\", attach_flags);\n\t\t\tattach_flags_str = buf;\n\t\t}\n\n\t\tshow_bpf_prog(prog_ids[iter], type,\n\t\t\t      attach_flags_str, level);\n\t}\n\n\treturn 0;\n}\n\nstatic int show_bpf_progs(int cgroup_fd, enum bpf_attach_type type,\n\t\t\t  int level)\n{\n\treturn query_flags & BPF_F_QUERY_EFFECTIVE ?\n\t       show_effective_bpf_progs(cgroup_fd, type, level) :\n\t       show_attached_bpf_progs(cgroup_fd, type, level);\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tenum bpf_attach_type type;\n\tint has_attached_progs;\n\tconst char *path;\n\tint cgroup_fd;\n\tint ret = -1;\n\n\tquery_flags = 0;\n\n\tif (!REQ_ARGS(1))\n\t\treturn -1;\n\tpath = GET_ARG();\n\n\twhile (argc) {\n\t\tif (is_prefix(*argv, \"effective\")) {\n\t\t\tif (query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\t\t\tp_err(\"duplicated argument: %s\", *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tquery_flags |= BPF_F_QUERY_EFFECTIVE;\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tp_err(\"expected no more arguments, 'effective', got: '%s'?\",\n\t\t\t      *argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcgroup_fd = open(path, O_RDONLY);\n\tif (cgroup_fd < 0) {\n\t\tp_err(\"can't open cgroup %s\", path);\n\t\tgoto exit;\n\t}\n\n\thas_attached_progs = cgroup_has_attached_progs(cgroup_fd);\n\tif (has_attached_progs < 0) {\n\t\tp_err(\"can't query bpf programs attached to %s: %s\",\n\t\t      path, strerror(errno));\n\t\tgoto exit_cgroup;\n\t} else if (!has_attached_progs) {\n\t\tret = 0;\n\t\tgoto exit_cgroup;\n\t}\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\telse if (query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tprintf(\"%-8s %-15s %-15s\\n\", \"ID\", \"AttachType\", \"Name\");\n\telse\n\t\tprintf(\"%-8s %-15s %-15s %-15s\\n\", \"ID\", \"AttachType\",\n\t\t       \"AttachFlags\", \"Name\");\n\n\tbtf_vmlinux = libbpf_find_kernel_btf();\n\tfor (type = 0; type < __MAX_BPF_ATTACH_TYPE; type++) {\n\t\t \n\t\tif (show_bpf_progs(cgroup_fd, type, 0) == 0)\n\t\t\tret = 0;\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\nexit_cgroup:\n\tclose(cgroup_fd);\nexit:\n\treturn ret;\n}\n\n \n#define NFTW_ERR\t\t-1\n#define SHOW_TREE_FN_ERR\t-2\nstatic int do_show_tree_fn(const char *fpath, const struct stat *sb,\n\t\t\t   int typeflag, struct FTW *ftw)\n{\n\tenum bpf_attach_type type;\n\tint has_attached_progs;\n\tint cgroup_fd;\n\n\tif (typeflag != FTW_D)\n\t\treturn 0;\n\n\tcgroup_fd = open(fpath, O_RDONLY);\n\tif (cgroup_fd < 0) {\n\t\tp_err(\"can't open cgroup %s: %s\", fpath, strerror(errno));\n\t\treturn SHOW_TREE_FN_ERR;\n\t}\n\n\thas_attached_progs = cgroup_has_attached_progs(cgroup_fd);\n\tif (has_attached_progs < 0) {\n\t\tp_err(\"can't query bpf programs attached to %s: %s\",\n\t\t      fpath, strerror(errno));\n\t\tclose(cgroup_fd);\n\t\treturn SHOW_TREE_FN_ERR;\n\t} else if (!has_attached_progs) {\n\t\tclose(cgroup_fd);\n\t\treturn 0;\n\t}\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_string_field(json_wtr, \"cgroup\", fpath);\n\t\tjsonw_name(json_wtr, \"programs\");\n\t\tjsonw_start_array(json_wtr);\n\t} else {\n\t\tprintf(\"%s\\n\", fpath);\n\t}\n\n\tbtf_vmlinux = libbpf_find_kernel_btf();\n\tfor (type = 0; type < __MAX_BPF_ATTACH_TYPE; type++)\n\t\tshow_bpf_progs(cgroup_fd, type, ftw->level);\n\n\tif (errno == EINVAL)\n\t\t \n\t\terrno = 0;\n\n\tif (json_output) {\n\t\tjsonw_end_array(json_wtr);\n\t\tjsonw_end_object(json_wtr);\n\t}\n\n\tclose(cgroup_fd);\n\n\treturn 0;\n}\n\nstatic char *find_cgroup_root(void)\n{\n\tstruct mntent *mnt;\n\tFILE *f;\n\n\tf = fopen(\"/proc/mounts\", \"r\");\n\tif (f == NULL)\n\t\treturn NULL;\n\n\twhile ((mnt = getmntent(f))) {\n\t\tif (strcmp(mnt->mnt_type, \"cgroup2\") == 0) {\n\t\t\tfclose(f);\n\t\t\treturn strdup(mnt->mnt_dir);\n\t\t}\n\t}\n\n\tfclose(f);\n\treturn NULL;\n}\n\nstatic int do_show_tree(int argc, char **argv)\n{\n\tchar *cgroup_root, *cgroup_alloced = NULL;\n\tint ret;\n\n\tquery_flags = 0;\n\n\tif (!argc) {\n\t\tcgroup_alloced = find_cgroup_root();\n\t\tif (!cgroup_alloced) {\n\t\t\tp_err(\"cgroup v2 isn't mounted\");\n\t\t\treturn -1;\n\t\t}\n\t\tcgroup_root = cgroup_alloced;\n\t} else {\n\t\tcgroup_root = GET_ARG();\n\n\t\twhile (argc) {\n\t\t\tif (is_prefix(*argv, \"effective\")) {\n\t\t\t\tif (query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\t\t\t\tp_err(\"duplicated argument: %s\", *argv);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tquery_flags |= BPF_F_QUERY_EFFECTIVE;\n\t\t\t\tNEXT_ARG();\n\t\t\t} else {\n\t\t\t\tp_err(\"expected no more arguments, 'effective', got: '%s'?\",\n\t\t\t\t      *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\telse if (query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tprintf(\"%s\\n\"\n\t\t       \"%-8s %-15s %-15s\\n\",\n\t\t       \"CgroupPath\",\n\t\t       \"ID\", \"AttachType\", \"Name\");\n\telse\n\t\tprintf(\"%s\\n\"\n\t\t       \"%-8s %-15s %-15s %-15s\\n\",\n\t\t       \"CgroupPath\",\n\t\t       \"ID\", \"AttachType\", \"AttachFlags\", \"Name\");\n\n\tswitch (nftw(cgroup_root, do_show_tree_fn, 1024, FTW_MOUNT)) {\n\tcase NFTW_ERR:\n\t\tp_err(\"can't iterate over %s: %s\", cgroup_root,\n\t\t      strerror(errno));\n\t\tret = -1;\n\t\tbreak;\n\tcase SHOW_TREE_FN_ERR:\n\t\tret = -1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tfree(cgroup_alloced);\n\n\treturn ret;\n}\n\nstatic int do_attach(int argc, char **argv)\n{\n\tenum bpf_attach_type attach_type;\n\tint cgroup_fd, prog_fd;\n\tint attach_flags = 0;\n\tint ret = -1;\n\tint i;\n\n\tif (argc < 4) {\n\t\tp_err(\"too few parameters for cgroup attach\");\n\t\tgoto exit;\n\t}\n\n\tcgroup_fd = open(argv[0], O_RDONLY);\n\tif (cgroup_fd < 0) {\n\t\tp_err(\"can't open cgroup %s\", argv[0]);\n\t\tgoto exit;\n\t}\n\n\tattach_type = parse_attach_type(argv[1]);\n\tif (attach_type == __MAX_BPF_ATTACH_TYPE) {\n\t\tp_err(\"invalid attach type\");\n\t\tgoto exit_cgroup;\n\t}\n\n\targc -= 2;\n\targv = &argv[2];\n\tprog_fd = prog_parse_fd(&argc, &argv);\n\tif (prog_fd < 0)\n\t\tgoto exit_cgroup;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tif (is_prefix(argv[i], \"multi\")) {\n\t\t\tattach_flags |= BPF_F_ALLOW_MULTI;\n\t\t} else if (is_prefix(argv[i], \"override\")) {\n\t\t\tattach_flags |= BPF_F_ALLOW_OVERRIDE;\n\t\t} else {\n\t\t\tp_err(\"unknown option: %s\", argv[i]);\n\t\t\tgoto exit_cgroup;\n\t\t}\n\t}\n\n\tif (bpf_prog_attach(prog_fd, cgroup_fd, attach_type, attach_flags)) {\n\t\tp_err(\"failed to attach program\");\n\t\tgoto exit_prog;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\tret = 0;\n\nexit_prog:\n\tclose(prog_fd);\nexit_cgroup:\n\tclose(cgroup_fd);\nexit:\n\treturn ret;\n}\n\nstatic int do_detach(int argc, char **argv)\n{\n\tenum bpf_attach_type attach_type;\n\tint prog_fd, cgroup_fd;\n\tint ret = -1;\n\n\tif (argc < 4) {\n\t\tp_err(\"too few parameters for cgroup detach\");\n\t\tgoto exit;\n\t}\n\n\tcgroup_fd = open(argv[0], O_RDONLY);\n\tif (cgroup_fd < 0) {\n\t\tp_err(\"can't open cgroup %s\", argv[0]);\n\t\tgoto exit;\n\t}\n\n\tattach_type = parse_attach_type(argv[1]);\n\tif (attach_type == __MAX_BPF_ATTACH_TYPE) {\n\t\tp_err(\"invalid attach type\");\n\t\tgoto exit_cgroup;\n\t}\n\n\targc -= 2;\n\targv = &argv[2];\n\tprog_fd = prog_parse_fd(&argc, &argv);\n\tif (prog_fd < 0)\n\t\tgoto exit_cgroup;\n\n\tif (bpf_prog_detach2(prog_fd, cgroup_fd, attach_type)) {\n\t\tp_err(\"failed to detach program\");\n\t\tgoto exit_prog;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\tret = 0;\n\nexit_prog:\n\tclose(prog_fd);\nexit_cgroup:\n\tclose(cgroup_fd);\nexit:\n\treturn ret;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list } CGROUP [**effective**]\\n\"\n\t\t\"       %1$s %2$s tree [CGROUP_ROOT] [**effective**]\\n\"\n\t\t\"       %1$s %2$s attach CGROUP ATTACH_TYPE PROG [ATTACH_FLAGS]\\n\"\n\t\t\"       %1$s %2$s detach CGROUP ATTACH_TYPE PROG\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\tHELP_SPEC_ATTACH_TYPES \"\\n\"\n\t\t\"       \" HELP_SPEC_ATTACH_FLAGS \"\\n\"\n\t\t\"       \" HELP_SPEC_PROGRAM \"\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-f|--bpffs} }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"tree\",       do_show_tree },\n\t{ \"attach\",\tdo_attach },\n\t{ \"detach\",\tdo_detach },\n\t{ \"help\",\tdo_help },\n\t{ 0 }\n};\n\nint do_cgroup(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}