{
  "module_name": "main.c",
  "hash_id": "faeba44730a2f8adfa1cd6ea6cd629d22d7ce388e3bc4e345a55b5db3780c081",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/main.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <linux/bpf.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/hashmap.h>\n#include <bpf/libbpf.h>\n\n#include \"main.h\"\n\n#define BATCH_LINE_LEN_MAX 65536\n#define BATCH_ARG_NB_MAX 4096\n\nconst char *bin_name;\nstatic int last_argc;\nstatic char **last_argv;\nstatic int (*last_do_help)(int argc, char **argv);\njson_writer_t *json_wtr;\nbool pretty_output;\nbool json_output;\nbool show_pinned;\nbool block_mount;\nbool verifier_logs;\nbool relaxed_maps;\nbool use_loader;\nstruct btf *base_btf;\nstruct hashmap *refs_table;\n\nstatic void __noreturn clean_and_exit(int i)\n{\n\tif (json_output)\n\t\tjsonw_destroy(&json_wtr);\n\n\texit(i);\n}\n\nvoid usage(void)\n{\n\tlast_do_help(last_argc - 1, last_argv + 1);\n\n\tclean_and_exit(-1);\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\\n\"\n\t\t\"       %s batch file FILE\\n\"\n\t\t\"       %s version\\n\"\n\t\t\"\\n\"\n\t\t\"       OBJECT := { prog | map | link | cgroup | perf | net | feature | btf | gen | struct_ops | iter }\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-V|--version} }\\n\"\n\t\t\"\",\n\t\tbin_name, bin_name, bin_name);\n\n\treturn 0;\n}\n\nstatic int do_batch(int argc, char **argv);\nstatic int do_version(int argc, char **argv);\n\nstatic const struct cmd commands[] = {\n\t{ \"help\",\tdo_help },\n\t{ \"batch\",\tdo_batch },\n\t{ \"prog\",\tdo_prog },\n\t{ \"map\",\tdo_map },\n\t{ \"link\",\tdo_link },\n\t{ \"cgroup\",\tdo_cgroup },\n\t{ \"perf\",\tdo_perf },\n\t{ \"net\",\tdo_net },\n\t{ \"feature\",\tdo_feature },\n\t{ \"btf\",\tdo_btf },\n\t{ \"gen\",\tdo_gen },\n\t{ \"struct_ops\",\tdo_struct_ops },\n\t{ \"iter\",\tdo_iter },\n\t{ \"version\",\tdo_version },\n\t{ 0 }\n};\n\n#ifndef BPFTOOL_VERSION\n \n#define BPFTOOL_MAJOR_VERSION (LIBBPF_MAJOR_VERSION + 6)\n#define BPFTOOL_MINOR_VERSION LIBBPF_MINOR_VERSION\n#define BPFTOOL_PATCH_VERSION 0\n#endif\n\nstatic void\nprint_feature(const char *feature, bool state, unsigned int *nb_features)\n{\n\tif (state) {\n\t\tprintf(\"%s %s\", *nb_features ? \",\" : \"\", feature);\n\t\t*nb_features = *nb_features + 1;\n\t}\n}\n\nstatic int do_version(int argc, char **argv)\n{\n#ifdef HAVE_LIBBFD_SUPPORT\n\tconst bool has_libbfd = true;\n#else\n\tconst bool has_libbfd = false;\n#endif\n#ifdef HAVE_LLVM_SUPPORT\n\tconst bool has_llvm = true;\n#else\n\tconst bool has_llvm = false;\n#endif\n#ifdef BPFTOOL_WITHOUT_SKELETONS\n\tconst bool has_skeletons = false;\n#else\n\tconst bool has_skeletons = true;\n#endif\n\tbool bootstrap = false;\n\tint i;\n\n\tfor (i = 0; commands[i].cmd; i++) {\n\t\tif (!strcmp(commands[i].cmd, \"prog\")) {\n\t\t\t \n\t\t\tbootstrap = !commands[i].func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\t \n\n\t\tjsonw_name(json_wtr, \"version\");\n#ifdef BPFTOOL_VERSION\n\t\tjsonw_printf(json_wtr, \"\\\"%s\\\"\", BPFTOOL_VERSION);\n#else\n\t\tjsonw_printf(json_wtr, \"\\\"%d.%d.%d\\\"\", BPFTOOL_MAJOR_VERSION,\n\t\t\t     BPFTOOL_MINOR_VERSION, BPFTOOL_PATCH_VERSION);\n#endif\n\t\tjsonw_name(json_wtr, \"libbpf_version\");\n\t\tjsonw_printf(json_wtr, \"\\\"%d.%d\\\"\",\n\t\t\t     libbpf_major_version(), libbpf_minor_version());\n\n\t\tjsonw_name(json_wtr, \"features\");\n\t\tjsonw_start_object(json_wtr);\t \n\t\tjsonw_bool_field(json_wtr, \"libbfd\", has_libbfd);\n\t\tjsonw_bool_field(json_wtr, \"llvm\", has_llvm);\n\t\tjsonw_bool_field(json_wtr, \"skeletons\", has_skeletons);\n\t\tjsonw_bool_field(json_wtr, \"bootstrap\", bootstrap);\n\t\tjsonw_end_object(json_wtr);\t \n\n\t\tjsonw_end_object(json_wtr);\t \n\t} else {\n\t\tunsigned int nb_features = 0;\n\n#ifdef BPFTOOL_VERSION\n\t\tprintf(\"%s v%s\\n\", bin_name, BPFTOOL_VERSION);\n#else\n\t\tprintf(\"%s v%d.%d.%d\\n\", bin_name, BPFTOOL_MAJOR_VERSION,\n\t\t       BPFTOOL_MINOR_VERSION, BPFTOOL_PATCH_VERSION);\n#endif\n\t\tprintf(\"using libbpf %s\\n\", libbpf_version_string());\n\t\tprintf(\"features:\");\n\t\tprint_feature(\"libbfd\", has_libbfd, &nb_features);\n\t\tprint_feature(\"llvm\", has_llvm, &nb_features);\n\t\tprint_feature(\"skeletons\", has_skeletons, &nb_features);\n\t\tprint_feature(\"bootstrap\", bootstrap, &nb_features);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\nint cmd_select(const struct cmd *cmds, int argc, char **argv,\n\t       int (*help)(int argc, char **argv))\n{\n\tunsigned int i;\n\n\tlast_argc = argc;\n\tlast_argv = argv;\n\tlast_do_help = help;\n\n\tif (argc < 1 && cmds[0].func)\n\t\treturn cmds[0].func(argc, argv);\n\n\tfor (i = 0; cmds[i].cmd; i++) {\n\t\tif (is_prefix(*argv, cmds[i].cmd)) {\n\t\t\tif (!cmds[i].func) {\n\t\t\t\tp_err(\"command '%s' is not supported in bootstrap mode\",\n\t\t\t\t      cmds[i].cmd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn cmds[i].func(argc - 1, argv + 1);\n\t\t}\n\t}\n\n\thelp(argc - 1, argv + 1);\n\n\treturn -1;\n}\n\nbool is_prefix(const char *pfx, const char *str)\n{\n\tif (!pfx)\n\t\treturn false;\n\tif (strlen(str) < strlen(pfx))\n\t\treturn false;\n\n\treturn !memcmp(str, pfx, strlen(pfx));\n}\n\n \nint detect_common_prefix(const char *arg, ...)\n{\n\tunsigned int count = 0;\n\tconst char *ref;\n\tchar msg[256];\n\tva_list ap;\n\n\tsnprintf(msg, sizeof(msg), \"ambiguous prefix: '%s' could be '\", arg);\n\tva_start(ap, arg);\n\twhile ((ref = va_arg(ap, const char *))) {\n\t\tif (!is_prefix(arg, ref))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tif (count > 1)\n\t\t\tstrncat(msg, \"' or '\", sizeof(msg) - strlen(msg) - 1);\n\t\tstrncat(msg, ref, sizeof(msg) - strlen(msg) - 1);\n\t}\n\tva_end(ap);\n\tstrncat(msg, \"'\", sizeof(msg) - strlen(msg) - 1);\n\n\tif (count >= 2) {\n\t\tp_err(\"%s\", msg);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid fprint_hex(FILE *f, void *arg, unsigned int n, const char *sep)\n{\n\tunsigned char *data = arg;\n\tunsigned int i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tconst char *pfx = \"\";\n\n\t\tif (!i)\n\t\t\t ;\n\t\telse if (!(i % 16))\n\t\t\tfprintf(f, \"\\n\");\n\t\telse if (!(i % 8))\n\t\t\tfprintf(f, \"  \");\n\t\telse\n\t\t\tpfx = sep;\n\n\t\tfprintf(f, \"%s%02hhx\", i ? pfx : \"\", data[i]);\n\t}\n}\n\n \nstatic int make_args(char *line, char *n_argv[], int maxargs, int cmd_nb)\n{\n\tstatic const char ws[] = \" \\t\\r\\n\";\n\tchar *cp = line;\n\tint n_argc = 0;\n\n\twhile (*cp) {\n\t\t \n\t\tcp += strspn(cp, ws);\n\n\t\tif (*cp == '\\0')\n\t\t\tbreak;\n\n\t\tif (n_argc >= (maxargs - 1)) {\n\t\t\tp_err(\"too many arguments to command %d\", cmd_nb);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (*cp == '\\'' || *cp == '\"') {\n\t\t\tchar quote = *cp++;\n\n\t\t\tn_argv[n_argc++] = cp;\n\t\t\t \n\t\t\tcp = strchr(cp, quote);\n\t\t\tif (!cp) {\n\t\t\t\tp_err(\"unterminated quoted string in command %d\",\n\t\t\t\t      cmd_nb);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tn_argv[n_argc++] = cp;\n\n\t\t\t \n\t\t\tcp += strcspn(cp, ws);\n\t\t\tif (*cp == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t*cp++ = 0;\n\t}\n\tn_argv[n_argc] = NULL;\n\n\treturn n_argc;\n}\n\nstatic int do_batch(int argc, char **argv)\n{\n\tchar buf[BATCH_LINE_LEN_MAX], contline[BATCH_LINE_LEN_MAX];\n\tchar *n_argv[BATCH_ARG_NB_MAX];\n\tunsigned int lines = 0;\n\tint n_argc;\n\tFILE *fp;\n\tchar *cp;\n\tint err = 0;\n\tint i;\n\n\tif (argc < 2) {\n\t\tp_err(\"too few parameters for batch\");\n\t\treturn -1;\n\t} else if (argc > 2) {\n\t\tp_err(\"too many parameters for batch\");\n\t\treturn -1;\n\t} else if (!is_prefix(*argv, \"file\")) {\n\t\tp_err(\"expected 'file', got: %s\", *argv);\n\t\treturn -1;\n\t}\n\tNEXT_ARG();\n\n\tif (!strcmp(*argv, \"-\"))\n\t\tfp = stdin;\n\telse\n\t\tfp = fopen(*argv, \"r\");\n\tif (!fp) {\n\t\tp_err(\"Can't open file (%s): %s\", *argv, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\tcp = strchr(buf, '#');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\n\t\tif (strlen(buf) == sizeof(buf) - 1) {\n\t\t\terrno = E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\twhile ((cp = strstr(buf, \"\\\\\\n\")) != NULL) {\n\t\t\tif (!fgets(contline, sizeof(contline), fp) ||\n\t\t\t    strlen(contline) == 0) {\n\t\t\t\tp_err(\"missing continuation line on command %d\",\n\t\t\t\t      lines);\n\t\t\t\terr = -1;\n\t\t\t\tgoto err_close;\n\t\t\t}\n\n\t\t\tcp = strchr(contline, '#');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\n\t\t\tif (strlen(buf) + strlen(contline) + 1 > sizeof(buf)) {\n\t\t\t\tp_err(\"command %d is too long\", lines);\n\t\t\t\terr = -1;\n\t\t\t\tgoto err_close;\n\t\t\t}\n\t\t\tbuf[strlen(buf) - 2] = '\\0';\n\t\t\tstrcat(buf, contline);\n\t\t}\n\n\t\tn_argc = make_args(buf, n_argv, BATCH_ARG_NB_MAX, lines);\n\t\tif (!n_argc)\n\t\t\tcontinue;\n\t\tif (n_argc < 0) {\n\t\t\terr = n_argc;\n\t\t\tgoto err_close;\n\t\t}\n\n\t\tif (json_output) {\n\t\t\tjsonw_start_object(json_wtr);\n\t\t\tjsonw_name(json_wtr, \"command\");\n\t\t\tjsonw_start_array(json_wtr);\n\t\t\tfor (i = 0; i < n_argc; i++)\n\t\t\t\tjsonw_string(json_wtr, n_argv[i]);\n\t\t\tjsonw_end_array(json_wtr);\n\t\t\tjsonw_name(json_wtr, \"output\");\n\t\t}\n\n\t\terr = cmd_select(commands, n_argc, n_argv, do_help);\n\n\t\tif (json_output)\n\t\t\tjsonw_end_object(json_wtr);\n\n\t\tif (err)\n\t\t\tgoto err_close;\n\n\t\tlines++;\n\t}\n\n\tif (errno && errno != ENOENT) {\n\t\tp_err(\"reading batch file failed: %s\", strerror(errno));\n\t\terr = -1;\n\t} else {\n\t\tif (!json_output)\n\t\t\tprintf(\"processed %d commands\\n\", lines);\n\t}\nerr_close:\n\tif (fp != stdin)\n\t\tfclose(fp);\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\treturn err;\n}\n\nint main(int argc, char **argv)\n{\n\tstatic const struct option options[] = {\n\t\t{ \"json\",\tno_argument,\tNULL,\t'j' },\n\t\t{ \"help\",\tno_argument,\tNULL,\t'h' },\n\t\t{ \"pretty\",\tno_argument,\tNULL,\t'p' },\n\t\t{ \"version\",\tno_argument,\tNULL,\t'V' },\n\t\t{ \"bpffs\",\tno_argument,\tNULL,\t'f' },\n\t\t{ \"mapcompat\",\tno_argument,\tNULL,\t'm' },\n\t\t{ \"nomount\",\tno_argument,\tNULL,\t'n' },\n\t\t{ \"debug\",\tno_argument,\tNULL,\t'd' },\n\t\t{ \"use-loader\",\tno_argument,\tNULL,\t'L' },\n\t\t{ \"base-btf\",\trequired_argument, NULL, 'B' },\n\t\t{ 0 }\n\t};\n\tbool version_requested = false;\n\tint opt, ret;\n\n\tsetlinebuf(stdout);\n\n#ifdef USE_LIBCAP\n\t \n\terrno = 0;\n#endif\n\n\tlast_do_help = do_help;\n\tpretty_output = false;\n\tjson_output = false;\n\tshow_pinned = false;\n\tblock_mount = false;\n\tbin_name = \"bpftool\";\n\n\topterr = 0;\n\twhile ((opt = getopt_long(argc, argv, \"VhpjfLmndB:l\",\n\t\t\t\t  options, NULL)) >= 0) {\n\t\tswitch (opt) {\n\t\tcase 'V':\n\t\t\tversion_requested = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\treturn do_help(argc, argv);\n\t\tcase 'p':\n\t\t\tpretty_output = true;\n\t\t\t \n\t\tcase 'j':\n\t\t\tif (!json_output) {\n\t\t\t\tjson_wtr = jsonw_new(stdout);\n\t\t\t\tif (!json_wtr) {\n\t\t\t\t\tp_err(\"failed to create JSON writer\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjson_output = true;\n\t\t\t}\n\t\t\tjsonw_pretty(json_wtr, pretty_output);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tshow_pinned = true;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\trelaxed_maps = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tblock_mount = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tlibbpf_set_print(print_all_levels);\n\t\t\tverifier_logs = true;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tbase_btf = btf__parse(optarg, NULL);\n\t\t\tif (!base_btf) {\n\t\t\t\tp_err(\"failed to parse base BTF at '%s': %d\\n\",\n\t\t\t\t      optarg, -errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tuse_loader = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp_err(\"unrecognized option '%s'\", argv[optind - 1]);\n\t\t\tif (json_output)\n\t\t\t\tclean_and_exit(-1);\n\t\t\telse\n\t\t\t\tusage();\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\tif (argc < 0)\n\t\tusage();\n\n\tif (version_requested)\n\t\treturn do_version(argc, argv);\n\n\tret = cmd_select(commands, argc, argv, do_help);\n\n\tif (json_output)\n\t\tjsonw_destroy(&json_wtr);\n\n\tbtf__free(base_btf);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}