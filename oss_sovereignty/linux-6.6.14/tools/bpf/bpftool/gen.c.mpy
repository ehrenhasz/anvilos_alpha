{
  "module_name": "gen.c",
  "hash_id": "2d719c29080cb568ddbf0f504f33c3d8b29cc0644b749f2049152881c4d05406",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/gen.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <bpf/libbpf_internal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <bpf/btf.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\n#define MAX_OBJ_NAME_LEN 64\n\nstatic void sanitize_identifier(char *name)\n{\n\tint i;\n\n\tfor (i = 0; name[i]; i++)\n\t\tif (!isalnum(name[i]) && name[i] != '_')\n\t\t\tname[i] = '_';\n}\n\nstatic bool str_has_prefix(const char *str, const char *prefix)\n{\n\treturn strncmp(str, prefix, strlen(prefix)) == 0;\n}\n\nstatic bool str_has_suffix(const char *str, const char *suffix)\n{\n\tsize_t i, n1 = strlen(str), n2 = strlen(suffix);\n\n\tif (n1 < n2)\n\t\treturn false;\n\n\tfor (i = 0; i < n2; i++) {\n\t\tif (str[n1 - i - 1] != suffix[n2 - i - 1])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void get_obj_name(char *name, const char *file)\n{\n\t \n\tstrncpy(name, basename(file), MAX_OBJ_NAME_LEN - 1);\n\tname[MAX_OBJ_NAME_LEN - 1] = '\\0';\n\tif (str_has_suffix(name, \".o\"))\n\t\tname[strlen(name) - 2] = '\\0';\n\tsanitize_identifier(name);\n}\n\nstatic void get_header_guard(char *guard, const char *obj_name, const char *suffix)\n{\n\tint i;\n\n\tsprintf(guard, \"__%s_%s__\", obj_name, suffix);\n\tfor (i = 0; guard[i]; i++)\n\t\tguard[i] = toupper(guard[i]);\n}\n\nstatic bool get_map_ident(const struct bpf_map *map, char *buf, size_t buf_sz)\n{\n\tstatic const char *sfxs[] = { \".data\", \".rodata\", \".bss\", \".kconfig\" };\n\tconst char *name = bpf_map__name(map);\n\tint i, n;\n\n\tif (!bpf_map__is_internal(map)) {\n\t\tsnprintf(buf, buf_sz, \"%s\", name);\n\t\treturn true;\n\t}\n\n\tfor  (i = 0, n = ARRAY_SIZE(sfxs); i < n; i++) {\n\t\tconst char *sfx = sfxs[i], *p;\n\n\t\tp = strstr(name, sfx);\n\t\tif (p) {\n\t\t\tsnprintf(buf, buf_sz, \"%s\", p + 1);\n\t\t\tsanitize_identifier(buf);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool get_datasec_ident(const char *sec_name, char *buf, size_t buf_sz)\n{\n\tstatic const char *pfxs[] = { \".data\", \".rodata\", \".bss\", \".kconfig\" };\n\tint i, n;\n\n\tfor  (i = 0, n = ARRAY_SIZE(pfxs); i < n; i++) {\n\t\tconst char *pfx = pfxs[i];\n\n\t\tif (str_has_prefix(sec_name, pfx)) {\n\t\t\tsnprintf(buf, buf_sz, \"%s\", sec_name + 1);\n\t\t\tsanitize_identifier(buf);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void codegen_btf_dump_printf(void *ctx, const char *fmt, va_list args)\n{\n\tvprintf(fmt, args);\n}\n\nstatic int codegen_datasec_def(struct bpf_object *obj,\n\t\t\t       struct btf *btf,\n\t\t\t       struct btf_dump *d,\n\t\t\t       const struct btf_type *sec,\n\t\t\t       const char *obj_name)\n{\n\tconst char *sec_name = btf__name_by_offset(btf, sec->name_off);\n\tconst struct btf_var_secinfo *sec_var = btf_var_secinfos(sec);\n\tint i, err, off = 0, pad_cnt = 0, vlen = btf_vlen(sec);\n\tchar var_ident[256], sec_ident[256];\n\tbool strip_mods = false;\n\n\tif (!get_datasec_ident(sec_name, sec_ident, sizeof(sec_ident)))\n\t\treturn 0;\n\n\tif (strcmp(sec_name, \".kconfig\") != 0)\n\t\tstrip_mods = true;\n\n\tprintf(\"\tstruct %s__%s {\\n\", obj_name, sec_ident);\n\tfor (i = 0; i < vlen; i++, sec_var++) {\n\t\tconst struct btf_type *var = btf__type_by_id(btf, sec_var->type);\n\t\tconst char *var_name = btf__name_by_offset(btf, var->name_off);\n\t\tDECLARE_LIBBPF_OPTS(btf_dump_emit_type_decl_opts, opts,\n\t\t\t.field_name = var_ident,\n\t\t\t.indent_level = 2,\n\t\t\t.strip_mods = strip_mods,\n\t\t);\n\t\tint need_off = sec_var->offset, align_off, align;\n\t\t__u32 var_type_id = var->type;\n\n\t\t \n\t\tif (btf_var(var)->linkage == BTF_VAR_STATIC)\n\t\t\tcontinue;\n\n\t\tif (off > need_off) {\n\t\t\tp_err(\"Something is wrong for %s's variable #%d: need offset %d, already at %d.\\n\",\n\t\t\t      sec_name, i, need_off, off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\talign = btf__align_of(btf, var->type);\n\t\tif (align <= 0) {\n\t\t\tp_err(\"Failed to determine alignment of variable '%s': %d\",\n\t\t\t      var_name, align);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (align > 4)\n\t\t\talign = 4;\n\n\t\talign_off = (off + align - 1) / align * align;\n\t\tif (align_off != need_off) {\n\t\t\tprintf(\"\\t\\tchar __pad%d[%d];\\n\",\n\t\t\t       pad_cnt, need_off - off);\n\t\t\tpad_cnt++;\n\t\t}\n\n\t\t \n\t\tvar_ident[0] = '\\0';\n\t\tstrncat(var_ident, var_name, sizeof(var_ident) - 1);\n\t\tsanitize_identifier(var_ident);\n\n\t\tprintf(\"\\t\\t\");\n\t\terr = btf_dump__emit_type_decl(d, var_type_id, &opts);\n\t\tif (err)\n\t\t\treturn err;\n\t\tprintf(\";\\n\");\n\n\t\toff = sec_var->offset + sec_var->size;\n\t}\n\tprintf(\"\t} *%s;\\n\", sec_ident);\n\treturn 0;\n}\n\nstatic const struct btf_type *find_type_for_map(struct btf *btf, const char *map_ident)\n{\n\tint n = btf__type_cnt(btf), i;\n\tchar sec_ident[256];\n\n\tfor (i = 1; i < n; i++) {\n\t\tconst struct btf_type *t = btf__type_by_id(btf, i);\n\t\tconst char *name;\n\n\t\tif (!btf_is_datasec(t))\n\t\t\tcontinue;\n\n\t\tname = btf__str_by_offset(btf, t->name_off);\n\t\tif (!get_datasec_ident(name, sec_ident, sizeof(sec_ident)))\n\t\t\tcontinue;\n\n\t\tif (strcmp(sec_ident, map_ident) == 0)\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}\n\nstatic bool is_internal_mmapable_map(const struct bpf_map *map, char *buf, size_t sz)\n{\n\tif (!bpf_map__is_internal(map) || !(bpf_map__map_flags(map) & BPF_F_MMAPABLE))\n\t\treturn false;\n\n\tif (!get_map_ident(map, buf, sz))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int codegen_datasecs(struct bpf_object *obj, const char *obj_name)\n{\n\tstruct btf *btf = bpf_object__btf(obj);\n\tstruct btf_dump *d;\n\tstruct bpf_map *map;\n\tconst struct btf_type *sec;\n\tchar map_ident[256];\n\tint err = 0;\n\n\td = btf_dump__new(btf, codegen_btf_dump_printf, NULL, NULL);\n\tif (!d)\n\t\treturn -errno;\n\n\tbpf_object__for_each_map(map, obj) {\n\t\t \n\t\tif (!is_internal_mmapable_map(map, map_ident, sizeof(map_ident)))\n\t\t\tcontinue;\n\n\t\tsec = find_type_for_map(btf, map_ident);\n\n\t\t \n\t\tif (!sec) {\n\t\t\tprintf(\"\tstruct %s__%s {\\n\", obj_name, map_ident);\n\t\t\tprintf(\"\t} *%s;\\n\", map_ident);\n\t\t} else {\n\t\t\terr = codegen_datasec_def(obj, btf, d, sec, obj_name);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\nout:\n\tbtf_dump__free(d);\n\treturn err;\n}\n\nstatic bool btf_is_ptr_to_func_proto(const struct btf *btf,\n\t\t\t\t     const struct btf_type *v)\n{\n\treturn btf_is_ptr(v) && btf_is_func_proto(btf__type_by_id(btf, v->type));\n}\n\nstatic int codegen_subskel_datasecs(struct bpf_object *obj, const char *obj_name)\n{\n\tstruct btf *btf = bpf_object__btf(obj);\n\tstruct btf_dump *d;\n\tstruct bpf_map *map;\n\tconst struct btf_type *sec, *var;\n\tconst struct btf_var_secinfo *sec_var;\n\tint i, err = 0, vlen;\n\tchar map_ident[256], sec_ident[256];\n\tbool strip_mods = false, needs_typeof = false;\n\tconst char *sec_name, *var_name;\n\t__u32 var_type_id;\n\n\td = btf_dump__new(btf, codegen_btf_dump_printf, NULL, NULL);\n\tif (!d)\n\t\treturn -errno;\n\n\tbpf_object__for_each_map(map, obj) {\n\t\t \n\t\tif (!is_internal_mmapable_map(map, map_ident, sizeof(map_ident)))\n\t\t\tcontinue;\n\n\t\tsec = find_type_for_map(btf, map_ident);\n\t\tif (!sec)\n\t\t\tcontinue;\n\n\t\tsec_name = btf__name_by_offset(btf, sec->name_off);\n\t\tif (!get_datasec_ident(sec_name, sec_ident, sizeof(sec_ident)))\n\t\t\tcontinue;\n\n\t\tstrip_mods = strcmp(sec_name, \".kconfig\") != 0;\n\t\tprintf(\"\tstruct %s__%s {\\n\", obj_name, sec_ident);\n\n\t\tsec_var = btf_var_secinfos(sec);\n\t\tvlen = btf_vlen(sec);\n\t\tfor (i = 0; i < vlen; i++, sec_var++) {\n\t\t\tDECLARE_LIBBPF_OPTS(btf_dump_emit_type_decl_opts, opts,\n\t\t\t\t.indent_level = 2,\n\t\t\t\t.strip_mods = strip_mods,\n\t\t\t\t \n\t\t\t\t.field_name = \"\",\n\t\t\t);\n\n\t\t\tvar = btf__type_by_id(btf, sec_var->type);\n\t\t\tvar_name = btf__name_by_offset(btf, var->name_off);\n\t\t\tvar_type_id = var->type;\n\n\t\t\t \n\t\t\tif (btf_var(var)->linkage == BTF_VAR_STATIC)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tvar = skip_mods_and_typedefs(btf, var->type, NULL);\n\n\t\t\tprintf(\"\\t\\t\");\n\t\t\t \n\t\t\tneeds_typeof = btf_is_array(var) || btf_is_ptr_to_func_proto(btf, var);\n\t\t\tif (needs_typeof)\n\t\t\t\tprintf(\"typeof(\");\n\n\t\t\terr = btf_dump__emit_type_decl(d, var_type_id, &opts);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (needs_typeof)\n\t\t\t\tprintf(\")\");\n\n\t\t\tprintf(\" *%s;\\n\", var_name);\n\t\t}\n\t\tprintf(\"\t} %s;\\n\", sec_ident);\n\t}\n\nout:\n\tbtf_dump__free(d);\n\treturn err;\n}\n\nstatic void codegen(const char *template, ...)\n{\n\tconst char *src, *end;\n\tint skip_tabs = 0, n;\n\tchar *s, *dst;\n\tva_list args;\n\tchar c;\n\n\tn = strlen(template);\n\ts = malloc(n + 1);\n\tif (!s)\n\t\texit(-1);\n\tsrc = template;\n\tdst = s;\n\n\t \n\twhile ((c = *src++)) {\n\t\tif (c == '\\t') {\n\t\t\tskip_tabs++;\n\t\t} else if (c == '\\n') {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tp_err(\"unrecognized character at pos %td in template '%s': '%c'\",\n\t\t\t      src - template - 1, template, c);\n\t\t\tfree(s);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\twhile (*src) {\n\t\t \n\t\tfor (n = skip_tabs; n > 0; n--, src++) {\n\t\t\tif (*src != '\\t') {\n\t\t\t\tp_err(\"not enough tabs at pos %td in template '%s'\",\n\t\t\t\t      src - template - 1, template);\n\t\t\t\tfree(s);\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t}\n\t\t \n\t\tend = strchrnul(src, '\\n');\n\t\tfor (n = end - src; n > 0 && isspace(src[n - 1]); n--)\n\t\t\t;\n\t\tmemcpy(dst, src, n);\n\t\tdst += n;\n\t\tif (*end)\n\t\t\t*dst++ = '\\n';\n\t\tsrc = *end ? end + 1 : end;\n\t}\n\t*dst++ = '\\0';\n\n\t \n\tva_start(args, template);\n\tn = vprintf(s, args);\n\tva_end(args);\n\n\tfree(s);\n}\n\nstatic void print_hex(const char *data, int data_sz)\n{\n\tint i, len;\n\n\tfor (i = 0, len = 0; i < data_sz; i++) {\n\t\tint w = data[i] ? 4 : 2;\n\n\t\tlen += w;\n\t\tif (len > 78) {\n\t\t\tprintf(\"\\\\\\n\");\n\t\t\tlen = w;\n\t\t}\n\t\tif (!data[i])\n\t\t\tprintf(\"\\\\0\");\n\t\telse\n\t\t\tprintf(\"\\\\x%02x\", (unsigned char)data[i]);\n\t}\n}\n\nstatic size_t bpf_map_mmap_sz(const struct bpf_map *map)\n{\n\tlong page_sz = sysconf(_SC_PAGE_SIZE);\n\tsize_t map_sz;\n\n\tmap_sz = (size_t)roundup(bpf_map__value_size(map), 8) * bpf_map__max_entries(map);\n\tmap_sz = roundup(map_sz, page_sz);\n\treturn map_sz;\n}\n\n \nstatic void codegen_asserts(struct bpf_object *obj, const char *obj_name)\n{\n\tstruct btf *btf = bpf_object__btf(obj);\n\tstruct bpf_map *map;\n\tstruct btf_var_secinfo *sec_var;\n\tint i, vlen;\n\tconst struct btf_type *sec;\n\tchar map_ident[256], var_ident[256];\n\n\tif (!btf)\n\t\treturn;\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t__attribute__((unused)) static void\t\t\t    \\n\\\n\t\t%1$s__assert(struct %1$s *s __attribute__((unused)))\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\t#define _Static_assert static_assert\t\t\t    \\n\\\n\t\t#endif\t\t\t\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!is_internal_mmapable_map(map, map_ident, sizeof(map_ident)))\n\t\t\tcontinue;\n\n\t\tsec = find_type_for_map(btf, map_ident);\n\t\tif (!sec) {\n\t\t\t/* best effort, couldn't find the type for this map */\n\t\t\tcontinue;\n\t\t}\n\n\t\tsec_var = btf_var_secinfos(sec);\n\t\tvlen =  btf_vlen(sec);\n\n\t\tfor (i = 0; i < vlen; i++, sec_var++) {\n\t\t\tconst struct btf_type *var = btf__type_by_id(btf, sec_var->type);\n\t\t\tconst char *var_name = btf__name_by_offset(btf, var->name_off);\n\t\t\tlong var_size;\n\n\t\t\t/* static variables are not exposed through BPF skeleton */\n\t\t\tif (btf_var(var)->linkage == BTF_VAR_STATIC)\n\t\t\t\tcontinue;\n\n\t\t\tvar_size = btf__resolve_size(btf, var->type);\n\t\t\tif (var_size < 0)\n\t\t\t\tcontinue;\n\n\t\t\tvar_ident[0] = '\\0';\n\t\t\tstrncat(var_ident, var_name, sizeof(var_ident) - 1);\n\t\t\tsanitize_identifier(var_ident);\n\n\t\t\tprintf(\"\\t_Static_assert(sizeof(s->%s->%s) == %ld, \\\"unexpected size of '%s'\\\");\\n\",\n\t\t\t       map_ident, var_ident, var_size, var_ident);\n\t\t}\n\t}\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\t#undef _Static_assert\t\t\t\t\t    \\n\\\n\t\t#endif\t\t\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\");\n}\n\nstatic void codegen_attach_detach(struct bpf_object *obj, const char *obj_name)\n{\n\tstruct bpf_program *prog;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tconst char *tp_name;\n\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\\n\\\n\t\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t\t%1$s__%2$s__attach(struct %1$s *skel)\t\t\t    \\n\\\n\t\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\t\tint prog_fd = skel->progs.%2$s.prog_fd;\t\t    \\n\\\n\t\t\t\", obj_name, bpf_program__name(prog));\n\n\t\tswitch (bpf_program__type(prog)) {\n\t\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\t\t\ttp_name = strchr(bpf_program__section_name(prog), '/') + 1;\n\t\t\tprintf(\"\\tint fd = skel_raw_tracepoint_open(\\\"%s\\\", prog_fd);\\n\", tp_name);\n\t\t\tbreak;\n\t\tcase BPF_PROG_TYPE_TRACING:\n\t\tcase BPF_PROG_TYPE_LSM:\n\t\t\tif (bpf_program__expected_attach_type(prog) == BPF_TRACE_ITER)\n\t\t\t\tprintf(\"\\tint fd = skel_link_create(prog_fd, 0, BPF_TRACE_ITER);\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"\\tint fd = skel_raw_tracepoint_open(NULL, prog_fd);\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"\\tint fd = ((void)prog_fd, 0); /* auto-attach not supported */\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\t\tif (fd > 0)\t\t\t\t\t    \\n\\\n\t\t\t\t\tskel->links.%1$s_fd = fd;\t\t    \\n\\\n\t\t\t\treturn fd;\t\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\", bpf_program__name(prog));\n\t}\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__attach(struct %1$s *skel)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tint ret = 0;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\tret = ret < 0 ? ret : %1$s__%2$s__attach(skel);   \\n\\\n\t\t\t\", obj_name, bpf_program__name(prog));\n\t}\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\treturn ret < 0 ? ret : 0;\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline void\t\t\t\t\t    \\n\\\n\t\t%1$s__detach(struct %1$s *skel)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\tskel_closenz(skel->links.%1$s_fd);\t    \\n\\\n\t\t\t\", bpf_program__name(prog));\n\t}\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\");\n}\n\nstatic void codegen_destroy(struct bpf_object *obj, const char *obj_name)\n{\n\tstruct bpf_program *prog;\n\tstruct bpf_map *map;\n\tchar ident[256];\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\tstatic void\t\t\t\t\t\t    \\n\\\n\t\t%1$s__destroy(struct %1$s *skel)\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tif (!skel)\t\t\t\t\t    \\n\\\n\t\t\t\treturn;\t\t\t\t\t    \\n\\\n\t\t\t%1$s__detach(skel);\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name);\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\tskel_closenz(skel->progs.%1$s.prog_fd);\t    \\n\\\n\t\t\t\", bpf_program__name(prog));\n\t}\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!get_map_ident(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\t\tif (bpf_map__is_internal(map) &&\n\t\t    (bpf_map__map_flags(map) & BPF_F_MMAPABLE))\n\t\t\tprintf(\"\\tskel_free_map_data(skel->%1$s, skel->maps.%1$s.initial_value, %2$zd);\\n\",\n\t\t\t       ident, bpf_map_mmap_sz(map));\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\tskel_closenz(skel->maps.%1$s.map_fd);\t    \\n\\\n\t\t\t\", ident);\n\t}\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\tskel_free(skel);\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name);\n}\n\nstatic int gen_trace(struct bpf_object *obj, const char *obj_name, const char *header_guard)\n{\n\tDECLARE_LIBBPF_OPTS(gen_loader_opts, opts);\n\tstruct bpf_map *map;\n\tchar ident[256];\n\tint err = 0;\n\n\terr = bpf_object__gen_loader(obj, &opts);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_object__load(obj);\n\tif (err) {\n\t\tp_err(\"failed to load object file\");\n\t\tgoto out;\n\t}\n\t/* If there was no error during load then gen_loader_opts\n\t * are populated with the loader program.\n\t */\n\n\t/* finish generating 'struct skel' */\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t};\t\t\t\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\n\n\tcodegen_attach_detach(obj, obj_name);\n\n\tcodegen_destroy(obj, obj_name);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open(void)\t\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct %1$s *skel;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tskel = skel_alloc(sizeof(*skel));\t\t    \\n\\\n\t\t\tif (!skel)\t\t\t\t\t    \\n\\\n\t\t\t\tgoto cleanup;\t\t\t\t    \\n\\\n\t\t\tskel->ctx.sz = (void *)&skel->links - (void *)skel; \\n\\\n\t\t\",\n\t\tobj_name, opts.data_sz);\n\tbpf_object__for_each_map(map, obj) {\n\t\tconst void *mmap_data = NULL;\n\t\tsize_t mmap_size = 0;\n\n\t\tif (!is_internal_mmapable_map(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\tcodegen(\"\\\n\t\t\\n\\\n\t\t\tskel->%1$s = skel_prep_map_data((void *)\\\"\\\\\t    \\n\\\n\t\t\", ident);\n\t\tmmap_data = bpf_map__initial_value(map, &mmap_size);\n\t\tprint_hex(mmap_data, mmap_size);\n\t\tcodegen(\"\\\n\t\t\\n\\\n\t\t\\\", %1$zd, %2$zd);\t\t\t\t\t    \\n\\\n\t\t\tif (!skel->%3$s)\t\t\t\t    \\n\\\n\t\t\t\tgoto cleanup;\t\t\t\t    \\n\\\n\t\t\tskel->maps.%3$s.initial_value = (__u64) (long) skel->%3$s;\\n\\\n\t\t\", bpf_map_mmap_sz(map), mmap_size, ident);\n\t}\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\treturn skel;\t\t\t\t\t    \\n\\\n\t\tcleanup:\t\t\t\t\t\t    \\n\\\n\t\t\t%1$s__destroy(skel);\t\t\t\t    \\n\\\n\t\t\treturn NULL;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__load(struct %1$s *skel)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct bpf_load_and_run_opts opts = {};\t\t    \\n\\\n\t\t\tint err;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\topts.ctx = (struct bpf_loader_ctx *)skel;\t    \\n\\\n\t\t\topts.data_sz = %2$d;\t\t\t\t    \\n\\\n\t\t\topts.data = (void *)\\\"\\\\\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name, opts.data_sz);\n\tprint_hex(opts.data, opts.data_sz);\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\\\";\t\t\t\t\t\t\t    \\n\\\n\t\t\");\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\topts.insns_sz = %d;\t\t\t\t    \\n\\\n\t\t\topts.insns = (void *)\\\"\\\\\t\t\t    \\n\\\n\t\t\",\n\t\topts.insns_sz);\n\tprint_hex(opts.insns, opts.insns_sz);\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\\\";\t\t\t\t\t\t\t    \\n\\\n\t\t\terr = bpf_load_and_run(&opts);\t\t\t    \\n\\\n\t\t\tif (err < 0)\t\t\t\t\t    \\n\\\n\t\t\t\treturn err;\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\tbpf_object__for_each_map(map, obj) {\n\t\tconst char *mmap_flags;\n\n\t\tif (!is_internal_mmapable_map(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\tif (bpf_map__map_flags(map) & BPF_F_RDONLY_PROG)\n\t\t\tmmap_flags = \"PROT_READ\";\n\t\telse\n\t\t\tmmap_flags = \"PROT_READ | PROT_WRITE\";\n\n\t\tcodegen(\"\\\n\t\t\\n\\\n\t\t\tskel->%1$s = skel_finalize_map_data(&skel->maps.%1$s.initial_value,  \\n\\\n\t\t\t\t\t\t\t%2$zd, %3$s, skel->maps.%1$s.map_fd);\\n\\\n\t\t\tif (!skel->%1$s)\t\t\t\t    \\n\\\n\t\t\t\treturn -ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\",\n\t\t       ident, bpf_map_mmap_sz(map), mmap_flags);\n\t}\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\treturn 0;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open_and_load(void)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct %1$s *skel;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tskel = %1$s__open();\t\t\t\t    \\n\\\n\t\t\tif (!skel)\t\t\t\t\t    \\n\\\n\t\t\t\treturn NULL;\t\t\t\t    \\n\\\n\t\t\tif (%1$s__load(skel)) {\t\t\t\t    \\n\\\n\t\t\t\t%1$s__destroy(skel);\t\t\t    \\n\\\n\t\t\t\treturn NULL;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\treturn skel;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\", obj_name);\n\n\tcodegen_asserts(obj, obj_name);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#endif  \t\t\t\t\t\t    \\n\\\n\t\t\",\n\t\theader_guard);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic void\ncodegen_maps_skeleton(struct bpf_object *obj, size_t map_cnt, bool mmaped)\n{\n\tstruct bpf_map *map;\n\tchar ident[256];\n\tsize_t i;\n\n\tif (!map_cnt)\n\t\treturn;\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t \t\t\t\t    \\n\\\n\t\t\ts->map_cnt = %zu;\t\t\t    \\n\\\n\t\t\ts->map_skel_sz = sizeof(*s->maps);\t    \\n\\\n\t\t\ts->maps = (struct bpf_map_skeleton *)calloc(s->map_cnt, s->map_skel_sz);\\n\\\n\t\t\tif (!s->maps) {\t\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tmap_cnt\n\t);\n\ti = 0;\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!get_map_ident(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t\ts->maps[%zu].name = \\\"%s\\\";\t    \\n\\\n\t\t\t\ts->maps[%zu].map = &obj->maps.%s;   \\n\\\n\t\t\t\",\n\t\t\ti, bpf_map__name(map), i, ident);\n\t\t/* memory-mapped internal maps */\n\t\tif (mmaped && is_internal_mmapable_map(map, ident, sizeof(ident))) {\n\t\t\tprintf(\"\\ts->maps[%zu].mmaped = (void **)&obj->%s;\\n\",\n\t\t\t\ti, ident);\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic void\ncodegen_progs_skeleton(struct bpf_object *obj, size_t prog_cnt, bool populate_links)\n{\n\tstruct bpf_program *prog;\n\tint i;\n\n\tif (!prog_cnt)\n\t\treturn;\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t \t\t\t\t    \\n\\\n\t\t\ts->prog_cnt = %zu;\t\t\t    \\n\\\n\t\t\ts->prog_skel_sz = sizeof(*s->progs);\t    \\n\\\n\t\t\ts->progs = (struct bpf_prog_skeleton *)calloc(s->prog_cnt, s->prog_skel_sz);\\n\\\n\t\t\tif (!s->progs) {\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tprog_cnt\n\t);\n\ti = 0;\n\tbpf_object__for_each_program(prog, obj) {\n\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t\ts->progs[%1$zu].name = \\\"%2$s\\\";    \\n\\\n\t\t\t\ts->progs[%1$zu].prog = &obj->progs.%2$s;\\n\\\n\t\t\t\",\n\t\t\ti, bpf_program__name(prog));\n\n\t\tif (populate_links) {\n\t\t\tcodegen(\"\\\n\t\t\t\t\\n\\\n\t\t\t\t\ts->progs[%1$zu].link = &obj->links.%2$s;\\n\\\n\t\t\t\t\",\n\t\t\t\ti, bpf_program__name(prog));\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic int do_skeleton(int argc, char **argv)\n{\n\tchar header_guard[MAX_OBJ_NAME_LEN + sizeof(\"__SKEL_H__\")];\n\tsize_t map_cnt = 0, prog_cnt = 0, file_sz, mmap_sz;\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts);\n\tchar obj_name[MAX_OBJ_NAME_LEN] = \"\", *obj_data;\n\tstruct bpf_object *obj = NULL;\n\tconst char *file;\n\tchar ident[256];\n\tstruct bpf_program *prog;\n\tint fd, err = -1;\n\tstruct bpf_map *map;\n\tstruct btf *btf;\n\tstruct stat st;\n\n\tif (!REQ_ARGS(1)) {\n\t\tusage();\n\t\treturn -1;\n\t}\n\tfile = GET_ARG();\n\n\twhile (argc) {\n\t\tif (!REQ_ARGS(2))\n\t\t\treturn -1;\n\n\t\tif (is_prefix(*argv, \"name\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (obj_name[0] != '\\0') {\n\t\t\t\tp_err(\"object name already specified\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstrncpy(obj_name, *argv, MAX_OBJ_NAME_LEN - 1);\n\t\t\tobj_name[MAX_OBJ_NAME_LEN - 1] = '\\0';\n\t\t} else {\n\t\t\tp_err(\"unknown arg %s\", *argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\tNEXT_ARG();\n\t}\n\n\tif (argc) {\n\t\tp_err(\"extra unknown arguments\");\n\t\treturn -1;\n\t}\n\n\tif (stat(file, &st)) {\n\t\tp_err(\"failed to stat() %s: %s\", file, strerror(errno));\n\t\treturn -1;\n\t}\n\tfile_sz = st.st_size;\n\tmmap_sz = roundup(file_sz, sysconf(_SC_PAGE_SIZE));\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tp_err(\"failed to open() %s: %s\", file, strerror(errno));\n\t\treturn -1;\n\t}\n\tobj_data = mmap(NULL, mmap_sz, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (obj_data == MAP_FAILED) {\n\t\tobj_data = NULL;\n\t\tp_err(\"failed to mmap() %s: %s\", file, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (obj_name[0] == '\\0')\n\t\tget_obj_name(obj_name, file);\n\topts.object_name = obj_name;\n\tif (verifier_logs)\n\t\t/* log_level1 + log_level2 + stats, but not stable UAPI */\n\t\topts.kernel_log_level = 1 + 2 + 4;\n\tobj = bpf_object__open_mem(obj_data, file_sz, &opts);\n\tif (!obj) {\n\t\tchar err_buf[256];\n\n\t\terr = -errno;\n\t\tlibbpf_strerror(err, err_buf, sizeof(err_buf));\n\t\tp_err(\"failed to open BPF object file: %s\", err_buf);\n\t\tgoto out;\n\t}\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!get_map_ident(map, ident, sizeof(ident))) {\n\t\t\tp_err(\"ignoring unrecognized internal map '%s'...\",\n\t\t\t      bpf_map__name(map));\n\t\t\tcontinue;\n\t\t}\n\t\tmap_cnt++;\n\t}\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprog_cnt++;\n\t}\n\n\tget_header_guard(header_guard, obj_name, \"SKEL_H\");\n\tif (use_loader) {\n\t\tcodegen(\"\\\n\t\t\\n\\\n\t\t    \\n\\\n\t\t \t\t    \\n\\\n\t\t#ifndef %2$s\t\t\t\t\t\t    \\n\\\n\t\t#define %2$s\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#include <bpf/skel_internal.h>\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstruct %1$s {\t\t\t\t\t\t    \\n\\\n\t\t\tstruct bpf_loader_ctx ctx;\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name, header_guard\n\t\t);\n\t} else {\n\t\tcodegen(\"\\\n\t\t\\n\\\n\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t \t\t    \\n\\\n\t\t#ifndef %2$s\t\t\t\t\t\t    \\n\\\n\t\t#define %2$s\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#include <errno.h>\t\t\t\t\t    \\n\\\n\t\t#include <stdlib.h>\t\t\t\t\t    \\n\\\n\t\t#include <bpf/libbpf.h>\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstruct %1$s {\t\t\t\t\t\t    \\n\\\n\t\t\tstruct bpf_object_skeleton *skeleton;\t\t    \\n\\\n\t\t\tstruct bpf_object *obj;\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name, header_guard\n\t\t);\n\t}\n\n\tif (map_cnt) {\n\t\tprintf(\"\\tstruct {\\n\");\n\t\tbpf_object__for_each_map(map, obj) {\n\t\t\tif (!get_map_ident(map, ident, sizeof(ident)))\n\t\t\t\tcontinue;\n\t\t\tif (use_loader)\n\t\t\t\tprintf(\"\\t\\tstruct bpf_map_desc %s;\\n\", ident);\n\t\t\telse\n\t\t\t\tprintf(\"\\t\\tstruct bpf_map *%s;\\n\", ident);\n\t\t}\n\t\tprintf(\"\\t} maps;\\n\");\n\t}\n\n\tif (prog_cnt) {\n\t\tprintf(\"\\tstruct {\\n\");\n\t\tbpf_object__for_each_program(prog, obj) {\n\t\t\tif (use_loader)\n\t\t\t\tprintf(\"\\t\\tstruct bpf_prog_desc %s;\\n\",\n\t\t\t\t       bpf_program__name(prog));\n\t\t\telse\n\t\t\t\tprintf(\"\\t\\tstruct bpf_program *%s;\\n\",\n\t\t\t\t       bpf_program__name(prog));\n\t\t}\n\t\tprintf(\"\\t} progs;\\n\");\n\t\tprintf(\"\\tstruct {\\n\");\n\t\tbpf_object__for_each_program(prog, obj) {\n\t\t\tif (use_loader)\n\t\t\t\tprintf(\"\\t\\tint %s_fd;\\n\",\n\t\t\t\t       bpf_program__name(prog));\n\t\t\telse\n\t\t\t\tprintf(\"\\t\\tstruct bpf_link *%s;\\n\",\n\t\t\t\t       bpf_program__name(prog));\n\t\t}\n\t\tprintf(\"\\t} links;\\n\");\n\t}\n\n\tbtf = bpf_object__btf(obj);\n\tif (btf) {\n\t\terr = codegen_datasecs(obj, obj_name);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (use_loader) {\n\t\terr = gen_trace(obj, obj_name, header_guard);\n\t\tgoto out;\n\t}\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\t\tstatic inline struct %1$s *open(const struct bpf_object_open_opts *opts = nullptr);\\n\\\n\t\t\tstatic inline struct %1$s *open_and_load();\t    \\n\\\n\t\t\tstatic inline int load(struct %1$s *skel);\t    \\n\\\n\t\t\tstatic inline int attach(struct %1$s *skel);\t    \\n\\\n\t\t\tstatic inline void detach(struct %1$s *skel);\t    \\n\\\n\t\t\tstatic inline void destroy(struct %1$s *skel);\t    \\n\\\n\t\t\tstatic inline const void *elf_bytes(size_t *sz);    \\n\\\n\t\t#endif  \t\t\t\t    \\n\\\n\t\t};\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic void\t\t\t\t\t\t    \\n\\\n\t\t%1$s__destroy(struct %1$s *obj)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tif (!obj)\t\t\t\t\t    \\n\\\n\t\t\t\treturn;\t\t\t\t\t    \\n\\\n\t\t\tif (obj->skeleton)\t\t\t\t    \\n\\\n\t\t\t\tbpf_object__destroy_skeleton(obj->skeleton);\\n\\\n\t\t\tfree(obj);\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__create_skeleton(struct %1$s *obj);\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open_opts(const struct bpf_object_open_opts *opts)    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct %1$s *obj;\t\t\t\t    \\n\\\n\t\t\tint err;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tobj = (struct %1$s *)calloc(1, sizeof(*obj));\t    \\n\\\n\t\t\tif (!obj) {\t\t\t\t\t    \\n\\\n\t\t\t\terrno = ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\treturn NULL;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\terr = %1$s__create_skeleton(obj);\t\t    \\n\\\n\t\t\tif (err)\t\t\t\t\t    \\n\\\n\t\t\t\tgoto err_out;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\terr = bpf_object__open_skeleton(obj->skeleton, opts);\\n\\\n\t\t\tif (err)\t\t\t\t\t    \\n\\\n\t\t\t\tgoto err_out;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\treturn obj;\t\t\t\t\t    \\n\\\n\t\terr_out:\t\t\t\t\t\t    \\n\\\n\t\t\t%1$s__destroy(obj);\t\t\t\t    \\n\\\n\t\t\terrno = -err;\t\t\t\t\t    \\n\\\n\t\t\treturn NULL;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open(void)\t\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\treturn %1$s__open_opts(NULL);\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__load(struct %1$s *obj)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\treturn bpf_object__load_skeleton(obj->skeleton);    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open_and_load(void)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct %1$s *obj;\t\t\t\t    \\n\\\n\t\t\tint err;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tobj = %1$s__open();\t\t\t\t    \\n\\\n\t\t\tif (!obj)\t\t\t\t\t    \\n\\\n\t\t\t\treturn NULL;\t\t\t\t    \\n\\\n\t\t\terr = %1$s__load(obj);\t\t\t\t    \\n\\\n\t\t\tif (err) {\t\t\t\t\t    \\n\\\n\t\t\t\t%1$s__destroy(obj);\t\t\t    \\n\\\n\t\t\t\terrno = -err;\t\t\t\t    \\n\\\n\t\t\t\treturn NULL;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\treturn obj;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__attach(struct %1$s *obj)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\treturn bpf_object__attach_skeleton(obj->skeleton);  \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline void\t\t\t\t\t    \\n\\\n\t\t%1$s__detach(struct %1$s *obj)\t\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tbpf_object__detach_skeleton(obj->skeleton);\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name\n\t);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline const void *%1$s__elf_bytes(size_t *sz);\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline int\t\t\t\t\t    \\n\\\n\t\t%1$s__create_skeleton(struct %1$s *obj)\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct bpf_object_skeleton *s;\t\t\t    \\n\\\n\t\t\tint err;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\ts = (struct bpf_object_skeleton *)calloc(1, sizeof(*s));\\n\\\n\t\t\tif (!s)\t{\t\t\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\ts->sz = sizeof(*s);\t\t\t\t    \\n\\\n\t\t\ts->name = \\\"%1$s\\\";\t\t\t\t    \\n\\\n\t\t\ts->obj = &obj->obj;\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name\n\t);\n\n\tcodegen_maps_skeleton(obj, map_cnt, true /*mmaped*/);\n\tcodegen_progs_skeleton(obj, prog_cnt, true /*populate_links*/);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\ts->data = %1$s__elf_bytes(&s->data_sz);\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tobj->skeleton = s;\t\t\t\t    \\n\\\n\t\t\treturn 0;\t\t\t\t\t    \\n\\\n\t\terr:\t\t\t\t\t\t\t    \\n\\\n\t\t\tbpf_object__destroy_skeleton(s);\t\t    \\n\\\n\t\t\treturn err;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline const void *%1$s__elf_bytes(size_t *sz)\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstatic const char data[] __attribute__((__aligned__(8))) = \\\"\\\\\\n\\\n\t\t\",\n\t\tobj_name\n\t);\n\n\t/* embed contents of BPF object file */\n\tprint_hex(obj_data, file_sz);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\\\";\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\t*sz = sizeof(data) - 1;\t\t\t\t    \\n\\\n\t\t\treturn (const void *)data;\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\tstruct %1$s *%1$s::open(const struct bpf_object_open_opts *opts) { return %1$s__open_opts(opts); }\\n\\\n\t\tstruct %1$s *%1$s::open_and_load() { return %1$s__open_and_load(); }\t\\n\\\n\t\tint %1$s::load(struct %1$s *skel) { return %1$s__load(skel); }\t\t\\n\\\n\t\tint %1$s::attach(struct %1$s *skel) { return %1$s__attach(skel); }\t\\n\\\n\t\tvoid %1$s::detach(struct %1$s *skel) { %1$s__detach(skel); }\t\t\\n\\\n\t\tvoid %1$s::destroy(struct %1$s *skel) { %1$s__destroy(skel); }\t\t\\n\\\n\t\tconst void *%1$s::elf_bytes(size_t *sz) { return %1$s__elf_bytes(sz); } \\n\\\n\t\t#endif  \t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name);\n\n\tcodegen_asserts(obj, obj_name);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#endif  \t\t\t\t\t    \\n\\\n\t\t\",\n\t\theader_guard);\n\terr = 0;\nout:\n\tbpf_object__close(obj);\n\tif (obj_data)\n\t\tmunmap(obj_data, mmap_sz);\n\tclose(fd);\n\treturn err;\n}\n\n/* Subskeletons are like skeletons, except they don't own the bpf_object,\n * associated maps, links, etc. Instead, they know about the existence of\n * variables, maps, programs and are able to find their locations\n * _at runtime_ from an already loaded bpf_object.\n *\n * This allows for library-like BPF objects to have userspace counterparts\n * with access to their own items without having to know anything about the\n * final BPF object that the library was linked into.\n */\nstatic int do_subskeleton(int argc, char **argv)\n{\n\tchar header_guard[MAX_OBJ_NAME_LEN + sizeof(\"__SUBSKEL_H__\")];\n\tsize_t i, len, file_sz, map_cnt = 0, prog_cnt = 0, mmap_sz, var_cnt = 0, var_idx = 0;\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts);\n\tchar obj_name[MAX_OBJ_NAME_LEN] = \"\", *obj_data;\n\tstruct bpf_object *obj = NULL;\n\tconst char *file, *var_name;\n\tchar ident[256];\n\tint fd, err = -1, map_type_id;\n\tconst struct bpf_map *map;\n\tstruct bpf_program *prog;\n\tstruct btf *btf;\n\tconst struct btf_type *map_type, *var_type;\n\tconst struct btf_var_secinfo *var;\n\tstruct stat st;\n\n\tif (!REQ_ARGS(1)) {\n\t\tusage();\n\t\treturn -1;\n\t}\n\tfile = GET_ARG();\n\n\twhile (argc) {\n\t\tif (!REQ_ARGS(2))\n\t\t\treturn -1;\n\n\t\tif (is_prefix(*argv, \"name\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (obj_name[0] != '\\0') {\n\t\t\t\tp_err(\"object name already specified\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstrncpy(obj_name, *argv, MAX_OBJ_NAME_LEN - 1);\n\t\t\tobj_name[MAX_OBJ_NAME_LEN - 1] = '\\0';\n\t\t} else {\n\t\t\tp_err(\"unknown arg %s\", *argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\tNEXT_ARG();\n\t}\n\n\tif (argc) {\n\t\tp_err(\"extra unknown arguments\");\n\t\treturn -1;\n\t}\n\n\tif (use_loader) {\n\t\tp_err(\"cannot use loader for subskeletons\");\n\t\treturn -1;\n\t}\n\n\tif (stat(file, &st)) {\n\t\tp_err(\"failed to stat() %s: %s\", file, strerror(errno));\n\t\treturn -1;\n\t}\n\tfile_sz = st.st_size;\n\tmmap_sz = roundup(file_sz, sysconf(_SC_PAGE_SIZE));\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tp_err(\"failed to open() %s: %s\", file, strerror(errno));\n\t\treturn -1;\n\t}\n\tobj_data = mmap(NULL, mmap_sz, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (obj_data == MAP_FAILED) {\n\t\tobj_data = NULL;\n\t\tp_err(\"failed to mmap() %s: %s\", file, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (obj_name[0] == '\\0')\n\t\tget_obj_name(obj_name, file);\n\n\t/* The empty object name allows us to use bpf_map__name and produce\n\t * ELF section names out of it. (\".data\" instead of \"obj.data\")\n\t */\n\topts.object_name = \"\";\n\tobj = bpf_object__open_mem(obj_data, file_sz, &opts);\n\tif (!obj) {\n\t\tchar err_buf[256];\n\n\t\tlibbpf_strerror(errno, err_buf, sizeof(err_buf));\n\t\tp_err(\"failed to open BPF object file: %s\", err_buf);\n\t\tobj = NULL;\n\t\tgoto out;\n\t}\n\n\tbtf = bpf_object__btf(obj);\n\tif (!btf) {\n\t\terr = -1;\n\t\tp_err(\"need btf type information for %s\", obj_name);\n\t\tgoto out;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprog_cnt++;\n\t}\n\n\t/* First, count how many variables we have to find.\n\t * We need this in advance so the subskel can allocate the right\n\t * amount of storage.\n\t */\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!get_map_ident(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\t/* Also count all maps that have a name */\n\t\tmap_cnt++;\n\n\t\tif (!is_internal_mmapable_map(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\tmap_type_id = bpf_map__btf_value_type_id(map);\n\t\tif (map_type_id <= 0) {\n\t\t\terr = map_type_id;\n\t\t\tgoto out;\n\t\t}\n\t\tmap_type = btf__type_by_id(btf, map_type_id);\n\n\t\tvar = btf_var_secinfos(map_type);\n\t\tlen = btf_vlen(map_type);\n\t\tfor (i = 0; i < len; i++, var++) {\n\t\t\tvar_type = btf__type_by_id(btf, var->type);\n\n\t\t\tif (btf_var(var_type)->linkage == BTF_VAR_STATIC)\n\t\t\t\tcontinue;\n\n\t\t\tvar_cnt++;\n\t\t}\n\t}\n\n\tget_header_guard(header_guard, obj_name, \"SUBSKEL_H\");\n\tcodegen(\"\\\n\t\\n\\\n\t \t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t \t\t\t\t    \\n\\\n\t#ifndef %2$s\t\t\t\t\t\t\t    \\n\\\n\t#define %2$s\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t#include <errno.h>\t\t\t\t\t\t    \\n\\\n\t#include <stdlib.h>\t\t\t\t\t\t    \\n\\\n\t#include <bpf/libbpf.h>\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\tstruct %1$s {\t\t\t\t\t\t\t    \\n\\\n\t\tstruct bpf_object *obj;\t\t\t\t\t    \\n\\\n\t\tstruct bpf_object_subskeleton *subskel;\t\t\t    \\n\\\n\t\", obj_name, header_guard);\n\n\tif (map_cnt) {\n\t\tprintf(\"\\tstruct {\\n\");\n\t\tbpf_object__for_each_map(map, obj) {\n\t\t\tif (!get_map_ident(map, ident, sizeof(ident)))\n\t\t\t\tcontinue;\n\t\t\tprintf(\"\\t\\tstruct bpf_map *%s;\\n\", ident);\n\t\t}\n\t\tprintf(\"\\t} maps;\\n\");\n\t}\n\n\tif (prog_cnt) {\n\t\tprintf(\"\\tstruct {\\n\");\n\t\tbpf_object__for_each_program(prog, obj) {\n\t\t\tprintf(\"\\t\\tstruct bpf_program *%s;\\n\",\n\t\t\t\tbpf_program__name(prog));\n\t\t}\n\t\tprintf(\"\\t} progs;\\n\");\n\t}\n\n\terr = codegen_subskel_datasecs(obj, obj_name);\n\tif (err)\n\t\tgoto out;\n\n\t/* emit code that will allocate enough storage for all symbols */\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\t\tstatic inline struct %1$s *open(const struct bpf_object *src);\\n\\\n\t\t\tstatic inline void destroy(struct %1$s *skel);\t    \\n\\\n\t\t#endif  \t\t\t\t    \\n\\\n\t\t};\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline void\t\t\t\t\t    \\n\\\n\t\t%1$s__destroy(struct %1$s *skel)\t\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tif (!skel)\t\t\t\t\t    \\n\\\n\t\t\t\treturn;\t\t\t\t\t    \\n\\\n\t\t\tif (skel->subskel)\t\t\t\t    \\n\\\n\t\t\t\tbpf_object__destroy_subskeleton(skel->subskel);\\n\\\n\t\t\tfree(skel);\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\tstatic inline struct %1$s *\t\t\t\t    \\n\\\n\t\t%1$s__open(const struct bpf_object *src)\t\t    \\n\\\n\t\t{\t\t\t\t\t\t\t    \\n\\\n\t\t\tstruct %1$s *obj;\t\t\t\t    \\n\\\n\t\t\tstruct bpf_object_subskeleton *s;\t\t    \\n\\\n\t\t\tint err;\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\tobj = (struct %1$s *)calloc(1, sizeof(*obj));\t    \\n\\\n\t\t\tif (!obj) {\t\t\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\ts = (struct bpf_object_subskeleton *)calloc(1, sizeof(*s));\\n\\\n\t\t\tif (!s) {\t\t\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\ts->sz = sizeof(*s);\t\t\t\t    \\n\\\n\t\t\ts->obj = src;\t\t\t\t\t    \\n\\\n\t\t\ts->var_skel_sz = sizeof(*s->vars);\t\t    \\n\\\n\t\t\tobj->subskel = s;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\t \t\t\t\t\t    \\n\\\n\t\t\ts->var_cnt = %2$d;\t\t\t\t    \\n\\\n\t\t\ts->vars = (struct bpf_var_skeleton *)calloc(%2$d, sizeof(*s->vars));\\n\\\n\t\t\tif (!s->vars) {\t\t\t\t\t    \\n\\\n\t\t\t\terr = -ENOMEM;\t\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t\t    \\n\\\n\t\t\t}\t\t\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name, var_cnt\n\t);\n\n\t/* walk through each symbol and emit the runtime representation */\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!is_internal_mmapable_map(map, ident, sizeof(ident)))\n\t\t\tcontinue;\n\n\t\tmap_type_id = bpf_map__btf_value_type_id(map);\n\t\tif (map_type_id <= 0)\n\t\t\t/* skip over internal maps with no type*/\n\t\t\tcontinue;\n\n\t\tmap_type = btf__type_by_id(btf, map_type_id);\n\t\tvar = btf_var_secinfos(map_type);\n\t\tlen = btf_vlen(map_type);\n\t\tfor (i = 0; i < len; i++, var++) {\n\t\t\tvar_type = btf__type_by_id(btf, var->type);\n\t\t\tvar_name = btf__name_by_offset(btf, var_type->name_off);\n\n\t\t\tif (btf_var(var_type)->linkage == BTF_VAR_STATIC)\n\t\t\t\tcontinue;\n\n\t\t\t/* Note that we use the dot prefix in .data as the\n\t\t\t * field access operator i.e. maps%s becomes maps.data\n\t\t\t */\n\t\t\tcodegen(\"\\\n\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\t\ts->vars[%3$d].name = \\\"%1$s\\\";\t\t    \\n\\\n\t\t\t\ts->vars[%3$d].map = &obj->maps.%2$s;\t    \\n\\\n\t\t\t\ts->vars[%3$d].addr = (void **) &obj->%2$s.%1$s;\\n\\\n\t\t\t\", var_name, ident, var_idx);\n\n\t\t\tvar_idx++;\n\t\t}\n\t}\n\n\tcodegen_maps_skeleton(obj, map_cnt, false /*mmaped*/);\n\tcodegen_progs_skeleton(obj, prog_cnt, false /*links*/);\n\n\tcodegen(\"\\\n\t\t\\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\terr = bpf_object__open_subskeleton(s);\t\t    \\n\\\n\t\t\tif (err)\t\t\t\t\t    \\n\\\n\t\t\t\tgoto err;\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t\treturn obj;\t\t\t\t\t    \\n\\\n\t\terr:\t\t\t\t\t\t\t    \\n\\\n\t\t\t%1$s__destroy(obj);\t\t\t\t    \\n\\\n\t\t\terrno = -err;\t\t\t\t\t    \\n\\\n\t\t\treturn NULL;\t\t\t\t\t    \\n\\\n\t\t}\t\t\t\t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#ifdef __cplusplus\t\t\t\t\t    \\n\\\n\t\tstruct %1$s *%1$s::open(const struct bpf_object *src) { return %1$s__open(src); }\\n\\\n\t\tvoid %1$s::destroy(struct %1$s *skel) { %1$s__destroy(skel); }\\n\\\n\t\t#endif  \t\t\t\t    \\n\\\n\t\t\t\t\t\t\t\t\t    \\n\\\n\t\t#endif  \t\t\t\t\t    \\n\\\n\t\t\",\n\t\tobj_name, header_guard);\n\terr = 0;\nout:\n\tbpf_object__close(obj);\n\tif (obj_data)\n\t\tmunmap(obj_data, mmap_sz);\n\tclose(fd);\n\treturn err;\n}\n\nstatic int do_object(int argc, char **argv)\n{\n\tstruct bpf_linker *linker;\n\tconst char *output_file, *file;\n\tint err = 0;\n\n\tif (!REQ_ARGS(2)) {\n\t\tusage();\n\t\treturn -1;\n\t}\n\n\toutput_file = GET_ARG();\n\n\tlinker = bpf_linker__new(output_file, NULL);\n\tif (!linker) {\n\t\tp_err(\"failed to create BPF linker instance\");\n\t\treturn -1;\n\t}\n\n\twhile (argc) {\n\t\tfile = GET_ARG();\n\n\t\terr = bpf_linker__add_file(linker, file, NULL);\n\t\tif (err) {\n\t\t\tp_err(\"failed to link '%s': %s (%d)\", file, strerror(errno), errno);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = bpf_linker__finalize(linker);\n\tif (err) {\n\t\tp_err(\"failed to finalize ELF file: %s (%d)\", strerror(errno), errno);\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tbpf_linker__free(linker);\n\treturn err;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s object OUTPUT_FILE INPUT_FILE [INPUT_FILE...]\\n\"\n\t\t\"       %1$s %2$s skeleton FILE [name OBJECT_NAME]\\n\"\n\t\t\"       %1$s %2$s subskeleton FILE [name OBJECT_NAME]\\n\"\n\t\t\"       %1$s %2$s min_core_btf INPUT OUTPUT OBJECT [OBJECT...]\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-L|--use-loader} }\\n\"\n\t\t\"\",\n\t\tbin_name, \"gen\");\n\n\treturn 0;\n}\n\nstatic int btf_save_raw(const struct btf *btf, const char *path)\n{\n\tconst void *data;\n\tFILE *f = NULL;\n\t__u32 data_sz;\n\tint err = 0;\n\n\tdata = btf__raw_data(btf, &data_sz);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tf = fopen(path, \"wb\");\n\tif (!f)\n\t\treturn -errno;\n\n\tif (fwrite(data, 1, data_sz, f) != data_sz)\n\t\terr = -errno;\n\n\tfclose(f);\n\treturn err;\n}\n\nstruct btfgen_info {\n\tstruct btf *src_btf;\n\tstruct btf *marked_btf; /* btf structure used to mark used types */\n};\n\nstatic size_t btfgen_hash_fn(long key, void *ctx)\n{\n\treturn key;\n}\n\nstatic bool btfgen_equal_fn(long k1, long k2, void *ctx)\n{\n\treturn k1 == k2;\n}\n\nstatic void btfgen_free_info(struct btfgen_info *info)\n{\n\tif (!info)\n\t\treturn;\n\n\tbtf__free(info->src_btf);\n\tbtf__free(info->marked_btf);\n\n\tfree(info);\n}\n\nstatic struct btfgen_info *\nbtfgen_new_info(const char *targ_btf_path)\n{\n\tstruct btfgen_info *info;\n\tint err;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->src_btf = btf__parse(targ_btf_path, NULL);\n\tif (!info->src_btf) {\n\t\terr = -errno;\n\t\tp_err(\"failed parsing '%s' BTF file: %s\", targ_btf_path, strerror(errno));\n\t\tgoto err_out;\n\t}\n\n\tinfo->marked_btf = btf__parse(targ_btf_path, NULL);\n\tif (!info->marked_btf) {\n\t\terr = -errno;\n\t\tp_err(\"failed parsing '%s' BTF file: %s\", targ_btf_path, strerror(errno));\n\t\tgoto err_out;\n\t}\n\n\treturn info;\n\nerr_out:\n\tbtfgen_free_info(info);\n\terrno = -err;\n\treturn NULL;\n}\n\n#define MARKED UINT32_MAX\n\nstatic void btfgen_mark_member(struct btfgen_info *info, int type_id, int idx)\n{\n\tconst struct btf_type *t = btf__type_by_id(info->marked_btf, type_id);\n\tstruct btf_member *m = btf_members(t) + idx;\n\n\tm->name_off = MARKED;\n}\n\nstatic int\nbtfgen_mark_type(struct btfgen_info *info, unsigned int type_id, bool follow_pointers)\n{\n\tconst struct btf_type *btf_type = btf__type_by_id(info->src_btf, type_id);\n\tstruct btf_type *cloned_type;\n\tstruct btf_param *param;\n\tstruct btf_array *array;\n\tint err, i;\n\n\tif (type_id == 0)\n\t\treturn 0;\n\n\t/* mark type on cloned BTF as used */\n\tcloned_type = (struct btf_type *) btf__type_by_id(info->marked_btf, type_id);\n\tcloned_type->name_off = MARKED;\n\n\t/* recursively mark other types needed by it */\n\tswitch (btf_kind(btf_type)) {\n\tcase BTF_KIND_UNKN:\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tbreak;\n\tcase BTF_KIND_PTR:\n\t\tif (follow_pointers) {\n\t\t\terr = btfgen_mark_type(info, btf_type->type, follow_pointers);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_TYPEDEF:\n\t\terr = btfgen_mark_type(info, btf_type->type, follow_pointers);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase BTF_KIND_ARRAY:\n\t\tarray = btf_array(btf_type);\n\n\t\t/* mark array type */\n\t\terr = btfgen_mark_type(info, array->type, follow_pointers);\n\t\t/* mark array's index type */\n\t\terr = err ? : btfgen_mark_type(info, array->index_type, follow_pointers);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase BTF_KIND_FUNC_PROTO:\n\t\t/* mark ret type */\n\t\terr = btfgen_mark_type(info, btf_type->type, follow_pointers);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/* mark parameters types */\n\t\tparam = btf_params(btf_type);\n\t\tfor (i = 0; i < btf_vlen(btf_type); i++) {\n\t\t\terr = btfgen_mark_type(info, param->type, follow_pointers);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tparam++;\n\t\t}\n\t\tbreak;\n\t/* tells if some other type needs to be handled */\n\tdefault:\n\t\tp_err(\"unsupported kind: %s (%d)\", btf_kind_str(btf_type), type_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btfgen_record_field_relo(struct btfgen_info *info, struct bpf_core_spec *targ_spec)\n{\n\tstruct btf *btf = info->src_btf;\n\tconst struct btf_type *btf_type;\n\tstruct btf_member *btf_member;\n\tstruct btf_array *array;\n\tunsigned int type_id = targ_spec->root_type_id;\n\tint idx, err;\n\n\t/* mark root type */\n\tbtf_type = btf__type_by_id(btf, type_id);\n\terr = btfgen_mark_type(info, type_id, false);\n\tif (err)\n\t\treturn err;\n\n\t/* mark types for complex types (arrays, unions, structures) */\n\tfor (int i = 1; i < targ_spec->raw_len; i++) {\n\t\t/* skip typedefs and mods */\n\t\twhile (btf_is_mod(btf_type) || btf_is_typedef(btf_type)) {\n\t\t\ttype_id = btf_type->type;\n\t\t\tbtf_type = btf__type_by_id(btf, type_id);\n\t\t}\n\n\t\tswitch (btf_kind(btf_type)) {\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\t\tidx = targ_spec->raw_spec[i];\n\t\t\tbtf_member = btf_members(btf_type) + idx;\n\n\t\t\t/* mark member */\n\t\t\tbtfgen_mark_member(info, type_id, idx);\n\n\t\t\t/* mark member's type */\n\t\t\ttype_id = btf_member->type;\n\t\t\tbtf_type = btf__type_by_id(btf, type_id);\n\t\t\terr = btfgen_mark_type(info, type_id, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tarray = btf_array(btf_type);\n\t\t\ttype_id = array->type;\n\t\t\tbtf_type = btf__type_by_id(btf, type_id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp_err(\"unsupported kind: %s (%d)\",\n\t\t\t      btf_kind_str(btf_type), btf_type->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Mark types, members, and member types. Compared to btfgen_record_field_relo,\n * this function does not rely on the target spec for inferring members, but\n * uses the associated BTF.\n *\n * The `behind_ptr` argument is used to stop marking of composite types reached\n * through a pointer. This way, we can keep BTF size in check while providing\n * reasonable match semantics.\n */\nstatic int btfgen_mark_type_match(struct btfgen_info *info, __u32 type_id, bool behind_ptr)\n{\n\tconst struct btf_type *btf_type;\n\tstruct btf *btf = info->src_btf;\n\tstruct btf_type *cloned_type;\n\tint i, err;\n\n\tif (type_id == 0)\n\t\treturn 0;\n\n\tbtf_type = btf__type_by_id(btf, type_id);\n\t/* mark type on cloned BTF as used */\n\tcloned_type = (struct btf_type *)btf__type_by_id(info->marked_btf, type_id);\n\tcloned_type->name_off = MARKED;\n\n\tswitch (btf_kind(btf_type)) {\n\tcase BTF_KIND_UNKN:\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_ENUM64:\n\t\tbreak;\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tstruct btf_member *m = btf_members(btf_type);\n\t\t__u16 vlen = btf_vlen(btf_type);\n\n\t\tif (behind_ptr)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < vlen; i++, m++) {\n\t\t\t/* mark member */\n\t\t\tbtfgen_mark_member(info, type_id, i);\n\n\t\t\t/* mark member's type */\n\t\t\terr = btfgen_mark_type_match(info, m->type, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\t\treturn btfgen_mark_type_match(info, btf_type->type, behind_ptr);\n\tcase BTF_KIND_PTR:\n\t\treturn btfgen_mark_type_match(info, btf_type->type, true);\n\tcase BTF_KIND_ARRAY: {\n\t\tstruct btf_array *array;\n\n\t\tarray = btf_array(btf_type);\n\t\t/* mark array type */\n\t\terr = btfgen_mark_type_match(info, array->type, false);\n\t\t/* mark array's index type */\n\t\terr = err ? : btfgen_mark_type_match(info, array->index_type, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\t__u16 vlen = btf_vlen(btf_type);\n\t\tstruct btf_param *param;\n\n\t\t/* mark ret type */\n\t\terr = btfgen_mark_type_match(info, btf_type->type, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/* mark parameters types */\n\t\tparam = btf_params(btf_type);\n\t\tfor (i = 0; i < vlen; i++) {\n\t\t\terr = btfgen_mark_type_match(info, param->type, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tparam++;\n\t\t}\n\t\tbreak;\n\t}\n\t/* tells if some other type needs to be handled */\n\tdefault:\n\t\tp_err(\"unsupported kind: %s (%d)\", btf_kind_str(btf_type), type_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Mark types, members, and member types. Compared to btfgen_record_field_relo,\n * this function does not rely on the target spec for inferring members, but\n * uses the associated BTF.\n */\nstatic int btfgen_record_type_match_relo(struct btfgen_info *info, struct bpf_core_spec *targ_spec)\n{\n\treturn btfgen_mark_type_match(info, targ_spec->root_type_id, false);\n}\n\nstatic int btfgen_record_type_relo(struct btfgen_info *info, struct bpf_core_spec *targ_spec)\n{\n\treturn btfgen_mark_type(info, targ_spec->root_type_id, true);\n}\n\nstatic int btfgen_record_enumval_relo(struct btfgen_info *info, struct bpf_core_spec *targ_spec)\n{\n\treturn btfgen_mark_type(info, targ_spec->root_type_id, false);\n}\n\nstatic int btfgen_record_reloc(struct btfgen_info *info, struct bpf_core_spec *res)\n{\n\tswitch (res->relo_kind) {\n\tcase BPF_CORE_FIELD_BYTE_OFFSET:\n\tcase BPF_CORE_FIELD_BYTE_SIZE:\n\tcase BPF_CORE_FIELD_EXISTS:\n\tcase BPF_CORE_FIELD_SIGNED:\n\tcase BPF_CORE_FIELD_LSHIFT_U64:\n\tcase BPF_CORE_FIELD_RSHIFT_U64:\n\t\treturn btfgen_record_field_relo(info, res);\n\tcase BPF_CORE_TYPE_ID_LOCAL: /* BPF_CORE_TYPE_ID_LOCAL doesn't require kernel BTF */\n\t\treturn 0;\n\tcase BPF_CORE_TYPE_ID_TARGET:\n\tcase BPF_CORE_TYPE_EXISTS:\n\tcase BPF_CORE_TYPE_SIZE:\n\t\treturn btfgen_record_type_relo(info, res);\n\tcase BPF_CORE_TYPE_MATCHES:\n\t\treturn btfgen_record_type_match_relo(info, res);\n\tcase BPF_CORE_ENUMVAL_EXISTS:\n\tcase BPF_CORE_ENUMVAL_VALUE:\n\t\treturn btfgen_record_enumval_relo(info, res);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct bpf_core_cand_list *\nbtfgen_find_cands(const struct btf *local_btf, const struct btf *targ_btf, __u32 local_id)\n{\n\tconst struct btf_type *local_type;\n\tstruct bpf_core_cand_list *cands = NULL;\n\tstruct bpf_core_cand local_cand = {};\n\tsize_t local_essent_len;\n\tconst char *local_name;\n\tint err;\n\n\tlocal_cand.btf = local_btf;\n\tlocal_cand.id = local_id;\n\n\tlocal_type = btf__type_by_id(local_btf, local_id);\n\tif (!local_type) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tlocal_name = btf__name_by_offset(local_btf, local_type->name_off);\n\tif (!local_name) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\tlocal_essent_len = bpf_core_essential_name_len(local_name);\n\n\tcands = calloc(1, sizeof(*cands));\n\tif (!cands)\n\t\treturn NULL;\n\n\terr = bpf_core_add_cands(&local_cand, local_essent_len, targ_btf, \"vmlinux\", 1, cands);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn cands;\n\nerr_out:\n\tbpf_core_free_cands(cands);\n\terrno = -err;\n\treturn NULL;\n}\n\n/* Record relocation information for a single BPF object */\nstatic int btfgen_record_obj(struct btfgen_info *info, const char *obj_path)\n{\n\tconst struct btf_ext_info_sec *sec;\n\tconst struct bpf_core_relo *relo;\n\tconst struct btf_ext_info *seg;\n\tstruct hashmap_entry *entry;\n\tstruct hashmap *cand_cache = NULL;\n\tstruct btf_ext *btf_ext = NULL;\n\tunsigned int relo_idx;\n\tstruct btf *btf = NULL;\n\tsize_t i;\n\tint err;\n\n\tbtf = btf__parse(obj_path, &btf_ext);\n\tif (!btf) {\n\t\terr = -errno;\n\t\tp_err(\"failed to parse BPF object '%s': %s\", obj_path, strerror(errno));\n\t\treturn err;\n\t}\n\n\tif (!btf_ext) {\n\t\tp_err(\"failed to parse BPF object '%s': section %s not found\",\n\t\t      obj_path, BTF_EXT_ELF_SEC);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btf_ext->core_relo_info.len == 0) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tcand_cache = hashmap__new(btfgen_hash_fn, btfgen_equal_fn, NULL);\n\tif (IS_ERR(cand_cache)) {\n\t\terr = PTR_ERR(cand_cache);\n\t\tgoto out;\n\t}\n\n\tseg = &btf_ext->core_relo_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tfor_each_btf_ext_rec(seg, sec, relo_idx, relo) {\n\t\t\tstruct bpf_core_spec specs_scratch[3] = {};\n\t\t\tstruct bpf_core_relo_res targ_res = {};\n\t\t\tstruct bpf_core_cand_list *cands = NULL;\n\t\t\tconst char *sec_name = btf__name_by_offset(btf, sec->sec_name_off);\n\n\t\t\tif (relo->kind != BPF_CORE_TYPE_ID_LOCAL &&\n\t\t\t    !hashmap__find(cand_cache, relo->type_id, &cands)) {\n\t\t\t\tcands = btfgen_find_cands(btf, info->src_btf, relo->type_id);\n\t\t\t\tif (!cands) {\n\t\t\t\t\terr = -errno;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\terr = hashmap__set(cand_cache, relo->type_id, cands,\n\t\t\t\t\t\t   NULL, NULL);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = bpf_core_calc_relo_insn(sec_name, relo, relo_idx, btf, cands,\n\t\t\t\t\t\t      specs_scratch, &targ_res);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t/* specs_scratch[2] is the target spec */\n\t\t\terr = btfgen_record_reloc(info, &specs_scratch[2]);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtf__free(btf);\n\tbtf_ext__free(btf_ext);\n\n\tif (!IS_ERR_OR_NULL(cand_cache)) {\n\t\thashmap__for_each_entry(cand_cache, entry, i) {\n\t\t\tbpf_core_free_cands(entry->pvalue);\n\t\t}\n\t\thashmap__free(cand_cache);\n\t}\n\n\treturn err;\n}\n\nstatic int btfgen_remap_id(__u32 *type_id, void *ctx)\n{\n\tunsigned int *ids = ctx;\n\n\t*type_id = ids[*type_id];\n\n\treturn 0;\n}\n\n/* Generate BTF from relocation information previously recorded */\nstatic struct btf *btfgen_get_btf(struct btfgen_info *info)\n{\n\tstruct btf *btf_new = NULL;\n\tunsigned int *ids = NULL;\n\tunsigned int i, n = btf__type_cnt(info->marked_btf);\n\tint err = 0;\n\n\tbtf_new = btf__new_empty();\n\tif (!btf_new) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\n\tids = calloc(n, sizeof(*ids));\n\tif (!ids) {\n\t\terr = -errno;\n\t\tgoto err_out;\n\t}\n\n\t/* first pass: add all marked types to btf_new and add their new ids to the ids map */\n\tfor (i = 1; i < n; i++) {\n\t\tconst struct btf_type *cloned_type, *type;\n\t\tconst char *name;\n\t\tint new_id;\n\n\t\tcloned_type = btf__type_by_id(info->marked_btf, i);\n\n\t\tif (cloned_type->name_off != MARKED)\n\t\t\tcontinue;\n\n\t\ttype = btf__type_by_id(info->src_btf, i);\n\n\t\t/* add members for struct and union */\n\t\tif (btf_is_composite(type)) {\n\t\t\tstruct btf_member *cloned_m, *m;\n\t\t\tunsigned short vlen;\n\t\t\tint idx_src;\n\n\t\t\tname = btf__str_by_offset(info->src_btf, type->name_off);\n\n\t\t\tif (btf_is_struct(type))\n\t\t\t\terr = btf__add_struct(btf_new, name, type->size);\n\t\t\telse\n\t\t\t\terr = btf__add_union(btf_new, name, type->size);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_out;\n\t\t\tnew_id = err;\n\n\t\t\tcloned_m = btf_members(cloned_type);\n\t\t\tm = btf_members(type);\n\t\t\tvlen = btf_vlen(cloned_type);\n\t\t\tfor (idx_src = 0; idx_src < vlen; idx_src++, cloned_m++, m++) {\n\t\t\t\t/* add only members that are marked as used */\n\t\t\t\tif (cloned_m->name_off != MARKED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tname = btf__str_by_offset(info->src_btf, m->name_off);\n\t\t\t\terr = btf__add_field(btf_new, name, m->type,\n\t\t\t\t\t\t     btf_member_bit_offset(cloned_type, idx_src),\n\t\t\t\t\t\t     btf_member_bitfield_size(cloned_type, idx_src));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else {\n\t\t\terr = btf__add_type(btf_new, info->src_btf, type);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_out;\n\t\t\tnew_id = err;\n\t\t}\n\n\t\t/* add ID mapping */\n\t\tids[i] = new_id;\n\t}\n\n\t/* second pass: fix up type ids */\n\tfor (i = 1; i < btf__type_cnt(btf_new); i++) {\n\t\tstruct btf_type *btf_type = (struct btf_type *) btf__type_by_id(btf_new, i);\n\n\t\terr = btf_type_visit_type_ids(btf_type, btfgen_remap_id, ids);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tfree(ids);\n\treturn btf_new;\n\nerr_out:\n\tbtf__free(btf_new);\n\tfree(ids);\n\terrno = -err;\n\treturn NULL;\n}\n\n/* Create minimized BTF file for a set of BPF objects.\n *\n * The BTFGen algorithm is divided in two main parts: (1) collect the\n * BTF types that are involved in relocations and (2) generate the BTF\n * object using the collected types.\n *\n * In order to collect the types involved in the relocations, we parse\n * the BTF and BTF.ext sections of the BPF objects and use\n * bpf_core_calc_relo_insn() to get the target specification, this\n * indicates how the types and fields are used in a relocation.\n *\n * Types are recorded in different ways according to the kind of the\n * relocation. For field-based relocations only the members that are\n * actually used are saved in order to reduce the size of the generated\n * BTF file. For type-based relocations empty struct / unions are\n * generated and for enum-based relocations the whole type is saved.\n *\n * The second part of the algorithm generates the BTF object. It creates\n * an empty BTF object and fills it with the types recorded in the\n * previous step. This function takes care of only adding the structure\n * and union members that were marked as used and it also fixes up the\n * type IDs on the generated BTF object.\n */\nstatic int minimize_btf(const char *src_btf, const char *dst_btf, const char *objspaths[])\n{\n\tstruct btfgen_info *info;\n\tstruct btf *btf_new = NULL;\n\tint err, i;\n\n\tinfo = btfgen_new_info(src_btf);\n\tif (!info) {\n\t\terr = -errno;\n\t\tp_err(\"failed to allocate info structure: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; objspaths[i] != NULL; i++) {\n\t\terr = btfgen_record_obj(info, objspaths[i]);\n\t\tif (err) {\n\t\t\tp_err(\"error recording relocations for %s: %s\", objspaths[i],\n\t\t\t      strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtf_new = btfgen_get_btf(info);\n\tif (!btf_new) {\n\t\terr = -errno;\n\t\tp_err(\"error generating BTF: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\n\terr = btf_save_raw(btf_new, dst_btf);\n\tif (err) {\n\t\tp_err(\"error saving btf file: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\nout:\n\tbtf__free(btf_new);\n\tbtfgen_free_info(info);\n\n\treturn err;\n}\n\nstatic int do_min_core_btf(int argc, char **argv)\n{\n\tconst char *input, *output, **objs;\n\tint i, err;\n\n\tif (!REQ_ARGS(3)) {\n\t\tusage();\n\t\treturn -1;\n\t}\n\n\tinput = GET_ARG();\n\toutput = GET_ARG();\n\n\tobjs = (const char **) calloc(argc + 1, sizeof(*objs));\n\tif (!objs) {\n\t\tp_err(\"failed to allocate array for object names\");\n\t\treturn -ENOMEM;\n\t}\n\n\ti = 0;\n\twhile (argc)\n\t\tobjs[i++] = GET_ARG();\n\n\terr = minimize_btf(input, output, objs);\n\tfree(objs);\n\treturn err;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"object\",\t\tdo_object },\n\t{ \"skeleton\",\t\tdo_skeleton },\n\t{ \"subskeleton\",\tdo_subskeleton },\n\t{ \"min_core_btf\",\tdo_min_core_btf},\n\t{ \"help\",\t\tdo_help },\n\t{ 0 }\n};\n\nint do_gen(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}