{
  "module_name": "cfg.c",
  "hash_id": "adbd2aa8e1a1be8e3af0ca74981edad33f6c99dd7b463548bfffe253526d5b2e",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/cfg.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cfg.h\"\n#include \"main.h\"\n#include \"xlated_dumper.h\"\n\nstruct cfg {\n\tstruct list_head funcs;\n\tint func_num;\n};\n\nstruct func_node {\n\tstruct list_head l;\n\tstruct list_head bbs;\n\tstruct bpf_insn *start;\n\tstruct bpf_insn *end;\n\tint idx;\n\tint bb_num;\n};\n\nstruct bb_node {\n\tstruct list_head l;\n\tstruct list_head e_prevs;\n\tstruct list_head e_succs;\n\tstruct bpf_insn *head;\n\tstruct bpf_insn *tail;\n\tint idx;\n};\n\n#define EDGE_FLAG_EMPTY\t\t0x0\n#define EDGE_FLAG_FALLTHROUGH\t0x1\n#define EDGE_FLAG_JUMP\t\t0x2\nstruct edge_node {\n\tstruct list_head l;\n\tstruct bb_node *src;\n\tstruct bb_node *dst;\n\tint flags;\n};\n\n#define ENTRY_BLOCK_INDEX\t0\n#define EXIT_BLOCK_INDEX\t1\n#define NUM_FIXED_BLOCKS\t2\n#define func_prev(func)\t\tlist_prev_entry(func, l)\n#define func_next(func)\t\tlist_next_entry(func, l)\n#define bb_prev(bb)\t\tlist_prev_entry(bb, l)\n#define bb_next(bb)\t\tlist_next_entry(bb, l)\n#define entry_bb(func)\t\tfunc_first_bb(func)\n#define exit_bb(func)\t\tfunc_last_bb(func)\n#define cfg_first_func(cfg)\t\\\n\tlist_first_entry(&cfg->funcs, struct func_node, l)\n#define cfg_last_func(cfg)\t\\\n\tlist_last_entry(&cfg->funcs, struct func_node, l)\n#define func_first_bb(func)\t\\\n\tlist_first_entry(&func->bbs, struct bb_node, l)\n#define func_last_bb(func)\t\\\n\tlist_last_entry(&func->bbs, struct bb_node, l)\n\nstatic struct func_node *cfg_append_func(struct cfg *cfg, struct bpf_insn *insn)\n{\n\tstruct func_node *new_func, *func;\n\n\tlist_for_each_entry(func, &cfg->funcs, l) {\n\t\tif (func->start == insn)\n\t\t\treturn func;\n\t\telse if (func->start > insn)\n\t\t\tbreak;\n\t}\n\n\tfunc = func_prev(func);\n\tnew_func = calloc(1, sizeof(*new_func));\n\tif (!new_func) {\n\t\tp_err(\"OOM when allocating FUNC node\");\n\t\treturn NULL;\n\t}\n\tnew_func->start = insn;\n\tnew_func->idx = cfg->func_num;\n\tlist_add(&new_func->l, &func->l);\n\tcfg->func_num++;\n\n\treturn new_func;\n}\n\nstatic struct bb_node *func_append_bb(struct func_node *func,\n\t\t\t\t      struct bpf_insn *insn)\n{\n\tstruct bb_node *new_bb, *bb;\n\n\tlist_for_each_entry(bb, &func->bbs, l) {\n\t\tif (bb->head == insn)\n\t\t\treturn bb;\n\t\telse if (bb->head > insn)\n\t\t\tbreak;\n\t}\n\n\tbb = bb_prev(bb);\n\tnew_bb = calloc(1, sizeof(*new_bb));\n\tif (!new_bb) {\n\t\tp_err(\"OOM when allocating BB node\");\n\t\treturn NULL;\n\t}\n\tnew_bb->head = insn;\n\tINIT_LIST_HEAD(&new_bb->e_prevs);\n\tINIT_LIST_HEAD(&new_bb->e_succs);\n\tlist_add(&new_bb->l, &bb->l);\n\n\treturn new_bb;\n}\n\nstatic struct bb_node *func_insert_dummy_bb(struct list_head *after)\n{\n\tstruct bb_node *bb;\n\n\tbb = calloc(1, sizeof(*bb));\n\tif (!bb) {\n\t\tp_err(\"OOM when allocating BB node\");\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&bb->e_prevs);\n\tINIT_LIST_HEAD(&bb->e_succs);\n\tlist_add(&bb->l, after);\n\n\treturn bb;\n}\n\nstatic bool cfg_partition_funcs(struct cfg *cfg, struct bpf_insn *cur,\n\t\t\t\tstruct bpf_insn *end)\n{\n\tstruct func_node *func, *last_func;\n\n\tfunc = cfg_append_func(cfg, cur);\n\tif (!func)\n\t\treturn true;\n\n\tfor (; cur < end; cur++) {\n\t\tif (cur->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (cur->src_reg != BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\t\tfunc = cfg_append_func(cfg, cur + cur->off + 1);\n\t\tif (!func)\n\t\t\treturn true;\n\t}\n\n\tlast_func = cfg_last_func(cfg);\n\tlast_func->end = end - 1;\n\tfunc = cfg_first_func(cfg);\n\tlist_for_each_entry_from(func, &last_func->l, l) {\n\t\tfunc->end = func_next(func)->start - 1;\n\t}\n\n\treturn false;\n}\n\nstatic bool is_jmp_insn(__u8 code)\n{\n\treturn BPF_CLASS(code) == BPF_JMP || BPF_CLASS(code) == BPF_JMP32;\n}\n\nstatic bool func_partition_bb_head(struct func_node *func)\n{\n\tstruct bpf_insn *cur, *end;\n\tstruct bb_node *bb;\n\n\tcur = func->start;\n\tend = func->end;\n\tINIT_LIST_HEAD(&func->bbs);\n\tbb = func_append_bb(func, cur);\n\tif (!bb)\n\t\treturn true;\n\n\tfor (; cur <= end; cur++) {\n\t\tif (is_jmp_insn(cur->code)) {\n\t\t\t__u8 opcode = BPF_OP(cur->code);\n\n\t\t\tif (opcode == BPF_EXIT || opcode == BPF_CALL)\n\t\t\t\tcontinue;\n\n\t\t\tbb = func_append_bb(func, cur + cur->off + 1);\n\t\t\tif (!bb)\n\t\t\t\treturn true;\n\n\t\t\tif (opcode != BPF_JA) {\n\t\t\t\tbb = func_append_bb(func, cur + 1);\n\t\t\t\tif (!bb)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void func_partition_bb_tail(struct func_node *func)\n{\n\tunsigned int bb_idx = NUM_FIXED_BLOCKS;\n\tstruct bb_node *bb, *last;\n\n\tlast = func_last_bb(func);\n\tlast->tail = func->end;\n\tbb = func_first_bb(func);\n\tlist_for_each_entry_from(bb, &last->l, l) {\n\t\tbb->tail = bb_next(bb)->head - 1;\n\t\tbb->idx = bb_idx++;\n\t}\n\n\tlast->idx = bb_idx++;\n\tfunc->bb_num = bb_idx;\n}\n\nstatic bool func_add_special_bb(struct func_node *func)\n{\n\tstruct bb_node *bb;\n\n\tbb = func_insert_dummy_bb(&func->bbs);\n\tif (!bb)\n\t\treturn true;\n\tbb->idx = ENTRY_BLOCK_INDEX;\n\n\tbb = func_insert_dummy_bb(&func_last_bb(func)->l);\n\tif (!bb)\n\t\treturn true;\n\tbb->idx = EXIT_BLOCK_INDEX;\n\n\treturn false;\n}\n\nstatic bool func_partition_bb(struct func_node *func)\n{\n\tif (func_partition_bb_head(func))\n\t\treturn true;\n\n\tfunc_partition_bb_tail(func);\n\n\treturn false;\n}\n\nstatic struct bb_node *func_search_bb_with_head(struct func_node *func,\n\t\t\t\t\t\tstruct bpf_insn *insn)\n{\n\tstruct bb_node *bb;\n\n\tlist_for_each_entry(bb, &func->bbs, l) {\n\t\tif (bb->head == insn)\n\t\t\treturn bb;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct edge_node *new_edge(struct bb_node *src, struct bb_node *dst,\n\t\t\t\t  int flags)\n{\n\tstruct edge_node *e;\n\n\te = calloc(1, sizeof(*e));\n\tif (!e) {\n\t\tp_err(\"OOM when allocating edge node\");\n\t\treturn NULL;\n\t}\n\n\tif (src)\n\t\te->src = src;\n\tif (dst)\n\t\te->dst = dst;\n\n\te->flags |= flags;\n\n\treturn e;\n}\n\nstatic bool func_add_bb_edges(struct func_node *func)\n{\n\tstruct bpf_insn *insn;\n\tstruct edge_node *e;\n\tstruct bb_node *bb;\n\n\tbb = entry_bb(func);\n\te = new_edge(bb, bb_next(bb), EDGE_FLAG_FALLTHROUGH);\n\tif (!e)\n\t\treturn true;\n\tlist_add_tail(&e->l, &bb->e_succs);\n\n\tbb = exit_bb(func);\n\te = new_edge(bb_prev(bb), bb, EDGE_FLAG_FALLTHROUGH);\n\tif (!e)\n\t\treturn true;\n\tlist_add_tail(&e->l, &bb->e_prevs);\n\n\tbb = entry_bb(func);\n\tbb = bb_next(bb);\n\tlist_for_each_entry_from(bb, &exit_bb(func)->l, l) {\n\t\te = new_edge(bb, NULL, EDGE_FLAG_EMPTY);\n\t\tif (!e)\n\t\t\treturn true;\n\t\te->src = bb;\n\n\t\tinsn = bb->tail;\n\t\tif (!is_jmp_insn(insn->code) ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT) {\n\t\t\te->dst = bb_next(bb);\n\t\t\te->flags |= EDGE_FLAG_FALLTHROUGH;\n\t\t\tlist_add_tail(&e->l, &bb->e_succs);\n\t\t\tcontinue;\n\t\t} else if (BPF_OP(insn->code) == BPF_JA) {\n\t\t\te->dst = func_search_bb_with_head(func,\n\t\t\t\t\t\t\t  insn + insn->off + 1);\n\t\t\te->flags |= EDGE_FLAG_JUMP;\n\t\t\tlist_add_tail(&e->l, &bb->e_succs);\n\t\t\tcontinue;\n\t\t}\n\n\t\te->dst = bb_next(bb);\n\t\te->flags |= EDGE_FLAG_FALLTHROUGH;\n\t\tlist_add_tail(&e->l, &bb->e_succs);\n\n\t\te = new_edge(bb, NULL, EDGE_FLAG_JUMP);\n\t\tif (!e)\n\t\t\treturn true;\n\t\te->src = bb;\n\t\te->dst = func_search_bb_with_head(func, insn + insn->off + 1);\n\t\tlist_add_tail(&e->l, &bb->e_succs);\n\t}\n\n\treturn false;\n}\n\nstatic bool cfg_build(struct cfg *cfg, struct bpf_insn *insn, unsigned int len)\n{\n\tint cnt = len / sizeof(*insn);\n\tstruct func_node *func;\n\n\tINIT_LIST_HEAD(&cfg->funcs);\n\n\tif (cfg_partition_funcs(cfg, insn, insn + cnt))\n\t\treturn true;\n\n\tlist_for_each_entry(func, &cfg->funcs, l) {\n\t\tif (func_partition_bb(func) || func_add_special_bb(func))\n\t\t\treturn true;\n\n\t\tif (func_add_bb_edges(func))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void cfg_destroy(struct cfg *cfg)\n{\n\tstruct func_node *func, *func2;\n\n\tlist_for_each_entry_safe(func, func2, &cfg->funcs, l) {\n\t\tstruct bb_node *bb, *bb2;\n\n\t\tlist_for_each_entry_safe(bb, bb2, &func->bbs, l) {\n\t\t\tstruct edge_node *e, *e2;\n\n\t\t\tlist_for_each_entry_safe(e, e2, &bb->e_prevs, l) {\n\t\t\t\tlist_del(&e->l);\n\t\t\t\tfree(e);\n\t\t\t}\n\n\t\t\tlist_for_each_entry_safe(e, e2, &bb->e_succs, l) {\n\t\t\t\tlist_del(&e->l);\n\t\t\t\tfree(e);\n\t\t\t}\n\n\t\t\tlist_del(&bb->l);\n\t\t\tfree(bb);\n\t\t}\n\n\t\tlist_del(&func->l);\n\t\tfree(func);\n\t}\n}\n\nstatic void\ndraw_bb_node(struct func_node *func, struct bb_node *bb, struct dump_data *dd,\n\t     bool opcodes, bool linum)\n{\n\tconst char *shape;\n\n\tif (bb->idx == ENTRY_BLOCK_INDEX || bb->idx == EXIT_BLOCK_INDEX)\n\t\tshape = \"Mdiamond\";\n\telse\n\t\tshape = \"record\";\n\n\tprintf(\"\\tfn_%d_bb_%d [shape=%s,style=filled,label=\\\"\",\n\t       func->idx, bb->idx, shape);\n\n\tif (bb->idx == ENTRY_BLOCK_INDEX) {\n\t\tprintf(\"ENTRY\");\n\t} else if (bb->idx == EXIT_BLOCK_INDEX) {\n\t\tprintf(\"EXIT\");\n\t} else {\n\t\tunsigned int start_idx;\n\t\tprintf(\"{\\\\\\n\");\n\t\tstart_idx = bb->head - func->start;\n\t\tdump_xlated_for_graph(dd, bb->head, bb->tail, start_idx,\n\t\t\t\t      opcodes, linum);\n\t\tprintf(\"}\");\n\t}\n\n\tprintf(\"\\\"];\\n\\n\");\n}\n\nstatic void draw_bb_succ_edges(struct func_node *func, struct bb_node *bb)\n{\n\tconst char *style = \"\\\"solid,bold\\\"\";\n\tconst char *color = \"black\";\n\tint func_idx = func->idx;\n\tstruct edge_node *e;\n\tint weight = 10;\n\n\tif (list_empty(&bb->e_succs))\n\t\treturn;\n\n\tlist_for_each_entry(e, &bb->e_succs, l) {\n\t\tprintf(\"\\tfn_%d_bb_%d:s -> fn_%d_bb_%d:n [style=%s, color=%s, weight=%d, constraint=true\",\n\t\t       func_idx, e->src->idx, func_idx, e->dst->idx,\n\t\t       style, color, weight);\n\t\tprintf(\"];\\n\");\n\t}\n}\n\nstatic void\nfunc_output_bb_def(struct func_node *func, struct dump_data *dd,\n\t\t   bool opcodes, bool linum)\n{\n\tstruct bb_node *bb;\n\n\tlist_for_each_entry(bb, &func->bbs, l) {\n\t\tdraw_bb_node(func, bb, dd, opcodes, linum);\n\t}\n}\n\nstatic void func_output_edges(struct func_node *func)\n{\n\tint func_idx = func->idx;\n\tstruct bb_node *bb;\n\n\tlist_for_each_entry(bb, &func->bbs, l) {\n\t\tdraw_bb_succ_edges(func, bb);\n\t}\n\n\t \n\tprintf(\"\\tfn_%d_bb_%d:s -> fn_%d_bb_%d:n [style=\\\"invis\\\", constraint=true];\\n\",\n\t       func_idx, ENTRY_BLOCK_INDEX, func_idx, EXIT_BLOCK_INDEX);\n}\n\nstatic void\ncfg_dump(struct cfg *cfg, struct dump_data *dd, bool opcodes, bool linum)\n{\n\tstruct func_node *func;\n\n\tprintf(\"digraph \\\"DOT graph for eBPF program\\\" {\\n\");\n\tlist_for_each_entry(func, &cfg->funcs, l) {\n\t\tprintf(\"subgraph \\\"cluster_%d\\\" {\\n\\tstyle=\\\"dashed\\\";\\n\\tcolor=\\\"black\\\";\\n\\tlabel=\\\"func_%d ()\\\";\\n\",\n\t\t       func->idx, func->idx);\n\t\tfunc_output_bb_def(func, dd, opcodes, linum);\n\t\tfunc_output_edges(func);\n\t\tprintf(\"}\\n\");\n\t}\n\tprintf(\"}\\n\");\n}\n\nvoid dump_xlated_cfg(struct dump_data *dd, void *buf, unsigned int len,\n\t\t     bool opcodes, bool linum)\n{\n\tstruct bpf_insn *insn = buf;\n\tstruct cfg cfg;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tif (cfg_build(&cfg, insn, len))\n\t\treturn;\n\n\tcfg_dump(&cfg, dd, opcodes, linum);\n\n\tcfg_destroy(&cfg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}