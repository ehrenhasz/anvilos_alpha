{
  "module_name": "jit_disasm.c",
  "hash_id": "c1c25248fe07ebedc22a61691cb5d309737598617ff7706366e8a1bafa05abe5",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/jit_disasm.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <limits.h>\n#include <bpf/libbpf.h>\n\n#ifdef HAVE_LLVM_SUPPORT\n#include <llvm-c/Core.h>\n#include <llvm-c/Disassembler.h>\n#include <llvm-c/Target.h>\n#include <llvm-c/TargetMachine.h>\n#endif\n\n#ifdef HAVE_LIBBFD_SUPPORT\n#include <bfd.h>\n#include <dis-asm.h>\n#include <tools/dis-asm-compat.h>\n#endif\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\nstatic int oper_count;\n\n#ifdef HAVE_LLVM_SUPPORT\n#define DISASM_SPACER\n\ntypedef LLVMDisasmContextRef disasm_ctx_t;\n\nstatic int printf_json(char *s)\n{\n\ts = strtok(s, \" \\t\");\n\tjsonw_string_field(json_wtr, \"operation\", s);\n\n\tjsonw_name(json_wtr, \"operands\");\n\tjsonw_start_array(json_wtr);\n\toper_count = 1;\n\n\twhile ((s = strtok(NULL, \" \\t,()\")) != 0) {\n\t\tjsonw_string(json_wtr, s);\n\t\toper_count++;\n\t}\n\treturn 0;\n}\n\n \nstatic const char *\nsymbol_lookup_callback(__maybe_unused void *disasm_info,\n\t\t       __maybe_unused uint64_t ref_value,\n\t\t       uint64_t *ref_type, __maybe_unused uint64_t ref_PC,\n\t\t       __maybe_unused const char **ref_name)\n{\n\t*ref_type = LLVMDisassembler_ReferenceType_InOut_None;\n\treturn NULL;\n}\n\nstatic int\ninit_context(disasm_ctx_t *ctx, const char *arch,\n\t     __maybe_unused const char *disassembler_options,\n\t     __maybe_unused unsigned char *image, __maybe_unused ssize_t len)\n{\n\tchar *triple;\n\n\tif (arch)\n\t\ttriple = LLVMNormalizeTargetTriple(arch);\n\telse\n\t\ttriple = LLVMGetDefaultTargetTriple();\n\tif (!triple) {\n\t\tp_err(\"Failed to retrieve triple\");\n\t\treturn -1;\n\t}\n\t*ctx = LLVMCreateDisasm(triple, NULL, 0, NULL, symbol_lookup_callback);\n\tLLVMDisposeMessage(triple);\n\n\tif (!*ctx) {\n\t\tp_err(\"Failed to create disassembler\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void destroy_context(disasm_ctx_t *ctx)\n{\n\tLLVMDisposeMessage(*ctx);\n}\n\nstatic int\ndisassemble_insn(disasm_ctx_t *ctx, unsigned char *image, ssize_t len, int pc)\n{\n\tchar buf[256];\n\tint count;\n\n\tcount = LLVMDisasmInstruction(*ctx, image + pc, len - pc, pc,\n\t\t\t\t      buf, sizeof(buf));\n\tif (json_output)\n\t\tprintf_json(buf);\n\telse\n\t\tprintf(\"%s\", buf);\n\n\treturn count;\n}\n\nint disasm_init(void)\n{\n\tLLVMInitializeAllTargetInfos();\n\tLLVMInitializeAllTargetMCs();\n\tLLVMInitializeAllDisassemblers();\n\treturn 0;\n}\n#endif  \n\n#ifdef HAVE_LIBBFD_SUPPORT\n#define DISASM_SPACER \"\\t\"\n\ntypedef struct {\n\tstruct disassemble_info *info;\n\tdisassembler_ftype disassemble;\n\tbfd *bfdf;\n} disasm_ctx_t;\n\nstatic int get_exec_path(char *tpath, size_t size)\n{\n\tconst char *path = \"/proc/self/exe\";\n\tssize_t len;\n\n\tlen = readlink(path, tpath, size - 1);\n\tif (len <= 0)\n\t\treturn -1;\n\n\ttpath[len] = 0;\n\n\treturn 0;\n}\n\nstatic int printf_json(void *out, const char *fmt, va_list ap)\n{\n\tchar *s;\n\tint err;\n\n\terr = vasprintf(&s, fmt, ap);\n\tif (err < 0)\n\t\treturn -1;\n\n\tif (!oper_count) {\n\t\tint i;\n\n\t\t \n\t\ti = strlen(s) - 1;\n\t\twhile (s[i] == ' ')\n\t\t\ts[i--] = '\\0';\n\n\t\tjsonw_string_field(json_wtr, \"operation\", s);\n\t\tjsonw_name(json_wtr, \"operands\");\n\t\tjsonw_start_array(json_wtr);\n\t\toper_count++;\n\t} else if (!strcmp(fmt, \",\")) {\n\t\t    \n\t} else {\n\t\tjsonw_string(json_wtr, s);\n\t\toper_count++;\n\t}\n\tfree(s);\n\treturn 0;\n}\n\nstatic int fprintf_json(void *out, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = printf_json(out, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}\n\nstatic int fprintf_json_styled(void *out,\n\t\t\t       enum disassembler_style style __maybe_unused,\n\t\t\t       const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = printf_json(out, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}\n\nstatic int init_context(disasm_ctx_t *ctx, const char *arch,\n\t\t\tconst char *disassembler_options,\n\t\t\tunsigned char *image, ssize_t len)\n{\n\tstruct disassemble_info *info;\n\tchar tpath[PATH_MAX];\n\tbfd *bfdf;\n\n\tmemset(tpath, 0, sizeof(tpath));\n\tif (get_exec_path(tpath, sizeof(tpath))) {\n\t\tp_err(\"failed to create disassembler (get_exec_path)\");\n\t\treturn -1;\n\t}\n\n\tctx->bfdf = bfd_openr(tpath, NULL);\n\tif (!ctx->bfdf) {\n\t\tp_err(\"failed to create disassembler (bfd_openr)\");\n\t\treturn -1;\n\t}\n\tif (!bfd_check_format(ctx->bfdf, bfd_object)) {\n\t\tp_err(\"failed to create disassembler (bfd_check_format)\");\n\t\tgoto err_close;\n\t}\n\tbfdf = ctx->bfdf;\n\n\tctx->info = malloc(sizeof(struct disassemble_info));\n\tif (!ctx->info) {\n\t\tp_err(\"mem alloc failed\");\n\t\tgoto err_close;\n\t}\n\tinfo = ctx->info;\n\n\tif (json_output)\n\t\tinit_disassemble_info_compat(info, stdout,\n\t\t\t\t\t     (fprintf_ftype) fprintf_json,\n\t\t\t\t\t     fprintf_json_styled);\n\telse\n\t\tinit_disassemble_info_compat(info, stdout,\n\t\t\t\t\t     (fprintf_ftype) fprintf,\n\t\t\t\t\t     fprintf_styled);\n\n\t \n\tif (arch) {\n\t\tconst bfd_arch_info_type *inf = bfd_scan_arch(arch);\n\n\t\tif (inf) {\n\t\t\tbfdf->arch_info = inf;\n\t\t} else {\n\t\t\tp_err(\"No libbfd support for %s\", arch);\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tinfo->arch = bfd_get_arch(bfdf);\n\tinfo->mach = bfd_get_mach(bfdf);\n\tif (disassembler_options)\n\t\tinfo->disassembler_options = disassembler_options;\n\tinfo->buffer = image;\n\tinfo->buffer_length = len;\n\n\tdisassemble_init_for_target(info);\n\n#ifdef DISASM_FOUR_ARGS_SIGNATURE\n\tctx->disassemble = disassembler(info->arch,\n\t\t\t\t\tbfd_big_endian(bfdf),\n\t\t\t\t\tinfo->mach,\n\t\t\t\t\tbfdf);\n#else\n\tctx->disassemble = disassembler(bfdf);\n#endif\n\tif (!ctx->disassemble) {\n\t\tp_err(\"failed to create disassembler\");\n\t\tgoto err_free;\n\t}\n\treturn 0;\n\nerr_free:\n\tfree(info);\nerr_close:\n\tbfd_close(ctx->bfdf);\n\treturn -1;\n}\n\nstatic void destroy_context(disasm_ctx_t *ctx)\n{\n\tfree(ctx->info);\n\tbfd_close(ctx->bfdf);\n}\n\nstatic int\ndisassemble_insn(disasm_ctx_t *ctx, __maybe_unused unsigned char *image,\n\t\t __maybe_unused ssize_t len, int pc)\n{\n\treturn ctx->disassemble(pc, ctx->info);\n}\n\nint disasm_init(void)\n{\n\tbfd_init();\n\treturn 0;\n}\n#endif  \n\nint disasm_print_insn(unsigned char *image, ssize_t len, int opcodes,\n\t\t      const char *arch, const char *disassembler_options,\n\t\t      const struct btf *btf,\n\t\t      const struct bpf_prog_linfo *prog_linfo,\n\t\t      __u64 func_ksym, unsigned int func_idx,\n\t\t      bool linum)\n{\n\tconst struct bpf_line_info *linfo = NULL;\n\tunsigned int nr_skip = 0;\n\tint count, i, pc = 0;\n\tdisasm_ctx_t ctx;\n\n\tif (!len)\n\t\treturn -1;\n\n\tif (init_context(&ctx, arch, disassembler_options, image, len))\n\t\treturn -1;\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\tdo {\n\t\tif (prog_linfo) {\n\t\t\tlinfo = bpf_prog_linfo__lfind_addr_func(prog_linfo,\n\t\t\t\t\t\t\t\tfunc_ksym + pc,\n\t\t\t\t\t\t\t\tfunc_idx,\n\t\t\t\t\t\t\t\tnr_skip);\n\t\t\tif (linfo)\n\t\t\t\tnr_skip++;\n\t\t}\n\n\t\tif (json_output) {\n\t\t\tjsonw_start_object(json_wtr);\n\t\t\toper_count = 0;\n\t\t\tif (linfo)\n\t\t\t\tbtf_dump_linfo_json(btf, linfo, linum);\n\t\t\tjsonw_name(json_wtr, \"pc\");\n\t\t\tjsonw_printf(json_wtr, \"\\\"0x%x\\\"\", pc);\n\t\t} else {\n\t\t\tif (linfo)\n\t\t\t\tbtf_dump_linfo_plain(btf, linfo, \"; \",\n\t\t\t\t\t\t     linum);\n\t\t\tprintf(\"%4x:\" DISASM_SPACER, pc);\n\t\t}\n\n\t\tcount = disassemble_insn(&ctx, image, len, pc);\n\n\t\tif (json_output) {\n\t\t\t \n\t\t\tif (oper_count == 1)\n\t\t\t\tjsonw_null(json_wtr);\n\t\t\tjsonw_end_array(json_wtr);\n\t\t}\n\n\t\tif (opcodes) {\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_name(json_wtr, \"opcodes\");\n\t\t\t\tjsonw_start_array(json_wtr);\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\tjsonw_printf(json_wtr, \"\\\"0x%02hhx\\\"\",\n\t\t\t\t\t\t     (uint8_t)image[pc + i]);\n\t\t\t\tjsonw_end_array(json_wtr);\n\t\t\t} else {\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\tprintf(\"%02x \",\n\t\t\t\t\t       (uint8_t)image[pc + i]);\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_object(json_wtr);\n\t\telse\n\t\t\tprintf(\"\\n\");\n\n\t\tpc += count;\n\t} while (count > 0 && pc < len);\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tdestroy_context(&ctx);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}