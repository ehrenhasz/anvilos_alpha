{
  "module_name": "xlated_dumper.c",
  "hash_id": "7f84d1a29d862d0fac7e0eabdc977bab83fc4d7a84ff409c1f17531b5f109eb2",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/xlated_dumper.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <bpf/libbpf.h>\n#include <bpf/libbpf_internal.h>\n\n#include \"disasm.h\"\n#include \"json_writer.h\"\n#include \"main.h\"\n#include \"xlated_dumper.h\"\n\nstatic int kernel_syms_cmp(const void *sym_a, const void *sym_b)\n{\n\treturn ((struct kernel_sym *)sym_a)->address -\n\t       ((struct kernel_sym *)sym_b)->address;\n}\n\nvoid kernel_syms_load(struct dump_data *dd)\n{\n\tstruct kernel_sym *sym;\n\tchar buff[256];\n\tvoid *tmp, *address;\n\tFILE *fp;\n\n\tfp = fopen(\"/proc/kallsyms\", \"r\");\n\tif (!fp)\n\t\treturn;\n\n\twhile (fgets(buff, sizeof(buff), fp)) {\n\t\ttmp = libbpf_reallocarray(dd->sym_mapping, dd->sym_count + 1,\n\t\t\t\t\t  sizeof(*dd->sym_mapping));\n\t\tif (!tmp) {\nout:\n\t\t\tfree(dd->sym_mapping);\n\t\t\tdd->sym_mapping = NULL;\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t\tdd->sym_mapping = tmp;\n\t\tsym = &dd->sym_mapping[dd->sym_count];\n\n\t\t \n\t\tsym->module[0] = '\\0';\n\t\t \n\t\tif (sscanf(buff, \"%p %*c %s [%[^]]s\", &address, sym->name, sym->module) < 2)\n\t\t\tcontinue;\n\t\tsym->address = (unsigned long)address;\n\t\tif (!strcmp(sym->name, \"__bpf_call_base\")) {\n\t\t\tdd->address_call_base = sym->address;\n\t\t\t \n\t\t\tif (!sym->address)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (sym->address)\n\t\t\tdd->sym_count++;\n\t}\n\n\tfclose(fp);\n\n\tqsort(dd->sym_mapping, dd->sym_count,\n\t      sizeof(*dd->sym_mapping), kernel_syms_cmp);\n}\n\nvoid kernel_syms_destroy(struct dump_data *dd)\n{\n\tfree(dd->sym_mapping);\n}\n\nstruct kernel_sym *kernel_syms_search(struct dump_data *dd,\n\t\t\t\t      unsigned long key)\n{\n\tstruct kernel_sym sym = {\n\t\t.address = key,\n\t};\n\n\treturn dd->sym_mapping ?\n\t       bsearch(&sym, dd->sym_mapping, dd->sym_count,\n\t\t       sizeof(*dd->sym_mapping), kernel_syms_cmp) : NULL;\n}\n\nstatic void __printf(2, 3) print_insn(void *private_data, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvprintf(fmt, args);\n\tva_end(args);\n}\n\nstatic void __printf(2, 3)\nprint_insn_for_graph(void *private_data, const char *fmt, ...)\n{\n\tchar buf[64], *p;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tp = buf;\n\twhile (*p != '\\0') {\n\t\tif (*p == '\\n') {\n\t\t\tmemmove(p + 3, p, strlen(buf) + 1 - (p - buf));\n\t\t\t \n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = 'l';\n\t\t\t \n\t\t\t*p++ = '\\\\';\n\t\t} else if (*p == '<' || *p == '>' || *p == '|' || *p == '&') {\n\t\t\tmemmove(p + 1, p, strlen(buf) + 1 - (p - buf));\n\t\t\t \n\t\t\t*p++ = '\\\\';\n\t\t}\n\n\t\tp++;\n\t}\n\n\tprintf(\"%s\", buf);\n}\n\nstatic void __printf(2, 3)\nprint_insn_json(void *private_data, const char *fmt, ...)\n{\n\tunsigned int l = strlen(fmt);\n\tchar chomped_fmt[l];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tif (l > 0) {\n\t\tstrncpy(chomped_fmt, fmt, l - 1);\n\t\tchomped_fmt[l - 1] = '\\0';\n\t}\n\tjsonw_vprintf_enquote(json_wtr, chomped_fmt, args);\n\tva_end(args);\n}\n\nstatic const char *print_call_pcrel(struct dump_data *dd,\n\t\t\t\t    struct kernel_sym *sym,\n\t\t\t\t    unsigned long address,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\tif (!dd->nr_jited_ksyms)\n\t\t \n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t\"%+d\", insn->off);\n\telse if (sym)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"%+d#%s\", insn->off, sym->name);\n\telse\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"%+d#0x%lx\", insn->off, address);\n\treturn dd->scratch_buff;\n}\n\nstatic const char *print_call_helper(struct dump_data *dd,\n\t\t\t\t     struct kernel_sym *sym,\n\t\t\t\t     unsigned long address)\n{\n\tif (sym)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"%s\", sym->name);\n\telse\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"0x%lx\", address);\n\treturn dd->scratch_buff;\n}\n\nstatic const char *print_call(void *private_data,\n\t\t\t      const struct bpf_insn *insn)\n{\n\tstruct dump_data *dd = private_data;\n\tunsigned long address = dd->address_call_base + insn->imm;\n\tstruct kernel_sym *sym;\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL &&\n\t    (__u32) insn->imm < dd->nr_jited_ksyms && dd->jited_ksyms)\n\t\taddress = dd->jited_ksyms[insn->imm];\n\n\tsym = kernel_syms_search(dd, address);\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\treturn print_call_pcrel(dd, sym, address, insn);\n\telse\n\t\treturn print_call_helper(dd, sym, address);\n}\n\nstatic const char *print_imm(void *private_data,\n\t\t\t     const struct bpf_insn *insn,\n\t\t\t     __u64 full_imm)\n{\n\tstruct dump_data *dd = private_data;\n\n\tif (insn->src_reg == BPF_PSEUDO_MAP_FD)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"map[id:%u]\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_MAP_VALUE)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"map[id:%u][0]+%u\", insn->imm, (insn + 1)->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_MAP_IDX_VALUE)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"map[idx:%u]+%u\", insn->imm, (insn + 1)->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_FUNC)\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"subprog[%+d]\", insn->imm);\n\telse\n\t\tsnprintf(dd->scratch_buff, sizeof(dd->scratch_buff),\n\t\t\t \"0x%llx\", (unsigned long long)full_imm);\n\treturn dd->scratch_buff;\n}\n\nvoid dump_xlated_json(struct dump_data *dd, void *buf, unsigned int len,\n\t\t      bool opcodes, bool linum)\n{\n\tconst struct bpf_prog_linfo *prog_linfo = dd->prog_linfo;\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_print\t= print_insn_json,\n\t\t.cb_call\t= print_call,\n\t\t.cb_imm\t\t= print_imm,\n\t\t.private_data\t= dd,\n\t};\n\tstruct bpf_func_info *record;\n\tstruct bpf_insn *insn = buf;\n\tstruct btf *btf = dd->btf;\n\tbool double_insn = false;\n\tunsigned int nr_skip = 0;\n\tchar func_sig[1024];\n\tunsigned int i;\n\n\tjsonw_start_array(json_wtr);\n\trecord = dd->func_info;\n\tfor (i = 0; i < len / sizeof(*insn); i++) {\n\t\tif (double_insn) {\n\t\t\tdouble_insn = false;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble_insn = insn[i].code == (BPF_LD | BPF_IMM | BPF_DW);\n\n\t\tjsonw_start_object(json_wtr);\n\n\t\tif (btf && record) {\n\t\t\tif (record->insn_off == i) {\n\t\t\t\tbtf_dumper_type_only(btf, record->type_id,\n\t\t\t\t\t\t     func_sig,\n\t\t\t\t\t\t     sizeof(func_sig));\n\t\t\t\tif (func_sig[0] != '\\0') {\n\t\t\t\t\tjsonw_name(json_wtr, \"proto\");\n\t\t\t\t\tjsonw_string(json_wtr, func_sig);\n\t\t\t\t}\n\t\t\t\trecord = (void *)record + dd->finfo_rec_size;\n\t\t\t}\n\t\t}\n\n\t\tif (prog_linfo) {\n\t\t\tconst struct bpf_line_info *linfo;\n\n\t\t\tlinfo = bpf_prog_linfo__lfind(prog_linfo, i, nr_skip);\n\t\t\tif (linfo) {\n\t\t\t\tbtf_dump_linfo_json(btf, linfo, linum);\n\t\t\t\tnr_skip++;\n\t\t\t}\n\t\t}\n\n\t\tjsonw_name(json_wtr, \"disasm\");\n\t\tprint_bpf_insn(&cbs, insn + i, true);\n\n\t\tif (opcodes) {\n\t\t\tjsonw_name(json_wtr, \"opcodes\");\n\t\t\tjsonw_start_object(json_wtr);\n\n\t\t\tjsonw_name(json_wtr, \"code\");\n\t\t\tjsonw_printf(json_wtr, \"\\\"0x%02hhx\\\"\", insn[i].code);\n\n\t\t\tjsonw_name(json_wtr, \"src_reg\");\n\t\t\tjsonw_printf(json_wtr, \"\\\"0x%hhx\\\"\", insn[i].src_reg);\n\n\t\t\tjsonw_name(json_wtr, \"dst_reg\");\n\t\t\tjsonw_printf(json_wtr, \"\\\"0x%hhx\\\"\", insn[i].dst_reg);\n\n\t\t\tjsonw_name(json_wtr, \"off\");\n\t\t\tprint_hex_data_json((uint8_t *)(&insn[i].off), 2);\n\n\t\t\tjsonw_name(json_wtr, \"imm\");\n\t\t\tif (double_insn && i < len - 1)\n\t\t\t\tprint_hex_data_json((uint8_t *)(&insn[i].imm),\n\t\t\t\t\t\t    12);\n\t\t\telse\n\t\t\t\tprint_hex_data_json((uint8_t *)(&insn[i].imm),\n\t\t\t\t\t\t    4);\n\t\t\tjsonw_end_object(json_wtr);\n\t\t}\n\t\tjsonw_end_object(json_wtr);\n\t}\n\tjsonw_end_array(json_wtr);\n}\n\nvoid dump_xlated_plain(struct dump_data *dd, void *buf, unsigned int len,\n\t\t       bool opcodes, bool linum)\n{\n\tconst struct bpf_prog_linfo *prog_linfo = dd->prog_linfo;\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_print\t= print_insn,\n\t\t.cb_call\t= print_call,\n\t\t.cb_imm\t\t= print_imm,\n\t\t.private_data\t= dd,\n\t};\n\tstruct bpf_func_info *record;\n\tstruct bpf_insn *insn = buf;\n\tstruct btf *btf = dd->btf;\n\tunsigned int nr_skip = 0;\n\tbool double_insn = false;\n\tchar func_sig[1024];\n\tunsigned int i;\n\n\trecord = dd->func_info;\n\tfor (i = 0; i < len / sizeof(*insn); i++) {\n\t\tif (double_insn) {\n\t\t\tdouble_insn = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (btf && record) {\n\t\t\tif (record->insn_off == i) {\n\t\t\t\tbtf_dumper_type_only(btf, record->type_id,\n\t\t\t\t\t\t     func_sig,\n\t\t\t\t\t\t     sizeof(func_sig));\n\t\t\t\tif (func_sig[0] != '\\0')\n\t\t\t\t\tprintf(\"%s:\\n\", func_sig);\n\t\t\t\trecord = (void *)record + dd->finfo_rec_size;\n\t\t\t}\n\t\t}\n\n\t\tif (prog_linfo) {\n\t\t\tconst struct bpf_line_info *linfo;\n\n\t\t\tlinfo = bpf_prog_linfo__lfind(prog_linfo, i, nr_skip);\n\t\t\tif (linfo) {\n\t\t\t\tbtf_dump_linfo_plain(btf, linfo, \"; \",\n\t\t\t\t\t\t     linum);\n\t\t\t\tnr_skip++;\n\t\t\t}\n\t\t}\n\n\t\tdouble_insn = insn[i].code == (BPF_LD | BPF_IMM | BPF_DW);\n\n\t\tprintf(\"% 4d: \", i);\n\t\tprint_bpf_insn(&cbs, insn + i, true);\n\n\t\tif (opcodes) {\n\t\t\tprintf(\"       \");\n\t\t\tfprint_hex(stdout, insn + i, 8, \" \");\n\t\t\tif (double_insn && i < len - 1) {\n\t\t\t\tprintf(\" \");\n\t\t\t\tfprint_hex(stdout, insn + i + 1, 8, \" \");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nvoid dump_xlated_for_graph(struct dump_data *dd, void *buf_start, void *buf_end,\n\t\t\t   unsigned int start_idx,\n\t\t\t   bool opcodes, bool linum)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_print\t= print_insn_for_graph,\n\t\t.cb_call\t= print_call,\n\t\t.cb_imm\t\t= print_imm,\n\t\t.private_data\t= dd,\n\t};\n\tconst struct bpf_prog_linfo *prog_linfo = dd->prog_linfo;\n\tconst struct bpf_line_info *last_linfo = NULL;\n\tstruct bpf_func_info *record = dd->func_info;\n\tstruct bpf_insn *insn_start = buf_start;\n\tstruct bpf_insn *insn_end = buf_end;\n\tstruct bpf_insn *cur = insn_start;\n\tstruct btf *btf = dd->btf;\n\tbool double_insn = false;\n\tchar func_sig[1024];\n\n\tfor (; cur <= insn_end; cur++) {\n\t\tunsigned int insn_off;\n\n\t\tif (double_insn) {\n\t\t\tdouble_insn = false;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble_insn = cur->code == (BPF_LD | BPF_IMM | BPF_DW);\n\n\t\tinsn_off = (unsigned int)(cur - insn_start + start_idx);\n\t\tif (btf && record) {\n\t\t\tif (record->insn_off == insn_off) {\n\t\t\t\tbtf_dumper_type_only(btf, record->type_id,\n\t\t\t\t\t\t     func_sig,\n\t\t\t\t\t\t     sizeof(func_sig));\n\t\t\t\tif (func_sig[0] != '\\0')\n\t\t\t\t\tprintf(\"; %s:\\\\l\\\\\\n\", func_sig);\n\t\t\t\trecord = (void *)record + dd->finfo_rec_size;\n\t\t\t}\n\t\t}\n\n\t\tif (prog_linfo) {\n\t\t\tconst struct bpf_line_info *linfo;\n\n\t\t\tlinfo = bpf_prog_linfo__lfind(prog_linfo, insn_off, 0);\n\t\t\tif (linfo && linfo != last_linfo) {\n\t\t\t\tbtf_dump_linfo_dotlabel(btf, linfo, linum);\n\t\t\t\tlast_linfo = linfo;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d: \", insn_off);\n\t\tprint_bpf_insn(&cbs, cur, true);\n\n\t\tif (opcodes) {\n\t\t\tprintf(\"\\\\ \\\\ \\\\ \\\\ \");\n\t\t\tfprint_hex(stdout, cur, 8, \" \");\n\t\t\tif (double_insn && cur <= insn_end - 1) {\n\t\t\t\tprintf(\" \");\n\t\t\t\tfprint_hex(stdout, cur + 1, 8, \" \");\n\t\t\t}\n\t\t\tprintf(\"\\\\l\\\\\\n\");\n\t\t}\n\n\t\tif (cur != insn_end)\n\t\t\tprintf(\"| \");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}