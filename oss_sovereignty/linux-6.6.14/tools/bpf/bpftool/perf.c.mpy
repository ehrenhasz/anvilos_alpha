{
  "module_name": "perf.c",
  "hash_id": "d7281232275cede55e8fd721e8c164085e10c2a0d272364f1016b5f5354a4baf",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/perf.c",
  "human_readable_source": "\n\n\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <dirent.h>\n\n#include <bpf/bpf.h>\n\n#include \"main.h\"\n\n \nstatic int perf_query_supported;\nstatic bool has_perf_query_support(void)\n{\n\t__u64 probe_offset, probe_addr;\n\t__u32 len, prog_id, fd_type;\n\tchar buf[256];\n\tint fd;\n\n\tif (perf_query_supported)\n\t\tgoto out;\n\n\tfd = open(\"/\", O_RDONLY);\n\tif (fd < 0) {\n\t\tp_err(\"perf_query_support: cannot open directory \\\"/\\\" (%s)\",\n\t\t      strerror(errno));\n\t\tgoto out;\n\t}\n\n\t \n\terrno = 0;\n\tlen = sizeof(buf);\n\tbpf_task_fd_query(getpid(), fd, 0, buf, &len, &prog_id,\n\t\t\t  &fd_type, &probe_offset, &probe_addr);\n\n\tif (errno == 524  ) {\n\t\tperf_query_supported = 1;\n\t\tgoto close_fd;\n\t}\n\n\tperf_query_supported = 2;\n\tp_err(\"perf_query_support: %s\", strerror(errno));\n\tfprintf(stderr,\n\t\t\"HINT: non root or kernel doesn't support TASK_FD_QUERY\\n\");\n\nclose_fd:\n\tclose(fd);\nout:\n\treturn perf_query_supported == 1;\n}\n\nstatic void print_perf_json(int pid, int fd, __u32 prog_id, __u32 fd_type,\n\t\t\t    char *buf, __u64 probe_offset, __u64 probe_addr)\n{\n\tjsonw_start_object(json_wtr);\n\tjsonw_int_field(json_wtr, \"pid\", pid);\n\tjsonw_int_field(json_wtr, \"fd\", fd);\n\tjsonw_uint_field(json_wtr, \"prog_id\", prog_id);\n\tswitch (fd_type) {\n\tcase BPF_FD_TYPE_RAW_TRACEPOINT:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"raw_tracepoint\");\n\t\tjsonw_string_field(json_wtr, \"tracepoint\", buf);\n\t\tbreak;\n\tcase BPF_FD_TYPE_TRACEPOINT:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"tracepoint\");\n\t\tjsonw_string_field(json_wtr, \"tracepoint\", buf);\n\t\tbreak;\n\tcase BPF_FD_TYPE_KPROBE:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"kprobe\");\n\t\tif (buf[0] != '\\0') {\n\t\t\tjsonw_string_field(json_wtr, \"func\", buf);\n\t\t\tjsonw_lluint_field(json_wtr, \"offset\", probe_offset);\n\t\t} else {\n\t\t\tjsonw_lluint_field(json_wtr, \"addr\", probe_addr);\n\t\t}\n\t\tbreak;\n\tcase BPF_FD_TYPE_KRETPROBE:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"kretprobe\");\n\t\tif (buf[0] != '\\0') {\n\t\t\tjsonw_string_field(json_wtr, \"func\", buf);\n\t\t\tjsonw_lluint_field(json_wtr, \"offset\", probe_offset);\n\t\t} else {\n\t\t\tjsonw_lluint_field(json_wtr, \"addr\", probe_addr);\n\t\t}\n\t\tbreak;\n\tcase BPF_FD_TYPE_UPROBE:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"uprobe\");\n\t\tjsonw_string_field(json_wtr, \"filename\", buf);\n\t\tjsonw_lluint_field(json_wtr, \"offset\", probe_offset);\n\t\tbreak;\n\tcase BPF_FD_TYPE_URETPROBE:\n\t\tjsonw_string_field(json_wtr, \"fd_type\", \"uretprobe\");\n\t\tjsonw_string_field(json_wtr, \"filename\", buf);\n\t\tjsonw_lluint_field(json_wtr, \"offset\", probe_offset);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tjsonw_end_object(json_wtr);\n}\n\nstatic void print_perf_plain(int pid, int fd, __u32 prog_id, __u32 fd_type,\n\t\t\t     char *buf, __u64 probe_offset, __u64 probe_addr)\n{\n\tprintf(\"pid %d  fd %d: prog_id %u  \", pid, fd, prog_id);\n\tswitch (fd_type) {\n\tcase BPF_FD_TYPE_RAW_TRACEPOINT:\n\t\tprintf(\"raw_tracepoint  %s\\n\", buf);\n\t\tbreak;\n\tcase BPF_FD_TYPE_TRACEPOINT:\n\t\tprintf(\"tracepoint  %s\\n\", buf);\n\t\tbreak;\n\tcase BPF_FD_TYPE_KPROBE:\n\t\tif (buf[0] != '\\0')\n\t\t\tprintf(\"kprobe  func %s  offset %llu\\n\", buf,\n\t\t\t       probe_offset);\n\t\telse\n\t\t\tprintf(\"kprobe  addr %llu\\n\", probe_addr);\n\t\tbreak;\n\tcase BPF_FD_TYPE_KRETPROBE:\n\t\tif (buf[0] != '\\0')\n\t\t\tprintf(\"kretprobe  func %s  offset %llu\\n\", buf,\n\t\t\t       probe_offset);\n\t\telse\n\t\t\tprintf(\"kretprobe  addr %llu\\n\", probe_addr);\n\t\tbreak;\n\tcase BPF_FD_TYPE_UPROBE:\n\t\tprintf(\"uprobe  filename %s  offset %llu\\n\", buf, probe_offset);\n\t\tbreak;\n\tcase BPF_FD_TYPE_URETPROBE:\n\t\tprintf(\"uretprobe  filename %s  offset %llu\\n\", buf,\n\t\t       probe_offset);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int show_proc(void)\n{\n\tstruct dirent *proc_de, *pid_fd_de;\n\t__u64 probe_offset, probe_addr;\n\t__u32 len, prog_id, fd_type;\n\tDIR *proc, *pid_fd;\n\tint err, pid, fd;\n\tconst char *pch;\n\tchar buf[4096];\n\n\tproc = opendir(\"/proc\");\n\tif (!proc)\n\t\treturn -1;\n\n\twhile ((proc_de = readdir(proc))) {\n\t\tpid = 0;\n\t\tpch = proc_de->d_name;\n\n\t\t \n\t\twhile (isdigit(*pch)) {\n\t\t\tpid = pid * 10 + *pch - '0';\n\t\t\tpch++;\n\t\t}\n\t\tif (*pch != '\\0')\n\t\t\tcontinue;\n\n\t\terr = snprintf(buf, sizeof(buf), \"/proc/%s/fd\", proc_de->d_name);\n\t\tif (err < 0 || err >= (int)sizeof(buf))\n\t\t\tcontinue;\n\n\t\tpid_fd = opendir(buf);\n\t\tif (!pid_fd)\n\t\t\tcontinue;\n\n\t\twhile ((pid_fd_de = readdir(pid_fd))) {\n\t\t\tfd = 0;\n\t\t\tpch = pid_fd_de->d_name;\n\n\t\t\t \n\t\t\twhile (isdigit(*pch)) {\n\t\t\t\tfd = fd * 10 + *pch - '0';\n\t\t\t\tpch++;\n\t\t\t}\n\t\t\tif (*pch != '\\0')\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tlen = sizeof(buf);\n\t\t\terr = bpf_task_fd_query(pid, fd, 0, buf, &len,\n\t\t\t\t\t\t&prog_id, &fd_type,\n\t\t\t\t\t\t&probe_offset, &probe_addr);\n\t\t\tif (err < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (json_output)\n\t\t\t\tprint_perf_json(pid, fd, prog_id, fd_type, buf,\n\t\t\t\t\t\tprobe_offset, probe_addr);\n\t\t\telse\n\t\t\t\tprint_perf_plain(pid, fd, prog_id, fd_type, buf,\n\t\t\t\t\t\t probe_offset, probe_addr);\n\t\t}\n\t\tclosedir(pid_fd);\n\t}\n\tclosedir(proc);\n\treturn 0;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tint err;\n\n\tif (!has_perf_query_support())\n\t\treturn -1;\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\terr = show_proc();\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\treturn err;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list }\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"help\",\tdo_help },\n\t{ 0 }\n};\n\nint do_perf(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}