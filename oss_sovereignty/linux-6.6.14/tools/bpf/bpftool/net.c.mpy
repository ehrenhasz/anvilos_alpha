{
  "module_name": "net.c",
  "hash_id": "29a51ad8dfce7fee7edf43a2e9a54c134b05f05a2507818cf68fe9537298d16f",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/net.c",
  "human_readable_source": "\n\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <net/if.h>\n#include <linux/rtnetlink.h>\n#include <linux/socket.h>\n#include <linux/tc_act/tc_bpf.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"bpf/nlattr.h\"\n#include \"main.h\"\n#include \"netlink_dumper.h\"\n\n#ifndef SOL_NETLINK\n#define SOL_NETLINK 270\n#endif\n\nstruct ip_devname_ifindex {\n\tchar\tdevname[64];\n\tint\tifindex;\n};\n\nstruct bpf_netdev_t {\n\tstruct ip_devname_ifindex *devices;\n\tint\tused_len;\n\tint\tarray_len;\n\tint\tfilter_idx;\n};\n\nstruct tc_kind_handle {\n\tchar\tkind[64];\n\tint\thandle;\n};\n\nstruct bpf_tcinfo_t {\n\tstruct tc_kind_handle\t*handle_array;\n\tint\t\t\tused_len;\n\tint\t\t\tarray_len;\n\tbool\t\t\tis_qdisc;\n};\n\nstruct bpf_filter_t {\n\tconst char\t*kind;\n\tconst char\t*devname;\n\tint\t\tifindex;\n};\n\nstruct bpf_attach_info {\n\t__u32 flow_dissector_id;\n};\n\nenum net_attach_type {\n\tNET_ATTACH_TYPE_XDP,\n\tNET_ATTACH_TYPE_XDP_GENERIC,\n\tNET_ATTACH_TYPE_XDP_DRIVER,\n\tNET_ATTACH_TYPE_XDP_OFFLOAD,\n};\n\nstatic const char * const attach_type_strings[] = {\n\t[NET_ATTACH_TYPE_XDP]\t\t= \"xdp\",\n\t[NET_ATTACH_TYPE_XDP_GENERIC]\t= \"xdpgeneric\",\n\t[NET_ATTACH_TYPE_XDP_DRIVER]\t= \"xdpdrv\",\n\t[NET_ATTACH_TYPE_XDP_OFFLOAD]\t= \"xdpoffload\",\n};\n\nstatic const char * const attach_loc_strings[] = {\n\t[BPF_TCX_INGRESS]\t\t= \"tcx/ingress\",\n\t[BPF_TCX_EGRESS]\t\t= \"tcx/egress\",\n};\n\nconst size_t net_attach_type_size = ARRAY_SIZE(attach_type_strings);\n\nstatic enum net_attach_type parse_attach_type(const char *str)\n{\n\tenum net_attach_type type;\n\n\tfor (type = 0; type < net_attach_type_size; type++) {\n\t\tif (attach_type_strings[type] &&\n\t\t    is_prefix(str, attach_type_strings[type]))\n\t\t\treturn type;\n\t}\n\n\treturn net_attach_type_size;\n}\n\ntypedef int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);\n\ntypedef int (*__dump_nlmsg_t)(struct nlmsghdr *nlmsg, dump_nlmsg_t, void *cookie);\n\nstatic int netlink_open(__u32 *nl_pid)\n{\n\tstruct sockaddr_nl sa;\n\tsocklen_t addrlen;\n\tint one = 1, ret;\n\tint sock;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.nl_family = AF_NETLINK;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (sock < 0)\n\t\treturn -errno;\n\n\tif (setsockopt(sock, SOL_NETLINK, NETLINK_EXT_ACK,\n\t\t       &one, sizeof(one)) < 0) {\n\t\tp_err(\"Netlink error reporting not supported\");\n\t}\n\n\tif (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\n\taddrlen = sizeof(sa);\n\tif (getsockname(sock, (struct sockaddr *)&sa, &addrlen) < 0) {\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\n\tif (addrlen != sizeof(sa)) {\n\t\tret = -LIBBPF_ERRNO__INTERNAL;\n\t\tgoto cleanup;\n\t}\n\n\t*nl_pid = sa.nl_pid;\n\treturn sock;\n\ncleanup:\n\tclose(sock);\n\treturn ret;\n}\n\nstatic int netlink_recv(int sock, __u32 nl_pid, __u32 seq,\n\t\t\t    __dump_nlmsg_t _fn, dump_nlmsg_t fn,\n\t\t\t    void *cookie)\n{\n\tbool multipart = true;\n\tstruct nlmsgerr *err;\n\tstruct nlmsghdr *nh;\n\tchar buf[4096];\n\tint len, ret;\n\n\twhile (multipart) {\n\t\tmultipart = false;\n\t\tlen = recv(sock, buf, sizeof(buf), 0);\n\t\tif (len < 0) {\n\t\t\tret = -errno;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tfor (nh = (struct nlmsghdr *)buf; NLMSG_OK(nh, (unsigned int)len);\n\t\t     nh = NLMSG_NEXT(nh, len)) {\n\t\t\tif (nh->nlmsg_pid != nl_pid) {\n\t\t\t\tret = -LIBBPF_ERRNO__WRNGPID;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (nh->nlmsg_seq != seq) {\n\t\t\t\tret = -LIBBPF_ERRNO__INVSEQ;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (nh->nlmsg_flags & NLM_F_MULTI)\n\t\t\t\tmultipart = true;\n\t\t\tswitch (nh->nlmsg_type) {\n\t\t\tcase NLMSG_ERROR:\n\t\t\t\terr = (struct nlmsgerr *)NLMSG_DATA(nh);\n\t\t\t\tif (!err->error)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = err->error;\n\t\t\t\tlibbpf_nla_dump_errormsg(nh);\n\t\t\t\tgoto done;\n\t\t\tcase NLMSG_DONE:\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_fn) {\n\t\t\t\tret = _fn(nh, fn, cookie);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\ndone:\n\treturn ret;\n}\n\nstatic int __dump_class_nlmsg(struct nlmsghdr *nlh,\n\t\t\t      dump_nlmsg_t dump_class_nlmsg,\n\t\t\t      void *cookie)\n{\n\tstruct nlattr *tb[TCA_MAX + 1], *attr;\n\tstruct tcmsg *t = NLMSG_DATA(nlh);\n\tint len;\n\n\tlen = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*t));\n\tattr = (struct nlattr *) ((void *) t + NLMSG_ALIGN(sizeof(*t)));\n\tif (libbpf_nla_parse(tb, TCA_MAX, attr, len, NULL) != 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\treturn dump_class_nlmsg(cookie, t, tb);\n}\n\nstatic int netlink_get_class(int sock, unsigned int nl_pid, int ifindex,\n\t\t\t     dump_nlmsg_t dump_class_nlmsg, void *cookie)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct tcmsg t;\n\t} req = {\n\t\t.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t\t.nlh.nlmsg_type = RTM_GETTCLASS,\n\t\t.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,\n\t\t.t.tcm_family = AF_UNSPEC,\n\t\t.t.tcm_ifindex = ifindex,\n\t};\n\tint seq = time(NULL);\n\n\treq.nlh.nlmsg_seq = seq;\n\tif (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)\n\t\treturn -errno;\n\n\treturn netlink_recv(sock, nl_pid, seq, __dump_class_nlmsg,\n\t\t\t    dump_class_nlmsg, cookie);\n}\n\nstatic int __dump_qdisc_nlmsg(struct nlmsghdr *nlh,\n\t\t\t      dump_nlmsg_t dump_qdisc_nlmsg,\n\t\t\t      void *cookie)\n{\n\tstruct nlattr *tb[TCA_MAX + 1], *attr;\n\tstruct tcmsg *t = NLMSG_DATA(nlh);\n\tint len;\n\n\tlen = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*t));\n\tattr = (struct nlattr *) ((void *) t + NLMSG_ALIGN(sizeof(*t)));\n\tif (libbpf_nla_parse(tb, TCA_MAX, attr, len, NULL) != 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\treturn dump_qdisc_nlmsg(cookie, t, tb);\n}\n\nstatic int netlink_get_qdisc(int sock, unsigned int nl_pid, int ifindex,\n\t\t\t     dump_nlmsg_t dump_qdisc_nlmsg, void *cookie)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct tcmsg t;\n\t} req = {\n\t\t.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t\t.nlh.nlmsg_type = RTM_GETQDISC,\n\t\t.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,\n\t\t.t.tcm_family = AF_UNSPEC,\n\t\t.t.tcm_ifindex = ifindex,\n\t};\n\tint seq = time(NULL);\n\n\treq.nlh.nlmsg_seq = seq;\n\tif (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)\n\t\treturn -errno;\n\n\treturn netlink_recv(sock, nl_pid, seq, __dump_qdisc_nlmsg,\n\t\t\t    dump_qdisc_nlmsg, cookie);\n}\n\nstatic int __dump_filter_nlmsg(struct nlmsghdr *nlh,\n\t\t\t       dump_nlmsg_t dump_filter_nlmsg,\n\t\t\t       void *cookie)\n{\n\tstruct nlattr *tb[TCA_MAX + 1], *attr;\n\tstruct tcmsg *t = NLMSG_DATA(nlh);\n\tint len;\n\n\tlen = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*t));\n\tattr = (struct nlattr *) ((void *) t + NLMSG_ALIGN(sizeof(*t)));\n\tif (libbpf_nla_parse(tb, TCA_MAX, attr, len, NULL) != 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\treturn dump_filter_nlmsg(cookie, t, tb);\n}\n\nstatic int netlink_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,\n\t\t\t      dump_nlmsg_t dump_filter_nlmsg, void *cookie)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct tcmsg t;\n\t} req = {\n\t\t.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t\t.nlh.nlmsg_type = RTM_GETTFILTER,\n\t\t.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,\n\t\t.t.tcm_family = AF_UNSPEC,\n\t\t.t.tcm_ifindex = ifindex,\n\t\t.t.tcm_parent = handle,\n\t};\n\tint seq = time(NULL);\n\n\treq.nlh.nlmsg_seq = seq;\n\tif (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)\n\t\treturn -errno;\n\n\treturn netlink_recv(sock, nl_pid, seq, __dump_filter_nlmsg,\n\t\t\t    dump_filter_nlmsg, cookie);\n}\n\nstatic int __dump_link_nlmsg(struct nlmsghdr *nlh,\n\t\t\t     dump_nlmsg_t dump_link_nlmsg, void *cookie)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1], *attr;\n\tstruct ifinfomsg *ifi = NLMSG_DATA(nlh);\n\tint len;\n\n\tlen = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\tattr = (struct nlattr *) ((void *) ifi + NLMSG_ALIGN(sizeof(*ifi)));\n\tif (libbpf_nla_parse(tb, IFLA_MAX, attr, len, NULL) != 0)\n\t\treturn -LIBBPF_ERRNO__NLPARSE;\n\n\treturn dump_link_nlmsg(cookie, ifi, tb);\n}\n\nstatic int netlink_get_link(int sock, unsigned int nl_pid,\n\t\t\t    dump_nlmsg_t dump_link_nlmsg, void *cookie)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct ifinfomsg ifm;\n\t} req = {\n\t\t.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.nlh.nlmsg_type = RTM_GETLINK,\n\t\t.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,\n\t\t.ifm.ifi_family = AF_PACKET,\n\t};\n\tint seq = time(NULL);\n\n\treq.nlh.nlmsg_seq = seq;\n\tif (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)\n\t\treturn -errno;\n\n\treturn netlink_recv(sock, nl_pid, seq, __dump_link_nlmsg,\n\t\t\t    dump_link_nlmsg, cookie);\n}\n\nstatic int dump_link_nlmsg(void *cookie, void *msg, struct nlattr **tb)\n{\n\tstruct bpf_netdev_t *netinfo = cookie;\n\tstruct ifinfomsg *ifinfo = msg;\n\n\tif (netinfo->filter_idx > 0 && netinfo->filter_idx != ifinfo->ifi_index)\n\t\treturn 0;\n\n\tif (netinfo->used_len == netinfo->array_len) {\n\t\tnetinfo->devices = realloc(netinfo->devices,\n\t\t\t(netinfo->array_len + 16) *\n\t\t\tsizeof(struct ip_devname_ifindex));\n\t\tif (!netinfo->devices)\n\t\t\treturn -ENOMEM;\n\n\t\tnetinfo->array_len += 16;\n\t}\n\tnetinfo->devices[netinfo->used_len].ifindex = ifinfo->ifi_index;\n\tsnprintf(netinfo->devices[netinfo->used_len].devname,\n\t\t sizeof(netinfo->devices[netinfo->used_len].devname),\n\t\t \"%s\",\n\t\t tb[IFLA_IFNAME]\n\t\t\t ? libbpf_nla_getattr_str(tb[IFLA_IFNAME])\n\t\t\t : \"\");\n\tnetinfo->used_len++;\n\n\treturn do_xdp_dump(ifinfo, tb);\n}\n\nstatic int dump_class_qdisc_nlmsg(void *cookie, void *msg, struct nlattr **tb)\n{\n\tstruct bpf_tcinfo_t *tcinfo = cookie;\n\tstruct tcmsg *info = msg;\n\n\tif (tcinfo->is_qdisc) {\n\t\t \n\t\tif (tb[TCA_KIND] &&\n\t\t    strcmp(libbpf_nla_data(tb[TCA_KIND]), \"clsact\") == 0)\n\t\t\treturn 0;\n\t\tif (info->tcm_handle == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (tcinfo->used_len == tcinfo->array_len) {\n\t\ttcinfo->handle_array = realloc(tcinfo->handle_array,\n\t\t\t(tcinfo->array_len + 16) * sizeof(struct tc_kind_handle));\n\t\tif (!tcinfo->handle_array)\n\t\t\treturn -ENOMEM;\n\n\t\ttcinfo->array_len += 16;\n\t}\n\ttcinfo->handle_array[tcinfo->used_len].handle = info->tcm_handle;\n\tsnprintf(tcinfo->handle_array[tcinfo->used_len].kind,\n\t\t sizeof(tcinfo->handle_array[tcinfo->used_len].kind),\n\t\t \"%s\",\n\t\t tb[TCA_KIND]\n\t\t\t ? libbpf_nla_getattr_str(tb[TCA_KIND])\n\t\t\t : \"unknown\");\n\ttcinfo->used_len++;\n\n\treturn 0;\n}\n\nstatic int dump_filter_nlmsg(void *cookie, void *msg, struct nlattr **tb)\n{\n\tconst struct bpf_filter_t *filter_info = cookie;\n\n\treturn do_filter_dump((struct tcmsg *)msg, tb, filter_info->kind,\n\t\t\t      filter_info->devname, filter_info->ifindex);\n}\n\nstatic int __show_dev_tc_bpf_name(__u32 id, char *name, size_t len)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 ilen = sizeof(info);\n\tint fd, ret;\n\n\tfd = bpf_prog_get_fd_by_id(id);\n\tif (fd < 0)\n\t\treturn fd;\n\tret = bpf_obj_get_info_by_fd(fd, &info, &ilen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = -ENOENT;\n\tif (info.name[0]) {\n\t\tget_prog_full_name(&info, fd, name, len);\n\t\tret = 0;\n\t}\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void __show_dev_tc_bpf(const struct ip_devname_ifindex *dev,\n\t\t\t      const enum bpf_attach_type loc)\n{\n\t__u32 prog_flags[64] = {}, link_flags[64] = {}, i, j;\n\t__u32 prog_ids[64] = {}, link_ids[64] = {};\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tchar prog_name[MAX_PROG_FULL_NAME];\n\tint ret;\n\n\toptq.prog_ids = prog_ids;\n\toptq.prog_attach_flags = prog_flags;\n\toptq.link_ids = link_ids;\n\toptq.link_attach_flags = link_flags;\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\tret = bpf_prog_query_opts(dev->ifindex, loc, &optq);\n\tif (ret)\n\t\treturn;\n\tfor (i = 0; i < optq.count; i++) {\n\t\tNET_START_OBJECT;\n\t\tNET_DUMP_STR(\"devname\", \"%s\", dev->devname);\n\t\tNET_DUMP_UINT(\"ifindex\", \"(%u)\", dev->ifindex);\n\t\tNET_DUMP_STR(\"kind\", \" %s\", attach_loc_strings[loc]);\n\t\tret = __show_dev_tc_bpf_name(prog_ids[i], prog_name,\n\t\t\t\t\t     sizeof(prog_name));\n\t\tif (!ret)\n\t\t\tNET_DUMP_STR(\"name\", \" %s\", prog_name);\n\t\tNET_DUMP_UINT(\"prog_id\", \" prog_id %u \", prog_ids[i]);\n\t\tif (prog_flags[i] || json_output) {\n\t\t\tNET_START_ARRAY(\"prog_flags\", \"%s \");\n\t\t\tfor (j = 0; prog_flags[i] && j < 32; j++) {\n\t\t\t\tif (!(prog_flags[i] & (1 << j)))\n\t\t\t\t\tcontinue;\n\t\t\t\tNET_DUMP_UINT_ONLY(1 << j);\n\t\t\t}\n\t\t\tNET_END_ARRAY(\"\");\n\t\t}\n\t\tif (link_ids[i] || json_output) {\n\t\t\tNET_DUMP_UINT(\"link_id\", \"link_id %u \", link_ids[i]);\n\t\t\tif (link_flags[i] || json_output) {\n\t\t\t\tNET_START_ARRAY(\"link_flags\", \"%s \");\n\t\t\t\tfor (j = 0; link_flags[i] && j < 32; j++) {\n\t\t\t\t\tif (!(link_flags[i] & (1 << j)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tNET_DUMP_UINT_ONLY(1 << j);\n\t\t\t\t}\n\t\t\t\tNET_END_ARRAY(\"\");\n\t\t\t}\n\t\t}\n\t\tNET_END_OBJECT_FINAL;\n\t}\n}\n\nstatic void show_dev_tc_bpf(struct ip_devname_ifindex *dev)\n{\n\t__show_dev_tc_bpf(dev, BPF_TCX_INGRESS);\n\t__show_dev_tc_bpf(dev, BPF_TCX_EGRESS);\n}\n\nstatic int show_dev_tc_bpf_classic(int sock, unsigned int nl_pid,\n\t\t\t\t   struct ip_devname_ifindex *dev)\n{\n\tstruct bpf_filter_t filter_info;\n\tstruct bpf_tcinfo_t tcinfo;\n\tint i, handle, ret = 0;\n\n\ttcinfo.handle_array = NULL;\n\ttcinfo.used_len = 0;\n\ttcinfo.array_len = 0;\n\n\ttcinfo.is_qdisc = false;\n\tret = netlink_get_class(sock, nl_pid, dev->ifindex,\n\t\t\t\tdump_class_qdisc_nlmsg, &tcinfo);\n\tif (ret)\n\t\tgoto out;\n\n\ttcinfo.is_qdisc = true;\n\tret = netlink_get_qdisc(sock, nl_pid, dev->ifindex,\n\t\t\t\tdump_class_qdisc_nlmsg, &tcinfo);\n\tif (ret)\n\t\tgoto out;\n\n\tfilter_info.devname = dev->devname;\n\tfilter_info.ifindex = dev->ifindex;\n\tfor (i = 0; i < tcinfo.used_len; i++) {\n\t\tfilter_info.kind = tcinfo.handle_array[i].kind;\n\t\tret = netlink_get_filter(sock, nl_pid, dev->ifindex,\n\t\t\t\t\t tcinfo.handle_array[i].handle,\n\t\t\t\t\t dump_filter_nlmsg, &filter_info);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\thandle = TC_H_ROOT;\n\tfilter_info.kind = \"root\";\n\tret = netlink_get_filter(sock, nl_pid, dev->ifindex, handle,\n\t\t\t\t dump_filter_nlmsg, &filter_info);\n\tif (ret)\n\t\tgoto out;\n\n\thandle = TC_H_MAKE(TC_H_CLSACT, TC_H_MIN_INGRESS);\n\tfilter_info.kind = \"clsact/ingress\";\n\tret = netlink_get_filter(sock, nl_pid, dev->ifindex, handle,\n\t\t\t\t dump_filter_nlmsg, &filter_info);\n\tif (ret)\n\t\tgoto out;\n\n\thandle = TC_H_MAKE(TC_H_CLSACT, TC_H_MIN_EGRESS);\n\tfilter_info.kind = \"clsact/egress\";\n\tret = netlink_get_filter(sock, nl_pid, dev->ifindex, handle,\n\t\t\t\t dump_filter_nlmsg, &filter_info);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tfree(tcinfo.handle_array);\n\treturn 0;\n}\n\nstatic int query_flow_dissector(struct bpf_attach_info *attach_info)\n{\n\t__u32 attach_flags;\n\t__u32 prog_ids[1];\n\t__u32 prog_cnt;\n\tint err;\n\tint fd;\n\n\tfd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (fd < 0) {\n\t\tp_err(\"can't open /proc/self/ns/net: %s\",\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\tprog_cnt = ARRAY_SIZE(prog_ids);\n\terr = bpf_prog_query(fd, BPF_FLOW_DISSECTOR, 0,\n\t\t\t     &attach_flags, prog_ids, &prog_cnt);\n\tclose(fd);\n\tif (err) {\n\t\tif (errno == EINVAL) {\n\t\t\t \n\t\t\terrno = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tp_err(\"can't query prog: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (prog_cnt == 1)\n\t\tattach_info->flow_dissector_id = prog_ids[0];\n\n\treturn 0;\n}\n\nstatic int net_parse_dev(int *argc, char ***argv)\n{\n\tint ifindex;\n\n\tif (is_prefix(**argv, \"dev\")) {\n\t\tNEXT_ARGP();\n\n\t\tifindex = if_nametoindex(**argv);\n\t\tif (!ifindex)\n\t\t\tp_err(\"invalid devname %s\", **argv);\n\n\t\tNEXT_ARGP();\n\t} else {\n\t\tp_err(\"expected 'dev', got: '%s'?\", **argv);\n\t\treturn -1;\n\t}\n\n\treturn ifindex;\n}\n\nstatic int do_attach_detach_xdp(int progfd, enum net_attach_type attach_type,\n\t\t\t\tint ifindex, bool overwrite)\n{\n\t__u32 flags = 0;\n\n\tif (!overwrite)\n\t\tflags = XDP_FLAGS_UPDATE_IF_NOEXIST;\n\tif (attach_type == NET_ATTACH_TYPE_XDP_GENERIC)\n\t\tflags |= XDP_FLAGS_SKB_MODE;\n\tif (attach_type == NET_ATTACH_TYPE_XDP_DRIVER)\n\t\tflags |= XDP_FLAGS_DRV_MODE;\n\tif (attach_type == NET_ATTACH_TYPE_XDP_OFFLOAD)\n\t\tflags |= XDP_FLAGS_HW_MODE;\n\n\treturn bpf_xdp_attach(ifindex, progfd, flags, NULL);\n}\n\nstatic int do_attach(int argc, char **argv)\n{\n\tenum net_attach_type attach_type;\n\tint progfd, ifindex, err = 0;\n\tbool overwrite = false;\n\n\t \n\tif (!REQ_ARGS(5))\n\t\treturn -EINVAL;\n\n\tattach_type = parse_attach_type(*argv);\n\tif (attach_type == net_attach_type_size) {\n\t\tp_err(\"invalid net attach/detach type: %s\", *argv);\n\t\treturn -EINVAL;\n\t}\n\tNEXT_ARG();\n\n\tprogfd = prog_parse_fd(&argc, &argv);\n\tif (progfd < 0)\n\t\treturn -EINVAL;\n\n\tifindex = net_parse_dev(&argc, &argv);\n\tif (ifindex < 1) {\n\t\terr = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tif (argc) {\n\t\tif (is_prefix(*argv, \"overwrite\")) {\n\t\t\toverwrite = true;\n\t\t} else {\n\t\t\tp_err(\"expected 'overwrite', got: '%s'?\", *argv);\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tif (is_prefix(\"xdp\", attach_type_strings[attach_type]))\n\t\terr = do_attach_detach_xdp(progfd, attach_type, ifindex,\n\t\t\t\t\t   overwrite);\n\tif (err) {\n\t\tp_err(\"interface %s attach failed: %s\",\n\t\t      attach_type_strings[attach_type], strerror(-err));\n\t\tgoto cleanup;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\ncleanup:\n\tclose(progfd);\n\treturn err;\n}\n\nstatic int do_detach(int argc, char **argv)\n{\n\tenum net_attach_type attach_type;\n\tint progfd, ifindex, err = 0;\n\n\t \n\tif (!REQ_ARGS(3))\n\t\treturn -EINVAL;\n\n\tattach_type = parse_attach_type(*argv);\n\tif (attach_type == net_attach_type_size) {\n\t\tp_err(\"invalid net attach/detach type: %s\", *argv);\n\t\treturn -EINVAL;\n\t}\n\tNEXT_ARG();\n\n\tifindex = net_parse_dev(&argc, &argv);\n\tif (ifindex < 1)\n\t\treturn -EINVAL;\n\n\t \n\tprogfd = -1;\n\tif (is_prefix(\"xdp\", attach_type_strings[attach_type]))\n\t\terr = do_attach_detach_xdp(progfd, attach_type, ifindex, NULL);\n\n\tif (err < 0) {\n\t\tp_err(\"interface %s detach failed: %s\",\n\t\t      attach_type_strings[attach_type], strerror(-err));\n\t\treturn err;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\treturn 0;\n}\n\nstatic int netfilter_link_compar(const void *a, const void *b)\n{\n\tconst struct bpf_link_info *nfa = a;\n\tconst struct bpf_link_info *nfb = b;\n\tint delta;\n\n\tdelta = nfa->netfilter.pf - nfb->netfilter.pf;\n\tif (delta)\n\t\treturn delta;\n\n\tdelta = nfa->netfilter.hooknum - nfb->netfilter.hooknum;\n\tif (delta)\n\t\treturn delta;\n\n\tif (nfa->netfilter.priority < nfb->netfilter.priority)\n\t\treturn -1;\n\tif (nfa->netfilter.priority > nfb->netfilter.priority)\n\t\treturn 1;\n\n\treturn nfa->netfilter.flags - nfb->netfilter.flags;\n}\n\nstatic void show_link_netfilter(void)\n{\n\tunsigned int nf_link_len = 0, nf_link_count = 0;\n\tstruct bpf_link_info *nf_link_info = NULL;\n\t__u32 id = 0;\n\n\twhile (true) {\n\t\tstruct bpf_link_info info;\n\t\tint fd, err;\n\t\t__u32 len;\n\n\t\terr = bpf_link_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\tp_err(\"can't get next link: %s (id %d)\", strerror(errno), id);\n\t\t\tbreak;\n\t\t}\n\n\t\tfd = bpf_link_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tp_err(\"can't get link by id (%u): %s\", id, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tlen = sizeof(info);\n\n\t\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\n\t\tclose(fd);\n\n\t\tif (err) {\n\t\t\tp_err(\"can't get link info for fd %d: %s\", fd, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (info.type != BPF_LINK_TYPE_NETFILTER)\n\t\t\tcontinue;\n\n\t\tif (nf_link_count >= nf_link_len) {\n\t\t\tstatic const unsigned int max_link_count = INT_MAX / sizeof(info);\n\t\t\tstruct bpf_link_info *expand;\n\n\t\t\tif (nf_link_count > max_link_count) {\n\t\t\t\tp_err(\"cannot handle more than %u links\\n\", max_link_count);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnf_link_len += 16;\n\n\t\t\texpand = realloc(nf_link_info, nf_link_len * sizeof(info));\n\t\t\tif (!expand) {\n\t\t\t\tp_err(\"realloc: %s\",  strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnf_link_info = expand;\n\t\t}\n\n\t\tnf_link_info[nf_link_count] = info;\n\t\tnf_link_count++;\n\t}\n\n\tqsort(nf_link_info, nf_link_count, sizeof(*nf_link_info), netfilter_link_compar);\n\n\tfor (id = 0; id < nf_link_count; id++) {\n\t\tNET_START_OBJECT;\n\t\tif (json_output)\n\t\t\tnetfilter_dump_json(&nf_link_info[id], json_wtr);\n\t\telse\n\t\t\tnetfilter_dump_plain(&nf_link_info[id]);\n\n\t\tNET_DUMP_UINT(\"id\", \" prog_id %u\", nf_link_info[id].prog_id);\n\t\tNET_END_OBJECT;\n\t}\n\n\tfree(nf_link_info);\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tstruct bpf_attach_info attach_info = {};\n\tint i, sock, ret, filter_idx = -1;\n\tstruct bpf_netdev_t dev_array;\n\tunsigned int nl_pid = 0;\n\tchar err_buf[256];\n\n\tif (argc == 2) {\n\t\tfilter_idx = net_parse_dev(&argc, &argv);\n\t\tif (filter_idx < 1)\n\t\t\treturn -1;\n\t} else if (argc != 0) {\n\t\tusage();\n\t}\n\n\tret = query_flow_dissector(&attach_info);\n\tif (ret)\n\t\treturn -1;\n\n\tsock = netlink_open(&nl_pid);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"failed to open netlink sock\\n\");\n\t\treturn -1;\n\t}\n\n\tdev_array.devices = NULL;\n\tdev_array.used_len = 0;\n\tdev_array.array_len = 0;\n\tdev_array.filter_idx = filter_idx;\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\tNET_START_OBJECT;\n\tNET_START_ARRAY(\"xdp\", \"%s:\\n\");\n\tret = netlink_get_link(sock, nl_pid, dump_link_nlmsg, &dev_array);\n\tNET_END_ARRAY(\"\\n\");\n\n\tif (!ret) {\n\t\tNET_START_ARRAY(\"tc\", \"%s:\\n\");\n\t\tfor (i = 0; i < dev_array.used_len; i++) {\n\t\t\tshow_dev_tc_bpf(&dev_array.devices[i]);\n\t\t\tret = show_dev_tc_bpf_classic(sock, nl_pid,\n\t\t\t\t\t\t      &dev_array.devices[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tNET_END_ARRAY(\"\\n\");\n\t}\n\n\tNET_START_ARRAY(\"flow_dissector\", \"%s:\\n\");\n\tif (attach_info.flow_dissector_id > 0)\n\t\tNET_DUMP_UINT(\"id\", \"id %u\", attach_info.flow_dissector_id);\n\tNET_END_ARRAY(\"\\n\");\n\n\tNET_START_ARRAY(\"netfilter\", \"%s:\\n\");\n\tshow_link_netfilter();\n\tNET_END_ARRAY(\"\\n\");\n\n\tNET_END_OBJECT;\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tif (ret) {\n\t\tif (json_output)\n\t\t\tjsonw_null(json_wtr);\n\t\tlibbpf_strerror(ret, err_buf, sizeof(err_buf));\n\t\tfprintf(stderr, \"Error: %s\\n\", err_buf);\n\t}\n\tfree(dev_array.devices);\n\tclose(sock);\n\treturn ret;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list } [dev <devname>]\\n\"\n\t\t\"       %1$s %2$s attach ATTACH_TYPE PROG dev <devname> [ overwrite ]\\n\"\n\t\t\"       %1$s %2$s detach ATTACH_TYPE dev <devname>\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_PROGRAM \"\\n\"\n\t\t\"       ATTACH_TYPE := { xdp | xdpgeneric | xdpdrv | xdpoffload }\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" }\\n\"\n\t\t\"\\n\"\n\t\t\"Note: Only xdp, tcx, tc, flow_dissector and netfilter attachments\\n\"\n\t\t\"      are currently supported.\\n\"\n\t\t\"      For progs attached to cgroups, use \\\"bpftool cgroup\\\"\\n\"\n\t\t\"      to dump program attachments. For program types\\n\"\n\t\t\"      sk_{filter,skb,msg,reuseport} and lwt/seg6, please\\n\"\n\t\t\"      consult iproute2.\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"attach\",\tdo_attach },\n\t{ \"detach\",\tdo_detach },\n\t{ \"help\",\tdo_help },\n\t{ 0 }\n};\n\nint do_net(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}