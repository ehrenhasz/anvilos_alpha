{
  "module_name": "main.h",
  "hash_id": "0941cba593c3f6d58c277d471775992561383e8bd1ffbf01afcb2b08ad7e1aa0",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/main.h",
  "human_readable_source": " \n \n\n#ifndef __BPF_TOOL_H\n#define __BPF_TOOL_H\n\n \n#undef GCC_VERSION\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/bpf.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\n#include <bpf/hashmap.h>\n#include <bpf/libbpf.h>\n\n#include \"json_writer.h\"\n\n \n#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64\n\nstatic inline __u64 ptr_to_u64(const void *ptr)\n{\n\treturn (__u64)(unsigned long)ptr;\n}\n\nstatic inline void *u64_to_ptr(__u64 ptr)\n{\n\treturn (void *)(unsigned long)ptr;\n}\n\n#define NEXT_ARG()\t({ argc--; argv++; if (argc < 0) usage(); })\n#define NEXT_ARGP()\t({ (*argc)--; (*argv)++; if (*argc < 0) usage(); })\n#define BAD_ARG()\t({ p_err(\"what is '%s'?\", *argv); -1; })\n#define GET_ARG()\t({ argc--; *argv++; })\n#define REQ_ARGS(cnt)\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint _cnt = (cnt);\t\t\t\t\t\\\n\t\tbool _res;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (argc < _cnt) {\t\t\t\t\t\\\n\t\t\tp_err(\"'%s' needs at least %d arguments, %d found\", \\\n\t\t\t      argv[-1], _cnt, argc);\t\t\t\\\n\t\t\t_res = false;\t\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t_res = true;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t_res;\t\t\t\t\t\t\t\\\n\t})\n\n#define ERR_MAX_LEN\t1024\n\n#define BPF_TAG_FMT\t\"%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\"\n\n#define HELP_SPEC_PROGRAM\t\t\t\t\t\t\\\n\t\"PROG := { id PROG_ID | pinned FILE | tag PROG_TAG | name PROG_NAME }\"\n#define HELP_SPEC_OPTIONS\t\t\t\t\t\t\\\n\t\"OPTIONS := { {-j|--json} [{-p|--pretty}] | {-d|--debug}\"\n#define HELP_SPEC_MAP\t\t\t\t\t\t\t\\\n\t\"MAP := { id MAP_ID | pinned FILE | name MAP_NAME }\"\n#define HELP_SPEC_LINK\t\t\t\t\t\t\t\\\n\t\"LINK := { id LINK_ID | pinned FILE }\"\n\n \nenum bpf_obj_type {\n\tBPF_OBJ_UNKNOWN,\n\tBPF_OBJ_PROG,\n\tBPF_OBJ_MAP,\n\tBPF_OBJ_LINK,\n\tBPF_OBJ_BTF,\n};\n\nextern const char *bin_name;\n\nextern json_writer_t *json_wtr;\nextern bool json_output;\nextern bool show_pinned;\nextern bool show_pids;\nextern bool block_mount;\nextern bool verifier_logs;\nextern bool relaxed_maps;\nextern bool use_loader;\nextern struct btf *base_btf;\nextern struct hashmap *refs_table;\n\nvoid __printf(1, 2) p_err(const char *fmt, ...);\nvoid __printf(1, 2) p_info(const char *fmt, ...);\n\nbool is_prefix(const char *pfx, const char *str);\nint detect_common_prefix(const char *arg, ...);\nvoid fprint_hex(FILE *f, void *arg, unsigned int n, const char *sep);\nvoid usage(void) __noreturn;\n\nvoid set_max_rlimit(void);\n\nint mount_tracefs(const char *target);\n\nstruct obj_ref {\n\tint pid;\n\tchar comm[16];\n};\n\nstruct obj_refs {\n\tint ref_cnt;\n\tbool has_bpf_cookie;\n\tstruct obj_ref *refs;\n\t__u64 bpf_cookie;\n};\n\nstruct btf;\nstruct bpf_line_info;\n\nint build_pinned_obj_table(struct hashmap *table,\n\t\t\t   enum bpf_obj_type type);\nvoid delete_pinned_obj_table(struct hashmap *table);\n__weak int build_obj_refs_table(struct hashmap **table,\n\t\t\t\tenum bpf_obj_type type);\n__weak void delete_obj_refs_table(struct hashmap *table);\n__weak void emit_obj_refs_json(struct hashmap *table, __u32 id,\n\t\t\t       json_writer_t *json_wtr);\n__weak void emit_obj_refs_plain(struct hashmap *table, __u32 id,\n\t\t\t\tconst char *prefix);\nvoid print_dev_plain(__u32 ifindex, __u64 ns_dev, __u64 ns_inode);\nvoid print_dev_json(__u32 ifindex, __u64 ns_dev, __u64 ns_inode);\n\nstruct cmd {\n\tconst char *cmd;\n\tint (*func)(int argc, char **argv);\n};\n\nint cmd_select(const struct cmd *cmds, int argc, char **argv,\n\t       int (*help)(int argc, char **argv));\n\n#define MAX_PROG_FULL_NAME 128\nvoid get_prog_full_name(const struct bpf_prog_info *prog_info, int prog_fd,\n\t\t\tchar *name_buff, size_t buff_len);\n\nint get_fd_type(int fd);\nconst char *get_fd_type_name(enum bpf_obj_type type);\nchar *get_fdinfo(int fd, const char *key);\nint open_obj_pinned(const char *path, bool quiet);\nint open_obj_pinned_any(const char *path, enum bpf_obj_type exp_type);\nint mount_bpffs_for_pin(const char *name, bool is_dir);\nint do_pin_any(int argc, char **argv, int (*get_fd_by_id)(int *, char ***));\nint do_pin_fd(int fd, const char *name);\n\n \nint do_gen(int argc, char **argv);\nint do_btf(int argc, char **argv);\n\n \nint do_prog(int argc, char **arg) __weak;\nint do_map(int argc, char **arg) __weak;\nint do_link(int argc, char **arg) __weak;\nint do_event_pipe(int argc, char **argv) __weak;\nint do_cgroup(int argc, char **arg) __weak;\nint do_perf(int argc, char **arg) __weak;\nint do_net(int argc, char **arg) __weak;\nint do_tracelog(int argc, char **arg) __weak;\nint do_feature(int argc, char **argv) __weak;\nint do_struct_ops(int argc, char **argv) __weak;\nint do_iter(int argc, char **argv) __weak;\n\nint parse_u32_arg(int *argc, char ***argv, __u32 *val, const char *what);\nint prog_parse_fd(int *argc, char ***argv);\nint prog_parse_fds(int *argc, char ***argv, int **fds);\nint map_parse_fd(int *argc, char ***argv);\nint map_parse_fds(int *argc, char ***argv, int **fds);\nint map_parse_fd_and_info(int *argc, char ***argv, struct bpf_map_info *info,\n\t\t\t  __u32 *info_len);\n\nstruct bpf_prog_linfo;\n#if defined(HAVE_LLVM_SUPPORT) || defined(HAVE_LIBBFD_SUPPORT)\nint disasm_print_insn(unsigned char *image, ssize_t len, int opcodes,\n\t\t      const char *arch, const char *disassembler_options,\n\t\t      const struct btf *btf,\n\t\t      const struct bpf_prog_linfo *prog_linfo,\n\t\t      __u64 func_ksym, unsigned int func_idx,\n\t\t      bool linum);\nint disasm_init(void);\n#else\nstatic inline\nint disasm_print_insn(unsigned char *image, ssize_t len, int opcodes,\n\t\t      const char *arch, const char *disassembler_options,\n\t\t      const struct btf *btf,\n\t\t      const struct bpf_prog_linfo *prog_linfo,\n\t\t      __u64 func_ksym, unsigned int func_idx,\n\t\t      bool linum)\n{\n\treturn 0;\n}\nstatic inline int disasm_init(void)\n{\n\tp_err(\"No JIT disassembly support\");\n\treturn -1;\n}\n#endif\nvoid print_data_json(uint8_t *data, size_t len);\nvoid print_hex_data_json(uint8_t *data, size_t len);\n\nunsigned int get_page_size(void);\nunsigned int get_possible_cpus(void);\nconst char *\nifindex_to_arch(__u32 ifindex, __u64 ns_dev, __u64 ns_ino, const char **opt);\n\nstruct btf_dumper {\n\tconst struct btf *btf;\n\tjson_writer_t *jw;\n\tbool is_plain_text;\n\tbool prog_id_as_func_ptr;\n};\n\n \nint btf_dumper_type(const struct btf_dumper *d, __u32 type_id,\n\t\t    const void *data);\nvoid btf_dumper_type_only(const struct btf *btf, __u32 func_type_id,\n\t\t\t  char *func_only, int size);\n\nvoid btf_dump_linfo_plain(const struct btf *btf,\n\t\t\t  const struct bpf_line_info *linfo,\n\t\t\t  const char *prefix, bool linum);\nvoid btf_dump_linfo_json(const struct btf *btf,\n\t\t\t const struct bpf_line_info *linfo, bool linum);\nvoid btf_dump_linfo_dotlabel(const struct btf *btf,\n\t\t\t     const struct bpf_line_info *linfo, bool linum);\n\nstruct nlattr;\nstruct ifinfomsg;\nstruct tcmsg;\nint do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb);\nint do_filter_dump(struct tcmsg *ifinfo, struct nlattr **tb, const char *kind,\n\t\t   const char *devname, int ifindex);\n\nint print_all_levels(__maybe_unused enum libbpf_print_level level,\n\t\t     const char *format, va_list args);\n\nsize_t hash_fn_for_key_as_id(long key, void *ctx);\nbool equal_fn_for_key_as_id(long k1, long k2, void *ctx);\n\n \nconst char *bpf_attach_type_input_str(enum bpf_attach_type t);\n\nstatic inline bool hashmap__empty(struct hashmap *map)\n{\n\treturn map ? hashmap__size(map) == 0 : true;\n}\n\nint pathname_concat(char *buf, int buf_sz, const char *path,\n\t\t    const char *name);\n\n \nvoid netfilter_dump_plain(const struct bpf_link_info *info);\nvoid netfilter_dump_json(const struct bpf_link_info *info, json_writer_t *wtr);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}