{
  "module_name": "btf.c",
  "hash_id": "81c95dab2c7996f4e337a585cc9e45cfbdbd90047a71f1a8951bf7e3d0d86ede",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/btf.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/btf.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/hashmap.h>\n#include <bpf/libbpf.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n\t[BTF_KIND_ENUM64]\t= \"ENUM64\",\n};\n\nstatic const char *btf_int_enc_str(__u8 encoding)\n{\n\tswitch (encoding) {\n\tcase 0:\n\t\treturn \"(none)\";\n\tcase BTF_INT_SIGNED:\n\t\treturn \"SIGNED\";\n\tcase BTF_INT_CHAR:\n\t\treturn \"CHAR\";\n\tcase BTF_INT_BOOL:\n\t\treturn \"BOOL\";\n\tdefault:\n\t\treturn \"UNKN\";\n\t}\n}\n\nstatic const char *btf_var_linkage_str(__u32 linkage)\n{\n\tswitch (linkage) {\n\tcase BTF_VAR_STATIC:\n\t\treturn \"static\";\n\tcase BTF_VAR_GLOBAL_ALLOCATED:\n\t\treturn \"global\";\n\tcase BTF_VAR_GLOBAL_EXTERN:\n\t\treturn \"extern\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic const char *btf_func_linkage_str(const struct btf_type *t)\n{\n\tswitch (btf_vlen(t)) {\n\tcase BTF_FUNC_STATIC:\n\t\treturn \"static\";\n\tcase BTF_FUNC_GLOBAL:\n\t\treturn \"global\";\n\tcase BTF_FUNC_EXTERN:\n\t\treturn \"extern\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic const char *btf_str(const struct btf *btf, __u32 off)\n{\n\tif (!off)\n\t\treturn \"(anon)\";\n\treturn btf__name_by_offset(btf, off) ? : \"(invalid)\";\n}\n\nstatic int btf_kind_safe(int kind)\n{\n\treturn kind <= BTF_KIND_MAX ? kind : BTF_KIND_UNKN;\n}\n\nstatic int dump_btf_type(const struct btf *btf, __u32 id,\n\t\t\t const struct btf_type *t)\n{\n\tjson_writer_t *w = json_wtr;\n\tint kind = btf_kind(t);\n\n\tif (json_output) {\n\t\tjsonw_start_object(w);\n\t\tjsonw_uint_field(w, \"id\", id);\n\t\tjsonw_string_field(w, \"kind\", btf_kind_str[btf_kind_safe(kind)]);\n\t\tjsonw_string_field(w, \"name\", btf_str(btf, t->name_off));\n\t} else {\n\t\tprintf(\"[%u] %s '%s'\", id, btf_kind_str[btf_kind_safe(kind)],\n\t\t       btf_str(btf, t->name_off));\n\t}\n\n\tswitch (kind) {\n\tcase BTF_KIND_INT: {\n\t\t__u32 v = *(__u32 *)(t + 1);\n\t\tconst char *enc;\n\n\t\tenc = btf_int_enc_str(BTF_INT_ENCODING(v));\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\t\tjsonw_uint_field(w, \"bits_offset\", BTF_INT_OFFSET(v));\n\t\t\tjsonw_uint_field(w, \"nr_bits\", BTF_INT_BITS(v));\n\t\t\tjsonw_string_field(w, \"encoding\", enc);\n\t\t} else {\n\t\t\tprintf(\" size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t       t->size, BTF_INT_OFFSET(v), BTF_INT_BITS(v),\n\t\t\t       enc);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_TYPE_TAG:\n\t\tif (json_output)\n\t\t\tjsonw_uint_field(w, \"type_id\", t->type);\n\t\telse\n\t\t\tprintf(\" type_id=%u\", t->type);\n\t\tbreak;\n\tcase BTF_KIND_ARRAY: {\n\t\tconst struct btf_array *arr = (const void *)(t + 1);\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"type_id\", arr->type);\n\t\t\tjsonw_uint_field(w, \"index_type_id\", arr->index_type);\n\t\t\tjsonw_uint_field(w, \"nr_elems\", arr->nelems);\n\t\t} else {\n\t\t\tprintf(\" type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t       arr->type, arr->index_type, arr->nelems);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m = (const void *)(t + 1);\n\t\t__u16 vlen = BTF_INFO_VLEN(t->info);\n\t\tint i;\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\t\tjsonw_uint_field(w, \"vlen\", vlen);\n\t\t\tjsonw_name(w, \"members\");\n\t\t\tjsonw_start_array(w);\n\t\t} else {\n\t\t\tprintf(\" size=%u vlen=%u\", t->size, vlen);\n\t\t}\n\t\tfor (i = 0; i < vlen; i++, m++) {\n\t\t\tconst char *name = btf_str(btf, m->name_off);\n\t\t\t__u32 bit_off, bit_sz;\n\n\t\t\tif (BTF_INFO_KFLAG(t->info)) {\n\t\t\t\tbit_off = BTF_MEMBER_BIT_OFFSET(m->offset);\n\t\t\t\tbit_sz = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\t\t} else {\n\t\t\t\tbit_off = m->offset;\n\t\t\t\tbit_sz = 0;\n\t\t\t}\n\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_start_object(w);\n\t\t\t\tjsonw_string_field(w, \"name\", name);\n\t\t\t\tjsonw_uint_field(w, \"type_id\", m->type);\n\t\t\t\tjsonw_uint_field(w, \"bits_offset\", bit_off);\n\t\t\t\tif (bit_sz) {\n\t\t\t\t\tjsonw_uint_field(w, \"bitfield_size\",\n\t\t\t\t\t\t\t bit_sz);\n\t\t\t\t}\n\t\t\t\tjsonw_end_object(w);\n\t\t\t} else {\n\t\t\t\tprintf(\"\\n\\t'%s' type_id=%u bits_offset=%u\",\n\t\t\t\t       name, m->type, bit_off);\n\t\t\t\tif (bit_sz)\n\t\t\t\t\tprintf(\" bitfield_size=%u\", bit_sz);\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_array(w);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM: {\n\t\tconst struct btf_enum *v = (const void *)(t + 1);\n\t\t__u16 vlen = BTF_INFO_VLEN(t->info);\n\t\tconst char *encoding;\n\t\tint i;\n\n\t\tencoding = btf_kflag(t) ? \"SIGNED\" : \"UNSIGNED\";\n\t\tif (json_output) {\n\t\t\tjsonw_string_field(w, \"encoding\", encoding);\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\t\tjsonw_uint_field(w, \"vlen\", vlen);\n\t\t\tjsonw_name(w, \"values\");\n\t\t\tjsonw_start_array(w);\n\t\t} else {\n\t\t\tprintf(\" encoding=%s size=%u vlen=%u\", encoding, t->size, vlen);\n\t\t}\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tconst char *name = btf_str(btf, v->name_off);\n\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_start_object(w);\n\t\t\t\tjsonw_string_field(w, \"name\", name);\n\t\t\t\tif (btf_kflag(t))\n\t\t\t\t\tjsonw_int_field(w, \"val\", v->val);\n\t\t\t\telse\n\t\t\t\t\tjsonw_uint_field(w, \"val\", v->val);\n\t\t\t\tjsonw_end_object(w);\n\t\t\t} else {\n\t\t\t\tif (btf_kflag(t))\n\t\t\t\t\tprintf(\"\\n\\t'%s' val=%d\", name, v->val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\n\\t'%s' val=%u\", name, v->val);\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_array(w);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM64: {\n\t\tconst struct btf_enum64 *v = btf_enum64(t);\n\t\t__u16 vlen = btf_vlen(t);\n\t\tconst char *encoding;\n\t\tint i;\n\n\t\tencoding = btf_kflag(t) ? \"SIGNED\" : \"UNSIGNED\";\n\t\tif (json_output) {\n\t\t\tjsonw_string_field(w, \"encoding\", encoding);\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\t\tjsonw_uint_field(w, \"vlen\", vlen);\n\t\t\tjsonw_name(w, \"values\");\n\t\t\tjsonw_start_array(w);\n\t\t} else {\n\t\t\tprintf(\" encoding=%s size=%u vlen=%u\", encoding, t->size, vlen);\n\t\t}\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tconst char *name = btf_str(btf, v->name_off);\n\t\t\t__u64 val = ((__u64)v->val_hi32 << 32) | v->val_lo32;\n\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_start_object(w);\n\t\t\t\tjsonw_string_field(w, \"name\", name);\n\t\t\t\tif (btf_kflag(t))\n\t\t\t\t\tjsonw_int_field(w, \"val\", val);\n\t\t\t\telse\n\t\t\t\t\tjsonw_uint_field(w, \"val\", val);\n\t\t\t\tjsonw_end_object(w);\n\t\t\t} else {\n\t\t\t\tif (btf_kflag(t))\n\t\t\t\t\tprintf(\"\\n\\t'%s' val=%lldLL\", name,\n\t\t\t\t\t       (unsigned long long)val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\n\\t'%s' val=%lluULL\", name,\n\t\t\t\t\t       (unsigned long long)val);\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_array(w);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FWD: {\n\t\tconst char *fwd_kind = BTF_INFO_KFLAG(t->info) ? \"union\"\n\t\t\t\t\t\t\t       : \"struct\";\n\n\t\tif (json_output)\n\t\t\tjsonw_string_field(w, \"fwd_kind\", fwd_kind);\n\t\telse\n\t\t\tprintf(\" fwd_kind=%s\", fwd_kind);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FUNC: {\n\t\tconst char *linkage = btf_func_linkage_str(t);\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"type_id\", t->type);\n\t\t\tjsonw_string_field(w, \"linkage\", linkage);\n\t\t} else {\n\t\t\tprintf(\" type_id=%u linkage=%s\", t->type, linkage);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *p = (const void *)(t + 1);\n\t\t__u16 vlen = BTF_INFO_VLEN(t->info);\n\t\tint i;\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"ret_type_id\", t->type);\n\t\t\tjsonw_uint_field(w, \"vlen\", vlen);\n\t\t\tjsonw_name(w, \"params\");\n\t\t\tjsonw_start_array(w);\n\t\t} else {\n\t\t\tprintf(\" ret_type_id=%u vlen=%u\", t->type, vlen);\n\t\t}\n\t\tfor (i = 0; i < vlen; i++, p++) {\n\t\t\tconst char *name = btf_str(btf, p->name_off);\n\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_start_object(w);\n\t\t\t\tjsonw_string_field(w, \"name\", name);\n\t\t\t\tjsonw_uint_field(w, \"type_id\", p->type);\n\t\t\t\tjsonw_end_object(w);\n\t\t\t} else {\n\t\t\t\tprintf(\"\\n\\t'%s' type_id=%u\", name, p->type);\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_array(w);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_VAR: {\n\t\tconst struct btf_var *v = (const void *)(t + 1);\n\t\tconst char *linkage;\n\n\t\tlinkage = btf_var_linkage_str(v->linkage);\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"type_id\", t->type);\n\t\t\tjsonw_string_field(w, \"linkage\", linkage);\n\t\t} else {\n\t\t\tprintf(\" type_id=%u, linkage=%s\", t->type, linkage);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_DATASEC: {\n\t\tconst struct btf_var_secinfo *v = (const void *)(t + 1);\n\t\tconst struct btf_type *vt;\n\t\t__u16 vlen = BTF_INFO_VLEN(t->info);\n\t\tint i;\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\t\tjsonw_uint_field(w, \"vlen\", vlen);\n\t\t\tjsonw_name(w, \"vars\");\n\t\t\tjsonw_start_array(w);\n\t\t} else {\n\t\t\tprintf(\" size=%u vlen=%u\", t->size, vlen);\n\t\t}\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_start_object(w);\n\t\t\t\tjsonw_uint_field(w, \"type_id\", v->type);\n\t\t\t\tjsonw_uint_field(w, \"offset\", v->offset);\n\t\t\t\tjsonw_uint_field(w, \"size\", v->size);\n\t\t\t\tjsonw_end_object(w);\n\t\t\t} else {\n\t\t\t\tprintf(\"\\n\\ttype_id=%u offset=%u size=%u\",\n\t\t\t\t       v->type, v->offset, v->size);\n\n\t\t\t\tif (v->type < btf__type_cnt(btf)) {\n\t\t\t\t\tvt = btf__type_by_id(btf, v->type);\n\t\t\t\t\tprintf(\" (%s '%s')\",\n\t\t\t\t\t       btf_kind_str[btf_kind_safe(btf_kind(vt))],\n\t\t\t\t\t       btf_str(btf, vt->name_off));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (json_output)\n\t\t\tjsonw_end_array(w);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FLOAT: {\n\t\tif (json_output)\n\t\t\tjsonw_uint_field(w, \"size\", t->size);\n\t\telse\n\t\t\tprintf(\" size=%u\", t->size);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_DECL_TAG: {\n\t\tconst struct btf_decl_tag *tag = (const void *)(t + 1);\n\n\t\tif (json_output) {\n\t\t\tjsonw_uint_field(w, \"type_id\", t->type);\n\t\t\tjsonw_int_field(w, \"component_idx\", tag->component_idx);\n\t\t} else {\n\t\t\tprintf(\" type_id=%u component_idx=%d\", t->type, tag->component_idx);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_object(json_wtr);\n\telse\n\t\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nstatic int dump_btf_raw(const struct btf *btf,\n\t\t\t__u32 *root_type_ids, int root_type_cnt)\n{\n\tconst struct btf_type *t;\n\tint i;\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tjsonw_name(json_wtr, \"types\");\n\t\tjsonw_start_array(json_wtr);\n\t}\n\n\tif (root_type_cnt) {\n\t\tfor (i = 0; i < root_type_cnt; i++) {\n\t\t\tt = btf__type_by_id(btf, root_type_ids[i]);\n\t\t\tdump_btf_type(btf, root_type_ids[i], t);\n\t\t}\n\t} else {\n\t\tconst struct btf *base;\n\t\tint cnt = btf__type_cnt(btf);\n\t\tint start_id = 1;\n\n\t\tbase = btf__base_btf(btf);\n\t\tif (base)\n\t\t\tstart_id = btf__type_cnt(base);\n\n\t\tfor (i = start_id; i < cnt; i++) {\n\t\t\tt = btf__type_by_id(btf, i);\n\t\t\tdump_btf_type(btf, i, t);\n\t\t}\n\t}\n\n\tif (json_output) {\n\t\tjsonw_end_array(json_wtr);\n\t\tjsonw_end_object(json_wtr);\n\t}\n\treturn 0;\n}\n\nstatic void __printf(2, 0) btf_dump_printf(void *ctx,\n\t\t\t\t\t   const char *fmt, va_list args)\n{\n\tvfprintf(stdout, fmt, args);\n}\n\nstatic int dump_btf_c(const struct btf *btf,\n\t\t      __u32 *root_type_ids, int root_type_cnt)\n{\n\tstruct btf_dump *d;\n\tint err = 0, i;\n\n\td = btf_dump__new(btf, btf_dump_printf, NULL, NULL);\n\tif (!d)\n\t\treturn -errno;\n\n\tprintf(\"#ifndef __VMLINUX_H__\\n\");\n\tprintf(\"#define __VMLINUX_H__\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\\n\");\n\tprintf(\"#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)\\n\");\n\tprintf(\"#endif\\n\\n\");\n\n\tif (root_type_cnt) {\n\t\tfor (i = 0; i < root_type_cnt; i++) {\n\t\t\terr = btf_dump__dump_type(d, root_type_ids[i]);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tint cnt = btf__type_cnt(btf);\n\n\t\tfor (i = 1; i < cnt; i++) {\n\t\t\terr = btf_dump__dump_type(d, i);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tprintf(\"#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\\n\");\n\tprintf(\"#pragma clang attribute pop\\n\");\n\tprintf(\"#endif\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"#endif /* __VMLINUX_H__ */\\n\");\n\ndone:\n\tbtf_dump__free(d);\n\treturn err;\n}\n\nstatic const char sysfs_vmlinux[] = \"/sys/kernel/btf/vmlinux\";\n\nstatic struct btf *get_vmlinux_btf_from_sysfs(void)\n{\n\tstruct btf *base;\n\n\tbase = btf__parse(sysfs_vmlinux, NULL);\n\tif (!base)\n\t\tp_err(\"failed to parse vmlinux BTF at '%s': %d\\n\",\n\t\t      sysfs_vmlinux, -errno);\n\n\treturn base;\n}\n\n#define BTF_NAME_BUFF_LEN 64\n\nstatic bool btf_is_kernel_module(__u32 btf_id)\n{\n\tstruct bpf_btf_info btf_info = {};\n\tchar btf_name[BTF_NAME_BUFF_LEN];\n\tint btf_fd;\n\t__u32 len;\n\tint err;\n\n\tbtf_fd = bpf_btf_get_fd_by_id(btf_id);\n\tif (btf_fd < 0) {\n\t\tp_err(\"can't get BTF object by id (%u): %s\", btf_id, strerror(errno));\n\t\treturn false;\n\t}\n\n\tlen = sizeof(btf_info);\n\tbtf_info.name = ptr_to_u64(btf_name);\n\tbtf_info.name_len = sizeof(btf_name);\n\terr = bpf_btf_get_info_by_fd(btf_fd, &btf_info, &len);\n\tclose(btf_fd);\n\tif (err) {\n\t\tp_err(\"can't get BTF (ID %u) object info: %s\", btf_id, strerror(errno));\n\t\treturn false;\n\t}\n\n\treturn btf_info.kernel_btf && strncmp(btf_name, \"vmlinux\", sizeof(btf_name)) != 0;\n}\n\nstatic int do_dump(int argc, char **argv)\n{\n\tstruct btf *btf = NULL, *base = NULL;\n\t__u32 root_type_ids[2];\n\tint root_type_cnt = 0;\n\tbool dump_c = false;\n\t__u32 btf_id = -1;\n\tconst char *src;\n\tint fd = -1;\n\tint err = 0;\n\n\tif (!REQ_ARGS(2)) {\n\t\tusage();\n\t\treturn -1;\n\t}\n\tsrc = GET_ARG();\n\tif (is_prefix(src, \"map\")) {\n\t\tstruct bpf_map_info info = {};\n\t\t__u32 len = sizeof(info);\n\n\t\tif (!REQ_ARGS(2)) {\n\t\t\tusage();\n\t\t\treturn -1;\n\t\t}\n\n\t\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\n\t\tbtf_id = info.btf_id;\n\t\tif (argc && is_prefix(*argv, \"key\")) {\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_key_type_id;\n\t\t\tNEXT_ARG();\n\t\t} else if (argc && is_prefix(*argv, \"value\")) {\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_value_type_id;\n\t\t\tNEXT_ARG();\n\t\t} else if (argc && is_prefix(*argv, \"all\")) {\n\t\t\tNEXT_ARG();\n\t\t} else if (argc && is_prefix(*argv, \"kv\")) {\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_key_type_id;\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_value_type_id;\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_key_type_id;\n\t\t\troot_type_ids[root_type_cnt++] = info.btf_value_type_id;\n\t\t}\n\t} else if (is_prefix(src, \"prog\")) {\n\t\tstruct bpf_prog_info info = {};\n\t\t__u32 len = sizeof(info);\n\n\t\tif (!REQ_ARGS(2)) {\n\t\t\tusage();\n\t\t\treturn -1;\n\t\t}\n\n\t\tfd = prog_parse_fd(&argc, &argv);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\n\t\terr = bpf_prog_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get prog info: %s\", strerror(errno));\n\t\t\tgoto done;\n\t\t}\n\n\t\tbtf_id = info.btf_id;\n\t} else if (is_prefix(src, \"id\")) {\n\t\tchar *endptr;\n\n\t\tbtf_id = strtoul(*argv, &endptr, 0);\n\t\tif (*endptr) {\n\t\t\tp_err(\"can't parse %s as ID\", *argv);\n\t\t\treturn -1;\n\t\t}\n\t\tNEXT_ARG();\n\t} else if (is_prefix(src, \"file\")) {\n\t\tconst char sysfs_prefix[] = \"/sys/kernel/btf/\";\n\n\t\tif (!base_btf &&\n\t\t    strncmp(*argv, sysfs_prefix, sizeof(sysfs_prefix) - 1) == 0 &&\n\t\t    strcmp(*argv, sysfs_vmlinux) != 0)\n\t\t\tbase = get_vmlinux_btf_from_sysfs();\n\n\t\tbtf = btf__parse_split(*argv, base ?: base_btf);\n\t\tif (!btf) {\n\t\t\terr = -errno;\n\t\t\tp_err(\"failed to load BTF from %s: %s\",\n\t\t\t      *argv, strerror(errno));\n\t\t\tgoto done;\n\t\t}\n\t\tNEXT_ARG();\n\t} else {\n\t\terr = -1;\n\t\tp_err(\"unrecognized BTF source specifier: '%s'\", src);\n\t\tgoto done;\n\t}\n\n\twhile (argc) {\n\t\tif (is_prefix(*argv, \"format\")) {\n\t\t\tNEXT_ARG();\n\t\t\tif (argc < 1) {\n\t\t\t\tp_err(\"expecting value for 'format' option\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (strcmp(*argv, \"c\") == 0) {\n\t\t\t\tdump_c = true;\n\t\t\t} else if (strcmp(*argv, \"raw\") == 0) {\n\t\t\t\tdump_c = false;\n\t\t\t} else {\n\t\t\t\tp_err(\"unrecognized format specifier: '%s', possible values: raw, c\",\n\t\t\t\t      *argv);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else {\n\t\t\tp_err(\"unrecognized option: '%s'\", *argv);\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!btf) {\n\t\tif (!base_btf && btf_is_kernel_module(btf_id)) {\n\t\t\tp_info(\"Warning: valid base BTF was not specified with -B option, falling back to standard base BTF (%s)\",\n\t\t\t       sysfs_vmlinux);\n\t\t\tbase_btf = get_vmlinux_btf_from_sysfs();\n\t\t}\n\n\t\tbtf = btf__load_from_kernel_by_id_split(btf_id, base_btf);\n\t\tif (!btf) {\n\t\t\terr = -errno;\n\t\t\tp_err(\"get btf by id (%u): %s\", btf_id, strerror(errno));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (dump_c) {\n\t\tif (json_output) {\n\t\t\tp_err(\"JSON output for C-syntax dump is not supported\");\n\t\t\terr = -ENOTSUP;\n\t\t\tgoto done;\n\t\t}\n\t\terr = dump_btf_c(btf, root_type_ids, root_type_cnt);\n\t} else {\n\t\terr = dump_btf_raw(btf, root_type_ids, root_type_cnt);\n\t}\n\ndone:\n\tclose(fd);\n\tbtf__free(btf);\n\tbtf__free(base);\n\treturn err;\n}\n\nstatic int btf_parse_fd(int *argc, char ***argv)\n{\n\tunsigned int id;\n\tchar *endptr;\n\tint fd;\n\n\tif (!is_prefix(*argv[0], \"id\")) {\n\t\tp_err(\"expected 'id', got: '%s'?\", **argv);\n\t\treturn -1;\n\t}\n\tNEXT_ARGP();\n\n\tid = strtoul(**argv, &endptr, 0);\n\tif (*endptr) {\n\t\tp_err(\"can't parse %s as ID\", **argv);\n\t\treturn -1;\n\t}\n\tNEXT_ARGP();\n\n\tfd = bpf_btf_get_fd_by_id(id);\n\tif (fd < 0)\n\t\tp_err(\"can't get BTF object by id (%u): %s\",\n\t\t      id, strerror(errno));\n\n\treturn fd;\n}\n\nstatic int\nbuild_btf_type_table(struct hashmap *tab, enum bpf_obj_type type,\n\t\t     void *info, __u32 *len)\n{\n\tstatic const char * const names[] = {\n\t\t[BPF_OBJ_UNKNOWN]\t= \"unknown\",\n\t\t[BPF_OBJ_PROG]\t\t= \"prog\",\n\t\t[BPF_OBJ_MAP]\t\t= \"map\",\n\t};\n\t__u32 btf_id, id = 0;\n\tint err;\n\tint fd;\n\n\twhile (true) {\n\t\tswitch (type) {\n\t\tcase BPF_OBJ_PROG:\n\t\t\terr = bpf_prog_get_next_id(id, &id);\n\t\t\tbreak;\n\t\tcase BPF_OBJ_MAP:\n\t\t\terr = bpf_map_get_next_id(id, &id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tp_err(\"unexpected object type: %d\", type);\n\t\t\tgoto err_free;\n\t\t}\n\t\tif (err) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_err(\"can't get next %s: %s%s\", names[type],\n\t\t\t      strerror(errno),\n\t\t\t      errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase BPF_OBJ_PROG:\n\t\t\tfd = bpf_prog_get_fd_by_id(id);\n\t\t\tbreak;\n\t\tcase BPF_OBJ_MAP:\n\t\t\tfd = bpf_map_get_fd_by_id(id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tp_err(\"unexpected object type: %d\", type);\n\t\t\tgoto err_free;\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get %s by id (%u): %s\", names[type], id,\n\t\t\t      strerror(errno));\n\t\t\terr = -1;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tmemset(info, 0, *len);\n\t\tif (type == BPF_OBJ_PROG)\n\t\t\terr = bpf_prog_get_info_by_fd(fd, info, len);\n\t\telse\n\t\t\terr = bpf_map_get_info_by_fd(fd, info, len);\n\t\tclose(fd);\n\t\tif (err) {\n\t\t\tp_err(\"can't get %s info: %s\", names[type],\n\t\t\t      strerror(errno));\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase BPF_OBJ_PROG:\n\t\t\tbtf_id = ((struct bpf_prog_info *)info)->btf_id;\n\t\t\tbreak;\n\t\tcase BPF_OBJ_MAP:\n\t\t\tbtf_id = ((struct bpf_map_info *)info)->btf_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tp_err(\"unexpected object type: %d\", type);\n\t\t\tgoto err_free;\n\t\t}\n\t\tif (!btf_id)\n\t\t\tcontinue;\n\n\t\terr = hashmap__append(tab, btf_id, id);\n\t\tif (err) {\n\t\t\tp_err(\"failed to append entry to hashmap for BTF ID %u, object ID %u: %s\",\n\t\t\t      btf_id, id, strerror(-err));\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free:\n\thashmap__free(tab);\n\treturn err;\n}\n\nstatic int\nbuild_btf_tables(struct hashmap *btf_prog_table,\n\t\t struct hashmap *btf_map_table)\n{\n\tstruct bpf_prog_info prog_info;\n\t__u32 prog_len = sizeof(prog_info);\n\tstruct bpf_map_info map_info;\n\t__u32 map_len = sizeof(map_info);\n\tint err = 0;\n\n\terr = build_btf_type_table(btf_prog_table, BPF_OBJ_PROG, &prog_info,\n\t\t\t\t   &prog_len);\n\tif (err)\n\t\treturn err;\n\n\terr = build_btf_type_table(btf_map_table, BPF_OBJ_MAP, &map_info,\n\t\t\t\t   &map_len);\n\tif (err) {\n\t\thashmap__free(btf_prog_table);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nshow_btf_plain(struct bpf_btf_info *info, int fd,\n\t       struct hashmap *btf_prog_table,\n\t       struct hashmap *btf_map_table)\n{\n\tstruct hashmap_entry *entry;\n\tconst char *name = u64_to_ptr(info->name);\n\tint n;\n\n\tprintf(\"%u: \", info->id);\n\tif (info->kernel_btf)\n\t\tprintf(\"name [%s]  \", name);\n\telse if (name && name[0])\n\t\tprintf(\"name %s  \", name);\n\telse\n\t\tprintf(\"name <anon>  \");\n\tprintf(\"size %uB\", info->btf_size);\n\n\tn = 0;\n\thashmap__for_each_key_entry(btf_prog_table, entry, info->id) {\n\t\tprintf(\"%s%lu\", n++ == 0 ? \"  prog_ids \" : \",\", entry->value);\n\t}\n\n\tn = 0;\n\thashmap__for_each_key_entry(btf_map_table, entry, info->id) {\n\t\tprintf(\"%s%lu\", n++ == 0 ? \"  map_ids \" : \",\", entry->value);\n\t}\n\n\temit_obj_refs_plain(refs_table, info->id, \"\\n\\tpids \");\n\n\tprintf(\"\\n\");\n}\n\nstatic void\nshow_btf_json(struct bpf_btf_info *info, int fd,\n\t      struct hashmap *btf_prog_table,\n\t      struct hashmap *btf_map_table)\n{\n\tstruct hashmap_entry *entry;\n\tconst char *name = u64_to_ptr(info->name);\n\n\tjsonw_start_object(json_wtr);\t \n\tjsonw_uint_field(json_wtr, \"id\", info->id);\n\tjsonw_uint_field(json_wtr, \"size\", info->btf_size);\n\n\tjsonw_name(json_wtr, \"prog_ids\");\n\tjsonw_start_array(json_wtr);\t \n\thashmap__for_each_key_entry(btf_prog_table, entry, info->id) {\n\t\tjsonw_uint(json_wtr, entry->value);\n\t}\n\tjsonw_end_array(json_wtr);\t \n\n\tjsonw_name(json_wtr, \"map_ids\");\n\tjsonw_start_array(json_wtr);\t \n\thashmap__for_each_key_entry(btf_map_table, entry, info->id) {\n\t\tjsonw_uint(json_wtr, entry->value);\n\t}\n\tjsonw_end_array(json_wtr);\t \n\n\temit_obj_refs_json(refs_table, info->id, json_wtr);  \n\n\tjsonw_bool_field(json_wtr, \"kernel\", info->kernel_btf);\n\n\tif (name && name[0])\n\t\tjsonw_string_field(json_wtr, \"name\", name);\n\n\tjsonw_end_object(json_wtr);\t \n}\n\nstatic int\nshow_btf(int fd, struct hashmap *btf_prog_table,\n\t struct hashmap *btf_map_table)\n{\n\tstruct bpf_btf_info info;\n\t__u32 len = sizeof(info);\n\tchar name[64];\n\tint err;\n\n\tmemset(&info, 0, sizeof(info));\n\terr = bpf_btf_get_info_by_fd(fd, &info, &len);\n\tif (err) {\n\t\tp_err(\"can't get BTF object info: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\t \n\tif (info.name_len) {\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.name_len = sizeof(name);\n\t\tinfo.name = ptr_to_u64(name);\n\t\tlen = sizeof(info);\n\n\t\terr = bpf_btf_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get BTF object info: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (json_output)\n\t\tshow_btf_json(&info, fd, btf_prog_table, btf_map_table);\n\telse\n\t\tshow_btf_plain(&info, fd, btf_prog_table, btf_map_table);\n\n\treturn 0;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tstruct hashmap *btf_prog_table;\n\tstruct hashmap *btf_map_table;\n\tint err, fd = -1;\n\t__u32 id = 0;\n\n\tif (argc == 2) {\n\t\tfd = btf_parse_fd(&argc, &argv);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (argc) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn BAD_ARG();\n\t}\n\n\tbtf_prog_table = hashmap__new(hash_fn_for_key_as_id,\n\t\t\t\t      equal_fn_for_key_as_id, NULL);\n\tbtf_map_table = hashmap__new(hash_fn_for_key_as_id,\n\t\t\t\t     equal_fn_for_key_as_id, NULL);\n\tif (IS_ERR(btf_prog_table) || IS_ERR(btf_map_table)) {\n\t\thashmap__free(btf_prog_table);\n\t\thashmap__free(btf_map_table);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tp_err(\"failed to create hashmap for object references\");\n\t\treturn -1;\n\t}\n\terr = build_btf_tables(btf_prog_table, btf_map_table);\n\tif (err) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn err;\n\t}\n\tbuild_obj_refs_table(&refs_table, BPF_OBJ_BTF);\n\n\tif (fd >= 0) {\n\t\terr = show_btf(fd, btf_prog_table, btf_map_table);\n\t\tclose(fd);\n\t\tgoto exit_free;\n\t}\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\t \n\n\twhile (true) {\n\t\terr = bpf_btf_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_err(\"can't get next BTF object: %s%s\",\n\t\t\t      strerror(errno),\n\t\t\t      errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfd = bpf_btf_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get BTF object by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = show_btf(fd, btf_prog_table, btf_map_table);\n\t\tclose(fd);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\t \n\nexit_free:\n\thashmap__free(btf_prog_table);\n\thashmap__free(btf_map_table);\n\tdelete_obj_refs_table(refs_table);\n\n\treturn err;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list } [id BTF_ID]\\n\"\n\t\t\"       %1$s %2$s dump BTF_SRC [format FORMAT]\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       BTF_SRC := { id BTF_ID | prog PROG | map MAP [{key | value | kv | all}] | file FILE }\\n\"\n\t\t\"       FORMAT  := { raw | c }\\n\"\n\t\t\"       \" HELP_SPEC_MAP \"\\n\"\n\t\t\"       \" HELP_SPEC_PROGRAM \"\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-B|--base-btf} }\\n\"\n\t\t\"\",\n\t\tbin_name, \"btf\");\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"help\",\tdo_help },\n\t{ \"dump\",\tdo_dump },\n\t{ 0 }\n};\n\nint do_btf(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}