{
  "module_name": "struct_ops.c",
  "hash_id": "6b87d28f9bca8bfde6ef02a946323eebef7c1c2cee4e658a9919383d6780773f",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/struct_ops.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <linux/err.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\n#define STRUCT_OPS_VALUE_PREFIX \"bpf_struct_ops_\"\n\nstatic const struct btf_type *map_info_type;\nstatic __u32 map_info_alloc_len;\nstatic struct btf *btf_vmlinux;\nstatic __s32 map_info_type_id;\n\nstruct res {\n\tunsigned int nr_maps;\n\tunsigned int nr_errs;\n};\n\nstatic const struct btf *get_btf_vmlinux(void)\n{\n\tif (btf_vmlinux)\n\t\treturn btf_vmlinux;\n\n\tbtf_vmlinux = libbpf_find_kernel_btf();\n\tif (!btf_vmlinux)\n\t\tp_err(\"struct_ops requires kernel CONFIG_DEBUG_INFO_BTF=y\");\n\n\treturn btf_vmlinux;\n}\n\nstatic const char *get_kern_struct_ops_name(const struct bpf_map_info *info)\n{\n\tconst struct btf *kern_btf;\n\tconst struct btf_type *t;\n\tconst char *st_ops_name;\n\n\tkern_btf = get_btf_vmlinux();\n\tif (!kern_btf)\n\t\treturn \"<btf_vmlinux_not_found>\";\n\n\tt = btf__type_by_id(kern_btf, info->btf_vmlinux_value_type_id);\n\tst_ops_name = btf__name_by_offset(kern_btf, t->name_off);\n\tst_ops_name += strlen(STRUCT_OPS_VALUE_PREFIX);\n\n\treturn st_ops_name;\n}\n\nstatic __s32 get_map_info_type_id(void)\n{\n\tconst struct btf *kern_btf;\n\n\tif (map_info_type_id)\n\t\treturn map_info_type_id;\n\n\tkern_btf = get_btf_vmlinux();\n\tif (!kern_btf)\n\t\treturn 0;\n\n\tmap_info_type_id = btf__find_by_name_kind(kern_btf, \"bpf_map_info\",\n\t\t\t\t\t\t  BTF_KIND_STRUCT);\n\tif (map_info_type_id < 0) {\n\t\tp_err(\"can't find bpf_map_info from btf_vmlinux\");\n\t\treturn map_info_type_id;\n\t}\n\tmap_info_type = btf__type_by_id(kern_btf, map_info_type_id);\n\n\t \n\tmap_info_alloc_len = map_info_type->size;\n\tif (map_info_alloc_len < sizeof(struct bpf_map_info))\n\t\tmap_info_alloc_len = sizeof(struct bpf_map_info);\n\n\treturn map_info_type_id;\n}\n\n \nstatic struct bpf_map_info *map_info_alloc(__u32 *alloc_len)\n{\n\tstruct bpf_map_info *info;\n\n\tif (get_map_info_type_id() < 0)\n\t\treturn NULL;\n\n\tinfo = calloc(1, map_info_alloc_len);\n\tif (!info)\n\t\tp_err(\"mem alloc failed\");\n\telse\n\t\t*alloc_len = map_info_alloc_len;\n\n\treturn info;\n}\n\n \nstatic int get_next_struct_ops_map(const char *name, int *res_fd,\n\t\t\t\t   struct bpf_map_info *info, __u32 info_len)\n{\n\t__u32 id = info->id;\n\tint err, fd;\n\n\twhile (true) {\n\t\terr = bpf_map_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\treturn 0;\n\t\t\tp_err(\"can't get next map: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tfd = bpf_map_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get map by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = bpf_map_get_info_by_fd(fd, info, &info_len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (info->type == BPF_MAP_TYPE_STRUCT_OPS &&\n\t\t    (!name || !strcmp(name, info->name))) {\n\t\t\t*res_fd = fd;\n\t\t\treturn 1;\n\t\t}\n\t\tclose(fd);\n\t}\n}\n\nstatic int cmd_retval(const struct res *res, bool must_have_one_map)\n{\n\tif (res->nr_errs || (!res->nr_maps && must_have_one_map))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \ntypedef int (*work_func)(int fd, const struct bpf_map_info *info, void *data,\n\t\t\t struct json_writer *wtr);\n\n \nstatic struct res do_search(const char *name, work_func func, void *data,\n\t\t\t    struct json_writer *wtr)\n{\n\tstruct bpf_map_info *info;\n\tstruct res res = {};\n\t__u32 info_len;\n\tint fd, err;\n\n\tinfo = map_info_alloc(&info_len);\n\tif (!info) {\n\t\tres.nr_errs++;\n\t\treturn res;\n\t}\n\n\tif (wtr)\n\t\tjsonw_start_array(wtr);\n\twhile ((err = get_next_struct_ops_map(name, &fd, info, info_len)) == 1) {\n\t\tres.nr_maps++;\n\t\terr = func(fd, info, data, wtr);\n\t\tif (err)\n\t\t\tres.nr_errs++;\n\t\tclose(fd);\n\t}\n\tif (wtr)\n\t\tjsonw_end_array(wtr);\n\n\tif (err)\n\t\tres.nr_errs++;\n\n\tif (!wtr && name && !res.nr_errs && !res.nr_maps)\n\t\t \n\t\tp_err(\"no struct_ops found for %s\", name);\n\telse if (!wtr && json_output && !res.nr_errs)\n\t\t \n\t\tjsonw_null(json_wtr);\n\n\tfree(info);\n\treturn res;\n}\n\nstatic struct res do_one_id(const char *id_str, work_func func, void *data,\n\t\t\t    struct json_writer *wtr)\n{\n\tstruct bpf_map_info *info;\n\tstruct res res = {};\n\tunsigned long id;\n\t__u32 info_len;\n\tchar *endptr;\n\tint fd;\n\n\tid = strtoul(id_str, &endptr, 0);\n\tif (*endptr || !id || id > UINT32_MAX) {\n\t\tp_err(\"invalid id %s\", id_str);\n\t\tres.nr_errs++;\n\t\treturn res;\n\t}\n\n\tfd = bpf_map_get_fd_by_id(id);\n\tif (fd < 0) {\n\t\tp_err(\"can't get map by id (%lu): %s\", id, strerror(errno));\n\t\tres.nr_errs++;\n\t\treturn res;\n\t}\n\n\tinfo = map_info_alloc(&info_len);\n\tif (!info) {\n\t\tres.nr_errs++;\n\t\tgoto done;\n\t}\n\n\tif (bpf_map_get_info_by_fd(fd, info, &info_len)) {\n\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\tres.nr_errs++;\n\t\tgoto done;\n\t}\n\n\tif (info->type != BPF_MAP_TYPE_STRUCT_OPS) {\n\t\tp_err(\"%s id %u is not a struct_ops map\", info->name, info->id);\n\t\tres.nr_errs++;\n\t\tgoto done;\n\t}\n\n\tres.nr_maps++;\n\n\tif (func(fd, info, data, wtr))\n\t\tres.nr_errs++;\n\telse if (!wtr && json_output)\n\t\t \n\t\tjsonw_null(json_wtr);\n\ndone:\n\tfree(info);\n\tclose(fd);\n\n\treturn res;\n}\n\nstatic struct res do_work_on_struct_ops(const char *search_type,\n\t\t\t\t\tconst char *search_term,\n\t\t\t\t\twork_func func, void *data,\n\t\t\t\t\tstruct json_writer *wtr)\n{\n\tif (search_type) {\n\t\tif (is_prefix(search_type, \"id\"))\n\t\t\treturn do_one_id(search_term, func, data, wtr);\n\t\telse if (!is_prefix(search_type, \"name\"))\n\t\t\tusage();\n\t}\n\n\treturn do_search(search_term, func, data, wtr);\n}\n\nstatic int __do_show(int fd, const struct bpf_map_info *info, void *data,\n\t\t     struct json_writer *wtr)\n{\n\tif (wtr) {\n\t\tjsonw_start_object(wtr);\n\t\tjsonw_uint_field(wtr, \"id\", info->id);\n\t\tjsonw_string_field(wtr, \"name\", info->name);\n\t\tjsonw_string_field(wtr, \"kernel_struct_ops\",\n\t\t\t\t   get_kern_struct_ops_name(info));\n\t\tjsonw_end_object(wtr);\n\t} else {\n\t\tprintf(\"%u: %-15s %-32s\\n\", info->id, info->name,\n\t\t       get_kern_struct_ops_name(info));\n\t}\n\n\treturn 0;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tconst char *search_type = NULL, *search_term = NULL;\n\tstruct res res;\n\n\tif (argc && argc != 2)\n\t\tusage();\n\n\tif (argc == 2) {\n\t\tsearch_type = GET_ARG();\n\t\tsearch_term = GET_ARG();\n\t}\n\n\tres = do_work_on_struct_ops(search_type, search_term, __do_show,\n\t\t\t\t    NULL, json_wtr);\n\n\treturn cmd_retval(&res, !!search_term);\n}\n\nstatic int __do_dump(int fd, const struct bpf_map_info *info, void *data,\n\t\t     struct json_writer *wtr)\n{\n\tstruct btf_dumper *d = (struct btf_dumper *)data;\n\tconst struct btf_type *struct_ops_type;\n\tconst struct btf *kern_btf = d->btf;\n\tconst char *struct_ops_name;\n\tint zero = 0;\n\tvoid *value;\n\n\t \n\n\tkern_btf = d->btf;\n\n\t \n\tstruct_ops_type = btf__type_by_id(kern_btf,\n\t\t\t\t\t  info->btf_vmlinux_value_type_id);\n\tstruct_ops_name = btf__name_by_offset(kern_btf,\n\t\t\t\t\t      struct_ops_type->name_off);\n\tvalue = calloc(1, info->value_size);\n\tif (!value) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\n\tif (bpf_map_lookup_elem(fd, &zero, value)) {\n\t\tp_err(\"can't lookup struct_ops map %s id %u\",\n\t\t      info->name, info->id);\n\t\tfree(value);\n\t\treturn -1;\n\t}\n\n\tjsonw_start_object(wtr);\n\tjsonw_name(wtr, \"bpf_map_info\");\n\tbtf_dumper_type(d, map_info_type_id, (void *)info);\n\tjsonw_end_object(wtr);\n\n\tjsonw_start_object(wtr);\n\tjsonw_name(wtr, struct_ops_name);\n\tbtf_dumper_type(d, info->btf_vmlinux_value_type_id, value);\n\tjsonw_end_object(wtr);\n\n\tfree(value);\n\n\treturn 0;\n}\n\nstatic int do_dump(int argc, char **argv)\n{\n\tconst char *search_type = NULL, *search_term = NULL;\n\tjson_writer_t *wtr = json_wtr;\n\tconst struct btf *kern_btf;\n\tstruct btf_dumper d = {};\n\tstruct res res;\n\n\tif (argc && argc != 2)\n\t\tusage();\n\n\tif (argc == 2) {\n\t\tsearch_type = GET_ARG();\n\t\tsearch_term = GET_ARG();\n\t}\n\n\tkern_btf = get_btf_vmlinux();\n\tif (!kern_btf)\n\t\treturn -1;\n\n\tif (!json_output) {\n\t\twtr = jsonw_new(stdout);\n\t\tif (!wtr) {\n\t\t\tp_err(\"can't create json writer\");\n\t\t\treturn -1;\n\t\t}\n\t\tjsonw_pretty(wtr, true);\n\t}\n\n\td.btf = kern_btf;\n\td.jw = wtr;\n\td.is_plain_text = !json_output;\n\td.prog_id_as_func_ptr = true;\n\n\tres = do_work_on_struct_ops(search_type, search_term, __do_dump, &d,\n\t\t\t\t    wtr);\n\n\tif (!json_output)\n\t\tjsonw_destroy(&wtr);\n\n\treturn cmd_retval(&res, !!search_term);\n}\n\nstatic int __do_unregister(int fd, const struct bpf_map_info *info, void *data,\n\t\t\t   struct json_writer *wtr)\n{\n\tint zero = 0;\n\n\tif (bpf_map_delete_elem(fd, &zero)) {\n\t\tp_err(\"can't unload %s %s id %u: %s\",\n\t\t      get_kern_struct_ops_name(info), info->name,\n\t\t      info->id, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tp_info(\"Unregistered %s %s id %u\",\n\t       get_kern_struct_ops_name(info), info->name,\n\t       info->id);\n\n\treturn 0;\n}\n\nstatic int do_unregister(int argc, char **argv)\n{\n\tconst char *search_type, *search_term;\n\tstruct res res;\n\n\tif (argc != 2)\n\t\tusage();\n\n\tsearch_type = GET_ARG();\n\tsearch_term = GET_ARG();\n\n\tres = do_work_on_struct_ops(search_type, search_term,\n\t\t\t\t    __do_unregister, NULL, NULL);\n\n\treturn cmd_retval(&res, true);\n}\n\nstatic int pin_link(struct bpf_link *link, const char *pindir,\n\t\t    const char *name)\n{\n\tchar pinfile[PATH_MAX];\n\tint err;\n\n\terr = pathname_concat(pinfile, sizeof(pinfile), pindir, name);\n\tif (err)\n\t\treturn -1;\n\n\treturn bpf_link__pin(link, pinfile);\n}\n\nstatic int do_register(int argc, char **argv)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, open_opts);\n\t__u32 link_info_len = sizeof(struct bpf_link_info);\n\tstruct bpf_link_info link_info = {};\n\tstruct bpf_map_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint nr_errs = 0, nr_maps = 0;\n\tconst char *linkdir = NULL;\n\tstruct bpf_object *obj;\n\tstruct bpf_link *link;\n\tstruct bpf_map *map;\n\tconst char *file;\n\n\tif (argc != 1 && argc != 2)\n\t\tusage();\n\n\tfile = GET_ARG();\n\tif (argc == 1)\n\t\tlinkdir = GET_ARG();\n\n\tif (linkdir && mount_bpffs_for_pin(linkdir, true)) {\n\t\tp_err(\"can't mount bpffs for pinning\");\n\t\treturn -1;\n\t}\n\n\tif (verifier_logs)\n\t\t \n\t\topen_opts.kernel_log_level = 1 + 2 + 4;\n\n\tobj = bpf_object__open_file(file, &open_opts);\n\tif (!obj)\n\t\treturn -1;\n\n\tset_max_rlimit();\n\n\tif (bpf_object__load(obj)) {\n\t\tbpf_object__close(obj);\n\t\treturn -1;\n\t}\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (bpf_map__type(map) != BPF_MAP_TYPE_STRUCT_OPS)\n\t\t\tcontinue;\n\n\t\tlink = bpf_map__attach_struct_ops(map);\n\t\tif (!link) {\n\t\t\tp_err(\"can't register struct_ops %s: %s\",\n\t\t\t      bpf_map__name(map), strerror(errno));\n\t\t\tnr_errs++;\n\t\t\tcontinue;\n\t\t}\n\t\tnr_maps++;\n\n\t\tif (bpf_map_get_info_by_fd(bpf_map__fd(map), &info,\n\t\t\t\t\t   &info_len)) {\n\t\t\t \n\t\t\tp_info(\"Registered %s but can't find id: %s\",\n\t\t\t       bpf_map__name(map), strerror(errno));\n\t\t\tgoto clean_link;\n\t\t}\n\t\tif (!(bpf_map__map_flags(map) & BPF_F_LINK)) {\n\t\t\tp_info(\"Registered %s %s id %u\",\n\t\t\t       get_kern_struct_ops_name(&info),\n\t\t\t       info.name,\n\t\t\t       info.id);\n\t\t\tgoto clean_link;\n\t\t}\n\t\tif (bpf_link_get_info_by_fd(bpf_link__fd(link),\n\t\t\t\t\t    &link_info,\n\t\t\t\t\t    &link_info_len)) {\n\t\t\tp_err(\"Registered %s but can't find link id: %s\",\n\t\t\t      bpf_map__name(map), strerror(errno));\n\t\t\tnr_errs++;\n\t\t\tgoto clean_link;\n\t\t}\n\t\tif (linkdir && pin_link(link, linkdir, info.name)) {\n\t\t\tp_err(\"can't pin link %u for %s: %s\",\n\t\t\t      link_info.id, info.name,\n\t\t\t      strerror(errno));\n\t\t\tnr_errs++;\n\t\t\tgoto clean_link;\n\t\t}\n\t\tp_info(\"Registered %s %s map id %u link id %u\",\n\t\t       get_kern_struct_ops_name(&info),\n\t\t       info.name, info.id, link_info.id);\n\nclean_link:\n\t\tbpf_link__disconnect(link);\n\t\tbpf_link__destroy(link);\n\t}\n\n\tbpf_object__close(obj);\n\n\tif (nr_errs)\n\t\treturn -1;\n\n\tif (!nr_maps) {\n\t\tp_err(\"no struct_ops found in %s\", file);\n\t\treturn -1;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\treturn 0;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list } [STRUCT_OPS_MAP]\\n\"\n\t\t\"       %1$s %2$s dump [STRUCT_OPS_MAP]\\n\"\n\t\t\"       %1$s %2$s register OBJ [LINK_DIR]\\n\"\n\t\t\"       %1$s %2$s unregister STRUCT_OPS_MAP\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       STRUCT_OPS_MAP := [ id STRUCT_OPS_MAP_ID | name STRUCT_OPS_MAP_NAME ]\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"register\",\tdo_register },\n\t{ \"unregister\",\tdo_unregister },\n\t{ \"dump\",\tdo_dump },\n\t{ \"help\",\tdo_help },\n\t{ 0 }\n};\n\nint do_struct_ops(int argc, char **argv)\n{\n\tint err;\n\n\terr = cmd_select(cmds, argc, argv, do_help);\n\n\tbtf__free(btf_vmlinux);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}