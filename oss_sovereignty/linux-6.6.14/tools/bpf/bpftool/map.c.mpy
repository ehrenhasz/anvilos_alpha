{
  "module_name": "map.c",
  "hash_id": "d88400aeb2c5c5534e0b976b18bd4041edf042956e96d1a88c4e565ed3a840a1",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/map.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <net/if.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/hashmap.h>\n\n#include \"json_writer.h\"\n#include \"main.h\"\n\nstatic struct hashmap *map_table;\n\nstatic bool map_is_per_cpu(__u32 type)\n{\n\treturn type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t       type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t       type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t       type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE;\n}\n\nstatic bool map_is_map_of_maps(__u32 type)\n{\n\treturn type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||\n\t       type == BPF_MAP_TYPE_HASH_OF_MAPS;\n}\n\nstatic bool map_is_map_of_progs(__u32 type)\n{\n\treturn type == BPF_MAP_TYPE_PROG_ARRAY;\n}\n\nstatic int map_type_from_str(const char *type)\n{\n\tconst char *map_type_str;\n\tunsigned int i;\n\n\tfor (i = 0; ; i++) {\n\t\tmap_type_str = libbpf_bpf_map_type_str(i);\n\t\tif (!map_type_str)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!strcmp(map_type_str, type))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic void *alloc_value(struct bpf_map_info *info)\n{\n\tif (map_is_per_cpu(info->type))\n\t\treturn malloc(round_up(info->value_size, 8) *\n\t\t\t      get_possible_cpus());\n\telse\n\t\treturn malloc(info->value_size);\n}\n\nstatic int do_dump_btf(const struct btf_dumper *d,\n\t\t       struct bpf_map_info *map_info, void *key,\n\t\t       void *value)\n{\n\t__u32 value_id;\n\tint ret = 0;\n\n\t \n\tjsonw_start_object(d->jw);\n\n\tif (map_info->btf_key_type_id) {\n\t\tjsonw_name(d->jw, \"key\");\n\n\t\tret = btf_dumper_type(d, map_info->btf_key_type_id, key);\n\t\tif (ret)\n\t\t\tgoto err_end_obj;\n\t}\n\n\tvalue_id = map_info->btf_vmlinux_value_type_id ?\n\t\t: map_info->btf_value_type_id;\n\n\tif (!map_is_per_cpu(map_info->type)) {\n\t\tjsonw_name(d->jw, \"value\");\n\t\tret = btf_dumper_type(d, value_id, value);\n\t} else {\n\t\tunsigned int i, n, step;\n\n\t\tjsonw_name(d->jw, \"values\");\n\t\tjsonw_start_array(d->jw);\n\t\tn = get_possible_cpus();\n\t\tstep = round_up(map_info->value_size, 8);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tjsonw_start_object(d->jw);\n\t\t\tjsonw_int_field(d->jw, \"cpu\", i);\n\t\t\tjsonw_name(d->jw, \"value\");\n\t\t\tret = btf_dumper_type(d, value_id, value + i * step);\n\t\t\tjsonw_end_object(d->jw);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tjsonw_end_array(d->jw);\n\t}\n\nerr_end_obj:\n\t \n\tjsonw_end_object(d->jw);\n\n\treturn ret;\n}\n\nstatic json_writer_t *get_btf_writer(void)\n{\n\tjson_writer_t *jw = jsonw_new(stdout);\n\n\tif (!jw)\n\t\treturn NULL;\n\tjsonw_pretty(jw, true);\n\n\treturn jw;\n}\n\nstatic void print_entry_json(struct bpf_map_info *info, unsigned char *key,\n\t\t\t     unsigned char *value, struct btf *btf)\n{\n\tjsonw_start_object(json_wtr);\n\n\tif (!map_is_per_cpu(info->type)) {\n\t\tjsonw_name(json_wtr, \"key\");\n\t\tprint_hex_data_json(key, info->key_size);\n\t\tjsonw_name(json_wtr, \"value\");\n\t\tprint_hex_data_json(value, info->value_size);\n\t\tif (map_is_map_of_maps(info->type))\n\t\t\tjsonw_uint_field(json_wtr, \"inner_map_id\",\n\t\t\t\t\t *(unsigned int *)value);\n\t\tif (btf) {\n\t\t\tstruct btf_dumper d = {\n\t\t\t\t.btf = btf,\n\t\t\t\t.jw = json_wtr,\n\t\t\t\t.is_plain_text = false,\n\t\t\t};\n\n\t\t\tjsonw_name(json_wtr, \"formatted\");\n\t\t\tdo_dump_btf(&d, info, key, value);\n\t\t}\n\t} else {\n\t\tunsigned int i, n, step;\n\n\t\tn = get_possible_cpus();\n\t\tstep = round_up(info->value_size, 8);\n\n\t\tjsonw_name(json_wtr, \"key\");\n\t\tprint_hex_data_json(key, info->key_size);\n\n\t\tjsonw_name(json_wtr, \"values\");\n\t\tjsonw_start_array(json_wtr);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tjsonw_start_object(json_wtr);\n\n\t\t\tjsonw_int_field(json_wtr, \"cpu\", i);\n\n\t\t\tjsonw_name(json_wtr, \"value\");\n\t\t\tprint_hex_data_json(value + i * step,\n\t\t\t\t\t    info->value_size);\n\n\t\t\tjsonw_end_object(json_wtr);\n\t\t}\n\t\tjsonw_end_array(json_wtr);\n\t\tif (btf) {\n\t\t\tstruct btf_dumper d = {\n\t\t\t\t.btf = btf,\n\t\t\t\t.jw = json_wtr,\n\t\t\t\t.is_plain_text = false,\n\t\t\t};\n\n\t\t\tjsonw_name(json_wtr, \"formatted\");\n\t\t\tdo_dump_btf(&d, info, key, value);\n\t\t}\n\t}\n\n\tjsonw_end_object(json_wtr);\n}\n\nstatic void\nprint_entry_error_msg(struct bpf_map_info *info, unsigned char *key,\n\t\t      const char *error_msg)\n{\n\tint msg_size = strlen(error_msg);\n\tbool single_line, break_names;\n\n\tbreak_names = info->key_size > 16 || msg_size > 16;\n\tsingle_line = info->key_size + msg_size <= 24 && !break_names;\n\n\tprintf(\"key:%c\", break_names ? '\\n' : ' ');\n\tfprint_hex(stdout, key, info->key_size, \" \");\n\n\tprintf(single_line ? \"  \" : \"\\n\");\n\n\tprintf(\"value:%c%s\", break_names ? '\\n' : ' ', error_msg);\n\n\tprintf(\"\\n\");\n}\n\nstatic void\nprint_entry_error(struct bpf_map_info *map_info, void *key, int lookup_errno)\n{\n\t \n\tif ((map_is_map_of_maps(map_info->type) ||\n\t     map_is_map_of_progs(map_info->type)) && lookup_errno == ENOENT)\n\t\treturn;\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\t \n\t\tjsonw_name(json_wtr, \"key\");\n\t\tprint_hex_data_json(key, map_info->key_size);\n\t\tjsonw_name(json_wtr, \"value\");\n\t\tjsonw_start_object(json_wtr);\t \n\t\tjsonw_string_field(json_wtr, \"error\", strerror(lookup_errno));\n\t\tjsonw_end_object(json_wtr);\t \n\t\tjsonw_end_object(json_wtr);\t \n\t} else {\n\t\tconst char *msg = NULL;\n\n\t\tif (lookup_errno == ENOENT)\n\t\t\tmsg = \"<no entry>\";\n\t\telse if (lookup_errno == ENOSPC &&\n\t\t\t map_info->type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY)\n\t\t\tmsg = \"<cannot read>\";\n\n\t\tprint_entry_error_msg(map_info, key,\n\t\t\t\t      msg ? : strerror(lookup_errno));\n\t}\n}\n\nstatic void print_entry_plain(struct bpf_map_info *info, unsigned char *key,\n\t\t\t      unsigned char *value)\n{\n\tif (!map_is_per_cpu(info->type)) {\n\t\tbool single_line, break_names;\n\n\t\tbreak_names = info->key_size > 16 || info->value_size > 16;\n\t\tsingle_line = info->key_size + info->value_size <= 24 &&\n\t\t\t!break_names;\n\n\t\tif (info->key_size) {\n\t\t\tprintf(\"key:%c\", break_names ? '\\n' : ' ');\n\t\t\tfprint_hex(stdout, key, info->key_size, \" \");\n\n\t\t\tprintf(single_line ? \"  \" : \"\\n\");\n\t\t}\n\n\t\tif (info->value_size) {\n\t\t\tif (map_is_map_of_maps(info->type)) {\n\t\t\t\tprintf(\"inner_map_id:%c\", break_names ? '\\n' : ' ');\n\t\t\t\tprintf(\"%u \", *(unsigned int *)value);\n\t\t\t} else {\n\t\t\t\tprintf(\"value:%c\", break_names ? '\\n' : ' ');\n\t\t\t\tfprint_hex(stdout, value, info->value_size, \" \");\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tunsigned int i, n, step;\n\n\t\tn = get_possible_cpus();\n\t\tstep = round_up(info->value_size, 8);\n\n\t\tif (info->key_size) {\n\t\t\tprintf(\"key:\\n\");\n\t\t\tfprint_hex(stdout, key, info->key_size, \" \");\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tif (info->value_size) {\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tprintf(\"value (CPU %02d):%c\",\n\t\t\t\t       i, info->value_size > 16 ? '\\n' : ' ');\n\t\t\t\tfprint_hex(stdout, value + i * step,\n\t\t\t\t\t   info->value_size, \" \");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic char **parse_bytes(char **argv, const char *name, unsigned char *val,\n\t\t\t  unsigned int n)\n{\n\tunsigned int i = 0, base = 0;\n\tchar *endptr;\n\n\tif (is_prefix(*argv, \"hex\")) {\n\t\tbase = 16;\n\t\targv++;\n\t}\n\n\twhile (i < n && argv[i]) {\n\t\tval[i] = strtoul(argv[i], &endptr, base);\n\t\tif (*endptr) {\n\t\t\tp_err(\"error parsing byte: %s\", argv[i]);\n\t\t\treturn NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (i != n) {\n\t\tp_err(\"%s expected %d bytes got %d\", name, n, i);\n\t\treturn NULL;\n\t}\n\n\treturn argv + i;\n}\n\n \nstatic void fill_per_cpu_value(struct bpf_map_info *info, void *value)\n{\n\tunsigned int i, n, step;\n\n\tif (!map_is_per_cpu(info->type))\n\t\treturn;\n\n\tn = get_possible_cpus();\n\tstep = round_up(info->value_size, 8);\n\tfor (i = 1; i < n; i++)\n\t\tmemcpy(value + i * step, value, info->value_size);\n}\n\nstatic int parse_elem(char **argv, struct bpf_map_info *info,\n\t\t      void *key, void *value, __u32 key_size, __u32 value_size,\n\t\t      __u32 *flags, __u32 **value_fd)\n{\n\tif (!*argv) {\n\t\tif (!key && !value)\n\t\t\treturn 0;\n\t\tp_err(\"did not find %s\", key ? \"key\" : \"value\");\n\t\treturn -1;\n\t}\n\n\tif (is_prefix(*argv, \"key\")) {\n\t\tif (!key) {\n\t\t\tif (key_size)\n\t\t\t\tp_err(\"duplicate key\");\n\t\t\telse\n\t\t\t\tp_err(\"unnecessary key\");\n\t\t\treturn -1;\n\t\t}\n\n\t\targv = parse_bytes(argv + 1, \"key\", key, key_size);\n\t\tif (!argv)\n\t\t\treturn -1;\n\n\t\treturn parse_elem(argv, info, NULL, value, key_size, value_size,\n\t\t\t\t  flags, value_fd);\n\t} else if (is_prefix(*argv, \"value\")) {\n\t\tint fd;\n\n\t\tif (!value) {\n\t\t\tif (value_size)\n\t\t\t\tp_err(\"duplicate value\");\n\t\t\telse\n\t\t\t\tp_err(\"unnecessary value\");\n\t\t\treturn -1;\n\t\t}\n\n\t\targv++;\n\n\t\tif (map_is_map_of_maps(info->type)) {\n\t\t\tint argc = 2;\n\n\t\t\tif (value_size != 4) {\n\t\t\t\tp_err(\"value smaller than 4B for map in map?\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!argv[0] || !argv[1]) {\n\t\t\t\tp_err(\"not enough value arguments for map in map\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfd = map_parse_fd(&argc, &argv);\n\t\t\tif (fd < 0)\n\t\t\t\treturn -1;\n\n\t\t\t*value_fd = value;\n\t\t\t**value_fd = fd;\n\t\t} else if (map_is_map_of_progs(info->type)) {\n\t\t\tint argc = 2;\n\n\t\t\tif (value_size != 4) {\n\t\t\t\tp_err(\"value smaller than 4B for map of progs?\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!argv[0] || !argv[1]) {\n\t\t\t\tp_err(\"not enough value arguments for map of progs\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (is_prefix(*argv, \"id\"))\n\t\t\t\tp_info(\"Warning: updating program array via MAP_ID, make sure this map is kept open\\n\"\n\t\t\t\t       \"         by some process or pinned otherwise update will be lost\");\n\n\t\t\tfd = prog_parse_fd(&argc, &argv);\n\t\t\tif (fd < 0)\n\t\t\t\treturn -1;\n\n\t\t\t*value_fd = value;\n\t\t\t**value_fd = fd;\n\t\t} else {\n\t\t\targv = parse_bytes(argv, \"value\", value, value_size);\n\t\t\tif (!argv)\n\t\t\t\treturn -1;\n\n\t\t\tfill_per_cpu_value(info, value);\n\t\t}\n\n\t\treturn parse_elem(argv, info, key, NULL, key_size, value_size,\n\t\t\t\t  flags, NULL);\n\t} else if (is_prefix(*argv, \"any\") || is_prefix(*argv, \"noexist\") ||\n\t\t   is_prefix(*argv, \"exist\")) {\n\t\tif (!flags) {\n\t\t\tp_err(\"flags specified multiple times: %s\", *argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_prefix(*argv, \"any\"))\n\t\t\t*flags = BPF_ANY;\n\t\telse if (is_prefix(*argv, \"noexist\"))\n\t\t\t*flags = BPF_NOEXIST;\n\t\telse if (is_prefix(*argv, \"exist\"))\n\t\t\t*flags = BPF_EXIST;\n\n\t\treturn parse_elem(argv + 1, info, key, value, key_size,\n\t\t\t\t  value_size, NULL, value_fd);\n\t}\n\n\tp_err(\"expected key or value, got: %s\", *argv);\n\treturn -1;\n}\n\nstatic void show_map_header_json(struct bpf_map_info *info, json_writer_t *wtr)\n{\n\tconst char *map_type_str;\n\n\tjsonw_uint_field(wtr, \"id\", info->id);\n\tmap_type_str = libbpf_bpf_map_type_str(info->type);\n\tif (map_type_str)\n\t\tjsonw_string_field(wtr, \"type\", map_type_str);\n\telse\n\t\tjsonw_uint_field(wtr, \"type\", info->type);\n\n\tif (*info->name)\n\t\tjsonw_string_field(wtr, \"name\", info->name);\n\n\tjsonw_name(wtr, \"flags\");\n\tjsonw_printf(wtr, \"%d\", info->map_flags);\n}\n\nstatic int show_map_close_json(int fd, struct bpf_map_info *info)\n{\n\tchar *memlock, *frozen_str;\n\tint frozen = 0;\n\n\tmemlock = get_fdinfo(fd, \"memlock\");\n\tfrozen_str = get_fdinfo(fd, \"frozen\");\n\n\tjsonw_start_object(json_wtr);\n\n\tshow_map_header_json(info, json_wtr);\n\n\tprint_dev_json(info->ifindex, info->netns_dev, info->netns_ino);\n\n\tjsonw_uint_field(json_wtr, \"bytes_key\", info->key_size);\n\tjsonw_uint_field(json_wtr, \"bytes_value\", info->value_size);\n\tjsonw_uint_field(json_wtr, \"max_entries\", info->max_entries);\n\n\tif (memlock)\n\t\tjsonw_int_field(json_wtr, \"bytes_memlock\", atoll(memlock));\n\tfree(memlock);\n\n\tif (info->type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tchar *owner_prog_type = get_fdinfo(fd, \"owner_prog_type\");\n\t\tchar *owner_jited = get_fdinfo(fd, \"owner_jited\");\n\n\t\tif (owner_prog_type) {\n\t\t\tunsigned int prog_type = atoi(owner_prog_type);\n\t\t\tconst char *prog_type_str;\n\n\t\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_type);\n\t\t\tif (prog_type_str)\n\t\t\t\tjsonw_string_field(json_wtr, \"owner_prog_type\",\n\t\t\t\t\t\t   prog_type_str);\n\t\t\telse\n\t\t\t\tjsonw_uint_field(json_wtr, \"owner_prog_type\",\n\t\t\t\t\t\t prog_type);\n\t\t}\n\t\tif (owner_jited)\n\t\t\tjsonw_bool_field(json_wtr, \"owner_jited\",\n\t\t\t\t\t !!atoi(owner_jited));\n\n\t\tfree(owner_prog_type);\n\t\tfree(owner_jited);\n\t}\n\tclose(fd);\n\n\tif (frozen_str) {\n\t\tfrozen = atoi(frozen_str);\n\t\tfree(frozen_str);\n\t}\n\tjsonw_int_field(json_wtr, \"frozen\", frozen);\n\n\tif (info->btf_id)\n\t\tjsonw_int_field(json_wtr, \"btf_id\", info->btf_id);\n\n\tif (!hashmap__empty(map_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\tjsonw_name(json_wtr, \"pinned\");\n\t\tjsonw_start_array(json_wtr);\n\t\thashmap__for_each_key_entry(map_table, entry, info->id)\n\t\t\tjsonw_string(json_wtr, entry->pvalue);\n\t\tjsonw_end_array(json_wtr);\n\t}\n\n\temit_obj_refs_json(refs_table, info->id, json_wtr);\n\n\tjsonw_end_object(json_wtr);\n\n\treturn 0;\n}\n\nstatic void show_map_header_plain(struct bpf_map_info *info)\n{\n\tconst char *map_type_str;\n\n\tprintf(\"%u: \", info->id);\n\n\tmap_type_str = libbpf_bpf_map_type_str(info->type);\n\tif (map_type_str)\n\t\tprintf(\"%s  \", map_type_str);\n\telse\n\t\tprintf(\"type %u  \", info->type);\n\n\tif (*info->name)\n\t\tprintf(\"name %s  \", info->name);\n\n\tprintf(\"flags 0x%x\", info->map_flags);\n\tprint_dev_plain(info->ifindex, info->netns_dev, info->netns_ino);\n\tprintf(\"\\n\");\n}\n\nstatic int show_map_close_plain(int fd, struct bpf_map_info *info)\n{\n\tchar *memlock, *frozen_str;\n\tint frozen = 0;\n\n\tmemlock = get_fdinfo(fd, \"memlock\");\n\tfrozen_str = get_fdinfo(fd, \"frozen\");\n\n\tshow_map_header_plain(info);\n\tprintf(\"\\tkey %uB  value %uB  max_entries %u\",\n\t       info->key_size, info->value_size, info->max_entries);\n\n\tif (memlock)\n\t\tprintf(\"  memlock %sB\", memlock);\n\tfree(memlock);\n\n\tif (info->type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tchar *owner_prog_type = get_fdinfo(fd, \"owner_prog_type\");\n\t\tchar *owner_jited = get_fdinfo(fd, \"owner_jited\");\n\n\t\tif (owner_prog_type || owner_jited)\n\t\t\tprintf(\"\\n\\t\");\n\t\tif (owner_prog_type) {\n\t\t\tunsigned int prog_type = atoi(owner_prog_type);\n\t\t\tconst char *prog_type_str;\n\n\t\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_type);\n\t\t\tif (prog_type_str)\n\t\t\t\tprintf(\"owner_prog_type %s  \", prog_type_str);\n\t\t\telse\n\t\t\t\tprintf(\"owner_prog_type %d  \", prog_type);\n\t\t}\n\t\tif (owner_jited)\n\t\t\tprintf(\"owner%s jited\",\n\t\t\t       atoi(owner_jited) ? \"\" : \" not\");\n\n\t\tfree(owner_prog_type);\n\t\tfree(owner_jited);\n\t}\n\tclose(fd);\n\n\tif (!hashmap__empty(map_table)) {\n\t\tstruct hashmap_entry *entry;\n\n\t\thashmap__for_each_key_entry(map_table, entry, info->id)\n\t\t\tprintf(\"\\n\\tpinned %s\", (char *)entry->pvalue);\n\t}\n\n\tif (frozen_str) {\n\t\tfrozen = atoi(frozen_str);\n\t\tfree(frozen_str);\n\t}\n\n\tif (info->btf_id || frozen)\n\t\tprintf(\"\\n\\t\");\n\n\tif (info->btf_id)\n\t\tprintf(\"btf_id %d\", info->btf_id);\n\n\tif (frozen)\n\t\tprintf(\"%sfrozen\", info->btf_id ? \"  \" : \"\");\n\n\temit_obj_refs_plain(refs_table, info->id, \"\\n\\tpids \");\n\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nstatic int do_show_subset(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tint *fds = NULL;\n\tint nb_fds, i;\n\tint err = -1;\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = map_parse_fds(&argc, &argv, &fds);\n\tif (nb_fds < 1)\n\t\tgoto exit_free;\n\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_start_array(json_wtr);\t \n\tfor (i = 0; i < nb_fds; i++) {\n\t\terr = bpf_map_get_info_by_fd(fds[i], &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get map info: %s\",\n\t\t\t      strerror(errno));\n\t\t\tfor (; i < nb_fds; i++)\n\t\t\t\tclose(fds[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (json_output)\n\t\t\tshow_map_close_json(fds[i], &info);\n\t\telse\n\t\t\tshow_map_close_plain(fds[i], &info);\n\n\t\tclose(fds[i]);\n\t}\n\tif (json_output && nb_fds > 1)\n\t\tjsonw_end_array(json_wtr);\t \n\nexit_free:\n\tfree(fds);\n\treturn err;\n}\n\nstatic int do_show(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\t__u32 id = 0;\n\tint err;\n\tint fd;\n\n\tif (show_pinned) {\n\t\tmap_table = hashmap__new(hash_fn_for_key_as_id,\n\t\t\t\t\t equal_fn_for_key_as_id, NULL);\n\t\tif (IS_ERR(map_table)) {\n\t\t\tp_err(\"failed to create hashmap for pinned paths\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuild_pinned_obj_table(map_table, BPF_OBJ_MAP);\n\t}\n\tbuild_obj_refs_table(&refs_table, BPF_OBJ_MAP);\n\n\tif (argc == 2)\n\t\treturn do_show_subset(argc, argv);\n\n\tif (argc)\n\t\treturn BAD_ARG();\n\n\tif (json_output)\n\t\tjsonw_start_array(json_wtr);\n\twhile (true) {\n\t\terr = bpf_map_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\tp_err(\"can't get next map: %s%s\", strerror(errno),\n\t\t\t      errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfd = bpf_map_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tp_err(\"can't get map by id (%u): %s\",\n\t\t\t      id, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\terr = bpf_map_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\t\tclose(fd);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (json_output)\n\t\t\tshow_map_close_json(fd, &info);\n\t\telse\n\t\t\tshow_map_close_plain(fd, &info);\n\t}\n\tif (json_output)\n\t\tjsonw_end_array(json_wtr);\n\n\tdelete_obj_refs_table(refs_table);\n\n\tif (show_pinned)\n\t\tdelete_pinned_obj_table(map_table);\n\n\treturn errno == ENOENT ? 0 : -1;\n}\n\nstatic int dump_map_elem(int fd, void *key, void *value,\n\t\t\t struct bpf_map_info *map_info, struct btf *btf,\n\t\t\t json_writer_t *btf_wtr)\n{\n\tif (bpf_map_lookup_elem(fd, key, value)) {\n\t\tprint_entry_error(map_info, key, errno);\n\t\treturn -1;\n\t}\n\n\tif (json_output) {\n\t\tprint_entry_json(map_info, key, value, btf);\n\t} else if (btf) {\n\t\tstruct btf_dumper d = {\n\t\t\t.btf = btf,\n\t\t\t.jw = btf_wtr,\n\t\t\t.is_plain_text = true,\n\t\t};\n\n\t\tdo_dump_btf(&d, map_info, key, value);\n\t} else {\n\t\tprint_entry_plain(map_info, key, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int maps_have_btf(int *fds, int nb_fds)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tint err, i;\n\n\tfor (i = 0; i < nb_fds; i++) {\n\t\terr = bpf_map_get_info_by_fd(fds[i], &info, &len);\n\t\tif (err) {\n\t\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!info.btf_id)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic struct btf *btf_vmlinux;\n\nstatic int get_map_kv_btf(const struct bpf_map_info *info, struct btf **btf)\n{\n\tint err = 0;\n\n\tif (info->btf_vmlinux_value_type_id) {\n\t\tif (!btf_vmlinux) {\n\t\t\tbtf_vmlinux = libbpf_find_kernel_btf();\n\t\t\tif (!btf_vmlinux) {\n\t\t\t\tp_err(\"failed to get kernel btf\");\n\t\t\t\treturn -errno;\n\t\t\t}\n\t\t}\n\t\t*btf = btf_vmlinux;\n\t} else if (info->btf_value_type_id) {\n\t\t*btf = btf__load_from_kernel_by_id(info->btf_id);\n\t\tif (!*btf) {\n\t\t\terr = -errno;\n\t\t\tp_err(\"failed to get btf\");\n\t\t}\n\t} else {\n\t\t*btf = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic void free_map_kv_btf(struct btf *btf)\n{\n\tif (btf != btf_vmlinux)\n\t\tbtf__free(btf);\n}\n\nstatic int\nmap_dump(int fd, struct bpf_map_info *info, json_writer_t *wtr,\n\t bool show_header)\n{\n\tvoid *key, *value, *prev_key;\n\tunsigned int num_elems = 0;\n\tstruct btf *btf = NULL;\n\tint err;\n\n\tkey = malloc(info->key_size);\n\tvalue = alloc_value(info);\n\tif (!key || !value) {\n\t\tp_err(\"mem alloc failed\");\n\t\terr = -1;\n\t\tgoto exit_free;\n\t}\n\n\tprev_key = NULL;\n\n\tif (wtr) {\n\t\terr = get_map_kv_btf(info, &btf);\n\t\tif (err) {\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (show_header) {\n\t\t\tjsonw_start_object(wtr);\t \n\t\t\tshow_map_header_json(info, wtr);\n\t\t\tjsonw_name(wtr, \"elements\");\n\t\t}\n\t\tjsonw_start_array(wtr);\t\t \n\t} else if (show_header) {\n\t\tshow_map_header_plain(info);\n\t}\n\n\tif (info->type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY &&\n\t    info->value_size != 8) {\n\t\tconst char *map_type_str;\n\n\t\tmap_type_str = libbpf_bpf_map_type_str(info->type);\n\t\tp_info(\"Warning: cannot read values from %s map with value_size != 8\",\n\t\t       map_type_str);\n\t}\n\twhile (true) {\n\t\terr = bpf_map_get_next_key(fd, prev_key, key);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!dump_map_elem(fd, key, value, info, btf, wtr))\n\t\t\tnum_elems++;\n\t\tprev_key = key;\n\t}\n\n\tif (wtr) {\n\t\tjsonw_end_array(wtr);\t \n\t\tif (show_header)\n\t\t\tjsonw_end_object(wtr);\t \n\t} else {\n\t\tprintf(\"Found %u element%s\\n\", num_elems,\n\t\t       num_elems != 1 ? \"s\" : \"\");\n\t}\n\nexit_free:\n\tfree(key);\n\tfree(value);\n\tclose(fd);\n\tfree_map_kv_btf(btf);\n\n\treturn err;\n}\n\nstatic int do_dump(int argc, char **argv)\n{\n\tjson_writer_t *wtr = NULL, *btf_wtr = NULL;\n\tstruct bpf_map_info info = {};\n\tint nb_fds, i = 0;\n\t__u32 len = sizeof(info);\n\tint *fds = NULL;\n\tint err = -1;\n\n\tif (argc != 2)\n\t\tusage();\n\n\tfds = malloc(sizeof(int));\n\tif (!fds) {\n\t\tp_err(\"mem alloc failed\");\n\t\treturn -1;\n\t}\n\tnb_fds = map_parse_fds(&argc, &argv, &fds);\n\tif (nb_fds < 1)\n\t\tgoto exit_free;\n\n\tif (json_output) {\n\t\twtr = json_wtr;\n\t} else {\n\t\tint do_plain_btf;\n\n\t\tdo_plain_btf = maps_have_btf(fds, nb_fds);\n\t\tif (do_plain_btf < 0)\n\t\t\tgoto exit_close;\n\n\t\tif (do_plain_btf) {\n\t\t\tbtf_wtr = get_btf_writer();\n\t\t\twtr = btf_wtr;\n\t\t\tif (!btf_wtr)\n\t\t\t\tp_info(\"failed to create json writer for btf. falling back to plain output\");\n\t\t}\n\t}\n\n\tif (wtr && nb_fds > 1)\n\t\tjsonw_start_array(wtr);\t \n\tfor (i = 0; i < nb_fds; i++) {\n\t\tif (bpf_map_get_info_by_fd(fds[i], &info, &len)) {\n\t\t\tp_err(\"can't get map info: %s\", strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\terr = map_dump(fds[i], &info, wtr, nb_fds > 1);\n\t\tif (!wtr && i != nb_fds - 1)\n\t\t\tprintf(\"\\n\");\n\n\t\tif (err)\n\t\t\tbreak;\n\t\tclose(fds[i]);\n\t}\n\tif (wtr && nb_fds > 1)\n\t\tjsonw_end_array(wtr);\t \n\n\tif (btf_wtr)\n\t\tjsonw_destroy(&btf_wtr);\nexit_close:\n\tfor (; i < nb_fds; i++)\n\t\tclose(fds[i]);\nexit_free:\n\tfree(fds);\n\tbtf__free(btf_vmlinux);\n\treturn err;\n}\n\nstatic int alloc_key_value(struct bpf_map_info *info, void **key, void **value)\n{\n\t*key = NULL;\n\t*value = NULL;\n\n\tif (info->key_size) {\n\t\t*key = malloc(info->key_size);\n\t\tif (!*key) {\n\t\t\tp_err(\"key mem alloc failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (info->value_size) {\n\t\t*value = alloc_value(info);\n\t\tif (!*value) {\n\t\t\tp_err(\"value mem alloc failed\");\n\t\t\tfree(*key);\n\t\t\t*key = NULL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int do_update(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\t__u32 *value_fd = NULL;\n\t__u32 flags = BPF_ANY;\n\tvoid *key, *value;\n\tint fd, err;\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\tif (fd < 0)\n\t\treturn -1;\n\n\terr = alloc_key_value(&info, &key, &value);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = parse_elem(argv, &info, key, value, info.key_size,\n\t\t\t info.value_size, &flags, &value_fd);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = bpf_map_update_elem(fd, key, value, flags);\n\tif (err) {\n\t\tp_err(\"update failed: %s\", strerror(errno));\n\t\tgoto exit_free;\n\t}\n\nexit_free:\n\tif (value_fd)\n\t\tclose(*value_fd);\n\tfree(key);\n\tfree(value);\n\tclose(fd);\n\n\tif (!err && json_output)\n\t\tjsonw_null(json_wtr);\n\treturn err;\n}\n\nstatic void print_key_value(struct bpf_map_info *info, void *key,\n\t\t\t    void *value)\n{\n\tjson_writer_t *btf_wtr;\n\tstruct btf *btf;\n\n\tif (get_map_kv_btf(info, &btf))\n\t\treturn;\n\n\tif (json_output) {\n\t\tprint_entry_json(info, key, value, btf);\n\t} else if (btf) {\n\t\t \n\t\tbtf_wtr = get_btf_writer();\n\t\tif (!btf_wtr) {\n\t\t\tp_info(\"failed to create json writer for btf. falling back to plain output\");\n\t\t\tbtf__free(btf);\n\t\t\tbtf = NULL;\n\t\t\tprint_entry_plain(info, key, value);\n\t\t} else {\n\t\t\tstruct btf_dumper d = {\n\t\t\t\t.btf = btf,\n\t\t\t\t.jw = btf_wtr,\n\t\t\t\t.is_plain_text = true,\n\t\t\t};\n\n\t\t\tdo_dump_btf(&d, info, key, value);\n\t\t\tjsonw_destroy(&btf_wtr);\n\t\t}\n\t} else {\n\t\tprint_entry_plain(info, key, value);\n\t}\n\tbtf__free(btf);\n}\n\nstatic int do_lookup(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tvoid *key, *value;\n\tint err;\n\tint fd;\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\tif (fd < 0)\n\t\treturn -1;\n\n\terr = alloc_key_value(&info, &key, &value);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = parse_elem(argv, &info, key, NULL, info.key_size, 0, NULL, NULL);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = bpf_map_lookup_elem(fd, key, value);\n\tif (err) {\n\t\tif (errno == ENOENT) {\n\t\t\tif (json_output) {\n\t\t\t\tjsonw_null(json_wtr);\n\t\t\t} else {\n\t\t\t\tprintf(\"key:\\n\");\n\t\t\t\tfprint_hex(stdout, key, info.key_size, \" \");\n\t\t\t\tprintf(\"\\n\\nNot found\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tp_err(\"lookup failed: %s\", strerror(errno));\n\t\t}\n\n\t\tgoto exit_free;\n\t}\n\n\t \n\tprint_key_value(&info, key, value);\n\nexit_free:\n\tfree(key);\n\tfree(value);\n\tclose(fd);\n\n\treturn err;\n}\n\nstatic int do_getnext(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tvoid *key, *nextkey;\n\tint err;\n\tint fd;\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tkey = malloc(info.key_size);\n\tnextkey = malloc(info.key_size);\n\tif (!key || !nextkey) {\n\t\tp_err(\"mem alloc failed\");\n\t\terr = -1;\n\t\tgoto exit_free;\n\t}\n\n\tif (argc) {\n\t\terr = parse_elem(argv, &info, key, NULL, info.key_size, 0,\n\t\t\t\t NULL, NULL);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\t} else {\n\t\tfree(key);\n\t\tkey = NULL;\n\t}\n\n\terr = bpf_map_get_next_key(fd, key, nextkey);\n\tif (err) {\n\t\tp_err(\"can't get next key: %s\", strerror(errno));\n\t\tgoto exit_free;\n\t}\n\n\tif (json_output) {\n\t\tjsonw_start_object(json_wtr);\n\t\tif (key) {\n\t\t\tjsonw_name(json_wtr, \"key\");\n\t\t\tprint_hex_data_json(key, info.key_size);\n\t\t} else {\n\t\t\tjsonw_null_field(json_wtr, \"key\");\n\t\t}\n\t\tjsonw_name(json_wtr, \"next_key\");\n\t\tprint_hex_data_json(nextkey, info.key_size);\n\t\tjsonw_end_object(json_wtr);\n\t} else {\n\t\tif (key) {\n\t\t\tprintf(\"key:\\n\");\n\t\t\tfprint_hex(stdout, key, info.key_size, \" \");\n\t\t\tprintf(\"\\n\");\n\t\t} else {\n\t\t\tprintf(\"key: None\\n\");\n\t\t}\n\t\tprintf(\"next key:\\n\");\n\t\tfprint_hex(stdout, nextkey, info.key_size, \" \");\n\t\tprintf(\"\\n\");\n\t}\n\nexit_free:\n\tfree(nextkey);\n\tfree(key);\n\tclose(fd);\n\n\treturn err;\n}\n\nstatic int do_delete(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tvoid *key;\n\tint err;\n\tint fd;\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tkey = malloc(info.key_size);\n\tif (!key) {\n\t\tp_err(\"mem alloc failed\");\n\t\terr = -1;\n\t\tgoto exit_free;\n\t}\n\n\terr = parse_elem(argv, &info, key, NULL, info.key_size, 0, NULL, NULL);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = bpf_map_delete_elem(fd, key);\n\tif (err)\n\t\tp_err(\"delete failed: %s\", strerror(errno));\n\nexit_free:\n\tfree(key);\n\tclose(fd);\n\n\tif (!err && json_output)\n\t\tjsonw_null(json_wtr);\n\treturn err;\n}\n\nstatic int do_pin(int argc, char **argv)\n{\n\tint err;\n\n\terr = do_pin_any(argc, argv, map_parse_fd);\n\tif (!err && json_output)\n\t\tjsonw_null(json_wtr);\n\treturn err;\n}\n\nstatic int do_create(int argc, char **argv)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, attr);\n\tenum bpf_map_type map_type = BPF_MAP_TYPE_UNSPEC;\n\t__u32 key_size = 0, value_size = 0, max_entries = 0;\n\tconst char *map_name = NULL;\n\tconst char *pinfile;\n\tint err = -1, fd;\n\n\tif (!REQ_ARGS(7))\n\t\treturn -1;\n\tpinfile = GET_ARG();\n\n\twhile (argc) {\n\t\tif (!REQ_ARGS(2))\n\t\t\treturn -1;\n\n\t\tif (is_prefix(*argv, \"type\")) {\n\t\t\tNEXT_ARG();\n\n\t\t\tif (map_type) {\n\t\t\t\tp_err(\"map type already specified\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tmap_type = map_type_from_str(*argv);\n\t\t\tif ((int)map_type < 0) {\n\t\t\t\tp_err(\"unrecognized map type: %s\", *argv);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"name\")) {\n\t\t\tNEXT_ARG();\n\t\t\tmap_name = GET_ARG();\n\t\t} else if (is_prefix(*argv, \"key\")) {\n\t\t\tif (parse_u32_arg(&argc, &argv, &key_size,\n\t\t\t\t\t  \"key size\"))\n\t\t\t\tgoto exit;\n\t\t} else if (is_prefix(*argv, \"value\")) {\n\t\t\tif (parse_u32_arg(&argc, &argv, &value_size,\n\t\t\t\t\t  \"value size\"))\n\t\t\t\tgoto exit;\n\t\t} else if (is_prefix(*argv, \"entries\")) {\n\t\t\tif (parse_u32_arg(&argc, &argv, &max_entries,\n\t\t\t\t\t  \"max entries\"))\n\t\t\t\tgoto exit;\n\t\t} else if (is_prefix(*argv, \"flags\")) {\n\t\t\tif (parse_u32_arg(&argc, &argv, &attr.map_flags,\n\t\t\t\t\t  \"flags\"))\n\t\t\t\tgoto exit;\n\t\t} else if (is_prefix(*argv, \"dev\")) {\n\t\t\tp_info(\"Warning: 'bpftool map create [...] dev <ifname>' syntax is deprecated.\\n\"\n\t\t\t       \"Going further, please use 'offload_dev <ifname>' to request hardware offload for the map.\");\n\t\t\tgoto offload_dev;\n\t\t} else if (is_prefix(*argv, \"offload_dev\")) {\noffload_dev:\n\t\t\tNEXT_ARG();\n\n\t\t\tif (attr.map_ifindex) {\n\t\t\t\tp_err(\"offload device already specified\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tattr.map_ifindex = if_nametoindex(*argv);\n\t\t\tif (!attr.map_ifindex) {\n\t\t\t\tp_err(\"unrecognized netdevice '%s': %s\",\n\t\t\t\t      *argv, strerror(errno));\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\t\t} else if (is_prefix(*argv, \"inner_map\")) {\n\t\t\tstruct bpf_map_info info = {};\n\t\t\t__u32 len = sizeof(info);\n\t\t\tint inner_map_fd;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (!REQ_ARGS(2))\n\t\t\t\tusage();\n\t\t\tinner_map_fd = map_parse_fd_and_info(&argc, &argv,\n\t\t\t\t\t\t\t     &info, &len);\n\t\t\tif (inner_map_fd < 0)\n\t\t\t\treturn -1;\n\t\t\tattr.inner_map_fd = inner_map_fd;\n\t\t} else {\n\t\t\tp_err(\"unknown arg %s\", *argv);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (!map_name) {\n\t\tp_err(\"map name not specified\");\n\t\tgoto exit;\n\t}\n\n\tset_max_rlimit();\n\n\tfd = bpf_map_create(map_type, map_name, key_size, value_size, max_entries, &attr);\n\tif (fd < 0) {\n\t\tp_err(\"map create failed: %s\", strerror(errno));\n\t\tgoto exit;\n\t}\n\n\terr = do_pin_fd(fd, pinfile);\n\tclose(fd);\n\tif (err)\n\t\tgoto exit;\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\nexit:\n\tif (attr.inner_map_fd > 0)\n\t\tclose(attr.inner_map_fd);\n\n\treturn err;\n}\n\nstatic int do_pop_dequeue(int argc, char **argv)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tvoid *key, *value;\n\tint err;\n\tint fd;\n\n\tif (argc < 2)\n\t\tusage();\n\n\tfd = map_parse_fd_and_info(&argc, &argv, &info, &len);\n\tif (fd < 0)\n\t\treturn -1;\n\n\terr = alloc_key_value(&info, &key, &value);\n\tif (err)\n\t\tgoto exit_free;\n\n\terr = bpf_map_lookup_and_delete_elem(fd, key, value);\n\tif (err) {\n\t\tif (errno == ENOENT) {\n\t\t\tif (json_output)\n\t\t\t\tjsonw_null(json_wtr);\n\t\t\telse\n\t\t\t\tprintf(\"Error: empty map\\n\");\n\t\t} else {\n\t\t\tp_err(\"pop failed: %s\", strerror(errno));\n\t\t}\n\n\t\tgoto exit_free;\n\t}\n\n\tprint_key_value(&info, key, value);\n\nexit_free:\n\tfree(key);\n\tfree(value);\n\tclose(fd);\n\n\treturn err;\n}\n\nstatic int do_freeze(int argc, char **argv)\n{\n\tint err, fd;\n\n\tif (!REQ_ARGS(2))\n\t\treturn -1;\n\n\tfd = map_parse_fd(&argc, &argv);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (argc) {\n\t\tclose(fd);\n\t\treturn BAD_ARG();\n\t}\n\n\terr = bpf_map_freeze(fd);\n\tclose(fd);\n\tif (err) {\n\t\tp_err(\"failed to freeze map: %s\", strerror(errno));\n\t\treturn err;\n\t}\n\n\tif (json_output)\n\t\tjsonw_null(json_wtr);\n\n\treturn 0;\n}\n\nstatic int do_help(int argc, char **argv)\n{\n\tif (json_output) {\n\t\tjsonw_null(json_wtr);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr,\n\t\t\"Usage: %1$s %2$s { show | list }   [MAP]\\n\"\n\t\t\"       %1$s %2$s create     FILE type TYPE key KEY_SIZE value VALUE_SIZE \\\\\\n\"\n\t\t\"                                  entries MAX_ENTRIES name NAME [flags FLAGS] \\\\\\n\"\n\t\t\"                                  [inner_map MAP] [offload_dev NAME]\\n\"\n\t\t\"       %1$s %2$s dump       MAP\\n\"\n\t\t\"       %1$s %2$s update     MAP [key DATA] [value VALUE] [UPDATE_FLAGS]\\n\"\n\t\t\"       %1$s %2$s lookup     MAP [key DATA]\\n\"\n\t\t\"       %1$s %2$s getnext    MAP [key DATA]\\n\"\n\t\t\"       %1$s %2$s delete     MAP  key DATA\\n\"\n\t\t\"       %1$s %2$s pin        MAP  FILE\\n\"\n\t\t\"       %1$s %2$s event_pipe MAP [cpu N index M]\\n\"\n\t\t\"       %1$s %2$s peek       MAP\\n\"\n\t\t\"       %1$s %2$s push       MAP value VALUE\\n\"\n\t\t\"       %1$s %2$s pop        MAP\\n\"\n\t\t\"       %1$s %2$s enqueue    MAP value VALUE\\n\"\n\t\t\"       %1$s %2$s dequeue    MAP\\n\"\n\t\t\"       %1$s %2$s freeze     MAP\\n\"\n\t\t\"       %1$s %2$s help\\n\"\n\t\t\"\\n\"\n\t\t\"       \" HELP_SPEC_MAP \"\\n\"\n\t\t\"       DATA := { [hex] BYTES }\\n\"\n\t\t\"       \" HELP_SPEC_PROGRAM \"\\n\"\n\t\t\"       VALUE := { DATA | MAP | PROG }\\n\"\n\t\t\"       UPDATE_FLAGS := { any | exist | noexist }\\n\"\n\t\t\"       TYPE := { hash | array | prog_array | perf_event_array | percpu_hash |\\n\"\n\t\t\"                 percpu_array | stack_trace | cgroup_array | lru_hash |\\n\"\n\t\t\"                 lru_percpu_hash | lpm_trie | array_of_maps | hash_of_maps |\\n\"\n\t\t\"                 devmap | devmap_hash | sockmap | cpumap | xskmap | sockhash |\\n\"\n\t\t\"                 cgroup_storage | reuseport_sockarray | percpu_cgroup_storage |\\n\"\n\t\t\"                 queue | stack | sk_storage | struct_ops | ringbuf | inode_storage |\\n\"\n\t\t\"                 task_storage | bloom_filter | user_ringbuf | cgrp_storage }\\n\"\n\t\t\"       \" HELP_SPEC_OPTIONS \" |\\n\"\n\t\t\"                    {-f|--bpffs} | {-n|--nomount} }\\n\"\n\t\t\"\",\n\t\tbin_name, argv[-2]);\n\n\treturn 0;\n}\n\nstatic const struct cmd cmds[] = {\n\t{ \"show\",\tdo_show },\n\t{ \"list\",\tdo_show },\n\t{ \"help\",\tdo_help },\n\t{ \"dump\",\tdo_dump },\n\t{ \"update\",\tdo_update },\n\t{ \"lookup\",\tdo_lookup },\n\t{ \"getnext\",\tdo_getnext },\n\t{ \"delete\",\tdo_delete },\n\t{ \"pin\",\tdo_pin },\n\t{ \"event_pipe\",\tdo_event_pipe },\n\t{ \"create\",\tdo_create },\n\t{ \"peek\",\tdo_lookup },\n\t{ \"push\",\tdo_update },\n\t{ \"enqueue\",\tdo_update },\n\t{ \"pop\",\tdo_pop_dequeue },\n\t{ \"dequeue\",\tdo_pop_dequeue },\n\t{ \"freeze\",\tdo_freeze },\n\t{ 0 }\n};\n\nint do_map(int argc, char **argv)\n{\n\treturn cmd_select(cmds, argc, argv, do_help);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}