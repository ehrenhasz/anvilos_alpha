{
  "module_name": "pids.c",
  "hash_id": "397476948ee335d93c538c5508d0f83a9ff042f450120edc53d4dea47960f304",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpftool/pids.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <linux/err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/hashmap.h>\n\n#include \"main.h\"\n#include \"skeleton/pid_iter.h\"\n\n#ifdef BPFTOOL_WITHOUT_SKELETONS\n\nint build_obj_refs_table(struct hashmap **map, enum bpf_obj_type type)\n{\n\treturn -ENOTSUP;\n}\nvoid delete_obj_refs_table(struct hashmap *map) {}\nvoid emit_obj_refs_plain(struct hashmap *map, __u32 id, const char *prefix) {}\nvoid emit_obj_refs_json(struct hashmap *map, __u32 id, json_writer_t *json_writer) {}\n\n#else  \n\n#include \"pid_iter.skel.h\"\n\nstatic void add_ref(struct hashmap *map, struct pid_iter_entry *e)\n{\n\tstruct hashmap_entry *entry;\n\tstruct obj_refs *refs;\n\tstruct obj_ref *ref;\n\tint err, i;\n\tvoid *tmp;\n\n\thashmap__for_each_key_entry(map, entry, e->id) {\n\t\trefs = entry->pvalue;\n\n\t\tfor (i = 0; i < refs->ref_cnt; i++) {\n\t\t\tif (refs->refs[i].pid == e->pid)\n\t\t\t\treturn;\n\t\t}\n\n\t\ttmp = realloc(refs->refs, (refs->ref_cnt + 1) * sizeof(*ref));\n\t\tif (!tmp) {\n\t\t\tp_err(\"failed to re-alloc memory for ID %u, PID %d, COMM %s...\",\n\t\t\t      e->id, e->pid, e->comm);\n\t\t\treturn;\n\t\t}\n\t\trefs->refs = tmp;\n\t\tref = &refs->refs[refs->ref_cnt];\n\t\tref->pid = e->pid;\n\t\tmemcpy(ref->comm, e->comm, sizeof(ref->comm));\n\t\trefs->ref_cnt++;\n\n\t\treturn;\n\t}\n\n\t \n\trefs = calloc(1, sizeof(*refs));\n\tif (!refs) {\n\t\tp_err(\"failed to alloc memory for ID %u, PID %d, COMM %s...\",\n\t\t      e->id, e->pid, e->comm);\n\t\treturn;\n\t}\n\n\trefs->refs = malloc(sizeof(*refs->refs));\n\tif (!refs->refs) {\n\t\tfree(refs);\n\t\tp_err(\"failed to alloc memory for ID %u, PID %d, COMM %s...\",\n\t\t      e->id, e->pid, e->comm);\n\t\treturn;\n\t}\n\tref = &refs->refs[0];\n\tref->pid = e->pid;\n\tmemcpy(ref->comm, e->comm, sizeof(ref->comm));\n\trefs->ref_cnt = 1;\n\trefs->has_bpf_cookie = e->has_bpf_cookie;\n\trefs->bpf_cookie = e->bpf_cookie;\n\n\terr = hashmap__append(map, e->id, refs);\n\tif (err)\n\t\tp_err(\"failed to append entry to hashmap for ID %u: %s\",\n\t\t      e->id, strerror(errno));\n}\n\nstatic int __printf(2, 0)\nlibbpf_print_none(__maybe_unused enum libbpf_print_level level,\n\t\t  __maybe_unused const char *format,\n\t\t  __maybe_unused va_list args)\n{\n\treturn 0;\n}\n\nint build_obj_refs_table(struct hashmap **map, enum bpf_obj_type type)\n{\n\tstruct pid_iter_entry *e;\n\tchar buf[4096 / sizeof(*e) * sizeof(*e)];\n\tstruct pid_iter_bpf *skel;\n\tint err, ret, fd = -1, i;\n\tlibbpf_print_fn_t default_print;\n\n\t*map = hashmap__new(hash_fn_for_key_as_id, equal_fn_for_key_as_id, NULL);\n\tif (IS_ERR(*map)) {\n\t\tp_err(\"failed to create hashmap for PID references\");\n\t\treturn -1;\n\t}\n\tset_max_rlimit();\n\n\tskel = pid_iter_bpf__open();\n\tif (!skel) {\n\t\tp_err(\"failed to open PID iterator skeleton\");\n\t\treturn -1;\n\t}\n\n\tskel->rodata->obj_type = type;\n\n\t \n\tdefault_print = libbpf_set_print(libbpf_print_none);\n\terr = pid_iter_bpf__load(skel);\n\tlibbpf_set_print(default_print);\n\tif (err) {\n\t\t \n\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = pid_iter_bpf__attach(skel);\n\tif (err) {\n\t\t \n\t\tp_err(\"failed to attach PID iterator: %d\", err);\n\t\tgoto out;\n\t}\n\n\tfd = bpf_iter_create(bpf_link__fd(skel->links.iter));\n\tif (fd < 0) {\n\t\terr = -errno;\n\t\tp_err(\"failed to create PID iterator session: %d\", err);\n\t\tgoto out;\n\t}\n\n\twhile (true) {\n\t\tret = read(fd, buf, sizeof(buf));\n\t\tif (ret < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\terr = -errno;\n\t\t\tp_err(\"failed to read PID iterator output: %d\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret % sizeof(*e)) {\n\t\t\terr = -EINVAL;\n\t\t\tp_err(\"invalid PID iterator output format\");\n\t\t\tgoto out;\n\t\t}\n\t\tret /= sizeof(*e);\n\n\t\te = (void *)buf;\n\t\tfor (i = 0; i < ret; i++, e++) {\n\t\t\tadd_ref(*map, e);\n\t\t}\n\t}\n\terr = 0;\nout:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tpid_iter_bpf__destroy(skel);\n\treturn err;\n}\n\nvoid delete_obj_refs_table(struct hashmap *map)\n{\n\tstruct hashmap_entry *entry;\n\tsize_t bkt;\n\n\tif (!map)\n\t\treturn;\n\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tstruct obj_refs *refs = entry->pvalue;\n\n\t\tfree(refs->refs);\n\t\tfree(refs);\n\t}\n\n\thashmap__free(map);\n}\n\nvoid emit_obj_refs_json(struct hashmap *map, __u32 id,\n\t\t\tjson_writer_t *json_writer)\n{\n\tstruct hashmap_entry *entry;\n\n\tif (hashmap__empty(map))\n\t\treturn;\n\n\thashmap__for_each_key_entry(map, entry, id) {\n\t\tstruct obj_refs *refs = entry->pvalue;\n\t\tint i;\n\n\t\tif (refs->ref_cnt == 0)\n\t\t\tbreak;\n\n\t\tif (refs->has_bpf_cookie)\n\t\t\tjsonw_lluint_field(json_writer, \"bpf_cookie\", refs->bpf_cookie);\n\n\t\tjsonw_name(json_writer, \"pids\");\n\t\tjsonw_start_array(json_writer);\n\t\tfor (i = 0; i < refs->ref_cnt; i++) {\n\t\t\tstruct obj_ref *ref = &refs->refs[i];\n\n\t\t\tjsonw_start_object(json_writer);\n\t\t\tjsonw_int_field(json_writer, \"pid\", ref->pid);\n\t\t\tjsonw_string_field(json_writer, \"comm\", ref->comm);\n\t\t\tjsonw_end_object(json_writer);\n\t\t}\n\t\tjsonw_end_array(json_writer);\n\t\tbreak;\n\t}\n}\n\nvoid emit_obj_refs_plain(struct hashmap *map, __u32 id, const char *prefix)\n{\n\tstruct hashmap_entry *entry;\n\n\tif (hashmap__empty(map))\n\t\treturn;\n\n\thashmap__for_each_key_entry(map, entry, id) {\n\t\tstruct obj_refs *refs = entry->pvalue;\n\t\tint i;\n\n\t\tif (refs->ref_cnt == 0)\n\t\t\tbreak;\n\n\t\tif (refs->has_bpf_cookie)\n\t\t\tprintf(\"\\n\\tbpf_cookie %llu\", (unsigned long long) refs->bpf_cookie);\n\n\t\tprintf(\"%s\", prefix);\n\t\tfor (i = 0; i < refs->ref_cnt; i++) {\n\t\t\tstruct obj_ref *ref = &refs->refs[i];\n\n\t\t\tprintf(\"%s%s(%d)\", i == 0 ? \"\" : \", \", ref->comm, ref->pid);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}