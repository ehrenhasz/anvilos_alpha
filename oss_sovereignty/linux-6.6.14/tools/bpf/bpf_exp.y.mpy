{
  "module_name": "bpf_exp.y",
  "hash_id": "5a3fd1efe4904df60b06849a71ef9811e04f28b395fa3e9d95ef8c8afcd29a92",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpf_exp.y",
  "human_readable_source": "/*\n * BPF asm code parser\n *\n * This program is free software; you can distribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * Syntax kept close to:\n *\n * Steven McCanne and Van Jacobson. 1993. The BSD packet filter: a new\n * architecture for user-level packet capture. In Proceedings of the\n * USENIX Winter 1993 Conference Proceedings on USENIX Winter 1993\n * Conference Proceedings (USENIX'93). USENIX Association, Berkeley,\n * CA, USA, 2-2.\n *\n * Copyright 2013 Daniel Borkmann <borkmann@redhat.com>\n * Licensed under the GNU General Public License, version 2.0 (GPLv2)\n */\n\n%{\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <linux/filter.h>\n\n#include \"bpf_exp.yacc.h\"\n\nenum jmp_type { JTL, JFL, JKL };\n\nextern FILE *yyin;\nextern int yylineno;\nextern int yylex(void);\nextern void yyerror(const char *str);\n\nextern void bpf_asm_compile(FILE *fp, bool cstyle);\nstatic void bpf_set_curr_instr(uint16_t op, uint8_t jt, uint8_t jf, uint32_t k);\nstatic void bpf_set_curr_label(char *label);\nstatic void bpf_set_jmp_label(char *label, enum jmp_type type);\n\n%}\n\n%union {\n\tchar *label;\n\tuint32_t number;\n}\n\n%token OP_LDB OP_LDH OP_LD OP_LDX OP_ST OP_STX OP_JMP OP_JEQ OP_JGT OP_JGE\n%token OP_JSET OP_ADD OP_SUB OP_MUL OP_DIV OP_AND OP_OR OP_XOR OP_LSH OP_RSH\n%token OP_RET OP_TAX OP_TXA OP_LDXB OP_MOD OP_NEG OP_JNEQ OP_JLT OP_JLE OP_LDI\n%token OP_LDXI\n\n%token K_PKT_LEN\n\n%token ':' ',' '[' ']' '(' ')' 'x' 'a' '+' 'M' '*' '&' '#' '%'\n\n%token extension number label\n\n%type <label> label\n%type <number> extension\n%type <number> number\n\n%%\n\nprog\n\t: line\n\t| prog line\n\t;\n\nline\n\t: instr\n\t| labelled_instr\n\t;\n\nlabelled_instr\n\t: labelled instr\n\t;\n\ninstr\n\t: ldb\n\t| ldh\n\t| ld\n\t| ldi\n\t| ldx\n\t| ldxi\n\t| st\n\t| stx\n\t| jmp\n\t| jeq\n\t| jneq\n\t| jlt\n\t| jle\n\t| jgt\n\t| jge\n\t| jset\n\t| add\n\t| sub\n\t| mul\n\t| div\n\t| mod\n\t| neg\n\t| and\n\t| or\n\t| xor\n\t| lsh\n\t| rsh\n\t| ret\n\t| tax\n\t| txa\n\t;\n\nlabelled\n\t: label ':' { bpf_set_curr_label($1); }\n\t;\n\nldb\n\t: OP_LDB '[' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_B | BPF_IND, 0, 0, $5); }\n\t| OP_LDB '[' '%' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_B | BPF_IND, 0, 0, $6); }\n\t| OP_LDB '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_B | BPF_ABS, 0, 0, $3); }\n\t| OP_LDB extension {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_B | BPF_ABS, 0, 0,\n\t\t\t\t   SKF_AD_OFF + $2); }\n\t;\n\nldh\n\t: OP_LDH '[' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_H | BPF_IND, 0, 0, $5); }\n\t| OP_LDH '[' '%' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_H | BPF_IND, 0, 0, $6); }\n\t| OP_LDH '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_H | BPF_ABS, 0, 0, $3); }\n\t| OP_LDH extension {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_H | BPF_ABS, 0, 0,\n\t\t\t\t   SKF_AD_OFF + $2); }\n\t;\n\nldi\n\t: OP_LDI '#' number {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_IMM, 0, 0, $3); }\n\t| OP_LDI number {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_IMM, 0, 0, $2); }\n\t;\n\nld\n\t: OP_LD '#' number {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_IMM, 0, 0, $3); }\n\t| OP_LD K_PKT_LEN {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_W | BPF_LEN, 0, 0, 0); }\n\t| OP_LD extension {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_W | BPF_ABS, 0, 0,\n\t\t\t\t   SKF_AD_OFF + $2); }\n\t| OP_LD 'M' '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_MEM, 0, 0, $4); }\n\t| OP_LD '[' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_W | BPF_IND, 0, 0, $5); }\n\t| OP_LD '[' '%' 'x' '+' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_W | BPF_IND, 0, 0, $6); }\n\t| OP_LD '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_LD | BPF_W | BPF_ABS, 0, 0, $3); }\n\t;\n\nldxi\n\t: OP_LDXI '#' number {\n\t\tbpf_set_curr_instr(BPF_LDX | BPF_IMM, 0, 0, $3); }\n\t| OP_LDXI number {\n\t\tbpf_set_curr_instr(BPF_LDX | BPF_IMM, 0, 0, $2); }\n\t;\n\nldx\n\t: OP_LDX '#' number {\n\t\tbpf_set_curr_instr(BPF_LDX | BPF_IMM, 0, 0, $3); }\n\t| OP_LDX K_PKT_LEN {\n\t\tbpf_set_curr_instr(BPF_LDX | BPF_W | BPF_LEN, 0, 0, 0); }\n\t| OP_LDX 'M' '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_LDX | BPF_MEM, 0, 0, $4); }\n\t| OP_LDXB number '*' '(' '[' number ']' '&' number ')' {\n\t\tif ($2 != 4 || $9 != 0xf) {\n\t\t\tfprintf(stderr, \"ldxb offset not supported!\\n\");\n\t\t\texit(1);\n\t\t} else {\n\t\t\tbpf_set_curr_instr(BPF_LDX | BPF_MSH | BPF_B, 0, 0, $6); } }\n\t| OP_LDX number '*' '(' '[' number ']' '&' number ')' {\n\t\tif ($2 != 4 || $9 != 0xf) {\n\t\t\tfprintf(stderr, \"ldxb offset not supported!\\n\");\n\t\t\texit(1);\n\t\t} else {\n\t\t\tbpf_set_curr_instr(BPF_LDX | BPF_MSH | BPF_B, 0, 0, $6); } }\n\t;\n\nst\n\t: OP_ST 'M' '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_ST, 0, 0, $4); }\n\t;\n\nstx\n\t: OP_STX 'M' '[' number ']' {\n\t\tbpf_set_curr_instr(BPF_STX, 0, 0, $4); }\n\t;\n\njmp\n\t: OP_JMP label {\n\t\tbpf_set_jmp_label($2, JKL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JA, 0, 0, 0); }\n\t;\n\njeq\n\t: OP_JEQ '#' number ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_K, 0, 0, $3); }\n\t| OP_JEQ 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_jmp_label($6, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t| OP_JEQ '%' 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t| OP_JEQ '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_K, 0, 0, $3); }\n\t| OP_JEQ 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t| OP_JEQ '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t;\n\njneq\n\t: OP_JNEQ '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_K, 0, 0, $3); }\n\t| OP_JNEQ 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t| OP_JNEQ '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JEQ | BPF_X, 0, 0, 0); }\n\t;\n\njlt\n\t: OP_JLT '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_K, 0, 0, $3); }\n\t| OP_JLT 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t| OP_JLT '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t;\n\njle\n\t: OP_JLE '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_K, 0, 0, $3); }\n\t| OP_JLE 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t| OP_JLE '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t;\n\njgt\n\t: OP_JGT '#' number ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_K, 0, 0, $3); }\n\t| OP_JGT 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_jmp_label($6, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t| OP_JGT '%' 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t| OP_JGT '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_K, 0, 0, $3); }\n\t| OP_JGT 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t| OP_JGT '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGT | BPF_X, 0, 0, 0); }\n\t;\n\njge\n\t: OP_JGE '#' number ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_K, 0, 0, $3); }\n\t| OP_JGE 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_jmp_label($6, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t| OP_JGE '%' 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t| OP_JGE '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_K, 0, 0, $3); }\n\t| OP_JGE 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t| OP_JGE '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JGE | BPF_X, 0, 0, 0); }\n\t;\n\njset\n\t: OP_JSET '#' number ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_K, 0, 0, $3); }\n\t| OP_JSET 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_jmp_label($6, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_X, 0, 0, 0); }\n\t| OP_JSET '%' 'x' ',' label ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_jmp_label($7, JFL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_X, 0, 0, 0); }\n\t| OP_JSET '#' number ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_K, 0, 0, $3); }\n\t| OP_JSET 'x' ',' label {\n\t\tbpf_set_jmp_label($4, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_X, 0, 0, 0); }\n\t| OP_JSET '%' 'x' ',' label {\n\t\tbpf_set_jmp_label($5, JTL);\n\t\tbpf_set_curr_instr(BPF_JMP | BPF_JSET | BPF_X, 0, 0, 0); }\n\t;\n\nadd\n\t: OP_ADD '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_ADD | BPF_K, 0, 0, $3); }\n\t| OP_ADD 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_ADD | BPF_X, 0, 0, 0); }\n\t| OP_ADD '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_ADD | BPF_X, 0, 0, 0); }\n\t;\n\nsub\n\t: OP_SUB '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_SUB | BPF_K, 0, 0, $3); }\n\t| OP_SUB 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_SUB | BPF_X, 0, 0, 0); }\n\t| OP_SUB '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_SUB | BPF_X, 0, 0, 0); }\n\t;\n\nmul\n\t: OP_MUL '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MUL | BPF_K, 0, 0, $3); }\n\t| OP_MUL 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MUL | BPF_X, 0, 0, 0); }\n\t| OP_MUL '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MUL | BPF_X, 0, 0, 0); }\n\t;\n\ndiv\n\t: OP_DIV '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_DIV | BPF_K, 0, 0, $3); }\n\t| OP_DIV 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_DIV | BPF_X, 0, 0, 0); }\n\t| OP_DIV '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_DIV | BPF_X, 0, 0, 0); }\n\t;\n\nmod\n\t: OP_MOD '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MOD | BPF_K, 0, 0, $3); }\n\t| OP_MOD 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MOD | BPF_X, 0, 0, 0); }\n\t| OP_MOD '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_MOD | BPF_X, 0, 0, 0); }\n\t;\n\nneg\n\t: OP_NEG {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_NEG, 0, 0, 0); }\n\t;\n\nand\n\t: OP_AND '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_AND | BPF_K, 0, 0, $3); }\n\t| OP_AND 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_AND | BPF_X, 0, 0, 0); }\n\t| OP_AND '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_AND | BPF_X, 0, 0, 0); }\n\t;\n\nor\n\t: OP_OR '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_OR | BPF_K, 0, 0, $3); }\n\t| OP_OR 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_OR | BPF_X, 0, 0, 0); }\n\t| OP_OR '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_OR | BPF_X, 0, 0, 0); }\n\t;\n\nxor\n\t: OP_XOR '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_XOR | BPF_K, 0, 0, $3); }\n\t| OP_XOR 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_XOR | BPF_X, 0, 0, 0); }\n\t| OP_XOR '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_XOR | BPF_X, 0, 0, 0); }\n\t;\n\nlsh\n\t: OP_LSH '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_LSH | BPF_K, 0, 0, $3); }\n\t| OP_LSH 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_LSH | BPF_X, 0, 0, 0); }\n\t| OP_LSH '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_LSH | BPF_X, 0, 0, 0); }\n\t;\n\nrsh\n\t: OP_RSH '#' number {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_RSH | BPF_K, 0, 0, $3); }\n\t| OP_RSH 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_RSH | BPF_X, 0, 0, 0); }\n\t| OP_RSH '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_ALU | BPF_RSH | BPF_X, 0, 0, 0); }\n\t;\n\nret\n\t: OP_RET 'a' {\n\t\tbpf_set_curr_instr(BPF_RET | BPF_A, 0, 0, 0); }\n\t| OP_RET '%' 'a' {\n\t\tbpf_set_curr_instr(BPF_RET | BPF_A, 0, 0, 0); }\n\t| OP_RET 'x' {\n\t\tbpf_set_curr_instr(BPF_RET | BPF_X, 0, 0, 0); }\n\t| OP_RET '%' 'x' {\n\t\tbpf_set_curr_instr(BPF_RET | BPF_X, 0, 0, 0); }\n\t| OP_RET '#' number {\n\t\tbpf_set_curr_instr(BPF_RET | BPF_K, 0, 0, $3); }\n\t;\n\ntax\n\t: OP_TAX {\n\t\tbpf_set_curr_instr(BPF_MISC | BPF_TAX, 0, 0, 0); }\n\t;\n\ntxa\n\t: OP_TXA {\n\t\tbpf_set_curr_instr(BPF_MISC | BPF_TXA, 0, 0, 0); }\n\t;\n\n%%\n\nstatic int curr_instr = 0;\nstatic struct sock_filter out[BPF_MAXINSNS];\nstatic char **labels, **labels_jt, **labels_jf, **labels_k;\n\nstatic void bpf_assert_max(void)\n{\n\tif (curr_instr >= BPF_MAXINSNS) {\n\t\tfprintf(stderr, \"only max %u insns allowed!\\n\", BPF_MAXINSNS);\n\t\texit(1);\n\t}\n}\n\nstatic void bpf_set_curr_instr(uint16_t code, uint8_t jt, uint8_t jf,\n\t\t\t       uint32_t k)\n{\n\tbpf_assert_max();\n\tout[curr_instr].code = code;\n\tout[curr_instr].jt = jt;\n\tout[curr_instr].jf = jf;\n\tout[curr_instr].k = k;\n\tcurr_instr++;\n}\n\nstatic void bpf_set_curr_label(char *label)\n{\n\tbpf_assert_max();\n\tlabels[curr_instr] = label;\n}\n\nstatic void bpf_set_jmp_label(char *label, enum jmp_type type)\n{\n\tbpf_assert_max();\n\tswitch (type) {\n\tcase JTL:\n\t\tlabels_jt[curr_instr] = label;\n\t\tbreak;\n\tcase JFL:\n\t\tlabels_jf[curr_instr] = label;\n\t\tbreak;\n\tcase JKL:\n\t\tlabels_k[curr_instr] = label;\n\t\tbreak;\n\t}\n}\n\nstatic int bpf_find_insns_offset(const char *label)\n{\n\tint i, max = curr_instr, ret = -ENOENT;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (labels[i] && !strcmp(label, labels[i])) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == -ENOENT) {\n\t\tfprintf(stderr, \"no such label \\'%s\\'!\\n\", label);\n\t\texit(1);\n\t}\n\n\treturn ret;\n}\n\nstatic void bpf_stage_1_insert_insns(void)\n{\n\tyyparse();\n}\n\nstatic void bpf_reduce_k_jumps(void)\n{\n\tint i;\n\n\tfor (i = 0; i < curr_instr; i++) {\n\t\tif (labels_k[i]) {\n\t\t\tint off = bpf_find_insns_offset(labels_k[i]);\n\t\t\tout[i].k = (uint32_t) (off - i - 1);\n\t\t}\n\t}\n}\n\nstatic uint8_t bpf_encode_jt_jf_offset(int off, int i)\n{\n\tint delta = off - i - 1;\n\n\tif (delta < 0 || delta > 255) {\n\t\tfprintf(stderr, \"error: insn #%d jumps to insn #%d, \"\n\t\t\t\t\"which is out of range\\n\", i, off);\n\t\texit(1);\n\t}\n\treturn (uint8_t) delta;\n}\n\nstatic void bpf_reduce_jt_jumps(void)\n{\n\tint i;\n\n\tfor (i = 0; i < curr_instr; i++) {\n\t\tif (labels_jt[i]) {\n\t\t\tint off = bpf_find_insns_offset(labels_jt[i]);\n\t\t\tout[i].jt = bpf_encode_jt_jf_offset(off, i);\n\t\t}\n\t}\n}\n\nstatic void bpf_reduce_jf_jumps(void)\n{\n\tint i;\n\n\tfor (i = 0; i < curr_instr; i++) {\n\t\tif (labels_jf[i]) {\n\t\t\tint off = bpf_find_insns_offset(labels_jf[i]);\n\t\t\tout[i].jf = bpf_encode_jt_jf_offset(off, i);\n\t\t}\n\t}\n}\n\nstatic void bpf_stage_2_reduce_labels(void)\n{\n\tbpf_reduce_k_jumps();\n\tbpf_reduce_jt_jumps();\n\tbpf_reduce_jf_jumps();\n}\n\nstatic void bpf_pretty_print_c(void)\n{\n\tint i;\n\n\tfor (i = 0; i < curr_instr; i++)\n\t\tprintf(\"{ %#04x, %2u, %2u, %#010x },\\n\", out[i].code,\n\t\t       out[i].jt, out[i].jf, out[i].k);\n}\n\nstatic void bpf_pretty_print(void)\n{\n\tint i;\n\n\tprintf(\"%u,\", curr_instr);\n\tfor (i = 0; i < curr_instr; i++)\n\t\tprintf(\"%u %u %u %u,\", out[i].code,\n\t\t       out[i].jt, out[i].jf, out[i].k);\n\tprintf(\"\\n\");\n}\n\nstatic void bpf_init(void)\n{\n\tmemset(out, 0, sizeof(out));\n\n\tlabels = calloc(BPF_MAXINSNS, sizeof(*labels));\n\tassert(labels);\n\tlabels_jt = calloc(BPF_MAXINSNS, sizeof(*labels_jt));\n\tassert(labels_jt);\n\tlabels_jf = calloc(BPF_MAXINSNS, sizeof(*labels_jf));\n\tassert(labels_jf);\n\tlabels_k = calloc(BPF_MAXINSNS, sizeof(*labels_k));\n\tassert(labels_k);\n}\n\nstatic void bpf_destroy_labels(void)\n{\n\tint i;\n\n\tfor (i = 0; i < curr_instr; i++) {\n\t\tfree(labels_jf[i]);\n\t\tfree(labels_jt[i]);\n\t\tfree(labels_k[i]);\n\t\tfree(labels[i]);\n\t}\n}\n\nstatic void bpf_destroy(void)\n{\n\tbpf_destroy_labels();\n\tfree(labels_jt);\n\tfree(labels_jf);\n\tfree(labels_k);\n\tfree(labels);\n}\n\nvoid bpf_asm_compile(FILE *fp, bool cstyle)\n{\n\tyyin = fp;\n\n\tbpf_init();\n\tbpf_stage_1_insert_insns();\n\tbpf_stage_2_reduce_labels();\n\tbpf_destroy();\n\n\tif (cstyle)\n\t\tbpf_pretty_print_c();\n\telse\n\t\tbpf_pretty_print();\n\n\tif (fp != stdin)\n\t\tfclose(yyin);\n}\n\nvoid yyerror(const char *str)\n{\n\tfprintf(stderr, \"error: %s at line %d\\n\", str, yylineno);\n\texit(1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}