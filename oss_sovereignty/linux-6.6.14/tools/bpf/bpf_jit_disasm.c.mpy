{
  "module_name": "bpf_jit_disasm.c",
  "hash_id": "e30036411d454b823645d28233b847aa2ee7dbccf56bcfab90f70fdaf45e0e95",
  "original_prompt": "Ingested from linux-6.6.14/tools/bpf/bpf_jit_disasm.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unistd.h>\n#include <string.h>\n#include <bfd.h>\n#include <dis-asm.h>\n#include <regex.h>\n#include <fcntl.h>\n#include <sys/klog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <limits.h>\n#include <tools/dis-asm-compat.h>\n\n#define CMD_ACTION_SIZE_BUFFER\t\t10\n#define CMD_ACTION_READ_ALL\t\t3\n\nstatic void get_exec_path(char *tpath, size_t size)\n{\n\tchar *path;\n\tssize_t len;\n\n\tsnprintf(tpath, size, \"/proc/%d/exe\", (int) getpid());\n\ttpath[size - 1] = 0;\n\n\tpath = strdup(tpath);\n\tassert(path);\n\n\tlen = readlink(path, tpath, size);\n\ttpath[len] = 0;\n\n\tfree(path);\n}\n\nstatic void get_asm_insns(uint8_t *image, size_t len, int opcodes)\n{\n\tint count, i, pc = 0;\n\tchar tpath[PATH_MAX];\n\tstruct disassemble_info info;\n\tdisassembler_ftype disassemble;\n\tbfd *bfdf;\n\n\tmemset(tpath, 0, sizeof(tpath));\n\tget_exec_path(tpath, sizeof(tpath));\n\n\tbfdf = bfd_openr(tpath, NULL);\n\tassert(bfdf);\n\tassert(bfd_check_format(bfdf, bfd_object));\n\n\tinit_disassemble_info_compat(&info, stdout,\n\t\t\t\t     (fprintf_ftype) fprintf,\n\t\t\t\t     fprintf_styled);\n\tinfo.arch = bfd_get_arch(bfdf);\n\tinfo.mach = bfd_get_mach(bfdf);\n\tinfo.buffer = image;\n\tinfo.buffer_length = len;\n\n\tdisassemble_init_for_target(&info);\n\n#ifdef DISASM_FOUR_ARGS_SIGNATURE\n\tdisassemble = disassembler(info.arch,\n\t\t\t\t   bfd_big_endian(bfdf),\n\t\t\t\t   info.mach,\n\t\t\t\t   bfdf);\n#else\n\tdisassemble = disassembler(bfdf);\n#endif\n\tassert(disassemble);\n\n\tdo {\n\t\tprintf(\"%4x:\\t\", pc);\n\n\t\tcount = disassemble(pc, &info);\n\n\t\tif (opcodes) {\n\t\t\tprintf(\"\\n\\t\");\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\tprintf(\"%02x \", (uint8_t) image[pc + i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\tpc += count;\n\t} while(count > 0 && pc < len);\n\n\tbfd_close(bfdf);\n}\n\nstatic char *get_klog_buff(unsigned int *klen)\n{\n\tint ret, len;\n\tchar *buff;\n\n\tlen = klogctl(CMD_ACTION_SIZE_BUFFER, NULL, 0);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tbuff = malloc(len);\n\tif (!buff)\n\t\treturn NULL;\n\n\tret = klogctl(CMD_ACTION_READ_ALL, buff, len);\n\tif (ret < 0) {\n\t\tfree(buff);\n\t\treturn NULL;\n\t}\n\n\t*klen = ret;\n\treturn buff;\n}\n\nstatic char *get_flog_buff(const char *file, unsigned int *klen)\n{\n\tint fd, ret, len;\n\tstruct stat fi;\n\tchar *buff;\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fstat(fd, &fi);\n\tif (ret < 0 || !S_ISREG(fi.st_mode))\n\t\tgoto out;\n\n\tlen = fi.st_size + 1;\n\tbuff = malloc(len);\n\tif (!buff)\n\t\tgoto out;\n\n\tmemset(buff, 0, len);\n\tret = read(fd, buff, len - 1);\n\tif (ret <= 0)\n\t\tgoto out_free;\n\n\tclose(fd);\n\t*klen = ret;\n\treturn buff;\nout_free:\n\tfree(buff);\nout:\n\tclose(fd);\n\treturn NULL;\n}\n\nstatic char *get_log_buff(const char *file, unsigned int *klen)\n{\n\treturn file ? get_flog_buff(file, klen) : get_klog_buff(klen);\n}\n\nstatic void put_log_buff(char *buff)\n{\n\tfree(buff);\n}\n\nstatic uint8_t *get_last_jit_image(char *haystack, size_t hlen,\n\t\t\t\t   unsigned int *ilen)\n{\n\tchar *ptr, *pptr, *tmp;\n\toff_t off = 0;\n\tunsigned int proglen;\n\tint ret, flen, pass, ulen = 0;\n\tregmatch_t pmatch[1];\n\tunsigned long base;\n\tregex_t regex;\n\tuint8_t *image;\n\n\tif (hlen == 0)\n\t\treturn NULL;\n\n\tret = regcomp(&regex, \"flen=[[:alnum:]]+ proglen=[[:digit:]]+ \"\n\t\t      \"pass=[[:digit:]]+ image=[[:xdigit:]]+\", REG_EXTENDED);\n\tassert(ret == 0);\n\n\tptr = haystack;\n\tmemset(pmatch, 0, sizeof(pmatch));\n\n\twhile (1) {\n\t\tret = regexec(&regex, ptr, 1, pmatch, 0);\n\t\tif (ret == 0) {\n\t\t\tptr += pmatch[0].rm_eo;\n\t\t\toff += pmatch[0].rm_eo;\n\t\t\tassert(off < hlen);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tptr = haystack + off - (pmatch[0].rm_eo - pmatch[0].rm_so);\n\tret = sscanf(ptr, \"flen=%d proglen=%u pass=%d image=%lx\",\n\t\t     &flen, &proglen, &pass, &base);\n\tif (ret != 4) {\n\t\tregfree(&regex);\n\t\treturn NULL;\n\t}\n\tif (proglen > 1000000) {\n\t\tprintf(\"proglen of %d too big, stopping\\n\", proglen);\n\t\treturn NULL;\n\t}\n\n\timage = malloc(proglen);\n\tif (!image) {\n\t\tprintf(\"Out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(image, 0, proglen);\n\n\ttmp = ptr = haystack + off;\n\twhile ((ptr = strtok(tmp, \"\\n\")) != NULL && ulen < proglen) {\n\t\ttmp = NULL;\n\t\tif (!strstr(ptr, \"JIT code\"))\n\t\t\tcontinue;\n\t\tpptr = ptr;\n\t\twhile ((ptr = strstr(pptr, \":\")))\n\t\t\tpptr = ptr + 1;\n\t\tptr = pptr;\n\t\tdo {\n\t\t\timage[ulen++] = (uint8_t) strtoul(pptr, &pptr, 16);\n\t\t\tif (ptr == pptr) {\n\t\t\t\tulen--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ulen >= proglen)\n\t\t\t\tbreak;\n\t\t\tptr = pptr;\n\t\t} while (1);\n\t}\n\n\tassert(ulen == proglen);\n\tprintf(\"%u bytes emitted from JIT compiler (pass:%d, flen:%d)\\n\",\n\t       proglen, pass, flen);\n\tprintf(\"%lx + <x>:\\n\", base);\n\n\tregfree(&regex);\n\t*ilen = ulen;\n\treturn image;\n}\n\nstatic void usage(void)\n{\n\tprintf(\"Usage: bpf_jit_disasm [...]\\n\");\n\tprintf(\"       -o          Also display related opcodes (default: off).\\n\");\n\tprintf(\"       -O <file>   Write binary image of code to file, don't disassemble to stdout.\\n\");\n\tprintf(\"       -f <file>   Read last image dump from file or stdin (default: klog).\\n\");\n\tprintf(\"       -h          Display this help.\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned int len, klen, opt, opcodes = 0;\n\tchar *kbuff, *file = NULL;\n\tchar *ofile = NULL;\n\tint ofd;\n\tssize_t nr;\n\tuint8_t *pos;\n\tuint8_t *image = NULL;\n\n\twhile ((opt = getopt(argc, argv, \"of:O:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'o':\n\t\t\topcodes = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tofile = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfile = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbfd_init();\n\n\tkbuff = get_log_buff(file, &klen);\n\tif (!kbuff) {\n\t\tfprintf(stderr, \"Could not retrieve log buffer!\\n\");\n\t\treturn -1;\n\t}\n\n\timage = get_last_jit_image(kbuff, klen, &len);\n\tif (!image) {\n\t\tfprintf(stderr, \"No JIT image found!\\n\");\n\t\tgoto done;\n\t}\n\tif (!ofile) {\n\t\tget_asm_insns(image, len, opcodes);\n\t\tgoto done;\n\t}\n\n\tofd = open(ofile, O_WRONLY | O_CREAT | O_TRUNC, DEFFILEMODE);\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Could not open file %s for writing: \", ofile);\n\t\tperror(NULL);\n\t\tgoto done;\n\t}\n\tpos = image;\n\tdo {\n\t\tnr = write(ofd, pos, len);\n\t\tif (nr < 0) {\n\t\t\tfprintf(stderr, \"Could not write data to %s: \", ofile);\n\t\t\tperror(NULL);\n\t\t\tgoto done;\n\t\t}\n\t\tlen -= nr;\n\t\tpos += nr;\n\t} while (len);\n\tclose(ofd);\n\ndone:\n\tput_log_buff(kbuff);\n\tfree(image);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}