{
  "module_name": "getdelays.c",
  "hash_id": "3e89000ccb6aca5e25ee827352d771bdf3cd8a04c69440afcf7c350f7efb3e25",
  "original_prompt": "Ingested from linux-6.6.14/tools/accounting/getdelays.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <poll.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#include <linux/genetlink.h>\n#include <linux/taskstats.h>\n#include <linux/cgroupstats.h>\n\n \n#define GENLMSG_DATA(glh)\t((void *)(NLMSG_DATA(glh) + GENL_HDRLEN))\n#define GENLMSG_PAYLOAD(glh)\t(NLMSG_PAYLOAD(glh, 0) - GENL_HDRLEN)\n#define NLA_DATA(na)\t\t((void *)((char*)(na) + NLA_HDRLEN))\n#define NLA_PAYLOAD(len)\t(len - NLA_HDRLEN)\n\n#define err(code, fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tfprintf(stderr, fmt, ##arg);\t\\\n\t\texit(code);\t\t\t\\\n\t} while (0)\n\nint rcvbufsz;\nchar name[100];\nint dbg;\nint print_delays;\nint print_io_accounting;\nint print_task_context_switch_counts;\n\n#define PRINTF(fmt, arg...) {\t\t\t\\\n\t    if (dbg) {\t\t\t\t\\\n\t\tprintf(fmt, ##arg);\t\t\\\n\t    }\t\t\t\t\t\\\n\t}\n\n \n#define MAX_MSG_SIZE\t1024\n \n#define MAX_CPUS\t32\n\nstruct msgtemplate {\n\tstruct nlmsghdr n;\n\tstruct genlmsghdr g;\n\tchar buf[MAX_MSG_SIZE];\n};\n\nchar cpumask[100+6*MAX_CPUS];\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"getdelays [-dilv] [-w logfile] [-r bufsize] \"\n\t\t\t\"[-m cpumask] [-t tgid] [-p pid]\\n\");\n\tfprintf(stderr, \"  -d: print delayacct stats\\n\");\n\tfprintf(stderr, \"  -i: print IO accounting (works only with -p)\\n\");\n\tfprintf(stderr, \"  -l: listen forever\\n\");\n\tfprintf(stderr, \"  -v: debug on\\n\");\n\tfprintf(stderr, \"  -C: container path\\n\");\n}\n\n \nstatic int create_nl_socket(int protocol)\n{\n\tint fd;\n\tstruct sockaddr_nl local;\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, protocol);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (rcvbufsz)\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,\n\t\t\t\t&rcvbufsz, sizeof(rcvbufsz)) < 0) {\n\t\t\tfprintf(stderr, \"Unable to set socket rcv buf size to %d\\n\",\n\t\t\t\trcvbufsz);\n\t\t\tgoto error;\n\t\t}\n\n\tmemset(&local, 0, sizeof(local));\n\tlocal.nl_family = AF_NETLINK;\n\n\tif (bind(fd, (struct sockaddr *) &local, sizeof(local)) < 0)\n\t\tgoto error;\n\n\treturn fd;\nerror:\n\tclose(fd);\n\treturn -1;\n}\n\n\nstatic int send_cmd(int sd, __u16 nlmsg_type, __u32 nlmsg_pid,\n\t     __u8 genl_cmd, __u16 nla_type,\n\t     void *nla_data, int nla_len)\n{\n\tstruct nlattr *na;\n\tstruct sockaddr_nl nladdr;\n\tint r, buflen;\n\tchar *buf;\n\n\tstruct msgtemplate msg;\n\n\tmsg.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\n\tmsg.n.nlmsg_type = nlmsg_type;\n\tmsg.n.nlmsg_flags = NLM_F_REQUEST;\n\tmsg.n.nlmsg_seq = 0;\n\tmsg.n.nlmsg_pid = nlmsg_pid;\n\tmsg.g.cmd = genl_cmd;\n\tmsg.g.version = 0x1;\n\tna = (struct nlattr *) GENLMSG_DATA(&msg);\n\tna->nla_type = nla_type;\n\tna->nla_len = nla_len + NLA_HDRLEN;\n\tmemcpy(NLA_DATA(na), nla_data, nla_len);\n\tmsg.n.nlmsg_len += NLMSG_ALIGN(na->nla_len);\n\n\tbuf = (char *) &msg;\n\tbuflen = msg.n.nlmsg_len ;\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\twhile ((r = sendto(sd, buf, buflen, 0, (struct sockaddr *) &nladdr,\n\t\t\t   sizeof(nladdr))) < buflen) {\n\t\tif (r > 0) {\n\t\t\tbuf += r;\n\t\t\tbuflen -= r;\n\t\t} else if (errno != EAGAIN)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int get_family_id(int sd)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct genlmsghdr g;\n\t\tchar buf[256];\n\t} ans;\n\n\tint id = 0, rc;\n\tstruct nlattr *na;\n\tint rep_len;\n\n\tstrcpy(name, TASKSTATS_GENL_NAME);\n\trc = send_cmd(sd, GENL_ID_CTRL, getpid(), CTRL_CMD_GETFAMILY,\n\t\t\tCTRL_ATTR_FAMILY_NAME, (void *)name,\n\t\t\tstrlen(TASKSTATS_GENL_NAME)+1);\n\tif (rc < 0)\n\t\treturn 0;\t \n\n\trep_len = recv(sd, &ans, sizeof(ans), 0);\n\tif (ans.n.nlmsg_type == NLMSG_ERROR ||\n\t    (rep_len < 0) || !NLMSG_OK((&ans.n), rep_len))\n\t\treturn 0;\n\n\tna = (struct nlattr *) GENLMSG_DATA(&ans);\n\tna = (struct nlattr *) ((char *) na + NLA_ALIGN(na->nla_len));\n\tif (na->nla_type == CTRL_ATTR_FAMILY_ID) {\n\t\tid = *(__u16 *) NLA_DATA(na);\n\t}\n\treturn id;\n}\n\n#define average_ms(t, c) (t / 1000000ULL / (c ? c : 1))\n\nstatic void print_delayacct(struct taskstats *t)\n{\n\tprintf(\"\\n\\nCPU   %15s%15s%15s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15llu%15llu%15.3fms\\n\"\n\t       \"IO    %15s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"SWAP  %15s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"RECLAIM  %12s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"THRASHING%12s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"COMPACT  %12s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"WPCOPY   %12s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\"\n\t       \"IRQ   %15s%15s%15s\\n\"\n\t       \"      %15llu%15llu%15.3fms\\n\",\n\t       \"count\", \"real total\", \"virtual total\",\n\t       \"delay total\", \"delay average\",\n\t       (unsigned long long)t->cpu_count,\n\t       (unsigned long long)t->cpu_run_real_total,\n\t       (unsigned long long)t->cpu_run_virtual_total,\n\t       (unsigned long long)t->cpu_delay_total,\n\t       average_ms((double)t->cpu_delay_total, t->cpu_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->blkio_count,\n\t       (unsigned long long)t->blkio_delay_total,\n\t       average_ms((double)t->blkio_delay_total, t->blkio_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->swapin_count,\n\t       (unsigned long long)t->swapin_delay_total,\n\t       average_ms((double)t->swapin_delay_total, t->swapin_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->freepages_count,\n\t       (unsigned long long)t->freepages_delay_total,\n\t       average_ms((double)t->freepages_delay_total, t->freepages_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->thrashing_count,\n\t       (unsigned long long)t->thrashing_delay_total,\n\t       average_ms((double)t->thrashing_delay_total, t->thrashing_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->compact_count,\n\t       (unsigned long long)t->compact_delay_total,\n\t       average_ms((double)t->compact_delay_total, t->compact_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->wpcopy_count,\n\t       (unsigned long long)t->wpcopy_delay_total,\n\t       average_ms((double)t->wpcopy_delay_total, t->wpcopy_count),\n\t       \"count\", \"delay total\", \"delay average\",\n\t       (unsigned long long)t->irq_count,\n\t       (unsigned long long)t->irq_delay_total,\n\t       average_ms((double)t->irq_delay_total, t->irq_count));\n}\n\nstatic void task_context_switch_counts(struct taskstats *t)\n{\n\tprintf(\"\\n\\nTask   %15s%15s\\n\"\n\t       \"       %15llu%15llu\\n\",\n\t       \"voluntary\", \"nonvoluntary\",\n\t       (unsigned long long)t->nvcsw, (unsigned long long)t->nivcsw);\n}\n\nstatic void print_cgroupstats(struct cgroupstats *c)\n{\n\tprintf(\"sleeping %llu, blocked %llu, running %llu, stopped %llu, \"\n\t\t\"uninterruptible %llu\\n\", (unsigned long long)c->nr_sleeping,\n\t\t(unsigned long long)c->nr_io_wait,\n\t\t(unsigned long long)c->nr_running,\n\t\t(unsigned long long)c->nr_stopped,\n\t\t(unsigned long long)c->nr_uninterruptible);\n}\n\n\nstatic void print_ioacct(struct taskstats *t)\n{\n\tprintf(\"%s: read=%llu, write=%llu, cancelled_write=%llu\\n\",\n\t\tt->ac_comm,\n\t\t(unsigned long long)t->read_bytes,\n\t\t(unsigned long long)t->write_bytes,\n\t\t(unsigned long long)t->cancelled_write_bytes);\n}\n\nint main(int argc, char *argv[])\n{\n\tint c, rc, rep_len, aggr_len, len2;\n\tint cmd_type = TASKSTATS_CMD_ATTR_UNSPEC;\n\t__u16 id;\n\t__u32 mypid;\n\n\tstruct nlattr *na;\n\tint nl_sd = -1;\n\tint len = 0;\n\tpid_t tid = 0;\n\tpid_t rtid = 0;\n\n\tint fd = 0;\n\tint write_file = 0;\n\tint maskset = 0;\n\tchar *logfile = NULL;\n\tint loop = 0;\n\tint containerset = 0;\n\tchar *containerpath = NULL;\n\tint cfd = 0;\n\tint forking = 0;\n\tsigset_t sigset;\n\n\tstruct msgtemplate msg;\n\n\twhile (!forking) {\n\t\tc = getopt(argc, argv, \"qdiw:r:m:t:p:vlC:c:\");\n\t\tif (c < 0)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'd':\n\t\t\tprintf(\"print delayacct stats ON\\n\");\n\t\t\tprint_delays = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tprintf(\"printing IO accounting\\n\");\n\t\t\tprint_io_accounting = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tprintf(\"printing task/process context switch rates\\n\");\n\t\t\tprint_task_context_switch_counts = 1;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcontainerset = 1;\n\t\t\tcontainerpath = optarg;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tlogfile = strdup(optarg);\n\t\t\tprintf(\"write to file %s\\n\", logfile);\n\t\t\twrite_file = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trcvbufsz = atoi(optarg);\n\t\t\tprintf(\"receive buf size %d\\n\", rcvbufsz);\n\t\t\tif (rcvbufsz < 0)\n\t\t\t\terr(1, \"Invalid rcv buf size\\n\");\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tstrncpy(cpumask, optarg, sizeof(cpumask));\n\t\t\tcpumask[sizeof(cpumask) - 1] = '\\0';\n\t\t\tmaskset = 1;\n\t\t\tprintf(\"cpumask %s maskset %d\\n\", cpumask, maskset);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttid = atoi(optarg);\n\t\t\tif (!tid)\n\t\t\t\terr(1, \"Invalid tgid\\n\");\n\t\t\tcmd_type = TASKSTATS_CMD_ATTR_TGID;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttid = atoi(optarg);\n\t\t\tif (!tid)\n\t\t\t\terr(1, \"Invalid pid\\n\");\n\t\t\tcmd_type = TASKSTATS_CMD_ATTR_PID;\n\t\t\tbreak;\n\t\tcase 'c':\n\n\t\t\t \n\t\t\tif (sigemptyset(&sigset) == -1)\n\t\t\t\terr(1, \"Failed to empty sigset\");\n\t\t\tif (sigaddset(&sigset, SIGCHLD))\n\t\t\t\terr(1, \"Failed to set sigchld in sigset\");\n\t\t\tsigprocmask(SIG_BLOCK, &sigset, NULL);\n\n\t\t\t \n\t\t\ttid = fork();\n\t\t\tif (tid < 0)\n\t\t\t\terr(1, \"Fork failed\\n\");\n\t\t\tif (tid == 0)\n\t\t\t\tif (execvp(argv[optind - 1],\n\t\t\t\t    &argv[optind - 1]) < 0)\n\t\t\t\t\texit(-1);\n\n\t\t\t \n\t\t\tcmd_type = TASKSTATS_CMD_ATTR_PID;\n\t\t\tforking = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprintf(\"debug on\\n\");\n\t\t\tdbg = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tprintf(\"listen forever\\n\");\n\t\t\tloop = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tif (write_file) {\n\t\tfd = open(logfile, O_WRONLY | O_CREAT | O_TRUNC,\n\t\t\t  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\tif (fd == -1) {\n\t\t\tperror(\"Cannot open output file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tnl_sd = create_nl_socket(NETLINK_GENERIC);\n\tif (nl_sd < 0)\n\t\terr(1, \"error creating Netlink socket\\n\");\n\n\n\tmypid = getpid();\n\tid = get_family_id(nl_sd);\n\tif (!id) {\n\t\tfprintf(stderr, \"Error getting family id, errno %d\\n\", errno);\n\t\tgoto err;\n\t}\n\tPRINTF(\"family id %d\\n\", id);\n\n\tif (maskset) {\n\t\trc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\n\t\t\t      TASKSTATS_CMD_ATTR_REGISTER_CPUMASK,\n\t\t\t      &cpumask, strlen(cpumask) + 1);\n\t\tPRINTF(\"Sent register cpumask, retval %d\\n\", rc);\n\t\tif (rc < 0) {\n\t\t\tfprintf(stderr, \"error sending register cpumask\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (tid && containerset) {\n\t\tfprintf(stderr, \"Select either -t or -C, not both\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (tid && forking) {\n\t\tint sig_received;\n\t\tsigwait(&sigset, &sig_received);\n\t}\n\n\tif (tid) {\n\t\trc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\n\t\t\t      cmd_type, &tid, sizeof(__u32));\n\t\tPRINTF(\"Sent pid/tgid, retval %d\\n\", rc);\n\t\tif (rc < 0) {\n\t\t\tfprintf(stderr, \"error sending tid/tgid cmd\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (containerset) {\n\t\tcfd = open(containerpath, O_RDONLY);\n\t\tif (cfd < 0) {\n\t\t\tperror(\"error opening container file\");\n\t\t\tgoto err;\n\t\t}\n\t\trc = send_cmd(nl_sd, id, mypid, CGROUPSTATS_CMD_GET,\n\t\t\t      CGROUPSTATS_CMD_ATTR_FD, &cfd, sizeof(__u32));\n\t\tif (rc < 0) {\n\t\t\tperror(\"error sending cgroupstats command\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (!maskset && !tid && !containerset) {\n\t\tusage();\n\t\tgoto err;\n\t}\n\n\tdo {\n\t\trep_len = recv(nl_sd, &msg, sizeof(msg), 0);\n\t\tPRINTF(\"received %d bytes\\n\", rep_len);\n\n\t\tif (rep_len < 0) {\n\t\t\tfprintf(stderr, \"nonfatal reply error: errno %d\\n\",\n\t\t\t\terrno);\n\t\t\tcontinue;\n\t\t}\n\t\tif (msg.n.nlmsg_type == NLMSG_ERROR ||\n\t\t    !NLMSG_OK((&msg.n), rep_len)) {\n\t\t\tstruct nlmsgerr *err = NLMSG_DATA(&msg);\n\t\t\tfprintf(stderr, \"fatal reply error,  errno %d\\n\",\n\t\t\t\terr->error);\n\t\t\tgoto done;\n\t\t}\n\n\t\tPRINTF(\"nlmsghdr size=%zu, nlmsg_len=%d, rep_len=%d\\n\",\n\t\t       sizeof(struct nlmsghdr), msg.n.nlmsg_len, rep_len);\n\n\n\t\trep_len = GENLMSG_PAYLOAD(&msg.n);\n\n\t\tna = (struct nlattr *) GENLMSG_DATA(&msg);\n\t\tlen = 0;\n\t\twhile (len < rep_len) {\n\t\t\tlen += NLA_ALIGN(na->nla_len);\n\t\t\tswitch (na->nla_type) {\n\t\t\tcase TASKSTATS_TYPE_AGGR_TGID:\n\t\t\t\t \n\t\t\tcase TASKSTATS_TYPE_AGGR_PID:\n\t\t\t\taggr_len = NLA_PAYLOAD(na->nla_len);\n\t\t\t\tlen2 = 0;\n\t\t\t\t \n\t\t\t\tna = (struct nlattr *) NLA_DATA(na);\n\t\t\t\twhile (len2 < aggr_len) {\n\t\t\t\t\tswitch (na->nla_type) {\n\t\t\t\t\tcase TASKSTATS_TYPE_PID:\n\t\t\t\t\t\trtid = *(int *) NLA_DATA(na);\n\t\t\t\t\t\tif (print_delays)\n\t\t\t\t\t\t\tprintf(\"PID\\t%d\\n\", rtid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TASKSTATS_TYPE_TGID:\n\t\t\t\t\t\trtid = *(int *) NLA_DATA(na);\n\t\t\t\t\t\tif (print_delays)\n\t\t\t\t\t\t\tprintf(\"TGID\\t%d\\n\", rtid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TASKSTATS_TYPE_STATS:\n\t\t\t\t\t\tif (print_delays)\n\t\t\t\t\t\t\tprint_delayacct((struct taskstats *) NLA_DATA(na));\n\t\t\t\t\t\tif (print_io_accounting)\n\t\t\t\t\t\t\tprint_ioacct((struct taskstats *) NLA_DATA(na));\n\t\t\t\t\t\tif (print_task_context_switch_counts)\n\t\t\t\t\t\t\ttask_context_switch_counts((struct taskstats *) NLA_DATA(na));\n\t\t\t\t\t\tif (fd) {\n\t\t\t\t\t\t\tif (write(fd, NLA_DATA(na), na->nla_len) < 0) {\n\t\t\t\t\t\t\t\terr(1,\"write error\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!loop)\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TASKSTATS_TYPE_NULL:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Unknown nested\"\n\t\t\t\t\t\t\t\" nla_type %d\\n\",\n\t\t\t\t\t\t\tna->nla_type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlen2 += NLA_ALIGN(na->nla_len);\n\t\t\t\t\tna = (struct nlattr *)((char *)na +\n\t\t\t\t\t\t\t       NLA_ALIGN(na->nla_len));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CGROUPSTATS_TYPE_CGROUP_STATS:\n\t\t\t\tprint_cgroupstats(NLA_DATA(na));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unknown nla_type %d\\n\",\n\t\t\t\t\tna->nla_type);\n\t\t\tcase TASKSTATS_TYPE_NULL:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tna = (struct nlattr *) (GENLMSG_DATA(&msg) + len);\n\t\t}\n\t} while (loop);\ndone:\n\tif (maskset) {\n\t\trc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\n\t\t\t      TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK,\n\t\t\t      &cpumask, strlen(cpumask) + 1);\n\t\tprintf(\"Sent deregister mask, retval %d\\n\", rc);\n\t\tif (rc < 0)\n\t\t\terr(rc, \"error sending deregister cpumask\\n\");\n\t}\nerr:\n\tclose(nl_sd);\n\tif (fd)\n\t\tclose(fd);\n\tif (cfd)\n\t\tclose(cfd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}