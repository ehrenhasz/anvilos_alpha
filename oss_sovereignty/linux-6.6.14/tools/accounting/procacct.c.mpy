{
  "module_name": "procacct.c",
  "hash_id": "9253172864e2e614febacf9a03adece5623c5f103bfc8412324cdc10a56e0d18",
  "original_prompt": "Ingested from linux-6.6.14/tools/accounting/procacct.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <poll.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#include <linux/genetlink.h>\n#include <linux/acct.h>\n#include <linux/taskstats.h>\n#include <linux/kdev_t.h>\n\n \n#define GENLMSG_DATA(glh)\t((void *)(NLMSG_DATA(glh) + GENL_HDRLEN))\n#define GENLMSG_PAYLOAD(glh)\t(NLMSG_PAYLOAD(glh, 0) - GENL_HDRLEN)\n#define NLA_DATA(na)\t\t((void *)((char *)(na) + NLA_HDRLEN))\n#define NLA_PAYLOAD(len)\t(len - NLA_HDRLEN)\n\n#define err(code, fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tfprintf(stderr, fmt, ##arg);\t\\\n\t\texit(code);\t\t\t\\\n\t} while (0)\n\nint rcvbufsz;\nchar name[100];\nint dbg;\nint print_delays;\nint print_io_accounting;\nint print_task_context_switch_counts;\n\n#define PRINTF(fmt, arg...) {\t\t\t\\\n\t\tif (dbg) {\t\t\t\\\n\t\t\tprintf(fmt, ##arg);\t\\\n\t\t}\t\t\t\t\\\n\t}\n\n \n#define MAX_MSG_SIZE\t1024\n \n#define MAX_CPUS\t32\n\nstruct msgtemplate {\n\tstruct nlmsghdr n;\n\tstruct genlmsghdr g;\n\tchar buf[MAX_MSG_SIZE];\n};\n\nchar cpumask[100+6*MAX_CPUS];\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"procacct [-v] [-w logfile] [-r bufsize] [-m cpumask]\\n\");\n\tfprintf(stderr, \"  -v: debug on\\n\");\n}\n\n \nstatic int create_nl_socket(int protocol)\n{\n\tint fd;\n\tstruct sockaddr_nl local;\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, protocol);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (rcvbufsz)\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,\n\t\t\t\t&rcvbufsz, sizeof(rcvbufsz)) < 0) {\n\t\t\tfprintf(stderr, \"Unable to set socket rcv buf size to %d\\n\",\n\t\t\t\trcvbufsz);\n\t\t\tgoto error;\n\t\t}\n\n\tmemset(&local, 0, sizeof(local));\n\tlocal.nl_family = AF_NETLINK;\n\n\tif (bind(fd, (struct sockaddr *) &local, sizeof(local)) < 0)\n\t\tgoto error;\n\n\treturn fd;\nerror:\n\tclose(fd);\n\treturn -1;\n}\n\n\nstatic int send_cmd(int sd, __u16 nlmsg_type, __u32 nlmsg_pid,\n\t     __u8 genl_cmd, __u16 nla_type,\n\t     void *nla_data, int nla_len)\n{\n\tstruct nlattr *na;\n\tstruct sockaddr_nl nladdr;\n\tint r, buflen;\n\tchar *buf;\n\n\tstruct msgtemplate msg;\n\n\tmsg.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\n\tmsg.n.nlmsg_type = nlmsg_type;\n\tmsg.n.nlmsg_flags = NLM_F_REQUEST;\n\tmsg.n.nlmsg_seq = 0;\n\tmsg.n.nlmsg_pid = nlmsg_pid;\n\tmsg.g.cmd = genl_cmd;\n\tmsg.g.version = 0x1;\n\tna = (struct nlattr *) GENLMSG_DATA(&msg);\n\tna->nla_type = nla_type;\n\tna->nla_len = nla_len + 1 + NLA_HDRLEN;\n\tmemcpy(NLA_DATA(na), nla_data, nla_len);\n\tmsg.n.nlmsg_len += NLMSG_ALIGN(na->nla_len);\n\n\tbuf = (char *) &msg;\n\tbuflen = msg.n.nlmsg_len;\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\twhile ((r = sendto(sd, buf, buflen, 0, (struct sockaddr *) &nladdr,\n\t\t\t   sizeof(nladdr))) < buflen) {\n\t\tif (r > 0) {\n\t\t\tbuf += r;\n\t\t\tbuflen -= r;\n\t\t} else if (errno != EAGAIN)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int get_family_id(int sd)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct genlmsghdr g;\n\t\tchar buf[256];\n\t} ans;\n\n\tint id = 0, rc;\n\tstruct nlattr *na;\n\tint rep_len;\n\n\tstrcpy(name, TASKSTATS_GENL_NAME);\n\trc = send_cmd(sd, GENL_ID_CTRL, getpid(), CTRL_CMD_GETFAMILY,\n\t\t\tCTRL_ATTR_FAMILY_NAME, (void *)name,\n\t\t\tstrlen(TASKSTATS_GENL_NAME)+1);\n\tif (rc < 0)\n\t\treturn 0;\t \n\n\trep_len = recv(sd, &ans, sizeof(ans), 0);\n\tif (ans.n.nlmsg_type == NLMSG_ERROR ||\n\t    (rep_len < 0) || !NLMSG_OK((&ans.n), rep_len))\n\t\treturn 0;\n\n\tna = (struct nlattr *) GENLMSG_DATA(&ans);\n\tna = (struct nlattr *) ((char *) na + NLA_ALIGN(na->nla_len));\n\tif (na->nla_type == CTRL_ATTR_FAMILY_ID)\n\t\tid = *(__u16 *) NLA_DATA(na);\n\n\treturn id;\n}\n\n#define average_ms(t, c) (t / 1000000ULL / (c ? c : 1))\n\nstatic void print_procacct(struct taskstats *t)\n{\n\t \n\tprintf(\n\t\t\"%c pid=%lu tgid=%lu uid=%lu wall=%llu gwall=%llu cpu=%llu vmpeak=%llu rsspeak=%llu dev=%lu:%lu inode=%llu comm=%s\\n\"\n\t,\tt->version >= 12 ? (t->ac_flag & AGROUP ? 'P' : 'T') : '?'\n\t,\t(unsigned long)t->ac_pid\n\t,\t(unsigned long)(t->version >= 12 ? t->ac_tgid : 0)\n\t,\t(unsigned long)t->ac_uid\n\t,\t(unsigned long long)t->ac_etime\n\t,\t(unsigned long long)(t->version >= 12 ? t->ac_tgetime : 0)\n\t,\t(unsigned long long)(t->ac_utime+t->ac_stime)\n\t,\t(unsigned long long)t->hiwater_vm\n\t,\t(unsigned long long)t->hiwater_rss\n\t,\t(unsigned long)(t->version >= 12 ? MAJOR(t->ac_exe_dev) : 0)\n\t,\t(unsigned long)(t->version >= 12 ? MINOR(t->ac_exe_dev) : 0)\n\t,\t(unsigned long long)(t->version >= 12 ? t->ac_exe_inode : 0)\n\t,\tt->ac_comm\n\t);\n}\n\nvoid handle_aggr(int mother, struct nlattr *na, int fd)\n{\n\tint aggr_len = NLA_PAYLOAD(na->nla_len);\n\tint len2 = 0;\n\tpid_t rtid = 0;\n\n\tna = (struct nlattr *) NLA_DATA(na);\n\twhile (len2 < aggr_len) {\n\t\tswitch (na->nla_type) {\n\t\tcase TASKSTATS_TYPE_PID:\n\t\t\trtid = *(int *) NLA_DATA(na);\n\t\t\tPRINTF(\"PID\\t%d\\n\", rtid);\n\t\t\tbreak;\n\t\tcase TASKSTATS_TYPE_TGID:\n\t\t\trtid = *(int *) NLA_DATA(na);\n\t\t\tPRINTF(\"TGID\\t%d\\n\", rtid);\n\t\t\tbreak;\n\t\tcase TASKSTATS_TYPE_STATS:\n\t\t\tif (mother == TASKSTATS_TYPE_AGGR_PID)\n\t\t\t\tprint_procacct((struct taskstats *) NLA_DATA(na));\n\t\t\tif (fd) {\n\t\t\t\tif (write(fd, NLA_DATA(na), na->nla_len) < 0)\n\t\t\t\t\terr(1, \"write error\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TASKSTATS_TYPE_NULL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown nested nla_type %d\\n\",\n\t\t\t\tna->nla_type);\n\t\t\tbreak;\n\t\t}\n\t\tlen2 += NLA_ALIGN(na->nla_len);\n\t\tna = (struct nlattr *)((char *)na +\n\t\t\t\t\t\t NLA_ALIGN(na->nla_len));\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint c, rc, rep_len;\n\t__u16 id;\n\t__u32 mypid;\n\n\tstruct nlattr *na;\n\tint nl_sd = -1;\n\tint len = 0;\n\n\tint fd = 0;\n\tint write_file = 0;\n\tint maskset = 0;\n\tchar *logfile = NULL;\n\tint cfd = 0;\n\tint forking = 0;\n\n\tstruct msgtemplate msg;\n\n\twhile (!forking) {\n\t\tc = getopt(argc, argv, \"m:vr:\");\n\t\tif (c < 0)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'w':\n\t\t\tlogfile = strdup(optarg);\n\t\t\tprintf(\"write to file %s\\n\", logfile);\n\t\t\twrite_file = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trcvbufsz = atoi(optarg);\n\t\t\tprintf(\"receive buf size %d\\n\", rcvbufsz);\n\t\t\tif (rcvbufsz < 0)\n\t\t\t\terr(1, \"Invalid rcv buf size\\n\");\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tstrncpy(cpumask, optarg, sizeof(cpumask));\n\t\t\tcpumask[sizeof(cpumask) - 1] = '\\0';\n\t\t\tmaskset = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprintf(\"debug on\\n\");\n\t\t\tdbg = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(-1);\n\t\t}\n\t}\n\tif (!maskset) {\n\t\tmaskset = 1;\n\t\tstrncpy(cpumask, \"1\", sizeof(cpumask));\n\t\tcpumask[sizeof(cpumask) - 1] = '\\0';\n\t}\n\tprintf(\"cpumask %s maskset %d\\n\", cpumask, maskset);\n\n\tif (write_file) {\n\t\tfd = open(logfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\t\tif (fd == -1) {\n\t\t\tperror(\"Cannot open output file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tnl_sd = create_nl_socket(NETLINK_GENERIC);\n\tif (nl_sd < 0)\n\t\terr(1, \"error creating Netlink socket\\n\");\n\n\tmypid = getpid();\n\tid = get_family_id(nl_sd);\n\tif (!id) {\n\t\tfprintf(stderr, \"Error getting family id, errno %d\\n\", errno);\n\t\tgoto err;\n\t}\n\tPRINTF(\"family id %d\\n\", id);\n\n\tif (maskset) {\n\t\trc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\n\t\t\t      TASKSTATS_CMD_ATTR_REGISTER_CPUMASK,\n\t\t\t      &cpumask, strlen(cpumask) + 1);\n\t\tPRINTF(\"Sent register cpumask, retval %d\\n\", rc);\n\t\tif (rc < 0) {\n\t\t\tfprintf(stderr, \"error sending register cpumask\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdo {\n\t\trep_len = recv(nl_sd, &msg, sizeof(msg), 0);\n\t\tPRINTF(\"received %d bytes\\n\", rep_len);\n\n\t\tif (rep_len < 0) {\n\t\t\tfprintf(stderr, \"nonfatal reply error: errno %d\\n\",\n\t\t\t\terrno);\n\t\t\tcontinue;\n\t\t}\n\t\tif (msg.n.nlmsg_type == NLMSG_ERROR ||\n\t\t    !NLMSG_OK((&msg.n), rep_len)) {\n\t\t\tstruct nlmsgerr *err = NLMSG_DATA(&msg);\n\n\t\t\tfprintf(stderr, \"fatal reply error,  errno %d\\n\",\n\t\t\t\terr->error);\n\t\t\tgoto done;\n\t\t}\n\n\t\tPRINTF(\"nlmsghdr size=%zu, nlmsg_len=%d, rep_len=%d\\n\",\n\t\t       sizeof(struct nlmsghdr), msg.n.nlmsg_len, rep_len);\n\n\n\t\trep_len = GENLMSG_PAYLOAD(&msg.n);\n\n\t\tna = (struct nlattr *) GENLMSG_DATA(&msg);\n\t\tlen = 0;\n\t\twhile (len < rep_len) {\n\t\t\tlen += NLA_ALIGN(na->nla_len);\n\t\t\tint mother = na->nla_type;\n\n\t\t\tPRINTF(\"mother=%i\\n\", mother);\n\t\t\tswitch (na->nla_type) {\n\t\t\tcase TASKSTATS_TYPE_AGGR_PID:\n\t\t\tcase TASKSTATS_TYPE_AGGR_TGID:\n\t\t\t\t \n\t\t\t\thandle_aggr(mother, na, fd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unexpected nla_type %d\\n\",\n\t\t\t\t\tna->nla_type);\n\t\t\tcase TASKSTATS_TYPE_NULL:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tna = (struct nlattr *) (GENLMSG_DATA(&msg) + len);\n\t\t}\n\t} while (1);\ndone:\n\tif (maskset) {\n\t\trc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\n\t\t\t      TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK,\n\t\t\t      &cpumask, strlen(cpumask) + 1);\n\t\tprintf(\"Sent deregister mask, retval %d\\n\", rc);\n\t\tif (rc < 0)\n\t\t\terr(rc, \"error sending deregister cpumask\\n\");\n\t}\nerr:\n\tclose(nl_sd);\n\tif (fd)\n\t\tclose(fd);\n\tif (cfd)\n\t\tclose(cfd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}