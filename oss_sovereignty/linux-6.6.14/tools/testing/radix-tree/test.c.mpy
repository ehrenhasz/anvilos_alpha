{
  "module_name": "test.c",
  "hash_id": "cce4d0c29a36018532bd46d885f24c0b96347f0746ec9377592aa7e77380aa92",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/test.c",
  "human_readable_source": "\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n\n#include \"test.h\"\n\nstruct item *\nitem_tag_set(struct radix_tree_root *root, unsigned long index, int tag)\n{\n\treturn radix_tree_tag_set(root, index, tag);\n}\n\nstruct item *\nitem_tag_clear(struct radix_tree_root *root, unsigned long index, int tag)\n{\n\treturn radix_tree_tag_clear(root, index, tag);\n}\n\nint item_tag_get(struct radix_tree_root *root, unsigned long index, int tag)\n{\n\treturn radix_tree_tag_get(root, index, tag);\n}\n\nstruct item *item_create(unsigned long index, unsigned int order)\n{\n\tstruct item *ret = malloc(sizeof(*ret));\n\n\tret->index = index;\n\tret->order = order;\n\treturn ret;\n}\n\nint item_insert(struct radix_tree_root *root, unsigned long index)\n{\n\tstruct item *item = item_create(index, 0);\n\tint err = radix_tree_insert(root, item->index, item);\n\tif (err)\n\t\tfree(item);\n\treturn err;\n}\n\nvoid item_sanity(struct item *item, unsigned long index)\n{\n\tunsigned long mask;\n\tassert(!radix_tree_is_internal_node(item));\n\tassert(item->order < BITS_PER_LONG);\n\tmask = (1UL << item->order) - 1;\n\tassert((item->index | mask) == (index | mask));\n}\n\nvoid item_free(struct item *item, unsigned long index)\n{\n\titem_sanity(item, index);\n\tfree(item);\n}\n\nint item_delete(struct radix_tree_root *root, unsigned long index)\n{\n\tstruct item *item = radix_tree_delete(root, index);\n\n\tif (!item)\n\t\treturn 0;\n\n\titem_free(item, index);\n\treturn 1;\n}\n\nstatic void item_free_rcu(struct rcu_head *head)\n{\n\tstruct item *item = container_of(head, struct item, rcu_head);\n\n\tfree(item);\n}\n\nint item_delete_rcu(struct xarray *xa, unsigned long index)\n{\n\tstruct item *item = xa_erase(xa, index);\n\n\tif (item) {\n\t\titem_sanity(item, index);\n\t\tcall_rcu(&item->rcu_head, item_free_rcu);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid item_check_present(struct radix_tree_root *root, unsigned long index)\n{\n\tstruct item *item;\n\n\titem = radix_tree_lookup(root, index);\n\tassert(item != NULL);\n\titem_sanity(item, index);\n}\n\nstruct item *item_lookup(struct radix_tree_root *root, unsigned long index)\n{\n\treturn radix_tree_lookup(root, index);\n}\n\nvoid item_check_absent(struct radix_tree_root *root, unsigned long index)\n{\n\tstruct item *item;\n\n\titem = radix_tree_lookup(root, index);\n\tassert(item == NULL);\n}\n\n \nvoid item_gang_check_present(struct radix_tree_root *root,\n\t\t\tunsigned long start, unsigned long nr,\n\t\t\tint chunk, int hop)\n{\n\tstruct item *items[chunk];\n\tunsigned long into;\n\n\tfor (into = 0; into < nr; ) {\n\t\tint nfound;\n\t\tint nr_to_find = chunk;\n\t\tint i;\n\n\t\tif (nr_to_find > (nr - into))\n\t\t\tnr_to_find = nr - into;\n\n\t\tnfound = radix_tree_gang_lookup(root, (void **)items,\n\t\t\t\t\t\tstart + into, nr_to_find);\n\t\tassert(nfound == nr_to_find);\n\t\tfor (i = 0; i < nfound; i++)\n\t\t\tassert(items[i]->index == start + into + i);\n\t\tinto += hop;\n\t}\n}\n\n \nvoid item_full_scan(struct radix_tree_root *root, unsigned long start,\n\t\t\tunsigned long nr, int chunk)\n{\n\tstruct item *items[chunk];\n\tunsigned long into = 0;\n\tunsigned long this_index = start;\n\tint nfound;\n\tint i;\n\n\n\n\twhile ((nfound = radix_tree_gang_lookup(root, (void **)items, into,\n\t\t\t\t\tchunk))) {\n\n\t\tfor (i = 0; i < nfound; i++) {\n\t\t\tassert(items[i]->index == this_index);\n\t\t\tthis_index++;\n\t\t}\n\n\n\t\tinto = this_index;\n\t}\n\tif (chunk)\n\t\tassert(this_index == start + nr);\n\tnfound = radix_tree_gang_lookup(root, (void **)items,\n\t\t\t\t\tthis_index, chunk);\n\tassert(nfound == 0);\n}\n\n \nint tag_tagged_items(struct xarray *xa, unsigned long start, unsigned long end,\n\t\tunsigned batch, xa_mark_t iftag, xa_mark_t thentag)\n{\n\tXA_STATE(xas, xa, start);\n\tunsigned int tagged = 0;\n\tstruct item *item;\n\n\tif (batch == 0)\n\t\tbatch = 1;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, item, end, iftag) {\n\t\txas_set_mark(&xas, thentag);\n\t\tif (++tagged % batch)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\trcu_barrier();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n\n\treturn tagged;\n}\n\nstatic int verify_node(struct radix_tree_node *slot, unsigned int tag,\n\t\t\tint tagged)\n{\n\tint anyset = 0;\n\tint i;\n\tint j;\n\n\tslot = entry_to_node(slot);\n\n\t \n\tfor (i = 0; i < RADIX_TREE_TAG_LONGS; i++) {\n\t\tif (slot->tags[tag][i]) {\n\t\t\tanyset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tagged != anyset) {\n\t\tprintf(\"tag: %u, shift %u, tagged: %d, anyset: %d\\n\",\n\t\t\ttag, slot->shift, tagged, anyset);\n\t\tfor (j = 0; j < RADIX_TREE_MAX_TAGS; j++) {\n\t\t\tprintf(\"tag %d: \", j);\n\t\t\tfor (i = 0; i < RADIX_TREE_TAG_LONGS; i++)\n\t\t\t\tprintf(\"%016lx \", slot->tags[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tassert(tagged == anyset);\n\n\t \n\tif (slot->shift > 0) {\n\t\tfor (i = 0; i < RADIX_TREE_MAP_SIZE; i++)\n\t\t\tif (slot->slots[i])\n\t\t\t\tif (verify_node(slot->slots[i], tag,\n\t\t\t\t\t    !!test_bit(i, slot->tags[tag]))) {\n\t\t\t\t\tprintf(\"Failure at off %d\\n\", i);\n\t\t\t\t\tfor (j = 0; j < RADIX_TREE_MAX_TAGS; j++) {\n\t\t\t\t\t\tprintf(\"tag %d: \", j);\n\t\t\t\t\t\tfor (i = 0; i < RADIX_TREE_TAG_LONGS; i++)\n\t\t\t\t\t\t\tprintf(\"%016lx \", slot->tags[j][i]);\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t}\n\treturn 0;\n}\n\nvoid verify_tag_consistency(struct radix_tree_root *root, unsigned int tag)\n{\n\tstruct radix_tree_node *node = root->xa_head;\n\tif (!radix_tree_is_internal_node(node))\n\t\treturn;\n\tverify_node(node, tag, !!root_tag_get(root, tag));\n}\n\nvoid item_kill_tree(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tvoid *entry;\n\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\titem_free(entry, xas.xa_index);\n\t\t}\n\t\txas_store(&xas, NULL);\n\t}\n\n\tassert(xa_empty(xa));\n}\n\nvoid tree_verify_min_height(struct radix_tree_root *root, int maxindex)\n{\n\tunsigned shift;\n\tstruct radix_tree_node *node = root->xa_head;\n\tif (!radix_tree_is_internal_node(node)) {\n\t\tassert(maxindex == 0);\n\t\treturn;\n\t}\n\n\tnode = entry_to_node(node);\n\tassert(maxindex <= node_maxindex(node));\n\n\tshift = node->shift;\n\tif (shift > 0)\n\t\tassert(maxindex > shift_maxindex(shift - RADIX_TREE_MAP_SHIFT));\n\telse\n\t\tassert(maxindex > 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}