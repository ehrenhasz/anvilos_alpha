{
  "module_name": "idr-test.c",
  "hash_id": "8f16dd852583f7513a6b24c6e6b4b8fb0d4acd69cbee36027b6caf57efe02586",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/idr-test.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#include \"test.h\"\n\n#define DUMMY_PTR\t((void *)0x10)\n\nint item_idr_free(int id, void *p, void *data)\n{\n\tstruct item *item = p;\n\tassert(item->index == id);\n\tfree(p);\n\n\treturn 0;\n}\n\nvoid item_idr_remove(struct idr *idr, int id)\n{\n\tstruct item *item = idr_find(idr, id);\n\tassert(item->index == id);\n\tidr_remove(idr, id);\n\tfree(item);\n}\n\nvoid idr_alloc_test(void)\n{\n\tunsigned long i;\n\tDEFINE_IDR(idr);\n\n\tassert(idr_alloc_cyclic(&idr, DUMMY_PTR, 0, 0x4000, GFP_KERNEL) == 0);\n\tassert(idr_alloc_cyclic(&idr, DUMMY_PTR, 0x3ffd, 0x4000, GFP_KERNEL) == 0x3ffd);\n\tidr_remove(&idr, 0x3ffd);\n\tidr_remove(&idr, 0);\n\n\tfor (i = 0x3ffe; i < 0x4003; i++) {\n\t\tint id;\n\t\tstruct item *item;\n\n\t\tif (i < 0x4000)\n\t\t\titem = item_create(i, 0);\n\t\telse\n\t\t\titem = item_create(i - 0x3fff, 0);\n\n\t\tid = idr_alloc_cyclic(&idr, item, 1, 0x4000, GFP_KERNEL);\n\t\tassert(id == item->index);\n\t}\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n}\n\nvoid idr_replace_test(void)\n{\n\tDEFINE_IDR(idr);\n\n\tidr_alloc(&idr, (void *)-1, 10, 11, GFP_KERNEL);\n\tidr_replace(&idr, &idr, 10);\n\n\tidr_destroy(&idr);\n}\n\n \nvoid idr_null_test(void)\n{\n\tint i;\n\tDEFINE_IDR(idr);\n\n\tassert(idr_is_empty(&idr));\n\n\tassert(idr_alloc(&idr, NULL, 0, 0, GFP_KERNEL) == 0);\n\tassert(!idr_is_empty(&idr));\n\tidr_remove(&idr, 0);\n\tassert(idr_is_empty(&idr));\n\n\tassert(idr_alloc(&idr, NULL, 0, 0, GFP_KERNEL) == 0);\n\tassert(!idr_is_empty(&idr));\n\tidr_destroy(&idr);\n\tassert(idr_is_empty(&idr));\n\n\tfor (i = 0; i < 10; i++) {\n\t\tassert(idr_alloc(&idr, NULL, 0, 0, GFP_KERNEL) == i);\n\t}\n\n\tassert(idr_replace(&idr, DUMMY_PTR, 3) == NULL);\n\tassert(idr_replace(&idr, DUMMY_PTR, 4) == NULL);\n\tassert(idr_replace(&idr, NULL, 4) == DUMMY_PTR);\n\tassert(idr_replace(&idr, DUMMY_PTR, 11) == ERR_PTR(-ENOENT));\n\tidr_remove(&idr, 5);\n\tassert(idr_alloc(&idr, NULL, 0, 0, GFP_KERNEL) == 5);\n\tidr_remove(&idr, 5);\n\n\tfor (i = 0; i < 9; i++) {\n\t\tidr_remove(&idr, i);\n\t\tassert(!idr_is_empty(&idr));\n\t}\n\tidr_remove(&idr, 8);\n\tassert(!idr_is_empty(&idr));\n\tidr_remove(&idr, 9);\n\tassert(idr_is_empty(&idr));\n\n\tassert(idr_alloc(&idr, NULL, 0, 0, GFP_KERNEL) == 0);\n\tassert(idr_replace(&idr, DUMMY_PTR, 3) == ERR_PTR(-ENOENT));\n\tassert(idr_replace(&idr, DUMMY_PTR, 0) == NULL);\n\tassert(idr_replace(&idr, NULL, 0) == DUMMY_PTR);\n\n\tidr_destroy(&idr);\n\tassert(idr_is_empty(&idr));\n\n\tfor (i = 1; i < 10; i++) {\n\t\tassert(idr_alloc(&idr, NULL, 1, 0, GFP_KERNEL) == i);\n\t}\n\n\tidr_destroy(&idr);\n\tassert(idr_is_empty(&idr));\n}\n\nvoid idr_nowait_test(void)\n{\n\tunsigned int i;\n\tDEFINE_IDR(idr);\n\n\tidr_preload(GFP_KERNEL);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct item *item = item_create(i, 0);\n\t\tassert(idr_alloc(&idr, item, i, i + 1, GFP_NOWAIT) == i);\n\t}\n\n\tidr_preload_end();\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n}\n\nvoid idr_get_next_test(int base)\n{\n\tunsigned long i;\n\tint nextid;\n\tDEFINE_IDR(idr);\n\tidr_init_base(&idr, base);\n\n\tint indices[] = {4, 7, 9, 15, 65, 128, 1000, 99999, 0};\n\n\tfor(i = 0; indices[i]; i++) {\n\t\tstruct item *item = item_create(indices[i], 0);\n\t\tassert(idr_alloc(&idr, item, indices[i], indices[i+1],\n\t\t\t\t GFP_KERNEL) == indices[i]);\n\t}\n\n\tfor(i = 0, nextid = 0; indices[i]; i++) {\n\t\tidr_get_next(&idr, &nextid);\n\t\tassert(nextid == indices[i]);\n\t\tnextid++;\n\t}\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n}\n\nint idr_u32_cb(int id, void *ptr, void *data)\n{\n\tBUG_ON(id < 0);\n\tBUG_ON(ptr != DUMMY_PTR);\n\treturn 0;\n}\n\nvoid idr_u32_test1(struct idr *idr, u32 handle)\n{\n\tstatic bool warned = false;\n\tu32 id = handle;\n\tint sid = 0;\n\tvoid *ptr;\n\n\tBUG_ON(idr_alloc_u32(idr, DUMMY_PTR, &id, id, GFP_KERNEL));\n\tBUG_ON(id != handle);\n\tBUG_ON(idr_alloc_u32(idr, DUMMY_PTR, &id, id, GFP_KERNEL) != -ENOSPC);\n\tBUG_ON(id != handle);\n\tif (!warned && id > INT_MAX)\n\t\tprintk(\"vvv Ignore these warnings\\n\");\n\tptr = idr_get_next(idr, &sid);\n\tif (id > INT_MAX) {\n\t\tBUG_ON(ptr != NULL);\n\t\tBUG_ON(sid != 0);\n\t} else {\n\t\tBUG_ON(ptr != DUMMY_PTR);\n\t\tBUG_ON(sid != id);\n\t}\n\tidr_for_each(idr, idr_u32_cb, NULL);\n\tif (!warned && id > INT_MAX) {\n\t\tprintk(\"^^^ Warnings over\\n\");\n\t\twarned = true;\n\t}\n\tBUG_ON(idr_remove(idr, id) != DUMMY_PTR);\n\tBUG_ON(!idr_is_empty(idr));\n}\n\nvoid idr_u32_test(int base)\n{\n\tDEFINE_IDR(idr);\n\tidr_init_base(&idr, base);\n\tidr_u32_test1(&idr, 10);\n\tidr_u32_test1(&idr, 0x7fffffff);\n\tidr_u32_test1(&idr, 0x80000000);\n\tidr_u32_test1(&idr, 0x80000001);\n\tidr_u32_test1(&idr, 0xffe00000);\n\tidr_u32_test1(&idr, 0xffffffff);\n}\n\nstatic void idr_align_test(struct idr *idr)\n{\n\tchar name[] = \"Motorola 68000\";\n\tint i, id;\n\tvoid *entry;\n\n\tfor (i = 0; i < 9; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != i);\n\t\tidr_for_each_entry(idr, entry, id);\n\t}\n\tidr_destroy(idr);\n\n\tfor (i = 1; i < 10; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != i - 1);\n\t\tidr_for_each_entry(idr, entry, id);\n\t}\n\tidr_destroy(idr);\n\n\tfor (i = 2; i < 11; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != i - 2);\n\t\tidr_for_each_entry(idr, entry, id);\n\t}\n\tidr_destroy(idr);\n\n\tfor (i = 3; i < 12; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != i - 3);\n\t\tidr_for_each_entry(idr, entry, id);\n\t}\n\tidr_destroy(idr);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != 0);\n\t\tBUG_ON(idr_alloc(idr, &name[i + 1], 0, 0, GFP_KERNEL) != 1);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tidr_remove(idr, 1);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tidr_remove(idr, 0);\n\t\tBUG_ON(!idr_is_empty(idr));\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tBUG_ON(idr_alloc(idr, NULL, 0, 0, GFP_KERNEL) != 0);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tidr_replace(idr, &name[i], 0);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tBUG_ON(idr_find(idr, 0) != &name[i]);\n\t\tidr_remove(idr, 0);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tBUG_ON(idr_alloc(idr, &name[i], 0, 0, GFP_KERNEL) != 0);\n\t\tBUG_ON(idr_alloc(idr, NULL, 0, 0, GFP_KERNEL) != 1);\n\t\tidr_remove(idr, 1);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tidr_replace(idr, &name[i + 1], 0);\n\t\tidr_for_each_entry(idr, entry, id);\n\t\tidr_remove(idr, 0);\n\t}\n}\n\nDEFINE_IDR(find_idr);\n\nstatic void *idr_throbber(void *arg)\n{\n\ttime_t start = time(NULL);\n\tint id = *(int *)arg;\n\n\trcu_register_thread();\n\tdo {\n\t\tidr_alloc(&find_idr, xa_mk_value(id), id, id + 1, GFP_KERNEL);\n\t\tidr_remove(&find_idr, id);\n\t} while (time(NULL) < start + 10);\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\n \nvoid idr_find_test_1(int anchor_id, int throbber_id)\n{\n\tpthread_t throbber;\n\ttime_t start = time(NULL);\n\n\tBUG_ON(idr_alloc(&find_idr, xa_mk_value(anchor_id), anchor_id,\n\t\t\t\tanchor_id + 1, GFP_KERNEL) != anchor_id);\n\n\tpthread_create(&throbber, NULL, idr_throbber, &throbber_id);\n\n\trcu_read_lock();\n\tdo {\n\t\tint id = 0;\n\t\tvoid *entry = idr_get_next(&find_idr, &id);\n\t\trcu_read_unlock();\n\t\tif ((id != anchor_id && id != throbber_id) ||\n\t\t    entry != xa_mk_value(id)) {\n\t\t\tprintf(\"%s(%d, %d): %p at %d\\n\", __func__, anchor_id,\n\t\t\t\tthrobber_id, entry, id);\n\t\t\tabort();\n\t\t}\n\t\trcu_read_lock();\n\t} while (time(NULL) < start + 11);\n\trcu_read_unlock();\n\n\tpthread_join(throbber, NULL);\n\n\tidr_remove(&find_idr, anchor_id);\n\tBUG_ON(!idr_is_empty(&find_idr));\n}\n\nvoid idr_find_test(void)\n{\n\tidr_find_test_1(100000, 0);\n\tidr_find_test_1(0, 100000);\n}\n\nvoid idr_checks(void)\n{\n\tunsigned long i;\n\tDEFINE_IDR(idr);\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tstruct item *item = item_create(i, 0);\n\t\tassert(idr_alloc(&idr, item, 0, 20000, GFP_KERNEL) == i);\n\t}\n\n\tassert(idr_alloc(&idr, DUMMY_PTR, 5, 30, GFP_KERNEL) < 0);\n\n\tfor (i = 0; i < 5000; i++)\n\t\titem_idr_remove(&idr, i);\n\n\tidr_remove(&idr, 3);\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n\n\tassert(idr_is_empty(&idr));\n\n\tidr_remove(&idr, 3);\n\tidr_remove(&idr, 0);\n\n\tassert(idr_alloc(&idr, DUMMY_PTR, 0, 0, GFP_KERNEL) == 0);\n\tidr_remove(&idr, 1);\n\tfor (i = 1; i < RADIX_TREE_MAP_SIZE; i++)\n\t\tassert(idr_alloc(&idr, DUMMY_PTR, 0, 0, GFP_KERNEL) == i);\n\tidr_remove(&idr, 1 << 30);\n\tidr_destroy(&idr);\n\n\tfor (i = INT_MAX - 3UL; i < INT_MAX + 1UL; i++) {\n\t\tstruct item *item = item_create(i, 0);\n\t\tassert(idr_alloc(&idr, item, i, i + 10, GFP_KERNEL) == i);\n\t}\n\tassert(idr_alloc(&idr, DUMMY_PTR, i - 2, i, GFP_KERNEL) == -ENOSPC);\n\tassert(idr_alloc(&idr, DUMMY_PTR, i - 2, i + 10, GFP_KERNEL) == -ENOSPC);\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n\tidr_destroy(&idr);\n\n\tassert(idr_is_empty(&idr));\n\n\tidr_set_cursor(&idr, INT_MAX - 3UL);\n\tfor (i = INT_MAX - 3UL; i < INT_MAX + 3UL; i++) {\n\t\tstruct item *item;\n\t\tunsigned int id;\n\t\tif (i <= INT_MAX)\n\t\t\titem = item_create(i, 0);\n\t\telse\n\t\t\titem = item_create(i - INT_MAX - 1, 0);\n\n\t\tid = idr_alloc_cyclic(&idr, item, 0, 0, GFP_KERNEL);\n\t\tassert(id == item->index);\n\t}\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n\tassert(idr_is_empty(&idr));\n\n\tfor (i = 1; i < 10000; i++) {\n\t\tstruct item *item = item_create(i, 0);\n\t\tassert(idr_alloc(&idr, item, 1, 20000, GFP_KERNEL) == i);\n\t}\n\n\tidr_for_each(&idr, item_idr_free, &idr);\n\tidr_destroy(&idr);\n\n\tidr_replace_test();\n\tidr_alloc_test();\n\tidr_null_test();\n\tidr_nowait_test();\n\tidr_get_next_test(0);\n\tidr_get_next_test(1);\n\tidr_get_next_test(4);\n\tidr_u32_test(4);\n\tidr_u32_test(1);\n\tidr_u32_test(0);\n\tidr_align_test(&idr);\n\tidr_find_test();\n}\n\n#define module_init(x)\n#define module_exit(x)\n#define MODULE_AUTHOR(x)\n#define MODULE_LICENSE(x)\n#define dump_stack()    assert(0)\nvoid ida_dump(struct ida *);\n\n#include \"../../../lib/test_ida.c\"\n\n \nvoid ida_check_nomem(void)\n{\n\tDEFINE_IDA(ida);\n\tint id;\n\n\tid = ida_alloc_min(&ida, 256, GFP_NOWAIT);\n\tIDA_BUG_ON(&ida, id != -ENOMEM);\n\tid = ida_alloc_min(&ida, 1UL << 30, GFP_NOWAIT);\n\tIDA_BUG_ON(&ida, id != -ENOMEM);\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n}\n\n \nvoid ida_check_conv_user(void)\n{\n\tDEFINE_IDA(ida);\n\tunsigned long i;\n\n\tfor (i = 0; i < 1000000; i++) {\n\t\tint id = ida_alloc(&ida, GFP_NOWAIT);\n\t\tif (id == -ENOMEM) {\n\t\t\tIDA_BUG_ON(&ida, ((i % IDA_BITMAP_BITS) !=\n\t\t\t\t\t  BITS_PER_XA_VALUE) &&\n\t\t\t\t\t ((i % IDA_BITMAP_BITS) != 0));\n\t\t\tid = ida_alloc(&ida, GFP_KERNEL);\n\t\t} else {\n\t\t\tIDA_BUG_ON(&ida, (i % IDA_BITMAP_BITS) ==\n\t\t\t\t\tBITS_PER_XA_VALUE);\n\t\t}\n\t\tIDA_BUG_ON(&ida, id != i);\n\t}\n\tida_destroy(&ida);\n}\n\nvoid ida_check_random(void)\n{\n\tDEFINE_IDA(ida);\n\tDECLARE_BITMAP(bitmap, 2048);\n\tunsigned int i;\n\ttime_t s = time(NULL);\n\n repeat:\n\tmemset(bitmap, 0, sizeof(bitmap));\n\tfor (i = 0; i < 100000; i++) {\n\t\tint i = rand();\n\t\tint bit = i & 2047;\n\t\tif (test_bit(bit, bitmap)) {\n\t\t\t__clear_bit(bit, bitmap);\n\t\t\tida_free(&ida, bit);\n\t\t} else {\n\t\t\t__set_bit(bit, bitmap);\n\t\t\tIDA_BUG_ON(&ida, ida_alloc_min(&ida, bit, GFP_KERNEL)\n\t\t\t\t\t!= bit);\n\t\t}\n\t}\n\tida_destroy(&ida);\n\tif (time(NULL) < s + 10)\n\t\tgoto repeat;\n}\n\nvoid ida_simple_get_remove_test(void)\n{\n\tDEFINE_IDA(ida);\n\tunsigned long i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tassert(ida_simple_get(&ida, 0, 20000, GFP_KERNEL) == i);\n\t}\n\tassert(ida_simple_get(&ida, 5, 30, GFP_KERNEL) < 0);\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tida_simple_remove(&ida, i);\n\t}\n\tassert(ida_is_empty(&ida));\n\n\tida_destroy(&ida);\n}\n\nvoid user_ida_checks(void)\n{\n\tradix_tree_cpu_dead(1);\n\n\tida_check_nomem();\n\tida_check_conv_user();\n\tida_check_random();\n\tida_simple_get_remove_test();\n\n\tradix_tree_cpu_dead(1);\n}\n\nstatic void *ida_random_fn(void *arg)\n{\n\trcu_register_thread();\n\tida_check_random();\n\trcu_unregister_thread();\n\treturn NULL;\n}\n\nstatic void *ida_leak_fn(void *arg)\n{\n\tstruct ida *ida = arg;\n\ttime_t s = time(NULL);\n\tint i, ret;\n\n\trcu_register_thread();\n\n\tdo for (i = 0; i < 1000; i++) {\n\t\tret = ida_alloc_range(ida, 128, 128, GFP_KERNEL);\n\t\tif (ret >= 0)\n\t\t\tida_free(ida, 128);\n\t} while (time(NULL) < s + 2);\n\n\trcu_unregister_thread();\n\treturn NULL;\n}\n\nvoid ida_thread_tests(void)\n{\n\tDEFINE_IDA(ida);\n\tpthread_t threads[20];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++)\n\t\tif (pthread_create(&threads[i], NULL, ida_random_fn, NULL)) {\n\t\t\tperror(\"creating ida thread\");\n\t\t\texit(1);\n\t\t}\n\n\twhile (i--)\n\t\tpthread_join(threads[i], NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++)\n\t\tif (pthread_create(&threads[i], NULL, ida_leak_fn, &ida)) {\n\t\t\tperror(\"creating ida thread\");\n\t\t\texit(1);\n\t\t}\n\n\twhile (i--)\n\t\tpthread_join(threads[i], NULL);\n\tassert(ida_is_empty(&ida));\n}\n\nvoid ida_tests(void)\n{\n\tuser_ida_checks();\n\tida_checks();\n\tida_exit();\n\tida_thread_tests();\n}\n\nint __weak main(void)\n{\n\trcu_register_thread();\n\tradix_tree_init();\n\tidr_checks();\n\tida_tests();\n\tradix_tree_cpu_dead(1);\n\trcu_barrier();\n\tif (nr_allocated)\n\t\tprintf(\"nr_allocated = %d\\n\", nr_allocated);\n\trcu_unregister_thread();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}