{
  "module_name": "multiorder.c",
  "hash_id": "b45ba0de1ccf3d6f0b6e3b31adc8bf01cae5a82edcacacfab12c61f55ae0c79b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/multiorder.c",
  "human_readable_source": "\n \n#include <linux/radix-tree.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <pthread.h>\n\n#include \"test.h\"\n\nstatic int item_insert_order(struct xarray *xa, unsigned long index,\n\t\t\tunsigned order)\n{\n\tXA_STATE_ORDER(xas, xa, index, order);\n\tstruct item *item = item_create(index, order);\n\n\tdo {\n\t\txas_lock(&xas);\n\t\txas_store(&xas, item);\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tfree(item);\n\treturn xas_error(&xas);\n}\n\nvoid multiorder_iteration(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tstruct item *item;\n\tint i, j, err;\n\n#define NUM_ENTRIES 11\n\tint index[NUM_ENTRIES] = {0, 2, 4, 8, 16, 32, 34, 36, 64, 72, 128};\n\tint order[NUM_ENTRIES] = {1, 1, 2, 3,  4,  1,  0,  1,  3,  0, 7};\n\n\tprintv(1, \"Multiorder iteration test\\n\");\n\n\tfor (i = 0; i < NUM_ENTRIES; i++) {\n\t\terr = item_insert_order(xa, index[i], order[i]);\n\t\tassert(!err);\n\t}\n\n\tfor (j = 0; j < 256; j++) {\n\t\tfor (i = 0; i < NUM_ENTRIES; i++)\n\t\t\tif (j <= (index[i] | ((1 << order[i]) - 1)))\n\t\t\t\tbreak;\n\n\t\txas_set(&xas, j);\n\t\txas_for_each(&xas, item, ULONG_MAX) {\n\t\t\tint height = order[i] / XA_CHUNK_SHIFT;\n\t\t\tint shift = height * XA_CHUNK_SHIFT;\n\t\t\tunsigned long mask = (1UL << order[i]) - 1;\n\n\t\t\tassert((xas.xa_index | mask) == (index[i] | mask));\n\t\t\tassert(xas.xa_node->shift == shift);\n\t\t\tassert(!radix_tree_is_internal_node(item));\n\t\t\tassert((item->index | mask) == (index[i] | mask));\n\t\t\tassert(item->order == order[i]);\n\t\t\ti++;\n\t\t}\n\t}\n\n\titem_kill_tree(xa);\n}\n\nvoid multiorder_tagged_iteration(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tstruct item *item;\n\tint i, j;\n\n#define MT_NUM_ENTRIES 9\n\tint index[MT_NUM_ENTRIES] = {0, 2, 4, 16, 32, 40, 64, 72, 128};\n\tint order[MT_NUM_ENTRIES] = {1, 0, 2, 4,  3,  1,  3,  0,   7};\n\n#define TAG_ENTRIES 7\n\tint tag_index[TAG_ENTRIES] = {0, 4, 16, 40, 64, 72, 128};\n\n\tprintv(1, \"Multiorder tagged iteration test\\n\");\n\n\tfor (i = 0; i < MT_NUM_ENTRIES; i++)\n\t\tassert(!item_insert_order(xa, index[i], order[i]));\n\n\tassert(!xa_marked(xa, XA_MARK_1));\n\n\tfor (i = 0; i < TAG_ENTRIES; i++)\n\t\txa_set_mark(xa, tag_index[i], XA_MARK_1);\n\n\tfor (j = 0; j < 256; j++) {\n\t\tint k;\n\n\t\tfor (i = 0; i < TAG_ENTRIES; i++) {\n\t\t\tfor (k = i; index[k] < tag_index[i]; k++)\n\t\t\t\t;\n\t\t\tif (j <= (index[k] | ((1 << order[k]) - 1)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\txas_set(&xas, j);\n\t\txas_for_each_marked(&xas, item, ULONG_MAX, XA_MARK_1) {\n\t\t\tunsigned long mask;\n\t\t\tfor (k = i; index[k] < tag_index[i]; k++)\n\t\t\t\t;\n\t\t\tmask = (1UL << order[k]) - 1;\n\n\t\t\tassert((xas.xa_index | mask) == (tag_index[i] | mask));\n\t\t\tassert(!xa_is_internal(item));\n\t\t\tassert((item->index | mask) == (tag_index[i] | mask));\n\t\t\tassert(item->order == order[k]);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tassert(tag_tagged_items(xa, 0, ULONG_MAX, TAG_ENTRIES, XA_MARK_1,\n\t\t\t\tXA_MARK_2) == TAG_ENTRIES);\n\n\tfor (j = 0; j < 256; j++) {\n\t\tint mask, k;\n\n\t\tfor (i = 0; i < TAG_ENTRIES; i++) {\n\t\t\tfor (k = i; index[k] < tag_index[i]; k++)\n\t\t\t\t;\n\t\t\tif (j <= (index[k] | ((1 << order[k]) - 1)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\txas_set(&xas, j);\n\t\txas_for_each_marked(&xas, item, ULONG_MAX, XA_MARK_2) {\n\t\t\tfor (k = i; index[k] < tag_index[i]; k++)\n\t\t\t\t;\n\t\t\tmask = (1 << order[k]) - 1;\n\n\t\t\tassert((xas.xa_index | mask) == (tag_index[i] | mask));\n\t\t\tassert(!xa_is_internal(item));\n\t\t\tassert((item->index | mask) == (tag_index[i] | mask));\n\t\t\tassert(item->order == order[k]);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tassert(tag_tagged_items(xa, 1, ULONG_MAX, MT_NUM_ENTRIES * 2, XA_MARK_1,\n\t\t\t\tXA_MARK_0) == TAG_ENTRIES);\n\ti = 0;\n\txas_set(&xas, 0);\n\txas_for_each_marked(&xas, item, ULONG_MAX, XA_MARK_0) {\n\t\tassert(xas.xa_index == tag_index[i]);\n\t\ti++;\n\t}\n\tassert(i == TAG_ENTRIES);\n\n\titem_kill_tree(xa);\n}\n\nbool stop_iteration;\n\nstatic void *creator_func(void *ptr)\n{\n\t \n\tunsigned int order = RADIX_TREE_MAP_SHIFT - 1;\n\tstruct radix_tree_root *tree = ptr;\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\titem_insert_order(tree, 0, order);\n\t\titem_delete_rcu(tree, 0);\n\t}\n\n\tstop_iteration = true;\n\treturn NULL;\n}\n\nstatic void *iterator_func(void *ptr)\n{\n\tXA_STATE(xas, ptr, 0);\n\tstruct item *item;\n\n\twhile (!stop_iteration) {\n\t\trcu_read_lock();\n\t\txas_for_each(&xas, item, ULONG_MAX) {\n\t\t\tif (xas_retry(&xas, item))\n\t\t\t\tcontinue;\n\n\t\t\titem_sanity(item, xas.xa_index);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\treturn NULL;\n}\n\nstatic void multiorder_iteration_race(struct xarray *xa)\n{\n\tconst int num_threads = sysconf(_SC_NPROCESSORS_ONLN);\n\tpthread_t worker_thread[num_threads];\n\tint i;\n\n\tstop_iteration = false;\n\tpthread_create(&worker_thread[0], NULL, &creator_func, xa);\n\tfor (i = 1; i < num_threads; i++)\n\t\tpthread_create(&worker_thread[i], NULL, &iterator_func, xa);\n\n\tfor (i = 0; i < num_threads; i++)\n\t\tpthread_join(worker_thread[i], NULL);\n\n\titem_kill_tree(xa);\n}\n\nstatic void *load_creator(void *ptr)\n{\n\t \n\tunsigned int order;\n\tstruct radix_tree_root *tree = ptr;\n\tint i;\n\n\trcu_register_thread();\n\titem_insert_order(tree, 3 << RADIX_TREE_MAP_SHIFT, 0);\n\titem_insert_order(tree, 2 << RADIX_TREE_MAP_SHIFT, 0);\n\tfor (i = 0; i < 10000; i++) {\n\t\tfor (order = 1; order < RADIX_TREE_MAP_SHIFT; order++) {\n\t\t\tunsigned long index = (3 << RADIX_TREE_MAP_SHIFT) -\n\t\t\t\t\t\t(1 << order);\n\t\t\titem_insert_order(tree, index, order);\n\t\t\titem_delete_rcu(tree, index);\n\t\t}\n\t}\n\trcu_unregister_thread();\n\n\tstop_iteration = true;\n\treturn NULL;\n}\n\nstatic void *load_worker(void *ptr)\n{\n\tunsigned long index = (3 << RADIX_TREE_MAP_SHIFT) - 1;\n\n\trcu_register_thread();\n\twhile (!stop_iteration) {\n\t\tstruct item *item = xa_load(ptr, index);\n\t\tassert(!xa_is_internal(item));\n\t}\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\nstatic void load_race(struct xarray *xa)\n{\n\tconst int num_threads = sysconf(_SC_NPROCESSORS_ONLN) * 4;\n\tpthread_t worker_thread[num_threads];\n\tint i;\n\n\tstop_iteration = false;\n\tpthread_create(&worker_thread[0], NULL, &load_creator, xa);\n\tfor (i = 1; i < num_threads; i++)\n\t\tpthread_create(&worker_thread[i], NULL, &load_worker, xa);\n\n\tfor (i = 0; i < num_threads; i++)\n\t\tpthread_join(worker_thread[i], NULL);\n\n\titem_kill_tree(xa);\n}\n\nstatic DEFINE_XARRAY(array);\n\nvoid multiorder_checks(void)\n{\n\tmultiorder_iteration(&array);\n\tmultiorder_tagged_iteration(&array);\n\tmultiorder_iteration_race(&array);\n\tload_race(&array);\n\n\tradix_tree_cpu_dead(0);\n}\n\nint __weak main(int argc, char **argv)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"ls:v\")) != -1) {\n\t\tif (opt == 'v')\n\t\t\ttest_verbose++;\n\t}\n\n\trcu_register_thread();\n\tradix_tree_init();\n\tmultiorder_checks();\n\trcu_unregister_thread();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}