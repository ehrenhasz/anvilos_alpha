{
  "module_name": "tag_check.c",
  "hash_id": "387ed9367d1228f0b47eb4bfd95b631dbf81994202cef2c55f3c9244be3035dd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/tag_check.c",
  "human_readable_source": "\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <linux/slab.h>\n#include <linux/radix-tree.h>\n\n#include \"test.h\"\n\n\nstatic void\n__simple_checks(struct radix_tree_root *tree, unsigned long index, int tag)\n{\n\tunsigned long first = 0;\n\tint ret;\n\n\titem_check_absent(tree, index);\n\tassert(item_tag_get(tree, index, tag) == 0);\n\n\titem_insert(tree, index);\n\tassert(item_tag_get(tree, index, tag) == 0);\n\titem_tag_set(tree, index, tag);\n\tret = item_tag_get(tree, index, tag);\n\tassert(ret != 0);\n\tret = tag_tagged_items(tree, first, ~0UL, 10, tag, !tag);\n\tassert(ret == 1);\n\tret = item_tag_get(tree, index, !tag);\n\tassert(ret != 0);\n\tret = item_delete(tree, index);\n\tassert(ret != 0);\n\titem_insert(tree, index);\n\tret = item_tag_get(tree, index, tag);\n\tassert(ret == 0);\n\tret = item_delete(tree, index);\n\tassert(ret != 0);\n\tret = item_delete(tree, index);\n\tassert(ret == 0);\n}\n\nvoid simple_checks(void)\n{\n\tunsigned long index;\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\tfor (index = 0; index < 10000; index++) {\n\t\t__simple_checks(&tree, index, 0);\n\t\t__simple_checks(&tree, index, 1);\n\t}\n\tverify_tag_consistency(&tree, 0);\n\tverify_tag_consistency(&tree, 1);\n\tprintv(2, \"before item_kill_tree: %d allocated\\n\", nr_allocated);\n\titem_kill_tree(&tree);\n\trcu_barrier();\n\tprintv(2, \"after item_kill_tree: %d allocated\\n\", nr_allocated);\n}\n\n \nstatic void extend_checks(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\titem_insert(&tree, 43);\n\tassert(item_tag_get(&tree, 43, 0) == 0);\n\titem_tag_set(&tree, 43, 0);\n\tassert(item_tag_get(&tree, 43, 0) == 1);\n\titem_insert(&tree, 1000000);\n\tassert(item_tag_get(&tree, 43, 0) == 1);\n\n\titem_insert(&tree, 0);\n\titem_tag_set(&tree, 0, 0);\n\titem_delete(&tree, 1000000);\n\tassert(item_tag_get(&tree, 43, 0) != 0);\n\titem_delete(&tree, 43);\n\tassert(item_tag_get(&tree, 43, 0) == 0);\t \n\tassert(item_tag_get(&tree, 0, 0) == 1);\n\n\tverify_tag_consistency(&tree, 0);\n\n\titem_kill_tree(&tree);\n}\n\n \nstatic void contract_checks(void)\n{\n\tstruct item *item;\n\tint tmp;\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\ttmp = 1<<RADIX_TREE_MAP_SHIFT;\n\titem_insert(&tree, tmp);\n\titem_insert(&tree, tmp+1);\n\titem_tag_set(&tree, tmp, 0);\n\titem_tag_set(&tree, tmp, 1);\n\titem_tag_set(&tree, tmp+1, 0);\n\titem_delete(&tree, tmp+1);\n\titem_tag_clear(&tree, tmp, 1);\n\n\tassert(radix_tree_gang_lookup_tag(&tree, (void **)&item, 0, 1, 0) == 1);\n\tassert(radix_tree_gang_lookup_tag(&tree, (void **)&item, 0, 1, 1) == 0);\n\n\tassert(item_tag_get(&tree, tmp, 0) == 1);\n\tassert(item_tag_get(&tree, tmp, 1) == 0);\n\n\tverify_tag_consistency(&tree, 0);\n\titem_kill_tree(&tree);\n}\n\n \n\nenum {\n\tNODE_ABSENT = 0,\n\tNODE_PRESENT = 1,\n\tNODE_TAGGED = 2,\n};\n\n#define THRASH_SIZE\t\t(1000 * 1000)\n#define N 127\n#define BATCH\t33\n\nstatic void gang_check(struct radix_tree_root *tree,\n\t\t\tchar *thrash_state, int tag)\n{\n\tstruct item *items[BATCH];\n\tint nr_found;\n\tunsigned long index = 0;\n\tunsigned long last_index = 0;\n\n\twhile ((nr_found = radix_tree_gang_lookup_tag(tree, (void **)items,\n\t\t\t\t\tindex, BATCH, tag))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct item *item = items[i];\n\n\t\t\twhile (last_index < item->index) {\n\t\t\t\tassert(thrash_state[last_index] != NODE_TAGGED);\n\t\t\t\tlast_index++;\n\t\t\t}\n\t\t\tassert(thrash_state[last_index] == NODE_TAGGED);\n\t\t\tlast_index++;\n\t\t}\n\t\tindex = items[nr_found - 1]->index + 1;\n\t}\n}\n\nstatic void do_thrash(struct radix_tree_root *tree, char *thrash_state, int tag)\n{\n\tint insert_chunk;\n\tint delete_chunk;\n\tint tag_chunk;\n\tint untag_chunk;\n\tint total_tagged = 0;\n\tint total_present = 0;\n\n\tfor (insert_chunk = 1; insert_chunk < THRASH_SIZE; insert_chunk *= N)\n\tfor (delete_chunk = 1; delete_chunk < THRASH_SIZE; delete_chunk *= N)\n\tfor (tag_chunk = 1; tag_chunk < THRASH_SIZE; tag_chunk *= N)\n\tfor (untag_chunk = 1; untag_chunk < THRASH_SIZE; untag_chunk *= N) {\n\t\tint i;\n\t\tunsigned long index;\n\t\tint nr_inserted = 0;\n\t\tint nr_deleted = 0;\n\t\tint nr_tagged = 0;\n\t\tint nr_untagged = 0;\n\t\tint actual_total_tagged;\n\t\tint actual_total_present;\n\n\t\tfor (i = 0; i < insert_chunk; i++) {\n\t\t\tindex = rand() % THRASH_SIZE;\n\t\t\tif (thrash_state[index] != NODE_ABSENT)\n\t\t\t\tcontinue;\n\t\t\titem_check_absent(tree, index);\n\t\t\titem_insert(tree, index);\n\t\t\tassert(thrash_state[index] != NODE_PRESENT);\n\t\t\tthrash_state[index] = NODE_PRESENT;\n\t\t\tnr_inserted++;\n\t\t\ttotal_present++;\n\t\t}\n\n\t\tfor (i = 0; i < delete_chunk; i++) {\n\t\t\tindex = rand() % THRASH_SIZE;\n\t\t\tif (thrash_state[index] == NODE_ABSENT)\n\t\t\t\tcontinue;\n\t\t\titem_check_present(tree, index);\n\t\t\tif (item_tag_get(tree, index, tag)) {\n\t\t\t\tassert(thrash_state[index] == NODE_TAGGED);\n\t\t\t\ttotal_tagged--;\n\t\t\t} else {\n\t\t\t\tassert(thrash_state[index] == NODE_PRESENT);\n\t\t\t}\n\t\t\titem_delete(tree, index);\n\t\t\tassert(thrash_state[index] != NODE_ABSENT);\n\t\t\tthrash_state[index] = NODE_ABSENT;\n\t\t\tnr_deleted++;\n\t\t\ttotal_present--;\n\t\t}\n\n\t\tfor (i = 0; i < tag_chunk; i++) {\n\t\t\tindex = rand() % THRASH_SIZE;\n\t\t\tif (thrash_state[index] != NODE_PRESENT) {\n\t\t\t\tif (item_lookup(tree, index))\n\t\t\t\t\tassert(item_tag_get(tree, index, tag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titem_tag_set(tree, index, tag);\n\t\t\titem_tag_set(tree, index, tag);\n\t\t\tassert(thrash_state[index] != NODE_TAGGED);\n\t\t\tthrash_state[index] = NODE_TAGGED;\n\t\t\tnr_tagged++;\n\t\t\ttotal_tagged++;\n\t\t}\n\n\t\tfor (i = 0; i < untag_chunk; i++) {\n\t\t\tindex = rand() % THRASH_SIZE;\n\t\t\tif (thrash_state[index] != NODE_TAGGED)\n\t\t\t\tcontinue;\n\t\t\titem_check_present(tree, index);\n\t\t\tassert(item_tag_get(tree, index, tag));\n\t\t\titem_tag_clear(tree, index, tag);\n\t\t\titem_tag_clear(tree, index, tag);\n\t\t\tassert(thrash_state[index] != NODE_PRESENT);\n\t\t\tthrash_state[index] = NODE_PRESENT;\n\t\t\tnr_untagged++;\n\t\t\ttotal_tagged--;\n\t\t}\n\n\t\tactual_total_tagged = 0;\n\t\tactual_total_present = 0;\n\t\tfor (index = 0; index < THRASH_SIZE; index++) {\n\t\t\tswitch (thrash_state[index]) {\n\t\t\tcase NODE_ABSENT:\n\t\t\t\titem_check_absent(tree, index);\n\t\t\t\tbreak;\n\t\t\tcase NODE_PRESENT:\n\t\t\t\titem_check_present(tree, index);\n\t\t\t\tassert(!item_tag_get(tree, index, tag));\n\t\t\t\tactual_total_present++;\n\t\t\t\tbreak;\n\t\t\tcase NODE_TAGGED:\n\t\t\t\titem_check_present(tree, index);\n\t\t\t\tassert(item_tag_get(tree, index, tag));\n\t\t\t\tactual_total_present++;\n\t\t\t\tactual_total_tagged++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgang_check(tree, thrash_state, tag);\n\n\t\tprintv(2, \"%d(%d) %d(%d) %d(%d) %d(%d) / \"\n\t\t\t\t\"%d(%d) present, %d(%d) tagged\\n\",\n\t\t\tinsert_chunk, nr_inserted,\n\t\t\tdelete_chunk, nr_deleted,\n\t\t\ttag_chunk, nr_tagged,\n\t\t\tuntag_chunk, nr_untagged,\n\t\t\ttotal_present, actual_total_present,\n\t\t\ttotal_tagged, actual_total_tagged);\n\t}\n}\n\nstatic void thrash_tags(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\tchar *thrash_state;\n\n\tthrash_state = malloc(THRASH_SIZE);\n\tmemset(thrash_state, 0, THRASH_SIZE);\n\n\tdo_thrash(&tree, thrash_state, 0);\n\n\tverify_tag_consistency(&tree, 0);\n\titem_kill_tree(&tree);\n\tfree(thrash_state);\n}\n\nstatic void leak_check(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\titem_insert(&tree, 1000000);\n\titem_delete(&tree, 1000000);\n\titem_kill_tree(&tree);\n}\n\nstatic void __leak_check(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\tprintv(2, \"%d: nr_allocated=%d\\n\", __LINE__, nr_allocated);\n\titem_insert(&tree, 1000000);\n\tprintv(2, \"%d: nr_allocated=%d\\n\", __LINE__, nr_allocated);\n\titem_delete(&tree, 1000000);\n\tprintv(2, \"%d: nr_allocated=%d\\n\", __LINE__, nr_allocated);\n\titem_kill_tree(&tree);\n\tprintv(2, \"%d: nr_allocated=%d\\n\", __LINE__, nr_allocated);\n}\n\nstatic void single_check(void)\n{\n\tstruct item *items[BATCH];\n\tRADIX_TREE(tree, GFP_KERNEL);\n\tint ret;\n\tunsigned long first = 0;\n\n\titem_insert(&tree, 0);\n\titem_tag_set(&tree, 0, 0);\n\tret = radix_tree_gang_lookup_tag(&tree, (void **)items, 0, BATCH, 0);\n\tassert(ret == 1);\n\tret = radix_tree_gang_lookup_tag(&tree, (void **)items, 1, BATCH, 0);\n\tassert(ret == 0);\n\tverify_tag_consistency(&tree, 0);\n\tverify_tag_consistency(&tree, 1);\n\tret = tag_tagged_items(&tree, first, 10, 10, XA_MARK_0, XA_MARK_1);\n\tassert(ret == 1);\n\tret = radix_tree_gang_lookup_tag(&tree, (void **)items, 0, BATCH, 1);\n\tassert(ret == 1);\n\titem_tag_clear(&tree, 0, 0);\n\tret = radix_tree_gang_lookup_tag(&tree, (void **)items, 0, BATCH, 0);\n\tassert(ret == 0);\n\titem_kill_tree(&tree);\n}\n\nvoid tag_check(void)\n{\n\tsingle_check();\n\textend_checks();\n\tcontract_checks();\n\trcu_barrier();\n\tprintv(2, \"after extend_checks: %d allocated\\n\", nr_allocated);\n\t__leak_check();\n\tleak_check();\n\trcu_barrier();\n\tprintv(2, \"after leak_check: %d allocated\\n\", nr_allocated);\n\tsimple_checks();\n\trcu_barrier();\n\tprintv(2, \"after simple_checks: %d allocated\\n\", nr_allocated);\n\tthrash_tags();\n\trcu_barrier();\n\tprintv(2, \"after thrash_tags: %d allocated\\n\", nr_allocated);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}