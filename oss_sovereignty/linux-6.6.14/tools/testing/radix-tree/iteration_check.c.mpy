{
  "module_name": "iteration_check.c",
  "hash_id": "29d35fe98b57c4ff4d27d8b9132dbdf5e9a31b37a7dce9755a38ee854a5e903a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/iteration_check.c",
  "human_readable_source": "\n \n#include <pthread.h>\n#include \"test.h\"\n\n#define NUM_THREADS\t5\n#define MAX_IDX\t\t100\n#define TAG\t\tXA_MARK_0\n#define NEW_TAG\t\tXA_MARK_1\n\nstatic pthread_t threads[NUM_THREADS];\nstatic unsigned int seeds[3];\nstatic DEFINE_XARRAY(array);\nstatic bool test_complete;\nstatic int max_order;\n\nvoid my_item_insert(struct xarray *xa, unsigned long index)\n{\n\tXA_STATE(xas, xa, index);\n\tstruct item *item = item_create(index, 0);\n\tint order;\n\nretry:\n\txas_lock(&xas);\n\tfor (order = max_order; order >= 0; order--) {\n\t\txas_set_order(&xas, index, order);\n\t\titem->order = order;\n\t\tif (xas_find_conflict(&xas))\n\t\t\tcontinue;\n\t\txas_store(&xas, item);\n\t\txas_set_mark(&xas, TAG);\n\t\tbreak;\n\t}\n\txas_unlock(&xas);\n\tif (xas_nomem(&xas, GFP_KERNEL))\n\t\tgoto retry;\n\tif (order < 0)\n\t\tfree(item);\n}\n\n \nstatic void *add_entries_fn(void *arg)\n{\n\trcu_register_thread();\n\n\twhile (!test_complete) {\n\t\tunsigned long pgoff;\n\n\t\tfor (pgoff = 0; pgoff < MAX_IDX; pgoff++) {\n\t\t\tmy_item_insert(&array, pgoff);\n\t\t}\n\t}\n\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\n \nstatic void *tagged_iteration_fn(void *arg)\n{\n\tXA_STATE(xas, &array, 0);\n\tvoid *entry;\n\n\trcu_register_thread();\n\n\twhile (!test_complete) {\n\t\txas_set(&xas, 0);\n\t\trcu_read_lock();\n\t\txas_for_each_marked(&xas, entry, ULONG_MAX, TAG) {\n\t\t\tif (xas_retry(&xas, entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (rand_r(&seeds[0]) % 50 == 0) {\n\t\t\t\txas_pause(&xas);\n\t\t\t\trcu_read_unlock();\n\t\t\t\trcu_barrier();\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\n \nstatic void *untagged_iteration_fn(void *arg)\n{\n\tXA_STATE(xas, &array, 0);\n\tvoid *entry;\n\n\trcu_register_thread();\n\n\twhile (!test_complete) {\n\t\txas_set(&xas, 0);\n\t\trcu_read_lock();\n\t\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\t\tif (xas_retry(&xas, entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (rand_r(&seeds[1]) % 50 == 0) {\n\t\t\t\txas_pause(&xas);\n\t\t\t\trcu_read_unlock();\n\t\t\t\trcu_barrier();\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\n \nstatic void *remove_entries_fn(void *arg)\n{\n\trcu_register_thread();\n\n\twhile (!test_complete) {\n\t\tint pgoff;\n\t\tstruct item *item;\n\n\t\tpgoff = rand_r(&seeds[2]) % MAX_IDX;\n\n\t\titem = xa_erase(&array, pgoff);\n\t\tif (item)\n\t\t\titem_free(item, pgoff);\n\t}\n\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\nstatic void *tag_entries_fn(void *arg)\n{\n\trcu_register_thread();\n\n\twhile (!test_complete) {\n\t\ttag_tagged_items(&array, 0, MAX_IDX, 10, TAG, NEW_TAG);\n\t}\n\trcu_unregister_thread();\n\treturn NULL;\n}\n\n \nvoid iteration_test(unsigned order, unsigned test_duration)\n{\n\tint i;\n\n\tprintv(1, \"Running %siteration tests for %d seconds\\n\",\n\t\t\torder > 0 ? \"multiorder \" : \"\", test_duration);\n\n\tmax_order = order;\n\ttest_complete = false;\n\n\tfor (i = 0; i < 3; i++)\n\t\tseeds[i] = rand();\n\n\tif (pthread_create(&threads[0], NULL, tagged_iteration_fn, NULL)) {\n\t\tperror(\"create tagged iteration thread\");\n\t\texit(1);\n\t}\n\tif (pthread_create(&threads[1], NULL, untagged_iteration_fn, NULL)) {\n\t\tperror(\"create untagged iteration thread\");\n\t\texit(1);\n\t}\n\tif (pthread_create(&threads[2], NULL, add_entries_fn, NULL)) {\n\t\tperror(\"create add entry thread\");\n\t\texit(1);\n\t}\n\tif (pthread_create(&threads[3], NULL, remove_entries_fn, NULL)) {\n\t\tperror(\"create remove entry thread\");\n\t\texit(1);\n\t}\n\tif (pthread_create(&threads[4], NULL, tag_entries_fn, NULL)) {\n\t\tperror(\"create tag entry thread\");\n\t\texit(1);\n\t}\n\n\tsleep(test_duration);\n\ttest_complete = true;\n\n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\tif (pthread_join(threads[i], NULL)) {\n\t\t\tperror(\"pthread_join\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\titem_kill_tree(&array);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}