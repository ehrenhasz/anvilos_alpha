{
  "module_name": "regression1.c",
  "hash_id": "5b8628780c85c517676568f9723945010336b4d79f50a61c5751ca37b3e85804",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/regression1.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/radix-tree.h>\n#include <linux/rcupdate.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <assert.h>\n\n#include \"regression.h\"\n\nstatic RADIX_TREE(mt_tree, GFP_KERNEL);\n\nstruct page {\n\tpthread_mutex_t lock;\n\tstruct rcu_head rcu;\n\tint count;\n\tunsigned long index;\n};\n\nstatic struct page *page_alloc(int index)\n{\n\tstruct page *p;\n\tp = malloc(sizeof(struct page));\n\tp->count = 1;\n\tp->index = index;\n\tpthread_mutex_init(&p->lock, NULL);\n\n\treturn p;\n}\n\nstatic void page_rcu_free(struct rcu_head *rcu)\n{\n\tstruct page *p = container_of(rcu, struct page, rcu);\n\tassert(!p->count);\n\tpthread_mutex_destroy(&p->lock);\n\tfree(p);\n}\n\nstatic void page_free(struct page *p)\n{\n\tcall_rcu(&p->rcu, page_rcu_free);\n}\n\nstatic unsigned find_get_pages(unsigned long start,\n\t\t\t    unsigned int nr_pages, struct page **pages)\n{\n\tXA_STATE(xas, &mt_tree, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\n\t\tpthread_mutex_lock(&page->lock);\n\t\tif (!page->count)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tpthread_mutex_unlock(&page->lock);\n\n\t\t \n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tret++;\n\t\tcontinue;\nunlock:\n\t\tpthread_mutex_unlock(&page->lock);\nput_page:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic pthread_barrier_t worker_barrier;\n\nstatic void *regression1_fn(void *arg)\n{\n\trcu_register_thread();\n\n\tif (pthread_barrier_wait(&worker_barrier) ==\n\t\t\tPTHREAD_BARRIER_SERIAL_THREAD) {\n\t\tint j;\n\n\t\tfor (j = 0; j < 1000000; j++) {\n\t\t\tstruct page *p;\n\n\t\t\tp = page_alloc(0);\n\t\t\txa_lock(&mt_tree);\n\t\t\tradix_tree_insert(&mt_tree, 0, p);\n\t\t\txa_unlock(&mt_tree);\n\n\t\t\tp = page_alloc(1);\n\t\t\txa_lock(&mt_tree);\n\t\t\tradix_tree_insert(&mt_tree, 1, p);\n\t\t\txa_unlock(&mt_tree);\n\n\t\t\txa_lock(&mt_tree);\n\t\t\tp = radix_tree_delete(&mt_tree, 1);\n\t\t\tpthread_mutex_lock(&p->lock);\n\t\t\tp->count--;\n\t\t\tpthread_mutex_unlock(&p->lock);\n\t\t\txa_unlock(&mt_tree);\n\t\t\tpage_free(p);\n\n\t\t\txa_lock(&mt_tree);\n\t\t\tp = radix_tree_delete(&mt_tree, 0);\n\t\t\tpthread_mutex_lock(&p->lock);\n\t\t\tp->count--;\n\t\t\tpthread_mutex_unlock(&p->lock);\n\t\t\txa_unlock(&mt_tree);\n\t\t\tpage_free(p);\n\t\t}\n\t} else {\n\t\tint j;\n\n\t\tfor (j = 0; j < 100000000; j++) {\n\t\t\tstruct page *pages[10];\n\n\t\t\tfind_get_pages(0, 10, pages);\n\t\t}\n\t}\n\n\trcu_unregister_thread();\n\n\treturn NULL;\n}\n\nstatic pthread_t *threads;\nvoid regression1_test(void)\n{\n\tint nr_threads;\n\tint i;\n\tlong arg;\n\n\t \n\tprintv(1, \"running regression test 1, should finish in under a minute\\n\");\n\tnr_threads = 2;\n\tpthread_barrier_init(&worker_barrier, NULL, nr_threads);\n\n\tthreads = malloc(nr_threads * sizeof(*threads));\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\targ = i;\n\t\tif (pthread_create(&threads[i], NULL, regression1_fn, (void *)arg)) {\n\t\t\tperror(\"pthread_create\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tif (pthread_join(threads[i], NULL)) {\n\t\t\tperror(\"pthread_join\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfree(threads);\n\n\tprintv(1, \"regression test 1, done\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}