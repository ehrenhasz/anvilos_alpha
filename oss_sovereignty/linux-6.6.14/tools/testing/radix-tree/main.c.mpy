{
  "module_name": "main.c",
  "hash_id": "23e784f0f747eb476ce8b287ebf1327e0c44491fb1843c6a6a60f74ab0c62a8c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/radix-tree/main.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n\n#include <linux/slab.h>\n#include <linux/radix-tree.h>\n\n#include \"test.h\"\n#include \"regression.h\"\n\nvoid __gang_check(unsigned long middle, long down, long up, int chunk, int hop)\n{\n\tlong idx;\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\tmiddle = 1 << 30;\n\n\tfor (idx = -down; idx < up; idx++)\n\t\titem_insert(&tree, middle + idx);\n\n\titem_check_absent(&tree, middle - down - 1);\n\tfor (idx = -down; idx < up; idx++)\n\t\titem_check_present(&tree, middle + idx);\n\titem_check_absent(&tree, middle + up);\n\n\tif (chunk > 0) {\n\t\titem_gang_check_present(&tree, middle - down, up + down,\n\t\t\t\tchunk, hop);\n\t\titem_full_scan(&tree, middle - down, down + up, chunk);\n\t}\n\titem_kill_tree(&tree);\n}\n\nvoid gang_check(void)\n{\n\t__gang_check(1UL << 30, 128, 128, 35, 2);\n\t__gang_check(1UL << 31, 128, 128, 32, 32);\n\t__gang_check(1UL << 31, 128, 128, 32, 100);\n\t__gang_check(1UL << 31, 128, 128, 17, 7);\n\t__gang_check(0xffff0000UL, 0, 65536, 17, 7);\n\t__gang_check(0xfffffffeUL, 1, 1, 17, 7);\n}\n\nvoid __big_gang_check(void)\n{\n\tunsigned long start;\n\tint wrapped = 0;\n\n\tstart = 0;\n\tdo {\n\t\tunsigned long old_start;\n\n\n\t\t__gang_check(start, rand() % 113 + 1, rand() % 71,\n\t\t\t\trand() % 157, rand() % 91 + 1);\n\t\told_start = start;\n\t\tstart += rand() % 1000000;\n\t\tstart %= 1ULL << 33;\n\t\tif (start < old_start)\n\t\t\twrapped = 1;\n\t} while (!wrapped);\n}\n\nvoid big_gang_check(bool long_run)\n{\n\tint i;\n\n\tfor (i = 0; i < (long_run ? 1000 : 3); i++) {\n\t\t__big_gang_check();\n\t\tprintv(2, \"%d \", i);\n\t\tfflush(stdout);\n\t}\n}\n\nvoid add_and_check(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\n\titem_insert(&tree, 44);\n\titem_check_present(&tree, 44);\n\titem_check_absent(&tree, 43);\n\titem_kill_tree(&tree);\n}\n\nvoid dynamic_height_check(void)\n{\n\tint i;\n\tRADIX_TREE(tree, GFP_KERNEL);\n\ttree_verify_min_height(&tree, 0);\n\n\titem_insert(&tree, 42);\n\ttree_verify_min_height(&tree, 42);\n\n\titem_insert(&tree, 1000000);\n\ttree_verify_min_height(&tree, 1000000);\n\n\tassert(item_delete(&tree, 1000000));\n\ttree_verify_min_height(&tree, 42);\n\n\tassert(item_delete(&tree, 42));\n\ttree_verify_min_height(&tree, 0);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\titem_insert(&tree, i);\n\t\ttree_verify_min_height(&tree, i);\n\t}\n\n\ti--;\n\tfor (;;) {\n\t\tassert(item_delete(&tree, i));\n\t\tif (i == 0) {\n\t\t\ttree_verify_min_height(&tree, 0);\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t\ttree_verify_min_height(&tree, i);\n\t}\n\n\titem_kill_tree(&tree);\n}\n\nvoid check_copied_tags(struct radix_tree_root *tree, unsigned long start, unsigned long end, unsigned long *idx, int count, int fromtag, int totag)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n \n\t\tif (idx[i] < start || idx[i] > end) {\n\t\t\tif (item_tag_get(tree, idx[i], totag)) {\n\t\t\t\tprintv(2, \"%lu-%lu: %lu, tags %d-%d\\n\", start,\n\t\t\t\t       end, idx[i], item_tag_get(tree, idx[i],\n\t\t\t\t\t\t\t\t fromtag),\n\t\t\t\t       item_tag_get(tree, idx[i], totag));\n\t\t\t}\n\t\t\tassert(!item_tag_get(tree, idx[i], totag));\n\t\t\tcontinue;\n\t\t}\n\t\tif (item_tag_get(tree, idx[i], fromtag) ^\n\t\t\titem_tag_get(tree, idx[i], totag)) {\n\t\t\tprintv(2, \"%lu-%lu: %lu, tags %d-%d\\n\", start, end,\n\t\t\t       idx[i], item_tag_get(tree, idx[i], fromtag),\n\t\t\t       item_tag_get(tree, idx[i], totag));\n\t\t}\n\t\tassert(!(item_tag_get(tree, idx[i], fromtag) ^\n\t\t\t item_tag_get(tree, idx[i], totag)));\n\t}\n}\n\n#define ITEMS 50000\n\nvoid copy_tag_check(void)\n{\n\tRADIX_TREE(tree, GFP_KERNEL);\n\tunsigned long idx[ITEMS];\n\tunsigned long start, end, count = 0, tagged, cur, tmp;\n\tint i;\n\n\n\tstart = rand();\n\tend = rand();\n\tif (start > end && (rand() % 10)) {\n\t\tcur = start;\n\t\tstart = end;\n\t\tend = cur;\n\t}\n\t \n\tcur = rand();\n\tif (cur & 1) {\n\t\titem_insert(&tree, start);\n\t\tif (cur & 2) {\n\t\t\tif (start <= end)\n\t\t\t\tcount++;\n\t\t\titem_tag_set(&tree, start, 0);\n\t\t}\n\t}\n\tif (cur & 4) {\n\t\titem_insert(&tree, start-1);\n\t\tif (cur & 8)\n\t\t\titem_tag_set(&tree, start-1, 0);\n\t}\n\tif (cur & 16) {\n\t\titem_insert(&tree, end);\n\t\tif (cur & 32) {\n\t\t\tif (start <= end)\n\t\t\t\tcount++;\n\t\t\titem_tag_set(&tree, end, 0);\n\t\t}\n\t}\n\tif (cur & 64) {\n\t\titem_insert(&tree, end+1);\n\t\tif (cur & 128)\n\t\t\titem_tag_set(&tree, end+1, 0);\n\t}\n\n\tfor (i = 0; i < ITEMS; i++) {\n\t\tdo {\n\t\t\tidx[i] = rand();\n\t\t} while (item_lookup(&tree, idx[i]));\n\n\t\titem_insert(&tree, idx[i]);\n\t\tif (rand() & 1) {\n\t\t\titem_tag_set(&tree, idx[i], 0);\n\t\t\tif (idx[i] >= start && idx[i] <= end)\n\t\t\t\tcount++;\n\t\t}\n \n\t}\n\n\n\ttagged = tag_tagged_items(&tree, start, end, ITEMS, XA_MARK_0, XA_MARK_1);\n\n\n\tassert(tagged == count);\n\tcheck_copied_tags(&tree, start, end, idx, ITEMS, 0, 1);\n\n\t \n\n\ttmp = rand() % (count / 10 + 2);\n\ttagged = tag_tagged_items(&tree, start, end, tmp, XA_MARK_0, XA_MARK_2);\n\tassert(tagged == count);\n\n\n\n\tcheck_copied_tags(&tree, start, end, idx, ITEMS, 0, 2);\n\tverify_tag_consistency(&tree, 0);\n\tverify_tag_consistency(&tree, 1);\n\tverify_tag_consistency(&tree, 2);\n\n\titem_kill_tree(&tree);\n}\n\nstatic void single_thread_tests(bool long_run)\n{\n\tint i;\n\n\tprintv(1, \"starting single_thread_tests: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tmultiorder_checks();\n\trcu_barrier();\n\tprintv(2, \"after multiorder_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\ttag_check();\n\trcu_barrier();\n\tprintv(2, \"after tag_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tgang_check();\n\trcu_barrier();\n\tprintv(2, \"after gang_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tadd_and_check();\n\trcu_barrier();\n\tprintv(2, \"after add_and_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tdynamic_height_check();\n\trcu_barrier();\n\tprintv(2, \"after dynamic_height_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tidr_checks();\n\tida_tests();\n\trcu_barrier();\n\tprintv(2, \"after idr_checks: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tbig_gang_check(long_run);\n\trcu_barrier();\n\tprintv(2, \"after big_gang_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\tfor (i = 0; i < (long_run ? 2000 : 3); i++) {\n\t\tcopy_tag_check();\n\t\tprintv(2, \"%d \", i);\n\t\tfflush(stdout);\n\t}\n\trcu_barrier();\n\tprintv(2, \"after copy_tag_check: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n}\n\nint main(int argc, char **argv)\n{\n\tbool long_run = false;\n\tint opt;\n\tunsigned int seed = time(NULL);\n\n\twhile ((opt = getopt(argc, argv, \"ls:v\")) != -1) {\n\t\tif (opt == 'l')\n\t\t\tlong_run = true;\n\t\telse if (opt == 's')\n\t\t\tseed = strtoul(optarg, NULL, 0);\n\t\telse if (opt == 'v')\n\t\t\ttest_verbose++;\n\t}\n\n\tprintf(\"random seed %u\\n\", seed);\n\tsrand(seed);\n\n\tprintf(\"running tests\\n\");\n\n\trcu_register_thread();\n\tradix_tree_init();\n\n\txarray_tests();\n\tregression1_test();\n\tregression2_test();\n\tregression3_test();\n\tregression4_test();\n\titeration_test(0, 10 + 90 * long_run);\n\titeration_test(7, 10 + 90 * long_run);\n\titeration_test2(10 + 90 * long_run);\n\tsingle_thread_tests(long_run);\n\n\t \n\tradix_tree_cpu_dead(0);\n\n\tbenchmark();\n\n\trcu_barrier();\n\tprintv(2, \"after rcu_barrier: %d allocated, preempt %d\\n\",\n\t\tnr_allocated, preempt_count);\n\trcu_unregister_thread();\n\n\tprintf(\"tests completed\\n\");\n\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}