{
  "module_name": "config-bisect.pl",
  "hash_id": "ac852f9f1a1f5f737282bcb6f87df7ac26c2a134efd795b0c210fc1c5bd784d5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/ktest/config-bisect.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright 2015 - Steven Rostedt, Red Hat Inc.\n# Copyright 2017 - Steven Rostedt, VMware, Inc.\n#\n\n# usage:\n#  config-bisect.pl [options] good-config bad-config [good|bad]\n#\n\n# Compares a good config to a bad config, then takes half of the diffs\n# and produces a config that is somewhere between the good config and\n# the bad config. That is, the resulting config will start with the\n# good config and will try to make half of the differences of between\n# the good and bad configs match the bad config. It tries because of\n# dependencies between the two configs it may not be able to change\n# exactly half of the configs that are different between the two config\n# files.\n\n# Here's a normal way to use it:\n#\n#  $ cd /path/to/linux/kernel\n#  $ config-bisect.pl /path/to/good/config /path/to/bad/config\n\n# This will now pull in good config (blowing away .config in that directory\n# so do not make that be one of the good or bad configs), and then\n# build the config with \"make oldconfig\" to make sure it matches the\n# current kernel. It will then store the configs in that result for\n# the good config. It does the same for the bad config as well.\n# The algorithm will run, merging half of the differences between\n# the two configs and building them with \"make oldconfig\" to make sure\n# the result changes (dependencies may reset changes the tool had made).\n# It then copies the result of its good config to /path/to/good/config.tmp\n# and the bad config to /path/to/bad/config.tmp (just appends \".tmp\" to the\n# files passed in). And the \".config\" that you should test will be in\n# directory\n\n# After the first run, determine if the result is good or bad then\n# run the same command appending the result\n\n# For good results:\n#  $ config-bisect.pl /path/to/good/config /path/to/bad/config good\n\n# For bad results:\n#  $ config-bisect.pl /path/to/good/config /path/to/bad/config bad\n\n# Do not change the good-config or bad-config, config-bisect.pl will\n# copy the good-config to a temp file with the same name as good-config\n# but with a \".tmp\" after it. It will do the same with the bad-config.\n\n# If \"good\" or \"bad\" is not stated at the end, it will copy the good and\n# bad configs to the .tmp versions. If a .tmp version already exists, it will\n# warn before writing over them (-r will not warn, and just write over them).\n# If the last config is labeled \"good\", then it will copy it to the good .tmp\n# version. If the last config is labeled \"bad\", it will copy it to the bad\n# .tmp version. It will continue this until it can not merge the two any more\n# without the result being equal to either the good or bad .tmp configs.\n\nmy $start = 0;\nmy $val = \"\";\n\nmy $pwd = `pwd`;\nchomp $pwd;\nmy $tree = $pwd;\nmy $build;\n\nmy $output_config;\nmy $reset_bisect;\n\nsub usage {\n    print << \"EOF\"\n\nusage: config-bisect.pl [-l linux-tree][-b build-dir] good-config bad-config [good|bad]\n  -l [optional] define location of linux-tree (default is current directory)\n  -b [optional] define location to build (O=build-dir) (default is linux-tree)\n  good-config the config that is considered good\n  bad-config the config that does not work\n  \"good\" add this if the last run produced a good config\n  \"bad\" add this if the last run produced a bad config\n  If \"good\" or \"bad\" is not specified, then it is the start of a new bisect\n\n  Note, each run will create copy of good and bad configs with \".tmp\" appended.\n\nEOF\n;\n\n    exit(-1);\n}\n\nsub doprint {\n    print @_;\n}\n\nsub dodie {\n    doprint \"CRITICAL FAILURE... \", @_, \"\\n\";\n\n    die @_, \"\\n\";\n}\n\nsub expand_path {\n    my ($file) = @_;\n\n    if ($file =~ m,^/,) {\n\treturn $file;\n    }\n    return \"$pwd/$file\";\n}\n\nsub read_prompt {\n    my ($cancel, $prompt) = @_;\n\n    my $ans;\n\n    for (;;) {\n\tif ($cancel) {\n\t    print \"$prompt [y/n/C] \";\n\t} else {\n\t    print \"$prompt [y/N] \";\n\t}\n\t$ans = <STDIN>;\n\tchomp $ans;\n\tif ($ans =~ /^\\s*$/) {\n\t    if ($cancel) {\n\t\t$ans = \"c\";\n\t    } else {\n\t\t$ans = \"n\";\n\t    }\n\t}\n\tlast if ($ans =~ /^y$/i || $ans =~ /^n$/i);\n\tif ($cancel) {\n\t    last if ($ans =~ /^c$/i);\n\t    print \"Please answer either 'y', 'n' or 'c'.\\n\";\n\t} else {\n\t    print \"Please answer either 'y' or 'n'.\\n\";\n\t}\n    }\n    if ($ans =~ /^c/i) {\n\texit;\n    }\n    if ($ans !~ /^y$/i) {\n\treturn 0;\n    }\n    return 1;\n}\n\nsub read_yn {\n    my ($prompt) = @_;\n\n    return read_prompt 0, $prompt;\n}\n\nsub read_ync {\n    my ($prompt) = @_;\n\n    return read_prompt 1, $prompt;\n}\n\nsub run_command {\n    my ($command, $redirect) = @_;\n    my $start_time;\n    my $end_time;\n    my $dord = 0;\n    my $pid;\n\n    $start_time = time;\n\n    doprint(\"$command ... \");\n\n    $pid = open(CMD, \"$command 2>&1 |\") or\n\tdodie \"unable to exec $command\";\n\n    if (defined($redirect)) {\n\topen (RD, \">$redirect\") or\n\t    dodie \"failed to write to redirect $redirect\";\n\t$dord = 1;\n    }\n\n    while (<CMD>) {\n\tprint RD  if ($dord);\n    }\n\n    waitpid($pid, 0);\n    my $failed = $?;\n\n    close(CMD);\n    close(RD)  if ($dord);\n\n    $end_time = time;\n    my $delta = $end_time - $start_time;\n\n    if ($delta == 1) {\n\tdoprint \"[1 second] \";\n    } else {\n\tdoprint \"[$delta seconds] \";\n    }\n\n    if ($failed) {\n\tdoprint \"FAILED!\\n\";\n    } else {\n\tdoprint \"SUCCESS\\n\";\n    }\n\n    return !$failed;\n}\n\n###### CONFIG BISECT ######\n\n# config_ignore holds the configs that were set (or unset) for\n# a good config and we will ignore these configs for the rest\n# of a config bisect. These configs stay as they were.\nmy %config_ignore;\n\n# config_set holds what all configs were set as.\nmy %config_set;\n\n# config_off holds the set of configs that the bad config had disabled.\n# We need to record them and set them in the .config when running\n# olddefconfig, because olddefconfig keeps the defaults.\nmy %config_off;\n\n# config_off_tmp holds a set of configs to turn off for now\nmy @config_off_tmp;\n\n# config_list is the set of configs that are being tested\nmy %config_list;\nmy %null_config;\n\nmy %dependency;\n\nmy $make;\n\nsub make_oldconfig {\n\n    if (!run_command \"$make olddefconfig\") {\n\t# Perhaps olddefconfig doesn't exist in this version of the kernel\n\t# try oldnoconfig\n\tdoprint \"olddefconfig failed, trying make oldnoconfig\\n\";\n\tif (!run_command \"$make oldnoconfig\") {\n\t    doprint \"oldnoconfig failed, trying yes '' | make oldconfig\\n\";\n\t    # try a yes '' | oldconfig\n\t    run_command \"yes '' | $make oldconfig\" or\n\t\tdodie \"failed make config oldconfig\";\n\t}\n    }\n}\n\nsub assign_configs {\n    my ($hash, $config) = @_;\n\n    doprint \"Reading configs from $config\\n\";\n\n    open (IN, $config)\n\tor dodie \"Failed to read $config\";\n\n    while (<IN>) {\n\tchomp;\n\tif (/^((CONFIG\\S*)=.*)/) {\n\t    ${$hash}{$2} = $1;\n\t} elsif (/^(# (CONFIG\\S*) is not set)/) {\n\t    ${$hash}{$2} = $1;\n\t}\n    }\n\n    close(IN);\n}\n\nsub process_config_ignore {\n    my ($config) = @_;\n\n    assign_configs \\%config_ignore, $config;\n}\n\nsub get_dependencies {\n    my ($config) = @_;\n\n    my $arr = $dependency{$config};\n    if (!defined($arr)) {\n\treturn ();\n    }\n\n    my @deps = @{$arr};\n\n    foreach my $dep (@{$arr}) {\n\tprint \"ADD DEP $dep\\n\";\n\t@deps = (@deps, get_dependencies $dep);\n    }\n\n    return @deps;\n}\n\nsub save_config {\n    my ($pc, $file) = @_;\n\n    my %configs = %{$pc};\n\n    doprint \"Saving configs into $file\\n\";\n\n    open(OUT, \">$file\") or dodie \"Can not write to $file\";\n\n    foreach my $config (keys %configs) {\n\tprint OUT \"$configs{$config}\\n\";\n    }\n    close(OUT);\n}\n\nsub create_config {\n    my ($name, $pc) = @_;\n\n    doprint \"Creating old config from $name configs\\n\";\n\n    save_config $pc, $output_config;\n\n    make_oldconfig;\n}\n\n# compare two config hashes, and return configs with different vals.\n# It returns B's config values, but you can use A to see what A was.\nsub diff_config_vals {\n    my ($pa, $pb) = @_;\n\n    # crappy Perl way to pass in hashes.\n    my %a = %{$pa};\n    my %b = %{$pb};\n\n    my %ret;\n\n    foreach my $item (keys %a) {\n\tif (defined($b{$item}) && $b{$item} ne $a{$item}) {\n\t    $ret{$item} = $b{$item};\n\t}\n    }\n\n    return %ret;\n}\n\n# compare two config hashes and return the configs in B but not A\nsub diff_configs {\n    my ($pa, $pb) = @_;\n\n    my %ret;\n\n    # crappy Perl way to pass in hashes.\n    my %a = %{$pa};\n    my %b = %{$pb};\n\n    foreach my $item (keys %b) {\n\tif (!defined($a{$item})) {\n\t    $ret{$item} = $b{$item};\n\t}\n    }\n\n    return %ret;\n}\n\n# return if two configs are equal or not\n# 0 is equal +1 b has something a does not\n# +1 if a and b have a different item.\n# -1 if a has something b does not\nsub compare_configs {\n    my ($pa, $pb) = @_;\n\n    my %ret;\n\n    # crappy Perl way to pass in hashes.\n    my %a = %{$pa};\n    my %b = %{$pb};\n\n    foreach my $item (keys %b) {\n\tif (!defined($a{$item})) {\n\t    return 1;\n\t}\n\tif ($a{$item} ne $b{$item}) {\n\t    return 1;\n\t}\n    }\n\n    foreach my $item (keys %a) {\n\tif (!defined($b{$item})) {\n\t    return -1;\n\t}\n    }\n\n    return 0;\n}\n\nsub process_failed {\n    my ($config) = @_;\n\n    doprint \"\\n\\n***************************************\\n\";\n    doprint \"Found bad config: $config\\n\";\n    doprint \"***************************************\\n\\n\";\n}\n\nsub process_new_config {\n    my ($tc, $nc, $gc, $bc) = @_;\n\n    my %tmp_config = %{$tc};\n    my %good_configs = %{$gc};\n    my %bad_configs = %{$bc};\n\n    my %new_configs;\n\n    my $runtest = 1;\n    my $ret;\n\n    create_config \"tmp_configs\", \\%tmp_config;\n    assign_configs \\%new_configs, $output_config;\n\n    $ret = compare_configs \\%new_configs, \\%bad_configs;\n    if (!$ret) {\n\tdoprint \"New config equals bad config, try next test\\n\";\n\t$runtest = 0;\n    }\n\n    if ($runtest) {\n\t$ret = compare_configs \\%new_configs, \\%good_configs;\n\tif (!$ret) {\n\t    doprint \"New config equals good config, try next test\\n\";\n\t    $runtest = 0;\n\t}\n    }\n\n    %{$nc} = %new_configs;\n\n    return $runtest;\n}\n\nsub convert_config {\n    my ($config) = @_;\n\n    if ($config =~ /^# (.*) is not set/) {\n\t$config = \"$1=n\";\n    }\n\n    $config =~ s/^CONFIG_//;\n    return $config;\n}\n\nsub print_config {\n    my ($sym, $config) = @_;\n\n    $config = convert_config $config;\n    doprint \"$sym$config\\n\";\n}\n\nsub print_config_compare {\n    my ($good_config, $bad_config) = @_;\n\n    $good_config = convert_config $good_config;\n    $bad_config = convert_config $bad_config;\n\n    my $good_value = $good_config;\n    my $bad_value = $bad_config;\n    $good_value =~ s/(.*)=//;\n    my $config = $1;\n\n    $bad_value =~ s/.*=//;\n\n    doprint \" $config $good_value -> $bad_value\\n\";\n}\n\n# Pass in:\n# $phalf: half of the configs names you want to add\n# $oconfigs: The orginial configs to start with\n# $sconfigs: The source to update $oconfigs with (from $phalf)\n# $which: The name of which half that is updating (top / bottom)\n# $type: The name of the source type (good / bad)\nsub make_half {\n    my ($phalf, $oconfigs, $sconfigs, $which, $type) = @_;\n\n    my @half = @{$phalf};\n    my %orig_configs = %{$oconfigs};\n    my %source_configs = %{$sconfigs};\n\n    my %tmp_config = %orig_configs;\n\n    doprint \"Settings bisect with $which half of $type configs:\\n\";\n    foreach my $item (@half) {\n\tdoprint \"Updating $item to $source_configs{$item}\\n\";\n\t$tmp_config{$item} = $source_configs{$item};\n    }\n\n    return %tmp_config;\n}\n\nsub run_config_bisect {\n    my ($pgood, $pbad) = @_;\n\n    my %good_configs = %{$pgood};\n    my %bad_configs = %{$pbad};\n\n    my %diff_configs = diff_config_vals \\%good_configs, \\%bad_configs;\n    my %b_configs = diff_configs \\%good_configs, \\%bad_configs;\n    my %g_configs = diff_configs \\%bad_configs, \\%good_configs;\n\n    # diff_arr is what is in both good and bad but are different (y->n)\n    my @diff_arr = keys %diff_configs;\n    my $len_diff = $#diff_arr + 1;\n\n    # b_arr is what is in bad but not in good (has depends)\n    my @b_arr = keys %b_configs;\n    my $len_b = $#b_arr + 1;\n\n    # g_arr is what is in good but not in bad\n    my @g_arr = keys %g_configs;\n    my $len_g = $#g_arr + 1;\n\n    my $runtest = 0;\n    my %new_configs;\n    my $ret;\n\n    # Look at the configs that are different between good and bad.\n    # This does not include those that depend on other configs\n    #  (configs depending on other configs that are not set would\n    #   not show up even as a \"# CONFIG_FOO is not set\"\n\n\n    doprint \"# of configs to check:             $len_diff\\n\";\n    doprint \"# of configs showing only in good: $len_g\\n\";\n    doprint \"# of configs showing only in bad:  $len_b\\n\";\n\n    if ($len_diff > 0) {\n\t# Now test for different values\n\n\tdoprint \"Configs left to check:\\n\";\n\tdoprint \"  Good Config\\t\\t\\tBad Config\\n\";\n\tdoprint \"  -----------\\t\\t\\t----------\\n\";\n\tforeach my $item (@diff_arr) {\n\t    doprint \"  $good_configs{$item}\\t$bad_configs{$item}\\n\";\n\t}\n\n\tmy $half = int($#diff_arr / 2);\n\tmy @tophalf = @diff_arr[0 .. $half];\n\n\tdoprint \"Set tmp config to be good config with some bad config values\\n\";\n\n\tmy %tmp_config = make_half \\@tophalf, \\%good_configs,\n\t    \\%bad_configs, \"top\", \"bad\";\n\n\t$runtest = process_new_config \\%tmp_config, \\%new_configs,\n\t\t\t    \\%good_configs, \\%bad_configs;\n\n\tif (!$runtest) {\n\t    doprint \"Set tmp config to be bad config with some good config values\\n\";\n\n\t    my %tmp_config = make_half \\@tophalf, \\%bad_configs,\n\t\t\\%good_configs, \"top\", \"good\";\n\n\t    $runtest = process_new_config \\%tmp_config, \\%new_configs,\n\t\t\\%good_configs, \\%bad_configs;\n\t}\n    }\n\n    if (!$runtest && $len_diff > 0) {\n\t# do the same thing, but this time with bottom half\n\n\tmy $half = int($#diff_arr / 2);\n\tmy @bottomhalf = @diff_arr[$half+1 .. $#diff_arr];\n\n\tdoprint \"Set tmp config to be good config with some bad config values\\n\";\n\n\tmy %tmp_config = make_half \\@bottomhalf, \\%good_configs,\n\t    \\%bad_configs, \"bottom\", \"bad\";\n\n\t$runtest = process_new_config \\%tmp_config, \\%new_configs,\n\t\t\t    \\%good_configs, \\%bad_configs;\n\n\tif (!$runtest) {\n\t    doprint \"Set tmp config to be bad config with some good config values\\n\";\n\n\t    my %tmp_config = make_half \\@bottomhalf, \\%bad_configs,\n\t\t\\%good_configs, \"bottom\", \"good\";\n\n\t    $runtest = process_new_config \\%tmp_config, \\%new_configs,\n\t\t\\%good_configs, \\%bad_configs;\n\t}\n    }\n\n    if ($runtest) {\n\tmake_oldconfig;\n\tdoprint \"READY TO TEST .config IN $build\\n\";\n\treturn 0;\n    }\n\n    doprint \"\\n%%%%%%%% FAILED TO FIND SINGLE BAD CONFIG %%%%%%%%\\n\";\n    doprint \"Hmm, can't make any more changes without making good == bad?\\n\";\n    doprint \"Difference between good (+) and bad (-)\\n\";\n\n    foreach my $item (keys %bad_configs) {\n\tif (!defined($good_configs{$item})) {\n\t    print_config \"-\", $bad_configs{$item};\n\t}\n    }\n\n    foreach my $item (keys %good_configs) {\n\tnext if (!defined($bad_configs{$item}));\n\tif ($good_configs{$item} ne $bad_configs{$item}) {\n\t    print_config_compare $good_configs{$item}, $bad_configs{$item};\n\t}\n    }\n\n    foreach my $item (keys %good_configs) {\n\tif (!defined($bad_configs{$item})) {\n\t    print_config \"+\", $good_configs{$item};\n\t}\n    }\n    return -1;\n}\n\nsub config_bisect {\n    my ($good_config, $bad_config) = @_;\n    my $ret;\n\n    my %good_configs;\n    my %bad_configs;\n    my %tmp_configs;\n\n    doprint \"Run good configs through make oldconfig\\n\";\n    assign_configs \\%tmp_configs, $good_config;\n    create_config \"$good_config\", \\%tmp_configs;\n    assign_configs \\%good_configs, $output_config;\n\n    doprint \"Run bad configs through make oldconfig\\n\";\n    assign_configs \\%tmp_configs, $bad_config;\n    create_config \"$bad_config\", \\%tmp_configs;\n    assign_configs \\%bad_configs, $output_config;\n\n    save_config \\%good_configs, $good_config;\n    save_config \\%bad_configs, $bad_config;\n\n    return run_config_bisect \\%good_configs, \\%bad_configs;\n}\n\nwhile ($#ARGV >= 0) {\n    if ($ARGV[0] !~ m/^-/) {\n\tlast;\n    }\n    my $opt = shift @ARGV;\n\n    if ($opt eq \"-b\") {\n\t$val = shift @ARGV;\n\tif (!defined($val)) {\n\t    die \"-b requires value\\n\";\n\t}\n\t$build = $val;\n    }\n\n    elsif ($opt eq \"-l\") {\n\t$val = shift @ARGV;\n\tif (!defined($val)) {\n\t    die \"-l requires value\\n\";\n\t}\n\t$tree = $val;\n    }\n\n    elsif ($opt eq \"-r\") {\n\t$reset_bisect = 1;\n    }\n\n    elsif ($opt eq \"-h\") {\n\tusage;\n    }\n\n    else {\n\tdie \"Unknown option $opt\\n\";\n    }\n}\n\n$build = $tree if (!defined($build));\n\n$tree = expand_path $tree;\n$build = expand_path $build;\n\nif ( ! -d $tree ) {\n    die \"$tree not a directory\\n\";\n}\n\nif ( ! -d $build ) {\n    die \"$build not a directory\\n\";\n}\n\nusage if $#ARGV < 1;\n\nif ($#ARGV == 1) {\n    $start = 1;\n} elsif ($#ARGV == 2) {\n    $val = $ARGV[2];\n    if ($val ne \"good\" && $val ne \"bad\") {\n\tdie \"Unknown command '$val', bust be either \\\"good\\\" or \\\"bad\\\"\\n\";\n    }\n} else {\n    usage;\n}\n\nmy $good_start = expand_path $ARGV[0];\nmy $bad_start = expand_path $ARGV[1];\n\nmy $good = \"$good_start.tmp\";\nmy $bad = \"$bad_start.tmp\";\n\n$make = \"make\";\n\nif ($build ne $tree) {\n    $make = \"make O=$build\"\n}\n\n$output_config = \"$build/.config\";\n\nif ($start) {\n    if ( ! -f $good_start ) {\n\tdie \"$good_start not found\\n\";\n    }\n    if ( ! -f $bad_start ) {\n\tdie \"$bad_start not found\\n\";\n    }\n    if ( -f $good || -f $bad ) {\n\tmy $p = \"\";\n\n\tif ( -f $good ) {\n\t    $p = \"$good exists\\n\";\n\t}\n\n\tif ( -f $bad ) {\n\t    $p = \"$p$bad exists\\n\";\n\t}\n\n\tif (!defined($reset_bisect)) {\n\t    if (!read_yn \"${p}Overwrite and start new bisect anyway?\") {\n\t\texit (-1);\n\t    }\n\t}\n    }\n    run_command \"cp $good_start $good\" or die \"failed to copy to $good\\n\";\n    run_command \"cp $bad_start $bad\" or die \"failed to copy to $bad\\n\";\n} else {\n    if ( ! -f $good ) {\n\tdie \"Can not find file $good\\n\";\n    }\n    if ( ! -f $bad ) {\n\tdie \"Can not find file $bad\\n\";\n    }\n    if ($val eq \"good\") {\n\trun_command \"cp $output_config $good\" or die \"failed to copy $config to $good\\n\";\n    } elsif ($val eq \"bad\") {\n\trun_command \"cp $output_config $bad\" or die \"failed to copy $config to $bad\\n\";\n    }\n}\n\nchdir $tree || die \"can't change directory to $tree\";\n\nmy $ret = config_bisect $good, $bad;\n\nif (!$ret) {\n    exit(0);\n}\n\nif ($ret > 0) {\n    doprint \"Cleaning temp files\\n\";\n    run_command \"rm $good\";\n    run_command \"rm $bad\";\n    exit(1);\n} else {\n    doprint \"See good and bad configs for details:\\n\";\n    doprint \"good: $good\\n\";\n    doprint \"bad:  $bad\\n\";\n    doprint \"%%%%%%%% FAILED TO FIND SINGLE BAD CONFIG %%%%%%%%\\n\";\n}\nexit(2);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}