{
  "module_name": "sample.conf",
  "hash_id": "aa64e18fb339bb9f8a7092a0ce2e48ed7e1c7feaf80907f73634aeab1b68177a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/ktest/sample.conf",
  "human_readable_source": "#\n# Config file for ktest.pl\n#\n# Place your customized version of this, in the working directory that\n# ktest.pl is run from. By default, ktest.pl will look for a file\n# called \"ktest.conf\", but you can name it anything you like and specify\n# the name of your config file as the first argument of ktest.pl.\n#\n# Note, all paths must be absolute\n#\n\n# Options set in the beginning of the file are considered to be\n# default options. These options can be overridden by test specific\n# options, with the following exceptions:\n#\n#  LOG_FILE\n#  CLEAR_LOG\n#  POWEROFF_ON_SUCCESS\n#  REBOOT_ON_SUCCESS\n#\n# Test specific options are set after the label:\n#\n# TEST_START\n#\n# The options after a TEST_START label are specific to that test.\n# Each TEST_START label will set up a new test. If you want to\n# perform a test more than once, you can add the ITERATE label\n# to it followed by the number of times you want that test\n# to iterate. If the ITERATE is left off, the test will only\n# be performed once.\n#\n# TEST_START ITERATE 10\n#\n# You can skip a test by adding SKIP (before or after the ITERATE\n# and number)\n#\n# TEST_START SKIP\n#\n# TEST_START SKIP ITERATE 10\n#\n# TEST_START ITERATE 10 SKIP\n#\n# The SKIP label causes the options and the test itself to be ignored.\n# This is useful to set up several different tests in one config file, and\n# only enabling the ones you want to use for a current test run.\n#\n# You can add default options anywhere in the file as well\n# with the DEFAULTS tag. This allows you to have default options\n# after the test options to keep the test options at the top\n# of the file. You can even place the DEFAULTS tag between\n# test cases (but not in the middle of a single test case)\n#\n# TEST_START\n# MIN_CONFIG = /home/test/config-test1\n#\n# DEFAULTS\n# MIN_CONFIG = /home/test/config-default\n#\n# TEST_START ITERATE 10\n#\n# The above will run the first test with MIN_CONFIG set to\n# /home/test/config-test-1. Then 10 tests will be executed\n# with MIN_CONFIG with /home/test/config-default.\n#\n# You can also disable defaults with the SKIP option\n#\n# DEFAULTS SKIP\n# MIN_CONFIG = /home/test/config-use-sometimes\n#\n# DEFAULTS\n# MIN_CONFIG = /home/test/config-most-times\n#\n# The above will ignore the first MIN_CONFIG. If you want to\n# use the first MIN_CONFIG, remove the SKIP from the first\n# DEFAULTS tag and add it to the second. Be careful, options\n# may only be declared once per test or default. If you have\n# the same option name under the same test or as default\n# ktest will fail to execute, and no tests will run.\n#\n# DEFAULTS OVERRIDE\n#\n# Options defined in the DEFAULTS section can not be duplicated\n# even if they are defined in two different DEFAULT sections.\n# This is done to catch mistakes where an option is added but\n# the previous option was forgotten about and not commented.\n#\n# The OVERRIDE keyword can be added to a section to allow this\n# section to override other DEFAULT sections values that have\n# been defined previously. It will only override options that\n# have been defined before its use. Options defined later\n# in a non override section will still error. The same option\n# can not be defined in the same section even if that section\n# is marked OVERRIDE.\n#\n#\n#\n# Both TEST_START and DEFAULTS sections can also have the IF keyword\n# The value after the IF must evaluate into a 0 or non 0 positive\n# integer, and can use the config variables (explained below).\n#\n# DEFAULTS IF ${IS_X86_32}\n#\n# The above will process the DEFAULTS section if the config\n# variable IS_X86_32 evaluates to a non zero positive integer\n# otherwise if it evaluates to zero, it will act the same\n# as if the SKIP keyword was used.\n#\n# The ELSE keyword can be used directly after a section with\n# a IF statement.\n#\n# TEST_START IF ${RUN_NET_TESTS}\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-network\n#\n# ELSE\n#\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-normal\n#\n#\n# The ELSE keyword can also contain an IF statement to allow multiple\n# if then else sections. But all the sections must be either\n# DEFAULT or TEST_START, they can not be a mixture.\n#\n# TEST_START IF ${RUN_NET_TESTS}\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-network\n#\n# ELSE IF ${RUN_DISK_TESTS}\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-tests\n#\n# ELSE IF ${RUN_CPU_TESTS}\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-cpu\n#\n# ELSE\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-network\n#\n# The if statement may also have comparisons that will and for\n# == and !=, strings may be used for both sides.\n#\n# BOX_TYPE := x86_32\n#\n# DEFAULTS IF ${BOX_TYPE} == x86_32\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-32\n# ELSE\n# BUILD_TYPE = useconfig:${CONFIG_DIR}/config-64\n#\n# The DEFINED keyword can be used by the IF statements too.\n# It returns true if the given config variable or option has been defined\n# or false otherwise.\n#\n# \n# DEFAULTS IF DEFINED USE_CC\n# CC := ${USE_CC}\n# ELSE\n# CC := gcc\n#\n#\n# As well as NOT DEFINED.\n#\n# DEFAULTS IF NOT DEFINED MAKE_CMD\n# MAKE_CMD := make ARCH=x86\n#\n#\n# And/or ops (&&,||) may also be used to make complex conditionals.\n#\n# TEST_START IF (DEFINED ALL_TESTS || ${MYTEST} == boottest) && ${MACHINE} == gandalf\n#\n# Notice the use of parentheses. Without any parentheses the above would be\n# processed the same as:\n#\n# TEST_START IF DEFINED ALL_TESTS || (${MYTEST} == boottest && ${MACHINE} == gandalf)\n#\n#\n#\n# INCLUDE file\n#\n# The INCLUDE keyword may be used in DEFAULT sections. This will\n# read another config file and process that file as well. The included\n# file can include other files, add new test cases or default\n# statements. Config variables will be passed to these files and changes\n# to config variables will be seen by top level config files. Including\n# a file is processed just like the contents of the file was cut and pasted\n# into the top level file, except, that include files that end with\n# TEST_START sections will have that section ended at the end of\n# the include file. That is, an included file is included followed\n# by another DEFAULT keyword.\n#\n# Unlike other files referenced in this config, the file path does not need\n# to be absolute. If the file does not start with '/', then the directory\n# that the current config file was located in is used. If no config by the\n# given name is found there, then the current directory is searched.\n#\n# INCLUDE myfile\n# DEFAULT\n#\n# is the same as:\n#\n# INCLUDE myfile\n#\n# Note, if the include file does not contain a full path, the file is\n# searched first by the location of the original include file, and then\n# by the location that ktest.pl was executed in.\n#\n\n#### Config variables ####\n#\n# This config file can also contain \"config variables\".\n# These are assigned with \":=\" instead of the ktest option\n# assignment \"=\".\n#\n# The difference between ktest options and config variables\n# is that config variables can be used multiple times,\n# where each instance will override the previous instance.\n# And that they only live at time of processing this config.\n#\n# The advantage to config variables are that they can be used\n# by any option or any other config variables to define thing\n# that you may use over and over again in the options.\n#\n# For example:\n#\n# USER      := root\n# TARGET    := mybox\n# TEST_CASE := ssh ${USER}@${TARGET} /path/to/my/test\n#\n# TEST_START\n# MIN_CONFIG = config1\n# TEST = ${TEST_CASE}\n#\n# TEST_START\n# MIN_CONFIG = config2\n# TEST = ${TEST_CASE}\n#\n# TEST_CASE := ssh ${USER}@${TARGET} /path/to/my/test2\n#\n# TEST_START\n# MIN_CONFIG = config1\n# TEST = ${TEST_CASE}\n#\n# TEST_START\n# MIN_CONFIG = config2\n# TEST = ${TEST_CASE}\n#\n# TEST_DIR := /home/me/test\n#\n# BUILD_DIR = ${TEST_DIR}/linux.git\n# OUTPUT_DIR = ${TEST_DIR}/test\n#\n# Note, the config variables are evaluated immediately, thus\n# updating TARGET after TEST_CASE has been assigned does nothing\n# to TEST_CASE.\n#\n# As shown in the example, to evaluate a config variable, you\n# use the ${X} convention. Simple $X will not work.\n#\n# If the config variable does not exist, the ${X} will not\n# be evaluated. Thus:\n#\n# MAKE_CMD = PATH=/mypath:${PATH} make\n#\n# If PATH is not a config variable, then the ${PATH} in\n# the MAKE_CMD option will be evaluated by the shell when\n# the MAKE_CMD option is passed into shell processing.\n#\n# Shell commands can also be inserted with the ${shell <command>}\n# expression. Note, this is case sensitive, thus ${SHELL <command>}\n# will not work.\n#\n# HOSTNAME := ${shell hostname}\n# DEFAULTS IF \"${HOSTNAME}\" == \"frodo\"\n#\n\n#### Using options in other options ####\n#\n# Options that are defined in the config file may also be used\n# by other options. All options are evaluated at time of\n# use (except that config variables are evaluated at config\n# processing time).\n#\n# If an ktest option is used within another option, instead of\n# typing it again in that option you can simply use the option\n# just like you can config variables.\n#\n# MACHINE = mybox\n#\n# TEST = ssh root@${MACHINE} /path/to/test\n#\n# The option will be used per test case. Thus:\n#\n# TEST_TYPE = test\n# TEST = ssh root@{MACHINE}\n#\n# TEST_START\n# MACHINE = box1\n#\n# TEST_START\n# MACHINE = box2\n#\n# For both test cases, MACHINE will be evaluated at the time\n# of the test case. The first test will run ssh root@box1\n# and the second will run ssh root@box2.\n\n#### Mandatory Default Options ####\n\n# These options must be in the default section, although most\n# may be overridden by test options.\n\n# The machine hostname that you will test\n#MACHINE = target\n\n# The box is expected to have ssh on normal bootup, provide the user\n#  (most likely root, since you need privileged operations)\n#SSH_USER = root\n\n# The directory that contains the Linux source code\n#BUILD_DIR = /home/test/linux.git\n\n# The directory that the objects will be built\n# (can not be same as BUILD_DIR)\n#OUTPUT_DIR = /home/test/build/target\n\n# The location of the compiled file to copy to the target\n# (relative to OUTPUT_DIR)\n#BUILD_TARGET = arch/x86/boot/bzImage\n\n# The place to put your image on the test machine\n#TARGET_IMAGE = /boot/vmlinuz-test\n\n# A script or command to reboot the box\n#\n# Here is a digital loggers power switch example\n#POWER_CYCLE = wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin@power/outlet?5=CCL'\n#\n# Here is an example to reboot a virtual box on the current host\n# with the name \"Guest\".\n#POWER_CYCLE = virsh destroy Guest; sleep 5; virsh start Guest\n\n# The script or command that reads the console\n#\n#  If you use ttywatch server, something like the following would work.\n#CONSOLE = nc -d localhost 3001\n#\n# For a virtual machine with guest name \"Guest\".\n#CONSOLE =  virsh console Guest\n\n# Signal to send to kill console.\n# ktest.pl will create a child process to monitor the console.\n# When the console is finished, ktest will kill the child process\n# with this signal.\n# (default INT)\n#CLOSE_CONSOLE_SIGNAL = HUP\n\n# Required version ending to differentiate the test\n# from other linux builds on the system.\n#LOCALVERSION = -test\n\n# For REBOOT_TYPE = grub2, you must specify where the grub.cfg\n# file is. This is the file that is searched to find the menu\n# option to boot to with GRUB_REBOOT\n#GRUB_FILE = /boot/grub2/grub.cfg\n\n# The tool for REBOOT_TYPE = grub2 or grub2bls to set the next reboot kernel\n# to boot into (one shot mode).\n# (default grub2_reboot)\n#GRUB_REBOOT = grub2_reboot\n\n# The grub title name for the test kernel to boot\n# (Only mandatory if REBOOT_TYPE = grub or grub2 or grub2bls)\n#\n# Note, ktest.pl will not update the grub menu.lst, you need to\n# manually add an option for the test. ktest.pl will search\n# the grub menu.lst for this option to find what kernel to\n# reboot into.\n#\n# For example, if in the /boot/grub/menu.lst the test kernel title has:\n# title Test Kernel\n# kernel vmlinuz-test\n#\n# For grub2, a search of top level \"menuentry\"s are done. No\n# submenu is searched. The menu is found by searching for the\n# contents of GRUB_MENU in the line that starts with \"menuentry\".\n# You may want to include the quotes around the option. For example:\n# for: menuentry 'Test Kernel'\n# do a: GRUB_MENU = 'Test Kernel'\n# For customizing, add your entry in /etc/grub.d/40_custom.\n#\n# For grub2bls, a search of \"title\"s are done. The menu is found\n# by searching for the contents of GRUB_MENU in the line that starts\n# with \"title\".\n#\n#GRUB_MENU = Test Kernel\n\n# For REBOOT_TYPE = syslinux, the name of the syslinux executable\n# (on the target) to use to set up the next reboot to boot the\n# test kernel.\n# (default extlinux)\n#SYSLINUX = syslinux\n\n# For REBOOT_TYPE = syslinux, the path that is passed to to the\n# syslinux command where syslinux is installed.\n# (default /boot/extlinux)\n#SYSLINUX_PATH = /boot/syslinux\n\n# For REBOOT_TYPE = syslinux, the syslinux label that references the\n# test kernel in the syslinux config file.\n# (default undefined)\n#SYSLINUX_LABEL = \"test-kernel\"\n\n# A script to reboot the target into the test kernel\n# This and SWITCH_TO_TEST are about the same, except\n# SWITCH_TO_TEST is run even for REBOOT_TYPE = grub.\n# This may be left undefined.\n# (default undefined)\n#REBOOT_SCRIPT =\n\n#### Optional Config Options (all have defaults) ####\n\n# Email options for receiving notifications. Users must setup\n# the specified mailer prior to using this feature.\n#\n# (default undefined)\n#MAILTO =\n#\n# Supported mailers: sendmail, mail, mailx\n# (default sendmail)\n#MAILER = sendmail\n#\n# The executable to run\n# (default: for sendmail \"/usr/sbin/sendmail\", otherwise equals ${MAILER})\n#MAIL_EXEC = /usr/sbin/sendmail\n#\n# The command used to send mail, which uses the above options\n# can be modified. By default if the mailer is \"sendmail\" then\n#  MAIL_COMMAND = echo \\'Subject: $SUBJECT\\n\\n$MESSAGE\\' | $MAIL_PATH/$MAILER -t $MAILTO\n# For mail or mailx:\n#  MAIL_COMMAND = \"$MAIL_PATH/$MAILER -s \\'$SUBJECT\\' $MAILTO <<< \\'$MESSAGE\\'\n# ktest.pl will do the substitution for MAIL_PATH, MAILER, MAILTO at the time\n#    it sends the mail if \"$FOO\" format is used. If \"${FOO}\" format is used,\n#    then the substitutions will occur at the time the config file is read.\n#    But note, MAIL_PATH and MAILER require being set by the config file if\n#     ${MAIL_PATH} or ${MAILER} are used, but not if $MAIL_PATH or $MAILER are.\n#MAIL_COMMAND = echo \\'Subject: $SUBJECT\\n\\n$MESSAGE\\' | $MAIL_PATH/$MAILER -t $MAILTO\n#\n# Errors are defined as those would terminate the script\n# (default 1)\n#EMAIL_ON_ERROR = 1\n# (default 1)\n#EMAIL_WHEN_FINISHED = 1\n# (default 0)\n#EMAIL_WHEN_STARTED = 1\n#\n# Users can cancel the test by Ctrl^C\n# (default 0)\n#EMAIL_WHEN_CANCELED = 1\n#\n# If a test ends with an error and EMAIL_ON_ERROR is set as well\n# as a LOG_FILE is defined, then the log of the failing test will\n# be included in the email that is sent.\n# It is possible that the log may be very large, in which case,\n# only the last amount of the log should be sent. To limit how\n# much of the log is sent, set MAIL_MAX_SIZE. This will be the\n# size in bytes of the last portion of the log of the failed\n# test file. That is, if this is set to 100000, then only the\n# last 100 thousand bytes of the log file will be included in\n# the email.\n# (default undef)\n#MAIL_MAX_SIZE = 1000000\n\n# Start a test setup. If you leave this off, all options\n# will be default and the test will run once.\n# This is a label and not really an option (it takes no value).\n# You can append ITERATE and a number after it to iterate the\n# test a number of times, or SKIP to ignore this test.\n#\n#TEST_START\n#TEST_START ITERATE 5\n#TEST_START SKIP\n\n# Have the following options as default again. Used after tests\n# have already been defined by TEST_START. Optionally, you can\n# just define all default options before the first TEST_START\n# and you do not need this option.\n#\n# This is a label and not really an option (it takes no value).\n# You can append SKIP to this label and the options within this\n# section will be ignored.\n#\n# DEFAULTS\n# DEFAULTS SKIP\n\n# If you want to execute some command before the first test runs\n# you can set this option. Note, it can be set as a default option\n# or an option in the first test case. All other test cases will\n# ignore it. If both the default and first test have this option\n# set, then the first test will take precedence.\n#\n# default (undefined)\n#PRE_KTEST = ${SSH} ~/set_up_test\n\n# If you want to execute some command after all the tests have\n# completed, you can set this option. Note, it can be set as a\n# default or any test case can override it. If multiple test cases\n# set this option, then the last test case that set it will take\n# precedence\n#\n# default (undefined)\n#POST_KTEST = ${SSH} ~/dismantle_test\n\n# If you want to remove the kernel entry in Boot Loader Specification (BLS)\n# environment, use kernel-install command.\n# Here's the example:\n#POST_KTEST = ssh root@Test \"/usr/bin/kernel-install remove $KERNEL_VERSION\"\n\n# The default test type (default test)\n# The test types may be:\n#   build   - only build the kernel, do nothing else\n#   install - build and install, but do nothing else (does not reboot)\n#   boot    - build, install, and boot the kernel\n#   test    - build, boot and if TEST is set, run the test script\n#          (If TEST is not set, it defaults back to boot)\n#   bisect - Perform a bisect on the kernel (see BISECT_TYPE below)\n#   patchcheck - Do a test on a series of commits in git (see PATCHCHECK below)\n#TEST_TYPE = test\n\n# Test to run if there is a successful boot and TEST_TYPE is test.\n# Must exit with 0 on success and non zero on error\n# default (undefined)\n#TEST = ssh user@machine /root/run_test\n\n# The build type is any make config type or special command\n#  (default oldconfig)\n#   nobuild - skip the clean and build step\n#   useconfig:/path/to/config - use the given config and run\n#              oldconfig on it.\n# This option is ignored if TEST_TYPE is patchcheck or bisect\n#BUILD_TYPE = randconfig\n\n# The make command (default make)\n# If you are building a 32bit x86 on a 64 bit host\n#MAKE_CMD = CC=i386-gcc AS=i386-as make ARCH=i386\n\n# Any build options for the make of the kernel (not for other makes, like configs)\n# (default \"\")\n#BUILD_OPTIONS = -j20\n\n# If you need to do some special handling before installing\n# you can add a script with this option.\n# The environment variable KERNEL_VERSION will be set to the\n# kernel version that is used.\n#\n# default (undefined)\n#PRE_INSTALL = ssh user@target rm -rf '/lib/modules/*-test*'\n\n# If you need an initrd, you can add a script or code here to install\n# it. The environment variable KERNEL_VERSION will be set to the\n# kernel version that is used. Remember to add the initrd line\n# to your grub menu.lst file.\n#\n# Here's a couple of examples to use:\n#POST_INSTALL = ssh user@target /sbin/mkinitrd --allow-missing -f /boot/initramfs-test.img $KERNEL_VERSION\n#\n# or on some systems:\n#POST_INSTALL = ssh user@target /sbin/dracut -f /boot/initramfs-test.img $KERNEL_VERSION\n\n# If you want to add the kernel entry in Boot Loader Specification (BLS)\n# environment, use kernel-install command.\n# Here's the example:\n#POST_INSTALL = ssh root@Test \"/usr/bin/kernel-install add $KERNEL_VERSION /boot/vmlinuz-$KERNEL_VERSION\"\n\n# If for some reason you just want to boot the kernel and you do not\n# want the test to install anything new. For example, you may just want\n# to boot test the same kernel over and over and do not want to go through\n# the hassle of installing anything, you can set this option to 1\n# (default 0)\n#NO_INSTALL = 1\n\n# If there is a command that you want to run before the individual test\n# case executes, then you can set this option\n#\n# default (undefined)\n#PRE_TEST = ${SSH} reboot_to_special_kernel\n\n# To kill the entire test if PRE_TEST is defined but fails set this\n# to 1.\n# (default 0)\n#PRE_TEST_DIE = 1\n\n# If there is a command you want to run after the individual test case\n# completes, then you can set this option.\n#\n# default (undefined)\n#POST_TEST = cd ${BUILD_DIR}; git reset --hard\n\n# If there is a script that you require to run before the build is done\n# you can specify it with PRE_BUILD.\n#\n# One example may be if you must add a temporary patch to the build to\n# fix a unrelated bug to perform a patchcheck test. This will apply the\n# patch before each build that is made. Use the POST_BUILD to do a git reset --hard\n# to remove the patch.\n#\n# (default undef)\n#PRE_BUILD = cd ${BUILD_DIR} && patch -p1 < /tmp/temp.patch\n\n# To specify if the test should fail if the PRE_BUILD fails,\n# PRE_BUILD_DIE needs to be set to 1. Otherwise the PRE_BUILD\n# result is ignored.\n# (default 0)\n# PRE_BUILD_DIE = 1\n\n# If there is a script that should run after the build is done\n# you can specify it with POST_BUILD.\n#\n# As the example in PRE_BUILD, POST_BUILD can be used to reset modifications\n# made by the PRE_BUILD.\n#\n# (default undef)\n#POST_BUILD = cd ${BUILD_DIR} && git reset --hard\n\n# To specify if the test should fail if the POST_BUILD fails,\n# POST_BUILD_DIE needs to be set to 1. Otherwise the POST_BUILD\n# result is ignored.\n# (default 0)\n#POST_BUILD_DIE = 1\n\n# Way to reboot the box to the test kernel.\n# Only valid options so far are \"grub\", \"grub2\", \"syslinux\" and \"script\"\n# (default grub)\n# If you specify grub, it will assume grub version 1\n# and will search in /boot/grub/menu.lst for the title $GRUB_MENU\n# and select that target to reboot to the kernel. If this is not\n# your setup, then specify \"script\" and have a command or script\n# specified in REBOOT_SCRIPT to boot to the target.\n#\n# For REBOOT_TYPE = grub2, you must define both GRUB_MENU and\n# GRUB_FILE.\n#\n# For REBOOT_TYPE = grub2bls, you must define GRUB_MENU.\n#\n# For REBOOT_TYPE = syslinux, you must define SYSLINUX_LABEL, and\n# perhaps modify SYSLINUX (default extlinux) and SYSLINUX_PATH\n# (default /boot/extlinux)\n#\n# The entry in /boot/grub/menu.lst must be entered in manually.\n# The test will not modify that file.\n#REBOOT_TYPE = grub\n\n# If you are using a machine that doesn't boot with grub, and\n# perhaps gets its kernel from a remote server (tftp), then\n# you can use this option to update the target image with the\n# test image.\n#\n# You could also do the same with POST_INSTALL, but the difference\n# between that option and this option is that POST_INSTALL runs\n# after the install, where this one runs just before a reboot.\n# (default undefined)\n#SWITCH_TO_TEST = cp ${OUTPUT_DIR}/${BUILD_TARGET} ${TARGET_IMAGE}\n\n# If you are using a machine that doesn't boot with grub, and\n# perhaps gets its kernel from a remote server (tftp), then\n# you can use this option to update the target image with the\n# the known good image to reboot safely back into.\n#\n# This option holds a command that will execute before needing\n# to reboot to a good known image.\n# (default undefined)\n#SWITCH_TO_GOOD = ssh ${SSH_USER}/${MACHINE} cp good_image ${TARGET_IMAGE}\n\n# The min config that is needed to build for the machine\n# A nice way to create this is with the following:\n#\n#   $ ssh target\n#   $ lsmod > mymods\n#   $ scp mymods host:/tmp\n#   $ exit\n#   $ cd linux.git\n#   $ rm .config\n#   $ make LSMOD=mymods localyesconfig\n#   $ grep '^CONFIG' .config > /home/test/config-min\n#\n# If you want even less configs:\n#\n#   log in directly to target (do not ssh)\n#\n#   $ su\n#   # lsmod | cut -d' ' -f1 | xargs rmmod\n#\n#   repeat the above several times\n#\n#   # lsmod > mymods\n#   # reboot\n#\n# May need to reboot to get your network back to copy the mymods\n# to the host, and then remove the previous .config and run the\n# localyesconfig again. The CONFIG_MIN generated like this will\n# not guarantee network activity to the box so the TEST_TYPE of\n# test may fail.\n#\n# You might also want to set:\n#   CONFIG_CMDLINE=\"<your options here>\"\n#  randconfig may set the above and override your real command\n#  line options.\n# (default undefined)\n#MIN_CONFIG = /home/test/config-min\n\n# Sometimes there's options that just break the boot and\n# you do not care about. Here are a few:\n#   # CONFIG_STAGING is not set\n#  Staging drivers are horrible, and can break the build.\n#   # CONFIG_SCSI_DEBUG is not set\n#  SCSI_DEBUG may change your root partition\n#   # CONFIG_KGDB_SERIAL_CONSOLE is not set\n#  KGDB may cause oops waiting for a connection that's not there.\n# This option points to the file containing config options that will be prepended\n# to the MIN_CONFIG (or be the MIN_CONFIG if it is not set)\n#\n# Note, config options in MIN_CONFIG will override these options.\n#\n# (default undefined)\n#ADD_CONFIG = /home/test/config-broken\n\n# The location on the host where to write temp files\n# (default /tmp/ktest/${MACHINE})\n#TMP_DIR = /tmp/ktest/${MACHINE}\n\n# Optional log file to write the status (recommended)\n#  Note, this is a DEFAULT section only option.\n# (default undefined)\n#LOG_FILE = /home/test/logfiles/target.log\n\n# Remove old logfile if it exists before starting all tests.\n#  Note, this is a DEFAULT section only option.\n# (default 0)\n#CLEAR_LOG = 0\n\n# Line to define a successful boot up in console output.\n# This is what the line contains, not the entire line. If you need\n# the entire line to match, then use regular expression syntax like:\n#  (do not add any quotes around it)\n#\n#  SUCCESS_LINE = ^MyBox Login:$\n#\n# (default \"login:\")\n#SUCCESS_LINE = login:\n\n# To speed up between reboots, defining a line that the\n# default kernel produces that represents that the default\n# kernel has successfully booted and can be used to pass\n# a new test kernel to it. Otherwise ktest.pl will wait till\n# SLEEP_TIME to continue.\n# (default undefined)\n#REBOOT_SUCCESS_LINE = login:\n\n# In case the console constantly fills the screen, having\n# a specified time to stop the test after success is recommended.\n# (in seconds)\n# (default 10)\n#STOP_AFTER_SUCCESS = 10\n\n# In case the console constantly fills the screen, having\n# a specified time to stop the test after failure is recommended.\n# (in seconds)\n# (default 60)\n#STOP_AFTER_FAILURE = 60\n\n# In case the console constantly fills the screen, having\n# a specified time to stop the test if it never succeeds nor fails\n# is recommended.\n# Note: this is ignored if a success or failure is detected.\n# (in seconds)\n# (default 600, -1 is to never stop)\n#STOP_TEST_AFTER = 600\n\n# Stop testing if a build fails. If set, the script will end if\n# a failure is detected, otherwise it will save off the .config,\n# dmesg and bootlog in a directory called\n# MACHINE-TEST_TYPE_BUILD_TYPE-fail-yyyymmddhhmmss\n# if the STORE_FAILURES directory is set.\n# (default 1)\n# Note, even if this is set to zero, there are some errors that still\n# stop the tests.\n#DIE_ON_FAILURE = 1\n\n# Directory to store failure directories on failure. If this is not\n# set, DIE_ON_FAILURE=0 will not save off the .config, dmesg and\n# bootlog. This option is ignored if DIE_ON_FAILURE is not set.\n# (default undefined)\n#STORE_FAILURES = /home/test/failures\n\n# Directory to store success directories on success. If this is not\n# set, the .config, dmesg and bootlog will not be saved if a\n# test succeeds.\n# (default undefined)\n#STORE_SUCCESSES = /home/test/successes\n\n# Build without doing a make mrproper, or removing .config\n# (default 0)\n#BUILD_NOCLEAN = 0\n\n# As the test reads the console, after it hits the SUCCESS_LINE\n# the time it waits for the monitor to settle down between reads\n# can usually be lowered.\n# (in seconds) (default 1)\n#BOOTED_TIMEOUT = 1\n\n# The timeout in seconds when we consider the box hung after\n# the console stop producing output. Be sure to leave enough\n# time here to get pass a reboot. Some machines may not produce\n# any console output for a long time during a reboot. You do\n# not want the test to fail just because the system was in\n# the process of rebooting to the test kernel.\n# (default 120)\n#TIMEOUT = 120\n\n# The timeout in seconds when to test if the box can be rebooted\n# or not. Before issuing the reboot command, a ssh connection\n# is attempted to see if the target machine is still active.\n# If the target does not connect within this timeout, a power cycle\n# is issued instead of a reboot.\n# CONNECT_TIMEOUT = 25\n\n# The timeout in seconds for how long to wait for any running command\n# to timeout. If not defined, it will let it go indefinitely.\n# (default undefined)\n#RUN_TIMEOUT = 600\n\n# In between tests, a reboot of the box may occur, and this\n# is the time to wait for the console after it stops producing\n# output. Some machines may not produce a large lag on reboot\n# so this should accommodate it.\n# The difference between this and TIMEOUT, is that TIMEOUT happens\n# when rebooting to the test kernel. This sleep time happens\n# after a test has completed and we are about to start running\n# another test. If a reboot to the reliable kernel happens,\n# we wait SLEEP_TIME for the console to stop producing output\n# before starting the next test.\n#\n# You can speed up reboot times even more by setting REBOOT_SUCCESS_LINE.\n# (default 60)\n#SLEEP_TIME = 60\n\n# The time in between bisects to sleep (in seconds)\n# (default 60)\n#BISECT_SLEEP_TIME = 60\n\n# The max wait time (in seconds) for waiting for the console to finish.\n# If for some reason, the console is outputting content without\n# ever finishing, this will cause ktest to get stuck. This\n# option is the max time ktest will wait for the monitor (console)\n# to settle down before continuing.\n# (default 1800)\n#MAX_MONITOR_WAIT\n\n# The time in between patch checks to sleep (in seconds)\n# (default 60)\n#PATCHCHECK_SLEEP_TIME = 60\n\n# Reboot the target box on error (default 0)\n#REBOOT_ON_ERROR = 0\n\n# Power off the target on error (ignored if REBOOT_ON_ERROR is set)\n#  Note, this is a DEFAULT section only option.\n# (default 0)\n#POWEROFF_ON_ERROR = 0\n\n# Power off the target after all tests have completed successfully\n#  Note, this is a DEFAULT section only option.\n# (default 0)\n#POWEROFF_ON_SUCCESS = 0\n\n# Reboot the target after all test completed successfully (default 1)\n# (ignored if POWEROFF_ON_SUCCESS is set)\n#REBOOT_ON_SUCCESS = 1\n\n# In case there are issues with rebooting, you can specify this\n# to always powercycle after this amount of time after calling\n# reboot.\n# Note, POWERCYCLE_AFTER_REBOOT = 0 does NOT disable it. It just\n# makes it powercycle immediately after rebooting. Do not define\n# it if you do not want it.\n# (default undefined)\n#POWERCYCLE_AFTER_REBOOT = 5\n\n# In case there's issues with halting, you can specify this\n# to always poweroff after this amount of time after calling\n# halt.\n# Note, POWEROFF_AFTER_HALT = 0 does NOT disable it. It just\n# makes it poweroff immediately after halting. Do not define\n# it if you do not want it.\n# (default undefined)\n#POWEROFF_AFTER_HALT = 20\n\n# A script or command to power off the box (default undefined)\n# Needed for POWEROFF_ON_ERROR and SUCCESS\n#\n# Example for digital loggers power switch:\n#POWER_OFF = wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin@power/outlet?5=OFF'\n#\n# Example for a virtual guest call \"Guest\".\n#POWER_OFF = virsh destroy Guest\n\n# To have the build fail on \"new\" warnings, create a file that\n# contains a list of all known warnings (they must match exactly\n# to the line with 'warning:', 'error:' or 'Error:'. If the option\n# WARNINGS_FILE is set, then that file will be read, and if the\n# build detects a warning, it will examine this file and if the\n# warning does not exist in it, it will fail the build.\n#\n# Note, if this option is defined to a file that does not exist\n# then any warning will fail the build.\n#  (see make_warnings_file below)\n#\n# (optional, default undefined)\n#WARNINGS_FILE = ${OUTPUT_DIR}/warnings_file\n\n# The way to execute a command on the target\n# (default ssh $SSH_USER@$MACHINE $SSH_COMMAND\";)\n# The variables SSH_USER, MACHINE and SSH_COMMAND are defined\n#SSH_EXEC = ssh $SSH_USER@$MACHINE $SSH_COMMAND\";\n\n# The way to copy a file to the target (install and modules)\n# (default scp $SRC_FILE $SSH_USER@$MACHINE:$DST_FILE)\n# The variables SSH_USER, MACHINE are defined by the config\n# SRC_FILE and DST_FILE are ktest internal variables and\n# should only have '$' and not the '${}' notation.\n# (default scp $SRC_FILE ${SSH_USER}@${MACHINE}:$DST_FILE)\n#SCP_TO_TARGET = echo skip scp for $SRC_FILE $DST_FILE\n\n# If install needs to be different than modules, then this\n# option will override the SCP_TO_TARGET for installation.\n# (default ${SCP_TO_TARGET} )\n#SCP_TO_TARGET_INSTALL = scp $SRC_FILE tftp@tftpserver:$DST_FILE\n\n# The nice way to reboot the target\n# (default ssh $SSH_USER@$MACHINE reboot)\n# The variables SSH_USER and MACHINE are defined.\n#REBOOT = ssh $SSH_USER@$MACHINE reboot\n\n# The return code of REBOOT\n# (default 255)\n#REBOOT_RETURN_CODE = 255\n\n# The way triple faults are detected is by testing the kernel\n# banner. If the kernel banner for the kernel we are testing is\n# found, and then later a kernel banner for another kernel version\n# is found, it is considered that we encountered a triple fault,\n# and there is no panic or callback, but simply a reboot.\n# To disable this (because it did a false positive) set the following\n# to 0.\n# (default 1)\n#DETECT_TRIPLE_FAULT = 0\n\n# All options in the config file should be either used by ktest\n# or could be used within a value of another option. If an option\n# in the config file is not used, ktest will warn about it and ask\n# if you want to continue.\n#\n# If you don't care if there are non-used options, enable this\n# option. Be careful though, a non-used option is usually a sign\n# of an option name being typed incorrectly.\n# (default 0)\n#IGNORE_UNUSED = 1\n\n# When testing a kernel that happens to have WARNINGs, and call\n# traces, ktest.pl will detect these and fail a boot or test run\n# due to warnings. By setting this option, ktest will ignore\n# call traces, and will not fail a test if the kernel produces\n# an oops. Use this option with care.\n# (default 0)\n#IGNORE_ERRORS = 1\n\n#### Per test run options ####\n# The following options are only allowed in TEST_START sections.\n# They are ignored in the DEFAULTS sections.\n#\n# All of these are optional and undefined by default, although\n#  some of these options are required for TEST_TYPE of patchcheck\n#  and bisect.\n#\n#\n# CHECKOUT = branch\n#\n#  If the BUILD_DIR is a git repository, then you can set this option\n#  to checkout the given branch before running the TEST. If you\n#  specify this for the first run, that branch will be used for\n#  all preceding tests until a new CHECKOUT is set.\n#\n#\n# TEST_NAME = name\n#\n#  If you want the test to have a name that is displayed in\n#  the test result banner at the end of the test, then use this\n#  option. This is useful to search for the RESULT keyword and\n#  not have to translate a test number to a test in the config.\n#\n# For TEST_TYPE = patchcheck\n#\n#  This expects the BUILD_DIR to be a git repository, and\n#  will checkout the PATCHCHECK_START commit.\n#\n#  The option BUILD_TYPE will be ignored.\n#\n#  The MIN_CONFIG will be used for all builds of the patchcheck. The build type\n#  used for patchcheck is oldconfig.\n#\n#  PATCHCHECK_START is required and is the first patch to\n#   test (the SHA1 of the commit). You may also specify anything\n#   that git checkout allows (branch name, tag, HEAD~3).\n#\n#  PATCHCHECK_END is the last patch to check (default HEAD)\n#\n#  PATCHCHECK_CHERRY if set to non zero, then git cherry will be\n#      performed against PATCHCHECK_START and PATCHCHECK_END. That is\n#\n#      git cherry ${PATCHCHECK_START} ${PATCHCHECK_END}\n#\n#      Then the changes found will be tested.\n#\n#      Note, PATCHCHECK_CHERRY requires PATCHCHECK_END to be defined.\n#      (default 0)\n#\n#  PATCHCHECK_TYPE is required and is the type of test to run:\n#      build, boot, test.\n#\n#   Note, the build test will look for warnings, if a warning occurred\n#     in a file that a commit touches, the build will fail, unless\n#     IGNORE_WARNINGS is set for the given commit's sha1\n#\n#   IGNORE_WARNINGS can be used to disable the failure of patchcheck\n#     on a particular commit (SHA1). You can add more than one commit\n#     by adding a list of SHA1s that are space delimited.\n#\n#   If BUILD_NOCLEAN is set, then make mrproper will not be run on\n#   any of the builds, just like all other TEST_TYPE tests. But\n#   what makes patchcheck different from the other tests, is if\n#   BUILD_NOCLEAN is not set, only the first and last patch run\n#   make mrproper. This helps speed up the test.\n#\n# Example:\n#   TEST_START\n#   TEST_TYPE = patchcheck\n#   CHECKOUT = mybranch\n#   PATCHCHECK_TYPE = boot\n#   PATCHCHECK_START = 747e94ae3d1b4c9bf5380e569f614eb9040b79e7\n#   PATCHCHECK_END = HEAD~2\n#   IGNORE_WARNINGS = 42f9c6b69b54946ffc0515f57d01dc7f5c0e4712 0c17ca2c7187f431d8ffc79e81addc730f33d128\n#\n#\n#\n# For TEST_TYPE = bisect\n#\n#  You can specify a git bisect if the BUILD_DIR is a git repository.\n#  The MIN_CONFIG will be used for all builds of the bisect. The build type\n#  used for bisecting is oldconfig.\n#\n#  The option BUILD_TYPE will be ignored.\n#\n#  BISECT_TYPE is the type of test to perform:\n#\tbuild\t- bad fails to build\n#\tboot\t- bad builds but fails to boot\n#\ttest\t- bad boots but fails a test\n#\n# BISECT_GOOD is the commit (SHA1) to label as good (accepts all git good commit types)\n# BISECT_BAD is the commit to label as bad (accepts all git bad commit types)\n#\n# The above three options are required for a bisect operation.\n#\n# BISECT_REPLAY = /path/to/replay/file (optional, default undefined)\n#\n#   If an operation failed in the bisect that was not expected to\n#   fail. Then the test ends. The state of the BUILD_DIR will be\n#   left off at where the failure occurred. You can examine the\n#   reason for the failure, and perhaps even find a git commit\n#   that would work to continue with. You can run:\n#\n#   git bisect log > /path/to/replay/file\n#\n#   The adding:\n#\n#    BISECT_REPLAY= /path/to/replay/file\n#\n#   And running the test again. The test will perform the initial\n#    git bisect start, git bisect good, and git bisect bad, and\n#    then it will run git bisect replay on this file, before\n#    continuing with the bisect.\n#\n# BISECT_START = commit (optional, default undefined)\n#\n#   As with BISECT_REPLAY, if the test failed on a commit that\n#   just happen to have a bad commit in the middle of the bisect,\n#   and you need to skip it. If BISECT_START is defined, it\n#   will checkout that commit after doing the initial git bisect start,\n#   git bisect good, git bisect bad, and running the git bisect replay\n#   if the BISECT_REPLAY is set.\n#\n# BISECT_SKIP = 1 (optional, default 0)\n#\n#   If BISECT_TYPE is set to test but the build fails, ktest will\n#   simply fail the test and end their. You could use BISECT_REPLAY\n#   and BISECT_START to resume after you found a new starting point,\n#   or you could set BISECT_SKIP to 1. If BISECT_SKIP is set to 1,\n#   when something other than the BISECT_TYPE fails, ktest.pl will\n#   run \"git bisect skip\" and try again.\n#\n# BISECT_FILES = <path> (optional, default undefined)\n#\n#   To just run the git bisect on a specific path, set BISECT_FILES.\n#   For example:\n#\n#     BISECT_FILES = arch/x86 kernel/time\n#\n#   Will run the bisect with \"git bisect start -- arch/x86 kernel/time\"\n#\n# BISECT_REVERSE = 1 (optional, default 0)\n#\n#   In those strange instances where it was broken forever\n#   and you are trying to find where it started to work!\n#   Set BISECT_GOOD to the commit that was last known to fail\n#   Set BISECT_BAD to the commit that is known to start working.\n#   With BISECT_REVERSE = 1, The test will consider failures as\n#   good, and success as bad.\n#\n# BISECT_MANUAL = 1 (optional, default 0)\n#\n#   In case there's a problem with automating the bisect for\n#   whatever reason. (Can't reboot, want to inspect each iteration)\n#   Doing a BISECT_MANUAL will have the test wait for you to\n#   tell it if the test passed or failed after each iteration.\n#   This is basically the same as running git bisect yourself\n#   but ktest will rebuild and install the kernel for you.\n#\n# BISECT_CHECK = 1 (optional, default 0)\n#\n#   Just to be sure the good is good and bad is bad, setting\n#   BISECT_CHECK to 1 will start the bisect by first checking\n#   out BISECT_BAD and makes sure it fails, then it will check\n#   out BISECT_GOOD and makes sure it succeeds before starting\n#   the bisect (it works for BISECT_REVERSE too).\n#\n#   You can limit the test to just check BISECT_GOOD or\n#   BISECT_BAD with BISECT_CHECK = good or\n#   BISECT_CHECK = bad, respectively.\n#\n# BISECT_TRIES = 5 (optional, default 1)\n#\n#   For those cases that it takes several tries to hit a bug,\n#   the BISECT_TRIES is useful. It is the number of times the\n#   test is ran before it says the kernel is good. The first failure\n#   will stop trying and mark the current SHA1 as bad.\n#\n#   Note, as with all race bugs, there's no guarantee that if\n#   it succeeds, it is really a good bisect. But it helps in case\n#   the bug is some what reliable.\n#\n#   You can set BISECT_TRIES to zero, and all tests will be considered\n#   good, unless you also set BISECT_MANUAL.\n#\n# BISECT_RET_GOOD = 0 (optional, default undefined)\n#\n#   In case the specificed test returns something other than just\n#   0 for good, and non-zero for bad, you can override 0 being\n#   good by defining BISECT_RET_GOOD.\n#\n# BISECT_RET_BAD = 1 (optional, default undefined)\n#\n#   In case the specificed test returns something other than just\n#   0 for good, and non-zero for bad, you can override non-zero being\n#   bad by defining BISECT_RET_BAD.\n#\n# BISECT_RET_ABORT = 255 (optional, default undefined)\n#\n#   If you need to abort the bisect if the test discovers something\n#   that was wrong, you can define BISECT_RET_ABORT to be the error\n#   code returned by the test in order to abort the bisect.\n#\n# BISECT_RET_SKIP = 2 (optional, default undefined)\n#\n#   If the test detects that the current commit is neither good\n#   nor bad, but something else happened (another bug detected)\n#   you can specify BISECT_RET_SKIP to an error code that the\n#   test returns when it should skip the current commit.\n#\n# BISECT_RET_DEFAULT = good (optional, default undefined)\n#\n#   You can override the default of what to do when the above\n#   options are not hit. This may be one of, \"good\", \"bad\",\n#   \"abort\" or \"skip\" (without the quotes).\n#\n#   Note, if you do not define any of the previous BISECT_RET_*\n#   and define BISECT_RET_DEFAULT, all bisects results will do\n#   what the BISECT_RET_DEFAULT has.\n#\n#\n# Example:\n#   TEST_START\n#   TEST_TYPE = bisect\n#   BISECT_GOOD = v2.6.36\n#   BISECT_BAD = b5153163ed580e00c67bdfecb02b2e3843817b3e\n#   BISECT_TYPE = build\n#   MIN_CONFIG = /home/test/config-bisect\n#\n#\n#\n# For TEST_TYPE = config_bisect\n#\n#  In those cases that you have two different configs. One of them\n#  work, the other does not, and you do not know what config causes\n#  the problem.\n#  The TEST_TYPE config_bisect will bisect the bad config looking for\n#  what config causes the failure.\n#\n#  The way it works is this:\n#\n#   You can specify a good config with CONFIG_BISECT_GOOD, otherwise it\n#   will use the MIN_CONFIG, and if that's not specified, it will use\n#   the config that comes with \"make defconfig\".\n#\n#   It runs both the good and bad configs through a make oldconfig to\n#   make sure that they are set up for the kernel that is checked out.\n#\n#   It then reads the configs that are set, as well as the ones that are\n#   not set for both the good and bad configs, and then compares them.\n#   It will set half of the good configs within the bad config (note,\n#   \"set\" means to make the bad config match the good config, a config\n#   in the good config that is off, will be turned off in the bad\n#   config. That is considered a \"set\").\n#\n#   It tests this new config and if it works, it becomes the new good\n#   config, otherwise it becomes the new bad config. It continues this\n#   process until there's only one config left and it will report that\n#   config.\n#\n#   The \"bad config\" can also be a config that is needed to boot but was\n#   disabled because it depended on something that wasn't set.\n#\n#   During this process, it saves the current good and bad configs in\n#   ${TMP_DIR}/good_config and ${TMP_DIR}/bad_config respectively.\n#   If you stop the test, you can copy them to a new location to\n#   reuse them again.\n#\n#   Although the MIN_CONFIG may be the config it starts with, the\n#   MIN_CONFIG is ignored.\n#\n#  The option BUILD_TYPE will be ignored.\n#\n#  CONFIG_BISECT_TYPE is the type of test to perform:\n#\tbuild\t- bad fails to build\n#\tboot\t- bad builds but fails to boot\n#\ttest\t- bad boots but fails a test\n#\n#  CONFIG_BISECT is the config that failed to boot\n#\n#  If BISECT_MANUAL is set, it will pause between iterations.\n#  This is useful to use just ktest.pl just for the config bisect.\n#  If you set it to build, it will run the bisect and you can\n#  control what happens in between iterations. It will ask you if\n#  the test succeeded or not and continue the config bisect.\n#\n# CONFIG_BISECT_GOOD (optional)\n#  If you have a good config to start with, then you\n#  can specify it with CONFIG_BISECT_GOOD. Otherwise\n#  the MIN_CONFIG is the base, if MIN_CONFIG is not set\n#  It will build a config with \"make defconfig\"\n#\n# CONFIG_BISECT_CHECK (optional)\n#  Set this to 1 if you want to confirm that the config ktest\n#  generates (the bad config with the min config) is still bad.\n#  It may be that the min config fixes what broke the bad config\n#  and the test will not return a result.\n#  Set it to \"good\" to test only the good config and set it\n#  to \"bad\" to only test the bad config.\n#\n# CONFIG_BISECT_EXEC (optional)\n#  The config bisect is a separate program that comes with ktest.pl.\n#  By default, it will look for:\n#    `pwd`/config-bisect.pl # the location ktest.pl was executed from.\n#  If it does not find it there, it will look for:\n#    `dirname <ktest.pl>`/config-bisect.pl # The directory that holds ktest.pl\n#  If it does not find it there, it will look for:\n#    ${BUILD_DIR}/tools/testing/ktest/config-bisect.pl\n#  Setting CONFIG_BISECT_EXEC will override where it looks.\n#\n# Example:\n#   TEST_START\n#   TEST_TYPE = config_bisect\n#   CONFIG_BISECT_TYPE = build\n#   CONFIG_BISECT = /home/test/config-bad\n#   MIN_CONFIG = /home/test/config-min\n#   BISECT_MANUAL = 1\n#\n#\n#\n# For TEST_TYPE = make_min_config\n#\n#  After doing a make localyesconfig, your kernel configuration may\n#  not be the most useful minimum configuration. Having a true minimum\n#  config that you can use against other configs is very useful if\n#  someone else has a config that breaks on your code. By only forcing\n#  those configurations that are truly required to boot your machine\n#  will give you less of a chance that one of your set configurations\n#  will make the bug go away. This will give you a better chance to\n#  be able to reproduce the reported bug matching the broken config.\n#\n#  Note, this does take some time, and may require you to run the\n#  test over night, or perhaps over the weekend. But it also allows\n#  you to interrupt it, and gives you the current minimum config\n#  that was found till that time.\n#\n#  Note, this test automatically assumes a BUILD_TYPE of oldconfig\n#  and its test type acts like boot.\n#  TODO: add a test version that makes the config do more than just\n#   boot, like having network access.\n#\n#  To save time, the test does not just grab any option and test\n#  it. The Kconfig files are examined to determine the dependencies\n#  of the configs. If a config is chosen that depends on another\n#  config, that config will be checked first. By checking the\n#  parents first, we can eliminate whole groups of configs that\n#  may have been enabled.\n#\n#  For example, if a USB device config is chosen and depends on CONFIG_USB,\n#  the CONFIG_USB will be tested before the device. If CONFIG_USB is\n#  found not to be needed, it, as well as all configs that depend on\n#  it, will be disabled and removed from the current min_config.\n#\n#  OUTPUT_MIN_CONFIG is the path and filename of the file that will\n#   be created from the MIN_CONFIG. If you interrupt the test, set\n#   this file as your new min config, and use it to continue the test.\n#   This file does not need to exist on start of test.\n#   This file is not created until a config is found that can be removed.\n#   If this file exists, you will be prompted if you want to use it\n#   as the min_config (overriding MIN_CONFIG) if START_MIN_CONFIG\n#   is not defined.\n#   (required field)\n#\n#  START_MIN_CONFIG is the config to use to start the test with.\n#   you can set this as the same OUTPUT_MIN_CONFIG, but if you do\n#   the OUTPUT_MIN_CONFIG file must exist.\n#   (default MIN_CONFIG)\n#\n#  IGNORE_CONFIG is used to specify a config file that has configs that\n#   you already know must be set. Configs are written here that have\n#   been tested and proved to be required. It is best to define this\n#   file if you intend on interrupting the test and running it where\n#   it left off. New configs that it finds will be written to this file\n#   and will not be tested again in later runs.\n#   (optional)\n#\n#  MIN_CONFIG_TYPE can be either 'boot' or 'test'. With 'boot' it will\n#   test if the created config can just boot the machine. If this is\n#   set to 'test', then the TEST option must be defined and the created\n#   config will not only boot the target, but also make sure that the\n#   config lets the test succeed. This is useful to make sure the final\n#   config that is generated allows network activity (ssh).\n#   (optional)\n#\n#  USE_OUTPUT_MIN_CONFIG set this to 1 if you do not want to be prompted\n#   about using the OUTPUT_MIN_CONFIG as the MIN_CONFIG as the starting\n#   point. Set it to 0 if you want to always just use the given MIN_CONFIG.\n#   If it is not defined, it will prompt you to pick which config\n#   to start with (MIN_CONFIG or OUTPUT_MIN_CONFIG).\n#\n# Example:\n#\n#  TEST_TYPE = make_min_config\n#  OUTPUT_MIN_CONFIG = /path/to/config-new-min\n#  START_MIN_CONFIG = /path/to/config-min\n#  IGNORE_CONFIG = /path/to/config-tested\n#  MIN_CONFIG_TYPE = test\n#  TEST = ssh ${USER}@${MACHINE} echo hi\n#\n#\n#\n#\n# For TEST_TYPE = make_warnings_file\n#\n# If you want the build to fail when a new warning is discovered\n# you set the WARNINGS_FILE to point to a file of known warnings.\n#\n# The test \"make_warnings_file\" will let you create a new warnings\n# file before you run other tests, like patchcheck.\n#\n# What this test does is to run just a build, you still need to\n# specify BUILD_TYPE to tell the test what type of config to use.\n# A BUILD_TYPE of nobuild will fail this test.\n#\n# The test will do the build and scan for all warnings. Any warning\n# it discovers will be saved in the WARNINGS_FILE (required) option.\n#\n# It is recommended (but not necessary) to make sure BUILD_NOCLEAN is\n# off, so that a full build is done (make mrproper is performed).\n# That way, all warnings will be captured.\n#\n# Example:\n#\n#  TEST_TYPE = make_warnings_file\n#  WARNINGS_FILE = ${OUTPUT_DIR}\n#  BUILD_TYPE = useconfig:oldconfig\n#  CHECKOUT = v3.8\n#  BUILD_NOCLEAN = 0\n#\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}