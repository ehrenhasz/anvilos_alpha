{
  "module_name": "ktest.pl",
  "hash_id": "68f123e52f3aaf42b45dcaf090559ebd23a4a414cd6b132e6a0b9fc6e4a507db",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/ktest/ktest.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright 2010 - Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.\n#\n\nuse strict;\nuse IPC::Open2;\nuse Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);\nuse File::Path qw(mkpath);\nuse File::Copy qw(cp);\nuse FileHandle;\nuse FindBin;\nuse IO::Handle;\n\nmy $VERSION = \"0.2\";\n\n$| = 1;\n\nmy %opt;\nmy %repeat_tests;\nmy %repeats;\nmy %evals;\n\n#default opts\nmy %default = (\n    \"MAILER\"\t\t\t=> \"sendmail\",\t# default mailer\n    \"EMAIL_ON_ERROR\"\t\t=> 1,\n    \"EMAIL_WHEN_FINISHED\"\t=> 1,\n    \"EMAIL_WHEN_CANCELED\"\t=> 0,\n    \"EMAIL_WHEN_STARTED\"\t=> 0,\n    \"NUM_TESTS\"\t\t\t=> 1,\n    \"TEST_TYPE\"\t\t\t=> \"build\",\n    \"BUILD_TYPE\"\t\t=> \"oldconfig\",\n    \"MAKE_CMD\"\t\t\t=> \"make\",\n    \"CLOSE_CONSOLE_SIGNAL\"\t=> \"INT\",\n    \"TIMEOUT\"\t\t\t=> 120,\n    \"TMP_DIR\"\t\t\t=> \"/tmp/ktest/\\${MACHINE}\",\n    \"SLEEP_TIME\"\t\t=> 60,\t\t# sleep time between tests\n    \"BUILD_NOCLEAN\"\t\t=> 0,\n    \"REBOOT_ON_ERROR\"\t\t=> 0,\n    \"POWEROFF_ON_ERROR\"\t\t=> 0,\n    \"REBOOT_ON_SUCCESS\"\t\t=> 1,\n    \"POWEROFF_ON_SUCCESS\"\t=> 0,\n    \"BUILD_OPTIONS\"\t\t=> \"\",\n    \"BISECT_SLEEP_TIME\"\t\t=> 60,\t\t# sleep time between bisects\n    \"PATCHCHECK_SLEEP_TIME\"\t=> 60, \t\t# sleep time between patch checks\n    \"CLEAR_LOG\"\t\t\t=> 0,\n    \"BISECT_MANUAL\"\t\t=> 0,\n    \"BISECT_SKIP\"\t\t=> 1,\n    \"BISECT_TRIES\"\t\t=> 1,\n    \"MIN_CONFIG_TYPE\"\t\t=> \"boot\",\n    \"SUCCESS_LINE\"\t\t=> \"login:\",\n    \"DETECT_TRIPLE_FAULT\"\t=> 1,\n    \"NO_INSTALL\"\t\t=> 0,\n    \"BOOTED_TIMEOUT\"\t\t=> 1,\n    \"DIE_ON_FAILURE\"\t\t=> 1,\n    \"SSH_EXEC\"\t\t\t=> \"ssh \\$SSH_USER\\@\\$MACHINE \\$SSH_COMMAND\",\n    \"SCP_TO_TARGET\"\t\t=> \"scp \\$SRC_FILE \\$SSH_USER\\@\\$MACHINE:\\$DST_FILE\",\n    \"SCP_TO_TARGET_INSTALL\"\t=> \"\\${SCP_TO_TARGET}\",\n    \"REBOOT\"\t\t\t=> \"ssh \\$SSH_USER\\@\\$MACHINE reboot\",\n    \"REBOOT_RETURN_CODE\"\t=> 255,\n    \"STOP_AFTER_SUCCESS\"\t=> 10,\n    \"STOP_AFTER_FAILURE\"\t=> 60,\n    \"STOP_TEST_AFTER\"\t\t=> 600,\n    \"MAX_MONITOR_WAIT\"\t\t=> 1800,\n    \"GRUB_REBOOT\"\t\t=> \"grub2-reboot\",\n    \"GRUB_BLS_GET\"\t\t=> \"grubby --info=ALL\",\n    \"SYSLINUX\"\t\t\t=> \"extlinux\",\n    \"SYSLINUX_PATH\"\t\t=> \"/boot/extlinux\",\n    \"CONNECT_TIMEOUT\"\t\t=> 25,\n\n# required, and we will ask users if they don't have them but we keep the default\n# value something that is common.\n    \"REBOOT_TYPE\"\t\t=> \"grub\",\n    \"LOCALVERSION\"\t\t=> \"-test\",\n    \"SSH_USER\"\t\t\t=> \"root\",\n    \"BUILD_TARGET\"\t \t=> \"arch/x86/boot/bzImage\",\n    \"TARGET_IMAGE\"\t\t=> \"/boot/vmlinuz-test\",\n\n    \"LOG_FILE\"\t\t\t=> undef,\n    \"IGNORE_UNUSED\"\t\t=> 0,\n);\n\nmy $test_log_start = 0;\n\nmy $ktest_config = \"ktest.conf\";\nmy $version;\nmy $have_version = 0;\nmy $machine;\nmy $last_machine;\nmy $ssh_user;\nmy $tmpdir;\nmy $builddir;\nmy $outputdir;\nmy $output_config;\nmy $test_type;\nmy $build_type;\nmy $build_options;\nmy $final_post_ktest;\nmy $pre_ktest;\nmy $post_ktest;\nmy $pre_test;\nmy $pre_test_die;\nmy $post_test;\nmy $pre_build;\nmy $post_build;\nmy $pre_build_die;\nmy $post_build_die;\nmy $reboot_type;\nmy $reboot_script;\nmy $power_cycle;\nmy $reboot;\nmy $reboot_return_code;\nmy $reboot_on_error;\nmy $switch_to_good;\nmy $switch_to_test;\nmy $poweroff_on_error;\nmy $reboot_on_success;\nmy $die_on_failure;\nmy $powercycle_after_reboot;\nmy $poweroff_after_halt;\nmy $max_monitor_wait;\nmy $ssh_exec;\nmy $scp_to_target;\nmy $scp_to_target_install;\nmy $power_off;\nmy $grub_menu;\nmy $last_grub_menu;\nmy $grub_file;\nmy $grub_number;\nmy $grub_reboot;\nmy $grub_bls_get;\nmy $syslinux;\nmy $syslinux_path;\nmy $syslinux_label;\nmy $target;\nmy $make;\nmy $pre_install;\nmy $post_install;\nmy $no_install;\nmy $noclean;\nmy $minconfig;\nmy $start_minconfig;\nmy $start_minconfig_defined;\nmy $output_minconfig;\nmy $minconfig_type;\nmy $use_output_minconfig;\nmy $warnings_file;\nmy $ignore_config;\nmy $ignore_errors;\nmy $addconfig;\nmy $in_bisect = 0;\nmy $bisect_bad_commit = \"\";\nmy $reverse_bisect;\nmy $bisect_manual;\nmy $bisect_skip;\nmy $bisect_tries;\nmy $config_bisect_good;\nmy $bisect_ret_good;\nmy $bisect_ret_bad;\nmy $bisect_ret_skip;\nmy $bisect_ret_abort;\nmy $bisect_ret_default;\nmy $in_patchcheck = 0;\nmy $run_test;\nmy $buildlog;\nmy $testlog;\nmy $dmesg;\nmy $monitor_fp;\nmy $monitor_pid;\nmy $monitor_cnt = 0;\nmy $sleep_time;\nmy $bisect_sleep_time;\nmy $patchcheck_sleep_time;\nmy $ignore_warnings;\nmy $store_failures;\nmy $store_successes;\nmy $test_name;\nmy $timeout;\nmy $run_timeout;\nmy $connect_timeout;\nmy $config_bisect_exec;\nmy $booted_timeout;\nmy $detect_triplefault;\nmy $console;\nmy $close_console_signal;\nmy $reboot_success_line;\nmy $success_line;\nmy $stop_after_success;\nmy $stop_after_failure;\nmy $stop_test_after;\nmy $build_target;\nmy $target_image;\nmy $checkout;\nmy $localversion;\nmy $iteration = 0;\nmy $successes = 0;\nmy $stty_orig;\nmy $run_command_status = 0;\n\nmy $bisect_good;\nmy $bisect_bad;\nmy $bisect_type;\nmy $bisect_start;\nmy $bisect_replay;\nmy $bisect_files;\nmy $bisect_reverse;\nmy $bisect_check;\n\nmy $config_bisect;\nmy $config_bisect_type;\nmy $config_bisect_check;\n\nmy $patchcheck_type;\nmy $patchcheck_start;\nmy $patchcheck_cherry;\nmy $patchcheck_end;\n\nmy $build_time;\nmy $install_time;\nmy $reboot_time;\nmy $test_time;\n\nmy $pwd;\nmy $dirname = $FindBin::Bin;\n\nmy $mailto;\nmy $mailer;\nmy $mail_path;\nmy $mail_max_size;\nmy $mail_command;\nmy $email_on_error;\nmy $email_when_finished;\nmy $email_when_started;\nmy $email_when_canceled;\n\nmy $script_start_time = localtime();\n\n# set when a test is something other that just building or install\n# which would require more options.\nmy $buildonly = 1;\n\n# tell build not to worry about warnings, even when WARNINGS_FILE is set\nmy $warnings_ok = 0;\n\n# set when creating a new config\nmy $newconfig = 0;\n\nmy %entered_configs;\nmy %config_help;\nmy %variable;\n\n# force_config is the list of configs that we force enabled (or disabled)\n# in a .config file. The MIN_CONFIG and ADD_CONFIG configs.\nmy %force_config;\n\n# do not force reboots on config problems\nmy $no_reboot = 1;\n\n# reboot on success\nmy $reboot_success = 0;\n\nmy %option_map = (\n    \"MAILTO\"\t\t\t=> \\$mailto,\n    \"MAILER\"\t\t\t=> \\$mailer,\n    \"MAIL_PATH\"\t\t\t=> \\$mail_path,\n    \"MAIL_MAX_SIZE\"\t\t=> \\$mail_max_size,\n    \"MAIL_COMMAND\"\t\t=> \\$mail_command,\n    \"EMAIL_ON_ERROR\"\t\t=> \\$email_on_error,\n    \"EMAIL_WHEN_FINISHED\"\t=> \\$email_when_finished,\n    \"EMAIL_WHEN_STARTED\"\t=> \\$email_when_started,\n    \"EMAIL_WHEN_CANCELED\"\t=> \\$email_when_canceled,\n    \"MACHINE\"\t\t\t=> \\$machine,\n    \"SSH_USER\"\t\t\t=> \\$ssh_user,\n    \"TMP_DIR\"\t\t\t=> \\$tmpdir,\n    \"OUTPUT_DIR\"\t\t=> \\$outputdir,\n    \"BUILD_DIR\"\t\t\t=> \\$builddir,\n    \"TEST_TYPE\"\t\t\t=> \\$test_type,\n    \"PRE_KTEST\"\t\t\t=> \\$pre_ktest,\n    \"POST_KTEST\"\t\t=> \\$post_ktest,\n    \"PRE_TEST\"\t\t\t=> \\$pre_test,\n    \"PRE_TEST_DIE\"\t\t=> \\$pre_test_die,\n    \"POST_TEST\"\t\t\t=> \\$post_test,\n    \"BUILD_TYPE\"\t\t=> \\$build_type,\n    \"BUILD_OPTIONS\"\t\t=> \\$build_options,\n    \"PRE_BUILD\"\t\t\t=> \\$pre_build,\n    \"POST_BUILD\"\t\t=> \\$post_build,\n    \"PRE_BUILD_DIE\"\t\t=> \\$pre_build_die,\n    \"POST_BUILD_DIE\"\t\t=> \\$post_build_die,\n    \"POWER_CYCLE\"\t\t=> \\$power_cycle,\n    \"REBOOT\"\t\t\t=> \\$reboot,\n    \"REBOOT_RETURN_CODE\"\t=> \\$reboot_return_code,\n    \"BUILD_NOCLEAN\"\t\t=> \\$noclean,\n    \"MIN_CONFIG\"\t\t=> \\$minconfig,\n    \"OUTPUT_MIN_CONFIG\"\t\t=> \\$output_minconfig,\n    \"START_MIN_CONFIG\"\t\t=> \\$start_minconfig,\n    \"MIN_CONFIG_TYPE\"\t\t=> \\$minconfig_type,\n    \"USE_OUTPUT_MIN_CONFIG\"\t=> \\$use_output_minconfig,\n    \"WARNINGS_FILE\"\t\t=> \\$warnings_file,\n    \"IGNORE_CONFIG\"\t\t=> \\$ignore_config,\n    \"TEST\"\t\t\t=> \\$run_test,\n    \"ADD_CONFIG\"\t\t=> \\$addconfig,\n    \"REBOOT_TYPE\"\t\t=> \\$reboot_type,\n    \"GRUB_MENU\"\t\t\t=> \\$grub_menu,\n    \"GRUB_FILE\"\t\t\t=> \\$grub_file,\n    \"GRUB_REBOOT\"\t\t=> \\$grub_reboot,\n    \"GRUB_BLS_GET\"\t\t=> \\$grub_bls_get,\n    \"SYSLINUX\"\t\t\t=> \\$syslinux,\n    \"SYSLINUX_PATH\"\t\t=> \\$syslinux_path,\n    \"SYSLINUX_LABEL\"\t\t=> \\$syslinux_label,\n    \"PRE_INSTALL\"\t\t=> \\$pre_install,\n    \"POST_INSTALL\"\t\t=> \\$post_install,\n    \"NO_INSTALL\"\t\t=> \\$no_install,\n    \"REBOOT_SCRIPT\"\t\t=> \\$reboot_script,\n    \"REBOOT_ON_ERROR\"\t\t=> \\$reboot_on_error,\n    \"SWITCH_TO_GOOD\"\t\t=> \\$switch_to_good,\n    \"SWITCH_TO_TEST\"\t\t=> \\$switch_to_test,\n    \"POWEROFF_ON_ERROR\"\t\t=> \\$poweroff_on_error,\n    \"REBOOT_ON_SUCCESS\"\t\t=> \\$reboot_on_success,\n    \"DIE_ON_FAILURE\"\t\t=> \\$die_on_failure,\n    \"POWER_OFF\"\t\t\t=> \\$power_off,\n    \"POWERCYCLE_AFTER_REBOOT\"\t=> \\$powercycle_after_reboot,\n    \"POWEROFF_AFTER_HALT\"\t=> \\$poweroff_after_halt,\n    \"MAX_MONITOR_WAIT\"\t\t=> \\$max_monitor_wait,\n    \"SLEEP_TIME\"\t\t=> \\$sleep_time,\n    \"BISECT_SLEEP_TIME\"\t\t=> \\$bisect_sleep_time,\n    \"PATCHCHECK_SLEEP_TIME\"\t=> \\$patchcheck_sleep_time,\n    \"IGNORE_WARNINGS\"\t\t=> \\$ignore_warnings,\n    \"IGNORE_ERRORS\"\t\t=> \\$ignore_errors,\n    \"BISECT_MANUAL\"\t\t=> \\$bisect_manual,\n    \"BISECT_SKIP\"\t\t=> \\$bisect_skip,\n    \"BISECT_TRIES\"\t\t=> \\$bisect_tries,\n    \"CONFIG_BISECT_GOOD\"\t=> \\$config_bisect_good,\n    \"BISECT_RET_GOOD\"\t\t=> \\$bisect_ret_good,\n    \"BISECT_RET_BAD\"\t\t=> \\$bisect_ret_bad,\n    \"BISECT_RET_SKIP\"\t\t=> \\$bisect_ret_skip,\n    \"BISECT_RET_ABORT\"\t\t=> \\$bisect_ret_abort,\n    \"BISECT_RET_DEFAULT\"\t=> \\$bisect_ret_default,\n    \"STORE_FAILURES\"\t\t=> \\$store_failures,\n    \"STORE_SUCCESSES\"\t\t=> \\$store_successes,\n    \"TEST_NAME\"\t\t\t=> \\$test_name,\n    \"TIMEOUT\"\t\t\t=> \\$timeout,\n    \"RUN_TIMEOUT\"\t\t=> \\$run_timeout,\n    \"CONNECT_TIMEOUT\"\t\t=> \\$connect_timeout,\n    \"CONFIG_BISECT_EXEC\"\t=> \\$config_bisect_exec,\n    \"BOOTED_TIMEOUT\"\t\t=> \\$booted_timeout,\n    \"CONSOLE\"\t\t\t=> \\$console,\n    \"CLOSE_CONSOLE_SIGNAL\"\t=> \\$close_console_signal,\n    \"DETECT_TRIPLE_FAULT\"\t=> \\$detect_triplefault,\n    \"SUCCESS_LINE\"\t\t=> \\$success_line,\n    \"REBOOT_SUCCESS_LINE\"\t=> \\$reboot_success_line,\n    \"STOP_AFTER_SUCCESS\"\t=> \\$stop_after_success,\n    \"STOP_AFTER_FAILURE\"\t=> \\$stop_after_failure,\n    \"STOP_TEST_AFTER\"\t\t=> \\$stop_test_after,\n    \"BUILD_TARGET\"\t\t=> \\$build_target,\n    \"SSH_EXEC\"\t\t\t=> \\$ssh_exec,\n    \"SCP_TO_TARGET\"\t\t=> \\$scp_to_target,\n    \"SCP_TO_TARGET_INSTALL\"\t=> \\$scp_to_target_install,\n    \"CHECKOUT\"\t\t\t=> \\$checkout,\n    \"TARGET_IMAGE\"\t\t=> \\$target_image,\n    \"LOCALVERSION\"\t\t=> \\$localversion,\n\n    \"BISECT_GOOD\"\t\t=> \\$bisect_good,\n    \"BISECT_BAD\"\t\t=> \\$bisect_bad,\n    \"BISECT_TYPE\"\t\t=> \\$bisect_type,\n    \"BISECT_START\"\t\t=> \\$bisect_start,\n    \"BISECT_REPLAY\"\t\t=> \\$bisect_replay,\n    \"BISECT_FILES\"\t\t=> \\$bisect_files,\n    \"BISECT_REVERSE\"\t\t=> \\$bisect_reverse,\n    \"BISECT_CHECK\"\t\t=> \\$bisect_check,\n\n    \"CONFIG_BISECT\"\t\t=> \\$config_bisect,\n    \"CONFIG_BISECT_TYPE\"\t=> \\$config_bisect_type,\n    \"CONFIG_BISECT_CHECK\"\t=> \\$config_bisect_check,\n\n    \"PATCHCHECK_TYPE\"\t\t=> \\$patchcheck_type,\n    \"PATCHCHECK_START\"\t\t=> \\$patchcheck_start,\n    \"PATCHCHECK_CHERRY\"\t\t=> \\$patchcheck_cherry,\n    \"PATCHCHECK_END\"\t\t=> \\$patchcheck_end,\n);\n\n# Options may be used by other options, record them.\nmy %used_options;\n\n# default variables that can be used\nchomp ($variable{\"PWD\"} = `pwd`);\n$pwd = $variable{\"PWD\"};\n\n$config_help{\"MACHINE\"} = << \"EOF\"\n The machine hostname that you will test.\n For build only tests, it is still needed to differentiate log files.\nEOF\n    ;\n$config_help{\"SSH_USER\"} = << \"EOF\"\n The box is expected to have ssh on normal bootup, provide the user\n  (most likely root, since you need privileged operations)\nEOF\n    ;\n$config_help{\"BUILD_DIR\"} = << \"EOF\"\n The directory that contains the Linux source code (full path).\n You can use \\${PWD} that will be the path where ktest.pl is run, or use\n \\${THIS_DIR} which is assigned \\${PWD} but may be changed later.\nEOF\n    ;\n$config_help{\"OUTPUT_DIR\"} = << \"EOF\"\n The directory that the objects will be built (full path).\n (can not be same as BUILD_DIR)\n You can use \\${PWD} that will be the path where ktest.pl is run, or use\n \\${THIS_DIR} which is assigned \\${PWD} but may be changed later.\nEOF\n    ;\n$config_help{\"BUILD_TARGET\"} = << \"EOF\"\n The location of the compiled file to copy to the target.\n (relative to OUTPUT_DIR)\nEOF\n    ;\n$config_help{\"BUILD_OPTIONS\"} = << \"EOF\"\n Options to add to \\\"make\\\" when building.\n i.e.  -j20\nEOF\n    ;\n$config_help{\"TARGET_IMAGE\"} = << \"EOF\"\n The place to put your image on the test machine.\nEOF\n    ;\n$config_help{\"POWER_CYCLE\"} = << \"EOF\"\n A script or command to reboot the box.\n\n Here is a digital loggers power switch example\n POWER_CYCLE = wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin\\@power/outlet?5=CCL'\n\n Here is an example to reboot a virtual box on the current host\n with the name \"Guest\".\n POWER_CYCLE = virsh destroy Guest; sleep 5; virsh start Guest\nEOF\n    ;\n$config_help{\"CONSOLE\"} = << \"EOF\"\n The script or command that reads the console\n\n  If you use ttywatch server, something like the following would work.\nCONSOLE = nc -d localhost 3001\n\n For a virtual machine with guest name \"Guest\".\nCONSOLE =  virsh console Guest\nEOF\n    ;\n$config_help{\"LOCALVERSION\"} = << \"EOF\"\n Required version ending to differentiate the test\n from other linux builds on the system.\nEOF\n    ;\n$config_help{\"REBOOT_TYPE\"} = << \"EOF\"\n Way to reboot the box to the test kernel.\n Only valid options so far are \"grub\", \"grub2\", \"grub2bls\", \"syslinux\", and \"script\".\n\n If you specify grub, it will assume grub version 1\n and will search in /boot/grub/menu.lst for the title \\$GRUB_MENU\n and select that target to reboot to the kernel. If this is not\n your setup, then specify \"script\" and have a command or script\n specified in REBOOT_SCRIPT to boot to the target.\n\n The entry in /boot/grub/menu.lst must be entered in manually.\n The test will not modify that file.\n\n If you specify grub2, then you also need to specify both \\$GRUB_MENU\n and \\$GRUB_FILE.\n\n If you specify grub2bls, then you also need to specify \\$GRUB_MENU.\n\n If you specify syslinux, then you may use SYSLINUX to define the syslinux\n command (defaults to extlinux), and SYSLINUX_PATH to specify the path to\n the syslinux install (defaults to /boot/extlinux). But you have to specify\n SYSLINUX_LABEL to define the label to boot to for the test kernel.\nEOF\n    ;\n$config_help{\"GRUB_MENU\"} = << \"EOF\"\n The grub title name for the test kernel to boot\n (Only mandatory if REBOOT_TYPE = grub or grub2)\n\n Note, ktest.pl will not update the grub menu.lst, you need to\n manually add an option for the test. ktest.pl will search\n the grub menu.lst for this option to find what kernel to\n reboot into.\n\n For example, if in the /boot/grub/menu.lst the test kernel title has:\n title Test Kernel\n kernel vmlinuz-test\n GRUB_MENU = Test Kernel\n\n For grub2, a search of \\$GRUB_FILE is performed for the lines\n that begin with \"menuentry\". It will not detect submenus. The\n menu must be a non-nested menu. Add the quotes used in the menu\n to guarantee your selection, as the first menuentry with the content\n of \\$GRUB_MENU that is found will be used.\n\n For grub2bls, \\$GRUB_MENU is searched on the result of \\$GRUB_BLS_GET\n command for the lines that begin with \"title\".\nEOF\n    ;\n$config_help{\"GRUB_FILE\"} = << \"EOF\"\n If grub2 is used, the full path for the grub.cfg file is placed\n here. Use something like /boot/grub2/grub.cfg to search.\nEOF\n    ;\n$config_help{\"SYSLINUX_LABEL\"} = << \"EOF\"\n If syslinux is used, the label that boots the target kernel must\n be specified with SYSLINUX_LABEL.\nEOF\n    ;\n$config_help{\"REBOOT_SCRIPT\"} = << \"EOF\"\n A script to reboot the target into the test kernel\n (Only mandatory if REBOOT_TYPE = script)\nEOF\n    ;\n\n# used with process_expression()\nmy $d = 0;\n\n# defined before get_test_name()\nmy $in_die = 0;\n\n# defined before process_warning_line()\nmy $check_build_re = \".*:.*(warning|error|Error):.*\";\nmy $utf8_quote = \"\\\\x{e2}\\\\x{80}(\\\\x{98}|\\\\x{99})\";\n\n# defined before child_finished()\nmy $child_done;\n\n# config_ignore holds the configs that were set (or unset) for\n# a good config and we will ignore these configs for the rest\n# of a config bisect. These configs stay as they were.\nmy %config_ignore;\n\n# config_set holds what all configs were set as.\nmy %config_set;\n\n# config_off holds the set of configs that the bad config had disabled.\n# We need to record them and set them in the .config when running\n# olddefconfig, because olddefconfig keeps the defaults.\nmy %config_off;\n\n# config_off_tmp holds a set of configs to turn off for now\nmy @config_off_tmp;\n\n# config_list is the set of configs that are being tested\nmy %config_list;\nmy %null_config;\n\nmy %dependency;\n\n# found above run_config_bisect()\nmy $pass = 1;\n\n# found above add_dep()\n\nmy %depends;\nmy %depcount;\nmy $iflevel = 0;\nmy @ifdeps;\n\n# prevent recursion\nmy %read_kconfigs;\n\n# found above test_this_config()\nmy %min_configs;\nmy %keep_configs;\nmy %save_configs;\nmy %processed_configs;\nmy %nochange_config;\n\n#\n# These are first defined here, main function later on\n#\nsub run_command;\nsub start_monitor;\nsub end_monitor;\nsub wait_for_monitor;\n\nsub _logit {\n    if (defined($opt{\"LOG_FILE\"})) {\n\tprint LOG @_;\n    }\n}\n\nsub logit {\n    if (defined($opt{\"LOG_FILE\"})) {\n\t_logit @_;\n    } else {\n\tprint @_;\n    }\n}\n\nsub doprint {\n    print @_;\n    _logit @_;\n}\n\nsub read_prompt {\n    my ($cancel, $prompt) = @_;\n\n    my $ans;\n\n    for (;;) {\n        if ($cancel) {\n\t    print \"$prompt [y/n/C] \";\n\t} else {\n\t    print \"$prompt [Y/n] \";\n\t}\n\t$ans = <STDIN>;\n\tchomp $ans;\n\tif ($ans =~ /^\\s*$/) {\n\t    if ($cancel) {\n\t\t$ans = \"c\";\n\t    } else {\n\t\t$ans = \"y\";\n\t    }\n\t}\n\tlast if ($ans =~ /^y$/i || $ans =~ /^n$/i);\n\tif ($cancel) {\n\t    last if ($ans =~ /^c$/i);\n\t    print \"Please answer either 'y', 'n' or 'c'.\\n\";\n\t} else {\n\t    print \"Please answer either 'y' or 'n'.\\n\";\n\t}\n    }\n    if ($ans =~ /^c/i) {\n\texit;\n    }\n    if ($ans !~ /^y$/i) {\n\treturn 0;\n    }\n    return 1;\n}\n\nsub read_yn {\n    my ($prompt) = @_;\n\n    return read_prompt 0, $prompt;\n}\n\nsub read_ync {\n    my ($prompt) = @_;\n\n    return read_prompt 1, $prompt;\n}\n\nsub get_mandatory_config {\n    my ($config) = @_;\n    my $ans;\n\n    return if (defined($opt{$config}));\n\n    if (defined($config_help{$config})) {\n\tprint \"\\n\";\n\tprint $config_help{$config};\n    }\n\n    for (;;) {\n\tprint \"$config = \";\n\tif (defined($default{$config}) && length($default{$config})) {\n\t    print \"\\[$default{$config}\\] \";\n\t}\n\t$ans = <STDIN>;\n\t$ans =~ s/^\\s*(.*\\S)\\s*$/$1/;\n\tif ($ans =~ /^\\s*$/) {\n\t    if ($default{$config}) {\n\t\t$ans = $default{$config};\n\t    } else {\n\t\tprint \"Your answer can not be blank\\n\";\n\t\tnext;\n\t    }\n\t}\n\t$entered_configs{$config} = ${ans};\n\tlast;\n    }\n}\n\nsub show_time {\n    my ($time) = @_;\n\n    my $hours = 0;\n    my $minutes = 0;\n\n    if ($time > 3600) {\n\t$hours = int($time / 3600);\n\t$time -= $hours * 3600;\n    }\n    if ($time > 60) {\n\t$minutes = int($time / 60);\n\t$time -= $minutes * 60;\n    }\n\n    if ($hours > 0) {\n\tdoprint \"$hours hour\";\n\tdoprint \"s\" if ($hours > 1);\n\tdoprint \" \";\n    }\n\n    if ($minutes > 0) {\n\tdoprint \"$minutes minute\";\n\tdoprint \"s\" if ($minutes > 1);\n\tdoprint \" \";\n    }\n\n    doprint \"$time second\";\n    doprint \"s\" if ($time != 1);\n}\n\nsub print_times {\n    doprint \"\\n\";\n    if ($build_time) {\n\tdoprint \"Build time:   \";\n\tshow_time($build_time);\n\tdoprint \"\\n\";\n    }\n    if ($install_time) {\n\tdoprint \"Install time: \";\n\tshow_time($install_time);\n\tdoprint \"\\n\";\n    }\n    if ($reboot_time) {\n\tdoprint \"Reboot time:  \";\n\tshow_time($reboot_time);\n\tdoprint \"\\n\";\n    }\n    if ($test_time) {\n\tdoprint \"Test time:    \";\n\tshow_time($test_time);\n\tdoprint \"\\n\";\n    }\n    # reset for iterations like bisect\n    $build_time = 0;\n    $install_time = 0;\n    $reboot_time = 0;\n    $test_time = 0;\n}\n\nsub get_mandatory_configs {\n    get_mandatory_config(\"MACHINE\");\n    get_mandatory_config(\"BUILD_DIR\");\n    get_mandatory_config(\"OUTPUT_DIR\");\n\n    if ($newconfig) {\n\tget_mandatory_config(\"BUILD_OPTIONS\");\n    }\n\n    # options required for other than just building a kernel\n    if (!$buildonly) {\n\tget_mandatory_config(\"POWER_CYCLE\");\n\tget_mandatory_config(\"CONSOLE\");\n    }\n\n    # options required for install and more\n    if ($buildonly != 1) {\n\tget_mandatory_config(\"SSH_USER\");\n\tget_mandatory_config(\"BUILD_TARGET\");\n\tget_mandatory_config(\"TARGET_IMAGE\");\n    }\n\n    get_mandatory_config(\"LOCALVERSION\");\n\n    return if ($buildonly);\n\n    my $rtype = $opt{\"REBOOT_TYPE\"};\n\n    if (!defined($rtype)) {\n\tif (!defined($opt{\"GRUB_MENU\"})) {\n\t    get_mandatory_config(\"REBOOT_TYPE\");\n\t    $rtype = $entered_configs{\"REBOOT_TYPE\"};\n\t} else {\n\t    $rtype = \"grub\";\n\t}\n    }\n\n    if (($rtype eq \"grub\") or ($rtype eq \"grub2bls\")) {\n\tget_mandatory_config(\"GRUB_MENU\");\n    }\n\n    if ($rtype eq \"grub2\") {\n\tget_mandatory_config(\"GRUB_MENU\");\n\tget_mandatory_config(\"GRUB_FILE\");\n    }\n\n    if ($rtype eq \"syslinux\") {\n\tget_mandatory_config(\"SYSLINUX_LABEL\");\n    }\n}\n\nsub process_variables {\n    my ($value, $remove_undef) = @_;\n    my $retval = \"\";\n\n    # We want to check for '\\', and it is just easier\n    # to check the previous characet of '$' and not need\n    # to worry if '$' is the first character. By adding\n    # a space to $value, we can just check [^\\\\]\\$ and\n    # it will still work.\n    $value = \" $value\";\n\n    while ($value =~ /(.*?[^\\\\])\\$\\{(.*?)\\}(.*)/) {\n\tmy $begin = $1;\n\tmy $var = $2;\n\tmy $end = $3;\n\t# append beginning of value to retval\n\t$retval = \"$retval$begin\";\n\tif ($var =~ s/^shell\\s+//) {\n\t    $retval = `$var`;\n\t    if ($?) {\n\t\tdoprint \"WARNING: $var returned an error\\n\";\n\t    } else {\n\t\tchomp $retval;\n\t    }\n\t} elsif (defined($variable{$var})) {\n\t    $retval = \"$retval$variable{$var}\";\n\t} elsif (defined($remove_undef) && $remove_undef) {\n\t    # for if statements, any variable that is not defined,\n\t    # we simple convert to 0\n\t    $retval = \"${retval}0\";\n\t} else {\n\t    # put back the origin piece.\n\t    $retval = \"$retval\\$\\{$var\\}\";\n\t    # This could be an option that is used later, save\n\t    # it so we don't warn if this option is not one of\n\t    # ktests options.\n\t    $used_options{$var} = 1;\n\t}\n\t$value = $end;\n    }\n    $retval = \"$retval$value\";\n\n    # remove the space added in the beginning\n    $retval =~ s/ //;\n\n    return \"$retval\";\n}\n\nsub set_value {\n    my ($lvalue, $rvalue, $override, $overrides, $name) = @_;\n\n    my $prvalue = process_variables($rvalue);\n\n    if ($lvalue =~ /^(TEST|BISECT|CONFIG_BISECT)_TYPE(\\[.*\\])?$/ &&\n\t$prvalue !~ /^(config_|)bisect$/ &&\n\t$prvalue !~ /^build$/ &&\n\t$buildonly) {\n\n\t# Note if a test is something other than build, then we\n\t# will need other mandatory options.\n\tif ($prvalue ne \"install\") {\n\t    $buildonly = 0;\n\t} else {\n\t    # install still limits some mandatory options.\n\t    $buildonly = 2;\n\t}\n    }\n\n    if (defined($opt{$lvalue})) {\n\tif (!$override || defined(${$overrides}{$lvalue})) {\n\t    my $extra = \"\";\n\t    if ($override) {\n\t\t$extra = \"In the same override section!\\n\";\n\t    }\n\t    die \"$name: $.: Option $lvalue defined more than once!\\n$extra\";\n\t}\n\t${$overrides}{$lvalue} = $prvalue;\n    }\n\n    $opt{$lvalue} = $prvalue;\n}\n\nsub set_eval {\n    my ($lvalue, $rvalue, $name) = @_;\n\n    my $prvalue = process_variables($rvalue);\n    my $arr;\n\n    if (defined($evals{$lvalue})) {\n\t$arr = $evals{$lvalue};\n    } else {\n\t$arr = [];\n\t$evals{$lvalue} = $arr;\n    }\n\n    push @{$arr}, $rvalue;\n}\n\nsub set_variable {\n    my ($lvalue, $rvalue) = @_;\n\n    if ($rvalue =~ /^\\s*$/) {\n\tdelete $variable{$lvalue};\n    } else {\n\t$rvalue = process_variables($rvalue);\n\t$variable{$lvalue} = $rvalue;\n    }\n}\n\nsub process_compare {\n    my ($lval, $cmp, $rval) = @_;\n\n    # remove whitespace\n\n    $lval =~ s/^\\s*//;\n    $lval =~ s/\\s*$//;\n\n    $rval =~ s/^\\s*//;\n    $rval =~ s/\\s*$//;\n\n    if ($cmp eq \"==\") {\n\treturn $lval eq $rval;\n    } elsif ($cmp eq \"!=\") {\n\treturn $lval ne $rval;\n    } elsif ($cmp eq \"=~\") {\n\treturn $lval =~ m/$rval/;\n    } elsif ($cmp eq \"!~\") {\n\treturn $lval !~ m/$rval/;\n    }\n\n    my $statement = \"$lval $cmp $rval\";\n    my $ret = eval $statement;\n\n    # $@ stores error of eval\n    if ($@) {\n\treturn -1;\n    }\n\n    return $ret;\n}\n\nsub value_defined {\n    my ($val) = @_;\n\n    return defined($variable{$2}) ||\n\tdefined($opt{$2});\n}\n\nsub process_expression {\n    my ($name, $val) = @_;\n\n    my $c = $d++;\n\n    while ($val =~ s/\\(([^\\(]*?)\\)/\\&\\&\\&\\&VAL\\&\\&\\&\\&/) {\n\tmy $express = $1;\n\n\tif (process_expression($name, $express)) {\n\t    $val =~ s/\\&\\&\\&\\&VAL\\&\\&\\&\\&/ 1 /;\n\t} else {\n\t    $val =~ s/\\&\\&\\&\\&VAL\\&\\&\\&\\&/ 0 /;\n\t}\n    }\n\n    $d--;\n    my $OR = \"\\\\|\\\\|\";\n    my $AND = \"\\\\&\\\\&\";\n\n    while ($val =~ s/^(.*?)($OR|$AND)//) {\n\tmy $express = $1;\n\tmy $op = $2;\n\n\tif (process_expression($name, $express)) {\n\t    if ($op eq \"||\") {\n\t\treturn 1;\n\t    }\n\t} else {\n\t    if ($op eq \"&&\") {\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    if ($val =~ /(.*)(==|\\!=|>=|<=|>|<|=~|\\!~)(.*)/) {\n\tmy $ret = process_compare($1, $2, $3);\n\tif ($ret < 0) {\n\t    die \"$name: $.: Unable to process comparison\\n\";\n\t}\n\treturn $ret;\n    }\n\n    if ($val =~ /^\\s*(NOT\\s*)?DEFINED\\s+(\\S+)\\s*$/) {\n\tif (defined $1) {\n\t    return !value_defined($2);\n\t} else {\n\t    return value_defined($2);\n\t}\n    }\n\n    if ($val =~ s/^\\s*NOT\\s+(.*)//) {\n\tmy $express = $1;\n\tmy $ret = process_expression($name, $express);\n\treturn !$ret;\n    }\n\n    if ($val =~ /^\\s*0\\s*$/) {\n\treturn 0;\n    } elsif ($val =~ /^\\s*\\d+\\s*$/) {\n\treturn 1;\n    }\n\n    die (\"$name: $.: Undefined content $val in if statement\\n\");\n}\n\nsub process_if {\n    my ($name, $value) = @_;\n\n    # Convert variables and replace undefined ones with 0\n    my $val = process_variables($value, 1);\n    my $ret = process_expression $name, $val;\n\n    return $ret;\n}\n\nsub __read_config {\n    my ($config, $current_test_num) = @_;\n\n    my $in;\n    open($in, $config) || die \"can't read file $config\";\n\n    my $name = $config;\n    $name =~ s,.*/(.*),$1,;\n\n    my $test_num = $$current_test_num;\n    my $default = 1;\n    my $repeat = 1;\n    my $num_tests_set = 0;\n    my $skip = 0;\n    my $rest;\n    my $line;\n    my $test_case = 0;\n    my $if = 0;\n    my $if_set = 0;\n    my $override = 0;\n\n    my %overrides;\n\n    while (<$in>) {\n\n\t# ignore blank lines and comments\n\tnext if (/^\\s*$/ || /\\s*\\#/);\n\n\tif (/^\\s*(TEST_START|DEFAULTS)\\b(.*)/) {\n\n\t    my $type = $1;\n\t    $rest = $2;\n\t    $line = $2;\n\n\t    my $old_test_num;\n\t    my $old_repeat;\n\t    $override = 0;\n\n\t    if ($type eq \"TEST_START\") {\n\t\tif ($num_tests_set) {\n\t\t    die \"$name: $.: Can not specify both NUM_TESTS and TEST_START\\n\";\n\t\t}\n\n\t\t$old_test_num = $test_num;\n\t\t$old_repeat = $repeat;\n\n\t\t$test_num += $repeat;\n\t\t$default = 0;\n\t\t$repeat = 1;\n\t    } else {\n\t\t$default = 1;\n\t    }\n\n\t    # If SKIP is anywhere in the line, the command will be skipped\n\t    if ($rest =~ s/\\s+SKIP\\b//) {\n\t\t$skip = 1;\n\t    } else {\n\t\t$test_case = 1;\n\t\t$skip = 0;\n\t    }\n\n\t    if ($rest =~ s/\\sELSE\\b//) {\n\t\tif (!$if) {\n\t\t    die \"$name: $.: ELSE found with out matching IF section\\n$_\";\n\t\t}\n\t\t$if = 0;\n\n\t\tif ($if_set) {\n\t\t    $skip = 1;\n\t\t} else {\n\t\t    $skip = 0;\n\t\t}\n\t    }\n\n\t    if ($rest =~ s/\\sIF\\s+(.*)//) {\n\t\tif (process_if($name, $1)) {\n\t\t    $if_set = 1;\n\t\t} else {\n\t\t    $skip = 1;\n\t\t}\n\t\t$if = 1;\n\t    } else {\n\t\t$if = 0;\n\t\t$if_set = 0;\n\t    }\n\n\t    if (!$skip) {\n\t\tif ($type eq \"TEST_START\") {\n\t\t    if ($rest =~ s/\\s+ITERATE\\s+(\\d+)//) {\n\t\t\t$repeat = $1;\n\t\t\t$repeat_tests{\"$test_num\"} = $repeat;\n\t\t    }\n\t\t} elsif ($rest =~ s/\\sOVERRIDE\\b//) {\n\t\t    # DEFAULT only\n\t\t    $override = 1;\n\t\t    # Clear previous overrides\n\t\t    %overrides = ();\n\t\t}\n\t    }\n\n\t    if (!$skip && $rest !~ /^\\s*$/) {\n\t\tdie \"$name: $.: Garbage found after $type\\n$_\";\n\t    }\n\n\t    if ($skip && $type eq \"TEST_START\") {\n\t\t$test_num = $old_test_num;\n\t\t$repeat = $old_repeat;\n\t    }\n\t} elsif (/^\\s*ELSE\\b(.*)$/) {\n\t    if (!$if) {\n\t\tdie \"$name: $.: ELSE found with out matching IF section\\n$_\";\n\t    }\n\t    $rest = $1;\n\t    if ($if_set) {\n\t\t$skip = 1;\n\t\t$rest = \"\";\n\t    } else {\n\t\t$skip = 0;\n\n\t\tif ($rest =~ /\\sIF\\s+(.*)/) {\n\t\t    # May be a ELSE IF section.\n\t\t    if (process_if($name, $1)) {\n\t\t\t$if_set = 1;\n\t\t    } else {\n\t\t\t$skip = 1;\n\t\t    }\n\t\t    $rest = \"\";\n\t\t} else {\n\t\t    $if = 0;\n\t\t}\n\t    }\n\n\t    if ($rest !~ /^\\s*$/) {\n\t\tdie \"$name: $.: Garbage found after DEFAULTS\\n$_\";\n\t    }\n\n\t} elsif (/^\\s*INCLUDE\\s+(\\S+)/) {\n\n\t    next if ($skip);\n\n\t    if (!$default) {\n\t\tdie \"$name: $.: INCLUDE can only be done in default sections\\n$_\";\n\t    }\n\n\t    my $file = process_variables($1);\n\n\t    if ($file !~ m,^/,) {\n\t\t# check the path of the config file first\n\t\tif ($config =~ m,(.*)/,) {\n\t\t    if (-f \"$1/$file\") {\n\t\t\t$file = \"$1/$file\";\n\t\t    }\n\t\t}\n\t    }\n\n\t    if ( ! -r $file ) {\n\t\tdie \"$name: $.: Can't read file $file\\n$_\";\n\t    }\n\n\t    if (__read_config($file, \\$test_num)) {\n\t\t$test_case = 1;\n\t    }\n\n\t} elsif (/^\\s*([A-Z_\\[\\]\\d]+)\\s*=~\\s*(.*?)\\s*$/) {\n\n\t    next if ($skip);\n\n\t    my $lvalue = $1;\n\t    my $rvalue = $2;\n\n\t    if ($default || $lvalue =~ /\\[\\d+\\]$/) {\n\t\tset_eval($lvalue, $rvalue, $name);\n\t    } else {\n\t\tmy $val = \"$lvalue\\[$test_num\\]\";\n\t\tset_eval($val, $rvalue, $name);\n\t    }\n\n\t} elsif (/^\\s*([A-Z_\\[\\]\\d]+)\\s*=\\s*(.*?)\\s*$/) {\n\n\t    next if ($skip);\n\n\t    my $lvalue = $1;\n\t    my $rvalue = $2;\n\n\t    if (!$default &&\n\t\t($lvalue eq \"NUM_TESTS\" ||\n\t\t $lvalue eq \"LOG_FILE\" ||\n\t\t $lvalue eq \"CLEAR_LOG\")) {\n\t\tdie \"$name: $.: $lvalue must be set in DEFAULTS section\\n\";\n\t    }\n\n\t    if ($lvalue eq \"NUM_TESTS\") {\n\t\tif ($test_num) {\n\t\t    die \"$name: $.: Can not specify both NUM_TESTS and TEST_START\\n\";\n\t\t}\n\t\tif (!$default) {\n\t\t    die \"$name: $.: NUM_TESTS must be set in default section\\n\";\n\t\t}\n\t\t$num_tests_set = 1;\n\t    }\n\n\t    if ($default || $lvalue =~ /\\[\\d+\\]$/) {\n\t\tset_value($lvalue, $rvalue, $override, \\%overrides, $name);\n\t    } else {\n\t\tmy $val = \"$lvalue\\[$test_num\\]\";\n\t\tset_value($val, $rvalue, $override, \\%overrides, $name);\n\n\t\tif ($repeat > 1) {\n\t\t    $repeats{$val} = $repeat;\n\t\t}\n\t    }\n\t} elsif (/^\\s*([A-Z_\\[\\]\\d]+)\\s*:=\\s*(.*?)\\s*$/) {\n\t    next if ($skip);\n\n\t    my $lvalue = $1;\n\t    my $rvalue = $2;\n\n\t    # process config variables.\n\t    # Config variables are only active while reading the\n\t    # config and can be defined anywhere. They also ignore\n\t    # TEST_START and DEFAULTS, but are skipped if they are in\n\t    # on of these sections that have SKIP defined.\n\t    # The save variable can be\n\t    # defined multiple times and the new one simply overrides\n\t    # the previous one.\n\t    set_variable($lvalue, $rvalue);\n\n\t} else {\n\t    die \"$name: $.: Garbage found in config\\n$_\";\n\t}\n    }\n\n    if ($test_num) {\n\t$test_num += $repeat - 1;\n\t$opt{\"NUM_TESTS\"} = $test_num;\n    }\n\n    close($in);\n\n    $$current_test_num = $test_num;\n\n    return $test_case;\n}\n\nsub get_test_case {\n    print \"What test case would you like to run?\\n\";\n    print \" (build, install or boot)\\n\";\n    print \" Other tests are available but require editing ktest.conf\\n\";\n    print \" (see tools/testing/ktest/sample.conf)\\n\";\n    my $ans = <STDIN>;\n    chomp $ans;\n    $default{\"TEST_TYPE\"} = $ans;\n}\n\nsub read_config {\n    my ($config) = @_;\n\n    my $test_case;\n    my $test_num = 0;\n\n    $test_case = __read_config $config, \\$test_num;\n\n    # make sure we have all mandatory configs\n    get_mandatory_configs;\n\n    # was a test specified?\n    if (!$test_case) {\n\tprint \"No test case specified.\\n\";\n\tget_test_case;\n    }\n\n    # set any defaults\n\n    foreach my $default (keys %default) {\n\tif (!defined($opt{$default})) {\n\t    $opt{$default} = $default{$default};\n\t}\n    }\n\n    if ($opt{\"IGNORE_UNUSED\"} == 1) {\n\treturn;\n    }\n\n    my %not_used;\n\n    # check if there are any stragglers (typos?)\n    foreach my $option (keys %opt) {\n\tmy $op = $option;\n\t# remove per test labels.\n\t$op =~ s/\\[.*\\]//;\n\tif (!exists($option_map{$op}) &&\n\t    !exists($default{$op}) &&\n\t    !exists($used_options{$op})) {\n\t    $not_used{$op} = 1;\n\t}\n    }\n\n    if (%not_used) {\n\tmy $s = \"s are\";\n\t$s = \" is\" if (keys %not_used == 1);\n\tprint \"The following option$s not used; could be a typo:\\n\";\n\tforeach my $option (keys %not_used) {\n\t    print \"$option\\n\";\n\t}\n\tprint \"Set IGNORE_UNUSED = 1 to have ktest ignore unused variables\\n\";\n\tif (!read_yn \"Do you want to continue?\") {\n\t    exit -1;\n\t}\n    }\n}\n\nsub __eval_option {\n    my ($name, $option, $i) = @_;\n\n    # Add space to evaluate the character before $\n    $option = \" $option\";\n    my $retval = \"\";\n    my $repeated = 0;\n    my $parent = 0;\n\n    foreach my $test (keys %repeat_tests) {\n\tif ($i >= $test &&\n\t    $i < $test + $repeat_tests{$test}) {\n\n\t    $repeated = 1;\n\t    $parent = $test;\n\t    last;\n\t}\n    }\n\n    while ($option =~ /(.*?[^\\\\])\\$\\{(.*?)\\}(.*)/) {\n\tmy $start = $1;\n\tmy $var = $2;\n\tmy $end = $3;\n\n\t# Append beginning of line\n\t$retval = \"$retval$start\";\n\n\t# If the iteration option OPT[$i] exists, then use that.\n\t# otherwise see if the default OPT (without [$i]) exists.\n\n\tmy $o = \"$var\\[$i\\]\";\n\tmy $parento = \"$var\\[$parent\\]\";\n\n\t# If a variable contains itself, use the default var\n\tif (($var eq $name) && defined($opt{$var})) {\n\t    $o = $opt{$var};\n\t    $retval = \"$retval$o\";\n\t} elsif (defined($opt{$o})) {\n\t    $o = $opt{$o};\n\t    $retval = \"$retval$o\";\n\t} elsif ($repeated && defined($opt{$parento})) {\n\t    $o = $opt{$parento};\n\t    $retval = \"$retval$o\";\n\t} elsif (defined($opt{$var})) {\n\t    $o = $opt{$var};\n\t    $retval = \"$retval$o\";\n\t} elsif ($var eq \"KERNEL_VERSION\" && defined($make)) {\n\t    # special option KERNEL_VERSION uses kernel version\n\t    get_version();\n\t    $retval = \"$retval$version\";\n\t} else {\n\t    $retval = \"$retval\\$\\{$var\\}\";\n\t}\n\n\t$option = $end;\n    }\n\n    $retval = \"$retval$option\";\n\n    $retval =~ s/^ //;\n\n    return $retval;\n}\n\nsub process_evals {\n    my ($name, $option, $i) = @_;\n\n    my $option_name = \"$name\\[$i\\]\";\n    my $ev;\n\n    my $old_option = $option;\n\n    if (defined($evals{$option_name})) {\n\t$ev = $evals{$option_name};\n    } elsif (defined($evals{$name})) {\n\t$ev = $evals{$name};\n    } else {\n\treturn $option;\n    }\n\n    for my $e (@{$ev}) {\n\teval \"\\$option =~ $e\";\n    }\n\n    if ($option ne $old_option) {\n\tdoprint(\"$name changed from '$old_option' to '$option'\\n\");\n    }\n\n    return $option;\n}\n\nsub eval_option {\n    my ($name, $option, $i) = @_;\n\n    my $prev = \"\";\n\n    # Since an option can evaluate to another option,\n    # keep iterating until we do not evaluate any more\n    # options.\n    my $r = 0;\n    while ($prev ne $option) {\n\t# Check for recursive evaluations.\n\t# 100 deep should be more than enough.\n\tif ($r++ > 100) {\n\t    die \"Over 100 evaluations occurred with $option\\n\" .\n\t\t\"Check for recursive variables\\n\";\n\t}\n\t$prev = $option;\n\t$option = __eval_option($name, $option, $i);\n    }\n\n    $option = process_evals($name, $option, $i);\n\n    return $option;\n}\n\nsub reboot {\n    my ($time) = @_;\n    my $powercycle = 0;\n\n    # test if the machine can be connected to within a few seconds\n    my $stat = run_ssh(\"echo check machine status\", $connect_timeout);\n    if (!$stat) {\n\tdoprint(\"power cycle\\n\");\n\t$powercycle = 1;\n    }\n\n    if ($powercycle) {\n\trun_command \"$power_cycle\";\n\n\tstart_monitor;\n\t# flush out current monitor\n\t# May contain the reboot success line\n\twait_for_monitor 1;\n\n    } else {\n\t# Make sure everything has been written to disk\n\trun_ssh(\"sync\", 10);\n\n\tif (defined($time)) {\n\t    start_monitor;\n\t    # flush out current monitor\n\t    # May contain the reboot success line\n\t    wait_for_monitor 1;\n\t}\n\n\t# try to reboot normally\n\tif (run_command $reboot) {\n\t    if (defined($powercycle_after_reboot)) {\n\t\tsleep $powercycle_after_reboot;\n\t\trun_command \"$power_cycle\";\n\t    }\n\t} else {\n\t    # nope? power cycle it.\n\t    run_command \"$power_cycle\";\n\t}\n    }\n\n    if (defined($time)) {\n\n\t# We only want to get to the new kernel, don't fail\n\t# if we stumble over a call trace.\n\tmy $save_ignore_errors = $ignore_errors;\n\t$ignore_errors = 1;\n\n\t# Look for the good kernel to boot\n\tif (wait_for_monitor($time, \"Linux version\")) {\n\t    # reboot got stuck?\n\t    doprint \"Reboot did not finish. Forcing power cycle\\n\";\n\t    run_command \"$power_cycle\";\n\t}\n\n\t$ignore_errors = $save_ignore_errors;\n\n\t# Still need to wait for the reboot to finish\n\twait_for_monitor($time, $reboot_success_line);\n    }\n    if ($powercycle || $time) {\n\tend_monitor;\n    }\n}\n\nsub reboot_to_good {\n    my ($time) = @_;\n\n    if (defined($switch_to_good)) {\n\trun_command $switch_to_good;\n    }\n\n    reboot $time;\n}\n\nsub do_not_reboot {\n    my $i = $iteration;\n\n    return $test_type eq \"build\" || $no_reboot ||\n\t($test_type eq \"patchcheck\" && $opt{\"PATCHCHECK_TYPE[$i]\"} eq \"build\") ||\n\t($test_type eq \"bisect\" && $opt{\"BISECT_TYPE[$i]\"} eq \"build\") ||\n\t($test_type eq \"config_bisect\" && $opt{\"CONFIG_BISECT_TYPE[$i]\"} eq \"build\");\n}\n\nsub get_test_name() {\n    my $name;\n\n    if (defined($test_name)) {\n\t$name = \"$test_name:$test_type\";\n    } else {\n\t$name = $test_type;\n    }\n    return $name;\n}\n\nsub dodie {\n    # avoid recursion\n    return if ($in_die);\n    $in_die = 1;\n\n    if ($monitor_cnt) {\n\t# restore terminal settings\n\tsystem(\"stty $stty_orig\");\n    }\n\n    my $i = $iteration;\n\n    doprint \"CRITICAL FAILURE... [TEST $i] \", @_, \"\\n\";\n\n    if ($reboot_on_error && !do_not_reboot) {\n\tdoprint \"REBOOTING\\n\";\n\treboot_to_good;\n    } elsif ($poweroff_on_error && defined($power_off)) {\n\tdoprint \"POWERING OFF\\n\";\n\t`$power_off`;\n    }\n\n    if (defined($opt{\"LOG_FILE\"})) {\n\tprint \" See $opt{LOG_FILE} for more info.\\n\";\n    }\n\n    if ($email_on_error) {\n\tmy $name = get_test_name;\n\tmy $log_file;\n\n\tif (defined($opt{\"LOG_FILE\"})) {\n\t    my $whence = 2; # End of file\n\t    my $log_size = tell LOG;\n\t    my $size = $log_size - $test_log_start;\n\n\t    if (defined($mail_max_size)) {\n\t\tif ($size > $mail_max_size) {\n\t\t    $size = $mail_max_size;\n\t\t}\n\t    }\n\t    my $pos = - $size;\n\t    $log_file = \"$tmpdir/log\";\n\t    open (L, \"$opt{LOG_FILE}\") or die \"Can't open $opt{LOG_FILE} to read)\";\n\t    open (O, \"> $tmpdir/log\") or die \"Can't open $tmpdir/log\\n\";\n\t    seek(L, $pos, $whence);\n\t    while (<L>) {\n\t\tprint O;\n\t    }\n\t    close O;\n\t    close L;\n\t}\n\n\tsend_email(\"KTEST: critical failure for test $i [$name]\",\n\t\t\"Your test started at $script_start_time has failed with:\\n@_\\n\", $log_file);\n    }\n\n    if (defined($post_test)) {\n\trun_command $post_test;\n    }\n\n    die @_, \"\\n\";\n}\n\nsub create_pty {\n    my ($ptm, $pts) = @_;\n    my $tmp;\n    my $TIOCSPTLCK = 0x40045431;\n    my $TIOCGPTN = 0x80045430;\n\n    sysopen($ptm, \"/dev/ptmx\", O_RDWR | O_NONBLOCK) or\n\tdodie \"Can't open /dev/ptmx\";\n\n    # unlockpt()\n    $tmp = pack(\"i\", 0);\n    ioctl($ptm, $TIOCSPTLCK, $tmp) or\n\tdodie \"ioctl TIOCSPTLCK for /dev/ptmx failed\";\n\n    # ptsname()\n    ioctl($ptm, $TIOCGPTN, $tmp) or\n\tdodie \"ioctl TIOCGPTN for /dev/ptmx failed\";\n    $tmp = unpack(\"i\", $tmp);\n\n    sysopen($pts, \"/dev/pts/$tmp\", O_RDWR | O_NONBLOCK) or\n\tdodie \"Can't open /dev/pts/$tmp\";\n}\n\nsub exec_console {\n    my ($ptm, $pts) = @_;\n\n    close($ptm);\n\n    close(\\*STDIN);\n    close(\\*STDOUT);\n    close(\\*STDERR);\n\n    open(\\*STDIN, '<&', $pts);\n    open(\\*STDOUT, '>&', $pts);\n    open(\\*STDERR, '>&', $pts);\n\n    close($pts);\n\n    exec $console or\n\tdodie \"Can't open console $console\";\n}\n\nsub open_console {\n    my ($ptm) = @_;\n    my $pts = \\*PTSFD;\n    my $pid;\n\n    # save terminal settings\n    $stty_orig = `stty -g`;\n\n    # place terminal in cbreak mode so that stdin can be read one character at\n    # a time without having to wait for a newline\n    system(\"stty -icanon -echo -icrnl\");\n\n    create_pty($ptm, $pts);\n\n    $pid = fork;\n\n    if (!$pid) {\n\t# child\n\texec_console($ptm, $pts)\n    }\n\n    # parent\n    close($pts);\n\n    return $pid;\n\n    open(PTSFD, \"Stop perl from warning about single use of PTSFD\");\n}\n\nsub close_console {\n    my ($fp, $pid) = @_;\n\n    doprint \"kill child process $pid\\n\";\n    kill $close_console_signal, $pid;\n\n    doprint \"wait for child process $pid to exit\\n\";\n    waitpid($pid, 0);\n\n    print \"closing!\\n\";\n    close($fp);\n\n    # restore terminal settings\n    system(\"stty $stty_orig\");\n}\n\nsub start_monitor {\n    if ($monitor_cnt++) {\n\treturn;\n    }\n    $monitor_fp = \\*MONFD;\n    $monitor_pid = open_console $monitor_fp;\n\n    return;\n\n    open(MONFD, \"Stop perl from warning about single use of MONFD\");\n}\n\nsub end_monitor {\n    return if (!defined $console);\n    if (--$monitor_cnt) {\n\treturn;\n    }\n    close_console($monitor_fp, $monitor_pid);\n}\n\nsub wait_for_monitor {\n    my ($time, $stop) = @_;\n    my $full_line = \"\";\n    my $line;\n    my $booted = 0;\n    my $start_time = time;\n    my $skip_call_trace = 0;\n    my $bug = 0;\n    my $bug_ignored = 0;\n    my $now;\n\n    doprint \"** Wait for monitor to settle down **\\n\";\n\n    # read the monitor and wait for the system to calm down\n    while (!$booted) {\n\t$line = wait_for_input($monitor_fp, $time);\n\tlast if (!defined($line));\n\tprint \"$line\";\n\t$full_line .= $line;\n\n\tif (defined($stop) && $full_line =~ /$stop/) {\n\t    doprint \"wait for monitor detected $stop\\n\";\n\t    $booted = 1;\n\t}\n\n\tif ($full_line =~ /\\[ backtrace testing \\]/) {\n\t    $skip_call_trace = 1;\n\t}\n\n\tif ($full_line =~ /call trace:/i) {\n\t    if (!$bug && !$skip_call_trace) {\n\t\tif ($ignore_errors) {\n\t\t    $bug_ignored = 1;\n\t\t} else {\n\t\t    $bug = 1;\n\t\t}\n\t    }\n\t}\n\n\tif ($full_line =~ /\\[ end of backtrace testing \\]/) {\n\t    $skip_call_trace = 0;\n\t}\n\n\tif ($full_line =~ /Kernel panic -/) {\n\t    $bug = 1;\n\t}\n\n\tif ($line =~ /\\n/) {\n\t    $full_line = \"\";\n\t}\n\t$now = time;\n\tif ($now - $start_time >= $max_monitor_wait) {\n\t    doprint \"Exiting monitor flush due to hitting MAX_MONITOR_WAIT\\n\";\n\t    return 1;\n\t}\n    }\n    print \"** Monitor flushed **\\n\";\n\n    # if stop is defined but wasn't hit, return error\n    # used by reboot (which wants to see a reboot)\n    if (defined($stop) && !$booted) {\n\t$bug = 1;\n    }\n    return $bug;\n}\n\nsub save_logs {\n    my ($result, $basedir) = @_;\n    my @t = localtime;\n    my $date = sprintf \"%04d%02d%02d%02d%02d%02d\",\n\t1900+$t[5],$t[4],$t[3],$t[2],$t[1],$t[0];\n\n    my $type = $build_type;\n    if ($type =~ /useconfig/) {\n\t$type = \"useconfig\";\n    }\n\n    my $dir = \"$machine-$test_type-$type-$result-$date\";\n\n    $dir = \"$basedir/$dir\";\n\n    if (!-d $dir) {\n\tmkpath($dir) or\n\t    dodie \"can't create $dir\";\n    }\n\n    my %files = (\n\t\"config\" => $output_config,\n\t\"buildlog\" => $buildlog,\n\t\"dmesg\" => $dmesg,\n\t\"testlog\" => $testlog,\n    );\n\n    while (my ($name, $source) = each(%files)) {\n\tif (-f \"$source\") {\n\t    cp \"$source\", \"$dir/$name\" or\n\t\tdodie \"failed to copy $source\";\n\t}\n    }\n\n    doprint \"*** Saved info to $dir ***\\n\";\n}\n\nsub fail {\n\n    if ($die_on_failure) {\n\tdodie @_;\n    }\n\n    doprint \"FAILED\\n\";\n\n    my $i = $iteration;\n\n    # no need to reboot for just building.\n    if (!do_not_reboot) {\n\tdoprint \"REBOOTING\\n\";\n\treboot_to_good $sleep_time;\n    }\n\n    my $name = \"\";\n\n    if (defined($test_name)) {\n\t$name = \" ($test_name)\";\n    }\n\n    print_times;\n\n    doprint \"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\";\n    doprint \"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\";\n    doprint \"KTEST RESULT: TEST $i$name Failed: \", @_, \"\\n\";\n    doprint \"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\";\n    doprint \"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\";\n\n    if (defined($store_failures)) {\n\tsave_logs \"fail\", $store_failures;\n    }\n\n    if (defined($post_test)) {\n\trun_command $post_test;\n    }\n\n    return 1;\n}\n\nsub run_command {\n    my ($command, $redirect, $timeout) = @_;\n    my $start_time;\n    my $end_time;\n    my $dolog = 0;\n    my $dord = 0;\n    my $dostdout = 0;\n    my $pid;\n    my $command_orig = $command;\n\n    $command =~ s/\\$SSH_USER/$ssh_user/g;\n    $command =~ s/\\$MACHINE/$machine/g;\n\n    if (!defined($timeout)) {\n\t$timeout = $run_timeout;\n    }\n\n    if (!defined($timeout)) {\n\t$timeout = -1; # tell wait_for_input to wait indefinitely\n    }\n\n    doprint(\"$command ... \");\n    $start_time = time;\n\n    $pid = open(CMD, \"$command 2>&1 |\") or\n\t(fail \"unable to exec $command\" and return 0);\n\n    if (defined($opt{\"LOG_FILE\"})) {\n\t$dolog = 1;\n    }\n\n    if (defined($redirect)) {\n\tif ($redirect eq 1) {\n\t    $dostdout = 1;\n\t    # Have the output of the command on its own line\n\t    doprint \"\\n\";\n\t} else {\n\t    open (RD, \">$redirect\") or\n\t\tdodie \"failed to write to redirect $redirect\";\n\t    $dord = 1;\n\t}\n    }\n\n    my $hit_timeout = 0;\n\n    while (1) {\n\tmy $fp = \\*CMD;\n\tmy $line = wait_for_input($fp, $timeout);\n\tif (!defined($line)) {\n\t    my $now = time;\n\t    if ($timeout >= 0 && (($now - $start_time) >= $timeout)) {\n\t\tdoprint \"Hit timeout of $timeout, killing process\\n\";\n\t\t$hit_timeout = 1;\n\t\tkill 9, $pid;\n\t    }\n\t    last;\n\t}\n\tprint LOG $line if ($dolog);\n\tprint RD $line if ($dord);\n\tprint $line if ($dostdout);\n    }\n\n    waitpid($pid, 0);\n    # shift 8 for real exit status\n    $run_command_status = $? >> 8;\n\n    if ($command_orig eq $default{REBOOT} &&\n\t$run_command_status == $reboot_return_code) {\n\t$run_command_status = 0;\n    }\n\n    close(CMD);\n    close(RD)  if ($dord);\n\n    $end_time = time;\n    my $delta = $end_time - $start_time;\n\n    if ($delta == 1) {\n\tdoprint \"[1 second] \";\n    } else {\n\tdoprint \"[$delta seconds] \";\n    }\n\n    if ($hit_timeout) {\n\t$run_command_status = 1;\n    }\n\n    if ($run_command_status) {\n\tdoprint \"FAILED!\\n\";\n    } else {\n\tdoprint \"SUCCESS\\n\";\n    }\n\n    return !$run_command_status;\n}\n\nsub run_ssh {\n    my ($cmd, $timeout) = @_;\n    my $cp_exec = $ssh_exec;\n\n    $cp_exec =~ s/\\$SSH_COMMAND/$cmd/g;\n    return run_command \"$cp_exec\", undef , $timeout;\n}\n\nsub run_scp {\n    my ($src, $dst, $cp_scp) = @_;\n\n    $cp_scp =~ s/\\$SRC_FILE/$src/g;\n    $cp_scp =~ s/\\$DST_FILE/$dst/g;\n\n    return run_command \"$cp_scp\";\n}\n\nsub run_scp_install {\n    my ($src, $dst) = @_;\n\n    my $cp_scp = $scp_to_target_install;\n\n    return run_scp($src, $dst, $cp_scp);\n}\n\nsub run_scp_mod {\n    my ($src, $dst) = @_;\n\n    my $cp_scp = $scp_to_target;\n\n    return run_scp($src, $dst, $cp_scp);\n}\n\nsub _get_grub_index {\n\n    my ($command, $target, $skip, $submenu) = @_;\n\n    return if (defined($grub_number) && defined($last_grub_menu) &&\n\t$last_grub_menu eq $grub_menu && defined($last_machine) &&\n\t$last_machine eq $machine);\n\n    doprint \"Find $reboot_type menu ... \";\n    $grub_number = -1;\n\n    my $ssh_grub = $ssh_exec;\n    $ssh_grub =~ s,\\$SSH_COMMAND,$command,g;\n\n    open(IN, \"$ssh_grub |\") or\n\tdodie \"unable to execute $command\";\n\n    my $found = 0;\n\n    my $submenu_number = 0;\n\n    while (<IN>) {\n\tif (/$target/) {\n\t    $grub_number++;\n\t    $found = 1;\n\t    last;\n\t} elsif (defined($submenu) && /$submenu/) {\n\t\t$submenu_number++;\n\t\t$grub_number = -1;\n\t} elsif (/$skip/) {\n\t    $grub_number++;\n\t}\n    }\n    close(IN);\n\n    dodie \"Could not find '$grub_menu' through $command on $machine\"\n\tif (!$found);\n    if ($submenu_number > 0) {\n\t$grub_number = \"$submenu_number>$grub_number\";\n    }\n    doprint \"$grub_number\\n\";\n    $last_grub_menu = $grub_menu;\n    $last_machine = $machine;\n}\n\nsub get_grub_index {\n\n    my $command;\n    my $target;\n    my $skip;\n    my $submenu;\n    my $grub_menu_qt;\n\n    if ($reboot_type !~ /^grub/) {\n\treturn;\n    }\n\n    $grub_menu_qt = quotemeta($grub_menu);\n\n    if ($reboot_type eq \"grub\") {\n\t$command = \"cat /boot/grub/menu.lst\";\n\t$target = '^\\s*title\\s+' . $grub_menu_qt . '\\s*$';\n\t$skip = '^\\s*title\\s';\n    } elsif ($reboot_type eq \"grub2\") {\n\t$command = \"cat $grub_file\";\n\t$target = '^\\s*menuentry.*' . $grub_menu_qt;\n\t$skip = '^\\s*menuentry';\n\t$submenu = '^\\s*submenu\\s';\n    } elsif ($reboot_type eq \"grub2bls\") {\n\t$command = $grub_bls_get;\n\t$target = '^title=.*' . $grub_menu_qt;\n\t$skip = '^title=';\n    } else {\n\treturn;\n    }\n\n    _get_grub_index($command, $target, $skip, $submenu);\n}\n\nsub wait_for_input {\n    my ($fp, $time) = @_;\n    my $start_time;\n    my $rin;\n    my $rout;\n    my $nr;\n    my $buf;\n    my $line;\n    my $ch;\n\n    if (!defined($time)) {\n\t$time = $timeout;\n    }\n\n    if ($time < 0) {\n\t# Negative number means wait indefinitely\n\tundef $time;\n    }\n\n    $rin = '';\n    vec($rin, fileno($fp), 1) = 1;\n    vec($rin, fileno(\\*STDIN), 1) = 1;\n\n    $start_time = time;\n\n    while (1) {\n\t$nr = select($rout=$rin, undef, undef, $time);\n\n\tlast if ($nr <= 0);\n\n\t# copy data from stdin to the console\n\tif (vec($rout, fileno(\\*STDIN), 1) == 1) {\n\t    $nr = sysread(\\*STDIN, $buf, 1000);\n\t    syswrite($fp, $buf, $nr) if ($nr > 0);\n\t}\n\n\t# The timeout is based on time waiting for the fp data\n\tif (vec($rout, fileno($fp), 1) != 1) {\n\t    last if (defined($time) && (time - $start_time > $time));\n\t    next;\n\t}\n\n\t$line = \"\";\n\n\t# try to read one char at a time\n\twhile (sysread $fp, $ch, 1) {\n\t    $line .= $ch;\n\t    last if ($ch eq \"\\n\");\n\t}\n\n\tlast if (!length($line));\n\n\treturn $line;\n    }\n    return undef;\n}\n\nsub reboot_to {\n    if (defined($switch_to_test)) {\n\trun_command $switch_to_test;\n    }\n\n    if ($reboot_type eq \"grub\") {\n\trun_ssh \"'(echo \\\"savedefault --default=$grub_number --once\\\" | grub --batch)'\";\n    } elsif (($reboot_type eq \"grub2\") or ($reboot_type eq \"grub2bls\")) {\n\trun_ssh \"$grub_reboot \\\"'$grub_number'\\\"\";\n    } elsif ($reboot_type eq \"syslinux\") {\n\trun_ssh \"$syslinux --once \\\\\\\"$syslinux_label\\\\\\\" $syslinux_path\";\n    } elsif (defined $reboot_script) {\n\trun_command \"$reboot_script\";\n    }\n    reboot;\n}\n\nsub get_sha1 {\n    my ($commit) = @_;\n\n    doprint \"git rev-list --max-count=1 $commit ... \";\n    my $sha1 = `git rev-list --max-count=1 $commit`;\n    my $ret = $?;\n\n    logit $sha1;\n\n    if ($ret) {\n\tdoprint \"FAILED\\n\";\n\tdodie \"Failed to get git $commit\";\n    }\n\n    print \"SUCCESS\\n\";\n\n    chomp $sha1;\n\n    return $sha1;\n}\n\nsub monitor {\n    my $booted = 0;\n    my $bug = 0;\n    my $bug_ignored = 0;\n    my $skip_call_trace = 0;\n    my $loops;\n\n    my $start_time = time;\n\n    wait_for_monitor 5;\n\n    my $line;\n    my $full_line = \"\";\n\n    open(DMESG, \"> $dmesg\") or\n\tdodie \"unable to write to $dmesg\";\n\n    reboot_to;\n\n    my $success_start;\n    my $failure_start;\n    my $monitor_start = time;\n    my $done = 0;\n    my $version_found = 0;\n\n    while (!$done) {\n\tif ($bug && defined($stop_after_failure) &&\n\t    $stop_after_failure >= 0) {\n\t    my $time = $stop_after_failure - (time - $failure_start);\n\t    $line = wait_for_input($monitor_fp, $time);\n\t    if (!defined($line)) {\n\t\tdoprint \"bug timed out after $booted_timeout seconds\\n\";\n\t\tdoprint \"Test forced to stop after $stop_after_failure seconds after failure\\n\";\n\t\tlast;\n\t    }\n\t} elsif ($booted) {\n\t    $line = wait_for_input($monitor_fp, $booted_timeout);\n\t    if (!defined($line)) {\n\t\tmy $s = $booted_timeout == 1 ? \"\" : \"s\";\n\t\tdoprint \"Successful boot found: break after $booted_timeout second$s\\n\";\n\t\tlast;\n\t    }\n\t} else {\n\t    $line = wait_for_input($monitor_fp);\n\t    if (!defined($line)) {\n\t\tmy $s = $timeout == 1 ? \"\" : \"s\";\n\t\tdoprint \"Timed out after $timeout second$s\\n\";\n\t\tlast;\n\t    }\n\t}\n\n\tdoprint $line;\n\tprint DMESG $line;\n\n\t# we are not guaranteed to get a full line\n\t$full_line .= $line;\n\n\tif ($full_line =~ /$success_line/) {\n\t    $booted = 1;\n\t    $success_start = time;\n\t}\n\n\tif ($booted && defined($stop_after_success) &&\n\t    $stop_after_success >= 0) {\n\t    my $now = time;\n\t    if ($now - $success_start >= $stop_after_success) {\n\t\tdoprint \"Test forced to stop after $stop_after_success seconds after success\\n\";\n\t\tlast;\n\t    }\n\t}\n\n\tif ($full_line =~ /\\[ backtrace testing \\]/) {\n\t    $skip_call_trace = 1;\n\t}\n\n\tif ($full_line =~ /call trace:/i) {\n\t    if (!$bug && !$skip_call_trace) {\n\t\tif ($ignore_errors) {\n\t\t    $bug_ignored = 1;\n\t\t} else {\n\t\t    $bug = 1;\n\t\t    $failure_start = time;\n\t\t}\n\t    }\n\t}\n\n\tif ($bug && defined($stop_after_failure) &&\n\t    $stop_after_failure >= 0) {\n\t    my $now = time;\n\t    if ($now - $failure_start >= $stop_after_failure) {\n\t\tdoprint \"Test forced to stop after $stop_after_failure seconds after failure\\n\";\n\t\tlast;\n\t    }\n\t}\n\n\tif ($full_line =~ /\\[ end of backtrace testing \\]/) {\n\t    $skip_call_trace = 0;\n\t}\n\n\tif ($full_line =~ /Kernel panic -/) {\n\t    $failure_start = time;\n\t    $bug = 1;\n\t}\n\n\t# Detect triple faults by testing the banner\n\tif ($full_line =~ /\\bLinux version (\\S+).*\\n/) {\n\t    if ($1 eq $version) {\n\t\t$version_found = 1;\n\t    } elsif ($version_found && $detect_triplefault) {\n\t\t# We already booted into the kernel we are testing,\n\t\t# but now we booted into another kernel?\n\t\t# Consider this a triple fault.\n\t\tdoprint \"Already booted in Linux kernel $version, but now\\n\";\n\t\tdoprint \"we booted into Linux kernel $1.\\n\";\n\t\tdoprint \"Assuming that this is a triple fault.\\n\";\n\t\tdoprint \"To disable this: set DETECT_TRIPLE_FAULT to 0\\n\";\n\t\tlast;\n\t    }\n\t}\n\n\tif ($line =~ /\\n/) {\n\t    $full_line = \"\";\n\t}\n\n\tif ($stop_test_after > 0 && !$booted && !$bug) {\n\t    if (time - $monitor_start > $stop_test_after) {\n\t\tdoprint \"STOP_TEST_AFTER ($stop_test_after seconds) timed out\\n\";\n\t\t$done = 1;\n\t    }\n\t}\n    }\n\n    my $end_time = time;\n    $reboot_time = $end_time - $start_time;\n\n    close(DMESG);\n\n    if ($bug) {\n\treturn 0 if ($in_bisect);\n\tfail \"failed - got a bug report\" and return 0;\n    }\n\n    if (!$booted) {\n\treturn 0 if ($in_bisect);\n\tfail \"failed - never got a boot prompt.\" and return 0;\n    }\n\n    if ($bug_ignored) {\n\tdoprint \"WARNING: Call Trace detected but ignored due to IGNORE_ERRORS=1\\n\";\n    }\n\n    return 1;\n}\n\nsub eval_kernel_version {\n    my ($option) = @_;\n\n    $option =~ s/\\$KERNEL_VERSION/$version/g;\n\n    return $option;\n}\n\nsub do_post_install {\n\n    return if (!defined($post_install));\n\n    my $cp_post_install = eval_kernel_version $post_install;\n    run_command \"$cp_post_install\" or\n\tdodie \"Failed to run post install\";\n}\n\n# Sometimes the reboot fails, and will hang. We try to ssh to the box\n# and if we fail, we force another reboot, that should powercycle it.\nsub test_booted {\n    if (!run_ssh \"echo testing connection\") {\n\treboot $sleep_time;\n    }\n}\n\nsub install {\n\n    return if ($no_install);\n\n    my $start_time = time;\n\n    if (defined($pre_install)) {\n\tmy $cp_pre_install = eval_kernel_version $pre_install;\n\trun_command \"$cp_pre_install\" or\n\t    dodie \"Failed to run pre install\";\n    }\n\n    my $cp_target = eval_kernel_version $target_image;\n\n    test_booted;\n\n    run_scp_install \"$outputdir/$build_target\", \"$cp_target\" or\n\tdodie \"failed to copy image\";\n\n    my $install_mods = 0;\n\n    # should we process modules?\n    $install_mods = 0;\n    open(IN, \"$output_config\") or dodie(\"Can't read config file\");\n    while (<IN>) {\n\tif (/CONFIG_MODULES(=y)?/) {\n\t    if (defined($1)) {\n\t\t$install_mods = 1;\n\t\tlast;\n\t    }\n\t}\n    }\n    close(IN);\n\n    if (!$install_mods) {\n\tdo_post_install;\n\tdoprint \"No modules needed\\n\";\n\tmy $end_time = time;\n\t$install_time = $end_time - $start_time;\n\treturn;\n    }\n\n    run_command \"$make INSTALL_MOD_STRIP=1 INSTALL_MOD_PATH=$tmpdir modules_install\" or\n\tdodie \"Failed to install modules\";\n\n    my $modlib = \"/lib/modules/$version\";\n    my $modtar = \"ktest-mods.tar.bz2\";\n\n    run_ssh \"rm -rf $modlib\" or\n\tdodie \"failed to remove old mods: $modlib\";\n\n    # would be nice if scp -r did not follow symbolic links\n    run_command \"cd $tmpdir && tar -cjf $modtar lib/modules/$version\" or\n\tdodie \"making tarball\";\n\n    run_scp_mod \"$tmpdir/$modtar\", \"/tmp\" or\n\tdodie \"failed to copy modules\";\n\n    unlink \"$tmpdir/$modtar\";\n\n    run_ssh \"'(cd / && tar xjf /tmp/$modtar)'\" or\n\tdodie \"failed to tar modules\";\n\n    run_ssh \"rm -f /tmp/$modtar\";\n\n    do_post_install;\n\n    my $end_time = time;\n    $install_time = $end_time - $start_time;\n}\n\nsub get_version {\n    # get the release name\n    return if ($have_version);\n    doprint \"$make kernelrelease ... \";\n    $version = `$make -s kernelrelease | tail -1`;\n    chomp($version);\n    doprint \"$version\\n\";\n    $have_version = 1;\n}\n\nsub start_monitor_and_install {\n    # Make sure the stable kernel has finished booting\n\n    # Install bisects, don't need console\n    if (defined $console) {\n\tstart_monitor;\n\twait_for_monitor 5;\n\tend_monitor;\n    }\n\n    get_grub_index;\n    get_version;\n    install;\n\n    start_monitor if (defined $console);\n    return monitor;\n}\n\nsub process_warning_line {\n    my ($line) = @_;\n\n    chomp $line;\n\n    # for distcc heterogeneous systems, some compilers\n    # do things differently causing warning lines\n    # to be slightly different. This makes an attempt\n    # to fixe those issues.\n\n    # chop off the index into the line\n    # using distcc, some compilers give different indexes\n    # depending on white space\n    $line =~ s/^(\\s*\\S+:\\d+:)\\d+/$1/;\n\n    # Some compilers use UTF-8 extended for quotes and some don't.\n    $line =~ s/$utf8_quote/'/g;\n\n    return $line;\n}\n\n# Read buildlog and check against warnings file for any\n# new warnings.\n#\n# Returns 1 if OK\n#         0 otherwise\nsub check_buildlog {\n    return 1 if (!defined $warnings_file);\n\n    my %warnings_list;\n\n    # Failed builds should not reboot the target\n    my $save_no_reboot = $no_reboot;\n    $no_reboot = 1;\n\n    if (-f $warnings_file) {\n\topen(IN, $warnings_file) or\n\t    dodie \"Error opening $warnings_file\";\n\n\twhile (<IN>) {\n\t    if (/$check_build_re/) {\n\t\tmy $warning = process_warning_line $_;\n\n\t\t$warnings_list{$warning} = 1;\n\t    }\n\t}\n\tclose(IN);\n    }\n\n    # If warnings file didn't exist, and WARNINGS_FILE exist,\n    # then we fail on any warning!\n\n    open(IN, $buildlog) or dodie \"Can't open $buildlog\";\n    while (<IN>) {\n\tif (/$check_build_re/) {\n\t    my $warning = process_warning_line $_;\n\n\t    if (!defined $warnings_list{$warning}) {\n\t\tfail \"New warning found (not in $warnings_file)\\n$_\\n\";\n\t\t$no_reboot = $save_no_reboot;\n\t\treturn 0;\n\t    }\n\t}\n    }\n    $no_reboot = $save_no_reboot;\n    close(IN);\n}\n\nsub check_patch_buildlog {\n    my ($patch) = @_;\n\n    my @files = `git show $patch | diffstat -l`;\n\n    foreach my $file (@files) {\n\tchomp $file;\n    }\n\n    open(IN, \"git show $patch |\") or\n\tdodie \"failed to show $patch\";\n    while (<IN>) {\n\tif (m,^--- a/(.*),) {\n\t    chomp $1;\n\t    $files[$#files] = $1;\n\t}\n    }\n    close(IN);\n\n    open(IN, $buildlog) or dodie \"Can't open $buildlog\";\n    while (<IN>) {\n\tif (/^\\s*(.*?):.*(warning|error)/) {\n\t    my $err = $1;\n\t    foreach my $file (@files) {\n\t\tmy $fullpath = \"$builddir/$file\";\n\t\tif ($file eq $err || $fullpath eq $err) {\n\t\t    fail \"$file built with warnings\" and return 0;\n\t\t}\n\t    }\n\t}\n    }\n    close(IN);\n\n    return 1;\n}\n\nsub apply_min_config {\n    my $outconfig = \"$output_config.new\";\n\n    # Read the config file and remove anything that\n    # is in the force_config hash (from minconfig and others)\n    # then add the force config back.\n\n    doprint \"Applying minimum configurations into $output_config.new\\n\";\n\n    open (OUT, \">$outconfig\") or\n\tdodie \"Can't create $outconfig\";\n\n    if (-f $output_config) {\n\topen (IN, $output_config) or\n\t    dodie \"Failed to open $output_config\";\n\twhile (<IN>) {\n\t    if (/^(# )?(CONFIG_[^\\s=]*)/) {\n\t\tnext if (defined($force_config{$2}));\n\t    }\n\t    print OUT;\n\t}\n\tclose IN;\n    }\n    foreach my $config (keys %force_config) {\n\tprint OUT \"$force_config{$config}\\n\";\n    }\n    close OUT;\n\n    run_command \"mv $outconfig $output_config\";\n}\n\nsub make_oldconfig {\n\n    my @force_list = keys %force_config;\n\n    if ($#force_list >= 0) {\n\tapply_min_config;\n    }\n\n    if (!run_command \"$make olddefconfig\") {\n\t# Perhaps olddefconfig doesn't exist in this version of the kernel\n\t# try oldnoconfig\n\tdoprint \"olddefconfig failed, trying make oldnoconfig\\n\";\n\tif (!run_command \"$make oldnoconfig\") {\n\t    doprint \"oldnoconfig failed, trying yes '' | make oldconfig\\n\";\n\t    # try a yes '' | oldconfig\n\t    run_command \"yes '' | $make oldconfig\" or\n\t\tdodie \"failed make config oldconfig\";\n\t}\n    }\n}\n\n# read a config file and use this to force new configs.\nsub load_force_config {\n    my ($config) = @_;\n\n    doprint \"Loading force configs from $config\\n\";\n    open(IN, $config) or\n\tdodie \"failed to read $config\";\n    while (<IN>) {\n\tchomp;\n\tif (/^(CONFIG[^\\s=]*)(\\s*=.*)/) {\n\t    $force_config{$1} = $_;\n\t} elsif (/^# (CONFIG_\\S*) is not set/) {\n\t    $force_config{$1} = $_;\n\t}\n    }\n    close IN;\n}\n\nsub build {\n    my ($type) = @_;\n\n    unlink $buildlog;\n\n    my $start_time = time;\n\n    # Failed builds should not reboot the target\n    my $save_no_reboot = $no_reboot;\n    $no_reboot = 1;\n\n    # Calculate a new version from here.\n    $have_version = 0;\n\n    if (defined($pre_build)) {\n\tmy $ret = run_command $pre_build;\n\tif (!$ret && defined($pre_build_die) &&\n\t    $pre_build_die) {\n\t    dodie \"failed to pre_build\\n\";\n\t}\n    }\n\n    if ($type =~ /^useconfig:(.*)/) {\n\trun_command \"cp $1 $output_config\" or\n\t    dodie \"could not copy $1 to .config\";\n\n\t$type = \"oldconfig\";\n    }\n\n    # old config can ask questions\n    if ($type eq \"oldconfig\") {\n\t$type = \"olddefconfig\";\n\n\t# allow for empty configs\n\trun_command \"touch $output_config\";\n\n\tif (!$noclean) {\n\t    run_command \"mv $output_config $outputdir/config_temp\" or\n\t\tdodie \"moving .config\";\n\n\t    run_command \"$make mrproper\" or dodie \"make mrproper\";\n\n\t    run_command \"mv $outputdir/config_temp $output_config\" or\n\t\tdodie \"moving config_temp\";\n\t}\n    } elsif (!$noclean) {\n\tunlink \"$output_config\";\n\trun_command \"$make mrproper\" or\n\t    dodie \"make mrproper\";\n    }\n\n    # add something to distinguish this build\n    open(OUT, \"> $outputdir/localversion\") or dodie(\"Can't make localversion file\");\n    print OUT \"$localversion\\n\";\n    close(OUT);\n\n    if (defined($minconfig)) {\n\tload_force_config($minconfig);\n    }\n\n    if ($type ne \"olddefconfig\") {\n\trun_command \"$make $type\" or\n\t    dodie \"failed make config\";\n    }\n    # Run old config regardless, to enforce min configurations\n    make_oldconfig;\n\n    if (not defined($build_options)){\n\t$build_options = \"\";\n    }\n    my $build_ret = run_command \"$make $build_options\", $buildlog;\n\n    if (defined($post_build)) {\n\t# Because a post build may change the kernel version\n\t# do it now.\n\tget_version;\n\tmy $ret = run_command $post_build;\n\tif (!$ret && defined($post_build_die) &&\n\t    $post_build_die) {\n\t    dodie \"failed to post_build\\n\";\n\t}\n    }\n\n    if (!$build_ret) {\n\t# bisect may need this to pass\n\tif ($in_bisect) {\n\t    $no_reboot = $save_no_reboot;\n\t    return 0;\n\t}\n\tfail \"failed build\" and return 0;\n    }\n\n    $no_reboot = $save_no_reboot;\n\n    my $end_time = time;\n    $build_time = $end_time - $start_time;\n\n    return 1;\n}\n\nsub halt {\n    if (!run_ssh \"halt\" or defined($power_off)) {\n\tif (defined($poweroff_after_halt)) {\n\t    sleep $poweroff_after_halt;\n\t    run_command \"$power_off\";\n\t}\n    } else {\n\t# nope? the zap it!\n\trun_command \"$power_off\";\n    }\n}\n\nsub success {\n    my ($i) = @_;\n\n    $successes++;\n\n    my $name = \"\";\n\n    if (defined($test_name)) {\n\t$name = \" ($test_name)\";\n    }\n\n    print_times;\n\n    doprint \"\\n\\n\";\n    doprint \"*******************************************\\n\";\n    doprint \"*******************************************\\n\";\n    doprint \"KTEST RESULT: TEST $i$name SUCCESS!!!!   **\\n\";\n    doprint \"*******************************************\\n\";\n    doprint \"*******************************************\\n\";\n\n    if (defined($store_successes)) {\n\tsave_logs \"success\", $store_successes;\n    }\n\n    if ($i != $opt{\"NUM_TESTS\"} && !do_not_reboot) {\n\tdoprint \"Reboot and wait $sleep_time seconds\\n\";\n\treboot_to_good $sleep_time;\n    }\n\n    if (defined($post_test)) {\n\trun_command $post_test;\n    }\n}\n\nsub answer_bisect {\n    for (;;) {\n\tdoprint \"Pass, fail, or skip? [p/f/s]\";\n\tmy $ans = <STDIN>;\n\tchomp $ans;\n\tif ($ans eq \"p\" || $ans eq \"P\") {\n\t    return 1;\n\t} elsif ($ans eq \"f\" || $ans eq \"F\") {\n\t    return 0;\n\t} elsif ($ans eq \"s\" || $ans eq \"S\") {\n\t    return -1;\n\t} else {\n\t    print \"Please answer 'p', 'f', or 's'\\n\";\n\t}\n    }\n}\n\nsub child_run_test {\n\n    # child should have no power\n    $reboot_on_error = 0;\n    $poweroff_on_error = 0;\n    $die_on_failure = 1;\n\n    run_command $run_test, $testlog;\n\n    exit $run_command_status;\n}\n\nsub child_finished {\n    $child_done = 1;\n}\n\nsub do_run_test {\n    my $child_pid;\n    my $child_exit;\n    my $line;\n    my $full_line;\n    my $bug = 0;\n    my $bug_ignored = 0;\n\n    my $start_time = time;\n\n    wait_for_monitor 1;\n\n    doprint \"run test $run_test\\n\";\n\n    $child_done = 0;\n\n    $SIG{CHLD} = qw(child_finished);\n\n    $child_pid = fork;\n\n    child_run_test if (!$child_pid);\n\n    $full_line = \"\";\n\n    do {\n\t$line = wait_for_input($monitor_fp, 1);\n\tif (defined($line)) {\n\n\t    # we are not guaranteed to get a full line\n\t    $full_line .= $line;\n\t    doprint $line;\n\n\t    if ($full_line =~ /call trace:/i) {\n\t\tif ($ignore_errors) {\n\t\t    $bug_ignored = 1;\n\t\t} else {\n\t\t    $bug = 1;\n\t\t}\n\t    }\n\n\t    if ($full_line =~ /Kernel panic -/) {\n\t\t$bug = 1;\n\t    }\n\n\t    if ($line =~ /\\n/) {\n\t\t$full_line = \"\";\n\t    }\n\t}\n    } while (!$child_done && !$bug);\n\n    if (!$bug && $bug_ignored) {\n\tdoprint \"WARNING: Call Trace detected but ignored due to IGNORE_ERRORS=1\\n\";\n    }\n\n    if ($bug) {\n\tmy $failure_start = time;\n\tmy $now;\n\tdo {\n\t    $line = wait_for_input($monitor_fp, 1);\n\t    if (defined($line)) {\n\t\tdoprint $line;\n\t    }\n\t    $now = time;\n\t    if ($now - $failure_start >= $stop_after_failure) {\n\t\tlast;\n\t    }\n\t} while (defined($line));\n\n\tdoprint \"Detected kernel crash!\\n\";\n\t# kill the child with extreme prejudice\n\tkill 9, $child_pid;\n    }\n\n    waitpid $child_pid, 0;\n    $child_exit = $? >> 8;\n\n    my $end_time = time;\n    $test_time = $end_time - $start_time;\n\n    if (!$bug && $in_bisect) {\n\tif (defined($bisect_ret_good)) {\n\t    if ($child_exit == $bisect_ret_good) {\n\t\treturn 1;\n\t    }\n\t}\n\tif (defined($bisect_ret_skip)) {\n\t    if ($child_exit == $bisect_ret_skip) {\n\t\treturn -1;\n\t    }\n\t}\n\tif (defined($bisect_ret_abort)) {\n\t    if ($child_exit == $bisect_ret_abort) {\n\t\tfail \"test abort\" and return -2;\n\t    }\n\t}\n\tif (defined($bisect_ret_bad)) {\n\t    if ($child_exit == $bisect_ret_skip) {\n\t\treturn 0;\n\t    }\n\t}\n\tif (defined($bisect_ret_default)) {\n\t    if ($bisect_ret_default eq \"good\") {\n\t\treturn 1;\n\t    } elsif ($bisect_ret_default eq \"bad\") {\n\t\treturn 0;\n\t    } elsif ($bisect_ret_default eq \"skip\") {\n\t\treturn -1;\n\t    } elsif ($bisect_ret_default eq \"abort\") {\n\t\treturn -2;\n\t    } else {\n\t\tfail \"unknown default action: $bisect_ret_default\"\n\t\t    and return -2;\n\t    }\n\t}\n    }\n\n    if ($bug || $child_exit) {\n\treturn 0 if $in_bisect;\n\tfail \"test failed\" and return 0;\n    }\n    return 1;\n}\n\nsub run_git_bisect {\n    my ($command) = @_;\n\n    doprint \"$command ... \";\n\n    my $output = `$command 2>&1`;\n    my $ret = $?;\n\n    logit $output;\n\n    if ($ret) {\n\tdoprint \"FAILED\\n\";\n\tdodie \"Failed to git bisect\";\n    }\n\n    doprint \"SUCCESS\\n\";\n    if ($output =~ m/^(Bisecting: .*\\(roughly \\d+ steps?\\))\\s+\\[([[:xdigit:]]+)\\]/) {\n\tdoprint \"$1 [$2]\\n\";\n    } elsif ($output =~ m/^([[:xdigit:]]+) is the first bad commit/) {\n\t$bisect_bad_commit = $1;\n\tdoprint \"Found bad commit... $1\\n\";\n\treturn 0;\n    } else {\n\t# we already logged it, just print it now.\n\tprint $output;\n    }\n\n    return 1;\n}\n\nsub bisect_reboot {\n    doprint \"Reboot and sleep $bisect_sleep_time seconds\\n\";\n    reboot_to_good $bisect_sleep_time;\n}\n\n# returns 1 on success, 0 on failure, -1 on skip\nsub run_bisect_test {\n    my ($type, $buildtype) = @_;\n\n    my $failed = 0;\n    my $result;\n    my $output;\n    my $ret;\n\n    $in_bisect = 1;\n\n    build $buildtype or $failed = 1;\n\n    if ($type ne \"build\") {\n\tif ($failed && $bisect_skip) {\n\t    $in_bisect = 0;\n\t    return -1;\n\t}\n\tdodie \"Failed on build\" if $failed;\n\n\t# Now boot the box\n\tstart_monitor_and_install or $failed = 1;\n\n\tif ($type ne \"boot\") {\n\t    if ($failed && $bisect_skip) {\n\t\tend_monitor;\n\t\tbisect_reboot;\n\t\t$in_bisect = 0;\n\t\treturn -1;\n\t    }\n\t    dodie \"Failed on boot\" if $failed;\n\n\t    do_run_test or $failed = 1;\n\t}\n\tend_monitor;\n    }\n\n    if ($failed) {\n\t$result = 0;\n    } else {\n\t$result = 1;\n    }\n\n    # reboot the box to a kernel we can ssh to\n    if ($type ne \"build\") {\n\tbisect_reboot;\n    }\n    $in_bisect = 0;\n\n    return $result;\n}\n\nsub run_bisect {\n    my ($type) = @_;\n    my $buildtype = \"oldconfig\";\n\n    # We should have a minconfig to use?\n    if (defined($minconfig)) {\n\t$buildtype = \"useconfig:$minconfig\";\n    }\n\n    # If the user sets bisect_tries to less than 1, then no tries\n    # is a success.\n    my $ret = 1;\n\n    # Still let the user manually decide that though.\n    if ($bisect_tries < 1 && $bisect_manual) {\n\t$ret = answer_bisect;\n    }\n\n    for (my $i = 0; $i < $bisect_tries; $i++) {\n\tif ($bisect_tries > 1) {\n\t    my $t = $i + 1;\n\t    doprint(\"Running bisect trial $t of $bisect_tries:\\n\");\n\t}\n\t$ret = run_bisect_test $type, $buildtype;\n\n\tif ($bisect_manual) {\n\t    $ret = answer_bisect;\n\t}\n\n\tlast if (!$ret);\n    }\n\n    # Are we looking for where it worked, not failed?\n    if ($reverse_bisect && $ret >= 0) {\n\t$ret = !$ret;\n    }\n\n    if ($ret > 0) {\n\treturn \"good\";\n    } elsif ($ret == 0) {\n\treturn  \"bad\";\n    } elsif ($bisect_skip) {\n\tdoprint \"HIT A BAD COMMIT ... SKIPPING\\n\";\n\treturn \"skip\";\n    }\n}\n\nsub update_bisect_replay {\n    my $tmp_log = \"$tmpdir/ktest_bisect_log\";\n    run_command \"git bisect log > $tmp_log\" or\n\tdodie \"can't create bisect log\";\n    return $tmp_log;\n}\n\nsub bisect {\n    my ($i) = @_;\n\n    my $result;\n\n    dodie \"BISECT_GOOD[$i] not defined\\n\"\tif (!defined($bisect_good));\n    dodie \"BISECT_BAD[$i] not defined\\n\"\tif (!defined($bisect_bad));\n    dodie \"BISECT_TYPE[$i] not defined\\n\"\tif (!defined($bisect_type));\n\n    my $good = $bisect_good;\n    my $bad = $bisect_bad;\n    my $type = $bisect_type;\n    my $start = $bisect_start;\n    my $replay = $bisect_replay;\n    my $start_files = $bisect_files;\n\n    if (defined($start_files)) {\n\t$start_files = \" -- \" . $start_files;\n    } else {\n\t$start_files = \"\";\n    }\n\n    # convert to true sha1's\n    $good = get_sha1($good);\n    $bad = get_sha1($bad);\n\n    if (defined($bisect_reverse) && $bisect_reverse == 1) {\n\tdoprint \"Performing a reverse bisect (bad is good, good is bad!)\\n\";\n\t$reverse_bisect = 1;\n    } else {\n\t$reverse_bisect = 0;\n    }\n\n    # Can't have a test without having a test to run\n    if ($type eq \"test\" && !defined($run_test)) {\n\t$type = \"boot\";\n    }\n\n    # Check if a bisect was running\n    my $bisect_start_file = \"$builddir/.git/BISECT_START\";\n\n    my $check = $bisect_check;\n    my $do_check = defined($check) && $check ne \"0\";\n\n    if ( -f $bisect_start_file ) {\n\tprint \"Bisect in progress found\\n\";\n\tif ($do_check) {\n\t    print \" If you say yes, then no checks of good or bad will be done\\n\";\n\t}\n\tif (defined($replay)) {\n\t    print \"** BISECT_REPLAY is defined in config file **\";\n\t    print \" Ignore config option and perform new git bisect log?\\n\";\n\t    if (read_ync \" (yes, no, or cancel) \") {\n\t\t$replay = update_bisect_replay;\n\t\t$do_check = 0;\n\t    }\n\t} elsif (read_yn \"read git log and continue?\") {\n\t    $replay = update_bisect_replay;\n\t    $do_check = 0;\n\t}\n    }\n\n    if ($do_check) {\n\t# get current HEAD\n\tmy $head = get_sha1(\"HEAD\");\n\n\tif ($check ne \"good\") {\n\t    doprint \"TESTING BISECT BAD [$bad]\\n\";\n\t    run_command \"git checkout $bad\" or\n\t\tdodie \"Failed to checkout $bad\";\n\n\t    $result = run_bisect $type;\n\n\t    if ($result ne \"bad\") {\n\t\tfail \"Tested BISECT_BAD [$bad] and it succeeded\" and return 0;\n\t    }\n\t}\n\n\tif ($check ne \"bad\") {\n\t    doprint \"TESTING BISECT GOOD [$good]\\n\";\n\t    run_command \"git checkout $good\" or\n\t\tdodie \"Failed to checkout $good\";\n\n\t    $result = run_bisect $type;\n\n\t    if ($result ne \"good\") {\n\t\tfail \"Tested BISECT_GOOD [$good] and it failed\" and return 0;\n\t    }\n\t}\n\n\t# checkout where we started\n\trun_command \"git checkout $head\" or\n\t    dodie \"Failed to checkout $head\";\n    }\n\n    run_command \"git bisect start$start_files\" or\n\tdodie \"could not start bisect\";\n\n    if (defined($replay)) {\n\trun_command \"git bisect replay $replay\" or\n\t    dodie \"failed to run replay\";\n    } else {\n\trun_command \"git bisect good $good\" or\n\t    dodie \"could not set bisect good to $good\";\n\n\trun_git_bisect \"git bisect bad $bad\" or\n\t    dodie \"could not set bisect bad to $bad\";\n    }\n\n    if (defined($start)) {\n\trun_command \"git checkout $start\" or\n\t    dodie \"failed to checkout $start\";\n    }\n\n    my $test;\n    do {\n\t$result = run_bisect $type;\n\t$test = run_git_bisect \"git bisect $result\";\n\tprint_times;\n    } while ($test);\n\n    run_command \"git bisect log\" or\n\tdodie \"could not capture git bisect log\";\n\n    run_command \"git bisect reset\" or\n\tdodie \"could not reset git bisect\";\n\n    doprint \"Bad commit was [$bisect_bad_commit]\\n\";\n\n    success $i;\n}\n\nsub assign_configs {\n    my ($hash, $config) = @_;\n\n    doprint \"Reading configs from $config\\n\";\n\n    open (IN, $config) or\n\tdodie \"Failed to read $config\";\n\n    while (<IN>) {\n\tchomp;\n\tif (/^((CONFIG\\S*)=.*)/) {\n\t    ${$hash}{$2} = $1;\n\t} elsif (/^(# (CONFIG\\S*) is not set)/) {\n\t    ${$hash}{$2} = $1;\n\t}\n    }\n\n    close(IN);\n}\n\nsub process_config_ignore {\n    my ($config) = @_;\n\n    assign_configs \\%config_ignore, $config;\n}\n\nsub get_dependencies {\n    my ($config) = @_;\n\n    my $arr = $dependency{$config};\n    if (!defined($arr)) {\n\treturn ();\n    }\n\n    my @deps = @{$arr};\n\n    foreach my $dep (@{$arr}) {\n\tprint \"ADD DEP $dep\\n\";\n\t@deps = (@deps, get_dependencies $dep);\n    }\n\n    return @deps;\n}\n\nsub save_config {\n    my ($pc, $file) = @_;\n\n    my %configs = %{$pc};\n\n    doprint \"Saving configs into $file\\n\";\n\n    open(OUT, \">$file\") or dodie \"Can not write to $file\";\n\n    foreach my $config (keys %configs) {\n\tprint OUT \"$configs{$config}\\n\";\n    }\n    close(OUT);\n}\n\nsub create_config {\n    my ($name, $pc) = @_;\n\n    doprint \"Creating old config from $name configs\\n\";\n\n    save_config $pc, $output_config;\n\n    make_oldconfig;\n}\n\nsub run_config_bisect_test {\n    my ($type) = @_;\n\n    my $ret = run_bisect_test $type, \"oldconfig\";\n\n    if ($bisect_manual) {\n\t$ret = answer_bisect;\n    }\n\n    return $ret;\n}\n\nsub config_bisect_end {\n    my ($good, $bad) = @_;\n    my $diffexec = \"diff -u\";\n\n    if (-f \"$builddir/scripts/diffconfig\") {\n\t$diffexec = \"$builddir/scripts/diffconfig\";\n    }\n    doprint \"\\n\\n***************************************\\n\";\n    doprint \"No more config bisecting possible.\\n\";\n    run_command \"$diffexec $good $bad\", 1;\n    doprint \"***************************************\\n\\n\";\n}\n\nsub run_config_bisect {\n    my ($good, $bad, $last_result) = @_;\n    my $reset = \"\";\n    my $cmd;\n    my $ret;\n\n    if (!length($last_result)) {\n\t$reset = \"-r\";\n    }\n    run_command \"$config_bisect_exec $reset -b $outputdir $good $bad $last_result\", 1;\n\n    # config-bisect returns:\n    #   0 if there is more to bisect\n    #   1 for finding a good config\n    #   2 if it can not find any more configs\n    #  -1 (255) on error\n    if ($run_command_status) {\n\treturn $run_command_status;\n    }\n\n    $ret = run_config_bisect_test $config_bisect_type;\n    if ($ret) {\n\tdoprint \"NEW GOOD CONFIG ($pass)\\n\";\n\tsystem(\"cp $output_config $tmpdir/good_config.tmp.$pass\");\n\t$pass++;\n\t# Return 3 for good config\n\treturn 3;\n    } else {\n\tdoprint \"NEW BAD CONFIG ($pass)\\n\";\n\tsystem(\"cp $output_config $tmpdir/bad_config.tmp.$pass\");\n\t$pass++;\n\t# Return 4 for bad config\n\treturn 4;\n    }\n}\n\nsub config_bisect {\n    my ($i) = @_;\n\n    my $good_config;\n    my $bad_config;\n\n    my $type = $config_bisect_type;\n    my $ret;\n\n    $bad_config = $config_bisect;\n\n    if (defined($config_bisect_good)) {\n\t$good_config = $config_bisect_good;\n    } elsif (defined($minconfig)) {\n\t$good_config = $minconfig;\n    } else {\n\tdoprint \"No config specified, checking if defconfig works\";\n\t$ret = run_bisect_test $type, \"defconfig\";\n\tif (!$ret) {\n\t    fail \"Have no good config to compare with, please set CONFIG_BISECT_GOOD\";\n\t    return 1;\n\t}\n\t$good_config = $output_config;\n    }\n\n    if (!defined($config_bisect_exec)) {\n\t# First check the location that ktest.pl ran\n\tmy @locations = (\n\t\t\"$pwd/config-bisect.pl\",\n\t\t\"$dirname/config-bisect.pl\",\n\t\t\"$builddir/tools/testing/ktest/config-bisect.pl\",\n\t\tundef );\n\tforeach my $loc (@locations) {\n\t    doprint \"loc = $loc\\n\";\n\t    $config_bisect_exec = $loc;\n\t    last if (defined($config_bisect_exec && -x $config_bisect_exec));\n\t}\n\tif (!defined($config_bisect_exec)) {\n\t    fail \"Could not find an executable config-bisect.pl\\n\",\n\t\t\"  Set CONFIG_BISECT_EXEC to point to config-bisect.pl\";\n\t    return 1;\n\t}\n    }\n\n    # we don't want min configs to cause issues here.\n    doprint \"Disabling 'MIN_CONFIG' for this test\\n\";\n    undef $minconfig;\n\n    my %good_configs;\n    my %bad_configs;\n    my %tmp_configs;\n\n    if (-f \"$tmpdir/good_config.tmp\" || -f \"$tmpdir/bad_config.tmp\") {\n\tif (read_yn \"Interrupted config-bisect. Continue (n - will start new)?\") {\n\t    if (-f \"$tmpdir/good_config.tmp\") {\n\t\t$good_config = \"$tmpdir/good_config.tmp\";\n\t    } else {\n\t\t$good_config = \"$tmpdir/good_config\";\n\t    }\n\t    if (-f \"$tmpdir/bad_config.tmp\") {\n\t\t$bad_config = \"$tmpdir/bad_config.tmp\";\n\t    } else {\n\t\t$bad_config = \"$tmpdir/bad_config\";\n\t    }\n\t}\n    }\n    doprint \"Run good configs through make oldconfig\\n\";\n    assign_configs \\%tmp_configs, $good_config;\n    create_config \"$good_config\", \\%tmp_configs;\n    $good_config = \"$tmpdir/good_config\";\n    system(\"cp $output_config $good_config\") == 0 or dodie \"cp good config\";\n\n    doprint \"Run bad configs through make oldconfig\\n\";\n    assign_configs \\%tmp_configs, $bad_config;\n    create_config \"$bad_config\", \\%tmp_configs;\n    $bad_config = \"$tmpdir/bad_config\";\n    system(\"cp $output_config $bad_config\") == 0 or dodie \"cp bad config\";\n\n    if (defined($config_bisect_check) && $config_bisect_check ne \"0\") {\n\tif ($config_bisect_check ne \"good\") {\n\t    doprint \"Testing bad config\\n\";\n\n\t    $ret = run_bisect_test $type, \"useconfig:$bad_config\";\n\t    if ($ret) {\n\t\tfail \"Bad config succeeded when expected to fail!\";\n\t\treturn 0;\n\t    }\n\t}\n\tif ($config_bisect_check ne \"bad\") {\n\t    doprint \"Testing good config\\n\";\n\n\t    $ret = run_bisect_test $type, \"useconfig:$good_config\";\n\t    if (!$ret) {\n\t\tfail \"Good config failed when expected to succeed!\";\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    my $last_run = \"\";\n\n    do {\n\t$ret = run_config_bisect $good_config, $bad_config, $last_run;\n\tif ($ret == 3) {\n\t    $last_run = \"good\";\n\t} elsif ($ret == 4) {\n\t    $last_run = \"bad\";\n\t}\n\tprint_times;\n    } while ($ret == 3 || $ret == 4);\n\n    if ($ret == 2) {\n\tconfig_bisect_end \"$good_config.tmp\", \"$bad_config.tmp\";\n    }\n\n    return $ret if ($ret < 0);\n\n    success $i;\n}\n\nsub patchcheck_reboot {\n    doprint \"Reboot and sleep $patchcheck_sleep_time seconds\\n\";\n    reboot_to_good $patchcheck_sleep_time;\n}\n\nsub patchcheck {\n    my ($i) = @_;\n\n    dodie \"PATCHCHECK_START[$i] not defined\\n\"\n\tif (!defined($patchcheck_start));\n    dodie \"PATCHCHECK_TYPE[$i] not defined\\n\"\n\tif (!defined($patchcheck_type));\n\n    my $start = $patchcheck_start;\n\n    my $cherry = $patchcheck_cherry;\n    if (!defined($cherry)) {\n\t$cherry = 0;\n    }\n\n    my $end = \"HEAD\";\n    if (defined($patchcheck_end)) {\n\t$end = $patchcheck_end;\n    } elsif ($cherry) {\n\tdodie \"PATCHCHECK_END must be defined with PATCHCHECK_CHERRY\\n\";\n    }\n\n    # Get the true sha1's since we can use things like HEAD~3\n    $start = get_sha1($start);\n    $end = get_sha1($end);\n\n    my $type = $patchcheck_type;\n\n    # Can't have a test without having a test to run\n    if ($type eq \"test\" && !defined($run_test)) {\n\t$type = \"boot\";\n    }\n\n    if ($cherry) {\n\topen (IN, \"git cherry -v $start $end|\") or\n\t    dodie \"could not get git list\";\n    } else {\n\topen (IN, \"git log --pretty=oneline $end|\") or\n\t    dodie \"could not get git list\";\n    }\n\n    my @list;\n\n    while (<IN>) {\n\tchomp;\n\t# git cherry adds a '+' we want to remove\n\ts/^\\+ //;\n\t$list[$#list+1] = $_;\n\tlast if (/^$start/);\n    }\n    close(IN);\n\n    if (!$cherry) {\n\tif ($list[$#list] !~ /^$start/) {\n\t    fail \"SHA1 $start not found\";\n\t}\n\n\t# go backwards in the list\n\t@list = reverse @list;\n    }\n\n    doprint(\"Going to test the following commits:\\n\");\n    foreach my $l (@list) {\n\tdoprint \"$l\\n\";\n    }\n\n    my $save_clean = $noclean;\n    my %ignored_warnings;\n\n    if (defined($ignore_warnings)) {\n\tforeach my $sha1 (split /\\s+/, $ignore_warnings) {\n\t    $ignored_warnings{$sha1} = 1;\n\t}\n    }\n\n    $in_patchcheck = 1;\n    foreach my $item (@list) {\n\tmy $sha1 = $item;\n\t$sha1 =~ s/^([[:xdigit:]]+).*/$1/;\n\n\tdoprint \"\\nProcessing commit \\\"$item\\\"\\n\\n\";\n\n\trun_command \"git checkout $sha1\" or\n\t    dodie \"Failed to checkout $sha1\";\n\n\t# only clean on the first and last patch\n\tif ($item eq $list[0] ||\n\t    $item eq $list[$#list]) {\n\t    $noclean = $save_clean;\n\t} else {\n\t    $noclean = 1;\n\t}\n\n\tif (defined($minconfig)) {\n\t    build \"useconfig:$minconfig\" or return 0;\n\t} else {\n\t    # ?? no config to use?\n\t    build \"oldconfig\" or return 0;\n\t}\n\n\t# No need to do per patch checking if warnings file exists\n\tif (!defined($warnings_file) && !defined($ignored_warnings{$sha1})) {\n\t    check_patch_buildlog $sha1 or return 0;\n\t}\n\n\tcheck_buildlog or return 0;\n\n\tnext if ($type eq \"build\");\n\n\tmy $failed = 0;\n\n\tstart_monitor_and_install or $failed = 1;\n\n\tif (!$failed && $type ne \"boot\"){\n\t    do_run_test or $failed = 1;\n\t}\n\tend_monitor;\n\tif ($failed) {\n\t    print_times;\n\t    return 0;\n\t}\n\tpatchcheck_reboot;\n\tprint_times;\n    }\n    $in_patchcheck = 0;\n    success $i;\n\n    return 1;\n}\n\nsub add_dep {\n    # $config depends on $dep\n    my ($config, $dep) = @_;\n\n    if (defined($depends{$config})) {\n\t$depends{$config} .= \" \" . $dep;\n    } else {\n\t$depends{$config} = $dep;\n    }\n\n    # record the number of configs depending on $dep\n    if (defined $depcount{$dep}) {\n\t$depcount{$dep}++;\n    } else {\n\t$depcount{$dep} = 1;\n    } \n}\n\n# taken from streamline_config.pl\nsub read_kconfig {\n    my ($kconfig) = @_;\n\n    my $state = \"NONE\";\n    my $config;\n    my @kconfigs;\n\n    my $cont = 0;\n    my $line;\n\n    if (! -f $kconfig) {\n\tdoprint \"file $kconfig does not exist, skipping\\n\";\n\treturn;\n    }\n\n    open(KIN, \"$kconfig\")\n\tor dodie \"Can't open $kconfig\";\n    while (<KIN>) {\n\tchomp;\n\n\t# Make sure that lines ending with \\ continue\n\tif ($cont) {\n\t    $_ = $line . \" \" . $_;\n\t}\n\n\tif (s/\\\\$//) {\n\t    $cont = 1;\n\t    $line = $_;\n\t    next;\n\t}\n\n\t$cont = 0;\n\n\t# collect any Kconfig sources\n\tif (/^source\\s*\"(.*)\"/) {\n\t    $kconfigs[$#kconfigs+1] = $1;\n\t}\n\n\t# configs found\n\tif (/^\\s*(menu)?config\\s+(\\S+)\\s*$/) {\n\t    $state = \"NEW\";\n\t    $config = $2;\n\n\t    for (my $i = 0; $i < $iflevel; $i++) {\n\t\tadd_dep $config, $ifdeps[$i];\n\t    }\n\n\t# collect the depends for the config\n\t} elsif ($state eq \"NEW\" && /^\\s*depends\\s+on\\s+(.*)$/) {\n\n\t    add_dep $config, $1;\n\n\t# Get the configs that select this config\n\t} elsif ($state eq \"NEW\" && /^\\s*select\\s+(\\S+)/) {\n\n\t    # selected by depends on config\n\t    add_dep $1, $config;\n\n\t# Check for if statements\n\t} elsif (/^if\\s+(.*\\S)\\s*$/) {\n\t    my $deps = $1;\n\t    # remove beginning and ending non text\n\t    $deps =~ s/^[^a-zA-Z0-9_]*//;\n\t    $deps =~ s/[^a-zA-Z0-9_]*$//;\n\n\t    my @deps = split /[^a-zA-Z0-9_]+/, $deps;\n\n\t    $ifdeps[$iflevel++] = join ':', @deps;\n\n\t} elsif (/^endif/) {\n\n\t    $iflevel-- if ($iflevel);\n\n\t# stop on \"help\"\n\t} elsif (/^\\s*help\\s*$/) {\n\t    $state = \"NONE\";\n\t}\n    }\n    close(KIN);\n\n    # read in any configs that were found.\n    foreach $kconfig (@kconfigs) {\n\tif (!defined($read_kconfigs{$kconfig})) {\n\t    $read_kconfigs{$kconfig} = 1;\n\t    read_kconfig(\"$builddir/$kconfig\");\n\t}\n    }\n}\n\nsub read_depends {\n    # find out which arch this is by the kconfig file\n    open (IN, $output_config) or\n\tdodie \"Failed to read $output_config\";\n    my $arch;\n    while (<IN>) {\n\tif (m,Linux/(\\S+)\\s+\\S+\\s+Kernel Configuration,) {\n\t    $arch = $1;\n\t    last;\n\t}\n    }\n    close IN;\n\n    if (!defined($arch)) {\n\tdoprint \"Could not find arch from config file\\n\";\n\tdoprint \"no dependencies used\\n\";\n\treturn;\n    }\n\n    # arch is really the subarch, we need to know\n    # what directory to look at.\n    if ($arch eq \"i386\" || $arch eq \"x86_64\") {\n\t$arch = \"x86\";\n    }\n\n    my $kconfig = \"$builddir/arch/$arch/Kconfig\";\n\n    if (! -f $kconfig && $arch =~ /\\d$/) {\n\tmy $orig = $arch;\n\t# some subarchs have numbers, truncate them\n\t$arch =~ s/\\d*$//;\n\t$kconfig = \"$builddir/arch/$arch/Kconfig\";\n\tif (! -f $kconfig) {\n\t    doprint \"No idea what arch dir $orig is for\\n\";\n\t    doprint \"no dependencies used\\n\";\n\t    return;\n\t}\n    }\n\n    read_kconfig($kconfig);\n}\n\nsub make_new_config {\n    my @configs = @_;\n\n    open (OUT, \">$output_config\")\n\tor dodie \"Failed to write $output_config\";\n\n    foreach my $config (@configs) {\n\tprint OUT \"$config\\n\";\n    }\n    close OUT;\n}\n\nsub chomp_config {\n    my ($config) = @_;\n\n    $config =~ s/CONFIG_//;\n\n    return $config;\n}\n\nsub get_depends {\n    my ($dep) = @_;\n\n    my $kconfig = chomp_config $dep;\n\n    $dep = $depends{\"$kconfig\"};\n\n    # the dep string we have saves the dependencies as they\n    # were found, including expressions like ! && ||. We\n    # want to split this out into just an array of configs.\n\n    my $valid = \"A-Za-z_0-9\";\n\n    my @configs;\n\n    while ($dep =~ /[$valid]/) {\n\tif ($dep =~ /^[^$valid]*([$valid]+)/) {\n\t    my $conf = \"CONFIG_\" . $1;\n\n\t    $configs[$#configs + 1] = $conf;\n\n\t    $dep =~ s/^[^$valid]*[$valid]+//;\n\t} else {\n\t    dodie \"this should never happen\";\n\t}\n    }\n\n    return @configs;\n}\n\nsub test_this_config {\n    my ($config) = @_;\n\n    my $found;\n\n    # if we already processed this config, skip it\n    if (defined($processed_configs{$config})) {\n\treturn undef;\n    }\n    $processed_configs{$config} = 1;\n\n    # if this config failed during this round, skip it\n    if (defined($nochange_config{$config})) {\n\treturn undef;\n    }\n\n    my $kconfig = chomp_config $config;\n\n    # Test dependencies first\n    if (defined($depends{\"$kconfig\"})) {\n\tmy @parents = get_depends $config;\n\tforeach my $parent (@parents) {\n\t    # if the parent is in the min config, check it first\n\t    next if (!defined($min_configs{$parent}));\n\t    $found = test_this_config($parent);\n\t    if (defined($found)) {\n\t\treturn $found;\n\t    }\n\t}\n    }\n\n    # Remove this config from the list of configs\n    # do a make olddefconfig and then read the resulting\n    # .config to make sure it is missing the config that\n    # we had before\n    my %configs = %min_configs;\n    $configs{$config} = \"# $config is not set\";\n    make_new_config ((values %configs), (values %keep_configs));\n    make_oldconfig;\n    delete $configs{$config};\n    undef %configs;\n    assign_configs \\%configs, $output_config;\n\n    if (!defined($configs{$config}) || $configs{$config} =~ /^#/) {\n\treturn $config;\n    }\n\n    doprint \"disabling config $config did not change .config\\n\";\n\n    $nochange_config{$config} = 1;\n\n    return undef;\n}\n\nsub make_min_config {\n    my ($i) = @_;\n\n    my $type = $minconfig_type;\n    if ($type ne \"boot\" && $type ne \"test\") {\n\tfail \"Invalid MIN_CONFIG_TYPE '$minconfig_type'\\n\" .\n\t    \" make_min_config works only with 'boot' and 'test'\\n\" and return;\n    }\n\n    if (!defined($output_minconfig)) {\n\tfail \"OUTPUT_MIN_CONFIG not defined\" and return;\n    }\n\n    # If output_minconfig exists, and the start_minconfig\n    # came from min_config, than ask if we should use\n    # that instead.\n    if (-f $output_minconfig && !$start_minconfig_defined) {\n\tprint \"$output_minconfig exists\\n\";\n\tif (!defined($use_output_minconfig)) {\n\t    if (read_yn \" Use it as minconfig?\") {\n\t\t$start_minconfig = $output_minconfig;\n\t    }\n\t} elsif ($use_output_minconfig > 0) {\n\t    doprint \"Using $output_minconfig as MIN_CONFIG\\n\";\n\t    $start_minconfig = $output_minconfig;\n\t} else {\n\t    doprint \"Set to still use MIN_CONFIG as starting point\\n\";\n\t}\n    }\n\n    if (!defined($start_minconfig)) {\n\tfail \"START_MIN_CONFIG or MIN_CONFIG not defined\" and return;\n    }\n\n    my $temp_config = \"$tmpdir/temp_config\";\n\n    # First things first. We build an allnoconfig to find\n    # out what the defaults are that we can't touch.\n    # Some are selections, but we really can't handle selections.\n\n    my $save_minconfig = $minconfig;\n    undef $minconfig;\n\n    run_command \"$make allnoconfig\" or return 0;\n\n    read_depends;\n\n    process_config_ignore $output_config;\n\n    undef %save_configs;\n    undef %min_configs;\n\n    if (defined($ignore_config)) {\n\t# make sure the file exists\n\t`touch $ignore_config`;\n\tassign_configs \\%save_configs, $ignore_config;\n    }\n\n    %keep_configs = %save_configs;\n\n    doprint \"Load initial configs from $start_minconfig\\n\";\n\n    # Look at the current min configs, and save off all the\n    # ones that were set via the allnoconfig\n    assign_configs \\%min_configs, $start_minconfig;\n\n    my @config_keys = keys %min_configs;\n\n    # All configs need a depcount\n    foreach my $config (@config_keys) {\n\tmy $kconfig = chomp_config $config;\n\tif (!defined $depcount{$kconfig}) {\n\t    $depcount{$kconfig} = 0;\n\t}\n    }\n\n    # Remove anything that was set by the make allnoconfig\n    # we shouldn't need them as they get set for us anyway.\n    foreach my $config (@config_keys) {\n\t# Remove anything in the ignore_config\n\tif (defined($keep_configs{$config})) {\n\t    my $file = $ignore_config;\n\t    $file =~ s,.*/(.*?)$,$1,;\n\t    doprint \"$config set by $file ... ignored\\n\";\n\t    delete $min_configs{$config};\n\t    next;\n\t}\n\t# But make sure the settings are the same. If a min config\n\t# sets a selection, we do not want to get rid of it if\n\t# it is not the same as what we have. Just move it into\n\t# the keep configs.\n\tif (defined($config_ignore{$config})) {\n\t    if ($config_ignore{$config} ne $min_configs{$config}) {\n\t\tdoprint \"$config is in allnoconfig as '$config_ignore{$config}'\";\n\t\tdoprint \" but it is '$min_configs{$config}' in minconfig .. keeping\\n\";\n\t\t$keep_configs{$config} = $min_configs{$config};\n\t    } else {\n\t\tdoprint \"$config set by allnoconfig ... ignored\\n\";\n\t    }\n\t    delete $min_configs{$config};\n\t}\n    }\n\n    my $done = 0;\n    my $take_two = 0;\n\n    while (!$done) {\n\tmy $config;\n\tmy $found;\n\n\t# Now disable each config one by one and do a make oldconfig\n\t# till we find a config that changes our list.\n\n\tmy @test_configs = keys %min_configs;\n\n\t# Sort keys by who is most dependent on\n\t@test_configs = sort  { $depcount{chomp_config($b)} <=> $depcount{chomp_config($a)} }\n\t    @test_configs ;\n\n\t# Put configs that did not modify the config at the end.\n\tmy $reset = 1;\n\tfor (my $i = 0; $i < $#test_configs; $i++) {\n\t    if (!defined($nochange_config{$test_configs[0]})) {\n\t\t$reset = 0;\n\t\tlast;\n\t    }\n\t    # This config didn't change the .config last time.\n\t    # Place it at the end\n\t    my $config = shift @test_configs;\n\t    push @test_configs, $config;\n\t}\n\n\t# if every test config has failed to modify the .config file\n\t# in the past, then reset and start over.\n\tif ($reset) {\n\t    undef %nochange_config;\n\t}\n\n\tundef %processed_configs;\n\n\tforeach my $config (@test_configs) {\n\n\t    $found = test_this_config $config;\n\n\t    last if (defined($found));\n\n\t    # oh well, try another config\n\t}\n\n\tif (!defined($found)) {\n\t    # we could have failed due to the nochange_config hash\n\t    # reset and try again\n\t    if (!$take_two) {\n\t\tundef %nochange_config;\n\t\t$take_two = 1;\n\t\tnext;\n\t    }\n\t    doprint \"No more configs found that we can disable\\n\";\n\t    $done = 1;\n\t    last;\n\t}\n\t$take_two = 0;\n\n\t$config = $found;\n\n\tdoprint \"Test with $config disabled\\n\";\n\n\t# set in_bisect to keep build and monitor from dieing\n\t$in_bisect = 1;\n\n\tmy $failed = 0;\n\tbuild \"oldconfig\" or $failed = 1;\n\tif (!$failed) {\n\t    start_monitor_and_install or $failed = 1;\n\n\t    if ($type eq \"test\" && !$failed) {\n\t\tdo_run_test or $failed = 1;\n\t    }\n\n\t    end_monitor;\n\t}\n\n\t$in_bisect = 0;\n\n\tif ($failed) {\n\t    doprint \"$min_configs{$config} is needed to boot the box... keeping\\n\";\n\t    # this config is needed, add it to the ignore list.\n\t    $keep_configs{$config} = $min_configs{$config};\n\t    $save_configs{$config} = $min_configs{$config};\n\t    delete $min_configs{$config};\n\n\t    # update new ignore configs\n\t    if (defined($ignore_config)) {\n\t\topen (OUT, \">$temp_config\") or\n\t\t    dodie \"Can't write to $temp_config\";\n\t\tforeach my $config (keys %save_configs) {\n\t\t    print OUT \"$save_configs{$config}\\n\";\n\t\t}\n\t\tclose OUT;\n\t\trun_command \"mv $temp_config $ignore_config\" or\n\t\t    dodie \"failed to copy update to $ignore_config\";\n\t    }\n\n\t} else {\n\t    # We booted without this config, remove it from the minconfigs.\n\t    doprint \"$config is not needed, disabling\\n\";\n\n\t    delete $min_configs{$config};\n\n\t    # Also disable anything that is not enabled in this config\n\t    my %configs;\n\t    assign_configs \\%configs, $output_config;\n\t    my @config_keys = keys %min_configs;\n\t    foreach my $config (@config_keys) {\n\t\tif (!defined($configs{$config})) {\n\t\t    doprint \"$config is not set, disabling\\n\";\n\t\t    delete $min_configs{$config};\n\t\t}\n\t    }\n\n\t    # Save off all the current mandatory configs\n\t    open (OUT, \">$temp_config\") or\n\t\tdodie \"Can't write to $temp_config\";\n\t    foreach my $config (keys %keep_configs) {\n\t\tprint OUT \"$keep_configs{$config}\\n\";\n\t    }\n\t    foreach my $config (keys %min_configs) {\n\t\tprint OUT \"$min_configs{$config}\\n\";\n\t    }\n\t    close OUT;\n\n\t    run_command \"mv $temp_config $output_minconfig\" or\n\t\tdodie \"failed to copy update to $output_minconfig\";\n\t}\n\n\tdoprint \"Reboot and wait $sleep_time seconds\\n\";\n\treboot_to_good $sleep_time;\n    }\n\n    success $i;\n    return 1;\n}\n\nsub make_warnings_file {\n    my ($i) = @_;\n\n    if (!defined($warnings_file)) {\n\tdodie \"Must define WARNINGS_FILE for make_warnings_file test\";\n    }\n\n    if ($build_type eq \"nobuild\") {\n\tdodie \"BUILD_TYPE can not be 'nobuild' for make_warnings_file test\";\n    }\n\n    build $build_type or dodie \"Failed to build\";\n\n    open(OUT, \">$warnings_file\") or dodie \"Can't create $warnings_file\";\n\n    open(IN, $buildlog) or dodie \"Can't open $buildlog\";\n    while (<IN>) {\n\t# Some compilers use UTF-8 extended for quotes\n\t# for distcc heterogeneous systems, this causes issues\n\ts/$utf8_quote/'/g;\n\n\tif (/$check_build_re/) {\n\t    print OUT;\n\t}\n    }\n    close(IN);\n\n    close(OUT);\n\n    success $i;\n}\n\nsub option_defined {\n    my ($option) = @_;\n\n    if (defined($opt{$option}) && $opt{$option} !~ /^\\s*$/) {\n\treturn 1;\n    }\n\n    return 0;\n}\n\nsub __set_test_option {\n    my ($name, $i) = @_;\n\n    my $option = \"$name\\[$i\\]\";\n\n    if (option_defined($option)) {\n\treturn $opt{$option};\n    }\n\n    foreach my $test (keys %repeat_tests) {\n\tif ($i >= $test &&\n\t    $i < $test + $repeat_tests{$test}) {\n\t    $option = \"$name\\[$test\\]\";\n\t    if (option_defined($option)) {\n\t\treturn $opt{$option};\n\t    }\n\t}\n    }\n\n    if (option_defined($name)) {\n\treturn $opt{$name};\n    }\n\n    return undef;\n}\n\nsub set_test_option {\n    my ($name, $i) = @_;\n\n    my $option = __set_test_option($name, $i);\n    return $option if (!defined($option));\n\n    return eval_option($name, $option, $i);\n}\n\nsub find_mailer {\n    my ($mailer) = @_;\n\n    my @paths = split /:/, $ENV{PATH};\n\n    # sendmail is usually in /usr/sbin\n    $paths[$#paths + 1] = \"/usr/sbin\";\n\n    foreach my $path (@paths) {\n\tif (-x \"$path/$mailer\") {\n\t    return $path;\n\t}\n    }\n\n    return undef;\n}\n\nsub do_send_mail {\n    my ($subject, $message, $file) = @_;\n\n    if (!defined($mail_path)) {\n\t# find the mailer\n\t$mail_path = find_mailer $mailer;\n\tif (!defined($mail_path)) {\n\t    die \"\\nCan not find $mailer in PATH\\n\";\n\t}\n    }\n\n    my $header_file = \"$tmpdir/header\";\n    open (HEAD, \">$header_file\") or die \"Can not create $header_file\\n\";\n    print HEAD \"To: $mailto\\n\";\n    print HEAD \"Subject: $subject\\n\\n\";\n    print HEAD \"$message\\n\";\n    close HEAD;\n\n    if (!defined($mail_command)) {\n\tif ($mailer eq \"mail\" || $mailer eq \"mailx\") {\n\t    $mail_command = \"cat \\$HEADER_FILE \\$BODY_FILE | \\$MAIL_PATH/\\$MAILER -s \\'\\$SUBJECT\\' \\$MAILTO\";\n\t} elsif ($mailer eq \"sendmail\" ) {\n\t    $mail_command =  \"cat \\$HEADER_FILE \\$BODY_FILE | \\$MAIL_PATH/\\$MAILER -t \\$MAILTO\";\n\t} else {\n\t    die \"\\nYour mailer: $mailer is not supported.\\n\";\n\t}\n    }\n\n    if (defined($file)) {\n\t$mail_command =~ s/\\$BODY_FILE/$file/g;\n    } else {\n\t$mail_command =~ s/\\$BODY_FILE//g;\n    }\n\n    $mail_command =~ s/\\$HEADER_FILE/$header_file/g;\n    $mail_command =~ s/\\$MAILER/$mailer/g;\n    $mail_command =~ s/\\$MAIL_PATH/$mail_path/g;\n    $mail_command =~ s/\\$MAILTO/$mailto/g;\n    $mail_command =~ s/\\$SUBJECT/$subject/g;\n    $mail_command =~ s/\\$MESSAGE/$message/g;\n\n    my $ret = run_command $mail_command;\n    if (!$ret && defined($file)) {\n\t# try again without the file\n\t$message .= \"\\n\\n*** FAILED TO SEND LOG ***\\n\\n\";\n\tdo_send_email($subject, $message);\n    }\n}\n\nsub send_email {\n    if (defined($mailto)) {\n\tif (!defined($mailer)) {\n\t    doprint \"No email sent: email or mailer not specified in config.\\n\";\n\t    return;\n\t}\n\tdo_send_mail @_;\n    }\n}\n\nsub cancel_test {\n    if ($monitor_cnt) {\n\tend_monitor;\n    }\n    if ($email_when_canceled) {\n\tmy $name = get_test_name;\n\tsend_email(\"KTEST: Your [$name] test was cancelled\",\n\t    \"Your test started at $script_start_time was cancelled: sig int\");\n    }\n    die \"\\nCaught Sig Int, test interrupted: $!\\n\"\n}\n\n$#ARGV < 1 or die \"ktest.pl version: $VERSION\\n   usage: ktest.pl [config-file]\\n\";\n\nif ($#ARGV == 0) {\n    $ktest_config = $ARGV[0];\n    if (! -f $ktest_config) {\n\tprint \"$ktest_config does not exist.\\n\";\n\tif (!read_yn \"Create it?\") {\n\t    exit 0;\n\t}\n    }\n}\n\nif (! -f $ktest_config) {\n    $newconfig = 1;\n    get_test_case;\n    open(OUT, \">$ktest_config\") or die \"Can not create $ktest_config\";\n    print OUT << \"EOF\"\n# Generated by ktest.pl\n#\n\n# PWD is a ktest.pl variable that will result in the process working\n# directory that ktest.pl is executed in.\n\n# THIS_DIR is automatically assigned the PWD of the path that generated\n# the config file. It is best to use this variable when assigning other\n# directory paths within this directory. This allows you to easily\n# move the test cases to other locations or to other machines.\n#\nTHIS_DIR := $variable{\"PWD\"}\n\n# Define each test with TEST_START\n# The config options below it will override the defaults\nTEST_START\nTEST_TYPE = $default{\"TEST_TYPE\"}\n\nDEFAULTS\nEOF\n;\n    close(OUT);\n}\nread_config $ktest_config;\n\nif (defined($opt{\"LOG_FILE\"})) {\n    $opt{\"LOG_FILE\"} = eval_option(\"LOG_FILE\", $opt{\"LOG_FILE\"}, -1);\n}\n\n# Append any configs entered in manually to the config file.\nmy @new_configs = keys %entered_configs;\nif ($#new_configs >= 0) {\n    print \"\\nAppending entered in configs to $ktest_config\\n\";\n    open(OUT, \">>$ktest_config\") or die \"Can not append to $ktest_config\";\n    foreach my $config (@new_configs) {\n\tprint OUT \"$config = $entered_configs{$config}\\n\";\n\t$opt{$config} = process_variables($entered_configs{$config});\n    }\n}\n\nif (defined($opt{\"LOG_FILE\"})) {\n    if ($opt{\"CLEAR_LOG\"}) {\n\tunlink $opt{\"LOG_FILE\"};\n    }\n    open(LOG, \">> $opt{LOG_FILE}\") or die \"Can't write to $opt{LOG_FILE}\";\n    LOG->autoflush(1);\n}\n\ndoprint \"\\n\\nSTARTING AUTOMATED TESTS\\n\\n\";\n\nfor (my $i = 0, my $repeat = 1; $i <= $opt{\"NUM_TESTS\"}; $i += $repeat) {\n\n    if (!$i) {\n\tdoprint \"DEFAULT OPTIONS:\\n\";\n    } else {\n\tdoprint \"\\nTEST $i OPTIONS\";\n\tif (defined($repeat_tests{$i})) {\n\t    $repeat = $repeat_tests{$i};\n\t    doprint \" ITERATE $repeat\";\n\t}\n\tdoprint \"\\n\";\n    }\n\n    foreach my $option (sort keys %opt) {\n\tif ($option =~ /\\[(\\d+)\\]$/) {\n\t    next if ($i != $1);\n\t} else {\n\t    next if ($i);\n\t}\n\n\tdoprint \"$option = $opt{$option}\\n\";\n    }\n}\n\n$SIG{INT} = qw(cancel_test);\n\n# First we need to do is the builds\nfor (my $i = 1; $i <= $opt{\"NUM_TESTS\"}; $i++) {\n\n    # Do not reboot on failing test options\n    $no_reboot = 1;\n    $reboot_success = 0;\n\n    $have_version = 0;\n\n    $iteration = $i;\n\n    $build_time = 0;\n    $install_time = 0;\n    $reboot_time = 0;\n    $test_time = 0;\n\n    undef %force_config;\n\n    my $makecmd = set_test_option(\"MAKE_CMD\", $i);\n\n    $outputdir = set_test_option(\"OUTPUT_DIR\", $i);\n    $builddir = set_test_option(\"BUILD_DIR\", $i);\n\n    chdir $builddir || dodie \"can't change directory to $builddir\";\n\n    if (!-d $outputdir) {\n\tmkpath($outputdir) or\n\t    dodie \"can't create $outputdir\";\n    }\n\n    $make = \"$makecmd O=$outputdir\";\n\n    # Load all the options into their mapped variable names\n    foreach my $opt (keys %option_map) {\n\t${$option_map{$opt}} = set_test_option($opt, $i);\n    }\n\n    $start_minconfig_defined = 1;\n\n    # The first test may override the PRE_KTEST option\n    if ($i == 1) {\n\tif (defined($pre_ktest)) {\n\t    doprint \"\\n\";\n\t    run_command $pre_ktest;\n\t}\n\tif ($email_when_started) {\n\t    my $name = get_test_name;\n\t    send_email(\"KTEST: Your [$name] test was started\",\n\t\t\"Your test was started on $script_start_time\");\n\t}\n    }\n\n    # Any test can override the POST_KTEST option\n    # The last test takes precedence.\n    if (defined($post_ktest)) {\n\t$final_post_ktest = $post_ktest;\n    }\n\n    if (!defined($start_minconfig)) {\n\t$start_minconfig_defined = 0;\n\t$start_minconfig = $minconfig;\n    }\n\n    if (!-d $tmpdir) {\n\tmkpath($tmpdir) or\n\t    dodie \"can't create $tmpdir\";\n    }\n\n    $ENV{\"SSH_USER\"} = $ssh_user;\n    $ENV{\"MACHINE\"} = $machine;\n\n    $buildlog = \"$tmpdir/buildlog-$machine\";\n    $testlog = \"$tmpdir/testlog-$machine\";\n    $dmesg = \"$tmpdir/dmesg-$machine\";\n    $output_config = \"$outputdir/.config\";\n\n    if (!$buildonly) {\n\t$target = \"$ssh_user\\@$machine\";\n\tif (($reboot_type eq \"grub\") or ($reboot_type eq \"grub2bls\")) {\n\t    dodie \"GRUB_MENU not defined\" if (!defined($grub_menu));\n\t} elsif ($reboot_type eq \"grub2\") {\n\t    dodie \"GRUB_MENU not defined\" if (!defined($grub_menu));\n\t    dodie \"GRUB_FILE not defined\" if (!defined($grub_file));\n\t} elsif ($reboot_type eq \"syslinux\") {\n\t    dodie \"SYSLINUX_LABEL not defined\" if (!defined($syslinux_label));\n\t}\n    }\n\n    my $run_type = $build_type;\n    if ($test_type eq \"patchcheck\") {\n\t$run_type = $patchcheck_type;\n    } elsif ($test_type eq \"bisect\") {\n\t$run_type = $bisect_type;\n    } elsif ($test_type eq \"config_bisect\") {\n\t$run_type = $config_bisect_type;\n    } elsif ($test_type eq \"make_min_config\") {\n\t$run_type = \"\";\n    } elsif ($test_type eq \"make_warnings_file\") {\n\t$run_type = \"\";\n    }\n\n    # mistake in config file?\n    if (!defined($run_type)) {\n\t$run_type = \"ERROR\";\n    }\n\n    my $installme = \"\";\n    $installme = \" no_install\" if ($no_install);\n\n    my $name = \"\";\n\n    if (defined($test_name)) {\n\t$name = \" ($test_name)\";\n    }\n\n    doprint \"\\n\\n\";\n\n    if (defined($opt{\"LOG_FILE\"})) {\n\t$test_log_start = tell(LOG);\n    }\n\n    doprint \"RUNNING TEST $i of $opt{NUM_TESTS}$name with option $test_type $run_type$installme\\n\\n\";\n\n    if (defined($pre_test)) {\n\tmy $ret = run_command $pre_test;\n\tif (!$ret && defined($pre_test_die) &&\n\t    $pre_test_die) {\n\t\tdodie \"failed to pre_test\\n\";\n\t}\n    }\n\n    unlink $dmesg;\n    unlink $buildlog;\n    unlink $testlog;\n\n    if (defined($addconfig)) {\n\tmy $min = $minconfig;\n\tif (!defined($minconfig)) {\n\t    $min = \"\";\n\t}\n\trun_command \"cat $addconfig $min > $tmpdir/add_config\" or\n\t    dodie \"Failed to create temp config\";\n\t$minconfig = \"$tmpdir/add_config\";\n    }\n\n    if (defined($checkout)) {\n\trun_command \"git checkout $checkout\" or\n\t    dodie \"failed to checkout $checkout\";\n    }\n\n    $no_reboot = 0;\n\n    # A test may opt to not reboot the box\n    if ($reboot_on_success) {\n\t$reboot_success = 1;\n    }\n\n    if ($test_type eq \"bisect\") {\n\tbisect $i;\n\tnext;\n    } elsif ($test_type eq \"config_bisect\") {\n\tconfig_bisect $i;\n\tnext;\n    } elsif ($test_type eq \"patchcheck\") {\n\tpatchcheck $i;\n\tnext;\n    } elsif ($test_type eq \"make_min_config\") {\n\tmake_min_config $i;\n\tnext;\n    } elsif ($test_type eq \"make_warnings_file\") {\n\t$no_reboot = 1;\n\tmake_warnings_file $i;\n\tnext;\n    }\n\n    if ($build_type ne \"nobuild\") {\n\tbuild $build_type or next;\n\tcheck_buildlog or next;\n    }\n\n    if ($test_type eq \"install\") {\n\tget_version;\n\tinstall;\n\tsuccess $i;\n\tnext;\n    }\n\n    if ($test_type ne \"build\") {\n\tmy $failed = 0;\n\tstart_monitor_and_install or $failed = 1;\n\n\tif (!$failed && $test_type ne \"boot\" && defined($run_test)) {\n\t    do_run_test or $failed = 1;\n\t}\n\tend_monitor;\n\tif ($failed) {\n\t    print_times;\n\t    next;\n\t}\n    }\n\n    print_times;\n\n    success $i;\n}\n\nif (defined($final_post_ktest)) {\n\n    my $cp_final_post_ktest = eval_kernel_version $final_post_ktest;\n    run_command $cp_final_post_ktest;\n}\n\nif ($opt{\"POWEROFF_ON_SUCCESS\"}) {\n    halt;\n} elsif ($opt{\"REBOOT_ON_SUCCESS\"} && !do_not_reboot && $reboot_success) {\n    reboot_to_good;\n} elsif (defined($switch_to_good)) {\n    # still need to get to the good kernel\n    run_command $switch_to_good;\n}\n\ndoprint \"\\n    $successes of $opt{NUM_TESTS} tests were successful\\n\\n\";\n\nif ($email_when_finished) {\n    send_email(\"KTEST: Your test has finished!\",\n\t\"$successes of $opt{NUM_TESTS} tests started at $script_start_time were successful!\");\n}\n\nif (defined($opt{\"LOG_FILE\"})) {\n    print \"\\n See $opt{LOG_FILE} for the record of results.\\n\\n\";\n    close LOG;\n}\n\nexit 0;\n\n##\n# The following are here to standardize tabs/spaces/etc across the most likely editors\n###\n\n# Local Variables:\n# mode: perl\n# End:\n# vim: softtabstop=4\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}