{
  "module_name": "kunit_parser.py",
  "hash_id": "446bd8ddd432cd0a0b3c72ab3f72cb096ed6ebe687d0b35b16bd1ee7e6341dad",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/kunit_parser.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Parses KTAP test results from a kernel dmesg log and incrementally prints\n# results with reader-friendly format. Stores and returns test results in a\n# Test object.\n#\n# Copyright (C) 2019, Google LLC.\n# Author: Felix Guo <felixguoxiuping@gmail.com>\n# Author: Brendan Higgins <brendanhiggins@google.com>\n# Author: Rae Moar <rmoar@google.com>\n\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nimport re\nimport textwrap\n\nfrom enum import Enum, auto\nfrom typing import Iterable, Iterator, List, Optional, Tuple\n\nfrom kunit_printer import stdout\n\nclass Test:\n\t\"\"\"\n\tA class to represent a test parsed from KTAP results. All KTAP\n\tresults within a test log are stored in a main Test object as\n\tsubtests.\n\n\tAttributes:\n\tstatus : TestStatus - status of the test\n\tname : str - name of the test\n\texpected_count : int - expected number of subtests (0 if single\n\t\ttest case and None if unknown expected number of subtests)\n\tsubtests : List[Test] - list of subtests\n\tlog : List[str] - log of KTAP lines that correspond to the test\n\tcounts : TestCounts - counts of the test statuses and errors of\n\t\tsubtests or of the test itself if the test is a single\n\t\ttest case.\n\t\"\"\"\n\tdef __init__(self) -> None:\n\t\t\"\"\"Creates Test object with default attributes.\"\"\"\n\t\tself.status = TestStatus.TEST_CRASHED\n\t\tself.name = ''\n\t\tself.expected_count = 0  # type: Optional[int]\n\t\tself.subtests = []  # type: List[Test]\n\t\tself.log = []  # type: List[str]\n\t\tself.counts = TestCounts()\n\n\tdef __str__(self) -> str:\n\t\t\"\"\"Returns string representation of a Test class object.\"\"\"\n\t\treturn (f'Test({self.status}, {self.name}, {self.expected_count}, '\n\t\t\tf'{self.subtests}, {self.log}, {self.counts})')\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"Returns string representation of a Test class object.\"\"\"\n\t\treturn str(self)\n\n\tdef add_error(self, error_message: str) -> None:\n\t\t\"\"\"Records an error that occurred while parsing this test.\"\"\"\n\t\tself.counts.errors += 1\n\t\tstdout.print_with_timestamp(stdout.red('[ERROR]') + f' Test: {self.name}: {error_message}')\n\n\tdef ok_status(self) -> bool:\n\t\t\"\"\"Returns true if the status was ok, i.e. passed or skipped.\"\"\"\n\t\treturn self.status in (TestStatus.SUCCESS, TestStatus.SKIPPED)\n\nclass TestStatus(Enum):\n\t\"\"\"An enumeration class to represent the status of a test.\"\"\"\n\tSUCCESS = auto()\n\tFAILURE = auto()\n\tSKIPPED = auto()\n\tTEST_CRASHED = auto()\n\tNO_TESTS = auto()\n\tFAILURE_TO_PARSE_TESTS = auto()\n\n@dataclass\nclass TestCounts:\n\t\"\"\"\n\tTracks the counts of statuses of all test cases and any errors within\n\ta Test.\n\t\"\"\"\n\tpassed: int = 0\n\tfailed: int = 0\n\tcrashed: int = 0\n\tskipped: int = 0\n\terrors: int = 0\n\n\tdef __str__(self) -> str:\n\t\t\"\"\"Returns the string representation of a TestCounts object.\"\"\"\n\t\tstatuses = [('passed', self.passed), ('failed', self.failed),\n\t\t\t('crashed', self.crashed), ('skipped', self.skipped),\n\t\t\t('errors', self.errors)]\n\t\treturn f'Ran {self.total()} tests: ' + \\\n\t\t\t', '.join(f'{s}: {n}' for s, n in statuses if n > 0)\n\n\tdef total(self) -> int:\n\t\t\"\"\"Returns the total number of test cases within a test\n\t\tobject, where a test case is a test with no subtests.\n\t\t\"\"\"\n\t\treturn (self.passed + self.failed + self.crashed +\n\t\t\tself.skipped)\n\n\tdef add_subtest_counts(self, counts: TestCounts) -> None:\n\t\t\"\"\"\n\t\tAdds the counts of another TestCounts object to the current\n\t\tTestCounts object. Used to add the counts of a subtest to the\n\t\tparent test.\n\n\t\tParameters:\n\t\tcounts - a different TestCounts object whose counts\n\t\t\twill be added to the counts of the TestCounts object\n\t\t\"\"\"\n\t\tself.passed += counts.passed\n\t\tself.failed += counts.failed\n\t\tself.crashed += counts.crashed\n\t\tself.skipped += counts.skipped\n\t\tself.errors += counts.errors\n\n\tdef get_status(self) -> TestStatus:\n\t\t\"\"\"Returns the aggregated status of a Test using test\n\t\tcounts.\n\t\t\"\"\"\n\t\tif self.total() == 0:\n\t\t\treturn TestStatus.NO_TESTS\n\t\tif self.crashed:\n\t\t\t# Crashes should take priority.\n\t\t\treturn TestStatus.TEST_CRASHED\n\t\tif self.failed:\n\t\t\treturn TestStatus.FAILURE\n\t\tif self.passed:\n\t\t\t# No failures or crashes, looks good!\n\t\t\treturn TestStatus.SUCCESS\n\t\t# We have only skipped tests.\n\t\treturn TestStatus.SKIPPED\n\n\tdef add_status(self, status: TestStatus) -> None:\n\t\t\"\"\"Increments the count for `status`.\"\"\"\n\t\tif status == TestStatus.SUCCESS:\n\t\t\tself.passed += 1\n\t\telif status == TestStatus.FAILURE:\n\t\t\tself.failed += 1\n\t\telif status == TestStatus.SKIPPED:\n\t\t\tself.skipped += 1\n\t\telif status != TestStatus.NO_TESTS:\n\t\t\tself.crashed += 1\n\nclass LineStream:\n\t\"\"\"\n\tA class to represent the lines of kernel output.\n\tProvides a lazy peek()/pop() interface over an iterator of\n\t(line#, text).\n\t\"\"\"\n\t_lines: Iterator[Tuple[int, str]]\n\t_next: Tuple[int, str]\n\t_need_next: bool\n\t_done: bool\n\n\tdef __init__(self, lines: Iterator[Tuple[int, str]]):\n\t\t\"\"\"Creates a new LineStream that wraps the given iterator.\"\"\"\n\t\tself._lines = lines\n\t\tself._done = False\n\t\tself._need_next = True\n\t\tself._next = (0, '')\n\n\tdef _get_next(self) -> None:\n\t\t\"\"\"Advances the LineSteam to the next line, if necessary.\"\"\"\n\t\tif not self._need_next:\n\t\t\treturn\n\t\ttry:\n\t\t\tself._next = next(self._lines)\n\t\texcept StopIteration:\n\t\t\tself._done = True\n\t\tfinally:\n\t\t\tself._need_next = False\n\n\tdef peek(self) -> str:\n\t\t\"\"\"Returns the current line, without advancing the LineStream.\n\t\t\"\"\"\n\t\tself._get_next()\n\t\treturn self._next[1]\n\n\tdef pop(self) -> str:\n\t\t\"\"\"Returns the current line and advances the LineStream to\n\t\tthe next line.\n\t\t\"\"\"\n\t\ts = self.peek()\n\t\tif self._done:\n\t\t\traise ValueError(f'LineStream: going past EOF, last line was {s}')\n\t\tself._need_next = True\n\t\treturn s\n\n\tdef __bool__(self) -> bool:\n\t\t\"\"\"Returns True if stream has more lines.\"\"\"\n\t\tself._get_next()\n\t\treturn not self._done\n\n\t# Only used by kunit_tool_test.py.\n\tdef __iter__(self) -> Iterator[str]:\n\t\t\"\"\"Empties all lines stored in LineStream object into\n\t\tIterator object and returns the Iterator object.\n\t\t\"\"\"\n\t\twhile bool(self):\n\t\t\tyield self.pop()\n\n\tdef line_number(self) -> int:\n\t\t\"\"\"Returns the line number of the current line.\"\"\"\n\t\tself._get_next()\n\t\treturn self._next[0]\n\n# Parsing helper methods:\n\nKTAP_START = re.compile(r'\\s*KTAP version ([0-9]+)$')\nTAP_START = re.compile(r'\\s*TAP version ([0-9]+)$')\nKTAP_END = re.compile(r'\\s*(List of all partitions:|'\n\t'Kernel panic - not syncing: VFS:|reboot: System halted)')\nEXECUTOR_ERROR = re.compile(r'\\s*kunit executor: (.*)$')\n\ndef extract_tap_lines(kernel_output: Iterable[str]) -> LineStream:\n\t\"\"\"Extracts KTAP lines from the kernel output.\"\"\"\n\tdef isolate_ktap_output(kernel_output: Iterable[str]) \\\n\t\t\t-> Iterator[Tuple[int, str]]:\n\t\tline_num = 0\n\t\tstarted = False\n\t\tfor line in kernel_output:\n\t\t\tline_num += 1\n\t\t\tline = line.rstrip()  # remove trailing \\n\n\t\t\tif not started and KTAP_START.search(line):\n\t\t\t\t# start extracting KTAP lines and set prefix\n\t\t\t\t# to number of characters before version line\n\t\t\t\tprefix_len = len(\n\t\t\t\t\tline.split('KTAP version')[0])\n\t\t\t\tstarted = True\n\t\t\t\tyield line_num, line[prefix_len:]\n\t\t\telif not started and TAP_START.search(line):\n\t\t\t\t# start extracting KTAP lines and set prefix\n\t\t\t\t# to number of characters before version line\n\t\t\t\tprefix_len = len(line.split('TAP version')[0])\n\t\t\t\tstarted = True\n\t\t\t\tyield line_num, line[prefix_len:]\n\t\t\telif started and KTAP_END.search(line):\n\t\t\t\t# stop extracting KTAP lines\n\t\t\t\tbreak\n\t\t\telif started:\n\t\t\t\t# remove the prefix, if any.\n\t\t\t\tline = line[prefix_len:]\n\t\t\t\tyield line_num, line\n\t\t\telif EXECUTOR_ERROR.search(line):\n\t\t\t\tyield line_num, line\n\treturn LineStream(lines=isolate_ktap_output(kernel_output))\n\nKTAP_VERSIONS = [1]\nTAP_VERSIONS = [13, 14]\n\ndef check_version(version_num: int, accepted_versions: List[int],\n\t\t\tversion_type: str, test: Test) -> None:\n\t\"\"\"\n\tAdds error to test object if version number is too high or too\n\tlow.\n\n\tParameters:\n\tversion_num - The inputted version number from the parsed KTAP or TAP\n\t\theader line\n\taccepted_version - List of accepted KTAP or TAP versions\n\tversion_type - 'KTAP' or 'TAP' depending on the type of\n\t\tversion line.\n\ttest - Test object for current test being parsed\n\t\"\"\"\n\tif version_num < min(accepted_versions):\n\t\ttest.add_error(f'{version_type} version lower than expected!')\n\telif version_num > max(accepted_versions):\n\t\ttest.add_error(f'{version_type} version higer than expected!')\n\ndef parse_ktap_header(lines: LineStream, test: Test) -> bool:\n\t\"\"\"\n\tParses KTAP/TAP header line and checks version number.\n\tReturns False if fails to parse KTAP/TAP header line.\n\n\tAccepted formats:\n\t- 'KTAP version [version number]'\n\t- 'TAP version [version number]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\ttest - Test object for current test being parsed\n\n\tReturn:\n\tTrue if successfully parsed KTAP/TAP header line\n\t\"\"\"\n\tktap_match = KTAP_START.match(lines.peek())\n\ttap_match = TAP_START.match(lines.peek())\n\tif ktap_match:\n\t\tversion_num = int(ktap_match.group(1))\n\t\tcheck_version(version_num, KTAP_VERSIONS, 'KTAP', test)\n\telif tap_match:\n\t\tversion_num = int(tap_match.group(1))\n\t\tcheck_version(version_num, TAP_VERSIONS, 'TAP', test)\n\telse:\n\t\treturn False\n\tlines.pop()\n\treturn True\n\nTEST_HEADER = re.compile(r'^\\s*# Subtest: (.*)$')\n\ndef parse_test_header(lines: LineStream, test: Test) -> bool:\n\t\"\"\"\n\tParses test header and stores test name in test object.\n\tReturns False if fails to parse test header line.\n\n\tAccepted format:\n\t- '# Subtest: [test name]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\ttest - Test object for current test being parsed\n\n\tReturn:\n\tTrue if successfully parsed test header line\n\t\"\"\"\n\tmatch = TEST_HEADER.match(lines.peek())\n\tif not match:\n\t\treturn False\n\ttest.name = match.group(1)\n\tlines.pop()\n\treturn True\n\nTEST_PLAN = re.compile(r'^\\s*1\\.\\.([0-9]+)')\n\ndef parse_test_plan(lines: LineStream, test: Test) -> bool:\n\t\"\"\"\n\tParses test plan line and stores the expected number of subtests in\n\ttest object. Reports an error if expected count is 0.\n\tReturns False and sets expected_count to None if there is no valid test\n\tplan.\n\n\tAccepted format:\n\t- '1..[number of subtests]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\ttest - Test object for current test being parsed\n\n\tReturn:\n\tTrue if successfully parsed test plan line\n\t\"\"\"\n\tmatch = TEST_PLAN.match(lines.peek())\n\tif not match:\n\t\ttest.expected_count = None\n\t\treturn False\n\texpected_count = int(match.group(1))\n\ttest.expected_count = expected_count\n\tlines.pop()\n\treturn True\n\nTEST_RESULT = re.compile(r'^\\s*(ok|not ok) ([0-9]+) (- )?([^#]*)( # .*)?$')\n\nTEST_RESULT_SKIP = re.compile(r'^\\s*(ok|not ok) ([0-9]+) (- )?(.*) # SKIP(.*)$')\n\ndef peek_test_name_match(lines: LineStream, test: Test) -> bool:\n\t\"\"\"\n\tMatches current line with the format of a test result line and checks\n\tif the name matches the name of the current test.\n\tReturns False if fails to match format or name.\n\n\tAccepted format:\n\t- '[ok|not ok] [test number] [-] [test name] [optional skip\n\t\tdirective]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\ttest - Test object for current test being parsed\n\n\tReturn:\n\tTrue if matched a test result line and the name matching the\n\t\texpected test name\n\t\"\"\"\n\tline = lines.peek()\n\tmatch = TEST_RESULT.match(line)\n\tif not match:\n\t\treturn False\n\tname = match.group(4)\n\treturn name == test.name\n\ndef parse_test_result(lines: LineStream, test: Test,\n\t\t\texpected_num: int) -> bool:\n\t\"\"\"\n\tParses test result line and stores the status and name in the test\n\tobject. Reports an error if the test number does not match expected\n\ttest number.\n\tReturns False if fails to parse test result line.\n\n\tNote that the SKIP directive is the only direction that causes a\n\tchange in status.\n\n\tAccepted format:\n\t- '[ok|not ok] [test number] [-] [test name] [optional skip\n\t\tdirective]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\ttest - Test object for current test being parsed\n\texpected_num - expected test number for current test\n\n\tReturn:\n\tTrue if successfully parsed a test result line.\n\t\"\"\"\n\tline = lines.peek()\n\tmatch = TEST_RESULT.match(line)\n\tskip_match = TEST_RESULT_SKIP.match(line)\n\n\t# Check if line matches test result line format\n\tif not match:\n\t\treturn False\n\tlines.pop()\n\n\t# Set name of test object\n\tif skip_match:\n\t\ttest.name = skip_match.group(4)\n\telse:\n\t\ttest.name = match.group(4)\n\n\t# Check test num\n\tnum = int(match.group(2))\n\tif num != expected_num:\n\t\ttest.add_error(f'Expected test number {expected_num} but found {num}')\n\n\t# Set status of test object\n\tstatus = match.group(1)\n\tif skip_match:\n\t\ttest.status = TestStatus.SKIPPED\n\telif status == 'ok':\n\t\ttest.status = TestStatus.SUCCESS\n\telse:\n\t\ttest.status = TestStatus.FAILURE\n\treturn True\n\ndef parse_diagnostic(lines: LineStream) -> List[str]:\n\t\"\"\"\n\tParse lines that do not match the format of a test result line or\n\ttest header line and returns them in list.\n\n\tLine formats that are not parsed:\n\t- '# Subtest: [test name]'\n\t- '[ok|not ok] [test number] [-] [test name] [optional skip\n\t\tdirective]'\n\t- 'KTAP version [version number]'\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\n\tReturn:\n\tLog of diagnostic lines\n\t\"\"\"\n\tlog = []  # type: List[str]\n\tnon_diagnostic_lines = [TEST_RESULT, TEST_HEADER, KTAP_START, TAP_START]\n\twhile lines and not any(re.match(lines.peek())\n\t\t\tfor re in non_diagnostic_lines):\n\t\tlog.append(lines.pop())\n\treturn log\n\n\n# Printing helper methods:\n\nDIVIDER = '=' * 60\n\ndef format_test_divider(message: str, len_message: int) -> str:\n\t\"\"\"\n\tReturns string with message centered in fixed width divider.\n\n\tExample:\n\t'===================== message example ====================='\n\n\tParameters:\n\tmessage - message to be centered in divider line\n\tlen_message - length of the message to be printed such that\n\t\tany characters of the color codes are not counted\n\n\tReturn:\n\tString containing message centered in fixed width divider\n\t\"\"\"\n\tdefault_count = 3  # default number of dashes\n\tlen_1 = default_count\n\tlen_2 = default_count\n\tdifference = len(DIVIDER) - len_message - 2  # 2 spaces added\n\tif difference > 0:\n\t\t# calculate number of dashes for each side of the divider\n\t\tlen_1 = int(difference / 2)\n\t\tlen_2 = difference - len_1\n\treturn ('=' * len_1) + f' {message} ' + ('=' * len_2)\n\ndef print_test_header(test: Test) -> None:\n\t\"\"\"\n\tPrints test header with test name and optionally the expected number\n\tof subtests.\n\n\tExample:\n\t'=================== example (2 subtests) ==================='\n\n\tParameters:\n\ttest - Test object representing current test being printed\n\t\"\"\"\n\tmessage = test.name\n\tif message != \"\":\n\t\t# Add a leading space before the subtest counts only if a test name\n\t\t# is provided using a \"# Subtest\" header line.\n\t\tmessage += \" \"\n\tif test.expected_count:\n\t\tif test.expected_count == 1:\n\t\t\tmessage += '(1 subtest)'\n\t\telse:\n\t\t\tmessage += f'({test.expected_count} subtests)'\n\tstdout.print_with_timestamp(format_test_divider(message, len(message)))\n\ndef print_log(log: Iterable[str]) -> None:\n\t\"\"\"Prints all strings in saved log for test in yellow.\"\"\"\n\tformatted = textwrap.dedent('\\n'.join(log))\n\tfor line in formatted.splitlines():\n\t\tstdout.print_with_timestamp(stdout.yellow(line))\n\ndef format_test_result(test: Test) -> str:\n\t\"\"\"\n\tReturns string with formatted test result with colored status and test\n\tname.\n\n\tExample:\n\t'[PASSED] example'\n\n\tParameters:\n\ttest - Test object representing current test being printed\n\n\tReturn:\n\tString containing formatted test result\n\t\"\"\"\n\tif test.status == TestStatus.SUCCESS:\n\t\treturn stdout.green('[PASSED] ') + test.name\n\tif test.status == TestStatus.SKIPPED:\n\t\treturn stdout.yellow('[SKIPPED] ') + test.name\n\tif test.status == TestStatus.NO_TESTS:\n\t\treturn stdout.yellow('[NO TESTS RUN] ') + test.name\n\tif test.status == TestStatus.TEST_CRASHED:\n\t\tprint_log(test.log)\n\t\treturn stdout.red('[CRASHED] ') + test.name\n\tprint_log(test.log)\n\treturn stdout.red('[FAILED] ') + test.name\n\ndef print_test_result(test: Test) -> None:\n\t\"\"\"\n\tPrints result line with status of test.\n\n\tExample:\n\t'[PASSED] example'\n\n\tParameters:\n\ttest - Test object representing current test being printed\n\t\"\"\"\n\tstdout.print_with_timestamp(format_test_result(test))\n\ndef print_test_footer(test: Test) -> None:\n\t\"\"\"\n\tPrints test footer with status of test.\n\n\tExample:\n\t'===================== [PASSED] example ====================='\n\n\tParameters:\n\ttest - Test object representing current test being printed\n\t\"\"\"\n\tmessage = format_test_result(test)\n\tstdout.print_with_timestamp(format_test_divider(message,\n\t\tlen(message) - stdout.color_len()))\n\n\n\ndef _summarize_failed_tests(test: Test) -> str:\n\t\"\"\"Tries to summarize all the failing subtests in `test`.\"\"\"\n\n\tdef failed_names(test: Test, parent_name: str) -> List[str]:\n\t\t# Note: we use 'main' internally for the top-level test.\n\t\tif not parent_name or parent_name == 'main':\n\t\t\tfull_name = test.name\n\t\telse:\n\t\t\tfull_name = parent_name + '.' + test.name\n\n\t\tif not test.subtests:  # this is a leaf node\n\t\t\treturn [full_name]\n\n\t\t# If all the children failed, just say this subtest failed.\n\t\t# Don't summarize it down \"the top-level test failed\", though.\n\t\tfailed_subtests = [sub for sub in test.subtests if not sub.ok_status()]\n\t\tif parent_name and len(failed_subtests) ==  len(test.subtests):\n\t\t\treturn [full_name]\n\n\t\tall_failures = []  # type: List[str]\n\t\tfor t in failed_subtests:\n\t\t\tall_failures.extend(failed_names(t, full_name))\n\t\treturn all_failures\n\n\tfailures = failed_names(test, '')\n\t# If there are too many failures, printing them out will just be noisy.\n\tif len(failures) > 10:  # this is an arbitrary limit\n\t\treturn ''\n\n\treturn 'Failures: ' + ', '.join(failures)\n\n\ndef print_summary_line(test: Test) -> None:\n\t\"\"\"\n\tPrints summary line of test object. Color of line is dependent on\n\tstatus of test. Color is green if test passes, yellow if test is\n\tskipped, and red if the test fails or crashes. Summary line contains\n\tcounts of the statuses of the tests subtests or the test itself if it\n\thas no subtests.\n\n\tExample:\n\t\"Testing complete. Passed: 2, Failed: 0, Crashed: 0, Skipped: 0,\n\tErrors: 0\"\n\n\ttest - Test object representing current test being printed\n\t\"\"\"\n\tif test.status == TestStatus.SUCCESS:\n\t\tcolor = stdout.green\n\telif test.status in (TestStatus.SKIPPED, TestStatus.NO_TESTS):\n\t\tcolor = stdout.yellow\n\telse:\n\t\tcolor = stdout.red\n\tstdout.print_with_timestamp(color(f'Testing complete. {test.counts}'))\n\n\t# Summarize failures that might have gone off-screen since we had a lot\n\t# of tests (arbitrarily defined as >=100 for now).\n\tif test.ok_status() or test.counts.total() < 100:\n\t\treturn\n\tsummarized = _summarize_failed_tests(test)\n\tif not summarized:\n\t\treturn\n\tstdout.print_with_timestamp(color(summarized))\n\n# Other methods:\n\ndef bubble_up_test_results(test: Test) -> None:\n\t\"\"\"\n\tIf the test has subtests, add the test counts of the subtests to the\n\ttest and check if any of the tests crashed and if so set the test\n\tstatus to crashed. Otherwise if the test has no subtests add the\n\tstatus of the test to the test counts.\n\n\tParameters:\n\ttest - Test object for current test being parsed\n\t\"\"\"\n\tsubtests = test.subtests\n\tcounts = test.counts\n\tstatus = test.status\n\tfor t in subtests:\n\t\tcounts.add_subtest_counts(t.counts)\n\tif counts.total() == 0:\n\t\tcounts.add_status(status)\n\telif test.counts.get_status() == TestStatus.TEST_CRASHED:\n\t\ttest.status = TestStatus.TEST_CRASHED\n\ndef parse_test(lines: LineStream, expected_num: int, log: List[str], is_subtest: bool) -> Test:\n\t\"\"\"\n\tFinds next test to parse in LineStream, creates new Test object,\n\tparses any subtests of the test, populates Test object with all\n\tinformation (status, name) about the test and the Test objects for\n\tany subtests, and then returns the Test object. The method accepts\n\tthree formats of tests:\n\n\tAccepted test formats:\n\n\t- Main KTAP/TAP header\n\n\tExample:\n\n\tKTAP version 1\n\t1..4\n\t[subtests]\n\n\t- Subtest header (must include either the KTAP version line or\n\t  \"# Subtest\" header line)\n\n\tExample (preferred format with both KTAP version line and\n\t\"# Subtest\" line):\n\n\tKTAP version 1\n\t# Subtest: name\n\t1..3\n\t[subtests]\n\tok 1 name\n\n\tExample (only \"# Subtest\" line):\n\n\t# Subtest: name\n\t1..3\n\t[subtests]\n\tok 1 name\n\n\tExample (only KTAP version line, compliant with KTAP v1 spec):\n\n\tKTAP version 1\n\t1..3\n\t[subtests]\n\tok 1 name\n\n\t- Test result line\n\n\tExample:\n\n\tok 1 - test\n\n\tParameters:\n\tlines - LineStream of KTAP output to parse\n\texpected_num - expected test number for test to be parsed\n\tlog - list of strings containing any preceding diagnostic lines\n\t\tcorresponding to the current test\n\tis_subtest - boolean indicating whether test is a subtest\n\n\tReturn:\n\tTest object populated with characteristics and any subtests\n\t\"\"\"\n\ttest = Test()\n\ttest.log.extend(log)\n\n\t# Parse any errors prior to parsing tests\n\terr_log = parse_diagnostic(lines)\n\ttest.log.extend(err_log)\n\n\tif not is_subtest:\n\t\t# If parsing the main/top-level test, parse KTAP version line and\n\t\t# test plan\n\t\ttest.name = \"main\"\n\t\tktap_line = parse_ktap_header(lines, test)\n\t\tparse_test_plan(lines, test)\n\t\tparent_test = True\n\telse:\n\t\t# If not the main test, attempt to parse a test header containing\n\t\t# the KTAP version line and/or subtest header line\n\t\tktap_line = parse_ktap_header(lines, test)\n\t\tsubtest_line = parse_test_header(lines, test)\n\t\tparent_test = (ktap_line or subtest_line)\n\t\tif parent_test:\n\t\t\t# If KTAP version line and/or subtest header is found, attempt\n\t\t\t# to parse test plan and print test header\n\t\t\tparse_test_plan(lines, test)\n\t\t\tprint_test_header(test)\n\texpected_count = test.expected_count\n\tsubtests = []\n\ttest_num = 1\n\twhile parent_test and (expected_count is None or test_num <= expected_count):\n\t\t# Loop to parse any subtests.\n\t\t# Break after parsing expected number of tests or\n\t\t# if expected number of tests is unknown break when test\n\t\t# result line with matching name to subtest header is found\n\t\t# or no more lines in stream.\n\t\tsub_log = parse_diagnostic(lines)\n\t\tsub_test = Test()\n\t\tif not lines or (peek_test_name_match(lines, test) and\n\t\t\t\tis_subtest):\n\t\t\tif expected_count and test_num <= expected_count:\n\t\t\t\t# If parser reaches end of test before\n\t\t\t\t# parsing expected number of subtests, print\n\t\t\t\t# crashed subtest and record error\n\t\t\t\ttest.add_error('missing expected subtest!')\n\t\t\t\tsub_test.log.extend(sub_log)\n\t\t\t\ttest.counts.add_status(\n\t\t\t\t\tTestStatus.TEST_CRASHED)\n\t\t\t\tprint_test_result(sub_test)\n\t\t\telse:\n\t\t\t\ttest.log.extend(sub_log)\n\t\t\t\tbreak\n\t\telse:\n\t\t\tsub_test = parse_test(lines, test_num, sub_log, True)\n\t\tsubtests.append(sub_test)\n\t\ttest_num += 1\n\ttest.subtests = subtests\n\tif is_subtest:\n\t\t# If not main test, look for test result line\n\t\ttest.log.extend(parse_diagnostic(lines))\n\t\tif test.name != \"\" and not peek_test_name_match(lines, test):\n\t\t\ttest.add_error('missing subtest result line!')\n\t\telse:\n\t\t\tparse_test_result(lines, test, expected_num)\n\n\t# Check for there being no subtests within parent test\n\tif parent_test and len(subtests) == 0:\n\t\t# Don't override a bad status if this test had one reported.\n\t\t# Assumption: no subtests means CRASHED is from Test.__init__()\n\t\tif test.status in (TestStatus.TEST_CRASHED, TestStatus.SUCCESS):\n\t\t\tprint_log(test.log)\n\t\t\ttest.status = TestStatus.NO_TESTS\n\t\t\ttest.add_error('0 tests run!')\n\n\t# Add statuses to TestCounts attribute in Test object\n\tbubble_up_test_results(test)\n\tif parent_test and is_subtest:\n\t\t# If test has subtests and is not the main test object, print\n\t\t# footer.\n\t\tprint_test_footer(test)\n\telif is_subtest:\n\t\tprint_test_result(test)\n\treturn test\n\ndef parse_run_tests(kernel_output: Iterable[str]) -> Test:\n\t\"\"\"\n\tUsing kernel output, extract KTAP lines, parse the lines for test\n\tresults and print condensed test results and summary line.\n\n\tParameters:\n\tkernel_output - Iterable object contains lines of kernel output\n\n\tReturn:\n\tTest - the main test object with all subtests.\n\t\"\"\"\n\tstdout.print_with_timestamp(DIVIDER)\n\tlines = extract_tap_lines(kernel_output)\n\ttest = Test()\n\tif not lines:\n\t\ttest.name = '<missing>'\n\t\ttest.add_error('Could not find any KTAP output. Did any KUnit tests run?')\n\t\ttest.status = TestStatus.FAILURE_TO_PARSE_TESTS\n\telse:\n\t\ttest = parse_test(lines, 0, [], False)\n\t\tif test.status != TestStatus.NO_TESTS:\n\t\t\ttest.status = test.counts.get_status()\n\tstdout.print_with_timestamp(DIVIDER)\n\tprint_summary_line(test)\n\treturn test\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}