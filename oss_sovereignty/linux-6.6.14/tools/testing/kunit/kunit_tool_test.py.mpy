{
  "module_name": "kunit_tool_test.py",
  "hash_id": "b1e321c872733828e072bf171fbc2b01a867d76b49e30258bf73f466f60821f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/kunit_tool_test.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# A collection of tests for tools/testing/kunit/kunit.py\n#\n# Copyright (C) 2019, Google LLC.\n# Author: Brendan Higgins <brendanhiggins@google.com>\n\nimport unittest\nfrom unittest import mock\n\nimport tempfile, shutil # Handling test_tmpdir\n\nimport itertools\nimport json\nimport os\nimport signal\nimport subprocess\nfrom typing import Iterable\n\nimport kunit_config\nimport kunit_parser\nimport kunit_kernel\nimport kunit_json\nimport kunit\n\ntest_tmpdir = ''\nabs_test_data_dir = ''\n\ndef setUpModule():\n\tglobal test_tmpdir, abs_test_data_dir\n\ttest_tmpdir = tempfile.mkdtemp()\n\tabs_test_data_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_data'))\n\ndef tearDownModule():\n\tshutil.rmtree(test_tmpdir)\n\ndef test_data_path(path):\n\treturn os.path.join(abs_test_data_dir, path)\n\nclass KconfigTest(unittest.TestCase):\n\n\tdef test_is_subset_of(self):\n\t\tkconfig0 = kunit_config.Kconfig()\n\t\tself.assertTrue(kconfig0.is_subset_of(kconfig0))\n\n\t\tkconfig1 = kunit_config.Kconfig()\n\t\tkconfig1.add_entry('TEST', 'y')\n\t\tself.assertTrue(kconfig1.is_subset_of(kconfig1))\n\t\tself.assertTrue(kconfig0.is_subset_of(kconfig1))\n\t\tself.assertFalse(kconfig1.is_subset_of(kconfig0))\n\n\tdef test_read_from_file(self):\n\t\tkconfig_path = test_data_path('test_read_from_file.kconfig')\n\n\t\tkconfig = kunit_config.parse_file(kconfig_path)\n\n\t\texpected_kconfig = kunit_config.Kconfig()\n\t\texpected_kconfig.add_entry('UML', 'y')\n\t\texpected_kconfig.add_entry('MMU', 'y')\n\t\texpected_kconfig.add_entry('TEST', 'y')\n\t\texpected_kconfig.add_entry('EXAMPLE_TEST', 'y')\n\t\texpected_kconfig.add_entry('MK8', 'n')\n\n\t\tself.assertEqual(kconfig, expected_kconfig)\n\n\tdef test_write_to_file(self):\n\t\tkconfig_path = os.path.join(test_tmpdir, '.config')\n\n\t\texpected_kconfig = kunit_config.Kconfig()\n\t\texpected_kconfig.add_entry('UML', 'y')\n\t\texpected_kconfig.add_entry('MMU', 'y')\n\t\texpected_kconfig.add_entry('TEST', 'y')\n\t\texpected_kconfig.add_entry('EXAMPLE_TEST', 'y')\n\t\texpected_kconfig.add_entry('MK8', 'n')\n\n\t\texpected_kconfig.write_to_file(kconfig_path)\n\n\t\tactual_kconfig = kunit_config.parse_file(kconfig_path)\n\t\tself.assertEqual(actual_kconfig, expected_kconfig)\n\nclass KUnitParserTest(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.print_mock = mock.patch('kunit_printer.Printer.print').start()\n\t\tself.addCleanup(mock.patch.stopall)\n\n\tdef noPrintCallContains(self, substr: str):\n\t\tfor call in self.print_mock.mock_calls:\n\t\t\tself.assertNotIn(substr, call.args[0])\n\n\tdef assertContains(self, needle: str, haystack: kunit_parser.LineStream):\n\t\t# Clone the iterator so we can print the contents on failure.\n\t\tcopy, backup = itertools.tee(haystack)\n\t\tfor line in copy:\n\t\t\tif needle in line:\n\t\t\t\treturn\n\t\traise AssertionError(f'\"{needle}\" not found in {list(backup)}!')\n\n\tdef test_output_isolated_correctly(self):\n\t\tlog_path = test_data_path('test_output_isolated_correctly.log')\n\t\twith open(log_path) as file:\n\t\t\tresult = kunit_parser.extract_tap_lines(file.readlines())\n\t\tself.assertContains('TAP version 14', result)\n\t\tself.assertContains('# Subtest: example', result)\n\t\tself.assertContains('1..2', result)\n\t\tself.assertContains('ok 1 - example_simple_test', result)\n\t\tself.assertContains('ok 2 - example_mock_test', result)\n\t\tself.assertContains('ok 1 - example', result)\n\n\tdef test_output_with_prefix_isolated_correctly(self):\n\t\tlog_path = test_data_path('test_pound_sign.log')\n\t\twith open(log_path) as file:\n\t\t\tresult = kunit_parser.extract_tap_lines(file.readlines())\n\t\tself.assertContains('TAP version 14', result)\n\t\tself.assertContains('# Subtest: kunit-resource-test', result)\n\t\tself.assertContains('1..5', result)\n\t\tself.assertContains('ok 1 - kunit_resource_test_init_resources', result)\n\t\tself.assertContains('ok 2 - kunit_resource_test_alloc_resource', result)\n\t\tself.assertContains('ok 3 - kunit_resource_test_destroy_resource', result)\n\t\tself.assertContains('foo bar \t#', result)\n\t\tself.assertContains('ok 4 - kunit_resource_test_cleanup_resources', result)\n\t\tself.assertContains('ok 5 - kunit_resource_test_proper_free_ordering', result)\n\t\tself.assertContains('ok 1 - kunit-resource-test', result)\n\t\tself.assertContains('foo bar \t# non-kunit output', result)\n\t\tself.assertContains('# Subtest: kunit-try-catch-test', result)\n\t\tself.assertContains('1..2', result)\n\t\tself.assertContains('ok 1 - kunit_test_try_catch_successful_try_no_catch',\n\t\t\t\t    result)\n\t\tself.assertContains('ok 2 - kunit_test_try_catch_unsuccessful_try_does_catch',\n\t\t\t\t    result)\n\t\tself.assertContains('ok 2 - kunit-try-catch-test', result)\n\t\tself.assertContains('# Subtest: string-stream-test', result)\n\t\tself.assertContains('1..3', result)\n\t\tself.assertContains('ok 1 - string_stream_test_empty_on_creation', result)\n\t\tself.assertContains('ok 2 - string_stream_test_not_empty_after_add', result)\n\t\tself.assertContains('ok 3 - string_stream_test_get_string', result)\n\t\tself.assertContains('ok 3 - string-stream-test', result)\n\n\tdef test_parse_successful_test_log(self):\n\t\tall_passed_log = test_data_path('test_is_test_passed-all_passed.log')\n\t\twith open(all_passed_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_parse_successful_nested_tests_log(self):\n\t\tall_passed_log = test_data_path('test_is_test_passed-all_passed_nested.log')\n\t\twith open(all_passed_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_kselftest_nested(self):\n\t\tkselftest_log = test_data_path('test_is_test_passed-kselftest.log')\n\t\twith open(kselftest_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_parse_failed_test_log(self):\n\t\tfailed_log = test_data_path('test_is_test_passed-failure.log')\n\t\twith open(failed_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.FAILURE, result.status)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_no_header(self):\n\t\tempty_log = test_data_path('test_is_test_passed-no_tests_run_no_header.log')\n\t\twith open(empty_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(\n\t\t\t\tkunit_parser.extract_tap_lines(file.readlines()))\n\t\tself.assertEqual(0, len(result.subtests))\n\t\tself.assertEqual(kunit_parser.TestStatus.FAILURE_TO_PARSE_TESTS, result.status)\n\t\tself.assertEqual(result.counts.errors, 1)\n\n\tdef test_missing_test_plan(self):\n\t\tmissing_plan_log = test_data_path('test_is_test_passed-'\n\t\t\t'missing_plan.log')\n\t\twith open(missing_plan_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(\n\t\t\t\tkunit_parser.extract_tap_lines(\n\t\t\t\tfile.readlines()))\n\t\t# A missing test plan is not an error.\n\t\tself.assertEqual(result.counts, kunit_parser.TestCounts(passed=10, errors=0))\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\n\tdef test_no_tests(self):\n\t\theader_log = test_data_path('test_is_test_passed-no_tests_run_with_header.log')\n\t\twith open(header_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(\n\t\t\t\tkunit_parser.extract_tap_lines(file.readlines()))\n\t\tself.assertEqual(0, len(result.subtests))\n\t\tself.assertEqual(kunit_parser.TestStatus.NO_TESTS, result.status)\n\t\tself.assertEqual(result.counts.errors, 1)\n\n\tdef test_no_tests_no_plan(self):\n\t\tno_plan_log = test_data_path('test_is_test_passed-no_tests_no_plan.log')\n\t\twith open(no_plan_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(\n\t\t\t\tkunit_parser.extract_tap_lines(file.readlines()))\n\t\tself.assertEqual(0, len(result.subtests[0].subtests[0].subtests))\n\t\tself.assertEqual(\n\t\t\tkunit_parser.TestStatus.NO_TESTS,\n\t\t\tresult.subtests[0].subtests[0].status)\n\t\tself.assertEqual(result.counts, kunit_parser.TestCounts(passed=1, errors=1))\n\n\n\tdef test_no_kunit_output(self):\n\t\tcrash_log = test_data_path('test_insufficient_memory.log')\n\t\tprint_mock = mock.patch('kunit_printer.Printer.print').start()\n\t\twith open(crash_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(\n\t\t\t\tkunit_parser.extract_tap_lines(file.readlines()))\n\t\tprint_mock.assert_any_call(StrContains('Could not find any KTAP output.'))\n\t\tprint_mock.stop()\n\t\tself.assertEqual(0, len(result.subtests))\n\t\tself.assertEqual(result.counts.errors, 1)\n\n\tdef test_skipped_test(self):\n\t\tskipped_log = test_data_path('test_skip_tests.log')\n\t\twith open(skipped_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\n\t\t# A skipped test does not fail the whole suite.\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual(result.counts, kunit_parser.TestCounts(passed=4, skipped=1))\n\n\tdef test_skipped_all_tests(self):\n\t\tskipped_log = test_data_path('test_skip_all_tests.log')\n\t\twith open(skipped_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\n\t\tself.assertEqual(kunit_parser.TestStatus.SKIPPED, result.status)\n\t\tself.assertEqual(result.counts, kunit_parser.TestCounts(skipped=5))\n\n\tdef test_ignores_hyphen(self):\n\t\thyphen_log = test_data_path('test_strip_hyphen.log')\n\t\twith open(hyphen_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\n\t\t# A skipped test does not fail the whole suite.\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual(\n\t\t\t\"sysctl_test\",\n\t\t\tresult.subtests[0].name)\n\t\tself.assertEqual(\n\t\t\t\"example\",\n\t\t\tresult.subtests[1].name)\n\n\tdef test_ignores_prefix_printk_time(self):\n\t\tprefix_log = test_data_path('test_config_printk_time.log')\n\t\twith open(prefix_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_ignores_multiple_prefixes(self):\n\t\tprefix_log = test_data_path('test_multiple_prefixes.log')\n\t\twith open(prefix_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_prefix_mixed_kernel_output(self):\n\t\tmixed_prefix_log = test_data_path('test_interrupted_tap_output.log')\n\t\twith open(mixed_prefix_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_prefix_poundsign(self):\n\t\tpound_log = test_data_path('test_pound_sign.log')\n\t\twith open(pound_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_kernel_panic_end(self):\n\t\tpanic_log = test_data_path('test_kernel_panic_interrupt.log')\n\t\twith open(panic_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.TEST_CRASHED, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertGreaterEqual(result.counts.errors, 1)\n\n\tdef test_pound_no_prefix(self):\n\t\tpound_log = test_data_path('test_pound_no_prefix.log')\n\t\twith open(pound_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.SUCCESS, result.status)\n\t\tself.assertEqual('kunit-resource-test', result.subtests[0].name)\n\t\tself.assertEqual(result.counts.errors, 0)\n\n\tdef test_summarize_failures(self):\n\t\toutput = \"\"\"\n\t\tKTAP version 1\n\t\t1..2\n\t\t\t# Subtest: all_failed_suite\n\t\t\t1..2\n\t\t\tnot ok 1 - test1\n\t\t\tnot ok 2 - test2\n\t\tnot ok 1 - all_failed_suite\n\t\t\t# Subtest: some_failed_suite\n\t\t\t1..2\n\t\t\tok 1 - test1\n\t\t\tnot ok 2 - test2\n\t\tnot ok 1 - some_failed_suite\n\t\t\"\"\"\n\t\tresult = kunit_parser.parse_run_tests(output.splitlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.FAILURE, result.status)\n\n\t\tself.assertEqual(kunit_parser._summarize_failed_tests(result),\n\t\t\t'Failures: all_failed_suite, some_failed_suite.test2')\n\n\tdef test_ktap_format(self):\n\t\tktap_log = test_data_path('test_parse_ktap_output.log')\n\t\twith open(ktap_log) as file:\n\t\t\tresult = kunit_parser.parse_run_tests(file.readlines())\n\t\tself.assertEqual(result.counts, kunit_parser.TestCounts(passed=3))\n\t\tself.assertEqual('suite', result.subtests[0].name)\n\t\tself.assertEqual('case_1', result.subtests[0].subtests[0].name)\n\t\tself.assertEqual('case_2', result.subtests[0].subtests[1].name)\n\n\tdef test_parse_subtest_header(self):\n\t\tktap_log = test_data_path('test_parse_subtest_header.log')\n\t\twith open(ktap_log) as file:\n\t\t\tkunit_parser.parse_run_tests(file.readlines())\n\t\tself.print_mock.assert_any_call(StrContains('suite (1 subtest)'))\n\n\tdef test_show_test_output_on_failure(self):\n\t\toutput = \"\"\"\n\t\tKTAP version 1\n\t\t1..1\n\t\t  Test output.\n\t\t    Indented more.\n\t\tnot ok 1 test1\n\t\t\"\"\"\n\t\tresult = kunit_parser.parse_run_tests(output.splitlines())\n\t\tself.assertEqual(kunit_parser.TestStatus.FAILURE, result.status)\n\n\t\tself.print_mock.assert_any_call(StrContains('Test output.'))\n\t\tself.print_mock.assert_any_call(StrContains('  Indented more.'))\n\t\tself.noPrintCallContains('not ok 1 test1')\n\ndef line_stream_from_strs(strs: Iterable[str]) -> kunit_parser.LineStream:\n\treturn kunit_parser.LineStream(enumerate(strs, start=1))\n\nclass LineStreamTest(unittest.TestCase):\n\n\tdef test_basic(self):\n\t\tstream = line_stream_from_strs(['hello', 'world'])\n\n\t\tself.assertTrue(stream, msg='Should be more input')\n\t\tself.assertEqual(stream.line_number(), 1)\n\t\tself.assertEqual(stream.peek(), 'hello')\n\t\tself.assertEqual(stream.pop(), 'hello')\n\n\t\tself.assertTrue(stream, msg='Should be more input')\n\t\tself.assertEqual(stream.line_number(), 2)\n\t\tself.assertEqual(stream.peek(), 'world')\n\t\tself.assertEqual(stream.pop(), 'world')\n\n\t\tself.assertFalse(stream, msg='Should be no more input')\n\t\twith self.assertRaisesRegex(ValueError, 'LineStream: going past EOF'):\n\t\t\tstream.pop()\n\n\tdef test_is_lazy(self):\n\t\tcalled_times = 0\n\t\tdef generator():\n\t\t\tnonlocal called_times\n\t\t\tfor _ in range(1,5):\n\t\t\t\tcalled_times += 1\n\t\t\t\tyield called_times, str(called_times)\n\n\t\tstream = kunit_parser.LineStream(generator())\n\t\tself.assertEqual(called_times, 0)\n\n\t\tself.assertEqual(stream.pop(), '1')\n\t\tself.assertEqual(called_times, 1)\n\n\t\tself.assertEqual(stream.pop(), '2')\n\t\tself.assertEqual(called_times, 2)\n\nclass LinuxSourceTreeTest(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tmock.patch.object(signal, 'signal').start()\n\t\tself.addCleanup(mock.patch.stopall)\n\n\tdef test_invalid_kunitconfig(self):\n\t\twith self.assertRaisesRegex(kunit_kernel.ConfigError, 'nonexistent.* does not exist'):\n\t\t\tkunit_kernel.LinuxSourceTree('', kunitconfig_paths=['/nonexistent_file'])\n\n\tdef test_valid_kunitconfig(self):\n\t\twith tempfile.NamedTemporaryFile('wt') as kunitconfig:\n\t\t\tkunit_kernel.LinuxSourceTree('', kunitconfig_paths=[kunitconfig.name])\n\n\tdef test_dir_kunitconfig(self):\n\t\twith tempfile.TemporaryDirectory('') as dir:\n\t\t\twith open(os.path.join(dir, '.kunitconfig'), 'w'):\n\t\t\t\tpass\n\t\t\tkunit_kernel.LinuxSourceTree('', kunitconfig_paths=[dir])\n\n\tdef test_multiple_kunitconfig(self):\n\t\twant_kconfig = kunit_config.Kconfig()\n\t\twant_kconfig.add_entry('KUNIT', 'y')\n\t\twant_kconfig.add_entry('KUNIT_TEST', 'm')\n\n\t\twith tempfile.TemporaryDirectory('') as dir:\n\t\t\tother = os.path.join(dir, 'otherkunitconfig')\n\t\t\twith open(os.path.join(dir, '.kunitconfig'), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\t\t\twith open(other, 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT_TEST=m')\n\t\t\t\tpass\n\n\t\t\ttree = kunit_kernel.LinuxSourceTree('', kunitconfig_paths=[dir, other])\n\t\t\tself.assertTrue(want_kconfig.is_subset_of(tree._kconfig), msg=tree._kconfig)\n\n\n\tdef test_multiple_kunitconfig_invalid(self):\n\t\twith tempfile.TemporaryDirectory('') as dir:\n\t\t\tother = os.path.join(dir, 'otherkunitconfig')\n\t\t\twith open(os.path.join(dir, '.kunitconfig'), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\t\t\twith open(other, 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=m')\n\n\t\t\twith self.assertRaisesRegex(kunit_kernel.ConfigError, '(?s)Multiple values.*CONFIG_KUNIT'):\n\t\t\t\tkunit_kernel.LinuxSourceTree('', kunitconfig_paths=[dir, other])\n\n\n\tdef test_kconfig_add(self):\n\t\twant_kconfig = kunit_config.Kconfig()\n\t\twant_kconfig.add_entry('NOT_REAL', 'y')\n\n\t\ttree = kunit_kernel.LinuxSourceTree('', kconfig_add=['CONFIG_NOT_REAL=y'])\n\t\tself.assertTrue(want_kconfig.is_subset_of(tree._kconfig), msg=tree._kconfig)\n\n\tdef test_invalid_arch(self):\n\t\twith self.assertRaisesRegex(kunit_kernel.ConfigError, 'not a valid arch, options are.*x86_64'):\n\t\t\tkunit_kernel.LinuxSourceTree('', arch='invalid')\n\n\tdef test_run_kernel_hits_exception(self):\n\t\tdef fake_start(unused_args, unused_build_dir):\n\t\t\treturn subprocess.Popen(['echo \"hi\\nbye\"'], shell=True, text=True, stdout=subprocess.PIPE)\n\n\t\twith tempfile.TemporaryDirectory('') as build_dir:\n\t\t\ttree = kunit_kernel.LinuxSourceTree(build_dir)\n\t\t\tmock.patch.object(tree._ops, 'start', side_effect=fake_start).start()\n\n\t\t\twith self.assertRaises(ValueError):\n\t\t\t\tfor line in tree.run_kernel(build_dir=build_dir):\n\t\t\t\t\tself.assertEqual(line, 'hi\\n')\n\t\t\t\t\traise ValueError('uh oh, did not read all output')\n\n\t\t\twith open(kunit_kernel.get_outfile_path(build_dir), 'rt') as outfile:\n\t\t\t\tself.assertEqual(outfile.read(), 'hi\\nbye\\n', msg='Missing some output')\n\n\tdef test_build_reconfig_no_config(self):\n\t\twith tempfile.TemporaryDirectory('') as build_dir:\n\t\t\twith open(kunit_kernel.get_kunitconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\n\t\t\ttree = kunit_kernel.LinuxSourceTree(build_dir)\n\t\t\t# Stub out the source tree operations, so we don't have\n\t\t\t# the defaults for any given architecture get in the\n\t\t\t# way.\n\t\t\ttree._ops = kunit_kernel.LinuxSourceTreeOperations('none', None)\n\t\t\tmock_build_config = mock.patch.object(tree, 'build_config').start()\n\n\t\t\t# Should generate the .config\n\t\t\tself.assertTrue(tree.build_reconfig(build_dir, make_options=[]))\n\t\t\tmock_build_config.assert_called_once_with(build_dir, [])\n\n\tdef test_build_reconfig_existing_config(self):\n\t\twith tempfile.TemporaryDirectory('') as build_dir:\n\t\t\t# Existing .config is a superset, should not touch it\n\t\t\twith open(kunit_kernel.get_kunitconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\t\t\twith open(kunit_kernel.get_old_kunitconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\t\t\twith open(kunit_kernel.get_kconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y\\nCONFIG_KUNIT_TEST=y')\n\n\t\t\ttree = kunit_kernel.LinuxSourceTree(build_dir)\n\t\t\t# Stub out the source tree operations, so we don't have\n\t\t\t# the defaults for any given architecture get in the\n\t\t\t# way.\n\t\t\ttree._ops = kunit_kernel.LinuxSourceTreeOperations('none', None)\n\t\t\tmock_build_config = mock.patch.object(tree, 'build_config').start()\n\n\t\t\tself.assertTrue(tree.build_reconfig(build_dir, make_options=[]))\n\t\t\tself.assertEqual(mock_build_config.call_count, 0)\n\n\tdef test_build_reconfig_remove_option(self):\n\t\twith tempfile.TemporaryDirectory('') as build_dir:\n\t\t\t# We removed CONFIG_KUNIT_TEST=y from our .kunitconfig...\n\t\t\twith open(kunit_kernel.get_kunitconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y')\n\t\t\twith open(kunit_kernel.get_old_kunitconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y\\nCONFIG_KUNIT_TEST=y')\n\t\t\twith open(kunit_kernel.get_kconfig_path(build_dir), 'w') as f:\n\t\t\t\tf.write('CONFIG_KUNIT=y\\nCONFIG_KUNIT_TEST=y')\n\n\t\t\ttree = kunit_kernel.LinuxSourceTree(build_dir)\n\t\t\t# Stub out the source tree operations, so we don't have\n\t\t\t# the defaults for any given architecture get in the\n\t\t\t# way.\n\t\t\ttree._ops = kunit_kernel.LinuxSourceTreeOperations('none', None)\n\t\t\tmock_build_config = mock.patch.object(tree, 'build_config').start()\n\n\t\t\t# ... so we should trigger a call to build_config()\n\t\t\tself.assertTrue(tree.build_reconfig(build_dir, make_options=[]))\n\t\t\tmock_build_config.assert_called_once_with(build_dir, [])\n\n\t# TODO: add more test cases.\n\n\nclass KUnitJsonTest(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.print_mock = mock.patch('kunit_printer.Printer.print').start()\n\t\tself.addCleanup(mock.patch.stopall)\n\n\tdef _json_for(self, log_file):\n\t\twith open(test_data_path(log_file)) as file:\n\t\t\ttest_result = kunit_parser.parse_run_tests(file)\n\t\t\tjson_obj = kunit_json.get_json_result(\n\t\t\t\ttest=test_result,\n\t\t\t\tmetadata=kunit_json.Metadata())\n\t\treturn json.loads(json_obj)\n\n\tdef test_failed_test_json(self):\n\t\tresult = self._json_for('test_is_test_passed-failure.log')\n\t\tself.assertEqual(\n\t\t\t{'name': 'example_simple_test', 'status': 'FAIL'},\n\t\t\tresult[\"sub_groups\"][1][\"test_cases\"][0])\n\n\tdef test_crashed_test_json(self):\n\t\tresult = self._json_for('test_kernel_panic_interrupt.log')\n\t\tself.assertEqual(\n\t\t\t{'name': '', 'status': 'ERROR'},\n\t\t\tresult[\"sub_groups\"][2][\"test_cases\"][1])\n\n\tdef test_skipped_test_json(self):\n\t\tresult = self._json_for('test_skip_tests.log')\n\t\tself.assertEqual(\n\t\t\t{'name': 'example_skip_test', 'status': 'SKIP'},\n\t\t\tresult[\"sub_groups\"][1][\"test_cases\"][1])\n\n\tdef test_no_tests_json(self):\n\t\tresult = self._json_for('test_is_test_passed-no_tests_run_with_header.log')\n\t\tself.assertEqual(0, len(result['sub_groups']))\n\n\tdef test_nested_json(self):\n\t\tresult = self._json_for('test_is_test_passed-all_passed_nested.log')\n\t\tself.assertEqual(\n\t\t\t{'name': 'example_simple_test', 'status': 'PASS'},\n\t\t\tresult[\"sub_groups\"][0][\"sub_groups\"][0][\"test_cases\"][0])\n\nclass StrContains(str):\n\tdef __eq__(self, other):\n\t\treturn self in other\n\nclass KUnitMainTest(unittest.TestCase):\n\tdef setUp(self):\n\t\tpath = test_data_path('test_is_test_passed-all_passed.log')\n\t\twith open(path) as file:\n\t\t\tall_passed_log = file.readlines()\n\n\t\tself.print_mock = mock.patch('kunit_printer.Printer.print').start()\n\t\tself.addCleanup(mock.patch.stopall)\n\n\t\tself.mock_linux_init = mock.patch.object(kunit_kernel, 'LinuxSourceTree').start()\n\t\tself.linux_source_mock = self.mock_linux_init.return_value\n\t\tself.linux_source_mock.build_reconfig.return_value = True\n\t\tself.linux_source_mock.build_kernel.return_value = True\n\t\tself.linux_source_mock.run_kernel.return_value = all_passed_log\n\n\tdef test_config_passes_args_pass(self):\n\t\tkunit.main(['config', '--build_dir=.kunit'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 0)\n\n\tdef test_build_passes_args_pass(self):\n\t\tkunit.main(['build'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.linux_source_mock.build_kernel.assert_called_once_with(kunit.get_default_jobs(), '.kunit', None)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 0)\n\n\tdef test_exec_passes_args_pass(self):\n\t\tkunit.main(['exec'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 0)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_run_passes_args_pass(self):\n\t\tkunit.main(['run'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_exec_passes_args_fail(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\twith self.assertRaises(SystemExit) as e:\n\t\t\tkunit.main(['exec'])\n\t\tself.assertEqual(e.exception.code, 1)\n\n\tdef test_run_passes_args_fail(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\twith self.assertRaises(SystemExit) as e:\n\t\t\tkunit.main(['run'])\n\t\tself.assertEqual(e.exception.code, 1)\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tself.print_mock.assert_any_call(StrContains('Could not find any KTAP output.'))\n\n\tdef test_exec_no_tests(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=['TAP version 14', '1..0'])\n\t\twith self.assertRaises(SystemExit) as e:\n\t\t\tkunit.main(['run'])\n\t\tself.assertEqual(e.exception.code, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains(' 0 tests run!'))\n\n\tdef test_exec_raw_output(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\tkunit.main(['exec', '--raw_output'])\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tfor call in self.print_mock.call_args_list:\n\t\t\tself.assertNotEqual(call, mock.call(StrContains('Testing complete.')))\n\t\t\tself.assertNotEqual(call, mock.call(StrContains(' 0 tests run!')))\n\n\tdef test_run_raw_output(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\tkunit.main(['run', '--raw_output'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tfor call in self.print_mock.call_args_list:\n\t\t\tself.assertNotEqual(call, mock.call(StrContains('Testing complete.')))\n\t\t\tself.assertNotEqual(call, mock.call(StrContains(' 0 tests run!')))\n\n\tdef test_run_raw_output_kunit(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\tkunit.main(['run', '--raw_output=kunit'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.assertEqual(self.linux_source_mock.run_kernel.call_count, 1)\n\t\tfor call in self.print_mock.call_args_list:\n\t\t\tself.assertNotEqual(call, mock.call(StrContains('Testing complete.')))\n\t\t\tself.assertNotEqual(call, mock.call(StrContains(' 0 tests run')))\n\n\tdef test_run_raw_output_invalid(self):\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\twith self.assertRaises(SystemExit) as e:\n\t\t\tkunit.main(['run', '--raw_output=invalid'])\n\t\tself.assertNotEqual(e.exception.code, 0)\n\n\tdef test_run_raw_output_does_not_take_positional_args(self):\n\t\t# --raw_output is a string flag, but we don't want it to consume\n\t\t# any positional arguments, only ones after an '='\n\t\tself.linux_source_mock.run_kernel = mock.Mock(return_value=[])\n\t\tkunit.main(['run', '--raw_output', 'filter_glob'])\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='filter_glob', filter='', filter_action=None, timeout=300)\n\n\tdef test_exec_timeout(self):\n\t\ttimeout = 3453\n\t\tkunit.main(['exec', '--timeout', str(timeout)])\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=timeout)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_run_timeout(self):\n\t\ttimeout = 3453\n\t\tkunit.main(['run', '--timeout', str(timeout)])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=timeout)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_run_builddir(self):\n\t\tbuild_dir = '.kunit'\n\t\tkunit.main(['run', '--build_dir=.kunit'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir=build_dir, filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_config_builddir(self):\n\t\tbuild_dir = '.kunit'\n\t\tkunit.main(['config', '--build_dir', build_dir])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\n\tdef test_build_builddir(self):\n\t\tbuild_dir = '.kunit'\n\t\tjobs = kunit.get_default_jobs()\n\t\tkunit.main(['build', '--build_dir', build_dir])\n\t\tself.linux_source_mock.build_kernel.assert_called_once_with(jobs, build_dir, None)\n\n\tdef test_exec_builddir(self):\n\t\tbuild_dir = '.kunit'\n\t\tkunit.main(['exec', '--build_dir', build_dir])\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=None, build_dir=build_dir, filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_run_kunitconfig(self):\n\t\tkunit.main(['run', '--kunitconfig=mykunitconfig'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tself.mock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\tkunitconfig_paths=['mykunitconfig'],\n\t\t\t\t\t\tkconfig_add=None,\n\t\t\t\t\t\tarch='um',\n\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\textra_qemu_args=[])\n\n\tdef test_config_kunitconfig(self):\n\t\tkunit.main(['config', '--kunitconfig=mykunitconfig'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tself.mock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\tkunitconfig_paths=['mykunitconfig'],\n\t\t\t\t\t\tkconfig_add=None,\n\t\t\t\t\t\tarch='um',\n\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\textra_qemu_args=[])\n\n\tdef test_config_alltests(self):\n\t\tkunit.main(['config', '--kunitconfig=mykunitconfig', '--alltests'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tself.mock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\tkunitconfig_paths=[kunit_kernel.ALL_TESTS_CONFIG_PATH, 'mykunitconfig'],\n\t\t\t\t\t\tkconfig_add=None,\n\t\t\t\t\t\tarch='um',\n\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\textra_qemu_args=[])\n\n\n\t@mock.patch.object(kunit_kernel, 'LinuxSourceTree')\n\tdef test_run_multiple_kunitconfig(self, mock_linux_init):\n\t\tmock_linux_init.return_value = self.linux_source_mock\n\t\tkunit.main(['run', '--kunitconfig=mykunitconfig', '--kunitconfig=other'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tmock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\t\tkunitconfig_paths=['mykunitconfig', 'other'],\n\t\t\t\t\t\t\tkconfig_add=None,\n\t\t\t\t\t\t\tarch='um',\n\t\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\t\textra_qemu_args=[])\n\n\tdef test_run_kconfig_add(self):\n\t\tkunit.main(['run', '--kconfig_add=CONFIG_KASAN=y', '--kconfig_add=CONFIG_KCSAN=y'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tself.mock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\tkunitconfig_paths=[],\n\t\t\t\t\t\tkconfig_add=['CONFIG_KASAN=y', 'CONFIG_KCSAN=y'],\n\t\t\t\t\t\tarch='um',\n\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\textra_qemu_args=[])\n\n\tdef test_run_qemu_args(self):\n\t\tkunit.main(['run', '--arch=x86_64', '--qemu_args', '-m 2048'])\n\t\t# Just verify that we parsed and initialized it correctly here.\n\t\tself.mock_linux_init.assert_called_once_with('.kunit',\n\t\t\t\t\t\tkunitconfig_paths=[],\n\t\t\t\t\t\tkconfig_add=None,\n\t\t\t\t\t\tarch='x86_64',\n\t\t\t\t\t\tcross_compile=None,\n\t\t\t\t\t\tqemu_config_path=None,\n\t\t\t\t\t\textra_qemu_args=['-m', '2048'])\n\n\tdef test_run_kernel_args(self):\n\t\tkunit.main(['run', '--kernel_args=a=1', '--kernel_args=b=2'])\n\t\tself.assertEqual(self.linux_source_mock.build_reconfig.call_count, 1)\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t      args=['a=1','b=2'], build_dir='.kunit', filter_glob='', filter='', filter_action=None, timeout=300)\n\t\tself.print_mock.assert_any_call(StrContains('Testing complete.'))\n\n\tdef test_list_tests(self):\n\t\twant = ['suite.test1', 'suite.test2', 'suite2.test1']\n\t\tself.linux_source_mock.run_kernel.return_value = ['TAP version 14', 'init: random output'] + want\n\n\t\tgot = kunit._list_tests(self.linux_source_mock,\n\t\t\t\t     kunit.KunitExecRequest(None, None, '.kunit', 300, 'suite*', '', None, None, 'suite', False, False))\n\t\tself.assertEqual(got, want)\n\t\t# Should respect the user's filter glob when listing tests.\n\t\tself.linux_source_mock.run_kernel.assert_called_once_with(\n\t\t\targs=['kunit.action=list'], build_dir='.kunit', filter_glob='suite*', filter='', filter_action=None, timeout=300)\n\n\t@mock.patch.object(kunit, '_list_tests')\n\tdef test_run_isolated_by_suite(self, mock_tests):\n\t\tmock_tests.return_value = ['suite.test1', 'suite.test2', 'suite2.test1']\n\t\tkunit.main(['exec', '--run_isolated=suite', 'suite*.test*'])\n\n\t\t# Should respect the user's filter glob when listing tests.\n\t\tmock_tests.assert_called_once_with(mock.ANY,\n\t\t\t\t     kunit.KunitExecRequest(None, None, '.kunit', 300, 'suite*.test*', '', None, None, 'suite', False, False))\n\t\tself.linux_source_mock.run_kernel.assert_has_calls([\n\t\t\tmock.call(args=None, build_dir='.kunit', filter_glob='suite.test*', filter='', filter_action=None, timeout=300),\n\t\t\tmock.call(args=None, build_dir='.kunit', filter_glob='suite2.test*', filter='', filter_action=None, timeout=300),\n\t\t])\n\n\t@mock.patch.object(kunit, '_list_tests')\n\tdef test_run_isolated_by_test(self, mock_tests):\n\t\tmock_tests.return_value = ['suite.test1', 'suite.test2', 'suite2.test1']\n\t\tkunit.main(['exec', '--run_isolated=test', 'suite*'])\n\n\t\t# Should respect the user's filter glob when listing tests.\n\t\tmock_tests.assert_called_once_with(mock.ANY,\n\t\t\t\t     kunit.KunitExecRequest(None, None, '.kunit', 300, 'suite*', '', None, None, 'test', False, False))\n\t\tself.linux_source_mock.run_kernel.assert_has_calls([\n\t\t\tmock.call(args=None, build_dir='.kunit', filter_glob='suite.test1', filter='', filter_action=None, timeout=300),\n\t\t\tmock.call(args=None, build_dir='.kunit', filter_glob='suite.test2', filter='', filter_action=None, timeout=300),\n\t\t\tmock.call(args=None, build_dir='.kunit', filter_glob='suite2.test1', filter='', filter_action=None, timeout=300),\n\t\t])\n\nif __name__ == '__main__':\n\tunittest.main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}