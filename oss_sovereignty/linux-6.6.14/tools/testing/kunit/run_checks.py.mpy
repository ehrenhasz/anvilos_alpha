{
  "module_name": "run_checks.py",
  "hash_id": "665423d61c2e9f594fe2dcc32f1b8fc01411a4493314e3b593082523d5695ea8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/run_checks.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# This file runs some basic checks to verify kunit works.\n# It is only of interest if you're making changes to KUnit itself.\n#\n# Copyright (C) 2021, Google LLC.\n# Author: Daniel Latypov <dlatypov@google.com.com>\n\nfrom concurrent import futures\nimport datetime\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport textwrap\nfrom typing import Dict, List, Sequence\n\nABS_TOOL_PATH = os.path.abspath(os.path.dirname(__file__))\nTIMEOUT = datetime.timedelta(minutes=5).total_seconds()\n\ncommands: Dict[str, Sequence[str]] = {\n\t'kunit_tool_test.py': ['./kunit_tool_test.py'],\n\t'kunit smoke test': ['./kunit.py', 'run', '--kunitconfig=lib/kunit', '--build_dir=kunit_run_checks'],\n\t'pytype': ['/bin/sh', '-c', 'pytype *.py'],\n\t'mypy': ['mypy', '--config-file', 'mypy.ini', '--exclude', '_test.py$', '--exclude', 'qemu_configs/', '.'],\n}\n\n# The user might not have mypy or pytype installed, skip them if so.\n# Note: you can install both via `$ pip install mypy pytype`\nnecessary_deps : Dict[str, str] = {\n\t'pytype': 'pytype',\n\t'mypy': 'mypy',\n}\n\ndef main(argv: Sequence[str]) -> None:\n\tif argv:\n\t\traise RuntimeError('This script takes no arguments')\n\n\tfuture_to_name: Dict[futures.Future[None], str] = {}\n\texecutor = futures.ThreadPoolExecutor(max_workers=len(commands))\n\tfor name, argv in commands.items():\n\t\tif name in necessary_deps and shutil.which(necessary_deps[name]) is None:\n\t\t\tprint(f'{name}: SKIPPED, {necessary_deps[name]} not in $PATH')\n\t\t\tcontinue\n\t\tf = executor.submit(run_cmd, argv)\n\t\tfuture_to_name[f] = name\n\n\thas_failures = False\n\tprint(f'Waiting on {len(future_to_name)} checks ({\", \".join(future_to_name.values())})...')\n\tfor f in  futures.as_completed(future_to_name.keys()):\n\t\tname = future_to_name[f]\n\t\tex = f.exception()\n\t\tif not ex:\n\t\t\tprint(f'{name}: PASSED')\n\t\t\tcontinue\n\n\t\thas_failures = True\n\t\tif isinstance(ex, subprocess.TimeoutExpired):\n\t\t\tprint(f'{name}: TIMED OUT')\n\t\telif isinstance(ex, subprocess.CalledProcessError):\n\t\t\tprint(f'{name}: FAILED')\n\t\telse:\n\t\t\tprint(f'{name}: unexpected exception: {ex}')\n\t\t\tcontinue\n\n\t\toutput = ex.output\n\t\tif output:\n\t\t\tprint(textwrap.indent(output.decode(), '> '))\n\texecutor.shutdown()\n\n\tif has_failures:\n\t\tsys.exit(1)\n\n\ndef run_cmd(argv: Sequence[str]) -> None:\n\tsubprocess.check_output(argv, stderr=subprocess.STDOUT, cwd=ABS_TOOL_PATH, timeout=TIMEOUT)\n\n\nif __name__ == '__main__':\n\tmain(sys.argv[1:])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}