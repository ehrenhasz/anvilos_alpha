{
  "module_name": "kunit.py",
  "hash_id": "53ef596e6e0122a1d6cd32c24380566d2d1019d7383ff233c43ad99fa981a71d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/kunit.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# A thin wrapper on top of the KUnit Kernel\n#\n# Copyright (C) 2019, Google LLC.\n# Author: Felix Guo <felixguoxiuping@gmail.com>\n# Author: Brendan Higgins <brendanhiggins@google.com>\n\nimport argparse\nimport os\nimport re\nimport shlex\nimport sys\nimport time\n\nassert sys.version_info >= (3, 7), \"Python version is too old\"\n\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom typing import Iterable, List, Optional, Sequence, Tuple\n\nimport kunit_json\nimport kunit_kernel\nimport kunit_parser\nfrom kunit_printer import stdout\n\nclass KunitStatus(Enum):\n\tSUCCESS = auto()\n\tCONFIG_FAILURE = auto()\n\tBUILD_FAILURE = auto()\n\tTEST_FAILURE = auto()\n\n@dataclass\nclass KunitResult:\n\tstatus: KunitStatus\n\telapsed_time: float\n\n@dataclass\nclass KunitConfigRequest:\n\tbuild_dir: str\n\tmake_options: Optional[List[str]]\n\n@dataclass\nclass KunitBuildRequest(KunitConfigRequest):\n\tjobs: int\n\n@dataclass\nclass KunitParseRequest:\n\traw_output: Optional[str]\n\tjson: Optional[str]\n\n@dataclass\nclass KunitExecRequest(KunitParseRequest):\n\tbuild_dir: str\n\ttimeout: int\n\tfilter_glob: str\n\tfilter: str\n\tfilter_action: Optional[str]\n\tkernel_args: Optional[List[str]]\n\trun_isolated: Optional[str]\n\tlist_tests: bool\n\tlist_tests_attr: bool\n\n@dataclass\nclass KunitRequest(KunitExecRequest, KunitBuildRequest):\n\tpass\n\n\ndef get_kernel_root_path() -> str:\n\tpath = sys.argv[0] if not __file__ else __file__\n\tparts = os.path.realpath(path).split('tools/testing/kunit')\n\tif len(parts) != 2:\n\t\tsys.exit(1)\n\treturn parts[0]\n\ndef config_tests(linux: kunit_kernel.LinuxSourceTree,\n\t\t request: KunitConfigRequest) -> KunitResult:\n\tstdout.print_with_timestamp('Configuring KUnit Kernel ...')\n\n\tconfig_start = time.time()\n\tsuccess = linux.build_reconfig(request.build_dir, request.make_options)\n\tconfig_end = time.time()\n\tstatus = KunitStatus.SUCCESS if success else KunitStatus.CONFIG_FAILURE\n\treturn KunitResult(status, config_end - config_start)\n\ndef build_tests(linux: kunit_kernel.LinuxSourceTree,\n\t\trequest: KunitBuildRequest) -> KunitResult:\n\tstdout.print_with_timestamp('Building KUnit Kernel ...')\n\n\tbuild_start = time.time()\n\tsuccess = linux.build_kernel(request.jobs,\n\t\t\t\t     request.build_dir,\n\t\t\t\t     request.make_options)\n\tbuild_end = time.time()\n\tstatus = KunitStatus.SUCCESS if success else KunitStatus.BUILD_FAILURE\n\treturn KunitResult(status, build_end - build_start)\n\ndef config_and_build_tests(linux: kunit_kernel.LinuxSourceTree,\n\t\t\t   request: KunitBuildRequest) -> KunitResult:\n\tconfig_result = config_tests(linux, request)\n\tif config_result.status != KunitStatus.SUCCESS:\n\t\treturn config_result\n\n\treturn build_tests(linux, request)\n\ndef _list_tests(linux: kunit_kernel.LinuxSourceTree, request: KunitExecRequest) -> List[str]:\n\targs = ['kunit.action=list']\n\n\tif request.kernel_args:\n\t\targs.extend(request.kernel_args)\n\n\toutput = linux.run_kernel(args=args,\n\t\t\t   timeout=request.timeout,\n\t\t\t   filter_glob=request.filter_glob,\n\t\t\t   filter=request.filter,\n\t\t\t   filter_action=request.filter_action,\n\t\t\t   build_dir=request.build_dir)\n\tlines = kunit_parser.extract_tap_lines(output)\n\t# Hack! Drop the dummy TAP version header that the executor prints out.\n\tlines.pop()\n\n\t# Filter out any extraneous non-test output that might have gotten mixed in.\n\treturn [l for l in output if re.match(r'^[^\\s.]+\\.[^\\s.]+$', l)]\n\ndef _list_tests_attr(linux: kunit_kernel.LinuxSourceTree, request: KunitExecRequest) -> Iterable[str]:\n\targs = ['kunit.action=list_attr']\n\n\tif request.kernel_args:\n\t\targs.extend(request.kernel_args)\n\n\toutput = linux.run_kernel(args=args,\n\t\t\t   timeout=request.timeout,\n\t\t\t   filter_glob=request.filter_glob,\n\t\t\t   filter=request.filter,\n\t\t\t   filter_action=request.filter_action,\n\t\t\t   build_dir=request.build_dir)\n\tlines = kunit_parser.extract_tap_lines(output)\n\t# Hack! Drop the dummy TAP version header that the executor prints out.\n\tlines.pop()\n\n\t# Filter out any extraneous non-test output that might have gotten mixed in.\n\treturn lines\n\ndef _suites_from_test_list(tests: List[str]) -> List[str]:\n\t\"\"\"Extracts all the suites from an ordered list of tests.\"\"\"\n\tsuites = []  # type: List[str]\n\tfor t in tests:\n\t\tparts = t.split('.', maxsplit=2)\n\t\tif len(parts) != 2:\n\t\t\traise ValueError(f'internal KUnit error, test name should be of the form \"<suite>.<test>\", got \"{t}\"')\n\t\tsuite, _ = parts\n\t\tif not suites or suites[-1] != suite:\n\t\t\tsuites.append(suite)\n\treturn suites\n\ndef exec_tests(linux: kunit_kernel.LinuxSourceTree, request: KunitExecRequest) -> KunitResult:\n\tfilter_globs = [request.filter_glob]\n\tif request.list_tests:\n\t\toutput = _list_tests(linux, request)\n\t\tfor line in output:\n\t\t\tprint(line.rstrip())\n\t\treturn KunitResult(status=KunitStatus.SUCCESS, elapsed_time=0.0)\n\tif request.list_tests_attr:\n\t\tattr_output = _list_tests_attr(linux, request)\n\t\tfor line in attr_output:\n\t\t\tprint(line.rstrip())\n\t\treturn KunitResult(status=KunitStatus.SUCCESS, elapsed_time=0.0)\n\tif request.run_isolated:\n\t\ttests = _list_tests(linux, request)\n\t\tif request.run_isolated == 'test':\n\t\t\tfilter_globs = tests\n\t\telif request.run_isolated == 'suite':\n\t\t\tfilter_globs = _suites_from_test_list(tests)\n\t\t\t# Apply the test-part of the user's glob, if present.\n\t\t\tif '.' in request.filter_glob:\n\t\t\t\ttest_glob = request.filter_glob.split('.', maxsplit=2)[1]\n\t\t\t\tfilter_globs = [g + '.'+ test_glob for g in filter_globs]\n\n\tmetadata = kunit_json.Metadata(arch=linux.arch(), build_dir=request.build_dir, def_config='kunit_defconfig')\n\n\ttest_counts = kunit_parser.TestCounts()\n\texec_time = 0.0\n\tfor i, filter_glob in enumerate(filter_globs):\n\t\tstdout.print_with_timestamp('Starting KUnit Kernel ({}/{})...'.format(i+1, len(filter_globs)))\n\n\t\ttest_start = time.time()\n\t\trun_result = linux.run_kernel(\n\t\t\targs=request.kernel_args,\n\t\t\ttimeout=request.timeout,\n\t\t\tfilter_glob=filter_glob,\n\t\t\tfilter=request.filter,\n\t\t\tfilter_action=request.filter_action,\n\t\t\tbuild_dir=request.build_dir)\n\n\t\t_, test_result = parse_tests(request, metadata, run_result)\n\t\t# run_kernel() doesn't block on the kernel exiting.\n\t\t# That only happens after we get the last line of output from `run_result`.\n\t\t# So exec_time here actually contains parsing + execution time, which is fine.\n\t\ttest_end = time.time()\n\t\texec_time += test_end - test_start\n\n\t\ttest_counts.add_subtest_counts(test_result.counts)\n\n\tif len(filter_globs) == 1 and test_counts.crashed > 0:\n\t\tbd = request.build_dir\n\t\tprint('The kernel seems to have crashed; you can decode the stack traces with:')\n\t\tprint('$ scripts/decode_stacktrace.sh {}/vmlinux {} < {} | tee {}/decoded.log | {} parse'.format(\n\t\t\t\tbd, bd, kunit_kernel.get_outfile_path(bd), bd, sys.argv[0]))\n\n\tkunit_status = _map_to_overall_status(test_counts.get_status())\n\treturn KunitResult(status=kunit_status, elapsed_time=exec_time)\n\ndef _map_to_overall_status(test_status: kunit_parser.TestStatus) -> KunitStatus:\n\tif test_status in (kunit_parser.TestStatus.SUCCESS, kunit_parser.TestStatus.SKIPPED):\n\t\treturn KunitStatus.SUCCESS\n\treturn KunitStatus.TEST_FAILURE\n\ndef parse_tests(request: KunitParseRequest, metadata: kunit_json.Metadata, input_data: Iterable[str]) -> Tuple[KunitResult, kunit_parser.Test]:\n\tparse_start = time.time()\n\n\tif request.raw_output:\n\t\t# Treat unparsed results as one passing test.\n\t\tfake_test = kunit_parser.Test()\n\t\tfake_test.status = kunit_parser.TestStatus.SUCCESS\n\t\tfake_test.counts.passed = 1\n\n\t\toutput: Iterable[str] = input_data\n\t\tif request.raw_output == 'all':\n\t\t\tpass\n\t\telif request.raw_output == 'kunit':\n\t\t\toutput = kunit_parser.extract_tap_lines(output)\n\t\tfor line in output:\n\t\t\tprint(line.rstrip())\n\t\tparse_time = time.time() - parse_start\n\t\treturn KunitResult(KunitStatus.SUCCESS, parse_time), fake_test\n\n\n\t# Actually parse the test results.\n\ttest = kunit_parser.parse_run_tests(input_data)\n\tparse_time = time.time() - parse_start\n\n\tif request.json:\n\t\tjson_str = kunit_json.get_json_result(\n\t\t\t\t\ttest=test,\n\t\t\t\t\tmetadata=metadata)\n\t\tif request.json == 'stdout':\n\t\t\tprint(json_str)\n\t\telse:\n\t\t\twith open(request.json, 'w') as f:\n\t\t\t\tf.write(json_str)\n\t\t\tstdout.print_with_timestamp(\"Test results stored in %s\" %\n\t\t\t\tos.path.abspath(request.json))\n\n\tif test.status != kunit_parser.TestStatus.SUCCESS:\n\t\treturn KunitResult(KunitStatus.TEST_FAILURE, parse_time), test\n\n\treturn KunitResult(KunitStatus.SUCCESS, parse_time), test\n\ndef run_tests(linux: kunit_kernel.LinuxSourceTree,\n\t      request: KunitRequest) -> KunitResult:\n\trun_start = time.time()\n\n\tconfig_result = config_tests(linux, request)\n\tif config_result.status != KunitStatus.SUCCESS:\n\t\treturn config_result\n\n\tbuild_result = build_tests(linux, request)\n\tif build_result.status != KunitStatus.SUCCESS:\n\t\treturn build_result\n\n\texec_result = exec_tests(linux, request)\n\n\trun_end = time.time()\n\n\tstdout.print_with_timestamp((\n\t\t'Elapsed time: %.3fs total, %.3fs configuring, %.3fs ' +\n\t\t'building, %.3fs running\\n') % (\n\t\t\t\trun_end - run_start,\n\t\t\t\tconfig_result.elapsed_time,\n\t\t\t\tbuild_result.elapsed_time,\n\t\t\t\texec_result.elapsed_time))\n\treturn exec_result\n\n# Problem:\n# $ kunit.py run --json\n# works as one would expect and prints the parsed test results as JSON.\n# $ kunit.py run --json suite_name\n# would *not* pass suite_name as the filter_glob and print as json.\n# argparse will consider it to be another way of writing\n# $ kunit.py run --json=suite_name\n# i.e. it would run all tests, and dump the json to a `suite_name` file.\n# So we hackily automatically rewrite --json => --json=stdout\npseudo_bool_flag_defaults = {\n\t\t'--json': 'stdout',\n\t\t'--raw_output': 'kunit',\n}\ndef massage_argv(argv: Sequence[str]) -> Sequence[str]:\n\tdef massage_arg(arg: str) -> str:\n\t\tif arg not in pseudo_bool_flag_defaults:\n\t\t\treturn arg\n\t\treturn  f'{arg}={pseudo_bool_flag_defaults[arg]}'\n\treturn list(map(massage_arg, argv))\n\ndef get_default_jobs() -> int:\n\treturn len(os.sched_getaffinity(0))\n\ndef add_common_opts(parser: argparse.ArgumentParser) -> None:\n\tparser.add_argument('--build_dir',\n\t\t\t    help='As in the make command, it specifies the build '\n\t\t\t    'directory.',\n\t\t\t    type=str, default='.kunit', metavar='DIR')\n\tparser.add_argument('--make_options',\n\t\t\t    help='X=Y make option, can be repeated.',\n\t\t\t    action='append', metavar='X=Y')\n\tparser.add_argument('--alltests',\n\t\t\t    help='Run all KUnit tests via tools/testing/kunit/configs/all_tests.config',\n\t\t\t    action='store_true')\n\tparser.add_argument('--kunitconfig',\n\t\t\t     help='Path to Kconfig fragment that enables KUnit tests.'\n\t\t\t     ' If given a directory, (e.g. lib/kunit), \"/.kunitconfig\" '\n\t\t\t     'will get  automatically appended. If repeated, the files '\n\t\t\t     'blindly concatenated, which might not work in all cases.',\n\t\t\t     action='append', metavar='PATHS')\n\tparser.add_argument('--kconfig_add',\n\t\t\t     help='Additional Kconfig options to append to the '\n\t\t\t     '.kunitconfig, e.g. CONFIG_KASAN=y. Can be repeated.',\n\t\t\t    action='append', metavar='CONFIG_X=Y')\n\n\tparser.add_argument('--arch',\n\t\t\t    help=('Specifies the architecture to run tests under. '\n\t\t\t\t  'The architecture specified here must match the '\n\t\t\t\t  'string passed to the ARCH make param, '\n\t\t\t\t  'e.g. i386, x86_64, arm, um, etc. Non-UML '\n\t\t\t\t  'architectures run on QEMU.'),\n\t\t\t    type=str, default='um', metavar='ARCH')\n\n\tparser.add_argument('--cross_compile',\n\t\t\t    help=('Sets make\\'s CROSS_COMPILE variable; it should '\n\t\t\t\t  'be set to a toolchain path prefix (the prefix '\n\t\t\t\t  'of gcc and other tools in your toolchain, for '\n\t\t\t\t  'example `sparc64-linux-gnu-` if you have the '\n\t\t\t\t  'sparc toolchain installed on your system, or '\n\t\t\t\t  '`$HOME/toolchains/microblaze/gcc-9.2.0-nolibc/microblaze-linux/bin/microblaze-linux-` '\n\t\t\t\t  'if you have downloaded the microblaze toolchain '\n\t\t\t\t  'from the 0-day website to a directory in your '\n\t\t\t\t  'home directory called `toolchains`).'),\n\t\t\t    metavar='PREFIX')\n\n\tparser.add_argument('--qemu_config',\n\t\t\t    help=('Takes a path to a path to a file containing '\n\t\t\t\t  'a QemuArchParams object.'),\n\t\t\t    type=str, metavar='FILE')\n\n\tparser.add_argument('--qemu_args',\n\t\t\t    help='Additional QEMU arguments, e.g. \"-smp 8\"',\n\t\t\t    action='append', metavar='')\n\ndef add_build_opts(parser: argparse.ArgumentParser) -> None:\n\tparser.add_argument('--jobs',\n\t\t\t    help='As in the make command, \"Specifies  the number of '\n\t\t\t    'jobs (commands) to run simultaneously.\"',\n\t\t\t    type=int, default=get_default_jobs(), metavar='N')\n\ndef add_exec_opts(parser: argparse.ArgumentParser) -> None:\n\tparser.add_argument('--timeout',\n\t\t\t    help='maximum number of seconds to allow for all tests '\n\t\t\t    'to run. This does not include time taken to build the '\n\t\t\t    'tests.',\n\t\t\t    type=int,\n\t\t\t    default=300,\n\t\t\t    metavar='SECONDS')\n\tparser.add_argument('filter_glob',\n\t\t\t    help='Filter which KUnit test suites/tests run at '\n\t\t\t    'boot-time, e.g. list* or list*.*del_test',\n\t\t\t    type=str,\n\t\t\t    nargs='?',\n\t\t\t    default='',\n\t\t\t    metavar='filter_glob')\n\tparser.add_argument('--filter',\n\t\t\t    help='Filter KUnit tests with attributes, '\n\t\t\t    'e.g. module=example or speed>slow',\n\t\t\t    type=str,\n\t\t\t\tdefault='')\n\tparser.add_argument('--filter_action',\n\t\t\t    help='If set to skip, filtered tests will be skipped, '\n\t\t\t\t'e.g. --filter_action=skip. Otherwise they will not run.',\n\t\t\t    type=str,\n\t\t\t\tchoices=['skip'])\n\tparser.add_argument('--kernel_args',\n\t\t\t    help='Kernel command-line parameters. Maybe be repeated',\n\t\t\t     action='append', metavar='')\n\tparser.add_argument('--run_isolated', help='If set, boot the kernel for each '\n\t\t\t    'individual suite/test. This is can be useful for debugging '\n\t\t\t    'a non-hermetic test, one that might pass/fail based on '\n\t\t\t    'what ran before it.',\n\t\t\t    type=str,\n\t\t\t    choices=['suite', 'test'])\n\tparser.add_argument('--list_tests', help='If set, list all tests that will be '\n\t\t\t    'run.',\n\t\t\t    action='store_true')\n\tparser.add_argument('--list_tests_attr', help='If set, list all tests and test '\n\t\t\t    'attributes.',\n\t\t\t    action='store_true')\n\ndef add_parse_opts(parser: argparse.ArgumentParser) -> None:\n\tparser.add_argument('--raw_output', help='If set don\\'t parse output from kernel. '\n\t\t\t    'By default, filters to just KUnit output. Use '\n\t\t\t    '--raw_output=all to show everything',\n\t\t\t     type=str, nargs='?', const='all', default=None, choices=['all', 'kunit'])\n\tparser.add_argument('--json',\n\t\t\t    nargs='?',\n\t\t\t    help='Prints parsed test results as JSON to stdout or a file if '\n\t\t\t    'a filename is specified. Does nothing if --raw_output is set.',\n\t\t\t    type=str, const='stdout', default=None, metavar='FILE')\n\n\ndef tree_from_args(cli_args: argparse.Namespace) -> kunit_kernel.LinuxSourceTree:\n\t\"\"\"Returns a LinuxSourceTree based on the user's arguments.\"\"\"\n\t# Allow users to specify multiple arguments in one string, e.g. '-smp 8'\n\tqemu_args: List[str] = []\n\tif cli_args.qemu_args:\n\t\tfor arg in cli_args.qemu_args:\n\t\t\tqemu_args.extend(shlex.split(arg))\n\n\tkunitconfigs = cli_args.kunitconfig if cli_args.kunitconfig else []\n\tif cli_args.alltests:\n\t\t# Prepend so user-specified options take prio if we ever allow\n\t\t# --kunitconfig options to have differing options.\n\t\tkunitconfigs = [kunit_kernel.ALL_TESTS_CONFIG_PATH] + kunitconfigs\n\n\treturn kunit_kernel.LinuxSourceTree(cli_args.build_dir,\n\t\t\tkunitconfig_paths=kunitconfigs,\n\t\t\tkconfig_add=cli_args.kconfig_add,\n\t\t\tarch=cli_args.arch,\n\t\t\tcross_compile=cli_args.cross_compile,\n\t\t\tqemu_config_path=cli_args.qemu_config,\n\t\t\textra_qemu_args=qemu_args)\n\n\ndef run_handler(cli_args: argparse.Namespace) -> None:\n\tif not os.path.exists(cli_args.build_dir):\n\t\tos.mkdir(cli_args.build_dir)\n\n\tlinux = tree_from_args(cli_args)\n\trequest = KunitRequest(build_dir=cli_args.build_dir,\n\t\t\t\t\tmake_options=cli_args.make_options,\n\t\t\t\t\tjobs=cli_args.jobs,\n\t\t\t\t\traw_output=cli_args.raw_output,\n\t\t\t\t\tjson=cli_args.json,\n\t\t\t\t\ttimeout=cli_args.timeout,\n\t\t\t\t\tfilter_glob=cli_args.filter_glob,\n\t\t\t\t\tfilter=cli_args.filter,\n\t\t\t\t\tfilter_action=cli_args.filter_action,\n\t\t\t\t\tkernel_args=cli_args.kernel_args,\n\t\t\t\t\trun_isolated=cli_args.run_isolated,\n\t\t\t\t\tlist_tests=cli_args.list_tests,\n\t\t\t\t\tlist_tests_attr=cli_args.list_tests_attr)\n\tresult = run_tests(linux, request)\n\tif result.status != KunitStatus.SUCCESS:\n\t\tsys.exit(1)\n\n\ndef config_handler(cli_args: argparse.Namespace) -> None:\n\tif cli_args.build_dir and (\n\t\t\tnot os.path.exists(cli_args.build_dir)):\n\t\tos.mkdir(cli_args.build_dir)\n\n\tlinux = tree_from_args(cli_args)\n\trequest = KunitConfigRequest(build_dir=cli_args.build_dir,\n\t\t\t\t\t\tmake_options=cli_args.make_options)\n\tresult = config_tests(linux, request)\n\tstdout.print_with_timestamp((\n\t\t'Elapsed time: %.3fs\\n') % (\n\t\t\tresult.elapsed_time))\n\tif result.status != KunitStatus.SUCCESS:\n\t\tsys.exit(1)\n\n\ndef build_handler(cli_args: argparse.Namespace) -> None:\n\tlinux = tree_from_args(cli_args)\n\trequest = KunitBuildRequest(build_dir=cli_args.build_dir,\n\t\t\t\t\tmake_options=cli_args.make_options,\n\t\t\t\t\tjobs=cli_args.jobs)\n\tresult = config_and_build_tests(linux, request)\n\tstdout.print_with_timestamp((\n\t\t'Elapsed time: %.3fs\\n') % (\n\t\t\tresult.elapsed_time))\n\tif result.status != KunitStatus.SUCCESS:\n\t\tsys.exit(1)\n\n\ndef exec_handler(cli_args: argparse.Namespace) -> None:\n\tlinux = tree_from_args(cli_args)\n\texec_request = KunitExecRequest(raw_output=cli_args.raw_output,\n\t\t\t\t\tbuild_dir=cli_args.build_dir,\n\t\t\t\t\tjson=cli_args.json,\n\t\t\t\t\ttimeout=cli_args.timeout,\n\t\t\t\t\tfilter_glob=cli_args.filter_glob,\n\t\t\t\t\tfilter=cli_args.filter,\n\t\t\t\t\tfilter_action=cli_args.filter_action,\n\t\t\t\t\tkernel_args=cli_args.kernel_args,\n\t\t\t\t\trun_isolated=cli_args.run_isolated,\n\t\t\t\t\tlist_tests=cli_args.list_tests,\n\t\t\t\t\tlist_tests_attr=cli_args.list_tests_attr)\n\tresult = exec_tests(linux, exec_request)\n\tstdout.print_with_timestamp((\n\t\t'Elapsed time: %.3fs\\n') % (result.elapsed_time))\n\tif result.status != KunitStatus.SUCCESS:\n\t\tsys.exit(1)\n\n\ndef parse_handler(cli_args: argparse.Namespace) -> None:\n\tif cli_args.file is None:\n\t\tsys.stdin.reconfigure(errors='backslashreplace')  # type: ignore\n\t\tkunit_output = sys.stdin  # type: Iterable[str]\n\telse:\n\t\twith open(cli_args.file, 'r', errors='backslashreplace') as f:\n\t\t\tkunit_output = f.read().splitlines()\n\t# We know nothing about how the result was created!\n\tmetadata = kunit_json.Metadata()\n\trequest = KunitParseRequest(raw_output=cli_args.raw_output,\n\t\t\t\t\tjson=cli_args.json)\n\tresult, _ = parse_tests(request, metadata, kunit_output)\n\tif result.status != KunitStatus.SUCCESS:\n\t\tsys.exit(1)\n\n\nsubcommand_handlers_map = {\n\t'run': run_handler,\n\t'config': config_handler,\n\t'build': build_handler,\n\t'exec': exec_handler,\n\t'parse': parse_handler\n}\n\n\ndef main(argv: Sequence[str]) -> None:\n\tparser = argparse.ArgumentParser(\n\t\t\tdescription='Helps writing and running KUnit tests.')\n\tsubparser = parser.add_subparsers(dest='subcommand')\n\n\t# The 'run' command will config, build, exec, and parse in one go.\n\trun_parser = subparser.add_parser('run', help='Runs KUnit tests.')\n\tadd_common_opts(run_parser)\n\tadd_build_opts(run_parser)\n\tadd_exec_opts(run_parser)\n\tadd_parse_opts(run_parser)\n\n\tconfig_parser = subparser.add_parser('config',\n\t\t\t\t\t\thelp='Ensures that .config contains all of '\n\t\t\t\t\t\t'the options in .kunitconfig')\n\tadd_common_opts(config_parser)\n\n\tbuild_parser = subparser.add_parser('build', help='Builds a kernel with KUnit tests')\n\tadd_common_opts(build_parser)\n\tadd_build_opts(build_parser)\n\n\texec_parser = subparser.add_parser('exec', help='Run a kernel with KUnit tests')\n\tadd_common_opts(exec_parser)\n\tadd_exec_opts(exec_parser)\n\tadd_parse_opts(exec_parser)\n\n\t# The 'parse' option is special, as it doesn't need the kernel source\n\t# (therefore there is no need for a build_dir, hence no add_common_opts)\n\t# and the '--file' argument is not relevant to 'run', so isn't in\n\t# add_parse_opts()\n\tparse_parser = subparser.add_parser('parse',\n\t\t\t\t\t    help='Parses KUnit results from a file, '\n\t\t\t\t\t    'and parses formatted results.')\n\tadd_parse_opts(parse_parser)\n\tparse_parser.add_argument('file',\n\t\t\t\t  help='Specifies the file to read results from.',\n\t\t\t\t  type=str, nargs='?', metavar='input_file')\n\n\tcli_args = parser.parse_args(massage_argv(argv))\n\n\tif get_kernel_root_path():\n\t\tos.chdir(get_kernel_root_path())\n\n\tsubcomand_handler = subcommand_handlers_map.get(cli_args.subcommand, None)\n\n\tif subcomand_handler is None:\n\t\tparser.print_help()\n\t\treturn\n\n\tsubcomand_handler(cli_args)\n\n\nif __name__ == '__main__':\n\tmain(sys.argv[1:])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}