{
  "module_name": "kunit_config.py",
  "hash_id": "853bcd4fe51c29e57c15707800bd801ca0092f31af7e4c8c1c35b5eaa0c23c53",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/kunit_config.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Builds a .config from a kunitconfig.\n#\n# Copyright (C) 2019, Google LLC.\n# Author: Felix Guo <felixguoxiuping@gmail.com>\n# Author: Brendan Higgins <brendanhiggins@google.com>\n\nfrom dataclasses import dataclass\nimport re\nfrom typing import Any, Dict, Iterable, List, Tuple\n\nCONFIG_IS_NOT_SET_PATTERN = r'^# CONFIG_(\\w+) is not set$'\nCONFIG_PATTERN = r'^CONFIG_(\\w+)=(\\S+|\".*\")$'\n\n@dataclass(frozen=True)\nclass KconfigEntry:\n\tname: str\n\tvalue: str\n\n\tdef __str__(self) -> str:\n\t\tif self.value == 'n':\n\t\t\treturn f'# CONFIG_{self.name} is not set'\n\t\treturn f'CONFIG_{self.name}={self.value}'\n\n\nclass KconfigParseError(Exception):\n\t\"\"\"Error parsing Kconfig defconfig or .config.\"\"\"\n\n\nclass Kconfig:\n\t\"\"\"Represents defconfig or .config specified using the Kconfig language.\"\"\"\n\n\tdef __init__(self) -> None:\n\t\tself._entries = {}  # type: Dict[str, str]\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\tif not isinstance(other, self.__class__):\n\t\t\treturn False\n\t\treturn self._entries == other._entries\n\n\tdef __repr__(self) -> str:\n\t\treturn ','.join(str(e) for e in self.as_entries())\n\n\tdef as_entries(self) -> Iterable[KconfigEntry]:\n\t\tfor name, value in self._entries.items():\n\t\t\tyield KconfigEntry(name, value)\n\n\tdef add_entry(self, name: str, value: str) -> None:\n\t\tself._entries[name] = value\n\n\tdef is_subset_of(self, other: 'Kconfig') -> bool:\n\t\tfor name, value in self._entries.items():\n\t\t\tb = other._entries.get(name)\n\t\t\tif b is None:\n\t\t\t\tif value == 'n':\n\t\t\t\t\tcontinue\n\t\t\t\treturn False\n\t\t\tif value != b:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef conflicting_options(self, other: 'Kconfig') -> List[Tuple[KconfigEntry, KconfigEntry]]:\n\t\tdiff = []  # type: List[Tuple[KconfigEntry, KconfigEntry]]\n\t\tfor name, value in self._entries.items():\n\t\t\tb = other._entries.get(name)\n\t\t\tif b and value != b:\n\t\t\t\tpair = (KconfigEntry(name, value), KconfigEntry(name, b))\n\t\t\t\tdiff.append(pair)\n\t\treturn diff\n\n\tdef merge_in_entries(self, other: 'Kconfig') -> None:\n\t\tfor name, value in other._entries.items():\n\t\t\tself._entries[name] = value\n\n\tdef write_to_file(self, path: str) -> None:\n\t\twith open(path, 'a+') as f:\n\t\t\tfor e in self.as_entries():\n\t\t\t\tf.write(str(e) + '\\n')\n\ndef parse_file(path: str) -> Kconfig:\n\twith open(path, 'r') as f:\n\t\treturn parse_from_string(f.read())\n\ndef parse_from_string(blob: str) -> Kconfig:\n\t\"\"\"Parses a string containing Kconfig entries.\"\"\"\n\tkconfig = Kconfig()\n\tis_not_set_matcher = re.compile(CONFIG_IS_NOT_SET_PATTERN)\n\tconfig_matcher = re.compile(CONFIG_PATTERN)\n\tfor line in blob.split('\\n'):\n\t\tline = line.strip()\n\t\tif not line:\n\t\t\tcontinue\n\n\t\tmatch = config_matcher.match(line)\n\t\tif match:\n\t\t\tkconfig.add_entry(match.group(1), match.group(2))\n\t\t\tcontinue\n\n\t\tempty_match = is_not_set_matcher.match(line)\n\t\tif empty_match:\n\t\t\tkconfig.add_entry(empty_match.group(1), 'n')\n\t\t\tcontinue\n\n\t\tif line[0] == '#':\n\t\t\tcontinue\n\t\traise KconfigParseError('Failed to parse: ' + line)\n\treturn kconfig\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}