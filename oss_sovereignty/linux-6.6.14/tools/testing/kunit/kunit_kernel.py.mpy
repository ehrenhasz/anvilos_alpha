{
  "module_name": "kunit_kernel.py",
  "hash_id": "a28a60c43d189a6dc64c917b95f16c143fb3739961cf11faa4cdf3a62ec5a900",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/kunit/kunit_kernel.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Runs UML kernel, collects output, and handles errors.\n#\n# Copyright (C) 2019, Google LLC.\n# Author: Felix Guo <felixguoxiuping@gmail.com>\n# Author: Brendan Higgins <brendanhiggins@google.com>\n\nimport importlib.abc\nimport importlib.util\nimport logging\nimport subprocess\nimport os\nimport shlex\nimport shutil\nimport signal\nimport threading\nfrom typing import Iterator, List, Optional, Tuple\nfrom types import FrameType\n\nimport kunit_config\nimport qemu_config\n\nKCONFIG_PATH = '.config'\nKUNITCONFIG_PATH = '.kunitconfig'\nOLD_KUNITCONFIG_PATH = 'last_used_kunitconfig'\nDEFAULT_KUNITCONFIG_PATH = 'tools/testing/kunit/configs/default.config'\nALL_TESTS_CONFIG_PATH = 'tools/testing/kunit/configs/all_tests.config'\nUML_KCONFIG_PATH = 'tools/testing/kunit/configs/arch_uml.config'\nOUTFILE_PATH = 'test.log'\nABS_TOOL_PATH = os.path.abspath(os.path.dirname(__file__))\nQEMU_CONFIGS_DIR = os.path.join(ABS_TOOL_PATH, 'qemu_configs')\n\nclass ConfigError(Exception):\n\t\"\"\"Represents an error trying to configure the Linux kernel.\"\"\"\n\n\nclass BuildError(Exception):\n\t\"\"\"Represents an error trying to build the Linux kernel.\"\"\"\n\n\nclass LinuxSourceTreeOperations:\n\t\"\"\"An abstraction over command line operations performed on a source tree.\"\"\"\n\n\tdef __init__(self, linux_arch: str, cross_compile: Optional[str]):\n\t\tself._linux_arch = linux_arch\n\t\tself._cross_compile = cross_compile\n\n\tdef make_mrproper(self) -> None:\n\t\ttry:\n\t\t\tsubprocess.check_output(['make', 'mrproper'], stderr=subprocess.STDOUT)\n\t\texcept OSError as e:\n\t\t\traise ConfigError('Could not call make command: ' + str(e))\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\traise ConfigError(e.output.decode())\n\n\tdef make_arch_config(self, base_kunitconfig: kunit_config.Kconfig) -> kunit_config.Kconfig:\n\t\treturn base_kunitconfig\n\n\tdef make_olddefconfig(self, build_dir: str, make_options: Optional[List[str]]) -> None:\n\t\tcommand = ['make', 'ARCH=' + self._linux_arch, 'O=' + build_dir, 'olddefconfig']\n\t\tif self._cross_compile:\n\t\t\tcommand += ['CROSS_COMPILE=' + self._cross_compile]\n\t\tif make_options:\n\t\t\tcommand.extend(make_options)\n\t\tprint('Populating config with:\\n$', ' '.join(command))\n\t\ttry:\n\t\t\tsubprocess.check_output(command, stderr=subprocess.STDOUT)\n\t\texcept OSError as e:\n\t\t\traise ConfigError('Could not call make command: ' + str(e))\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\traise ConfigError(e.output.decode())\n\n\tdef make(self, jobs: int, build_dir: str, make_options: Optional[List[str]]) -> None:\n\t\tcommand = ['make', 'ARCH=' + self._linux_arch, 'O=' + build_dir, '--jobs=' + str(jobs)]\n\t\tif make_options:\n\t\t\tcommand.extend(make_options)\n\t\tif self._cross_compile:\n\t\t\tcommand += ['CROSS_COMPILE=' + self._cross_compile]\n\t\tprint('Building with:\\n$', ' '.join(command))\n\t\ttry:\n\t\t\tproc = subprocess.Popen(command,\n\t\t\t\t\t\tstderr=subprocess.PIPE,\n\t\t\t\t\t\tstdout=subprocess.DEVNULL)\n\t\texcept OSError as e:\n\t\t\traise BuildError('Could not call execute make: ' + str(e))\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\traise BuildError(e.output)\n\t\t_, stderr = proc.communicate()\n\t\tif proc.returncode != 0:\n\t\t\traise BuildError(stderr.decode())\n\t\tif stderr:  # likely only due to build warnings\n\t\t\tprint(stderr.decode())\n\n\tdef start(self, params: List[str], build_dir: str) -> subprocess.Popen:\n\t\traise RuntimeError('not implemented!')\n\n\nclass LinuxSourceTreeOperationsQemu(LinuxSourceTreeOperations):\n\n\tdef __init__(self, qemu_arch_params: qemu_config.QemuArchParams, cross_compile: Optional[str]):\n\t\tsuper().__init__(linux_arch=qemu_arch_params.linux_arch,\n\t\t\t\t cross_compile=cross_compile)\n\t\tself._kconfig = qemu_arch_params.kconfig\n\t\tself._qemu_arch = qemu_arch_params.qemu_arch\n\t\tself._kernel_path = qemu_arch_params.kernel_path\n\t\tself._kernel_command_line = qemu_arch_params.kernel_command_line + ' kunit_shutdown=reboot'\n\t\tself._extra_qemu_params = qemu_arch_params.extra_qemu_params\n\t\tself._serial = qemu_arch_params.serial\n\n\tdef make_arch_config(self, base_kunitconfig: kunit_config.Kconfig) -> kunit_config.Kconfig:\n\t\tkconfig = kunit_config.parse_from_string(self._kconfig)\n\t\tkconfig.merge_in_entries(base_kunitconfig)\n\t\treturn kconfig\n\n\tdef start(self, params: List[str], build_dir: str) -> subprocess.Popen:\n\t\tkernel_path = os.path.join(build_dir, self._kernel_path)\n\t\tqemu_command = ['qemu-system-' + self._qemu_arch,\n\t\t\t\t'-nodefaults',\n\t\t\t\t'-m', '1024',\n\t\t\t\t'-kernel', kernel_path,\n\t\t\t\t'-append', ' '.join(params + [self._kernel_command_line]),\n\t\t\t\t'-no-reboot',\n\t\t\t\t'-nographic',\n\t\t\t\t'-serial', self._serial] + self._extra_qemu_params\n\t\t# Note: shlex.join() does what we want, but requires python 3.8+.\n\t\tprint('Running tests with:\\n$', ' '.join(shlex.quote(arg) for arg in qemu_command))\n\t\treturn subprocess.Popen(qemu_command,\n\t\t\t\t\tstdin=subprocess.PIPE,\n\t\t\t\t\tstdout=subprocess.PIPE,\n\t\t\t\t\tstderr=subprocess.STDOUT,\n\t\t\t\t\ttext=True, errors='backslashreplace')\n\nclass LinuxSourceTreeOperationsUml(LinuxSourceTreeOperations):\n\t\"\"\"An abstraction over command line operations performed on a source tree.\"\"\"\n\n\tdef __init__(self, cross_compile: Optional[str]=None):\n\t\tsuper().__init__(linux_arch='um', cross_compile=cross_compile)\n\n\tdef make_arch_config(self, base_kunitconfig: kunit_config.Kconfig) -> kunit_config.Kconfig:\n\t\tkconfig = kunit_config.parse_file(UML_KCONFIG_PATH)\n\t\tkconfig.merge_in_entries(base_kunitconfig)\n\t\treturn kconfig\n\n\tdef start(self, params: List[str], build_dir: str) -> subprocess.Popen:\n\t\t\"\"\"Runs the Linux UML binary. Must be named 'linux'.\"\"\"\n\t\tlinux_bin = os.path.join(build_dir, 'linux')\n\t\tparams.extend(['mem=1G', 'console=tty', 'kunit_shutdown=halt'])\n\t\treturn subprocess.Popen([linux_bin] + params,\n\t\t\t\t\t   stdin=subprocess.PIPE,\n\t\t\t\t\t   stdout=subprocess.PIPE,\n\t\t\t\t\t   stderr=subprocess.STDOUT,\n\t\t\t\t\t   text=True, errors='backslashreplace')\n\ndef get_kconfig_path(build_dir: str) -> str:\n\treturn os.path.join(build_dir, KCONFIG_PATH)\n\ndef get_kunitconfig_path(build_dir: str) -> str:\n\treturn os.path.join(build_dir, KUNITCONFIG_PATH)\n\ndef get_old_kunitconfig_path(build_dir: str) -> str:\n\treturn os.path.join(build_dir, OLD_KUNITCONFIG_PATH)\n\ndef get_parsed_kunitconfig(build_dir: str,\n\t\t\t   kunitconfig_paths: Optional[List[str]]=None) -> kunit_config.Kconfig:\n\tif not kunitconfig_paths:\n\t\tpath = get_kunitconfig_path(build_dir)\n\t\tif not os.path.exists(path):\n\t\t\tshutil.copyfile(DEFAULT_KUNITCONFIG_PATH, path)\n\t\treturn kunit_config.parse_file(path)\n\n\tmerged = kunit_config.Kconfig()\n\n\tfor path in kunitconfig_paths:\n\t\tif os.path.isdir(path):\n\t\t\tpath = os.path.join(path, KUNITCONFIG_PATH)\n\t\tif not os.path.exists(path):\n\t\t\traise ConfigError(f'Specified kunitconfig ({path}) does not exist')\n\n\t\tpartial = kunit_config.parse_file(path)\n\t\tdiff = merged.conflicting_options(partial)\n\t\tif diff:\n\t\t\tdiff_str = '\\n\\n'.join(f'{a}\\n  vs from {path}\\n{b}' for a, b in diff)\n\t\t\traise ConfigError(f'Multiple values specified for {len(diff)} options in kunitconfig:\\n{diff_str}')\n\t\tmerged.merge_in_entries(partial)\n\treturn merged\n\ndef get_outfile_path(build_dir: str) -> str:\n\treturn os.path.join(build_dir, OUTFILE_PATH)\n\ndef _default_qemu_config_path(arch: str) -> str:\n\tconfig_path = os.path.join(QEMU_CONFIGS_DIR, arch + '.py')\n\tif os.path.isfile(config_path):\n\t\treturn config_path\n\n\toptions = [f[:-3] for f in os.listdir(QEMU_CONFIGS_DIR) if f.endswith('.py')]\n\traise ConfigError(arch + ' is not a valid arch, options are ' + str(sorted(options)))\n\ndef _get_qemu_ops(config_path: str,\n\t\t  extra_qemu_args: Optional[List[str]],\n\t\t  cross_compile: Optional[str]) -> Tuple[str, LinuxSourceTreeOperations]:\n\t# The module name/path has very little to do with where the actual file\n\t# exists (I learned this through experimentation and could not find it\n\t# anywhere in the Python documentation).\n\t#\n\t# Bascially, we completely ignore the actual file location of the config\n\t# we are loading and just tell Python that the module lives in the\n\t# QEMU_CONFIGS_DIR for import purposes regardless of where it actually\n\t# exists as a file.\n\tmodule_path = '.' + os.path.join(os.path.basename(QEMU_CONFIGS_DIR), os.path.basename(config_path))\n\tspec = importlib.util.spec_from_file_location(module_path, config_path)\n\tassert spec is not None\n\tconfig = importlib.util.module_from_spec(spec)\n\t# See https://github.com/python/typeshed/pull/2626 for context.\n\tassert isinstance(spec.loader, importlib.abc.Loader)\n\tspec.loader.exec_module(config)\n\n\tif not hasattr(config, 'QEMU_ARCH'):\n\t\traise ValueError('qemu_config module missing \"QEMU_ARCH\": ' + config_path)\n\tparams: qemu_config.QemuArchParams = config.QEMU_ARCH\n\tif extra_qemu_args:\n\t\tparams.extra_qemu_params.extend(extra_qemu_args)\n\treturn params.linux_arch, LinuxSourceTreeOperationsQemu(\n\t\t\tparams, cross_compile=cross_compile)\n\nclass LinuxSourceTree:\n\t\"\"\"Represents a Linux kernel source tree with KUnit tests.\"\"\"\n\n\tdef __init__(\n\t      self,\n\t      build_dir: str,\n\t      kunitconfig_paths: Optional[List[str]]=None,\n\t      kconfig_add: Optional[List[str]]=None,\n\t      arch: Optional[str]=None,\n\t      cross_compile: Optional[str]=None,\n\t      qemu_config_path: Optional[str]=None,\n\t      extra_qemu_args: Optional[List[str]]=None) -> None:\n\t\tsignal.signal(signal.SIGINT, self.signal_handler)\n\t\tif qemu_config_path:\n\t\t\tself._arch, self._ops = _get_qemu_ops(qemu_config_path, extra_qemu_args, cross_compile)\n\t\telse:\n\t\t\tself._arch = 'um' if arch is None else arch\n\t\t\tif self._arch == 'um':\n\t\t\t\tself._ops = LinuxSourceTreeOperationsUml(cross_compile=cross_compile)\n\t\t\telse:\n\t\t\t\tqemu_config_path = _default_qemu_config_path(self._arch)\n\t\t\t\t_, self._ops = _get_qemu_ops(qemu_config_path, extra_qemu_args, cross_compile)\n\n\t\tself._kconfig = get_parsed_kunitconfig(build_dir, kunitconfig_paths)\n\t\tif kconfig_add:\n\t\t\tkconfig = kunit_config.parse_from_string('\\n'.join(kconfig_add))\n\t\t\tself._kconfig.merge_in_entries(kconfig)\n\n\tdef arch(self) -> str:\n\t\treturn self._arch\n\n\tdef clean(self) -> bool:\n\t\ttry:\n\t\t\tself._ops.make_mrproper()\n\t\texcept ConfigError as e:\n\t\t\tlogging.error(e)\n\t\t\treturn False\n\t\treturn True\n\n\tdef validate_config(self, build_dir: str) -> bool:\n\t\tkconfig_path = get_kconfig_path(build_dir)\n\t\tvalidated_kconfig = kunit_config.parse_file(kconfig_path)\n\t\tif self._kconfig.is_subset_of(validated_kconfig):\n\t\t\treturn True\n\t\tmissing = set(self._kconfig.as_entries()) - set(validated_kconfig.as_entries())\n\t\tmessage = 'Not all Kconfig options selected in kunitconfig were in the generated .config.\\n' \\\n\t\t\t  'This is probably due to unsatisfied dependencies.\\n' \\\n\t\t\t  'Missing: ' + ', '.join(str(e) for e in missing)\n\t\tif self._arch == 'um':\n\t\t\tmessage += '\\nNote: many Kconfig options aren\\'t available on UML. You can try running ' \\\n\t\t\t\t   'on a different architecture with something like \"--arch=x86_64\".'\n\t\tlogging.error(message)\n\t\treturn False\n\n\tdef build_config(self, build_dir: str, make_options: Optional[List[str]]) -> bool:\n\t\tkconfig_path = get_kconfig_path(build_dir)\n\t\tif build_dir and not os.path.exists(build_dir):\n\t\t\tos.mkdir(build_dir)\n\t\ttry:\n\t\t\tself._kconfig = self._ops.make_arch_config(self._kconfig)\n\t\t\tself._kconfig.write_to_file(kconfig_path)\n\t\t\tself._ops.make_olddefconfig(build_dir, make_options)\n\t\texcept ConfigError as e:\n\t\t\tlogging.error(e)\n\t\t\treturn False\n\t\tif not self.validate_config(build_dir):\n\t\t\treturn False\n\n\t\told_path = get_old_kunitconfig_path(build_dir)\n\t\tif os.path.exists(old_path):\n\t\t\tos.remove(old_path)  # write_to_file appends to the file\n\t\tself._kconfig.write_to_file(old_path)\n\t\treturn True\n\n\tdef _kunitconfig_changed(self, build_dir: str) -> bool:\n\t\told_path = get_old_kunitconfig_path(build_dir)\n\t\tif not os.path.exists(old_path):\n\t\t\treturn True\n\n\t\told_kconfig = kunit_config.parse_file(old_path)\n\t\treturn old_kconfig != self._kconfig\n\n\tdef build_reconfig(self, build_dir: str, make_options: Optional[List[str]]) -> bool:\n\t\t\"\"\"Creates a new .config if it is not a subset of the .kunitconfig.\"\"\"\n\t\tkconfig_path = get_kconfig_path(build_dir)\n\t\tif not os.path.exists(kconfig_path):\n\t\t\tprint('Generating .config ...')\n\t\t\treturn self.build_config(build_dir, make_options)\n\n\t\texisting_kconfig = kunit_config.parse_file(kconfig_path)\n\t\tself._kconfig = self._ops.make_arch_config(self._kconfig)\n\n\t\tif self._kconfig.is_subset_of(existing_kconfig) and not self._kunitconfig_changed(build_dir):\n\t\t\treturn True\n\t\tprint('Regenerating .config ...')\n\t\tos.remove(kconfig_path)\n\t\treturn self.build_config(build_dir, make_options)\n\n\tdef build_kernel(self, jobs: int, build_dir: str, make_options: Optional[List[str]]) -> bool:\n\t\ttry:\n\t\t\tself._ops.make_olddefconfig(build_dir, make_options)\n\t\t\tself._ops.make(jobs, build_dir, make_options)\n\t\texcept (ConfigError, BuildError) as e:\n\t\t\tlogging.error(e)\n\t\t\treturn False\n\t\treturn self.validate_config(build_dir)\n\n\tdef run_kernel(self, args: Optional[List[str]]=None, build_dir: str='', filter_glob: str='', filter: str='', filter_action: Optional[str]=None, timeout: Optional[int]=None) -> Iterator[str]:\n\t\tif not args:\n\t\t\targs = []\n\t\tif filter_glob:\n\t\t\targs.append('kunit.filter_glob=' + filter_glob)\n\t\tif filter:\n\t\t\targs.append('kunit.filter=\"' + filter + '\"')\n\t\tif filter_action:\n\t\t\targs.append('kunit.filter_action=' + filter_action)\n\t\targs.append('kunit.enable=1')\n\n\t\tprocess = self._ops.start(args, build_dir)\n\t\tassert process.stdout is not None  # tell mypy it's set\n\n\t\t# Enforce the timeout in a background thread.\n\t\tdef _wait_proc() -> None:\n\t\t\ttry:\n\t\t\t\tprocess.wait(timeout=timeout)\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\t\t\tprocess.terminate()\n\t\t\t\tprocess.wait()\n\t\twaiter = threading.Thread(target=_wait_proc)\n\t\twaiter.start()\n\n\t\toutput = open(get_outfile_path(build_dir), 'w')\n\t\ttry:\n\t\t\t# Tee the output to the file and to our caller in real time.\n\t\t\tfor line in process.stdout:\n\t\t\t\toutput.write(line)\n\t\t\t\tyield line\n\t\t# This runs even if our caller doesn't consume every line.\n\t\tfinally:\n\t\t\t# Flush any leftover output to the file\n\t\t\toutput.write(process.stdout.read())\n\t\t\toutput.close()\n\t\t\tprocess.stdout.close()\n\n\t\t\twaiter.join()\n\t\t\tsubprocess.call(['stty', 'sane'])\n\n\tdef signal_handler(self, unused_sig: int, unused_frame: Optional[FrameType]) -> None:\n\t\tlogging.error('Build interruption occurred. Cleaning console.')\n\t\tsubprocess.call(['stty', 'sane'])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}