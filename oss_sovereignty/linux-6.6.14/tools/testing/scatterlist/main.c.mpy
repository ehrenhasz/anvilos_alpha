{
  "module_name": "main.c",
  "hash_id": "4f7a4aa1eacdaffbac5a1f74d3655e5e4518fc23a2ed5828d589f8352ad8752f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/scatterlist/main.c",
  "human_readable_source": "#include <stdio.h>\n#include <assert.h>\n\n#include <linux/scatterlist.h>\n\n#define MAX_PAGES (64)\n\nstruct test {\n\tint alloc_ret;\n\tunsigned num_pages;\n\tunsigned *pfn;\n\tunsigned *pfn_app;\n\tunsigned size;\n\tunsigned int max_seg;\n\tunsigned int expected_segments;\n};\n\nstatic void set_pages(struct page **pages, const unsigned *array, unsigned num)\n{\n\tunsigned int i;\n\n\tassert(num < MAX_PAGES);\n\tfor (i = 0; i < num; i++)\n\t\tpages[i] = (struct page *)(unsigned long)\n\t\t\t   ((1 + array[i]) * PAGE_SIZE);\n}\n\n#define pfn(...) (unsigned []){ __VA_ARGS__ }\n\nstatic void fail(struct test *test, struct sg_table *st, const char *cond)\n{\n\tunsigned int i;\n\n\tfprintf(stderr, \"Failed on '%s'!\\n\\n\", cond);\n\n\tprintf(\"size = %u, max segment = %u, expected nents = %u\\nst->nents = %u, st->orig_nents= %u\\n\",\n\t       test->size, test->max_seg, test->expected_segments, st->nents,\n\t       st->orig_nents);\n\n\tprintf(\"%u input PFNs:\", test->num_pages);\n\tfor (i = 0; i < test->num_pages; i++)\n\t\tprintf(\" %x\", test->pfn[i]);\n\tprintf(\"\\n\");\n\n\texit(1);\n}\n\n#define VALIDATE(cond, st, test) \\\n\tif (!(cond)) \\\n\t\tfail((test), (st), #cond);\n\nint main(void)\n{\n\tconst unsigned int sgmax = UINT_MAX;\n\tstruct test *test, tests[] = {\n\t\t{ -EINVAL, 1, pfn(0), NULL, PAGE_SIZE, 0, 1 },\n\t\t{ 0, 1, pfn(0), NULL, PAGE_SIZE, PAGE_SIZE + 1, 1 },\n\t\t{ 0, 1, pfn(0), NULL, PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 1, pfn(0), NULL, 1, sgmax, 1 },\n\t\t{ 0, 2, pfn(0, 1), NULL, 2 * PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 2, pfn(1, 0), NULL, 2 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 3, pfn(0, 1, 2), NULL, 3 * PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 3, pfn(0, 1, 2), NULL, 3 * PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 3, pfn(0, 1, 2), pfn(3, 4, 5), 3 * PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 3, pfn(0, 1, 2), pfn(4, 5, 6), 3 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 3, pfn(0, 2, 1), NULL, 3 * PAGE_SIZE, sgmax, 3 },\n\t\t{ 0, 3, pfn(0, 1, 3), NULL, 3 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 3, pfn(1, 2, 4), NULL, 3 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 3, pfn(1, 3, 4), NULL, 3 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 4, pfn(0, 1, 3, 4), NULL, 4 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 5, pfn(0, 1, 3, 4, 5), NULL, 5 * PAGE_SIZE, sgmax, 2 },\n\t\t{ 0, 5, pfn(0, 1, 3, 4, 6), NULL, 5 * PAGE_SIZE, sgmax, 3 },\n\t\t{ 0, 5, pfn(0, 1, 2, 3, 4), NULL, 5 * PAGE_SIZE, sgmax, 1 },\n\t\t{ 0, 5, pfn(0, 1, 2, 3, 4), NULL, 5 * PAGE_SIZE, 2 * PAGE_SIZE,\n\t\t  3 },\n\t\t{ 0, 6, pfn(0, 1, 2, 3, 4, 5), NULL, 6 * PAGE_SIZE,\n\t\t  2 * PAGE_SIZE, 3 },\n\t\t{ 0, 6, pfn(0, 2, 3, 4, 5, 6), NULL, 6 * PAGE_SIZE,\n\t\t  2 * PAGE_SIZE, 4 },\n\t\t{ 0, 6, pfn(0, 1, 3, 4, 5, 6), pfn(7, 8, 9, 10, 11, 12),\n\t\t  6 * PAGE_SIZE, 12 * PAGE_SIZE, 2 },\n\t\t{ 0, 0, NULL, NULL, 0, 0, 0 },\n\t};\n\tunsigned int i;\n\n\tfor (i = 0, test = tests; test->expected_segments; test++, i++) {\n\t\tint left_pages = test->pfn_app ? test->num_pages : 0;\n\t\tstruct sg_append_table append = {};\n\t\tstruct page *pages[MAX_PAGES];\n\t\tint ret;\n\n\t\tset_pages(pages, test->pfn, test->num_pages);\n\n\t\tif (test->pfn_app)\n\t\t\tret = sg_alloc_append_table_from_pages(\n\t\t\t\t&append, pages, test->num_pages, 0, test->size,\n\t\t\t\ttest->max_seg, left_pages, GFP_KERNEL);\n\t\telse\n\t\t\tret = sg_alloc_table_from_pages_segment(\n\t\t\t\t&append.sgt, pages, test->num_pages, 0,\n\t\t\t\ttest->size, test->max_seg, GFP_KERNEL);\n\n\t\tassert(ret == test->alloc_ret);\n\n\t\tif (test->alloc_ret)\n\t\t\tcontinue;\n\n\t\tif (test->pfn_app) {\n\t\t\tset_pages(pages, test->pfn_app, test->num_pages);\n\t\t\tret = sg_alloc_append_table_from_pages(\n\t\t\t\t&append, pages, test->num_pages, 0, test->size,\n\t\t\t\ttest->max_seg, 0, GFP_KERNEL);\n\n\t\t\tassert(ret == test->alloc_ret);\n\t\t}\n\n\t\tVALIDATE(append.sgt.nents == test->expected_segments,\n\t\t\t &append.sgt, test);\n\t\tif (!test->pfn_app)\n\t\t\tVALIDATE(append.sgt.orig_nents ==\n\t\t\t\t\t test->expected_segments,\n\t\t\t\t &append.sgt, test);\n\n\t\tif (test->pfn_app)\n\t\t\tsg_free_append_table(&append);\n\t\telse\n\t\t\tsg_free_table(&append.sgt);\n\t}\n\n\tassert(i == (sizeof(tests) / sizeof(tests[0])) - 1);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}