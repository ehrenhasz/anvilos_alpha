{
  "module_name": "control.c",
  "hash_id": "885de03f27d70a5850d85d0bf92f4ef25be034a1063396cdb2d60e18728bd5b3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/vsock/control.c",
  "human_readable_source": "\n \n\n \n\n#include <errno.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include \"timeout.h\"\n#include \"control.h\"\n\nstatic int control_fd = -1;\n\n \nvoid control_init(const char *control_host,\n\t\t  const char *control_port,\n\t\t  bool server)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_socktype = SOCK_STREAM,\n\t};\n\tstruct addrinfo *result = NULL;\n\tstruct addrinfo *ai;\n\tint ret;\n\n\tret = getaddrinfo(control_host, control_port, &hints, &result);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%s\\n\", gai_strerror(ret));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (ai = result; ai; ai = ai->ai_next) {\n\t\tint fd;\n\t\tint val = 1;\n\n\t\tfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tif (!server) {\n\t\t\tif (connect(fd, ai->ai_addr, ai->ai_addrlen) < 0)\n\t\t\t\tgoto next;\n\t\t\tcontrol_fd = fd;\n\t\t\tprintf(\"Control socket connected to %s:%s.\\n\",\n\t\t\t       control_host, control_port);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t       &val, sizeof(val)) < 0) {\n\t\t\tperror(\"setsockopt\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (bind(fd, ai->ai_addr, ai->ai_addrlen) < 0)\n\t\t\tgoto next;\n\t\tif (listen(fd, 1) < 0)\n\t\t\tgoto next;\n\n\t\tprintf(\"Control socket listening on %s:%s\\n\",\n\t\t       control_host, control_port);\n\t\tfflush(stdout);\n\n\t\tcontrol_fd = accept(fd, NULL, 0);\n\t\tclose(fd);\n\n\t\tif (control_fd < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tprintf(\"Control socket connection accepted...\\n\");\n\t\tbreak;\n\nnext:\n\t\tclose(fd);\n\t}\n\n\tif (control_fd < 0) {\n\t\tfprintf(stderr, \"Control socket initialization failed.  Invalid address %s:%s?\\n\",\n\t\t\tcontrol_host, control_port);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfreeaddrinfo(result);\n}\n\n \nvoid control_cleanup(void)\n{\n\tclose(control_fd);\n\tcontrol_fd = -1;\n}\n\n \nvoid control_writeln(const char *str)\n{\n\tssize_t len = strlen(str);\n\tssize_t ret;\n\n\ttimeout_begin(TIMEOUT);\n\n\tdo {\n\t\tret = send(control_fd, str, len, MSG_MORE);\n\t\ttimeout_check(\"send\");\n\t} while (ret < 0 && errno == EINTR);\n\n\tif (ret != len) {\n\t\tperror(\"send\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tdo {\n\t\tret = send(control_fd, \"\\n\", 1, 0);\n\t\ttimeout_check(\"send\");\n\t} while (ret < 0 && errno == EINTR);\n\n\tif (ret != 1) {\n\t\tperror(\"send\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\ttimeout_end();\n}\n\nvoid control_writeulong(unsigned long value)\n{\n\tchar str[32];\n\n\tif (snprintf(str, sizeof(str), \"%lu\", value) >= sizeof(str)) {\n\t\tperror(\"snprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(str);\n}\n\nunsigned long control_readulong(void)\n{\n\tunsigned long value;\n\tchar *str;\n\n\tstr = control_readln();\n\n\tif (!str)\n\t\texit(EXIT_FAILURE);\n\n\tvalue = strtoul(str, NULL, 10);\n\tfree(str);\n\n\treturn value;\n}\n\n \nchar *control_readln(void)\n{\n\tchar *buf = NULL;\n\tsize_t idx = 0;\n\tsize_t buflen = 0;\n\n\ttimeout_begin(TIMEOUT);\n\n\tfor (;;) {\n\t\tssize_t ret;\n\n\t\tif (idx >= buflen) {\n\t\t\tchar *new_buf;\n\n\t\t\tnew_buf = realloc(buf, buflen + 80);\n\t\t\tif (!new_buf) {\n\t\t\t\tperror(\"realloc\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tbuf = new_buf;\n\t\t\tbuflen += 80;\n\t\t}\n\n\t\tdo {\n\t\t\tret = recv(control_fd, &buf[idx], 1, 0);\n\t\t\ttimeout_check(\"recv\");\n\t\t} while (ret < 0 && errno == EINTR);\n\n\t\tif (ret == 0) {\n\t\t\tfprintf(stderr, \"unexpected EOF on control socket\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (ret != 1) {\n\t\t\tperror(\"recv\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (buf[idx] == '\\n') {\n\t\t\tbuf[idx] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\ttimeout_end();\n\n\treturn buf;\n}\n\n \nvoid control_expectln(const char *str)\n{\n\tchar *line;\n\n\tline = control_readln();\n\n\tcontrol_cmpln(line, str, true);\n\n\tfree(line);\n}\n\nbool control_cmpln(char *line, const char *str, bool fail)\n{\n\tif (strcmp(str, line) == 0)\n\t\treturn true;\n\n\tif (fail) {\n\t\tfprintf(stderr, \"expected \\\"%s\\\" on control socket, got \\\"%s\\\"\\n\",\n\t\t\tstr, line);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}