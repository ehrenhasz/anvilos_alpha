{
  "module_name": "vsock_diag_test.c",
  "hash_id": "863bb73d9b9e3af83ea1f1fe8c983424e6f96eb0e17a1e8eaf4a23901a08f394",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/vsock/vsock_diag_test.c",
  "human_readable_source": "\n \n\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/list.h>\n#include <linux/net.h>\n#include <linux/netlink.h>\n#include <linux/sock_diag.h>\n#include <linux/vm_sockets_diag.h>\n#include <netinet/tcp.h>\n\n#include \"timeout.h\"\n#include \"control.h\"\n#include \"util.h\"\n\n \nstruct vsock_stat {\n\tstruct list_head list;\n\tstruct vsock_diag_msg msg;\n};\n\nstatic const char *sock_type_str(int type)\n{\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\t\treturn \"DGRAM\";\n\tcase SOCK_STREAM:\n\t\treturn \"STREAM\";\n\tdefault:\n\t\treturn \"INVALID TYPE\";\n\t}\n}\n\nstatic const char *sock_state_str(int state)\n{\n\tswitch (state) {\n\tcase TCP_CLOSE:\n\t\treturn \"UNCONNECTED\";\n\tcase TCP_SYN_SENT:\n\t\treturn \"CONNECTING\";\n\tcase TCP_ESTABLISHED:\n\t\treturn \"CONNECTED\";\n\tcase TCP_CLOSING:\n\t\treturn \"DISCONNECTING\";\n\tcase TCP_LISTEN:\n\t\treturn \"LISTEN\";\n\tdefault:\n\t\treturn \"INVALID STATE\";\n\t}\n}\n\nstatic const char *sock_shutdown_str(int shutdown)\n{\n\tswitch (shutdown) {\n\tcase 1:\n\t\treturn \"RCV_SHUTDOWN\";\n\tcase 2:\n\t\treturn \"SEND_SHUTDOWN\";\n\tcase 3:\n\t\treturn \"RCV_SHUTDOWN | SEND_SHUTDOWN\";\n\tdefault:\n\t\treturn \"0\";\n\t}\n}\n\nstatic void print_vsock_addr(FILE *fp, unsigned int cid, unsigned int port)\n{\n\tif (cid == VMADDR_CID_ANY)\n\t\tfprintf(fp, \"*:\");\n\telse\n\t\tfprintf(fp, \"%u:\", cid);\n\n\tif (port == VMADDR_PORT_ANY)\n\t\tfprintf(fp, \"*\");\n\telse\n\t\tfprintf(fp, \"%u\", port);\n}\n\nstatic void print_vsock_stat(FILE *fp, struct vsock_stat *st)\n{\n\tprint_vsock_addr(fp, st->msg.vdiag_src_cid, st->msg.vdiag_src_port);\n\tfprintf(fp, \" \");\n\tprint_vsock_addr(fp, st->msg.vdiag_dst_cid, st->msg.vdiag_dst_port);\n\tfprintf(fp, \" %s %s %s %u\\n\",\n\t\tsock_type_str(st->msg.vdiag_type),\n\t\tsock_state_str(st->msg.vdiag_state),\n\t\tsock_shutdown_str(st->msg.vdiag_shutdown),\n\t\tst->msg.vdiag_ino);\n}\n\nstatic void print_vsock_stats(FILE *fp, struct list_head *head)\n{\n\tstruct vsock_stat *st;\n\n\tlist_for_each_entry(st, head, list)\n\t\tprint_vsock_stat(fp, st);\n}\n\nstatic struct vsock_stat *find_vsock_stat(struct list_head *head, int fd)\n{\n\tstruct vsock_stat *st;\n\tstruct stat stat;\n\n\tif (fstat(fd, &stat) < 0) {\n\t\tperror(\"fstat\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlist_for_each_entry(st, head, list)\n\t\tif (st->msg.vdiag_ino == stat.st_ino)\n\t\t\treturn st;\n\n\tfprintf(stderr, \"cannot find fd %d\\n\", fd);\n\texit(EXIT_FAILURE);\n}\n\nstatic void check_no_sockets(struct list_head *head)\n{\n\tif (!list_empty(head)) {\n\t\tfprintf(stderr, \"expected no sockets\\n\");\n\t\tprint_vsock_stats(stderr, head);\n\t\texit(1);\n\t}\n}\n\nstatic void check_num_sockets(struct list_head *head, int expected)\n{\n\tstruct list_head *node;\n\tint n = 0;\n\n\tlist_for_each(node, head)\n\t\tn++;\n\n\tif (n != expected) {\n\t\tfprintf(stderr, \"expected %d sockets, found %d\\n\",\n\t\t\texpected, n);\n\t\tprint_vsock_stats(stderr, head);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void check_socket_state(struct vsock_stat *st, __u8 state)\n{\n\tif (st->msg.vdiag_state != state) {\n\t\tfprintf(stderr, \"expected socket state %#x, got %#x\\n\",\n\t\t\tstate, st->msg.vdiag_state);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void send_req(int fd)\n{\n\tstruct sockaddr_nl nladdr = {\n\t\t.nl_family = AF_NETLINK,\n\t};\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct vsock_diag_req vreq;\n\t} req = {\n\t\t.nlh = {\n\t\t\t.nlmsg_len = sizeof(req),\n\t\t\t.nlmsg_type = SOCK_DIAG_BY_FAMILY,\n\t\t\t.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP,\n\t\t},\n\t\t.vreq = {\n\t\t\t.sdiag_family = AF_VSOCK,\n\t\t\t.vdiag_states = ~(__u32)0,\n\t\t},\n\t};\n\tstruct iovec iov = {\n\t\t.iov_base = &req,\n\t\t.iov_len = sizeof(req),\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\n\tfor (;;) {\n\t\tif (sendmsg(fd, &msg, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tperror(\"sendmsg\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\treturn;\n\t}\n}\n\nstatic ssize_t recv_resp(int fd, void *buf, size_t len)\n{\n\tstruct sockaddr_nl nladdr = {\n\t\t.nl_family = AF_NETLINK,\n\t};\n\tstruct iovec iov = {\n\t\t.iov_base = buf,\n\t\t.iov_len = len,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tssize_t ret;\n\n\tdo {\n\t\tret = recvmsg(fd, &msg, 0);\n\t} while (ret < 0 && errno == EINTR);\n\n\tif (ret < 0) {\n\t\tperror(\"recvmsg\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn ret;\n}\n\nstatic void add_vsock_stat(struct list_head *sockets,\n\t\t\t   const struct vsock_diag_msg *resp)\n{\n\tstruct vsock_stat *st;\n\n\tst = malloc(sizeof(*st));\n\tif (!st) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tst->msg = *resp;\n\tlist_add_tail(&st->list, sockets);\n}\n\n \nstatic void read_vsock_stat(struct list_head *sockets)\n{\n\tlong buf[8192 / sizeof(long)];\n\tint fd;\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n\tif (fd < 0) {\n\t\tperror(\"socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_req(fd);\n\n\tfor (;;) {\n\t\tconst struct nlmsghdr *h;\n\t\tssize_t ret;\n\n\t\tret = recv_resp(fd, buf, sizeof(buf));\n\t\tif (ret == 0)\n\t\t\tgoto done;\n\t\tif (ret < sizeof(*h)) {\n\t\t\tfprintf(stderr, \"short read of %zd bytes\\n\", ret);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\th = (struct nlmsghdr *)buf;\n\n\t\twhile (NLMSG_OK(h, ret)) {\n\t\t\tif (h->nlmsg_type == NLMSG_DONE)\n\t\t\t\tgoto done;\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tconst struct nlmsgerr *err = NLMSG_DATA(h);\n\n\t\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n\t\t\t\t\tfprintf(stderr, \"NLMSG_ERROR\\n\");\n\t\t\t\telse {\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t\tperror(\"NLMSG_ERROR\");\n\t\t\t\t}\n\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n\t\t\t\tfprintf(stderr, \"unexpected nlmsg_type %#x\\n\",\n\t\t\t\t\th->nlmsg_type);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (h->nlmsg_len <\n\t\t\t    NLMSG_LENGTH(sizeof(struct vsock_diag_msg))) {\n\t\t\t\tfprintf(stderr, \"short vsock_diag_msg\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tadd_vsock_stat(sockets, NLMSG_DATA(h));\n\n\t\t\th = NLMSG_NEXT(h, ret);\n\t\t}\n\t}\n\ndone:\n\tclose(fd);\n}\n\nstatic void free_sock_stat(struct list_head *sockets)\n{\n\tstruct vsock_stat *st;\n\tstruct vsock_stat *next;\n\n\tlist_for_each_entry_safe(st, next, sockets, list)\n\t\tfree(st);\n}\n\nstatic void test_no_sockets(const struct test_opts *opts)\n{\n\tLIST_HEAD(sockets);\n\n\tread_vsock_stat(&sockets);\n\n\tcheck_no_sockets(&sockets);\n}\n\nstatic void test_listen_socket_server(const struct test_opts *opts)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = 1234,\n\t\t\t.svm_cid = VMADDR_CID_ANY,\n\t\t},\n\t};\n\tLIST_HEAD(sockets);\n\tstruct vsock_stat *st;\n\tint fd;\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\tif (bind(fd, &addr.sa, sizeof(addr.svm)) < 0) {\n\t\tperror(\"bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (listen(fd, 1) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_vsock_stat(&sockets);\n\n\tcheck_num_sockets(&sockets, 1);\n\tst = find_vsock_stat(&sockets, fd);\n\tcheck_socket_state(st, TCP_LISTEN);\n\n\tclose(fd);\n\tfree_sock_stat(&sockets);\n}\n\nstatic void test_connect_client(const struct test_opts *opts)\n{\n\tint fd;\n\tLIST_HEAD(sockets);\n\tstruct vsock_stat *st;\n\n\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_vsock_stat(&sockets);\n\n\tcheck_num_sockets(&sockets, 1);\n\tst = find_vsock_stat(&sockets, fd);\n\tcheck_socket_state(st, TCP_ESTABLISHED);\n\n\tcontrol_expectln(\"DONE\");\n\tcontrol_writeln(\"DONE\");\n\n\tclose(fd);\n\tfree_sock_stat(&sockets);\n}\n\nstatic void test_connect_server(const struct test_opts *opts)\n{\n\tstruct vsock_stat *st;\n\tLIST_HEAD(sockets);\n\tint client_fd;\n\n\tclient_fd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (client_fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_vsock_stat(&sockets);\n\n\tcheck_num_sockets(&sockets, 1);\n\tst = find_vsock_stat(&sockets, client_fd);\n\tcheck_socket_state(st, TCP_ESTABLISHED);\n\n\tcontrol_writeln(\"DONE\");\n\tcontrol_expectln(\"DONE\");\n\n\tclose(client_fd);\n\tfree_sock_stat(&sockets);\n}\n\nstatic struct test_case test_cases[] = {\n\t{\n\t\t.name = \"No sockets\",\n\t\t.run_server = test_no_sockets,\n\t},\n\t{\n\t\t.name = \"Listen socket\",\n\t\t.run_server = test_listen_socket_server,\n\t},\n\t{\n\t\t.name = \"Connect\",\n\t\t.run_client = test_connect_client,\n\t\t.run_server = test_connect_server,\n\t},\n\t{},\n};\n\nstatic const char optstring[] = \"\";\nstatic const struct option longopts[] = {\n\t{\n\t\t.name = \"control-host\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'H',\n\t},\n\t{\n\t\t.name = \"control-port\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'P',\n\t},\n\t{\n\t\t.name = \"mode\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'm',\n\t},\n\t{\n\t\t.name = \"peer-cid\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'p',\n\t},\n\t{\n\t\t.name = \"list\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'l',\n\t},\n\t{\n\t\t.name = \"skip\",\n\t\t.has_arg = required_argument,\n\t\t.val = 's',\n\t},\n\t{\n\t\t.name = \"help\",\n\t\t.has_arg = no_argument,\n\t\t.val = '?',\n\t},\n\t{},\n};\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"Usage: vsock_diag_test [--help] [--control-host=<host>] --control-port=<port> --mode=client|server --peer-cid=<cid> [--list] [--skip=<test_id>]\\n\"\n\t\t\"\\n\"\n\t\t\"  Server: vsock_diag_test --control-port=1234 --mode=server --peer-cid=3\\n\"\n\t\t\"  Client: vsock_diag_test --control-host=192.168.0.1 --control-port=1234 --mode=client --peer-cid=2\\n\"\n\t\t\"\\n\"\n\t\t\"Run vsock_diag.ko tests.  Must be launched in both\\n\"\n\t\t\"guest and host.  One side must use --mode=client and\\n\"\n\t\t\"the other side must use --mode=server.\\n\"\n\t\t\"\\n\"\n\t\t\"A TCP control socket connection is used to coordinate tests\\n\"\n\t\t\"between the client and the server.  The server requires a\\n\"\n\t\t\"listen address and the client requires an address to\\n\"\n\t\t\"connect to.\\n\"\n\t\t\"\\n\"\n\t\t\"The CID of the other side must be given with --peer-cid=<cid>.\\n\"\n\t\t\"\\n\"\n\t\t\"Options:\\n\"\n\t\t\"  --help                 This help message\\n\"\n\t\t\"  --control-host <host>  Server IP address to connect to\\n\"\n\t\t\"  --control-port <port>  Server port to listen on/connect to\\n\"\n\t\t\"  --mode client|server   Server or client mode\\n\"\n\t\t\"  --peer-cid <cid>       CID of the other side\\n\"\n\t\t\"  --list                 List of tests that will be executed\\n\"\n\t\t\"  --skip <test_id>       Test ID to skip;\\n\"\n\t\t\"                         use multiple --skip options to skip more tests\\n\"\n\t\t);\n\texit(EXIT_FAILURE);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *control_host = NULL;\n\tconst char *control_port = NULL;\n\tstruct test_opts opts = {\n\t\t.mode = TEST_MODE_UNSET,\n\t\t.peer_cid = VMADDR_CID_ANY,\n\t};\n\n\tinit_signals();\n\n\tfor (;;) {\n\t\tint opt = getopt_long(argc, argv, optstring, longopts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'H':\n\t\t\tcontrol_host = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcmp(optarg, \"client\") == 0)\n\t\t\t\topts.mode = TEST_MODE_CLIENT;\n\t\t\telse if (strcmp(optarg, \"server\") == 0)\n\t\t\t\topts.mode = TEST_MODE_SERVER;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"--mode must be \\\"client\\\" or \\\"server\\\"\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topts.peer_cid = parse_cid(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol_port = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_tests(test_cases);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tskip_test(test_cases, ARRAY_SIZE(test_cases) - 1,\n\t\t\t\t  optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (!control_port)\n\t\tusage();\n\tif (opts.mode == TEST_MODE_UNSET)\n\t\tusage();\n\tif (opts.peer_cid == VMADDR_CID_ANY)\n\t\tusage();\n\n\tif (!control_host) {\n\t\tif (opts.mode != TEST_MODE_SERVER)\n\t\t\tusage();\n\t\tcontrol_host = \"0.0.0.0\";\n\t}\n\n\tcontrol_init(control_host, control_port,\n\t\t     opts.mode == TEST_MODE_SERVER);\n\n\trun_tests(test_cases, &opts);\n\n\tcontrol_cleanup();\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}