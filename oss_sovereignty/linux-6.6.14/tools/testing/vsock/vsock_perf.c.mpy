{
  "module_name": "vsock_perf.c",
  "hash_id": "1121af44daebc94ff349edeb548bfa1e1f31daf489c9a0415fbc467361f59d46",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/vsock/vsock_perf.c",
  "human_readable_source": "\n \n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdint.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <linux/vm_sockets.h>\n\n#define DEFAULT_BUF_SIZE_BYTES\t(128 * 1024)\n#define DEFAULT_TO_SEND_BYTES\t(64 * 1024)\n#define DEFAULT_VSOCK_BUF_BYTES (256 * 1024)\n#define DEFAULT_RCVLOWAT_BYTES\t1\n#define DEFAULT_PORT\t\t1234\n\n#define BYTES_PER_GB\t\t(1024 * 1024 * 1024ULL)\n#define NSEC_PER_SEC\t\t(1000000000ULL)\n\nstatic unsigned int port = DEFAULT_PORT;\nstatic unsigned long buf_size_bytes = DEFAULT_BUF_SIZE_BYTES;\nstatic unsigned long vsock_buf_bytes = DEFAULT_VSOCK_BUF_BYTES;\n\nstatic void error(const char *s)\n{\n\tperror(s);\n\texit(EXIT_FAILURE);\n}\n\nstatic time_t current_nsec(void)\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_REALTIME, &ts))\n\t\terror(\"clock_gettime\");\n\n\treturn (ts.tv_sec * NSEC_PER_SEC) + ts.tv_nsec;\n}\n\n \nstatic unsigned long memparse(const char *ptr)\n{\n\tchar *endptr;\n\n\tunsigned long long ret = strtoull(ptr, &endptr, 0);\n\n\tswitch (*endptr) {\n\tcase 'E':\n\tcase 'e':\n\t\tret <<= 10;\n\tcase 'P':\n\tcase 'p':\n\t\tret <<= 10;\n\tcase 'T':\n\tcase 't':\n\t\tret <<= 10;\n\tcase 'G':\n\tcase 'g':\n\t\tret <<= 10;\n\tcase 'M':\n\tcase 'm':\n\t\tret <<= 10;\n\tcase 'K':\n\tcase 'k':\n\t\tret <<= 10;\n\t\tendptr++;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void vsock_increase_buf_size(int fd)\n{\n\tif (setsockopt(fd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,\n\t\t       &vsock_buf_bytes, sizeof(vsock_buf_bytes)))\n\t\terror(\"setsockopt(SO_VM_SOCKETS_BUFFER_MAX_SIZE)\");\n\n\tif (setsockopt(fd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,\n\t\t       &vsock_buf_bytes, sizeof(vsock_buf_bytes)))\n\t\terror(\"setsockopt(SO_VM_SOCKETS_BUFFER_SIZE)\");\n}\n\nstatic int vsock_connect(unsigned int cid, unsigned int port)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = port,\n\t\t\t.svm_cid = cid,\n\t\t},\n\t};\n\tint fd;\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\tif (fd < 0) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\tif (connect(fd, &addr.sa, sizeof(addr.svm)) < 0) {\n\t\tperror(\"connect\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic float get_gbps(unsigned long bits, time_t ns_delta)\n{\n\treturn ((float)bits / 1000000000ULL) /\n\t       ((float)ns_delta / NSEC_PER_SEC);\n}\n\nstatic void run_receiver(unsigned long rcvlowat_bytes)\n{\n\tunsigned int read_cnt;\n\ttime_t rx_begin_ns;\n\ttime_t in_read_ns;\n\tsize_t total_recv;\n\tint client_fd;\n\tchar *data;\n\tint fd;\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = port,\n\t\t\t.svm_cid = VMADDR_CID_ANY,\n\t\t},\n\t};\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} clientaddr;\n\n\tsocklen_t clientaddr_len = sizeof(clientaddr.svm);\n\n\tprintf(\"Run as receiver\\n\");\n\tprintf(\"Listen port %u\\n\", port);\n\tprintf(\"RX buffer %lu bytes\\n\", buf_size_bytes);\n\tprintf(\"vsock buffer %lu bytes\\n\", vsock_buf_bytes);\n\tprintf(\"SO_RCVLOWAT %lu bytes\\n\", rcvlowat_bytes);\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\tif (fd < 0)\n\t\terror(\"socket\");\n\n\tif (bind(fd, &addr.sa, sizeof(addr.svm)) < 0)\n\t\terror(\"bind\");\n\n\tif (listen(fd, 1) < 0)\n\t\terror(\"listen\");\n\n\tclient_fd = accept(fd, &clientaddr.sa, &clientaddr_len);\n\n\tif (client_fd < 0)\n\t\terror(\"accept\");\n\n\tvsock_increase_buf_size(client_fd);\n\n\tif (setsockopt(client_fd, SOL_SOCKET, SO_RCVLOWAT,\n\t\t       &rcvlowat_bytes,\n\t\t       sizeof(rcvlowat_bytes)))\n\t\terror(\"setsockopt(SO_RCVLOWAT)\");\n\n\tdata = malloc(buf_size_bytes);\n\n\tif (!data) {\n\t\tfprintf(stderr, \"'malloc()' failed\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_cnt = 0;\n\tin_read_ns = 0;\n\ttotal_recv = 0;\n\trx_begin_ns = current_nsec();\n\n\twhile (1) {\n\t\tstruct pollfd fds = { 0 };\n\n\t\tfds.fd = client_fd;\n\t\tfds.events = POLLIN | POLLERR |\n\t\t\t     POLLHUP | POLLRDHUP;\n\n\t\tif (poll(&fds, 1, -1) < 0)\n\t\t\terror(\"poll\");\n\n\t\tif (fds.revents & POLLERR) {\n\t\t\tfprintf(stderr, \"'poll()' error\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (fds.revents & POLLIN) {\n\t\t\tssize_t bytes_read;\n\t\t\ttime_t t;\n\n\t\t\tt = current_nsec();\n\t\t\tbytes_read = read(fds.fd, data, buf_size_bytes);\n\t\t\tin_read_ns += (current_nsec() - t);\n\t\t\tread_cnt++;\n\n\t\t\tif (!bytes_read)\n\t\t\t\tbreak;\n\n\t\t\tif (bytes_read < 0) {\n\t\t\t\tperror(\"read\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\ttotal_recv += bytes_read;\n\t\t}\n\n\t\tif (fds.revents & (POLLHUP | POLLRDHUP))\n\t\t\tbreak;\n\t}\n\n\tprintf(\"total bytes received: %zu\\n\", total_recv);\n\tprintf(\"rx performance: %f Gbits/s\\n\",\n\t       get_gbps(total_recv * 8, current_nsec() - rx_begin_ns));\n\tprintf(\"total time in 'read()': %f sec\\n\", (float)in_read_ns / NSEC_PER_SEC);\n\tprintf(\"average time in 'read()': %f ns\\n\", (float)in_read_ns / read_cnt);\n\tprintf(\"POLLIN wakeups: %i\\n\", read_cnt);\n\n\tfree(data);\n\tclose(client_fd);\n\tclose(fd);\n}\n\nstatic void run_sender(int peer_cid, unsigned long to_send_bytes)\n{\n\ttime_t tx_begin_ns;\n\ttime_t tx_total_ns;\n\tsize_t total_send;\n\tvoid *data;\n\tint fd;\n\n\tprintf(\"Run as sender\\n\");\n\tprintf(\"Connect to %i:%u\\n\", peer_cid, port);\n\tprintf(\"Send %lu bytes\\n\", to_send_bytes);\n\tprintf(\"TX buffer %lu bytes\\n\", buf_size_bytes);\n\n\tfd = vsock_connect(peer_cid, port);\n\n\tif (fd < 0)\n\t\texit(EXIT_FAILURE);\n\n\tdata = malloc(buf_size_bytes);\n\n\tif (!data) {\n\t\tfprintf(stderr, \"'malloc()' failed\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(data, 0, buf_size_bytes);\n\ttotal_send = 0;\n\ttx_begin_ns = current_nsec();\n\n\twhile (total_send < to_send_bytes) {\n\t\tssize_t sent;\n\n\t\tsent = write(fd, data, buf_size_bytes);\n\n\t\tif (sent <= 0)\n\t\t\terror(\"write\");\n\n\t\ttotal_send += sent;\n\t}\n\n\ttx_total_ns = current_nsec() - tx_begin_ns;\n\n\tprintf(\"total bytes sent: %zu\\n\", total_send);\n\tprintf(\"tx performance: %f Gbits/s\\n\",\n\t       get_gbps(total_send * 8, tx_total_ns));\n\tprintf(\"total time in 'write()': %f sec\\n\",\n\t       (float)tx_total_ns / NSEC_PER_SEC);\n\n\tclose(fd);\n\tfree(data);\n}\n\nstatic const char optstring[] = \"\";\nstatic const struct option longopts[] = {\n\t{\n\t\t.name = \"help\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'H',\n\t},\n\t{\n\t\t.name = \"sender\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'S',\n\t},\n\t{\n\t\t.name = \"port\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'P',\n\t},\n\t{\n\t\t.name = \"bytes\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'M',\n\t},\n\t{\n\t\t.name = \"buf-size\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'B',\n\t},\n\t{\n\t\t.name = \"vsk-size\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'V',\n\t},\n\t{\n\t\t.name = \"rcvlowat\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'R',\n\t},\n\t{},\n};\n\nstatic void usage(void)\n{\n\tprintf(\"Usage: ./vsock_perf [--help] [options]\\n\"\n\t       \"\\n\"\n\t       \"This is benchmarking utility, to test vsock performance.\\n\"\n\t       \"It runs in two modes: sender or receiver. In sender mode, it\\n\"\n\t       \"connects to the specified CID and starts data transmission.\\n\"\n\t       \"\\n\"\n\t       \"Options:\\n\"\n\t       \"  --help\t\t\tThis message\\n\"\n\t       \"  --sender   <cid>\t\tSender mode (receiver default)\\n\"\n\t       \"                                <cid> of the receiver to connect to\\n\"\n\t       \"  --port     <port>\t\tPort (default %d)\\n\"\n\t       \"  --bytes    <bytes>KMG\t\tBytes to send (default %d)\\n\"\n\t       \"  --buf-size <bytes>KMG\t\tData buffer size (default %d). In sender mode\\n\"\n\t       \"                                it is the buffer size, passed to 'write()'. In\\n\"\n\t       \"                                receiver mode it is the buffer size passed to 'read()'.\\n\"\n\t       \"  --vsk-size <bytes>KMG\t\tSocket buffer size (default %d)\\n\"\n\t       \"  --rcvlowat <bytes>KMG\t\tSO_RCVLOWAT value (default %d)\\n\"\n\t       \"\\n\", DEFAULT_PORT, DEFAULT_TO_SEND_BYTES,\n\t       DEFAULT_BUF_SIZE_BYTES, DEFAULT_VSOCK_BUF_BYTES,\n\t       DEFAULT_RCVLOWAT_BYTES);\n\texit(EXIT_FAILURE);\n}\n\nstatic long strtolx(const char *arg)\n{\n\tlong value;\n\tchar *end;\n\n\tvalue = strtol(arg, &end, 10);\n\n\tif (end != arg + strlen(arg))\n\t\tusage();\n\n\treturn value;\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned long to_send_bytes = DEFAULT_TO_SEND_BYTES;\n\tunsigned long rcvlowat_bytes = DEFAULT_RCVLOWAT_BYTES;\n\tint peer_cid = -1;\n\tbool sender = false;\n\n\twhile (1) {\n\t\tint opt = getopt_long(argc, argv, optstring, longopts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'V':  \n\t\t\tvsock_buf_bytes = memparse(optarg);\n\t\t\tbreak;\n\t\tcase 'R':  \n\t\t\trcvlowat_bytes = memparse(optarg);\n\t\t\tbreak;\n\t\tcase 'P':  \n\t\t\tport = strtolx(optarg);\n\t\t\tbreak;\n\t\tcase 'M':  \n\t\t\tto_send_bytes = memparse(optarg);\n\t\t\tbreak;\n\t\tcase 'B':  \n\t\t\tbuf_size_bytes = memparse(optarg);\n\t\t\tbreak;\n\t\tcase 'S':  \n\t\t\tpeer_cid = strtolx(optarg);\n\t\t\tsender = true;\n\t\t\tbreak;\n\t\tcase 'H':  \n\t\t\tusage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (!sender)\n\t\trun_receiver(rcvlowat_bytes);\n\telse\n\t\trun_sender(peer_cid, to_send_bytes);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}