{
  "module_name": "util.c",
  "hash_id": "f81d41c1256e58c015c8cfa4371b7c5d4c0e53a0c54dce07c1406b16353e9c96",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/vsock/util.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/epoll.h>\n\n#include \"timeout.h\"\n#include \"control.h\"\n#include \"util.h\"\n\n \nvoid init_signals(void)\n{\n\tstruct sigaction act = {\n\t\t.sa_handler = sigalrm,\n\t};\n\n\tsigaction(SIGALRM, &act, NULL);\n\tsignal(SIGPIPE, SIG_IGN);\n}\n\n \nunsigned int parse_cid(const char *str)\n{\n\tchar *endptr = NULL;\n\tunsigned long n;\n\n\terrno = 0;\n\tn = strtoul(str, &endptr, 10);\n\tif (errno || *endptr != '\\0') {\n\t\tfprintf(stderr, \"malformed CID \\\"%s\\\"\\n\", str);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn n;\n}\n\n \nvoid vsock_wait_remote_close(int fd)\n{\n\tstruct epoll_event ev;\n\tint epollfd, nfds;\n\n\tepollfd = epoll_create1(0);\n\tif (epollfd == -1) {\n\t\tperror(\"epoll_create1\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tev.events = EPOLLRDHUP | EPOLLHUP;\n\tev.data.fd = fd;\n\tif (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev) == -1) {\n\t\tperror(\"epoll_ctl\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tnfds = epoll_wait(epollfd, &ev, 1, TIMEOUT * 1000);\n\tif (nfds == -1) {\n\t\tperror(\"epoll_wait\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (nfds == 0) {\n\t\tfprintf(stderr, \"epoll_wait timed out\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tassert(nfds == 1);\n\tassert(ev.events & (EPOLLRDHUP | EPOLLHUP));\n\tassert(ev.data.fd == fd);\n\n\tclose(epollfd);\n}\n\n \nstatic int vsock_connect(unsigned int cid, unsigned int port, int type)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = port,\n\t\t\t.svm_cid = cid,\n\t\t},\n\t};\n\tint ret;\n\tint fd;\n\n\tcontrol_expectln(\"LISTENING\");\n\n\tfd = socket(AF_VSOCK, type, 0);\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tret = connect(fd, &addr.sa, sizeof(addr.svm));\n\t\ttimeout_check(\"connect\");\n\t} while (ret < 0 && errno == EINTR);\n\ttimeout_end();\n\n\tif (ret < 0) {\n\t\tint old_errno = errno;\n\n\t\tclose(fd);\n\t\tfd = -1;\n\t\terrno = old_errno;\n\t}\n\treturn fd;\n}\n\nint vsock_stream_connect(unsigned int cid, unsigned int port)\n{\n\treturn vsock_connect(cid, port, SOCK_STREAM);\n}\n\nint vsock_seqpacket_connect(unsigned int cid, unsigned int port)\n{\n\treturn vsock_connect(cid, port, SOCK_SEQPACKET);\n}\n\n \nstatic int vsock_accept(unsigned int cid, unsigned int port,\n\t\t\tstruct sockaddr_vm *clientaddrp, int type)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = port,\n\t\t\t.svm_cid = cid,\n\t\t},\n\t};\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} clientaddr;\n\tsocklen_t clientaddr_len = sizeof(clientaddr.svm);\n\tint fd;\n\tint client_fd;\n\tint old_errno;\n\n\tfd = socket(AF_VSOCK, type, 0);\n\n\tif (bind(fd, &addr.sa, sizeof(addr.svm)) < 0) {\n\t\tperror(\"bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (listen(fd, 1) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"LISTENING\");\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tclient_fd = accept(fd, &clientaddr.sa, &clientaddr_len);\n\t\ttimeout_check(\"accept\");\n\t} while (client_fd < 0 && errno == EINTR);\n\ttimeout_end();\n\n\told_errno = errno;\n\tclose(fd);\n\terrno = old_errno;\n\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\tif (clientaddr_len != sizeof(clientaddr.svm)) {\n\t\tfprintf(stderr, \"unexpected addrlen from accept(2), %zu\\n\",\n\t\t\t(size_t)clientaddr_len);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (clientaddr.sa.sa_family != AF_VSOCK) {\n\t\tfprintf(stderr, \"expected AF_VSOCK from accept(2), got %d\\n\",\n\t\t\tclientaddr.sa.sa_family);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (clientaddrp)\n\t\t*clientaddrp = clientaddr.svm;\n\treturn client_fd;\n}\n\nint vsock_stream_accept(unsigned int cid, unsigned int port,\n\t\t\tstruct sockaddr_vm *clientaddrp)\n{\n\treturn vsock_accept(cid, port, clientaddrp, SOCK_STREAM);\n}\n\nint vsock_seqpacket_accept(unsigned int cid, unsigned int port,\n\t\t\t   struct sockaddr_vm *clientaddrp)\n{\n\treturn vsock_accept(cid, port, clientaddrp, SOCK_SEQPACKET);\n}\n\n \nvoid send_byte(int fd, int expected_ret, int flags)\n{\n\tconst uint8_t byte = 'A';\n\tssize_t nwritten;\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tnwritten = send(fd, &byte, sizeof(byte), flags);\n\t\ttimeout_check(\"write\");\n\t} while (nwritten < 0 && errno == EINTR);\n\ttimeout_end();\n\n\tif (expected_ret < 0) {\n\t\tif (nwritten != -1) {\n\t\t\tfprintf(stderr, \"bogus send(2) return value %zd\\n\",\n\t\t\t\tnwritten);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (errno != -expected_ret) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (nwritten < 0) {\n\t\tperror(\"write\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (nwritten == 0) {\n\t\tif (expected_ret == 0)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"unexpected EOF while sending byte\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (nwritten != sizeof(byte)) {\n\t\tfprintf(stderr, \"bogus send(2) return value %zd\\n\", nwritten);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n \nvoid recv_byte(int fd, int expected_ret, int flags)\n{\n\tuint8_t byte;\n\tssize_t nread;\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tnread = recv(fd, &byte, sizeof(byte), flags);\n\t\ttimeout_check(\"read\");\n\t} while (nread < 0 && errno == EINTR);\n\ttimeout_end();\n\n\tif (expected_ret < 0) {\n\t\tif (nread != -1) {\n\t\t\tfprintf(stderr, \"bogus recv(2) return value %zd\\n\",\n\t\t\t\tnread);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (errno != -expected_ret) {\n\t\t\tperror(\"read\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (nread < 0) {\n\t\tperror(\"read\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (nread == 0) {\n\t\tif (expected_ret == 0)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"unexpected EOF while receiving byte\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (nread != sizeof(byte)) {\n\t\tfprintf(stderr, \"bogus recv(2) return value %zd\\n\", nread);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (byte != 'A') {\n\t\tfprintf(stderr, \"unexpected byte read %c\\n\", byte);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n \nvoid run_tests(const struct test_case *test_cases,\n\t       const struct test_opts *opts)\n{\n\tint i;\n\n\tfor (i = 0; test_cases[i].name; i++) {\n\t\tvoid (*run)(const struct test_opts *opts);\n\t\tchar *line;\n\n\t\tprintf(\"%d - %s...\", i, test_cases[i].name);\n\t\tfflush(stdout);\n\n\t\t \n\t\tif (test_cases[i].skip)\n\t\t\tcontrol_writeln(\"SKIP\");\n\t\telse\n\t\t\tcontrol_writeln(\"NEXT\");\n\n\t\tline = control_readln();\n\t\tif (control_cmpln(line, \"SKIP\", false) || test_cases[i].skip) {\n\n\t\t\tprintf(\"skipped\\n\");\n\n\t\t\tfree(line);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontrol_cmpln(line, \"NEXT\", true);\n\t\tfree(line);\n\n\t\tif (opts->mode == TEST_MODE_CLIENT)\n\t\t\trun = test_cases[i].run_client;\n\t\telse\n\t\t\trun = test_cases[i].run_server;\n\n\t\tif (run)\n\t\t\trun(opts);\n\n\t\tprintf(\"ok\\n\");\n\t}\n}\n\nvoid list_tests(const struct test_case *test_cases)\n{\n\tint i;\n\n\tprintf(\"ID\\tTest name\\n\");\n\n\tfor (i = 0; test_cases[i].name; i++)\n\t\tprintf(\"%d\\t%s\\n\", i, test_cases[i].name);\n\n\texit(EXIT_FAILURE);\n}\n\nvoid skip_test(struct test_case *test_cases, size_t test_cases_len,\n\t       const char *test_id_str)\n{\n\tunsigned long test_id;\n\tchar *endptr = NULL;\n\n\terrno = 0;\n\ttest_id = strtoul(test_id_str, &endptr, 10);\n\tif (errno || *endptr != '\\0') {\n\t\tfprintf(stderr, \"malformed test ID \\\"%s\\\"\\n\", test_id_str);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (test_id >= test_cases_len) {\n\t\tfprintf(stderr, \"test ID (%lu) larger than the max allowed (%lu)\\n\",\n\t\t\ttest_id, test_cases_len - 1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\ttest_cases[test_id].skip = true;\n}\n\nunsigned long hash_djb2(const void *data, size_t len)\n{\n\tunsigned long hash = 5381;\n\tint i = 0;\n\n\twhile (i < len) {\n\t\thash = ((hash << 5) + hash) + ((unsigned char *)data)[i];\n\t\ti++;\n\t}\n\n\treturn hash;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}