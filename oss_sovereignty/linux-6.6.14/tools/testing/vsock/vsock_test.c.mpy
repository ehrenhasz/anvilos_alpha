{
  "module_name": "vsock_test.c",
  "hash_id": "a4438cd81522273fc9723138252a9deac3e6cb1ce020ccbe3a888f3f1238834a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/vsock/vsock_test.c",
  "human_readable_source": "\n \n\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <linux/kernel.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <time.h>\n#include <sys/mman.h>\n#include <poll.h>\n\n#include \"timeout.h\"\n#include \"control.h\"\n#include \"util.h\"\n\nstatic void test_stream_connection_reset(const struct test_opts *opts)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = 1234,\n\t\t\t.svm_cid = opts->peer_cid,\n\t\t},\n\t};\n\tint ret;\n\tint fd;\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tret = connect(fd, &addr.sa, sizeof(addr.svm));\n\t\ttimeout_check(\"connect\");\n\t} while (ret < 0 && errno == EINTR);\n\ttimeout_end();\n\n\tif (ret != -1) {\n\t\tfprintf(stderr, \"expected connect(2) failure, got %d\\n\", ret);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (errno != ECONNRESET) {\n\t\tfprintf(stderr, \"unexpected connect(2) errno %d\\n\", errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_stream_bind_only_client(const struct test_opts *opts)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = 1234,\n\t\t\t.svm_cid = opts->peer_cid,\n\t\t},\n\t};\n\tint ret;\n\tint fd;\n\n\t \n\tcontrol_expectln(\"BIND\");\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\ttimeout_begin(TIMEOUT);\n\tdo {\n\t\tret = connect(fd, &addr.sa, sizeof(addr.svm));\n\t\ttimeout_check(\"connect\");\n\t} while (ret < 0 && errno == EINTR);\n\ttimeout_end();\n\n\tif (ret != -1) {\n\t\tfprintf(stderr, \"expected connect(2) failure, got %d\\n\", ret);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (errno != ECONNRESET) {\n\t\tfprintf(stderr, \"unexpected connect(2) errno %d\\n\", errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tcontrol_writeln(\"DONE\");\n\n\tclose(fd);\n}\n\nstatic void test_stream_bind_only_server(const struct test_opts *opts)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_vm svm;\n\t} addr = {\n\t\t.svm = {\n\t\t\t.svm_family = AF_VSOCK,\n\t\t\t.svm_port = 1234,\n\t\t\t.svm_cid = VMADDR_CID_ANY,\n\t\t},\n\t};\n\tint fd;\n\n\tfd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\n\tif (bind(fd, &addr.sa, sizeof(addr.svm)) < 0) {\n\t\tperror(\"bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tcontrol_writeln(\"BIND\");\n\n\t \n\tcontrol_expectln(\"DONE\");\n\n\tclose(fd);\n}\n\nstatic void test_stream_client_close_client(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_byte(fd, 1, 0);\n\tclose(fd);\n}\n\nstatic void test_stream_client_close_server(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tvsock_wait_remote_close(fd);\n\n\tsend_byte(fd, -EPIPE, 0);\n\trecv_byte(fd, 1, 0);\n\trecv_byte(fd, 0, 0);\n\tclose(fd);\n}\n\nstatic void test_stream_server_close_client(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tvsock_wait_remote_close(fd);\n\n\tsend_byte(fd, -EPIPE, 0);\n\trecv_byte(fd, 1, 0);\n\trecv_byte(fd, 0, 0);\n\tclose(fd);\n}\n\nstatic void test_stream_server_close_server(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_byte(fd, 1, 0);\n\tclose(fd);\n}\n\n \n#define MULTICONN_NFDS 100\n\nstatic void test_stream_multiconn_client(const struct test_opts *opts)\n{\n\tint fds[MULTICONN_NFDS];\n\tint i;\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++) {\n\t\tfds[i] = vsock_stream_connect(opts->peer_cid, 1234);\n\t\tif (fds[i] < 0) {\n\t\t\tperror(\"connect\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++) {\n\t\tif (i % 2)\n\t\t\trecv_byte(fds[i], 1, 0);\n\t\telse\n\t\t\tsend_byte(fds[i], 1, 0);\n\t}\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++)\n\t\tclose(fds[i]);\n}\n\nstatic void test_stream_multiconn_server(const struct test_opts *opts)\n{\n\tint fds[MULTICONN_NFDS];\n\tint i;\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++) {\n\t\tfds[i] = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\t\tif (fds[i] < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++) {\n\t\tif (i % 2)\n\t\t\tsend_byte(fds[i], 1, 0);\n\t\telse\n\t\t\trecv_byte(fds[i], 1, 0);\n\t}\n\n\tfor (i = 0; i < MULTICONN_NFDS; i++)\n\t\tclose(fds[i]);\n}\n\n#define MSG_PEEK_BUF_LEN 64\n\nstatic void test_msg_peek_client(const struct test_opts *opts,\n\t\t\t\t bool seqpacket)\n{\n\tunsigned char buf[MSG_PEEK_BUF_LEN];\n\tssize_t send_size;\n\tint fd;\n\tint i;\n\n\tif (seqpacket)\n\t\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\telse\n\t\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (i = 0; i < sizeof(buf); i++)\n\t\tbuf[i] = rand() & 0xFF;\n\n\tcontrol_expectln(\"SRVREADY\");\n\n\tsend_size = send(fd, buf, sizeof(buf), 0);\n\n\tif (send_size < 0) {\n\t\tperror(\"send\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (send_size != sizeof(buf)) {\n\t\tfprintf(stderr, \"Invalid send size %zi\\n\", send_size);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_msg_peek_server(const struct test_opts *opts,\n\t\t\t\t bool seqpacket)\n{\n\tunsigned char buf_half[MSG_PEEK_BUF_LEN / 2];\n\tunsigned char buf_normal[MSG_PEEK_BUF_LEN];\n\tunsigned char buf_peek[MSG_PEEK_BUF_LEN];\n\tssize_t res;\n\tint fd;\n\n\tif (seqpacket)\n\t\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\telse\n\t\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tres = recv(fd, buf_peek, sizeof(buf_peek), MSG_PEEK | MSG_DONTWAIT);\n\tif (res != -1) {\n\t\tfprintf(stderr, \"expected recv(2) failure, got %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (errno != EAGAIN) {\n\t\tperror(\"EAGAIN expected\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"SRVREADY\");\n\n\t \n\tres = recv(fd, buf_half, sizeof(buf_half), MSG_PEEK);\n\tif (res != sizeof(buf_half)) {\n\t\tfprintf(stderr, \"recv(2) + MSG_PEEK, expected %zu, got %zi\\n\",\n\t\t\tsizeof(buf_half), res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tres = recv(fd, buf_peek, sizeof(buf_peek), MSG_PEEK);\n\tif (res != sizeof(buf_peek)) {\n\t\tfprintf(stderr, \"recv(2) + MSG_PEEK, expected %zu, got %zi\\n\",\n\t\t\tsizeof(buf_peek), res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (memcmp(buf_half, buf_peek, sizeof(buf_half))) {\n\t\tfprintf(stderr, \"Partial peek data mismatch\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (seqpacket) {\n\t\t \n\t\tres = recv(fd, buf_half, sizeof(buf_half), MSG_PEEK |\n\t\t\t   MSG_TRUNC);\n\t\tif (res != sizeof(buf_peek)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"recv(2) + MSG_PEEK | MSG_TRUNC, exp %zu, got %zi\\n\",\n\t\t\t\tsizeof(buf_half), res);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tres = recv(fd, buf_normal, sizeof(buf_normal), 0);\n\tif (res != sizeof(buf_normal)) {\n\t\tfprintf(stderr, \"recv(2), expected %zu, got %zi\\n\",\n\t\t\tsizeof(buf_normal), res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (memcmp(buf_peek, buf_normal, sizeof(buf_peek))) {\n\t\tfprintf(stderr, \"Full peek data mismatch\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_stream_msg_peek_client(const struct test_opts *opts)\n{\n\treturn test_msg_peek_client(opts, false);\n}\n\nstatic void test_stream_msg_peek_server(const struct test_opts *opts)\n{\n\treturn test_msg_peek_server(opts, false);\n}\n\n#define SOCK_BUF_SIZE (2 * 1024 * 1024)\n#define MAX_MSG_PAGES 4\n\nstatic void test_seqpacket_msg_bounds_client(const struct test_opts *opts)\n{\n\tunsigned long curr_hash;\n\tsize_t max_msg_size;\n\tint page_size;\n\tint msg_count;\n\tint fd;\n\n\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tcontrol_expectln(\"SRVREADY\");\n\n\tcurr_hash = 0;\n\tpage_size = getpagesize();\n\tmax_msg_size = MAX_MSG_PAGES * page_size;\n\tmsg_count = SOCK_BUF_SIZE / max_msg_size;\n\n\tfor (int i = 0; i < msg_count; i++) {\n\t\tssize_t send_size;\n\t\tsize_t buf_size;\n\t\tint flags;\n\t\tvoid *buf;\n\n\t\t \n\t\tif (i & 1)\n\t\t\tbuf_size = page_size +\n\t\t\t\t\t(rand() % (max_msg_size - page_size));\n\t\telse\n\t\t\tbuf_size = 1 + (rand() % page_size);\n\n\t\tbuf = malloc(buf_size);\n\n\t\tif (!buf) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tmemset(buf, rand() & 0xff, buf_size);\n\t\t \n\t\tif (i == (msg_count / 2) || (rand() & 1)) {\n\t\t\tflags = MSG_EOR;\n\t\t\tcurr_hash++;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tsend_size = send(fd, buf, buf_size, flags);\n\n\t\tif (send_size < 0) {\n\t\t\tperror(\"send\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (send_size != buf_size) {\n\t\t\tfprintf(stderr, \"Invalid send size\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tcurr_hash += hash_djb2(buf, buf_size);\n\t\tfree(buf);\n\t}\n\n\tcontrol_writeln(\"SENDDONE\");\n\tcontrol_writeulong(curr_hash);\n\tclose(fd);\n}\n\nstatic void test_seqpacket_msg_bounds_server(const struct test_opts *opts)\n{\n\tunsigned long sock_buf_size;\n\tunsigned long remote_hash;\n\tunsigned long curr_hash;\n\tint fd;\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\n\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsock_buf_size = SOCK_BUF_SIZE;\n\n\tif (setsockopt(fd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,\n\t\t       &sock_buf_size, sizeof(sock_buf_size))) {\n\t\tperror(\"setsockopt(SO_VM_SOCKETS_BUFFER_MAX_SIZE)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (setsockopt(fd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,\n\t\t       &sock_buf_size, sizeof(sock_buf_size))) {\n\t\tperror(\"setsockopt(SO_VM_SOCKETS_BUFFER_SIZE)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tcontrol_writeln(\"SRVREADY\");\n\t \n\tcontrol_expectln(\"SENDDONE\");\n\tiov.iov_len = MAX_MSG_PAGES * getpagesize();\n\tiov.iov_base = malloc(iov.iov_len);\n\tif (!iov.iov_base) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tcurr_hash = 0;\n\n\twhile (1) {\n\t\tssize_t recv_size;\n\n\t\trecv_size = recvmsg(fd, &msg, 0);\n\n\t\tif (!recv_size)\n\t\t\tbreak;\n\n\t\tif (recv_size < 0) {\n\t\t\tperror(\"recvmsg\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_EOR)\n\t\t\tcurr_hash++;\n\n\t\tcurr_hash += hash_djb2(msg.msg_iov[0].iov_base, recv_size);\n\t}\n\n\tfree(iov.iov_base);\n\tclose(fd);\n\tremote_hash = control_readulong();\n\n\tif (curr_hash != remote_hash) {\n\t\tfprintf(stderr, \"Message bounds broken\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n#define MESSAGE_TRUNC_SZ 32\nstatic void test_seqpacket_msg_trunc_client(const struct test_opts *opts)\n{\n\tint fd;\n\tchar buf[MESSAGE_TRUNC_SZ];\n\n\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (send(fd, buf, sizeof(buf), 0) != sizeof(buf)) {\n\t\tperror(\"send failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"SENDDONE\");\n\tclose(fd);\n}\n\nstatic void test_seqpacket_msg_trunc_server(const struct test_opts *opts)\n{\n\tint fd;\n\tchar buf[MESSAGE_TRUNC_SZ / 2];\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\n\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"SENDDONE\");\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tssize_t ret = recvmsg(fd, &msg, MSG_TRUNC);\n\n\tif (ret != MESSAGE_TRUNC_SZ) {\n\t\tprintf(\"%zi\\n\", ret);\n\t\tperror(\"MSG_TRUNC doesn't work\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!(msg.msg_flags & MSG_TRUNC)) {\n\t\tfprintf(stderr, \"MSG_TRUNC expected\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}\n\nstatic time_t current_nsec(void)\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_REALTIME, &ts)) {\n\t\tperror(\"clock_gettime(3) failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn (ts.tv_sec * 1000000000ULL) + ts.tv_nsec;\n}\n\n#define RCVTIMEO_TIMEOUT_SEC 1\n#define READ_OVERHEAD_NSEC 250000000  \n\nstatic void test_seqpacket_timeout_client(const struct test_opts *opts)\n{\n\tint fd;\n\tstruct timeval tv;\n\tchar dummy;\n\ttime_t read_enter_ns;\n\ttime_t read_overhead_ns;\n\n\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\ttv.tv_sec = RCVTIMEO_TIMEOUT_SEC;\n\ttv.tv_usec = 0;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (void *)&tv, sizeof(tv)) == -1) {\n\t\tperror(\"setsockopt(SO_RCVTIMEO)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_enter_ns = current_nsec();\n\n\tif (read(fd, &dummy, sizeof(dummy)) != -1) {\n\t\tfprintf(stderr,\n\t\t\t\"expected 'dummy' read(2) failure\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (errno != EAGAIN) {\n\t\tperror(\"EAGAIN expected\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tread_overhead_ns = current_nsec() - read_enter_ns -\n\t\t\t1000000000ULL * RCVTIMEO_TIMEOUT_SEC;\n\n\tif (read_overhead_ns > READ_OVERHEAD_NSEC) {\n\t\tfprintf(stderr,\n\t\t\t\"too much time in read(2), %lu > %i ns\\n\",\n\t\t\tread_overhead_ns, READ_OVERHEAD_NSEC);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"WAITDONE\");\n\tclose(fd);\n}\n\nstatic void test_seqpacket_timeout_server(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"WAITDONE\");\n\tclose(fd);\n}\n\nstatic void test_seqpacket_bigmsg_client(const struct test_opts *opts)\n{\n\tunsigned long sock_buf_size;\n\tssize_t send_size;\n\tsocklen_t len;\n\tvoid *data;\n\tint fd;\n\n\tlen = sizeof(sock_buf_size);\n\n\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (getsockopt(fd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,\n\t\t       &sock_buf_size, &len)) {\n\t\tperror(\"getsockopt\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsock_buf_size++;\n\n\tdata = malloc(sock_buf_size);\n\tif (!data) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_size = send(fd, data, sock_buf_size, 0);\n\tif (send_size != -1) {\n\t\tfprintf(stderr, \"expected 'send(2)' failure, got %zi\\n\",\n\t\t\tsend_size);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (errno != EMSGSIZE) {\n\t\tfprintf(stderr, \"expected EMSGSIZE in 'errno', got %i\\n\",\n\t\t\terrno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"CLISENT\");\n\n\tfree(data);\n\tclose(fd);\n}\n\nstatic void test_seqpacket_bigmsg_server(const struct test_opts *opts)\n{\n\tint fd;\n\n\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"CLISENT\");\n\n\tclose(fd);\n}\n\n#define BUF_PATTERN_1 'a'\n#define BUF_PATTERN_2 'b'\n\nstatic void test_seqpacket_invalid_rec_buffer_client(const struct test_opts *opts)\n{\n\tint fd;\n\tunsigned char *buf1;\n\tunsigned char *buf2;\n\tint buf_size = getpagesize() * 3;\n\n\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tbuf1 = malloc(buf_size);\n\tif (!buf1) {\n\t\tperror(\"'malloc()' for 'buf1'\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tbuf2 = malloc(buf_size);\n\tif (!buf2) {\n\t\tperror(\"'malloc()' for 'buf2'\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(buf1, BUF_PATTERN_1, buf_size);\n\tmemset(buf2, BUF_PATTERN_2, buf_size);\n\n\tif (send(fd, buf1, buf_size, 0) != buf_size) {\n\t\tperror(\"send failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (send(fd, buf2, buf_size, 0) != buf_size) {\n\t\tperror(\"send failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_seqpacket_invalid_rec_buffer_server(const struct test_opts *opts)\n{\n\tint fd;\n\tunsigned char *broken_buf;\n\tunsigned char *valid_buf;\n\tint page_size = getpagesize();\n\tint buf_size = page_size * 3;\n\tssize_t res;\n\tint prot = PROT_READ | PROT_WRITE;\n\tint flags = MAP_PRIVATE | MAP_ANONYMOUS;\n\tint i;\n\n\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tbroken_buf = mmap(NULL, buf_size, prot, flags, -1, 0);\n\tif (broken_buf == MAP_FAILED) {\n\t\tperror(\"mmap for 'broken_buf'\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (munmap(broken_buf + page_size, page_size)) {\n\t\tperror(\"'broken_buf' setup\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tvalid_buf = mmap(NULL, buf_size, prot, flags, -1, 0);\n\tif (valid_buf == MAP_FAILED) {\n\t\tperror(\"mmap for 'valid_buf'\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tres = read(fd, broken_buf, buf_size);\n\tif (res != -1) {\n\t\tfprintf(stderr,\n\t\t\t\"expected 'broken_buf' read(2) failure, got %zi\\n\",\n\t\t\tres);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (errno != EFAULT) {\n\t\tperror(\"unexpected errno of 'broken_buf'\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tres = read(fd, valid_buf, buf_size);\n\tif (res < 0) {\n\t\tperror(\"unexpected 'valid_buf' read(2) failure\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (res != buf_size) {\n\t\tfprintf(stderr,\n\t\t\t\"invalid 'valid_buf' read(2), expected %i, got %zi\\n\",\n\t\t\tbuf_size, res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (i = 0; i < buf_size; i++) {\n\t\tif (valid_buf[i] != BUF_PATTERN_2) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"invalid pattern for 'valid_buf' at %i, expected %hhX, got %hhX\\n\",\n\t\t\t\ti, BUF_PATTERN_2, valid_buf[i]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t \n\tmunmap(broken_buf, page_size);\n\tmunmap(broken_buf + page_size * 2, page_size);\n\tmunmap(valid_buf, buf_size);\n\tclose(fd);\n}\n\n#define RCVLOWAT_BUF_SIZE 128\n\nstatic void test_stream_poll_rcvlowat_server(const struct test_opts *opts)\n{\n\tint fd;\n\tint i;\n\n\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tsend_byte(fd, 1, 0);\n\n\tcontrol_writeln(\"SRVSENT\");\n\n\t \n\tcontrol_expectln(\"CLNSENT\");\n\n\tfor (i = 0; i < RCVLOWAT_BUF_SIZE - 1; i++)\n\t\tsend_byte(fd, 1, 0);\n\n\t \n\tcontrol_expectln(\"POLLDONE\");\n\n\tclose(fd);\n}\n\nstatic void test_stream_poll_rcvlowat_client(const struct test_opts *opts)\n{\n\tunsigned long lowat_val = RCVLOWAT_BUF_SIZE;\n\tchar buf[RCVLOWAT_BUF_SIZE];\n\tstruct pollfd fds;\n\tssize_t read_res;\n\tshort poll_flags;\n\tint fd;\n\n\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVLOWAT,\n\t\t       &lowat_val, sizeof(lowat_val))) {\n\t\tperror(\"setsockopt(SO_RCVLOWAT)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"SRVSENT\");\n\n\t \n\tfds.fd = fd;\n\tpoll_flags = POLLIN | POLLRDNORM;\n\tfds.events = poll_flags;\n\n\t \n\tif (poll(&fds, 1, 1000) < 0) {\n\t\tperror(\"poll\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (fds.revents) {\n\t\tfprintf(stderr, \"Unexpected poll result %hx\\n\",\n\t\t\tfds.revents);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tcontrol_writeln(\"CLNSENT\");\n\n\t \n\tif (poll(&fds, 1, 10000) < 0) {\n\t\tperror(\"poll\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (fds.revents != poll_flags) {\n\t\tfprintf(stderr, \"Unexpected poll result %hx\\n\",\n\t\t\tfds.revents);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tread_res = recv(fd, buf, sizeof(buf), MSG_DONTWAIT);\n\tif (read_res != RCVLOWAT_BUF_SIZE) {\n\t\tfprintf(stderr, \"Unexpected recv result %zi\\n\",\n\t\t\tread_res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"POLLDONE\");\n\n\tclose(fd);\n}\n\n#define INV_BUF_TEST_DATA_LEN 512\n\nstatic void test_inv_buf_client(const struct test_opts *opts, bool stream)\n{\n\tunsigned char data[INV_BUF_TEST_DATA_LEN] = {0};\n\tssize_t ret;\n\tint fd;\n\n\tif (stream)\n\t\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\telse\n\t\tfd = vsock_seqpacket_connect(opts->peer_cid, 1234);\n\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"SENDDONE\");\n\n\t \n\tret = recv(fd, NULL, sizeof(data), 0);\n\tif (ret != -1) {\n\t\tfprintf(stderr, \"expected recv(2) failure, got %zi\\n\", ret);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (errno != EFAULT) {\n\t\tfprintf(stderr, \"unexpected recv(2) errno %d\\n\", errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = recv(fd, data, sizeof(data), MSG_DONTWAIT);\n\n\tif (stream) {\n\t\t \n\t\tif (ret != sizeof(data)) {\n\t\t\tfprintf(stderr, \"expected recv(2) success, got %zi\\n\", ret);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tif (ret != -1) {\n\t\t\tfprintf(stderr, \"expected recv(2) failure, got %zi\\n\", ret);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (errno != EAGAIN) {\n\t\t\tfprintf(stderr, \"unexpected recv(2) errno %d\\n\", errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tcontrol_writeln(\"DONE\");\n\n\tclose(fd);\n}\n\nstatic void test_inv_buf_server(const struct test_opts *opts, bool stream)\n{\n\tunsigned char data[INV_BUF_TEST_DATA_LEN] = {0};\n\tssize_t res;\n\tint fd;\n\n\tif (stream)\n\t\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\telse\n\t\tfd = vsock_seqpacket_accept(VMADDR_CID_ANY, 1234, NULL);\n\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tres = send(fd, data, sizeof(data), 0);\n\tif (res != sizeof(data)) {\n\t\tfprintf(stderr, \"unexpected send(2) result %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"SENDDONE\");\n\n\tcontrol_expectln(\"DONE\");\n\n\tclose(fd);\n}\n\nstatic void test_stream_inv_buf_client(const struct test_opts *opts)\n{\n\ttest_inv_buf_client(opts, true);\n}\n\nstatic void test_stream_inv_buf_server(const struct test_opts *opts)\n{\n\ttest_inv_buf_server(opts, true);\n}\n\nstatic void test_seqpacket_inv_buf_client(const struct test_opts *opts)\n{\n\ttest_inv_buf_client(opts, false);\n}\n\nstatic void test_seqpacket_inv_buf_server(const struct test_opts *opts)\n{\n\ttest_inv_buf_server(opts, false);\n}\n\n#define HELLO_STR \"HELLO\"\n#define WORLD_STR \"WORLD\"\n\nstatic void test_stream_virtio_skb_merge_client(const struct test_opts *opts)\n{\n\tssize_t res;\n\tint fd;\n\n\tfd = vsock_stream_connect(opts->peer_cid, 1234);\n\tif (fd < 0) {\n\t\tperror(\"connect\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tres = send(fd, HELLO_STR, strlen(HELLO_STR), 0);\n\tif (res != strlen(HELLO_STR)) {\n\t\tfprintf(stderr, \"unexpected send(2) result %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"SEND0\");\n\t \n\tcontrol_expectln(\"REPLY0\");\n\n\t \n\tres = send(fd, WORLD_STR, strlen(WORLD_STR), 0);\n\tif (res != strlen(WORLD_STR)) {\n\t\tfprintf(stderr, \"unexpected send(2) result %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"SEND1\");\n\t \n\tcontrol_expectln(\"REPLY1\");\n\n\tclose(fd);\n}\n\nstatic void test_stream_virtio_skb_merge_server(const struct test_opts *opts)\n{\n\tunsigned char buf[64];\n\tssize_t res;\n\tint fd;\n\n\tfd = vsock_stream_accept(VMADDR_CID_ANY, 1234, NULL);\n\tif (fd < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_expectln(\"SEND0\");\n\n\t \n\tres = recv(fd, buf, 2, 0);\n\tif (res != 2) {\n\t\tfprintf(stderr, \"expected recv(2) returns 2 bytes, got %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"REPLY0\");\n\tcontrol_expectln(\"SEND1\");\n\n\tres = recv(fd, buf + 2, sizeof(buf) - 2, 0);\n\tif (res != 8) {\n\t\tfprintf(stderr, \"expected recv(2) returns 8 bytes, got %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tres = recv(fd, buf, sizeof(buf) - 8 - 2, MSG_DONTWAIT);\n\tif (res != -1) {\n\t\tfprintf(stderr, \"expected recv(2) failure, got %zi\\n\", res);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (memcmp(buf, HELLO_STR WORLD_STR, strlen(HELLO_STR WORLD_STR))) {\n\t\tfprintf(stderr, \"pattern mismatch\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcontrol_writeln(\"REPLY1\");\n\n\tclose(fd);\n}\n\nstatic void test_seqpacket_msg_peek_client(const struct test_opts *opts)\n{\n\treturn test_msg_peek_client(opts, true);\n}\n\nstatic void test_seqpacket_msg_peek_server(const struct test_opts *opts)\n{\n\treturn test_msg_peek_server(opts, true);\n}\n\nstatic struct test_case test_cases[] = {\n\t{\n\t\t.name = \"SOCK_STREAM connection reset\",\n\t\t.run_client = test_stream_connection_reset,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM bind only\",\n\t\t.run_client = test_stream_bind_only_client,\n\t\t.run_server = test_stream_bind_only_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM client close\",\n\t\t.run_client = test_stream_client_close_client,\n\t\t.run_server = test_stream_client_close_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM server close\",\n\t\t.run_client = test_stream_server_close_client,\n\t\t.run_server = test_stream_server_close_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM multiple connections\",\n\t\t.run_client = test_stream_multiconn_client,\n\t\t.run_server = test_stream_multiconn_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM MSG_PEEK\",\n\t\t.run_client = test_stream_msg_peek_client,\n\t\t.run_server = test_stream_msg_peek_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET msg bounds\",\n\t\t.run_client = test_seqpacket_msg_bounds_client,\n\t\t.run_server = test_seqpacket_msg_bounds_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET MSG_TRUNC flag\",\n\t\t.run_client = test_seqpacket_msg_trunc_client,\n\t\t.run_server = test_seqpacket_msg_trunc_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET timeout\",\n\t\t.run_client = test_seqpacket_timeout_client,\n\t\t.run_server = test_seqpacket_timeout_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET invalid receive buffer\",\n\t\t.run_client = test_seqpacket_invalid_rec_buffer_client,\n\t\t.run_server = test_seqpacket_invalid_rec_buffer_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM poll() + SO_RCVLOWAT\",\n\t\t.run_client = test_stream_poll_rcvlowat_client,\n\t\t.run_server = test_stream_poll_rcvlowat_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET big message\",\n\t\t.run_client = test_seqpacket_bigmsg_client,\n\t\t.run_server = test_seqpacket_bigmsg_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM test invalid buffer\",\n\t\t.run_client = test_stream_inv_buf_client,\n\t\t.run_server = test_stream_inv_buf_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET test invalid buffer\",\n\t\t.run_client = test_seqpacket_inv_buf_client,\n\t\t.run_server = test_seqpacket_inv_buf_server,\n\t},\n\t{\n\t\t.name = \"SOCK_STREAM virtio skb merge\",\n\t\t.run_client = test_stream_virtio_skb_merge_client,\n\t\t.run_server = test_stream_virtio_skb_merge_server,\n\t},\n\t{\n\t\t.name = \"SOCK_SEQPACKET MSG_PEEK\",\n\t\t.run_client = test_seqpacket_msg_peek_client,\n\t\t.run_server = test_seqpacket_msg_peek_server,\n\t},\n\t{},\n};\n\nstatic const char optstring[] = \"\";\nstatic const struct option longopts[] = {\n\t{\n\t\t.name = \"control-host\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'H',\n\t},\n\t{\n\t\t.name = \"control-port\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'P',\n\t},\n\t{\n\t\t.name = \"mode\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'm',\n\t},\n\t{\n\t\t.name = \"peer-cid\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'p',\n\t},\n\t{\n\t\t.name = \"list\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'l',\n\t},\n\t{\n\t\t.name = \"skip\",\n\t\t.has_arg = required_argument,\n\t\t.val = 's',\n\t},\n\t{\n\t\t.name = \"help\",\n\t\t.has_arg = no_argument,\n\t\t.val = '?',\n\t},\n\t{},\n};\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"Usage: vsock_test [--help] [--control-host=<host>] --control-port=<port> --mode=client|server --peer-cid=<cid> [--list] [--skip=<test_id>]\\n\"\n\t\t\"\\n\"\n\t\t\"  Server: vsock_test --control-port=1234 --mode=server --peer-cid=3\\n\"\n\t\t\"  Client: vsock_test --control-host=192.168.0.1 --control-port=1234 --mode=client --peer-cid=2\\n\"\n\t\t\"\\n\"\n\t\t\"Run vsock.ko tests.  Must be launched in both guest\\n\"\n\t\t\"and host.  One side must use --mode=client and\\n\"\n\t\t\"the other side must use --mode=server.\\n\"\n\t\t\"\\n\"\n\t\t\"A TCP control socket connection is used to coordinate tests\\n\"\n\t\t\"between the client and the server.  The server requires a\\n\"\n\t\t\"listen address and the client requires an address to\\n\"\n\t\t\"connect to.\\n\"\n\t\t\"\\n\"\n\t\t\"The CID of the other side must be given with --peer-cid=<cid>.\\n\"\n\t\t\"\\n\"\n\t\t\"Options:\\n\"\n\t\t\"  --help                 This help message\\n\"\n\t\t\"  --control-host <host>  Server IP address to connect to\\n\"\n\t\t\"  --control-port <port>  Server port to listen on/connect to\\n\"\n\t\t\"  --mode client|server   Server or client mode\\n\"\n\t\t\"  --peer-cid <cid>       CID of the other side\\n\"\n\t\t\"  --list                 List of tests that will be executed\\n\"\n\t\t\"  --skip <test_id>       Test ID to skip;\\n\"\n\t\t\"                         use multiple --skip options to skip more tests\\n\"\n\t\t);\n\texit(EXIT_FAILURE);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *control_host = NULL;\n\tconst char *control_port = NULL;\n\tstruct test_opts opts = {\n\t\t.mode = TEST_MODE_UNSET,\n\t\t.peer_cid = VMADDR_CID_ANY,\n\t};\n\n\tsrand(time(NULL));\n\tinit_signals();\n\n\tfor (;;) {\n\t\tint opt = getopt_long(argc, argv, optstring, longopts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'H':\n\t\t\tcontrol_host = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcmp(optarg, \"client\") == 0)\n\t\t\t\topts.mode = TEST_MODE_CLIENT;\n\t\t\telse if (strcmp(optarg, \"server\") == 0)\n\t\t\t\topts.mode = TEST_MODE_SERVER;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"--mode must be \\\"client\\\" or \\\"server\\\"\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topts.peer_cid = parse_cid(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol_port = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_tests(test_cases);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tskip_test(test_cases, ARRAY_SIZE(test_cases) - 1,\n\t\t\t\t  optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (!control_port)\n\t\tusage();\n\tif (opts.mode == TEST_MODE_UNSET)\n\t\tusage();\n\tif (opts.peer_cid == VMADDR_CID_ANY)\n\t\tusage();\n\n\tif (!control_host) {\n\t\tif (opts.mode != TEST_MODE_SERVER)\n\t\t\tusage();\n\t\tcontrol_host = \"0.0.0.0\";\n\t}\n\n\tcontrol_init(control_host, control_port,\n\t\t     opts.mode == TEST_MODE_SERVER);\n\n\trun_tests(test_cases, &opts);\n\n\tcontrol_cleanup();\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}