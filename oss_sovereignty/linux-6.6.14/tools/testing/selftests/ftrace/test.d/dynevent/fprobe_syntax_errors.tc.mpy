{
  "module_name": "fprobe_syntax_errors.tc",
  "hash_id": "31ce1e3f85a838ff4a65df2cc19c0c047b625e794c50130698fe647cdad57f23",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/dynevent/fprobe_syntax_errors.tc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# description: Fprobe event parser error log check\n# requires: dynamic_events \"f[:[<group>/][<event>]] <func-name>[%return] [<args>]\":README\n\ncheck_error() { # command-with-error-pos-by-^\n    ftrace_errlog_check 'trace_fprobe' \"$1\" 'dynamic_events'\n}\n\ncase `uname -m` in\nx86_64|i[3456]86)\n  REG=%ax ;;\naarch64)\n  REG=%x0 ;;\n*)\n  REG=%r0 ;;\nesac\n\ncheck_error 'f^100 vfs_read'\t\t# MAXACT_NO_KPROBE\ncheck_error 'f^1a111 vfs_read'\t\t# BAD_MAXACT\ncheck_error 'f^100000 vfs_read'\t\t# MAXACT_TOO_BIG\n\ncheck_error 'f ^non_exist_func'\t\t# BAD_PROBE_ADDR (enoent)\ncheck_error 'f ^vfs_read+10'\t\t# BAD_PROBE_ADDR\ncheck_error 'f:^/bar vfs_read'\t\t# NO_GROUP_NAME\ncheck_error 'f:^12345678901234567890123456789012345678901234567890123456789012345/bar vfs_read'\t# GROUP_TOO_LONG\n\ncheck_error 'f:^foo.1/bar vfs_read'\t# BAD_GROUP_NAME\ncheck_error 'f:^ vfs_read'\t\t# NO_EVENT_NAME\ncheck_error 'f:foo/^12345678901234567890123456789012345678901234567890123456789012345 vfs_read'\t# EVENT_TOO_LONG\ncheck_error 'f:foo/^bar.1 vfs_read'\t# BAD_EVENT_NAME\n\ncheck_error 'f vfs_read ^$stack10000'\t# BAD_STACK_NUM\n\ncheck_error 'f vfs_read ^$arg10000'\t# BAD_ARG_NUM\n\ncheck_error 'f vfs_read $retval ^$arg1' # BAD_VAR\ncheck_error 'f vfs_read ^$none_var'\t# BAD_VAR\ncheck_error 'f vfs_read ^'$REG\t\t# BAD_VAR\n\ncheck_error 'f vfs_read ^@12345678abcde'\t# BAD_MEM_ADDR\ncheck_error 'f vfs_read ^@+10'\t\t# FILE_ON_KPROBE\n\ngrep -q \"imm-value\" README && \\\ncheck_error 'f vfs_read arg1=\\^x'\t# BAD_IMM\ngrep -q \"imm-string\" README && \\\ncheck_error 'f vfs_read arg1=\\\"abcd^'\t# IMMSTR_NO_CLOSE\n\ncheck_error 'f vfs_read ^+0@0)'\t\t# DEREF_NEED_BRACE\ncheck_error 'f vfs_read ^+0ab1(@0)'\t# BAD_DEREF_OFFS\ncheck_error 'f vfs_read +0(+0(@0^)'\t# DEREF_OPEN_BRACE\n\nif grep -A1 \"fetcharg:\" README | grep -q '\\$comm' ; then\ncheck_error 'f vfs_read +0(^$comm)'\t# COMM_CANT_DEREF\nfi\n\ncheck_error 'f vfs_read ^&1'\t\t# BAD_FETCH_ARG\n\n\n# We've introduced this limitation with array support\nif grep -q ' <type>\\\\\\[<array-size>\\\\\\]' README; then\ncheck_error 'f vfs_read +0(^+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(@0))))))))))))))'\t# TOO_MANY_OPS?\ncheck_error 'f vfs_read +0(@11):u8[10^'\t\t# ARRAY_NO_CLOSE\ncheck_error 'f vfs_read +0(@11):u8[10]^a'\t# BAD_ARRAY_SUFFIX\ncheck_error 'f vfs_read +0(@11):u8[^10a]'\t# BAD_ARRAY_NUM\ncheck_error 'f vfs_read +0(@11):u8[^256]'\t# ARRAY_TOO_BIG\nfi\n\ncheck_error 'f vfs_read @11:^unknown_type'\t# BAD_TYPE\ncheck_error 'f vfs_read $stack0:^string'\t# BAD_STRING\ncheck_error 'f vfs_read @11:^b10@a/16'\t\t# BAD_BITFIELD\n\ncheck_error 'f vfs_read ^arg123456789012345678901234567890=@11'\t# ARG_NAME_TOO_LOG\ncheck_error 'f vfs_read ^=@11'\t\t\t# NO_ARG_NAME\ncheck_error 'f vfs_read ^var.1=@11'\t\t# BAD_ARG_NAME\ncheck_error 'f vfs_read var1=@11 ^var1=@12'\t# USED_ARG_NAME\ncheck_error 'f vfs_read ^+1234567(+1234567(+1234567(+1234567(+1234567(+1234567(@1234))))))'\t# ARG_TOO_LONG\ncheck_error 'f vfs_read arg1=^'\t\t\t# NO_ARG_BODY\n\n\n# multiprobe errors\nif grep -q \"Create/append/\" README && grep -q \"imm-value\" README; then\necho \"f:fprobes/testevent $FUNCTION_FORK\" > dynamic_events\ncheck_error '^f:fprobes/testevent do_exit%return'\t# DIFF_PROBE_TYPE\n\n# Explicitly use printf \"%s\" to not interpret \\1\nprintf \"%s\" \"f:fprobes/testevent $FUNCTION_FORK abcd=\\\\1\" > dynamic_events\ncheck_error \"f:fprobes/testevent $FUNCTION_FORK ^bcd=\\\\1\"\t# DIFF_ARG_TYPE\ncheck_error \"f:fprobes/testevent $FUNCTION_FORK ^abcd=\\\\1:u8\"\t# DIFF_ARG_TYPE\ncheck_error \"f:fprobes/testevent $FUNCTION_FORK ^abcd=\\\\\\\"foo\\\"\" # DIFF_ARG_TYPE\ncheck_error \"^f:fprobes/testevent $FUNCTION_FORK abcd=\\\\1\"\t# SAME_PROBE\nfi\n\n# %return suffix errors\ncheck_error 'f vfs_read^%hoge'\t\t# BAD_ADDR_SUFFIX\n\n# BTF arguments errors\nif grep -q \"<argname>\" README; then\ncheck_error 'f vfs_read args=^$arg*'\t\t# BAD_VAR_ARGS\ncheck_error 'f vfs_read +0(^$arg*)'\t\t# BAD_VAR_ARGS\ncheck_error 'f vfs_read $arg* ^$arg*'\t\t# DOUBLE_ARGS\ncheck_error 'f vfs_read%return ^$arg*'\t\t# NOFENTRY_ARGS\ncheck_error 'f vfs_read ^hoge'\t\t\t# NO_BTFARG\ncheck_error 'f kfree ^$arg10'\t\t\t# NO_BTFARG (exceed the number of parameters)\ncheck_error 'f kfree%return ^$retval'\t\t# NO_RETVAL\n\nif grep -qF \"<argname>[->field[->field|.field...]]\" README ; then\ncheck_error 'f vfs_read%return $retval->^foo'\t# NO_PTR_STRCT\ncheck_error 'f vfs_read file->^foo'\t\t# NO_BTF_FIELD\ncheck_error 'f vfs_read file^-.foo'\t\t# BAD_HYPHEN\ncheck_error 'f vfs_read ^file:string'\t\t# BAD_TYPE4STR\nfi\n\nelse\ncheck_error 'f vfs_read ^$arg*'\t\t\t# NOSUP_BTFARG\ncheck_error 't kfree ^$arg*'\t\t\t# NOSUP_BTFARG\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}