{
  "module_name": "tprobe_syntax_errors.tc",
  "hash_id": "ef39853ad225d6a8f5e448b0488dd7db8a6825a4f11564f4a76aa74eff8036ea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/dynevent/tprobe_syntax_errors.tc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# description: Tracepoint probe event parser error log check\n# requires: dynamic_events \"t[:[<group>/][<event>]] <tracepoint> [<args>]\":README\n\ncheck_error() { # command-with-error-pos-by-^\n    ftrace_errlog_check 'trace_fprobe' \"$1\" 'dynamic_events'\n}\n\ncheck_error 't^100 kfree'\t\t# BAD_MAXACT_TYPE\n\ncheck_error 't ^non_exist_tracepoint'\t# NO_TRACEPOINT\ncheck_error 't:^/bar kfree'\t\t# NO_GROUP_NAME\ncheck_error 't:^12345678901234567890123456789012345678901234567890123456789012345/bar kfree'\t# GROUP_TOO_LONG\n\ncheck_error 't:^foo.1/bar kfree'\t# BAD_GROUP_NAME\ncheck_error 't:^ kfree'\t\t\t# NO_EVENT_NAME\ncheck_error 't:foo/^12345678901234567890123456789012345678901234567890123456789012345 kfree'\t# EVENT_TOO_LONG\ncheck_error 't:foo/^bar.1 kfree'\t# BAD_EVENT_NAME\n\ncheck_error 't kfree ^$retval'\t\t# RETVAL_ON_PROBE\ncheck_error 't kfree ^$stack10000'\t# BAD_STACK_NUM\n\ncheck_error 't kfree ^$arg10000'\t# BAD_ARG_NUM\n\ncheck_error 't kfree ^$none_var'\t# BAD_VAR\ncheck_error 't kfree ^%rax'\t\t# BAD_VAR\n\ncheck_error 't kfree ^@12345678abcde'\t# BAD_MEM_ADDR\ncheck_error 't kfree ^@+10'\t\t# FILE_ON_KPROBE\n\ngrep -q \"imm-value\" README && \\\ncheck_error 't kfree arg1=\\^x'\t# BAD_IMM\ngrep -q \"imm-string\" README && \\\ncheck_error 't kfree arg1=\\\"abcd^'\t# IMMSTR_NO_CLOSE\n\ncheck_error 't kfree ^+0@0)'\t\t# DEREF_NEED_BRACE\ncheck_error 't kfree ^+0ab1(@0)'\t# BAD_DEREF_OFFS\ncheck_error 't kfree +0(+0(@0^)'\t# DEREF_OPEN_BRACE\n\nif grep -A1 \"fetcharg:\" README | grep -q '\\$comm' ; then\ncheck_error 't kfree +0(^$comm)'\t# COMM_CANT_DEREF\nfi\n\ncheck_error 't kfree ^&1'\t\t# BAD_FETCH_ARG\n\n\n# We've introduced this limitation with array support\nif grep -q ' <type>\\\\\\[<array-size>\\\\\\]' README; then\ncheck_error 't kfree +0(^+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(@0))))))))))))))'\t# TOO_MANY_OPS?\ncheck_error 't kfree +0(@11):u8[10^'\t\t# ARRAY_NO_CLOSE\ncheck_error 't kfree +0(@11):u8[10]^a'\t\t# BAD_ARRAY_SUFFIX\ncheck_error 't kfree +0(@11):u8[^10a]'\t\t# BAD_ARRAY_NUM\ncheck_error 't kfree +0(@11):u8[^256]'\t\t# ARRAY_TOO_BIG\nfi\n\ncheck_error 't kfree @11:^unknown_type'\t\t# BAD_TYPE\ncheck_error 't kfree $stack0:^string'\t\t# BAD_STRING\ncheck_error 't kfree @11:^b10@a/16'\t\t# BAD_BITFIELD\n\ncheck_error 't kfree ^arg123456789012345678901234567890=@11'\t# ARG_NAME_TOO_LOG\ncheck_error 't kfree ^=@11'\t\t\t# NO_ARG_NAME\ncheck_error 't kfree ^var.1=@11'\t\t# BAD_ARG_NAME\ncheck_error 't kfree var1=@11 ^var1=@12'\t# USED_ARG_NAME\ncheck_error 't kfree ^+1234567(+1234567(+1234567(+1234567(+1234567(+1234567(@1234))))))'\t# ARG_TOO_LONG\ncheck_error 't kfree arg1=^'\t\t\t# NO_ARG_BODY\n\n\n# multiprobe errors\nif grep -q \"Create/append/\" README && grep -q \"imm-value\" README; then\necho \"t:tracepoint/testevent kfree\" > dynamic_events\ncheck_error '^f:tracepoint/testevent kfree'\t# DIFF_PROBE_TYPE\n\n# Explicitly use printf \"%s\" to not interpret \\1\nprintf \"%s\" \"t:tracepoints/testevent kfree abcd=\\\\1\" > dynamic_events\ncheck_error \"t:tracepoints/testevent kfree ^bcd=\\\\1\"\t# DIFF_ARG_TYPE\ncheck_error \"t:tracepoints/testevent kfree ^abcd=\\\\1:u8\"\t# DIFF_ARG_TYPE\ncheck_error \"t:tracepoints/testevent kfree ^abcd=\\\\\\\"foo\\\"\" # DIFF_ARG_TYPE\ncheck_error \"^t:tracepoints/testevent kfree abcd=\\\\1\"\t# SAME_PROBE\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}