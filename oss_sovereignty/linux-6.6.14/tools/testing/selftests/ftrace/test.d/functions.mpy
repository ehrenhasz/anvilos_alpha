{
  "module_name": "functions",
  "hash_id": "bcc39117dd54a9795f157711ab20bc603aae7d8fb33001a39244adb61fec43bd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/functions",
  "human_readable_source": "clear_trace() { # reset trace output\n    echo > trace\n}\n\ndisable_tracing() { # stop trace recording\n    echo 0 > tracing_on\n}\n\nenable_tracing() { # start trace recording\n    echo 1 > tracing_on\n}\n\nreset_tracer() { # reset the current tracer\n    echo nop > current_tracer\n}\n\nreset_trigger_file() {\n    # remove action triggers first\n    grep -H ':on[^:]*(' $@ |\n    while read line; do\n        cmd=`echo $line | cut -f2- -d: | cut -f1 -d\"[\"`\n\tfile=`echo $line | cut -f1 -d:`\n\techo \"!$cmd\" >> $file\n    done\n    grep -Hv ^# $@ |\n    while read line; do\n        cmd=`echo $line | cut -f2- -d: | cut -f1 -d\"[\"`\n\tfile=`echo $line | cut -f1 -d:`\n\techo \"!$cmd\" > $file\n    done\n}\n\nreset_trigger() { # reset all current setting triggers\n    if [ -d events/synthetic ]; then\n        reset_trigger_file events/synthetic/*/trigger\n    fi\n    reset_trigger_file events/*/*/trigger\n}\n\nreset_events_filter() { # reset all current setting filters\n    grep -v ^none events/*/*/filter |\n    while read line; do\n\techo 0 > `echo $line | cut -f1 -d:`\n    done\n}\n\nreset_ftrace_filter() { # reset all triggers in set_ftrace_filter\n    if [ ! -f set_ftrace_filter ]; then\n      return 0\n    fi\n    echo > set_ftrace_filter\n    grep -v '^#' set_ftrace_filter | while read t; do\n\ttr=`echo $t | cut -d: -f2`\n\tif [ \"$tr\" = \"\" ]; then\n\t    continue\n\tfi\n\tif ! grep -q \"$t\" set_ftrace_filter; then\n\t\tcontinue;\n\tfi\n\tname=`echo $t | cut -d: -f1 | cut -d' ' -f1`\n\tif [ $tr = \"enable_event\" -o $tr = \"disable_event\" ]; then\n\t    tr=`echo $t | cut -d: -f2-4`\n\t    limit=`echo $t | cut -d: -f5`\n\telse\n\t    tr=`echo $t | cut -d: -f2`\n\t    limit=`echo $t | cut -d: -f3`\n\tfi\n\tif [ \"$limit\" != \"unlimited\" ]; then\n\t    tr=\"$tr:$limit\"\n\tfi\n\techo \"!$name:$tr\" > set_ftrace_filter\n    done\n}\n\ndisable_events() {\n    echo 0 > events/enable\n}\n\nclear_synthetic_events() { # reset all current synthetic events\n    grep -v ^# synthetic_events |\n    while read line; do\n        echo \"!$line\" >> synthetic_events\n    done\n}\n\nclear_dynamic_events() { # reset all current dynamic events\n    again=1\n    stop=1\n    # loop mulitple times as some events require other to be removed first\n    while [ $again -eq 1 ]; do\n\tstop=$((stop+1))\n\t# Prevent infinite loops\n\tif [ $stop -gt 10 ]; then\n\t    break;\n\tfi\n\tagain=2\n\tgrep -v '^#' dynamic_events|\n\twhile read line; do\n\t    del=`echo $line | sed -e 's/^.\\([^ ]*\\).*/-\\1/'`\n\t    if ! echo \"$del\" >> dynamic_events; then\n\t\tagain=1\n\t    fi\n\tdone\n    done\n}\n\ninitialize_ftrace() { # Reset ftrace to initial-state\n# As the initial state, ftrace will be set to nop tracer,\n# no events, no triggers, no filters, no function filters,\n# no probes, and tracing on.\n    disable_tracing\n    reset_tracer\n    reset_trigger\n    reset_events_filter\n    reset_ftrace_filter\n    disable_events\n    clear_dynamic_events\n    [ -f set_event_pid ] && echo > set_event_pid\n    [ -f set_ftrace_pid ] && echo > set_ftrace_pid\n    [ -f set_ftrace_notrace ] && echo > set_ftrace_notrace\n    [ -f set_graph_function ] && echo | tee set_graph_*\n    [ -f stack_trace_filter ] && echo > stack_trace_filter\n    [ -f kprobe_events ] && echo > kprobe_events\n    [ -f uprobe_events ] && echo > uprobe_events\n    [ -f synthetic_events ] && echo > synthetic_events\n    [ -f snapshot ] && echo 0 > snapshot\n\n# Stop tracing while reading the trace file by default, to prevent\n# the test results while checking it and to avoid taking a long time\n# to check the result.\n    [ -f options/pause-on-trace ] && echo 1 > options/pause-on-trace\n\n    clear_trace\n    enable_tracing\n}\n\nfinish_ftrace() {\n    initialize_ftrace\n# And recover it to default.\n    [ -f options/pause-on-trace ] && echo 0 > options/pause-on-trace\n}\n\ncheck_requires() { # Check required files and tracers\n    for i in \"$@\" ; do\n\tp=${i%:program}\n        r=${i%:README}\n        t=${i%:tracer}\n\tif [ $p != $i ]; then\n\t    if ! which $p ; then\n                echo \"Required program $p is not found.\"\n                exit_unresolved\n\t    fi\n        elif [ $t != $i ]; then\n            if ! grep -wq $t available_tracers ; then\n                echo \"Required tracer $t is not configured.\"\n                exit_unsupported\n            fi\n        elif [ \"$r\" != \"$i\" ]; then\n            if ! grep -Fq \"$r\" README ; then\n                echo \"Required feature pattern \\\"$r\\\" is not in README.\"\n                exit_unsupported\n            fi\n        elif [ ! -e $i ]; then\n            echo \"Required feature interface $i doesn't exist.\"\n            exit_unsupported\n        fi\n    done\n}\n\nLOCALHOST=127.0.0.1\n\nyield() {\n    ping $LOCALHOST -c 1 || sleep .001 || usleep 1 || sleep 1\n}\n\n# The fork function in the kernel was renamed from \"_do_fork\" to\n# \"kernel_fork\". As older tests should still work with older kernels\n# as well as newer kernels, check which version of fork is used on this\n# kernel so that the tests can use the fork function for the running kernel.\nFUNCTION_FORK=`(if grep '\\bkernel_clone\\b' /proc/kallsyms > /dev/null; then\n                echo kernel_clone; else echo '_do_fork'; fi)`\n\n# Since probe event command may include backslash, explicitly use printf \"%s\"\n# to NOT interpret it.\nftrace_errlog_check() { # err-prefix command-with-error-pos-by-^ command-file\n    pos=$(printf \"%s\" \"${2%^*}\" | wc -c) # error position\n    command=$(printf \"%s\" \"$2\" | tr -d ^)\n    echo \"Test command: $command\"\n    echo > error_log\n    (! printf \"%s\" \"$command\" >> \"$3\" ) 2> /dev/null\n    grep \"$1: error:\" -A 3 error_log\n    N=$(tail -n 1 error_log | wc -c)\n    # \"  Command: \" and \"^\\n\" => 13\n    test $(expr 13 + $pos) -eq $N\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}