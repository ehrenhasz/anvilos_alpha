{
  "module_name": "kprobe_syntax_errors.tc",
  "hash_id": "1c156bd75739d65a047b235a9896e7f629791ce559d615c7ba6e8e9a4bc1e334",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/kprobe/kprobe_syntax_errors.tc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# description: Kprobe event parser error log check\n# requires: kprobe_events error_log\n\ncheck_error() { # command-with-error-pos-by-^\n    ftrace_errlog_check 'trace_kprobe' \"$1\" 'kprobe_events'\n}\n\nif grep -q 'r\\[maxactive\\]' README; then\ncheck_error 'p^100 vfs_read'\t\t# BAD_MAXACT_TYPE\ncheck_error 'r^1a111 vfs_read'\t\t# BAD_MAXACT\ncheck_error 'r^100000 vfs_read'\t\t# MAXACT_TOO_BIG\nfi\n\ncheck_error 'p ^non_exist_func'\t\t# BAD_PROBE_ADDR (enoent)\ncheck_error 'p ^hoge-fuga'\t\t# BAD_PROBE_ADDR (bad syntax)\ncheck_error 'p ^hoge+1000-1000'\t\t# BAD_PROBE_ADDR (bad syntax)\ncheck_error 'r ^vfs_read+10'\t\t# BAD_RETPROBE\ncheck_error 'p:^/bar vfs_read'\t\t# NO_GROUP_NAME\ncheck_error 'p:^12345678901234567890123456789012345678901234567890123456789012345/bar vfs_read'\t# GROUP_TOO_LONG\n\ncheck_error 'p:^foo.1/bar vfs_read'\t# BAD_GROUP_NAME\ncheck_error 'p:^ vfs_read'\t\t# NO_EVENT_NAME\ncheck_error 'p:foo/^12345678901234567890123456789012345678901234567890123456789012345 vfs_read'\t# EVENT_TOO_LONG\ncheck_error 'p:foo/^bar.1 vfs_read'\t# BAD_EVENT_NAME\n\ncheck_error 'p vfs_read ^$retval'\t# RETVAL_ON_PROBE\ncheck_error 'p vfs_read ^$stack10000'\t# BAD_STACK_NUM\n\nif grep -q '$arg<N>' README; then\ncheck_error 'p vfs_read ^$arg10000'\t# BAD_ARG_NUM\nfi\n\ncheck_error 'p vfs_read ^$none_var'\t# BAD_VAR\n\ncheck_error 'p vfs_read ^%none_reg'\t# BAD_REG_NAME\ncheck_error 'p vfs_read ^@12345678abcde'\t# BAD_MEM_ADDR\ncheck_error 'p vfs_read ^@+10'\t\t# FILE_ON_KPROBE\n\ngrep -q \"imm-value\" README && \\\ncheck_error 'p vfs_read arg1=\\^x'\t# BAD_IMM\ngrep -q \"imm-string\" README && \\\ncheck_error 'p vfs_read arg1=\\\"abcd^'\t# IMMSTR_NO_CLOSE\n\ncheck_error 'p vfs_read ^+0@0)'\t\t# DEREF_NEED_BRACE\ncheck_error 'p vfs_read ^+0ab1(@0)'\t# BAD_DEREF_OFFS\ncheck_error 'p vfs_read +0(+0(@0^)'\t# DEREF_OPEN_BRACE\n\nif grep -A1 \"fetcharg:\" README | grep -q '\\$comm' ; then\ncheck_error 'p vfs_read +0(^$comm)'\t# COMM_CANT_DEREF\nfi\n\ncheck_error 'p vfs_read ^&1'\t\t# BAD_FETCH_ARG\n\n\n# We've introduced this limitation with array support\nif grep -q ' <type>\\\\\\[<array-size>\\\\\\]' README; then\ncheck_error 'p vfs_read +0(^+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(@0))))))))))))))'\t# TOO_MANY_OPS?\ncheck_error 'p vfs_read +0(@11):u8[10^'\t\t# ARRAY_NO_CLOSE\ncheck_error 'p vfs_read +0(@11):u8[10]^a'\t# BAD_ARRAY_SUFFIX\ncheck_error 'p vfs_read +0(@11):u8[^10a]'\t# BAD_ARRAY_NUM\ncheck_error 'p vfs_read +0(@11):u8[^256]'\t# ARRAY_TOO_BIG\nfi\n\ncheck_error 'p vfs_read @11:^unknown_type'\t# BAD_TYPE\ncheck_error 'p vfs_read $stack0:^string'\t# BAD_STRING\ncheck_error 'p vfs_read @11:^b10@a/16'\t\t# BAD_BITFIELD\n\ncheck_error 'p vfs_read ^arg123456789012345678901234567890=@11'\t# ARG_NAME_TOO_LOG\ncheck_error 'p vfs_read ^=@11'\t\t\t# NO_ARG_NAME\ncheck_error 'p vfs_read ^var.1=@11'\t\t# BAD_ARG_NAME\ncheck_error 'p vfs_read var1=@11 ^var1=@12'\t# USED_ARG_NAME\ncheck_error 'p vfs_read ^+1234567(+1234567(+1234567(+1234567(+1234567(+1234567(@1234))))))'\t# ARG_TOO_LONG\ncheck_error 'p vfs_read arg1=^'\t\t\t# NO_ARG_BODY\n\n# instruction boundary check is valid on x86 (at this moment)\ncase $(uname -m) in\n  x86_64|i[3456]86)\n    echo 'p vfs_read' > kprobe_events\n    if grep -q FTRACE ../kprobes/list ; then\n\tcheck_error 'p ^vfs_read+3'\t\t# BAD_INSN_BNDRY (only if function-tracer is enabled)\n    fi\n    ;;\nesac\n\n# multiprobe errors\nif grep -q \"Create/append/\" README && grep -q \"imm-value\" README; then\necho \"p:kprobes/testevent $FUNCTION_FORK\" > kprobe_events\ncheck_error '^r:kprobes/testevent do_exit'\t# DIFF_PROBE_TYPE\n\n# Explicitly use printf \"%s\" to not interpret \\1\nprintf \"%s\" \"p:kprobes/testevent $FUNCTION_FORK abcd=\\\\1\" > kprobe_events\ncheck_error \"p:kprobes/testevent $FUNCTION_FORK ^bcd=\\\\1\"\t# DIFF_ARG_TYPE\ncheck_error \"p:kprobes/testevent $FUNCTION_FORK ^abcd=\\\\1:u8\"\t# DIFF_ARG_TYPE\ncheck_error \"p:kprobes/testevent $FUNCTION_FORK ^abcd=\\\\\\\"foo\\\"\" # DIFF_ARG_TYPE\ncheck_error \"^p:kprobes/testevent $FUNCTION_FORK abcd=\\\\1\"\t# SAME_PROBE\nfi\n\n# %return suffix errors\nif grep -q \"place (kretprobe): .*%return.*\" README; then\ncheck_error 'p vfs_read^%hoge'\t\t# BAD_ADDR_SUFFIX\ncheck_error 'p ^vfs_read+10%return'\t# BAD_RETPROBE\nfi\n\n# BTF arguments errors\nif grep -q \"<argname>\" README; then\ncheck_error 'p vfs_read args=^$arg*'\t\t# BAD_VAR_ARGS\ncheck_error 'p vfs_read +0(^$arg*)'\t\t# BAD_VAR_ARGS\ncheck_error 'p vfs_read $arg* ^$arg*'\t\t# DOUBLE_ARGS\ncheck_error 'r vfs_read ^$arg*'\t\t\t# NOFENTRY_ARGS\ncheck_error 'p vfs_read+8 ^$arg*'\t\t# NOFENTRY_ARGS\ncheck_error 'p vfs_read ^hoge'\t\t\t# NO_BTFARG\ncheck_error 'p kfree ^$arg10'\t\t\t# NO_BTFARG (exceed the number of parameters)\ncheck_error 'r kfree ^$retval'\t\t\t# NO_RETVAL\nelse\ncheck_error 'p vfs_read ^$arg*'\t\t\t# NOSUP_BTFARG\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}