{
  "module_name": "func_traceonoff_triggers.tc",
  "hash_id": "0f988b6ab93a51547caaa68cd4aae9158dbbe13b5fbc3ae4bc63993348243307",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/ftrace/func_traceonoff_triggers.tc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# description: ftrace - test for function traceon/off triggers\n# flags: instance\n#\n# The triggers are set within the set_ftrace_filter file\n# requires: set_ftrace_filter\n#\n# Ftrace allows to add triggers to functions, such as enabling or disabling\n# tracing, enabling or disabling trace events, or recording a stack trace\n# within the ring buffer.\n#\n# This test is designed to test enabling and disabling tracing triggers\n#\n\nfail() { # mesg\n    echo $1\n    exit_fail\n}\n\nSLEEP_TIME=\".1\"\n\necho \"Testing function probes with enabling disabling tracing:\"\n\ncnt_trace() {\n    grep -v '^#' trace | wc -l\n}\n\necho '** DISABLE TRACING'\ndisable_tracing\nclear_trace\n\ncnt=`cnt_trace`\nif [ $cnt -ne 0 ]; then\n    fail \"Found junk in trace\"\nfi\n\n\necho '** ENABLE EVENTS'\n\necho 1 > events/sched/enable\n\necho '** ENABLE TRACING'\nenable_tracing\n\ncnt=`cnt_trace`\nif [ $cnt -eq 0 ]; then\n   fail \"Nothing found in trace\"\nfi\n\n# powerpc uses .schedule\nfunc=\"schedule\"\navailable_file=available_filter_functions\nif [ -d ../../instances -a -f ../../available_filter_functions ]; then\n   available_file=../../available_filter_functions\nfi\nx=`grep '^\\.schedule$' available_filter_functions | wc -l`\nif [ \"$x\" -eq 1 ]; then\n   func=\".schedule\"\nfi\n\necho '** SET TRACEOFF'\n\necho \"$func:traceoff\" > set_ftrace_filter\nif [ -d ../../instances ]; then # Check instances\n    cur=`cat set_ftrace_filter`\n    top=`cat ../../set_ftrace_filter`\n    if [ \"$cur\" = \"$top\" ]; then\n\techo \"This kernel is too old to support per instance filter\"\n\treset_ftrace_filter\n\texit_unsupported\n    fi\nfi\n\ncnt=`grep schedule set_ftrace_filter | wc -l`\nif [ $cnt -ne 1 ]; then\n   fail \"Did not find traceoff trigger\"\nfi\n\ncnt=`cnt_trace`\nsleep $SLEEP_TIME\ncnt2=`cnt_trace`\n\nif [ $cnt -ne $cnt2 ]; then\n   fail \"Tracing is not stopped\"\nfi\n\non=`cat tracing_on`\nif [ $on != \"0\" ]; then\n    fail \"Tracing is not off\"\nfi\n\ncsum1=`md5sum trace`\nsleep $SLEEP_TIME\ncsum2=`md5sum trace`\n\nif [ \"$csum1\" != \"$csum2\" ]; then\n    fail \"Tracing file is still changing\"\nfi\n\nclear_trace\n\ncnt=`cnt_trace`\nif [ $cnt -ne 0 ]; then\n    fail \"Tracing is still happeing\"\nfi\n\necho \"!$func:traceoff\" >> set_ftrace_filter\n\ncnt=`grep schedule set_ftrace_filter | wc -l`\nif [ $cnt -ne 0 ]; then\n    fail \"traceoff trigger still exists\"\nfi\n\non=`cat tracing_on`\nif [ $on != \"0\" ]; then\n    fail \"Tracing is started again\"\nfi\n\necho \"$func:traceon\" > set_ftrace_filter\n\ncnt=`grep schedule set_ftrace_filter | wc -l`\nif [ $cnt -ne 1 ]; then\n    fail \"traceon trigger not found\"\nfi\n\ncnt=`cnt_trace`\nif [ $cnt -eq 0 ]; then\n   fail \"Tracing did not start\"\nfi\n\non=`cat tracing_on`\nif [ $on != \"1\" ]; then\n    fail \"Tracing was not enabled\"\nfi\n\n\necho \"!$func:traceon\" >> set_ftrace_filter\n\ncnt=`grep schedule set_ftrace_filter | wc -l`\nif [ $cnt -ne 0 ]; then\n   fail \"traceon trigger still exists\"\nfi\n\ncheck_sleep() {\n    val=$1\n    sleep $SLEEP_TIME\n    cat set_ftrace_filter\n    on=`cat tracing_on`\n    if [ $on != \"$val\" ]; then\n\tfail \"Expected tracing_on to be $val, but it was $on\"\n    fi\n}\n\n\necho \"$func:traceoff:3\" > set_ftrace_filter\ncheck_sleep \"0\"\necho 1 > tracing_on\ncheck_sleep \"0\"\necho 1 > tracing_on\ncheck_sleep \"0\"\necho 1 > tracing_on\ncheck_sleep \"1\"\necho \"!$func:traceoff:0\" > set_ftrace_filter\n\nif grep -e traceon -e traceoff set_ftrace_filter; then\n    fail \"Tracing on and off triggers still exist\"\nfi\n\ndisable_events\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}