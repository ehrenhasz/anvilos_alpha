{
  "module_name": "func_set_ftrace_file.tc",
  "hash_id": "fc656f974716575a18b6cf961453cebe32f7f081642460a627e3f3aa32dce129",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ftrace/test.d/ftrace/func_set_ftrace_file.tc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# description: ftrace - test reading of set_ftrace_filter\n#\n# The triggers are set within the set_ftrace_filter file\n# requires: set_ftrace_filter\n#\n# The set_ftrace_filter file of ftrace is used to list functions as well as\n# triggers (probes) attached to functions. The code to read this file is not\n# straight forward and has had various bugs in the past. This test is designed\n# to add functions and triggers to that file in various ways and read that\n# file in various ways (cat vs dd).\n#\n\nfail() { # mesg\n    echo $1\n    exit_fail\n}\n\nFILTER=set_ftrace_filter\nFUNC1=\"schedule\"\nFUNC2=\"scheduler_tick\"\n\nALL_FUNCS=\"#### all functions enabled ####\"\n\ntest_func() {\n    if ! echo \"$1\" | grep -q \"^$2\\$\"; then\n\treturn 0\n    fi\n    echo \"$1\" | grep -v \"^$2\\$\"\n    return 1\n}\n\ncheck_set_ftrace_filter() {\n    cat=`cat $FILTER`\n    dd1=`dd if=$FILTER bs=1 | grep -v -e 'records in' -e 'records out' -e 'bytes copied'`\n    dd100=`dd if=$FILTER bs=100 | grep -v -e 'records in' -e 'records out' -e 'bytes copied'`\n\n    echo \"Testing '$@'\"\n\n    while [ $# -gt 0 ]; do\n\techo \"test $1\"\n\tif cat=`test_func \"$cat\" \"$1\"`; then\n\t    return 0\n\tfi\n\tif dd1=`test_func \"$dd1\" \"$1\"`; then\n\t    return 0\n\tfi\n\tif dd100=`test_func \"$dd100\" \"$1\"`; then\n\t    return 0\n\tfi\n\tshift\n    done\n\n    if [ -n \"$cat\" ]; then\n\treturn 0\n    fi\n    if [ -n \"$dd1\" ]; then\n\treturn 0\n    fi\n    if [ -n \"$dd100\" ]; then\n\treturn 0\n    fi\n    return 1;\n}\n\nif check_set_ftrace_filter \"$ALL_FUNCS\"; then\n    fail \"Expected only $ALL_FUNCS\"\nfi\n\necho \"$FUNC1:traceoff\" > set_ftrace_filter\nif check_set_ftrace_filter \"$ALL_FUNCS\" \"$FUNC1:traceoff:unlimited\"; then\n    fail \"Expected $ALL_FUNCS and $FUNC1:traceoff:unlimited\"\nfi\n\necho \"$FUNC1\" > set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" \"$FUNC1:traceoff:unlimited\"; then\n    fail \"Expected $FUNC1 and $FUNC1:traceoff:unlimited\"\nfi\n\necho \"$FUNC2\" >> set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" \"$FUNC2\" \"$FUNC1:traceoff:unlimited\"; then\n    fail \"Expected $FUNC1 $FUNC2 and $FUNC1:traceoff:unlimited\"\nfi\n\necho \"$FUNC2:traceoff\" >> set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" \"$FUNC2\" \"$FUNC1:traceoff:unlimited\" \"$FUNC2:traceoff:unlimited\"; then\n    fail \"Expected $FUNC1 $FUNC2 $FUNC1:traceoff:unlimited and $FUNC2:traceoff:unlimited\"\nfi\n\necho \"$FUNC1\" > set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" \"$FUNC1:traceoff:unlimited\" \"$FUNC2:traceoff:unlimited\"; then\n    fail \"Expected $FUNC1 $FUNC1:traceoff:unlimited and $FUNC2:traceoff:unlimited\"\nfi\n\necho > set_ftrace_filter\nif check_set_ftrace_filter \"$ALL_FUNCS\" \"$FUNC1:traceoff:unlimited\" \"$FUNC2:traceoff:unlimited\"; then\n    fail \"Expected $ALL_FUNCS $FUNC1:traceoff:unlimited and $FUNC2:traceoff:unlimited\"\nfi\n\nreset_ftrace_filter\n\nif check_set_ftrace_filter \"$ALL_FUNCS\"; then\n    fail \"Expected $ALL_FUNCS\"\nfi\n\necho \"$FUNC1\" > set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" ; then\n    fail \"Expected $FUNC1\"\nfi\n\necho \"$FUNC2\" >> set_ftrace_filter\nif check_set_ftrace_filter \"$FUNC1\" \"$FUNC2\" ; then\n    fail \"Expected $FUNC1 and $FUNC2\"\nfi\n\ntest_actual() { # Compares $TMPDIR/expected with set_ftrace_filter\n    cat set_ftrace_filter | grep -v '#' | cut -d' ' -f1 | cut -d':' -f1 | sort -u > $TMPDIR/actual\n    DIFF=`diff $TMPDIR/actual $TMPDIR/expected`\n    test -z \"$DIFF\"\n}\n\n# Set traceoff trigger for all fuctions with \"lock\" in their name\ncat available_filter_functions | cut -d' ' -f1 |  grep 'lock' | sort -u > $TMPDIR/expected\necho '*lock*:traceoff' > set_ftrace_filter\ntest_actual\n\n# now remove all with 'try' in it, and end with lock\ngrep -v 'try.*lock$' $TMPDIR/expected > $TMPDIR/expected2\nmv $TMPDIR/expected2 $TMPDIR/expected\necho '!*try*lock:traceoff' >> set_ftrace_filter\ntest_actual\n\n# remove all that start with \"m\" and end with \"lock\"\ngrep -v '^m.*lock$' $TMPDIR/expected > $TMPDIR/expected2\nmv $TMPDIR/expected2 $TMPDIR/expected\necho '!m*lock:traceoff' >> set_ftrace_filter\ntest_actual\n\n# remove all that start with \"c\" and have \"unlock\"\ngrep -v '^c.*unlock' $TMPDIR/expected > $TMPDIR/expected2\nmv $TMPDIR/expected2 $TMPDIR/expected\necho '!c*unlock*:traceoff' >> set_ftrace_filter\ntest_actual\n\n# clear all the rest\n> $TMPDIR/expected\necho '!*:traceoff' >> set_ftrace_filter\ntest_actual\n\nrm $TMPDIR/expected\nrm $TMPDIR/actual\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}