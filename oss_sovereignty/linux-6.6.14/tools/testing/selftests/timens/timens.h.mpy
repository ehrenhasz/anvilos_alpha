{
  "module_name": "timens.h",
  "hash_id": "32f509643b1abbc8363acda805f17c2904c1af408b38254a15ce5fa98ae66b5f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/timens.h",
  "human_readable_source": " \n#ifndef __TIMENS_H__\n#define __TIMENS_H__\n\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"../kselftest.h\"\n\n#ifndef CLONE_NEWTIME\n# define CLONE_NEWTIME\t0x00000080\n#endif\n\nstatic int config_posix_timers = true;\nstatic int config_alarm_timers = true;\n\nstatic inline void check_supported_timers(void)\n{\n\tstruct timespec ts;\n\n\tif (timer_create(-1, 0, 0) == -1 && errno == ENOSYS)\n\t\tconfig_posix_timers = false;\n\n\tif (clock_gettime(CLOCK_BOOTTIME_ALARM, &ts) == -1 && errno == EINVAL)\n\t\tconfig_alarm_timers = false;\n}\n\nstatic inline bool check_skip(int clockid)\n{\n\tif (!config_alarm_timers && clockid == CLOCK_BOOTTIME_ALARM) {\n\t\tksft_test_result_skip(\"CLOCK_BOOTTIME_ALARM isn't supported\\n\");\n\t\treturn true;\n\t}\n\n\tif (config_posix_timers)\n\t\treturn false;\n\n\tswitch (clockid) {\n\t \n\tcase CLOCK_BOOTTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_REALTIME:\n\t\treturn false;\n\tdefault:\n\t\tksft_test_result_skip(\"Posix Clocks & timers are not supported\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline int unshare_timens(void)\n{\n\tif (unshare(CLONE_NEWTIME)) {\n\t\tif (errno == EPERM)\n\t\t\tksft_exit_skip(\"need to run as root\\n\");\n\t\treturn pr_perror(\"Can't unshare() timens\");\n\t}\n\treturn 0;\n}\n\nstatic inline int _settime(clockid_t clk_id, time_t offset)\n{\n\tint fd, len;\n\tchar buf[4096];\n\n\tif (clk_id == CLOCK_MONOTONIC_COARSE || clk_id == CLOCK_MONOTONIC_RAW)\n\t\tclk_id = CLOCK_MONOTONIC;\n\n\tlen = snprintf(buf, sizeof(buf), \"%d %ld 0\", clk_id, offset);\n\n\tfd = open(\"/proc/self/timens_offsets\", O_WRONLY);\n\tif (fd < 0)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tif (write(fd, buf, len) != len)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic inline int _gettime(clockid_t clk_id, struct timespec *res, bool raw_syscall)\n{\n\tint err;\n\n\tif (!raw_syscall) {\n\t\tif (clock_gettime(clk_id, res)) {\n\t\t\tpr_perror(\"clock_gettime(%d)\", (int)clk_id);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\terr = syscall(SYS_clock_gettime, clk_id, res);\n\tif (err)\n\t\tpr_perror(\"syscall(SYS_clock_gettime(%d))\", (int)clk_id);\n\n\treturn err;\n}\n\nstatic inline void nscheck(void)\n{\n\tif (access(\"/proc/self/ns/time\", F_OK) < 0)\n\t\tksft_exit_skip(\"Time namespaces are not supported\\n\");\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}