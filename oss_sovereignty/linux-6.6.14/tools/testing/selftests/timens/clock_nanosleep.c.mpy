{
  "module_name": "clock_nanosleep.c",
  "hash_id": "d0d4f31bfcaf7ae1ac5207f8d44ceb5492298fe78a4222ef092425cc336ec14c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/clock_nanosleep.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n\n#include <sys/timerfd.h>\n#include <sys/syscall.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\nvoid test_sig(int sig)\n{\n\tif (sig == SIGUSR2)\n\t\tpthread_exit(NULL);\n}\n\nstruct thread_args {\n\tstruct timespec *now, *rem;\n\tpthread_mutex_t *lock;\n\tint clockid;\n\tint abs;\n};\n\nvoid *call_nanosleep(void *_args)\n{\n\tstruct thread_args *args = _args;\n\n\tclock_nanosleep(args->clockid, args->abs ? TIMER_ABSTIME : 0, args->now, args->rem);\n\tpthread_mutex_unlock(args->lock);\n\treturn NULL;\n}\n\nint run_test(int clockid, int abs)\n{\n\tstruct timespec now = {}, rem;\n\tstruct thread_args args = { .now = &now, .rem = &rem, .clockid = clockid};\n\tstruct timespec start;\n\tpthread_mutex_t lock;\n\tpthread_t thread;\n\tint j, ok, ret;\n\n\tsignal(SIGUSR1, test_sig);\n\tsignal(SIGUSR2, test_sig);\n\n\tpthread_mutex_init(&lock, NULL);\n\tpthread_mutex_lock(&lock);\n\n\tif (clock_gettime(clockid, &start) == -1) {\n\t\tif (errno == EINVAL && check_skip(clockid))\n\t\t\treturn 0;\n\t\treturn pr_perror(\"clock_gettime\");\n\t}\n\n\n\tif (abs) {\n\t\tnow.tv_sec = start.tv_sec;\n\t\tnow.tv_nsec = start.tv_nsec;\n\t}\n\n\tnow.tv_sec += 3600;\n\targs.abs = abs;\n\targs.lock = &lock;\n\tret = pthread_create(&thread, NULL, call_nanosleep, &args);\n\tif (ret != 0) {\n\t\tpr_err(\"Unable to create a thread: %s\", strerror(ret));\n\t\treturn 1;\n\t}\n\n\t \n\tok = 0;\n\tfor (j = 0; j < 8; j++) {\n\t\t \n\t\tusleep(10000 << j);\n\n\t\t \n\t\tpthread_kill(thread, SIGUSR1);\n\n\t\tusleep(10000 << j);\n\t\t \n\t\tif (pthread_mutex_trylock(&lock) == 0) {\n\t\t\t \n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ok)\n\t\tpthread_kill(thread, SIGUSR2);\n\tpthread_join(thread, NULL);\n\tpthread_mutex_destroy(&lock);\n\n\tif (!ok) {\n\t\tksft_test_result_pass(\"clockid: %d abs:%d timeout\\n\", clockid, abs);\n\t\treturn 1;\n\t}\n\n\tif (rem.tv_sec < 3300 || rem.tv_sec > 3900) {\n\t\tpr_fail(\"clockid: %d abs: %d remain: %ld\\n\",\n\t\t\tclockid, abs, rem.tv_sec);\n\t\treturn 1;\n\t}\n\tksft_test_result_pass(\"clockid: %d abs:%d\\n\", clockid, abs);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret, nsfd;\n\n\tnscheck();\n\n\tksft_set_plan(4);\n\n\tcheck_supported_timers();\n\n\tif (unshare_timens())\n\t\treturn 1;\n\n\tif (_settime(CLOCK_MONOTONIC, 7 * 24 * 3600))\n\t\treturn 1;\n\tif (_settime(CLOCK_BOOTTIME, 9 * 24 * 3600))\n\t\treturn 1;\n\n\tnsfd = open(\"/proc/self/ns/time_for_children\", O_RDONLY);\n\tif (nsfd < 0)\n\t\treturn pr_perror(\"Unable to open timens_for_children\");\n\n\tif (setns(nsfd, CLONE_NEWTIME))\n\t\treturn pr_perror(\"Unable to set timens\");\n\n\tret = 0;\n\tret |= run_test(CLOCK_MONOTONIC, 0);\n\tret |= run_test(CLOCK_MONOTONIC, 1);\n\tret |= run_test(CLOCK_BOOTTIME_ALARM, 0);\n\tret |= run_test(CLOCK_BOOTTIME_ALARM, 1);\n\n\tif (ret)\n\t\tksft_exit_fail();\n\tksft_exit_pass();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}