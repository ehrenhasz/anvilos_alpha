{
  "module_name": "futex.c",
  "hash_id": "e8259929de2812e7a8b03acdee0e72513f78b0bfe5f591e7db5d46e422cf7a42",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/futex.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n\n#include <linux/unistd.h>\n#include <linux/futex.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\n#define NSEC_PER_SEC 1000000000ULL\n\nstatic int run_test(int clockid)\n{\n\tint futex_op = FUTEX_WAIT_BITSET;\n\tstruct timespec timeout, end;\n\tint val = 0;\n\n\tif (clockid == CLOCK_REALTIME)\n\t\tfutex_op |= FUTEX_CLOCK_REALTIME;\n\n\tclock_gettime(clockid, &timeout);\n\ttimeout.tv_nsec += NSEC_PER_SEC / 10; \n\tif (timeout.tv_nsec > NSEC_PER_SEC) {\n\t\ttimeout.tv_sec++;\n\t\ttimeout.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tif (syscall(__NR_futex, &val, futex_op, 0,\n\t\t    &timeout, 0, FUTEX_BITSET_MATCH_ANY) >= 0) {\n\t\tksft_test_result_fail(\"futex didn't return ETIMEDOUT\\n\");\n\t\treturn 1;\n\t}\n\n\tif (errno != ETIMEDOUT) {\n\t\tksft_test_result_fail(\"futex didn't return ETIMEDOUT: %s\\n\",\n\t\t\t\t\t\t\tstrerror(errno));\n\t\treturn 1;\n\t}\n\n\tclock_gettime(clockid, &end);\n\n\tif (end.tv_sec < timeout.tv_sec ||\n\t    (end.tv_sec == timeout.tv_sec && end.tv_nsec < timeout.tv_nsec)) {\n\t\tksft_test_result_fail(\"futex slept less than 100ms\\n\");\n\t\treturn 1;\n\t}\n\n\n\tksft_test_result_pass(\"futex with the %d clockid\\n\", clockid);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint status, len, fd;\n\tchar buf[4096];\n\tpid_t pid;\n\tstruct timespec mtime_now;\n\n\tnscheck();\n\n\tksft_set_plan(2);\n\n\tclock_gettime(CLOCK_MONOTONIC, &mtime_now);\n\n\tif (unshare_timens())\n\t\treturn 1;\n\n\tlen = snprintf(buf, sizeof(buf), \"%d %d 0\",\n\t\t\tCLOCK_MONOTONIC, 70 * 24 * 3600);\n\tfd = open(\"/proc/self/timens_offsets\", O_WRONLY);\n\tif (fd < 0)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tif (write(fd, buf, len) != len)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tclose(fd);\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn pr_perror(\"Unable to fork\");\n\tif (pid == 0) {\n\t\tint ret = 0;\n\n\t\tret |= run_test(CLOCK_REALTIME);\n\t\tret |= run_test(CLOCK_MONOTONIC);\n\t\tif (ret)\n\t\t\tksft_exit_fail();\n\t\tksft_exit_pass();\n\t\treturn 0;\n\t}\n\n\tif (waitpid(pid, &status, 0) != pid)\n\t\treturn pr_perror(\"Unable to wait the child process\");\n\n\tif (WIFEXITED(status))\n\t\treturn WEXITSTATUS(status);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}