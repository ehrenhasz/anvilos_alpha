{
  "module_name": "vfork_exec.c",
  "hash_id": "607fa74782a5feedb05398b3a0024efd960f70de66cc0c980e7b8ad437f45cbc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/vfork_exec.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\n#define OFFSET (36000)\n\nstruct thread_args {\n\tchar *tst_name;\n\tstruct timespec *now;\n};\n\nstatic void *tcheck(void *_args)\n{\n\tstruct thread_args *args = _args;\n\tstruct timespec *now = args->now, tst;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\t_gettime(CLOCK_MONOTONIC, &tst, i);\n\t\tif (abs(tst.tv_sec - now->tv_sec) > 5) {\n\t\t\tpr_fail(\"%s: in-thread: unexpected value: %ld (%ld)\\n\",\n\t\t\t\targs->tst_name, tst.tv_sec, now->tv_sec);\n\t\t\treturn (void *)1UL;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int check_in_thread(char *tst_name, struct timespec *now)\n{\n\tstruct thread_args args = {\n\t\t.tst_name = tst_name,\n\t\t.now = now,\n\t};\n\tpthread_t th;\n\tvoid *retval;\n\n\tif (pthread_create(&th, NULL, tcheck, &args))\n\t\treturn pr_perror(\"thread\");\n\tif (pthread_join(th, &retval))\n\t\treturn pr_perror(\"pthread_join\");\n\treturn !(retval == NULL);\n}\n\nstatic int check(char *tst_name, struct timespec *now)\n{\n\tstruct timespec tst;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\t_gettime(CLOCK_MONOTONIC, &tst, i);\n\t\tif (abs(tst.tv_sec - now->tv_sec) > 5)\n\t\t\treturn pr_fail(\"%s: unexpected value: %ld (%ld)\\n\",\n\t\t\t\t\ttst_name, tst.tv_sec, now->tv_sec);\n\t}\n\tif (check_in_thread(tst_name, now))\n\t\treturn 1;\n\tksft_test_result_pass(\"%s\\n\", tst_name);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct timespec now;\n\tint status;\n\tpid_t pid;\n\n\tif (argc > 1) {\n\t\tchar *endptr;\n\n\t\tksft_cnt.ksft_pass = 1;\n\t\tnow.tv_sec = strtoul(argv[1], &endptr, 0);\n\t\tif (*endptr != 0)\n\t\t\treturn pr_perror(\"strtoul\");\n\n\t\treturn check(\"child after exec\", &now);\n\t}\n\n\tnscheck();\n\n\tksft_set_plan(4);\n\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\n\tif (unshare_timens())\n\t\treturn 1;\n\n\tif (_settime(CLOCK_MONOTONIC, OFFSET))\n\t\treturn 1;\n\n\tif (check(\"parent before vfork\", &now))\n\t\treturn 1;\n\n\tpid = vfork();\n\tif (pid < 0)\n\t\treturn pr_perror(\"fork\");\n\n\tif (pid == 0) {\n\t\tchar now_str[64];\n\t\tchar *cargv[] = {\"exec\", now_str, NULL};\n\t\tchar *cenv[] = {NULL};\n\n\t\t \n\t\tsnprintf(now_str, sizeof(now_str), \"%ld\", now.tv_sec + OFFSET);\n\t\texecve(\"/proc/self/exe\", cargv, cenv);\n\t\tpr_perror(\"execve\");\n\t\t_exit(1);\n\t}\n\n\tif (waitpid(pid, &status, 0) != pid)\n\t\treturn pr_perror(\"waitpid\");\n\n\tif (status)\n\t\tksft_exit_fail();\n\tksft_inc_pass_cnt();\n\tksft_test_result_pass(\"wait for child\\n\");\n\n\t \n\tif (check(\"parent after vfork\", &now))\n\t\treturn 1;\n\n\tksft_exit_pass();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}