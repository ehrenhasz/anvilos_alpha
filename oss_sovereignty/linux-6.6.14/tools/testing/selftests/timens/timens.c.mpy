{
  "module_name": "timens.c",
  "hash_id": "eaf6e85ffa2070c75bafc46bcdd93cbe7a7ef65d865d800e01b7d32334aec639",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/timens.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\n \n#define DAY_IN_SEC\t\t\t(60*60*24)\n#define TEN_DAYS_IN_SEC\t\t\t(10*DAY_IN_SEC)\n\nstruct test_clock {\n\tclockid_t id;\n\tchar *name;\n\t \n\tint off_id;\n\ttime_t offset;\n};\n\n#define ct(clock, off_id)\t{ clock, #clock, off_id }\nstatic struct test_clock clocks[] = {\n\tct(CLOCK_BOOTTIME, -1),\n\tct(CLOCK_BOOTTIME_ALARM, 1),\n\tct(CLOCK_MONOTONIC, -1),\n\tct(CLOCK_MONOTONIC_COARSE, 1),\n\tct(CLOCK_MONOTONIC_RAW, 1),\n};\n#undef ct\n\nstatic int child_ns, parent_ns = -1;\n\nstatic int switch_ns(int fd)\n{\n\tif (setns(fd, CLONE_NEWTIME)) {\n\t\tpr_perror(\"setns()\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_namespaces(void)\n{\n\tchar path[] = \"/proc/self/ns/time_for_children\";\n\tstruct stat st1, st2;\n\n\tif (parent_ns == -1) {\n\t\tparent_ns = open(path, O_RDONLY);\n\t\tif (parent_ns <= 0)\n\t\t\treturn pr_perror(\"Unable to open %s\", path);\n\t}\n\n\tif (fstat(parent_ns, &st1))\n\t\treturn pr_perror(\"Unable to stat the parent timens\");\n\n\tif (unshare_timens())\n\t\treturn  -1;\n\n\tchild_ns = open(path, O_RDONLY);\n\tif (child_ns <= 0)\n\t\treturn pr_perror(\"Unable to open %s\", path);\n\n\tif (fstat(child_ns, &st2))\n\t\treturn pr_perror(\"Unable to stat the timens\");\n\n\tif (st1.st_ino == st2.st_ino)\n\t\treturn pr_perror(\"The same child_ns after CLONE_NEWTIME\");\n\n\treturn 0;\n}\n\nstatic int test_gettime(clockid_t clock_index, bool raw_syscall, time_t offset)\n{\n\tstruct timespec child_ts_new, parent_ts_old, cur_ts;\n\tchar *entry = raw_syscall ? \"syscall\" : \"vdso\";\n\tdouble precision = 0.0;\n\n\tif (check_skip(clocks[clock_index].id))\n\t\treturn 0;\n\n\tswitch (clocks[clock_index].id) {\n\tcase CLOCK_MONOTONIC_COARSE:\n\tcase CLOCK_MONOTONIC_RAW:\n\t\tprecision = -2.0;\n\t\tbreak;\n\t}\n\n\tif (switch_ns(parent_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", child_ns);\n\n\tif (_gettime(clocks[clock_index].id, &parent_ts_old, raw_syscall))\n\t\treturn -1;\n\n\tchild_ts_new.tv_nsec = parent_ts_old.tv_nsec;\n\tchild_ts_new.tv_sec = parent_ts_old.tv_sec + offset;\n\n\tif (switch_ns(child_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", child_ns);\n\n\tif (_gettime(clocks[clock_index].id, &cur_ts, raw_syscall))\n\t\treturn -1;\n\n\tif (difftime(cur_ts.tv_sec, child_ts_new.tv_sec) < precision) {\n\t\tksft_test_result_fail(\n\t\t\t\"Child's %s (%s) time has not changed: %lu -> %lu [%lu]\\n\",\n\t\t\tclocks[clock_index].name, entry, parent_ts_old.tv_sec,\n\t\t\tchild_ts_new.tv_sec, cur_ts.tv_sec);\n\t\treturn -1;\n\t}\n\n\tif (switch_ns(parent_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", parent_ns);\n\n\tif (_gettime(clocks[clock_index].id, &cur_ts, raw_syscall))\n\t\treturn -1;\n\n\tif (difftime(cur_ts.tv_sec, parent_ts_old.tv_sec) > DAY_IN_SEC) {\n\t\tksft_test_result_fail(\n\t\t\t\"Parent's %s (%s) time has changed: %lu -> %lu [%lu]\\n\",\n\t\t\tclocks[clock_index].name, entry, parent_ts_old.tv_sec,\n\t\t\tchild_ts_new.tv_sec, cur_ts.tv_sec);\n\t\t \n\t\tclock_settime(clocks[clock_index].id, &cur_ts);\n\t\treturn -1;\n\t}\n\n\tksft_test_result_pass(\"Passed for %s (%s)\\n\",\n\t\t\t\tclocks[clock_index].name, entry);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tunsigned int i;\n\ttime_t offset;\n\tint ret = 0;\n\n\tnscheck();\n\n\tcheck_supported_timers();\n\n\tksft_set_plan(ARRAY_SIZE(clocks) * 2);\n\n\tif (init_namespaces())\n\t\treturn 1;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clocks); i++) {\n\t\tif (clocks[i].off_id != -1)\n\t\t\tcontinue;\n\t\toffset = TEN_DAYS_IN_SEC + i * 1000;\n\t\tclocks[i].offset = offset;\n\t\tif (_settime(clocks[i].id, offset))\n\t\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(clocks); i++) {\n\t\tif (clocks[i].off_id != -1)\n\t\t\toffset = clocks[clocks[i].off_id].offset;\n\t\telse\n\t\t\toffset = clocks[i].offset;\n\t\tret |= test_gettime(i, true, offset);\n\t\tret |= test_gettime(i, false, offset);\n\t}\n\n\tif (ret)\n\t\tksft_exit_fail();\n\n\tksft_exit_pass();\n\treturn !!ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}