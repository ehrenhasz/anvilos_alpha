{
  "module_name": "timerfd.c",
  "hash_id": "5861612757b8f959dacde9fc7e3e4e2c35cea0813b005fbff88eb3bf493e22f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/timerfd.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n\n#include <sys/timerfd.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\nstatic int tclock_gettime(clock_t clockid, struct timespec *now)\n{\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\tclockid = CLOCK_BOOTTIME;\n\treturn clock_gettime(clockid, now);\n}\n\nint run_test(int clockid, struct timespec now)\n{\n\tstruct itimerspec new_value;\n\tlong long elapsed;\n\tint fd, i;\n\n\tif (check_skip(clockid))\n\t\treturn 0;\n\n\tif (tclock_gettime(clockid, &now))\n\t\treturn pr_perror(\"clock_gettime(%d)\", clockid);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint flags = 0;\n\n\t\tnew_value.it_value.tv_sec = 3600;\n\t\tnew_value.it_value.tv_nsec = 0;\n\t\tnew_value.it_interval.tv_sec = 1;\n\t\tnew_value.it_interval.tv_nsec = 0;\n\n\t\tif (i == 1) {\n\t\t\tnew_value.it_value.tv_sec += now.tv_sec;\n\t\t\tnew_value.it_value.tv_nsec += now.tv_nsec;\n\t\t}\n\n\t\tfd = timerfd_create(clockid, 0);\n\t\tif (fd == -1)\n\t\t\treturn pr_perror(\"timerfd_create(%d)\", clockid);\n\n\t\tif (i == 1)\n\t\t\tflags |= TFD_TIMER_ABSTIME;\n\n\t\tif (timerfd_settime(fd, flags, &new_value, NULL))\n\t\t\treturn pr_perror(\"timerfd_settime(%d)\", clockid);\n\n\t\tif (timerfd_gettime(fd, &new_value))\n\t\t\treturn pr_perror(\"timerfd_gettime(%d)\", clockid);\n\n\t\telapsed = new_value.it_value.tv_sec;\n\t\tif (abs(elapsed - 3600) > 60) {\n\t\t\tksft_test_result_fail(\"clockid: %d elapsed: %lld\\n\",\n\t\t\t\t\t      clockid, elapsed);\n\t\t\treturn 1;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\tksft_test_result_pass(\"clockid=%d\\n\", clockid);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret, status, len, fd;\n\tchar buf[4096];\n\tpid_t pid;\n\tstruct timespec btime_now, mtime_now;\n\n\tnscheck();\n\n\tcheck_supported_timers();\n\n\tksft_set_plan(3);\n\n\tclock_gettime(CLOCK_MONOTONIC, &mtime_now);\n\tclock_gettime(CLOCK_BOOTTIME, &btime_now);\n\n\tif (unshare_timens())\n\t\treturn 1;\n\n\tlen = snprintf(buf, sizeof(buf), \"%d %d 0\\n%d %d 0\",\n\t\t\tCLOCK_MONOTONIC, 70 * 24 * 3600,\n\t\t\tCLOCK_BOOTTIME, 9 * 24 * 3600);\n\tfd = open(\"/proc/self/timens_offsets\", O_WRONLY);\n\tif (fd < 0)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tif (write(fd, buf, len) != len)\n\t\treturn pr_perror(\"/proc/self/timens_offsets\");\n\n\tclose(fd);\n\tmtime_now.tv_sec += 70 * 24 * 3600;\n\tbtime_now.tv_sec += 9 * 24 * 3600;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn pr_perror(\"Unable to fork\");\n\tif (pid == 0) {\n\t\tret = 0;\n\t\tret |= run_test(CLOCK_BOOTTIME, btime_now);\n\t\tret |= run_test(CLOCK_MONOTONIC, mtime_now);\n\t\tret |= run_test(CLOCK_BOOTTIME_ALARM, btime_now);\n\n\t\tif (ret)\n\t\t\tksft_exit_fail();\n\t\tksft_exit_pass();\n\t\treturn ret;\n\t}\n\n\tif (waitpid(pid, &status, 0) != pid)\n\t\treturn pr_perror(\"Unable to wait the child process\");\n\n\tif (WIFEXITED(status))\n\t\treturn WEXITSTATUS(status);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}