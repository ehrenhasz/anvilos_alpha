{
  "module_name": "procfs.c",
  "hash_id": "210962ab80d4ae9d740b1b8f3b1babe7264fd3dd8b54e3e5ce3e282fd6bd2062",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/procfs.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <math.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\n \n#define MAX_TEST_TIME_SEC\t\t(60*5)\n#define DAY_IN_SEC\t\t\t(60*60*24)\n#define TEN_DAYS_IN_SEC\t\t\t(10*DAY_IN_SEC)\n\nstatic int child_ns, parent_ns;\n\nstatic int switch_ns(int fd)\n{\n\tif (setns(fd, CLONE_NEWTIME))\n\t\treturn pr_perror(\"setns()\");\n\n\treturn 0;\n}\n\nstatic int init_namespaces(void)\n{\n\tchar path[] = \"/proc/self/ns/time_for_children\";\n\tstruct stat st1, st2;\n\n\tparent_ns = open(path, O_RDONLY);\n\tif (parent_ns <= 0)\n\t\treturn pr_perror(\"Unable to open %s\", path);\n\n\tif (fstat(parent_ns, &st1))\n\t\treturn pr_perror(\"Unable to stat the parent timens\");\n\n\tif (unshare_timens())\n\t\treturn -1;\n\n\tchild_ns = open(path, O_RDONLY);\n\tif (child_ns <= 0)\n\t\treturn pr_perror(\"Unable to open %s\", path);\n\n\tif (fstat(child_ns, &st2))\n\t\treturn pr_perror(\"Unable to stat the timens\");\n\n\tif (st1.st_ino == st2.st_ino)\n\t\treturn pr_err(\"The same child_ns after CLONE_NEWTIME\");\n\n\tif (_settime(CLOCK_BOOTTIME, TEN_DAYS_IN_SEC))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int read_proc_uptime(struct timespec *uptime)\n{\n\tunsigned long up_sec, up_nsec;\n\tFILE *proc;\n\n\tproc = fopen(\"/proc/uptime\", \"r\");\n\tif (proc == NULL) {\n\t\tpr_perror(\"Unable to open /proc/uptime\");\n\t\treturn -1;\n\t}\n\n\tif (fscanf(proc, \"%lu.%02lu\", &up_sec, &up_nsec) != 2) {\n\t\tif (errno) {\n\t\t\tpr_perror(\"fscanf\");\n\t\t\treturn -errno;\n\t\t}\n\t\tpr_err(\"failed to parse /proc/uptime\");\n\t\treturn -1;\n\t}\n\tfclose(proc);\n\n\tuptime->tv_sec = up_sec;\n\tuptime->tv_nsec = up_nsec;\n\treturn 0;\n}\n\nstatic int read_proc_stat_btime(unsigned long long *boottime_sec)\n{\n\tFILE *proc;\n\tchar line_buf[2048];\n\n\tproc = fopen(\"/proc/stat\", \"r\");\n\tif (proc == NULL) {\n\t\tpr_perror(\"Unable to open /proc/stat\");\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line_buf, 2048, proc)) {\n\t\tif (sscanf(line_buf, \"btime %llu\", boottime_sec) != 1)\n\t\t\tcontinue;\n\t\tfclose(proc);\n\t\treturn 0;\n\t}\n\tif (errno) {\n\t\tpr_perror(\"fscanf\");\n\t\tfclose(proc);\n\t\treturn -errno;\n\t}\n\tpr_err(\"failed to parse /proc/stat\");\n\tfclose(proc);\n\treturn -1;\n}\n\nstatic int check_uptime(void)\n{\n\tstruct timespec uptime_new, uptime_old;\n\ttime_t uptime_expected;\n\tdouble prec = MAX_TEST_TIME_SEC;\n\n\tif (switch_ns(parent_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", parent_ns);\n\n\tif (read_proc_uptime(&uptime_old))\n\t\treturn 1;\n\n\tif (switch_ns(child_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", child_ns);\n\n\tif (read_proc_uptime(&uptime_new))\n\t\treturn 1;\n\n\tuptime_expected = uptime_old.tv_sec + TEN_DAYS_IN_SEC;\n\tif (fabs(difftime(uptime_new.tv_sec, uptime_expected)) > prec) {\n\t\tpr_fail(\"uptime in /proc/uptime: old %ld, new %ld [%ld]\",\n\t\t\tuptime_old.tv_sec, uptime_new.tv_sec,\n\t\t\tuptime_old.tv_sec + TEN_DAYS_IN_SEC);\n\t\treturn 1;\n\t}\n\n\tksft_test_result_pass(\"Passed for /proc/uptime\\n\");\n\treturn 0;\n}\n\nstatic int check_stat_btime(void)\n{\n\tunsigned long long btime_new, btime_old;\n\tunsigned long long btime_expected;\n\n\tif (switch_ns(parent_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", parent_ns);\n\n\tif (read_proc_stat_btime(&btime_old))\n\t\treturn 1;\n\n\tif (switch_ns(child_ns))\n\t\treturn pr_err(\"switch_ns(%d)\", child_ns);\n\n\tif (read_proc_stat_btime(&btime_new))\n\t\treturn 1;\n\n\tbtime_expected = btime_old - TEN_DAYS_IN_SEC;\n\tif (btime_new != btime_expected) {\n\t\tpr_fail(\"btime in /proc/stat: old %llu, new %llu [%llu]\",\n\t\t\tbtime_old, btime_new, btime_expected);\n\t\treturn 1;\n\t}\n\n\tksft_test_result_pass(\"Passed for /proc/stat btime\\n\");\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\n\tnscheck();\n\n\tksft_set_plan(2);\n\n\tif (init_namespaces())\n\t\treturn 1;\n\n\tret |= check_uptime();\n\tret |= check_stat_btime();\n\n\tif (ret)\n\t\tksft_exit_fail();\n\tksft_exit_pass();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}