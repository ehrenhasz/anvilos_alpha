{
  "module_name": "gettime_perf.c",
  "hash_id": "e0fdf577ae8a6da5ef4409db5d850b9449587d28a1f547f2314e9d4d48516407",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timens/gettime_perf.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <time.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <dlfcn.h>\n\n#include \"log.h\"\n#include \"timens.h\"\n\ntypedef int (*vgettime_t)(clockid_t, struct timespec *);\n\nvgettime_t vdso_clock_gettime;\n\nstatic void fill_function_pointers(void)\n{\n\tvoid *vdso = dlopen(\"linux-vdso.so.1\",\n\t\t\t    RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso)\n\t\tvdso = dlopen(\"linux-gate.so.1\",\n\t\t\t      RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso)\n\t\tvdso = dlopen(\"linux-vdso32.so.1\",\n\t\t\t      RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso)\n\t\tvdso = dlopen(\"linux-vdso64.so.1\",\n\t\t\t      RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso) {\n\t\tpr_err(\"[WARN]\\tfailed to find vDSO\\n\");\n\t\treturn;\n\t}\n\n\tvdso_clock_gettime = (vgettime_t)dlsym(vdso, \"__vdso_clock_gettime\");\n\tif (!vdso_clock_gettime)\n\t\tvdso_clock_gettime = (vgettime_t)dlsym(vdso, \"__kernel_clock_gettime\");\n\tif (!vdso_clock_gettime)\n\t\tpr_err(\"Warning: failed to find clock_gettime in vDSO\\n\");\n\n}\n\nstatic void test(clock_t clockid, char *clockstr, bool in_ns)\n{\n\tstruct timespec tp, start;\n\tlong i = 0;\n\tconst int timeout = 3;\n\n\tvdso_clock_gettime(clockid, &start);\n\ttp = start;\n\tfor (tp = start; start.tv_sec + timeout > tp.tv_sec ||\n\t\t\t (start.tv_sec + timeout == tp.tv_sec &&\n\t\t\t  start.tv_nsec > tp.tv_nsec); i++) {\n\t\tvdso_clock_gettime(clockid, &tp);\n\t}\n\n\tksft_test_result_pass(\"%s:\\tclock: %10s\\tcycles:\\t%10ld\\n\",\n\t\t\t      in_ns ? \"ns\" : \"host\", clockstr, i);\n}\n\nint main(int argc, char *argv[])\n{\n\ttime_t offset = 10;\n\tint nsfd;\n\n\tksft_set_plan(8);\n\n\tfill_function_pointers();\n\n\ttest(CLOCK_MONOTONIC, \"monotonic\", false);\n\ttest(CLOCK_MONOTONIC_COARSE, \"monotonic-coarse\", false);\n\ttest(CLOCK_MONOTONIC_RAW, \"monotonic-raw\", false);\n\ttest(CLOCK_BOOTTIME, \"boottime\", false);\n\n\tnscheck();\n\n\tif (unshare_timens())\n\t\treturn 1;\n\n\tnsfd = open(\"/proc/self/ns/time_for_children\", O_RDONLY);\n\tif (nsfd < 0)\n\t\treturn pr_perror(\"Can't open a time namespace\");\n\n\tif (_settime(CLOCK_MONOTONIC, offset))\n\t\treturn 1;\n\tif (_settime(CLOCK_BOOTTIME, offset))\n\t\treturn 1;\n\n\tif (setns(nsfd, CLONE_NEWTIME))\n\t\treturn pr_perror(\"setns\");\n\n\ttest(CLOCK_MONOTONIC, \"monotonic\", true);\n\ttest(CLOCK_MONOTONIC_COARSE, \"monotonic-coarse\", true);\n\ttest(CLOCK_MONOTONIC_RAW, \"monotonic-raw\", true);\n\ttest(CLOCK_BOOTTIME, \"boottime\", true);\n\n\tksft_exit_pass();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}