{
  "module_name": "mincore_selftest.c",
  "hash_id": "aaa79b5903ddd8fefc4ae703a980f7cfe56cc5c8cb5445d4fb25027f2234a0f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mincore/mincore_selftest.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <string.h>\n#include <fcntl.h>\n\n#include \"../kselftest.h\"\n#include \"../kselftest_harness.h\"\n\n \n#define MB (1UL << 20)\n#define FILE_SIZE (4 * MB)\n\n\n \nTEST(basic_interface)\n{\n\tint retval;\n\tint page_size;\n\tunsigned char vec[1];\n\tchar *addr;\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\t \n\tretval = mincore(0, 0, vec);\n\tEXPECT_EQ(0, retval);\n\n\t \n\terrno = 0;\n\tretval = mincore(NULL, page_size, vec);\n\tEXPECT_EQ(-1, retval);\n\tEXPECT_EQ(ENOMEM, errno);\n\n\terrno = 0;\n\taddr = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n\t\tMAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(MAP_FAILED, addr) {\n\t\tTH_LOG(\"mmap error: %s\", strerror(errno));\n\t}\n\n\t \n\terrno = 0;\n\tretval = mincore(addr + 1, page_size, vec);\n\tEXPECT_EQ(-1, retval);\n\tEXPECT_EQ(EINVAL, errno);\n\n\t \n\terrno = 0;\n\tretval = mincore(addr, -1, vec);\n\tEXPECT_EQ(-1, retval);\n\tEXPECT_EQ(ENOMEM, errno);\n\n\t \n\terrno = 0;\n\tretval = mincore(addr, page_size, NULL);\n\tEXPECT_EQ(-1, retval);\n\tEXPECT_EQ(EFAULT, errno);\n\tmunmap(addr, page_size);\n}\n\n\n \nTEST(check_anonymous_locked_pages)\n{\n\tunsigned char vec[1];\n\tchar *addr;\n\tint retval;\n\tint page_size;\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\t \n\terrno = 0;\n\taddr = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(MAP_FAILED, addr) {\n\t\tTH_LOG(\"mmap error: %s\", strerror(errno));\n\t}\n\tretval = mincore(addr, page_size, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(0, vec[0]) {\n\t\tTH_LOG(\"Page found in memory before use\");\n\t}\n\n\t \n\taddr[0] = 1;\n\tmlock(addr, page_size);\n\tretval = mincore(addr, page_size, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(1, vec[0]) {\n\t\tTH_LOG(\"Page not found in memory after use\");\n\t}\n\n\t \n\tmunlock(addr, page_size);\n\tmadvise(addr, page_size, MADV_DONTNEED);\n\tretval = mincore(addr, page_size, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(0, vec[0]) {\n\t\tTH_LOG(\"Page in memory after being zapped\");\n\t}\n\tmunmap(addr, page_size);\n}\n\n\n \nTEST(check_huge_pages)\n{\n\tunsigned char vec[1];\n\tchar *addr;\n\tint retval;\n\tint page_size;\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\terrno = 0;\n\taddr = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,\n\t\t-1, 0);\n\tif (addr == MAP_FAILED) {\n\t\tif (errno == ENOMEM || errno == EINVAL)\n\t\t\tSKIP(return, \"No huge pages available or CONFIG_HUGETLB_PAGE disabled.\");\n\t\telse\n\t\t\tTH_LOG(\"mmap error: %s\", strerror(errno));\n\t}\n\tretval = mincore(addr, page_size, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(0, vec[0]) {\n\t\tTH_LOG(\"Page found in memory before use\");\n\t}\n\n\taddr[0] = 1;\n\tmlock(addr, page_size);\n\tretval = mincore(addr, page_size, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(1, vec[0]) {\n\t\tTH_LOG(\"Page not found in memory after use\");\n\t}\n\n\tmunlock(addr, page_size);\n\tmunmap(addr, page_size);\n}\n\n\n \nTEST(check_file_mmap)\n{\n\tunsigned char *vec;\n\tint vec_size;\n\tchar *addr;\n\tint retval;\n\tint page_size;\n\tint fd;\n\tint i;\n\tint ra_pages = 0;\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tvec_size = FILE_SIZE / page_size;\n\tif (FILE_SIZE % page_size)\n\t\tvec_size++;\n\n\tvec = calloc(vec_size, sizeof(unsigned char));\n\tASSERT_NE(NULL, vec) {\n\t\tTH_LOG(\"Can't allocate array\");\n\t}\n\n\terrno = 0;\n\tfd = open(\".\", O_TMPFILE | O_RDWR, 0600);\n\tif (fd < 0) {\n\t\tASSERT_EQ(errno, EOPNOTSUPP) {\n\t\t\tTH_LOG(\"Can't create temporary file: %s\",\n\t\t\t       strerror(errno));\n\t\t}\n\t\tSKIP(goto out_free, \"O_TMPFILE not supported by filesystem.\");\n\t}\n\terrno = 0;\n\tretval = fallocate(fd, 0, 0, FILE_SIZE);\n\tif (retval) {\n\t\tASSERT_EQ(errno, EOPNOTSUPP) {\n\t\t\tTH_LOG(\"Error allocating space for the temporary file: %s\",\n\t\t\t       strerror(errno));\n\t\t}\n\t\tSKIP(goto out_close, \"fallocate not supported by filesystem.\");\n\t}\n\n\t \n\terrno = 0;\n\taddr = mmap(NULL, FILE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED, fd, 0);\n\tASSERT_NE(MAP_FAILED, addr) {\n\t\tTH_LOG(\"mmap error: %s\", strerror(errno));\n\t}\n\tretval = mincore(addr, FILE_SIZE, vec);\n\tASSERT_EQ(0, retval);\n\tfor (i = 0; i < vec_size; i++) {\n\t\tASSERT_EQ(0, vec[i]) {\n\t\t\tTH_LOG(\"Unexpected page in memory\");\n\t\t}\n\t}\n\n\t \n\taddr[FILE_SIZE / 2] = 1;\n\tretval = mincore(addr, FILE_SIZE, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(1, vec[FILE_SIZE / 2 / page_size]) {\n\t\tTH_LOG(\"Page not found in memory after use\");\n\t}\n\n\ti = FILE_SIZE / 2 / page_size + 1;\n\twhile (i < vec_size && vec[i]) {\n\t\tra_pages++;\n\t\ti++;\n\t}\n\tEXPECT_GT(ra_pages, 0) {\n\t\tTH_LOG(\"No read-ahead pages found in memory\");\n\t}\n\n\tEXPECT_LT(i, vec_size) {\n\t\tTH_LOG(\"Read-ahead pages reached the end of the file\");\n\t}\n\t \n\tif (i < vec_size) {\n\t\twhile (i < vec_size && !vec[i])\n\t\t\ti++;\n\t\tEXPECT_EQ(vec_size, i) {\n\t\t\tTH_LOG(\"Unexpected page in memory beyond readahead window\");\n\t\t}\n\t}\n\n\tmunmap(addr, FILE_SIZE);\nout_close:\n\tclose(fd);\nout_free:\n\tfree(vec);\n}\n\n\n \nTEST(check_tmpfs_mmap)\n{\n\tunsigned char *vec;\n\tint vec_size;\n\tchar *addr;\n\tint retval;\n\tint page_size;\n\tint fd;\n\tint i;\n\tint ra_pages = 0;\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tvec_size = FILE_SIZE / page_size;\n\tif (FILE_SIZE % page_size)\n\t\tvec_size++;\n\n\tvec = calloc(vec_size, sizeof(unsigned char));\n\tASSERT_NE(NULL, vec) {\n\t\tTH_LOG(\"Can't allocate array\");\n\t}\n\n\terrno = 0;\n\tfd = open(\"/dev/shm\", O_TMPFILE | O_RDWR, 0600);\n\tASSERT_NE(-1, fd) {\n\t\tTH_LOG(\"Can't create temporary file: %s\",\n\t\t\tstrerror(errno));\n\t}\n\terrno = 0;\n\tretval = fallocate(fd, 0, 0, FILE_SIZE);\n\tASSERT_EQ(0, retval) {\n\t\tTH_LOG(\"Error allocating space for the temporary file: %s\",\n\t\t\tstrerror(errno));\n\t}\n\n\t \n\terrno = 0;\n\taddr = mmap(NULL, FILE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED, fd, 0);\n\tASSERT_NE(MAP_FAILED, addr) {\n\t\tTH_LOG(\"mmap error: %s\", strerror(errno));\n\t}\n\tretval = mincore(addr, FILE_SIZE, vec);\n\tASSERT_EQ(0, retval);\n\tfor (i = 0; i < vec_size; i++) {\n\t\tASSERT_EQ(0, vec[i]) {\n\t\t\tTH_LOG(\"Unexpected page in memory\");\n\t\t}\n\t}\n\n\t \n\taddr[FILE_SIZE / 2] = 1;\n\tretval = mincore(addr, FILE_SIZE, vec);\n\tASSERT_EQ(0, retval);\n\tASSERT_EQ(1, vec[FILE_SIZE / 2 / page_size]) {\n\t\tTH_LOG(\"Page not found in memory after use\");\n\t}\n\n\ti = FILE_SIZE / 2 / page_size + 1;\n\twhile (i < vec_size && vec[i]) {\n\t\tra_pages++;\n\t\ti++;\n\t}\n\tASSERT_EQ(ra_pages, 0) {\n\t\tTH_LOG(\"Read-ahead pages found in memory\");\n\t}\n\n\tmunmap(addr, FILE_SIZE);\n\tclose(fd);\n\tfree(vec);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}