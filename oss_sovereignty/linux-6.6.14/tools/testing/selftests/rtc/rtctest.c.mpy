{
  "module_name": "rtctest.c",
  "hash_id": "440e519710451871dd421b4172c35a3265daaa297591c0db17d5ba5966d22aa8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rtc/rtctest.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/rtc.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\n#define NUM_UIE 3\n#define ALARM_DELTA 3\n#define READ_LOOP_DURATION_SEC 30\n#define READ_LOOP_SLEEP_MS 11\n\nstatic char *rtc_file = \"/dev/rtc0\";\n\nFIXTURE(rtc) {\n\tint fd;\n};\n\nFIXTURE_SETUP(rtc) {\n\tself->fd = open(rtc_file, O_RDONLY);\n}\n\nFIXTURE_TEARDOWN(rtc) {\n\tclose(self->fd);\n}\n\nTEST_F(rtc, date_read) {\n\tint rc;\n\tstruct rtc_time rtc_tm;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\t \n\trc = ioctl(self->fd, RTC_RD_TIME, &rtc_tm);\n\tASSERT_NE(-1, rc);\n\n\tTH_LOG(\"Current RTC date/time is %02d/%02d/%02d %02d:%02d:%02d.\",\n\t       rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,\n\t       rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);\n}\n\nstatic time_t rtc_time_to_timestamp(struct rtc_time *rtc_time)\n{\n\tstruct tm tm_time = {\n\t       .tm_sec = rtc_time->tm_sec,\n\t       .tm_min = rtc_time->tm_min,\n\t       .tm_hour = rtc_time->tm_hour,\n\t       .tm_mday = rtc_time->tm_mday,\n\t       .tm_mon = rtc_time->tm_mon,\n\t       .tm_year = rtc_time->tm_year,\n\t};\n\n\treturn mktime(&tm_time);\n}\n\nstatic void nanosleep_with_retries(long ns)\n{\n\tstruct timespec req = {\n\t\t.tv_sec = 0,\n\t\t.tv_nsec = ns,\n\t};\n\tstruct timespec rem;\n\n\twhile (nanosleep(&req, &rem) != 0) {\n\t\treq.tv_sec = rem.tv_sec;\n\t\treq.tv_nsec = rem.tv_nsec;\n\t}\n}\n\nTEST_F_TIMEOUT(rtc, date_read_loop, READ_LOOP_DURATION_SEC + 2) {\n\tint rc;\n\tlong iter_count = 0;\n\tstruct rtc_time rtc_tm;\n\ttime_t start_rtc_read, prev_rtc_read;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\tTH_LOG(\"Continuously reading RTC time for %ds (with %dms breaks after every read).\",\n\t       READ_LOOP_DURATION_SEC, READ_LOOP_SLEEP_MS);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &rtc_tm);\n\tASSERT_NE(-1, rc);\n\tstart_rtc_read = rtc_time_to_timestamp(&rtc_tm);\n\tprev_rtc_read = start_rtc_read;\n\n\tdo  {\n\t\ttime_t rtc_read;\n\n\t\trc = ioctl(self->fd, RTC_RD_TIME, &rtc_tm);\n\t\tASSERT_NE(-1, rc);\n\n\t\trtc_read = rtc_time_to_timestamp(&rtc_tm);\n\t\t \n\t\tASSERT_LE(prev_rtc_read, rtc_read);\n\t\t \n\t\tASSERT_GE(prev_rtc_read + 1, rtc_read);\n\n\t\t \n\t\tnanosleep_with_retries(READ_LOOP_SLEEP_MS * 1000000);\n\n\t\tprev_rtc_read = rtc_read;\n\t\titer_count++;\n\t} while (prev_rtc_read <= start_rtc_read + READ_LOOP_DURATION_SEC);\n\n\tTH_LOG(\"Performed %ld RTC time reads.\", iter_count);\n}\n\nTEST_F_TIMEOUT(rtc, uie_read, NUM_UIE + 2) {\n\tint i, rc, irq = 0;\n\tunsigned long data;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\t \n\trc = ioctl(self->fd, RTC_UIE_ON, 0);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip update IRQs not supported.\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NUM_UIE; i++) {\n\t\t \n\t\trc = read(self->fd, &data, sizeof(data));\n\t\tASSERT_NE(-1, rc);\n\t\tirq++;\n\t}\n\n\tEXPECT_EQ(NUM_UIE, irq);\n\n\trc = ioctl(self->fd, RTC_UIE_OFF, 0);\n\tASSERT_NE(-1, rc);\n}\n\nTEST_F(rtc, uie_select) {\n\tint i, rc, irq = 0;\n\tunsigned long data;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\t \n\trc = ioctl(self->fd, RTC_UIE_ON, 0);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip update IRQs not supported.\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NUM_UIE; i++) {\n\t\tstruct timeval tv = { .tv_sec = 2 };\n\t\tfd_set readfds;\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(self->fd, &readfds);\n\t\t \n\t\trc = select(self->fd + 1, &readfds, NULL, NULL, &tv);\n\t\tASSERT_NE(-1, rc);\n\t\tASSERT_NE(0, rc);\n\n\t\t \n\t\trc = read(self->fd, &data, sizeof(unsigned long));\n\t\tASSERT_NE(-1, rc);\n\t\tirq++;\n\t}\n\n\tEXPECT_EQ(NUM_UIE, irq);\n\n\trc = ioctl(self->fd, RTC_UIE_OFF, 0);\n\tASSERT_NE(-1, rc);\n}\n\nTEST_F(rtc, alarm_alm_set) {\n\tstruct timeval tv = { .tv_sec = ALARM_DELTA + 2 };\n\tunsigned long data;\n\tstruct rtc_time tm;\n\tfd_set readfds;\n\ttime_t secs, new;\n\tint rc;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tsecs = timegm((struct tm *)&tm) + ALARM_DELTA;\n\tgmtime_r(&secs, (struct tm *)&tm);\n\n\trc = ioctl(self->fd, RTC_ALM_SET, &tm);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip alarms are not supported.\");\n\t\treturn;\n\t}\n\n\trc = ioctl(self->fd, RTC_ALM_READ, &tm);\n\tASSERT_NE(-1, rc);\n\n\tTH_LOG(\"Alarm time now set to %02d:%02d:%02d.\",\n\t       tm.tm_hour, tm.tm_min, tm.tm_sec);\n\n\t \n\trc = ioctl(self->fd, RTC_AIE_ON, 0);\n\tASSERT_NE(-1, rc);\n\n\tFD_ZERO(&readfds);\n\tFD_SET(self->fd, &readfds);\n\n\trc = select(self->fd + 1, &readfds, NULL, NULL, &tv);\n\tASSERT_NE(-1, rc);\n\tASSERT_NE(0, rc);\n\n\t \n\trc = ioctl(self->fd, RTC_AIE_OFF, 0);\n\tASSERT_NE(-1, rc);\n\n\trc = read(self->fd, &data, sizeof(unsigned long));\n\tASSERT_NE(-1, rc);\n\tTH_LOG(\"data: %lx\", data);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tnew = timegm((struct tm *)&tm);\n\tASSERT_EQ(new, secs);\n}\n\nTEST_F(rtc, alarm_wkalm_set) {\n\tstruct timeval tv = { .tv_sec = ALARM_DELTA + 2 };\n\tstruct rtc_wkalrm alarm = { 0 };\n\tstruct rtc_time tm;\n\tunsigned long data;\n\tfd_set readfds;\n\ttime_t secs, new;\n\tint rc;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &alarm.time);\n\tASSERT_NE(-1, rc);\n\n\tsecs = timegm((struct tm *)&alarm.time) + ALARM_DELTA;\n\tgmtime_r(&secs, (struct tm *)&alarm.time);\n\n\talarm.enabled = 1;\n\n\trc = ioctl(self->fd, RTC_WKALM_SET, &alarm);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip alarms are not supported.\");\n\t\treturn;\n\t}\n\n\trc = ioctl(self->fd, RTC_WKALM_RD, &alarm);\n\tASSERT_NE(-1, rc);\n\n\tTH_LOG(\"Alarm time now set to %02d/%02d/%02d %02d:%02d:%02d.\",\n\t       alarm.time.tm_mday, alarm.time.tm_mon + 1,\n\t       alarm.time.tm_year + 1900, alarm.time.tm_hour,\n\t       alarm.time.tm_min, alarm.time.tm_sec);\n\n\tFD_ZERO(&readfds);\n\tFD_SET(self->fd, &readfds);\n\n\trc = select(self->fd + 1, &readfds, NULL, NULL, &tv);\n\tASSERT_NE(-1, rc);\n\tASSERT_NE(0, rc);\n\n\trc = read(self->fd, &data, sizeof(unsigned long));\n\tASSERT_NE(-1, rc);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tnew = timegm((struct tm *)&tm);\n\tASSERT_EQ(new, secs);\n}\n\nTEST_F_TIMEOUT(rtc, alarm_alm_set_minute, 65) {\n\tstruct timeval tv = { .tv_sec = 62 };\n\tunsigned long data;\n\tstruct rtc_time tm;\n\tfd_set readfds;\n\ttime_t secs, new;\n\tint rc;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tsecs = timegm((struct tm *)&tm) + 60 - tm.tm_sec;\n\tgmtime_r(&secs, (struct tm *)&tm);\n\n\trc = ioctl(self->fd, RTC_ALM_SET, &tm);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip alarms are not supported.\");\n\t\treturn;\n\t}\n\n\trc = ioctl(self->fd, RTC_ALM_READ, &tm);\n\tASSERT_NE(-1, rc);\n\n\tTH_LOG(\"Alarm time now set to %02d:%02d:%02d.\",\n\t       tm.tm_hour, tm.tm_min, tm.tm_sec);\n\n\t \n\trc = ioctl(self->fd, RTC_AIE_ON, 0);\n\tASSERT_NE(-1, rc);\n\n\tFD_ZERO(&readfds);\n\tFD_SET(self->fd, &readfds);\n\n\trc = select(self->fd + 1, &readfds, NULL, NULL, &tv);\n\tASSERT_NE(-1, rc);\n\tASSERT_NE(0, rc);\n\n\t \n\trc = ioctl(self->fd, RTC_AIE_OFF, 0);\n\tASSERT_NE(-1, rc);\n\n\trc = read(self->fd, &data, sizeof(unsigned long));\n\tASSERT_NE(-1, rc);\n\tTH_LOG(\"data: %lx\", data);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tnew = timegm((struct tm *)&tm);\n\tASSERT_EQ(new, secs);\n}\n\nTEST_F_TIMEOUT(rtc, alarm_wkalm_set_minute, 65) {\n\tstruct timeval tv = { .tv_sec = 62 };\n\tstruct rtc_wkalrm alarm = { 0 };\n\tstruct rtc_time tm;\n\tunsigned long data;\n\tfd_set readfds;\n\ttime_t secs, new;\n\tint rc;\n\n\tif (self->fd == -1 && errno == ENOENT)\n\t\tSKIP(return, \"Skipping test since %s does not exist\", rtc_file);\n\tASSERT_NE(-1, self->fd);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &alarm.time);\n\tASSERT_NE(-1, rc);\n\n\tsecs = timegm((struct tm *)&alarm.time) + 60 - alarm.time.tm_sec;\n\tgmtime_r(&secs, (struct tm *)&alarm.time);\n\n\talarm.enabled = 1;\n\n\trc = ioctl(self->fd, RTC_WKALM_SET, &alarm);\n\tif (rc == -1) {\n\t\tASSERT_EQ(EINVAL, errno);\n\t\tTH_LOG(\"skip alarms are not supported.\");\n\t\treturn;\n\t}\n\n\trc = ioctl(self->fd, RTC_WKALM_RD, &alarm);\n\tASSERT_NE(-1, rc);\n\n\tTH_LOG(\"Alarm time now set to %02d/%02d/%02d %02d:%02d:%02d.\",\n\t       alarm.time.tm_mday, alarm.time.tm_mon + 1,\n\t       alarm.time.tm_year + 1900, alarm.time.tm_hour,\n\t       alarm.time.tm_min, alarm.time.tm_sec);\n\n\tFD_ZERO(&readfds);\n\tFD_SET(self->fd, &readfds);\n\n\trc = select(self->fd + 1, &readfds, NULL, NULL, &tv);\n\tASSERT_NE(-1, rc);\n\tASSERT_NE(0, rc);\n\n\trc = read(self->fd, &data, sizeof(unsigned long));\n\tASSERT_NE(-1, rc);\n\n\trc = ioctl(self->fd, RTC_RD_TIME, &tm);\n\tASSERT_NE(-1, rc);\n\n\tnew = timegm((struct tm *)&tm);\n\tASSERT_EQ(new, secs);\n}\n\nstatic void __attribute__((constructor))\n__constructor_order_last(void)\n{\n\tif (!__constructor_order)\n\t\t__constructor_order = _CONSTRUCTOR_ORDER_BACKWARD;\n}\n\nint main(int argc, char **argv)\n{\n\tswitch (argc) {\n\tcase 2:\n\t\trtc_file = argv[1];\n\t\t \n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"usage: %s [rtcdev]\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}