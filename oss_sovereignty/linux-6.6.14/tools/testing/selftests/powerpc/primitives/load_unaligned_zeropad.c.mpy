{
  "module_name": "load_unaligned_zeropad.c",
  "hash_id": "8150cc9cfd3a6c005221f619276d8ae1bfc708b3da7bead6be6b4f56e1ca07e3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/primitives/load_unaligned_zeropad.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n#define FIXUP_SECTION \".ex_fixup\"\n\nstatic inline unsigned long __fls(unsigned long x);\n\n#include \"word-at-a-time.h\"\n\n#include \"utils.h\"\n\nstatic inline unsigned long __fls(unsigned long x)\n{\n\tint lz;\n\n\tasm (PPC_CNTLZL \"%0,%1\" : \"=r\" (lz) : \"r\" (x));\n\treturn sizeof(unsigned long) - 1 - lz;\n}\n\nstatic int page_size;\nstatic char *mem_region;\n\nstatic int protect_region(void)\n{\n\tif (mprotect(mem_region + page_size, page_size, PROT_NONE)) {\n\t\tperror(\"mprotect\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int unprotect_region(void)\n{\n\tif (mprotect(mem_region + page_size, page_size, PROT_READ|PROT_WRITE)) {\n\t\tperror(\"mprotect\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nextern char __start___ex_table[];\nextern char __stop___ex_table[];\n\nstruct extbl_entry {\n\tint insn;\n\tint fixup;\n};\n\nstatic void segv_handler(int signr, siginfo_t *info, void *ptr)\n{\n\tucontext_t *uc = (ucontext_t *)ptr;\n\tunsigned long addr = (unsigned long)info->si_addr;\n\tunsigned long *ip = &UCONTEXT_NIA(uc);\n\tstruct extbl_entry *entry = (struct extbl_entry *)__start___ex_table;\n\n\twhile (entry < (struct extbl_entry *)__stop___ex_table) {\n\t\tunsigned long insn, fixup;\n\n\t\tinsn  = (unsigned long)&entry->insn + entry->insn;\n\t\tfixup = (unsigned long)&entry->fixup + entry->fixup;\n\n\t\tif (insn == *ip) {\n\t\t\t*ip = fixup;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"No exception table match for NIA %lx ADDR %lx\\n\", *ip, addr);\n\tabort();\n}\n\nstatic void setup_segv_handler(void)\n{\n\tstruct sigaction action;\n\n\tmemset(&action, 0, sizeof(action));\n\taction.sa_sigaction = segv_handler;\n\taction.sa_flags = SA_SIGINFO;\n\tsigaction(SIGSEGV, &action, NULL);\n}\n\nstatic int do_one_test(char *p, int page_offset)\n{\n\tunsigned long should;\n\tunsigned long got;\n\n\tFAIL_IF(unprotect_region());\n\tshould = *(unsigned long *)p;\n\tFAIL_IF(protect_region());\n\n\tgot = load_unaligned_zeropad(p);\n\n\tif (should != got) {\n\t\tprintf(\"offset %u load_unaligned_zeropad returned 0x%lx, should be 0x%lx\\n\", page_offset, got, should);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_body(void)\n{\n\tunsigned long i;\n\n\tpage_size = getpagesize();\n\tmem_region = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,\n\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\n\tFAIL_IF(mem_region == MAP_FAILED);\n\n\tfor (i = 0; i < page_size; i++)\n\t\tmem_region[i] = i;\n\n\tmemset(mem_region+page_size, 0, page_size);\n\n\tsetup_segv_handler();\n\n\tfor (i = 0; i < page_size; i++)\n\t\tFAIL_IF(do_one_test(mem_region+i, i));\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test_body, \"load_unaligned_zeropad\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}