{
  "module_name": "alignment_handler.c",
  "hash_id": "8090a73d748dfd6194311b3bbb7374a812796316f84ea9f98753607963e98fb6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/alignment/alignment_handler.c",
  "human_readable_source": "\n \n\n \n\n\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <getopt.h>\n#include <setjmp.h>\n#include <signal.h>\n\n#include \"utils.h\"\n#include \"instructions.h\"\n\nint bufsize;\nint debug;\nint testing;\nvolatile int gotsig;\nbool prefixes_enabled;\nchar *cipath = \"/dev/fb0\";\nlong cioffset;\n\nvoid sighandler(int sig, siginfo_t *info, void *ctx)\n{\n\tucontext_t *ucp = ctx;\n\n\tif (!testing) {\n\t\tsignal(sig, SIG_DFL);\n\t\tkill(0, sig);\n\t}\n\tgotsig = sig;\n#ifdef __powerpc64__\n\tif (prefixes_enabled) {\n\t\tu32 inst = *(u32 *)ucp->uc_mcontext.gp_regs[PT_NIP];\n\t\tucp->uc_mcontext.gp_regs[PT_NIP] += ((inst >> 26 == 1) ? 8 : 4);\n\t} else {\n\t\tucp->uc_mcontext.gp_regs[PT_NIP] += 4;\n\t}\n#else\n\tucp->uc_mcontext.uc_regs->gregs[PT_NIP] += 4;\n#endif\n}\n\n#define XFORM(reg, n)  \" \" #reg \" ,%\"#n\",%2 ;\"\n#define DFORM(reg, n)  \" \" #reg \" ,0(%\"#n\") ;\"\n\n#define TEST(name, ld_op, st_op, form, ld_reg, st_reg)\t\t\\\n\tvoid test_##name(char *s, char *d)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tasm volatile(\t\t\t\t\t\\\n\t\t\t#ld_op form(ld_reg, 0)\t\t\t\\\n\t\t\t#st_op form(st_reg, 1)\t\t\t\\\n\t\t\t:: \"r\"(s), \"r\"(d), \"r\"(0)\t\t\\\n\t\t\t: \"memory\", \"vs0\", \"vs32\", \"r31\");\t\\\n\t}\t\t\t\t\t\t\t\\\n\trc |= do_test(#name, test_##name)\n\n#define TESTP(name, ld_op, st_op, ld_reg, st_reg)\t\t\\\n\tvoid test_##name(char *s, char *d)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tasm volatile(\t\t\t\t\t\\\n\t\t\tld_op(ld_reg, %0, 0, 0)\t\t\t\\\n\t\t\tst_op(st_reg, %1, 0, 0)\t\t\t\\\n\t\t\t:: \"r\"(s), \"r\"(d), \"r\"(0)\t\t\\\n\t\t\t: \"memory\", \"vs0\", \"vs32\", \"r31\");\t\\\n\t}\t\t\t\t\t\t\t\\\n\trc |= do_test(#name, test_##name)\n\n#define LOAD_VSX_XFORM_TEST(op) TEST(op, op, stxvd2x, XFORM, 32, 32)\n#define STORE_VSX_XFORM_TEST(op) TEST(op, lxvd2x, op, XFORM, 32, 32)\n#define LOAD_VSX_DFORM_TEST(op) TEST(op, op, stxv, DFORM, 32, 32)\n#define STORE_VSX_DFORM_TEST(op) TEST(op, lxv, op, DFORM, 32, 32)\n#define LOAD_VMX_XFORM_TEST(op) TEST(op, op, stxvd2x, XFORM, 0, 32)\n#define STORE_VMX_XFORM_TEST(op) TEST(op, lxvd2x, op, XFORM, 32, 0)\n#define LOAD_VMX_DFORM_TEST(op) TEST(op, op, stxv, DFORM, 0, 32)\n#define STORE_VMX_DFORM_TEST(op) TEST(op, lxv, op, DFORM, 32, 0)\n\n#define LOAD_XFORM_TEST(op) TEST(op, op, stdx, XFORM, 31, 31)\n#define STORE_XFORM_TEST(op) TEST(op, ldx, op, XFORM, 31, 31)\n#define LOAD_DFORM_TEST(op) TEST(op, op, std, DFORM, 31, 31)\n#define STORE_DFORM_TEST(op) TEST(op, ld, op, DFORM, 31, 31)\n\n#define LOAD_FLOAT_DFORM_TEST(op)  TEST(op, op, stfd, DFORM, 0, 0)\n#define STORE_FLOAT_DFORM_TEST(op) TEST(op, lfd, op, DFORM, 0, 0)\n#define LOAD_FLOAT_XFORM_TEST(op)  TEST(op, op, stfdx, XFORM, 0, 0)\n#define STORE_FLOAT_XFORM_TEST(op) TEST(op, lfdx, op, XFORM, 0, 0)\n\n#define LOAD_MLS_PREFIX_TEST(op) TESTP(op, op, PSTD, 31, 31)\n#define STORE_MLS_PREFIX_TEST(op) TESTP(op, PLD, op, 31, 31)\n\n#define LOAD_8LS_PREFIX_TEST(op) TESTP(op, op, PSTD, 31, 31)\n#define STORE_8LS_PREFIX_TEST(op) TESTP(op, PLD, op, 31, 31)\n\n#define LOAD_FLOAT_MLS_PREFIX_TEST(op) TESTP(op, op, PSTFD, 0, 0)\n#define STORE_FLOAT_MLS_PREFIX_TEST(op) TESTP(op, PLFD, op, 0, 0)\n\n#define LOAD_VSX_8LS_PREFIX_TEST(op, tail) TESTP(op, op, PSTXV ## tail, 0, 32)\n#define STORE_VSX_8LS_PREFIX_TEST(op, tail) TESTP(op, PLXV ## tail, op, 32, 0)\n\n \n\n\n\n\n\n\n\n \nvoid preload_data(void *dst, int offset, int width)\n{\n\tchar *c = dst;\n\tint i;\n\n\tc += offset;\n\n\tfor (i = 0 ; i < width ; i++)\n\t\tc[i] = i;\n}\n\nint test_memcpy(void *dst, void *src, int size, int offset,\n\t\tvoid (*test_func)(char *, char *))\n{\n\tchar *s, *d;\n\n\ts = src;\n\ts += offset;\n\td = dst;\n\td += offset;\n\n\tassert(size == 16);\n\tgotsig = 0;\n\ttesting = 1;\n\n\ttest_func(s, d);  \n\n\ttesting = 0;\n\tif (gotsig) {\n\t\tif (debug)\n\t\t\tprintf(\"  Got signal %i\\n\", gotsig);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid dumpdata(char *s1, char *s2, int n, char *test_name)\n{\n\tint i;\n\n\tprintf(\"  %s: unexpected result:\\n\", test_name);\n\tprintf(\"    mem:\");\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\" %02x\", s1[i]);\n\tprintf(\"\\n\");\n\tprintf(\"    ci: \");\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\" %02x\", s2[i]);\n\tprintf(\"\\n\");\n}\n\nint test_memcmp(void *s1, void *s2, int n, int offset, char *test_name)\n{\n\tchar *s1c, *s2c;\n\n\ts1c = s1;\n\ts1c += offset;\n\ts2c = s2;\n\ts2c += offset;\n\n\tif (memcmp(s1c, s2c, n)) {\n\t\tif (debug) {\n\t\t\tprintf(\"\\n  Compare failed. Offset:%i length:%i\\n\",\n\t\t\t       offset, n);\n\t\t\tdumpdata(s1c, s2c, n, test_name);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint do_test(char *test_name, void (*test_func)(char *, char *))\n{\n\tint offset, width, fd, rc, r;\n\tvoid *mem0, *mem1, *ci0, *ci1;\n\n\tprintf(\"\\tDoing %s:\\t\", test_name);\n\n\tfd = open(cipath, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"\\n\");\n\t\tperror(\"Can't open ci file now?\");\n\t\treturn 1;\n\t}\n\n\tci0 = mmap(NULL, bufsize, PROT_WRITE | PROT_READ, MAP_SHARED,\n\t\t   fd, cioffset);\n\tci1 = mmap(NULL, bufsize, PROT_WRITE | PROT_READ, MAP_SHARED,\n\t\t   fd, cioffset + bufsize);\n\n\tif ((ci0 == MAP_FAILED) || (ci1 == MAP_FAILED)) {\n\t\tprintf(\"\\n\");\n\t\tperror(\"mmap failed\");\n\t\tSKIP_IF(1);\n\t}\n\n\trc = posix_memalign(&mem0, bufsize, bufsize);\n\tif (rc) {\n\t\tprintf(\"\\n\");\n\t\treturn rc;\n\t}\n\n\trc = posix_memalign(&mem1, bufsize, bufsize);\n\tif (rc) {\n\t\tprintf(\"\\n\");\n\t\tfree(mem0);\n\t\treturn rc;\n\t}\n\n\trc = 0;\n\t \n\tfor (offset = 0; offset < 16; offset++) {\n\t\twidth = 16;  \n\t\tr = 0;\n\n\t\t \n\t\tpreload_data(ci0, offset, width);\n\t\tpreload_data(mem0, offset, width);  \n\t\tmemcpy(ci0, mem0, bufsize);\n\t\tmemcpy(ci1, mem1, bufsize);  \n\n\t\t \n\t\ttest_memcmp(mem0, ci0, width, offset, test_name);\n\n\t\tr |= test_memcpy(ci1,  ci0,  width, offset, test_func);\n\t\tr |= test_memcpy(mem1, mem0, width, offset, test_func);\n\t\tif (r && !debug) {\n\t\t\tprintf(\"FAILED: Got signal\");\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr |= test_memcmp(mem1, ci1, width, offset, test_name);\n\t\tif (r && !debug) {\n\t\t\tprintf(\"FAILED: Wrong Data\");\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\tprintf(\"PASSED\");\n\n\tprintf(\"\\n\");\n\n\tmunmap(ci0, bufsize);\n\tmunmap(ci1, bufsize);\n\tfree(mem0);\n\tfree(mem1);\n\tclose(fd);\n\n\treturn rc;\n}\n\nstatic bool can_open_cifile(void)\n{\n\tint fd;\n\n\tfd = open(cipath, O_RDWR);\n\tif (fd < 0)\n\t\treturn false;\n\n\tclose(fd);\n\treturn true;\n}\n\nint test_alignment_handler_vsx_206(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_ARCH_2_06));\n\n\tprintf(\"VSX: 2.06B\\n\");\n\tLOAD_VSX_XFORM_TEST(lxvd2x);\n\tLOAD_VSX_XFORM_TEST(lxvw4x);\n\tLOAD_VSX_XFORM_TEST(lxsdx);\n\tLOAD_VSX_XFORM_TEST(lxvdsx);\n\tSTORE_VSX_XFORM_TEST(stxvd2x);\n\tSTORE_VSX_XFORM_TEST(stxvw4x);\n\tSTORE_VSX_XFORM_TEST(stxsdx);\n\treturn rc;\n}\n\nint test_alignment_handler_vsx_207(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_2_07));\n\n\tprintf(\"VSX: 2.07B\\n\");\n\tLOAD_VSX_XFORM_TEST(lxsspx);\n\tLOAD_VSX_XFORM_TEST(lxsiwax);\n\tLOAD_VSX_XFORM_TEST(lxsiwzx);\n\tSTORE_VSX_XFORM_TEST(stxsspx);\n\tSTORE_VSX_XFORM_TEST(stxsiwx);\n\treturn rc;\n}\n\nint test_alignment_handler_vsx_300(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_3_00));\n\tprintf(\"VSX: 3.00B\\n\");\n\tLOAD_VMX_DFORM_TEST(lxsd);\n\tLOAD_VSX_XFORM_TEST(lxsibzx);\n\tLOAD_VSX_XFORM_TEST(lxsihzx);\n\tLOAD_VMX_DFORM_TEST(lxssp);\n\tLOAD_VSX_DFORM_TEST(lxv);\n\tLOAD_VSX_XFORM_TEST(lxvb16x);\n\tLOAD_VSX_XFORM_TEST(lxvh8x);\n\tLOAD_VSX_XFORM_TEST(lxvx);\n\tLOAD_VSX_XFORM_TEST(lxvwsx);\n\tLOAD_VSX_XFORM_TEST(lxvl);\n\tLOAD_VSX_XFORM_TEST(lxvll);\n\tSTORE_VMX_DFORM_TEST(stxsd);\n\tSTORE_VSX_XFORM_TEST(stxsibx);\n\tSTORE_VSX_XFORM_TEST(stxsihx);\n\tSTORE_VMX_DFORM_TEST(stxssp);\n\tSTORE_VSX_DFORM_TEST(stxv);\n\tSTORE_VSX_XFORM_TEST(stxvb16x);\n\tSTORE_VSX_XFORM_TEST(stxvh8x);\n\tSTORE_VSX_XFORM_TEST(stxvx);\n\tSTORE_VSX_XFORM_TEST(stxvl);\n\tSTORE_VSX_XFORM_TEST(stxvll);\n\treturn rc;\n}\n\nint test_alignment_handler_vsx_prefix(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_3_1));\n\n\tprintf(\"VSX: PREFIX\\n\");\n\tLOAD_VSX_8LS_PREFIX_TEST(PLXSD, 0);\n\tLOAD_VSX_8LS_PREFIX_TEST(PLXSSP, 0);\n\tLOAD_VSX_8LS_PREFIX_TEST(PLXV0, 0);\n\tLOAD_VSX_8LS_PREFIX_TEST(PLXV1, 1);\n\tSTORE_VSX_8LS_PREFIX_TEST(PSTXSD, 0);\n\tSTORE_VSX_8LS_PREFIX_TEST(PSTXSSP, 0);\n\tSTORE_VSX_8LS_PREFIX_TEST(PSTXV0, 0);\n\tSTORE_VSX_8LS_PREFIX_TEST(PSTXV1, 1);\n\treturn rc;\n}\n\nint test_alignment_handler_integer(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\n\tprintf(\"Integer\\n\");\n\tLOAD_DFORM_TEST(lbz);\n\tLOAD_DFORM_TEST(lbzu);\n\tLOAD_XFORM_TEST(lbzx);\n\tLOAD_XFORM_TEST(lbzux);\n\tLOAD_DFORM_TEST(lhz);\n\tLOAD_DFORM_TEST(lhzu);\n\tLOAD_XFORM_TEST(lhzx);\n\tLOAD_XFORM_TEST(lhzux);\n\tLOAD_DFORM_TEST(lha);\n\tLOAD_DFORM_TEST(lhau);\n\tLOAD_XFORM_TEST(lhax);\n\tLOAD_XFORM_TEST(lhaux);\n\tLOAD_XFORM_TEST(lhbrx);\n\tLOAD_DFORM_TEST(lwz);\n\tLOAD_DFORM_TEST(lwzu);\n\tLOAD_XFORM_TEST(lwzx);\n\tLOAD_XFORM_TEST(lwzux);\n\tLOAD_DFORM_TEST(lwa);\n\tLOAD_XFORM_TEST(lwax);\n\tLOAD_XFORM_TEST(lwaux);\n\tLOAD_XFORM_TEST(lwbrx);\n\tLOAD_DFORM_TEST(ld);\n\tLOAD_DFORM_TEST(ldu);\n\tLOAD_XFORM_TEST(ldx);\n\tLOAD_XFORM_TEST(ldux);\n\tSTORE_DFORM_TEST(stb);\n\tSTORE_XFORM_TEST(stbx);\n\tSTORE_DFORM_TEST(stbu);\n\tSTORE_XFORM_TEST(stbux);\n\tSTORE_DFORM_TEST(sth);\n\tSTORE_XFORM_TEST(sthx);\n\tSTORE_DFORM_TEST(sthu);\n\tSTORE_XFORM_TEST(sthux);\n\tSTORE_XFORM_TEST(sthbrx);\n\tSTORE_DFORM_TEST(stw);\n\tSTORE_XFORM_TEST(stwx);\n\tSTORE_DFORM_TEST(stwu);\n\tSTORE_XFORM_TEST(stwux);\n\tSTORE_XFORM_TEST(stwbrx);\n\tSTORE_DFORM_TEST(std);\n\tSTORE_XFORM_TEST(stdx);\n\tSTORE_DFORM_TEST(stdu);\n\tSTORE_XFORM_TEST(stdux);\n\n#ifdef __BIG_ENDIAN__\n\tLOAD_DFORM_TEST(lmw);\n\tSTORE_DFORM_TEST(stmw);\n#endif\n\n\treturn rc;\n}\n\nint test_alignment_handler_integer_206(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_ARCH_2_06));\n\n\tprintf(\"Integer: 2.06\\n\");\n\n\tLOAD_XFORM_TEST(ldbrx);\n\tSTORE_XFORM_TEST(stdbrx);\n\n\treturn rc;\n}\n\nint test_alignment_handler_integer_prefix(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_3_1));\n\n\tprintf(\"Integer: PREFIX\\n\");\n\tLOAD_MLS_PREFIX_TEST(PLBZ);\n\tLOAD_MLS_PREFIX_TEST(PLHZ);\n\tLOAD_MLS_PREFIX_TEST(PLHA);\n\tLOAD_MLS_PREFIX_TEST(PLWZ);\n\tLOAD_8LS_PREFIX_TEST(PLWA);\n\tLOAD_8LS_PREFIX_TEST(PLD);\n\tSTORE_MLS_PREFIX_TEST(PSTB);\n\tSTORE_MLS_PREFIX_TEST(PSTH);\n\tSTORE_MLS_PREFIX_TEST(PSTW);\n\tSTORE_8LS_PREFIX_TEST(PSTD);\n\treturn rc;\n}\n\nint test_alignment_handler_vmx(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_HAS_ALTIVEC));\n\n\tprintf(\"VMX\\n\");\n\tLOAD_VMX_XFORM_TEST(lvx);\n\n\t \n\tSTORE_VMX_XFORM_TEST(stvx);\n\tSTORE_VMX_XFORM_TEST(stvebx);\n\tSTORE_VMX_XFORM_TEST(stvehx);\n\tSTORE_VMX_XFORM_TEST(stvewx);\n\tSTORE_VMX_XFORM_TEST(stvxl);\n\treturn rc;\n}\n\nint test_alignment_handler_fp(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\n\tprintf(\"Floating point\\n\");\n\tLOAD_FLOAT_DFORM_TEST(lfd);\n\tLOAD_FLOAT_XFORM_TEST(lfdx);\n\tLOAD_FLOAT_DFORM_TEST(lfdu);\n\tLOAD_FLOAT_XFORM_TEST(lfdux);\n\tLOAD_FLOAT_DFORM_TEST(lfs);\n\tLOAD_FLOAT_XFORM_TEST(lfsx);\n\tLOAD_FLOAT_DFORM_TEST(lfsu);\n\tLOAD_FLOAT_XFORM_TEST(lfsux);\n\tSTORE_FLOAT_DFORM_TEST(stfd);\n\tSTORE_FLOAT_XFORM_TEST(stfdx);\n\tSTORE_FLOAT_DFORM_TEST(stfdu);\n\tSTORE_FLOAT_XFORM_TEST(stfdux);\n\tSTORE_FLOAT_DFORM_TEST(stfs);\n\tSTORE_FLOAT_XFORM_TEST(stfsx);\n\tSTORE_FLOAT_DFORM_TEST(stfsu);\n\tSTORE_FLOAT_XFORM_TEST(stfsux);\n\tSTORE_FLOAT_XFORM_TEST(stfiwx);\n\n\treturn rc;\n}\n\nint test_alignment_handler_fp_205(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_ARCH_2_05));\n\n\tprintf(\"Floating point: 2.05\\n\");\n\n\tLOAD_FLOAT_DFORM_TEST(lfdp);\n\tLOAD_FLOAT_XFORM_TEST(lfdpx);\n\tLOAD_FLOAT_XFORM_TEST(lfiwax);\n\tSTORE_FLOAT_DFORM_TEST(stfdp);\n\tSTORE_FLOAT_XFORM_TEST(stfdpx);\n\n\treturn rc;\n}\n\nint test_alignment_handler_fp_206(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_ARCH_2_06));\n\n\tprintf(\"Floating point: 2.06\\n\");\n\n\tLOAD_FLOAT_XFORM_TEST(lfiwzx);\n\n\treturn rc;\n}\n\n\nint test_alignment_handler_fp_prefix(void)\n{\n\tint rc = 0;\n\n\tSKIP_IF(!can_open_cifile());\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_3_1));\n\n\tprintf(\"Floating point: PREFIX\\n\");\n\tLOAD_FLOAT_DFORM_TEST(lfs);\n\tLOAD_FLOAT_MLS_PREFIX_TEST(PLFS);\n\tLOAD_FLOAT_MLS_PREFIX_TEST(PLFD);\n\tSTORE_FLOAT_MLS_PREFIX_TEST(PSTFS);\n\tSTORE_FLOAT_MLS_PREFIX_TEST(PSTFD);\n\treturn rc;\n}\n\nvoid usage(char *prog)\n{\n\tprintf(\"Usage: %s [options] [path [offset]]\\n\", prog);\n\tprintf(\"  -d\tEnable debug error output\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"This test requires a POWER8, POWER9 or POWER10 CPU \");\n\tprintf(\"and either a usable framebuffer at /dev/fb0 or \");\n\tprintf(\"the path to usable cache inhibited memory and optional \");\n\tprintf(\"offset to be provided\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n\n\tstruct sigaction sa;\n\tint rc = 0;\n\tint option = 0;\n\n\twhile ((option = getopt(argc, argv, \"d\")) != -1) {\n\t\tswitch (option) {\n\t\tcase 'd':\n\t\t\tdebug++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\texit(1);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc > 0)\n\t\tcipath = argv[0];\n\tif (argc > 1)\n\t\tcioffset = strtol(argv[1], 0, 0x10);\n\n\tbufsize = getpagesize();\n\n\tsa.sa_sigaction = sighandler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL) == -1\n\t    || sigaction(SIGBUS, &sa, NULL) == -1\n\t    || sigaction(SIGILL, &sa, NULL) == -1) {\n\t\tperror(\"sigaction\");\n\t\texit(1);\n\t}\n\n\tprefixes_enabled = have_hwcap2(PPC_FEATURE2_ARCH_3_1);\n\n\trc |= test_harness(test_alignment_handler_vsx_206,\n\t\t\t   \"test_alignment_handler_vsx_206\");\n\trc |= test_harness(test_alignment_handler_vsx_207,\n\t\t\t   \"test_alignment_handler_vsx_207\");\n\trc |= test_harness(test_alignment_handler_vsx_300,\n\t\t\t   \"test_alignment_handler_vsx_300\");\n\trc |= test_harness(test_alignment_handler_vsx_prefix,\n\t\t\t   \"test_alignment_handler_vsx_prefix\");\n\trc |= test_harness(test_alignment_handler_integer,\n\t\t\t   \"test_alignment_handler_integer\");\n\trc |= test_harness(test_alignment_handler_integer_206,\n\t\t\t   \"test_alignment_handler_integer_206\");\n\trc |= test_harness(test_alignment_handler_integer_prefix,\n\t\t\t   \"test_alignment_handler_integer_prefix\");\n\trc |= test_harness(test_alignment_handler_vmx,\n\t\t\t   \"test_alignment_handler_vmx\");\n\trc |= test_harness(test_alignment_handler_fp,\n\t\t\t   \"test_alignment_handler_fp\");\n\trc |= test_harness(test_alignment_handler_fp_205,\n\t\t\t   \"test_alignment_handler_fp_205\");\n\trc |= test_harness(test_alignment_handler_fp_206,\n\t\t\t   \"test_alignment_handler_fp_206\");\n\trc |= test_harness(test_alignment_handler_fp_prefix,\n\t\t\t   \"test_alignment_handler_fp_prefix\");\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}