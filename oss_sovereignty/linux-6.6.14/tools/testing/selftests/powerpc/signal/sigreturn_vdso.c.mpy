{
  "module_name": "sigreturn_vdso.c",
  "hash_id": "b25f3c530b1c63b12afcec18e404634f09ce474a179879639bfb9d799bb9b1b7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/signal/sigreturn_vdso.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n\n#undef NDEBUG\n#include <assert.h>\n\n#include \"utils.h\"\n\nstatic int search_proc_maps(char *needle, unsigned long *low, unsigned long *high)\n{\n\tunsigned long start, end;\n\tstatic char buf[4096];\n\tchar name[128];\n\tFILE *f;\n\tint rc = -1;\n\n\tf = fopen(\"/proc/self/maps\", \"r\");\n\tif (!f) {\n\t\tperror(\"fopen\");\n\t\treturn -1;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\trc = sscanf(buf, \"%lx-%lx %*c%*c%*c%*c %*x %*d:%*d %*d %127s\\n\",\n\t\t\t    &start, &end, name);\n\t\tif (rc == 2)\n\t\t\tcontinue;\n\n\t\tif (rc != 3) {\n\t\t\tprintf(\"sscanf errored\\n\");\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strstr(name, needle)) {\n\t\t\t*low = start;\n\t\t\t*high = end - 1;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\n\treturn rc;\n}\n\nstatic volatile sig_atomic_t took_signal = 0;\n\nstatic void sigusr1_handler(int sig)\n{\n\ttook_signal++;\n}\n\nint test_sigreturn_vdso(void)\n{\n\tunsigned long low, high, size;\n\tstruct sigaction act;\n\tchar *p;\n\n\tact.sa_handler = sigusr1_handler;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\n\n\tassert(sigaction(SIGUSR1, &act, NULL) == 0);\n\n\t\n\tassert(search_proc_maps(\"[vdso]\", &low, &high) == 0);\n\tsize = high - low + 1;\n\tprintf(\"VDSO is at 0x%lx-0x%lx (%lu bytes)\\n\", low, high, size);\n\n\tkill(getpid(), SIGUSR1);\n\tassert(took_signal == 1);\n\tprintf(\"Signal delivered OK with VDSO mapped\\n\");\n\n\t\n\tp = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\tassert(p != MAP_FAILED);\n\tassert(mremap((void *)low, size, size, MREMAP_MAYMOVE|MREMAP_FIXED, p) != MAP_FAILED);\n\tassert(search_proc_maps(\"[vdso]\", &low, &high) == 0);\n\tsize = high - low + 1;\n\tprintf(\"VDSO moved to 0x%lx-0x%lx (%lu bytes)\\n\", low, high, size);\n\n\tkill(getpid(), SIGUSR1);\n\tassert(took_signal == 2);\n\tprintf(\"Signal delivered OK with VDSO moved\\n\");\n\n\tassert(munmap((void *)low, size) == 0);\n\tprintf(\"Unmapped VDSO\\n\");\n\n\t\n\tassert(search_proc_maps(\"[vdso]\", &low, &high) != 0);\n\n\t\n\tassert(search_proc_maps(\"[stack]\", &low, &high) == 0);\n\tsize = high - low + 1;\n\tmprotect((void *)low, size, PROT_READ|PROT_WRITE|PROT_EXEC);\n\tprintf(\"Remapped the stack executable\\n\");\n\n\tkill(getpid(), SIGUSR1);\n\tassert(took_signal == 3);\n\tprintf(\"Signal delivered OK with VDSO unmapped\\n\");\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test_sigreturn_vdso, \"sigreturn_vdso\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}