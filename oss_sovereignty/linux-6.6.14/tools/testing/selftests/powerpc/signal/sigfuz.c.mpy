{
  "module_name": "sigfuz.c",
  "hash_id": "5df3fec72db775c79e9baeda1c82ebb3ff09baa20238a39b6254bd83289dfabe",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/signal/sigfuz.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <limits.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <ucontext.h>\n#include <sys/mman.h>\n#include <pthread.h>\n#include \"utils.h\"\n\n \n#define COUNT_MAX\t600\t\t \n#define THREADS\t\t16\t\t \n\n \n#define ARG_MESS_WITH_TM_AT\t0x1\n#define ARG_MESS_WITH_TM_BEFORE\t0x2\n#define ARG_MESS_WITH_MSR_AT\t0x4\n#define ARG_FOREVER\t\t0x10\n#define ARG_COMPLETE\t\t(ARG_MESS_WITH_TM_AT |\t\t\\\n\t\t\t\tARG_MESS_WITH_TM_BEFORE |\t\\\n\t\t\t\tARG_MESS_WITH_MSR_AT)\n\nstatic int args;\nstatic int nthread = THREADS;\nstatic int count_max = COUNT_MAX;\n\n \nstatic ucontext_t *tmp_uc;\n\n \nstatic int one_in_chance(int x)\n{\n\treturn rand() % x == 0;\n}\n\n \nstatic void mess_with_tm(void)\n{\n\t \n\tif (one_in_chance(3)) {\n\t\tasm (\"tbegin.\t;\"\n\t\t     \"beq 8\t;\");\n\n\t\t \n\t\tif (one_in_chance(2))\n\t\t\tasm(\"tsuspend.\t;\");\n\t}\n\n\t \n\tif (one_in_chance(20))\n\t\tasm(\"tend.\t;\");\n}\n\n \nstatic void trap_signal_handler(int signo, siginfo_t *si, void *uc)\n{\n\tucontext_t *ucp = uc;\n\n\tucp->uc_link = tmp_uc;\n\n\t \n\tif (one_in_chance(3)) {\n\t\tmemset(ucp->uc_link, rand(), sizeof(ucontext_t));\n\t} else if (one_in_chance(2)) {\n\t\tmemcpy(ucp->uc_link, uc, sizeof(ucontext_t));\n\t} else if (one_in_chance(2)) {\n\t\tif (tmp_uc) {\n\t\t\tfree(tmp_uc);\n\t\t\ttmp_uc = NULL;\n\t\t}\n\t\ttmp_uc = malloc(sizeof(ucontext_t));\n\t\tucp->uc_link = tmp_uc;\n\t\t \n\t\tmadvise(ucp->uc_link, sizeof(ucontext_t), MADV_DONTNEED);\n\t}\n\n\tif (args & ARG_MESS_WITH_MSR_AT) {\n\t\t \n\t\tif (one_in_chance(4)) {\n\t\t\tucp->uc_link->uc_mcontext.gp_regs[PT_MSR] |= MSR_TS_S;\n\t\t} else {\n\t\t\tif (one_in_chance(2)) {\n\t\t\t\tucp->uc_link->uc_mcontext.gp_regs[PT_MSR] |=\n\t\t\t\t\t\t MSR_TS_T;\n\t\t\t} else if (one_in_chance(2)) {\n\t\t\t\tucp->uc_link->uc_mcontext.gp_regs[PT_MSR] |=\n\t\t\t\t\t\tMSR_TS_T | MSR_TS_S;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (one_in_chance(2)) {\n\t\t\tucp->uc_mcontext.gp_regs[PT_MSR] |= MSR_TS_S;\n\t\t} else if (one_in_chance(2)) {\n\t\t\tif (one_in_chance(2))\n\t\t\t\tucp->uc_mcontext.gp_regs[PT_MSR] |=\n\t\t\t\t\tMSR_TS_T;\n\t\t\telse if (one_in_chance(2))\n\t\t\t\tucp->uc_mcontext.gp_regs[PT_MSR] |=\n\t\t\t\t\tMSR_TS_T | MSR_TS_S;\n\t\t}\n\t}\n\n\tif (one_in_chance(20)) {\n\t\t \n\t\tif (one_in_chance(5))\n\t\t\tmess_with_tm();\n\n\t\t \n\t\treturn;\n\t}\n\n\tif (one_in_chance(10))\n\t\tucp->uc_mcontext.gp_regs[PT_MSR] = random();\n\tif (one_in_chance(10))\n\t\tucp->uc_mcontext.gp_regs[PT_NIP] = random();\n\tif (one_in_chance(10))\n\t\tucp->uc_link->uc_mcontext.gp_regs[PT_MSR] = random();\n\tif (one_in_chance(10))\n\t\tucp->uc_link->uc_mcontext.gp_regs[PT_NIP] = random();\n\n\tucp->uc_mcontext.gp_regs[PT_TRAP] = random();\n\tucp->uc_mcontext.gp_regs[PT_DSISR] = random();\n\tucp->uc_mcontext.gp_regs[PT_DAR] = random();\n\tucp->uc_mcontext.gp_regs[PT_ORIG_R3] = random();\n\tucp->uc_mcontext.gp_regs[PT_XER] = random();\n\tucp->uc_mcontext.gp_regs[PT_RESULT] = random();\n\tucp->uc_mcontext.gp_regs[PT_SOFTE] = random();\n\tucp->uc_mcontext.gp_regs[PT_DSCR] = random();\n\tucp->uc_mcontext.gp_regs[PT_CTR] = random();\n\tucp->uc_mcontext.gp_regs[PT_LNK] = random();\n\tucp->uc_mcontext.gp_regs[PT_CCR] = random();\n\tucp->uc_mcontext.gp_regs[PT_REGS_COUNT] = random();\n\n\tucp->uc_link->uc_mcontext.gp_regs[PT_TRAP] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_DSISR] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_DAR] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_ORIG_R3] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_XER] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_RESULT] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_SOFTE] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_DSCR] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_CTR] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_LNK] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_CCR] = random();\n\tucp->uc_link->uc_mcontext.gp_regs[PT_REGS_COUNT] = random();\n\n\tif (args & ARG_MESS_WITH_TM_BEFORE) {\n\t\tif (one_in_chance(2))\n\t\t\tmess_with_tm();\n\t}\n}\n\nstatic void seg_signal_handler(int signo, siginfo_t *si, void *uc)\n{\n\t \n\texit(0);\n}\n\nstatic void *sigfuz_test(void *thrid)\n{\n\tstruct sigaction trap_sa, seg_sa;\n\tint ret, i = 0;\n\tpid_t t;\n\n\ttmp_uc = malloc(sizeof(ucontext_t));\n\n\t \n\ttrap_sa.sa_flags = SA_SIGINFO;\n\ttrap_sa.sa_sigaction = trap_signal_handler;\n\n\t \n\tseg_sa.sa_flags = SA_SIGINFO;\n\tseg_sa.sa_sigaction = seg_signal_handler;\n\n\t \n\tsigaction(SIGUSR1, &trap_sa, NULL);\n\n\t \n\tsigaction(SIGSEGV, &seg_sa, NULL);\n\n\twhile (i < count_max) {\n\t\tt = fork();\n\n\t\tif (t == 0) {\n\t\t\t \n\t\t\tsrand(time(NULL) + getpid());\n\t\t\tif (args & ARG_MESS_WITH_TM_AT) {\n\t\t\t\tif (one_in_chance(2))\n\t\t\t\t\tmess_with_tm();\n\t\t\t}\n\t\t\traise(SIGUSR1);\n\t\t\texit(0);\n\t\t} else {\n\t\t\twaitpid(t, &ret, 0);\n\t\t}\n\t\tif (!(args & ARG_FOREVER))\n\t\t\ti++;\n\t}\n\n\t \n\tif (tmp_uc) {\n\t\tfree(tmp_uc);\n\t\ttmp_uc = NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic int signal_fuzzer(void)\n{\n\tint t, rc;\n\tpthread_t *threads;\n\n\tthreads = malloc(nthread * sizeof(pthread_t));\n\n\tfor (t = 0; t < nthread; t++) {\n\t\trc = pthread_create(&threads[t], NULL, sigfuz_test,\n\t\t\t\t    (void *)&t);\n\t\tif (rc)\n\t\t\tperror(\"Thread creation error\\n\");\n\t}\n\n\tfor (t = 0; t < nthread; t++) {\n\t\trc = pthread_join(threads[t], NULL);\n\t\tif (rc)\n\t\t\tperror(\"Thread join error\\n\");\n\t}\n\n\tfree(threads);\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic void show_help(char *name)\n{\n\tprintf(\"%s: Sigfuzzer for powerpc\\n\", name);\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\t-b\\t Mess with TM before raising a SIGUSR1 signal\\n\");\n\tprintf(\"\\t-a\\t Mess with TM after raising a SIGUSR1 signal\\n\");\n\tprintf(\"\\t-m\\t Mess with MSR[TS] bits at mcontext\\n\");\n\tprintf(\"\\t-x\\t Mess with everything above\\n\");\n\tprintf(\"\\t-f\\t Run forever (Press ^C to Quit)\\n\");\n\tprintf(\"\\t-i\\t Amount of interactions.\t(Default = %d)\\n\", COUNT_MAX);\n\tprintf(\"\\t-t\\t Amount of threads.\t(Default = %d)\\n\", THREADS);\n\texit(-1);\n}\n\nint main(int argc, char **argv)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"bamxt:fi:h\")) != -1) {\n\t\tif (opt == 'b') {\n\t\t\tprintf(\"Mess with TM before signal\\n\");\n\t\t\targs |= ARG_MESS_WITH_TM_BEFORE;\n\t\t} else if (opt == 'a') {\n\t\t\tprintf(\"Mess with TM at signal handler\\n\");\n\t\t\targs |= ARG_MESS_WITH_TM_AT;\n\t\t} else if (opt == 'm') {\n\t\t\tprintf(\"Mess with MSR[TS] bits in mcontext\\n\");\n\t\t\targs |= ARG_MESS_WITH_MSR_AT;\n\t\t} else if (opt == 'x') {\n\t\t\tprintf(\"Running with all options enabled\\n\");\n\t\t\targs |= ARG_COMPLETE;\n\t\t} else if (opt == 't') {\n\t\t\tnthread = atoi(optarg);\n\t\t\tprintf(\"Threads = %d\\n\", nthread);\n\t\t} else if (opt == 'f') {\n\t\t\targs |= ARG_FOREVER;\n\t\t\tprintf(\"Press ^C to stop\\n\");\n\t\t\ttest_harness_set_timeout(-1);\n\t\t} else if (opt == 'i') {\n\t\t\tcount_max = atoi(optarg);\n\t\t\tprintf(\"Running for %d interactions\\n\", count_max);\n\t\t} else if (opt == 'h') {\n\t\t\tshow_help(argv[0]);\n\t\t}\n\t}\n\n\t \n\tif (!args)\n\t\targs = ARG_COMPLETE;\n\n\ttest_harness(signal_fuzzer, \"signal_fuzzer\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}