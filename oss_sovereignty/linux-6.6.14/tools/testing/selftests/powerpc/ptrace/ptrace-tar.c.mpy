{
  "module_name": "ptrace-tar.c",
  "hash_id": "9dc0f79ca7519d0a261434c25a078ee38f8a98a084284e42a1d4ef25aa2ff3dc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-tar.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"ptrace-tar.h\"\n\n \nint shm_id;\nint *cptr;\nint *pptr;\n\nvoid tar(void)\n{\n\tunsigned long reg[3];\n\tint ret;\n\n\tcptr = (int *)shmat(shm_id, NULL, 0);\n\tprintf(\"%-30s TAR: %u PPR: %lx DSCR: %u\\n\",\n\t\t\tuser_write, TAR_1, PPR_1, DSCR_1);\n\n\tmtspr(SPRN_TAR, TAR_1);\n\tmtspr(SPRN_PPR, PPR_1);\n\tmtspr(SPRN_DSCR, DSCR_1);\n\n\tcptr[2] = 1;\n\n\t \n\twhile (!cptr[0])\n\t\tasm volatile(\"\" : : : \"memory\");\n\n\treg[0] = mfspr(SPRN_TAR);\n\treg[1] = mfspr(SPRN_PPR);\n\treg[2] = mfspr(SPRN_DSCR);\n\n\tprintf(\"%-30s TAR: %lu PPR: %lx DSCR: %lu\\n\",\n\t\t\tuser_read, reg[0], reg[1], reg[2]);\n\n\t \n\tcptr[1] = 1;\n\tshmdt((int *)cptr);\n\n\tret = validate_tar_registers(reg, TAR_2, PPR_2, DSCR_2);\n\tif (ret)\n\t\texit(1);\n\texit(0);\n}\n\nint trace_tar(pid_t child)\n{\n\tunsigned long reg[3];\n\n\tFAIL_IF(start_trace(child));\n\tFAIL_IF(show_tar_registers(child, reg));\n\tprintf(\"%-30s TAR: %lu PPR: %lx DSCR: %lu\\n\",\n\t\t\tptrace_read_running, reg[0], reg[1], reg[2]);\n\n\tFAIL_IF(validate_tar_registers(reg, TAR_1, PPR_1, DSCR_1));\n\tFAIL_IF(stop_trace(child));\n\treturn TEST_PASS;\n}\n\nint trace_tar_write(pid_t child)\n{\n\tFAIL_IF(start_trace(child));\n\tFAIL_IF(write_tar_registers(child, TAR_2, PPR_2, DSCR_2));\n\tprintf(\"%-30s TAR: %u PPR: %lx DSCR: %u\\n\",\n\t\t\tptrace_write_running, TAR_2, PPR_2, DSCR_2);\n\n\tFAIL_IF(stop_trace(child));\n\treturn TEST_PASS;\n}\n\nint ptrace_tar(void)\n{\n\tpid_t pid;\n\tint ret, status;\n\n\t\n\tSKIP_IF_MSG(!have_hwcap2(PPC_FEATURE2_ARCH_2_07), \"TAR requires ISA 2.07 compatible hardware\");\n\n\tshm_id = shmget(IPC_PRIVATE, sizeof(int) * 3, 0777|IPC_CREAT);\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tif (pid == 0)\n\t\ttar();\n\n\tif (pid) {\n\t\tpptr = (int *)shmat(shm_id, NULL, 0);\n\t\tpptr[0] = 0;\n\t\tpptr[1] = 0;\n\n\t\twhile (!pptr[2])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\t\tret = trace_tar(pid);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = trace_tar_write(pid);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tpptr[0] = 1;\n\n\t\t \n\t\twhile (!pptr[1])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\n\t\tshmdt((int *)pptr);\n\n\t\tret = wait(&status);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\tif (ret != pid) {\n\t\t\tprintf(\"Child's exit status not captured\\n\");\n\t\t\treturn TEST_PASS;\n\t\t}\n\n\t\treturn (WIFEXITED(status) && WEXITSTATUS(status)) ? TEST_FAIL :\n\t\t\tTEST_PASS;\n\t}\n\treturn TEST_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_tar, \"ptrace_tar\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}