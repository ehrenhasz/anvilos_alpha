{
  "module_name": "ptrace-tm-spd-gpr.c",
  "hash_id": "28e8f939e3e0c0366533d156451b10a67c8f6e1818656e17ec756221598f4ec7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-tm-spd-gpr.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"ptrace-gpr.h\"\n#include \"tm.h\"\n\n \nint shm_id;\nint *cptr, *pptr;\n\ndouble a = FPR_1;\ndouble b = FPR_2;\ndouble c = FPR_3;\ndouble d = FPR_4;\n\n__attribute__((used)) void wait_parent(void)\n{\n\tcptr[2] = 1;\n\twhile (!cptr[1])\n\t\tasm volatile(\"\" : : : \"memory\");\n}\n\nvoid tm_spd_gpr(void)\n{\n\tunsigned long gpr_buf[18];\n\tunsigned long result, texasr;\n\tdouble fpr_buf[32];\n\n\tcptr = (int *)shmat(shm_id, NULL, 0);\n\ntrans:\n\tcptr[2] = 0;\n\tasm __volatile__(\n\t\tASM_LOAD_GPR_IMMED(gpr_1)\n\t\tASM_LOAD_FPR(flt_1)\n\n\t\t\"1: ;\"\n\t\t\"tbegin.;\"\n\t\t\"beq 2f;\"\n\n\t\tASM_LOAD_GPR_IMMED(gpr_2)\n\t\t\"tsuspend.;\"\n\t\tASM_LOAD_GPR_IMMED(gpr_4)\n\t\tASM_LOAD_FPR(flt_4)\n\n\t\t\"bl wait_parent;\"\n\t\t\"tresume.;\"\n\t\t\"tend.;\"\n\t\t\"li 0, 0;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"b 3f;\"\n\n\t\t \n\t\t\"2: ;\"\n\t\t\"li 0, 1;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"mfspr %[texasr], %[sprn_texasr];\"\n\n\t\t\"3: ;\"\n\t\t: [res] \"=r\" (result), [texasr] \"=r\" (texasr)\n\t\t: [gpr_1]\"i\"(GPR_1), [gpr_2]\"i\"(GPR_2), [gpr_4]\"i\"(GPR_4),\n\t\t[sprn_texasr] \"i\" (SPRN_TEXASR), [flt_1] \"b\" (&a),\n\t\t[flt_4] \"b\" (&d)\n\t\t: \"memory\", \"r0\", \"r5\", \"r6\", \"r7\",\n\t\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n\t\t\"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n\t\t\"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\"\n\t\t);\n\n\tif (result) {\n\t\tif (!cptr[0])\n\t\t\tgoto trans;\n\n\t\tshmdt((void *)cptr);\n\t\tstore_gpr(gpr_buf);\n\t\tstore_fpr(fpr_buf);\n\n\t\tif (validate_gpr(gpr_buf, GPR_3))\n\t\t\texit(1);\n\n\t\tif (validate_fpr_double(fpr_buf, c))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\tshmdt((void *)cptr);\n\texit(1);\n}\n\nint trace_tm_spd_gpr(pid_t child)\n{\n\tunsigned long gpr[18];\n\t__u64 fpr[32];\n\n\tFAIL_IF(start_trace(child));\n\tFAIL_IF(show_gpr(child, gpr));\n\tFAIL_IF(validate_gpr(gpr, GPR_4));\n\tFAIL_IF(show_fpr(child, fpr));\n\tFAIL_IF(validate_fpr(fpr, FPR_4_REP));\n\tFAIL_IF(show_ckpt_fpr(child, fpr));\n\tFAIL_IF(validate_fpr(fpr, FPR_1_REP));\n\tFAIL_IF(show_ckpt_gpr(child, gpr));\n\tFAIL_IF(validate_gpr(gpr, GPR_1));\n\tFAIL_IF(write_ckpt_gpr(child, GPR_3));\n\tFAIL_IF(write_ckpt_fpr(child, FPR_3_REP));\n\n\tpptr[0] = 1;\n\tpptr[1] = 1;\n\tFAIL_IF(stop_trace(child));\n\treturn TEST_PASS;\n}\n\nint ptrace_tm_spd_gpr(void)\n{\n\tpid_t pid;\n\tint ret, status;\n\n\tSKIP_IF_MSG(!have_htm(), \"Don't have transactional memory\");\n\tSKIP_IF_MSG(htm_is_synthetic(), \"Transactional memory is synthetic\");\n\tshm_id = shmget(IPC_PRIVATE, sizeof(int) * 3, 0777|IPC_CREAT);\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tif (pid == 0)\n\t\ttm_spd_gpr();\n\n\tif (pid) {\n\t\tpptr = (int *)shmat(shm_id, NULL, 0);\n\t\tpptr[0] = 0;\n\t\tpptr[1] = 0;\n\n\t\twhile (!pptr[2])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\t\tret = trace_tm_spd_gpr(pid);\n\t\tif (ret) {\n\t\t\tkill(pid, SIGTERM);\n\t\t\tshmdt((void *)pptr);\n\t\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\tshmdt((void *)pptr);\n\n\t\tret = wait(&status);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\tif (ret != pid) {\n\t\t\tprintf(\"Child's exit status not captured\\n\");\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\treturn (WIFEXITED(status) && WEXITSTATUS(status)) ? TEST_FAIL :\n\t\t\tTEST_PASS;\n\t}\n\treturn TEST_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_tm_spd_gpr, \"ptrace_tm_spd_gpr\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}