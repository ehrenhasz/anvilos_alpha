{
  "module_name": "perf-hwbreak.c",
  "hash_id": "a6a6a961a568b25410b5822dfc935b673d4a09755fe1b6e66f8ac9d85a2d1b28",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/perf-hwbreak.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <unistd.h>\n#include <assert.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/resource.h>\n#include <sys/sysinfo.h>\n#include <asm/ptrace.h>\n#include <elf.h>\n#include <pthread.h>\n#include <sys/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include \"utils.h\"\n\n#ifndef PPC_DEBUG_FEATURE_DATA_BP_ARCH_31\n#define PPC_DEBUG_FEATURE_DATA_BP_ARCH_31\t0x20\n#endif\n\n#define MAX_LOOPS 10000\n\n#define DAWR_LENGTH_MAX ((0x3f + 1) * 8)\n\nint nprocs;\n\nstatic volatile int a = 10;\nstatic volatile int b = 10;\nstatic volatile char c[512 + 8] __attribute__((aligned(512)));\n\nstatic void perf_event_attr_set(struct perf_event_attr *attr,\n\t\t\t\t__u32 type, __u64 addr, __u64 len,\n\t\t\t\tbool exclude_user)\n{\n\tmemset(attr, 0, sizeof(struct perf_event_attr));\n\tattr->type           = PERF_TYPE_BREAKPOINT;\n\tattr->size           = sizeof(struct perf_event_attr);\n\tattr->bp_type        = type;\n\tattr->bp_addr        = addr;\n\tattr->bp_len         = len;\n\tattr->exclude_kernel = 1;\n\tattr->exclude_hv     = 1;\n\tattr->exclude_guest  = 1;\n\tattr->exclude_user   = exclude_user;\n\tattr->disabled       = 1;\n}\n\nstatic int\nperf_process_event_open_exclude_user(__u32 type, __u64 addr, __u64 len, bool exclude_user)\n{\n\tstruct perf_event_attr attr;\n\n\tperf_event_attr_set(&attr, type, addr, len, exclude_user);\n\treturn syscall(__NR_perf_event_open, &attr, getpid(), -1, -1, 0);\n}\n\nstatic int perf_process_event_open(__u32 type, __u64 addr, __u64 len)\n{\n\tstruct perf_event_attr attr;\n\n\tperf_event_attr_set(&attr, type, addr, len, 0);\n\treturn syscall(__NR_perf_event_open, &attr, getpid(), -1, -1, 0);\n}\n\nstatic int perf_cpu_event_open(long cpu, __u32 type, __u64 addr, __u64 len)\n{\n\tstruct perf_event_attr attr;\n\n\tperf_event_attr_set(&attr, type, addr, len, 0);\n\treturn syscall(__NR_perf_event_open, &attr, -1, cpu, -1, 0);\n}\n\nstatic void close_fds(int *fd, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tclose(fd[i]);\n}\n\nstatic unsigned long read_fds(int *fd, int n)\n{\n\tint i;\n\tunsigned long c = 0;\n\tunsigned long count = 0;\n\tsize_t res;\n\n\tfor (i = 0; i < n; i++) {\n\t\tres = read(fd[i], &c, sizeof(c));\n\t\tassert(res == sizeof(unsigned long long));\n\t\tcount += c;\n\t}\n\treturn count;\n}\n\nstatic void reset_fds(int *fd, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tioctl(fd[i], PERF_EVENT_IOC_RESET);\n}\n\nstatic void enable_fds(int *fd, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tioctl(fd[i], PERF_EVENT_IOC_ENABLE);\n}\n\nstatic void disable_fds(int *fd, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tioctl(fd[i], PERF_EVENT_IOC_DISABLE);\n}\n\nstatic int perf_systemwide_event_open(int *fd, __u32 type, __u64 addr, __u64 len)\n{\n\tint i, ncpus, cpu, ret = 0;\n\tstruct rlimit rlim;\n\tcpu_set_t *mask;\n\tsize_t size;\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim)) {\n\t\tperror(\"getrlimit\");\n\t\treturn -1;\n\t}\n\trlim.rlim_cur = 65536;\n\tif (setrlimit(RLIMIT_NOFILE, &rlim)) {\n\t\tperror(\"setrlimit\");\n\t\treturn -1;\n\t}\n\n\tncpus = get_nprocs_conf();\n\tsize = CPU_ALLOC_SIZE(ncpus);\n\tmask = CPU_ALLOC(ncpus);\n\tif (!mask) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\n\tCPU_ZERO_S(size, mask);\n\n\tif (sched_getaffinity(0, size, mask)) {\n\t\tperror(\"sched_getaffinity\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0, cpu = 0; i < nprocs && cpu < ncpus; cpu++) {\n\t\tif (!CPU_ISSET_S(cpu, size, mask))\n\t\t\tcontinue;\n\t\tfd[i] = perf_cpu_event_open(cpu, type, addr, len);\n\t\tif (fd[i] < 0) {\n\t\t\tperror(\"perf_systemwide_event_open\");\n\t\t\tclose_fds(fd, i);\n\t\t\tret = fd[i];\n\t\t\tgoto done;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (i < nprocs) {\n\t\tprintf(\"Error: Number of online cpus reduced since start of test: %d < %d\\n\", i, nprocs);\n\t\tclose_fds(fd, i);\n\t\tret = -1;\n\t}\n\ndone:\n\tCPU_FREE(mask);\n\treturn ret;\n}\n\nstatic inline bool breakpoint_test(int len)\n{\n\tint fd;\n\n\t \n\tfd = perf_process_event_open(HW_BREAKPOINT_R, (__u64)(&fd) & 0xfffffffffffff800, len);\n\tif (fd < 0)\n\t\treturn false;\n\tclose(fd);\n\treturn true;\n}\n\nstatic inline bool perf_breakpoint_supported(void)\n{\n\treturn breakpoint_test(4);\n}\n\nstatic inline bool dawr_supported(void)\n{\n\treturn breakpoint_test(DAWR_LENGTH_MAX);\n}\n\nstatic int runtestsingle(int readwriteflag, int exclude_user, int arraytest)\n{\n\tint i,j;\n\tsize_t res;\n\tunsigned long long breaks, needed;\n\tint readint;\n\tint readintarraybig[2*DAWR_LENGTH_MAX/sizeof(int)];\n\tint *readintalign;\n\tvolatile int *ptr;\n\tint break_fd;\n\tint loop_num = MAX_LOOPS - (rand() % 100);  \n\tvolatile int *k;\n\t__u64 len;\n\n\t \n\treadintalign = (int *)(((unsigned long)readintarraybig + 0x7ff) &\n\t\t\t       0xfffffffffffff800);\n\n\tptr = &readint;\n\tif (arraytest)\n\t\tptr = &readintalign[0];\n\n\tlen = arraytest ? DAWR_LENGTH_MAX : sizeof(int);\n\tbreak_fd = perf_process_event_open_exclude_user(readwriteflag, (__u64)ptr,\n\t\t\t\t\t\t\tlen, exclude_user);\n\tif (break_fd < 0) {\n\t\tperror(\"perf_process_event_open_exclude_user\");\n\t\texit(1);\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\n\t \n\tk = &readint;\n\tfor (i = 0; i < loop_num; i++) {\n\t\tif (arraytest)\n\t\t\tk = &(readintalign[i % (DAWR_LENGTH_MAX/sizeof(int))]);\n\n\t\tj = *k;\n\t\t*k = j;\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\n\t \n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\t \n\tneeded = 0;\n\tif (readwriteflag & HW_BREAKPOINT_R)\n\t\tneeded += loop_num;\n\tif (readwriteflag & HW_BREAKPOINT_W)\n\t\tneeded += loop_num;\n\tneeded = needed * (1 - exclude_user);\n\tprintf(\"TESTED: addr:0x%lx brks:% 8lld loops:% 8i rw:%i !user:%i array:%i\\n\",\n\t       (unsigned long int)ptr, breaks, loop_num, readwriteflag, exclude_user, arraytest);\n\tif (breaks != needed) {\n\t\tprintf(\"FAILED: 0x%lx brks:%lld needed:%lli %i %i %i\\n\\n\",\n\t\t       (unsigned long int)ptr, breaks, needed, loop_num, readwriteflag, exclude_user);\n\t\treturn 1;\n\t}\n\tclose(break_fd);\n\n\treturn 0;\n}\n\nstatic int runtest_dar_outside(void)\n{\n\tvoid *target;\n\tvolatile __u16 temp16;\n\tvolatile __u64 temp64;\n\tint break_fd;\n\tunsigned long long breaks;\n\tint fail = 0;\n\tsize_t res;\n\n\ttarget = malloc(8);\n\tif (!target) {\n\t\tperror(\"malloc failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tbreak_fd = perf_process_event_open(HW_BREAKPOINT_RW, (__u64)(target + 2), 4);\n\tif (break_fd < 0) {\n\t\tfree(target);\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_RESET);\n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\ttemp16 = *((__u16 *)target);\n\t*((__u16 *)target) = temp16;\n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\tif (breaks == 0) {\n\t\tprintf(\"TESTED: No overlap\\n\");\n\t} else {\n\t\tprintf(\"FAILED: No overlap: %lld != 0\\n\", breaks);\n\t\tfail = 1;\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_RESET);\n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\ttemp16 = *((__u16 *)(target + 1));\n\t*((__u16 *)(target + 1)) = temp16;\n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\tif (breaks == 2) {\n\t\tprintf(\"TESTED: Partial overlap\\n\");\n\t} else {\n\t\tprintf(\"FAILED: Partial overlap: %lld != 2\\n\", breaks);\n\t\tfail = 1;\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_RESET);\n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\ttemp16 = *((__u16 *)(target + 5));\n\t*((__u16 *)(target + 5)) = temp16;\n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\tif (breaks == 2) {\n\t\tprintf(\"TESTED: Partial overlap\\n\");\n\t} else {\n\t\tprintf(\"FAILED: Partial overlap: %lld != 2\\n\", breaks);\n\t\tfail = 1;\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_RESET);\n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\ttemp16 = *((__u16 *)(target + 6));\n\t*((__u16 *)(target + 6)) = temp16;\n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\tif (breaks == 0) {\n\t\tprintf(\"TESTED: No overlap\\n\");\n\t} else {\n\t\tprintf(\"FAILED: No overlap: %lld != 0\\n\", breaks);\n\t\tfail = 1;\n\t}\n\n\t \n\tioctl(break_fd, PERF_EVENT_IOC_RESET);\n\tioctl(break_fd, PERF_EVENT_IOC_ENABLE);\n\ttemp64 = *((__u64 *)target);\n\t*((__u64 *)target) = temp64;\n\tioctl(break_fd, PERF_EVENT_IOC_DISABLE);\n\tres = read(break_fd, &breaks, sizeof(unsigned long long));\n\tassert(res == sizeof(unsigned long long));\n\tif (breaks == 2) {\n\t\tprintf(\"TESTED: Full overlap\\n\");\n\t} else {\n\t\tprintf(\"FAILED: Full overlap: %lld != 2\\n\", breaks);\n\t\tfail = 1;\n\t}\n\n\tfree(target);\n\tclose(break_fd);\n\treturn fail;\n}\n\nstatic void multi_dawr_workload(void)\n{\n\ta += 10;\n\tb += 10;\n\tc[512 + 1] += 'a';\n}\n\nstatic int test_process_multi_diff_addr(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint fd1, fd2;\n\tchar *desc = \"Process specific, Two events, diff addr\";\n\tsize_t res;\n\n\tfd1 = perf_process_event_open(HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (fd1 < 0) {\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd2 = perf_process_event_open(HW_BREAKPOINT_RW, (__u64)&b, (__u64)sizeof(b));\n\tif (fd2 < 0) {\n\t\tclose(fd1);\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tioctl(fd1, PERF_EVENT_IOC_RESET);\n\tioctl(fd2, PERF_EVENT_IOC_RESET);\n\tioctl(fd1, PERF_EVENT_IOC_ENABLE);\n\tioctl(fd2, PERF_EVENT_IOC_ENABLE);\n\tmulti_dawr_workload();\n\tioctl(fd1, PERF_EVENT_IOC_DISABLE);\n\tioctl(fd2, PERF_EVENT_IOC_DISABLE);\n\n\tres = read(fd1, &breaks1, sizeof(breaks1));\n\tassert(res == sizeof(unsigned long long));\n\tres = read(fd2, &breaks2, sizeof(breaks2));\n\tassert(res == sizeof(unsigned long long));\n\n\tclose(fd1);\n\tclose(fd2);\n\n\tif (breaks1 != 2 || breaks2 != 2) {\n\t\tprintf(\"FAILED: %s: %lld != 2 || %lld != 2\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_process_multi_same_addr(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint fd1, fd2;\n\tchar *desc = \"Process specific, Two events, same addr\";\n\tsize_t res;\n\n\tfd1 = perf_process_event_open(HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (fd1 < 0) {\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd2 = perf_process_event_open(HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (fd2 < 0) {\n\t\tclose(fd1);\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tioctl(fd1, PERF_EVENT_IOC_RESET);\n\tioctl(fd2, PERF_EVENT_IOC_RESET);\n\tioctl(fd1, PERF_EVENT_IOC_ENABLE);\n\tioctl(fd2, PERF_EVENT_IOC_ENABLE);\n\tmulti_dawr_workload();\n\tioctl(fd1, PERF_EVENT_IOC_DISABLE);\n\tioctl(fd2, PERF_EVENT_IOC_DISABLE);\n\n\tres = read(fd1, &breaks1, sizeof(breaks1));\n\tassert(res == sizeof(unsigned long long));\n\tres = read(fd2, &breaks2, sizeof(breaks2));\n\tassert(res == sizeof(unsigned long long));\n\n\tclose(fd1);\n\tclose(fd2);\n\n\tif (breaks1 != 2 || breaks2 != 2) {\n\t\tprintf(\"FAILED: %s: %lld != 2 || %lld != 2\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_process_multi_diff_addr_ro_wo(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint fd1, fd2;\n\tchar *desc = \"Process specific, Two events, diff addr, one is RO, other is WO\";\n\tsize_t res;\n\n\tfd1 = perf_process_event_open(HW_BREAKPOINT_W, (__u64)&a, (__u64)sizeof(a));\n\tif (fd1 < 0) {\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd2 = perf_process_event_open(HW_BREAKPOINT_R, (__u64)&b, (__u64)sizeof(b));\n\tif (fd2 < 0) {\n\t\tclose(fd1);\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tioctl(fd1, PERF_EVENT_IOC_RESET);\n\tioctl(fd2, PERF_EVENT_IOC_RESET);\n\tioctl(fd1, PERF_EVENT_IOC_ENABLE);\n\tioctl(fd2, PERF_EVENT_IOC_ENABLE);\n\tmulti_dawr_workload();\n\tioctl(fd1, PERF_EVENT_IOC_DISABLE);\n\tioctl(fd2, PERF_EVENT_IOC_DISABLE);\n\n\tres = read(fd1, &breaks1, sizeof(breaks1));\n\tassert(res == sizeof(unsigned long long));\n\tres = read(fd2, &breaks2, sizeof(breaks2));\n\tassert(res == sizeof(unsigned long long));\n\n\tclose(fd1);\n\tclose(fd2);\n\n\tif (breaks1 != 1 || breaks2 != 1) {\n\t\tprintf(\"FAILED: %s: %lld != 1 || %lld != 1\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_process_multi_same_addr_ro_wo(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint fd1, fd2;\n\tchar *desc = \"Process specific, Two events, same addr, one is RO, other is WO\";\n\tsize_t res;\n\n\tfd1 = perf_process_event_open(HW_BREAKPOINT_R, (__u64)&a, (__u64)sizeof(a));\n\tif (fd1 < 0) {\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd2 = perf_process_event_open(HW_BREAKPOINT_W, (__u64)&a, (__u64)sizeof(a));\n\tif (fd2 < 0) {\n\t\tclose(fd1);\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tioctl(fd1, PERF_EVENT_IOC_RESET);\n\tioctl(fd2, PERF_EVENT_IOC_RESET);\n\tioctl(fd1, PERF_EVENT_IOC_ENABLE);\n\tioctl(fd2, PERF_EVENT_IOC_ENABLE);\n\tmulti_dawr_workload();\n\tioctl(fd1, PERF_EVENT_IOC_DISABLE);\n\tioctl(fd2, PERF_EVENT_IOC_DISABLE);\n\n\tres = read(fd1, &breaks1, sizeof(breaks1));\n\tassert(res == sizeof(unsigned long long));\n\tres = read(fd2, &breaks2, sizeof(breaks2));\n\tassert(res == sizeof(unsigned long long));\n\n\tclose(fd1);\n\tclose(fd2);\n\n\tif (breaks1 != 1 || breaks2 != 1) {\n\t\tprintf(\"FAILED: %s: %lld != 1 || %lld != 1\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_syswide_multi_diff_addr(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint *fd1 = malloc(nprocs * sizeof(int));\n\tint *fd2 = malloc(nprocs * sizeof(int));\n\tchar *desc = \"Systemwide, Two events, diff addr\";\n\tint ret;\n\n\tret = perf_systemwide_event_open(fd1, HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\tret = perf_systemwide_event_open(fd2, HW_BREAKPOINT_RW, (__u64)&b, (__u64)sizeof(b));\n\tif (ret) {\n\t\tclose_fds(fd1, nprocs);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treset_fds(fd1, nprocs);\n\treset_fds(fd2, nprocs);\n\tenable_fds(fd1, nprocs);\n\tenable_fds(fd2, nprocs);\n\tmulti_dawr_workload();\n\tdisable_fds(fd1, nprocs);\n\tdisable_fds(fd2, nprocs);\n\n\tbreaks1 = read_fds(fd1, nprocs);\n\tbreaks2 = read_fds(fd2, nprocs);\n\n\tclose_fds(fd1, nprocs);\n\tclose_fds(fd2, nprocs);\n\n\tfree(fd1);\n\tfree(fd2);\n\n\tif (breaks1 != 2 || breaks2 != 2) {\n\t\tprintf(\"FAILED: %s: %lld != 2 || %lld != 2\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_syswide_multi_same_addr(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint *fd1 = malloc(nprocs * sizeof(int));\n\tint *fd2 = malloc(nprocs * sizeof(int));\n\tchar *desc = \"Systemwide, Two events, same addr\";\n\tint ret;\n\n\tret = perf_systemwide_event_open(fd1, HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\tret = perf_systemwide_event_open(fd2, HW_BREAKPOINT_RW, (__u64)&a, (__u64)sizeof(a));\n\tif (ret) {\n\t\tclose_fds(fd1, nprocs);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treset_fds(fd1, nprocs);\n\treset_fds(fd2, nprocs);\n\tenable_fds(fd1, nprocs);\n\tenable_fds(fd2, nprocs);\n\tmulti_dawr_workload();\n\tdisable_fds(fd1, nprocs);\n\tdisable_fds(fd2, nprocs);\n\n\tbreaks1 = read_fds(fd1, nprocs);\n\tbreaks2 = read_fds(fd2, nprocs);\n\n\tclose_fds(fd1, nprocs);\n\tclose_fds(fd2, nprocs);\n\n\tfree(fd1);\n\tfree(fd2);\n\n\tif (breaks1 != 2 || breaks2 != 2) {\n\t\tprintf(\"FAILED: %s: %lld != 2 || %lld != 2\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_syswide_multi_diff_addr_ro_wo(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint *fd1 = malloc(nprocs * sizeof(int));\n\tint *fd2 = malloc(nprocs * sizeof(int));\n\tchar *desc = \"Systemwide, Two events, diff addr, one is RO, other is WO\";\n\tint ret;\n\n\tret = perf_systemwide_event_open(fd1, HW_BREAKPOINT_W, (__u64)&a, (__u64)sizeof(a));\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\tret = perf_systemwide_event_open(fd2, HW_BREAKPOINT_R, (__u64)&b, (__u64)sizeof(b));\n\tif (ret) {\n\t\tclose_fds(fd1, nprocs);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treset_fds(fd1, nprocs);\n\treset_fds(fd2, nprocs);\n\tenable_fds(fd1, nprocs);\n\tenable_fds(fd2, nprocs);\n\tmulti_dawr_workload();\n\tdisable_fds(fd1, nprocs);\n\tdisable_fds(fd2, nprocs);\n\n\tbreaks1 = read_fds(fd1, nprocs);\n\tbreaks2 = read_fds(fd2, nprocs);\n\n\tclose_fds(fd1, nprocs);\n\tclose_fds(fd2, nprocs);\n\n\tfree(fd1);\n\tfree(fd2);\n\n\tif (breaks1 != 1 || breaks2 != 1) {\n\t\tprintf(\"FAILED: %s: %lld != 1 || %lld != 1\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int test_syswide_multi_same_addr_ro_wo(void)\n{\n\tunsigned long long breaks1 = 0, breaks2 = 0;\n\tint *fd1 = malloc(nprocs * sizeof(int));\n\tint *fd2 = malloc(nprocs * sizeof(int));\n\tchar *desc = \"Systemwide, Two events, same addr, one is RO, other is WO\";\n\tint ret;\n\n\tret = perf_systemwide_event_open(fd1, HW_BREAKPOINT_W, (__u64)&a, (__u64)sizeof(a));\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\tret = perf_systemwide_event_open(fd2, HW_BREAKPOINT_R, (__u64)&a, (__u64)sizeof(a));\n\tif (ret) {\n\t\tclose_fds(fd1, nprocs);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treset_fds(fd1, nprocs);\n\treset_fds(fd2, nprocs);\n\tenable_fds(fd1, nprocs);\n\tenable_fds(fd2, nprocs);\n\tmulti_dawr_workload();\n\tdisable_fds(fd1, nprocs);\n\tdisable_fds(fd2, nprocs);\n\n\tbreaks1 = read_fds(fd1, nprocs);\n\tbreaks2 = read_fds(fd2, nprocs);\n\n\tclose_fds(fd1, nprocs);\n\tclose_fds(fd2, nprocs);\n\n\tfree(fd1);\n\tfree(fd2);\n\n\tif (breaks1 != 1 || breaks2 != 1) {\n\t\tprintf(\"FAILED: %s: %lld != 1 || %lld != 1\\n\", desc, breaks1, breaks2);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\nstatic int runtest_multi_dawr(void)\n{\n\tint ret = 0;\n\n\tret |= test_process_multi_diff_addr();\n\tret |= test_process_multi_same_addr();\n\tret |= test_process_multi_diff_addr_ro_wo();\n\tret |= test_process_multi_same_addr_ro_wo();\n\tret |= test_syswide_multi_diff_addr();\n\tret |= test_syswide_multi_same_addr();\n\tret |= test_syswide_multi_diff_addr_ro_wo();\n\tret |= test_syswide_multi_same_addr_ro_wo();\n\n\treturn ret;\n}\n\nstatic int runtest_unaligned_512bytes(void)\n{\n\tunsigned long long breaks = 0;\n\tint fd;\n\tchar *desc = \"Process specific, 512 bytes, unaligned\";\n\t__u64 addr = (__u64)&c + 8;\n\tsize_t res;\n\n\tfd = perf_process_event_open(HW_BREAKPOINT_RW, addr, 512);\n\tif (fd < 0) {\n\t\tperror(\"perf_process_event_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tioctl(fd, PERF_EVENT_IOC_RESET);\n\tioctl(fd, PERF_EVENT_IOC_ENABLE);\n\tmulti_dawr_workload();\n\tioctl(fd, PERF_EVENT_IOC_DISABLE);\n\n\tres = read(fd, &breaks, sizeof(breaks));\n\tassert(res == sizeof(unsigned long long));\n\n\tclose(fd);\n\n\tif (breaks != 2) {\n\t\tprintf(\"FAILED: %s: %lld != 2\\n\", desc, breaks);\n\t\treturn 1;\n\t}\n\n\tprintf(\"TESTED: %s\\n\", desc);\n\treturn 0;\n}\n\n \nstatic int get_nr_wps(bool *arch_31)\n{\n\tstruct ppc_debug_info dbginfo;\n\tint child_pid;\n\n\tchild_pid = fork();\n\tif (!child_pid) {\n\t\tint ret = ptrace(PTRACE_TRACEME, 0, NULL, 0);\n\t\tif (ret) {\n\t\t\tperror(\"PTRACE_TRACEME failed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tkill(getpid(), SIGUSR1);\n\n\t\tsleep(1);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\twait(NULL);\n\tif (ptrace(PPC_PTRACE_GETHWDBGINFO, child_pid, NULL, &dbginfo)) {\n\t\tperror(\"Can't get breakpoint info\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t*arch_31 = !!(dbginfo.features & PPC_DEBUG_FEATURE_DATA_BP_ARCH_31);\n\treturn dbginfo.num_data_bps;\n}\n\nstatic int runtest(void)\n{\n\tint rwflag;\n\tint exclude_user;\n\tint ret;\n\tbool dawr = dawr_supported();\n\tbool arch_31 = false;\n\tint nr_wps = get_nr_wps(&arch_31);\n\n\t \n\tfor (rwflag = 1 ; rwflag < 4; rwflag++) {\n\t\tfor (exclude_user = 0 ; exclude_user < 2; exclude_user++) {\n\t\t\tret = runtestsingle(rwflag, exclude_user, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (!dawr)\n\t\t\t\tcontinue;\n\t\t\tret = runtestsingle(rwflag, exclude_user, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = runtest_dar_outside();\n\tif (ret)\n\t\treturn ret;\n\n\tif (dawr && nr_wps > 1) {\n\t\tnprocs = get_nprocs();\n\t\tret = runtest_multi_dawr();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dawr && arch_31)\n\t\tret = runtest_unaligned_512bytes();\n\n\treturn ret;\n}\n\n\nstatic int perf_hwbreak(void)\n{\n\tsrand ( time(NULL) );\n\n\tSKIP_IF_MSG(!perf_breakpoint_supported(), \"Perf breakpoints not supported\");\n\n\treturn runtest();\n}\n\nint main(int argc, char *argv[], char **envp)\n{\n\treturn test_harness(perf_hwbreak, \"perf_hwbreak\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}