{
  "module_name": "core-pkey.c",
  "hash_id": "c6d07cc54e4e05c41c7c49e2a522ea4198eb34846016f994feefec6b3cf84aff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/core-pkey.c",
  "human_readable_source": "\n \n#include <limits.h>\n#include <linux/kernel.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"ptrace.h\"\n#include \"child.h\"\n\n#ifndef __NR_pkey_alloc\n#define __NR_pkey_alloc\t\t384\n#endif\n\n#ifndef __NR_pkey_free\n#define __NR_pkey_free\t\t385\n#endif\n\n#ifndef NT_PPC_PKEY\n#define NT_PPC_PKEY\t\t0x110\n#endif\n\n#ifndef PKEY_DISABLE_EXECUTE\n#define PKEY_DISABLE_EXECUTE\t0x4\n#endif\n\n#define AMR_BITS_PER_PKEY 2\n#define PKEY_REG_BITS (sizeof(u64) * 8)\n#define pkeyshift(pkey) (PKEY_REG_BITS - ((pkey + 1) * AMR_BITS_PER_PKEY))\n\n#define CORE_FILE_LIMIT\t(5 * 1024 * 1024)\t \n\nstatic const char core_pattern_file[] = \"/proc/sys/kernel/core_pattern\";\n\nstatic const char user_write[] = \"[User Write (Running)]\";\nstatic const char core_read_running[] = \"[Core Read (Running)]\";\n\n \nstruct shared_info {\n\tstruct child_sync child_sync;\n\n\t \n\tunsigned long amr;\n\n\t \n\tunsigned long iamr;\n\n\t \n\tunsigned long uamor;\n\n\t \n\ttime_t core_time;\n};\n\nstatic int sys_pkey_alloc(unsigned long flags, unsigned long init_access_rights)\n{\n\treturn syscall(__NR_pkey_alloc, flags, init_access_rights);\n}\n\nstatic int sys_pkey_free(int pkey)\n{\n\treturn syscall(__NR_pkey_free, pkey);\n}\n\nstatic int increase_core_file_limit(void)\n{\n\tstruct rlimit rlim;\n\tint ret;\n\n\tret = getrlimit(RLIMIT_CORE, &rlim);\n\tFAIL_IF(ret);\n\n\tif (rlim.rlim_cur != RLIM_INFINITY && rlim.rlim_cur < CORE_FILE_LIMIT) {\n\t\trlim.rlim_cur = CORE_FILE_LIMIT;\n\n\t\tif (rlim.rlim_max != RLIM_INFINITY &&\n\t\t    rlim.rlim_max < CORE_FILE_LIMIT)\n\t\t\trlim.rlim_max = CORE_FILE_LIMIT;\n\n\t\tret = setrlimit(RLIMIT_CORE, &rlim);\n\t\tFAIL_IF(ret);\n\t}\n\n\tret = getrlimit(RLIMIT_FSIZE, &rlim);\n\tFAIL_IF(ret);\n\n\tif (rlim.rlim_cur != RLIM_INFINITY && rlim.rlim_cur < CORE_FILE_LIMIT) {\n\t\trlim.rlim_cur = CORE_FILE_LIMIT;\n\n\t\tif (rlim.rlim_max != RLIM_INFINITY &&\n\t\t    rlim.rlim_max < CORE_FILE_LIMIT)\n\t\t\trlim.rlim_max = CORE_FILE_LIMIT;\n\n\t\tret = setrlimit(RLIMIT_FSIZE, &rlim);\n\t\tFAIL_IF(ret);\n\t}\n\n\treturn TEST_PASS;\n}\n\nstatic int child(struct shared_info *info)\n{\n\tbool disable_execute = true;\n\tint pkey1, pkey2, pkey3;\n\tint *ptr, ret;\n\n\t \n\tret = wait_parent(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\tret = increase_core_file_limit();\n\tFAIL_IF(ret);\n\n\t \n\tpkey1 = sys_pkey_alloc(0, PKEY_DISABLE_EXECUTE);\n\tif (pkey1 < 0) {\n\t\tpkey1 = sys_pkey_alloc(0, 0);\n\t\tFAIL_IF(pkey1 < 0);\n\n\t\tdisable_execute = false;\n\t}\n\n\tpkey2 = sys_pkey_alloc(0, 0);\n\tFAIL_IF(pkey2 < 0);\n\n\tpkey3 = sys_pkey_alloc(0, 0);\n\tFAIL_IF(pkey3 < 0);\n\n\tinfo->amr |= 3ul << pkeyshift(pkey1) | 2ul << pkeyshift(pkey2);\n\n\tif (disable_execute)\n\t\tinfo->iamr |= 1ul << pkeyshift(pkey1);\n\telse\n\t\tinfo->iamr &= ~(1ul << pkeyshift(pkey1));\n\n\tinfo->iamr &= ~(1ul << pkeyshift(pkey2) | 1ul << pkeyshift(pkey3));\n\n\tinfo->uamor |= 3ul << pkeyshift(pkey1) | 3ul << pkeyshift(pkey2);\n\n\tprintf(\"%-30s AMR: %016lx pkey1: %d pkey2: %d pkey3: %d\\n\",\n\t       user_write, info->amr, pkey1, pkey2, pkey3);\n\n\tset_amr(info->amr);\n\n\t \n\tsys_pkey_free(pkey3);\n\n\tinfo->core_time = time(NULL);\n\n\t \n\tptr = 0;\n\t*ptr = 1;\n\n\t \n\tFAIL_IF(true);\n\n\treturn TEST_FAIL;\n}\n\n \nstatic off_t try_core_file(const char *filename, struct shared_info *info,\n\t\t\t   pid_t pid)\n{\n\tstruct stat buf;\n\tint ret;\n\n\tret = stat(filename, &buf);\n\tif (ret == -1)\n\t\treturn TEST_FAIL;\n\n\t \n\treturn buf.st_mtime >= info->core_time ? buf.st_size : TEST_FAIL;\n}\n\nstatic Elf64_Nhdr *next_note(Elf64_Nhdr *nhdr)\n{\n\treturn (void *) nhdr + sizeof(*nhdr) +\n\t\t__ALIGN_KERNEL(nhdr->n_namesz, 4) +\n\t\t__ALIGN_KERNEL(nhdr->n_descsz, 4);\n}\n\nstatic int check_core_file(struct shared_info *info, Elf64_Ehdr *ehdr,\n\t\t\t   off_t core_size)\n{\n\tunsigned long *regs;\n\tElf64_Phdr *phdr;\n\tElf64_Nhdr *nhdr;\n\tsize_t phdr_size;\n\tvoid *p = ehdr, *note;\n\tint ret;\n\n\tret = memcmp(ehdr->e_ident, ELFMAG, SELFMAG);\n\tFAIL_IF(ret);\n\n\tFAIL_IF(ehdr->e_type != ET_CORE);\n\tFAIL_IF(ehdr->e_machine != EM_PPC64);\n\tFAIL_IF(ehdr->e_phoff == 0 || ehdr->e_phnum == 0);\n\n\t \n\tphdr_size = sizeof(*phdr) * ehdr->e_phnum;\n\n\t \n\tFAIL_IF(ehdr->e_phoff + phdr_size < ehdr->e_phoff);\n\tFAIL_IF(ehdr->e_phoff + phdr_size > core_size);\n\n\t \n\tfor (phdr = p + ehdr->e_phoff;\n\t     (void *) phdr < p + ehdr->e_phoff + phdr_size;\n\t     phdr += ehdr->e_phentsize)\n\t\tif (phdr->p_type == PT_NOTE)\n\t\t\tbreak;\n\n\tFAIL_IF((void *) phdr >= p + ehdr->e_phoff + phdr_size);\n\n\t \n\tfor (nhdr = p + phdr->p_offset;\n\t     (void *) nhdr < p + phdr->p_offset + phdr->p_filesz;\n\t     nhdr = next_note(nhdr))\n\t\tif (nhdr->n_type == NT_PPC_PKEY)\n\t\t\tbreak;\n\n\tFAIL_IF((void *) nhdr >= p + phdr->p_offset + phdr->p_filesz);\n\tFAIL_IF(nhdr->n_descsz == 0);\n\n\tp = nhdr;\n\tnote = p + sizeof(*nhdr) + __ALIGN_KERNEL(nhdr->n_namesz, 4);\n\n\tregs = (unsigned long *) note;\n\n\tprintf(\"%-30s AMR: %016lx IAMR: %016lx UAMOR: %016lx\\n\",\n\t       core_read_running, regs[0], regs[1], regs[2]);\n\n\tFAIL_IF(regs[0] != info->amr);\n\tFAIL_IF(regs[1] != info->iamr);\n\tFAIL_IF(regs[2] != info->uamor);\n\n\treturn TEST_PASS;\n}\n\nstatic int parent(struct shared_info *info, pid_t pid)\n{\n\tchar *filenames, *filename[3];\n\tint fd, i, ret, status;\n\tunsigned long regs[3];\n\toff_t core_size;\n\tvoid *core;\n\n\t \n\tret = ptrace_read_regs(pid, NT_PPC_PKEY, regs, 3);\n\tPARENT_SKIP_IF_UNSUPPORTED(ret, &info->child_sync, \"PKEYs not supported\");\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tinfo->amr = regs[0];\n\tinfo->iamr = regs[1];\n\tinfo->uamor = regs[2];\n\n\t \n\tret = prod_child(&info->child_sync);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait(&status);\n\tif (ret != pid) {\n\t\tprintf(\"Child's exit status not captured\\n\");\n\t\treturn TEST_FAIL;\n\t} else if (!WIFSIGNALED(status) || !WCOREDUMP(status)) {\n\t\tprintf(\"Child didn't dump core\\n\");\n\t\treturn TEST_FAIL;\n\t}\n\n\t \n\n\tfilename[0] = filenames = malloc(PATH_MAX);\n\tif (!filenames) {\n\t\tperror(\"Error allocating memory\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tret = snprintf(filename[0], PATH_MAX, \"core-pkey.%d\", pid);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\n\tfilename[1] = filename[0] + ret + 1;\n\tret = snprintf(filename[1], PATH_MAX - ret - 1, \"core.%d\", pid);\n\tif (ret < 0 || ret >= PATH_MAX - ret - 1) {\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\tfilename[2] = \"core\";\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcore_size = try_core_file(filename[i], info, pid);\n\t\tif (core_size != TEST_FAIL)\n\t\t\tbreak;\n\t}\n\n\tif (i == 3) {\n\t\tprintf(\"Couldn't find core file\\n\");\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\n\tfd = open(filename[i], O_RDONLY);\n\tif (fd == -1) {\n\t\tperror(\"Error opening core file\");\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\n\tcore = mmap(NULL, core_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (core == (void *) -1) {\n\t\tperror(\"Error mmapping core file\");\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\n\tret = check_core_file(info, core, core_size);\n\n\tmunmap(core, core_size);\n\tclose(fd);\n\tunlink(filename[i]);\n\n out:\n\tfree(filenames);\n\n\treturn ret;\n}\n\nstatic int write_core_pattern(const char *core_pattern)\n{\n\tint err;\n\n\terr = write_file(core_pattern_file, core_pattern, strlen(core_pattern));\n\tif (err) {\n\t\tSKIP_IF_MSG(err == -EPERM, \"Try with root privileges\");\n\t\tperror(\"Error writing to core_pattern file\");\n\t\treturn TEST_FAIL;\n\t}\n\n\treturn TEST_PASS;\n}\n\nstatic int setup_core_pattern(char **core_pattern_, bool *changed_)\n{\n\tchar *core_pattern;\n\tsize_t len;\n\tint ret;\n\n\tcore_pattern = malloc(PATH_MAX);\n\tif (!core_pattern) {\n\t\tperror(\"Error allocating memory\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tret = read_file(core_pattern_file, core_pattern, PATH_MAX - 1, &len);\n\tif (ret) {\n\t\tperror(\"Error reading core_pattern file\");\n\t\tret = TEST_FAIL;\n\t\tgoto out;\n\t}\n\n\tcore_pattern[len] = '\\0';\n\n\t \n\tif (!strcmp(core_pattern, \"core\") || !strcmp(core_pattern, \"core.%p\"))\n\t\t*changed_ = false;\n\telse {\n\t\tret = write_core_pattern(\"core-pkey.%p\");\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t*changed_ = true;\n\t}\n\n\t*core_pattern_ = core_pattern;\n\tret = TEST_PASS;\n\n out:\n\tif (ret)\n\t\tfree(core_pattern);\n\n\treturn ret;\n}\n\nstatic int core_pkey(void)\n{\n\tchar *core_pattern;\n\tbool changed_core_pattern;\n\tstruct shared_info *info;\n\tint shm_id;\n\tint ret;\n\tpid_t pid;\n\n\tret = setup_core_pattern(&core_pattern, &changed_core_pattern);\n\tif (ret)\n\t\treturn ret;\n\n\tshm_id = shmget(IPC_PRIVATE, sizeof(*info), 0777 | IPC_CREAT);\n\tinfo = shmat(shm_id, NULL, 0);\n\n\tret = init_child_sync(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\tret = TEST_FAIL;\n\t} else if (pid == 0)\n\t\tret = child(info);\n\telse\n\t\tret = parent(info, pid);\n\n\tshmdt(info);\n\n\tif (pid) {\n\t\tdestroy_child_sync(&info->child_sync);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\n\t\tif (changed_core_pattern)\n\t\t\twrite_core_pattern(core_pattern);\n\t}\n\n\tfree(core_pattern);\n\n\treturn ret;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(core_pkey, \"core_pkey\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}