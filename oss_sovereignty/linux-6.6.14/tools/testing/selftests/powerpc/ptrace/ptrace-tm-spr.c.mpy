{
  "module_name": "ptrace-tm-spr.c",
  "hash_id": "b541224794ca35bad1a6db264559e5c47a8dac09aa5dc6a4c7bd813ef257b40b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-tm-spr.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"tm.h\"\n\n \nstruct shared {\n\tint flag;\n\tstruct tm_spr_regs regs;\n};\nunsigned long tfhar;\n\nint shm_id;\nstruct shared *cptr, *pptr;\n\nint shm_id1;\nint *cptr1, *pptr1;\n\n#define TM_KVM_SCHED   0xe0000001ac000001\nint validate_tm_spr(struct tm_spr_regs *regs)\n{\n\tFAIL_IF(regs->tm_tfhar != tfhar);\n\tFAIL_IF((regs->tm_texasr == TM_KVM_SCHED) && (regs->tm_tfiar != 0));\n\n\treturn TEST_PASS;\n}\n\nvoid tm_spr(void)\n{\n\tunsigned long result, texasr;\n\tint ret;\n\n\tcptr = (struct shared *)shmat(shm_id, NULL, 0);\n\tcptr1 = (int *)shmat(shm_id1, NULL, 0);\n\ntrans:\n\tcptr1[0] = 0;\n\tasm __volatile__(\n\t\t\"1: ;\"\n\t\t \n\t\t\"mflr 31;\"\n\t\t\"bl 4f;\"\t \n\t\t\"4: ;\"\n\t\t\"mflr %[tfhar];\"\n\t\t\"mtlr 31;\"\n\n\t\t\"tbegin.;\"\n\t\t\"beq 2f;\"\n\n\t\t\"tsuspend.;\"\n\t\t\"li 8, 1;\"\n\t\t\"sth 8, 0(%[cptr1]);\"\n\t\t\"tresume.;\"\n\t\t\"b .;\"\n\n\t\t\"tend.;\"\n\t\t\"li 0, 0;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"b 3f;\"\n\n\t\t\"2: ;\"\n\n\t\t\"li 0, 1;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"mfspr %[texasr], %[sprn_texasr];\"\n\n\t\t\"3: ;\"\n\t\t: [tfhar] \"=r\" (tfhar), [res] \"=r\" (result),\n\t\t[texasr] \"=r\" (texasr), [cptr1] \"=b\" (cptr1)\n\t\t: [sprn_texasr] \"i\"  (SPRN_TEXASR)\n\t\t: \"memory\", \"r0\", \"r8\", \"r31\"\n\t\t);\n\n\t \n\ttfhar += 12;\n\n\tif (result) {\n\t\tif (!cptr->flag)\n\t\t\tgoto trans;\n\n\t\tret = validate_tm_spr((struct tm_spr_regs *)&cptr->regs);\n\t\tshmdt((void *)cptr);\n\t\tshmdt((void *)cptr1);\n\t\tif (ret)\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\tshmdt((void *)cptr);\n\tshmdt((void *)cptr1);\n\texit(1);\n}\n\nint trace_tm_spr(pid_t child)\n{\n\tFAIL_IF(start_trace(child));\n\tFAIL_IF(show_tm_spr(child, (struct tm_spr_regs *)&pptr->regs));\n\n\tprintf(\"TFHAR: %lx TEXASR: %lx TFIAR: %lx\\n\", pptr->regs.tm_tfhar,\n\t\t\t\tpptr->regs.tm_texasr, pptr->regs.tm_tfiar);\n\n\tpptr->flag = 1;\n\tFAIL_IF(stop_trace(child));\n\n\treturn TEST_PASS;\n}\n\nint ptrace_tm_spr(void)\n{\n\tpid_t pid;\n\tint ret, status;\n\n\tSKIP_IF_MSG(!have_htm(), \"Don't have transactional memory\");\n\tSKIP_IF_MSG(htm_is_synthetic(), \"Transactional memory is synthetic\");\n\tshm_id = shmget(IPC_PRIVATE, sizeof(struct shared), 0777|IPC_CREAT);\n\tshm_id1 = shmget(IPC_PRIVATE, sizeof(int), 0777|IPC_CREAT);\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tif (pid == 0)\n\t\ttm_spr();\n\n\tif (pid) {\n\t\tpptr = (struct shared *)shmat(shm_id, NULL, 0);\n\t\tpptr1 = (int *)shmat(shm_id1, NULL, 0);\n\n\t\twhile (!pptr1[0])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\t\tret = trace_tm_spr(pid);\n\t\tif (ret) {\n\t\t\tkill(pid, SIGKILL);\n\t\t\tshmdt((void *)pptr);\n\t\t\tshmdt((void *)pptr1);\n\t\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\t\tshmctl(shm_id1, IPC_RMID, NULL);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\tshmdt((void *)pptr);\n\t\tshmdt((void *)pptr1);\n\t\tret = wait(&status);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\tshmctl(shm_id1, IPC_RMID, NULL);\n\t\tif (ret != pid) {\n\t\t\tprintf(\"Child's exit status not captured\\n\");\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\treturn (WIFEXITED(status) && WEXITSTATUS(status)) ? TEST_FAIL :\n\t\t\tTEST_PASS;\n\t}\n\treturn TEST_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_tm_spr, \"ptrace_tm_spr\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}