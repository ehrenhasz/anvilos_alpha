{
  "module_name": "ptrace-vsx.h",
  "hash_id": "aea2246fc14bdc3659b3d97921bfe60246d357f686fa20b0c5aacd979f2b8d04",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-vsx.h",
  "human_readable_source": " \n \n#define VEC_MAX 128\n#define VSX_MAX 32\n#define VMX_MAX 32\n\n \nint validate_vsx(unsigned long *vsx, unsigned long *load)\n{\n\tint i;\n\n\tfor (i = 0; i < VSX_MAX; i++) {\n\t\tif (vsx[i] != load[2 * i + 1]) {\n\t\t\tprintf(\"vsx[%d]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, vsx[i], 2 * i + 1, load[2 * i + 1]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t}\n\treturn TEST_PASS;\n}\n\n \nint validate_vmx(unsigned long vmx[][2], unsigned long *load)\n{\n\tint i;\n\n\tfor (i = 0; i < VMX_MAX; i++) {\n\t\t#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\t\tif ((vmx[i][0] != load[64 + 2 * i]) ||\n\t\t\t\t(vmx[i][1] != load[65 + 2 * i])) {\n\t\t\tprintf(\"vmx[%d][0]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, vmx[i][0], 64 + 2 * i,\n\t\t\t\t\tload[64 + 2 * i]);\n\t\t\tprintf(\"vmx[%d][1]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, vmx[i][1], 65 + 2 * i,\n\t\t\t\t\tload[65 + 2 * i]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t\t#else   \n\t\tif ((vmx[i][0] != load[65 + 2 * i]) ||\n\t\t\t\t(vmx[i][1] != load[64 + 2 * i])) {\n\t\t\tprintf(\"vmx[%d][0]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, vmx[i][0], 65 + 2 * i,\n\t\t\t\t\tload[65 + 2 * i]);\n\t\t\tprintf(\"vmx[%d][1]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, vmx[i][1], 64 + 2 * i,\n\t\t\t\t\tload[64 + 2 * i]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t\t#endif\n\t}\n\treturn TEST_PASS;\n}\n\n \nint compare_vsx_vmx(unsigned long *store, unsigned long *load)\n{\n\tint i;\n\n\tfor (i = 0; i < VSX_MAX; i++) {\n\t\tif (store[1 + 2 * i] != load[1 + 2 * i]) {\n\t\t\tprintf(\"store[%d]: %lx load[%d] %lx\\n\",\n\t\t\t\t\t1 + 2 * i, store[i],\n\t\t\t\t\t1 + 2 * i, load[i]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t}\n\n\t#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tfor (i = 64; i < VEC_MAX; i++) {\n\t\tif (store[i] != load[i]) {\n\t\t\tprintf(\"store[%d]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, store[i], i, load[i]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t}\n\t#else\t \n\tfor (i = 64; i < VEC_MAX; i++) {\n\t\tif (!(i % 2) && (store[i] != load[i+1])) {\n\t\t\tprintf(\"store[%d]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, store[i], i+1, load[i+1]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t\tif ((i % 2) && (store[i] != load[i-1])) {\n\t\t\tprintf(\"here store[%d]: %lx load[%d] %lx\\n\",\n\t\t\t\t\ti, store[i], i-1, load[i-1]);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\t}\n\t#endif\n\treturn TEST_PASS;\n}\n\nvoid load_vsx_vmx(unsigned long *load, unsigned long *vsx,\n\t\tunsigned long vmx[][2])\n{\n\tint i;\n\n\tfor (i = 0; i < VSX_MAX; i++)\n\t\tvsx[i] = load[1 + 2 * i];\n\n\tfor (i = 0; i < VMX_MAX; i++) {\n\t\tvmx[i][0] = load[64 + 2 * i];\n\t\tvmx[i][1] = load[65 + 2 * i];\n\t}\n}\n\nvoid loadvsx(void *p, int tmp);\nvoid storevsx(void *p, int tmp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}