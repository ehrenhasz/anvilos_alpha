{
  "module_name": "ptrace-perf-hwbreak.c",
  "hash_id": "9f237dc70ea69b9d8d034950bdecc4de7a3bc6b51140fb0f525e298ffb2cc564",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-perf-hwbreak.c",
  "human_readable_source": "\n\n#include <asm/unistd.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ptrace.h>\n#include <memory.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n\n#include \"utils.h\"\n\n \nvoid same_watch_addr_child(unsigned long *addr);\n\n \nextern char same_watch_addr_load[];\n\n \nextern char same_watch_addr_trap[];\n\n \nvoid perf_then_ptrace_child(unsigned long *first_addr, unsigned long *second_addr);\n\n \nextern char perf_then_ptrace_load1[];\n\n \nextern char perf_then_ptrace_load2[];\n\n \nextern char perf_then_ptrace_trap[];\n\nstatic inline long sys_ptrace(long request, pid_t pid, unsigned long addr, unsigned long data)\n{\n\treturn syscall(__NR_ptrace, request, pid, addr, data);\n}\n\nstatic long ptrace_traceme(void)\n{\n\treturn sys_ptrace(PTRACE_TRACEME, 0, 0, 0);\n}\n\nstatic long ptrace_getregs(pid_t pid, struct pt_regs *result)\n{\n\treturn sys_ptrace(PTRACE_GETREGS, pid, 0, (unsigned long)result);\n}\n\nstatic long ptrace_setregs(pid_t pid, struct pt_regs *result)\n{\n\treturn sys_ptrace(PTRACE_SETREGS, pid, 0, (unsigned long)result);\n}\n\nstatic long ptrace_cont(pid_t pid, long signal)\n{\n\treturn sys_ptrace(PTRACE_CONT, pid, 0, signal);\n}\n\nstatic long ptrace_singlestep(pid_t pid, long signal)\n{\n\treturn sys_ptrace(PTRACE_SINGLESTEP, pid, 0, signal);\n}\n\nstatic long ppc_ptrace_gethwdbginfo(pid_t pid, struct ppc_debug_info *dbginfo)\n{\n\treturn sys_ptrace(PPC_PTRACE_GETHWDBGINFO, pid, 0, (unsigned long)dbginfo);\n}\n\nstatic long ppc_ptrace_sethwdbg(pid_t pid, struct ppc_hw_breakpoint *bp_info)\n{\n\treturn sys_ptrace(PPC_PTRACE_SETHWDEBUG, pid, 0, (unsigned long)bp_info);\n}\n\nstatic long ppc_ptrace_delhwdbg(pid_t pid, int bp_id)\n{\n\treturn sys_ptrace(PPC_PTRACE_DELHWDEBUG, pid, 0L, bp_id);\n}\n\nstatic long ptrace_getreg_pc(pid_t pid, void **pc)\n{\n\tstruct pt_regs regs;\n\tlong err;\n\n\terr = ptrace_getregs(pid, &regs);\n\tif (err)\n\t\treturn err;\n\n\t*pc = (void *)regs.nip;\n\n\treturn 0;\n}\n\nstatic long ptrace_setreg_pc(pid_t pid, void *pc)\n{\n\tstruct pt_regs regs;\n\tlong err;\n\n\terr = ptrace_getregs(pid, &regs);\n\tif (err)\n\t\treturn err;\n\n\tregs.nip = (unsigned long)pc;\n\n\terr = ptrace_setregs(pid, &regs);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int perf_event_open(struct perf_event_attr *attr, pid_t pid, int cpu,\n\t\t\t   int group_fd, unsigned long flags)\n{\n\treturn syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);\n}\n\nstatic void perf_user_event_attr_set(struct perf_event_attr *attr, void *addr, u64 len)\n{\n\tmemset(attr, 0, sizeof(struct perf_event_attr));\n\n\tattr->type\t\t= PERF_TYPE_BREAKPOINT;\n\tattr->size\t\t= sizeof(struct perf_event_attr);\n\tattr->bp_type\t\t= HW_BREAKPOINT_R;\n\tattr->bp_addr\t\t= (u64)addr;\n\tattr->bp_len\t\t= len;\n\tattr->exclude_kernel\t= 1;\n\tattr->exclude_hv\t= 1;\n}\n\nstatic int perf_watchpoint_open(pid_t child_pid, void *addr, u64 len)\n{\n\tstruct perf_event_attr attr;\n\n\tperf_user_event_attr_set(&attr, addr, len);\n\treturn perf_event_open(&attr, child_pid, -1, -1, 0);\n}\n\nstatic int perf_read_counter(int perf_fd, u64 *count)\n{\n\t \n\tssize_t len = read(perf_fd, count, sizeof(*count));\n\n\tif (len != sizeof(*count))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void ppc_ptrace_init_breakpoint(struct ppc_hw_breakpoint *info,\n\t\t\t\t       int type, void *addr, int len)\n{\n\tinfo->version = 1;\n\tinfo->trigger_type = type;\n\tinfo->condition_mode = PPC_BREAKPOINT_CONDITION_NONE;\n\tinfo->addr = (u64)addr;\n\tinfo->addr2 = (u64)addr + len;\n\tinfo->condition_value = 0;\n\tif (!len)\n\t\tinfo->addr_mode = PPC_BREAKPOINT_MODE_EXACT;\n\telse\n\t\tinfo->addr_mode = PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE;\n}\n\n \nstatic int check_watchpoints(pid_t pid)\n{\n\tstruct ppc_debug_info dbginfo;\n\n\tFAIL_IF_MSG(ppc_ptrace_gethwdbginfo(pid, &dbginfo), \"PPC_PTRACE_GETHWDBGINFO failed\");\n\tSKIP_IF_MSG(dbginfo.num_data_bps <= 1, \"Not enough data watchpoints (need at least 2)\");\n\n\treturn 0;\n}\n\n \nstatic int ptrace_fork_child(pid_t *pid)\n{\n\tint status;\n\n\t*pid = fork();\n\n\tif (*pid < 0)\n\t\tFAIL_IF_MSG(1, \"Failed to fork child\");\n\n\tif (!*pid) {\n\t\tFAIL_IF_EXIT_MSG(ptrace_traceme(), \"PTRACE_TRACEME failed\");\n\t\tFAIL_IF_EXIT_MSG(raise(SIGSTOP), \"Child failed to raise SIGSTOP\");\n\t} else {\n\t\t \n\t\tFAIL_IF_MSG(waitpid(*pid, &status, 0) == -1, \"Failed to wait for child\");\n\t\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\t}\n\n\treturn 0;\n}\n\n \nint same_watch_addr_test(void)\n{\n\tstruct ppc_hw_breakpoint bp_info;\t \n\tint bp_id;\t \n\tint perf_fd;\t \n\tu64 perf_count;\t \n\tpid_t pid;\t \n\tvoid *pc;\t \n\tint status;\t \n\tunsigned long value;\t \n\tint err;\n\n\terr = ptrace_fork_child(&pid);\n\tif (err)\n\t\treturn err;\n\n\tif (!pid) {\n\t\tsame_watch_addr_child(&value);\n\t\texit(1);\n\t}\n\n\terr = check_watchpoints(pid);\n\tif (err)\n\t\treturn err;\n\n\t \n\tperf_fd = perf_watchpoint_open(pid, &value, sizeof(value));\n\tFAIL_IF_MSG(perf_fd < 0, \"Failed to open perf performance counter\");\n\n\t \n\tppc_ptrace_init_breakpoint(&bp_info, PPC_BREAKPOINT_TRIGGER_READ, &value, sizeof(value));\n\tbp_id = ppc_ptrace_sethwdbg(pid, &bp_info);\n\tFAIL_IF_MSG(bp_id < 0, \"Failed to set ptrace watchpoint\");\n\n\t \n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_load, \"Child did not stop on load instruction\");\n\n\t \n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 0, \"perf recorded unexpected event\");\n\n\t \n\tFAIL_IF_MSG(ptrace_singlestep(pid, 0), \"Failed to single step child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_load + 4, \"Failed to single step load instruction\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 1, \"perf counter did not increment\");\n\n\t \n\tFAIL_IF_MSG(ppc_ptrace_delhwdbg(pid, bp_id), \"Failed to remove old ptrace watchpoint\");\n\tbp_id = ppc_ptrace_sethwdbg(pid, &bp_info);\n\tFAIL_IF_MSG(bp_id < 0, \"Failed to set ptrace watchpoint\");\n\tFAIL_IF_MSG(ptrace_setreg_pc(pid, same_watch_addr_load), \"Failed to set child PC\");\n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_load, \"Child did not stop on load trap\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 1, \"perf counter should not have changed\");\n\n\t \n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_trap, \"Child did not stop on end trap\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 2, \"perf counter did not increment\");\n\n\t \n\tFAIL_IF_MSG(ptrace_setreg_pc(pid, same_watch_addr_load), \"Failed to set child PC\");\n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_trap, \"Child did not stop on end trap\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 3, \"perf counter did not increment\");\n\n\t \n\tFAIL_IF_MSG(ppc_ptrace_delhwdbg(pid, bp_id), \"Failed to remove old ptrace watchpoint\");\n\tbp_id = ppc_ptrace_sethwdbg(pid, &bp_info);\n\tFAIL_IF_MSG(bp_id < 0, \"Failed to set ptrace watchpoint\");\n\tFAIL_IF_MSG(ptrace_setreg_pc(pid, same_watch_addr_load), \"Failed to set child PC\");\n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_load, \"Child did not stop on load instruction\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 3, \"perf counter should not have changed\");\n\n\t \n\tFAIL_IF_MSG(ptrace_setreg_pc(pid, same_watch_addr_load + 4), \"Failed to set child PC\");\n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != same_watch_addr_trap, \"Child did not stop on end trap\");\n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 3, \"perf counter should not have changed\");\n\n\t \n\tFAIL_IF_MSG(kill(pid, SIGKILL) != 0, \"Failed to kill child\");\n\n\treturn 0;\n}\n\n \nint perf_then_ptrace_test(void)\n{\n\tstruct ppc_hw_breakpoint bp_info;\t \n\tint bp_id;\t \n\tint perf_fd;\t \n\tu64 perf_count;\t \n\tpid_t pid;\t \n\tvoid *pc;\t \n\tint status;\t \n\tunsigned long perf_value;\t \n\tunsigned long ptrace_value;\t \n\tint err;\n\n\terr = ptrace_fork_child(&pid);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!pid) {\n\t\tperf_then_ptrace_child(&perf_value, &ptrace_value);\n\t\texit(0);\n\t}\n\n\terr = check_watchpoints(pid);\n\tif (err)\n\t\treturn err;\n\n\t \n\tperf_fd = perf_watchpoint_open(pid, &perf_value, sizeof(perf_value));\n\tFAIL_IF_MSG(perf_fd < 0, \"Failed to open perf performance counter\");\n\n\t \n\tppc_ptrace_init_breakpoint(&bp_info, PPC_BREAKPOINT_TRIGGER_READ,\n\t\t\t\t   &ptrace_value, sizeof(ptrace_value));\n\tbp_id = ppc_ptrace_sethwdbg(pid, &bp_info);\n\tFAIL_IF_MSG(bp_id < 0, \"Failed to set ptrace watchpoint\");\n\n\t \n\tFAIL_IF_MSG(ptrace_cont(pid, 0), \"Failed to continue child\");\n\n\tFAIL_IF_MSG(waitpid(pid, &status, 0) == -1, \"Failed to wait for child\");\n\tFAIL_IF_MSG(!WIFSTOPPED(status), \"Child is not stopped\");\n\tFAIL_IF_MSG(ptrace_getreg_pc(pid, &pc), \"Failed to get child PC\");\n\tFAIL_IF_MSG(pc != perf_then_ptrace_load2, \"Child did not stop on ptrace load\");\n\n\t \n\tFAIL_IF_MSG(perf_read_counter(perf_fd, &perf_count), \"Failed to read perf counter\");\n\tFAIL_IF_MSG(perf_count != 1, \"perf counter did not increment\");\n\n\t \n\tFAIL_IF_MSG(kill(pid, SIGKILL) != 0, \"Failed to kill child\");\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err = 0;\n\n\terr |= test_harness(same_watch_addr_test, \"same_watch_addr\");\n\terr |= test_harness(perf_then_ptrace_test, \"perf_then_ptrace\");\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}