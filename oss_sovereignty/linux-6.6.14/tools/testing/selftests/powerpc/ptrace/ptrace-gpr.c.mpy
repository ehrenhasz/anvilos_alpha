{
  "module_name": "ptrace-gpr.c",
  "hash_id": "e3a8004a34e14d9289e7e2b98519615a2acd0bb79f6c8f5398b8de28402aa756",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-gpr.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"ptrace-gpr.h\"\n#include \"reg.h\"\n#include <time.h>\n\n \nint shm_id;\nint *cptr, *pptr;\n\nextern void gpr_child_loop(int *read_flag, int *write_flag,\n\t\t\t   unsigned long *gpr_buf, double *fpr_buf);\n\nunsigned long child_gpr_val, parent_gpr_val;\ndouble child_fpr_val, parent_fpr_val;\n\nstatic int child(void)\n{\n\tunsigned long gpr_buf[32];\n\tdouble fpr_buf[32];\n\tint i;\n\n\tcptr = (int *)shmat(shm_id, NULL, 0);\n\tmemset(gpr_buf, 0, sizeof(gpr_buf));\n\tmemset(fpr_buf, 0, sizeof(fpr_buf));\n\n\tfor (i = 0; i < 32; i++) {\n\t\tgpr_buf[i] = child_gpr_val;\n\t\tfpr_buf[i] = child_fpr_val;\n\t}\n\n\tgpr_child_loop(&cptr[0], &cptr[1], gpr_buf, fpr_buf);\n\n\tshmdt((void *)cptr);\n\n\tFAIL_IF(validate_gpr(gpr_buf, parent_gpr_val));\n\tFAIL_IF(validate_fpr_double(fpr_buf, parent_fpr_val));\n\n\treturn 0;\n}\n\nint trace_gpr(pid_t child)\n{\n\t__u64 tmp, fpr[32], *peeked_fprs;\n\tunsigned long gpr[18];\n\n\tFAIL_IF(start_trace(child));\n\n\t\n\tFAIL_IF(show_gpr(child, gpr));\n\tFAIL_IF(validate_gpr(gpr, child_gpr_val));\n\n\t\n\tFAIL_IF(show_fpr(child, fpr));\n\tmemcpy(&tmp, &child_fpr_val, sizeof(tmp));\n\tFAIL_IF(validate_fpr(fpr, tmp));\n\n\t\n\tpeeked_fprs = peek_fprs(child);\n\tFAIL_IF(!peeked_fprs);\n\tFAIL_IF(validate_fpr(peeked_fprs, tmp));\n\tfree(peeked_fprs);\n\n\t\n\tFAIL_IF(write_gpr(child, parent_gpr_val));\n\n\t\n\tmemcpy(&tmp, &parent_fpr_val, sizeof(tmp));\n\tFAIL_IF(write_fpr(child, tmp));\n\n\t\n\tpeeked_fprs = peek_fprs(child);\n\tFAIL_IF(!peeked_fprs);\n\tFAIL_IF(validate_fpr(peeked_fprs, tmp));\n\n\t\n\tFAIL_IF(poke_fprs(child, (unsigned long *)peeked_fprs));\n\n\t\n\tFAIL_IF(stop_trace(child));\n\n\treturn TEST_PASS;\n}\n\n#ifndef __LONG_WIDTH__\n#define __LONG_WIDTH__ (sizeof(long) * 8)\n#endif\n\nstatic uint64_t rand_reg(void)\n{\n\tuint64_t result;\n\tlong r;\n\n\tr = random();\n\n\t\n\tresult = r & 0xffff;\n\tif (r & 0x10000)\n\t\treturn result;\n\n\t\n\tresult |= random() << (__LONG_WIDTH__ - 31);\n\tif (r & 0x100000)\n\t\treturn result;\n\n\t\n\tresult ^= random() << 16;\n\n\treturn result;\n}\n\nint ptrace_gpr(void)\n{\n\tunsigned long seed;\n\tint ret, status;\n\tpid_t pid;\n\n\tseed = getpid() ^ time(NULL);\n\tprintf(\"srand(%lu)\\n\", seed);\n\tsrand(seed);\n\n\tchild_gpr_val = rand_reg();\n\tchild_fpr_val = rand_reg();\n\tparent_gpr_val = rand_reg();\n\tparent_fpr_val = rand_reg();\n\n\tshm_id = shmget(IPC_PRIVATE, sizeof(int) * 2, 0777|IPC_CREAT);\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\treturn TEST_FAIL;\n\t}\n\tif (pid == 0)\n\t\texit(child());\n\n\tif (pid) {\n\t\tpptr = (int *)shmat(shm_id, NULL, 0);\n\t\twhile (!pptr[1])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\n\t\tret = trace_gpr(pid);\n\t\tif (ret) {\n\t\t\tkill(pid, SIGTERM);\n\t\t\tshmdt((void *)pptr);\n\t\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\tpptr[0] = 1;\n\t\tshmdt((void *)pptr);\n\n\t\tret = wait(&status);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\tif (ret != pid) {\n\t\t\tprintf(\"Child's exit status not captured\\n\");\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\treturn (WIFEXITED(status) && WEXITSTATUS(status)) ? TEST_FAIL :\n\t\t\tTEST_PASS;\n\t}\n\n\treturn TEST_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_gpr, \"ptrace_gpr\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}