{
  "module_name": "ptrace-tm-vsx.c",
  "hash_id": "691e30898a0875c4fcd37f92597b1de0763a557d0657ad518fb84f72a50e396f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-tm-vsx.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"tm.h\"\n#include \"ptrace-vsx.h\"\n\nint shm_id;\nunsigned long *cptr, *pptr;\n\nunsigned long fp_load[VEC_MAX];\nunsigned long fp_store[VEC_MAX];\nunsigned long fp_load_ckpt[VEC_MAX];\nunsigned long fp_load_ckpt_new[VEC_MAX];\n\n__attribute__((used)) void load_vsx(void)\n{\n\tloadvsx(fp_load, 0);\n}\n\n__attribute__((used)) void load_vsx_ckpt(void)\n{\n\tloadvsx(fp_load_ckpt, 0);\n}\n\nvoid tm_vsx(void)\n{\n\tunsigned long result, texasr;\n\tint ret;\n\n\tcptr = (unsigned long *)shmat(shm_id, NULL, 0);\n\ntrans:\n\tcptr[1] = 0;\n\tasm __volatile__(\n\t\t\"bl load_vsx_ckpt;\"\n\n\t\t\"1: ;\"\n\t\t\"tbegin.;\"\n\t\t\"beq 2f;\"\n\n\t\t\"bl load_vsx;\"\n\t\t\"tsuspend.;\"\n\t\t\"li 7, 1;\"\n\t\t\"stw 7, 0(%[cptr1]);\"\n\t\t\"tresume.;\"\n\t\t\"b .;\"\n\n\t\t\"tend.;\"\n\t\t\"li 0, 0;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"b 3f;\"\n\n\t\t\"2: ;\"\n\t\t\"li 0, 1;\"\n\t\t\"ori %[res], 0, 0;\"\n\t\t\"mfspr %[texasr], %[sprn_texasr];\"\n\n\t\t\"3: ;\"\n\t\t: [res] \"=r\" (result), [texasr] \"=r\" (texasr)\n\t\t: [sprn_texasr] \"i\"  (SPRN_TEXASR), [cptr1] \"b\" (&cptr[1])\n\t\t: \"memory\", \"r0\", \"r3\", \"r4\",\n\t\t  \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"lr\"\n\t\t);\n\n\tif (result) {\n\t\tif (!cptr[0])\n\t\t\tgoto trans;\n\n\t\tshmdt((void *)cptr);\n\t\tstorevsx(fp_store, 0);\n\t\tret = compare_vsx_vmx(fp_store, fp_load_ckpt_new);\n\t\tif (ret)\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\tshmdt((void *)cptr);\n\texit(1);\n}\n\nint trace_tm_vsx(pid_t child)\n{\n\tunsigned long vsx[VSX_MAX];\n\tunsigned long vmx[VMX_MAX + 2][2];\n\n\tFAIL_IF(start_trace(child));\n\tFAIL_IF(show_vsx(child, vsx));\n\tFAIL_IF(validate_vsx(vsx, fp_load));\n\tFAIL_IF(show_vmx(child, vmx));\n\tFAIL_IF(validate_vmx(vmx, fp_load));\n\tFAIL_IF(show_vsx_ckpt(child, vsx));\n\tFAIL_IF(validate_vsx(vsx, fp_load_ckpt));\n\tFAIL_IF(show_vmx_ckpt(child, vmx));\n\tFAIL_IF(validate_vmx(vmx, fp_load_ckpt));\n\tmemset(vsx, 0, sizeof(vsx));\n\tmemset(vmx, 0, sizeof(vmx));\n\n\tload_vsx_vmx(fp_load_ckpt_new, vsx, vmx);\n\n\tFAIL_IF(write_vsx_ckpt(child, vsx));\n\tFAIL_IF(write_vmx_ckpt(child, vmx));\n\tpptr[0] = 1;\n\tFAIL_IF(stop_trace(child));\n\treturn TEST_PASS;\n}\n\nint ptrace_tm_vsx(void)\n{\n\tpid_t pid;\n\tint ret, status, i;\n\n\tSKIP_IF_MSG(!have_htm(), \"Don't have transactional memory\");\n\tSKIP_IF_MSG(htm_is_synthetic(), \"Transactional memory is synthetic\");\n\tshm_id = shmget(IPC_PRIVATE, sizeof(int) * 2, 0777|IPC_CREAT);\n\n\tfor (i = 0; i < 128; i++) {\n\t\tfp_load[i] = 1 + rand();\n\t\tfp_load_ckpt[i] = 1 + 2 * rand();\n\t\tfp_load_ckpt_new[i] = 1 + 3 * rand();\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\treturn TEST_FAIL;\n\t}\n\n\tif (pid == 0)\n\t\ttm_vsx();\n\n\tif (pid) {\n\t\tpptr = (unsigned long *)shmat(shm_id, NULL, 0);\n\t\twhile (!pptr[1])\n\t\t\tasm volatile(\"\" : : : \"memory\");\n\n\t\tret = trace_tm_vsx(pid);\n\t\tif (ret) {\n\t\t\tkill(pid, SIGKILL);\n\t\t\tshmdt((void *)pptr);\n\t\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\tshmdt((void *)pptr);\n\t\tret = wait(&status);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t\tif (ret != pid) {\n\t\t\tprintf(\"Child's exit status not captured\\n\");\n\t\t\treturn TEST_FAIL;\n\t\t}\n\n\t\treturn (WIFEXITED(status) && WEXITSTATUS(status)) ? TEST_FAIL :\n\t\t\tTEST_PASS;\n\t}\n\treturn TEST_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_tm_vsx, \"ptrace_tm_vsx\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}