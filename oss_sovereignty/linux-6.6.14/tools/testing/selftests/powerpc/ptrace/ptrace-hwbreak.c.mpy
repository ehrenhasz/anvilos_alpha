{
  "module_name": "ptrace-hwbreak.c",
  "hash_id": "62779e43c8f901dfa0508e8ad69b0e954349929f7f365b53ef87269548faad82",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-hwbreak.c",
  "human_readable_source": "\n\n \n\n#include <sys/ptrace.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <sys/user.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <linux/limits.h>\n#include \"ptrace.h\"\n#include \"reg.h\"\n\n#define SPRN_PVR\t0x11F\n#define PVR_8xx\t\t0x00500000\n\nbool is_8xx;\n\n \nstatic volatile __u64 glvar;\n\n#define DAWR_MAX_LEN 512\nstatic volatile __u8 big_var[DAWR_MAX_LEN] __attribute__((aligned(512)));\n\n#define A_LEN 6\n#define B_LEN 6\nstruct gstruct {\n\t__u8 a[A_LEN];  \n\t__u8 b[B_LEN];  \n};\nstatic volatile struct gstruct gstruct __attribute__((aligned(512)));\n\nstatic volatile char cwd[PATH_MAX] __attribute__((aligned(8)));\n\nstatic void get_dbginfo(pid_t child_pid, struct ppc_debug_info *dbginfo)\n{\n\tif (ptrace(PPC_PTRACE_GETHWDBGINFO, child_pid, NULL, dbginfo)) {\n\t\tperror(\"Can't get breakpoint info\");\n\t\texit(-1);\n\t}\n}\n\nstatic bool dawr_present(struct ppc_debug_info *dbginfo)\n{\n\treturn !!(dbginfo->features & PPC_DEBUG_FEATURE_DATA_BP_DAWR);\n}\n\nstatic void write_var(int len)\n{\n\tvolatile __u8 *pcvar;\n\tvolatile __u16 *psvar;\n\tvolatile __u32 *pivar;\n\tvolatile __u64 *plvar;\n\n\tswitch (len) {\n\tcase 1:\n\t\tpcvar = (volatile __u8 *)&glvar;\n\t\t*pcvar = 0xff;\n\t\tbreak;\n\tcase 2:\n\t\tpsvar = (volatile __u16 *)&glvar;\n\t\t*psvar = 0xffff;\n\t\tbreak;\n\tcase 4:\n\t\tpivar = (volatile __u32 *)&glvar;\n\t\t*pivar = 0xffffffff;\n\t\tbreak;\n\tcase 8:\n\t\tplvar = (volatile __u64 *)&glvar;\n\t\t*plvar = 0xffffffffffffffffLL;\n\t\tbreak;\n\t}\n}\n\nstatic void read_var(int len)\n{\n\t__u8 cvar __attribute__((unused));\n\t__u16 svar __attribute__((unused));\n\t__u32 ivar __attribute__((unused));\n\t__u64 lvar __attribute__((unused));\n\n\tswitch (len) {\n\tcase 1:\n\t\tcvar = (volatile __u8)glvar;\n\t\tbreak;\n\tcase 2:\n\t\tsvar = (volatile __u16)glvar;\n\t\tbreak;\n\tcase 4:\n\t\tivar = (volatile __u32)glvar;\n\t\tbreak;\n\tcase 8:\n\t\tlvar = (volatile __u64)glvar;\n\t\tbreak;\n\t}\n}\n\nstatic void test_workload(void)\n{\n\t__u8 cvar __attribute__((unused));\n\t__u32 ivar __attribute__((unused));\n\tint len = 0;\n\n\tif (ptrace(PTRACE_TRACEME, 0, NULL, 0)) {\n\t\tperror(\"Child can't be traced?\");\n\t\texit(-1);\n\t}\n\n\t \n\tkill(getpid(), SIGUSR1);\n\n\t \n\tfor (len = 1; len <= sizeof(glvar); len <<= 1)\n\t\twrite_var(len);\n\n\t \n\tfor (len = 1; len <= sizeof(glvar); len <<= 1)\n\t\tread_var(len);\n\n\t \n\tfor (len = 1; len <= sizeof(glvar); len <<= 1) {\n\t\tif (rand() % 2)\n\t\t\tread_var(len);\n\t\telse\n\t\t\twrite_var(len);\n\t}\n\n\t \n\tsyscall(__NR_getcwd, &cwd, PATH_MAX);\n\n\t \n\twrite_var(1);\n\n\t \n\tread_var(1);\n\n\t \n\tif (rand() % 2)\n\t\twrite_var(1);\n\telse\n\t\tread_var(1);\n\n\t \n\tsyscall(__NR_getcwd, &cwd, PATH_MAX);\n\n\t \n\tgstruct.a[rand() % A_LEN] = 'a';\n\n\t \n\tcvar = gstruct.a[rand() % A_LEN];\n\n\t \n\tif (rand() % 2)\n\t\tgstruct.a[rand() % A_LEN] = 'a';\n\telse\n\t\tcvar = gstruct.a[rand() % A_LEN];\n\n\t \n\tgstruct.b[rand() % B_LEN] = 'b';\n\n\t \n\tcvar = gstruct.b[rand() % B_LEN];\n\n\t \n\tif (rand() % 2)\n\t\tgstruct.b[rand() % B_LEN] = 'b';\n\telse\n\t\tcvar = gstruct.b[rand() % B_LEN];\n\n\t \n\tif (rand() % 2)\n\t\t*((int *)(gstruct.a + 4)) = 10;\n\telse\n\t\tivar = *((int *)(gstruct.a + 4));\n\n\t \n\tif (rand() % 2)\n\t\tbig_var[rand() % DAWR_MAX_LEN] = 'a';\n\telse\n\t\tcvar = big_var[rand() % DAWR_MAX_LEN];\n\n\t \n\tgstruct.a[rand() % A_LEN] = 'a';\n\n\t \n\tcvar = gstruct.b[rand() % B_LEN];\n\n\t \n\tgstruct.a[rand() % A_LEN] = 'a';\n\n\t \n\tcvar = gstruct.a[rand() % A_LEN];\n}\n\nstatic void check_success(pid_t child_pid, const char *name, const char *type,\n\t\t\t  unsigned long saddr, int len)\n{\n\tint status;\n\tsiginfo_t siginfo;\n\tunsigned long eaddr = (saddr + len - 1) | 0x7;\n\n\tsaddr &= ~0x7;\n\n\t \n\twait(&status);\n\n\tptrace(PTRACE_GETSIGINFO, child_pid, NULL, &siginfo);\n\n\tif (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGTRAP ||\n\t    (unsigned long)siginfo.si_addr < saddr ||\n\t    (unsigned long)siginfo.si_addr > eaddr) {\n\t\tprintf(\"%s, %s, len: %d: Fail\\n\", name, type, len);\n\t\texit(-1);\n\t}\n\n\tprintf(\"%s, %s, len: %d: Ok\\n\", name, type, len);\n\n\tif (!is_8xx) {\n\t\t \n\t\tptrace(PTRACE_SINGLESTEP, child_pid, NULL, 0);\n\t\twait(NULL);\n\t}\n}\n\nstatic void ptrace_set_debugreg(pid_t child_pid, unsigned long wp_addr)\n{\n\tif (ptrace(PTRACE_SET_DEBUGREG, child_pid, 0, wp_addr)) {\n\t\tperror(\"PTRACE_SET_DEBUGREG failed\");\n\t\texit(-1);\n\t}\n}\n\nstatic int ptrace_sethwdebug(pid_t child_pid, struct ppc_hw_breakpoint *info)\n{\n\tint wh = ptrace(PPC_PTRACE_SETHWDEBUG, child_pid, 0, info);\n\n\tif (wh <= 0) {\n\t\tperror(\"PPC_PTRACE_SETHWDEBUG failed\");\n\t\texit(-1);\n\t}\n\treturn wh;\n}\n\nstatic void ptrace_delhwdebug(pid_t child_pid, int wh)\n{\n\tif (ptrace(PPC_PTRACE_DELHWDEBUG, child_pid, 0, wh) < 0) {\n\t\tperror(\"PPC_PTRACE_DELHWDEBUG failed\");\n\t\texit(-1);\n\t}\n}\n\n#define DABR_READ_SHIFT\t\t0\n#define DABR_WRITE_SHIFT\t1\n#define DABR_TRANSLATION_SHIFT\t2\n\nstatic int test_set_debugreg(pid_t child_pid)\n{\n\tunsigned long wp_addr = (unsigned long)&glvar;\n\tchar *name = \"PTRACE_SET_DEBUGREG\";\n\tint len;\n\n\t \n\twp_addr &= ~0x7UL;\n\twp_addr |= (1UL << DABR_WRITE_SHIFT);\n\twp_addr |= (1UL << DABR_TRANSLATION_SHIFT);\n\tfor (len = 1; len <= sizeof(glvar); len <<= 1) {\n\t\tptrace_set_debugreg(child_pid, wp_addr);\n\t\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\t\tcheck_success(child_pid, name, \"WO\", wp_addr, len);\n\t}\n\n\t \n\twp_addr &= ~0x7UL;\n\twp_addr |= (1UL << DABR_READ_SHIFT);\n\twp_addr |= (1UL << DABR_TRANSLATION_SHIFT);\n\tfor (len = 1; len <= sizeof(glvar); len <<= 1) {\n\t\tptrace_set_debugreg(child_pid, wp_addr);\n\t\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\t\tcheck_success(child_pid, name, \"RO\", wp_addr, len);\n\t}\n\n\t \n\twp_addr &= ~0x7UL;\n\twp_addr |= (1Ul << DABR_READ_SHIFT);\n\twp_addr |= (1UL << DABR_WRITE_SHIFT);\n\twp_addr |= (1UL << DABR_TRANSLATION_SHIFT);\n\tfor (len = 1; len <= sizeof(glvar); len <<= 1) {\n\t\tptrace_set_debugreg(child_pid, wp_addr);\n\t\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\t\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\t}\n\n\tptrace_set_debugreg(child_pid, 0);\n\treturn 0;\n}\n\nstatic int test_set_debugreg_kernel_userspace(pid_t child_pid)\n{\n\tunsigned long wp_addr = (unsigned long)cwd;\n\tchar *name = \"PTRACE_SET_DEBUGREG\";\n\n\t \n\twp_addr &= ~0x7UL;\n\twp_addr |= (1Ul << DABR_READ_SHIFT);\n\twp_addr |= (1UL << DABR_WRITE_SHIFT);\n\twp_addr |= (1UL << DABR_TRANSLATION_SHIFT);\n\tptrace_set_debugreg(child_pid, wp_addr);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"Kernel Access Userspace\", wp_addr, 8);\n\n\tptrace_set_debugreg(child_pid, 0);\n\treturn 0;\n}\n\nstatic void get_ppc_hw_breakpoint(struct ppc_hw_breakpoint *info, int type,\n\t\t\t\t  unsigned long addr, int len)\n{\n\tinfo->version = 1;\n\tinfo->trigger_type = type;\n\tinfo->condition_mode = PPC_BREAKPOINT_CONDITION_NONE;\n\tinfo->addr = (__u64)addr;\n\tinfo->addr2 = (__u64)addr + len;\n\tinfo->condition_value = 0;\n\tif (!len)\n\t\tinfo->addr_mode = PPC_BREAKPOINT_MODE_EXACT;\n\telse\n\t\tinfo->addr_mode = PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE;\n}\n\nstatic void test_sethwdebug_exact(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr = (unsigned long)&glvar;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, MODE_EXACT\";\n\tint len = 1;  \n\tint wh;\n\n\t \n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr, 0);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"WO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_READ, wp_addr, 0);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_RW, wp_addr, 0);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n}\n\nstatic void test_sethwdebug_exact_kernel_userspace(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr = (unsigned long)&cwd;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, MODE_EXACT\";\n\tint len = 1;  \n\tint wh;\n\n\t \n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr, 0);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"Kernel Access Userspace\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n}\n\nstatic void test_sethwdebug_range_aligned(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED\";\n\tint len;\n\tint wh;\n\n\t \n\twp_addr = (unsigned long)&gstruct.a;\n\tlen = A_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"WO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\twp_addr = (unsigned long)&gstruct.a;\n\tlen = A_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_READ, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\twp_addr = (unsigned long)&gstruct.a;\n\tlen = A_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_RW, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n}\n\nstatic void test_multi_sethwdebug_range(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info1, info2;\n\tunsigned long wp_addr1, wp_addr2;\n\tchar *name1 = \"PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW ALIGNED\";\n\tchar *name2 = \"PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW UNALIGNED\";\n\tint len1, len2;\n\tint wh1, wh2;\n\n\twp_addr1 = (unsigned long)&gstruct.a;\n\twp_addr2 = (unsigned long)&gstruct.b;\n\tlen1 = A_LEN;\n\tlen2 = B_LEN;\n\tget_ppc_hw_breakpoint(&info1, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr1, len1);\n\tget_ppc_hw_breakpoint(&info2, PPC_BREAKPOINT_TRIGGER_READ, wp_addr2, len2);\n\n\t \n\twh1 = ptrace_sethwdebug(child_pid, &info1);\n\n\t \n\twh2 = ptrace_sethwdebug(child_pid, &info2);\n\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name1, \"WO\", wp_addr1, len1);\n\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name2, \"RO\", wp_addr2, len2);\n\n\tptrace_delhwdebug(child_pid, wh1);\n\tptrace_delhwdebug(child_pid, wh2);\n}\n\nstatic void test_multi_sethwdebug_range_dawr_overlap(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info1, info2;\n\tunsigned long wp_addr1, wp_addr2;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap\";\n\tint len1, len2;\n\tint wh1, wh2;\n\n\twp_addr1 = (unsigned long)&gstruct.a;\n\twp_addr2 = (unsigned long)&gstruct.a;\n\tlen1 = A_LEN;\n\tlen2 = A_LEN;\n\tget_ppc_hw_breakpoint(&info1, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr1, len1);\n\tget_ppc_hw_breakpoint(&info2, PPC_BREAKPOINT_TRIGGER_READ, wp_addr2, len2);\n\n\t \n\twh1 = ptrace_sethwdebug(child_pid, &info1);\n\n\t \n\twh2 = ptrace_sethwdebug(child_pid, &info2);\n\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"WO\", wp_addr1, len1);\n\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RO\", wp_addr2, len2);\n\n\tptrace_delhwdebug(child_pid, wh1);\n\tptrace_delhwdebug(child_pid, wh2);\n}\n\nstatic void test_sethwdebug_range_unaligned(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED\";\n\tint len;\n\tint wh;\n\n\t \n\twp_addr = (unsigned long)&gstruct.b;\n\tlen = B_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"WO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\twp_addr = (unsigned long)&gstruct.b;\n\tlen = B_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_READ, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RO\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n\t \n\twp_addr = (unsigned long)&gstruct.b;\n\tlen = B_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_RW, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n\n}\n\nstatic void test_sethwdebug_range_unaligned_dar(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, DAR OUTSIDE\";\n\tint len;\n\tint wh;\n\n\t \n\twp_addr = (unsigned long)&gstruct.b;\n\tlen = B_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_WRITE, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n}\n\nstatic void test_sethwdebug_dawr_max_range(pid_t child_pid)\n{\n\tstruct ppc_hw_breakpoint info;\n\tunsigned long wp_addr;\n\tchar *name = \"PPC_PTRACE_SETHWDEBUG, DAWR_MAX_LEN\";\n\tint len;\n\tint wh;\n\n\t \n\twp_addr = (unsigned long)big_var;\n\tlen = DAWR_MAX_LEN;\n\tget_ppc_hw_breakpoint(&info, PPC_BREAKPOINT_TRIGGER_RW, wp_addr, len);\n\twh = ptrace_sethwdebug(child_pid, &info);\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(child_pid, name, \"RW\", wp_addr, len);\n\tptrace_delhwdebug(child_pid, wh);\n}\n\n \nstatic void\nrun_tests(pid_t child_pid, struct ppc_debug_info *dbginfo, bool dawr)\n{\n\ttest_set_debugreg(child_pid);\n\ttest_set_debugreg_kernel_userspace(child_pid);\n\ttest_sethwdebug_exact(child_pid);\n\ttest_sethwdebug_exact_kernel_userspace(child_pid);\n\tif (dbginfo->features & PPC_DEBUG_FEATURE_DATA_BP_RANGE) {\n\t\ttest_sethwdebug_range_aligned(child_pid);\n\t\tif (dawr || is_8xx) {\n\t\t\ttest_sethwdebug_range_unaligned(child_pid);\n\t\t\ttest_sethwdebug_range_unaligned_dar(child_pid);\n\t\t\ttest_sethwdebug_dawr_max_range(child_pid);\n\t\t\tif (dbginfo->num_data_bps > 1) {\n\t\t\t\ttest_multi_sethwdebug_range(child_pid);\n\t\t\t\ttest_multi_sethwdebug_range_dawr_overlap(child_pid);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int ptrace_hwbreak(void)\n{\n\tpid_t child_pid;\n\tstruct ppc_debug_info dbginfo;\n\tbool dawr;\n\n\tchild_pid = fork();\n\tif (!child_pid) {\n\t\ttest_workload();\n\t\treturn 0;\n\t}\n\n\twait(NULL);\n\n\tget_dbginfo(child_pid, &dbginfo);\n\tSKIP_IF_MSG(dbginfo.num_data_bps == 0, \"No data breakpoints present\");\n\n\tdawr = dawr_present(&dbginfo);\n\trun_tests(child_pid, &dbginfo, dawr);\n\n\t \n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\twait(NULL);\n\n\t \n\treturn TEST_PASS;\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tis_8xx = mfspr(SPRN_PVR) == PVR_8xx;\n\n\treturn test_harness(ptrace_hwbreak, \"ptrace-hwbreak\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}