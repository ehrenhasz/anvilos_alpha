{
  "module_name": "ptrace-pkey.c",
  "hash_id": "657752845e95a0a58604b10884525de4e1d1a31e48f011957b37cfd871122c37",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/ptrace/ptrace-pkey.c",
  "human_readable_source": "\n \n#include \"ptrace.h\"\n#include \"child.h\"\n\n#ifndef __NR_pkey_alloc\n#define __NR_pkey_alloc\t\t384\n#endif\n\n#ifndef __NR_pkey_free\n#define __NR_pkey_free\t\t385\n#endif\n\n#ifndef NT_PPC_PKEY\n#define NT_PPC_PKEY\t\t0x110\n#endif\n\n#ifndef PKEY_DISABLE_EXECUTE\n#define PKEY_DISABLE_EXECUTE\t0x4\n#endif\n\n#define AMR_BITS_PER_PKEY 2\n#define PKEY_REG_BITS (sizeof(u64) * 8)\n#define pkeyshift(pkey) (PKEY_REG_BITS - ((pkey + 1) * AMR_BITS_PER_PKEY))\n\nstatic const char user_read[] = \"[User Read (Running)]\";\nstatic const char user_write[] = \"[User Write (Running)]\";\nstatic const char ptrace_read_running[] = \"[Ptrace Read (Running)]\";\nstatic const char ptrace_write_running[] = \"[Ptrace Write (Running)]\";\n\n \nstruct shared_info {\n\tstruct child_sync child_sync;\n\n\t \n\tunsigned long amr1;\n\n\t \n\tunsigned long amr2;\n\n\t \n\tunsigned long invalid_amr;\n\n\t \n\tunsigned long expected_iamr;\n\n\t \n\tunsigned long expected_uamor;\n\n\t \n\tunsigned long invalid_iamr;\n\tunsigned long invalid_uamor;\n};\n\nstatic int sys_pkey_alloc(unsigned long flags, unsigned long init_access_rights)\n{\n\treturn syscall(__NR_pkey_alloc, flags, init_access_rights);\n}\n\nstatic int child(struct shared_info *info)\n{\n\tunsigned long reg;\n\tbool disable_execute = true;\n\tint pkey1, pkey2, pkey3;\n\tint ret;\n\n\t \n\tret = wait_parent(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpkey1 = sys_pkey_alloc(0, PKEY_DISABLE_EXECUTE);\n\tif (pkey1 < 0) {\n\t\tpkey1 = sys_pkey_alloc(0, 0);\n\t\tCHILD_FAIL_IF(pkey1 < 0, &info->child_sync);\n\n\t\tdisable_execute = false;\n\t}\n\n\tpkey2 = sys_pkey_alloc(0, 0);\n\tCHILD_FAIL_IF(pkey2 < 0, &info->child_sync);\n\n\tpkey3 = sys_pkey_alloc(0, 0);\n\tCHILD_FAIL_IF(pkey3 < 0, &info->child_sync);\n\n\tinfo->amr1 |= 3ul << pkeyshift(pkey1);\n\tinfo->amr2 |= 3ul << pkeyshift(pkey2);\n\t \n\tinfo->invalid_amr = info->amr2 | (~0x0UL & ~info->expected_uamor);\n\n\t \n\tif (disable_execute)\n\t\tinfo->expected_iamr |= 1ul << pkeyshift(pkey1);\n\telse\n\t\tinfo->expected_iamr &= ~(1ul << pkeyshift(pkey1));\n\n\t \n\tinfo->expected_iamr &= ~(1ul << pkeyshift(pkey2));\n\tinfo->expected_iamr &= ~(1ul << pkeyshift(pkey3));\n\n\t \n\tinfo->invalid_iamr = info->expected_iamr | (1ul << pkeyshift(pkey1) | 1ul << pkeyshift(pkey2));\n\tinfo->invalid_uamor = info->expected_uamor & ~(0x3ul << pkeyshift(pkey1));\n\n\tprintf(\"%-30s AMR: %016lx pkey1: %d pkey2: %d pkey3: %d\\n\",\n\t       user_write, info->amr1, pkey1, pkey2, pkey3);\n\n\tset_amr(info->amr1);\n\n\t \n\tret = prod_parent(&info->child_sync);\n\tCHILD_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_parent(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\treg = mfspr(SPRN_AMR);\n\n\tprintf(\"%-30s AMR: %016lx\\n\", user_read, reg);\n\n\tCHILD_FAIL_IF(reg != info->amr2, &info->child_sync);\n\n\t \n\tret = prod_parent(&info->child_sync);\n\tCHILD_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_parent(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\treg = mfspr(SPRN_AMR);\n\n\tprintf(\"%-30s AMR: %016lx\\n\", user_read, reg);\n\n\tCHILD_FAIL_IF(reg != info->amr2, &info->child_sync);\n\n\t \n\tret = prod_parent(&info->child_sync);\n\tCHILD_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_parent(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\treg = mfspr(SPRN_AMR);\n\n\tprintf(\"%-30s AMR: %016lx\\n\", user_read, reg);\n\n\tCHILD_FAIL_IF(reg != info->amr2, &info->child_sync);\n\n\t \n\n\tret = prod_parent(&info->child_sync);\n\tCHILD_FAIL_IF(ret, &info->child_sync);\n\n\treturn TEST_PASS;\n}\n\nstatic int parent(struct shared_info *info, pid_t pid)\n{\n\tunsigned long regs[3];\n\tint ret, status;\n\n\t \n\tret = ptrace_read_regs(pid, NT_PPC_PKEY, regs, 3);\n\tPARENT_SKIP_IF_UNSUPPORTED(ret, &info->child_sync, \"PKEYs not supported\");\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tinfo->amr1 = info->amr2 = regs[0];\n\tinfo->expected_iamr = regs[1];\n\tinfo->expected_uamor = regs[2];\n\n\t \n\tret = prod_child(&info->child_sync);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_child(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ptrace_read_regs(pid, NT_PPC_PKEY, regs, 3);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx IAMR: %016lx UAMOR: %016lx\\n\",\n\t       ptrace_read_running, regs[0], regs[1], regs[2]);\n\n\tPARENT_FAIL_IF(regs[0] != info->amr1, &info->child_sync);\n\tPARENT_FAIL_IF(regs[1] != info->expected_iamr, &info->child_sync);\n\tPARENT_FAIL_IF(regs[2] != info->expected_uamor, &info->child_sync);\n\n\t \n\tret = ptrace_write_regs(pid, NT_PPC_PKEY, &info->amr2, 1);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx\\n\", ptrace_write_running, info->amr2);\n\n\t \n\tret = prod_child(&info->child_sync);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_child(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ptrace_write_regs(pid, NT_PPC_PKEY, &info->invalid_amr, 1);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx\\n\", ptrace_write_running, info->invalid_amr);\n\n\t \n\tret = prod_child(&info->child_sync);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait_child(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregs[0] = info->amr1;\n\tregs[1] = info->invalid_iamr;\n\tret = ptrace_write_regs(pid, NT_PPC_PKEY, regs, 2);\n\tPARENT_FAIL_IF(!ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx IAMR: %016lx\\n\",\n\t       ptrace_write_running, regs[0], regs[1]);\n\n\t \n\tregs[2] = info->invalid_uamor;\n\tret = ptrace_write_regs(pid, NT_PPC_PKEY, regs, 3);\n\tPARENT_FAIL_IF(!ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx IAMR: %016lx UAMOR: %016lx\\n\",\n\t       ptrace_write_running, regs[0], regs[1], regs[2]);\n\n\t \n\tret = ptrace_read_regs(pid, NT_PPC_PKEY, regs, 3);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tprintf(\"%-30s AMR: %016lx IAMR: %016lx UAMOR: %016lx\\n\",\n\t       ptrace_read_running, regs[0], regs[1], regs[2]);\n\n\tPARENT_FAIL_IF(regs[0] != info->amr2, &info->child_sync);\n\tPARENT_FAIL_IF(regs[1] != info->expected_iamr, &info->child_sync);\n\tPARENT_FAIL_IF(regs[2] != info->expected_uamor, &info->child_sync);\n\n\t \n\tret = prod_child(&info->child_sync);\n\tPARENT_FAIL_IF(ret, &info->child_sync);\n\n\tret = wait(&status);\n\tif (ret != pid) {\n\t\tprintf(\"Child's exit status not captured\\n\");\n\t\tret = TEST_PASS;\n\t} else if (!WIFEXITED(status)) {\n\t\tprintf(\"Child exited abnormally\\n\");\n\t\tret = TEST_FAIL;\n\t} else\n\t\tret = WEXITSTATUS(status) ? TEST_FAIL : TEST_PASS;\n\n\treturn ret;\n}\n\nstatic int ptrace_pkey(void)\n{\n\tstruct shared_info *info;\n\tint shm_id;\n\tint ret;\n\tpid_t pid;\n\n\tshm_id = shmget(IPC_PRIVATE, sizeof(*info), 0777 | IPC_CREAT);\n\tinfo = shmat(shm_id, NULL, 0);\n\n\tret = init_child_sync(&info->child_sync);\n\tif (ret)\n\t\treturn ret;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork() failed\");\n\t\tret = TEST_FAIL;\n\t} else if (pid == 0)\n\t\tret = child(info);\n\telse\n\t\tret = parent(info, pid);\n\n\tshmdt(info);\n\n\tif (pid) {\n\t\tdestroy_child_sync(&info->child_sync);\n\t\tshmctl(shm_id, IPC_RMID, NULL);\n\t}\n\n\treturn ret;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(ptrace_pkey, \"ptrace_pkey\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}