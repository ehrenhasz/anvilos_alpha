{
  "module_name": "rtas_filter.c",
  "hash_id": "7af91a800524edc182fd1b41516ce6962d155f46f8bd88eae6ff9decebf07171",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/syscalls/rtas_filter.c",
  "human_readable_source": "\n \n\n#include <byteswap.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"utils.h\"\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define cpu_to_be32(x)\t\tbswap_32(x)\n#define be32_to_cpu(x)\t\tbswap_32(x)\n#else\n#define cpu_to_be32(x)\t\t(x)\n#define be32_to_cpu(x)\t\t(x)\n#endif\n\n#define RTAS_IO_ASSERT\t-1098\t \n#define RTAS_UNKNOWN_OP -1099\t \n#define BLOCK_SIZE 4096\n#define PAGE_SIZE 4096\n#define MAX_PAGES 64\n\nstatic const char *ofdt_rtas_path = \"/proc/device-tree/rtas\";\n\ntypedef __be32 uint32_t;\nstruct rtas_args {\n\t__be32 token;\n\t__be32 nargs;\n\t__be32 nret;\n\t__be32 args[16];\n\t__be32 *rets;\t   \n};\n\nstruct region {\n\tuint64_t addr;\n\tuint32_t size;\n\tstruct region *next;\n};\n\nstatic int get_property(const char *prop_path, const char *prop_name,\n\t\t\tchar **prop_val, size_t *prop_len)\n{\n\tchar path[PATH_MAX];\n\n\tint len = snprintf(path, sizeof(path), \"%s/%s\", prop_path, prop_name);\n\tif (len < 0 || len >= sizeof(path))\n\t\treturn -ENOMEM;\n\n\treturn read_file_alloc(path, prop_val, prop_len);\n}\n\nint rtas_token(const char *call_name)\n{\n\tchar *prop_buf = NULL;\n\tsize_t len;\n\tint rc;\n\n\trc = get_property(ofdt_rtas_path, call_name, &prop_buf, &len);\n\tif (rc < 0) {\n\t\trc = RTAS_UNKNOWN_OP;\n\t\tgoto err;\n\t}\n\n\trc = be32_to_cpu(*(int *)prop_buf);\n\nerr:\n\tfree(prop_buf);\n\treturn rc;\n}\n\nstatic int read_kregion_bounds(struct region *kregion)\n{\n\tchar *buf;\n\tint err;\n\n\terr = read_file_alloc(\"/proc/ppc64/rtas/rmo_buffer\", &buf, NULL);\n\tif (err) {\n\t\tperror(\"Could not open rmo_buffer file\");\n\t\treturn RTAS_IO_ASSERT;\n\t}\n\n\tsscanf(buf, \"%\" SCNx64 \" %x\", &kregion->addr, &kregion->size);\n\tfree(buf);\n\n\tif (!(kregion->size && kregion->addr) ||\n\t    (kregion->size > (PAGE_SIZE * MAX_PAGES))) {\n\t\tprintf(\"Unexpected kregion bounds\\n\");\n\t\treturn RTAS_IO_ASSERT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtas_call(const char *name, int nargs,\n\t\t     int nrets, ...)\n{\n\tstruct rtas_args args;\n\t__be32 *rets[16];\n\tint i, rc, token;\n\tva_list ap;\n\n\tva_start(ap, nrets);\n\n\ttoken = rtas_token(name);\n\tif (token == RTAS_UNKNOWN_OP) {\n\t\t\n\t\tprintf(\"call '%s' not available, skipping...\", name);\n\t\trc = RTAS_UNKNOWN_OP;\n\t\tgoto err;\n\t}\n\n\targs.token = cpu_to_be32(token);\n\targs.nargs = cpu_to_be32(nargs);\n\targs.nret = cpu_to_be32(nrets);\n\n\tfor (i = 0; i < nargs; i++)\n\t\targs.args[i] = (__be32) va_arg(ap, unsigned long);\n\n\tfor (i = 0; i < nrets; i++)\n\t\trets[i] = (__be32 *) va_arg(ap, unsigned long);\n\n\trc = syscall(__NR_rtas, &args);\n\tif (rc) {\n\t\trc = -errno;\n\t\tgoto err;\n\t}\n\n\tif (nrets) {\n\t\t*(rets[0]) = be32_to_cpu(args.args[nargs]);\n\n\t\tfor (i = 1; i < nrets; i++) {\n\t\t\t*(rets[i]) = args.args[nargs + i];\n\t\t}\n\t}\n\nerr:\n\tva_end(ap);\n\treturn rc;\n}\n\nstatic int test(void)\n{\n\tstruct region rmo_region;\n\tuint32_t rmo_start;\n\tuint32_t rmo_end;\n\t__be32 rets[1];\n\tint rc;\n\n\t\n\t\n\tprintf(\"Test a permitted call, no parameters... \");\n\trc = rtas_call(\"get-time-of-day\", 0, 1, rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != 0 && rc != RTAS_UNKNOWN_OP);\n\n\t\n\t\n\tprintf(\"Test a prohibited call... \");\n\trc = rtas_call(\"nvram-fetch\", 0, 1, rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != -EINVAL && rc != RTAS_UNKNOWN_OP);\n\n\t\n\trc = read_kregion_bounds(&rmo_region);\n\tif (rc) {\n\t\tprintf(\"Couldn't read RMO region bounds, skipping remaining cases\\n\");\n\t\treturn 0;\n\t}\n\trmo_start = rmo_region.addr;\n\trmo_end = rmo_start + rmo_region.size - 1;\n\tprintf(\"RMO range: %08x - %08x\\n\", rmo_start, rmo_end);\n\n\t\n\t\n\tprintf(\"Test a permitted call, user-supplied size, buffer inside RMO... \");\n\trc = rtas_call(\"ibm,get-system-parameter\", 3, 1, 0, cpu_to_be32(rmo_start),\n\t\t       cpu_to_be32(rmo_end - rmo_start + 1), rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != 0 && rc != RTAS_UNKNOWN_OP);\n\n\t\n\t\n\tprintf(\"Test a permitted call, user-supplied size, buffer start outside RMO... \");\n\trc = rtas_call(\"ibm,get-system-parameter\", 3, 1, 0, cpu_to_be32(rmo_end + 1),\n\t\t       cpu_to_be32(4000), rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != -EINVAL && rc != RTAS_UNKNOWN_OP);\n\n\t\n\t\n\tprintf(\"Test a permitted call, user-supplied size, buffer end outside RMO... \");\n\trc = rtas_call(\"ibm,get-system-parameter\", 3, 1, 0, cpu_to_be32(rmo_start),\n\t\t       cpu_to_be32(rmo_end - rmo_start + 2), rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != -EINVAL && rc != RTAS_UNKNOWN_OP);\n\n\t\n\t\n\tprintf(\"Test a permitted call, fixed size, buffer end outside RMO... \");\n\trc = rtas_call(\"ibm,configure-connector\", 2, 1, cpu_to_be32(rmo_end - 4000), 0, rets);\n\tprintf(\"rc: %d\\n\", rc);\n\tFAIL_IF(rc != -EINVAL && rc != RTAS_UNKNOWN_OP);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(test, \"rtas_filter\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}