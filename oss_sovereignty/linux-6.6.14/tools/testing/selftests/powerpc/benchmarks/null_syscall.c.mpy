{
  "module_name": "null_syscall.c",
  "hash_id": "0c294c97d0814f1b0d499c5ae6933a445349ff0aa7262ad3abfafd69790028af",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/benchmarks/null_syscall.c",
  "human_readable_source": "\n \n\n#define NR_LOOPS 10000000\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/syscall.h>\n#include <signal.h>\n\nstatic volatile int soak_done;\nunsigned long long clock_frequency;\nunsigned long long timebase_frequency;\ndouble timebase_multiplier;\n\nstatic inline unsigned long mftb(void)\n{\n\tunsigned long low;\n\n\tasm volatile(\"mftb %0\" : \"=r\" (low));\n\n\treturn low;\n}\n\nstatic void sigalrm_handler(int unused)\n{\n\tsoak_done = 1;\n}\n\n \nstatic void cpu_soak_usecs(unsigned long usecs)\n{\n\tstruct itimerval val;\n\n\tmemset(&val, 0, sizeof(val));\n\tval.it_value.tv_usec = usecs;\n\n\tsignal(SIGALRM, sigalrm_handler);\n\tsetitimer(ITIMER_REAL, &val, NULL);\n\n\twhile (1) {\n\t\tif (soak_done)\n\t\t\tbreak;\n\t}\n\n\tsignal(SIGALRM, SIG_DFL);\n}\n\n \nstatic void get_proc_frequency(void)\n{\n\tFILE *f;\n\tchar line[128];\n\tchar *p, *end;\n\tunsigned long v;\n\tdouble d;\n\tchar *override;\n\n\t \n\tcpu_soak_usecs(0.25 * 1000000);\n\n\tf = fopen(\"/proc/cpuinfo\", \"r\");\n\tif (f == NULL)\n\t\treturn;\n\n\ttimebase_frequency = 0;\n\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (strncmp(line, \"timebase\", 8) == 0) {\n\t\t\tp = strchr(line, ':');\n\t\t\tif (p != NULL) {\n\t\t\t\tv = strtoull(p + 1, &end, 0);\n\t\t\t\tif (end != p + 1)\n\t\t\t\t\ttimebase_frequency = v;\n\t\t\t}\n\t\t}\n\n\t\tif (((strncmp(line, \"clock\", 5) == 0) ||\n\t\t     (strncmp(line, \"cpu MHz\", 7) == 0))) {\n\t\t\tp = strchr(line, ':');\n\t\t\tif (p != NULL) {\n\t\t\t\td = strtod(p + 1, &end);\n\t\t\t\tif (end != p + 1) {\n\t\t\t\t\t \n\t\t\t\t\tif ((d * 1000000ULL) > clock_frequency)\n\t\t\t\t\t\tclock_frequency = d * 1000000ULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(f);\n\n\toverride = getenv(\"FREQUENCY\");\n\tif (override)\n\t\tclock_frequency = strtoull(override, NULL, 10);\n\n\tif (timebase_frequency)\n\t\ttimebase_multiplier = (double)clock_frequency\n\t\t\t\t\t/ timebase_frequency;\n\telse\n\t\ttimebase_multiplier = 1;\n}\n\nstatic void do_null_syscall(unsigned long nr)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < nr; i++)\n\t\tsyscall(__NR_gettid);\n}\n\n#define TIME(A, STR) \\\n\nint main(void)\n{\n\tunsigned long tb_start, tb_now;\n\tstruct timespec tv_start, tv_now;\n\tunsigned long long elapsed_ns, elapsed_tb;\n\n\tget_proc_frequency();\n\n\tclock_gettime(CLOCK_MONOTONIC, &tv_start);\n\ttb_start = mftb();\n\n\tdo_null_syscall(NR_LOOPS);\n\n\tclock_gettime(CLOCK_MONOTONIC, &tv_now);\n\ttb_now = mftb();\n\n\telapsed_ns = (tv_now.tv_sec - tv_start.tv_sec) * 1000000000ULL +\n\t\t\t(tv_now.tv_nsec - tv_start.tv_nsec);\n\telapsed_tb = tb_now - tb_start;\n\n\tprintf(\"%10.2f ns %10.2f cycles\\n\", (float)elapsed_ns / NR_LOOPS,\n\t\t\t(float)elapsed_tb * timebase_multiplier / NR_LOOPS);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}