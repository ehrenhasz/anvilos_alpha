{
  "module_name": "context_switch.c",
  "hash_id": "e8ccfb8d5f61b53e21de5d5fc2989f3373d8041075a714f43c26f715a0a1a8e1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/benchmarks/context_switch.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <sched.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <getopt.h>\n#include <signal.h>\n#include <assert.h>\n#include <pthread.h>\n#include <limits.h>\n#include <sys/time.h>\n#include <sys/syscall.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <sys/shm.h>\n#include <linux/futex.h>\n#ifdef __powerpc__\n#include <altivec.h>\n#endif\n#include \"utils.h\"\n\nstatic unsigned int timeout = 30;\n\nstatic int touch_vdso;\nstruct timeval tv;\n\nstatic int touch_fp = 1;\ndouble fp;\n\nstatic int touch_vector = 1;\nvector int a, b, c;\n\n#ifdef __powerpc__\nstatic int touch_altivec = 1;\n\n \nstatic void __attribute__((__target__(\"no-vsx\"))) altivec_touch_fn(void)\n{\n\tc = a + b;\n}\n#endif\n\nstatic void touch(void)\n{\n\tif (touch_vdso)\n\t\tgettimeofday(&tv, NULL);\n\n\tif (touch_fp)\n\t\tfp += 0.1;\n\n#ifdef __powerpc__\n\tif (touch_altivec)\n\t\taltivec_touch_fn();\n#endif\n\n\tif (touch_vector)\n\t\tc = a + b;\n\n\tasm volatile(\"# %0 %1 %2\": : \"r\"(&tv), \"r\"(&fp), \"r\"(&c));\n}\n\nstatic void start_thread_on(void *(*fn)(void *), void *arg, unsigned long cpu)\n{\n\tint rc;\n\tpthread_t tid;\n\tcpu_set_t cpuset;\n\tpthread_attr_t attr;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\n\trc = pthread_attr_init(&attr);\n\tif (rc) {\n\t\terrno = rc;\n\t\tperror(\"pthread_attr_init\");\n\t\texit(1);\n\t}\n\n\trc = pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n\tif (rc)\t{\n\t\terrno = rc;\n\t\tperror(\"pthread_attr_setaffinity_np\");\n\t\texit(1);\n\t}\n\n\trc = pthread_create(&tid, &attr, fn, arg);\n\tif (rc) {\n\t\terrno = rc;\n\t\tperror(\"pthread_create\");\n\t\texit(1);\n\t}\n}\n\nstatic void start_process_on(void *(*fn)(void *), void *arg, unsigned long cpu)\n{\n\tint pid, ncpus;\n\tcpu_set_t *cpuset;\n\tsize_t size;\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\texit(1);\n\t}\n\n\tif (pid)\n\t\treturn;\n\n\tncpus = get_nprocs();\n\tsize = CPU_ALLOC_SIZE(ncpus);\n\tcpuset = CPU_ALLOC(ncpus);\n\tif (!cpuset) {\n\t\tperror(\"malloc\");\n\t\texit(1);\n\t}\n\tCPU_ZERO_S(size, cpuset);\n\tCPU_SET_S(cpu, size, cpuset);\n\n\tif (sched_setaffinity(0, size, cpuset)) {\n\t\tperror(\"sched_setaffinity\");\n\t\tCPU_FREE(cpuset);\n\t\texit(1);\n\t}\n\n\tCPU_FREE(cpuset);\n\tfn(arg);\n\n\texit(0);\n}\n\nstatic unsigned long iterations;\nstatic unsigned long iterations_prev;\n\nstatic void sigalrm_handler(int junk)\n{\n\tunsigned long i = iterations;\n\n\tprintf(\"%ld\\n\", i - iterations_prev);\n\titerations_prev = i;\n\n\tif (--timeout == 0)\n\t\tkill(0, SIGUSR1);\n\n\talarm(1);\n}\n\nstatic void sigusr1_handler(int junk)\n{\n\texit(0);\n}\n\nstruct actions {\n\tvoid (*setup)(int, int);\n\tvoid *(*thread1)(void *);\n\tvoid *(*thread2)(void *);\n};\n\n#define READ 0\n#define WRITE 1\n\nstatic int pipe_fd1[2];\nstatic int pipe_fd2[2];\n\nstatic void pipe_setup(int cpu1, int cpu2)\n{\n\tif (pipe(pipe_fd1) || pipe(pipe_fd2))\n\t\texit(1);\n}\n\nstatic void *pipe_thread1(void *arg)\n{\n\tsignal(SIGALRM, sigalrm_handler);\n\talarm(1);\n\n\twhile (1) {\n\t\tassert(read(pipe_fd1[READ], &c, 1) == 1);\n\t\ttouch();\n\n\t\tassert(write(pipe_fd2[WRITE], &c, 1) == 1);\n\t\ttouch();\n\n\t\titerations += 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *pipe_thread2(void *arg)\n{\n\twhile (1) {\n\t\tassert(write(pipe_fd1[WRITE], &c, 1) == 1);\n\t\ttouch();\n\n\t\tassert(read(pipe_fd2[READ], &c, 1) == 1);\n\t\ttouch();\n\t}\n\n\treturn NULL;\n}\n\nstatic struct actions pipe_actions = {\n\t.setup = pipe_setup,\n\t.thread1 = pipe_thread1,\n\t.thread2 = pipe_thread2,\n};\n\nstatic void yield_setup(int cpu1, int cpu2)\n{\n\tif (cpu1 != cpu2) {\n\t\tfprintf(stderr, \"Both threads must be on the same CPU for yield test\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void *yield_thread1(void *arg)\n{\n\tsignal(SIGALRM, sigalrm_handler);\n\talarm(1);\n\n\twhile (1) {\n\t\tsched_yield();\n\t\ttouch();\n\n\t\titerations += 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *yield_thread2(void *arg)\n{\n\twhile (1) {\n\t\tsched_yield();\n\t\ttouch();\n\t}\n\n\treturn NULL;\n}\n\nstatic struct actions yield_actions = {\n\t.setup = yield_setup,\n\t.thread1 = yield_thread1,\n\t.thread2 = yield_thread2,\n};\n\nstatic long sys_futex(void *addr1, int op, int val1, struct timespec *timeout,\n\t\t      void *addr2, int val3)\n{\n\treturn syscall(SYS_futex, addr1, op, val1, timeout, addr2, val3);\n}\n\nstatic unsigned long cmpxchg(unsigned long *p, unsigned long expected,\n\t\t\t     unsigned long desired)\n{\n\tunsigned long exp = expected;\n\n\t__atomic_compare_exchange_n(p, &exp, desired, 0,\n\t\t\t\t    __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n\treturn exp;\n}\n\nstatic unsigned long xchg(unsigned long *p, unsigned long val)\n{\n\treturn __atomic_exchange_n(p, val, __ATOMIC_SEQ_CST);\n}\n\nstatic int processes;\n\nstatic int mutex_lock(unsigned long *m)\n{\n\tint c;\n\tint flags = FUTEX_WAIT;\n\tif (!processes)\n\t\tflags |= FUTEX_PRIVATE_FLAG;\n\n\tc = cmpxchg(m, 0, 1);\n\tif (!c)\n\t\treturn 0;\n\n\tif (c == 1)\n\t\tc = xchg(m, 2);\n\n\twhile (c) {\n\t\tsys_futex(m, flags, 2, NULL, NULL, 0);\n\t\tc = xchg(m, 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int mutex_unlock(unsigned long *m)\n{\n\tint flags = FUTEX_WAKE;\n\tif (!processes)\n\t\tflags |= FUTEX_PRIVATE_FLAG;\n\n\tif (*m == 2)\n\t\t*m = 0;\n\telse if (xchg(m, 0) == 1)\n\t\treturn 0;\n\n\tsys_futex(m, flags, 1, NULL, NULL, 0);\n\n\treturn 0;\n}\n\nstatic unsigned long *m1, *m2;\n\nstatic void futex_setup(int cpu1, int cpu2)\n{\n\tif (!processes) {\n\t\tstatic unsigned long _m1, _m2;\n\t\tm1 = &_m1;\n\t\tm2 = &_m2;\n\t} else {\n\t\tint shmid;\n\t\tvoid *shmaddr;\n\n\t\tshmid = shmget(IPC_PRIVATE, getpagesize(), SHM_R | SHM_W);\n\t\tif (shmid < 0) {\n\t\t\tperror(\"shmget\");\n\t\t\texit(1);\n\t\t}\n\n\t\tshmaddr = shmat(shmid, NULL, 0);\n\t\tif (shmaddr == (char *)-1) {\n\t\t\tperror(\"shmat\");\n\t\t\tshmctl(shmid, IPC_RMID, NULL);\n\t\t\texit(1);\n\t\t}\n\n\t\tshmctl(shmid, IPC_RMID, NULL);\n\n\t\tm1 = shmaddr;\n\t\tm2 = shmaddr + sizeof(*m1);\n\t}\n\n\t*m1 = 0;\n\t*m2 = 0;\n\n\tmutex_lock(m1);\n\tmutex_lock(m2);\n}\n\nstatic void *futex_thread1(void *arg)\n{\n\tsignal(SIGALRM, sigalrm_handler);\n\talarm(1);\n\n\twhile (1) {\n\t\tmutex_lock(m2);\n\t\tmutex_unlock(m1);\n\n\t\titerations += 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *futex_thread2(void *arg)\n{\n\twhile (1) {\n\t\tmutex_unlock(m2);\n\t\tmutex_lock(m1);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct actions futex_actions = {\n\t.setup = futex_setup,\n\t.thread1 = futex_thread1,\n\t.thread2 = futex_thread2,\n};\n\nstatic struct option options[] = {\n\t{ \"test\", required_argument, 0, 't' },\n\t{ \"process\", no_argument, &processes, 1 },\n\t{ \"timeout\", required_argument, 0, 's' },\n\t{ \"vdso\", no_argument, &touch_vdso, 1 },\n\t{ \"no-fp\", no_argument, &touch_fp, 0 },\n#ifdef __powerpc__\n\t{ \"no-altivec\", no_argument, &touch_altivec, 0 },\n#endif\n\t{ \"no-vector\", no_argument, &touch_vector, 0 },\n\t{ 0, },\n};\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"Usage: context_switch2 <options> CPU1 CPU2\\n\\n\");\n\tfprintf(stderr, \"\\t\\t--test=X\\tpipe, futex or yield (default)\\n\");\n\tfprintf(stderr, \"\\t\\t--process\\tUse processes (default threads)\\n\");\n\tfprintf(stderr, \"\\t\\t--timeout=X\\tDuration in seconds to run (default 30)\\n\");\n\tfprintf(stderr, \"\\t\\t--vdso\\t\\ttouch VDSO\\n\");\n\tfprintf(stderr, \"\\t\\t--no-fp\\t\\tDon't touch FP\\n\");\n#ifdef __powerpc__\n\tfprintf(stderr, \"\\t\\t--no-altivec\\tDon't touch altivec\\n\");\n#endif\n\tfprintf(stderr, \"\\t\\t--no-vector\\tDon't touch vector\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n\tsigned char c;\n\tstruct actions *actions = &yield_actions;\n\tint cpu1;\n\tint cpu2;\n\tstatic void (*start_fn)(void *(*fn)(void *), void *arg, unsigned long cpu);\n\n\twhile (1) {\n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"\", options, &option_index);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tif (options[option_index].flag != 0)\n\t\t\t\tbreak;\n\n\t\t\tusage();\n\t\t\texit(1);\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tif (!strcmp(optarg, \"pipe\")) {\n\t\t\t\tactions = &pipe_actions;\n\t\t\t} else if (!strcmp(optarg, \"yield\")) {\n\t\t\t\tactions = &yield_actions;\n\t\t\t} else if (!strcmp(optarg, \"futex\")) {\n\t\t\t\tactions = &futex_actions;\n\t\t\t} else {\n\t\t\t\tusage();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\ttimeout = atoi(optarg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (processes)\n\t\tstart_fn = start_process_on;\n\telse\n\t\tstart_fn = start_thread_on;\n\n\tif (((argc - optind) != 2)) {\n\t\tcpu1 = cpu2 = pick_online_cpu();\n\t} else {\n\t\tcpu1 = atoi(argv[optind++]);\n\t\tcpu2 = atoi(argv[optind++]);\n\t}\n\n\tprintf(\"Using %s with \", processes ? \"processes\" : \"threads\");\n\n\tif (actions == &pipe_actions)\n\t\tprintf(\"pipe\");\n\telse if (actions == &yield_actions)\n\t\tprintf(\"yield\");\n\telse\n\t\tprintf(\"futex\");\n\n\tif (!have_hwcap(PPC_FEATURE_HAS_ALTIVEC))\n\t\ttouch_altivec = 0;\n\n\tif (!have_hwcap(PPC_FEATURE_HAS_VSX))\n\t\ttouch_vector = 0;\n\n\tprintf(\" on cpus %d/%d touching FP:%s altivec:%s vector:%s vdso:%s\\n\",\n\t       cpu1, cpu2, touch_fp ?  \"yes\" : \"no\", touch_altivec ? \"yes\" : \"no\",\n\t       touch_vector ? \"yes\" : \"no\", touch_vdso ? \"yes\" : \"no\");\n\n\t \n\tsetpgid(getpid(), getpid());\n\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tactions->setup(cpu1, cpu2);\n\n\tstart_fn(actions->thread1, NULL, cpu1);\n\tstart_fn(actions->thread2, NULL, cpu2);\n\n\twhile (1)\n\t\tsleep(3600);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}