{
  "module_name": "dscr_explicit_test.c",
  "hash_id": "0767f75ed6f94118d63676dc5869ed81f5757d6c0439038567681fc457cb0d33",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/dscr/dscr_explicit_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include \"dscr.h\"\n#include \"utils.h\"\n\n#include <pthread.h>\n#include <sched.h>\n#include <semaphore.h>\n\nvoid *dscr_explicit_lockstep_thread(void *args)\n{\n\tsem_t *prev = (sem_t *)args;\n\tsem_t *next = (sem_t *)args + 1;\n\tunsigned long expected_dscr = 0;\n\n\tset_dscr(expected_dscr);\n\tsrand(gettid());\n\n\tfor (int i = 0; i < COUNT; i++) {\n\t\tFAIL_IF_EXIT(sem_wait(prev));\n\n\t\tFAIL_IF_EXIT(expected_dscr != get_dscr());\n\t\tFAIL_IF_EXIT(expected_dscr != get_dscr_usr());\n\n\t\texpected_dscr = (expected_dscr + 1) % DSCR_MAX;\n\t\tset_dscr(expected_dscr);\n\n\t\tFAIL_IF_EXIT(sem_post(next));\n\t}\n\n\treturn NULL;\n}\n\nint dscr_explicit_lockstep_test(void)\n{\n\tpthread_t thread;\n\tsem_t semaphores[2];\n\tsem_t *prev = &semaphores[1];   \n\tsem_t *next = &semaphores[0];\n\tunsigned long expected_dscr = 0;\n\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_DSCR));\n\n\tsrand(gettid());\n\tset_dscr(expected_dscr);\n\n\tFAIL_IF(sem_init(prev, 0, 0));\n\tFAIL_IF(sem_init(next, 0, 1));   \n\tFAIL_IF(bind_to_cpu(BIND_CPU_ANY) < 0);\n\tFAIL_IF(pthread_create(&thread, NULL, dscr_explicit_lockstep_thread, (void *)semaphores));\n\n\tfor (int i = 0; i < COUNT; i++) {\n\t\tFAIL_IF(sem_wait(prev));\n\n\t\tFAIL_IF(expected_dscr != get_dscr());\n\t\tFAIL_IF(expected_dscr != get_dscr_usr());\n\n\t\texpected_dscr = (expected_dscr - 1) % DSCR_MAX;\n\t\tset_dscr(expected_dscr);\n\n\t\tFAIL_IF(sem_post(next));\n\t}\n\n\tFAIL_IF(pthread_join(thread, NULL));\n\tFAIL_IF(sem_destroy(prev));\n\tFAIL_IF(sem_destroy(next));\n\n\treturn 0;\n}\n\nstruct random_thread_args {\n\tpthread_t thread_id;\n\tbool do_yields;\n\tpthread_barrier_t *barrier;\n};\n\nvoid *dscr_explicit_random_thread(void *in)\n{\n\tstruct random_thread_args *args = (struct random_thread_args *)in;\n\tunsigned long expected_dscr = 0;\n\tint err;\n\n\tsrand(gettid());\n\n\terr = pthread_barrier_wait(args->barrier);\n\tFAIL_IF_EXIT(err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD);\n\n\tfor (int i = 0; i < COUNT; i++) {\n\t\texpected_dscr = rand() % DSCR_MAX;\n\t\tset_dscr(expected_dscr);\n\n\t\tfor (int j = rand() % 5; j > 0; --j) {\n\t\t\tFAIL_IF_EXIT(get_dscr() != expected_dscr);\n\t\t\tFAIL_IF_EXIT(get_dscr_usr() != expected_dscr);\n\n\t\t\tif (args->do_yields && rand() % 2)\n\t\t\t\tsched_yield();\n\t\t}\n\n\t\texpected_dscr = rand() % DSCR_MAX;\n\t\tset_dscr_usr(expected_dscr);\n\n\t\tfor (int j = rand() % 5; j > 0; --j) {\n\t\t\tFAIL_IF_EXIT(get_dscr() != expected_dscr);\n\t\t\tFAIL_IF_EXIT(get_dscr_usr() != expected_dscr);\n\n\t\t\tif (args->do_yields && rand() % 2)\n\t\t\t\tsched_yield();\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint dscr_explicit_random_test(void)\n{\n\tstruct random_thread_args threads[THREADS];\n\tpthread_barrier_t barrier;\n\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_DSCR));\n\n\tFAIL_IF(pthread_barrier_init(&barrier, NULL, THREADS));\n\n\tfor (int i = 0; i < THREADS; i++) {\n\t\tthreads[i].do_yields = i % 2 == 0;\n\t\tthreads[i].barrier = &barrier;\n\n\t\tFAIL_IF(pthread_create(&threads[i].thread_id, NULL,\n\t\t\t\t       dscr_explicit_random_thread, (void *)&threads[i]));\n\t}\n\n\tfor (int i = 0; i < THREADS; i++)\n\t\tFAIL_IF(pthread_join(threads[i].thread_id, NULL));\n\n\tFAIL_IF(pthread_barrier_destroy(&barrier));\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tunsigned long orig_dscr_default = 0;\n\tint err = 0;\n\n\tif (have_hwcap2(PPC_FEATURE2_DSCR))\n\t\torig_dscr_default = get_default_dscr();\n\n\terr |= test_harness(dscr_explicit_lockstep_test, \"dscr_explicit_lockstep_test\");\n\terr |= test_harness(dscr_explicit_random_test, \"dscr_explicit_random_test\");\n\n\tif (have_hwcap2(PPC_FEATURE2_DSCR))\n\t\tset_default_dscr(orig_dscr_default);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}