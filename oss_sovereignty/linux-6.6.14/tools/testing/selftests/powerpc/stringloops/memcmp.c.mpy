{
  "module_name": "memcmp.c",
  "hash_id": "b278ddfce75877c85d0dba0801bcab3b5c7a0528aeca30cb77b904927578ad51",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/stringloops/memcmp.c",
  "human_readable_source": "\n#include <malloc.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <time.h>\n\n#include \"utils.h\"\n\n#define SIZE 256\n#define ITERATIONS 10000\n\n#define LARGE_SIZE (5 * 1024)\n#define LARGE_ITERATIONS 1000\n#define LARGE_MAX_OFFSET 32\n#define LARGE_SIZE_START 4096\n\n \n#define MAP_SIZE (64 * 1024)\n\n#define MAX_OFFSET_DIFF_S1_S2 48\n\nint vmx_count;\nint enter_vmx_ops(void)\n{\n\tvmx_count++;\n\treturn 1;\n}\n\nvoid exit_vmx_ops(void)\n{\n\tvmx_count--;\n}\nint test_memcmp(const void *s1, const void *s2, size_t n);\n\n \nstatic void test_one(char *s1, char *s2, unsigned long max_offset,\n\t\tunsigned long size_start, unsigned long max_size)\n{\n\tunsigned long offset, size;\n\n\tfor (offset = 0; offset < max_offset; offset++) {\n\t\tfor (size = size_start; size < (max_size - offset); size++) {\n\t\t\tint x, y;\n\t\t\tunsigned long i;\n\n\t\t\ty = memcmp(s1+offset, s2+offset, size);\n\t\t\tx = test_memcmp(s1+offset, s2+offset, size);\n\n\t\t\tif (((x ^ y) < 0) &&\t \n\t\t\t\t((x | y) != 0)) {  \n\t\t\t\tprintf(\"memcmp returned %d, should have returned %d (offset %ld size %ld)\\n\", x, y, offset, size);\n\n\t\t\t\tfor (i = offset; i < offset+size; i++)\n\t\t\t\t\tprintf(\"%02x \", s1[i]);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tfor (i = offset; i < offset+size; i++)\n\t\t\t\t\tprintf(\"%02x \", s2[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tabort();\n\t\t\t}\n\n\t\t\tif (vmx_count != 0) {\n\t\t\t\tprintf(\"vmx enter/exit not paired.(offset:%ld size:%ld s1:%p s2:%p vc:%d\\n\",\n\t\t\t\t\toffset, size, s1, s2, vmx_count);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int testcase(bool islarge)\n{\n\tunsigned long i, comp_size, alloc_size;\n\tchar *p, *s1, *s2;\n\tint iterations;\n\n\tcomp_size = (islarge ? LARGE_SIZE : SIZE);\n\talloc_size = comp_size + MAX_OFFSET_DIFF_S1_S2;\n\titerations = islarge ? LARGE_ITERATIONS : ITERATIONS;\n\n\tp = mmap(NULL, 4 * MAP_SIZE, PROT_READ | PROT_WRITE,\n\t\t MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tFAIL_IF(p == MAP_FAILED);\n\n\t \n\ts1 = p + MAP_SIZE - alloc_size;\n\ts2 = p + 3 * MAP_SIZE - alloc_size;\n\n\t \n\tmunmap(p + MAP_SIZE, MAP_SIZE);\n\tmunmap(p + 3 * MAP_SIZE, MAP_SIZE);\n\n\tsrandom(time(0));\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tunsigned long j;\n\t\tunsigned long change;\n\t\tchar *rand_s1 = s1;\n\t\tchar *rand_s2 = s2;\n\n\t\tfor (j = 0; j < alloc_size; j++)\n\t\t\ts1[j] = random();\n\n\t\trand_s1 += random() % MAX_OFFSET_DIFF_S1_S2;\n\t\trand_s2 += random() % MAX_OFFSET_DIFF_S1_S2;\n\t\tmemcpy(rand_s2, rand_s1, comp_size);\n\n\t\t \n\t\tchange = random() % comp_size;\n\t\trand_s2[change] = random() & 0xff;\n\n\t\tif (islarge)\n\t\t\ttest_one(rand_s1, rand_s2, LARGE_MAX_OFFSET,\n\t\t\t\t\tLARGE_SIZE_START, comp_size);\n\t\telse\n\t\t\ttest_one(rand_s1, rand_s2, SIZE, 0, comp_size);\n\t}\n\n\tsrandom(time(0));\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tunsigned long j;\n\t\tunsigned long change;\n\t\tchar *rand_s1 = s1;\n\t\tchar *rand_s2 = s2;\n\n\t\tfor (j = 0; j < alloc_size; j++)\n\t\t\ts1[j] = random();\n\n\t\trand_s1 += random() % MAX_OFFSET_DIFF_S1_S2;\n\t\trand_s2 += random() % MAX_OFFSET_DIFF_S1_S2;\n\t\tmemcpy(rand_s2, rand_s1, comp_size);\n\n\t\t \n\t\tfor (j = 0; j < comp_size / 8; j++) {\n\t\t\tchange = random() % comp_size;\n\t\t\ts2[change] = random() & 0xff;\n\t\t}\n\n\t\tif (islarge)\n\t\t\ttest_one(rand_s1, rand_s2, LARGE_MAX_OFFSET,\n\t\t\t\t\tLARGE_SIZE_START, comp_size);\n\t\telse\n\t\t\ttest_one(rand_s1, rand_s2, SIZE, 0, comp_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int testcases(void)\n{\n#ifdef __powerpc64__\n\t\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_2_07));\n#endif\n\n\ttestcase(0);\n\ttestcase(1);\n\treturn 0;\n}\n\nint main(void)\n{\n\ttest_harness_set_timeout(300);\n\treturn test_harness(testcases, \"memcmp\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}