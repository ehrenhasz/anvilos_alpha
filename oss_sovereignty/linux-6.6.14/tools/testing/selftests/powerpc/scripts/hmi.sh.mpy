{
  "module_name": "hmi.sh",
  "hash_id": "bb50881512ff8b84793b43ca63b3385059ed299d91dfb008b43371a298f790cf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/scripts/hmi.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright 2015, Daniel Axtens, IBM Corporation\n#\n\n\n# do we have ./getscom, ./putscom?\nif [ -x ./getscom ] && [ -x ./putscom ]; then\n\tGETSCOM=./getscom\n\tPUTSCOM=./putscom\nelif which getscom > /dev/null; then\n\tGETSCOM=$(which getscom)\n\tPUTSCOM=$(which putscom)\nelse\n\tcat <<EOF\nCan't find getscom/putscom in . or \\$PATH.\nSee https://github.com/open-power/skiboot.\nThe tool is in external/xscom-utils\nEOF\n\texit 1\nfi\n\n# We will get 8 HMI events per injection\n# todo: deal with things being offline\nexpected_hmis=8\nCOUNT_HMIS() {\n    dmesg | grep -c 'Harmless Hypervisor Maintenance interrupt'\n}\n\n# massively expand snooze delay, allowing injection on all cores\nppc64_cpu --smt-snooze-delay=1000000000\n\n# when we exit, restore it\ntrap \"ppc64_cpu --smt-snooze-delay=100\" 0 1\n\n# for each chip+core combination\n# todo - less fragile parsing\ngrep -E -o 'OCC: Chip [0-9a-f]+ Core [0-9a-f]' < /sys/firmware/opal/msglog |\nwhile read chipcore; do\n\tchip=$(echo \"$chipcore\"|awk '{print $3}')\n\tcore=$(echo \"$chipcore\"|awk '{print $5}')\n\tfir=\"0x1${core}013100\"\n\n\t# verify that Core FIR is zero as expected\n\tif [ \"$($GETSCOM -c 0x${chip} $fir)\" != 0 ]; then\n\t\techo \"FIR was not zero before injection for chip $chip, core $core. Aborting!\"\n\t\techo \"Result of $GETSCOM -c 0x${chip} $fir:\"\n\t\t$GETSCOM -c 0x${chip} $fir\n\t\techo \"If you get a -5 error, the core may be in idle state. Try stress-ng.\"\n\t\techo \"Otherwise, try $PUTSCOM -c 0x${chip} $fir 0\"\n\t\texit 1\n\tfi\n\n\t# keep track of the number of HMIs handled\n\told_hmis=$(COUNT_HMIS)\n\n\t# do injection, adding a marker to dmesg for clarity\n\techo \"Injecting HMI on core $core, chip $chip\" | tee /dev/kmsg\n\t# inject a RegFile recoverable error\n\tif ! $PUTSCOM -c 0x${chip} $fir 2000000000000000 > /dev/null; then\n\t\techo \"Error injecting. Aborting!\"\n\t\texit 1\n\tfi\n\n\t# now we want to wait for all the HMIs to be processed\n\t# we expect one per thread on the core\n\ti=0;\n\tnew_hmis=$(COUNT_HMIS)\n\twhile [ $new_hmis -lt $((old_hmis + expected_hmis)) ] && [ $i -lt 12 ]; do\n\t    echo \"Seen $((new_hmis - old_hmis)) HMI(s) out of $expected_hmis expected, sleeping\"\n\t    sleep 5;\n\t    i=$((i + 1))\n\t    new_hmis=$(COUNT_HMIS)\n\tdone\n\tif [ $i = 12 ]; then\n\t    echo \"Haven't seen expected $expected_hmis recoveries after 1 min. Aborting.\"\n\t    exit 1\n\tfi\n\techo \"Processed $expected_hmis events; presumed success. Check dmesg.\"\n\techo \"\"\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}