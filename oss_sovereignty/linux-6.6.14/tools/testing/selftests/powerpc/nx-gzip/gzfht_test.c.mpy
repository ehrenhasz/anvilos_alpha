{
  "module_name": "gzfht_test.c",
  "hash_id": "8cf452683c49702873b04da6257eb9bac2c63648c91bbafd5f4dab6de396ff2b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/nx-gzip/gzfht_test.c",
  "human_readable_source": "\n\n \n\n#define _ISOC11_SOURCE\t\n#define _DEFAULT_SOURCE\t\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <endian.h>\n#include <bits/endian.h>\n#include <sys/ioctl.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include \"utils.h\"\n#include \"nxu.h\"\n#include \"nx.h\"\n\nint nx_dbg;\nFILE *nx_gzip_log;\n\n#define NX_MIN(X, Y) (((X) < (Y)) ? (X) : (Y))\n#define FNAME_MAX 1024\n#define FEXT \".nx.gz\"\n\n#define SYSFS_MAX_REQ_BUF_PATH \"devices/vio/ibm,compression-v1/nx_gzip_caps/req_max_processed_len\"\n\n \nstatic int compress_fht_sample(char *src, uint32_t srclen, char *dst,\n\t\t\t\tuint32_t dstlen, int with_count,\n\t\t\t\tstruct nx_gzip_crb_cpb_t *cmdp, void *handle)\n{\n\tuint32_t fc;\n\n\tassert(!!cmdp);\n\n\tput32(cmdp->crb, gzip_fc, 0);   \n\tfc = (with_count) ? GZIP_FC_COMPRESS_RESUME_FHT_COUNT :\n\t\t\t    GZIP_FC_COMPRESS_RESUME_FHT;\n\tputnn(cmdp->crb, gzip_fc, fc);\n\tputnn(cmdp->cpb, in_histlen, 0);  \n\tmemset((void *) &cmdp->crb.csb, 0, sizeof(cmdp->crb.csb));\n\n\t \n\tif (!with_count)\n\t\tput32(cmdp->cpb, out_spbc_comp, 0);\n\telse\n\t\tput32(cmdp->cpb, out_spbc_comp_with_count, 0);\n\n\t \n\tput64(cmdp->crb, csb_address, 0);\n\tput64(cmdp->crb, csb_address,\n\t      (uint64_t) &cmdp->crb.csb & csb_address_mask);\n\n\t \n\tclear_dde(cmdp->crb.source_dde);\n\tputnn(cmdp->crb.source_dde, dde_count, 0);\n\tput32(cmdp->crb.source_dde, ddebc, srclen);\n\tput64(cmdp->crb.source_dde, ddead, (uint64_t) src);\n\n\t \n\tclear_dde(cmdp->crb.target_dde);\n\tputnn(cmdp->crb.target_dde, dde_count, 0);\n\tput32(cmdp->crb.target_dde, ddebc, dstlen);\n\tput64(cmdp->crb.target_dde, ddead, (uint64_t) dst);\n\n\t \n\treturn nxu_submit_job(cmdp, handle);\n}\n\n \nint gzip_header_blank(char *buf)\n{\n\tint i = 0;\n\n\tbuf[i++] = 0x1f;  \n\tbuf[i++] = 0x8b;  \n\tbuf[i++] = 0x08;  \n\tbuf[i++] = 0x00;  \n\tbuf[i++] = 0x00;  \n\tbuf[i++] = 0x00;  \n\tbuf[i++] = 0x00;  \n\tbuf[i++] = 0x00;  \n\tbuf[i++] = 0x04;  \n\tbuf[i++] = 0x03;  \n\n\treturn i;\n}\n\n \nint append_sync_flush(char *buf, int tebc, int final)\n{\n\tuint64_t flush;\n\tint shift = (tebc & 0x7);\n\n\tif (tebc > 0) {\n\t\t \n\t\tbuf = buf - 1;\n\t\t*buf = *buf & (unsigned char) ((1<<tebc)-1);\n\t} else\n\t\t*buf = 0;\n\tflush = ((0x1ULL & final) << shift) | *buf;\n\tshift = shift + 3;  \n\tshift = (shift <= 8) ? 8 : 16;\n\tflush |= (0xFFFF0000ULL) << shift;  \n\tshift = shift + 32;\n\twhile (shift > 0) {\n\t\t*buf++ = (unsigned char) (flush & 0xffULL);\n\t\tflush = flush >> 8;\n\t\tshift = shift - 8;\n\t}\n\treturn(((tebc > 5) || (tebc == 0)) ? 5 : 4);\n}\n\n \nstatic void set_bfinal(void *buf, int bfinal)\n{\n\tchar *b = buf;\n\n\tif (bfinal)\n\t\t*b = *b | (unsigned char) 0x01;\n\telse\n\t\t*b = *b & (unsigned char) 0xfe;\n}\n\nint compress_file(int argc, char **argv, void *handle)\n{\n\tchar *inbuf, *outbuf, *srcbuf, *dstbuf;\n\tchar outname[FNAME_MAX];\n\tuint32_t srclen, dstlen;\n\tuint32_t flushlen, chunk;\n\tsize_t inlen, outlen, dsttotlen, srctotlen;\n\tuint32_t crc, spbc, tpbc, tebc;\n\tint lzcounts = 0;\n\tint cc;\n\tint num_hdr_bytes;\n\tstruct nx_gzip_crb_cpb_t *cmdp;\n\tuint32_t pagelen = 65536;\n\tint fault_tries = NX_MAX_FAULTS;\n\tchar buf[32];\n\n\tcmdp = (void *)(uintptr_t)\n\t\taligned_alloc(sizeof(struct nx_gzip_crb_cpb_t),\n\t\t\t      sizeof(struct nx_gzip_crb_cpb_t));\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"usage: %s <fname>\\n\", argv[0]);\n\t\texit(-1);\n\t}\n\tif (read_file_alloc(argv[1], &inbuf, &inlen))\n\t\texit(-1);\n\tfprintf(stderr, \"file %s read, %ld bytes\\n\", argv[1], inlen);\n\n\t \n\toutlen = 2 * inlen + 1024;\n\n\tassert(NULL != (outbuf = (char *)malloc(outlen)));\n\tnxu_touch_pages(outbuf, outlen, pagelen, 1);\n\n\t \n\tif (!read_sysfs_file(SYSFS_MAX_REQ_BUF_PATH, buf, sizeof(buf))) {\n\t\tchunk = atoi(buf);\n\t} else {\n\t\t \n\t\t \n\t\tchunk = 1<<22;\n\t}\n\n\t \n\tnum_hdr_bytes = gzip_header_blank(outbuf);\n\tdstbuf    = outbuf + num_hdr_bytes;\n\toutlen    = outlen - num_hdr_bytes;\n\tdsttotlen = num_hdr_bytes;\n\n\tsrcbuf    = inbuf;\n\tsrctotlen = 0;\n\n\t \n\tmemset(&cmdp->crb, 0, sizeof(cmdp->crb));\n\n\t \n\tput32(cmdp->cpb, in_crc, 0);\n\n\twhile (inlen > 0) {\n\n\t\t \n\t\tsrclen = NX_MIN(chunk, inlen);\n\t\t \n\t\tdstlen = NX_MIN(2*srclen, outlen);\n\n\t\t \n\n\t\t \n\t\tnxu_touch_pages(cmdp, sizeof(struct nx_gzip_crb_cpb_t), pagelen,\n\t\t\t\t1);\n\t\tnxu_touch_pages(srcbuf, srclen, pagelen, 0);\n\t\tnxu_touch_pages(dstbuf, dstlen, pagelen, 1);\n\n\t\tcc = compress_fht_sample(\n\t\t\tsrcbuf, srclen,\n\t\t\tdstbuf, dstlen,\n\t\t\tlzcounts, cmdp, handle);\n\n\t\tif (cc != ERR_NX_OK && cc != ERR_NX_TPBC_GT_SPBC &&\n\t\t    cc != ERR_NX_AT_FAULT) {\n\t\t\tfprintf(stderr, \"nx error: cc= %d\\n\", cc);\n\t\t\texit(-1);\n\t\t}\n\n\t\t \n\t\tif (cc == ERR_NX_AT_FAULT) {\n\t\t\tNXPRT(fprintf(stderr, \"page fault: cc= %d, \", cc));\n\t\t\tNXPRT(fprintf(stderr, \"try= %d, fsa= %08llx\\n\",\n\t\t\t\t  fault_tries,\n\t\t\t\t  (unsigned long long) cmdp->crb.csb.fsaddr));\n\t\t\tfault_tries--;\n\t\t\tif (fault_tries > 0) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"error: cannot progress; \");\n\t\t\t\tfprintf(stderr, \"too many faults\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t}\n\n\t\tfault_tries = NX_MAX_FAULTS;  \n\n\t\tinlen     = inlen - srclen;\n\t\tsrcbuf    = srcbuf + srclen;\n\t\tsrctotlen = srctotlen + srclen;\n\n\t\t \n\t\tspbc = (!lzcounts) ? get32(cmdp->cpb, out_spbc_comp) :\n\t\t\tget32(cmdp->cpb, out_spbc_comp_with_count);\n\t\tassert(spbc == srclen);\n\n\t\t \n\t\ttpbc = get32(cmdp->crb.csb, tpbc);\n\t\t \n\t\ttebc = getnn(cmdp->cpb, out_tebc);\n\t\tNXPRT(fprintf(stderr, \"compressed chunk %d \", spbc));\n\t\tNXPRT(fprintf(stderr, \"to %d bytes, tebc= %d\\n\", tpbc, tebc));\n\n\t\tif (inlen > 0) {  \n\t\t\tset_bfinal(dstbuf, 0);\n\t\t\tdstbuf    = dstbuf + tpbc;\n\t\t\tdsttotlen = dsttotlen + tpbc;\n\t\t\toutlen    = outlen - tpbc;\n\t\t\t \n\t\t\tflushlen  = append_sync_flush(dstbuf, tebc, 0);\n\t\t\tdsttotlen = dsttotlen + flushlen;\n\t\t\toutlen    = outlen - flushlen;\n\t\t\tdstbuf    = dstbuf + flushlen;\n\t\t\tNXPRT(fprintf(stderr, \"added sync_flush %d bytes\\n\",\n\t\t\t\t\tflushlen));\n\t\t} else {   \n\t\t\t \n\t\t\tset_bfinal(dstbuf, 1);\n\t\t\tdstbuf    = dstbuf + tpbc;\n\t\t\tdsttotlen = dsttotlen + tpbc;\n\t\t\toutlen    = outlen - tpbc;\n\t\t}\n\n\t\t \n\t\tcrc = get32(cmdp->cpb, out_crc);\n\t\tput32(cmdp->cpb, in_crc, crc);\n\t\tcrc = be32toh(crc);\n\t}\n\n\t \n\tmemcpy(dstbuf, &crc, 4);\n\tmemcpy(dstbuf+4, &srctotlen, 4);\n\tdsttotlen = dsttotlen + 8;\n\toutlen    = outlen - 8;\n\n\tassert(FNAME_MAX > (strlen(argv[1]) + strlen(FEXT)));\n\tstrcpy(outname, argv[1]);\n\tstrcat(outname, FEXT);\n\tif (write_file(outname, outbuf, dsttotlen)) {\n\t\tfprintf(stderr, \"write error: %s\\n\", outname);\n\t\texit(-1);\n\t}\n\n\tfprintf(stderr, \"compressed %ld to %ld bytes total, \", srctotlen,\n\t\tdsttotlen);\n\tfprintf(stderr, \"crc32 checksum = %08x\\n\", crc);\n\n\tif (inbuf != NULL)\n\t\tfree(inbuf);\n\n\tif (outbuf != NULL)\n\t\tfree(outbuf);\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint rc;\n\tstruct sigaction act;\n\tvoid *handle;\n\n\tnx_dbg = 0;\n\tnx_gzip_log = NULL;\n\tact.sa_handler = 0;\n\tact.sa_sigaction = nxu_sigsegv_handler;\n\tact.sa_flags = SA_SIGINFO;\n\tact.sa_restorer = 0;\n\tsigemptyset(&act.sa_mask);\n\tsigaction(SIGSEGV, &act, NULL);\n\n\thandle = nx_function_begin(NX_FUNC_COMP_GZIP, 0);\n\tif (!handle) {\n\t\tfprintf(stderr, \"Unable to init NX, errno %d\\n\", errno);\n\t\texit(-1);\n\t}\n\n\trc = compress_file(argc, argv, handle);\n\n\tnx_function_end(handle);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}