{
  "module_name": "gzip_vas.c",
  "hash_id": "7b4b6754872b324f7ab5bbc4933104b21efd40f8bfd94f99006b96cb941d403c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/nx-gzip/gzip_vas.c",
  "human_readable_source": "\n\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <endian.h>\n#include <bits/endian.h>\n#include <sys/ioctl.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include \"vas-api.h\"\n#include \"nx.h\"\n#include \"copy-paste.h\"\n#include \"nxu.h\"\n#include \"nx_dbg.h\"\n#include <sys/platform/ppc.h>\n\n#define barrier()\n#define hwsync()    ({ asm volatile(\"sync\" ::: \"memory\"); })\n\n#ifndef NX_NO_CPU_PRI\n#define cpu_pri_default()  ({ asm volatile (\"or 2, 2, 2\"); })\n#define cpu_pri_low()      ({ asm volatile (\"or 31, 31, 31\"); })\n#else\n#define cpu_pri_default()\n#define cpu_pri_low()\n#endif\n\nvoid *nx_fault_storage_address;\n\nstruct nx_handle {\n\tint fd;\n\tint function;\n\tvoid *paste_addr;\n};\n\nstatic int open_device_nodes(char *devname, int pri, struct nx_handle *handle)\n{\n\tint rc, fd;\n\tvoid *addr;\n\tstruct vas_tx_win_open_attr txattr;\n\n\tfd = open(devname, O_RDWR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \" open device name %s\\n\", devname);\n\t\treturn -errno;\n\t}\n\n\tmemset(&txattr, 0, sizeof(txattr));\n\ttxattr.version = 1;\n\ttxattr.vas_id = pri;\n\trc = ioctl(fd, VAS_TX_WIN_OPEN, (unsigned long)&txattr);\n\tif (rc < 0) {\n\t\tfprintf(stderr, \"ioctl() n %d, error %d\\n\", rc, errno);\n\t\trc = -errno;\n\t\tgoto out;\n\t}\n\n\taddr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0ULL);\n\tif (addr == MAP_FAILED) {\n\t\tfprintf(stderr, \"mmap() failed, errno %d\\n\", errno);\n\t\trc = -errno;\n\t\tgoto out;\n\t}\n\thandle->fd = fd;\n\thandle->paste_addr = (void *)((char *)addr + 0x400);\n\n\trc = 0;\nout:\n\tclose(fd);\n\treturn rc;\n}\n\nvoid *nx_function_begin(int function, int pri)\n{\n\tint rc;\n\tchar *devname = \"/dev/crypto/nx-gzip\";\n\tstruct nx_handle *nxhandle;\n\n\tif (function != NX_FUNC_COMP_GZIP) {\n\t\terrno = EINVAL;\n\t\tfprintf(stderr, \" NX_FUNC_COMP_GZIP not found\\n\");\n\t\treturn NULL;\n\t}\n\n\n\tnxhandle = malloc(sizeof(*nxhandle));\n\tif (!nxhandle) {\n\t\terrno = ENOMEM;\n\t\tfprintf(stderr, \" No memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tnxhandle->function = function;\n\trc = open_device_nodes(devname, pri, nxhandle);\n\tif (rc < 0) {\n\t\terrno = -rc;\n\t\tfprintf(stderr, \" open_device_nodes failed\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn nxhandle;\n}\n\nint nx_function_end(void *handle)\n{\n\tint rc = 0;\n\tstruct nx_handle *nxhandle = handle;\n\n\trc = munmap(nxhandle->paste_addr - 0x400, 4096);\n\tif (rc < 0) {\n\t\tfprintf(stderr, \"munmap() failed, errno %d\\n\", errno);\n\t\treturn rc;\n\t}\n\tclose(nxhandle->fd);\n\tfree(nxhandle);\n\n\treturn rc;\n}\n\nstatic int nx_wait_for_csb(struct nx_gzip_crb_cpb_t *cmdp)\n{\n\tlong poll = 0;\n\tuint64_t t;\n\n\t \n\tcpu_pri_low();\n\n#define CSB_MAX_POLL 200000000UL\n#define USLEEP_TH     300000UL\n\n\tt = __ppc_get_timebase();\n\n\twhile (getnn(cmdp->crb.csb, csb_v) == 0) {\n\t\t++poll;\n\t\thwsync();\n\n\t\tcpu_pri_low();\n\n\t\t \n\t\tif ((__ppc_get_timebase() - t) > USLEEP_TH) {\n\t\t\tcpu_pri_default();\n\t\t\tusleep(1);\n\t\t}\n\n\t\tif (poll > CSB_MAX_POLL)\n\t\t\tbreak;\n\n\t\t \n\t\tif (nx_fault_storage_address) {\n\t\t\tcpu_pri_default();\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t}\n\n\tcpu_pri_default();\n\n\t \n\thwsync();\n\n\t \n\tif (getnn(cmdp->crb.csb, csb_v) == 0) {\n\t\tfprintf(stderr, \"CSB still not valid after %d polls.\\n\",\n\t\t\t(int) poll);\n\t\tprt_err(\"CSB still not valid after %d polls, giving up.\\n\",\n\t\t\t(int) poll);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxu_run_job(struct nx_gzip_crb_cpb_t *cmdp, void *handle)\n{\n\tint i, ret, retries;\n\tstruct nx_handle *nxhandle = handle;\n\n\tassert(handle != NULL);\n\ti = 0;\n\tretries = 5000;\n\twhile (i++ < retries) {\n\t\thwsync();\n\t\tvas_copy(&cmdp->crb, 0);\n\t\tret = vas_paste(nxhandle->paste_addr, 0);\n\t\thwsync();\n\n\t\tNXPRT(fprintf(stderr, \"Paste attempt %d/%d returns 0x%x\\n\",\n\t\t\t\ti, retries, ret));\n\n\t\tif ((ret == 2) || (ret == 3)) {\n\n\t\t\tret = nx_wait_for_csb(cmdp);\n\t\t\tif (!ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret == -EAGAIN) {\n\t\t\t\tlong x;\n\n\t\t\t\tprt_err(\"Touching address %p, 0x%lx\\n\",\n\t\t\t\t\t nx_fault_storage_address,\n\t\t\t\t\t *(long *) nx_fault_storage_address);\n\t\t\t\tx = *(long *) nx_fault_storage_address;\n\t\t\t\t*(long *) nx_fault_storage_address = x;\n\t\t\t\tnx_fault_storage_address = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tprt_err(\"wait_for_csb() returns %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i < 10) {\n\t\t\t\t \n#define SPIN_TH 500UL\n\t\t\t\tuint64_t fail_spin;\n\n\t\t\t\tfail_spin = __ppc_get_timebase();\n\t\t\t\twhile ((__ppc_get_timebase() - fail_spin) <\n\t\t\t\t\t SPIN_TH)\n\t\t\t\t\t;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tunsigned int pr = 0;\n\n\t\t\t\tif (pr++ % 100 == 0) {\n\t\t\t\t\tprt_err(\"Paste attempt %d/\", i);\n\t\t\t\t\tprt_err(\"%d, failed pid= %d\\n\", retries,\n\t\t\t\t\t\tgetpid());\n\t\t\t\t}\n\t\t\t\tusleep(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n\nout:\n\tcpu_pri_default();\n\n\treturn ret;\n}\n\nint nxu_submit_job(struct nx_gzip_crb_cpb_t *cmdp, void *handle)\n{\n\tint cc;\n\n\tcc = nxu_run_job(cmdp, handle);\n\n\tif (!cc)\n\t\tcc = getnn(cmdp->crb.csb, csb_cc);       \n\n\treturn cc;\n}\n\n\nvoid nxu_sigsegv_handler(int sig, siginfo_t *info, void *ctx)\n{\n\tfprintf(stderr, \"%d: Got signal %d si_code %d, si_addr %p\\n\", getpid(),\n\t\tsig, info->si_code, info->si_addr);\n\n\tnx_fault_storage_address = info->si_addr;\n}\n\n \nint nxu_touch_pages(void *buf, long buf_len, long page_len, int wr)\n{\n\tchar *begin = buf;\n\tchar *end = (char *) buf + buf_len - 1;\n\tvolatile char t;\n\n\tassert(buf_len >= 0 && !!buf);\n\n\tNXPRT(fprintf(stderr, \"touch %p %p len 0x%lx wr=%d\\n\", buf,\n\t\t\t(buf + buf_len), buf_len, wr));\n\n\tif (buf_len <= 0 || buf == NULL)\n\t\treturn -1;\n\n\tdo {\n\t\tt = *begin;\n\t\tif (wr)\n\t\t\t*begin = t;\n\t\tbegin = begin + page_len;\n\t} while (begin < end);\n\n\t \n\tt = *end;\n\tif (wr)\n\t\t*end = t;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}