{
  "module_name": "gunz_test.c",
  "hash_id": "1fd90c9756999a6ffdc94cf2f8ed15468d7983376ae999f16f447bd08d3bdbb0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/nx-gzip/gunz_test.c",
  "human_readable_source": "\n\n \n\n#define _ISOC11_SOURCE\t\n#define _DEFAULT_SOURCE\t\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <endian.h>\n#include <bits/endian.h>\n#include <sys/ioctl.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include \"nxu.h\"\n#include \"nx.h\"\n#include \"crb.h\"\n\nint nx_dbg;\nFILE *nx_gzip_log;\n\n#define NX_MIN(X, Y) (((X) < (Y))?(X):(Y))\n#define NX_MAX(X, Y) (((X) > (Y))?(X):(Y))\n\n#define GETINPC(X) fgetc(X)\n#define FNAME_MAX 1024\n\n \n#define fifo_used_bytes(used) (used)\n#define fifo_free_bytes(used, len) ((len)-(used))\n \n#define fifo_free_first_bytes(cur, used, len)  ((((cur)+(used)) <= (len)) \\\n\t\t\t\t\t\t  ? (len)-((cur)+(used)) : 0)\n#define fifo_free_last_bytes(cur, used, len)   ((((cur)+(used)) <= (len)) \\\n\t\t\t\t\t\t  ? (cur) : (len)-(used))\n \n#define fifo_used_first_bytes(cur, used, len)  ((((cur)+(used)) <= (len)) \\\n\t\t\t\t\t\t  ? (used) : (len)-(cur))\n#define fifo_used_last_bytes(cur, used, len)   ((((cur)+(used)) <= (len)) \\\n\t\t\t\t\t\t  ? 0 : ((used)+(cur))-(len))\n \n#define fifo_free_first_offset(cur, used)      ((cur)+(used))\n#define fifo_free_last_offset(cur, used, len)  \\\n\t\t\t\t\t   fifo_used_last_bytes(cur, used, len)\n \n#define fifo_used_first_offset(cur)            (cur)\n#define fifo_used_last_offset(cur)             (0)\n\nconst int fifo_in_len = 1<<24;\nconst int fifo_out_len = 1<<24;\nconst int page_sz = 1<<16;\nconst int line_sz = 1<<7;\nconst int window_max = 1<<15;\n\n \nstatic inline uint32_t nx_append_dde(struct nx_dde_t *ddl, void *addr,\n\t\t\t\t\tuint32_t len)\n{\n\tuint32_t ddecnt;\n\tuint32_t bytes;\n\n\tif (addr == NULL && len == 0) {\n\t\tclearp_dde(ddl);\n\t\treturn 0;\n\t}\n\n\tNXPRT(fprintf(stderr, \"%d: %s addr %p len %x\\n\", __LINE__, addr,\n\t\t\t__func__, len));\n\n\t \n\tddecnt = getpnn(ddl, dde_count);\n\tbytes = getp32(ddl, ddebc);\n\n\tif (ddecnt == 0 && bytes == 0) {\n\t\t \n\t\tbytes = len;\n\t\tputp32(ddl, ddebc, bytes);\n\t\tputp64(ddl, ddead, (uint64_t) addr);\n\t} else if (ddecnt == 0) {\n\t\t \n\t\tddl[1] = ddl[0];\n\n\t\t \n\t\tclear_dde(ddl[2]);\n\t\tput32(ddl[2], ddebc, len);\n\t\tput64(ddl[2], ddead, (uint64_t) addr);\n\n\t\t \n\t\tddecnt = 2;\n\t\tputpnn(ddl, dde_count, ddecnt);\n\t\tbytes = bytes + len;\n\t\tputp32(ddl, ddebc, bytes);\n\t\t \n\t\tputp64(ddl, ddead, (uint64_t) &ddl[1]);\n\t} else {\n\t\t \n\t\t++ddecnt;\n\t\tclear_dde(ddl[ddecnt]);\n\t\tput64(ddl[ddecnt], ddead, (uint64_t) addr);\n\t\tput32(ddl[ddecnt], ddebc, len);\n\n\t\tputpnn(ddl, dde_count, ddecnt);\n\t\tbytes = bytes + len;\n\t\tputp32(ddl, ddebc, bytes);  \n\t}\n\treturn bytes;\n}\n\n \nstatic int nx_touch_pages_dde(struct nx_dde_t *ddep, long buf_sz, long page_sz,\n\t\t\t\tint wr)\n{\n\tuint32_t indirect_count;\n\tuint32_t buf_len;\n\tlong total;\n\tuint64_t buf_addr;\n\tstruct nx_dde_t *dde_list;\n\tint i;\n\n\tassert(!!ddep);\n\n\tindirect_count = getpnn(ddep, dde_count);\n\n\tNXPRT(fprintf(stderr, \"%s dde_count %d request len \", __func__,\n\t\t\tindirect_count));\n\tNXPRT(fprintf(stderr, \"0x%lx\\n\", buf_sz));\n\n\tif (indirect_count == 0) {\n\t\t \n\t\tbuf_len = getp32(ddep, ddebc);\n\t\tbuf_addr = getp64(ddep, ddead);\n\n\t\tNXPRT(fprintf(stderr, \"touch direct ddebc 0x%x ddead %p\\n\",\n\t\t\t\tbuf_len, (void *)buf_addr));\n\n\t\tif (buf_sz == 0)\n\t\t\tnxu_touch_pages((void *)buf_addr, buf_len, page_sz, wr);\n\t\telse\n\t\t\tnxu_touch_pages((void *)buf_addr, NX_MIN(buf_len,\n\t\t\t\t\tbuf_sz), page_sz, wr);\n\n\t\treturn ERR_NX_OK;\n\t}\n\n\t \n\tif (indirect_count > MAX_DDE_COUNT)\n\t\treturn ERR_NX_EXCESSIVE_DDE;\n\n\t \n\tdde_list = (struct nx_dde_t *) getp64(ddep, ddead);\n\n\tif (buf_sz == 0)\n\t\tbuf_sz = getp32(ddep, ddebc);\n\n\ttotal = 0;\n\tfor (i = 0; i < indirect_count; i++) {\n\t\tbuf_len = get32(dde_list[i], ddebc);\n\t\tbuf_addr = get64(dde_list[i], ddead);\n\t\ttotal += buf_len;\n\n\t\tNXPRT(fprintf(stderr, \"touch loop len 0x%x ddead %p total \",\n\t\t\t\tbuf_len, (void *)buf_addr));\n\t\tNXPRT(fprintf(stderr, \"0x%lx\\n\", total));\n\n\t\t \n\t\tif (total > buf_sz) {\n\t\t\tbuf_len = NX_MIN(buf_len, total - buf_sz);\n\t\t\tnxu_touch_pages((void *)buf_addr, buf_len, page_sz, wr);\n\t\t\tNXPRT(fprintf(stderr, \"touch loop break len 0x%x \",\n\t\t\t\t      buf_len));\n\t\t\tNXPRT(fprintf(stderr, \"ddead %p\\n\", (void *)buf_addr));\n\t\t\tbreak;\n\t\t}\n\t\tnxu_touch_pages((void *)buf_addr, buf_len, page_sz, wr);\n\t}\n\treturn ERR_NX_OK;\n}\n\n \nstatic int nx_submit_job(struct nx_dde_t *src, struct nx_dde_t *dst,\n\t\t\t struct nx_gzip_crb_cpb_t *cmdp, void *handle)\n{\n\tuint64_t csbaddr;\n\n\tmemset((void *)&cmdp->crb.csb, 0, sizeof(cmdp->crb.csb));\n\n\tcmdp->crb.source_dde = *src;\n\tcmdp->crb.target_dde = *dst;\n\n\t \n\tcsbaddr = ((uint64_t) &cmdp->crb.csb) & csb_address_mask;\n\tput64(cmdp->crb, csb_address, csbaddr);\n\n\t \n\tcmdp->cpb.out_spbc_comp_wrap = 0;\n\tcmdp->cpb.out_spbc_comp_with_count = 0;\n\tcmdp->cpb.out_spbc_decomp = 0;\n\n\t \n\tput32(cmdp->cpb, out_crc, INIT_CRC);\n\tput32(cmdp->cpb, out_adler, INIT_ADLER);\n\n\t \n\treturn nxu_submit_job(cmdp, handle);\n}\n\nint decompress_file(int argc, char **argv, void *devhandle)\n{\n\tFILE *inpf = NULL;\n\tFILE *outf = NULL;\n\n\tint c, expect, i, cc, rc = 0;\n\tchar gzfname[FNAME_MAX];\n\n\t \n\tchar *fifo_in, *fifo_out;\n\tint used_in, cur_in, used_out, cur_out, read_sz, n;\n\tint first_free, last_free, first_used, last_used;\n\tint first_offset, last_offset;\n\tint write_sz, free_space, source_sz;\n\tint source_sz_estimate, target_sz_estimate;\n\tuint64_t last_comp_ratio = 0;  \n\tuint64_t total_out = 0;\n\tint is_final, is_eof;\n\n\t \n\tint sfbt, subc, spbc, tpbc, nx_ce, fc, resuming = 0;\n\tint history_len = 0;\n\tstruct nx_gzip_crb_cpb_t cmd, *cmdp;\n\tstruct nx_dde_t *ddl_in;\n\tstruct nx_dde_t dde_in[6] __aligned(128);\n\tstruct nx_dde_t *ddl_out;\n\tstruct nx_dde_t dde_out[6] __aligned(128);\n\tint pgfault_retries;\n\n\t \n\toff_t input_file_offset;\n\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"usage: %s <fname> or stdin\\n\", argv[0]);\n\t\tfprintf(stderr, \"    writes to stdout or <fname>.nx.gunzip\\n\");\n\t\treturn -1;\n\t}\n\n\tif (argc == 1) {\n\t\tinpf = stdin;\n\t\toutf = stdout;\n\t} else if (argc == 2) {\n\t\tchar w[1024];\n\t\tchar *wp;\n\n\t\tinpf = fopen(argv[1], \"r\");\n\t\tif (inpf == NULL) {\n\t\t\tperror(argv[1]);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\twp = (NULL != (wp = strrchr(argv[1], '/'))) ? (wp+1) : argv[1];\n\t\tstrcpy(w, wp);\n\t\tstrcat(w, \".nx.gunzip\");\n\n\t\toutf = fopen(w, \"w\");\n\t\tif (outf == NULL) {\n\t\t\tperror(w);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tc = GETINPC(inpf); expect = 0x1f;  \n\tif (c != expect)\n\t\tgoto err1;\n\n\tc = GETINPC(inpf); expect = 0x8b;  \n\tif (c != expect)\n\t\tgoto err1;\n\n\tc = GETINPC(inpf); expect = 0x08;  \n\tif (c != expect)\n\t\tgoto err1;\n\n\tint flg = GETINPC(inpf);  \n\n\tif (flg & 0xE0 || flg & 0x4 || flg == EOF)\n\t\tgoto err2;\n\n\tfprintf(stderr, \"gzHeader FLG %x\\n\", flg);\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tchar tmp[10];\n\n\t\ttmp[i] = GETINPC(inpf);\n\t\tif (tmp[i] == EOF)\n\t\t\tgoto err3;\n\t\tfprintf(stderr, \"%02x \", tmp[i]);\n\t\tif (i == 5)\n\t\t\tfprintf(stderr, \"\\n\");\n\t}\n\tfprintf(stderr, \"gzHeader MTIME, XFL, OS ignored\\n\");\n\n\t \n\tif (flg & 0x8) {\n\t\tint k = 0;\n\n\t\tdo {\n\t\t\tc = GETINPC(inpf);\n\t\t\tif (c == EOF || k >= FNAME_MAX)\n\t\t\t\tgoto err3;\n\t\t\tgzfname[k++] = c;\n\t\t} while (c);\n\t\tfprintf(stderr, \"gzHeader FNAME: %s\\n\", gzfname);\n\t}\n\n\t \n\tif (flg & 0x2) {\n\t\tc = GETINPC(inpf);\n\t\tif (c == EOF)\n\t\t\tgoto err3;\n\t\tc = GETINPC(inpf);\n\t\tif (c == EOF)\n\t\t\tgoto err3;\n\t\tfprintf(stderr, \"gzHeader FHCRC: ignored\\n\");\n\t}\n\n\tused_in = cur_in = used_out = cur_out = 0;\n\tis_final = is_eof = 0;\n\n\t \n\tassert((fifo_in  = (char *)(uintptr_t)aligned_alloc(line_sz,\n\t\t\t\t   fifo_in_len + page_sz)) != NULL);\n\tassert((fifo_out = (char *)(uintptr_t)aligned_alloc(line_sz,\n\t\t\t\t   fifo_out_len + page_sz + line_sz)) != NULL);\n\t \n\tfifo_out = fifo_out + line_sz;\n\tnxu_touch_pages(fifo_out, fifo_out_len, page_sz, 1);\n\n\tddl_in  = &dde_in[0];\n\tddl_out = &dde_out[0];\n\tcmdp = &cmd;\n\tmemset(&cmdp->crb, 0, sizeof(cmdp->crb));\n\nread_state:\n\n\t \n\n\tNXPRT(fprintf(stderr, \"read_state:\\n\"));\n\n\tif (is_eof != 0)\n\t\tgoto write_state;\n\n\t \n\n\t \n\tcur_in = (used_in == 0) ? 0 : cur_in;\n\n\t \n\tfree_space = NX_MAX(0, fifo_free_bytes(used_in, fifo_in_len)\n\t\t\t    - line_sz);\n\n\t \n\tfirst_free = fifo_free_first_bytes(cur_in, used_in, fifo_in_len);\n\tlast_free  = fifo_free_last_bytes(cur_in, used_in, fifo_in_len);\n\n\t \n\tfirst_offset = fifo_free_first_offset(cur_in, used_in);\n\tlast_offset  = fifo_free_last_offset(cur_in, used_in, fifo_in_len);\n\n\t \n\tread_sz = NX_MIN(free_space, first_free);\n\tn = 0;\n\tif (read_sz > 0) {\n\t\t \n\t\tn = fread(fifo_in + first_offset, 1, read_sz, inpf);\n\t\tused_in = used_in + n;\n\t\tfree_space = free_space - n;\n\t\tassert(n <= read_sz);\n\t\tif (n != read_sz) {\n\t\t\t \n\t\t\tis_eof = 1;\n\t\t\tgoto write_state;\n\t\t}\n\t}\n\n\t \n\tif (last_free > 0) {\n\t\t \n\t\tread_sz = NX_MIN(free_space, last_free);\n\t\tn = 0;\n\t\tif (read_sz > 0) {\n\t\t\tn = fread(fifo_in + last_offset, 1, read_sz, inpf);\n\t\t\tused_in = used_in + n;        \n\t\t\tfree_space = free_space - n;  \n\t\t\tassert(n <= read_sz);\n\t\t\tif (n != read_sz) {\n\t\t\t\t \n\t\t\t\tis_eof = 1;\n\t\t\t\tgoto write_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\nwrite_state:\n\n\t \n\n\tNXPRT(fprintf(stderr, \"write_state:\\n\"));\n\n\tif (used_out == 0)\n\t\tgoto decomp_state;\n\n\t \n\n\tfirst_used = fifo_used_first_bytes(cur_out, used_out, fifo_out_len);\n\tlast_used  = fifo_used_last_bytes(cur_out, used_out, fifo_out_len);\n\n\twrite_sz = first_used;\n\n\tn = 0;\n\tif (write_sz > 0) {\n\t\tn = fwrite(fifo_out + cur_out, 1, write_sz, outf);\n\t\tused_out = used_out - n;\n\t\t \n\t\tcur_out = (cur_out + n) % fifo_out_len;\n\t\tassert(n <= write_sz);\n\t\tif (n != write_sz) {\n\t\t\tfprintf(stderr, \"error: write\\n\");\n\t\t\trc = -1;\n\t\t\tgoto err5;\n\t\t}\n\t}\n\n\tif (last_used > 0) {  \n\t\twrite_sz = last_used;  \n\t\tn = 0;\n\t\tif (write_sz > 0) {\n\t\t\tn = fwrite(fifo_out, 1, write_sz, outf);\n\t\t\tused_out = used_out - n;\n\t\t\tcur_out = (cur_out + n) % fifo_out_len;\n\t\t\tassert(n <= write_sz);\n\t\t\tif (n != write_sz) {\n\t\t\t\tfprintf(stderr, \"error: write\\n\");\n\t\t\t\trc = -1;\n\t\t\t\tgoto err5;\n\t\t\t}\n\t\t}\n\t}\n\ndecomp_state:\n\n\t \n\n\tNXPRT(fprintf(stderr, \"decomp_state:\\n\"));\n\n\tif (is_final)\n\t\tgoto finish_state;\n\n\t \n\tclearp_dde(ddl_in);\n\tclearp_dde(ddl_out);\n\n\t \n\tif (resuming) {\n\t\t \n\t\tfc = GZIP_FC_DECOMPRESS_RESUME;\n\n\t\tcmdp->cpb.in_crc   = cmdp->cpb.out_crc;\n\t\tcmdp->cpb.in_adler = cmdp->cpb.out_adler;\n\n\t\t \n\t\thistory_len = (history_len + 15) / 16;\n\t\tputnn(cmdp->cpb, in_histlen, history_len);\n\t\thistory_len = history_len * 16;  \n\n\t\tif (history_len > 0) {\n\t\t\t \n\t\t\tif (cur_out >= history_len) {\n\t\t\t\tnx_append_dde(ddl_in, fifo_out\n\t\t\t\t\t      + (cur_out - history_len),\n\t\t\t\t\t      history_len);\n\t\t\t} else {\n\t\t\t\tnx_append_dde(ddl_in, fifo_out\n\t\t\t\t\t      + ((fifo_out_len + cur_out)\n\t\t\t\t\t      - history_len),\n\t\t\t\t\t      history_len - cur_out);\n\t\t\t\t \n\t\t\t\tnx_append_dde(ddl_in, fifo_out, cur_out);\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\t \n\t\tfc = GZIP_FC_DECOMPRESS;\n\n\t\thistory_len = 0;\n\t\t \n\t\tcmdp->cpb.in_histlen = 0;\n\t\ttotal_out = 0;\n\n\t\tput32(cmdp->cpb, in_crc, INIT_CRC);\n\t\tput32(cmdp->cpb, in_adler, INIT_ADLER);\n\t\tput32(cmdp->cpb, out_crc, INIT_CRC);\n\t\tput32(cmdp->cpb, out_adler, INIT_ADLER);\n\n\t\t \n\t\tlast_comp_ratio = 100UL;\n\t}\n\tcmdp->crb.gzip_fc = 0;\n\tputnn(cmdp->crb, gzip_fc, fc);\n\n\t \n\tfirst_used = fifo_used_first_bytes(cur_in, used_in, fifo_in_len);\n\tlast_used = fifo_used_last_bytes(cur_in, used_in, fifo_in_len);\n\n\tif (first_used > 0)\n\t\tnx_append_dde(ddl_in, fifo_in + cur_in, first_used);\n\n\tif (last_used > 0)\n\t\tnx_append_dde(ddl_in, fifo_in, last_used);\n\n\t \n\tfirst_free = fifo_free_first_bytes(cur_out, used_out, fifo_out_len);\n\tlast_free = fifo_free_last_bytes(cur_out, used_out, fifo_out_len);\n\n\t \n\tint target_max = NX_MAX(0, fifo_free_bytes(used_out, fifo_out_len)\n\t\t\t\t- (1<<16));\n\n\tNXPRT(fprintf(stderr, \"target_max %d (0x%x)\\n\", target_max,\n\t\t      target_max));\n\n\tfirst_free = NX_MIN(target_max, first_free);\n\tif (first_free > 0) {\n\t\tfirst_offset = fifo_free_first_offset(cur_out, used_out);\n\t\tnx_append_dde(ddl_out, fifo_out + first_offset, first_free);\n\t}\n\n\tif (last_free > 0) {\n\t\tlast_free = NX_MIN(target_max - first_free, last_free);\n\t\tif (last_free > 0) {\n\t\t\tlast_offset = fifo_free_last_offset(cur_out, used_out,\n\t\t\t\t\t\t\t    fifo_out_len);\n\t\t\tnx_append_dde(ddl_out, fifo_out + last_offset,\n\t\t\t\t      last_free);\n\t\t}\n\t}\n\n\t \n\n\t \n\tsource_sz = getp32(ddl_in, ddebc);\n\tassert(source_sz > history_len);\n\tsource_sz = source_sz - history_len;\n\n\t \n\n\tsource_sz_estimate = ((uint64_t)target_max * last_comp_ratio * 3UL)\n\t\t\t\t/ 4000;\n\n\tif (source_sz_estimate < source_sz) {\n\t\t \n\t\tsource_sz = source_sz_estimate;\n\t\ttarget_sz_estimate = target_max;\n\t} else {\n\t\t \n\t\ttarget_sz_estimate = ((uint64_t)source_sz * 1000UL)\n\t\t\t\t\t/ (last_comp_ratio + 1);\n\t\ttarget_sz_estimate = NX_MIN(2 * target_sz_estimate,\n\t\t\t\t\t    target_max);\n\t}\n\n\tsource_sz = source_sz + history_len;\n\n\t \n\tpgfault_retries = NX_MAX_FAULTS;\n\nrestart_nx:\n\n\tputp32(ddl_in, ddebc, source_sz);\n\n\t \n\tnxu_touch_pages(cmdp, sizeof(struct nx_gzip_crb_cpb_t), page_sz, 1);\n\tnx_touch_pages_dde(ddl_in, 0, page_sz, 0);\n\tnx_touch_pages_dde(ddl_out, target_sz_estimate, page_sz, 1);\n\n\t \n\tcc = nx_submit_job(ddl_in, ddl_out, cmdp, devhandle);\n\n\tswitch (cc) {\n\n\tcase ERR_NX_AT_FAULT:\n\n\t\t \n\t\tNXPRT(fprintf(stderr, \"ERR_NX_AT_FAULT %p\\n\",\n\t\t\t      (void *)cmdp->crb.csb.fsaddr));\n\n\t\tif (pgfault_retries == NX_MAX_FAULTS) {\n\t\t\t \n\t\t\t--pgfault_retries;\n\t\t\tgoto restart_nx;\n\t\t} else if (pgfault_retries > 0) {\n\t\t\t \n\t\t\tif (source_sz > page_sz)\n\t\t\t\tsource_sz = NX_MAX(source_sz / 2, page_sz);\n\t\t\t--pgfault_retries;\n\t\t\tgoto restart_nx;\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot make progress; too many \");\n\t\t\tfprintf(stderr, \"page fault retries cc= %d\\n\", cc);\n\t\t\trc = -1;\n\t\t\tgoto err5;\n\t\t}\n\n\tcase ERR_NX_DATA_LENGTH:\n\n\t\tNXPRT(fprintf(stderr, \"ERR_NX_DATA_LENGTH; \"));\n\t\tNXPRT(fprintf(stderr, \"stream may have trailing data\\n\"));\n\n\t\t \n\t\tnx_ce = get_csb_ce_ms3b(cmdp->crb.csb);\n\n\t\tif (!csb_ce_termination(nx_ce) &&\n\t\t    csb_ce_partial_completion(nx_ce)) {\n\t\t\t \n\t\t\tsfbt = getnn(cmdp->cpb, out_sfbt);  \n\t\t\tsubc = getnn(cmdp->cpb, out_subc);  \n\t\t\tspbc = get32(cmdp->cpb, out_spbc_decomp);\n\t\t\ttpbc = get32(cmdp->crb.csb, tpbc);\n\t\t\tassert(target_max >= tpbc);\n\n\t\t\tgoto ok_cc3;  \n\t\t} else {\n\t\t\t \n\t\t\trc = -1;\n\t\t\tfprintf(stderr, \"history length error cc= %d\\n\", cc);\n\t\t\tgoto err5;\n\t\t}\n\n\tcase ERR_NX_TARGET_SPACE:\n\n\t\t \n\t\tassert(source_sz > history_len);\n\t\tsource_sz = ((source_sz - history_len + 2) / 2) + history_len;\n\t\tNXPRT(fprintf(stderr, \"ERR_NX_TARGET_SPACE; retry with \"));\n\t\tNXPRT(fprintf(stderr, \"smaller input data src %d hist %d\\n\",\n\t\t\t      source_sz, history_len));\n\t\tgoto restart_nx;\n\n\tcase ERR_NX_OK:\n\n\t\t \n\t\tfprintf(stderr, \"ERR_NX_OK\\n\");\n\t\tspbc = get32(cmdp->cpb, out_spbc_decomp);\n\t\ttpbc = get32(cmdp->crb.csb, tpbc);\n\t\tassert(target_max >= tpbc);\n\t\tassert(spbc >= history_len);\n\t\tsource_sz = spbc - history_len;\n\t\tgoto offsets_state;\n\n\tdefault:\n\t\tfprintf(stderr, \"error: cc= %d\\n\", cc);\n\t\trc = -1;\n\t\tgoto err5;\n\t}\n\nok_cc3:\n\n\tNXPRT(fprintf(stderr, \"cc3: sfbt: %x\\n\", sfbt));\n\n\tassert(spbc > history_len);\n\tsource_sz = spbc - history_len;\n\n\t \n\n\tswitch (sfbt) {\n\t\tint dhtlen;\n\n\tcase 0x0:  \n\n\t\t \n\n\t\tsource_sz = source_sz - subc / 8;\n\t\tis_final = 1;\n\t\tbreak;\n\n\t\t \n\n\tcase 0x8:  \n\tcase 0x9:  \n\n\t\t \n\t\tsource_sz = source_sz - ((subc + 7) / 8);\n\n\t\t \n\t\tcmdp->cpb.in_subc = 0;\n\t\tcmdp->cpb.in_sfbt = 0;\n\t\tputnn(cmdp->cpb, in_subc, subc % 8);\n\t\tputnn(cmdp->cpb, in_sfbt, sfbt);\n\t\tputnn(cmdp->cpb, in_rembytecnt, getnn(cmdp->cpb,\n\t\t\t\t\t\t      out_rembytecnt));\n\t\tbreak;\n\n\tcase 0xA:  \n\tcase 0xB:  \n\n\t\tsource_sz = source_sz - ((subc + 7) / 8);\n\n\t\t \n\t\tcmdp->cpb.in_subc = 0;\n\t\tcmdp->cpb.in_sfbt = 0;\n\t\tputnn(cmdp->cpb, in_subc, subc % 8);\n\t\tputnn(cmdp->cpb, in_sfbt, sfbt);\n\t\tbreak;\n\n\tcase 0xC:  \n\tcase 0xD:  \n\n\t\tsource_sz = source_sz - ((subc + 7) / 8);\n\n\t\t \n\t\tcmdp->cpb.in_subc = 0;\n\t\tcmdp->cpb.in_sfbt = 0;\n\t\tputnn(cmdp->cpb, in_subc, subc % 8);\n\t\tputnn(cmdp->cpb, in_sfbt, sfbt);\n\n\t\tdhtlen = getnn(cmdp->cpb, out_dhtlen);\n\t\tputnn(cmdp->cpb, in_dhtlen, dhtlen);\n\t\tassert(dhtlen >= 42);\n\n\t\t \n\t\tdhtlen = (dhtlen + 127) / 128;\n\n\t\twhile (dhtlen > 0) {  \n\t\t\t--dhtlen;\n\t\t\tcmdp->cpb.in_dht[dhtlen] = cmdp->cpb.out_dht[dhtlen];\n\t\t}\n\t\tbreak;\n\n\tcase 0xE:  \n\t\t      \n\tcase 0xF:  \n\n\t\tsource_sz = source_sz - ((subc + 7) / 8);\n\n\t\t \n\t\tcmdp->cpb.in_subc = 0;\n\t\tcmdp->cpb.in_sfbt = 0;\n\t\tputnn(cmdp->cpb, in_subc, subc % 8);\n\t\tputnn(cmdp->cpb, in_sfbt, sfbt);\n\n\t\t \n\t\tif (is_eof && (source_sz == 0))\n\t\t\tis_final = 1;\n\t}\n\noffsets_state:\n\n\t \n\n\tNXPRT(fprintf(stderr, \"offsets_state:\\n\"));\n\n\t \n\tused_in = used_in - source_sz;\n\tcur_in = (cur_in + source_sz) % fifo_in_len;\n\tinput_file_offset = input_file_offset + source_sz;\n\n\t \n\tused_out = used_out + tpbc;\n\n\tassert(used_out <= fifo_out_len);\n\n\ttotal_out = total_out + tpbc;\n\n\t \n\thistory_len = (total_out > window_max) ? window_max : total_out;\n\n\t \n\tlast_comp_ratio = (1000UL * ((uint64_t)source_sz + 1))\n\t\t\t  / ((uint64_t)tpbc + 1);\n\tlast_comp_ratio = NX_MAX(NX_MIN(1000UL, last_comp_ratio), 1);\n\tNXPRT(fprintf(stderr, \"comp_ratio %ld source_sz %d spbc %d tpbc %d\\n\",\n\t\t      last_comp_ratio, source_sz, spbc, tpbc));\n\n\tresuming = 1;\n\nfinish_state:\n\n\tNXPRT(fprintf(stderr, \"finish_state:\\n\"));\n\n\tif (is_final) {\n\t\tif (used_out)\n\t\t\tgoto write_state;  \n\t\telse if (used_in < 8) {\n\t\t\t \n\t\t\trc = -1;\n\t\t\tgoto err4;\n\t\t} else {\n\t\t\t \n\t\t\tint i;\n\t\t\tunsigned char tail[8];\n\t\t\tuint32_t cksum, isize;\n\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\ttail[i] = fifo_in[(cur_in + i) % fifo_in_len];\n\t\t\tfprintf(stderr, \"computed checksum %08x isize %08x\\n\",\n\t\t\t\tcmdp->cpb.out_crc, (uint32_t) (total_out\n\t\t\t\t% (1ULL<<32)));\n\t\t\tcksum = ((uint32_t) tail[0] | (uint32_t) tail[1]<<8\n\t\t\t\t | (uint32_t) tail[2]<<16\n\t\t\t\t | (uint32_t) tail[3]<<24);\n\t\t\tisize = ((uint32_t) tail[4] | (uint32_t) tail[5]<<8\n\t\t\t\t | (uint32_t) tail[6]<<16\n\t\t\t\t | (uint32_t) tail[7]<<24);\n\t\t\tfprintf(stderr, \"stored   checksum %08x isize %08x\\n\",\n\t\t\t\tcksum, isize);\n\n\t\t\tif (cksum == cmdp->cpb.out_crc && isize == (uint32_t)\n\t\t\t    (total_out % (1ULL<<32))) {\n\t\t\t\trc = 0;\tgoto ok1;\n\t\t\t} else {\n\t\t\t\trc = -1; goto err4;\n\t\t\t}\n\t\t}\n\t} else\n\t\tgoto read_state;\n\n\treturn -1;\n\nerr1:\n\tfprintf(stderr, \"error: not a gzip file, expect %x, read %x\\n\",\n\t\texpect, c);\n\treturn -1;\n\nerr2:\n\tfprintf(stderr, \"error: the FLG byte is wrong or not being handled\\n\");\n\treturn -1;\n\nerr3:\n\tfprintf(stderr, \"error: gzip header\\n\");\n\treturn -1;\n\nerr4:\n\tfprintf(stderr, \"error: checksum missing or mismatch\\n\");\n\nerr5:\nok1:\n\tfprintf(stderr, \"decomp is complete: fclose\\n\");\n\tfclose(outf);\n\n\treturn rc;\n}\n\n\nint main(int argc, char **argv)\n{\n\tint rc;\n\tstruct sigaction act;\n\tvoid *handle;\n\n\tnx_dbg = 0;\n\tnx_gzip_log = NULL;\n\tact.sa_handler = 0;\n\tact.sa_sigaction = nxu_sigsegv_handler;\n\tact.sa_flags = SA_SIGINFO;\n\tact.sa_restorer = 0;\n\tsigemptyset(&act.sa_mask);\n\tsigaction(SIGSEGV, &act, NULL);\n\n\thandle = nx_function_begin(NX_FUNC_COMP_GZIP, 0);\n\tif (!handle) {\n\t\tfprintf(stderr, \"Unable to init NX, errno %d\\n\", errno);\n\t\texit(-1);\n\t}\n\n\trc = decompress_file(argc, argv, handle);\n\n\tnx_function_end(handle);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}