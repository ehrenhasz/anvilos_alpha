{
  "module_name": "hashchk_test.c",
  "hash_id": "ae84f016c1c1c3677c55420657d0690b1894c74cc239df015ef4e38b9fe86d91",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/dexcr/hashchk_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n\n#include \"dexcr.h\"\n#include \"utils.h\"\n\nstatic int require_nphie(void)\n{\n\tSKIP_IF_MSG(!dexcr_exists(), \"DEXCR not supported\");\n\tSKIP_IF_MSG(!(get_dexcr(EFFECTIVE) & DEXCR_PR_NPHIE),\n\t\t    \"DEXCR[NPHIE] not enabled\");\n\n\treturn 0;\n}\n\nstatic jmp_buf hashchk_detected_buf;\nstatic const char *hashchk_failure_msg;\n\nstatic void hashchk_handler(int signum, siginfo_t *info, void *context)\n{\n\tif (signum != SIGILL)\n\t\thashchk_failure_msg = \"wrong signal received\";\n\telse if (info->si_code != ILL_ILLOPN)\n\t\thashchk_failure_msg = \"wrong signal code received\";\n\n\tlongjmp(hashchk_detected_buf, 0);\n}\n\n \nstatic int hashchk_detected_test(void)\n{\n\tstruct sigaction old;\n\tint err;\n\n\terr = require_nphie();\n\tif (err)\n\t\treturn err;\n\n\told = push_signal_handler(SIGILL, hashchk_handler);\n\tif (setjmp(hashchk_detected_buf))\n\t\tgoto out;\n\n\thashchk_failure_msg = NULL;\n\tdo_bad_hashchk();\n\thashchk_failure_msg = \"hashchk failed to trigger\";\n\nout:\n\tpop_signal_handler(SIGILL, old);\n\tFAIL_IF_MSG(hashchk_failure_msg, hashchk_failure_msg);\n\treturn 0;\n}\n\n#define HASH_COUNT 8\n\nstatic unsigned long hash_values[HASH_COUNT + 1];\n\nstatic void fill_hash_values(void)\n{\n\tfor (unsigned long i = 0; i < HASH_COUNT; i++)\n\t\thashst(i, &hash_values[i]);\n\n\t \n\thash_values[HASH_COUNT] = (unsigned long)&hash_values;\n}\n\nstatic unsigned int count_hash_values_matches(void)\n{\n\tunsigned long matches = 0;\n\n\tfor (unsigned long i = 0; i < HASH_COUNT; i++) {\n\t\tunsigned long orig_hash = hash_values[i];\n\t\thash_values[i] = 0;\n\n\t\thashst(i, &hash_values[i]);\n\n\t\tif (hash_values[i] == orig_hash)\n\t\t\tmatches++;\n\t}\n\n\treturn matches;\n}\n\nstatic int hashchk_exec_child(void)\n{\n\tssize_t count;\n\n\tfill_hash_values();\n\n\tcount = write(STDOUT_FILENO, hash_values, sizeof(hash_values));\n\treturn count == sizeof(hash_values) ? 0 : EOVERFLOW;\n}\n\nstatic char *hashchk_exec_child_args[] = { \"hashchk_exec_child\", NULL };\n\n \nstatic int hashchk_exec_random_key_test(void)\n{\n\tpid_t pid;\n\tint err;\n\tint pipefd[2];\n\n\terr = require_nphie();\n\tif (err)\n\t\treturn err;\n\n\tFAIL_IF_MSG(pipe(pipefd), \"failed to create pipe\");\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (dup2(pipefd[1], STDOUT_FILENO) == -1)\n\t\t\t_exit(errno);\n\n\t\texecve(\"/proc/self/exe\", hashchk_exec_child_args, NULL);\n\t\t_exit(errno);\n\t}\n\n\tawait_child_success(pid);\n\tFAIL_IF_MSG(read(pipefd[0], hash_values, sizeof(hash_values)) != sizeof(hash_values),\n\t\t    \"missing expected child output\");\n\n\t \n\tFAIL_IF_EXIT_MSG(hash_values[HASH_COUNT] != (unsigned long)&hash_values,\n\t\t\t \"bad address check\");\n\n\t \n\tFAIL_IF_MSG(count_hash_values_matches() == HASH_COUNT, \"shared key detected\");\n\n\treturn 0;\n}\n\n \nstatic int hashchk_fork_share_key_test(void)\n{\n\tpid_t pid;\n\tint err;\n\n\terr = require_nphie();\n\tif (err)\n\t\treturn err;\n\n\tfill_hash_values();\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (count_hash_values_matches() != HASH_COUNT)\n\t\t\t_exit(1);\n\t\t_exit(0);\n\t}\n\n\tawait_child_success(pid);\n\treturn 0;\n}\n\n#define STACK_SIZE (1024 * 1024)\n\nstatic int hashchk_clone_child_fn(void *args)\n{\n\tfill_hash_values();\n\treturn 0;\n}\n\n \nstatic int hashchk_clone_share_key_test(void)\n{\n\tvoid *child_stack;\n\tpid_t pid;\n\tint err;\n\n\terr = require_nphie();\n\tif (err)\n\t\treturn err;\n\n\tchild_stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\n\tFAIL_IF_MSG(child_stack == MAP_FAILED, \"failed to map child stack\");\n\n\tpid = clone(hashchk_clone_child_fn, child_stack + STACK_SIZE,\n\t\t    CLONE_VM | SIGCHLD, NULL);\n\n\tawait_child_success(pid);\n\tFAIL_IF_MSG(count_hash_values_matches() != HASH_COUNT,\n\t\t    \"different key detected\");\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err = 0;\n\n\tif (argc >= 1 && !strcmp(argv[0], hashchk_exec_child_args[0]))\n\t\treturn hashchk_exec_child();\n\n\terr |= test_harness(hashchk_detected_test, \"hashchk_detected\");\n\terr |= test_harness(hashchk_exec_random_key_test, \"hashchk_exec_random_key\");\n\terr |= test_harness(hashchk_fork_share_key_test, \"hashchk_fork_share_key\");\n\terr |= test_harness(hashchk_clone_share_key_test, \"hashchk_clone_share_key\");\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}