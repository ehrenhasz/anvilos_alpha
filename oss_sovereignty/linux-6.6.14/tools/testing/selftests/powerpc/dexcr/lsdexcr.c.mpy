{
  "module_name": "lsdexcr.c",
  "hash_id": "5405fc65f4504bdea91c688d8b3d19e325801bc296f3f56f647daac7b5547651",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/dexcr/lsdexcr.c",
  "human_readable_source": "\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"dexcr.h\"\n#include \"utils.h\"\n\nstatic unsigned int dexcr;\nstatic unsigned int hdexcr;\nstatic unsigned int effective;\n\nstruct dexcr_aspect {\n\tconst char *name;\n\tconst char *desc;\n\tunsigned int index;\n};\n\nstatic const struct dexcr_aspect aspects[] = {\n\t{\n\t\t.name = \"SBHE\",\n\t\t.desc = \"Speculative branch hint enable\",\n\t\t.index = 0,\n\t},\n\t{\n\t\t.name = \"IBRTPD\",\n\t\t.desc = \"Indirect branch recurrent target prediction disable\",\n\t\t.index = 3,\n\t},\n\t{\n\t\t.name = \"SRAPD\",\n\t\t.desc = \"Subroutine return address prediction disable\",\n\t\t.index = 4,\n\t},\n\t{\n\t\t.name = \"NPHIE\",\n\t\t.desc = \"Non-privileged hash instruction enable\",\n\t\t.index = 5,\n\t},\n\t{\n\t\t.name = \"PHIE\",\n\t\t.desc = \"Privileged hash instruction enable\",\n\t\t.index = 6,\n\t},\n};\n\nstatic void print_list(const char *list[], size_t len)\n{\n\tfor (size_t i = 0; i < len; i++) {\n\t\tprintf(\"%s\", list[i]);\n\t\tif (i + 1 < len)\n\t\t\tprintf(\", \");\n\t}\n}\n\nstatic void print_dexcr(char *name, unsigned int bits)\n{\n\tconst char *enabled_aspects[ARRAY_SIZE(aspects) + 1] = {NULL};\n\tsize_t j = 0;\n\n\tprintf(\"%s: %08x\", name, bits);\n\n\tif (bits == 0) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(aspects); i++) {\n\t\tunsigned int mask = DEXCR_PR_BIT(aspects[i].index);\n\n\t\tif (bits & mask) {\n\t\t\tenabled_aspects[j++] = aspects[i].name;\n\t\t\tbits &= ~mask;\n\t\t}\n\t}\n\n\tif (bits)\n\t\tenabled_aspects[j++] = \"unknown\";\n\n\tprintf(\" (\");\n\tprint_list(enabled_aspects, j);\n\tprintf(\")\\n\");\n}\n\nstatic void print_aspect(const struct dexcr_aspect *aspect)\n{\n\tconst char *attributes[8] = {NULL};\n\tsize_t j = 0;\n\tunsigned long mask;\n\n\tmask = DEXCR_PR_BIT(aspect->index);\n\tif (dexcr & mask)\n\t\tattributes[j++] = \"set\";\n\tif (hdexcr & mask)\n\t\tattributes[j++] = \"set (hypervisor)\";\n\tif (!(effective & mask))\n\t\tattributes[j++] = \"clear\";\n\n\tprintf(\"%12s %c (%d): \", aspect->name, effective & mask ? '*' : ' ', aspect->index);\n\tprint_list(attributes, j);\n\tprintf(\"  \\t(%s)\\n\", aspect->desc);\n}\n\nint main(int argc, char *argv[])\n{\n\tif (!dexcr_exists()) {\n\t\tprintf(\"DEXCR not detected on this hardware\\n\");\n\t\treturn 1;\n\t}\n\n\tdexcr = get_dexcr(DEXCR);\n\thdexcr = get_dexcr(HDEXCR);\n\teffective = dexcr | hdexcr;\n\n\tprint_dexcr(\"    DEXCR\", dexcr);\n\tprint_dexcr(\"   HDEXCR\", hdexcr);\n\tprint_dexcr(\"Effective\", effective);\n\tprintf(\"\\n\");\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(aspects); i++)\n\t\tprint_aspect(&aspects[i]);\n\tprintf(\"\\n\");\n\n\tif (effective & DEXCR_PR_NPHIE) {\n\t\tprintf(\"DEXCR[NPHIE] enabled: hashst/hashchk \");\n\t\tif (hashchk_triggers())\n\t\t\tprintf(\"working\\n\");\n\t\telse\n\t\t\tprintf(\"failed to trigger\\n\");\n\t} else {\n\t\tprintf(\"DEXCR[NPHIE] disabled: hashst/hashchk \");\n\t\tif (hashchk_triggers())\n\t\t\tprintf(\"unexpectedly triggered\\n\");\n\t\telse\n\t\t\tprintf(\"ignored\\n\");\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}