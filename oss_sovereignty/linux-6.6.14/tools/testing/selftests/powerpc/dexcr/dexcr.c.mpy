{
  "module_name": "dexcr.c",
  "hash_id": "8e80d03d2cdd0f43027cc7ff9161250fa7075ce8f80b7d9a79db5194eef1fcb5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/dexcr/dexcr.c",
  "human_readable_source": "\n\n#include <errno.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include \"dexcr.h\"\n#include \"reg.h\"\n#include \"utils.h\"\n\nstatic jmp_buf generic_signal_jump_buf;\n\nstatic void generic_signal_handler(int signum, siginfo_t *info, void *context)\n{\n\tlongjmp(generic_signal_jump_buf, 0);\n}\n\nbool dexcr_exists(void)\n{\n\tstruct sigaction old;\n\tvolatile bool exists;\n\n\told = push_signal_handler(SIGILL, generic_signal_handler);\n\tif (setjmp(generic_signal_jump_buf))\n\t\tgoto out;\n\n\t \n\texists = false;\n\tmfspr(SPRN_DEXCR_RO);\n\texists = true;\n\nout:\n\tpop_signal_handler(SIGILL, old);\n\treturn exists;\n}\n\n \nbool hashchk_triggers(void)\n{\n\tstruct sigaction old;\n\tvolatile bool triggers;\n\n\told = push_signal_handler(SIGILL, generic_signal_handler);\n\tif (setjmp(generic_signal_jump_buf))\n\t\tgoto out;\n\n\ttriggers = true;\n\tdo_bad_hashchk();\n\ttriggers = false;\n\nout:\n\tpop_signal_handler(SIGILL, old);\n\treturn triggers;\n}\n\nunsigned int get_dexcr(enum dexcr_source source)\n{\n\tswitch (source) {\n\tcase DEXCR:\n\t\treturn mfspr(SPRN_DEXCR_RO);\n\tcase HDEXCR:\n\t\treturn mfspr(SPRN_HDEXCR_RO);\n\tcase EFFECTIVE:\n\t\treturn mfspr(SPRN_DEXCR_RO) | mfspr(SPRN_HDEXCR_RO);\n\tdefault:\n\t\tFAIL_IF_EXIT_MSG(true, \"bad enum dexcr_source\");\n\t}\n}\n\nvoid await_child_success(pid_t pid)\n{\n\tint wstatus;\n\n\tFAIL_IF_EXIT_MSG(pid == -1, \"fork failed\");\n\tFAIL_IF_EXIT_MSG(waitpid(pid, &wstatus, 0) == -1, \"wait failed\");\n\tFAIL_IF_EXIT_MSG(!WIFEXITED(wstatus), \"child did not exit cleanly\");\n\tFAIL_IF_EXIT_MSG(WEXITSTATUS(wstatus) != 0, \"child exit error\");\n}\n\n \nvoid hashst(unsigned long lr, void *sp)\n{\n\tasm volatile (\"addi 31, %0, 0;\"\t\t \n\t\t      \"addi 30, %1, 8;\"\t\t \n\t\t      PPC_RAW_HASHST(31, -8, 30)\t \n\t\t      : : \"r\" (lr), \"r\" (sp) : \"r31\", \"r30\", \"memory\");\n}\n\n \nvoid hashchk(unsigned long lr, void *sp)\n{\n\tasm volatile (\"addi 31, %0, 0;\"\t\t \n\t\t      \"addi 30, %1, 8;\"\t\t \n\t\t      PPC_RAW_HASHCHK(31, -8, 30)\t \n\t\t      : : \"r\" (lr), \"r\" (sp) : \"r31\", \"r30\", \"memory\");\n}\n\nvoid do_bad_hashchk(void)\n{\n\tunsigned long hash = 0;\n\n\thashst(0, &hash);\n\thash += 1;\n\thashchk(0, &hash);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}