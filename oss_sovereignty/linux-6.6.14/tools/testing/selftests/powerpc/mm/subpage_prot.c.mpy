{
  "module_name": "subpage_prot.c",
  "hash_id": "df2b5b7a985d47629094c329adac7dac1862618f4ed2621a58c4aa81e9aedaa8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/subpage_prot.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/ptrace.h>\n#include <sys/syscall.h>\n#include <ucontext.h>\n#include <unistd.h>\n\n#include \"utils.h\"\n\nchar *file_name;\n\nint in_test;\nvolatile int faulted;\nvolatile void *dar;\nint errors;\n\nstatic void segv(int signum, siginfo_t *info, void *ctxt_v)\n{\n\tucontext_t *ctxt = (ucontext_t *)ctxt_v;\n\tstruct pt_regs *regs = ctxt->uc_mcontext.regs;\n\n\tif (!in_test) {\n\t\tfprintf(stderr, \"Segfault outside of test !\\n\");\n\t\texit(1);\n\t}\n\n\tfaulted = 1;\n\tdar = (void *)regs->dar;\n\tregs->nip += 4;\n}\n\nstatic inline void do_read(const volatile void *addr)\n{\n\tint ret;\n\n\tasm volatile(\"lwz %0,0(%1); twi 0,%0,0; isync;\\n\"\n\t\t     : \"=r\" (ret) : \"r\" (addr) : \"memory\");\n}\n\nstatic inline void do_write(const volatile void *addr)\n{\n\tint val = 0x1234567;\n\n\tasm volatile(\"stw %0,0(%1); sync; \\n\"\n\t\t     : : \"r\" (val), \"r\" (addr) : \"memory\");\n}\n\nstatic inline void check_faulted(void *addr, long page, long subpage, int write)\n{\n\tint want_fault = (subpage == ((page + 3) % 16));\n\n\tif (write)\n\t\twant_fault |= (subpage == ((page + 1) % 16));\n\n\tif (faulted != want_fault) {\n\t\tprintf(\"Failed at %p (p=%ld,sp=%ld,w=%d), want=%s, got=%s !\\n\",\n\t\t       addr, page, subpage, write,\n\t\t       want_fault ? \"fault\" : \"pass\",\n\t\t       faulted ? \"fault\" : \"pass\");\n\t\t++errors;\n\t}\n\n\tif (faulted) {\n\t\tif (dar != addr) {\n\t\t\tprintf(\"Fault expected at %p and happened at %p !\\n\",\n\t\t\t       addr, dar);\n\t\t}\n\t\tfaulted = 0;\n\t\tasm volatile(\"sync\" : : : \"memory\");\n\t}\n}\n\nstatic int run_test(void *addr, unsigned long size)\n{\n\tunsigned int *map;\n\tlong i, j, pages, err;\n\n\tpages = size / 0x10000;\n\tmap = malloc(pages * 4);\n\tassert(map);\n\n\t \n\tfor (i = 0; i < pages; i++) {\n\t\tmap[i] = (0x40000000 >> (((i + 1) * 2) % 32)) |\n\t\t\t(0xc0000000 >> (((i + 3) * 2) % 32));\n\t}\n\n\terr = syscall(__NR_subpage_prot, addr, size, map);\n\tif (err) {\n\t\tperror(\"subpage_perm\");\n\t\treturn 1;\n\t}\n\tfree(map);\n\n\tin_test = 1;\n\terrors = 0;\n\tfor (i = 0; i < pages; i++) {\n\t\tfor (j = 0; j < 16; j++, addr += 0x1000) {\n\t\t\tdo_read(addr);\n\t\t\tcheck_faulted(addr, i, j, 0);\n\t\t\tdo_write(addr);\n\t\t\tcheck_faulted(addr, i, j, 1);\n\t\t}\n\t}\n\n\tin_test = 0;\n\tif (errors) {\n\t\tprintf(\"%d errors detected\\n\", errors);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int syscall_available(void)\n{\n\tint rc;\n\n\terrno = 0;\n\trc = syscall(__NR_subpage_prot, 0, 0, 0);\n\n\treturn rc == 0 || (errno != ENOENT && errno != ENOSYS);\n}\n\nint test_anon(void)\n{\n\tunsigned long align;\n\tstruct sigaction act = {\n\t\t.sa_sigaction = segv,\n\t\t.sa_flags = SA_SIGINFO\n\t};\n\tvoid *mallocblock;\n\tunsigned long mallocsize;\n\n\tSKIP_IF(!syscall_available());\n\n\tif (getpagesize() != 0x10000) {\n\t\tfprintf(stderr, \"Kernel page size must be 64K!\\n\");\n\t\treturn 1;\n\t}\n\n\tsigaction(SIGSEGV, &act, NULL);\n\n\tmallocsize = 4 * 16 * 1024 * 1024;\n\n\tFAIL_IF(posix_memalign(&mallocblock, 64 * 1024, mallocsize));\n\n\talign = (unsigned long)mallocblock;\n\tif (align & 0xffff)\n\t\talign = (align | 0xffff) + 1;\n\n\tmallocblock = (void *)align;\n\n\tprintf(\"allocated malloc block of 0x%lx bytes at %p\\n\",\n\t       mallocsize, mallocblock);\n\n\tprintf(\"testing malloc block...\\n\");\n\n\treturn run_test(mallocblock, mallocsize);\n}\n\nint test_file(void)\n{\n\tstruct sigaction act = {\n\t\t.sa_sigaction = segv,\n\t\t.sa_flags = SA_SIGINFO\n\t};\n\tvoid *fileblock;\n\toff_t filesize;\n\tint fd;\n\n\tSKIP_IF(!syscall_available());\n\n\tfd = open(file_name, O_RDWR);\n\tif (fd == -1) {\n\t\tperror(\"failed to open file\");\n\t\treturn 1;\n\t}\n\tsigaction(SIGSEGV, &act, NULL);\n\n\tfilesize = lseek(fd, 0, SEEK_END);\n\tif (filesize & 0xffff)\n\t\tfilesize &= ~0xfffful;\n\n\tfileblock = mmap(NULL, filesize, PROT_READ | PROT_WRITE,\n\t\t\t MAP_SHARED, fd, 0);\n\tif (fileblock == MAP_FAILED) {\n\t\tperror(\"failed to map file\");\n\t\treturn 1;\n\t}\n\tprintf(\"allocated %s for 0x%lx bytes at %p\\n\",\n\t       file_name, filesize, fileblock);\n\n\tprintf(\"testing file map...\\n\");\n\n\treturn run_test(fileblock, filesize);\n}\n\nint main(int argc, char *argv[])\n{\n\tint rc;\n\n\trc = test_harness(test_anon, \"subpage_prot_anon\");\n\tif (rc)\n\t\treturn rc;\n\n\tif (argc > 1)\n\t\tfile_name = argv[1];\n\telse\n\t\tfile_name = \"tempfile\";\n\n\treturn test_harness(test_file, \"subpage_prot_file\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}