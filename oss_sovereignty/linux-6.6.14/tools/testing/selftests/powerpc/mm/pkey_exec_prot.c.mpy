{
  "module_name": "pkey_exec_prot.c",
  "hash_id": "0e4aed969e397dbd378fc13947ba04cbd1f6af623b954178bb6ec5905820acb1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/pkey_exec_prot.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n\n#include <unistd.h>\n\n#include \"pkeys.h\"\n\n#define PPC_INST_NOP\t0x60000000\n#define PPC_INST_TRAP\t0x7fe00008\n#define PPC_INST_BLR\t0x4e800020\n\nstatic volatile sig_atomic_t fault_pkey, fault_code, fault_type;\nstatic volatile sig_atomic_t remaining_faults;\nstatic volatile unsigned int *fault_addr;\nstatic unsigned long pgsize, numinsns;\nstatic unsigned int *insns;\n\nstatic void trap_handler(int signum, siginfo_t *sinfo, void *ctx)\n{\n\t \n\tif (sinfo->si_addr != (void *) fault_addr)\n\t\tsigsafe_err(\"got a fault for an unexpected address\\n\");\n\n\t_exit(1);\n}\n\nstatic void segv_handler(int signum, siginfo_t *sinfo, void *ctx)\n{\n\tint signal_pkey;\n\n\tsignal_pkey = siginfo_pkey(sinfo);\n\tfault_code = sinfo->si_code;\n\n\t \n\tif (sinfo->si_addr != (void *) fault_addr) {\n\t\tsigsafe_err(\"got a fault for an unexpected address\\n\");\n\t\t_exit(1);\n\t}\n\n\t \n\tif (!remaining_faults) {\n\t\tsigsafe_err(\"got too many faults for the same address\\n\");\n\t\t_exit(1);\n\t}\n\n\n\t \n\tswitch (fault_code) {\n\tcase SEGV_ACCERR:\n\t\tif (mprotect(insns, pgsize, PROT_READ | PROT_WRITE)) {\n\t\t\tsigsafe_err(\"failed to set access permissions\\n\");\n\t\t\t_exit(1);\n\t\t}\n\t\tbreak;\n\tcase SEGV_PKUERR:\n\t\tif (signal_pkey != fault_pkey) {\n\t\t\tsigsafe_err(\"got a fault for an unexpected pkey\\n\");\n\t\t\t_exit(1);\n\t\t}\n\n\t\tswitch (fault_type) {\n\t\tcase PKEY_DISABLE_ACCESS:\n\t\t\tpkey_set_rights(fault_pkey, 0);\n\t\t\tbreak;\n\t\tcase PKEY_DISABLE_EXECUTE:\n\t\t\t \n\t\t\tif (mprotect(insns, pgsize, PROT_EXEC)) {\n\t\t\t\tsigsafe_err(\"failed to set execute permissions\\n\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsigsafe_err(\"got a fault with an unexpected type\\n\");\n\t\t\t_exit(1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsigsafe_err(\"got a fault with an unexpected code\\n\");\n\t\t_exit(1);\n\t}\n\n\tremaining_faults--;\n}\n\nstatic int test(void)\n{\n\tstruct sigaction segv_act, trap_act;\n\tunsigned long rights;\n\tint pkey, ret, i;\n\n\tret = pkeys_unsupported();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsegv_act.sa_handler = 0;\n\tsegv_act.sa_sigaction = segv_handler;\n\tFAIL_IF(sigprocmask(SIG_SETMASK, 0, &segv_act.sa_mask) != 0);\n\tsegv_act.sa_flags = SA_SIGINFO;\n\tsegv_act.sa_restorer = 0;\n\tFAIL_IF(sigaction(SIGSEGV, &segv_act, NULL) != 0);\n\n\t \n\ttrap_act.sa_handler = 0;\n\ttrap_act.sa_sigaction = trap_handler;\n\tFAIL_IF(sigprocmask(SIG_SETMASK, 0, &trap_act.sa_mask) != 0);\n\ttrap_act.sa_flags = SA_SIGINFO;\n\ttrap_act.sa_restorer = 0;\n\tFAIL_IF(sigaction(SIGTRAP, &trap_act, NULL) != 0);\n\n\t \n\tpgsize = getpagesize();\n\tnuminsns = pgsize / sizeof(unsigned int);\n\tinsns = (unsigned int *) mmap(NULL, pgsize, PROT_READ | PROT_WRITE,\n\t\t\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tFAIL_IF(insns == MAP_FAILED);\n\n\t \n\tfor (i = 1; i < numinsns - 1; i++)\n\t\tinsns[i] = PPC_INST_NOP;\n\n\t \n\tinsns[0] = PPC_INST_TRAP;\n\n\t \n\tinsns[numinsns - 1] = PPC_INST_BLR;\n\n\t \n\trights = PKEY_DISABLE_EXECUTE;\n\tpkey = sys_pkey_alloc(0, rights);\n\tFAIL_IF(pkey < 0);\n\n\t \n\tfault_addr = insns;\n\n\t \n\tfault_type = -1;\n\tfault_pkey = -1;\n\n\t \n\tremaining_faults = 0;\n\tFAIL_IF(sys_pkey_mprotect(insns, pgsize, PROT_EXEC, pkey) != 0);\n\tprintf(\"read from %p, pkey permissions are %s\\n\", fault_addr,\n\t       pkey_rights(rights));\n\ti = *fault_addr;\n\tFAIL_IF(remaining_faults != 0);\n\n\t \n\tremaining_faults = 1;\n\tFAIL_IF(sys_pkey_mprotect(insns, pgsize, PROT_EXEC, pkey) != 0);\n\tprintf(\"write to %p, pkey permissions are %s\\n\", fault_addr,\n\t       pkey_rights(rights));\n\t*fault_addr = PPC_INST_TRAP;\n\tFAIL_IF(remaining_faults != 0 || fault_code != SEGV_ACCERR);\n\n\t \n\trights |= PKEY_DISABLE_ACCESS;\n\tfault_type = PKEY_DISABLE_ACCESS;\n\tfault_pkey = pkey;\n\n\t \n\tremaining_faults = 1;\n\tFAIL_IF(sys_pkey_mprotect(insns, pgsize, PROT_EXEC, pkey) != 0);\n\tpkey_set_rights(pkey, rights);\n\tprintf(\"read from %p, pkey permissions are %s\\n\", fault_addr,\n\t       pkey_rights(rights));\n\ti = *fault_addr;\n\tFAIL_IF(remaining_faults != 0 || fault_code != SEGV_PKUERR);\n\n\t \n\tremaining_faults = 2;\n\tFAIL_IF(sys_pkey_mprotect(insns, pgsize, PROT_EXEC, pkey) != 0);\n\tpkey_set_rights(pkey, rights);\n\tprintf(\"write to %p, pkey permissions are %s\\n\", fault_addr,\n\t       pkey_rights(rights));\n\t*fault_addr = PPC_INST_NOP;\n\tFAIL_IF(remaining_faults != 0 || fault_code != SEGV_ACCERR);\n\n\t \n\tsys_pkey_free(pkey);\n\n\trights = 0;\n\tdo {\n\t\t \n\t\tpkey = sys_pkey_alloc(0, rights);\n\t\tFAIL_IF(pkey < 0);\n\n\t\t \n\t\tfault_pkey = pkey;\n\t\tfault_type = -1;\n\t\tremaining_faults = 0;\n\t\tif (rights & PKEY_DISABLE_EXECUTE) {\n\t\t\tfault_type = PKEY_DISABLE_EXECUTE;\n\t\t\tremaining_faults = 1;\n\t\t}\n\n\t\tFAIL_IF(sys_pkey_mprotect(insns, pgsize, PROT_EXEC, pkey) != 0);\n\t\tprintf(\"execute at %p, pkey permissions are %s\\n\", fault_addr,\n\t\t       pkey_rights(rights));\n\t\tasm volatile(\"mtctr\t%0; bctrl\" : : \"r\"(insns));\n\t\tFAIL_IF(remaining_faults != 0);\n\t\tif (rights & PKEY_DISABLE_EXECUTE)\n\t\t\tFAIL_IF(fault_code != SEGV_PKUERR);\n\n\t\t \n\t\tsys_pkey_free(pkey);\n\n\t\t \n\t\trights = next_pkey_rights(rights);\n\t} while (rights);\n\n\t \n\tmunmap((void *) insns, pgsize);\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test, \"pkey_exec_prot\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}