{
  "module_name": "large_vm_gpr_corruption.c",
  "hash_id": "ed06671ac4350d0d4a5e4f5b117cd268bc0bfc58645f048757dea6ee03f75e0b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/large_vm_gpr_corruption.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"utils.h\"\n\n#ifndef MAP_FIXED_NOREPLACE\n#define MAP_FIXED_NOREPLACE MAP_FIXED \n#endif\n\n#define BASE_ADDRESS (1ul << 50) \n#define STRIDE\t     (2ul << 40) \n#define SLB_SIZE     32\n#define NR_MAPPINGS  (SLB_SIZE * 2)\n\nstatic volatile sig_atomic_t signaled;\n\nstatic void signal_handler(int sig)\n{\n\tsignaled = 1;\n}\n\n#define CHECK_REG(_reg)                                                                \\\n\tif (_reg != _reg##_orig) {                                                     \\\n\t\tprintf(str(_reg) \" corrupted! Expected 0x%lx != 0x%lx\\n\", _reg##_orig, \\\n\t\t       _reg);                                                          \\\n\t\t_exit(1);                                                              \\\n\t}\n\nstatic int touch_mappings(void)\n{\n\tunsigned long r9_orig, r10_orig, r11_orig, r12_orig, r13_orig;\n\tunsigned long r9, r10, r11, r12, r13;\n\tunsigned long addr, *p;\n\tint i;\n\n\tfor (i = 0; i < NR_MAPPINGS; i++) {\n\t\taddr = BASE_ADDRESS + (i * STRIDE);\n\t\tp = (unsigned long *)addr;\n\n\t\tasm volatile(\"mr   %0, %%r9\t;\" \n\t\t\t     \"mr   %1, %%r10\t;\"\n\t\t\t     \"mr   %2, %%r11\t;\"\n\t\t\t     \"mr   %3, %%r12\t;\"\n\t\t\t     \"mr   %4, %%r13\t;\"\n\t\t\t     \"std %10, 0(%11)   ;\" \n\t\t\t     \"mr   %5, %%r9\t;\" \n\t\t\t     \"mr   %6, %%r10\t;\"\n\t\t\t     \"mr   %7, %%r11\t;\"\n\t\t\t     \"mr   %8, %%r12\t;\"\n\t\t\t     \"mr   %9, %%r13\t;\"\n\t\t\t     \"mr   %%r9,  %0\t;\" \n\t\t\t     \"mr   %%r10, %1\t;\"\n\t\t\t     \"mr   %%r11, %2\t;\"\n\t\t\t     \"mr   %%r12, %3\t;\"\n\t\t\t     \"mr   %%r13, %4\t;\"\n\t\t\t     : \"=&b\"(r9_orig), \"=&b\"(r10_orig), \"=&b\"(r11_orig),\n\t\t\t       \"=&b\"(r12_orig), \"=&b\"(r13_orig), \"=&b\"(r9), \"=&b\"(r10),\n\t\t\t       \"=&b\"(r11), \"=&b\"(r12), \"=&b\"(r13)\n\t\t\t     : \"b\"(i), \"b\"(p)\n\t\t\t     : \"r9\", \"r10\", \"r11\", \"r12\", \"r13\");\n\n\t\tCHECK_REG(r9);\n\t\tCHECK_REG(r10);\n\t\tCHECK_REG(r11);\n\t\tCHECK_REG(r12);\n\t\tCHECK_REG(r13);\n\t}\n\n\treturn 0;\n}\n\nstatic int test(void)\n{\n\tunsigned long page_size, addr, *p;\n\tstruct sigaction action;\n\tbool hash_mmu;\n\tint i, status;\n\tpid_t pid;\n\n\t\n\tFAIL_IF(using_hash_mmu(&hash_mmu));\n\tSKIP_IF(!hash_mmu);\n\t\n\tSKIP_IF(sysconf(_SC_PAGESIZE) < 65536);\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\tfor (i = 0; i < NR_MAPPINGS; i++) {\n\t\taddr = BASE_ADDRESS + (i * STRIDE);\n\n\t\tp = mmap((void *)addr, page_size, PROT_READ | PROT_WRITE,\n\t\t\t MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE, -1, 0);\n\t\tif (p == MAP_FAILED) {\n\t\t\tperror(\"mmap\");\n\t\t\tprintf(\"Error: couldn't mmap(), confirm kernel has 4PB support?\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\taction.sa_handler = signal_handler;\n\taction.sa_flags = SA_RESTART;\n\tFAIL_IF(sigaction(SIGALRM, &action, NULL) < 0);\n\n\t\n\talarm(30);\n\n\twhile (!signaled) {\n\t\t\n\t\t\n\t\tpid = fork();\n\t\tif (pid == 0)\n\t\t\texit(touch_mappings());\n\n\t\tFAIL_IF(waitpid(-1, &status, 0) == -1);\n\t\tFAIL_IF(WIFSIGNALED(status));\n\t\tFAIL_IF(!WIFEXITED(status));\n\t\tFAIL_IF(WEXITSTATUS(status));\n\t}\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test, \"large_vm_gpr_corruption\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}