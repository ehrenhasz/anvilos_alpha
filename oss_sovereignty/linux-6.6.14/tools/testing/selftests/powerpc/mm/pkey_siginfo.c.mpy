{
  "module_name": "pkey_siginfo.c",
  "hash_id": "8252e57f291f56a7c7487f356171d25024c752315dd5d3a4a63dca92f645239a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/pkey_siginfo.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/mman.h>\n\n#include \"pkeys.h\"\n\n#define PPC_INST_NOP\t0x60000000\n#define PPC_INST_BLR\t0x4e800020\n#define PROT_RWX\t(PROT_READ | PROT_WRITE | PROT_EXEC)\n\n#define NUM_ITERATIONS\t1000000\n\nstatic volatile sig_atomic_t perm_pkey, rest_pkey;\nstatic volatile sig_atomic_t rights, fault_count;\nstatic volatile unsigned int *volatile fault_addr;\nstatic pthread_barrier_t iteration_barrier;\n\nstatic void segv_handler(int signum, siginfo_t *sinfo, void *ctx)\n{\n\tvoid *pgstart;\n\tsize_t pgsize;\n\tint pkey;\n\n\tpkey = siginfo_pkey(sinfo);\n\n\t \n\tif (sinfo->si_code != SEGV_PKUERR) {\n\t\tsigsafe_err(\"got a fault for an unexpected reason\\n\");\n\t\t_exit(1);\n\t}\n\n\t \n\tif (sinfo->si_addr != (void *) fault_addr) {\n\t\tsigsafe_err(\"got a fault for an unexpected address\\n\");\n\t\t_exit(1);\n\t}\n\n\t \n\tif (pkey != rest_pkey) {\n\t\tsigsafe_err(\"got a fault for an unexpected pkey\\n\");\n\t\t_exit(1);\n\t}\n\n\t \n\tif (fault_count > 0) {\n\t\tsigsafe_err(\"got too many faults for the same address\\n\");\n\t\t_exit(1);\n\t}\n\n\tpgsize = getpagesize();\n\tpgstart = (void *) ((unsigned long) fault_addr & ~(pgsize - 1));\n\n\t \n\tif (rights == PKEY_DISABLE_EXECUTE &&\n\t    mprotect(pgstart, pgsize, PROT_EXEC))\n\t\t_exit(1);\n\telse\n\t\tpkey_set_rights(pkey, 0);\n\n\tfault_count++;\n}\n\nstruct region {\n\tunsigned long rights;\n\tunsigned int *base;\n\tsize_t size;\n};\n\nstatic void *protect(void *p)\n{\n\tunsigned long rights;\n\tunsigned int *base;\n\tsize_t size;\n\tint tid, i;\n\n\ttid = gettid();\n\tbase = ((struct region *) p)->base;\n\tsize = ((struct region *) p)->size;\n\tFAIL_IF_EXIT(!base);\n\n\t \n\trights = 0;\n\n\tprintf(\"tid %d, pkey permissions are %s\\n\", tid, pkey_rights(rights));\n\n\t \n\tperm_pkey = sys_pkey_alloc(0, rights);\n\tFAIL_IF_EXIT(perm_pkey < 0);\n\n\t \n\tfor (i = 0; i < NUM_ITERATIONS; i++) {\n\t\t \n\t\tpthread_barrier_wait(&iteration_barrier);\n\n\t\t \n\t\tFAIL_IF_EXIT(sys_pkey_mprotect(base, size, PROT_RWX,\n\t\t\t\t\t       perm_pkey));\n\t}\n\n\t \n\tsys_pkey_free(perm_pkey);\n\n\treturn NULL;\n}\n\nstatic void *protect_access(void *p)\n{\n\tsize_t size, numinsns;\n\tunsigned int *base;\n\tint tid, i;\n\n\ttid = gettid();\n\tbase = ((struct region *) p)->base;\n\tsize = ((struct region *) p)->size;\n\trights = ((struct region *) p)->rights;\n\tnuminsns = size / sizeof(base[0]);\n\tFAIL_IF_EXIT(!base);\n\n\t \n\trest_pkey = sys_pkey_alloc(0, rights);\n\tFAIL_IF_EXIT(rest_pkey < 0);\n\n\tprintf(\"tid %d, pkey permissions are %s\\n\", tid, pkey_rights(rights));\n\tprintf(\"tid %d, %s randomly in range [%p, %p]\\n\", tid,\n\t       (rights == PKEY_DISABLE_EXECUTE) ? \"execute\" :\n\t       (rights == PKEY_DISABLE_WRITE)  ? \"write\" : \"read\",\n\t       base, base + numinsns);\n\n\t \n\tfor (i = 0; i < NUM_ITERATIONS; i++) {\n\t\t \n\t\tpthread_barrier_wait(&iteration_barrier);\n\n\t\t \n\t\tFAIL_IF_EXIT(sys_pkey_mprotect(base, size, PROT_RWX,\n\t\t\t\t\t       rest_pkey));\n\n\t\t \n\t\tfault_addr = base + (rand() % numinsns);\n\t\tfault_count = 0;\n\n\t\tswitch (rights) {\n\t\t \n\t\tcase PKEY_DISABLE_ACCESS:\n\t\t\t \n\t\t\tFAIL_IF_EXIT(*fault_addr != PPC_INST_NOP &&\n\t\t\t\t     *fault_addr != PPC_INST_BLR);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PKEY_DISABLE_WRITE:\n\t\t\t \n\t\t\t*fault_addr = PPC_INST_BLR;\n\t\t\tFAIL_IF_EXIT(*fault_addr != PPC_INST_BLR);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PKEY_DISABLE_EXECUTE:\n\t\t\t \n\t\t\tasm volatile(\n\t\t\t\t\"mtctr\t%0; bctrl\"\n\t\t\t\t: : \"r\"(fault_addr) : \"ctr\", \"lr\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpkey_set_rights(rest_pkey, rights);\n\t}\n\n\t \n\tsys_pkey_free(rest_pkey);\n\n\treturn NULL;\n}\n\nstatic void reset_pkeys(unsigned long rights)\n{\n\tint pkeys[NR_PKEYS], i;\n\n\t \n\tfor (i = 0; i < NR_PKEYS; i++)\n\t\tpkeys[i] = sys_pkey_alloc(0, rights);\n\n\t \n\tfor (i = 0; i < NR_PKEYS; i++)\n\t\tsys_pkey_free(pkeys[i]);\n}\n\nstatic int test(void)\n{\n\tpthread_t prot_thread, pacc_thread;\n\tstruct sigaction act;\n\tpthread_attr_t attr;\n\tsize_t numinsns;\n\tstruct region r;\n\tint ret, i;\n\n\tsrand(time(NULL));\n\tret = pkeys_unsupported();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tr.size = getpagesize();\n\tr.base = mmap(NULL, r.size, PROT_RWX,\n\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tFAIL_IF(r.base == MAP_FAILED);\n\n\t \n\tnuminsns = r.size / sizeof(r.base[0]);\n\tfor (i = 0; i < numinsns - 1; i++)\n\t\tr.base[i] = PPC_INST_NOP;\n\tr.base[i] = PPC_INST_BLR;\n\n\t \n\tact.sa_handler = 0;\n\tact.sa_sigaction = segv_handler;\n\tFAIL_IF(sigprocmask(SIG_SETMASK, 0, &act.sa_mask) != 0);\n\tact.sa_flags = SA_SIGINFO;\n\tact.sa_restorer = 0;\n\tFAIL_IF(sigaction(SIGSEGV, &act, NULL) != 0);\n\n\t \n\treset_pkeys(0);\n\n\t \n\tFAIL_IF(pthread_attr_init(&attr) != 0);\n\tFAIL_IF(pthread_barrier_init(&iteration_barrier, NULL, 2) != 0);\n\n\t \n\tputs(\"starting thread pair (protect, protect-and-read)\");\n\tr.rights = PKEY_DISABLE_ACCESS;\n\tFAIL_IF(pthread_create(&prot_thread, &attr, &protect, &r) != 0);\n\tFAIL_IF(pthread_create(&pacc_thread, &attr, &protect_access, &r) != 0);\n\tFAIL_IF(pthread_join(prot_thread, NULL) != 0);\n\tFAIL_IF(pthread_join(pacc_thread, NULL) != 0);\n\n\t \n\tputs(\"starting thread pair (protect, protect-and-write)\");\n\tr.rights = PKEY_DISABLE_WRITE;\n\tFAIL_IF(pthread_create(&prot_thread, &attr, &protect, &r) != 0);\n\tFAIL_IF(pthread_create(&pacc_thread, &attr, &protect_access, &r) != 0);\n\tFAIL_IF(pthread_join(prot_thread, NULL) != 0);\n\tFAIL_IF(pthread_join(pacc_thread, NULL) != 0);\n\n\t \n\tputs(\"starting thread pair (protect, protect-and-execute)\");\n\tr.rights = PKEY_DISABLE_EXECUTE;\n\tFAIL_IF(pthread_create(&prot_thread, &attr, &protect, &r) != 0);\n\tFAIL_IF(pthread_create(&pacc_thread, &attr, &protect_access, &r) != 0);\n\tFAIL_IF(pthread_join(prot_thread, NULL) != 0);\n\tFAIL_IF(pthread_join(pacc_thread, NULL) != 0);\n\n\t \n\tFAIL_IF(pthread_attr_destroy(&attr) != 0);\n\tFAIL_IF(pthread_barrier_destroy(&iteration_barrier) != 0);\n\tmunmap(r.base, r.size);\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test, \"pkey_siginfo\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}