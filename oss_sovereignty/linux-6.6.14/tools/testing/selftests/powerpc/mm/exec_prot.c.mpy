{
  "module_name": "exec_prot.c",
  "hash_id": "a987b866f6843805ecfaa14d466bede820a8dad0e75753c429ba82b1e8a3dd48",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/exec_prot.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n\n#include <unistd.h>\n#include <sys/mman.h>\n\n#include \"pkeys.h\"\n\n\n#define PPC_INST_NOP\t0x60000000\n#define PPC_INST_TRAP\t0x7fe00008\n#define PPC_INST_BLR\t0x4e800020\n\nstatic volatile sig_atomic_t fault_code;\nstatic volatile sig_atomic_t remaining_faults;\nstatic volatile unsigned int *fault_addr;\nstatic unsigned long pgsize, numinsns;\nstatic unsigned int *insns;\nstatic bool pkeys_supported;\n\nstatic bool is_fault_expected(int fault_code)\n{\n\tif (fault_code == SEGV_ACCERR)\n\t\treturn true;\n\n\t \n\tif (fault_code == SEGV_PKUERR && pkeys_supported)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void trap_handler(int signum, siginfo_t *sinfo, void *ctx)\n{\n\t \n\tif (sinfo->si_addr != (void *)fault_addr)\n\t\tsigsafe_err(\"got a fault for an unexpected address\\n\");\n\n\t_exit(1);\n}\n\nstatic void segv_handler(int signum, siginfo_t *sinfo, void *ctx)\n{\n\tfault_code = sinfo->si_code;\n\n\t \n\tif (sinfo->si_addr != (void *)fault_addr) {\n\t\tsigsafe_err(\"got a fault for an unexpected address\\n\");\n\t\t_exit(1);\n\t}\n\n\t \n\tif (!remaining_faults) {\n\t\tsigsafe_err(\"got too many faults for the same address\\n\");\n\t\t_exit(1);\n\t}\n\n\n\t \n\tif (is_fault_expected(fault_code)) {\n\t\tif (mprotect(insns, pgsize, PROT_READ | PROT_WRITE | PROT_EXEC)) {\n\t\t\tsigsafe_err(\"failed to set access permissions\\n\");\n\t\t\t_exit(1);\n\t\t}\n\t} else {\n\t\tsigsafe_err(\"got a fault with an unexpected code\\n\");\n\t\t_exit(1);\n\t}\n\n\tremaining_faults--;\n}\n\nstatic int check_exec_fault(int rights)\n{\n\t \n\tfault_code = -1;\n\tremaining_faults = 0;\n\tif (!(rights & PROT_EXEC))\n\t\tremaining_faults = 1;\n\n\tFAIL_IF(mprotect(insns, pgsize, rights) != 0);\n\tasm volatile(\"mtctr\t%0; bctrl\" : : \"r\"(insns));\n\n\tFAIL_IF(remaining_faults != 0);\n\tif (!(rights & PROT_EXEC))\n\t\tFAIL_IF(!is_fault_expected(fault_code));\n\n\treturn 0;\n}\n\nstatic int test(void)\n{\n\tstruct sigaction segv_act, trap_act;\n\tint i;\n\n\t \n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_3_00));\n\n\t \n\tpkeys_supported = pkeys_unsupported() == 0;\n\n\t \n\tsegv_act.sa_handler = 0;\n\tsegv_act.sa_sigaction = segv_handler;\n\tFAIL_IF(sigprocmask(SIG_SETMASK, 0, &segv_act.sa_mask) != 0);\n\tsegv_act.sa_flags = SA_SIGINFO;\n\tsegv_act.sa_restorer = 0;\n\tFAIL_IF(sigaction(SIGSEGV, &segv_act, NULL) != 0);\n\n\t \n\ttrap_act.sa_handler = 0;\n\ttrap_act.sa_sigaction = trap_handler;\n\tFAIL_IF(sigprocmask(SIG_SETMASK, 0, &trap_act.sa_mask) != 0);\n\ttrap_act.sa_flags = SA_SIGINFO;\n\ttrap_act.sa_restorer = 0;\n\tFAIL_IF(sigaction(SIGTRAP, &trap_act, NULL) != 0);\n\n\t \n\tpgsize = getpagesize();\n\tnuminsns = pgsize / sizeof(unsigned int);\n\tinsns = (unsigned int *)mmap(NULL, pgsize, PROT_READ | PROT_WRITE,\n\t\t\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tFAIL_IF(insns == MAP_FAILED);\n\n\t \n\tfor (i = 1; i < numinsns - 1; i++)\n\t\tinsns[i] = PPC_INST_NOP;\n\n\t \n\tinsns[0] = PPC_INST_TRAP;\n\n\t \n\tinsns[numinsns - 1] = PPC_INST_BLR;\n\n\t \n\tfault_addr = insns;\n\n\t \n\tfault_code = -1;\n\tremaining_faults = 1;\n\tprintf(\"Testing read on --x, should fault...\");\n\tFAIL_IF(mprotect(insns, pgsize, PROT_EXEC) != 0);\n\ti = *fault_addr;\n\tFAIL_IF(remaining_faults != 0 || !is_fault_expected(fault_code));\n\tprintf(\"ok!\\n\");\n\n\t \n\tfault_code = -1;\n\tremaining_faults = 1;\n\tprintf(\"Testing write on --x, should fault...\");\n\tFAIL_IF(mprotect(insns, pgsize, PROT_EXEC) != 0);\n\t*fault_addr = PPC_INST_NOP;\n\tFAIL_IF(remaining_faults != 0 || !is_fault_expected(fault_code));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on ---, should fault...\");\n\tFAIL_IF(check_exec_fault(PROT_NONE));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on r--, should fault...\");\n\tFAIL_IF(check_exec_fault(PROT_READ));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on -w-, should fault...\");\n\tFAIL_IF(check_exec_fault(PROT_WRITE));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on rw-, should fault...\");\n\tFAIL_IF(check_exec_fault(PROT_READ | PROT_WRITE));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on --x, should succeed...\");\n\tFAIL_IF(check_exec_fault(PROT_EXEC));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on r-x, should succeed...\");\n\tFAIL_IF(check_exec_fault(PROT_READ | PROT_EXEC));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on -wx, should succeed...\");\n\tFAIL_IF(check_exec_fault(PROT_WRITE | PROT_EXEC));\n\tprintf(\"ok!\\n\");\n\n\tprintf(\"Testing exec on rwx, should succeed...\");\n\tFAIL_IF(check_exec_fault(PROT_READ | PROT_WRITE | PROT_EXEC));\n\tprintf(\"ok!\\n\");\n\n\t \n\tFAIL_IF(munmap((void *)insns, pgsize));\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test, \"exec_prot\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}