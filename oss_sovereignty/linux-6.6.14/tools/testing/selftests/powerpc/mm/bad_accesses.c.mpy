{
  "module_name": "bad_accesses.c",
  "hash_id": "eda451369bc5c7d8fc4bfa7b7316e94f45ea92efb3fd77ad3053f9481c3ec100",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/bad_accesses.c",
  "human_readable_source": "\n\n\n\n\n\n#include <setjmp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"utils.h\"\n\n\n#ifndef SEGV_BNDERR\n#define SEGV_BNDERR\t3\n#endif\n\n\n#define PAGE_OFFSET\t(0xcul << 60)\n\nstatic unsigned long kernel_virt_end;\n\nstatic volatile int fault_code;\nstatic volatile unsigned long fault_addr;\nstatic jmp_buf setjmp_env;\n\nstatic void segv_handler(int n, siginfo_t *info, void *ctxt_v)\n{\n\tfault_code = info->si_code;\n\tfault_addr = (unsigned long)info->si_addr;\n\tsiglongjmp(setjmp_env, 1);\n}\n\nint bad_access(char *p, bool write)\n{\n\tchar x = 0;\n\n\tfault_code = 0;\n\tfault_addr = 0;\n\n\tif (sigsetjmp(setjmp_env, 1) == 0) {\n\t\tif (write)\n\t\t\t*p = 1;\n\t\telse\n\t\t\tx = *p;\n\n\t\tprintf(\"Bad - no SEGV! (%c)\\n\", x);\n\t\treturn 1;\n\t}\n\n\t\n\t\n\t\n\tFAIL_IF(fault_code == SEGV_MAPERR && \\\n\t\t(fault_addr < PAGE_OFFSET || fault_addr >= kernel_virt_end));\n\n\tFAIL_IF(fault_code != SEGV_MAPERR && fault_code != SEGV_BNDERR);\n\n\treturn 0;\n}\n\nstatic int test(void)\n{\n\tunsigned long i, j, addr, region_shift, page_shift, page_size;\n\tstruct sigaction sig;\n\tbool hash_mmu;\n\n\tsig = (struct sigaction) {\n\t\t.sa_sigaction = segv_handler,\n\t\t.sa_flags = SA_SIGINFO,\n\t};\n\n\tFAIL_IF(sigaction(SIGSEGV, &sig, NULL) != 0);\n\n\tFAIL_IF(using_hash_mmu(&hash_mmu));\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tif (page_size == (64 * 1024))\n\t\tpage_shift = 16;\n\telse\n\t\tpage_shift = 12;\n\n\tif (page_size == (64 * 1024) || !hash_mmu) {\n\t\tregion_shift = 52;\n\n\t\t\n\t\tkernel_virt_end = PAGE_OFFSET + (7 * (512ul << 40));\n\t} else if (page_size == (4 * 1024) && hash_mmu) {\n\t\tregion_shift = 46;\n\n\t\t\n\t\tkernel_virt_end = PAGE_OFFSET + (7 * (64ul << 40));\n\t} else\n\t\tFAIL_IF(true);\n\n\tprintf(\"Using %s MMU, PAGE_SIZE = %dKB start address 0x%016lx\\n\",\n\t       hash_mmu ? \"hash\" : \"radix\",\n\t       (1 << page_shift) >> 10,\n\t       1ul << region_shift);\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\tfor (i = 1; i <= ((0xful << 60) >> region_shift); i++) {\n\t\tfor (j = page_shift - 1; j < 60; j++) {\n\t\t\tunsigned long base, delta;\n\n\t\t\tbase  = i << region_shift;\n\t\t\tdelta = 1ul << j;\n\n\t\t\tif (delta >= base)\n\t\t\t\tbreak;\n\n\t\t\taddr = (base | delta) & ~((1 << page_shift) - 1);\n\n\t\t\tFAIL_IF(bad_access((char *)addr, false));\n\t\t\tFAIL_IF(bad_access((char *)addr, true));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main(void)\n{\n\ttest_harness_set_timeout(300);\n\treturn test_harness(test, \"bad_accesses\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}