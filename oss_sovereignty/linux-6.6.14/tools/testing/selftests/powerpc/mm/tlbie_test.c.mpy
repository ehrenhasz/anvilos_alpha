{
  "module_name": "tlbie_test.c",
  "hash_id": "1eb61816f3de892685bbaa9f7e9c873e9e8fa00acb1274fe87d1b720118fac72",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/mm/tlbie_test.c",
  "human_readable_source": "\n\n \n\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <linux/futex.h>\n#include <unistd.h>\n#include <asm/unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <time.h>\n#include <stdarg.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/prctl.h>\n\nstatic inline void dcbf(volatile unsigned int *addr)\n{\n\t__asm__ __volatile__ (\"dcbf %y0; sync\" : : \"Z\"(*(unsigned char *)addr) : \"memory\");\n}\n\nstatic void err_msg(char *msg)\n{\n\n\ttime_t now;\n\ttime(&now);\n\tprintf(\"=================================\\n\");\n\tprintf(\"    Error: %s\\n\", msg);\n\tprintf(\"    %s\", ctime(&now));\n\tprintf(\"=================================\\n\");\n\texit(1);\n}\n\nstatic char *map1;\nstatic char *map2;\nstatic pid_t rim_process_pid;\n\n \n\n \nstatic volatile unsigned int corruption_found;\n\n \n#define MAX_THREADS \t\t64\n#define THREAD_ID_BITS\t\t8\n#define THREAD_ID_MASK\t\t((1 << THREAD_ID_BITS) - 1)\nstatic unsigned int rim_thread_ids[MAX_THREADS];\nstatic pthread_t rim_threads[MAX_THREADS];\n\n\n \n#define RIM_CHUNK_SIZE  \t1024\n#define BITS_PER_BYTE \t\t8\n#define WORD_SIZE     \t\t(sizeof(unsigned int))\n#define WORD_BITS\t\t(WORD_SIZE * BITS_PER_BYTE)\n#define WORDS_PER_CHUNK\t\t(RIM_CHUNK_SIZE/WORD_SIZE)\n\nstatic inline char *compute_chunk_start_addr(unsigned int thread_id)\n{\n\tchar *chunk_start;\n\n\tchunk_start = (char *)((unsigned long)map1 +\n\t\t\t       (thread_id * RIM_CHUNK_SIZE));\n\n\treturn chunk_start;\n}\n\n \n#define WORD_OFFSET_BITS\t(__builtin_ctz(WORDS_PER_CHUNK))\n#define WORD_OFFSET_MASK\t((1 << WORD_OFFSET_BITS) - 1)\n\nstatic inline unsigned int compute_word_offset(char *start, unsigned int *addr)\n{\n\tunsigned int delta_bytes, ret;\n\tdelta_bytes = (unsigned long)addr - (unsigned long)start;\n\n\tret = delta_bytes/WORD_SIZE;\n\n\treturn ret;\n}\n\n \n#define SWEEP_ID_BITS\t\t(WORD_BITS - (THREAD_ID_BITS + WORD_OFFSET_BITS))\n#define SWEEP_ID_MASK\t\t((1 << SWEEP_ID_BITS) - 1)\n\n \n#define SWEEP_ID_SHIFT\t0\n#define WORD_OFFSET_SHIFT\t(SWEEP_ID_BITS)\n#define THREAD_ID_SHIFT\t\t(WORD_OFFSET_BITS + SWEEP_ID_BITS)\n\n \nstatic inline unsigned int compute_store_pattern(unsigned int tid,\n\t\t\t\t\t\t unsigned int *addr,\n\t\t\t\t\t\t unsigned int sweep_id)\n{\n\tunsigned int ret = 0;\n\tchar *start = compute_chunk_start_addr(tid);\n\tunsigned int word_offset = compute_word_offset(start, addr);\n\n\tret += (tid & THREAD_ID_MASK) << THREAD_ID_SHIFT;\n\tret += (word_offset & WORD_OFFSET_MASK) << WORD_OFFSET_SHIFT;\n\tret += (sweep_id & SWEEP_ID_MASK) << SWEEP_ID_SHIFT;\n\treturn ret;\n}\n\n \nstatic inline unsigned int extract_tid(unsigned int pattern)\n{\n\tunsigned int ret;\n\n\tret = (pattern >> THREAD_ID_SHIFT) & THREAD_ID_MASK;\n\treturn ret;\n}\n\n \nstatic inline unsigned int extract_word_offset(unsigned int pattern)\n{\n\tunsigned int ret;\n\n\tret = (pattern >> WORD_OFFSET_SHIFT) & WORD_OFFSET_MASK;\n\n\treturn ret;\n}\n\n \nstatic inline unsigned int extract_sweep_id(unsigned int pattern)\n\n{\n\tunsigned int ret;\n\n\tret = (pattern >> SWEEP_ID_SHIFT) & SWEEP_ID_MASK;\n\n\treturn ret;\n}\n\n \n#define LOGDIR_NAME_SIZE 100\nstatic char logdir[LOGDIR_NAME_SIZE];\n\nstatic FILE *fp[MAX_THREADS];\nstatic const char logfilename[] =\"Thread-%02d-Chunk\";\n\nstatic inline void start_verification_log(unsigned int tid,\n\t\t\t\t\t  unsigned int *addr,\n\t\t\t\t\t  unsigned int cur_sweep_id,\n\t\t\t\t\t  unsigned int prev_sweep_id)\n{\n\tFILE *f;\n\tchar logfile[30];\n\tchar path[LOGDIR_NAME_SIZE + 30];\n\tchar separator[2] = \"/\";\n\tchar *chunk_start = compute_chunk_start_addr(tid);\n\tunsigned int size = RIM_CHUNK_SIZE;\n\n\tsprintf(logfile, logfilename, tid);\n\tstrcpy(path, logdir);\n\tstrcat(path, separator);\n\tstrcat(path, logfile);\n\tf = fopen(path, \"w\");\n\n\tif (!f) {\n\t\terr_msg(\"Unable to create logfile\\n\");\n\t}\n\n\tfp[tid] = f;\n\n\tfprintf(f, \"----------------------------------------------------------\\n\");\n\tfprintf(f, \"PID                = %d\\n\", rim_process_pid);\n\tfprintf(f, \"Thread id          = %02d\\n\", tid);\n\tfprintf(f, \"Chunk Start Addr   = 0x%016lx\\n\", (unsigned long)chunk_start);\n\tfprintf(f, \"Chunk Size         = %d\\n\", size);\n\tfprintf(f, \"Next Store Addr    = 0x%016lx\\n\", (unsigned long)addr);\n\tfprintf(f, \"Current sweep-id   = 0x%08x\\n\", cur_sweep_id);\n\tfprintf(f, \"Previous sweep-id  = 0x%08x\\n\", prev_sweep_id);\n\tfprintf(f, \"----------------------------------------------------------\\n\");\n}\n\nstatic inline void log_anamoly(unsigned int tid, unsigned int *addr,\n\t\t\t       unsigned int expected, unsigned int observed)\n{\n\tFILE *f = fp[tid];\n\n\tfprintf(f, \"Thread %02d: Addr 0x%lx: Expected 0x%x, Observed 0x%x\\n\",\n\t        tid, (unsigned long)addr, expected, observed);\n\tfprintf(f, \"Thread %02d: Expected Thread id   = %02d\\n\", tid, extract_tid(expected));\n\tfprintf(f, \"Thread %02d: Observed Thread id   = %02d\\n\", tid, extract_tid(observed));\n\tfprintf(f, \"Thread %02d: Expected Word offset = %03d\\n\", tid, extract_word_offset(expected));\n\tfprintf(f, \"Thread %02d: Observed Word offset = %03d\\n\", tid, extract_word_offset(observed));\n\tfprintf(f, \"Thread %02d: Expected sweep-id    = 0x%x\\n\", tid, extract_sweep_id(expected));\n\tfprintf(f, \"Thread %02d: Observed sweep-id    = 0x%x\\n\", tid, extract_sweep_id(observed));\n\tfprintf(f, \"----------------------------------------------------------\\n\");\n}\n\nstatic inline void end_verification_log(unsigned int tid, unsigned nr_anamolies)\n{\n\tFILE *f = fp[tid];\n\tchar logfile[30];\n\tchar path[LOGDIR_NAME_SIZE + 30];\n\tchar separator[] = \"/\";\n\n\tfclose(f);\n\n\tif (nr_anamolies == 0) {\n\t\tremove(path);\n\t\treturn;\n\t}\n\n\tsprintf(logfile, logfilename, tid);\n\tstrcpy(path, logdir);\n\tstrcat(path, separator);\n\tstrcat(path, logfile);\n\n\tprintf(\"Thread %02d chunk has %d corrupted words. For details check %s\\n\",\n\t\ttid, nr_anamolies, path);\n}\n\n \nstatic void verify_chunk(unsigned int tid, unsigned int *next_store_addr,\n\t\t  unsigned int cur_sweep_id,\n\t\t  unsigned int prev_sweep_id)\n{\n\tunsigned int *iter_ptr;\n\tunsigned int size = RIM_CHUNK_SIZE;\n\tunsigned int expected;\n\tunsigned int observed;\n\tchar *chunk_start = compute_chunk_start_addr(tid);\n\n\tint nr_anamolies = 0;\n\n\tstart_verification_log(tid, next_store_addr,\n\t\t\t       cur_sweep_id, prev_sweep_id);\n\n\tfor (iter_ptr = (unsigned int *)chunk_start;\n\t     (unsigned long)iter_ptr < (unsigned long)chunk_start + size;\n\t     iter_ptr++) {\n\t\tunsigned int expected_sweep_id;\n\n\t\tif (iter_ptr < next_store_addr) {\n\t\t\texpected_sweep_id = cur_sweep_id;\n\t\t} else {\n\t\t\texpected_sweep_id = prev_sweep_id;\n\t\t}\n\n\t\texpected = compute_store_pattern(tid, iter_ptr, expected_sweep_id);\n\n\t\tdcbf((volatile unsigned int*)iter_ptr); \n\t\tobserved = *iter_ptr;\n\n\t        if (observed != expected) {\n\t\t\tnr_anamolies++;\n\t\t\tlog_anamoly(tid, iter_ptr, expected, observed);\n\t\t}\n\t}\n\n\tend_verification_log(tid, nr_anamolies);\n}\n\nstatic void set_pthread_cpu(pthread_t th, int cpu)\n{\n\tcpu_set_t run_cpu_mask;\n\tstruct sched_param param;\n\n\tCPU_ZERO(&run_cpu_mask);\n\tCPU_SET(cpu, &run_cpu_mask);\n\tpthread_setaffinity_np(th, sizeof(cpu_set_t), &run_cpu_mask);\n\n\tparam.sched_priority = 1;\n\tif (0 && sched_setscheduler(0, SCHED_FIFO, &param) == -1) {\n\t\t \n\t\tfprintf(stderr, \"could not set SCHED_FIFO, run as root?\\n\");\n\t}\n}\n\nstatic void set_mycpu(int cpu)\n{\n\tcpu_set_t run_cpu_mask;\n\tstruct sched_param param;\n\n\tCPU_ZERO(&run_cpu_mask);\n\tCPU_SET(cpu, &run_cpu_mask);\n\tsched_setaffinity(0, sizeof(cpu_set_t), &run_cpu_mask);\n\n\tparam.sched_priority = 1;\n\tif (0 && sched_setscheduler(0, SCHED_FIFO, &param) == -1) {\n\t\tfprintf(stderr, \"could not set SCHED_FIFO, run as root?\\n\");\n\t}\n}\n\nstatic volatile int segv_wait;\n\nstatic void segv_handler(int signo, siginfo_t *info, void *extra)\n{\n\twhile (segv_wait) {\n\t\tsched_yield();\n\t}\n\n}\n\nstatic void set_segv_handler(void)\n{\n\tstruct sigaction sa;\n\n\tsa.sa_flags = SA_SIGINFO;\n\tsa.sa_sigaction = segv_handler;\n\n\tif (sigaction(SIGSEGV, &sa, NULL) == -1) {\n\t\tperror(\"sigaction\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nint timeout = 0;\n \nstatic void *rim_fn(void *arg)\n{\n\tunsigned int tid = *((unsigned int *)arg);\n\n\tint size = RIM_CHUNK_SIZE;\n\tchar *chunk_start = compute_chunk_start_addr(tid);\n\n\tunsigned int prev_sweep_id;\n\tunsigned int cur_sweep_id = 0;\n\n\t \n\tunsigned int pattern = cur_sweep_id;\n\tunsigned int *pattern_ptr = &pattern;\n\tunsigned int *w_ptr, read_data;\n\n\tset_segv_handler();\n\n\t \n\tfor (w_ptr = (unsigned int *)chunk_start;\n\t     (unsigned long)w_ptr < (unsigned long)(chunk_start) + size;\n\t     w_ptr++) {\n\n\t\t*pattern_ptr = compute_store_pattern(tid, w_ptr, cur_sweep_id);\n\t\t*w_ptr = *pattern_ptr;\n\t}\n\n\twhile (!corruption_found && !timeout) {\n\t\tprev_sweep_id = cur_sweep_id;\n\t\tcur_sweep_id = cur_sweep_id + 1;\n\n\t\tfor (w_ptr = (unsigned int *)chunk_start;\n\t\t     (unsigned long)w_ptr < (unsigned long)(chunk_start) + size;\n\t\t     w_ptr++)  {\n\t\t\tunsigned int old_pattern;\n\n\t\t\t \n\t\t\told_pattern = compute_store_pattern(tid, w_ptr, prev_sweep_id);\n\n\t\t\t \n\t\t\tdcbf((volatile unsigned int*)w_ptr);  \n\n\t\t\t \n\t\t\tread_data = *w_ptr;  \n\n\t\t\t \n\t\t\tif (read_data != old_pattern) {\n\t\t\t\t \n\t\t\t\tcorruption_found = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (corruption_found || timeout) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tverify_chunk(tid, w_ptr, cur_sweep_id, prev_sweep_id);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\t*pattern_ptr = compute_store_pattern(tid, w_ptr, cur_sweep_id);\n\n\t\t\t \n\t\t\t*w_ptr = *pattern_ptr;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\nstatic unsigned long start_cpu = 0;\nstatic unsigned long nrthreads = 4;\n\nstatic pthread_t mem_snapshot_thread;\n\nstatic void *mem_snapshot_fn(void *arg)\n{\n\tint page_size = getpagesize();\n\tsize_t size = page_size;\n\tvoid *tmp = malloc(size);\n\n\twhile (!corruption_found && !timeout) {\n\t\t \n\t\tsegv_wait = 1;\n\n\t\tmprotect(map1, size, PROT_READ);\n\n\t\t \n\t\tmemcpy(tmp, map1, size);\n\n\t\t \n\t\tmemcpy(map2, tmp, size);\n\t\t \n\t\tasm volatile(\"sync\" ::: \"memory\");\n\t\tmprotect(map1, size, PROT_READ|PROT_WRITE);\n\t\tasm volatile(\"sync\" ::: \"memory\");\n\t\tsegv_wait = 0;\n\n\t\tusleep(1);  \n\t}\n\n\treturn 0;\n}\n\nvoid alrm_sighandler(int sig)\n{\n\ttimeout = 1;\n}\n\nint main(int argc, char *argv[])\n{\n\tint c;\n\tint page_size = getpagesize();\n\ttime_t now;\n\tint i, dir_error;\n\tpthread_attr_t attr;\n\tkey_t shm_key = (key_t) getpid();\n\tint shmid, run_time = 20 * 60;\n\tstruct sigaction sa_alrm;\n\n\tsnprintf(logdir, LOGDIR_NAME_SIZE,\n\t\t \"/tmp/logdir-%u\", (unsigned int)getpid());\n\twhile ((c = getopt(argc, argv, \"r:hn:l:t:\")) != -1) {\n\t\tswitch(c) {\n\t\tcase 'r':\n\t\t\tstart_cpu = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprintf(\"%s [-r <start_cpu>] [-n <nrthreads>] [-l <logdir>] [-t <timeout>]\\n\", argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnrthreads = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tstrncpy(logdir, optarg, LOGDIR_NAME_SIZE - 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\trun_time = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"invalid option\\n\");\n\t\t\texit(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nrthreads > MAX_THREADS)\n\t\tnrthreads = MAX_THREADS;\n\n\tshmid = shmget(shm_key, page_size, IPC_CREAT|0666);\n\tif (shmid < 0) {\n\t\terr_msg(\"Failed shmget\\n\");\n\t}\n\n\tmap1 = shmat(shmid, NULL, 0);\n\tif (map1 == (void *) -1) {\n\t\terr_msg(\"Failed shmat\");\n\t}\n\n\tmap2 = shmat(shmid, NULL, 0);\n\tif (map2 == (void *) -1) {\n\t\terr_msg(\"Failed shmat\");\n\t}\n\n\tdir_error = mkdir(logdir, 0755);\n\n\tif (dir_error) {\n\t\terr_msg(\"Failed mkdir\");\n\t}\n\n\tprintf(\"start_cpu list:%lu\\n\", start_cpu);\n\tprintf(\"number of worker threads:%lu + 1 snapshot thread\\n\", nrthreads);\n\tprintf(\"Allocated address:0x%016lx + secondary map:0x%016lx\\n\", (unsigned long)map1, (unsigned long)map2);\n\tprintf(\"logdir at : %s\\n\", logdir);\n\tprintf(\"Timeout: %d seconds\\n\", run_time);\n\n\ttime(&now);\n\tprintf(\"=================================\\n\");\n\tprintf(\"     Starting Test\\n\");\n\tprintf(\"     %s\", ctime(&now));\n\tprintf(\"=================================\\n\");\n\n\tfor (i = 0; i < nrthreads; i++) {\n\t\tif (1 && !fork()) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL);\n\t\t\tset_mycpu(start_cpu + i);\n\t\t\tfor (;;)\n\t\t\t\tsched_yield();\n\t\t\texit(0);\n\t\t}\n\t}\n\n\n\tsa_alrm.sa_handler = &alrm_sighandler;\n\tsigemptyset(&sa_alrm.sa_mask);\n\tsa_alrm.sa_flags = 0;\n\n\tif (sigaction(SIGALRM, &sa_alrm, 0) == -1) {\n\t\terr_msg(\"Failed signal handler registration\\n\");\n\t}\n\n\talarm(run_time);\n\n\tpthread_attr_init(&attr);\n\tfor (i = 0; i < nrthreads; i++) {\n\t\trim_thread_ids[i] = i;\n\t\tpthread_create(&rim_threads[i], &attr, rim_fn, &rim_thread_ids[i]);\n\t\tset_pthread_cpu(rim_threads[i], start_cpu + i);\n\t}\n\n\tpthread_create(&mem_snapshot_thread, &attr, mem_snapshot_fn, map1);\n\tset_pthread_cpu(mem_snapshot_thread, start_cpu + i);\n\n\n\tpthread_join(mem_snapshot_thread, NULL);\n\tfor (i = 0; i < nrthreads; i++) {\n\t\tpthread_join(rim_threads[i], NULL);\n\t}\n\n\tif (!timeout) {\n\t\ttime(&now);\n\t\tprintf(\"=================================\\n\");\n\t\tprintf(\"      Data Corruption Detected\\n\");\n\t\tprintf(\"      %s\", ctime(&now));\n\t\tprintf(\"      See logfiles in %s\\n\", logdir);\n\t\tprintf(\"=================================\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}