{
  "module_name": "tm-signal-pagefault.c",
  "hash_id": "40aa0e057fc66703dffcaee46edaa6372f0ce02788e0447bd7de2e66fb7b0d3a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/tm/tm-signal-pagefault.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/userfaultfd.h>\n#include <poll.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <pthread.h>\n#include <signal.h>\n#include <errno.h>\n\n#include \"tm.h\"\n\n\n#define UF_MEM_SIZE 655360\t \n\n \nstatic char *uf_mem;\nstatic size_t uf_mem_offset = 0;\n\n \nstatic char backing_mem[UF_MEM_SIZE];\n\nstatic size_t pagesize;\n\n \nvoid *get_uf_mem(size_t size, void *backing_data)\n{\n\tvoid *ret;\n\n\tif (uf_mem_offset + size > UF_MEM_SIZE) {\n\t\tfprintf(stderr, \"Requesting more uf_mem than expected!\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = &uf_mem[uf_mem_offset];\n\n\t \n\tif (backing_data != NULL)\n\t\tmemcpy(&backing_mem[uf_mem_offset], backing_data, size);\n\n\t \n\tuf_mem_offset += size;\n\t \n\tuf_mem_offset = (uf_mem_offset + pagesize - 1) & ~(pagesize - 1);\n\n\treturn ret;\n}\n\nvoid *fault_handler_thread(void *arg)\n{\n\tstruct uffd_msg msg;\t \n\tlong uffd;\t\t \n\tstruct uffdio_copy uffdio_copy;\n\tstruct pollfd pollfd;\n\tssize_t nread, offset;\n\n\tuffd = (long) arg;\n\n\tfor (;;) {\n\t\tpollfd.fd = uffd;\n\t\tpollfd.events = POLLIN;\n\t\tif (poll(&pollfd, 1, -1) == -1) {\n\t\t\tperror(\"poll() failed\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tnread = read(uffd, &msg, sizeof(msg));\n\t\tif (nread == 0) {\n\t\t\tfprintf(stderr, \"read(): EOF on userfaultfd\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (nread == -1) {\n\t\t\tperror(\"read() failed\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tif (msg.event != UFFD_EVENT_PAGEFAULT) {\n\t\t\tfprintf(stderr, \"Unexpected event on userfaultfd\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tuffdio_copy.dst = msg.arg.pagefault.address & ~(pagesize-1);\n\n\t\toffset = (char *) uffdio_copy.dst - uf_mem;\n\t\tuffdio_copy.src = (unsigned long) &backing_mem[offset];\n\n\t\tuffdio_copy.len = pagesize;\n\t\tuffdio_copy.mode = 0;\n\t\tuffdio_copy.copy = 0;\n\t\tif (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {\n\t\t\tperror(\"ioctl-UFFDIO_COPY failed\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nvoid setup_uf_mem(void)\n{\n\tlong uffd;\t\t \n\tpthread_t thr;\n\tstruct uffdio_api uffdio_api;\n\tstruct uffdio_register uffdio_register;\n\tint ret;\n\n\tpagesize = sysconf(_SC_PAGE_SIZE);\n\n\t \n\tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\tif (uffd == -1) {\n\t\tperror(\"userfaultfd() failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) {\n\t\tperror(\"ioctl-UFFDIO_API failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tuf_mem = mmap(NULL, UF_MEM_SIZE, PROT_READ | PROT_WRITE,\n\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (uf_mem == MAP_FAILED) {\n\t\tperror(\"mmap() failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tuffdio_register.range.start = (unsigned long) uf_mem;\n\tuffdio_register.range.len = UF_MEM_SIZE;\n\tuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n\tif (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) {\n\t\tperror(\"ioctl-UFFDIO_REGISTER\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tret = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"pthread_create(): Error. Returned %d\\n\", ret);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n \nvoid signal_handler(int signo, siginfo_t *si, void *uc)\n{\n\tucontext_t *ucp = uc;\n\n\t \n\tucp->uc_link->uc_mcontext.regs->nip += 4;\n\n\tucp->uc_mcontext.v_regs =\n\t\tget_uf_mem(sizeof(elf_vrreg_t), ucp->uc_mcontext.v_regs);\n\n\tucp->uc_link->uc_mcontext.v_regs =\n\t\tget_uf_mem(sizeof(elf_vrreg_t), ucp->uc_link->uc_mcontext.v_regs);\n\n\tucp->uc_link = get_uf_mem(sizeof(ucontext_t), ucp->uc_link);\n}\n\nbool have_userfaultfd(void)\n{\n\tlong rc;\n\n\terrno = 0;\n\trc = syscall(__NR_userfaultfd, -1);\n\n\treturn rc == 0 || errno != ENOSYS;\n}\n\nint tm_signal_pagefault(void)\n{\n\tstruct sigaction sa;\n\tstack_t ss;\n\n\tSKIP_IF(!have_htm());\n\tSKIP_IF(htm_is_synthetic());\n\tSKIP_IF(!have_userfaultfd());\n\n\tsetup_uf_mem();\n\n\t \n\tss.ss_sp = get_uf_mem(SIGSTKSZ, NULL);\n\tss.ss_size = SIGSTKSZ;\n\tss.ss_flags = 0;\n\tif (sigaltstack(&ss, NULL) == -1) {\n\t\tperror(\"sigaltstack() failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n\tsa.sa_sigaction = signal_handler;\n\tif (sigaction(SIGTRAP, &sa, NULL) == -1) {\n\t\tperror(\"sigaction() failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tasm __volatile__(\n\t\t\t\"tbegin.;\"\n\t\t\t\"beq    1f;\"\n\t\t\t\"trap;\"\n\t\t\t\"1: ;\"\n\t\t\t: : : \"memory\");\n\n\t \n\tasm __volatile__(\n\t\t\t\"tbegin.;\"\n\t\t\t\"beq    1f;\"\n\t\t\t\"tsuspend.;\"\n\t\t\t\"trap;\"\n\t\t\t\"tresume.;\"\n\t\t\t\"1: ;\"\n\t\t\t: : : \"memory\");\n\n\treturn EXIT_SUCCESS;\n}\n\nint main(int argc, char **argv)\n{\n\t \n\ttest_harness_set_timeout(2);\n\treturn test_harness(tm_signal_pagefault, \"tm_signal_pagefault\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}