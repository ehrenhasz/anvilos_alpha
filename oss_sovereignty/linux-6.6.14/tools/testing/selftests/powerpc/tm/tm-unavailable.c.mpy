{
  "module_name": "tm-unavailable.c",
  "hash_id": "3eaeb4e1757086825ab3730421e0dff8beb5a8d342e0ea50e7ff867d2eab9bdc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/tm/tm-unavailable.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <error.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <sched.h>\n\n#include \"tm.h\"\n\n#define DEBUG 0\n\n \n#define FP_UNA_EXCEPTION\t0\n#define VEC_UNA_EXCEPTION\t1\n#define VSX_UNA_EXCEPTION\t2\n\n#define NUM_EXCEPTIONS\t\t3\n#define err_at_line(status, errnum, format, ...) \\\n\terror_at_line(status, errnum,  __FILE__, __LINE__, format ##__VA_ARGS__)\n\n#define pr_warn(code, format, ...) err_at_line(0, code, format, ##__VA_ARGS__)\n#define pr_err(code, format, ...) err_at_line(1, code, format, ##__VA_ARGS__)\n\nstruct Flags {\n\tint touch_fp;\n\tint touch_vec;\n\tint result;\n\tint exception;\n} flags;\n\nbool expecting_failure(void)\n{\n\tif (flags.touch_fp && flags.exception == FP_UNA_EXCEPTION)\n\t\treturn false;\n\n\tif (flags.touch_vec && flags.exception == VEC_UNA_EXCEPTION)\n\t\treturn false;\n\n\t \n\tif ((flags.touch_fp && flags.touch_vec) &&\n\t     flags.exception == VSX_UNA_EXCEPTION)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool is_failure(uint64_t condition_reg)\n{\n\t \n\treturn ((condition_reg >> 28) & 0xa) == 0xa;\n}\n\nvoid *tm_una_ping(void *input)\n{\n\n\t \n\tuint64_t high_vs0 = 0x5555555555555555;\n\tuint64_t low_vs0 = 0xffffffffffffffff;\n\tuint64_t high_vs32 = 0x5555555555555555;\n\tuint64_t low_vs32 = 0xffffffffffffffff;\n\n\t \n\tuint64_t counter = 0x1ff000000;\n\n\t \n\tuint64_t cr_ = 0;\n\n\t \n\tif (DEBUG)\n\t\tsleep(1);\n\n\tprintf(\"If MSR.FP=%d MSR.VEC=%d: \", flags.touch_fp, flags.touch_vec);\n\n\tif (flags.exception != FP_UNA_EXCEPTION &&\n\t    flags.exception != VEC_UNA_EXCEPTION &&\n\t    flags.exception != VSX_UNA_EXCEPTION) {\n\t\tprintf(\"No valid exception specified to test.\\n\");\n\t\treturn NULL;\n\t}\n\n\tasm (\n\t\t \n\t\t\"\tmtvsrd\t\t33, %[high_vs0]\t\t;\"\n\t\t\"\tmtvsrd\t\t34, %[low_vs0]\t\t;\"\n\n\t\t \n\t\t\"\txxmrghd\t\t0, 33, 34\t\t;\"\n\n\t\t \n\t\t\"\txxmrghd\t\t32, 33, 34\t\t;\"\n\n\t\t \n\t\t\"\tmtctr\t\t%[counter]\t\t;\"\n\n\t\t \n\t\t\"1:\tbdnz 1b\t\t\t\t\t;\"\n\n\t\t \n\t\t\"\tcmpldi\t\t%[touch_fp], 0\t\t;\"\n\t\t\"\tbeq\t\tno_fp\t\t\t;\"\n\t\t\"\tfadd\t\t10, 10, 10\t\t;\"\n\t\t\"no_fp:\t\t\t\t\t\t;\"\n\n\t\t \n\t\t\"\tcmpldi\t\t%[touch_vec], 0\t\t;\"\n\t\t\"\tbeq\t\tno_vec\t\t\t;\"\n\t\t\"\tvaddcuw\t\t10, 10, 10\t\t;\"\n\t\t\"no_vec:\t\t\t\t\t;\"\n\n\t\t \n\t\t\"\ttbegin.\t\t\t\t\t;\"\n\t\t\"\tbeq\t\ttrans_fail\t\t;\"\n\n\t\t \n\t\t\"\tcmpldi\t\t%[exception], %[ex_fp]\t;\"\n\t\t\"\tbne\t\t1f\t\t\t;\"\n\t\t\"\tfadd\t\t10, 10, 10\t\t;\"\n\t\t\"\tb\t\tdone\t\t\t;\"\n\n\t\t \n\t\t\"1:\tcmpldi\t\t%[exception], %[ex_vec]\t;\"\n\t\t\"\tbne\t\t2f\t\t\t;\"\n\t\t\"\tvaddcuw\t\t10, 10, 10\t\t;\"\n\t\t\"\tb\t\tdone\t\t\t;\"\n\n\t\t \n\t\t\"2:\txxmrghd\t\t10, 10, 10\t\t;\"\n\n\t\t\"done:\ttend. ;\"\n\n\t\t\"trans_fail: ;\"\n\n\t\t \n\t\t\"\tmfvsrd\t\t%[high_vs0], 0\t\t;\"\n\t\t\"\txxsldwi\t\t3, 0, 0, 2\t\t;\"\n\t\t\"\tmfvsrd\t\t%[low_vs0], 3\t\t;\"\n\t\t\"\tmfvsrd\t\t%[high_vs32], 32\t;\"\n\t\t\"\txxsldwi\t\t3, 32, 32, 2\t\t;\"\n\t\t\"\tmfvsrd\t\t%[low_vs32], 3\t\t;\"\n\n\t\t \n\t\t\"\tmfcr\t\t%[cr_]\t\t;\"\n\n\t\t: [high_vs0]  \"+r\" (high_vs0),\n\t\t  [low_vs0]   \"+r\" (low_vs0),\n\t\t  [high_vs32] \"=r\" (high_vs32),\n\t\t  [low_vs32]  \"=r\" (low_vs32),\n\t\t  [cr_]       \"+r\" (cr_)\n\t\t: [touch_fp]  \"r\"  (flags.touch_fp),\n\t\t  [touch_vec] \"r\"  (flags.touch_vec),\n\t\t  [exception] \"r\"  (flags.exception),\n\t\t  [ex_fp]     \"i\"  (FP_UNA_EXCEPTION),\n\t\t  [ex_vec]    \"i\"  (VEC_UNA_EXCEPTION),\n\t\t  [ex_vsx]    \"i\"  (VSX_UNA_EXCEPTION),\n\t\t  [counter]   \"r\"  (counter)\n\n\t\t: \"cr0\", \"ctr\", \"v10\", \"vs0\", \"vs10\", \"vs3\", \"vs32\", \"vs33\",\n\t\t  \"vs34\", \"fr10\"\n\n\t\t);\n\n\t \n\tif (expecting_failure() && !is_failure(cr_)) {\n\t\tprintf(\"\\n\\tExpecting the transaction to fail, %s\",\n\t\t\t\"but it didn't\\n\\t\");\n\t\tflags.result++;\n\t}\n\n\t \n\tif (!expecting_failure() && is_failure(cr_) &&\n\t    !failure_is_reschedule()) {\n\t\tprintf(\"\\n\\tUnexpected transaction failure 0x%02lx\\n\\t\",\n\t\t\tfailure_code());\n\t\treturn (void *) -1;\n\t}\n\n\t \n\tif (is_failure(cr_) && !failure_is_unavailable() &&\n\t    !failure_is_reschedule()) {\n\t\tprintf(\"\\n\\tUnexpected failure cause 0x%02lx\\n\\t\",\n\t\t\tfailure_code());\n\t\treturn (void *) -1;\n\t}\n\n\t \n\tif (DEBUG)\n\t\tprintf(\"CR0: 0x%1lx \", cr_ >> 28);\n\n\t \n\tif (high_vs0 != 0x5555555555555555 || low_vs0 != 0xFFFFFFFFFFFFFFFF) {\n\t\tprintf(\"FP corrupted!\");\n\t\t\tprintf(\"  high = %#16\" PRIx64 \"  low = %#16\" PRIx64 \" \",\n\t\t\t\thigh_vs0, low_vs0);\n\t\tflags.result++;\n\t} else\n\t\tprintf(\"FP ok \");\n\n\t \n\tif (high_vs32 != 0x5555555555555555 || low_vs32 != 0xFFFFFFFFFFFFFFFF) {\n\t\tprintf(\"VEC corrupted!\");\n\t\t\tprintf(\"  high = %#16\" PRIx64 \"  low = %#16\" PRIx64,\n\t\t\t\thigh_vs32, low_vs32);\n\t\tflags.result++;\n\t} else\n\t\tprintf(\"VEC ok\");\n\n\tputchar('\\n');\n\n\treturn NULL;\n}\n\n \nvoid *tm_una_pong(void *not_used)\n{\n\t \n\tif (DEBUG)\n\t\tsleep(1);\n\n\t \n\twhile (1)\n\t\tsched_yield();\n}\n\n \nvoid test_fp_vec(int fp, int vec, pthread_attr_t *attr)\n{\n\tint retries = 2;\n\tvoid *ret_value;\n\tpthread_t t0;\n\n\tflags.touch_fp = fp;\n\tflags.touch_vec = vec;\n\n\t \n\tdo {\n\t\tint rc;\n\n\t\t \n\t\trc = pthread_create(&t0, attr, tm_una_ping, (void *) &flags);\n\t\tif (rc)\n\t\t\tpr_err(rc, \"pthread_create()\");\n\t\trc = pthread_setname_np(t0, \"tm_una_ping\");\n\t\tif (rc)\n\t\t\tpr_warn(rc, \"pthread_setname_np\");\n\t\trc = pthread_join(t0, &ret_value);\n\t\tif (rc)\n\t\t\tpr_err(rc, \"pthread_join\");\n\n\t\tretries--;\n\t} while (ret_value != NULL && retries);\n\n\tif (!retries) {\n\t\tflags.result = 1;\n\t\tif (DEBUG)\n\t\t\tprintf(\"All transactions failed unexpectedly\\n\");\n\n\t}\n}\n\nint tm_unavailable_test(void)\n{\n\tint cpu, rc, exception;  \n\tpthread_t t1;\n\tpthread_attr_t attr;\n\tcpu_set_t cpuset;\n\n\tSKIP_IF(!have_htm());\n\tSKIP_IF(htm_is_synthetic());\n\n\tcpu = pick_online_cpu();\n\tFAIL_IF(cpu < 0);\n\n\t\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\n\t \n\trc = pthread_attr_init(&attr);\n\tif (rc)\n\t\tpr_err(rc, \"pthread_attr_init()\");\n\n\t \n\trc = pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n\tif (rc)\n\t\tpr_err(rc, \"pthread_attr_setaffinity_np()\");\n\n\trc = pthread_create(&t1, &attr  , tm_una_pong, NULL);\n\tif (rc)\n\t\tpr_err(rc, \"pthread_create()\");\n\n\t \n\trc = pthread_setname_np(t1, \"tm_una_pong\");\n\tif (rc)\n\t\tpr_warn(rc, \"pthread_create()\");\n\n\tflags.result = 0;\n\n\tfor (exception = 0; exception < NUM_EXCEPTIONS; exception++) {\n\t\tprintf(\"Checking if FP/VEC registers are sane after\");\n\n\t\tif (exception == FP_UNA_EXCEPTION)\n\t\t\tprintf(\" a FP unavailable exception...\\n\");\n\n\t\telse if (exception == VEC_UNA_EXCEPTION)\n\t\t\tprintf(\" a VEC unavailable exception...\\n\");\n\n\t\telse\n\t\t\tprintf(\" a VSX unavailable exception...\\n\");\n\n\t\tflags.exception = exception;\n\n\t\ttest_fp_vec(0, 0, &attr);\n\t\ttest_fp_vec(1, 0, &attr);\n\t\ttest_fp_vec(0, 1, &attr);\n\t\ttest_fp_vec(1, 1, &attr);\n\n\t}\n\n\tif (flags.result > 0) {\n\t\tprintf(\"result: failed!\\n\");\n\t\texit(1);\n\t} else {\n\t\tprintf(\"result: success\\n\");\n\t\texit(0);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\ttest_harness_set_timeout(220);\n\treturn test_harness(tm_unavailable_test, \"tm_unavailable_test\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}