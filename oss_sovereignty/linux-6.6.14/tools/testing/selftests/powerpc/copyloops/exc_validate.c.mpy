{
  "module_name": "exc_validate.c",
  "hash_id": "c2bf5a84db4ab82fe72eef8795ccfe16387b075fe42ebe6fa647db2db65c2fb9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/copyloops/exc_validate.c",
  "human_readable_source": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n#include \"utils.h\"\n\nextern char __start___ex_table[];\nextern char __stop___ex_table[];\n\n#if defined(__powerpc64__)\n#define UCONTEXT_NIA(UC)\t(UC)->uc_mcontext.gp_regs[PT_NIP]\n#elif defined(__powerpc__)\n#define UCONTEXT_NIA(UC)\t(UC)->uc_mcontext.uc_regs->gregs[PT_NIP]\n#else\n#error implement UCONTEXT_NIA\n#endif\n\nstatic void segv_handler(int signr, siginfo_t *info, void *ptr)\n{\n\tucontext_t *uc = (ucontext_t *)ptr;\n\tunsigned long addr = (unsigned long)info->si_addr;\n\tunsigned long *ip = &UCONTEXT_NIA(uc);\n\tunsigned long *ex_p = (unsigned long *)__start___ex_table;\n\n\twhile (ex_p < (unsigned long *)__stop___ex_table) {\n\t\tunsigned long insn, fixup;\n\n\t\tinsn = *ex_p++;\n\t\tfixup = *ex_p++;\n\n\t\tif (insn == *ip) {\n\t\t\t*ip = fixup;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"No exception table match for NIA %lx ADDR %lx\\n\", *ip, addr);\n\tabort();\n}\n\nstatic void setup_segv_handler(void)\n{\n\tstruct sigaction action;\n\n\tmemset(&action, 0, sizeof(action));\n\taction.sa_sigaction = segv_handler;\n\taction.sa_flags = SA_SIGINFO;\n\tsigaction(SIGSEGV, &action, NULL);\n}\n\nunsigned long COPY_LOOP(void *to, const void *from, unsigned long size);\nunsigned long test_copy_tofrom_user_reference(void *to, const void *from, unsigned long size);\n\nstatic int total_passed;\nstatic int total_failed;\n\nstatic void do_one_test(char *dstp, char *srcp, unsigned long len)\n{\n\tunsigned long got, expected;\n\n\tgot = COPY_LOOP(dstp, srcp, len);\n\texpected = test_copy_tofrom_user_reference(dstp, srcp, len);\n\n\tif (got != expected) {\n\t\ttotal_failed++;\n\t\tprintf(\"FAIL from=%p to=%p len=%ld returned %ld, expected %ld\\n\",\n\t\t       srcp, dstp, len, got, expected);\n\t\t\n\t} else\n\t\ttotal_passed++;\n}\n\n\n#define MAX_LEN 16\n\nint test_copy_exception(void)\n{\n\tint page_size;\n\tstatic char *p, *q;\n\tunsigned long src, dst, len;\n\n\tpage_size = getpagesize();\n\tp = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,\n\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\n\tif (p == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\texit(1);\n\t}\n\n\tmemset(p, 0, page_size);\n\n\tsetup_segv_handler();\n\n\tif (mprotect(p + page_size, page_size, PROT_NONE)) {\n\t\tperror(\"mprotect\");\n\t\texit(1);\n\t}\n\n\tq = p + page_size - MAX_LEN;\n\n\tfor (src = 0; src < MAX_LEN; src++) {\n\t\tfor (dst = 0; dst < MAX_LEN; dst++) {\n\t\t\tfor (len = 0; len < MAX_LEN+1; len++) {\n\t\t\t\t\n\t\t\t\tdo_one_test(q+dst, q+src, len);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Totals:\\n\");\n\tprintf(\"  Pass: %d\\n\", total_passed);\n\tprintf(\"  Fail: %d\\n\", total_failed);\n\n\treturn 0;\n}\n\nint main(void)\n{\n\treturn test_harness(test_copy_exception, str(COPY_LOOP));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}