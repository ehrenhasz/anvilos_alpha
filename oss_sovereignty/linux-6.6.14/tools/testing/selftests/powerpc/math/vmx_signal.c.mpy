{
  "module_name": "vmx_signal.c",
  "hash_id": "0b4c6d8adc4f07200e9b163e34285d5fb9b6bd6994c342f4c432abfa4e2a746e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/vmx_signal.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <altivec.h>\n\n#include \"utils.h\"\n\n \n#define ITERATIONS 10\n \n#define THREAD_FACTOR 8\n\n__thread vector int varray[] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10,11,12},\n\t{13,14,15,16},{17,18,19,20},{21,22,23,24},\n\t{25,26,27,28},{29,30,31,32},{33,34,35,36},\n\t{37,38,39,40},{41,42,43,44},{45,46,47,48}};\n\nbool bad_context;\nint running;\nint threads_starting;\n\nextern int preempt_vmx(vector int *varray, int *threads_starting, int *sentinal);\n\nvoid signal_vmx_sig(int sig, siginfo_t *info, void *context)\n{\n\tint i;\n\tucontext_t *uc = context;\n\tmcontext_t *mc = &uc->uc_mcontext;\n\n\t \n\tfor (i = 20; i < 32; i++) {\n\t\tif (memcmp(mc->v_regs->vrregs[i], &varray[i - 20], 16)) {\n\t\t\tint j;\n\t\t\t \n\t\t\tprintf(\"VMX mismatch at reg %d!\\n\", i);\n\t\t\tprintf(\"Reg | Actual                  | Expected\\n\");\n\t\t\tfor (j = 20; j < 32; j++) {\n\t\t\t\tprintf(\"%d  | 0x%04x%04x%04x%04x      | 0x%04x%04x%04x%04x\\n\", j, mc->v_regs->vrregs[j][0],\n\t\t\t\t\t   mc->v_regs->vrregs[j][1], mc->v_regs->vrregs[j][2], mc->v_regs->vrregs[j][3],\n\t\t\t\t\t   varray[j - 20][0], varray[j - 20][1], varray[j - 20][2], varray[j - 20][3]);\n\t\t\t}\n\t\t\tbad_context = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid *signal_vmx_c(void *p)\n{\n\tint i, j;\n\tlong rc;\n\tstruct sigaction act;\n\tact.sa_sigaction = signal_vmx_sig;\n\tact.sa_flags = SA_SIGINFO;\n\trc = sigaction(SIGUSR1, &act, NULL);\n\tif (rc)\n\t\treturn p;\n\n\tsrand(pthread_self());\n\tfor (i = 0; i < 12; i++)\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tvarray[i][j] = rand();\n\n\trc = preempt_vmx(varray, &threads_starting, &running);\n\n\treturn (void *) rc;\n}\n\nint test_signal_vmx(void)\n{\n\tint i, j, rc, threads;\n\tvoid *rc_p;\n\tpthread_t *tids;\n\n\t\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_2_07));\n\n\tthreads = sysconf(_SC_NPROCESSORS_ONLN) * THREAD_FACTOR;\n\ttids = malloc(threads * sizeof(pthread_t));\n\tFAIL_IF(!tids);\n\n\trunning = true;\n\tthreads_starting = threads;\n\tfor (i = 0; i < threads; i++) {\n\t\trc = pthread_create(&tids[i], NULL, signal_vmx_c, NULL);\n\t\tFAIL_IF(rc);\n\t}\n\n\tsetbuf(stdout, NULL);\n\tprintf(\"\\tWaiting for %d workers to start... %d\", threads, threads_starting);\n\twhile (threads_starting) {\n\t\tasm volatile(\"\": : :\"memory\");\n\t\tusleep(1000);\n\t\tprintf(\", %d\", threads_starting);\n\t}\n\tprintf(\" ...done\\n\");\n\n\tprintf(\"\\tSending signals to all threads %d times...\", ITERATIONS);\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tfor (j = 0; j < threads; j++) {\n\t\t\tpthread_kill(tids[j], SIGUSR1);\n\t\t}\n\t\tsleep(1);\n\t}\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tKilling workers...\");\n\trunning = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\tpthread_join(tids[i], &rc_p);\n\n\t\t \n\t\tif ((long) rc_p || bad_context)\n\t\t\tprintf(\"oops\\n\");\n\t\tif (bad_context)\n\t\t\tfprintf(stderr, \"\\t!! bad_context is true\\n\");\n\t\tFAIL_IF((long) rc_p || bad_context);\n\t}\n\tprintf(\"done\\n\");\n\n\tfree(tids);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\ttest_harness_set_timeout(360);\n\treturn test_harness(test_signal_vmx, \"vmx_signal\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}