{
  "module_name": "vmx_asm.S",
  "hash_id": "bc8197cd7a14cbb0190ba162fd8c2cd9cc970e2b132a86ff5a76a077e05f61cd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/vmx_asm.S",
  "human_readable_source": " \n \n\n#include \"basic_asm.h\"\n#include \"vmx_asm.h\"\n\n# Should be safe from C, only touches r4, r5 and v0,v1,v2\nFUNC_START(check_vmx)\n\tPUSH_BASIC_STACK(32)\n\tmr r4,r3\n\tli\tr3,1 # assume a bad result\n\tli\tr5,0\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v20\n\tvmr\tv2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v21\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v22\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v23\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v24\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v25\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v26\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v27\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v28\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v29\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v30\n\tvand\tv2,v2,v1\n\n\taddi\tr5,r5,16\n\tlvx\tv0,r5,r4\n\tvcmpequd.\tv1,v0,v31\n\tvand\tv2,v2,v1\n\n\tli\tr5,STACK_FRAME_LOCAL(0,0)\n\tstvx\tv2,r5,sp\n\tldx\tr0,r5,sp\n\tcmpdi\tr0,0xffffffffffffffff\n\tbne\t1f\n\tli\tr3,0\n1:\tPOP_BASIC_STACK(32)\n\tblr\nFUNC_END(check_vmx)\n\n# Safe from C\nFUNC_START(test_vmx)\n\t# r3 holds pointer to where to put the result of fork\n\t# r4 holds pointer to the pid\n\t# v20-v31 are non-volatile\n\tPUSH_BASIC_STACK(512)\n\tstd\tr3,STACK_FRAME_PARAM(0)(sp) # Address of varray\n\tstd r4,STACK_FRAME_PARAM(1)(sp) # address of pid\n\tPUSH_VMX(STACK_FRAME_LOCAL(2,0),r4)\n\n\tbl load_vmx\n\tnop\n\n\tli\tr0,__NR_fork\n\tsc\n\t# Pass the result of fork back to the caller\n\tld\tr9,STACK_FRAME_PARAM(1)(sp)\n\tstd\tr3,0(r9)\n\n\tld r3,STACK_FRAME_PARAM(0)(sp)\n\tbl check_vmx\n\tnop\n\n\tPOP_VMX(STACK_FRAME_LOCAL(2,0),r4)\n\tPOP_BASIC_STACK(512)\n\tblr\nFUNC_END(test_vmx)\n\n# int preempt_vmx(vector int *varray, int *threads_starting, int *running)\n# On starting will (atomically) decrement threads_starting as a signal that\n# the VMX have been loaded with varray. Will proceed to check the validity of\n# the VMX registers while running is not zero.\nFUNC_START(preempt_vmx)\n\tPUSH_BASIC_STACK(512)\n\tstd r3,STACK_FRAME_PARAM(0)(sp) # vector int *varray\n\tstd r4,STACK_FRAME_PARAM(1)(sp) # int *threads_starting\n\tstd r5,STACK_FRAME_PARAM(2)(sp) # int *running\n\t# VMX need to write to 16 byte aligned addresses, skip STACK_FRAME_LOCAL(3,0)\n\tPUSH_VMX(STACK_FRAME_LOCAL(4,0),r4)\n\n\tbl load_vmx\n\tnop\n\n\tsync\n\t# Atomic DEC\n\tld r3,STACK_FRAME_PARAM(1)(sp)\n1:\tlwarx r4,0,r3\n\taddi r4,r4,-1\n\tstwcx. r4,0,r3\n\tbne- 1b\n\n2:\tld r3,STACK_FRAME_PARAM(0)(sp)\n\tbl check_vmx\n\tnop\n\tcmpdi r3,0\n\tbne 3f\n\tld r4,STACK_FRAME_PARAM(2)(sp)\n\tld r5,0(r4)\n\tcmpwi r5,0\n\tbne 2b\n\n3:\tPOP_VMX(STACK_FRAME_LOCAL(4,0),r4)\n\tPOP_BASIC_STACK(512)\n\tblr\nFUNC_END(preempt_vmx)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}