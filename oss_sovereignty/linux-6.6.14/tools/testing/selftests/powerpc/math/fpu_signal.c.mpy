{
  "module_name": "fpu_signal.c",
  "hash_id": "e89bdca50e033ee2a2d8dba7769a2533ddd87166c29d3e90b6928dec4b1504a8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/fpu_signal.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include \"utils.h\"\n\n \n#define ITERATIONS 10\n \n#define THREAD_FACTOR 8\n\n__thread double darray[] = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n\t\t     1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0,\n\t\t     2.1};\n\nbool bad_context;\nint threads_starting;\nint running;\n\nextern long preempt_fpu(double *darray, int *threads_starting, int *running);\n\nvoid signal_fpu_sig(int sig, siginfo_t *info, void *context)\n{\n\tint i;\n\tucontext_t *uc = context;\n\tmcontext_t *mc = &uc->uc_mcontext;\n\n\t \n\tfor (i = 14; i < 32; i++) {\n\t\tif (mc->fp_regs[i] != darray[i - 14]) {\n\t\t\tbad_context = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid *signal_fpu_c(void *p)\n{\n\tint i;\n\tlong rc;\n\tstruct sigaction act;\n\tact.sa_sigaction = signal_fpu_sig;\n\tact.sa_flags = SA_SIGINFO;\n\trc = sigaction(SIGUSR1, &act, NULL);\n\tif (rc)\n\t\treturn p;\n\n\tsrand(pthread_self());\n\tfor (i = 0; i < 21; i++)\n\t\tdarray[i] = rand();\n\n\trc = preempt_fpu(darray, &threads_starting, &running);\n\n\treturn (void *) rc;\n}\n\nint test_signal_fpu(void)\n{\n\tint i, j, rc, threads;\n\tvoid *rc_p;\n\tpthread_t *tids;\n\n\tthreads = sysconf(_SC_NPROCESSORS_ONLN) * THREAD_FACTOR;\n\ttids = malloc(threads * sizeof(pthread_t));\n\tFAIL_IF(!tids);\n\n\trunning = true;\n\tthreads_starting = threads;\n\tfor (i = 0; i < threads; i++) {\n\t\trc = pthread_create(&tids[i], NULL, signal_fpu_c, NULL);\n\t\tFAIL_IF(rc);\n\t}\n\n\tsetbuf(stdout, NULL);\n\tprintf(\"\\tWaiting for all workers to start...\");\n\twhile (threads_starting)\n\t\tasm volatile(\"\": : :\"memory\");\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tSending signals to all threads %d times...\", ITERATIONS);\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tfor (j = 0; j < threads; j++) {\n\t\t\tpthread_kill(tids[j], SIGUSR1);\n\t\t}\n\t\tsleep(1);\n\t}\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tStopping workers...\");\n\trunning = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\tpthread_join(tids[i], &rc_p);\n\n\t\t \n\t\tif ((long) rc_p || bad_context)\n\t\t\tprintf(\"oops\\n\");\n\t\tif (bad_context)\n\t\t\tfprintf(stderr, \"\\t!! bad_context is true\\n\");\n\t\tFAIL_IF((long) rc_p || bad_context);\n\t}\n\tprintf(\"done\\n\");\n\n\tfree(tids);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(test_signal_fpu, \"fpu_signal\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}