{
  "module_name": "fpu_preempt.c",
  "hash_id": "25718b3064b5e2ffe1b9b76300e36b4546b1e79b2af9e306f5c3098ccd4e6ee0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/fpu_preempt.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include \"utils.h\"\n\n \n#define PREEMPT_TIME 20\n \n#define THREAD_FACTOR 8\n\n\n__thread double darray[] = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n\t\t     1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0,\n\t\t     2.1};\n\nint threads_starting;\nint running;\n\nextern int preempt_fpu(double *darray, int *threads_starting, int *running);\n\nvoid *preempt_fpu_c(void *p)\n{\n\tlong rc;\n\tint i;\n\n\tsrand(pthread_self());\n\tfor (i = 0; i < 21; i++)\n\t\tdarray[i] = rand();\n\n\trc = preempt_fpu(darray, &threads_starting, &running);\n\n\treturn (void *)rc;\n}\n\nint test_preempt_fpu(void)\n{\n\tint i, rc, threads;\n\tpthread_t *tids;\n\n\tthreads = sysconf(_SC_NPROCESSORS_ONLN) * THREAD_FACTOR;\n\ttids = malloc((threads) * sizeof(pthread_t));\n\tFAIL_IF(!tids);\n\n\trunning = true;\n\tthreads_starting = threads;\n\tfor (i = 0; i < threads; i++) {\n\t\trc = pthread_create(&tids[i], NULL, preempt_fpu_c, NULL);\n\t\tFAIL_IF(rc);\n\t}\n\n\tsetbuf(stdout, NULL);\n\t \n\tprintf(\"\\tWaiting for all workers to start...\");\n\twhile(threads_starting)\n\t\tasm volatile(\"\": : :\"memory\");\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tWaiting for %d seconds to let some workers get preempted...\", PREEMPT_TIME);\n\tsleep(PREEMPT_TIME);\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tStopping workers...\");\n\t \n\trunning = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\tvoid *rc_p;\n\t\tpthread_join(tids[i], &rc_p);\n\n\t\t \n\t\tif ((long) rc_p)\n\t\t\tprintf(\"oops\\n\");\n\t\tFAIL_IF((long) rc_p);\n\t}\n\tprintf(\"done\\n\");\n\n\tfree(tids);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(test_preempt_fpu, \"fpu_preempt\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}