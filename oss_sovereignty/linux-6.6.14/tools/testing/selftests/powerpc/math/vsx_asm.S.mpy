{
  "module_name": "vsx_asm.S",
  "hash_id": "c9dabc2c9d2d2a362d239c5d1efea366ef5bf1c66207ad4b2c152fef12d19853",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/vsx_asm.S",
  "human_readable_source": " \n \n\n#include \"basic_asm.h\"\n#include \"vsx_asm.h\"\n\n#long check_vsx(vector int *r3);\n#This function wraps storeing VSX regs to the end of an array and a\n#call to a comparison function in C which boils down to a memcmp()\nFUNC_START(check_vsx)\n\tPUSH_BASIC_STACK(32)\n\tstd\tr3,STACK_FRAME_PARAM(0)(sp)\n\taddi r3, r3, 16 * 12 #Second half of array\n\tbl store_vsx\n\tld r3,STACK_FRAME_PARAM(0)(sp)\n\tbl vsx_memcmp\n\tPOP_BASIC_STACK(32)\n\tblr\nFUNC_END(check_vsx)\n\n# int preempt_vmx(vector int *varray, int *threads_starting,\n#                 int *running);\n# On starting will (atomically) decrement threads_starting as a signal\n# that the VMX have been loaded with varray. Will proceed to check the\n# validity of the VMX registers while running is not zero.\nFUNC_START(preempt_vsx)\n\tPUSH_BASIC_STACK(512)\n\tstd r3,STACK_FRAME_PARAM(0)(sp) # vector int *varray\n\tstd r4,STACK_FRAME_PARAM(1)(sp) # int *threads_starting\n\tstd r5,STACK_FRAME_PARAM(2)(sp) # int *running\n\n\tbl load_vsx\n\tnop\n\n\tsync\n\t# Atomic DEC\n\tld r3,STACK_FRAME_PARAM(1)(sp)\n1:\tlwarx r4,0,r3\n\taddi r4,r4,-1\n\tstwcx. r4,0,r3\n\tbne- 1b\n\n2:\tld r3,STACK_FRAME_PARAM(0)(sp)\n\tbl check_vsx\n\tnop\n\tcmpdi r3,0\n\tbne 3f\n\tld r4,STACK_FRAME_PARAM(2)(sp)\n\tld r5,0(r4)\n\tcmpwi r5,0\n\tbne 2b\n\n3:\tPOP_BASIC_STACK(512)\n\tblr\nFUNC_END(preempt_vsx)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}