{
  "module_name": "vsx_preempt.c",
  "hash_id": "f850c59d01b181a44ec5ee7b4c16739e7e25defff0f8e3cd3ba0ebbd959c48e4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/math/vsx_preempt.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include \"utils.h\"\n\n \n#define PREEMPT_TIME 20\n \n#define THREAD_FACTOR 8\n\n \n__thread vector int varray[24] = {\n\t{1, 2, 3, 4 }, {5, 6, 7, 8 }, {9, 10,11,12},\n\t{13,14,15,16}, {17,18,19,20}, {21,22,23,24},\n\t{25,26,27,28}, {29,30,31,32}, {33,34,35,36},\n\t{37,38,39,40}, {41,42,43,44}, {45,46,47,48}\n};\n\nint threads_starting;\nint running;\n\nextern long preempt_vsx(vector int *varray, int *threads_starting, int *running);\n\nlong vsx_memcmp(vector int *a) {\n\tvector int zero = {0, 0, 0, 0};\n\tint i;\n\n\tFAIL_IF(a != varray);\n\n\tfor(i = 0; i < 12; i++) {\n\t\tif (memcmp(&a[i + 12], &zero, sizeof(vector int)) == 0) {\n\t\t\tfprintf(stderr, \"Detected zero from the VSX reg %d\\n\", i + 12);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (memcmp(a, &a[12], 12 * sizeof(vector int))) {\n\t\tlong *p = (long *)a;\n\t\tfprintf(stderr, \"VSX mismatch\\n\");\n\t\tfor (i = 0; i < 24; i=i+2)\n\t\t\tfprintf(stderr, \"%d: 0x%08lx%08lx | 0x%08lx%08lx\\n\",\n\t\t\t\t\ti/2 + i%2 + 20, p[i], p[i + 1], p[i + 24], p[i + 25]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid *preempt_vsx_c(void *p)\n{\n\tint i, j;\n\tlong rc;\n\tsrand(pthread_self());\n\tfor (i = 0; i < 12; i++)\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tvarray[i][j] = rand();\n\t\t\t \n\t\t\tif (varray[i][j] == 0)\n\t\t\t\tj--;\n\t\t}\n\trc = preempt_vsx(varray, &threads_starting, &running);\n\tif (rc == 2)\n\t\tfprintf(stderr, \"Caught zeros in VSX compares\\n\");\n\treturn (void *)rc;\n}\n\nint test_preempt_vsx(void)\n{\n\tint i, rc, threads;\n\tpthread_t *tids;\n\n\tSKIP_IF(!have_hwcap(PPC_FEATURE_HAS_VSX));\n\n\tthreads = sysconf(_SC_NPROCESSORS_ONLN) * THREAD_FACTOR;\n\ttids = malloc(threads * sizeof(pthread_t));\n\tFAIL_IF(!tids);\n\n\trunning = true;\n\tthreads_starting = threads;\n\tfor (i = 0; i < threads; i++) {\n\t\trc = pthread_create(&tids[i], NULL, preempt_vsx_c, NULL);\n\t\tFAIL_IF(rc);\n\t}\n\n\tsetbuf(stdout, NULL);\n\t \n\tprintf(\"\\tWaiting for %d workers to start...\", threads_starting);\n\twhile(threads_starting)\n\t\tasm volatile(\"\": : :\"memory\");\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tWaiting for %d seconds to let some workers get preempted...\", PREEMPT_TIME);\n\tsleep(PREEMPT_TIME);\n\tprintf(\"done\\n\");\n\n\tprintf(\"\\tStopping workers...\");\n\t \n\trunning = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\tvoid *rc_p;\n\t\tpthread_join(tids[i], &rc_p);\n\n\t\t \n\t\tif ((long) rc_p)\n\t\t\tprintf(\"oops\\n\");\n\t\tFAIL_IF((long) rc_p);\n\t}\n\tprintf(\"done\\n\");\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\treturn test_harness(test_preempt_vsx, \"vsx_preempt\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}