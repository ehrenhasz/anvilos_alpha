{
  "module_name": "instruction_count_test.c",
  "hash_id": "12739267a084a0038b0c1139b5e4b29905a8041049445dfc2c42a168770ca82a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/ebb/instruction_count_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/prctl.h>\n\n#include \"ebb.h\"\n\n\n \n\nextern void thirty_two_instruction_loop(uint64_t loops);\n\nstatic bool counters_frozen = true;\n\nstatic int do_count_loop(struct event *event, uint64_t instructions,\n\t\t\t uint64_t overhead, bool report)\n{\n\tint64_t difference, expected;\n\tdouble percentage;\n\n\tclear_ebb_stats();\n\n\tcounters_frozen = false;\n\tmb();\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_FC);\n\n\tthirty_two_instruction_loop(instructions >> 5);\n\n\tcounters_frozen = true;\n\tmb();\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\n\tcount_pmc(4, sample_period);\n\n\tevent->result.value = ebb_state.stats.pmc_count[4-1];\n\texpected = instructions + overhead;\n\tdifference = event->result.value - expected;\n\tpercentage = (double)difference / event->result.value * 100;\n\n\tif (report) {\n\t\tprintf(\"Looped for %lu instructions, overhead %lu\\n\", instructions, overhead);\n\t\tprintf(\"Expected %lu\\n\", expected);\n\t\tprintf(\"Actual   %llu\\n\", event->result.value);\n\t\tprintf(\"Delta    %ld, %f%%\\n\", difference, percentage);\n\t\tprintf(\"Took %d EBBs\\n\", ebb_state.stats.ebb_count);\n\t}\n\n\tif (difference < 0)\n\t\tdifference = -difference;\n\n\t \n\tdifference *= 10000 * 100;\n\tif (difference / event->result.value)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic uint64_t determine_overhead(struct event *event)\n{\n\tuint64_t current, overhead;\n\tint i;\n\n\tdo_count_loop(event, 0, 0, false);\n\toverhead = event->result.value;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdo_count_loop(event, 0, 0, false);\n\t\tcurrent = event->result.value;\n\t\tif (current < overhead) {\n\t\t\tprintf(\"Replacing overhead %lu with %lu\\n\", overhead, current);\n\t\t\toverhead = current;\n\t\t}\n\t}\n\n\treturn overhead;\n}\n\nstatic void pmc4_ebb_callee(void)\n{\n\tuint64_t val;\n\n\tval = mfspr(SPRN_BESCR);\n\tif (!(val & BESCR_PMEO)) {\n\t\tebb_state.stats.spurious++;\n\t\tgoto out;\n\t}\n\n\tebb_state.stats.ebb_count++;\n\tcount_pmc(4, sample_period);\nout:\n\tif (counters_frozen)\n\t\treset_ebb_with_clear_mask(MMCR0_PMAO);\n\telse\n\t\treset_ebb();\n}\n\nint instruction_count(void)\n{\n\tstruct event event;\n\tuint64_t overhead;\n\n\tSKIP_IF(!ebb_is_supported());\n\n\tevent_init_named(&event, 0x400FA, \"PM_RUN_INST_CMPL\");\n\tevent_leader_ebb_init(&event);\n\tevent.attr.exclude_kernel = 1;\n\tevent.attr.exclude_hv = 1;\n\tevent.attr.exclude_idle = 1;\n\n\tFAIL_IF(event_open(&event));\n\tFAIL_IF(ebb_event_enable(&event));\n\n\tsample_period = COUNTER_OVERFLOW;\n\n\tsetup_ebb_handler(pmc4_ebb_callee);\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_FC);\n\tebb_global_enable();\n\n\toverhead = determine_overhead(&event);\n\tprintf(\"Overhead of null loop: %lu instructions\\n\", overhead);\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x100000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0xa00000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x6400000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x40000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x400000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x1000000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(&event, 0x2000000000, overhead, true));\n\n\tebb_global_disable();\n\tevent_close(&event);\n\n\tprintf(\"Finished OK\\n\");\n\n\treturn 0;\n}\n\nint main(void)\n{\n\ttest_harness_set_timeout(300);\n\treturn test_harness(instruction_count, \"instruction_count\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}