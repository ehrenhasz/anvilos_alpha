{
  "module_name": "ebb.c",
  "hash_id": "9ec0d6e0d9905f755ba423a57ead0939e50f8d541c0ed7aa644025cb03a6303d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/ebb/ebb.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\t \n\n#include <sched.h>\n#include <sys/wait.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"trace.h\"\n#include \"ebb.h\"\n\n\nvoid (*ebb_user_func)(void);\n\nvoid ebb_hook(void)\n{\n\tif (ebb_user_func)\n\t\tebb_user_func();\n}\n\nstruct ebb_state ebb_state;\n\nu64 sample_period = 0x40000000ull;\n\nvoid reset_ebb_with_clear_mask(unsigned long mmcr0_clear_mask)\n{\n\tu64 val;\n\n\t \n\t \n\tval = mfspr(SPRN_MMCR0);\n\tmtspr(SPRN_MMCR0, (val & ~mmcr0_clear_mask) | MMCR0_PMAE);\n\n\t \n\tmtspr(SPRN_BESCRR, BESCR_PMEO);\n\n\t \n\tmtspr(SPRN_BESCRS, BESCR_PME);\n\n\t \n}\n\nvoid reset_ebb(void)\n{\n\treset_ebb_with_clear_mask(MMCR0_PMAO | MMCR0_FC);\n}\n\n \nint ebb_check_mmcr0(void)\n{\n\tu64 val;\n\n\tval = mfspr(SPRN_MMCR0);\n\tif ((val & (MMCR0_FC | MMCR0_PMAO)) == MMCR0_FC) {\n\t\t \n\t\tprintf(\"Outside of loop, only FC set 0x%llx\\n\", val);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nbool ebb_check_count(int pmc, u64 sample_period, int fudge)\n{\n\tu64 count, upper, lower;\n\n\tcount = ebb_state.stats.pmc_count[PMC_INDEX(pmc)];\n\n\tlower = ebb_state.stats.ebb_count * (sample_period - fudge);\n\n\tif (count < lower) {\n\t\tprintf(\"PMC%d count (0x%llx) below lower limit 0x%llx (-0x%llx)\\n\",\n\t\t\tpmc, count, lower, lower - count);\n\t\treturn false;\n\t}\n\n\tupper = ebb_state.stats.ebb_count * (sample_period + fudge);\n\n\tif (count > upper) {\n\t\tprintf(\"PMC%d count (0x%llx) above upper limit 0x%llx (+0x%llx)\\n\",\n\t\t\tpmc, count, upper, count - upper);\n\t\treturn false;\n\t}\n\n\tprintf(\"PMC%d count (0x%llx) is between 0x%llx and 0x%llx delta +0x%llx/-0x%llx\\n\",\n\t\tpmc, count, lower, upper, count - lower, upper - count);\n\n\treturn true;\n}\n\nvoid standard_ebb_callee(void)\n{\n\tint found, i;\n\tu64 val;\n\n\tval = mfspr(SPRN_BESCR);\n\tif (!(val & BESCR_PMEO)) {\n\t\tebb_state.stats.spurious++;\n\t\tgoto out;\n\t}\n\n\tebb_state.stats.ebb_count++;\n\ttrace_log_counter(ebb_state.trace, ebb_state.stats.ebb_count);\n\n\tval = mfspr(SPRN_MMCR0);\n\ttrace_log_reg(ebb_state.trace, SPRN_MMCR0, val);\n\n\tfound = 0;\n\tfor (i = 1; i <= 6; i++) {\n\t\tif (ebb_state.pmc_enable[PMC_INDEX(i)])\n\t\t\tfound += count_pmc(i, sample_period);\n\t}\n\n\tif (!found)\n\t\tebb_state.stats.no_overflow++;\n\nout:\n\treset_ebb();\n}\n\nextern void ebb_handler(void);\n\nvoid setup_ebb_handler(void (*callee)(void))\n{\n\tu64 entry;\n\n#if defined(_CALL_ELF) && _CALL_ELF == 2\n\tentry = (u64)ebb_handler;\n#else\n\tstruct opd\n\t{\n\t    u64 entry;\n\t    u64 toc;\n\t} *opd;\n\n\topd = (struct opd *)ebb_handler;\n\tentry = opd->entry;\n#endif\n\tprintf(\"EBB Handler is at %#llx\\n\", entry);\n\n\tebb_user_func = callee;\n\n\t \n\tmb();\n\tmtspr(SPRN_EBBHR, entry);\n\n\t \n\tmb();\n}\n\nvoid clear_ebb_stats(void)\n{\n\tmemset(&ebb_state.stats, 0, sizeof(ebb_state.stats));\n}\n\nvoid dump_summary_ebb_state(void)\n{\n\tprintf(\"ebb_state:\\n\"\t\t\t\\\n\t       \"  ebb_count    = %d\\n\"\t\t\\\n\t       \"  spurious     = %d\\n\"\t\t\\\n\t       \"  negative     = %d\\n\"\t\t\\\n\t       \"  no_overflow  = %d\\n\"\t\t\\\n\t       \"  pmc[1] count = 0x%llx\\n\"\t\\\n\t       \"  pmc[2] count = 0x%llx\\n\"\t\\\n\t       \"  pmc[3] count = 0x%llx\\n\"\t\\\n\t       \"  pmc[4] count = 0x%llx\\n\"\t\\\n\t       \"  pmc[5] count = 0x%llx\\n\"\t\\\n\t       \"  pmc[6] count = 0x%llx\\n\",\n\t\tebb_state.stats.ebb_count, ebb_state.stats.spurious,\n\t\tebb_state.stats.negative, ebb_state.stats.no_overflow,\n\t\tebb_state.stats.pmc_count[0], ebb_state.stats.pmc_count[1],\n\t\tebb_state.stats.pmc_count[2], ebb_state.stats.pmc_count[3],\n\t\tebb_state.stats.pmc_count[4], ebb_state.stats.pmc_count[5]);\n}\n\nstatic char *decode_mmcr0(u32 value)\n{\n\tstatic char buf[16];\n\n\tbuf[0] = '\\0';\n\n\tif (value & (1 << 31))\n\t\tstrcat(buf, \"FC \");\n\tif (value & (1 << 26))\n\t\tstrcat(buf, \"PMAE \");\n\tif (value & (1 << 7))\n\t\tstrcat(buf, \"PMAO \");\n\n\treturn buf;\n}\n\nstatic char *decode_bescr(u64 value)\n{\n\tstatic char buf[16];\n\n\tbuf[0] = '\\0';\n\n\tif (value & (1ull << 63))\n\t\tstrcat(buf, \"GE \");\n\tif (value & (1ull << 32))\n\t\tstrcat(buf, \"PMAE \");\n\tif (value & 1)\n\t\tstrcat(buf, \"PMAO \");\n\n\treturn buf;\n}\n\nvoid dump_ebb_hw_state(void)\n{\n\tu64 bescr;\n\tu32 mmcr0;\n\n\tmmcr0 = mfspr(SPRN_MMCR0);\n\tbescr = mfspr(SPRN_BESCR);\n\n\tprintf(\"HW state:\\n\"\t\t\\\n\t       \"MMCR0 0x%016x %s\\n\"\t\\\n\t       \"MMCR2 0x%016lx\\n\"\t\\\n\t       \"EBBHR 0x%016lx\\n\"\t\\\n\t       \"BESCR 0x%016llx %s\\n\"\t\\\n\t       \"PMC1  0x%016lx\\n\"\t\\\n\t       \"PMC2  0x%016lx\\n\"\t\\\n\t       \"PMC3  0x%016lx\\n\"\t\\\n\t       \"PMC4  0x%016lx\\n\"\t\\\n\t       \"PMC5  0x%016lx\\n\"\t\\\n\t       \"PMC6  0x%016lx\\n\"\t\\\n\t       \"SIAR  0x%016lx\\n\",\n\t       mmcr0, decode_mmcr0(mmcr0), mfspr(SPRN_MMCR2),\n\t       mfspr(SPRN_EBBHR), bescr, decode_bescr(bescr),\n\t       mfspr(SPRN_PMC1), mfspr(SPRN_PMC2), mfspr(SPRN_PMC3),\n\t       mfspr(SPRN_PMC4), mfspr(SPRN_PMC5), mfspr(SPRN_PMC6),\n\t       mfspr(SPRN_SIAR));\n}\n\nvoid dump_ebb_state(void)\n{\n\tdump_summary_ebb_state();\n\n\tdump_ebb_hw_state();\n\n\ttrace_buffer_print(ebb_state.trace);\n}\n\nint count_pmc(int pmc, uint32_t sample_period)\n{\n\tuint32_t start_value;\n\tu64 val;\n\n\t \n\tstart_value = pmc_sample_period(sample_period);\n\n\tval = read_pmc(pmc);\n\tif (val < start_value)\n\t\tebb_state.stats.negative++;\n\telse\n\t\tebb_state.stats.pmc_count[PMC_INDEX(pmc)] += val - start_value;\n\n\ttrace_log_reg(ebb_state.trace, SPRN_PMC1 + pmc - 1, val);\n\n\t \n\twrite_pmc(pmc, start_value);\n\n\t \n\treturn val >= COUNTER_OVERFLOW;\n}\n\nint ebb_event_enable(struct event *e)\n{\n\tint rc;\n\n\t \n\tmb();\n\n\trc = ioctl(e->fd, PERF_EVENT_IOC_ENABLE);\n\tif (rc)\n\t\treturn rc;\n\n\trc = event_read(e);\n\n\t \n\tmb();\n\n\treturn rc;\n}\n\nvoid ebb_freeze_pmcs(void)\n{\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\tmb();\n}\n\nvoid ebb_unfreeze_pmcs(void)\n{\n\t \n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_FC);\n\tmb();\n}\n\nvoid ebb_global_enable(void)\n{\n\t \n\tmtspr(SPRN_BESCR, 0x8000000100000000ull);\n\tmb();\n}\n\nvoid ebb_global_disable(void)\n{\n\t \n\tmtspr(SPRN_BESCRR, BESCR_PME);\n\tmb();\n}\n\nbool ebb_is_supported(void)\n{\n#ifdef PPC_FEATURE2_EBB\n\t \n\treturn have_hwcap2(PPC_FEATURE2_EBB);\n#else\n\treturn false;\n#endif\n}\n\nvoid event_ebb_init(struct event *e)\n{\n\te->attr.config |= (1ull << 63);\n}\n\nvoid event_bhrb_init(struct event *e, unsigned ifm)\n{\n\te->attr.config |= (1ull << 62) | ((u64)ifm << 60);\n}\n\nvoid event_leader_ebb_init(struct event *e)\n{\n\tevent_ebb_init(e);\n\n\te->attr.exclusive = 1;\n\te->attr.pinned = 1;\n}\n\nint ebb_child(union pipe read_pipe, union pipe write_pipe)\n{\n\tstruct event event;\n\tuint64_t val;\n\n\tFAIL_IF(wait_for_parent(read_pipe));\n\n\tevent_init_named(&event, 0x1001e, \"cycles\");\n\tevent_leader_ebb_init(&event);\n\n\tevent.attr.exclude_kernel = 1;\n\tevent.attr.exclude_hv = 1;\n\tevent.attr.exclude_idle = 1;\n\n\tFAIL_IF(event_open(&event));\n\n\tebb_enable_pmc_counting(1);\n\tsetup_ebb_handler(standard_ebb_callee);\n\tebb_global_enable();\n\n\tFAIL_IF(event_enable(&event));\n\n\tif (event_read(&event)) {\n\t\t \n\t\tnotify_parent_of_error(write_pipe);\n\t\treturn 2;\n\t}\n\n\tmtspr(SPRN_PMC1, pmc_sample_period(sample_period));\n\n\tFAIL_IF(notify_parent(write_pipe));\n\tFAIL_IF(wait_for_parent(read_pipe));\n\tFAIL_IF(notify_parent(write_pipe));\n\n\twhile (ebb_state.stats.ebb_count < 20) {\n\t\tFAIL_IF(core_busy_loop());\n\n\t\t \n\t\tval  = mfspr(SPRN_MMCRA);\n\t\tval |= mfspr(SPRN_MMCR2);\n\t\tval |= mfspr(SPRN_MMCR0);\n\t}\n\n\tebb_global_disable();\n\tebb_freeze_pmcs();\n\n\tdump_ebb_state();\n\n\tevent_close(&event);\n\n\tFAIL_IF(ebb_state.stats.ebb_count == 0);\n\n\treturn 0;\n}\n\nstatic jmp_buf setjmp_env;\n\nstatic void sigill_handler(int signal)\n{\n\tprintf(\"Took sigill\\n\");\n\tlongjmp(setjmp_env, 1);\n}\n\nstatic struct sigaction sigill_action = {\n\t.sa_handler = sigill_handler,\n};\n\nint catch_sigill(void (*func)(void))\n{\n\tif (sigaction(SIGILL, &sigill_action, NULL)) {\n\t\tperror(\"sigaction\");\n\t\treturn 1;\n\t}\n\n\tif (setjmp(setjmp_env) == 0) {\n\t\tfunc();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid write_pmc1(void)\n{\n\tmtspr(SPRN_PMC1, 0);\n}\n\nvoid write_pmc(int pmc, u64 value)\n{\n\tswitch (pmc) {\n\t\tcase 1: mtspr(SPRN_PMC1, value); break;\n\t\tcase 2: mtspr(SPRN_PMC2, value); break;\n\t\tcase 3: mtspr(SPRN_PMC3, value); break;\n\t\tcase 4: mtspr(SPRN_PMC4, value); break;\n\t\tcase 5: mtspr(SPRN_PMC5, value); break;\n\t\tcase 6: mtspr(SPRN_PMC6, value); break;\n\t}\n}\n\nu64 read_pmc(int pmc)\n{\n\tswitch (pmc) {\n\t\tcase 1: return mfspr(SPRN_PMC1);\n\t\tcase 2: return mfspr(SPRN_PMC2);\n\t\tcase 3: return mfspr(SPRN_PMC3);\n\t\tcase 4: return mfspr(SPRN_PMC4);\n\t\tcase 5: return mfspr(SPRN_PMC5);\n\t\tcase 6: return mfspr(SPRN_PMC6);\n\t}\n\n\treturn 0;\n}\n\nstatic void term_handler(int signal)\n{\n\tdump_summary_ebb_state();\n\tdump_ebb_hw_state();\n\tabort();\n}\n\nstruct sigaction term_action = {\n\t.sa_handler = term_handler,\n};\n\nstatic void __attribute__((constructor)) ebb_init(void)\n{\n\tclear_ebb_stats();\n\n\tif (sigaction(SIGTERM, &term_action, NULL))\n\t\tperror(\"sigaction\");\n\n\tebb_state.trace = trace_buffer_allocate(1 * 1024 * 1024);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}