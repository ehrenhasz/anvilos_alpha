{
  "module_name": "trace.c",
  "hash_id": "8d383f8971adfa0fbe5771d96c760816e2f72f1411b6a8dd6b9a207caa4b7aba",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/ebb/trace.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n\n#include \"trace.h\"\n\n\nstruct trace_buffer *trace_buffer_allocate(u64 size)\n{\n\tstruct trace_buffer *tb;\n\n\tif (size < sizeof(*tb)) {\n\t\tfprintf(stderr, \"Error: trace buffer too small\\n\");\n\t\treturn NULL;\n\t}\n\n\ttb = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (tb == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\treturn NULL;\n\t}\n\n\ttb->size = size;\n\ttb->tail = tb->data;\n\ttb->overflow = false;\n\n\treturn tb;\n}\n\nstatic bool trace_check_bounds(struct trace_buffer *tb, void *p)\n{\n\treturn p < ((void *)tb + tb->size);\n}\n\nstatic bool trace_check_alloc(struct trace_buffer *tb, void *p)\n{\n\t \n\tif (tb->overflow)\n\t\treturn false;\n\n\tif (!trace_check_bounds(tb, p)) {\n\t\ttb->overflow = true;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void *trace_alloc(struct trace_buffer *tb, int bytes)\n{\n\tvoid *p, *newtail;\n\n\tp = tb->tail;\n\tnewtail = tb->tail + bytes;\n\tif (!trace_check_alloc(tb, newtail))\n\t\treturn NULL;\n\n\ttb->tail = newtail;\n\n\treturn p;\n}\n\nstatic struct trace_entry *trace_alloc_entry(struct trace_buffer *tb, int payload_size)\n{\n\tstruct trace_entry *e;\n\n\te = trace_alloc(tb, sizeof(*e) + payload_size);\n\tif (e)\n\t\te->length = payload_size;\n\n\treturn e;\n}\n\nint trace_log_reg(struct trace_buffer *tb, u64 reg, u64 value)\n{\n\tstruct trace_entry *e;\n\tu64 *p;\n\n\te = trace_alloc_entry(tb, sizeof(reg) + sizeof(value));\n\tif (!e)\n\t\treturn -ENOSPC;\n\n\te->type = TRACE_TYPE_REG;\n\tp = (u64 *)e->data;\n\t*p++ = reg;\n\t*p++ = value;\n\n\treturn 0;\n}\n\nint trace_log_counter(struct trace_buffer *tb, u64 value)\n{\n\tstruct trace_entry *e;\n\tu64 *p;\n\n\te = trace_alloc_entry(tb, sizeof(value));\n\tif (!e)\n\t\treturn -ENOSPC;\n\n\te->type = TRACE_TYPE_COUNTER;\n\tp = (u64 *)e->data;\n\t*p++ = value;\n\n\treturn 0;\n}\n\nint trace_log_string(struct trace_buffer *tb, char *str)\n{\n\tstruct trace_entry *e;\n\tchar *p;\n\tint len;\n\n\tlen = strlen(str);\n\n\t \n\te = trace_alloc_entry(tb, len + 1);\n\tif (!e)\n\t\treturn -ENOSPC;\n\n\te->type = TRACE_TYPE_STRING;\n\tp = (char *)e->data;\n\tmemcpy(p, str, len);\n\tp += len;\n\t*p = '\\0';\n\n\treturn 0;\n}\n\nint trace_log_indent(struct trace_buffer *tb)\n{\n\tstruct trace_entry *e;\n\n\te = trace_alloc_entry(tb, 0);\n\tif (!e)\n\t\treturn -ENOSPC;\n\n\te->type = TRACE_TYPE_INDENT;\n\n\treturn 0;\n}\n\nint trace_log_outdent(struct trace_buffer *tb)\n{\n\tstruct trace_entry *e;\n\n\te = trace_alloc_entry(tb, 0);\n\tif (!e)\n\t\treturn -ENOSPC;\n\n\te->type = TRACE_TYPE_OUTDENT;\n\n\treturn 0;\n}\n\nstatic void trace_print_header(int seq, int prefix)\n{\n\tprintf(\"%*s[%d]: \", prefix, \"\", seq);\n}\n\nstatic char *trace_decode_reg(int reg)\n{\n\tswitch (reg) {\n\t\tcase 769: return \"SPRN_MMCR2\"; break;\n\t\tcase 770: return \"SPRN_MMCRA\"; break;\n\t\tcase 779: return \"SPRN_MMCR0\"; break;\n\t\tcase 804: return \"SPRN_EBBHR\"; break;\n\t\tcase 805: return \"SPRN_EBBRR\"; break;\n\t\tcase 806: return \"SPRN_BESCR\"; break;\n\t\tcase 800: return \"SPRN_BESCRS\"; break;\n\t\tcase 801: return \"SPRN_BESCRSU\"; break;\n\t\tcase 802: return \"SPRN_BESCRR\"; break;\n\t\tcase 803: return \"SPRN_BESCRRU\"; break;\n\t\tcase 771: return \"SPRN_PMC1\"; break;\n\t\tcase 772: return \"SPRN_PMC2\"; break;\n\t\tcase 773: return \"SPRN_PMC3\"; break;\n\t\tcase 774: return \"SPRN_PMC4\"; break;\n\t\tcase 775: return \"SPRN_PMC5\"; break;\n\t\tcase 776: return \"SPRN_PMC6\"; break;\n\t\tcase 780: return \"SPRN_SIAR\"; break;\n\t\tcase 781: return \"SPRN_SDAR\"; break;\n\t\tcase 768: return \"SPRN_SIER\"; break;\n\t}\n\n\treturn NULL;\n}\n\nstatic void trace_print_reg(struct trace_entry *e)\n{\n\tu64 *p, *reg, *value;\n\tchar *name;\n\n\tp = (u64 *)e->data;\n\treg = p++;\n\tvalue = p;\n\n\tname = trace_decode_reg(*reg);\n\tif (name)\n\t\tprintf(\"register %-10s = 0x%016llx\\n\", name, *value);\n\telse\n\t\tprintf(\"register %lld = 0x%016llx\\n\", *reg, *value);\n}\n\nstatic void trace_print_counter(struct trace_entry *e)\n{\n\tu64 *value;\n\n\tvalue = (u64 *)e->data;\n\tprintf(\"counter = %lld\\n\", *value);\n}\n\nstatic void trace_print_string(struct trace_entry *e)\n{\n\tchar *str;\n\n\tstr = (char *)e->data;\n\tputs(str);\n}\n\n#define BASE_PREFIX\t2\n#define PREFIX_DELTA\t8\n\nstatic void trace_print_entry(struct trace_entry *e, int seq, int *prefix)\n{\n\tswitch (e->type) {\n\tcase TRACE_TYPE_REG:\n\t\ttrace_print_header(seq, *prefix);\n\t\ttrace_print_reg(e);\n\t\tbreak;\n\tcase TRACE_TYPE_COUNTER:\n\t\ttrace_print_header(seq, *prefix);\n\t\ttrace_print_counter(e);\n\t\tbreak;\n\tcase TRACE_TYPE_STRING:\n\t\ttrace_print_header(seq, *prefix);\n\t\ttrace_print_string(e);\n\t\tbreak;\n\tcase TRACE_TYPE_INDENT:\n\t\ttrace_print_header(seq, *prefix);\n\t\tputs(\"{\");\n\t\t*prefix += PREFIX_DELTA;\n\t\tbreak;\n\tcase TRACE_TYPE_OUTDENT:\n\t\t*prefix -= PREFIX_DELTA;\n\t\tif (*prefix < BASE_PREFIX)\n\t\t\t*prefix = BASE_PREFIX;\n\t\ttrace_print_header(seq, *prefix);\n\t\tputs(\"}\");\n\t\tbreak;\n\tdefault:\n\t\ttrace_print_header(seq, *prefix);\n\t\tprintf(\"entry @ %p type %d\\n\", e, e->type);\n\t\tbreak;\n\t}\n}\n\nvoid trace_buffer_print(struct trace_buffer *tb)\n{\n\tstruct trace_entry *e;\n\tint i, prefix;\n\tvoid *p;\n\n\tprintf(\"Trace buffer dump:\\n\");\n\tprintf(\"  address  %p \\n\", tb);\n\tprintf(\"  tail     %p\\n\", tb->tail);\n\tprintf(\"  size     %llu\\n\", tb->size);\n\tprintf(\"  overflow %s\\n\", tb->overflow ? \"TRUE\" : \"false\");\n\tprintf(\"  Content:\\n\");\n\n\tp = tb->data;\n\n\ti = 0;\n\tprefix = BASE_PREFIX;\n\n\twhile (trace_check_bounds(tb, p) && p < tb->tail) {\n\t\te = p;\n\n\t\ttrace_print_entry(e, i, &prefix);\n\n\t\ti++;\n\t\tp = (void *)e + sizeof(*e) + e->length;\n\t}\n}\n\nvoid trace_print_location(struct trace_buffer *tb)\n{\n\tprintf(\"Trace buffer 0x%llx bytes @ %p\\n\", tb->size, tb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}