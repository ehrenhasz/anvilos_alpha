{
  "module_name": "event.c",
  "hash_id": "4a2e3883a9547943a4df032e3a22c666134ac1a3ce9f9f2259831010e2015199",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/event.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <sys/ioctl.h>\n\n#include \"event.h\"\n\n\nint perf_event_open(struct perf_event_attr *attr, pid_t pid, int cpu,\n\t\tint group_fd, unsigned long flags)\n{\n\treturn syscall(__NR_perf_event_open, attr, pid, cpu,\n\t\t\t   group_fd, flags);\n}\n\nstatic void  __event_init_opts(struct event *e, u64 config,\n\t\t\t       int type, char *name, bool sampling)\n{\n\tmemset(e, 0, sizeof(*e));\n\n\te->name = name;\n\n\te->attr.type = type;\n\te->attr.config = config;\n\te->attr.size = sizeof(e->attr);\n\t \n\te->attr.read_format = PERF_FORMAT_TOTAL_TIME_ENABLED | \\\n\t\t\t\t  PERF_FORMAT_TOTAL_TIME_RUNNING;\n\tif (sampling) {\n\t\te->attr.sample_period = 1000;\n\t\te->attr.sample_type = PERF_SAMPLE_REGS_INTR;\n\t\te->attr.disabled = 1;\n\t}\n}\n\nvoid event_init_opts(struct event *e, u64 config, int type, char *name)\n{\n\t__event_init_opts(e, config, type, name, false);\n}\n\nvoid event_init_named(struct event *e, u64 config, char *name)\n{\n\tevent_init_opts(e, config, PERF_TYPE_RAW, name);\n}\n\nvoid event_init(struct event *e, u64 config)\n{\n\tevent_init_opts(e, config, PERF_TYPE_RAW, \"event\");\n}\n\nvoid event_init_sampling(struct event *e, u64 config)\n{\n\t__event_init_opts(e, config, PERF_TYPE_RAW, \"event\", true);\n}\n\n#define PERF_CURRENT_PID\t0\n#define PERF_NO_PID\t\t-1\n#define PERF_NO_CPU\t\t-1\n#define PERF_NO_GROUP\t\t-1\n\nint event_open_with_options(struct event *e, pid_t pid, int cpu, int group_fd)\n{\n\te->fd = perf_event_open(&e->attr, pid, cpu, group_fd, 0);\n\tif (e->fd == -1) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint event_open_with_group(struct event *e, int group_fd)\n{\n\treturn event_open_with_options(e, PERF_CURRENT_PID, PERF_NO_CPU, group_fd);\n}\n\nint event_open_with_pid(struct event *e, pid_t pid)\n{\n\treturn event_open_with_options(e, pid, PERF_NO_CPU, PERF_NO_GROUP);\n}\n\nint event_open_with_cpu(struct event *e, int cpu)\n{\n\treturn event_open_with_options(e, PERF_NO_PID, cpu, PERF_NO_GROUP);\n}\n\nint event_open(struct event *e)\n{\n\treturn event_open_with_options(e, PERF_CURRENT_PID, PERF_NO_CPU, PERF_NO_GROUP);\n}\n\nvoid event_close(struct event *e)\n{\n\tclose(e->fd);\n}\n\nint event_enable(struct event *e)\n{\n\treturn ioctl(e->fd, PERF_EVENT_IOC_ENABLE);\n}\n\nint event_disable(struct event *e)\n{\n\treturn ioctl(e->fd, PERF_EVENT_IOC_DISABLE);\n}\n\nint event_reset(struct event *e)\n{\n\treturn ioctl(e->fd, PERF_EVENT_IOC_RESET);\n}\n\nint event_read(struct event *e)\n{\n\tint rc;\n\n\trc = read(e->fd, &e->result, sizeof(e->result));\n\tif (rc != sizeof(e->result)) {\n\t\tfprintf(stderr, \"read error on event %p!\\n\", e);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid event_report_justified(struct event *e, int name_width, int result_width)\n{\n\tprintf(\"%*s: result %*llu \", name_width, e->name, result_width,\n\t       e->result.value);\n\n\tif (e->result.running == e->result.enabled)\n\t\tprintf(\"running/enabled %llu\\n\", e->result.running);\n\telse\n\t\tprintf(\"running %llu enabled %llu\\n\", e->result.running,\n\t\t\te->result.enabled);\n}\n\nvoid event_report(struct event *e)\n{\n\tevent_report_justified(e, 0, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}