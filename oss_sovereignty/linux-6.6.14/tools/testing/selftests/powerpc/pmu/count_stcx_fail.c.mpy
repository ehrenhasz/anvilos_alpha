{
  "module_name": "count_stcx_fail.c",
  "hash_id": "ff05cabee484c3d930c29dde9862fd8417921e60dad293c325874fec11fa9cc9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/count_stcx_fail.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/prctl.h>\n\n#include \"event.h\"\n#include \"utils.h\"\n#include \"lib.h\"\n\nextern void thirty_two_instruction_loop_with_ll_sc(u64 loops, u64 *ll_sc_target);\n\nstatic void setup_event(struct event *e, u64 config, int type, char *name)\n{\n\tevent_init_opts(e, config, type, name);\n\n\te->attr.disabled = 1;\n\te->attr.exclude_kernel = 1;\n\te->attr.exclude_hv = 1;\n\te->attr.exclude_idle = 1;\n}\n\nstatic int do_count_loop(struct event *events, u64 instructions,\n\t\t\t u64 overhead, bool report)\n{\n\ts64 difference, expected;\n\tdouble percentage;\n\tu64 dummy;\n\n\tprctl(PR_TASK_PERF_EVENTS_ENABLE);\n\n\t \n\tthirty_two_instruction_loop_with_ll_sc(instructions >> 5, &dummy);\n\n\tprctl(PR_TASK_PERF_EVENTS_DISABLE);\n\n\tevent_read(&events[0]);\n\tevent_read(&events[1]);\n\tevent_read(&events[2]);\n\n\texpected = instructions + overhead + (events[2].result.value * 10);\n\tdifference = events[0].result.value - expected;\n\tpercentage = (double)difference / events[0].result.value * 100;\n\n\tif (report) {\n\t\tprintf(\"-----\\n\");\n\t\tevent_report(&events[0]);\n\t\tevent_report(&events[1]);\n\t\tevent_report(&events[2]);\n\n\t\tprintf(\"Looped for %llu instructions, overhead %llu\\n\", instructions, overhead);\n\t\tprintf(\"Expected %llu\\n\", expected);\n\t\tprintf(\"Actual   %llu\\n\", events[0].result.value);\n\t\tprintf(\"Delta    %lld, %f%%\\n\", difference, percentage);\n\t}\n\n\tevent_reset(&events[0]);\n\tevent_reset(&events[1]);\n\tevent_reset(&events[2]);\n\n\tif (difference < 0)\n\t\tdifference = -difference;\n\n\t \n\tdifference *= 10000 * 100;\n\tif (difference / events[0].result.value)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic u64 determine_overhead(struct event *events)\n{\n\tu64 current, overhead;\n\tint i;\n\n\tdo_count_loop(events, 0, 0, false);\n\toverhead = events[0].result.value;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdo_count_loop(events, 0, 0, false);\n\t\tcurrent = events[0].result.value;\n\t\tif (current < overhead) {\n\t\t\tprintf(\"Replacing overhead %llu with %llu\\n\", overhead, current);\n\t\t\toverhead = current;\n\t\t}\n\t}\n\n\treturn overhead;\n}\n\n#define\tPM_MRK_STCX_FAIL\t0x03e158\n#define PM_STCX_FAIL\t0x01e058\n\nstatic int test_body(void)\n{\n\tstruct event events[3];\n\tu64 overhead;\n\n\t\n\tSKIP_IF(!have_hwcap2(PPC_FEATURE2_ARCH_2_07));\n\n\tsetup_event(&events[0], PERF_COUNT_HW_INSTRUCTIONS, PERF_TYPE_HARDWARE, \"instructions\");\n\tsetup_event(&events[1], PERF_COUNT_HW_CPU_CYCLES, PERF_TYPE_HARDWARE, \"cycles\");\n\tsetup_event(&events[2], PM_STCX_FAIL, PERF_TYPE_RAW, \"stcx_fail\");\n\n\tif (event_open(&events[0])) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\tif (event_open_with_group(&events[1], events[0].fd)) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\tif (event_open_with_group(&events[2], events[0].fd)) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\toverhead = determine_overhead(events);\n\tprintf(\"Overhead of null loop: %llu instructions\\n\", overhead);\n\n\t \n\tFAIL_IF(do_count_loop(events, 1000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 10000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 100000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 1000000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 16000000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 64000000000, overhead, true));\n\n\tevent_close(&events[0]);\n\tevent_close(&events[1]);\n\n\treturn 0;\n}\n\nstatic int count_ll_sc(void)\n{\n\treturn eat_cpu(test_body);\n}\n\nint main(void)\n{\n\treturn test_harness(count_ll_sc, \"count_ll_sc\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}