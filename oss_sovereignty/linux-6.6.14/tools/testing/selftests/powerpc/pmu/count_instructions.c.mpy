{
  "module_name": "count_instructions.c",
  "hash_id": "68c106160b75b710ba488af0dee9109ba38c55dcec09c94d7d0fd592e4b0005b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/count_instructions.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/prctl.h>\n\n#include \"event.h\"\n#include \"utils.h\"\n#include \"lib.h\"\n\nextern void thirty_two_instruction_loop(u64 loops);\n\nstatic void setup_event(struct event *e, u64 config, char *name)\n{\n\tevent_init_opts(e, config, PERF_TYPE_HARDWARE, name);\n\n\te->attr.disabled = 1;\n\te->attr.exclude_kernel = 1;\n\te->attr.exclude_hv = 1;\n\te->attr.exclude_idle = 1;\n}\n\nstatic int do_count_loop(struct event *events, u64 instructions,\n\t\t\t u64 overhead, bool report)\n{\n\ts64 difference, expected;\n\tdouble percentage;\n\n\tprctl(PR_TASK_PERF_EVENTS_ENABLE);\n\n\t \n\tthirty_two_instruction_loop(instructions >> 5);\n\n\tprctl(PR_TASK_PERF_EVENTS_DISABLE);\n\n\tevent_read(&events[0]);\n\tevent_read(&events[1]);\n\n\texpected = instructions + overhead;\n\tdifference = events[0].result.value - expected;\n\tpercentage = (double)difference / events[0].result.value * 100;\n\n\tif (report) {\n\t\tevent_report(&events[0]);\n\t\tevent_report(&events[1]);\n\n\t\tprintf(\"Looped for %llu instructions, overhead %llu\\n\", instructions, overhead);\n\t\tprintf(\"Expected %llu\\n\", expected);\n\t\tprintf(\"Actual   %llu\\n\", events[0].result.value);\n\t\tprintf(\"Delta    %lld, %f%%\\n\", difference, percentage);\n\t}\n\n\tevent_reset(&events[0]);\n\tevent_reset(&events[1]);\n\n\tif (difference < 0)\n\t\tdifference = -difference;\n\n\t \n\tdifference *= 10000 * 100;\n\tif (difference / events[0].result.value)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic u64 determine_overhead(struct event *events)\n{\n\tu64 current, overhead;\n\tint i;\n\n\tdo_count_loop(events, 0, 0, false);\n\toverhead = events[0].result.value;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdo_count_loop(events, 0, 0, false);\n\t\tcurrent = events[0].result.value;\n\t\tif (current < overhead) {\n\t\t\tprintf(\"Replacing overhead %llu with %llu\\n\", overhead, current);\n\t\t\toverhead = current;\n\t\t}\n\t}\n\n\treturn overhead;\n}\n\nstatic int test_body(void)\n{\n\tstruct event events[2];\n\tu64 overhead;\n\n\tsetup_event(&events[0], PERF_COUNT_HW_INSTRUCTIONS, \"instructions\");\n\tsetup_event(&events[1], PERF_COUNT_HW_CPU_CYCLES, \"cycles\");\n\n\tif (event_open(&events[0])) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\tif (event_open_with_group(&events[1], events[0].fd)) {\n\t\tperror(\"perf_event_open\");\n\t\treturn -1;\n\t}\n\n\toverhead = determine_overhead(events);\n\tprintf(\"Overhead of null loop: %llu instructions\\n\", overhead);\n\n\t \n\tFAIL_IF(do_count_loop(events, 1000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 10000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 100000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 1000000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 16000000000, overhead, true));\n\n\t \n\tFAIL_IF(do_count_loop(events, 64000000000, overhead, true));\n\n\tevent_close(&events[0]);\n\tevent_close(&events[1]);\n\n\treturn 0;\n}\n\nstatic int count_instructions(void)\n{\n\treturn eat_cpu(test_body);\n}\n\nint main(void)\n{\n\treturn test_harness(count_instructions, \"count_instructions\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}