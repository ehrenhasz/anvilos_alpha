{
  "module_name": "misc.h",
  "hash_id": "322813b731b1c7d1b75d54db4c27be792bbca449b9b5dae8e46368228081b91b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/sampling_tests/misc.h",
  "human_readable_source": " \n \n\n#include <sys/stat.h>\n#include \"../event.h\"\n\n#define POWER10 0x80\n#define POWER9  0x4e\n#define PERF_POWER9_MASK        0x7f8ffffffffffff\n#define PERF_POWER10_MASK       0x7ffffffffffffff\n\n#define MMCR0_FC56      0x00000010UL  \n#define MMCR0_PMCCEXT   0x00000200UL  \n#define MMCR1_RSQ       0x200000000000ULL  \n#define BHRB_DISABLE    0x2000000000ULL  \n\nextern int ev_mask_pmcxsel, ev_shift_pmcxsel;\nextern int ev_mask_marked, ev_shift_marked;\nextern int ev_mask_comb, ev_shift_comb;\nextern int ev_mask_unit, ev_shift_unit;\nextern int ev_mask_pmc, ev_shift_pmc;\nextern int ev_mask_cache, ev_shift_cache;\nextern int ev_mask_sample, ev_shift_sample;\nextern int ev_mask_thd_sel, ev_shift_thd_sel;\nextern int ev_mask_thd_start, ev_shift_thd_start;\nextern int ev_mask_thd_stop, ev_shift_thd_stop;\nextern int ev_mask_thd_cmp, ev_shift_thd_cmp;\nextern int ev_mask_sm, ev_shift_sm;\nextern int ev_mask_rsq, ev_shift_rsq;\nextern int ev_mask_l2l3, ev_shift_l2l3;\nextern int ev_mask_mmcr3_src, ev_shift_mmcr3_src;\nextern int pvr;\nextern u64 platform_extended_mask;\nextern int check_pvr_for_sampling_tests(void);\nextern int platform_check_for_tests(void);\n\n \n#define EV_CODE_EXTRACT(x, y)   \\\n\t((x >> ev_shift_##y) & ev_mask_##y)\n\nvoid *event_sample_buf_mmap(int fd, int mmap_pages);\nvoid *__event_read_samples(void *sample_buff, size_t *size, u64 *sample_count);\nint collect_samples(void *sample_buff);\nu64 *get_intr_regs(struct event *event, void *sample_buff);\nu64 get_reg_value(u64 *intr_regs, char *register_name);\nint get_thresh_cmp_val(struct event event);\nbool check_for_generic_compat_pmu(void);\nbool check_for_compat_mode(void);\n\nstatic inline int get_mmcr0_fc56(u64 mmcr0, int pmc)\n{\n\treturn (mmcr0 & MMCR0_FC56);\n}\n\nstatic inline int get_mmcr0_pmccext(u64 mmcr0, int pmc)\n{\n\treturn (mmcr0 & MMCR0_PMCCEXT);\n}\n\nstatic inline int get_mmcr0_pmao(u64 mmcr0, int pmc)\n{\n\treturn ((mmcr0 >> 7) & 0x1);\n}\n\nstatic inline int get_mmcr0_cc56run(u64 mmcr0, int pmc)\n{\n\treturn ((mmcr0 >> 8) & 0x1);\n}\n\nstatic inline int get_mmcr0_pmcjce(u64 mmcr0, int pmc)\n{\n\treturn ((mmcr0 >> 14) & 0x1);\n}\n\nstatic inline int get_mmcr0_pmc1ce(u64 mmcr0, int pmc)\n{\n\treturn ((mmcr0 >> 15) & 0x1);\n}\n\nstatic inline int get_mmcr0_pmae(u64 mmcr0, int pmc)\n{\n\treturn ((mmcr0 >> 27) & 0x1);\n}\n\nstatic inline int get_mmcr1_pmcxsel(u64 mmcr1, int pmc)\n{\n\treturn ((mmcr1 >> ((24 - (((pmc) - 1) * 8))) & 0xff));\n}\n\nstatic inline int get_mmcr1_unit(u64 mmcr1, int pmc)\n{\n\treturn ((mmcr1 >> ((60 - (4 * ((pmc) - 1))))) & 0xf);\n}\n\nstatic inline int get_mmcr1_comb(u64 mmcr1, int pmc)\n{\n\treturn ((mmcr1 >> (38 - ((pmc - 1) * 2))) & 0x3);\n}\n\nstatic inline int get_mmcr1_cache(u64 mmcr1, int pmc)\n{\n\treturn ((mmcr1 >> 46) & 0x3);\n}\n\nstatic inline int get_mmcr1_rsq(u64 mmcr1, int pmc)\n{\n\treturn mmcr1 & MMCR1_RSQ;\n}\n\nstatic inline int get_mmcr2_fcs(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (63 - (((pmc) - 1) * 9)))) >> (63 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcp(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (62 - (((pmc) - 1) * 9)))) >> (62 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcpc(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (61 - (((pmc) - 1) * 9)))) >> (61 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcm1(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (60 - (((pmc) - 1) * 9)))) >> (60 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcm0(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (59 - (((pmc) - 1) * 9)))) >> (59 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcwait(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (58 - (((pmc) - 1) * 9)))) >> (58 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fch(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (57 - (((pmc) - 1) * 9)))) >> (57 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcti(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (56 - (((pmc) - 1) * 9)))) >> (56 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_fcta(u64 mmcr2, int pmc)\n{\n\treturn ((mmcr2 & (1ull << (55 - (((pmc) - 1) * 9)))) >> (55 - (((pmc) - 1) * 9)));\n}\n\nstatic inline int get_mmcr2_l2l3(u64 mmcr2, int pmc)\n{\n\tif (pvr == POWER10)\n\t\treturn ((mmcr2 & 0xf8) >> 3);\n\treturn 0;\n}\n\nstatic inline int get_mmcr3_src(u64 mmcr3, int pmc)\n{\n\tif (pvr != POWER10)\n\t\treturn 0;\n\treturn ((mmcr3 >> ((49 - (15 * ((pmc) - 1))))) & 0x7fff);\n}\n\nstatic inline int get_mmcra_thd_cmp(u64 mmcra, int pmc)\n{\n\tif (pvr == POWER10)\n\t\treturn ((mmcra >> 45) & 0x7ff);\n\treturn ((mmcra >> 45) & 0x3ff);\n}\n\nstatic inline int get_mmcra_sm(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 42) & 0x3);\n}\n\nstatic inline u64 get_mmcra_bhrb_disable(u64 mmcra, int pmc)\n{\n\tif (pvr == POWER10)\n\t\treturn mmcra & BHRB_DISABLE;\n\treturn 0;\n}\n\nstatic inline int get_mmcra_ifm(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 30) & 0x3);\n}\n\nstatic inline int get_mmcra_thd_sel(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 16) & 0x7);\n}\n\nstatic inline int get_mmcra_thd_start(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 12) & 0xf);\n}\n\nstatic inline int get_mmcra_thd_stop(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 8) & 0xf);\n}\n\nstatic inline int get_mmcra_rand_samp_elig(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 4) & 0x7);\n}\n\nstatic inline int get_mmcra_sample_mode(u64 mmcra, int pmc)\n{\n\treturn ((mmcra >> 1) & 0x3);\n}\n\nstatic inline int get_mmcra_marked(u64 mmcra, int pmc)\n{\n\treturn mmcra & 0x1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}