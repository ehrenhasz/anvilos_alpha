{
  "module_name": "misc.c",
  "hash_id": "77f72c4d5586c46490c82ec406d17eff9a279a18d6099ac7e604054c67aea35c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/sampling_tests/misc.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#include \"misc.h\"\n\n#define PAGE_SIZE               sysconf(_SC_PAGESIZE)\n\n \nint pvr;\nu64 platform_extended_mask;\n\n \nint ev_mask_pmcxsel, ev_shift_pmcxsel;\t\t\nint ev_mask_marked, ev_shift_marked;\t\t\nint ev_mask_comb, ev_shift_comb;\t\t\nint ev_mask_unit, ev_shift_unit;\t\t\nint ev_mask_pmc, ev_shift_pmc;\t\t\t\nint ev_mask_cache, ev_shift_cache;\t\t\nint ev_mask_sample, ev_shift_sample;\t\t\nint ev_mask_thd_sel, ev_shift_thd_sel;\t\t\nint ev_mask_thd_start, ev_shift_thd_start;\t\nint ev_mask_thd_stop, ev_shift_thd_stop;\t\nint ev_mask_thd_cmp, ev_shift_thd_cmp;\t\t\nint ev_mask_sm, ev_shift_sm;\t\t\t\nint ev_mask_rsq, ev_shift_rsq;\t\t\t\nint ev_mask_l2l3, ev_shift_l2l3;\t\t\nint ev_mask_mmcr3_src, ev_shift_mmcr3_src;\t\n\nstatic void init_ev_encodes(void)\n{\n\tev_mask_pmcxsel = 0xff;\n\tev_shift_pmcxsel = 0;\n\tev_mask_marked = 1;\n\tev_shift_marked = 8;\n\tev_mask_unit = 0xf;\n\tev_shift_unit = 12;\n\tev_mask_pmc = 0xf;\n\tev_shift_pmc = 16;\n\tev_mask_sample\t= 0x1f;\n\tev_shift_sample = 24;\n\tev_mask_thd_sel = 0x7;\n\tev_shift_thd_sel = 29;\n\tev_mask_thd_start = 0xf;\n\tev_shift_thd_start = 36;\n\tev_mask_thd_stop = 0xf;\n\tev_shift_thd_stop = 32;\n\n\tswitch (pvr) {\n\tcase POWER10:\n\t\tev_mask_thd_cmp = 0x3ffff;\n\t\tev_shift_thd_cmp = 0;\n\t\tev_mask_rsq = 1;\n\t\tev_shift_rsq = 9;\n\t\tev_mask_comb = 3;\n\t\tev_shift_comb = 10;\n\t\tev_mask_cache = 3;\n\t\tev_shift_cache = 20;\n\t\tev_mask_sm = 0x3;\n\t\tev_shift_sm = 22;\n\t\tev_mask_l2l3 = 0x1f;\n\t\tev_shift_l2l3 = 40;\n\t\tev_mask_mmcr3_src = 0x7fff;\n\t\tev_shift_mmcr3_src = 45;\n\t\tbreak;\n\tcase POWER9:\n\t\tev_mask_comb = 3;\n\t\tev_shift_comb = 10;\n\t\tev_mask_cache = 0xf;\n\t\tev_shift_cache = 20;\n\t\tev_mask_thd_cmp = 0x3ff;\n\t\tev_shift_thd_cmp = 40;\n\t\tev_mask_sm = 0x3;\n\t\tev_shift_sm = 50;\n\t\tbreak;\n\tdefault:\n\t\tFAIL_IF_EXIT(1);\n\t}\n}\n\n \nstatic u64 perf_get_platform_reg_mask(void)\n{\n\tif (have_hwcap2(PPC_FEATURE2_ARCH_3_1))\n\t\treturn PERF_POWER10_MASK;\n\tif (have_hwcap2(PPC_FEATURE2_ARCH_3_00))\n\t\treturn PERF_POWER9_MASK;\n\n\treturn -1;\n}\n\nint check_extended_regs_support(void)\n{\n\tint fd;\n\tstruct event event;\n\n\tevent_init(&event, 0x1001e);\n\n\tevent.attr.type = 4;\n\tevent.attr.sample_period = 1;\n\tevent.attr.disabled = 1;\n\tevent.attr.sample_type = PERF_SAMPLE_REGS_INTR;\n\tevent.attr.sample_regs_intr = platform_extended_mask;\n\n\tfd = event_open(&event);\n\tif (fd != -1)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nint platform_check_for_tests(void)\n{\n\tpvr = PVR_VER(mfspr(SPRN_PVR));\n\n\t \n\tif ((pvr != POWER10) && (pvr != POWER9))\n\t\tgoto out;\n\n\t \n\tif (!have_hwcap2(PPC_FEATURE2_EBB) || !have_hwcap2(PPC_FEATURE2_ARCH_3_00))\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tprintf(\"%s: Tests unsupported for this platform\\n\", __func__);\n\treturn -1;\n}\n\nint check_pvr_for_sampling_tests(void)\n{\n\tSKIP_IF(platform_check_for_tests());\n\n\tplatform_extended_mask = perf_get_platform_reg_mask();\n\t \n\tif (check_extended_regs_support())\n\t\tgoto out;\n\n\tinit_ev_encodes();\n\treturn 0;\n\nout:\n\tprintf(\"%s: Sampling tests un-supported\\n\", __func__);\n\treturn -1;\n}\n\n \nvoid *event_sample_buf_mmap(int fd, int mmap_pages)\n{\n\tsize_t page_size = sysconf(_SC_PAGESIZE);\n\tsize_t mmap_size;\n\tvoid *buff;\n\n\tif (mmap_pages <= 0)\n\t\treturn NULL;\n\n\tif (fd <= 0)\n\t\treturn NULL;\n\n\tmmap_size =  page_size * (1 + mmap_pages);\n\tbuff = mmap(NULL, mmap_size,\n\t\tPROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n\tif (buff == MAP_FAILED) {\n\t\tperror(\"mmap() failed.\");\n\t\treturn NULL;\n\t}\n\treturn buff;\n}\n\n \nvoid *__event_read_samples(void *sample_buff, size_t *size, u64 *sample_count)\n{\n\tsize_t page_size = sysconf(_SC_PAGESIZE);\n\tstruct perf_event_header *header = sample_buff + page_size;\n\tstruct perf_event_mmap_page *metadata_page = sample_buff;\n\tunsigned long data_head, data_tail;\n\n\t \n\n\tdata_head = metadata_page->data_head;\n\t \n\tmb();\n\tdata_tail = metadata_page->data_tail;\n\n\t \n\tif (sample_count)\n\t\t*sample_count = 0;\n\n\twhile (1) {\n\t\t \n\t\tif (data_head - data_tail < sizeof(header))\n\t\t\treturn NULL;\n\n\t\tdata_tail += sizeof(header);\n\t\tif (header->type == PERF_RECORD_SAMPLE) {\n\t\t\t*size = (header->size - sizeof(header));\n\t\t\tif (!sample_count)\n\t\t\t\treturn sample_buff + page_size + data_tail;\n\t\t\tdata_tail += *size;\n\t\t\t*sample_count += 1;\n\t\t} else {\n\t\t\t*size = (header->size - sizeof(header));\n\t\t\tif ((metadata_page->data_tail + *size) > metadata_page->data_head)\n\t\t\t\tdata_tail = metadata_page->data_head;\n\t\t\telse\n\t\t\t\tdata_tail += *size;\n\t\t}\n\t\theader = (struct perf_event_header *)((void *)header + header->size);\n\t}\n\treturn NULL;\n}\n\nint collect_samples(void *sample_buff)\n{\n\tu64 sample_count;\n\tsize_t size = 0;\n\n\t__event_read_samples(sample_buff, &size, &sample_count);\n\treturn sample_count;\n}\n\nstatic void *perf_read_first_sample(void *sample_buff, size_t *size)\n{\n\treturn __event_read_samples(sample_buff, size, NULL);\n}\n\nu64 *get_intr_regs(struct event *event, void *sample_buff)\n{\n\tu64 type = event->attr.sample_type;\n\tu64 *intr_regs;\n\tsize_t size = 0;\n\n\tif ((type ^ (PERF_SAMPLE_REGS_INTR | PERF_SAMPLE_BRANCH_STACK)) &&\n\t\t\t(type  ^ PERF_SAMPLE_REGS_INTR))\n\t\treturn NULL;\n\n\tintr_regs = (u64 *)perf_read_first_sample(sample_buff, &size);\n\tif (!intr_regs)\n\t\treturn NULL;\n\n\tif (type & PERF_SAMPLE_BRANCH_STACK) {\n\t\t \n\t\tintr_regs += ((*intr_regs) * 3) + 1;\n\t}\n\n\t \n\t++intr_regs;\n\n\treturn intr_regs;\n}\n\nstatic const int __perf_reg_mask(const char *register_name)\n{\n\tif (!strcmp(register_name, \"R0\"))\n\t\treturn 0;\n\telse if (!strcmp(register_name, \"R1\"))\n\t\treturn 1;\n\telse if (!strcmp(register_name, \"R2\"))\n\t\treturn 2;\n\telse if (!strcmp(register_name, \"R3\"))\n\t\treturn 3;\n\telse if (!strcmp(register_name, \"R4\"))\n\t\treturn 4;\n\telse if (!strcmp(register_name, \"R5\"))\n\t\treturn 5;\n\telse if (!strcmp(register_name, \"R6\"))\n\t\treturn 6;\n\telse if (!strcmp(register_name, \"R7\"))\n\t\treturn 7;\n\telse if (!strcmp(register_name, \"R8\"))\n\t\treturn 8;\n\telse if (!strcmp(register_name, \"R9\"))\n\t\treturn 9;\n\telse if (!strcmp(register_name, \"R10\"))\n\t\treturn 10;\n\telse if (!strcmp(register_name, \"R11\"))\n\t\treturn 11;\n\telse if (!strcmp(register_name, \"R12\"))\n\t\treturn 12;\n\telse if (!strcmp(register_name, \"R13\"))\n\t\treturn 13;\n\telse if (!strcmp(register_name, \"R14\"))\n\t\treturn 14;\n\telse if (!strcmp(register_name, \"R15\"))\n\t\treturn 15;\n\telse if (!strcmp(register_name, \"R16\"))\n\t\treturn 16;\n\telse if (!strcmp(register_name, \"R17\"))\n\t\treturn 17;\n\telse if (!strcmp(register_name, \"R18\"))\n\t\treturn 18;\n\telse if (!strcmp(register_name, \"R19\"))\n\t\treturn 19;\n\telse if (!strcmp(register_name, \"R20\"))\n\t\treturn 20;\n\telse if (!strcmp(register_name, \"R21\"))\n\t\treturn 21;\n\telse if (!strcmp(register_name, \"R22\"))\n\t\treturn 22;\n\telse if (!strcmp(register_name, \"R23\"))\n\t\treturn 23;\n\telse if (!strcmp(register_name, \"R24\"))\n\t\treturn 24;\n\telse if (!strcmp(register_name, \"R25\"))\n\t\treturn 25;\n\telse if (!strcmp(register_name, \"R26\"))\n\t\treturn 26;\n\telse if (!strcmp(register_name, \"R27\"))\n\t\treturn 27;\n\telse if (!strcmp(register_name, \"R28\"))\n\t\treturn 28;\n\telse if (!strcmp(register_name, \"R29\"))\n\t\treturn 29;\n\telse if (!strcmp(register_name, \"R30\"))\n\t\treturn 30;\n\telse if (!strcmp(register_name, \"R31\"))\n\t\treturn 31;\n\telse if (!strcmp(register_name, \"NIP\"))\n\t\treturn 32;\n\telse if (!strcmp(register_name, \"MSR\"))\n\t\treturn 33;\n\telse if (!strcmp(register_name, \"ORIG_R3\"))\n\t\treturn 34;\n\telse if (!strcmp(register_name, \"CTR\"))\n\t\treturn 35;\n\telse if (!strcmp(register_name, \"LINK\"))\n\t\treturn 36;\n\telse if (!strcmp(register_name, \"XER\"))\n\t\treturn 37;\n\telse if (!strcmp(register_name, \"CCR\"))\n\t\treturn 38;\n\telse if (!strcmp(register_name, \"SOFTE\"))\n\t\treturn 39;\n\telse if (!strcmp(register_name, \"TRAP\"))\n\t\treturn 40;\n\telse if (!strcmp(register_name, \"DAR\"))\n\t\treturn 41;\n\telse if (!strcmp(register_name, \"DSISR\"))\n\t\treturn 42;\n\telse if (!strcmp(register_name, \"SIER\"))\n\t\treturn 43;\n\telse if (!strcmp(register_name, \"MMCRA\"))\n\t\treturn 44;\n\telse if (!strcmp(register_name, \"MMCR0\"))\n\t\treturn 45;\n\telse if (!strcmp(register_name, \"MMCR1\"))\n\t\treturn 46;\n\telse if (!strcmp(register_name, \"MMCR2\"))\n\t\treturn 47;\n\telse if (!strcmp(register_name, \"MMCR3\"))\n\t\treturn 48;\n\telse if (!strcmp(register_name, \"SIER2\"))\n\t\treturn 49;\n\telse if (!strcmp(register_name, \"SIER3\"))\n\t\treturn 50;\n\telse if (!strcmp(register_name, \"PMC1\"))\n\t\treturn 51;\n\telse if (!strcmp(register_name, \"PMC2\"))\n\t\treturn 52;\n\telse if (!strcmp(register_name, \"PMC3\"))\n\t\treturn 53;\n\telse if (!strcmp(register_name, \"PMC4\"))\n\t\treturn 54;\n\telse if (!strcmp(register_name, \"PMC5\"))\n\t\treturn 55;\n\telse if (!strcmp(register_name, \"PMC6\"))\n\t\treturn 56;\n\telse if (!strcmp(register_name, \"SDAR\"))\n\t\treturn 57;\n\telse if (!strcmp(register_name, \"SIAR\"))\n\t\treturn 58;\n\telse\n\t\treturn -1;\n}\n\nu64 get_reg_value(u64 *intr_regs, char *register_name)\n{\n\tint register_bit_position;\n\n\tregister_bit_position = __perf_reg_mask(register_name);\n\n\tif (register_bit_position < 0 || (!((platform_extended_mask >>\n\t\t\t(register_bit_position - 1)) & 1)))\n\t\treturn -1;\n\n\treturn *(intr_regs + register_bit_position);\n}\n\nint get_thresh_cmp_val(struct event event)\n{\n\tint exp = 0;\n\tu64 result = 0;\n\tu64 value;\n\n\tif (!have_hwcap2(PPC_FEATURE2_ARCH_3_1))\n\t\treturn EV_CODE_EXTRACT(event.attr.config, thd_cmp);\n\n\tvalue = EV_CODE_EXTRACT(event.attr.config1, thd_cmp);\n\n\tif (!value)\n\t\treturn value;\n\n\t \n\tif (value > 261120)\n\t\tvalue = 261120;\n\twhile ((64 - __builtin_clzl(value)) > 8) {\n\t\texp++;\n\t\tvalue >>= 2;\n\t}\n\n\t \n\tif (!(value & 0xC0) && exp)\n\t\tresult = -1;\n\telse\n\t\tresult = (exp << 8) | value;\n\treturn result;\n}\n\n \nstatic bool auxv_generic_compat_pmu(void)\n{\n\tint base_pvr = 0;\n\n\tif (!strcmp(auxv_base_platform(), \"power9\"))\n\t\tbase_pvr = POWER9;\n\telse if (!strcmp(auxv_base_platform(), \"power10\"))\n\t\tbase_pvr = POWER10;\n\n\treturn (!base_pvr);\n}\n\n \nbool check_for_generic_compat_pmu(void)\n{\n\tchar pmu_name[256];\n\n\tmemset(pmu_name, 0, sizeof(pmu_name));\n\tif (read_sysfs_file(\"bus/event_source/devices/cpu/caps/pmu_name\",\n\t\tpmu_name, sizeof(pmu_name)) < 0)\n\t\treturn auxv_generic_compat_pmu();\n\n\tif (!strcmp(pmu_name, \"ISAv3\"))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nbool check_for_compat_mode(void)\n{\n\tchar *platform = auxv_platform();\n\tchar *base_platform = auxv_base_platform();\n\n\treturn strcmp(platform, base_platform);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}