{
  "module_name": "lib.c",
  "hash_id": "d21f5a0116803b578b8cc36109f7b58e6199d02b7d076856304c2dca9f751958",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/pmu/lib.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\t \n\n#include <errno.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n\n#include \"utils.h\"\n#include \"lib.h\"\n\n#define PARENT_TOKEN\t0xAA\n#define CHILD_TOKEN\t0x55\n\nint sync_with_child(union pipe read_pipe, union pipe write_pipe)\n{\n\tchar c = PARENT_TOKEN;\n\n\tFAIL_IF(write(write_pipe.write_fd, &c, 1) != 1);\n\tFAIL_IF(read(read_pipe.read_fd, &c, 1) != 1);\n\tif (c != CHILD_TOKEN)  \n\t\treturn 1;\n\n\treturn 0;\n}\n\nint wait_for_parent(union pipe read_pipe)\n{\n\tchar c;\n\n\tFAIL_IF(read(read_pipe.read_fd, &c, 1) != 1);\n\tFAIL_IF(c != PARENT_TOKEN);\n\n\treturn 0;\n}\n\nint notify_parent(union pipe write_pipe)\n{\n\tchar c = CHILD_TOKEN;\n\n\tFAIL_IF(write(write_pipe.write_fd, &c, 1) != 1);\n\n\treturn 0;\n}\n\nint notify_parent_of_error(union pipe write_pipe)\n{\n\tchar c = ~CHILD_TOKEN;\n\n\tFAIL_IF(write(write_pipe.write_fd, &c, 1) != 1);\n\n\treturn 0;\n}\n\nint wait_for_child(pid_t child_pid)\n{\n\tint rc;\n\n\tif (waitpid(child_pid, &rc, 0) == -1) {\n\t\tperror(\"waitpid\");\n\t\treturn 1;\n\t}\n\n\tif (WIFEXITED(rc))\n\t\trc = WEXITSTATUS(rc);\n\telse\n\t\trc = 1;  \n\n\treturn rc;\n}\n\nint kill_child_and_wait(pid_t child_pid)\n{\n\tkill(child_pid, SIGTERM);\n\n\treturn wait_for_child(child_pid);\n}\n\nstatic int eat_cpu_child(union pipe read_pipe, union pipe write_pipe)\n{\n\tvolatile int i = 0;\n\n\t \n\tsignal(SIGTERM, SIG_DFL);\n\n\tnotify_parent(write_pipe);\n\twait_for_parent(read_pipe);\n\n\t \n\twhile (1) i++;\n\n\treturn 0;\n}\n\npid_t eat_cpu(int (test_function)(void))\n{\n\tunion pipe read_pipe, write_pipe;\n\tint rc;\n\tpid_t pid;\n\n\tFAIL_IF(bind_to_cpu(BIND_CPU_ANY) < 0);\n\n\tif (pipe(read_pipe.fds) == -1)\n\t\treturn -1;\n\n\tif (pipe(write_pipe.fds) == -1)\n\t\treturn -1;\n\n\tpid = fork();\n\tif (pid == 0)\n\t\texit(eat_cpu_child(write_pipe, read_pipe));\n\n\tif (sync_with_child(read_pipe, write_pipe)) {\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\n\tprintf(\"main test running as pid %d\\n\", getpid());\n\n\trc = test_function();\nout:\n\tkill(pid, SIGKILL);\n\n\treturn rc;\n}\n\nstruct addr_range libc, vdso;\n\nint parse_proc_maps(void)\n{\n\tunsigned long start, end;\n\tchar execute, name[128];\n\tFILE *f;\n\tint rc;\n\n\tf = fopen(\"/proc/self/maps\", \"r\");\n\tif (!f) {\n\t\tperror(\"fopen\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\t \n\t\trc = fscanf(f, \"%lx-%lx %*c%*c%c%*c %*x %*d:%*d %*d %127s\\n\",\n\t\t\t    &start, &end, &execute, name);\n\t\tif (rc <= 0)\n\t\t\tbreak;\n\n\t\tif (execute != 'x')\n\t\t\tcontinue;\n\n\t\tif (strstr(name, \"libc\")) {\n\t\t\tlibc.first = start;\n\t\t\tlibc.last = end - 1;\n\t\t} else if (strstr(name, \"[vdso]\")) {\n\t\t\tvdso.first = start;\n\t\t\tvdso.last = end - 1;\n\t\t}\n\t} while(1);\n\n\tfclose(f);\n\n\treturn 0;\n}\n\n#define PARANOID_PATH\t\"/proc/sys/kernel/perf_event_paranoid\"\n\nbool require_paranoia_below(int level)\n{\n\tint err;\n\tlong current;\n\n\terr = read_long(PARANOID_PATH, &current, 10);\n\tif (err) {\n\t\tprintf(\"Couldn't parse \" PARANOID_PATH \"?\\n\");\n\t\treturn false;\n\t}\n\n\treturn current < level;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}