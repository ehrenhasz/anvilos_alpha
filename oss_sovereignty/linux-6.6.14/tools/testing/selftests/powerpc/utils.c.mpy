{
  "module_name": "utils.c",
  "hash_id": "922f26a9725cdebd9e4fa6bd8f6a2fae233b758ff5f2f87eb7e7236470ab0ca9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/powerpc/utils.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\t \n\n#include <elf.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <link.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <asm/unistd.h>\n#include <linux/limits.h>\n\n#include \"utils.h\"\n\nstatic char auxv[4096];\n\nint read_file(const char *path, char *buf, size_t count, size_t *len)\n{\n\tssize_t rc;\n\tint fd;\n\tint err;\n\tchar eof;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\trc = read(fd, buf, count);\n\tif (rc < 0) {\n\t\terr = -errno;\n\t\tgoto out;\n\t}\n\n\tif (len)\n\t\t*len = rc;\n\n\t \n\tif (rc == count) {\n\t\trc = read(fd, &eof, 1);\n\t\tif (rc != 0) {\n\t\t\terr = -EOVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\n\nout:\n\tclose(fd);\n\terrno = -err;\n\treturn err;\n}\n\nint read_file_alloc(const char *path, char **buf, size_t *len)\n{\n\tsize_t read_offset = 0;\n\tsize_t buffer_len = 0;\n\tchar *buffer = NULL;\n\tint err;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\t \n\twhile (1) {\n\t\tssize_t rc;\n\n\t\tif (read_offset >= buffer_len / 2) {\n\t\t\tchar *next_buffer;\n\n\t\t\tbuffer_len = buffer_len ? buffer_len * 2 : 4096;\n\t\t\tnext_buffer = realloc(buffer, buffer_len);\n\t\t\tif (!next_buffer) {\n\t\t\t\terr = -errno;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbuffer = next_buffer;\n\t\t}\n\n\t\trc = read(fd, buffer + read_offset, buffer_len - read_offset);\n\t\tif (rc < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rc == 0)\n\t\t\tbreak;\n\n\t\tread_offset += rc;\n\t}\n\n\t*buf = buffer;\n\tif (len)\n\t\t*len = read_offset;\n\n\terr = 0;\n\nout:\n\tclose(fd);\n\tif (err)\n\t\tfree(buffer);\n\terrno = -err;\n\treturn err;\n}\n\nint write_file(const char *path, const char *buf, size_t count)\n{\n\tint fd;\n\tint err;\n\tssize_t rc;\n\n\tfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\trc = write(fd, buf, count);\n\tif (rc < 0) {\n\t\terr = -errno;\n\t\tgoto out;\n\t}\n\n\tif (rc != count) {\n\t\terr = -EOVERFLOW;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\tclose(fd);\n\terrno = -err;\n\treturn err;\n}\n\nint read_auxv(char *buf, ssize_t buf_size)\n{\n\tint err;\n\n\terr = read_file(\"/proc/self/auxv\", buf, buf_size, NULL);\n\tif (err) {\n\t\tperror(\"Error reading /proc/self/auxv\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint read_debugfs_file(const char *subpath, char *buf, size_t count)\n{\n\tchar path[PATH_MAX] = \"/sys/kernel/debug/\";\n\n\tstrncat(path, subpath, sizeof(path) - strlen(path) - 1);\n\n\treturn read_file(path, buf, count, NULL);\n}\n\nint write_debugfs_file(const char *subpath, const char *buf, size_t count)\n{\n\tchar path[PATH_MAX] = \"/sys/kernel/debug/\";\n\n\tstrncat(path, subpath, sizeof(path) - strlen(path) - 1);\n\n\treturn write_file(path, buf, count);\n}\n\nstatic int validate_int_parse(const char *buffer, size_t count, char *end)\n{\n\tint err = 0;\n\n\t \n\tif (end == buffer) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (; end < buffer + count; end++) {\n\t\tif (*end == '\\0')\n\t\t\tbreak;\n\n\t\tif (*end != ' ' && *end != '\\n') {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\terrno = -err;\n\treturn err;\n}\n\nstatic int parse_bounded_int(const char *buffer, size_t count, intmax_t *result,\n\t\t\t     int base, intmax_t min, intmax_t max)\n{\n\tint err;\n\tchar *end;\n\n\terrno = 0;\n\t*result = strtoimax(buffer, &end, base);\n\n\tif (errno)\n\t\treturn -errno;\n\n\terr = validate_int_parse(buffer, count, end);\n\tif (err)\n\t\tgoto out;\n\n\tif (*result < min || *result > max)\n\t\terr = -EOVERFLOW;\n\nout:\n\terrno = -err;\n\treturn err;\n}\n\nstatic int parse_bounded_uint(const char *buffer, size_t count, uintmax_t *result,\n\t\t\t      int base, uintmax_t max)\n{\n\tint err = 0;\n\tchar *end;\n\n\terrno = 0;\n\t*result = strtoumax(buffer, &end, base);\n\n\tif (errno)\n\t\treturn -errno;\n\n\terr = validate_int_parse(buffer, count, end);\n\tif (err)\n\t\tgoto out;\n\n\tif (*result > max)\n\t\terr = -EOVERFLOW;\n\nout:\n\terrno = -err;\n\treturn err;\n}\n\nint parse_intmax(const char *buffer, size_t count, intmax_t *result, int base)\n{\n\treturn parse_bounded_int(buffer, count, result, base, INTMAX_MIN, INTMAX_MAX);\n}\n\nint parse_uintmax(const char *buffer, size_t count, uintmax_t *result, int base)\n{\n\treturn parse_bounded_uint(buffer, count, result, base, UINTMAX_MAX);\n}\n\nint parse_int(const char *buffer, size_t count, int *result, int base)\n{\n\tintmax_t parsed;\n\tint err = parse_bounded_int(buffer, count, &parsed, base, INT_MIN, INT_MAX);\n\n\t*result = parsed;\n\treturn err;\n}\n\nint parse_uint(const char *buffer, size_t count, unsigned int *result, int base)\n{\n\tuintmax_t parsed;\n\tint err = parse_bounded_uint(buffer, count, &parsed, base, UINT_MAX);\n\n\t*result = parsed;\n\treturn err;\n}\n\nint parse_long(const char *buffer, size_t count, long *result, int base)\n{\n\tintmax_t parsed;\n\tint err = parse_bounded_int(buffer, count, &parsed, base, LONG_MIN, LONG_MAX);\n\n\t*result = parsed;\n\treturn err;\n}\n\nint parse_ulong(const char *buffer, size_t count, unsigned long *result, int base)\n{\n\tuintmax_t parsed;\n\tint err = parse_bounded_uint(buffer, count, &parsed, base, ULONG_MAX);\n\n\t*result = parsed;\n\treturn err;\n}\n\nint read_long(const char *path, long *result, int base)\n{\n\tint err;\n\tchar buffer[32] = {0};\n\n\terr = read_file(path, buffer, sizeof(buffer) - 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn parse_long(buffer, sizeof(buffer), result, base);\n}\n\nint read_ulong(const char *path, unsigned long *result, int base)\n{\n\tint err;\n\tchar buffer[32] = {0};\n\n\terr = read_file(path, buffer, sizeof(buffer) - 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn parse_ulong(buffer, sizeof(buffer), result, base);\n}\n\nint write_long(const char *path, long result, int base)\n{\n\tint err;\n\tint len;\n\tchar buffer[32];\n\n\t \n\tif (base != 10) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%ld\", result);\n\tif (len < 0 || len >= sizeof(buffer)) {\n\t\terr = -EOVERFLOW;\n\t\tgoto out;\n\t}\n\n\terr = write_file(path, buffer, len);\n\nout:\n\terrno = -err;\n\treturn err;\n}\n\nint write_ulong(const char *path, unsigned long result, int base)\n{\n\tint err;\n\tint len;\n\tchar buffer[32];\n\tchar *fmt;\n\n\tswitch (base) {\n\tcase 10:\n\t\tfmt = \"%lu\";\n\t\tbreak;\n\tcase 16:\n\t\tfmt = \"%lx\";\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = snprintf(buffer, sizeof(buffer), fmt, result);\n\tif (len < 0 || len >= sizeof(buffer)) {\n\t\terr = -errno;\n\t\tgoto out;\n\t}\n\n\terr = write_file(path, buffer, len);\n\nout:\n\terrno = -err;\n\treturn err;\n}\n\nvoid *find_auxv_entry(int type, char *auxv)\n{\n\tElfW(auxv_t) *p;\n\n\tp = (ElfW(auxv_t) *)auxv;\n\n\twhile (p->a_type != AT_NULL) {\n\t\tif (p->a_type == type)\n\t\t\treturn p;\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}\n\nvoid *get_auxv_entry(int type)\n{\n\tElfW(auxv_t) *p;\n\n\tif (read_auxv(auxv, sizeof(auxv)))\n\t\treturn NULL;\n\n\tp = find_auxv_entry(type, auxv);\n\tif (p)\n\t\treturn (void *)p->a_un.a_val;\n\n\treturn NULL;\n}\n\nint pick_online_cpu(void)\n{\n\tint ncpus, cpu = -1;\n\tcpu_set_t *mask;\n\tsize_t size;\n\n\tncpus = get_nprocs_conf();\n\tsize = CPU_ALLOC_SIZE(ncpus);\n\tmask = CPU_ALLOC(ncpus);\n\tif (!mask) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\n\tCPU_ZERO_S(size, mask);\n\n\tif (sched_getaffinity(0, size, mask)) {\n\t\tperror(\"sched_getaffinity\");\n\t\tgoto done;\n\t}\n\n\t \n\tfor (cpu = 8; cpu < ncpus; cpu += 8)\n\t\tif (CPU_ISSET_S(cpu, size, mask))\n\t\t\tgoto done;\n\n\t \n\tfor (cpu = ncpus - 1; cpu >= 0; cpu--)\n\t\tif (CPU_ISSET_S(cpu, size, mask))\n\t\t\tgoto done;\n\n\tprintf(\"No cpus in affinity mask?!\\n\");\n\ndone:\n\tCPU_FREE(mask);\n\treturn cpu;\n}\n\nint bind_to_cpu(int cpu)\n{\n\tcpu_set_t mask;\n\tint err;\n\n\tif (cpu == BIND_CPU_ANY) {\n\t\tcpu = pick_online_cpu();\n\t\tif (cpu < 0)\n\t\t\treturn cpu;\n\t}\n\n\tprintf(\"Binding to cpu %d\\n\", cpu);\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(cpu, &mask);\n\n\terr = sched_setaffinity(0, sizeof(mask), &mask);\n\tif (err)\n\t\treturn err;\n\n\treturn cpu;\n}\n\nbool is_ppc64le(void)\n{\n\tstruct utsname uts;\n\tint rc;\n\n\terrno = 0;\n\trc = uname(&uts);\n\tif (rc) {\n\t\tperror(\"uname\");\n\t\treturn false;\n\t}\n\n\treturn strcmp(uts.machine, \"ppc64le\") == 0;\n}\n\nint read_sysfs_file(char *fpath, char *result, size_t result_size)\n{\n\tchar path[PATH_MAX] = \"/sys/\";\n\n\tstrncat(path, fpath, PATH_MAX - strlen(path) - 1);\n\n\treturn read_file(path, result, result_size, NULL);\n}\n\nint read_debugfs_int(const char *debugfs_file, int *result)\n{\n\tint err;\n\tchar value[16] = {0};\n\n\terr = read_debugfs_file(debugfs_file, value, sizeof(value) - 1);\n\tif (err)\n\t\treturn err;\n\n\treturn parse_int(value, sizeof(value), result, 10);\n}\n\nint write_debugfs_int(const char *debugfs_file, int result)\n{\n\tchar value[16];\n\n\tsnprintf(value, 16, \"%d\", result);\n\n\treturn write_debugfs_file(debugfs_file, value, strlen(value));\n}\n\nstatic long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n\t\tint cpu, int group_fd, unsigned long flags)\n{\n\treturn syscall(__NR_perf_event_open, hw_event, pid, cpu,\n\t\t      group_fd, flags);\n}\n\nstatic void perf_event_attr_init(struct perf_event_attr *event_attr,\n\t\t\t\t\tunsigned int type,\n\t\t\t\t\tunsigned long config)\n{\n\tmemset(event_attr, 0, sizeof(*event_attr));\n\n\tevent_attr->type = type;\n\tevent_attr->size = sizeof(struct perf_event_attr);\n\tevent_attr->config = config;\n\tevent_attr->read_format = PERF_FORMAT_GROUP;\n\tevent_attr->disabled = 1;\n\tevent_attr->exclude_kernel = 1;\n\tevent_attr->exclude_hv = 1;\n\tevent_attr->exclude_guest = 1;\n}\n\nint perf_event_open_counter(unsigned int type,\n\t\t\t    unsigned long config, int group_fd)\n{\n\tint fd;\n\tstruct perf_event_attr event_attr;\n\n\tperf_event_attr_init(&event_attr, type, config);\n\n\tfd = perf_event_open(&event_attr, 0, -1, group_fd, 0);\n\n\tif (fd < 0)\n\t\tperror(\"perf_event_open() failed\");\n\n\treturn fd;\n}\n\nint perf_event_enable(int fd)\n{\n\tif (ioctl(fd, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP) == -1) {\n\t\tperror(\"error while enabling perf events\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint perf_event_disable(int fd)\n{\n\tif (ioctl(fd, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP) == -1) {\n\t\tperror(\"error disabling perf events\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint perf_event_reset(int fd)\n{\n\tif (ioctl(fd, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP) == -1) {\n\t\tperror(\"error resetting perf events\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint using_hash_mmu(bool *using_hash)\n{\n\tchar line[128];\n\tFILE *f;\n\tint rc;\n\n\tf = fopen(\"/proc/cpuinfo\", \"r\");\n\tFAIL_IF(!f);\n\n\trc = 0;\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (!strcmp(line, \"MMU\t\t: Hash\\n\") ||\n\t\t    !strcmp(line, \"platform\t: Cell\\n\") ||\n\t\t    !strcmp(line, \"platform\t: PowerMac\\n\")) {\n\t\t\t*using_hash = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (strcmp(line, \"MMU\t\t: Radix\\n\") == 0) {\n\t\t\t*using_hash = false;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -1;\nout:\n\tfclose(f);\n\treturn rc;\n}\n\nstruct sigaction push_signal_handler(int sig, void (*fn)(int, siginfo_t *, void *))\n{\n\tstruct sigaction sa;\n\tstruct sigaction old_handler;\n\n\tsa.sa_sigaction = fn;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_SIGINFO;\n\tFAIL_IF_EXIT_MSG(sigaction(sig, &sa, &old_handler),\n\t\t\t \"failed to push signal handler\");\n\n\treturn old_handler;\n}\n\nstruct sigaction pop_signal_handler(int sig, struct sigaction old_handler)\n{\n\tstruct sigaction popped;\n\n\tFAIL_IF_EXIT_MSG(sigaction(sig, &old_handler, &popped),\n\t\t\t \"failed to pop signal handler\");\n\n\treturn popped;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}