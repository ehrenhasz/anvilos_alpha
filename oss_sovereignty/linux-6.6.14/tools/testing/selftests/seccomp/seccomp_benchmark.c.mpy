{
  "module_name": "seccomp_benchmark.c",
  "hash_id": "625d7ce74598b614fdb38d0bb21a5d93a19d29b9181b44fed497dd9767427329",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/seccomp/seccomp_benchmark.c",
  "human_readable_source": " \n#define _GNU_SOURCE\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <sys/param.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n\n#include \"../kselftest.h\"\n\nunsigned long long timing(clockid_t clk_id, unsigned long long samples)\n{\n\tstruct timespec start, finish;\n\tunsigned long long i;\n\tpid_t pid, ret;\n\n\tpid = getpid();\n\tassert(clock_gettime(clk_id, &start) == 0);\n\tfor (i = 0; i < samples; i++) {\n\t\tret = syscall(__NR_getpid);\n\t\tassert(pid == ret);\n\t}\n\tassert(clock_gettime(clk_id, &finish) == 0);\n\n\ti = finish.tv_sec - start.tv_sec;\n\ti *= 1000000000ULL;\n\ti += finish.tv_nsec - start.tv_nsec;\n\n\tprintf(\"%lu.%09lu - %lu.%09lu = %llu (%.1fs)\\n\",\n\t\tfinish.tv_sec, finish.tv_nsec,\n\t\tstart.tv_sec, start.tv_nsec,\n\t\ti, (double)i / 1000000000.0);\n\n\treturn i;\n}\n\nunsigned long long calibrate(void)\n{\n\tstruct timespec start, finish;\n\tunsigned long long i, samples, step = 9973;\n\tpid_t pid, ret;\n\tint seconds = 15;\n\n\tprintf(\"Calibrating sample size for %d seconds worth of syscalls ...\\n\", seconds);\n\n\tsamples = 0;\n\tpid = getpid();\n\tassert(clock_gettime(CLOCK_MONOTONIC, &start) == 0);\n\tdo {\n\t\tfor (i = 0; i < step; i++) {\n\t\t\tret = syscall(__NR_getpid);\n\t\t\tassert(pid == ret);\n\t\t}\n\t\tassert(clock_gettime(CLOCK_MONOTONIC, &finish) == 0);\n\n\t\tsamples += step;\n\t\ti = finish.tv_sec - start.tv_sec;\n\t\ti *= 1000000000ULL;\n\t\ti += finish.tv_nsec - start.tv_nsec;\n\t} while (i < 1000000000ULL);\n\n\treturn samples * seconds;\n}\n\nbool approx(int i_one, int i_two)\n{\n\tdouble one = i_one, one_bump = one * 0.01;\n\tdouble two = i_two, two_bump = two * 0.01;\n\n\tone_bump = one + MAX(one_bump, 2.0);\n\ttwo_bump = two + MAX(two_bump, 2.0);\n\n\t \n\tif (one == two ||\n\t    (one > two && one <= two_bump) ||\n\t    (two > one && two <= one_bump))\n\t\treturn true;\n\treturn false;\n}\n\nbool le(int i_one, int i_two)\n{\n\tif (i_one <= i_two)\n\t\treturn true;\n\treturn false;\n}\n\nlong compare(const char *name_one, const char *name_eval, const char *name_two,\n\t     unsigned long long one, bool (*eval)(int, int), unsigned long long two)\n{\n\tbool good;\n\n\tprintf(\"\\t%s %s %s (%lld %s %lld): \", name_one, name_eval, name_two,\n\t       (long long)one, name_eval, (long long)two);\n\tif (one > INT_MAX) {\n\t\tprintf(\"Miscalculation! Measurement went negative: %lld\\n\", (long long)one);\n\t\treturn 1;\n\t}\n\tif (two > INT_MAX) {\n\t\tprintf(\"Miscalculation! Measurement went negative: %lld\\n\", (long long)two);\n\t\treturn 1;\n\t}\n\n\tgood = eval(one, two);\n\tprintf(\"%s\\n\", good ? \"\u2714\ufe0f\" : \"\u274c\");\n\n\treturn good ? 0 : 1;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct sock_filter bitmap_filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS, offsetof(struct seccomp_data, nr)),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog bitmap_prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(bitmap_filter),\n\t\t.filter = bitmap_filter,\n\t};\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS, offsetof(struct seccomp_data, args[0])),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\tlong ret, bits;\n\tunsigned long long samples, calc;\n\tunsigned long long native, filter1, filter2, bitmap1, bitmap2;\n\tunsigned long long entry, per_filter1, per_filter2;\n\n\tsetbuf(stdout, NULL);\n\n\tprintf(\"Running on:\\n\");\n\tsystem(\"uname -a\");\n\n\tprintf(\"Current BPF sysctl settings:\\n\");\n\t \n\tsystem(\"grep -H . /proc/sys/net/core/bpf_jit_enable\");\n\tsystem(\"grep -H . /proc/sys/net/core/bpf_jit_harden\");\n\n\tif (argc > 1)\n\t\tsamples = strtoull(argv[1], NULL, 0);\n\telse\n\t\tsamples = calibrate();\n\n\tprintf(\"Benchmarking %llu syscalls...\\n\", samples);\n\n\t \n\tnative = timing(CLOCK_PROCESS_CPUTIME_ID, samples) / samples;\n\tprintf(\"getpid native: %llu ns\\n\", native);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tassert(ret == 0);\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &bitmap_prog);\n\tassert(ret == 0);\n\n\tbitmap1 = timing(CLOCK_PROCESS_CPUTIME_ID, samples) / samples;\n\tprintf(\"getpid RET_ALLOW 1 filter (bitmap): %llu ns\\n\", bitmap1);\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &bitmap_prog);\n\tassert(ret == 0);\n\n\tbitmap2 = timing(CLOCK_PROCESS_CPUTIME_ID, samples) / samples;\n\tprintf(\"getpid RET_ALLOW 2 filters (bitmap): %llu ns\\n\", bitmap2);\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tassert(ret == 0);\n\n\tfilter1 = timing(CLOCK_PROCESS_CPUTIME_ID, samples) / samples;\n\tprintf(\"getpid RET_ALLOW 3 filters (full): %llu ns\\n\", filter1);\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &bitmap_prog);\n\tassert(ret == 0);\n\n\tfilter2 = timing(CLOCK_PROCESS_CPUTIME_ID, samples) / samples;\n\tprintf(\"getpid RET_ALLOW 4 filters (full): %llu ns\\n\", filter2);\n\n\t \n#define ESTIMATE(fmt, var, what)\tdo {\t\t\t\\\n\t\tvar = (what);\t\t\t\t\t\\\n\t\tprintf(\"Estimated \" fmt \": %llu ns\\n\", var);\t\\\n\t\tif (var > INT_MAX)\t\t\t\t\\\n\t\t\tgoto more_samples;\t\t\t\\\n\t} while (0)\n\n\tESTIMATE(\"total seccomp overhead for 1 bitmapped filter\", calc,\n\t\t bitmap1 - native);\n\tESTIMATE(\"total seccomp overhead for 2 bitmapped filters\", calc,\n\t\t bitmap2 - native);\n\tESTIMATE(\"total seccomp overhead for 3 full filters\", calc,\n\t\t filter1 - native);\n\tESTIMATE(\"total seccomp overhead for 4 full filters\", calc,\n\t\t filter2 - native);\n\tESTIMATE(\"seccomp entry overhead\", entry,\n\t\t bitmap1 - native - (bitmap2 - bitmap1));\n\tESTIMATE(\"seccomp per-filter overhead (last 2 diff)\", per_filter1,\n\t\t filter2 - filter1);\n\tESTIMATE(\"seccomp per-filter overhead (filters / 4)\", per_filter2,\n\t\t (filter2 - native - entry) / 4);\n\n\tprintf(\"Expectations:\\n\");\n\tret |= compare(\"native\", \"\u2264\", \"1 bitmap\", native, le, bitmap1);\n\tbits = compare(\"native\", \"\u2264\", \"1 filter\", native, le, filter1);\n\tif (bits)\n\t\tgoto more_samples;\n\n\tret |= compare(\"per-filter (last 2 diff)\", \"\u2248\", \"per-filter (filters / 4)\",\n\t\t\tper_filter1, approx, per_filter2);\n\n\tbits = compare(\"1 bitmapped\", \"\u2248\", \"2 bitmapped\",\n\t\t\tbitmap1 - native, approx, bitmap2 - native);\n\tif (bits) {\n\t\tprintf(\"Skipping constant action bitmap expectations: they appear unsupported.\\n\");\n\t\tgoto out;\n\t}\n\n\tret |= compare(\"entry\", \"\u2248\", \"1 bitmapped\", entry, approx, bitmap1 - native);\n\tret |= compare(\"entry\", \"\u2248\", \"2 bitmapped\", entry, approx, bitmap2 - native);\n\tret |= compare(\"native + entry + (per filter * 4)\", \"\u2248\", \"4 filters total\",\n\t\t\tentry + (per_filter1 * 4) + native, approx, filter2);\n\tif (ret == 0)\n\t\tgoto out;\n\nmore_samples:\n\tprintf(\"Saw unexpected benchmark result. Try running again with more samples?\\n\");\nout:\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}