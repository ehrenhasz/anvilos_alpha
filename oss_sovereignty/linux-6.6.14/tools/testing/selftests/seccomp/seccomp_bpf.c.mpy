{
  "module_name": "seccomp_bpf.c",
  "hash_id": "2ae99d74d80b57ccffe0e611362ec639757b2cfbfad605a6514da0381b517e7c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/seccomp/seccomp_bpf.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sys/types.h>\n\n \n#if !__GLIBC_PREREQ(2, 26)\n# include <asm/siginfo.h>\n# define __have_siginfo_t 1\n# define __have_sigval_t 1\n# define __have_sigevent_t 1\n#endif\n\n#include <errno.h>\n#include <linux/filter.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/seccomp.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <linux/elf.h>\n#include <sys/uio.h>\n#include <sys/utsname.h>\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <sys/times.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <linux/kcmp.h>\n#include <sys/resource.h>\n#include <sys/capability.h>\n\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <poll.h>\n\n#include \"../kselftest_harness.h\"\n#include \"../clone3/clone3_selftests.h\"\n\n \n#ifndef SKIP\n#define SKIP(s, ...)\tXFAIL(s, ##__VA_ARGS__)\n#endif\n\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n#ifndef PR_SET_PTRACER\n# define PR_SET_PTRACER 0x59616d61\n#endif\n\n#ifndef PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#define PR_GET_NO_NEW_PRIVS 39\n#endif\n\n#ifndef PR_SECCOMP_EXT\n#define PR_SECCOMP_EXT 43\n#endif\n\n#ifndef SECCOMP_EXT_ACT\n#define SECCOMP_EXT_ACT 1\n#endif\n\n#ifndef SECCOMP_EXT_ACT_TSYNC\n#define SECCOMP_EXT_ACT_TSYNC 1\n#endif\n\n#ifndef SECCOMP_MODE_STRICT\n#define SECCOMP_MODE_STRICT 1\n#endif\n\n#ifndef SECCOMP_MODE_FILTER\n#define SECCOMP_MODE_FILTER 2\n#endif\n\n#ifndef SECCOMP_RET_ALLOW\nstruct seccomp_data {\n\tint nr;\n\t__u32 arch;\n\t__u64 instruction_pointer;\n\t__u64 args[6];\n};\n#endif\n\n#ifndef SECCOMP_RET_KILL_PROCESS\n#define SECCOMP_RET_KILL_PROCESS 0x80000000U  \n#define SECCOMP_RET_KILL_THREAD\t 0x00000000U  \n#endif\n#ifndef SECCOMP_RET_KILL\n#define SECCOMP_RET_KILL\t SECCOMP_RET_KILL_THREAD\n#define SECCOMP_RET_TRAP\t 0x00030000U  \n#define SECCOMP_RET_ERRNO\t 0x00050000U  \n#define SECCOMP_RET_TRACE\t 0x7ff00000U  \n#define SECCOMP_RET_ALLOW\t 0x7fff0000U  \n#endif\n#ifndef SECCOMP_RET_LOG\n#define SECCOMP_RET_LOG\t\t 0x7ffc0000U  \n#endif\n\n#ifndef __NR_seccomp\n# if defined(__i386__)\n#  define __NR_seccomp 354\n# elif defined(__x86_64__)\n#  define __NR_seccomp 317\n# elif defined(__arm__)\n#  define __NR_seccomp 383\n# elif defined(__aarch64__)\n#  define __NR_seccomp 277\n# elif defined(__riscv)\n#  define __NR_seccomp 277\n# elif defined(__csky__)\n#  define __NR_seccomp 277\n# elif defined(__loongarch__)\n#  define __NR_seccomp 277\n# elif defined(__hppa__)\n#  define __NR_seccomp 338\n# elif defined(__powerpc__)\n#  define __NR_seccomp 358\n# elif defined(__s390__)\n#  define __NR_seccomp 348\n# elif defined(__xtensa__)\n#  define __NR_seccomp 337\n# elif defined(__sh__)\n#  define __NR_seccomp 372\n# elif defined(__mc68000__)\n#  define __NR_seccomp 380\n# else\n#  warning \"seccomp syscall number unknown for this architecture\"\n#  define __NR_seccomp 0xffff\n# endif\n#endif\n\n#ifndef SECCOMP_SET_MODE_STRICT\n#define SECCOMP_SET_MODE_STRICT 0\n#endif\n\n#ifndef SECCOMP_SET_MODE_FILTER\n#define SECCOMP_SET_MODE_FILTER 1\n#endif\n\n#ifndef SECCOMP_GET_ACTION_AVAIL\n#define SECCOMP_GET_ACTION_AVAIL 2\n#endif\n\n#ifndef SECCOMP_GET_NOTIF_SIZES\n#define SECCOMP_GET_NOTIF_SIZES 3\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_TSYNC\n#define SECCOMP_FILTER_FLAG_TSYNC (1UL << 0)\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_LOG\n#define SECCOMP_FILTER_FLAG_LOG (1UL << 1)\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_SPEC_ALLOW\n#define SECCOMP_FILTER_FLAG_SPEC_ALLOW (1UL << 2)\n#endif\n\n#ifndef PTRACE_SECCOMP_GET_METADATA\n#define PTRACE_SECCOMP_GET_METADATA\t0x420d\n\nstruct seccomp_metadata {\n\t__u64 filter_off;        \n\t__u64 flags;              \n};\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_NEW_LISTENER\n#define SECCOMP_FILTER_FLAG_NEW_LISTENER\t(1UL << 3)\n#endif\n\n#ifndef SECCOMP_RET_USER_NOTIF\n#define SECCOMP_RET_USER_NOTIF 0x7fc00000U\n\n#define SECCOMP_IOC_MAGIC\t\t'!'\n#define SECCOMP_IO(nr)\t\t\t_IO(SECCOMP_IOC_MAGIC, nr)\n#define SECCOMP_IOR(nr, type)\t\t_IOR(SECCOMP_IOC_MAGIC, nr, type)\n#define SECCOMP_IOW(nr, type)\t\t_IOW(SECCOMP_IOC_MAGIC, nr, type)\n#define SECCOMP_IOWR(nr, type)\t\t_IOWR(SECCOMP_IOC_MAGIC, nr, type)\n\n \n#define SECCOMP_IOCTL_NOTIF_RECV\tSECCOMP_IOWR(0, struct seccomp_notif)\n#define SECCOMP_IOCTL_NOTIF_SEND\tSECCOMP_IOWR(1,\t\\\n\t\t\t\t\t\tstruct seccomp_notif_resp)\n#define SECCOMP_IOCTL_NOTIF_ID_VALID\tSECCOMP_IOW(2, __u64)\n\nstruct seccomp_notif {\n\t__u64 id;\n\t__u32 pid;\n\t__u32 flags;\n\tstruct seccomp_data data;\n};\n\nstruct seccomp_notif_resp {\n\t__u64 id;\n\t__s64 val;\n\t__s32 error;\n\t__u32 flags;\n};\n\nstruct seccomp_notif_sizes {\n\t__u16 seccomp_notif;\n\t__u16 seccomp_notif_resp;\n\t__u16 seccomp_data;\n};\n#endif\n\n#ifndef SECCOMP_IOCTL_NOTIF_ADDFD\n \n#define SECCOMP_IOCTL_NOTIF_ADDFD\tSECCOMP_IOW(3,\t\\\n\t\t\t\t\t\tstruct seccomp_notif_addfd)\n\n \n#define SECCOMP_ADDFD_FLAG_SETFD\t(1UL << 0)  \n\nstruct seccomp_notif_addfd {\n\t__u64 id;\n\t__u32 flags;\n\t__u32 srcfd;\n\t__u32 newfd;\n\t__u32 newfd_flags;\n};\n#endif\n\n#ifndef SECCOMP_ADDFD_FLAG_SEND\n#define SECCOMP_ADDFD_FLAG_SEND\t(1UL << 1)  \n#endif\n\nstruct seccomp_notif_addfd_small {\n\t__u64 id;\n\tchar weird[4];\n};\n#define SECCOMP_IOCTL_NOTIF_ADDFD_SMALL\t\\\n\tSECCOMP_IOW(3, struct seccomp_notif_addfd_small)\n\nstruct seccomp_notif_addfd_big {\n\tunion {\n\t\tstruct seccomp_notif_addfd addfd;\n\t\tchar buf[sizeof(struct seccomp_notif_addfd) + 8];\n\t};\n};\n#define SECCOMP_IOCTL_NOTIF_ADDFD_BIG\t\\\n\tSECCOMP_IOWR(3, struct seccomp_notif_addfd_big)\n\n#ifndef PTRACE_EVENTMSG_SYSCALL_ENTRY\n#define PTRACE_EVENTMSG_SYSCALL_ENTRY\t1\n#define PTRACE_EVENTMSG_SYSCALL_EXIT\t2\n#endif\n\n#ifndef SECCOMP_USER_NOTIF_FLAG_CONTINUE\n#define SECCOMP_USER_NOTIF_FLAG_CONTINUE 0x00000001\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_TSYNC_ESRCH\n#define SECCOMP_FILTER_FLAG_TSYNC_ESRCH (1UL << 4)\n#endif\n\n#ifndef SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV\n#define SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV (1UL << 5)\n#endif\n\n#ifndef seccomp\nint seccomp(unsigned int op, unsigned int flags, void *args)\n{\n\terrno = 0;\n\treturn syscall(__NR_seccomp, op, flags, args);\n}\n#endif\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define syscall_arg(_n) (offsetof(struct seccomp_data, args[_n]))\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define syscall_arg(_n) (offsetof(struct seccomp_data, args[_n]) + sizeof(__u32))\n#else\n#error \"wut? Unknown __BYTE_ORDER__?!\"\n#endif\n\n#define SIBLING_EXIT_UNKILLED\t0xbadbeef\n#define SIBLING_EXIT_FAILURE\t0xbadface\n#define SIBLING_EXIT_NEWPRIVS\t0xbadfeed\n\nstatic int __filecmp(pid_t pid1, pid_t pid2, int fd1, int fd2)\n{\n#ifdef __NR_kcmp\n\terrno = 0;\n\treturn syscall(__NR_kcmp, pid1, pid2, KCMP_FILE, fd1, fd2);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}\n\n \n#define filecmp(pid1, pid2, fd1, fd2)\t({\t\t\\\n\tint _ret;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\t_ret = __filecmp(pid1, pid2, fd1, fd2);\t\t\\\n\tif (_ret != 0) {\t\t\t\t\\\n\t\tif (_ret < 0 && errno == ENOSYS) {\t\\\n\t\t\tTH_LOG(\"kcmp() syscall missing (test is less accurate)\");\\\n\t\t\t_ret = 0;\t\t\t\\\n\t\t}\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t_ret; })\n\nTEST(kcmp)\n{\n\tint ret;\n\n\tret = __filecmp(getpid(), getpid(), 1, 1);\n\tEXPECT_EQ(ret, 0);\n\tif (ret != 0 && errno == ENOSYS)\n\t\tSKIP(return, \"Kernel does not support kcmp() (missing CONFIG_KCMP?)\");\n}\n\nTEST(mode_strict_support)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, NULL, NULL, NULL);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support CONFIG_SECCOMP\");\n\t}\n\tsyscall(__NR_exit, 0);\n}\n\nTEST_SIGNAL(mode_strict_cannot_call_prctl, SIGKILL)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, NULL, NULL, NULL);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support CONFIG_SECCOMP\");\n\t}\n\tsyscall(__NR_prctl, PR_SET_SECCOMP, SECCOMP_MODE_FILTER,\n\t\tNULL, NULL, NULL);\n\tEXPECT_FALSE(true) {\n\t\tTH_LOG(\"Unreachable!\");\n\t}\n}\n\n \nTEST(no_new_privs_support)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tEXPECT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n}\n\n \nTEST(mode_filter_support)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, NULL, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL, NULL, NULL);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EFAULT, errno) {\n\t\tTH_LOG(\"Kernel does not support CONFIG_SECCOMP_FILTER!\");\n\t}\n}\n\nTEST(mode_filter_without_nnp)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\tcap_t cap = cap_get_proc();\n\tcap_flag_value_t is_cap_sys_admin = 0;\n\n\tret = prctl(PR_GET_NO_NEW_PRIVS, 0, NULL, 0, 0);\n\tASSERT_LE(0, ret) {\n\t\tTH_LOG(\"Expected 0 or unsupported for NO_NEW_PRIVS\");\n\t}\n\terrno = 0;\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\t \n\tcap_get_flag(cap, CAP_SYS_ADMIN, CAP_EFFECTIVE, &is_cap_sys_admin);\n\tif (!is_cap_sys_admin) {\n\t\tEXPECT_EQ(-1, ret);\n\t\tEXPECT_EQ(EACCES, errno);\n\t} else {\n\t\tEXPECT_EQ(0, ret);\n\t}\n}\n\n#define MAX_INSNS_PER_PATH 32768\n\nTEST(filter_size_limits)\n{\n\tint i;\n\tint count = BPF_MAXINSNS + 1;\n\tstruct sock_filter allow[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_filter *filter;\n\tstruct sock_fprog prog = { };\n\tlong ret;\n\n\tfilter = calloc(count, sizeof(*filter));\n\tASSERT_NE(NULL, filter);\n\n\tfor (i = 0; i < count; i++)\n\t\tfilter[i] = allow[0];\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tprog.filter = filter;\n\tprog.len = count;\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_NE(0, ret) {\n\t\tTH_LOG(\"Installing %d insn filter was allowed\", prog.len);\n\t}\n\n\t \n\tprog.len -= 1;\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Installing %d insn filter wasn't allowed\", prog.len);\n\t}\n}\n\nTEST(filter_chain_limits)\n{\n\tint i;\n\tint count = BPF_MAXINSNS;\n\tstruct sock_filter allow[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_filter *filter;\n\tstruct sock_fprog prog = { };\n\tlong ret;\n\n\tfilter = calloc(count, sizeof(*filter));\n\tASSERT_NE(NULL, filter);\n\n\tfor (i = 0; i < count; i++)\n\t\tfilter[i] = allow[0];\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tprog.filter = filter;\n\tprog.len = 1;\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tprog.len = count;\n\n\t \n\tfor (i = 0; i < MAX_INSNS_PER_PATH; i++) {\n\t\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t}\n\tASSERT_NE(0, ret) {\n\t\tTH_LOG(\"Allowed %d %d-insn filters (total with penalties:%d)\",\n\t\t       i, count, i * (count + 4));\n\t}\n}\n\nTEST(mode_filter_cannot_move_to_strict)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, NULL, 0, 0);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno);\n}\n\n\nTEST(mode_filter_get_seccomp)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_GET_SECCOMP, 0, 0, 0, 0);\n\tEXPECT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_GET_SECCOMP, 0, 0, 0, 0);\n\tEXPECT_EQ(2, ret);\n}\n\n\nTEST(ALLOW_all)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n}\n\nTEST(empty_prog)\n{\n\tstruct sock_filter filter[] = {\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno);\n}\n\nTEST(log_all)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_LOG),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n}\n\nTEST_SIGNAL(unknown_ret_is_kill_inside, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, 0x10000000U),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\tEXPECT_EQ(0, syscall(__NR_getpid)) {\n\t\tTH_LOG(\"getpid() shouldn't ever return\");\n\t}\n}\n\n \nTEST_SIGNAL(unknown_ret_is_kill_above_allow, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, 0x90000000U),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\tEXPECT_EQ(0, syscall(__NR_getpid)) {\n\t\tTH_LOG(\"getpid() shouldn't ever return\");\n\t}\n}\n\nTEST_SIGNAL(KILL_all, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n}\n\nTEST_SIGNAL(KILL_one, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_SIGNAL(KILL_one_arg_one, SIGSYS)\n{\n\tvoid *fatal_address;\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_times, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\t \n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS, syscall_arg(0)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K,\n\t\t\t(unsigned long)&fatal_address, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\tpid_t parent = getppid();\n\tstruct tms timebuf;\n\tclock_t clock = times(&timebuf);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_LE(clock, syscall(__NR_times, &timebuf));\n\t \n\tEXPECT_EQ(0, syscall(__NR_times, &fatal_address));\n}\n\nTEST_SIGNAL(KILL_one_arg_six, SIGSYS)\n{\n#ifndef __NR_mmap2\n\tint sysno = __NR_mmap;\n#else\n\tint sysno = __NR_mmap2;\n#endif\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, sysno, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\t \n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS, syscall_arg(5)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 0x0C0FFEE, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\tpid_t parent = getppid();\n\tint fd;\n\tvoid *map1, *map2;\n\tint page_size = sysconf(_SC_PAGESIZE);\n\n\tASSERT_LT(0, page_size);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tASSERT_EQ(0, ret);\n\n\tfd = open(\"/dev/zero\", O_RDONLY);\n\tASSERT_NE(-1, fd);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tmap1 = (void *)syscall(sysno,\n\t\tNULL, page_size, PROT_READ, MAP_PRIVATE, fd, page_size);\n\tEXPECT_NE(MAP_FAILED, map1);\n\t \n\tmap2 = (void *)syscall(sysno,\n\t\t NULL, page_size, PROT_READ, MAP_PRIVATE, fd, 0x0C0FFEE);\n\tEXPECT_EQ(MAP_FAILED, map2);\n\n\t \n\tmunmap(map1, page_size);\n\tmunmap(map2, page_size);\n\tclose(fd);\n}\n\n \nvoid *kill_thread(void *data)\n{\n\tbool die = (bool)data;\n\n\tif (die) {\n\t\tprctl(PR_GET_SECCOMP, 0, 0, 0, 0);\n\t\treturn (void *)SIBLING_EXIT_FAILURE;\n\t}\n\n\treturn (void *)SIBLING_EXIT_UNKILLED;\n}\n\nenum kill_t {\n\tKILL_THREAD,\n\tKILL_PROCESS,\n\tRET_UNKNOWN\n};\n\n \nvoid kill_thread_or_group(struct __test_metadata *_metadata,\n\t\t\t  enum kill_t kill_how)\n{\n\tpthread_t thread;\n\tvoid *status;\n\t \n\tstruct sock_filter filter_thread[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_prctl, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL_THREAD),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog_thread = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter_thread),\n\t\t.filter = filter_thread,\n\t};\n\tint kill = kill_how == KILL_PROCESS ? SECCOMP_RET_KILL_PROCESS : 0xAAAAAAAA;\n\tstruct sock_filter filter_process[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_prctl, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, kill),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog_process = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter_process),\n\t\t.filter = filter_process,\n\t};\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tASSERT_EQ(0, seccomp(SECCOMP_SET_MODE_FILTER, 0,\n\t\t\t     kill_how == KILL_THREAD ? &prog_thread\n\t\t\t\t\t\t     : &prog_process));\n\n\t \n\tif (kill_how == KILL_PROCESS)\n\t\tASSERT_EQ(0, seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog_thread));\n\n\t \n\tASSERT_EQ(0, pthread_create(&thread, NULL, kill_thread, (void *)false));\n\tASSERT_EQ(0, pthread_join(thread, &status));\n\tASSERT_EQ(SIBLING_EXIT_UNKILLED, (unsigned long)status);\n\n\t \n\tASSERT_EQ(0, pthread_create(&thread, NULL, kill_thread, (void *)true));\n\tASSERT_EQ(0, pthread_join(thread, &status));\n\tASSERT_NE(SIBLING_EXIT_FAILURE, (unsigned long)status);\n\n\t \n\texit(42);\n}\n\nTEST(KILL_thread)\n{\n\tint status;\n\tpid_t child_pid;\n\n\tchild_pid = fork();\n\tASSERT_LE(0, child_pid);\n\tif (child_pid == 0) {\n\t\tkill_thread_or_group(_metadata, KILL_THREAD);\n\t\t_exit(38);\n\t}\n\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\n\t \n\tASSERT_TRUE(WIFEXITED(status));\n\tASSERT_EQ(42, WEXITSTATUS(status));\n}\n\nTEST(KILL_process)\n{\n\tint status;\n\tpid_t child_pid;\n\n\tchild_pid = fork();\n\tASSERT_LE(0, child_pid);\n\tif (child_pid == 0) {\n\t\tkill_thread_or_group(_metadata, KILL_PROCESS);\n\t\t_exit(38);\n\t}\n\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\n\t \n\tASSERT_TRUE(WIFSIGNALED(status));\n\tASSERT_EQ(SIGSYS, WTERMSIG(status));\n}\n\nTEST(KILL_unknown)\n{\n\tint status;\n\tpid_t child_pid;\n\n\tchild_pid = fork();\n\tASSERT_LE(0, child_pid);\n\tif (child_pid == 0) {\n\t\tkill_thread_or_group(_metadata, RET_UNKNOWN);\n\t\t_exit(38);\n\t}\n\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\n\t \n\tEXPECT_TRUE(WIFSIGNALED(status)) {\n\t\tTH_LOG(\"Unknown SECCOMP_RET is only killing the thread?\");\n\t}\n\tASSERT_EQ(SIGSYS, WTERMSIG(status));\n}\n\n \nTEST(arg_out_of_range)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS, syscall_arg(6)),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno);\n}\n\n#define ERRNO_FILTER(name, errno)\t\t\t\t\t\\\n\tstruct sock_filter _read_filter_##name[] = {\t\t\t\\\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\t\t\t\t\\\n\t\t\toffsetof(struct seccomp_data, nr)),\t\t\\\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_read, 0, 1),\t\\\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO | errno),\t\\\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tstruct sock_fprog prog_##name = {\t\t\t\t\\\n\t\t.len = (unsigned short)ARRAY_SIZE(_read_filter_##name),\t\\\n\t\t.filter = _read_filter_##name,\t\t\t\t\\\n\t}\n\n \nTEST(ERRNO_valid)\n{\n\tERRNO_FILTER(valid, E2BIG);\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_valid);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_EQ(-1, read(-1, NULL, 0));\n\tEXPECT_EQ(E2BIG, errno);\n}\n\n \nTEST(ERRNO_zero)\n{\n\tERRNO_FILTER(zero, 0);\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_zero);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, read(-1, NULL, 0));\n}\n\n \nTEST(ERRNO_capped)\n{\n\tERRNO_FILTER(capped, 4096);\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_capped);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_EQ(-1, read(-1, NULL, 0));\n\tEXPECT_EQ(4095, errno);\n}\n\n \nTEST(ERRNO_order)\n{\n\tERRNO_FILTER(first,  11);\n\tERRNO_FILTER(second, 13);\n\tERRNO_FILTER(third,  12);\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_first);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_second);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_third);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_EQ(-1, read(-1, NULL, 0));\n\tEXPECT_EQ(12, errno);\n}\n\nFIXTURE(TRAP) {\n\tstruct sock_fprog prog;\n};\n\nFIXTURE_SETUP(TRAP)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRAP),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tmemset(&self->prog, 0, sizeof(self->prog));\n\tself->prog.filter = malloc(sizeof(filter));\n\tASSERT_NE(NULL, self->prog.filter);\n\tmemcpy(self->prog.filter, filter, sizeof(filter));\n\tself->prog.len = (unsigned short)ARRAY_SIZE(filter);\n}\n\nFIXTURE_TEARDOWN(TRAP)\n{\n\tif (self->prog.filter)\n\t\tfree(self->prog.filter);\n}\n\nTEST_F_SIGNAL(TRAP, dfl, SIGSYS)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->prog);\n\tASSERT_EQ(0, ret);\n\tsyscall(__NR_getpid);\n}\n\n \nTEST_F_SIGNAL(TRAP, ign, SIGSYS)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tsignal(SIGSYS, SIG_IGN);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->prog);\n\tASSERT_EQ(0, ret);\n\tsyscall(__NR_getpid);\n}\n\nstatic siginfo_t TRAP_info;\nstatic volatile int TRAP_nr;\nstatic void TRAP_action(int nr, siginfo_t *info, void *void_context)\n{\n\tmemcpy(&TRAP_info, info, sizeof(TRAP_info));\n\tTRAP_nr = nr;\n}\n\nTEST_F(TRAP, handler)\n{\n\tint ret, test;\n\tstruct sigaction act;\n\tsigset_t mask;\n\n\tmemset(&act, 0, sizeof(act));\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGSYS);\n\n\tact.sa_sigaction = &TRAP_action;\n\tact.sa_flags = SA_SIGINFO;\n\tret = sigaction(SIGSYS, &act, NULL);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"sigaction failed\");\n\t}\n\tret = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"sigprocmask failed\");\n\t}\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->prog);\n\tASSERT_EQ(0, ret);\n\tTRAP_nr = 0;\n\tmemset(&TRAP_info, 0, sizeof(TRAP_info));\n\t \n\tret = syscall(__NR_getpid);\n\t \n\ttest = TRAP_nr;\n\tEXPECT_EQ(SIGSYS, test);\n\tstruct local_sigsys {\n\t\tvoid *_call_addr;\t \n\t\tint _syscall;\t\t \n\t\tunsigned int _arch;\t \n\t} *sigsys = (struct local_sigsys *)\n#ifdef si_syscall\n\t\t&(TRAP_info.si_call_addr);\n#else\n\t\t&TRAP_info.si_pid;\n#endif\n\tEXPECT_EQ(__NR_getpid, sigsys->_syscall);\n\t \n\tEXPECT_NE(0, sigsys->_arch);\n\tEXPECT_NE(0, (unsigned long)sigsys->_call_addr);\n}\n\nFIXTURE(precedence) {\n\tstruct sock_fprog allow;\n\tstruct sock_fprog log;\n\tstruct sock_fprog trace;\n\tstruct sock_fprog error;\n\tstruct sock_fprog trap;\n\tstruct sock_fprog kill;\n};\n\nFIXTURE_SETUP(precedence)\n{\n\tstruct sock_filter allow_insns[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_filter log_insns[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_LOG),\n\t};\n\tstruct sock_filter trace_insns[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE),\n\t};\n\tstruct sock_filter error_insns[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO),\n\t};\n\tstruct sock_filter trap_insns[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRAP),\n\t};\n\tstruct sock_filter kill_insns[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 1, 0),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t};\n\n\tmemset(self, 0, sizeof(*self));\n#define FILTER_ALLOC(_x) \\\n\tself->_x.filter = malloc(sizeof(_x##_insns)); \\\n\tASSERT_NE(NULL, self->_x.filter); \\\n\tmemcpy(self->_x.filter, &_x##_insns, sizeof(_x##_insns)); \\\n\tself->_x.len = (unsigned short)ARRAY_SIZE(_x##_insns)\n\tFILTER_ALLOC(allow);\n\tFILTER_ALLOC(log);\n\tFILTER_ALLOC(trace);\n\tFILTER_ALLOC(error);\n\tFILTER_ALLOC(trap);\n\tFILTER_ALLOC(kill);\n}\n\nFIXTURE_TEARDOWN(precedence)\n{\n#define FILTER_FREE(_x) if (self->_x.filter) free(self->_x.filter)\n\tFILTER_FREE(allow);\n\tFILTER_FREE(log);\n\tFILTER_FREE(trace);\n\tFILTER_FREE(error);\n\tFILTER_FREE(trap);\n\tFILTER_FREE(kill);\n}\n\nTEST_F(precedence, allow_ok)\n{\n\tpid_t parent, res = 0;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trap);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->kill);\n\tASSERT_EQ(0, ret);\n\t \n\tres = syscall(__NR_getppid);\n\tEXPECT_EQ(parent, res);\n}\n\nTEST_F_SIGNAL(precedence, kill_is_highest, SIGSYS)\n{\n\tpid_t parent, res = 0;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trap);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->kill);\n\tASSERT_EQ(0, ret);\n\t \n\tres = syscall(__NR_getppid);\n\tEXPECT_EQ(parent, res);\n\t \n\tres = syscall(__NR_getpid);\n\tEXPECT_EQ(0, res);\n}\n\nTEST_F_SIGNAL(precedence, kill_is_highest_in_any_order, SIGSYS)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->kill);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trap);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_F_SIGNAL(precedence, trap_is_second, SIGSYS)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trap);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_F_SIGNAL(precedence, trap_is_second_in_any_order, SIGSYS)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trap);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, errno_is_third)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, errno_is_third_in_any_order)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->error);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, trace_is_fourth)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(-1, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, trace_is_fourth_in_any_order)\n{\n\tpid_t parent;\n\tlong ret;\n\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->trace);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(-1, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, log_is_fifth)\n{\n\tpid_t mypid, parent;\n\tlong ret;\n\n\tmypid = getpid();\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(mypid, syscall(__NR_getpid));\n}\n\nTEST_F(precedence, log_is_fifth_in_any_order)\n{\n\tpid_t mypid, parent;\n\tlong ret;\n\n\tmypid = getpid();\n\tparent = getppid();\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->log);\n\tASSERT_EQ(0, ret);\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->allow);\n\tASSERT_EQ(0, ret);\n\t \n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(mypid, syscall(__NR_getpid));\n}\n\n#ifndef PTRACE_O_TRACESECCOMP\n#define PTRACE_O_TRACESECCOMP\t0x00000080\n#endif\n\n \n#if PTRACE_EVENT_SECCOMP != 7\n#undef PTRACE_EVENT_SECCOMP\n#endif\n\n#ifndef PTRACE_EVENT_SECCOMP\n#define PTRACE_EVENT_SECCOMP 7\n#endif\n\n#define PTRACE_EVENT_MASK(status) ((status) >> 16)\nbool tracer_running;\nvoid tracer_stop(int sig)\n{\n\ttracer_running = false;\n}\n\ntypedef void tracer_func_t(struct __test_metadata *_metadata,\n\t\t\t   pid_t tracee, int status, void *args);\n\nvoid start_tracer(struct __test_metadata *_metadata, int fd, pid_t tracee,\n\t    tracer_func_t tracer_func, void *args, bool ptrace_syscall)\n{\n\tint ret = -1;\n\tstruct sigaction action = {\n\t\t.sa_handler = tracer_stop,\n\t};\n\n\t \n\ttracer_running = true;\n\tASSERT_EQ(0, sigaction(SIGUSR1, &action, NULL));\n\n\terrno = 0;\n\twhile (ret == -1 && errno != EINVAL)\n\t\tret = ptrace(PTRACE_ATTACH, tracee, NULL, 0);\n\tASSERT_EQ(0, ret) {\n\t\tkill(tracee, SIGKILL);\n\t}\n\t \n\twait(NULL);\n\n\tret = ptrace(PTRACE_SETOPTIONS, tracee, NULL, ptrace_syscall ?\n\t\t\t\t\t\t      PTRACE_O_TRACESYSGOOD :\n\t\t\t\t\t\t      PTRACE_O_TRACESECCOMP);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Failed to set PTRACE_O_TRACESECCOMP\");\n\t\tkill(tracee, SIGKILL);\n\t}\n\tret = ptrace(ptrace_syscall ? PTRACE_SYSCALL : PTRACE_CONT,\n\t\t     tracee, NULL, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\tASSERT_EQ(1, write(fd, \"A\", 1));\n\tASSERT_EQ(0, close(fd));\n\n\t \n\twhile (tracer_running) {\n\t\tint status;\n\n\t\tif (wait(&status) != tracee)\n\t\t\tcontinue;\n\n\t\tif (WIFSIGNALED(status)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tif (WIFEXITED(status)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tASSERT_EQ(WIFCONTINUED(status), false);\n\t\tASSERT_EQ(WIFSTOPPED(status), true);\n\t\tASSERT_EQ(WSTOPSIG(status) & SIGTRAP, SIGTRAP) {\n\t\t\tTH_LOG(\"Unexpected WSTOPSIG: %d\", WSTOPSIG(status));\n\t\t}\n\n\t\ttracer_func(_metadata, tracee, status, args);\n\n\t\tret = ptrace(ptrace_syscall ? PTRACE_SYSCALL : PTRACE_CONT,\n\t\t\t     tracee, NULL, 0);\n\t\tASSERT_EQ(0, ret);\n\t}\n\t \n\tsyscall(__NR_exit, _metadata->passed ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n\n \nvoid cont_handler(int num)\n{ }\npid_t setup_trace_fixture(struct __test_metadata *_metadata,\n\t\t\t  tracer_func_t func, void *args, bool ptrace_syscall)\n{\n\tchar sync;\n\tint pipefd[2];\n\tpid_t tracer_pid;\n\tpid_t tracee = getpid();\n\n\t \n\tASSERT_EQ(0, pipe(pipefd));\n\n\t \n\ttracer_pid = fork();\n\tASSERT_LE(0, tracer_pid);\n\tsignal(SIGALRM, cont_handler);\n\tif (tracer_pid == 0) {\n\t\tclose(pipefd[0]);\n\t\tstart_tracer(_metadata, pipefd[1], tracee, func, args,\n\t\t\t     ptrace_syscall);\n\t\tsyscall(__NR_exit, 0);\n\t}\n\tclose(pipefd[1]);\n\tprctl(PR_SET_PTRACER, tracer_pid, 0, 0, 0);\n\tread(pipefd[0], &sync, 1);\n\tclose(pipefd[0]);\n\n\treturn tracer_pid;\n}\n\nvoid teardown_trace_fixture(struct __test_metadata *_metadata,\n\t\t\t    pid_t tracer)\n{\n\tif (tracer) {\n\t\tint status;\n\t\t \n\t\tASSERT_EQ(0, kill(tracer, SIGUSR1));\n\t\tASSERT_EQ(tracer, waitpid(tracer, &status, 0));\n\t\tif (WEXITSTATUS(status))\n\t\t\t_metadata->passed = 0;\n\t}\n}\n\n \nstruct tracer_args_poke_t {\n\tunsigned long poke_addr;\n};\n\nvoid tracer_poke(struct __test_metadata *_metadata, pid_t tracee, int status,\n\t\t void *args)\n{\n\tint ret;\n\tunsigned long msg;\n\tstruct tracer_args_poke_t *info = (struct tracer_args_poke_t *)args;\n\n\tret = ptrace(PTRACE_GETEVENTMSG, tracee, NULL, &msg);\n\tEXPECT_EQ(0, ret);\n\t \n\tASSERT_EQ(0x1001, msg) {\n\t\tkill(tracee, SIGKILL);\n\t}\n\t \n\tret = ptrace(PTRACE_POKEDATA, tracee, info->poke_addr, 0x1001);\n\tEXPECT_EQ(0, ret);\n}\n\nFIXTURE(TRACE_poke) {\n\tstruct sock_fprog prog;\n\tpid_t tracer;\n\tlong poked;\n\tstruct tracer_args_poke_t tracer_args;\n};\n\nFIXTURE_SETUP(TRACE_poke)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_read, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE | 0x1001),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tself->poked = 0;\n\tmemset(&self->prog, 0, sizeof(self->prog));\n\tself->prog.filter = malloc(sizeof(filter));\n\tASSERT_NE(NULL, self->prog.filter);\n\tmemcpy(self->prog.filter, filter, sizeof(filter));\n\tself->prog.len = (unsigned short)ARRAY_SIZE(filter);\n\n\t \n\tself->tracer_args.poke_addr = (unsigned long)&self->poked;\n\n\t \n\tself->tracer = setup_trace_fixture(_metadata, tracer_poke,\n\t\t\t\t\t   &self->tracer_args, false);\n}\n\nFIXTURE_TEARDOWN(TRACE_poke)\n{\n\tteardown_trace_fixture(_metadata, self->tracer);\n\tif (self->prog.filter)\n\t\tfree(self->prog.filter);\n}\n\nTEST_F(TRACE_poke, read_has_side_effects)\n{\n\tssize_t ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(0, self->poked);\n\tret = read(-1, NULL, 0);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(0x1001, self->poked);\n}\n\nTEST_F(TRACE_poke, getpid_runs_normally)\n{\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &self->prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\tEXPECT_EQ(0, self->poked);\n\tEXPECT_NE(0, syscall(__NR_getpid));\n\tEXPECT_EQ(0, self->poked);\n}\n\n#if defined(__x86_64__)\n# define ARCH_REGS\t\tstruct user_regs_struct\n# define SYSCALL_NUM(_regs)\t(_regs).orig_rax\n# define SYSCALL_RET(_regs)\t(_regs).rax\n#elif defined(__i386__)\n# define ARCH_REGS\t\tstruct user_regs_struct\n# define SYSCALL_NUM(_regs)\t(_regs).orig_eax\n# define SYSCALL_RET(_regs)\t(_regs).eax\n#elif defined(__arm__)\n# define ARCH_REGS\t\tstruct pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).ARM_r7\n# ifndef PTRACE_SET_SYSCALL\n#  define PTRACE_SET_SYSCALL   23\n# endif\n# define SYSCALL_NUM_SET(_regs, _nr)\t\\\n\t\tEXPECT_EQ(0, ptrace(PTRACE_SET_SYSCALL, tracee, NULL, _nr))\n# define SYSCALL_RET(_regs)\t(_regs).ARM_r0\n#elif defined(__aarch64__)\n# define ARCH_REGS\t\tstruct user_pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).regs[8]\n# ifndef NT_ARM_SYSTEM_CALL\n#  define NT_ARM_SYSTEM_CALL 0x404\n# endif\n# define SYSCALL_NUM_SET(_regs, _nr)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstruct iovec __v;\t\t\t\t\\\n\t\ttypeof(_nr) __nr = (_nr);\t\t\t\\\n\t\t__v.iov_base = &__nr;\t\t\t\t\\\n\t\t__v.iov_len = sizeof(__nr);\t\t\t\\\n\t\tEXPECT_EQ(0, ptrace(PTRACE_SETREGSET, tracee,\t\\\n\t\t\t\t    NT_ARM_SYSTEM_CALL, &__v));\t\\\n\t} while (0)\n# define SYSCALL_RET(_regs)\t(_regs).regs[0]\n#elif defined(__loongarch__)\n# define ARCH_REGS\t\tstruct user_pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).regs[11]\n# define SYSCALL_RET(_regs)\t(_regs).regs[4]\n#elif defined(__riscv) && __riscv_xlen == 64\n# define ARCH_REGS\t\tstruct user_regs_struct\n# define SYSCALL_NUM(_regs)\t(_regs).a7\n# define SYSCALL_RET(_regs)\t(_regs).a0\n#elif defined(__csky__)\n# define ARCH_REGS\t\tstruct pt_regs\n#  if defined(__CSKYABIV2__)\n#   define SYSCALL_NUM(_regs)\t(_regs).regs[3]\n#  else\n#   define SYSCALL_NUM(_regs)\t(_regs).regs[9]\n#  endif\n# define SYSCALL_RET(_regs)\t(_regs).a0\n#elif defined(__hppa__)\n# define ARCH_REGS\t\tstruct user_regs_struct\n# define SYSCALL_NUM(_regs)\t(_regs).gr[20]\n# define SYSCALL_RET(_regs)\t(_regs).gr[28]\n#elif defined(__powerpc__)\n# define ARCH_REGS\t\tstruct pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).gpr[0]\n# define SYSCALL_RET(_regs)\t(_regs).gpr[3]\n# define SYSCALL_RET_SET(_regs, _val)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypeof(_val) _result = (_val);\t\t\t\\\n\t\tif ((_regs.trap & 0xfff0) == 0x3000) {\t\t\\\n\t\t\t \t\t\t\t\t\\\n\t\t\tSYSCALL_RET(_regs) = _result;\t\t\\\n\t\t} else {\t\t\t\t\t\\\n\t\t\t \t\t\t\t\t\\\n\t\t\tif (_result < 0) {\t\t\t\\\n\t\t\t\tSYSCALL_RET(_regs) = -_result;\t\\\n\t\t\t\t(_regs).ccr |= 0x10000000;\t\\\n\t\t\t} else {\t\t\t\t\\\n\t\t\t\tSYSCALL_RET(_regs) = _result;\t\\\n\t\t\t\t(_regs).ccr &= ~0x10000000;\t\\\n\t\t\t}\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n# define SYSCALL_RET_SET_ON_PTRACE_EXIT\n#elif defined(__s390__)\n# define ARCH_REGS\t\ts390_regs\n# define SYSCALL_NUM(_regs)\t(_regs).gprs[2]\n# define SYSCALL_RET_SET(_regs, _val)\t\t\t\\\n\t\tTH_LOG(\"Can't modify syscall return on this architecture\")\n#elif defined(__mips__)\n# include <asm/unistd_nr_n32.h>\n# include <asm/unistd_nr_n64.h>\n# include <asm/unistd_nr_o32.h>\n# define ARCH_REGS\t\tstruct pt_regs\n# define SYSCALL_NUM(_regs)\t\t\t\t\\\n\t({\t\t\t\t\t\t\\\n\t\ttypeof((_regs).regs[2]) _nr;\t\t\\\n\t\tif ((_regs).regs[2] == __NR_O32_Linux)\t\\\n\t\t\t_nr = (_regs).regs[4];\t\t\\\n\t\telse\t\t\t\t\t\\\n\t\t\t_nr = (_regs).regs[2];\t\t\\\n\t\t_nr;\t\t\t\t\t\\\n\t})\n# define SYSCALL_NUM_SET(_regs, _nr)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((_regs).regs[2] == __NR_O32_Linux)\t\\\n\t\t\t(_regs).regs[4] = _nr;\t\t\\\n\t\telse\t\t\t\t\t\\\n\t\t\t(_regs).regs[2] = _nr;\t\t\\\n\t} while (0)\n# define SYSCALL_RET_SET(_regs, _val)\t\t\t\\\n\t\tTH_LOG(\"Can't modify syscall return on this architecture\")\n#elif defined(__xtensa__)\n# define ARCH_REGS\t\tstruct user_pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).syscall\n \n#define SYSCALL_RET(_regs)\t(_regs).a[(_regs).windowbase * 4 + 2]\n#elif defined(__sh__)\n# define ARCH_REGS\t\tstruct pt_regs\n# define SYSCALL_NUM(_regs)\t(_regs).regs[3]\n# define SYSCALL_RET(_regs)\t(_regs).regs[0]\n#elif defined(__mc68000__)\n# define ARCH_REGS\t\tstruct user_regs_struct\n# define SYSCALL_NUM(_regs)\t(_regs).orig_d0\n# define SYSCALL_RET(_regs)\t(_regs).d0\n#else\n# error \"Do not know how to find your architecture's registers and syscalls\"\n#endif\n\n \n#ifndef SYSCALL_NUM_SET\n# define SYSCALL_NUM_SET(_regs, _nr)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tSYSCALL_NUM(_regs) = (_nr);\t\\\n\t} while (0)\n#endif\n \n#if !defined(SYSCALL_RET) && !defined(SYSCALL_RET_SET)\n# error \"One of SYSCALL_RET or SYSCALL_RET_SET is needed for this arch\"\n#endif\n#ifndef SYSCALL_RET_SET\n# define SYSCALL_RET_SET(_regs, _val)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tSYSCALL_RET(_regs) = (_val);\t\\\n\t} while (0)\n#endif\n\n \n#ifndef SYSCALL_RET\n# define EXPECT_SYSCALL_RETURN(val, action)\tEXPECT_EQ(-1, action)\n#else\n# define EXPECT_SYSCALL_RETURN(val, action)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\terrno = 0;\t\t\t\t\\\n\t\tif (val < 0) {\t\t\t\t\\\n\t\t\tEXPECT_EQ(-1, action);\t\t\\\n\t\t\tEXPECT_EQ(-(val), errno);\t\\\n\t\t} else {\t\t\t\t\\\n\t\t\tEXPECT_EQ(val, action);\t\t\\\n\t\t}\t\t\t\t\t\\\n\t} while (0)\n#endif\n\n \nconst bool ptrace_entry_set_syscall_nr = true;\nconst bool ptrace_entry_set_syscall_ret =\n#ifndef SYSCALL_RET_SET_ON_PTRACE_EXIT\n\ttrue;\n#else\n\tfalse;\n#endif\n\n \n#if defined(__x86_64__) || defined(__i386__) || defined(__mips__) || defined(__mc68000__)\n# define ARCH_GETREGS(_regs)\tptrace(PTRACE_GETREGS, tracee, 0, &(_regs))\n# define ARCH_SETREGS(_regs)\tptrace(PTRACE_SETREGS, tracee, 0, &(_regs))\n#else\n# define ARCH_GETREGS(_regs)\t({\t\t\t\t\t\\\n\t\tstruct iovec __v;\t\t\t\t\t\\\n\t\t__v.iov_base = &(_regs);\t\t\t\t\\\n\t\t__v.iov_len = sizeof(_regs);\t\t\t\t\\\n\t\tptrace(PTRACE_GETREGSET, tracee, NT_PRSTATUS, &__v);\t\\\n\t})\n# define ARCH_SETREGS(_regs)\t({\t\t\t\t\t\\\n\t\tstruct iovec __v;\t\t\t\t\t\\\n\t\t__v.iov_base = &(_regs);\t\t\t\t\\\n\t\t__v.iov_len = sizeof(_regs);\t\t\t\t\\\n\t\tptrace(PTRACE_SETREGSET, tracee, NT_PRSTATUS, &__v);\t\\\n\t})\n#endif\n\n \nint get_syscall(struct __test_metadata *_metadata, pid_t tracee)\n{\n\tARCH_REGS regs;\n\n\tEXPECT_EQ(0, ARCH_GETREGS(regs)) {\n\t\treturn -1;\n\t}\n\n\treturn SYSCALL_NUM(regs);\n}\n\n \nvoid __change_syscall(struct __test_metadata *_metadata,\n\t\t    pid_t tracee, long *syscall, long *ret)\n{\n\tARCH_REGS orig, regs;\n\n\t \n\tif (!syscall && !ret)\n\t\treturn;\n\n\tEXPECT_EQ(0, ARCH_GETREGS(regs)) {\n\t\treturn;\n\t}\n\torig = regs;\n\n\tif (syscall)\n\t\tSYSCALL_NUM_SET(regs, *syscall);\n\n\tif (ret)\n\t\tSYSCALL_RET_SET(regs, *ret);\n\n\t \n\tif (memcmp(&orig, &regs, sizeof(orig)) != 0)\n\t\tEXPECT_EQ(0, ARCH_SETREGS(regs));\n}\n\n \nvoid change_syscall_nr(struct __test_metadata *_metadata,\n\t\t       pid_t tracee, long syscall)\n{\n\t__change_syscall(_metadata, tracee, &syscall, NULL);\n}\n\n \nvoid change_syscall_ret(struct __test_metadata *_metadata,\n\t\t\tpid_t tracee, long ret)\n{\n\tlong syscall = -1;\n\n\t__change_syscall(_metadata, tracee, &syscall, &ret);\n}\n\nvoid tracer_seccomp(struct __test_metadata *_metadata, pid_t tracee,\n\t\t    int status, void *args)\n{\n\tint ret;\n\tunsigned long msg;\n\n\tEXPECT_EQ(PTRACE_EVENT_MASK(status), PTRACE_EVENT_SECCOMP) {\n\t\tTH_LOG(\"Unexpected ptrace event: %d\", PTRACE_EVENT_MASK(status));\n\t\treturn;\n\t}\n\n\t \n\tret = ptrace(PTRACE_GETEVENTMSG, tracee, NULL, &msg);\n\tEXPECT_EQ(0, ret);\n\n\t \n\tswitch (msg) {\n\tcase 0x1002:\n\t\t \n\t\tEXPECT_EQ(__NR_getpid, get_syscall(_metadata, tracee));\n\t\tchange_syscall_nr(_metadata, tracee, __NR_getppid);\n\t\tbreak;\n\tcase 0x1003:\n\t\t \n\t\tEXPECT_EQ(__NR_gettid, get_syscall(_metadata, tracee));\n\t\tchange_syscall_ret(_metadata, tracee, 45000);\n\t\tbreak;\n\tcase 0x1004:\n\t\t \n\t\tEXPECT_EQ(__NR_openat, get_syscall(_metadata, tracee));\n\t\tchange_syscall_ret(_metadata, tracee, -ESRCH);\n\t\tbreak;\n\tcase 0x1005:\n\t\t \n\t\tEXPECT_EQ(__NR_getppid, get_syscall(_metadata, tracee));\n\t\tbreak;\n\tdefault:\n\t\tEXPECT_EQ(0, msg) {\n\t\t\tTH_LOG(\"Unknown PTRACE_GETEVENTMSG: 0x%lx\", msg);\n\t\t\tkill(tracee, SIGKILL);\n\t\t}\n\t}\n\n}\n\nFIXTURE(TRACE_syscall) {\n\tstruct sock_fprog prog;\n\tpid_t tracer, mytid, mypid, parent;\n\tlong syscall_nr;\n};\n\nvoid tracer_ptrace(struct __test_metadata *_metadata, pid_t tracee,\n\t\t   int status, void *args)\n{\n\tint ret;\n\tunsigned long msg;\n\tstatic bool entry;\n\tlong syscall_nr_val, syscall_ret_val;\n\tlong *syscall_nr = NULL, *syscall_ret = NULL;\n\tFIXTURE_DATA(TRACE_syscall) *self = args;\n\n\tEXPECT_EQ(WSTOPSIG(status) & 0x80, 0x80) {\n\t\tTH_LOG(\"Unexpected WSTOPSIG: %d\", WSTOPSIG(status));\n\t\treturn;\n\t}\n\n\t \n\tentry = !entry;\n\n\t \n\tret = ptrace(PTRACE_GETEVENTMSG, tracee, NULL, &msg);\n\tEXPECT_EQ(0, ret);\n\tEXPECT_EQ(entry ? PTRACE_EVENTMSG_SYSCALL_ENTRY\n\t\t\t: PTRACE_EVENTMSG_SYSCALL_EXIT, msg);\n\n\t \n\tif (entry)\n\t\tself->syscall_nr = get_syscall(_metadata, tracee);\n\n\t \n\tif (entry == ptrace_entry_set_syscall_nr)\n\t\tsyscall_nr = &syscall_nr_val;\n\tif (entry == ptrace_entry_set_syscall_ret)\n\t\tsyscall_ret = &syscall_ret_val;\n\n\t \n\tswitch (self->syscall_nr) {\n\tcase __NR_getpid:\n\t\tsyscall_nr_val = __NR_getppid;\n\t\t \n\t\tsyscall_ret = NULL;\n\t\tbreak;\n\tcase __NR_gettid:\n\t\tsyscall_nr_val = -1;\n\t\tsyscall_ret_val = 45000;\n\t\tbreak;\n\tcase __NR_openat:\n\t\tsyscall_nr_val = -1;\n\t\tsyscall_ret_val = -ESRCH;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t__change_syscall(_metadata, tracee, syscall_nr, syscall_ret);\n}\n\nFIXTURE_VARIANT(TRACE_syscall) {\n\t \n\tbool use_ptrace;\n};\n\nFIXTURE_VARIANT_ADD(TRACE_syscall, ptrace) {\n\t.use_ptrace = true,\n};\n\nFIXTURE_VARIANT_ADD(TRACE_syscall, seccomp) {\n\t.use_ptrace = false,\n};\n\nFIXTURE_SETUP(TRACE_syscall)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE | 0x1002),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_gettid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE | 0x1003),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_openat, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE | 0x1004),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getppid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE | 0x1005),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\t \n\tself->mytid = syscall(__NR_gettid);\n\tASSERT_GT(self->mytid, 0);\n\tASSERT_NE(self->mytid, 1) {\n\t\tTH_LOG(\"Running this test as init is not supported. :)\");\n\t}\n\n\tself->mypid = getpid();\n\tASSERT_GT(self->mypid, 0);\n\tASSERT_EQ(self->mytid, self->mypid);\n\n\tself->parent = getppid();\n\tASSERT_GT(self->parent, 0);\n\tASSERT_NE(self->parent, self->mypid);\n\n\t \n\tself->tracer = setup_trace_fixture(_metadata,\n\t\t\t\t\t   variant->use_ptrace ? tracer_ptrace\n\t\t\t\t\t\t\t       : tracer_seccomp,\n\t\t\t\t\t   self, variant->use_ptrace);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\tif (variant->use_ptrace)\n\t\treturn;\n\n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n}\n\nFIXTURE_TEARDOWN(TRACE_syscall)\n{\n\tteardown_trace_fixture(_metadata, self->tracer);\n}\n\nTEST(negative_ENOSYS)\n{\n#if defined(__arm__)\n\tSKIP(return, \"arm32 does not support calling syscall -1\");\n#endif\n\t \n\terrno = 0;\n\tEXPECT_EQ(-1, syscall(-1));\n\tEXPECT_EQ(errno, ENOSYS);\n\t \n\terrno = 0;\n\tEXPECT_EQ(-1, syscall(-101));\n\tEXPECT_EQ(errno, ENOSYS);\n}\n\nTEST_F(TRACE_syscall, negative_ENOSYS)\n{\n\tnegative_ENOSYS(_metadata);\n}\n\nTEST_F(TRACE_syscall, syscall_allowed)\n{\n\t \n\tEXPECT_EQ(self->parent, syscall(__NR_getppid));\n\tEXPECT_NE(self->mypid, syscall(__NR_getppid));\n}\n\nTEST_F(TRACE_syscall, syscall_redirected)\n{\n\t \n\tEXPECT_EQ(self->parent, syscall(__NR_getpid));\n\tEXPECT_NE(self->mypid, syscall(__NR_getpid));\n}\n\nTEST_F(TRACE_syscall, syscall_errno)\n{\n\t \n\tEXPECT_SYSCALL_RETURN(-ESRCH, syscall(__NR_openat));\n}\n\nTEST_F(TRACE_syscall, syscall_faked)\n{\n\t \n\tEXPECT_SYSCALL_RETURN(45000, syscall(__NR_gettid));\n}\n\nTEST_F_SIGNAL(TRACE_syscall, kill_immediate, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_mknodat, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL_THREAD),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\tEXPECT_EQ(-1, syscall(__NR_mknodat, -1, NULL, 0, 0));\n}\n\nTEST_F(TRACE_syscall, skip_after)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getppid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO | EPERM),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\terrno = 0;\n\tEXPECT_EQ(-1, syscall(__NR_getpid));\n\tEXPECT_EQ(EPERM, errno);\n}\n\nTEST_F_SIGNAL(TRACE_syscall, kill_after, SIGSYS)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getppid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\tEXPECT_NE(self->mypid, syscall(__NR_getpid));\n}\n\nTEST(seccomp_syscall)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tret = seccomp(-1, 0, &prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Did not reject crazy op value!\");\n\t}\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_STRICT, -1, NULL);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Did not reject mode strict with flags!\");\n\t}\n\tret = seccomp(SECCOMP_SET_MODE_STRICT, 0, &prog);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Did not reject mode strict with uargs!\");\n\t}\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_FILTER, -1, &prog);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Did not reject crazy filter flags!\");\n\t}\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, NULL);\n\tEXPECT_EQ(EFAULT, errno) {\n\t\tTH_LOG(\"Did not reject NULL filter!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog);\n\tEXPECT_EQ(0, errno) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_SET_MODE_FILTER: %s\",\n\t\t\tstrerror(errno));\n\t}\n}\n\nTEST(seccomp_syscall_mode_lock)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, NULL, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tEXPECT_EQ(0, ret) {\n\t\tTH_LOG(\"Could not install filter!\");\n\t}\n\n\t \n\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, 0, 0, 0);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Switched to mode strict!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_STRICT, 0, NULL);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Switched to mode strict!\");\n\t}\n}\n\n \nTEST(detect_seccomp_filter_flags)\n{\n\tunsigned int flags[] = { SECCOMP_FILTER_FLAG_TSYNC,\n\t\t\t\t SECCOMP_FILTER_FLAG_LOG,\n\t\t\t\t SECCOMP_FILTER_FLAG_SPEC_ALLOW,\n\t\t\t\t SECCOMP_FILTER_FLAG_NEW_LISTENER,\n\t\t\t\t SECCOMP_FILTER_FLAG_TSYNC_ESRCH };\n\tunsigned int exclusive[] = {\n\t\t\t\tSECCOMP_FILTER_FLAG_TSYNC,\n\t\t\t\tSECCOMP_FILTER_FLAG_NEW_LISTENER };\n\tunsigned int flag, all_flags, exclusive_mask;\n\tint i;\n\tlong ret;\n\n\t \n\tfor (i = 0, all_flags = 0; i < ARRAY_SIZE(flags); i++) {\n\t\tint bits = 0;\n\n\t\tflag = flags[i];\n\t\t \n\t\twhile (flag) {\n\t\t\tif (flag & 0x1)\n\t\t\t\tbits ++;\n\t\t\tflag >>= 1;\n\t\t}\n\t\tASSERT_EQ(1, bits);\n\t\tflag = flags[i];\n\n\t\tret = seccomp(SECCOMP_SET_MODE_FILTER, flag, NULL);\n\t\tASSERT_NE(ENOSYS, errno) {\n\t\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t\t}\n\t\tEXPECT_EQ(-1, ret);\n\t\tEXPECT_EQ(EFAULT, errno) {\n\t\t\tTH_LOG(\"Failed to detect that a known-good filter flag (0x%X) is supported!\",\n\t\t\t       flag);\n\t\t}\n\n\t\tall_flags |= flag;\n\t}\n\n\t \n\texclusive_mask = 0;\n\tfor (i = 0; i < ARRAY_SIZE(exclusive); i++)\n\t\texclusive_mask |= exclusive[i];\n\tfor (i = 0; i < ARRAY_SIZE(exclusive); i++) {\n\t\tflag = all_flags & ~exclusive_mask;\n\t\tflag |= exclusive[i];\n\n\t\tret = seccomp(SECCOMP_SET_MODE_FILTER, flag, NULL);\n\t\tEXPECT_EQ(-1, ret);\n\t\tEXPECT_EQ(EFAULT, errno) {\n\t\t\tTH_LOG(\"Failed to detect that all known-good filter flags (0x%X) are supported!\",\n\t\t\t       flag);\n\t\t}\n\t}\n\n\t \n\tflag = -1;\n\tflag &= ~exclusive_mask;\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, flag, NULL);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Failed to detect that an unknown filter flag (0x%X) is unsupported!\",\n\t\t       flag);\n\t}\n\n\t \n\tflag = flags[ARRAY_SIZE(flags) - 1] << 1;\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, flag, NULL);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Failed to detect that an unknown filter flag (0x%X) is unsupported! Does a new flag need to be added to this test?\",\n\t\t       flag);\n\t}\n}\n\nTEST(TSYNC_first)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, NULL, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tEXPECT_EQ(0, ret) {\n\t\tTH_LOG(\"Could not install initial filter with TSYNC!\");\n\t}\n}\n\n#define TSYNC_SIBLINGS 2\nstruct tsync_sibling {\n\tpthread_t tid;\n\tpid_t system_tid;\n\tsem_t *started;\n\tpthread_cond_t *cond;\n\tpthread_mutex_t *mutex;\n\tint diverge;\n\tint num_waits;\n\tstruct sock_fprog *prog;\n\tstruct __test_metadata *metadata;\n};\n\n \n#define PTHREAD_JOIN(tid, status)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint _rc = pthread_join(tid, status);\t\t\t\\\n\t\tif (_rc) {\t\t\t\t\t\t\\\n\t\t\tTH_LOG(\"pthread_join of tid %u failed: %d\\n\",\t\\\n\t\t\t\t(unsigned int)tid, _rc);\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\ttid = 0;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nFIXTURE(TSYNC) {\n\tstruct sock_fprog root_prog, apply_prog;\n\tstruct tsync_sibling sibling[TSYNC_SIBLINGS];\n\tsem_t started;\n\tpthread_cond_t cond;\n\tpthread_mutex_t mutex;\n\tint sibling_count;\n};\n\nFIXTURE_SETUP(TSYNC)\n{\n\tstruct sock_filter root_filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_filter apply_filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_read, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tmemset(&self->root_prog, 0, sizeof(self->root_prog));\n\tmemset(&self->apply_prog, 0, sizeof(self->apply_prog));\n\tmemset(&self->sibling, 0, sizeof(self->sibling));\n\tself->root_prog.filter = malloc(sizeof(root_filter));\n\tASSERT_NE(NULL, self->root_prog.filter);\n\tmemcpy(self->root_prog.filter, &root_filter, sizeof(root_filter));\n\tself->root_prog.len = (unsigned short)ARRAY_SIZE(root_filter);\n\n\tself->apply_prog.filter = malloc(sizeof(apply_filter));\n\tASSERT_NE(NULL, self->apply_prog.filter);\n\tmemcpy(self->apply_prog.filter, &apply_filter, sizeof(apply_filter));\n\tself->apply_prog.len = (unsigned short)ARRAY_SIZE(apply_filter);\n\n\tself->sibling_count = 0;\n\tpthread_mutex_init(&self->mutex, NULL);\n\tpthread_cond_init(&self->cond, NULL);\n\tsem_init(&self->started, 0, 0);\n\tself->sibling[0].tid = 0;\n\tself->sibling[0].cond = &self->cond;\n\tself->sibling[0].started = &self->started;\n\tself->sibling[0].mutex = &self->mutex;\n\tself->sibling[0].diverge = 0;\n\tself->sibling[0].num_waits = 1;\n\tself->sibling[0].prog = &self->root_prog;\n\tself->sibling[0].metadata = _metadata;\n\tself->sibling[1].tid = 0;\n\tself->sibling[1].cond = &self->cond;\n\tself->sibling[1].started = &self->started;\n\tself->sibling[1].mutex = &self->mutex;\n\tself->sibling[1].diverge = 0;\n\tself->sibling[1].prog = &self->root_prog;\n\tself->sibling[1].num_waits = 1;\n\tself->sibling[1].metadata = _metadata;\n}\n\nFIXTURE_TEARDOWN(TSYNC)\n{\n\tint sib = 0;\n\n\tif (self->root_prog.filter)\n\t\tfree(self->root_prog.filter);\n\tif (self->apply_prog.filter)\n\t\tfree(self->apply_prog.filter);\n\n\tfor ( ; sib < self->sibling_count; ++sib) {\n\t\tstruct tsync_sibling *s = &self->sibling[sib];\n\n\t\tif (!s->tid)\n\t\t\tcontinue;\n\t\t \n\t\tpthread_kill(s->tid, 9);\n\t}\n\tpthread_mutex_destroy(&self->mutex);\n\tpthread_cond_destroy(&self->cond);\n\tsem_destroy(&self->started);\n}\n\nvoid *tsync_sibling(void *data)\n{\n\tlong ret = 0;\n\tstruct tsync_sibling *me = data;\n\n\tme->system_tid = syscall(__NR_gettid);\n\n\tpthread_mutex_lock(me->mutex);\n\tif (me->diverge) {\n\t\t \n\t\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER,\n\t\t\t\tme->prog, 0, 0);\n\t}\n\tsem_post(me->started);\n\t \n\tif (ret) {\n\t\tpthread_mutex_unlock(me->mutex);\n\t\treturn (void *)SIBLING_EXIT_FAILURE;\n\t}\n\tdo {\n\t\tpthread_cond_wait(me->cond, me->mutex);\n\t\tme->num_waits = me->num_waits - 1;\n\t} while (me->num_waits);\n\tpthread_mutex_unlock(me->mutex);\n\n\tret = prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0);\n\tif (!ret)\n\t\treturn (void *)SIBLING_EXIT_NEWPRIVS;\n\tread(-1, NULL, 0);\n\treturn (void *)SIBLING_EXIT_UNKILLED;\n}\n\nvoid tsync_start_sibling(struct tsync_sibling *sibling)\n{\n\tpthread_create(&sibling->tid, NULL, tsync_sibling, (void *)sibling);\n}\n\nTEST_F(TSYNC, siblings_fail_prctl)\n{\n\tlong ret;\n\tvoid *status;\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_prctl, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO | EINVAL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"setting filter failed\");\n\t}\n\n\tself->sibling[0].diverge = 1;\n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_FAILURE, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n}\n\nTEST_F(TSYNC, two_siblings_with_ancestor)\n{\n\tlong ret;\n\tvoid *status;\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &self->root_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_SET_MODE_FILTER!\");\n\t}\n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Could install filter on all threads!\");\n\t}\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(0x0, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(0x0, (long)status);\n}\n\nTEST_F(TSYNC, two_sibling_want_nnp)\n{\n\tvoid *status;\n\n\t \n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_NEWPRIVS, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_NEWPRIVS, (long)status);\n}\n\nTEST_F(TSYNC, two_siblings_with_no_filter)\n{\n\tlong ret;\n\tvoid *status;\n\n\t \n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Could install filter on all threads!\");\n\t}\n\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(0x0, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(0x0, (long)status);\n}\n\nTEST_F(TSYNC, two_siblings_with_one_divergence)\n{\n\tlong ret;\n\tvoid *status;\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &self->root_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_SET_MODE_FILTER!\");\n\t}\n\tself->sibling[0].diverge = 1;\n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_EQ(self->sibling[0].system_tid, ret) {\n\t\tTH_LOG(\"Did not fail on diverged sibling.\");\n\t}\n\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n}\n\nTEST_F(TSYNC, two_siblings_with_one_divergence_no_tid_in_err)\n{\n\tlong ret, flags;\n\tvoid *status;\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &self->root_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_SET_MODE_FILTER!\");\n\t}\n\tself->sibling[0].diverge = 1;\n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\tflags = SECCOMP_FILTER_FLAG_TSYNC | \\\n\t\tSECCOMP_FILTER_FLAG_TSYNC_ESRCH;\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, flags, &self->apply_prog);\n\tASSERT_EQ(ESRCH, errno) {\n\t\tTH_LOG(\"Did not return ESRCH for diverged sibling.\");\n\t}\n\tASSERT_EQ(-1, ret) {\n\t\tTH_LOG(\"Did not fail on diverged sibling.\");\n\t}\n\n\t \n\tpthread_mutex_lock(&self->mutex);\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\n\t \n\tPTHREAD_JOIN(self->sibling[0].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n\tPTHREAD_JOIN(self->sibling[1].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n}\n\nTEST_F(TSYNC, two_siblings_not_under_filter)\n{\n\tlong ret, sib;\n\tvoid *status;\n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tself->sibling[0].diverge = 1;\n\ttsync_start_sibling(&self->sibling[0]);\n\ttsync_start_sibling(&self->sibling[1]);\n\n\twhile (self->sibling_count < TSYNC_SIBLINGS) {\n\t\tsem_wait(&self->started);\n\t\tself->sibling_count++;\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &self->root_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_SET_MODE_FILTER!\");\n\t}\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_EQ(ret, self->sibling[0].system_tid) {\n\t\tTH_LOG(\"Did not fail on diverged sibling.\");\n\t}\n\tsib = 1;\n\tif (ret == self->sibling[0].system_tid)\n\t\tsib = 0;\n\n\tpthread_mutex_lock(&self->mutex);\n\n\t \n\tself->sibling[!sib].num_waits += 1;\n\n\t \n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\tPTHREAD_JOIN(self->sibling[sib].tid, &status);\n\tEXPECT_EQ(SIBLING_EXIT_UNKILLED, (long)status);\n\t \n\twhile (!kill(self->sibling[sib].system_tid, 0))\n\t\tnanosleep(&delay, NULL);\n\t \n\tsib = !sib;\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Expected the remaining sibling to sync\");\n\t};\n\n\tpthread_mutex_lock(&self->mutex);\n\n\t \n\tif (self->sibling[sib].num_waits > 1)\n\t\tself->sibling[sib].num_waits = 1;\n\tASSERT_EQ(0, pthread_cond_broadcast(&self->cond)) {\n\t\tTH_LOG(\"cond broadcast non-zero\");\n\t}\n\tpthread_mutex_unlock(&self->mutex);\n\tPTHREAD_JOIN(self->sibling[sib].tid, &status);\n\tEXPECT_EQ(0, (long)status);\n\t \n\twhile (!kill(self->sibling[sib].system_tid, 0))\n\t\tnanosleep(&delay, NULL);\n\n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,\n\t\t      &self->apply_prog);\n\tASSERT_EQ(0, ret);   \n}\n\n \nTEST(syscall_restart)\n{\n\tlong ret;\n\tunsigned long msg;\n\tpid_t child_pid;\n\tint pipefd[2];\n\tint status;\n\tsiginfo_t info = { };\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\t offsetof(struct seccomp_data, nr)),\n\n#ifdef __NR_sigreturn\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_sigreturn, 7, 0),\n#endif\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_read, 6, 0),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_exit, 5, 0),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_rt_sigreturn, 4, 0),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_nanosleep, 5, 0),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_clock_nanosleep, 4, 0),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_restart_syscall, 4, 0),\n\n\t\t \n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_write, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\t \n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE|0x100),\n\t\t \n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_TRACE|0x200),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n#if defined(__arm__)\n\tstruct utsname utsbuf;\n#endif\n\n\tASSERT_EQ(0, pipe(pipefd));\n\n\tchild_pid = fork();\n\tASSERT_LE(0, child_pid);\n\tif (child_pid == 0) {\n\t\t \n\t\tchar buf = ' ';\n\t\tstruct timespec timeout = { };\n\n\t\t \n\t\tEXPECT_EQ(0, ptrace(PTRACE_TRACEME));\n\t\tEXPECT_EQ(0, raise(SIGSTOP));\n\n\t\tEXPECT_EQ(0, close(pipefd[1]));\n\n\t\tEXPECT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t\t}\n\n\t\tret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, 0, 0);\n\t\tEXPECT_EQ(0, ret) {\n\t\t\tTH_LOG(\"Failed to install filter!\");\n\t\t}\n\n\t\tEXPECT_EQ(1, read(pipefd[0], &buf, 1)) {\n\t\t\tTH_LOG(\"Failed to read() sync from parent\");\n\t\t}\n\t\tEXPECT_EQ('.', buf) {\n\t\t\tTH_LOG(\"Failed to get sync data from read()\");\n\t\t}\n\n\t\t \n\t\ttimeout.tv_sec = 1;\n\t\terrno = 0;\n\t\tEXPECT_EQ(0, nanosleep(&timeout, NULL)) {\n\t\t\tTH_LOG(\"Call to nanosleep() failed (errno %d: %s)\",\n\t\t\t\terrno, strerror(errno));\n\t\t}\n\n\t\t \n\t\tEXPECT_EQ(1, read(pipefd[0], &buf, 1)) {\n\t\t\tTH_LOG(\"Failed final read() from parent\");\n\t\t}\n\t\tEXPECT_EQ('!', buf) {\n\t\t\tTH_LOG(\"Failed to get final data from read()\");\n\t\t}\n\n\t\t \n\t\tsyscall(__NR_exit, _metadata->passed ? EXIT_SUCCESS\n\t\t\t\t\t\t     : EXIT_FAILURE);\n\t}\n\tEXPECT_EQ(0, close(pipefd[0]));\n\n\t \n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tASSERT_EQ(true, WIFSTOPPED(status));\n\tASSERT_EQ(0, ptrace(PTRACE_SETOPTIONS, child_pid, NULL,\n\t\t\t    PTRACE_O_TRACESECCOMP));\n\tASSERT_EQ(0, ptrace(PTRACE_CONT, child_pid, NULL, 0));\n\tASSERT_EQ(1, write(pipefd[1], \".\", 1));\n\n\t \n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tASSERT_EQ(true, WIFSTOPPED(status));\n\tASSERT_EQ(SIGTRAP, WSTOPSIG(status));\n\tASSERT_EQ(PTRACE_EVENT_SECCOMP, (status >> 16));\n\tASSERT_EQ(0, ptrace(PTRACE_GETEVENTMSG, child_pid, NULL, &msg));\n\tASSERT_EQ(0x100, msg);\n\tret = get_syscall(_metadata, child_pid);\n\tEXPECT_TRUE(ret == __NR_nanosleep || ret == __NR_clock_nanosleep);\n\n\t \n\tASSERT_EQ(0, ptrace(PTRACE_GETSIGINFO, child_pid, NULL, &info));\n\tASSERT_EQ(SIGTRAP, info.si_signo);\n\tASSERT_EQ(SIGTRAP | (PTRACE_EVENT_SECCOMP << 8), info.si_code);\n\tEXPECT_EQ(0, info.si_errno);\n\tEXPECT_EQ(getuid(), info.si_uid);\n\t \n\tEXPECT_EQ(child_pid, info.si_pid);\n\n\t \n\tASSERT_EQ(0, kill(child_pid, SIGSTOP));\n\tASSERT_EQ(0, ptrace(PTRACE_CONT, child_pid, NULL, 0));\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tASSERT_EQ(true, WIFSTOPPED(status));\n\tASSERT_EQ(SIGSTOP, WSTOPSIG(status));\n\tASSERT_EQ(0, ptrace(PTRACE_GETSIGINFO, child_pid, NULL, &info));\n\t \n\tEXPECT_EQ(SIGSTOP, info.si_signo);\n\n\t \n\tASSERT_EQ(0, kill(child_pid, SIGCONT));\n\tASSERT_EQ(0, ptrace(PTRACE_CONT, child_pid, NULL, 0));\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tASSERT_EQ(true, WIFSTOPPED(status));\n\tASSERT_EQ(SIGCONT, WSTOPSIG(status));\n\tASSERT_EQ(0, ptrace(PTRACE_CONT, child_pid, NULL, 0));\n\n\t \n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tASSERT_EQ(true, WIFSTOPPED(status));\n\tASSERT_EQ(SIGTRAP, WSTOPSIG(status));\n\tASSERT_EQ(PTRACE_EVENT_SECCOMP, (status >> 16));\n\tASSERT_EQ(0, ptrace(PTRACE_GETEVENTMSG, child_pid, NULL, &msg));\n\n\tASSERT_EQ(0x200, msg);\n\tret = get_syscall(_metadata, child_pid);\n#if defined(__arm__)\n\t \n\tASSERT_EQ(0, uname(&utsbuf));\n\tif (strncmp(utsbuf.machine, \"arm\", 3) == 0) {\n\t\tEXPECT_EQ(__NR_nanosleep, ret);\n\t} else\n#endif\n\t{\n\t\tEXPECT_EQ(__NR_restart_syscall, ret);\n\t}\n\n\t \n\tASSERT_EQ(0, ptrace(PTRACE_CONT, child_pid, NULL, 0));\n\tASSERT_EQ(1, write(pipefd[1], \"!\", 1));\n\tEXPECT_EQ(0, close(pipefd[1]));\n\n\tASSERT_EQ(child_pid, waitpid(child_pid, &status, 0));\n\tif (WIFSIGNALED(status) || WEXITSTATUS(status))\n\t\t_metadata->passed = 0;\n}\n\nTEST_SIGNAL(filter_flag_log, SIGSYS)\n{\n\tstruct sock_filter allow_filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_filter kill_filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_getpid, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_KILL),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog allow_prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(allow_filter),\n\t\t.filter = allow_filter,\n\t};\n\tstruct sock_fprog kill_prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(kill_filter),\n\t\t.filter = kill_filter,\n\t};\n\tlong ret;\n\tpid_t parent = getppid();\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret);\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_STRICT, SECCOMP_FILTER_FLAG_LOG,\n\t\t      &allow_prog);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tEXPECT_NE(0, ret) {\n\t\tTH_LOG(\"Kernel accepted FILTER_FLAG_LOG flag in strict mode!\");\n\t}\n\tEXPECT_EQ(EINVAL, errno) {\n\t\tTH_LOG(\"Kernel returned unexpected errno for FILTER_FLAG_LOG flag in strict mode!\");\n\t}\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_FILTER, 0, &allow_prog);\n\tEXPECT_EQ(0, ret);\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_LOG,\n\t\t      &allow_prog);\n\tASSERT_NE(EINVAL, errno) {\n\t\tTH_LOG(\"Kernel does not support the FILTER_FLAG_LOG flag!\");\n\t}\n\tEXPECT_EQ(0, ret);\n\n\t \n\tret = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_LOG,\n\t\t      &kill_prog);\n\tEXPECT_EQ(0, ret);\n\n\tEXPECT_EQ(parent, syscall(__NR_getppid));\n\t \n\tEXPECT_EQ(0, syscall(__NR_getpid));\n}\n\nTEST(get_action_avail)\n{\n\t__u32 actions[] = { SECCOMP_RET_KILL_THREAD, SECCOMP_RET_TRAP,\n\t\t\t    SECCOMP_RET_ERRNO, SECCOMP_RET_TRACE,\n\t\t\t    SECCOMP_RET_LOG,   SECCOMP_RET_ALLOW };\n\t__u32 unknown_action = 0x10000000U;\n\tint i;\n\tlong ret;\n\n\tret = seccomp(SECCOMP_GET_ACTION_AVAIL, 0, &actions[0]);\n\tASSERT_NE(ENOSYS, errno) {\n\t\tTH_LOG(\"Kernel does not support seccomp syscall!\");\n\t}\n\tASSERT_NE(EINVAL, errno) {\n\t\tTH_LOG(\"Kernel does not support SECCOMP_GET_ACTION_AVAIL operation!\");\n\t}\n\tEXPECT_EQ(ret, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(actions); i++) {\n\t\tret = seccomp(SECCOMP_GET_ACTION_AVAIL, 0, &actions[i]);\n\t\tEXPECT_EQ(ret, 0) {\n\t\t\tTH_LOG(\"Expected action (0x%X) not available!\",\n\t\t\t       actions[i]);\n\t\t}\n\t}\n\n\t \n\tret = seccomp(SECCOMP_GET_ACTION_AVAIL, 0, &unknown_action);\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, EOPNOTSUPP);\n}\n\nTEST(get_metadata)\n{\n\tpid_t pid;\n\tint pipefd[2];\n\tchar buf;\n\tstruct seccomp_metadata md;\n\tlong ret;\n\n\t \n\tif (geteuid()) {\n\t\tSKIP(return, \"get_metadata requires real root\");\n\t\treturn;\n\t}\n\n\tASSERT_EQ(0, pipe(pipefd));\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\tif (pid == 0) {\n\t\tstruct sock_filter filter[] = {\n\t\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t\t};\n\t\tstruct sock_fprog prog = {\n\t\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t\t.filter = filter,\n\t\t};\n\n\t\t \n\t\tEXPECT_EQ(0, seccomp(SECCOMP_SET_MODE_FILTER,\n\t\t\t\t     SECCOMP_FILTER_FLAG_LOG, &prog));\n\t\tEXPECT_EQ(0, seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog));\n\n\t\tEXPECT_EQ(0, close(pipefd[0]));\n\t\tASSERT_EQ(1, write(pipefd[1], \"1\", 1));\n\t\tASSERT_EQ(0, close(pipefd[1]));\n\n\t\twhile (1)\n\t\t\tsleep(100);\n\t}\n\n\tASSERT_EQ(0, close(pipefd[1]));\n\tASSERT_EQ(1, read(pipefd[0], &buf, 1));\n\n\tASSERT_EQ(0, ptrace(PTRACE_ATTACH, pid));\n\tASSERT_EQ(pid, waitpid(pid, NULL, 0));\n\n\t \n\n\tmd.filter_off = 0;\n\terrno = 0;\n\tret = ptrace(PTRACE_SECCOMP_GET_METADATA, pid, sizeof(md), &md);\n\tEXPECT_EQ(sizeof(md), ret) {\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(goto skip, \"Kernel does not support PTRACE_SECCOMP_GET_METADATA (missing CONFIG_CHECKPOINT_RESTORE?)\");\n\t}\n\n\tEXPECT_EQ(md.flags, SECCOMP_FILTER_FLAG_LOG);\n\tEXPECT_EQ(md.filter_off, 0);\n\n\tmd.filter_off = 1;\n\tret = ptrace(PTRACE_SECCOMP_GET_METADATA, pid, sizeof(md), &md);\n\tEXPECT_EQ(sizeof(md), ret);\n\tEXPECT_EQ(md.flags, 0);\n\tEXPECT_EQ(md.filter_off, 1);\n\nskip:\n\tASSERT_EQ(0, kill(pid, SIGKILL));\n}\n\nstatic int user_notif_syscall(int nr, unsigned int flags)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, nr, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_USER_NOTIF),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\treturn seccomp(SECCOMP_SET_MODE_FILTER, flags, &prog);\n}\n\n#define USER_NOTIF_MAGIC INT_MAX\nTEST(user_notification_basic)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\tstruct pollfd pollfd;\n\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\t \n\tif (pid == 0) {\n\t\tif (user_notif_syscall(__NR_getppid, 0) < 0)\n\t\t\texit(1);\n\t\tret = syscall(__NR_getppid);\n\t\texit(ret >= 0 || errno != ENOSYS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\t \n\tEXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);\n\tEXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);\n\tEXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);\n\tEXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);\n\n\t \n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\t \n\tEXPECT_EQ(user_notif_syscall(__NR_getppid,\n\t\t\t\t     SECCOMP_FILTER_FLAG_NEW_LISTENER),\n\t\t  -1);\n\tEXPECT_EQ(errno, EBUSY);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = syscall(__NR_getppid);\n\t\texit(ret != USER_NOTIF_MAGIC);\n\t}\n\n\tpollfd.fd = listener;\n\tpollfd.events = POLLIN | POLLOUT;\n\n\tEXPECT_GT(poll(&pollfd, 1, -1), 0);\n\tEXPECT_EQ(pollfd.revents, POLLIN);\n\n\t \n\tmemset(&req, 0, sizeof(req));\n\treq.pid = -1;\n\terrno = 0;\n\tret = ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req);\n\tEXPECT_EQ(-1, ret);\n\tEXPECT_EQ(EINVAL, errno);\n\n\tif (ret) {\n\t\treq.pid = 0;\n\t\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\t}\n\n\tpollfd.fd = listener;\n\tpollfd.events = POLLIN | POLLOUT;\n\n\tEXPECT_GT(poll(&pollfd, 1, -1), 0);\n\tEXPECT_EQ(pollfd.revents, POLLOUT);\n\n\tEXPECT_EQ(req.data.nr,  __NR_getppid);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\n\t \n\tresp.flags = 1;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tresp.flags = 0;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(user_notification_with_tsync)\n{\n\tint ret;\n\tunsigned int flags;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tflags = SECCOMP_FILTER_FLAG_NEW_LISTENER |\n\t\tSECCOMP_FILTER_FLAG_TSYNC;\n\tASSERT_EQ(-1, user_notif_syscall(__NR_getppid, flags));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tflags |= SECCOMP_FILTER_FLAG_TSYNC_ESRCH;\n\tret = user_notif_syscall(__NR_getppid, flags);\n\tclose(ret);\n\tASSERT_LE(0, ret);\n}\n\nTEST(user_notification_kill_in_middle)\n{\n\tpid_t pid;\n\tlong ret;\n\tint listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\t \n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = syscall(__NR_getppid);\n\t\texit(ret != USER_NOTIF_MAGIC);\n\t}\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ID_VALID, &req.id), 0);\n\n\tEXPECT_EQ(kill(pid, SIGKILL), 0);\n\tEXPECT_EQ(waitpid(pid, NULL, 0), pid);\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ID_VALID, &req.id), -1);\n\n\tresp.id = req.id;\n\tret = ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp);\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, ENOENT);\n}\n\nstatic int handled = -1;\n\nstatic void signal_handler(int signal)\n{\n\tif (write(handled, \"c\", 1) != 1)\n\t\tperror(\"write from signal\");\n}\n\nTEST(user_notification_signal)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener, sk_pair[2];\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\tchar c;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tASSERT_EQ(socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair), 0);\n\n\tlistener = user_notif_syscall(__NR_gettid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tclose(sk_pair[0]);\n\t\thandled = sk_pair[1];\n\t\tif (signal(SIGUSR1, signal_handler) == SIG_ERR) {\n\t\t\tperror(\"signal\");\n\t\t\texit(1);\n\t\t}\n\t\t \n\t\tret = syscall(__NR_gettid);\n\t\texit(!(ret == -1 && errno == 512));\n\t}\n\n\tclose(sk_pair[1]);\n\n\tmemset(&req, 0, sizeof(req));\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\tEXPECT_EQ(kill(pid, SIGUSR1), 0);\n\n\t \n\tEXPECT_EQ(read(sk_pair[0], &c, 1), 1);\n\n\tresp.id = req.id;\n\tresp.error = -EPERM;\n\tresp.val = 0;\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);\n\tEXPECT_EQ(errno, ENOENT);\n\n\tmemset(&req, 0, sizeof(req));\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\tresp.id = req.id;\n\tresp.error = -512;  \n\tresp.val = 0;\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(user_notification_closed_listener)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\t \n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\tif (pid == 0) {\n\t\tclose(listener);\n\t\tret = syscall(__NR_getppid);\n\t\texit(ret != -1 && errno != ENOSYS);\n\t}\n\n\tclose(listener);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\n \nTEST(user_notification_child_pid_ns)\n{\n\tpid_t pid;\n\tint status, listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\n\tASSERT_EQ(unshare(CLONE_NEWUSER | CLONE_NEWPID), 0) {\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(return, \"kernel missing CLONE_NEWUSER support\");\n\t};\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0)\n\t\texit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tEXPECT_EQ(req.pid, pid);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\tclose(listener);\n}\n\n \nTEST(user_notification_sibling_pid_ns)\n{\n\tpid_t pid, pid2;\n\tint status, listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\n\tASSERT_EQ(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0), 0) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tASSERT_EQ(unshare(CLONE_NEWPID), 0);\n\n\t\tpid2 = fork();\n\t\tASSERT_GE(pid2, 0);\n\n\t\tif (pid2 == 0)\n\t\t\texit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);\n\n\t\tEXPECT_EQ(waitpid(pid2, &status, 0), pid2);\n\t\tEXPECT_EQ(true, WIFEXITED(status));\n\t\tEXPECT_EQ(0, WEXITSTATUS(status));\n\t\texit(WEXITSTATUS(status));\n\t}\n\n\t \n\tASSERT_EQ(unshare(CLONE_NEWPID), 0) {\n\t\tif (errno == EPERM)\n\t\t\tSKIP(return, \"CLONE_NEWPID requires CAP_SYS_ADMIN\");\n\t}\n\tASSERT_EQ(errno, 0);\n\n\tpid2 = fork();\n\tASSERT_GE(pid2, 0);\n\n\tif (pid2 == 0) {\n\t\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\t\t \n\t\tEXPECT_EQ(req.pid, 0);\n\n\t\tresp.id = req.id;\n\t\tresp.error = 0;\n\t\tresp.val = USER_NOTIF_MAGIC;\n\n\t\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\t\texit(0);\n\t}\n\n\tclose(listener);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\tEXPECT_EQ(waitpid(pid2, &status, 0), pid2);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(user_notification_fault_recv)\n{\n\tpid_t pid;\n\tint status, listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\n\tASSERT_EQ(unshare(CLONE_NEWUSER), 0) {\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(return, \"kernel missing CLONE_NEWUSER support\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0)\n\t\texit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, NULL), -1);\n\tEXPECT_EQ(errno, EFAULT);\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tEXPECT_EQ(req.pid, pid);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(seccomp_get_notif_sizes)\n{\n\tstruct seccomp_notif_sizes sizes;\n\n\tASSERT_EQ(seccomp(SECCOMP_GET_NOTIF_SIZES, 0, &sizes), 0);\n\tEXPECT_EQ(sizes.seccomp_notif, sizeof(struct seccomp_notif));\n\tEXPECT_EQ(sizes.seccomp_notif_resp, sizeof(struct seccomp_notif_resp));\n}\n\nTEST(user_notification_continue)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener;\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\tstruct pollfd pollfd;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_dup, SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tint dup_fd, pipe_fds[2];\n\t\tpid_t self;\n\n\t\tASSERT_GE(pipe(pipe_fds), 0);\n\n\t\tdup_fd = dup(pipe_fds[0]);\n\t\tASSERT_GE(dup_fd, 0);\n\t\tEXPECT_NE(pipe_fds[0], dup_fd);\n\n\t\tself = getpid();\n\t\tASSERT_EQ(filecmp(self, self, pipe_fds[0], dup_fd), 0);\n\t\texit(0);\n\t}\n\n\tpollfd.fd = listener;\n\tpollfd.events = POLLIN | POLLOUT;\n\n\tEXPECT_GT(poll(&pollfd, 1, -1), 0);\n\tEXPECT_EQ(pollfd.revents, POLLIN);\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\tpollfd.fd = listener;\n\tpollfd.events = POLLIN | POLLOUT;\n\n\tEXPECT_GT(poll(&pollfd, 1, -1), 0);\n\tEXPECT_EQ(pollfd.revents, POLLOUT);\n\n\tEXPECT_EQ(req.data.nr, __NR_dup);\n\n\tresp.id = req.id;\n\tresp.flags = SECCOMP_USER_NOTIF_FLAG_CONTINUE;\n\n\t \n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tresp.error = USER_NOTIF_MAGIC;\n\tresp.val = 0;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tresp.error = 0;\n\tresp.val = 0;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0) {\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(goto skip, \"Kernel does not support SECCOMP_USER_NOTIF_FLAG_CONTINUE\");\n\t}\n\nskip:\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status)) {\n\t\tif (WEXITSTATUS(status) == 2) {\n\t\t\tSKIP(return, \"Kernel does not support kcmp() syscall\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nTEST(user_notification_filter_empty)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status;\n\tstruct pollfd pollfd;\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tif (__NR_clone3 < 0)\n\t\tSKIP(return, \"Test not built with clone3 support\");\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tint listener;\n\n\t\tlistener = user_notif_syscall(__NR_mknodat, SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\t\tif (listener < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (dup2(listener, 200) != 200)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tclose(listener);\n\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\t \n\tpollfd.fd = 200;\n\tpollfd.events = POLLHUP;\n\n\tEXPECT_GT(poll(&pollfd, 1, 2000), 0);\n\tEXPECT_GT((pollfd.revents & POLLHUP) ?: 0, 0);\n}\n\nstatic void *do_thread(void *data)\n{\n\treturn NULL;\n}\n\nTEST(user_notification_filter_empty_threaded)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status;\n\tstruct pollfd pollfd;\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tif (__NR_clone3 < 0)\n\t\tSKIP(return, \"Test not built with clone3 support\");\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tpid_t pid1, pid2;\n\t\tint listener, status;\n\t\tpthread_t thread;\n\n\t\tlistener = user_notif_syscall(__NR_dup, SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\t\tif (listener < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (dup2(listener, 200) != 200)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tclose(listener);\n\n\t\tpid1 = fork();\n\t\tif (pid1 < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (pid1 == 0)\n\t\t\t_exit(EXIT_SUCCESS);\n\n\t\tpid2 = fork();\n\t\tif (pid2 < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (pid2 == 0)\n\t\t\t_exit(EXIT_SUCCESS);\n\n\t\tif (pthread_create(&thread, NULL, do_thread, NULL) ||\n\t\t    pthread_join(thread, NULL))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (pthread_create(&thread, NULL, do_thread, NULL) ||\n\t\t    pthread_join(thread, NULL))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (waitpid(pid1, &status, 0) != pid1 || !WIFEXITED(status) ||\n\t\t    WEXITSTATUS(status))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (waitpid(pid2, &status, 0) != pid2 || !WIFEXITED(status) ||\n\t\t    WEXITSTATUS(status))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\t \n\tpollfd.fd = 200;\n\tpollfd.events = POLLHUP;\n\n\tEXPECT_GT(poll(&pollfd, 1, 2000), 0);\n\tEXPECT_GT((pollfd.revents & POLLHUP) ?: 0, 0);\n}\n\nTEST(user_notification_addfd)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener, memfd, fd, nextfd;\n\tstruct seccomp_notif_addfd addfd = {};\n\tstruct seccomp_notif_addfd_small small = {};\n\tstruct seccomp_notif_addfd_big big = {};\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\t \n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\t \n\tmemfd = memfd_create(\"test\", 0);\n\tASSERT_GE(memfd, 0);\n\tnextfd = memfd + 1;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\t \n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_EQ(listener, nextfd++);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\t \n\t\tif (syscall(__NR_getppid) != USER_NOTIF_MAGIC)\n\t\t\texit(1);\n\n\t\t \n\t\tif (fcntl(syscall(__NR_getppid), F_GETFD) == -1)\n\t\t\texit(1);\n\n\t\texit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);\n\t}\n\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\taddfd.srcfd = memfd;\n\taddfd.newfd = 0;\n\taddfd.id = req.id;\n\taddfd.flags = 0x0;\n\n\t \n\taddfd.newfd_flags = ~O_CLOEXEC;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\taddfd.newfd_flags = O_CLOEXEC;\n\n\t \n\taddfd.flags = 0xff;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\taddfd.flags = 0;\n\n\t \n\taddfd.newfd = 1;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\taddfd.newfd = 0;\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD_SMALL, &small), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\t \n\tmemset(&big, 0xAA, sizeof(big));\n\tbig.addfd = addfd;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD_BIG, &big), -1);\n\tEXPECT_EQ(errno, E2BIG);\n\n\n\t \n\tfd = ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd);\n\tEXPECT_EQ(fd, nextfd++);\n\tEXPECT_EQ(filecmp(getpid(), pid, memfd, fd), 0);\n\n\t \n\tmemset(&big, 0x0, sizeof(big));\n\tbig.addfd = addfd;\n\tfd = ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD_BIG, &big);\n\tEXPECT_EQ(fd, nextfd++);\n\n\t \n\taddfd.newfd = 42;\n\taddfd.flags = SECCOMP_ADDFD_FLAG_SETFD;\n\tfd = ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd);\n\tEXPECT_EQ(fd, 42);\n\tEXPECT_EQ(filecmp(getpid(), pid, memfd, fd), 0);\n\n\t \n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\t \n\taddfd.id = req.id + 1;\n\n\t \n\twhile (ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd) != -1 &&\n\t       errno != -EINPROGRESS)\n\t\tnanosleep(&delay, NULL);\n\n\tmemset(&req, 0, sizeof(req));\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tASSERT_EQ(addfd.id, req.id);\n\n\t \n\taddfd.newfd = 0;\n\taddfd.flags = SECCOMP_ADDFD_FLAG_SEND;\n\tfd = ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd);\n\t \n\tEXPECT_EQ(fd, nextfd++);\n\tASSERT_EQ(filecmp(getpid(), pid, memfd, fd), 0);\n\n\t \n\taddfd.id = req.id + 1;\n\n\t \n\twhile (ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd) != -1 &&\n\t       errno != -EINPROGRESS)\n\t\tnanosleep(&delay, NULL);\n\n\tmemset(&req, 0, sizeof(req));\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tASSERT_EQ(addfd.id, req.id);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\t \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\tclose(memfd);\n}\n\nTEST(user_notification_addfd_rlimit)\n{\n\tpid_t pid;\n\tlong ret;\n\tint status, listener, memfd;\n\tstruct seccomp_notif_addfd addfd = {};\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\tconst struct rlimit lim = {\n\t\t.rlim_cur\t= 0,\n\t\t.rlim_max\t= 0,\n\t};\n\n\tmemfd = memfd_create(\"test\", 0);\n\tASSERT_GE(memfd, 0);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0)\n\t\texit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);\n\n\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\tASSERT_EQ(prlimit(pid, RLIMIT_NOFILE, &lim, NULL), 0);\n\n\taddfd.srcfd = memfd;\n\taddfd.newfd_flags = O_CLOEXEC;\n\taddfd.newfd = 0;\n\taddfd.id = req.id;\n\taddfd.flags = 0;\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EMFILE);\n\n\taddfd.flags = SECCOMP_ADDFD_FLAG_SEND;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EMFILE);\n\n\taddfd.newfd = 100;\n\taddfd.flags = SECCOMP_ADDFD_FLAG_SETFD;\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd), -1);\n\tEXPECT_EQ(errno, EBADF);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\t \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\tclose(memfd);\n}\n\n#ifndef SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP\n#define SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP (1UL << 0)\n#define SECCOMP_IOCTL_NOTIF_SET_FLAGS  SECCOMP_IOW(4, __u64)\n#endif\n\nTEST(user_notification_sync)\n{\n\tstruct seccomp_notif req = {};\n\tstruct seccomp_notif_resp resp = {};\n\tint status, listener;\n\tpid_t pid;\n\tlong ret;\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\t \n\tEXPECT_SYSCALL_RETURN(-EINVAL,\n\t\tioctl(listener, SECCOMP_IOCTL_NOTIF_SET_FLAGS, 0xffffffff, 0));\n\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SET_FLAGS,\n\t\t\tSECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP, 0), 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\tif (pid == 0) {\n\t\tret = syscall(__NR_getppid);\n\t\tASSERT_EQ(ret, USER_NOTIF_MAGIC) {\n\t\t\t_exit(1);\n\t\t}\n\t\t_exit(0);\n\t}\n\n\treq.pid = 0;\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\n\tASSERT_EQ(req.data.nr,  __NR_getppid);\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\tresp.flags = 0;\n\tASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tASSERT_EQ(waitpid(pid, &status, 0), pid);\n\tASSERT_EQ(status, 0);\n}\n\n\n \nFIXTURE(O_SUSPEND_SECCOMP) {\n\tpid_t pid;\n};\n\nFIXTURE_SETUP(O_SUSPEND_SECCOMP)\n{\n\tERRNO_FILTER(block_read, E2BIG);\n\tcap_value_t cap_list[] = { CAP_SYS_ADMIN };\n\tcap_t caps;\n\n\tself->pid = 0;\n\n\t \n\tcaps = cap_get_proc();\n\tASSERT_NE(NULL, caps);\n\tASSERT_EQ(0, cap_set_flag(caps, CAP_EFFECTIVE, 1, cap_list, CAP_CLEAR));\n\tASSERT_EQ(0, cap_set_proc(caps));\n\tcap_free(caps);\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\tASSERT_EQ(0, prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog_block_read));\n\n\tself->pid = fork();\n\tASSERT_GE(self->pid, 0);\n\n\tif (self->pid == 0) {\n\t\twhile (1)\n\t\t\tpause();\n\t\t_exit(127);\n\t}\n}\n\nFIXTURE_TEARDOWN(O_SUSPEND_SECCOMP)\n{\n\tif (self->pid)\n\t\tkill(self->pid, SIGKILL);\n}\n\nTEST_F(O_SUSPEND_SECCOMP, setoptions)\n{\n\tint wstatus;\n\n\tASSERT_EQ(0, ptrace(PTRACE_ATTACH, self->pid, NULL, 0));\n\tASSERT_EQ(self->pid, wait(&wstatus));\n\tASSERT_EQ(-1, ptrace(PTRACE_SETOPTIONS, self->pid, NULL, PTRACE_O_SUSPEND_SECCOMP));\n\tif (errno == EINVAL)\n\t\tSKIP(return, \"Kernel does not support PTRACE_O_SUSPEND_SECCOMP (missing CONFIG_CHECKPOINT_RESTORE?)\");\n\tASSERT_EQ(EPERM, errno);\n}\n\nTEST_F(O_SUSPEND_SECCOMP, seize)\n{\n\tint ret;\n\n\tret = ptrace(PTRACE_SEIZE, self->pid, NULL, PTRACE_O_SUSPEND_SECCOMP);\n\tASSERT_EQ(-1, ret);\n\tif (errno == EINVAL)\n\t\tSKIP(return, \"Kernel does not support PTRACE_O_SUSPEND_SECCOMP (missing CONFIG_CHECKPOINT_RESTORE?)\");\n\tASSERT_EQ(EPERM, errno);\n}\n\n \nstatic ssize_t get_nth(struct __test_metadata *_metadata, const char *path,\n\t\t     const unsigned int position, char **entry)\n{\n\tchar *line = NULL;\n\tunsigned int i;\n\tssize_t nread;\n\tsize_t len = 0;\n\tFILE *f;\n\n\tf = fopen(path, \"r\");\n\tASSERT_NE(f, NULL) {\n\t\tTH_LOG(\"Could not open %s: %s\", path, strerror(errno));\n\t}\n\n\tfor (i = 0; i < position; i++) {\n\t\tnread = getdelim(&line, &len, ' ', f);\n\t\tASSERT_GE(nread, 0) {\n\t\t\tTH_LOG(\"Failed to read %d entry in file %s\", i, path);\n\t\t}\n\t}\n\tfclose(f);\n\n\tASSERT_GT(nread, 0) {\n\t\tTH_LOG(\"Entry in file %s had zero length\", path);\n\t}\n\n\t*entry = line;\n\treturn nread - 1;\n}\n\n \nstatic char get_proc_stat(struct __test_metadata *_metadata, pid_t pid)\n{\n\tchar proc_path[100] = {0};\n\tchar status;\n\tchar *line;\n\n\tsnprintf(proc_path, sizeof(proc_path), \"/proc/%d/stat\", pid);\n\tASSERT_EQ(get_nth(_metadata, proc_path, 3, &line), 1);\n\n\tstatus = *line;\n\tfree(line);\n\n\treturn status;\n}\n\nTEST(user_notification_fifo)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_notif req = {};\n\tint i, status, listener;\n\tpid_t pid, pids[3];\n\t__u64 baseid;\n\tlong ret;\n\t \n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\t \n\tlistener = user_notif_syscall(__NR_getppid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = syscall(__NR_getppid);\n\t\texit(ret != USER_NOTIF_MAGIC);\n\t}\n\n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\tbaseid = req.id + 1;\n\n\tresp.id = req.id;\n\tresp.error = 0;\n\tresp.val = USER_NOTIF_MAGIC;\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pids); i++) {\n\t\tpid = fork();\n\t\tif (pid == 0) {\n\t\t\tret = syscall(__NR_getppid);\n\t\t\texit(ret != USER_NOTIF_MAGIC);\n\t\t}\n\t\tpids[i] = pid;\n\t}\n\n\t \nrestart_wait:\n\tfor (i = 0; i < ARRAY_SIZE(pids); i++) {\n\t\tif (get_proc_stat(_metadata, pids[i]) != 'S') {\n\t\t\tnanosleep(&delay, NULL);\n\t\t\tgoto restart_wait;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pids); i++) {\n\t\tmemset(&req, 0, sizeof(req));\n\t\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\t\tEXPECT_EQ(req.id, baseid + i);\n\t\tresp.id = req.id;\n\t\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pids); i++) {\n\t\tEXPECT_EQ(waitpid(pids[i], &status, 0), pids[i]);\n\t\tEXPECT_EQ(true, WIFEXITED(status));\n\t\tEXPECT_EQ(0, WEXITSTATUS(status));\n\t}\n}\n\n \nstatic long get_proc_syscall(struct __test_metadata *_metadata, int pid)\n{\n\tchar proc_path[100] = {0};\n\tlong ret = -1;\n\tssize_t nread;\n\tchar *line;\n\n\tsnprintf(proc_path, sizeof(proc_path), \"/proc/%d/syscall\", pid);\n\tnread = get_nth(_metadata, proc_path, 1, &line);\n\tASSERT_GT(nread, 0);\n\n\tif (!strncmp(\"running\", line, MIN(7, nread)))\n\t\tret = strtol(line, NULL, 16);\n\n\tfree(line);\n\treturn ret;\n}\n\n \nTEST(user_notification_wait_killable_pre_notification)\n{\n\tstruct sigaction new_action = {\n\t\t.sa_handler = signal_handler,\n\t};\n\tint listener, status, sk_pair[2];\n\tpid_t pid;\n\tlong ret;\n\tchar c;\n\t \n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\tASSERT_EQ(sigemptyset(&new_action.sa_mask), 0);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret)\n\t{\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tASSERT_EQ(socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair), 0);\n\n\tlistener = user_notif_syscall(\n\t\t__NR_getppid, SECCOMP_FILTER_FLAG_NEW_LISTENER |\n\t\t\t\t      SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV);\n\tASSERT_GE(listener, 0);\n\n\t \n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tclose(sk_pair[0]);\n\t\thandled = sk_pair[1];\n\n\t\t \n\t\tif (sigaction(SIGUSR1, &new_action, NULL)) {\n\t\t\tperror(\"sigaction\");\n\t\t\texit(1);\n\t\t}\n\n\t\tret = syscall(__NR_getppid);\n\t\t \n\t\texit(ret != -1 || errno != EINTR);\n\t}\n\n\t \n\twhile (get_proc_syscall(_metadata, pid) != __NR_getppid &&\n\t       get_proc_stat(_metadata, pid) != 'S')\n\t\tnanosleep(&delay, NULL);\n\n\t \n\tEXPECT_EQ(kill(pid, SIGUSR1), 0);\n\n\t \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\tEXPECT_EQ(read(sk_pair[0], &c, 1), 1);\n}\n\n \nTEST(user_notification_wait_killable)\n{\n\tstruct sigaction new_action = {\n\t\t.sa_handler = signal_handler,\n\t};\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_notif req = {};\n\tint listener, status, sk_pair[2];\n\tpid_t pid;\n\tlong ret;\n\tchar c;\n\t \n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\tASSERT_EQ(sigemptyset(&new_action.sa_mask), 0);\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret)\n\t{\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tASSERT_EQ(socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair), 0);\n\n\tlistener = user_notif_syscall(\n\t\t__NR_getppid, SECCOMP_FILTER_FLAG_NEW_LISTENER |\n\t\t\t\t      SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tclose(sk_pair[0]);\n\t\thandled = sk_pair[1];\n\n\t\t \n\t\tif (sigaction(SIGUSR1, &new_action, NULL)) {\n\t\t\tperror(\"sigaction\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tret = syscall(__NR_getppid);\n\t\texit(ret != USER_NOTIF_MAGIC);\n\t}\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\t \n\tEXPECT_EQ(kill(pid, SIGUSR1), 0);\n\n\t \n\twhile (get_proc_stat(_metadata, pid) != 'D')\n\t\tnanosleep(&delay, NULL);\n\n\tresp.id = req.id;\n\tresp.val = USER_NOTIF_MAGIC;\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);\n\n\t \n\tEXPECT_EQ(read(sk_pair[0], &c, 1), 1);\n\t \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\n \nTEST(user_notification_wait_killable_fatal)\n{\n\tstruct seccomp_notif req = {};\n\tint listener, status;\n\tpid_t pid;\n\tlong ret;\n\t \n\tstruct timespec delay = { .tv_nsec = 100000000 };\n\n\tret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tASSERT_EQ(0, ret)\n\t{\n\t\tTH_LOG(\"Kernel does not support PR_SET_NO_NEW_PRIVS!\");\n\t}\n\n\tlistener = user_notif_syscall(\n\t\t__NR_getppid, SECCOMP_FILTER_FLAG_NEW_LISTENER |\n\t\t\t\t      SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV);\n\tASSERT_GE(listener, 0);\n\n\tpid = fork();\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\t \n\t\tsyscall(__NR_getppid);\n\t\texit(1);\n\t}\n\n\twhile (get_proc_stat(_metadata, pid) != 'S')\n\t\tnanosleep(&delay, NULL);\n\n\t \n\tEXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);\n\t \n\tEXPECT_EQ(kill(pid, SIGTERM), 0);\n\n\t \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFSIGNALED(status));\n\tEXPECT_EQ(SIGTERM, WTERMSIG(status));\n}\n\n \n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}