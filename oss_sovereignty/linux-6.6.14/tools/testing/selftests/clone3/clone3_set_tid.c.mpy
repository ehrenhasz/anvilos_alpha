{
  "module_name": "clone3_set_tid.c",
  "hash_id": "a034ba0b568e601c139cead95b280db2bee9a24b32c951da493cec3de74db38a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/clone3/clone3_set_tid.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sched.h>\n\n#include \"../kselftest.h\"\n#include \"clone3_selftests.h\"\n\n#ifndef MAX_PID_NS_LEVEL\n#define MAX_PID_NS_LEVEL 32\n#endif\n\nstatic int pipe_1[2];\nstatic int pipe_2[2];\n\nstatic void child_exit(int ret)\n{\n\tfflush(stdout);\n\tfflush(stderr);\n\t_exit(ret);\n}\n\nstatic int call_clone3_set_tid(pid_t *set_tid,\n\t\t\t       size_t set_tid_size,\n\t\t\t       int flags,\n\t\t\t       int expected_pid,\n\t\t\t       bool wait_for_it)\n{\n\tint status;\n\tpid_t pid = -1;\n\n\tstruct __clone_args args = {\n\t\t.flags = flags,\n\t\t.exit_signal = SIGCHLD,\n\t\t.set_tid = ptr_to_u64(set_tid),\n\t\t.set_tid_size = set_tid_size,\n\t};\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tif (pid < 0) {\n\t\tksft_print_msg(\"%s - Failed to create new process\\n\",\n\t\t\t       strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tif (pid == 0) {\n\t\tint ret;\n\t\tchar tmp = 0;\n\t\tint exit_code = EXIT_SUCCESS;\n\n\t\tksft_print_msg(\"I am the child, my PID is %d (expected %d)\\n\",\n\t\t\t       getpid(), set_tid[0]);\n\t\tif (wait_for_it) {\n\t\t\tksft_print_msg(\"[%d] Child is ready and waiting\\n\",\n\t\t\t\t       getpid());\n\n\t\t\t \n\t\t\tclose(pipe_1[0]);\n\t\t\tret = write(pipe_1[1], &tmp, 1);\n\t\t\tif (ret != 1) {\n\t\t\t\tksft_print_msg(\n\t\t\t\t\t\"Writing to pipe returned %d\", ret);\n\t\t\t\texit_code = EXIT_FAILURE;\n\t\t\t}\n\t\t\tclose(pipe_1[1]);\n\t\t\tclose(pipe_2[1]);\n\t\t\tret = read(pipe_2[0], &tmp, 1);\n\t\t\tif (ret != 1) {\n\t\t\t\tksft_print_msg(\n\t\t\t\t\t\"Reading from pipe returned %d\", ret);\n\t\t\t\texit_code = EXIT_FAILURE;\n\t\t\t}\n\t\t\tclose(pipe_2[0]);\n\t\t}\n\n\t\tif (set_tid[0] != getpid())\n\t\t\tchild_exit(EXIT_FAILURE);\n\t\tchild_exit(exit_code);\n\t}\n\n\tif (expected_pid == 0 || expected_pid == pid) {\n\t\tksft_print_msg(\"I am the parent (%d). My child's pid is %d\\n\",\n\t\t\t       getpid(), pid);\n\t} else {\n\t\tksft_print_msg(\n\t\t\t\"Expected child pid %d does not match actual pid %d\\n\",\n\t\t\texpected_pid, pid);\n\t\treturn -1;\n\t}\n\n\tif (waitpid(pid, &status, 0) < 0) {\n\t\tksft_print_msg(\"Child returned %s\\n\", strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tif (!WIFEXITED(status))\n\t\treturn -1;\n\n\treturn WEXITSTATUS(status);\n}\n\nstatic void test_clone3_set_tid(pid_t *set_tid,\n\t\t\t\tsize_t set_tid_size,\n\t\t\t\tint flags,\n\t\t\t\tint expected,\n\t\t\t\tint expected_pid,\n\t\t\t\tbool wait_for_it)\n{\n\tint ret;\n\n\tksft_print_msg(\n\t\t\"[%d] Trying clone3() with CLONE_SET_TID to %d and 0x%x\\n\",\n\t\tgetpid(), set_tid[0], flags);\n\tret = call_clone3_set_tid(set_tid, set_tid_size, flags, expected_pid,\n\t\t\t\t  wait_for_it);\n\tksft_print_msg(\n\t\t\"[%d] clone3() with CLONE_SET_TID %d says :%d - expected %d\\n\",\n\t\tgetpid(), set_tid[0], ret, expected);\n\tif (ret != expected)\n\t\tksft_test_result_fail(\n\t\t\t\"[%d] Result (%d) is different than expected (%d)\\n\",\n\t\t\tgetpid(), ret, expected);\n\telse\n\t\tksft_test_result_pass(\n\t\t\t\"[%d] Result (%d) matches expectation (%d)\\n\",\n\t\t\tgetpid(), ret, expected);\n}\nint main(int argc, char *argv[])\n{\n\tFILE *f;\n\tchar buf;\n\tchar *line;\n\tint status;\n\tint ret = -1;\n\tsize_t len = 0;\n\tint pid_max = 0;\n\tuid_t uid = getuid();\n\tchar proc_path[100] = {0};\n\tpid_t pid, ns1, ns2, ns3, ns_pid;\n\tpid_t set_tid[MAX_PID_NS_LEVEL * 2];\n\n\tksft_print_header();\n\tksft_set_plan(29);\n\ttest_clone3_supported();\n\n\tif (pipe(pipe_1) < 0 || pipe(pipe_2) < 0)\n\t\tksft_exit_fail_msg(\"pipe() failed\\n\");\n\n\tf = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (f == NULL)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s - Could not open /proc/sys/kernel/pid_max\\n\",\n\t\t\tstrerror(errno));\n\tfscanf(f, \"%d\", &pid_max);\n\tfclose(f);\n\tksft_print_msg(\"/proc/sys/kernel/pid_max %d\\n\", pid_max);\n\n\t \n\tmemset(&set_tid, 0, sizeof(set_tid));\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL + 1, 0, -EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 2, 0, -EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 2 + 1, 0,\n\t\t\t-EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 42, 0, -EINVAL, 0, 0);\n\n\t \n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL - 1, 0, -EINVAL, 0, 0);\n\n\tmemset(&set_tid, 0xff, sizeof(set_tid));\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL + 1, 0, -EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 2, 0, -EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 2 + 1, 0,\n\t\t\t-EINVAL, 0, 0);\n\n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL * 42, 0, -EINVAL, 0, 0);\n\n\t \n\ttest_clone3_set_tid(set_tid, MAX_PID_NS_LEVEL - 1, 0, -EINVAL, 0, 0);\n\n\tmemset(&set_tid, 0, sizeof(set_tid));\n\t \n\tset_tid[0] = 0;\n\ttest_clone3_set_tid(set_tid, 1, 0, -EINVAL, 0, 0);\n\n\tset_tid[0] = -1;\n\ttest_clone3_set_tid(set_tid, 1, 0, -EINVAL, 0, 0);\n\n\t \n\ttest_clone3_set_tid(set_tid, 2, 0, -EINVAL, 0, 0);\n\n\t \n\tif (uid == 0)\n\t\ttest_clone3_set_tid(set_tid, 1, CLONE_NEWPID, -EINVAL, 0, 0);\n\telse\n\t\tksft_test_result_skip(\"Clone3() with set_tid requires root\\n\");\n\n\t \n\tset_tid[0] = 1;\n\tif (uid == 0)\n\t\ttest_clone3_set_tid(set_tid, 1, 0, -EEXIST, 0, 0);\n\telse\n\t\tksft_test_result_skip(\"Clone3() with set_tid requires root\\n\");\n\n\t \n\tif (uid == 0)\n\t\ttest_clone3_set_tid(set_tid, 1, CLONE_NEWPID, 0, 0, 0);\n\telse\n\t\tksft_test_result_skip(\"Clone3() with set_tid requires root\\n\");\n\n\t \n\tset_tid[0] = pid_max;\n\ttest_clone3_set_tid(set_tid, 1, 0, -EINVAL, 0, 0);\n\n\tif (uid == 0)\n\t\ttest_clone3_set_tid(set_tid, 1, CLONE_NEWPID, -EINVAL, 0, 0);\n\telse\n\t\tksft_test_result_skip(\"Clone3() with set_tid requires root\\n\");\n\n\tif (uid != 0) {\n\t\t \n\t\tksft_cnt.ksft_xskip += ksft_plan - ksft_test_num();\n\t\tgoto out;\n\t}\n\n\t \n\tpid = fork();\n\tif (pid == 0) {\n\t\tksft_print_msg(\"Child has PID %d\\n\", getpid());\n\t\tchild_exit(EXIT_SUCCESS);\n\t}\n\tif (waitpid(pid, &status, 0) < 0)\n\t\tksft_exit_fail_msg(\"Waiting for child %d failed\", pid);\n\n\t \n\tset_tid[0] = pid;\n\ttest_clone3_set_tid(set_tid, 1, 0, 0, 0, 0);\n\n\t \n\ttest_clone3_set_tid(set_tid, 1, CLONE_NEWPID, -EINVAL, 0, 0);\n\n\t \n\tset_tid[0] = 1;\n\tset_tid[1] = pid;\n\ttest_clone3_set_tid(set_tid, 2, CLONE_NEWPID, 0, pid, 0);\n\n\tksft_print_msg(\"unshare PID namespace\\n\");\n\tif (unshare(CLONE_NEWPID) == -1)\n\t\tksft_exit_fail_msg(\"unshare(CLONE_NEWPID) failed: %s\\n\",\n\t\t\t\tstrerror(errno));\n\n\tset_tid[0] = pid;\n\n\t \n\ttest_clone3_set_tid(set_tid, 1, 0, -EINVAL, 0, 0);\n\n\t \n\tns_pid = fork();\n\tif (ns_pid == 0) {\n\t\t \n\t\tset_tid[0] = 43;\n\t\tset_tid[1] = -1;\n\t\ttest_clone3_set_tid(set_tid, 2, 0, -EINVAL, 0, 0);\n\n\t\tset_tid[0] = 43;\n\t\tset_tid[1] = pid;\n\t\ttest_clone3_set_tid(set_tid, 2, 0, 0, 43, 0);\n\n\t\tksft_print_msg(\"Child in PID namespace has PID %d\\n\", getpid());\n\t\tset_tid[0] = 2;\n\t\ttest_clone3_set_tid(set_tid, 1, 0, 0, 2, 0);\n\n\t\tset_tid[0] = 1;\n\t\tset_tid[1] = -1;\n\t\tset_tid[2] = pid;\n\t\t \n\t\ttest_clone3_set_tid(set_tid, 3, CLONE_NEWPID, -EINVAL, 0, 0);\n\n\t\tset_tid[0] = 1;\n\t\tset_tid[1] = 42;\n\t\tset_tid[2] = pid;\n\t\t \n\t\ttest_clone3_set_tid(set_tid, 4, CLONE_NEWPID, -EINVAL, 0, 0);\n\n\t\t \n\t\ttest_clone3_set_tid(set_tid, 3, CLONE_NEWPID, 0, 42, true);\n\n\t\tchild_exit(ksft_cnt.ksft_fail);\n\t}\n\n\tclose(pipe_1[1]);\n\tclose(pipe_2[0]);\n\twhile (read(pipe_1[0], &buf, 1) > 0) {\n\t\tksft_print_msg(\"[%d] Child is ready and waiting\\n\", getpid());\n\t\tbreak;\n\t}\n\n\tsnprintf(proc_path, sizeof(proc_path), \"/proc/%d/status\", pid);\n\tf = fopen(proc_path, \"r\");\n\tif (f == NULL)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s - Could not open %s\\n\",\n\t\t\tstrerror(errno), proc_path);\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tif (strstr(line, \"NSpid\")) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\ti = sscanf(line, \"NSpid:\\t%d\\t%d\\t%d\",\n\t\t\t\t   &ns3, &ns2, &ns1);\n\t\t\tif (i != 3) {\n\t\t\t\tksft_print_msg(\n\t\t\t\t\t\"Unexpected 'NSPid:' entry: %s\",\n\t\t\t\t\tline);\n\t\t\t\tns1 = ns2 = ns3 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n\tclose(pipe_2[0]);\n\n\t \n\twrite(pipe_2[1], &buf, 1);\n\tclose(pipe_2[1]);\n\n\tif (waitpid(ns_pid, &status, 0) < 0) {\n\t\tksft_print_msg(\"Child returned %s\\n\", strerror(errno));\n\t\tret = -errno;\n\t\tgoto out;\n\t}\n\n\tif (!WIFEXITED(status))\n\t\tksft_test_result_fail(\"Child error\\n\");\n\n\tksft_cnt.ksft_pass += 6 - (ksft_cnt.ksft_fail - WEXITSTATUS(status));\n\tksft_cnt.ksft_fail = WEXITSTATUS(status);\n\n\tif (ns3 == pid && ns2 == 42 && ns1 == 1)\n\t\tksft_test_result_pass(\n\t\t\t\"PIDs in all namespaces as expected (%d,%d,%d)\\n\",\n\t\t\tns3, ns2, ns1);\n\telse\n\t\tksft_test_result_fail(\n\t\t\t\"PIDs in all namespaces not as expected (%d,%d,%d)\\n\",\n\t\t\tns3, ns2, ns1);\nout:\n\tret = 0;\n\n\treturn !ret ? ksft_exit_pass() : ksft_exit_fail();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}