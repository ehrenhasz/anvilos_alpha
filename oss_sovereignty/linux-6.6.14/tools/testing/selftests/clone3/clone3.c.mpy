{
  "module_name": "clone3.c",
  "hash_id": "0c296c20ec3f90774d37370e2d192dea356f1f9c3ef540e89a3a57157da0bdfd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/clone3/clone3.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sched.h>\n\n#include \"../kselftest.h\"\n#include \"clone3_selftests.h\"\n\nenum test_mode {\n\tCLONE3_ARGS_NO_TEST,\n\tCLONE3_ARGS_ALL_0,\n\tCLONE3_ARGS_INVAL_EXIT_SIGNAL_BIG,\n\tCLONE3_ARGS_INVAL_EXIT_SIGNAL_NEG,\n\tCLONE3_ARGS_INVAL_EXIT_SIGNAL_CSIG,\n\tCLONE3_ARGS_INVAL_EXIT_SIGNAL_NSIG,\n};\n\nstatic int call_clone3(uint64_t flags, size_t size, enum test_mode test_mode)\n{\n\tstruct __clone_args args = {\n\t\t.flags = flags,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\tstruct clone_args_extended {\n\t\tstruct __clone_args args;\n\t\t__aligned_u64 excess_space[2];\n\t} args_ext;\n\n\tpid_t pid = -1;\n\tint status;\n\n\tmemset(&args_ext, 0, sizeof(args_ext));\n\tif (size > sizeof(struct __clone_args))\n\t\targs_ext.excess_space[1] = 1;\n\n\tif (size == 0)\n\t\tsize = sizeof(struct __clone_args);\n\n\tswitch (test_mode) {\n\tcase CLONE3_ARGS_NO_TEST:\n\t\t \n\t\tbreak;\n\tcase CLONE3_ARGS_ALL_0:\n\t\targs.flags = 0;\n\t\targs.exit_signal = 0;\n\t\tbreak;\n\tcase CLONE3_ARGS_INVAL_EXIT_SIGNAL_BIG:\n\t\targs.exit_signal = 0xbadc0ded00000000ULL;\n\t\tbreak;\n\tcase CLONE3_ARGS_INVAL_EXIT_SIGNAL_NEG:\n\t\targs.exit_signal = 0x0000000080000000ULL;\n\t\tbreak;\n\tcase CLONE3_ARGS_INVAL_EXIT_SIGNAL_CSIG:\n\t\targs.exit_signal = 0x0000000000000100ULL;\n\t\tbreak;\n\tcase CLONE3_ARGS_INVAL_EXIT_SIGNAL_NSIG:\n\t\targs.exit_signal = 0x00000000000000f0ULL;\n\t\tbreak;\n\t}\n\n\tmemcpy(&args_ext.args, &args, sizeof(struct __clone_args));\n\n\tpid = sys_clone3((struct __clone_args *)&args_ext, size);\n\tif (pid < 0) {\n\t\tksft_print_msg(\"%s - Failed to create new process\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn -errno;\n\t}\n\n\tif (pid == 0) {\n\t\tksft_print_msg(\"I am the child, my PID is %d\\n\", getpid());\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tksft_print_msg(\"I am the parent (%d). My child's pid is %d\\n\",\n\t\t\tgetpid(), pid);\n\n\tif (waitpid(-1, &status, __WALL) < 0) {\n\t\tksft_print_msg(\"Child returned %s\\n\", strerror(errno));\n\t\treturn -errno;\n\t}\n\tif (WEXITSTATUS(status))\n\t\treturn WEXITSTATUS(status);\n\n\treturn 0;\n}\n\nstatic void test_clone3(uint64_t flags, size_t size, int expected,\n\t\t       enum test_mode test_mode)\n{\n\tint ret;\n\n\tksft_print_msg(\n\t\t\"[%d] Trying clone3() with flags %#\" PRIx64 \" (size %zu)\\n\",\n\t\tgetpid(), flags, size);\n\tret = call_clone3(flags, size, test_mode);\n\tksft_print_msg(\"[%d] clone3() with flags says: %d expected %d\\n\",\n\t\t\tgetpid(), ret, expected);\n\tif (ret != expected)\n\t\tksft_test_result_fail(\n\t\t\t\"[%d] Result (%d) is different than expected (%d)\\n\",\n\t\t\tgetpid(), ret, expected);\n\telse\n\t\tksft_test_result_pass(\n\t\t\t\"[%d] Result (%d) matches expectation (%d)\\n\",\n\t\t\tgetpid(), ret, expected);\n}\n\nint main(int argc, char *argv[])\n{\n\tuid_t uid = getuid();\n\n\tksft_print_header();\n\tksft_set_plan(19);\n\ttest_clone3_supported();\n\n\t \n\ttest_clone3(0, 0, 0, CLONE3_ARGS_NO_TEST);\n\n\t \n\tif (uid == 0)\n\t\ttest_clone3(CLONE_NEWPID, 0, 0, CLONE3_ARGS_NO_TEST);\n\telse\n\t\tksft_test_result_skip(\"Skipping clone3() with CLONE_NEWPID\\n\");\n\n\t \n\ttest_clone3(0, CLONE_ARGS_SIZE_VER0, 0, CLONE3_ARGS_NO_TEST);\n\n\t \n\ttest_clone3(0, CLONE_ARGS_SIZE_VER0 - 8, -EINVAL, CLONE3_ARGS_NO_TEST);\n\n\t \n\ttest_clone3(0, sizeof(struct __clone_args) + 8, 0, CLONE3_ARGS_NO_TEST);\n\n\t \n\ttest_clone3(0, 0, -EINVAL, CLONE3_ARGS_INVAL_EXIT_SIGNAL_BIG);\n\n\t \n\ttest_clone3(0, 0, -EINVAL, CLONE3_ARGS_INVAL_EXIT_SIGNAL_NEG);\n\n\t \n\ttest_clone3(0, 0, -EINVAL, CLONE3_ARGS_INVAL_EXIT_SIGNAL_CSIG);\n\n\t \n\ttest_clone3(0, 0, -EINVAL, CLONE3_ARGS_INVAL_EXIT_SIGNAL_NSIG);\n\n\ttest_clone3(0, sizeof(struct __clone_args) + 8, 0, CLONE3_ARGS_ALL_0);\n\n\ttest_clone3(0, sizeof(struct __clone_args) + 16, -E2BIG,\n\t\t\tCLONE3_ARGS_ALL_0);\n\n\ttest_clone3(0, sizeof(struct __clone_args) * 2, -E2BIG,\n\t\t\tCLONE3_ARGS_ALL_0);\n\n\t \n\ttest_clone3(0, getpagesize() + 8, -E2BIG, CLONE3_ARGS_NO_TEST);\n\n\t \n\tif (uid == 0)\n\t\ttest_clone3(CLONE_NEWPID, CLONE_ARGS_SIZE_VER0, 0,\n\t\t\t\tCLONE3_ARGS_NO_TEST);\n\telse\n\t\tksft_test_result_skip(\"Skipping clone3() with CLONE_NEWPID\\n\");\n\n\t \n\ttest_clone3(CLONE_NEWPID, CLONE_ARGS_SIZE_VER0 - 8, -EINVAL,\n\t\t\tCLONE3_ARGS_NO_TEST);\n\n\t \n\tif (uid == 0)\n\t\ttest_clone3(CLONE_NEWPID, sizeof(struct __clone_args) + 8, 0,\n\t\t\t\tCLONE3_ARGS_NO_TEST);\n\telse\n\t\tksft_test_result_skip(\"Skipping clone3() with CLONE_NEWPID\\n\");\n\n\t \n\ttest_clone3(CLONE_NEWPID, getpagesize() + 8, -E2BIG,\n\t\t\tCLONE3_ARGS_NO_TEST);\n\n\t \n\tif (access(\"/proc/self/ns/time\", F_OK) == 0) {\n\t\ttest_clone3(CLONE_NEWTIME, 0, 0, CLONE3_ARGS_NO_TEST);\n\t} else {\n\t\tksft_print_msg(\"Time namespaces are not supported\\n\");\n\t\tksft_test_result_skip(\"Skipping clone3() with CLONE_NEWTIME\\n\");\n\t}\n\n\t \n\ttest_clone3(SIGCHLD, 0, -EINVAL, CLONE3_ARGS_NO_TEST);\n\n\tksft_finished();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}