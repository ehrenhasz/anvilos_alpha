{
  "module_name": "proc_filter.c",
  "hash_id": "8edc6b1548738aa8c7ab7b64834d7fe0218c0974a244608dc66eab8060fd74da",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/connector/proc_filter.c",
  "human_readable_source": "\n\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/socket.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <linux/cn_proc.h>\n\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <strings.h>\n#include <errno.h>\n#include <signal.h>\n#include <string.h>\n\n#include \"../kselftest.h\"\n\n#define NL_MESSAGE_SIZE (sizeof(struct nlmsghdr) + sizeof(struct cn_msg) + \\\n\t\t\t sizeof(struct proc_input))\n#define NL_MESSAGE_SIZE_NF (sizeof(struct nlmsghdr) + sizeof(struct cn_msg) + \\\n\t\t\t sizeof(int))\n\n#define MAX_EVENTS 1\n\nvolatile static int interrupted;\nstatic int nl_sock, ret_errno, tcount;\nstatic struct epoll_event evn;\n\nstatic int filter;\n\n#ifdef ENABLE_PRINTS\n#define Printf printf\n#else\n#define Printf ksft_print_msg\n#endif\n\nint send_message(void *pinp)\n{\n\tchar buff[NL_MESSAGE_SIZE];\n\tstruct nlmsghdr *hdr;\n\tstruct cn_msg *msg;\n\n\thdr = (struct nlmsghdr *)buff;\n\tif (filter)\n\t\thdr->nlmsg_len = NL_MESSAGE_SIZE;\n\telse\n\t\thdr->nlmsg_len = NL_MESSAGE_SIZE_NF;\n\thdr->nlmsg_type = NLMSG_DONE;\n\thdr->nlmsg_flags = 0;\n\thdr->nlmsg_seq = 0;\n\thdr->nlmsg_pid = getpid();\n\n\tmsg = (struct cn_msg *)NLMSG_DATA(hdr);\n\tmsg->id.idx = CN_IDX_PROC;\n\tmsg->id.val = CN_VAL_PROC;\n\tmsg->seq = 0;\n\tmsg->ack = 0;\n\tmsg->flags = 0;\n\n\tif (filter) {\n\t\tmsg->len = sizeof(struct proc_input);\n\t\t((struct proc_input *)msg->data)->mcast_op =\n\t\t\t((struct proc_input *)pinp)->mcast_op;\n\t\t((struct proc_input *)msg->data)->event_type =\n\t\t\t((struct proc_input *)pinp)->event_type;\n\t} else {\n\t\tmsg->len = sizeof(int);\n\t\t*(int *)msg->data = *(enum proc_cn_mcast_op *)pinp;\n\t}\n\n\tif (send(nl_sock, hdr, hdr->nlmsg_len, 0) == -1) {\n\t\tret_errno = errno;\n\t\tperror(\"send failed\");\n\t\treturn -3;\n\t}\n\treturn 0;\n}\n\nint register_proc_netlink(int *efd, void *input)\n{\n\tstruct sockaddr_nl sa_nl;\n\tint err = 0, epoll_fd;\n\n\tnl_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\n\tif (nl_sock == -1) {\n\t\tret_errno = errno;\n\t\tperror(\"socket failed\");\n\t\treturn -1;\n\t}\n\n\tbzero(&sa_nl, sizeof(sa_nl));\n\tsa_nl.nl_family = AF_NETLINK;\n\tsa_nl.nl_groups = CN_IDX_PROC;\n\tsa_nl.nl_pid    = getpid();\n\n\tif (bind(nl_sock, (struct sockaddr *)&sa_nl, sizeof(sa_nl)) == -1) {\n\t\tret_errno = errno;\n\t\tperror(\"bind failed\");\n\t\treturn -2;\n\t}\n\n\tepoll_fd = epoll_create1(EPOLL_CLOEXEC);\n\tif (epoll_fd < 0) {\n\t\tret_errno = errno;\n\t\tperror(\"epoll_create1 failed\");\n\t\treturn -2;\n\t}\n\n\terr = send_message(input);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tevn.events = EPOLLIN;\n\tevn.data.fd = nl_sock;\n\tif (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, nl_sock, &evn) < 0) {\n\t\tret_errno = errno;\n\t\tperror(\"epoll_ctl failed\");\n\t\treturn -3;\n\t}\n\t*efd = epoll_fd;\n\treturn 0;\n}\n\nstatic void sigint(int sig)\n{\n\tinterrupted = 1;\n}\n\nint handle_packet(char *buff, int fd, struct proc_event *event)\n{\n\tstruct nlmsghdr *hdr;\n\n\thdr = (struct nlmsghdr *)buff;\n\n\tif (hdr->nlmsg_type == NLMSG_ERROR) {\n\t\tperror(\"NLMSG_ERROR error\\n\");\n\t\treturn -3;\n\t} else if (hdr->nlmsg_type == NLMSG_DONE) {\n\t\tevent = (struct proc_event *)\n\t\t\t((struct cn_msg *)NLMSG_DATA(hdr))->data;\n\t\ttcount++;\n\t\tswitch (event->what) {\n\t\tcase PROC_EVENT_EXIT:\n\t\t\tPrintf(\"Exit process %d (tgid %d) with code %d, signal %d\\n\",\n\t\t\t       event->event_data.exit.process_pid,\n\t\t\t       event->event_data.exit.process_tgid,\n\t\t\t       event->event_data.exit.exit_code,\n\t\t\t       event->event_data.exit.exit_signal);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_FORK:\n\t\t\tPrintf(\"Fork process %d (tgid %d), parent %d (tgid %d)\\n\",\n\t\t\t       event->event_data.fork.child_pid,\n\t\t\t       event->event_data.fork.child_tgid,\n\t\t\t       event->event_data.fork.parent_pid,\n\t\t\t       event->event_data.fork.parent_tgid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_EXEC:\n\t\t\tPrintf(\"Exec process %d (tgid %d)\\n\",\n\t\t\t       event->event_data.exec.process_pid,\n\t\t\t       event->event_data.exec.process_tgid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_UID:\n\t\t\tPrintf(\"UID process %d (tgid %d) uid %d euid %d\\n\",\n\t\t\t       event->event_data.id.process_pid,\n\t\t\t       event->event_data.id.process_tgid,\n\t\t\t       event->event_data.id.r.ruid,\n\t\t\t       event->event_data.id.e.euid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_GID:\n\t\t\tPrintf(\"GID process %d (tgid %d) gid %d egid %d\\n\",\n\t\t\t       event->event_data.id.process_pid,\n\t\t\t       event->event_data.id.process_tgid,\n\t\t\t       event->event_data.id.r.rgid,\n\t\t\t       event->event_data.id.e.egid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_SID:\n\t\t\tPrintf(\"SID process %d (tgid %d)\\n\",\n\t\t\t       event->event_data.sid.process_pid,\n\t\t\t       event->event_data.sid.process_tgid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_PTRACE:\n\t\t\tPrintf(\"Ptrace process %d (tgid %d), Tracer %d (tgid %d)\\n\",\n\t\t\t       event->event_data.ptrace.process_pid,\n\t\t\t       event->event_data.ptrace.process_tgid,\n\t\t\t       event->event_data.ptrace.tracer_pid,\n\t\t\t       event->event_data.ptrace.tracer_tgid);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_COMM:\n\t\t\tPrintf(\"Comm process %d (tgid %d) comm %s\\n\",\n\t\t\t       event->event_data.comm.process_pid,\n\t\t\t       event->event_data.comm.process_tgid,\n\t\t\t       event->event_data.comm.comm);\n\t\t\tbreak;\n\t\tcase PROC_EVENT_COREDUMP:\n\t\t\tPrintf(\"Coredump process %d (tgid %d) parent %d, (tgid %d)\\n\",\n\t\t\t       event->event_data.coredump.process_pid,\n\t\t\t       event->event_data.coredump.process_tgid,\n\t\t\t       event->event_data.coredump.parent_pid,\n\t\t\t       event->event_data.coredump.parent_tgid);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint handle_events(int epoll_fd, struct proc_event *pev)\n{\n\tchar buff[CONNECTOR_MAX_MSG_SIZE];\n\tstruct epoll_event ev[MAX_EVENTS];\n\tint i, event_count = 0, err = 0;\n\n\tevent_count = epoll_wait(epoll_fd, ev, MAX_EVENTS, -1);\n\tif (event_count < 0) {\n\t\tret_errno = errno;\n\t\tif (ret_errno != EINTR)\n\t\t\tperror(\"epoll_wait failed\");\n\t\treturn -3;\n\t}\n\tfor (i = 0; i < event_count; i++) {\n\t\tif (!(ev[i].events & EPOLLIN))\n\t\t\tcontinue;\n\t\tif (recv(ev[i].data.fd, buff, sizeof(buff), 0) == -1) {\n\t\t\tret_errno = errno;\n\t\t\tperror(\"recv failed\");\n\t\t\treturn -3;\n\t\t}\n\t\terr = handle_packet(buff, ev[i].data.fd, pev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint epoll_fd, err;\n\tstruct proc_event proc_ev;\n\tstruct proc_input input;\n\n\tsignal(SIGINT, sigint);\n\n\tif (argc > 2) {\n\t\tprintf(\"Expected 0(assume no-filter) or 1 argument(-f)\\n\");\n\t\texit(KSFT_SKIP);\n\t}\n\n\tif (argc == 2) {\n\t\tif (strcmp(argv[1], \"-f\") == 0) {\n\t\t\tfilter = 1;\n\t\t} else {\n\t\t\tprintf(\"Valid option : -f (for filter feature)\\n\");\n\t\t\texit(KSFT_SKIP);\n\t\t}\n\t}\n\n\tif (filter) {\n\t\tinput.event_type = PROC_EVENT_NONZERO_EXIT;\n\t\tinput.mcast_op = PROC_CN_MCAST_LISTEN;\n\t\terr = register_proc_netlink(&epoll_fd, (void*)&input);\n\t} else {\n\t\tenum proc_cn_mcast_op op = PROC_CN_MCAST_LISTEN;\n\t\terr = register_proc_netlink(&epoll_fd, (void*)&op);\n\t}\n\n\tif (err < 0) {\n\t\tif (err == -2)\n\t\t\tclose(nl_sock);\n\t\tif (err == -3) {\n\t\t\tclose(nl_sock);\n\t\t\tclose(epoll_fd);\n\t\t}\n\t\texit(1);\n\t}\n\n\twhile (!interrupted) {\n\t\terr = handle_events(epoll_fd, &proc_ev);\n\t\tif (err < 0) {\n\t\t\tif (ret_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (err == -2)\n\t\t\t\tclose(nl_sock);\n\t\t\tif (err == -3) {\n\t\t\t\tclose(nl_sock);\n\t\t\t\tclose(epoll_fd);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (filter) {\n\t\tinput.mcast_op = PROC_CN_MCAST_IGNORE;\n\t\tsend_message((void*)&input);\n\t} else {\n\t\tenum proc_cn_mcast_op op = PROC_CN_MCAST_IGNORE;\n\t\tsend_message((void*)&op);\n\t}\n\n\tclose(epoll_fd);\n\tclose(nl_sock);\n\n\tprintf(\"Done total count: %d\\n\", tcount);\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}