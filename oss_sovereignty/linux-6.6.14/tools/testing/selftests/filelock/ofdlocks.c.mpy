{
  "module_name": "ofdlocks.c",
  "hash_id": "7b936203c425582ab83369daaa9a3c103559f9dd6a529ff13a3777dd978f15a8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/filelock/ofdlocks.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <assert.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include \"../kselftest.h\"\n\nstatic int lock_set(int fd, struct flock *fl)\n{\n\tint ret;\n\n\tfl->l_pid = 0;\t\t\n\tfl->l_whence = SEEK_SET;\n\tret = fcntl(fd, F_OFD_SETLK, fl);\n\tif (ret)\n\t\tperror(\"fcntl()\");\n\treturn ret;\n}\n\nstatic int lock_get(int fd, struct flock *fl)\n{\n\tint ret;\n\n\tfl->l_pid = 0;\t\t\n\tfl->l_whence = SEEK_SET;\n\tret = fcntl(fd, F_OFD_GETLK, fl);\n\tif (ret)\n\t\tperror(\"fcntl()\");\n\treturn ret;\n}\n\nint main(void)\n{\n\tint rc;\n\tstruct flock fl, fl2;\n\tint fd = open(\"/tmp/aa\", O_RDWR | O_CREAT | O_EXCL, 0600);\n\tint fd2 = open(\"/tmp/aa\", O_RDONLY);\n\n\tunlink(\"/tmp/aa\");\n\tassert(fd != -1);\n\tassert(fd2 != -1);\n\tksft_print_msg(\"[INFO] opened fds %i %i\\n\", fd, fd2);\n\n\t \n\tfl.l_type = F_RDLCK;\n\tfl.l_start = 5;\n\tfl.l_len = 3;\n\trc = lock_set(fd, &fl);\n\tif (rc == 0) {\n\t\tksft_print_msg\n\t\t    (\"[SUCCESS] set OFD read lock on first fd\\n\");\n\t} else {\n\t\tksft_print_msg(\"[FAIL] to set OFD read lock on first fd\\n\");\n\t\treturn -1;\n\t}\n\t \n\tfl.l_type = F_RDLCK;\n\tfl.l_start = 5;\n\tfl.l_len = 1;\n\trc = lock_get(fd2, &fl);\n\tif (rc != 0)\n\t\treturn -1;\n\tif (fl.l_type != F_UNLCK) {\n\t\tksft_print_msg(\"[FAIL] read locks conflicted\\n\");\n\t\treturn -1;\n\t}\n\t \n\tfl.l_type = F_WRLCK;\n\tfl.l_start = 5;\n\tfl.l_len = 1;\n\trc = lock_get(fd2, &fl);\n\tif (rc != 0)\n\t\treturn -1;\n\tif (fl.l_type != F_UNLCK) {\n\t\tksft_print_msg\n\t\t    (\"[SUCCESS] read and write locks conflicted\\n\");\n\t} else {\n\t\tksft_print_msg\n\t\t    (\"[SUCCESS] read and write locks not conflicted\\n\");\n\t\treturn -1;\n\t}\n\t \n\tfl.l_type = F_UNLCK;\n\tfl.l_start = 5;\n\tfl.l_len = 1;\n\trc = lock_get(fd, &fl);\n\tif (rc != 0) {\n\t\tksft_print_msg\n\t\t    (\"[FAIL] F_OFD_GETLK with F_UNLCK not supported\\n\");\n\t\treturn -1;\n\t}\n\tif (fl.l_type != F_UNLCK) {\n\t\tksft_print_msg\n\t\t    (\"[SUCCESS] F_UNLCK test returns: locked, type %i pid %i len %zi\\n\",\n\t\t     fl.l_type, fl.l_pid, fl.l_len);\n\t} else {\n\t\tksft_print_msg\n\t\t    (\"[FAIL] F_OFD_GETLK with F_UNLCK did not return lock info\\n\");\n\t\treturn -1;\n\t}\n\t \n\tfl2.l_type = F_UNLCK;\n\tfl2.l_start = 0;\n\tfl2.l_len = 0;\n\trc = lock_get(fd, &fl2);\n\tif (rc != 0) {\n\t\tksft_print_msg\n\t\t    (\"[FAIL] F_OFD_GETLK with F_UNLCK not supported\\n\");\n\t\treturn -1;\n\t}\n\tif (memcmp(&fl, &fl2, sizeof(fl))) {\n\t\tksft_print_msg\n\t\t    (\"[FAIL] F_UNLCK test returns: locked, type %i pid %i len %zi\\n\",\n\t\t     fl.l_type, fl.l_pid, fl.l_len);\n\t\treturn -1;\n\t}\n\tksft_print_msg(\"[SUCCESS] F_UNLCK with len==0 returned the same\\n\");\n\t \n\tfl.l_type = F_UNLCK;\n\tfl.l_start = 0;\n\tfl.l_len = 0;\n\tlock_get(fd2, &fl);\n\tif (fl.l_type != F_UNLCK) {\n\t\tksft_print_msg\n\t\t    (\"[FAIL] F_OFD_GETLK with F_UNLCK return lock info from another fd\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}