{
  "module_name": "openat2_test.c",
  "hash_id": "1852a5f5d12c3ec4b0556867e046a25d5aee581e81d2e739cec189cddd5bef3e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/openat2/openat2_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <sched.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"../kselftest.h\"\n#include \"helpers.h\"\n\n \n#undef\tO_LARGEFILE\n#ifdef __aarch64__\n#define\tO_LARGEFILE 0x20000\n#else\n#define\tO_LARGEFILE 0x8000\n#endif\n\nstruct open_how_ext {\n\tstruct open_how inner;\n\tuint32_t extra1;\n\tchar pad1[128];\n\tuint32_t extra2;\n\tchar pad2[128];\n\tuint32_t extra3;\n};\n\nstruct struct_test {\n\tconst char *name;\n\tstruct open_how_ext arg;\n\tsize_t size;\n\tint err;\n};\n\n#define NUM_OPENAT2_STRUCT_TESTS 7\n#define NUM_OPENAT2_STRUCT_VARIATIONS 13\n\nvoid test_openat2_struct(void)\n{\n\tint misalignments[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 17, 87 };\n\n\tstruct struct_test tests[] = {\n\t\t \n\t\t{ .name = \"normal struct\",\n\t\t  .arg.inner.flags = O_RDONLY,\n\t\t  .size = sizeof(struct open_how) },\n\t\t \n\t\t{ .name = \"bigger struct (zeroed out)\",\n\t\t  .arg.inner.flags = O_RDONLY,\n\t\t  .size = sizeof(struct open_how_ext) },\n\n\t\t \n\n\t\t \n\t\t{ .name = \"zero-sized 'struct'\",\n\t\t  .arg.inner.flags = O_RDONLY, .size = 0, .err = -EINVAL },\n\t\t{ .name = \"smaller-than-v0 struct\",\n\t\t  .arg.inner.flags = O_RDONLY,\n\t\t  .size = OPEN_HOW_SIZE_VER0 - 1, .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"bigger struct (non-zero data in first 'future field')\",\n\t\t  .arg.inner.flags = O_RDONLY, .arg.extra1 = 0xdeadbeef,\n\t\t  .size = sizeof(struct open_how_ext), .err = -E2BIG },\n\t\t{ .name = \"bigger struct (non-zero data in middle of 'future fields')\",\n\t\t  .arg.inner.flags = O_RDONLY, .arg.extra2 = 0xfeedcafe,\n\t\t  .size = sizeof(struct open_how_ext), .err = -E2BIG },\n\t\t{ .name = \"bigger struct (non-zero data at end of 'future fields')\",\n\t\t  .arg.inner.flags = O_RDONLY, .arg.extra3 = 0xabad1dea,\n\t\t  .size = sizeof(struct open_how_ext), .err = -E2BIG },\n\t};\n\n\tBUILD_BUG_ON(ARRAY_LEN(misalignments) != NUM_OPENAT2_STRUCT_VARIATIONS);\n\tBUILD_BUG_ON(ARRAY_LEN(tests) != NUM_OPENAT2_STRUCT_TESTS);\n\n\tfor (int i = 0; i < ARRAY_LEN(tests); i++) {\n\t\tstruct struct_test *test = &tests[i];\n\t\tstruct open_how_ext how_ext = test->arg;\n\n\t\tfor (int j = 0; j < ARRAY_LEN(misalignments); j++) {\n\t\t\tint fd, misalign = misalignments[j];\n\t\t\tchar *fdpath = NULL;\n\t\t\tbool failed;\n\t\t\tvoid (*resultfn)(const char *msg, ...) = ksft_test_result_pass;\n\n\t\t\tvoid *copy = NULL, *how_copy = &how_ext;\n\n\t\t\tif (!openat2_supported) {\n\t\t\t\tksft_print_msg(\"openat2(2) unsupported\\n\");\n\t\t\t\tresultfn = ksft_test_result_skip;\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tif (misalign) {\n\t\t\t\t \n\t\t\t\tcopy = malloc(misalign + sizeof(how_ext));\n\t\t\t\thow_copy = copy + misalign;\n\t\t\t\tmemset(copy, 0xff, misalign);\n\t\t\t\tmemcpy(how_copy, &how_ext, sizeof(how_ext));\n\t\t\t}\n\n\t\t\tfd = raw_openat2(AT_FDCWD, \".\", how_copy, test->size);\n\t\t\tif (test->err >= 0)\n\t\t\t\tfailed = (fd < 0);\n\t\t\telse\n\t\t\t\tfailed = (fd != test->err);\n\t\t\tif (fd >= 0) {\n\t\t\t\tfdpath = fdreadlink(fd);\n\t\t\t\tclose(fd);\n\t\t\t}\n\n\t\t\tif (failed) {\n\t\t\t\tresultfn = ksft_test_result_fail;\n\n\t\t\t\tksft_print_msg(\"openat2 unexpectedly returned \");\n\t\t\t\tif (fdpath)\n\t\t\t\t\tksft_print_msg(\"%d['%s']\\n\", fd, fdpath);\n\t\t\t\telse\n\t\t\t\t\tksft_print_msg(\"%d (%s)\\n\", fd, strerror(-fd));\n\t\t\t}\n\nskip:\n\t\t\tif (test->err >= 0)\n\t\t\t\tresultfn(\"openat2 with %s argument [misalign=%d] succeeds\\n\",\n\t\t\t\t\t test->name, misalign);\n\t\t\telse\n\t\t\t\tresultfn(\"openat2 with %s argument [misalign=%d] fails with %d (%s)\\n\",\n\t\t\t\t\t test->name, misalign, test->err,\n\t\t\t\t\t strerror(-test->err));\n\n\t\t\tfree(copy);\n\t\t\tfree(fdpath);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n}\n\nstruct flag_test {\n\tconst char *name;\n\tstruct open_how how;\n\tint err;\n};\n\n#define NUM_OPENAT2_FLAG_TESTS 25\n\nvoid test_openat2_flags(void)\n{\n\tstruct flag_test tests[] = {\n\t\t \n\t\t{ .name = \"incompatible flags (O_TMPFILE | O_PATH)\",\n\t\t  .how.flags = O_TMPFILE | O_PATH | O_RDWR, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_TMPFILE | O_CREAT)\",\n\t\t  .how.flags = O_TMPFILE | O_CREAT | O_RDWR, .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"compatible flags (O_PATH | O_CLOEXEC)\",\n\t\t  .how.flags = O_PATH | O_CLOEXEC },\n\t\t{ .name = \"compatible flags (O_PATH | O_DIRECTORY)\",\n\t\t  .how.flags = O_PATH | O_DIRECTORY },\n\t\t{ .name = \"compatible flags (O_PATH | O_NOFOLLOW)\",\n\t\t  .how.flags = O_PATH | O_NOFOLLOW },\n\t\t \n\t\t{ .name = \"incompatible flags (O_PATH | O_RDWR)\",\n\t\t  .how.flags = O_PATH | O_RDWR, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_PATH | O_CREAT)\",\n\t\t  .how.flags = O_PATH | O_CREAT, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_PATH | O_EXCL)\",\n\t\t  .how.flags = O_PATH | O_EXCL, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_PATH | O_NOCTTY)\",\n\t\t  .how.flags = O_PATH | O_NOCTTY, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_PATH | O_DIRECT)\",\n\t\t  .how.flags = O_PATH | O_DIRECT, .err = -EINVAL },\n\t\t{ .name = \"incompatible flags (O_PATH | O_LARGEFILE)\",\n\t\t  .how.flags = O_PATH | O_LARGEFILE, .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"non-zero how.mode and O_RDONLY\",\n\t\t  .how.flags = O_RDONLY, .how.mode = 0600, .err = -EINVAL },\n\t\t{ .name = \"non-zero how.mode and O_PATH\",\n\t\t  .how.flags = O_PATH,   .how.mode = 0600, .err = -EINVAL },\n\t\t{ .name = \"valid how.mode and O_CREAT\",\n\t\t  .how.flags = O_CREAT,  .how.mode = 0600 },\n\t\t{ .name = \"valid how.mode and O_TMPFILE\",\n\t\t  .how.flags = O_TMPFILE | O_RDWR, .how.mode = 0600 },\n\t\t \n\t\t{ .name = \"invalid how.mode and O_CREAT\",\n\t\t  .how.flags = O_CREAT,\n\t\t  .how.mode = 0xFFFF, .err = -EINVAL },\n\t\t{ .name = \"invalid (very large) how.mode and O_CREAT\",\n\t\t  .how.flags = O_CREAT,\n\t\t  .how.mode = 0xC000000000000000ULL, .err = -EINVAL },\n\t\t{ .name = \"invalid how.mode and O_TMPFILE\",\n\t\t  .how.flags = O_TMPFILE | O_RDWR,\n\t\t  .how.mode = 0x1337, .err = -EINVAL },\n\t\t{ .name = \"invalid (very large) how.mode and O_TMPFILE\",\n\t\t  .how.flags = O_TMPFILE | O_RDWR,\n\t\t  .how.mode = 0x0000A00000000000ULL, .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"incompatible resolve flags (BENEATH | IN_ROOT)\",\n\t\t  .how.flags = O_RDONLY,\n\t\t  .how.resolve = RESOLVE_BENEATH | RESOLVE_IN_ROOT,\n\t\t  .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"invalid how.resolve and O_RDONLY\",\n\t\t  .how.flags = O_RDONLY,\n\t\t  .how.resolve = 0x1337, .err = -EINVAL },\n\t\t{ .name = \"invalid how.resolve and O_CREAT\",\n\t\t  .how.flags = O_CREAT,\n\t\t  .how.resolve = 0x1337, .err = -EINVAL },\n\t\t{ .name = \"invalid how.resolve and O_TMPFILE\",\n\t\t  .how.flags = O_TMPFILE | O_RDWR,\n\t\t  .how.resolve = 0x1337, .err = -EINVAL },\n\t\t{ .name = \"invalid how.resolve and O_PATH\",\n\t\t  .how.flags = O_PATH,\n\t\t  .how.resolve = 0x1337, .err = -EINVAL },\n\n\t\t \n\t\t{ .name = \"currently unknown bit (1 << 63)\",\n\t\t  .how.flags = O_RDONLY | (1ULL << 63),\n\t\t  .how.resolve = 0, .err = -EINVAL },\n\t};\n\n\tBUILD_BUG_ON(ARRAY_LEN(tests) != NUM_OPENAT2_FLAG_TESTS);\n\n\tfor (int i = 0; i < ARRAY_LEN(tests); i++) {\n\t\tint fd, fdflags = -1;\n\t\tchar *path, *fdpath = NULL;\n\t\tbool failed = false;\n\t\tstruct flag_test *test = &tests[i];\n\t\tvoid (*resultfn)(const char *msg, ...) = ksft_test_result_pass;\n\n\t\tif (!openat2_supported) {\n\t\t\tksft_print_msg(\"openat2(2) unsupported\\n\");\n\t\t\tresultfn = ksft_test_result_skip;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tpath = (test->how.flags & O_CREAT) ? \"/tmp/ksft.openat2_tmpfile\" : \".\";\n\t\tunlink(path);\n\n\t\tfd = sys_openat2(AT_FDCWD, path, &test->how);\n\t\tif (fd < 0 && fd == -EOPNOTSUPP) {\n\t\t\t \n\t\t\tksft_test_result_skip(\"openat2 with %s fails with %d (%s)\\n\",\n\t\t\t\t\t      test->name, fd, strerror(-fd));\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (test->err >= 0)\n\t\t\tfailed = (fd < 0);\n\t\telse\n\t\t\tfailed = (fd != test->err);\n\t\tif (fd >= 0) {\n\t\t\tint otherflags;\n\n\t\t\tfdpath = fdreadlink(fd);\n\t\t\tfdflags = fcntl(fd, F_GETFL);\n\t\t\totherflags = fcntl(fd, F_GETFD);\n\t\t\tclose(fd);\n\n\t\t\tE_assert(fdflags >= 0, \"fcntl F_GETFL of new fd\");\n\t\t\tE_assert(otherflags >= 0, \"fcntl F_GETFD of new fd\");\n\n\t\t\t \n\t\t\tif (otherflags & FD_CLOEXEC)\n\t\t\t\tfdflags |= O_CLOEXEC;\n\t\t\t \n\t\t\tif (test->how.flags & O_CREAT)\n\t\t\t\tfdflags |= O_CREAT;\n\t\t\tif (!(test->how.flags & O_LARGEFILE))\n\t\t\t\tfdflags &= ~O_LARGEFILE;\n\t\t\tfailed |= (fdflags != test->how.flags);\n\t\t}\n\n\t\tif (failed) {\n\t\t\tresultfn = ksft_test_result_fail;\n\n\t\t\tksft_print_msg(\"openat2 unexpectedly returned \");\n\t\t\tif (fdpath)\n\t\t\t\tksft_print_msg(\"%d['%s'] with %X (!= %X)\\n\",\n\t\t\t\t\t       fd, fdpath, fdflags,\n\t\t\t\t\t       test->how.flags);\n\t\t\telse\n\t\t\t\tksft_print_msg(\"%d (%s)\\n\", fd, strerror(-fd));\n\t\t}\n\nskip:\n\t\tif (test->err >= 0)\n\t\t\tresultfn(\"openat2 with %s succeeds\\n\", test->name);\n\t\telse\n\t\t\tresultfn(\"openat2 with %s fails with %d (%s)\\n\",\n\t\t\t\t test->name, test->err, strerror(-test->err));\nnext:\n\t\tfree(fdpath);\n\t\tfflush(stdout);\n\t}\n}\n\n#define NUM_TESTS (NUM_OPENAT2_STRUCT_VARIATIONS * NUM_OPENAT2_STRUCT_TESTS + \\\n\t\t   NUM_OPENAT2_FLAG_TESTS)\n\nint main(int argc, char **argv)\n{\n\tksft_print_header();\n\tksft_set_plan(NUM_TESTS);\n\n\ttest_openat2_struct();\n\ttest_openat2_flags();\n\n\tif (ksft_get_fail_cnt() + ksft_get_error_cnt() > 0)\n\t\tksft_exit_fail();\n\telse\n\t\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}