{
  "module_name": "resolve_test.c",
  "hash_id": "812ffa12d87921bc144e5325eacf283971c87a935bc4e9b6ad607bd7cafc105c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/openat2/resolve_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <sched.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"../kselftest.h\"\n#include \"helpers.h\"\n\n \nint setup_testdir(void)\n{\n\tint dfd, tmpfd;\n\tchar dirname[] = \"/tmp/ksft-openat2-testdir.XXXXXX\";\n\n\t \n\tE_unshare(CLONE_NEWNS);\n\tE_mount(\"\", \"/tmp\", \"\", MS_PRIVATE, \"\");\n\n\t \n\tif (!mkdtemp(dirname))\n\t\tksft_exit_fail_msg(\"setup_testdir: failed to create tmpdir\\n\");\n\tdfd = open(dirname, O_PATH | O_DIRECTORY);\n\tif (dfd < 0)\n\t\tksft_exit_fail_msg(\"setup_testdir: failed to open tmpdir\\n\");\n\n\t \n\tE_mkdirat(dfd, \"root\", 0755);\n\ttmpfd = openat(dfd, \"root\", O_PATH | O_DIRECTORY);\n\tif (tmpfd < 0)\n\t\tksft_exit_fail_msg(\"setup_testdir: failed to open tmpdir\\n\");\n\tclose(dfd);\n\tdfd = tmpfd;\n\n\tE_symlinkat(\"/proc/self/exe\", dfd, \"procexe\");\n\tE_symlinkat(\"/proc/self/root\", dfd, \"procroot\");\n\tE_mkdirat(dfd, \"root\", 0755);\n\n\t \n\tE_mkdirat(dfd, \"mnt\", 0755);\n\tE_fchdir(dfd);\n\tE_mount(\"tmpfs\", \"./mnt\", \"tmpfs\", MS_NOSUID | MS_NODEV, \"\");\n\tE_symlinkat(\"../mnt/\", dfd, \"mnt/self\");\n\tE_symlinkat(\"/mnt/\", dfd, \"mnt/absself\");\n\n\tE_mkdirat(dfd, \"etc\", 0755);\n\tE_touchat(dfd, \"etc/passwd\");\n\n\tE_symlinkat(\"/newfile3\", dfd, \"creatlink\");\n\tE_symlinkat(\"etc/\", dfd, \"reletc\");\n\tE_symlinkat(\"etc/passwd\", dfd, \"relsym\");\n\tE_symlinkat(\"/etc/\", dfd, \"absetc\");\n\tE_symlinkat(\"/etc/passwd\", dfd, \"abssym\");\n\tE_symlinkat(\"/cheeky\", dfd, \"abscheeky\");\n\n\tE_mkdirat(dfd, \"cheeky\", 0755);\n\n\tE_symlinkat(\"/\", dfd, \"cheeky/absself\");\n\tE_symlinkat(\"../../root/\", dfd, \"cheeky/self\");\n\tE_symlinkat(\"/../../root/\", dfd, \"cheeky/garbageself\");\n\n\tE_symlinkat(\"../cheeky/../etc/../etc/passwd\", dfd, \"cheeky/passwd\");\n\tE_symlinkat(\"/../cheeky/../etc/../etc/passwd\", dfd, \"cheeky/abspasswd\");\n\n\tE_symlinkat(\"../../../../../../../../../../../../../../etc/passwd\",\n\t\t    dfd, \"cheeky/dotdotlink\");\n\tE_symlinkat(\"/../../../../../../../../../../../../../../etc/passwd\",\n\t\t    dfd, \"cheeky/garbagelink\");\n\n\treturn dfd;\n}\n\nstruct basic_test {\n\tconst char *name;\n\tconst char *dir;\n\tconst char *path;\n\tstruct open_how how;\n\tbool pass;\n\tunion {\n\t\tint err;\n\t\tconst char *path;\n\t} out;\n};\n\n#define NUM_OPENAT2_OPATH_TESTS 88\n\nvoid test_openat2_opath_tests(void)\n{\n\tint rootfd, hardcoded_fd;\n\tchar *procselfexe, *hardcoded_fdpath;\n\n\tE_asprintf(&procselfexe, \"/proc/%d/exe\", getpid());\n\trootfd = setup_testdir();\n\n\thardcoded_fd = open(\"/dev/null\", O_RDONLY);\n\tE_assert(hardcoded_fd >= 0, \"open fd to hardcode\");\n\tE_asprintf(&hardcoded_fdpath, \"self/fd/%d\", hardcoded_fd);\n\n\tstruct basic_test tests[] = {\n\t\t \n\t\t \n\t\t{ .name = \"[beneath] jump to /\",\n\t\t  .path = \"/\",\t\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] absolute link to $root\",\n\t\t  .path = \"cheeky/absself\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] chained absolute links to $root\",\n\t\t  .path = \"abscheeky/absself\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] jump outside $root\",\n\t\t  .path = \"..\",\t\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] temporary jump outside $root\",\n\t\t  .path = \"../root/\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] symlink temporary jump outside $root\",\n\t\t  .path = \"cheeky/self\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] chained symlink temporary jump outside $root\",\n\t\t  .path = \"abscheeky/self\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] garbage links to $root\",\n\t\t  .path = \"cheeky/garbageself\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] chained garbage links to $root\",\n\t\t  .path = \"abscheeky/garbageself\", .how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[beneath] ordinary path to 'root'\",\n\t\t  .path = \"root\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[beneath] ordinary path to 'etc'\",\n\t\t  .path = \"etc\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.path = \"etc\",\t\t.pass = true },\n\t\t{ .name = \"[beneath] ordinary path to 'etc/passwd'\",\n\t\t  .path = \"etc/passwd\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[beneath] relative symlink inside $root\",\n\t\t  .path = \"relsym\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[beneath] chained-'..' relative symlink inside $root\",\n\t\t  .path = \"cheeky/passwd\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[beneath] absolute symlink component outside $root\",\n\t\t  .path = \"abscheeky/passwd\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] absolute symlink target outside $root\",\n\t\t  .path = \"abssym\",\t\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] absolute path outside $root\",\n\t\t  .path = \"/etc/passwd\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] cheeky absolute path outside $root\",\n\t\t  .path = \"cheeky/abspasswd\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] chained cheeky absolute path outside $root\",\n\t\t  .path = \"abscheeky/abspasswd\", .how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[beneath] tricky '..'-chained symlink outside $root\",\n\t\t  .path = \"cheeky/dotdotlink\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] tricky absolute + '..'-chained symlink outside $root\",\n\t\t  .path = \"abscheeky/dotdotlink\", .how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] tricky garbage link outside $root\",\n\t\t  .path = \"cheeky/garbagelink\",\t.how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[beneath] tricky absolute + garbage link outside $root\",\n\t\t  .path = \"abscheeky/garbagelink\", .how.resolve = RESOLVE_BENEATH,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\n\t\t \n\t\t \n\t\t{ .name = \"[in_root] jump to /\",\n\t\t  .path = \"/\",\t\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = NULL,\t\t.pass = true },\n\t\t{ .name = \"[in_root] absolute symlink to /root\",\n\t\t  .path = \"cheeky/absself\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = NULL,\t\t.pass = true },\n\t\t{ .name = \"[in_root] chained absolute symlinks to /root\",\n\t\t  .path = \"abscheeky/absself\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = NULL,\t\t.pass = true },\n\t\t{ .name = \"[in_root] '..' at root\",\n\t\t  .path = \"..\",\t\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = NULL,\t\t.pass = true },\n\t\t{ .name = \"[in_root] '../root' at root\",\n\t\t  .path = \"../root/\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] relative symlink containing '..' above root\",\n\t\t  .path = \"cheeky/self\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] garbage link to /root\",\n\t\t  .path = \"cheeky/garbageself\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] chained garbage links to /root\",\n\t\t  .path = \"abscheeky/garbageself\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] relative path to 'root'\",\n\t\t  .path = \"root\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] relative path to 'etc'\",\n\t\t  .path = \"etc\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc\",\t\t.pass = true },\n\t\t{ .name = \"[in_root] relative path to 'etc/passwd'\",\n\t\t  .path = \"etc/passwd\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] relative symlink to 'etc/passwd'\",\n\t\t  .path = \"relsym\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] chained-'..' relative symlink to 'etc/passwd'\",\n\t\t  .path = \"cheeky/passwd\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] chained-'..' absolute + relative symlink to 'etc/passwd'\",\n\t\t  .path = \"abscheeky/passwd\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] absolute symlink to 'etc/passwd'\",\n\t\t  .path = \"abssym\",\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] absolute path 'etc/passwd'\",\n\t\t  .path = \"/etc/passwd\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] cheeky absolute path 'etc/passwd'\",\n\t\t  .path = \"cheeky/abspasswd\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] chained cheeky absolute path 'etc/passwd'\",\n\t\t  .path = \"abscheeky/abspasswd\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky '..'-chained symlink outside $root\",\n\t\t  .path = \"cheeky/dotdotlink\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky absolute + '..'-chained symlink outside $root\",\n\t\t  .path = \"abscheeky/dotdotlink\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky absolute path + absolute + '..'-chained symlink outside $root\",\n\t\t  .path = \"/../../../../abscheeky/dotdotlink\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky garbage link outside $root\",\n\t\t  .path = \"cheeky/garbagelink\",\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky absolute + garbage link outside $root\",\n\t\t  .path = \"abscheeky/garbagelink\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t{ .name = \"[in_root] tricky absolute path + absolute + garbage link outside $root\",\n\t\t  .path = \"/../../../../abscheeky/garbagelink\", .how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t \n\t\t{ .name = \"[in_root] O_CREAT of relative path inside $root\",\n\t\t  .path = \"newfile1\",\t\t.how.flags = O_CREAT,\n\t\t\t\t\t\t.how.mode = 0700,\n\t\t\t\t\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"newfile1\",\t.pass = true },\n\t\t{ .name = \"[in_root] O_CREAT of absolute path\",\n\t\t  .path = \"/newfile2\",\t\t.how.flags = O_CREAT,\n\t\t\t\t\t\t.how.mode = 0700,\n\t\t\t\t\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"newfile2\",\t.pass = true },\n\t\t{ .name = \"[in_root] O_CREAT of tricky symlink outside root\",\n\t\t  .path = \"/creatlink\",\t\t.how.flags = O_CREAT,\n\t\t\t\t\t\t.how.mode = 0700,\n\t\t\t\t\t\t.how.resolve = RESOLVE_IN_ROOT,\n\t\t  .out.path = \"newfile3\",\t.pass = true },\n\n\t\t \n\t\t \n\t\t{ .name = \"[no_xdev] cross into $mnt\",\n\t\t  .path = \"mnt\",\t\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] cross into $mnt/\",\n\t\t  .path = \"mnt/\",\t\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] cross into $mnt/.\",\n\t\t  .path = \"mnt/.\",\t\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[no_xdev] goto mountpoint root\",\n\t\t  .dir = \"mnt\", .path = \".\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.path = \"mnt\",\t\t.pass = true },\n\t\t{ .name = \"[no_xdev] cross up through '..'\",\n\t\t  .dir = \"mnt\", .path = \"..\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] temporary cross up through '..'\",\n\t\t  .dir = \"mnt\", .path = \"../mnt\", .how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] temporary relative symlink cross up\",\n\t\t  .dir = \"mnt\", .path = \"self\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] temporary absolute symlink cross up\",\n\t\t  .dir = \"mnt\", .path = \"absself\", .how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[no_xdev] jump to / directly\",\n\t\t  .dir = \"mnt\", .path = \"/\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.path = \"/\",\t\t.pass = true },\n\t\t{ .name = \"[no_xdev] jump to / (from /) directly\",\n\t\t  .dir = \"/\", .path = \"/\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.path = \"/\",\t\t.pass = true },\n\t\t{ .name = \"[no_xdev] jump to / then proc\",\n\t\t  .path = \"/proc/1\",\t\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] jump to / then tmp\",\n\t\t  .path = \"/tmp\",\t\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[no_xdev] cross through magic-link to self/root\",\n\t\t  .dir = \"/proc\", .path = \"self/root\", \t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t\t.pass = false },\n\t\t{ .name = \"[no_xdev] cross through magic-link to self/cwd\",\n\t\t  .dir = \"/proc\", .path = \"self/cwd\",\t.how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.err = -EXDEV,\t\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[no_xdev] jump through magic-link to same procfs\",\n\t\t  .dir = \"/proc\", .path = hardcoded_fdpath, .how.resolve = RESOLVE_NO_XDEV,\n\t\t  .out.path = \"/proc\",\t\t\t    .pass = true, },\n\n\t\t \n\t\t \n\t\t{ .name = \"[no_magiclinks] ordinary relative symlink\",\n\t\t  .path = \"relsym\",\t\t.how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t \n\t\t{ .name = \"[no_magiclinks] symlink to magic-link\",\n\t\t  .path = \"procexe\",\t\t.how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_magiclinks] normal path to magic-link\",\n\t\t  .path = \"/proc/self/exe\",\t.how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_magiclinks] normal path to magic-link with O_NOFOLLOW\",\n\t\t  .path = \"/proc/self/exe\",\t.how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t.how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.path = procselfexe,\t.pass = true },\n\t\t{ .name = \"[no_magiclinks] symlink to magic-link path component\",\n\t\t  .path = \"procroot/etc\",\t.how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_magiclinks] magic-link path component\",\n\t\t  .path = \"/proc/self/root/etc\", .how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_magiclinks] magic-link path component with O_NOFOLLOW\",\n\t\t  .path = \"/proc/self/root/etc\", .how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t .how.resolve = RESOLVE_NO_MAGICLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\n\t\t \n\t\t \n\t\t{ .name = \"[no_symlinks] ordinary path to '.'\",\n\t\t  .path = \".\",\t\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = NULL,\t\t.pass = true },\n\t\t{ .name = \"[no_symlinks] ordinary path to 'root'\",\n\t\t  .path = \"root\",\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"root\",\t\t.pass = true },\n\t\t{ .name = \"[no_symlinks] ordinary path to 'etc'\",\n\t\t  .path = \"etc\",\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"etc\",\t\t.pass = true },\n\t\t{ .name = \"[no_symlinks] ordinary path to 'etc/passwd'\",\n\t\t  .path = \"etc/passwd\",\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"etc/passwd\",\t.pass = true },\n\t\t \n\t\t{ .name = \"[no_symlinks] relative symlink target\",\n\t\t  .path = \"relsym\",\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] relative symlink component\",\n\t\t  .path = \"reletc/passwd\",\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] absolute symlink target\",\n\t\t  .path = \"abssym\",\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] absolute symlink component\",\n\t\t  .path = \"absetc/passwd\",\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] cheeky garbage link\",\n\t\t  .path = \"cheeky/garbagelink\",\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] cheeky absolute + garbage link\",\n\t\t  .path = \"abscheeky/garbagelink\", .how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] cheeky absolute + absolute symlink\",\n\t\t  .path = \"abscheeky/absself\",\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t \n\t\t{ .name = \"[no_symlinks] relative symlink with O_NOFOLLOW\",\n\t\t  .path = \"relsym\",\t\t.how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"relsym\",\t\t.pass = true },\n\t\t{ .name = \"[no_symlinks] absolute symlink with O_NOFOLLOW\",\n\t\t  .path = \"abssym\",\t\t.how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"abssym\",\t\t.pass = true },\n\t\t{ .name = \"[no_symlinks] trailing symlink with O_NOFOLLOW\",\n\t\t  .path = \"cheeky/garbagelink\",\t.how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.path = \"cheeky/garbagelink\", .pass = true },\n\t\t{ .name = \"[no_symlinks] multiple symlink components with O_NOFOLLOW\",\n\t\t  .path = \"abscheeky/absself\",\t.how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t.how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t\t{ .name = \"[no_symlinks] multiple symlink (and garbage link) components with O_NOFOLLOW\",\n\t\t  .path = \"abscheeky/garbagelink\", .how.flags = O_NOFOLLOW,\n\t\t\t\t\t\t   .how.resolve = RESOLVE_NO_SYMLINKS,\n\t\t  .out.err = -ELOOP,\t\t.pass = false },\n\t};\n\n\tBUILD_BUG_ON(ARRAY_LEN(tests) != NUM_OPENAT2_OPATH_TESTS);\n\n\tfor (int i = 0; i < ARRAY_LEN(tests); i++) {\n\t\tint dfd, fd;\n\t\tchar *fdpath = NULL;\n\t\tbool failed;\n\t\tvoid (*resultfn)(const char *msg, ...) = ksft_test_result_pass;\n\t\tstruct basic_test *test = &tests[i];\n\n\t\tif (!openat2_supported) {\n\t\t\tksft_print_msg(\"openat2(2) unsupported\\n\");\n\t\t\tresultfn = ksft_test_result_skip;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t \n\t\tif (!(test->how.flags & O_CREAT))\n\t\t\ttest->how.flags |= O_PATH;\n\n\t\tif (test->dir)\n\t\t\tdfd = openat(rootfd, test->dir, O_PATH | O_DIRECTORY);\n\t\telse\n\t\t\tdfd = dup(rootfd);\n\t\tE_assert(dfd, \"failed to openat root '%s': %m\", test->dir);\n\n\t\tE_dup2(dfd, hardcoded_fd);\n\n\t\tfd = sys_openat2(dfd, test->path, &test->how);\n\t\tif (test->pass)\n\t\t\tfailed = (fd < 0 || !fdequal(fd, rootfd, test->out.path));\n\t\telse\n\t\t\tfailed = (fd != test->out.err);\n\t\tif (fd >= 0) {\n\t\t\tfdpath = fdreadlink(fd);\n\t\t\tclose(fd);\n\t\t}\n\t\tclose(dfd);\n\n\t\tif (failed) {\n\t\t\tresultfn = ksft_test_result_fail;\n\n\t\t\tksft_print_msg(\"openat2 unexpectedly returned \");\n\t\t\tif (fdpath)\n\t\t\t\tksft_print_msg(\"%d['%s']\\n\", fd, fdpath);\n\t\t\telse\n\t\t\t\tksft_print_msg(\"%d (%s)\\n\", fd, strerror(-fd));\n\t\t}\n\nskip:\n\t\tif (test->pass)\n\t\t\tresultfn(\"%s gives path '%s'\\n\", test->name,\n\t\t\t\t test->out.path ?: \".\");\n\t\telse\n\t\t\tresultfn(\"%s fails with %d (%s)\\n\", test->name,\n\t\t\t\t test->out.err, strerror(-test->out.err));\n\n\t\tfflush(stdout);\n\t\tfree(fdpath);\n\t}\n\n\tfree(procselfexe);\n\tclose(rootfd);\n\n\tfree(hardcoded_fdpath);\n\tclose(hardcoded_fd);\n}\n\n#define NUM_TESTS NUM_OPENAT2_OPATH_TESTS\n\nint main(int argc, char **argv)\n{\n\tksft_print_header();\n\tksft_set_plan(NUM_TESTS);\n\n\t \n\tif (geteuid() != 0)\n\t\tksft_exit_skip(\"all tests require euid == 0\\n\");\n\n\ttest_openat2_opath_tests();\n\n\tif (ksft_get_fail_cnt() + ksft_get_error_cnt() > 0)\n\t\tksft_exit_fail();\n\telse\n\t\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}