{
  "module_name": "cs_prctl_test.c",
  "hash_id": "1527a8796349fc4b142f998215a3cfac545d0ec7206151e8cced06ddfceae5cb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sched/cs_prctl_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sys/eventfd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sched.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if __GLIBC_PREREQ(2, 30) == 0\n#include <sys/syscall.h>\nstatic pid_t gettid(void)\n{\n\treturn syscall(SYS_gettid);\n}\n#endif\n\n#ifndef PR_SCHED_CORE\n#define PR_SCHED_CORE\t\t\t62\n# define PR_SCHED_CORE_GET\t\t0\n# define PR_SCHED_CORE_CREATE\t\t1  \n# define PR_SCHED_CORE_SHARE_TO\t\t2  \n# define PR_SCHED_CORE_SHARE_FROM\t3  \n# define PR_SCHED_CORE_MAX\t\t4\n#endif\n\n#define MAX_PROCESSES 128\n#define MAX_THREADS   128\n\nstatic const char USAGE[] = \"cs_prctl_test [options]\\n\"\n\"    options:\\n\"\n\"\t-P  : number of processes to create.\\n\"\n\"\t-T  : number of threads per process to create.\\n\"\n\"\t-d  : delay time to keep tasks alive.\\n\"\n\"\t-k  : keep tasks alive until keypress.\\n\";\n\nenum pid_type {PIDTYPE_PID = 0, PIDTYPE_TGID, PIDTYPE_PGID};\n\nconst int THREAD_CLONE_FLAGS = CLONE_THREAD | CLONE_SIGHAND | CLONE_FS | CLONE_VM | CLONE_FILES;\n\nstruct child_args {\n\tint num_threads;\n\tint pfd[2];\n\tint cpid;\n\tint thr_tids[MAX_THREADS];\n};\n\nstatic struct child_args procs[MAX_PROCESSES];\nstatic int num_processes = 2;\nstatic int need_cleanup = 0;\n\nstatic int _prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,\n\t\t  unsigned long arg5)\n{\n\tint res;\n\n\tres = prctl(option, arg2, arg3, arg4, arg5);\n\tprintf(\"%d = prctl(%d, %ld, %ld, %ld, %lx)\\n\", res, option, (long)arg2, (long)arg3,\n\t       (long)arg4, arg5);\n\treturn res;\n}\n\n#define STACK_SIZE (1024 * 1024)\n\n#define handle_error(msg) __handle_error(__FILE__, __LINE__, msg)\nstatic void __handle_error(char *fn, int ln, char *msg)\n{\n\tint pidx;\n\tprintf(\"(%s:%d) - \", fn, ln);\n\tperror(msg);\n\tif (need_cleanup) {\n\t\tfor (pidx = 0; pidx < num_processes; ++pidx)\n\t\t\tkill(procs[pidx].cpid, 15);\n\t\tneed_cleanup = 0;\n\t}\n\texit(EXIT_FAILURE);\n}\n\nstatic void handle_usage(int rc, char *msg)\n{\n\tputs(USAGE);\n\tputs(msg);\n\tputchar('\\n');\n\texit(rc);\n}\n\nstatic unsigned long get_cs_cookie(int pid)\n{\n\tunsigned long long cookie;\n\tint ret;\n\n\tret = prctl(PR_SCHED_CORE, PR_SCHED_CORE_GET, pid, PIDTYPE_PID,\n\t\t    (unsigned long)&cookie);\n\tif (ret) {\n\t\tprintf(\"Not a core sched system\\n\");\n\t\treturn -1UL;\n\t}\n\n\treturn cookie;\n}\n\nstatic int child_func_thread(void __attribute__((unused))*arg)\n{\n\twhile (1)\n\t\tusleep(20000);\n\treturn 0;\n}\n\nstatic void create_threads(int num_threads, int thr_tids[])\n{\n\tvoid *child_stack;\n\tpid_t tid;\n\tint i;\n\n\tfor (i = 0; i < num_threads; ++i) {\n\t\tchild_stack = malloc(STACK_SIZE);\n\t\tif (!child_stack)\n\t\t\thandle_error(\"child stack allocate\");\n\n\t\ttid = clone(child_func_thread, child_stack + STACK_SIZE, THREAD_CLONE_FLAGS, NULL);\n\t\tif (tid == -1)\n\t\t\thandle_error(\"clone thread\");\n\t\tthr_tids[i] = tid;\n\t}\n}\n\nstatic int child_func_process(void *arg)\n{\n\tstruct child_args *ca = (struct child_args *)arg;\n\tint ret;\n\n\tclose(ca->pfd[0]);\n\n\tcreate_threads(ca->num_threads, ca->thr_tids);\n\n\tret = write(ca->pfd[1], &ca->thr_tids, sizeof(int) * ca->num_threads);\n\tif (ret == -1)\n\t\tprintf(\"write failed on pfd[%d] - error (%s)\\n\",\n\t\t\tca->pfd[1], strerror(errno));\n\n\tclose(ca->pfd[1]);\n\n\twhile (1)\n\t\tusleep(20000);\n\treturn 0;\n}\n\nstatic unsigned char child_func_process_stack[STACK_SIZE];\n\nvoid create_processes(int num_processes, int num_threads, struct child_args proc[])\n{\n\tpid_t cpid;\n\tint i, ret;\n\n\tfor (i = 0; i < num_processes; ++i) {\n\t\tproc[i].num_threads = num_threads;\n\n\t\tif (pipe(proc[i].pfd) == -1)\n\t\t\thandle_error(\"pipe() failed\");\n\n\t\tcpid = clone(child_func_process, child_func_process_stack + STACK_SIZE,\n\t\t\t     SIGCHLD, &proc[i]);\n\t\tproc[i].cpid = cpid;\n\t\tclose(proc[i].pfd[1]);\n\t}\n\n\tfor (i = 0; i < num_processes; ++i) {\n\t\tret = read(proc[i].pfd[0], &proc[i].thr_tids, sizeof(int) * proc[i].num_threads);\n\t\tif (ret == -1)\n\t\t\tprintf(\"read failed on proc[%d].pfd[0] error (%s)\\n\",\n\t\t\t\ti, strerror(errno));\n\t\tclose(proc[i].pfd[0]);\n\t}\n}\n\nvoid disp_processes(int num_processes, struct child_args proc[])\n{\n\tint i, j;\n\n\tprintf(\"tid=%d, / tgid=%d / pgid=%d: %lx\\n\", gettid(), getpid(), getpgid(0),\n\t       get_cs_cookie(getpid()));\n\n\tfor (i = 0; i < num_processes; ++i) {\n\t\tprintf(\"    tid=%d, / tgid=%d / pgid=%d: %lx\\n\", proc[i].cpid, proc[i].cpid,\n\t\t       getpgid(proc[i].cpid), get_cs_cookie(proc[i].cpid));\n\t\tfor (j = 0; j < proc[i].num_threads; ++j) {\n\t\t\tprintf(\"        tid=%d, / tgid=%d / pgid=%d: %lx\\n\", proc[i].thr_tids[j],\n\t\t\t       proc[i].cpid, getpgid(0), get_cs_cookie(proc[i].thr_tids[j]));\n\t\t}\n\t}\n\tputs(\"\\n\");\n}\n\nstatic int errors;\n\n#define validate(v) _validate(__LINE__, v, #v)\nvoid _validate(int line, int val, char *msg)\n{\n\tif (!val) {\n\t\t++errors;\n\t\tprintf(\"(%d) FAILED: %s\\n\", line, msg);\n\t} else {\n\t\tprintf(\"(%d) PASSED: %s\\n\", line, msg);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint keypress = 0;\n\tint num_threads = 3;\n\tint delay = 0;\n\tint res = 0;\n\tint pidx;\n\tint pid;\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \":hkT:P:d:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'P':\n\t\t\tnum_processes = (int)strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tnum_threads = (int)strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdelay = (int)strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkeypress = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprintf(USAGE);\n\t\t\texit(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\thandle_usage(20, \"unknown option\");\n\t\t}\n\t}\n\n\tif (num_processes < 1 || num_processes > MAX_PROCESSES)\n\t\thandle_usage(1, \"Bad processes value\");\n\n\tif (num_threads < 1 || num_threads > MAX_THREADS)\n\t\thandle_usage(2, \"Bad thread value\");\n\n\tif (keypress)\n\t\tdelay = -1;\n\n\tsrand(time(NULL));\n\n\t \n\tif (setpgid(0, 0) != 0)\n\t\thandle_error(\"process group\");\n\n\tprintf(\"\\n## Create a thread/process/process group hiearchy\\n\");\n\tcreate_processes(num_processes, num_threads, procs);\n\tneed_cleanup = 1;\n\tdisp_processes(num_processes, procs);\n\tvalidate(get_cs_cookie(0) == 0);\n\n\tprintf(\"\\n## Set a cookie on entire process group\\n\");\n\tif (_prctl(PR_SCHED_CORE, PR_SCHED_CORE_CREATE, 0, PIDTYPE_PGID, 0) < 0)\n\t\thandle_error(\"core_sched create failed -- PGID\");\n\tdisp_processes(num_processes, procs);\n\n\tvalidate(get_cs_cookie(0) != 0);\n\n\t \n\tpidx = rand() % num_processes;\n\tpid = procs[pidx].cpid;\n\n\tvalidate(get_cs_cookie(0) == get_cs_cookie(pid));\n\tvalidate(get_cs_cookie(0) == get_cs_cookie(procs[pidx].thr_tids[0]));\n\n\tprintf(\"\\n## Set a new cookie on entire process/TGID [%d]\\n\", pid);\n\tif (_prctl(PR_SCHED_CORE, PR_SCHED_CORE_CREATE, pid, PIDTYPE_TGID, 0) < 0)\n\t\thandle_error(\"core_sched create failed -- TGID\");\n\tdisp_processes(num_processes, procs);\n\n\tvalidate(get_cs_cookie(0) != get_cs_cookie(pid));\n\tvalidate(get_cs_cookie(pid) != 0);\n\tvalidate(get_cs_cookie(pid) == get_cs_cookie(procs[pidx].thr_tids[0]));\n\n\tprintf(\"\\n## Copy the cookie of current/PGID[%d], to pid [%d] as PIDTYPE_PID\\n\",\n\t       getpid(), pid);\n\tif (_prctl(PR_SCHED_CORE, PR_SCHED_CORE_SHARE_TO, pid, PIDTYPE_PID, 0) < 0)\n\t\thandle_error(\"core_sched share to itself failed -- PID\");\n\tdisp_processes(num_processes, procs);\n\n\tvalidate(get_cs_cookie(0) == get_cs_cookie(pid));\n\tvalidate(get_cs_cookie(pid) != 0);\n\tvalidate(get_cs_cookie(pid) != get_cs_cookie(procs[pidx].thr_tids[0]));\n\n\tprintf(\"\\n## Copy cookie from a thread [%d] to current/PGID [%d] as PIDTYPE_PID\\n\",\n\t       procs[pidx].thr_tids[0], getpid());\n\tif (_prctl(PR_SCHED_CORE, PR_SCHED_CORE_SHARE_FROM, procs[pidx].thr_tids[0],\n\t\t   PIDTYPE_PID, 0) < 0)\n\t\thandle_error(\"core_sched share from thread failed -- PID\");\n\tdisp_processes(num_processes, procs);\n\n\tvalidate(get_cs_cookie(0) == get_cs_cookie(procs[pidx].thr_tids[0]));\n\tvalidate(get_cs_cookie(pid) != get_cs_cookie(procs[pidx].thr_tids[0]));\n\n\tprintf(\"\\n## Copy cookie from current [%d] to current as pidtype PGID\\n\", getpid());\n\tif (_prctl(PR_SCHED_CORE, PR_SCHED_CORE_SHARE_TO, 0, PIDTYPE_PGID, 0) < 0)\n\t\thandle_error(\"core_sched share to self failed -- PGID\");\n\tdisp_processes(num_processes, procs);\n\n\tvalidate(get_cs_cookie(0) == get_cs_cookie(pid));\n\tvalidate(get_cs_cookie(pid) != 0);\n\tvalidate(get_cs_cookie(pid) == get_cs_cookie(procs[pidx].thr_tids[0]));\n\n\tvalidate(_prctl(PR_SCHED_CORE, PR_SCHED_CORE_MAX, 0, PIDTYPE_PGID, 0) < 0\n\t\t&& errno == EINVAL);\n\n\tvalidate(_prctl(PR_SCHED_CORE, PR_SCHED_CORE_SHARE_TO, 0, PIDTYPE_PGID, 1) < 0\n\t\t&& errno == EINVAL);\n\n\tif (errors) {\n\t\tprintf(\"TESTS FAILED. errors: %d\\n\", errors);\n\t\tres = 10;\n\t} else {\n\t\tprintf(\"SUCCESS !!!\\n\");\n\t}\n\n\tif (keypress)\n\t\tgetchar();\n\telse\n\t\tsleep(delay);\n\n\tfor (pidx = 0; pidx < num_processes; ++pidx)\n\t\tkill(procs[pidx].cpid, 15);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}