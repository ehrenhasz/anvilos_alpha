{
  "module_name": "gpio-mockup-cdev.c",
  "hash_id": "71afa3d7037cee19218951c83b9be29c57d427e9730c8aa8b0327f3208de3f74",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/gpio/gpio-mockup-cdev.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/gpio.h>\n\n#define CONSUMER\t\"gpio-mockup-cdev\"\n\nstatic int request_line_v2(int cfd, unsigned int offset,\n\t\t\t   uint64_t flags, unsigned int val)\n{\n\tstruct gpio_v2_line_request req;\n\tint ret;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.num_lines = 1;\n\treq.offsets[0] = offset;\n\treq.config.flags = flags;\n\tstrcpy(req.consumer, CONSUMER);\n\tif (flags & GPIO_V2_LINE_FLAG_OUTPUT) {\n\t\treq.config.num_attrs = 1;\n\t\treq.config.attrs[0].mask = 1;\n\t\treq.config.attrs[0].attr.id = GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES;\n\t\tif (val)\n\t\t\treq.config.attrs[0].attr.values = 1;\n\t}\n\tret = ioctl(cfd, GPIO_V2_GET_LINE_IOCTL, &req);\n\tif (ret == -1)\n\t\treturn -errno;\n\treturn req.fd;\n}\n\n\nstatic int get_value_v2(int lfd)\n{\n\tstruct gpio_v2_line_values vals;\n\tint ret;\n\n\tmemset(&vals, 0, sizeof(vals));\n\tvals.mask = 1;\n\tret = ioctl(lfd, GPIO_V2_LINE_GET_VALUES_IOCTL, &vals);\n\tif (ret == -1)\n\t\treturn -errno;\n\treturn vals.bits & 0x1;\n}\n\nstatic int request_line_v1(int cfd, unsigned int offset,\n\t\t\t   uint32_t flags, unsigned int val)\n{\n\tstruct gpiohandle_request req;\n\tint ret;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.lines = 1;\n\treq.lineoffsets[0] = offset;\n\treq.flags = flags;\n\tstrcpy(req.consumer_label, CONSUMER);\n\tif (flags & GPIOHANDLE_REQUEST_OUTPUT)\n\t\treq.default_values[0] = val;\n\n\tret = ioctl(cfd, GPIO_GET_LINEHANDLE_IOCTL, &req);\n\tif (ret == -1)\n\t\treturn -errno;\n\treturn req.fd;\n}\n\nstatic int get_value_v1(int lfd)\n{\n\tstruct gpiohandle_data vals;\n\tint ret;\n\n\tmemset(&vals, 0, sizeof(vals));\n\tret = ioctl(lfd, GPIOHANDLE_GET_LINE_VALUES_IOCTL, &vals);\n\tif (ret == -1)\n\t\treturn -errno;\n\treturn vals.values[0];\n}\n\nstatic void usage(char *prog)\n{\n\tprintf(\"Usage: %s [-l] [-b <bias>] [-s <value>] [-u <uAPI>] <gpiochip> <offset>\\n\", prog);\n\tprintf(\"        -b: set line bias to one of pull-down, pull-up, disabled\\n\");\n\tprintf(\"               (default is to leave bias unchanged):\\n\");\n\tprintf(\"        -l: set line active low (default is active high)\\n\");\n\tprintf(\"        -s: set line value (default is to get line value)\\n\");\n\tprintf(\"        -u: uAPI version to use (default is 2)\\n\");\n\texit(-1);\n}\n\nstatic int wait_signal(void)\n{\n\tint sig;\n\tsigset_t wset;\n\n\tsigemptyset(&wset);\n\tsigaddset(&wset, SIGHUP);\n\tsigaddset(&wset, SIGINT);\n\tsigaddset(&wset, SIGTERM);\n\tsigwait(&wset, &sig);\n\n\treturn sig;\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *chip;\n\tint opt, ret, cfd, lfd;\n\tunsigned int offset, val = 0, abiv;\n\tuint32_t flags_v1;\n\tuint64_t flags_v2;\n\n\tabiv = 2;\n\tret = 0;\n\tflags_v1 = GPIOHANDLE_REQUEST_INPUT;\n\tflags_v2 = GPIO_V2_LINE_FLAG_INPUT;\n\n\twhile ((opt = getopt(argc, argv, \"lb:s:u:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'l':\n\t\t\tflags_v1 |= GPIOHANDLE_REQUEST_ACTIVE_LOW;\n\t\t\tflags_v2 |= GPIO_V2_LINE_FLAG_ACTIVE_LOW;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (strcmp(\"pull-up\", optarg) == 0) {\n\t\t\t\tflags_v1 |= GPIOHANDLE_REQUEST_BIAS_PULL_UP;\n\t\t\t\tflags_v2 |= GPIO_V2_LINE_FLAG_BIAS_PULL_UP;\n\t\t\t} else if (strcmp(\"pull-down\", optarg) == 0) {\n\t\t\t\tflags_v1 |= GPIOHANDLE_REQUEST_BIAS_PULL_DOWN;\n\t\t\t\tflags_v2 |= GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN;\n\t\t\t} else if (strcmp(\"disabled\", optarg) == 0) {\n\t\t\t\tflags_v1 |= GPIOHANDLE_REQUEST_BIAS_DISABLE;\n\t\t\t\tflags_v2 |= GPIO_V2_LINE_FLAG_BIAS_DISABLED;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tval = atoi(optarg);\n\t\t\tflags_v1 &= ~GPIOHANDLE_REQUEST_INPUT;\n\t\t\tflags_v1 |= GPIOHANDLE_REQUEST_OUTPUT;\n\t\t\tflags_v2 &= ~GPIO_V2_LINE_FLAG_INPUT;\n\t\t\tflags_v2 |= GPIO_V2_LINE_FLAG_OUTPUT;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tabiv = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (argc < optind + 2)\n\t\tusage(argv[0]);\n\n\tchip = argv[optind];\n\toffset = atoi(argv[optind + 1]);\n\n\tcfd = open(chip, 0);\n\tif (cfd == -1) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", chip, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tif (abiv == 1)\n\t\tlfd = request_line_v1(cfd, offset, flags_v1, val);\n\telse\n\t\tlfd = request_line_v2(cfd, offset, flags_v2, val);\n\n\tclose(cfd);\n\n\tif (lfd < 0) {\n\t\tfprintf(stderr, \"Failed to request %s:%d: %s\\n\", chip, offset, strerror(-lfd));\n\t\treturn lfd;\n\t}\n\n\tif (flags_v2 & GPIO_V2_LINE_FLAG_OUTPUT) {\n\t\twait_signal();\n\t} else {\n\t\tif (abiv == 1)\n\t\t\tret = get_value_v1(lfd);\n\t\telse\n\t\t\tret = get_value_v2(lfd);\n\t}\n\n\tclose(lfd);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}