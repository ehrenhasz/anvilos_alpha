{
  "module_name": "gpio-mockup.sh",
  "hash_id": "6dfefe807d306d2fa4a977d5ea054a482c3a5fa8249435ae10e51d850d40300c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/gpio/gpio-mockup.sh",
  "human_readable_source": "#!/bin/bash -efu\n# SPDX-License-Identifier: GPL-2.0\n\n#exit status\n#0: success\n#1: fail\n#4: skip test - including run as non-root user\n\nBASE=${0%/*}\nDEBUGFS=\nGPIO_DEBUGFS=\ndev_type=\"cdev\"\nmodule=\"gpio-mockup\"\nverbose=\nfull_test=\nrandom=\nuapi_opt=\nactive_opt=\nbias_opt=\nline_set_pid=\n\n# Kselftest return codes\nksft_fail=1\nksft_skip=4\n\nusage()\n{\n\techo \"Usage:\"\n\techo \"$0 [-frv] [-t type]\"\n\techo \"-f:  full test (minimal set run by default)\"\n\techo \"-r:  test random lines as well as fence posts\"\n\techo \"-t:  interface type:\"\n\techo \"      cdev (character device ABI) - default\"\n\techo \"      cdev_v1 (deprecated character device ABI)\"\n\techo \"      sysfs (deprecated SYSFS ABI)\"\n\techo \"-v:  verbose progress reporting\"\n\texit $ksft_fail\n}\n\nskip()\n{\n\techo \"$*\" >&2\n\techo \"GPIO $module test SKIP\"\n\texit $ksft_skip\n}\n\nprerequisite()\n{\n\t[ $(id -u) -eq 0 ] || skip \"must be run as root\"\n\n\tDEBUGFS=$(grep -w debugfs /proc/mounts | cut -f2 -d' ')\n\t[ -d \"$DEBUGFS\" ] || skip \"debugfs is not mounted\"\n\n\tGPIO_DEBUGFS=$DEBUGFS/$module\n}\n\nremove_module()\n{\n\tmodprobe -r -q $module\n}\n\ncleanup()\n{\n\tset +e\n\trelease_line\n\tremove_module\n\tjobs -p | xargs -r kill > /dev/null 2>&1\n}\n\nfail()\n{\n\techo \"test failed: $*\" >&2\n\techo \"GPIO $module test FAIL\"\n\texit $ksft_fail\n}\n\ntry_insert_module()\n{\n\tmodprobe -q $module \"$1\" || fail \"insert $module failed with error $?\"\n}\n\nlog()\n{\n\t[ -z \"$verbose\" ] || echo \"$*\"\n}\n\n# The following line helpers, release_Line, get_line and set_line, all\n# make use of the global $chip and $offset variables.\n#\n# This implementation drives the GPIO character device (cdev) uAPI.\n# Other implementations may override these to test different uAPIs.\n\n# Release any resources related to the line\nrelease_line()\n{\n\t[ \"$line_set_pid\" ] && kill $line_set_pid && wait $line_set_pid || true\n\tline_set_pid=\n}\n\n# Read the current value of the line\nget_line()\n{\n\trelease_line\n\n\tlocal cdev_opts=${uapi_opt}${active_opt}\n\t$BASE/gpio-mockup-cdev $cdev_opts /dev/$chip $offset\n\techo $?\n}\n\n# Set the state of the line\n#\n# Changes to line configuration are provided as parameters.\n# The line is assumed to be an output if the line value 0 or 1 is\n# specified, else an input.\nset_line()\n{\n\tlocal val=\n\n\trelease_line\n\n\t# parse config options...\n\tfor option in $*; do\n\t\tcase $option in\n\t\tactive-low)\n\t\t\tactive_opt=\"-l \"\n\t\t\t;;\n\t\tactive-high)\n\t\t\tactive_opt=\n\t\t\t;;\n\t\tbias-none)\n\t\t\tbias_opt=\n\t\t\t;;\n\t\tpull-down)\n\t\t\tbias_opt=\"-bpull-down \"\n\t\t\t;;\n\t\tpull-up)\n\t\t\tbias_opt=\"-bpull-up \"\n\t\t\t;;\n\t\t0)\n\t\t\tval=0\n\t\t\t;;\n\t\t1)\n\t\t\tval=1\n\t\t\t;;\n\t\tesac\n\tdone\n\n\tlocal cdev_opts=${uapi_opt}${active_opt}\n\tif [ \"$val\" ]; then\n\t\t$BASE/gpio-mockup-cdev $cdev_opts -s$val /dev/$chip $offset &\n\t\t# failure to set is detected by reading mockup and toggling values\n\t\tline_set_pid=$!\n\t\t# allow for gpio-mockup-cdev to launch and request line\n\t\t# (there is limited value in checking if line has been requested)\n\t\tsleep 0.01\n\telif [ \"$bias_opt\" ]; then\n\t\tcdev_opts=${cdev_opts}${bias_opt}\n\t\t$BASE/gpio-mockup-cdev $cdev_opts /dev/$chip $offset || true\n\tfi\n}\n\nassert_line()\n{\n\tlocal val\n\t# don't need any retry here as set_mock allows for propagation\n\tval=$(get_line)\n\t[ \"$val\" = \"$1\" ] || fail \"line value is ${val:-empty} when $1 was expected\"\n}\n\n# The following mockup helpers all make use of the $mock_line\nassert_mock()\n{\n\tlocal backoff_wait=10\n\tlocal retry=0\n\tlocal val\n\t# retry allows for set propagation from uAPI to mockup\n\twhile true; do\n\t\tval=$(< $mock_line)\n\t\t[ \"$val\" = \"$1\" ] && break\n\t\tretry=$((retry + 1))\n\t\t[ $retry -lt 5 ] || fail \"mockup $mock_line value ${val:-empty} when $1 expected\"\n\t\tsleep $(printf \"%0.2f\" $((backoff_wait))e-3)\n\t\tbackoff_wait=$((backoff_wait * 2))\n\tdone\n}\n\nset_mock()\n{\n\techo \"$1\" > $mock_line\n\t# allow for set propagation - so we won't be in a race with set_line\n\tassert_mock \"$1\"\n}\n\n# test the functionality of a line\n#\n# The line is set from the mockup side and is read from the userspace side\n# (input), and is set from the userspace side and is read from the mockup side\n# (output).\n#\n# Setting the mockup pull using the userspace interface bias settings is\n# tested where supported by the userspace interface (cdev).\ntest_line()\n{\n\tchip=$1\n\toffset=$2\n\tlog \"test_line $chip $offset\"\n\tmock_line=$GPIO_DEBUGFS/$chip/$offset\n\t[ -e \"$mock_line\" ] || fail \"missing line $chip:$offset\"\n\n\t# test input active-high\n\tset_mock 1\n\tset_line input active-high\n\tassert_line 1\n\tset_mock 0\n\tassert_line 0\n\tset_mock 1\n\tassert_line 1\n\n\tif [ \"$full_test\" ]; then\n\t\tif [ \"$dev_type\" != \"sysfs\" ]; then\n\t\t\t# test pulls\n\t\t\tset_mock 0\n\t\t\tset_line input pull-up\n\t\t\tassert_line 1\n\t\t\tset_mock 0\n\t\t\tassert_line 0\n\n\t\t\tset_mock 1\n\t\t\tset_line input pull-down\n\t\t\tassert_line 0\n\t\t\tset_mock 1\n\t\t\tassert_line 1\n\n\t\t\tset_line bias-none\n\t\tfi\n\n\t\t# test input active-low\n\t\tset_mock 0\n\t\tset_line active-low\n\t\tassert_line 1\n\t\tset_mock 1\n\t\tassert_line 0\n\t\tset_mock 0\n\t\tassert_line 1\n\n\t\t# test output active-high\n\t\tset_mock 1\n\t\tset_line active-high 0\n\t\tassert_mock 0\n\t\tset_line 1\n\t\tassert_mock 1\n\t\tset_line 0\n\t\tassert_mock 0\n\tfi\n\n\t# test output active-low\n\tset_mock 0\n\tset_line active-low 0\n\tassert_mock 1\n\tset_line 1\n\tassert_mock 0\n\tset_line 0\n\tassert_mock 1\n\n\trelease_line\n}\n\ntest_no_line()\n{\n\tlog test_no_line \"$*\"\n\t[ ! -e \"$GPIO_DEBUGFS/$1/$2\" ] || fail \"unexpected line $1:$2\"\n}\n\n# Load the module and check that the expected number of gpiochips, with the\n# expected number of lines, are created and are functional.\n#\n# $1 is the gpio_mockup_ranges parameter for the module\n# The remaining parameters are the number of lines, n, expected for each of\n# the gpiochips expected to be created.\n#\n# For each gpiochip the fence post lines, 0 and n-1, are tested, and the\n# line on the far side of the fence post, n, is tested to not exist.\n#\n# If the $random flag is set then a random line in the middle of the\n# gpiochip is tested as well.\ninsmod_test()\n{\n\tlocal ranges=\n\tlocal gc=\n\tlocal width=\n\n\t[ \"${1:-}\" ] || fail \"missing ranges\"\n\tranges=$1 ; shift\n\ttry_insert_module \"gpio_mockup_ranges=$ranges\"\n\tlog \"GPIO $module test with ranges: <$ranges>:\"\n\t# e.g. /sys/kernel/debug/gpio-mockup/gpiochip1\n\tgpiochip=$(find \"$DEBUGFS/$module/\" -name gpiochip* -type d | sort)\n\tfor chip in $gpiochip; do\n\t\tgc=${chip##*/}\n\t\t[ \"${1:-}\" ] || fail \"unexpected chip - $gc\"\n\t\twidth=$1 ; shift\n\t\ttest_line $gc 0\n\t\tif [ \"$random\" -a $width -gt 2 ]; then\n\t\t\ttest_line $gc $((RANDOM % ($width - 2) + 1))\n\t\tfi\n\t\ttest_line $gc $(($width - 1))\n\t\ttest_no_line $gc $width\n\tdone\n\t[ \"${1:-}\" ] && fail \"missing expected chip of width $1\"\n\tremove_module || fail \"failed to remove module with error $?\"\n}\n\nwhile getopts \":frvt:\" opt; do\n\tcase $opt in\n\tf)\n\t\tfull_test=true\n\t\t;;\n\tr)\n\t\trandom=true\n\t\t;;\n\tt)\n\t\tdev_type=$OPTARG\n\t\t;;\n\tv)\n\t\tverbose=true\n\t\t;;\n\t*)\n\t\tusage\n\t\t;;\n\tesac\ndone\nshift $((OPTIND - 1))\n\n[ \"${1:-}\" ] && fail \"unknown argument '$1'\"\n\nprerequisite\n\ntrap 'exit $ksft_fail' SIGTERM SIGINT\ntrap cleanup EXIT\n\ncase \"$dev_type\" in\nsysfs)\n\tsource $BASE/gpio-mockup-sysfs.sh\n\techo \"WARNING: gpio sysfs ABI is deprecated.\"\n\t;;\ncdev_v1)\n\techo \"WARNING: gpio cdev ABI v1 is deprecated.\"\n\tuapi_opt=\"-u1 \"\n\t;;\ncdev)\n\t;;\n*)\n\tfail \"unknown interface type: $dev_type\"\n\t;;\nesac\n\nremove_module || fail \"can't remove existing $module module\"\n\n# manual gpio allocation tests fail if a physical chip already exists\n[ \"$full_test\" -a -e \"/dev/gpiochip0\" ] && skip \"full tests conflict with gpiochip0\"\n\necho \"1.  Module load tests\"\necho \"1.1.  dynamic allocation of gpio\"\ninsmod_test \"-1,32\" 32\ninsmod_test \"-1,23,-1,32\" 23 32\ninsmod_test \"-1,23,-1,26,-1,32\" 23 26 32\nif [ \"$full_test\" ]; then\n\techo \"1.2.  manual allocation of gpio\"\n\tinsmod_test \"0,32\" 32\n\tinsmod_test \"0,32,32,60\" 32 28\n\tinsmod_test \"0,32,40,64,64,96\" 32 24 32\n\techo \"1.3.  dynamic and manual allocation of gpio\"\n\tinsmod_test \"-1,32,32,62\" 32 30\n\tinsmod_test \"-1,22,-1,23,0,24,32,64\" 22 23 24 32\n\tinsmod_test \"-1,32,32,60,-1,29\" 32 28 29\n\tinsmod_test \"-1,32,40,64,-1,5\" 32 24 5\n\tinsmod_test \"0,32,32,44,-1,22,-1,31\" 32 12 22 31\nfi\necho \"2.  Module load error tests\"\necho \"2.1 gpio overflow\"\n# Currently: The max number of gpio(1024) is defined in arm architecture.\ninsmod_test \"-1,1024\"\nif [ \"$full_test\" ]; then\n\techo \"2.2 no lines defined\"\n\tinsmod_test \"0,0\"\n\techo \"2.3 ignore range overlap\"\n\tinsmod_test \"0,32,0,1\" 32\n\tinsmod_test \"0,32,1,5\" 32\n\tinsmod_test \"0,32,30,35\" 32\n\tinsmod_test \"0,32,31,32\" 32\n\tinsmod_test \"10,32,30,35\" 22\n\tinsmod_test \"10,32,9,14\" 22\n\tinsmod_test \"0,32,20,21,40,56\" 32 16\n\tinsmod_test \"0,32,32,64,32,40\" 32 32\n\tinsmod_test \"0,32,32,64,36,37\" 32 32\n\tinsmod_test \"0,32,35,64,34,36\" 32 29\n\tinsmod_test \"0,30,35,64,35,45\" 30 29\n\tinsmod_test \"0,32,40,56,30,33\" 32 16\n\tinsmod_test \"0,32,40,56,30,41\" 32 16\n\tinsmod_test \"0,32,40,56,39,45\" 32 16\nfi\n\necho \"GPIO $module test PASS\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}