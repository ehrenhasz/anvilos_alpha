{
  "module_name": "run.sh",
  "hash_id": "b707ea3dd89d6a187cc3e78959cc407802ca749ba92c76ef6bf965ea85fe68d6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/intel_pstate/run.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# This test runs on Intel x86 based hardware which support the intel_pstate\n# driver.  The test checks the frequency settings from the maximum turbo\n# state to the minimum supported frequency, in decrements of 100MHz.  The\n# test runs the aperf.c program to put load on each processor.\n#\n# The results are displayed in a table which indicate the \"Target\" state,\n# or the requested frequency in MHz, the Actual frequency, as read from\n# /proc/cpuinfo, the difference between the Target and Actual frequencies,\n# and the value of MSR 0x199 (MSR_IA32_PERF_CTL) which indicates what\n# pstate the cpu is in, and the value of\n# /sys/devices/system/cpu/intel_pstate/max_perf_pct X maximum turbo state\n#\n# Notes: In some cases several frequency values may be placed in the\n# /tmp/result.X files.  This is done on purpose in order to catch cases\n# where the pstate driver may not be working at all.  There is the case\n# where, for example, several \"similar\" frequencies are in the file:\n#\n#\n#/tmp/result.3100:1:cpu MHz              : 2899.980\n#/tmp/result.3100:2:cpu MHz              : 2900.000\n#/tmp/result.3100:3:msr 0x199: 0x1e00\n#/tmp/result.3100:4:max_perf_pct 94\n#\n# and the test will error out in those cases.  The result.X file can be checked\n# for consistency and modified to remove the extra MHz values.  The result.X\n# files can be re-evaluated by setting EVALUATE_ONLY to 1 below.\n\nEVALUATE_ONLY=0\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nif ! uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ | grep -q x86; then\n\techo \"$0 # Skipped: Test can only run on x86 architectures.\"\n\texit $ksft_skip\nfi\n\nmsg=\"skip all tests:\"\nif [ $UID != 0 ] && [ $EVALUATE_ONLY == 0 ]; then\n    echo $msg please run this as root >&2\n    exit $ksft_skip\nfi\n\nmax_cpus=$(($(nproc)-1))\n\nfunction run_test () {\n\n\tfile_ext=$1\n\tfor cpu in `seq 0 $max_cpus`\n\tdo\n\t\techo \"launching aperf load on $cpu\"\n\t\t./aperf $cpu &\n\tdone\n\n\techo \"sleeping for 5 seconds\"\n\tsleep 5\n\tgrep MHz /proc/cpuinfo | sort -u > /tmp/result.freqs\n\tnum_freqs=$(wc -l /tmp/result.freqs | awk ' { print $1 } ')\n\tif [ $num_freqs -ge 2 ]; then\n\t\ttail -n 1 /tmp/result.freqs > /tmp/result.$1\n\telse\n\t\tcp /tmp/result.freqs /tmp/result.$1\n\tfi\n\t./msr 0 >> /tmp/result.$1\n\n\tmax_perf_pct=$(cat /sys/devices/system/cpu/intel_pstate/max_perf_pct)\n\techo \"max_perf_pct $max_perf_pct\" >> /tmp/result.$1\n\n\tfor job in `jobs -p`\n\tdo\n\t\techo \"waiting for job id $job\"\n\t\twait $job\n\tdone\n}\n\n#\n# MAIN (ALL UNITS IN MHZ)\n#\n\n# Get the marketing frequency\n_mkt_freq=$(cat /proc/cpuinfo | grep -m 1 \"model name\" | awk '{print $NF}')\n_mkt_freq=$(echo $_mkt_freq | tr -d [:alpha:][:punct:])\nmkt_freq=${_mkt_freq}0\n\n# Get the ranges from cpupower\n_min_freq=$(cpupower frequency-info -l | tail -1 | awk ' { print $1 } ')\nmin_freq=$(($_min_freq / 1000))\n_max_freq=$(cpupower frequency-info -l | tail -1 | awk ' { print $2 } ')\nmax_freq=$(($_max_freq / 1000))\n\n\n[ $EVALUATE_ONLY -eq 0 ] && for freq in `seq $max_freq -100 $min_freq`\ndo\n\techo \"Setting maximum frequency to $freq\"\n\tcpupower frequency-set -g powersave --max=${freq}MHz >& /dev/null\n\trun_test $freq\ndone\n\n[ $EVALUATE_ONLY -eq 0 ] && cpupower frequency-set -g powersave --max=${max_freq}MHz >& /dev/null\n\necho \"========================================================================\"\necho \"The marketing frequency of the cpu is $mkt_freq MHz\"\necho \"The maximum frequency of the cpu is $max_freq MHz\"\necho \"The minimum frequency of the cpu is $min_freq MHz\"\n\n# make a pretty table\necho \"Target Actual Difference MSR(0x199) max_perf_pct\" | tr \" \" \"\\n\" > /tmp/result.tab\nfor freq in `seq $max_freq -100 $min_freq`\ndo\n\tresult_freq=$(cat /tmp/result.${freq} | grep \"cpu MHz\" | awk ' { print $4 } ' | awk -F \".\" ' { print $1 } ')\n\tmsr=$(cat /tmp/result.${freq} | grep \"msr\" | awk ' { print $3 } ')\n\tmax_perf_pct=$(cat /tmp/result.${freq} | grep \"max_perf_pct\" | awk ' { print $2 } ' )\n\tcat >> /tmp/result.tab << EOF\n$freq\n$result_freq\n$((result_freq - freq))\n$msr\n$((max_perf_pct * max_freq))\nEOF\ndone\n\n# print the table\npr -aTt -5 < /tmp/result.tab\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}