{
  "module_name": "runner.sh",
  "hash_id": "6b6b9b0efc6b881af7a0aa00bb8ef545f7b714c02b8b3beb7bc8c02921ef1dbe",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kselftest/runner.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# Runs a set of tests in a given subdirectory.\nexport skip_rc=4\nexport timeout_rc=124\nexport logfile=/dev/stdout\nexport per_test_logging=\n\n# Defaults for \"settings\" file fields:\n# \"timeout\" how many seconds to let each test run before running\n# over our soft timeout limit.\nexport kselftest_default_timeout=45\n\n# There isn't a shell-agnostic way to find the path of a sourced file,\n# so we must rely on BASE_DIR being set to find other tools.\nif [ -z \"$BASE_DIR\" ]; then\n\techo \"Error: BASE_DIR must be set before sourcing.\" >&2\n\texit 1\nfi\n\nTR_CMD=$(command -v tr)\n\n# If Perl is unavailable, we must fall back to line-at-a-time prefixing\n# with sed instead of unbuffered output.\ntap_prefix()\n{\n\tif [ ! -x /usr/bin/perl ]; then\n\t\tsed -e 's/^/# /'\n\telse\n\t\t\"$BASE_DIR\"/kselftest/prefix.pl\n\tfi\n}\n\ntap_timeout()\n{\n\t# Make sure tests will time out if utility is available.\n\tif [ -x /usr/bin/timeout ] ; then\n\t\t/usr/bin/timeout --foreground \"$kselftest_timeout\" \\\n\t\t\t/usr/bin/timeout \"$kselftest_timeout\" $1\n\telse\n\t\t$1\n\tfi\n}\n\nrun_one()\n{\n\tDIR=\"$1\"\n\tTEST=\"$2\"\n\tNUM=\"$3\"\n\n\tBASENAME_TEST=$(basename $TEST)\n\n\t# Reset any \"settings\"-file variables.\n\texport kselftest_timeout=\"$kselftest_default_timeout\"\n\n\t# Safe default if tr not available\n\tkselftest_cmd_args_ref=\"KSELFTEST_ARGS\"\n\n\t# Optional arguments for this command, possibly defined as an\n\t# environment variable built using the test executable in all\n\t# uppercase and sanitized substituting non acceptable shell\n\t# variable name characters with \"_\" as in:\n\t#\n\t# \tKSELFTEST_<UPPERCASE_SANITIZED_TESTNAME>_ARGS=\"<options>\"\n\t#\n\t# e.g.\n\t#\n\t# \trtctest --> KSELFTEST_RTCTEST_ARGS=\"/dev/rtc1\"\n\t#\n\t# \tcpu-on-off-test.sh --> KSELFTEST_CPU_ON_OFF_TEST_SH_ARGS=\"-a -p 10\"\n\t#\n\tif [ -n \"$TR_CMD\" ]; then\n\t\tBASENAME_SANITIZED=$(echo \"$BASENAME_TEST\" | \\\n\t\t\t\t\t$TR_CMD -d \"[:blank:][:cntrl:]\" | \\\n\t\t\t\t\t$TR_CMD -c \"[:alnum:]_\" \"_\" | \\\n\t\t\t\t\t$TR_CMD [:lower:] [:upper:])\n\t\tkselftest_cmd_args_ref=\"KSELFTEST_${BASENAME_SANITIZED}_ARGS\"\n\tfi\n\n\t# Load per-test-directory kselftest \"settings\" file.\n\tsettings=\"$BASE_DIR/$DIR/settings\"\n\tif [ -r \"$settings\" ] ; then\n\t\twhile read line ; do\n\t\t\t# Skip comments.\n\t\t\tif echo \"$line\" | grep -q '^#'; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\tfield=$(echo \"$line\" | cut -d= -f1)\n\t\t\tvalue=$(echo \"$line\" | cut -d= -f2-)\n\t\t\teval \"kselftest_$field\"=\"$value\"\n\t\tdone < \"$settings\"\n\tfi\n\n\t# Command line timeout overrides the settings file\n\tif [ -n \"$kselftest_override_timeout\" ]; then\n\t\tkselftest_timeout=\"$kselftest_override_timeout\"\n\t\techo \"# overriding timeout to $kselftest_timeout\" >> \"$logfile\"\n\telse\n\t\techo \"# timeout set to $kselftest_timeout\" >> \"$logfile\"\n\tfi\n\n\tTEST_HDR_MSG=\"selftests: $DIR: $BASENAME_TEST\"\n\techo \"# $TEST_HDR_MSG\"\n\tif [ ! -e \"$TEST\" ]; then\n\t\techo \"# Warning: file $TEST is missing!\"\n\t\techo \"not ok $test_num $TEST_HDR_MSG\"\n\telse\n\t\tif [ -x /usr/bin/stdbuf ]; then\n\t\t\tstdbuf=\"/usr/bin/stdbuf --output=L \"\n\t\tfi\n\t\teval kselftest_cmd_args=\"\\$${kselftest_cmd_args_ref:-}\"\n\t\tcmd=\"$stdbuf ./$BASENAME_TEST $kselftest_cmd_args\"\n\t\tif [ ! -x \"$TEST\" ]; then\n\t\t\techo \"# Warning: file $TEST is not executable\"\n\n\t\t\tif [ $(head -n 1 \"$TEST\" | cut -c -2) = \"#!\" ]\n\t\t\tthen\n\t\t\t\tinterpreter=$(head -n 1 \"$TEST\" | cut -c 3-)\n\t\t\t\tcmd=\"$stdbuf $interpreter ./$BASENAME_TEST\"\n\t\t\telse\n\t\t\t\techo \"not ok $test_num $TEST_HDR_MSG\"\n\t\t\t\treturn\n\t\t\tfi\n\t\tfi\n\t\tcd `dirname $TEST` > /dev/null\n\t\t((((( tap_timeout \"$cmd\" 2>&1; echo $? >&3) |\n\t\t\ttap_prefix >&4) 3>&1) |\n\t\t\t(read xs; exit $xs)) 4>>\"$logfile\" &&\n\t\techo \"ok $test_num $TEST_HDR_MSG\") ||\n\t\t(rc=$?;\t\\\n\t\tif [ $rc -eq $skip_rc ]; then\t\\\n\t\t\techo \"ok $test_num $TEST_HDR_MSG # SKIP\"\n\t\telif [ $rc -eq $timeout_rc ]; then \\\n\t\t\techo \"#\"\n\t\t\techo \"not ok $test_num $TEST_HDR_MSG # TIMEOUT $kselftest_timeout seconds\"\n\t\telse\n\t\t\techo \"not ok $test_num $TEST_HDR_MSG # exit=$rc\"\n\t\tfi)\n\t\tcd - >/dev/null\n\tfi\n}\n\nrun_many()\n{\n\techo \"TAP version 13\"\n\tDIR=\"${PWD#${BASE_DIR}/}\"\n\ttest_num=0\n\ttotal=$(echo \"$@\" | wc -w)\n\techo \"1..$total\"\n\tfor TEST in \"$@\"; do\n\t\tBASENAME_TEST=$(basename $TEST)\n\t\ttest_num=$(( test_num + 1 ))\n\t\tif [ -n \"$per_test_logging\" ]; then\n\t\t\tlogfile=\"/tmp/$BASENAME_TEST\"\n\t\t\tcat /dev/null > \"$logfile\"\n\t\tfi\n\t\trun_one \"$DIR\" \"$TEST\" \"$test_num\"\n\tdone\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}