{
  "module_name": "sud_benchmark.c",
  "hash_id": "c9527588b65a81fbae8bc41e15f606fbc08a790864726467b2f2efb17ee05894",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/syscall_user_dispatch/sud_benchmark.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <time.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <sys/sysinfo.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n\n#ifndef PR_SET_SYSCALL_USER_DISPATCH\n# define PR_SET_SYSCALL_USER_DISPATCH\t59\n# define PR_SYS_DISPATCH_OFF\t0\n# define PR_SYS_DISPATCH_ON\t1\n# define SYSCALL_DISPATCH_FILTER_ALLOW\t0\n# define SYSCALL_DISPATCH_FILTER_BLOCK\t1\n#endif\n\n#ifdef __NR_syscalls\n# define MAGIC_SYSCALL_1 (__NR_syscalls + 1)  \n#else\n# define MAGIC_SYSCALL_1 (0xff00)   \n#endif\n\n \n#if defined(__x86_64__) || defined(__i386__)\n#define TEST_BLOCKED_RETURN\n#endif\n\n#ifdef __x86_64__\nvoid* (syscall_dispatcher_start)(void);\nvoid* (syscall_dispatcher_end)(void);\n#else\nunsigned long syscall_dispatcher_start = 0;\nunsigned long syscall_dispatcher_end = 0;\n#endif\n\nunsigned long trapped_call_count = 0;\nunsigned long native_call_count = 0;\n\nchar selector;\n#define SYSCALL_BLOCK   (selector = SYSCALL_DISPATCH_FILTER_BLOCK)\n#define SYSCALL_UNBLOCK (selector = SYSCALL_DISPATCH_FILTER_ALLOW)\n\n#define CALIBRATION_STEP 100000\n#define CALIBRATE_TO_SECS 5\nint factor;\n\nstatic double one_sysinfo_step(void)\n{\n\tstruct timespec t1, t2;\n\tint i;\n\tstruct sysinfo info;\n\n\tclock_gettime(CLOCK_MONOTONIC, &t1);\n\tfor (i = 0; i < CALIBRATION_STEP; i++)\n\t\tsysinfo(&info);\n\tclock_gettime(CLOCK_MONOTONIC, &t2);\n\treturn (t2.tv_sec - t1.tv_sec) + 1.0e-9 * (t2.tv_nsec - t1.tv_nsec);\n}\n\nstatic void calibrate_set(void)\n{\n\tdouble elapsed = 0;\n\n\tprintf(\"Calibrating test set to last ~%d seconds...\\n\", CALIBRATE_TO_SECS);\n\n\twhile (elapsed < 1) {\n\t\telapsed += one_sysinfo_step();\n\t\tfactor += CALIBRATE_TO_SECS;\n\t}\n\n\tprintf(\"test iterations = %d\\n\", CALIBRATION_STEP * factor);\n}\n\nstatic double perf_syscall(void)\n{\n\tunsigned int i;\n\tdouble partial = 0;\n\n\tfor (i = 0; i < factor; ++i)\n\t\tpartial += one_sysinfo_step()/(CALIBRATION_STEP*factor);\n\treturn partial;\n}\n\nstatic void handle_sigsys(int sig, siginfo_t *info, void *ucontext)\n{\n\tchar buf[1024];\n\tint len;\n\n\tSYSCALL_UNBLOCK;\n\n\t \n\tlen = snprintf(buf, 1024, \"Caught sys_%x\\n\", info->si_syscall);\n\twrite(1, buf, len);\n\n\tif (info->si_syscall == MAGIC_SYSCALL_1)\n\t\ttrapped_call_count++;\n\telse\n\t\tnative_call_count++;\n\n#ifdef TEST_BLOCKED_RETURN\n\tSYSCALL_BLOCK;\n#endif\n\n#ifdef __x86_64__\n\t__asm__ volatile(\"movq $0xf, %rax\");\n\t__asm__ volatile(\"leaveq\");\n\t__asm__ volatile(\"add $0x8, %rsp\");\n\t__asm__ volatile(\"syscall_dispatcher_start:\");\n\t__asm__ volatile(\"syscall\");\n\t__asm__ volatile(\"nop\");  \n\t__asm__ volatile(\"syscall_dispatcher_end:\");\n#endif\n\n}\n\nint main(void)\n{\n\tstruct sigaction act;\n\tdouble time1, time2;\n\tint ret;\n\tsigset_t mask;\n\n\tmemset(&act, 0, sizeof(act));\n\tsigemptyset(&mask);\n\n\tact.sa_sigaction = handle_sigsys;\n\tact.sa_flags = SA_SIGINFO;\n\tact.sa_mask = mask;\n\n\tcalibrate_set();\n\n\ttime1 = perf_syscall();\n\tprintf(\"Avg syscall time %.0lfns.\\n\", time1 * 1.0e9);\n\n\tret = sigaction(SIGSYS, &act, NULL);\n\tif (ret) {\n\t\tperror(\"Error sigaction:\");\n\t\texit(-1);\n\t}\n\n\tfprintf(stderr, \"Enabling syscall trapping.\\n\");\n\n\tif (prctl(PR_SET_SYSCALL_USER_DISPATCH, PR_SYS_DISPATCH_ON,\n\t\t  syscall_dispatcher_start,\n\t\t  (syscall_dispatcher_end - syscall_dispatcher_start + 1),\n\t\t  &selector)) {\n\t\tperror(\"prctl failed\\n\");\n\t\texit(-1);\n\t}\n\n\tSYSCALL_BLOCK;\n\tsyscall(MAGIC_SYSCALL_1);\n\n#ifdef TEST_BLOCKED_RETURN\n\tif (selector == SYSCALL_DISPATCH_FILTER_ALLOW) {\n\t\tfprintf(stderr, \"Failed to return with selector blocked.\\n\");\n\t\texit(-1);\n\t}\n#endif\n\n\tSYSCALL_UNBLOCK;\n\n\tif (!trapped_call_count) {\n\t\tfprintf(stderr, \"syscall trapping does not work.\\n\");\n\t\texit(-1);\n\t}\n\n\ttime2 = perf_syscall();\n\n\tif (native_call_count) {\n\t\tperror(\"syscall trapping intercepted more syscalls than expected\\n\");\n\t\texit(-1);\n\t}\n\n\tprintf(\"trapped_call_count %lu, native_call_count %lu.\\n\",\n\t       trapped_call_count, native_call_count);\n\tprintf(\"Avg syscall time %.0lfns.\\n\", time2 * 1.0e9);\n\tprintf(\"Interception overhead: %.1lf%% (+%.0lfns).\\n\",\n\t       100.0 * (time2 / time1 - 1.0), 1.0e9 * (time2 - time1));\n\treturn 0;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}