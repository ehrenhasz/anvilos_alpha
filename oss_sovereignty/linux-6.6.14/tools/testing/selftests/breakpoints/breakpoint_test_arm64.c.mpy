{
  "module_name": "breakpoint_test_arm64.c",
  "hash_id": "05f1d3f712caa44659acdc6a1cb77013206161091b55b9c7aa18b7ca12500c08",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <asm/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/param.h>\n#include <sys/uio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <elf.h>\n#include <errno.h>\n#include <signal.h>\n\n#include \"../kselftest.h\"\n\nstatic volatile uint8_t var[96] __attribute__((__aligned__(32)));\n\nstatic void child(int size, int wr)\n{\n\tvolatile uint8_t *addr = &var[32 + wr];\n\n\tif (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {\n\t\tksft_print_msg(\n\t\t\t\"ptrace(PTRACE_TRACEME) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t\t_exit(1);\n\t}\n\n\tif (raise(SIGSTOP) != 0) {\n\t\tksft_print_msg(\n\t\t\t\"raise(SIGSTOP) failed: %s\\n\", strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tif ((uintptr_t) addr % size) {\n\t\tksft_print_msg(\n\t\t\t \"Wrong address write for the given size: %s\\n\",\n\t\t\t strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\t*addr = 47;\n\t\tbreak;\n\tcase 2:\n\t\t*(uint16_t *)addr = 47;\n\t\tbreak;\n\tcase 4:\n\t\t*(uint32_t *)addr = 47;\n\t\tbreak;\n\tcase 8:\n\t\t*(uint64_t *)addr = 47;\n\t\tbreak;\n\tcase 16:\n\t\t__asm__ volatile (\"stp x29, x30, %0\" : \"=m\" (addr[0]));\n\t\tbreak;\n\tcase 32:\n\t\t__asm__ volatile (\"stp q29, q30, %0\" : \"=m\" (addr[0]));\n\t\tbreak;\n\t}\n\n\t_exit(0);\n}\n\nstatic bool set_watchpoint(pid_t pid, int size, int wp)\n{\n\tconst volatile uint8_t *addr = &var[32 + wp];\n\tconst int offset = (uintptr_t)addr % 8;\n\tconst unsigned int byte_mask = ((1 << size) - 1) << offset;\n\tconst unsigned int type = 2;  \n\tconst unsigned int enable = 1;\n\tconst unsigned int control = byte_mask << 5 | type << 3 | enable;\n\tstruct user_hwdebug_state dreg_state;\n\tstruct iovec iov;\n\n\tmemset(&dreg_state, 0, sizeof(dreg_state));\n\tdreg_state.dbg_regs[0].addr = (uintptr_t)(addr - offset);\n\tdreg_state.dbg_regs[0].ctrl = control;\n\tiov.iov_base = &dreg_state;\n\tiov.iov_len = offsetof(struct user_hwdebug_state, dbg_regs) +\n\t\t\t\tsizeof(dreg_state.dbg_regs[0]);\n\tif (ptrace(PTRACE_SETREGSET, pid, NT_ARM_HW_WATCH, &iov) == 0)\n\t\treturn true;\n\n\tif (errno == EIO)\n\t\tksft_print_msg(\n\t\t\t\"ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) not supported on this hardware: %s\\n\",\n\t\t\tstrerror(errno));\n\n\tksft_print_msg(\n\t\t\"ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) failed: %s\\n\",\n\t\tstrerror(errno));\n\treturn false;\n}\n\nstatic bool run_test(int wr_size, int wp_size, int wr, int wp)\n{\n\tint status;\n\tsiginfo_t siginfo;\n\tpid_t pid = fork();\n\tpid_t wpid;\n\n\tif (pid < 0) {\n\t\tksft_test_result_fail(\n\t\t\t\"fork() failed: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tif (pid == 0)\n\t\tchild(wr_size, wr);\n\n\twpid = waitpid(pid, &status, __WALL);\n\tif (wpid != pid) {\n\t\tksft_print_msg(\n\t\t\t\"waitpid() failed: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tif (!WIFSTOPPED(status)) {\n\t\tksft_print_msg(\n\t\t\t\"child did not stop: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tif (WSTOPSIG(status) != SIGSTOP) {\n\t\tksft_print_msg(\"child did not stop with SIGSTOP\\n\");\n\t\treturn false;\n\t}\n\n\tif (!set_watchpoint(pid, wp_size, wp))\n\t\treturn false;\n\n\tif (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {\n\t\tksft_print_msg(\n\t\t\t\"ptrace(PTRACE_CONT) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn false;\n\t}\n\n\talarm(3);\n\twpid = waitpid(pid, &status, __WALL);\n\tif (wpid != pid) {\n\t\tksft_print_msg(\n\t\t\t\"waitpid() failed: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\talarm(0);\n\tif (WIFEXITED(status)) {\n\t\tksft_print_msg(\"child exited prematurely\\n\");\n\t\treturn false;\n\t}\n\tif (!WIFSTOPPED(status)) {\n\t\tksft_print_msg(\"child did not stop\\n\");\n\t\treturn false;\n\t}\n\tif (WSTOPSIG(status) != SIGTRAP) {\n\t\tksft_print_msg(\"child did not stop with SIGTRAP\\n\");\n\t\treturn false;\n\t}\n\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &siginfo) != 0) {\n\t\tksft_print_msg(\n\t\t\t\"ptrace(PTRACE_GETSIGINFO): %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn false;\n\t}\n\tif (siginfo.si_code != TRAP_HWBKPT) {\n\t\tksft_print_msg(\n\t\t\t\"Unexpected si_code %d\\n\", siginfo.si_code);\n\t\treturn false;\n\t}\n\n\tkill(pid, SIGKILL);\n\twpid = waitpid(pid, &status, 0);\n\tif (wpid != pid) {\n\t\tksft_print_msg(\n\t\t\t\"waitpid() failed: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void sigalrm(int sig)\n{\n}\n\nint main(int argc, char **argv)\n{\n\tint opt;\n\tbool succeeded = true;\n\tstruct sigaction act;\n\tint wr, wp, size;\n\tbool result;\n\n\tksft_print_header();\n\tksft_set_plan(213);\n\n\tact.sa_handler = sigalrm;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tsigaction(SIGALRM, &act, NULL);\n\tfor (size = 1; size <= 32; size = size*2) {\n\t\tfor (wr = 0; wr <= 32; wr = wr + size) {\n\t\t\tfor (wp = wr - size; wp <= wr + size; wp = wp + size) {\n\t\t\t\tresult = run_test(size, MIN(size, 8), wr, wp);\n\t\t\t\tif ((result && wr == wp) ||\n\t\t\t\t    (!result && wr != wp))\n\t\t\t\t\tksft_test_result_pass(\n\t\t\t\t\t\t\"Test size = %d write offset = %d watchpoint offset = %d\\n\",\n\t\t\t\t\t\tsize, wr, wp);\n\t\t\t\telse {\n\t\t\t\t\tksft_test_result_fail(\n\t\t\t\t\t\t\"Test size = %d write offset = %d watchpoint offset = %d\\n\",\n\t\t\t\t\t\tsize, wr, wp);\n\t\t\t\t\tsucceeded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (size = 1; size <= 32; size = size*2) {\n\t\tif (run_test(size, 8, -size, -8))\n\t\t\tksft_test_result_pass(\n\t\t\t\t\"Test size = %d write offset = %d watchpoint offset = -8\\n\",\n\t\t\t\tsize, -size);\n\t\telse {\n\t\t\tksft_test_result_fail(\n\t\t\t\t\"Test size = %d write offset = %d watchpoint offset = -8\\n\",\n\t\t\t\tsize, -size);\n\t\t\tsucceeded = false;\n\t\t}\n\t}\n\n\tif (succeeded)\n\t\tksft_exit_pass();\n\telse\n\t\tksft_exit_fail();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}