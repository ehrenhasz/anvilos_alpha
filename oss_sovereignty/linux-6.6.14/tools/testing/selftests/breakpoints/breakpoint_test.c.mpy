{
  "module_name": "breakpoint_test.c",
  "hash_id": "9fcf5c1e8072dd977eac686fe59ede6e39dc060d22c306f3a7e94974a2f4c3cc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/breakpoints/breakpoint_test.c",
  "human_readable_source": "\n \n\n\n#include <sys/ptrace.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <sys/user.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n\n#include \"../kselftest.h\"\n\n#define COUNT_ISN_BPS\t4\n#define COUNT_WPS\t4\n\n \nenum {\n\tBP_X = 1,\n\tBP_RW = 2,\n\tBP_W = 4,\n};\n\nstatic pid_t child_pid;\n\n \nstatic int nr_tests;\n\nstatic void set_breakpoint_addr(void *addr, int n)\n{\n\tint ret;\n\n\tret = ptrace(PTRACE_POKEUSER, child_pid,\n\t\t     offsetof(struct user, u_debugreg[n]), addr);\n\tif (ret)\n\t\tksft_exit_fail_msg(\"Can't set breakpoint addr: %s\\n\",\n\t\t\tstrerror(errno));\n}\n\nstatic void toggle_breakpoint(int n, int type, int len,\n\t\t\t      int local, int global, int set)\n{\n\tint ret;\n\n\tint xtype, xlen;\n\tunsigned long vdr7, dr7;\n\n\tswitch (type) {\n\tcase BP_X:\n\t\txtype = 0;\n\t\tbreak;\n\tcase BP_W:\n\t\txtype = 1;\n\t\tbreak;\n\tcase BP_RW:\n\t\txtype = 3;\n\t\tbreak;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\txlen = 0;\n\t\tbreak;\n\tcase 2:\n\t\txlen = 4;\n\t\tbreak;\n\tcase 4:\n\t\txlen = 0xc;\n\t\tbreak;\n\tcase 8:\n\t\txlen = 8;\n\t\tbreak;\n\t}\n\n\tdr7 = ptrace(PTRACE_PEEKUSER, child_pid,\n\t\t     offsetof(struct user, u_debugreg[7]), 0);\n\n\tvdr7 = (xlen | xtype) << 16;\n\tvdr7 <<= 4 * n;\n\n\tif (local) {\n\t\tvdr7 |= 1 << (2 * n);\n\t\tvdr7 |= 1 << 8;\n\t}\n\tif (global) {\n\t\tvdr7 |= 2 << (2 * n);\n\t\tvdr7 |= 1 << 9;\n\t}\n\n\tif (set)\n\t\tdr7 |= vdr7;\n\telse\n\t\tdr7 &= ~vdr7;\n\n\tret = ptrace(PTRACE_POKEUSER, child_pid,\n\t\t     offsetof(struct user, u_debugreg[7]), dr7);\n\tif (ret) {\n\t\tksft_print_msg(\"Can't set dr7: %s\\n\", strerror(errno));\n\t\texit(-1);\n\t}\n}\n\n \nstatic unsigned long long dummy_var[4];\n\n \nstatic void dummy_func(void) { }\nstatic void dummy_func1(void) { }\nstatic void dummy_func2(void) { }\nstatic void dummy_func3(void) { }\n\nstatic void (*dummy_funcs[])(void) = {\n\tdummy_func,\n\tdummy_func1,\n\tdummy_func2,\n\tdummy_func3,\n};\n\nstatic int trapped;\n\nstatic void check_trapped(void)\n{\n\t \n\tif (!trapped)\n\t\tkill(getpid(), SIGUSR1);\n\ttrapped = 0;\n\n\tnr_tests++;\n}\n\nstatic void write_var(int len)\n{\n\tchar *pcval; short *psval; int *pival; long long *plval;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\tpcval = (char *)&dummy_var[i];\n\t\t\t*pcval = 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpsval = (short *)&dummy_var[i];\n\t\t\t*psval = 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpival = (int *)&dummy_var[i];\n\t\t\t*pival = 0xffffffff;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tplval = (long long *)&dummy_var[i];\n\t\t\t*plval = 0xffffffffffffffffLL;\n\t\t\tbreak;\n\t\t}\n\t\tcheck_trapped();\n\t}\n}\n\nstatic void read_var(int len)\n{\n\tchar cval; short sval; int ival; long long lval;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\tcval = *(char *)&dummy_var[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsval = *(short *)&dummy_var[i];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tival = *(int *)&dummy_var[i];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlval = *(long long *)&dummy_var[i];\n\t\t\tbreak;\n\t\t}\n\t\tcheck_trapped();\n\t}\n}\n\n \nstatic void trigger_tests(void)\n{\n\tint len, local, global, i;\n\tchar val;\n\tint ret;\n\n\tret = ptrace(PTRACE_TRACEME, 0, NULL, 0);\n\tif (ret) {\n\t\tksft_print_msg(\"Can't be traced? %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tkill(getpid(), SIGUSR1);\n\n\t \n\tfor (local = 0; local < 2; local++) {\n\t\tfor (global = 0; global < 2; global++) {\n\t\t\tif (!local && !global)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < COUNT_ISN_BPS; i++) {\n\t\t\t\tdummy_funcs[i]();\n\t\t\t\tcheck_trapped();\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (len = 1; len <= sizeof(long); len <<= 1) {\n\t\tfor (local = 0; local < 2; local++) {\n\t\t\tfor (global = 0; global < 2; global++) {\n\t\t\t\tif (!local && !global)\n\t\t\t\t\tcontinue;\n\t\t\t\twrite_var(len);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (len = 1; len <= sizeof(long); len <<= 1) {\n\t\tfor (local = 0; local < 2; local++) {\n\t\t\tfor (global = 0; global < 2; global++) {\n\t\t\t\tif (!local && !global)\n\t\t\t\t\tcontinue;\n\t\t\t\tread_var(len);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tasm(\".byte 0xf1\\n\");\n\tcheck_trapped();\n\n\t \n\tasm(\"int $3\\n\");\n\tcheck_trapped();\n\n\tkill(getpid(), SIGUSR1);\n}\n\nstatic void check_success(const char *msg)\n{\n\tint child_nr_tests;\n\tint status;\n\tint ret;\n\n\t \n\twait(&status);\n\n\tret = 0;\n\n\tif (WSTOPSIG(status) == SIGTRAP) {\n\t\tchild_nr_tests = ptrace(PTRACE_PEEKDATA, child_pid,\n\t\t\t\t\t&nr_tests, 0);\n\t\tif (child_nr_tests == nr_tests)\n\t\t\tret = 1;\n\t\tif (ptrace(PTRACE_POKEDATA, child_pid, &trapped, 1))\n\t\t\tksft_exit_fail_msg(\"Can't poke: %s\\n\", strerror(errno));\n\t}\n\n\tnr_tests++;\n\n\tif (ret)\n\t\tksft_test_result_pass(msg);\n\telse\n\t\tksft_test_result_fail(msg);\n}\n\nstatic void launch_instruction_breakpoints(char *buf, int local, int global)\n{\n\tint i;\n\n\tfor (i = 0; i < COUNT_ISN_BPS; i++) {\n\t\tset_breakpoint_addr(dummy_funcs[i], i);\n\t\ttoggle_breakpoint(i, BP_X, 1, local, global, 1);\n\t\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\t\tsprintf(buf, \"Test breakpoint %d with local: %d global: %d\\n\",\n\t\t\ti, local, global);\n\t\tcheck_success(buf);\n\t\ttoggle_breakpoint(i, BP_X, 1, local, global, 0);\n\t}\n}\n\nstatic void launch_watchpoints(char *buf, int mode, int len,\n\t\t\t       int local, int global)\n{\n\tconst char *mode_str;\n\tint i;\n\n\tif (mode == BP_W)\n\t\tmode_str = \"write\";\n\telse\n\t\tmode_str = \"read\";\n\n\tfor (i = 0; i < COUNT_WPS; i++) {\n\t\tset_breakpoint_addr(&dummy_var[i], i);\n\t\ttoggle_breakpoint(i, mode, len, local, global, 1);\n\t\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\t\tsprintf(buf,\n\t\t\t\"Test %s watchpoint %d with len: %d local: %d global: %d\\n\",\n\t\t\tmode_str, i, len, local, global);\n\t\tcheck_success(buf);\n\t\ttoggle_breakpoint(i, mode, len, local, global, 0);\n\t}\n}\n\n \nstatic void launch_tests(void)\n{\n\tchar buf[1024];\n\tunsigned int tests = 0;\n\tint len, local, global, i;\n\n\ttests += 3 * COUNT_ISN_BPS;\n\ttests += sizeof(long) / 2 * 3 * COUNT_WPS;\n\ttests += sizeof(long) / 2 * 3 * COUNT_WPS;\n\ttests += 2;\n\tksft_set_plan(tests);\n\n\t \n\tfor (local = 0; local < 2; local++) {\n\t\tfor (global = 0; global < 2; global++) {\n\t\t\tif (!local && !global)\n\t\t\t\tcontinue;\n\t\t\tlaunch_instruction_breakpoints(buf, local, global);\n\t\t}\n\t}\n\n\t \n\tfor (len = 1; len <= sizeof(long); len <<= 1) {\n\t\tfor (local = 0; local < 2; local++) {\n\t\t\tfor (global = 0; global < 2; global++) {\n\t\t\t\tif (!local && !global)\n\t\t\t\t\tcontinue;\n\t\t\t\tlaunch_watchpoints(buf, BP_W, len,\n\t\t\t\t\t\t   local, global);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (len = 1; len <= sizeof(long); len <<= 1) {\n\t\tfor (local = 0; local < 2; local++) {\n\t\t\tfor (global = 0; global < 2; global++) {\n\t\t\t\tif (!local && !global)\n\t\t\t\t\tcontinue;\n\t\t\t\tlaunch_watchpoints(buf, BP_RW, len,\n\t\t\t\t\t\t   local, global);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(\"Test icebp\\n\");\n\n\t \n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n\tcheck_success(\"Test int 3 trap\\n\");\n\n\tptrace(PTRACE_CONT, child_pid, NULL, 0);\n}\n\nint main(int argc, char **argv)\n{\n\tpid_t pid;\n\tint ret;\n\n\tksft_print_header();\n\n\tpid = fork();\n\tif (!pid) {\n\t\ttrigger_tests();\n\t\texit(0);\n\t}\n\n\tchild_pid = pid;\n\n\twait(NULL);\n\n\tlaunch_tests();\n\n\twait(NULL);\n\n\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}