{
  "module_name": "disable-tsc-on-off-stress-test.c",
  "hash_id": "dd14b2eec261fff27948447f924a43f345d13487df7082882e14677c1da894af",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/prctl/disable-tsc-on-off-stress-test.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <inttypes.h>\n#include <wait.h>\n\n\n#include <sys/prctl.h>\n#include <linux/prctl.h>\n\n \n#ifndef PR_GET_TSC\n#define PR_GET_TSC 25\n#define PR_SET_TSC 26\n# define PR_TSC_ENABLE\t\t1    \n# define PR_TSC_SIGSEGV\t\t2    \n#endif\n\n \n\nstatic uint64_t rdtsc(void)\n{\nuint32_t lo, hi;\n \n__asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\nreturn (uint64_t)hi << 32 | lo;\n}\n\nint should_segv = 0;\n\nstatic void sigsegv_cb(int sig)\n{\n\tif (!should_segv)\n\t{\n\t\tfprintf(stderr, \"FATAL ERROR, rdtsc() failed while enabled\\n\");\n\t\texit(0);\n\t}\n\tif (prctl(PR_SET_TSC, PR_TSC_ENABLE) < 0)\n\t{\n\t\tperror(\"prctl\");\n\t\texit(0);\n\t}\n\tshould_segv = 0;\n\n\trdtsc();\n}\n\nstatic void task(void)\n{\n\tsignal(SIGSEGV, sigsegv_cb);\n\talarm(10);\n\tfor(;;)\n\t{\n\t\trdtsc();\n\t\tif (should_segv)\n\t\t{\n\t\t\tfprintf(stderr, \"FATAL ERROR, rdtsc() succeeded while disabled\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (prctl(PR_SET_TSC, PR_TSC_SIGSEGV) < 0)\n\t\t{\n\t\t\tperror(\"prctl\");\n\t\t\texit(0);\n\t\t}\n\t\tshould_segv = 1;\n\t}\n}\n\n\nint main(void)\n{\n\tint n_tasks = 100, i;\n\n\tfprintf(stderr, \"[No further output means we're all right]\\n\");\n\n\tfor (i=0; i<n_tasks; i++)\n\t\tif (fork() == 0)\n\t\t\ttask();\n\n\tfor (i=0; i<n_tasks; i++)\n\t\twait(NULL);\n\n\texit(0);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}