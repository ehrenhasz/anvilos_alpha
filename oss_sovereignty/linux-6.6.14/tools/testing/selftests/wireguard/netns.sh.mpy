{
  "module_name": "netns.sh",
  "hash_id": "0bdc197d52c9eb5b3ce063195c80f80bd6866ea8972e40d359de5f8bd59dc391",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/wireguard/netns.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.\n#\n# This script tests the below topology:\n#\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502   $ns1 namespace    \u2502   \u2502          $ns0 namespace          \u2502   \u2502   $ns2 namespace    \u2502\n# \u2502                     \u2502   \u2502                                  \u2502   \u2502                     \u2502\n# \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502   \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502   \u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n# \u2502\u2502  wg0   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   lo   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  wg0   \u2502\u2502\n# \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502   \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502\n# \u2502\u2502192.168.241.1/24   \u2502\u2502   \u2502    \u2502(ns1)         (ns2)      \u2502   \u2502   \u2502\u2502192.168.241.2/24   \u2502\u2502\n# \u2502\u2502fd00::1/24         \u2502\u2502   \u2502    \u2502127.0.0.1:1   127.0.0.1:2\u2502   \u2502   \u2502\u2502fd00::2/24         \u2502\u2502\n# \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502   \u2502    \u2502[::]:1        [::]:2     \u2502   \u2502   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n#                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n#\n# After the topology is prepared we run a series of TCP/UDP iperf3 tests between the\n# wireguard peers in $ns1 and $ns2. Note that $ns0 is the endpoint for the wg0\n# interfaces in $ns1 and $ns2. See https://www.wireguard.com/netns/ for further\n# details on how this is accomplished.\nset -e\nshopt -s extglob\n\nexec 3>&1\nexport LANG=C\nexport WG_HIDE_KEYS=never\nNPROC=( /sys/devices/system/cpu/cpu+([0-9]) ); NPROC=${#NPROC[@]}\nnetns0=\"wg-test-$$-0\"\nnetns1=\"wg-test-$$-1\"\nnetns2=\"wg-test-$$-2\"\npretty() { echo -e \"\\x1b[32m\\x1b[1m[+] ${1:+NS$1: }${2}\\x1b[0m\" >&3; }\npp() { pretty \"\" \"$*\"; \"$@\"; }\nmaybe_exec() { if [[ $BASHPID -eq $$ ]]; then \"$@\"; else exec \"$@\"; fi; }\nn0() { pretty 0 \"$*\"; maybe_exec ip netns exec $netns0 \"$@\"; }\nn1() { pretty 1 \"$*\"; maybe_exec ip netns exec $netns1 \"$@\"; }\nn2() { pretty 2 \"$*\"; maybe_exec ip netns exec $netns2 \"$@\"; }\nip0() { pretty 0 \"ip $*\"; ip -n $netns0 \"$@\"; }\nip1() { pretty 1 \"ip $*\"; ip -n $netns1 \"$@\"; }\nip2() { pretty 2 \"ip $*\"; ip -n $netns2 \"$@\"; }\nsleep() { read -t \"$1\" -N 1 || true; }\nwaitiperf() { pretty \"${1//*-}\" \"wait for iperf:${3:-5201} pid $2\"; while [[ $(ss -N \"$1\" -tlpH \"sport = ${3:-5201}\") != *\\\"iperf3\\\",pid=$2,fd=* ]]; do sleep 0.1; done; }\nwaitncatudp() { pretty \"${1//*-}\" \"wait for udp:1111 pid $2\"; while [[ $(ss -N \"$1\" -ulpH 'sport = 1111') != *\\\"ncat\\\",pid=$2,fd=* ]]; do sleep 0.1; done; }\nwaitiface() { pretty \"${1//*-}\" \"wait for $2 to come up\"; ip netns exec \"$1\" bash -c \"while [[ \\$(< \\\"/sys/class/net/$2/operstate\\\") != up ]]; do read -t .1 -N 0 || true; done;\"; }\n\ncleanup() {\n\tset +e\n\texec 2>/dev/null\n\tprintf \"$orig_message_cost\" > /proc/sys/net/core/message_cost\n\tip0 link del dev wg0\n\tip0 link del dev wg1\n\tip1 link del dev wg0\n\tip1 link del dev wg1\n\tip2 link del dev wg0\n\tip2 link del dev wg1\n\tlocal to_kill=\"$(ip netns pids $netns0) $(ip netns pids $netns1) $(ip netns pids $netns2)\"\n\t[[ -n $to_kill ]] && kill $to_kill\n\tpp ip netns del $netns1\n\tpp ip netns del $netns2\n\tpp ip netns del $netns0\n\texit\n}\n\norig_message_cost=\"$(< /proc/sys/net/core/message_cost)\"\ntrap cleanup EXIT\nprintf 0 > /proc/sys/net/core/message_cost\n\nip netns del $netns0 2>/dev/null || true\nip netns del $netns1 2>/dev/null || true\nip netns del $netns2 2>/dev/null || true\npp ip netns add $netns0\npp ip netns add $netns1\npp ip netns add $netns2\nip0 link set up dev lo\n\nip0 link add dev wg0 type wireguard\nip0 link set wg0 netns $netns1\nip0 link add dev wg0 type wireguard\nip0 link set wg0 netns $netns2\nkey1=\"$(pp wg genkey)\"\nkey2=\"$(pp wg genkey)\"\nkey3=\"$(pp wg genkey)\"\nkey4=\"$(pp wg genkey)\"\npub1=\"$(pp wg pubkey <<<\"$key1\")\"\npub2=\"$(pp wg pubkey <<<\"$key2\")\"\npub3=\"$(pp wg pubkey <<<\"$key3\")\"\npub4=\"$(pp wg pubkey <<<\"$key4\")\"\npsk=\"$(pp wg genpsk)\"\n[[ -n $key1 && -n $key2 && -n $psk ]]\n\nconfigure_peers() {\n\tip1 addr add 192.168.241.1/24 dev wg0\n\tip1 addr add fd00::1/112 dev wg0\n\n\tip2 addr add 192.168.241.2/24 dev wg0\n\tip2 addr add fd00::2/112 dev wg0\n\n\tn1 wg set wg0 \\\n\t\tprivate-key <(echo \"$key1\") \\\n\t\tlisten-port 1 \\\n\t\tpeer \"$pub2\" \\\n\t\t\tpreshared-key <(echo \"$psk\") \\\n\t\t\tallowed-ips 192.168.241.2/32,fd00::2/128\n\tn2 wg set wg0 \\\n\t\tprivate-key <(echo \"$key2\") \\\n\t\tlisten-port 2 \\\n\t\tpeer \"$pub1\" \\\n\t\t\tpreshared-key <(echo \"$psk\") \\\n\t\t\tallowed-ips 192.168.241.1/32,fd00::1/128\n\n\tip1 link set up dev wg0\n\tip2 link set up dev wg0\n}\nconfigure_peers\n\ntests() {\n\t# Ping over IPv4\n\tn2 ping -c 10 -f -W 1 192.168.241.1\n\tn1 ping -c 10 -f -W 1 192.168.241.2\n\n\t# Ping over IPv6\n\tn2 ping6 -c 10 -f -W 1 fd00::1\n\tn1 ping6 -c 10 -f -W 1 fd00::2\n\n\t# TCP over IPv4\n\tn2 iperf3 -s -1 -B 192.168.241.2 &\n\twaitiperf $netns2 $!\n\tn1 iperf3 -Z -t 3 -c 192.168.241.2\n\n\t# TCP over IPv6\n\tn1 iperf3 -s -1 -B fd00::1 &\n\twaitiperf $netns1 $!\n\tn2 iperf3 -Z -t 3 -c fd00::1\n\n\t# UDP over IPv4\n\tn1 iperf3 -s -1 -B 192.168.241.1 &\n\twaitiperf $netns1 $!\n\tn2 iperf3 -Z -t 3 -b 0 -u -c 192.168.241.1\n\n\t# UDP over IPv6\n\tn2 iperf3 -s -1 -B fd00::2 &\n\twaitiperf $netns2 $!\n\tn1 iperf3 -Z -t 3 -b 0 -u -c fd00::2\n\n\t# TCP over IPv4, in parallel\n\tlocal pids=( ) i\n\tfor ((i=0; i < NPROC; ++i)) do\n\t\tn2 iperf3 -p $(( 5200 + i )) -s -1 -B 192.168.241.2 &\n\t\tpids+=( $! ); waitiperf $netns2 $! $(( 5200 + i ))\n\tdone\n\tfor ((i=0; i < NPROC; ++i)) do\n\t\tn1 iperf3 -Z -t 3 -p $(( 5200 + i )) -c 192.168.241.2 &\n\tdone\n\twait \"${pids[@]}\"\n}\n\n[[ $(ip1 link show dev wg0) =~ mtu\\ ([0-9]+) ]] && orig_mtu=\"${BASH_REMATCH[1]}\"\nbig_mtu=$(( 34816 - 1500 + $orig_mtu ))\n\n# Test using IPv4 as outer transport\nn1 wg set wg0 peer \"$pub2\" endpoint 127.0.0.1:2\nn2 wg set wg0 peer \"$pub1\" endpoint 127.0.0.1:1\n# Before calling tests, we first make sure that the stats counters and timestamper are working\nn2 ping -c 10 -f -W 1 192.168.241.1\n{ read _; read _; read _; read rx_bytes _; read _; read tx_bytes _; } < <(ip2 -stats link show dev wg0)\n(( rx_bytes == 1372 && (tx_bytes == 1428 || tx_bytes == 1460) ))\n{ read _; read _; read _; read rx_bytes _; read _; read tx_bytes _; } < <(ip1 -stats link show dev wg0)\n(( tx_bytes == 1372 && (rx_bytes == 1428 || rx_bytes == 1460) ))\nread _ rx_bytes tx_bytes < <(n2 wg show wg0 transfer)\n(( rx_bytes == 1372 && (tx_bytes == 1428 || tx_bytes == 1460) ))\nread _ rx_bytes tx_bytes < <(n1 wg show wg0 transfer)\n(( tx_bytes == 1372 && (rx_bytes == 1428 || rx_bytes == 1460) ))\nread _ timestamp < <(n1 wg show wg0 latest-handshakes)\n(( timestamp != 0 ))\n\ntests\nip1 link set wg0 mtu $big_mtu\nip2 link set wg0 mtu $big_mtu\ntests\n\nip1 link set wg0 mtu $orig_mtu\nip2 link set wg0 mtu $orig_mtu\n\n# Test using IPv6 as outer transport\nn1 wg set wg0 peer \"$pub2\" endpoint [::1]:2\nn2 wg set wg0 peer \"$pub1\" endpoint [::1]:1\ntests\nip1 link set wg0 mtu $big_mtu\nip2 link set wg0 mtu $big_mtu\ntests\n\n# Test that route MTUs work with the padding\nip1 link set wg0 mtu 1300\nip2 link set wg0 mtu 1300\nn1 wg set wg0 peer \"$pub2\" endpoint 127.0.0.1:2\nn2 wg set wg0 peer \"$pub1\" endpoint 127.0.0.1:1\nn0 iptables -A INPUT -m length --length 1360 -j DROP\nn1 ip route add 192.168.241.2/32 dev wg0 mtu 1299\nn2 ip route add 192.168.241.1/32 dev wg0 mtu 1299\nn2 ping -c 1 -W 1 -s 1269 192.168.241.1\nn2 ip route delete 192.168.241.1/32 dev wg0 mtu 1299\nn1 ip route delete 192.168.241.2/32 dev wg0 mtu 1299\nn0 iptables -F INPUT\n\nip1 link set wg0 mtu $orig_mtu\nip2 link set wg0 mtu $orig_mtu\n\n# Test using IPv4 that roaming works\nip0 -4 addr del 127.0.0.1/8 dev lo\nip0 -4 addr add 127.212.121.99/8 dev lo\nn1 wg set wg0 listen-port 9999\nn1 wg set wg0 peer \"$pub2\" endpoint 127.0.0.1:2\nn1 ping6 -W 1 -c 1 fd00::2\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t127.212.121.99:9999\" ]]\n\n# Test using IPv6 that roaming works\nn1 wg set wg0 listen-port 9998\nn1 wg set wg0 peer \"$pub2\" endpoint [::1]:2\nn1 ping -W 1 -c 1 192.168.241.2\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t[::1]:9998\" ]]\n\n# Test that crypto-RP filter works\nn1 wg set wg0 peer \"$pub2\" allowed-ips 192.168.241.0/24\nexec 4< <(n1 ncat -l -u -p 1111)\nncat_pid=$!\nwaitncatudp $netns1 $ncat_pid\nn2 ncat -u 192.168.241.1 1111 <<<\"X\"\nread -r -N 1 -t 1 out <&4 && [[ $out == \"X\" ]]\nkill $ncat_pid\nmore_specific_key=\"$(pp wg genkey | pp wg pubkey)\"\nn1 wg set wg0 peer \"$more_specific_key\" allowed-ips 192.168.241.2/32\nn2 wg set wg0 listen-port 9997\nexec 4< <(n1 ncat -l -u -p 1111)\nncat_pid=$!\nwaitncatudp $netns1 $ncat_pid\nn2 ncat -u 192.168.241.1 1111 <<<\"X\"\n! read -r -N 1 -t 1 out <&4 || false\nkill $ncat_pid\nn1 wg set wg0 peer \"$more_specific_key\" remove\n[[ $(n1 wg show wg0 endpoints) == \"$pub2\t[::1]:9997\" ]]\n\n# Test that we can change private keys keys and immediately handshake\nn1 wg set wg0 private-key <(echo \"$key1\") peer \"$pub2\" preshared-key <(echo \"$psk\") allowed-ips 192.168.241.2/32 endpoint 127.0.0.1:2\nn2 wg set wg0 private-key <(echo \"$key2\") listen-port 2 peer \"$pub1\" preshared-key <(echo \"$psk\") allowed-ips 192.168.241.1/32\nn1 ping -W 1 -c 1 192.168.241.2\nn1 wg set wg0 private-key <(echo \"$key3\")\nn2 wg set wg0 peer \"$pub3\" preshared-key <(echo \"$psk\") allowed-ips 192.168.241.1/32 peer \"$pub1\" remove\nn1 ping -W 1 -c 1 192.168.241.2\nn2 wg set wg0 peer \"$pub3\" remove\n\n# Test that we can route wg through wg\nip1 addr flush dev wg0\nip2 addr flush dev wg0\nip1 addr add fd00::5:1/112 dev wg0\nip2 addr add fd00::5:2/112 dev wg0\nn1 wg set wg0 private-key <(echo \"$key1\") peer \"$pub2\" preshared-key <(echo \"$psk\") allowed-ips fd00::5:2/128 endpoint 127.0.0.1:2\nn2 wg set wg0 private-key <(echo \"$key2\") listen-port 2 peer \"$pub1\" preshared-key <(echo \"$psk\") allowed-ips fd00::5:1/128 endpoint 127.212.121.99:9998\nip1 link add wg1 type wireguard\nip2 link add wg1 type wireguard\nip1 addr add 192.168.241.1/24 dev wg1\nip1 addr add fd00::1/112 dev wg1\nip2 addr add 192.168.241.2/24 dev wg1\nip2 addr add fd00::2/112 dev wg1\nip1 link set mtu 1340 up dev wg1\nip2 link set mtu 1340 up dev wg1\nn1 wg set wg1 listen-port 5 private-key <(echo \"$key3\") peer \"$pub4\" allowed-ips 192.168.241.2/32,fd00::2/128 endpoint [fd00::5:2]:5\nn2 wg set wg1 listen-port 5 private-key <(echo \"$key4\") peer \"$pub3\" allowed-ips 192.168.241.1/32,fd00::1/128 endpoint [fd00::5:1]:5\ntests\n# Try to set up a routing loop between the two namespaces\nip1 link set netns $netns0 dev wg1\nip0 addr add 192.168.241.1/24 dev wg1\nip0 link set up dev wg1\nn0 ping -W 1 -c 1 192.168.241.2\nn1 wg set wg0 peer \"$pub2\" endpoint 192.168.241.2:7\nip2 link del wg0\nip2 link del wg1\nread _ _ tx_bytes_before < <(n0 wg show wg1 transfer)\n! n0 ping -W 1 -c 10 -f 192.168.241.2 || false\nsleep 1\nread _ _ tx_bytes_after < <(n0 wg show wg1 transfer)\nif ! (( tx_bytes_after - tx_bytes_before < 70000 )); then\n\terrstart=$'\\x1b[37m\\x1b[41m\\x1b[1m'\n\terrend=$'\\x1b[0m'\n\techo \"${errstart}                                                ${errend}\"\n\techo \"${errstart}                   E  R  R  O  R                ${errend}\"\n\techo \"${errstart}                                                ${errend}\"\n\techo \"${errstart} This architecture does not do the right thing  ${errend}\"\n\techo \"${errstart} with cross-namespace routing loops. This test  ${errend}\"\n\techo \"${errstart} has thus technically failed but, as this issue ${errend}\"\n\techo \"${errstart} is as yet unsolved, these tests will continue  ${errend}\"\n\techo \"${errstart} onward. :(                                     ${errend}\"\n\techo \"${errstart}                                                ${errend}\"\nfi\n\nip0 link del wg1\nip1 link del wg0\n\n# Test using NAT. We now change the topology to this:\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502             $ns1 namespace             \u2502    \u2502                 $ns0 namespace                 \u2502     \u2502             $ns2 namespace             \u2502\n# \u2502                                        \u2502    \u2502                                                \u2502     \u2502                                        \u2502\n# \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2510           \u2502    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n# \u2502  \u2502 wg0 \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502vethc\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502vethrc\u2502              \u2502vethrs\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2502veths\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 wg0 \u2502            \u2502\n# \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n# \u2502  \u2502192.168.241.1/24\u2502  \u2502192.168.1.100/24\u2502\u2502    \u2502    \u2502192.168.1.1/24  \u2502    \u250210.0.0.1/24        \u2502 \u2502     \u2502  \u250210.0.0.100/24   \u2502 \u2502192.168.241.2/24\u2502 \u2502\n# \u2502  \u2502fd00::1/24      \u2502  \u2502                \u2502\u2502    \u2502    \u2502                \u2502    \u2502SNAT:192.168.1.0/24\u2502 \u2502     \u2502  \u2502                \u2502 \u2502fd00::2/24      \u2502 \u2502\n# \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nip1 link add dev wg0 type wireguard\nip2 link add dev wg0 type wireguard\nconfigure_peers\n\nip0 link add vethrc type veth peer name vethc\nip0 link add vethrs type veth peer name veths\nip0 link set vethc netns $netns1\nip0 link set veths netns $netns2\nip0 link set vethrc up\nip0 link set vethrs up\nip0 addr add 192.168.1.1/24 dev vethrc\nip0 addr add 10.0.0.1/24 dev vethrs\nip1 addr add 192.168.1.100/24 dev vethc\nip1 link set vethc up\nip1 route add default via 192.168.1.1\nip2 addr add 10.0.0.100/24 dev veths\nip2 link set veths up\nwaitiface $netns0 vethrc\nwaitiface $netns0 vethrs\nwaitiface $netns1 vethc\nwaitiface $netns2 veths\n\nn0 bash -c 'printf 1 > /proc/sys/net/ipv4/ip_forward'\nn0 bash -c 'printf 2 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout'\nn0 bash -c 'printf 2 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream'\nn0 iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -d 10.0.0.0/24 -j SNAT --to 10.0.0.1\n\nn1 wg set wg0 peer \"$pub2\" endpoint 10.0.0.100:2 persistent-keepalive 1\nn1 ping -W 1 -c 1 192.168.241.2\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.0.0.1:1\" ]]\n# Demonstrate n2 can still send packets to n1, since persistent-keepalive will prevent connection tracking entry from expiring (to see entries: `n0 conntrack -L`).\npp sleep 3\nn2 ping -W 1 -c 1 192.168.241.1\nn1 wg set wg0 peer \"$pub2\" persistent-keepalive 0\n\n# Test that sk_bound_dev_if works\nn1 ping -I wg0 -c 1 -W 1 192.168.241.2\n# What about when the mark changes and the packet must be rerouted?\nn1 iptables -t mangle -I OUTPUT -j MARK --set-xmark 1\nn1 ping -c 1 -W 1 192.168.241.2 # First the boring case\nn1 ping -I wg0 -c 1 -W 1 192.168.241.2 # Then the sk_bound_dev_if case\nn1 iptables -t mangle -D OUTPUT -j MARK --set-xmark 1\n\n# Test that onion routing works, even when it loops\nn1 wg set wg0 peer \"$pub3\" allowed-ips 192.168.242.2/32 endpoint 192.168.241.2:5\nip1 addr add 192.168.242.1/24 dev wg0\nip2 link add wg1 type wireguard\nip2 addr add 192.168.242.2/24 dev wg1\nn2 wg set wg1 private-key <(echo \"$key3\") listen-port 5 peer \"$pub1\" allowed-ips 192.168.242.1/32\nip2 link set wg1 up\nn1 ping -W 1 -c 1 192.168.242.2\nip2 link del wg1\nn1 wg set wg0 peer \"$pub3\" endpoint 192.168.242.2:5\n! n1 ping -W 1 -c 1 192.168.242.2 || false # Should not crash kernel\nn1 wg set wg0 peer \"$pub3\" remove\nip1 addr del 192.168.242.1/24 dev wg0\n\n# Do a wg-quick(8)-style policy routing for the default route, making sure vethc has a v6 address to tease out bugs.\nip1 -6 addr add fc00::9/96 dev vethc\nip1 -6 route add default via fc00::1\nip2 -4 addr add 192.168.99.7/32 dev wg0\nip2 -6 addr add abab::1111/128 dev wg0\nn1 wg set wg0 fwmark 51820 peer \"$pub2\" allowed-ips 192.168.99.7,abab::1111\nip1 -6 route add default dev wg0 table 51820\nip1 -6 rule add not fwmark 51820 table 51820\nip1 -6 rule add table main suppress_prefixlength 0\nip1 -4 route add default dev wg0 table 51820\nip1 -4 rule add not fwmark 51820 table 51820\nip1 -4 rule add table main suppress_prefixlength 0\nn1 bash -c 'printf 0 > /proc/sys/net/ipv4/conf/vethc/rp_filter'\n# Flood the pings instead of sending just one, to trigger routing table reference counting bugs.\nn1 ping -W 1 -c 100 -f 192.168.99.7\nn1 ping -W 1 -c 100 -f abab::1111\n\n# Have ns2 NAT into wg0 packets from ns0, but return an icmp error along the right route.\nn2 iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -d 192.168.241.0/24 -j SNAT --to 192.168.241.2\nn0 iptables -t filter -A INPUT \\! -s 10.0.0.0/24 -i vethrs -j DROP # Manual rpfilter just to be explicit.\nn2 bash -c 'printf 1 > /proc/sys/net/ipv4/ip_forward'\nip0 -4 route add 192.168.241.1 via 10.0.0.100\nn2 wg set wg0 peer \"$pub1\" remove\n[[ $(! n0 ping -W 1 -c 1 192.168.241.1 || false) == *\"From 10.0.0.100 icmp_seq=1 Destination Host Unreachable\"* ]]\n\nn0 iptables -t nat -F\nn0 iptables -t filter -F\nn2 iptables -t nat -F\nip0 link del vethrc\nip0 link del vethrs\nip1 link del wg0\nip2 link del wg0\n\n# Test that saddr routing is sticky but not too sticky, changing to this topology:\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502             $ns1 namespace             \u2502    \u2502             $ns2 namespace             \u2502\n# \u2502                                        \u2502    \u2502                                        \u2502\n# \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2510           \u2502    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n# \u2502  \u2502 wg0 \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502veth1\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2502veth2\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 wg0 \u2502            \u2502\n# \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502    \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n# \u2502  \u2502192.168.241.1/24\u2502  \u250210.0.0.1/24     \u2502\u2502    \u2502  \u250210.0.0.2/24     \u2502 \u2502192.168.241.2/24\u2502 \u2502\n# \u2502  \u2502fd00::1/24      \u2502  \u2502fd00:aa::1/96   \u2502\u2502    \u2502  \u2502fd00:aa::2/96   \u2502 \u2502fd00::2/24      \u2502 \u2502\n# \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nip1 link add dev wg0 type wireguard\nip2 link add dev wg0 type wireguard\nconfigure_peers\nip1 link add veth1 type veth peer name veth2\nip1 link set veth2 netns $netns2\nn1 bash -c 'printf 0 > /proc/sys/net/ipv6/conf/all/accept_dad'\nn2 bash -c 'printf 0 > /proc/sys/net/ipv6/conf/all/accept_dad'\nn1 bash -c 'printf 0 > /proc/sys/net/ipv6/conf/veth1/accept_dad'\nn2 bash -c 'printf 0 > /proc/sys/net/ipv6/conf/veth2/accept_dad'\nn1 bash -c 'printf 1 > /proc/sys/net/ipv4/conf/veth1/promote_secondaries'\n\n# First we check that we aren't overly sticky and can fall over to new IPs when old ones are removed\nip1 addr add 10.0.0.1/24 dev veth1\nip1 addr add fd00:aa::1/96 dev veth1\nip2 addr add 10.0.0.2/24 dev veth2\nip2 addr add fd00:aa::2/96 dev veth2\nip1 link set veth1 up\nip2 link set veth2 up\nwaitiface $netns1 veth1\nwaitiface $netns2 veth2\nn1 wg set wg0 peer \"$pub2\" endpoint 10.0.0.2:2\nn1 ping -W 1 -c 1 192.168.241.2\nip1 addr add 10.0.0.10/24 dev veth1\nip1 addr del 10.0.0.1/24 dev veth1\nn1 ping -W 1 -c 1 192.168.241.2\nn1 wg set wg0 peer \"$pub2\" endpoint [fd00:aa::2]:2\nn1 ping -W 1 -c 1 192.168.241.2\nip1 addr add fd00:aa::10/96 dev veth1\nip1 addr del fd00:aa::1/96 dev veth1\nn1 ping -W 1 -c 1 192.168.241.2\n\n# Now we show that we can successfully do reply to sender routing\nip1 link set veth1 down\nip2 link set veth2 down\nip1 addr flush dev veth1\nip2 addr flush dev veth2\nip1 addr add 10.0.0.1/24 dev veth1\nip1 addr add 10.0.0.2/24 dev veth1\nip1 addr add fd00:aa::1/96 dev veth1\nip1 addr add fd00:aa::2/96 dev veth1\nip2 addr add 10.0.0.3/24 dev veth2\nip2 addr add fd00:aa::3/96 dev veth2\nip1 link set veth1 up\nip2 link set veth2 up\nwaitiface $netns1 veth1\nwaitiface $netns2 veth2\nn2 wg set wg0 peer \"$pub1\" endpoint 10.0.0.1:1\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.0.0.1:1\" ]]\nn2 wg set wg0 peer \"$pub1\" endpoint [fd00:aa::1]:1\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t[fd00:aa::1]:1\" ]]\nn2 wg set wg0 peer \"$pub1\" endpoint 10.0.0.2:1\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.0.0.2:1\" ]]\nn2 wg set wg0 peer \"$pub1\" endpoint [fd00:aa::2]:1\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t[fd00:aa::2]:1\" ]]\n\n# What happens if the inbound destination address belongs to a different interface as the default route?\nip1 link add dummy0 type dummy\nip1 addr add 10.50.0.1/24 dev dummy0\nip1 link set dummy0 up\nip2 route add 10.50.0.0/24 dev veth2\nn2 wg set wg0 peer \"$pub1\" endpoint 10.50.0.1:1\nn2 ping -W 1 -c 1 192.168.241.1\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.50.0.1:1\" ]]\n\nip1 link del dummy0\nip1 addr flush dev veth1\nip2 addr flush dev veth2\nip1 route flush dev veth1\nip2 route flush dev veth2\n\n# Now we see what happens if another interface route takes precedence over an ongoing one\nip1 link add veth3 type veth peer name veth4\nip1 link set veth4 netns $netns2\nip1 addr add 10.0.0.1/24 dev veth1\nip2 addr add 10.0.0.2/24 dev veth2\nip1 addr add 10.0.0.3/24 dev veth3\nip1 link set veth1 up\nip2 link set veth2 up\nip1 link set veth3 up\nip2 link set veth4 up\nwaitiface $netns1 veth1\nwaitiface $netns2 veth2\nwaitiface $netns1 veth3\nwaitiface $netns2 veth4\nip1 route flush dev veth1\nip1 route flush dev veth3\nip1 route add 10.0.0.0/24 dev veth1 src 10.0.0.1 metric 2\nn1 wg set wg0 peer \"$pub2\" endpoint 10.0.0.2:2\nn1 ping -W 1 -c 1 192.168.241.2\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.0.0.1:1\" ]]\nip1 route add 10.0.0.0/24 dev veth3 src 10.0.0.3 metric 1\nn1 bash -c 'printf 0 > /proc/sys/net/ipv4/conf/veth1/rp_filter'\nn2 bash -c 'printf 0 > /proc/sys/net/ipv4/conf/veth4/rp_filter'\nn1 bash -c 'printf 0 > /proc/sys/net/ipv4/conf/all/rp_filter'\nn2 bash -c 'printf 0 > /proc/sys/net/ipv4/conf/all/rp_filter'\nn1 ping -W 1 -c 1 192.168.241.2\n[[ $(n2 wg show wg0 endpoints) == \"$pub1\t10.0.0.3:1\" ]]\n\nip1 link del dev veth3\nip1 link del dev wg0\nip2 link del dev wg0\n\n# Make sure persistent keep alives are sent when an adapter comes up\nip1 link add dev wg0 type wireguard\nn1 wg set wg0 private-key <(echo \"$key1\") peer \"$pub2\" endpoint 10.0.0.1:1 persistent-keepalive 1\nread _ _ tx_bytes < <(n1 wg show wg0 transfer)\n[[ $tx_bytes -eq 0 ]]\nip1 link set dev wg0 up\nread _ _ tx_bytes < <(n1 wg show wg0 transfer)\n[[ $tx_bytes -gt 0 ]]\nip1 link del dev wg0\n# This should also happen even if the private key is set later\nip1 link add dev wg0 type wireguard\nn1 wg set wg0 peer \"$pub2\" endpoint 10.0.0.1:1 persistent-keepalive 1\nread _ _ tx_bytes < <(n1 wg show wg0 transfer)\n[[ $tx_bytes -eq 0 ]]\nip1 link set dev wg0 up\nread _ _ tx_bytes < <(n1 wg show wg0 transfer)\n[[ $tx_bytes -eq 0 ]]\nn1 wg set wg0 private-key <(echo \"$key1\")\nread _ _ tx_bytes < <(n1 wg show wg0 transfer)\n[[ $tx_bytes -gt 0 ]]\nip1 link del dev veth1\nip1 link del dev wg0\n\n# We test that Netlink/IPC is working properly by doing things that usually cause split responses\nip0 link add dev wg0 type wireguard\nconfig=( \"[Interface]\" \"PrivateKey=$(wg genkey)\" \"[Peer]\" \"PublicKey=$(wg genkey)\" )\nfor a in {1..255}; do\n\tfor b in {0..255}; do\n\t\tconfig+=( \"AllowedIPs=$a.$b.0.0/16,$a::$b/128\" )\n\tdone\ndone\nn0 wg setconf wg0 <(printf '%s\\n' \"${config[@]}\")\ni=0\nfor ip in $(n0 wg show wg0 allowed-ips); do\n\t((++i))\ndone\n((i == 255*256*2+1))\nip0 link del wg0\nip0 link add dev wg0 type wireguard\nconfig=( \"[Interface]\" \"PrivateKey=$(wg genkey)\" )\nfor a in {1..40}; do\n\tconfig+=( \"[Peer]\" \"PublicKey=$(wg genkey)\" )\n\tfor b in {1..52}; do\n\t\tconfig+=( \"AllowedIPs=$a.$b.0.0/16\" )\n\tdone\ndone\nn0 wg setconf wg0 <(printf '%s\\n' \"${config[@]}\")\ni=0\nwhile read -r line; do\n\tj=0\n\tfor ip in $line; do\n\t\t((++j))\n\tdone\n\t((j == 53))\n\t((++i))\ndone < <(n0 wg show wg0 allowed-ips)\n((i == 40))\nip0 link del wg0\nip0 link add wg0 type wireguard\nconfig=( )\nfor i in {1..29}; do\n\tconfig+=( \"[Peer]\" \"PublicKey=$(wg genkey)\" )\ndone\nconfig+=( \"[Peer]\" \"PublicKey=$(wg genkey)\" \"AllowedIPs=255.2.3.4/32,abcd::255/128\" )\nn0 wg setconf wg0 <(printf '%s\\n' \"${config[@]}\")\nn0 wg showconf wg0 > /dev/null\nip0 link del wg0\n\nallowedips=( )\nfor i in {1..197}; do\n        allowedips+=( abcd::$i )\ndone\nsaved_ifs=\"$IFS\"\nIFS=,\nallowedips=\"${allowedips[*]}\"\nIFS=\"$saved_ifs\"\nip0 link add wg0 type wireguard\nn0 wg set wg0 peer \"$pub1\"\nn0 wg set wg0 peer \"$pub2\" allowed-ips \"$allowedips\"\n{\n\tread -r pub allowedips\n\t[[ $pub == \"$pub1\" && $allowedips == \"(none)\" ]]\n\tread -r pub allowedips\n\t[[ $pub == \"$pub2\" ]]\n\ti=0\n\tfor _ in $allowedips; do\n\t\t((++i))\n\tdone\n\t((i == 197))\n} < <(n0 wg show wg0 allowed-ips)\nip0 link del wg0\n\n! n0 wg show doesnotexist || false\n\nip0 link add wg0 type wireguard\nn0 wg set wg0 private-key <(echo \"$key1\") peer \"$pub2\" preshared-key <(echo \"$psk\")\n[[ $(n0 wg show wg0 private-key) == \"$key1\" ]]\n[[ $(n0 wg show wg0 preshared-keys) == \"$pub2\t$psk\" ]]\nn0 wg set wg0 private-key /dev/null peer \"$pub2\" preshared-key /dev/null\n[[ $(n0 wg show wg0 private-key) == \"(none)\" ]]\n[[ $(n0 wg show wg0 preshared-keys) == \"$pub2\t(none)\" ]]\nn0 wg set wg0 peer \"$pub2\"\nn0 wg set wg0 private-key <(echo \"$key2\")\n[[ $(n0 wg show wg0 public-key) == \"$pub2\" ]]\n[[ -z $(n0 wg show wg0 peers) ]]\nn0 wg set wg0 peer \"$pub2\"\n[[ -z $(n0 wg show wg0 peers) ]]\nn0 wg set wg0 private-key <(echo \"$key1\")\nn0 wg set wg0 peer \"$pub2\"\n[[ $(n0 wg show wg0 peers) == \"$pub2\" ]]\nn0 wg set wg0 private-key <(echo \"/${key1:1}\")\n[[ $(n0 wg show wg0 private-key) == \"+${key1:1}\" ]]\nn0 wg set wg0 peer \"$pub2\" allowed-ips 0.0.0.0/0,10.0.0.0/8,100.0.0.0/10,172.16.0.0/12,192.168.0.0/16\nn0 wg set wg0 peer \"$pub2\" allowed-ips 0.0.0.0/0\nn0 wg set wg0 peer \"$pub2\" allowed-ips ::/0,1700::/111,5000::/4,e000::/37,9000::/75\nn0 wg set wg0 peer \"$pub2\" allowed-ips ::/0\nn0 wg set wg0 peer \"$pub2\" remove\nfor low_order_point in AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= 4Ot6fDtBuK4WVuP68Z/EatoJjeucMrH9hmIFFl9JuAA= X5yVvKNQjCSx0LFVnIPvWwREXMRYHI6G2CJO3dCfEVc= 7P///////////////////////////////////////38= 7f///////////////////////////////////////38= 7v///////////////////////////////////////38=; do\n\tn0 wg set wg0 peer \"$low_order_point\" persistent-keepalive 1 endpoint 127.0.0.1:1111\ndone\n[[ -n $(n0 wg show wg0 peers) ]]\nexec 4< <(n0 ncat -l -u -p 1111)\nncat_pid=$!\nwaitncatudp $netns0 $ncat_pid\nip0 link set wg0 up\n! read -r -n 1 -t 2 <&4 || false\nkill $ncat_pid\nip0 link del wg0\n\n# Ensure that dst_cache references don't outlive netns lifetime\nip1 link add dev wg0 type wireguard\nip2 link add dev wg0 type wireguard\nconfigure_peers\nip1 link add veth1 type veth peer name veth2\nip1 link set veth2 netns $netns2\nip1 addr add fd00:aa::1/64 dev veth1\nip2 addr add fd00:aa::2/64 dev veth2\nip1 link set veth1 up\nip2 link set veth2 up\nwaitiface $netns1 veth1\nwaitiface $netns2 veth2\nip1 -6 route add default dev veth1 via fd00:aa::2\nip2 -6 route add default dev veth2 via fd00:aa::1\nn1 wg set wg0 peer \"$pub2\" endpoint [fd00:aa::2]:2\nn2 wg set wg0 peer \"$pub1\" endpoint [fd00:aa::1]:1\nn1 ping6 -c 1 fd00::2\npp ip netns delete $netns1\npp ip netns delete $netns2\npp ip netns add $netns1\npp ip netns add $netns2\n\n# Ensure there aren't circular reference loops\nip1 link add wg1 type wireguard\nip2 link add wg2 type wireguard\nip1 link set wg1 netns $netns2\nip2 link set wg2 netns $netns1\npp ip netns delete $netns1\npp ip netns delete $netns2\npp ip netns add $netns1\npp ip netns add $netns2\n\nsleep 2 # Wait for cleanup and grace periods\ndeclare -A objects\nwhile read -t 0.1 -r line 2>/dev/null || [[ $? -ne 142 ]]; do\n\t[[ $line =~ .*(wg[0-9]+:\\ [A-Z][a-z]+\\ ?[0-9]*)\\ .*(created|destroyed).* ]] || continue\n\tobjects[\"${BASH_REMATCH[1]}\"]+=\"${BASH_REMATCH[2]}\"\ndone < /dev/kmsg\nalldeleted=1\nfor object in \"${!objects[@]}\"; do\n\tif [[ ${objects[\"$object\"]} != *createddestroyed && ${objects[\"$object\"]} != *createdcreateddestroyeddestroyed ]]; then\n\t\techo \"Error: $object: merely ${objects[\"$object\"]}\" >&3\n\t\talldeleted=0\n\tfi\ndone\n[[ $alldeleted -eq 1 ]]\npretty \"\" \"Objects that were created were also destroyed.\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}