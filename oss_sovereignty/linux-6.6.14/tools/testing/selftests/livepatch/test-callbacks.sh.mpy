{
  "module_name": "test-callbacks.sh",
  "hash_id": "7f37fee435367e54c34966e8193bef61aa73922791d9d0993b98256999fdea2d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/livepatch/test-callbacks.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Copyright (C) 2018 Joe Lawrence <joe.lawrence@redhat.com>\n\n. $(dirname $0)/functions.sh\n\nMOD_LIVEPATCH=test_klp_callbacks_demo\nMOD_LIVEPATCH2=test_klp_callbacks_demo2\nMOD_TARGET=test_klp_callbacks_mod\nMOD_TARGET_BUSY=test_klp_callbacks_busy\n\nsetup_config\n\n\n# Test a combination of loading a kernel module and a livepatch that\n# patches a function in the first module.  Load the target module\n# before the livepatch module.  Unload them in the same order.\n#\n# - On livepatch enable, before the livepatch transition starts,\n#   pre-patch callbacks are executed for vmlinux and $MOD_TARGET (those\n#   klp_objects currently loaded).  After klp_objects are patched\n#   according to the klp_patch, their post-patch callbacks run and the\n#   transition completes.\n#\n# - Similarly, on livepatch disable, pre-patch callbacks run before the\n#   unpatching transition starts.  klp_objects are reverted, post-patch\n#   callbacks execute and the transition completes.\n\nstart_test \"target module before livepatch\"\n\nload_mod $MOD_TARGET\nload_lp $MOD_LIVEPATCH\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\nunload_mod $MOD_TARGET\n\ncheck_result \"% modprobe $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_init\n% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\"\n\n\n# This test is similar to the previous test, but (un)load the livepatch\n# module before the target kernel module.  This tests the livepatch\n# core's module_coming handler.\n#\n# - On livepatch enable, only pre/post-patch callbacks are executed for\n#   currently loaded klp_objects, in this case, vmlinux.\n#\n# - When a targeted module is subsequently loaded, only its\n#   pre/post-patch callbacks are executed.\n#\n# - On livepatch disable, all currently loaded klp_objects' (vmlinux and\n#   $MOD_TARGET) pre/post-unpatch callbacks are executed.\n\nstart_test \"module_coming notifier\"\n\nload_lp $MOD_LIVEPATCH\nload_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\nunload_mod $MOD_TARGET\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% modprobe $MOD_TARGET\nlivepatch: applying patch '$MOD_LIVEPATCH' to loading module '$MOD_TARGET'\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_TARGET: ${MOD_TARGET}_init\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\"\n\n\n# Test loading the livepatch after a targeted kernel module, then unload\n# the kernel module before disabling the livepatch.  This tests the\n# livepatch core's module_going handler.\n#\n# - First load a target module, then the livepatch.\n#\n# - When a target module is unloaded, the livepatch is only reverted\n#   from that klp_object ($MOD_TARGET).  As such, only its pre and\n#   post-unpatch callbacks are executed when this occurs.\n#\n# - When the livepatch is disabled, pre and post-unpatch callbacks are\n#   run for the remaining klp_object, vmlinux.\n\nstart_test \"module_going notifier\"\n\nload_mod $MOD_TARGET\nload_lp $MOD_LIVEPATCH\nunload_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_init\n% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\nlivepatch: reverting patch '$MOD_LIVEPATCH' on unloading module '$MOD_TARGET'\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\"\n\n\n# This test is similar to the previous test, however the livepatch is\n# loaded first.  This tests the livepatch core's module_coming and\n# module_going handlers.\n#\n# - First load the livepatch.\n#\n# - When a targeted kernel module is subsequently loaded, only its\n#   pre/post-patch callbacks are executed.\n#\n# - When the target module is unloaded, the livepatch is only reverted\n#   from the $MOD_TARGET klp_object.  As such, only pre and\n#   post-unpatch callbacks are executed when this occurs.\n\nstart_test \"module_coming and module_going notifiers\"\n\nload_lp $MOD_LIVEPATCH\nload_mod $MOD_TARGET\nunload_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% modprobe $MOD_TARGET\nlivepatch: applying patch '$MOD_LIVEPATCH' to loading module '$MOD_TARGET'\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_TARGET: ${MOD_TARGET}_init\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\nlivepatch: reverting patch '$MOD_LIVEPATCH' on unloading module '$MOD_TARGET'\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\"\n\n\n# A simple test of loading a livepatch without one of its patch target\n# klp_objects ever loaded ($MOD_TARGET).\n#\n# - Load the livepatch.\n#\n# - As expected, only pre/post-(un)patch handlers are executed for\n#   vmlinux.\n\nstart_test \"target module not present\"\n\nload_lp $MOD_LIVEPATCH\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\"\n\n\n# Test a scenario where a vmlinux pre-patch callback returns a non-zero\n# status (ie, failure).\n#\n# - First load a target module.\n#\n# - Load the livepatch module, setting its 'pre_patch_ret' value to -19\n#   (-ENODEV).  When its vmlinux pre-patch callback executes, this\n#   status code will propagate back to the module-loading subsystem.\n#   The result is that the insmod command refuses to load the livepatch\n#   module.\n\nstart_test \"pre-patch callback -ENODEV\"\n\nload_mod $MOD_TARGET\nload_failing_mod $MOD_LIVEPATCH pre_patch_ret=-19\nunload_mod $MOD_TARGET\n\ncheck_result \"% modprobe $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_init\n% modprobe $MOD_LIVEPATCH pre_patch_ret=-19\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\ntest_klp_callbacks_demo: pre_patch_callback: vmlinux\nlivepatch: pre-patch callback failed for object 'vmlinux'\nlivepatch: failed to enable patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': canceling patching transition, going to unpatch\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\nmodprobe: ERROR: could not insert '$MOD_LIVEPATCH': No such device\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\"\n\n\n# Similar to the previous test, setup a livepatch such that its vmlinux\n# pre-patch callback returns success.  However, when a targeted kernel\n# module is later loaded, have the livepatch return a failing status\n# code.\n#\n# - Load the livepatch, vmlinux pre-patch callback succeeds.\n#\n# - Set a trap so subsequent pre-patch callbacks to this livepatch will\n#   return -ENODEV.\n#\n# - The livepatch pre-patch callback for subsequently loaded target\n#   modules will return failure, so the module loader refuses to load\n#   the kernel module.  No post-patch or pre/post-unpatch callbacks are\n#   executed for this klp_object.\n#\n# - Pre/post-unpatch callbacks are run for the vmlinux klp_object.\n\nstart_test \"module_coming + pre-patch callback -ENODEV\"\n\nload_lp $MOD_LIVEPATCH\nset_pre_patch_ret $MOD_LIVEPATCH -19\nload_failing_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% echo -19 > /sys/module/$MOD_LIVEPATCH/parameters/pre_patch_ret\n% modprobe $MOD_TARGET\nlivepatch: applying patch '$MOD_LIVEPATCH' to loading module '$MOD_TARGET'\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\nlivepatch: pre-patch callback failed for object '$MOD_TARGET'\nlivepatch: patch '$MOD_LIVEPATCH' failed for module '$MOD_TARGET', refusing to load module '$MOD_TARGET'\nmodprobe: ERROR: could not insert '$MOD_TARGET': No such device\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\"\n\n\n# Test loading multiple targeted kernel modules.  This test-case is\n# mainly for comparing with the next test-case.\n#\n# - Load a target \"busy\" kernel module which kicks off a worker function\n#   that immediately exits.\n#\n# - Proceed with loading the livepatch and another ordinary target\n#   module.  Post-patch callbacks are executed and the transition\n#   completes quickly.\n\nstart_test \"multiple target modules\"\n\nload_mod $MOD_TARGET_BUSY block_transition=N\nload_lp $MOD_LIVEPATCH\nload_mod $MOD_TARGET\nunload_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\nunload_mod $MOD_TARGET_BUSY\n\ncheck_result \"% modprobe $MOD_TARGET_BUSY block_transition=N\n$MOD_TARGET_BUSY: ${MOD_TARGET_BUSY}_init\n$MOD_TARGET_BUSY: busymod_work_func enter\n$MOD_TARGET_BUSY: busymod_work_func exit\n% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% modprobe $MOD_TARGET\nlivepatch: applying patch '$MOD_LIVEPATCH' to loading module '$MOD_TARGET'\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_LIVEPATCH: post_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_TARGET: ${MOD_TARGET}_init\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\nlivepatch: reverting patch '$MOD_LIVEPATCH' on unloading module '$MOD_TARGET'\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: pre_unpatch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\n% rmmod $MOD_TARGET_BUSY\n$MOD_TARGET_BUSY: ${MOD_TARGET_BUSY}_exit\"\n\n\n# A similar test as the previous one, but force the \"busy\" kernel module\n# to block the livepatch transition.\n#\n# The livepatching core will refuse to patch a task that is currently\n# executing a to-be-patched function -- the consistency model stalls the\n# current patch transition until this safety-check is met.  Test a\n# scenario where one of a livepatch's target klp_objects sits on such a\n# function for a long time.  Meanwhile, load and unload other target\n# kernel modules while the livepatch transition is in progress.\n#\n# - Load the \"busy\" kernel module, this time make its work function loop\n#\n# - Meanwhile, the livepatch is loaded.  Notice that the patch\n#   transition does not complete as the targeted \"busy\" module is\n#   sitting on a to-be-patched function.\n#\n# - Load a second target module (this one is an ordinary idle kernel\n#   module).  Note that *no* post-patch callbacks will be executed while\n#   the livepatch is still in transition.\n#\n# - Request an unload of the simple kernel module.  The patch is still\n#   transitioning, so its pre-unpatch callbacks are skipped.\n#\n# - Finally the livepatch is disabled.  Since none of the patch's\n#   klp_object's post-patch callbacks executed, the remaining\n#   klp_object's pre-unpatch callbacks are skipped.\n\nstart_test \"busy target module\"\n\nload_mod $MOD_TARGET_BUSY block_transition=Y\nload_lp_nowait $MOD_LIVEPATCH\n\n# Wait until the livepatch reports in-transition state, i.e. that it's\n# stalled on $MOD_TARGET_BUSY::busymod_work_func()\nloop_until 'grep -q '^1$' /sys/kernel/livepatch/$MOD_LIVEPATCH/transition' ||\n\tdie \"failed to stall transition\"\n\nload_mod $MOD_TARGET\nunload_mod $MOD_TARGET\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH\nunload_mod $MOD_TARGET_BUSY\n\ncheck_result \"% modprobe $MOD_TARGET_BUSY block_transition=Y\n$MOD_TARGET_BUSY: ${MOD_TARGET_BUSY}_init\n$MOD_TARGET_BUSY: busymod_work_func enter\n% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\n% modprobe $MOD_TARGET\nlivepatch: applying patch '$MOD_LIVEPATCH' to loading module '$MOD_TARGET'\n$MOD_LIVEPATCH: pre_patch_callback: $MOD_TARGET -> [MODULE_STATE_COMING] Full formed, running module_init\n$MOD_TARGET: ${MOD_TARGET}_init\n% rmmod $MOD_TARGET\n$MOD_TARGET: ${MOD_TARGET}_exit\nlivepatch: reverting patch '$MOD_LIVEPATCH' on unloading module '$MOD_TARGET'\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET -> [MODULE_STATE_GOING] Going away\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': reversing transition from patching to unpatching\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\n$MOD_LIVEPATCH: post_unpatch_callback: $MOD_TARGET_BUSY -> [MODULE_STATE_LIVE] Normal state\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH\n% rmmod $MOD_TARGET_BUSY\n$MOD_TARGET_BUSY: busymod_work_func exit\n$MOD_TARGET_BUSY: ${MOD_TARGET_BUSY}_exit\"\n\n\n# Test loading multiple livepatches.  This test-case is mainly for comparing\n# with the next test-case.\n#\n# - Load and unload two livepatches, pre and post (un)patch callbacks\n#   execute as each patch progresses through its (un)patching\n#   transition.\n\nstart_test \"multiple livepatches\"\n\nload_lp $MOD_LIVEPATCH\nload_lp $MOD_LIVEPATCH2\ndisable_lp $MOD_LIVEPATCH2\ndisable_lp $MOD_LIVEPATCH\nunload_lp $MOD_LIVEPATCH2\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% modprobe $MOD_LIVEPATCH2\nlivepatch: enabling patch '$MOD_LIVEPATCH2'\nlivepatch: '$MOD_LIVEPATCH2': initializing patching transition\n$MOD_LIVEPATCH2: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': starting patching transition\nlivepatch: '$MOD_LIVEPATCH2': completing patching transition\n$MOD_LIVEPATCH2: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': patching complete\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH2/enabled\nlivepatch: '$MOD_LIVEPATCH2': initializing unpatching transition\n$MOD_LIVEPATCH2: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH2': completing unpatching transition\n$MOD_LIVEPATCH2: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': unpatching complete\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH/enabled\nlivepatch: '$MOD_LIVEPATCH': initializing unpatching transition\n$MOD_LIVEPATCH: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH': completing unpatching transition\n$MOD_LIVEPATCH: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': unpatching complete\n% rmmod $MOD_LIVEPATCH2\n% rmmod $MOD_LIVEPATCH\"\n\n\n# Load multiple livepatches, but the second as an 'atomic-replace'\n# patch.  When the latter loads, the original livepatch should be\n# disabled and *none* of its pre/post-unpatch callbacks executed.  On\n# the other hand, when the atomic-replace livepatch is disabled, its\n# pre/post-unpatch callbacks *should* be executed.\n#\n# - Load and unload two livepatches, the second of which has its\n#   .replace flag set true.\n#\n# - Pre and post patch callbacks are executed for both livepatches.\n#\n# - Once the atomic replace module is loaded, only its pre and post\n#   unpatch callbacks are executed.\n\nstart_test \"atomic replace\"\n\nload_lp $MOD_LIVEPATCH\nload_lp $MOD_LIVEPATCH2 replace=1\ndisable_lp $MOD_LIVEPATCH2\nunload_lp $MOD_LIVEPATCH2\nunload_lp $MOD_LIVEPATCH\n\ncheck_result \"% modprobe $MOD_LIVEPATCH\nlivepatch: enabling patch '$MOD_LIVEPATCH'\nlivepatch: '$MOD_LIVEPATCH': initializing patching transition\n$MOD_LIVEPATCH: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': starting patching transition\nlivepatch: '$MOD_LIVEPATCH': completing patching transition\n$MOD_LIVEPATCH: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH': patching complete\n% modprobe $MOD_LIVEPATCH2 replace=1\nlivepatch: enabling patch '$MOD_LIVEPATCH2'\nlivepatch: '$MOD_LIVEPATCH2': initializing patching transition\n$MOD_LIVEPATCH2: pre_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': starting patching transition\nlivepatch: '$MOD_LIVEPATCH2': completing patching transition\n$MOD_LIVEPATCH2: post_patch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': patching complete\n% echo 0 > /sys/kernel/livepatch/$MOD_LIVEPATCH2/enabled\nlivepatch: '$MOD_LIVEPATCH2': initializing unpatching transition\n$MOD_LIVEPATCH2: pre_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': starting unpatching transition\nlivepatch: '$MOD_LIVEPATCH2': completing unpatching transition\n$MOD_LIVEPATCH2: post_unpatch_callback: vmlinux\nlivepatch: '$MOD_LIVEPATCH2': unpatching complete\n% rmmod $MOD_LIVEPATCH2\n% rmmod $MOD_LIVEPATCH\"\n\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}