{
  "module_name": "functions.sh",
  "hash_id": "c9de18356b9df6f90154071b6484bc6c3183eb5b3cf903b6f88e730f29b366fa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/livepatch/functions.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Copyright (C) 2018 Joe Lawrence <joe.lawrence@redhat.com>\n\n# Shell functions for the rest of the scripts.\n\nMAX_RETRIES=600\nRETRY_INTERVAL=\".1\"\t# seconds\nKLP_SYSFS_DIR=\"/sys/kernel/livepatch\"\n\n# Kselftest framework requirement - SKIP code is 4\nksft_skip=4\n\n# log(msg) - write message to kernel log\n#\tmsg - insightful words\nfunction log() {\n\techo \"$1\" > /dev/kmsg\n}\n\n# skip(msg) - testing can't proceed\n#\tmsg - explanation\nfunction skip() {\n\tlog \"SKIP: $1\"\n\techo \"SKIP: $1\" >&2\n\texit $ksft_skip\n}\n\n# root test\nfunction is_root() {\n\tuid=$(id -u)\n\tif [ $uid -ne 0 ]; then\n\t\techo \"skip all tests: must be run as root\" >&2\n\t\texit $ksft_skip\n\tfi\n}\n\n# die(msg) - game over, man\n#\tmsg - dying words\nfunction die() {\n\tlog \"ERROR: $1\"\n\techo \"ERROR: $1\" >&2\n\texit 1\n}\n\n# save existing dmesg so we can detect new content\nfunction save_dmesg() {\n\tSAVED_DMESG=$(mktemp --tmpdir -t klp-dmesg-XXXXXX)\n\tdmesg > \"$SAVED_DMESG\"\n}\n\n# cleanup temporary dmesg file from save_dmesg()\nfunction cleanup_dmesg_file() {\n\trm -f \"$SAVED_DMESG\"\n}\n\nfunction push_config() {\n\tDYNAMIC_DEBUG=$(grep '^kernel/livepatch' /sys/kernel/debug/dynamic_debug/control | \\\n\t\t\tawk -F'[: ]' '{print \"file \" $1 \" line \" $2 \" \" $4}')\n\tFTRACE_ENABLED=$(sysctl --values kernel.ftrace_enabled)\n}\n\nfunction pop_config() {\n\tif [[ -n \"$DYNAMIC_DEBUG\" ]]; then\n\t\techo -n \"$DYNAMIC_DEBUG\" > /sys/kernel/debug/dynamic_debug/control\n\tfi\n\tif [[ -n \"$FTRACE_ENABLED\" ]]; then\n\t\tsysctl kernel.ftrace_enabled=\"$FTRACE_ENABLED\" &> /dev/null\n\tfi\n}\n\nfunction set_dynamic_debug() {\n        cat <<-EOF > /sys/kernel/debug/dynamic_debug/control\n\t\tfile kernel/livepatch/* +p\n\t\tfunc klp_try_switch_task -p\n\t\tEOF\n}\n\nfunction set_ftrace_enabled() {\n\tlocal can_fail=0\n\tif [[ \"$1\" == \"--fail\" ]] ; then\n\t\tcan_fail=1\n\t\tshift\n\tfi\n\n\tlocal err=$(sysctl -q kernel.ftrace_enabled=\"$1\" 2>&1)\n\tlocal result=$(sysctl --values kernel.ftrace_enabled)\n\n\tif [[ \"$result\" != \"$1\" ]] ; then\n\t\tif [[ $can_fail -eq 1 ]] ; then\n\t\t\techo \"livepatch: $err\" | sed 's#/proc/sys/kernel/#kernel.#' > /dev/kmsg\n\t\t\treturn\n\t\tfi\n\n\t\tskip \"failed to set kernel.ftrace_enabled = $1\"\n\tfi\n\n\techo \"livepatch: kernel.ftrace_enabled = $result\" > /dev/kmsg\n}\n\nfunction cleanup() {\n\tpop_config\n\tcleanup_dmesg_file\n}\n\n# setup_config - save the current config and set a script exit trap that\n#\t\t restores the original config.  Setup the dynamic debug\n#\t\t for verbose livepatching output and turn on\n#\t\t the ftrace_enabled sysctl.\nfunction setup_config() {\n\tis_root\n\tpush_config\n\tset_dynamic_debug\n\tset_ftrace_enabled 1\n\ttrap cleanup EXIT INT TERM HUP\n}\n\n# loop_until(cmd) - loop a command until it is successful or $MAX_RETRIES,\n#\t\t    sleep $RETRY_INTERVAL between attempts\n#\tcmd - command and its arguments to run\nfunction loop_until() {\n\tlocal cmd=\"$*\"\n\tlocal i=0\n\twhile true; do\n\t\teval \"$cmd\" && return 0\n\t\t[[ $((i++)) -eq $MAX_RETRIES ]] && return 1\n\t\tsleep $RETRY_INTERVAL\n\tdone\n}\n\nfunction assert_mod() {\n\tlocal mod=\"$1\"\n\n\tmodprobe --dry-run \"$mod\" &>/dev/null\n}\n\nfunction is_livepatch_mod() {\n\tlocal mod=\"$1\"\n\n\tif [[ $(modinfo \"$mod\" | awk '/^livepatch:/{print $NF}') == \"Y\" ]]; then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nfunction __load_mod() {\n\tlocal mod=\"$1\"; shift\n\n\tlocal msg=\"% modprobe $mod $*\"\n\tlog \"${msg%% }\"\n\tret=$(modprobe \"$mod\" \"$@\" 2>&1)\n\tif [[ \"$ret\" != \"\" ]]; then\n\t\tdie \"$ret\"\n\tfi\n\n\t# Wait for module in sysfs ...\n\tloop_until '[[ -e \"/sys/module/$mod\" ]]' ||\n\t\tdie \"failed to load module $mod\"\n}\n\n\n# load_mod(modname, params) - load a kernel module\n#\tmodname - module name to load\n#\tparams  - module parameters to pass to modprobe\nfunction load_mod() {\n\tlocal mod=\"$1\"; shift\n\n\tassert_mod \"$mod\" ||\n\t\tskip \"unable to load module ${mod}, verify CONFIG_TEST_LIVEPATCH=m and run self-tests as root\"\n\n\tis_livepatch_mod \"$mod\" &&\n\t\tdie \"use load_lp() to load the livepatch module $mod\"\n\n\t__load_mod \"$mod\" \"$@\"\n}\n\n# load_lp_nowait(modname, params) - load a kernel module with a livepatch\n#\t\t\tbut do not wait on until the transition finishes\n#\tmodname - module name to load\n#\tparams  - module parameters to pass to modprobe\nfunction load_lp_nowait() {\n\tlocal mod=\"$1\"; shift\n\n\tassert_mod \"$mod\" ||\n\t\tskip \"unable to load module ${mod}, verify CONFIG_TEST_LIVEPATCH=m and run self-tests as root\"\n\n\tis_livepatch_mod \"$mod\" ||\n\t\tdie \"module $mod is not a livepatch\"\n\n\t__load_mod \"$mod\" \"$@\"\n\n\t# Wait for livepatch in sysfs ...\n\tloop_until '[[ -e \"/sys/kernel/livepatch/$mod\" ]]' ||\n\t\tdie \"failed to load module $mod (sysfs)\"\n}\n\n# load_lp(modname, params) - load a kernel module with a livepatch\n#\tmodname - module name to load\n#\tparams  - module parameters to pass to modprobe\nfunction load_lp() {\n\tlocal mod=\"$1\"; shift\n\n\tload_lp_nowait \"$mod\" \"$@\"\n\n\t# Wait until the transition finishes ...\n\tloop_until 'grep -q '^0$' /sys/kernel/livepatch/$mod/transition' ||\n\t\tdie \"failed to complete transition\"\n}\n\n# load_failing_mod(modname, params) - load a kernel module, expect to fail\n#\tmodname - module name to load\n#\tparams  - module parameters to pass to modprobe\nfunction load_failing_mod() {\n\tlocal mod=\"$1\"; shift\n\n\tlocal msg=\"% modprobe $mod $*\"\n\tlog \"${msg%% }\"\n\tret=$(modprobe \"$mod\" \"$@\" 2>&1)\n\tif [[ \"$ret\" == \"\" ]]; then\n\t\tdie \"$mod unexpectedly loaded\"\n\tfi\n\tlog \"$ret\"\n}\n\n# unload_mod(modname) - unload a kernel module\n#\tmodname - module name to unload\nfunction unload_mod() {\n\tlocal mod=\"$1\"\n\n\t# Wait for module reference count to clear ...\n\tloop_until '[[ $(cat \"/sys/module/$mod/refcnt\") == \"0\" ]]' ||\n\t\tdie \"failed to unload module $mod (refcnt)\"\n\n\tlog \"% rmmod $mod\"\n\tret=$(rmmod \"$mod\" 2>&1)\n\tif [[ \"$ret\" != \"\" ]]; then\n\t\tdie \"$ret\"\n\tfi\n\n\t# Wait for module in sysfs ...\n\tloop_until '[[ ! -e \"/sys/module/$mod\" ]]' ||\n\t\tdie \"failed to unload module $mod (/sys/module)\"\n}\n\n# unload_lp(modname) - unload a kernel module with a livepatch\n#\tmodname - module name to unload\nfunction unload_lp() {\n\tunload_mod \"$1\"\n}\n\n# disable_lp(modname) - disable a livepatch\n#\tmodname - module name to unload\nfunction disable_lp() {\n\tlocal mod=\"$1\"\n\n\tlog \"% echo 0 > /sys/kernel/livepatch/$mod/enabled\"\n\techo 0 > /sys/kernel/livepatch/\"$mod\"/enabled\n\n\t# Wait until the transition finishes and the livepatch gets\n\t# removed from sysfs...\n\tloop_until '[[ ! -e \"/sys/kernel/livepatch/$mod\" ]]' ||\n\t\tdie \"failed to disable livepatch $mod\"\n}\n\n# set_pre_patch_ret(modname, pre_patch_ret)\n#\tmodname - module name to set\n#\tpre_patch_ret - new pre_patch_ret value\nfunction set_pre_patch_ret {\n\tlocal mod=\"$1\"; shift\n\tlocal ret=\"$1\"\n\n\tlog \"% echo $ret > /sys/module/$mod/parameters/pre_patch_ret\"\n\techo \"$ret\" > /sys/module/\"$mod\"/parameters/pre_patch_ret\n\n\t# Wait for sysfs value to hold ...\n\tloop_until '[[ $(cat \"/sys/module/$mod/parameters/pre_patch_ret\") == \"$ret\" ]]' ||\n\t\tdie \"failed to set pre_patch_ret parameter for $mod module\"\n}\n\nfunction start_test {\n\tlocal test=\"$1\"\n\n\tsave_dmesg\n\techo -n \"TEST: $test ... \"\n\tlog \"===== TEST: $test =====\"\n}\n\n# check_result() - verify dmesg output\n#\tTODO - better filter, out of order msgs, etc?\nfunction check_result {\n\tlocal expect=\"$*\"\n\tlocal result\n\n\t# Note: when comparing dmesg output, the kernel log timestamps\n\t# help differentiate repeated testing runs.  Remove them with a\n\t# post-comparison sed filter.\n\n\tresult=$(dmesg | comm --nocheck-order -13 \"$SAVED_DMESG\" - | \\\n\t\t grep -e 'livepatch:' -e 'test_klp' | \\\n\t\t grep -v '\\(tainting\\|taints\\) kernel' | \\\n\t\t sed 's/^\\[[ 0-9.]*\\] //')\n\n\tif [[ \"$expect\" == \"$result\" ]] ; then\n\t\techo \"ok\"\n\telse\n\t\techo -e \"not ok\\n\\n$(diff -upr --label expected --label result <(echo \"$expect\") <(echo \"$result\"))\\n\"\n\t\tdie \"livepatch kselftest(s) failed\"\n\tfi\n\n\tcleanup_dmesg_file\n}\n\n# check_sysfs_rights(modname, rel_path, expected_rights) - check sysfs\n# path permissions\n#\tmodname - livepatch module creating the sysfs interface\n#\trel_path - relative path of the sysfs interface\n#\texpected_rights - expected access rights\nfunction check_sysfs_rights() {\n\tlocal mod=\"$1\"; shift\n\tlocal rel_path=\"$1\"; shift\n\tlocal expected_rights=\"$1\"; shift\n\n\tlocal path=\"$KLP_SYSFS_DIR/$mod/$rel_path\"\n\tlocal rights=$(/bin/stat --format '%A' \"$path\")\n\tif test \"$rights\" != \"$expected_rights\" ; then\n\t\tdie \"Unexpected access rights of $path: $expected_rights vs. $rights\"\n\tfi\n}\n\n# check_sysfs_value(modname, rel_path, expected_value) - check sysfs value\n#\tmodname - livepatch module creating the sysfs interface\n#\trel_path - relative path of the sysfs interface\n#\texpected_value - expected value read from the file\nfunction check_sysfs_value() {\n\tlocal mod=\"$1\"; shift\n\tlocal rel_path=\"$1\"; shift\n\tlocal expected_value=\"$1\"; shift\n\n\tlocal path=\"$KLP_SYSFS_DIR/$mod/$rel_path\"\n\tlocal value=`cat $path`\n\tif test \"$value\" != \"$expected_value\" ; then\n\t\tdie \"Unexpected value in $path: $expected_value vs. $value\"\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}