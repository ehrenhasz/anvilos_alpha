{
  "module_name": "pidfd_wait.c",
  "hash_id": "643ea69ba654e9006e6adbe017243d862af1c7b3460a2ecd6c289f1bcb676a58",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_wait.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sched.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"pidfd.h\"\n#include \"../kselftest_harness.h\"\n\n#define ptr_to_u64(ptr) ((__u64)((uintptr_t)(ptr)))\n\n \n#ifndef SKIP\n#define SKIP(s, ...)\tXFAIL(s, ##__VA_ARGS__)\n#endif\n\nstatic pid_t sys_clone3(struct clone_args *args)\n{\n\treturn syscall(__NR_clone3, args, sizeof(struct clone_args));\n}\n\nstatic int sys_waitid(int which, pid_t pid, siginfo_t *info, int options,\n\t\t      struct rusage *ru)\n{\n\treturn syscall(__NR_waitid, which, pid, info, options, ru);\n}\n\nTEST(wait_simple)\n{\n\tint pidfd = -1;\n\tpid_t parent_tid = -1;\n\tstruct clone_args args = {\n\t\t.parent_tid = ptr_to_u64(&parent_tid),\n\t\t.pidfd = ptr_to_u64(&pidfd),\n\t\t.flags = CLONE_PIDFD | CLONE_PARENT_SETTID,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\tpid_t pid;\n\tsiginfo_t info = {\n\t\t.si_signo = 0,\n\t};\n\n\tpidfd = open(\"/proc/self\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\tASSERT_GE(pidfd, 0);\n\n\tpid = sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL);\n\tASSERT_NE(pid, 0);\n\tEXPECT_EQ(close(pidfd), 0);\n\tpidfd = -1;\n\n\tpidfd = open(\"/dev/null\", O_RDONLY | O_CLOEXEC);\n\tASSERT_GE(pidfd, 0);\n\n\tpid = sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL);\n\tASSERT_NE(pid, 0);\n\tEXPECT_EQ(close(pidfd), 0);\n\tpidfd = -1;\n\n\tpid = sys_clone3(&args);\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0)\n\t\texit(EXIT_SUCCESS);\n\n\tpid = sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL);\n\tASSERT_GE(pid, 0);\n\tASSERT_EQ(WIFEXITED(info.si_status), true);\n\tASSERT_EQ(WEXITSTATUS(info.si_status), 0);\n\tEXPECT_EQ(close(pidfd), 0);\n\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_EXITED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n}\n\nTEST(wait_states)\n{\n\tint pidfd = -1;\n\tpid_t parent_tid = -1;\n\tstruct clone_args args = {\n\t\t.parent_tid = ptr_to_u64(&parent_tid),\n\t\t.pidfd = ptr_to_u64(&pidfd),\n\t\t.flags = CLONE_PIDFD | CLONE_PARENT_SETTID,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\tint pfd[2];\n\tpid_t pid;\n\tsiginfo_t info = {\n\t\t.si_signo = 0,\n\t};\n\n\tASSERT_EQ(pipe(pfd), 0);\n\tpid = sys_clone3(&args);\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tchar buf[2];\n\n\t\tclose(pfd[1]);\n\t\tkill(getpid(), SIGSTOP);\n\t\tASSERT_EQ(read(pfd[0], buf, 1), 1);\n\t\tclose(pfd[0]);\n\t\tkill(getpid(), SIGSTOP);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tclose(pfd[0]);\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WSTOPPED, NULL), 0);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_STOPPED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tASSERT_EQ(sys_pidfd_send_signal(pidfd, SIGCONT, NULL, 0), 0);\n\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WCONTINUED, NULL), 0);\n\tASSERT_EQ(write(pfd[1], \"C\", 1), 1);\n\tclose(pfd[1]);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_CONTINUED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WUNTRACED, NULL), 0);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_STOPPED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tASSERT_EQ(sys_pidfd_send_signal(pidfd, SIGKILL, NULL, 0), 0);\n\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL), 0);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_KILLED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tEXPECT_EQ(close(pidfd), 0);\n}\n\nTEST(wait_nonblock)\n{\n\tint pidfd;\n\tunsigned int flags = 0;\n\tpid_t parent_tid = -1;\n\tstruct clone_args args = {\n\t\t.parent_tid = ptr_to_u64(&parent_tid),\n\t\t.flags = CLONE_PARENT_SETTID,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\tint ret;\n\tpid_t pid;\n\tsiginfo_t info = {\n\t\t.si_signo = 0,\n\t};\n\n\t \n\tpidfd = sys_pidfd_open(getpid(), PIDFD_NONBLOCK);\n\tEXPECT_GE(pidfd, 0) {\n\t\t \n\t\tASSERT_EQ(errno, EINVAL);\n\t\tSKIP(return, \"Skipping PIDFD_NONBLOCK test\");\n\t}\n\n\tret = sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL);\n\tASSERT_LT(ret, 0);\n\tASSERT_EQ(errno, ECHILD);\n\tEXPECT_EQ(close(pidfd), 0);\n\n\tpid = sys_clone3(&args);\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tkill(getpid(), SIGSTOP);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tpidfd = sys_pidfd_open(pid, PIDFD_NONBLOCK);\n\tEXPECT_GE(pidfd, 0) {\n\t\t \n\t\tASSERT_EQ(errno, EINVAL);\n\t\tSKIP(return, \"Skipping PIDFD_NONBLOCK test\");\n\t}\n\n\tflags = fcntl(pidfd, F_GETFL, 0);\n\tASSERT_GT(flags, 0);\n\tASSERT_GT((flags & O_NONBLOCK), 0);\n\n\t \n\tret = sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL);\n\tASSERT_LT(ret, 0);\n\tASSERT_EQ(errno, EAGAIN);\n\n\t \n\tret = sys_waitid(P_PIDFD, pidfd, &info, WEXITED | WNOHANG, NULL);\n\tASSERT_EQ(ret, 0);\n\n\tASSERT_EQ(fcntl(pidfd, F_SETFL, (flags & ~O_NONBLOCK)), 0);\n\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WSTOPPED, NULL), 0);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_STOPPED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tASSERT_EQ(sys_pidfd_send_signal(pidfd, SIGCONT, NULL, 0), 0);\n\n\tASSERT_EQ(sys_waitid(P_PIDFD, pidfd, &info, WEXITED, NULL), 0);\n\tASSERT_EQ(info.si_signo, SIGCHLD);\n\tASSERT_EQ(info.si_code, CLD_EXITED);\n\tASSERT_EQ(info.si_pid, parent_tid);\n\n\tEXPECT_EQ(close(pidfd), 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}