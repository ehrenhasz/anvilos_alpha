{
  "module_name": "pidfd_test.c",
  "hash_id": "1c2ffcb9e08bb710bc161b73fdca4579a47345266a543e7a8ec009ac58058f94",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_test.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/types.h>\n#include <pthread.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/epoll.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"pidfd.h\"\n#include \"../kselftest.h\"\n\n#define str(s) _str(s)\n#define _str(s) #s\n#define CHILD_THREAD_MIN_WAIT 3  \n\n#define MAX_EVENTS 5\n\nstatic bool have_pidfd_send_signal;\n\nstatic pid_t pidfd_clone(int flags, int *pidfd, int (*fn)(void *))\n{\n\tsize_t stack_size = 1024;\n\tchar *stack[1024] = { 0 };\n\n#ifdef __ia64__\n\treturn __clone2(fn, stack, stack_size, flags | SIGCHLD, NULL, pidfd);\n#else\n\treturn clone(fn, stack + stack_size, flags | SIGCHLD, NULL, pidfd);\n#endif\n}\n\nstatic int signal_received;\n\nstatic void set_signal_received_on_sigusr1(int sig)\n{\n\tif (sig == SIGUSR1)\n\t\tsignal_received = 1;\n}\n\n \nstatic int test_pidfd_send_signal_simple_success(void)\n{\n\tint pidfd, ret;\n\tconst char *test_name = \"pidfd_send_signal send SIGUSR1\";\n\n\tif (!have_pidfd_send_signal) {\n\t\tksft_test_result_skip(\n\t\t\t\"%s test: pidfd_send_signal() syscall not supported\\n\",\n\t\t\ttest_name);\n\t\treturn 0;\n\t}\n\n\tpidfd = open(\"/proc/self\", O_DIRECTORY | O_CLOEXEC);\n\tif (pidfd < 0)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Failed to open process file descriptor\\n\",\n\t\t\ttest_name);\n\n\tsignal(SIGUSR1, set_signal_received_on_sigusr1);\n\n\tret = sys_pidfd_send_signal(pidfd, SIGUSR1, NULL, 0);\n\tclose(pidfd);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"%s test: Failed to send signal\\n\",\n\t\t\t\t   test_name);\n\n\tif (signal_received != 1)\n\t\tksft_exit_fail_msg(\"%s test: Failed to receive signal\\n\",\n\t\t\t\t   test_name);\n\n\tsignal_received = 0;\n\tksft_test_result_pass(\"%s test: Sent signal\\n\", test_name);\n\treturn 0;\n}\n\nstatic int test_pidfd_send_signal_exited_fail(void)\n{\n\tint pidfd, ret, saved_errno;\n\tchar buf[256];\n\tpid_t pid;\n\tconst char *test_name = \"pidfd_send_signal signal exited process\";\n\n\tif (!have_pidfd_send_signal) {\n\t\tksft_test_result_skip(\n\t\t\t\"%s test: pidfd_send_signal() syscall not supported\\n\",\n\t\t\ttest_name);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0)\n\t\tksft_exit_fail_msg(\"%s test: Failed to create new process\\n\",\n\t\t\t\t   test_name);\n\n\tif (pid == 0)\n\t\t_exit(EXIT_SUCCESS);\n\n\tsnprintf(buf, sizeof(buf), \"/proc/%d\", pid);\n\n\tpidfd = open(buf, O_DIRECTORY | O_CLOEXEC);\n\n\tret = wait_for_pid(pid);\n\tksft_print_msg(\"waitpid WEXITSTATUS=%d\\n\", ret);\n\n\tif (pidfd < 0)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Failed to open process file descriptor\\n\",\n\t\t\ttest_name);\n\n\tret = sys_pidfd_send_signal(pidfd, 0, NULL, 0);\n\tsaved_errno = errno;\n\tclose(pidfd);\n\tif (ret == 0)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Managed to send signal to process even though it should have failed\\n\",\n\t\t\ttest_name);\n\n\tif (saved_errno != ESRCH)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Expected to receive ESRCH as errno value but received %d instead\\n\",\n\t\t\ttest_name, saved_errno);\n\n\tksft_test_result_pass(\"%s test: Failed to send signal as expected\\n\",\n\t\t\t      test_name);\n\treturn 0;\n}\n\n \n#define PIDFD_MAX_DEFAULT 0x8000\n\nstatic int test_pidfd_send_signal_recycled_pid_fail(void)\n{\n\tint i, ret;\n\tpid_t pid1;\n\tconst char *test_name = \"pidfd_send_signal signal recycled pid\";\n\n\tif (!have_pidfd_send_signal) {\n\t\tksft_test_result_skip(\n\t\t\t\"%s test: pidfd_send_signal() syscall not supported\\n\",\n\t\t\ttest_name);\n\t\treturn 0;\n\t}\n\n\tret = unshare(CLONE_NEWPID);\n\tif (ret < 0) {\n\t\tif (errno == EPERM) {\n\t\t\tksft_test_result_skip(\"%s test: Unsharing pid namespace not permitted\\n\",\n\t\t\t\t\t      test_name);\n\t\t\treturn 0;\n\t\t}\n\t\tksft_exit_fail_msg(\"%s test: Failed to unshare pid namespace\\n\",\n\t\t\t\t   test_name);\n\t}\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tif (errno == EPERM) {\n\t\t\tksft_test_result_skip(\"%s test: Unsharing mount namespace not permitted\\n\",\n\t\t\t\t\t      test_name);\n\t\t\treturn 0;\n\t\t}\n\t\tksft_exit_fail_msg(\"%s test: Failed to unshare mount namespace\\n\",\n\t\t\t\t   test_name);\n\t}\n\n\tret = mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, 0);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"%s test: Failed to remount / private\\n\",\n\t\t\t\t   test_name);\n\n\t \n\tpid1 = fork();\n\tif (pid1 < 0)\n\t\tksft_exit_fail_msg(\"%s test: Failed to create new process\\n\",\n\t\t\t\t   test_name);\n\n\tif (pid1 == 0) {\n\t\tchar buf[256];\n\t\tpid_t pid2;\n\t\tint pidfd = -1;\n\n\t\t(void)umount2(\"/proc\", MNT_DETACH);\n\t\tret = mount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n\t\tif (ret < 0)\n\t\t\t_exit(PIDFD_ERROR);\n\n\t\t \n\t\tfor (i = 0; i <= PIDFD_MAX_DEFAULT; i++) {\n\t\t\tpid2 = fork();\n\t\t\tif (pid2 < 0)\n\t\t\t\t_exit(PIDFD_ERROR);\n\n\t\t\tif (pid2 == 0)\n\t\t\t\t_exit(PIDFD_PASS);\n\n\t\t\tif (pid2 == PID_RECYCLE) {\n\t\t\t\tsnprintf(buf, sizeof(buf), \"/proc/%d\", pid2);\n\t\t\t\tksft_print_msg(\"pid to recycle is %d\\n\", pid2);\n\t\t\t\tpidfd = open(buf, O_DIRECTORY | O_CLOEXEC);\n\t\t\t}\n\n\t\t\tif (wait_for_pid(pid2))\n\t\t\t\t_exit(PIDFD_ERROR);\n\n\t\t\tif (pid2 >= PID_RECYCLE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (pid2 != PID_RECYCLE) {\n\t\t\t \n\t\t\tclose(pidfd);\n\t\t\t_exit(PIDFD_SKIP);\n\t\t}\n\n\t\tif (pidfd < 0)\n\t\t\t_exit(PIDFD_ERROR);\n\n\t\tfor (i = 0; i <= PIDFD_MAX_DEFAULT; i++) {\n\t\t\tchar c;\n\t\t\tint pipe_fds[2];\n\t\t\tpid_t recycled_pid;\n\t\t\tint child_ret = PIDFD_PASS;\n\n\t\t\tret = pipe2(pipe_fds, O_CLOEXEC);\n\t\t\tif (ret < 0)\n\t\t\t\t_exit(PIDFD_ERROR);\n\n\t\t\trecycled_pid = fork();\n\t\t\tif (recycled_pid < 0)\n\t\t\t\t_exit(PIDFD_ERROR);\n\n\t\t\tif (recycled_pid == 0) {\n\t\t\t\tclose(pipe_fds[1]);\n\t\t\t\t(void)read(pipe_fds[0], &c, 1);\n\t\t\t\tclose(pipe_fds[0]);\n\n\t\t\t\t_exit(PIDFD_PASS);\n\t\t\t}\n\n\t\t\t \n\t\t\tclose(pipe_fds[0]);\n\t\t\tret = kill(recycled_pid, SIGSTOP);\n\t\t\tclose(pipe_fds[1]);\n\t\t\tif (ret) {\n\t\t\t\t(void)wait_for_pid(recycled_pid);\n\t\t\t\t_exit(PIDFD_ERROR);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (recycled_pid == PID_RECYCLE) {\n\t\t\t\tret = sys_pidfd_send_signal(pidfd, SIGCONT,\n\t\t\t\t\t\t\t    NULL, 0);\n\t\t\t\tif (ret && errno == ESRCH)\n\t\t\t\t\tchild_ret = PIDFD_XFAIL;\n\t\t\t\telse\n\t\t\t\t\tchild_ret = PIDFD_FAIL;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = kill(recycled_pid, SIGCONT);\n\t\t\tif (ret)\n\t\t\t\t(void)kill(recycled_pid, SIGKILL);\n\n\t\t\tif (wait_for_pid(recycled_pid))\n\t\t\t\t_exit(PIDFD_ERROR);\n\n\t\t\tswitch (child_ret) {\n\t\t\tcase PIDFD_FAIL:\n\t\t\t\t \n\t\t\tcase PIDFD_XFAIL:\n\t\t\t\t_exit(child_ret);\n\t\t\tcase PIDFD_PASS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\t_exit(PIDFD_ERROR);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (recycled_pid > PIDFD_MAX_DEFAULT)\n\t\t\t\t_exit(PIDFD_SKIP);\n\t\t}\n\n\t\t \n\t\t_exit(PIDFD_SKIP);\n\t}\n\n\tret = wait_for_pid(pid1);\n\tswitch (ret) {\n\tcase PIDFD_FAIL:\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Managed to signal recycled pid %d\\n\",\n\t\t\ttest_name, PID_RECYCLE);\n\tcase PIDFD_PASS:\n\t\tksft_exit_fail_msg(\"%s test: Failed to recycle pid %d\\n\",\n\t\t\t\t   test_name, PID_RECYCLE);\n\tcase PIDFD_SKIP:\n\t\tksft_test_result_skip(\"%s test: Skipping test\\n\", test_name);\n\t\tret = 0;\n\t\tbreak;\n\tcase PIDFD_XFAIL:\n\t\tksft_test_result_pass(\n\t\t\t\"%s test: Failed to signal recycled pid as expected\\n\",\n\t\t\ttest_name);\n\t\tret = 0;\n\t\tbreak;\n\tdefault  :\n\t\tksft_exit_fail_msg(\"%s test: Error while running tests\\n\",\n\t\t\t\t   test_name);\n\t}\n\n\treturn ret;\n}\n\nstatic int test_pidfd_send_signal_syscall_support(void)\n{\n\tint pidfd, ret;\n\tconst char *test_name = \"pidfd_send_signal check for support\";\n\n\tpidfd = open(\"/proc/self\", O_DIRECTORY | O_CLOEXEC);\n\tif (pidfd < 0)\n\t\tksft_exit_fail_msg(\n\t\t\t\"%s test: Failed to open process file descriptor\\n\",\n\t\t\ttest_name);\n\n\tret = sys_pidfd_send_signal(pidfd, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tif (errno == ENOSYS) {\n\t\t\tksft_test_result_skip(\n\t\t\t\t\"%s test: pidfd_send_signal() syscall not supported\\n\",\n\t\t\t\ttest_name);\n\t\t\treturn 0;\n\t\t}\n\t\tksft_exit_fail_msg(\"%s test: Failed to send signal\\n\",\n\t\t\t\t   test_name);\n\t}\n\n\thave_pidfd_send_signal = true;\n\tclose(pidfd);\n\tksft_test_result_pass(\n\t\t\"%s test: pidfd_send_signal() syscall is supported. Tests can be executed\\n\",\n\t\ttest_name);\n\treturn 0;\n}\n\nstatic void *test_pidfd_poll_exec_thread(void *priv)\n{\n\tksft_print_msg(\"Child Thread: starting. pid %d tid %ld ; and sleeping\\n\",\n\t\t\tgetpid(), syscall(SYS_gettid));\n\tksft_print_msg(\"Child Thread: doing exec of sleep\\n\");\n\n\texecl(\"/bin/sleep\", \"sleep\", str(CHILD_THREAD_MIN_WAIT), (char *)NULL);\n\n\tksft_print_msg(\"Child Thread: DONE. pid %d tid %ld\\n\",\n\t\t\tgetpid(), syscall(SYS_gettid));\n\treturn NULL;\n}\n\nstatic void poll_pidfd(const char *test_name, int pidfd)\n{\n\tint c;\n\tint epoll_fd = epoll_create1(EPOLL_CLOEXEC);\n\tstruct epoll_event event, events[MAX_EVENTS];\n\n\tif (epoll_fd == -1)\n\t\tksft_exit_fail_msg(\"%s test: Failed to create epoll file descriptor \"\n\t\t\t\t   \"(errno %d)\\n\",\n\t\t\t\t   test_name, errno);\n\n\tevent.events = EPOLLIN;\n\tevent.data.fd = pidfd;\n\n\tif (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, pidfd, &event)) {\n\t\tksft_exit_fail_msg(\"%s test: Failed to add epoll file descriptor \"\n\t\t\t\t   \"(errno %d)\\n\",\n\t\t\t\t   test_name, errno);\n\t}\n\n\tc = epoll_wait(epoll_fd, events, MAX_EVENTS, 5000);\n\tif (c != 1 || !(events[0].events & EPOLLIN))\n\t\tksft_exit_fail_msg(\"%s test: Unexpected epoll_wait result (c=%d, events=%x) \"\n\t\t\t\t   \"(errno %d)\\n\",\n\t\t\t\t   test_name, c, events[0].events, errno);\n\n\tclose(epoll_fd);\n\treturn;\n\n}\n\nstatic int child_poll_exec_test(void *args)\n{\n\tpthread_t t1;\n\n\tksft_print_msg(\"Child (pidfd): starting. pid %d tid %ld\\n\", getpid(),\n\t\t\tsyscall(SYS_gettid));\n\tpthread_create(&t1, NULL, test_pidfd_poll_exec_thread, NULL);\n\t \n\twhile (1)\n\t\tsleep(1);\n\n\treturn 0;\n}\n\nstatic void test_pidfd_poll_exec(int use_waitpid)\n{\n\tint pid, pidfd = 0;\n\tint status, ret;\n\ttime_t prog_start = time(NULL);\n\tconst char *test_name = \"pidfd_poll check for premature notification on child thread exec\";\n\n\tksft_print_msg(\"Parent: pid: %d\\n\", getpid());\n\tpid = pidfd_clone(CLONE_PIDFD, &pidfd, child_poll_exec_test);\n\tif (pid < 0)\n\t\tksft_exit_fail_msg(\"%s test: pidfd_clone failed (ret %d, errno %d)\\n\",\n\t\t\t\t   test_name, pid, errno);\n\n\tksft_print_msg(\"Parent: Waiting for Child (%d) to complete.\\n\", pid);\n\n\tif (use_waitpid) {\n\t\tret = waitpid(pid, &status, 0);\n\t\tif (ret == -1)\n\t\t\tksft_print_msg(\"Parent: error\\n\");\n\n\t\tif (ret == pid)\n\t\t\tksft_print_msg(\"Parent: Child process waited for.\\n\");\n\t} else {\n\t\tpoll_pidfd(test_name, pidfd);\n\t}\n\n\ttime_t prog_time = time(NULL) - prog_start;\n\n\tksft_print_msg(\"Time waited for child: %lu\\n\", prog_time);\n\n\tclose(pidfd);\n\n\tif (prog_time < CHILD_THREAD_MIN_WAIT || prog_time > CHILD_THREAD_MIN_WAIT + 2)\n\t\tksft_exit_fail_msg(\"%s test: Failed\\n\", test_name);\n\telse\n\t\tksft_test_result_pass(\"%s test: Passed\\n\", test_name);\n}\n\nstatic void *test_pidfd_poll_leader_exit_thread(void *priv)\n{\n\tksft_print_msg(\"Child Thread: starting. pid %d tid %ld ; and sleeping\\n\",\n\t\t\tgetpid(), syscall(SYS_gettid));\n\tsleep(CHILD_THREAD_MIN_WAIT);\n\tksft_print_msg(\"Child Thread: DONE. pid %d tid %ld\\n\", getpid(), syscall(SYS_gettid));\n\treturn NULL;\n}\n\nstatic time_t *child_exit_secs;\nstatic int child_poll_leader_exit_test(void *args)\n{\n\tpthread_t t1, t2;\n\n\tksft_print_msg(\"Child: starting. pid %d tid %ld\\n\", getpid(), syscall(SYS_gettid));\n\tpthread_create(&t1, NULL, test_pidfd_poll_leader_exit_thread, NULL);\n\tpthread_create(&t2, NULL, test_pidfd_poll_leader_exit_thread, NULL);\n\n\t \n\t*child_exit_secs = time(NULL);\n\tsyscall(SYS_exit, 0);\n\t \n\texit(0);\n}\n\nstatic void test_pidfd_poll_leader_exit(int use_waitpid)\n{\n\tint pid, pidfd = 0;\n\tint status, ret = 0;\n\tconst char *test_name = \"pidfd_poll check for premature notification on non-empty\"\n\t\t\t\t\"group leader exit\";\n\n\tchild_exit_secs = mmap(NULL, sizeof *child_exit_secs, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\n\tif (child_exit_secs == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"%s test: mmap failed (errno %d)\\n\",\n\t\t\t\t   test_name, errno);\n\n\tksft_print_msg(\"Parent: pid: %d\\n\", getpid());\n\tpid = pidfd_clone(CLONE_PIDFD, &pidfd, child_poll_leader_exit_test);\n\tif (pid < 0)\n\t\tksft_exit_fail_msg(\"%s test: pidfd_clone failed (ret %d, errno %d)\\n\",\n\t\t\t\t   test_name, pid, errno);\n\n\tksft_print_msg(\"Parent: Waiting for Child (%d) to complete.\\n\", pid);\n\n\tif (use_waitpid) {\n\t\tret = waitpid(pid, &status, 0);\n\t\tif (ret == -1)\n\t\t\tksft_print_msg(\"Parent: error\\n\");\n\t} else {\n\t\t \n\t\tsleep(1);\n\t\tpoll_pidfd(test_name, pidfd);\n\t}\n\n\tif (ret == pid)\n\t\tksft_print_msg(\"Parent: Child process waited for.\\n\");\n\n\ttime_t since_child_exit = time(NULL) - *child_exit_secs;\n\n\tksft_print_msg(\"Time since child exit: %lu\\n\", since_child_exit);\n\n\tclose(pidfd);\n\n\tif (since_child_exit < CHILD_THREAD_MIN_WAIT ||\n\t\t\tsince_child_exit > CHILD_THREAD_MIN_WAIT + 2)\n\t\tksft_exit_fail_msg(\"%s test: Failed\\n\", test_name);\n\telse\n\t\tksft_test_result_pass(\"%s test: Passed\\n\", test_name);\n}\n\nint main(int argc, char **argv)\n{\n\tksft_print_header();\n\tksft_set_plan(8);\n\n\ttest_pidfd_poll_exec(0);\n\ttest_pidfd_poll_exec(1);\n\ttest_pidfd_poll_leader_exit(0);\n\ttest_pidfd_poll_leader_exit(1);\n\ttest_pidfd_send_signal_syscall_support();\n\ttest_pidfd_send_signal_simple_success();\n\ttest_pidfd_send_signal_exited_fail();\n\ttest_pidfd_send_signal_recycled_pid_fail();\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}