{
  "module_name": "pidfd_getfd_test.c",
  "hash_id": "fa250ffdaaedeece03661931b855c5b1882c290f3e6918b00a6039b8e996b665",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_getfd_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <linux/kcmp.h>\n\n#include \"pidfd.h\"\n#include \"../kselftest_harness.h\"\n\n \n#define UNKNOWN_FD 111\n#define UID_NOBODY 65535\n\nstatic int sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1,\n\t\t    unsigned long idx2)\n{\n\treturn syscall(__NR_kcmp, pid1, pid2, type, idx1, idx2);\n}\n\nstatic int __child(int sk, int memfd)\n{\n\tint ret;\n\tchar buf;\n\n\t \n\tret = prctl(PR_SET_PDEATHSIG, SIGKILL);\n\tif (ret) {\n\t\tfprintf(stderr, \"%s: Child could not set DEATHSIG\\n\",\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = send(sk, &memfd, sizeof(memfd), 0);\n\tif (ret != sizeof(memfd)) {\n\t\tfprintf(stderr, \"%s: Child failed to send fd number\\n\",\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\t \n\twhile ((ret = recv(sk, &buf, sizeof(buf), 0)) > 0) {\n\t\tif (buf == 'P') {\n\t\t\tret = prctl(PR_SET_DUMPABLE, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: Child failed to disable ptrace\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Child received unknown command %c\\n\",\n\t\t\t\tbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tret = send(sk, &buf, sizeof(buf), 0);\n\t\tif (ret != 1) {\n\t\t\tfprintf(stderr, \"%s: Child failed to ack\\n\",\n\t\t\t\tstrerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"%s: Child failed to read from socket\\n\",\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int child(int sk)\n{\n\tint memfd, ret;\n\n\tmemfd = sys_memfd_create(\"test\", 0);\n\tif (memfd < 0) {\n\t\tfprintf(stderr, \"%s: Child could not create memfd\\n\",\n\t\t\tstrerror(errno));\n\t\tret = -1;\n\t} else {\n\t\tret = __child(sk, memfd);\n\t\tclose(memfd);\n\t}\n\n\tclose(sk);\n\treturn ret;\n}\n\nFIXTURE(child)\n{\n\t \n\tint remote_fd;\n\t \n\tpid_t pid;\n\t \n\tint pidfd;\n\t \n\tint sk;\n};\n\nFIXTURE_SETUP(child)\n{\n\tint ret, sk_pair[2];\n\n\tASSERT_EQ(0, socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair)) {\n\t\tTH_LOG(\"%s: failed to create socketpair\", strerror(errno));\n\t}\n\tself->sk = sk_pair[0];\n\n\tself->pid = fork();\n\tASSERT_GE(self->pid, 0);\n\n\tif (self->pid == 0) {\n\t\tclose(sk_pair[0]);\n\t\tif (child(sk_pair[1]))\n\t\t\t_exit(EXIT_FAILURE);\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tclose(sk_pair[1]);\n\n\tself->pidfd = sys_pidfd_open(self->pid, 0);\n\tASSERT_GE(self->pidfd, 0);\n\n\t \n\tret = recv(sk_pair[0], &self->remote_fd, sizeof(self->remote_fd), 0);\n\tASSERT_EQ(sizeof(self->remote_fd), ret);\n}\n\nFIXTURE_TEARDOWN(child)\n{\n\tEXPECT_EQ(0, close(self->pidfd));\n\tEXPECT_EQ(0, close(self->sk));\n\n\tEXPECT_EQ(0, wait_for_pid(self->pid));\n}\n\nTEST_F(child, disable_ptrace)\n{\n\tint uid, fd;\n\tchar c;\n\n\t \n\tuid = getuid();\n\tif (uid == 0)\n\t\tASSERT_EQ(0, seteuid(UID_NOBODY));\n\n\tASSERT_EQ(1, send(self->sk, \"P\", 1, 0));\n\tASSERT_EQ(1, recv(self->sk, &c, 1, 0));\n\n\tfd = sys_pidfd_getfd(self->pidfd, self->remote_fd, 0);\n\tEXPECT_EQ(-1, fd);\n\tEXPECT_EQ(EPERM, errno);\n\n\tif (uid == 0)\n\t\tASSERT_EQ(0, seteuid(0));\n}\n\nTEST_F(child, fetch_fd)\n{\n\tint fd, ret;\n\n\tfd = sys_pidfd_getfd(self->pidfd, self->remote_fd, 0);\n\tASSERT_GE(fd, 0);\n\n\tret = sys_kcmp(getpid(), self->pid, KCMP_FILE, fd, self->remote_fd);\n\tif (ret < 0 && errno == ENOSYS)\n\t\tSKIP(return, \"kcmp() syscall not supported\");\n\tEXPECT_EQ(ret, 0);\n\n\tret = fcntl(fd, F_GETFD);\n\tASSERT_GE(ret, 0);\n\tEXPECT_GE(ret & FD_CLOEXEC, 0);\n\n\tclose(fd);\n}\n\nTEST_F(child, test_unknown_fd)\n{\n\tint fd;\n\n\tfd = sys_pidfd_getfd(self->pidfd, UNKNOWN_FD, 0);\n\tEXPECT_EQ(-1, fd) {\n\t\tTH_LOG(\"getfd succeeded while fetching unknown fd\");\n\t};\n\tEXPECT_EQ(EBADF, errno) {\n\t\tTH_LOG(\"%s: getfd did not get EBADF\", strerror(errno));\n\t}\n}\n\nTEST(flags_set)\n{\n\tASSERT_EQ(-1, sys_pidfd_getfd(0, 0, 1));\n\tEXPECT_EQ(errno, EINVAL);\n}\n\n#if __NR_pidfd_getfd == -1\nint main(void)\n{\n\tfprintf(stderr, \"__NR_pidfd_getfd undefined. The pidfd_getfd syscall is unavailable. Test aborting\\n\");\n\treturn KSFT_SKIP;\n}\n#else\nTEST_HARNESS_MAIN\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}