{
  "module_name": "pidfd_setns_test.c",
  "hash_id": "439064e53c5f8683a18d534d940ddcd45928e0d0a8d15209b96f2670bc92f22f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_setns_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n\n#include \"pidfd.h\"\n#include \"../clone3/clone3_selftests.h\"\n#include \"../kselftest_harness.h\"\n\nenum {\n\tPIDFD_NS_USER,\n\tPIDFD_NS_MNT,\n\tPIDFD_NS_PID,\n\tPIDFD_NS_UTS,\n\tPIDFD_NS_IPC,\n\tPIDFD_NS_NET,\n\tPIDFD_NS_CGROUP,\n\tPIDFD_NS_PIDCLD,\n\tPIDFD_NS_TIME,\n\tPIDFD_NS_MAX\n};\n\nconst struct ns_info {\n\tconst char *name;\n\tint flag;\n} ns_info[] = {\n\t[PIDFD_NS_USER]   = { \"user\",             CLONE_NEWUSER,   },\n\t[PIDFD_NS_MNT]    = { \"mnt\",              CLONE_NEWNS,     },\n\t[PIDFD_NS_PID]    = { \"pid\",              CLONE_NEWPID,    },\n\t[PIDFD_NS_UTS]    = { \"uts\",              CLONE_NEWUTS,    },\n\t[PIDFD_NS_IPC]    = { \"ipc\",              CLONE_NEWIPC,    },\n\t[PIDFD_NS_NET]    = { \"net\",              CLONE_NEWNET,    },\n\t[PIDFD_NS_CGROUP] = { \"cgroup\",           CLONE_NEWCGROUP, },\n\t[PIDFD_NS_PIDCLD] = { \"pid_for_children\", 0,               },\n\t[PIDFD_NS_TIME]\t  = { \"time\",             CLONE_NEWTIME,   },\n};\n\nFIXTURE(current_nsset)\n{\n\tpid_t pid;\n\tint pidfd;\n\tint nsfds[PIDFD_NS_MAX];\n\n\tpid_t child_pid_exited;\n\tint child_pidfd_exited;\n\n\tpid_t child_pid1;\n\tint child_pidfd1;\n\tint child_nsfds1[PIDFD_NS_MAX];\n\n\tpid_t child_pid2;\n\tint child_pidfd2;\n\tint child_nsfds2[PIDFD_NS_MAX];\n};\n\nstatic int sys_waitid(int which, pid_t pid, int options)\n{\n\treturn syscall(__NR_waitid, which, pid, NULL, options, NULL);\n}\n\npid_t create_child(int *pidfd, unsigned flags)\n{\n\tstruct __clone_args args = {\n\t\t.flags\t\t= CLONE_PIDFD | flags,\n\t\t.exit_signal\t= SIGCHLD,\n\t\t.pidfd\t\t= ptr_to_u64(pidfd),\n\t};\n\n\treturn sys_clone3(&args, sizeof(struct clone_args));\n}\n\nstatic bool switch_timens(void)\n{\n\tint fd, ret;\n\n\tif (unshare(CLONE_NEWTIME))\n\t\treturn false;\n\n\tfd = open(\"/proc/self/ns/time_for_children\", O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn false;\n\n\tret = setns(fd, CLONE_NEWTIME);\n\tclose(fd);\n\treturn ret == 0;\n}\n\nstatic ssize_t read_nointr(int fd, void *buf, size_t count)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = read(fd, buf, count);\n\t} while (ret < 0 && errno == EINTR);\n\n\treturn ret;\n}\n\nstatic ssize_t write_nointr(int fd, const void *buf, size_t count)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = write(fd, buf, count);\n\t} while (ret < 0 && errno == EINTR);\n\n\treturn ret;\n}\n\nFIXTURE_SETUP(current_nsset)\n{\n\tint i, proc_fd, ret;\n\tint ipc_sockets[2];\n\tchar c;\n\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tself->nsfds[i]\t\t= -EBADF;\n\t\tself->child_nsfds1[i]\t= -EBADF;\n\t\tself->child_nsfds2[i]\t= -EBADF;\n\t}\n\n\tproc_fd = open(\"/proc/self/ns\", O_DIRECTORY | O_CLOEXEC);\n\tASSERT_GE(proc_fd, 0) {\n\t\tTH_LOG(\"%m - Failed to open /proc/self/ns\");\n\t}\n\n\tself->pid = getpid();\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\t\tself->nsfds[i] = openat(proc_fd, info->name, O_RDONLY | O_CLOEXEC);\n\t\tif (self->nsfds[i] < 0) {\n\t\t\tEXPECT_EQ(errno, ENOENT) {\n\t\t\t\tTH_LOG(\"%m - Failed to open %s namespace for process %d\",\n\t\t\t\t       info->name, self->pid);\n\t\t\t}\n\t\t}\n\t}\n\n\tself->pidfd = sys_pidfd_open(self->pid, 0);\n\tEXPECT_GT(self->pidfd, 0) {\n\t\tTH_LOG(\"%m - Failed to open pidfd for process %d\", self->pid);\n\t}\n\n\t \n\tself->child_pid_exited = create_child(&self->child_pidfd_exited,\n\t\t\t\t\t      CLONE_NEWUSER | CLONE_NEWNET);\n\tEXPECT_GT(self->child_pid_exited, 0);\n\n\tif (self->child_pid_exited == 0)\n\t\t_exit(EXIT_SUCCESS);\n\n\tASSERT_EQ(sys_waitid(P_PID, self->child_pid_exited, WEXITED | WNOWAIT), 0);\n\n\tself->pidfd = sys_pidfd_open(self->pid, 0);\n\tEXPECT_GE(self->pidfd, 0) {\n\t\tTH_LOG(\"%m - Failed to open pidfd for process %d\", self->pid);\n\t}\n\n\tret = socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tEXPECT_EQ(ret, 0);\n\n\t \n\tself->child_pid1 = create_child(&self->child_pidfd1,\n\t\t\t\t\tCLONE_NEWUSER | CLONE_NEWNS |\n\t\t\t\t\tCLONE_NEWCGROUP | CLONE_NEWIPC |\n\t\t\t\t\tCLONE_NEWUTS | CLONE_NEWPID |\n\t\t\t\t\tCLONE_NEWNET);\n\tEXPECT_GE(self->child_pid1, 0);\n\n\tif (self->child_pid1 == 0) {\n\t\tclose(ipc_sockets[0]);\n\n\t\tif (!switch_timens())\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (write_nointr(ipc_sockets[1], \"1\", 1) < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tclose(ipc_sockets[1]);\n\n\t\tpause();\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tclose(ipc_sockets[1]);\n\tASSERT_EQ(read_nointr(ipc_sockets[0], &c, 1), 1);\n\tclose(ipc_sockets[0]);\n\n\tret = socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tEXPECT_EQ(ret, 0);\n\n\tself->child_pid2 = create_child(&self->child_pidfd2,\n\t\t\t\t\tCLONE_NEWUSER | CLONE_NEWNS |\n\t\t\t\t\tCLONE_NEWCGROUP | CLONE_NEWIPC |\n\t\t\t\t\tCLONE_NEWUTS | CLONE_NEWPID |\n\t\t\t\t\tCLONE_NEWNET);\n\tEXPECT_GE(self->child_pid2, 0);\n\n\tif (self->child_pid2 == 0) {\n\t\tclose(ipc_sockets[0]);\n\n\t\tif (!switch_timens())\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (write_nointr(ipc_sockets[1], \"1\", 1) < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tclose(ipc_sockets[1]);\n\n\t\tpause();\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tclose(ipc_sockets[1]);\n\tASSERT_EQ(read_nointr(ipc_sockets[0], &c, 1), 1);\n\tclose(ipc_sockets[0]);\n\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tchar p[100];\n\n\t\tconst struct ns_info *info = &ns_info[i];\n\n\t\tself->nsfds[i] = openat(proc_fd, info->name, O_RDONLY | O_CLOEXEC);\n\t\tif (self->nsfds[i] < 0) {\n\t\t\tEXPECT_EQ(errno, ENOENT) {\n\t\t\t\tTH_LOG(\"%m - Failed to open %s namespace for process %d\",\n\t\t\t\t       info->name, self->pid);\n\t\t\t}\n\t\t}\n\n\t\tret = snprintf(p, sizeof(p), \"/proc/%d/ns/%s\",\n\t\t\t       self->child_pid1, info->name);\n\t\tEXPECT_GT(ret, 0);\n\t\tEXPECT_LT(ret, sizeof(p));\n\n\t\tself->child_nsfds1[i] = open(p, O_RDONLY | O_CLOEXEC);\n\t\tif (self->child_nsfds1[i] < 0) {\n\t\t\tEXPECT_EQ(errno, ENOENT) {\n\t\t\t\tTH_LOG(\"%m - Failed to open %s namespace for process %d\",\n\t\t\t\t       info->name, self->child_pid1);\n\t\t\t}\n\t\t}\n\n\t\tret = snprintf(p, sizeof(p), \"/proc/%d/ns/%s\",\n\t\t\t       self->child_pid2, info->name);\n\t\tEXPECT_GT(ret, 0);\n\t\tEXPECT_LT(ret, sizeof(p));\n\n\t\tself->child_nsfds2[i] = open(p, O_RDONLY | O_CLOEXEC);\n\t\tif (self->child_nsfds2[i] < 0) {\n\t\t\tEXPECT_EQ(errno, ENOENT) {\n\t\t\t\tTH_LOG(\"%m - Failed to open %s namespace for process %d\",\n\t\t\t\t       info->name, self->child_pid1);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(proc_fd);\n}\n\nFIXTURE_TEARDOWN(current_nsset)\n{\n\tint i;\n\n\tASSERT_EQ(sys_pidfd_send_signal(self->child_pidfd1,\n\t\t\t\t\tSIGKILL, NULL, 0), 0);\n\tASSERT_EQ(sys_pidfd_send_signal(self->child_pidfd2,\n\t\t\t\t\tSIGKILL, NULL, 0), 0);\n\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tif (self->nsfds[i] >= 0)\n\t\t\tclose(self->nsfds[i]);\n\t\tif (self->child_nsfds1[i] >= 0)\n\t\t\tclose(self->child_nsfds1[i]);\n\t\tif (self->child_nsfds2[i] >= 0)\n\t\t\tclose(self->child_nsfds2[i]);\n\t}\n\n\tif (self->child_pidfd1 >= 0)\n\t\tEXPECT_EQ(0, close(self->child_pidfd1));\n\tif (self->child_pidfd2 >= 0)\n\t\tEXPECT_EQ(0, close(self->child_pidfd2));\n\tASSERT_EQ(sys_waitid(P_PID, self->child_pid_exited, WEXITED), 0);\n\tASSERT_EQ(sys_waitid(P_PID, self->child_pid1, WEXITED), 0);\n\tASSERT_EQ(sys_waitid(P_PID, self->child_pid2, WEXITED), 0);\n}\n\nstatic int preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n\tchar path[50];\n\n\tret = snprintf(path, sizeof(path), \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || (size_t)ret >= sizeof(path))\n\t\treturn -EIO;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}\n\nstatic int in_same_namespace(int ns_fd1, pid_t pid2, const char *ns)\n{\n\tint ns_fd2 = -EBADF;\n\tint ret = -1;\n\tstruct stat ns_st1, ns_st2;\n\n\tret = fstat(ns_fd1, &ns_st1);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tns_fd2 = preserve_ns(pid2, ns);\n\tif (ns_fd2 < 0)\n\t\treturn -1;\n\n\tret = fstat(ns_fd2, &ns_st2);\n\tclose(ns_fd2);\n\tif (ret < 0)\n\t\treturn -1;\n\n\t \n\tif ((ns_st1.st_dev == ns_st2.st_dev) &&\n\t    (ns_st1.st_ino == ns_st2.st_ino))\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\n \nTEST_F(current_nsset, invalid_flags)\n{\n\tASSERT_NE(setns(self->pidfd, 0), 0);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tASSERT_NE(setns(self->pidfd, -1), 0);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tASSERT_NE(setns(self->pidfd, CLONE_VM), 0);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tASSERT_NE(setns(self->pidfd, CLONE_NEWUSER | CLONE_VM), 0);\n\tEXPECT_EQ(errno, EINVAL);\n}\n\n \nTEST_F(current_nsset, pidfd_exited_child)\n{\n\tint i;\n\tpid_t pid;\n\n\tASSERT_NE(setns(self->child_pidfd_exited, CLONE_NEWUSER | CLONE_NEWNET),\n\t\t  0);\n\tEXPECT_EQ(errno, ESRCH);\n\n\tpid = getpid();\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\t\t \n\t\tif (self->nsfds[i] >= 0)\n\t\t\tASSERT_EQ(in_same_namespace(self->nsfds[i], pid, info->name), 1);\n\t}\n}\n\nTEST_F(current_nsset, pidfd_incremental_setns)\n{\n\tint i;\n\tpid_t pid;\n\n\tpid = getpid();\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\t\tint nsfd;\n\n\t\tif (self->child_nsfds1[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (info->flag) {\n\t\t\tASSERT_EQ(setns(self->child_pidfd1, info->flag), 0) {\n\t\t\t\tTH_LOG(\"%m - Failed to setns to %s namespace of %d via pidfd %d\",\n\t\t\t\t       info->name, self->child_pid1,\n\t\t\t\t       self->child_pidfd1);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (info->flag == CLONE_NEWPID)\n\t\t\tnsfd = self->nsfds[i];\n\t\telse\n\t\t\tnsfd = self->child_nsfds1[i];\n\t\tASSERT_EQ(in_same_namespace(nsfd, pid, info->name), 1) {\n\t\t\tTH_LOG(\"setns failed to place us correctly into %s namespace of %d via pidfd %d\",\n\t\t\t       info->name, self->child_pid1,\n\t\t\t       self->child_pidfd1);\n\t\t}\n\t\tTH_LOG(\"Managed to correctly setns to %s namespace of %d via pidfd %d\",\n\t\t       info->name, self->child_pid1, self->child_pidfd1);\n\t}\n}\n\nTEST_F(current_nsset, nsfd_incremental_setns)\n{\n\tint i;\n\tpid_t pid;\n\n\tpid = getpid();\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\t\tint nsfd;\n\n\t\tif (self->child_nsfds1[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (info->flag) {\n\t\t\tASSERT_EQ(setns(self->child_nsfds1[i], info->flag), 0) {\n\t\t\t\tTH_LOG(\"%m - Failed to setns to %s namespace of %d via nsfd %d\",\n\t\t\t\t       info->name, self->child_pid1,\n\t\t\t\t       self->child_nsfds1[i]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (info->flag == CLONE_NEWPID)\n\t\t\tnsfd = self->nsfds[i];\n\t\telse\n\t\t\tnsfd = self->child_nsfds1[i];\n\t\tASSERT_EQ(in_same_namespace(nsfd, pid, info->name), 1) {\n\t\t\tTH_LOG(\"setns failed to place us correctly into %s namespace of %d via nsfd %d\",\n\t\t\t       info->name, self->child_pid1,\n\t\t\t       self->child_nsfds1[i]);\n\t\t}\n\t\tTH_LOG(\"Managed to correctly setns to %s namespace of %d via nsfd %d\",\n\t\t       info->name, self->child_pid1, self->child_nsfds1[i]);\n\t}\n}\n\nTEST_F(current_nsset, pidfd_one_shot_setns)\n{\n\tunsigned flags = 0;\n\tint i;\n\tpid_t pid;\n\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\n\t\tif (self->child_nsfds1[i] < 0)\n\t\t\tcontinue;\n\n\t\tflags |= info->flag;\n\t\tTH_LOG(\"Adding %s namespace of %d to list of namespaces to attach to\",\n\t\t       info->name, self->child_pid1);\n\t}\n\n\tASSERT_EQ(setns(self->child_pidfd1, flags), 0) {\n\t\tTH_LOG(\"%m - Failed to setns to namespaces of %d\",\n\t\t       self->child_pid1);\n\t}\n\n\tpid = getpid();\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\t\tint nsfd;\n\n\t\tif (self->child_nsfds1[i] < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (info->flag == CLONE_NEWPID)\n\t\t\tnsfd = self->nsfds[i];\n\t\telse\n\t\t\tnsfd = self->child_nsfds1[i];\n\t\tASSERT_EQ(in_same_namespace(nsfd, pid, info->name), 1) {\n\t\t\tTH_LOG(\"setns failed to place us correctly into %s namespace of %d\",\n\t\t\t       info->name, self->child_pid1);\n\t\t}\n\t\tTH_LOG(\"Managed to correctly setns to %s namespace of %d\",\n\t\t       info->name, self->child_pid1);\n\t}\n}\n\nTEST_F(current_nsset, no_foul_play)\n{\n\tunsigned flags = 0;\n\tint i;\n\n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\n\t\tif (self->child_nsfds1[i] < 0)\n\t\t\tcontinue;\n\n\t\tflags |= info->flag;\n\t\tif (info->flag)  \n\t\t\tTH_LOG(\"Adding %s namespace of %d to list of namespaces to attach to\",\n\t\t\t       info->name, self->child_pid1);\n\t}\n\n\tASSERT_EQ(setns(self->child_pidfd1, flags), 0) {\n\t\tTH_LOG(\"%m - Failed to setns to namespaces of %d vid pidfd %d\",\n\t\t       self->child_pid1, self->child_pidfd1);\n\t}\n\n\t \n\tfor (i = 0; i < PIDFD_NS_MAX; i++) {\n\t\tconst struct ns_info *info = &ns_info[i];\n\n\t\tif (self->child_nsfds2[i] < 0 || !info->flag)\n\t\t\tcontinue;\n\n\t\tASSERT_NE(setns(self->child_pidfd2, info->flag), 0) {\n\t\t\tTH_LOG(\"Managed to setns to %s namespace of %d via pidfd %d\",\n\t\t\t       info->name, self->child_pid2,\n\t\t\t       self->child_pidfd2);\n\t\t}\n\t\tTH_LOG(\"%m - Correctly failed to setns to %s namespace of %d via pidfd %d\",\n\t\t       info->name, self->child_pid2,\n\t\t       self->child_pidfd2);\n\n\t\tASSERT_NE(setns(self->child_nsfds2[i], info->flag), 0) {\n\t\t\tTH_LOG(\"Managed to setns to %s namespace of %d via nsfd %d\",\n\t\t\t       info->name, self->child_pid2,\n\t\t\t       self->child_nsfds2[i]);\n\t\t}\n\t\tTH_LOG(\"%m - Correctly failed to setns to %s namespace of %d via nsfd %d\",\n\t\t       info->name, self->child_pid2,\n\t\t       self->child_nsfds2[i]);\n\t}\n}\n\nTEST(setns_einval)\n{\n\tint fd;\n\n\tfd = sys_memfd_create(\"rostock\", 0);\n\tEXPECT_GT(fd, 0);\n\n\tASSERT_NE(setns(fd, 0), 0);\n\tEXPECT_EQ(errno, EINVAL);\n\tclose(fd);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}