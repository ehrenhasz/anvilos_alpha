{
  "module_name": "pidfd_open_test.c",
  "hash_id": "6cafd5441f640871fbb66acf70a9e00c16afda6d716cca716aa077170c90c5f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_open_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"pidfd.h\"\n#include \"../kselftest.h\"\n\nstatic int safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tlong sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX || sli < INT_MIN)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}\n\nstatic int char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' ||\n\t\t    buffer[i] == '\\t')\n\t\t\tcontinue;\n\n\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic int char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' '  ||\n\t\t    buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' ||\n\t\t    buffer[i] == '\\0')\n\t\t\tcontinue;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *trim_whitespace_in_place(char *buffer)\n{\n\tbuffer += char_left_gc(buffer, strlen(buffer));\n\tbuffer[char_right_gc(buffer, strlen(buffer))] = '\\0';\n\treturn buffer;\n}\n\nstatic pid_t get_pid_from_fdinfo_file(int pidfd, const char *key, size_t keylen)\n{\n\tint ret;\n\tchar path[512];\n\tFILE *f;\n\tsize_t n = 0;\n\tpid_t result = -1;\n\tchar *line = NULL;\n\n\tsnprintf(path, sizeof(path), \"/proc/self/fdinfo/%d\", pidfd);\n\n\tf = fopen(path, \"re\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\n\t\tif (strncmp(line, key, keylen))\n\t\t\tcontinue;\n\n\t\tnumstr = trim_whitespace_in_place(line + 4);\n\t\tret = safe_int(numstr, &result);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbreak;\n\t}\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn result;\n}\n\nint main(int argc, char **argv)\n{\n\tint pidfd = -1, ret = 1;\n\tpid_t pid;\n\n\tksft_set_plan(3);\n\n\tpidfd = sys_pidfd_open(-1, 0);\n\tif (pidfd >= 0) {\n\t\tksft_print_msg(\n\t\t\t\"%s - succeeded to open pidfd for invalid pid -1\\n\",\n\t\t\tstrerror(errno));\n\t\tgoto on_error;\n\t}\n\tksft_test_result_pass(\"do not allow invalid pid test: passed\\n\");\n\n\tpidfd = sys_pidfd_open(getpid(), 1);\n\tif (pidfd >= 0) {\n\t\tksft_print_msg(\n\t\t\t\"%s - succeeded to open pidfd with invalid flag value specified\\n\",\n\t\t\tstrerror(errno));\n\t\tgoto on_error;\n\t}\n\tksft_test_result_pass(\"do not allow invalid flag test: passed\\n\");\n\n\tpidfd = sys_pidfd_open(getpid(), 0);\n\tif (pidfd < 0) {\n\t\tksft_print_msg(\"%s - failed to open pidfd\\n\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\tksft_test_result_pass(\"open a new pidfd test: passed\\n\");\n\n\tpid = get_pid_from_fdinfo_file(pidfd, \"Pid:\", sizeof(\"Pid:\") - 1);\n\tksft_print_msg(\"pidfd %d refers to process with pid %d\\n\", pidfd, pid);\n\n\tret = 0;\n\non_error:\n\tif (pidfd >= 0)\n\t\tclose(pidfd);\n\n\treturn !ret ? ksft_exit_pass() : ksft_exit_fail();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}