{
  "module_name": "pidfd_fdinfo_test.c",
  "hash_id": "bb88ee24207f1739ac2bb089a6385da2f81b194e243bea5dabdd8c508f77dd16",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/pidfd/pidfd_fdinfo_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n\n#include \"pidfd.h\"\n#include \"../kselftest.h\"\n\nstruct error {\n\tint  code;\n\tchar msg[512];\n};\n\nstatic int error_set(struct error *err, int code, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tif (code == PIDFD_PASS || !err || err->code != PIDFD_PASS)\n\t\treturn code;\n\n\terr->code = code;\n\tva_start(args, fmt);\n\tr = vsnprintf(err->msg, sizeof(err->msg), fmt, args);\n\tassert((size_t)r < sizeof(err->msg));\n\tva_end(args);\n\n\treturn code;\n}\n\nstatic void error_report(struct error *err, const char *test_name)\n{\n\tswitch (err->code) {\n\tcase PIDFD_ERROR:\n\t\tksft_exit_fail_msg(\"%s test: Fatal: %s\\n\", test_name, err->msg);\n\t\tbreak;\n\n\tcase PIDFD_FAIL:\n\t\t \n\t\tksft_test_result_error(\"%s test: %s\\n\", test_name, err->msg);\n\t\tbreak;\n\n\tcase PIDFD_SKIP:\n\t\t \n\t\tksft_test_result_skip(\"%s test: %s\\n\", test_name, err->msg);\n\t\tbreak;\n\n\tcase PIDFD_XFAIL:\n\t\tksft_test_result_pass(\"%s test: Expected failure: %s\\n\",\n\t\t\t\t      test_name, err->msg);\n\t\tbreak;\n\n\tcase PIDFD_PASS:\n\t\tksft_test_result_pass(\"%s test: Passed\\n\", test_name);\n\t\tbreak;\n\n\tdefault:\n\t\tksft_exit_fail_msg(\"%s test: Unknown code: %d %s\\n\",\n\t\t\t\t   test_name, err->code, err->msg);\n\t\tbreak;\n\t}\n}\n\nstatic inline int error_check(struct error *err, const char *test_name)\n{\n\t \n\tif (err->code == PIDFD_ERROR)\n\t\terror_report(err, test_name);\n\n\treturn err->code;\n}\n\n#define CHILD_STACK_SIZE 8192\n\nstruct child {\n\tchar *stack;\n\tpid_t pid;\n\tint   fd;\n};\n\nstatic struct child clone_newns(int (*fn)(void *), void *args,\n\t\t\t\tstruct error *err)\n{\n\tstatic int flags = CLONE_PIDFD | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD;\n\tstruct child ret;\n\n\tif (!(flags & CLONE_NEWUSER) && geteuid() != 0)\n\t\tflags |= CLONE_NEWUSER;\n\n\tret.stack = mmap(NULL, CHILD_STACK_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\tif (ret.stack == MAP_FAILED) {\n\t\terror_set(err, -1, \"mmap of stack failed (errno %d)\", errno);\n\t\treturn ret;\n\t}\n\n#ifdef __ia64__\n\tret.pid = __clone2(fn, ret.stack, CHILD_STACK_SIZE, flags, args, &ret.fd);\n#else\n\tret.pid = clone(fn, ret.stack + CHILD_STACK_SIZE, flags, args, &ret.fd);\n#endif\n\n\tif (ret.pid < 0) {\n\t\terror_set(err, PIDFD_ERROR, \"clone failed (ret %d, errno %d)\",\n\t\t\t  ret.fd, errno);\n\t\treturn ret;\n\t}\n\n\tksft_print_msg(\"New child: %d, fd: %d\\n\", ret.pid, ret.fd);\n\n\treturn ret;\n}\n\nstatic inline void child_close(struct child *child)\n{\n\tclose(child->fd);\n}\n\nstatic inline int child_join(struct child *child, struct error *err)\n{\n\tint r;\n\n\tr = wait_for_pid(child->pid);\n\tif (r < 0)\n\t\terror_set(err, PIDFD_ERROR, \"waitpid failed (ret %d, errno %d)\",\n\t\t\t  r, errno);\n\telse if (r > 0)\n\t\terror_set(err, r, \"child %d reported: %d\", child->pid, r);\n\n\tif (munmap(child->stack, CHILD_STACK_SIZE)) {\n\t\terror_set(err, -1, \"munmap of child stack failed (errno %d)\", errno);\n\t\tr = -1;\n\t}\n\n\tksft_print_msg(\"waitpid WEXITSTATUS=%d\\n\", r);\n\treturn r;\n}\n\nstatic inline int child_join_close(struct child *child, struct error *err)\n{\n\tchild_close(child);\n\treturn child_join(child, err);\n}\n\nstatic inline void trim_newline(char *str)\n{\n\tchar *pos = strrchr(str, '\\n');\n\n\tif (pos)\n\t\t*pos = '\\0';\n}\n\nstatic int verify_fdinfo(int pidfd, struct error *err, const char *prefix,\n\t\t\t size_t prefix_len, const char *expect, ...)\n{\n\tchar buffer[512] = {0, };\n\tchar path[512] = {0, };\n\tva_list args;\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t n = 0;\n\tint found = 0;\n\tint r;\n\n\tva_start(args, expect);\n\tr = vsnprintf(buffer, sizeof(buffer), expect, args);\n\tassert((size_t)r < sizeof(buffer));\n\tva_end(args);\n\n\tsnprintf(path, sizeof(path), \"/proc/self/fdinfo/%d\", pidfd);\n\tf = fopen(path, \"re\");\n\tif (!f)\n\t\treturn error_set(err, PIDFD_ERROR, \"fdinfo open failed for %d\",\n\t\t\t\t pidfd);\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *val;\n\n\t\tif (strncmp(line, prefix, prefix_len))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\n\t\tval = line + prefix_len;\n\t\tr = strcmp(val, buffer);\n\t\tif (r != 0) {\n\t\t\ttrim_newline(line);\n\t\t\ttrim_newline(buffer);\n\t\t\terror_set(err, PIDFD_FAIL, \"%s '%s' != '%s'\",\n\t\t\t\t  prefix, val, buffer);\n\t\t}\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(f);\n\n\tif (found == 0)\n\t\treturn error_set(err, PIDFD_FAIL, \"%s not found for fd %d\",\n\t\t\t\t prefix, pidfd);\n\n\treturn PIDFD_PASS;\n}\n\nstatic int child_fdinfo_nspid_test(void *args)\n{\n\tstruct error err;\n\tint pidfd;\n\tint r;\n\n\t \n\tif (!args)\n\t\treturn PIDFD_PASS;\n\n\t \n\tr = mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, 0);\n\tif (r < 0) {\n\t\tksft_print_msg(\"Failed to remount / private\\n\");\n\t\treturn PIDFD_ERROR;\n\t}\n\n\t(void)umount2(\"/proc\", MNT_DETACH);\n\tr = mount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n\tif (r < 0) {\n\t\tksft_print_msg(\"Failed to remount /proc\\n\");\n\t\treturn PIDFD_ERROR;\n\t}\n\n\tpidfd = *(int *)args;\n\tr = verify_fdinfo(pidfd, &err, \"NSpid:\", 6, \"\\t0\\n\");\n\n\tif (r != PIDFD_PASS)\n\t\tksft_print_msg(\"NSpid fdinfo check failed: %s\\n\", err.msg);\n\n\treturn r;\n}\n\nstatic void test_pidfd_fdinfo_nspid(void)\n{\n\tstruct child a, b;\n\tstruct error err = {0, };\n\tconst char *test_name = \"pidfd check for NSpid in fdinfo\";\n\n\t \n\ta = clone_newns(child_fdinfo_nspid_test, NULL, &err);\n\terror_check(&err, test_name);\n\n\t \n\tb = clone_newns(child_fdinfo_nspid_test, &a.fd, &err);\n\terror_check(&err, test_name);\n\n\t \n\tverify_fdinfo(a.fd, &err, \"NSpid:\", 6, \"\\t%d\\t%d\\n\", a.pid, 1);\n\tverify_fdinfo(b.fd, &err, \"NSpid:\", 6, \"\\t%d\\t%d\\n\", b.pid, 1);\n\n\t \n\tchild_join_close(&a, &err);\n\tchild_join_close(&b, &err);\n\n\terror_report(&err, test_name);\n}\n\nstatic void test_pidfd_dead_fdinfo(void)\n{\n\tstruct child a;\n\tstruct error err = {0, };\n\tconst char *test_name = \"pidfd check fdinfo for dead process\";\n\n\t \n\ta = clone_newns(child_fdinfo_nspid_test, NULL, &err);\n\terror_check(&err, test_name);\n\tchild_join(&a, &err);\n\n\tverify_fdinfo(a.fd, &err, \"Pid:\", 4, \"\\t-1\\n\");\n\tverify_fdinfo(a.fd, &err, \"NSpid:\", 6, \"\\t-1\\n\");\n\tchild_close(&a);\n\terror_report(&err, test_name);\n}\n\nint main(int argc, char **argv)\n{\n\tksft_print_header();\n\tksft_set_plan(2);\n\n\ttest_pidfd_fdinfo_nspid();\n\ttest_pidfd_dead_fdinfo();\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}