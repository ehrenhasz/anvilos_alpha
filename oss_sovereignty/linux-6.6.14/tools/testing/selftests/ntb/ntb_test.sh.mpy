{
  "module_name": "ntb_test.sh",
  "hash_id": "ab9fd9e2f8ab4d741f17661c335c29d8b20fe6a23fd9dc08aa32bd577d84607c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ntb/ntb_test.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0-or-later\n# Copyright (c) 2016 Microsemi. All Rights Reserved.\n#\n# Author: Logan Gunthorpe <logang@deltatee.com>\n\nREMOTE_HOST=\nLIST_DEVS=FALSE\n\nDEBUGFS=${DEBUGFS-/sys/kernel/debug}\n\nPERF_RUN_ORDER=32\nMAX_MW_SIZE=0\nRUN_DMA_TESTS=\nDONT_CLEANUP=\nMW_SIZE=65536\n\nfunction show_help()\n{\n\techo \"Usage: $0 [OPTIONS] LOCAL_DEV REMOTE_DEV\"\n\techo \"Run tests on a pair of NTB endpoints.\"\n\techo\n\techo \"If the NTB device loops back to the same host then,\"\n\techo \"just specifying the two PCI ids on the command line is\"\n\techo \"sufficient. Otherwise, if the NTB link spans two hosts\"\n\techo \"use the -r option to specify the hostname for the remote\"\n\techo \"device. SSH will then be used to test the remote side.\"\n\techo \"An SSH key between the root users of the host would then\"\n\techo \"be highly recommended.\"\n\techo\n\techo \"Options:\"\n\techo \"  -C              don't cleanup ntb modules on exit\"\n\techo \"  -h              show this help message\"\n\techo \"  -l              list available local and remote PCI ids\"\n\techo \"  -r REMOTE_HOST  specify the remote's hostname to connect\"\n\techo \"                  to for the test (using ssh)\"\n\techo \"  -m MW_SIZE      memory window size for ntb_tool\"\n\techo \"                  (default: $MW_SIZE)\"\n\techo \"  -d              run dma tests for ntb_perf\"\n\techo \"  -p ORDER        total data order for ntb_perf\"\n\techo \"                  (default: $PERF_RUN_ORDER)\"\n\techo \"  -w MAX_MW_SIZE  maxmium memory window size for ntb_perf\"\n\techo\n}\n\nfunction parse_args()\n{\n\tOPTIND=0\n\twhile getopts \"b:Cdhlm:r:p:w:\" opt; do\n\t\tcase \"$opt\" in\n\t\tC)  DONT_CLEANUP=1 ;;\n\t\td)  RUN_DMA_TESTS=1 ;;\n\t\th)  show_help; exit 0 ;;\n\t\tl)  LIST_DEVS=TRUE ;;\n\t\tm)  MW_SIZE=${OPTARG} ;;\n\t\tr)  REMOTE_HOST=${OPTARG} ;;\n\t\tp)  PERF_RUN_ORDER=${OPTARG} ;;\n\t\tw)  MAX_MW_SIZE=${OPTARG} ;;\n\t\t\\?)\n\t\t    echo \"Invalid option: -$OPTARG\" >&2\n\t\t    exit 1\n\t\t    ;;\n\t\tesac\n\tdone\n}\n\nparse_args \"$@\"\nshift $((OPTIND-1))\nLOCAL_DEV=$1\nshift\nparse_args \"$@\"\nshift $((OPTIND-1))\nREMOTE_DEV=$1\nshift\nparse_args \"$@\"\n\nset -e\n\nfunction _modprobe()\n{\n\tmodprobe \"$@\" || return 1\n\n\tif [[ \"$REMOTE_HOST\" != \"\" ]]; then\n\t\tssh \"$REMOTE_HOST\" modprobe \"$@\" || return 1\n\tfi\n}\n\nfunction split_remote()\n{\n\tVPATH=$1\n\tREMOTE=\n\n\tif [[ \"$VPATH\" == *\":/\"* ]]; then\n\t\tREMOTE=${VPATH%%:*}\n\t\tVPATH=${VPATH#*:}\n\tfi\n}\n\nfunction read_file()\n{\n\tsplit_remote $1\n\tif [[ \"$REMOTE\" != \"\" ]]; then\n\t\tssh \"$REMOTE\" cat \"$VPATH\"\n\telse\n\t\tcat \"$VPATH\"\n\tfi\n}\n\nfunction write_file()\n{\n\tsplit_remote $2\n\tVALUE=$1\n\n\tif [[ \"$REMOTE\" != \"\" ]]; then\n\t\tssh \"$REMOTE\" \"echo \\\"$VALUE\\\" > \\\"$VPATH\\\"\"\n\telse\n\t\techo \"$VALUE\" > \"$VPATH\"\n\tfi\n}\n\nfunction check_file()\n{\n\tsplit_remote $1\n\n\tif [[ \"$REMOTE\" != \"\" ]]; then\n\t\tssh \"$REMOTE\" \"[[ -e ${VPATH} ]]\"\n\telse\n\t\t[[ -e ${VPATH} ]]\n\tfi\n}\n\nfunction subdirname()\n{\n\techo $(basename $(dirname $1)) 2> /dev/null\n}\n\nfunction find_pidx()\n{\n\tPORT=$1\n\tPPATH=$2\n\n\tfor ((i = 0; i < 64; i++)); do\n\t\tPEER_DIR=\"$PPATH/peer$i\"\n\n\t\tcheck_file ${PEER_DIR} || break\n\n\t\tPEER_PORT=$(read_file \"${PEER_DIR}/port\")\n\t\tif [[ ${PORT} -eq $PEER_PORT ]]; then\n\t\t\techo $i\n\t\t\treturn 0\n\t\tfi\n\tdone\n\n\treturn 1\n}\n\nfunction port_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\techo \"Running port tests on: $(basename $LOC) / $(basename $REM)\"\n\n\tLOCAL_PORT=$(read_file \"$LOC/port\")\n\tREMOTE_PORT=$(read_file \"$REM/port\")\n\n\tLOCAL_PIDX=$(find_pidx ${REMOTE_PORT} \"$LOC\")\n\tREMOTE_PIDX=$(find_pidx ${LOCAL_PORT} \"$REM\")\n\n\techo \"Local port ${LOCAL_PORT} with index ${REMOTE_PIDX} on remote host\"\n\techo \"Peer port ${REMOTE_PORT} with index ${LOCAL_PIDX} on local host\"\n\n\techo \"  Passed\"\n}\n\nfunction link_test()\n{\n\tLOC=$1\n\tREM=$2\n\tEXP=0\n\n\techo \"Running link tests on: $(subdirname $LOC) / $(subdirname $REM)\"\n\n\tif ! write_file \"N\" \"$LOC/../link\" 2> /dev/null; then\n\t\techo \"  Unsupported\"\n\t\treturn\n\tfi\n\n\twrite_file \"N\" \"$LOC/link_event\"\n\n\tif [[ $(read_file \"$REM/link\") != \"N\" ]]; then\n\t\techo \"Expected link to be down in $REM/link\" >&2\n\t\texit -1\n\tfi\n\n\twrite_file \"Y\" \"$LOC/../link\"\n\n\techo \"  Passed\"\n}\n\nfunction doorbell_test()\n{\n\tLOC=$1\n\tREM=$2\n\tEXP=0\n\n\techo \"Running db tests on: $(basename $LOC) / $(basename $REM)\"\n\n\tDB_VALID_MASK=$(read_file \"$LOC/db_valid_mask\")\n\n\twrite_file \"c $DB_VALID_MASK\" \"$REM/db\"\n\n\tfor ((i = 0; i < 64; i++)); do\n\t\tDB=$(read_file \"$REM/db\")\n\t\tif [[ \"$DB\" -ne \"$EXP\" ]]; then\n\t\t\techo \"Doorbell doesn't match expected value $EXP \" \\\n\t\t\t     \"in $REM/db\" >&2\n\t\t\texit -1\n\t\tfi\n\n\t\tlet \"MASK = (1 << $i) & $DB_VALID_MASK\" || true\n\t\tlet \"EXP = $EXP | $MASK\" || true\n\n\t\twrite_file \"s $MASK\" \"$LOC/peer_db\"\n\tdone\n\n\twrite_file \"c $DB_VALID_MASK\" \"$REM/db_mask\"\n\twrite_file $DB_VALID_MASK \"$REM/db_event\"\n\twrite_file \"s $DB_VALID_MASK\" \"$REM/db_mask\"\n\n\twrite_file \"c $DB_VALID_MASK\" \"$REM/db\"\n\n\techo \"  Passed\"\n}\n\nfunction get_files_count()\n{\n\tNAME=$1\n\tLOC=$2\n\n\tsplit_remote $LOC\n\n\tif [[ \"$REMOTE\" == \"\" ]]; then\n\t\techo $(ls -1 \"$VPATH\"/${NAME}* 2>/dev/null | wc -l)\n\telse\n\t\techo $(ssh \"$REMOTE\" \"ls -1 \\\"$VPATH\\\"/${NAME}* | \\\n\t\t       wc -l\" 2> /dev/null)\n\tfi\n}\n\nfunction scratchpad_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\techo \"Running spad tests on: $(subdirname $LOC) / $(subdirname $REM)\"\n\n\tCNT=$(get_files_count \"spad\" \"$LOC\")\n\n\tif [[ $CNT -eq 0 ]]; then\n\t\techo \"  Unsupported\"\n\t\treturn\n\tfi\n\n\tfor ((i = 0; i < $CNT; i++)); do\n\t\tVAL=$RANDOM\n\t\twrite_file \"$VAL\" \"$LOC/spad$i\"\n\t\tRVAL=$(read_file \"$REM/../spad$i\")\n\n\t\tif [[ \"$VAL\" -ne \"$RVAL\" ]]; then\n\t\t\techo \"Scratchpad $i value $RVAL doesn't match $VAL\" >&2\n\t\t\texit -1\n\t\tfi\n\tdone\n\n\techo \"  Passed\"\n}\n\nfunction message_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\techo \"Running msg tests on: $(subdirname $LOC) / $(subdirname $REM)\"\n\n\tCNT=$(get_files_count \"msg\" \"$LOC\")\n\n\tif [[ $CNT -eq 0 ]]; then\n\t\techo \"  Unsupported\"\n\t\treturn\n\tfi\n\n\tMSG_OUTBITS_MASK=$(read_file \"$LOC/../msg_inbits\")\n\tMSG_INBITS_MASK=$(read_file \"$REM/../msg_inbits\")\n\n\twrite_file \"c $MSG_OUTBITS_MASK\" \"$LOC/../msg_sts\"\n\twrite_file \"c $MSG_INBITS_MASK\" \"$REM/../msg_sts\"\n\n\tfor ((i = 0; i < $CNT; i++)); do\n\t\tVAL=$RANDOM\n\t\twrite_file \"$VAL\" \"$LOC/msg$i\"\n\t\tRVAL=$(read_file \"$REM/../msg$i\")\n\n\t\tif [[ \"$VAL\" -ne \"${RVAL%%<-*}\" ]]; then\n\t\t\techo \"Message $i value $RVAL doesn't match $VAL\" >&2\n\t\t\texit -1\n\t\tfi\n\tdone\n\n\techo \"  Passed\"\n}\n\nfunction get_number()\n{\n\tKEY=$1\n\n\tsed -n \"s/^\\(${KEY}\\)[ \\t]*\\(0x[0-9a-fA-F]*\\)\\(\\[p\\]\\)\\?$/\\2/p\"\n}\n\nfunction mw_alloc()\n{\n\tIDX=$1\n\tLOC=$2\n\tREM=$3\n\n\twrite_file $MW_SIZE \"$LOC/mw_trans$IDX\"\n\n\tINB_MW=$(read_file \"$LOC/mw_trans$IDX\")\n\tMW_ALIGNED_SIZE=$(echo \"$INB_MW\" | get_number \"Window Size\")\n\tMW_DMA_ADDR=$(echo \"$INB_MW\" | get_number \"DMA Address\")\n\n\twrite_file \"$MW_DMA_ADDR:$(($MW_ALIGNED_SIZE))\" \"$REM/peer_mw_trans$IDX\"\n\n\tif [[ $MW_SIZE -ne $MW_ALIGNED_SIZE ]]; then\n\t\techo \"MW $IDX size aligned to $MW_ALIGNED_SIZE\"\n\tfi\n}\n\nfunction write_mw()\n{\n\tsplit_remote $2\n\n\tif [[ \"$REMOTE\" != \"\" ]]; then\n\t\tssh \"$REMOTE\" \\\n\t\t\tdd if=/dev/urandom \"of=$VPATH\" 2> /dev/null || true\n\telse\n\t\tdd if=/dev/urandom \"of=$VPATH\" 2> /dev/null || true\n\tfi\n}\n\nfunction mw_check()\n{\n\tIDX=$1\n\tLOC=$2\n\tREM=$3\n\n\twrite_mw \"$LOC/mw$IDX\"\n\n\tsplit_remote \"$LOC/mw$IDX\"\n\tif [[ \"$REMOTE\" == \"\" ]]; then\n\t\tA=$VPATH\n\telse\n\t\tA=/tmp/ntb_test.$$.A\n\t\tssh \"$REMOTE\" cat \"$VPATH\" > \"$A\"\n\tfi\n\n\tsplit_remote \"$REM/peer_mw$IDX\"\n\tif [[ \"$REMOTE\" == \"\" ]]; then\n\t\tB=$VPATH\n\telse\n\t\tB=/tmp/ntb_test.$$.B\n\t\tssh \"$REMOTE\" cat \"$VPATH\" > \"$B\"\n\tfi\n\n\tcmp -n $MW_ALIGNED_SIZE \"$A\" \"$B\"\n\tif [[ $? != 0 ]]; then\n\t\techo \"Memory window $MW did not match!\" >&2\n\tfi\n\n\tif [[ \"$A\" == \"/tmp/*\" ]]; then\n\t\trm \"$A\"\n\tfi\n\n\tif [[ \"$B\" == \"/tmp/*\" ]]; then\n\t\trm \"$B\"\n\tfi\n}\n\nfunction mw_free()\n{\n\tIDX=$1\n\tLOC=$2\n\tREM=$3\n\n\twrite_file \"$MW_DMA_ADDR:0\" \"$REM/peer_mw_trans$IDX\"\n\n\twrite_file 0 \"$LOC/mw_trans$IDX\"\n}\n\nfunction mw_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\tCNT=$(get_files_count \"mw_trans\" \"$LOC\")\n\n\tfor ((i = 0; i < $CNT; i++)); do\n\t\techo \"Running mw$i tests on: $(subdirname $LOC) / \" \\\n\t\t     \"$(subdirname $REM)\"\n\n\t\tmw_alloc $i $LOC $REM\n\n\t\tmw_check $i $LOC $REM\n\n\t\tmw_free $i $LOC  $REM\n\n\t\techo \"  Passed\"\n\tdone\n\n}\n\nfunction pingpong_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\techo \"Running ping pong tests on: $(basename $LOC) / $(basename $REM)\"\n\n\tLOC_START=$(read_file \"$LOC/count\")\n\tREM_START=$(read_file \"$REM/count\")\n\n\tsleep 7\n\n\tLOC_END=$(read_file \"$LOC/count\")\n\tREM_END=$(read_file \"$REM/count\")\n\n\tif [[ $LOC_START == $LOC_END ]] || [[ $REM_START == $REM_END ]]; then\n\t\techo \"Ping pong counter not incrementing!\" >&2\n\t\texit 1\n\tfi\n\n\techo \"  Passed\"\n}\n\nfunction msi_test()\n{\n\tLOC=$1\n\tREM=$2\n\n\twrite_file 1 $LOC/ready\n\n\techo \"Running MSI interrupt tests on: $(subdirname $LOC) / $(subdirname $REM)\"\n\n\tCNT=$(read_file \"$LOC/count\")\n\tfor ((i = 0; i < $CNT; i++)); do\n\t\tSTART=$(read_file $REM/../irq${i}_occurrences)\n\t\twrite_file $i $LOC/trigger\n\t\tEND=$(read_file $REM/../irq${i}_occurrences)\n\n\t\tif [[ $(($END - $START)) != 1 ]]; then\n\t\t\techo \"MSI did not trigger the interrupt on the remote side!\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo \"  Passed\"\n}\n\nfunction perf_test()\n{\n\tUSE_DMA=$1\n\n\tif [[ $USE_DMA == \"1\" ]]; then\n\t\tWITH=\"with\"\n\telse\n\t\tWITH=\"without\"\n\tfi\n\n\t_modprobe ntb_perf total_order=$PERF_RUN_ORDER \\\n\t\tmax_mw_size=$MAX_MW_SIZE use_dma=$USE_DMA\n\n\techo \"Running local perf test $WITH DMA\"\n\twrite_file \"$LOCAL_PIDX\" \"$LOCAL_PERF/run\"\n\techo -n \"  \"\n\tread_file \"$LOCAL_PERF/run\"\n\techo \"  Passed\"\n\n\techo \"Running remote perf test $WITH DMA\"\n\twrite_file \"$REMOTE_PIDX\" \"$REMOTE_PERF/run\"\n\techo -n \"  \"\n\tread_file \"$REMOTE_PERF/run\"\n\techo \"  Passed\"\n\n\t_modprobe -r ntb_perf\n}\n\nfunction ntb_tool_tests()\n{\n\tLOCAL_TOOL=\"$DEBUGFS/ntb_tool/$LOCAL_DEV\"\n\tREMOTE_TOOL=\"$REMOTE_HOST:$DEBUGFS/ntb_tool/$REMOTE_DEV\"\n\n\techo \"Starting ntb_tool tests...\"\n\n\t_modprobe ntb_tool\n\n\tport_test \"$LOCAL_TOOL\" \"$REMOTE_TOOL\"\n\n\tLOCAL_PEER_TOOL=\"$LOCAL_TOOL/peer$LOCAL_PIDX\"\n\tREMOTE_PEER_TOOL=\"$REMOTE_TOOL/peer$REMOTE_PIDX\"\n\n\tlink_test \"$LOCAL_PEER_TOOL\" \"$REMOTE_PEER_TOOL\"\n\tlink_test \"$REMOTE_PEER_TOOL\" \"$LOCAL_PEER_TOOL\"\n\n\t#Ensure the link is up on both sides before continuing\n\twrite_file \"Y\" \"$LOCAL_PEER_TOOL/link_event\"\n\twrite_file \"Y\" \"$REMOTE_PEER_TOOL/link_event\"\n\n\tdoorbell_test \"$LOCAL_TOOL\" \"$REMOTE_TOOL\"\n\tdoorbell_test \"$REMOTE_TOOL\" \"$LOCAL_TOOL\"\n\n\tscratchpad_test \"$LOCAL_PEER_TOOL\" \"$REMOTE_PEER_TOOL\"\n\tscratchpad_test \"$REMOTE_PEER_TOOL\" \"$LOCAL_PEER_TOOL\"\n\n\tmessage_test \"$LOCAL_PEER_TOOL\" \"$REMOTE_PEER_TOOL\"\n\tmessage_test \"$REMOTE_PEER_TOOL\" \"$LOCAL_PEER_TOOL\"\n\n\tmw_test \"$LOCAL_PEER_TOOL\" \"$REMOTE_PEER_TOOL\"\n\tmw_test \"$REMOTE_PEER_TOOL\" \"$LOCAL_PEER_TOOL\"\n\n\t_modprobe -r ntb_tool\n}\n\nfunction ntb_pingpong_tests()\n{\n\tLOCAL_PP=\"$DEBUGFS/ntb_pingpong/$LOCAL_DEV\"\n\tREMOTE_PP=\"$REMOTE_HOST:$DEBUGFS/ntb_pingpong/$REMOTE_DEV\"\n\n\techo \"Starting ntb_pingpong tests...\"\n\n\t_modprobe ntb_pingpong\n\n\tpingpong_test $LOCAL_PP $REMOTE_PP\n\n\t_modprobe -r ntb_pingpong\n}\n\nfunction ntb_msi_tests()\n{\n\tLOCAL_MSI=\"$DEBUGFS/ntb_msi_test/$LOCAL_DEV\"\n\tREMOTE_MSI=\"$REMOTE_HOST:$DEBUGFS/ntb_msi_test/$REMOTE_DEV\"\n\n\techo \"Starting ntb_msi_test tests...\"\n\n\tif ! _modprobe ntb_msi_test 2> /dev/null; then\n\t\techo \"  Not doing MSI tests seeing the module is not available.\"\n\t\treturn\n\tfi\n\n\tport_test $LOCAL_MSI $REMOTE_MSI\n\n\tLOCAL_PEER=\"$LOCAL_MSI/peer$LOCAL_PIDX\"\n\tREMOTE_PEER=\"$REMOTE_MSI/peer$REMOTE_PIDX\"\n\n\tmsi_test $LOCAL_PEER $REMOTE_PEER\n\tmsi_test $REMOTE_PEER $LOCAL_PEER\n\n\t_modprobe -r ntb_msi_test\n}\n\nfunction ntb_perf_tests()\n{\n\tLOCAL_PERF=\"$DEBUGFS/ntb_perf/$LOCAL_DEV\"\n\tREMOTE_PERF=\"$REMOTE_HOST:$DEBUGFS/ntb_perf/$REMOTE_DEV\"\n\n\techo \"Starting ntb_perf tests...\"\n\n\tperf_test 0\n\n\tif [[ $RUN_DMA_TESTS ]]; then\n\t\tperf_test 1\n\tfi\n}\n\nfunction cleanup()\n{\n\tset +e\n\t_modprobe -r ntb_tool 2> /dev/null\n\t_modprobe -r ntb_perf 2> /dev/null\n\t_modprobe -r ntb_pingpong 2> /dev/null\n\t_modprobe -r ntb_transport 2> /dev/null\n\t_modprobe -r ntb_msi_test 2> /dev/null\n\tset -e\n}\n\ncleanup\n\nif ! [[ $$DONT_CLEANUP ]]; then\n\ttrap cleanup EXIT\nfi\n\nif [ \"$(id -u)\" != \"0\" ]; then\n\techo \"This script must be run as root\" 1>&2\n\texit 1\nfi\n\nif [[ \"$LIST_DEVS\" == TRUE ]]; then\n\techo \"Local Devices:\"\n\tls -1 /sys/bus/ntb/devices\n\techo\n\n\tif [[ \"$REMOTE_HOST\" != \"\" ]]; then\n\t\techo \"Remote Devices:\"\n\t\tssh $REMOTE_HOST ls -1 /sys/bus/ntb/devices\n\tfi\n\n\texit 0\nfi\n\nif [[ \"$LOCAL_DEV\" == $\"\" ]] || [[ \"$REMOTE_DEV\" == $\"\" ]]; then\n\tshow_help\n\texit 1\nfi\n\nntb_tool_tests\necho\nntb_pingpong_tests\necho\nntb_msi_tests\necho\nntb_perf_tests\necho\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}