{
  "module_name": "vdso_test_abi.c",
  "hash_id": "82e729c1fd6c074d3958362e10cecd6cedb0552d77ab31d59286557642ea8852",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/vDSO/vdso_test_abi.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n#include <elf.h>\n#include <stdio.h>\n#include <time.h>\n#include <sys/auxv.h>\n#include <sys/time.h>\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <sys/syscall.h>\n\n#include \"../kselftest.h\"\n#include \"vdso_config.h\"\n\nextern void *vdso_sym(const char *version, const char *name);\nextern void vdso_init_from_sysinfo_ehdr(uintptr_t base);\nextern void vdso_init_from_auxv(void *auxv);\n\nstatic const char *version;\nstatic const char **name;\n\ntypedef long (*vdso_gettimeofday_t)(struct timeval *tv, struct timezone *tz);\ntypedef long (*vdso_clock_gettime_t)(clockid_t clk_id, struct timespec *ts);\ntypedef long (*vdso_clock_getres_t)(clockid_t clk_id, struct timespec *ts);\ntypedef time_t (*vdso_time_t)(time_t *t);\n\n#define VDSO_TEST_PASS_MSG()\t\"\\n%s(): PASS\\n\", __func__\n#define VDSO_TEST_FAIL_MSG(x)\t\"\\n%s(): %s FAIL\\n\", __func__, x\n#define VDSO_TEST_SKIP_MSG(x)\t\"\\n%s(): SKIP: Could not find %s\\n\", __func__, x\n\nstatic void vdso_test_gettimeofday(void)\n{\n\t \n\tvdso_gettimeofday_t vdso_gettimeofday =\n\t\t(vdso_gettimeofday_t)vdso_sym(version, name[0]);\n\n\tif (!vdso_gettimeofday) {\n\t\tksft_test_result_skip(VDSO_TEST_SKIP_MSG(name[0]));\n\t\treturn;\n\t}\n\n\tstruct timeval tv;\n\tlong ret = vdso_gettimeofday(&tv, 0);\n\n\tif (ret == 0) {\n\t\tksft_print_msg(\"The time is %lld.%06lld\\n\",\n\t\t\t       (long long)tv.tv_sec, (long long)tv.tv_usec);\n\t\tksft_test_result_pass(VDSO_TEST_PASS_MSG());\n\t} else {\n\t\tksft_test_result_fail(VDSO_TEST_FAIL_MSG(name[0]));\n\t}\n}\n\nstatic void vdso_test_clock_gettime(clockid_t clk_id)\n{\n\t \n\tvdso_clock_gettime_t vdso_clock_gettime =\n\t\t(vdso_clock_gettime_t)vdso_sym(version, name[1]);\n\n\tif (!vdso_clock_gettime) {\n\t\tksft_test_result_skip(VDSO_TEST_SKIP_MSG(name[1]));\n\t\treturn;\n\t}\n\n\tstruct timespec ts;\n\tlong ret = vdso_clock_gettime(clk_id, &ts);\n\n\tif (ret == 0) {\n\t\tksft_print_msg(\"The time is %lld.%06lld\\n\",\n\t\t\t       (long long)ts.tv_sec, (long long)ts.tv_nsec);\n\t\tksft_test_result_pass(VDSO_TEST_PASS_MSG());\n\t} else {\n\t\tksft_test_result_fail(VDSO_TEST_FAIL_MSG(name[1]));\n\t}\n}\n\nstatic void vdso_test_time(void)\n{\n\t \n\tvdso_time_t vdso_time =\n\t\t(vdso_time_t)vdso_sym(version, name[2]);\n\n\tif (!vdso_time) {\n\t\tksft_test_result_skip(VDSO_TEST_SKIP_MSG(name[2]));\n\t\treturn;\n\t}\n\n\tlong ret = vdso_time(NULL);\n\n\tif (ret > 0) {\n\t\tksft_print_msg(\"The time in hours since January 1, 1970 is %lld\\n\",\n\t\t\t\t(long long)(ret / 3600));\n\t\tksft_test_result_pass(VDSO_TEST_PASS_MSG());\n\t} else {\n\t\tksft_test_result_fail(VDSO_TEST_FAIL_MSG(name[2]));\n\t}\n}\n\nstatic void vdso_test_clock_getres(clockid_t clk_id)\n{\n\tint clock_getres_fail = 0;\n\n\t \n\tvdso_clock_getres_t vdso_clock_getres =\n\t\t(vdso_clock_getres_t)vdso_sym(version, name[3]);\n\n\tif (!vdso_clock_getres) {\n\t\tksft_test_result_skip(VDSO_TEST_SKIP_MSG(name[3]));\n\t\treturn;\n\t}\n\n\tstruct timespec ts, sys_ts;\n\tlong ret = vdso_clock_getres(clk_id, &ts);\n\n\tif (ret == 0) {\n\t\tksft_print_msg(\"The vdso resolution is %lld %lld\\n\",\n\t\t\t       (long long)ts.tv_sec, (long long)ts.tv_nsec);\n\t} else {\n\t\tclock_getres_fail++;\n\t}\n\n\tret = syscall(SYS_clock_getres, clk_id, &sys_ts);\n\n\tksft_print_msg(\"The syscall resolution is %lld %lld\\n\",\n\t\t\t(long long)sys_ts.tv_sec, (long long)sys_ts.tv_nsec);\n\n\tif ((sys_ts.tv_sec != ts.tv_sec) || (sys_ts.tv_nsec != ts.tv_nsec))\n\t\tclock_getres_fail++;\n\n\tif (clock_getres_fail > 0) {\n\t\tksft_test_result_fail(VDSO_TEST_FAIL_MSG(name[3]));\n\t} else {\n\t\tksft_test_result_pass(VDSO_TEST_PASS_MSG());\n\t}\n}\n\nconst char *vdso_clock_name[12] = {\n\t\"CLOCK_REALTIME\",\n\t\"CLOCK_MONOTONIC\",\n\t\"CLOCK_PROCESS_CPUTIME_ID\",\n\t\"CLOCK_THREAD_CPUTIME_ID\",\n\t\"CLOCK_MONOTONIC_RAW\",\n\t\"CLOCK_REALTIME_COARSE\",\n\t\"CLOCK_MONOTONIC_COARSE\",\n\t\"CLOCK_BOOTTIME\",\n\t\"CLOCK_REALTIME_ALARM\",\n\t\"CLOCK_BOOTTIME_ALARM\",\n\t\"CLOCK_SGI_CYCLE\",\n\t\"CLOCK_TAI\",\n};\n\n \nstatic inline void vdso_test_clock(clockid_t clock_id)\n{\n\tksft_print_msg(\"\\nclock_id: %s\\n\", vdso_clock_name[clock_id]);\n\n\tvdso_test_clock_gettime(clock_id);\n\n\tvdso_test_clock_getres(clock_id);\n}\n\n#define VDSO_TEST_PLAN\t16\n\nint main(int argc, char **argv)\n{\n\tunsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR);\n\n\tksft_print_header();\n\tksft_set_plan(VDSO_TEST_PLAN);\n\n\tif (!sysinfo_ehdr) {\n\t\tprintf(\"AT_SYSINFO_EHDR is not present!\\n\");\n\t\treturn KSFT_SKIP;\n\t}\n\n\tversion = versions[VDSO_VERSION];\n\tname = (const char **)&names[VDSO_NAMES];\n\n\tprintf(\"[vDSO kselftest] VDSO_VERSION: %s\\n\", version);\n\n\tvdso_init_from_sysinfo_ehdr(getauxval(AT_SYSINFO_EHDR));\n\n\tvdso_test_gettimeofday();\n\n#if _POSIX_TIMERS > 0\n\n#ifdef CLOCK_REALTIME\n\tvdso_test_clock(CLOCK_REALTIME);\n#endif\n\n#ifdef CLOCK_BOOTTIME\n\tvdso_test_clock(CLOCK_BOOTTIME);\n#endif\n\n#ifdef CLOCK_TAI\n\tvdso_test_clock(CLOCK_TAI);\n#endif\n\n#ifdef CLOCK_REALTIME_COARSE\n\tvdso_test_clock(CLOCK_REALTIME_COARSE);\n#endif\n\n#ifdef CLOCK_MONOTONIC\n\tvdso_test_clock(CLOCK_MONOTONIC);\n#endif\n\n#ifdef CLOCK_MONOTONIC_RAW\n\tvdso_test_clock(CLOCK_MONOTONIC_RAW);\n#endif\n\n#ifdef CLOCK_MONOTONIC_COARSE\n\tvdso_test_clock(CLOCK_MONOTONIC_COARSE);\n#endif\n\n#endif\n\n\tvdso_test_time();\n\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}