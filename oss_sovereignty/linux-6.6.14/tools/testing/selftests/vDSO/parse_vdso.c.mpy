{
  "module_name": "parse_vdso.c",
  "hash_id": "8fbb76d8ed5e23308dd272d1a135da9110c991a1bc5ff4f9c0faa1ac767620f9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/vDSO/parse_vdso.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <limits.h>\n#include <elf.h>\n\n#include \"parse_vdso.h\"\n\n \n#ifndef ELF_BITS\n# if ULONG_MAX > 0xffffffffUL\n#  define ELF_BITS 64\n# else\n#  define ELF_BITS 32\n# endif\n#endif\n\n#define ELF_BITS_XFORM2(bits, x) Elf##bits##_##x\n#define ELF_BITS_XFORM(bits, x) ELF_BITS_XFORM2(bits, x)\n#define ELF(x) ELF_BITS_XFORM(ELF_BITS, x)\n\nstatic struct vdso_info\n{\n\tbool valid;\n\n\t \n\tuintptr_t load_addr;\n\tuintptr_t load_offset;   \n\n\t \n\tELF(Sym) *symtab;\n\tconst char *symstrings;\n\tELF(Word) *bucket, *chain;\n\tELF(Word) nbucket, nchain;\n\n\t \n\tELF(Versym) *versym;\n\tELF(Verdef) *verdef;\n} vdso_info;\n\n \nstatic unsigned long elf_hash(const unsigned char *name)\n{\n\tunsigned long h = 0, g;\n\twhile (*name)\n\t{\n\t\th = (h << 4) + *name++;\n\t\tif (g = h & 0xf0000000)\n\t\t\th ^= g >> 24;\n\t\th &= ~g;\n\t}\n\treturn h;\n}\n\nvoid vdso_init_from_sysinfo_ehdr(uintptr_t base)\n{\n\tsize_t i;\n\tbool found_vaddr = false;\n\n\tvdso_info.valid = false;\n\n\tvdso_info.load_addr = base;\n\n\tELF(Ehdr) *hdr = (ELF(Ehdr)*)base;\n\tif (hdr->e_ident[EI_CLASS] !=\n\t    (ELF_BITS == 32 ? ELFCLASS32 : ELFCLASS64)) {\n\t\treturn;   \n\t}\n\n\tELF(Phdr) *pt = (ELF(Phdr)*)(vdso_info.load_addr + hdr->e_phoff);\n\tELF(Dyn) *dyn = 0;\n\n\t \n\tfor (i = 0; i < hdr->e_phnum; i++)\n\t{\n\t\tif (pt[i].p_type == PT_LOAD && !found_vaddr) {\n\t\t\tfound_vaddr = true;\n\t\t\tvdso_info.load_offset =\tbase\n\t\t\t\t+ (uintptr_t)pt[i].p_offset\n\t\t\t\t- (uintptr_t)pt[i].p_vaddr;\n\t\t} else if (pt[i].p_type == PT_DYNAMIC) {\n\t\t\tdyn = (ELF(Dyn)*)(base + pt[i].p_offset);\n\t\t}\n\t}\n\n\tif (!found_vaddr || !dyn)\n\t\treturn;   \n\n\t \n\tELF(Word) *hash = 0;\n\tvdso_info.symstrings = 0;\n\tvdso_info.symtab = 0;\n\tvdso_info.versym = 0;\n\tvdso_info.verdef = 0;\n\tfor (i = 0; dyn[i].d_tag != DT_NULL; i++) {\n\t\tswitch (dyn[i].d_tag) {\n\t\tcase DT_STRTAB:\n\t\t\tvdso_info.symstrings = (const char *)\n\t\t\t\t((uintptr_t)dyn[i].d_un.d_ptr\n\t\t\t\t + vdso_info.load_offset);\n\t\t\tbreak;\n\t\tcase DT_SYMTAB:\n\t\t\tvdso_info.symtab = (ELF(Sym) *)\n\t\t\t\t((uintptr_t)dyn[i].d_un.d_ptr\n\t\t\t\t + vdso_info.load_offset);\n\t\t\tbreak;\n\t\tcase DT_HASH:\n\t\t\thash = (ELF(Word) *)\n\t\t\t\t((uintptr_t)dyn[i].d_un.d_ptr\n\t\t\t\t + vdso_info.load_offset);\n\t\t\tbreak;\n\t\tcase DT_VERSYM:\n\t\t\tvdso_info.versym = (ELF(Versym) *)\n\t\t\t\t((uintptr_t)dyn[i].d_un.d_ptr\n\t\t\t\t + vdso_info.load_offset);\n\t\t\tbreak;\n\t\tcase DT_VERDEF:\n\t\t\tvdso_info.verdef = (ELF(Verdef) *)\n\t\t\t\t((uintptr_t)dyn[i].d_un.d_ptr\n\t\t\t\t + vdso_info.load_offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!vdso_info.symstrings || !vdso_info.symtab || !hash)\n\t\treturn;   \n\n\tif (!vdso_info.verdef)\n\t\tvdso_info.versym = 0;\n\n\t \n\tvdso_info.nbucket = hash[0];\n\tvdso_info.nchain = hash[1];\n\tvdso_info.bucket = &hash[2];\n\tvdso_info.chain = &hash[vdso_info.nbucket + 2];\n\n\t \n\tvdso_info.valid = true;\n}\n\nstatic bool vdso_match_version(ELF(Versym) ver,\n\t\t\t       const char *name, ELF(Word) hash)\n{\n\t \n\n\t \n\tver &= 0x7fff;   \n\tELF(Verdef) *def = vdso_info.verdef;\n\twhile(true) {\n\t\tif ((def->vd_flags & VER_FLG_BASE) == 0\n\t\t    && (def->vd_ndx & 0x7fff) == ver)\n\t\t\tbreak;\n\n\t\tif (def->vd_next == 0)\n\t\t\treturn false;   \n\n\t\tdef = (ELF(Verdef) *)((char *)def + def->vd_next);\n\t}\n\n\t \n\tELF(Verdaux) *aux = (ELF(Verdaux)*)((char *)def + def->vd_aux);\n\treturn def->vd_hash == hash\n\t\t&& !strcmp(name, vdso_info.symstrings + aux->vda_name);\n}\n\nvoid *vdso_sym(const char *version, const char *name)\n{\n\tunsigned long ver_hash;\n\tif (!vdso_info.valid)\n\t\treturn 0;\n\n\tver_hash = elf_hash(version);\n\tELF(Word) chain = vdso_info.bucket[elf_hash(name) % vdso_info.nbucket];\n\n\tfor (; chain != STN_UNDEF; chain = vdso_info.chain[chain]) {\n\t\tELF(Sym) *sym = &vdso_info.symtab[chain];\n\n\t\t \n\t\tif (ELF64_ST_TYPE(sym->st_info) != STT_FUNC)\n\t\t\tcontinue;\n\t\tif (ELF64_ST_BIND(sym->st_info) != STB_GLOBAL &&\n\t\t    ELF64_ST_BIND(sym->st_info) != STB_WEAK)\n\t\t\tcontinue;\n\t\tif (sym->st_shndx == SHN_UNDEF)\n\t\t\tcontinue;\n\t\tif (strcmp(name, vdso_info.symstrings + sym->st_name))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vdso_info.versym\n\t\t    && !vdso_match_version(vdso_info.versym[chain],\n\t\t\t\t\t   version, ver_hash))\n\t\t\tcontinue;\n\n\t\treturn (void *)(vdso_info.load_offset + sym->st_value);\n\t}\n\n\treturn 0;\n}\n\nvoid vdso_init_from_auxv(void *auxv)\n{\n\tELF(auxv_t) *elf_auxv = auxv;\n\tfor (int i = 0; elf_auxv[i].a_type != AT_NULL; i++)\n\t{\n\t\tif (elf_auxv[i].a_type == AT_SYSINFO_EHDR) {\n\t\t\tvdso_init_from_sysinfo_ehdr(elf_auxv[i].a_un.a_val);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvdso_info.valid = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}