{
  "module_name": "vdso_test_correctness.c",
  "hash_id": "8cc05ed0bec58c0c5a966360c604a38f2720ef731b9b896d1afb8e88925a4ff0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/vDSO/vdso_test_correctness.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <errno.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#include \"vdso_config.h\"\n#include \"../kselftest.h\"\n\nstatic const char **name;\n\n#ifndef SYS_getcpu\n# ifdef __x86_64__\n#  define SYS_getcpu 309\n# else\n#  define SYS_getcpu 318\n# endif\n#endif\n\n#ifndef __NR_clock_gettime64\n#define __NR_clock_gettime64\t403\n#endif\n\n#ifndef __kernel_timespec\nstruct __kernel_timespec {\n\tlong long\ttv_sec;\n\tlong long\ttv_nsec;\n};\n#endif\n\n \n#define MAPS_LINE_LEN 128\n\nint nerrs = 0;\n\ntypedef int (*vgettime_t)(clockid_t, struct timespec *);\n\nvgettime_t vdso_clock_gettime;\n\ntypedef int (*vgettime64_t)(clockid_t, struct __kernel_timespec *);\n\nvgettime64_t vdso_clock_gettime64;\n\ntypedef long (*vgtod_t)(struct timeval *tv, struct timezone *tz);\n\nvgtod_t vdso_gettimeofday;\n\ntypedef long (*getcpu_t)(unsigned *, unsigned *, void *);\n\ngetcpu_t vgetcpu;\ngetcpu_t vdso_getcpu;\n\nstatic void *vsyscall_getcpu(void)\n{\n#ifdef __x86_64__\n\tFILE *maps;\n\tchar line[MAPS_LINE_LEN];\n\tbool found = false;\n\n\tmaps = fopen(\"/proc/self/maps\", \"r\");\n\tif (!maps)  \n\t\treturn NULL;\n\n\twhile (fgets(line, MAPS_LINE_LEN, maps)) {\n\t\tchar r, x;\n\t\tvoid *start, *end;\n\t\tchar name[MAPS_LINE_LEN];\n\n\t\t \n\t\tif (sscanf(line, \"%p-%p %c-%cp %*x %*x:%*x %*u %s\",\n\t\t\t   &start, &end, &r, &x, name) != 5)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, \"[vsyscall]\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tfclose(maps);\n\n\tif (!found) {\n\t\tprintf(\"Warning: failed to find vsyscall getcpu\\n\");\n\t\treturn NULL;\n\t}\n\treturn (void *) (0xffffffffff600800);\n#else\n\treturn NULL;\n#endif\n}\n\n\nstatic void fill_function_pointers()\n{\n\tvoid *vdso = dlopen(\"linux-vdso.so.1\",\n\t\t\t    RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso)\n\t\tvdso = dlopen(\"linux-gate.so.1\",\n\t\t\t      RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso) {\n\t\tprintf(\"[WARN]\\tfailed to find vDSO\\n\");\n\t\treturn;\n\t}\n\n\tvdso_getcpu = (getcpu_t)dlsym(vdso, name[4]);\n\tif (!vdso_getcpu)\n\t\tprintf(\"Warning: failed to find getcpu in vDSO\\n\");\n\n\tvgetcpu = (getcpu_t) vsyscall_getcpu();\n\n\tvdso_clock_gettime = (vgettime_t)dlsym(vdso, name[1]);\n\tif (!vdso_clock_gettime)\n\t\tprintf(\"Warning: failed to find clock_gettime in vDSO\\n\");\n\n#if defined(VDSO_32BIT)\n\tvdso_clock_gettime64 = (vgettime64_t)dlsym(vdso, name[5]);\n\tif (!vdso_clock_gettime64)\n\t\tprintf(\"Warning: failed to find clock_gettime64 in vDSO\\n\");\n#endif\n\n\tvdso_gettimeofday = (vgtod_t)dlsym(vdso, name[0]);\n\tif (!vdso_gettimeofday)\n\t\tprintf(\"Warning: failed to find gettimeofday in vDSO\\n\");\n\n}\n\nstatic long sys_getcpu(unsigned * cpu, unsigned * node,\n\t\t       void* cache)\n{\n\treturn syscall(__NR_getcpu, cpu, node, cache);\n}\n\nstatic inline int sys_clock_gettime(clockid_t id, struct timespec *ts)\n{\n\treturn syscall(__NR_clock_gettime, id, ts);\n}\n\nstatic inline int sys_clock_gettime64(clockid_t id, struct __kernel_timespec *ts)\n{\n\treturn syscall(__NR_clock_gettime64, id, ts);\n}\n\nstatic inline int sys_gettimeofday(struct timeval *tv, struct timezone *tz)\n{\n\treturn syscall(__NR_gettimeofday, tv, tz);\n}\n\nstatic void test_getcpu(void)\n{\n\tprintf(\"[RUN]\\tTesting getcpu...\\n\");\n\n\tfor (int cpu = 0; ; cpu++) {\n\t\tcpu_set_t cpuset;\n\t\tCPU_ZERO(&cpuset);\n\t\tCPU_SET(cpu, &cpuset);\n\t\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0)\n\t\t\treturn;\n\n\t\tunsigned cpu_sys, cpu_vdso, cpu_vsys,\n\t\t\tnode_sys, node_vdso, node_vsys;\n\t\tlong ret_sys, ret_vdso = 1, ret_vsys = 1;\n\t\tunsigned node;\n\n\t\tret_sys = sys_getcpu(&cpu_sys, &node_sys, 0);\n\t\tif (vdso_getcpu)\n\t\t\tret_vdso = vdso_getcpu(&cpu_vdso, &node_vdso, 0);\n\t\tif (vgetcpu)\n\t\t\tret_vsys = vgetcpu(&cpu_vsys, &node_vsys, 0);\n\n\t\tif (!ret_sys)\n\t\t\tnode = node_sys;\n\t\telse if (!ret_vdso)\n\t\t\tnode = node_vdso;\n\t\telse if (!ret_vsys)\n\t\t\tnode = node_vsys;\n\n\t\tbool ok = true;\n\t\tif (!ret_sys && (cpu_sys != cpu || node_sys != node))\n\t\t\tok = false;\n\t\tif (!ret_vdso && (cpu_vdso != cpu || node_vdso != node))\n\t\t\tok = false;\n\t\tif (!ret_vsys && (cpu_vsys != cpu || node_vsys != node))\n\t\t\tok = false;\n\n\t\tprintf(\"[%s]\\tCPU %u:\", ok ? \"OK\" : \"FAIL\", cpu);\n\t\tif (!ret_sys)\n\t\t\tprintf(\" syscall: cpu %u, node %u\", cpu_sys, node_sys);\n\t\tif (!ret_vdso)\n\t\t\tprintf(\" vdso: cpu %u, node %u\", cpu_vdso, node_vdso);\n\t\tif (!ret_vsys)\n\t\t\tprintf(\" vsyscall: cpu %u, node %u\", cpu_vsys,\n\t\t\t       node_vsys);\n\t\tprintf(\"\\n\");\n\n\t\tif (!ok)\n\t\t\tnerrs++;\n\t}\n}\n\nstatic bool ts_leq(const struct timespec *a, const struct timespec *b)\n{\n\tif (a->tv_sec != b->tv_sec)\n\t\treturn a->tv_sec < b->tv_sec;\n\telse\n\t\treturn a->tv_nsec <= b->tv_nsec;\n}\n\nstatic bool ts64_leq(const struct __kernel_timespec *a,\n\t\t     const struct __kernel_timespec *b)\n{\n\tif (a->tv_sec != b->tv_sec)\n\t\treturn a->tv_sec < b->tv_sec;\n\telse\n\t\treturn a->tv_nsec <= b->tv_nsec;\n}\n\nstatic bool tv_leq(const struct timeval *a, const struct timeval *b)\n{\n\tif (a->tv_sec != b->tv_sec)\n\t\treturn a->tv_sec < b->tv_sec;\n\telse\n\t\treturn a->tv_usec <= b->tv_usec;\n}\n\nstatic char const * const clocknames[] = {\n\t[0] = \"CLOCK_REALTIME\",\n\t[1] = \"CLOCK_MONOTONIC\",\n\t[2] = \"CLOCK_PROCESS_CPUTIME_ID\",\n\t[3] = \"CLOCK_THREAD_CPUTIME_ID\",\n\t[4] = \"CLOCK_MONOTONIC_RAW\",\n\t[5] = \"CLOCK_REALTIME_COARSE\",\n\t[6] = \"CLOCK_MONOTONIC_COARSE\",\n\t[7] = \"CLOCK_BOOTTIME\",\n\t[8] = \"CLOCK_REALTIME_ALARM\",\n\t[9] = \"CLOCK_BOOTTIME_ALARM\",\n\t[10] = \"CLOCK_SGI_CYCLE\",\n\t[11] = \"CLOCK_TAI\",\n};\n\nstatic void test_one_clock_gettime(int clock, const char *name)\n{\n\tstruct timespec start, vdso, end;\n\tint vdso_ret, end_ret;\n\n\tprintf(\"[RUN]\\tTesting clock_gettime for clock %s (%d)...\\n\", name, clock);\n\n\tif (sys_clock_gettime(clock, &start) < 0) {\n\t\tif (errno == EINVAL) {\n\t\t\tvdso_ret = vdso_clock_gettime(clock, &vdso);\n\t\t\tif (vdso_ret == -EINVAL) {\n\t\t\t\tprintf(\"[OK]\\tNo such clock.\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"[FAIL]\\tNo such clock, but __vdso_clock_gettime returned %d\\n\", vdso_ret);\n\t\t\t\tnerrs++;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"[WARN]\\t clock_gettime(%d) syscall returned error %d\\n\", clock, errno);\n\t\t}\n\t\treturn;\n\t}\n\n\tvdso_ret = vdso_clock_gettime(clock, &vdso);\n\tend_ret = sys_clock_gettime(clock, &end);\n\n\tif (vdso_ret != 0 || end_ret != 0) {\n\t\tprintf(\"[FAIL]\\tvDSO returned %d, syscall errno=%d\\n\",\n\t\t       vdso_ret, errno);\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tprintf(\"\\t%llu.%09ld %llu.%09ld %llu.%09ld\\n\",\n\t       (unsigned long long)start.tv_sec, start.tv_nsec,\n\t       (unsigned long long)vdso.tv_sec, vdso.tv_nsec,\n\t       (unsigned long long)end.tv_sec, end.tv_nsec);\n\n\tif (!ts_leq(&start, &vdso) || !ts_leq(&vdso, &end)) {\n\t\tprintf(\"[FAIL]\\tTimes are out of sequence\\n\");\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tprintf(\"[OK]\\tTest Passed.\\n\");\n}\n\nstatic void test_clock_gettime(void)\n{\n\tif (!vdso_clock_gettime) {\n\t\tprintf(\"[SKIP]\\tNo vDSO, so skipping clock_gettime() tests\\n\");\n\t\treturn;\n\t}\n\n\tfor (int clock = 0; clock < ARRAY_SIZE(clocknames); clock++)\n\t\ttest_one_clock_gettime(clock, clocknames[clock]);\n\n\t \n\ttest_one_clock_gettime(-1, \"invalid\");\n\ttest_one_clock_gettime(INT_MIN, \"invalid\");\n\ttest_one_clock_gettime(INT_MAX, \"invalid\");\n}\n\nstatic void test_one_clock_gettime64(int clock, const char *name)\n{\n\tstruct __kernel_timespec start, vdso, end;\n\tint vdso_ret, end_ret;\n\n\tprintf(\"[RUN]\\tTesting clock_gettime64 for clock %s (%d)...\\n\", name, clock);\n\n\tif (sys_clock_gettime64(clock, &start) < 0) {\n\t\tif (errno == EINVAL) {\n\t\t\tvdso_ret = vdso_clock_gettime64(clock, &vdso);\n\t\t\tif (vdso_ret == -EINVAL) {\n\t\t\t\tprintf(\"[OK]\\tNo such clock.\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"[FAIL]\\tNo such clock, but __vdso_clock_gettime64 returned %d\\n\", vdso_ret);\n\t\t\t\tnerrs++;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"[WARN]\\t clock_gettime64(%d) syscall returned error %d\\n\", clock, errno);\n\t\t}\n\t\treturn;\n\t}\n\n\tvdso_ret = vdso_clock_gettime64(clock, &vdso);\n\tend_ret = sys_clock_gettime64(clock, &end);\n\n\tif (vdso_ret != 0 || end_ret != 0) {\n\t\tprintf(\"[FAIL]\\tvDSO returned %d, syscall errno=%d\\n\",\n\t\t       vdso_ret, errno);\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tprintf(\"\\t%llu.%09lld %llu.%09lld %llu.%09lld\\n\",\n\t       (unsigned long long)start.tv_sec, start.tv_nsec,\n\t       (unsigned long long)vdso.tv_sec, vdso.tv_nsec,\n\t       (unsigned long long)end.tv_sec, end.tv_nsec);\n\n\tif (!ts64_leq(&start, &vdso) || !ts64_leq(&vdso, &end)) {\n\t\tprintf(\"[FAIL]\\tTimes are out of sequence\\n\");\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tprintf(\"[OK]\\tTest Passed.\\n\");\n}\n\nstatic void test_clock_gettime64(void)\n{\n\tif (!vdso_clock_gettime64) {\n\t\tprintf(\"[SKIP]\\tNo vDSO, so skipping clock_gettime64() tests\\n\");\n\t\treturn;\n\t}\n\n\tfor (int clock = 0; clock < ARRAY_SIZE(clocknames); clock++)\n\t\ttest_one_clock_gettime64(clock, clocknames[clock]);\n\n\t \n\ttest_one_clock_gettime64(-1, \"invalid\");\n\ttest_one_clock_gettime64(INT_MIN, \"invalid\");\n\ttest_one_clock_gettime64(INT_MAX, \"invalid\");\n}\n\nstatic void test_gettimeofday(void)\n{\n\tstruct timeval start, vdso, end;\n\tstruct timezone sys_tz, vdso_tz;\n\tint vdso_ret, end_ret;\n\n\tif (!vdso_gettimeofday)\n\t\treturn;\n\n\tprintf(\"[RUN]\\tTesting gettimeofday...\\n\");\n\n\tif (sys_gettimeofday(&start, &sys_tz) < 0) {\n\t\tprintf(\"[FAIL]\\tsys_gettimeofday failed (%d)\\n\", errno);\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tvdso_ret = vdso_gettimeofday(&vdso, &vdso_tz);\n\tend_ret = sys_gettimeofday(&end, NULL);\n\n\tif (vdso_ret != 0 || end_ret != 0) {\n\t\tprintf(\"[FAIL]\\tvDSO returned %d, syscall errno=%d\\n\",\n\t\t       vdso_ret, errno);\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\tprintf(\"\\t%llu.%06ld %llu.%06ld %llu.%06ld\\n\",\n\t       (unsigned long long)start.tv_sec, start.tv_usec,\n\t       (unsigned long long)vdso.tv_sec, vdso.tv_usec,\n\t       (unsigned long long)end.tv_sec, end.tv_usec);\n\n\tif (!tv_leq(&start, &vdso) || !tv_leq(&vdso, &end)) {\n\t\tprintf(\"[FAIL]\\tTimes are out of sequence\\n\");\n\t\tnerrs++;\n\t}\n\n\tif (sys_tz.tz_minuteswest == vdso_tz.tz_minuteswest &&\n\t    sys_tz.tz_dsttime == vdso_tz.tz_dsttime) {\n\t\tprintf(\"[OK]\\ttimezones match: minuteswest=%d, dsttime=%d\\n\",\n\t\t       sys_tz.tz_minuteswest, sys_tz.tz_dsttime);\n\t} else {\n\t\tprintf(\"[FAIL]\\ttimezones do not match\\n\");\n\t\tnerrs++;\n\t}\n\n\t \n\tvdso_gettimeofday(&vdso, NULL);\n}\n\nint main(int argc, char **argv)\n{\n\tname = (const char **)&names[VDSO_NAMES];\n\n\tfill_function_pointers();\n\n\ttest_clock_gettime();\n\ttest_clock_gettime64();\n\ttest_gettimeofday();\n\n\t \n\ttest_getcpu();\n\n\treturn nerrs ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}