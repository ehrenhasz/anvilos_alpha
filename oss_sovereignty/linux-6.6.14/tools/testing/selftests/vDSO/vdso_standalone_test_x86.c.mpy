{
  "module_name": "vdso_standalone_test_x86.c",
  "hash_id": "9f939a0af3506b1d3c6f454b7c7d9fbf5ce5208415e61745af9282ee99afdcf9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/vDSO/vdso_standalone_test_x86.c",
  "human_readable_source": "\n \n\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <stdint.h>\n\n#include \"parse_vdso.h\"\n\n \nint strcmp(const char *a, const char *b)\n{\n\t \n\twhile (*a || *b) {\n\t\tif (*a != *b)\n\t\t\treturn 1;\n\t\tif (*a == 0 || *b == 0)\n\t\t\treturn 1;\n\t\ta++;\n\t\tb++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline long x86_syscall3(long nr, long a0, long a1, long a2)\n{\n\tlong ret;\n#ifdef __x86_64__\n\tasm volatile (\"syscall\" : \"=a\" (ret) : \"a\" (nr),\n\t\t      \"D\" (a0), \"S\" (a1), \"d\" (a2) :\n\t\t      \"cc\", \"memory\", \"rcx\",\n\t\t      \"r8\", \"r9\", \"r10\", \"r11\" );\n#else\n\tasm volatile (\"int $0x80\" : \"=a\" (ret) : \"a\" (nr),\n\t\t      \"b\" (a0), \"c\" (a1), \"d\" (a2) :\n\t\t      \"cc\", \"memory\" );\n#endif\n\treturn ret;\n}\n\nstatic inline long linux_write(int fd, const void *data, size_t len)\n{\n\treturn x86_syscall3(__NR_write, fd, (long)data, (long)len);\n}\n\nstatic inline void linux_exit(int code)\n{\n\tx86_syscall3(__NR_exit, code, 0, 0);\n}\n\nvoid to_base10(char *lastdig, time_t n)\n{\n\twhile (n) {\n\t\t*lastdig = (n % 10) + '0';\n\t\tn /= 10;\n\t\tlastdig--;\n\t}\n}\n\n__attribute__((externally_visible)) void c_main(void **stack)\n{\n\t \n\tlong argc = (long)*stack;\n\tstack += argc + 2;\n\n\t \n\twhile(*stack)\n\t\tstack++;\n\tstack++;\n\n\t \n\tvdso_init_from_auxv((void *)stack);\n\n\t \n\ttypedef long (*gtod_t)(struct timeval *tv, struct timezone *tz);\n\tgtod_t gtod = (gtod_t)vdso_sym(\"LINUX_2.6\", \"__vdso_gettimeofday\");\n\n\tif (!gtod)\n\t\tlinux_exit(1);\n\n\tstruct timeval tv;\n\tlong ret = gtod(&tv, 0);\n\n\tif (ret == 0) {\n\t\tchar buf[] = \"The time is                     .000000\\n\";\n\t\tto_base10(buf + 31, tv.tv_sec);\n\t\tto_base10(buf + 38, tv.tv_usec);\n\t\tlinux_write(1, buf, sizeof(buf) - 1);\n\t} else {\n\t\tlinux_exit(ret);\n\t}\n\n\tlinux_exit(0);\n}\n\n \nasm (\n\t\".text\\n\"\n\t\".global _start\\n\"\n\t\".type _start,@function\\n\"\n\t\"_start:\\n\\t\"\n#ifdef __x86_64__\n\t\"mov %rsp,%rdi\\n\\t\"\n\t\"jmp c_main\"\n#else\n\t\"push %esp\\n\\t\"\n\t\"call c_main\\n\\t\"\n\t\"int $3\"\n#endif\n\t);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}