{
  "module_name": "move_mount_set_group_test.c",
  "hash_id": "f47f99c8e9c847bd7087329feb04e2bd31100174cf7fe9e49c6d54b229efd8bf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/move_mount_set_group/move_mount_set_group_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <sys/syscall.h>\n\n#include \"../kselftest_harness.h\"\n\n#ifndef CLONE_NEWNS\n#define CLONE_NEWNS 0x00020000\n#endif\n\n#ifndef CLONE_NEWUSER\n#define CLONE_NEWUSER 0x10000000\n#endif\n\n#ifndef MS_SHARED\n#define MS_SHARED (1 << 20)\n#endif\n\n#ifndef MS_PRIVATE\n#define MS_PRIVATE (1<<18)\n#endif\n\n#ifndef MOVE_MOUNT_SET_GROUP\n#define MOVE_MOUNT_SET_GROUP 0x00000100\n#endif\n\n#ifndef MOVE_MOUNT_F_EMPTY_PATH\n#define MOVE_MOUNT_F_EMPTY_PATH 0x00000004\n#endif\n\n#ifndef MOVE_MOUNT_T_EMPTY_PATH\n#define MOVE_MOUNT_T_EMPTY_PATH 0x00000040\n#endif\n\nstatic ssize_t write_nointr(int fd, const void *buf, size_t count)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = write(fd, buf, count);\n\t} while (ret < 0 && errno == EINTR);\n\n\treturn ret;\n}\n\nstatic int write_file(const char *path, const void *buf, size_t count)\n{\n\tint fd;\n\tssize_t ret;\n\n\tfd = open(path, O_WRONLY | O_CLOEXEC | O_NOCTTY | O_NOFOLLOW);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = write_nointr(fd, buf, count);\n\tclose(fd);\n\tif (ret < 0 || (size_t)ret != count)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int create_and_enter_userns(void)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tchar map[100];\n\n\tuid = getuid();\n\tgid = getgid();\n\n\tif (unshare(CLONE_NEWUSER))\n\t\treturn -1;\n\n\tif (write_file(\"/proc/self/setgroups\", \"deny\", sizeof(\"deny\") - 1) &&\n\t    errno != ENOENT)\n\t\treturn -1;\n\n\tsnprintf(map, sizeof(map), \"0 %d 1\", uid);\n\tif (write_file(\"/proc/self/uid_map\", map, strlen(map)))\n\t\treturn -1;\n\n\n\tsnprintf(map, sizeof(map), \"0 %d 1\", gid);\n\tif (write_file(\"/proc/self/gid_map\", map, strlen(map)))\n\t\treturn -1;\n\n\tif (setgid(0))\n\t\treturn -1;\n\n\tif (setuid(0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int prepare_unpriv_mountns(void)\n{\n\tif (create_and_enter_userns())\n\t\treturn -1;\n\n\tif (unshare(CLONE_NEWNS))\n\t\treturn -1;\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, 0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic char *get_field(char *src, int nfields)\n{\n\tint i;\n\tchar *p = src;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\n\t\tif (!*p)\n\t\t\tbreak;\n\n\t\tp++;\n\t}\n\n\treturn p;\n}\n\nstatic void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}\n\nstatic bool is_shared_mount(const char *path)\n{\n\tsize_t len = 0;\n\tchar *line = NULL;\n\tFILE *f = NULL;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *opts, *target;\n\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\n\t\tnull_endofword(target);\n\n\t\tif (strcmp(target, path) != 0)\n\t\t\tcontinue;\n\n\t\tnull_endofword(opts);\n\t\tif (strstr(opts, \"shared:\"))\n\t\t\treturn true;\n\t}\n\n\tfree(line);\n\tfclose(f);\n\n\treturn false;\n}\n\n \n#ifndef SKIP\n#define SKIP(s, ...)\tXFAIL(s, ##__VA_ARGS__)\n#endif\n\n#define SET_GROUP_FROM\t\"/tmp/move_mount_set_group_supported_from\"\n#define SET_GROUP_TO\t\"/tmp/move_mount_set_group_supported_to\"\n\nstatic bool move_mount_set_group_supported(void)\n{\n\tint ret;\n\n\tif (mount(\"testing\", \"/tmp\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t  \"size=100000,mode=700\"))\n\t\treturn -1;\n\n\tif (mount(NULL, \"/tmp\", NULL, MS_PRIVATE, 0))\n\t\treturn -1;\n\n\tif (mkdir(SET_GROUP_FROM, 0777))\n\t\treturn -1;\n\n\tif (mkdir(SET_GROUP_TO, 0777))\n\t\treturn -1;\n\n\tif (mount(\"testing\", SET_GROUP_FROM, \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t  \"size=100000,mode=700\"))\n\t\treturn -1;\n\n\tif (mount(SET_GROUP_FROM, SET_GROUP_TO, NULL, MS_BIND, NULL))\n\t\treturn -1;\n\n\tif (mount(NULL, SET_GROUP_FROM, NULL, MS_SHARED, 0))\n\t\treturn -1;\n\n\tret = syscall(SYS_move_mount, AT_FDCWD, SET_GROUP_FROM,\n\t\t      AT_FDCWD, SET_GROUP_TO, MOVE_MOUNT_SET_GROUP);\n\tumount2(\"/tmp\", MNT_DETACH);\n\n\treturn ret >= 0;\n}\n\nFIXTURE(move_mount_set_group) {\n};\n\n#define SET_GROUP_A \"/tmp/A\"\n\nFIXTURE_SETUP(move_mount_set_group)\n{\n\tbool ret;\n\n\tASSERT_EQ(prepare_unpriv_mountns(), 0);\n\n\tret = move_mount_set_group_supported();\n\tASSERT_GE(ret, 0);\n\tif (!ret)\n\t\tSKIP(return, \"move_mount(MOVE_MOUNT_SET_GROUP) is not supported\");\n\n\tumount2(\"/tmp\", MNT_DETACH);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(SET_GROUP_A, 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", SET_GROUP_A, \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n}\n\nFIXTURE_TEARDOWN(move_mount_set_group)\n{\n\tbool ret;\n\n\tret = move_mount_set_group_supported();\n\tASSERT_GE(ret, 0);\n\tif (!ret)\n\t\tSKIP(return, \"move_mount(MOVE_MOUNT_SET_GROUP) is not supported\");\n\n\tumount2(\"/tmp\", MNT_DETACH);\n}\n\n#define __STACK_SIZE (8 * 1024 * 1024)\nstatic pid_t do_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tvoid *stack;\n\n\tstack = malloc(__STACK_SIZE);\n\tif (!stack)\n\t\treturn -ENOMEM;\n\n#ifdef __ia64__\n\treturn __clone2(fn, stack, __STACK_SIZE, flags | SIGCHLD, arg, NULL);\n#else\n\treturn clone(fn, stack + __STACK_SIZE, flags | SIGCHLD, arg, NULL);\n#endif\n}\n\nstatic int wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\n\t\treturn -1;\n\t}\n\n\tif (!WIFEXITED(status))\n\t\treturn -1;\n\n\treturn WEXITSTATUS(status);\n}\n\nstruct child_args {\n\tint unsfd;\n\tint mntnsfd;\n\tbool shared;\n\tint mntfd;\n};\n\nstatic int get_nestedns_mount_cb(void *data)\n{\n\tstruct child_args *ca = (struct child_args *)data;\n\tint ret;\n\n\tret = prepare_unpriv_mountns();\n\tif (ret)\n\t\treturn 1;\n\n\tif (ca->shared) {\n\t\tret = mount(NULL, SET_GROUP_A, NULL, MS_SHARED, 0);\n\t\tif (ret)\n\t\t\treturn 1;\n\t}\n\n\tret = open(\"/proc/self/ns/user\", O_RDONLY);\n\tif (ret < 0)\n\t\treturn 1;\n\tca->unsfd = ret;\n\n\tret = open(\"/proc/self/ns/mnt\", O_RDONLY);\n\tif (ret < 0)\n\t\treturn 1;\n\tca->mntnsfd = ret;\n\n\tret = open(SET_GROUP_A, O_RDONLY);\n\tif (ret < 0)\n\t\treturn 1;\n\tca->mntfd = ret;\n\n\treturn 0;\n}\n\nTEST_F(move_mount_set_group, complex_sharing_copying)\n{\n\tstruct child_args ca_from = {\n\t\t.shared = true,\n\t};\n\tstruct child_args ca_to = {\n\t\t.shared = false,\n\t};\n\tpid_t pid;\n\tbool ret;\n\n\tret = move_mount_set_group_supported();\n\tASSERT_GE(ret, 0);\n\tif (!ret)\n\t\tSKIP(return, \"move_mount(MOVE_MOUNT_SET_GROUP) is not supported\");\n\n\tpid = do_clone(get_nestedns_mount_cb, (void *)&ca_from, CLONE_VFORK |\n\t\t       CLONE_VM | CLONE_FILES); ASSERT_GT(pid, 0);\n\tASSERT_EQ(wait_for_pid(pid), 0);\n\n\tpid = do_clone(get_nestedns_mount_cb, (void *)&ca_to, CLONE_VFORK |\n\t\t       CLONE_VM | CLONE_FILES); ASSERT_GT(pid, 0);\n\tASSERT_EQ(wait_for_pid(pid), 0);\n\n\tASSERT_EQ(syscall(SYS_move_mount, ca_from.mntfd, \"\",\n\t\t\t  ca_to.mntfd, \"\", MOVE_MOUNT_SET_GROUP\n\t\t\t  | MOVE_MOUNT_F_EMPTY_PATH | MOVE_MOUNT_T_EMPTY_PATH),\n\t\t  0);\n\n\tASSERT_EQ(setns(ca_to.mntnsfd, CLONE_NEWNS), 0);\n\tASSERT_EQ(is_shared_mount(SET_GROUP_A), 1);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}