{
  "module_name": "uffd-unit-tests.c",
  "hash_id": "e1dd645c49dd5f26c54d9a9963eb06040f2939719391e53017c4c94e9fafa988",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/uffd-unit-tests.c",
  "human_readable_source": "\n \n\n#include \"uffd-common.h\"\n\n#include \"../../../../mm/gup_test.h\"\n\n#ifdef __NR_userfaultfd\n\n \n#define  UFFD_TEST_MEM_SIZE               (32UL << 20)\n\n#define  MEM_ANON                         BIT_ULL(0)\n#define  MEM_SHMEM                        BIT_ULL(1)\n#define  MEM_SHMEM_PRIVATE                BIT_ULL(2)\n#define  MEM_HUGETLB                      BIT_ULL(3)\n#define  MEM_HUGETLB_PRIVATE              BIT_ULL(4)\n\n#define  MEM_ALL  (MEM_ANON | MEM_SHMEM | MEM_SHMEM_PRIVATE | \\\n\t\t   MEM_HUGETLB | MEM_HUGETLB_PRIVATE)\n\nstruct mem_type {\n\tconst char *name;\n\tunsigned int mem_flag;\n\tuffd_test_ops_t *mem_ops;\n\tbool shared;\n};\ntypedef struct mem_type mem_type_t;\n\nmem_type_t mem_types[] = {\n\t{\n\t\t.name = \"anon\",\n\t\t.mem_flag = MEM_ANON,\n\t\t.mem_ops = &anon_uffd_test_ops,\n\t\t.shared = false,\n\t},\n\t{\n\t\t.name = \"shmem\",\n\t\t.mem_flag = MEM_SHMEM,\n\t\t.mem_ops = &shmem_uffd_test_ops,\n\t\t.shared = true,\n\t},\n\t{\n\t\t.name = \"shmem-private\",\n\t\t.mem_flag = MEM_SHMEM_PRIVATE,\n\t\t.mem_ops = &shmem_uffd_test_ops,\n\t\t.shared = false,\n\t},\n\t{\n\t\t.name = \"hugetlb\",\n\t\t.mem_flag = MEM_HUGETLB,\n\t\t.mem_ops = &hugetlb_uffd_test_ops,\n\t\t.shared = true,\n\t},\n\t{\n\t\t.name = \"hugetlb-private\",\n\t\t.mem_flag = MEM_HUGETLB_PRIVATE,\n\t\t.mem_ops = &hugetlb_uffd_test_ops,\n\t\t.shared = false,\n\t},\n};\n\n \nstruct uffd_test_args {\n\tmem_type_t *mem_type;\n};\ntypedef struct uffd_test_args uffd_test_args_t;\n\n \ntypedef void (*uffd_test_fn)(uffd_test_args_t *);\n\ntypedef struct {\n\tconst char *name;\n\tuffd_test_fn uffd_fn;\n\tunsigned int mem_targets;\n\tuint64_t uffd_feature_required;\n} uffd_test_case_t;\n\nstatic void uffd_test_report(void)\n{\n\tprintf(\"Userfaults unit tests: pass=%u, skip=%u, fail=%u (total=%u)\\n\",\n\t       ksft_get_pass_cnt(),\n\t       ksft_get_xskip_cnt(),\n\t       ksft_get_fail_cnt(),\n\t       ksft_test_num());\n}\n\nstatic void uffd_test_pass(void)\n{\n\tprintf(\"done\\n\");\n\tksft_inc_pass_cnt();\n}\n\n#define  uffd_test_start(...)  do {\t\t\\\n\t\tprintf(\"Testing \");\t\t\\\n\t\tprintf(__VA_ARGS__);\t\t\\\n\t\tprintf(\"... \");\t\t\t\\\n\t\tfflush(stdout);\t\t\t\\\n\t} while (0)\n\n#define  uffd_test_fail(...)  do {\t\t\\\n\t\tprintf(\"failed [reason: \");\t\\\n\t\tprintf(__VA_ARGS__);\t\t\\\n\t\tprintf(\"]\\n\");\t\t\t\\\n\t\tksft_inc_fail_cnt();\t\t\\\n\t} while (0)\n\nstatic void uffd_test_skip(const char *message)\n{\n\tprintf(\"skipped [reason: %s]\\n\", message);\n\tksft_inc_xskip_cnt();\n}\n\n \nstatic int test_uffd_api(bool use_dev)\n{\n\tstruct uffdio_api uffdio_api;\n\tint uffd;\n\n\tuffd_test_start(\"UFFDIO_API (with %s)\",\n\t\t\tuse_dev ? \"/dev/userfaultfd\" : \"syscall\");\n\n\tif (use_dev)\n\t\tuffd = uffd_open_dev(UFFD_FLAGS);\n\telse\n\t\tuffd = uffd_open_sys(UFFD_FLAGS);\n\tif (uffd < 0) {\n\t\tuffd_test_skip(\"cannot open userfaultfd handle\");\n\t\treturn 0;\n\t}\n\n\t \n\tuffdio_api.api = 0xab;\n\tuffdio_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) == 0) {\n\t\tuffd_test_fail(\"UFFDIO_API should fail with wrong api but didn't\");\n\t\tgoto out;\n\t}\n\n\t \n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = BIT_ULL(63);\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) == 0) {\n\t\tuffd_test_fail(\"UFFDIO_API should fail with wrong feature but didn't\");\n\t\tgoto out;\n\t}\n\n\t \n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api)) {\n\t\tuffd_test_fail(\"UFFDIO_API should succeed but failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tuffdio_api.features = BIT_ULL(0);\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) == 0) {\n\t\tuffd_test_fail(\"UFFDIO_API should reject initialized uffd\");\n\t\tgoto out;\n\t}\n\n\tuffd_test_pass();\nout:\n\tclose(uffd);\n\t \n\treturn 1;\n}\n\n \nstatic int\nuffd_setup_environment(uffd_test_args_t *args, uffd_test_case_t *test,\n\t\t       mem_type_t *mem_type, const char **errmsg)\n{\n\tmap_shared = mem_type->shared;\n\tuffd_test_ops = mem_type->mem_ops;\n\n\tif (mem_type->mem_flag & (MEM_HUGETLB_PRIVATE | MEM_HUGETLB))\n\t\tpage_size = default_huge_page_size();\n\telse\n\t\tpage_size = psize();\n\n\tnr_pages = UFFD_TEST_MEM_SIZE / page_size;\n\t \n\tnr_cpus = 1;\n\n\t \n\targs->mem_type = mem_type;\n\n\treturn uffd_test_ctx_init(test->uffd_feature_required, errmsg);\n}\n\nstatic bool uffd_feature_supported(uffd_test_case_t *test)\n{\n\tuint64_t features;\n\n\tif (uffd_get_features(&features))\n\t\treturn false;\n\n\treturn (features & test->uffd_feature_required) ==\n\t    test->uffd_feature_required;\n}\n\nstatic int pagemap_open(void)\n{\n\tint fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\n\tif (fd < 0)\n\t\terr(\"open pagemap\");\n\n\treturn fd;\n}\n\n \n#define  pagemap_check_wp(value, wp) do {\t\t\t\t\\\n\t\tif (!!(value & PM_UFFD_WP) != wp)\t\t\t\\\n\t\t\terr(\"pagemap uffd-wp bit error: 0x%\"PRIx64, value); \\\n\t} while (0)\n\ntypedef struct {\n\tint parent_uffd, child_uffd;\n} fork_event_args;\n\nstatic void *fork_event_consumer(void *data)\n{\n\tfork_event_args *args = data;\n\tstruct uffd_msg msg = { 0 };\n\n\t \n\twhile (uffd_read_msg(args->parent_uffd, &msg));\n\n\tif (msg.event != UFFD_EVENT_FORK)\n\t\terr(\"wrong message: %u\\n\", msg.event);\n\n\t \n\targs->child_uffd = msg.arg.fork.ufd;\n\treturn NULL;\n}\n\ntypedef struct {\n\tint gup_fd;\n\tbool pinned;\n} pin_args;\n\n \nstatic int pin_pages(pin_args *args, void *buffer, size_t size)\n{\n\tstruct pin_longterm_test test = {\n\t\t.addr = (uintptr_t)buffer,\n\t\t.size = size,\n\t\t \n\t\t.flags = 0,\n\t};\n\n\tif (args->pinned)\n\t\terr(\"already pinned\");\n\n\targs->gup_fd = open(\"/sys/kernel/debug/gup_test\", O_RDWR);\n\tif (args->gup_fd < 0)\n\t\treturn -errno;\n\n\tif (ioctl(args->gup_fd, PIN_LONGTERM_TEST_START, &test)) {\n\t\t \n\t\tclose(args->gup_fd);\n\t\treturn -errno;\n\t}\n\targs->pinned = true;\n\treturn 0;\n}\n\nstatic void unpin_pages(pin_args *args)\n{\n\tif (!args->pinned)\n\t\terr(\"unpin without pin first\");\n\tif (ioctl(args->gup_fd, PIN_LONGTERM_TEST_STOP))\n\t\terr(\"PIN_LONGTERM_TEST_STOP\");\n\tclose(args->gup_fd);\n\targs->pinned = false;\n}\n\nstatic int pagemap_test_fork(int uffd, bool with_event, bool test_pin)\n{\n\tfork_event_args args = { .parent_uffd = uffd, .child_uffd = -1 };\n\tpthread_t thread;\n\tpid_t child;\n\tuint64_t value;\n\tint fd, result;\n\n\t \n\tif (with_event) {\n\t\tif (pthread_create(&thread, NULL, fork_event_consumer, &args))\n\t\t\terr(\"pthread_create()\");\n\t}\n\n\tchild = fork();\n\tif (!child) {\n\t\t \n\t\tpin_args args = {};\n\n\t\tfd = pagemap_open();\n\n\t\tif (test_pin && pin_pages(&args, area_dst, page_size))\n\t\t\t \n\t\t\terr(\"pin page failed in child\");\n\n\t\tvalue = pagemap_get_entry(fd, area_dst);\n\t\t \n\t\tpagemap_check_wp(value, with_event);\n\t\tif (test_pin)\n\t\t\tunpin_pages(&args);\n\t\t \n\t\texit(0);\n\t}\n\twaitpid(child, &result, 0);\n\n\tif (with_event) {\n\t\tif (pthread_join(thread, NULL))\n\t\t\terr(\"pthread_join()\");\n\t\tif (args.child_uffd < 0)\n\t\t\terr(\"Didn't receive child uffd\");\n\t\tclose(args.child_uffd);\n\t}\n\n\treturn result;\n}\n\nstatic void uffd_wp_unpopulated_test(uffd_test_args_t *args)\n{\n\tuint64_t value;\n\tint pagemap_fd;\n\n\tif (uffd_register(uffd, area_dst, nr_pages * page_size,\n\t\t\t  false, true, false))\n\t\terr(\"register failed\");\n\n\tpagemap_fd = pagemap_open();\n\n\t \n\twp_range(uffd, (uint64_t)area_dst, page_size, true);\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, true);\n\n\t \n\twp_range(uffd, (uint64_t)area_dst, page_size, false);\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, false);\n\n\t \n\twp_range(uffd, (uint64_t)area_dst, page_size, true);\n\tif (madvise(area_dst, page_size, MADV_DONTNEED))\n\t\terr(\"madvise(MADV_DONTNEED) failed\");\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, false);\n\n\t \n\t*area_dst = 1;\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, false);\n\t \n\tif (madvise(area_dst, page_size, MADV_DONTNEED))\n\t\terr(\"madvise(MADV_DONTNEED) failed\");\n\n\t \n\twp_range(uffd, (uint64_t)area_dst, page_size, true);\n\t*(volatile char *)area_dst;\n\t \n\tif (madvise(area_dst, page_size, MADV_DONTNEED))\n\t\terr(\"madvise(MADV_DONTNEED) failed\");\n\n\tuffd_test_pass();\n}\n\nstatic void uffd_wp_fork_test_common(uffd_test_args_t *args,\n\t\t\t\t     bool with_event)\n{\n\tint pagemap_fd;\n\tuint64_t value;\n\n\tif (uffd_register(uffd, area_dst, nr_pages * page_size,\n\t\t\t  false, true, false))\n\t\terr(\"register failed\");\n\n\tpagemap_fd = pagemap_open();\n\n\t \n\t*area_dst = 1;\n\twp_range(uffd, (uint64_t)area_dst, page_size, true);\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, true);\n\tif (pagemap_test_fork(uffd, with_event, false)) {\n\t\tuffd_test_fail(\"Detected %s uffd-wp bit in child in present pte\",\n\t\t\t       with_event ? \"missing\" : \"stall\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (args->mem_type->shared) {\n\t\tif (madvise(area_dst, page_size, MADV_DONTNEED))\n\t\t\terr(\"MADV_DONTNEED\");\n\t} else {\n\t\t \n\t\tmadvise(area_dst, page_size, MADV_PAGEOUT);\n\t}\n\n\t \n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, true);\n\tif (pagemap_test_fork(uffd, with_event, false)) {\n\t\tuffd_test_fail(\"Detected %s uffd-wp bit in child in zapped pte\",\n\t\t\t       with_event ? \"missing\" : \"stall\");\n\t\tgoto out;\n\t}\n\n\t \n\twp_range(uffd, (uint64_t)area_dst, page_size, false);\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, false);\n\n\t \n\t*area_dst = 2;\n\tvalue = pagemap_get_entry(pagemap_fd, area_dst);\n\tpagemap_check_wp(value, false);\n\tuffd_test_pass();\nout:\n\tif (uffd_unregister(uffd, area_dst, nr_pages * page_size))\n\t\terr(\"unregister failed\");\n\tclose(pagemap_fd);\n}\n\nstatic void uffd_wp_fork_test(uffd_test_args_t *args)\n{\n\tuffd_wp_fork_test_common(args, false);\n}\n\nstatic void uffd_wp_fork_with_event_test(uffd_test_args_t *args)\n{\n\tuffd_wp_fork_test_common(args, true);\n}\n\nstatic void uffd_wp_fork_pin_test_common(uffd_test_args_t *args,\n\t\t\t\t\t bool with_event)\n{\n\tint pagemap_fd;\n\tpin_args pin_args = {};\n\n\tif (uffd_register(uffd, area_dst, page_size, false, true, false))\n\t\terr(\"register failed\");\n\n\tpagemap_fd = pagemap_open();\n\n\t \n\t*area_dst = 1;\n\twp_range(uffd, (uint64_t)area_dst, page_size, true);\n\n\t \n\tif (pin_pages(&pin_args, area_dst, page_size)) {\n\t\tuffd_test_skip(\"Possibly CONFIG_GUP_TEST missing \"\n\t\t\t       \"or unprivileged\");\n\t\tclose(pagemap_fd);\n\t\tuffd_unregister(uffd, area_dst, page_size);\n\t\treturn;\n\t}\n\n\tif (pagemap_test_fork(uffd, with_event, false)) {\n\t\tuffd_test_fail(\"Detected %s uffd-wp bit in early CoW of fork()\",\n\t\t\t       with_event ? \"missing\" : \"stall\");\n\t\tunpin_pages(&pin_args);\n\t\tgoto out;\n\t}\n\n\tunpin_pages(&pin_args);\n\n\t \n\tif (pagemap_test_fork(uffd, with_event, true)) {\n\t\tuffd_test_fail(\"Detected %s uffd-wp bit when RO pin\",\n\t\t\t       with_event ? \"missing\" : \"stall\");\n\t\tgoto out;\n\t}\n\tuffd_test_pass();\nout:\n\tif (uffd_unregister(uffd, area_dst, page_size))\n\t\terr(\"register failed\");\n\tclose(pagemap_fd);\n}\n\nstatic void uffd_wp_fork_pin_test(uffd_test_args_t *args)\n{\n\tuffd_wp_fork_pin_test_common(args, false);\n}\n\nstatic void uffd_wp_fork_pin_with_event_test(uffd_test_args_t *args)\n{\n\tuffd_wp_fork_pin_test_common(args, true);\n}\n\nstatic void check_memory_contents(char *p)\n{\n\tunsigned long i, j;\n\tuint8_t expected_byte;\n\n\tfor (i = 0; i < nr_pages; ++i) {\n\t\texpected_byte = ~((uint8_t)(i % ((uint8_t)-1)));\n\t\tfor (j = 0; j < page_size; j++) {\n\t\t\tuint8_t v = *(uint8_t *)(p + (i * page_size) + j);\n\t\t\tif (v != expected_byte)\n\t\t\t\terr(\"unexpected page contents\");\n\t\t}\n\t}\n}\n\nstatic void uffd_minor_test_common(bool test_collapse, bool test_wp)\n{\n\tunsigned long p;\n\tpthread_t uffd_mon;\n\tchar c;\n\tstruct uffd_args args = { 0 };\n\n\t \n\tassert(!(test_collapse && test_wp));\n\n\tif (uffd_register(uffd, area_dst_alias, nr_pages * page_size,\n\t\t\t   \n\t\t\t  false, test_wp, true))\n\t\terr(\"register failure\");\n\n\t \n\tfor (p = 0; p < nr_pages; ++p)\n\t\tmemset(area_dst + (p * page_size), p % ((uint8_t)-1),\n\t\t       page_size);\n\n\targs.apply_wp = test_wp;\n\tif (pthread_create(&uffd_mon, NULL, uffd_poll_thread, &args))\n\t\terr(\"uffd_poll_thread create\");\n\n\t \n\tcheck_memory_contents(area_dst_alias);\n\n\tif (write(pipefd[1], &c, sizeof(c)) != sizeof(c))\n\t\terr(\"pipe write\");\n\tif (pthread_join(uffd_mon, NULL))\n\t\terr(\"join() failed\");\n\n\tif (test_collapse) {\n\t\tif (madvise(area_dst_alias, nr_pages * page_size,\n\t\t\t    MADV_COLLAPSE)) {\n\t\t\t \n\t\t\tuffd_test_skip(\"MADV_COLLAPSE failed\");\n\t\t\treturn;\n\t\t}\n\n\t\tuffd_test_ops->check_pmd_mapping(area_dst,\n\t\t\t\t\t\t nr_pages * page_size /\n\t\t\t\t\t\t read_pmd_pagesize());\n\t\t \n\t\tcheck_memory_contents(area_dst_alias);\n\t}\n\n\tif (args.missing_faults != 0 || args.minor_faults != nr_pages)\n\t\tuffd_test_fail(\"stats check error\");\n\telse\n\t\tuffd_test_pass();\n}\n\nvoid uffd_minor_test(uffd_test_args_t *args)\n{\n\tuffd_minor_test_common(false, false);\n}\n\nvoid uffd_minor_wp_test(uffd_test_args_t *args)\n{\n\tuffd_minor_test_common(false, true);\n}\n\nvoid uffd_minor_collapse_test(uffd_test_args_t *args)\n{\n\tuffd_minor_test_common(true, false);\n}\n\nstatic sigjmp_buf jbuf, *sigbuf;\n\nstatic void sighndl(int sig, siginfo_t *siginfo, void *ptr)\n{\n\tif (sig == SIGBUS) {\n\t\tif (sigbuf)\n\t\t\tsiglongjmp(*sigbuf, 1);\n\t\tabort();\n\t}\n}\n\n \nstatic int faulting_process(int signal_test, bool wp)\n{\n\tunsigned long nr, i;\n\tunsigned long long count;\n\tunsigned long split_nr_pages;\n\tunsigned long lastnr;\n\tstruct sigaction act;\n\tvolatile unsigned long signalled = 0;\n\n\tsplit_nr_pages = (nr_pages + 1) / 2;\n\n\tif (signal_test) {\n\t\tsigbuf = &jbuf;\n\t\tmemset(&act, 0, sizeof(act));\n\t\tact.sa_sigaction = sighndl;\n\t\tact.sa_flags = SA_SIGINFO;\n\t\tif (sigaction(SIGBUS, &act, 0))\n\t\t\terr(\"sigaction\");\n\t\tlastnr = (unsigned long)-1;\n\t}\n\n\tfor (nr = 0; nr < split_nr_pages; nr++) {\n\t\tvolatile int steps = 1;\n\t\tunsigned long offset = nr * page_size;\n\n\t\tif (signal_test) {\n\t\t\tif (sigsetjmp(*sigbuf, 1) != 0) {\n\t\t\t\tif (steps == 1 && nr == lastnr)\n\t\t\t\t\terr(\"Signal repeated\");\n\n\t\t\t\tlastnr = nr;\n\t\t\t\tif (signal_test == 1) {\n\t\t\t\t\tif (steps == 1) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tsteps++;\n\t\t\t\t\t\tif (copy_page(uffd, offset, wp))\n\t\t\t\t\t\t\tsignalled++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tassert(steps == 2);\n\t\t\t\t\t\twp_range(uffd,\n\t\t\t\t\t\t\t (__u64)area_dst +\n\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t page_size, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsignalled++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount = *area_count(area_dst, nr);\n\t\tif (count != count_verify[nr])\n\t\t\terr(\"nr %lu memory corruption %llu %llu\\n\",\n\t\t\t    nr, count, count_verify[nr]);\n\t\t \n\t\t*area_count(area_dst, nr) = count;\n\t}\n\n\tif (signal_test)\n\t\treturn signalled != split_nr_pages;\n\n\tarea_dst = mremap(area_dst, nr_pages * page_size,  nr_pages * page_size,\n\t\t\t  MREMAP_MAYMOVE | MREMAP_FIXED, area_src);\n\tif (area_dst == MAP_FAILED)\n\t\terr(\"mremap\");\n\t \n\tarea_src = NULL;\n\n\tfor (; nr < nr_pages; nr++) {\n\t\tcount = *area_count(area_dst, nr);\n\t\tif (count != count_verify[nr]) {\n\t\t\terr(\"nr %lu memory corruption %llu %llu\\n\",\n\t\t\t    nr, count, count_verify[nr]);\n\t\t}\n\t\t \n\t\t*area_count(area_dst, nr) = count;\n\t}\n\n\tuffd_test_ops->release_pages(area_dst);\n\n\tfor (nr = 0; nr < nr_pages; nr++)\n\t\tfor (i = 0; i < page_size; i++)\n\t\t\tif (*(area_dst + nr * page_size + i) != 0)\n\t\t\t\terr(\"page %lu offset %lu is not zero\", nr, i);\n\n\treturn 0;\n}\n\nstatic void uffd_sigbus_test_common(bool wp)\n{\n\tunsigned long userfaults;\n\tpthread_t uffd_mon;\n\tpid_t pid;\n\tint err;\n\tchar c;\n\tstruct uffd_args args = { 0 };\n\n\tfcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);\n\n\tif (uffd_register(uffd, area_dst, nr_pages * page_size,\n\t\t\t  true, wp, false))\n\t\terr(\"register failure\");\n\n\tif (faulting_process(1, wp))\n\t\terr(\"faulting process failed\");\n\n\tuffd_test_ops->release_pages(area_dst);\n\n\targs.apply_wp = wp;\n\tif (pthread_create(&uffd_mon, NULL, uffd_poll_thread, &args))\n\t\terr(\"uffd_poll_thread create\");\n\n\tpid = fork();\n\tif (pid < 0)\n\t\terr(\"fork\");\n\n\tif (!pid)\n\t\texit(faulting_process(2, wp));\n\n\twaitpid(pid, &err, 0);\n\tif (err)\n\t\terr(\"faulting process failed\");\n\tif (write(pipefd[1], &c, sizeof(c)) != sizeof(c))\n\t\terr(\"pipe write\");\n\tif (pthread_join(uffd_mon, (void **)&userfaults))\n\t\terr(\"pthread_join()\");\n\n\tif (userfaults)\n\t\tuffd_test_fail(\"Signal test failed, userfaults: %ld\", userfaults);\n\telse\n\t\tuffd_test_pass();\n}\n\nstatic void uffd_sigbus_test(uffd_test_args_t *args)\n{\n\tuffd_sigbus_test_common(false);\n}\n\nstatic void uffd_sigbus_wp_test(uffd_test_args_t *args)\n{\n\tuffd_sigbus_test_common(true);\n}\n\nstatic void uffd_events_test_common(bool wp)\n{\n\tpthread_t uffd_mon;\n\tpid_t pid;\n\tint err;\n\tchar c;\n\tstruct uffd_args args = { 0 };\n\n\tfcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);\n\tif (uffd_register(uffd, area_dst, nr_pages * page_size,\n\t\t\t  true, wp, false))\n\t\terr(\"register failure\");\n\n\targs.apply_wp = wp;\n\tif (pthread_create(&uffd_mon, NULL, uffd_poll_thread, &args))\n\t\terr(\"uffd_poll_thread create\");\n\n\tpid = fork();\n\tif (pid < 0)\n\t\terr(\"fork\");\n\n\tif (!pid)\n\t\texit(faulting_process(0, wp));\n\n\twaitpid(pid, &err, 0);\n\tif (err)\n\t\terr(\"faulting process failed\");\n\tif (write(pipefd[1], &c, sizeof(c)) != sizeof(c))\n\t\terr(\"pipe write\");\n\tif (pthread_join(uffd_mon, NULL))\n\t\terr(\"pthread_join()\");\n\n\tif (args.missing_faults != nr_pages)\n\t\tuffd_test_fail(\"Fault counts wrong\");\n\telse\n\t\tuffd_test_pass();\n}\n\nstatic void uffd_events_test(uffd_test_args_t *args)\n{\n\tuffd_events_test_common(false);\n}\n\nstatic void uffd_events_wp_test(uffd_test_args_t *args)\n{\n\tuffd_events_test_common(true);\n}\n\nstatic void retry_uffdio_zeropage(int ufd,\n\t\t\t\t  struct uffdio_zeropage *uffdio_zeropage)\n{\n\tuffd_test_ops->alias_mapping(&uffdio_zeropage->range.start,\n\t\t\t\t     uffdio_zeropage->range.len,\n\t\t\t\t     0);\n\tif (ioctl(ufd, UFFDIO_ZEROPAGE, uffdio_zeropage)) {\n\t\tif (uffdio_zeropage->zeropage != -EEXIST)\n\t\t\terr(\"UFFDIO_ZEROPAGE error: %\"PRId64,\n\t\t\t    (int64_t)uffdio_zeropage->zeropage);\n\t} else {\n\t\terr(\"UFFDIO_ZEROPAGE error: %\"PRId64,\n\t\t    (int64_t)uffdio_zeropage->zeropage);\n\t}\n}\n\nstatic bool do_uffdio_zeropage(int ufd, bool has_zeropage)\n{\n\tstruct uffdio_zeropage uffdio_zeropage = { 0 };\n\tint ret;\n\t__s64 res;\n\n\tuffdio_zeropage.range.start = (unsigned long) area_dst;\n\tuffdio_zeropage.range.len = page_size;\n\tuffdio_zeropage.mode = 0;\n\tret = ioctl(ufd, UFFDIO_ZEROPAGE, &uffdio_zeropage);\n\tres = uffdio_zeropage.zeropage;\n\tif (ret) {\n\t\t \n\t\tif (has_zeropage)\n\t\t\terr(\"UFFDIO_ZEROPAGE error: %\"PRId64, (int64_t)res);\n\t\telse if (res != -EINVAL)\n\t\t\terr(\"UFFDIO_ZEROPAGE not -EINVAL\");\n\t} else if (has_zeropage) {\n\t\tif (res != page_size)\n\t\t\terr(\"UFFDIO_ZEROPAGE unexpected size\");\n\t\telse\n\t\t\tretry_uffdio_zeropage(ufd, &uffdio_zeropage);\n\t\treturn true;\n\t} else\n\t\terr(\"UFFDIO_ZEROPAGE succeeded\");\n\n\treturn false;\n}\n\n \nstatic bool\nuffd_register_detect_zeropage(int uffd, void *addr, uint64_t len)\n{\n\tuint64_t ioctls = 0;\n\n\tif (uffd_register_with_ioctls(uffd, addr, len, true,\n\t\t\t\t      false, false, &ioctls))\n\t\terr(\"zeropage register fail\");\n\n\treturn ioctls & (1 << _UFFDIO_ZEROPAGE);\n}\n\n \nstatic void uffd_zeropage_test(uffd_test_args_t *args)\n{\n\tbool has_zeropage;\n\tint i;\n\n\thas_zeropage = uffd_register_detect_zeropage(uffd, area_dst, page_size);\n\tif (area_dst_alias)\n\t\t \n\t\tuffd_register_detect_zeropage(uffd, area_dst_alias, page_size);\n\n\tif (do_uffdio_zeropage(uffd, has_zeropage))\n\t\tfor (i = 0; i < page_size; i++)\n\t\t\tif (area_dst[i] != 0)\n\t\t\t\terr(\"data non-zero at offset %d\\n\", i);\n\n\tif (uffd_unregister(uffd, area_dst, page_size))\n\t\terr(\"unregister\");\n\n\tif (area_dst_alias && uffd_unregister(uffd, area_dst_alias, page_size))\n\t\terr(\"unregister\");\n\n\tuffd_test_pass();\n}\n\nstatic void uffd_register_poison(int uffd, void *addr, uint64_t len)\n{\n\tuint64_t ioctls = 0;\n\tuint64_t expected = (1 << _UFFDIO_COPY) | (1 << _UFFDIO_POISON);\n\n\tif (uffd_register_with_ioctls(uffd, addr, len, true,\n\t\t\t\t      false, false, &ioctls))\n\t\terr(\"poison register fail\");\n\n\tif ((ioctls & expected) != expected)\n\t\terr(\"registered area doesn't support COPY and POISON ioctls\");\n}\n\nstatic void do_uffdio_poison(int uffd, unsigned long offset)\n{\n\tstruct uffdio_poison uffdio_poison = { 0 };\n\tint ret;\n\t__s64 res;\n\n\tuffdio_poison.range.start = (unsigned long) area_dst + offset;\n\tuffdio_poison.range.len = page_size;\n\tuffdio_poison.mode = 0;\n\tret = ioctl(uffd, UFFDIO_POISON, &uffdio_poison);\n\tres = uffdio_poison.updated;\n\n\tif (ret)\n\t\terr(\"UFFDIO_POISON error: %\"PRId64, (int64_t)res);\n\telse if (res != page_size)\n\t\terr(\"UFFDIO_POISON unexpected size: %\"PRId64, (int64_t)res);\n}\n\nstatic void uffd_poison_handle_fault(\n\tstruct uffd_msg *msg, struct uffd_args *args)\n{\n\tunsigned long offset;\n\n\tif (msg->event != UFFD_EVENT_PAGEFAULT)\n\t\terr(\"unexpected msg event %u\", msg->event);\n\n\tif (msg->arg.pagefault.flags &\n\t    (UFFD_PAGEFAULT_FLAG_WP | UFFD_PAGEFAULT_FLAG_MINOR))\n\t\terr(\"unexpected fault type %llu\", msg->arg.pagefault.flags);\n\n\toffset = (char *)(unsigned long)msg->arg.pagefault.address - area_dst;\n\toffset &= ~(page_size-1);\n\n\t \n\tif (offset & page_size)\n\t\tcopy_page(uffd, offset, false);\n\telse\n\t\tdo_uffdio_poison(uffd, offset);\n}\n\nstatic void uffd_poison_test(uffd_test_args_t *targs)\n{\n\tpthread_t uffd_mon;\n\tchar c;\n\tstruct uffd_args args = { 0 };\n\tstruct sigaction act = { 0 };\n\tunsigned long nr_sigbus = 0;\n\tunsigned long nr;\n\n\tfcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);\n\n\tuffd_register_poison(uffd, area_dst, nr_pages * page_size);\n\tmemset(area_src, 0, nr_pages * page_size);\n\n\targs.handle_fault = uffd_poison_handle_fault;\n\tif (pthread_create(&uffd_mon, NULL, uffd_poll_thread, &args))\n\t\terr(\"uffd_poll_thread create\");\n\n\tsigbuf = &jbuf;\n\tact.sa_sigaction = sighndl;\n\tact.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGBUS, &act, 0))\n\t\terr(\"sigaction\");\n\n\tfor (nr = 0; nr < nr_pages; ++nr) {\n\t\tunsigned long offset = nr * page_size;\n\t\tconst char *bytes = (const char *) area_dst + offset;\n\t\tconst char *i;\n\n\t\tif (sigsetjmp(*sigbuf, 1)) {\n\t\t\t \n\t\t\t++nr_sigbus;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = bytes; i < bytes + page_size; ++i) {\n\t\t\tif (*i)\n\t\t\t\terr(\"nonzero byte in area_dst (%p) at %p: %u\",\n\t\t\t\t    area_dst, i, *i);\n\t\t}\n\t}\n\n\tif (write(pipefd[1], &c, sizeof(c)) != sizeof(c))\n\t\terr(\"pipe write\");\n\tif (pthread_join(uffd_mon, NULL))\n\t\terr(\"pthread_join()\");\n\n\tif (nr_sigbus != nr_pages / 2)\n\t\terr(\"expected to receive %lu SIGBUS, actually received %lu\",\n\t\t    nr_pages / 2, nr_sigbus);\n\n\tuffd_test_pass();\n}\n\n \nstatic void\ndo_register_ioctls_test(uffd_test_args_t *args, bool miss, bool wp, bool minor)\n{\n\tuint64_t ioctls = 0, expected = BIT_ULL(_UFFDIO_WAKE);\n\tmem_type_t *mem_type = args->mem_type;\n\tint ret;\n\n\tret = uffd_register_with_ioctls(uffd, area_dst, page_size,\n\t\t\t\t\tmiss, wp, minor, &ioctls);\n\n\t \n\tif ((minor && (mem_type->mem_flag == MEM_ANON)) ||\n\t    (!miss && !wp && !minor)) {\n\t\tif (ret != -EINVAL)\n\t\t\terr(\"register (miss=%d, wp=%d, minor=%d) failed \"\n\t\t\t    \"with wrong errno=%d\", miss, wp, minor, ret);\n\t\treturn;\n\t}\n\n\t \n\tif (miss)\n\t\texpected |= BIT_ULL(_UFFDIO_COPY);\n\tif (wp)\n\t\texpected |= BIT_ULL(_UFFDIO_WRITEPROTECT);\n\tif (minor)\n\t\texpected |= BIT_ULL(_UFFDIO_CONTINUE);\n\n\tif ((ioctls & expected) != expected)\n\t\terr(\"unexpected uffdio_register.ioctls \"\n\t\t    \"(miss=%d, wp=%d, minor=%d): expected=0x%\"PRIx64\", \"\n\t\t    \"returned=0x%\"PRIx64, miss, wp, minor, expected, ioctls);\n\n\tif (uffd_unregister(uffd, area_dst, page_size))\n\t\terr(\"unregister\");\n}\n\nstatic void uffd_register_ioctls_test(uffd_test_args_t *args)\n{\n\tint miss, wp, minor;\n\n\tfor (miss = 0; miss <= 1; miss++)\n\t\tfor (wp = 0; wp <= 1; wp++)\n\t\t\tfor (minor = 0; minor <= 1; minor++)\n\t\t\t\tdo_register_ioctls_test(args, miss, wp, minor);\n\n\tuffd_test_pass();\n}\n\nuffd_test_case_t uffd_tests[] = {\n\t{\n\t\t \n\t\t.name = \"register-ioctls\",\n\t\t.uffd_fn = uffd_register_ioctls_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_MISSING_HUGETLBFS |\n\t\tUFFD_FEATURE_MISSING_SHMEM |\n\t\tUFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM |\n\t\tUFFD_FEATURE_MINOR_HUGETLBFS |\n\t\tUFFD_FEATURE_MINOR_SHMEM,\n\t},\n\t{\n\t\t.name = \"zeropage\",\n\t\t.uffd_fn = uffd_zeropage_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = 0,\n\t},\n\t{\n\t\t.name = \"wp-fork\",\n\t\t.uffd_fn = uffd_wp_fork_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM,\n\t},\n\t{\n\t\t.name = \"wp-fork-with-event\",\n\t\t.uffd_fn = uffd_wp_fork_with_event_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM |\n\t\t \n\t\tUFFD_FEATURE_EVENT_FORK,\n\t},\n\t{\n\t\t.name = \"wp-fork-pin\",\n\t\t.uffd_fn = uffd_wp_fork_pin_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM,\n\t},\n\t{\n\t\t.name = \"wp-fork-pin-with-event\",\n\t\t.uffd_fn = uffd_wp_fork_pin_with_event_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM |\n\t\t \n\t\tUFFD_FEATURE_EVENT_FORK,\n\t},\n\t{\n\t\t.name = \"wp-unpopulated\",\n\t\t.uffd_fn = uffd_wp_unpopulated_test,\n\t\t.mem_targets = MEM_ANON,\n\t\t.uffd_feature_required =\n\t\tUFFD_FEATURE_PAGEFAULT_FLAG_WP | UFFD_FEATURE_WP_UNPOPULATED,\n\t},\n\t{\n\t\t.name = \"minor\",\n\t\t.uffd_fn = uffd_minor_test,\n\t\t.mem_targets = MEM_SHMEM | MEM_HUGETLB,\n\t\t.uffd_feature_required =\n\t\tUFFD_FEATURE_MINOR_HUGETLBFS | UFFD_FEATURE_MINOR_SHMEM,\n\t},\n\t{\n\t\t.name = \"minor-wp\",\n\t\t.uffd_fn = uffd_minor_wp_test,\n\t\t.mem_targets = MEM_SHMEM | MEM_HUGETLB,\n\t\t.uffd_feature_required =\n\t\tUFFD_FEATURE_MINOR_HUGETLBFS | UFFD_FEATURE_MINOR_SHMEM |\n\t\tUFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\t \n\t\tUFFD_FEATURE_WP_UNPOPULATED,\n\t},\n\t{\n\t\t.name = \"minor-collapse\",\n\t\t.uffd_fn = uffd_minor_collapse_test,\n\t\t \n\t\t.mem_targets = MEM_SHMEM,\n\t\t \n\t\t.uffd_feature_required = UFFD_FEATURE_MINOR_SHMEM,\n\t},\n\t{\n\t\t.name = \"sigbus\",\n\t\t.uffd_fn = uffd_sigbus_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_SIGBUS |\n\t\tUFFD_FEATURE_EVENT_FORK,\n\t},\n\t{\n\t\t.name = \"sigbus-wp\",\n\t\t.uffd_fn = uffd_sigbus_wp_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_SIGBUS |\n\t\tUFFD_FEATURE_EVENT_FORK | UFFD_FEATURE_PAGEFAULT_FLAG_WP,\n\t},\n\t{\n\t\t.name = \"events\",\n\t\t.uffd_fn = uffd_events_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_EVENT_FORK |\n\t\tUFFD_FEATURE_EVENT_REMAP | UFFD_FEATURE_EVENT_REMOVE,\n\t},\n\t{\n\t\t.name = \"events-wp\",\n\t\t.uffd_fn = uffd_events_wp_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_EVENT_FORK |\n\t\tUFFD_FEATURE_EVENT_REMAP | UFFD_FEATURE_EVENT_REMOVE |\n\t\tUFFD_FEATURE_PAGEFAULT_FLAG_WP |\n\t\tUFFD_FEATURE_WP_HUGETLBFS_SHMEM,\n\t},\n\t{\n\t\t.name = \"poison\",\n\t\t.uffd_fn = uffd_poison_test,\n\t\t.mem_targets = MEM_ALL,\n\t\t.uffd_feature_required = UFFD_FEATURE_POISON,\n\t},\n};\n\nstatic void usage(const char *prog)\n{\n\tprintf(\"usage: %s [-f TESTNAME]\\n\", prog);\n\tputs(\"\");\n\tputs(\" -f: test name to filter (e.g., event)\");\n\tputs(\" -h: show the help msg\");\n\tputs(\" -l: list tests only\");\n\tputs(\"\");\n\texit(KSFT_FAIL);\n}\n\nint main(int argc, char *argv[])\n{\n\tint n_tests = sizeof(uffd_tests) / sizeof(uffd_test_case_t);\n\tint n_mems = sizeof(mem_types) / sizeof(mem_type_t);\n\tconst char *test_filter = NULL;\n\tbool list_only = false;\n\tuffd_test_case_t *test;\n\tmem_type_t *mem_type;\n\tuffd_test_args_t args;\n\tconst char *errmsg;\n\tint has_uffd, opt;\n\tint i, j;\n\n\twhile ((opt = getopt(argc, argv, \"f:hl\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'f':\n\t\t\ttest_filter = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_only = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\t \n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!test_filter && !list_only) {\n\t\thas_uffd = test_uffd_api(false);\n\t\thas_uffd |= test_uffd_api(true);\n\n\t\tif (!has_uffd) {\n\t\t\tprintf(\"Userfaultfd not supported or unprivileged, skip all tests\\n\");\n\t\t\texit(KSFT_SKIP);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n_tests; i++) {\n\t\ttest = &uffd_tests[i];\n\t\tif (test_filter && !strstr(test->name, test_filter))\n\t\t\tcontinue;\n\t\tif (list_only) {\n\t\t\tprintf(\"%s\\n\", test->name);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < n_mems; j++) {\n\t\t\tmem_type = &mem_types[j];\n\t\t\tif (!(test->mem_targets & mem_type->mem_flag))\n\t\t\t\tcontinue;\n\n\t\t\tuffd_test_start(\"%s on %s\", test->name, mem_type->name);\n\t\t\tif (!uffd_feature_supported(test)) {\n\t\t\t\tuffd_test_skip(\"feature missing\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (uffd_setup_environment(&args, test, mem_type,\n\t\t\t\t\t\t   &errmsg)) {\n\t\t\t\tuffd_test_skip(errmsg);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttest->uffd_fn(&args);\n\t\t}\n\t}\n\n\tif (!list_only)\n\t\tuffd_test_report();\n\n\treturn ksft_get_fail_cnt() ? KSFT_FAIL : KSFT_PASS;\n}\n\n#else  \n\n#warning \"missing __NR_userfaultfd definition\"\n\nint main(void)\n{\n\tprintf(\"Skipping %s (missing __NR_userfaultfd)\\n\", __file__);\n\treturn KSFT_SKIP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}