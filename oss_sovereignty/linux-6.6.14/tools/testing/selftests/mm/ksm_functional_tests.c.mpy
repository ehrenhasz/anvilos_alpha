{
  "module_name": "ksm_functional_tests.c",
  "hash_id": "581e18e7aba9c5437c15adb3cad7e53fe4bf124673b5474a0e72108ce978e491",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/ksm_functional_tests.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <linux/userfaultfd.h>\n\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\n#define KiB 1024u\n#define MiB (1024 * KiB)\n\nstatic int mem_fd;\nstatic int ksm_fd;\nstatic int ksm_full_scans_fd;\nstatic int proc_self_ksm_stat_fd;\nstatic int proc_self_ksm_merging_pages_fd;\nstatic int ksm_use_zero_pages_fd;\nstatic int pagemap_fd;\nstatic size_t pagesize;\n\nstatic bool range_maps_duplicates(char *addr, unsigned long size)\n{\n\tunsigned long offs_a, offs_b, pfn_a, pfn_b;\n\n\t \n\tfor (offs_a = 0; offs_a < size; offs_a += pagesize) {\n\t\tpfn_a = pagemap_get_pfn(pagemap_fd, addr + offs_a);\n\t\t \n\t\tif (pfn_a == -1ul || !pfn_a)\n\t\t\tcontinue;\n\n\t\tfor (offs_b = offs_a + pagesize; offs_b < size;\n\t\t     offs_b += pagesize) {\n\t\t\tpfn_b = pagemap_get_pfn(pagemap_fd, addr + offs_b);\n\t\t\tif (pfn_b == -1ul || !pfn_b)\n\t\t\t\tcontinue;\n\t\t\tif (pfn_a == pfn_b)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic long get_my_ksm_zero_pages(void)\n{\n\tchar buf[200];\n\tchar *substr_ksm_zero;\n\tsize_t value_pos;\n\tssize_t read_size;\n\tunsigned long my_ksm_zero_pages;\n\n\tif (!proc_self_ksm_stat_fd)\n\t\treturn 0;\n\n\tread_size = pread(proc_self_ksm_stat_fd, buf, sizeof(buf) - 1, 0);\n\tif (read_size < 0)\n\t\treturn -errno;\n\n\tbuf[read_size] = 0;\n\n\tsubstr_ksm_zero = strstr(buf, \"ksm_zero_pages\");\n\tif (!substr_ksm_zero)\n\t\treturn 0;\n\n\tvalue_pos = strcspn(substr_ksm_zero, \"0123456789\");\n\tmy_ksm_zero_pages = strtol(substr_ksm_zero + value_pos, NULL, 10);\n\n\treturn my_ksm_zero_pages;\n}\n\nstatic long get_my_merging_pages(void)\n{\n\tchar buf[10];\n\tssize_t ret;\n\n\tif (proc_self_ksm_merging_pages_fd < 0)\n\t\treturn proc_self_ksm_merging_pages_fd;\n\n\tret = pread(proc_self_ksm_merging_pages_fd, buf, sizeof(buf) - 1, 0);\n\tif (ret <= 0)\n\t\treturn -errno;\n\tbuf[ret] = 0;\n\n\treturn strtol(buf, NULL, 10);\n}\n\nstatic long ksm_get_full_scans(void)\n{\n\tchar buf[10];\n\tssize_t ret;\n\n\tret = pread(ksm_full_scans_fd, buf, sizeof(buf) - 1, 0);\n\tif (ret <= 0)\n\t\treturn -errno;\n\tbuf[ret] = 0;\n\n\treturn strtol(buf, NULL, 10);\n}\n\nstatic int ksm_merge(void)\n{\n\tlong start_scans, end_scans;\n\n\t \n\tstart_scans = ksm_get_full_scans();\n\tif (start_scans < 0)\n\t\treturn start_scans;\n\tif (write(ksm_fd, \"1\", 1) != 1)\n\t\treturn -errno;\n\tdo {\n\t\tend_scans = ksm_get_full_scans();\n\t\tif (end_scans < 0)\n\t\t\treturn end_scans;\n\t} while (end_scans < start_scans + 2);\n\n\treturn 0;\n}\n\nstatic int ksm_unmerge(void)\n{\n\tif (write(ksm_fd, \"2\", 1) != 1)\n\t\treturn -errno;\n\treturn 0;\n}\n\nstatic char *mmap_and_merge_range(char val, unsigned long size, int prot,\n\t\t\t\t  bool use_prctl)\n{\n\tchar *map;\n\tint ret;\n\n\t \n\tif (ksm_unmerge()) {\n\t\tksft_test_result_fail(\"Disabling (unmerging) KSM failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tif (get_my_merging_pages() > 0) {\n\t\tksft_test_result_fail(\"Still pages merged\\n\");\n\t\tgoto unmap;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ|PROT_WRITE,\n\t\t   MAP_PRIVATE|MAP_ANON, -1, 0);\n\tif (map == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn MAP_FAILED;\n\t}\n\n\t \n\tif (madvise(map, size, MADV_NOHUGEPAGE) && errno != EINVAL) {\n\t\tksft_test_result_fail(\"MADV_NOHUGEPAGE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tmemset(map, val, size);\n\n\tif (mprotect(map, size, prot)) {\n\t\tksft_test_result_skip(\"mprotect() failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tif (use_prctl) {\n\t\tret = prctl(PR_SET_MEMORY_MERGE, 1, 0, 0, 0);\n\t\tif (ret < 0 && errno == EINVAL) {\n\t\t\tksft_test_result_skip(\"PR_SET_MEMORY_MERGE not supported\\n\");\n\t\t\tgoto unmap;\n\t\t} else if (ret) {\n\t\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=1 failed\\n\");\n\t\t\tgoto unmap;\n\t\t}\n\t} else if (madvise(map, size, MADV_MERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_MERGEABLE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tif (ksm_merge()) {\n\t\tksft_test_result_fail(\"Running KSM failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tif (val && !get_my_merging_pages()) {\n\t\tksft_test_result_fail(\"No pages got merged\\n\");\n\t\tgoto unmap;\n\t}\n\n\treturn map;\nunmap:\n\tmunmap(map, size);\n\treturn MAP_FAILED;\n}\n\nstatic void test_unmerge(void)\n{\n\tconst unsigned int size = 2 * MiB;\n\tchar *map;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tmap = mmap_and_merge_range(0xcf, size, PROT_READ | PROT_WRITE, false);\n\tif (map == MAP_FAILED)\n\t\treturn;\n\n\tif (madvise(map, size, MADV_UNMERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_UNMERGEABLE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t \"Pages were unmerged\\n\");\nunmap:\n\tmunmap(map, size);\n}\n\nstatic void test_unmerge_zero_pages(void)\n{\n\tconst unsigned int size = 2 * MiB;\n\tchar *map;\n\tunsigned int offs;\n\tunsigned long pages_expected;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tif (proc_self_ksm_stat_fd < 0) {\n\t\tksft_test_result_skip(\"open(\\\"/proc/self/ksm_stat\\\") failed\\n\");\n\t\treturn;\n\t}\n\tif (ksm_use_zero_pages_fd < 0) {\n\t\tksft_test_result_skip(\"open \\\"/sys/kernel/mm/ksm/use_zero_pages\\\" failed\\n\");\n\t\treturn;\n\t}\n\tif (write(ksm_use_zero_pages_fd, \"1\", 1) != 1) {\n\t\tksft_test_result_skip(\"write \\\"/sys/kernel/mm/ksm/use_zero_pages\\\" failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmap = mmap_and_merge_range(0x00, size, PROT_READ | PROT_WRITE, false);\n\tif (map == MAP_FAILED)\n\t\treturn;\n\n\t \n\tpages_expected = size / pagesize;\n\tif (pages_expected != get_my_ksm_zero_pages()) {\n\t\tksft_test_result_fail(\"'ksm_zero_pages' updated after merging\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tif (madvise(map, size / 2, MADV_UNMERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_UNMERGEABLE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tpages_expected /= 2;\n\tif (pages_expected != get_my_ksm_zero_pages()) {\n\t\tksft_test_result_fail(\"'ksm_zero_pages' updated after unmerging\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tfor (offs = size / 2; offs < size; offs += pagesize)\n\t\t*((unsigned int *)&map[offs]) = offs;\n\n\t \n\tif (get_my_ksm_zero_pages()) {\n\t\tksft_test_result_fail(\"'ksm_zero_pages' updated after write fault\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t\"KSM zero pages were unmerged\\n\");\nunmap:\n\tmunmap(map, size);\n}\n\nstatic void test_unmerge_discarded(void)\n{\n\tconst unsigned int size = 2 * MiB;\n\tchar *map;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tmap = mmap_and_merge_range(0xcf, size, PROT_READ | PROT_WRITE, false);\n\tif (map == MAP_FAILED)\n\t\treturn;\n\n\t \n\tif (madvise(map, size / 2, MADV_DONTNEED)) {\n\t\tksft_test_result_fail(\"MADV_DONTNEED failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tif (madvise(map, size, MADV_UNMERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_UNMERGEABLE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t \"Pages were unmerged\\n\");\nunmap:\n\tmunmap(map, size);\n}\n\n#ifdef __NR_userfaultfd\nstatic void test_unmerge_uffd_wp(void)\n{\n\tstruct uffdio_writeprotect uffd_writeprotect;\n\tconst unsigned int size = 2 * MiB;\n\tstruct uffdio_api uffdio_api;\n\tchar *map;\n\tint uffd;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tmap = mmap_and_merge_range(0xcf, size, PROT_READ | PROT_WRITE, false);\n\tif (map == MAP_FAILED)\n\t\treturn;\n\n\t \n\tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\tif (uffd < 0) {\n\t\tksft_test_result_skip(\"__NR_userfaultfd failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\t \n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = UFFD_FEATURE_PAGEFAULT_FLAG_WP;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) < 0) {\n\t\tksft_test_result_fail(\"UFFDIO_API failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\tif (!(uffdio_api.features & UFFD_FEATURE_PAGEFAULT_FLAG_WP)) {\n\t\tksft_test_result_skip(\"UFFD_FEATURE_PAGEFAULT_FLAG_WP not available\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\t \n\tif (uffd_register(uffd, map, size, false, true, false)) {\n\t\tksft_test_result_fail(\"UFFDIO_REGISTER_MODE_WP failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\t \n\tuffd_writeprotect.range.start = (unsigned long) map;\n\tuffd_writeprotect.range.len = size;\n\tuffd_writeprotect.mode = UFFDIO_WRITEPROTECT_MODE_WP;\n\tif (ioctl(uffd, UFFDIO_WRITEPROTECT, &uffd_writeprotect)) {\n\t\tksft_test_result_fail(\"UFFDIO_WRITEPROTECT failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\tif (madvise(map, size, MADV_UNMERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_UNMERGEABLE failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t \"Pages were unmerged\\n\");\nclose_uffd:\n\tclose(uffd);\nunmap:\n\tmunmap(map, size);\n}\n#endif\n\n \nstatic void test_prctl(void)\n{\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tret = prctl(PR_SET_MEMORY_MERGE, 1, 0, 0, 0);\n\tif (ret < 0 && errno == EINVAL) {\n\t\tksft_test_result_skip(\"PR_SET_MEMORY_MERGE not supported\\n\");\n\t\treturn;\n\t} else if (ret) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=1 failed\\n\");\n\t\treturn;\n\t}\n\n\tret = prctl(PR_GET_MEMORY_MERGE, 0, 0, 0, 0);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"PR_GET_MEMORY_MERGE failed\\n\");\n\t\treturn;\n\t} else if (ret != 1) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=1 not effective\\n\");\n\t\treturn;\n\t}\n\n\tret = prctl(PR_SET_MEMORY_MERGE, 0, 0, 0, 0);\n\tif (ret) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=0 failed\\n\");\n\t\treturn;\n\t}\n\n\tret = prctl(PR_GET_MEMORY_MERGE, 0, 0, 0, 0);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"PR_GET_MEMORY_MERGE failed\\n\");\n\t\treturn;\n\t} else if (ret != 0) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=0 not effective\\n\");\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"Setting/clearing PR_SET_MEMORY_MERGE works\\n\");\n}\n\n \nstatic void test_prctl_fork(void)\n{\n\tint ret, status;\n\tpid_t child_pid;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tret = prctl(PR_SET_MEMORY_MERGE, 1, 0, 0, 0);\n\tif (ret < 0 && errno == EINVAL) {\n\t\tksft_test_result_skip(\"PR_SET_MEMORY_MERGE not supported\\n\");\n\t\treturn;\n\t} else if (ret) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=1 failed\\n\");\n\t\treturn;\n\t}\n\n\tchild_pid = fork();\n\tif (!child_pid) {\n\t\texit(prctl(PR_GET_MEMORY_MERGE, 0, 0, 0, 0));\n\t} else if (child_pid < 0) {\n\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\treturn;\n\t}\n\n\tif (waitpid(child_pid, &status, 0) < 0) {\n\t\tksft_test_result_fail(\"waitpid() failed\\n\");\n\t\treturn;\n\t} else if (WEXITSTATUS(status) != 1) {\n\t\tksft_test_result_fail(\"unexpected PR_GET_MEMORY_MERGE result in child\\n\");\n\t\treturn;\n\t}\n\n\tif (prctl(PR_SET_MEMORY_MERGE, 0, 0, 0, 0)) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=0 failed\\n\");\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"PR_SET_MEMORY_MERGE value is inherited\\n\");\n}\n\nstatic void test_prctl_unmerge(void)\n{\n\tconst unsigned int size = 2 * MiB;\n\tchar *map;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tmap = mmap_and_merge_range(0xcf, size, PROT_READ | PROT_WRITE, true);\n\tif (map == MAP_FAILED)\n\t\treturn;\n\n\tif (prctl(PR_SET_MEMORY_MERGE, 0, 0, 0, 0)) {\n\t\tksft_test_result_fail(\"PR_SET_MEMORY_MERGE=0 failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t \"Pages were unmerged\\n\");\nunmap:\n\tmunmap(map, size);\n}\n\nstatic void test_prot_none(void)\n{\n\tconst unsigned int size = 2 * MiB;\n\tchar *map;\n\tint i;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\tmap = mmap_and_merge_range(0x11, size, PROT_NONE, false);\n\tif (map == MAP_FAILED)\n\t\tgoto unmap;\n\n\t \n\tfor (i = 0; i < size / 2; i += pagesize) {\n\t\tlseek(mem_fd, (uintptr_t) map + i, SEEK_SET);\n\t\tif (write(mem_fd, &i, sizeof(i)) != sizeof(i)) {\n\t\t\tksft_test_result_fail(\"ptrace write failed\\n\");\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\t \n\tif (madvise(map + size / 2, size / 2, MADV_UNMERGEABLE)) {\n\t\tksft_test_result_fail(\"MADV_UNMERGEABLE failed\\n\");\n\t\tgoto unmap;\n\t}\n\n\tksft_test_result(!range_maps_duplicates(map, size),\n\t\t\t \"Pages were unmerged\\n\");\nunmap:\n\tmunmap(map, size);\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned int tests = 7;\n\tint err;\n\n#ifdef __NR_userfaultfd\n\ttests++;\n#endif\n\n\tksft_print_header();\n\tksft_set_plan(tests);\n\n\tpagesize = getpagesize();\n\n\tmem_fd = open(\"/proc/self/mem\", O_RDWR);\n\tif (mem_fd < 0)\n\t\tksft_exit_fail_msg(\"opening /proc/self/mem failed\\n\");\n\tksm_fd = open(\"/sys/kernel/mm/ksm/run\", O_RDWR);\n\tif (ksm_fd < 0)\n\t\tksft_exit_skip(\"open(\\\"/sys/kernel/mm/ksm/run\\\") failed\\n\");\n\tksm_full_scans_fd = open(\"/sys/kernel/mm/ksm/full_scans\", O_RDONLY);\n\tif (ksm_full_scans_fd < 0)\n\t\tksft_exit_skip(\"open(\\\"/sys/kernel/mm/ksm/full_scans\\\") failed\\n\");\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\tksft_exit_skip(\"open(\\\"/proc/self/pagemap\\\") failed\\n\");\n\tproc_self_ksm_stat_fd = open(\"/proc/self/ksm_stat\", O_RDONLY);\n\tproc_self_ksm_merging_pages_fd = open(\"/proc/self/ksm_merging_pages\",\n\t\t\t\t\t      O_RDONLY);\n\tksm_use_zero_pages_fd = open(\"/sys/kernel/mm/ksm/use_zero_pages\", O_RDWR);\n\n\ttest_unmerge();\n\ttest_unmerge_zero_pages();\n\ttest_unmerge_discarded();\n#ifdef __NR_userfaultfd\n\ttest_unmerge_uffd_wp();\n#endif\n\n\ttest_prot_none();\n\n\ttest_prctl();\n\ttest_prctl_fork();\n\ttest_prctl_unmerge();\n\n\terr = ksft_get_fail_cnt();\n\tif (err)\n\t\tksft_exit_fail_msg(\"%d out of %d tests failed\\n\",\n\t\t\t\t   err, ksft_test_num());\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}