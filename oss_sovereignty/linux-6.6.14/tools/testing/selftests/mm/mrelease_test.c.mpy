{
  "module_name": "mrelease_test.c",
  "hash_id": "b415edb110b3f620814e586b319e70142da12bd52488b3bbded853f2517727c1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mrelease_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <asm-generic/unistd.h>\n#include \"vm_util.h\"\n#include \"../kselftest.h\"\n\n#define MB(x) (x << 20)\n#define MAX_SIZE_MB 1024\n\nstatic int alloc_noexit(unsigned long nr_pages, int pipefd)\n{\n\tint ppid = getppid();\n\tint timeout = 10;  \n\tunsigned long i;\n\tchar *buf;\n\n\tbuf = (char *)mmap(NULL, nr_pages * psize(), PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANON, 0, 0);\n\tif (buf == MAP_FAILED) {\n\t\tperror(\"mmap failed, halting the test\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\t*((unsigned long *)(buf + (i * psize()))) = i;\n\n\t \n\tif (write(pipefd, \"\", 1) < 0) {\n\t\tperror(\"write\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\t \n\twhile (getppid() == ppid && timeout > 0) {\n\t\tsleep(1);\n\t\ttimeout--;\n\t}\n\n\tmunmap(buf, nr_pages * psize());\n\n\treturn (timeout > 0) ? KSFT_PASS : KSFT_FAIL;\n}\n\n \nstatic void run_negative_tests(int pidfd)\n{\n\tint res;\n\t \n\tif (!syscall(__NR_process_mrelease, pidfd, (unsigned int)-1) ||\n\t\t\terrno != EINVAL) {\n\t\tres = (errno == ENOSYS ? KSFT_SKIP : KSFT_FAIL);\n\t\tperror(\"process_mrelease with wrong flags\");\n\t\texit(res);\n\t}\n\t \n\tif (!syscall(__NR_process_mrelease, pidfd, 0) || errno != EINVAL) {\n\t\tres = (errno == ENOSYS ? KSFT_SKIP : KSFT_FAIL);\n\t\tperror(\"process_mrelease on a live process\");\n\t\texit(res);\n\t}\n}\n\nstatic int child_main(int pipefd[], size_t size)\n{\n\tint res;\n\n\t \n\tclose(pipefd[0]);\n\tres = alloc_noexit(MB(size) / psize(), pipefd[1]);\n\tclose(pipefd[1]);\n\treturn res;\n}\n\nint main(void)\n{\n\tint pipefd[2], pidfd;\n\tbool success, retry;\n\tsize_t size;\n\tpid_t pid;\n\tchar byte;\n\tint res;\n\n\t \n\tif (!syscall(__NR_process_mrelease, -1, 0) || errno != EBADF) {\n\t\tres = (errno == ENOSYS ? KSFT_SKIP : KSFT_FAIL);\n\t\tperror(\"process_mrelease with wrong pidfd\");\n\t\texit(res);\n\t}\n\n\t \n\tsize = 1;\nretry:\n\t \n\tif (pipe(pipefd)) {\n\t\tperror(\"pipe\");\n\t\texit(KSFT_FAIL);\n\t}\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\texit(KSFT_FAIL);\n\t}\n\n\tif (pid == 0) {\n\t\t \n\t\tres = child_main(pipefd, size);\n\t\texit(res);\n\t}\n\n\t \n\tclose(pipefd[1]);\n\t \n\tres = read(pipefd[0], &byte, 1);\n\tclose(pipefd[0]);\n\tif (res < 0) {\n\t\tperror(\"read\");\n\t\tif (!kill(pid, SIGKILL))\n\t\t\twaitpid(pid, NULL, 0);\n\t\texit(KSFT_FAIL);\n\t}\n\n\tpidfd = syscall(__NR_pidfd_open, pid, 0);\n\tif (pidfd < 0) {\n\t\tperror(\"pidfd_open\");\n\t\tif (!kill(pid, SIGKILL))\n\t\t\twaitpid(pid, NULL, 0);\n\t\texit(KSFT_FAIL);\n\t}\n\n\t \n\trun_negative_tests(pidfd);\n\n\tif (kill(pid, SIGKILL)) {\n\t\tres = (errno == ENOSYS ? KSFT_SKIP : KSFT_FAIL);\n\t\tperror(\"kill\");\n\t\texit(res);\n\t}\n\n\tsuccess = (syscall(__NR_process_mrelease, pidfd, 0) == 0);\n\tif (!success) {\n\t\t \n\t\tif (errno == ESRCH) {\n\t\t\tretry = (size <= MAX_SIZE_MB);\n\t\t} else {\n\t\t\tres = (errno == ENOSYS ? KSFT_SKIP : KSFT_FAIL);\n\t\t\tperror(\"process_mrelease\");\n\t\t\twaitpid(pid, NULL, 0);\n\t\t\texit(res);\n\t\t}\n\t}\n\n\t \n\tif (waitpid(pid, NULL, 0) < 0) {\n\t\tperror(\"waitpid\");\n\t\texit(KSFT_FAIL);\n\t}\n\tclose(pidfd);\n\n\tif (!success) {\n\t\tif (retry) {\n\t\t\tsize *= 2;\n\t\t\tgoto retry;\n\t\t}\n\t\tprintf(\"All process_mrelease attempts failed!\\n\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\tprintf(\"Success reaping a child with %zuMB of memory allocations\\n\",\n\t       size);\n\treturn KSFT_PASS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}