{
  "module_name": "gup_longterm.c",
  "hash_id": "7660120fa9babfd0cf806a82a8af07ee9fcdaf081d27f24113bd27093f1c1d00",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/gup_longterm.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <sys/vfs.h>\n#include <linux/magic.h>\n#include <linux/memfd.h>\n\n#include \"local_config.h\"\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n#include <liburing.h>\n#endif  \n\n#include \"../../../../mm/gup_test.h\"\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\nstatic size_t pagesize;\nstatic int nr_hugetlbsizes;\nstatic size_t hugetlbsizes[10];\nstatic int gup_fd;\n\nstatic __fsword_t get_fs_type(int fd)\n{\n\tstruct statfs fs;\n\tint ret;\n\n\tdo {\n\t\tret = fstatfs(fd, &fs);\n\t} while (ret && errno == EINTR);\n\n\treturn ret ? 0 : fs.f_type;\n}\n\nstatic bool fs_is_unknown(__fsword_t fs_type)\n{\n\t \n\tswitch (fs_type) {\n\tcase TMPFS_MAGIC:\n\tcase HUGETLBFS_MAGIC:\n\tcase BTRFS_SUPER_MAGIC:\n\tcase EXT4_SUPER_MAGIC:\n\tcase XFS_SUPER_MAGIC:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool fs_supports_writable_longterm_pinning(__fsword_t fs_type)\n{\n\tassert(!fs_is_unknown(fs_type));\n\tswitch (fs_type) {\n\tcase TMPFS_MAGIC:\n\tcase HUGETLBFS_MAGIC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nenum test_type {\n\tTEST_TYPE_RO,\n\tTEST_TYPE_RO_FAST,\n\tTEST_TYPE_RW,\n\tTEST_TYPE_RW_FAST,\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n\tTEST_TYPE_IOURING,\n#endif  \n};\n\nstatic void do_test(int fd, size_t size, enum test_type type, bool shared)\n{\n\t__fsword_t fs_type = get_fs_type(fd);\n\tbool should_work;\n\tchar *mem;\n\tint ret;\n\n\tif (ftruncate(fd, size)) {\n\t\tksft_test_result_fail(\"ftruncate() failed\\n\");\n\t\treturn;\n\t}\n\n\tif (fallocate(fd, 0, 0, size)) {\n\t\tif (size == pagesize)\n\t\t\tksft_test_result_fail(\"fallocate() failed\\n\");\n\t\telse\n\t\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\treturn;\n\t}\n\n\tmem = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t   shared ? MAP_SHARED : MAP_PRIVATE, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tif (size == pagesize || shared)\n\t\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\telse\n\t\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemset(mem, 0, size);\n\n\tswitch (type) {\n\tcase TEST_TYPE_RO:\n\tcase TEST_TYPE_RO_FAST:\n\tcase TEST_TYPE_RW:\n\tcase TEST_TYPE_RW_FAST: {\n\t\tstruct pin_longterm_test args;\n\t\tconst bool fast = type == TEST_TYPE_RO_FAST ||\n\t\t\t\t  type == TEST_TYPE_RW_FAST;\n\t\tconst bool rw = type == TEST_TYPE_RW ||\n\t\t\t\ttype == TEST_TYPE_RW_FAST;\n\n\t\tif (gup_fd < 0) {\n\t\t\tksft_test_result_skip(\"gup_test not available\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw && shared && fs_is_unknown(fs_type)) {\n\t\t\tksft_test_result_skip(\"Unknown filesystem\\n\");\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tshould_work = !shared || !rw ||\n\t\t\t      fs_supports_writable_longterm_pinning(fs_type);\n\n\t\targs.addr = (__u64)(uintptr_t)mem;\n\t\targs.size = size;\n\t\targs.flags = fast ? PIN_LONGTERM_TEST_FLAG_USE_FAST : 0;\n\t\targs.flags |= rw ? PIN_LONGTERM_TEST_FLAG_USE_WRITE : 0;\n\t\tret = ioctl(gup_fd, PIN_LONGTERM_TEST_START, &args);\n\t\tif (ret && errno == EINVAL) {\n\t\t\tksft_test_result_skip(\"PIN_LONGTERM_TEST_START failed\\n\");\n\t\t\tbreak;\n\t\t} else if (ret && errno == EFAULT) {\n\t\t\tksft_test_result(!should_work, \"Should have failed\\n\");\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tksft_test_result_fail(\"PIN_LONGTERM_TEST_START failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ioctl(gup_fd, PIN_LONGTERM_TEST_STOP))\n\t\t\tksft_print_msg(\"[INFO] PIN_LONGTERM_TEST_STOP failed\\n\");\n\n\t\t \n\t\tksft_test_result(should_work, \"Should have worked\\n\");\n\t\tbreak;\n\t}\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n\tcase TEST_TYPE_IOURING: {\n\t\tstruct io_uring ring;\n\t\tstruct iovec iov;\n\n\t\t \n\t\tif (shared && fs_is_unknown(fs_type)) {\n\t\t\tksft_test_result_skip(\"Unknown filesystem\\n\");\n\t\t\treturn;\n\t\t}\n\t\tshould_work = !shared ||\n\t\t\t      fs_supports_writable_longterm_pinning(fs_type);\n\n\t\t \n\t\tret = io_uring_queue_init(1, &ring, 0);\n\t\tif (ret < 0) {\n\t\t\tksft_test_result_skip(\"io_uring_queue_init() failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tiov.iov_base = mem;\n\t\tiov.iov_len = size;\n\t\tret = io_uring_register_buffers(&ring, &iov, 1);\n\t\t \n\t\tif (ret && (errno == ENOSPC || errno == EOPNOTSUPP ||\n\t\t\t    errno == EFAULT)) {\n\t\t\tksft_test_result(!should_work, \"Should have failed\\n\");\n\t\t} else if (ret) {\n\t\t\t \n\t\t\tksft_test_result_skip(\"io_uring_register_buffers() failed\\n\");\n\t\t} else {\n\t\t\tksft_test_result(should_work, \"Should have worked\\n\");\n\t\t\tio_uring_unregister_buffers(&ring);\n\t\t}\n\n\t\tio_uring_queue_exit(&ring);\n\t\tbreak;\n\t}\n#endif  \n\tdefault:\n\t\tassert(false);\n\t}\n\n\tmunmap(mem, size);\n}\n\ntypedef void (*test_fn)(int fd, size_t size);\n\nstatic void run_with_memfd(test_fn fn, const char *desc)\n{\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with memfd\\n\", desc);\n\n\tfd = memfd_create(\"test\", 0);\n\tif (fd < 0) {\n\t\tksft_test_result_fail(\"memfd_create() failed\\n\");\n\t\treturn;\n\t}\n\n\tfn(fd, pagesize);\n\tclose(fd);\n}\n\nstatic void run_with_tmpfile(test_fn fn, const char *desc)\n{\n\tFILE *file;\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with tmpfile\\n\", desc);\n\n\tfile = tmpfile();\n\tif (!file) {\n\t\tksft_test_result_fail(\"tmpfile() failed\\n\");\n\t\treturn;\n\t}\n\n\tfd = fileno(file);\n\tif (fd < 0) {\n\t\tksft_test_result_fail(\"fileno() failed\\n\");\n\t\treturn;\n\t}\n\n\tfn(fd, pagesize);\n\tfclose(file);\n}\n\nstatic void run_with_local_tmpfile(test_fn fn, const char *desc)\n{\n\tchar filename[] = __FILE__\"_tmpfile_XXXXXX\";\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with local tmpfile\\n\", desc);\n\n\tfd = mkstemp(filename);\n\tif (fd < 0) {\n\t\tksft_test_result_fail(\"mkstemp() failed\\n\");\n\t\treturn;\n\t}\n\n\tif (unlink(filename)) {\n\t\tksft_test_result_fail(\"unlink() failed\\n\");\n\t\tgoto close;\n\t}\n\n\tfn(fd, pagesize);\nclose:\n\tclose(fd);\n}\n\nstatic void run_with_memfd_hugetlb(test_fn fn, const char *desc,\n\t\t\t\t   size_t hugetlbsize)\n{\n\tint flags = MFD_HUGETLB;\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with memfd hugetlb (%zu kB)\\n\", desc,\n\t\t       hugetlbsize / 1024);\n\n\tflags |= __builtin_ctzll(hugetlbsize) << MFD_HUGE_SHIFT;\n\n\tfd = memfd_create(\"test\", flags);\n\tif (fd < 0) {\n\t\tksft_test_result_skip(\"memfd_create() failed\\n\");\n\t\treturn;\n\t}\n\n\tfn(fd, hugetlbsize);\n\tclose(fd);\n}\n\nstruct test_case {\n\tconst char *desc;\n\ttest_fn fn;\n};\n\nstatic void test_shared_rw_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RW, true);\n}\n\nstatic void test_shared_rw_fast_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RW_FAST, true);\n}\n\nstatic void test_shared_ro_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RO, true);\n}\n\nstatic void test_shared_ro_fast_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RO_FAST, true);\n}\n\nstatic void test_private_rw_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RW, false);\n}\n\nstatic void test_private_rw_fast_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RW_FAST, false);\n}\n\nstatic void test_private_ro_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RO, false);\n}\n\nstatic void test_private_ro_fast_pin(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_RO_FAST, false);\n}\n\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\nstatic void test_shared_iouring(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_IOURING, true);\n}\n\nstatic void test_private_iouring(int fd, size_t size)\n{\n\tdo_test(fd, size, TEST_TYPE_IOURING, false);\n}\n#endif  \n\nstatic const struct test_case test_cases[] = {\n\t{\n\t\t\"R/W longterm GUP pin in MAP_SHARED file mapping\",\n\t\ttest_shared_rw_pin,\n\t},\n\t{\n\t\t\"R/W longterm GUP-fast pin in MAP_SHARED file mapping\",\n\t\ttest_shared_rw_fast_pin,\n\t},\n\t{\n\t\t\"R/O longterm GUP pin in MAP_SHARED file mapping\",\n\t\ttest_shared_ro_pin,\n\t},\n\t{\n\t\t\"R/O longterm GUP-fast pin in MAP_SHARED file mapping\",\n\t\ttest_shared_ro_fast_pin,\n\t},\n\t{\n\t\t\"R/W longterm GUP pin in MAP_PRIVATE file mapping\",\n\t\ttest_private_rw_pin,\n\t},\n\t{\n\t\t\"R/W longterm GUP-fast pin in MAP_PRIVATE file mapping\",\n\t\ttest_private_rw_fast_pin,\n\t},\n\t{\n\t\t\"R/O longterm GUP pin in MAP_PRIVATE file mapping\",\n\t\ttest_private_ro_pin,\n\t},\n\t{\n\t\t\"R/O longterm GUP-fast pin in MAP_PRIVATE file mapping\",\n\t\ttest_private_ro_fast_pin,\n\t},\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n\t{\n\t\t\"io_uring fixed buffer with MAP_SHARED file mapping\",\n\t\ttest_shared_iouring,\n\t},\n\t{\n\t\t\"io_uring fixed buffer with MAP_PRIVATE file mapping\",\n\t\ttest_private_iouring,\n\t},\n#endif  \n};\n\nstatic void run_test_case(struct test_case const *test_case)\n{\n\tint i;\n\n\trun_with_memfd(test_case->fn, test_case->desc);\n\trun_with_tmpfile(test_case->fn, test_case->desc);\n\trun_with_local_tmpfile(test_case->fn, test_case->desc);\n\tfor (i = 0; i < nr_hugetlbsizes; i++)\n\t\trun_with_memfd_hugetlb(test_case->fn, test_case->desc,\n\t\t\t\t       hugetlbsizes[i]);\n}\n\nstatic int tests_per_test_case(void)\n{\n\treturn 3 + nr_hugetlbsizes;\n}\n\nint main(int argc, char **argv)\n{\n\tint i, err;\n\n\tpagesize = getpagesize();\n\tnr_hugetlbsizes = detect_hugetlb_page_sizes(hugetlbsizes,\n\t\t\t\t\t\t    ARRAY_SIZE(hugetlbsizes));\n\n\tksft_print_header();\n\tksft_set_plan(ARRAY_SIZE(test_cases) * tests_per_test_case());\n\n\tgup_fd = open(\"/sys/kernel/debug/gup_test\", O_RDWR);\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++)\n\t\trun_test_case(&test_cases[i]);\n\n\terr = ksft_get_fail_cnt();\n\tif (err)\n\t\tksft_exit_fail_msg(\"%d out of %d tests failed\\n\",\n\t\t\t\t   err, ksft_test_num());\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}