{
  "module_name": "mlock-random-test.c",
  "hash_id": "27c270f144ea7e8fd240668df079e8f3da23711616a569b3e733ba3ddc1828f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mlock-random-test.c",
  "human_readable_source": "\n \n#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/capability.h>\n#include <sys/mman.h>\n#include <linux/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <time.h>\n#include \"mlock2.h\"\n\n#define CHUNK_UNIT (128 * 1024)\n#define MLOCK_RLIMIT_SIZE (CHUNK_UNIT * 2)\n#define MLOCK_WITHIN_LIMIT_SIZE CHUNK_UNIT\n#define MLOCK_OUTOF_LIMIT_SIZE (CHUNK_UNIT * 3)\n\n#define TEST_LOOP 100\n#define PAGE_ALIGN(size, ps) (((size) + ((ps) - 1)) & ~((ps) - 1))\n\nint set_cap_limits(rlim_t max)\n{\n\tstruct rlimit new;\n\tcap_t cap = cap_init();\n\n\tnew.rlim_cur = max;\n\tnew.rlim_max = max;\n\tif (setrlimit(RLIMIT_MEMLOCK, &new)) {\n\t\tperror(\"setrlimit() returns error\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (cap_set_proc(cap)) {\n\t\tperror(\"cap_set_proc() returns error\\n\");\n\t\treturn -2;\n\t}\n\n\treturn 0;\n}\n\nint get_proc_locked_vm_size(void)\n{\n\tFILE *f;\n\tint ret = -1;\n\tchar line[1024] = {0};\n\tunsigned long lock_size = 0;\n\n\tf = fopen(\"/proc/self/status\", \"r\");\n\tif (!f) {\n\t\tperror(\"fopen\");\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line, 1024, f)) {\n\t\tif (strstr(line, \"VmLck\")) {\n\t\t\tret = sscanf(line, \"VmLck:\\t%8lu kB\", &lock_size);\n\t\t\tif (ret <= 0) {\n\t\t\t\tprintf(\"sscanf() on VmLck error: %s: %d\\n\",\n\t\t\t\t\t\tline, ret);\n\t\t\t\tfclose(f);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(f);\n\t\t\treturn (int)(lock_size << 10);\n\t\t}\n\t}\n\n\tperror(\"cannot parse VmLck in /proc/self/status\\n\");\n\tfclose(f);\n\treturn -1;\n}\n\n \nint get_proc_page_size(unsigned long addr)\n{\n\tFILE *smaps;\n\tchar *line;\n\tunsigned long mmupage_size = 0;\n\tsize_t size;\n\n\tsmaps = seek_to_smaps_entry(addr);\n\tif (!smaps) {\n\t\tprintf(\"Unable to parse /proc/self/smaps\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (getline(&line, &size, smaps) > 0) {\n\t\tif (!strstr(line, \"MMUPageSize\")) {\n\t\t\tfree(line);\n\t\t\tline = NULL;\n\t\t\tsize = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (sscanf(line, \"MMUPageSize:    %8lu kB\",\n\t\t\t\t\t&mmupage_size) < 1) {\n\t\t\tprintf(\"Unable to parse smaps entry for Size:%s\\n\",\n\t\t\t\t\tline);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tfree(line);\n\tif (smaps)\n\t\tfclose(smaps);\n\treturn mmupage_size << 10;\n}\n\n \nint test_mlock_within_limit(char *p, int alloc_size)\n{\n\tint i;\n\tint ret = 0;\n\tint locked_vm_size = 0;\n\tstruct rlimit cur;\n\tint page_size = 0;\n\n\tgetrlimit(RLIMIT_MEMLOCK, &cur);\n\tif (cur.rlim_cur < alloc_size) {\n\t\tprintf(\"alloc_size[%d] < %u rlimit,lead to mlock failure\\n\",\n\t\t\t\talloc_size, (unsigned int)cur.rlim_cur);\n\t\treturn -1;\n\t}\n\n\tsrand(time(NULL));\n\tfor (i = 0; i < TEST_LOOP; i++) {\n\t\t \n\t\tint is_mlock = !!(rand() % 2);\n\t\tint lock_size = rand() % alloc_size;\n\t\tint start_offset = rand() % (alloc_size - lock_size);\n\n\t\tif (is_mlock)\n\t\t\tret = mlock(p + start_offset, lock_size);\n\t\telse\n\t\t\tret = mlock2_(p + start_offset, lock_size,\n\t\t\t\t       MLOCK_ONFAULT);\n\n\t\tif (ret) {\n\t\t\tprintf(\"%s() failure at |%p(%d)| mlock:|%p(%d)|\\n\",\n\t\t\t\t\tis_mlock ? \"mlock\" : \"mlock2\",\n\t\t\t\t\tp, alloc_size,\n\t\t\t\t\tp + start_offset, lock_size);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlocked_vm_size = get_proc_locked_vm_size();\n\tpage_size = get_proc_page_size((unsigned long)p);\n\tif (page_size == 0) {\n\t\tprintf(\"cannot get proc MMUPageSize\\n\");\n\t\treturn -1;\n\t}\n\n\tif (locked_vm_size > PAGE_ALIGN(alloc_size, page_size) + page_size) {\n\t\tprintf(\"test_mlock_within_limit() left VmLck:%d on %d chunk\\n\",\n\t\t\t\tlocked_vm_size, alloc_size);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n \nint test_mlock_outof_limit(char *p, int alloc_size)\n{\n\tint i;\n\tint ret = 0;\n\tint locked_vm_size = 0, old_locked_vm_size = 0;\n\tstruct rlimit cur;\n\n\tgetrlimit(RLIMIT_MEMLOCK, &cur);\n\tif (cur.rlim_cur >= alloc_size) {\n\t\tprintf(\"alloc_size[%d] >%u rlimit, violates test condition\\n\",\n\t\t\t\talloc_size, (unsigned int)cur.rlim_cur);\n\t\treturn -1;\n\t}\n\n\told_locked_vm_size = get_proc_locked_vm_size();\n\tsrand(time(NULL));\n\tfor (i = 0; i < TEST_LOOP; i++) {\n\t\tint is_mlock = !!(rand() % 2);\n\t\tint lock_size = (rand() % (alloc_size - cur.rlim_cur))\n\t\t\t+ cur.rlim_cur;\n\t\tint start_offset = rand() % (alloc_size - lock_size);\n\n\t\tif (is_mlock)\n\t\t\tret = mlock(p + start_offset, lock_size);\n\t\telse\n\t\t\tret = mlock2_(p + start_offset, lock_size,\n\t\t\t\t\tMLOCK_ONFAULT);\n\t\tif (ret == 0) {\n\t\t\tprintf(\"%s() succeeds? on %p(%d) mlock%p(%d)\\n\",\n\t\t\t\t\tis_mlock ? \"mlock\" : \"mlock2\",\n\t\t\t\t\tp, alloc_size,\n\t\t\t\t\tp + start_offset, lock_size);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlocked_vm_size = get_proc_locked_vm_size();\n\tif (locked_vm_size != old_locked_vm_size) {\n\t\tprintf(\"tests leads to new mlocked page: old[%d], new[%d]\\n\",\n\t\t\t\told_locked_vm_size,\n\t\t\t\tlocked_vm_size);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tchar *p = NULL;\n\tint ret = 0;\n\n\tif (set_cap_limits(MLOCK_RLIMIT_SIZE))\n\t\treturn -1;\n\n\tp = malloc(MLOCK_WITHIN_LIMIT_SIZE);\n\tif (p == NULL) {\n\t\tperror(\"malloc() failure\\n\");\n\t\treturn -1;\n\t}\n\tret = test_mlock_within_limit(p, MLOCK_WITHIN_LIMIT_SIZE);\n\tif (ret)\n\t\treturn ret;\n\tmunlock(p, MLOCK_WITHIN_LIMIT_SIZE);\n\tfree(p);\n\n\n\tp = malloc(MLOCK_OUTOF_LIMIT_SIZE);\n\tif (p == NULL) {\n\t\tperror(\"malloc() failure\\n\");\n\t\treturn -1;\n\t}\n\tret = test_mlock_outof_limit(p, MLOCK_OUTOF_LIMIT_SIZE);\n\tif (ret)\n\t\treturn ret;\n\tmunlock(p, MLOCK_OUTOF_LIMIT_SIZE);\n\tfree(p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}