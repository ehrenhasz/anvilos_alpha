{
  "module_name": "mlock2-tests.c",
  "hash_id": "528dc5cea53f9560cebbd9b1beef70f0d2834f37a459d20ceaf75f8099ae5e0d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mlock2-tests.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sys/mman.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#include \"mlock2.h\"\n\n#include \"../kselftest.h\"\n\nstruct vm_boundaries {\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstatic int get_vm_area(unsigned long addr, struct vm_boundaries *area)\n{\n\tFILE *file;\n\tint ret = 1;\n\tchar line[1024] = {0};\n\tchar *end_addr;\n\tchar *stop;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (!area)\n\t\treturn ret;\n\n\tfile = fopen(\"/proc/self/maps\", \"r\");\n\tif (!file) {\n\t\tperror(\"fopen\");\n\t\treturn ret;\n\t}\n\n\tmemset(area, 0, sizeof(struct vm_boundaries));\n\n\twhile(fgets(line, 1024, file)) {\n\t\tend_addr = strchr(line, '-');\n\t\tif (!end_addr) {\n\t\t\tprintf(\"cannot parse /proc/self/maps\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t*end_addr = '\\0';\n\t\tend_addr++;\n\t\tstop = strchr(end_addr, ' ');\n\t\tif (!stop) {\n\t\t\tprintf(\"cannot parse /proc/self/maps\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsscanf(line, \"%lx\", &start);\n\t\tsscanf(end_addr, \"%lx\", &end);\n\n\t\tif (start <= addr && end > addr) {\n\t\t\tarea->start = start;\n\t\t\tarea->end = end;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfclose(file);\n\treturn ret;\n}\n\n#define VMFLAGS \"VmFlags:\"\n\nstatic bool is_vmflag_set(unsigned long addr, const char *vmflag)\n{\n\tchar *line = NULL;\n\tchar *flags;\n\tsize_t size = 0;\n\tbool ret = false;\n\tFILE *smaps;\n\n\tsmaps = seek_to_smaps_entry(addr);\n\tif (!smaps) {\n\t\tprintf(\"Unable to parse /proc/self/smaps\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (getline(&line, &size, smaps) > 0) {\n\t\tif (!strstr(line, VMFLAGS)) {\n\t\t\tfree(line);\n\t\t\tline = NULL;\n\t\t\tsize = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflags = line + strlen(VMFLAGS);\n\t\tret = (strstr(flags, vmflag) != NULL);\n\t\tgoto out;\n\t}\n\nout:\n\tfree(line);\n\tfclose(smaps);\n\treturn ret;\n}\n\n#define SIZE \"Size:\"\n#define RSS  \"Rss:\"\n#define LOCKED \"lo\"\n\nstatic unsigned long get_value_for_name(unsigned long addr, const char *name)\n{\n\tchar *line = NULL;\n\tsize_t size = 0;\n\tchar *value_ptr;\n\tFILE *smaps = NULL;\n\tunsigned long value = -1UL;\n\n\tsmaps = seek_to_smaps_entry(addr);\n\tif (!smaps) {\n\t\tprintf(\"Unable to parse /proc/self/smaps\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (getline(&line, &size, smaps) > 0) {\n\t\tif (!strstr(line, name)) {\n\t\t\tfree(line);\n\t\t\tline = NULL;\n\t\t\tsize = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue_ptr = line + strlen(name);\n\t\tif (sscanf(value_ptr, \"%lu kB\", &value) < 1) {\n\t\t\tprintf(\"Unable to parse smaps entry for Size\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tif (smaps)\n\t\tfclose(smaps);\n\tfree(line);\n\treturn value;\n}\n\nstatic bool is_vma_lock_on_fault(unsigned long addr)\n{\n\tbool locked;\n\tunsigned long vma_size, vma_rss;\n\n\tlocked = is_vmflag_set(addr, LOCKED);\n\tif (!locked)\n\t\treturn false;\n\n\tvma_size = get_value_for_name(addr, SIZE);\n\tvma_rss = get_value_for_name(addr, RSS);\n\n\t \n\treturn (vma_rss < vma_size);\n}\n\n#define PRESENT_BIT     0x8000000000000000ULL\n#define PFN_MASK        0x007FFFFFFFFFFFFFULL\n#define UNEVICTABLE_BIT (1UL << 18)\n\nstatic int lock_check(unsigned long addr)\n{\n\tbool locked;\n\tunsigned long vma_size, vma_rss;\n\n\tlocked = is_vmflag_set(addr, LOCKED);\n\tif (!locked)\n\t\treturn false;\n\n\tvma_size = get_value_for_name(addr, SIZE);\n\tvma_rss = get_value_for_name(addr, RSS);\n\n\treturn (vma_rss == vma_size);\n}\n\nstatic int unlock_lock_check(char *map)\n{\n\tif (is_vmflag_set((unsigned long)map, LOCKED)) {\n\t\tprintf(\"VMA flag %s is present on page 1 after unlock\\n\", LOCKED);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_mlock_lock()\n{\n\tchar *map;\n\tint ret = 1;\n\tunsigned long page_size = getpagesize();\n\n\tmap = mmap(NULL, 2 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (map == MAP_FAILED) {\n\t\tperror(\"test_mlock_locked mmap\");\n\t\tgoto out;\n\t}\n\n\tif (mlock2_(map, 2 * page_size, 0)) {\n\t\tif (errno == ENOSYS) {\n\t\t\tprintf(\"Cannot call new mlock family, skipping test\\n\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\t\tperror(\"mlock2(0)\");\n\t\tgoto unmap;\n\t}\n\n\tif (!lock_check((unsigned long)map))\n\t\tgoto unmap;\n\n\t \n\tif (munlock(map, 2 * page_size)) {\n\t\tperror(\"munlock()\");\n\t\tgoto unmap;\n\t}\n\n\tret = unlock_lock_check(map);\n\nunmap:\n\tmunmap(map, 2 * page_size);\nout:\n\treturn ret;\n}\n\nstatic int onfault_check(char *map)\n{\n\t*map = 'a';\n\tif (!is_vma_lock_on_fault((unsigned long)map)) {\n\t\tprintf(\"VMA is not marked for lock on fault\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int unlock_onfault_check(char *map)\n{\n\tunsigned long page_size = getpagesize();\n\n\tif (is_vma_lock_on_fault((unsigned long)map) ||\n\t    is_vma_lock_on_fault((unsigned long)map + page_size)) {\n\t\tprintf(\"VMA is still lock on fault after unlock\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_mlock_onfault()\n{\n\tchar *map;\n\tint ret = 1;\n\tunsigned long page_size = getpagesize();\n\n\tmap = mmap(NULL, 2 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (map == MAP_FAILED) {\n\t\tperror(\"test_mlock_locked mmap\");\n\t\tgoto out;\n\t}\n\n\tif (mlock2_(map, 2 * page_size, MLOCK_ONFAULT)) {\n\t\tif (errno == ENOSYS) {\n\t\t\tprintf(\"Cannot call new mlock family, skipping test\\n\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\t\tperror(\"mlock2(MLOCK_ONFAULT)\");\n\t\tgoto unmap;\n\t}\n\n\tif (onfault_check(map))\n\t\tgoto unmap;\n\n\t \n\tif (munlock(map, 2 * page_size)) {\n\t\tif (errno == ENOSYS) {\n\t\t\tprintf(\"Cannot call new mlock family, skipping test\\n\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\t\tperror(\"munlock()\");\n\t\tgoto unmap;\n\t}\n\n\tret = unlock_onfault_check(map);\nunmap:\n\tmunmap(map, 2 * page_size);\nout:\n\treturn ret;\n}\n\nstatic int test_lock_onfault_of_present()\n{\n\tchar *map;\n\tint ret = 1;\n\tunsigned long page_size = getpagesize();\n\n\tmap = mmap(NULL, 2 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (map == MAP_FAILED) {\n\t\tperror(\"test_mlock_locked mmap\");\n\t\tgoto out;\n\t}\n\n\t*map = 'a';\n\n\tif (mlock2_(map, 2 * page_size, MLOCK_ONFAULT)) {\n\t\tif (errno == ENOSYS) {\n\t\t\tprintf(\"Cannot call new mlock family, skipping test\\n\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\t\tperror(\"mlock2(MLOCK_ONFAULT)\");\n\t\tgoto unmap;\n\t}\n\n\tif (!is_vma_lock_on_fault((unsigned long)map) ||\n\t    !is_vma_lock_on_fault((unsigned long)map + page_size)) {\n\t\tprintf(\"VMA with present pages is not marked lock on fault\\n\");\n\t\tgoto unmap;\n\t}\n\tret = 0;\nunmap:\n\tmunmap(map, 2 * page_size);\nout:\n\treturn ret;\n}\n\nstatic int test_munlockall()\n{\n\tchar *map;\n\tint ret = 1;\n\tunsigned long page_size = getpagesize();\n\n\tmap = mmap(NULL, 2 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n\tif (map == MAP_FAILED) {\n\t\tperror(\"test_munlockall mmap\");\n\t\tgoto out;\n\t}\n\n\tif (mlockall(MCL_CURRENT)) {\n\t\tperror(\"mlockall(MCL_CURRENT)\");\n\t\tgoto out;\n\t}\n\n\tif (!lock_check((unsigned long)map))\n\t\tgoto unmap;\n\n\tif (munlockall()) {\n\t\tperror(\"munlockall()\");\n\t\tgoto unmap;\n\t}\n\n\tif (unlock_lock_check(map))\n\t\tgoto unmap;\n\n\tmunmap(map, 2 * page_size);\n\n\tmap = mmap(NULL, 2 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n\tif (map == MAP_FAILED) {\n\t\tperror(\"test_munlockall second mmap\");\n\t\tgoto out;\n\t}\n\n\tif (mlockall(MCL_CURRENT | MCL_ONFAULT)) {\n\t\tperror(\"mlockall(MCL_CURRENT | MCL_ONFAULT)\");\n\t\tgoto unmap;\n\t}\n\n\tif (onfault_check(map))\n\t\tgoto unmap;\n\n\tif (munlockall()) {\n\t\tperror(\"munlockall()\");\n\t\tgoto unmap;\n\t}\n\n\tif (unlock_onfault_check(map))\n\t\tgoto unmap;\n\n\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\tperror(\"mlockall(MCL_CURRENT | MCL_FUTURE)\");\n\t\tgoto out;\n\t}\n\n\tif (!lock_check((unsigned long)map))\n\t\tgoto unmap;\n\n\tif (munlockall()) {\n\t\tperror(\"munlockall()\");\n\t\tgoto unmap;\n\t}\n\n\tret = unlock_lock_check(map);\n\nunmap:\n\tmunmap(map, 2 * page_size);\nout:\n\tmunlockall();\n\treturn ret;\n}\n\nstatic int test_vma_management(bool call_mlock)\n{\n\tint ret = 1;\n\tvoid *map;\n\tunsigned long page_size = getpagesize();\n\tstruct vm_boundaries page1;\n\tstruct vm_boundaries page2;\n\tstruct vm_boundaries page3;\n\n\tmap = mmap(NULL, 3 * page_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (map == MAP_FAILED) {\n\t\tperror(\"mmap()\");\n\t\treturn ret;\n\t}\n\n\tif (call_mlock && mlock2_(map, 3 * page_size, MLOCK_ONFAULT)) {\n\t\tif (errno == ENOSYS) {\n\t\t\tprintf(\"Cannot call new mlock family, skipping test\\n\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\t\tperror(\"mlock(ONFAULT)\\n\");\n\t\tgoto out;\n\t}\n\n\tif (get_vm_area((unsigned long)map, &page1) ||\n\t    get_vm_area((unsigned long)map + page_size, &page2) ||\n\t    get_vm_area((unsigned long)map + page_size * 2, &page3)) {\n\t\tprintf(\"couldn't find mapping in /proc/self/maps\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (page1.start != page2.start || page2.start != page3.start) {\n\t\tprintf(\"VMAs are not merged to start, aborting test\\n\");\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (munlock(map + page_size, page_size)) {\n\t\tperror(\"munlock()\");\n\t\tgoto out;\n\t}\n\n\tif (get_vm_area((unsigned long)map, &page1) ||\n\t    get_vm_area((unsigned long)map + page_size, &page2) ||\n\t    get_vm_area((unsigned long)map + page_size * 2, &page3)) {\n\t\tprintf(\"couldn't find mapping in /proc/self/maps\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (page1.start == page2.start || page2.start == page3.start) {\n\t\tprintf(\"failed to split VMA for munlock\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (munlock(map, page_size * 3)) {\n\t\tperror(\"munlock()\");\n\t\tgoto out;\n\t}\n\n\tif (get_vm_area((unsigned long)map, &page1) ||\n\t    get_vm_area((unsigned long)map + page_size, &page2) ||\n\t    get_vm_area((unsigned long)map + page_size * 2, &page3)) {\n\t\tprintf(\"couldn't find mapping in /proc/self/maps\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (page1.start != page2.start || page2.start != page3.start) {\n\t\tprintf(\"failed to merge VMAs after munlock\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tmunmap(map, 3 * page_size);\n\treturn ret;\n}\n\nstatic int test_mlockall(int (test_function)(bool call_mlock))\n{\n\tint ret = 1;\n\n\tif (mlockall(MCL_CURRENT | MCL_ONFAULT | MCL_FUTURE)) {\n\t\tperror(\"mlockall\");\n\t\treturn ret;\n\t}\n\n\tret = test_function(false);\n\tmunlockall();\n\treturn ret;\n}\n\nint main(int argc, char **argv)\n{\n\tint ret = 0;\n\tret += test_mlock_lock();\n\tret += test_mlock_onfault();\n\tret += test_munlockall();\n\tret += test_lock_onfault_of_present();\n\tret += test_vma_management(true);\n\tret += test_mlockall(test_vma_management);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}