{
  "module_name": "migration.c",
  "hash_id": "c8a76f03cd9d859e3b25c75f2245898cb7e96f1e2a8e74b5a473ed9518ba2685",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/migration.c",
  "human_readable_source": "\n \n\n#include \"../kselftest_harness.h\"\n#include <strings.h>\n#include <pthread.h>\n#include <numa.h>\n#include <numaif.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <time.h>\n\n#define TWOMEG (2<<20)\n#define RUNTIME (20)\n\n#define ALIGN(x, a) (((x) + (a - 1)) & (~((a) - 1)))\n\nFIXTURE(migration)\n{\n\tpthread_t *threads;\n\tpid_t *pids;\n\tint nthreads;\n\tint n1;\n\tint n2;\n};\n\nFIXTURE_SETUP(migration)\n{\n\tint n;\n\n\tASSERT_EQ(numa_available(), 0);\n\tself->nthreads = numa_num_task_cpus() - 1;\n\tself->n1 = -1;\n\tself->n2 = -1;\n\n\tfor (n = 0; n < numa_max_possible_node(); n++)\n\t\tif (numa_bitmask_isbitset(numa_all_nodes_ptr, n)) {\n\t\t\tif (self->n1 == -1) {\n\t\t\t\tself->n1 = n;\n\t\t\t} else {\n\t\t\t\tself->n2 = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tself->threads = malloc(self->nthreads * sizeof(*self->threads));\n\tASSERT_NE(self->threads, NULL);\n\tself->pids = malloc(self->nthreads * sizeof(*self->pids));\n\tASSERT_NE(self->pids, NULL);\n};\n\nFIXTURE_TEARDOWN(migration)\n{\n\tfree(self->threads);\n\tfree(self->pids);\n}\n\nint migrate(uint64_t *ptr, int n1, int n2)\n{\n\tint ret, tmp;\n\tint status = 0;\n\tstruct timespec ts1, ts2;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts1))\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (clock_gettime(CLOCK_MONOTONIC, &ts2))\n\t\t\treturn -1;\n\n\t\tif (ts2.tv_sec - ts1.tv_sec >= RUNTIME)\n\t\t\treturn 0;\n\n\t\tret = move_pages(0, 1, (void **) &ptr, &n2, &status,\n\t\t\t\tMPOL_MF_MOVE_ALL);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tprintf(\"Didn't migrate %d pages\\n\", ret);\n\t\t\telse\n\t\t\t\tperror(\"Couldn't migrate pages\");\n\t\t\treturn -2;\n\t\t}\n\n\t\ttmp = n2;\n\t\tn2 = n1;\n\t\tn1 = tmp;\n\t}\n\n\treturn 0;\n}\n\nvoid *access_mem(void *ptr)\n{\n\tvolatile uint64_t y = 0;\n\tvolatile uint64_t *x = ptr;\n\n\twhile (1) {\n\t\tpthread_testcancel();\n\t\ty += *x;\n\n\t\t \n\t\tasm volatile(\"\" : \"+r\" (y));\n\t}\n\n\treturn NULL;\n}\n\n \nTEST_F_TIMEOUT(migration, private_anon, 2*RUNTIME)\n{\n\tuint64_t *ptr;\n\tint i;\n\n\tif (self->nthreads < 2 || self->n1 < 0 || self->n2 < 0)\n\t\tSKIP(return, \"Not enough threads or NUMA nodes available\");\n\n\tptr = mmap(NULL, TWOMEG, PROT_READ | PROT_WRITE,\n\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(ptr, MAP_FAILED);\n\n\tmemset(ptr, 0xde, TWOMEG);\n\tfor (i = 0; i < self->nthreads - 1; i++)\n\t\tif (pthread_create(&self->threads[i], NULL, access_mem, ptr))\n\t\t\tperror(\"Couldn't create thread\");\n\n\tASSERT_EQ(migrate(ptr, self->n1, self->n2), 0);\n\tfor (i = 0; i < self->nthreads - 1; i++)\n\t\tASSERT_EQ(pthread_cancel(self->threads[i]), 0);\n}\n\n \nTEST_F_TIMEOUT(migration, shared_anon, 2*RUNTIME)\n{\n\tpid_t pid;\n\tuint64_t *ptr;\n\tint i;\n\n\tif (self->nthreads < 2 || self->n1 < 0 || self->n2 < 0)\n\t\tSKIP(return, \"Not enough threads or NUMA nodes available\");\n\n\tptr = mmap(NULL, TWOMEG, PROT_READ | PROT_WRITE,\n\t\tMAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(ptr, MAP_FAILED);\n\n\tmemset(ptr, 0xde, TWOMEG);\n\tfor (i = 0; i < self->nthreads - 1; i++) {\n\t\tpid = fork();\n\t\tif (!pid) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGHUP);\n\t\t\t \n\t\t\tif (getppid() == 1)\n\t\t\t\tkill(getpid(), SIGHUP);\n\t\t\taccess_mem(ptr);\n\t\t} else {\n\t\t\tself->pids[i] = pid;\n\t\t}\n\t}\n\n\tASSERT_EQ(migrate(ptr, self->n1, self->n2), 0);\n\tfor (i = 0; i < self->nthreads - 1; i++)\n\t\tASSERT_EQ(kill(self->pids[i], SIGTERM), 0);\n}\n\n \nTEST_F_TIMEOUT(migration, private_anon_thp, 2*RUNTIME)\n{\n\tuint64_t *ptr;\n\tint i;\n\n\tif (self->nthreads < 2 || self->n1 < 0 || self->n2 < 0)\n\t\tSKIP(return, \"Not enough threads or NUMA nodes available\");\n\n\tptr = mmap(NULL, 2*TWOMEG, PROT_READ | PROT_WRITE,\n\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(ptr, MAP_FAILED);\n\n\tptr = (uint64_t *) ALIGN((uintptr_t) ptr, TWOMEG);\n\tASSERT_EQ(madvise(ptr, TWOMEG, MADV_HUGEPAGE), 0);\n\tmemset(ptr, 0xde, TWOMEG);\n\tfor (i = 0; i < self->nthreads - 1; i++)\n\t\tif (pthread_create(&self->threads[i], NULL, access_mem, ptr))\n\t\t\tperror(\"Couldn't create thread\");\n\n\tASSERT_EQ(migrate(ptr, self->n1, self->n2), 0);\n\tfor (i = 0; i < self->nthreads - 1; i++)\n\t\tASSERT_EQ(pthread_cancel(self->threads[i]), 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}