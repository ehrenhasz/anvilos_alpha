{
  "module_name": "transhuge-stress.c",
  "hash_id": "20ca37a09e22d4596bd5b367b51c1fb72a3c46200375635d185a351906ae0197",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/transhuge-stress.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <err.h>\n#include <time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/mman.h>\n#include \"vm_util.h\"\n\nint backing_fd = -1;\nint mmap_flags = MAP_ANONYMOUS | MAP_NORESERVE | MAP_PRIVATE;\n#define PROT_RW (PROT_READ | PROT_WRITE)\n\nint main(int argc, char **argv)\n{\n\tsize_t ram, len;\n\tvoid *ptr, *p;\n\tstruct timespec start, a, b;\n\tint i = 0;\n\tchar *name = NULL;\n\tdouble s;\n\tuint8_t *map;\n\tsize_t map_len;\n\tint pagemap_fd;\n\tint duration = 0;\n\n\tram = sysconf(_SC_PHYS_PAGES);\n\tif (ram > SIZE_MAX / psize() / 4)\n\t\tram = SIZE_MAX / 4;\n\telse\n\t\tram *= psize();\n\tlen = ram;\n\n\twhile (++i < argc) {\n\t\tif (!strcmp(argv[i], \"-h\"))\n\t\t\terrx(1, \"usage: %s [-f <filename>] [-d <duration>] [size in MiB]\", argv[0]);\n\t\telse if (!strcmp(argv[i], \"-f\"))\n\t\t\tname = argv[++i];\n\t\telse if (!strcmp(argv[i], \"-d\"))\n\t\t\tduration = atoi(argv[++i]);\n\t\telse\n\t\t\tlen = atoll(argv[i]) << 20;\n\t}\n\n\tif (name) {\n\t\tbacking_fd = open(name, O_RDWR);\n\t\tif (backing_fd == -1)\n\t\t\terrx(2, \"open %s\", name);\n\t\tmmap_flags = MAP_SHARED;\n\t}\n\n\twarnx(\"allocate %zd transhuge pages, using %zd MiB virtual memory\"\n\t      \" and %zd MiB of ram\", len >> HPAGE_SHIFT, len >> 20,\n\t      ram >> (20 + HPAGE_SHIFT - pshift() - 1));\n\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\terr(2, \"open pagemap\");\n\n\tlen -= len % HPAGE_SIZE;\n\tptr = mmap(NULL, len + HPAGE_SIZE, PROT_RW, mmap_flags, backing_fd, 0);\n\tif (ptr == MAP_FAILED)\n\t\terr(2, \"initial mmap\");\n\tptr += HPAGE_SIZE - (uintptr_t)ptr % HPAGE_SIZE;\n\n\tif (madvise(ptr, len, MADV_HUGEPAGE))\n\t\terr(2, \"MADV_HUGEPAGE\");\n\n\tmap_len = ram >> (HPAGE_SHIFT - 1);\n\tmap = malloc(map_len);\n\tif (!map)\n\t\terrx(2, \"map malloc\");\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\n\twhile (1) {\n\t\tint nr_succeed = 0, nr_failed = 0, nr_pages = 0;\n\n\t\tmemset(map, 0, map_len);\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &a);\n\t\tfor (p = ptr; p < ptr + len; p += HPAGE_SIZE) {\n\t\t\tint64_t pfn;\n\n\t\t\tpfn = allocate_transhuge(p, pagemap_fd);\n\n\t\t\tif (pfn < 0) {\n\t\t\t\tnr_failed++;\n\t\t\t} else {\n\t\t\t\tsize_t idx = pfn >> (HPAGE_SHIFT - pshift());\n\n\t\t\t\tnr_succeed++;\n\t\t\t\tif (idx >= map_len) {\n\t\t\t\t\tmap = realloc(map, idx + 1);\n\t\t\t\t\tif (!map)\n\t\t\t\t\t\terrx(2, \"map realloc\");\n\t\t\t\t\tmemset(map + map_len, 0, idx + 1 - map_len);\n\t\t\t\t\tmap_len = idx + 1;\n\t\t\t\t}\n\t\t\t\tif (!map[idx])\n\t\t\t\t\tnr_pages++;\n\t\t\t\tmap[idx] = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (madvise(p, HPAGE_SIZE - psize(), MADV_DONTNEED))\n\t\t\t\terr(2, \"MADV_DONTNEED\");\n\t\t}\n\t\tclock_gettime(CLOCK_MONOTONIC, &b);\n\t\ts = b.tv_sec - a.tv_sec + (b.tv_nsec - a.tv_nsec) / 1000000000.;\n\n\t\twarnx(\"%.3f s/loop, %.3f ms/page, %10.3f MiB/s\\t\"\n\t\t      \"%4d succeed, %4d failed, %4d different pages\",\n\t\t      s, s * 1000 / (len >> HPAGE_SHIFT), len / s / (1 << 20),\n\t\t      nr_succeed, nr_failed, nr_pages);\n\n\t\tif (duration > 0 && b.tv_sec - start.tv_sec >= duration)\n\t\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}