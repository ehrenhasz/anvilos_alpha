{
  "module_name": "hugepage-vmemmap.c",
  "hash_id": "ba3aadd68567626d98f1dec366ba42f152bc697d90c0161332997b8bc9f30cf2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/hugepage-vmemmap.c",
  "human_readable_source": "\n \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n\n#define MAP_LENGTH\t\t(2UL * 1024 * 1024)\n\n#define PAGE_SIZE\t\t4096\n\n#define PAGE_COMPOUND_HEAD\t(1UL << 15)\n#define PAGE_COMPOUND_TAIL\t(1UL << 16)\n#define PAGE_HUGE\t\t(1UL << 17)\n\n#define HEAD_PAGE_FLAGS\t\t(PAGE_COMPOUND_HEAD | PAGE_HUGE)\n#define TAIL_PAGE_FLAGS\t\t(PAGE_COMPOUND_TAIL | PAGE_HUGE)\n\n#define PM_PFRAME_BITS\t\t55\n#define PM_PFRAME_MASK\t\t~((1UL << PM_PFRAME_BITS) - 1)\n\n \n#ifdef __ia64__\n#define MAP_ADDR\t\t(void *)(0x8000000000000000UL)\n#define MAP_FLAGS\t\t(MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB | MAP_FIXED)\n#else\n#define MAP_ADDR\t\tNULL\n#define MAP_FLAGS\t\t(MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB)\n#endif\n\nstatic void write_bytes(char *addr, size_t length)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < length; i++)\n\t\t*(addr + i) = (char)i;\n}\n\nstatic unsigned long virt_to_pfn(void *addr)\n{\n\tint fd;\n\tunsigned long pagemap;\n\n\tfd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1UL;\n\n\tlseek(fd, (unsigned long)addr / PAGE_SIZE * sizeof(pagemap), SEEK_SET);\n\tread(fd, &pagemap, sizeof(pagemap));\n\tclose(fd);\n\n\treturn pagemap & ~PM_PFRAME_MASK;\n}\n\nstatic int check_page_flags(unsigned long pfn)\n{\n\tint fd, i;\n\tunsigned long pageflags;\n\n\tfd = open(\"/proc/kpageflags\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tlseek(fd, pfn * sizeof(pageflags), SEEK_SET);\n\n\tread(fd, &pageflags, sizeof(pageflags));\n\tif ((pageflags & HEAD_PAGE_FLAGS) != HEAD_PAGE_FLAGS) {\n\t\tclose(fd);\n\t\tprintf(\"Head page flags (%lx) is invalid\\n\", pageflags);\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 1; i < MAP_LENGTH / PAGE_SIZE; i++) {\n\t\tread(fd, &pageflags, sizeof(pageflags));\n\t\tif ((pageflags & TAIL_PAGE_FLAGS) != TAIL_PAGE_FLAGS ||\n\t\t    (pageflags & HEAD_PAGE_FLAGS) == HEAD_PAGE_FLAGS) {\n\t\t\tclose(fd);\n\t\t\tprintf(\"Tail page flags (%lx) is invalid\\n\", pageflags);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tvoid *addr;\n\tunsigned long pfn;\n\n\taddr = mmap(MAP_ADDR, MAP_LENGTH, PROT_READ | PROT_WRITE, MAP_FLAGS, -1, 0);\n\tif (addr == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\texit(1);\n\t}\n\n\t \n\twrite_bytes(addr, MAP_LENGTH);\n\n\tpfn = virt_to_pfn(addr);\n\tif (pfn == -1UL) {\n\t\tmunmap(addr, MAP_LENGTH);\n\t\tperror(\"virt_to_pfn\");\n\t\texit(1);\n\t}\n\n\tprintf(\"Returned address is %p whose pfn is %lx\\n\", addr, pfn);\n\n\tif (check_page_flags(pfn) < 0) {\n\t\tmunmap(addr, MAP_LENGTH);\n\t\tperror(\"check_page_flags\");\n\t\texit(1);\n\t}\n\n\t \n\tif (munmap(addr, MAP_LENGTH)) {\n\t\tperror(\"munmap\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}