{
  "module_name": "soft-dirty.c",
  "hash_id": "bfab727dc5c8cfbb009a76880a4539794e37357f6d01033ff19e06bcaefc8e31",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/soft-dirty.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <malloc.h>\n#include <sys/mman.h>\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\n#define PAGEMAP_FILE_PATH \"/proc/self/pagemap\"\n#define TEST_ITERATIONS 10000\n\nstatic void test_simple(int pagemap_fd, int pagesize)\n{\n\tint i;\n\tchar *map;\n\n\tmap = aligned_alloc(pagesize, pagesize);\n\tif (!map)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\n\tclear_softdirty();\n\n\tfor (i = 0 ; i < TEST_ITERATIONS; i++) {\n\t\tif (pagemap_is_softdirty(pagemap_fd, map) == 1) {\n\t\t\tksft_print_msg(\"dirty bit was 1, but should be 0 (i=%d)\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tclear_softdirty();\n\t\t\n\t\tmap[0]++;\n\n\t\tif (pagemap_is_softdirty(pagemap_fd, map) == 0) {\n\t\t\tksft_print_msg(\"dirty bit was 0, but should be 1 (i=%d)\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tclear_softdirty();\n\t}\n\tfree(map);\n\n\tksft_test_result(i == TEST_ITERATIONS, \"Test %s\\n\", __func__);\n}\n\nstatic void test_vma_reuse(int pagemap_fd, int pagesize)\n{\n\tchar *map, *map2;\n\n\tmap = mmap(NULL, pagesize, (PROT_READ | PROT_WRITE), (MAP_PRIVATE | MAP_ANON), -1, 0);\n\tif (map == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\");\n\n\t\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 1,\n\t\t\t \"Test %s dirty bit of allocated page\\n\", __func__);\n\n\tclear_softdirty();\n\tmunmap(map, pagesize);\n\n\tmap2 = mmap(NULL, pagesize, (PROT_READ | PROT_WRITE), (MAP_PRIVATE | MAP_ANON), -1, 0);\n\tif (map2 == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\");\n\n\t\n\tif (map == map2)\n\t\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map2) == 1,\n\t\t\t\t \"Test %s dirty bit of reused address page\\n\", __func__);\n\telse\n\t\tksft_test_result_skip(\"Test %s dirty bit of reused address page\\n\", __func__);\n\n\tmunmap(map2, pagesize);\n}\n\nstatic void test_hugepage(int pagemap_fd, int pagesize)\n{\n\tchar *map;\n\tint i, ret;\n\tsize_t hpage_len = read_pmd_pagesize();\n\n\tif (!hpage_len)\n\t\tksft_exit_fail_msg(\"Reading PMD pagesize failed\");\n\n\tmap = memalign(hpage_len, hpage_len);\n\tif (!map)\n\t\tksft_exit_fail_msg(\"memalign failed\\n\");\n\n\tret = madvise(map, hpage_len, MADV_HUGEPAGE);\n\tif (ret)\n\t\tksft_exit_fail_msg(\"madvise failed %d\\n\", ret);\n\n\tfor (i = 0; i < hpage_len; i++)\n\t\tmap[i] = (char)i;\n\n\tif (check_huge_anon(map, 1, hpage_len)) {\n\t\tksft_test_result_pass(\"Test %s huge page allocation\\n\", __func__);\n\n\t\tclear_softdirty();\n\t\tfor (i = 0 ; i < TEST_ITERATIONS ; i++) {\n\t\t\tif (pagemap_is_softdirty(pagemap_fd, map) == 1) {\n\t\t\t\tksft_print_msg(\"dirty bit was 1, but should be 0 (i=%d)\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tclear_softdirty();\n\t\t\t\n\t\t\tmap[0]++;\n\n\t\t\tif (pagemap_is_softdirty(pagemap_fd, map) == 0) {\n\t\t\t\tksft_print_msg(\"dirty bit was 0, but should be 1 (i=%d)\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclear_softdirty();\n\t\t}\n\n\t\tksft_test_result(i == TEST_ITERATIONS, \"Test %s huge page dirty bit\\n\", __func__);\n\t} else {\n\t\t\n\t\tksft_test_result_skip(\"Test %s huge page allocation\\n\", __func__);\n\t\tksft_test_result_skip(\"Test %s huge page dirty bit\\n\", __func__);\n\t}\n\tfree(map);\n}\n\nstatic void test_mprotect(int pagemap_fd, int pagesize, bool anon)\n{\n\tconst char *type[] = {\"file\", \"anon\"};\n\tconst char *fname = \"./soft-dirty-test-file\";\n\tint test_fd;\n\tchar *map;\n\n\tif (anon) {\n\t\tmap = mmap(NULL, pagesize, PROT_READ|PROT_WRITE,\n\t\t\t   MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\t\tif (!map)\n\t\t\tksft_exit_fail_msg(\"anon mmap failed\\n\");\n\t} else {\n\t\ttest_fd = open(fname, O_RDWR | O_CREAT);\n\t\tif (test_fd < 0) {\n\t\t\tksft_test_result_skip(\"Test %s open() file failed\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tunlink(fname);\n\t\tftruncate(test_fd, pagesize);\n\t\tmap = mmap(NULL, pagesize, PROT_READ|PROT_WRITE,\n\t\t\t   MAP_SHARED, test_fd, 0);\n\t\tif (!map)\n\t\t\tksft_exit_fail_msg(\"file mmap failed\\n\");\n\t}\n\n\t*map = 1;\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 1,\n\t\t\t \"Test %s-%s dirty bit of new written page\\n\",\n\t\t\t __func__, type[anon]);\n\tclear_softdirty();\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 0,\n\t\t\t \"Test %s-%s soft-dirty clear after clear_refs\\n\",\n\t\t\t __func__, type[anon]);\n\tmprotect(map, pagesize, PROT_READ);\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 0,\n\t\t\t \"Test %s-%s soft-dirty clear after marking RO\\n\",\n\t\t\t __func__, type[anon]);\n\tmprotect(map, pagesize, PROT_READ|PROT_WRITE);\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 0,\n\t\t\t \"Test %s-%s soft-dirty clear after marking RW\\n\",\n\t\t\t __func__, type[anon]);\n\t*map = 2;\n\tksft_test_result(pagemap_is_softdirty(pagemap_fd, map) == 1,\n\t\t\t \"Test %s-%s soft-dirty after rewritten\\n\",\n\t\t\t __func__, type[anon]);\n\n\tmunmap(map, pagesize);\n\n\tif (!anon)\n\t\tclose(test_fd);\n}\n\nstatic void test_mprotect_anon(int pagemap_fd, int pagesize)\n{\n\ttest_mprotect(pagemap_fd, pagesize, true);\n}\n\nstatic void test_mprotect_file(int pagemap_fd, int pagesize)\n{\n\ttest_mprotect(pagemap_fd, pagesize, false);\n}\n\nint main(int argc, char **argv)\n{\n\tint pagemap_fd;\n\tint pagesize;\n\n\tksft_print_header();\n\tksft_set_plan(15);\n\n\tpagemap_fd = open(PAGEMAP_FILE_PATH, O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\tksft_exit_fail_msg(\"Failed to open %s\\n\", PAGEMAP_FILE_PATH);\n\n\tpagesize = getpagesize();\n\n\ttest_simple(pagemap_fd, pagesize);\n\ttest_vma_reuse(pagemap_fd, pagesize);\n\ttest_hugepage(pagemap_fd, pagesize);\n\ttest_mprotect_anon(pagemap_fd, pagesize);\n\ttest_mprotect_file(pagemap_fd, pagesize);\n\n\tclose(pagemap_fd);\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}