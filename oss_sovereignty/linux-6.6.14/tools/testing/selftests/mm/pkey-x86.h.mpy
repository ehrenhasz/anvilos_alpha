{
  "module_name": "pkey-x86.h",
  "hash_id": "348f4335f5e6dd79af958f996da283dda6f20a4de430ec9398766c75b2c7f175",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/pkey-x86.h",
  "human_readable_source": " \n\n#ifndef _PKEYS_X86_H\n#define _PKEYS_X86_H\n\n#ifdef __i386__\n\n#define REG_IP_IDX\t\tREG_EIP\n#define si_pkey_offset\t\t0x14\n\n#else\n\n#define REG_IP_IDX\t\tREG_RIP\n#define si_pkey_offset\t\t0x20\n\n#endif\n\n#ifndef PKEY_DISABLE_ACCESS\n# define PKEY_DISABLE_ACCESS\t0x1\n#endif\n\n#ifndef PKEY_DISABLE_WRITE\n# define PKEY_DISABLE_WRITE\t0x2\n#endif\n\n#define NR_PKEYS\t\t16\n#define NR_RESERVED_PKEYS\t2  \n#define PKEY_BITS_PER_PKEY\t2\n#define HPAGE_SIZE\t\t(1UL<<21)\n#define PAGE_SIZE\t\t4096\n#define MB\t\t\t(1<<20)\n\nstatic inline void __page_o_noops(void)\n{\n\t \n\tasm(\".rept 512 ; nopl 0x7eeeeeee(%eax) ; .endr\");\n}\n\nstatic inline u64 __read_pkey_reg(void)\n{\n\tunsigned int eax, edx;\n\tunsigned int ecx = 0;\n\tunsigned pkey_reg;\n\n\tasm volatile(\".byte 0x0f,0x01,0xee\\n\\t\"\n\t\t     : \"=a\" (eax), \"=d\" (edx)\n\t\t     : \"c\" (ecx));\n\tpkey_reg = eax;\n\treturn pkey_reg;\n}\n\nstatic inline void __write_pkey_reg(u64 pkey_reg)\n{\n\tunsigned int eax = pkey_reg;\n\tunsigned int ecx = 0;\n\tunsigned int edx = 0;\n\n\tdprintf4(\"%s() changing %016llx to %016llx\\n\", __func__,\n\t\t\t__read_pkey_reg(), pkey_reg);\n\tasm volatile(\".byte 0x0f,0x01,0xef\\n\\t\"\n\t\t     : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n\tassert(pkey_reg == __read_pkey_reg());\n}\n\n \n#define X86_FEATURE_PKU        (1<<3)  \n#define X86_FEATURE_OSPKE      (1<<4)  \n\nstatic inline int cpu_has_pkeys(void)\n{\n\tunsigned int eax;\n\tunsigned int ebx;\n\tunsigned int ecx;\n\tunsigned int edx;\n\n\t__cpuid_count(0x7, 0x0, eax, ebx, ecx, edx);\n\n\tif (!(ecx & X86_FEATURE_PKU)) {\n\t\tdprintf2(\"cpu does not have PKU\\n\");\n\t\treturn 0;\n\t}\n\tif (!(ecx & X86_FEATURE_OSPKE)) {\n\t\tdprintf2(\"cpu does not have OSPKE\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic inline int cpu_max_xsave_size(void)\n{\n\tunsigned long XSTATE_CPUID = 0xd;\n\tunsigned int eax;\n\tunsigned int ebx;\n\tunsigned int ecx;\n\tunsigned int edx;\n\n\t__cpuid_count(XSTATE_CPUID, 0, eax, ebx, ecx, edx);\n\treturn ecx;\n}\n\nstatic inline u32 pkey_bit_position(int pkey)\n{\n\treturn pkey * PKEY_BITS_PER_PKEY;\n}\n\n#define XSTATE_PKEY_BIT\t(9)\n#define XSTATE_PKEY\t0x200\n#define XSTATE_BV_OFFSET\t512\n\nint pkey_reg_xstate_offset(void)\n{\n\tunsigned int eax;\n\tunsigned int ebx;\n\tunsigned int ecx;\n\tunsigned int edx;\n\tint xstate_offset;\n\tint xstate_size = 0;\n\tunsigned long XSTATE_CPUID = 0xd;\n\tint leaf;\n\n\t \n\tleaf = XSTATE_PKEY_BIT;\n\t{\n\t\t__cpuid_count(XSTATE_CPUID, leaf, eax, ebx, ecx, edx);\n\n\t\tif (leaf == XSTATE_PKEY_BIT) {\n\t\t\txstate_offset = ebx;\n\t\t\txstate_size = eax;\n\t\t}\n\t}\n\n\tif (xstate_size == 0) {\n\t\tprintf(\"could not find size/offset of PKEY in xsave state\\n\");\n\t\treturn 0;\n\t}\n\n\treturn xstate_offset;\n}\n\nstatic inline int get_arch_reserved_keys(void)\n{\n\treturn NR_RESERVED_PKEYS;\n}\n\nvoid expect_fault_on_read_execonly_key(void *p1, int pkey)\n{\n\tint ptr_contents;\n\n\tptr_contents = read_ptr(p1);\n\tdprintf2(\"ptr (%p) contents@%d: %x\\n\", p1, __LINE__, ptr_contents);\n\texpected_pkey_fault(pkey);\n}\n\nvoid *malloc_pkey_with_mprotect_subpage(long size, int prot, u16 pkey)\n{\n\treturn PTR_ERR_ENOTSUP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}