{
  "module_name": "uffd-stress.c",
  "hash_id": "660436c814982abbeb6e4d92940b649df674b9092609b43651e42fc796b988b5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/uffd-stress.c",
  "human_readable_source": "\n \n\n#include \"uffd-common.h\"\n\n#ifdef __NR_userfaultfd\n\n#define BOUNCE_RANDOM\t\t(1<<0)\n#define BOUNCE_RACINGFAULTS\t(1<<1)\n#define BOUNCE_VERIFY\t\t(1<<2)\n#define BOUNCE_POLL\t\t(1<<3)\nstatic int bounces;\n\n \n#define ALARM_INTERVAL_SECS 10\nstatic char *zeropage;\npthread_attr_t attr;\n\n#define swap(a, b) \\\n\tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n\nconst char *examples =\n\t\"# Run anonymous memory test on 100MiB region with 99999 bounces:\\n\"\n\t\"./uffd-stress anon 100 99999\\n\\n\"\n\t\"# Run share memory test on 1GiB region with 99 bounces:\\n\"\n\t\"./uffd-stress shmem 1000 99\\n\\n\"\n\t\"# Run hugetlb memory test on 256MiB region with 50 bounces:\\n\"\n\t\"./uffd-stress hugetlb 256 50\\n\\n\"\n\t\"# Run the same hugetlb test but using private file:\\n\"\n\t\"./uffd-stress hugetlb-private 256 50\\n\\n\"\n\t\"# 10MiB-~6GiB 999 bounces anonymous test, \"\n\t\"continue forever unless an error triggers\\n\"\n\t\"while ./uffd-stress anon $[RANDOM % 6000 + 10] 999; do true; done\\n\\n\";\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"\\nUsage: ./uffd-stress <test type> <MiB> <bounces>\\n\\n\");\n\tfprintf(stderr, \"Supported <test type>: anon, hugetlb, \"\n\t\t\"hugetlb-private, shmem, shmem-private\\n\\n\");\n\tfprintf(stderr, \"Examples:\\n\\n\");\n\tfprintf(stderr, \"%s\", examples);\n\texit(1);\n}\n\nstatic void uffd_stats_reset(struct uffd_args *args, unsigned long n_cpus)\n{\n\tint i;\n\n\tfor (i = 0; i < n_cpus; i++) {\n\t\targs[i].cpu = i;\n\t\targs[i].apply_wp = test_uffdio_wp;\n\t\targs[i].missing_faults = 0;\n\t\targs[i].wp_faults = 0;\n\t\targs[i].minor_faults = 0;\n\t}\n}\n\nstatic void *locking_thread(void *arg)\n{\n\tunsigned long cpu = (unsigned long) arg;\n\tunsigned long page_nr;\n\tunsigned long long count;\n\n\tif (!(bounces & BOUNCE_RANDOM)) {\n\t\tpage_nr = -bounces;\n\t\tif (!(bounces & BOUNCE_RACINGFAULTS))\n\t\t\tpage_nr += cpu * nr_pages_per_cpu;\n\t}\n\n\twhile (!finished) {\n\t\tif (bounces & BOUNCE_RANDOM) {\n\t\t\tif (getrandom(&page_nr, sizeof(page_nr), 0) != sizeof(page_nr))\n\t\t\t\terr(\"getrandom failed\");\n\t\t} else\n\t\t\tpage_nr += 1;\n\t\tpage_nr %= nr_pages;\n\t\tpthread_mutex_lock(area_mutex(area_dst, page_nr));\n\t\tcount = *area_count(area_dst, page_nr);\n\t\tif (count != count_verify[page_nr])\n\t\t\terr(\"page_nr %lu memory corruption %llu %llu\",\n\t\t\t    page_nr, count, count_verify[page_nr]);\n\t\tcount++;\n\t\t*area_count(area_dst, page_nr) = count_verify[page_nr] = count;\n\t\tpthread_mutex_unlock(area_mutex(area_dst, page_nr));\n\t}\n\n\treturn NULL;\n}\n\nstatic int copy_page_retry(int ufd, unsigned long offset)\n{\n\treturn __copy_page(ufd, offset, true, test_uffdio_wp);\n}\n\npthread_mutex_t uffd_read_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void *uffd_read_thread(void *arg)\n{\n\tstruct uffd_args *args = (struct uffd_args *)arg;\n\tstruct uffd_msg msg;\n\n\tpthread_mutex_unlock(&uffd_read_mutex);\n\t \n\n\tfor (;;) {\n\t\tif (uffd_read_msg(uffd, &msg))\n\t\t\tcontinue;\n\t\tuffd_handle_page_fault(&msg, args);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *background_thread(void *arg)\n{\n\tunsigned long cpu = (unsigned long) arg;\n\tunsigned long page_nr, start_nr, mid_nr, end_nr;\n\n\tstart_nr = cpu * nr_pages_per_cpu;\n\tend_nr = (cpu+1) * nr_pages_per_cpu;\n\tmid_nr = (start_nr + end_nr) / 2;\n\n\t \n\tfor (page_nr = start_nr; page_nr < mid_nr; page_nr++)\n\t\tcopy_page_retry(uffd, page_nr * page_size);\n\n\t \n\tif (test_uffdio_wp)\n\t\twp_range(uffd, (unsigned long)area_dst + start_nr * page_size,\n\t\t\tnr_pages_per_cpu * page_size, true);\n\n\t \n\tfor (page_nr = mid_nr; page_nr < end_nr; page_nr++)\n\t\tcopy_page_retry(uffd, page_nr * page_size);\n\n\treturn NULL;\n}\n\nstatic int stress(struct uffd_args *args)\n{\n\tunsigned long cpu;\n\tpthread_t locking_threads[nr_cpus];\n\tpthread_t uffd_threads[nr_cpus];\n\tpthread_t background_threads[nr_cpus];\n\n\tfinished = 0;\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tif (pthread_create(&locking_threads[cpu], &attr,\n\t\t\t\t   locking_thread, (void *)cpu))\n\t\t\treturn 1;\n\t\tif (bounces & BOUNCE_POLL) {\n\t\t\tif (pthread_create(&uffd_threads[cpu], &attr, uffd_poll_thread, &args[cpu]))\n\t\t\t\terr(\"uffd_poll_thread create\");\n\t\t} else {\n\t\t\tif (pthread_create(&uffd_threads[cpu], &attr,\n\t\t\t\t\t   uffd_read_thread,\n\t\t\t\t\t   (void *)&args[cpu]))\n\t\t\t\treturn 1;\n\t\t\tpthread_mutex_lock(&uffd_read_mutex);\n\t\t}\n\t\tif (pthread_create(&background_threads[cpu], &attr,\n\t\t\t\t   background_thread, (void *)cpu))\n\t\t\treturn 1;\n\t}\n\tfor (cpu = 0; cpu < nr_cpus; cpu++)\n\t\tif (pthread_join(background_threads[cpu], NULL))\n\t\t\treturn 1;\n\n\t \n\tuffd_test_ops->release_pages(area_src);\n\n\tfinished = 1;\n\tfor (cpu = 0; cpu < nr_cpus; cpu++)\n\t\tif (pthread_join(locking_threads[cpu], NULL))\n\t\t\treturn 1;\n\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tchar c;\n\t\tif (bounces & BOUNCE_POLL) {\n\t\t\tif (write(pipefd[cpu*2+1], &c, 1) != 1)\n\t\t\t\terr(\"pipefd write error\");\n\t\t\tif (pthread_join(uffd_threads[cpu],\n\t\t\t\t\t (void *)&args[cpu]))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (pthread_cancel(uffd_threads[cpu]))\n\t\t\t\treturn 1;\n\t\t\tif (pthread_join(uffd_threads[cpu], NULL))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int userfaultfd_stress(void)\n{\n\tvoid *area;\n\tunsigned long nr;\n\tstruct uffd_args args[nr_cpus];\n\tuint64_t mem_size = nr_pages * page_size;\n\n\tmemset(args, 0, sizeof(struct uffd_args) * nr_cpus);\n\n\tif (uffd_test_ctx_init(UFFD_FEATURE_WP_UNPOPULATED, NULL))\n\t\terr(\"context init failed\");\n\n\tif (posix_memalign(&area, page_size, page_size))\n\t\terr(\"out of memory\");\n\tzeropage = area;\n\tbzero(zeropage, page_size);\n\n\tpthread_mutex_lock(&uffd_read_mutex);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_setstacksize(&attr, 16*1024*1024);\n\n\twhile (bounces--) {\n\t\tprintf(\"bounces: %d, mode:\", bounces);\n\t\tif (bounces & BOUNCE_RANDOM)\n\t\t\tprintf(\" rnd\");\n\t\tif (bounces & BOUNCE_RACINGFAULTS)\n\t\t\tprintf(\" racing\");\n\t\tif (bounces & BOUNCE_VERIFY)\n\t\t\tprintf(\" ver\");\n\t\tif (bounces & BOUNCE_POLL)\n\t\t\tprintf(\" poll\");\n\t\telse\n\t\t\tprintf(\" read\");\n\t\tprintf(\", \");\n\t\tfflush(stdout);\n\n\t\tif (bounces & BOUNCE_POLL)\n\t\t\tfcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);\n\t\telse\n\t\t\tfcntl(uffd, F_SETFL, uffd_flags & ~O_NONBLOCK);\n\n\t\t \n\t\tif (uffd_register(uffd, area_dst, mem_size,\n\t\t\t\t  true, test_uffdio_wp, false))\n\t\t\terr(\"register failure\");\n\n\t\tif (area_dst_alias) {\n\t\t\tif (uffd_register(uffd, area_dst_alias, mem_size,\n\t\t\t\t\t  true, test_uffdio_wp, false))\n\t\t\t\terr(\"register failure alias\");\n\t\t}\n\n\t\t \n\t\tuffd_test_ops->release_pages(area_dst);\n\n\t\tuffd_stats_reset(args, nr_cpus);\n\n\t\t \n\t\tif (stress(args))\n\t\t\treturn 1;\n\n\t\t \n\t\tif (test_uffdio_wp)\n\t\t\twp_range(uffd, (unsigned long)area_dst,\n\t\t\t\t nr_pages * page_size, false);\n\n\t\t \n\t\tif (uffd_unregister(uffd, area_dst, mem_size))\n\t\t\terr(\"unregister failure\");\n\t\tif (area_dst_alias) {\n\t\t\tif (uffd_unregister(uffd, area_dst_alias, mem_size))\n\t\t\t\terr(\"unregister failure alias\");\n\t\t}\n\n\t\t \n\t\tif (bounces & BOUNCE_VERIFY)\n\t\t\tfor (nr = 0; nr < nr_pages; nr++)\n\t\t\t\tif (*area_count(area_dst, nr) != count_verify[nr])\n\t\t\t\t\terr(\"error area_count %llu %llu %lu\\n\",\n\t\t\t\t\t    *area_count(area_src, nr),\n\t\t\t\t\t    count_verify[nr], nr);\n\n\t\t \n\t\tswap(area_src, area_dst);\n\n\t\tswap(area_src_alias, area_dst_alias);\n\n\t\tuffd_stats_report(args, nr_cpus);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_test_type(const char *type)\n{\n\tif (!strcmp(type, \"anon\")) {\n\t\ttest_type = TEST_ANON;\n\t\tuffd_test_ops = &anon_uffd_test_ops;\n\t} else if (!strcmp(type, \"hugetlb\")) {\n\t\ttest_type = TEST_HUGETLB;\n\t\tuffd_test_ops = &hugetlb_uffd_test_ops;\n\t\tmap_shared = true;\n\t} else if (!strcmp(type, \"hugetlb-private\")) {\n\t\ttest_type = TEST_HUGETLB;\n\t\tuffd_test_ops = &hugetlb_uffd_test_ops;\n\t} else if (!strcmp(type, \"shmem\")) {\n\t\tmap_shared = true;\n\t\ttest_type = TEST_SHMEM;\n\t\tuffd_test_ops = &shmem_uffd_test_ops;\n\t} else if (!strcmp(type, \"shmem-private\")) {\n\t\ttest_type = TEST_SHMEM;\n\t\tuffd_test_ops = &shmem_uffd_test_ops;\n\t}\n}\n\nstatic void parse_test_type_arg(const char *raw_type)\n{\n\tuint64_t features = UFFD_API_FEATURES;\n\n\tset_test_type(raw_type);\n\n\tif (!test_type)\n\t\terr(\"failed to parse test type argument: '%s'\", raw_type);\n\n\tif (test_type == TEST_HUGETLB)\n\t\tpage_size = default_huge_page_size();\n\telse\n\t\tpage_size = sysconf(_SC_PAGE_SIZE);\n\n\tif (!page_size)\n\t\terr(\"Unable to determine page size\");\n\tif ((unsigned long) area_count(NULL, 0) + sizeof(unsigned long long) * 2\n\t    > page_size)\n\t\terr(\"Impossible to run this test\");\n\n\t \n\n\tif (userfaultfd_open(&features))\n\t\terr(\"Userfaultfd open failed\");\n\n\ttest_uffdio_wp = test_uffdio_wp &&\n\t\t(features & UFFD_FEATURE_PAGEFAULT_FLAG_WP);\n\n\tclose(uffd);\n\tuffd = -1;\n}\n\nstatic void sigalrm(int sig)\n{\n\tif (sig != SIGALRM)\n\t\tabort();\n\ttest_uffdio_copy_eexist = true;\n\talarm(ALARM_INTERVAL_SECS);\n}\n\nint main(int argc, char **argv)\n{\n\tsize_t bytes;\n\n\tif (argc < 4)\n\t\tusage();\n\n\tif (signal(SIGALRM, sigalrm) == SIG_ERR)\n\t\terr(\"failed to arm SIGALRM\");\n\talarm(ALARM_INTERVAL_SECS);\n\n\tparse_test_type_arg(argv[1]);\n\tbytes = atol(argv[2]) * 1024 * 1024;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\n\tnr_pages_per_cpu = bytes / page_size / nr_cpus;\n\tif (!nr_pages_per_cpu) {\n\t\t_err(\"invalid MiB\");\n\t\tusage();\n\t}\n\n\tbounces = atoi(argv[3]);\n\tif (bounces <= 0) {\n\t\t_err(\"invalid bounces\");\n\t\tusage();\n\t}\n\tnr_pages = nr_pages_per_cpu * nr_cpus;\n\n\tprintf(\"nr_pages: %lu, nr_pages_per_cpu: %lu\\n\",\n\t       nr_pages, nr_pages_per_cpu);\n\treturn userfaultfd_stress();\n}\n\n#else  \n\n#warning \"missing __NR_userfaultfd definition\"\n\nint main(void)\n{\n\tprintf(\"skip: Skipping userfaultfd test (missing __NR_userfaultfd)\\n\");\n\treturn KSFT_SKIP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}