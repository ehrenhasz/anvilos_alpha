{
  "module_name": "protection_keys.c",
  "hash_id": "a0b27273e92692da8858d0d6f1518a06a23044d393128776fef1b4fbe487bc83",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/protection_keys.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#define __SANE_USERSPACE_TYPES__\n#include <errno.h>\n#include <linux/elf.h>\n#include <linux/futex.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/syscall.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <ucontext.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ptrace.h>\n#include <setjmp.h>\n\n#include \"pkey-helpers.h\"\n\nint iteration_nr = 1;\nint test_nr;\n\nu64 shadow_pkey_reg;\nint dprint_in_signal;\nchar dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];\n\nvoid cat_into_file(char *str, char *file)\n{\n\tint fd = open(file, O_RDWR);\n\tint ret;\n\n\tdprintf2(\"%s(): writing '%s' to '%s'\\n\", __func__, str, file);\n\t \n\tif (fd < 0) {\n\t\tfprintf(stderr, \"error opening '%s'\\n\", str);\n\t\tperror(\"error: \");\n\t\texit(__LINE__);\n\t}\n\n\tret = write(fd, str, strlen(str));\n\tif (ret != strlen(str)) {\n\t\tperror(\"write to file failed\");\n\t\tfprintf(stderr, \"filename: '%s' str: '%s'\\n\", file, str);\n\t\texit(__LINE__);\n\t}\n\tclose(fd);\n}\n\n#if CONTROL_TRACING > 0\nstatic int warned_tracing;\nint tracing_root_ok(void)\n{\n\tif (geteuid() != 0) {\n\t\tif (!warned_tracing)\n\t\t\tfprintf(stderr, \"WARNING: not run as root, \"\n\t\t\t\t\t\"can not do tracing control\\n\");\n\t\twarned_tracing = 1;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n#endif\n\nvoid tracing_on(void)\n{\n#if CONTROL_TRACING > 0\n#define TRACEDIR \"/sys/kernel/tracing\"\n\tchar pidstr[32];\n\n\tif (!tracing_root_ok())\n\t\treturn;\n\n\tsprintf(pidstr, \"%d\", getpid());\n\tcat_into_file(\"0\", TRACEDIR \"/tracing_on\");\n\tcat_into_file(\"\\n\", TRACEDIR \"/trace\");\n\tif (1) {\n\t\tcat_into_file(\"function_graph\", TRACEDIR \"/current_tracer\");\n\t\tcat_into_file(\"1\", TRACEDIR \"/options/funcgraph-proc\");\n\t} else {\n\t\tcat_into_file(\"nop\", TRACEDIR \"/current_tracer\");\n\t}\n\tcat_into_file(pidstr, TRACEDIR \"/set_ftrace_pid\");\n\tcat_into_file(\"1\", TRACEDIR \"/tracing_on\");\n\tdprintf1(\"enabled tracing\\n\");\n#endif\n}\n\nvoid tracing_off(void)\n{\n#if CONTROL_TRACING > 0\n\tif (!tracing_root_ok())\n\t\treturn;\n\tcat_into_file(\"0\", \"/sys/kernel/tracing/tracing_on\");\n#endif\n}\n\nvoid abort_hooks(void)\n{\n\tfprintf(stderr, \"running %s()...\\n\", __func__);\n\ttracing_off();\n#ifdef SLEEP_ON_ABORT\n\tsleep(SLEEP_ON_ABORT);\n#endif\n}\n\n \n#ifdef __powerpc64__\n \n__attribute__((__aligned__(65536)))\n#else\n__attribute__((__aligned__(PAGE_SIZE)))\n#endif\nvoid lots_o_noops_around_write(int *write_to_me)\n{\n\tdprintf3(\"running %s()\\n\", __func__);\n\t__page_o_noops();\n\t \n\t*write_to_me = __LINE__;\n\t \n\t__page_o_noops();\n\tdprintf3(\"%s() done\\n\", __func__);\n}\n\nvoid dump_mem(void *dumpme, int len_bytes)\n{\n\tchar *c = (void *)dumpme;\n\tint i;\n\n\tfor (i = 0; i < len_bytes; i += sizeof(u64)) {\n\t\tu64 *ptr = (u64 *)(c + i);\n\t\tdprintf1(\"dump[%03d][@%p]: %016llx\\n\", i, ptr, *ptr);\n\t}\n}\n\nstatic u32 hw_pkey_get(int pkey, unsigned long flags)\n{\n\tu64 pkey_reg = __read_pkey_reg();\n\n\tdprintf1(\"%s(pkey=%d, flags=%lx) = %x / %d\\n\",\n\t\t\t__func__, pkey, flags, 0, 0);\n\tdprintf2(\"%s() raw pkey_reg: %016llx\\n\", __func__, pkey_reg);\n\n\treturn (u32) get_pkey_bits(pkey_reg, pkey);\n}\n\nstatic int hw_pkey_set(int pkey, unsigned long rights, unsigned long flags)\n{\n\tu32 mask = (PKEY_DISABLE_ACCESS|PKEY_DISABLE_WRITE);\n\tu64 old_pkey_reg = __read_pkey_reg();\n\tu64 new_pkey_reg;\n\n\t \n\tassert(!(rights & ~mask));\n\n\t \n\tnew_pkey_reg = set_pkey_bits(old_pkey_reg, pkey, rights);\n\n\t__write_pkey_reg(new_pkey_reg);\n\n\tdprintf3(\"%s(pkey=%d, rights=%lx, flags=%lx) = %x\"\n\t\t\" pkey_reg now: %016llx old_pkey_reg: %016llx\\n\",\n\t\t__func__, pkey, rights, flags, 0, __read_pkey_reg(),\n\t\told_pkey_reg);\n\treturn 0;\n}\n\nvoid pkey_disable_set(int pkey, int flags)\n{\n\tunsigned long syscall_flags = 0;\n\tint ret;\n\tint pkey_rights;\n\tu64 orig_pkey_reg = read_pkey_reg();\n\n\tdprintf1(\"START->%s(%d, 0x%x)\\n\", __func__,\n\t\tpkey, flags);\n\tpkey_assert(flags & (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));\n\n\tpkey_rights = hw_pkey_get(pkey, syscall_flags);\n\n\tdprintf1(\"%s(%d) hw_pkey_get(%d): %x\\n\", __func__,\n\t\t\tpkey, pkey, pkey_rights);\n\n\tpkey_assert(pkey_rights >= 0);\n\n\tpkey_rights |= flags;\n\n\tret = hw_pkey_set(pkey, pkey_rights, syscall_flags);\n\tassert(!ret);\n\t \n\tshadow_pkey_reg = set_pkey_bits(shadow_pkey_reg, pkey, pkey_rights);\n\tdprintf1(\"%s(%d) shadow: 0x%016llx\\n\",\n\t\t__func__, pkey, shadow_pkey_reg);\n\n\tpkey_assert(ret >= 0);\n\n\tpkey_rights = hw_pkey_get(pkey, syscall_flags);\n\tdprintf1(\"%s(%d) hw_pkey_get(%d): %x\\n\", __func__,\n\t\t\tpkey, pkey, pkey_rights);\n\n\tdprintf1(\"%s(%d) pkey_reg: 0x%016llx\\n\",\n\t\t__func__, pkey, read_pkey_reg());\n\tif (flags)\n\t\tpkey_assert(read_pkey_reg() >= orig_pkey_reg);\n\tdprintf1(\"END<---%s(%d, 0x%x)\\n\", __func__,\n\t\tpkey, flags);\n}\n\nvoid pkey_disable_clear(int pkey, int flags)\n{\n\tunsigned long syscall_flags = 0;\n\tint ret;\n\tint pkey_rights = hw_pkey_get(pkey, syscall_flags);\n\tu64 orig_pkey_reg = read_pkey_reg();\n\n\tpkey_assert(flags & (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));\n\n\tdprintf1(\"%s(%d) hw_pkey_get(%d): %x\\n\", __func__,\n\t\t\tpkey, pkey, pkey_rights);\n\tpkey_assert(pkey_rights >= 0);\n\n\tpkey_rights &= ~flags;\n\n\tret = hw_pkey_set(pkey, pkey_rights, 0);\n\tshadow_pkey_reg = set_pkey_bits(shadow_pkey_reg, pkey, pkey_rights);\n\tpkey_assert(ret >= 0);\n\n\tpkey_rights = hw_pkey_get(pkey, syscall_flags);\n\tdprintf1(\"%s(%d) hw_pkey_get(%d): %x\\n\", __func__,\n\t\t\tpkey, pkey, pkey_rights);\n\n\tdprintf1(\"%s(%d) pkey_reg: 0x%016llx\\n\", __func__,\n\t\t\tpkey, read_pkey_reg());\n\tif (flags)\n\t\tassert(read_pkey_reg() <= orig_pkey_reg);\n}\n\nvoid pkey_write_allow(int pkey)\n{\n\tpkey_disable_clear(pkey, PKEY_DISABLE_WRITE);\n}\nvoid pkey_write_deny(int pkey)\n{\n\tpkey_disable_set(pkey, PKEY_DISABLE_WRITE);\n}\nvoid pkey_access_allow(int pkey)\n{\n\tpkey_disable_clear(pkey, PKEY_DISABLE_ACCESS);\n}\nvoid pkey_access_deny(int pkey)\n{\n\tpkey_disable_set(pkey, PKEY_DISABLE_ACCESS);\n}\n\nstatic char *si_code_str(int si_code)\n{\n\tif (si_code == SEGV_MAPERR)\n\t\treturn \"SEGV_MAPERR\";\n\tif (si_code == SEGV_ACCERR)\n\t\treturn \"SEGV_ACCERR\";\n\tif (si_code == SEGV_BNDERR)\n\t\treturn \"SEGV_BNDERR\";\n\tif (si_code == SEGV_PKUERR)\n\t\treturn \"SEGV_PKUERR\";\n\treturn \"UNKNOWN\";\n}\n\nint pkey_faults;\nint last_si_pkey = -1;\nvoid signal_handler(int signum, siginfo_t *si, void *vucontext)\n{\n\tucontext_t *uctxt = vucontext;\n\tint trapno;\n\tunsigned long ip;\n\tchar *fpregs;\n#if defined(__i386__) || defined(__x86_64__)  \n\tu32 *pkey_reg_ptr;\n\tint pkey_reg_offset;\n#endif  \n\tu64 siginfo_pkey;\n\tu32 *si_pkey_ptr;\n\n\tdprint_in_signal = 1;\n\tdprintf1(\">>>>===============SIGSEGV============================\\n\");\n\tdprintf1(\"%s()::%d, pkey_reg: 0x%016llx shadow: %016llx\\n\",\n\t\t\t__func__, __LINE__,\n\t\t\t__read_pkey_reg(), shadow_pkey_reg);\n\n\ttrapno = uctxt->uc_mcontext.gregs[REG_TRAPNO];\n\tip = uctxt->uc_mcontext.gregs[REG_IP_IDX];\n\tfpregs = (char *) uctxt->uc_mcontext.fpregs;\n\n\tdprintf2(\"%s() trapno: %d ip: 0x%016lx info->si_code: %s/%d\\n\",\n\t\t\t__func__, trapno, ip, si_code_str(si->si_code),\n\t\t\tsi->si_code);\n\n#if defined(__i386__) || defined(__x86_64__)  \n#ifdef __i386__\n\t \n\tfpregs += 0x70;\n#endif  \n\tpkey_reg_offset = pkey_reg_xstate_offset();\n\tpkey_reg_ptr = (void *)(&fpregs[pkey_reg_offset]);\n\n\t \n\tdprintf1(\"pkey_reg_xstate_offset: %d\\n\", pkey_reg_xstate_offset());\n\tif (DEBUG_LEVEL > 4)\n\t\tdump_mem(pkey_reg_ptr - 128, 256);\n\tpkey_assert(*pkey_reg_ptr);\n#endif  \n\n\tdprintf1(\"siginfo: %p\\n\", si);\n\tdprintf1(\" fpregs: %p\\n\", fpregs);\n\n\tif ((si->si_code == SEGV_MAPERR) ||\n\t    (si->si_code == SEGV_ACCERR) ||\n\t    (si->si_code == SEGV_BNDERR)) {\n\t\tprintf(\"non-PK si_code, exiting...\\n\");\n\t\texit(4);\n\t}\n\n\tsi_pkey_ptr = siginfo_get_pkey_ptr(si);\n\tdprintf1(\"si_pkey_ptr: %p\\n\", si_pkey_ptr);\n\tdump_mem((u8 *)si_pkey_ptr - 8, 24);\n\tsiginfo_pkey = *si_pkey_ptr;\n\tpkey_assert(siginfo_pkey < NR_PKEYS);\n\tlast_si_pkey = siginfo_pkey;\n\n\t \n\tdprintf1(\"signal pkey_reg from  pkey_reg: %016llx\\n\",\n\t\t\t__read_pkey_reg());\n\tdprintf1(\"pkey from siginfo: %016llx\\n\", siginfo_pkey);\n#if defined(__i386__) || defined(__x86_64__)  \n\tdprintf1(\"signal pkey_reg from xsave: %08x\\n\", *pkey_reg_ptr);\n\t*(u64 *)pkey_reg_ptr = 0x00000000;\n\tdprintf1(\"WARNING: set PKEY_REG=0 to allow faulting instruction to continue\\n\");\n#elif defined(__powerpc64__)  \n\t \n\tpkey_access_allow(siginfo_pkey);\n#endif  \n\tpkey_faults++;\n\tdprintf1(\"<<<<==================================================\\n\");\n\tdprint_in_signal = 0;\n}\n\nint wait_all_children(void)\n{\n\tint status;\n\treturn waitpid(-1, &status, 0);\n}\n\nvoid sig_chld(int x)\n{\n\tdprint_in_signal = 1;\n\tdprintf2(\"[%d] SIGCHLD: %d\\n\", getpid(), x);\n\tdprint_in_signal = 0;\n}\n\nvoid setup_sigsegv_handler(void)\n{\n\tint r, rs;\n\tstruct sigaction newact;\n\tstruct sigaction oldact;\n\n\t \n\tint signum  = SIGSEGV;\n\n\tnewact.sa_handler = 0;\n\tnewact.sa_sigaction = signal_handler;\n\n\t \n\t \n\trs = sigprocmask(SIG_SETMASK, 0, &newact.sa_mask);\n\tpkey_assert(rs == 0);\n\n\t \n\tnewact.sa_flags = SA_SIGINFO;\n\n\tnewact.sa_restorer = 0;   \n\tr = sigaction(signum, &newact, &oldact);\n\tr = sigaction(SIGALRM, &newact, &oldact);\n\tpkey_assert(r == 0);\n}\n\nvoid setup_handlers(void)\n{\n\tsignal(SIGCHLD, &sig_chld);\n\tsetup_sigsegv_handler();\n}\n\npid_t fork_lazy_child(void)\n{\n\tpid_t forkret;\n\n\tforkret = fork();\n\tpkey_assert(forkret >= 0);\n\tdprintf3(\"[%d] fork() ret: %d\\n\", getpid(), forkret);\n\n\tif (!forkret) {\n\t\t \n\t\twhile (1) {\n\t\t\tdprintf1(\"child sleeping...\\n\");\n\t\t\tsleep(30);\n\t\t}\n\t}\n\treturn forkret;\n}\n\nint sys_mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,\n\t\tunsigned long pkey)\n{\n\tint sret;\n\n\tdprintf2(\"%s(0x%p, %zx, prot=%lx, pkey=%lx)\\n\", __func__,\n\t\t\tptr, size, orig_prot, pkey);\n\n\terrno = 0;\n\tsret = syscall(__NR_pkey_mprotect, ptr, size, orig_prot, pkey);\n\tif (errno) {\n\t\tdprintf2(\"SYS_mprotect_key sret: %d\\n\", sret);\n\t\tdprintf2(\"SYS_mprotect_key prot: 0x%lx\\n\", orig_prot);\n\t\tdprintf2(\"SYS_mprotect_key failed, errno: %d\\n\", errno);\n\t\tif (DEBUG_LEVEL >= 2)\n\t\t\tperror(\"SYS_mprotect_pkey\");\n\t}\n\treturn sret;\n}\n\nint sys_pkey_alloc(unsigned long flags, unsigned long init_val)\n{\n\tint ret = syscall(SYS_pkey_alloc, flags, init_val);\n\tdprintf1(\"%s(flags=%lx, init_val=%lx) syscall ret: %d errno: %d\\n\",\n\t\t\t__func__, flags, init_val, ret, errno);\n\treturn ret;\n}\n\nint alloc_pkey(void)\n{\n\tint ret;\n\tunsigned long init_val = 0x0;\n\n\tdprintf1(\"%s()::%d, pkey_reg: 0x%016llx shadow: %016llx\\n\",\n\t\t\t__func__, __LINE__, __read_pkey_reg(), shadow_pkey_reg);\n\tret = sys_pkey_alloc(0, init_val);\n\t \n\tdprintf4(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t__func__, __LINE__, ret, __read_pkey_reg(),\n\t\t\tshadow_pkey_reg);\n\tif (ret > 0) {\n\t\t \n\t\tshadow_pkey_reg = set_pkey_bits(shadow_pkey_reg, ret,\n\t\t\t\t\t\t~PKEY_MASK);\n\t\tdprintf4(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t\t__func__,\n\t\t\t\t__LINE__, ret, __read_pkey_reg(),\n\t\t\t\tshadow_pkey_reg);\n\t\t \n\t\tshadow_pkey_reg = set_pkey_bits(shadow_pkey_reg, ret,\n\t\t\t\t\t\tinit_val);\n\t}\n\tdprintf4(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t__func__, __LINE__, ret, __read_pkey_reg(),\n\t\t\tshadow_pkey_reg);\n\tdprintf1(\"%s()::%d errno: %d\\n\", __func__, __LINE__, errno);\n\t \n\tread_pkey_reg();\n\tdprintf4(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t \" shadow: 0x%016llx\\n\",\n\t\t__func__, __LINE__, ret, __read_pkey_reg(),\n\t\tshadow_pkey_reg);\n\treturn ret;\n}\n\nint sys_pkey_free(unsigned long pkey)\n{\n\tint ret = syscall(SYS_pkey_free, pkey);\n\tdprintf1(\"%s(pkey=%ld) syscall ret: %d\\n\", __func__, pkey, ret);\n\treturn ret;\n}\n\n \nint alloc_random_pkey(void)\n{\n\tint max_nr_pkey_allocs;\n\tint ret;\n\tint i;\n\tint alloced_pkeys[NR_PKEYS];\n\tint nr_alloced = 0;\n\tint random_index;\n\tmemset(alloced_pkeys, 0, sizeof(alloced_pkeys));\n\n\t \n\tmax_nr_pkey_allocs = NR_PKEYS;\n\tfor (i = 0; i < max_nr_pkey_allocs; i++) {\n\t\tint new_pkey = alloc_pkey();\n\t\tif (new_pkey < 0)\n\t\t\tbreak;\n\t\talloced_pkeys[nr_alloced++] = new_pkey;\n\t}\n\n\tpkey_assert(nr_alloced > 0);\n\t \n\trandom_index = rand() % nr_alloced;\n\tret = alloced_pkeys[random_index];\n\t \n\talloced_pkeys[random_index] = 0;\n\n\t \n\tfor (i = 0; i < nr_alloced; i++) {\n\t\tint free_ret;\n\t\tif (!alloced_pkeys[i])\n\t\t\tcontinue;\n\t\tfree_ret = sys_pkey_free(alloced_pkeys[i]);\n\t\tpkey_assert(!free_ret);\n\t}\n\tdprintf1(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t \" shadow: 0x%016llx\\n\", __func__,\n\t\t\t__LINE__, ret, __read_pkey_reg(), shadow_pkey_reg);\n\treturn ret;\n}\n\nint mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,\n\t\tunsigned long pkey)\n{\n\tint nr_iterations = random() % 100;\n\tint ret;\n\n\twhile (0) {\n\t\tint rpkey = alloc_random_pkey();\n\t\tret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);\n\t\tdprintf1(\"sys_mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\\n\",\n\t\t\t\tptr, size, orig_prot, pkey, ret);\n\t\tif (nr_iterations-- < 0)\n\t\t\tbreak;\n\n\t\tdprintf1(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t__func__, __LINE__, ret, __read_pkey_reg(),\n\t\t\tshadow_pkey_reg);\n\t\tsys_pkey_free(rpkey);\n\t\tdprintf1(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t__func__, __LINE__, ret, __read_pkey_reg(),\n\t\t\tshadow_pkey_reg);\n\t}\n\tpkey_assert(pkey < NR_PKEYS);\n\n\tret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);\n\tdprintf1(\"mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\\n\",\n\t\t\tptr, size, orig_prot, pkey, ret);\n\tpkey_assert(!ret);\n\tdprintf1(\"%s()::%d, ret: %d pkey_reg: 0x%016llx\"\n\t\t\t\" shadow: 0x%016llx\\n\", __func__,\n\t\t\t__LINE__, ret, __read_pkey_reg(), shadow_pkey_reg);\n\treturn ret;\n}\n\nstruct pkey_malloc_record {\n\tvoid *ptr;\n\tlong size;\n\tint prot;\n};\nstruct pkey_malloc_record *pkey_malloc_records;\nstruct pkey_malloc_record *pkey_last_malloc_record;\nlong nr_pkey_malloc_records;\nvoid record_pkey_malloc(void *ptr, long size, int prot)\n{\n\tlong i;\n\tstruct pkey_malloc_record *rec = NULL;\n\n\tfor (i = 0; i < nr_pkey_malloc_records; i++) {\n\t\trec = &pkey_malloc_records[i];\n\t\t \n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\tif (!rec) {\n\t\t \n\t\tsize_t old_nr_records = nr_pkey_malloc_records;\n\t\tsize_t new_nr_records = (nr_pkey_malloc_records * 2 + 1);\n\t\tsize_t new_size = new_nr_records * sizeof(struct pkey_malloc_record);\n\t\tdprintf2(\"new_nr_records: %zd\\n\", new_nr_records);\n\t\tdprintf2(\"new_size: %zd\\n\", new_size);\n\t\tpkey_malloc_records = realloc(pkey_malloc_records, new_size);\n\t\tpkey_assert(pkey_malloc_records != NULL);\n\t\trec = &pkey_malloc_records[nr_pkey_malloc_records];\n\t\t \n\t\tfor (i = 0; i < new_nr_records - old_nr_records; i++)\n\t\t\tmemset(rec + i, 0, sizeof(*rec));\n\t}\n\tdprintf3(\"filling malloc record[%d/%p]: {%p, %ld}\\n\",\n\t\t(int)(rec - pkey_malloc_records), rec, ptr, size);\n\trec->ptr = ptr;\n\trec->size = size;\n\trec->prot = prot;\n\tpkey_last_malloc_record = rec;\n\tnr_pkey_malloc_records++;\n}\n\nvoid free_pkey_malloc(void *ptr)\n{\n\tlong i;\n\tint ret;\n\tdprintf3(\"%s(%p)\\n\", __func__, ptr);\n\tfor (i = 0; i < nr_pkey_malloc_records; i++) {\n\t\tstruct pkey_malloc_record *rec = &pkey_malloc_records[i];\n\t\tdprintf4(\"looking for ptr %p at record[%ld/%p]: {%p, %ld}\\n\",\n\t\t\t\tptr, i, rec, rec->ptr, rec->size);\n\t\tif ((ptr <  rec->ptr) ||\n\t\t    (ptr >= rec->ptr + rec->size))\n\t\t\tcontinue;\n\n\t\tdprintf3(\"found ptr %p at record[%ld/%p]: {%p, %ld}\\n\",\n\t\t\t\tptr, i, rec, rec->ptr, rec->size);\n\t\tnr_pkey_malloc_records--;\n\t\tret = munmap(rec->ptr, rec->size);\n\t\tdprintf3(\"munmap ret: %d\\n\", ret);\n\t\tpkey_assert(!ret);\n\t\tdprintf3(\"clearing rec->ptr, rec: %p\\n\", rec);\n\t\trec->ptr = NULL;\n\t\tdprintf3(\"done clearing rec->ptr, rec: %p\\n\", rec);\n\t\treturn;\n\t}\n\tpkey_assert(false);\n}\n\n\nvoid *malloc_pkey_with_mprotect(long size, int prot, u16 pkey)\n{\n\tvoid *ptr;\n\tint ret;\n\n\tread_pkey_reg();\n\tdprintf1(\"doing %s(size=%ld, prot=0x%x, pkey=%d)\\n\", __func__,\n\t\t\tsize, prot, pkey);\n\tpkey_assert(pkey < NR_PKEYS);\n\tptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\tpkey_assert(ptr != (void *)-1);\n\tret = mprotect_pkey((void *)ptr, PAGE_SIZE, prot, pkey);\n\tpkey_assert(!ret);\n\trecord_pkey_malloc(ptr, size, prot);\n\tread_pkey_reg();\n\n\tdprintf1(\"%s() for pkey %d @ %p\\n\", __func__, pkey, ptr);\n\treturn ptr;\n}\n\nvoid *malloc_pkey_anon_huge(long size, int prot, u16 pkey)\n{\n\tint ret;\n\tvoid *ptr;\n\n\tdprintf1(\"doing %s(size=%ld, prot=0x%x, pkey=%d)\\n\", __func__,\n\t\t\tsize, prot, pkey);\n\t \n\tsize = ALIGN_UP(size, HPAGE_SIZE * 2);\n\tptr = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\tpkey_assert(ptr != (void *)-1);\n\trecord_pkey_malloc(ptr, size, prot);\n\tmprotect_pkey(ptr, size, prot, pkey);\n\n\tdprintf1(\"unaligned ptr: %p\\n\", ptr);\n\tptr = ALIGN_PTR_UP(ptr, HPAGE_SIZE);\n\tdprintf1(\"  aligned ptr: %p\\n\", ptr);\n\tret = madvise(ptr, HPAGE_SIZE, MADV_HUGEPAGE);\n\tdprintf1(\"MADV_HUGEPAGE ret: %d\\n\", ret);\n\tret = madvise(ptr, HPAGE_SIZE, MADV_WILLNEED);\n\tdprintf1(\"MADV_WILLNEED ret: %d\\n\", ret);\n\tmemset(ptr, 0, HPAGE_SIZE);\n\n\tdprintf1(\"mmap()'d thp for pkey %d @ %p\\n\", pkey, ptr);\n\treturn ptr;\n}\n\nint hugetlb_setup_ok;\n#define SYSFS_FMT_NR_HUGE_PAGES \"/sys/kernel/mm/hugepages/hugepages-%ldkB/nr_hugepages\"\n#define GET_NR_HUGE_PAGES 10\nvoid setup_hugetlbfs(void)\n{\n\tint err;\n\tint fd;\n\tchar buf[256];\n\tlong hpagesz_kb;\n\tlong hpagesz_mb;\n\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"WARNING: not run as root, can not do hugetlb test\\n\");\n\t\treturn;\n\t}\n\n\tcat_into_file(__stringify(GET_NR_HUGE_PAGES), \"/proc/sys/vm/nr_hugepages\");\n\n\t \n\thpagesz_kb = HPAGE_SIZE / 1024;\n\thpagesz_mb = hpagesz_kb / 1024;\n\tsprintf(buf, SYSFS_FMT_NR_HUGE_PAGES, hpagesz_kb);\n\tfd = open(buf, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"opening sysfs %ldM hugetlb config: %s\\n\",\n\t\t\thpagesz_mb, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\terr = read(fd, buf, sizeof(buf)-1);\n\tclose(fd);\n\tif (err <= 0) {\n\t\tfprintf(stderr, \"reading sysfs %ldM hugetlb config: %s\\n\",\n\t\t\thpagesz_mb, strerror(errno));\n\t\treturn;\n\t}\n\n\tif (atoi(buf) != GET_NR_HUGE_PAGES) {\n\t\tfprintf(stderr, \"could not confirm %ldM pages, got: '%s' expected %d\\n\",\n\t\t\thpagesz_mb, buf, GET_NR_HUGE_PAGES);\n\t\treturn;\n\t}\n\n\thugetlb_setup_ok = 1;\n}\n\nvoid *malloc_pkey_hugetlb(long size, int prot, u16 pkey)\n{\n\tvoid *ptr;\n\tint flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB;\n\n\tif (!hugetlb_setup_ok)\n\t\treturn PTR_ERR_ENOTSUP;\n\n\tdprintf1(\"doing %s(%ld, %x, %x)\\n\", __func__, size, prot, pkey);\n\tsize = ALIGN_UP(size, HPAGE_SIZE * 2);\n\tpkey_assert(pkey < NR_PKEYS);\n\tptr = mmap(NULL, size, PROT_NONE, flags, -1, 0);\n\tpkey_assert(ptr != (void *)-1);\n\tmprotect_pkey(ptr, size, prot, pkey);\n\n\trecord_pkey_malloc(ptr, size, prot);\n\n\tdprintf1(\"mmap()'d hugetlbfs for pkey %d @ %p\\n\", pkey, ptr);\n\treturn ptr;\n}\n\nvoid *malloc_pkey_mmap_dax(long size, int prot, u16 pkey)\n{\n\tvoid *ptr;\n\tint fd;\n\n\tdprintf1(\"doing %s(size=%ld, prot=0x%x, pkey=%d)\\n\", __func__,\n\t\t\tsize, prot, pkey);\n\tpkey_assert(pkey < NR_PKEYS);\n\tfd = open(\"/dax/foo\", O_RDWR);\n\tpkey_assert(fd >= 0);\n\n\tptr = mmap(0, size, prot, MAP_SHARED, fd, 0);\n\tpkey_assert(ptr != (void *)-1);\n\n\tmprotect_pkey(ptr, size, prot, pkey);\n\n\trecord_pkey_malloc(ptr, size, prot);\n\n\tdprintf1(\"mmap()'d for pkey %d @ %p\\n\", pkey, ptr);\n\tclose(fd);\n\treturn ptr;\n}\n\nvoid *(*pkey_malloc[])(long size, int prot, u16 pkey) = {\n\n\tmalloc_pkey_with_mprotect,\n\tmalloc_pkey_with_mprotect_subpage,\n\tmalloc_pkey_anon_huge,\n\tmalloc_pkey_hugetlb\n \n};\n\nvoid *malloc_pkey(long size, int prot, u16 pkey)\n{\n\tvoid *ret;\n\tstatic int malloc_type;\n\tint nr_malloc_types = ARRAY_SIZE(pkey_malloc);\n\n\tpkey_assert(pkey < NR_PKEYS);\n\n\twhile (1) {\n\t\tpkey_assert(malloc_type < nr_malloc_types);\n\n\t\tret = pkey_malloc[malloc_type](size, prot, pkey);\n\t\tpkey_assert(ret != (void *)-1);\n\n\t\tmalloc_type++;\n\t\tif (malloc_type >= nr_malloc_types)\n\t\t\tmalloc_type = (random()%nr_malloc_types);\n\n\t\t \n\t\tif (ret == PTR_ERR_ENOTSUP)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tdprintf3(\"%s(%ld, prot=%x, pkey=%x) returning: %p\\n\", __func__,\n\t\t\tsize, prot, pkey, ret);\n\treturn ret;\n}\n\nint last_pkey_faults;\n#define UNKNOWN_PKEY -2\nvoid expected_pkey_fault(int pkey)\n{\n\tdprintf2(\"%s(): last_pkey_faults: %d pkey_faults: %d\\n\",\n\t\t\t__func__, last_pkey_faults, pkey_faults);\n\tdprintf2(\"%s(%d): last_si_pkey: %d\\n\", __func__, pkey, last_si_pkey);\n\tpkey_assert(last_pkey_faults + 1 == pkey_faults);\n\n        \n\tif (pkey != UNKNOWN_PKEY)\n\t\tpkey_assert(last_si_pkey == pkey);\n\n#if defined(__i386__) || defined(__x86_64__)  \n\t \n\tif (__read_pkey_reg() != 0)\n#else  \n\tif (__read_pkey_reg() != shadow_pkey_reg)\n#endif  \n\t\tpkey_assert(0);\n\n\t__write_pkey_reg(shadow_pkey_reg);\n\tdprintf1(\"%s() set pkey_reg=%016llx to restore state after signal \"\n\t\t       \"nuked it\\n\", __func__, shadow_pkey_reg);\n\tlast_pkey_faults = pkey_faults;\n\tlast_si_pkey = -1;\n}\n\n#define do_not_expect_pkey_fault(msg)\tdo {\t\t\t\\\n\tif (last_pkey_faults != pkey_faults)\t\t\t\\\n\t\tdprintf0(\"unexpected PKey fault: %s\\n\", msg);\t\\\n\tpkey_assert(last_pkey_faults == pkey_faults);\t\t\\\n} while (0)\n\nint test_fds[10] = { -1 };\nint nr_test_fds;\nvoid __save_test_fd(int fd)\n{\n\tpkey_assert(fd >= 0);\n\tpkey_assert(nr_test_fds < ARRAY_SIZE(test_fds));\n\ttest_fds[nr_test_fds] = fd;\n\tnr_test_fds++;\n}\n\nint get_test_read_fd(void)\n{\n\tint test_fd = open(\"/etc/passwd\", O_RDONLY);\n\t__save_test_fd(test_fd);\n\treturn test_fd;\n}\n\nvoid close_test_fds(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_test_fds; i++) {\n\t\tif (test_fds[i] < 0)\n\t\t\tcontinue;\n\t\tclose(test_fds[i]);\n\t\ttest_fds[i] = -1;\n\t}\n\tnr_test_fds = 0;\n}\n\n#define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n__attribute__((noinline)) int read_ptr(int *ptr)\n{\n\t \n\tbarrier();\n\treturn *ptr;\n}\n\nvoid test_pkey_alloc_free_attach_pkey0(int *ptr, u16 pkey)\n{\n\tint i, err;\n\tint max_nr_pkey_allocs;\n\tint alloced_pkeys[NR_PKEYS];\n\tint nr_alloced = 0;\n\tlong size;\n\n\tpkey_assert(pkey_last_malloc_record);\n\tsize = pkey_last_malloc_record->size;\n\t \n\tif (size >= HPAGE_SIZE)\n\t\tsize = HPAGE_SIZE;\n\n\t \n\tmax_nr_pkey_allocs = NR_PKEYS;\n\tfor (i = 0; i < max_nr_pkey_allocs; i++) {\n\t\tint new_pkey = alloc_pkey();\n\t\tpkey_assert(new_pkey != 0);\n\n\t\tif (new_pkey < 0)\n\t\t\tbreak;\n\t\talloced_pkeys[nr_alloced++] = new_pkey;\n\t}\n\t \n\tfor (i = 0; i < nr_alloced; i++) {\n\t\tint free_ret;\n\n\t\tif (!alloced_pkeys[i])\n\t\t\tcontinue;\n\t\tfree_ret = sys_pkey_free(alloced_pkeys[i]);\n\t\tpkey_assert(!free_ret);\n\t}\n\n\t \n\terr = sys_mprotect_pkey(ptr, size, PROT_READ, 0);\n\tpkey_assert(!err);\n\terr = sys_mprotect_pkey(ptr, size, PROT_WRITE, 0);\n\tpkey_assert(!err);\n\terr = sys_mprotect_pkey(ptr, size, PROT_EXEC, 0);\n\tpkey_assert(!err);\n\terr = sys_mprotect_pkey(ptr, size, PROT_READ|PROT_WRITE, 0);\n\tpkey_assert(!err);\n\terr = sys_mprotect_pkey(ptr, size, PROT_READ|PROT_WRITE|PROT_EXEC, 0);\n\tpkey_assert(!err);\n}\n\nvoid test_read_of_write_disabled_region(int *ptr, u16 pkey)\n{\n\tint ptr_contents;\n\n\tdprintf1(\"disabling write access to PKEY[1], doing read\\n\");\n\tpkey_write_deny(pkey);\n\tptr_contents = read_ptr(ptr);\n\tdprintf1(\"*ptr: %d\\n\", ptr_contents);\n\tdprintf1(\"\\n\");\n}\nvoid test_read_of_access_disabled_region(int *ptr, u16 pkey)\n{\n\tint ptr_contents;\n\n\tdprintf1(\"disabling access to PKEY[%02d], doing read @ %p\\n\", pkey, ptr);\n\tread_pkey_reg();\n\tpkey_access_deny(pkey);\n\tptr_contents = read_ptr(ptr);\n\tdprintf1(\"*ptr: %d\\n\", ptr_contents);\n\texpected_pkey_fault(pkey);\n}\n\nvoid test_read_of_access_disabled_region_with_page_already_mapped(int *ptr,\n\t\tu16 pkey)\n{\n\tint ptr_contents;\n\n\tdprintf1(\"disabling access to PKEY[%02d], doing read @ %p\\n\",\n\t\t\t\tpkey, ptr);\n\tptr_contents = read_ptr(ptr);\n\tdprintf1(\"reading ptr before disabling the read : %d\\n\",\n\t\t\tptr_contents);\n\tread_pkey_reg();\n\tpkey_access_deny(pkey);\n\tptr_contents = read_ptr(ptr);\n\tdprintf1(\"*ptr: %d\\n\", ptr_contents);\n\texpected_pkey_fault(pkey);\n}\n\nvoid test_write_of_write_disabled_region_with_page_already_mapped(int *ptr,\n\t\tu16 pkey)\n{\n\t*ptr = __LINE__;\n\tdprintf1(\"disabling write access; after accessing the page, \"\n\t\t\"to PKEY[%02d], doing write\\n\", pkey);\n\tpkey_write_deny(pkey);\n\t*ptr = __LINE__;\n\texpected_pkey_fault(pkey);\n}\n\nvoid test_write_of_write_disabled_region(int *ptr, u16 pkey)\n{\n\tdprintf1(\"disabling write access to PKEY[%02d], doing write\\n\", pkey);\n\tpkey_write_deny(pkey);\n\t*ptr = __LINE__;\n\texpected_pkey_fault(pkey);\n}\nvoid test_write_of_access_disabled_region(int *ptr, u16 pkey)\n{\n\tdprintf1(\"disabling access to PKEY[%02d], doing write\\n\", pkey);\n\tpkey_access_deny(pkey);\n\t*ptr = __LINE__;\n\texpected_pkey_fault(pkey);\n}\n\nvoid test_write_of_access_disabled_region_with_page_already_mapped(int *ptr,\n\t\t\tu16 pkey)\n{\n\t*ptr = __LINE__;\n\tdprintf1(\"disabling access; after accessing the page, \"\n\t\t\" to PKEY[%02d], doing write\\n\", pkey);\n\tpkey_access_deny(pkey);\n\t*ptr = __LINE__;\n\texpected_pkey_fault(pkey);\n}\n\nvoid test_kernel_write_of_access_disabled_region(int *ptr, u16 pkey)\n{\n\tint ret;\n\tint test_fd = get_test_read_fd();\n\n\tdprintf1(\"disabling access to PKEY[%02d], \"\n\t\t \"having kernel read() to buffer\\n\", pkey);\n\tpkey_access_deny(pkey);\n\tret = read(test_fd, ptr, 1);\n\tdprintf1(\"read ret: %d\\n\", ret);\n\tpkey_assert(ret);\n}\nvoid test_kernel_write_of_write_disabled_region(int *ptr, u16 pkey)\n{\n\tint ret;\n\tint test_fd = get_test_read_fd();\n\n\tpkey_write_deny(pkey);\n\tret = read(test_fd, ptr, 100);\n\tdprintf1(\"read ret: %d\\n\", ret);\n\tif (ret < 0 && (DEBUG_LEVEL > 0))\n\t\tperror(\"verbose read result (OK for this to be bad)\");\n\tpkey_assert(ret);\n}\n\nvoid test_kernel_gup_of_access_disabled_region(int *ptr, u16 pkey)\n{\n\tint pipe_ret, vmsplice_ret;\n\tstruct iovec iov;\n\tint pipe_fds[2];\n\n\tpipe_ret = pipe(pipe_fds);\n\n\tpkey_assert(pipe_ret == 0);\n\tdprintf1(\"disabling access to PKEY[%02d], \"\n\t\t \"having kernel vmsplice from buffer\\n\", pkey);\n\tpkey_access_deny(pkey);\n\tiov.iov_base = ptr;\n\tiov.iov_len = PAGE_SIZE;\n\tvmsplice_ret = vmsplice(pipe_fds[1], &iov, 1, SPLICE_F_GIFT);\n\tdprintf1(\"vmsplice() ret: %d\\n\", vmsplice_ret);\n\tpkey_assert(vmsplice_ret == -1);\n\n\tclose(pipe_fds[0]);\n\tclose(pipe_fds[1]);\n}\n\nvoid test_kernel_gup_write_to_write_disabled_region(int *ptr, u16 pkey)\n{\n\tint ignored = 0xdada;\n\tint futex_ret;\n\tint some_int = __LINE__;\n\n\tdprintf1(\"disabling write to PKEY[%02d], \"\n\t\t \"doing futex gunk in buffer\\n\", pkey);\n\t*ptr = some_int;\n\tpkey_write_deny(pkey);\n\tfutex_ret = syscall(SYS_futex, ptr, FUTEX_WAIT, some_int-1, NULL,\n\t\t\t&ignored, ignored);\n\tif (DEBUG_LEVEL > 0)\n\t\tperror(\"futex\");\n\tdprintf1(\"futex() ret: %d\\n\", futex_ret);\n}\n\n \nvoid test_pkey_syscalls_on_non_allocated_pkey(int *ptr, u16 pkey)\n{\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 1; i < NR_PKEYS; i++) {\n\t\tif (pkey == i)\n\t\t\tcontinue;\n\n\t\tdprintf1(\"trying get/set/free to non-allocated pkey: %2d\\n\", i);\n\t\terr = sys_pkey_free(i);\n\t\tpkey_assert(err);\n\n\t\terr = sys_pkey_free(i);\n\t\tpkey_assert(err);\n\n\t\terr = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, i);\n\t\tpkey_assert(err);\n\t}\n}\n\n \nvoid test_pkey_syscalls_bad_args(int *ptr, u16 pkey)\n{\n\tint err;\n\tint bad_pkey = NR_PKEYS+99;\n\n\t \n\terr = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, bad_pkey);\n\tpkey_assert(err);\n}\n\nvoid become_child(void)\n{\n\tpid_t forkret;\n\n\tforkret = fork();\n\tpkey_assert(forkret >= 0);\n\tdprintf3(\"[%d] fork() ret: %d\\n\", getpid(), forkret);\n\n\tif (!forkret) {\n\t\t \n\t\treturn;\n\t}\n\texit(0);\n}\n\n \nvoid test_pkey_alloc_exhaust(int *ptr, u16 pkey)\n{\n\tint err;\n\tint allocated_pkeys[NR_PKEYS] = {0};\n\tint nr_allocated_pkeys = 0;\n\tint i;\n\n\tfor (i = 0; i < NR_PKEYS*3; i++) {\n\t\tint new_pkey;\n\t\tdprintf1(\"%s() alloc loop: %d\\n\", __func__, i);\n\t\tnew_pkey = alloc_pkey();\n\t\tdprintf4(\"%s()::%d, err: %d pkey_reg: 0x%016llx\"\n\t\t\t\t\" shadow: 0x%016llx\\n\",\n\t\t\t\t__func__, __LINE__, err, __read_pkey_reg(),\n\t\t\t\tshadow_pkey_reg);\n\t\tread_pkey_reg();  \n\t\tdprintf2(\"%s() errno: %d ENOSPC: %d\\n\", __func__, errno, ENOSPC);\n\t\tif ((new_pkey == -1) && (errno == ENOSPC)) {\n\t\t\tdprintf2(\"%s() failed to allocate pkey after %d tries\\n\",\n\t\t\t\t__func__, nr_allocated_pkeys);\n\t\t} else {\n\t\t\t \n\t\t\tpkey_assert(nr_allocated_pkeys < NR_PKEYS);\n\t\t\tallocated_pkeys[nr_allocated_pkeys++] = new_pkey;\n\t\t}\n\n\t\t \n\t\tif (i == NR_PKEYS*2)\n\t\t\tbecome_child();\n\t}\n\n\tdprintf3(\"%s()::%d\\n\", __func__, __LINE__);\n\n\t \n\tpkey_assert(i >= (NR_PKEYS - get_arch_reserved_keys() - 1));\n\n\tfor (i = 0; i < nr_allocated_pkeys; i++) {\n\t\terr = sys_pkey_free(allocated_pkeys[i]);\n\t\tpkey_assert(!err);\n\t\tread_pkey_reg();  \n\t}\n}\n\nvoid arch_force_pkey_reg_init(void)\n{\n#if defined(__i386__) || defined(__x86_64__)  \n\tu64 *buf;\n\n\t \n\tif (read_pkey_reg())\n\t\treturn;\n\n\t \n\tbuf = mmap(NULL, 1*MB, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\n\t \n\n\t \n\t__builtin_ia32_xsave(buf, XSTATE_PKEY);\n\t \n\tbuf[XSTATE_BV_OFFSET/sizeof(u64)] &= ~XSTATE_PKEY;\n\t \n\t__builtin_ia32_xrstor(buf, XSTATE_PKEY);\n\n\tmunmap(buf, 1*MB);\n#endif\n}\n\n\n \nvoid test_pkey_init_state(int *ptr, u16 pkey)\n{\n\tint err;\n\tint allocated_pkeys[NR_PKEYS] = {0};\n\tint nr_allocated_pkeys = 0;\n\tint i;\n\n\tfor (i = 0; i < NR_PKEYS; i++) {\n\t\tint new_pkey = alloc_pkey();\n\n\t\tif (new_pkey < 0)\n\t\t\tcontinue;\n\t\tallocated_pkeys[nr_allocated_pkeys++] = new_pkey;\n\t}\n\n\tdprintf3(\"%s()::%d\\n\", __func__, __LINE__);\n\n\tarch_force_pkey_reg_init();\n\n\t \n\tfor (i = 0; i < 1000000; i++)\n\t\tread_pkey_reg();\n\n\tfor (i = 0; i < nr_allocated_pkeys; i++) {\n\t\terr = sys_pkey_free(allocated_pkeys[i]);\n\t\tpkey_assert(!err);\n\t\tread_pkey_reg();  \n\t}\n}\n\n \nvoid test_mprotect_with_pkey_0(int *ptr, u16 pkey)\n{\n\tlong size;\n\tint prot;\n\n\tassert(pkey_last_malloc_record);\n\tsize = pkey_last_malloc_record->size;\n\t \n\tif (size >= HPAGE_SIZE)\n\t\tsize = HPAGE_SIZE;\n\tprot = pkey_last_malloc_record->prot;\n\n\t \n\tmprotect_pkey(ptr, size, prot, 0);\n\n\t \n\tmprotect_pkey(ptr, size, prot, pkey);\n}\n\nvoid test_ptrace_of_child(int *ptr, u16 pkey)\n{\n\t__attribute__((__unused__)) int peek_result;\n\tpid_t child_pid;\n\tvoid *ignored = 0;\n\tlong ret;\n\tint status;\n\t \n\tint *plain_ptr_unaligned = malloc(HPAGE_SIZE);\n\tint *plain_ptr = ALIGN_PTR_UP(plain_ptr_unaligned, PAGE_SIZE);\n\n\t \n\tchild_pid = fork_lazy_child();\n\tdprintf1(\"[%d] child pid: %d\\n\", getpid(), child_pid);\n\n\tret = ptrace(PTRACE_ATTACH, child_pid, ignored, ignored);\n\tif (ret)\n\t\tperror(\"attach\");\n\tdprintf1(\"[%d] attach ret: %ld %d\\n\", getpid(), ret, __LINE__);\n\tpkey_assert(ret != -1);\n\tret = waitpid(child_pid, &status, WUNTRACED);\n\tif ((ret != child_pid) || !(WIFSTOPPED(status))) {\n\t\tfprintf(stderr, \"weird waitpid result %ld stat %x\\n\",\n\t\t\t\tret, status);\n\t\tpkey_assert(0);\n\t}\n\tdprintf2(\"waitpid ret: %ld\\n\", ret);\n\tdprintf2(\"waitpid status: %d\\n\", status);\n\n\tpkey_access_deny(pkey);\n\tpkey_write_deny(pkey);\n\n\t \n\n\t \n\tret = ptrace(PTRACE_PEEKDATA, child_pid, ptr, ignored);\n\t \n\tpkey_assert(ret != -1);\n\t \n\tpeek_result = read_ptr(ptr);\n\texpected_pkey_fault(pkey);\n\n\t \n\tret = ptrace(PTRACE_PEEKDATA, child_pid, plain_ptr, ignored);\n\t \n\tpkey_assert(ret != -1);\n\t \n\tpeek_result = read_ptr(plain_ptr);\n\tdo_not_expect_pkey_fault(\"read plain pointer after ptrace\");\n\n\tret = ptrace(PTRACE_DETACH, child_pid, ignored, 0);\n\tpkey_assert(ret != -1);\n\n\tret = kill(child_pid, SIGKILL);\n\tpkey_assert(ret != -1);\n\n\twait(&status);\n\n\tfree(plain_ptr_unaligned);\n}\n\nvoid *get_pointer_to_instructions(void)\n{\n\tvoid *p1;\n\n\tp1 = ALIGN_PTR_UP(&lots_o_noops_around_write, PAGE_SIZE);\n\tdprintf3(\"&lots_o_noops: %p\\n\", &lots_o_noops_around_write);\n\t \n\tassert(p1 == &lots_o_noops_around_write);\n\n\t \n\tp1 += PAGE_SIZE;\n\n\t \n\tmadvise(p1, PAGE_SIZE, MADV_DONTNEED);\n\n\treturn p1;\n}\n\nvoid test_executing_on_unreadable_memory(int *ptr, u16 pkey)\n{\n\tvoid *p1;\n\tint scratch;\n\tint ptr_contents;\n\tint ret;\n\n\tp1 = get_pointer_to_instructions();\n\tlots_o_noops_around_write(&scratch);\n\tptr_contents = read_ptr(p1);\n\tdprintf2(\"ptr (%p) contents@%d: %x\\n\", p1, __LINE__, ptr_contents);\n\n\tret = mprotect_pkey(p1, PAGE_SIZE, PROT_EXEC, (u64)pkey);\n\tpkey_assert(!ret);\n\tpkey_access_deny(pkey);\n\n\tdprintf2(\"pkey_reg: %016llx\\n\", read_pkey_reg());\n\n\t \n\tmadvise(p1, PAGE_SIZE, MADV_DONTNEED);\n\tlots_o_noops_around_write(&scratch);\n\tdo_not_expect_pkey_fault(\"executing on PROT_EXEC memory\");\n\texpect_fault_on_read_execonly_key(p1, pkey);\n}\n\nvoid test_implicit_mprotect_exec_only_memory(int *ptr, u16 pkey)\n{\n\tvoid *p1;\n\tint scratch;\n\tint ptr_contents;\n\tint ret;\n\n\tdprintf1(\"%s() start\\n\", __func__);\n\n\tp1 = get_pointer_to_instructions();\n\tlots_o_noops_around_write(&scratch);\n\tptr_contents = read_ptr(p1);\n\tdprintf2(\"ptr (%p) contents@%d: %x\\n\", p1, __LINE__, ptr_contents);\n\n\t \n\tret = mprotect(p1, PAGE_SIZE, PROT_EXEC);\n\tpkey_assert(!ret);\n\n\t \n\tshadow_pkey_reg = __read_pkey_reg();\n\n\tdprintf2(\"pkey_reg: %016llx\\n\", read_pkey_reg());\n\n\t \n\tmadvise(p1, PAGE_SIZE, MADV_DONTNEED);\n\tlots_o_noops_around_write(&scratch);\n\tdo_not_expect_pkey_fault(\"executing on PROT_EXEC memory\");\n\texpect_fault_on_read_execonly_key(p1, UNKNOWN_PKEY);\n\n\t \n\tret = mprotect(p1, PAGE_SIZE, PROT_NONE);\n\tpkey_assert(!ret);\n\n\tret = mprotect(p1, PAGE_SIZE, PROT_READ|PROT_EXEC);\n\tpkey_assert(!ret);\n\tptr_contents = read_ptr(p1);\n\tdo_not_expect_pkey_fault(\"plain read on recently PROT_EXEC area\");\n}\n\n#if defined(__i386__) || defined(__x86_64__)\nvoid test_ptrace_modifies_pkru(int *ptr, u16 pkey)\n{\n\tu32 new_pkru;\n\tpid_t child;\n\tint status, ret;\n\tint pkey_offset = pkey_reg_xstate_offset();\n\tsize_t xsave_size = cpu_max_xsave_size();\n\tvoid *xsave;\n\tu32 *pkey_register;\n\tu64 *xstate_bv;\n\tstruct iovec iov;\n\n\tnew_pkru = ~read_pkey_reg();\n\t \n\tnew_pkru &= ~3;\n\n\tchild = fork();\n\tpkey_assert(child >= 0);\n\tdprintf3(\"[%d] fork() ret: %d\\n\", getpid(), child);\n\tif (!child) {\n\t\tptrace(PTRACE_TRACEME, 0, 0, 0);\n\t\t \n\t\traise(SIGSTOP);\n\n\t\t \n\t\tif (__read_pkey_reg() != new_pkru)\n\t\t\texit(1);\n\n\t\t \n\t\traise(SIGSTOP);\n\n\t\tif (__read_pkey_reg() != 0)\n\t\t\texit(1);\n\n\t\t \n\t\traise(SIGSTOP);\n\n\t\texit(0);\n\t}\n\n\tpkey_assert(child == waitpid(child, &status, 0));\n\tdprintf3(\"[%d] waitpid(%d) status: %x\\n\", getpid(), child, status);\n\tpkey_assert(WIFSTOPPED(status) && WSTOPSIG(status) == SIGSTOP);\n\n\txsave = (void *)malloc(xsave_size);\n\tpkey_assert(xsave > 0);\n\n\t \n\tiov.iov_base = xsave;\n\tiov.iov_len = xsave_size;\n\tret = ptrace(PTRACE_GETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\n\tpkey_register = (u32 *)(xsave + pkey_offset);\n\tpkey_assert(*pkey_register == read_pkey_reg());\n\n\t*pkey_register = new_pkru;\n\n\tret = ptrace(PTRACE_SETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\n\t \n\tmemset(xsave, 0xCC, xsave_size);\n\tret = ptrace(PTRACE_GETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\tpkey_assert(*pkey_register == new_pkru);\n\n\t \n\tret = ptrace(PTRACE_CONT, child, 0, 0);\n\tpkey_assert(ret == 0);\n\n\t \n\tpkey_assert(child == waitpid(child, &status, 0));\n\tdprintf3(\"[%d] waitpid(%d) status: %x\\n\", getpid(), child, status);\n\tpkey_assert(WIFSTOPPED(status) && WSTOPSIG(status) == SIGSTOP);\n\n\t \n\tmemset(xsave, 0xCC, xsave_size);\n\tret = ptrace(PTRACE_GETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\tpkey_assert(*pkey_register == new_pkru);\n\n\t \n\txstate_bv = (u64 *)(xsave + 512);\n\t*xstate_bv &= ~(1 << 9);\n\n\tret = ptrace(PTRACE_SETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\n\t \n\tmemset(xsave, 0xCC, xsave_size);\n\tret = ptrace(PTRACE_GETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\tpkey_assert(*pkey_register == 0);\n\n\tret = ptrace(PTRACE_CONT, child, 0, 0);\n\tpkey_assert(ret == 0);\n\n\t \n\tpkey_assert(child == waitpid(child, &status, 0));\n\tdprintf3(\"[%d] waitpid(%d) status: %x\\n\", getpid(), child, status);\n\tpkey_assert(WIFSTOPPED(status) && WSTOPSIG(status) == SIGSTOP);\n\n\t \n\tmemset(xsave, 0xCC, xsave_size);\n\tret = ptrace(PTRACE_GETREGSET, child, (void *)NT_X86_XSTATE, &iov);\n\tpkey_assert(ret == 0);\n\tpkey_assert(*pkey_register == 0);\n\n\tret = ptrace(PTRACE_CONT, child, 0, 0);\n\tpkey_assert(ret == 0);\n\tpkey_assert(child == waitpid(child, &status, 0));\n\tdprintf3(\"[%d] waitpid(%d) status: %x\\n\", getpid(), child, status);\n\tpkey_assert(WIFEXITED(status));\n\tpkey_assert(WEXITSTATUS(status) == 0);\n\tfree(xsave);\n}\n#endif\n\nvoid test_mprotect_pkey_on_unsupported_cpu(int *ptr, u16 pkey)\n{\n\tint size = PAGE_SIZE;\n\tint sret;\n\n\tif (cpu_has_pkeys()) {\n\t\tdprintf1(\"SKIP: %s: no CPU support\\n\", __func__);\n\t\treturn;\n\t}\n\n\tsret = syscall(__NR_pkey_mprotect, ptr, size, PROT_READ, pkey);\n\tpkey_assert(sret < 0);\n}\n\nvoid (*pkey_tests[])(int *ptr, u16 pkey) = {\n\ttest_read_of_write_disabled_region,\n\ttest_read_of_access_disabled_region,\n\ttest_read_of_access_disabled_region_with_page_already_mapped,\n\ttest_write_of_write_disabled_region,\n\ttest_write_of_write_disabled_region_with_page_already_mapped,\n\ttest_write_of_access_disabled_region,\n\ttest_write_of_access_disabled_region_with_page_already_mapped,\n\ttest_kernel_write_of_access_disabled_region,\n\ttest_kernel_write_of_write_disabled_region,\n\ttest_kernel_gup_of_access_disabled_region,\n\ttest_kernel_gup_write_to_write_disabled_region,\n\ttest_executing_on_unreadable_memory,\n\ttest_implicit_mprotect_exec_only_memory,\n\ttest_mprotect_with_pkey_0,\n\ttest_ptrace_of_child,\n\ttest_pkey_init_state,\n\ttest_pkey_syscalls_on_non_allocated_pkey,\n\ttest_pkey_syscalls_bad_args,\n\ttest_pkey_alloc_exhaust,\n\ttest_pkey_alloc_free_attach_pkey0,\n#if defined(__i386__) || defined(__x86_64__)\n\ttest_ptrace_modifies_pkru,\n#endif\n};\n\nvoid run_tests_once(void)\n{\n\tint *ptr;\n\tint prot = PROT_READ|PROT_WRITE;\n\n\tfor (test_nr = 0; test_nr < ARRAY_SIZE(pkey_tests); test_nr++) {\n\t\tint pkey;\n\t\tint orig_pkey_faults = pkey_faults;\n\n\t\tdprintf1(\"======================\\n\");\n\t\tdprintf1(\"test %d preparing...\\n\", test_nr);\n\n\t\ttracing_on();\n\t\tpkey = alloc_random_pkey();\n\t\tdprintf1(\"test %d starting with pkey: %d\\n\", test_nr, pkey);\n\t\tptr = malloc_pkey(PAGE_SIZE, prot, pkey);\n\t\tdprintf1(\"test %d starting...\\n\", test_nr);\n\t\tpkey_tests[test_nr](ptr, pkey);\n\t\tdprintf1(\"freeing test memory: %p\\n\", ptr);\n\t\tfree_pkey_malloc(ptr);\n\t\tsys_pkey_free(pkey);\n\n\t\tdprintf1(\"pkey_faults: %d\\n\", pkey_faults);\n\t\tdprintf1(\"orig_pkey_faults: %d\\n\", orig_pkey_faults);\n\n\t\ttracing_off();\n\t\tclose_test_fds();\n\n\t\tprintf(\"test %2d PASSED (iteration %d)\\n\", test_nr, iteration_nr);\n\t\tdprintf1(\"======================\\n\\n\");\n\t}\n\titeration_nr++;\n}\n\nvoid pkey_setup_shadow(void)\n{\n\tshadow_pkey_reg = __read_pkey_reg();\n}\n\nint main(void)\n{\n\tint nr_iterations = 22;\n\tint pkeys_supported = is_pkeys_supported();\n\n\tsrand((unsigned int)time(NULL));\n\n\tsetup_handlers();\n\n\tprintf(\"has pkeys: %d\\n\", pkeys_supported);\n\n\tif (!pkeys_supported) {\n\t\tint size = PAGE_SIZE;\n\t\tint *ptr;\n\n\t\tprintf(\"running PKEY tests for unsupported CPU/OS\\n\");\n\n\t\tptr  = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\t\tassert(ptr != (void *)-1);\n\t\ttest_mprotect_pkey_on_unsupported_cpu(ptr, 1);\n\t\texit(0);\n\t}\n\n\tpkey_setup_shadow();\n\tprintf(\"startup pkey_reg: %016llx\\n\", read_pkey_reg());\n\tsetup_hugetlbfs();\n\n\twhile (nr_iterations-- > 0)\n\t\trun_tests_once();\n\n\tprintf(\"done (all tests OK)\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}