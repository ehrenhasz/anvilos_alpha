{
  "module_name": "madv_populate.c",
  "hash_id": "58df1edaaf133929bcbfd1d12a0270c9364b4fbf71f9df3002ebe38898d9ba70",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/madv_populate.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/mman.h>\n#include <sys/mman.h>\n\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\n \n#define SIZE (2 * 1024 * 1024)\n\nstatic size_t pagesize;\n\nstatic void sense_support(void)\n{\n\tchar *addr;\n\tint ret;\n\n\taddr = mmap(0, pagesize, PROT_READ | PROT_WRITE,\n\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (!addr)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\n\tret = madvise(addr, pagesize, MADV_POPULATE_READ);\n\tif (ret)\n\t\tksft_exit_skip(\"MADV_POPULATE_READ is not available\\n\");\n\n\tret = madvise(addr, pagesize, MADV_POPULATE_WRITE);\n\tif (ret)\n\t\tksft_exit_skip(\"MADV_POPULATE_WRITE is not available\\n\");\n\n\tmunmap(addr, pagesize);\n}\n\nstatic void test_prot_read(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_READ);\n\tksft_test_result(!ret, \"MADV_POPULATE_READ with PROT_READ\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_WRITE);\n\tksft_test_result(ret == -1 && errno == EINVAL,\n\t\t\t \"MADV_POPULATE_WRITE with PROT_READ\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic void test_prot_write(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_READ);\n\tksft_test_result(ret == -1 && errno == EINVAL,\n\t\t\t \"MADV_POPULATE_READ with PROT_WRITE\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_WRITE);\n\tksft_test_result(!ret, \"MADV_POPULATE_WRITE with PROT_WRITE\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic void test_holes(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_READ | PROT_WRITE,\n\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\tret = munmap(addr + pagesize, pagesize);\n\tif (ret)\n\t\tksft_exit_fail_msg(\"munmap failed\\n\");\n\n\t \n\tret = madvise(addr, SIZE, MADV_POPULATE_READ);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_READ with holes in the middle\\n\");\n\tret = madvise(addr, SIZE, MADV_POPULATE_WRITE);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_WRITE with holes in the middle\\n\");\n\n\t \n\tret = madvise(addr, 2 * pagesize, MADV_POPULATE_READ);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_READ with holes at the end\\n\");\n\tret = madvise(addr, 2 * pagesize, MADV_POPULATE_WRITE);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_WRITE with holes at the end\\n\");\n\n\t \n\tret = madvise(addr + pagesize, pagesize, MADV_POPULATE_READ);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_READ with holes at the beginning\\n\");\n\tret = madvise(addr + pagesize, pagesize, MADV_POPULATE_WRITE);\n\tksft_test_result(ret == -1 && errno == ENOMEM,\n\t\t\t \"MADV_POPULATE_WRITE with holes at the beginning\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic bool range_is_populated(char *start, ssize_t size)\n{\n\tint fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tbool ret = true;\n\n\tif (fd < 0)\n\t\tksft_exit_fail_msg(\"opening pagemap failed\\n\");\n\tfor (; size > 0 && ret; size -= pagesize, start += pagesize)\n\t\tif (!pagemap_is_populated(fd, start))\n\t\t\tret = false;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic bool range_is_not_populated(char *start, ssize_t size)\n{\n\tint fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tbool ret = true;\n\n\tif (fd < 0)\n\t\tksft_exit_fail_msg(\"opening pagemap failed\\n\");\n\tfor (; size > 0 && ret; size -= pagesize, start += pagesize)\n\t\tif (pagemap_is_populated(fd, start))\n\t\t\tret = false;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void test_populate_read(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_READ | PROT_WRITE,\n\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\tksft_test_result(range_is_not_populated(addr, SIZE),\n\t\t\t \"range initially not populated\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_READ);\n\tksft_test_result(!ret, \"MADV_POPULATE_READ\\n\");\n\tksft_test_result(range_is_populated(addr, SIZE),\n\t\t\t \"range is populated\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic void test_populate_write(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_READ | PROT_WRITE,\n\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\tksft_test_result(range_is_not_populated(addr, SIZE),\n\t\t\t \"range initially not populated\\n\");\n\n\tret = madvise(addr, SIZE, MADV_POPULATE_WRITE);\n\tksft_test_result(!ret, \"MADV_POPULATE_WRITE\\n\");\n\tksft_test_result(range_is_populated(addr, SIZE),\n\t\t\t \"range is populated\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic bool range_is_softdirty(char *start, ssize_t size)\n{\n\tint fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tbool ret = true;\n\n\tif (fd < 0)\n\t\tksft_exit_fail_msg(\"opening pagemap failed\\n\");\n\tfor (; size > 0 && ret; size -= pagesize, start += pagesize)\n\t\tif (!pagemap_is_softdirty(fd, start))\n\t\t\tret = false;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic bool range_is_not_softdirty(char *start, ssize_t size)\n{\n\tint fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tbool ret = true;\n\n\tif (fd < 0)\n\t\tksft_exit_fail_msg(\"opening pagemap failed\\n\");\n\tfor (; size > 0 && ret; size -= pagesize, start += pagesize)\n\t\tif (pagemap_is_softdirty(fd, start))\n\t\t\tret = false;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void test_softdirty(void)\n{\n\tchar *addr;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s\\n\", __func__);\n\n\taddr = mmap(0, SIZE, PROT_READ | PROT_WRITE,\n\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\tif (addr == MAP_FAILED)\n\t\tksft_exit_fail_msg(\"mmap failed\\n\");\n\n\t \n\tclear_softdirty();\n\tksft_test_result(range_is_not_softdirty(addr, SIZE),\n\t\t\t \"range is not softdirty\\n\");\n\n\t \n\tret = madvise(addr, SIZE, MADV_POPULATE_READ);\n\tksft_test_result(!ret, \"MADV_POPULATE_READ\\n\");\n\tksft_test_result(range_is_not_softdirty(addr, SIZE),\n\t\t\t \"range is not softdirty\\n\");\n\n\t \n\tret = madvise(addr, SIZE, MADV_POPULATE_WRITE);\n\tksft_test_result(!ret, \"MADV_POPULATE_WRITE\\n\");\n\tksft_test_result(range_is_softdirty(addr, SIZE),\n\t\t\t \"range is softdirty\\n\");\n\n\tmunmap(addr, SIZE);\n}\n\nstatic int system_has_softdirty(void)\n{\n\t \n#if defined(__aarch64__)\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}\n\nint main(int argc, char **argv)\n{\n\tint nr_tests = 16;\n\tint err;\n\n\tpagesize = getpagesize();\n\n\tif (system_has_softdirty())\n\t\tnr_tests += 5;\n\n\tksft_print_header();\n\tksft_set_plan(nr_tests);\n\n\tsense_support();\n\ttest_prot_read();\n\ttest_prot_write();\n\ttest_holes();\n\ttest_populate_read();\n\ttest_populate_write();\n\tif (system_has_softdirty())\n\t\ttest_softdirty();\n\n\terr = ksft_get_fail_cnt();\n\tif (err)\n\t\tksft_exit_fail_msg(\"%d out of %d tests failed\\n\",\n\t\t\t\t   err, ksft_test_num());\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}