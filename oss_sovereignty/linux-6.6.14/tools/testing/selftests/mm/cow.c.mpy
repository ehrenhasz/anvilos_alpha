{
  "module_name": "cow.c",
  "hash_id": "e63a12995a5492f59857ba6f38d031d112d02ee95b65af6ad993ae7a506e30ce",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/cow.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <linux/mman.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <linux/memfd.h>\n\n#include \"local_config.h\"\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n#include <liburing.h>\n#endif  \n\n#include \"../../../../mm/gup_test.h\"\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\nstatic size_t pagesize;\nstatic int pagemap_fd;\nstatic size_t thpsize;\nstatic int nr_hugetlbsizes;\nstatic size_t hugetlbsizes[10];\nstatic int gup_fd;\nstatic bool has_huge_zeropage;\n\nstatic void detect_huge_zeropage(void)\n{\n\tint fd = open(\"/sys/kernel/mm/transparent_hugepage/use_zero_page\",\n\t\t      O_RDONLY);\n\tsize_t enabled = 0;\n\tchar buf[15];\n\tint ret;\n\n\tif (fd < 0)\n\t\treturn;\n\n\tret = pread(fd, buf, sizeof(buf), 0);\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tbuf[ret] = 0;\n\n\t\tenabled = strtoul(buf, NULL, 10);\n\t\tif (enabled == 1) {\n\t\t\thas_huge_zeropage = true;\n\t\t\tksft_print_msg(\"[INFO] huge zeropage is enabled\\n\");\n\t\t}\n\t}\n\n\tclose(fd);\n}\n\nstatic bool range_is_swapped(void *addr, size_t size)\n{\n\tfor (; size; addr += pagesize, size -= pagesize)\n\t\tif (!pagemap_is_swapped(pagemap_fd, addr))\n\t\t\treturn false;\n\treturn true;\n}\n\nstruct comm_pipes {\n\tint child_ready[2];\n\tint parent_ready[2];\n};\n\nstatic int setup_comm_pipes(struct comm_pipes *comm_pipes)\n{\n\tif (pipe(comm_pipes->child_ready) < 0)\n\t\treturn -errno;\n\tif (pipe(comm_pipes->parent_ready) < 0) {\n\t\tclose(comm_pipes->child_ready[0]);\n\t\tclose(comm_pipes->child_ready[1]);\n\t\treturn -errno;\n\t}\n\n\treturn 0;\n}\n\nstatic void close_comm_pipes(struct comm_pipes *comm_pipes)\n{\n\tclose(comm_pipes->child_ready[0]);\n\tclose(comm_pipes->child_ready[1]);\n\tclose(comm_pipes->parent_ready[0]);\n\tclose(comm_pipes->parent_ready[1]);\n}\n\nstatic int child_memcmp_fn(char *mem, size_t size,\n\t\t\t   struct comm_pipes *comm_pipes)\n{\n\tchar *old = malloc(size);\n\tchar buf;\n\n\t \n\tmemcpy(old, mem, size);\n\n\t \n\twrite(comm_pipes->child_ready[1], \"0\", 1);\n\twhile (read(comm_pipes->parent_ready[0], &buf, 1) != 1)\n\t\t;\n\n\t \n\treturn memcmp(old, mem, size);\n}\n\nstatic int child_vmsplice_memcmp_fn(char *mem, size_t size,\n\t\t\t\t    struct comm_pipes *comm_pipes)\n{\n\tstruct iovec iov = {\n\t\t.iov_base = mem,\n\t\t.iov_len = size,\n\t};\n\tssize_t cur, total, transferred;\n\tchar *old, *new;\n\tint fds[2];\n\tchar buf;\n\n\told = malloc(size);\n\tnew = malloc(size);\n\n\t \n\tmemcpy(old, mem, size);\n\n\tif (pipe(fds) < 0)\n\t\treturn -errno;\n\n\t \n\ttransferred = vmsplice(fds[1], &iov, 1, 0);\n\tif (transferred < 0)\n\t\treturn -errno;\n\tif (transferred == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (munmap(mem, size) < 0)\n\t\treturn -errno;\n\n\t \n\twrite(comm_pipes->child_ready[1], \"0\", 1);\n\twhile (read(comm_pipes->parent_ready[0], &buf, 1) != 1)\n\t\t;\n\n\t \n\tfor (total = 0; total < transferred; total += cur) {\n\t\tcur = read(fds[0], new + total, transferred - total);\n\t\tif (cur < 0)\n\t\t\treturn -errno;\n\t}\n\n\treturn memcmp(old, new, transferred);\n}\n\ntypedef int (*child_fn)(char *mem, size_t size, struct comm_pipes *comm_pipes);\n\nstatic void do_test_cow_in_parent(char *mem, size_t size, bool do_mprotect,\n\t\t\t\t  child_fn fn)\n{\n\tstruct comm_pipes comm_pipes;\n\tchar buf;\n\tint ret;\n\n\tret = setup_comm_pipes(&comm_pipes);\n\tif (ret) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\treturn;\n\t}\n\n\tret = fork();\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t} else if (!ret) {\n\t\texit(fn(mem, size, &comm_pipes));\n\t}\n\n\twhile (read(comm_pipes.child_ready[0], &buf, 1) != 1)\n\t\t;\n\n\tif (do_mprotect) {\n\t\t \n\t\tret = mprotect(mem, size, PROT_READ);\n\t\tret |= mprotect(mem, size, PROT_READ|PROT_WRITE);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\t\twait(&ret);\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t}\n\n\t \n\tmemset(mem, 0xff, size);\n\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\n\twait(&ret);\n\tif (WIFEXITED(ret))\n\t\tret = WEXITSTATUS(ret);\n\telse\n\t\tret = -EINVAL;\n\n\tksft_test_result(!ret, \"No leak from parent into child\\n\");\nclose_comm_pipes:\n\tclose_comm_pipes(&comm_pipes);\n}\n\nstatic void test_cow_in_parent(char *mem, size_t size)\n{\n\tdo_test_cow_in_parent(mem, size, false, child_memcmp_fn);\n}\n\nstatic void test_cow_in_parent_mprotect(char *mem, size_t size)\n{\n\tdo_test_cow_in_parent(mem, size, true, child_memcmp_fn);\n}\n\nstatic void test_vmsplice_in_child(char *mem, size_t size)\n{\n\tdo_test_cow_in_parent(mem, size, false, child_vmsplice_memcmp_fn);\n}\n\nstatic void test_vmsplice_in_child_mprotect(char *mem, size_t size)\n{\n\tdo_test_cow_in_parent(mem, size, true, child_vmsplice_memcmp_fn);\n}\n\nstatic void do_test_vmsplice_in_parent(char *mem, size_t size,\n\t\t\t\t       bool before_fork)\n{\n\tstruct iovec iov = {\n\t\t.iov_base = mem,\n\t\t.iov_len = size,\n\t};\n\tssize_t cur, total, transferred;\n\tstruct comm_pipes comm_pipes;\n\tchar *old, *new;\n\tint ret, fds[2];\n\tchar buf;\n\n\told = malloc(size);\n\tnew = malloc(size);\n\n\tmemcpy(old, mem, size);\n\n\tret = setup_comm_pipes(&comm_pipes);\n\tif (ret) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\tgoto free;\n\t}\n\n\tif (pipe(fds) < 0) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t}\n\n\tif (before_fork) {\n\t\ttransferred = vmsplice(fds[1], &iov, 1, 0);\n\t\tif (transferred <= 0) {\n\t\t\tksft_test_result_fail(\"vmsplice() failed\\n\");\n\t\t\tgoto close_pipe;\n\t\t}\n\t}\n\n\tret = fork();\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\tgoto close_pipe;\n\t} else if (!ret) {\n\t\twrite(comm_pipes.child_ready[1], \"0\", 1);\n\t\twhile (read(comm_pipes.parent_ready[0], &buf, 1) != 1)\n\t\t\t;\n\t\t \n\t\tmemset(mem, 0xff, size);\n\t\texit(0);\n\t}\n\n\tif (!before_fork) {\n\t\ttransferred = vmsplice(fds[1], &iov, 1, 0);\n\t\tif (transferred <= 0) {\n\t\t\tksft_test_result_fail(\"vmsplice() failed\\n\");\n\t\t\twait(&ret);\n\t\t\tgoto close_pipe;\n\t\t}\n\t}\n\n\twhile (read(comm_pipes.child_ready[0], &buf, 1) != 1)\n\t\t;\n\tif (munmap(mem, size) < 0) {\n\t\tksft_test_result_fail(\"munmap() failed\\n\");\n\t\tgoto close_pipe;\n\t}\n\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\n\t \n\twait(&ret);\n\tif (!WIFEXITED(ret)) {\n\t\tksft_test_result_fail(\"wait() failed\\n\");\n\t\tgoto close_pipe;\n\t}\n\n\t \n\tfor (total = 0; total < transferred; total += cur) {\n\t\tcur = read(fds[0], new + total, transferred - total);\n\t\tif (cur < 0) {\n\t\t\tksft_test_result_fail(\"read() failed\\n\");\n\t\t\tgoto close_pipe;\n\t\t}\n\t}\n\n\tksft_test_result(!memcmp(old, new, transferred),\n\t\t\t \"No leak from child into parent\\n\");\nclose_pipe:\n\tclose(fds[0]);\n\tclose(fds[1]);\nclose_comm_pipes:\n\tclose_comm_pipes(&comm_pipes);\nfree:\n\tfree(old);\n\tfree(new);\n}\n\nstatic void test_vmsplice_before_fork(char *mem, size_t size)\n{\n\tdo_test_vmsplice_in_parent(mem, size, true);\n}\n\nstatic void test_vmsplice_after_fork(char *mem, size_t size)\n{\n\tdo_test_vmsplice_in_parent(mem, size, false);\n}\n\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\nstatic void do_test_iouring(char *mem, size_t size, bool use_fork)\n{\n\tstruct comm_pipes comm_pipes;\n\tstruct io_uring_cqe *cqe;\n\tstruct io_uring_sqe *sqe;\n\tstruct io_uring ring;\n\tssize_t cur, total;\n\tstruct iovec iov;\n\tchar *buf, *tmp;\n\tint ret, fd;\n\tFILE *file;\n\n\tret = setup_comm_pipes(&comm_pipes);\n\tif (ret) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\treturn;\n\t}\n\n\tfile = tmpfile();\n\tif (!file) {\n\t\tksft_test_result_fail(\"tmpfile() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t}\n\tfd = fileno(file);\n\tassert(fd);\n\n\ttmp = malloc(size);\n\tif (!tmp) {\n\t\tksft_test_result_fail(\"malloc() failed\\n\");\n\t\tgoto close_file;\n\t}\n\n\t \n\tret = io_uring_queue_init(1, &ring, 0);\n\tif (ret < 0) {\n\t\tksft_test_result_skip(\"io_uring_queue_init() failed\\n\");\n\t\tgoto free_tmp;\n\t}\n\n\t \n\tiov.iov_base = mem;\n\tiov.iov_len = size;\n\tret = io_uring_register_buffers(&ring, &iov, 1);\n\tif (ret) {\n\t\tksft_test_result_skip(\"io_uring_register_buffers() failed\\n\");\n\t\tgoto queue_exit;\n\t}\n\n\tif (use_fork) {\n\t\t \n\t\tret = fork();\n\t\tif (ret < 0) {\n\t\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\t\tgoto unregister_buffers;\n\t\t} else if (!ret) {\n\t\t\twrite(comm_pipes.child_ready[1], \"0\", 1);\n\t\t\twhile (read(comm_pipes.parent_ready[0], &buf, 1) != 1)\n\t\t\t\t;\n\t\t\texit(0);\n\t\t}\n\n\t\twhile (read(comm_pipes.child_ready[0], &buf, 1) != 1)\n\t\t\t;\n\t} else {\n\t\t \n\t\tret = mprotect(mem, size, PROT_READ);\n\t\tclear_softdirty();\n\t\tret |= mprotect(mem, size, PROT_READ | PROT_WRITE);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\t\tgoto unregister_buffers;\n\t\t}\n\t}\n\n\t \n\tmemset(mem, 0xff, size);\n\tsqe = io_uring_get_sqe(&ring);\n\tif (!sqe) {\n\t\tksft_test_result_fail(\"io_uring_get_sqe() failed\\n\");\n\t\tgoto quit_child;\n\t}\n\tio_uring_prep_write_fixed(sqe, fd, mem, size, 0, 0);\n\n\tret = io_uring_submit(&ring);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"io_uring_submit() failed\\n\");\n\t\tgoto quit_child;\n\t}\n\n\tret = io_uring_wait_cqe(&ring, &cqe);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"io_uring_wait_cqe() failed\\n\");\n\t\tgoto quit_child;\n\t}\n\n\tif (cqe->res != size) {\n\t\tksft_test_result_fail(\"write_fixed failed\\n\");\n\t\tgoto quit_child;\n\t}\n\tio_uring_cqe_seen(&ring, cqe);\n\n\t \n\ttotal = 0;\n\twhile (total < size) {\n\t\tcur = pread(fd, tmp + total, size - total, total);\n\t\tif (cur < 0) {\n\t\t\tksft_test_result_fail(\"pread() failed\\n\");\n\t\t\tgoto quit_child;\n\t\t}\n\t\ttotal += cur;\n\t}\n\n\t \n\tksft_test_result(!memcmp(mem, tmp, size),\n\t\t\t \"Longterm R/W pin is reliable\\n\");\n\nquit_child:\n\tif (use_fork) {\n\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\twait(&ret);\n\t}\nunregister_buffers:\n\tio_uring_unregister_buffers(&ring);\nqueue_exit:\n\tio_uring_queue_exit(&ring);\nfree_tmp:\n\tfree(tmp);\nclose_file:\n\tfclose(file);\nclose_comm_pipes:\n\tclose_comm_pipes(&comm_pipes);\n}\n\nstatic void test_iouring_ro(char *mem, size_t size)\n{\n\tdo_test_iouring(mem, size, false);\n}\n\nstatic void test_iouring_fork(char *mem, size_t size)\n{\n\tdo_test_iouring(mem, size, true);\n}\n\n#endif  \n\nenum ro_pin_test {\n\tRO_PIN_TEST,\n\tRO_PIN_TEST_SHARED,\n\tRO_PIN_TEST_PREVIOUSLY_SHARED,\n\tRO_PIN_TEST_RO_EXCLUSIVE,\n};\n\nstatic void do_test_ro_pin(char *mem, size_t size, enum ro_pin_test test,\n\t\t\t   bool fast)\n{\n\tstruct pin_longterm_test args;\n\tstruct comm_pipes comm_pipes;\n\tchar *tmp, buf;\n\t__u64 tmp_val;\n\tint ret;\n\n\tif (gup_fd < 0) {\n\t\tksft_test_result_skip(\"gup_test not available\\n\");\n\t\treturn;\n\t}\n\n\ttmp = malloc(size);\n\tif (!tmp) {\n\t\tksft_test_result_fail(\"malloc() failed\\n\");\n\t\treturn;\n\t}\n\n\tret = setup_comm_pipes(&comm_pipes);\n\tif (ret) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\tgoto free_tmp;\n\t}\n\n\tswitch (test) {\n\tcase RO_PIN_TEST:\n\t\tbreak;\n\tcase RO_PIN_TEST_SHARED:\n\tcase RO_PIN_TEST_PREVIOUSLY_SHARED:\n\t\t \n\t\tret = fork();\n\t\tif (ret < 0) {\n\t\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\t\tgoto close_comm_pipes;\n\t\t} else if (!ret) {\n\t\t\twrite(comm_pipes.child_ready[1], \"0\", 1);\n\t\t\twhile (read(comm_pipes.parent_ready[0], &buf, 1) != 1)\n\t\t\t\t;\n\t\t\texit(0);\n\t\t}\n\n\t\t \n\t\twhile (read(comm_pipes.child_ready[0], &buf, 1) != 1)\n\t\t\t;\n\n\t\tif (test == RO_PIN_TEST_PREVIOUSLY_SHARED) {\n\t\t\t \n\t\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\t\twait(&ret);\n\t\t\tif (!WIFEXITED(ret))\n\t\t\t\tksft_print_msg(\"[INFO] wait() failed\\n\");\n\t\t}\n\t\tbreak;\n\tcase RO_PIN_TEST_RO_EXCLUSIVE:\n\t\t \n\t\tret = mprotect(mem, size, PROT_READ);\n\t\tclear_softdirty();\n\t\tret |= mprotect(mem, size, PROT_READ | PROT_WRITE);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n\n\t \n\targs.addr = (__u64)(uintptr_t)mem;\n\targs.size = size;\n\targs.flags = fast ? PIN_LONGTERM_TEST_FLAG_USE_FAST : 0;\n\tret = ioctl(gup_fd, PIN_LONGTERM_TEST_START, &args);\n\tif (ret) {\n\t\tif (errno == EINVAL)\n\t\t\tksft_test_result_skip(\"PIN_LONGTERM_TEST_START failed\\n\");\n\t\telse\n\t\t\tksft_test_result_fail(\"PIN_LONGTERM_TEST_START failed\\n\");\n\t\tgoto wait;\n\t}\n\n\t \n\tmemset(mem, 0xff, size);\n\n\t \n\ttmp_val = (__u64)(uintptr_t)tmp;\n\tret = ioctl(gup_fd, PIN_LONGTERM_TEST_READ, &tmp_val);\n\tif (ret)\n\t\tksft_test_result_fail(\"PIN_LONGTERM_TEST_READ failed\\n\");\n\telse\n\t\tksft_test_result(!memcmp(mem, tmp, size),\n\t\t\t\t \"Longterm R/O pin is reliable\\n\");\n\n\tret = ioctl(gup_fd, PIN_LONGTERM_TEST_STOP);\n\tif (ret)\n\t\tksft_print_msg(\"[INFO] PIN_LONGTERM_TEST_STOP failed\\n\");\nwait:\n\tswitch (test) {\n\tcase RO_PIN_TEST_SHARED:\n\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\twait(&ret);\n\t\tif (!WIFEXITED(ret))\n\t\t\tksft_print_msg(\"[INFO] wait() failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nclose_comm_pipes:\n\tclose_comm_pipes(&comm_pipes);\nfree_tmp:\n\tfree(tmp);\n}\n\nstatic void test_ro_pin_on_shared(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_SHARED, false);\n}\n\nstatic void test_ro_fast_pin_on_shared(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_SHARED, true);\n}\n\nstatic void test_ro_pin_on_ro_previously_shared(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_PREVIOUSLY_SHARED, false);\n}\n\nstatic void test_ro_fast_pin_on_ro_previously_shared(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_PREVIOUSLY_SHARED, true);\n}\n\nstatic void test_ro_pin_on_ro_exclusive(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_RO_EXCLUSIVE, false);\n}\n\nstatic void test_ro_fast_pin_on_ro_exclusive(char *mem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST_RO_EXCLUSIVE, true);\n}\n\ntypedef void (*test_fn)(char *mem, size_t size);\n\nstatic void do_run_with_base_page(test_fn fn, bool swapout)\n{\n\tchar *mem;\n\tint ret;\n\n\tmem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE,\n\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\tret = madvise(mem, pagesize, MADV_NOHUGEPAGE);\n\t \n\tif (ret && errno != EINVAL) {\n\t\tksft_test_result_fail(\"MADV_NOHUGEPAGE failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tmemset(mem, 0, pagesize);\n\n\tif (swapout) {\n\t\tmadvise(mem, pagesize, MADV_PAGEOUT);\n\t\tif (!pagemap_is_swapped(pagemap_fd, mem)) {\n\t\t\tksft_test_result_skip(\"MADV_PAGEOUT did not work, is swap enabled?\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t}\n\n\tfn(mem, pagesize);\nmunmap:\n\tmunmap(mem, pagesize);\n}\n\nstatic void run_with_base_page(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with base page\\n\", desc);\n\tdo_run_with_base_page(fn, false);\n}\n\nstatic void run_with_base_page_swap(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with swapped out base page\\n\", desc);\n\tdo_run_with_base_page(fn, true);\n}\n\nenum thp_run {\n\tTHP_RUN_PMD,\n\tTHP_RUN_PMD_SWAPOUT,\n\tTHP_RUN_PTE,\n\tTHP_RUN_PTE_SWAPOUT,\n\tTHP_RUN_SINGLE_PTE,\n\tTHP_RUN_SINGLE_PTE_SWAPOUT,\n\tTHP_RUN_PARTIAL_MREMAP,\n\tTHP_RUN_PARTIAL_SHARED,\n};\n\nstatic void do_run_with_thp(test_fn fn, enum thp_run thp_run)\n{\n\tchar *mem, *mmap_mem, *tmp, *mremap_mem = MAP_FAILED;\n\tsize_t size, mmap_size, mremap_size;\n\tint ret;\n\n\t \n\tmmap_size = 2 * thpsize;\n\tmmap_mem = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (mmap_mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmem = (char *)(((uintptr_t)mmap_mem + thpsize) & ~(thpsize - 1));\n\n\tret = madvise(mem, thpsize, MADV_HUGEPAGE);\n\tif (ret) {\n\t\tksft_test_result_fail(\"MADV_HUGEPAGE failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tmem[0] = 0;\n\tif (!pagemap_is_populated(pagemap_fd, mem + pagesize)) {\n\t\tksft_test_result_skip(\"Did not get a THP populated\\n\");\n\t\tgoto munmap;\n\t}\n\tmemset(mem, 0, thpsize);\n\n\tsize = thpsize;\n\tswitch (thp_run) {\n\tcase THP_RUN_PMD:\n\tcase THP_RUN_PMD_SWAPOUT:\n\t\tbreak;\n\tcase THP_RUN_PTE:\n\tcase THP_RUN_PTE_SWAPOUT:\n\t\t \n\t\tret = mprotect(mem + pagesize, pagesize, PROT_READ);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tret = mprotect(mem + pagesize, pagesize, PROT_READ | PROT_WRITE);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tbreak;\n\tcase THP_RUN_SINGLE_PTE:\n\tcase THP_RUN_SINGLE_PTE_SWAPOUT:\n\t\t \n\t\tret = madvise(mem + pagesize, thpsize - pagesize, MADV_DONTNEED);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DONTNEED failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tsize = pagesize;\n\t\tbreak;\n\tcase THP_RUN_PARTIAL_MREMAP:\n\t\t \n\t\tmremap_size = thpsize / 2;\n\t\tmremap_mem = mmap(NULL, mremap_size, PROT_NONE,\n\t\t\t\t  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\t\tif (mem == MAP_FAILED) {\n\t\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\ttmp = mremap(mem + mremap_size, mremap_size, mremap_size,\n\t\t\t     MREMAP_MAYMOVE | MREMAP_FIXED, mremap_mem);\n\t\tif (tmp != mremap_mem) {\n\t\t\tksft_test_result_fail(\"mremap() failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tsize = mremap_size;\n\t\tbreak;\n\tcase THP_RUN_PARTIAL_SHARED:\n\t\t \n\t\tret = madvise(mem + pagesize, thpsize - pagesize, MADV_DONTFORK);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DONTFORK failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tret = fork();\n\t\tif (ret < 0) {\n\t\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\t\tgoto munmap;\n\t\t} else if (!ret) {\n\t\t\texit(0);\n\t\t}\n\t\twait(&ret);\n\t\t \n\t\tret = madvise(mem + pagesize, thpsize - pagesize, MADV_DOFORK);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DOFORK failed\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n\n\tswitch (thp_run) {\n\tcase THP_RUN_PMD_SWAPOUT:\n\tcase THP_RUN_PTE_SWAPOUT:\n\tcase THP_RUN_SINGLE_PTE_SWAPOUT:\n\t\tmadvise(mem, size, MADV_PAGEOUT);\n\t\tif (!range_is_swapped(mem, size)) {\n\t\t\tksft_test_result_skip(\"MADV_PAGEOUT did not work, is swap enabled?\\n\");\n\t\t\tgoto munmap;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfn(mem, size);\nmunmap:\n\tmunmap(mmap_mem, mmap_size);\n\tif (mremap_mem != MAP_FAILED)\n\t\tmunmap(mremap_mem, mremap_size);\n}\n\nstatic void run_with_thp(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PMD);\n}\n\nstatic void run_with_thp_swap(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with swapped-out THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PMD_SWAPOUT);\n}\n\nstatic void run_with_pte_mapped_thp(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with PTE-mapped THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PTE);\n}\n\nstatic void run_with_pte_mapped_thp_swap(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with swapped-out, PTE-mapped THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PTE_SWAPOUT);\n}\n\nstatic void run_with_single_pte_of_thp(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with single PTE of THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_SINGLE_PTE);\n}\n\nstatic void run_with_single_pte_of_thp_swap(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with single PTE of swapped-out THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_SINGLE_PTE_SWAPOUT);\n}\n\nstatic void run_with_partial_mremap_thp(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with partially mremap()'ed THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PARTIAL_MREMAP);\n}\n\nstatic void run_with_partial_shared_thp(test_fn fn, const char *desc)\n{\n\tksft_print_msg(\"[RUN] %s ... with partially shared THP\\n\", desc);\n\tdo_run_with_thp(fn, THP_RUN_PARTIAL_SHARED);\n}\n\nstatic void run_with_hugetlb(test_fn fn, const char *desc, size_t hugetlbsize)\n{\n\tint flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB;\n\tchar *mem, *dummy;\n\n\tksft_print_msg(\"[RUN] %s ... with hugetlb (%zu kB)\\n\", desc,\n\t\t       hugetlbsize / 1024);\n\n\tflags |= __builtin_ctzll(hugetlbsize) << MAP_HUGE_SHIFT;\n\n\tmem = mmap(NULL, hugetlbsize, PROT_READ | PROT_WRITE, flags, -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemset(mem, 0, hugetlbsize);\n\n\t \n\tdummy = mmap(NULL, hugetlbsize, PROT_READ | PROT_WRITE, flags, -1, 0);\n\tif (dummy == MAP_FAILED) {\n\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\tgoto munmap;\n\t}\n\tmunmap(dummy, hugetlbsize);\n\n\tfn(mem, hugetlbsize);\nmunmap:\n\tmunmap(mem, hugetlbsize);\n}\n\nstruct test_case {\n\tconst char *desc;\n\ttest_fn fn;\n};\n\n \nstatic const struct test_case anon_test_cases[] = {\n\t \n\t{\n\t\t\"Basic COW after fork()\",\n\t\ttest_cow_in_parent,\n\t},\n\t \n\t{\n\t\t\"Basic COW after fork() with mprotect() optimization\",\n\t\ttest_cow_in_parent_mprotect,\n\t},\n\t \n\t{\n\t\t\"vmsplice() + unmap in child\",\n\t\ttest_vmsplice_in_child\n\t},\n\t \n\t{\n\t\t\"vmsplice() + unmap in child with mprotect() optimization\",\n\t\ttest_vmsplice_in_child_mprotect\n\t},\n\t \n\t{\n\t\t\"vmsplice() before fork(), unmap in parent after fork()\",\n\t\ttest_vmsplice_before_fork,\n\t},\n\t \n\t{\n\t\t\"vmsplice() + unmap in parent after fork()\",\n\t\ttest_vmsplice_after_fork,\n\t},\n#ifdef LOCAL_CONFIG_HAVE_LIBURING\n\t \n\t{\n\t\t\"R/O-mapping a page registered as iouring fixed buffer\",\n\t\ttest_iouring_ro,\n\t},\n\t \n\t{\n\t\t\"fork() with an iouring fixed buffer\",\n\t\ttest_iouring_fork,\n\t},\n\n#endif  \n\t \n\t{\n\t\t\"R/O GUP pin on R/O-mapped shared page\",\n\t\ttest_ro_pin_on_shared,\n\t},\n\t \n\t{\n\t\t\"R/O GUP-fast pin on R/O-mapped shared page\",\n\t\ttest_ro_fast_pin_on_shared,\n\t},\n\t \n\t{\n\t\t\"R/O GUP pin on R/O-mapped previously-shared page\",\n\t\ttest_ro_pin_on_ro_previously_shared,\n\t},\n\t \n\t{\n\t\t\"R/O GUP-fast pin on R/O-mapped previously-shared page\",\n\t\ttest_ro_fast_pin_on_ro_previously_shared,\n\t},\n\t \n\t{\n\t\t\"R/O GUP pin on R/O-mapped exclusive page\",\n\t\ttest_ro_pin_on_ro_exclusive,\n\t},\n\t \n\t{\n\t\t\"R/O GUP-fast pin on R/O-mapped exclusive page\",\n\t\ttest_ro_fast_pin_on_ro_exclusive,\n\t},\n};\n\nstatic void run_anon_test_case(struct test_case const *test_case)\n{\n\tint i;\n\n\trun_with_base_page(test_case->fn, test_case->desc);\n\trun_with_base_page_swap(test_case->fn, test_case->desc);\n\tif (thpsize) {\n\t\trun_with_thp(test_case->fn, test_case->desc);\n\t\trun_with_thp_swap(test_case->fn, test_case->desc);\n\t\trun_with_pte_mapped_thp(test_case->fn, test_case->desc);\n\t\trun_with_pte_mapped_thp_swap(test_case->fn, test_case->desc);\n\t\trun_with_single_pte_of_thp(test_case->fn, test_case->desc);\n\t\trun_with_single_pte_of_thp_swap(test_case->fn, test_case->desc);\n\t\trun_with_partial_mremap_thp(test_case->fn, test_case->desc);\n\t\trun_with_partial_shared_thp(test_case->fn, test_case->desc);\n\t}\n\tfor (i = 0; i < nr_hugetlbsizes; i++)\n\t\trun_with_hugetlb(test_case->fn, test_case->desc,\n\t\t\t\t hugetlbsizes[i]);\n}\n\nstatic void run_anon_test_cases(void)\n{\n\tint i;\n\n\tksft_print_msg(\"[INFO] Anonymous memory tests in private mappings\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(anon_test_cases); i++)\n\t\trun_anon_test_case(&anon_test_cases[i]);\n}\n\nstatic int tests_per_anon_test_case(void)\n{\n\tint tests = 2 + nr_hugetlbsizes;\n\n\tif (thpsize)\n\t\ttests += 8;\n\treturn tests;\n}\n\nenum anon_thp_collapse_test {\n\tANON_THP_COLLAPSE_UNSHARED,\n\tANON_THP_COLLAPSE_FULLY_SHARED,\n\tANON_THP_COLLAPSE_LOWER_SHARED,\n\tANON_THP_COLLAPSE_UPPER_SHARED,\n};\n\nstatic void do_test_anon_thp_collapse(char *mem, size_t size,\n\t\t\t\t      enum anon_thp_collapse_test test)\n{\n\tstruct comm_pipes comm_pipes;\n\tchar buf;\n\tint ret;\n\n\tret = setup_comm_pipes(&comm_pipes);\n\tif (ret) {\n\t\tksft_test_result_fail(\"pipe() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = mprotect(mem + pagesize, pagesize, PROT_READ);\n\tif (ret) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t}\n\tret = mprotect(mem + pagesize, pagesize, PROT_READ | PROT_WRITE);\n\tif (ret) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t}\n\n\tswitch (test) {\n\tcase ANON_THP_COLLAPSE_UNSHARED:\n\t\t \n\t\tret = madvise(mem, size, MADV_COLLAPSE);\n\t\tif (ret) {\n\t\t\tksft_test_result_skip(\"MADV_COLLAPSE failed: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\tbreak;\n\tcase ANON_THP_COLLAPSE_FULLY_SHARED:\n\t\t \n\t\tbreak;\n\tcase ANON_THP_COLLAPSE_LOWER_SHARED:\n\t\t \n\t\tret = madvise(mem + size / 2, size / 2, MADV_DONTFORK);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DONTFORK failed\\n\");\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\tbreak;\n\tcase ANON_THP_COLLAPSE_UPPER_SHARED:\n\t\t \n\t\tret = madvise(mem, size / 2, MADV_DONTFORK);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DONTFORK failed\\n\");\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n\n\tret = fork();\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"fork() failed\\n\");\n\t\tgoto close_comm_pipes;\n\t} else if (!ret) {\n\t\tswitch (test) {\n\t\tcase ANON_THP_COLLAPSE_UNSHARED:\n\t\tcase ANON_THP_COLLAPSE_FULLY_SHARED:\n\t\t\texit(child_memcmp_fn(mem, size, &comm_pipes));\n\t\t\tbreak;\n\t\tcase ANON_THP_COLLAPSE_LOWER_SHARED:\n\t\t\texit(child_memcmp_fn(mem, size / 2, &comm_pipes));\n\t\t\tbreak;\n\t\tcase ANON_THP_COLLAPSE_UPPER_SHARED:\n\t\t\texit(child_memcmp_fn(mem + size / 2, size / 2,\n\t\t\t\t\t     &comm_pipes));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\twhile (read(comm_pipes.child_ready[0], &buf, 1) != 1)\n\t\t;\n\n\tswitch (test) {\n\tcase ANON_THP_COLLAPSE_UNSHARED:\n\t\tbreak;\n\tcase ANON_THP_COLLAPSE_UPPER_SHARED:\n\tcase ANON_THP_COLLAPSE_LOWER_SHARED:\n\t\t \n\t\tret = madvise(mem, size, MADV_DOFORK);\n\t\tif (ret) {\n\t\t\tksft_test_result_fail(\"MADV_DOFORK failed\\n\");\n\t\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\t\twait(&ret);\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\t \n\tcase ANON_THP_COLLAPSE_FULLY_SHARED:\n\t\t \n\t\tret = madvise(mem, size, MADV_COLLAPSE);\n\t\tif (ret) {\n\t\t\tksft_test_result_skip(\"MADV_COLLAPSE failed: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\t\t\twait(&ret);\n\t\t\tgoto close_comm_pipes;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n\n\t \n\tmemset(mem, 0xff, size);\n\twrite(comm_pipes.parent_ready[1], \"0\", 1);\n\n\twait(&ret);\n\tif (WIFEXITED(ret))\n\t\tret = WEXITSTATUS(ret);\n\telse\n\t\tret = -EINVAL;\n\n\tksft_test_result(!ret, \"No leak from parent into child\\n\");\nclose_comm_pipes:\n\tclose_comm_pipes(&comm_pipes);\n}\n\nstatic void test_anon_thp_collapse_unshared(char *mem, size_t size)\n{\n\tdo_test_anon_thp_collapse(mem, size, ANON_THP_COLLAPSE_UNSHARED);\n}\n\nstatic void test_anon_thp_collapse_fully_shared(char *mem, size_t size)\n{\n\tdo_test_anon_thp_collapse(mem, size, ANON_THP_COLLAPSE_FULLY_SHARED);\n}\n\nstatic void test_anon_thp_collapse_lower_shared(char *mem, size_t size)\n{\n\tdo_test_anon_thp_collapse(mem, size, ANON_THP_COLLAPSE_LOWER_SHARED);\n}\n\nstatic void test_anon_thp_collapse_upper_shared(char *mem, size_t size)\n{\n\tdo_test_anon_thp_collapse(mem, size, ANON_THP_COLLAPSE_UPPER_SHARED);\n}\n\n \nstatic const struct test_case anon_thp_test_cases[] = {\n\t \n\t{\n\t\t\"Basic COW after fork() when collapsing before fork()\",\n\t\ttest_anon_thp_collapse_unshared,\n\t},\n\t \n\t{\n\t\t\"Basic COW after fork() when collapsing after fork() (fully shared)\",\n\t\ttest_anon_thp_collapse_fully_shared,\n\t},\n\t \n\t{\n\t\t\"Basic COW after fork() when collapsing after fork() (lower shared)\",\n\t\ttest_anon_thp_collapse_lower_shared,\n\t},\n\t \n\t{\n\t\t\"Basic COW after fork() when collapsing after fork() (upper shared)\",\n\t\ttest_anon_thp_collapse_upper_shared,\n\t},\n};\n\nstatic void run_anon_thp_test_cases(void)\n{\n\tint i;\n\n\tif (!thpsize)\n\t\treturn;\n\n\tksft_print_msg(\"[INFO] Anonymous THP tests\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(anon_thp_test_cases); i++) {\n\t\tstruct test_case const *test_case = &anon_thp_test_cases[i];\n\n\t\tksft_print_msg(\"[RUN] %s\\n\", test_case->desc);\n\t\tdo_run_with_thp(test_case->fn, THP_RUN_PMD);\n\t}\n}\n\nstatic int tests_per_anon_thp_test_case(void)\n{\n\treturn thpsize ? 1 : 0;\n}\n\ntypedef void (*non_anon_test_fn)(char *mem, const char *smem, size_t size);\n\nstatic void test_cow(char *mem, const char *smem, size_t size)\n{\n\tchar *old = malloc(size);\n\n\t \n\tmemcpy(old, smem, size);\n\n\t \n\tmemset(mem, 0xff, size);\n\n\t \n\tksft_test_result(!memcmp(smem, old, size),\n\t\t\t \"Other mapping not modified\\n\");\n\tfree(old);\n}\n\nstatic void test_ro_pin(char *mem, const char *smem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST, false);\n}\n\nstatic void test_ro_fast_pin(char *mem, const char *smem, size_t size)\n{\n\tdo_test_ro_pin(mem, size, RO_PIN_TEST, true);\n}\n\nstatic void run_with_zeropage(non_anon_test_fn fn, const char *desc)\n{\n\tchar *mem, *smem, tmp;\n\n\tksft_print_msg(\"[RUN] %s ... with shared zeropage\\n\", desc);\n\n\tmem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE,\n\t\t   MAP_PRIVATE | MAP_ANON, -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\tsmem = mmap(NULL, pagesize, PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\ttmp = *mem + *smem;\n\tasm volatile(\"\" : \"+r\" (tmp));\n\n\tfn(mem, smem, pagesize);\nmunmap:\n\tmunmap(mem, pagesize);\n\tif (smem != MAP_FAILED)\n\t\tmunmap(smem, pagesize);\n}\n\nstatic void run_with_huge_zeropage(non_anon_test_fn fn, const char *desc)\n{\n\tchar *mem, *smem, *mmap_mem, *mmap_smem, tmp;\n\tsize_t mmap_size;\n\tint ret;\n\n\tksft_print_msg(\"[RUN] %s ... with huge zeropage\\n\", desc);\n\n\tif (!has_huge_zeropage) {\n\t\tksft_test_result_skip(\"Huge zeropage not enabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmmap_size = 2 * thpsize;\n\tmmap_mem = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (mmap_mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\tmmap_smem = mmap(NULL, mmap_size, PROT_READ,\n\t\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (mmap_smem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tmem = (char *)(((uintptr_t)mmap_mem + thpsize) & ~(thpsize - 1));\n\tsmem = (char *)(((uintptr_t)mmap_smem + thpsize) & ~(thpsize - 1));\n\n\tret = madvise(mem, thpsize, MADV_HUGEPAGE);\n\tret |= madvise(smem, thpsize, MADV_HUGEPAGE);\n\tif (ret) {\n\t\tksft_test_result_fail(\"MADV_HUGEPAGE failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\ttmp = *mem + *smem;\n\tasm volatile(\"\" : \"+r\" (tmp));\n\tif (!pagemap_is_populated(pagemap_fd, mem + pagesize) ||\n\t    !pagemap_is_populated(pagemap_fd, smem + pagesize)) {\n\t\tksft_test_result_skip(\"Did not get THPs populated\\n\");\n\t\tgoto munmap;\n\t}\n\n\tfn(mem, smem, thpsize);\nmunmap:\n\tmunmap(mmap_mem, mmap_size);\n\tif (mmap_smem != MAP_FAILED)\n\t\tmunmap(mmap_smem, mmap_size);\n}\n\nstatic void run_with_memfd(non_anon_test_fn fn, const char *desc)\n{\n\tchar *mem, *smem, tmp;\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with memfd\\n\", desc);\n\n\tfd = memfd_create(\"test\", 0);\n\tif (fd < 0) {\n\t\tksft_test_result_fail(\"memfd_create() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (fallocate(fd, 0, 0, pagesize)) {\n\t\tksft_test_result_fail(\"fallocate() failed\\n\");\n\t\tgoto close;\n\t}\n\n\t \n\tmem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto close;\n\t}\n\tsmem = mmap(NULL, pagesize, PROT_READ, MAP_SHARED, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\ttmp = *mem + *smem;\n\tasm volatile(\"\" : \"+r\" (tmp));\n\n\tfn(mem, smem, pagesize);\nmunmap:\n\tmunmap(mem, pagesize);\n\tif (smem != MAP_FAILED)\n\t\tmunmap(smem, pagesize);\nclose:\n\tclose(fd);\n}\n\nstatic void run_with_tmpfile(non_anon_test_fn fn, const char *desc)\n{\n\tchar *mem, *smem, tmp;\n\tFILE *file;\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with tmpfile\\n\", desc);\n\n\tfile = tmpfile();\n\tif (!file) {\n\t\tksft_test_result_fail(\"tmpfile() failed\\n\");\n\t\treturn;\n\t}\n\n\tfd = fileno(file);\n\tif (fd < 0) {\n\t\tksft_test_result_skip(\"fileno() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (fallocate(fd, 0, 0, pagesize)) {\n\t\tksft_test_result_fail(\"fallocate() failed\\n\");\n\t\tgoto close;\n\t}\n\n\t \n\tmem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto close;\n\t}\n\tsmem = mmap(NULL, pagesize, PROT_READ, MAP_SHARED, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\ttmp = *mem + *smem;\n\tasm volatile(\"\" : \"+r\" (tmp));\n\n\tfn(mem, smem, pagesize);\nmunmap:\n\tmunmap(mem, pagesize);\n\tif (smem != MAP_FAILED)\n\t\tmunmap(smem, pagesize);\nclose:\n\tfclose(file);\n}\n\nstatic void run_with_memfd_hugetlb(non_anon_test_fn fn, const char *desc,\n\t\t\t\t   size_t hugetlbsize)\n{\n\tint flags = MFD_HUGETLB;\n\tchar *mem, *smem, tmp;\n\tint fd;\n\n\tksft_print_msg(\"[RUN] %s ... with memfd hugetlb (%zu kB)\\n\", desc,\n\t\t       hugetlbsize / 1024);\n\n\tflags |= __builtin_ctzll(hugetlbsize) << MFD_HUGE_SHIFT;\n\n\tfd = memfd_create(\"test\", flags);\n\tif (fd < 0) {\n\t\tksft_test_result_skip(\"memfd_create() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (fallocate(fd, 0, 0, hugetlbsize)) {\n\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\tgoto close;\n\t}\n\n\t \n\tmem = mmap(NULL, hugetlbsize, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd,\n\t\t   0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_skip(\"need more free huge pages\\n\");\n\t\tgoto close;\n\t}\n\tsmem = mmap(NULL, hugetlbsize, PROT_READ, MAP_SHARED, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\ttmp = *mem + *smem;\n\tasm volatile(\"\" : \"+r\" (tmp));\n\n\tfn(mem, smem, hugetlbsize);\nmunmap:\n\tmunmap(mem, hugetlbsize);\n\tif (mem != MAP_FAILED)\n\t\tmunmap(smem, hugetlbsize);\nclose:\n\tclose(fd);\n}\n\nstruct non_anon_test_case {\n\tconst char *desc;\n\tnon_anon_test_fn fn;\n};\n\n \nstatic const struct non_anon_test_case non_anon_test_cases[] = {\n\t \n\t{\n\t\t\"Basic COW\",\n\t\ttest_cow,\n\t},\n\t \n\t{\n\t\t\"R/O longterm GUP pin\",\n\t\ttest_ro_pin,\n\t},\n\t \n\t{\n\t\t\"R/O longterm GUP-fast pin\",\n\t\ttest_ro_fast_pin,\n\t},\n};\n\nstatic void run_non_anon_test_case(struct non_anon_test_case const *test_case)\n{\n\tint i;\n\n\trun_with_zeropage(test_case->fn, test_case->desc);\n\trun_with_memfd(test_case->fn, test_case->desc);\n\trun_with_tmpfile(test_case->fn, test_case->desc);\n\tif (thpsize)\n\t\trun_with_huge_zeropage(test_case->fn, test_case->desc);\n\tfor (i = 0; i < nr_hugetlbsizes; i++)\n\t\trun_with_memfd_hugetlb(test_case->fn, test_case->desc,\n\t\t\t\t       hugetlbsizes[i]);\n}\n\nstatic void run_non_anon_test_cases(void)\n{\n\tint i;\n\n\tksft_print_msg(\"[RUN] Non-anonymous memory tests in private mappings\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(non_anon_test_cases); i++)\n\t\trun_non_anon_test_case(&non_anon_test_cases[i]);\n}\n\nstatic int tests_per_non_anon_test_case(void)\n{\n\tint tests = 3 + nr_hugetlbsizes;\n\n\tif (thpsize)\n\t\ttests += 1;\n\treturn tests;\n}\n\nint main(int argc, char **argv)\n{\n\tint err;\n\n\tksft_print_header();\n\n\tpagesize = getpagesize();\n\tthpsize = read_pmd_pagesize();\n\tif (thpsize)\n\t\tksft_print_msg(\"[INFO] detected THP size: %zu KiB\\n\",\n\t\t\t       thpsize / 1024);\n\tnr_hugetlbsizes = detect_hugetlb_page_sizes(hugetlbsizes,\n\t\t\t\t\t\t    ARRAY_SIZE(hugetlbsizes));\n\tdetect_huge_zeropage();\n\n\tksft_set_plan(ARRAY_SIZE(anon_test_cases) * tests_per_anon_test_case() +\n\t\t      ARRAY_SIZE(anon_thp_test_cases) * tests_per_anon_thp_test_case() +\n\t\t      ARRAY_SIZE(non_anon_test_cases) * tests_per_non_anon_test_case());\n\n\tgup_fd = open(\"/sys/kernel/debug/gup_test\", O_RDWR);\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\tksft_exit_fail_msg(\"opening pagemap failed\\n\");\n\n\trun_anon_test_cases();\n\trun_anon_thp_test_cases();\n\trun_non_anon_test_cases();\n\n\terr = ksft_get_fail_cnt();\n\tif (err)\n\t\tksft_exit_fail_msg(\"%d out of %d tests failed\\n\",\n\t\t\t\t   err, ksft_test_num());\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}