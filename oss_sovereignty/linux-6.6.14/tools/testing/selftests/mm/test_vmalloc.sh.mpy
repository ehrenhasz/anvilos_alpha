{
  "module_name": "test_vmalloc.sh",
  "hash_id": "5b72b1b4eba52f790e38bb6932306ad311dc67a89b7677660f7c8dbb6fd92ddb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/test_vmalloc.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (C) 2018 Uladzislau Rezki (Sony) <urezki@gmail.com>\n#\n# This is a test script for the kernel test driver to analyse vmalloc\n# allocator. Therefore it is just a kernel module loader. You can specify\n# and pass different parameters in order to:\n#     a) analyse performance of vmalloc allocations;\n#     b) stressing and stability check of vmalloc subsystem.\n\nTEST_NAME=\"vmalloc\"\nDRIVER=\"test_${TEST_NAME}\"\nNUM_CPUS=`grep -c ^processor /proc/cpuinfo`\n\n# 1 if fails\nexitcode=1\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n#\n# Static templates for performance, stressing and smoke tests.\n# Also it is possible to pass any supported parameters manualy.\n#\nPERF_PARAM=\"sequential_test_order=1 test_repeat_count=3\"\nSMOKE_PARAM=\"test_loop_count=10000 test_repeat_count=10\"\nSTRESS_PARAM=\"nr_threads=$NUM_CPUS test_repeat_count=20\"\n\ncheck_test_requirements()\n{\n\tuid=$(id -u)\n\tif [ $uid -ne 0 ]; then\n\t\techo \"$0: Must be run as root\"\n\t\texit $ksft_skip\n\tfi\n\n\tif ! which modprobe > /dev/null 2>&1; then\n\t\techo \"$0: You need modprobe installed\"\n\t\texit $ksft_skip\n\tfi\n\n\tif ! modinfo $DRIVER > /dev/null 2>&1; then\n\t\techo \"$0: You must have the following enabled in your kernel:\"\n\t\techo \"CONFIG_TEST_VMALLOC=m\"\n\t\texit $ksft_skip\n\tfi\n}\n\nrun_perfformance_check()\n{\n\techo \"Run performance tests to evaluate how fast vmalloc allocation is.\"\n\techo \"It runs all test cases on one single CPU with sequential order.\"\n\n\tmodprobe $DRIVER $PERF_PARAM > /dev/null 2>&1\n\techo \"Done.\"\n\techo \"Ccheck the kernel message buffer to see the summary.\"\n}\n\nrun_stability_check()\n{\n\techo \"Run stability tests. In order to stress vmalloc subsystem all\"\n\techo \"available test cases are run by NUM_CPUS workers simultaneously.\"\n\techo \"It will take time, so be patient.\"\n\n\tmodprobe $DRIVER $STRESS_PARAM > /dev/null 2>&1\n\techo \"Done.\"\n\techo \"Check the kernel ring buffer to see the summary.\"\n}\n\nrun_smoke_check()\n{\n\techo \"Run smoke test. Note, this test provides basic coverage.\"\n\techo \"Please check $0 output how it can be used\"\n\techo \"for deep performance analysis as well as stress testing.\"\n\n\tmodprobe $DRIVER $SMOKE_PARAM > /dev/null 2>&1\n\techo \"Done.\"\n\techo \"Check the kernel ring buffer to see the summary.\"\n}\n\nusage()\n{\n\techo -n \"Usage: $0 [ performance ] | [ stress ] | | [ smoke ] | \"\n\techo \"manual parameters\"\n\techo\n\techo \"Valid tests and parameters:\"\n\techo\n\tmodinfo $DRIVER\n\techo\n\techo \"Example usage:\"\n\techo\n\techo \"# Shows help message\"\n\techo \"./${DRIVER}.sh\"\n\techo\n\techo \"# Runs 1 test(id_1), repeats it 5 times by NUM_CPUS workers\"\n\techo \"./${DRIVER}.sh nr_threads=$NUM_CPUS run_test_mask=1 test_repeat_count=5\"\n\techo\n\techo -n \"# Runs 4 tests(id_1|id_2|id_4|id_16) on one CPU with \"\n\techo \"sequential order\"\n\techo -n \"./${DRIVER}.sh sequential_test_order=1 \"\n\techo \"run_test_mask=23\"\n\techo\n\techo -n \"# Runs all tests by NUM_CPUS workers, shuffled order, repeats \"\n\techo \"20 times\"\n\techo \"./${DRIVER}.sh nr_threads=$NUM_CPUS test_repeat_count=20\"\n\techo\n\techo \"# Performance analysis\"\n\techo \"./${DRIVER}.sh performance\"\n\techo\n\techo \"# Stress testing\"\n\techo \"./${DRIVER}.sh stress\"\n\techo\n\texit 0\n}\n\nfunction validate_passed_args()\n{\n\tVALID_ARGS=`modinfo $DRIVER | awk '/parm:/ {print $2}' | sed 's/:.*//'`\n\n\t#\n\t# Something has been passed, check it.\n\t#\n\tfor passed_arg in $@; do\n\t\tkey=${passed_arg//=*/}\n\t\tval=\"${passed_arg:$((${#key}+1))}\"\n\t\tvalid=0\n\n\t\tfor valid_arg in $VALID_ARGS; do\n\t\t\tif [[ $key = $valid_arg ]] && [[ $val -gt 0 ]]; then\n\t\t\t\tvalid=1\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\n\t\tif [[ $valid -ne 1 ]]; then\n\t\t\techo \"Error: key or value is not correct: ${key} $val\"\n\t\t\texit $exitcode\n\t\tfi\n\tdone\n}\n\nfunction run_manual_check()\n{\n\t#\n\t# Validate passed parameters. If there is wrong one,\n\t# the script exists and does not execute further.\n\t#\n\tvalidate_passed_args $@\n\n\techo \"Run the test with following parameters: $@\"\n\tmodprobe $DRIVER $@ > /dev/null 2>&1\n\techo \"Done.\"\n\techo \"Check the kernel ring buffer to see the summary.\"\n}\n\nfunction run_test()\n{\n\tif [ $# -eq 0 ]; then\n\t\tusage\n\telse\n\t\tif [[ \"$1\" = \"performance\" ]]; then\n\t\t\trun_perfformance_check\n\t\telif [[ \"$1\" = \"stress\" ]]; then\n\t\t\trun_stability_check\n\t\telif [[ \"$1\" = \"smoke\" ]]; then\n\t\t\trun_smoke_check\n\t\telse\n\t\t\trun_manual_check $@\n\t\tfi\n\tfi\n}\n\ncheck_test_requirements\nrun_test $@\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}