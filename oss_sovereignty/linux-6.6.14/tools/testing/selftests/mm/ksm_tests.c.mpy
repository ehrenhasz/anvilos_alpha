{
  "module_name": "ksm_tests.c",
  "hash_id": "f41f5554b2617626a3ac043515daf21b6575d3cc9a3fd4c4d2a26ab0f9740c81",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/ksm_tests.c",
  "human_readable_source": "\n\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <stdbool.h>\n#include <time.h>\n#include <string.h>\n#include <numa.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <err.h>\n\n#include \"../kselftest.h\"\n#include <include/vdso/time64.h>\n#include \"vm_util.h\"\n\n#define KSM_SYSFS_PATH \"/sys/kernel/mm/ksm/\"\n#define KSM_FP(s) (KSM_SYSFS_PATH s)\n#define KSM_SCAN_LIMIT_SEC_DEFAULT 120\n#define KSM_PAGE_COUNT_DEFAULT 10l\n#define KSM_PROT_STR_DEFAULT \"rw\"\n#define KSM_USE_ZERO_PAGES_DEFAULT false\n#define KSM_MERGE_ACROSS_NODES_DEFAULT true\n#define KSM_MERGE_TYPE_DEFAULT 0\n#define MB (1ul << 20)\n\nstruct ksm_sysfs {\n\tunsigned long max_page_sharing;\n\tunsigned long merge_across_nodes;\n\tunsigned long pages_to_scan;\n\tunsigned long run;\n\tunsigned long sleep_millisecs;\n\tunsigned long stable_node_chains_prune_millisecs;\n\tunsigned long use_zero_pages;\n};\n\nenum ksm_merge_type {\n\tKSM_MERGE_MADVISE,\n\tKSM_MERGE_PRCTL,\n\tKSM_MERGE_LAST = KSM_MERGE_PRCTL\n};\n\nenum ksm_test_name {\n\tCHECK_KSM_MERGE,\n\tCHECK_KSM_UNMERGE,\n\tCHECK_KSM_GET_MERGE_TYPE,\n\tCHECK_KSM_ZERO_PAGE_MERGE,\n\tCHECK_KSM_NUMA_MERGE,\n\tKSM_MERGE_TIME,\n\tKSM_MERGE_TIME_HUGE_PAGES,\n\tKSM_UNMERGE_TIME,\n\tKSM_COW_TIME\n};\n\nint debug;\n\nstatic int ksm_write_sysfs(const char *file_path, unsigned long val)\n{\n\tFILE *f = fopen(file_path, \"w\");\n\n\tif (!f) {\n\t\tfprintf(stderr, \"f %s\\n\", file_path);\n\t\tperror(\"fopen\");\n\t\treturn 1;\n\t}\n\tif (fprintf(f, \"%lu\", val) < 0) {\n\t\tperror(\"fprintf\");\n\t\tfclose(f);\n\t\treturn 1;\n\t}\n\tfclose(f);\n\n\treturn 0;\n}\n\nstatic int ksm_read_sysfs(const char *file_path, unsigned long *val)\n{\n\tFILE *f = fopen(file_path, \"r\");\n\n\tif (!f) {\n\t\tfprintf(stderr, \"f %s\\n\", file_path);\n\t\tperror(\"fopen\");\n\t\treturn 1;\n\t}\n\tif (fscanf(f, \"%lu\", val) != 1) {\n\t\tperror(\"fscanf\");\n\t\tfclose(f);\n\t\treturn 1;\n\t}\n\tfclose(f);\n\n\treturn 0;\n}\n\nstatic void ksm_print_sysfs(void)\n{\n\tunsigned long max_page_sharing, pages_sharing, pages_shared;\n\tunsigned long full_scans, pages_unshared, pages_volatile;\n\tunsigned long stable_node_chains, stable_node_dups;\n\tlong general_profit;\n\n\tif (ksm_read_sysfs(KSM_FP(\"pages_shared\"), &pages_shared) ||\n\t    ksm_read_sysfs(KSM_FP(\"pages_sharing\"), &pages_sharing) ||\n\t    ksm_read_sysfs(KSM_FP(\"max_page_sharing\"), &max_page_sharing) ||\n\t    ksm_read_sysfs(KSM_FP(\"full_scans\"), &full_scans) ||\n\t    ksm_read_sysfs(KSM_FP(\"pages_unshared\"), &pages_unshared) ||\n\t    ksm_read_sysfs(KSM_FP(\"pages_volatile\"), &pages_volatile) ||\n\t    ksm_read_sysfs(KSM_FP(\"stable_node_chains\"), &stable_node_chains) ||\n\t    ksm_read_sysfs(KSM_FP(\"stable_node_dups\"), &stable_node_dups) ||\n\t    ksm_read_sysfs(KSM_FP(\"general_profit\"), (unsigned long *)&general_profit))\n\t\treturn;\n\n\tprintf(\"pages_shared      : %lu\\n\", pages_shared);\n\tprintf(\"pages_sharing     : %lu\\n\", pages_sharing);\n\tprintf(\"max_page_sharing  : %lu\\n\", max_page_sharing);\n\tprintf(\"full_scans        : %lu\\n\", full_scans);\n\tprintf(\"pages_unshared    : %lu\\n\", pages_unshared);\n\tprintf(\"pages_volatile    : %lu\\n\", pages_volatile);\n\tprintf(\"stable_node_chains: %lu\\n\", stable_node_chains);\n\tprintf(\"stable_node_dups  : %lu\\n\", stable_node_dups);\n\tprintf(\"general_profit    : %ld\\n\", general_profit);\n}\n\nstatic void ksm_print_procfs(void)\n{\n\tconst char *file_name = \"/proc/self/ksm_stat\";\n\tchar buffer[512];\n\tFILE *f = fopen(file_name, \"r\");\n\n\tif (!f) {\n\t\tfprintf(stderr, \"f %s\\n\", file_name);\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\n\twhile (fgets(buffer, sizeof(buffer), f))\n\t\tprintf(\"%s\", buffer);\n\n\tfclose(f);\n}\n\nstatic int str_to_prot(char *prot_str)\n{\n\tint prot = 0;\n\n\tif ((strchr(prot_str, 'r')) != NULL)\n\t\tprot |= PROT_READ;\n\tif ((strchr(prot_str, 'w')) != NULL)\n\t\tprot |= PROT_WRITE;\n\tif ((strchr(prot_str, 'x')) != NULL)\n\t\tprot |= PROT_EXEC;\n\n\treturn prot;\n}\n\nstatic void print_help(void)\n{\n\tprintf(\"usage: ksm_tests [-h] <test type> [-a prot] [-p page_count] [-l timeout]\\n\"\n\t       \"[-z use_zero_pages] [-m merge_across_nodes] [-s size]\\n\");\n\n\tprintf(\"Supported <test type>:\\n\"\n\t       \" -M (page merging)\\n\"\n\t       \" -Z (zero pages merging)\\n\"\n\t       \" -N (merging of pages in different NUMA nodes)\\n\"\n\t       \" -U (page unmerging)\\n\"\n\t       \" -P evaluate merging time and speed.\\n\"\n\t       \"    For this test, the size of duplicated memory area (in MiB)\\n\"\n\t       \"    must be provided using -s option\\n\"\n\t       \" -H evaluate merging time and speed of area allocated mostly with huge pages\\n\"\n\t       \"    For this test, the size of duplicated memory area (in MiB)\\n\"\n\t       \"    must be provided using -s option\\n\"\n\t       \" -D evaluate unmerging time and speed when disabling KSM.\\n\"\n\t       \"    For this test, the size of duplicated memory area (in MiB)\\n\"\n\t       \"    must be provided using -s option\\n\"\n\t       \" -C evaluate the time required to break COW of merged pages.\\n\\n\");\n\n\tprintf(\" -a: specify the access protections of pages.\\n\"\n\t       \"     <prot> must be of the form [rwx].\\n\"\n\t       \"     Default: %s\\n\", KSM_PROT_STR_DEFAULT);\n\tprintf(\" -p: specify the number of pages to test.\\n\"\n\t       \"     Default: %ld\\n\", KSM_PAGE_COUNT_DEFAULT);\n\tprintf(\" -l: limit the maximum running time (in seconds) for a test.\\n\"\n\t       \"     Default: %d seconds\\n\", KSM_SCAN_LIMIT_SEC_DEFAULT);\n\tprintf(\" -z: change use_zero_pages tunable\\n\"\n\t       \"     Default: %d\\n\", KSM_USE_ZERO_PAGES_DEFAULT);\n\tprintf(\" -m: change merge_across_nodes tunable\\n\"\n\t       \"     Default: %d\\n\", KSM_MERGE_ACROSS_NODES_DEFAULT);\n\tprintf(\" -d: turn debugging output on\\n\");\n\tprintf(\" -s: the size of duplicated memory area (in MiB)\\n\");\n\tprintf(\" -t: KSM merge type\\n\"\n\t       \"     Default: 0\\n\"\n\t       \"     0: madvise merging\\n\"\n\t       \"     1: prctl merging\\n\");\n\n\texit(0);\n}\n\nstatic void  *allocate_memory(void *ptr, int prot, int mapping, char data, size_t map_size)\n{\n\tvoid *map_ptr = mmap(ptr, map_size, PROT_WRITE, mapping, -1, 0);\n\n\tif (!map_ptr) {\n\t\tperror(\"mmap\");\n\t\treturn NULL;\n\t}\n\tmemset(map_ptr, data, map_size);\n\tif (mprotect(map_ptr, map_size, prot)) {\n\t\tperror(\"mprotect\");\n\t\tmunmap(map_ptr, map_size);\n\t\treturn NULL;\n\t}\n\n\treturn map_ptr;\n}\n\nstatic int ksm_do_scan(int scan_count, struct timespec start_time, int timeout)\n{\n\tstruct timespec cur_time;\n\tunsigned long cur_scan, init_scan;\n\n\tif (ksm_read_sysfs(KSM_FP(\"full_scans\"), &init_scan))\n\t\treturn 1;\n\tcur_scan = init_scan;\n\n\twhile (cur_scan < init_scan + scan_count) {\n\t\tif (ksm_read_sysfs(KSM_FP(\"full_scans\"), &cur_scan))\n\t\t\treturn 1;\n\t\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &cur_time)) {\n\t\t\tperror(\"clock_gettime\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((cur_time.tv_sec - start_time.tv_sec) > timeout) {\n\t\t\tprintf(\"Scan time limit exceeded\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ksm_merge_pages(int merge_type, void *addr, size_t size,\n\t\t\tstruct timespec start_time, int timeout)\n{\n\tif (merge_type == KSM_MERGE_MADVISE) {\n\t\tif (madvise(addr, size, MADV_MERGEABLE)) {\n\t\t\tperror(\"madvise\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (merge_type == KSM_MERGE_PRCTL) {\n\t\tif (prctl(PR_SET_MEMORY_MERGE, 1, 0, 0, 0)) {\n\t\t\tperror(\"prctl\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (ksm_write_sysfs(KSM_FP(\"run\"), 1))\n\t\treturn 1;\n\n\t \n\tif (ksm_do_scan(2, start_time, timeout))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ksm_unmerge_pages(void *addr, size_t size,\n\t\t\t     struct timespec start_time, int timeout)\n{\n\tif (madvise(addr, size, MADV_UNMERGEABLE)) {\n\t\tperror(\"madvise\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool assert_ksm_pages_count(long dupl_page_count)\n{\n\tunsigned long max_page_sharing, pages_sharing, pages_shared;\n\n\tif (ksm_read_sysfs(KSM_FP(\"pages_shared\"), &pages_shared) ||\n\t    ksm_read_sysfs(KSM_FP(\"pages_sharing\"), &pages_sharing) ||\n\t    ksm_read_sysfs(KSM_FP(\"max_page_sharing\"), &max_page_sharing))\n\t\treturn false;\n\n\tif (debug) {\n\t\tksm_print_sysfs();\n\t\tksm_print_procfs();\n\t}\n\n\t \n\tif (dupl_page_count % max_page_sharing == 1 || dupl_page_count % max_page_sharing == 0) {\n\t\tif (pages_shared == dupl_page_count / max_page_sharing &&\n\t\t    pages_sharing == pages_shared * (max_page_sharing - 1))\n\t\t\treturn true;\n\t} else {\n\t\tif (pages_shared == (dupl_page_count / max_page_sharing + 1) &&\n\t\t    pages_sharing == dupl_page_count - pages_shared)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ksm_save_def(struct ksm_sysfs *ksm_sysfs)\n{\n\tif (ksm_read_sysfs(KSM_FP(\"max_page_sharing\"), &ksm_sysfs->max_page_sharing) ||\n\t    numa_available() ? 0 :\n\t\tksm_read_sysfs(KSM_FP(\"merge_across_nodes\"), &ksm_sysfs->merge_across_nodes) ||\n\t    ksm_read_sysfs(KSM_FP(\"sleep_millisecs\"), &ksm_sysfs->sleep_millisecs) ||\n\t    ksm_read_sysfs(KSM_FP(\"pages_to_scan\"), &ksm_sysfs->pages_to_scan) ||\n\t    ksm_read_sysfs(KSM_FP(\"run\"), &ksm_sysfs->run) ||\n\t    ksm_read_sysfs(KSM_FP(\"stable_node_chains_prune_millisecs\"),\n\t\t\t   &ksm_sysfs->stable_node_chains_prune_millisecs) ||\n\t    ksm_read_sysfs(KSM_FP(\"use_zero_pages\"), &ksm_sysfs->use_zero_pages))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ksm_restore(struct ksm_sysfs *ksm_sysfs)\n{\n\tif (ksm_write_sysfs(KSM_FP(\"max_page_sharing\"), ksm_sysfs->max_page_sharing) ||\n\t    numa_available() ? 0 :\n\t\tksm_write_sysfs(KSM_FP(\"merge_across_nodes\"), ksm_sysfs->merge_across_nodes) ||\n\t    ksm_write_sysfs(KSM_FP(\"pages_to_scan\"), ksm_sysfs->pages_to_scan) ||\n\t    ksm_write_sysfs(KSM_FP(\"run\"), ksm_sysfs->run) ||\n\t    ksm_write_sysfs(KSM_FP(\"sleep_millisecs\"), ksm_sysfs->sleep_millisecs) ||\n\t    ksm_write_sysfs(KSM_FP(\"stable_node_chains_prune_millisecs\"),\n\t\t\t    ksm_sysfs->stable_node_chains_prune_millisecs) ||\n\t    ksm_write_sysfs(KSM_FP(\"use_zero_pages\"), ksm_sysfs->use_zero_pages))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int check_ksm_merge(int merge_type, int mapping, int prot,\n\t\t\tlong page_count, int timeout, size_t page_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\t \n\tmap_ptr = allocate_memory(NULL, prot, mapping, '*', page_size * page_count);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\n\tif (ksm_merge_pages(merge_type, map_ptr, page_size * page_count, start_time, timeout))\n\t\tgoto err_out;\n\n\t \n\tif (assert_ksm_pages_count(page_count)) {\n\t\tprintf(\"OK\\n\");\n\t\tmunmap(map_ptr, page_size * page_count);\n\t\tif (merge_type == KSM_MERGE_PRCTL)\n\t\t\tprctl(PR_SET_MEMORY_MERGE, 0, 0, 0, 0);\n\t\treturn KSFT_PASS;\n\t}\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_FAIL;\n}\n\nstatic int check_ksm_unmerge(int merge_type, int mapping, int prot, int timeout, size_t page_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time;\n\tint page_count = 2;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\t \n\tmap_ptr = allocate_memory(NULL, prot, mapping, '*', page_size * page_count);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\n\tif (ksm_merge_pages(merge_type, map_ptr, page_size * page_count, start_time, timeout))\n\t\tgoto err_out;\n\n\t \n\tmemset(map_ptr, '-', 1);\n\tmemset(map_ptr + page_size, '+', 1);\n\n\t \n\tif (ksm_do_scan(1, start_time, timeout))\n\t\tgoto err_out;\n\n\t \n\tif (assert_ksm_pages_count(0)) {\n\t\tprintf(\"OK\\n\");\n\t\tmunmap(map_ptr, page_size * page_count);\n\t\treturn KSFT_PASS;\n\t}\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_FAIL;\n}\n\nstatic int check_ksm_zero_page_merge(int merge_type, int mapping, int prot, long page_count,\n\t\t\t\tint timeout, bool use_zero_pages, size_t page_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (ksm_write_sysfs(KSM_FP(\"use_zero_pages\"), use_zero_pages))\n\t\treturn KSFT_FAIL;\n\n\t \n\tmap_ptr = allocate_memory(NULL, prot, mapping, 0, page_size * page_count);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\n\tif (ksm_merge_pages(merge_type, map_ptr, page_size * page_count, start_time, timeout))\n\t\tgoto err_out;\n\n        \n\tif (use_zero_pages && !assert_ksm_pages_count(0))\n\t\tgoto err_out;\n\telse if (!use_zero_pages && !assert_ksm_pages_count(page_count))\n\t\tgoto err_out;\n\n\tprintf(\"OK\\n\");\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_PASS;\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_FAIL;\n}\n\nstatic int get_next_mem_node(int node)\n{\n\n\tlong node_size;\n\tint mem_node = 0;\n\tint i, max_node = numa_max_node();\n\n\tfor (i = node + 1; i <= max_node + node; i++) {\n\t\tmem_node = i % (max_node + 1);\n\t\tnode_size = numa_node_size(mem_node, NULL);\n\t\tif (node_size > 0)\n\t\t\tbreak;\n\t}\n\treturn mem_node;\n}\n\nstatic int get_first_mem_node(void)\n{\n\treturn get_next_mem_node(numa_max_node());\n}\n\nstatic int check_ksm_numa_merge(int merge_type, int mapping, int prot, int timeout,\n\t\t\t\tbool merge_across_nodes, size_t page_size)\n{\n\tvoid *numa1_map_ptr, *numa2_map_ptr;\n\tstruct timespec start_time;\n\tint page_count = 2;\n\tint first_node;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (numa_available() < 0) {\n\t\tperror(\"NUMA support not enabled\");\n\t\treturn KSFT_SKIP;\n\t}\n\tif (numa_num_configured_nodes() <= 1) {\n\t\tprintf(\"At least 2 NUMA nodes must be available\\n\");\n\t\treturn KSFT_SKIP;\n\t}\n\tif (ksm_write_sysfs(KSM_FP(\"merge_across_nodes\"), merge_across_nodes))\n\t\treturn KSFT_FAIL;\n\n\t \n\tfirst_node = get_first_mem_node();\n\tnuma1_map_ptr = numa_alloc_onnode(page_size, first_node);\n\tnuma2_map_ptr = numa_alloc_onnode(page_size, get_next_mem_node(first_node));\n\tif (!numa1_map_ptr || !numa2_map_ptr) {\n\t\tperror(\"numa_alloc_onnode\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tmemset(numa1_map_ptr, '*', page_size);\n\tmemset(numa2_map_ptr, '*', page_size);\n\n\t \n\tif (ksm_merge_pages(merge_type, numa1_map_ptr, page_size, start_time, timeout) ||\n\t    ksm_merge_pages(merge_type, numa2_map_ptr, page_size, start_time, timeout))\n\t\tgoto err_out;\n\n        \n\tif (merge_across_nodes && !assert_ksm_pages_count(page_count))\n\t\tgoto err_out;\n\telse if (!merge_across_nodes && !assert_ksm_pages_count(0))\n\t\tgoto err_out;\n\n\tnuma_free(numa1_map_ptr, page_size);\n\tnuma_free(numa2_map_ptr, page_size);\n\tprintf(\"OK\\n\");\n\treturn KSFT_PASS;\n\nerr_out:\n\tnuma_free(numa1_map_ptr, page_size);\n\tnuma_free(numa2_map_ptr, page_size);\n\tprintf(\"Not OK\\n\");\n\treturn KSFT_FAIL;\n}\n\nstatic int ksm_merge_hugepages_time(int merge_type, int mapping, int prot,\n\t\t\t\tint timeout, size_t map_size)\n{\n\tvoid *map_ptr, *map_ptr_orig;\n\tstruct timespec start_time, end_time;\n\tunsigned long scan_time_ns;\n\tint pagemap_fd, n_normal_pages, n_huge_pages;\n\n\tmap_size *= MB;\n\tsize_t len = map_size;\n\n\tlen -= len % HPAGE_SIZE;\n\tmap_ptr_orig = mmap(NULL, len + HPAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\tMAP_ANONYMOUS | MAP_NORESERVE | MAP_PRIVATE, -1, 0);\n\tmap_ptr = map_ptr_orig + HPAGE_SIZE - (uintptr_t)map_ptr_orig % HPAGE_SIZE;\n\n\tif (map_ptr_orig == MAP_FAILED)\n\t\terr(2, \"initial mmap\");\n\n\tif (madvise(map_ptr, len + HPAGE_SIZE, MADV_HUGEPAGE))\n\t\terr(2, \"MADV_HUGEPAGE\");\n\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\terr(2, \"open pagemap\");\n\n\tn_normal_pages = 0;\n\tn_huge_pages = 0;\n\tfor (void *p = map_ptr; p < map_ptr + len; p += HPAGE_SIZE) {\n\t\tif (allocate_transhuge(p, pagemap_fd) < 0)\n\t\t\tn_normal_pages++;\n\t\telse\n\t\t\tn_huge_pages++;\n\t}\n\tprintf(\"Number of normal pages:    %d\\n\", n_normal_pages);\n\tprintf(\"Number of huge pages:    %d\\n\", n_huge_pages);\n\n\tmemset(map_ptr, '*', len);\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\tif (ksm_merge_pages(merge_type, map_ptr, map_size, start_time, timeout))\n\t\tgoto err_out;\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &end_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\n\tscan_time_ns = (end_time.tv_sec - start_time.tv_sec) * NSEC_PER_SEC +\n\t\t       (end_time.tv_nsec - start_time.tv_nsec);\n\n\tprintf(\"Total size:    %lu MiB\\n\", map_size / MB);\n\tprintf(\"Total time:    %ld.%09ld s\\n\", scan_time_ns / NSEC_PER_SEC,\n\t       scan_time_ns % NSEC_PER_SEC);\n\tprintf(\"Average speed:  %.3f MiB/s\\n\", (map_size / MB) /\n\t\t\t\t\t       ((double)scan_time_ns / NSEC_PER_SEC));\n\n\tmunmap(map_ptr_orig, len + HPAGE_SIZE);\n\treturn KSFT_PASS;\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr_orig, len + HPAGE_SIZE);\n\treturn KSFT_FAIL;\n}\n\nstatic int ksm_merge_time(int merge_type, int mapping, int prot, int timeout, size_t map_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time, end_time;\n\tunsigned long scan_time_ns;\n\n\tmap_size *= MB;\n\n\tmap_ptr = allocate_memory(NULL, prot, mapping, '*', map_size);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\tif (ksm_merge_pages(merge_type, map_ptr, map_size, start_time, timeout))\n\t\tgoto err_out;\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &end_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\n\tscan_time_ns = (end_time.tv_sec - start_time.tv_sec) * NSEC_PER_SEC +\n\t\t       (end_time.tv_nsec - start_time.tv_nsec);\n\n\tprintf(\"Total size:    %lu MiB\\n\", map_size / MB);\n\tprintf(\"Total time:    %ld.%09ld s\\n\", scan_time_ns / NSEC_PER_SEC,\n\t       scan_time_ns % NSEC_PER_SEC);\n\tprintf(\"Average speed:  %.3f MiB/s\\n\", (map_size / MB) /\n\t\t\t\t\t       ((double)scan_time_ns / NSEC_PER_SEC));\n\n\tmunmap(map_ptr, map_size);\n\treturn KSFT_PASS;\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, map_size);\n\treturn KSFT_FAIL;\n}\n\nstatic int ksm_unmerge_time(int merge_type, int mapping, int prot, int timeout, size_t map_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time, end_time;\n\tunsigned long scan_time_ns;\n\n\tmap_size *= MB;\n\n\tmap_ptr = allocate_memory(NULL, prot, mapping, '*', map_size);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\tif (ksm_merge_pages(merge_type, map_ptr, map_size, start_time, timeout))\n\t\tgoto err_out;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\tif (ksm_unmerge_pages(map_ptr, map_size, start_time, timeout))\n\t\tgoto err_out;\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &end_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\n\tscan_time_ns = (end_time.tv_sec - start_time.tv_sec) * NSEC_PER_SEC +\n\t\t       (end_time.tv_nsec - start_time.tv_nsec);\n\n\tprintf(\"Total size:    %lu MiB\\n\", map_size / MB);\n\tprintf(\"Total time:    %ld.%09ld s\\n\", scan_time_ns / NSEC_PER_SEC,\n\t       scan_time_ns % NSEC_PER_SEC);\n\tprintf(\"Average speed:  %.3f MiB/s\\n\", (map_size / MB) /\n\t\t\t\t\t       ((double)scan_time_ns / NSEC_PER_SEC));\n\n\tmunmap(map_ptr, map_size);\n\treturn KSFT_PASS;\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, map_size);\n\treturn KSFT_FAIL;\n}\n\nstatic int ksm_cow_time(int merge_type, int mapping, int prot, int timeout, size_t page_size)\n{\n\tvoid *map_ptr;\n\tstruct timespec start_time, end_time;\n\tunsigned long cow_time_ns;\n\n\t \n\tsize_t page_count = 4000;\n\n\tmap_ptr = allocate_memory(NULL, prot, mapping, '*', page_size * page_count);\n\tif (!map_ptr)\n\t\treturn KSFT_FAIL;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\tfor (size_t i = 0; i < page_count - 1; i = i + 2)\n\t\tmemset(map_ptr + page_size * i, '-', 1);\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &end_time)) {\n\t\tperror(\"clock_gettime\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tcow_time_ns = (end_time.tv_sec - start_time.tv_sec) * NSEC_PER_SEC +\n\t\t       (end_time.tv_nsec - start_time.tv_nsec);\n\n\tprintf(\"Total size:    %lu MiB\\n\\n\", (page_size * page_count) / MB);\n\tprintf(\"Not merged pages:\\n\");\n\tprintf(\"Total time:     %ld.%09ld s\\n\", cow_time_ns / NSEC_PER_SEC,\n\t       cow_time_ns % NSEC_PER_SEC);\n\tprintf(\"Average speed:  %.3f MiB/s\\n\\n\", ((page_size * (page_count / 2)) / MB) /\n\t\t\t\t\t       ((double)cow_time_ns / NSEC_PER_SEC));\n\n\t \n\tfor (size_t i = 0; i < page_count - 1; i = i + 2) {\n\t\tmemset(map_ptr + page_size * i, '+', i / 2 + 1);\n\t\tmemset(map_ptr + page_size * (i + 1), '+', i / 2 + 1);\n\t}\n\tif (ksm_merge_pages(merge_type, map_ptr, page_size * page_count, start_time, timeout))\n\t\tgoto err_out;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &start_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\tfor (size_t i = 0; i < page_count - 1; i = i + 2)\n\t\tmemset(map_ptr + page_size * i, '-', 1);\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &end_time)) {\n\t\tperror(\"clock_gettime\");\n\t\tgoto err_out;\n\t}\n\n\tcow_time_ns = (end_time.tv_sec - start_time.tv_sec) * NSEC_PER_SEC +\n\t\t       (end_time.tv_nsec - start_time.tv_nsec);\n\n\tprintf(\"Merged pages:\\n\");\n\tprintf(\"Total time:     %ld.%09ld s\\n\", cow_time_ns / NSEC_PER_SEC,\n\t       cow_time_ns % NSEC_PER_SEC);\n\tprintf(\"Average speed:  %.3f MiB/s\\n\", ((page_size * (page_count / 2)) / MB) /\n\t\t\t\t\t       ((double)cow_time_ns / NSEC_PER_SEC));\n\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_PASS;\n\nerr_out:\n\tprintf(\"Not OK\\n\");\n\tmunmap(map_ptr, page_size * page_count);\n\treturn KSFT_FAIL;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret, opt;\n\tint prot = 0;\n\tint ksm_scan_limit_sec = KSM_SCAN_LIMIT_SEC_DEFAULT;\n\tint merge_type = KSM_MERGE_TYPE_DEFAULT;\n\tlong page_count = KSM_PAGE_COUNT_DEFAULT;\n\tsize_t page_size = sysconf(_SC_PAGESIZE);\n\tstruct ksm_sysfs ksm_sysfs_old;\n\tint test_name = CHECK_KSM_MERGE;\n\tbool use_zero_pages = KSM_USE_ZERO_PAGES_DEFAULT;\n\tbool merge_across_nodes = KSM_MERGE_ACROSS_NODES_DEFAULT;\n\tlong size_MB = 0;\n\n\twhile ((opt = getopt(argc, argv, \"dha:p:l:z:m:s:t:MUZNPCHD\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tprot = str_to_prot(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpage_count = atol(optarg);\n\t\t\tif (page_count <= 0) {\n\t\t\t\tprintf(\"The number of pages must be greater than 0\\n\");\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tksm_scan_limit_sec = atoi(optarg);\n\t\t\tif (ksm_scan_limit_sec <= 0) {\n\t\t\t\tprintf(\"Timeout value must be greater than 0\\n\");\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprint_help();\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tif (strcmp(optarg, \"0\") == 0)\n\t\t\t\tuse_zero_pages = 0;\n\t\t\telse\n\t\t\t\tuse_zero_pages = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcmp(optarg, \"0\") == 0)\n\t\t\t\tmerge_across_nodes = 0;\n\t\t\telse\n\t\t\t\tmerge_across_nodes = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsize_MB = atoi(optarg);\n\t\t\tif (size_MB <= 0) {\n\t\t\t\tprintf(\"Size must be greater than 0\\n\");\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t{\n\t\t\t\tint tmp = atoi(optarg);\n\n\t\t\t\tif (tmp < 0 || tmp > KSM_MERGE_LAST) {\n\t\t\t\t\tprintf(\"Invalid merge type\\n\");\n\t\t\t\t\treturn KSFT_FAIL;\n\t\t\t\t}\n\t\t\t\tmerge_type = tmp;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\ttest_name = CHECK_KSM_UNMERGE;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\ttest_name = CHECK_KSM_ZERO_PAGE_MERGE;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttest_name = CHECK_KSM_NUMA_MERGE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\ttest_name = KSM_MERGE_TIME;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\ttest_name = KSM_MERGE_TIME_HUGE_PAGES;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\ttest_name = KSM_UNMERGE_TIME;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\ttest_name = KSM_COW_TIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t}\n\n\tif (prot == 0)\n\t\tprot = str_to_prot(KSM_PROT_STR_DEFAULT);\n\n\tif (access(KSM_SYSFS_PATH, F_OK)) {\n\t\tprintf(\"Config KSM not enabled\\n\");\n\t\treturn KSFT_SKIP;\n\t}\n\n\tif (ksm_save_def(&ksm_sysfs_old)) {\n\t\tprintf(\"Cannot save default tunables\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (ksm_write_sysfs(KSM_FP(\"run\"), 2) ||\n\t    ksm_write_sysfs(KSM_FP(\"sleep_millisecs\"), 0) ||\n\t    numa_available() ? 0 :\n\t\tksm_write_sysfs(KSM_FP(\"merge_across_nodes\"), 1) ||\n\t    ksm_write_sysfs(KSM_FP(\"pages_to_scan\"), page_count))\n\t\treturn KSFT_FAIL;\n\n\tswitch (test_name) {\n\tcase CHECK_KSM_MERGE:\n\t\tret = check_ksm_merge(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot, page_count,\n\t\t\t\t      ksm_scan_limit_sec, page_size);\n\t\tbreak;\n\tcase CHECK_KSM_UNMERGE:\n\t\tret = check_ksm_unmerge(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\t\tksm_scan_limit_sec, page_size);\n\t\tbreak;\n\tcase CHECK_KSM_ZERO_PAGE_MERGE:\n\t\tret = check_ksm_zero_page_merge(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\t\t\tpage_count, ksm_scan_limit_sec, use_zero_pages,\n\t\t\t\t\t\tpage_size);\n\t\tbreak;\n\tcase CHECK_KSM_NUMA_MERGE:\n\t\tret = check_ksm_numa_merge(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\t\tksm_scan_limit_sec, merge_across_nodes, page_size);\n\t\tbreak;\n\tcase KSM_MERGE_TIME:\n\t\tif (size_MB == 0) {\n\t\t\tprintf(\"Option '-s' is required.\\n\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tret = ksm_merge_time(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\tksm_scan_limit_sec, size_MB);\n\t\tbreak;\n\tcase KSM_MERGE_TIME_HUGE_PAGES:\n\t\tif (size_MB == 0) {\n\t\t\tprintf(\"Option '-s' is required.\\n\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tret = ksm_merge_hugepages_time(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\tksm_scan_limit_sec, size_MB);\n\t\tbreak;\n\tcase KSM_UNMERGE_TIME:\n\t\tif (size_MB == 0) {\n\t\t\tprintf(\"Option '-s' is required.\\n\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tret = ksm_unmerge_time(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\t       ksm_scan_limit_sec, size_MB);\n\t\tbreak;\n\tcase KSM_COW_TIME:\n\t\tret = ksm_cow_time(merge_type, MAP_PRIVATE | MAP_ANONYMOUS, prot,\n\t\t\t\tksm_scan_limit_sec, page_size);\n\t\tbreak;\n\t}\n\n\tif (ksm_restore(&ksm_sysfs_old)) {\n\t\tprintf(\"Cannot restore default tunables\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}