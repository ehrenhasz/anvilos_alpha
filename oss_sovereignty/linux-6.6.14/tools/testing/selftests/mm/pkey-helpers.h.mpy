{
  "module_name": "pkey-helpers.h",
  "hash_id": "3b5fa159c311528a5ed92cf6752fc6c64c798dd9a211e293b56f15db89d5a820",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/pkey-helpers.h",
  "human_readable_source": " \n#ifndef _PKEYS_HELPER_H\n#define _PKEYS_HELPER_H\n#define _GNU_SOURCE\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <ucontext.h>\n#include <sys/mman.h>\n\n#include \"../kselftest.h\"\n\n \n#define  u8 __u8\n#define u16 __u16\n#define u32 __u32\n#define u64 __u64\n\n#define PTR_ERR_ENOTSUP ((void *)-ENOTSUP)\n\n#ifndef DEBUG_LEVEL\n#define DEBUG_LEVEL 0\n#endif\n#define DPRINT_IN_SIGNAL_BUF_SIZE 4096\nextern int dprint_in_signal;\nextern char dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];\n\nextern int test_nr;\nextern int iteration_nr;\n\n#ifdef __GNUC__\n__attribute__((format(printf, 1, 2)))\n#endif\nstatic inline void sigsafe_printf(const char *format, ...)\n{\n\tva_list ap;\n\n\tif (!dprint_in_signal) {\n\t\tva_start(ap, format);\n\t\tvprintf(format, ap);\n\t\tva_end(ap);\n\t} else {\n\t\tint ret;\n\t\t \n\t\tret = write(1, format, strlen(format));\n\t\tif (ret < 0)\n\t\t\texit(1);\n\t}\n}\n#define dprintf_level(level, args...) do {\t\\\n\tif (level <= DEBUG_LEVEL)\t\t\\\n\t\tsigsafe_printf(args);\t\t\\\n} while (0)\n#define dprintf0(args...) dprintf_level(0, args)\n#define dprintf1(args...) dprintf_level(1, args)\n#define dprintf2(args...) dprintf_level(2, args)\n#define dprintf3(args...) dprintf_level(3, args)\n#define dprintf4(args...) dprintf_level(4, args)\n\nextern void abort_hooks(void);\n#define pkey_assert(condition) do {\t\t\\\n\tif (!(condition)) {\t\t\t\\\n\t\tdprintf0(\"assert() at %s::%d test_nr: %d iteration: %d\\n\", \\\n\t\t\t\t__FILE__, __LINE__,\t\\\n\t\t\t\ttest_nr, iteration_nr);\t\\\n\t\tdprintf0(\"errno at assert: %d\", errno);\t\\\n\t\tabort_hooks();\t\t\t\\\n\t\texit(__LINE__);\t\t\t\\\n\t}\t\t\t\t\t\\\n} while (0)\n\n__attribute__((noinline)) int read_ptr(int *ptr);\nvoid expected_pkey_fault(int pkey);\nint sys_pkey_alloc(unsigned long flags, unsigned long init_val);\nint sys_pkey_free(unsigned long pkey);\nint mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,\n\t\tunsigned long pkey);\nvoid record_pkey_malloc(void *ptr, long size, int prot);\n\n#if defined(__i386__) || defined(__x86_64__)  \n#include \"pkey-x86.h\"\n#elif defined(__powerpc64__)  \n#include \"pkey-powerpc.h\"\n#else  \n#error Architecture not supported\n#endif  \n\n#define PKEY_MASK\t(PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE)\n\nstatic inline u64 set_pkey_bits(u64 reg, int pkey, u64 flags)\n{\n\tu32 shift = pkey_bit_position(pkey);\n\t \n\treg &= ~((u64)PKEY_MASK << shift);\n\t \n\treg |= (flags & PKEY_MASK) << shift;\n\treturn reg;\n}\n\nstatic inline u64 get_pkey_bits(u64 reg, int pkey)\n{\n\tu32 shift = pkey_bit_position(pkey);\n\t \n\treturn ((reg >> shift) & PKEY_MASK);\n}\n\nextern u64 shadow_pkey_reg;\n\nstatic inline u64 _read_pkey_reg(int line)\n{\n\tu64 pkey_reg = __read_pkey_reg();\n\n\tdprintf4(\"read_pkey_reg(line=%d) pkey_reg: %016llx\"\n\t\t\t\" shadow: %016llx\\n\",\n\t\t\tline, pkey_reg, shadow_pkey_reg);\n\tassert(pkey_reg == shadow_pkey_reg);\n\n\treturn pkey_reg;\n}\n\n#define read_pkey_reg() _read_pkey_reg(__LINE__)\n\nstatic inline void write_pkey_reg(u64 pkey_reg)\n{\n\tdprintf4(\"%s() changing %016llx to %016llx\\n\", __func__,\n\t\t\t__read_pkey_reg(), pkey_reg);\n\t \n\tread_pkey_reg();\n\t__write_pkey_reg(pkey_reg);\n\tshadow_pkey_reg = pkey_reg;\n\tdprintf4(\"%s(%016llx) pkey_reg: %016llx\\n\", __func__,\n\t\t\tpkey_reg, __read_pkey_reg());\n}\n\n \nstatic inline void __pkey_access_allow(int pkey, int do_allow)\n{\n\tu64 pkey_reg = read_pkey_reg();\n\tint bit = pkey * 2;\n\n\tif (do_allow)\n\t\tpkey_reg &= (1<<bit);\n\telse\n\t\tpkey_reg |= (1<<bit);\n\n\tdprintf4(\"pkey_reg now: %016llx\\n\", read_pkey_reg());\n\twrite_pkey_reg(pkey_reg);\n}\n\nstatic inline void __pkey_write_allow(int pkey, int do_allow_write)\n{\n\tu64 pkey_reg = read_pkey_reg();\n\tint bit = pkey * 2 + 1;\n\n\tif (do_allow_write)\n\t\tpkey_reg &= (1<<bit);\n\telse\n\t\tpkey_reg |= (1<<bit);\n\n\twrite_pkey_reg(pkey_reg);\n\tdprintf4(\"pkey_reg now: %016llx\\n\", read_pkey_reg());\n}\n\n#define ALIGN_UP(x, align_to)\t(((x) + ((align_to)-1)) & ~((align_to)-1))\n#define ALIGN_DOWN(x, align_to) ((x) & ~((align_to)-1))\n#define ALIGN_PTR_UP(p, ptr_align_to)\t\\\n\t((typeof(p))ALIGN_UP((unsigned long)(p), ptr_align_to))\n#define ALIGN_PTR_DOWN(p, ptr_align_to)\t\\\n\t((typeof(p))ALIGN_DOWN((unsigned long)(p), ptr_align_to))\n#define __stringify_1(x...)     #x\n#define __stringify(x...)       __stringify_1(x)\n\nstatic inline u32 *siginfo_get_pkey_ptr(siginfo_t *si)\n{\n#ifdef si_pkey\n\treturn &si->si_pkey;\n#else\n\treturn (u32 *)(((u8 *)si) + si_pkey_offset);\n#endif\n}\n\nstatic inline int kernel_has_pkeys(void)\n{\n\t \n\tint ret = sys_pkey_alloc(0, 0);\n\tif (ret <= 0) {\n\t\treturn 0;\n\t}\n\tsys_pkey_free(ret);\n\treturn 1;\n}\n\nstatic inline int is_pkeys_supported(void)\n{\n\t \n\tif (!cpu_has_pkeys()) {\n\t\tdprintf1(\"SKIP: %s: no CPU support\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!kernel_has_pkeys()) {\n\t\tdprintf1(\"SKIP: %s: no kernel support\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}