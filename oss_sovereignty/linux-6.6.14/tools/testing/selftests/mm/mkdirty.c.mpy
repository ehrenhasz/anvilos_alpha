{
  "module_name": "mkdirty.c",
  "hash_id": "bda5c67fc9b2b08be63f2ed325d9697f904b4f5caaccd5adc1e5cb228d98ad93",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mkdirty.c",
  "human_readable_source": "\n \n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/mman.h>\n#include <setjmp.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <linux/userfaultfd.h>\n#include <linux/mempolicy.h>\n\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\nstatic size_t pagesize;\nstatic size_t thpsize;\nstatic int mem_fd;\nstatic int pagemap_fd;\nstatic sigjmp_buf env;\n\nstatic void signal_handler(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tsiglongjmp(env, 1);\n\tsiglongjmp(env, 2);\n}\n\nstatic void do_test_write_sigsegv(char *mem)\n{\n\tchar orig = *mem;\n\tint ret;\n\n\tif (signal(SIGSEGV, signal_handler) == SIG_ERR) {\n\t\tksft_test_result_fail(\"signal() failed\\n\");\n\t\treturn;\n\t}\n\n\tret = sigsetjmp(env, 1);\n\tif (!ret)\n\t\t*mem = orig + 1;\n\n\tif (signal(SIGSEGV, SIG_DFL) == SIG_ERR)\n\t\tksft_test_result_fail(\"signal() failed\\n\");\n\n\tksft_test_result(ret == 1 && *mem == orig,\n\t\t\t \"SIGSEGV generated, page not modified\\n\");\n}\n\nstatic char *mmap_thp_range(int prot, char **_mmap_mem, size_t *_mmap_size)\n{\n\tconst size_t mmap_size = 2 * thpsize;\n\tchar *mem, *mmap_mem;\n\n\tmmap_mem = mmap(NULL, mmap_size, prot, MAP_PRIVATE|MAP_ANON,\n\t\t\t-1, 0);\n\tif (mmap_mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn MAP_FAILED;\n\t}\n\tmem = (char *)(((uintptr_t)mmap_mem + thpsize) & ~(thpsize - 1));\n\n\tif (madvise(mem, thpsize, MADV_HUGEPAGE)) {\n\t\tksft_test_result_skip(\"MADV_HUGEPAGE failed\\n\");\n\t\tmunmap(mmap_mem, mmap_size);\n\t\treturn MAP_FAILED;\n\t}\n\n\t*_mmap_mem = mmap_mem;\n\t*_mmap_size = mmap_size;\n\treturn mem;\n}\n\nstatic void test_ptrace_write(void)\n{\n\tchar data = 1;\n\tchar *mem;\n\tint ret;\n\n\tksft_print_msg(\"[INFO] PTRACE write access\\n\");\n\n\tmem = mmap(NULL, pagesize, PROT_READ, MAP_PRIVATE|MAP_ANON, -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (*mem != 0) {\n\t\tksft_test_result_fail(\"Memory not zero\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tlseek(mem_fd, (uintptr_t) mem, SEEK_SET);\n\tret = write(mem_fd, &data, 1);\n\tif (ret != 1 || *mem != data) {\n\t\tksft_test_result_fail(\"write() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\tdo_test_write_sigsegv(mem);\nmunmap:\n\tmunmap(mem, pagesize);\n}\n\nstatic void test_ptrace_write_thp(void)\n{\n\tchar *mem, *mmap_mem;\n\tsize_t mmap_size;\n\tchar data = 1;\n\tint ret;\n\n\tksft_print_msg(\"[INFO] PTRACE write access to THP\\n\");\n\n\tmem = mmap_thp_range(PROT_READ, &mmap_mem, &mmap_size);\n\tif (mem == MAP_FAILED)\n\t\treturn;\n\n\t \n\tlseek(mem_fd, (uintptr_t) mem, SEEK_SET);\n\tret = write(mem_fd, &data, 1);\n\tif (ret != 1 || *mem != data) {\n\t\tksft_test_result_fail(\"write() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (!pagemap_is_populated(pagemap_fd, mem + thpsize - pagesize)) {\n\t\tksft_test_result_skip(\"Did not get a THP populated\\n\");\n\t\tgoto munmap;\n\t}\n\n\tdo_test_write_sigsegv(mem);\nmunmap:\n\tmunmap(mmap_mem, mmap_size);\n}\n\nstatic void test_page_migration(void)\n{\n\tchar *mem;\n\n\tksft_print_msg(\"[INFO] Page migration\\n\");\n\n\tmem = mmap(NULL, pagesize, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON,\n\t\t   -1, 0);\n\tif (mem == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemset(mem, 1, pagesize);\n\tif (mprotect(mem, pagesize, PROT_READ)) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (syscall(__NR_mbind, mem, pagesize, MPOL_LOCAL, NULL, 0x7fful,\n\t\t    MPOL_MF_MOVE)) {\n\t\tksft_test_result_skip(\"mbind() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\tdo_test_write_sigsegv(mem);\nmunmap:\n\tmunmap(mem, pagesize);\n}\n\nstatic void test_page_migration_thp(void)\n{\n\tchar *mem, *mmap_mem;\n\tsize_t mmap_size;\n\n\tksft_print_msg(\"[INFO] Page migration of THP\\n\");\n\n\tmem = mmap_thp_range(PROT_READ|PROT_WRITE, &mmap_mem, &mmap_size);\n\tif (mem == MAP_FAILED)\n\t\treturn;\n\n\t \n\tmemset(mem, 1, pagesize);\n\tif (mprotect(mem, thpsize, PROT_READ)) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (!pagemap_is_populated(pagemap_fd, mem + thpsize - pagesize)) {\n\t\tksft_test_result_skip(\"Did not get a THP populated\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (syscall(__NR_mbind, mem, thpsize, MPOL_LOCAL, NULL, 0x7fful,\n\t\t    MPOL_MF_MOVE)) {\n\t\tksft_test_result_skip(\"mbind() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\tdo_test_write_sigsegv(mem);\nmunmap:\n\tmunmap(mmap_mem, mmap_size);\n}\n\nstatic void test_pte_mapped_thp(void)\n{\n\tchar *mem, *mmap_mem;\n\tsize_t mmap_size;\n\n\tksft_print_msg(\"[INFO] PTE-mapping a THP\\n\");\n\n\tmem = mmap_thp_range(PROT_READ|PROT_WRITE, &mmap_mem, &mmap_size);\n\tif (mem == MAP_FAILED)\n\t\treturn;\n\n\t \n\tmemset(mem, 1, pagesize);\n\tif (mprotect(mem, thpsize, PROT_READ)) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (!pagemap_is_populated(pagemap_fd, mem + thpsize - pagesize)) {\n\t\tksft_test_result_skip(\"Did not get a THP populated\\n\");\n\t\tgoto munmap;\n\t}\n\n\t \n\tif (mprotect(mem + thpsize - pagesize, pagesize,\n\t\t     PROT_READ|PROT_WRITE)) {\n\t\tksft_test_result_fail(\"mprotect() failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\tdo_test_write_sigsegv(mem);\nmunmap:\n\tmunmap(mmap_mem, mmap_size);\n}\n\n#ifdef __NR_userfaultfd\nstatic void test_uffdio_copy(void)\n{\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_copy uffdio_copy;\n\tstruct uffdio_api uffdio_api;\n\tchar *dst, *src;\n\tint uffd;\n\n\tksft_print_msg(\"[INFO] UFFDIO_COPY\\n\");\n\n\tsrc = malloc(pagesize);\n\tmemset(src, 1, pagesize);\n\tdst = mmap(NULL, pagesize, PROT_READ, MAP_PRIVATE|MAP_ANON, -1, 0);\n\tif (dst == MAP_FAILED) {\n\t\tksft_test_result_fail(\"mmap() failed\\n\");\n\t\treturn;\n\t}\n\n\tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\tif (uffd < 0) {\n\t\tksft_test_result_skip(\"__NR_userfaultfd failed\\n\");\n\t\tgoto munmap;\n\t}\n\n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api) < 0) {\n\t\tksft_test_result_fail(\"UFFDIO_API failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\tuffdio_register.range.start = (unsigned long) dst;\n\tuffdio_register.range.len = pagesize;\n\tuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n\tif (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register)) {\n\t\tksft_test_result_fail(\"UFFDIO_REGISTER failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\t \n\tuffdio_copy.dst = (unsigned long) dst;\n\tuffdio_copy.src = (unsigned long) src;\n\tuffdio_copy.len = pagesize;\n\tuffdio_copy.mode = 0;\n\tif (ioctl(uffd, UFFDIO_COPY, &uffdio_copy)) {\n\t\tksft_test_result_fail(\"UFFDIO_COPY failed\\n\");\n\t\tgoto close_uffd;\n\t}\n\n\tdo_test_write_sigsegv(dst);\nclose_uffd:\n\tclose(uffd);\nmunmap:\n\tmunmap(dst, pagesize);\n\tfree(src);\n}\n#endif  \n\nint main(void)\n{\n\tint err, tests = 2;\n\n\tpagesize = getpagesize();\n\tthpsize = read_pmd_pagesize();\n\tif (thpsize) {\n\t\tksft_print_msg(\"[INFO] detected THP size: %zu KiB\\n\",\n\t\t\t       thpsize / 1024);\n\t\ttests += 3;\n\t}\n#ifdef __NR_userfaultfd\n\ttests += 1;\n#endif  \n\n\tksft_print_header();\n\tksft_set_plan(tests);\n\n\tmem_fd = open(\"/proc/self/mem\", O_RDWR);\n\tif (mem_fd < 0)\n\t\tksft_exit_fail_msg(\"opening /proc/self/mem failed\\n\");\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tif (pagemap_fd < 0)\n\t\tksft_exit_fail_msg(\"opening /proc/self/pagemap failed\\n\");\n\n\t \n\ttest_ptrace_write();\n\tif (thpsize)\n\t\ttest_ptrace_write_thp();\n\t \n\ttest_page_migration();\n\tif (thpsize)\n\t\ttest_page_migration_thp();\n\t \n\tif (thpsize)\n\t\ttest_pte_mapped_thp();\n\t \n#ifdef __NR_userfaultfd\n\ttest_uffdio_copy();\n#endif  \n\n\terr = ksft_get_fail_cnt();\n\tif (err)\n\t\tksft_exit_fail_msg(\"%d out of %d tests failed\\n\",\n\t\t\t\t   err, ksft_test_num());\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}