{
  "module_name": "split_huge_page_test.c",
  "hash_id": "1478dd2e5b3f4383145a36852b8497cdc88117289da6e1a5b37536a22c5dccdd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/split_huge_page_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <malloc.h>\n#include <stdbool.h>\n#include \"vm_util.h\"\n\nuint64_t pagesize;\nunsigned int pageshift;\nuint64_t pmd_pagesize;\n\n#define SPLIT_DEBUGFS \"/sys/kernel/debug/split_huge_pages\"\n#define INPUT_MAX 80\n\n#define PID_FMT \"%d,0x%lx,0x%lx\"\n#define PATH_FMT \"%s,0x%lx,0x%lx\"\n\n#define PFN_MASK     ((1UL<<55)-1)\n#define KPF_THP      (1UL<<22)\n\nint is_backed_by_thp(char *vaddr, int pagemap_file, int kpageflags_file)\n{\n\tuint64_t paddr;\n\tuint64_t page_flags;\n\n\tif (pagemap_file) {\n\t\tpread(pagemap_file, &paddr, sizeof(paddr),\n\t\t\t((long)vaddr >> pageshift) * sizeof(paddr));\n\n\t\tif (kpageflags_file) {\n\t\t\tpread(kpageflags_file, &page_flags, sizeof(page_flags),\n\t\t\t\t(paddr & PFN_MASK) * sizeof(page_flags));\n\n\t\t\treturn !!(page_flags & KPF_THP);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int write_file(const char *path, const char *buf, size_t buflen)\n{\n\tint fd;\n\tssize_t numwritten;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwritten = write(fd, buf, buflen - 1);\n\tclose(fd);\n\tif (numwritten < 1)\n\t\treturn 0;\n\n\treturn (unsigned int) numwritten;\n}\n\nstatic void write_debugfs(const char *fmt, ...)\n{\n\tchar input[INPUT_MAX];\n\tint ret;\n\tva_list argp;\n\n\tva_start(argp, fmt);\n\tret = vsnprintf(input, INPUT_MAX, fmt, argp);\n\tva_end(argp);\n\n\tif (ret >= INPUT_MAX) {\n\t\tprintf(\"%s: Debugfs input is too long\\n\", __func__);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!write_file(SPLIT_DEBUGFS, input, ret + 1)) {\n\t\tperror(SPLIT_DEBUGFS);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid split_pmd_thp(void)\n{\n\tchar *one_page;\n\tsize_t len = 4 * pmd_pagesize;\n\tsize_t i;\n\n\tone_page = memalign(pmd_pagesize, len);\n\n\tif (!one_page) {\n\t\tprintf(\"Fail to allocate memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmadvise(one_page, len, MADV_HUGEPAGE);\n\n\tfor (i = 0; i < len; i++)\n\t\tone_page[i] = (char)i;\n\n\tif (!check_huge_anon(one_page, 4, pmd_pagesize)) {\n\t\tprintf(\"No THP is allocated\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\twrite_debugfs(PID_FMT, getpid(), (uint64_t)one_page,\n\t\t(uint64_t)one_page + len);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (one_page[i] != (char)i) {\n\t\t\tprintf(\"%ld byte corrupted\\n\", i);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\n\tif (!check_huge_anon(one_page, 0, pmd_pagesize)) {\n\t\tprintf(\"Still AnonHugePages not split\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tprintf(\"Split huge pages successful\\n\");\n\tfree(one_page);\n}\n\nvoid split_pte_mapped_thp(void)\n{\n\tchar *one_page, *pte_mapped, *pte_mapped2;\n\tsize_t len = 4 * pmd_pagesize;\n\tuint64_t thp_size;\n\tsize_t i;\n\tconst char *pagemap_template = \"/proc/%d/pagemap\";\n\tconst char *kpageflags_proc = \"/proc/kpageflags\";\n\tchar pagemap_proc[255];\n\tint pagemap_fd;\n\tint kpageflags_fd;\n\n\tif (snprintf(pagemap_proc, 255, pagemap_template, getpid()) < 0) {\n\t\tperror(\"get pagemap proc error\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tpagemap_fd = open(pagemap_proc, O_RDONLY);\n\n\tif (pagemap_fd == -1) {\n\t\tperror(\"read pagemap:\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tkpageflags_fd = open(kpageflags_proc, O_RDONLY);\n\n\tif (kpageflags_fd == -1) {\n\t\tperror(\"read kpageflags:\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tone_page = mmap((void *)(1UL << 30), len, PROT_READ | PROT_WRITE,\n\t\t\tMAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n\tmadvise(one_page, len, MADV_HUGEPAGE);\n\n\tfor (i = 0; i < len; i++)\n\t\tone_page[i] = (char)i;\n\n\tif (!check_huge_anon(one_page, 4, pmd_pagesize)) {\n\t\tprintf(\"No THP is allocated\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tpte_mapped = mremap(one_page, pagesize, pagesize, MREMAP_MAYMOVE);\n\n\t \n\tfor (i = 1; i < 4; i++) {\n\t\tpte_mapped2 = mremap(one_page + pmd_pagesize * i + pagesize * i,\n\t\t\t\t     pagesize, pagesize,\n\t\t\t\t     MREMAP_MAYMOVE|MREMAP_FIXED,\n\t\t\t\t     pte_mapped + pagesize * i);\n\t\tif (pte_mapped2 == (char *)-1) {\n\t\t\tperror(\"mremap failed\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t \n\tthp_size = 0;\n\tfor (i = 0; i < pagesize * 4; i++)\n\t\tif (i % pagesize == 0 &&\n\t\t    is_backed_by_thp(&pte_mapped[i], pagemap_fd, kpageflags_fd))\n\t\t\tthp_size++;\n\n\tif (thp_size != 4) {\n\t\tprintf(\"Some THPs are missing during mremap\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\twrite_debugfs(PID_FMT, getpid(), (uint64_t)pte_mapped,\n\t\t      (uint64_t)pte_mapped + pagesize * 4);\n\n\t \n\tthp_size = 0;\n\tfor (i = 0; i < pagesize * 4; i++) {\n\t\tif (pte_mapped[i] != (char)i) {\n\t\t\tprintf(\"%ld byte corrupted\\n\", i);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (i % pagesize == 0 &&\n\t\t    is_backed_by_thp(&pte_mapped[i], pagemap_fd, kpageflags_fd))\n\t\t\tthp_size++;\n\t}\n\n\tif (thp_size) {\n\t\tprintf(\"Still %ld THPs not split\\n\", thp_size);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tprintf(\"Split PTE-mapped huge pages successful\\n\");\n\tmunmap(one_page, len);\n\tclose(pagemap_fd);\n\tclose(kpageflags_fd);\n}\n\nvoid split_file_backed_thp(void)\n{\n\tint status;\n\tint fd;\n\tssize_t num_written;\n\tchar tmpfs_template[] = \"/tmp/thp_split_XXXXXX\";\n\tconst char *tmpfs_loc = mkdtemp(tmpfs_template);\n\tchar testfile[INPUT_MAX];\n\tuint64_t pgoff_start = 0, pgoff_end = 1024;\n\n\tprintf(\"Please enable pr_debug in split_huge_pages_in_file() if you need more info.\\n\");\n\n\tstatus = mount(\"tmpfs\", tmpfs_loc, \"tmpfs\", 0, \"huge=always,size=4m\");\n\n\tif (status) {\n\t\tprintf(\"Unable to create a tmpfs for testing\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tstatus = snprintf(testfile, INPUT_MAX, \"%s/thp_file\", tmpfs_loc);\n\tif (status >= INPUT_MAX) {\n\t\tprintf(\"Fail to create file-backed THP split testing file\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tfd = open(testfile, O_CREAT|O_WRONLY);\n\tif (fd == -1) {\n\t\tperror(\"Cannot open testing file\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tnum_written = write(fd, tmpfs_loc, strlen(tmpfs_loc) + 1);\n\tclose(fd);\n\n\tif (num_written < 1) {\n\t\tprintf(\"Fail to write data to testing file\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\twrite_debugfs(PATH_FMT, testfile, pgoff_start, pgoff_end);\n\n\tstatus = unlink(testfile);\n\tif (status)\n\t\tperror(\"Cannot remove testing file\\n\");\n\ncleanup:\n\tstatus = umount(tmpfs_loc);\n\tif (status) {\n\t\tprintf(\"Unable to umount %s\\n\", tmpfs_loc);\n\t\texit(EXIT_FAILURE);\n\t}\n\tstatus = rmdir(tmpfs_loc);\n\tif (status) {\n\t\tperror(\"cannot remove tmp dir\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tprintf(\"file-backed THP split test done, please check dmesg for more information\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tif (geteuid() != 0) {\n\t\tprintf(\"Please run the benchmark as root\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpagesize = getpagesize();\n\tpageshift = ffs(pagesize) - 1;\n\tpmd_pagesize = read_pmd_pagesize();\n\tif (!pmd_pagesize) {\n\t\tprintf(\"Reading PMD pagesize failed\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsplit_pmd_thp();\n\tsplit_pte_mapped_thp();\n\tsplit_file_backed_thp();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}