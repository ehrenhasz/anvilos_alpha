{
  "module_name": "memfd_secret.c",
  "hash_id": "a6c93622bca352e9dad690b3fb7160e0150052b4aaefd1106e2493308f976af3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/memfd_secret.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sys/uio.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ptrace.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/capability.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\n#include \"../kselftest.h\"\n\n#define fail(fmt, ...) ksft_test_result_fail(fmt, ##__VA_ARGS__)\n#define pass(fmt, ...) ksft_test_result_pass(fmt, ##__VA_ARGS__)\n#define skip(fmt, ...) ksft_test_result_skip(fmt, ##__VA_ARGS__)\n\n#ifdef __NR_memfd_secret\n\n#define PATTERN\t0x55\n\nstatic const int prot = PROT_READ | PROT_WRITE;\nstatic const int mode = MAP_SHARED;\n\nstatic unsigned long page_size;\nstatic unsigned long mlock_limit_cur;\nstatic unsigned long mlock_limit_max;\n\nstatic int memfd_secret(unsigned int flags)\n{\n\treturn syscall(__NR_memfd_secret, flags);\n}\n\nstatic void test_file_apis(int fd)\n{\n\tchar buf[64];\n\n\tif ((read(fd, buf, sizeof(buf)) >= 0) ||\n\t    (write(fd, buf, sizeof(buf)) >= 0) ||\n\t    (pread(fd, buf, sizeof(buf), 0) >= 0) ||\n\t    (pwrite(fd, buf, sizeof(buf), 0) >= 0))\n\t\tfail(\"unexpected file IO\\n\");\n\telse\n\t\tpass(\"file IO is blocked as expected\\n\");\n}\n\nstatic void test_mlock_limit(int fd)\n{\n\tsize_t len;\n\tchar *mem;\n\n\tlen = mlock_limit_cur;\n\tif (len % page_size != 0)\n\t\tlen = (len/page_size) * page_size;\n\n\tmem = mmap(NULL, len, prot, mode, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tfail(\"unable to mmap secret memory\\n\");\n\t\treturn;\n\t}\n\tmunmap(mem, len);\n\n\tlen = mlock_limit_max * 2;\n\tmem = mmap(NULL, len, prot, mode, fd, 0);\n\tif (mem != MAP_FAILED) {\n\t\tfail(\"unexpected mlock limit violation\\n\");\n\t\tmunmap(mem, len);\n\t\treturn;\n\t}\n\n\tpass(\"mlock limit is respected\\n\");\n}\n\nstatic void try_process_vm_read(int fd, int pipefd[2])\n{\n\tstruct iovec liov, riov;\n\tchar buf[64];\n\tchar *mem;\n\n\tif (read(pipefd[0], &mem, sizeof(mem)) < 0) {\n\t\tfail(\"pipe write: %s\\n\", strerror(errno));\n\t\texit(KSFT_FAIL);\n\t}\n\n\tliov.iov_len = riov.iov_len = sizeof(buf);\n\tliov.iov_base = buf;\n\triov.iov_base = mem;\n\n\tif (process_vm_readv(getppid(), &liov, 1, &riov, 1, 0) < 0) {\n\t\tif (errno == ENOSYS)\n\t\t\texit(KSFT_SKIP);\n\t\texit(KSFT_PASS);\n\t}\n\n\texit(KSFT_FAIL);\n}\n\nstatic void try_ptrace(int fd, int pipefd[2])\n{\n\tpid_t ppid = getppid();\n\tint status;\n\tchar *mem;\n\tlong ret;\n\n\tif (read(pipefd[0], &mem, sizeof(mem)) < 0) {\n\t\tperror(\"pipe write\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\tret = ptrace(PTRACE_ATTACH, ppid, 0, 0);\n\tif (ret) {\n\t\tperror(\"ptrace_attach\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\tret = waitpid(ppid, &status, WUNTRACED);\n\tif ((ret != ppid) || !(WIFSTOPPED(status))) {\n\t\tfprintf(stderr, \"weird waitppid result %ld stat %x\\n\",\n\t\t\tret, status);\n\t\texit(KSFT_FAIL);\n\t}\n\n\tif (ptrace(PTRACE_PEEKDATA, ppid, mem, 0))\n\t\texit(KSFT_PASS);\n\n\texit(KSFT_FAIL);\n}\n\nstatic void check_child_status(pid_t pid, const char *name)\n{\n\tint status;\n\n\twaitpid(pid, &status, 0);\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == KSFT_SKIP) {\n\t\tskip(\"%s is not supported\\n\", name);\n\t\treturn;\n\t}\n\n\tif ((WIFEXITED(status) && WEXITSTATUS(status) == KSFT_PASS) ||\n\t    WIFSIGNALED(status)) {\n\t\tpass(\"%s is blocked as expected\\n\", name);\n\t\treturn;\n\t}\n\n\tfail(\"%s: unexpected memory access\\n\", name);\n}\n\nstatic void test_remote_access(int fd, const char *name,\n\t\t\t       void (*func)(int fd, int pipefd[2]))\n{\n\tint pipefd[2];\n\tpid_t pid;\n\tchar *mem;\n\n\tif (pipe(pipefd)) {\n\t\tfail(\"pipe failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tfail(\"fork failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (pid == 0) {\n\t\tfunc(fd, pipefd);\n\t\treturn;\n\t}\n\n\tmem = mmap(NULL, page_size, prot, mode, fd, 0);\n\tif (mem == MAP_FAILED) {\n\t\tfail(\"Unable to mmap secret memory\\n\");\n\t\treturn;\n\t}\n\n\tftruncate(fd, page_size);\n\tmemset(mem, PATTERN, page_size);\n\n\tif (write(pipefd[1], &mem, sizeof(mem)) < 0) {\n\t\tfail(\"pipe write: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tcheck_child_status(pid, name);\n}\n\nstatic void test_process_vm_read(int fd)\n{\n\ttest_remote_access(fd, \"process_vm_read\", try_process_vm_read);\n}\n\nstatic void test_ptrace(int fd)\n{\n\ttest_remote_access(fd, \"ptrace\", try_ptrace);\n}\n\nstatic int set_cap_limits(rlim_t max)\n{\n\tstruct rlimit new;\n\tcap_t cap = cap_init();\n\n\tnew.rlim_cur = max;\n\tnew.rlim_max = max;\n\tif (setrlimit(RLIMIT_MEMLOCK, &new)) {\n\t\tperror(\"setrlimit() returns error\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (cap_set_proc(cap)) {\n\t\tperror(\"cap_set_proc() returns error\");\n\t\treturn -2;\n\t}\n\n\treturn 0;\n}\n\nstatic void prepare(void)\n{\n\tstruct rlimit rlim;\n\n\tpage_size = sysconf(_SC_PAGE_SIZE);\n\tif (!page_size)\n\t\tksft_exit_fail_msg(\"Failed to get page size %s\\n\",\n\t\t\t\t   strerror(errno));\n\n\tif (getrlimit(RLIMIT_MEMLOCK, &rlim))\n\t\tksft_exit_fail_msg(\"Unable to detect mlock limit: %s\\n\",\n\t\t\t\t   strerror(errno));\n\n\tmlock_limit_cur = rlim.rlim_cur;\n\tmlock_limit_max = rlim.rlim_max;\n\n\tprintf(\"page_size: %ld, mlock.soft: %ld, mlock.hard: %ld\\n\",\n\t       page_size, mlock_limit_cur, mlock_limit_max);\n\n\tif (page_size > mlock_limit_cur)\n\t\tmlock_limit_cur = page_size;\n\tif (page_size > mlock_limit_max)\n\t\tmlock_limit_max = page_size;\n\n\tif (set_cap_limits(mlock_limit_max))\n\t\tksft_exit_fail_msg(\"Unable to set mlock limit: %s\\n\",\n\t\t\t\t   strerror(errno));\n}\n\n#define NUM_TESTS 4\n\nint main(int argc, char *argv[])\n{\n\tint fd;\n\n\tprepare();\n\n\tksft_print_header();\n\tksft_set_plan(NUM_TESTS);\n\n\tfd = memfd_secret(0);\n\tif (fd < 0) {\n\t\tif (errno == ENOSYS)\n\t\t\tksft_exit_skip(\"memfd_secret is not supported\\n\");\n\t\telse\n\t\t\tksft_exit_fail_msg(\"memfd_secret failed: %s\\n\",\n\t\t\t\t\t   strerror(errno));\n\t}\n\n\ttest_mlock_limit(fd);\n\ttest_file_apis(fd);\n\ttest_process_vm_read(fd);\n\ttest_ptrace(fd);\n\n\tclose(fd);\n\n\tksft_finished();\n}\n\n#else  \n\nint main(int argc, char *argv[])\n{\n\tprintf(\"skip: skipping memfd_secret test (missing __NR_memfd_secret)\\n\");\n\treturn KSFT_SKIP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}