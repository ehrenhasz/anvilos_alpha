{
  "module_name": "virtual_address_range.c",
  "hash_id": "16aeb19c08e746b332dec444c34716ca6df09434f0124b829b69fe117e5750fa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/virtual_address_range.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n\n \n\n#define SZ_1GB\t(1024 * 1024 * 1024UL)\n#define SZ_1TB\t(1024 * 1024 * 1024 * 1024UL)\n\n#define MAP_CHUNK_SIZE\tSZ_1GB\n\n \n\n#define NR_CHUNKS_128TB   ((128 * SZ_1TB) / MAP_CHUNK_SIZE)  \n#define NR_CHUNKS_256TB   (NR_CHUNKS_128TB * 2UL)\n#define NR_CHUNKS_384TB   (NR_CHUNKS_128TB * 3UL)\n#define NR_CHUNKS_3840TB  (NR_CHUNKS_128TB * 30UL)\n\n#define ADDR_MARK_128TB  (1UL << 47)  \n#define ADDR_MARK_256TB  (1UL << 48)  \n\n#ifdef __aarch64__\n#define HIGH_ADDR_MARK  ADDR_MARK_256TB\n#define HIGH_ADDR_SHIFT 49\n#define NR_CHUNKS_LOW   NR_CHUNKS_256TB\n#define NR_CHUNKS_HIGH  NR_CHUNKS_3840TB\n#else\n#define HIGH_ADDR_MARK  ADDR_MARK_128TB\n#define HIGH_ADDR_SHIFT 48\n#define NR_CHUNKS_LOW   NR_CHUNKS_128TB\n#define NR_CHUNKS_HIGH  NR_CHUNKS_384TB\n#endif\n\nstatic char *hind_addr(void)\n{\n\tint bits = HIGH_ADDR_SHIFT + rand() % (63 - HIGH_ADDR_SHIFT);\n\n\treturn (char *) (1UL << bits);\n}\n\nstatic int validate_addr(char *ptr, int high_addr)\n{\n\tunsigned long addr = (unsigned long) ptr;\n\n\tif (high_addr) {\n\t\tif (addr < HIGH_ADDR_MARK) {\n\t\t\tprintf(\"Bad address %lx\\n\", addr);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (addr > HIGH_ADDR_MARK) {\n\t\tprintf(\"Bad address %lx\\n\", addr);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int validate_lower_address_hint(void)\n{\n\tchar *ptr;\n\n\tptr = mmap((void *) (1UL << 45), MAP_CHUNK_SIZE, PROT_READ |\n\t\t\tPROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\tif (ptr == MAP_FAILED)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *ptr[NR_CHUNKS_LOW];\n\tchar **hptr;\n\tchar *hint;\n\tunsigned long i, lchunks, hchunks;\n\n\tfor (i = 0; i < NR_CHUNKS_LOW; i++) {\n\t\tptr[i] = mmap(NULL, MAP_CHUNK_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\t\tif (ptr[i] == MAP_FAILED) {\n\t\t\tif (validate_lower_address_hint())\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (validate_addr(ptr[i], 0))\n\t\t\treturn 1;\n\t}\n\tlchunks = i;\n\thptr = (char **) calloc(NR_CHUNKS_HIGH, sizeof(char *));\n\tif (hptr == NULL)\n\t\treturn 1;\n\n\tfor (i = 0; i < NR_CHUNKS_HIGH; i++) {\n\t\thint = hind_addr();\n\t\thptr[i] = mmap(hint, MAP_CHUNK_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\t\tif (hptr[i] == MAP_FAILED)\n\t\t\tbreak;\n\n\t\tif (validate_addr(hptr[i], 1))\n\t\t\treturn 1;\n\t}\n\thchunks = i;\n\n\tfor (i = 0; i < lchunks; i++)\n\t\tmunmap(ptr[i], MAP_CHUNK_SIZE);\n\n\tfor (i = 0; i < hchunks; i++)\n\t\tmunmap(hptr[i], MAP_CHUNK_SIZE);\n\n\tfree(hptr);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}