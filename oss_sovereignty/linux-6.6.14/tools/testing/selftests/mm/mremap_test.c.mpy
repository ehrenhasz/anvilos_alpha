{
  "module_name": "mremap_test.c",
  "hash_id": "43bb25ec8ecc1f805a2f20432cd2fc4a1f804a5d60b0271860119879cf6b814d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mremap_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <time.h>\n#include <stdbool.h>\n\n#include \"../kselftest.h\"\n\n#define EXPECT_SUCCESS 0\n#define EXPECT_FAILURE 1\n#define NON_OVERLAPPING 0\n#define OVERLAPPING 1\n#define NS_PER_SEC 1000000000ULL\n#define VALIDATION_DEFAULT_THRESHOLD 4\t \n#define VALIDATION_NO_THRESHOLD 0\t \n\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\nstruct config {\n\tunsigned long long src_alignment;\n\tunsigned long long dest_alignment;\n\tunsigned long long region_size;\n\tint overlapping;\n};\n\nstruct test {\n\tconst char *name;\n\tstruct config config;\n\tint expect_failure;\n};\n\nenum {\n\t_1KB = 1ULL << 10,\t \n\t_4KB = 4ULL << 10,\n\t_8KB = 8ULL << 10,\n\t_1MB = 1ULL << 20,\n\t_2MB = 2ULL << 20,\n\t_4MB = 4ULL << 20,\n\t_1GB = 1ULL << 30,\n\t_2GB = 2ULL << 30,\n\tPMD = _2MB,\n\tPUD = _1GB,\n};\n\n#define PTE page_size\n\n#define MAKE_TEST(source_align, destination_align, size,\t\\\n\t\t  overlaps, should_fail, test_name)\t\t\\\n(struct test){\t\t\t\t\t\t\t\\\n\t.name = test_name,\t\t\t\t\t\\\n\t.config = {\t\t\t\t\t\t\\\n\t\t.src_alignment = source_align,\t\t\t\\\n\t\t.dest_alignment = destination_align,\t\t\\\n\t\t.region_size = size,\t\t\t\t\\\n\t\t.overlapping = overlaps,\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.expect_failure = should_fail\t\t\t\t\\\n}\n\n \nstatic bool is_remap_region_valid(void *addr, unsigned long long size)\n{\n\tvoid *remap_addr = NULL;\n\tbool ret = true;\n\n\t \n\tremap_addr = mmap(addr, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\t MAP_FIXED_NOREPLACE | MAP_ANONYMOUS | MAP_SHARED,\n\t\t\t\t\t -1, 0);\n\n\tif (remap_addr == MAP_FAILED) {\n\t\tif (errno == EEXIST)\n\t\t\tret = false;\n\t} else {\n\t\tmunmap(remap_addr, size);\n\t}\n\n\treturn ret;\n}\n\n \nstatic unsigned long long get_mmap_min_addr(void)\n{\n\tFILE *fp;\n\tint n_matched;\n\tstatic unsigned long long addr;\n\n\tif (addr)\n\t\treturn addr;\n\n\tfp = fopen(\"/proc/sys/vm/mmap_min_addr\", \"r\");\n\tif (fp == NULL) {\n\t\tksft_print_msg(\"Failed to open /proc/sys/vm/mmap_min_addr: %s\\n\",\n\t\t\tstrerror(errno));\n\t\texit(KSFT_SKIP);\n\t}\n\n\tn_matched = fscanf(fp, \"%llu\", &addr);\n\tif (n_matched != 1) {\n\t\tksft_print_msg(\"Failed to read /proc/sys/vm/mmap_min_addr: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tfclose(fp);\n\t\texit(KSFT_SKIP);\n\t}\n\n\tfclose(fp);\n\treturn addr;\n}\n\n \nstatic bool is_range_mapped(FILE *maps_fp, void *start, void *end)\n{\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tbool success = false;\n\n\trewind(maps_fp);\n\n\twhile (getline(&line, &len, maps_fp) != -1) {\n\t\tchar *first = strtok(line, \"- \");\n\t\tvoid *first_val = (void *)strtol(first, NULL, 16);\n\t\tchar *second = strtok(NULL, \"- \");\n\t\tvoid *second_val = (void *) strtol(second, NULL, 16);\n\n\t\tif (first_val <= start && second_val >= end) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn success;\n}\n\n \nstatic void mremap_expand_merge(FILE *maps_fp, unsigned long page_size)\n{\n\tchar *test_name = \"mremap expand merge\";\n\tbool success = false;\n\tchar *remap, *start;\n\n\tstart = mmap(NULL, 3 * page_size, PROT_READ | PROT_WRITE,\n\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\tif (start == MAP_FAILED) {\n\t\tksft_print_msg(\"mmap failed: %s\\n\", strerror(errno));\n\t\tgoto out;\n\t}\n\n\tmunmap(start + page_size, page_size);\n\tremap = mremap(start, page_size, 2 * page_size, 0);\n\tif (remap == MAP_FAILED) {\n\t\tksft_print_msg(\"mremap failed: %s\\n\", strerror(errno));\n\t\tmunmap(start, page_size);\n\t\tmunmap(start + 2 * page_size, page_size);\n\t\tgoto out;\n\t}\n\n\tsuccess = is_range_mapped(maps_fp, start, start + 3 * page_size);\n\tmunmap(start, 3 * page_size);\n\nout:\n\tif (success)\n\t\tksft_test_result_pass(\"%s\\n\", test_name);\n\telse\n\t\tksft_test_result_fail(\"%s\\n\", test_name);\n}\n\n \nstatic void mremap_expand_merge_offset(FILE *maps_fp, unsigned long page_size)\n{\n\n\tchar *test_name = \"mremap expand merge offset\";\n\tbool success = false;\n\tchar *remap, *start;\n\n\tstart = mmap(NULL, 3 * page_size, PROT_READ | PROT_WRITE,\n\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\tif (start == MAP_FAILED) {\n\t\tksft_print_msg(\"mmap failed: %s\\n\", strerror(errno));\n\t\tgoto out;\n\t}\n\n\t \n\tmunmap(start + 2 * page_size, page_size);\n\tremap = mremap(start + page_size, page_size, 2 * page_size, 0);\n\tif (remap == MAP_FAILED) {\n\t\tksft_print_msg(\"mremap failed: %s\\n\", strerror(errno));\n\t\tmunmap(start, 2 * page_size);\n\t\tgoto out;\n\t}\n\n\tsuccess = is_range_mapped(maps_fp, start, start + 3 * page_size);\n\tmunmap(start, 3 * page_size);\n\nout:\n\tif (success)\n\t\tksft_test_result_pass(\"%s\\n\", test_name);\n\telse\n\t\tksft_test_result_fail(\"%s\\n\", test_name);\n}\n\n \nstatic void *get_source_mapping(struct config c)\n{\n\tunsigned long long addr = 0ULL;\n\tvoid *src_addr = NULL;\n\tunsigned long long mmap_min_addr;\n\n\tmmap_min_addr = get_mmap_min_addr();\n\nretry:\n\taddr += c.src_alignment;\n\tif (addr < mmap_min_addr)\n\t\tgoto retry;\n\n\tsrc_addr = mmap((void *) addr, c.region_size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_FIXED_NOREPLACE | MAP_ANONYMOUS | MAP_SHARED,\n\t\t\t\t\t-1, 0);\n\tif (src_addr == MAP_FAILED) {\n\t\tif (errno == EPERM || errno == EEXIST)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\t \n\tif (((unsigned long long) src_addr & (c.src_alignment - 1)) ||\n\t\t\t!((unsigned long long) src_addr & c.src_alignment)) {\n\t\tmunmap(src_addr, c.region_size);\n\t\tgoto retry;\n\t}\n\n\tif (!src_addr)\n\t\tgoto error;\n\n\treturn src_addr;\nerror:\n\tksft_print_msg(\"Failed to map source region: %s\\n\",\n\t\t\tstrerror(errno));\n\treturn NULL;\n}\n\n \nstatic long long remap_region(struct config c, unsigned int threshold_mb,\n\t\t\t      char pattern_seed)\n{\n\tvoid *addr, *src_addr, *dest_addr;\n\tunsigned long long i;\n\tstruct timespec t_start = {0, 0}, t_end = {0, 0};\n\tlong long  start_ns, end_ns, align_mask, ret, offset;\n\tunsigned long long threshold;\n\n\tif (threshold_mb == VALIDATION_NO_THRESHOLD)\n\t\tthreshold = c.region_size;\n\telse\n\t\tthreshold = MIN(threshold_mb * _1MB, c.region_size);\n\n\tsrc_addr = get_source_mapping(c);\n\tif (!src_addr) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tsrand(pattern_seed);\n\tfor (i = 0; i < threshold; i++)\n\t\tmemset((char *) src_addr + i, (char) rand(), 1);\n\n\t \n\talign_mask = ~(c.dest_alignment - 1);\n\t \n\toffset = (c.overlapping) ? -c.dest_alignment : c.dest_alignment;\n\taddr = (void *) (((unsigned long long) src_addr + c.region_size\n\t\t\t  + offset) & align_mask);\n\n\t \n\tif (!((unsigned long long) addr & c.dest_alignment))\n\t\taddr = (void *) ((unsigned long long) addr | c.dest_alignment);\n\n\t \n\twhile (!is_remap_region_valid(addr, c.region_size) && !c.overlapping) {\n\t\t \n\t\tif (addr + c.dest_alignment < addr) {\n\t\t\tksft_print_msg(\"Couldn't find a valid region to remap to\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\taddr += c.dest_alignment;\n\t}\n\n\tclock_gettime(CLOCK_MONOTONIC, &t_start);\n\tdest_addr = mremap(src_addr, c.region_size, c.region_size,\n\t\t\t\t\t  MREMAP_MAYMOVE|MREMAP_FIXED, (char *) addr);\n\tclock_gettime(CLOCK_MONOTONIC, &t_end);\n\n\tif (dest_addr == MAP_FAILED) {\n\t\tksft_print_msg(\"mremap failed: %s\\n\", strerror(errno));\n\t\tret = -1;\n\t\tgoto clean_up_src;\n\t}\n\n\t \n\tsrand(pattern_seed);\n\tfor (i = 0; i < threshold; i++) {\n\t\tchar c = (char) rand();\n\n\t\tif (((char *) dest_addr)[i] != c) {\n\t\t\tksft_print_msg(\"Data after remap doesn't match at offset %d\\n\",\n\t\t\t\t       i);\n\t\t\tksft_print_msg(\"Expected: %#x\\t Got: %#x\\n\", c & 0xff,\n\t\t\t\t\t((char *) dest_addr)[i] & 0xff);\n\t\t\tret = -1;\n\t\t\tgoto clean_up_dest;\n\t\t}\n\t}\n\n\tstart_ns = t_start.tv_sec * NS_PER_SEC + t_start.tv_nsec;\n\tend_ns = t_end.tv_sec * NS_PER_SEC + t_end.tv_nsec;\n\tret = end_ns - start_ns;\n\n \nclean_up_dest:\n\tmunmap(dest_addr, c.region_size);\nclean_up_src:\n\tmunmap(src_addr, c.region_size);\nout:\n\treturn ret;\n}\n\nstatic void run_mremap_test_case(struct test test_case, int *failures,\n\t\t\t\t unsigned int threshold_mb,\n\t\t\t\t unsigned int pattern_seed)\n{\n\tlong long remap_time = remap_region(test_case.config, threshold_mb,\n\t\t\t\t\t    pattern_seed);\n\n\tif (remap_time < 0) {\n\t\tif (test_case.expect_failure)\n\t\t\tksft_test_result_xfail(\"%s\\n\\tExpected mremap failure\\n\",\n\t\t\t\t\t      test_case.name);\n\t\telse {\n\t\t\tksft_test_result_fail(\"%s\\n\", test_case.name);\n\t\t\t*failures += 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (threshold_mb == VALIDATION_NO_THRESHOLD ||\n\t\t    test_case.config.region_size <= threshold_mb * _1MB)\n\t\t\tksft_test_result_pass(\"%s\\n\\tmremap time: %12lldns\\n\",\n\t\t\t\t\t      test_case.name, remap_time);\n\t\telse\n\t\t\tksft_test_result_pass(\"%s\\n\", test_case.name);\n\t}\n}\n\nstatic void usage(const char *cmd)\n{\n\tfprintf(stderr,\n\t\t\"Usage: %s [[-t <threshold_mb>] [-p <pattern_seed>]]\\n\"\n\t\t\"-t\\t only validate threshold_mb of the remapped region\\n\"\n\t\t\"  \\t if 0 is supplied no threshold is used; all tests\\n\"\n\t\t\"  \\t are run and remapped regions validated fully.\\n\"\n\t\t\"  \\t The default threshold used is 4MB.\\n\"\n\t\t\"-p\\t provide a seed to generate the random pattern for\\n\"\n\t\t\"  \\t validating the remapped region.\\n\", cmd);\n}\n\nstatic int parse_args(int argc, char **argv, unsigned int *threshold_mb,\n\t\t      unsigned int *pattern_seed)\n{\n\tconst char *optstr = \"t:p:\";\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, optstr)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\t*threshold_mb = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t*pattern_seed = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (optind < argc) {\n\t\tusage(argv[0]);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#define MAX_TEST 13\n#define MAX_PERF_TEST 3\nint main(int argc, char **argv)\n{\n\tint failures = 0;\n\tint i, run_perf_tests;\n\tunsigned int threshold_mb = VALIDATION_DEFAULT_THRESHOLD;\n\tunsigned int pattern_seed;\n\tint num_expand_tests = 2;\n\tstruct test test_cases[MAX_TEST];\n\tstruct test perf_test_cases[MAX_PERF_TEST];\n\tint page_size;\n\ttime_t t;\n\tFILE *maps_fp;\n\n\tpattern_seed = (unsigned int) time(&t);\n\n\tif (parse_args(argc, argv, &threshold_mb, &pattern_seed) < 0)\n\t\texit(EXIT_FAILURE);\n\n\tksft_print_msg(\"Test configs:\\n\\tthreshold_mb=%u\\n\\tpattern_seed=%u\\n\\n\",\n\t\t       threshold_mb, pattern_seed);\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\t \n\ttest_cases[0] =\tMAKE_TEST(page_size, page_size, page_size,\n\t\t\t\t  OVERLAPPING, EXPECT_FAILURE,\n\t\t\t\t  \"mremap - Source and Destination Regions Overlapping\");\n\n\ttest_cases[1] = MAKE_TEST(page_size, page_size/4, page_size,\n\t\t\t\t  NON_OVERLAPPING, EXPECT_FAILURE,\n\t\t\t\t  \"mremap - Destination Address Misaligned (1KB-aligned)\");\n\ttest_cases[2] = MAKE_TEST(page_size/4, page_size, page_size,\n\t\t\t\t  NON_OVERLAPPING, EXPECT_FAILURE,\n\t\t\t\t  \"mremap - Source Address Misaligned (1KB-aligned)\");\n\n\t \n\ttest_cases[3] = MAKE_TEST(PTE, PTE, PTE * 2,\n\t\t\t\t  NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"8KB mremap - Source PTE-aligned, Destination PTE-aligned\");\n\n\t \n\ttest_cases[4] = MAKE_TEST(_1MB, PTE, _2MB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"2MB mremap - Source 1MB-aligned, Destination PTE-aligned\");\n\ttest_cases[5] = MAKE_TEST(_1MB, _1MB, _2MB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"2MB mremap - Source 1MB-aligned, Destination 1MB-aligned\");\n\n\t \n\ttest_cases[6] = MAKE_TEST(PMD, PTE, _4MB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"4MB mremap - Source PMD-aligned, Destination PTE-aligned\");\n\ttest_cases[7] =\tMAKE_TEST(PMD, _1MB, _4MB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"4MB mremap - Source PMD-aligned, Destination 1MB-aligned\");\n\ttest_cases[8] = MAKE_TEST(PMD, PMD, _4MB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"4MB mremap - Source PMD-aligned, Destination PMD-aligned\");\n\n\t \n\ttest_cases[9] = MAKE_TEST(PUD, PTE, _2GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t  \"2GB mremap - Source PUD-aligned, Destination PTE-aligned\");\n\ttest_cases[10] = MAKE_TEST(PUD, _1MB, _2GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t   \"2GB mremap - Source PUD-aligned, Destination 1MB-aligned\");\n\ttest_cases[11] = MAKE_TEST(PUD, PMD, _2GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t   \"2GB mremap - Source PUD-aligned, Destination PMD-aligned\");\n\ttest_cases[12] = MAKE_TEST(PUD, PUD, _2GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t   \"2GB mremap - Source PUD-aligned, Destination PUD-aligned\");\n\n\tperf_test_cases[0] =  MAKE_TEST(page_size, page_size, _1GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t\t\"1GB mremap - Source PTE-aligned, Destination PTE-aligned\");\n\t \n\tperf_test_cases[1] = MAKE_TEST(PMD, PMD, _1GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t       \"1GB mremap - Source PMD-aligned, Destination PMD-aligned\");\n\tperf_test_cases[2] = MAKE_TEST(PUD, PUD, _1GB, NON_OVERLAPPING, EXPECT_SUCCESS,\n\t\t\t\t       \"1GB mremap - Source PUD-aligned, Destination PUD-aligned\");\n\n\trun_perf_tests =  (threshold_mb == VALIDATION_NO_THRESHOLD) ||\n\t\t\t\t(threshold_mb * _1MB >= _1GB);\n\n\tksft_set_plan(ARRAY_SIZE(test_cases) + (run_perf_tests ?\n\t\t      ARRAY_SIZE(perf_test_cases) : 0) + num_expand_tests);\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++)\n\t\trun_mremap_test_case(test_cases[i], &failures, threshold_mb,\n\t\t\t\t     pattern_seed);\n\n\tmaps_fp = fopen(\"/proc/self/maps\", \"r\");\n\n\tif (maps_fp == NULL) {\n\t\tksft_print_msg(\"Failed to read /proc/self/maps: %s\\n\", strerror(errno));\n\t\texit(KSFT_FAIL);\n\t}\n\n\tmremap_expand_merge(maps_fp, page_size);\n\tmremap_expand_merge_offset(maps_fp, page_size);\n\n\tfclose(maps_fp);\n\n\tif (run_perf_tests) {\n\t\tksft_print_msg(\"\\n%s\\n\",\n\t\t \"mremap HAVE_MOVE_PMD/PUD optimization time comparison for 1GB region:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(perf_test_cases); i++)\n\t\t\trun_mremap_test_case(perf_test_cases[i], &failures,\n\t\t\t\t\t     threshold_mb, pattern_seed);\n\t}\n\n\tif (failures > 0)\n\t\tksft_exit_fail();\n\telse\n\t\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}