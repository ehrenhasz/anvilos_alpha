{
  "module_name": "thuge-gen.c",
  "hash_id": "fcb0778233d62ddc38abe3fcaf16f619f3c09218f44e1edae0319d36637d31ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/thuge-gen.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE 1\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <glob.h>\n#include <assert.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include \"vm_util.h\"\n\n#define err(x) perror(x), exit(1)\n\n#define MAP_HUGE_2MB    (21 << MAP_HUGE_SHIFT)\n#define MAP_HUGE_1GB    (30 << MAP_HUGE_SHIFT)\n#define MAP_HUGE_SHIFT  26\n#define MAP_HUGE_MASK   0x3f\n#if !defined(MAP_HUGETLB)\n#define MAP_HUGETLB\t0x40000\n#endif\n\n#define SHM_HUGETLB     04000    \n#define SHM_HUGE_SHIFT  26\n#define SHM_HUGE_MASK   0x3f\n#define SHM_HUGE_2MB    (21 << SHM_HUGE_SHIFT)\n#define SHM_HUGE_1GB    (30 << SHM_HUGE_SHIFT)\n\n#define NUM_PAGESIZES   5\n\n#define NUM_PAGES 4\n\n#define Dprintf(fmt...) \n\nunsigned long page_sizes[NUM_PAGESIZES];\nint num_page_sizes;\n\nint ilog2(unsigned long v)\n{\n\tint l = 0;\n\twhile ((1UL << l) < v)\n\t\tl++;\n\treturn l;\n}\n\nvoid find_pagesizes(void)\n{\n\tglob_t g;\n\tint i;\n\tglob(\"/sys/kernel/mm/hugepages/hugepages-*kB\", 0, NULL, &g);\n\tassert(g.gl_pathc <= NUM_PAGESIZES);\n\tfor (i = 0; i < g.gl_pathc; i++) {\n\t\tsscanf(g.gl_pathv[i], \"/sys/kernel/mm/hugepages/hugepages-%lukB\",\n\t\t\t\t&page_sizes[i]);\n\t\tpage_sizes[i] <<= 10;\n\t\tprintf(\"Found %luMB\\n\", page_sizes[i] >> 20);\n\t}\n\tnum_page_sizes = g.gl_pathc;\n\tglobfree(&g);\n}\n\nvoid show(unsigned long ps)\n{\n\tchar buf[100];\n\tif (ps == getpagesize())\n\t\treturn;\n\tprintf(\"%luMB: \", ps >> 20);\n\tfflush(stdout);\n\tsnprintf(buf, sizeof buf,\n\t\t\"cat /sys/kernel/mm/hugepages/hugepages-%lukB/free_hugepages\",\n\t\tps >> 10);\n\tsystem(buf);\n}\n\nunsigned long read_sysfs(int warn, char *fmt, ...)\n{\n\tchar *line = NULL;\n\tsize_t linelen = 0;\n\tchar buf[100];\n\tFILE *f;\n\tva_list ap;\n\tunsigned long val = 0;\n\n\tva_start(ap, fmt);\n\tvsnprintf(buf, sizeof buf, fmt, ap);\n\tva_end(ap);\n\n\tf = fopen(buf, \"r\");\n\tif (!f) {\n\t\tif (warn)\n\t\t\tprintf(\"missing %s\\n\", buf);\n\t\treturn 0;\n\t}\n\tif (getline(&line, &linelen, f) > 0) {\n\t\tsscanf(line, \"%lu\", &val);\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn val;\n}\n\nunsigned long read_free(unsigned long ps)\n{\n\treturn read_sysfs(ps != getpagesize(),\n\t\t\t\"/sys/kernel/mm/hugepages/hugepages-%lukB/free_hugepages\",\n\t\t\tps >> 10);\n}\n\nvoid test_mmap(unsigned long size, unsigned flags)\n{\n\tchar *map;\n\tunsigned long before, after;\n\tint err;\n\n\tbefore = read_free(size);\n\tmap = mmap(NULL, size*NUM_PAGES, PROT_READ|PROT_WRITE,\n\t\t\tMAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB|flags, -1, 0);\n\n\tif (map == (char *)-1) err(\"mmap\");\n\tmemset(map, 0xff, size*NUM_PAGES);\n\tafter = read_free(size);\n\tDprintf(\"before %lu after %lu diff %ld size %lu\\n\",\n\t\tbefore, after, before - after, size);\n\tassert(size == getpagesize() || (before - after) == NUM_PAGES);\n\tshow(size);\n\terr = munmap(map, size * NUM_PAGES);\n\tassert(!err);\n}\n\nvoid test_shmget(unsigned long size, unsigned flags)\n{\n\tint id;\n\tunsigned long before, after;\n\tint err;\n\n\tbefore = read_free(size);\n\tid = shmget(IPC_PRIVATE, size * NUM_PAGES, IPC_CREAT|0600|flags);\n\tif (id < 0) err(\"shmget\");\n\n\tstruct shm_info i;\n\tif (shmctl(id, SHM_INFO, (void *)&i) < 0) err(\"shmctl\");\n\tDprintf(\"alloc %lu res %lu\\n\", i.shm_tot, i.shm_rss);\n\n\n\tDprintf(\"id %d\\n\", id);\n\tchar *map = shmat(id, NULL, 0600);\n\tif (map == (char*)-1) err(\"shmat\");\n\n\tshmctl(id, IPC_RMID, NULL);\n\n\tmemset(map, 0xff, size*NUM_PAGES);\n\tafter = read_free(size);\n\n\tDprintf(\"before %lu after %lu diff %ld size %lu\\n\",\n\t\tbefore, after, before - after, size);\n\tassert(size == getpagesize() || (before - after) == NUM_PAGES);\n\tshow(size);\n\terr = shmdt(map);\n\tassert(!err);\n}\n\nvoid sanity_checks(void)\n{\n\tint i;\n\tunsigned long largest = getpagesize();\n\n\tfor (i = 0; i < num_page_sizes; i++) {\n\t\tif (page_sizes[i] > largest)\n\t\t\tlargest = page_sizes[i];\n\n\t\tif (read_free(page_sizes[i]) < NUM_PAGES) {\n\t\t\tprintf(\"Not enough huge pages for page size %lu MB, need %u\\n\",\n\t\t\t\tpage_sizes[i] >> 20,\n\t\t\t\tNUM_PAGES);\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif (read_sysfs(0, \"/proc/sys/kernel/shmmax\") < NUM_PAGES * largest) {\n\t\tprintf(\"Please do echo %lu > /proc/sys/kernel/shmmax\", largest * NUM_PAGES);\n\t\texit(0);\n\t}\n\n#if defined(__x86_64__)\n\tif (largest != 1U<<30) {\n\t\tprintf(\"No GB pages available on x86-64\\n\"\n\t\t       \"Please boot with hugepagesz=1G hugepages=%d\\n\", NUM_PAGES);\n\t\texit(0);\n\t}\n#endif\n}\n\nint main(void)\n{\n\tint i;\n\tunsigned default_hps = default_huge_page_size();\n\n\tfind_pagesizes();\n\n\tsanity_checks();\n\n\tfor (i = 0; i < num_page_sizes; i++) {\n\t\tunsigned long ps = page_sizes[i];\n\t\tint arg = ilog2(ps) << MAP_HUGE_SHIFT;\n\t\tprintf(\"Testing %luMB mmap with shift %x\\n\", ps >> 20, arg);\n\t\ttest_mmap(ps, MAP_HUGETLB | arg);\n\t}\n\tprintf(\"Testing default huge mmap\\n\");\n\ttest_mmap(default_hps, MAP_HUGETLB);\n\n\tputs(\"Testing non-huge shmget\");\n\ttest_shmget(getpagesize(), 0);\n\n\tfor (i = 0; i < num_page_sizes; i++) {\n\t\tunsigned long ps = page_sizes[i];\n\t\tint arg = ilog2(ps) << SHM_HUGE_SHIFT;\n\t\tprintf(\"Testing %luMB shmget with shift %x\\n\", ps >> 20, arg);\n\t\ttest_shmget(ps, SHM_HUGETLB | arg);\n\t}\n\tputs(\"default huge shmget\");\n\ttest_shmget(default_hps, SHM_HUGETLB);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}