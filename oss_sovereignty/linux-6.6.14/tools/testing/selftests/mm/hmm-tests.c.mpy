{
  "module_name": "hmm-tests.c",
  "hash_id": "eed84716bf67c06e922959f1b09dfa8a4512aeee0527771cd888f5d2f4d4cd65",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/hmm-tests.c",
  "human_readable_source": "\n \n\n#include \"../kselftest_harness.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <strings.h>\n#include <time.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n\n\n \n#include <lib/test_hmm_uapi.h>\n#include <mm/gup_test.h>\n\nstruct hmm_buffer {\n\tvoid\t\t*ptr;\n\tvoid\t\t*mirror;\n\tunsigned long\tsize;\n\tint\t\tfd;\n\tuint64_t\tcpages;\n\tuint64_t\tfaults;\n};\n\nenum {\n\tHMM_PRIVATE_DEVICE_ONE,\n\tHMM_PRIVATE_DEVICE_TWO,\n\tHMM_COHERENCE_DEVICE_ONE,\n\tHMM_COHERENCE_DEVICE_TWO,\n};\n\n#define TWOMEG\t\t(1 << 21)\n#define HMM_BUFFER_SIZE (1024 << 12)\n#define HMM_PATH_MAX    64\n#define NTIMES\t\t10\n\n#define ALIGN(x, a) (((x) + (a - 1)) & (~((a) - 1)))\n \n\n#ifndef FOLL_WRITE\n#define FOLL_WRITE\t0x01\t \n#endif\n\n#ifndef FOLL_LONGTERM\n#define FOLL_LONGTERM   0x100  \n#endif\nFIXTURE(hmm)\n{\n\tint\t\tfd;\n\tunsigned int\tpage_size;\n\tunsigned int\tpage_shift;\n};\n\nFIXTURE_VARIANT(hmm)\n{\n\tint     device_number;\n};\n\nFIXTURE_VARIANT_ADD(hmm, hmm_device_private)\n{\n\t.device_number = HMM_PRIVATE_DEVICE_ONE,\n};\n\nFIXTURE_VARIANT_ADD(hmm, hmm_device_coherent)\n{\n\t.device_number = HMM_COHERENCE_DEVICE_ONE,\n};\n\nFIXTURE(hmm2)\n{\n\tint\t\tfd0;\n\tint\t\tfd1;\n\tunsigned int\tpage_size;\n\tunsigned int\tpage_shift;\n};\n\nFIXTURE_VARIANT(hmm2)\n{\n\tint     device_number0;\n\tint     device_number1;\n};\n\nFIXTURE_VARIANT_ADD(hmm2, hmm2_device_private)\n{\n\t.device_number0 = HMM_PRIVATE_DEVICE_ONE,\n\t.device_number1 = HMM_PRIVATE_DEVICE_TWO,\n};\n\nFIXTURE_VARIANT_ADD(hmm2, hmm2_device_coherent)\n{\n\t.device_number0 = HMM_COHERENCE_DEVICE_ONE,\n\t.device_number1 = HMM_COHERENCE_DEVICE_TWO,\n};\n\nstatic int hmm_open(int unit)\n{\n\tchar pathname[HMM_PATH_MAX];\n\tint fd;\n\n\tsnprintf(pathname, sizeof(pathname), \"/dev/hmm_dmirror%d\", unit);\n\tfd = open(pathname, O_RDWR, 0);\n\tif (fd < 0)\n\t\tfprintf(stderr, \"could not open hmm dmirror driver (%s)\\n\",\n\t\t\tpathname);\n\treturn fd;\n}\n\nstatic bool hmm_is_coherent_type(int dev_num)\n{\n\treturn (dev_num >= HMM_COHERENCE_DEVICE_ONE);\n}\n\nFIXTURE_SETUP(hmm)\n{\n\tself->page_size = sysconf(_SC_PAGE_SIZE);\n\tself->page_shift = ffs(self->page_size) - 1;\n\n\tself->fd = hmm_open(variant->device_number);\n\tif (self->fd < 0 && hmm_is_coherent_type(variant->device_number))\n\t\tSKIP(exit(0), \"DEVICE_COHERENT not available\");\n\tASSERT_GE(self->fd, 0);\n}\n\nFIXTURE_SETUP(hmm2)\n{\n\tself->page_size = sysconf(_SC_PAGE_SIZE);\n\tself->page_shift = ffs(self->page_size) - 1;\n\n\tself->fd0 = hmm_open(variant->device_number0);\n\tif (self->fd0 < 0 && hmm_is_coherent_type(variant->device_number0))\n\t\tSKIP(exit(0), \"DEVICE_COHERENT not available\");\n\tASSERT_GE(self->fd0, 0);\n\tself->fd1 = hmm_open(variant->device_number1);\n\tASSERT_GE(self->fd1, 0);\n}\n\nFIXTURE_TEARDOWN(hmm)\n{\n\tint ret = close(self->fd);\n\n\tASSERT_EQ(ret, 0);\n\tself->fd = -1;\n}\n\nFIXTURE_TEARDOWN(hmm2)\n{\n\tint ret = close(self->fd0);\n\n\tASSERT_EQ(ret, 0);\n\tself->fd0 = -1;\n\n\tret = close(self->fd1);\n\tASSERT_EQ(ret, 0);\n\tself->fd1 = -1;\n}\n\nstatic int hmm_dmirror_cmd(int fd,\n\t\t\t   unsigned long request,\n\t\t\t   struct hmm_buffer *buffer,\n\t\t\t   unsigned long npages)\n{\n\tstruct hmm_dmirror_cmd cmd;\n\tint ret;\n\n\t \n\tcmd.addr = (__u64)buffer->ptr;\n\tcmd.ptr = (__u64)buffer->mirror;\n\tcmd.npages = npages;\n\n\tfor (;;) {\n\t\tret = ioctl(fd, request, &cmd);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\treturn -errno;\n\t}\n\tbuffer->cpages = cmd.cpages;\n\tbuffer->faults = cmd.faults;\n\n\treturn 0;\n}\n\nstatic void hmm_buffer_free(struct hmm_buffer *buffer)\n{\n\tif (buffer == NULL)\n\t\treturn;\n\n\tif (buffer->ptr)\n\t\tmunmap(buffer->ptr, buffer->size);\n\tfree(buffer->mirror);\n\tfree(buffer);\n}\n\n \nstatic int hmm_create_file(unsigned long size)\n{\n\tchar path[HMM_PATH_MAX];\n\tint fd;\n\n\tstrcpy(path, \"/tmp\");\n\tfd = open(path, O_TMPFILE | O_EXCL | O_RDWR, 0600);\n\tif (fd >= 0) {\n\t\tint r;\n\n\t\tdo {\n\t\t\tr = ftruncate(fd, size);\n\t\t} while (r == -1 && errno == EINTR);\n\t\tif (!r)\n\t\t\treturn fd;\n\t\tclose(fd);\n\t}\n\treturn -1;\n}\n\n \nstatic unsigned int hmm_random(void)\n{\n\tstatic int fd = -1;\n\tunsigned int r;\n\n\tif (fd < 0) {\n\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"%s:%d failed to open /dev/urandom\\n\",\n\t\t\t\t\t__FILE__, __LINE__);\n\t\t\treturn ~0U;\n\t\t}\n\t}\n\tread(fd, &r, sizeof(r));\n\treturn r;\n}\n\nstatic void hmm_nanosleep(unsigned int n)\n{\n\tstruct timespec t;\n\n\tt.tv_sec = 0;\n\tt.tv_nsec = n;\n\tnanosleep(&t, NULL);\n}\n\nstatic int hmm_migrate_sys_to_dev(int fd,\n\t\t\t\t   struct hmm_buffer *buffer,\n\t\t\t\t   unsigned long npages)\n{\n\treturn hmm_dmirror_cmd(fd, HMM_DMIRROR_MIGRATE_TO_DEV, buffer, npages);\n}\n\nstatic int hmm_migrate_dev_to_sys(int fd,\n\t\t\t\t   struct hmm_buffer *buffer,\n\t\t\t\t   unsigned long npages)\n{\n\treturn hmm_dmirror_cmd(fd, HMM_DMIRROR_MIGRATE_TO_SYS, buffer, npages);\n}\n\n \nTEST_F(hmm, open_close)\n{\n}\n\n \nTEST_F(hmm, anon_read)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\tint val;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\ti = 2 * self->page_size / sizeof(*ptr);\n\tfor (ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tval = *(int *)(buffer->ptr + self->page_size);\n\tASSERT_EQ(val, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tptr = buffer->mirror;\n\tfor (i = 0; i < 2 * self->page_size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], 0);\n\tfor (; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, anon_read_prot)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = -i;\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_NONE);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, -EFAULT);\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_READ);\n\tASSERT_EQ(ret, 0);\n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], -i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, anon_write)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, anon_write_prot)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer, 1);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, 1);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, -EPERM);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], 0);\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_WRITE | PROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, anon_write_child)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tpid_t pid;\n\tint child_fd;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = -i;\n\n\tpid = fork();\n\tif (pid == -1)\n\t\tASSERT_EQ(pid, 0);\n\tif (pid != 0) {\n\t\twaitpid(pid, &ret, 0);\n\t\tASSERT_EQ(WIFEXITED(ret), 1);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tASSERT_EQ(ptr[i], i);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], -i);\n\n\t \n\tchild_fd = hmm_open(0);\n\tASSERT_GE(child_fd, 0);\n\n\t \n\tret = hmm_dmirror_cmd(child_fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], -i);\n\n\tclose(child_fd);\n\texit(0);\n}\n\n \nTEST_F(hmm, anon_write_child_shared)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tpid_t pid;\n\tint child_fd;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_SHARED | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = -i;\n\n\tpid = fork();\n\tif (pid == -1)\n\t\tASSERT_EQ(pid, 0);\n\tif (pid != 0) {\n\t\twaitpid(pid, &ret, 0);\n\t\tASSERT_EQ(WIFEXITED(ret), 1);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tASSERT_EQ(ptr[i], -i);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], -i);\n\n\t \n\tchild_fd = hmm_open(0);\n\tASSERT_GE(child_fd, 0);\n\n\t \n\tret = hmm_dmirror_cmd(child_fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], -i);\n\n\tclose(child_fd);\n\texit(0);\n}\n\n \nTEST_F(hmm, anon_write_huge)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tvoid *old_ptr;\n\tvoid *map;\n\tint *ptr;\n\tint ret;\n\n\tsize = 2 * TWOMEG;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\tsize = TWOMEG;\n\tnpages = size >> self->page_shift;\n\tmap = (void *)ALIGN((uintptr_t)buffer->ptr, size);\n\tret = madvise(map, size, MADV_HUGEPAGE);\n\tASSERT_EQ(ret, 0);\n\told_ptr = buffer->ptr;\n\tbuffer->ptr = map;\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\tbuffer->ptr = old_ptr;\n\thmm_buffer_free(buffer);\n}\n\n \nstatic long file_read_ulong(char *file, const char *tag)\n{\n\tint fd;\n\tchar buf[2048];\n\tint len;\n\tchar *p, *q;\n\tlong val;\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\t \n\t\treturn -1;\n\t}\n\n\tlen = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tif (len < 0) {\n\t\t \n\t\treturn -1;\n\t}\n\tif (len == sizeof(buf)) {\n\t\t \n\t\treturn -1;\n\t}\n\tbuf[len] = '\\0';\n\n\t \n\tif (tag) {\n\t\tp = strstr(buf, tag);\n\t\tif (!p)\n\t\t\treturn -1;  \n\t\tp += strlen(tag);\n\t} else\n\t\tp = buf;\n\n\tval = strtol(p, &q, 0);\n\tif (*q != ' ') {\n\t\t \n\t\treturn -1;\n\t}\n\n\treturn val;\n}\n\n \nTEST_F(hmm, anon_write_hugetlbfs)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long default_hsize;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tdefault_hsize = file_read_ulong(\"/proc/meminfo\", \"Hugepagesize:\");\n\tif (default_hsize < 0 || default_hsize*1024 < default_hsize)\n\t\tSKIP(return, \"Huge page size could not be determined\");\n\tdefault_hsize = default_hsize*1024;  \n\n\tsize = ALIGN(TWOMEG, default_hsize);\n\tnpages = size >> self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,\n\t\t\t\t   -1, 0);\n\tif (buffer->ptr == MAP_FAILED) {\n\t\tfree(buffer);\n\t\tSKIP(return, \"Huge page could not be allocated\");\n\t}\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\tmunmap(buffer->ptr, buffer->size);\n\tbuffer->ptr = NULL;\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, file_read)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\tint fd;\n\tssize_t len;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tfd = hmm_create_file(size);\n\tASSERT_GE(fd, 0);\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = fd;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\tlen = pwrite(fd, buffer->mirror, size, 0);\n\tASSERT_EQ(len, size);\n\tmemset(buffer->mirror, 0, size);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ,\n\t\t\t   MAP_SHARED,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, file_write)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\tint fd;\n\tssize_t len;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tfd = hmm_create_file(size);\n\tASSERT_GE(fd, 0);\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = fd;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_SHARED,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tlen = pread(fd, buffer->mirror, size, 0);\n\tASSERT_EQ(len, size);\n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, migrate)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, migrate_fault)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / (2 * sizeof(*ptr)); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\nTEST_F(hmm, migrate_release)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS, buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_RELEASE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / (2 * sizeof(*ptr)); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, migrate_shared)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_SHARED | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, -ENOENT);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm2, migrate_mixed)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tint *ptr;\n\tunsigned char *p;\n\tint ret;\n\tint val;\n\n\tnpages = 6;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_NONE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\tp = buffer->ptr;\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd1, buffer, npages);\n\tASSERT_EQ(ret, -EINVAL);\n\n\t \n\tret = munmap(buffer->ptr + self->page_size, self->page_size);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd1, buffer, 3);\n\tASSERT_EQ(ret, -EINVAL);\n\n\t \n\tret = mprotect(buffer->ptr + 2 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 2 * self->page_size);\n\tval = *ptr + 3;\n\tASSERT_EQ(val, 3);\n\n\t \n\tret = mprotect(buffer->ptr + 3 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ | PROT_WRITE);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 3 * self->page_size);\n\t*ptr = val;\n\tret = mprotect(buffer->ptr + 3 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = mprotect(buffer->ptr + 4 * self->page_size, 2 * self->page_size,\n\t\t\t\tPROT_READ | PROT_WRITE);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 4 * self->page_size);\n\t*ptr = val;\n\tptr = (int *)(buffer->ptr + 5 * self->page_size);\n\t*ptr = val;\n\n\t \n\tbuffer->ptr = p + 2 * self->page_size;\n\tret = hmm_migrate_sys_to_dev(self->fd1, buffer, 4);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, 4);\n\n\t \n\tbuffer->ptr = p + 5 * self->page_size;\n\tret = hmm_migrate_sys_to_dev(self->fd0, buffer, 1);\n\tASSERT_EQ(ret, -ENOENT);\n\tbuffer->ptr = p;\n\n\tbuffer->ptr = p;\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, migrate_multiple)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tunsigned long c;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tfor (c = 0; c < NTIMES; c++) {\n\t\tbuffer = malloc(sizeof(*buffer));\n\t\tASSERT_NE(buffer, NULL);\n\n\t\tbuffer->fd = -1;\n\t\tbuffer->size = size;\n\t\tbuffer->mirror = malloc(size);\n\t\tASSERT_NE(buffer->mirror, NULL);\n\n\t\tbuffer->ptr = mmap(NULL, size,\n\t\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t\t   buffer->fd, 0);\n\t\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tptr[i] = i;\n\n\t\t \n\t\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\t\tASSERT_EQ(ret, 0);\n\t\tASSERT_EQ(buffer->cpages, npages);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\t\tASSERT_EQ(ptr[i], i);\n\n\t\t \n\t\tif (hmm_is_coherent_type(variant->device_number)) {\n\t\t\tret = hmm_migrate_dev_to_sys(self->fd, buffer, npages);\n\t\t\tASSERT_EQ(ret, 0);\n\t\t\tASSERT_EQ(buffer->cpages, npages);\n\t\t}\n\n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tASSERT_EQ(ptr[i], i);\n\n\t\thmm_buffer_free(buffer);\n\t}\n}\n\n \nTEST_F(hmm, anon_read_multiple)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tunsigned long c;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tfor (c = 0; c < NTIMES; c++) {\n\t\tbuffer = malloc(sizeof(*buffer));\n\t\tASSERT_NE(buffer, NULL);\n\n\t\tbuffer->fd = -1;\n\t\tbuffer->size = size;\n\t\tbuffer->mirror = malloc(size);\n\t\tASSERT_NE(buffer->mirror, NULL);\n\n\t\tbuffer->ptr = mmap(NULL, size,\n\t\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t\t   buffer->fd, 0);\n\t\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tptr[i] = i + c;\n\n\t\t \n\t\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer,\n\t\t\t\t      npages);\n\t\tASSERT_EQ(ret, 0);\n\t\tASSERT_EQ(buffer->cpages, npages);\n\t\tASSERT_EQ(buffer->faults, 1);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\t\tASSERT_EQ(ptr[i], i + c);\n\n\t\thmm_buffer_free(buffer);\n\t}\n}\n\nvoid *unmap_buffer(void *p)\n{\n\tstruct hmm_buffer *buffer = p;\n\n\t \n\thmm_nanosleep(hmm_random() % 32000);\n\tmunmap(buffer->ptr + buffer->size / 2, buffer->size / 2);\n\tbuffer->ptr = NULL;\n\n\treturn NULL;\n}\n\n \nTEST_F(hmm, anon_teardown)\n{\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long c;\n\tvoid *ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tfor (c = 0; c < NTIMES; ++c) {\n\t\tpthread_t thread;\n\t\tstruct hmm_buffer *buffer;\n\t\tunsigned long i;\n\t\tint *ptr;\n\t\tint rc;\n\n\t\tbuffer = malloc(sizeof(*buffer));\n\t\tASSERT_NE(buffer, NULL);\n\n\t\tbuffer->fd = -1;\n\t\tbuffer->size = size;\n\t\tbuffer->mirror = malloc(size);\n\t\tASSERT_NE(buffer->mirror, NULL);\n\n\t\tbuffer->ptr = mmap(NULL, size,\n\t\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t\t   buffer->fd, 0);\n\t\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t\t \n\t\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\t\tptr[i] = i + c;\n\n\t\trc = pthread_create(&thread, NULL, unmap_buffer, buffer);\n\t\tASSERT_EQ(rc, 0);\n\n\t\t \n\t\trc = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_READ, buffer,\n\t\t\t\t     npages);\n\t\tif (rc == 0) {\n\t\t\tASSERT_EQ(buffer->cpages, npages);\n\t\t\tASSERT_EQ(buffer->faults, 1);\n\n\t\t\t \n\t\t\tfor (i = 0, ptr = buffer->mirror;\n\t\t\t     i < size / sizeof(*ptr);\n\t\t\t     ++i)\n\t\t\t\tASSERT_EQ(ptr[i], i + c);\n\t\t}\n\n\t\tpthread_join(thread, &ret);\n\t\thmm_buffer_free(buffer);\n\t}\n}\n\n \nTEST_F(hmm, mixedmap)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned char *m;\n\tint ret;\n\n\tnpages = 1;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(npages);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\n\t \n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE,\n\t\t\t   self->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tm = buffer->mirror;\n\tASSERT_EQ(m[0], HMM_DMIRROR_PROT_READ);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm2, snapshot)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tint *ptr;\n\tunsigned char *p;\n\tunsigned char *m;\n\tint ret;\n\tint val;\n\n\tnpages = 7;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(npages);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_NONE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\tp = buffer->ptr;\n\n\t \n\tret = munmap(buffer->ptr + self->page_size, self->page_size);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = mprotect(buffer->ptr + 2 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 2 * self->page_size);\n\tval = *ptr + 3;\n\tASSERT_EQ(val, 3);\n\n\t \n\tret = mprotect(buffer->ptr + 3 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ | PROT_WRITE);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 3 * self->page_size);\n\t*ptr = val;\n\tret = mprotect(buffer->ptr + 3 * self->page_size, self->page_size,\n\t\t\t\tPROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = mprotect(buffer->ptr + 4 * self->page_size, 3 * self->page_size,\n\t\t\t\tPROT_READ | PROT_WRITE);\n\tASSERT_EQ(ret, 0);\n\tptr = (int *)(buffer->ptr + 4 * self->page_size);\n\t*ptr = val;\n\n\t \n\tbuffer->ptr = p + 5 * self->page_size;\n\tret = hmm_migrate_sys_to_dev(self->fd0, buffer, 1);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, 1);\n\n\t \n\tbuffer->ptr = p + 6 * self->page_size;\n\tret = hmm_migrate_sys_to_dev(self->fd1, buffer, 1);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, 1);\n\n\t \n\tbuffer->ptr = p;\n\tret = hmm_dmirror_cmd(self->fd0, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tm = buffer->mirror;\n\tASSERT_EQ(m[0], HMM_DMIRROR_PROT_ERROR);\n\tASSERT_EQ(m[1], HMM_DMIRROR_PROT_ERROR);\n\tASSERT_EQ(m[2], HMM_DMIRROR_PROT_ZERO | HMM_DMIRROR_PROT_READ);\n\tASSERT_EQ(m[3], HMM_DMIRROR_PROT_READ);\n\tASSERT_EQ(m[4], HMM_DMIRROR_PROT_WRITE);\n\tif (!hmm_is_coherent_type(variant->device_number0)) {\n\t\tASSERT_EQ(m[5], HMM_DMIRROR_PROT_DEV_PRIVATE_LOCAL |\n\t\t\t\tHMM_DMIRROR_PROT_WRITE);\n\t\tASSERT_EQ(m[6], HMM_DMIRROR_PROT_NONE);\n\t} else {\n\t\tASSERT_EQ(m[5], HMM_DMIRROR_PROT_DEV_COHERENT_LOCAL |\n\t\t\t\tHMM_DMIRROR_PROT_WRITE);\n\t\tASSERT_EQ(m[6], HMM_DMIRROR_PROT_DEV_COHERENT_REMOTE |\n\t\t\t\tHMM_DMIRROR_PROT_WRITE);\n\t}\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, compound)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long default_hsize;\n\tint *ptr;\n\tunsigned char *m;\n\tint ret;\n\tunsigned long i;\n\n\t \n\n\tdefault_hsize = file_read_ulong(\"/proc/meminfo\", \"Hugepagesize:\");\n\tif (default_hsize < 0 || default_hsize*1024 < default_hsize)\n\t\tSKIP(return, \"Huge page size could not be determined\");\n\tdefault_hsize = default_hsize*1024;  \n\n\tsize = ALIGN(TWOMEG, default_hsize);\n\tnpages = size >> self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,\n\t\t\t\t   -1, 0);\n\tif (buffer->ptr == MAP_FAILED) {\n\t\tfree(buffer);\n\t\treturn;\n\t}\n\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(npages);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tm = buffer->mirror;\n\tfor (i = 0; i < npages; ++i)\n\t\tASSERT_EQ(m[i], HMM_DMIRROR_PROT_WRITE |\n\t\t\t\tHMM_DMIRROR_PROT_PMD);\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tm = buffer->mirror;\n\tfor (i = 0; i < npages; ++i)\n\t\tASSERT_EQ(m[i], HMM_DMIRROR_PROT_READ |\n\t\t\t\tHMM_DMIRROR_PROT_PMD);\n\n\tmunmap(buffer->ptr, buffer->size);\n\tbuffer->ptr = NULL;\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm2, double_map)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = 6;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(npages);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\t \n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = mprotect(buffer->ptr, size, PROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd0, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd1, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd1, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\tret = hmm_dmirror_cmd(self->fd0, HMM_DMIRROR_READ, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tASSERT_EQ(buffer->faults, 1);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, exclusive)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_EXCLUSIVE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i]++, i);\n\n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i+1);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_CHECK_EXCLUSIVE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\n\thmm_buffer_free(buffer);\n}\n\nTEST_F(hmm, exclusive_mprotect)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_EXCLUSIVE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\tret = mprotect(buffer->ptr, size, PROT_READ);\n\tASSERT_EQ(ret, 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_WRITE, buffer, npages);\n\tASSERT_EQ(ret, -EPERM);\n\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, exclusive_cow)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\n\tnpages = ALIGN(HMM_BUFFER_SIZE, self->page_size) >> self->page_shift;\n\tASSERT_NE(npages, 0);\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_EXCLUSIVE, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\tfork();\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i]++, i);\n\n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i+1);\n\n\thmm_buffer_free(buffer);\n}\n\nstatic int gup_test_exec(int gup_fd, unsigned long addr, int cmd,\n\t\t\t int npages, int size, int flags)\n{\n\tstruct gup_test gup = {\n\t\t.nr_pages_per_call\t= npages,\n\t\t.addr\t\t\t= addr,\n\t\t.gup_flags\t\t= FOLL_WRITE | flags,\n\t\t.size\t\t\t= size,\n\t};\n\n\tif (ioctl(gup_fd, cmd, &gup)) {\n\t\tperror(\"ioctl on error\\n\");\n\t\treturn errno;\n\t}\n\n\treturn 0;\n}\n\n \nTEST_F(hmm, hmm_gup_test)\n{\n\tstruct hmm_buffer *buffer;\n\tint gup_fd;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\tunsigned char *m;\n\n\tgup_fd = open(\"/sys/kernel/debug/gup_test\", O_RDWR);\n\tif (gup_fd == -1)\n\t\tSKIP(return, \"Skipping test, could not find gup_test driver\");\n\n\tnpages = 4;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\t \n\tfor (i = 0, ptr = buffer->mirror; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\tASSERT_EQ(gup_test_exec(gup_fd,\n\t\t\t\t(unsigned long)buffer->ptr,\n\t\t\t\tGUP_BASIC_TEST, 1, self->page_size, 0), 0);\n\tASSERT_EQ(gup_test_exec(gup_fd,\n\t\t\t\t(unsigned long)buffer->ptr + 1 * self->page_size,\n\t\t\t\tGUP_FAST_BENCHMARK, 1, self->page_size, 0), 0);\n\tASSERT_EQ(gup_test_exec(gup_fd,\n\t\t\t\t(unsigned long)buffer->ptr + 2 * self->page_size,\n\t\t\t\tPIN_FAST_BENCHMARK, 1, self->page_size, FOLL_LONGTERM), 0);\n\tASSERT_EQ(gup_test_exec(gup_fd,\n\t\t\t\t(unsigned long)buffer->ptr + 3 * self->page_size,\n\t\t\t\tPIN_LONGTERM_BENCHMARK, 1, self->page_size, 0), 0);\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tm = buffer->mirror;\n\tif (hmm_is_coherent_type(variant->device_number)) {\n\t\tASSERT_EQ(HMM_DMIRROR_PROT_DEV_COHERENT_LOCAL | HMM_DMIRROR_PROT_WRITE, m[0]);\n\t\tASSERT_EQ(HMM_DMIRROR_PROT_DEV_COHERENT_LOCAL | HMM_DMIRROR_PROT_WRITE, m[1]);\n\t} else {\n\t\tASSERT_EQ(HMM_DMIRROR_PROT_WRITE, m[0]);\n\t\tASSERT_EQ(HMM_DMIRROR_PROT_WRITE, m[1]);\n\t}\n\tASSERT_EQ(HMM_DMIRROR_PROT_WRITE, m[2]);\n\tASSERT_EQ(HMM_DMIRROR_PROT_WRITE, m[3]);\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tASSERT_EQ(ptr[i], i);\n\n\tclose(gup_fd);\n\thmm_buffer_free(buffer);\n}\n\n \nTEST_F(hmm, hmm_cow_in_device)\n{\n\tstruct hmm_buffer *buffer;\n\tunsigned long npages;\n\tunsigned long size;\n\tunsigned long i;\n\tint *ptr;\n\tint ret;\n\tunsigned char *m;\n\tpid_t pid;\n\tint status;\n\n\tnpages = 4;\n\tsize = npages << self->page_shift;\n\n\tbuffer = malloc(sizeof(*buffer));\n\tASSERT_NE(buffer, NULL);\n\n\tbuffer->fd = -1;\n\tbuffer->size = size;\n\tbuffer->mirror = malloc(size);\n\tASSERT_NE(buffer->mirror, NULL);\n\n\tbuffer->ptr = mmap(NULL, size,\n\t\t\t   PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS,\n\t\t\t   buffer->fd, 0);\n\tASSERT_NE(buffer->ptr, MAP_FAILED);\n\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\n\tret = hmm_migrate_sys_to_dev(self->fd, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\n\tpid = fork();\n\tif (pid == -1)\n\t\tASSERT_EQ(pid, 0);\n\tif (!pid) {\n\t\t \n\t\twhile (1) {\n\t\t}\n\t\tperror(\"Should not reach this\\n\");\n\t\texit(0);\n\t}\n\t \n\tfor (i = 0, ptr = buffer->ptr; i < size / sizeof(*ptr); ++i)\n\t\tptr[i] = i;\n\n\t \n\tEXPECT_EQ(0, kill(pid, SIGTERM));\n\tEXPECT_EQ(pid, waitpid(pid, &status, 0));\n\tEXPECT_NE(0, WIFSIGNALED(status));\n\tEXPECT_EQ(SIGTERM, WTERMSIG(status));\n\n\t \n\tret = hmm_dmirror_cmd(self->fd, HMM_DMIRROR_SNAPSHOT, buffer, npages);\n\tASSERT_EQ(ret, 0);\n\tASSERT_EQ(buffer->cpages, npages);\n\tm = buffer->mirror;\n\tfor (i = 0; i < npages; i++)\n\t\tASSERT_EQ(HMM_DMIRROR_PROT_WRITE, m[i]);\n\n\thmm_buffer_free(buffer);\n}\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}