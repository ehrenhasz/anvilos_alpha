{
  "module_name": "mdwe_test.c",
  "hash_id": "0d636c3bdd6675980bc4ba8a87a39a39da0bf52b4bb3fa8c20181caea7245626",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mdwe_test.c",
  "human_readable_source": "\n\n#ifdef __aarch64__\n#include <asm/hwcap.h>\n#endif\n\n#include <linux/mman.h>\n#include <linux/prctl.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\n#ifndef __aarch64__\n# define PROT_BTI\t0\n#endif\n\nTEST(prctl_flags)\n{\n\tEXPECT_LT(prctl(PR_SET_MDWE, 7L, 0L, 0L, 0L), 0);\n\tEXPECT_LT(prctl(PR_SET_MDWE, 0L, 7L, 0L, 0L), 0);\n\tEXPECT_LT(prctl(PR_SET_MDWE, 0L, 0L, 7L, 0L), 0);\n\tEXPECT_LT(prctl(PR_SET_MDWE, 0L, 0L, 0L, 7L), 0);\n\n\tEXPECT_LT(prctl(PR_GET_MDWE, 7L, 0L, 0L, 0L), 0);\n\tEXPECT_LT(prctl(PR_GET_MDWE, 0L, 7L, 0L, 0L), 0);\n\tEXPECT_LT(prctl(PR_GET_MDWE, 0L, 0L, 7L, 0L), 0);\n\tEXPECT_LT(prctl(PR_GET_MDWE, 0L, 0L, 0L, 7L), 0);\n}\n\nFIXTURE(mdwe)\n{\n\tvoid *p;\n\tint flags;\n\tsize_t size;\n\tpid_t pid;\n};\n\nFIXTURE_VARIANT(mdwe)\n{\n\tbool enabled;\n\tbool forked;\n};\n\nFIXTURE_VARIANT_ADD(mdwe, stock)\n{\n        .enabled = false,\n\t.forked = false,\n};\n\nFIXTURE_VARIANT_ADD(mdwe, enabled)\n{\n        .enabled = true,\n\t.forked = false,\n};\n\nFIXTURE_VARIANT_ADD(mdwe, forked)\n{\n        .enabled = true,\n\t.forked = true,\n};\n\nFIXTURE_SETUP(mdwe)\n{\n\tint ret, status;\n\n\tself->p = NULL;\n\tself->flags = MAP_SHARED | MAP_ANONYMOUS;\n\tself->size = getpagesize();\n\n\tif (!variant->enabled)\n\t\treturn;\n\n\tret = prctl(PR_SET_MDWE, PR_MDWE_REFUSE_EXEC_GAIN, 0L, 0L, 0L);\n\tASSERT_EQ(ret, 0) {\n\t\tTH_LOG(\"PR_SET_MDWE failed or unsupported\");\n\t}\n\n\tret = prctl(PR_GET_MDWE, 0L, 0L, 0L, 0L);\n\tASSERT_EQ(ret, 1);\n\n\tif (variant->forked) {\n\t\tself->pid = fork();\n\t\tASSERT_GE(self->pid, 0) {\n\t\t\tTH_LOG(\"fork failed\\n\");\n\t\t}\n\n\t\tif (self->pid > 0) {\n\t\t\tret = waitpid(self->pid, &status, 0);\n\t\t\tASSERT_TRUE(WIFEXITED(status));\n\t\t\texit(WEXITSTATUS(status));\n\t\t}\n\t}\n}\n\nFIXTURE_TEARDOWN(mdwe)\n{\n\tif (self->p && self->p != MAP_FAILED)\n\t\tmunmap(self->p, self->size);\n}\n\nTEST_F(mdwe, mmap_READ_EXEC)\n{\n\tself->p = mmap(NULL, self->size, PROT_READ | PROT_EXEC, self->flags, 0, 0);\n\tEXPECT_NE(self->p, MAP_FAILED);\n}\n\nTEST_F(mdwe, mmap_WRITE_EXEC)\n{\n\tself->p = mmap(NULL, self->size, PROT_WRITE | PROT_EXEC, self->flags, 0, 0);\n\tif (variant->enabled) {\n\t\tEXPECT_EQ(self->p, MAP_FAILED);\n\t} else {\n\t\tEXPECT_NE(self->p, MAP_FAILED);\n\t}\n}\n\nTEST_F(mdwe, mprotect_stay_EXEC)\n{\n\tint ret;\n\n\tself->p = mmap(NULL, self->size, PROT_READ | PROT_EXEC, self->flags, 0, 0);\n\tASSERT_NE(self->p, MAP_FAILED);\n\n\tret = mprotect(self->p, self->size, PROT_READ | PROT_EXEC);\n\tEXPECT_EQ(ret, 0);\n}\n\nTEST_F(mdwe, mprotect_add_EXEC)\n{\n\tint ret;\n\n\tself->p = mmap(NULL, self->size, PROT_READ, self->flags, 0, 0);\n\tASSERT_NE(self->p, MAP_FAILED);\n\n\tret = mprotect(self->p, self->size, PROT_READ | PROT_EXEC);\n\tif (variant->enabled) {\n\t\tEXPECT_LT(ret, 0);\n\t} else {\n\t\tEXPECT_EQ(ret, 0);\n\t}\n}\n\nTEST_F(mdwe, mprotect_WRITE_EXEC)\n{\n\tint ret;\n\n\tself->p = mmap(NULL, self->size, PROT_WRITE, self->flags, 0, 0);\n\tASSERT_NE(self->p, MAP_FAILED);\n\n\tret = mprotect(self->p, self->size, PROT_WRITE | PROT_EXEC);\n\tif (variant->enabled) {\n\t\tEXPECT_LT(ret, 0);\n\t} else {\n\t\tEXPECT_EQ(ret, 0);\n\t}\n}\n\nTEST_F(mdwe, mmap_FIXED)\n{\n\tvoid *p;\n\n\tself->p = mmap(NULL, self->size, PROT_READ, self->flags, 0, 0);\n\tASSERT_NE(self->p, MAP_FAILED);\n\n\t \n\tp = mmap(self->p, self->size, PROT_READ | PROT_EXEC,\n\t\t self->flags | MAP_FIXED, 0, 0);\n\tEXPECT_EQ(p, self->p);\n}\n\nTEST_F(mdwe, arm64_BTI)\n{\n\tint ret;\n\n#ifdef __aarch64__\n\tif (!(getauxval(AT_HWCAP2) & HWCAP2_BTI))\n#endif\n\t\tSKIP(return, \"HWCAP2_BTI not supported\");\n\n\tself->p = mmap(NULL, self->size, PROT_EXEC, self->flags, 0, 0);\n\tASSERT_NE(self->p, MAP_FAILED);\n\n\tret = mprotect(self->p, self->size, PROT_EXEC | PROT_BTI);\n\tEXPECT_EQ(ret, 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}