{
  "module_name": "mremap_dontunmap.c",
  "hash_id": "08bf433463868574b6f4f127fb29db8161ef0c4405e8d49452cdb0f8e0e282ef",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/mremap_dontunmap.c",
  "human_readable_source": "\n\n \n#define _GNU_SOURCE\n#include <sys/mman.h>\n#include <linux/mman.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\nunsigned long page_size;\nchar *page_buffer;\n\nstatic void dump_maps(void)\n{\n\tchar cmd[32];\n\n\tsnprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n\tsystem(cmd);\n}\n\n#define BUG_ON(condition, description)\t\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tif (condition) {\t\t\t\t\t      \\\n\t\t\tfprintf(stderr, \"[FAIL]\\t%s():%d\\t%s:%s\\n\", __func__, \\\n\t\t\t\t__LINE__, (description), strerror(errno));    \\\n\t\t\tdump_maps();\t\t\t\t\t  \\\n\t\t\texit(1);\t\t\t\t\t      \\\n\t\t} \t\t\t\t\t\t\t      \\\n\t} while (0)\n\n\n\nstatic int kernel_support_for_mremap_dontunmap()\n{\n\tint ret = 0;\n\tunsigned long num_pages = 1;\n\tvoid *source_mapping = mmap(NULL, num_pages * page_size, PROT_NONE,\n\t\t\t\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\n\t\n\t\n\tvoid *dest_mapping =\n\t    mremap(source_mapping, num_pages * page_size, num_pages * page_size,\n\t\t   MREMAP_DONTUNMAP | MREMAP_MAYMOVE, 0);\n\tif (dest_mapping == MAP_FAILED) {\n\t\tret = errno;\n\t} else {\n\t\tBUG_ON(munmap(dest_mapping, num_pages * page_size) == -1,\n\t\t       \"unable to unmap destination mapping\");\n\t}\n\n\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n\treturn ret;\n}\n\n\n\nstatic int check_region_contains_byte(void *addr, unsigned long size, char byte)\n{\n\tBUG_ON(size & (page_size - 1),\n\t       \"check_region_contains_byte expects page multiples\");\n\tBUG_ON((unsigned long)addr & (page_size - 1),\n\t       \"check_region_contains_byte expects page alignment\");\n\n\tmemset(page_buffer, byte, page_size);\n\n\tunsigned long num_pages = size / page_size;\n\tunsigned long i;\n\n\t\n\tfor (i = 0; i < num_pages; ++i) {\n\t\tint ret =\n\t\t    memcmp(addr + (i * page_size), page_buffer, page_size);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\nstatic void mremap_dontunmap_simple()\n{\n\tunsigned long num_pages = 5;\n\n\tvoid *source_mapping =\n\t    mmap(NULL, num_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\n\tmemset(source_mapping, 'a', num_pages * page_size);\n\n\t\n\tvoid *dest_mapping =\n\t    mremap(source_mapping, num_pages * page_size, num_pages * page_size,\n\t\t   MREMAP_DONTUNMAP | MREMAP_MAYMOVE, NULL);\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mremap\");\n\n\t\n\t\n\tBUG_ON(check_region_contains_byte\n\t       (dest_mapping, num_pages * page_size, 'a') != 0,\n\t       \"pages did not migrate\");\n\tBUG_ON(check_region_contains_byte\n\t       (source_mapping, num_pages * page_size, 0) != 0,\n\t       \"source should have no ptes\");\n\n\tBUG_ON(munmap(dest_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap destination mapping\");\n\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n}\n\n\nstatic void mremap_dontunmap_simple_shmem()\n{\n\tunsigned long num_pages = 5;\n\n\tint mem_fd = memfd_create(\"memfd\", MFD_CLOEXEC);\n\tBUG_ON(mem_fd < 0, \"memfd_create\");\n\n\tBUG_ON(ftruncate(mem_fd, num_pages * page_size) < 0,\n\t\t\t\"ftruncate\");\n\n\tvoid *source_mapping =\n\t    mmap(NULL, num_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_FILE | MAP_SHARED, mem_fd, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\n\tBUG_ON(close(mem_fd) < 0, \"close\");\n\n\tmemset(source_mapping, 'a', num_pages * page_size);\n\n\t\n\tvoid *dest_mapping =\n\t    mremap(source_mapping, num_pages * page_size, num_pages * page_size,\n\t\t   MREMAP_DONTUNMAP | MREMAP_MAYMOVE, NULL);\n\tif (dest_mapping == MAP_FAILED && errno == EINVAL) {\n\t\t\n\t\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t\t\t\"unable to unmap source mapping\");\n\t\treturn;\n\t}\n\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mremap\");\n\n\t\n\t\n\tBUG_ON(check_region_contains_byte\n\t       (dest_mapping, num_pages * page_size, 'a') != 0,\n\t       \"pages did not migrate\");\n\n\t\n\t\n\tBUG_ON(check_region_contains_byte\n\t       (source_mapping, num_pages * page_size, 'a') != 0,\n\t       \"source should have no ptes\");\n\n\tBUG_ON(munmap(dest_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap destination mapping\");\n\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n}\n\n\n\n\nstatic void mremap_dontunmap_simple_fixed()\n{\n\tunsigned long num_pages = 5;\n\n\t\n\t\n\tvoid *dest_mapping =\n\t    mmap(NULL, num_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mmap\");\n\tmemset(dest_mapping, 'X', num_pages * page_size);\n\n\tvoid *source_mapping =\n\t    mmap(NULL, num_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\tmemset(source_mapping, 'a', num_pages * page_size);\n\n\tvoid *remapped_mapping =\n\t    mremap(source_mapping, num_pages * page_size, num_pages * page_size,\n\t\t   MREMAP_FIXED | MREMAP_DONTUNMAP | MREMAP_MAYMOVE,\n\t\t   dest_mapping);\n\tBUG_ON(remapped_mapping == MAP_FAILED, \"mremap\");\n\tBUG_ON(remapped_mapping != dest_mapping,\n\t       \"mremap should have placed the remapped mapping at dest_mapping\");\n\n\t\n\t\n\tBUG_ON(check_region_contains_byte\n\t       (dest_mapping, num_pages * page_size, 'a') != 0,\n\t       \"pages did not migrate\");\n\n\t\n\tBUG_ON(check_region_contains_byte\n\t       (source_mapping, num_pages * page_size, 0) != 0,\n\t       \"source should have no ptes\");\n\n\tBUG_ON(munmap(dest_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap destination mapping\");\n\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n}\n\n\n\nstatic void mremap_dontunmap_partial_mapping()\n{\n\t \n\tunsigned long num_pages = 10;\n\tvoid *source_mapping =\n\t    mmap(NULL, num_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\tmemset(source_mapping, 'a', num_pages * page_size);\n\n\t\n\tvoid *dest_mapping =\n\t    mremap(source_mapping + (5 * page_size), 5 * page_size,\n\t\t   5 * page_size,\n\t\t   MREMAP_DONTUNMAP | MREMAP_MAYMOVE, NULL);\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mremap\");\n\n\t\n\t\n\tBUG_ON(check_region_contains_byte(source_mapping, 5 * page_size, 'a') !=\n\t       0, \"first 5 pages of source should have original pages\");\n\tBUG_ON(check_region_contains_byte\n\t       (source_mapping + (5 * page_size), 5 * page_size, 0) != 0,\n\t       \"final 5 pages of source should have no ptes\");\n\n\t\n\tBUG_ON(check_region_contains_byte(dest_mapping, 5 * page_size, 'a') !=\n\t       0, \"dest mapping should contain ptes from the source\");\n\n\tBUG_ON(munmap(dest_mapping, 5 * page_size) == -1,\n\t       \"unable to unmap destination mapping\");\n\tBUG_ON(munmap(source_mapping, num_pages * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n}\n\n\nstatic void mremap_dontunmap_partial_mapping_overwrite(void)\n{\n\t \n\tvoid *source_mapping =\n\t    mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(source_mapping == MAP_FAILED, \"mmap\");\n\tmemset(source_mapping, 'a', 5 * page_size);\n\n\tvoid *dest_mapping =\n\t    mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mmap\");\n\tmemset(dest_mapping, 'X', 10 * page_size);\n\n\t\n\tvoid *remapped_mapping =\n\t    mremap(source_mapping, 5 * page_size,\n\t\t   5 * page_size,\n\t\t   MREMAP_DONTUNMAP | MREMAP_MAYMOVE | MREMAP_FIXED, dest_mapping);\n\tBUG_ON(dest_mapping == MAP_FAILED, \"mremap\");\n\tBUG_ON(dest_mapping != remapped_mapping, \"expected to remap to dest_mapping\");\n\n\tBUG_ON(check_region_contains_byte(source_mapping, 5 * page_size, 0) !=\n\t       0, \"first 5 pages of source should have no ptes\");\n\n\t\n\tBUG_ON(check_region_contains_byte(dest_mapping, 5 * page_size, 'a') != 0,\n\t\t\t\"dest mapping should contain ptes from the source\");\n\n\t\n\tBUG_ON(check_region_contains_byte(dest_mapping + (5 * page_size),\n\t\t\t\t5 * page_size, 'X') != 0,\n\t\t\t\"dest mapping should have retained the last 5 pages\");\n\n\tBUG_ON(munmap(dest_mapping, 10 * page_size) == -1,\n\t       \"unable to unmap destination mapping\");\n\tBUG_ON(munmap(source_mapping, 5 * page_size) == -1,\n\t       \"unable to unmap source mapping\");\n}\n\nint main(void)\n{\n\tpage_size = sysconf(_SC_PAGE_SIZE);\n\n\t\n\t\n\tif (kernel_support_for_mremap_dontunmap() != 0) {\n\t\tprintf(\"No kernel support for MREMAP_DONTUNMAP\\n\");\n\t\treturn KSFT_SKIP;\n\t}\n\n\t\n\tpage_buffer =\n\t    mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tBUG_ON(page_buffer == MAP_FAILED, \"unable to mmap a page.\");\n\n\tmremap_dontunmap_simple();\n\tmremap_dontunmap_simple_shmem();\n\tmremap_dontunmap_simple_fixed();\n\tmremap_dontunmap_partial_mapping();\n\tmremap_dontunmap_partial_mapping_overwrite();\n\n\tBUG_ON(munmap(page_buffer, page_size) == -1,\n\t       \"unable to unmap page buffer\");\n\n\tprintf(\"OK\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}