{
  "module_name": "uffd-common.c",
  "hash_id": "d543fe49c698e2054772457cae58d4857a5cabdbffd93be9b0cfde43172ab73c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/uffd-common.c",
  "human_readable_source": "\n \n\n#include \"uffd-common.h\"\n\n#define BASE_PMD_ADDR ((void *)(1UL << 30))\n\nvolatile bool test_uffdio_copy_eexist = true;\nunsigned long nr_cpus, nr_pages, nr_pages_per_cpu, page_size;\nchar *area_src, *area_src_alias, *area_dst, *area_dst_alias, *area_remap;\nint uffd = -1, uffd_flags, finished, *pipefd, test_type;\nbool map_shared;\nbool test_uffdio_wp = true;\nunsigned long long *count_verify;\nuffd_test_ops_t *uffd_test_ops;\n\nstatic int uffd_mem_fd_create(off_t mem_size, bool hugetlb)\n{\n\tunsigned int memfd_flags = 0;\n\tint mem_fd;\n\n\tif (hugetlb)\n\t\tmemfd_flags = MFD_HUGETLB;\n\tmem_fd = memfd_create(\"uffd-test\", memfd_flags);\n\tif (mem_fd < 0)\n\t\terr(\"memfd_create\");\n\tif (ftruncate(mem_fd, mem_size))\n\t\terr(\"ftruncate\");\n\tif (fallocate(mem_fd,\n\t\t      FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0,\n\t\t      mem_size))\n\t\terr(\"fallocate\");\n\n\treturn mem_fd;\n}\n\nstatic void anon_release_pages(char *rel_area)\n{\n\tif (madvise(rel_area, nr_pages * page_size, MADV_DONTNEED))\n\t\terr(\"madvise(MADV_DONTNEED) failed\");\n}\n\nstatic int anon_allocate_area(void **alloc_area, bool is_src)\n{\n\t*alloc_area = mmap(NULL, nr_pages * page_size, PROT_READ | PROT_WRITE,\n\t\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tif (*alloc_area == MAP_FAILED) {\n\t\t*alloc_area = NULL;\n\t\treturn -errno;\n\t}\n\treturn 0;\n}\n\nstatic void noop_alias_mapping(__u64 *start, size_t len, unsigned long offset)\n{\n}\n\nstatic void hugetlb_release_pages(char *rel_area)\n{\n\tif (!map_shared) {\n\t\tif (madvise(rel_area, nr_pages * page_size, MADV_DONTNEED))\n\t\t\terr(\"madvise(MADV_DONTNEED) failed\");\n\t} else {\n\t\tif (madvise(rel_area, nr_pages * page_size, MADV_REMOVE))\n\t\t\terr(\"madvise(MADV_REMOVE) failed\");\n\t}\n}\n\nstatic int hugetlb_allocate_area(void **alloc_area, bool is_src)\n{\n\toff_t size = nr_pages * page_size;\n\toff_t offset = is_src ? 0 : size;\n\tvoid *area_alias = NULL;\n\tchar **alloc_area_alias;\n\tint mem_fd = uffd_mem_fd_create(size * 2, true);\n\n\t*alloc_area = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t   (map_shared ? MAP_SHARED : MAP_PRIVATE) |\n\t\t\t   (is_src ? 0 : MAP_NORESERVE),\n\t\t\t   mem_fd, offset);\n\tif (*alloc_area == MAP_FAILED) {\n\t\t*alloc_area = NULL;\n\t\treturn -errno;\n\t}\n\n\tif (map_shared) {\n\t\tarea_alias = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t  MAP_SHARED, mem_fd, offset);\n\t\tif (area_alias == MAP_FAILED)\n\t\t\treturn -errno;\n\t}\n\n\tif (is_src) {\n\t\talloc_area_alias = &area_src_alias;\n\t} else {\n\t\talloc_area_alias = &area_dst_alias;\n\t}\n\tif (area_alias)\n\t\t*alloc_area_alias = area_alias;\n\n\tclose(mem_fd);\n\treturn 0;\n}\n\nstatic void hugetlb_alias_mapping(__u64 *start, size_t len, unsigned long offset)\n{\n\tif (!map_shared)\n\t\treturn;\n\n\t*start = (unsigned long) area_dst_alias + offset;\n}\n\nstatic void shmem_release_pages(char *rel_area)\n{\n\tif (madvise(rel_area, nr_pages * page_size, MADV_REMOVE))\n\t\terr(\"madvise(MADV_REMOVE) failed\");\n}\n\nstatic int shmem_allocate_area(void **alloc_area, bool is_src)\n{\n\tvoid *area_alias = NULL;\n\tsize_t bytes = nr_pages * page_size, hpage_size = read_pmd_pagesize();\n\tunsigned long offset = is_src ? 0 : bytes;\n\tchar *p = NULL, *p_alias = NULL;\n\tint mem_fd = uffd_mem_fd_create(bytes * 2, false);\n\n\t \n\tp = BASE_PMD_ADDR;\n\tif (!is_src)\n\t\t \n\t\tp += 2 * (bytes + hpage_size);\n\tp_alias = p;\n\tp_alias += bytes;\n\tp_alias += hpage_size;   \n\n\t*alloc_area = mmap(p, bytes, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t\t   mem_fd, offset);\n\tif (*alloc_area == MAP_FAILED) {\n\t\t*alloc_area = NULL;\n\t\treturn -errno;\n\t}\n\tif (*alloc_area != p)\n\t\terr(\"mmap of memfd failed at %p\", p);\n\n\tarea_alias = mmap(p_alias, bytes, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t\t  mem_fd, offset);\n\tif (area_alias == MAP_FAILED) {\n\t\tmunmap(*alloc_area, bytes);\n\t\t*alloc_area = NULL;\n\t\treturn -errno;\n\t}\n\tif (area_alias != p_alias)\n\t\terr(\"mmap of anonymous memory failed at %p\", p_alias);\n\n\tif (is_src)\n\t\tarea_src_alias = area_alias;\n\telse\n\t\tarea_dst_alias = area_alias;\n\n\tclose(mem_fd);\n\treturn 0;\n}\n\nstatic void shmem_alias_mapping(__u64 *start, size_t len, unsigned long offset)\n{\n\t*start = (unsigned long)area_dst_alias + offset;\n}\n\nstatic void shmem_check_pmd_mapping(void *p, int expect_nr_hpages)\n{\n\tif (!check_huge_shmem(area_dst_alias, expect_nr_hpages,\n\t\t\t      read_pmd_pagesize()))\n\t\terr(\"Did not find expected %d number of hugepages\",\n\t\t    expect_nr_hpages);\n}\n\nstruct uffd_test_ops anon_uffd_test_ops = {\n\t.allocate_area = anon_allocate_area,\n\t.release_pages = anon_release_pages,\n\t.alias_mapping = noop_alias_mapping,\n\t.check_pmd_mapping = NULL,\n};\n\nstruct uffd_test_ops shmem_uffd_test_ops = {\n\t.allocate_area = shmem_allocate_area,\n\t.release_pages = shmem_release_pages,\n\t.alias_mapping = shmem_alias_mapping,\n\t.check_pmd_mapping = shmem_check_pmd_mapping,\n};\n\nstruct uffd_test_ops hugetlb_uffd_test_ops = {\n\t.allocate_area = hugetlb_allocate_area,\n\t.release_pages = hugetlb_release_pages,\n\t.alias_mapping = hugetlb_alias_mapping,\n\t.check_pmd_mapping = NULL,\n};\n\nvoid uffd_stats_report(struct uffd_args *args, int n_cpus)\n{\n\tint i;\n\tunsigned long long miss_total = 0, wp_total = 0, minor_total = 0;\n\n\tfor (i = 0; i < n_cpus; i++) {\n\t\tmiss_total += args[i].missing_faults;\n\t\twp_total += args[i].wp_faults;\n\t\tminor_total += args[i].minor_faults;\n\t}\n\n\tprintf(\"userfaults: \");\n\tif (miss_total) {\n\t\tprintf(\"%llu missing (\", miss_total);\n\t\tfor (i = 0; i < n_cpus; i++)\n\t\t\tprintf(\"%lu+\", args[i].missing_faults);\n\t\tprintf(\"\\b) \");\n\t}\n\tif (wp_total) {\n\t\tprintf(\"%llu wp (\", wp_total);\n\t\tfor (i = 0; i < n_cpus; i++)\n\t\t\tprintf(\"%lu+\", args[i].wp_faults);\n\t\tprintf(\"\\b) \");\n\t}\n\tif (minor_total) {\n\t\tprintf(\"%llu minor (\", minor_total);\n\t\tfor (i = 0; i < n_cpus; i++)\n\t\t\tprintf(\"%lu+\", args[i].minor_faults);\n\t\tprintf(\"\\b)\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint userfaultfd_open(uint64_t *features)\n{\n\tstruct uffdio_api uffdio_api;\n\n\tuffd = uffd_open(UFFD_FLAGS);\n\tif (uffd < 0)\n\t\treturn -1;\n\tuffd_flags = fcntl(uffd, F_GETFD, NULL);\n\n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = *features;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api))\n\t\t \n\t\treturn -1;\n\tif (uffdio_api.api != UFFD_API)\n\t\terr(\"UFFDIO_API error: %\" PRIu64, (uint64_t)uffdio_api.api);\n\n\t*features = uffdio_api.features;\n\treturn 0;\n}\n\nstatic inline void munmap_area(void **area)\n{\n\tif (*area)\n\t\tif (munmap(*area, nr_pages * page_size))\n\t\t\terr(\"munmap\");\n\n\t*area = NULL;\n}\n\nstatic void uffd_test_ctx_clear(void)\n{\n\tsize_t i;\n\n\tif (pipefd) {\n\t\tfor (i = 0; i < nr_cpus * 2; ++i) {\n\t\t\tif (close(pipefd[i]))\n\t\t\t\terr(\"close pipefd\");\n\t\t}\n\t\tfree(pipefd);\n\t\tpipefd = NULL;\n\t}\n\n\tif (count_verify) {\n\t\tfree(count_verify);\n\t\tcount_verify = NULL;\n\t}\n\n\tif (uffd != -1) {\n\t\tif (close(uffd))\n\t\t\terr(\"close uffd\");\n\t\tuffd = -1;\n\t}\n\n\tmunmap_area((void **)&area_src);\n\tmunmap_area((void **)&area_src_alias);\n\tmunmap_area((void **)&area_dst);\n\tmunmap_area((void **)&area_dst_alias);\n\tmunmap_area((void **)&area_remap);\n}\n\nint uffd_test_ctx_init(uint64_t features, const char **errmsg)\n{\n\tunsigned long nr, cpu;\n\tint ret;\n\n\tuffd_test_ctx_clear();\n\n\tret = uffd_test_ops->allocate_area((void **)&area_src, true);\n\tret |= uffd_test_ops->allocate_area((void **)&area_dst, false);\n\tif (ret) {\n\t\tif (errmsg)\n\t\t\t*errmsg = \"memory allocation failed\";\n\t\treturn ret;\n\t}\n\n\tret = userfaultfd_open(&features);\n\tif (ret) {\n\t\tif (errmsg)\n\t\t\t*errmsg = \"possible lack of priviledge\";\n\t\treturn ret;\n\t}\n\n\tcount_verify = malloc(nr_pages * sizeof(unsigned long long));\n\tif (!count_verify)\n\t\terr(\"count_verify\");\n\n\tfor (nr = 0; nr < nr_pages; nr++) {\n\t\t*area_mutex(area_src, nr) =\n\t\t\t(pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;\n\t\tcount_verify[nr] = *area_count(area_src, nr) = 1;\n\t\t \n\t\t*(area_count(area_src, nr) + 1) = 1;\n\t}\n\n\t \n\tuffd_test_ops->release_pages(area_dst);\n\n\tpipefd = malloc(sizeof(int) * nr_cpus * 2);\n\tif (!pipefd)\n\t\terr(\"pipefd\");\n\tfor (cpu = 0; cpu < nr_cpus; cpu++)\n\t\tif (pipe2(&pipefd[cpu * 2], O_CLOEXEC | O_NONBLOCK))\n\t\t\terr(\"pipe\");\n\n\treturn 0;\n}\n\nvoid wp_range(int ufd, __u64 start, __u64 len, bool wp)\n{\n\tstruct uffdio_writeprotect prms;\n\n\t \n\tprms.range.start = start;\n\tprms.range.len = len;\n\t \n\tprms.mode = wp ? UFFDIO_WRITEPROTECT_MODE_WP : 0;\n\n\tif (ioctl(ufd, UFFDIO_WRITEPROTECT, &prms))\n\t\terr(\"clear WP failed: address=0x%\"PRIx64, (uint64_t)start);\n}\n\nstatic void continue_range(int ufd, __u64 start, __u64 len, bool wp)\n{\n\tstruct uffdio_continue req;\n\tint ret;\n\n\treq.range.start = start;\n\treq.range.len = len;\n\treq.mode = 0;\n\tif (wp)\n\t\treq.mode |= UFFDIO_CONTINUE_MODE_WP;\n\n\tif (ioctl(ufd, UFFDIO_CONTINUE, &req))\n\t\terr(\"UFFDIO_CONTINUE failed for address 0x%\" PRIx64,\n\t\t    (uint64_t)start);\n\n\t \n\treq.mapped = 0;\n\tret = ioctl(ufd, UFFDIO_CONTINUE, &req);\n\tif (ret >= 0 || req.mapped != -EEXIST)\n\t\terr(\"failed to exercise UFFDIO_CONTINUE error handling, ret=%d, mapped=%\" PRId64,\n\t\t    ret, (int64_t) req.mapped);\n}\n\nint uffd_read_msg(int ufd, struct uffd_msg *msg)\n{\n\tint ret = read(uffd, msg, sizeof(*msg));\n\n\tif (ret != sizeof(*msg)) {\n\t\tif (ret < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 1;\n\t\t\terr(\"blocking read error\");\n\t\t} else {\n\t\t\terr(\"short read\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid uffd_handle_page_fault(struct uffd_msg *msg, struct uffd_args *args)\n{\n\tunsigned long offset;\n\n\tif (msg->event != UFFD_EVENT_PAGEFAULT)\n\t\terr(\"unexpected msg event %u\", msg->event);\n\n\tif (msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WP) {\n\t\t \n\t\twp_range(uffd, msg->arg.pagefault.address, page_size, false);\n\t\targs->wp_faults++;\n\t} else if (msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_MINOR) {\n\t\tuint8_t *area;\n\t\tint b;\n\n\t\t \n\n\t\tarea = (uint8_t *)(area_dst +\n\t\t\t\t   ((char *)msg->arg.pagefault.address -\n\t\t\t\t    area_dst_alias));\n\t\tfor (b = 0; b < page_size; ++b)\n\t\t\tarea[b] = ~area[b];\n\t\tcontinue_range(uffd, msg->arg.pagefault.address, page_size,\n\t\t\t       args->apply_wp);\n\t\targs->minor_faults++;\n\t} else {\n\t\t \n\t\tif (msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE)\n\t\t\terr(\"unexpected write fault\");\n\n\t\toffset = (char *)(unsigned long)msg->arg.pagefault.address - area_dst;\n\t\toffset &= ~(page_size-1);\n\n\t\tif (copy_page(uffd, offset, args->apply_wp))\n\t\t\targs->missing_faults++;\n\t}\n}\n\nvoid *uffd_poll_thread(void *arg)\n{\n\tstruct uffd_args *args = (struct uffd_args *)arg;\n\tunsigned long cpu = args->cpu;\n\tstruct pollfd pollfd[2];\n\tstruct uffd_msg msg;\n\tstruct uffdio_register uffd_reg;\n\tint ret;\n\tchar tmp_chr;\n\n\tif (!args->handle_fault)\n\t\targs->handle_fault = uffd_handle_page_fault;\n\n\tpollfd[0].fd = uffd;\n\tpollfd[0].events = POLLIN;\n\tpollfd[1].fd = pipefd[cpu*2];\n\tpollfd[1].events = POLLIN;\n\n\tfor (;;) {\n\t\tret = poll(pollfd, 2, -1);\n\t\tif (ret <= 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\terr(\"poll error: %d\", ret);\n\t\t}\n\t\tif (pollfd[1].revents) {\n\t\t\tif (!(pollfd[1].revents & POLLIN))\n\t\t\t\terr(\"pollfd[1].revents %d\", pollfd[1].revents);\n\t\t\tif (read(pollfd[1].fd, &tmp_chr, 1) != 1)\n\t\t\t\terr(\"read pipefd error\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!(pollfd[0].revents & POLLIN))\n\t\t\terr(\"pollfd[0].revents %d\", pollfd[0].revents);\n\t\tif (uffd_read_msg(uffd, &msg))\n\t\t\tcontinue;\n\t\tswitch (msg.event) {\n\t\tdefault:\n\t\t\terr(\"unexpected msg event %u\\n\", msg.event);\n\t\t\tbreak;\n\t\tcase UFFD_EVENT_PAGEFAULT:\n\t\t\targs->handle_fault(&msg, args);\n\t\t\tbreak;\n\t\tcase UFFD_EVENT_FORK:\n\t\t\tclose(uffd);\n\t\t\tuffd = msg.arg.fork.ufd;\n\t\t\tpollfd[0].fd = uffd;\n\t\t\tbreak;\n\t\tcase UFFD_EVENT_REMOVE:\n\t\t\tuffd_reg.range.start = msg.arg.remove.start;\n\t\t\tuffd_reg.range.len = msg.arg.remove.end -\n\t\t\t\tmsg.arg.remove.start;\n\t\t\tif (ioctl(uffd, UFFDIO_UNREGISTER, &uffd_reg.range))\n\t\t\t\terr(\"remove failure\");\n\t\t\tbreak;\n\t\tcase UFFD_EVENT_REMAP:\n\t\t\tarea_remap = area_dst;   \n\t\t\tarea_dst = (char *)(unsigned long)msg.arg.remap.to;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void retry_copy_page(int ufd, struct uffdio_copy *uffdio_copy,\n\t\t\t    unsigned long offset)\n{\n\tuffd_test_ops->alias_mapping(&uffdio_copy->dst,\n\t\t\t\t     uffdio_copy->len,\n\t\t\t\t     offset);\n\tif (ioctl(ufd, UFFDIO_COPY, uffdio_copy)) {\n\t\t \n\t\tif (uffdio_copy->copy != -EEXIST)\n\t\t\terr(\"UFFDIO_COPY retry error: %\"PRId64,\n\t\t\t    (int64_t)uffdio_copy->copy);\n\t} else {\n\t\terr(\"UFFDIO_COPY retry unexpected: %\"PRId64,\n\t\t    (int64_t)uffdio_copy->copy);\n\t}\n}\n\nstatic void wake_range(int ufd, unsigned long addr, unsigned long len)\n{\n\tstruct uffdio_range uffdio_wake;\n\n\tuffdio_wake.start = addr;\n\tuffdio_wake.len = len;\n\n\tif (ioctl(ufd, UFFDIO_WAKE, &uffdio_wake))\n\t\tfprintf(stderr, \"error waking %lu\\n\",\n\t\t\taddr), exit(1);\n}\n\nint __copy_page(int ufd, unsigned long offset, bool retry, bool wp)\n{\n\tstruct uffdio_copy uffdio_copy;\n\n\tif (offset >= nr_pages * page_size)\n\t\terr(\"unexpected offset %lu\\n\", offset);\n\tuffdio_copy.dst = (unsigned long) area_dst + offset;\n\tuffdio_copy.src = (unsigned long) area_src + offset;\n\tuffdio_copy.len = page_size;\n\tif (wp)\n\t\tuffdio_copy.mode = UFFDIO_COPY_MODE_WP;\n\telse\n\t\tuffdio_copy.mode = 0;\n\tuffdio_copy.copy = 0;\n\tif (ioctl(ufd, UFFDIO_COPY, &uffdio_copy)) {\n\t\t \n\t\tif (uffdio_copy.copy != -EEXIST)\n\t\t\terr(\"UFFDIO_COPY error: %\"PRId64,\n\t\t\t    (int64_t)uffdio_copy.copy);\n\t\twake_range(ufd, uffdio_copy.dst, page_size);\n\t} else if (uffdio_copy.copy != page_size) {\n\t\terr(\"UFFDIO_COPY error: %\"PRId64, (int64_t)uffdio_copy.copy);\n\t} else {\n\t\tif (test_uffdio_copy_eexist && retry) {\n\t\t\ttest_uffdio_copy_eexist = false;\n\t\t\tretry_copy_page(ufd, &uffdio_copy, offset);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint copy_page(int ufd, unsigned long offset, bool wp)\n{\n\treturn __copy_page(ufd, offset, false, wp);\n}\n\nint uffd_open_dev(unsigned int flags)\n{\n\tint fd, uffd;\n\n\tfd = open(\"/dev/userfaultfd\", O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\tuffd = ioctl(fd, USERFAULTFD_IOC_NEW, flags);\n\tclose(fd);\n\n\treturn uffd;\n}\n\nint uffd_open_sys(unsigned int flags)\n{\n#ifdef __NR_userfaultfd\n\treturn syscall(__NR_userfaultfd, flags);\n#else\n\treturn -1;\n#endif\n}\n\nint uffd_open(unsigned int flags)\n{\n\tint uffd = uffd_open_sys(flags);\n\n\tif (uffd < 0)\n\t\tuffd = uffd_open_dev(flags);\n\n\treturn uffd;\n}\n\nint uffd_get_features(uint64_t *features)\n{\n\tstruct uffdio_api uffdio_api = { .api = UFFD_API, .features = 0 };\n\t \n\tint fd = uffd_open(UFFD_USER_MODE_ONLY);\n\n\tif (fd < 0)\n\t\t \n\t\tfd = uffd_open(0);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (ioctl(fd, UFFDIO_API, &uffdio_api)) {\n\t\tclose(fd);\n\t\treturn -errno;\n\t}\n\n\t*features = uffdio_api.features;\n\tclose(fd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}