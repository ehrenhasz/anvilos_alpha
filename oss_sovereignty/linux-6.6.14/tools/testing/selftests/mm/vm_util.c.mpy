{
  "module_name": "vm_util.c",
  "hash_id": "1efdb849d784cecf988125bcde17e96ddb666efe8f234dca74ad8813efae7399",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mm/vm_util.c",
  "human_readable_source": "\n#include <string.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <sys/ioctl.h>\n#include <linux/userfaultfd.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"../kselftest.h\"\n#include \"vm_util.h\"\n\n#define PMD_SIZE_FILE_PATH \"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\"\n#define SMAP_FILE_PATH \"/proc/self/smaps\"\n#define MAX_LINE_LENGTH 500\n\nunsigned int __page_size;\nunsigned int __page_shift;\n\nuint64_t pagemap_get_entry(int fd, char *start)\n{\n\tconst unsigned long pfn = (unsigned long)start / getpagesize();\n\tuint64_t entry;\n\tint ret;\n\n\tret = pread(fd, &entry, sizeof(entry), pfn * sizeof(entry));\n\tif (ret != sizeof(entry))\n\t\tksft_exit_fail_msg(\"reading pagemap failed\\n\");\n\treturn entry;\n}\n\nbool pagemap_is_softdirty(int fd, char *start)\n{\n\treturn pagemap_get_entry(fd, start) & PM_SOFT_DIRTY;\n}\n\nbool pagemap_is_swapped(int fd, char *start)\n{\n\treturn pagemap_get_entry(fd, start) & PM_SWAP;\n}\n\nbool pagemap_is_populated(int fd, char *start)\n{\n\treturn pagemap_get_entry(fd, start) & (PM_PRESENT | PM_SWAP);\n}\n\nunsigned long pagemap_get_pfn(int fd, char *start)\n{\n\tuint64_t entry = pagemap_get_entry(fd, start);\n\n\t \n\tif (entry & PM_PRESENT)\n\t\treturn entry & 0x007fffffffffffffull;\n\treturn -1ul;\n}\n\nvoid clear_softdirty(void)\n{\n\tint ret;\n\tconst char *ctrl = \"4\";\n\tint fd = open(\"/proc/self/clear_refs\", O_WRONLY);\n\n\tif (fd < 0)\n\t\tksft_exit_fail_msg(\"opening clear_refs failed\\n\");\n\tret = write(fd, ctrl, strlen(ctrl));\n\tclose(fd);\n\tif (ret != strlen(ctrl))\n\t\tksft_exit_fail_msg(\"writing clear_refs failed\\n\");\n}\n\nbool check_for_pattern(FILE *fp, const char *pattern, char *buf, size_t len)\n{\n\twhile (fgets(buf, len, fp)) {\n\t\tif (!strncmp(buf, pattern, strlen(pattern)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nuint64_t read_pmd_pagesize(void)\n{\n\tint fd;\n\tchar buf[20];\n\tssize_t num_read;\n\n\tfd = open(PMD_SIZE_FILE_PATH, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnum_read = read(fd, buf, 19);\n\tif (num_read < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tbuf[num_read] = '\\0';\n\tclose(fd);\n\n\treturn strtoul(buf, NULL, 10);\n}\n\nbool __check_huge(void *addr, char *pattern, int nr_hpages,\n\t\t  uint64_t hpage_size)\n{\n\tuint64_t thp = -1;\n\tint ret;\n\tFILE *fp;\n\tchar buffer[MAX_LINE_LENGTH];\n\tchar addr_pattern[MAX_LINE_LENGTH];\n\n\tret = snprintf(addr_pattern, MAX_LINE_LENGTH, \"%08lx-\",\n\t\t       (unsigned long) addr);\n\tif (ret >= MAX_LINE_LENGTH)\n\t\tksft_exit_fail_msg(\"%s: Pattern is too long\\n\", __func__);\n\n\tfp = fopen(SMAP_FILE_PATH, \"r\");\n\tif (!fp)\n\t\tksft_exit_fail_msg(\"%s: Failed to open file %s\\n\", __func__, SMAP_FILE_PATH);\n\n\tif (!check_for_pattern(fp, addr_pattern, buffer, sizeof(buffer)))\n\t\tgoto err_out;\n\n\t \n\tif (!check_for_pattern(fp, pattern, buffer, sizeof(buffer)))\n\t\tgoto err_out;\n\n\tsnprintf(addr_pattern, MAX_LINE_LENGTH, \"%s%%9ld kB\", pattern);\n\n\tif (sscanf(buffer, addr_pattern, &thp) != 1)\n\t\tksft_exit_fail_msg(\"Reading smap error\\n\");\n\nerr_out:\n\tfclose(fp);\n\treturn thp == (nr_hpages * (hpage_size >> 10));\n}\n\nbool check_huge_anon(void *addr, int nr_hpages, uint64_t hpage_size)\n{\n\treturn __check_huge(addr, \"AnonHugePages: \", nr_hpages, hpage_size);\n}\n\nbool check_huge_file(void *addr, int nr_hpages, uint64_t hpage_size)\n{\n\treturn __check_huge(addr, \"FilePmdMapped:\", nr_hpages, hpage_size);\n}\n\nbool check_huge_shmem(void *addr, int nr_hpages, uint64_t hpage_size)\n{\n\treturn __check_huge(addr, \"ShmemPmdMapped:\", nr_hpages, hpage_size);\n}\n\nint64_t allocate_transhuge(void *ptr, int pagemap_fd)\n{\n\tuint64_t ent[2];\n\n\t \n\tif (mmap(ptr, HPAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t MAP_FIXED | MAP_ANONYMOUS |\n\t\t MAP_NORESERVE | MAP_PRIVATE, -1, 0) != ptr)\n\t\terrx(2, \"mmap transhuge\");\n\n\tif (madvise(ptr, HPAGE_SIZE, MADV_HUGEPAGE))\n\t\terr(2, \"MADV_HUGEPAGE\");\n\n\t \n\t*(volatile void **)ptr = ptr;\n\n\tif (pread(pagemap_fd, ent, sizeof(ent),\n\t\t  (uintptr_t)ptr >> (pshift() - 3)) != sizeof(ent))\n\t\terr(2, \"read pagemap\");\n\n\tif (PAGEMAP_PRESENT(ent[0]) && PAGEMAP_PRESENT(ent[1]) &&\n\t    PAGEMAP_PFN(ent[0]) + 1 == PAGEMAP_PFN(ent[1]) &&\n\t    !(PAGEMAP_PFN(ent[0]) & ((1 << (HPAGE_SHIFT - pshift())) - 1)))\n\t\treturn PAGEMAP_PFN(ent[0]);\n\n\treturn -1;\n}\n\nunsigned long default_huge_page_size(void)\n{\n\tunsigned long hps = 0;\n\tchar *line = NULL;\n\tsize_t linelen = 0;\n\tFILE *f = fopen(\"/proc/meminfo\", \"r\");\n\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) > 0) {\n\t\tif (sscanf(line, \"Hugepagesize:       %lu kB\", &hps) == 1) {\n\t\t\thps <<= 10;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\treturn hps;\n}\n\nint detect_hugetlb_page_sizes(size_t sizes[], int max)\n{\n\tDIR *dir = opendir(\"/sys/kernel/mm/hugepages/\");\n\tint count = 0;\n\n\tif (!dir)\n\t\treturn 0;\n\n\twhile (count < max) {\n\t\tstruct dirent *entry = readdir(dir);\n\t\tsize_t kb;\n\n\t\tif (!entry)\n\t\t\tbreak;\n\t\tif (entry->d_type != DT_DIR)\n\t\t\tcontinue;\n\t\tif (sscanf(entry->d_name, \"hugepages-%zukB\", &kb) != 1)\n\t\t\tcontinue;\n\t\tsizes[count++] = kb * 1024;\n\t\tksft_print_msg(\"[INFO] detected hugetlb page size: %zu KiB\\n\",\n\t\t\t       kb);\n\t}\n\tclosedir(dir);\n\treturn count;\n}\n\n \nint uffd_register_with_ioctls(int uffd, void *addr, uint64_t len,\n\t\t\t      bool miss, bool wp, bool minor, uint64_t *ioctls)\n{\n\tstruct uffdio_register uffdio_register = { 0 };\n\tuint64_t mode = 0;\n\tint ret = 0;\n\n\tif (miss)\n\t\tmode |= UFFDIO_REGISTER_MODE_MISSING;\n\tif (wp)\n\t\tmode |= UFFDIO_REGISTER_MODE_WP;\n\tif (minor)\n\t\tmode |= UFFDIO_REGISTER_MODE_MINOR;\n\n\tuffdio_register.range.start = (unsigned long)addr;\n\tuffdio_register.range.len = len;\n\tuffdio_register.mode = mode;\n\n\tif (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n\t\tret = -errno;\n\telse if (ioctls)\n\t\t*ioctls = uffdio_register.ioctls;\n\n\treturn ret;\n}\n\nint uffd_register(int uffd, void *addr, uint64_t len,\n\t\t  bool miss, bool wp, bool minor)\n{\n\treturn uffd_register_with_ioctls(uffd, addr, len,\n\t\t\t\t\t miss, wp, minor, NULL);\n}\n\nint uffd_unregister(int uffd, void *addr, uint64_t len)\n{\n\tstruct uffdio_range range = { .start = (uintptr_t)addr, .len = len };\n\tint ret = 0;\n\n\tif (ioctl(uffd, UFFDIO_UNREGISTER, &range) == -1)\n\t\tret = -errno;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}