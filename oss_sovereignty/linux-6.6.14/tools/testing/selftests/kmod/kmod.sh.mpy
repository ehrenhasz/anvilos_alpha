{
  "module_name": "kmod.sh",
  "hash_id": "d983f782313ac959990bb69ca60bd4d34a7f6f17d39e0d753f32a795ecd0f509",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kmod/kmod.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0-or-later OR copyleft-next-0.3.1\n# Copyright (C) 2017 Luis R. Rodriguez <mcgrof@kernel.org>\n#\n# This is a stress test script for kmod, the kernel module loader. It uses\n# test_kmod which exposes a series of knobs for the API for us so we can\n# tweak each test in userspace rather than in kernelspace.\n#\n# The way kmod works is it uses the kernel's usermode helper API to eventually\n# call /sbin/modprobe. It has a limit of the number of concurrent calls\n# possible. The kernel interface to load modules is request_module(), however\n# mount uses get_fs_type(). Both behave slightly differently, but the\n# differences are important enough to test each call separately. For this\n# reason test_kmod starts by providing tests for both calls.\n#\n# The test driver test_kmod assumes a series of defaults which you can\n# override by exporting to your environment prior running this script.\n# For instance this script assumes you do not have xfs loaded upon boot.\n# If this is false, export DEFAULT_KMOD_FS=\"ext4\" prior to running this\n# script if the filesystem module you don't have loaded upon bootup\n# is ext4 instead. Refer to allow_user_defaults() for a list of user\n# override variables possible.\n#\n# You'll want at least 4 GiB of RAM to expect to run these tests\n# without running out of memory on them. For other requirements refer\n# to test_reqs()\n\nset -e\n\nTEST_NAME=\"kmod\"\nTEST_DRIVER=\"test_${TEST_NAME}\"\nTEST_DIR=$(dirname $0)\n\n# This represents\n#\n# TEST_ID:TEST_COUNT:ENABLED\n#\n# TEST_ID: is the test id number\n# TEST_COUNT: number of times we should run the test\n# ENABLED: 1 if enabled, 0 otherwise\n#\n# Once these are enabled please leave them as-is. Write your own test,\n# we have tons of space.\nALL_TESTS=\"0001:3:1\"\nALL_TESTS=\"$ALL_TESTS 0002:3:1\"\nALL_TESTS=\"$ALL_TESTS 0003:1:1\"\nALL_TESTS=\"$ALL_TESTS 0004:1:1\"\nALL_TESTS=\"$ALL_TESTS 0005:10:1\"\nALL_TESTS=\"$ALL_TESTS 0006:10:1\"\nALL_TESTS=\"$ALL_TESTS 0007:5:1\"\nALL_TESTS=\"$ALL_TESTS 0008:150:1\"\nALL_TESTS=\"$ALL_TESTS 0009:150:1\"\nALL_TESTS=\"$ALL_TESTS 0010:1:1\"\nALL_TESTS=\"$ALL_TESTS 0011:1:1\"\nALL_TESTS=\"$ALL_TESTS 0012:1:1\"\nALL_TESTS=\"$ALL_TESTS 0013:1:1\"\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\ntest_modprobe()\n{\n       if [ ! -d $DIR ]; then\n               echo \"$0: $DIR not present\" >&2\n               echo \"You must have the following enabled in your kernel:\" >&2\n               cat $TEST_DIR/config >&2\n               exit $ksft_skip\n       fi\n}\n\nfunction allow_user_defaults()\n{\n\tif [ -z $DEFAULT_KMOD_DRIVER ]; then\n\t\tDEFAULT_KMOD_DRIVER=\"test_module\"\n\tfi\n\n\tif [ -z $DEFAULT_KMOD_FS ]; then\n\t\tDEFAULT_KMOD_FS=\"xfs\"\n\tfi\n\n\tif [ -z $PROC_DIR ]; then\n\t\tPROC_DIR=\"/proc/sys/kernel/\"\n\tfi\n\n\tif [ -z $MODPROBE_LIMIT ]; then\n\t\tMODPROBE_LIMIT=50\n\tfi\n\n\tif [ -z $DIR ]; then\n\t\tDIR=\"/sys/devices/virtual/misc/${TEST_DRIVER}0/\"\n\tfi\n\n\tif [ -z $DEFAULT_NUM_TESTS ]; then\n\t\tDEFAULT_NUM_TESTS=150\n\tfi\n\n\tMODPROBE_LIMIT_FILE=\"${PROC_DIR}/kmod-limit\"\n}\n\ntest_reqs()\n{\n\tif ! which modprobe 2> /dev/null > /dev/null; then\n\t\techo \"$0: You need modprobe installed\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\tif ! which kmod 2> /dev/null > /dev/null; then\n\t\techo \"$0: You need kmod installed\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\t# kmod 19 has a bad bug where it returns 0 when modprobe\n\t# gets called *even* if the module was not loaded due to\n\t# some bad heuristics. For details see:\n\t#\n\t# A work around is possible in-kernel but its rather\n\t# complex.\n\tKMOD_VERSION=$(kmod --version | awk '{print $3}')\n\tif [[ $KMOD_VERSION  -le 19 ]]; then\n\t\techo \"$0: You need at least kmod 20\" >&2\n\t\techo \"kmod <= 19 is buggy, for details see:\" >&2\n\t\techo \"https://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/commit/libkmod/libkmod-module.c?id=fd44a98ae2eb5eb32161088954ab21e58e19dfc4\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\tuid=$(id -u)\n\tif [ $uid -ne 0 ]; then\n\t\techo $msg must be run as root >&2\n\t\texit $ksft_skip\n\tfi\n}\n\nfunction load_req_mod()\n{\n\ttrap \"test_modprobe\" EXIT\n\n\tif [ ! -d $DIR ]; then\n\t\t# Alanis: \"Oh isn't it ironic?\"\n\t\tmodprobe $TEST_DRIVER\n\tfi\n}\n\ntest_finish()\n{\n\techo \"$MODPROBE\" > /proc/sys/kernel/modprobe\n\techo \"Test completed\"\n}\n\nerrno_name_to_val()\n{\n\tcase \"$1\" in\n\t# kmod calls modprobe and upon of a module not found\n\t# modprobe returns just 1... However in the kernel we\n\t# *sometimes* see 256...\n\tMODULE_NOT_FOUND)\n\t\techo 256;;\n\tSUCCESS)\n\t\techo 0;;\n\t-EPERM)\n\t\techo -1;;\n\t-ENOENT)\n\t\techo -2;;\n\t-EINVAL)\n\t\techo -22;;\n\t-ERR_ANY)\n\t\techo -123456;;\n\t*)\n\t\techo invalid;;\n\tesac\n}\n\nerrno_val_to_name()\n\tcase \"$1\" in\n\t256)\n\t\techo MODULE_NOT_FOUND;;\n\t0)\n\t\techo SUCCESS;;\n\t-1)\n\t\techo -EPERM;;\n\t-2)\n\t\techo -ENOENT;;\n\t-22)\n\t\techo -EINVAL;;\n\t-123456)\n\t\techo -ERR_ANY;;\n\t*)\n\t\techo invalid;;\n\tesac\n\nconfig_set_test_case_driver()\n{\n\tif ! echo -n 1 >$DIR/config_test_case; then\n\t\techo \"$0: Unable to set to test case to driver\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_set_test_case_fs()\n{\n\tif ! echo -n 2 >$DIR/config_test_case; then\n\t\techo \"$0: Unable to set to test case to fs\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_num_threads()\n{\n\tif ! echo -n $1 >$DIR/config_num_threads; then\n\t\techo \"$0: Unable to set to number of threads\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_get_modprobe_limit()\n{\n\tif [[ -f ${MODPROBE_LIMIT_FILE} ]] ; then\n\t\tMODPROBE_LIMIT=$(cat $MODPROBE_LIMIT_FILE)\n\tfi\n\techo $MODPROBE_LIMIT\n}\n\nconfig_num_thread_limit_extra()\n{\n\tMODPROBE_LIMIT=$(config_get_modprobe_limit)\n\tlet EXTRA_LIMIT=$MODPROBE_LIMIT+$1\n\tconfig_num_threads $EXTRA_LIMIT\n}\n\n# For special characters use printf directly,\n# refer to kmod_test_0001\nconfig_set_driver()\n{\n\tif ! echo -n $1 >$DIR/config_test_driver; then\n\t\techo \"$0: Unable to set driver\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_set_fs()\n{\n\tif ! echo -n $1 >$DIR/config_test_fs; then\n\t\techo \"$0: Unable to set driver\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_get_driver()\n{\n\tcat $DIR/config_test_driver\n}\n\nconfig_get_test_result()\n{\n\tcat $DIR/test_result\n}\n\nconfig_reset()\n{\n\tif ! echo -n \"1\" >\"$DIR\"/reset; then\n\t\techo \"$0: reset should have worked\" >&2\n\t\texit 1\n\tfi\n}\n\nconfig_show_config()\n{\n\techo \"----------------------------------------------------\"\n\tcat \"$DIR\"/config\n\techo \"----------------------------------------------------\"\n}\n\nconfig_trigger()\n{\n\tif ! echo -n \"1\" >\"$DIR\"/trigger_config 2>/dev/null; then\n\t\techo \"$1: FAIL - loading should have worked\"\n\t\tconfig_show_config\n\t\texit 1\n\tfi\n\techo \"$1: OK! - loading kmod test\"\n}\n\nconfig_trigger_want_fail()\n{\n\tif echo \"1\" > $DIR/trigger_config 2>/dev/null; then\n\t\techo \"$1: FAIL - test case was expected to fail\"\n\t\tconfig_show_config\n\t\texit 1\n\tfi\n\techo \"$1: OK! - kmod test case failed as expected\"\n}\n\nconfig_expect_result()\n{\n\tRC=$(config_get_test_result)\n\tRC_NAME=$(errno_val_to_name $RC)\n\n\tERRNO_NAME=$2\n\tERRNO=$(errno_name_to_val $ERRNO_NAME)\n\n\tif [[ $ERRNO_NAME = \"-ERR_ANY\" ]]; then\n\t\tif [[ $RC -ge 0 ]]; then\n\t\t\techo \"$1: FAIL, test expects $ERRNO_NAME - got $RC_NAME ($RC)\" >&2\n\t\t\tconfig_show_config\n\t\t\texit 1\n\t\tfi\n\telif [[ $RC != $ERRNO ]]; then\n\t\techo \"$1: FAIL, test expects $ERRNO_NAME ($ERRNO) - got $RC_NAME ($RC)\" >&2\n\t\tconfig_show_config\n\t\texit 1\n\tfi\n\techo \"$1: OK! - Return value: $RC ($RC_NAME), expected $ERRNO_NAME\"\n}\n\nkmod_defaults_driver()\n{\n\tconfig_reset\n\tmodprobe -r $DEFAULT_KMOD_DRIVER\n\tconfig_set_driver $DEFAULT_KMOD_DRIVER\n}\n\nkmod_defaults_fs()\n{\n\tconfig_reset\n\tmodprobe -r $DEFAULT_KMOD_FS\n\tconfig_set_fs $DEFAULT_KMOD_FS\n\tconfig_set_test_case_fs\n}\n\nkmod_test_0001_driver()\n{\n\tNAME='\\000'\n\n\tkmod_defaults_driver\n\tconfig_num_threads 1\n\tprintf $NAME >\"$DIR\"/config_test_driver\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} MODULE_NOT_FOUND\n}\n\nkmod_test_0001_fs()\n{\n\tNAME='\\000'\n\n\tkmod_defaults_fs\n\tconfig_num_threads 1\n\tprintf $NAME >\"$DIR\"/config_test_fs\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} -EINVAL\n}\n\nkmod_test_0001()\n{\n\tkmod_test_0001_driver\n\tkmod_test_0001_fs\n}\n\nkmod_test_0002_driver()\n{\n\tNAME=\"nope-$DEFAULT_KMOD_DRIVER\"\n\n\tkmod_defaults_driver\n\tconfig_set_driver $NAME\n\tconfig_num_threads 1\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} MODULE_NOT_FOUND\n}\n\nkmod_test_0002_fs()\n{\n\tNAME=\"nope-$DEFAULT_KMOD_FS\"\n\n\tkmod_defaults_fs\n\tconfig_set_fs $NAME\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} -EINVAL\n}\n\nkmod_test_0002()\n{\n\tkmod_test_0002_driver\n\tkmod_test_0002_fs\n}\n\nkmod_test_0003()\n{\n\tkmod_defaults_fs\n\tconfig_num_threads 1\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0004()\n{\n\tkmod_defaults_fs\n\tconfig_num_threads 2\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0005()\n{\n\tkmod_defaults_driver\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0006()\n{\n\tkmod_defaults_fs\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0007()\n{\n\tkmod_test_0005\n\tkmod_test_0006\n}\n\nkmod_test_0008()\n{\n\tkmod_defaults_driver\n\tMODPROBE_LIMIT=$(config_get_modprobe_limit)\n\tlet EXTRA=$MODPROBE_LIMIT/6\n\tconfig_num_thread_limit_extra $EXTRA\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0009()\n{\n\tkmod_defaults_fs\n\tMODPROBE_LIMIT=$(config_get_modprobe_limit)\n\tlet EXTRA=$MODPROBE_LIMIT/4\n\tconfig_num_thread_limit_extra $EXTRA\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} SUCCESS\n}\n\nkmod_test_0010()\n{\n\tkmod_defaults_driver\n\tconfig_num_threads 1\n\techo \"/KMOD_TEST_NONEXISTENT\" > /proc/sys/kernel/modprobe\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} -ENOENT\n\techo \"$MODPROBE\" > /proc/sys/kernel/modprobe\n}\n\nkmod_test_0011()\n{\n\tkmod_defaults_driver\n\tconfig_num_threads 1\n\t# This causes the kernel to not even try executing modprobe.  The error\n\t# code is still -ENOENT like when modprobe doesn't exist, so we can't\n\t# easily test for the exact difference.  But this still is a useful test\n\t# since there was a bug where request_module() returned 0 in this case.\n\techo > /proc/sys/kernel/modprobe\n\tconfig_trigger ${FUNCNAME[0]}\n\tconfig_expect_result ${FUNCNAME[0]} -ENOENT\n\techo \"$MODPROBE\" > /proc/sys/kernel/modprobe\n}\n\nkmod_check_visibility()\n{\n\tlocal name=\"$1\"\n\tlocal cmd=\"$2\"\n\n\tmodprobe $DEFAULT_KMOD_DRIVER\n\n\tlocal priv=$(eval $cmd)\n\tlocal unpriv=$(capsh --drop=CAP_SYSLOG -- -c \"$cmd\")\n\n\tif [ \"$priv\" = \"$unpriv\" ] || \\\n\t   [ \"${priv:0:3}\" = \"0x0\" ] || \\\n\t   [ \"${unpriv:0:3}\" != \"0x0\" ] ; then\n\t\techo \"${FUNCNAME[0]}: FAIL, $name visible to unpriv: '$priv' vs '$unpriv'\" >&2\n\t\texit 1\n\telse\n\t\techo \"${FUNCNAME[0]}: OK!\"\n\tfi\n}\n\nkmod_test_0012()\n{\n\tkmod_check_visibility /proc/modules \\\n\t\t\"grep '^${DEFAULT_KMOD_DRIVER}\\b' /proc/modules | awk '{print \\$NF}'\"\n}\n\nkmod_test_0013()\n{\n\tkmod_check_visibility '/sys/module/*/sections/*' \\\n\t\t\"cat /sys/module/${DEFAULT_KMOD_DRIVER}/sections/.*text | head -n1\"\n}\n\nlist_tests()\n{\n\techo \"Test ID list:\"\n\techo\n\techo \"TEST_ID x NUM_TEST\"\n\techo \"TEST_ID:   Test ID\"\n\techo \"NUM_TESTS: Number of recommended times to run the test\"\n\techo\n\techo \"0001 x $(get_test_count 0001) - Simple test - 1 thread  for empty string\"\n\techo \"0002 x $(get_test_count 0002) - Simple test - 1 thread  for modules/filesystems that do not exist\"\n\techo \"0003 x $(get_test_count 0003) - Simple test - 1 thread  for get_fs_type() only\"\n\techo \"0004 x $(get_test_count 0004) - Simple test - 2 threads for get_fs_type() only\"\n\techo \"0005 x $(get_test_count 0005) - multithreaded tests with default setup - request_module() only\"\n\techo \"0006 x $(get_test_count 0006) - multithreaded tests with default setup - get_fs_type() only\"\n\techo \"0007 x $(get_test_count 0007) - multithreaded tests with default setup test request_module() and get_fs_type()\"\n\techo \"0008 x $(get_test_count 0008) - multithreaded - push kmod_concurrent over max_modprobes for request_module()\"\n\techo \"0009 x $(get_test_count 0009) - multithreaded - push kmod_concurrent over max_modprobes for get_fs_type()\"\n\techo \"0010 x $(get_test_count 0010) - test nonexistent modprobe path\"\n\techo \"0011 x $(get_test_count 0011) - test completely disabling module autoloading\"\n\techo \"0012 x $(get_test_count 0012) - test /proc/modules address visibility under CAP_SYSLOG\"\n\techo \"0013 x $(get_test_count 0013) - test /sys/module/*/sections/* visibility under CAP_SYSLOG\"\n}\n\nusage()\n{\n\tNUM_TESTS=$(grep -o ' ' <<<\"$ALL_TESTS\" | grep -c .)\n\tlet NUM_TESTS=$NUM_TESTS+1\n\tMAX_TEST=$(printf \"%04d\\n\" $NUM_TESTS)\n\techo \"Usage: $0 [ -t <4-number-digit> ] | [ -w <4-number-digit> ] |\"\n\techo \"\t\t [ -s <4-number-digit> ] | [ -c <4-number-digit> <test- count>\"\n\techo \"           [ all ] [ -h | --help ] [ -l ]\"\n\techo \"\"\n\techo \"Valid tests: 0001-$MAX_TEST\"\n\techo \"\"\n\techo \"    all     Runs all tests (default)\"\n\techo \"    -t      Run test ID the number amount of times is recommended\"\n\techo \"    -w      Watch test ID run until it runs into an error\"\n\techo \"    -s      Run test ID once\"\n\techo \"    -c      Run test ID x test-count number of times\"\n\techo \"    -l      List all test ID list\"\n\techo \" -h|--help  Help\"\n\techo\n\techo \"If an error every occurs execution will immediately terminate.\"\n\techo \"If you are adding a new test try using -w <test-ID> first to\"\n\techo \"make sure the test passes a series of tests.\"\n\techo\n\techo Example uses:\n\techo\n\techo \"${TEST_NAME}.sh\t\t-- executes all tests\"\n\techo \"${TEST_NAME}.sh -t 0008\t-- Executes test ID 0008 number of times is recommended\"\n\techo \"${TEST_NAME}.sh -w 0008\t-- Watch test ID 0008 run until an error occurs\"\n\techo \"${TEST_NAME}.sh -s 0008\t-- Run test ID 0008 once\"\n\techo \"${TEST_NAME}.sh -c 0008 3\t-- Run test ID 0008 three times\"\n\techo\n\tlist_tests\n\texit 1\n}\n\nfunction test_num()\n{\n\tre='^[0-9]+$'\n\tif ! [[ $1 =~ $re ]]; then\n\t\tusage\n\tfi\n}\n\nfunction get_test_data()\n{\n\ttest_num $1\n\tlocal field_num=$(echo $1 | sed 's/^0*//')\n\techo $ALL_TESTS | awk '{print $'$field_num'}'\n}\n\nfunction get_test_count()\n{\n\tTEST_DATA=$(get_test_data $1)\n\tLAST_TWO=${TEST_DATA#*:*}\n\techo ${LAST_TWO%:*}\n}\n\nfunction get_test_enabled()\n{\n\tTEST_DATA=$(get_test_data $1)\n\techo ${TEST_DATA#*:*:}\n}\n\nfunction run_all_tests()\n{\n\tfor i in $ALL_TESTS ; do\n\t\tTEST_ID=${i%:*:*}\n\t\tENABLED=$(get_test_enabled $TEST_ID)\n\t\tTEST_COUNT=$(get_test_count $TEST_ID)\n\t\tif [[ $ENABLED -eq \"1\" ]]; then\n\t\t\ttest_case $TEST_ID $TEST_COUNT\n\t\tfi\n\tdone\n}\n\nfunction watch_log()\n{\n\tif [ $# -ne 3 ]; then\n\t\tclear\n\tfi\n\tdate\n\techo \"Running test: $2 - run #$1\"\n}\n\nfunction watch_case()\n{\n\ti=0\n\twhile [ 1 ]; do\n\n\t\tif [ $# -eq 1 ]; then\n\t\t\ttest_num $1\n\t\t\twatch_log $i ${TEST_NAME}_test_$1\n\t\t\t${TEST_NAME}_test_$1\n\t\telse\n\t\t\twatch_log $i all\n\t\t\trun_all_tests\n\t\tfi\n\t\tlet i=$i+1\n\tdone\n}\n\nfunction test_case()\n{\n\tNUM_TESTS=$DEFAULT_NUM_TESTS\n\tif [ $# -eq 2 ]; then\n\t\tNUM_TESTS=$2\n\tfi\n\n\ti=0\n\twhile [ $i -lt $NUM_TESTS ]; do\n\t\ttest_num $1\n\t\twatch_log $i ${TEST_NAME}_test_$1 noclear\n\t\tRUN_TEST=${TEST_NAME}_test_$1\n\t\t$RUN_TEST\n\t\tlet i=$i+1\n\tdone\n}\n\nfunction parse_args()\n{\n\tif [ $# -eq 0 ]; then\n\t\trun_all_tests\n\telse\n\t\tif [[ \"$1\" = \"all\" ]]; then\n\t\t\trun_all_tests\n\t\telif [[ \"$1\" = \"-w\" ]]; then\n\t\t\tshift\n\t\t\twatch_case $@\n\t\telif [[ \"$1\" = \"-t\" ]]; then\n\t\t\tshift\n\t\t\ttest_num $1\n\t\t\ttest_case $1 $(get_test_count $1)\n\t\telif [[ \"$1\" = \"-c\" ]]; then\n\t\t\tshift\n\t\t\ttest_num $1\n\t\t\ttest_num $2\n\t\t\ttest_case $1 $2\n\t\telif [[ \"$1\" = \"-s\" ]]; then\n\t\t\tshift\n\t\t\ttest_case $1 1\n\t\telif [[ \"$1\" = \"-l\" ]]; then\n\t\t\tlist_tests\n\t\telif [[ \"$1\" = \"-h\" || \"$1\" = \"--help\" ]]; then\n\t\t\tusage\n\t\telse\n\t\t\tusage\n\t\tfi\n\tfi\n}\n\ntest_reqs\nallow_user_defaults\nload_req_mod\n\nMODPROBE=$(</proc/sys/kernel/modprobe)\ntrap \"test_finish\" EXIT\n\nparse_args $@\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}