{
  "module_name": "sas.c",
  "hash_id": "2fe01698e5e2ecbf087c10a18600008d6ecc87728dd5b67be602221b947a35c2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sigaltstack/sas.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <ucontext.h>\n#include <alloca.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include <sys/auxv.h>\n\n#include \"../kselftest.h\"\n#include \"current_stack_pointer.h\"\n\n#ifndef SS_AUTODISARM\n#define SS_AUTODISARM  (1U << 31)\n#endif\n\n#ifndef AT_MINSIGSTKSZ\n#define AT_MINSIGSTKSZ\t51\n#endif\n\nstatic unsigned int stack_size;\nstatic void *sstack, *ustack;\nstatic ucontext_t uc, sc;\nstatic const char *msg = \"[OK]\\tStack preserved\";\nstatic const char *msg2 = \"[FAIL]\\tStack corrupted\";\nstruct stk_data {\n\tchar msg[128];\n\tint flag;\n};\n\nvoid my_usr1(int sig, siginfo_t *si, void *u)\n{\n\tchar *aa;\n\tint err;\n\tstack_t stk;\n\tstruct stk_data *p;\n\n\tif (sp < (unsigned long)sstack ||\n\t\t\tsp >= (unsigned long)sstack + stack_size) {\n\t\tksft_exit_fail_msg(\"SP is not on sigaltstack\\n\");\n\t}\n\t \n\taa = alloca(1024);\n\tassert(aa);\n\tp = (struct stk_data *)(aa + 512);\n\tstrcpy(p->msg, msg);\n\tp->flag = 1;\n\tksft_print_msg(\"[RUN]\\tsignal USR1\\n\");\n\terr = sigaltstack(NULL, &stk);\n\tif (err) {\n\t\tksft_exit_fail_msg(\"sigaltstack() - %s\\n\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (stk.ss_flags != SS_DISABLE)\n\t\tksft_test_result_fail(\"tss_flags=%x, should be SS_DISABLE\\n\",\n\t\t\t\tstk.ss_flags);\n\telse\n\t\tksft_test_result_pass(\n\t\t\t\t\"sigaltstack is disabled in sighandler\\n\");\n\tswapcontext(&sc, &uc);\n\tksft_print_msg(\"%s\\n\", p->msg);\n\tif (!p->flag) {\n\t\tksft_exit_fail_msg(\"[RUN]\\tAborting\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid my_usr2(int sig, siginfo_t *si, void *u)\n{\n\tchar *aa;\n\tstruct stk_data *p;\n\n\tksft_print_msg(\"[RUN]\\tsignal USR2\\n\");\n\taa = alloca(1024);\n\t \n\t \n\tp = memmem(aa, 1024, msg, strlen(msg));\n\tif (p) {\n\t\tksft_test_result_fail(\"sigaltstack re-used\\n\");\n\t\t \n\t\tstrcpy(p->msg, msg2);\n\t\t \n\t\tp->flag = 0;\n\t}\n}\n\nstatic void switch_fn(void)\n{\n\tksft_print_msg(\"[RUN]\\tswitched to user ctx\\n\");\n\traise(SIGUSR2);\n\tsetcontext(&sc);\n}\n\nint main(void)\n{\n\tstruct sigaction act;\n\tstack_t stk;\n\tint err;\n\n\t \n\tstack_size = getauxval(AT_MINSIGSTKSZ) + SIGSTKSZ;\n\tksft_print_msg(\"[NOTE]\\tthe stack size is %lu\\n\", stack_size);\n\n\tksft_print_header();\n\tksft_set_plan(3);\n\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = SA_ONSTACK | SA_SIGINFO;\n\tact.sa_sigaction = my_usr1;\n\tsigaction(SIGUSR1, &act, NULL);\n\tact.sa_sigaction = my_usr2;\n\tsigaction(SIGUSR2, &act, NULL);\n\tsstack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,\n\t\t      MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\tif (sstack == MAP_FAILED) {\n\t\tksft_exit_fail_msg(\"mmap() - %s\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\terr = sigaltstack(NULL, &stk);\n\tif (err) {\n\t\tksft_exit_fail_msg(\"sigaltstack() - %s\\n\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (stk.ss_flags == SS_DISABLE) {\n\t\tksft_test_result_pass(\n\t\t\t\t\"Initial sigaltstack state was SS_DISABLE\\n\");\n\t} else {\n\t\tksft_exit_fail_msg(\"Initial sigaltstack state was %x; \"\n\t\t       \"should have been SS_DISABLE\\n\", stk.ss_flags);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstk.ss_sp = sstack;\n\tstk.ss_size = stack_size;\n\tstk.ss_flags = SS_ONSTACK | SS_AUTODISARM;\n\terr = sigaltstack(&stk, NULL);\n\tif (err) {\n\t\tif (errno == EINVAL) {\n\t\t\tksft_test_result_skip(\n\t\t\t\t\"[NOTE]\\tThe running kernel doesn't support SS_AUTODISARM\\n\");\n\t\t\t \n\t\t\treturn 0;\n\t\t} else {\n\t\t\tksft_exit_fail_msg(\n\t\t\t\t\"sigaltstack(SS_ONSTACK | SS_AUTODISARM)  %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tustack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,\n\t\t      MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\tif (ustack == MAP_FAILED) {\n\t\tksft_exit_fail_msg(\"mmap() - %s\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\tgetcontext(&uc);\n\tuc.uc_link = NULL;\n\tuc.uc_stack.ss_sp = ustack;\n\tuc.uc_stack.ss_size = stack_size;\n\tmakecontext(&uc, switch_fn, 0);\n\traise(SIGUSR1);\n\n\terr = sigaltstack(NULL, &stk);\n\tif (err) {\n\t\tksft_exit_fail_msg(\"sigaltstack() - %s\\n\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (stk.ss_flags != SS_AUTODISARM) {\n\t\tksft_exit_fail_msg(\"ss_flags=%x, should be SS_AUTODISARM\\n\",\n\t\t\t\tstk.ss_flags);\n\t\texit(EXIT_FAILURE);\n\t}\n\tksft_test_result_pass(\n\t\t\t\"sigaltstack is still SS_AUTODISARM after signal\\n\");\n\n\tksft_exit_pass();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}