{
  "module_name": "tdc.py",
  "hash_id": "306fbeb4b4b1b0b63fb27dcc81410516ddf4543824d32f574866e1bc303eb425",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tc-testing/tdc.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\n\"\"\"\ntdc.py - Linux tc (Traffic Control) unit test driver\n\nCopyright (C) 2017 Lucas Bates <lucasb@mojatatu.com>\n\"\"\"\n\nimport re\nimport os\nimport sys\nimport argparse\nimport importlib\nimport json\nimport subprocess\nimport time\nimport traceback\nfrom collections import OrderedDict\nfrom string import Template\n\nfrom tdc_config import *\nfrom tdc_helper import *\n\nimport TdcPlugin\nfrom TdcResults import *\n\nclass PluginDependencyException(Exception):\n    def __init__(self, missing_pg):\n        self.missing_pg = missing_pg\n\nclass PluginMgrTestFail(Exception):\n    def __init__(self, stage, output, message):\n        self.stage = stage\n        self.output = output\n        self.message = message\n\nclass PluginMgr:\n    def __init__(self, argparser):\n        super().__init__()\n        self.plugins = {}\n        self.plugin_instances = []\n        self.failed_plugins = {}\n        self.argparser = argparser\n\n        # TODO, put plugins in order\n        plugindir = os.getenv('TDC_PLUGIN_DIR', './plugins')\n        for dirpath, dirnames, filenames in os.walk(plugindir):\n            for fn in filenames:\n                if (fn.endswith('.py') and\n                    not fn == '__init__.py' and\n                    not fn.startswith('#') and\n                    not fn.startswith('.#')):\n                    mn = fn[0:-3]\n                    foo = importlib.import_module('plugins.' + mn)\n                    self.plugins[mn] = foo\n                    self.plugin_instances.append(foo.SubPlugin())\n\n    def load_plugin(self, pgdir, pgname):\n        pgname = pgname[0:-3]\n        foo = importlib.import_module('{}.{}'.format(pgdir, pgname))\n        self.plugins[pgname] = foo\n        self.plugin_instances.append(foo.SubPlugin())\n        self.plugin_instances[-1].check_args(self.args, None)\n\n    def get_required_plugins(self, testlist):\n        '''\n        Get all required plugins from the list of test cases and return\n        all unique items.\n        '''\n        reqs = []\n        for t in testlist:\n            try:\n                if 'requires' in t['plugins']:\n                    if isinstance(t['plugins']['requires'], list):\n                        reqs.extend(t['plugins']['requires'])\n                    else:\n                        reqs.append(t['plugins']['requires'])\n            except KeyError:\n                continue\n        reqs = get_unique_item(reqs)\n        return reqs\n\n    def load_required_plugins(self, reqs, parser, args, remaining):\n        '''\n        Get all required plugins from the list of test cases and load any plugin\n        that is not already enabled.\n        '''\n        pgd = ['plugin-lib', 'plugin-lib-custom']\n        pnf = []\n\n        for r in reqs:\n            if r not in self.plugins:\n                fname = '{}.py'.format(r)\n                source_path = []\n                for d in pgd:\n                    pgpath = '{}/{}'.format(d, fname)\n                    if os.path.isfile(pgpath):\n                        source_path.append(pgpath)\n                if len(source_path) == 0:\n                    print('ERROR: unable to find required plugin {}'.format(r))\n                    pnf.append(fname)\n                    continue\n                elif len(source_path) > 1:\n                    print('WARNING: multiple copies of plugin {} found, using version found')\n                    print('at {}'.format(source_path[0]))\n                pgdir = source_path[0]\n                pgdir = pgdir.split('/')[0]\n                self.load_plugin(pgdir, fname)\n        if len(pnf) > 0:\n            raise PluginDependencyException(pnf)\n\n        parser = self.call_add_args(parser)\n        (args, remaining) = parser.parse_known_args(args=remaining, namespace=args)\n        return args\n\n    def call_pre_suite(self, testcount, testidlist):\n        for pgn_inst in self.plugin_instances:\n            pgn_inst.pre_suite(testcount, testidlist)\n\n    def call_post_suite(self, index):\n        for pgn_inst in reversed(self.plugin_instances):\n            pgn_inst.post_suite(index)\n\n    def call_pre_case(self, caseinfo, *, test_skip=False):\n        for pgn_inst in self.plugin_instances:\n            try:\n                pgn_inst.pre_case(caseinfo, test_skip)\n            except Exception as ee:\n                print('exception {} in call to pre_case for {} plugin'.\n                      format(ee, pgn_inst.__class__))\n                print('test_ordinal is {}'.format(test_ordinal))\n                print('testid is {}'.format(caseinfo['id']))\n                raise\n\n    def call_post_case(self):\n        for pgn_inst in reversed(self.plugin_instances):\n            pgn_inst.post_case()\n\n    def call_pre_execute(self):\n        for pgn_inst in self.plugin_instances:\n            pgn_inst.pre_execute()\n\n    def call_post_execute(self):\n        for pgn_inst in reversed(self.plugin_instances):\n            pgn_inst.post_execute()\n\n    def call_add_args(self, parser):\n        for pgn_inst in self.plugin_instances:\n            parser = pgn_inst.add_args(parser)\n        return parser\n\n    def call_check_args(self, args, remaining):\n        for pgn_inst in self.plugin_instances:\n            pgn_inst.check_args(args, remaining)\n\n    def call_adjust_command(self, stage, command):\n        for pgn_inst in self.plugin_instances:\n            command = pgn_inst.adjust_command(stage, command)\n        return command\n\n    def set_args(self, args):\n        self.args = args\n\n    @staticmethod\n    def _make_argparser(args):\n        self.argparser = argparse.ArgumentParser(\n            description='Linux TC unit tests')\n\ndef replace_keywords(cmd):\n    \"\"\"\n    For a given executable command, substitute any known\n    variables contained within NAMES with the correct values\n    \"\"\"\n    tcmd = Template(cmd)\n    subcmd = tcmd.safe_substitute(NAMES)\n    return subcmd\n\n\ndef exec_cmd(args, pm, stage, command):\n    \"\"\"\n    Perform any required modifications on an executable command, then run\n    it in a subprocess and return the results.\n    \"\"\"\n    if len(command.strip()) == 0:\n        return None, None\n    if '$' in command:\n        command = replace_keywords(command)\n\n    command = pm.call_adjust_command(stage, command)\n    if args.verbose > 0:\n        print('command \"{}\"'.format(command))\n    proc = subprocess.Popen(command,\n        shell=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        env=ENVIR)\n\n    try:\n        (rawout, serr) = proc.communicate(timeout=NAMES['TIMEOUT'])\n        if proc.returncode != 0 and len(serr) > 0:\n            foutput = serr.decode(\"utf-8\", errors=\"ignore\")\n        else:\n            foutput = rawout.decode(\"utf-8\", errors=\"ignore\")\n    except subprocess.TimeoutExpired:\n        foutput = \"Command \\\"{}\\\" timed out\\n\".format(command)\n        proc.returncode = 255\n\n    proc.stdout.close()\n    proc.stderr.close()\n    return proc, foutput\n\n\ndef prepare_env(args, pm, stage, prefix, cmdlist, output = None):\n    \"\"\"\n    Execute the setup/teardown commands for a test case.\n    Optionally terminate test execution if the command fails.\n    \"\"\"\n    if args.verbose > 0:\n        print('{}'.format(prefix))\n    for cmdinfo in cmdlist:\n        if isinstance(cmdinfo, list):\n            exit_codes = cmdinfo[1:]\n            cmd = cmdinfo[0]\n        else:\n            exit_codes = [0]\n            cmd = cmdinfo\n\n        if not cmd:\n            continue\n\n        (proc, foutput) = exec_cmd(args, pm, stage, cmd)\n\n        if proc and (proc.returncode not in exit_codes):\n            print('', file=sys.stderr)\n            print(\"{} *** Could not execute: \\\"{}\\\"\".format(prefix, cmd),\n                  file=sys.stderr)\n            print(\"\\n{} *** Error message: \\\"{}\\\"\".format(prefix, foutput),\n                  file=sys.stderr)\n            print(\"returncode {}; expected {}\".format(proc.returncode,\n                                                      exit_codes))\n            print(\"\\n{} *** Aborting test run.\".format(prefix), file=sys.stderr)\n            print(\"\\n\\n{} *** stdout ***\".format(proc.stdout), file=sys.stderr)\n            print(\"\\n\\n{} *** stderr ***\".format(proc.stderr), file=sys.stderr)\n            raise PluginMgrTestFail(\n                stage, output,\n                '\"{}\" did not complete successfully'.format(prefix))\n\ndef verify_by_json(procout, res, tidx, args, pm):\n    try:\n        outputJSON = json.loads(procout)\n    except json.JSONDecodeError:\n        res.set_result(ResultState.fail)\n        res.set_failmsg('Cannot decode verify command\\'s output. Is it JSON?')\n        return res\n\n    matchJSON = json.loads(json.dumps(tidx['matchJSON']))\n\n    if type(outputJSON) != type(matchJSON):\n        failmsg = 'Original output and matchJSON value are not the same type: output: {} != matchJSON: {} '\n        failmsg = failmsg.format(type(outputJSON).__name__, type(matchJSON).__name__)\n        res.set_result(ResultState.fail)\n        res.set_failmsg(failmsg)\n        return res\n\n    if len(matchJSON) > len(outputJSON):\n        failmsg = \"Your matchJSON value is an array, and it contains more elements than the command under test\\'s output:\\ncommand output (length: {}):\\n{}\\nmatchJSON value (length: {}):\\n{}\"\n        failmsg = failmsg.format(len(outputJSON), outputJSON, len(matchJSON), matchJSON)\n        res.set_result(ResultState.fail)\n        res.set_failmsg(failmsg)\n        return res\n    res = find_in_json(res, outputJSON, matchJSON, 0)\n\n    return res\n\ndef find_in_json(res, outputJSONVal, matchJSONVal, matchJSONKey=None):\n    if res.get_result() == ResultState.fail:\n        return res\n\n    if type(matchJSONVal) == list:\n        res = find_in_json_list(res, outputJSONVal, matchJSONVal, matchJSONKey)\n\n    elif type(matchJSONVal) == dict:\n        res = find_in_json_dict(res, outputJSONVal, matchJSONVal)\n    else:\n        res = find_in_json_other(res, outputJSONVal, matchJSONVal, matchJSONKey)\n\n    if res.get_result() != ResultState.fail:\n        res.set_result(ResultState.success)\n        return res\n\n    return res\n\ndef find_in_json_list(res, outputJSONVal, matchJSONVal, matchJSONKey=None):\n    if (type(matchJSONVal) != type(outputJSONVal)):\n        failmsg = 'Original output and matchJSON value are not the same type: output: {} != matchJSON: {}'\n        failmsg = failmsg.format(outputJSONVal, matchJSONVal)\n        res.set_result(ResultState.fail)\n        res.set_failmsg(failmsg)\n        return res\n\n    if len(matchJSONVal) > len(outputJSONVal):\n        failmsg = \"Your matchJSON value is an array, and it contains more elements than the command under test\\'s output:\\ncommand output (length: {}):\\n{}\\nmatchJSON value (length: {}):\\n{}\"\n        failmsg = failmsg.format(len(outputJSONVal), outputJSONVal, len(matchJSONVal), matchJSONVal)\n        res.set_result(ResultState.fail)\n        res.set_failmsg(failmsg)\n        return res\n\n    for matchJSONIdx, matchJSONVal in enumerate(matchJSONVal):\n        res = find_in_json(res, outputJSONVal[matchJSONIdx], matchJSONVal,\n                           matchJSONKey)\n    return res\n\ndef find_in_json_dict(res, outputJSONVal, matchJSONVal):\n    for matchJSONKey, matchJSONVal in matchJSONVal.items():\n        if type(outputJSONVal) == dict:\n            if matchJSONKey not in outputJSONVal:\n                failmsg = 'Key not found in json output: {}: {}\\nMatching against output: {}'\n                failmsg = failmsg.format(matchJSONKey, matchJSONVal, outputJSONVal)\n                res.set_result(ResultState.fail)\n                res.set_failmsg(failmsg)\n                return res\n\n        else:\n            failmsg = 'Original output and matchJSON value are not the same type: output: {} != matchJSON: {}'\n            failmsg = failmsg.format(type(outputJSON).__name__, type(matchJSON).__name__)\n            res.set_result(ResultState.fail)\n            res.set_failmsg(failmsg)\n            return rest\n\n        if type(outputJSONVal) == dict and (type(outputJSONVal[matchJSONKey]) == dict or\n                type(outputJSONVal[matchJSONKey]) == list):\n            if len(matchJSONVal) > 0:\n                res = find_in_json(res, outputJSONVal[matchJSONKey], matchJSONVal, matchJSONKey)\n            # handling corner case where matchJSONVal == [] or matchJSONVal == {}\n            else:\n                res = find_in_json_other(res, outputJSONVal, matchJSONVal, matchJSONKey)\n        else:\n            res = find_in_json(res, outputJSONVal, matchJSONVal, matchJSONKey)\n    return res\n\ndef find_in_json_other(res, outputJSONVal, matchJSONVal, matchJSONKey=None):\n    if matchJSONKey in outputJSONVal:\n        if matchJSONVal != outputJSONVal[matchJSONKey]:\n            failmsg = 'Value doesn\\'t match: {}: {} != {}\\nMatching against output: {}'\n            failmsg = failmsg.format(matchJSONKey, matchJSONVal, outputJSONVal[matchJSONKey], outputJSONVal)\n            res.set_result(ResultState.fail)\n            res.set_failmsg(failmsg)\n            return res\n\n    return res\n\ndef run_one_test(pm, args, index, tidx):\n    global NAMES\n    result = True\n    tresult = \"\"\n    tap = \"\"\n    res = TestResult(tidx['id'], tidx['name'])\n    if args.verbose > 0:\n        print(\"\\t====================\\n=====> \", end=\"\")\n    print(\"Test \" + tidx[\"id\"] + \": \" + tidx[\"name\"])\n\n    if 'skip' in tidx:\n        if tidx['skip'] == 'yes':\n            res = TestResult(tidx['id'], tidx['name'])\n            res.set_result(ResultState.skip)\n            res.set_errormsg('Test case designated as skipped.')\n            pm.call_pre_case(tidx, test_skip=True)\n            pm.call_post_execute()\n            return res\n\n    if 'dependsOn' in tidx:\n        if (args.verbose > 0):\n            print('probe command for test skip')\n        (p, procout) = exec_cmd(args, pm, 'execute', tidx['dependsOn'])\n        if p:\n            if (p.returncode != 0):\n                res = TestResult(tidx['id'], tidx['name'])\n                res.set_result(ResultState.skip)\n                res.set_errormsg('probe command: test skipped.')\n                pm.call_pre_case(tidx, test_skip=True)\n                pm.call_post_execute()\n                return res\n\n    # populate NAMES with TESTID for this test\n    NAMES['TESTID'] = tidx['id']\n\n    pm.call_pre_case(tidx)\n    prepare_env(args, pm, 'setup', \"-----> prepare stage\", tidx[\"setup\"])\n\n    if (args.verbose > 0):\n        print('-----> execute stage')\n    pm.call_pre_execute()\n    (p, procout) = exec_cmd(args, pm, 'execute', tidx[\"cmdUnderTest\"])\n    if p:\n        exit_code = p.returncode\n    else:\n        exit_code = None\n\n    pm.call_post_execute()\n\n    if (exit_code is None or exit_code != int(tidx[\"expExitCode\"])):\n        print(\"exit: {!r}\".format(exit_code))\n        print(\"exit: {}\".format(int(tidx[\"expExitCode\"])))\n        #print(\"exit: {!r} {}\".format(exit_code, int(tidx[\"expExitCode\"])))\n        res.set_result(ResultState.fail)\n        res.set_failmsg('Command exited with {}, expected {}\\n{}'.format(exit_code, tidx[\"expExitCode\"], procout))\n        print(procout)\n    else:\n        if args.verbose > 0:\n            print('-----> verify stage')\n        (p, procout) = exec_cmd(args, pm, 'verify', tidx[\"verifyCmd\"])\n        if procout:\n            if 'matchJSON' in tidx:\n                verify_by_json(procout, res, tidx, args, pm)\n            elif 'matchPattern' in tidx:\n                match_pattern = re.compile(\n                    str(tidx[\"matchPattern\"]), re.DOTALL | re.MULTILINE)\n                match_index = re.findall(match_pattern, procout)\n                if len(match_index) != int(tidx[\"matchCount\"]):\n                    res.set_result(ResultState.fail)\n                    res.set_failmsg('Could not match regex pattern. Verify command output:\\n{}'.format(procout))\n                else:\n                    res.set_result(ResultState.success)\n            else:\n                res.set_result(ResultState.fail)\n                res.set_failmsg('Must specify a match option: matchJSON or matchPattern\\n{}'.format(procout))\n        elif int(tidx[\"matchCount\"]) != 0:\n            res.set_result(ResultState.fail)\n            res.set_failmsg('No output generated by verify command.')\n        else:\n            res.set_result(ResultState.success)\n\n    prepare_env(args, pm, 'teardown', '-----> teardown stage', tidx['teardown'], procout)\n    pm.call_post_case()\n\n    index += 1\n\n    # remove TESTID from NAMES\n    del(NAMES['TESTID'])\n    return res\n\ndef test_runner(pm, args, filtered_tests):\n    \"\"\"\n    Driver function for the unit tests.\n\n    Prints information about the tests being run, executes the setup and\n    teardown commands and the command under test itself. Also determines\n    success/failure based on the information in the test case and generates\n    TAP output accordingly.\n    \"\"\"\n    testlist = filtered_tests\n    tcount = len(testlist)\n    index = 1\n    tap = ''\n    badtest = None\n    stage = None\n    emergency_exit = False\n    emergency_exit_message = ''\n\n    tsr = TestSuiteReport()\n\n    try:\n        pm.call_pre_suite(tcount, [tidx['id'] for tidx in testlist])\n    except Exception as ee:\n        ex_type, ex, ex_tb = sys.exc_info()\n        print('Exception {} {} (caught in pre_suite).'.\n              format(ex_type, ex))\n        traceback.print_tb(ex_tb)\n        emergency_exit_message = 'EMERGENCY EXIT, call_pre_suite failed with exception {} {}\\n'.format(ex_type, ex)\n        emergency_exit = True\n        stage = 'pre-SUITE'\n\n    if emergency_exit:\n        pm.call_post_suite(index)\n        return emergency_exit_message\n    if args.verbose > 1:\n        print('give test rig 2 seconds to stabilize')\n    time.sleep(2)\n    for tidx in testlist:\n        if \"flower\" in tidx[\"category\"] and args.device == None:\n            errmsg = \"Tests using the DEV2 variable must define the name of a \"\n            errmsg += \"physical NIC with the -d option when running tdc.\\n\"\n            errmsg += \"Test has been skipped.\"\n            if args.verbose > 1:\n                print(errmsg)\n            res = TestResult(tidx['id'], tidx['name'])\n            res.set_result(ResultState.skip)\n            res.set_errormsg(errmsg)\n            tsr.add_resultdata(res)\n            index += 1\n            continue\n        try:\n            badtest = tidx  # in case it goes bad\n            res = run_one_test(pm, args, index, tidx)\n            tsr.add_resultdata(res)\n        except PluginMgrTestFail as pmtf:\n            ex_type, ex, ex_tb = sys.exc_info()\n            stage = pmtf.stage\n            message = pmtf.message\n            output = pmtf.output\n            res = TestResult(tidx['id'], tidx['name'])\n            res.set_result(ResultState.skip)\n            res.set_errormsg(pmtf.message)\n            res.set_failmsg(pmtf.output)\n            tsr.add_resultdata(res)\n            index += 1\n            print(message)\n            print('Exception {} {} (caught in test_runner, running test {} {} {} stage {})'.\n                  format(ex_type, ex, index, tidx['id'], tidx['name'], stage))\n            print('---------------')\n            print('traceback')\n            traceback.print_tb(ex_tb)\n            print('---------------')\n            if stage == 'teardown':\n                print('accumulated output for this test:')\n                if pmtf.output:\n                    print(pmtf.output)\n            print('---------------')\n            break\n        index += 1\n\n    # if we failed in setup or teardown,\n    # fill in the remaining tests with ok-skipped\n    count = index\n\n    if tcount + 1 != count:\n        for tidx in testlist[count - 1:]:\n            res = TestResult(tidx['id'], tidx['name'])\n            res.set_result(ResultState.skip)\n            msg = 'skipped - previous {} failed {} {}'.format(stage,\n                index, badtest.get('id', '--Unknown--'))\n            res.set_errormsg(msg)\n            tsr.add_resultdata(res)\n            count += 1\n\n    if args.pause:\n        print('Want to pause\\nPress enter to continue ...')\n        if input(sys.stdin):\n            print('got something on stdin')\n\n    pm.call_post_suite(index)\n\n    return tsr\n\ndef has_blank_ids(idlist):\n    \"\"\"\n    Search the list for empty ID fields and return true/false accordingly.\n    \"\"\"\n    return not(all(k for k in idlist))\n\n\ndef load_from_file(filename):\n    \"\"\"\n    Open the JSON file containing the test cases and return them\n    as list of ordered dictionary objects.\n    \"\"\"\n    try:\n        with open(filename) as test_data:\n            testlist = json.load(test_data, object_pairs_hook=OrderedDict)\n    except json.JSONDecodeError as jde:\n        print('IGNORING test case file {}\\n\\tBECAUSE:  {}'.format(filename, jde))\n        testlist = list()\n    else:\n        idlist = get_id_list(testlist)\n        if (has_blank_ids(idlist)):\n            for k in testlist:\n                k['filename'] = filename\n    return testlist\n\n\ndef args_parse():\n    \"\"\"\n    Create the argument parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Linux TC unit tests')\n    return parser\n\n\ndef set_args(parser):\n    \"\"\"\n    Set the command line arguments for tdc.\n    \"\"\"\n    parser.add_argument(\n        '--outfile', type=str,\n        help='Path to the file in which results should be saved. ' +\n        'Default target is the current directory.')\n    parser.add_argument(\n        '-p', '--path', type=str,\n        help='The full path to the tc executable to use')\n    sg = parser.add_argument_group(\n        'selection', 'select which test cases: ' +\n        'files plus directories; filtered by categories plus testids')\n    ag = parser.add_argument_group(\n        'action', 'select action to perform on selected test cases')\n\n    sg.add_argument(\n        '-D', '--directory', nargs='+', metavar='DIR',\n        help='Collect tests from the specified directory(ies) ' +\n        '(default [tc-tests])')\n    sg.add_argument(\n        '-f', '--file', nargs='+', metavar='FILE',\n        help='Run tests from the specified file(s)')\n    sg.add_argument(\n        '-c', '--category', nargs='*', metavar='CATG', default=['+c'],\n        help='Run tests only from the specified category/ies, ' +\n        'or if no category/ies is/are specified, list known categories.')\n    sg.add_argument(\n        '-e', '--execute', nargs='+', metavar='ID',\n        help='Execute the specified test cases with specified IDs')\n    ag.add_argument(\n        '-l', '--list', action='store_true',\n        help='List all test cases, or those only within the specified category')\n    ag.add_argument(\n        '-s', '--show', action='store_true', dest='showID',\n        help='Display the selected test cases')\n    ag.add_argument(\n        '-i', '--id', action='store_true', dest='gen_id',\n        help='Generate ID numbers for new test cases')\n    parser.add_argument(\n        '-v', '--verbose', action='count', default=0,\n        help='Show the commands that are being run')\n    parser.add_argument(\n        '--format', default='tap', const='tap', nargs='?',\n        choices=['none', 'xunit', 'tap'],\n        help='Specify the format for test results. (Default: TAP)')\n    parser.add_argument('-d', '--device',\n                        help='Execute test cases that use a physical device, ' +\n                        'where DEVICE is its name. (If not defined, tests ' +\n                        'that require a physical device will be skipped)')\n    parser.add_argument(\n        '-P', '--pause', action='store_true',\n        help='Pause execution just before post-suite stage')\n    return parser\n\n\ndef check_default_settings(args, remaining, pm):\n    \"\"\"\n    Process any arguments overriding the default settings,\n    and ensure the settings are correct.\n    \"\"\"\n    # Allow for overriding specific settings\n    global NAMES\n\n    if args.path != None:\n        NAMES['TC'] = args.path\n    if args.device != None:\n        NAMES['DEV2'] = args.device\n    if 'TIMEOUT' not in NAMES:\n        NAMES['TIMEOUT'] = None\n    if not os.path.isfile(NAMES['TC']):\n        print(\"The specified tc path \" + NAMES['TC'] + \" does not exist.\")\n        exit(1)\n\n    pm.call_check_args(args, remaining)\n\n\ndef get_id_list(alltests):\n    \"\"\"\n    Generate a list of all IDs in the test cases.\n    \"\"\"\n    return [x[\"id\"] for x in alltests]\n\n\ndef check_case_id(alltests):\n    \"\"\"\n    Check for duplicate test case IDs.\n    \"\"\"\n    idl = get_id_list(alltests)\n    return [x for x in idl if idl.count(x) > 1]\n\n\ndef does_id_exist(alltests, newid):\n    \"\"\"\n    Check if a given ID already exists in the list of test cases.\n    \"\"\"\n    idl = get_id_list(alltests)\n    return (any(newid == x for x in idl))\n\n\ndef generate_case_ids(alltests):\n    \"\"\"\n    If a test case has a blank ID field, generate a random hex ID for it\n    and then write the test cases back to disk.\n    \"\"\"\n    import random\n    for c in alltests:\n        if (c[\"id\"] == \"\"):\n            while True:\n                newid = str('{:04x}'.format(random.randrange(16**4)))\n                if (does_id_exist(alltests, newid)):\n                    continue\n                else:\n                    c['id'] = newid\n                    break\n\n    ufilename = []\n    for c in alltests:\n        if ('filename' in c):\n            ufilename.append(c['filename'])\n    ufilename = get_unique_item(ufilename)\n    for f in ufilename:\n        testlist = []\n        for t in alltests:\n            if 'filename' in t:\n                if t['filename'] == f:\n                    del t['filename']\n                    testlist.append(t)\n        outfile = open(f, \"w\")\n        json.dump(testlist, outfile, indent=4)\n        outfile.write(\"\\n\")\n        outfile.close()\n\ndef filter_tests_by_id(args, testlist):\n    '''\n    Remove tests from testlist that are not in the named id list.\n    If id list is empty, return empty list.\n    '''\n    newlist = list()\n    if testlist and args.execute:\n        target_ids = args.execute\n\n        if isinstance(target_ids, list) and (len(target_ids) > 0):\n            newlist = list(filter(lambda x: x['id'] in target_ids, testlist))\n    return newlist\n\ndef filter_tests_by_category(args, testlist):\n    '''\n    Remove tests from testlist that are not in a named category.\n    '''\n    answer = list()\n    if args.category and testlist:\n        test_ids = list()\n        for catg in set(args.category):\n            if catg == '+c':\n                continue\n            print('considering category {}'.format(catg))\n            for tc in testlist:\n                if catg in tc['category'] and tc['id'] not in test_ids:\n                    answer.append(tc)\n                    test_ids.append(tc['id'])\n\n    return answer\n\n\ndef get_test_cases(args):\n    \"\"\"\n    If a test case file is specified, retrieve tests from that file.\n    Otherwise, glob for all json files in subdirectories and load from\n    each one.\n    Also, if requested, filter by category, and add tests matching\n    certain ids.\n    \"\"\"\n    import fnmatch\n\n    flist = []\n    testdirs = ['tc-tests']\n\n    if args.file:\n        # at least one file was specified - remove the default directory\n        testdirs = []\n\n        for ff in args.file:\n            if not os.path.isfile(ff):\n                print(\"IGNORING file \" + ff + \"\\n\\tBECAUSE does not exist.\")\n            else:\n                flist.append(os.path.abspath(ff))\n\n    if args.directory:\n        testdirs = args.directory\n\n    for testdir in testdirs:\n        for root, dirnames, filenames in os.walk(testdir):\n            for filename in fnmatch.filter(filenames, '*.json'):\n                candidate = os.path.abspath(os.path.join(root, filename))\n                if candidate not in testdirs:\n                    flist.append(candidate)\n\n    alltestcases = list()\n    for casefile in flist:\n        alltestcases = alltestcases + (load_from_file(casefile))\n\n    allcatlist = get_test_categories(alltestcases)\n    allidlist = get_id_list(alltestcases)\n\n    testcases_by_cats = get_categorized_testlist(alltestcases, allcatlist)\n    idtestcases = filter_tests_by_id(args, alltestcases)\n    cattestcases = filter_tests_by_category(args, alltestcases)\n\n    cat_ids = [x['id'] for x in cattestcases]\n    if args.execute:\n        if args.category:\n            alltestcases = cattestcases + [x for x in idtestcases if x['id'] not in cat_ids]\n        else:\n            alltestcases = idtestcases\n    else:\n        if cat_ids:\n            alltestcases = cattestcases\n        else:\n            # just accept the existing value of alltestcases,\n            # which has been filtered by file/directory\n            pass\n\n    return allcatlist, allidlist, testcases_by_cats, alltestcases\n\n\ndef set_operation_mode(pm, parser, args, remaining):\n    \"\"\"\n    Load the test case data and process remaining arguments to determine\n    what the script should do for this run, and call the appropriate\n    function.\n    \"\"\"\n    ucat, idlist, testcases, alltests = get_test_cases(args)\n\n    if args.gen_id:\n        if (has_blank_ids(idlist)):\n            alltests = generate_case_ids(alltests)\n        else:\n            print(\"No empty ID fields found in test files.\")\n        exit(0)\n\n    duplicate_ids = check_case_id(alltests)\n    if (len(duplicate_ids) > 0):\n        print(\"The following test case IDs are not unique:\")\n        print(str(set(duplicate_ids)))\n        print(\"Please correct them before continuing.\")\n        exit(1)\n\n    if args.showID:\n        for atest in alltests:\n            print_test_case(atest)\n        exit(0)\n\n    if isinstance(args.category, list) and (len(args.category) == 0):\n        print(\"Available categories:\")\n        print_sll(ucat)\n        exit(0)\n\n    if args.list:\n        list_test_cases(alltests)\n        exit(0)\n\n    exit_code = 0 # KSFT_PASS\n    if len(alltests):\n        req_plugins = pm.get_required_plugins(alltests)\n        try:\n            args = pm.load_required_plugins(req_plugins, parser, args, remaining)\n        except PluginDependencyException as pde:\n            print('The following plugins were not found:')\n            print('{}'.format(pde.missing_pg))\n        catresults = test_runner(pm, args, alltests)\n        if catresults.count_failures() != 0:\n            exit_code = 1 # KSFT_FAIL\n        if args.format == 'none':\n            print('Test results output suppression requested\\n')\n        else:\n            print('\\nAll test results: \\n')\n            if args.format == 'xunit':\n                suffix = 'xml'\n                res = catresults.format_xunit()\n            elif args.format == 'tap':\n                suffix = 'tap'\n                res = catresults.format_tap()\n            print(res)\n            print('\\n\\n')\n            if not args.outfile:\n                fname = 'test-results.{}'.format(suffix)\n            else:\n                fname = args.outfile\n            with open(fname, 'w') as fh:\n                fh.write(res)\n                fh.close()\n                if os.getenv('SUDO_UID') is not None:\n                    os.chown(fname, uid=int(os.getenv('SUDO_UID')),\n                        gid=int(os.getenv('SUDO_GID')))\n    else:\n        print('No tests found\\n')\n        exit_code = 4 # KSFT_SKIP\n    exit(exit_code)\n\ndef main():\n    \"\"\"\n    Start of execution; set up argument parser and get the arguments,\n    and start operations.\n    \"\"\"\n    parser = args_parse()\n    parser = set_args(parser)\n    pm = PluginMgr(parser)\n    parser = pm.call_add_args(parser)\n    (args, remaining) = parser.parse_known_args()\n    args.NAMES = NAMES\n    pm.set_args(args)\n    check_default_settings(args, remaining, pm)\n    if args.verbose > 2:\n        print('args is {}'.format(args))\n\n    set_operation_mode(pm, parser, args, remaining)\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}