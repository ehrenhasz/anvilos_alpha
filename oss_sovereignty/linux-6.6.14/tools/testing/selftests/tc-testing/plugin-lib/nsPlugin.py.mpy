{
  "module_name": "nsPlugin.py",
  "hash_id": "0a805bea8235a2a68c96520b0c457ea69a9c59675c4771f34b8d056363d18b78",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tc-testing/plugin-lib/nsPlugin.py",
  "human_readable_source": "import os\nimport signal\nfrom string import Template\nimport subprocess\nimport time\nfrom TdcPlugin import TdcPlugin\n\nfrom tdc_config import *\n\nclass SubPlugin(TdcPlugin):\n    def __init__(self):\n        self.sub_class = 'ns/SubPlugin'\n        super().__init__()\n\n    def pre_suite(self, testcount, testidlist):\n        '''run commands before test_runner goes into a test loop'''\n        super().pre_suite(testcount, testidlist)\n\n        if self.args.namespace:\n            self._ns_create()\n        else:\n            self._ports_create()\n\n    def post_suite(self, index):\n        '''run commands after test_runner goes into a test loop'''\n        super().post_suite(index)\n        if self.args.verbose:\n            print('{}.post_suite'.format(self.sub_class))\n\n        if self.args.namespace:\n            self._ns_destroy()\n        else:\n            self._ports_destroy()\n\n    def add_args(self, parser):\n        super().add_args(parser)\n        self.argparser_group = self.argparser.add_argument_group(\n            'netns',\n            'options for nsPlugin(run commands in net namespace)')\n        self.argparser_group.add_argument(\n            '-N', '--no-namespace', action='store_false', default=True,\n            dest='namespace', help='Don\\'t run commands in namespace')\n        return self.argparser\n\n    def adjust_command(self, stage, command):\n        super().adjust_command(stage, command)\n        cmdform = 'list'\n        cmdlist = list()\n\n        if not self.args.namespace:\n            return command\n\n        if self.args.verbose:\n            print('{}.adjust_command'.format(self.sub_class))\n\n        if not isinstance(command, list):\n            cmdform = 'str'\n            cmdlist = command.split()\n        else:\n            cmdlist = command\n        if stage == 'setup' or stage == 'execute' or stage == 'verify' or stage == 'teardown':\n            if self.args.verbose:\n                print('adjust_command:  stage is {}; inserting netns stuff in command [{}] list [{}]'.format(stage, command, cmdlist))\n            cmdlist.insert(0, self.args.NAMES['NS'])\n            cmdlist.insert(0, 'exec')\n            cmdlist.insert(0, 'netns')\n            cmdlist.insert(0, self.args.NAMES['IP'])\n        else:\n            pass\n\n        if cmdform == 'str':\n            command = ' '.join(cmdlist)\n        else:\n            command = cmdlist\n\n        if self.args.verbose:\n            print('adjust_command:  return command [{}]'.format(command))\n        return command\n\n    def _ports_create(self):\n        cmd = '$IP link add $DEV0 type veth peer name $DEV1'\n        self._exec_cmd('pre', cmd)\n        cmd = '$IP link set $DEV0 up'\n        self._exec_cmd('pre', cmd)\n        if not self.args.namespace:\n            cmd = '$IP link set $DEV1 up'\n            self._exec_cmd('pre', cmd)\n\n    def _ports_destroy(self):\n        cmd = '$IP link del $DEV0'\n        self._exec_cmd('post', cmd)\n\n    def _ns_create(self):\n        '''\n        Create the network namespace in which the tests will be run and set up\n        the required network devices for it.\n        '''\n        self._ports_create()\n        if self.args.namespace:\n            cmd = '$IP netns add {}'.format(self.args.NAMES['NS'])\n            self._exec_cmd('pre', cmd)\n            cmd = '$IP link set $DEV1 netns {}'.format(self.args.NAMES['NS'])\n            self._exec_cmd('pre', cmd)\n            cmd = '$IP -n {} link set $DEV1 up'.format(self.args.NAMES['NS'])\n            self._exec_cmd('pre', cmd)\n            if self.args.device:\n                cmd = '$IP link set $DEV2 netns {}'.format(self.args.NAMES['NS'])\n                self._exec_cmd('pre', cmd)\n                cmd = '$IP -n {} link set $DEV2 up'.format(self.args.NAMES['NS'])\n                self._exec_cmd('pre', cmd)\n\n    def _ns_destroy(self):\n        '''\n        Destroy the network namespace for testing (and any associated network\n        devices as well)\n        '''\n        if self.args.namespace:\n            cmd = '$IP netns delete {}'.format(self.args.NAMES['NS'])\n            self._exec_cmd('post', cmd)\n\n    def _exec_cmd(self, stage, command):\n        '''\n        Perform any required modifications on an executable command, then run\n        it in a subprocess and return the results.\n        '''\n        if '$' in command:\n            command = self._replace_keywords(command)\n\n        self.adjust_command(stage, command)\n        if self.args.verbose:\n            print('_exec_cmd:  command \"{}\"'.format(command))\n        proc = subprocess.Popen(command,\n            shell=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            env=ENVIR)\n        (rawout, serr) = proc.communicate()\n\n        if proc.returncode != 0 and len(serr) > 0:\n            foutput = serr.decode(\"utf-8\")\n        else:\n            foutput = rawout.decode(\"utf-8\")\n\n        proc.stdout.close()\n        proc.stderr.close()\n        return proc, foutput\n\n    def _replace_keywords(self, cmd):\n        \"\"\"\n        For a given executable command, substitute any known\n        variables contained within NAMES with the correct values\n        \"\"\"\n        tcmd = Template(cmd)\n        subcmd = tcmd.safe_substitute(self.args.NAMES)\n        return subcmd\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}