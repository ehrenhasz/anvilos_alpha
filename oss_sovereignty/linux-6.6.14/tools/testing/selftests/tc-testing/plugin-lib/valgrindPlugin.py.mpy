{
  "module_name": "valgrindPlugin.py",
  "hash_id": "6dd74ac108b59394a33640f695d811d5be14129ce4b589000f5c3be8d9c31be1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tc-testing/plugin-lib/valgrindPlugin.py",
  "human_readable_source": "'''\nrun the command under test, under valgrind and collect memory leak info\nas a separate test.\n'''\n\n\nimport os\nimport re\nimport signal\nfrom string import Template\nimport subprocess\nimport time\nfrom TdcPlugin import TdcPlugin\nfrom TdcResults import *\n\nfrom tdc_config import *\n\ndef vp_extract_num_from_string(num_as_string_maybe_with_commas):\n    return int(num_as_string_maybe_with_commas.replace(',',''))\n\nclass SubPlugin(TdcPlugin):\n    def __init__(self):\n        self.sub_class = 'valgrind/SubPlugin'\n        self.tap = ''\n        self._tsr = TestSuiteReport()\n        super().__init__()\n\n    def pre_suite(self, testcount, testidlist):\n        '''run commands before test_runner goes into a test loop'''\n        super().pre_suite(testcount, testidlist)\n        if self.args.verbose > 1:\n            print('{}.pre_suite'.format(self.sub_class))\n        if self.args.valgrind:\n            self._add_to_tap('1..{}\\n'.format(self.testcount))\n\n    def post_suite(self, index):\n        '''run commands after test_runner goes into a test loop'''\n        super().post_suite(index)\n        if self.args.verbose > 1:\n            print('{}.post_suite'.format(self.sub_class))\n        #print('{}'.format(self.tap))\n        for xx in range(index - 1, self.testcount):\n            res = TestResult('{}-mem'.format(self.testidlist[xx]), 'Test skipped')\n            res.set_result(ResultState.skip)\n            res.set_errormsg('Skipped because of prior setup/teardown failure')\n            self._add_results(res)\n        if self.args.verbose < 4:\n            subprocess.check_output('rm -f vgnd-*.log', shell=True)\n\n    def add_args(self, parser):\n        super().add_args(parser)\n        self.argparser_group = self.argparser.add_argument_group(\n            'valgrind',\n            'options for valgrindPlugin (run command under test under Valgrind)')\n\n        self.argparser_group.add_argument(\n            '-V', '--valgrind', action='store_true',\n            help='Run commands under valgrind')\n\n        return self.argparser\n\n    def adjust_command(self, stage, command):\n        super().adjust_command(stage, command)\n        cmdform = 'list'\n        cmdlist = list()\n\n        if not self.args.valgrind:\n            return command\n\n        if self.args.verbose > 1:\n            print('{}.adjust_command'.format(self.sub_class))\n\n        if not isinstance(command, list):\n            cmdform = 'str'\n            cmdlist = command.split()\n        else:\n            cmdlist = command\n\n        if stage == 'execute':\n            if self.args.verbose > 1:\n                print('adjust_command:  stage is {}; inserting valgrind stuff in command [{}] list [{}]'.\n                      format(stage, command, cmdlist))\n            cmdlist.insert(0, '--track-origins=yes')\n            cmdlist.insert(0, '--show-leak-kinds=definite,indirect')\n            cmdlist.insert(0, '--leak-check=full')\n            cmdlist.insert(0, '--log-file=vgnd-{}.log'.format(self.args.testid))\n            cmdlist.insert(0, '-v')  # ask for summary of non-leak errors\n            cmdlist.insert(0, ENVIR['VALGRIND_BIN'])\n        else:\n            pass\n\n        if cmdform == 'str':\n            command = ' '.join(cmdlist)\n        else:\n            command = cmdlist\n\n        if self.args.verbose > 1:\n            print('adjust_command:  return command [{}]'.format(command))\n        return command\n\n    def post_execute(self):\n        if not self.args.valgrind:\n            return\n\n        res = TestResult('{}-mem'.format(self.args.testid),\n              '{} memory leak check'.format(self.args.test_name))\n        if self.args.test_skip:\n            res.set_result(ResultState.skip)\n            res.set_errormsg('Test case designated as skipped.')\n            self._add_results(res)\n            return\n\n        self.definitely_lost_re = re.compile(\n            r'definitely lost:\\s+([,0-9]+)\\s+bytes in\\s+([,0-9]+)\\sblocks', re.MULTILINE | re.DOTALL)\n        self.indirectly_lost_re = re.compile(\n            r'indirectly lost:\\s+([,0-9]+)\\s+bytes in\\s+([,0-9]+)\\s+blocks', re.MULTILINE | re.DOTALL)\n        self.possibly_lost_re = re.compile(\n            r'possibly lost:\\s+([,0-9]+)bytes in\\s+([,0-9]+)\\s+blocks', re.MULTILINE | re.DOTALL)\n        self.non_leak_error_re = re.compile(\n            r'ERROR SUMMARY:\\s+([,0-9]+) errors from\\s+([,0-9]+)\\s+contexts', re.MULTILINE | re.DOTALL)\n\n        def_num = 0\n        ind_num = 0\n        pos_num = 0\n        nle_num = 0\n\n        # what about concurrent test runs?  Maybe force them to be in different directories?\n        with open('vgnd-{}.log'.format(self.args.testid)) as vfd:\n            content = vfd.read()\n            def_mo = self.definitely_lost_re.search(content)\n            ind_mo = self.indirectly_lost_re.search(content)\n            pos_mo = self.possibly_lost_re.search(content)\n            nle_mo = self.non_leak_error_re.search(content)\n\n            if def_mo:\n                def_num = int(def_mo.group(2))\n            if ind_mo:\n                ind_num = int(ind_mo.group(2))\n            if pos_mo:\n                pos_num = int(pos_mo.group(2))\n            if nle_mo:\n                nle_num = int(nle_mo.group(1))\n\n        mem_results = ''\n        if (def_num > 0) or (ind_num > 0) or (pos_num > 0) or (nle_num > 0):\n            mem_results += 'not '\n            res.set_result(ResultState.fail)\n            res.set_failmsg('Memory leak detected')\n            res.append_failmsg(content)\n        else:\n            res.set_result(ResultState.success)\n\n        self._add_results(res)\n\n\n    def _add_results(self, res):\n        self._tsr.add_resultdata(res)\n\n    def _add_to_tap(self, more_tap_output):\n        self.tap += more_tap_output\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}