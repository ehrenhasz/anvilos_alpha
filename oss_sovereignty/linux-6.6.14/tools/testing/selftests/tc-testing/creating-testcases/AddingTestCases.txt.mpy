{
  "module_name": "AddingTestCases.txt",
  "hash_id": "58cb0734f7d1784be2121cf062259e5e8bc529d247eac4fefcc2c3a9be358141",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tc-testing/creating-testcases/AddingTestCases.txt",
  "human_readable_source": "tdc - Adding test cases for tdc\n\nAuthor: Lucas Bates - lucasb@mojatatu.com\n\nADDING TEST CASES\n-----------------\n\nUser-defined tests should be added by defining a separate JSON file.  This\nwill help prevent conflicts when updating the repository. Refer to\ntemplate.json for the required JSON format for test cases.\n\nInclude the 'id' field, but do not assign a value. Running tdc with the -i\noption will generate a unique ID for that test case.\n\ntdc will recursively search the 'tc-tests' subdirectory (or the\ndirectories named with the -D option) for .json files.  Any test case\nfiles you create in these directories will automatically be included.\nIf you wish to store your custom test cases elsewhere, be sure to run\ntdc with the -f argument and the path to your file, or the -D argument\nand the path to your directory(ies).\n\nBe aware of required escape characters in the JSON data - particularly\nwhen defining the match pattern. Refer to the supplied json test files\nfor examples when in doubt.  The match pattern is written in json, and\nwill be used by python.  So the match pattern will be a python regular\nexpression, but should be written using json syntax.\n\n\nTEST CASE STRUCTURE\n-------------------\n\nEach test case has required data:\n\nid:           A unique alphanumeric value to identify a particular test case\nname:         Descriptive name that explains the command under test\nskip:         A completely optional key, if the corresponding value is \"yes\"\n              then tdc will not execute the test case in question. However,\n              this test case will still appear in the results output but\n              marked as skipped. This key can be placed anywhere inside the\n              test case at the top level.\ndependsOn:    Same as 'skip', but the value is executed as a command. The test\n              is skipped when the command returns non-zero.\ncategory:     A list of single-word descriptions covering what the command\n              under test is testing. Example: filter, actions, u32, gact, etc.\nsetup:        The list of commands required to ensure the command under test\n              succeeds. For example: if testing a filter, the command to create\n              the qdisc would appear here.\n\t      This list can be empty.\n\t      Each command can be a string to be executed, or a list consisting\n\t      of a string which is a command to be executed, followed by 1 or\n\t      more acceptable exit codes for this command.\n\t      If only a string is given for the command, then an exit code of 0\n\t      will be expected.\ncmdUnderTest: The tc command being tested itself.\nexpExitCode:  The code returned by the command under test upon its termination.\n              tdc will compare this value against the actual returned value.\nverifyCmd:    The tc command to be run to verify successful execution.\n              For example: if the command under test creates a gact action,\n              verifyCmd should be \"$TC actions show action gact\"\nmatchPattern: A regular expression to be applied against the output of the\n              verifyCmd to prove the command under test succeeded. This pattern\n              should be as specific as possible so that a false positive is not\n              matched.\nmatchCount:   How many times the regex in matchPattern should match. A value\n              of 0 is acceptable.\nteardown:     The list of commands to clean up after the test is completed.\n              The environment should be returned to the same state as when\n              this test was started: qdiscs deleted, actions flushed, etc.\n\t      This list can be empty.\n\t      Each command can be a string to be executed, or a list consisting\n\t      of a string which is a command to be executed, followed by 1 or\n\t      more acceptable exit codes for this command.\n\t      If only a string is given for the command, then an exit code of 0\n\t      will be expected.\n\n\nSETUP/TEARDOWN ERRORS\n---------------------\n\nIf an error is detected during the setup/teardown process, execution of the\ntests will immediately stop with an error message and the namespace in which\nthe tests are run will be destroyed. This is to prevent inaccurate results\nin the test cases.  tdc will output a series of TAP results for the skipped\ntests.\n\nRepeated failures of the setup/teardown may indicate a problem with the test\ncase, or possibly even a bug in one of the commands that are not being tested.\n\nIt's possible to include acceptable exit codes with the setup/teardown command\nso that it doesn't halt the script for an error that doesn't matter. Turn the\nindividual command into a list, with the command being first, followed by all\nacceptable exit codes for the command.\n\nExample:\n\nA pair of setup commands.  The first can have exit code 0, 1 or 255, the\nsecond must have exit code 0.\n\n        \"setup\": [\n            [\n                \"$TC actions flush action gact\",\n                0,\n                1,\n                255\n            ],\n            \"$TC actions add action reclassify index 65536\"\n        ],\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}