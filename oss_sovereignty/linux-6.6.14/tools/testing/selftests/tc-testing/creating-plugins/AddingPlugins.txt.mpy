{
  "module_name": "AddingPlugins.txt",
  "hash_id": "cc08ed2522cc818a1a9c668c73c5fc92f4ca5ad897f56dee9d7fa129839ed89f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tc-testing/creating-plugins/AddingPlugins.txt",
  "human_readable_source": "tdc - Adding plugins for tdc\n\nAuthor: Brenda J. Butler - bjb@mojatatu.com\n\nADDING PLUGINS\n--------------\n\nA new plugin should be written in python as a class that inherits from TdcPlugin.\nThere are some examples in plugin-lib.\n\nThe plugin can be used to add functionality to the test framework,\nsuch as:\n\n- adding commands to be run before and/or after the test suite\n- adding commands to be run before and/or after the test cases\n- adding commands to be run before and/or after the execute phase of the test cases\n- ability to alter the command to be run in any phase:\n    pre        (the pre-suite stage)\n    prepare\n    execute\n    verify\n    teardown\n    post       (the post-suite stage)\n- ability to add to the command line args, and use them at run time\n\n\nThe functions in the class should follow the following interfaces:\n\n    def __init__(self)\n    def pre_suite(self, testcount, testidlist)     # see \"PRE_SUITE\" below\n    def post_suite(self, ordinal)                  # see \"SKIPPING\" below\n    def pre_case(self, test_ordinal, testid)       # see \"PRE_CASE\" below\n    def post_case(self)\n    def pre_execute(self)\n    def post_execute(self)\n    def adjust_command(self, stage, command)       # see \"ADJUST\" below\n    def add_args(self, parser)                     # see \"ADD_ARGS\" below\n    def check_args(self, args, remaining)          # see \"CHECK_ARGS\" below\n\n\nPRE_SUITE\n\nThis method takes a testcount (number of tests to be run) and\ntestidlist (array of test ids for tests that will be run).  This is\nuseful for various things, including when an exception occurs and the\nrest of the tests must be skipped.  The info is stored in the object,\nand the post_suite method can refer to it when dumping the \"skipped\"\nTAP output.  The tdc.py script will do that for the test suite as\ndefined in the test case, but if the plugin is being used to run extra\ntests on each test (eg, check for memory leaks on associated\nco-processes) then that other tap output can be generated in the\npost-suite method using this info passed in to the pre_suite method.\n\n\nSKIPPING\n\nThe post_suite method will receive the ordinal number of the last\ntest to be attempted.  It can use this info when outputting\nthe TAP output for the extra test cases.\n\n\nPRE_CASE\n\nThe pre_case method will receive the ordinal number of the test\nand the test id.  Useful for outputing the extra test results.\n\n\nADJUST\n\nThe adjust_command method receives a string representing\nthe execution stage and a string which is the actual command to be\nexecuted.  The plugin can adjust the command, based on the stage of\nexecution.\n\nThe stages are represented by the following strings:\n\n    'pre'\n    'setup'\n    'command'\n    'verify'\n    'teardown'\n    'post'\n\nThe adjust_command method must return the adjusted command so tdc\ncan use it.\n\n\nADD_ARGS\n\nThe add_args method receives the argparser object and can add\narguments to it.  Care should be taken that the new arguments do not\nconflict with any from tdc.py or from other plugins that will be used\nconcurrently.\n\nThe add_args method should return the argparser object.\n\n\nCHECK_ARGS\n\nThe check_args method is so that the plugin can do validation on\nthe args, if needed.  If there is a problem, and Exception should\nbe raised, with a string that explains the problem.\n\neg:  raise Exception('plugin xxx, arg -y is wrong, fix it')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}