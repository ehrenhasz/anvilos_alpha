{
  "module_name": "Makefile",
  "hash_id": "af1571540a588cfa0829f4389cf12d0ace5d14b54de96e1917741b30df35b866",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/nolibc/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# Makefile for nolibc tests\ninclude ../../../scripts/Makefile.include\n# We need this for the \"cc-option\" macro.\ninclude ../../../build/Build.include\n\n# we're in \".../tools/testing/selftests/nolibc\"\nifeq ($(srctree),)\nsrctree := $(patsubst %/tools/testing/selftests/,%,$(dir $(CURDIR)))\nendif\n\nifeq ($(ARCH),)\ninclude $(srctree)/scripts/subarch.include\nARCH = $(SUBARCH)\nendif\n\n# XARCH extends the kernel's ARCH with a few variants of the same\n# architecture that only differ by the configuration, the toolchain\n# and the Qemu program used. It is copied as-is into ARCH except for\n# a few specific values which are mapped like this:\n#\n#  XARCH        | ARCH      | config\n#  -------------|-----------|-------------------------\n#  ppc          | powerpc   | 32 bits\n#  ppc64        | powerpc   | 64 bits big endian\n#  ppc64le      | powerpc   | 64 bits little endian\n#\n# It is recommended to only use XARCH, though it does not harm if\n# ARCH is already set. For simplicity, ARCH is sufficient for all\n# architectures where both are equal.\n\n# configure default variants for target kernel supported architectures\nXARCH_powerpc    = ppc\nXARCH            = $(or $(XARCH_$(ARCH)),$(ARCH))\n\n# map from user input variants to their kernel supported architectures\nARCH_ppc         = powerpc\nARCH_ppc64       = powerpc\nARCH_ppc64le     = powerpc\nARCH            := $(or $(ARCH_$(XARCH)),$(XARCH))\n\n# kernel image names by architecture\nIMAGE_i386       = arch/x86/boot/bzImage\nIMAGE_x86_64     = arch/x86/boot/bzImage\nIMAGE_x86        = arch/x86/boot/bzImage\nIMAGE_arm64      = arch/arm64/boot/Image\nIMAGE_arm        = arch/arm/boot/zImage\nIMAGE_mips       = vmlinuz\nIMAGE_ppc        = vmlinux\nIMAGE_ppc64      = vmlinux\nIMAGE_ppc64le    = arch/powerpc/boot/zImage\nIMAGE_riscv      = arch/riscv/boot/Image\nIMAGE_s390       = arch/s390/boot/bzImage\nIMAGE_loongarch  = arch/loongarch/boot/vmlinuz.efi\nIMAGE            = $(IMAGE_$(XARCH))\nIMAGE_NAME       = $(notdir $(IMAGE))\n\n# default kernel configurations that appear to be usable\nDEFCONFIG_i386       = defconfig\nDEFCONFIG_x86_64     = defconfig\nDEFCONFIG_x86        = defconfig\nDEFCONFIG_arm64      = defconfig\nDEFCONFIG_arm        = multi_v7_defconfig\nDEFCONFIG_mips       = malta_defconfig\nDEFCONFIG_ppc        = pmac32_defconfig\nDEFCONFIG_ppc64      = powernv_be_defconfig\nDEFCONFIG_ppc64le    = powernv_defconfig\nDEFCONFIG_riscv      = defconfig\nDEFCONFIG_s390       = defconfig\nDEFCONFIG_loongarch  = defconfig\nDEFCONFIG            = $(DEFCONFIG_$(XARCH))\n\n# optional tests to run (default = all)\nTEST =\n\n# QEMU_ARCH: arch names used by qemu\nQEMU_ARCH_i386       = i386\nQEMU_ARCH_x86_64     = x86_64\nQEMU_ARCH_x86        = x86_64\nQEMU_ARCH_arm64      = aarch64\nQEMU_ARCH_arm        = arm\nQEMU_ARCH_mips       = mipsel  # works with malta_defconfig\nQEMU_ARCH_ppc        = ppc\nQEMU_ARCH_ppc64      = ppc64\nQEMU_ARCH_ppc64le    = ppc64le\nQEMU_ARCH_riscv      = riscv64\nQEMU_ARCH_s390       = s390x\nQEMU_ARCH_loongarch  = loongarch64\nQEMU_ARCH            = $(QEMU_ARCH_$(XARCH))\n\n# QEMU_ARGS : some arch-specific args to pass to qemu\nQEMU_ARGS_i386       = -M pc -append \"console=ttyS0,9600 i8042.noaux panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_x86_64     = -M pc -append \"console=ttyS0,9600 i8042.noaux panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_x86        = -M pc -append \"console=ttyS0,9600 i8042.noaux panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_arm64      = -M virt -cpu cortex-a53 -append \"panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_arm        = -M virt -append \"panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_mips       = -M malta -append \"panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_ppc        = -M g3beige -append \"console=ttyS0 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_ppc64      = -M powernv -append \"console=hvc0 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_ppc64le    = -M powernv -append \"console=hvc0 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_riscv      = -M virt -append \"console=ttyS0 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_s390       = -M s390-ccw-virtio -m 1G -append \"console=ttyS0 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS_loongarch  = -M virt -append \"console=ttyS0,115200 panic=-1 $(TEST:%=NOLIBC_TEST=%)\"\nQEMU_ARGS            = $(QEMU_ARGS_$(XARCH)) $(QEMU_ARGS_EXTRA)\n\n# OUTPUT is only set when run from the main makefile, otherwise\n# it defaults to this nolibc directory.\nOUTPUT ?= $(CURDIR)/\n\nifeq ($(V),1)\nQ=\nelse\nQ=@\nendif\n\nCFLAGS_ppc = -m32 -mbig-endian -mno-vsx $(call cc-option,-mmultiple)\nCFLAGS_ppc64 = -m64 -mbig-endian -mno-vsx $(call cc-option,-mmultiple)\nCFLAGS_ppc64le = -m64 -mlittle-endian -mno-vsx $(call cc-option,-mabi=elfv2)\nCFLAGS_s390 = -m64\nCFLAGS_mips = -EL\nCFLAGS_STACKPROTECTOR ?= $(call cc-option,-mstack-protector-guard=global $(call cc-option,-fstack-protector-all))\nCFLAGS  ?= -Os -fno-ident -fno-asynchronous-unwind-tables -std=c89 -W -Wall -Wextra \\\n\t\t$(call cc-option,-fno-stack-protector) \\\n\t\t$(CFLAGS_$(XARCH)) $(CFLAGS_STACKPROTECTOR)\nLDFLAGS :=\n\nREPORT  ?= awk '/\\[OK\\][\\r]*$$/{p++} /\\[FAIL\\][\\r]*$$/{if (!f) printf(\"\\n\"); f++; print;} /\\[SKIPPED\\][\\r]*$$/{s++} \\\n\t\tEND{ printf(\"\\n%3d test(s): %3d passed, %3d skipped, %3d failed => status: \", p+s+f, p, s, f); \\\n\t\tif (f) printf(\"failure\\n\"); else if (s) printf(\"warning\\n\"); else printf(\"success\\n\");; \\\n\t\tprintf(\"\\nSee all results in %s\\n\", ARGV[1]); }'\n\nhelp:\n\t@echo \"Supported targets under selftests/nolibc:\"\n\t@echo \"  all          call the \\\"run\\\" target below\"\n\t@echo \"  help         this help\"\n\t@echo \"  sysroot      create the nolibc sysroot here (uses \\$$ARCH)\"\n\t@echo \"  nolibc-test  build the executable (uses \\$$CC and \\$$CROSS_COMPILE)\"\n\t@echo \"  libc-test    build an executable using the compiler's default libc instead\"\n\t@echo \"  run-user     runs the executable under QEMU (uses \\$$XARCH, \\$$TEST)\"\n\t@echo \"  initramfs    prepare the initramfs with nolibc-test\"\n\t@echo \"  defconfig    create a fresh new default config (uses \\$$XARCH)\"\n\t@echo \"  kernel       (re)build the kernel with the initramfs (uses \\$$XARCH)\"\n\t@echo \"  run          runs the kernel in QEMU after building it (uses \\$$XARCH, \\$$TEST)\"\n\t@echo \"  rerun        runs a previously prebuilt kernel in QEMU (uses \\$$XARCH, \\$$TEST)\"\n\t@echo \"  clean        clean the sysroot, initramfs, build and output files\"\n\t@echo \"\"\n\t@echo \"The output file is \\\"run.out\\\". Test ranges may be passed using \\$$TEST.\"\n\t@echo \"\"\n\t@echo \"Currently using the following variables:\"\n\t@echo \"  ARCH          = $(ARCH)\"\n\t@echo \"  XARCH         = $(XARCH)\"\n\t@echo \"  CROSS_COMPILE = $(CROSS_COMPILE)\"\n\t@echo \"  CC            = $(CC)\"\n\t@echo \"  OUTPUT        = $(OUTPUT)\"\n\t@echo \"  TEST          = $(TEST)\"\n\t@echo \"  QEMU_ARCH     = $(if $(QEMU_ARCH),$(QEMU_ARCH),UNKNOWN_ARCH) [determined from \\$$XARCH]\"\n\t@echo \"  IMAGE_NAME    = $(if $(IMAGE_NAME),$(IMAGE_NAME),UNKNOWN_ARCH) [determined from \\$$XARCH]\"\n\t@echo \"\"\n\nall: run\n\nsysroot: sysroot/$(ARCH)/include\n\nsysroot/$(ARCH)/include:\n\t$(Q)rm -rf sysroot/$(ARCH) sysroot/sysroot\n\t$(QUIET_MKDIR)mkdir -p sysroot\n\t$(Q)$(MAKE) -C ../../../include/nolibc ARCH=$(ARCH) OUTPUT=$(CURDIR)/sysroot/ headers_standalone\n\t$(Q)mv sysroot/sysroot sysroot/$(ARCH)\n\nifneq ($(NOLIBC_SYSROOT),0)\nnolibc-test: nolibc-test.c sysroot/$(ARCH)/include\n\t$(QUIET_CC)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ \\\n\t  -nostdlib -static -Isysroot/$(ARCH)/include $< -lgcc\nelse\nnolibc-test: nolibc-test.c\n\t$(QUIET_CC)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ \\\n\t  -nostdlib -static -include ../../../include/nolibc/nolibc.h $< -lgcc\nendif\n\nlibc-test: nolibc-test.c\n\t$(QUIET_CC)$(HOSTCC) -o $@ $<\n\n# local libc-test\nrun-libc-test: libc-test\n\t$(Q)./libc-test > \"$(CURDIR)/run.out\" || :\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\n# local nolibc-test\nrun-nolibc-test: nolibc-test\n\t$(Q)./nolibc-test > \"$(CURDIR)/run.out\" || :\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\n# qemu user-land test\nrun-user: nolibc-test\n\t$(Q)qemu-$(QEMU_ARCH) ./nolibc-test > \"$(CURDIR)/run.out\" || :\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\ninitramfs: nolibc-test\n\t$(QUIET_MKDIR)mkdir -p initramfs\n\t$(call QUIET_INSTALL, initramfs/init)\n\t$(Q)cp nolibc-test initramfs/init\n\ndefconfig:\n\t$(Q)$(MAKE) -C $(srctree) ARCH=$(ARCH) CC=$(CC) CROSS_COMPILE=$(CROSS_COMPILE) mrproper $(DEFCONFIG) prepare\n\nkernel: initramfs\n\t$(Q)$(MAKE) -C $(srctree) ARCH=$(ARCH) CC=$(CC) CROSS_COMPILE=$(CROSS_COMPILE) $(IMAGE_NAME) CONFIG_INITRAMFS_SOURCE=$(CURDIR)/initramfs\n\n# run the tests after building the kernel\nrun: kernel\n\t$(Q)qemu-system-$(QEMU_ARCH) -display none -no-reboot -kernel \"$(srctree)/$(IMAGE)\" -serial stdio $(QEMU_ARGS) > \"$(CURDIR)/run.out\"\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\n# re-run the tests from an existing kernel\nrerun:\n\t$(Q)qemu-system-$(QEMU_ARCH) -display none -no-reboot -kernel \"$(srctree)/$(IMAGE)\" -serial stdio $(QEMU_ARGS) > \"$(CURDIR)/run.out\"\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\n# report with existing test log\nreport:\n\t$(Q)$(REPORT) $(CURDIR)/run.out\n\nclean:\n\t$(call QUIET_CLEAN, sysroot)\n\t$(Q)rm -rf sysroot\n\t$(call QUIET_CLEAN, nolibc-test)\n\t$(Q)rm -f nolibc-test\n\t$(call QUIET_CLEAN, libc-test)\n\t$(Q)rm -f libc-test\n\t$(call QUIET_CLEAN, initramfs)\n\t$(Q)rm -rf initramfs\n\t$(call QUIET_CLEAN, run.out)\n\t$(Q)rm -rf run.out\n\n.PHONY: sysroot/$(ARCH)/include\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}