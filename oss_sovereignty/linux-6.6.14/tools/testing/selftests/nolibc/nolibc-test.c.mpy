{
  "module_name": "nolibc-test.c",
  "hash_id": "74b7cd8136e7395f46c2e823ed5876fe61d05b1800f058bc45233b1fe768c0a1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/nolibc/nolibc-test.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#define _LARGEFILE64_SOURCE\n\n \n#ifndef NOLIBC\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifndef _NOLIBC_STDIO_H\n \n#include <sys/auxv.h>\n#include <sys/io.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/reboot.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/sysmacros.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <limits.h>\n#endif\n#endif\n\n \n#define SINT_MAX_OF_TYPE(type) (((type)1 << (sizeof(type) * 8 - 2)) - (type)1 + ((type)1 << (sizeof(type) * 8 - 2)))\n#define SINT_MIN_OF_TYPE(type) (-SINT_MAX_OF_TYPE(type) - 1)\n\n \nstatic char **test_envp;\n\n \nstatic char **test_argv;\n\n \nstatic int test_argc;\n\n \nstatic const char *argv0;\n\n \nstruct test {\n\tconst char *name;               \n\tint (*func)(int min, int max);  \n};\n\n#ifndef _NOLIBC_STDLIB_H\nchar *itoa(int i)\n{\n\tstatic char buf[12];\n\tint ret;\n\n\tret = snprintf(buf, sizeof(buf), \"%d\", i);\n\treturn (ret >= 0 && ret < sizeof(buf)) ? buf : \"#err\";\n}\n#endif\n\n#define CASE_ERR(err) \\\n\tcase err: return #err\n\n \nstatic const char *errorname(int err)\n{\n\tswitch (err) {\n\tcase 0: return \"SUCCESS\";\n\tCASE_ERR(EPERM);\n\tCASE_ERR(ENOENT);\n\tCASE_ERR(ESRCH);\n\tCASE_ERR(EINTR);\n\tCASE_ERR(EIO);\n\tCASE_ERR(ENXIO);\n\tCASE_ERR(E2BIG);\n\tCASE_ERR(ENOEXEC);\n\tCASE_ERR(EBADF);\n\tCASE_ERR(ECHILD);\n\tCASE_ERR(EAGAIN);\n\tCASE_ERR(ENOMEM);\n\tCASE_ERR(EACCES);\n\tCASE_ERR(EFAULT);\n\tCASE_ERR(ENOTBLK);\n\tCASE_ERR(EBUSY);\n\tCASE_ERR(EEXIST);\n\tCASE_ERR(EXDEV);\n\tCASE_ERR(ENODEV);\n\tCASE_ERR(ENOTDIR);\n\tCASE_ERR(EISDIR);\n\tCASE_ERR(EINVAL);\n\tCASE_ERR(ENFILE);\n\tCASE_ERR(EMFILE);\n\tCASE_ERR(ENOTTY);\n\tCASE_ERR(ETXTBSY);\n\tCASE_ERR(EFBIG);\n\tCASE_ERR(ENOSPC);\n\tCASE_ERR(ESPIPE);\n\tCASE_ERR(EROFS);\n\tCASE_ERR(EMLINK);\n\tCASE_ERR(EPIPE);\n\tCASE_ERR(EDOM);\n\tCASE_ERR(ERANGE);\n\tCASE_ERR(ENOSYS);\n\tCASE_ERR(EOVERFLOW);\n\tdefault:\n\t\treturn itoa(err);\n\t}\n}\n\nstatic void putcharn(char c, size_t n)\n{\n\tchar buf[64];\n\n\tmemset(buf, c, n);\n\tbuf[n] = '\\0';\n\tfputs(buf, stdout);\n}\n\nenum RESULT {\n\tOK,\n\tFAIL,\n\tSKIPPED,\n};\n\nstatic void result(int llen, enum RESULT r)\n{\n\tconst char *msg;\n\n\tif (r == OK)\n\t\tmsg = \" [OK]\";\n\telse if (r == SKIPPED)\n\t\tmsg = \"[SKIPPED]\";\n\telse\n\t\tmsg = \"[FAIL]\";\n\n\tif (llen < 64)\n\t\tputcharn(' ', 64 - llen);\n\tputs(msg);\n}\n\n \n\n#define EXPECT_ZR(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_zr(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_zr(int expr, int llen)\n{\n\tint ret = !(expr == 0);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_NZ(cond, expr, val)\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_nz(expr, llen; } while (0)\n\nstatic __attribute__((unused))\nint expect_nz(int expr, int llen)\n{\n\tint ret = !(expr != 0);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_EQ(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_eq(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_eq(uint64_t expr, int llen, uint64_t val)\n{\n\tint ret = !(expr == val);\n\n\tllen += printf(\" = %lld \", (long long)expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_NE(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ne(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_ne(int expr, int llen, int val)\n{\n\tint ret = !(expr != val);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_GE(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ge(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_ge(int expr, int llen, int val)\n{\n\tint ret = !(expr >= val);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_GT(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_gt(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_gt(int expr, int llen, int val)\n{\n\tint ret = !(expr > val);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_LE(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_le(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_le(int expr, int llen, int val)\n{\n\tint ret = !(expr <= val);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_LT(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_lt(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_lt(int expr, int llen, int val)\n{\n\tint ret = !(expr < val);\n\n\tllen += printf(\" = %d \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_SYSZR(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_syszr(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_syszr(int expr, int llen)\n{\n\tint ret = 0;\n\n\tif (expr) {\n\t\tret = 1;\n\t\tllen += printf(\" = %d %s \", expr, errorname(errno));\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tllen += printf(\" = %d \", expr);\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_SYSEQ(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_syseq(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_syseq(int expr, int llen, int val)\n{\n\tint ret = 0;\n\n\tif (expr != val) {\n\t\tret = 1;\n\t\tllen += printf(\" = %d %s \", expr, errorname(errno));\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tllen += printf(\" = %d \", expr);\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_SYSNE(cond, expr, val)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_sysne(expr, llen, val); } while (0)\n\nstatic __attribute__((unused))\nint expect_sysne(int expr, int llen, int val)\n{\n\tint ret = 0;\n\n\tif (expr == val) {\n\t\tret = 1;\n\t\tllen += printf(\" = %d %s \", expr, errorname(errno));\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tllen += printf(\" = %d \", expr);\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_SYSER2(cond, expr, expret, experr1, experr2)\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_syserr2(expr, expret, experr1, experr2, llen); } while (0)\n\n#define EXPECT_SYSER(cond, expr, expret, experr)\t\t\t\\\n\tEXPECT_SYSER2(cond, expr, expret, experr, 0)\n\nstatic __attribute__((unused))\nint expect_syserr2(int expr, int expret, int experr1, int experr2, int llen)\n{\n\tint ret = 0;\n\tint _errno = errno;\n\n\tllen += printf(\" = %d %s \", expr, errorname(_errno));\n\tif (expr != expret || (_errno != experr1 && _errno != experr2)) {\n\t\tret = 1;\n\t\tif (experr2 == 0)\n\t\t\tllen += printf(\" != (%d %s) \", expret, errorname(experr1));\n\t\telse\n\t\t\tllen += printf(\" != (%d %s %s) \", expret, errorname(experr1), errorname(experr2));\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_PTRZR(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrzr(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrzr(const void *expr, int llen)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%p> \", expr);\n\tif (expr) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_PTRNZ(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrnz(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrnz(const void *expr, int llen)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%p> \", expr);\n\tif (!expr) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n#define EXPECT_PTREQ(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptreq(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptreq(const void *expr, int llen, const void *cmp)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%p> \", expr);\n\tif (expr != cmp) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n#define EXPECT_PTRNE(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrne(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrne(const void *expr, int llen, const void *cmp)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%p> \", expr);\n\tif (expr == cmp) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n#define EXPECT_PTRGE(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrge(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrge(const void *expr, int llen, const void *cmp)\n{\n\tint ret = !(expr >= cmp);\n\n\tllen += printf(\" = <%p> \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n#define EXPECT_PTRGT(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrgt(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrgt(const void *expr, int llen, const void *cmp)\n{\n\tint ret = !(expr > cmp);\n\n\tllen += printf(\" = <%p> \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_PTRLE(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrle(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrle(const void *expr, int llen, const void *cmp)\n{\n\tint ret = !(expr <= cmp);\n\n\tllen += printf(\" = <%p> \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n\n#define EXPECT_PTRLT(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrlt(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_ptrlt(const void *expr, int llen, const void *cmp)\n{\n\tint ret = !(expr < cmp);\n\n\tllen += printf(\" = <%p> \", expr);\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\n#define EXPECT_PTRER2(cond, expr, expret, experr1, experr2)\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_ptrerr2(expr, expret, experr1, experr2, llen); } while (0)\n\n#define EXPECT_PTRER(cond, expr, expret, experr)\t\t\t\\\n\tEXPECT_PTRER2(cond, expr, expret, experr, 0)\n\nstatic __attribute__((unused))\nint expect_ptrerr2(const void *expr, const void *expret, int experr1, int experr2, int llen)\n{\n\tint ret = 0;\n\tint _errno = errno;\n\n\tllen += printf(\" = <%p> %s \", expr, errorname(_errno));\n\tif (expr != expret || (_errno != experr1 && _errno != experr2)) {\n\t\tret = 1;\n\t\tif (experr2 == 0)\n\t\t\tllen += printf(\" != (<%p> %s) \", expret, errorname(experr1));\n\t\telse\n\t\t\tllen += printf(\" != (<%p> %s %s) \", expret, errorname(experr1), errorname(experr2));\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n#define EXPECT_STRZR(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_strzr(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_strzr(const char *expr, int llen)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%s> \", expr);\n\tif (expr) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_STRNZ(cond, expr)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_strnz(expr, llen); } while (0)\n\nstatic __attribute__((unused))\nint expect_strnz(const char *expr, int llen)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%s> \", expr);\n\tif (!expr) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_STREQ(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_streq(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_streq(const char *expr, int llen, const char *cmp)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%s> \", expr);\n\tif (strcmp(expr, cmp) != 0) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n#define EXPECT_STRNE(cond, expr, cmp)\t\t\t\t\\\n\tdo { if (!(cond)) result(llen, SKIPPED); else ret += expect_strne(expr, llen, cmp); } while (0)\n\nstatic __attribute__((unused))\nint expect_strne(const char *expr, int llen, const char *cmp)\n{\n\tint ret = 0;\n\n\tllen += printf(\" = <%s> \", expr);\n\tif (strcmp(expr, cmp) == 0) {\n\t\tret = 1;\n\t\tresult(llen, FAIL);\n\t} else {\n\t\tresult(llen, OK);\n\t}\n\treturn ret;\n}\n\n\n \n#define CASE_TEST(name) \\\n\tcase __LINE__: llen += printf(\"%d %s\", test, #name);\n\nint run_startup(int min, int max)\n{\n\tint test;\n\tint ret = 0;\n\t \n\tint env_total = 2;\n\t \n\textern char end;\n\tchar *brk = sbrk(0) != (void *)-1 ? sbrk(0) : &end;\n\t \n\tconst unsigned long *test_auxv = (void *)-1;\n#ifdef NOLIBC\n\ttest_auxv = _auxv;\n#endif\n\n\tfor (test = min; test >= 0 && test <= max; test++) {\n\t\tint llen = 0;  \n\n\t\t \n\t\tswitch (test + __LINE__ + 1) {\n\t\tCASE_TEST(argc);             EXPECT_GE(1, test_argc, 1); break;\n\t\tCASE_TEST(argv_addr);        EXPECT_PTRGT(1, test_argv, brk); break;\n\t\tCASE_TEST(argv_environ);     EXPECT_PTRLT(1, test_argv, environ); break;\n\t\tCASE_TEST(argv_total);       EXPECT_EQ(1, environ - test_argv - 1, test_argc ?: 1); break;\n\t\tCASE_TEST(argv0_addr);       EXPECT_PTRGT(1, argv0, brk); break;\n\t\tCASE_TEST(argv0_str);        EXPECT_STRNZ(1, argv0 > brk ? argv0 : NULL); break;\n\t\tCASE_TEST(argv0_len);        EXPECT_GE(1,  argv0 > brk ? strlen(argv0) : 0, 1); break;\n\t\tCASE_TEST(environ_addr);     EXPECT_PTRGT(1, environ, brk); break;\n\t\tCASE_TEST(environ_envp);     EXPECT_PTREQ(1, environ, test_envp); break;\n\t\tCASE_TEST(environ_auxv);     EXPECT_PTRLT(test_auxv != (void *)-1, environ, test_auxv); break;\n\t\tCASE_TEST(environ_total);    EXPECT_GE(test_auxv != (void *)-1, (void *)test_auxv - (void *)environ - 1, env_total); break;\n\t\tCASE_TEST(environ_HOME);     EXPECT_PTRNZ(1, getenv(\"HOME\")); break;\n\t\tCASE_TEST(auxv_addr);        EXPECT_PTRGT(test_auxv != (void *)-1, test_auxv, brk); break;\n\t\tCASE_TEST(auxv_AT_UID);      EXPECT_EQ(1, getauxval(AT_UID), getuid()); break;\n\t\tCASE_TEST(auxv_AT_PAGESZ);   EXPECT_GE(1, getauxval(AT_PAGESZ), 4096); break;\n\t\tcase __LINE__:\n\t\t\treturn ret;  \n\t\t \n\t\t}\n\t}\n\treturn ret;\n}\n\n\n \nint test_getdents64(const char *dir)\n{\n\tchar buffer[4096];\n\tint fd, ret;\n\tint err;\n\n\tret = fd = open(dir, O_RDONLY | O_DIRECTORY, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = getdents64(fd, (void *)buffer, sizeof(buffer));\n\terr = errno;\n\tclose(fd);\n\n\terrno = err;\n\treturn ret;\n}\n\nint test_getpagesize(void)\n{\n\tint x = getpagesize();\n\tint c;\n\n\tif (x < 0)\n\t\treturn x;\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__)\n\t \n\tc = (x == 4096);\n#elif defined(__aarch64__)\n\t \n\tc = (x == 4096 || x == (16 * 1024) || x == (64 * 1024));\n#else\n\t \n\tc = (x >= 4096);\n#endif\n\n\treturn !c;\n}\n\nint test_fork(void)\n{\n\tint status;\n\tpid_t pid;\n\n\t \n\tfflush(stdout);\n\tfflush(stderr);\n\n\tpid = fork();\n\n\tswitch (pid) {\n\tcase -1:\n\t\treturn 1;\n\n\tcase 0:\n\t\texit(123);\n\n\tdefault:\n\t\tpid = waitpid(pid, &status, 0);\n\n\t\treturn pid == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 123;\n\t}\n}\n\nint test_stat_timestamps(void)\n{\n\tstruct stat st;\n\n\tif (sizeof(st.st_atim.tv_sec) != sizeof(st.st_atime))\n\t\treturn 1;\n\n\tif (stat(\"/proc/self/\", &st) && stat(argv0, &st) && stat(\"/\", &st))\n\t\treturn 1;\n\n\tif (st.st_atim.tv_sec != st.st_atime || st.st_atim.tv_nsec > 1000000000)\n\t\treturn 1;\n\n\tif (st.st_mtim.tv_sec != st.st_mtime || st.st_mtim.tv_nsec > 1000000000)\n\t\treturn 1;\n\n\tif (st.st_ctim.tv_sec != st.st_ctime || st.st_ctim.tv_nsec > 1000000000)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint test_mmap_munmap(void)\n{\n\tint ret, fd, i, page_size;\n\tvoid *mem;\n\tsize_t file_size, length;\n\toff_t offset, pa_offset;\n\tstruct stat stat_buf;\n\tconst char * const files[] = {\n\t\t\"/dev/zero\",\n\t\t\"/proc/1/exe\", \"/proc/self/exe\",\n\t\targv0,\n\t\tNULL\n\t};\n\n\tpage_size = getpagesize();\n\tif (page_size < 0)\n\t\treturn 1;\n\n\t \n\tfor (i = 0; files[i] != NULL; i++) {\n\t\tret = fd = open(files[i], O_RDONLY);\n\t\tif (ret == -1)\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (ret == -1)\n\t\treturn 1;\n\n\tret = stat(files[i], &stat_buf);\n\tif (ret == -1)\n\t\tgoto end;\n\n\t \n\tif (i == 0)\n\t\tfile_size = 3*page_size;\n\telse\n\t\tfile_size = stat_buf.st_size;\n\n\toffset = file_size - 1;\n\tif (offset < 0)\n\t\toffset = 0;\n\tlength = file_size - offset;\n\tpa_offset = offset & ~(page_size - 1);\n\n\tmem = mmap(NULL, length + offset - pa_offset, PROT_READ, MAP_SHARED, fd, pa_offset);\n\tif (mem == MAP_FAILED) {\n\t\tret = 1;\n\t\tgoto end;\n\t}\n\n\tret = munmap(mem, length + offset - pa_offset);\n\nend:\n\tclose(fd);\n\treturn !!ret;\n}\n\nint test_pipe(void)\n{\n\tconst char *const msg = \"hello, nolibc\";\n\tint pipefd[2];\n\tchar buf[32];\n\tsize_t len;\n\n\tif (pipe(pipefd) == -1)\n\t\treturn 1;\n\n\twrite(pipefd[1], msg, strlen(msg));\n\tclose(pipefd[1]);\n\tlen = read(pipefd[0], buf, sizeof(buf));\n\tclose(pipefd[0]);\n\n\tif (len != strlen(msg))\n\t\treturn 1;\n\n\treturn !!memcmp(buf, msg, len);\n}\n\n\n \nint run_syscall(int min, int max)\n{\n\tstruct timeval tv;\n\tstruct timezone tz;\n\tstruct stat stat_buf;\n\tint euid0;\n\tint proc;\n\tint test;\n\tint tmp;\n\tint ret = 0;\n\tvoid *p1, *p2;\n\tint has_gettid = 1;\n\n\t \n\tproc = stat(\"/proc\", &stat_buf) == 0;\n\n\t \n\teuid0 = geteuid() == 0;\n\n\t \n#if defined(__GLIBC_MINOR__) && defined(__GLIBC__)\n\thas_gettid = __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 30);\n#endif\n\n\tfor (test = min; test >= 0 && test <= max; test++) {\n\t\tint llen = 0;  \n\n\t\t \n\t\tswitch (test + __LINE__ + 1) {\n\t\tCASE_TEST(getpid);            EXPECT_SYSNE(1, getpid(), -1); break;\n\t\tCASE_TEST(getppid);           EXPECT_SYSNE(1, getppid(), -1); break;\n\t\tCASE_TEST(gettid);            EXPECT_SYSNE(has_gettid, gettid(), -1); break;\n\t\tCASE_TEST(getpgid_self);      EXPECT_SYSNE(1, getpgid(0), -1); break;\n\t\tCASE_TEST(getpgid_bad);       EXPECT_SYSER(1, getpgid(-1), -1, ESRCH); break;\n\t\tCASE_TEST(kill_0);            EXPECT_SYSZR(1, kill(getpid(), 0)); break;\n\t\tCASE_TEST(kill_CONT);         EXPECT_SYSZR(1, kill(getpid(), 0)); break;\n\t\tCASE_TEST(kill_BADPID);       EXPECT_SYSER(1, kill(INT_MAX, 0), -1, ESRCH); break;\n\t\tCASE_TEST(sbrk_0);            EXPECT_PTRNE(1, sbrk(0), (void *)-1); break;\n\t\tCASE_TEST(sbrk);              if ((p1 = p2 = sbrk(4096)) != (void *)-1) p2 = sbrk(-4096); EXPECT_SYSZR(1, (p2 == (void *)-1) || p2 == p1); break;\n\t\tCASE_TEST(brk);               EXPECT_SYSZR(1, brk(sbrk(0))); break;\n\t\tCASE_TEST(chdir_root);        EXPECT_SYSZR(1, chdir(\"/\")); chdir(getenv(\"PWD\")); break;\n\t\tCASE_TEST(chdir_dot);         EXPECT_SYSZR(1, chdir(\".\")); break;\n\t\tCASE_TEST(chdir_blah);        EXPECT_SYSER(1, chdir(\"/blah\"), -1, ENOENT); break;\n\t\tCASE_TEST(chmod_argv0);       EXPECT_SYSZR(1, chmod(argv0, 0555)); break;\n\t\tCASE_TEST(chmod_self);        EXPECT_SYSER(proc, chmod(\"/proc/self\", 0555), -1, EPERM); break;\n\t\tCASE_TEST(chown_self);        EXPECT_SYSER(proc, chown(\"/proc/self\", 0, 0), -1, EPERM); break;\n\t\tCASE_TEST(chroot_root);       EXPECT_SYSZR(euid0, chroot(\"/\")); break;\n\t\tCASE_TEST(chroot_blah);       EXPECT_SYSER(1, chroot(\"/proc/self/blah\"), -1, ENOENT); break;\n\t\tCASE_TEST(chroot_exe);        EXPECT_SYSER(1, chroot(argv0), -1, ENOTDIR); break;\n\t\tCASE_TEST(close_m1);          EXPECT_SYSER(1, close(-1), -1, EBADF); break;\n\t\tCASE_TEST(close_dup);         EXPECT_SYSZR(1, close(dup(0))); break;\n\t\tCASE_TEST(dup_0);             tmp = dup(0);  EXPECT_SYSNE(1, tmp, -1); close(tmp); break;\n\t\tCASE_TEST(dup_m1);            tmp = dup(-1); EXPECT_SYSER(1, tmp, -1, EBADF); if (tmp != -1) close(tmp); break;\n\t\tCASE_TEST(dup2_0);            tmp = dup2(0, 100);  EXPECT_SYSNE(1, tmp, -1); close(tmp); break;\n\t\tCASE_TEST(dup2_m1);           tmp = dup2(-1, 100); EXPECT_SYSER(1, tmp, -1, EBADF); if (tmp != -1) close(tmp); break;\n\t\tCASE_TEST(dup3_0);            tmp = dup3(0, 100, 0);  EXPECT_SYSNE(1, tmp, -1); close(tmp); break;\n\t\tCASE_TEST(dup3_m1);           tmp = dup3(-1, 100, 0); EXPECT_SYSER(1, tmp, -1, EBADF); if (tmp != -1) close(tmp); break;\n\t\tCASE_TEST(execve_root);       EXPECT_SYSER(1, execve(\"/\", (char*[]){ [0] = \"/\", [1] = NULL }, NULL), -1, EACCES); break;\n\t\tCASE_TEST(fork);              EXPECT_SYSZR(1, test_fork()); break;\n\t\tCASE_TEST(getdents64_root);   EXPECT_SYSNE(1, test_getdents64(\"/\"), -1); break;\n\t\tCASE_TEST(getdents64_null);   EXPECT_SYSER(1, test_getdents64(\"/dev/null\"), -1, ENOTDIR); break;\n\t\tCASE_TEST(gettimeofday_tv);   EXPECT_SYSZR(1, gettimeofday(&tv, NULL)); break;\n\t\tCASE_TEST(gettimeofday_tv_tz);EXPECT_SYSZR(1, gettimeofday(&tv, &tz)); break;\n\t\tCASE_TEST(getpagesize);       EXPECT_SYSZR(1, test_getpagesize()); break;\n\t\tCASE_TEST(ioctl_tiocinq);     EXPECT_SYSZR(1, ioctl(0, TIOCINQ, &tmp)); break;\n\t\tCASE_TEST(ioctl_tiocinq);     EXPECT_SYSZR(1, ioctl(0, TIOCINQ, &tmp)); break;\n\t\tCASE_TEST(link_root1);        EXPECT_SYSER(1, link(\"/\", \"/\"), -1, EEXIST); break;\n\t\tCASE_TEST(link_blah);         EXPECT_SYSER(1, link(\"/proc/self/blah\", \"/blah\"), -1, ENOENT); break;\n\t\tCASE_TEST(link_dir);          EXPECT_SYSER(euid0, link(\"/\", \"/blah\"), -1, EPERM); break;\n\t\tCASE_TEST(link_cross);        EXPECT_SYSER(proc, link(\"/proc/self/cmdline\", \"/blah\"), -1, EXDEV); break;\n\t\tCASE_TEST(lseek_m1);          EXPECT_SYSER(1, lseek(-1, 0, SEEK_SET), -1, EBADF); break;\n\t\tCASE_TEST(lseek_0);           EXPECT_SYSER(1, lseek(0, 0, SEEK_SET), -1, ESPIPE); break;\n\t\tCASE_TEST(mkdir_root);        EXPECT_SYSER(1, mkdir(\"/\", 0755), -1, EEXIST); break;\n\t\tCASE_TEST(mmap_bad);          EXPECT_PTRER(1, mmap(NULL, 0, PROT_READ, MAP_PRIVATE, 0, 0), MAP_FAILED, EINVAL); break;\n\t\tCASE_TEST(munmap_bad);        EXPECT_SYSER(1, munmap((void *)1, 0), -1, EINVAL); break;\n\t\tCASE_TEST(mmap_munmap_good);  EXPECT_SYSZR(1, test_mmap_munmap()); break;\n\t\tCASE_TEST(open_tty);          EXPECT_SYSNE(1, tmp = open(\"/dev/null\", 0), -1); if (tmp != -1) close(tmp); break;\n\t\tCASE_TEST(open_blah);         EXPECT_SYSER(1, tmp = open(\"/proc/self/blah\", 0), -1, ENOENT); if (tmp != -1) close(tmp); break;\n\t\tCASE_TEST(pipe);              EXPECT_SYSZR(1, test_pipe()); break;\n\t\tCASE_TEST(poll_null);         EXPECT_SYSZR(1, poll(NULL, 0, 0)); break;\n\t\tCASE_TEST(poll_stdout);       EXPECT_SYSNE(1, ({ struct pollfd fds = { 1, POLLOUT, 0}; poll(&fds, 1, 0); }), -1); break;\n\t\tCASE_TEST(poll_fault);        EXPECT_SYSER(1, poll((void *)1, 1, 0), -1, EFAULT); break;\n\t\tCASE_TEST(prctl);             EXPECT_SYSER(1, prctl(PR_SET_NAME, (unsigned long)NULL, 0, 0, 0), -1, EFAULT); break;\n\t\tCASE_TEST(read_badf);         EXPECT_SYSER(1, read(-1, &tmp, 1), -1, EBADF); break;\n\t\tCASE_TEST(rmdir_blah);        EXPECT_SYSER(1, rmdir(\"/blah\"), -1, ENOENT); break;\n\t\tCASE_TEST(sched_yield);       EXPECT_SYSZR(1, sched_yield()); break;\n\t\tCASE_TEST(select_null);       EXPECT_SYSZR(1, ({ struct timeval tv = { 0 }; select(0, NULL, NULL, NULL, &tv); })); break;\n\t\tCASE_TEST(select_stdout);     EXPECT_SYSNE(1, ({ fd_set fds; FD_ZERO(&fds); FD_SET(1, &fds); select(2, NULL, &fds, NULL, NULL); }), -1); break;\n\t\tCASE_TEST(select_fault);      EXPECT_SYSER(1, select(1, (void *)1, NULL, NULL, 0), -1, EFAULT); break;\n\t\tCASE_TEST(stat_blah);         EXPECT_SYSER(1, stat(\"/proc/self/blah\", &stat_buf), -1, ENOENT); break;\n\t\tCASE_TEST(stat_fault);        EXPECT_SYSER(1, stat((void *)1, &stat_buf), -1, EFAULT); break;\n\t\tCASE_TEST(stat_timestamps);   EXPECT_SYSZR(1, test_stat_timestamps()); break;\n\t\tCASE_TEST(symlink_root);      EXPECT_SYSER(1, symlink(\"/\", \"/\"), -1, EEXIST); break;\n\t\tCASE_TEST(unlink_root);       EXPECT_SYSER(1, unlink(\"/\"), -1, EISDIR); break;\n\t\tCASE_TEST(unlink_blah);       EXPECT_SYSER(1, unlink(\"/proc/self/blah\"), -1, ENOENT); break;\n\t\tCASE_TEST(wait_child);        EXPECT_SYSER(1, wait(&tmp), -1, ECHILD); break;\n\t\tCASE_TEST(waitpid_min);       EXPECT_SYSER(1, waitpid(INT_MIN, &tmp, WNOHANG), -1, ESRCH); break;\n\t\tCASE_TEST(waitpid_child);     EXPECT_SYSER(1, waitpid(getpid(), &tmp, WNOHANG), -1, ECHILD); break;\n\t\tCASE_TEST(write_badf);        EXPECT_SYSER(1, write(-1, &tmp, 1), -1, EBADF); break;\n\t\tCASE_TEST(write_zero);        EXPECT_SYSZR(1, write(1, &tmp, 0)); break;\n\t\tCASE_TEST(syscall_noargs);    EXPECT_SYSEQ(1, syscall(__NR_getpid), getpid()); break;\n\t\tCASE_TEST(syscall_args);      EXPECT_SYSER(1, syscall(__NR_statx, 0, NULL, 0, 0, NULL), -1, EFAULT); break;\n\t\tcase __LINE__:\n\t\t\treturn ret;  \n\t\t \n\t\t}\n\t}\n\treturn ret;\n}\n\nint run_stdlib(int min, int max)\n{\n\tint test;\n\tint ret = 0;\n\n\tfor (test = min; test >= 0 && test <= max; test++) {\n\t\tint llen = 0;  \n\n\t\t \n\t\tswitch (test + __LINE__ + 1) {\n\t\tCASE_TEST(getenv_TERM);        EXPECT_STRNZ(1, getenv(\"TERM\")); break;\n\t\tCASE_TEST(getenv_blah);        EXPECT_STRZR(1, getenv(\"blah\")); break;\n\t\tCASE_TEST(setcmp_blah_blah);   EXPECT_EQ(1, strcmp(\"blah\", \"blah\"), 0); break;\n\t\tCASE_TEST(setcmp_blah_blah2);  EXPECT_NE(1, strcmp(\"blah\", \"blah2\"), 0); break;\n\t\tCASE_TEST(setncmp_blah_blah);  EXPECT_EQ(1, strncmp(\"blah\", \"blah\", 10), 0); break;\n\t\tCASE_TEST(setncmp_blah_blah4); EXPECT_EQ(1, strncmp(\"blah\", \"blah4\", 4), 0); break;\n\t\tCASE_TEST(setncmp_blah_blah5); EXPECT_NE(1, strncmp(\"blah\", \"blah5\", 5), 0); break;\n\t\tCASE_TEST(setncmp_blah_blah6); EXPECT_NE(1, strncmp(\"blah\", \"blah6\", 6), 0); break;\n\t\tCASE_TEST(strchr_foobar_o);    EXPECT_STREQ(1, strchr(\"foobar\", 'o'), \"oobar\"); break;\n\t\tCASE_TEST(strchr_foobar_z);    EXPECT_STRZR(1, strchr(\"foobar\", 'z')); break;\n\t\tCASE_TEST(strrchr_foobar_o);   EXPECT_STREQ(1, strrchr(\"foobar\", 'o'), \"obar\"); break;\n\t\tCASE_TEST(strrchr_foobar_z);   EXPECT_STRZR(1, strrchr(\"foobar\", 'z')); break;\n\t\tCASE_TEST(memcmp_20_20);       EXPECT_EQ(1, memcmp(\"aaa\\x20\", \"aaa\\x20\", 4), 0); break;\n\t\tCASE_TEST(memcmp_20_60);       EXPECT_LT(1, memcmp(\"aaa\\x20\", \"aaa\\x60\", 4), 0); break;\n\t\tCASE_TEST(memcmp_60_20);       EXPECT_GT(1, memcmp(\"aaa\\x60\", \"aaa\\x20\", 4), 0); break;\n\t\tCASE_TEST(memcmp_20_e0);       EXPECT_LT(1, memcmp(\"aaa\\x20\", \"aaa\\xe0\", 4), 0); break;\n\t\tCASE_TEST(memcmp_e0_20);       EXPECT_GT(1, memcmp(\"aaa\\xe0\", \"aaa\\x20\", 4), 0); break;\n\t\tCASE_TEST(memcmp_80_e0);       EXPECT_LT(1, memcmp(\"aaa\\x80\", \"aaa\\xe0\", 4), 0); break;\n\t\tCASE_TEST(memcmp_e0_80);       EXPECT_GT(1, memcmp(\"aaa\\xe0\", \"aaa\\x80\", 4), 0); break;\n\t\tCASE_TEST(limit_int8_max);          EXPECT_EQ(1, INT8_MAX,         (int8_t)          0x7f); break;\n\t\tCASE_TEST(limit_int8_min);          EXPECT_EQ(1, INT8_MIN,         (int8_t)          0x80); break;\n\t\tCASE_TEST(limit_uint8_max);         EXPECT_EQ(1, UINT8_MAX,        (uint8_t)         0xff); break;\n\t\tCASE_TEST(limit_int16_max);         EXPECT_EQ(1, INT16_MAX,        (int16_t)         0x7fff); break;\n\t\tCASE_TEST(limit_int16_min);         EXPECT_EQ(1, INT16_MIN,        (int16_t)         0x8000); break;\n\t\tCASE_TEST(limit_uint16_max);        EXPECT_EQ(1, UINT16_MAX,       (uint16_t)        0xffff); break;\n\t\tCASE_TEST(limit_int32_max);         EXPECT_EQ(1, INT32_MAX,        (int32_t)         0x7fffffff); break;\n\t\tCASE_TEST(limit_int32_min);         EXPECT_EQ(1, INT32_MIN,        (int32_t)         0x80000000); break;\n\t\tCASE_TEST(limit_uint32_max);        EXPECT_EQ(1, UINT32_MAX,       (uint32_t)        0xffffffff); break;\n\t\tCASE_TEST(limit_int64_max);         EXPECT_EQ(1, INT64_MAX,        (int64_t)         0x7fffffffffffffff); break;\n\t\tCASE_TEST(limit_int64_min);         EXPECT_EQ(1, INT64_MIN,        (int64_t)         0x8000000000000000); break;\n\t\tCASE_TEST(limit_uint64_max);        EXPECT_EQ(1, UINT64_MAX,       (uint64_t)        0xffffffffffffffff); break;\n\t\tCASE_TEST(limit_int_least8_max);    EXPECT_EQ(1, INT_LEAST8_MAX,   (int_least8_t)    0x7f); break;\n\t\tCASE_TEST(limit_int_least8_min);    EXPECT_EQ(1, INT_LEAST8_MIN,   (int_least8_t)    0x80); break;\n\t\tCASE_TEST(limit_uint_least8_max);   EXPECT_EQ(1, UINT_LEAST8_MAX,  (uint_least8_t)   0xff); break;\n\t\tCASE_TEST(limit_int_least16_max);   EXPECT_EQ(1, INT_LEAST16_MAX,  (int_least16_t)   0x7fff); break;\n\t\tCASE_TEST(limit_int_least16_min);   EXPECT_EQ(1, INT_LEAST16_MIN,  (int_least16_t)   0x8000); break;\n\t\tCASE_TEST(limit_uint_least16_max);  EXPECT_EQ(1, UINT_LEAST16_MAX, (uint_least16_t)  0xffff); break;\n\t\tCASE_TEST(limit_int_least32_max);   EXPECT_EQ(1, INT_LEAST32_MAX,  (int_least32_t)   0x7fffffff); break;\n\t\tCASE_TEST(limit_int_least32_min);   EXPECT_EQ(1, INT_LEAST32_MIN,  (int_least32_t)   0x80000000); break;\n\t\tCASE_TEST(limit_uint_least32_max);  EXPECT_EQ(1, UINT_LEAST32_MAX, (uint_least32_t)  0xffffffffU); break;\n\t\tCASE_TEST(limit_int_least64_min);   EXPECT_EQ(1, INT_LEAST64_MIN,  (int_least64_t)   0x8000000000000000LL); break;\n\t\tCASE_TEST(limit_int_least64_max);   EXPECT_EQ(1, INT_LEAST64_MAX,  (int_least64_t)   0x7fffffffffffffffLL); break;\n\t\tCASE_TEST(limit_uint_least64_max);  EXPECT_EQ(1, UINT_LEAST64_MAX, (uint_least64_t)  0xffffffffffffffffULL); break;\n\t\tCASE_TEST(limit_int_fast8_max);     EXPECT_EQ(1, INT_FAST8_MAX,    (int_fast8_t)     0x7f); break;\n\t\tCASE_TEST(limit_int_fast8_min);     EXPECT_EQ(1, INT_FAST8_MIN,    (int_fast8_t)     0x80); break;\n\t\tCASE_TEST(limit_uint_fast8_max);    EXPECT_EQ(1, UINT_FAST8_MAX,   (uint_fast8_t)    0xff); break;\n\t\tCASE_TEST(limit_int_fast16_min);    EXPECT_EQ(1, INT_FAST16_MIN,   (int_fast16_t)    SINT_MIN_OF_TYPE(int_fast16_t)); break;\n\t\tCASE_TEST(limit_int_fast16_max);    EXPECT_EQ(1, INT_FAST16_MAX,   (int_fast16_t)    SINT_MAX_OF_TYPE(int_fast16_t)); break;\n\t\tCASE_TEST(limit_uint_fast16_max);   EXPECT_EQ(1, UINT_FAST16_MAX,  (uint_fast16_t)   UINTPTR_MAX); break;\n\t\tCASE_TEST(limit_int_fast32_min);    EXPECT_EQ(1, INT_FAST32_MIN,   (int_fast32_t)    SINT_MIN_OF_TYPE(int_fast32_t)); break;\n\t\tCASE_TEST(limit_int_fast32_max);    EXPECT_EQ(1, INT_FAST32_MAX,   (int_fast32_t)    SINT_MAX_OF_TYPE(int_fast32_t)); break;\n\t\tCASE_TEST(limit_uint_fast32_max);   EXPECT_EQ(1, UINT_FAST32_MAX,  (uint_fast32_t)   UINTPTR_MAX); break;\n\t\tCASE_TEST(limit_int_fast64_min);    EXPECT_EQ(1, INT_FAST64_MIN,   (int_fast64_t)    INT64_MIN); break;\n\t\tCASE_TEST(limit_int_fast64_max);    EXPECT_EQ(1, INT_FAST64_MAX,   (int_fast64_t)    INT64_MAX); break;\n\t\tCASE_TEST(limit_uint_fast64_max);   EXPECT_EQ(1, UINT_FAST64_MAX,  (uint_fast64_t)   UINT64_MAX); break;\n\t\tCASE_TEST(sizeof_long_sane);        EXPECT_EQ(1, sizeof(long) == 8 || sizeof(long) == 4, 1); break;\n\t\tCASE_TEST(limit_intptr_min);        EXPECT_EQ(1, INTPTR_MIN,  sizeof(long) == 8 ? (intptr_t)  0x8000000000000000LL  : (intptr_t)  0x80000000); break;\n\t\tCASE_TEST(limit_intptr_max);        EXPECT_EQ(1, INTPTR_MAX,  sizeof(long) == 8 ? (intptr_t)  0x7fffffffffffffffLL  : (intptr_t)  0x7fffffff); break;\n\t\tCASE_TEST(limit_uintptr_max);       EXPECT_EQ(1, UINTPTR_MAX, sizeof(long) == 8 ? (uintptr_t) 0xffffffffffffffffULL : (uintptr_t) 0xffffffffU); break;\n\t\tCASE_TEST(limit_ptrdiff_min);       EXPECT_EQ(1, PTRDIFF_MIN, sizeof(long) == 8 ? (ptrdiff_t) 0x8000000000000000LL  : (ptrdiff_t) 0x80000000); break;\n\t\tCASE_TEST(limit_ptrdiff_max);       EXPECT_EQ(1, PTRDIFF_MAX, sizeof(long) == 8 ? (ptrdiff_t) 0x7fffffffffffffffLL  : (ptrdiff_t) 0x7fffffff); break;\n\t\tCASE_TEST(limit_size_max);          EXPECT_EQ(1, SIZE_MAX,    sizeof(long) == 8 ? (size_t)    0xffffffffffffffffULL : (size_t)    0xffffffffU); break;\n\n\t\tcase __LINE__:\n\t\t\treturn ret;  \n\t\t \n\t\t}\n\t}\n\treturn ret;\n}\n\n#define EXPECT_VFPRINTF(c, expected, fmt, ...)\t\t\t\t\\\n\tret += expect_vfprintf(llen, c, expected, fmt, ##__VA_ARGS__)\n\nstatic int expect_vfprintf(int llen, int c, const char *expected, const char *fmt, ...)\n{\n\tint ret, fd;\n\tssize_t w, r;\n\tchar buf[100];\n\tFILE *memfile;\n\tva_list args;\n\n\tfd = open(\"/tmp\", O_TMPFILE | O_EXCL | O_RDWR, 0600);\n\tif (fd == -1) {\n\t\tresult(llen, SKIPPED);\n\t\treturn 0;\n\t}\n\n\tmemfile = fdopen(fd, \"w+\");\n\tif (!memfile) {\n\t\tresult(llen, FAIL);\n\t\treturn 1;\n\t}\n\n\tva_start(args, fmt);\n\tw = vfprintf(memfile, fmt, args);\n\tva_end(args);\n\n\tif (w != c) {\n\t\tllen += printf(\" written(%d) != %d\", (int)w, c);\n\t\tresult(llen, FAIL);\n\t\treturn 1;\n\t}\n\n\tfflush(memfile);\n\tlseek(fd, 0, SEEK_SET);\n\n\tr = read(fd, buf, sizeof(buf) - 1);\n\n\tfclose(memfile);\n\n\tif (r != w) {\n\t\tllen += printf(\" written(%d) != read(%d)\", (int)w, (int)r);\n\t\tresult(llen, FAIL);\n\t\treturn 1;\n\t}\n\n\tbuf[r] = '\\0';\n\tllen += printf(\" \\\"%s\\\" = \\\"%s\\\"\", expected, buf);\n\tret = strncmp(expected, buf, c);\n\n\tresult(llen, ret ? FAIL : OK);\n\treturn ret;\n}\n\nstatic int run_vfprintf(int min, int max)\n{\n\tint test;\n\tint ret = 0;\n\n\tfor (test = min; test >= 0 && test <= max; test++) {\n\t\tint llen = 0;  \n\n\t\t \n\t\tswitch (test + __LINE__ + 1) {\n\t\tCASE_TEST(empty);        EXPECT_VFPRINTF(0, \"\", \"\"); break;\n\t\tCASE_TEST(simple);       EXPECT_VFPRINTF(3, \"foo\", \"foo\"); break;\n\t\tCASE_TEST(string);       EXPECT_VFPRINTF(3, \"foo\", \"%s\", \"foo\"); break;\n\t\tCASE_TEST(number);       EXPECT_VFPRINTF(4, \"1234\", \"%d\", 1234); break;\n\t\tCASE_TEST(negnumber);    EXPECT_VFPRINTF(5, \"-1234\", \"%d\", -1234); break;\n\t\tCASE_TEST(unsigned);     EXPECT_VFPRINTF(5, \"12345\", \"%u\", 12345); break;\n\t\tCASE_TEST(char);         EXPECT_VFPRINTF(1, \"c\", \"%c\", 'c'); break;\n\t\tCASE_TEST(hex);          EXPECT_VFPRINTF(1, \"f\", \"%x\", 0xf); break;\n\t\tCASE_TEST(pointer);      EXPECT_VFPRINTF(3, \"0x1\", \"%p\", (void *) 0x1); break;\n\t\tcase __LINE__:\n\t\t\treturn ret;  \n\t\t \n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int smash_stack(void)\n{\n\tchar buf[100];\n\tvolatile char *ptr = buf;\n\tsize_t i;\n\n\tfor (i = 0; i < 200; i++)\n\t\tptr[i] = 'P';\n\n\treturn 1;\n}\n\nstatic int run_protection(int min __attribute__((unused)),\n\t\t\t  int max __attribute__((unused)))\n{\n\tpid_t pid;\n\tint llen = 0, status;\n\n\tllen += printf(\"0 -fstackprotector \");\n\n#if !defined(_NOLIBC_STACKPROTECTOR)\n\tllen += printf(\"not supported\");\n\tresult(llen, SKIPPED);\n\treturn 0;\n#endif\n\n#if defined(_NOLIBC_STACKPROTECTOR)\n\tif (!__stack_chk_guard) {\n\t\tllen += printf(\"__stack_chk_guard not initialized\");\n\t\tresult(llen, FAIL);\n\t\treturn 1;\n\t}\n#endif\n\n\tpid = -1;\n\tpid = fork();\n\n\tswitch (pid) {\n\tcase -1:\n\t\tllen += printf(\"fork()\");\n\t\tresult(llen, FAIL);\n\t\treturn 1;\n\n\tcase 0:\n\t\tclose(STDOUT_FILENO);\n\t\tclose(STDERR_FILENO);\n\n\t\tprctl(PR_SET_DUMPABLE, 0, 0, 0, 0);\n\t\tsmash_stack();\n\t\treturn 1;\n\n\tdefault:\n\t\tpid = waitpid(pid, &status, 0);\n\n\t\tif (pid == -1 || !WIFSIGNALED(status) || WTERMSIG(status) != SIGABRT) {\n\t\t\tllen += printf(\"waitpid()\");\n\t\t\tresult(llen, FAIL);\n\t\t\treturn 1;\n\t\t}\n\t\tresult(llen, OK);\n\t\treturn 0;\n\t}\n}\n\n \nint prepare(void)\n{\n\tstruct stat stat_buf;\n\n\t \n\tif (stat(\"/dev/.\", &stat_buf) == 0 || mkdir(\"/dev\", 0755) == 0) {\n\t\tif (stat(\"/dev/console\", &stat_buf) != 0 ||\n\t\t    stat(\"/dev/null\", &stat_buf) != 0 ||\n\t\t    stat(\"/dev/zero\", &stat_buf) != 0) {\n\t\t\t \n\t\t\tif (mount(\"/dev\", \"/dev\", \"devtmpfs\", 0, 0) != 0) {\n\t\t\t\tmknod(\"/dev/console\", 0600 | S_IFCHR, makedev(5, 1));\n\t\t\t\tmknod(\"/dev/null\",    0666 | S_IFCHR, makedev(1, 3));\n\t\t\t\tmknod(\"/dev/zero\",    0666 | S_IFCHR, makedev(1, 5));\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (close(dup(1)) == -1) {\n\t\tint fd = open(\"/dev/console\", O_RDWR);\n\n\t\tif (fd >= 0) {\n\t\t\tif (fd != 0)\n\t\t\t\tdup2(fd, 0);\n\t\t\tif (fd != 1)\n\t\t\t\tdup2(fd, 1);\n\t\t\tif (fd != 2)\n\t\t\t\tdup2(fd, 2);\n\t\t\tif (fd > 2)\n\t\t\t\tclose(fd);\n\t\t\tputs(\"\\nSuccessfully reopened /dev/console.\");\n\t\t}\n\t}\n\n\t \n\tif (stat(\"/proc/.\", &stat_buf) == 0 || mkdir(\"/proc\", 0755) == 0) {\n\t\tif (stat(\"/proc/self\", &stat_buf) != 0) {\n\t\t\t \n\t\t\tif (mount(\"none\", \"/proc\", \"proc\", 0, 0) != 0)\n\t\t\t\trmdir(\"/proc\");\n\t\t}\n\t}\n\n\t \n\tmkdir(\"/tmp\", 0755);\n\n\treturn 0;\n}\n\n \nstatic const struct test test_names[] = {\n\t \n\t{ .name = \"startup\",    .func = run_startup    },\n\t{ .name = \"syscall\",    .func = run_syscall    },\n\t{ .name = \"stdlib\",     .func = run_stdlib     },\n\t{ .name = \"vfprintf\",   .func = run_vfprintf   },\n\t{ .name = \"protection\", .func = run_protection },\n\t{ 0 }\n};\n\nstatic int is_setting_valid(char *test)\n{\n\tint idx, len, test_len, valid = 0;\n\tchar delimiter;\n\n\tif (!test)\n\t\treturn valid;\n\n\ttest_len = strlen(test);\n\n\tfor (idx = 0; test_names[idx].name; idx++) {\n\t\tlen = strlen(test_names[idx].name);\n\t\tif (test_len < len)\n\t\t\tcontinue;\n\n\t\tif (strncmp(test, test_names[idx].name, len) != 0)\n\t\t\tcontinue;\n\n\t\tdelimiter = test[len];\n\t\tif (delimiter != ':' && delimiter != ',' && delimiter != '\\0')\n\t\t\tcontinue;\n\n\t\tvalid = 1;\n\t\tbreak;\n\t}\n\n\treturn valid;\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint min = 0;\n\tint max = INT_MAX;\n\tint ret = 0;\n\tint err;\n\tint idx;\n\tchar *test;\n\n\targv0 = argv[0];\n\ttest_argc = argc;\n\ttest_argv = argv;\n\ttest_envp = envp;\n\n\t \n\tif (getpid() == 1)\n\t\tprepare();\n\n\t \n\ttest = argv[1];\n\tif (!is_setting_valid(test))\n\t\ttest = getenv(\"NOLIBC_TEST\");\n\n\tif (is_setting_valid(test)) {\n\t\tchar *comma, *colon, *dash, *value;\n\n\t\tdo {\n\t\t\tcomma = strchr(test, ',');\n\t\t\tif (comma)\n\t\t\t\t*(comma++) = '\\0';\n\n\t\t\tcolon = strchr(test, ':');\n\t\t\tif (colon)\n\t\t\t\t*(colon++) = '\\0';\n\n\t\t\tfor (idx = 0; test_names[idx].name; idx++) {\n\t\t\t\tif (strcmp(test, test_names[idx].name) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (test_names[idx].name) {\n\t\t\t\t \n\t\t\t\tdo {\n\t\t\t\t\tmin = 0; max = INT_MAX;\n\t\t\t\t\tvalue = colon;\n\t\t\t\t\tif (value && *value) {\n\t\t\t\t\t\tcolon = strchr(value, ':');\n\t\t\t\t\t\tif (colon)\n\t\t\t\t\t\t\t*(colon++) = '\\0';\n\n\t\t\t\t\t\tdash = strchr(value, '-');\n\t\t\t\t\t\tif (dash)\n\t\t\t\t\t\t\t*(dash++) = '\\0';\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (*value)\n\t\t\t\t\t\t\tmin = atoi(value);\n\t\t\t\t\t\tif (!dash)\n\t\t\t\t\t\t\tmax = min;\n\t\t\t\t\t\telse if (*dash)\n\t\t\t\t\t\t\tmax = atoi(dash);\n\n\t\t\t\t\t\tvalue = colon;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tprintf(\"Running test '%s'\\n\", test_names[idx].name);\n\t\t\t\t\terr = test_names[idx].func(min, max);\n\t\t\t\t\tret += err;\n\t\t\t\t\tprintf(\"Errors during this test: %d\\n\\n\", err);\n\t\t\t\t} while (colon && *colon);\n\t\t\t} else\n\t\t\t\tprintf(\"Ignoring unknown test name '%s'\\n\", test);\n\n\t\t\ttest = comma;\n\t\t} while (test && *test);\n\t} else {\n\t\t \n\t\tfor (idx = 0; test_names[idx].name; idx++) {\n\t\t\tprintf(\"Running test '%s'\\n\", test_names[idx].name);\n\t\t\terr = test_names[idx].func(min, max);\n\t\t\tret += err;\n\t\t\tprintf(\"Errors during this test: %d\\n\\n\", err);\n\t\t}\n\t}\n\n\tprintf(\"Total number of errors: %d\\n\", ret);\n\n\tif (getpid() == 1) {\n\t\t \n\t\tprintf(\"Leaving init with final status: %d\\n\", !!ret);\n\t\tif (ret == 0)\n\t\t\treboot(RB_POWER_OFF);\n#if defined(__x86_64__)\n\t\t \n\t\telse if (syscall(__NR_ioperm, 0x501, 1, 1) == 0)\n\t\t\t__asm__ volatile (\"outb %%al, %%dx\" :: \"d\"(0x501), \"a\"(0));\n\t\t \n#endif\n\t}\n\n\tprintf(\"Exiting with status %d\\n\", !!ret);\n\treturn !!ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}