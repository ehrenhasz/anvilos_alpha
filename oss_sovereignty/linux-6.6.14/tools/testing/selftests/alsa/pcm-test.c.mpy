{
  "module_name": "pcm-test.c",
  "hash_id": "54d4c3969ff47130f4b193976df7f3e284d3c8b0c5c59aa34d9c1b1ebceaf2d3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/alsa/pcm-test.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <assert.h>\n#include <pthread.h>\n\n#include \"../kselftest.h\"\n#include \"alsa-local.h\"\n\ntypedef struct timespec timestamp_t;\n\nstruct card_data {\n\tint card;\n\tpthread_t thread;\n\tstruct card_data *next;\n};\n\nstruct card_data *card_list = NULL;\n\nstruct pcm_data {\n\tsnd_pcm_t *handle;\n\tint card;\n\tint device;\n\tint subdevice;\n\tsnd_pcm_stream_t stream;\n\tsnd_config_t *pcm_config;\n\tstruct pcm_data *next;\n};\n\nstruct pcm_data *pcm_list = NULL;\n\nint num_missing = 0;\nstruct pcm_data *pcm_missing = NULL;\n\nsnd_config_t *default_pcm_config;\n\n \npthread_mutex_t results_lock = PTHREAD_MUTEX_INITIALIZER;\n\nenum test_class {\n\tTEST_CLASS_DEFAULT,\n\tTEST_CLASS_SYSTEM,\n};\n\nvoid timestamp_now(timestamp_t *tstamp)\n{\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, tstamp))\n\t\tksft_exit_fail_msg(\"clock_get_time\\n\");\n}\n\nlong long timestamp_diff_ms(timestamp_t *tstamp)\n{\n\ttimestamp_t now, diff;\n\ttimestamp_now(&now);\n\tif (tstamp->tv_nsec > now.tv_nsec) {\n\t\tdiff.tv_sec = now.tv_sec - tstamp->tv_sec - 1;\n\t\tdiff.tv_nsec = (now.tv_nsec + 1000000000L) - tstamp->tv_nsec;\n\t} else {\n\t\tdiff.tv_sec = now.tv_sec - tstamp->tv_sec;\n\t\tdiff.tv_nsec = now.tv_nsec - tstamp->tv_nsec;\n\t}\n\treturn (diff.tv_sec * 1000) + ((diff.tv_nsec + 500000L) / 1000000L);\n}\n\nstatic long device_from_id(snd_config_t *node)\n{\n\tconst char *id;\n\tchar *end;\n\tlong v;\n\n\tif (snd_config_get_id(node, &id))\n\t\tksft_exit_fail_msg(\"snd_config_get_id\\n\");\n\terrno = 0;\n\tv = strtol(id, &end, 10);\n\tif (errno || *end)\n\t\treturn -1;\n\treturn v;\n}\n\nstatic void missing_device(int card, int device, int subdevice, snd_pcm_stream_t stream)\n{\n\tstruct pcm_data *pcm_data;\n\n\tfor (pcm_data = pcm_list; pcm_data != NULL; pcm_data = pcm_data->next) {\n\t\tif (pcm_data->card != card)\n\t\t\tcontinue;\n\t\tif (pcm_data->device != device)\n\t\t\tcontinue;\n\t\tif (pcm_data->subdevice != subdevice)\n\t\t\tcontinue;\n\t\tif (pcm_data->stream != stream)\n\t\t\tcontinue;\n\t\treturn;\n\t}\n\tpcm_data = calloc(1, sizeof(*pcm_data));\n\tif (!pcm_data)\n\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\tpcm_data->card = card;\n\tpcm_data->device = device;\n\tpcm_data->subdevice = subdevice;\n\tpcm_data->stream = stream;\n\tpcm_data->next = pcm_missing;\n\tpcm_missing = pcm_data;\n\tnum_missing++;\n}\n\nstatic void missing_devices(int card, snd_config_t *card_config)\n{\n\tsnd_config_t *pcm_config, *node1, *node2;\n\tsnd_config_iterator_t i1, i2, next1, next2;\n\tint device, subdevice;\n\n\tpcm_config = conf_get_subtree(card_config, \"pcm\", NULL);\n\tif (!pcm_config)\n\t\treturn;\n\tsnd_config_for_each(i1, next1, pcm_config) {\n\t\tnode1 = snd_config_iterator_entry(i1);\n\t\tdevice = device_from_id(node1);\n\t\tif (device < 0)\n\t\t\tcontinue;\n\t\tif (snd_config_get_type(node1) != SND_CONFIG_TYPE_COMPOUND)\n\t\t\tcontinue;\n\t\tsnd_config_for_each(i2, next2, node1) {\n\t\t\tnode2 = snd_config_iterator_entry(i2);\n\t\t\tsubdevice = device_from_id(node2);\n\t\t\tif (subdevice < 0)\n\t\t\t\tcontinue;\n\t\t\tif (conf_get_subtree(node2, \"PLAYBACK\", NULL))\n\t\t\t\tmissing_device(card, device, subdevice, SND_PCM_STREAM_PLAYBACK);\n\t\t\tif (conf_get_subtree(node2, \"CAPTURE\", NULL))\n\t\t\t\tmissing_device(card, device, subdevice, SND_PCM_STREAM_CAPTURE);\n\t\t}\n\t}\n}\n\nstatic void find_pcms(void)\n{\n\tchar name[32], key[64];\n\tchar *card_name, *card_longname;\n\tint card, dev, subdev, count, direction, err;\n\tsnd_pcm_stream_t stream;\n\tstruct pcm_data *pcm_data;\n\tsnd_ctl_t *handle;\n\tsnd_pcm_info_t *pcm_info;\n\tsnd_config_t *config, *card_config, *pcm_config;\n\tstruct card_data *card_data;\n\n\tsnd_pcm_info_alloca(&pcm_info);\n\n\tcard = -1;\n\tif (snd_card_next(&card) < 0 || card < 0)\n\t\treturn;\n\n\tconfig = get_alsalib_config();\n\n\twhile (card >= 0) {\n\t\tsprintf(name, \"hw:%d\", card);\n\n\t\terr = snd_ctl_open_lconf(&handle, name, 0, config);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"Failed to get hctl for card %d: %s\\n\",\n\t\t\t\t       card, snd_strerror(err));\n\t\t\tgoto next_card;\n\t\t}\n\n\t\terr = snd_card_get_name(card, &card_name);\n\t\tif (err != 0)\n\t\t\tcard_name = \"Unknown\";\n\t\terr = snd_card_get_longname(card, &card_longname);\n\t\tif (err != 0)\n\t\t\tcard_longname = \"Unknown\";\n\t\tksft_print_msg(\"Card %d - %s (%s)\\n\", card,\n\t\t\t       card_name, card_longname);\n\n\t\tcard_config = conf_by_card(card);\n\n\t\tcard_data = calloc(1, sizeof(*card_data));\n\t\tif (!card_data)\n\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t\tcard_data->card = card;\n\t\tcard_data->next = card_list;\n\t\tcard_list = card_data;\n\n\t\tdev = -1;\n\t\twhile (1) {\n\t\t\tif (snd_ctl_pcm_next_device(handle, &dev) < 0)\n\t\t\t\tksft_exit_fail_msg(\"snd_ctl_pcm_next_device\\n\");\n\t\t\tif (dev < 0)\n\t\t\t\tbreak;\n\n\t\t\tfor (direction = 0; direction < 2; direction++) {\n\t\t\t\tstream = direction ? SND_PCM_STREAM_CAPTURE : SND_PCM_STREAM_PLAYBACK;\n\t\t\t\tsprintf(key, \"pcm.%d.%s\", dev, snd_pcm_stream_name(stream));\n\t\t\t\tpcm_config = conf_get_subtree(card_config, key, NULL);\n\t\t\t\tif (conf_get_bool(card_config, key, \"skip\", false)) {\n\t\t\t\t\tksft_print_msg(\"skipping pcm %d.%d.%s\\n\", card, dev, snd_pcm_stream_name(stream));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsnd_pcm_info_set_device(pcm_info, dev);\n\t\t\t\tsnd_pcm_info_set_subdevice(pcm_info, 0);\n\t\t\t\tsnd_pcm_info_set_stream(pcm_info, stream);\n\t\t\t\terr = snd_ctl_pcm_info(handle, pcm_info);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (err < 0)\n\t\t\t\t\tksft_exit_fail_msg(\"snd_ctl_pcm_info: %d:%d:%d\\n\",\n\t\t\t\t\t\t\t   dev, 0, stream);\n\t\t\t\tcount = snd_pcm_info_get_subdevices_count(pcm_info);\n\t\t\t\tfor (subdev = 0; subdev < count; subdev++) {\n\t\t\t\t\tsprintf(key, \"pcm.%d.%d.%s\", dev, subdev, snd_pcm_stream_name(stream));\n\t\t\t\t\tif (conf_get_bool(card_config, key, \"skip\", false)) {\n\t\t\t\t\t\tksft_print_msg(\"skipping pcm %d.%d.%d.%s\\n\", card, dev,\n\t\t\t\t\t\t\t       subdev, snd_pcm_stream_name(stream));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpcm_data = calloc(1, sizeof(*pcm_data));\n\t\t\t\t\tif (!pcm_data)\n\t\t\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t\t\t\t\tpcm_data->card = card;\n\t\t\t\t\tpcm_data->device = dev;\n\t\t\t\t\tpcm_data->subdevice = subdev;\n\t\t\t\t\tpcm_data->stream = stream;\n\t\t\t\t\tpcm_data->pcm_config = conf_get_subtree(card_config, key, NULL);\n\t\t\t\t\tpcm_data->next = pcm_list;\n\t\t\t\t\tpcm_list = pcm_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmissing_devices(card, card_config);\n\n\tnext_card:\n\t\tsnd_ctl_close(handle);\n\t\tif (snd_card_next(&card) < 0) {\n\t\t\tksft_print_msg(\"snd_card_next\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_config_delete(config);\n}\n\nstatic void test_pcm_time(struct pcm_data *data, enum test_class class,\n\t\t\t  const char *test_name, snd_config_t *pcm_cfg)\n{\n\tchar name[64], msg[256];\n\tconst int duration_s = 2, margin_ms = 100;\n\tconst int duration_ms = duration_s * 1000;\n\tconst char *cs;\n\tint i, err;\n\tsnd_pcm_t *handle = NULL;\n\tsnd_pcm_access_t access = SND_PCM_ACCESS_RW_INTERLEAVED;\n\tsnd_pcm_format_t format, old_format;\n\tconst char *alt_formats[8];\n\tunsigned char *samples = NULL;\n\tsnd_pcm_sframes_t frames;\n\tlong long ms;\n\tlong rate, channels, period_size, buffer_size;\n\tunsigned int rrate;\n\tsnd_pcm_uframes_t rperiod_size, rbuffer_size, start_threshold;\n\ttimestamp_t tstamp;\n\tbool pass = false;\n\tsnd_pcm_hw_params_t *hw_params;\n\tsnd_pcm_sw_params_t *sw_params;\n\tconst char *test_class_name;\n\tbool skip = true;\n\tconst char *desc;\n\n\tswitch (class) {\n\tcase TEST_CLASS_DEFAULT:\n\t\ttest_class_name = \"default\";\n\t\tbreak;\n\tcase TEST_CLASS_SYSTEM:\n\t\ttest_class_name = \"system\";\n\t\tbreak;\n\tdefault:\n\t\tksft_exit_fail_msg(\"Unknown test class %d\\n\", class);\n\t\tbreak;\n\t}\n\n\tdesc = conf_get_string(pcm_cfg, \"description\", NULL, NULL);\n\tif (desc)\n\t\tksft_print_msg(\"%s.%s.%d.%d.%d.%s - %s\\n\",\n\t\t\t       test_class_name, test_name,\n\t\t\t       data->card, data->device, data->subdevice,\n\t\t\t       snd_pcm_stream_name(data->stream),\n\t\t\t       desc);\n\n\n\tsnd_pcm_hw_params_alloca(&hw_params);\n\tsnd_pcm_sw_params_alloca(&sw_params);\n\n\tcs = conf_get_string(pcm_cfg, \"format\", NULL, \"S16_LE\");\n\tformat = snd_pcm_format_value(cs);\n\tif (format == SND_PCM_FORMAT_UNKNOWN)\n\t\tksft_exit_fail_msg(\"Wrong format '%s'\\n\", cs);\n\tconf_get_string_array(pcm_cfg, \"alt_formats\", NULL,\n\t\t\t\talt_formats, ARRAY_SIZE(alt_formats), NULL);\n\trate = conf_get_long(pcm_cfg, \"rate\", NULL, 48000);\n\tchannels = conf_get_long(pcm_cfg, \"channels\", NULL, 2);\n\tperiod_size = conf_get_long(pcm_cfg, \"period_size\", NULL, 4096);\n\tbuffer_size = conf_get_long(pcm_cfg, \"buffer_size\", NULL, 16384);\n\n\tsamples = malloc((rate * channels * snd_pcm_format_physical_width(format)) / 8);\n\tif (!samples)\n\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\tsnd_pcm_format_set_silence(format, samples, rate * channels);\n\n\tsprintf(name, \"hw:%d,%d,%d\", data->card, data->device, data->subdevice);\n\terr = snd_pcm_open(&handle, name, data->stream, 0);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"Failed to get pcm handle: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\n\terr = snd_pcm_hw_params_any(handle, hw_params);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_any: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_hw_params_set_rate_resample(handle, hw_params, 0);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_rate_resample: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_hw_params_set_access(handle, hw_params, access);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_access %s: %s\",\n\t\t\t\t\t   snd_pcm_access_name(access), snd_strerror(err));\n\t\tgoto __close;\n\t}\n\ti = -1;\n__format:\n\terr = snd_pcm_hw_params_set_format(handle, hw_params, format);\n\tif (err < 0) {\n\t\ti++;\n\t\tif (i < ARRAY_SIZE(alt_formats) && alt_formats[i]) {\n\t\t\told_format = format;\n\t\t\tformat = snd_pcm_format_value(alt_formats[i]);\n\t\t\tif (format != SND_PCM_FORMAT_UNKNOWN) {\n\t\t\t\tksft_print_msg(\"%s.%d.%d.%d.%s.%s format %s -> %s\\n\",\n\t\t\t\t\t\t test_name,\n\t\t\t\t\t\t data->card, data->device, data->subdevice,\n\t\t\t\t\t\t snd_pcm_stream_name(data->stream),\n\t\t\t\t\t\t snd_pcm_access_name(access),\n\t\t\t\t\t\t snd_pcm_format_name(old_format),\n\t\t\t\t\t\t snd_pcm_format_name(format));\n\t\t\t\tsamples = realloc(samples, (rate * channels *\n\t\t\t\t\t\t\t    snd_pcm_format_physical_width(format)) / 8);\n\t\t\t\tif (!samples)\n\t\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t\t\t\tsnd_pcm_format_set_silence(format, samples, rate * channels);\n\t\t\t\tgoto __format;\n\t\t\t}\n\t\t}\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_format %s: %s\",\n\t\t\t\t\t   snd_pcm_format_name(format), snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_hw_params_set_channels(handle, hw_params, channels);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_channels %ld: %s\", channels, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\trrate = rate;\n\terr = snd_pcm_hw_params_set_rate_near(handle, hw_params, &rrate, 0);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_rate %ld: %s\", rate, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\tif (rrate != rate) {\n\t\tsnprintf(msg, sizeof(msg), \"rate mismatch %ld != %d\", rate, rrate);\n\t\tgoto __close;\n\t}\n\trperiod_size = period_size;\n\terr = snd_pcm_hw_params_set_period_size_near(handle, hw_params, &rperiod_size, 0);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_period_size %ld: %s\", period_size, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\trbuffer_size = buffer_size;\n\terr = snd_pcm_hw_params_set_buffer_size_near(handle, hw_params, &rbuffer_size);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params_set_buffer_size %ld: %s\", buffer_size, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_hw_params(handle, hw_params);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_hw_params: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\n\terr = snd_pcm_sw_params_current(handle, sw_params);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_sw_params_current: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\tif (data->stream == SND_PCM_STREAM_PLAYBACK) {\n\t\tstart_threshold = (rbuffer_size / rperiod_size) * rperiod_size;\n\t} else {\n\t\tstart_threshold = rperiod_size;\n\t}\n\terr = snd_pcm_sw_params_set_start_threshold(handle, sw_params, start_threshold);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_sw_params_set_start_threshold %ld: %s\", (long)start_threshold, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_sw_params_set_avail_min(handle, sw_params, rperiod_size);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_sw_params_set_avail_min %ld: %s\", (long)rperiod_size, snd_strerror(err));\n\t\tgoto __close;\n\t}\n\terr = snd_pcm_sw_params(handle, sw_params);\n\tif (err < 0) {\n\t\tsnprintf(msg, sizeof(msg), \"snd_pcm_sw_params: %s\", snd_strerror(err));\n\t\tgoto __close;\n\t}\n\n\tksft_print_msg(\"%s.%s.%d.%d.%d.%s hw_params.%s.%s.%ld.%ld.%ld.%ld sw_params.%ld\\n\",\n\t\t         test_class_name, test_name,\n\t\t\t data->card, data->device, data->subdevice,\n\t\t\t snd_pcm_stream_name(data->stream),\n\t\t\t snd_pcm_access_name(access),\n\t\t\t snd_pcm_format_name(format),\n\t\t\t (long)rate, (long)channels,\n\t\t\t (long)rperiod_size, (long)rbuffer_size,\n\t\t\t (long)start_threshold);\n\n\t \n\tskip = false;\n\n\ttimestamp_now(&tstamp);\n\tfor (i = 0; i < duration_s; i++) {\n\t\tif (data->stream == SND_PCM_STREAM_PLAYBACK) {\n\t\t\tframes = snd_pcm_writei(handle, samples, rate);\n\t\t\tif (frames < 0) {\n\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t \"Write failed: expected %ld, wrote %li\", rate, frames);\n\t\t\t\tgoto __close;\n\t\t\t}\n\t\t\tif (frames < rate) {\n\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t \"expected %ld, wrote %li\", rate, frames);\n\t\t\t\tgoto __close;\n\t\t\t}\n\t\t} else {\n\t\t\tframes = snd_pcm_readi(handle, samples, rate);\n\t\t\tif (frames < 0) {\n\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t \"expected %ld, wrote %li\", rate, frames);\n\t\t\t\tgoto __close;\n\t\t\t}\n\t\t\tif (frames < rate) {\n\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t \"expected %ld, wrote %li\", rate, frames);\n\t\t\t\tgoto __close;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_pcm_drain(handle);\n\tms = timestamp_diff_ms(&tstamp);\n\tif (ms < duration_ms - margin_ms || ms > duration_ms + margin_ms) {\n\t\tsnprintf(msg, sizeof(msg), \"time mismatch: expected %dms got %lld\", duration_ms, ms);\n\t\tgoto __close;\n\t}\n\n\tmsg[0] = '\\0';\n\tpass = true;\n__close:\n\tpthread_mutex_lock(&results_lock);\n\n\tswitch (class) {\n\tcase TEST_CLASS_SYSTEM:\n\t\ttest_class_name = \"system\";\n\t\t \n\t\tksft_test_result(!skip, \"%s.%s.%d.%d.%d.%s.params\\n\",\n\t\t\t\t test_class_name, test_name,\n\t\t\t\t data->card, data->device, data->subdevice,\n\t\t\t\t snd_pcm_stream_name(data->stream));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!skip)\n\t\tksft_test_result(pass, \"%s.%s.%d.%d.%d.%s\\n\",\n\t\t\t\t test_class_name, test_name,\n\t\t\t\t data->card, data->device, data->subdevice,\n\t\t\t\t snd_pcm_stream_name(data->stream));\n\telse\n\t\tksft_test_result_skip(\"%s.%s.%d.%d.%d.%s\\n\",\n\t\t\t\t test_class_name, test_name,\n\t\t\t\t data->card, data->device, data->subdevice,\n\t\t\t\t snd_pcm_stream_name(data->stream));\n\n\tif (msg[0])\n\t\tksft_print_msg(\"%s\\n\", msg);\n\n\tpthread_mutex_unlock(&results_lock);\n\n\tfree(samples);\n\tif (handle)\n\t\tsnd_pcm_close(handle);\n}\n\nvoid run_time_tests(struct pcm_data *pcm, enum test_class class,\n\t\t    snd_config_t *cfg)\n{\n\tconst char *test_name, *test_type;\n\tsnd_config_t *pcm_cfg;\n\tsnd_config_iterator_t i, next;\n\n\tif (!cfg)\n\t\treturn;\n\n\tcfg = conf_get_subtree(cfg, \"test\", NULL);\n\tif (cfg == NULL)\n\t\treturn;\n\n\tsnd_config_for_each(i, next, cfg) {\n\t\tpcm_cfg = snd_config_iterator_entry(i);\n\t\tif (snd_config_get_id(pcm_cfg, &test_name) < 0)\n\t\t\tksft_exit_fail_msg(\"snd_config_get_id\\n\");\n\t\ttest_type = conf_get_string(pcm_cfg, \"type\", NULL, \"time\");\n\t\tif (strcmp(test_type, \"time\") == 0)\n\t\t\ttest_pcm_time(pcm, class, test_name, pcm_cfg);\n\t\telse\n\t\t\tksft_exit_fail_msg(\"unknown test type '%s'\\n\", test_type);\n\t}\n}\n\nvoid *card_thread(void *data)\n{\n\tstruct card_data *card = data;\n\tstruct pcm_data *pcm;\n\n\tfor (pcm = pcm_list; pcm != NULL; pcm = pcm->next) {\n\t\tif (pcm->card != card->card)\n\t\t\tcontinue;\n\n\t\trun_time_tests(pcm, TEST_CLASS_DEFAULT, default_pcm_config);\n\t\trun_time_tests(pcm, TEST_CLASS_SYSTEM, pcm->pcm_config);\n\t}\n\n\treturn 0;\n}\n\nint main(void)\n{\n\tstruct card_data *card;\n\tstruct pcm_data *pcm;\n\tsnd_config_t *global_config, *cfg;\n\tint num_pcm_tests = 0, num_tests, num_std_pcm_tests;\n\tint ret;\n\tvoid *thread_ret;\n\n\tksft_print_header();\n\n\tglobal_config = conf_load_from_file(\"pcm-test.conf\");\n\tdefault_pcm_config = conf_get_subtree(global_config, \"pcm\", NULL);\n\tif (default_pcm_config == NULL)\n\t\tksft_exit_fail_msg(\"default pcm test configuration (pcm compound) is missing\\n\");\n\n\tconf_load();\n\n\tfind_pcms();\n\n\tnum_std_pcm_tests = conf_get_count(default_pcm_config, \"test\", NULL);\n\n\tfor (pcm = pcm_list; pcm != NULL; pcm = pcm->next) {\n\t\tnum_pcm_tests += num_std_pcm_tests;\n\t\tcfg = pcm->pcm_config;\n\t\tif (cfg == NULL)\n\t\t\tcontinue;\n\t\t \n\t\tnum_tests = conf_get_count(cfg, \"test\", NULL) * 2;\n\t\tif (num_tests > 0)\n\t\t\tnum_pcm_tests += num_tests;\n\t}\n\n\tksft_set_plan(num_missing + num_pcm_tests);\n\n\tfor (pcm = pcm_missing; pcm != NULL; pcm = pcm->next) {\n\t\tksft_test_result(false, \"test.missing.%d.%d.%d.%s\\n\",\n\t\t\t\t pcm->card, pcm->device, pcm->subdevice,\n\t\t\t\t snd_pcm_stream_name(pcm->stream));\n\t}\n\n\tfor (card = card_list; card != NULL; card = card->next) {\n\t\tret = pthread_create(&card->thread, NULL, card_thread, card);\n\t\tif (ret != 0) {\n\t\t\tksft_exit_fail_msg(\"Failed to create card %d thread: %d (%s)\\n\",\n\t\t\t\t\t   card->card, ret,\n\t\t\t\t\t   strerror(errno));\n\t\t}\n\t}\n\n\tfor (card = card_list; card != NULL; card = card->next) {\n\t\tret = pthread_join(card->thread, &thread_ret);\n\t\tif (ret != 0) {\n\t\t\tksft_exit_fail_msg(\"Failed to join card %d thread: %d (%s)\\n\",\n\t\t\t\t\t   card->card, ret,\n\t\t\t\t\t   strerror(errno));\n\t\t}\n\t}\n\n\tsnd_config_delete(global_config);\n\tconf_free();\n\n\tksft_exit_pass();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}