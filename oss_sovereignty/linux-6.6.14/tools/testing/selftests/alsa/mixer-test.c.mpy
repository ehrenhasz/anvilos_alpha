{
  "module_name": "mixer-test.c",
  "hash_id": "d570183aafb3c84b5a75cd5332d672d239c48ff06eea5d9c6c1e9b62a4b360c0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/alsa/mixer-test.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <string.h>\n#include <getopt.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <math.h>\n#include <errno.h>\n#include <assert.h>\n#include <alsa/asoundlib.h>\n#include <poll.h>\n#include <stdint.h>\n\n#include \"../kselftest.h\"\n#include \"alsa-local.h\"\n\n#define TESTS_PER_CONTROL 7\n\nstruct card_data {\n\tsnd_ctl_t *handle;\n\tint card;\n\tstruct pollfd pollfd;\n\tint num_ctls;\n\tsnd_ctl_elem_list_t *ctls;\n\tstruct card_data *next;\n};\n\nstruct ctl_data {\n\tconst char *name;\n\tsnd_ctl_elem_id_t *id;\n\tsnd_ctl_elem_info_t *info;\n\tsnd_ctl_elem_value_t *def_val;\n\tint elem;\n\tint event_missing;\n\tint event_spurious;\n\tstruct card_data *card;\n\tstruct ctl_data *next;\n};\n\nint num_cards = 0;\nint num_controls = 0;\nstruct card_data *card_list = NULL;\nstruct ctl_data *ctl_list = NULL;\n\nstatic void find_controls(void)\n{\n\tchar name[32];\n\tint card, ctl, err;\n\tstruct card_data *card_data;\n\tstruct ctl_data *ctl_data;\n\tsnd_config_t *config;\n\tchar *card_name, *card_longname;\n\n\tcard = -1;\n\tif (snd_card_next(&card) < 0 || card < 0)\n\t\treturn;\n\n\tconfig = get_alsalib_config();\n\n\twhile (card >= 0) {\n\t\tsprintf(name, \"hw:%d\", card);\n\n\t\tcard_data = malloc(sizeof(*card_data));\n\t\tif (!card_data)\n\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\n\t\terr = snd_ctl_open_lconf(&card_data->handle, name, 0, config);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"Failed to get hctl for card %d: %s\\n\",\n\t\t\t\t       card, snd_strerror(err));\n\t\t\tgoto next_card;\n\t\t}\n\n\t\terr = snd_card_get_name(card, &card_name);\n\t\tif (err != 0)\n\t\t\tcard_name = \"Unknown\";\n\t\terr = snd_card_get_longname(card, &card_longname);\n\t\tif (err != 0)\n\t\t\tcard_longname = \"Unknown\";\n\t\tksft_print_msg(\"Card %d - %s (%s)\\n\", card,\n\t\t\t       card_name, card_longname);\n\n\t\t \n\t\tsnd_ctl_elem_list_malloc(&card_data->ctls);\n\t\tsnd_ctl_elem_list(card_data->handle, card_data->ctls);\n\t\tcard_data->num_ctls = snd_ctl_elem_list_get_count(card_data->ctls);\n\n\t\t \n\t\tsnd_ctl_elem_list_alloc_space(card_data->ctls, card_data->num_ctls);\n\t\tsnd_ctl_elem_list(card_data->handle, card_data->ctls);\n\n\t\tcard_data->card = num_cards++;\n\t\tcard_data->next = card_list;\n\t\tcard_list = card_data;\n\n\t\tnum_controls += card_data->num_ctls;\n\n\t\tfor (ctl = 0; ctl < card_data->num_ctls; ctl++) {\n\t\t\tctl_data = malloc(sizeof(*ctl_data));\n\t\t\tif (!ctl_data)\n\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\n\t\t\tmemset(ctl_data, 0, sizeof(*ctl_data));\n\t\t\tctl_data->card = card_data;\n\t\t\tctl_data->elem = ctl;\n\t\t\tctl_data->name = snd_ctl_elem_list_get_name(card_data->ctls,\n\t\t\t\t\t\t\t\t    ctl);\n\n\t\t\terr = snd_ctl_elem_id_malloc(&ctl_data->id);\n\t\t\tif (err < 0)\n\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\n\t\t\terr = snd_ctl_elem_info_malloc(&ctl_data->info);\n\t\t\tif (err < 0)\n\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\n\t\t\terr = snd_ctl_elem_value_malloc(&ctl_data->def_val);\n\t\t\tif (err < 0)\n\t\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\n\t\t\tsnd_ctl_elem_list_get_id(card_data->ctls, ctl,\n\t\t\t\t\t\t ctl_data->id);\n\t\t\tsnd_ctl_elem_info_set_id(ctl_data->info, ctl_data->id);\n\t\t\terr = snd_ctl_elem_info(card_data->handle,\n\t\t\t\t\t\tctl_data->info);\n\t\t\tif (err < 0) {\n\t\t\t\tksft_print_msg(\"%s getting info for %s\\n\",\n\t\t\t\t\t       snd_strerror(err),\n\t\t\t\t\t       ctl_data->name);\n\t\t\t}\n\n\t\t\tsnd_ctl_elem_value_set_id(ctl_data->def_val,\n\t\t\t\t\t\t  ctl_data->id);\n\n\t\t\tctl_data->next = ctl_list;\n\t\t\tctl_list = ctl_data;\n\t\t}\n\n\t\t \n\t\terr = snd_ctl_subscribe_events(card_data->handle, true);\n\t\tif (err < 0) {\n\t\t\tksft_exit_fail_msg(\"snd_ctl_subscribe_events() failed for card %d: %d\\n\",\n\t\t\t\t\t   card, err);\n\t\t}\n\n\t\terr = snd_ctl_poll_descriptors_count(card_data->handle);\n\t\tif (err != 1) {\n\t\t\tksft_exit_fail_msg(\"Unexpected descriptor count %d for card %d\\n\",\n\t\t\t\t\t   err, card);\n\t\t}\n\n\t\terr = snd_ctl_poll_descriptors(card_data->handle,\n\t\t\t\t\t       &card_data->pollfd, 1);\n\t\tif (err != 1) {\n\t\t\tksft_exit_fail_msg(\"snd_ctl_poll_descriptors() failed for card %d: %d\\n\",\n\t\t\t\t       card, err);\n\t\t}\n\n\tnext_card:\n\t\tif (snd_card_next(&card) < 0) {\n\t\t\tksft_print_msg(\"snd_card_next\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_config_delete(config);\n}\n\n \nstatic int wait_for_event(struct ctl_data *ctl, int timeout)\n{\n\tunsigned short revents;\n\tsnd_ctl_event_t *event;\n\tint err;\n\tunsigned int mask = 0;\n\tunsigned int ev_id;\n\n\tsnd_ctl_event_alloca(&event);\n\n\tdo {\n\t\terr = poll(&(ctl->card->pollfd), 1, timeout);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"poll() failed for %s: %s (%d)\\n\",\n\t\t\t\t       ctl->name, strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tif (err == 0)\n\t\t\treturn 0;\n\n\t\terr = snd_ctl_poll_descriptors_revents(ctl->card->handle,\n\t\t\t\t\t\t       &(ctl->card->pollfd),\n\t\t\t\t\t\t       1, &revents);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"snd_ctl_poll_descriptors_revents() failed for %s: %d\\n\",\n\t\t\t\t       ctl->name, err);\n\t\t\treturn err;\n\t\t}\n\t\tif (revents & POLLERR) {\n\t\t\tksft_print_msg(\"snd_ctl_poll_descriptors_revents() reported POLLERR for %s\\n\",\n\t\t\t\t       ctl->name);\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tif (!(revents & POLLIN)) {\n\t\t\tksft_print_msg(\"No POLLIN\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = snd_ctl_read(ctl->card->handle, event);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"snd_ctl_read() failed for %s: %d\\n\",\n\t\t\t       ctl->name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (snd_ctl_event_get_type(event) != SND_CTL_EVENT_ELEM)\n\t\t\tcontinue;\n\n\t\t \n\t\tmask = snd_ctl_event_elem_get_mask(event);\n\t\tev_id = snd_ctl_event_elem_get_numid(event);\n\t\tif (ev_id != snd_ctl_elem_info_get_numid(ctl->info)) {\n\t\t\tksft_print_msg(\"Event for unexpected ctl %s\\n\",\n\t\t\t\t       snd_ctl_event_elem_get_name(event));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((mask & SND_CTL_EVENT_MASK_REMOVE) == SND_CTL_EVENT_MASK_REMOVE) {\n\t\t\tksft_print_msg(\"Removal event for %s\\n\",\n\t\t\t\t       ctl->name);\n\t\t\treturn -1;\n\t\t}\n\t} while ((mask & SND_CTL_EVENT_MASK_VALUE) != SND_CTL_EVENT_MASK_VALUE);\n\n\treturn 1;\n}\n\nstatic bool ctl_value_index_valid(struct ctl_data *ctl,\n\t\t\t\t  snd_ctl_elem_value_t *val,\n\t\t\t\t  int index)\n{\n\tlong int_val;\n\tlong long int64_val;\n\n\tswitch (snd_ctl_elem_info_get_type(ctl->info)) {\n\tcase SND_CTL_ELEM_TYPE_NONE:\n\t\tksft_print_msg(\"%s.%d Invalid control type NONE\\n\",\n\t\t\t       ctl->name, index);\n\t\treturn false;\n\n\tcase SND_CTL_ELEM_TYPE_BOOLEAN:\n\t\tint_val = snd_ctl_elem_value_get_boolean(val, index);\n\t\tswitch (int_val) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tksft_print_msg(\"%s.%d Invalid boolean value %ld\\n\",\n\t\t\t\t       ctl->name, index, int_val);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER:\n\t\tint_val = snd_ctl_elem_value_get_integer(val, index);\n\n\t\tif (int_val < snd_ctl_elem_info_get_min(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %ld less than minimum %ld\\n\",\n\t\t\t\t       ctl->name, index, int_val,\n\t\t\t\t       snd_ctl_elem_info_get_min(ctl->info));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (int_val > snd_ctl_elem_info_get_max(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %ld more than maximum %ld\\n\",\n\t\t\t\t       ctl->name, index, int_val,\n\t\t\t\t       snd_ctl_elem_info_get_max(ctl->info));\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (snd_ctl_elem_info_get_step(ctl->info) &&\n\t\t    (int_val - snd_ctl_elem_info_get_min(ctl->info) %\n\t\t     snd_ctl_elem_info_get_step(ctl->info))) {\n\t\t\tksft_print_msg(\"%s.%d value %ld invalid for step %ld minimum %ld\\n\",\n\t\t\t\t       ctl->name, index, int_val,\n\t\t\t\t       snd_ctl_elem_info_get_step(ctl->info),\n\t\t\t\t       snd_ctl_elem_info_get_min(ctl->info));\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER64:\n\t\tint64_val = snd_ctl_elem_value_get_integer64(val, index);\n\n\t\tif (int64_val < snd_ctl_elem_info_get_min64(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %lld less than minimum %lld\\n\",\n\t\t\t\t       ctl->name, index, int64_val,\n\t\t\t\t       snd_ctl_elem_info_get_min64(ctl->info));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (int64_val > snd_ctl_elem_info_get_max64(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %lld more than maximum %ld\\n\",\n\t\t\t\t       ctl->name, index, int64_val,\n\t\t\t\t       snd_ctl_elem_info_get_max(ctl->info));\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (snd_ctl_elem_info_get_step64(ctl->info) &&\n\t\t    (int64_val - snd_ctl_elem_info_get_min64(ctl->info)) %\n\t\t    snd_ctl_elem_info_get_step64(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %lld invalid for step %lld minimum %lld\\n\",\n\t\t\t\t       ctl->name, index, int64_val,\n\t\t\t\t       snd_ctl_elem_info_get_step64(ctl->info),\n\t\t\t\t       snd_ctl_elem_info_get_min64(ctl->info));\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_ENUMERATED:\n\t\tint_val = snd_ctl_elem_value_get_enumerated(val, index);\n\n\t\tif (int_val < 0) {\n\t\t\tksft_print_msg(\"%s.%d negative value %ld for enumeration\\n\",\n\t\t\t\t       ctl->name, index, int_val);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (int_val >= snd_ctl_elem_info_get_items(ctl->info)) {\n\t\t\tksft_print_msg(\"%s.%d value %ld more than item count %ld\\n\",\n\t\t\t\t       ctl->name, index, int_val,\n\t\t\t\t       snd_ctl_elem_info_get_items(ctl->info));\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ctl_value_valid(struct ctl_data *ctl, snd_ctl_elem_value_t *val)\n{\n\tint i;\n\tbool valid = true;\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++)\n\t\tif (!ctl_value_index_valid(ctl, val, i))\n\t\t\tvalid = false;\n\n\treturn valid;\n}\n\n \nstatic void test_ctl_get_value(struct ctl_data *ctl)\n{\n\tint err;\n\n\t \n\tif (snd_ctl_elem_info_is_inactive(ctl->info)) {\n\t\tksft_print_msg(\"%s is inactive\\n\", ctl->name);\n\t\tksft_test_result_skip(\"get_value.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\t \n\tif (!snd_ctl_elem_info_is_readable(ctl->info)) {\n\t\tksft_print_msg(\"%s is not readable\\n\", ctl->name);\n\t\tksft_test_result_skip(\"get_value.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\terr = snd_ctl_elem_read(ctl->card->handle, ctl->def_val);\n\tif (err < 0) {\n\t\tksft_print_msg(\"snd_ctl_elem_read() failed: %s\\n\",\n\t\t\t       snd_strerror(err));\n\t\tgoto out;\n\t}\n\n\tif (!ctl_value_valid(ctl, ctl->def_val))\n\t\terr = -EINVAL;\n\nout:\n\tksft_test_result(err >= 0, \"get_value.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic bool strend(const char *haystack, const char *needle)\n{\n\tsize_t haystack_len = strlen(haystack);\n\tsize_t needle_len = strlen(needle);\n\n\tif (needle_len > haystack_len)\n\t\treturn false;\n\treturn strcmp(haystack + haystack_len - needle_len, needle) == 0;\n}\n\nstatic void test_ctl_name(struct ctl_data *ctl)\n{\n\tbool name_ok = true;\n\n\tksft_print_msg(\"%d.%d %s\\n\", ctl->card->card, ctl->elem,\n\t\t       ctl->name);\n\n\t \n\tif (strend(ctl->name, \" Switch\")) {\n\t\tif (snd_ctl_elem_info_get_type(ctl->info) != SND_CTL_ELEM_TYPE_BOOLEAN) {\n\t\t\tksft_print_msg(\"%d.%d %s ends in Switch but is not boolean\\n\",\n\t\t\t\t       ctl->card->card, ctl->elem, ctl->name);\n\t\t\tname_ok = false;\n\t\t}\n\t}\n\n\t \n\tif (snd_ctl_elem_info_get_type(ctl->info) == SND_CTL_ELEM_TYPE_BOOLEAN &&\n\t    snd_ctl_elem_info_is_writable(ctl->info)) {\n\t\tif (!strend(ctl->name, \" Switch\")) {\n\t\t\tksft_print_msg(\"%d.%d %s is a writeable boolean but not a Switch\\n\",\n\t\t\t\t       ctl->card->card, ctl->elem, ctl->name);\n\t\t\tname_ok = false;\n\t\t}\n\t}\n\n\tksft_test_result(name_ok, \"name.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic void show_values(struct ctl_data *ctl, snd_ctl_elem_value_t *orig_val,\n\t\t\tsnd_ctl_elem_value_t *read_val)\n{\n\tlong long orig_int, read_int;\n\tint i;\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tswitch (snd_ctl_elem_info_get_type(ctl->info)) {\n\t\tcase SND_CTL_ELEM_TYPE_BOOLEAN:\n\t\t\torig_int = snd_ctl_elem_value_get_boolean(orig_val, i);\n\t\t\tread_int = snd_ctl_elem_value_get_boolean(read_val, i);\n\t\t\tbreak;\n\n\t\tcase SND_CTL_ELEM_TYPE_INTEGER:\n\t\t\torig_int = snd_ctl_elem_value_get_integer(orig_val, i);\n\t\t\tread_int = snd_ctl_elem_value_get_integer(read_val, i);\n\t\t\tbreak;\n\n\t\tcase SND_CTL_ELEM_TYPE_INTEGER64:\n\t\t\torig_int = snd_ctl_elem_value_get_integer64(orig_val,\n\t\t\t\t\t\t\t\t    i);\n\t\t\tread_int = snd_ctl_elem_value_get_integer64(read_val,\n\t\t\t\t\t\t\t\t    i);\n\t\t\tbreak;\n\n\t\tcase SND_CTL_ELEM_TYPE_ENUMERATED:\n\t\t\torig_int = snd_ctl_elem_value_get_enumerated(orig_val,\n\t\t\t\t\t\t\t\t     i);\n\t\t\tread_int = snd_ctl_elem_value_get_enumerated(read_val,\n\t\t\t\t\t\t\t\t     i);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\tksft_print_msg(\"%s.%d orig %lld read %lld, is_volatile %d\\n\",\n\t\t\t       ctl->name, i, orig_int, read_int,\n\t\t\t       snd_ctl_elem_info_is_volatile(ctl->info));\n\t}\n}\n\nstatic bool show_mismatch(struct ctl_data *ctl, int index,\n\t\t\t  snd_ctl_elem_value_t *read_val,\n\t\t\t  snd_ctl_elem_value_t *expected_val)\n{\n\tlong long expected_int, read_int;\n\n\t \n\texpected_int = 0;\n\tread_int = 0;\n\n\tswitch (snd_ctl_elem_info_get_type(ctl->info)) {\n\tcase SND_CTL_ELEM_TYPE_BOOLEAN:\n\t\texpected_int = snd_ctl_elem_value_get_boolean(expected_val,\n\t\t\t\t\t\t\t      index);\n\t\tread_int = snd_ctl_elem_value_get_boolean(read_val, index);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER:\n\t\texpected_int = snd_ctl_elem_value_get_integer(expected_val,\n\t\t\t\t\t\t\t      index);\n\t\tread_int = snd_ctl_elem_value_get_integer(read_val, index);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER64:\n\t\texpected_int = snd_ctl_elem_value_get_integer64(expected_val,\n\t\t\t\t\t\t\t\tindex);\n\t\tread_int = snd_ctl_elem_value_get_integer64(read_val,\n\t\t\t\t\t\t\t    index);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_ENUMERATED:\n\t\texpected_int = snd_ctl_elem_value_get_enumerated(expected_val,\n\t\t\t\t\t\t\t\t index);\n\t\tread_int = snd_ctl_elem_value_get_enumerated(read_val,\n\t\t\t\t\t\t\t     index);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (expected_int != read_int) {\n\t\t \n\t\tbool is_volatile = snd_ctl_elem_info_is_volatile(ctl->info);\n\t\tksft_print_msg(\"%s.%d expected %lld but read %lld, is_volatile %d\\n\",\n\t\t\t       ctl->name, index, expected_int, read_int, is_volatile);\n\t\treturn !is_volatile;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n \nstatic int write_and_verify(struct ctl_data *ctl,\n\t\t\t    snd_ctl_elem_value_t *write_val,\n\t\t\t    snd_ctl_elem_value_t *expected_val)\n{\n\tint err, i;\n\tbool error_expected, mismatch_shown;\n\tsnd_ctl_elem_value_t *initial_val, *read_val, *w_val;\n\tsnd_ctl_elem_value_alloca(&initial_val);\n\tsnd_ctl_elem_value_alloca(&read_val);\n\tsnd_ctl_elem_value_alloca(&w_val);\n\n\t \n\tsnd_ctl_elem_value_copy(w_val, write_val);\n\tif (expected_val) {\n\t\terror_expected = true;\n\t} else {\n\t\terror_expected = false;\n\t\tsnd_ctl_elem_value_alloca(&expected_val);\n\t\tsnd_ctl_elem_value_copy(expected_val, write_val);\n\t}\n\n\t \n\tif (snd_ctl_elem_info_is_readable(ctl->info)) {\n\t\tsnd_ctl_elem_value_set_id(initial_val, ctl->id);\n\n\t\terr = snd_ctl_elem_read(ctl->card->handle, initial_val);\n\t\tif (err < 0) {\n\t\t\tksft_print_msg(\"snd_ctl_elem_read() failed: %s\\n\",\n\t\t\t\t       snd_strerror(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = snd_ctl_elem_write(ctl->card->handle, w_val);\n\tif (err < 0 && !error_expected) {\n\t\tksft_print_msg(\"snd_ctl_elem_write() failed: %s\\n\",\n\t\t\t       snd_strerror(err));\n\t\treturn err;\n\t}\n\n\t \n\tif (!snd_ctl_elem_info_is_readable(ctl->info))\n\t\treturn err;\n\n\tsnd_ctl_elem_value_set_id(read_val, ctl->id);\n\n\terr = snd_ctl_elem_read(ctl->card->handle, read_val);\n\tif (err < 0) {\n\t\tksft_print_msg(\"snd_ctl_elem_read() failed: %s\\n\",\n\t\t\t       snd_strerror(err));\n\t\treturn err;\n\t}\n\n\t \n\tif (!snd_ctl_elem_info_is_volatile(ctl->info)) {\n\t\terr = wait_for_event(ctl, 0);\n\t\tif (snd_ctl_elem_value_compare(initial_val, read_val)) {\n\t\t\tif (err < 1) {\n\t\t\t\tksft_print_msg(\"No event generated for %s\\n\",\n\t\t\t\t\t       ctl->name);\n\t\t\t\tshow_values(ctl, initial_val, read_val);\n\t\t\t\tctl->event_missing++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (err != 0) {\n\t\t\t\tksft_print_msg(\"Spurious event generated for %s\\n\",\n\t\t\t\t\t       ctl->name);\n\t\t\t\tshow_values(ctl, initial_val, read_val);\n\t\t\t\tctl->event_spurious++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!snd_ctl_elem_value_compare(expected_val, read_val))\n\t\treturn 0;\n\n\tmismatch_shown = false;\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++)\n\t\tif (show_mismatch(ctl, i, read_val, expected_val))\n\t\t\tmismatch_shown = true;\n\n\tif (!mismatch_shown)\n\t\tksft_print_msg(\"%s read and written values differ\\n\",\n\t\t\t       ctl->name);\n\n\treturn -1;\n}\n\n \nstatic void test_ctl_write_default(struct ctl_data *ctl)\n{\n\tint err;\n\n\t \n\tif (snd_ctl_elem_info_is_inactive(ctl->info)) {\n\t\tksft_print_msg(\"%s is inactive\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_default.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\tif (!snd_ctl_elem_info_is_writable(ctl->info)) {\n\t\tksft_print_msg(\"%s is not writeable\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_default.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\t \n\tif (!snd_ctl_elem_info_is_readable(ctl->info)) {\n\t\tksft_print_msg(\"%s couldn't read default\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_default.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\terr = write_and_verify(ctl, ctl->def_val, NULL);\n\n\tksft_test_result(err >= 0, \"write_default.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic bool test_ctl_write_valid_boolean(struct ctl_data *ctl)\n{\n\tint err, i, j;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tsnd_ctl_elem_value_set_id(val, ctl->id);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tsnd_ctl_elem_value_set_boolean(val, i, j);\n\t\t\terr = write_and_verify(ctl, val, NULL);\n\t\t\tif (err != 0)\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_valid_integer(struct ctl_data *ctl)\n{\n\tint err;\n\tint i;\n\tlong j, step;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tsnd_ctl_elem_value_set_id(val, ctl->id);\n\n\tstep = snd_ctl_elem_info_get_step(ctl->info);\n\tif (!step)\n\t\tstep = 1;\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tfor (j = snd_ctl_elem_info_get_min(ctl->info);\n\t\t     j <= snd_ctl_elem_info_get_max(ctl->info); j += step) {\n\n\t\t\tsnd_ctl_elem_value_set_integer(val, i, j);\n\t\t\terr = write_and_verify(ctl, val, NULL);\n\t\t\tif (err != 0)\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_valid_integer64(struct ctl_data *ctl)\n{\n\tint err, i;\n\tlong long j, step;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tsnd_ctl_elem_value_set_id(val, ctl->id);\n\n\tstep = snd_ctl_elem_info_get_step64(ctl->info);\n\tif (!step)\n\t\tstep = 1;\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tfor (j = snd_ctl_elem_info_get_min64(ctl->info);\n\t\t     j <= snd_ctl_elem_info_get_max64(ctl->info); j += step) {\n\n\t\t\tsnd_ctl_elem_value_set_integer64(val, i, j);\n\t\t\terr = write_and_verify(ctl, val, NULL);\n\t\t\tif (err != 0)\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_valid_enumerated(struct ctl_data *ctl)\n{\n\tint err, i, j;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tsnd_ctl_elem_value_set_id(val, ctl->id);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tfor (j = 0; j < snd_ctl_elem_info_get_items(ctl->info); j++) {\n\t\t\tsnd_ctl_elem_value_set_enumerated(val, i, j);\n\t\t\terr = write_and_verify(ctl, val, NULL);\n\t\t\tif (err != 0)\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\treturn !fail;\n}\n\nstatic void test_ctl_write_valid(struct ctl_data *ctl)\n{\n\tbool pass;\n\n\t \n\tif (snd_ctl_elem_info_is_inactive(ctl->info)) {\n\t\tksft_print_msg(\"%s is inactive\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_valid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\tif (!snd_ctl_elem_info_is_writable(ctl->info)) {\n\t\tksft_print_msg(\"%s is not writeable\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_valid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\tswitch (snd_ctl_elem_info_get_type(ctl->info)) {\n\tcase SND_CTL_ELEM_TYPE_BOOLEAN:\n\t\tpass = test_ctl_write_valid_boolean(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER:\n\t\tpass = test_ctl_write_valid_integer(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER64:\n\t\tpass = test_ctl_write_valid_integer64(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_ENUMERATED:\n\t\tpass = test_ctl_write_valid_enumerated(ctl);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tksft_test_result_skip(\"write_valid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\t \n\twrite_and_verify(ctl, ctl->def_val, NULL);\n\n\tksft_test_result(pass, \"write_valid.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic bool test_ctl_write_invalid_value(struct ctl_data *ctl,\n\t\t\t\t\t snd_ctl_elem_value_t *val)\n{\n\tint err;\n\n\t \n\terr = snd_ctl_elem_write(ctl->card->handle, val);\n\tif (err < 0)\n\t\treturn false;\n\n\t \n\terr = snd_ctl_elem_read(ctl->card->handle, val);\n\tif (err < 0) {\n\t\tksft_print_msg(\"%s failed to read: %s\\n\",\n\t\t\t       ctl->name, snd_strerror(err));\n\t\treturn true;\n\t}\n\n\treturn !ctl_value_valid(ctl, val);\n}\n\nstatic bool test_ctl_write_invalid_boolean(struct ctl_data *ctl)\n{\n\tint i;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\tsnd_ctl_elem_value_set_boolean(val, i, 2);\n\n\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\tfail = true;\n\t}\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_invalid_integer(struct ctl_data *ctl)\n{\n\tint i;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tif (snd_ctl_elem_info_get_min(ctl->info) != LONG_MIN) {\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer(val, i,\n\t\t\t       snd_ctl_elem_info_get_min(ctl->info) - 1);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer(val, i, LONG_MIN);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\t\t}\n\n\t\tif (snd_ctl_elem_info_get_max(ctl->info) != LONG_MAX) {\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer(val, i,\n\t\t\t       snd_ctl_elem_info_get_max(ctl->info) + 1);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer(val, i, LONG_MAX);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_invalid_integer64(struct ctl_data *ctl)\n{\n\tint i;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\tif (snd_ctl_elem_info_get_min64(ctl->info) != LLONG_MIN) {\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer64(val, i,\n\t\t\t\tsnd_ctl_elem_info_get_min64(ctl->info) - 1);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer64(val, i, LLONG_MIN);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\t\t}\n\n\t\tif (snd_ctl_elem_info_get_max64(ctl->info) != LLONG_MAX) {\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer64(val, i,\n\t\t\t\tsnd_ctl_elem_info_get_max64(ctl->info) + 1);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\n\t\t\t \n\t\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\t\tsnd_ctl_elem_value_set_integer64(val, i, LLONG_MAX);\n\n\t\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\t\tfail = true;\n\t\t}\n\t}\n\n\treturn !fail;\n}\n\nstatic bool test_ctl_write_invalid_enumerated(struct ctl_data *ctl)\n{\n\tint i;\n\tbool fail = false;\n\tsnd_ctl_elem_value_t *val;\n\tsnd_ctl_elem_value_alloca(&val);\n\n\tsnd_ctl_elem_value_set_id(val, ctl->id);\n\n\tfor (i = 0; i < snd_ctl_elem_info_get_count(ctl->info); i++) {\n\t\t \n\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\tsnd_ctl_elem_value_set_enumerated(val, i,\n\t\t\t\t  snd_ctl_elem_info_get_items(ctl->info));\n\n\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\tfail = true;\n\n\t\t \n\t\tsnd_ctl_elem_value_copy(val, ctl->def_val);\n\t\tsnd_ctl_elem_value_set_enumerated(val, i, UINT_MAX);\n\n\t\tif (test_ctl_write_invalid_value(ctl, val))\n\t\t\tfail = true;\n\n\t}\n\n\treturn !fail;\n}\n\n\nstatic void test_ctl_write_invalid(struct ctl_data *ctl)\n{\n\tbool pass;\n\n\t \n\tif (snd_ctl_elem_info_is_inactive(ctl->info)) {\n\t\tksft_print_msg(\"%s is inactive\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_invalid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\tif (!snd_ctl_elem_info_is_writable(ctl->info)) {\n\t\tksft_print_msg(\"%s is not writeable\\n\", ctl->name);\n\t\tksft_test_result_skip(\"write_invalid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\tswitch (snd_ctl_elem_info_get_type(ctl->info)) {\n\tcase SND_CTL_ELEM_TYPE_BOOLEAN:\n\t\tpass = test_ctl_write_invalid_boolean(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER:\n\t\tpass = test_ctl_write_invalid_integer(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_INTEGER64:\n\t\tpass = test_ctl_write_invalid_integer64(ctl);\n\t\tbreak;\n\n\tcase SND_CTL_ELEM_TYPE_ENUMERATED:\n\t\tpass = test_ctl_write_invalid_enumerated(ctl);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tksft_test_result_skip(\"write_invalid.%d.%d\\n\",\n\t\t\t\t      ctl->card->card, ctl->elem);\n\t\treturn;\n\t}\n\n\t \n\twrite_and_verify(ctl, ctl->def_val, NULL);\n\n\tksft_test_result(pass, \"write_invalid.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic void test_ctl_event_missing(struct ctl_data *ctl)\n{\n\tksft_test_result(!ctl->event_missing, \"event_missing.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nstatic void test_ctl_event_spurious(struct ctl_data *ctl)\n{\n\tksft_test_result(!ctl->event_spurious, \"event_spurious.%d.%d\\n\",\n\t\t\t ctl->card->card, ctl->elem);\n}\n\nint main(void)\n{\n\tstruct ctl_data *ctl;\n\n\tksft_print_header();\n\n\tfind_controls();\n\n\tksft_set_plan(num_controls * TESTS_PER_CONTROL);\n\n\tfor (ctl = ctl_list; ctl != NULL; ctl = ctl->next) {\n\t\t \n\t\ttest_ctl_get_value(ctl);\n\t\ttest_ctl_name(ctl);\n\t\ttest_ctl_write_default(ctl);\n\t\ttest_ctl_write_valid(ctl);\n\t\ttest_ctl_write_invalid(ctl);\n\t\ttest_ctl_event_missing(ctl);\n\t\ttest_ctl_event_spurious(ctl);\n\t}\n\n\tksft_exit_pass();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}