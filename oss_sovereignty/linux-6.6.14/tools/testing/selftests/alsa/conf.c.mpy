{
  "module_name": "conf.c",
  "hash_id": "78664dfc265a4db2cecd55b3ff51a5ea7c6f3b3b2acd6ab9fd75f8b24ed9499b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/alsa/conf.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <assert.h>\n#include <dirent.h>\n#include <regex.h>\n#include <sys/stat.h>\n\n#include \"../kselftest.h\"\n#include \"alsa-local.h\"\n\n#define SYSFS_ROOT \"/sys\"\n\nstruct card_data {\n\tint card;\n\tsnd_config_t *config;\n\tconst char *filename;\n\tstruct card_data *next;\n};\n\nstatic struct card_data *conf_cards;\n\nstatic const char *alsa_config =\n\"ctl.hw {\\n\"\n\"\t@args [ CARD ]\\n\"\n\"\t@args.CARD.type string\\n\"\n\"\ttype hw\\n\"\n\"\tcard $CARD\\n\"\n\"}\\n\"\n\"pcm.hw {\\n\"\n\"\t@args [ CARD DEV SUBDEV ]\\n\"\n\"\t@args.CARD.type string\\n\"\n\"\t@args.DEV.type integer\\n\"\n\"\t@args.SUBDEV.type integer\\n\"\n\"\ttype hw\\n\"\n\"\tcard $CARD\\n\"\n\"\tdevice $DEV\\n\"\n\"\tsubdevice $SUBDEV\\n\"\n\"}\\n\"\n;\n\n#ifdef SND_LIB_VER\n#if SND_LIB_VERSION >= SND_LIB_VER(1, 2, 6)\n#define LIB_HAS_LOAD_STRING\n#endif\n#endif\n\n#ifndef LIB_HAS_LOAD_STRING\nstatic int snd_config_load_string(snd_config_t **config, const char *s,\n\t\t\t\t  size_t size)\n{\n\tsnd_input_t *input;\n\tsnd_config_t *dst;\n\tint err;\n\n\tassert(config && s);\n\tif (size == 0)\n\t\tsize = strlen(s);\n\terr = snd_input_buffer_open(&input, s, size);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_config_top(&dst);\n\tif (err < 0) {\n\t\tsnd_input_close(input);\n\t\treturn err;\n\t}\n\terr = snd_config_load(dst, input);\n\tsnd_input_close(input);\n\tif (err < 0) {\n\t\tsnd_config_delete(dst);\n\t\treturn err;\n\t}\n\t*config = dst;\n\treturn 0;\n}\n#endif\n\nsnd_config_t *get_alsalib_config(void)\n{\n\tsnd_config_t *config;\n\tint err;\n\n\terr = snd_config_load_string(&config, alsa_config, strlen(alsa_config));\n\tif (err < 0) {\n\t\tksft_print_msg(\"Unable to parse custom alsa-lib configuration: %s\\n\",\n\t\t\t       snd_strerror(err));\n\t\tksft_exit_fail();\n\t}\n\treturn config;\n}\n\nstatic struct card_data *conf_data_by_card(int card, bool msg)\n{\n\tstruct card_data *conf;\n\n\tfor (conf = conf_cards; conf; conf = conf->next) {\n\t\tif (conf->card == card) {\n\t\t\tif (msg)\n\t\t\t\tksft_print_msg(\"using hw card config %s for card %d\\n\",\n\t\t\t\t\t       conf->filename, card);\n\t\t\treturn conf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int dump_config_tree(snd_config_t *top)\n{\n\tsnd_output_t *out;\n\tint err;\n\n\terr = snd_output_stdio_attach(&out, stdout, 0);\n\tif (err < 0)\n\t\tksft_exit_fail_msg(\"stdout attach\\n\");\n\tif (snd_config_save(top, out))\n\t\tksft_exit_fail_msg(\"config save\\n\");\n\tsnd_output_close(out);\n}\n\nsnd_config_t *conf_load_from_file(const char *filename)\n{\n\tsnd_config_t *dst;\n\tsnd_input_t *input;\n\tint err;\n\n\terr = snd_input_stdio_open(&input, filename, \"r\");\n\tif (err < 0)\n\t\tksft_exit_fail_msg(\"Unable to parse filename %s\\n\", filename);\n\terr = snd_config_top(&dst);\n\tif (err < 0)\n\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\terr = snd_config_load(dst, input);\n\tsnd_input_close(input);\n\tif (err < 0)\n\t\tksft_exit_fail_msg(\"Unable to parse filename %s\\n\", filename);\n\treturn dst;\n}\n\nstatic char *sysfs_get(const char *sysfs_root, const char *id)\n{\n\tchar path[PATH_MAX], link[PATH_MAX + 1];\n\tstruct stat sb;\n\tssize_t len;\n\tchar *e;\n\tint fd;\n\n\tif (id[0] == '/')\n\t\tid++;\n\tsnprintf(path, sizeof(path), \"%s/%s\", sysfs_root, id);\n\tif (lstat(path, &sb) != 0)\n\t\treturn NULL;\n\tif (S_ISLNK(sb.st_mode)) {\n\t\tlen = readlink(path, link, sizeof(link) - 1);\n\t\tif (len <= 0) {\n\t\t\tksft_exit_fail_msg(\"sysfs: cannot read link '%s': %s\\n\",\n\t\t\t\t\t   path, strerror(errno));\n\t\t\treturn NULL;\n\t\t}\n\t\tlink[len] = '\\0';\n\t\te = strrchr(link, '/');\n\t\tif (e)\n\t\t\treturn strdup(e + 1);\n\t\treturn NULL;\n\t}\n\tif (S_ISDIR(sb.st_mode))\n\t\treturn NULL;\n\tif ((sb.st_mode & S_IRUSR) == 0)\n\t\treturn NULL;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn NULL;\n\t\tksft_exit_fail_msg(\"sysfs: open failed for '%s': %s\\n\",\n\t\t\t\t   path, strerror(errno));\n\t}\n\tlen = read(fd, path, sizeof(path)-1);\n\tclose(fd);\n\tif (len < 0)\n\t\tksft_exit_fail_msg(\"sysfs: unable to read value '%s': %s\\n\",\n\t\t\t\t   path, strerror(errno));\n\twhile (len > 0 && path[len-1] == '\\n')\n\t\tlen--;\n\tpath[len] = '\\0';\n\te = strdup(path);\n\tif (e == NULL)\n\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\treturn e;\n}\n\nstatic bool sysfs_match(const char *sysfs_root, snd_config_t *config)\n{\n\tsnd_config_t *node, *path_config, *regex_config;\n\tsnd_config_iterator_t i, next;\n\tconst char *path_string, *regex_string, *v;\n\tregex_t re;\n\tregmatch_t match[1];\n\tint iter = 0, ret;\n\n\tsnd_config_for_each(i, next, config) {\n\t\tnode = snd_config_iterator_entry(i);\n\t\tif (snd_config_search(node, \"path\", &path_config))\n\t\t\tksft_exit_fail_msg(\"Missing path field in the sysfs block\\n\");\n\t\tif (snd_config_search(node, \"regex\", &regex_config))\n\t\t\tksft_exit_fail_msg(\"Missing regex field in the sysfs block\\n\");\n\t\tif (snd_config_get_string(path_config, &path_string))\n\t\t\tksft_exit_fail_msg(\"Path field in the sysfs block is not a string\\n\");\n\t\tif (snd_config_get_string(regex_config, &regex_string))\n\t\t\tksft_exit_fail_msg(\"Regex field in the sysfs block is not a string\\n\");\n\t\titer++;\n\t\tv = sysfs_get(sysfs_root, path_string);\n\t\tif (!v)\n\t\t\treturn false;\n\t\tif (regcomp(&re, regex_string, REG_EXTENDED))\n\t\t\tksft_exit_fail_msg(\"Wrong regex '%s'\\n\", regex_string);\n\t\tret = regexec(&re, v, 1, match, 0);\n\t\tregfree(&re);\n\t\tif (ret)\n\t\t\treturn false;\n\t}\n\treturn iter > 0;\n}\n\nstatic bool test_filename1(int card, const char *filename, const char *sysfs_card_root)\n{\n\tstruct card_data *data, *data2;\n\tsnd_config_t *config, *sysfs_config, *card_config, *sysfs_card_config, *node;\n\tsnd_config_iterator_t i, next;\n\n\tconfig = conf_load_from_file(filename);\n\tif (snd_config_search(config, \"sysfs\", &sysfs_config) ||\n\t    snd_config_get_type(sysfs_config) != SND_CONFIG_TYPE_COMPOUND)\n\t\tksft_exit_fail_msg(\"Missing global sysfs block in filename %s\\n\", filename);\n\tif (snd_config_search(config, \"card\", &card_config) ||\n\t    snd_config_get_type(card_config) != SND_CONFIG_TYPE_COMPOUND)\n\t\tksft_exit_fail_msg(\"Missing global card block in filename %s\\n\", filename);\n\tif (!sysfs_match(SYSFS_ROOT, sysfs_config))\n\t\treturn false;\n\tsnd_config_for_each(i, next, card_config) {\n\t\tnode = snd_config_iterator_entry(i);\n\t\tif (snd_config_search(node, \"sysfs\", &sysfs_card_config) ||\n\t\t    snd_config_get_type(sysfs_card_config) != SND_CONFIG_TYPE_COMPOUND)\n\t\t\tksft_exit_fail_msg(\"Missing card sysfs block in filename %s\\n\", filename);\n\t\tif (!sysfs_match(sysfs_card_root, sysfs_card_config))\n\t\t\tcontinue;\n\t\tdata = malloc(sizeof(*data));\n\t\tif (!data)\n\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t\tdata2 = conf_data_by_card(card, false);\n\t\tif (data2)\n\t\t\tksft_exit_fail_msg(\"Duplicate card '%s' <-> '%s'\\n\", filename, data2->filename);\n\t\tdata->card = card;\n\t\tdata->filename = filename;\n\t\tdata->config = node;\n\t\tdata->next = conf_cards;\n\t\tconf_cards = data;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool test_filename(const char *filename)\n{\n\tchar fn[128];\n\tint card;\n\n\tfor (card = 0; card < 32; card++) {\n\t\tsnprintf(fn, sizeof(fn), \"%s/class/sound/card%d\", SYSFS_ROOT, card);\n\t\tif (access(fn, R_OK) == 0 && test_filename1(card, filename, fn))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int filename_filter(const struct dirent *dirent)\n{\n\tsize_t flen;\n\n\tif (dirent == NULL)\n\t\treturn 0;\n\tif (dirent->d_type == DT_DIR)\n\t\treturn 0;\n\tflen = strlen(dirent->d_name);\n\tif (flen <= 5)\n\t\treturn 0;\n\tif (strncmp(&dirent->d_name[flen-5], \".conf\", 5) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid conf_load(void)\n{\n\tconst char *fn = \"conf.d\";\n\tstruct dirent **namelist;\n\tint n, j;\n\n\tn = scandir(fn, &namelist, filename_filter, alphasort);\n\tif (n < 0)\n\t\tksft_exit_fail_msg(\"scandir: %s\\n\", strerror(errno));\n\tfor (j = 0; j < n; j++) {\n\t\tsize_t sl = strlen(fn) + strlen(namelist[j]->d_name) + 2;\n\t\tchar *filename = malloc(sl);\n\t\tif (filename == NULL)\n\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t\tsprintf(filename, \"%s/%s\", fn, namelist[j]->d_name);\n\t\tif (test_filename(filename))\n\t\t\tfilename = NULL;\n\t\tfree(filename);\n\t\tfree(namelist[j]);\n\t}\n\tfree(namelist);\n}\n\nvoid conf_free(void)\n{\n\tstruct card_data *conf;\n\n\twhile (conf_cards) {\n\t\tconf = conf_cards;\n\t\tconf_cards = conf->next;\n\t\tsnd_config_delete(conf->config);\n\t}\n}\n\nsnd_config_t *conf_by_card(int card)\n{\n\tstruct card_data *conf;\n\n\tconf = conf_data_by_card(card, true);\n\tif (conf)\n\t\treturn conf->config;\n\treturn NULL;\n}\n\nstatic int conf_get_by_keys(snd_config_t *root, const char *key1,\n\t\t\t    const char *key2, snd_config_t **result)\n{\n\tint ret;\n\n\tif (key1) {\n\t\tret = snd_config_search(root, key1, &root);\n\t\tif (ret != -ENOENT && ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (key2)\n\t\tret = snd_config_search(root, key2, &root);\n\tif (ret >= 0)\n\t\t*result = root;\n\treturn ret;\n}\n\nsnd_config_t *conf_get_subtree(snd_config_t *root, const char *key1, const char *key2)\n{\n\tint ret;\n\n\tif (!root)\n\t\treturn NULL;\n\tret = conf_get_by_keys(root, key1, key2, &root);\n\tif (ret == -ENOENT)\n\t\treturn NULL;\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\treturn root;\n}\n\nint conf_get_count(snd_config_t *root, const char *key1, const char *key2)\n{\n\tsnd_config_t *cfg;\n\tsnd_config_iterator_t i, next;\n\tint count, ret;\n\n\tif (!root)\n\t\treturn -1;\n\tret = conf_get_by_keys(root, key1, key2, &cfg);\n\tif (ret == -ENOENT)\n\t\treturn -1;\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\tif (snd_config_get_type(cfg) != SND_CONFIG_TYPE_COMPOUND)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' is not a compound\\n\", key1, key2);\n\tcount = 0;\n\tsnd_config_for_each(i, next, cfg)\n\t\tcount++;\n\treturn count;\n}\n\nconst char *conf_get_string(snd_config_t *root, const char *key1, const char *key2, const char *def)\n{\n\tsnd_config_t *cfg;\n\tconst char *s;\n\tint ret;\n\n\tif (!root)\n\t\treturn def;\n\tret = conf_get_by_keys(root, key1, key2, &cfg);\n\tif (ret == -ENOENT)\n\t\treturn def;\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\tif (snd_config_get_string(cfg, &s))\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' is not a string\\n\", key1, key2);\n\treturn s;\n}\n\nlong conf_get_long(snd_config_t *root, const char *key1, const char *key2, long def)\n{\n\tsnd_config_t *cfg;\n\tlong l;\n\tint ret;\n\n\tif (!root)\n\t\treturn def;\n\tret = conf_get_by_keys(root, key1, key2, &cfg);\n\tif (ret == -ENOENT)\n\t\treturn def;\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\tif (snd_config_get_integer(cfg, &l))\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' is not an integer\\n\", key1, key2);\n\treturn l;\n}\n\nint conf_get_bool(snd_config_t *root, const char *key1, const char *key2, int def)\n{\n\tsnd_config_t *cfg;\n\tint ret;\n\n\tif (!root)\n\t\treturn def;\n\tret = conf_get_by_keys(root, key1, key2, &cfg);\n\tif (ret == -ENOENT)\n\t\treturn def;\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\tret = snd_config_get_bool(cfg);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' is not an bool\\n\", key1, key2);\n\treturn !!ret;\n}\n\nvoid conf_get_string_array(snd_config_t *root, const char *key1, const char *key2,\n\t\t\t   const char **array, int array_size, const char *def)\n{\n\tsnd_config_t *cfg;\n\tchar buf[16];\n\tint ret, index;\n\n\tret = conf_get_by_keys(root, key1, key2, &cfg);\n\tif (ret == -ENOENT)\n\t\tcfg = NULL;\n\telse if (ret < 0)\n\t\tksft_exit_fail_msg(\"key '%s'.'%s' search error: %s\\n\", key1, key2, snd_strerror(ret));\n\tfor (index = 0; index < array_size; index++) {\n\t\tif (cfg == NULL) {\n\t\t\tarray[index] = def;\n\t\t} else {\n\t\t\tsprintf(buf, \"%i\", index);\n\t\t\tarray[index] = conf_get_string(cfg, buf, NULL, def);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}