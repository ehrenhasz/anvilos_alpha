{
  "module_name": "test-pcmtest-driver.c",
  "hash_id": "a20d082196e8ee883daa98535e64ad7cb5b31b32c23b38fa372de00c9856302e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/alsa/test-pcmtest-driver.c",
  "human_readable_source": "\n \n#include <string.h>\n#include <alsa/asoundlib.h>\n#include \"../kselftest_harness.h\"\n\n#define CH_NUM 4\n\nstruct pattern_buf {\n\tchar buf[1024];\n\tint len;\n};\n\nstruct pattern_buf patterns[CH_NUM];\n\nstruct pcmtest_test_params {\n\tunsigned long buffer_size;\n\tunsigned long period_size;\n\tunsigned long channels;\n\tunsigned int rate;\n\tsnd_pcm_access_t access;\n\tsize_t sec_buf_len;\n\tsize_t sample_size;\n\tint time;\n\tsnd_pcm_format_t format;\n};\n\nstatic int read_patterns(void)\n{\n\tFILE *fp, *fpl;\n\tint i;\n\tchar pf[64];\n\tchar plf[64];\n\n\tfor (i = 0; i < CH_NUM; i++) {\n\t\tsprintf(plf, \"/sys/kernel/debug/pcmtest/fill_pattern%d_len\", i);\n\t\tfpl = fopen(plf, \"r\");\n\t\tif (!fpl)\n\t\t\treturn -1;\n\t\tfscanf(fpl, \"%u\", &patterns[i].len);\n\t\tfclose(fpl);\n\n\t\tsprintf(pf, \"/sys/kernel/debug/pcmtest/fill_pattern%d\", i);\n\t\tfp = fopen(pf, \"r\");\n\t\tif (!fp)\n\t\t\treturn -1;\n\t\tfread(patterns[i].buf, 1, patterns[i].len, fp);\n\t\tfclose(fp);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_test_results(char *debug_name)\n{\n\tint result;\n\tFILE *f;\n\tchar fname[128];\n\n\tsprintf(fname, \"/sys/kernel/debug/pcmtest/%s\", debug_name);\n\n\tf = fopen(fname, \"r\");\n\tif (!f) {\n\t\tprintf(\"Failed to open file\\n\");\n\t\treturn -1;\n\t}\n\tfscanf(f, \"%d\", &result);\n\tfclose(f);\n\n\treturn result;\n}\n\nstatic size_t get_sec_buf_len(unsigned int rate, unsigned long channels, snd_pcm_format_t format)\n{\n\treturn rate * channels * snd_pcm_format_physical_width(format) / 8;\n}\n\nstatic int setup_handle(snd_pcm_t **handle, snd_pcm_sw_params_t *swparams,\n\t\t\tsnd_pcm_hw_params_t *hwparams, struct pcmtest_test_params *params,\n\t\t\tint card, snd_pcm_stream_t stream)\n{\n\tchar pcm_name[32];\n\tint err;\n\n\tsprintf(pcm_name, \"hw:%d,0,0\", card);\n\terr = snd_pcm_open(handle, pcm_name, stream, 0);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_hw_params_any(*handle, hwparams);\n\tsnd_pcm_hw_params_set_rate_resample(*handle, hwparams, 0);\n\tsnd_pcm_hw_params_set_access(*handle, hwparams, params->access);\n\tsnd_pcm_hw_params_set_format(*handle, hwparams, params->format);\n\tsnd_pcm_hw_params_set_channels(*handle, hwparams, params->channels);\n\tsnd_pcm_hw_params_set_rate_near(*handle, hwparams, &params->rate, 0);\n\tsnd_pcm_hw_params_set_period_size_near(*handle, hwparams, &params->period_size, 0);\n\tsnd_pcm_hw_params_set_buffer_size_near(*handle, hwparams, &params->buffer_size);\n\tsnd_pcm_hw_params(*handle, hwparams);\n\tsnd_pcm_sw_params_current(*handle, swparams);\n\n\tsnd_pcm_hw_params_set_rate_resample(*handle, hwparams, 0);\n\tsnd_pcm_sw_params_set_avail_min(*handle, swparams, params->period_size);\n\tsnd_pcm_hw_params_set_buffer_size_near(*handle, hwparams, &params->buffer_size);\n\tsnd_pcm_hw_params_set_period_size_near(*handle, hwparams, &params->period_size, 0);\n\tsnd_pcm_sw_params(*handle, swparams);\n\tsnd_pcm_hw_params(*handle, hwparams);\n\n\treturn 0;\n}\n\nFIXTURE(pcmtest) {\n\tint card;\n\tsnd_pcm_sw_params_t *swparams;\n\tsnd_pcm_hw_params_t *hwparams;\n\tstruct pcmtest_test_params params;\n};\n\nFIXTURE_TEARDOWN(pcmtest) {\n}\n\nFIXTURE_SETUP(pcmtest) {\n\tchar *card_name;\n\tint err;\n\n\tif (geteuid())\n\t\tSKIP(exit(-1), \"This test needs root to run!\");\n\n\terr = read_patterns();\n\tif (err)\n\t\tSKIP(exit(-1), \"Can't read patterns. Probably, module isn't loaded\");\n\n\tcard_name = malloc(127);\n\tASSERT_NE(card_name, NULL);\n\tself->params.buffer_size = 16384;\n\tself->params.period_size = 4096;\n\tself->params.channels = CH_NUM;\n\tself->params.rate = 8000;\n\tself->params.access = SND_PCM_ACCESS_RW_INTERLEAVED;\n\tself->params.format = SND_PCM_FORMAT_S16_LE;\n\tself->card = -1;\n\tself->params.sample_size = snd_pcm_format_physical_width(self->params.format) / 8;\n\n\tself->params.sec_buf_len = get_sec_buf_len(self->params.rate, self->params.channels,\n\t\t\t\t\t\t   self->params.format);\n\tself->params.time = 4;\n\n\twhile (snd_card_next(&self->card) >= 0) {\n\t\tif (self->card == -1)\n\t\t\tbreak;\n\t\tsnd_card_get_name(self->card, &card_name);\n\t\tif (!strcmp(card_name, \"PCM-Test\"))\n\t\t\tbreak;\n\t}\n\tfree(card_name);\n\tASSERT_NE(self->card, -1);\n}\n\n \nTEST_F(pcmtest, playback) {\n\tsnd_pcm_t *handle;\n\tunsigned char *it;\n\tsize_t write_res;\n\tint test_results;\n\tint i, cur_ch, pos_in_ch;\n\tvoid *samples;\n\tstruct pcmtest_test_params *params = &self->params;\n\n\tsamples = calloc(self->params.sec_buf_len * self->params.time, 1);\n\tASSERT_NE(samples, NULL);\n\n\tsnd_pcm_sw_params_alloca(&self->swparams);\n\tsnd_pcm_hw_params_alloca(&self->hwparams);\n\n\tASSERT_EQ(setup_handle(&handle, self->swparams, self->hwparams, params,\n\t\t\t       self->card, SND_PCM_STREAM_PLAYBACK), 0);\n\tsnd_pcm_format_set_silence(params->format, samples,\n\t\t\t\t   params->rate * params->channels * params->time);\n\tit = samples;\n\tfor (i = 0; i < self->params.sec_buf_len * params->time; i++) {\n\t\tcur_ch = (i / params->sample_size) % CH_NUM;\n\t\tpos_in_ch = i / params->sample_size / CH_NUM * params->sample_size\n\t\t\t    + (i % params->sample_size);\n\t\tit[i] = patterns[cur_ch].buf[pos_in_ch % patterns[cur_ch].len];\n\t}\n\twrite_res = snd_pcm_writei(handle, samples, params->rate * params->time);\n\tASSERT_GE(write_res, 0);\n\n\tsnd_pcm_close(handle);\n\tfree(samples);\n\ttest_results = get_test_results(\"pc_test\");\n\tASSERT_EQ(test_results, 1);\n}\n\n \nTEST_F(pcmtest, capture) {\n\tsnd_pcm_t *handle;\n\tunsigned char *it;\n\tsize_t read_res;\n\tint i, cur_ch, pos_in_ch;\n\tvoid *samples;\n\tstruct pcmtest_test_params *params = &self->params;\n\n\tsamples = calloc(self->params.sec_buf_len * self->params.time, 1);\n\tASSERT_NE(samples, NULL);\n\n\tsnd_pcm_sw_params_alloca(&self->swparams);\n\tsnd_pcm_hw_params_alloca(&self->hwparams);\n\n\tASSERT_EQ(setup_handle(&handle, self->swparams, self->hwparams,\n\t\t\t       params, self->card, SND_PCM_STREAM_CAPTURE), 0);\n\tsnd_pcm_format_set_silence(params->format, samples,\n\t\t\t\t   params->rate * params->channels * params->time);\n\tread_res = snd_pcm_readi(handle, samples, params->rate * params->time);\n\tASSERT_GE(read_res, 0);\n\tsnd_pcm_close(handle);\n\tit = (unsigned char *)samples;\n\tfor (i = 0; i < self->params.sec_buf_len * self->params.time; i++) {\n\t\tcur_ch = (i / params->sample_size) % CH_NUM;\n\t\tpos_in_ch = i / params->sample_size / CH_NUM * params->sample_size\n\t\t\t    + (i % params->sample_size);\n\t\tASSERT_EQ(it[i], patterns[cur_ch].buf[pos_in_ch % patterns[cur_ch].len]);\n\t}\n\tfree(samples);\n}\n\n \nTEST_F(pcmtest, ni_capture) {\n\tsnd_pcm_t *handle;\n\tstruct pcmtest_test_params params = self->params;\n\tchar **chan_samples;\n\tsize_t i, j, read_res;\n\n\tchan_samples = calloc(CH_NUM, sizeof(*chan_samples));\n\tASSERT_NE(chan_samples, NULL);\n\n\tsnd_pcm_sw_params_alloca(&self->swparams);\n\tsnd_pcm_hw_params_alloca(&self->hwparams);\n\n\tparams.access = SND_PCM_ACCESS_RW_NONINTERLEAVED;\n\n\tASSERT_EQ(setup_handle(&handle, self->swparams, self->hwparams,\n\t\t\t       &params, self->card, SND_PCM_STREAM_CAPTURE), 0);\n\n\tfor (i = 0; i < CH_NUM; i++)\n\t\tchan_samples[i] = calloc(params.sec_buf_len * params.time, 1);\n\n\tfor (i = 0; i < 1; i++) {\n\t\tread_res = snd_pcm_readn(handle, (void **)chan_samples, params.rate * params.time);\n\t\tASSERT_GE(read_res, 0);\n\t}\n\tsnd_pcm_close(handle);\n\n\tfor (i = 0; i < CH_NUM; i++) {\n\t\tfor (j = 0; j < params.rate * params.time; j++)\n\t\t\tASSERT_EQ(chan_samples[i][j], patterns[i].buf[j % patterns[i].len]);\n\t\tfree(chan_samples[i]);\n\t}\n\tfree(chan_samples);\n}\n\nTEST_F(pcmtest, ni_playback) {\n\tsnd_pcm_t *handle;\n\tstruct pcmtest_test_params params = self->params;\n\tchar **chan_samples;\n\tsize_t i, j, read_res;\n\tint test_res;\n\n\tchan_samples = calloc(CH_NUM, sizeof(*chan_samples));\n\tASSERT_NE(chan_samples, NULL);\n\n\tsnd_pcm_sw_params_alloca(&self->swparams);\n\tsnd_pcm_hw_params_alloca(&self->hwparams);\n\n\tparams.access = SND_PCM_ACCESS_RW_NONINTERLEAVED;\n\n\tASSERT_EQ(setup_handle(&handle, self->swparams, self->hwparams,\n\t\t\t       &params, self->card, SND_PCM_STREAM_PLAYBACK), 0);\n\n\tfor (i = 0; i < CH_NUM; i++) {\n\t\tchan_samples[i] = calloc(params.sec_buf_len * params.time, 1);\n\t\tfor (j = 0; j < params.sec_buf_len * params.time; j++)\n\t\t\tchan_samples[i][j] = patterns[i].buf[j % patterns[i].len];\n\t}\n\n\tfor (i = 0; i < 1; i++) {\n\t\tread_res = snd_pcm_writen(handle, (void **)chan_samples, params.rate * params.time);\n\t\tASSERT_GE(read_res, 0);\n\t}\n\n\tsnd_pcm_close(handle);\n\ttest_res = get_test_results(\"pc_test\");\n\tASSERT_EQ(test_res, 1);\n\n\tfor (i = 0; i < CH_NUM; i++)\n\t\tfree(chan_samples[i]);\n\tfree(chan_samples);\n}\n\n \nTEST_F(pcmtest, reset_ioctl) {\n\tsnd_pcm_t *handle;\n\tint test_res;\n\tstruct pcmtest_test_params *params = &self->params;\n\n\tsnd_pcm_sw_params_alloca(&self->swparams);\n\tsnd_pcm_hw_params_alloca(&self->hwparams);\n\n\tASSERT_EQ(setup_handle(&handle, self->swparams, self->hwparams, params,\n\t\t\t       self->card, SND_PCM_STREAM_CAPTURE), 0);\n\tsnd_pcm_reset(handle);\n\ttest_res = get_test_results(\"ioctl_test\");\n\tASSERT_EQ(test_res, 1);\n\tsnd_pcm_close(handle);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}