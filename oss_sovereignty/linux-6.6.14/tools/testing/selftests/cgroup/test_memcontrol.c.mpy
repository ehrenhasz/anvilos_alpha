{
  "module_name": "test_memcontrol.c",
  "hash_id": "e7944c77293e72b3896864290e3799117b38ee77264b780a12f86d7d69308f21",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_memcontrol.c",
  "human_readable_source": " \n#define _GNU_SOURCE\n\n#include <linux/limits.h>\n#include <linux/oom.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/mman.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\nstatic bool has_localevents;\nstatic bool has_recursiveprot;\n\n \nstatic int test_memcg_subtree_control(const char *root)\n{\n\tchar *parent, *child, *parent2 = NULL, *child2 = NULL;\n\tint ret = KSFT_FAIL;\n\tchar buf[PAGE_SIZE];\n\n\t \n\tparent = cg_name(root, \"memcg_test_0\");\n\tchild = cg_name(root, \"memcg_test_0/memcg_test_1\");\n\tif (!parent || !child)\n\t\tgoto cleanup_free;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup_free;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup_parent;\n\n\tif (cg_create(child))\n\t\tgoto cleanup_parent;\n\n\tif (cg_read_strstr(child, \"cgroup.controllers\", \"memory\"))\n\t\tgoto cleanup_child;\n\n\t \n\tparent2 = cg_name(root, \"memcg_test_1\");\n\tchild2 = cg_name(root, \"memcg_test_1/memcg_test_1\");\n\tif (!parent2 || !child2)\n\t\tgoto cleanup_free2;\n\n\tif (cg_create(parent2))\n\t\tgoto cleanup_free2;\n\n\tif (cg_create(child2))\n\t\tgoto cleanup_parent2;\n\n\tif (cg_read(child2, \"cgroup.controllers\", buf, sizeof(buf)))\n\t\tgoto cleanup_all;\n\n\tif (!cg_read_strstr(child2, \"cgroup.controllers\", \"memory\"))\n\t\tgoto cleanup_all;\n\n\tret = KSFT_PASS;\n\ncleanup_all:\n\tcg_destroy(child2);\ncleanup_parent2:\n\tcg_destroy(parent2);\ncleanup_free2:\n\tfree(parent2);\n\tfree(child2);\ncleanup_child:\n\tcg_destroy(child);\ncleanup_parent:\n\tcg_destroy(parent);\ncleanup_free:\n\tfree(parent);\n\tfree(child);\n\n\treturn ret;\n}\n\nstatic int alloc_anon_50M_check(const char *cgroup, void *arg)\n{\n\tsize_t size = MB(50);\n\tchar *buf, *ptr;\n\tlong anon, current;\n\tint ret = -1;\n\n\tbuf = malloc(size);\n\tif (buf == NULL) {\n\t\tfprintf(stderr, \"malloc() failed\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)\n\t\t*ptr = 0;\n\n\tcurrent = cg_read_long(cgroup, \"memory.current\");\n\tif (current < size)\n\t\tgoto cleanup;\n\n\tif (!values_close(size, current, 3))\n\t\tgoto cleanup;\n\n\tanon = cg_read_key_long(cgroup, \"memory.stat\", \"anon \");\n\tif (anon < 0)\n\t\tgoto cleanup;\n\n\tif (!values_close(anon, current, 3))\n\t\tgoto cleanup;\n\n\tret = 0;\ncleanup:\n\tfree(buf);\n\treturn ret;\n}\n\nstatic int alloc_pagecache_50M_check(const char *cgroup, void *arg)\n{\n\tsize_t size = MB(50);\n\tint ret = -1;\n\tlong current, file;\n\tint fd;\n\n\tfd = get_temp_fd();\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (alloc_pagecache(fd, size))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(cgroup, \"memory.current\");\n\tif (current < size)\n\t\tgoto cleanup;\n\n\tfile = cg_read_key_long(cgroup, \"memory.stat\", \"file \");\n\tif (file < 0)\n\t\tgoto cleanup;\n\n\tif (!values_close(file, current, 10))\n\t\tgoto cleanup;\n\n\tret = 0;\n\ncleanup:\n\tclose(fd);\n\treturn ret;\n}\n\n \nstatic int test_memcg_current(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tlong current;\n\tchar *memcg;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(memcg, \"memory.current\");\n\tif (current != 0)\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_anon_50M_check, NULL))\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_pagecache_50M_check, NULL))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\nstatic int alloc_pagecache_50M_noexit(const char *cgroup, void *arg)\n{\n\tint fd = (long)arg;\n\tint ppid = getppid();\n\n\tif (alloc_pagecache(fd, MB(50)))\n\t\treturn -1;\n\n\twhile (getppid() == ppid)\n\t\tsleep(1);\n\n\treturn 0;\n}\n\nstatic int alloc_anon_noexit(const char *cgroup, void *arg)\n{\n\tint ppid = getppid();\n\tsize_t size = (unsigned long)arg;\n\tchar *buf, *ptr;\n\n\tbuf = malloc(size);\n\tif (buf == NULL) {\n\t\tfprintf(stderr, \"malloc() failed\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)\n\t\t*ptr = 0;\n\n\twhile (getppid() == ppid)\n\t\tsleep(1);\n\n\tfree(buf);\n\treturn 0;\n}\n\n \nstatic int cg_test_proc_killed(const char *cgroup)\n{\n\tint limit;\n\n\tfor (limit = 10; limit > 0; limit--) {\n\t\tif (cg_read_strcmp(cgroup, \"cgroup.procs\", \"\") == 0)\n\t\t\treturn 0;\n\n\t\tusleep(100000);\n\t}\n\treturn -1;\n}\n\nstatic bool reclaim_until(const char *memcg, long goal);\n\n \nstatic int test_memcg_protection(const char *root, bool min)\n{\n\tint ret = KSFT_FAIL, rc;\n\tchar *parent[3] = {NULL};\n\tchar *children[4] = {NULL};\n\tconst char *attribute = min ? \"memory.min\" : \"memory.low\";\n\tlong c[4];\n\tlong current;\n\tint i, attempts;\n\tint fd;\n\n\tfd = get_temp_fd();\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\tparent[0] = cg_name(root, \"memcg_test_0\");\n\tif (!parent[0])\n\t\tgoto cleanup;\n\n\tparent[1] = cg_name(parent[0], \"memcg_test_1\");\n\tif (!parent[1])\n\t\tgoto cleanup;\n\n\tparent[2] = cg_name(parent[0], \"memcg_test_2\");\n\tif (!parent[2])\n\t\tgoto cleanup;\n\n\tif (cg_create(parent[0]))\n\t\tgoto cleanup;\n\n\tif (cg_read_long(parent[0], attribute)) {\n\t\t \n\t\tif (min)\n\t\t\tret = KSFT_SKIP;\n\t\tgoto cleanup;\n\t}\n\n\tif (cg_write(parent[0], \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent[0], \"memory.max\", \"200M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent[0], \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_create(parent[1]))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent[1], \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_create(parent[2]))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tchildren[i] = cg_name_indexed(parent[1], \"child_memcg\", i);\n\t\tif (!children[i])\n\t\t\tgoto cleanup;\n\n\t\tif (cg_create(children[i]))\n\t\t\tgoto cleanup;\n\n\t\tif (i > 2)\n\t\t\tcontinue;\n\n\t\tcg_run_nowait(children[i], alloc_pagecache_50M_noexit,\n\t\t\t      (void *)(long)fd);\n\t}\n\n\tif (cg_write(parent[1],   attribute, \"50M\"))\n\t\tgoto cleanup;\n\tif (cg_write(children[0], attribute, \"75M\"))\n\t\tgoto cleanup;\n\tif (cg_write(children[1], attribute, \"25M\"))\n\t\tgoto cleanup;\n\tif (cg_write(children[2], attribute, \"0\"))\n\t\tgoto cleanup;\n\tif (cg_write(children[3], attribute, \"500M\"))\n\t\tgoto cleanup;\n\n\tattempts = 0;\n\twhile (!values_close(cg_read_long(parent[1], \"memory.current\"),\n\t\t\t     MB(150), 3)) {\n\t\tif (attempts++ > 5)\n\t\t\tbreak;\n\t\tsleep(1);\n\t}\n\n\tif (cg_run(parent[2], alloc_anon, (void *)MB(148)))\n\t\tgoto cleanup;\n\n\tif (!values_close(cg_read_long(parent[1], \"memory.current\"), MB(50), 3))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++)\n\t\tc[i] = cg_read_long(children[i], \"memory.current\");\n\n\tif (!values_close(c[0], MB(29), 10))\n\t\tgoto cleanup;\n\n\tif (!values_close(c[1], MB(21), 10))\n\t\tgoto cleanup;\n\n\tif (c[3] != 0)\n\t\tgoto cleanup;\n\n\trc = cg_run(parent[2], alloc_anon, (void *)MB(170));\n\tif (min && !rc)\n\t\tgoto cleanup;\n\telse if (!min && rc) {\n\t\tfprintf(stderr,\n\t\t\t\"memory.low prevents from allocating anon memory\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tcurrent = min ? MB(50) : MB(30);\n\tif (!values_close(cg_read_long(parent[1], \"memory.current\"), current, 3))\n\t\tgoto cleanup;\n\n\tif (!reclaim_until(children[0], MB(10)))\n\t\tgoto cleanup;\n\n\tif (min) {\n\t\tret = KSFT_PASS;\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tint no_low_events_index = 1;\n\t\tlong low, oom;\n\n\t\toom = cg_read_key_long(children[i], \"memory.events\", \"oom \");\n\t\tlow = cg_read_key_long(children[i], \"memory.events\", \"low \");\n\n\t\tif (oom)\n\t\t\tgoto cleanup;\n\t\tif (i <= no_low_events_index && low <= 0)\n\t\t\tgoto cleanup;\n\t\tif (i > no_low_events_index && low)\n\t\t\tgoto cleanup;\n\n\t}\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tfor (i = ARRAY_SIZE(children) - 1; i >= 0; i--) {\n\t\tif (!children[i])\n\t\t\tcontinue;\n\n\t\tcg_destroy(children[i]);\n\t\tfree(children[i]);\n\t}\n\n\tfor (i = ARRAY_SIZE(parent) - 1; i >= 0; i--) {\n\t\tif (!parent[i])\n\t\t\tcontinue;\n\n\t\tcg_destroy(parent[i]);\n\t\tfree(parent[i]);\n\t}\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int test_memcg_min(const char *root)\n{\n\treturn test_memcg_protection(root, true);\n}\n\nstatic int test_memcg_low(const char *root)\n{\n\treturn test_memcg_protection(root, false);\n}\n\nstatic int alloc_pagecache_max_30M(const char *cgroup, void *arg)\n{\n\tsize_t size = MB(50);\n\tint ret = -1;\n\tlong current, high, max;\n\tint fd;\n\n\thigh = cg_read_long(cgroup, \"memory.high\");\n\tmax = cg_read_long(cgroup, \"memory.max\");\n\tif (high != MB(30) && max != MB(30))\n\t\treturn -1;\n\n\tfd = get_temp_fd();\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (alloc_pagecache(fd, size))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(cgroup, \"memory.current\");\n\tif (!values_close(current, MB(30), 5))\n\t\tgoto cleanup;\n\n\tret = 0;\n\ncleanup:\n\tclose(fd);\n\treturn ret;\n\n}\n\n \nstatic int test_memcg_high(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *memcg;\n\tlong high;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(memcg, \"memory.high\", \"max\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.high\", \"30M\"))\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_anon, (void *)MB(31)))\n\t\tgoto cleanup;\n\n\tif (!cg_run(memcg, alloc_pagecache_50M_check, NULL))\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_pagecache_max_30M, NULL))\n\t\tgoto cleanup;\n\n\thigh = cg_read_key_long(memcg, \"memory.events\", \"high \");\n\tif (high <= 0)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\nstatic int alloc_anon_mlock(const char *cgroup, void *arg)\n{\n\tsize_t size = (size_t)arg;\n\tvoid *buf;\n\n\tbuf = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON,\n\t\t   0, 0);\n\tif (buf == MAP_FAILED)\n\t\treturn -1;\n\n\tmlock(buf, size);\n\tmunmap(buf, size);\n\treturn 0;\n}\n\n \nstatic int test_memcg_high_sync(const char *root)\n{\n\tint ret = KSFT_FAIL, pid, fd = -1;\n\tchar *memcg;\n\tlong pre_high, pre_max;\n\tlong post_high, post_max;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tpre_high = cg_read_key_long(memcg, \"memory.events\", \"high \");\n\tpre_max = cg_read_key_long(memcg, \"memory.events\", \"max \");\n\tif (pre_high < 0 || pre_max < 0)\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.high\", \"30M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.max\", \"140M\"))\n\t\tgoto cleanup;\n\n\tfd = memcg_prepare_for_wait(memcg);\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(memcg, alloc_anon_mlock, (void *)MB(200));\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tcg_wait_for(fd);\n\n\tpost_high = cg_read_key_long(memcg, \"memory.events\", \"high \");\n\tpost_max = cg_read_key_long(memcg, \"memory.events\", \"max \");\n\tif (post_high < 0 || post_max < 0)\n\t\tgoto cleanup;\n\n\tif (pre_high == post_high || pre_max != post_max)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\n \nstatic int test_memcg_max(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *memcg;\n\tlong current, max;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(memcg, \"memory.max\", \"max\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.max\", \"30M\"))\n\t\tgoto cleanup;\n\n\t \n\tif (!cg_run(memcg, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_pagecache_max_30M, NULL))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(memcg, \"memory.current\");\n\tif (current > MB(30) || !current)\n\t\tgoto cleanup;\n\n\tmax = cg_read_key_long(memcg, \"memory.events\", \"max \");\n\tif (max <= 0)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\n \nstatic bool reclaim_until(const char *memcg, long goal)\n{\n\tchar buf[64];\n\tint retries, err;\n\tlong current, to_reclaim;\n\tbool reclaimed = false;\n\n\tfor (retries = 5; retries > 0; retries--) {\n\t\tcurrent = cg_read_long(memcg, \"memory.current\");\n\n\t\tif (current < goal || values_close(current, goal, 3))\n\t\t\tbreak;\n\t\t \n\t\telse if (reclaimed)\n\t\t\treturn false;\n\n\t\tto_reclaim = current - goal;\n\t\tsnprintf(buf, sizeof(buf), \"%ld\", to_reclaim);\n\t\terr = cg_write(memcg, \"memory.reclaim\", buf);\n\t\tif (!err)\n\t\t\treclaimed = true;\n\t\telse if (err != -EAGAIN)\n\t\t\treturn false;\n\t}\n\treturn reclaimed;\n}\n\n \nstatic int test_memcg_reclaim(const char *root)\n{\n\tint ret = KSFT_FAIL, fd, retries;\n\tchar *memcg;\n\tlong current, expected_usage;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(memcg, \"memory.current\");\n\tif (current != 0)\n\t\tgoto cleanup;\n\n\tfd = get_temp_fd();\n\tif (fd < 0)\n\t\tgoto cleanup;\n\n\tcg_run_nowait(memcg, alloc_pagecache_50M_noexit, (void *)(long)fd);\n\n\t \n\tif (is_swap_enabled()) {\n\t\tcg_run_nowait(memcg, alloc_anon_noexit, (void *) MB(50));\n\t\texpected_usage = MB(100);\n\t} else\n\t\texpected_usage = MB(50);\n\n\t \n\tretries = 5;\n\twhile (!values_close(cg_read_long(memcg, \"memory.current\"),\n\t\t\t    expected_usage, 10)) {\n\t\tif (retries--) {\n\t\t\tsleep(1);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"failed to allocate %ld for memcg reclaim test\\n\",\n\t\t\t\texpected_usage);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tif (!reclaim_until(memcg, MB(30)))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int alloc_anon_50M_check_swap(const char *cgroup, void *arg)\n{\n\tlong mem_max = (long)arg;\n\tsize_t size = MB(50);\n\tchar *buf, *ptr;\n\tlong mem_current, swap_current;\n\tint ret = -1;\n\n\tbuf = malloc(size);\n\tif (buf == NULL) {\n\t\tfprintf(stderr, \"malloc() failed\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)\n\t\t*ptr = 0;\n\n\tmem_current = cg_read_long(cgroup, \"memory.current\");\n\tif (!mem_current || !values_close(mem_current, mem_max, 3))\n\t\tgoto cleanup;\n\n\tswap_current = cg_read_long(cgroup, \"memory.swap.current\");\n\tif (!swap_current ||\n\t    !values_close(mem_current + swap_current, size, 3))\n\t\tgoto cleanup;\n\n\tret = 0;\ncleanup:\n\tfree(buf);\n\treturn ret;\n}\n\n \nstatic int test_memcg_swap_max(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *memcg;\n\tlong max;\n\n\tif (!is_swap_enabled())\n\t\treturn KSFT_SKIP;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tif (cg_read_long(memcg, \"memory.swap.current\")) {\n\t\tret = KSFT_SKIP;\n\t\tgoto cleanup;\n\t}\n\n\tif (cg_read_strcmp(memcg, \"memory.max\", \"max\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(memcg, \"memory.swap.max\", \"max\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"30M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.max\", \"30M\"))\n\t\tgoto cleanup;\n\n\t \n\tif (!cg_run(memcg, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.events\", \"oom \") != 1)\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.events\", \"oom_kill \") != 1)\n\t\tgoto cleanup;\n\n\tif (cg_run(memcg, alloc_anon_50M_check_swap, (void *)MB(30)))\n\t\tgoto cleanup;\n\n\tmax = cg_read_key_long(memcg, \"memory.events\", \"max \");\n\tif (max <= 0)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\n \nstatic int test_memcg_oom_events(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *memcg;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.max\", \"30M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (!cg_run(memcg, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(memcg, \"cgroup.procs\", \"\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.events\", \"oom \") != 1)\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.events\", \"oom_kill \") != 1)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\nstruct tcp_server_args {\n\tunsigned short port;\n\tint ctl[2];\n};\n\nstatic int tcp_server(const char *cgroup, void *arg)\n{\n\tstruct tcp_server_args *srv_args = arg;\n\tstruct sockaddr_in6 saddr = { 0 };\n\tsocklen_t slen = sizeof(saddr);\n\tint sk, client_sk, ctl_fd, yes = 1, ret = -1;\n\n\tclose(srv_args->ctl[0]);\n\tctl_fd = srv_args->ctl[1];\n\n\tsaddr.sin6_family = AF_INET6;\n\tsaddr.sin6_addr = in6addr_any;\n\tsaddr.sin6_port = htons(srv_args->port);\n\n\tsk = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (sk < 0)\n\t\treturn ret;\n\n\tif (setsockopt(sk, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) < 0)\n\t\tgoto cleanup;\n\n\tif (bind(sk, (struct sockaddr *)&saddr, slen)) {\n\t\twrite(ctl_fd, &errno, sizeof(errno));\n\t\tgoto cleanup;\n\t}\n\n\tif (listen(sk, 1))\n\t\tgoto cleanup;\n\n\tret = 0;\n\tif (write(ctl_fd, &ret, sizeof(ret)) != sizeof(ret)) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\n\tclient_sk = accept(sk, NULL, NULL);\n\tif (client_sk < 0)\n\t\tgoto cleanup;\n\n\tret = -1;\n\tfor (;;) {\n\t\tuint8_t buf[0x100000];\n\n\t\tif (write(client_sk, buf, sizeof(buf)) <= 0) {\n\t\t\tif (errno == ECONNRESET)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose(client_sk);\n\ncleanup:\n\tclose(sk);\n\treturn ret;\n}\n\nstatic int tcp_client(const char *cgroup, unsigned short port)\n{\n\tconst char server[] = \"localhost\";\n\tstruct addrinfo *ai;\n\tchar servport[6];\n\tint retries = 0x10;  \n\tint sk, ret;\n\tlong allocated;\n\n\tallocated = cg_read_long(cgroup, \"memory.current\");\n\tsnprintf(servport, sizeof(servport), \"%hd\", port);\n\tret = getaddrinfo(server, servport, NULL, &ai);\n\tif (ret)\n\t\treturn ret;\n\n\tsk = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sk < 0)\n\t\tgoto free_ainfo;\n\n\tret = connect(sk, ai->ai_addr, ai->ai_addrlen);\n\tif (ret < 0)\n\t\tgoto close_sk;\n\n\tret = KSFT_FAIL;\n\twhile (retries--) {\n\t\tuint8_t buf[0x100000];\n\t\tlong current, sock;\n\n\t\tif (read(sk, buf, sizeof(buf)) <= 0)\n\t\t\tgoto close_sk;\n\n\t\tcurrent = cg_read_long(cgroup, \"memory.current\");\n\t\tsock = cg_read_key_long(cgroup, \"memory.stat\", \"sock \");\n\n\t\tif (current < 0 || sock < 0)\n\t\t\tgoto close_sk;\n\n\t\t \n\t\tif (values_close(current - allocated, sock, 10)) {\n\t\t\tret = KSFT_PASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\nclose_sk:\n\tclose(sk);\nfree_ainfo:\n\tfreeaddrinfo(ai);\n\treturn ret;\n}\n\n \nstatic int test_memcg_sock(const char *root)\n{\n\tint bind_retries = 5, ret = KSFT_FAIL, pid, err;\n\tunsigned short port;\n\tchar *memcg;\n\n\tmemcg = cg_name(root, \"memcg_test\");\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\twhile (bind_retries--) {\n\t\tstruct tcp_server_args args;\n\n\t\tif (pipe(args.ctl))\n\t\t\tgoto cleanup;\n\n\t\tport = args.port = 1000 + rand() % 60000;\n\n\t\tpid = cg_run_nowait(memcg, tcp_server, &args);\n\t\tif (pid < 0)\n\t\t\tgoto cleanup;\n\n\t\tclose(args.ctl[1]);\n\t\tif (read(args.ctl[0], &err, sizeof(err)) != sizeof(err))\n\t\t\tgoto cleanup;\n\t\tclose(args.ctl[0]);\n\n\t\tif (!err)\n\t\t\tbreak;\n\t\tif (err != EADDRINUSE)\n\t\t\tgoto cleanup;\n\n\t\twaitpid(pid, NULL, 0);\n\t}\n\n\tif (err == EADDRINUSE) {\n\t\tret = KSFT_SKIP;\n\t\tgoto cleanup;\n\t}\n\n\tif (tcp_client(memcg, port) != KSFT_PASS)\n\t\tgoto cleanup;\n\n\twaitpid(pid, &err, 0);\n\tif (WEXITSTATUS(err))\n\t\tgoto cleanup;\n\n\tif (cg_read_long(memcg, \"memory.current\") < 0)\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.stat\", \"sock \"))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\n \nstatic int test_memcg_oom_group_leaf_events(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent, *child;\n\tlong parent_oom_events;\n\n\tparent = cg_name(root, \"memcg_test_0\");\n\tchild = cg_name(root, \"memcg_test_0/memcg_test_1\");\n\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"memory.max\", \"50M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"memory.oom.group\", \"1\"))\n\t\tgoto cleanup;\n\n\tcg_run_nowait(parent, alloc_anon_noexit, (void *) MB(60));\n\tcg_run_nowait(child, alloc_anon_noexit, (void *) MB(1));\n\tcg_run_nowait(child, alloc_anon_noexit, (void *) MB(1));\n\tif (!cg_run(child, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_test_proc_killed(child))\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(child, \"memory.events\", \"oom_kill \") <= 0)\n\t\tgoto cleanup;\n\n\tparent_oom_events = cg_read_key_long(\n\t\t\tparent, \"memory.events\", \"oom_kill \");\n\t \n\tif (has_localevents && parent_oom_events != 0)\n\t\tgoto cleanup;\n\telse if (!has_localevents && parent_oom_events <= 0)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\n\treturn ret;\n}\n\n \nstatic int test_memcg_oom_group_parent_events(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent, *child;\n\n\tparent = cg_name(root, \"memcg_test_0\");\n\tchild = cg_name(root, \"memcg_test_0/memcg_test_1\");\n\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"memory.max\", \"80M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"memory.oom.group\", \"1\"))\n\t\tgoto cleanup;\n\n\tcg_run_nowait(parent, alloc_anon_noexit, (void *) MB(60));\n\tcg_run_nowait(child, alloc_anon_noexit, (void *) MB(1));\n\tcg_run_nowait(child, alloc_anon_noexit, (void *) MB(1));\n\n\tif (!cg_run(child, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_test_proc_killed(child))\n\t\tgoto cleanup;\n\tif (cg_test_proc_killed(parent))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\n\treturn ret;\n}\n\n \nstatic int test_memcg_oom_group_score_events(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *memcg;\n\tint safe_pid;\n\n\tmemcg = cg_name(root, \"memcg_test_0\");\n\n\tif (!memcg)\n\t\tgoto cleanup;\n\n\tif (cg_create(memcg))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.max\", \"50M\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.swap.max\", \"0\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(memcg, \"memory.oom.group\", \"1\"))\n\t\tgoto cleanup;\n\n\tsafe_pid = cg_run_nowait(memcg, alloc_anon_noexit, (void *) MB(1));\n\tif (set_oom_adj_score(safe_pid, OOM_SCORE_ADJ_MIN))\n\t\tgoto cleanup;\n\n\tcg_run_nowait(memcg, alloc_anon_noexit, (void *) MB(1));\n\tif (!cg_run(memcg, alloc_anon, (void *)MB(100)))\n\t\tgoto cleanup;\n\n\tif (cg_read_key_long(memcg, \"memory.events\", \"oom_kill \") != 3)\n\t\tgoto cleanup;\n\n\tif (kill(safe_pid, SIGKILL))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (memcg)\n\t\tcg_destroy(memcg);\n\tfree(memcg);\n\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct memcg_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_memcg_subtree_control),\n\tT(test_memcg_current),\n\tT(test_memcg_min),\n\tT(test_memcg_low),\n\tT(test_memcg_high),\n\tT(test_memcg_high_sync),\n\tT(test_memcg_max),\n\tT(test_memcg_reclaim),\n\tT(test_memcg_oom_events),\n\tT(test_memcg_swap_max),\n\tT(test_memcg_sock),\n\tT(test_memcg_oom_group_leaf_events),\n\tT(test_memcg_oom_group_parent_events),\n\tT(test_memcg_oom_group_score_events),\n};\n#undef T\n\nint main(int argc, char **argv)\n{\n\tchar root[PATH_MAX];\n\tint i, proc_status, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\t \n\tif (cg_read_strstr(root, \"cgroup.controllers\", \"memory\"))\n\t\tksft_exit_skip(\"memory controller isn't available\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"memory\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+memory\"))\n\t\t\tksft_exit_skip(\"Failed to set memory controller\\n\");\n\n\tproc_status = proc_mount_contains(\"memory_recursiveprot\");\n\tif (proc_status < 0)\n\t\tksft_exit_skip(\"Failed to query cgroup mount option\\n\");\n\thas_recursiveprot = proc_status;\n\n\tproc_status = proc_mount_contains(\"memory_localevents\");\n\tif (proc_status < 0)\n\t\tksft_exit_skip(\"Failed to query cgroup mount option\\n\");\n\thas_localevents = proc_status;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}