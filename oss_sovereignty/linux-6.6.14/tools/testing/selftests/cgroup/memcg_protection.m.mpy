{
  "module_name": "memcg_protection.m",
  "hash_id": "6dcfe14db1a1d20f9888902dbd8c10b7f473e97c41beef83fd196d778345dd88",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/memcg_protection.m",
  "human_readable_source": "% SPDX-License-Identifier: GPL-2.0\n%\n% run as: octave-cli memcg_protection.m\n%\n% This script simulates reclaim protection behavior on a single level of memcg\n% hierarchy to illustrate how overcommitted protection spreads among siblings\n% (as it depends also on their current consumption).\n%\n% Simulation assumes siblings consumed the initial amount of memory (w/out\n% reclaim) and then the reclaim starts, all memory is reclaimable, i.e. treated\n% same. It simulates only non-low reclaim and assumes all memory.min = 0.\n%\n% Input configurations\n% --------------------\n% E number\tparent effective protection\n% n vector\tnominal protection of siblings set at the given level (memory.low)\n% c vector\tcurrent consumption -,,- (memory.current)\n\n% example from testcase (values in GB)\nE = 50 / 1024;\nn = [75 25 0 500 ] / 1024;\nc = [50 50 50 0] / 1024;\n\n% Reclaim parameters\n% ------------------\n\n% Minimal reclaim amount (GB)\ncluster = 32*4 / 2**20;\n\n% Reclaim coefficient (think as 0.5^sc->priority)\nalpha = .1\n\n% Simulation parameters\n% ---------------------\nepsilon = 1e-7;\ntimeout = 1000;\n\n% Simulation loop\n% ---------------\n\nch = [];\neh = [];\nrh = [];\n\nfor t = 1:timeout\n        % low_usage\n        u = min(c, n);\n        siblings = sum(u);\n\n        % effective_protection()\n        protected = min(n, c);                % start with nominal\n        e = protected * min(1, E / siblings); % normalize overcommit\n\n        % recursive protection\n        unclaimed = max(0, E - siblings);\n        parent_overuse = sum(c) - siblings;\n        if (unclaimed > 0 && parent_overuse > 0)\n                overuse = max(0, c - protected);\n                e += unclaimed * (overuse / parent_overuse);\n        endif\n\n        % get_scan_count()\n        r = alpha * c;             % assume all memory is in a single LRU list\n\n        % commit 1bc63fb1272b (\"mm, memcg: make scan aggression always exclude protection\")\n        sz = max(e, c);\n        r .*= (1 - (e+epsilon) ./ (sz+epsilon));\n\n        % uncomment to debug prints\n        % e, c, r\n\n        % nothing to reclaim, reached equilibrium\n        if max(r) < epsilon\n                break;\n        endif\n\n        % SWAP_CLUSTER_MAX roundup\n        r = max(r, (r > epsilon) .* cluster);\n        % XXX here I do parallel reclaim of all siblings\n        % in reality reclaim is serialized and each sibling recalculates own residual\n        c = max(c - r, 0);\n\n        ch = [ch ; c];\n        eh = [eh ; e];\n        rh = [rh ; r];\nendfor\n\nt\nc, e\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}