{
  "module_name": "test_cpuset_prs.sh",
  "hash_id": "648e8179c61638b53260869b914f53c6cd93e3a2cf4f90a38e0016ac15294305",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_cpuset_prs.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test for cpuset v2 partition root state (PRS)\n#\n# The sched verbose flag is set, if available, so that the console log\n# can be examined for the correct setting of scheduling domain.\n#\n\nskip_test() {\n\techo \"$1\"\n\techo \"Test SKIPPED\"\n\texit 4 # ksft_skip\n}\n\n[[ $(id -u) -eq 0 ]] || skip_test \"Test must be run as root!\"\n\n\n# Get wait_inotify location\nWAIT_INOTIFY=$(cd $(dirname $0); pwd)/wait_inotify\n\n# Find cgroup v2 mount point\nCGROUP2=$(mount -t cgroup2 | head -1 | awk -e '{print $3}')\n[[ -n \"$CGROUP2\" ]] || skip_test \"Cgroup v2 mount point not found!\"\n\nCPUS=$(lscpu | grep \"^CPU(s):\" | sed -e \"s/.*:[[:space:]]*//\")\n[[ $CPUS -lt 8 ]] && skip_test \"Test needs at least 8 cpus available!\"\n\n# Set verbose flag and delay factor\nPROG=$1\nVERBOSE=\nDELAY_FACTOR=1\nSCHED_DEBUG=\nwhile [[ \"$1\" = -* ]]\ndo\n\tcase \"$1\" in\n\t\t-v) VERBOSE=1\n\t\t    # Enable sched/verbose can slow thing down\n\t\t    [[ $DELAY_FACTOR -eq 1 ]] &&\n\t\t\tDELAY_FACTOR=2\n\t\t    break\n\t\t    ;;\n\t\t-d) DELAY_FACTOR=$2\n\t\t    shift\n\t\t    break\n\t\t    ;;\n\t\t*)  echo \"Usage: $PROG [-v] [-d <delay-factor>\"\n\t\t    exit\n\t\t    ;;\n\tesac\n\tshift\ndone\n\n# Set sched verbose flag if available when \"-v\" option is specified\nif [[ -n \"$VERBOSE\" && -d /sys/kernel/debug/sched ]]\nthen\n\t# Used to restore the original setting during cleanup\n\tSCHED_DEBUG=$(cat /sys/kernel/debug/sched/verbose)\n\techo Y > /sys/kernel/debug/sched/verbose\nfi\n\ncd $CGROUP2\necho +cpuset > cgroup.subtree_control\n[[ -d test ]] || mkdir test\ncd test\n\ncleanup()\n{\n\tonline_cpus\n\trmdir A1/A2/A3 A1/A2 A1 B1 > /dev/null 2>&1\n\tcd ..\n\trmdir test > /dev/null 2>&1\n\t[[ -n \"$SCHED_DEBUG\" ]] &&\n\t\techo \"$SCHED_DEBUG\" > /sys/kernel/debug/sched/verbose\n}\n\n# Pause in ms\npause()\n{\n\tDELAY=$1\n\tLOOP=0\n\twhile [[ $LOOP -lt $DELAY_FACTOR ]]\n\tdo\n\t\tsleep $DELAY\n\t\t((LOOP++))\n\tdone\n\treturn 0\n}\n\nconsole_msg()\n{\n\tMSG=$1\n\techo \"$MSG\"\n\techo \"\" > /dev/console\n\techo \"$MSG\" > /dev/console\n\tpause 0.01\n}\n\ntest_partition()\n{\n\tEXPECTED_VAL=$1\n\techo $EXPECTED_VAL > cpuset.cpus.partition\n\t[[ $? -eq 0 ]] || exit 1\n\tACTUAL_VAL=$(cat cpuset.cpus.partition)\n\t[[ $ACTUAL_VAL != $EXPECTED_VAL ]] && {\n\t\techo \"cpuset.cpus.partition: expect $EXPECTED_VAL, found $EXPECTED_VAL\"\n\t\techo \"Test FAILED\"\n\t\texit 1\n\t}\n}\n\ntest_effective_cpus()\n{\n\tEXPECTED_VAL=$1\n\tACTUAL_VAL=$(cat cpuset.cpus.effective)\n\t[[ \"$ACTUAL_VAL\" != \"$EXPECTED_VAL\" ]] && {\n\t\techo \"cpuset.cpus.effective: expect '$EXPECTED_VAL', found '$EXPECTED_VAL'\"\n\t\techo \"Test FAILED\"\n\t\texit 1\n\t}\n}\n\n# Adding current process to cgroup.procs as a test\ntest_add_proc()\n{\n\tOUTSTR=\"$1\"\n\tERRMSG=$((echo $$ > cgroup.procs) |& cat)\n\techo $ERRMSG | grep -q \"$OUTSTR\"\n\t[[ $? -ne 0 ]] && {\n\t\techo \"cgroup.procs: expect '$OUTSTR', got '$ERRMSG'\"\n\t\techo \"Test FAILED\"\n\t\texit 1\n\t}\n\techo $$ > $CGROUP2/cgroup.procs\t# Move out the task\n}\n\n#\n# Testing the new \"isolated\" partition root type\n#\ntest_isolated()\n{\n\techo 2-3 > cpuset.cpus\n\tTYPE=$(cat cpuset.cpus.partition)\n\t[[ $TYPE = member ]] || echo member > cpuset.cpus.partition\n\n\tconsole_msg \"Change from member to root\"\n\ttest_partition root\n\n\tconsole_msg \"Change from root to isolated\"\n\ttest_partition isolated\n\n\tconsole_msg \"Change from isolated to member\"\n\ttest_partition member\n\n\tconsole_msg \"Change from member to isolated\"\n\ttest_partition isolated\n\n\tconsole_msg \"Change from isolated to root\"\n\ttest_partition root\n\n\tconsole_msg \"Change from root to member\"\n\ttest_partition member\n\n\t#\n\t# Testing partition root with no cpu\n\t#\n\tconsole_msg \"Distribute all cpus to child partition\"\n\techo +cpuset > cgroup.subtree_control\n\ttest_partition root\n\n\tmkdir A1\n\tcd A1\n\techo 2-3 > cpuset.cpus\n\ttest_partition root\n\ttest_effective_cpus 2-3\n\tcd ..\n\ttest_effective_cpus \"\"\n\n\tconsole_msg \"Moving task to partition test\"\n\ttest_add_proc \"No space left\"\n\tcd A1\n\ttest_add_proc \"\"\n\tcd ..\n\n\tconsole_msg \"Shrink and expand child partition\"\n\tcd A1\n\techo 2 > cpuset.cpus\n\tcd ..\n\ttest_effective_cpus 3\n\tcd A1\n\techo 2-3 > cpuset.cpus\n\tcd ..\n\ttest_effective_cpus \"\"\n\n\t# Cleaning up\n\tconsole_msg \"Cleaning up\"\n\techo $$ > $CGROUP2/cgroup.procs\n\t[[ -d A1 ]] && rmdir A1\n}\n\n#\n# Cpuset controller state transition test matrix.\n#\n# Cgroup test hierarchy\n#\n# test -- A1 -- A2 -- A3\n#      \\- B1\n#\n#  P<v> = set cpus.partition (0:member, 1:root, 2:isolated, -1:root invalid)\n#  C<l> = add cpu-list\n#  S<p> = use prefix in subtree_control\n#  T    = put a task into cgroup\n#  O<c>-<v> = Write <v> to CPU online file of <c>\n#\nSETUP_A123_PARTITIONS=\"C1-3:P1:S+ C2-3:P1:S+ C3:P1\"\nTEST_MATRIX=(\n\t# test  old-A1 old-A2 old-A3 old-B1 new-A1 new-A2 new-A3 new-B1 fail ECPUs Pstate\n\t# ----  ------ ------ ------ ------ ------ ------ ------ ------ ---- ----- ------\n\t\"  S+    C0-1     .      .    C2-3    S+    C4-5     .      .     0 A2:0-1\"\n\t\"  S+    C0-1     .      .    C2-3    P1      .      .      .     0 \"\n\t\"  S+    C0-1     .      .    C2-3   P1:S+ C0-1:P1   .      .     0 \"\n\t\"  S+    C0-1     .      .    C2-3   P1:S+  C1:P1    .      .     0 \"\n\t\"  S+   C0-1:S+   .      .    C2-3     .      .      .     P1     0 \"\n\t\"  S+   C0-1:P1   .      .    C2-3    S+     C1      .      .     0 \"\n\t\"  S+   C0-1:P1   .      .    C2-3    S+    C1:P1    .      .     0 \"\n\t\"  S+   C0-1:P1   .      .    C2-3    S+    C1:P1    .     P1     0 \"\n\t\"  S+   C0-1:P1   .      .    C2-3   C4-5     .      .      .     0 A1:4-5\"\n\t\"  S+   C0-1:P1   .      .    C2-3  S+:C4-5   .      .      .     0 A1:4-5\"\n\t\"  S+    C0-1     .      .   C2-3:P1   .      .      .     C2     0 \"\n\t\"  S+    C0-1     .      .   C2-3:P1   .      .      .    C4-5    0 B1:4-5\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .      .      .      .      .     0 A1:0-1,A2:2-3\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .     C1-3    .      .      .     0 A1:1,A2:2-3\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     C3      .      .      .     0 A1:,A2:3 A1:P1,A2:P1\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     C3      P0     .      .     0 A1:3,A2:3 A1:P1,A2:P0\"\n\t\"  S+ C2-3:P1:S+  C2:P1  .      .     C2-4    .      .      .     0 A1:3-4,A2:2\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     C3      .      .     C0-2   0 A1:,B1:0-2 A1:P1,A2:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .     C2-3    .      .      .     0 A1:,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\n\t# CPU offlining cases:\n\t\"  S+    C0-1     .      .    C2-3    S+    C4-5     .     O2-0   0 A1:0-1,B1:3\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .     O2-0    .      .      .     0 A1:0-1,A2:3\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .     O2-0   O2-1    .      .     0 A1:0-1,A2:2-3\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .     O1-0    .      .      .     0 A1:0,A2:2-3\"\n\t\"  S+ C0-3:P1:S+ C2-3:P1 .      .     O1-0   O1-1    .      .     0 A1:0-1,A2:2-3\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     O3-0   O3-1    .      .     0 A1:2,A2:3 A1:P1,A2:P1\"\n\t\"  S+ C2-3:P1:S+  C3:P2  .      .     O3-0   O3-1    .      .     0 A1:2,A2:3 A1:P1,A2:P2\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     O2-0   O2-1    .      .     0 A1:2,A2:3 A1:P1,A2:P1\"\n\t\"  S+ C2-3:P1:S+  C3:P2  .      .     O2-0   O2-1    .      .     0 A1:2,A2:3 A1:P1,A2:P2\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     O2-0    .      .      .     0 A1:,A2:3 A1:P1,A2:P1\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .     O3-0    .      .      .     0 A1:2,A2: A1:P1,A2:P1\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .    T:O2-0   .      .      .     0 A1:3,A2:3 A1:P1,A2:P-1\"\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .      .    T:O3-0   .      .     0 A1:2,A2:2 A1:P1,A2:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .     O1-0    .      .      .     0 A1:,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .     O2-0    .      .      .     0 A1:1,A2:,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .     O3-0    .      .      .     0 A1:1,A2:2,A3: A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .    T:O1-0   .      .      .     0 A1:2-3,A2:2-3,A3:3 A1:P1,A2:P-1,A3:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .      .    T:O2-0   .      .     0 A1:1,A2:3,A3:3 A1:P1,A2:P1,A3:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .      .      .    T:O3-0   .     0 A1:1,A2:2,A3:2 A1:P1,A2:P1,A3:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .    T:O1-0  O1-1    .      .     0 A1:1,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .      .    T:O2-0  O2-1    .     0 A1:1,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .      .      .    T:O3-0  O3-1   0 A1:1,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .    T:O1-0  O2-0   O1-1    .     0 A1:1,A2:,A3:3 A1:P1,A2:P1,A3:P1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .    T:O1-0  O2-0   O2-1    .     0 A1:2-3,A2:2-3,A3:3 A1:P1,A2:P-1,A3:P-1\"\n\n\t# test  old-A1 old-A2 old-A3 old-B1 new-A1 new-A2 new-A3 new-B1 fail ECPUs Pstate\n\t# ----  ------ ------ ------ ------ ------ ------ ------ ------ ---- ----- ------\n\t#\n\t# Incorrect change to cpuset.cpus invalidates partition root\n\t#\n\t# Adding CPUs to partition root that are not in parent's\n\t# cpuset.cpus is allowed, but those extra CPUs are ignored.\n\t\"  S+ C2-3:P1:S+ C3:P1   .      .      .     C2-4    .      .     0 A1:,A2:2-3 A1:P1,A2:P1\"\n\n\t# Taking away all CPUs from parent or itself if there are tasks\n\t# will make the partition invalid.\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .      T     C2-3    .      .     0 A1:2-3,A2:2-3 A1:P1,A2:P-1\"\n\t\"  S+  C3:P1:S+    C3    .      .      T      P1     .      .     0 A1:3,A2:3 A1:P1,A2:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .    T:C2-3   .      .      .     0 A1:2-3,A2:2-3,A3:3 A1:P1,A2:P-1,A3:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    . T:C2-3:C1-3 .      .      .     0 A1:1,A2:2,A3:3 A1:P1,A2:P1,A3:P1\"\n\n\t# Changing a partition root to member makes child partitions invalid\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .      P0     .      .      .     0 A1:2-3,A2:3 A1:P0,A2:P-1\"\n\t\"  S+ $SETUP_A123_PARTITIONS    .     C2-3    P0     .      .     0 A1:2-3,A2:2-3,A3:3 A1:P1,A2:P0,A3:P-1\"\n\n\t# cpuset.cpus can contains cpus not in parent's cpuset.cpus as long\n\t# as they overlap.\n\t\"  S+ C2-3:P1:S+  .      .      .      .   C3-4:P1   .      .     0 A1:2,A2:3 A1:P1,A2:P1\"\n\n\t# Deletion of CPUs distributed to child cgroup is allowed.\n\t\"  S+ C0-1:P1:S+ C1      .    C2-3   C4-5     .      .      .     0 A1:4-5,A2:4-5\"\n\n\t# To become a valid partition root, cpuset.cpus must overlap parent's\n\t# cpuset.cpus.\n\t\"  S+   C0-1:P1   .      .    C2-3    S+   C4-5:P1   .      .     0 A1:0-1,A2:0-1 A1:P1,A2:P-1\"\n\n\t# Enabling partition with child cpusets is allowed\n\t\"  S+   C0-1:S+  C1      .    C2-3    P1      .      .      .     0 A1:0-1,A2:1 A1:P1\"\n\n\t# A partition root with non-partition root parent is invalid, but it\n\t# can be made valid if its parent becomes a partition root too.\n\t\"  S+   C0-1:S+  C1      .    C2-3     .      P2     .      .     0 A1:0-1,A2:1 A1:P0,A2:P-2\"\n\t\"  S+   C0-1:S+ C1:P2    .    C2-3     P1     .      .      .     0 A1:0,A2:1 A1:P1,A2:P2\"\n\n\t# A non-exclusive cpuset.cpus change will invalidate partition and its siblings\n\t\"  S+   C0-1:P1   .      .    C2-3   C0-2     .      .      .     0 A1:0-2,B1:2-3 A1:P-1,B1:P0\"\n\t\"  S+   C0-1:P1   .      .  P1:C2-3  C0-2   .      .      .     0 A1:0-2,B1:2-3 A1:P-1,B1:P-1\"\n\t\"  S+    C0-1     .      .  P1:C2-3  C0-2   .      .      .     0 A1:0-2,B1:2-3 A1:P0,B1:P-1\"\n\n\t# test  old-A1 old-A2 old-A3 old-B1 new-A1 new-A2 new-A3 new-B1 fail ECPUs Pstate\n\t# ----  ------ ------ ------ ------ ------ ------ ------ ------ ---- ----- ------\n\t# Failure cases:\n\n\t# A task cannot be added to a partition with no cpu\n\t\"  S+ C2-3:P1:S+  C3:P1  .      .    O2-0:T   .      .      .     1 A1:,A2:3 A1:P1,A2:P1\"\n)\n\n#\n# Write to the cpu online file\n#  $1 - <c>-<v> where <c> = cpu number, <v> value to be written\n#\nwrite_cpu_online()\n{\n\tCPU=${1%-*}\n\tVAL=${1#*-}\n\tCPUFILE=//sys/devices/system/cpu/cpu${CPU}/online\n\tif [[ $VAL -eq 0 ]]\n\tthen\n\t\tOFFLINE_CPUS=\"$OFFLINE_CPUS $CPU\"\n\telse\n\t\t[[ -n \"$OFFLINE_CPUS\" ]] && {\n\t\t\tOFFLINE_CPUS=$(echo $CPU $CPU $OFFLINE_CPUS | fmt -1 |\\\n\t\t\t\t\tsort | uniq -u)\n\t\t}\n\tfi\n\techo $VAL > $CPUFILE\n\tpause 0.01\n}\n\n#\n# Set controller state\n#  $1 - cgroup directory\n#  $2 - state\n#  $3 - showerr\n#\n# The presence of \":\" in state means transition from one to the next.\n#\nset_ctrl_state()\n{\n\tTMPMSG=/tmp/.msg_$$\n\tCGRP=$1\n\tSTATE=$2\n\tSHOWERR=${3}${VERBOSE}\n\tCTRL=${CTRL:=$CONTROLLER}\n\tHASERR=0\n\tREDIRECT=\"2> $TMPMSG\"\n\t[[ -z \"$STATE\" || \"$STATE\" = '.' ]] && return 0\n\n\trm -f $TMPMSG\n\tfor CMD in $(echo $STATE | sed -e \"s/:/ /g\")\n\tdo\n\t\tTFILE=$CGRP/cgroup.procs\n\t\tSFILE=$CGRP/cgroup.subtree_control\n\t\tPFILE=$CGRP/cpuset.cpus.partition\n\t\tCFILE=$CGRP/cpuset.cpus\n\t\tS=$(expr substr $CMD 1 1)\n\t\tif [[ $S = S ]]\n\t\tthen\n\t\t\tPREFIX=${CMD#?}\n\t\t\tCOMM=\"echo ${PREFIX}${CTRL} > $SFILE\"\n\t\t\teval $COMM $REDIRECT\n\t\telif [[ $S = C ]]\n\t\tthen\n\t\t\tCPUS=${CMD#?}\n\t\t\tCOMM=\"echo $CPUS > $CFILE\"\n\t\t\teval $COMM $REDIRECT\n\t\telif [[ $S = P ]]\n\t\tthen\n\t\t\tVAL=${CMD#?}\n\t\t\tcase $VAL in\n\t\t\t0)  VAL=member\n\t\t\t    ;;\n\t\t\t1)  VAL=root\n\t\t\t    ;;\n\t\t\t2)  VAL=isolated\n\t\t\t    ;;\n\t\t\t*)\n\t\t\t    echo \"Invalid partition state - $VAL\"\n\t\t\t    exit 1\n\t\t\t    ;;\n\t\t\tesac\n\t\t\tCOMM=\"echo $VAL > $PFILE\"\n\t\t\teval $COMM $REDIRECT\n\t\telif [[ $S = O ]]\n\t\tthen\n\t\t\tVAL=${CMD#?}\n\t\t\twrite_cpu_online $VAL\n\t\telif [[ $S = T ]]\n\t\tthen\n\t\t\tCOMM=\"echo 0 > $TFILE\"\n\t\t\teval $COMM $REDIRECT\n\t\tfi\n\t\tRET=$?\n\t\t[[ $RET -ne 0 ]] && {\n\t\t\t[[ -n \"$SHOWERR\" ]] && {\n\t\t\t\techo \"$COMM\"\n\t\t\t\tcat $TMPMSG\n\t\t\t}\n\t\t\tHASERR=1\n\t\t}\n\t\tpause 0.01\n\t\trm -f $TMPMSG\n\tdone\n\treturn $HASERR\n}\n\nset_ctrl_state_noerr()\n{\n\tCGRP=$1\n\tSTATE=$2\n\t[[ -d $CGRP ]] || mkdir $CGRP\n\tset_ctrl_state $CGRP $STATE 1\n\t[[ $? -ne 0 ]] && {\n\t\techo \"ERROR: Failed to set $2 to cgroup $1!\"\n\t\texit 1\n\t}\n}\n\nonline_cpus()\n{\n\t[[ -n \"OFFLINE_CPUS\" ]] && {\n\t\tfor C in $OFFLINE_CPUS\n\t\tdo\n\t\t\twrite_cpu_online ${C}-1\n\t\tdone\n\t}\n}\n\n#\n# Return 1 if the list of effective cpus isn't the same as the initial list.\n#\nreset_cgroup_states()\n{\n\techo 0 > $CGROUP2/cgroup.procs\n\tonline_cpus\n\trmdir A1/A2/A3 A1/A2 A1 B1 > /dev/null 2>&1\n\tset_ctrl_state . S-\n\tpause 0.01\n}\n\ndump_states()\n{\n\tfor DIR in A1 A1/A2 A1/A2/A3 B1\n\tdo\n\t\tECPUS=$DIR/cpuset.cpus.effective\n\t\tPRS=$DIR/cpuset.cpus.partition\n\t\t[[ -e $ECPUS ]] && echo \"$ECPUS: $(cat $ECPUS)\"\n\t\t[[ -e $PRS   ]] && echo \"$PRS: $(cat $PRS)\"\n\tdone\n}\n\n#\n# Check effective cpus\n# $1 - check string, format: <cgroup>:<cpu-list>[,<cgroup>:<cpu-list>]*\n#\ncheck_effective_cpus()\n{\n\tCHK_STR=$1\n\tfor CHK in $(echo $CHK_STR | sed -e \"s/,/ /g\")\n\tdo\n\t\tset -- $(echo $CHK | sed -e \"s/:/ /g\")\n\t\tCGRP=$1\n\t\tCPUS=$2\n\t\t[[ $CGRP = A2 ]] && CGRP=A1/A2\n\t\t[[ $CGRP = A3 ]] && CGRP=A1/A2/A3\n\t\tFILE=$CGRP/cpuset.cpus.effective\n\t\t[[ -e $FILE ]] || return 1\n\t\t[[ $CPUS = $(cat $FILE) ]] || return 1\n\tdone\n}\n\n#\n# Check cgroup states\n#  $1 - check string, format: <cgroup>:<state>[,<cgroup>:<state>]*\n#\ncheck_cgroup_states()\n{\n\tCHK_STR=$1\n\tfor CHK in $(echo $CHK_STR | sed -e \"s/,/ /g\")\n\tdo\n\t\tset -- $(echo $CHK | sed -e \"s/:/ /g\")\n\t\tCGRP=$1\n\t\tSTATE=$2\n\t\tFILE=\n\t\tEVAL=$(expr substr $STATE 2 2)\n\t\t[[ $CGRP = A2 ]] && CGRP=A1/A2\n\t\t[[ $CGRP = A3 ]] && CGRP=A1/A2/A3\n\n\t\tcase $STATE in\n\t\t\tP*) FILE=$CGRP/cpuset.cpus.partition\n\t\t\t    ;;\n\t\t\t*)  echo \"Unknown state: $STATE!\"\n\t\t\t    exit 1\n\t\t\t    ;;\n\t\tesac\n\t\tVAL=$(cat $FILE)\n\n\t\tcase \"$VAL\" in\n\t\t\tmember) VAL=0\n\t\t\t\t;;\n\t\t\troot)\tVAL=1\n\t\t\t\t;;\n\t\t\tisolated)\n\t\t\t\tVAL=2\n\t\t\t\t;;\n\t\t\t\"root invalid\"*)\n\t\t\t\tVAL=-1\n\t\t\t\t;;\n\t\t\t\"isolated invalid\"*)\n\t\t\t\tVAL=-2\n\t\t\t\t;;\n\t\tesac\n\t\t[[ $EVAL != $VAL ]] && return 1\n\tdone\n\treturn 0\n}\n\n#\n# Run cpuset state transition test\n#  $1 - test matrix name\n#\n# This test is somewhat fragile as delays (sleep x) are added in various\n# places to make sure state changes are fully propagated before the next\n# action. These delays may need to be adjusted if running in a slower machine.\n#\nrun_state_test()\n{\n\tTEST=$1\n\tCONTROLLER=cpuset\n\tCPULIST=0-6\n\tI=0\n\teval CNT=\"\\${#$TEST[@]}\"\n\n\treset_cgroup_states\n\techo $CPULIST > cpuset.cpus\n\techo root > cpuset.cpus.partition\n\tconsole_msg \"Running state transition test ...\"\n\n\twhile [[ $I -lt $CNT ]]\n\tdo\n\t\techo \"Running test $I ...\" > /dev/console\n\t\teval set -- \"\\${$TEST[$I]}\"\n\t\tROOT=$1\n\t\tOLD_A1=$2\n\t\tOLD_A2=$3\n\t\tOLD_A3=$4\n\t\tOLD_B1=$5\n\t\tNEW_A1=$6\n\t\tNEW_A2=$7\n\t\tNEW_A3=$8\n\t\tNEW_B1=$9\n\t\tRESULT=${10}\n\t\tECPUS=${11}\n\t\tSTATES=${12}\n\n\t\tset_ctrl_state_noerr .        $ROOT\n\t\tset_ctrl_state_noerr A1       $OLD_A1\n\t\tset_ctrl_state_noerr A1/A2    $OLD_A2\n\t\tset_ctrl_state_noerr A1/A2/A3 $OLD_A3\n\t\tset_ctrl_state_noerr B1       $OLD_B1\n\t\tRETVAL=0\n\t\tset_ctrl_state A1       $NEW_A1; ((RETVAL += $?))\n\t\tset_ctrl_state A1/A2    $NEW_A2; ((RETVAL += $?))\n\t\tset_ctrl_state A1/A2/A3 $NEW_A3; ((RETVAL += $?))\n\t\tset_ctrl_state B1       $NEW_B1; ((RETVAL += $?))\n\n\t\t[[ $RETVAL -ne $RESULT ]] && {\n\t\t\techo \"Test $TEST[$I] failed result check!\"\n\t\t\teval echo \\\"\\${$TEST[$I]}\\\"\n\t\t\tdump_states\n\t\t\texit 1\n\t\t}\n\n\t\t[[ -n \"$ECPUS\" && \"$ECPUS\" != . ]] && {\n\t\t\tcheck_effective_cpus $ECPUS\n\t\t\t[[ $? -ne 0 ]] && {\n\t\t\t\techo \"Test $TEST[$I] failed effective CPU check!\"\n\t\t\t\teval echo \\\"\\${$TEST[$I]}\\\"\n\t\t\t\techo\n\t\t\t\tdump_states\n\t\t\t\texit 1\n\t\t\t}\n\t\t}\n\n\t\t[[ -n \"$STATES\" ]] && {\n\t\t\tcheck_cgroup_states $STATES\n\t\t\t[[ $? -ne 0 ]] && {\n\t\t\t\techo \"FAILED: Test $TEST[$I] failed states check!\"\n\t\t\t\teval echo \\\"\\${$TEST[$I]}\\\"\n\t\t\t\techo\n\t\t\t\tdump_states\n\t\t\t\texit 1\n\t\t\t}\n\t\t}\n\n\t\treset_cgroup_states\n\t\t#\n\t\t# Check to see if effective cpu list changes\n\t\t#\n\t\tpause 0.05\n\t\tNEWLIST=$(cat cpuset.cpus.effective)\n\t\t[[ $NEWLIST != $CPULIST ]] && {\n\t\t\techo \"Effective cpus changed to $NEWLIST after test $I!\"\n\t\t\texit 1\n\t\t}\n\t\t[[ -n \"$VERBOSE\" ]] && echo \"Test $I done.\"\n\t\t((I++))\n\tdone\n\techo \"All $I tests of $TEST PASSED.\"\n\n\techo member > cpuset.cpus.partition\n}\n\n#\n# Wait for inotify event for the given file and read it\n# $1: cgroup file to wait for\n# $2: file to store the read result\n#\nwait_inotify()\n{\n\tCGROUP_FILE=$1\n\tOUTPUT_FILE=$2\n\n\t$WAIT_INOTIFY $CGROUP_FILE\n\tcat $CGROUP_FILE > $OUTPUT_FILE\n}\n\n#\n# Test if inotify events are properly generated when going into and out of\n# invalid partition state.\n#\ntest_inotify()\n{\n\tERR=0\n\tPRS=/tmp/.prs_$$\n\t[[ -f $WAIT_INOTIFY ]] || {\n\t\techo \"wait_inotify not found, inotify test SKIPPED.\"\n\t\treturn\n\t}\n\n\tpause 0.01\n\techo 1 > cpuset.cpus\n\techo 0 > cgroup.procs\n\techo root > cpuset.cpus.partition\n\tpause 0.01\n\trm -f $PRS\n\twait_inotify $PWD/cpuset.cpus.partition $PRS &\n\tpause 0.01\n\tset_ctrl_state . \"O1-0\"\n\tpause 0.01\n\tcheck_cgroup_states \".:P-1\"\n\tif [[ $? -ne 0 ]]\n\tthen\n\t\techo \"FAILED: Inotify test - partition not invalid\"\n\t\tERR=1\n\telif [[ ! -f $PRS ]]\n\tthen\n\t\techo \"FAILED: Inotify test - event not generated\"\n\t\tERR=1\n\t\tkill %1\n\telif [[ $(cat $PRS) != \"root invalid\"* ]]\n\tthen\n\t\techo \"FAILED: Inotify test - incorrect state\"\n\t\tcat $PRS\n\t\tERR=1\n\tfi\n\tonline_cpus\n\techo member > cpuset.cpus.partition\n\techo 0 > ../cgroup.procs\n\tif [[ $ERR -ne 0 ]]\n\tthen\n\t\texit 1\n\telse\n\t\techo \"Inotify test PASSED\"\n\tfi\n}\n\ntrap cleanup 0 2 3 6\nrun_state_test TEST_MATRIX\ntest_isolated\ntest_inotify\necho \"All tests PASSED.\"\ncd ..\nrmdir test\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}