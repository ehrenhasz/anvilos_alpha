{
  "module_name": "cgroup_util.c",
  "hash_id": "483c35e1c7eb48093624551a42d73f8401c8979eb547b7ebee0ae75e10057510",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/cgroup_util.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/limits.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"cgroup_util.h\"\n#include \"../clone3/clone3_selftests.h\"\n\n \nstatic ssize_t read_text(const char *path, char *buf, size_t max_len)\n{\n\tssize_t len;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tlen = read(fd, buf, max_len - 1);\n\n\tif (len >= 0)\n\t\tbuf[len] = 0;\n\n\tclose(fd);\n\treturn len < 0 ? -errno : len;\n}\n\n \nstatic ssize_t write_text(const char *path, char *buf, ssize_t len)\n{\n\tint fd;\n\n\tfd = open(path, O_WRONLY | O_APPEND);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tlen = write(fd, buf, len);\n\tclose(fd);\n\treturn len < 0 ? -errno : len;\n}\n\nchar *cg_name(const char *root, const char *name)\n{\n\tsize_t len = strlen(root) + strlen(name) + 2;\n\tchar *ret = malloc(len);\n\n\tsnprintf(ret, len, \"%s/%s\", root, name);\n\n\treturn ret;\n}\n\nchar *cg_name_indexed(const char *root, const char *name, int index)\n{\n\tsize_t len = strlen(root) + strlen(name) + 10;\n\tchar *ret = malloc(len);\n\n\tsnprintf(ret, len, \"%s/%s_%d\", root, name, index);\n\n\treturn ret;\n}\n\nchar *cg_control(const char *cgroup, const char *control)\n{\n\tsize_t len = strlen(cgroup) + strlen(control) + 2;\n\tchar *ret = malloc(len);\n\n\tsnprintf(ret, len, \"%s/%s\", cgroup, control);\n\n\treturn ret;\n}\n\n \nint cg_read(const char *cgroup, const char *control, char *buf, size_t len)\n{\n\tchar path[PATH_MAX];\n\tssize_t ret;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", cgroup, control);\n\n\tret = read_text(path, buf, len);\n\treturn ret >= 0 ? 0 : ret;\n}\n\nint cg_read_strcmp(const char *cgroup, const char *control,\n\t\t   const char *expected)\n{\n\tsize_t size;\n\tchar *buf;\n\tint ret;\n\n\t \n\tif (!expected)\n\t\treturn -1;\n\telse\n\t\tsize = strlen(expected) + 1;\n\n\tbuf = malloc(size);\n\tif (!buf)\n\t\treturn -1;\n\n\tif (cg_read(cgroup, control, buf, size)) {\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\n\tret = strcmp(expected, buf);\n\tfree(buf);\n\treturn ret;\n}\n\nint cg_read_strstr(const char *cgroup, const char *control, const char *needle)\n{\n\tchar buf[PAGE_SIZE];\n\n\tif (cg_read(cgroup, control, buf, sizeof(buf)))\n\t\treturn -1;\n\n\treturn strstr(buf, needle) ? 0 : -1;\n}\n\nlong cg_read_long(const char *cgroup, const char *control)\n{\n\tchar buf[128];\n\n\tif (cg_read(cgroup, control, buf, sizeof(buf)))\n\t\treturn -1;\n\n\treturn atol(buf);\n}\n\nlong cg_read_key_long(const char *cgroup, const char *control, const char *key)\n{\n\tchar buf[PAGE_SIZE];\n\tchar *ptr;\n\n\tif (cg_read(cgroup, control, buf, sizeof(buf)))\n\t\treturn -1;\n\n\tptr = strstr(buf, key);\n\tif (!ptr)\n\t\treturn -1;\n\n\treturn atol(ptr + strlen(key));\n}\n\nlong cg_read_lc(const char *cgroup, const char *control)\n{\n\tchar buf[PAGE_SIZE];\n\tconst char delim[] = \"\\n\";\n\tchar *line;\n\tlong cnt = 0;\n\n\tif (cg_read(cgroup, control, buf, sizeof(buf)))\n\t\treturn -1;\n\n\tfor (line = strtok(buf, delim); line; line = strtok(NULL, delim))\n\t\tcnt++;\n\n\treturn cnt;\n}\n\n \nint cg_write(const char *cgroup, const char *control, char *buf)\n{\n\tchar path[PATH_MAX];\n\tssize_t len = strlen(buf), ret;\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", cgroup, control);\n\tret = write_text(path, buf, len);\n\treturn ret == len ? 0 : ret;\n}\n\nint cg_write_numeric(const char *cgroup, const char *control, long value)\n{\n\tchar buf[64];\n\tint ret;\n\n\tret = sprintf(buf, \"%lu\", value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn cg_write(cgroup, control, buf);\n}\n\nint cg_find_unified_root(char *root, size_t len)\n{\n\tchar buf[10 * PAGE_SIZE];\n\tchar *fs, *mount, *type;\n\tconst char delim[] = \"\\n\\t \";\n\n\tif (read_text(\"/proc/self/mounts\", buf, sizeof(buf)) <= 0)\n\t\treturn -1;\n\n\t \n\tfor (fs = strtok(buf, delim); fs; fs = strtok(NULL, delim)) {\n\t\tmount = strtok(NULL, delim);\n\t\ttype = strtok(NULL, delim);\n\t\tstrtok(NULL, delim);\n\t\tstrtok(NULL, delim);\n\t\tstrtok(NULL, delim);\n\n\t\tif (strcmp(type, \"cgroup2\") == 0) {\n\t\t\tstrncpy(root, mount, len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint cg_create(const char *cgroup)\n{\n\treturn mkdir(cgroup, 0755);\n}\n\nint cg_wait_for_proc_count(const char *cgroup, int count)\n{\n\tchar buf[10 * PAGE_SIZE] = {0};\n\tint attempts;\n\tchar *ptr;\n\n\tfor (attempts = 10; attempts >= 0; attempts--) {\n\t\tint nr = 0;\n\n\t\tif (cg_read(cgroup, \"cgroup.procs\", buf, sizeof(buf)))\n\t\t\tbreak;\n\n\t\tfor (ptr = buf; *ptr; ptr++)\n\t\t\tif (*ptr == '\\n')\n\t\t\t\tnr++;\n\n\t\tif (nr >= count)\n\t\t\treturn 0;\n\n\t\tusleep(100000);\n\t}\n\n\treturn -1;\n}\n\nint cg_killall(const char *cgroup)\n{\n\tchar buf[PAGE_SIZE];\n\tchar *ptr = buf;\n\n\t \n\tif (!cg_write(cgroup, \"cgroup.kill\", \"1\"))\n\t\treturn 0;\n\n\tif (cg_read(cgroup, \"cgroup.procs\", buf, sizeof(buf)))\n\t\treturn -1;\n\n\twhile (ptr < buf + sizeof(buf)) {\n\t\tint pid = strtol(ptr, &ptr, 10);\n\n\t\tif (pid == 0)\n\t\t\tbreak;\n\t\tif (*ptr)\n\t\t\tptr++;\n\t\telse\n\t\t\tbreak;\n\t\tif (kill(pid, SIGKILL))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint cg_destroy(const char *cgroup)\n{\n\tint ret;\n\n\tif (!cgroup)\n\t\treturn 0;\nretry:\n\tret = rmdir(cgroup);\n\tif (ret && errno == EBUSY) {\n\t\tcg_killall(cgroup);\n\t\tusleep(100);\n\t\tgoto retry;\n\t}\n\n\tif (ret && errno == ENOENT)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nint cg_enter(const char *cgroup, int pid)\n{\n\tchar pidbuf[64];\n\n\tsnprintf(pidbuf, sizeof(pidbuf), \"%d\", pid);\n\treturn cg_write(cgroup, \"cgroup.procs\", pidbuf);\n}\n\nint cg_enter_current(const char *cgroup)\n{\n\treturn cg_write(cgroup, \"cgroup.procs\", \"0\");\n}\n\nint cg_enter_current_thread(const char *cgroup)\n{\n\treturn cg_write(cgroup, \"cgroup.threads\", \"0\");\n}\n\nint cg_run(const char *cgroup,\n\t   int (*fn)(const char *cgroup, void *arg),\n\t   void *arg)\n{\n\tint pid, retcode;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn pid;\n\t} else if (pid == 0) {\n\t\tchar buf[64];\n\n\t\tsnprintf(buf, sizeof(buf), \"%d\", getpid());\n\t\tif (cg_write(cgroup, \"cgroup.procs\", buf))\n\t\t\texit(EXIT_FAILURE);\n\t\texit(fn(cgroup, arg));\n\t} else {\n\t\twaitpid(pid, &retcode, 0);\n\t\tif (WIFEXITED(retcode))\n\t\t\treturn WEXITSTATUS(retcode);\n\t\telse\n\t\t\treturn -1;\n\t}\n}\n\npid_t clone_into_cgroup(int cgroup_fd)\n{\n#ifdef CLONE_ARGS_SIZE_VER2\n\tpid_t pid;\n\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_INTO_CGROUP,\n\t\t.exit_signal = SIGCHLD,\n\t\t.cgroup = cgroup_fd,\n\t};\n\n\tpid = sys_clone3(&args, sizeof(struct __clone_args));\n\t \n\tif (pid < 0 && (errno == ENOSYS || errno == E2BIG))\n\t\tgoto pretend_enosys;\n\n\treturn pid;\n\npretend_enosys:\n#endif\n\terrno = ENOSYS;\n\treturn -ENOSYS;\n}\n\nint clone_reap(pid_t pid, int options)\n{\n\tint ret;\n\tsiginfo_t info = {\n\t\t.si_signo = 0,\n\t};\n\nagain:\n\tret = waitid(P_PID, pid, &info, options | __WALL | __WNOTHREAD);\n\tif (ret < 0) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\n\tif (options & WEXITED) {\n\t\tif (WIFEXITED(info.si_status))\n\t\t\treturn WEXITSTATUS(info.si_status);\n\t}\n\n\tif (options & WSTOPPED) {\n\t\tif (WIFSTOPPED(info.si_status))\n\t\t\treturn WSTOPSIG(info.si_status);\n\t}\n\n\tif (options & WCONTINUED) {\n\t\tif (WIFCONTINUED(info.si_status))\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nint dirfd_open_opath(const char *dir)\n{\n\treturn open(dir, O_DIRECTORY | O_CLOEXEC | O_NOFOLLOW | O_PATH);\n}\n\n#define close_prot_errno(fd)                                                   \\\n\tif (fd >= 0) {                                                         \\\n\t\tint _e_ = errno;                                               \\\n\t\tclose(fd);                                                     \\\n\t\terrno = _e_;                                                   \\\n\t}\n\nstatic int clone_into_cgroup_run_nowait(const char *cgroup,\n\t\t\t\t\tint (*fn)(const char *cgroup, void *arg),\n\t\t\t\t\tvoid *arg)\n{\n\tint cgroup_fd;\n\tpid_t pid;\n\n\tcgroup_fd =  dirfd_open_opath(cgroup);\n\tif (cgroup_fd < 0)\n\t\treturn -1;\n\n\tpid = clone_into_cgroup(cgroup_fd);\n\tclose_prot_errno(cgroup_fd);\n\tif (pid == 0)\n\t\texit(fn(cgroup, arg));\n\n\treturn pid;\n}\n\nint cg_run_nowait(const char *cgroup,\n\t\t  int (*fn)(const char *cgroup, void *arg),\n\t\t  void *arg)\n{\n\tint pid;\n\n\tpid = clone_into_cgroup_run_nowait(cgroup, fn, arg);\n\tif (pid > 0)\n\t\treturn pid;\n\n\t \n\tif (pid < 0 && errno != ENOSYS)\n\t\treturn -1;\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tchar buf[64];\n\n\t\tsnprintf(buf, sizeof(buf), \"%d\", getpid());\n\t\tif (cg_write(cgroup, \"cgroup.procs\", buf))\n\t\t\texit(EXIT_FAILURE);\n\t\texit(fn(cgroup, arg));\n\t}\n\n\treturn pid;\n}\n\nint get_temp_fd(void)\n{\n\treturn open(\".\", O_TMPFILE | O_RDWR | O_EXCL);\n}\n\nint alloc_pagecache(int fd, size_t size)\n{\n\tchar buf[PAGE_SIZE];\n\tstruct stat st;\n\tint i;\n\n\tif (fstat(fd, &st))\n\t\tgoto cleanup;\n\n\tsize += st.st_size;\n\n\tif (ftruncate(fd, size))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < size; i += sizeof(buf))\n\t\tread(fd, buf, sizeof(buf));\n\n\treturn 0;\n\ncleanup:\n\treturn -1;\n}\n\nint alloc_anon(const char *cgroup, void *arg)\n{\n\tsize_t size = (unsigned long)arg;\n\tchar *buf, *ptr;\n\n\tbuf = malloc(size);\n\tfor (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)\n\t\t*ptr = 0;\n\n\tfree(buf);\n\treturn 0;\n}\n\nint is_swap_enabled(void)\n{\n\tchar buf[PAGE_SIZE];\n\tconst char delim[] = \"\\n\";\n\tint cnt = 0;\n\tchar *line;\n\n\tif (read_text(\"/proc/swaps\", buf, sizeof(buf)) <= 0)\n\t\treturn -1;\n\n\tfor (line = strtok(buf, delim); line; line = strtok(NULL, delim))\n\t\tcnt++;\n\n\treturn cnt > 1;\n}\n\nint set_oom_adj_score(int pid, int score)\n{\n\tchar path[PATH_MAX];\n\tint fd, len;\n\n\tsprintf(path, \"/proc/%d/oom_score_adj\", pid);\n\n\tfd = open(path, O_WRONLY | O_APPEND);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tlen = dprintf(fd, \"%d\", score);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn len;\n\t}\n\n\tclose(fd);\n\treturn 0;\n}\n\nint proc_mount_contains(const char *option)\n{\n\tchar buf[4 * PAGE_SIZE];\n\tssize_t read;\n\n\tread = read_text(\"/proc/mounts\", buf, sizeof(buf));\n\tif (read < 0)\n\t\treturn read;\n\n\treturn strstr(buf, option) != NULL;\n}\n\nssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size)\n{\n\tchar path[PATH_MAX];\n\tssize_t ret;\n\n\tif (!pid)\n\t\tsnprintf(path, sizeof(path), \"/proc/%s/%s\",\n\t\t\t thread ? \"thread-self\" : \"self\", item);\n\telse\n\t\tsnprintf(path, sizeof(path), \"/proc/%d/%s\", pid, item);\n\n\tret = read_text(path, buf, size);\n\treturn ret < 0 ? -1 : ret;\n}\n\nint proc_read_strstr(int pid, bool thread, const char *item, const char *needle)\n{\n\tchar buf[PAGE_SIZE];\n\n\tif (proc_read_text(pid, thread, item, buf, sizeof(buf)) < 0)\n\t\treturn -1;\n\n\treturn strstr(buf, needle) ? 0 : -1;\n}\n\nint clone_into_cgroup_run_wait(const char *cgroup)\n{\n\tint cgroup_fd;\n\tpid_t pid;\n\n\tcgroup_fd =  dirfd_open_opath(cgroup);\n\tif (cgroup_fd < 0)\n\t\treturn -1;\n\n\tpid = clone_into_cgroup(cgroup_fd);\n\tclose_prot_errno(cgroup_fd);\n\tif (pid < 0)\n\t\treturn -1;\n\n\tif (pid == 0)\n\t\texit(EXIT_SUCCESS);\n\n\t \n\t(void)clone_reap(pid, WEXITED);\n\treturn 0;\n}\n\nstatic int __prepare_for_wait(const char *cgroup, const char *filename)\n{\n\tint fd, ret = -1;\n\n\tfd = inotify_init1(0);\n\tif (fd == -1)\n\t\treturn fd;\n\n\tret = inotify_add_watch(fd, cg_control(cgroup, filename), IN_MODIFY);\n\tif (ret == -1) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\treturn fd;\n}\n\nint cg_prepare_for_wait(const char *cgroup)\n{\n\treturn __prepare_for_wait(cgroup, \"cgroup.events\");\n}\n\nint memcg_prepare_for_wait(const char *cgroup)\n{\n\treturn __prepare_for_wait(cgroup, \"memory.events\");\n}\n\nint cg_wait_for(int fd)\n{\n\tint ret = -1;\n\tstruct pollfd fds = {\n\t\t.fd = fd,\n\t\t.events = POLLIN,\n\t};\n\n\twhile (true) {\n\t\tret = poll(&fds, 1, 10000);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret > 0 && fds.revents & POLLIN) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}