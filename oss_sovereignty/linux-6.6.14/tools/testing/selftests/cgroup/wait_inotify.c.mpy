{
  "module_name": "wait_inotify.c",
  "hash_id": "e293c5cd21fe3bd50c14ddae80083dfdc85679ce6320b12b0e494751213e7e9c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/wait_inotify.c",
  "human_readable_source": "\n \n#include <linux/limits.h>\n#include <sys/inotify.h>\n#include <sys/mman.h>\n#include <sys/ptrace.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nstatic const char usage[] = \"Usage: %s [-v] <cgroup_file>\\n\";\nstatic char *file;\nstatic int verbose;\n\nstatic inline void fail_message(char *msg)\n{\n\tfprintf(stderr, msg, file);\n\texit(1);\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *cmd = argv[0];\n\tint c, fd;\n\tstruct pollfd fds = { .events = POLLIN, };\n\n\twhile ((c = getopt(argc, argv, \"v\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\t}\n\t\targv++, argc--;\n\t}\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, usage, cmd);\n\t\treturn -1;\n\t}\n\tfile = argv[1];\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0)\n\t\tfail_message(\"Cgroup file %s not found!\\n\");\n\tclose(fd);\n\n\tfd = inotify_init();\n\tif (fd < 0)\n\t\tfail_message(\"inotify_init() fails on %s!\\n\");\n\tif (inotify_add_watch(fd, file, IN_MODIFY) < 0)\n\t\tfail_message(\"inotify_add_watch() fails on %s!\\n\");\n\tfds.fd = fd;\n\n\t \n\tfor (;;) {\n\t\tint ret = poll(&fds, 1, 10000);\n\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"poll\");\n\t\t\texit(1);\n\t\t}\n\t\tif ((ret > 0) && (fds.revents & POLLIN))\n\t\t\tbreak;\n\t}\n\tif (verbose) {\n\t\tstruct inotify_event events[10];\n\t\tlong len;\n\n\t\tusleep(1000);\n\t\tlen = read(fd, events, sizeof(events));\n\t\tprintf(\"Number of events read = %ld\\n\",\n\t\t\tlen/sizeof(struct inotify_event));\n\t}\n\tclose(fd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}