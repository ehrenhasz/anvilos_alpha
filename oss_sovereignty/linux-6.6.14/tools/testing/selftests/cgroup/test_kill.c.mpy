{
  "module_name": "test_kill.c",
  "hash_id": "5432c515b31f37027568b0c1ee17adcf730dd772d28eb539b70299b6cf943ab0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_kill.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <linux/limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n#include \"../pidfd/pidfd.h\"\n#include \"cgroup_util.h\"\n\n \nstatic int cg_kill_wait(const char *cgroup)\n{\n\tint fd, ret = -1;\n\n\tfd = cg_prepare_for_wait(cgroup);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = cg_write(cgroup, \"cgroup.kill\", \"1\");\n\tif (ret)\n\t\tgoto out;\n\n\tret = cg_wait_for(fd);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\n \nstatic int child_fn(const char *cgroup, void *arg)\n{\n\tint ppid = getppid();\n\n\twhile (getppid() == ppid)\n\t\tusleep(1000);\n\n\treturn getppid() == ppid;\n}\n\nstatic int test_cgkill_simple(const char *root)\n{\n\tpid_t pids[100];\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\tint i;\n\n\tcgroup = cg_name(root, \"cg_test_simple\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 100; i++)\n\t\tpids[i] = cg_run_nowait(cgroup, child_fn, NULL);\n\n\tif (cg_wait_for_proc_count(cgroup, 100))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cgroup, \"cgroup.events\", \"populated 1\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_kill_wait(cgroup))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tfor (i = 0; i < 100; i++)\n\t\twait_for_pid(pids[i]);\n\n\tif (ret == KSFT_PASS &&\n\t    cg_read_strcmp(cgroup, \"cgroup.events\", \"populated 0\\n\"))\n\t\tret = KSFT_FAIL;\n\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n \nstatic int test_cgkill_tree(const char *root)\n{\n\tpid_t pids[5];\n\tchar *cgroup[10] = {0};\n\tint ret = KSFT_FAIL;\n\tint i;\n\n\tcgroup[0] = cg_name(root, \"cg_test_tree_A\");\n\tif (!cgroup[0])\n\t\tgoto cleanup;\n\n\tcgroup[1] = cg_name(cgroup[0], \"B\");\n\tif (!cgroup[1])\n\t\tgoto cleanup;\n\n\tcgroup[2] = cg_name(cgroup[1], \"C\");\n\tif (!cgroup[2])\n\t\tgoto cleanup;\n\n\tcgroup[3] = cg_name(cgroup[1], \"D\");\n\tif (!cgroup[3])\n\t\tgoto cleanup;\n\n\tcgroup[4] = cg_name(cgroup[0], \"E\");\n\tif (!cgroup[4])\n\t\tgoto cleanup;\n\n\tcgroup[5] = cg_name(cgroup[4], \"F\");\n\tif (!cgroup[5])\n\t\tgoto cleanup;\n\n\tcgroup[6] = cg_name(cgroup[5], \"G\");\n\tif (!cgroup[6])\n\t\tgoto cleanup;\n\n\tcgroup[7] = cg_name(cgroup[6], \"H\");\n\tif (!cgroup[7])\n\t\tgoto cleanup;\n\n\tcgroup[8] = cg_name(cgroup[0], \"I\");\n\tif (!cgroup[8])\n\t\tgoto cleanup;\n\n\tcgroup[9] = cg_name(cgroup[0], \"K\");\n\tif (!cgroup[9])\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 10; i++)\n\t\tif (cg_create(cgroup[i]))\n\t\t\tgoto cleanup;\n\n\tpids[0] = cg_run_nowait(cgroup[2], child_fn, NULL);\n\tpids[1] = cg_run_nowait(cgroup[7], child_fn, NULL);\n\tpids[2] = cg_run_nowait(cgroup[9], child_fn, NULL);\n\tpids[3] = cg_run_nowait(cgroup[9], child_fn, NULL);\n\tpids[4] = cg_run_nowait(cgroup[9], child_fn, NULL);\n\n\t \n\n\tif (cg_wait_for_proc_count(cgroup[2], 1) ||\n\t    cg_wait_for_proc_count(cgroup[7], 1) ||\n\t    cg_wait_for_proc_count(cgroup[9], 3))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_kill_wait(cgroup[0]))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tfor (i = 0; i < 5; i++)\n\t\twait_for_pid(pids[i]);\n\n\tif (ret == KSFT_PASS &&\n\t    cg_read_strcmp(cgroup[0], \"cgroup.events\", \"populated 0\\n\"))\n\t\tret = KSFT_FAIL;\n\n\tfor (i = 9; i >= 0 && cgroup[i]; i--) {\n\t\tcg_destroy(cgroup[i]);\n\t\tfree(cgroup[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int forkbomb_fn(const char *cgroup, void *arg)\n{\n\tint ppid;\n\n\tfork();\n\tfork();\n\n\tppid = getppid();\n\n\twhile (getppid() == ppid)\n\t\tusleep(1000);\n\n\treturn getppid() == ppid;\n}\n\n \nstatic int test_cgkill_forkbomb(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\tpid_t pid = -ESRCH;\n\n\tcgroup = cg_name(root, \"cg_forkbomb_test\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(cgroup, forkbomb_fn, NULL);\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tusleep(100000);\n\n\tif (cg_kill_wait(cgroup))\n\t\tgoto cleanup;\n\n\tif (cg_wait_for_proc_count(cgroup, 0))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (pid > 0)\n\t\twait_for_pid(pid);\n\n\tif (ret == KSFT_PASS &&\n\t    cg_read_strcmp(cgroup, \"cgroup.events\", \"populated 0\\n\"))\n\t\tret = KSFT_FAIL;\n\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct cgkill_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_cgkill_simple),\n\tT(test_cgkill_tree),\n\tT(test_cgkill_forkbomb),\n};\n#undef T\n\nint main(int argc, char *argv[])\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}