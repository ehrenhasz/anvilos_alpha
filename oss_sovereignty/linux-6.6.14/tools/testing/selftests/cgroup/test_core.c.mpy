{
  "module_name": "test_core.c",
  "hash_id": "151a29703853c7dea357c43f9350fd2e17ae6360e894a0b128175a815230058d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_core.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <linux/limits.h>\n#include <linux/sched.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdio.h>\n#include <errno.h>\n#include <signal.h>\n#include <string.h>\n#include <pthread.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\nstatic int touch_anon(char *buf, size_t size)\n{\n\tint fd;\n\tchar *pos = buf;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\twhile (size > 0) {\n\t\tssize_t ret = read(fd, pos, size);\n\n\t\tif (ret < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tpos += ret;\n\t\t\tsize -= ret;\n\t\t}\n\t}\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic int alloc_and_touch_anon_noexit(const char *cgroup, void *arg)\n{\n\tint ppid = getppid();\n\tsize_t size = (size_t)arg;\n\tvoid *buf;\n\n\tbuf = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON,\n\t\t   0, 0);\n\tif (buf == MAP_FAILED)\n\t\treturn -1;\n\n\tif (touch_anon((char *)buf, size)) {\n\t\tmunmap(buf, size);\n\t\treturn -1;\n\t}\n\n\twhile (getppid() == ppid)\n\t\tsleep(1);\n\n\tmunmap(buf, size);\n\treturn 0;\n}\n\n \nstatic int test_cgcore_destroy(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cg_test = NULL;\n\tint child_pid;\n\tchar buf[PAGE_SIZE];\n\n\tcg_test = cg_name(root, \"cg_test\");\n\n\tif (!cg_test)\n\t\tgoto cleanup;\n\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (cg_create(cg_test))\n\t\t\tgoto cleanup;\n\n\t\tchild_pid = cg_run_nowait(cg_test, alloc_and_touch_anon_noexit,\n\t\t\t\t\t  (void *) MB(100));\n\n\t\tif (child_pid < 0)\n\t\t\tgoto cleanup;\n\n\t\t \n\t\tif (cg_wait_for_proc_count(cg_test, 1))\n\t\t\tgoto cleanup;\n\n\t\tif (cg_killall(cg_test))\n\t\t\tgoto cleanup;\n\n\t\t \n\t\twhile (1) {\n\t\t\tif (cg_read(cg_test, \"cgroup.procs\", buf, sizeof(buf)))\n\t\t\t\tgoto cleanup;\n\t\t\tif (buf[0] == '\\0')\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t}\n\n\t\tif (rmdir(cg_test))\n\t\t\tgoto cleanup;\n\n\t\tif (waitpid(child_pid, NULL, 0) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tret = KSFT_PASS;\ncleanup:\n\tif (cg_test)\n\t\tcg_destroy(cg_test);\n\tfree(cg_test);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_populated(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tint err;\n\tchar *cg_test_a = NULL, *cg_test_b = NULL;\n\tchar *cg_test_c = NULL, *cg_test_d = NULL;\n\tint cgroup_fd = -EBADF;\n\tpid_t pid;\n\n\tcg_test_a = cg_name(root, \"cg_test_a\");\n\tcg_test_b = cg_name(root, \"cg_test_a/cg_test_b\");\n\tcg_test_c = cg_name(root, \"cg_test_a/cg_test_b/cg_test_c\");\n\tcg_test_d = cg_name(root, \"cg_test_a/cg_test_b/cg_test_d\");\n\n\tif (!cg_test_a || !cg_test_b || !cg_test_c || !cg_test_d)\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_a))\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_b))\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_c))\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_d))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(cg_test_c))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_a, \"cgroup.events\", \"populated 1\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_b, \"cgroup.events\", \"populated 1\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_c, \"cgroup.events\", \"populated 1\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_d, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(root))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_a, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_b, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_c, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_d, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\t \n\tcgroup_fd = dirfd_open_opath(cg_test_d);\n\tif (cgroup_fd < 0)\n\t\tgoto cleanup;\n\n\tpid = clone_into_cgroup(cgroup_fd);\n\tif (pid < 0) {\n\t\tif (errno == ENOSYS)\n\t\t\tgoto cleanup_pass;\n\t\tgoto cleanup;\n\t}\n\n\tif (pid == 0) {\n\t\tif (raise(SIGSTOP))\n\t\t\texit(EXIT_FAILURE);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\terr = cg_read_strcmp(cg_test_d, \"cgroup.events\", \"populated 1\\n\");\n\n\t(void)clone_reap(pid, WSTOPPED);\n\t(void)kill(pid, SIGCONT);\n\t(void)clone_reap(pid, WEXITED);\n\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(cg_test_d, \"cgroup.events\", \"populated 0\\n\"))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_test_d) {\n\t\tcg_destroy(cg_test_d);\n\t\tfree(cg_test_d);\n\t\tcg_test_d = NULL;\n\t}\n\n\tpid = clone_into_cgroup(cgroup_fd);\n\tif (pid < 0)\n\t\tgoto cleanup_pass;\n\tif (pid == 0)\n\t\texit(EXIT_SUCCESS);\n\t(void)clone_reap(pid, WEXITED);\n\tgoto cleanup;\n\ncleanup_pass:\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cg_test_d)\n\t\tcg_destroy(cg_test_d);\n\tif (cg_test_c)\n\t\tcg_destroy(cg_test_c);\n\tif (cg_test_b)\n\t\tcg_destroy(cg_test_b);\n\tif (cg_test_a)\n\t\tcg_destroy(cg_test_a);\n\tfree(cg_test_d);\n\tfree(cg_test_c);\n\tfree(cg_test_b);\n\tfree(cg_test_a);\n\tif (cgroup_fd >= 0)\n\t\tclose(cgroup_fd);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_invalid_domain(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *grandparent = NULL, *parent = NULL, *child = NULL;\n\n\tgrandparent = cg_name(root, \"cg_test_grandparent\");\n\tparent = cg_name(root, \"cg_test_grandparent/cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_grandparent/cg_test_parent/cg_test_child\");\n\tif (!parent || !child || !grandparent)\n\t\tgoto cleanup;\n\n\tif (cg_create(grandparent))\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(child, \"cgroup.type\", \"domain invalid\\n\"))\n\t\tgoto cleanup;\n\n\tif (!cg_enter_current(child))\n\t\tgoto cleanup;\n\n\tif (errno != EOPNOTSUPP)\n\t\tgoto cleanup;\n\n\tif (!clone_into_cgroup_run_wait(child))\n\t\tgoto cleanup;\n\n\tif (errno == ENOSYS)\n\t\tgoto cleanup_pass;\n\n\tif (errno != EOPNOTSUPP)\n\t\tgoto cleanup;\n\ncleanup_pass:\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_enter_current(root);\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tif (grandparent)\n\t\tcg_destroy(grandparent);\n\tfree(child);\n\tfree(parent);\n\tfree(grandparent);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_parent_becomes_threaded(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent = NULL, *child = NULL;\n\n\tparent = cg_name(root, \"cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_parent/cg_test_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strcmp(parent, \"cgroup.type\", \"domain threaded\\n\"))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\treturn ret;\n\n}\n\n \nstatic int test_cgcore_no_internal_process_constraint_on_threads(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent = NULL, *child = NULL;\n\n\tif (cg_read_strstr(root, \"cgroup.controllers\", \"cpu\") ||\n\t    cg_write(root, \"cgroup.subtree_control\", \"+cpu\")) {\n\t\tret = KSFT_SKIP;\n\t\tgoto cleanup;\n\t}\n\n\tparent = cg_name(root, \"cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_parent/cg_test_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(parent))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_enter_current(root);\n\tcg_enter_current(root);\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_top_down_constraint_enable(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent = NULL, *child = NULL;\n\n\tparent = cg_name(root, \"cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_parent/cg_test_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (!cg_write(child, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_top_down_constraint_disable(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent = NULL, *child = NULL;\n\n\tparent = cg_name(root, \"cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_parent/cg_test_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_write(child, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (!cg_write(parent, \"cgroup.subtree_control\", \"-memory\"))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_internal_process_constraint(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent = NULL, *child = NULL;\n\n\tparent = cg_name(root, \"cg_test_parent\");\n\tchild = cg_name(root, \"cg_test_parent/cg_test_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (!cg_enter_current(parent))\n\t\tgoto cleanup;\n\n\tif (!clone_into_cgroup_run_wait(parent))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(child);\n\tfree(parent);\n\treturn ret;\n}\n\nstatic void *dummy_thread_fn(void *arg)\n{\n\treturn (void *)(size_t)pause();\n}\n\n \nstatic int test_cgcore_proc_migration(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tint t, c_threads = 0, n_threads = 13;\n\tchar *src = NULL, *dst = NULL;\n\tpthread_t threads[n_threads];\n\n\tsrc = cg_name(root, \"cg_src\");\n\tdst = cg_name(root, \"cg_dst\");\n\tif (!src || !dst)\n\t\tgoto cleanup;\n\n\tif (cg_create(src))\n\t\tgoto cleanup;\n\tif (cg_create(dst))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(src))\n\t\tgoto cleanup;\n\n\tfor (c_threads = 0; c_threads < n_threads; ++c_threads) {\n\t\tif (pthread_create(&threads[c_threads], NULL, dummy_thread_fn, NULL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcg_enter_current(dst);\n\tif (cg_read_lc(dst, \"cgroup.threads\") != n_threads + 1)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tfor (t = 0; t < c_threads; ++t) {\n\t\tpthread_cancel(threads[t]);\n\t}\n\n\tfor (t = 0; t < c_threads; ++t) {\n\t\tpthread_join(threads[t], NULL);\n\t}\n\n\tcg_enter_current(root);\n\n\tif (dst)\n\t\tcg_destroy(dst);\n\tif (src)\n\t\tcg_destroy(src);\n\tfree(dst);\n\tfree(src);\n\treturn ret;\n}\n\nstatic void *migrating_thread_fn(void *arg)\n{\n\tint g, i, n_iterations = 1000;\n\tchar **grps = arg;\n\tchar lines[3][PATH_MAX];\n\n\tfor (g = 1; g < 3; ++g)\n\t\tsnprintf(lines[g], sizeof(lines[g]), \"0::%s\", grps[g] + strlen(grps[0]));\n\n\tfor (i = 0; i < n_iterations; ++i) {\n\t\tcg_enter_current_thread(grps[(i % 2) + 1]);\n\n\t\tif (proc_read_strstr(0, 1, \"cgroup\", lines[(i % 2) + 1]))\n\t\t\treturn (void *)-1;\n\t}\n\treturn NULL;\n}\n\n \nstatic int test_cgcore_thread_migration(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *dom = NULL;\n\tchar line[PATH_MAX];\n\tchar *grps[3] = { (char *)root, NULL, NULL };\n\tpthread_t thr;\n\tvoid *retval;\n\n\tdom = cg_name(root, \"cg_dom\");\n\tgrps[1] = cg_name(root, \"cg_dom/cg_src\");\n\tgrps[2] = cg_name(root, \"cg_dom/cg_dst\");\n\tif (!grps[1] || !grps[2] || !dom)\n\t\tgoto cleanup;\n\n\tif (cg_create(dom))\n\t\tgoto cleanup;\n\tif (cg_create(grps[1]))\n\t\tgoto cleanup;\n\tif (cg_create(grps[2]))\n\t\tgoto cleanup;\n\n\tif (cg_write(grps[1], \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\tif (cg_write(grps[2], \"cgroup.type\", \"threaded\"))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(grps[1]))\n\t\tgoto cleanup;\n\n\tif (pthread_create(&thr, NULL, migrating_thread_fn, grps))\n\t\tgoto cleanup;\n\n\tif (pthread_join(thr, &retval))\n\t\tgoto cleanup;\n\n\tif (retval)\n\t\tgoto cleanup;\n\n\tsnprintf(line, sizeof(line), \"0::%s\", grps[1] + strlen(grps[0]));\n\tif (proc_read_strstr(0, 1, \"cgroup\", line))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_enter_current(root);\n\tif (grps[2])\n\t\tcg_destroy(grps[2]);\n\tif (grps[1])\n\t\tcg_destroy(grps[1]);\n\tif (dom)\n\t\tcg_destroy(dom);\n\tfree(grps[2]);\n\tfree(grps[1]);\n\tfree(dom);\n\treturn ret;\n}\n\n \nstatic int test_cgcore_lesser_euid_open(const char *root)\n{\n\tconst uid_t test_euid = TEST_UID;\n\tint ret = KSFT_FAIL;\n\tchar *cg_test_a = NULL, *cg_test_b = NULL;\n\tchar *cg_test_a_procs = NULL, *cg_test_b_procs = NULL;\n\tint cg_test_b_procs_fd = -1;\n\tuid_t saved_uid;\n\n\tcg_test_a = cg_name(root, \"cg_test_a\");\n\tcg_test_b = cg_name(root, \"cg_test_b\");\n\n\tif (!cg_test_a || !cg_test_b)\n\t\tgoto cleanup;\n\n\tcg_test_a_procs = cg_name(cg_test_a, \"cgroup.procs\");\n\tcg_test_b_procs = cg_name(cg_test_b, \"cgroup.procs\");\n\n\tif (!cg_test_a_procs || !cg_test_b_procs)\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_a) || cg_create(cg_test_b))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(cg_test_a))\n\t\tgoto cleanup;\n\n\tif (chown(cg_test_a_procs, test_euid, -1) ||\n\t    chown(cg_test_b_procs, test_euid, -1))\n\t\tgoto cleanup;\n\n\tsaved_uid = geteuid();\n\tif (seteuid(test_euid))\n\t\tgoto cleanup;\n\n\tcg_test_b_procs_fd = open(cg_test_b_procs, O_RDWR);\n\n\tif (seteuid(saved_uid))\n\t\tgoto cleanup;\n\n\tif (cg_test_b_procs_fd < 0)\n\t\tgoto cleanup;\n\n\tif (write(cg_test_b_procs_fd, \"0\", 1) >= 0 || errno != EACCES)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_enter_current(root);\n\tif (cg_test_b_procs_fd >= 0)\n\t\tclose(cg_test_b_procs_fd);\n\tif (cg_test_b)\n\t\tcg_destroy(cg_test_b);\n\tif (cg_test_a)\n\t\tcg_destroy(cg_test_a);\n\tfree(cg_test_b_procs);\n\tfree(cg_test_a_procs);\n\tfree(cg_test_b);\n\tfree(cg_test_a);\n\treturn ret;\n}\n\nstruct lesser_ns_open_thread_arg {\n\tconst char\t*path;\n\tint\t\tfd;\n\tint\t\terr;\n};\n\nstatic int lesser_ns_open_thread_fn(void *arg)\n{\n\tstruct lesser_ns_open_thread_arg *targ = arg;\n\n\ttarg->fd = open(targ->path, O_RDWR);\n\ttarg->err = errno;\n\treturn 0;\n}\n\n \nstatic int test_cgcore_lesser_ns_open(const char *root)\n{\n\tstatic char stack[65536];\n\tconst uid_t test_euid = 65534;\t \n\tint ret = KSFT_FAIL;\n\tchar *cg_test_a = NULL, *cg_test_b = NULL;\n\tchar *cg_test_a_procs = NULL, *cg_test_b_procs = NULL;\n\tint cg_test_b_procs_fd = -1;\n\tstruct lesser_ns_open_thread_arg targ = { .fd = -1 };\n\tpid_t pid;\n\tint status;\n\n\tcg_test_a = cg_name(root, \"cg_test_a\");\n\tcg_test_b = cg_name(root, \"cg_test_b\");\n\n\tif (!cg_test_a || !cg_test_b)\n\t\tgoto cleanup;\n\n\tcg_test_a_procs = cg_name(cg_test_a, \"cgroup.procs\");\n\tcg_test_b_procs = cg_name(cg_test_b, \"cgroup.procs\");\n\n\tif (!cg_test_a_procs || !cg_test_b_procs)\n\t\tgoto cleanup;\n\n\tif (cg_create(cg_test_a) || cg_create(cg_test_b))\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(cg_test_b))\n\t\tgoto cleanup;\n\n\tif (chown(cg_test_a_procs, test_euid, -1) ||\n\t    chown(cg_test_b_procs, test_euid, -1))\n\t\tgoto cleanup;\n\n\ttarg.path = cg_test_b_procs;\n\tpid = clone(lesser_ns_open_thread_fn, stack + sizeof(stack),\n\t\t    CLONE_NEWCGROUP | CLONE_FILES | CLONE_VM | SIGCHLD,\n\t\t    &targ);\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tif (waitpid(pid, &status, 0) < 0)\n\t\tgoto cleanup;\n\n\tif (!WIFEXITED(status))\n\t\tgoto cleanup;\n\n\tcg_test_b_procs_fd = targ.fd;\n\tif (cg_test_b_procs_fd < 0)\n\t\tgoto cleanup;\n\n\tif (cg_enter_current(cg_test_a))\n\t\tgoto cleanup;\n\n\tif ((status = write(cg_test_b_procs_fd, \"0\", 1)) >= 0 || errno != ENOENT)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_enter_current(root);\n\tif (cg_test_b_procs_fd >= 0)\n\t\tclose(cg_test_b_procs_fd);\n\tif (cg_test_b)\n\t\tcg_destroy(cg_test_b);\n\tif (cg_test_a)\n\t\tcg_destroy(cg_test_a);\n\tfree(cg_test_b_procs);\n\tfree(cg_test_a_procs);\n\tfree(cg_test_b);\n\tfree(cg_test_a);\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct corecg_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_cgcore_internal_process_constraint),\n\tT(test_cgcore_top_down_constraint_enable),\n\tT(test_cgcore_top_down_constraint_disable),\n\tT(test_cgcore_no_internal_process_constraint_on_threads),\n\tT(test_cgcore_parent_becomes_threaded),\n\tT(test_cgcore_invalid_domain),\n\tT(test_cgcore_populated),\n\tT(test_cgcore_proc_migration),\n\tT(test_cgcore_thread_migration),\n\tT(test_cgcore_destroy),\n\tT(test_cgcore_lesser_euid_open),\n\tT(test_cgcore_lesser_ns_open),\n};\n#undef T\n\nint main(int argc, char *argv[])\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"memory\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+memory\"))\n\t\t\tksft_exit_skip(\"Failed to set memory controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}