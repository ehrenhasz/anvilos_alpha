{
  "module_name": "test_zswap.c",
  "hash_id": "f69568995e966dc9c54a00fd3a6cf2bc71b151e84f5c4853d51cec844f91dabd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_zswap.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <linux/limits.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/sysinfo.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\nstatic int read_int(const char *path, size_t *value)\n{\n\tFILE *file;\n\tint ret = 0;\n\n\tfile = fopen(path, \"r\");\n\tif (!file)\n\t\treturn -1;\n\tif (fscanf(file, \"%ld\", value) != 1)\n\t\tret = -1;\n\tfclose(file);\n\treturn ret;\n}\n\nstatic int set_min_free_kb(size_t value)\n{\n\tFILE *file;\n\tint ret;\n\n\tfile = fopen(\"/proc/sys/vm/min_free_kbytes\", \"w\");\n\tif (!file)\n\t\treturn -1;\n\tret = fprintf(file, \"%ld\\n\", value);\n\tfclose(file);\n\treturn ret;\n}\n\nstatic int read_min_free_kb(size_t *value)\n{\n\treturn read_int(\"/proc/sys/vm/min_free_kbytes\", value);\n}\n\nstatic int get_zswap_stored_pages(size_t *value)\n{\n\treturn read_int(\"/sys/kernel/debug/zswap/stored_pages\", value);\n}\n\nstatic int get_zswap_written_back_pages(size_t *value)\n{\n\treturn read_int(\"/sys/kernel/debug/zswap/written_back_pages\", value);\n}\n\nstatic int allocate_bytes(const char *cgroup, void *arg)\n{\n\tsize_t size = (size_t)arg;\n\tchar *mem = (char *)malloc(size);\n\n\tif (!mem)\n\t\treturn -1;\n\tfor (int i = 0; i < size; i += 4095)\n\t\tmem[i] = 'a';\n\tfree(mem);\n\treturn 0;\n}\n\n \nstatic int test_no_invasive_cgroup_shrink(const char *root)\n{\n\tsize_t written_back_before, written_back_after;\n\tint ret = KSFT_FAIL;\n\tchar *test_group;\n\n\t \n\ttest_group = cg_name(root, \"no_shrink_test\");\n\tif (!test_group)\n\t\tgoto out;\n\tif (cg_create(test_group))\n\t\tgoto out;\n\tif (cg_write(test_group, \"memory.max\", \"1M\"))\n\t\tgoto out;\n\tif (cg_write(test_group, \"memory.zswap.max\", \"10K\"))\n\t\tgoto out;\n\tif (get_zswap_written_back_pages(&written_back_before))\n\t\tgoto out;\n\n\t \n\tif (cg_run(test_group, allocate_bytes, (void *)MB(10)))\n\t\tgoto out;\n\n\t \n\tif (get_zswap_written_back_pages(&written_back_after))\n\t\tgoto out;\n\tif (written_back_after == written_back_before)\n\t\tret = KSFT_PASS;\nout:\n\tcg_destroy(test_group);\n\tfree(test_group);\n\treturn ret;\n}\n\nstruct no_kmem_bypass_child_args {\n\tsize_t target_alloc_bytes;\n\tsize_t child_allocated;\n};\n\nstatic int no_kmem_bypass_child(const char *cgroup, void *arg)\n{\n\tstruct no_kmem_bypass_child_args *values = arg;\n\tvoid *allocation;\n\n\tallocation = malloc(values->target_alloc_bytes);\n\tif (!allocation) {\n\t\tvalues->child_allocated = true;\n\t\treturn -1;\n\t}\n\tfor (long i = 0; i < values->target_alloc_bytes; i += 4095)\n\t\t((char *)allocation)[i] = 'a';\n\tvalues->child_allocated = true;\n\tpause();\n\tfree(allocation);\n\treturn 0;\n}\n\n \nstatic int test_no_kmem_bypass(const char *root)\n{\n\tsize_t min_free_kb_high, min_free_kb_low, min_free_kb_original;\n\tstruct no_kmem_bypass_child_args *values;\n\tsize_t trigger_allocation_size;\n\tint wait_child_iteration = 0;\n\tlong stored_pages_threshold;\n\tstruct sysinfo sys_info;\n\tint ret = KSFT_FAIL;\n\tint child_status;\n\tchar *test_group;\n\tpid_t child_pid;\n\n\t \n\tif (sysinfo(&sys_info) != 0)\n\t\treturn KSFT_FAIL;\n\tif (sys_info.totalram > 5000000000)\n\t\treturn KSFT_SKIP;\n\tvalues = mmap(0, sizeof(struct no_kmem_bypass_child_args), PROT_READ |\n\t\t\tPROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tif (values == MAP_FAILED)\n\t\treturn KSFT_FAIL;\n\tif (read_min_free_kb(&min_free_kb_original))\n\t\treturn KSFT_FAIL;\n\tmin_free_kb_high = sys_info.totalram / 2000;\n\tmin_free_kb_low = sys_info.totalram / 500000;\n\tvalues->target_alloc_bytes = (sys_info.totalram - min_free_kb_high * 1000) +\n\t\tsys_info.totalram * 5 / 100;\n\tstored_pages_threshold = sys_info.totalram / 5 / 4096;\n\ttrigger_allocation_size = sys_info.totalram / 20;\n\n\t \n\tif (cg_write(root, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto out;\n\ttest_group = cg_name(root, \"kmem_bypass_test\");\n\tif (!test_group)\n\t\tgoto out;\n\n\t \n\tset_min_free_kb(min_free_kb_low);\n\tif (cg_create(test_group))\n\t\tgoto out;\n\tvalues->child_allocated = false;\n\tchild_pid = cg_run_nowait(test_group, no_kmem_bypass_child, values);\n\tif (child_pid < 0)\n\t\tgoto out;\n\twhile (!values->child_allocated && wait_child_iteration++ < 10000)\n\t\tusleep(1000);\n\n\t \n\tset_min_free_kb(min_free_kb_high);\n\tfor (int i = 0; i < 20; i++) {\n\t\tsize_t stored_pages;\n\t\tchar *trigger_allocation = malloc(trigger_allocation_size);\n\n\t\tif (!trigger_allocation)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < trigger_allocation_size; i += 4095)\n\t\t\ttrigger_allocation[i] = 'b';\n\t\tusleep(100000);\n\t\tfree(trigger_allocation);\n\t\tif (get_zswap_stored_pages(&stored_pages))\n\t\t\tbreak;\n\t\tif (stored_pages < 0)\n\t\t\tbreak;\n\t\t \n\t\tif (stored_pages > stored_pages_threshold) {\n\t\t\tint zswapped = cg_read_key_long(test_group, \"memory.stat\", \"zswapped \");\n\t\t\tint delta = stored_pages * 4096 - zswapped;\n\t\t\tint result_ok = delta < stored_pages * 4096 / 4;\n\n\t\t\tret = result_ok ? KSFT_PASS : KSFT_FAIL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkill(child_pid, SIGTERM);\n\twaitpid(child_pid, &child_status, 0);\nout:\n\tset_min_free_kb(min_free_kb_original);\n\tcg_destroy(test_group);\n\tfree(test_group);\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct zswap_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_no_kmem_bypass),\n\tT(test_no_invasive_cgroup_shrink),\n};\n#undef T\n\nstatic bool zswap_configured(void)\n{\n\treturn access(\"/sys/module/zswap\", F_OK) == 0;\n}\n\nint main(int argc, char **argv)\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\tif (!zswap_configured())\n\t\tksft_exit_skip(\"zswap isn't configured\\n\");\n\n\t \n\tif (cg_read_strstr(root, \"cgroup.controllers\", \"memory\"))\n\t\tksft_exit_skip(\"memory controller isn't available\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"memory\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+memory\"))\n\t\t\tksft_exit_skip(\"Failed to set memory controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}