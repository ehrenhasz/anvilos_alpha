{
  "module_name": "test_kmem.c",
  "hash_id": "506b8e9b47e2dce3e94c8c40fa8d0cccb9b3f27f5f0b3395f9cccb3a5d2a8395",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_kmem.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <linux/limits.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <sys/sysinfo.h>\n#include <pthread.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\n\n \n#define MAX_VMSTAT_ERROR (4096 * 64 * get_nprocs())\n\n\nstatic int alloc_dcache(const char *cgroup, void *arg)\n{\n\tunsigned long i;\n\tstruct stat st;\n\tchar buf[128];\n\n\tfor (i = 0; i < (unsigned long)arg; i++) {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\"/something-non-existent-with-a-long-name-%64lu-%d\",\n\t\t\t i, getpid());\n\t\tstat(buf, &st);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int test_kmem_basic(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cg = NULL;\n\tlong slab0, slab1, current;\n\n\tcg = cg_name(root, \"kmem_basic_test\");\n\tif (!cg)\n\t\tgoto cleanup;\n\n\tif (cg_create(cg))\n\t\tgoto cleanup;\n\n\tif (cg_run(cg, alloc_dcache, (void *)100000))\n\t\tgoto cleanup;\n\n\tslab0 = cg_read_key_long(cg, \"memory.stat\", \"slab \");\n\tif (slab0 < (1 << 20))\n\t\tgoto cleanup;\n\n\tcg_write(cg, \"memory.high\", \"1M\");\n\n\t \n\tsleep(1);\n\n\tslab1 = cg_read_key_long(cg, \"memory.stat\", \"slab \");\n\tif (slab1 < 0)\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(cg, \"memory.current\");\n\tif (current < 0)\n\t\tgoto cleanup;\n\n\tif (slab1 < slab0 / 2 && current < slab0 / 2)\n\t\tret = KSFT_PASS;\ncleanup:\n\tcg_destroy(cg);\n\tfree(cg);\n\n\treturn ret;\n}\n\nstatic void *alloc_kmem_fn(void *arg)\n{\n\talloc_dcache(NULL, (void *)100);\n\treturn NULL;\n}\n\nstatic int alloc_kmem_smp(const char *cgroup, void *arg)\n{\n\tint nr_threads = 2 * get_nprocs();\n\tpthread_t *tinfo;\n\tunsigned long i;\n\tint ret = -1;\n\n\ttinfo = calloc(nr_threads, sizeof(pthread_t));\n\tif (tinfo == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tif (pthread_create(&tinfo[i], NULL, &alloc_kmem_fn,\n\t\t\t\t   (void *)i)) {\n\t\t\tfree(tinfo);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tret = pthread_join(tinfo[i], NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(tinfo);\n\treturn ret;\n}\n\nstatic int cg_run_in_subcgroups(const char *parent,\n\t\t\t\tint (*fn)(const char *cgroup, void *arg),\n\t\t\t\tvoid *arg, int times)\n{\n\tchar *child;\n\tint i;\n\n\tfor (i = 0; i < times; i++) {\n\t\tchild = cg_name_indexed(parent, \"child\", i);\n\t\tif (!child)\n\t\t\treturn -1;\n\n\t\tif (cg_create(child)) {\n\t\t\tcg_destroy(child);\n\t\t\tfree(child);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cg_run(child, fn, NULL)) {\n\t\t\tcg_destroy(child);\n\t\t\tfree(child);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcg_destroy(child);\n\t\tfree(child);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int test_kmem_memcg_deletion(const char *root)\n{\n\tlong current, anon, file, kernel, sock, sum;\n\tint ret = KSFT_FAIL;\n\tchar *parent;\n\n\tparent = cg_name(root, \"kmem_memcg_deletion_test\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_run_in_subcgroups(parent, alloc_kmem_smp, NULL, 100))\n\t\tgoto cleanup;\n\n\tcurrent = cg_read_long(parent, \"memory.current\");\n\tanon = cg_read_key_long(parent, \"memory.stat\", \"anon \");\n\tfile = cg_read_key_long(parent, \"memory.stat\", \"file \");\n\tkernel = cg_read_key_long(parent, \"memory.stat\", \"kernel \");\n\tsock = cg_read_key_long(parent, \"memory.stat\", \"sock \");\n\tif (current < 0 || anon < 0 || file < 0 || kernel < 0 || sock < 0)\n\t\tgoto cleanup;\n\n\tsum = anon + file + kernel + sock;\n\tif (abs(sum - current) < MAX_VMSTAT_ERROR) {\n\t\tret = KSFT_PASS;\n\t} else {\n\t\tprintf(\"memory.current = %ld\\n\", current);\n\t\tprintf(\"anon + file + kernel + sock = %ld\\n\", sum);\n\t\tprintf(\"anon = %ld\\n\", anon);\n\t\tprintf(\"file = %ld\\n\", file);\n\t\tprintf(\"kernel = %ld\\n\", kernel);\n\t\tprintf(\"sock = %ld\\n\", sock);\n\t}\n\ncleanup:\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\n \nstatic int test_kmem_proc_kpagecgroup(const char *root)\n{\n\tunsigned long buf[128];\n\tint ret = KSFT_FAIL;\n\tssize_t len;\n\tint fd;\n\n\tfd = open(\"/proc/kpagecgroup\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn ret;\n\n\tdo {\n\t\tlen = read(fd, buf, sizeof(buf));\n\t} while (len > 0);\n\n\tif (len == 0)\n\t\tret = KSFT_PASS;\n\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void *pthread_wait_fn(void *arg)\n{\n\tsleep(100);\n\treturn NULL;\n}\n\nstatic int spawn_1000_threads(const char *cgroup, void *arg)\n{\n\tint nr_threads = 1000;\n\tpthread_t *tinfo;\n\tunsigned long i;\n\tlong stack;\n\tint ret = -1;\n\n\ttinfo = calloc(nr_threads, sizeof(pthread_t));\n\tif (tinfo == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tif (pthread_create(&tinfo[i], NULL, &pthread_wait_fn,\n\t\t\t\t   (void *)i)) {\n\t\t\tfree(tinfo);\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n\tstack = cg_read_key_long(cgroup, \"memory.stat\", \"kernel_stack \");\n\tif (stack >= 4096 * 1000)\n\t\tret = 0;\n\n\tfree(tinfo);\n\treturn ret;\n}\n\n \nstatic int test_kmem_kernel_stacks(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cg = NULL;\n\n\tcg = cg_name(root, \"kmem_kernel_stacks_test\");\n\tif (!cg)\n\t\tgoto cleanup;\n\n\tif (cg_create(cg))\n\t\tgoto cleanup;\n\n\tif (cg_run(cg, spawn_1000_threads, NULL))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\ncleanup:\n\tcg_destroy(cg);\n\tfree(cg);\n\n\treturn ret;\n}\n\n \nstatic int test_kmem_dead_cgroups(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent;\n\tlong dead;\n\tint i;\n\n\tparent = cg_name(root, \"kmem_dead_cgroups_test\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tif (cg_run_in_subcgroups(parent, alloc_dcache, (void *)100, 30))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tdead = cg_read_key_long(parent, \"cgroup.stat\",\n\t\t\t\t\t\"nr_dying_descendants \");\n\t\tif (dead == 0) {\n\t\t\tret = KSFT_PASS;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tsleep(1);\n\t}\n\ncleanup:\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\n \nstatic int test_percpu_basic(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent, *child;\n\tlong current, percpu;\n\tint i;\n\n\tparent = cg_name(root, \"percpu_basic_test\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+memory\"))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tchild = cg_name_indexed(parent, \"child\", i);\n\t\tif (!child)\n\t\t\treturn -1;\n\n\t\tif (cg_create(child))\n\t\t\tgoto cleanup_children;\n\n\t\tfree(child);\n\t}\n\n\tcurrent = cg_read_long(parent, \"memory.current\");\n\tpercpu = cg_read_key_long(parent, \"memory.stat\", \"percpu \");\n\n\tif (current > 0 && percpu > 0 && abs(current - percpu) <\n\t    MAX_VMSTAT_ERROR)\n\t\tret = KSFT_PASS;\n\telse\n\t\tprintf(\"memory.current %ld\\npercpu %ld\\n\",\n\t\t       current, percpu);\n\ncleanup_children:\n\tfor (i = 0; i < 1000; i++) {\n\t\tchild = cg_name_indexed(parent, \"child\", i);\n\t\tcg_destroy(child);\n\t\tfree(child);\n\t}\n\ncleanup:\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct kmem_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_kmem_basic),\n\tT(test_kmem_memcg_deletion),\n\tT(test_kmem_proc_kpagecgroup),\n\tT(test_kmem_kernel_stacks),\n\tT(test_kmem_dead_cgroups),\n\tT(test_percpu_basic),\n};\n#undef T\n\nint main(int argc, char **argv)\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\t \n\tif (cg_read_strstr(root, \"cgroup.controllers\", \"memory\"))\n\t\tksft_exit_skip(\"memory controller isn't available\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"memory\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+memory\"))\n\t\t\tksft_exit_skip(\"Failed to set memory controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}