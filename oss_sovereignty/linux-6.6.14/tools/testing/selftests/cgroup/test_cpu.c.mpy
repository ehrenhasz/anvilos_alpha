{
  "module_name": "test_cpu.c",
  "hash_id": "9f8c5ff700f88a5fe63ab2b9d2ee64271513a9e35a04637ae1f7f8f491c503c3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_cpu.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <linux/limits.h>\n#include <sys/sysinfo.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <time.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\nenum hog_clock_type {\n\t\n\tCPU_HOG_CLOCK_PROCESS,\n\t\n\tCPU_HOG_CLOCK_WALL,\n};\n\nstruct cpu_hogger {\n\tchar *cgroup;\n\tpid_t pid;\n\tlong usage;\n};\n\nstruct cpu_hog_func_param {\n\tint nprocs;\n\tstruct timespec ts;\n\tenum hog_clock_type clock_type;\n};\n\n \nstatic int test_cpucg_subtree_control(const char *root)\n{\n\tchar *parent = NULL, *child = NULL, *parent2 = NULL, *child2 = NULL;\n\tint ret = KSFT_FAIL;\n\n\t\n\tparent = cg_name(root, \"cpucg_test_0\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\n\tchild = cg_name(parent, \"cpucg_test_child\");\n\tif (!child)\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_read_strstr(child, \"cgroup.controllers\", \"cpu\"))\n\t\tgoto cleanup;\n\n\t\n\tparent2 = cg_name(root, \"cpucg_test_1\");\n\tif (!parent2)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent2))\n\t\tgoto cleanup;\n\n\tchild2 = cg_name(parent2, \"cpucg_test_child\");\n\tif (!child2)\n\t\tgoto cleanup;\n\n\tif (cg_create(child2))\n\t\tgoto cleanup;\n\n\tif (!cg_read_strstr(child2, \"cgroup.controllers\", \"cpu\"))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(child);\n\tfree(child);\n\tcg_destroy(child2);\n\tfree(child2);\n\tcg_destroy(parent);\n\tfree(parent);\n\tcg_destroy(parent2);\n\tfree(parent2);\n\n\treturn ret;\n}\n\nstatic void *hog_cpu_thread_func(void *arg)\n{\n\twhile (1)\n\t\t;\n\n\treturn NULL;\n}\n\nstatic struct timespec\ntimespec_sub(const struct timespec *lhs, const struct timespec *rhs)\n{\n\tstruct timespec zero = {\n\t\t.tv_sec = 0,\n\t\t.tv_nsec = 0,\n\t};\n\tstruct timespec ret;\n\n\tif (lhs->tv_sec < rhs->tv_sec)\n\t\treturn zero;\n\n\tret.tv_sec = lhs->tv_sec - rhs->tv_sec;\n\n\tif (lhs->tv_nsec < rhs->tv_nsec) {\n\t\tif (ret.tv_sec == 0)\n\t\t\treturn zero;\n\n\t\tret.tv_sec--;\n\t\tret.tv_nsec = NSEC_PER_SEC - rhs->tv_nsec + lhs->tv_nsec;\n\t} else\n\t\tret.tv_nsec = lhs->tv_nsec - rhs->tv_nsec;\n\n\treturn ret;\n}\n\nstatic int hog_cpus_timed(const char *cgroup, void *arg)\n{\n\tconst struct cpu_hog_func_param *param =\n\t\t(struct cpu_hog_func_param *)arg;\n\tstruct timespec ts_run = param->ts;\n\tstruct timespec ts_remaining = ts_run;\n\tstruct timespec ts_start;\n\tint i, ret;\n\n\tret = clock_gettime(CLOCK_MONOTONIC, &ts_start);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < param->nprocs; i++) {\n\t\tpthread_t tid;\n\n\t\tret = pthread_create(&tid, NULL, &hog_cpu_thread_func, NULL);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\twhile (ts_remaining.tv_sec > 0 || ts_remaining.tv_nsec > 0) {\n\t\tstruct timespec ts_total;\n\n\t\tret = nanosleep(&ts_remaining, NULL);\n\t\tif (ret && errno != EINTR)\n\t\t\treturn ret;\n\n\t\tif (param->clock_type == CPU_HOG_CLOCK_PROCESS) {\n\t\t\tret = clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts_total);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tstruct timespec ts_current;\n\n\t\t\tret = clock_gettime(CLOCK_MONOTONIC, &ts_current);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\tts_total = timespec_sub(&ts_current, &ts_start);\n\t\t}\n\n\t\tts_remaining = timespec_sub(&ts_run, &ts_total);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int test_cpucg_stats(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tlong usage_usec, user_usec, system_usec;\n\tlong usage_seconds = 2;\n\tlong expected_usage_usec = usage_seconds * USEC_PER_SEC;\n\tchar *cpucg;\n\n\tcpucg = cg_name(root, \"cpucg_test\");\n\tif (!cpucg)\n\t\tgoto cleanup;\n\n\tif (cg_create(cpucg))\n\t\tgoto cleanup;\n\n\tusage_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"usage_usec\");\n\tuser_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"user_usec\");\n\tsystem_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"system_usec\");\n\tif (usage_usec != 0 || user_usec != 0 || system_usec != 0)\n\t\tgoto cleanup;\n\n\tstruct cpu_hog_func_param param = {\n\t\t.nprocs = 1,\n\t\t.ts = {\n\t\t\t.tv_sec = usage_seconds,\n\t\t\t.tv_nsec = 0,\n\t\t},\n\t\t.clock_type = CPU_HOG_CLOCK_PROCESS,\n\t};\n\tif (cg_run(cpucg, hog_cpus_timed, (void *)&param))\n\t\tgoto cleanup;\n\n\tusage_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"usage_usec\");\n\tuser_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"user_usec\");\n\tif (user_usec <= 0)\n\t\tgoto cleanup;\n\n\tif (!values_close(usage_usec, expected_usage_usec, 1))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(cpucg);\n\tfree(cpucg);\n\n\treturn ret;\n}\n\nstatic int\nrun_cpucg_weight_test(\n\t\tconst char *root,\n\t\tpid_t (*spawn_child)(const struct cpu_hogger *child),\n\t\tint (*validate)(const struct cpu_hogger *children, int num_children))\n{\n\tint ret = KSFT_FAIL, i;\n\tchar *parent = NULL;\n\tstruct cpu_hogger children[3] = {NULL};\n\n\tparent = cg_name(root, \"cpucg_test_0\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tchildren[i].cgroup = cg_name_indexed(parent, \"cpucg_child\", i);\n\t\tif (!children[i].cgroup)\n\t\t\tgoto cleanup;\n\n\t\tif (cg_create(children[i].cgroup))\n\t\t\tgoto cleanup;\n\n\t\tif (cg_write_numeric(children[i].cgroup, \"cpu.weight\",\n\t\t\t\t\t50 * (i + 1)))\n\t\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tpid_t pid = spawn_child(&children[i]);\n\t\tif (pid <= 0)\n\t\t\tgoto cleanup;\n\t\tchildren[i].pid = pid;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tint retcode;\n\n\t\twaitpid(children[i].pid, &retcode, 0);\n\t\tif (!WIFEXITED(retcode))\n\t\t\tgoto cleanup;\n\t\tif (WEXITSTATUS(retcode))\n\t\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(children); i++)\n\t\tchildren[i].usage = cg_read_key_long(children[i].cgroup,\n\t\t\t\t\"cpu.stat\", \"usage_usec\");\n\n\tif (validate(children, ARRAY_SIZE(children)))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\ncleanup:\n\tfor (i = 0; i < ARRAY_SIZE(children); i++) {\n\t\tcg_destroy(children[i].cgroup);\n\t\tfree(children[i].cgroup);\n\t}\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\nstatic pid_t weight_hog_ncpus(const struct cpu_hogger *child, int ncpus)\n{\n\tlong usage_seconds = 10;\n\tstruct cpu_hog_func_param param = {\n\t\t.nprocs = ncpus,\n\t\t.ts = {\n\t\t\t.tv_sec = usage_seconds,\n\t\t\t.tv_nsec = 0,\n\t\t},\n\t\t.clock_type = CPU_HOG_CLOCK_WALL,\n\t};\n\treturn cg_run_nowait(child->cgroup, hog_cpus_timed, (void *)&param);\n}\n\nstatic pid_t weight_hog_all_cpus(const struct cpu_hogger *child)\n{\n\treturn weight_hog_ncpus(child, get_nprocs());\n}\n\nstatic int\noverprovision_validate(const struct cpu_hogger *children, int num_children)\n{\n\tint ret = KSFT_FAIL, i;\n\n\tfor (i = 0; i < num_children - 1; i++) {\n\t\tlong delta;\n\n\t\tif (children[i + 1].usage <= children[i].usage)\n\t\t\tgoto cleanup;\n\n\t\tdelta = children[i + 1].usage - children[i].usage;\n\t\tif (!values_close(delta, children[0].usage, 35))\n\t\t\tgoto cleanup;\n\t}\n\n\tret = KSFT_PASS;\ncleanup:\n\treturn ret;\n}\n\n \nstatic int test_cpucg_weight_overprovisioned(const char *root)\n{\n\treturn run_cpucg_weight_test(root, weight_hog_all_cpus,\n\t\t\toverprovision_validate);\n}\n\nstatic pid_t weight_hog_one_cpu(const struct cpu_hogger *child)\n{\n\treturn weight_hog_ncpus(child, 1);\n}\n\nstatic int\nunderprovision_validate(const struct cpu_hogger *children, int num_children)\n{\n\tint ret = KSFT_FAIL, i;\n\n\tfor (i = 0; i < num_children - 1; i++) {\n\t\tif (!values_close(children[i + 1].usage, children[0].usage, 15))\n\t\t\tgoto cleanup;\n\t}\n\n\tret = KSFT_PASS;\ncleanup:\n\treturn ret;\n}\n\n \nstatic int test_cpucg_weight_underprovisioned(const char *root)\n{\n\t\n\t\n\tif (get_nprocs() < 4)\n\t\treturn KSFT_SKIP;\n\n\treturn run_cpucg_weight_test(root, weight_hog_one_cpu,\n\t\t\tunderprovision_validate);\n}\n\nstatic int\nrun_cpucg_nested_weight_test(const char *root, bool overprovisioned)\n{\n\tint ret = KSFT_FAIL, i;\n\tchar *parent = NULL, *child = NULL;\n\tstruct cpu_hogger leaf[3] = {NULL};\n\tlong nested_leaf_usage, child_usage;\n\tint nprocs = get_nprocs();\n\n\tif (!overprovisioned) {\n\t\tif (nprocs < 4)\n\t\t\t \n\t\t\treturn KSFT_SKIP;\n\t\tnprocs /= 4;\n\t}\n\n\tparent = cg_name(root, \"cpucg_test\");\n\tchild = cg_name(parent, \"cpucg_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\tif (cg_write(child, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\tif (cg_write(child, \"cpu.weight\", \"1000\"))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ARRAY_SIZE(leaf); i++) {\n\t\tconst char *ancestor;\n\t\tlong weight;\n\n\t\tif (i == 0) {\n\t\t\tancestor = parent;\n\t\t\tweight = 1000;\n\t\t} else {\n\t\t\tancestor = child;\n\t\t\tweight = 5000;\n\t\t}\n\t\tleaf[i].cgroup = cg_name_indexed(ancestor, \"cpucg_leaf\", i);\n\t\tif (!leaf[i].cgroup)\n\t\t\tgoto cleanup;\n\n\t\tif (cg_create(leaf[i].cgroup))\n\t\t\tgoto cleanup;\n\n\t\tif (cg_write_numeric(leaf[i].cgroup, \"cpu.weight\", weight))\n\t\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(leaf); i++) {\n\t\tpid_t pid;\n\t\tstruct cpu_hog_func_param param = {\n\t\t\t.nprocs = nprocs,\n\t\t\t.ts = {\n\t\t\t\t.tv_sec = 10,\n\t\t\t\t.tv_nsec = 0,\n\t\t\t},\n\t\t\t.clock_type = CPU_HOG_CLOCK_WALL,\n\t\t};\n\n\t\tpid = cg_run_nowait(leaf[i].cgroup, hog_cpus_timed,\n\t\t\t\t(void *)&param);\n\t\tif (pid <= 0)\n\t\t\tgoto cleanup;\n\t\tleaf[i].pid = pid;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(leaf); i++) {\n\t\tint retcode;\n\n\t\twaitpid(leaf[i].pid, &retcode, 0);\n\t\tif (!WIFEXITED(retcode))\n\t\t\tgoto cleanup;\n\t\tif (WEXITSTATUS(retcode))\n\t\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(leaf); i++) {\n\t\tleaf[i].usage = cg_read_key_long(leaf[i].cgroup,\n\t\t\t\t\"cpu.stat\", \"usage_usec\");\n\t\tif (leaf[i].usage <= 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tnested_leaf_usage = leaf[1].usage + leaf[2].usage;\n\tif (overprovisioned) {\n\t\tif (!values_close(leaf[0].usage, nested_leaf_usage, 15))\n\t\t\tgoto cleanup;\n\t} else if (!values_close(leaf[0].usage * 2, nested_leaf_usage, 15))\n\t\tgoto cleanup;\n\n\n\tchild_usage = cg_read_key_long(child, \"cpu.stat\", \"usage_usec\");\n\tif (child_usage <= 0)\n\t\tgoto cleanup;\n\tif (!values_close(child_usage, nested_leaf_usage, 1))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\ncleanup:\n\tfor (i = 0; i < ARRAY_SIZE(leaf); i++) {\n\t\tcg_destroy(leaf[i].cgroup);\n\t\tfree(leaf[i].cgroup);\n\t}\n\tcg_destroy(child);\n\tfree(child);\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\n \nstatic int\ntest_cpucg_nested_weight_overprovisioned(const char *root)\n{\n\treturn run_cpucg_nested_weight_test(root, true);\n}\n\n \nstatic int\ntest_cpucg_nested_weight_underprovisioned(const char *root)\n{\n\treturn run_cpucg_nested_weight_test(root, false);\n}\n\n \nstatic int test_cpucg_max(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tlong usage_usec, user_usec;\n\tlong usage_seconds = 1;\n\tlong expected_usage_usec = usage_seconds * USEC_PER_SEC;\n\tchar *cpucg;\n\n\tcpucg = cg_name(root, \"cpucg_test\");\n\tif (!cpucg)\n\t\tgoto cleanup;\n\n\tif (cg_create(cpucg))\n\t\tgoto cleanup;\n\n\tif (cg_write(cpucg, \"cpu.max\", \"1000\"))\n\t\tgoto cleanup;\n\n\tstruct cpu_hog_func_param param = {\n\t\t.nprocs = 1,\n\t\t.ts = {\n\t\t\t.tv_sec = usage_seconds,\n\t\t\t.tv_nsec = 0,\n\t\t},\n\t\t.clock_type = CPU_HOG_CLOCK_WALL,\n\t};\n\tif (cg_run(cpucg, hog_cpus_timed, (void *)&param))\n\t\tgoto cleanup;\n\n\tusage_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"usage_usec\");\n\tuser_usec = cg_read_key_long(cpucg, \"cpu.stat\", \"user_usec\");\n\tif (user_usec <= 0)\n\t\tgoto cleanup;\n\n\tif (user_usec >= expected_usage_usec)\n\t\tgoto cleanup;\n\n\tif (values_close(usage_usec, expected_usage_usec, 95))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(cpucg);\n\tfree(cpucg);\n\n\treturn ret;\n}\n\n \nstatic int test_cpucg_max_nested(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tlong usage_usec, user_usec;\n\tlong usage_seconds = 1;\n\tlong expected_usage_usec = usage_seconds * USEC_PER_SEC;\n\tchar *parent, *child;\n\n\tparent = cg_name(root, \"cpucg_parent\");\n\tchild = cg_name(parent, \"cpucg_child\");\n\tif (!parent || !child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpu\"))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cpu.max\", \"1000\"))\n\t\tgoto cleanup;\n\n\tstruct cpu_hog_func_param param = {\n\t\t.nprocs = 1,\n\t\t.ts = {\n\t\t\t.tv_sec = usage_seconds,\n\t\t\t.tv_nsec = 0,\n\t\t},\n\t\t.clock_type = CPU_HOG_CLOCK_WALL,\n\t};\n\tif (cg_run(child, hog_cpus_timed, (void *)&param))\n\t\tgoto cleanup;\n\n\tusage_usec = cg_read_key_long(child, \"cpu.stat\", \"usage_usec\");\n\tuser_usec = cg_read_key_long(child, \"cpu.stat\", \"user_usec\");\n\tif (user_usec <= 0)\n\t\tgoto cleanup;\n\n\tif (user_usec >= expected_usage_usec)\n\t\tgoto cleanup;\n\n\tif (values_close(usage_usec, expected_usage_usec, 95))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tcg_destroy(child);\n\tfree(child);\n\tcg_destroy(parent);\n\tfree(parent);\n\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct cpucg_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_cpucg_subtree_control),\n\tT(test_cpucg_stats),\n\tT(test_cpucg_weight_overprovisioned),\n\tT(test_cpucg_weight_underprovisioned),\n\tT(test_cpucg_nested_weight_overprovisioned),\n\tT(test_cpucg_nested_weight_underprovisioned),\n\tT(test_cpucg_max),\n\tT(test_cpucg_max_nested),\n};\n#undef T\n\nint main(int argc, char *argv[])\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"cpu\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+cpu\"))\n\t\t\tksft_exit_skip(\"Failed to set cpu controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}