{
  "module_name": "test_cpuset.c",
  "hash_id": "3f7bcf5aa45ccf48e7195b21e1c651da4fc7fad78a4d78ddaa638498374a8777",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_cpuset.c",
  "human_readable_source": "\n\n#include <linux/limits.h>\n#include <signal.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\nstatic int idle_process_fn(const char *cgroup, void *arg)\n{\n\t(void)pause();\n\treturn 0;\n}\n\nstatic int do_migration_fn(const char *cgroup, void *arg)\n{\n\tint object_pid = (int)(size_t)arg;\n\n\tif (setuid(TEST_UID))\n\t\treturn EXIT_FAILURE;\n\n\t\n\tif (cg_enter(cgroup, object_pid) ||\n\t    cg_wait_for_proc_count(cgroup, 1))\n\t\treturn EXIT_FAILURE;\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic int do_controller_fn(const char *cgroup, void *arg)\n{\n\tconst char *child = cgroup;\n\tconst char *parent = arg;\n\n\tif (setuid(TEST_UID))\n\t\treturn EXIT_FAILURE;\n\n\tif (!cg_read_strstr(child, \"cgroup.controllers\", \"cpuset\"))\n\t\treturn EXIT_FAILURE;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpuset\"))\n\t\treturn EXIT_FAILURE;\n\n\tif (cg_read_strstr(child, \"cgroup.controllers\", \"cpuset\"))\n\t\treturn EXIT_FAILURE;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"-cpuset\"))\n\t\treturn EXIT_FAILURE;\n\n\tif (!cg_read_strstr(child, \"cgroup.controllers\", \"cpuset\"))\n\t\treturn EXIT_FAILURE;\n\n\treturn EXIT_SUCCESS;\n}\n\n \nstatic int test_cpuset_perms_object(const char *root, bool allow)\n{\n\tchar *parent = NULL, *child_src = NULL, *child_dst = NULL;\n\tchar *parent_procs = NULL, *child_src_procs = NULL, *child_dst_procs = NULL;\n\tconst uid_t test_euid = TEST_UID;\n\tint object_pid = 0;\n\tint ret = KSFT_FAIL;\n\n\tparent = cg_name(root, \"cpuset_test_0\");\n\tif (!parent)\n\t\tgoto cleanup;\n\tparent_procs = cg_name(parent, \"cgroup.procs\");\n\tif (!parent_procs)\n\t\tgoto cleanup;\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tchild_src = cg_name(parent, \"cpuset_test_1\");\n\tif (!child_src)\n\t\tgoto cleanup;\n\tchild_src_procs = cg_name(child_src, \"cgroup.procs\");\n\tif (!child_src_procs)\n\t\tgoto cleanup;\n\tif (cg_create(child_src))\n\t\tgoto cleanup;\n\n\tchild_dst = cg_name(parent, \"cpuset_test_2\");\n\tif (!child_dst)\n\t\tgoto cleanup;\n\tchild_dst_procs = cg_name(child_dst, \"cgroup.procs\");\n\tif (!child_dst_procs)\n\t\tgoto cleanup;\n\tif (cg_create(child_dst))\n\t\tgoto cleanup;\n\n\tif (cg_write(parent, \"cgroup.subtree_control\", \"+cpuset\"))\n\t\tgoto cleanup;\n\n\tif (cg_read_strstr(child_src, \"cgroup.controllers\", \"cpuset\") ||\n\t    cg_read_strstr(child_dst, \"cgroup.controllers\", \"cpuset\"))\n\t\tgoto cleanup;\n\n\t \n\tif (chown(child_src_procs, test_euid, -1) ||\n\t    chown(child_dst_procs, test_euid, -1))\n\t\tgoto cleanup;\n\n\tif (allow && chown(parent_procs, test_euid, -1))\n\t\tgoto cleanup;\n\n\t \n\tobject_pid = cg_run_nowait(child_src, idle_process_fn, NULL);\n\tif (object_pid < 0)\n\t\tgoto cleanup;\n\n\t \n\tif (allow ^ (cg_run(child_dst, do_migration_fn, (void *)(size_t)object_pid) == EXIT_SUCCESS))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (object_pid > 0) {\n\t\t(void)kill(object_pid, SIGTERM);\n\t\t(void)clone_reap(object_pid, WEXITED);\n\t}\n\n\tcg_destroy(child_dst);\n\tfree(child_dst_procs);\n\tfree(child_dst);\n\n\tcg_destroy(child_src);\n\tfree(child_src_procs);\n\tfree(child_src);\n\n\tcg_destroy(parent);\n\tfree(parent_procs);\n\tfree(parent);\n\n\treturn ret;\n}\n\nstatic int test_cpuset_perms_object_allow(const char *root)\n{\n\treturn test_cpuset_perms_object(root, true);\n}\n\nstatic int test_cpuset_perms_object_deny(const char *root)\n{\n\treturn test_cpuset_perms_object(root, false);\n}\n\n \nstatic int test_cpuset_perms_subtree(const char *root)\n{\n\tchar *parent = NULL, *child = NULL;\n\tchar *parent_procs = NULL, *parent_subctl = NULL, *child_procs = NULL;\n\tconst uid_t test_euid = TEST_UID;\n\tint object_pid = 0;\n\tint ret = KSFT_FAIL;\n\n\tparent = cg_name(root, \"cpuset_test_0\");\n\tif (!parent)\n\t\tgoto cleanup;\n\tparent_procs = cg_name(parent, \"cgroup.procs\");\n\tif (!parent_procs)\n\t\tgoto cleanup;\n\tparent_subctl = cg_name(parent, \"cgroup.subtree_control\");\n\tif (!parent_subctl)\n\t\tgoto cleanup;\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tchild = cg_name(parent, \"cpuset_test_1\");\n\tif (!child)\n\t\tgoto cleanup;\n\tchild_procs = cg_name(child, \"cgroup.procs\");\n\tif (!child_procs)\n\t\tgoto cleanup;\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\t \n\tif (chown(parent_procs, test_euid, -1) ||\n\t    chown(parent_subctl, test_euid, -1) ||\n\t    chown(child_procs, test_euid, -1))\n\t\tgoto cleanup;\n\n\t \n\tobject_pid = cg_run_nowait(child, idle_process_fn, NULL);\n\tif (object_pid < 0)\n\t\tgoto cleanup;\n\n\tif (cg_run(child, do_controller_fn, parent) != EXIT_SUCCESS)\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (object_pid > 0) {\n\t\t(void)kill(object_pid, SIGTERM);\n\t\t(void)clone_reap(object_pid, WEXITED);\n\t}\n\n\tcg_destroy(child);\n\tfree(child_procs);\n\tfree(child);\n\n\tcg_destroy(parent);\n\tfree(parent_subctl);\n\tfree(parent_procs);\n\tfree(parent);\n\n\treturn ret;\n}\n\n\n#define T(x) { x, #x }\nstruct cpuset_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_cpuset_perms_object_allow),\n\tT(test_cpuset_perms_object_deny),\n\tT(test_cpuset_perms_subtree),\n};\n#undef T\n\nint main(int argc, char *argv[])\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\n\tif (cg_read_strstr(root, \"cgroup.subtree_control\", \"cpuset\"))\n\t\tif (cg_write(root, \"cgroup.subtree_control\", \"+cpuset\"))\n\t\t\tksft_exit_skip(\"Failed to set cpuset controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}