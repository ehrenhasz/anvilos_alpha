{
  "module_name": "test_freezer.c",
  "hash_id": "d7f61cc979bf0cabb1c749097e21e352e21374af63b0db9a7b0e224c597aaa85",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cgroup/test_freezer.c",
  "human_readable_source": " \n#include <stdbool.h>\n#include <linux/limits.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n\n#include \"../kselftest.h\"\n#include \"cgroup_util.h\"\n\n#define DEBUG\n#ifdef DEBUG\n#define debug(args...) fprintf(stderr, args)\n#else\n#define debug(args...)\n#endif\n\n \nstatic int cg_check_frozen(const char *cgroup, bool frozen)\n{\n\tif (frozen) {\n\t\tif (cg_read_strstr(cgroup, \"cgroup.events\", \"frozen 1\") != 0) {\n\t\t\tdebug(\"Cgroup %s isn't frozen\\n\", cgroup);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (cg_read_strstr(cgroup, \"cgroup.events\", \"frozen 0\") != 0) {\n\t\t\tdebug(\"Cgroup %s is frozen\\n\", cgroup);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cg_freeze_nowait(const char *cgroup, bool freeze)\n{\n\treturn cg_write(cgroup, \"cgroup.freeze\", freeze ? \"1\" : \"0\");\n}\n\n \nstatic int cg_enter_and_wait_for_frozen(const char *cgroup, int pid,\n\t\t\t\t\tbool frozen)\n{\n\tint fd, ret = -1;\n\tint attempts;\n\n\tfd = cg_prepare_for_wait(cgroup);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = cg_enter(cgroup, pid);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (attempts = 0; attempts < 10; attempts++) {\n\t\tret = cg_wait_for(fd);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = cg_check_frozen(cgroup, frozen);\n\t\tif (ret)\n\t\t\tcontinue;\n\t}\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\n \nstatic int cg_freeze_wait(const char *cgroup, bool freeze)\n{\n\tint fd, ret = -1;\n\n\tfd = cg_prepare_for_wait(cgroup);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = cg_freeze_nowait(cgroup, freeze);\n\tif (ret) {\n\t\tdebug(\"Error: cg_freeze_nowait() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = cg_wait_for(fd);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cg_check_frozen(cgroup, freeze);\nout:\n\tclose(fd);\n\treturn ret;\n}\n\n \nstatic int child_fn(const char *cgroup, void *arg)\n{\n\tint ppid = getppid();\n\n\twhile (getppid() == ppid)\n\t\tusleep(1000);\n\n\treturn getppid() == ppid;\n}\n\n \nstatic int test_cgfreezer_simple(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\tint i;\n\n\tcgroup = cg_name(root, \"cg_test_simple\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 100; i++)\n\t\tcg_run_nowait(cgroup, child_fn, NULL);\n\n\tif (cg_wait_for_proc_count(cgroup, 100))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup, false))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, false))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_tree(const char *root)\n{\n\tchar *cgroup[10] = {0};\n\tint ret = KSFT_FAIL;\n\tint i;\n\n\tcgroup[0] = cg_name(root, \"cg_test_tree_A\");\n\tif (!cgroup[0])\n\t\tgoto cleanup;\n\n\tcgroup[1] = cg_name(cgroup[0], \"B\");\n\tif (!cgroup[1])\n\t\tgoto cleanup;\n\n\tcgroup[2] = cg_name(cgroup[1], \"C\");\n\tif (!cgroup[2])\n\t\tgoto cleanup;\n\n\tcgroup[3] = cg_name(cgroup[1], \"D\");\n\tif (!cgroup[3])\n\t\tgoto cleanup;\n\n\tcgroup[4] = cg_name(cgroup[0], \"E\");\n\tif (!cgroup[4])\n\t\tgoto cleanup;\n\n\tcgroup[5] = cg_name(cgroup[4], \"F\");\n\tif (!cgroup[5])\n\t\tgoto cleanup;\n\n\tcgroup[6] = cg_name(cgroup[5], \"G\");\n\tif (!cgroup[6])\n\t\tgoto cleanup;\n\n\tcgroup[7] = cg_name(cgroup[6], \"H\");\n\tif (!cgroup[7])\n\t\tgoto cleanup;\n\n\tcgroup[8] = cg_name(cgroup[0], \"I\");\n\tif (!cgroup[8])\n\t\tgoto cleanup;\n\n\tcgroup[9] = cg_name(cgroup[0], \"K\");\n\tif (!cgroup[9])\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 10; i++)\n\t\tif (cg_create(cgroup[i]))\n\t\t\tgoto cleanup;\n\n\tcg_run_nowait(cgroup[2], child_fn, NULL);\n\tcg_run_nowait(cgroup[7], child_fn, NULL);\n\tcg_run_nowait(cgroup[9], child_fn, NULL);\n\tcg_run_nowait(cgroup[9], child_fn, NULL);\n\tcg_run_nowait(cgroup[9], child_fn, NULL);\n\n\t \n\n\tif (cg_wait_for_proc_count(cgroup[2], 1) ||\n\t    cg_wait_for_proc_count(cgroup[7], 1) ||\n\t    cg_wait_for_proc_count(cgroup[9], 3))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[1], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[5], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[6], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_check_frozen(cgroup[0], false))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[4], false))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[0], true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[1], true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[4], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_nowait(cgroup[1], false))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_nowait(cgroup[5], false))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_nowait(cgroup[6], false))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_check_frozen(cgroup[2], true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[7], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[0], false))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[2], false))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[9], false))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tfor (i = 9; i >= 0 && cgroup[i]; i--) {\n\t\tcg_destroy(cgroup[i]);\n\t\tfree(cgroup[i]);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int forkbomb_fn(const char *cgroup, void *arg)\n{\n\tint ppid;\n\n\tfork();\n\tfork();\n\n\tppid = getppid();\n\n\twhile (getppid() == ppid)\n\t\tusleep(1000);\n\n\treturn getppid() == ppid;\n}\n\n \nstatic int test_cgfreezer_forkbomb(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\n\tcgroup = cg_name(root, \"cg_forkbomb_test\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tcg_run_nowait(cgroup, forkbomb_fn, NULL);\n\n\tusleep(100000);\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\tif (cg_killall(cgroup))\n\t\tgoto cleanup;\n\n\tif (cg_wait_for_proc_count(cgroup, 0))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_mkdir(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent, *child = NULL;\n\tint pid;\n\n\tparent = cg_name(root, \"cg_test_mkdir_A\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tchild = cg_name(parent, \"cg_test_mkdir_B\");\n\tif (!child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(parent, true))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(child, child_fn, NULL);\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tif (cg_wait_for_proc_count(child, 1))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(child, true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(parent, true))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tfree(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(parent);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_rmdir(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *parent, *child = NULL;\n\n\tparent = cg_name(root, \"cg_test_rmdir_A\");\n\tif (!parent)\n\t\tgoto cleanup;\n\n\tchild = cg_name(parent, \"cg_test_rmdir_B\");\n\tif (!child)\n\t\tgoto cleanup;\n\n\tif (cg_create(parent))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(parent, true))\n\t\tgoto cleanup;\n\n\tif (cg_destroy(child))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(parent, true))\n\t\tgoto cleanup;\n\n\tif (cg_create(child))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(child, true))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (child)\n\t\tcg_destroy(child);\n\tfree(child);\n\tif (parent)\n\t\tcg_destroy(parent);\n\tfree(parent);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_migrate(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup[2] = {0};\n\tint pid;\n\n\tcgroup[0] = cg_name(root, \"cg_test_migrate_A\");\n\tif (!cgroup[0])\n\t\tgoto cleanup;\n\n\tcgroup[1] = cg_name(root, \"cg_test_migrate_B\");\n\tif (!cgroup[1])\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup[0]))\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup[1]))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(cgroup[0], child_fn, NULL);\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tif (cg_wait_for_proc_count(cgroup[0], 1))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[1], true))\n\t\tgoto cleanup;\n\n\tif (cg_enter_and_wait_for_frozen(cgroup[1], pid, true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[0], false))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_enter_and_wait_for_frozen(cgroup[0], pid, false))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[1], true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup[0], true))\n\t\tgoto cleanup;\n\n\tif (cg_enter_and_wait_for_frozen(cgroup[1], pid, true))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup[0], true))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup[0])\n\t\tcg_destroy(cgroup[0]);\n\tfree(cgroup[0]);\n\tif (cgroup[1])\n\t\tcg_destroy(cgroup[1]);\n\tfree(cgroup[1]);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_ptrace(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\tsiginfo_t siginfo;\n\tint pid;\n\n\tcgroup = cg_name(root, \"cg_test_ptrace\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(cgroup, child_fn, NULL);\n\tif (pid < 0)\n\t\tgoto cleanup;\n\n\tif (cg_wait_for_proc_count(cgroup, 1))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_SEIZE, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_INTERRUPT, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\twaitpid(pid, NULL, 0);\n\n\t \n\tif (cg_check_frozen(cgroup, true))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &siginfo))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_DETACH, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup, true))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n \nstatic int proc_check_stopped(int pid)\n{\n\tchar buf[PAGE_SIZE];\n\tint len;\n\n\tlen = proc_read_text(pid, 0, \"stat\", buf, sizeof(buf));\n\tif (len == -1) {\n\t\tdebug(\"Can't get %d stat\\n\", pid);\n\t\treturn -1;\n\t}\n\n\tif (strstr(buf, \"(test_freezer) T \") == NULL) {\n\t\tdebug(\"Process %d in the unexpected state: %s\\n\", pid, buf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int test_cgfreezer_stopped(const char *root)\n{\n\tint pid, ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\n\tcgroup = cg_name(root, \"cg_test_stopped\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(cgroup, child_fn, NULL);\n\n\tif (cg_wait_for_proc_count(cgroup, 1))\n\t\tgoto cleanup;\n\n\tif (kill(pid, SIGSTOP))\n\t\tgoto cleanup;\n\n\tif (cg_check_frozen(cgroup, false))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, false))\n\t\tgoto cleanup;\n\n\tif (proc_check_stopped(pid))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n \nstatic int test_cgfreezer_ptraced(const char *root)\n{\n\tint pid, ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\tsiginfo_t siginfo;\n\n\tcgroup = cg_name(root, \"cg_test_ptraced\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tpid = cg_run_nowait(cgroup, child_fn, NULL);\n\n\tif (cg_wait_for_proc_count(cgroup, 1))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_SEIZE, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_INTERRUPT, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\twaitpid(pid, NULL, 0);\n\n\tif (cg_check_frozen(cgroup, false))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\t \n\tif (cg_freeze_wait(cgroup, false))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &siginfo))\n\t\tgoto cleanup;\n\n\tif (ptrace(PTRACE_DETACH, pid, NULL, NULL))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\nstatic int vfork_fn(const char *cgroup, void *arg)\n{\n\tint pid = vfork();\n\n\tif (pid == 0)\n\t\twhile (true)\n\t\t\tsleep(1);\n\n\treturn pid;\n}\n\n \nstatic int test_cgfreezer_vfork(const char *root)\n{\n\tint ret = KSFT_FAIL;\n\tchar *cgroup = NULL;\n\n\tcgroup = cg_name(root, \"cg_test_vfork\");\n\tif (!cgroup)\n\t\tgoto cleanup;\n\n\tif (cg_create(cgroup))\n\t\tgoto cleanup;\n\n\tcg_run_nowait(cgroup, vfork_fn, NULL);\n\n\tif (cg_wait_for_proc_count(cgroup, 2))\n\t\tgoto cleanup;\n\n\tif (cg_freeze_wait(cgroup, true))\n\t\tgoto cleanup;\n\n\tret = KSFT_PASS;\n\ncleanup:\n\tif (cgroup)\n\t\tcg_destroy(cgroup);\n\tfree(cgroup);\n\treturn ret;\n}\n\n#define T(x) { x, #x }\nstruct cgfreezer_test {\n\tint (*fn)(const char *root);\n\tconst char *name;\n} tests[] = {\n\tT(test_cgfreezer_simple),\n\tT(test_cgfreezer_tree),\n\tT(test_cgfreezer_forkbomb),\n\tT(test_cgfreezer_mkdir),\n\tT(test_cgfreezer_rmdir),\n\tT(test_cgfreezer_migrate),\n\tT(test_cgfreezer_ptrace),\n\tT(test_cgfreezer_stopped),\n\tT(test_cgfreezer_ptraced),\n\tT(test_cgfreezer_vfork),\n};\n#undef T\n\nint main(int argc, char *argv[])\n{\n\tchar root[PATH_MAX];\n\tint i, ret = EXIT_SUCCESS;\n\n\tif (cg_find_unified_root(root, sizeof(root)))\n\t\tksft_exit_skip(\"cgroup v2 isn't mounted\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tswitch (tests[i].fn(root)) {\n\t\tcase KSFT_PASS:\n\t\t\tksft_test_result_pass(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tcase KSFT_SKIP:\n\t\t\tksft_test_result_skip(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EXIT_FAILURE;\n\t\t\tksft_test_result_fail(\"%s\\n\", tests[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}