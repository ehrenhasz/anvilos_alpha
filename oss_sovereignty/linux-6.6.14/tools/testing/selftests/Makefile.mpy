{
  "module_name": "Makefile",
  "hash_id": "1c785e9b96bb82812983437cd7a1ea64c9df9e56521371fe8340aaefac4a10db",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\nTARGETS += alsa\nTARGETS += amd-pstate\nTARGETS += arm64\nTARGETS += bpf\nTARGETS += breakpoints\nTARGETS += cachestat\nTARGETS += capabilities\nTARGETS += cgroup\nTARGETS += clone3\nTARGETS += connector\nTARGETS += core\nTARGETS += cpufreq\nTARGETS += cpu-hotplug\nTARGETS += damon\nTARGETS += dmabuf-heaps\nTARGETS += drivers/dma-buf\nTARGETS += drivers/s390x/uvdevice\nTARGETS += drivers/net/bonding\nTARGETS += drivers/net/team\nTARGETS += efivarfs\nTARGETS += exec\nTARGETS += fchmodat2\nTARGETS += filesystems\nTARGETS += filesystems/binderfs\nTARGETS += filesystems/epoll\nTARGETS += filesystems/fat\nTARGETS += firmware\nTARGETS += fpu\nTARGETS += ftrace\nTARGETS += futex\nTARGETS += gpio\nTARGETS += hid\nTARGETS += intel_pstate\nTARGETS += iommu\nTARGETS += ipc\nTARGETS += ir\nTARGETS += kcmp\nTARGETS += kexec\nTARGETS += kvm\nTARGETS += landlock\nTARGETS += lib\nTARGETS += livepatch\nTARGETS += lkdtm\nTARGETS += membarrier\nTARGETS += memfd\nTARGETS += memory-hotplug\nTARGETS += mincore\nTARGETS += mount\nTARGETS += mount_setattr\nTARGETS += move_mount_set_group\nTARGETS += mqueue\nTARGETS += nci\nTARGETS += net\nTARGETS += net/af_unix\nTARGETS += net/forwarding\nTARGETS += net/hsr\nTARGETS += net/mptcp\nTARGETS += net/openvswitch\nTARGETS += netfilter\nTARGETS += nsfs\nTARGETS += perf_events\nTARGETS += pidfd\nTARGETS += pid_namespace\nTARGETS += powerpc\nTARGETS += prctl\nTARGETS += proc\nTARGETS += pstore\nTARGETS += ptrace\nTARGETS += openat2\nTARGETS += resctrl\nTARGETS += riscv\nTARGETS += rlimits\nTARGETS += rseq\nTARGETS += rtc\nTARGETS += seccomp\nTARGETS += sgx\nTARGETS += sigaltstack\nTARGETS += size\nTARGETS += sparc64\nTARGETS += splice\nTARGETS += static_keys\nTARGETS += sync\nTARGETS += syscall_user_dispatch\nTARGETS += sysctl\nTARGETS += tc-testing\nTARGETS += tdx\nTARGETS += timens\nifneq (1, $(quicktest))\nTARGETS += timers\nendif\nTARGETS += tmpfs\nTARGETS += tpm2\nTARGETS += tty\nTARGETS += uevent\nTARGETS += user\nTARGETS += user_events\nTARGETS += vDSO\nTARGETS += mm\nTARGETS += x86\nTARGETS += zram\n#Please keep the TARGETS list alphabetically sorted\n# Run \"make quicktest=1 run_tests\" or\n# \"make quicktest=1 kselftest\" from top level Makefile\n\nTARGETS_HOTPLUG = cpu-hotplug\nTARGETS_HOTPLUG += memory-hotplug\n\n# User can optionally provide a TARGETS skiplist.  By default we skip\n# BPF since it has cutting edge build time dependencies which require\n# more effort to install.\nSKIP_TARGETS ?= bpf\nifneq ($(SKIP_TARGETS),)\n\tTMP := $(filter-out $(SKIP_TARGETS), $(TARGETS))\n\toverride TARGETS := $(TMP)\nendif\n\n# User can set FORCE_TARGETS to 1 to require all targets to be successfully\n# built; make will fail if any of the targets cannot be built. If\n# FORCE_TARGETS is not set (the default), make will succeed if at least one\n# of the targets gets built.\nFORCE_TARGETS ?=\n\n# Clear LDFLAGS and MAKEFLAGS when implicit rules are missing.  This provides\n# implicit rules to sub-test Makefiles which avoids build failures in test\n# Makefile that don't have explicit build rules.\nifeq (,$(LINK.c))\noverride LDFLAGS =\noverride MAKEFLAGS =\nendif\n\n# Append kselftest to KBUILD_OUTPUT and O to avoid cluttering\n# KBUILD_OUTPUT with selftest objects and headers installed\n# by selftests Makefile or lib.mk.\nifdef building_out_of_srctree\noverride LDFLAGS =\nendif\n\ntop_srcdir ?= ../../..\n\nifeq (\"$(origin O)\", \"command line\")\n  KBUILD_OUTPUT := $(O)\nendif\n\nifneq ($(KBUILD_OUTPUT),)\n  # Make's built-in functions such as $(abspath ...), $(realpath ...) cannot\n  # expand a shell special character '~'. We use a somewhat tedious way here.\n  abs_objtree := $(shell cd $(top_srcdir) && mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) && pwd)\n  $(if $(abs_objtree),, \\\n    $(error failed to create output directory \"$(KBUILD_OUTPUT)\"))\n  # $(realpath ...) resolves symlinks\n  abs_objtree := $(realpath $(abs_objtree))\n  BUILD := $(abs_objtree)/kselftest\n  KHDR_INCLUDES := -isystem ${abs_objtree}/usr/include\nelse\n  BUILD := $(CURDIR)\n  abs_srctree := $(shell cd $(top_srcdir) && pwd)\n  KHDR_INCLUDES := -isystem ${abs_srctree}/usr/include\n  DEFAULT_INSTALL_HDR_PATH := 1\nendif\n\n# Prepare for headers install\ninclude $(top_srcdir)/scripts/subarch.include\nARCH           ?= $(SUBARCH)\nexport BUILD\nexport KHDR_INCLUDES\n\n# set default goal to all, so make without a target runs all, even when\n# all isn't the first target in the file.\n.DEFAULT_GOAL := all\n\nall:\n\t@ret=1;\t\t\t\t\t\t\t\\\n\tfor TARGET in $(TARGETS); do\t\t\t\t\\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\t\t\\\n\t\tmkdir $$BUILD_TARGET  -p;\t\t\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET\t\\\n\t\t\t\tO=$(abs_objtree)\t\t\\\n\t\t\t\t$(if $(FORCE_TARGETS),|| exit);\t\\\n\t\tret=$$((ret * $$?));\t\t\t\t\\\n\tdone; exit $$ret;\n\nrun_tests: all\n\t@for TARGET in $(TARGETS); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET run_tests \\\n\t\t\t\tO=$(abs_objtree);\t\t    \\\n\tdone;\n\nhotplug:\n\t@for TARGET in $(TARGETS_HOTPLUG); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET;\\\n\tdone;\n\nrun_hotplug: hotplug\n\t@for TARGET in $(TARGETS_HOTPLUG); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET run_full_test;\\\n\tdone;\n\nclean_hotplug:\n\t@for TARGET in $(TARGETS_HOTPLUG); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET clean;\\\n\tdone;\n\nrun_pstore_crash:\n\t$(MAKE) -C pstore run_crash\n\n# Use $BUILD as the default install root. $BUILD points to the\n# right output location for the following cases:\n# 1. output_dir=kernel_src\n# 2. a separate output directory is specified using O= KBUILD_OUTPUT\n# 3. a separate output directory is specified using KBUILD_OUTPUT\n# Avoid conflict with INSTALL_PATH set by the main Makefile\n#\nKSFT_INSTALL_PATH ?= $(BUILD)/kselftest_install\nKSFT_INSTALL_PATH := $(abspath $(KSFT_INSTALL_PATH))\n# Avoid changing the rest of the logic here and lib.mk.\nINSTALL_PATH := $(KSFT_INSTALL_PATH)\nALL_SCRIPT := $(INSTALL_PATH)/run_kselftest.sh\nTEST_LIST := $(INSTALL_PATH)/kselftest-list.txt\n\ninstall: all\nifdef INSTALL_PATH\n\t@# Ask all targets to install their files\n\tmkdir -p $(INSTALL_PATH)/kselftest\n\tinstall -m 744 kselftest/module.sh $(INSTALL_PATH)/kselftest/\n\tinstall -m 744 kselftest/runner.sh $(INSTALL_PATH)/kselftest/\n\tinstall -m 744 kselftest/prefix.pl $(INSTALL_PATH)/kselftest/\n\tinstall -m 744 run_kselftest.sh $(INSTALL_PATH)/\n\trm -f $(TEST_LIST)\n\t@ret=1;\t\\\n\tfor TARGET in $(TARGETS); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET INSTALL_PATH=$(INSTALL_PATH)/$$TARGET install \\\n\t\t\t\tO=$(abs_objtree)\t\t\\\n\t\t\t\t$(if $(FORCE_TARGETS),|| exit);\t\\\n\t\tret=$$((ret * $$?));\t\t\\\n\tdone; exit $$ret;\n\n\n\t@# Ask all targets to emit their test scripts\n\t@# While building kselftest-list.text skip also non-existent TARGET dirs:\n\t@# they could be the result of a build failure and should NOT be\n\t@# included in the generated runlist.\n\tfor TARGET in $(TARGETS); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t[ ! -d $(INSTALL_PATH)/$$TARGET ] && printf \"Skipping non-existent dir: $$TARGET\\n\" && continue; \\\n\t\tprintf \"Emit Tests for $$TARGET\\n\"; \\\n\t\t$(MAKE) -s --no-print-directory OUTPUT=$$BUILD_TARGET COLLECTION=$$TARGET \\\n\t\t\t-C $$TARGET emit_tests >> $(TEST_LIST); \\\n\tdone;\nelse\n\t$(error Error: set INSTALL_PATH to use install)\nendif\n\nFORMAT ?= .gz\nTAR_PATH = $(abspath ${INSTALL_PATH}/kselftest-packages/kselftest.tar${FORMAT})\ngen_tar: install\n\t@mkdir -p ${INSTALL_PATH}/kselftest-packages/\n\t@tar caf ${TAR_PATH} --exclude=kselftest-packages -C ${INSTALL_PATH} .\n\t@echo \"Created ${TAR_PATH}\"\n\nclean:\n\t@for TARGET in $(TARGETS); do \\\n\t\tBUILD_TARGET=$$BUILD/$$TARGET;\t\\\n\t\t$(MAKE) OUTPUT=$$BUILD_TARGET -C $$TARGET clean;\\\n\tdone;\n\n.PHONY: all run_tests hotplug run_hotplug clean_hotplug run_pstore_crash install clean gen_tar\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}