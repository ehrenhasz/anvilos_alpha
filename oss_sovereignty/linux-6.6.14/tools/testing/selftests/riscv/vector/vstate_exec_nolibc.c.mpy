{
  "module_name": "vstate_exec_nolibc.c",
  "hash_id": "bee4642db0c10c93a5253c4a574893f5e99beaacba6700ca9b815164061f9211",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/riscv/vector/vstate_exec_nolibc.c",
  "human_readable_source": "\n#define THIS_PROGRAM \"./vstate_exec_nolibc\"\n\nint main(int argc, char **argv)\n{\n\tint rc, pid, status, test_inherit = 0;\n\tlong ctrl, ctrl_c;\n\tchar *exec_argv[2], *exec_envp[2];\n\n\tif (argc > 1)\n\t\ttest_inherit = 1;\n\n\tctrl = my_syscall1(__NR_prctl, PR_RISCV_V_GET_CONTROL);\n\tif (ctrl < 0) {\n\t\tputs(\"PR_RISCV_V_GET_CONTROL is not supported\\n\");\n\t\treturn ctrl;\n\t}\n\n\tif (test_inherit) {\n\t\tpid = fork();\n\t\tif (pid == -1) {\n\t\t\tputs(\"fork failed\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\t \n\t\tif (!pid) {\n\t\t\texec_argv[0] = THIS_PROGRAM;\n\t\t\texec_argv[1] = NULL;\n\t\t\texec_envp[0] = NULL;\n\t\t\texec_envp[1] = NULL;\n\t\t\t \n\t\t\trc = execve(THIS_PROGRAM, exec_argv, exec_envp);\n\t\t\tif (rc) {\n\t\t\t\tputs(\"child execve failed\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tpid = fork();\n\t\tif (pid == -1) {\n\t\t\tputs(\"fork failed\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\tif (!pid) {\n\t\t\trc = my_syscall1(__NR_prctl, PR_RISCV_V_GET_CONTROL);\n\t\t\tif (rc != ctrl) {\n\t\t\t\tputs(\"child's vstate_ctrl not equal to parent's\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t\tasm volatile (\".option push\\n\\t\"\n\t\t\t\t      \".option arch, +v\\n\\t\"\n\t\t\t\t      \"vsetvli x0, x0, e32, m8, ta, ma\\n\\t\"\n\t\t\t\t      \".option pop\\n\\t\"\n\t\t\t\t      );\n\t\t\texit(ctrl);\n\t\t}\n\t}\n\n\trc = waitpid(-1, &status, 0);\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == -1) {\n\t\tputs(\"child exited abnormally\\n\");\n\t\texit(-1);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tif (WTERMSIG(status) != SIGILL) {\n\t\t\tputs(\"child was terminated by unexpected signal\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\tif ((ctrl & PR_RISCV_V_VSTATE_CTRL_CUR_MASK) != PR_RISCV_V_VSTATE_CTRL_OFF) {\n\t\t\tputs(\"child signaled by illegal V access but vstate_ctrl is not off\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\t \n\t\texit(ctrl);\n\t}\n\n\tctrl_c = WEXITSTATUS(status);\n\tif (test_inherit) {\n\t\tif (ctrl & PR_RISCV_V_VSTATE_CTRL_INHERIT) {\n\t\t\tif (!(ctrl_c & PR_RISCV_V_VSTATE_CTRL_INHERIT)) {\n\t\t\t\tputs(\"parent has inherit bit, but child has not\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t}\n\t\trc = (ctrl & PR_RISCV_V_VSTATE_CTRL_NEXT_MASK) >> 2;\n\t\tif (rc != PR_RISCV_V_VSTATE_CTRL_DEFAULT) {\n\t\t\tif (rc != (ctrl_c & PR_RISCV_V_VSTATE_CTRL_CUR_MASK)) {\n\t\t\t\tputs(\"parent's next setting does not equal to child's\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\n\t\t\tif (!(ctrl & PR_RISCV_V_VSTATE_CTRL_INHERIT)) {\n\t\t\t\tif ((ctrl_c & PR_RISCV_V_VSTATE_CTRL_NEXT_MASK) !=\n\t\t\t\t    PR_RISCV_V_VSTATE_CTRL_DEFAULT) {\n\t\t\t\t\tputs(\"must clear child's next vstate_ctrl if !inherit\\n\");\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ctrl;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}