{
  "module_name": "vstate_prctl.c",
  "hash_id": "0f79ba7b34624af25e3386bdda075033883744007eb813e4c725d7b9103b90da",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/riscv/vector/vstate_prctl.c",
  "human_readable_source": "\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <asm/hwprobe.h>\n#include <errno.h>\n#include <sys/wait.h>\n\n#include \"../../kselftest.h\"\n\n \nlong riscv_hwprobe(struct riscv_hwprobe *pairs, size_t pair_count,\n\t\t   size_t cpu_count, unsigned long *cpus, unsigned int flags);\n\n#define NEXT_PROGRAM \"./vstate_exec_nolibc\"\nstatic int launch_test(int test_inherit)\n{\n\tchar *exec_argv[3], *exec_envp[1];\n\tint rc, pid, status;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tksft_test_result_fail(\"fork failed %d\", pid);\n\t\treturn -1;\n\t}\n\n\tif (!pid) {\n\t\texec_argv[0] = NEXT_PROGRAM;\n\t\texec_argv[1] = test_inherit != 0 ? \"x\" : NULL;\n\t\texec_argv[2] = NULL;\n\t\texec_envp[0] = NULL;\n\t\t \n\t\trc = execve(NEXT_PROGRAM, exec_argv, exec_envp);\n\t\tif (rc) {\n\t\t\tperror(\"execve\");\n\t\t\tksft_test_result_fail(\"child execve failed %d\\n\", rc);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\trc = waitpid(-1, &status, 0);\n\tif (rc < 0) {\n\t\tksft_test_result_fail(\"waitpid failed\\n\");\n\t\treturn -3;\n\t}\n\n\tif ((WIFEXITED(status) && WEXITSTATUS(status) == -1) ||\n\t    WIFSIGNALED(status)) {\n\t\tksft_test_result_fail(\"child exited abnormally\\n\");\n\t\treturn -4;\n\t}\n\n\treturn WEXITSTATUS(status);\n}\n\nint test_and_compare_child(long provided, long expected, int inherit)\n{\n\tint rc;\n\n\trc = prctl(PR_RISCV_V_SET_CONTROL, provided);\n\tif (rc != 0) {\n\t\tksft_test_result_fail(\"prctl with provided arg %lx failed with code %d\\n\",\n\t\t\t\t      provided, rc);\n\t\treturn -1;\n\t}\n\trc = launch_test(inherit);\n\tif (rc != expected) {\n\t\tksft_test_result_fail(\"Test failed, check %d != %d\\n\", rc,\n\t\t\t\t      expected);\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n#define PR_RISCV_V_VSTATE_CTRL_CUR_SHIFT\t0\n#define PR_RISCV_V_VSTATE_CTRL_NEXT_SHIFT\t2\n\nint main(void)\n{\n\tstruct riscv_hwprobe pair;\n\tlong flag, expected;\n\tlong rc;\n\n\tpair.key = RISCV_HWPROBE_KEY_IMA_EXT_0;\n\trc = riscv_hwprobe(&pair, 1, 0, NULL, 0);\n\tif (rc < 0) {\n\t\tksft_test_result_fail(\"hwprobe() failed with %d\\n\", rc);\n\t\treturn -1;\n\t}\n\n\tif (pair.key != RISCV_HWPROBE_KEY_IMA_EXT_0) {\n\t\tksft_test_result_fail(\"hwprobe cannot probe RISCV_HWPROBE_KEY_IMA_EXT_0\\n\");\n\t\treturn -2;\n\t}\n\n\tif (!(pair.value & RISCV_HWPROBE_IMA_V)) {\n\t\trc = prctl(PR_RISCV_V_GET_CONTROL);\n\t\tif (rc != -1 || errno != EINVAL) {\n\t\t\tksft_test_result_fail(\"GET_CONTROL should fail on kernel/hw without V\\n\");\n\t\t\treturn -3;\n\t\t}\n\n\t\trc = prctl(PR_RISCV_V_SET_CONTROL, PR_RISCV_V_VSTATE_CTRL_ON);\n\t\tif (rc != -1 || errno != EINVAL) {\n\t\t\tksft_test_result_fail(\"GET_CONTROL should fail on kernel/hw without V\\n\");\n\t\t\treturn -4;\n\t\t}\n\n\t\tksft_test_result_skip(\"Vector not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tflag = PR_RISCV_V_VSTATE_CTRL_ON;\n\trc = prctl(PR_RISCV_V_SET_CONTROL, flag);\n\tif (rc != 0) {\n\t\tksft_test_result_fail(\"Enabling V for current should always success\\n\");\n\t\treturn -5;\n\t}\n\n\tflag = PR_RISCV_V_VSTATE_CTRL_OFF;\n\trc = prctl(PR_RISCV_V_SET_CONTROL, flag);\n\tif (rc != -1 || errno != EPERM) {\n\t\tksft_test_result_fail(\"Disabling current's V alive must fail with EPERM(%d)\\n\",\n\t\t\t\t      errno);\n\t\treturn -5;\n\t}\n\n\t \n\tflag = PR_RISCV_V_VSTATE_CTRL_ON << PR_RISCV_V_VSTATE_CTRL_NEXT_SHIFT;\n\tif (test_and_compare_child(flag, PR_RISCV_V_VSTATE_CTRL_ON, 0))\n\t\treturn -6;\n\n\t \n\tflag = PR_RISCV_V_VSTATE_CTRL_OFF << PR_RISCV_V_VSTATE_CTRL_NEXT_SHIFT;\n\tif (test_and_compare_child(flag, PR_RISCV_V_VSTATE_CTRL_OFF, 0))\n\t\treturn -7;\n\n\t \n\tflag = PR_RISCV_V_VSTATE_CTRL_ON << PR_RISCV_V_VSTATE_CTRL_NEXT_SHIFT;\n\tflag |= PR_RISCV_V_VSTATE_CTRL_INHERIT;\n\texpected = flag | PR_RISCV_V_VSTATE_CTRL_ON;\n\tif (test_and_compare_child(flag, expected, 0))\n\t\treturn -8;\n\n\tif (test_and_compare_child(flag, expected, 1))\n\t\treturn -9;\n\n\t \n\tflag = PR_RISCV_V_VSTATE_CTRL_OFF << PR_RISCV_V_VSTATE_CTRL_NEXT_SHIFT;\n\tflag |= PR_RISCV_V_VSTATE_CTRL_INHERIT;\n\texpected = flag | PR_RISCV_V_VSTATE_CTRL_OFF;\n\tif (test_and_compare_child(flag, expected, 0))\n\t\treturn -10;\n\n\tif (test_and_compare_child(flag, expected, 1))\n\t\treturn -11;\n\n\t \n\trc = prctl(PR_RISCV_V_SET_CONTROL, 0xff0);\n\tif (rc != -1 || errno != EINVAL) {\n\t\tksft_test_result_fail(\"Undefined control argument should return EINVAL\\n\");\n\t\treturn -12;\n\t}\n\n\trc = prctl(PR_RISCV_V_SET_CONTROL, 0x3);\n\tif (rc != -1 || errno != EINVAL) {\n\t\tksft_test_result_fail(\"Undefined control argument should return EINVAL\\n\");\n\t\treturn -12;\n\t}\n\n\trc = prctl(PR_RISCV_V_SET_CONTROL, 0xc);\n\tif (rc != -1 || errno != EINVAL) {\n\t\tksft_test_result_fail(\"Undefined control argument should return EINVAL\\n\");\n\t\treturn -12;\n\t}\n\n\trc = prctl(PR_RISCV_V_SET_CONTROL, 0xc);\n\tif (rc != -1 || errno != EINVAL) {\n\t\tksft_test_result_fail(\"Undefined control argument should return EINVAL\\n\");\n\t\treturn -12;\n\t}\n\n\tksft_test_result_pass(\"tests for riscv_v_vstate_ctrl pass\\n\");\n\tksft_exit_pass();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}