{
  "module_name": "sync_stress_merge.c",
  "hash_id": "f52496a77a2fdbe71656648ea60a9c35be67b243297414411ed6d667444efa71",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sync/sync_stress_merge.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"sync.h\"\n#include \"sw_sync.h\"\n#include \"synctest.h\"\n\nint test_merge_stress_random_merge(void)\n{\n\tint i, size, ret;\n\tint timeline_count = 32;\n\tint merge_count = 1024 * 32;\n\tint timelines[timeline_count];\n\tint fence_map[timeline_count];\n\tint fence, tmpfence, merged, valid;\n\tint timeline, timeline_offset, sync_point;\n\n\tsrand(time(NULL));\n\n\tfor (i = 0; i < timeline_count; i++)\n\t\ttimelines[i] = sw_sync_timeline_create();\n\n\tfence = sw_sync_fence_create(timelines[0], \"fence\", 0);\n\tvalid = sw_sync_fence_is_valid(fence);\n\tASSERT(valid, \"Failure creating fence\\n\");\n\n\tmemset(fence_map, -1, sizeof(fence_map));\n\tfence_map[0] = 0;\n\n\t \n\tfor (i = 0; i < merge_count; i++) {\n\t\t \n\t\ttimeline_offset = rand() % timeline_count;\n\t\ttimeline = timelines[timeline_offset];\n\t\tsync_point = rand();\n\n\t\t \n\t\tif (fence_map[timeline_offset] == -1)\n\t\t\tfence_map[timeline_offset] = sync_point;\n\t\telse if (fence_map[timeline_offset] < sync_point)\n\t\t\tfence_map[timeline_offset] = sync_point;\n\n\t\t \n\t\ttmpfence = sw_sync_fence_create(timeline, \"fence\", sync_point);\n\t\tmerged = sync_merge(\"merge\", tmpfence, fence);\n\t\tsw_sync_fence_destroy(tmpfence);\n\t\tsw_sync_fence_destroy(fence);\n\t\tfence = merged;\n\n\t\tvalid = sw_sync_fence_is_valid(merged);\n\t\tASSERT(valid, \"Failure creating fence i\\n\");\n\t}\n\n\tsize = 0;\n\tfor (i = 0; i < timeline_count; i++)\n\t\tif (fence_map[i] != -1)\n\t\t\tsize++;\n\n\t \n\tASSERT(sync_fence_size(fence) == size,\n\t       \"Quantity of elements not matching\\n\");\n\n\t \n\tfor (i = 0; i < timeline_count; i++) {\n\t\tif (fence_map[i] != -1) {\n\t\t\tret = sync_wait(fence, 0);\n\t\t\tASSERT(ret == 0,\n\t\t\t       \"Failure waiting on fence until timeout\\n\");\n\t\t\t \n\t\t\tsw_sync_timeline_inc(timelines[i], fence_map[i]);\n\t\t}\n\t}\n\n\t \n\tret = sync_wait(fence, 0);\n\tASSERT(ret > 0, \"Failure triggering fence\\n\");\n\n\tsw_sync_fence_destroy(fence);\n\n\tfor (i = 0; i < timeline_count; i++)\n\t\tsw_sync_timeline_destroy(timelines[i]);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}