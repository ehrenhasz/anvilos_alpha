{
  "module_name": "sync.c",
  "hash_id": "1648a7fb7af2bdc105ace04e28ff578c038b7ecde0fb84a856abbd9b3abd6e2d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sync/sync.c",
  "human_readable_source": " \n\n#include <fcntl.h>\n#include <malloc.h>\n#include <poll.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"sync.h\"\n#include \"sw_sync.h\"\n\n#include <linux/sync_file.h>\n\n\n \nstruct sw_sync_create_fence_data {\n\t__u32\tvalue;\n\tchar\tname[32];\n\t__s32\tfence;\n};\n\n#define SW_SYNC_IOC_MAGIC\t\t'W'\n#define SW_SYNC_IOC_CREATE_FENCE\t_IOWR(SW_SYNC_IOC_MAGIC, 0,\\\n\t\t\t\t\t      struct sw_sync_create_fence_data)\n#define SW_SYNC_IOC_INC\t\t\t_IOW(SW_SYNC_IOC_MAGIC, 1, __u32)\n\n\nint sync_wait(int fd, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLERR;\n\n\treturn poll(&fds, 1, timeout);\n}\n\nint sync_merge(const char *name, int fd1, int fd2)\n{\n\tstruct sync_merge_data data = {};\n\tint err;\n\n\tdata.fd2 = fd2;\n\tstrncpy(data.name, name, sizeof(data.name) - 1);\n\tdata.name[sizeof(data.name) - 1] = '\\0';\n\n\terr = ioctl(fd1, SYNC_IOC_MERGE, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn data.fence;\n}\n\nstatic struct sync_file_info *sync_file_info(int fd)\n{\n\tstruct sync_file_info *info;\n\tstruct sync_fence_info *fence_info;\n\tint err, num_fences;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (info == NULL)\n\t\treturn NULL;\n\n\terr = ioctl(fd, SYNC_IOC_FILE_INFO, info);\n\tif (err < 0) {\n\t\tfree(info);\n\t\treturn NULL;\n\t}\n\n\tnum_fences = info->num_fences;\n\n\tif (num_fences) {\n\t\tinfo->flags = 0;\n\t\tinfo->num_fences = num_fences;\n\n\t\tfence_info = calloc(num_fences, sizeof(*fence_info));\n\t\tif (!fence_info) {\n\t\t\tfree(info);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tinfo->sync_fence_info = (uint64_t)(unsigned long)fence_info;\n\n\t\terr = ioctl(fd, SYNC_IOC_FILE_INFO, info);\n\t\tif (err < 0) {\n\t\t\tfree(fence_info);\n\t\t\tfree(info);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn info;\n}\n\nstatic void sync_file_info_free(struct sync_file_info *info)\n{\n\tfree((void *)(unsigned long)info->sync_fence_info);\n\tfree(info);\n}\n\nint sync_fence_size(int fd)\n{\n\tint count;\n\tstruct sync_file_info *info = sync_file_info(fd);\n\n\tif (!info)\n\t\treturn 0;\n\n\tcount = info->num_fences;\n\n\tsync_file_info_free(info);\n\n\treturn count;\n}\n\nint sync_fence_count_with_status(int fd, int status)\n{\n\tunsigned int i, count = 0;\n\tstruct sync_fence_info *fence_info = NULL;\n\tstruct sync_file_info *info = sync_file_info(fd);\n\n\tif (!info)\n\t\treturn -1;\n\n\tfence_info = (struct sync_fence_info *)(unsigned long)info->sync_fence_info;\n\tfor (i = 0 ; i < info->num_fences ; i++) {\n\t\tif (fence_info[i].status == status)\n\t\t\tcount++;\n\t}\n\n\tsync_file_info_free(info);\n\n\treturn count;\n}\n\nint sw_sync_timeline_create(void)\n{\n\treturn open(\"/sys/kernel/debug/sync/sw_sync\", O_RDWR);\n}\n\nint sw_sync_timeline_inc(int fd, unsigned int count)\n{\n\t__u32 arg = count;\n\n\treturn ioctl(fd, SW_SYNC_IOC_INC, &arg);\n}\n\nint sw_sync_timeline_is_valid(int fd)\n{\n\tint status;\n\n\tif (fd == -1)\n\t\treturn 0;\n\n\tstatus = fcntl(fd, F_GETFD, 0);\n\treturn (status >= 0);\n}\n\nvoid sw_sync_timeline_destroy(int fd)\n{\n\tif (sw_sync_timeline_is_valid(fd))\n\t\tclose(fd);\n}\n\nint sw_sync_fence_create(int fd, const char *name, unsigned int value)\n{\n\tstruct sw_sync_create_fence_data data = {};\n\tint err;\n\n\tdata.value = value;\n\tstrncpy(data.name, name, sizeof(data.name) - 1);\n\tdata.name[sizeof(data.name) - 1] = '\\0';\n\n\terr = ioctl(fd, SW_SYNC_IOC_CREATE_FENCE, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn data.fence;\n}\n\nint sw_sync_fence_is_valid(int fd)\n{\n\t \n\treturn sw_sync_timeline_is_valid(fd);\n}\n\nvoid sw_sync_fence_destroy(int fd)\n{\n\tif (sw_sync_fence_is_valid(fd))\n\t\tclose(fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}