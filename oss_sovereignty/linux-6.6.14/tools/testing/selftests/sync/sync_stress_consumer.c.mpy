{
  "module_name": "sync_stress_consumer.c",
  "hash_id": "e9befeaac77a5062f6a61e891a5e3884a4adb5c6f0b65d29c1d049fa93004b28",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sync/sync_stress_consumer.c",
  "human_readable_source": " \n\n#include <pthread.h>\n\n#include \"sync.h\"\n#include \"sw_sync.h\"\n#include \"synctest.h\"\n\n \n\n \nstatic int busy_wait_on_fence(int fence)\n{\n\tint error, active;\n\n\tdo {\n\t\terror = sync_fence_count_with_status(fence, FENCE_STATUS_ERROR);\n\t\tASSERT(error == 0, \"Error occurred on fence\\n\");\n\t\tactive = sync_fence_count_with_status(fence,\n\t\t\t\t\t\t      FENCE_STATUS_ACTIVE);\n\t} while (active);\n\n\treturn 0;\n}\n\nstatic struct {\n\tint iterations;\n\tint threads;\n\tint counter;\n\tint consumer_timeline;\n\tint *producer_timelines;\n\tpthread_mutex_t lock;\n} test_data_mpsc;\n\nstatic int mpsc_producer_thread(void *d)\n{\n\tint id = (long)d;\n\tint fence, valid, i;\n\tint *producer_timelines = test_data_mpsc.producer_timelines;\n\tint consumer_timeline = test_data_mpsc.consumer_timeline;\n\tint iterations = test_data_mpsc.iterations;\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tfence = sw_sync_fence_create(consumer_timeline, \"fence\", i);\n\t\tvalid = sw_sync_fence_is_valid(fence);\n\t\tASSERT(valid, \"Failure creating fence\\n\");\n\n\t\t \n\n\t\tif ((iterations + id) % 8 != 0) {\n\t\t\tASSERT(sync_wait(fence, -1) > 0,\n\t\t\t       \"Failure waiting on fence\\n\");\n\t\t} else {\n\t\t\tASSERT(busy_wait_on_fence(fence) == 0,\n\t\t\t       \"Failure waiting on fence\\n\");\n\t\t}\n\n\t\t \n\t\tpthread_mutex_lock(&test_data_mpsc.lock);\n\t\ttest_data_mpsc.counter++;\n\t\tpthread_mutex_unlock(&test_data_mpsc.lock);\n\n\t\tASSERT(sw_sync_timeline_inc(producer_timelines[id], 1) == 0,\n\t\t       \"Error advancing producer timeline\\n\");\n\n\t\tsw_sync_fence_destroy(fence);\n\t}\n\n\treturn 0;\n}\n\nstatic int mpcs_consumer_thread(void)\n{\n\tint fence, merged, tmp, valid, it, i;\n\tint *producer_timelines = test_data_mpsc.producer_timelines;\n\tint consumer_timeline = test_data_mpsc.consumer_timeline;\n\tint iterations = test_data_mpsc.iterations;\n\tint n = test_data_mpsc.threads;\n\n\tfor (it = 1; it <= iterations; it++) {\n\t\tfence = sw_sync_fence_create(producer_timelines[0], \"name\", it);\n\t\tfor (i = 1; i < n; i++) {\n\t\t\ttmp = sw_sync_fence_create(producer_timelines[i],\n\t\t\t\t\t\t   \"name\", it);\n\t\t\tmerged = sync_merge(\"name\", tmp, fence);\n\t\t\tsw_sync_fence_destroy(tmp);\n\t\t\tsw_sync_fence_destroy(fence);\n\t\t\tfence = merged;\n\t\t}\n\n\t\tvalid = sw_sync_fence_is_valid(fence);\n\t\tASSERT(valid, \"Failure merging fences\\n\");\n\n\t\t \n\t\tif (iterations % 8 != 0) {\n\t\t\tASSERT(sync_wait(fence, -1) > 0,\n\t\t\t       \"Producers did not increment as expected\\n\");\n\t\t} else {\n\t\t\tASSERT(busy_wait_on_fence(fence) == 0,\n\t\t\t       \"Producers did not increment as expected\\n\");\n\t\t}\n\n\t\tASSERT(test_data_mpsc.counter == n * it,\n\t\t       \"Counter value mismatch!\\n\");\n\n\t\t \n\t\tASSERT(sw_sync_timeline_inc(consumer_timeline, 1) == 0,\n\t\t       \"Failure releasing producer threads\\n\");\n\n\t\tsw_sync_fence_destroy(fence);\n\t}\n\n\treturn 0;\n}\n\nint test_consumer_stress_multi_producer_single_consumer(void)\n{\n\tint iterations = 1 << 12;\n\tint n = 5;\n\tlong i, ret;\n\tint producer_timelines[n];\n\tint consumer_timeline;\n\tpthread_t threads[n];\n\n\tconsumer_timeline = sw_sync_timeline_create();\n\tfor (i = 0; i < n; i++)\n\t\tproducer_timelines[i] = sw_sync_timeline_create();\n\n\ttest_data_mpsc.producer_timelines = producer_timelines;\n\ttest_data_mpsc.consumer_timeline = consumer_timeline;\n\ttest_data_mpsc.iterations = iterations;\n\ttest_data_mpsc.threads = n;\n\ttest_data_mpsc.counter = 0;\n\tpthread_mutex_init(&test_data_mpsc.lock, NULL);\n\n\tfor (i = 0; i < n; i++) {\n\t\tpthread_create(&threads[i], NULL, (void * (*)(void *))\n\t\t\t       mpsc_producer_thread, (void *)i);\n\t}\n\n\t \n\tret = mpcs_consumer_thread();\n\n\tfor (i = 0; i < n; i++)\n\t\tpthread_join(threads[i], NULL);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}