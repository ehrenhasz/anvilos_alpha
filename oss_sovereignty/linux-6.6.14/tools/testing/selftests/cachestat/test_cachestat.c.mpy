{
  "module_name": "test_cachestat.c",
  "hash_id": "0ff4aa6af87807cd0831814b6f2bca11aabdc1110d90da8159895c23e7a114e5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cachestat/test_cachestat.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <linux/kernel.h>\n#include <linux/magic.h>\n#include <linux/mman.h>\n#include <sys/mman.h>\n#include <sys/shm.h>\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#include \"../kselftest.h\"\n\n#define NR_TESTS\t9\n\nstatic const char * const dev_files[] = {\n\t\"/dev/zero\", \"/dev/null\", \"/dev/urandom\",\n\t\"/proc/version\", \"/proc\"\n};\n\nvoid print_cachestat(struct cachestat *cs)\n{\n\tksft_print_msg(\n\t\"Using cachestat: Cached: %lu, Dirty: %lu, Writeback: %lu, Evicted: %lu, Recently Evicted: %lu\\n\",\n\tcs->nr_cache, cs->nr_dirty, cs->nr_writeback,\n\tcs->nr_evicted, cs->nr_recently_evicted);\n}\n\nbool write_exactly(int fd, size_t filesize)\n{\n\tint random_fd = open(\"/dev/urandom\", O_RDONLY);\n\tchar *cursor, *data;\n\tint remained;\n\tbool ret;\n\n\tif (random_fd < 0) {\n\t\tksft_print_msg(\"Unable to access urandom.\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tdata = malloc(filesize);\n\tif (!data) {\n\t\tksft_print_msg(\"Unable to allocate data.\\n\");\n\t\tret = false;\n\t\tgoto close_random_fd;\n\t}\n\n\tremained = filesize;\n\tcursor = data;\n\n\twhile (remained) {\n\t\tssize_t read_len = read(random_fd, cursor, remained);\n\n\t\tif (read_len <= 0) {\n\t\t\tksft_print_msg(\"Unable to read from urandom.\\n\");\n\t\t\tret = false;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tremained -= read_len;\n\t\tcursor += read_len;\n\t}\n\n\t \n\tremained = filesize;\n\tcursor = data;\n\twhile (remained) {\n\t\tssize_t write_len = write(fd, cursor, remained);\n\n\t\tif (write_len <= 0) {\n\t\t\tksft_print_msg(\"Unable write random data to file.\\n\");\n\t\t\tret = false;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tremained -= write_len;\n\t\tcursor += write_len;\n\t}\n\n\tret = true;\nout_free_data:\n\tfree(data);\nclose_random_fd:\n\tclose(random_fd);\nout:\n\treturn ret;\n}\n\n \nstatic bool is_on_tmpfs(int fd)\n{\n\tstruct statfs statfs_buf;\n\n\tif (fstatfs(fd, &statfs_buf))\n\t\treturn false;\n\n\treturn statfs_buf.f_type == TMPFS_MAGIC;\n}\n\n \nstatic int test_cachestat(const char *filename, bool write_random, bool create,\n\t\t\t  bool test_fsync, unsigned long num_pages,\n\t\t\t  int open_flags, mode_t open_mode)\n{\n\tsize_t PS = sysconf(_SC_PAGESIZE);\n\tint filesize = num_pages * PS;\n\tint ret = KSFT_PASS;\n\tlong syscall_ret;\n\tstruct cachestat cs;\n\tstruct cachestat_range cs_range = { 0, filesize };\n\n\tint fd = open(filename, open_flags, open_mode);\n\n\tif (fd == -1) {\n\t\tksft_print_msg(\"Unable to create/open file.\\n\");\n\t\tret = KSFT_FAIL;\n\t\tgoto out;\n\t} else {\n\t\tksft_print_msg(\"Create/open %s\\n\", filename);\n\t}\n\n\tif (write_random) {\n\t\tif (!write_exactly(fd, filesize)) {\n\t\t\tksft_print_msg(\"Unable to access urandom.\\n\");\n\t\t\tret = KSFT_FAIL;\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tsyscall_ret = syscall(__NR_cachestat, fd, &cs_range, &cs, 0);\n\n\tksft_print_msg(\"Cachestat call returned %ld\\n\", syscall_ret);\n\n\tif (syscall_ret) {\n\t\tksft_print_msg(\"Cachestat returned non-zero.\\n\");\n\t\tret = KSFT_FAIL;\n\t\tgoto out1;\n\n\t} else {\n\t\tprint_cachestat(&cs);\n\n\t\tif (write_random) {\n\t\t\tif (cs.nr_cache + cs.nr_evicted != num_pages) {\n\t\t\t\tksft_print_msg(\n\t\t\t\t\t\"Total number of cached and evicted pages is off.\\n\");\n\t\t\t\tret = KSFT_FAIL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_fsync) {\n\t\tif (is_on_tmpfs(fd)) {\n\t\t\tret = KSFT_SKIP;\n\t\t} else if (fsync(fd)) {\n\t\t\tksft_print_msg(\"fsync fails.\\n\");\n\t\t\tret = KSFT_FAIL;\n\t\t} else {\n\t\t\tsyscall_ret = syscall(__NR_cachestat, fd, &cs_range, &cs, 0);\n\n\t\t\tksft_print_msg(\"Cachestat call (after fsync) returned %ld\\n\",\n\t\t\t\tsyscall_ret);\n\n\t\t\tif (!syscall_ret) {\n\t\t\t\tprint_cachestat(&cs);\n\n\t\t\t\tif (cs.nr_dirty) {\n\t\t\t\t\tret = KSFT_FAIL;\n\t\t\t\t\tksft_print_msg(\n\t\t\t\t\t\t\"Number of dirty should be zero after fsync.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tksft_print_msg(\"Cachestat (after fsync) returned non-zero.\\n\");\n\t\t\t\tret = KSFT_FAIL;\n\t\t\t\tgoto out1;\n\t\t\t}\n\t\t}\n\t}\n\nout1:\n\tclose(fd);\n\n\tif (create)\n\t\tremove(filename);\nout:\n\treturn ret;\n}\n\nbool test_cachestat_shmem(void)\n{\n\tsize_t PS = sysconf(_SC_PAGESIZE);\n\tsize_t filesize = PS * 512 * 2;  \n\tint syscall_ret;\n\tsize_t compute_len = PS * 512;\n\tstruct cachestat_range cs_range = { PS, compute_len };\n\tchar *filename = \"tmpshmcstat\";\n\tstruct cachestat cs;\n\tbool ret = true;\n\tunsigned long num_pages = compute_len / PS;\n\tint fd = shm_open(filename, O_CREAT | O_RDWR, 0600);\n\n\tif (fd < 0) {\n\t\tksft_print_msg(\"Unable to create shmem file.\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (ftruncate(fd, filesize)) {\n\t\tksft_print_msg(\"Unable to truncate shmem file.\\n\");\n\t\tret = false;\n\t\tgoto close_fd;\n\t}\n\n\tif (!write_exactly(fd, filesize)) {\n\t\tksft_print_msg(\"Unable to write to shmem file.\\n\");\n\t\tret = false;\n\t\tgoto close_fd;\n\t}\n\n\tsyscall_ret = syscall(__NR_cachestat, fd, &cs_range, &cs, 0);\n\n\tif (syscall_ret) {\n\t\tksft_print_msg(\"Cachestat returned non-zero.\\n\");\n\t\tret = false;\n\t\tgoto close_fd;\n\t} else {\n\t\tprint_cachestat(&cs);\n\t\tif (cs.nr_cache + cs.nr_evicted != num_pages) {\n\t\t\tksft_print_msg(\n\t\t\t\t\"Total number of cached and evicted pages is off.\\n\");\n\t\t\tret = false;\n\t\t}\n\t}\n\nclose_fd:\n\tshm_unlink(filename);\nout:\n\treturn ret;\n}\n\nint main(void)\n{\n\tint ret;\n\n\tksft_print_header();\n\n\tret = syscall(__NR_cachestat, -1, NULL, NULL, 0);\n\tif (ret == -1 && errno == ENOSYS)\n\t\tksft_exit_skip(\"cachestat syscall not available\\n\");\n\n\tksft_set_plan(NR_TESTS);\n\n\tif (ret == -1 && errno == EBADF) {\n\t\tksft_test_result_pass(\"bad file descriptor recognized\\n\");\n\t\tret = 0;\n\t} else {\n\t\tksft_test_result_fail(\"bad file descriptor ignored\\n\");\n\t\tret = 1;\n\t}\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tconst char *dev_filename = dev_files[i];\n\n\t\tif (test_cachestat(dev_filename, false, false, false,\n\t\t\t4, O_RDONLY, 0400) == KSFT_PASS)\n\t\t\tksft_test_result_pass(\"cachestat works with %s\\n\", dev_filename);\n\t\telse {\n\t\t\tksft_test_result_fail(\"cachestat fails with %s\\n\", dev_filename);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (test_cachestat(\"tmpfilecachestat\", true, true,\n\t\tfalse, 4, O_CREAT | O_RDWR, 0600) == KSFT_PASS)\n\t\tksft_test_result_pass(\"cachestat works with a normal file\\n\");\n\telse {\n\t\tksft_test_result_fail(\"cachestat fails with normal file\\n\");\n\t\tret = 1;\n\t}\n\n\tswitch (test_cachestat(\"tmpfilecachestat\", true, true,\n\t\ttrue, 4, O_CREAT | O_RDWR, 0600)) {\n\tcase KSFT_FAIL:\n\t\tksft_test_result_fail(\"cachestat fsync fails with normal file\\n\");\n\t\tret = KSFT_FAIL;\n\t\tbreak;\n\tcase KSFT_PASS:\n\t\tksft_test_result_pass(\"cachestat fsync works with a normal file\\n\");\n\t\tbreak;\n\tcase KSFT_SKIP:\n\t\tksft_test_result_skip(\"tmpfilecachestat is on tmpfs\\n\");\n\t\tbreak;\n\t}\n\n\tif (test_cachestat_shmem())\n\t\tksft_test_result_pass(\"cachestat works with a shmem file\\n\");\n\telse {\n\t\tksft_test_result_fail(\"cachestat fails with a shmem file\\n\");\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}