{
  "module_name": "bench.c",
  "hash_id": "d40edfe5d5071300c93e800fc0a4b083d735683f23f799650c092b8626d277cb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/bench.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <argp.h>\n#include <linux/compiler.h>\n#include <sys/time.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <sys/sysinfo.h>\n#include <signal.h>\n#include \"bench.h\"\n#include \"testing_helpers.h\"\n\nstruct env env = {\n\t.warmup_sec = 1,\n\t.duration_sec = 5,\n\t.affinity = false,\n\t.quiet = false,\n\t.consumer_cnt = 0,\n\t.producer_cnt = 1,\n};\n\nstatic int libbpf_print_fn(enum libbpf_print_level level,\n\t\t    const char *format, va_list args)\n{\n\tif (level == LIBBPF_DEBUG && !env.verbose)\n\t\treturn 0;\n\treturn vfprintf(stderr, format, args);\n}\n\nvoid setup_libbpf(void)\n{\n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\tlibbpf_set_print(libbpf_print_fn);\n}\n\nvoid false_hits_report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tlong total = res->false_hits  + res->hits + res->drops;\n\n\tprintf(\"Iter %3d (%7.3lfus): \",\n\t       iter, (delta_ns - 1000000000) / 1000.0);\n\n\tprintf(\"%ld false hits of %ld total operations. Percentage = %2.2f %%\\n\",\n\t       res->false_hits, total, ((float)res->false_hits / total) * 100);\n}\n\nvoid false_hits_report_final(struct bench_res res[], int res_cnt)\n{\n\tlong total_hits = 0, total_drops = 0, total_false_hits = 0, total_ops = 0;\n\tint i;\n\n\tfor (i = 0; i < res_cnt; i++) {\n\t\ttotal_hits += res[i].hits;\n\t\ttotal_false_hits += res[i].false_hits;\n\t\ttotal_drops += res[i].drops;\n\t}\n\ttotal_ops = total_hits + total_false_hits + total_drops;\n\n\tprintf(\"Summary: %ld false hits of %ld total operations. \",\n\t       total_false_hits, total_ops);\n\tprintf(\"Percentage =  %2.2f %%\\n\",\n\t       ((float)total_false_hits / total_ops) * 100);\n}\n\nvoid hits_drops_report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tdouble hits_per_sec, drops_per_sec;\n\tdouble hits_per_prod;\n\n\thits_per_sec = res->hits / 1000000.0 / (delta_ns / 1000000000.0);\n\thits_per_prod = hits_per_sec / env.producer_cnt;\n\tdrops_per_sec = res->drops / 1000000.0 / (delta_ns / 1000000000.0);\n\n\tprintf(\"Iter %3d (%7.3lfus): \",\n\t       iter, (delta_ns - 1000000000) / 1000.0);\n\n\tprintf(\"hits %8.3lfM/s (%7.3lfM/prod), drops %8.3lfM/s, total operations %8.3lfM/s\\n\",\n\t       hits_per_sec, hits_per_prod, drops_per_sec, hits_per_sec + drops_per_sec);\n}\n\nvoid\ngrace_period_latency_basic_stats(struct bench_res res[], int res_cnt, struct basic_stats *gp_stat)\n{\n\tint i;\n\n\tmemset(gp_stat, 0, sizeof(struct basic_stats));\n\n\tfor (i = 0; i < res_cnt; i++)\n\t\tgp_stat->mean += res[i].gp_ns / 1000.0 / (double)res[i].gp_ct / (0.0 + res_cnt);\n\n#define IT_MEAN_DIFF (res[i].gp_ns / 1000.0 / (double)res[i].gp_ct - gp_stat->mean)\n\tif (res_cnt > 1) {\n\t\tfor (i = 0; i < res_cnt; i++)\n\t\t\tgp_stat->stddev += (IT_MEAN_DIFF * IT_MEAN_DIFF) / (res_cnt - 1.0);\n\t}\n\tgp_stat->stddev = sqrt(gp_stat->stddev);\n#undef IT_MEAN_DIFF\n}\n\nvoid\ngrace_period_ticks_basic_stats(struct bench_res res[], int res_cnt, struct basic_stats *gp_stat)\n{\n\tint i;\n\n\tmemset(gp_stat, 0, sizeof(struct basic_stats));\n\tfor (i = 0; i < res_cnt; i++)\n\t\tgp_stat->mean += res[i].stime / (double)res[i].gp_ct / (0.0 + res_cnt);\n\n#define IT_MEAN_DIFF (res[i].stime / (double)res[i].gp_ct - gp_stat->mean)\n\tif (res_cnt > 1) {\n\t\tfor (i = 0; i < res_cnt; i++)\n\t\t\tgp_stat->stddev += (IT_MEAN_DIFF * IT_MEAN_DIFF) / (res_cnt - 1.0);\n\t}\n\tgp_stat->stddev = sqrt(gp_stat->stddev);\n#undef IT_MEAN_DIFF\n}\n\nvoid hits_drops_report_final(struct bench_res res[], int res_cnt)\n{\n\tint i;\n\tdouble hits_mean = 0.0, drops_mean = 0.0, total_ops_mean = 0.0;\n\tdouble hits_stddev = 0.0, drops_stddev = 0.0, total_ops_stddev = 0.0;\n\tdouble total_ops;\n\n\tfor (i = 0; i < res_cnt; i++) {\n\t\thits_mean += res[i].hits / 1000000.0 / (0.0 + res_cnt);\n\t\tdrops_mean += res[i].drops / 1000000.0 / (0.0 + res_cnt);\n\t}\n\ttotal_ops_mean = hits_mean + drops_mean;\n\n\tif (res_cnt > 1)  {\n\t\tfor (i = 0; i < res_cnt; i++) {\n\t\t\thits_stddev += (hits_mean - res[i].hits / 1000000.0) *\n\t\t\t\t       (hits_mean - res[i].hits / 1000000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\t\t\tdrops_stddev += (drops_mean - res[i].drops / 1000000.0) *\n\t\t\t\t\t(drops_mean - res[i].drops / 1000000.0) /\n\t\t\t\t\t(res_cnt - 1.0);\n\t\t\ttotal_ops = res[i].hits + res[i].drops;\n\t\t\ttotal_ops_stddev += (total_ops_mean - total_ops / 1000000.0) *\n\t\t\t\t\t(total_ops_mean - total_ops / 1000000.0) /\n\t\t\t\t\t(res_cnt - 1.0);\n\t\t}\n\t\thits_stddev = sqrt(hits_stddev);\n\t\tdrops_stddev = sqrt(drops_stddev);\n\t\ttotal_ops_stddev = sqrt(total_ops_stddev);\n\t}\n\tprintf(\"Summary: hits %8.3lf \\u00B1 %5.3lfM/s (%7.3lfM/prod), \",\n\t       hits_mean, hits_stddev, hits_mean / env.producer_cnt);\n\tprintf(\"drops %8.3lf \\u00B1 %5.3lfM/s, \",\n\t       drops_mean, drops_stddev);\n\tprintf(\"total operations %8.3lf \\u00B1 %5.3lfM/s\\n\",\n\t       total_ops_mean, total_ops_stddev);\n}\n\nvoid ops_report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tdouble hits_per_sec, hits_per_prod;\n\n\thits_per_sec = res->hits / 1000000.0 / (delta_ns / 1000000000.0);\n\thits_per_prod = hits_per_sec / env.producer_cnt;\n\n\tprintf(\"Iter %3d (%7.3lfus): \", iter, (delta_ns - 1000000000) / 1000.0);\n\n\tprintf(\"hits %8.3lfM/s (%7.3lfM/prod)\\n\", hits_per_sec, hits_per_prod);\n}\n\nvoid ops_report_final(struct bench_res res[], int res_cnt)\n{\n\tdouble hits_mean = 0.0, hits_stddev = 0.0;\n\tint i;\n\n\tfor (i = 0; i < res_cnt; i++)\n\t\thits_mean += res[i].hits / 1000000.0 / (0.0 + res_cnt);\n\n\tif (res_cnt > 1)  {\n\t\tfor (i = 0; i < res_cnt; i++)\n\t\t\thits_stddev += (hits_mean - res[i].hits / 1000000.0) *\n\t\t\t\t       (hits_mean - res[i].hits / 1000000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\n\t\thits_stddev = sqrt(hits_stddev);\n\t}\n\tprintf(\"Summary: throughput %8.3lf \\u00B1 %5.3lf M ops/s (%7.3lfM ops/prod), \",\n\t       hits_mean, hits_stddev, hits_mean / env.producer_cnt);\n\tprintf(\"latency %8.3lf ns/op\\n\", 1000.0 / hits_mean * env.producer_cnt);\n}\n\nvoid local_storage_report_progress(int iter, struct bench_res *res,\n\t\t\t\t   long delta_ns)\n{\n\tdouble important_hits_per_sec, hits_per_sec;\n\tdouble delta_sec = delta_ns / 1000000000.0;\n\n\thits_per_sec = res->hits / 1000000.0 / delta_sec;\n\timportant_hits_per_sec = res->important_hits / 1000000.0 / delta_sec;\n\n\tprintf(\"Iter %3d (%7.3lfus): \", iter, (delta_ns - 1000000000) / 1000.0);\n\n\tprintf(\"hits %8.3lfM/s \", hits_per_sec);\n\tprintf(\"important_hits %8.3lfM/s\\n\", important_hits_per_sec);\n}\n\nvoid local_storage_report_final(struct bench_res res[], int res_cnt)\n{\n\tdouble important_hits_mean = 0.0, important_hits_stddev = 0.0;\n\tdouble hits_mean = 0.0, hits_stddev = 0.0;\n\tint i;\n\n\tfor (i = 0; i < res_cnt; i++) {\n\t\thits_mean += res[i].hits / 1000000.0 / (0.0 + res_cnt);\n\t\timportant_hits_mean += res[i].important_hits / 1000000.0 / (0.0 + res_cnt);\n\t}\n\n\tif (res_cnt > 1)  {\n\t\tfor (i = 0; i < res_cnt; i++) {\n\t\t\thits_stddev += (hits_mean - res[i].hits / 1000000.0) *\n\t\t\t\t       (hits_mean - res[i].hits / 1000000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\t\t\timportant_hits_stddev +=\n\t\t\t\t       (important_hits_mean - res[i].important_hits / 1000000.0) *\n\t\t\t\t       (important_hits_mean - res[i].important_hits / 1000000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\t\t}\n\n\t\thits_stddev = sqrt(hits_stddev);\n\t\timportant_hits_stddev = sqrt(important_hits_stddev);\n\t}\n\tprintf(\"Summary: hits throughput %8.3lf \\u00B1 %5.3lf M ops/s, \",\n\t       hits_mean, hits_stddev);\n\tprintf(\"hits latency %8.3lf ns/op, \", 1000.0 / hits_mean);\n\tprintf(\"important_hits throughput %8.3lf \\u00B1 %5.3lf M ops/s\\n\",\n\t       important_hits_mean, important_hits_stddev);\n}\n\nconst char *argp_program_version = \"benchmark\";\nconst char *argp_program_bug_address = \"<bpf@vger.kernel.org>\";\nconst char argp_program_doc[] =\n\"benchmark    Generic benchmarking framework.\\n\"\n\"\\n\"\n\"This tool runs benchmarks.\\n\"\n\"\\n\"\n\"USAGE: benchmark <bench-name>\\n\"\n\"\\n\"\n\"EXAMPLES:\\n\"\n\"    # run 'count-local' benchmark with 1 producer and 1 consumer\\n\"\n\"    benchmark count-local\\n\"\n\"    # run 'count-local' with 16 producer and 8 consumer thread, pinned to CPUs\\n\"\n\"    benchmark -p16 -c8 -a count-local\\n\";\n\nenum {\n\tARG_PROD_AFFINITY_SET = 1000,\n\tARG_CONS_AFFINITY_SET = 1001,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"list\", 'l', NULL, 0, \"List available benchmarks\"},\n\t{ \"duration\", 'd', \"SEC\", 0, \"Duration of benchmark, seconds\"},\n\t{ \"warmup\", 'w', \"SEC\", 0, \"Warm-up period, seconds\"},\n\t{ \"producers\", 'p', \"NUM\", 0, \"Number of producer threads\"},\n\t{ \"consumers\", 'c', \"NUM\", 0, \"Number of consumer threads\"},\n\t{ \"verbose\", 'v', NULL, 0, \"Verbose debug output\"},\n\t{ \"affinity\", 'a', NULL, 0, \"Set consumer/producer thread affinity\"},\n\t{ \"quiet\", 'q', NULL, 0, \"Be more quiet\"},\n\t{ \"prod-affinity\", ARG_PROD_AFFINITY_SET, \"CPUSET\", 0,\n\t  \"Set of CPUs for producer threads; implies --affinity\"},\n\t{ \"cons-affinity\", ARG_CONS_AFFINITY_SET, \"CPUSET\", 0,\n\t  \"Set of CPUs for consumer threads; implies --affinity\"},\n\t{},\n};\n\nextern struct argp bench_ringbufs_argp;\nextern struct argp bench_bloom_map_argp;\nextern struct argp bench_bpf_loop_argp;\nextern struct argp bench_local_storage_argp;\nextern struct argp bench_local_storage_rcu_tasks_trace_argp;\nextern struct argp bench_strncmp_argp;\nextern struct argp bench_hashmap_lookup_argp;\nextern struct argp bench_local_storage_create_argp;\nextern struct argp bench_htab_mem_argp;\n\nstatic const struct argp_child bench_parsers[] = {\n\t{ &bench_ringbufs_argp, 0, \"Ring buffers benchmark\", 0 },\n\t{ &bench_bloom_map_argp, 0, \"Bloom filter map benchmark\", 0 },\n\t{ &bench_bpf_loop_argp, 0, \"bpf_loop helper benchmark\", 0 },\n\t{ &bench_local_storage_argp, 0, \"local_storage benchmark\", 0 },\n\t{ &bench_strncmp_argp, 0, \"bpf_strncmp helper benchmark\", 0 },\n\t{ &bench_local_storage_rcu_tasks_trace_argp, 0,\n\t\t\"local_storage RCU Tasks Trace slowdown benchmark\", 0 },\n\t{ &bench_hashmap_lookup_argp, 0, \"Hashmap lookup benchmark\", 0 },\n\t{ &bench_local_storage_create_argp, 0, \"local-storage-create benchmark\", 0 },\n\t{ &bench_htab_mem_argp, 0, \"hash map memory benchmark\", 0 },\n\t{},\n};\n\n \nstatic int pos_args;\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tswitch (key) {\n\tcase 'v':\n\t\tenv.verbose = true;\n\t\tbreak;\n\tcase 'l':\n\t\tenv.list = true;\n\t\tbreak;\n\tcase 'd':\n\t\tenv.duration_sec = strtol(arg, NULL, 10);\n\t\tif (env.duration_sec <= 0) {\n\t\t\tfprintf(stderr, \"Invalid duration: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase 'w':\n\t\tenv.warmup_sec = strtol(arg, NULL, 10);\n\t\tif (env.warmup_sec <= 0) {\n\t\t\tfprintf(stderr, \"Invalid warm-up duration: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tenv.producer_cnt = strtol(arg, NULL, 10);\n\t\tif (env.producer_cnt <= 0) {\n\t\t\tfprintf(stderr, \"Invalid producer count: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase 'c':\n\t\tenv.consumer_cnt = strtol(arg, NULL, 10);\n\t\tif (env.consumer_cnt <= 0) {\n\t\t\tfprintf(stderr, \"Invalid consumer count: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\tenv.affinity = true;\n\t\tbreak;\n\tcase 'q':\n\t\tenv.quiet = true;\n\t\tbreak;\n\tcase ARG_PROD_AFFINITY_SET:\n\t\tenv.affinity = true;\n\t\tif (parse_num_list(arg, &env.prod_cpus.cpus,\n\t\t\t\t   &env.prod_cpus.cpus_len)) {\n\t\t\tfprintf(stderr, \"Invalid format of CPU set for producers.\");\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase ARG_CONS_AFFINITY_SET:\n\t\tenv.affinity = true;\n\t\tif (parse_num_list(arg, &env.cons_cpus.cpus,\n\t\t\t\t   &env.cons_cpus.cpus_len)) {\n\t\t\tfprintf(stderr, \"Invalid format of CPU set for consumers.\");\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase ARGP_KEY_ARG:\n\t\tif (pos_args++) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Unrecognized positional argument: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tenv.bench_name = strdup(arg);\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic void parse_cmdline_args_init(int argc, char **argv)\n{\n\tstatic const struct argp argp = {\n\t\t.options = opts,\n\t\t.parser = parse_arg,\n\t\t.doc = argp_program_doc,\n\t\t.children = bench_parsers,\n\t};\n\tif (argp_parse(&argp, argc, argv, 0, NULL, NULL))\n\t\texit(1);\n}\n\nstatic void parse_cmdline_args_final(int argc, char **argv)\n{\n\tstruct argp_child bench_parsers[2] = {};\n\tconst struct argp argp = {\n\t\t.options = opts,\n\t\t.parser = parse_arg,\n\t\t.doc = argp_program_doc,\n\t\t.children = bench_parsers,\n\t};\n\n\t \n\tif (bench->argp) {\n\t\tbench_parsers[0].argp = bench->argp;\n\t\tbench_parsers[0].header = bench->name;\n\t\tpos_args = 0;\n\t\tif (argp_parse(&argp, argc, argv, 0, NULL, NULL))\n\t\t\texit(1);\n\t}\n}\n\nstatic void collect_measurements(long delta_ns);\n\nstatic __u64 last_time_ns;\nstatic void sigalarm_handler(int signo)\n{\n\tlong new_time_ns = get_time_ns();\n\tlong delta_ns = new_time_ns - last_time_ns;\n\n\tcollect_measurements(delta_ns);\n\n\tlast_time_ns = new_time_ns;\n}\n\n \nstatic void setup_timer()\n{\n\tstatic struct sigaction sigalarm_action = {\n\t\t.sa_handler = sigalarm_handler,\n\t};\n\tstruct itimerval timer_settings = {};\n\tint err;\n\n\tlast_time_ns = get_time_ns();\n\terr = sigaction(SIGALRM, &sigalarm_action, NULL);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"failed to install SIGALRM handler: %d\\n\", -errno);\n\t\texit(1);\n\t}\n\ttimer_settings.it_interval.tv_sec = 1;\n\ttimer_settings.it_value.tv_sec = 1;\n\terr = setitimer(ITIMER_REAL, &timer_settings, NULL);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"failed to arm interval timer: %d\\n\", -errno);\n\t\texit(1);\n\t}\n}\n\nstatic void set_thread_affinity(pthread_t thread, int cpu)\n{\n\tcpu_set_t cpuset;\n\tint err;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\terr = pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset);\n\tif (err) {\n\t\tfprintf(stderr, \"setting affinity to CPU #%d failed: %d\\n\",\n\t\t\tcpu, -err);\n\t\texit(1);\n\t}\n}\n\nstatic int next_cpu(struct cpu_set *cpu_set)\n{\n\tif (cpu_set->cpus) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = cpu_set->next_cpu; i < cpu_set->cpus_len; i++) {\n\t\t\tif (cpu_set->cpus[i]) {\n\t\t\t\tcpu_set->next_cpu = i + 1;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"Not enough CPUs specified, need CPU #%d or higher.\\n\", i);\n\t\texit(1);\n\t}\n\n\treturn cpu_set->next_cpu++ % env.nr_cpus;\n}\n\nstatic struct bench_state {\n\tint res_cnt;\n\tstruct bench_res *results;\n\tpthread_t *consumers;\n\tpthread_t *producers;\n} state;\n\nconst struct bench *bench = NULL;\n\nextern const struct bench bench_count_global;\nextern const struct bench bench_count_local;\nextern const struct bench bench_rename_base;\nextern const struct bench bench_rename_kprobe;\nextern const struct bench bench_rename_kretprobe;\nextern const struct bench bench_rename_rawtp;\nextern const struct bench bench_rename_fentry;\nextern const struct bench bench_rename_fexit;\nextern const struct bench bench_trig_base;\nextern const struct bench bench_trig_tp;\nextern const struct bench bench_trig_rawtp;\nextern const struct bench bench_trig_kprobe;\nextern const struct bench bench_trig_fentry;\nextern const struct bench bench_trig_fentry_sleep;\nextern const struct bench bench_trig_fmodret;\nextern const struct bench bench_trig_uprobe_base;\nextern const struct bench bench_trig_uprobe_with_nop;\nextern const struct bench bench_trig_uretprobe_with_nop;\nextern const struct bench bench_trig_uprobe_without_nop;\nextern const struct bench bench_trig_uretprobe_without_nop;\nextern const struct bench bench_rb_libbpf;\nextern const struct bench bench_rb_custom;\nextern const struct bench bench_pb_libbpf;\nextern const struct bench bench_pb_custom;\nextern const struct bench bench_bloom_lookup;\nextern const struct bench bench_bloom_update;\nextern const struct bench bench_bloom_false_positive;\nextern const struct bench bench_hashmap_without_bloom;\nextern const struct bench bench_hashmap_with_bloom;\nextern const struct bench bench_bpf_loop;\nextern const struct bench bench_strncmp_no_helper;\nextern const struct bench bench_strncmp_helper;\nextern const struct bench bench_bpf_hashmap_full_update;\nextern const struct bench bench_local_storage_cache_seq_get;\nextern const struct bench bench_local_storage_cache_interleaved_get;\nextern const struct bench bench_local_storage_cache_hashmap_control;\nextern const struct bench bench_local_storage_tasks_trace;\nextern const struct bench bench_bpf_hashmap_lookup;\nextern const struct bench bench_local_storage_create;\nextern const struct bench bench_htab_mem;\n\nstatic const struct bench *benchs[] = {\n\t&bench_count_global,\n\t&bench_count_local,\n\t&bench_rename_base,\n\t&bench_rename_kprobe,\n\t&bench_rename_kretprobe,\n\t&bench_rename_rawtp,\n\t&bench_rename_fentry,\n\t&bench_rename_fexit,\n\t&bench_trig_base,\n\t&bench_trig_tp,\n\t&bench_trig_rawtp,\n\t&bench_trig_kprobe,\n\t&bench_trig_fentry,\n\t&bench_trig_fentry_sleep,\n\t&bench_trig_fmodret,\n\t&bench_trig_uprobe_base,\n\t&bench_trig_uprobe_with_nop,\n\t&bench_trig_uretprobe_with_nop,\n\t&bench_trig_uprobe_without_nop,\n\t&bench_trig_uretprobe_without_nop,\n\t&bench_rb_libbpf,\n\t&bench_rb_custom,\n\t&bench_pb_libbpf,\n\t&bench_pb_custom,\n\t&bench_bloom_lookup,\n\t&bench_bloom_update,\n\t&bench_bloom_false_positive,\n\t&bench_hashmap_without_bloom,\n\t&bench_hashmap_with_bloom,\n\t&bench_bpf_loop,\n\t&bench_strncmp_no_helper,\n\t&bench_strncmp_helper,\n\t&bench_bpf_hashmap_full_update,\n\t&bench_local_storage_cache_seq_get,\n\t&bench_local_storage_cache_interleaved_get,\n\t&bench_local_storage_cache_hashmap_control,\n\t&bench_local_storage_tasks_trace,\n\t&bench_bpf_hashmap_lookup,\n\t&bench_local_storage_create,\n\t&bench_htab_mem,\n};\n\nstatic void find_benchmark(void)\n{\n\tint i;\n\n\tif (!env.bench_name) {\n\t\tfprintf(stderr, \"benchmark name is not specified\\n\");\n\t\texit(1);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(benchs); i++) {\n\t\tif (strcmp(benchs[i]->name, env.bench_name) == 0) {\n\t\t\tbench = benchs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bench) {\n\t\tfprintf(stderr, \"benchmark '%s' not found\\n\", env.bench_name);\n\t\texit(1);\n\t}\n}\n\nstatic void setup_benchmark(void)\n{\n\tint i, err;\n\n\tif (!env.quiet)\n\t\tprintf(\"Setting up benchmark '%s'...\\n\", bench->name);\n\n\tstate.producers = calloc(env.producer_cnt, sizeof(*state.producers));\n\tstate.consumers = calloc(env.consumer_cnt, sizeof(*state.consumers));\n\tstate.results = calloc(env.duration_sec + env.warmup_sec + 2,\n\t\t\t       sizeof(*state.results));\n\tif (!state.producers || !state.consumers || !state.results)\n\t\texit(1);\n\n\tif (bench->validate)\n\t\tbench->validate();\n\tif (bench->setup)\n\t\tbench->setup();\n\n\tfor (i = 0; i < env.consumer_cnt; i++) {\n\t\terr = pthread_create(&state.consumers[i], NULL,\n\t\t\t\t     bench->consumer_thread, (void *)(long)i);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"failed to create consumer thread #%d: %d\\n\",\n\t\t\t\ti, -err);\n\t\t\texit(1);\n\t\t}\n\t\tif (env.affinity)\n\t\t\tset_thread_affinity(state.consumers[i],\n\t\t\t\t\t    next_cpu(&env.cons_cpus));\n\t}\n\n\t \n\tif (!env.prod_cpus.cpus)\n\t\tenv.prod_cpus.next_cpu = env.cons_cpus.next_cpu;\n\n\tfor (i = 0; i < env.producer_cnt; i++) {\n\t\terr = pthread_create(&state.producers[i], NULL,\n\t\t\t\t     bench->producer_thread, (void *)(long)i);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"failed to create producer thread #%d: %d\\n\",\n\t\t\t\ti, -err);\n\t\t\texit(1);\n\t\t}\n\t\tif (env.affinity)\n\t\t\tset_thread_affinity(state.producers[i],\n\t\t\t\t\t    next_cpu(&env.prod_cpus));\n\t}\n\n\tif (!env.quiet)\n\t\tprintf(\"Benchmark '%s' started.\\n\", bench->name);\n}\n\nstatic pthread_mutex_t bench_done_mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t bench_done = PTHREAD_COND_INITIALIZER;\n\nstatic void collect_measurements(long delta_ns) {\n\tint iter = state.res_cnt++;\n\tstruct bench_res *res = &state.results[iter];\n\n\tbench->measure(res);\n\n\tif (bench->report_progress)\n\t\tbench->report_progress(iter, res, delta_ns);\n\n\tif (iter == env.duration_sec + env.warmup_sec) {\n\t\tpthread_mutex_lock(&bench_done_mtx);\n\t\tpthread_cond_signal(&bench_done);\n\t\tpthread_mutex_unlock(&bench_done_mtx);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tenv.nr_cpus = get_nprocs();\n\tparse_cmdline_args_init(argc, argv);\n\n\tif (env.list) {\n\t\tint i;\n\n\t\tprintf(\"Available benchmarks:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(benchs); i++) {\n\t\t\tprintf(\"- %s\\n\", benchs[i]->name);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfind_benchmark();\n\tparse_cmdline_args_final(argc, argv);\n\n\tsetup_benchmark();\n\n\tsetup_timer();\n\n\tpthread_mutex_lock(&bench_done_mtx);\n\tpthread_cond_wait(&bench_done, &bench_done_mtx);\n\tpthread_mutex_unlock(&bench_done_mtx);\n\n\tif (bench->report_final)\n\t\t \n\t\tbench->report_final(state.results + env.warmup_sec,\n\t\t\t\t    state.res_cnt - env.warmup_sec);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}