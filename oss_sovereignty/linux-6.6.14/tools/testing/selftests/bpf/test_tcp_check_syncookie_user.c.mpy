{
  "module_name": "test_tcp_check_syncookie_user.c",
  "hash_id": "a03af044b137c4ce1799d1fcc59bc19663c549e13e8438eb0027b87750b6c859",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_tcp_check_syncookie_user.c",
  "human_readable_source": "\n\n\n\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"cgroup_helpers.h\"\n\nstatic int start_server(const struct sockaddr *addr, socklen_t len, bool dual)\n{\n\tint mode = !dual;\n\tint fd;\n\n\tfd = socket(addr->sa_family, SOCK_STREAM, 0);\n\tif (fd == -1) {\n\t\tlog_err(\"Failed to create server socket\");\n\t\tgoto out;\n\t}\n\n\tif (addr->sa_family == AF_INET6) {\n\t\tif (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&mode,\n\t\t\t       sizeof(mode)) == -1) {\n\t\t\tlog_err(\"Failed to set the dual-stack mode\");\n\t\t\tgoto close_out;\n\t\t}\n\t}\n\n\tif (bind(fd, addr, len) == -1) {\n\t\tlog_err(\"Failed to bind server socket\");\n\t\tgoto close_out;\n\t}\n\n\tif (listen(fd, 128) == -1) {\n\t\tlog_err(\"Failed to listen on server socket\");\n\t\tgoto close_out;\n\t}\n\n\tgoto out;\n\nclose_out:\n\tclose(fd);\n\tfd = -1;\nout:\n\treturn fd;\n}\n\nstatic int connect_to_server(const struct sockaddr *addr, socklen_t len)\n{\n\tint fd = -1;\n\n\tfd = socket(addr->sa_family, SOCK_STREAM, 0);\n\tif (fd == -1) {\n\t\tlog_err(\"Failed to create client socket\");\n\t\tgoto out;\n\t}\n\n\tif (connect(fd, (const struct sockaddr *)addr, len) == -1) {\n\t\tlog_err(\"Fail to connect to server\");\n\t\tgoto close_out;\n\t}\n\n\tgoto out;\n\nclose_out:\n\tclose(fd);\n\tfd = -1;\nout:\n\treturn fd;\n}\n\nstatic int get_map_fd_by_prog_id(int prog_id, bool *xdp)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\t__u32 map_ids[1];\n\tint prog_fd = -1;\n\tint map_fd = -1;\n\n\tprog_fd = bpf_prog_get_fd_by_id(prog_id);\n\tif (prog_fd < 0) {\n\t\tlog_err(\"Failed to get fd by prog id %d\", prog_id);\n\t\tgoto err;\n\t}\n\n\tinfo.nr_map_ids = 1;\n\tinfo.map_ids = (__u64)(unsigned long)map_ids;\n\n\tif (bpf_prog_get_info_by_fd(prog_fd, &info, &info_len)) {\n\t\tlog_err(\"Failed to get info by prog fd %d\", prog_fd);\n\t\tgoto err;\n\t}\n\n\tif (!info.nr_map_ids) {\n\t\tlog_err(\"No maps found for prog fd %d\", prog_fd);\n\t\tgoto err;\n\t}\n\n\t*xdp = info.type == BPF_PROG_TYPE_XDP;\n\n\tmap_fd = bpf_map_get_fd_by_id(map_ids[0]);\n\tif (map_fd < 0)\n\t\tlog_err(\"Failed to get fd by map id %d\", map_ids[0]);\nerr:\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\treturn map_fd;\n}\n\nstatic int run_test(int server_fd, int results_fd, bool xdp,\n\t\t    const struct sockaddr *addr, socklen_t len)\n{\n\tint client = -1, srv_client = -1;\n\tint ret = 0;\n\t__u32 key = 0;\n\t__u32 key_gen = 1;\n\t__u32 key_mss = 2;\n\t__u32 value = 0;\n\t__u32 value_gen = 0;\n\t__u32 value_mss = 0;\n\n\tif (bpf_map_update_elem(results_fd, &key, &value, 0) < 0) {\n\t\tlog_err(\"Can't clear results\");\n\t\tgoto err;\n\t}\n\n\tif (bpf_map_update_elem(results_fd, &key_gen, &value_gen, 0) < 0) {\n\t\tlog_err(\"Can't clear results\");\n\t\tgoto err;\n\t}\n\n\tif (bpf_map_update_elem(results_fd, &key_mss, &value_mss, 0) < 0) {\n\t\tlog_err(\"Can't clear results\");\n\t\tgoto err;\n\t}\n\n\tclient = connect_to_server(addr, len);\n\tif (client == -1)\n\t\tgoto err;\n\n\tsrv_client = accept(server_fd, NULL, 0);\n\tif (srv_client == -1) {\n\t\tlog_err(\"Can't accept connection\");\n\t\tgoto err;\n\t}\n\n\tif (bpf_map_lookup_elem(results_fd, &key, &value) < 0) {\n\t\tlog_err(\"Can't lookup result\");\n\t\tgoto err;\n\t}\n\n\tif (value == 0) {\n\t\tlog_err(\"Didn't match syncookie: %u\", value);\n\t\tgoto err;\n\t}\n\n\tif (bpf_map_lookup_elem(results_fd, &key_gen, &value_gen) < 0) {\n\t\tlog_err(\"Can't lookup result\");\n\t\tgoto err;\n\t}\n\n\tif (xdp && value_gen == 0) {\n\t\t\n\t\t\n\t\tprintf(\"Skipping XDP cookie check\\n\");\n\t\tgoto out;\n\t}\n\n\tif (bpf_map_lookup_elem(results_fd, &key_mss, &value_mss) < 0) {\n\t\tlog_err(\"Can't lookup result\");\n\t\tgoto err;\n\t}\n\n\tif (value != value_gen) {\n\t\tlog_err(\"BPF generated cookie does not match kernel one\");\n\t\tgoto err;\n\t}\n\n\tif (value_mss < 536 || value_mss > USHRT_MAX) {\n\t\tlog_err(\"Unexpected MSS retrieved\");\n\t\tgoto err;\n\t}\n\n\tgoto out;\n\nerr:\n\tret = 1;\nout:\n\tclose(client);\n\tclose(srv_client);\n\treturn ret;\n}\n\nstatic bool get_port(int server_fd, in_port_t *port)\n{\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof(addr);\n\n\tif (getsockname(server_fd, (struct sockaddr *)&addr, &len)) {\n\t\tlog_err(\"Failed to get server addr\");\n\t\treturn false;\n\t}\n\n\t \n\t*port = addr.sin_port;\n\treturn true;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct sockaddr_in addr4;\n\tstruct sockaddr_in6 addr6;\n\tstruct sockaddr_in addr4dual;\n\tstruct sockaddr_in6 addr6dual;\n\tint server = -1;\n\tint server_v6 = -1;\n\tint server_dual = -1;\n\tint results = -1;\n\tint err = 0;\n\tbool xdp;\n\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage: %s prog_id\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tresults = get_map_fd_by_prog_id(atoi(argv[1]), &xdp);\n\tif (results < 0) {\n\t\tlog_err(\"Can't get map\");\n\t\tgoto err;\n\t}\n\n\tmemset(&addr4, 0, sizeof(addr4));\n\taddr4.sin_family = AF_INET;\n\taddr4.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr4.sin_port = 0;\n\tmemcpy(&addr4dual, &addr4, sizeof(addr4dual));\n\n\tmemset(&addr6, 0, sizeof(addr6));\n\taddr6.sin6_family = AF_INET6;\n\taddr6.sin6_addr = in6addr_loopback;\n\taddr6.sin6_port = 0;\n\n\tmemset(&addr6dual, 0, sizeof(addr6dual));\n\taddr6dual.sin6_family = AF_INET6;\n\taddr6dual.sin6_addr = in6addr_any;\n\taddr6dual.sin6_port = 0;\n\n\tserver = start_server((const struct sockaddr *)&addr4, sizeof(addr4),\n\t\t\t      false);\n\tif (server == -1 || !get_port(server, &addr4.sin_port))\n\t\tgoto err;\n\n\tserver_v6 = start_server((const struct sockaddr *)&addr6,\n\t\t\t\t sizeof(addr6), false);\n\tif (server_v6 == -1 || !get_port(server_v6, &addr6.sin6_port))\n\t\tgoto err;\n\n\tserver_dual = start_server((const struct sockaddr *)&addr6dual,\n\t\t\t\t   sizeof(addr6dual), true);\n\tif (server_dual == -1 || !get_port(server_dual, &addr4dual.sin_port))\n\t\tgoto err;\n\n\tif (run_test(server, results, xdp,\n\t\t     (const struct sockaddr *)&addr4, sizeof(addr4)))\n\t\tgoto err;\n\n\tif (run_test(server_v6, results, xdp,\n\t\t     (const struct sockaddr *)&addr6, sizeof(addr6)))\n\t\tgoto err;\n\n\tif (run_test(server_dual, results, xdp,\n\t\t     (const struct sockaddr *)&addr4dual, sizeof(addr4dual)))\n\t\tgoto err;\n\n\tprintf(\"ok\\n\");\n\tgoto out;\nerr:\n\terr = 1;\nout:\n\tclose(server);\n\tclose(server_v6);\n\tclose(server_dual);\n\tclose(results);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}