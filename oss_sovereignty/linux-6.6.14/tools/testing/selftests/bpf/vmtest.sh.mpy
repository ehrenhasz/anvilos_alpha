{
  "module_name": "vmtest.sh",
  "hash_id": "ce77bd025f4b4d7b3cb6a2eb7e0a8bed74a6bb46c4a7edf6e8ae51ad56a95252",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/vmtest.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nset -u\nset -e\n\n# This script currently only works for x86_64 and s390x, as\n# it is based on the VM image used by the BPF CI, which is\n# available only for these architectures.\nARCH=\"$(uname -m)\"\ncase \"${ARCH}\" in\ns390x)\n\tQEMU_BINARY=qemu-system-s390x\n\tQEMU_CONSOLE=\"ttyS1\"\n\tQEMU_FLAGS=(-smp 2)\n\tBZIMAGE=\"arch/s390/boot/vmlinux\"\n\t;;\nx86_64)\n\tQEMU_BINARY=qemu-system-x86_64\n\tQEMU_CONSOLE=\"ttyS0,115200\"\n\tQEMU_FLAGS=(-cpu host -smp 8)\n\tBZIMAGE=\"arch/x86/boot/bzImage\"\n\t;;\naarch64)\n\tQEMU_BINARY=qemu-system-aarch64\n\tQEMU_CONSOLE=\"ttyAMA0,115200\"\n\tQEMU_FLAGS=(-M virt,gic-version=3 -cpu host -smp 8)\n\tBZIMAGE=\"arch/arm64/boot/Image\"\n\t;;\n*)\n\techo \"Unsupported architecture\"\n\texit 1\n\t;;\nesac\nDEFAULT_COMMAND=\"./test_progs\"\nMOUNT_DIR=\"mnt\"\nROOTFS_IMAGE=\"root.img\"\nOUTPUT_DIR=\"$HOME/.bpf_selftests\"\nKCONFIG_REL_PATHS=(\"tools/testing/selftests/bpf/config\" \"tools/testing/selftests/bpf/config.${ARCH}\")\nINDEX_URL=\"https://raw.githubusercontent.com/libbpf/ci/master/INDEX\"\nNUM_COMPILE_JOBS=\"$(nproc)\"\nLOG_FILE_BASE=\"$(date +\"bpf_selftests.%Y-%m-%d_%H-%M-%S\")\"\nLOG_FILE=\"${LOG_FILE_BASE}.log\"\nEXIT_STATUS_FILE=\"${LOG_FILE_BASE}.exit_status\"\n\nusage()\n{\n\tcat <<EOF\nUsage: $0 [-i] [-s] [-d <output_dir>] -- [<command>]\n\n<command> is the command you would normally run when you are in\ntools/testing/selftests/bpf. e.g:\n\n\t$0 -- ./test_progs -t test_lsm\n\nIf no command is specified and a debug shell (-s) is not requested,\n\"${DEFAULT_COMMAND}\" will be run by default.\n\nIf you build your kernel using KBUILD_OUTPUT= or O= options, these\ncan be passed as environment variables to the script:\n\n  O=<kernel_build_path> $0 -- ./test_progs -t test_lsm\n\nor\n\n  KBUILD_OUTPUT=<kernel_build_path> $0 -- ./test_progs -t test_lsm\n\nOptions:\n\n\t-i)\t\tUpdate the rootfs image with a newer version.\n\t-d)\t\tUpdate the output directory (default: ${OUTPUT_DIR})\n\t-j)\t\tNumber of jobs for compilation, similar to -j in make\n\t\t\t(default: ${NUM_COMPILE_JOBS})\n\t-s)\t\tInstead of powering off the VM, start an interactive\n\t\t\tshell. If <command> is specified, the shell runs after\n\t\t\tthe command finishes executing\nEOF\n}\n\nunset URLS\npopulate_url_map()\n{\n\tif ! declare -p URLS &> /dev/null; then\n\t\t# URLS contain the mapping from file names to URLs where\n\t\t# those files can be downloaded from.\n\t\tdeclare -gA URLS\n\t\twhile IFS=$'\\t' read -r name url; do\n\t\t\tURLS[\"$name\"]=\"$url\"\n\t\tdone < <(curl -Lsf ${INDEX_URL})\n\tfi\n}\n\ndownload()\n{\n\tlocal file=\"$1\"\n\n\tif [[ ! -v URLS[$file] ]]; then\n\t\techo \"$file not found\" >&2\n\t\treturn 1\n\tfi\n\n\techo \"Downloading $file...\" >&2\n\tcurl -Lsf \"${URLS[$file]}\" \"${@:2}\"\n}\n\nnewest_rootfs_version()\n{\n\t{\n\tfor file in \"${!URLS[@]}\"; do\n\t\tif [[ $file =~ ^\"${ARCH}\"/libbpf-vmtest-rootfs-(.*)\\.tar\\.zst$ ]]; then\n\t\t\techo \"${BASH_REMATCH[1]}\"\n\t\tfi\n\tdone\n\t} | sort -rV | head -1\n}\n\ndownload_rootfs()\n{\n\tlocal rootfsversion=\"$1\"\n\tlocal dir=\"$2\"\n\n\tif ! which zstd &> /dev/null; then\n\t\techo 'Could not find \"zstd\" on the system, please install zstd'\n\t\texit 1\n\tfi\n\n\tdownload \"${ARCH}/libbpf-vmtest-rootfs-$rootfsversion.tar.zst\" |\n\t\tzstd -d | sudo tar -C \"$dir\" -x\n}\n\nrecompile_kernel()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal make_command=\"$2\"\n\n\tcd \"${kernel_checkout}\"\n\n\t${make_command} olddefconfig\n\t${make_command}\n}\n\nmount_image()\n{\n\tlocal rootfs_img=\"${OUTPUT_DIR}/${ROOTFS_IMAGE}\"\n\tlocal mount_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}\"\n\n\tsudo mount -o loop \"${rootfs_img}\" \"${mount_dir}\"\n}\n\nunmount_image()\n{\n\tlocal mount_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}\"\n\n\tsudo umount \"${mount_dir}\" &> /dev/null\n}\n\nupdate_selftests()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal selftests_dir=\"${kernel_checkout}/tools/testing/selftests/bpf\"\n\n\tcd \"${selftests_dir}\"\n\t${make_command}\n\n\t# Mount the image and copy the selftests to the image.\n\tmount_image\n\tsudo rm -rf \"${mount_dir}/root/bpf\"\n\tsudo cp -r \"${selftests_dir}\" \"${mount_dir}/root\"\n\tunmount_image\n}\n\nupdate_init_script()\n{\n\tlocal init_script_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}/etc/rcS.d\"\n\tlocal init_script=\"${init_script_dir}/S50-startup\"\n\tlocal command=\"$1\"\n\tlocal exit_command=\"$2\"\n\n\tmount_image\n\n\tif [[ ! -d \"${init_script_dir}\" ]]; then\n\t\tcat <<EOF\nCould not find ${init_script_dir} in the mounted image.\nThis likely indicates a bad rootfs image, Please download\na new image by passing \"-i\" to the script\nEOF\n\t\texit 1\n\n\tfi\n\n\tsudo bash -c \"echo '#!/bin/bash' > ${init_script}\"\n\n\tif [[ \"${command}\" != \"\" ]]; then\n\t\tsudo bash -c \"cat >>${init_script}\" <<EOF\n# Have a default value in the exit status file\n# incase the VM is forcefully stopped.\necho \"130\" > \"/root/${EXIT_STATUS_FILE}\"\n\n{\n\tcd /root/bpf\n\techo ${command}\n\tstdbuf -oL -eL ${command}\n\techo \"\\$?\" > \"/root/${EXIT_STATUS_FILE}\"\n} 2>&1 | tee \"/root/${LOG_FILE}\"\n# Ensure that the logs are written to disk\nsync\nEOF\n\tfi\n\n\tsudo bash -c \"echo ${exit_command} >> ${init_script}\"\n\tsudo chmod a+x \"${init_script}\"\n\tunmount_image\n}\n\ncreate_vm_image()\n{\n\tlocal rootfs_img=\"${OUTPUT_DIR}/${ROOTFS_IMAGE}\"\n\tlocal mount_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}\"\n\n\trm -rf \"${rootfs_img}\"\n\ttouch \"${rootfs_img}\"\n\tchattr +C \"${rootfs_img}\" >/dev/null 2>&1 || true\n\n\ttruncate -s 2G \"${rootfs_img}\"\n\tmkfs.ext4 -q \"${rootfs_img}\"\n\n\tmount_image\n\tdownload_rootfs \"$(newest_rootfs_version)\" \"${mount_dir}\"\n\tunmount_image\n}\n\nrun_vm()\n{\n\tlocal kernel_bzimage=\"$1\"\n\tlocal rootfs_img=\"${OUTPUT_DIR}/${ROOTFS_IMAGE}\"\n\n\tif ! which \"${QEMU_BINARY}\" &> /dev/null; then\n\t\tcat <<EOF\nCould not find ${QEMU_BINARY}\nPlease install qemu or set the QEMU_BINARY environment variable.\nEOF\n\t\texit 1\n\tfi\n\n\t${QEMU_BINARY} \\\n\t\t-nodefaults \\\n\t\t-display none \\\n\t\t-serial mon:stdio \\\n\t\t\"${QEMU_FLAGS[@]}\" \\\n\t\t-enable-kvm \\\n\t\t-m 4G \\\n\t\t-drive file=\"${rootfs_img}\",format=raw,index=1,media=disk,if=virtio,cache=none \\\n\t\t-kernel \"${kernel_bzimage}\" \\\n\t\t-append \"root=/dev/vda rw console=${QEMU_CONSOLE}\"\n}\n\ncopy_logs()\n{\n\tlocal mount_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}\"\n\tlocal log_file=\"${mount_dir}/root/${LOG_FILE}\"\n\tlocal exit_status_file=\"${mount_dir}/root/${EXIT_STATUS_FILE}\"\n\n\tmount_image\n\tsudo cp ${log_file} \"${OUTPUT_DIR}\"\n\tsudo cp ${exit_status_file} \"${OUTPUT_DIR}\"\n\tsudo rm -f ${log_file}\n\tunmount_image\n}\n\nis_rel_path()\n{\n\tlocal path=\"$1\"\n\n\t[[ ${path:0:1} != \"/\" ]]\n}\n\ndo_update_kconfig()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal kconfig_file=\"$2\"\n\n\trm -f \"$kconfig_file\" 2> /dev/null\n\n\tfor config in \"${KCONFIG_REL_PATHS[@]}\"; do\n\t\tlocal kconfig_src=\"${kernel_checkout}/${config}\"\n\t\tcat \"$kconfig_src\" >> \"$kconfig_file\"\n\tdone\n}\n\nupdate_kconfig()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal kconfig_file=\"$2\"\n\n\tif [[ -f \"${kconfig_file}\" ]]; then\n\t\tlocal local_modified=\"$(stat -c %Y \"${kconfig_file}\")\"\n\n\t\tfor config in \"${KCONFIG_REL_PATHS[@]}\"; do\n\t\t\tlocal kconfig_src=\"${kernel_checkout}/${config}\"\n\t\t\tlocal src_modified=\"$(stat -c %Y \"${kconfig_src}\")\"\n\t\t\t# Only update the config if it has been updated after the\n\t\t\t# previously cached config was created. This avoids\n\t\t\t# unnecessarily compiling the kernel and selftests.\n\t\t\tif [[ \"${src_modified}\" -gt \"${local_modified}\" ]]; then\n\t\t\t\tdo_update_kconfig \"$kernel_checkout\" \"$kconfig_file\"\n\t\t\t\t# Once we have found one outdated configuration\n\t\t\t\t# there is no need to check other ones.\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\telse\n\t\tdo_update_kconfig \"$kernel_checkout\" \"$kconfig_file\"\n\tfi\n}\n\ncatch()\n{\n\tlocal exit_code=$1\n\tlocal exit_status_file=\"${OUTPUT_DIR}/${EXIT_STATUS_FILE}\"\n\t# This is just a cleanup and the directory may\n\t# have already been unmounted. So, don't let this\n\t# clobber the error code we intend to return.\n\tunmount_image || true\n\tif [[ -f \"${exit_status_file}\" ]]; then\n\t\texit_code=\"$(cat ${exit_status_file})\"\n\tfi\n\texit ${exit_code}\n}\n\nmain()\n{\n\tlocal script_dir=\"$(cd -P -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"\n\tlocal kernel_checkout=$(realpath \"${script_dir}\"/../../../../)\n\t# By default the script searches for the kernel in the checkout directory but\n\t# it also obeys environment variables O= and KBUILD_OUTPUT=\n\tlocal kernel_bzimage=\"${kernel_checkout}/${BZIMAGE}\"\n\tlocal command=\"${DEFAULT_COMMAND}\"\n\tlocal update_image=\"no\"\n\tlocal exit_command=\"poweroff -f\"\n\tlocal debug_shell=\"no\"\n\n\twhile getopts ':hskid:j:' opt; do\n\t\tcase ${opt} in\n\t\ti)\n\t\t\tupdate_image=\"yes\"\n\t\t\t;;\n\t\td)\n\t\t\tOUTPUT_DIR=\"$OPTARG\"\n\t\t\t;;\n\t\tj)\n\t\t\tNUM_COMPILE_JOBS=\"$OPTARG\"\n\t\t\t;;\n\t\ts)\n\t\t\tcommand=\"\"\n\t\t\tdebug_shell=\"yes\"\n\t\t\texit_command=\"bash\"\n\t\t\t;;\n\t\th)\n\t\t\tusage\n\t\t\texit 0\n\t\t\t;;\n\t\t\\? )\n\t\t\techo \"Invalid Option: -$OPTARG\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t: )\n\t\t\techo \"Invalid Option: -$OPTARG requires an argument\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\tesac\n\tdone\n\tshift $((OPTIND -1))\n\n\ttrap 'catch \"$?\"' EXIT\n\n\tif [[ $# -eq 0  && \"${debug_shell}\" == \"no\" ]]; then\n\t\techo \"No command specified, will run ${DEFAULT_COMMAND} in the vm\"\n\telse\n\t\tcommand=\"$@\"\n\tfi\n\n\tlocal kconfig_file=\"${OUTPUT_DIR}/latest.config\"\n\tlocal make_command=\"make -j ${NUM_COMPILE_JOBS} KCONFIG_CONFIG=${kconfig_file}\"\n\n\t# Figure out where the kernel is being built.\n\t# O takes precedence over KBUILD_OUTPUT.\n\tif [[ \"${O:=\"\"}\" != \"\" ]]; then\n\t\tif is_rel_path \"${O}\"; then\n\t\t\tO=\"$(realpath \"${PWD}/${O}\")\"\n\t\tfi\n\t\tkernel_bzimage=\"${O}/${BZIMAGE}\"\n\t\tmake_command=\"${make_command} O=${O}\"\n\telif [[ \"${KBUILD_OUTPUT:=\"\"}\" != \"\" ]]; then\n\t\tif is_rel_path \"${KBUILD_OUTPUT}\"; then\n\t\t\tKBUILD_OUTPUT=\"$(realpath \"${PWD}/${KBUILD_OUTPUT}\")\"\n\t\tfi\n\t\tkernel_bzimage=\"${KBUILD_OUTPUT}/${BZIMAGE}\"\n\t\tmake_command=\"${make_command} KBUILD_OUTPUT=${KBUILD_OUTPUT}\"\n\tfi\n\n\tpopulate_url_map\n\n\tlocal rootfs_img=\"${OUTPUT_DIR}/${ROOTFS_IMAGE}\"\n\tlocal mount_dir=\"${OUTPUT_DIR}/${MOUNT_DIR}\"\n\n\techo \"Output directory: ${OUTPUT_DIR}\"\n\n\tmkdir -p \"${OUTPUT_DIR}\"\n\tmkdir -p \"${mount_dir}\"\n\tupdate_kconfig \"${kernel_checkout}\" \"${kconfig_file}\"\n\n\trecompile_kernel \"${kernel_checkout}\" \"${make_command}\"\n\n\tif [[ \"${update_image}\" == \"no\" && ! -f \"${rootfs_img}\" ]]; then\n\t\techo \"rootfs image not found in ${rootfs_img}\"\n\t\tupdate_image=\"yes\"\n\tfi\n\n\tif [[ \"${update_image}\" == \"yes\" ]]; then\n\t\tcreate_vm_image\n\tfi\n\n\tupdate_selftests \"${kernel_checkout}\" \"${make_command}\"\n\tupdate_init_script \"${command}\" \"${exit_command}\"\n\trun_vm \"${kernel_bzimage}\"\n\tif [[ \"${command}\" != \"\" ]]; then\n\t\tcopy_logs\n\t\techo \"Logs saved in ${OUTPUT_DIR}/${LOG_FILE}\"\n\tfi\n}\n\nmain \"$@\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}