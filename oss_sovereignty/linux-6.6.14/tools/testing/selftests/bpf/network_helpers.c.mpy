{
  "module_name": "network_helpers.c",
  "hash_id": "0ce1843a399f5abce4a053e07b02ac8f1dc33ce9a09c0afee451009092c4bbbc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/network_helpers.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sched.h>\n\n#include <arpa/inet.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n\n#include <linux/err.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/limits.h>\n\n#include \"bpf_util.h\"\n#include \"network_helpers.h\"\n#include \"test_progs.h\"\n\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n\n#define clean_errno() (errno == 0 ? \"None\" : strerror(errno))\n#define log_err(MSG, ...) ({\t\t\t\t\t\t\\\n\t\t\tint __save = errno;\t\t\t\t\\\n\t\t\tfprintf(stderr, \"(%s:%d: errno: %s) \" MSG \"\\n\", \\\n\t\t\t\t__FILE__, __LINE__, clean_errno(),\t\\\n\t\t\t\t##__VA_ARGS__);\t\t\t\t\\\n\t\t\terrno = __save;\t\t\t\t\t\\\n})\n\nstruct ipv4_packet pkt_v4 = {\n\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t.iph.ihl = 5,\n\t.iph.protocol = IPPROTO_TCP,\n\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t.tcp.urg_ptr = 123,\n\t.tcp.doff = 5,\n};\n\nstruct ipv6_packet pkt_v6 = {\n\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t.iph.nexthdr = IPPROTO_TCP,\n\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t.tcp.urg_ptr = 123,\n\t.tcp.doff = 5,\n};\n\nint settimeo(int fd, int timeout_ms)\n{\n\tstruct timeval timeout = { .tv_sec = 3 };\n\n\tif (timeout_ms > 0) {\n\t\ttimeout.tv_sec = timeout_ms / 1000;\n\t\ttimeout.tv_usec = (timeout_ms % 1000) * 1000;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout,\n\t\t       sizeof(timeout))) {\n\t\tlog_err(\"Failed to set SO_RCVTIMEO\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout,\n\t\t       sizeof(timeout))) {\n\t\tlog_err(\"Failed to set SO_SNDTIMEO\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#define save_errno_close(fd) ({ int __save = errno; close(fd); errno = __save; })\n\nstatic int __start_server(int type, int protocol, const struct sockaddr *addr,\n\t\t\t  socklen_t addrlen, int timeout_ms, bool reuseport)\n{\n\tint on = 1;\n\tint fd;\n\n\tfd = socket(addr->sa_family, type, protocol);\n\tif (fd < 0) {\n\t\tlog_err(\"Failed to create server socket\");\n\t\treturn -1;\n\t}\n\n\tif (settimeo(fd, timeout_ms))\n\t\tgoto error_close;\n\n\tif (reuseport &&\n\t    setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on))) {\n\t\tlog_err(\"Failed to set SO_REUSEPORT\");\n\t\tgoto error_close;\n\t}\n\n\tif (bind(fd, addr, addrlen) < 0) {\n\t\tlog_err(\"Failed to bind socket\");\n\t\tgoto error_close;\n\t}\n\n\tif (type == SOCK_STREAM) {\n\t\tif (listen(fd, 1) < 0) {\n\t\t\tlog_err(\"Failed to listed on socket\");\n\t\t\tgoto error_close;\n\t\t}\n\t}\n\n\treturn fd;\n\nerror_close:\n\tsave_errno_close(fd);\n\treturn -1;\n}\n\nstatic int start_server_proto(int family, int type, int protocol,\n\t\t\t      const char *addr_str, __u16 port, int timeout_ms)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\n\tif (make_sockaddr(family, addr_str, port, &addr, &addrlen))\n\t\treturn -1;\n\n\treturn __start_server(type, protocol, (struct sockaddr *)&addr,\n\t\t\t      addrlen, timeout_ms, false);\n}\n\nint start_server(int family, int type, const char *addr_str, __u16 port,\n\t\t int timeout_ms)\n{\n\treturn start_server_proto(family, type, 0, addr_str, port, timeout_ms);\n}\n\nint start_mptcp_server(int family, const char *addr_str, __u16 port,\n\t\t       int timeout_ms)\n{\n\treturn start_server_proto(family, SOCK_STREAM, IPPROTO_MPTCP, addr_str,\n\t\t\t\t  port, timeout_ms);\n}\n\nint *start_reuseport_server(int family, int type, const char *addr_str,\n\t\t\t    __u16 port, int timeout_ms, unsigned int nr_listens)\n{\n\tstruct sockaddr_storage addr;\n\tunsigned int nr_fds = 0;\n\tsocklen_t addrlen;\n\tint *fds;\n\n\tif (!nr_listens)\n\t\treturn NULL;\n\n\tif (make_sockaddr(family, addr_str, port, &addr, &addrlen))\n\t\treturn NULL;\n\n\tfds = malloc(sizeof(*fds) * nr_listens);\n\tif (!fds)\n\t\treturn NULL;\n\n\tfds[0] = __start_server(type, 0, (struct sockaddr *)&addr, addrlen,\n\t\t\t\ttimeout_ms, true);\n\tif (fds[0] == -1)\n\t\tgoto close_fds;\n\tnr_fds = 1;\n\n\tif (getsockname(fds[0], (struct sockaddr *)&addr, &addrlen))\n\t\tgoto close_fds;\n\n\tfor (; nr_fds < nr_listens; nr_fds++) {\n\t\tfds[nr_fds] = __start_server(type, 0, (struct sockaddr *)&addr,\n\t\t\t\t\t     addrlen, timeout_ms, true);\n\t\tif (fds[nr_fds] == -1)\n\t\t\tgoto close_fds;\n\t}\n\n\treturn fds;\n\nclose_fds:\n\tfree_fds(fds, nr_fds);\n\treturn NULL;\n}\n\nvoid free_fds(int *fds, unsigned int nr_close_fds)\n{\n\tif (fds) {\n\t\twhile (nr_close_fds)\n\t\t\tclose(fds[--nr_close_fds]);\n\t\tfree(fds);\n\t}\n}\n\nint fastopen_connect(int server_fd, const char *data, unsigned int data_len,\n\t\t     int timeout_ms)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tstruct sockaddr_in *addr_in;\n\tint fd, ret;\n\n\tif (getsockname(server_fd, (struct sockaddr *)&addr, &addrlen)) {\n\t\tlog_err(\"Failed to get server addr\");\n\t\treturn -1;\n\t}\n\n\taddr_in = (struct sockaddr_in *)&addr;\n\tfd = socket(addr_in->sin_family, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tlog_err(\"Failed to create client socket\");\n\t\treturn -1;\n\t}\n\n\tif (settimeo(fd, timeout_ms))\n\t\tgoto error_close;\n\n\tret = sendto(fd, data, data_len, MSG_FASTOPEN, (struct sockaddr *)&addr,\n\t\t     addrlen);\n\tif (ret != data_len) {\n\t\tlog_err(\"sendto(data, %u) != %d\\n\", data_len, ret);\n\t\tgoto error_close;\n\t}\n\n\treturn fd;\n\nerror_close:\n\tsave_errno_close(fd);\n\treturn -1;\n}\n\nstatic int connect_fd_to_addr(int fd,\n\t\t\t      const struct sockaddr_storage *addr,\n\t\t\t      socklen_t addrlen, const bool must_fail)\n{\n\tint ret;\n\n\terrno = 0;\n\tret = connect(fd, (const struct sockaddr *)addr, addrlen);\n\tif (must_fail) {\n\t\tif (!ret) {\n\t\t\tlog_err(\"Unexpected success to connect to server\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (errno != EPERM) {\n\t\t\tlog_err(\"Unexpected error from connect to server\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (ret) {\n\t\t\tlog_err(\"Failed to connect to server\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct network_helper_opts default_opts;\n\nint connect_to_fd_opts(int server_fd, const struct network_helper_opts *opts)\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *addr_in;\n\tsocklen_t addrlen, optlen;\n\tint fd, type, protocol;\n\n\tif (!opts)\n\t\topts = &default_opts;\n\n\toptlen = sizeof(type);\n\n\tif (opts->type) {\n\t\ttype = opts->type;\n\t} else {\n\t\tif (getsockopt(server_fd, SOL_SOCKET, SO_TYPE, &type, &optlen)) {\n\t\t\tlog_err(\"getsockopt(SOL_TYPE)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (opts->proto) {\n\t\tprotocol = opts->proto;\n\t} else {\n\t\tif (getsockopt(server_fd, SOL_SOCKET, SO_PROTOCOL, &protocol, &optlen)) {\n\t\t\tlog_err(\"getsockopt(SOL_PROTOCOL)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\taddrlen = sizeof(addr);\n\tif (getsockname(server_fd, (struct sockaddr *)&addr, &addrlen)) {\n\t\tlog_err(\"Failed to get server addr\");\n\t\treturn -1;\n\t}\n\n\taddr_in = (struct sockaddr_in *)&addr;\n\tfd = socket(addr_in->sin_family, type, protocol);\n\tif (fd < 0) {\n\t\tlog_err(\"Failed to create client socket\");\n\t\treturn -1;\n\t}\n\n\tif (settimeo(fd, opts->timeout_ms))\n\t\tgoto error_close;\n\n\tif (opts->cc && opts->cc[0] &&\n\t    setsockopt(fd, SOL_TCP, TCP_CONGESTION, opts->cc,\n\t\t       strlen(opts->cc) + 1))\n\t\tgoto error_close;\n\n\tif (!opts->noconnect)\n\t\tif (connect_fd_to_addr(fd, &addr, addrlen, opts->must_fail))\n\t\t\tgoto error_close;\n\n\treturn fd;\n\nerror_close:\n\tsave_errno_close(fd);\n\treturn -1;\n}\n\nint connect_to_fd(int server_fd, int timeout_ms)\n{\n\tstruct network_helper_opts opts = {\n\t\t.timeout_ms = timeout_ms,\n\t};\n\n\treturn connect_to_fd_opts(server_fd, &opts);\n}\n\nint connect_fd_to_fd(int client_fd, int server_fd, int timeout_ms)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len = sizeof(addr);\n\n\tif (settimeo(client_fd, timeout_ms))\n\t\treturn -1;\n\n\tif (getsockname(server_fd, (struct sockaddr *)&addr, &len)) {\n\t\tlog_err(\"Failed to get server addr\");\n\t\treturn -1;\n\t}\n\n\tif (connect_fd_to_addr(client_fd, &addr, len, false))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint make_sockaddr(int family, const char *addr_str, __u16 port,\n\t\t  struct sockaddr_storage *addr, socklen_t *len)\n{\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (void *)addr;\n\n\t\tmemset(addr, 0, sizeof(*sin));\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = htons(port);\n\t\tif (addr_str &&\n\t\t    inet_pton(AF_INET, addr_str, &sin->sin_addr) != 1) {\n\t\t\tlog_err(\"inet_pton(AF_INET, %s)\", addr_str);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len)\n\t\t\t*len = sizeof(*sin);\n\t\treturn 0;\n\t} else if (family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (void *)addr;\n\n\t\tmemset(addr, 0, sizeof(*sin6));\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = htons(port);\n\t\tif (addr_str &&\n\t\t    inet_pton(AF_INET6, addr_str, &sin6->sin6_addr) != 1) {\n\t\t\tlog_err(\"inet_pton(AF_INET6, %s)\", addr_str);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len)\n\t\t\t*len = sizeof(*sin6);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nchar *ping_command(int family)\n{\n\tif (family == AF_INET6) {\n\t\t \n\t\tif (!system(\"which ping6 >/dev/null 2>&1\"))\n\t\t\treturn \"ping6\";\n\t\telse\n\t\t\treturn \"ping -6\";\n\t}\n\treturn \"ping\";\n}\n\nstruct nstoken {\n\tint orig_netns_fd;\n};\n\nstruct nstoken *open_netns(const char *name)\n{\n\tint nsfd;\n\tchar nspath[PATH_MAX];\n\tint err;\n\tstruct nstoken *token;\n\n\ttoken = calloc(1, sizeof(struct nstoken));\n\tif (!ASSERT_OK_PTR(token, \"malloc token\"))\n\t\treturn NULL;\n\n\ttoken->orig_netns_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (!ASSERT_GE(token->orig_netns_fd, 0, \"open /proc/self/ns/net\"))\n\t\tgoto fail;\n\n\tsnprintf(nspath, sizeof(nspath), \"%s/%s\", \"/var/run/netns\", name);\n\tnsfd = open(nspath, O_RDONLY | O_CLOEXEC);\n\tif (!ASSERT_GE(nsfd, 0, \"open netns fd\"))\n\t\tgoto fail;\n\n\terr = setns(nsfd, CLONE_NEWNET);\n\tclose(nsfd);\n\tif (!ASSERT_OK(err, \"setns\"))\n\t\tgoto fail;\n\n\treturn token;\nfail:\n\tfree(token);\n\treturn NULL;\n}\n\nvoid close_netns(struct nstoken *token)\n{\n\tif (!token)\n\t\treturn;\n\n\tASSERT_OK(setns(token->orig_netns_fd, CLONE_NEWNET), \"setns\");\n\tclose(token->orig_netns_fd);\n\tfree(token);\n}\n\nint get_socket_local_port(int sock_fd)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tint err;\n\n\terr = getsockname(sock_fd, (struct sockaddr *)&addr, &addrlen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (addr.ss_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&addr;\n\n\t\treturn sin->sin_port;\n\t} else if (addr.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin = (struct sockaddr_in6 *)&addr;\n\n\t\treturn sin->sin6_port;\n\t}\n\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}