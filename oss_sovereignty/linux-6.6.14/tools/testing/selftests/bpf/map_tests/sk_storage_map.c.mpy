{
  "module_name": "sk_storage_map.c",
  "hash_id": "751931d47155915bcfe3d37372c58617b12bc445f44257fcee5fb26752ac1357",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/sk_storage_map.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/err.h>\n\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <linux/btf.h>\n#include <unistd.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <pthread.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <test_btf.h>\n#include <test_maps.h>\n\nstatic struct bpf_map_create_opts map_opts = {\n\t.sz = sizeof(map_opts),\n\t.btf_key_type_id = 1,\n\t.btf_value_type_id = 3,\n\t.btf_fd = -1,\n\t.map_flags = BPF_F_NO_PREALLOC,\n};\n\nstatic unsigned int nr_sk_threads_done;\nstatic unsigned int nr_sk_threads_err;\nstatic unsigned int nr_sk_per_thread = 4096;\nstatic unsigned int nr_sk_threads = 4;\nstatic int sk_storage_map = -1;\nstatic unsigned int stop;\nstatic int runtime_s = 5;\n\nstatic bool is_stopped(void)\n{\n\treturn READ_ONCE(stop);\n}\n\nstatic unsigned int threads_err(void)\n{\n\treturn READ_ONCE(nr_sk_threads_err);\n}\n\nstatic void notify_thread_err(void)\n{\n\t__sync_add_and_fetch(&nr_sk_threads_err, 1);\n}\n\nstatic bool wait_for_threads_err(void)\n{\n\twhile (!is_stopped() && !threads_err())\n\t\tusleep(500);\n\n\treturn !is_stopped();\n}\n\nstatic unsigned int threads_done(void)\n{\n\treturn READ_ONCE(nr_sk_threads_done);\n}\n\nstatic void notify_thread_done(void)\n{\n\t__sync_add_and_fetch(&nr_sk_threads_done, 1);\n}\n\nstatic void notify_thread_redo(void)\n{\n\t__sync_sub_and_fetch(&nr_sk_threads_done, 1);\n}\n\nstatic bool wait_for_threads_done(void)\n{\n\twhile (threads_done() != nr_sk_threads && !is_stopped() &&\n\t       !threads_err())\n\t\tusleep(50);\n\n\treturn !is_stopped() && !threads_err();\n}\n\nstatic bool wait_for_threads_redo(void)\n{\n\twhile (threads_done() && !is_stopped() && !threads_err())\n\t\tusleep(50);\n\n\treturn !is_stopped() && !threads_err();\n}\n\nstatic bool wait_for_map(void)\n{\n\twhile (READ_ONCE(sk_storage_map) == -1 && !is_stopped())\n\t\tusleep(50);\n\n\treturn !is_stopped();\n}\n\nstatic bool wait_for_map_close(void)\n{\n\twhile (READ_ONCE(sk_storage_map) != -1 && !is_stopped())\n\t\t;\n\n\treturn !is_stopped();\n}\n\nstatic int load_btf(void)\n{\n\tconst char btf_str_sec[] = \"\\0bpf_spin_lock\\0val\\0cnt\\0l\";\n\t__u32 btf_raw_types[] = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),   \n\t\t                        \n\t\tBTF_TYPE_ENC(1, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\n\t\tBTF_MEMBER_ENC(15, 1, 0),  \n\t\t                                  \n\t\tBTF_TYPE_ENC(15, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(19, 1, 0),  \n\t\tBTF_MEMBER_ENC(23, 2, 32), \n\t};\n\tstruct btf_header btf_hdr = {\n\t\t.magic = BTF_MAGIC,\n\t\t.version = BTF_VERSION,\n\t\t.hdr_len = sizeof(struct btf_header),\n\t\t.type_len = sizeof(btf_raw_types),\n\t\t.str_off = sizeof(btf_raw_types),\n\t\t.str_len = sizeof(btf_str_sec),\n\t};\n\t__u8 raw_btf[sizeof(struct btf_header) + sizeof(btf_raw_types) +\n\t\t     sizeof(btf_str_sec)];\n\n\tmemcpy(raw_btf, &btf_hdr, sizeof(btf_hdr));\n\tmemcpy(raw_btf + sizeof(btf_hdr), btf_raw_types, sizeof(btf_raw_types));\n\tmemcpy(raw_btf + sizeof(btf_hdr) + sizeof(btf_raw_types),\n\t       btf_str_sec, sizeof(btf_str_sec));\n\n\treturn bpf_btf_load(raw_btf, sizeof(raw_btf), NULL);\n}\n\nstatic int create_sk_storage_map(void)\n{\n\tint btf_fd, map_fd;\n\n\tbtf_fd = load_btf();\n\tCHECK(btf_fd == -1, \"bpf_load_btf\", \"btf_fd:%d errno:%d\\n\",\n\t      btf_fd, errno);\n\tmap_opts.btf_fd = btf_fd;\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 0, &map_opts);\n\tmap_opts.btf_fd = -1;\n\tclose(btf_fd);\n\tCHECK(map_fd == -1,\n\t      \"bpf_map_create()\", \"errno:%d\\n\", errno);\n\n\treturn map_fd;\n}\n\nstatic void *insert_close_thread(void *arg)\n{\n\tstruct {\n\t\tint cnt;\n\t\tint lock;\n\t} value = { .cnt = 0xeB9F, .lock = 0, };\n\tint i, map_fd, err, *sk_fds;\n\n\tsk_fds = malloc(sizeof(*sk_fds) * nr_sk_per_thread);\n\tif (!sk_fds) {\n\t\tnotify_thread_err();\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nr_sk_per_thread; i++)\n\t\tsk_fds[i] = -1;\n\n\twhile (!is_stopped()) {\n\t\tif (!wait_for_map())\n\t\t\tgoto close_all;\n\n\t\tmap_fd = READ_ONCE(sk_storage_map);\n\t\tfor (i = 0; i < nr_sk_per_thread && !is_stopped(); i++) {\n\t\t\tsk_fds[i] = socket(AF_INET6, SOCK_STREAM, 0);\n\t\t\tif (sk_fds[i] == -1) {\n\t\t\t\terr = -errno;\n\t\t\t\tfprintf(stderr, \"socket(): errno:%d\\n\", errno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = bpf_map_update_elem(map_fd, &sk_fds[i], &value,\n\t\t\t\t\t\t  BPF_NOEXIST);\n\t\t\tif (err) {\n\t\t\t\terr = -errno;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bpf_map_update_elem(): errno:%d\\n\",\n\t\t\t\t\terrno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tnotify_thread_done();\n\t\twait_for_map_close();\n\nclose_all:\n\t\tfor (i = 0; i < nr_sk_per_thread; i++) {\n\t\t\tclose(sk_fds[i]);\n\t\t\tsk_fds[i] = -1;\n\t\t}\n\n\t\tnotify_thread_redo();\n\t}\n\n\tfree(sk_fds);\n\treturn NULL;\n\nerrout:\n\tfor (i = 0; i < nr_sk_per_thread && sk_fds[i] != -1; i++)\n\t\tclose(sk_fds[i]);\n\tfree(sk_fds);\n\tnotify_thread_err();\n\treturn ERR_PTR(err);\n}\n\nstatic int do_sk_storage_map_stress_free(void)\n{\n\tint i, map_fd = -1, err = 0, nr_threads_created = 0;\n\tpthread_t *sk_thread_ids;\n\tvoid *thread_ret;\n\n\tsk_thread_ids = malloc(sizeof(pthread_t) * nr_sk_threads);\n\tif (!sk_thread_ids) {\n\t\tfprintf(stderr, \"malloc(sk_threads): NULL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_sk_threads; i++) {\n\t\terr = pthread_create(&sk_thread_ids[i], NULL,\n\t\t\t\t     insert_close_thread, NULL);\n\t\tif (err) {\n\t\t\terr = -errno;\n\t\t\tgoto done;\n\t\t}\n\t\tnr_threads_created++;\n\t}\n\n\twhile (!is_stopped()) {\n\t\tmap_fd = create_sk_storage_map();\n\t\tWRITE_ONCE(sk_storage_map, map_fd);\n\n\t\tif (!wait_for_threads_done())\n\t\t\tbreak;\n\n\t\tWRITE_ONCE(sk_storage_map, -1);\n\t\tclose(map_fd);\n\t\tmap_fd = -1;\n\n\t\tif (!wait_for_threads_redo())\n\t\t\tbreak;\n\t}\n\ndone:\n\tWRITE_ONCE(stop, 1);\n\tfor (i = 0; i < nr_threads_created; i++) {\n\t\tpthread_join(sk_thread_ids[i], &thread_ret);\n\t\tif (IS_ERR(thread_ret) && !err) {\n\t\t\terr = PTR_ERR(thread_ret);\n\t\t\tfprintf(stderr, \"threads#%u: err:%d\\n\", i, err);\n\t\t}\n\t}\n\tfree(sk_thread_ids);\n\n\tif (map_fd != -1)\n\t\tclose(map_fd);\n\n\treturn err;\n}\n\nstatic void *update_thread(void *arg)\n{\n\tstruct {\n\t\tint cnt;\n\t\tint lock;\n\t} value = { .cnt = 0xeB9F, .lock = 0, };\n\tint map_fd = READ_ONCE(sk_storage_map);\n\tint sk_fd = *(int *)arg;\n\tint err = 0;  \n\n\twhile (!is_stopped()) {\n\t\terr = bpf_map_update_elem(map_fd, &sk_fd, &value, 0);\n\t\tif (err && errno != EAGAIN) {\n\t\t\terr = -errno;\n\t\t\tfprintf(stderr, \"bpf_map_update_elem: %d %d\\n\",\n\t\t\t\terr, errno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_stopped()) {\n\t\tnotify_thread_err();\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *delete_thread(void *arg)\n{\n\tint map_fd = READ_ONCE(sk_storage_map);\n\tint sk_fd = *(int *)arg;\n\tint err = 0;  \n\n\twhile (!is_stopped()) {\n\t\terr = bpf_map_delete_elem(map_fd, &sk_fd);\n\t\tif (err && errno != ENOENT) {\n\t\t\terr = -errno;\n\t\t\tfprintf(stderr, \"bpf_map_delete_elem: %d %d\\n\",\n\t\t\t\terr, errno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_stopped()) {\n\t\tnotify_thread_err();\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn NULL;\n}\n\nstatic int do_sk_storage_map_stress_change(void)\n{\n\tint i, sk_fd, map_fd = -1, err = 0, nr_threads_created = 0;\n\tpthread_t *sk_thread_ids;\n\tvoid *thread_ret;\n\n\tsk_thread_ids = malloc(sizeof(pthread_t) * nr_sk_threads);\n\tif (!sk_thread_ids) {\n\t\tfprintf(stderr, \"malloc(sk_threads): NULL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsk_fd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (sk_fd == -1) {\n\t\terr = -errno;\n\t\tgoto done;\n\t}\n\n\tmap_fd = create_sk_storage_map();\n\tWRITE_ONCE(sk_storage_map, map_fd);\n\n\tfor (i = 0; i < nr_sk_threads; i++) {\n\t\tif (i & 0x1)\n\t\t\terr = pthread_create(&sk_thread_ids[i], NULL,\n\t\t\t\t\t     update_thread, &sk_fd);\n\t\telse\n\t\t\terr = pthread_create(&sk_thread_ids[i], NULL,\n\t\t\t\t\t     delete_thread, &sk_fd);\n\t\tif (err) {\n\t\t\terr = -errno;\n\t\t\tgoto done;\n\t\t}\n\t\tnr_threads_created++;\n\t}\n\n\twait_for_threads_err();\n\ndone:\n\tWRITE_ONCE(stop, 1);\n\tfor (i = 0; i < nr_threads_created; i++) {\n\t\tpthread_join(sk_thread_ids[i], &thread_ret);\n\t\tif (IS_ERR(thread_ret) && !err) {\n\t\t\terr = PTR_ERR(thread_ret);\n\t\t\tfprintf(stderr, \"threads#%u: err:%d\\n\", i, err);\n\t\t}\n\t}\n\tfree(sk_thread_ids);\n\n\tif (sk_fd != -1)\n\t\tclose(sk_fd);\n\tclose(map_fd);\n\n\treturn err;\n}\n\nstatic void stop_handler(int signum)\n{\n\tif (signum != SIGALRM)\n\t\tprintf(\"stopping...\\n\");\n\tWRITE_ONCE(stop, 1);\n}\n\n#define BPF_SK_STORAGE_MAP_TEST_NR_THREADS \"BPF_SK_STORAGE_MAP_TEST_NR_THREADS\"\n#define BPF_SK_STORAGE_MAP_TEST_SK_PER_THREAD \"BPF_SK_STORAGE_MAP_TEST_SK_PER_THREAD\"\n#define BPF_SK_STORAGE_MAP_TEST_RUNTIME_S \"BPF_SK_STORAGE_MAP_TEST_RUNTIME_S\"\n#define BPF_SK_STORAGE_MAP_TEST_NAME \"BPF_SK_STORAGE_MAP_TEST_NAME\"\n\nstatic void test_sk_storage_map_stress_free(void)\n{\n\tstruct rlimit rlim_old, rlim_new = {};\n\tint err;\n\n\tgetrlimit(RLIMIT_NOFILE, &rlim_old);\n\n\tsignal(SIGTERM, stop_handler);\n\tsignal(SIGINT, stop_handler);\n\tif (runtime_s > 0) {\n\t\tsignal(SIGALRM, stop_handler);\n\t\talarm(runtime_s);\n\t}\n\n\tif (rlim_old.rlim_cur < nr_sk_threads * nr_sk_per_thread) {\n\t\trlim_new.rlim_cur = nr_sk_threads * nr_sk_per_thread + 128;\n\t\trlim_new.rlim_max = rlim_new.rlim_cur + 128;\n\t\terr = setrlimit(RLIMIT_NOFILE, &rlim_new);\n\t\tCHECK(err, \"setrlimit(RLIMIT_NOFILE)\", \"rlim_new:%lu errno:%d\",\n\t\t      rlim_new.rlim_cur, errno);\n\t}\n\n\terr = do_sk_storage_map_stress_free();\n\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\tif (runtime_s > 0) {\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\talarm(0);\n\t}\n\n\tif (rlim_new.rlim_cur)\n\t\tsetrlimit(RLIMIT_NOFILE, &rlim_old);\n\n\tCHECK(err, \"test_sk_storage_map_stress_free\", \"err:%d\\n\", err);\n}\n\nstatic void test_sk_storage_map_stress_change(void)\n{\n\tint err;\n\n\tsignal(SIGTERM, stop_handler);\n\tsignal(SIGINT, stop_handler);\n\tif (runtime_s > 0) {\n\t\tsignal(SIGALRM, stop_handler);\n\t\talarm(runtime_s);\n\t}\n\n\terr = do_sk_storage_map_stress_change();\n\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\tif (runtime_s > 0) {\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\talarm(0);\n\t}\n\n\tCHECK(err, \"test_sk_storage_map_stress_change\", \"err:%d\\n\", err);\n}\n\nstatic void test_sk_storage_map_basic(void)\n{\n\tstruct {\n\t\tint cnt;\n\t\tint lock;\n\t} value = { .cnt = 0xeB9f, .lock = 1, }, lookup_value;\n\tstruct bpf_map_create_opts bad_xattr;\n\tint btf_fd, map_fd, sk_fd, err;\n\n\tbtf_fd = load_btf();\n\tCHECK(btf_fd == -1, \"bpf_load_btf\", \"btf_fd:%d errno:%d\\n\",\n\t      btf_fd, errno);\n\tmap_opts.btf_fd = btf_fd;\n\n\tsk_fd = socket(AF_INET6, SOCK_STREAM, 0);\n\tCHECK(sk_fd == -1, \"socket()\", \"sk_fd:%d errno:%d\\n\",\n\t      sk_fd, errno);\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 0, &map_opts);\n\tCHECK(map_fd == -1, \"bpf_map_create(good_xattr)\",\n\t      \"map_fd:%d errno:%d\\n\", map_fd, errno);\n\n\t \n\tmemcpy(&lookup_value, &value, sizeof(value));\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value,\n\t\t\t\t  BPF_NOEXIST | BPF_F_LOCK);\n\tCHECK(err, \"bpf_map_update_elem(BPF_NOEXIST|BPF_F_LOCK)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(err || lookup_value.lock || lookup_value.cnt != value.cnt,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d lock:%x cnt:%x(%x)\\n\",\n\t      err, errno, lookup_value.lock, lookup_value.cnt, value.cnt);\n\n\t \n\tvalue.cnt += 1;\n\tvalue.lock = 2;\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value,\n\t\t\t\t  BPF_EXIST | BPF_F_LOCK);\n\tCHECK(err, \"bpf_map_update_elem(BPF_EXIST|BPF_F_LOCK)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(err || lookup_value.lock || lookup_value.cnt != value.cnt,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d lock:%x cnt:%x(%x)\\n\",\n\t      err, errno, lookup_value.lock, lookup_value.cnt, value.cnt);\n\n\t \n\tvalue.cnt += 1;\n\tvalue.lock = 2;\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value, BPF_EXIST);\n\tCHECK(err, \"bpf_map_update_elem(BPF_EXIST)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(err || lookup_value.lock || lookup_value.cnt != value.cnt,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d lock:%x cnt:%x(%x)\\n\",\n\t      err, errno, lookup_value.lock, lookup_value.cnt, value.cnt);\n\n\t \n\tvalue.cnt += 1;\n\tvalue.lock = 2;\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value,\n\t\t\t\t  BPF_NOEXIST | BPF_F_LOCK);\n\tCHECK(!err || errno != EEXIST,\n\t      \"bpf_map_update_elem(BPF_NOEXIST|BPF_F_LOCK)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value, BPF_NOEXIST);\n\tCHECK(!err || errno != EEXIST, \"bpf_map_update_elem(BPF_NOEXIST)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\tvalue.cnt -= 1;\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(err || lookup_value.lock || lookup_value.cnt != value.cnt,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d lock:%x cnt:%x(%x)\\n\",\n\t      err, errno, lookup_value.lock, lookup_value.cnt, value.cnt);\n\n\t \n\tvalue.cnt += 1;\n\tvalue.lock = 2;\n\terr = bpf_map_update_elem(map_fd, &sk_fd, &value, 0);\n\tCHECK(err, \"bpf_map_update_elem()\", \"err:%d errno:%d\\n\",\n\t      err, errno);\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(err || lookup_value.lock || lookup_value.cnt != value.cnt,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d lock:%x cnt:%x(%x)\\n\",\n\t      err, errno, lookup_value.lock, lookup_value.cnt, value.cnt);\n\n\t \n\terr = bpf_map_delete_elem(map_fd, &sk_fd);\n\tCHECK(err, \"bpf_map_delete_elem()\", \"err:%d errno:%d\\n\",\n\t      err, errno);\n\terr = bpf_map_lookup_elem_flags(map_fd, &sk_fd, &lookup_value,\n\t\t\t\t\tBPF_F_LOCK);\n\tCHECK(!err || errno != ENOENT,\n\t      \"bpf_map_lookup_elem_flags(BPF_F_LOCK)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_delete_elem(map_fd, &sk_fd);\n\tCHECK(!err || errno != ENOENT, \"bpf_map_delete_elem()\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\tmemcpy(&bad_xattr, &map_opts, sizeof(map_opts));\n\tbad_xattr.btf_key_type_id = 0;\n\terr = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 0, &bad_xattr);\n\tCHECK(!err || errno != EINVAL, \"bpf_map_create(bad_xattr)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\tmemcpy(&bad_xattr, &map_opts, sizeof(map_opts));\n\tbad_xattr.btf_key_type_id = 3;\n\terr = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 0, &bad_xattr);\n\tCHECK(!err || errno != EINVAL, \"bpf_map_create(bad_xattr)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\terr = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 1, &map_opts);\n\tCHECK(!err || errno != EINVAL, \"bpf_map_create(bad_xattr)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\tmemcpy(&bad_xattr, &map_opts, sizeof(map_opts));\n\tbad_xattr.map_flags = 0;\n\terr = bpf_map_create(BPF_MAP_TYPE_SK_STORAGE, \"sk_storage_map\", 4, 8, 0, &bad_xattr);\n\tCHECK(!err || errno != EINVAL, \"bap_create_map_xattr(bad_xattr)\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\tmap_opts.btf_fd = -1;\n\tclose(btf_fd);\n\tclose(map_fd);\n\tclose(sk_fd);\n}\n\nvoid test_sk_storage_map(void)\n{\n\tconst char *test_name, *env_opt;\n\tbool test_ran = false;\n\n\ttest_name = getenv(BPF_SK_STORAGE_MAP_TEST_NAME);\n\n\tenv_opt = getenv(BPF_SK_STORAGE_MAP_TEST_NR_THREADS);\n\tif (env_opt)\n\t\tnr_sk_threads = atoi(env_opt);\n\n\tenv_opt = getenv(BPF_SK_STORAGE_MAP_TEST_SK_PER_THREAD);\n\tif (env_opt)\n\t\tnr_sk_per_thread = atoi(env_opt);\n\n\tenv_opt = getenv(BPF_SK_STORAGE_MAP_TEST_RUNTIME_S);\n\tif (env_opt)\n\t\truntime_s = atoi(env_opt);\n\n\tif (!test_name || !strcmp(test_name, \"basic\")) {\n\t\ttest_sk_storage_map_basic();\n\t\ttest_ran = true;\n\t}\n\tif (!test_name || !strcmp(test_name, \"stress_free\")) {\n\t\ttest_sk_storage_map_stress_free();\n\t\ttest_ran = true;\n\t}\n\tif (!test_name || !strcmp(test_name, \"stress_change\")) {\n\t\ttest_sk_storage_map_stress_change();\n\t\ttest_ran = true;\n\t}\n\n\tif (test_ran)\n\t\tprintf(\"%s:PASS\\n\", __func__);\n\telse\n\t\tCHECK(1, \"Invalid test_name\", \"%s\\n\", test_name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}