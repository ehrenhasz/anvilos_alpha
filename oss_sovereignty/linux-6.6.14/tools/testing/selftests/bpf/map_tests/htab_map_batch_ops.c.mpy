{
  "module_name": "htab_map_batch_ops.c",
  "hash_id": "0f34924bf9c9b700e3f57028e5aa4adc41ab4c113293da1ceb6d545ecc396c37",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/htab_map_batch_ops.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <bpf_util.h>\n#include <test_maps.h>\n\nstatic void map_batch_update(int map_fd, __u32 max_entries, int *keys,\n\t\t\t     void *values, bool is_pcpu)\n{\n\ttypedef BPF_DECLARE_PERCPU(int, value);\n\tvalue *v = NULL;\n\tint i, j, err;\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tif (is_pcpu)\n\t\tv = (value *)values;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkeys[i] = i + 1;\n\t\tif (is_pcpu)\n\t\t\tfor (j = 0; j < bpf_num_possible_cpus(); j++)\n\t\t\t\tbpf_percpu(v[i], j) = i + 2 + j;\n\t\telse\n\t\t\t((int *)values)[i] = i + 2;\n\t}\n\n\terr = bpf_map_update_batch(map_fd, keys, values, &max_entries, &opts);\n\tCHECK(err, \"bpf_map_update_batch()\", \"error:%s\\n\", strerror(errno));\n}\n\nstatic void map_batch_verify(int *visited, __u32 max_entries,\n\t\t\t     int *keys, void *values, bool is_pcpu)\n{\n\ttypedef BPF_DECLARE_PERCPU(int, value);\n\tvalue *v = NULL;\n\tint i, j;\n\n\tif (is_pcpu)\n\t\tv = (value *)values;\n\n\tmemset(visited, 0, max_entries * sizeof(*visited));\n\tfor (i = 0; i < max_entries; i++) {\n\n\t\tif (is_pcpu) {\n\t\t\tfor (j = 0; j < bpf_num_possible_cpus(); j++) {\n\t\t\t\tCHECK(keys[i] + 1 + j != bpf_percpu(v[i], j),\n\t\t\t\t      \"key/value checking\",\n\t\t\t\t      \"error: i %d j %d key %d value %d\\n\",\n\t\t\t\t      i, j, keys[i], bpf_percpu(v[i],  j));\n\t\t\t}\n\t\t} else {\n\t\t\tCHECK(keys[i] + 1 != ((int *)values)[i],\n\t\t\t      \"key/value checking\",\n\t\t\t      \"error: i %d key %d value %d\\n\", i, keys[i],\n\t\t\t      ((int *)values)[i]);\n\t\t}\n\n\t\tvisited[i] = 1;\n\n\t}\n\tfor (i = 0; i < max_entries; i++) {\n\t\tCHECK(visited[i] != 1, \"visited checking\",\n\t\t      \"error: keys array at index %d missing\\n\", i);\n\t}\n}\n\nvoid __test_map_lookup_and_delete_batch(bool is_pcpu)\n{\n\t__u32 batch, count, total, total_success;\n\ttypedef BPF_DECLARE_PERCPU(int, value);\n\tint map_fd, *keys, *visited, key;\n\tconst __u32 max_entries = 10;\n\tvalue pcpu_values[max_entries];\n\tint err, step, value_size;\n\tbool nospace_err;\n\tvoid *values;\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tmap_fd = bpf_map_create(is_pcpu ? BPF_MAP_TYPE_PERCPU_HASH : BPF_MAP_TYPE_HASH,\n\t\t\t\t\"hash_map\", sizeof(int), sizeof(int), max_entries, NULL);\n\tCHECK(map_fd == -1,\n\t      \"bpf_map_create()\", \"error:%s\\n\", strerror(errno));\n\n\tvalue_size = is_pcpu ? sizeof(value) : sizeof(int);\n\tkeys = malloc(max_entries * sizeof(int));\n\tif (is_pcpu)\n\t\tvalues = pcpu_values;\n\telse\n\t\tvalues = malloc(max_entries * sizeof(int));\n\tvisited = malloc(max_entries * sizeof(int));\n\tCHECK(!keys || !values || !visited, \"malloc()\",\n\t      \"error:%s\\n\", strerror(errno));\n\n\t \n\tcount = max_entries;\n\terr = bpf_map_lookup_and_delete_batch(map_fd, NULL, &batch, keys,\n\t\t\t\t\t      values, &count, &opts);\n\tCHECK((err && errno != ENOENT), \"empty map\",\n\t      \"error: %s\\n\", strerror(errno));\n\n\t \n\tmap_batch_update(map_fd, max_entries, keys, values, is_pcpu);\n\n\t \n\tcount = 0;\n\terr = bpf_map_lookup_and_delete_batch(map_fd, NULL, &batch, keys,\n\t\t\t\t\t      values, &count, &opts);\n\tCHECK(err, \"count = 0\", \"error: %s\\n\", strerror(errno));\n\n\t \n\tmemset(keys, 0, max_entries * sizeof(*keys));\n\tmemset(values, 0, max_entries * value_size);\n\tcount = max_entries;\n\terr = bpf_map_lookup_and_delete_batch(map_fd, NULL, &batch, keys,\n\t\t\t\t\t      values, &count, &opts);\n\tCHECK((err && errno != ENOENT), \"count = max_entries\",\n\t       \"error: %s\\n\", strerror(errno));\n\tCHECK(count != max_entries, \"count = max_entries\",\n\t      \"count = %u, max_entries = %u\\n\", count, max_entries);\n\tmap_batch_verify(visited, max_entries, keys, values, is_pcpu);\n\n\t \n\terr = bpf_map_get_next_key(map_fd, NULL, &key);\n\tCHECK(!err, \"bpf_map_get_next_key()\", \"error: %s\\n\", strerror(errno));\n\n\t \n\ttotal_success = 0;\n\tfor (step = 1; step < max_entries; step++) {\n\t\tmap_batch_update(map_fd, max_entries, keys, values, is_pcpu);\n\t\tmemset(keys, 0, max_entries * sizeof(*keys));\n\t\tmemset(values, 0, max_entries * value_size);\n\t\ttotal = 0;\n\t\t \n\t\tcount = step;\n\t\tnospace_err = false;\n\t\twhile (true) {\n\t\t\terr = bpf_map_lookup_batch(map_fd,\n\t\t\t\t\t\t   total ? &batch : NULL,\n\t\t\t\t\t\t   &batch, keys + total,\n\t\t\t\t\t\t   values +\n\t\t\t\t\t\t   total * value_size,\n\t\t\t\t\t\t   &count, &opts);\n\t\t\t \n\t\t\tif (err && errno == ENOSPC) {\n\t\t\t\tnospace_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tCHECK((err && errno != ENOENT), \"lookup with steps\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tif (nospace_err == true)\n\t\t\tcontinue;\n\n\t\tCHECK(total != max_entries, \"lookup with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\t\tmap_batch_verify(visited, max_entries, keys, values, is_pcpu);\n\n\t\ttotal = 0;\n\t\tcount = step;\n\t\twhile (total < max_entries) {\n\t\t\tif (max_entries - total < step)\n\t\t\t\tcount = max_entries - total;\n\t\t\terr = bpf_map_delete_batch(map_fd,\n\t\t\t\t\t\t   keys + total,\n\t\t\t\t\t\t   &count, &opts);\n\t\t\tCHECK((err && errno != ENOENT), \"delete batch\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tCHECK(total != max_entries, \"delete with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\n\t\t \n\t\terr = bpf_map_get_next_key(map_fd, NULL, &key);\n\t\tCHECK(!err || errno != ENOENT, \"bpf_map_get_next_key()\",\n\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t \n\t\tmap_batch_update(map_fd, max_entries, keys, values, is_pcpu);\n\t\tmemset(keys, 0, max_entries * sizeof(*keys));\n\t\tmemset(values, 0, max_entries * value_size);\n\t\ttotal = 0;\n\t\tcount = step;\n\t\tnospace_err = false;\n\t\twhile (true) {\n\t\t\terr = bpf_map_lookup_and_delete_batch(map_fd,\n\t\t\t\t\t\t\ttotal ? &batch : NULL,\n\t\t\t\t\t\t\t&batch, keys + total,\n\t\t\t\t\t\t\tvalues +\n\t\t\t\t\t\t\ttotal * value_size,\n\t\t\t\t\t\t\t&count, &opts);\n\t\t\t \n\t\t\tif (err && errno == ENOSPC) {\n\t\t\t\tnospace_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tCHECK((err && errno != ENOENT), \"lookup with steps\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (nospace_err == true)\n\t\t\tcontinue;\n\n\t\tCHECK(total != max_entries, \"lookup/delete with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\n\t\tmap_batch_verify(visited, max_entries, keys, values, is_pcpu);\n\t\terr = bpf_map_get_next_key(map_fd, NULL, &key);\n\t\tCHECK(!err, \"bpf_map_get_next_key()\", \"error: %s\\n\",\n\t\t      strerror(errno));\n\n\t\ttotal_success++;\n\t}\n\n\tCHECK(total_success == 0, \"check total_success\",\n\t      \"unexpected failure\\n\");\n\tfree(keys);\n\tfree(visited);\n\tif (!is_pcpu)\n\t\tfree(values);\n\tclose(map_fd);\n}\n\nvoid htab_map_batch_ops(void)\n{\n\t__test_map_lookup_and_delete_batch(false);\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nvoid htab_percpu_map_batch_ops(void)\n{\n\t__test_map_lookup_and_delete_batch(true);\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nvoid test_htab_map_batch_ops(void)\n{\n\thtab_map_batch_ops();\n\thtab_percpu_map_batch_ops();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}