{
  "module_name": "task_storage_map.c",
  "hash_id": "cae28a66175fbff0411cb0dff8dad327d71a97136293ebd2ca68c97973b05ea9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/task_storage_map.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <string.h>\n#include <pthread.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"test_maps.h\"\n#include \"task_local_storage_helpers.h\"\n#include \"read_bpf_task_storage_busy.skel.h\"\n\nstruct lookup_ctx {\n\tbool start;\n\tbool stop;\n\tint pid_fd;\n\tint map_fd;\n\tint loop;\n};\n\nstatic void *lookup_fn(void *arg)\n{\n\tstruct lookup_ctx *ctx = arg;\n\tlong value;\n\tint i = 0;\n\n\twhile (!ctx->start)\n\t\tusleep(1);\n\n\twhile (!ctx->stop && i++ < ctx->loop)\n\t\tbpf_map_lookup_elem(ctx->map_fd, &ctx->pid_fd, &value);\n\treturn NULL;\n}\n\nstatic void abort_lookup(struct lookup_ctx *ctx, pthread_t *tids, unsigned int nr)\n{\n\tunsigned int i;\n\n\tctx->stop = true;\n\tctx->start = true;\n\tfor (i = 0; i < nr; i++)\n\t\tpthread_join(tids[i], NULL);\n}\n\nvoid test_task_storage_map_stress_lookup(void)\n{\n#define MAX_NR_THREAD 4096\n\tunsigned int i, nr = 256, loop = 8192, cpu = 0;\n\tstruct read_bpf_task_storage_busy *skel;\n\tpthread_t tids[MAX_NR_THREAD];\n\tstruct lookup_ctx ctx;\n\tcpu_set_t old, new;\n\tconst char *cfg;\n\tint err;\n\n\tcfg = getenv(\"TASK_STORAGE_MAP_NR_THREAD\");\n\tif (cfg) {\n\t\tnr = atoi(cfg);\n\t\tif (nr > MAX_NR_THREAD)\n\t\t\tnr = MAX_NR_THREAD;\n\t}\n\tcfg = getenv(\"TASK_STORAGE_MAP_NR_LOOP\");\n\tif (cfg)\n\t\tloop = atoi(cfg);\n\tcfg = getenv(\"TASK_STORAGE_MAP_PIN_CPU\");\n\tif (cfg)\n\t\tcpu = atoi(cfg);\n\n\tskel = read_bpf_task_storage_busy__open_and_load();\n\terr = libbpf_get_error(skel);\n\tCHECK(err, \"open_and_load\", \"error %d\\n\", err);\n\n\t \n\tif (!skel->kconfig->CONFIG_PREEMPT) {\n\t\tprintf(\"%s SKIP (no CONFIG_PREEMPT)\\n\", __func__);\n\t\tread_bpf_task_storage_busy__destroy(skel);\n\t\tskips++;\n\t\treturn;\n\t}\n\n\t \n\tsched_getaffinity(getpid(), sizeof(old), &old);\n\n\t \n\tCPU_ZERO(&new);\n\tCPU_SET(cpu, &new);\n\tsched_setaffinity(getpid(), sizeof(new), &new);\n\n\tctx.start = false;\n\tctx.stop = false;\n\tctx.pid_fd = sys_pidfd_open(getpid(), 0);\n\tctx.map_fd = bpf_map__fd(skel->maps.task);\n\tctx.loop = loop;\n\tfor (i = 0; i < nr; i++) {\n\t\terr = pthread_create(&tids[i], NULL, lookup_fn, &ctx);\n\t\tif (err) {\n\t\t\tabort_lookup(&ctx, tids, i);\n\t\t\tCHECK(err, \"pthread_create\", \"error %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tctx.start = true;\n\tfor (i = 0; i < nr; i++)\n\t\tpthread_join(tids[i], NULL);\n\n\tskel->bss->pid = getpid();\n\terr = read_bpf_task_storage_busy__attach(skel);\n\tCHECK(err, \"attach\", \"error %d\\n\", err);\n\n\t \n\tsyscall(SYS_gettid);\n\tskel->bss->pid = 0;\n\n\tCHECK(skel->bss->busy != 0, \"bad bpf_task_storage_busy\", \"got %d\\n\", skel->bss->busy);\nout:\n\tread_bpf_task_storage_busy__destroy(skel);\n\t \n\tsched_setaffinity(getpid(), sizeof(old), &old);\n\tprintf(\"%s:PASS\\n\", __func__);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}