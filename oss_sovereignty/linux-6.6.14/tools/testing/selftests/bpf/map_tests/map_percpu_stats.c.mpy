{
  "module_name": "map_percpu_stats.c",
  "hash_id": "db0a28d2556cb8e1a15ac899117dd27df2214f92ae94d972fabcf914c7a95f98",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/map_percpu_stats.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <unistd.h>\n#include <pthread.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <bpf_util.h>\n#include <test_maps.h>\n\n#include \"map_percpu_stats.skel.h\"\n\n#define MAX_ENTRIES\t\t\t16384\n#define MAX_ENTRIES_HASH_OF_MAPS\t64\n#define N_THREADS\t\t\t8\n#define MAX_MAP_KEY_SIZE\t\t4\n\nstatic void map_info(int map_fd, struct bpf_map_info *info)\n{\n\t__u32 len = sizeof(*info);\n\tint ret;\n\n\tmemset(info, 0, sizeof(*info));\n\n\tret = bpf_obj_get_info_by_fd(map_fd, info, &len);\n\tCHECK(ret < 0, \"bpf_obj_get_info_by_fd\", \"error: %s\\n\", strerror(errno));\n}\n\nstatic const char *map_type_to_s(__u32 type)\n{\n\tswitch (type) {\n\tcase BPF_MAP_TYPE_HASH:\n\t\treturn \"HASH\";\n\tcase BPF_MAP_TYPE_PERCPU_HASH:\n\t\treturn \"PERCPU_HASH\";\n\tcase BPF_MAP_TYPE_LRU_HASH:\n\t\treturn \"LRU_HASH\";\n\tcase BPF_MAP_TYPE_LRU_PERCPU_HASH:\n\t\treturn \"LRU_PERCPU_HASH\";\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\treturn \"BPF_MAP_TYPE_HASH_OF_MAPS\";\n\tdefault:\n\t\treturn \"<define-me>\";\n\t}\n}\n\nstatic __u32 map_count_elements(__u32 type, int map_fd)\n{\n\t__u32 key = -1;\n\tint n = 0;\n\n\twhile (!bpf_map_get_next_key(map_fd, &key, &key))\n\t\tn++;\n\treturn n;\n}\n\n#define BATCH\ttrue\n\nstatic void delete_and_lookup_batch(int map_fd, void *keys, __u32 count)\n{\n\tstatic __u8 values[(8 << 10) * MAX_ENTRIES];\n\tvoid *in_batch = NULL, *out_batch;\n\t__u32 save_count = count;\n\tint ret;\n\n\tret = bpf_map_lookup_and_delete_batch(map_fd,\n\t\t\t\t\t      &in_batch, &out_batch,\n\t\t\t\t\t      keys, values, &count,\n\t\t\t\t\t      NULL);\n\n\t \n\tCHECK(ret < 0 && (errno != ENOENT || !count), \"bpf_map_lookup_and_delete_batch\",\n\t\t       \"error: %s\\n\", strerror(errno));\n\n\tCHECK(count != save_count,\n\t\t\t\"bpf_map_lookup_and_delete_batch\",\n\t\t\t\"deleted not all elements: removed=%u expected=%u\\n\",\n\t\t\tcount, save_count);\n}\n\nstatic void delete_all_elements(__u32 type, int map_fd, bool batch)\n{\n\tstatic __u8 val[8 << 10];  \n\t__u32 key = -1;\n\tvoid *keys;\n\t__u32 i, n;\n\tint ret;\n\n\tkeys = calloc(MAX_MAP_KEY_SIZE, MAX_ENTRIES);\n\tCHECK(!keys, \"calloc\", \"error: %s\\n\", strerror(errno));\n\n\tfor (n = 0; !bpf_map_get_next_key(map_fd, &key, &key); n++)\n\t\tmemcpy(keys + n*MAX_MAP_KEY_SIZE, &key, MAX_MAP_KEY_SIZE);\n\n\tif (batch) {\n\t\t \n\t\tdelete_and_lookup_batch(map_fd, keys, n);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < n; i++) {\n\t\t\tvoid *keyp = keys + i*MAX_MAP_KEY_SIZE;\n\n\t\t\tif (i % 2 || type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\t\t\tret = bpf_map_delete_elem(map_fd, keyp);\n\t\t\t\tCHECK(ret < 0, \"bpf_map_delete_elem\",\n\t\t\t\t\t       \"error: key %u: %s\\n\", i, strerror(errno));\n\t\t\t} else {\n\t\t\t\tret = bpf_map_lookup_and_delete_elem(map_fd, keyp, val);\n\t\t\t\tCHECK(ret < 0, \"bpf_map_lookup_and_delete_elem\",\n\t\t\t\t\t       \"error: key %u: %s\\n\", i, strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(keys);\n}\n\nstatic bool is_lru(__u32 map_type)\n{\n\treturn map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t       map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}\n\nstruct upsert_opts {\n\t__u32 map_type;\n\tint map_fd;\n\t__u32 n;\n};\n\nstatic int create_small_hash(void)\n{\n\tint map_fd;\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_HASH, \"small\", 4, 4, 4, NULL);\n\tCHECK(map_fd < 0, \"bpf_map_create()\", \"error:%s (name=%s)\\n\",\n\t\t\tstrerror(errno), \"small\");\n\n\treturn map_fd;\n}\n\nstatic void *patch_map_thread(void *arg)\n{\n\tstruct upsert_opts *opts = arg;\n\tint val;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < opts->n; i++) {\n\t\tif (opts->map_type == BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\t\tval = create_small_hash();\n\t\telse\n\t\t\tval = rand();\n\t\tret = bpf_map_update_elem(opts->map_fd, &i, &val, 0);\n\t\tCHECK(ret < 0, \"bpf_map_update_elem\", \"key=%d error: %s\\n\", i, strerror(errno));\n\n\t\tif (opts->map_type == BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\t\tclose(val);\n\t}\n\treturn NULL;\n}\n\nstatic void upsert_elements(struct upsert_opts *opts)\n{\n\tpthread_t threads[N_THREADS];\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++) {\n\t\tret = pthread_create(&i[threads], NULL, patch_map_thread, opts);\n\t\tCHECK(ret != 0, \"pthread_create\", \"error: %s\\n\", strerror(ret));\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++) {\n\t\tret = pthread_join(i[threads], NULL);\n\t\tCHECK(ret != 0, \"pthread_join\", \"error: %s\\n\", strerror(ret));\n\t}\n}\n\nstatic __u32 read_cur_elements(int iter_fd)\n{\n\tchar buf[64];\n\tssize_t n;\n\t__u32 ret;\n\n\tn = read(iter_fd, buf, sizeof(buf)-1);\n\tCHECK(n <= 0, \"read\", \"error: %s\\n\", strerror(errno));\n\tbuf[n] = '\\0';\n\n\terrno = 0;\n\tret = (__u32)strtol(buf, NULL, 10);\n\tCHECK(errno != 0, \"strtol\", \"error: %s\\n\", strerror(errno));\n\n\treturn ret;\n}\n\nstatic __u32 get_cur_elements(int map_id)\n{\n\tstruct map_percpu_stats *skel;\n\tstruct bpf_link *link;\n\t__u32 n_elements;\n\tint iter_fd;\n\tint ret;\n\n\tskel = map_percpu_stats__open();\n\tCHECK(skel == NULL, \"map_percpu_stats__open\", \"error: %s\", strerror(errno));\n\n\tskel->bss->target_id = map_id;\n\n\tret = map_percpu_stats__load(skel);\n\tCHECK(ret != 0, \"map_percpu_stats__load\", \"error: %s\", strerror(errno));\n\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_map, NULL);\n\tCHECK(!link, \"bpf_program__attach_iter\", \"error: %s\\n\", strerror(errno));\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tCHECK(iter_fd < 0, \"bpf_iter_create\", \"error: %s\\n\", strerror(errno));\n\n\tn_elements = read_cur_elements(iter_fd);\n\n\tclose(iter_fd);\n\tbpf_link__destroy(link);\n\tmap_percpu_stats__destroy(skel);\n\n\treturn n_elements;\n}\n\nstatic void check_expected_number_elements(__u32 n_inserted, int map_fd,\n\t\t\t\t\t   struct bpf_map_info *info)\n{\n\t__u32 n_real;\n\t__u32 n_iter;\n\n\t \n\tn_real = map_count_elements(info->type, map_fd);\n\n\t \n\tif (n_inserted == 0 || !is_lru(info->type))\n\t\tCHECK(n_inserted != n_real, \"map_count_elements\",\n\t\t      \"n_real(%u) != n_inserted(%u)\\n\", n_real, n_inserted);\n\n\t \n\tn_iter = get_cur_elements(info->id);\n\n\t \n\tCHECK(n_iter != n_real, \"get_cur_elements\",\n\t      \"n_iter=%u, expected %u (map_type=%s,map_flags=%08x)\\n\",\n\t      n_iter, n_real, map_type_to_s(info->type), info->map_flags);\n}\n\nstatic void __test(int map_fd)\n{\n\tstruct upsert_opts opts = {\n\t\t.map_fd = map_fd,\n\t};\n\tstruct bpf_map_info info;\n\n\tmap_info(map_fd, &info);\n\topts.map_type = info.type;\n\topts.n = info.max_entries;\n\n\t \n\tif (opts.map_type != BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\topts.n -= 512;\n\telse\n\t\topts.n /= 2;\n\n\t \n\tupsert_elements(&opts);\n\tcheck_expected_number_elements(opts.n, map_fd, &info);\n\tdelete_all_elements(info.type, map_fd, !BATCH);\n\tcheck_expected_number_elements(0, map_fd, &info);\n\n\t \n\tupsert_elements(&opts);\n\tcheck_expected_number_elements(opts.n, map_fd, &info);\n\tdelete_all_elements(info.type, map_fd, BATCH);\n\tcheck_expected_number_elements(0, map_fd, &info);\n\n\tclose(map_fd);\n}\n\nstatic int map_create_opts(__u32 type, const char *name,\n\t\t\t   struct bpf_map_create_opts *map_opts,\n\t\t\t   __u32 key_size, __u32 val_size)\n{\n\tint max_entries;\n\tint map_fd;\n\n\tif (type == BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\tmax_entries = MAX_ENTRIES_HASH_OF_MAPS;\n\telse\n\t\tmax_entries = MAX_ENTRIES;\n\n\tmap_fd = bpf_map_create(type, name, key_size, val_size, max_entries, map_opts);\n\tCHECK(map_fd < 0, \"bpf_map_create()\", \"error:%s (name=%s)\\n\",\n\t\t\tstrerror(errno), name);\n\n\treturn map_fd;\n}\n\nstatic int map_create(__u32 type, const char *name, struct bpf_map_create_opts *map_opts)\n{\n\treturn map_create_opts(type, name, map_opts, sizeof(int), sizeof(int));\n}\n\nstatic int create_hash(void)\n{\n\tstruct bpf_map_create_opts map_opts = {\n\t\t.sz = sizeof(map_opts),\n\t\t.map_flags = BPF_F_NO_PREALLOC,\n\t};\n\n\treturn map_create(BPF_MAP_TYPE_HASH, \"hash\", &map_opts);\n}\n\nstatic int create_percpu_hash(void)\n{\n\tstruct bpf_map_create_opts map_opts = {\n\t\t.sz = sizeof(map_opts),\n\t\t.map_flags = BPF_F_NO_PREALLOC,\n\t};\n\n\treturn map_create(BPF_MAP_TYPE_PERCPU_HASH, \"percpu_hash\", &map_opts);\n}\n\nstatic int create_hash_prealloc(void)\n{\n\treturn map_create(BPF_MAP_TYPE_HASH, \"hash\", NULL);\n}\n\nstatic int create_percpu_hash_prealloc(void)\n{\n\treturn map_create(BPF_MAP_TYPE_PERCPU_HASH, \"percpu_hash_prealloc\", NULL);\n}\n\nstatic int create_lru_hash(__u32 type, __u32 map_flags)\n{\n\tstruct bpf_map_create_opts map_opts = {\n\t\t.sz = sizeof(map_opts),\n\t\t.map_flags = map_flags,\n\t};\n\n\treturn map_create(type, \"lru_hash\", &map_opts);\n}\n\nstatic int create_hash_of_maps(void)\n{\n\tstruct bpf_map_create_opts map_opts = {\n\t\t.sz = sizeof(map_opts),\n\t\t.map_flags = BPF_F_NO_PREALLOC,\n\t\t.inner_map_fd = create_small_hash(),\n\t};\n\tint ret;\n\n\tret = map_create_opts(BPF_MAP_TYPE_HASH_OF_MAPS, \"hash_of_maps\",\n\t\t\t      &map_opts, sizeof(int), sizeof(int));\n\tclose(map_opts.inner_map_fd);\n\treturn ret;\n}\n\nstatic void map_percpu_stats_hash(void)\n{\n\t__test(create_hash());\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_percpu_hash(void)\n{\n\t__test(create_percpu_hash());\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_hash_prealloc(void)\n{\n\t__test(create_hash_prealloc());\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_percpu_hash_prealloc(void)\n{\n\t__test(create_percpu_hash_prealloc());\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_lru_hash(void)\n{\n\t__test(create_lru_hash(BPF_MAP_TYPE_LRU_HASH, 0));\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_lru_hash_no_common(void)\n{\n\t__test(create_lru_hash(BPF_MAP_TYPE_LRU_HASH, BPF_F_NO_COMMON_LRU));\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_percpu_lru_hash(void)\n{\n\t__test(create_lru_hash(BPF_MAP_TYPE_LRU_PERCPU_HASH, 0));\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_percpu_lru_hash_no_common(void)\n{\n\t__test(create_lru_hash(BPF_MAP_TYPE_LRU_PERCPU_HASH, BPF_F_NO_COMMON_LRU));\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void map_percpu_stats_hash_of_maps(void)\n{\n\t__test(create_hash_of_maps());\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nvoid test_map_percpu_stats(void)\n{\n\tmap_percpu_stats_hash();\n\tmap_percpu_stats_percpu_hash();\n\tmap_percpu_stats_hash_prealloc();\n\tmap_percpu_stats_percpu_hash_prealloc();\n\tmap_percpu_stats_lru_hash();\n\tmap_percpu_stats_lru_hash_no_common();\n\tmap_percpu_stats_percpu_lru_hash();\n\tmap_percpu_stats_percpu_lru_hash_no_common();\n\tmap_percpu_stats_hash_of_maps();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}