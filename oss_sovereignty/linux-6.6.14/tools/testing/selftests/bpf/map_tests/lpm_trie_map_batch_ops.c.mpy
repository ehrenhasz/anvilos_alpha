{
  "module_name": "lpm_trie_map_batch_ops.c",
  "hash_id": "c68874218beb54a5ff6e869892e59d4d3b2e4d1bb276266f5ccb29e6b53ab042",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/lpm_trie_map_batch_ops.c",
  "human_readable_source": "\n\n#include <arpa/inet.h>\n#include <linux/bpf.h>\n#include <netinet/in.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <test_maps.h>\n\nstruct test_lpm_key {\n\t__u32 prefix;\n\tstruct in_addr ipv4;\n};\n\nstatic void map_batch_update(int map_fd, __u32 max_entries,\n\t\t\t     struct test_lpm_key *keys, int *values)\n{\n\t__u32 i;\n\tint err;\n\tchar buff[16] = { 0 };\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkeys[i].prefix = 32;\n\t\tsnprintf(buff, 16, \"192.168.1.%d\", i + 1);\n\t\tinet_pton(AF_INET, buff, &keys[i].ipv4);\n\t\tvalues[i] = i + 1;\n\t}\n\n\terr = bpf_map_update_batch(map_fd, keys, values, &max_entries, &opts);\n\tCHECK(err, \"bpf_map_update_batch()\", \"error:%s\\n\", strerror(errno));\n}\n\nstatic void map_batch_verify(int *visited, __u32 max_entries,\n\t\t\t     struct test_lpm_key *keys, int *values)\n{\n\tchar buff[16] = { 0 };\n\tint lower_byte = 0;\n\t__u32 i;\n\n\tmemset(visited, 0, max_entries * sizeof(*visited));\n\tfor (i = 0; i < max_entries; i++) {\n\t\tinet_ntop(AF_INET, &keys[i].ipv4, buff, 32);\n\t\tCHECK(sscanf(buff, \"192.168.1.%d\", &lower_byte) == EOF,\n\t\t      \"sscanf()\", \"error: i %d\\n\", i);\n\t\tCHECK(lower_byte != values[i], \"key/value checking\",\n\t\t      \"error: i %d key %s value %d\\n\", i, buff, values[i]);\n\t\tvisited[i] = 1;\n\t}\n\tfor (i = 0; i < max_entries; i++) {\n\t\tCHECK(visited[i] != 1, \"visited checking\",\n\t\t      \"error: keys array at index %d missing\\n\", i);\n\t}\n}\n\nvoid test_lpm_trie_map_batch_ops(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, create_opts, .map_flags = BPF_F_NO_PREALLOC);\n\tstruct test_lpm_key *keys, key;\n\tint map_fd, *values, *visited;\n\t__u32 step, count, total, total_success;\n\tconst __u32 max_entries = 10;\n\t__u64 batch = 0;\n\tint err;\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, \"lpm_trie_map\",\n\t\t\t\tsizeof(struct test_lpm_key), sizeof(int),\n\t\t\t\tmax_entries, &create_opts);\n\tCHECK(map_fd == -1, \"bpf_map_create()\", \"error:%s\\n\",\n\t      strerror(errno));\n\n\tkeys = malloc(max_entries * sizeof(struct test_lpm_key));\n\tvalues = malloc(max_entries * sizeof(int));\n\tvisited = malloc(max_entries * sizeof(int));\n\tCHECK(!keys || !values || !visited, \"malloc()\", \"error:%s\\n\",\n\t      strerror(errno));\n\n\ttotal_success = 0;\n\tfor (step = 1; step < max_entries; step++) {\n\t\tmap_batch_update(map_fd, max_entries, keys, values);\n\t\tmap_batch_verify(visited, max_entries, keys, values);\n\t\tmemset(keys, 0, max_entries * sizeof(*keys));\n\t\tmemset(values, 0, max_entries * sizeof(*values));\n\t\tbatch = 0;\n\t\ttotal = 0;\n\t\t \n\t\tcount = step;\n\t\twhile (true) {\n\t\t\terr = bpf_map_lookup_batch(map_fd,\n\t\t\t\ttotal ? &batch : NULL, &batch,\n\t\t\t\tkeys + total, values + total, &count, &opts);\n\n\t\t\tCHECK((err && errno != ENOENT), \"lookup with steps\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tCHECK(total != max_entries, \"lookup with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\n\t\tmap_batch_verify(visited, max_entries, keys, values);\n\n\t\ttotal = 0;\n\t\tcount = step;\n\t\twhile (total < max_entries) {\n\t\t\tif (max_entries - total < step)\n\t\t\t\tcount = max_entries - total;\n\t\t\terr = bpf_map_delete_batch(map_fd, keys + total, &count,\n\t\t\t\t\t\t   &opts);\n\t\t\tCHECK((err && errno != ENOENT), \"delete batch\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tCHECK(total != max_entries, \"delete with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\n\t\t \n\t\terr = bpf_map_get_next_key(map_fd, NULL, &key);\n\t\tCHECK(!err || errno != ENOENT, \"bpf_map_get_next_key()\",\n\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\ttotal_success++;\n\t}\n\n\tCHECK(total_success == 0, \"check total_success\",\n\t      \"unexpected failure\\n\");\n\n\tprintf(\"%s:PASS\\n\", __func__);\n\n\tfree(keys);\n\tfree(values);\n\tfree(visited);\n\tclose(map_fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}