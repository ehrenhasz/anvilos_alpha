{
  "module_name": "array_map_batch_ops.c",
  "hash_id": "e1054a9302045e5071374a6d46909a4102e954daabc80e5608ff92ce9057ef17",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/array_map_batch_ops.c",
  "human_readable_source": "\n\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <test_maps.h>\n\nstatic int nr_cpus;\n\nstatic void map_batch_update(int map_fd, __u32 max_entries, int *keys,\n\t\t\t     __s64 *values, bool is_pcpu)\n{\n\tint i, j, err;\n\tint cpu_offset = 0;\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkeys[i] = i;\n\t\tif (is_pcpu) {\n\t\t\tcpu_offset = i * nr_cpus;\n\t\t\tfor (j = 0; j < nr_cpus; j++)\n\t\t\t\t(values + cpu_offset)[j] = i + 1 + j;\n\t\t} else {\n\t\t\tvalues[i] = i + 1;\n\t\t}\n\t}\n\n\terr = bpf_map_update_batch(map_fd, keys, values, &max_entries, &opts);\n\tCHECK(err, \"bpf_map_update_batch()\", \"error:%s\\n\", strerror(errno));\n}\n\nstatic void map_batch_verify(int *visited, __u32 max_entries, int *keys,\n\t\t\t     __s64 *values, bool is_pcpu)\n{\n\tint i, j;\n\tint cpu_offset = 0;\n\n\tmemset(visited, 0, max_entries * sizeof(*visited));\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (is_pcpu) {\n\t\t\tcpu_offset = i * nr_cpus;\n\t\t\tfor (j = 0; j < nr_cpus; j++) {\n\t\t\t\t__s64 value = (values + cpu_offset)[j];\n\t\t\t\tCHECK(keys[i] + j + 1 != value,\n\t\t\t\t      \"key/value checking\",\n\t\t\t\t      \"error: i %d j %d key %d value %lld\\n\", i,\n\t\t\t\t      j, keys[i], value);\n\t\t\t}\n\t\t} else {\n\t\t\tCHECK(keys[i] + 1 != values[i], \"key/value checking\",\n\t\t\t      \"error: i %d key %d value %lld\\n\", i, keys[i],\n\t\t\t      values[i]);\n\t\t}\n\t\tvisited[i] = 1;\n\t}\n\tfor (i = 0; i < max_entries; i++) {\n\t\tCHECK(visited[i] != 1, \"visited checking\",\n\t\t      \"error: keys array at index %d missing\\n\", i);\n\t}\n}\n\nstatic void __test_map_lookup_and_update_batch(bool is_pcpu)\n{\n\tint map_fd, *keys, *visited;\n\t__u32 count, total, total_success;\n\tconst __u32 max_entries = 10;\n\t__u64 batch = 0;\n\tint err, step, value_size;\n\tvoid *values;\n\tDECLARE_LIBBPF_OPTS(bpf_map_batch_opts, opts,\n\t\t.elem_flags = 0,\n\t\t.flags = 0,\n\t);\n\n\tmap_fd = bpf_map_create(is_pcpu ? BPF_MAP_TYPE_PERCPU_ARRAY : BPF_MAP_TYPE_ARRAY,\n\t\t\t\t\"array_map\", sizeof(int), sizeof(__s64), max_entries, NULL);\n\tCHECK(map_fd == -1,\n\t      \"bpf_map_create()\", \"error:%s\\n\", strerror(errno));\n\n\tvalue_size = sizeof(__s64);\n\tif (is_pcpu)\n\t\tvalue_size *= nr_cpus;\n\n\tkeys = calloc(max_entries, sizeof(*keys));\n\tvalues = calloc(max_entries, value_size);\n\tvisited = calloc(max_entries, sizeof(*visited));\n\tCHECK(!keys || !values || !visited, \"malloc()\", \"error:%s\\n\",\n\t      strerror(errno));\n\n\t \n\ttotal_success = 0;\n\tfor (step = 1; step < max_entries; step++) {\n\t\tmap_batch_update(map_fd, max_entries, keys, values, is_pcpu);\n\t\tmap_batch_verify(visited, max_entries, keys, values, is_pcpu);\n\t\tmemset(keys, 0, max_entries * sizeof(*keys));\n\t\tmemset(values, 0, max_entries * value_size);\n\t\tbatch = 0;\n\t\ttotal = 0;\n\t\t \n\t\tcount = step;\n\t\twhile (true) {\n\t\t\terr = bpf_map_lookup_batch(map_fd,\n\t\t\t\t\t\t   total ? &batch : NULL,\n\t\t\t\t\t\t   &batch, keys + total,\n\t\t\t\t\t\t   values + total * value_size,\n\t\t\t\t\t\t   &count, &opts);\n\n\t\t\tCHECK((err && errno != ENOENT), \"lookup with steps\",\n\t\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t\ttotal += count;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tCHECK(total != max_entries, \"lookup with steps\",\n\t\t      \"total = %u, max_entries = %u\\n\", total, max_entries);\n\n\t\tmap_batch_verify(visited, max_entries, keys, values, is_pcpu);\n\n\t\ttotal_success++;\n\t}\n\n\tCHECK(total_success == 0, \"check total_success\",\n\t      \"unexpected failure\\n\");\n\n\tfree(keys);\n\tfree(values);\n\tfree(visited);\n\tclose(map_fd);\n}\n\nstatic void array_map_batch_ops(void)\n{\n\t__test_map_lookup_and_update_batch(false);\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nstatic void array_percpu_map_batch_ops(void)\n{\n\t__test_map_lookup_and_update_batch(true);\n\tprintf(\"test_%s:PASS\\n\", __func__);\n}\n\nvoid test_array_map_batch_ops(void)\n{\n\tnr_cpus = libbpf_num_possible_cpus();\n\n\tCHECK(nr_cpus < 0, \"nr_cpus checking\",\n\t      \"error: get possible cpus failed\");\n\n\tarray_map_batch_ops();\n\tarray_percpu_map_batch_ops();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}