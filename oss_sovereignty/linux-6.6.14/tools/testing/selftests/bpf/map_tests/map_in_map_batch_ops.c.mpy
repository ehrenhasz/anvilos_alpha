{
  "module_name": "map_in_map_batch_ops.c",
  "hash_id": "2a4c3cb00b5dd6cd25f5d3f457f1f3f9957366c341ed3a03e11337e0bcae4db4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/map_tests/map_in_map_batch_ops.c",
  "human_readable_source": "\n\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include <test_maps.h>\n\n#define OUTER_MAP_ENTRIES 10\n\nstatic __u32 get_map_id_from_fd(int map_fd)\n{\n\tstruct bpf_map_info map_info = {};\n\tuint32_t info_len = sizeof(map_info);\n\tint ret;\n\n\tret = bpf_map_get_info_by_fd(map_fd, &map_info, &info_len);\n\tCHECK(ret < 0, \"Finding map info failed\", \"error:%s\\n\",\n\t      strerror(errno));\n\n\treturn map_info.id;\n}\n\n \nstatic void create_inner_maps(enum bpf_map_type map_type,\n\t\t\t      __u32 *inner_map_fds)\n{\n\tint map_fd, map_index, ret;\n\t__u32 map_key = 0, map_id;\n\tchar map_name[15];\n\n\tfor (map_index = 0; map_index < OUTER_MAP_ENTRIES; map_index++) {\n\t\tmemset(map_name, 0, sizeof(map_name));\n\t\tsprintf(map_name, \"inner_map_fd_%d\", map_index);\n\t\tmap_fd = bpf_map_create(map_type, map_name, sizeof(__u32),\n\t\t\t\t\tsizeof(__u32), 1, NULL);\n\t\tCHECK(map_fd < 0,\n\t\t      \"inner bpf_map_create() failed\",\n\t\t      \"map_type=(%d) map_name(%s), error:%s\\n\",\n\t\t      map_type, map_name, strerror(errno));\n\n\t\t \n\t\tinner_map_fds[map_index] = map_fd;\n\n\t\t \n\t\tmap_id = get_map_id_from_fd(map_fd);\n\t\tret = bpf_map_update_elem(map_fd, &map_key, &map_id, 0);\n\t\tCHECK(ret != 0,\n\t\t      \"bpf_map_update_elem failed\",\n\t\t      \"map_type=(%d) map_name(%s), error:%s\\n\",\n\t\t      map_type, map_name, strerror(errno));\n\t}\n}\n\nstatic int create_outer_map(enum bpf_map_type map_type, __u32 inner_map_fd)\n{\n\tint outer_map_fd;\n\tLIBBPF_OPTS(bpf_map_create_opts, attr);\n\n\tattr.inner_map_fd = inner_map_fd;\n\touter_map_fd = bpf_map_create(map_type, \"outer_map\", sizeof(__u32),\n\t\t\t\t      sizeof(__u32), OUTER_MAP_ENTRIES,\n\t\t\t\t      &attr);\n\tCHECK(outer_map_fd < 0,\n\t      \"outer bpf_map_create()\",\n\t      \"map_type=(%d), error:%s\\n\",\n\t      map_type, strerror(errno));\n\n\treturn outer_map_fd;\n}\n\nstatic void validate_fetch_results(int outer_map_fd,\n\t\t\t\t   __u32 *fetched_keys, __u32 *fetched_values,\n\t\t\t\t   __u32 max_entries_fetched)\n{\n\t__u32 inner_map_key, inner_map_value;\n\tint inner_map_fd, entry, err;\n\t__u32 outer_map_value;\n\n\tfor (entry = 0; entry < max_entries_fetched; ++entry) {\n\t\touter_map_value = fetched_values[entry];\n\t\tinner_map_fd = bpf_map_get_fd_by_id(outer_map_value);\n\t\tCHECK(inner_map_fd < 0,\n\t\t      \"Failed to get inner map fd\",\n\t\t      \"from id(%d), error=%s\\n\",\n\t\t      outer_map_value, strerror(errno));\n\t\terr = bpf_map_get_next_key(inner_map_fd, NULL, &inner_map_key);\n\t\tCHECK(err != 0,\n\t\t      \"Failed to get inner map key\",\n\t\t      \"error=%s\\n\", strerror(errno));\n\n\t\terr = bpf_map_lookup_elem(inner_map_fd, &inner_map_key,\n\t\t\t\t\t  &inner_map_value);\n\n\t\tclose(inner_map_fd);\n\n\t\tCHECK(err != 0,\n\t\t      \"Failed to get inner map value\",\n\t\t      \"for key(%d), error=%s\\n\",\n\t\t      inner_map_key, strerror(errno));\n\n\t\t \n\t\tCHECK(outer_map_value != inner_map_value,\n\t\t      \"Failed to validate inner map value\",\n\t\t      \"fetched(%d) and lookedup(%d)!\\n\",\n\t\t      outer_map_value, inner_map_value);\n\t}\n}\n\nstatic void fetch_and_validate(int outer_map_fd,\n\t\t\t       struct bpf_map_batch_opts *opts,\n\t\t\t       __u32 batch_size, bool delete_entries)\n{\n\t__u32 *fetched_keys, *fetched_values, total_fetched = 0;\n\t__u32 batch_key = 0, fetch_count, step_size;\n\tint err, max_entries = OUTER_MAP_ENTRIES;\n\t__u32 value_size = sizeof(__u32);\n\n\t \n\tfetched_keys = calloc(max_entries, value_size);\n\tfetched_values = calloc(max_entries, value_size);\n\tCHECK((!fetched_keys || !fetched_values),\n\t      \"Memory allocation failed for fetched_keys or fetched_values\",\n\t      \"error=%s\\n\", strerror(errno));\n\n\tfor (step_size = batch_size;\n\t     step_size <= max_entries;\n\t     step_size += batch_size) {\n\t\tfetch_count = step_size;\n\t\terr = delete_entries\n\t\t      ? bpf_map_lookup_and_delete_batch(outer_map_fd,\n\t\t\t\t      total_fetched ? &batch_key : NULL,\n\t\t\t\t      &batch_key,\n\t\t\t\t      fetched_keys + total_fetched,\n\t\t\t\t      fetched_values + total_fetched,\n\t\t\t\t      &fetch_count, opts)\n\t\t      : bpf_map_lookup_batch(outer_map_fd,\n\t\t\t\t      total_fetched ? &batch_key : NULL,\n\t\t\t\t      &batch_key,\n\t\t\t\t      fetched_keys + total_fetched,\n\t\t\t\t      fetched_values + total_fetched,\n\t\t\t\t      &fetch_count, opts);\n\n\t\tif (err && errno == ENOSPC) {\n\t\t\t \n\t\t\ttotal_fetched = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tCHECK((err < 0 && (errno != ENOENT)),\n\t\t      \"lookup with steps failed\",\n\t\t      \"error: %s\\n\", strerror(errno));\n\n\t\t \n\t\ttotal_fetched += fetch_count;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tCHECK((total_fetched != max_entries),\n\t      \"Unable to fetch expected entries !\",\n\t      \"total_fetched(%d) and max_entries(%d) error: (%d):%s\\n\",\n\t      total_fetched, max_entries, errno, strerror(errno));\n\n\t \n\tvalidate_fetch_results(outer_map_fd, fetched_keys,\n\t\t\t       fetched_values, total_fetched);\n\tprintf(\"batch_op(%s) is successful with batch_size(%d)\\n\",\n\t       delete_entries ? \"LOOKUP_AND_DELETE\" : \"LOOKUP\", batch_size);\n\n\tfree(fetched_keys);\n\tfree(fetched_values);\n}\n\nstatic void _map_in_map_batch_ops(enum bpf_map_type outer_map_type,\n\t\t\t\t  enum bpf_map_type inner_map_type)\n{\n\t__u32 *outer_map_keys, *inner_map_fds;\n\t__u32 max_entries = OUTER_MAP_ENTRIES;\n\tLIBBPF_OPTS(bpf_map_batch_opts, opts);\n\t__u32 value_size = sizeof(__u32);\n\tint batch_size[2] = {5, 10};\n\t__u32 map_index, op_index;\n\tint outer_map_fd, ret;\n\n\touter_map_keys = calloc(max_entries, value_size);\n\tinner_map_fds = calloc(max_entries, value_size);\n\tCHECK((!outer_map_keys || !inner_map_fds),\n\t      \"Memory allocation failed for outer_map_keys or inner_map_fds\",\n\t      \"error=%s\\n\", strerror(errno));\n\n\tcreate_inner_maps(inner_map_type, inner_map_fds);\n\n\touter_map_fd = create_outer_map(outer_map_type, *inner_map_fds);\n\t \n\tfor (map_index = 0; map_index < max_entries; map_index++)\n\t\touter_map_keys[map_index] =\n\t\t\t((outer_map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\t\t ? 9 : 1000) - map_index;\n\n\t \n\tret = bpf_map_update_batch(outer_map_fd, outer_map_keys,\n\t\t\t\t   inner_map_fds, &max_entries, &opts);\n\tCHECK(ret != 0,\n\t      \"Failed to update the outer map batch ops\",\n\t      \"error=%s\\n\", strerror(errno));\n\n\t \n\tfor (op_index = 0; op_index < 2; ++op_index)\n\t\tfetch_and_validate(outer_map_fd, &opts,\n\t\t\t\t   batch_size[op_index], false);\n\n\t \n\tif (outer_map_type == BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\tfetch_and_validate(outer_map_fd, &opts,\n\t\t\t\t   max_entries, true  );\n\n\t \n\tfor (map_index = 0; map_index < max_entries; map_index++)\n\t\tclose(inner_map_fds[map_index]);\n\tclose(outer_map_fd);\n\n\tfree(inner_map_fds);\n\tfree(outer_map_keys);\n}\n\nvoid test_map_in_map_batch_ops_array(void)\n{\n\t_map_in_map_batch_ops(BPF_MAP_TYPE_ARRAY_OF_MAPS, BPF_MAP_TYPE_ARRAY);\n\tprintf(\"%s:PASS with inner ARRAY map\\n\", __func__);\n\t_map_in_map_batch_ops(BPF_MAP_TYPE_ARRAY_OF_MAPS, BPF_MAP_TYPE_HASH);\n\tprintf(\"%s:PASS with inner HASH map\\n\", __func__);\n}\n\nvoid test_map_in_map_batch_ops_hash(void)\n{\n\t_map_in_map_batch_ops(BPF_MAP_TYPE_HASH_OF_MAPS, BPF_MAP_TYPE_ARRAY);\n\tprintf(\"%s:PASS with inner ARRAY map\\n\", __func__);\n\t_map_in_map_batch_ops(BPF_MAP_TYPE_HASH_OF_MAPS, BPF_MAP_TYPE_HASH);\n\tprintf(\"%s:PASS with inner HASH map\\n\", __func__);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}