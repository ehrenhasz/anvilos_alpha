{
  "module_name": "test_tcp_hdr_options.h",
  "hash_id": "9902696a846dbcbb46bbdbf0c4fdb616a77d8fa5005bd711790b2d7b7428e737",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_tcp_hdr_options.h",
  "human_readable_source": " \n \n\n#ifndef _TEST_TCP_HDR_OPTIONS_H\n#define _TEST_TCP_HDR_OPTIONS_H\n\nstruct bpf_test_option {\n\t__u8 flags;\n\t__u8 max_delack_ms;\n\t__u8 rand;\n} __attribute__((packed));\n\nenum {\n\tOPTION_RESEND,\n\tOPTION_MAX_DELACK_MS,\n\tOPTION_RAND,\n\t__NR_OPTION_FLAGS,\n};\n\n#define OPTION_F_RESEND\t\t(1 << OPTION_RESEND)\n#define OPTION_F_MAX_DELACK_MS\t(1 << OPTION_MAX_DELACK_MS)\n#define OPTION_F_RAND\t\t(1 << OPTION_RAND)\n#define OPTION_MASK\t\t((1 << __NR_OPTION_FLAGS) - 1)\n\n#define TEST_OPTION_FLAGS(flags, option) (1 & ((flags) >> (option)))\n#define SET_OPTION_FLAGS(flags, option)\t((flags) |= (1 << (option)))\n\n \nstruct hdr_stg {\n\tbool active;\n\tbool resend_syn;  \n\tbool syncookie;   \n\tbool fastopen;\t \n};\n\nstruct linum_err {\n\tunsigned int linum;\n\tint err;\n};\n\n#define TCPHDR_FIN 0x01\n#define TCPHDR_SYN 0x02\n#define TCPHDR_RST 0x04\n#define TCPHDR_PSH 0x08\n#define TCPHDR_ACK 0x10\n#define TCPHDR_URG 0x20\n#define TCPHDR_ECE 0x40\n#define TCPHDR_CWR 0x80\n#define TCPHDR_SYNACK (TCPHDR_SYN | TCPHDR_ACK)\n\n#define TCPOPT_EOL\t\t0\n#define TCPOPT_NOP\t\t1\n#define TCPOPT_MSS\t\t2\n#define TCPOPT_WINDOW\t\t3\n#define TCPOPT_EXP\t\t254\n\n#define TCP_BPF_EXPOPT_BASE_LEN 4\n#define MAX_TCP_HDR_LEN\t\t60\n#define MAX_TCP_OPTION_SPACE\t40\n\n#ifdef BPF_PROG_TEST_TCP_HDR_OPTIONS\n\n#define CG_OK\t1\n#define CG_ERR\t0\n\n#ifndef SOL_TCP\n#define SOL_TCP 6\n#endif\n\nstruct tcp_exprm_opt {\n\t__u8 kind;\n\t__u8 len;\n\t__u16 magic;\n\tunion {\n\t\t__u8 data[4];\n\t\t__u32 data32;\n\t};\n} __attribute__((packed));\n\nstruct tcp_opt {\n\t__u8 kind;\n\t__u8 len;\n\tunion {\n\t\t__u8 data[4];\n\t\t__u32 data32;\n\t};\n} __attribute__((packed));\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, struct linum_err);\n} lport_linum_map SEC(\".maps\");\n\nstatic inline unsigned int tcp_hdrlen(const struct tcphdr *th)\n{\n\treturn th->doff << 2;\n}\n\nstatic inline __u8 skops_tcp_flags(const struct bpf_sock_ops *skops)\n{\n\treturn skops->skb_tcp_flags;\n}\n\nstatic inline void clear_hdr_cb_flags(struct bpf_sock_ops *skops)\n{\n\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t  skops->bpf_sock_ops_cb_flags &\n\t\t\t\t  ~(BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG |\n\t\t\t\t    BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG));\n}\n\nstatic inline void set_hdr_cb_flags(struct bpf_sock_ops *skops, __u32 extra)\n{\n\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t  skops->bpf_sock_ops_cb_flags |\n\t\t\t\t  BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG |\n\t\t\t\t  BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG |\n\t\t\t\t  extra);\n}\nstatic inline void\nclear_parse_all_hdr_cb_flags(struct bpf_sock_ops *skops)\n{\n\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t  skops->bpf_sock_ops_cb_flags &\n\t\t\t\t  ~BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG);\n}\n\nstatic inline void\nset_parse_all_hdr_cb_flags(struct bpf_sock_ops *skops)\n{\n\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t  skops->bpf_sock_ops_cb_flags |\n\t\t\t\t  BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG);\n}\n\n#define RET_CG_ERR(__err) ({\t\t\t\\\n\tstruct linum_err __linum_err;\t\t\\\n\tint __lport;\t\t\t\t\\\n\t\t\t\t\t\t\\\n\t__linum_err.linum = __LINE__;\t\t\\\n\t__linum_err.err = __err;\t\t\\\n\t__lport = skops->local_port;\t\t\\\n\tbpf_map_update_elem(&lport_linum_map, &__lport, &__linum_err, BPF_NOEXIST); \\\n\tclear_hdr_cb_flags(skops);\t\t\t\t\t\\\n\tclear_parse_all_hdr_cb_flags(skops);\t\t\t\t\\\n\treturn CG_ERR;\t\t\t\t\t\t\t\\\n})\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}