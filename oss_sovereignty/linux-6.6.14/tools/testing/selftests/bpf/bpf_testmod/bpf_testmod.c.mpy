{
  "module_name": "bpf_testmod.c",
  "hash_id": "83175b26f6f834529a69b065239c329d27dcf0734651cdbab80046ae8d587632",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/bpf_testmod/bpf_testmod.c",
  "human_readable_source": "\n \n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/percpu-defs.h>\n#include <linux/sysfs.h>\n#include <linux/tracepoint.h>\n#include \"bpf_testmod.h\"\n#include \"bpf_testmod_kfunc.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"bpf_testmod-events.h\"\n\ntypedef int (*func_proto_typedef)(long);\ntypedef int (*func_proto_typedef_nested1)(func_proto_typedef);\ntypedef int (*func_proto_typedef_nested2)(func_proto_typedef_nested1);\n\nDEFINE_PER_CPU(int, bpf_testmod_ksym_percpu) = 123;\nlong bpf_testmod_test_struct_arg_result;\n\nstruct bpf_testmod_struct_arg_1 {\n\tint a;\n};\nstruct bpf_testmod_struct_arg_2 {\n\tlong a;\n\tlong b;\n};\n\nstruct bpf_testmod_struct_arg_3 {\n\tint a;\n\tint b[];\n};\n\nstruct bpf_testmod_struct_arg_4 {\n\tu64 a;\n\tint b;\n};\n\n__diag_push();\n__diag_ignore_all(\"-Wmissing-prototypes\",\n\t\t  \"Global functions as their definitions will be in bpf_testmod.ko BTF\");\n\nnoinline int\nbpf_testmod_test_struct_arg_1(struct bpf_testmod_struct_arg_2 a, int b, int c) {\n\tbpf_testmod_test_struct_arg_result = a.a + a.b  + b + c;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_2(int a, struct bpf_testmod_struct_arg_2 b, int c) {\n\tbpf_testmod_test_struct_arg_result = a + b.a + b.b + c;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_3(int a, int b, struct bpf_testmod_struct_arg_2 c) {\n\tbpf_testmod_test_struct_arg_result = a + b + c.a + c.b;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_4(struct bpf_testmod_struct_arg_1 a, int b,\n\t\t\t      int c, int d, struct bpf_testmod_struct_arg_2 e) {\n\tbpf_testmod_test_struct_arg_result = a.a + b + c + d + e.a + e.b;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_5(void) {\n\tbpf_testmod_test_struct_arg_result = 1;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_6(struct bpf_testmod_struct_arg_3 *a) {\n\tbpf_testmod_test_struct_arg_result = a->b[0];\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_7(u64 a, void *b, short c, int d, void *e,\n\t\t\t      struct bpf_testmod_struct_arg_4 f)\n{\n\tbpf_testmod_test_struct_arg_result = a + (long)b + c + d +\n\t\t(long)e + f.a + f.b;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_struct_arg_8(u64 a, void *b, short c, int d, void *e,\n\t\t\t      struct bpf_testmod_struct_arg_4 f, int g)\n{\n\tbpf_testmod_test_struct_arg_result = a + (long)b + c + d +\n\t\t(long)e + f.a + f.b + g;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\nnoinline int\nbpf_testmod_test_arg_ptr_to_struct(struct bpf_testmod_struct_arg_1 *a) {\n\tbpf_testmod_test_struct_arg_result = a->a;\n\treturn bpf_testmod_test_struct_arg_result;\n}\n\n__bpf_kfunc void\nbpf_testmod_test_mod_kfunc(int i)\n{\n\t*(int *)this_cpu_ptr(&bpf_testmod_ksym_percpu) = i;\n}\n\n__bpf_kfunc int bpf_iter_testmod_seq_new(struct bpf_iter_testmod_seq *it, s64 value, int cnt)\n{\n\tif (cnt < 0) {\n\t\tit->cnt = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tit->value = value;\n\tit->cnt = cnt;\n\n\treturn 0;\n}\n\n__bpf_kfunc s64 *bpf_iter_testmod_seq_next(struct bpf_iter_testmod_seq* it)\n{\n\tif (it->cnt <= 0)\n\t\treturn NULL;\n\n\tit->cnt--;\n\n\treturn &it->value;\n}\n\n__bpf_kfunc void bpf_iter_testmod_seq_destroy(struct bpf_iter_testmod_seq *it)\n{\n\tit->cnt = 0;\n}\n\nstruct bpf_testmod_btf_type_tag_1 {\n\tint a;\n};\n\nstruct bpf_testmod_btf_type_tag_2 {\n\tstruct bpf_testmod_btf_type_tag_1 __user *p;\n};\n\nstruct bpf_testmod_btf_type_tag_3 {\n\tstruct bpf_testmod_btf_type_tag_1 __percpu *p;\n};\n\nnoinline int\nbpf_testmod_test_btf_type_tag_user_1(struct bpf_testmod_btf_type_tag_1 __user *arg) {\n\tBTF_TYPE_EMIT(func_proto_typedef);\n\tBTF_TYPE_EMIT(func_proto_typedef_nested1);\n\tBTF_TYPE_EMIT(func_proto_typedef_nested2);\n\treturn arg->a;\n}\n\nnoinline int\nbpf_testmod_test_btf_type_tag_user_2(struct bpf_testmod_btf_type_tag_2 *arg) {\n\treturn arg->p->a;\n}\n\nnoinline int\nbpf_testmod_test_btf_type_tag_percpu_1(struct bpf_testmod_btf_type_tag_1 __percpu *arg) {\n\treturn arg->a;\n}\n\nnoinline int\nbpf_testmod_test_btf_type_tag_percpu_2(struct bpf_testmod_btf_type_tag_3 *arg) {\n\treturn arg->p->a;\n}\n\nnoinline int bpf_testmod_loop_test(int n)\n{\n\t \n\tvolatile int sum = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < n; i++)\n\t\tsum += i;\n\treturn sum;\n}\n\n__weak noinline struct file *bpf_testmod_return_ptr(int arg)\n{\n\tstatic struct file f = {};\n\n\tswitch (arg) {\n\tcase 1: return (void *)EINVAL;\t\t \n\tcase 2: return (void *)0xcafe4a11;\t \n\tcase 3: return (void *)-EINVAL;\t\t \n\tcase 4: return (void *)(1ull << 60);\t \n\tcase 5: return (void *)~(1ull << 30);\t \n\tcase 6: return &f;\t\t\t \n\tcase 7: return (void *)((long)&f | 1);\t \n\tdefault: return NULL;\n\t}\n}\n\nnoinline int bpf_testmod_fentry_test1(int a)\n{\n\treturn a + 1;\n}\n\nnoinline int bpf_testmod_fentry_test2(int a, u64 b)\n{\n\treturn a + b;\n}\n\nnoinline int bpf_testmod_fentry_test3(char a, int b, u64 c)\n{\n\treturn a + b + c;\n}\n\nnoinline int bpf_testmod_fentry_test7(u64 a, void *b, short c, int d,\n\t\t\t\t      void *e, char f, int g)\n{\n\treturn a + (long)b + c + d + (long)e + f + g;\n}\n\nnoinline int bpf_testmod_fentry_test11(u64 a, void *b, short c, int d,\n\t\t\t\t       void *e, char f, int g,\n\t\t\t\t       unsigned int h, long i, __u64 j,\n\t\t\t\t       unsigned long k)\n{\n\treturn a + (long)b + c + d + (long)e + f + g + h + i + j + k;\n}\n\nint bpf_testmod_fentry_ok;\n\nnoinline ssize_t\nbpf_testmod_test_read(struct file *file, struct kobject *kobj,\n\t\t      struct bin_attribute *bin_attr,\n\t\t      char *buf, loff_t off, size_t len)\n{\n\tstruct bpf_testmod_test_read_ctx ctx = {\n\t\t.buf = buf,\n\t\t.off = off,\n\t\t.len = len,\n\t};\n\tstruct bpf_testmod_struct_arg_1 struct_arg1 = {10}, struct_arg1_2 = {-1};\n\tstruct bpf_testmod_struct_arg_2 struct_arg2 = {2, 3};\n\tstruct bpf_testmod_struct_arg_3 *struct_arg3;\n\tstruct bpf_testmod_struct_arg_4 struct_arg4 = {21, 22};\n\tint i = 1;\n\n\twhile (bpf_testmod_return_ptr(i))\n\t\ti++;\n\n\t(void)bpf_testmod_test_struct_arg_1(struct_arg2, 1, 4);\n\t(void)bpf_testmod_test_struct_arg_2(1, struct_arg2, 4);\n\t(void)bpf_testmod_test_struct_arg_3(1, 4, struct_arg2);\n\t(void)bpf_testmod_test_struct_arg_4(struct_arg1, 1, 2, 3, struct_arg2);\n\t(void)bpf_testmod_test_struct_arg_5();\n\t(void)bpf_testmod_test_struct_arg_7(16, (void *)17, 18, 19,\n\t\t\t\t\t    (void *)20, struct_arg4);\n\t(void)bpf_testmod_test_struct_arg_8(16, (void *)17, 18, 19,\n\t\t\t\t\t    (void *)20, struct_arg4, 23);\n\n\t(void)bpf_testmod_test_arg_ptr_to_struct(&struct_arg1_2);\n\n\tstruct_arg3 = kmalloc((sizeof(struct bpf_testmod_struct_arg_3) +\n\t\t\t\tsizeof(int)), GFP_KERNEL);\n\tif (struct_arg3 != NULL) {\n\t\tstruct_arg3->b[0] = 1;\n\t\t(void)bpf_testmod_test_struct_arg_6(struct_arg3);\n\t\tkfree(struct_arg3);\n\t}\n\n\t \n\tif (bpf_testmod_loop_test(101) > 100)\n\t\ttrace_bpf_testmod_test_read(current, &ctx);\n\n\t \n\tif (len == 64) {\n\t\tstruct bpf_testmod_test_writable_ctx writable = {\n\t\t\t.val = 1024,\n\t\t};\n\t\ttrace_bpf_testmod_test_writable_bare(&writable);\n\t\tif (writable.early_ret)\n\t\t\treturn snprintf(buf, len, \"%d\\n\", writable.val);\n\t}\n\n\tif (bpf_testmod_fentry_test1(1) != 2 ||\n\t    bpf_testmod_fentry_test2(2, 3) != 5 ||\n\t    bpf_testmod_fentry_test3(4, 5, 6) != 15 ||\n\t    bpf_testmod_fentry_test7(16, (void *)17, 18, 19, (void *)20,\n\t\t\t21, 22) != 133 ||\n\t    bpf_testmod_fentry_test11(16, (void *)17, 18, 19, (void *)20,\n\t\t\t21, 22, 23, 24, 25, 26) != 231)\n\t\tgoto out;\n\n\tbpf_testmod_fentry_ok = 1;\nout:\n\treturn -EIO;  \n}\nEXPORT_SYMBOL(bpf_testmod_test_read);\nALLOW_ERROR_INJECTION(bpf_testmod_test_read, ERRNO);\n\nnoinline ssize_t\nbpf_testmod_test_write(struct file *file, struct kobject *kobj,\n\t\t      struct bin_attribute *bin_attr,\n\t\t      char *buf, loff_t off, size_t len)\n{\n\tstruct bpf_testmod_test_write_ctx ctx = {\n\t\t.buf = buf,\n\t\t.off = off,\n\t\t.len = len,\n\t};\n\n\ttrace_bpf_testmod_test_write_bare(current, &ctx);\n\n\treturn -EIO;  \n}\nEXPORT_SYMBOL(bpf_testmod_test_write);\nALLOW_ERROR_INJECTION(bpf_testmod_test_write, ERRNO);\n\nnoinline int bpf_fentry_shadow_test(int a)\n{\n\treturn a + 2;\n}\nEXPORT_SYMBOL_GPL(bpf_fentry_shadow_test);\n\n__diag_pop();\n\nstatic struct bin_attribute bin_attr_bpf_testmod_file __ro_after_init = {\n\t.attr = { .name = \"bpf_testmod\", .mode = 0666, },\n\t.read = bpf_testmod_test_read,\n\t.write = bpf_testmod_test_write,\n};\n\nBTF_SET8_START(bpf_testmod_common_kfunc_ids)\nBTF_ID_FLAGS(func, bpf_iter_testmod_seq_new, KF_ITER_NEW)\nBTF_ID_FLAGS(func, bpf_iter_testmod_seq_next, KF_ITER_NEXT | KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_iter_testmod_seq_destroy, KF_ITER_DESTROY)\nBTF_SET8_END(bpf_testmod_common_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set bpf_testmod_common_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &bpf_testmod_common_kfunc_ids,\n};\n\n__bpf_kfunc u64 bpf_kfunc_call_test1(struct sock *sk, u32 a, u64 b, u32 c, u64 d)\n{\n\treturn a + b + c + d;\n}\n\n__bpf_kfunc int bpf_kfunc_call_test2(struct sock *sk, u32 a, u32 b)\n{\n\treturn a + b;\n}\n\n__bpf_kfunc struct sock *bpf_kfunc_call_test3(struct sock *sk)\n{\n\treturn sk;\n}\n\n__bpf_kfunc long noinline bpf_kfunc_call_test4(signed char a, short b, int c, long d)\n{\n\t \n\treturn (long)a + (long)b + (long)c + d;\n}\n\nstatic struct prog_test_ref_kfunc prog_test_struct = {\n\t.a = 42,\n\t.b = 108,\n\t.next = &prog_test_struct,\n\t.cnt = REFCOUNT_INIT(1),\n};\n\n__bpf_kfunc struct prog_test_ref_kfunc *\nbpf_kfunc_call_test_acquire(unsigned long *scalar_ptr)\n{\n\trefcount_inc(&prog_test_struct.cnt);\n\treturn &prog_test_struct;\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_offset(struct prog_test_ref_kfunc *p)\n{\n\tWARN_ON_ONCE(1);\n}\n\n__bpf_kfunc struct prog_test_member *\nbpf_kfunc_call_memb_acquire(void)\n{\n\tWARN_ON_ONCE(1);\n\treturn NULL;\n}\n\n__bpf_kfunc void bpf_kfunc_call_memb1_release(struct prog_test_member1 *p)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic int *__bpf_kfunc_call_test_get_mem(struct prog_test_ref_kfunc *p, const int size)\n{\n\tif (size > 2 * sizeof(int))\n\t\treturn NULL;\n\n\treturn (int *)p;\n}\n\n__bpf_kfunc int *bpf_kfunc_call_test_get_rdwr_mem(struct prog_test_ref_kfunc *p,\n\t\t\t\t\t\t  const int rdwr_buf_size)\n{\n\treturn __bpf_kfunc_call_test_get_mem(p, rdwr_buf_size);\n}\n\n__bpf_kfunc int *bpf_kfunc_call_test_get_rdonly_mem(struct prog_test_ref_kfunc *p,\n\t\t\t\t\t\t    const int rdonly_buf_size)\n{\n\treturn __bpf_kfunc_call_test_get_mem(p, rdonly_buf_size);\n}\n\n \n__bpf_kfunc int *bpf_kfunc_call_test_acq_rdonly_mem(struct prog_test_ref_kfunc *p,\n\t\t\t\t\t\t    const int rdonly_buf_size)\n{\n\treturn __bpf_kfunc_call_test_get_mem(p, rdonly_buf_size);\n}\n\n__bpf_kfunc void bpf_kfunc_call_int_mem_release(int *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_pass_ctx(struct __sk_buff *skb)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_pass1(struct prog_test_pass1 *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_pass2(struct prog_test_pass2 *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_fail1(struct prog_test_fail1 *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_fail2(struct prog_test_fail2 *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_fail3(struct prog_test_fail3 *p)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_mem_len_pass1(void *mem, int mem__sz)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_mem_len_fail1(void *mem, int len)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_mem_len_fail2(u64 *mem, int len)\n{\n}\n\n__bpf_kfunc void bpf_kfunc_call_test_ref(struct prog_test_ref_kfunc *p)\n{\n\t \n}\n\n__bpf_kfunc void bpf_kfunc_call_test_destructive(void)\n{\n}\n\n__bpf_kfunc static u32 bpf_kfunc_call_test_static_unused_arg(u32 arg, u32 unused)\n{\n\treturn arg;\n}\n\nBTF_SET8_START(bpf_testmod_check_kfunc_ids)\nBTF_ID_FLAGS(func, bpf_testmod_test_mod_kfunc)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test1)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test2)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test3)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test4)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_mem_len_pass1)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_mem_len_fail1)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_mem_len_fail2)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_acquire, KF_ACQUIRE | KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_kfunc_call_memb_acquire, KF_ACQUIRE | KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_kfunc_call_memb1_release, KF_RELEASE)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_get_rdwr_mem, KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_get_rdonly_mem, KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_acq_rdonly_mem, KF_ACQUIRE | KF_RET_NULL)\nBTF_ID_FLAGS(func, bpf_kfunc_call_int_mem_release, KF_RELEASE)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_pass_ctx)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_pass1)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_pass2)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_fail1)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_fail2)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_fail3)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_ref, KF_TRUSTED_ARGS | KF_RCU)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_destructive, KF_DESTRUCTIVE)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_static_unused_arg)\nBTF_ID_FLAGS(func, bpf_kfunc_call_test_offset)\nBTF_SET8_END(bpf_testmod_check_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set bpf_testmod_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &bpf_testmod_check_kfunc_ids,\n};\n\nextern int bpf_fentry_test1(int a);\n\nstatic int bpf_testmod_init(void)\n{\n\tint ret;\n\n\tret = register_btf_kfunc_id_set(BPF_PROG_TYPE_UNSPEC, &bpf_testmod_common_kfunc_set);\n\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SCHED_CLS, &bpf_testmod_kfunc_set);\n\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_TRACING, &bpf_testmod_kfunc_set);\n\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL, &bpf_testmod_kfunc_set);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (bpf_fentry_test1(0) < 0)\n\t\treturn -EINVAL;\n\treturn sysfs_create_bin_file(kernel_kobj, &bin_attr_bpf_testmod_file);\n}\n\nstatic void bpf_testmod_exit(void)\n{\n\treturn sysfs_remove_bin_file(kernel_kobj, &bin_attr_bpf_testmod_file);\n}\n\nmodule_init(bpf_testmod_init);\nmodule_exit(bpf_testmod_exit);\n\nMODULE_AUTHOR(\"Andrii Nakryiko\");\nMODULE_DESCRIPTION(\"BPF selftests module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}