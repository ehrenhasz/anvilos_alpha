{
  "module_name": "test_tc_tunnel.sh",
  "hash_id": "5117d3d965c377b840861add81feb7bdb6c4893242cbd1cbd1d2b15ea0cbdbf8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_tc_tunnel.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# In-place tunneling\n\nBPF_FILE=\"test_tc_tunnel.bpf.o\"\n# must match the port that the bpf program filters on\nreadonly port=8000\n\nreadonly ns_prefix=\"ns-$$-\"\nreadonly ns1=\"${ns_prefix}1\"\nreadonly ns2=\"${ns_prefix}2\"\n\nreadonly ns1_v4=192.168.1.1\nreadonly ns2_v4=192.168.1.2\nreadonly ns1_v6=fd::1\nreadonly ns2_v6=fd::2\n\n# Must match port used by bpf program\nreadonly udpport=5555\n# MPLSoverUDP\nreadonly mplsudpport=6635\nreadonly mplsproto=137\n\nreadonly infile=\"$(mktemp)\"\nreadonly outfile=\"$(mktemp)\"\n\nsetup() {\n\tip netns add \"${ns1}\"\n\tip netns add \"${ns2}\"\n\n\tip link add dev veth1 mtu 1500 netns \"${ns1}\" type veth \\\n\t      peer name veth2 mtu 1500 netns \"${ns2}\"\n\n\tip netns exec \"${ns1}\" ethtool -K veth1 tso off\n\n\tip -netns \"${ns1}\" link set veth1 up\n\tip -netns \"${ns2}\" link set veth2 up\n\n\tip -netns \"${ns1}\" -4 addr add \"${ns1_v4}/24\" dev veth1\n\tip -netns \"${ns2}\" -4 addr add \"${ns2_v4}/24\" dev veth2\n\tip -netns \"${ns1}\" -6 addr add \"${ns1_v6}/64\" dev veth1 nodad\n\tip -netns \"${ns2}\" -6 addr add \"${ns2_v6}/64\" dev veth2 nodad\n\n\t# clamp route to reserve room for tunnel headers\n\tip -netns \"${ns1}\" -4 route flush table main\n\tip -netns \"${ns1}\" -6 route flush table main\n\tip -netns \"${ns1}\" -4 route add \"${ns2_v4}\" mtu 1450 dev veth1\n\tip -netns \"${ns1}\" -6 route add \"${ns2_v6}\" mtu 1430 dev veth1\n\n\tsleep 1\n\n\tdd if=/dev/urandom of=\"${infile}\" bs=\"${datalen}\" count=1 status=none\n}\n\ncleanup() {\n\tip netns del \"${ns2}\"\n\tip netns del \"${ns1}\"\n\n\tif [[ -f \"${outfile}\" ]]; then\n\t\trm \"${outfile}\"\n\tfi\n\tif [[ -f \"${infile}\" ]]; then\n\t\trm \"${infile}\"\n\tfi\n\n\tif [[ -n $server_pid ]]; then\n\t\tkill $server_pid 2> /dev/null\n\tfi\n}\n\nserver_listen() {\n\tip netns exec \"${ns2}\" nc \"${netcat_opt}\" -l \"${port}\" > \"${outfile}\" &\n\tserver_pid=$!\n\tsleep 0.2\n}\n\nclient_connect() {\n\tip netns exec \"${ns1}\" timeout 2 nc \"${netcat_opt}\" -w 1 \"${addr2}\" \"${port}\" < \"${infile}\"\n\techo $?\n}\n\nverify_data() {\n\twait \"${server_pid}\"\n\tserver_pid=\n\t# sha1sum returns two fields [sha1] [filepath]\n\t# convert to bash array and access first elem\n\tinsum=($(sha1sum ${infile}))\n\toutsum=($(sha1sum ${outfile}))\n\tif [[ \"${insum[0]}\" != \"${outsum[0]}\" ]]; then\n\t\techo \"data mismatch\"\n\t\texit 1\n\tfi\n}\n\nset -e\n\n# no arguments: automated test, run all\nif [[ \"$#\" -eq \"0\" ]]; then\n\techo \"ipip\"\n\t$0 ipv4 ipip none 100\n\n\techo \"ipip6\"\n\t$0 ipv4 ipip6 none 100\n\n\techo \"ip6ip6\"\n\t$0 ipv6 ip6tnl none 100\n\n\techo \"sit\"\n\t$0 ipv6 sit none 100\n\n\techo \"ip4 vxlan\"\n\t$0 ipv4 vxlan eth 2000\n\n\techo \"ip6 vxlan\"\n\t$0 ipv6 ip6vxlan eth 2000\n\n\tfor mac in none mpls eth ; do\n\t\techo \"ip gre $mac\"\n\t\t$0 ipv4 gre $mac 100\n\n\t\techo \"ip6 gre $mac\"\n\t\t$0 ipv6 ip6gre $mac 100\n\n\t\techo \"ip gre $mac gso\"\n\t\t$0 ipv4 gre $mac 2000\n\n\t\techo \"ip6 gre $mac gso\"\n\t\t$0 ipv6 ip6gre $mac 2000\n\n\t\techo \"ip udp $mac\"\n\t\t$0 ipv4 udp $mac 100\n\n\t\techo \"ip6 udp $mac\"\n\t\t$0 ipv6 ip6udp $mac 100\n\n\t\techo \"ip udp $mac gso\"\n\t\t$0 ipv4 udp $mac 2000\n\n\t\techo \"ip6 udp $mac gso\"\n\t\t$0 ipv6 ip6udp $mac 2000\n\tdone\n\n\techo \"OK. All tests passed\"\n\texit 0\nfi\n\nif [[ \"$#\" -ne \"4\" ]]; then\n\techo \"Usage: $0\"\n\techo \"   or: $0 <ipv4|ipv6> <tuntype> <none|mpls|eth> <data_len>\"\n\texit 1\nfi\n\ncase \"$1\" in\n\"ipv4\")\n\treadonly addr1=\"${ns1_v4}\"\n\treadonly addr2=\"${ns2_v4}\"\n\treadonly ipproto=4\n\treadonly netcat_opt=-${ipproto}\n\treadonly foumod=fou\n\treadonly foutype=ipip\n\treadonly fouproto=4\n\treadonly fouproto_mpls=${mplsproto}\n\treadonly gretaptype=gretap\n\t;;\n\"ipv6\")\n\treadonly addr1=\"${ns1_v6}\"\n\treadonly addr2=\"${ns2_v6}\"\n\treadonly ipproto=6\n\treadonly netcat_opt=-${ipproto}\n\treadonly foumod=fou6\n\treadonly foutype=ip6tnl\n\treadonly fouproto=\"41 -6\"\n\treadonly fouproto_mpls=\"${mplsproto} -6\"\n\treadonly gretaptype=ip6gretap\n\t;;\n*)\n\techo \"unknown arg: $1\"\n\texit 1\n\t;;\nesac\n\nreadonly tuntype=$2\nreadonly mac=$3\nreadonly datalen=$4\n\necho \"encap ${addr1} to ${addr2}, type ${tuntype}, mac ${mac} len ${datalen}\"\n\ntrap cleanup EXIT\n\nsetup\n\n# basic communication works\necho \"test basic connectivity\"\nserver_listen\nclient_connect\nverify_data\n\n# clientside, insert bpf program to encap all TCP to port ${port}\n# client can no longer connect\nip netns exec \"${ns1}\" tc qdisc add dev veth1 clsact\nip netns exec \"${ns1}\" tc filter add dev veth1 egress \\\n\tbpf direct-action object-file ${BPF_FILE} \\\n\tsection \"encap_${tuntype}_${mac}\"\necho \"test bpf encap without decap (expect failure)\"\nserver_listen\n! client_connect\n\nif [[ \"$tuntype\" =~ \"udp\" ]]; then\n\t# Set up fou tunnel.\n\tttype=\"${foutype}\"\n\ttargs=\"encap fou encap-sport auto encap-dport $udpport\"\n\t# fou may be a module; allow this to fail.\n\tmodprobe \"${foumod}\" ||true\n\tif [[ \"$mac\" == \"mpls\" ]]; then\n\t\tdport=${mplsudpport}\n\t\tdproto=${fouproto_mpls}\n\t\ttmode=\"mode any ttl 255\"\n\telse\n\t\tdport=${udpport}\n\t\tdproto=${fouproto}\n\tfi\n\tip netns exec \"${ns2}\" ip fou add port $dport ipproto ${dproto}\n\ttargs=\"encap fou encap-sport auto encap-dport $dport\"\nelif [[ \"$tuntype\" =~ \"gre\" && \"$mac\" == \"eth\" ]]; then\n\tttype=$gretaptype\nelif [[ \"$tuntype\" =~ \"vxlan\" && \"$mac\" == \"eth\" ]]; then\n\tttype=\"vxlan\"\n\ttargs=\"id 1 dstport 8472 udp6zerocsumrx\"\nelif [[ \"$tuntype\" == \"ipip6\" ]]; then\n\tttype=\"ip6tnl\"\n\ttargs=\"\"\nelse\n\tttype=$tuntype\n\ttargs=\"\"\nfi\n\n# tunnel address family differs from inner for SIT\nif [[ \"${tuntype}\" == \"sit\" ]]; then\n\tlink_addr1=\"${ns1_v4}\"\n\tlink_addr2=\"${ns2_v4}\"\nelif [[ \"${tuntype}\" == \"ipip6\" ]]; then\n\tlink_addr1=\"${ns1_v6}\"\n\tlink_addr2=\"${ns2_v6}\"\nelse\n\tlink_addr1=\"${addr1}\"\n\tlink_addr2=\"${addr2}\"\nfi\n\n# serverside, insert decap module\n# server is still running\n# client can connect again\nip netns exec \"${ns2}\" ip link add name testtun0 type \"${ttype}\" \\\n\t${tmode} remote \"${link_addr1}\" local \"${link_addr2}\" $targs\n\nexpect_tun_fail=0\n\nif [[ \"$tuntype\" == \"ip6udp\" && \"$mac\" == \"mpls\" ]]; then\n\t# No support for MPLS IPv6 fou tunnel; expect failure.\n\texpect_tun_fail=1\nelif [[ \"$tuntype\" =~ \"udp\" && \"$mac\" == \"eth\" ]]; then\n\t# No support for TEB fou tunnel; expect failure.\n\texpect_tun_fail=1\nelif [[ \"$tuntype\" =~ (gre|vxlan) && \"$mac\" == \"eth\" ]]; then\n\t# Share ethernet address between tunnel/veth2 so L2 decap works.\n\tethaddr=$(ip netns exec \"${ns2}\" ip link show veth2 | \\\n\t\t  awk '/ether/ { print $2 }')\n\tip netns exec \"${ns2}\" ip link set testtun0 address $ethaddr\nelif [[ \"$mac\" == \"mpls\" ]]; then\n\tmodprobe mpls_iptunnel ||true\n\tmodprobe mpls_gso ||true\n\tip netns exec \"${ns2}\" sysctl -qw net.mpls.platform_labels=65536\n\tip netns exec \"${ns2}\" ip -f mpls route add 1000 dev lo\n\tip netns exec \"${ns2}\" ip link set lo up\n\tip netns exec \"${ns2}\" sysctl -qw net.mpls.conf.testtun0.input=1\n\tip netns exec \"${ns2}\" sysctl -qw net.ipv4.conf.lo.rp_filter=0\nfi\n\n# Because packets are decapped by the tunnel they arrive on testtun0 from\n# the IP stack perspective.  Ensure reverse path filtering is disabled\n# otherwise we drop the TCP SYN as arriving on testtun0 instead of the\n# expected veth2 (veth2 is where 192.168.1.2 is configured).\nip netns exec \"${ns2}\" sysctl -qw net.ipv4.conf.all.rp_filter=0\n# rp needs to be disabled for both all and testtun0 as the rp value is\n# selected as the max of the \"all\" and device-specific values.\nip netns exec \"${ns2}\" sysctl -qw net.ipv4.conf.testtun0.rp_filter=0\nip netns exec \"${ns2}\" ip link set dev testtun0 up\nif [[ \"$expect_tun_fail\" == 1 ]]; then\n\t# This tunnel mode is not supported, so we expect failure.\n\techo \"test bpf encap with tunnel device decap (expect failure)\"\n\t! client_connect\nelse\n\techo \"test bpf encap with tunnel device decap\"\n\tclient_connect\n\tverify_data\n\tserver_listen\nfi\n\n# serverside, use BPF for decap\nip netns exec \"${ns2}\" ip link del dev testtun0\nip netns exec \"${ns2}\" tc qdisc add dev veth2 clsact\nip netns exec \"${ns2}\" tc filter add dev veth2 ingress \\\n\tbpf direct-action object-file ${BPF_FILE} section decap\necho \"test bpf encap with bpf decap\"\nclient_connect\nverify_data\n\necho OK\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}