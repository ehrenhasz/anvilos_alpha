{
  "module_name": "btf_helpers.c",
  "hash_id": "f39d882b312ad67db68ab9a6200eb5009b7fd26cfba7c87ddf23bf629505e135",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/btf_helpers.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <errno.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#include \"test_progs.h\"\n\nstatic const char * const btf_kind_str_mapping[] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n\t[BTF_KIND_ENUM64]\t= \"ENUM64\",\n};\n\nstatic const char *btf_kind_str(__u16 kind)\n{\n\tif (kind > BTF_KIND_ENUM64)\n\t\treturn \"UNKNOWN\";\n\treturn btf_kind_str_mapping[kind];\n}\n\nstatic const char *btf_int_enc_str(__u8 encoding)\n{\n\tswitch (encoding) {\n\tcase 0:\n\t\treturn \"(none)\";\n\tcase BTF_INT_SIGNED:\n\t\treturn \"SIGNED\";\n\tcase BTF_INT_CHAR:\n\t\treturn \"CHAR\";\n\tcase BTF_INT_BOOL:\n\t\treturn \"BOOL\";\n\tdefault:\n\t\treturn \"UNKN\";\n\t}\n}\n\nstatic const char *btf_var_linkage_str(__u32 linkage)\n{\n\tswitch (linkage) {\n\tcase BTF_VAR_STATIC:\n\t\treturn \"static\";\n\tcase BTF_VAR_GLOBAL_ALLOCATED:\n\t\treturn \"global-alloc\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic const char *btf_func_linkage_str(const struct btf_type *t)\n{\n\tswitch (btf_vlen(t)) {\n\tcase BTF_FUNC_STATIC:\n\t\treturn \"static\";\n\tcase BTF_FUNC_GLOBAL:\n\t\treturn \"global\";\n\tcase BTF_FUNC_EXTERN:\n\t\treturn \"extern\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic const char *btf_str(const struct btf *btf, __u32 off)\n{\n\tif (!off)\n\t\treturn \"(anon)\";\n\treturn btf__str_by_offset(btf, off) ?: \"(invalid)\";\n}\n\nint fprintf_btf_type_raw(FILE *out, const struct btf *btf, __u32 id)\n{\n\tconst struct btf_type *t;\n\tint kind, i;\n\t__u32 vlen;\n\n\tt = btf__type_by_id(btf, id);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\tvlen = btf_vlen(t);\n\tkind = btf_kind(t);\n\n\tfprintf(out, \"[%u] %s '%s'\", id, btf_kind_str(kind), btf_str(btf, t->name_off));\n\n\tswitch (kind) {\n\tcase BTF_KIND_INT:\n\t\tfprintf(out, \" size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\tt->size, btf_int_offset(t), btf_int_bits(t),\n\t\t\tbtf_int_enc_str(btf_int_encoding(t)));\n\t\tbreak;\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_TYPE_TAG:\n\t\tfprintf(out, \" type_id=%u\", t->type);\n\t\tbreak;\n\tcase BTF_KIND_ARRAY: {\n\t\tconst struct btf_array *arr = btf_array(t);\n\n\t\tfprintf(out, \" type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\tarr->type, arr->index_type, arr->nelems);\n\t\tbreak;\n\t}\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION: {\n\t\tconst struct btf_member *m = btf_members(t);\n\n\t\tfprintf(out, \" size=%u vlen=%u\", t->size, vlen);\n\t\tfor (i = 0; i < vlen; i++, m++) {\n\t\t\t__u32 bit_off, bit_sz;\n\n\t\t\tbit_off = btf_member_bit_offset(t, i);\n\t\t\tbit_sz = btf_member_bitfield_size(t, i);\n\t\t\tfprintf(out, \"\\n\\t'%s' type_id=%u bits_offset=%u\",\n\t\t\t\tbtf_str(btf, m->name_off), m->type, bit_off);\n\t\t\tif (bit_sz)\n\t\t\t\tfprintf(out, \" bitfield_size=%u\", bit_sz);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM: {\n\t\tconst struct btf_enum *v = btf_enum(t);\n\t\tconst char *fmt_str;\n\n\t\tfmt_str = btf_kflag(t) ? \"\\n\\t'%s' val=%d\" : \"\\n\\t'%s' val=%u\";\n\t\tfprintf(out, \" encoding=%s size=%u vlen=%u\",\n\t\t\tbtf_kflag(t) ? \"SIGNED\" : \"UNSIGNED\", t->size, vlen);\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tfprintf(out, fmt_str,\n\t\t\t\tbtf_str(btf, v->name_off), v->val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_ENUM64: {\n\t\tconst struct btf_enum64 *v = btf_enum64(t);\n\t\tconst char *fmt_str;\n\n\t\tfmt_str = btf_kflag(t) ? \"\\n\\t'%s' val=%lld\" : \"\\n\\t'%s' val=%llu\";\n\n\t\tfprintf(out, \" encoding=%s size=%u vlen=%u\",\n\t\t\tbtf_kflag(t) ? \"SIGNED\" : \"UNSIGNED\", t->size, vlen);\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tfprintf(out, fmt_str,\n\t\t\t\tbtf_str(btf, v->name_off),\n\t\t\t\t((__u64)v->val_hi32 << 32) | v->val_lo32);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FWD:\n\t\tfprintf(out, \" fwd_kind=%s\", btf_kflag(t) ? \"union\" : \"struct\");\n\t\tbreak;\n\tcase BTF_KIND_FUNC:\n\t\tfprintf(out, \" type_id=%u linkage=%s\", t->type, btf_func_linkage_str(t));\n\t\tbreak;\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tconst struct btf_param *p = btf_params(t);\n\n\t\tfprintf(out, \" ret_type_id=%u vlen=%u\", t->type, vlen);\n\t\tfor (i = 0; i < vlen; i++, p++) {\n\t\t\tfprintf(out, \"\\n\\t'%s' type_id=%u\",\n\t\t\t\tbtf_str(btf, p->name_off), p->type);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_VAR:\n\t\tfprintf(out, \" type_id=%u, linkage=%s\",\n\t\t\tt->type, btf_var_linkage_str(btf_var(t)->linkage));\n\t\tbreak;\n\tcase BTF_KIND_DATASEC: {\n\t\tconst struct btf_var_secinfo *v = btf_var_secinfos(t);\n\n\t\tfprintf(out, \" size=%u vlen=%u\", t->size, vlen);\n\t\tfor (i = 0; i < vlen; i++, v++) {\n\t\t\tfprintf(out, \"\\n\\ttype_id=%u offset=%u size=%u\",\n\t\t\t\tv->type, v->offset, v->size);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BTF_KIND_FLOAT:\n\t\tfprintf(out, \" size=%u\", t->size);\n\t\tbreak;\n\tcase BTF_KIND_DECL_TAG:\n\t\tfprintf(out, \" type_id=%u component_idx=%d\",\n\t\t\tt->type, btf_decl_tag(t)->component_idx);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nconst char *btf_type_raw_dump(const struct btf *btf, int type_id)\n{\n\tstatic char buf[16 * 1024];\n\tFILE *buf_file;\n\n\tbuf_file = fmemopen(buf, sizeof(buf) - 1, \"w\");\n\tif (!buf_file) {\n\t\tfprintf(stderr, \"Failed to open memstream: %d\\n\", errno);\n\t\treturn NULL;\n\t}\n\n\tfprintf_btf_type_raw(buf_file, btf, type_id);\n\tfflush(buf_file);\n\tfclose(buf_file);\n\n\treturn buf;\n}\n\nint btf_validate_raw(struct btf *btf, int nr_types, const char *exp_types[])\n{\n\tint i;\n\tbool ok = true;\n\n\tASSERT_EQ(btf__type_cnt(btf) - 1, nr_types, \"btf_nr_types\");\n\n\tfor (i = 1; i <= nr_types; i++) {\n\t\tif (!ASSERT_STREQ(btf_type_raw_dump(btf, i), exp_types[i - 1], \"raw_dump\"))\n\t\t\tok = false;\n\t}\n\n\treturn ok;\n}\n\nstatic void btf_dump_printf(void *ctx, const char *fmt, va_list args)\n{\n\tvfprintf(ctx, fmt, args);\n}\n\n \nconst char *btf_type_c_dump(const struct btf *btf)\n{\n\tstatic char buf[16 * 1024];\n\tFILE *buf_file;\n\tstruct btf_dump *d = NULL;\n\tint err, i;\n\n\tbuf_file = fmemopen(buf, sizeof(buf) - 1, \"w\");\n\tif (!buf_file) {\n\t\tfprintf(stderr, \"Failed to open memstream: %d\\n\", errno);\n\t\treturn NULL;\n\t}\n\n\td = btf_dump__new(btf, btf_dump_printf, buf_file, NULL);\n\tif (libbpf_get_error(d)) {\n\t\tfprintf(stderr, \"Failed to create btf_dump instance: %ld\\n\", libbpf_get_error(d));\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 1; i < btf__type_cnt(btf); i++) {\n\t\terr = btf_dump__dump_type(d, i);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"Failed to dump type [%d]: %d\\n\", i, err);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tbtf_dump__free(d);\n\tfflush(buf_file);\n\tfclose(buf_file);\n\treturn buf;\nerr_out:\n\tbtf_dump__free(d);\n\tfclose(buf_file);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}