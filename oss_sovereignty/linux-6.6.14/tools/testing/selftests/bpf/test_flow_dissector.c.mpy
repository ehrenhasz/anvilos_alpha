{
  "module_name": "test_flow_dissector.c",
  "hash_id": "9f8165de624598770255b595029c45bc294d4a44f0538678d4ad3a6b994adbe5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_flow_dissector.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stddef.h>\n#include <arpa/inet.h>\n#include <asm/byteorder.h>\n#include <error.h>\n#include <errno.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n#include <linux/ipv6.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define CFG_PORT_INNER\t8000\n\n \n\nstruct grehdr {\n\tuint16_t unused;\n\tuint16_t protocol;\n} __attribute__((packed));\n\nstruct guehdr {\n\tunion {\n\t\tstruct {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t\t\t__u8\thlen:5,\n\t\t\t\tcontrol:1,\n\t\t\t\tversion:2;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n\t\t\t__u8\tversion:2,\n\t\t\t\tcontrol:1,\n\t\t\t\thlen:5;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n\t\t\t__u8\tproto_ctype;\n\t\t\t__be16\tflags;\n\t\t};\n\t\t__be32\tword;\n\t};\n};\n\nstatic uint8_t\tcfg_dsfield_inner;\nstatic uint8_t\tcfg_dsfield_outer;\nstatic uint8_t\tcfg_encap_proto;\nstatic bool\tcfg_expect_failure = false;\nstatic int\tcfg_l3_extra = AF_UNSPEC;\t \nstatic int\tcfg_l3_inner = AF_UNSPEC;\nstatic int\tcfg_l3_outer = AF_UNSPEC;\nstatic int\tcfg_num_pkt = 10;\nstatic int\tcfg_num_secs = 0;\nstatic char\tcfg_payload_char = 'a';\nstatic int\tcfg_payload_len = 100;\nstatic int\tcfg_port_gue = 6080;\nstatic bool\tcfg_only_rx;\nstatic bool\tcfg_only_tx;\nstatic int\tcfg_src_port = 9;\n\nstatic char\tbuf[ETH_DATA_LEN];\n\n#define INIT_ADDR4(name, addr4, port)\t\t\t\t\\\n\tstatic struct sockaddr_in name = {\t\t\t\\\n\t\t.sin_family = AF_INET,\t\t\t\t\\\n\t\t.sin_port = __constant_htons(port),\t\t\\\n\t\t.sin_addr.s_addr = __constant_htonl(addr4),\t\\\n\t};\n\n#define INIT_ADDR6(name, addr6, port)\t\t\t\t\\\n\tstatic struct sockaddr_in6 name = {\t\t\t\\\n\t\t.sin6_family = AF_INET6,\t\t\t\\\n\t\t.sin6_port = __constant_htons(port),\t\t\\\n\t\t.sin6_addr = addr6,\t\t\t\t\\\n\t};\n\nINIT_ADDR4(in_daddr4, INADDR_LOOPBACK, CFG_PORT_INNER)\nINIT_ADDR4(in_saddr4, INADDR_LOOPBACK + 2, 0)\nINIT_ADDR4(out_daddr4, INADDR_LOOPBACK, 0)\nINIT_ADDR4(out_saddr4, INADDR_LOOPBACK + 1, 0)\nINIT_ADDR4(extra_daddr4, INADDR_LOOPBACK, 0)\nINIT_ADDR4(extra_saddr4, INADDR_LOOPBACK + 1, 0)\n\nINIT_ADDR6(in_daddr6, IN6ADDR_LOOPBACK_INIT, CFG_PORT_INNER)\nINIT_ADDR6(in_saddr6, IN6ADDR_LOOPBACK_INIT, 0)\nINIT_ADDR6(out_daddr6, IN6ADDR_LOOPBACK_INIT, 0)\nINIT_ADDR6(out_saddr6, IN6ADDR_LOOPBACK_INIT, 0)\nINIT_ADDR6(extra_daddr6, IN6ADDR_LOOPBACK_INIT, 0)\nINIT_ADDR6(extra_saddr6, IN6ADDR_LOOPBACK_INIT, 0)\n\nstatic unsigned long util_gettime(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000) + (tv.tv_usec / 1000);\n}\n\nstatic void util_printaddr(const char *msg, struct sockaddr *addr)\n{\n\tunsigned long off = 0;\n\tchar nbuf[INET6_ADDRSTRLEN];\n\n\tswitch (addr->sa_family) {\n\tcase PF_INET:\n\t\toff = __builtin_offsetof(struct sockaddr_in, sin_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\toff = __builtin_offsetof(struct sockaddr_in6, sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"printaddr: unsupported family %u\\n\",\n\t\t      addr->sa_family);\n\t}\n\n\tif (!inet_ntop(addr->sa_family, ((void *) addr) + off, nbuf,\n\t\t       sizeof(nbuf)))\n\t\terror(1, errno, \"inet_ntop\");\n\n\tfprintf(stderr, \"%s: %s\\n\", msg, nbuf);\n}\n\nstatic unsigned long add_csum_hword(const uint16_t *start, int num_u16)\n{\n\tunsigned long sum = 0;\n\tint i;\n\n\tfor (i = 0; i < num_u16; i++)\n\t\tsum += start[i];\n\n\treturn sum;\n}\n\nstatic uint16_t build_ip_csum(const uint16_t *start, int num_u16,\n\t\t\t      unsigned long sum)\n{\n\tsum += add_csum_hword(start, num_u16);\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xffff) + (sum >> 16);\n\n\treturn ~sum;\n}\n\nstatic void build_ipv4_header(void *header, uint8_t proto,\n\t\t\t      uint32_t src, uint32_t dst,\n\t\t\t      int payload_len, uint8_t tos)\n{\n\tstruct iphdr *iph = header;\n\n\tiph->ihl = 5;\n\tiph->version = 4;\n\tiph->tos = tos;\n\tiph->ttl = 8;\n\tiph->tot_len = htons(sizeof(*iph) + payload_len);\n\tiph->id = htons(1337);\n\tiph->protocol = proto;\n\tiph->saddr = src;\n\tiph->daddr = dst;\n\tiph->check = build_ip_csum((void *) iph, iph->ihl << 1, 0);\n}\n\nstatic void ipv6_set_dsfield(struct ipv6hdr *ip6h, uint8_t dsfield)\n{\n\tuint16_t val, *ptr = (uint16_t *)ip6h;\n\n\tval = ntohs(*ptr);\n\tval &= 0xF00F;\n\tval |= ((uint16_t) dsfield) << 4;\n\t*ptr = htons(val);\n}\n\nstatic void build_ipv6_header(void *header, uint8_t proto,\n\t\t\t      struct sockaddr_in6 *src,\n\t\t\t      struct sockaddr_in6 *dst,\n\t\t\t      int payload_len, uint8_t dsfield)\n{\n\tstruct ipv6hdr *ip6h = header;\n\n\tip6h->version = 6;\n\tip6h->payload_len = htons(payload_len);\n\tip6h->nexthdr = proto;\n\tip6h->hop_limit = 8;\n\tipv6_set_dsfield(ip6h, dsfield);\n\n\tmemcpy(&ip6h->saddr, &src->sin6_addr, sizeof(ip6h->saddr));\n\tmemcpy(&ip6h->daddr, &dst->sin6_addr, sizeof(ip6h->daddr));\n}\n\nstatic uint16_t build_udp_v4_csum(const struct iphdr *iph,\n\t\t\t\t  const struct udphdr *udph,\n\t\t\t\t  int num_words)\n{\n\tunsigned long pseudo_sum;\n\tint num_u16 = sizeof(iph->saddr);\t \n\n\tpseudo_sum = add_csum_hword((void *) &iph->saddr, num_u16);\n\tpseudo_sum += htons(IPPROTO_UDP);\n\tpseudo_sum += udph->len;\n\treturn build_ip_csum((void *) udph, num_words, pseudo_sum);\n}\n\nstatic uint16_t build_udp_v6_csum(const struct ipv6hdr *ip6h,\n\t\t\t\t  const struct udphdr *udph,\n\t\t\t\t  int num_words)\n{\n\tunsigned long pseudo_sum;\n\tint num_u16 = sizeof(ip6h->saddr);\t \n\n\tpseudo_sum = add_csum_hword((void *) &ip6h->saddr, num_u16);\n\tpseudo_sum += htons(ip6h->nexthdr);\n\tpseudo_sum += ip6h->payload_len;\n\treturn build_ip_csum((void *) udph, num_words, pseudo_sum);\n}\n\nstatic void build_udp_header(void *header, int payload_len,\n\t\t\t     uint16_t dport, int family)\n{\n\tstruct udphdr *udph = header;\n\tint len = sizeof(*udph) + payload_len;\n\n\tudph->source = htons(cfg_src_port);\n\tudph->dest = htons(dport);\n\tudph->len = htons(len);\n\tudph->check = 0;\n\tif (family == AF_INET)\n\t\tudph->check = build_udp_v4_csum(header - sizeof(struct iphdr),\n\t\t\t\t\t\tudph, len >> 1);\n\telse\n\t\tudph->check = build_udp_v6_csum(header - sizeof(struct ipv6hdr),\n\t\t\t\t\t\tudph, len >> 1);\n}\n\nstatic void build_gue_header(void *header, uint8_t proto)\n{\n\tstruct guehdr *gueh = header;\n\n\tgueh->proto_ctype = proto;\n}\n\nstatic void build_gre_header(void *header, uint16_t proto)\n{\n\tstruct grehdr *greh = header;\n\n\tgreh->protocol = htons(proto);\n}\n\nstatic int l3_length(int family)\n{\n\tif (family == AF_INET)\n\t\treturn sizeof(struct iphdr);\n\telse\n\t\treturn sizeof(struct ipv6hdr);\n}\n\nstatic int build_packet(void)\n{\n\tint ol3_len = 0, ol4_len = 0, il3_len = 0, il4_len = 0;\n\tint el3_len = 0;\n\n\tif (cfg_l3_extra)\n\t\tel3_len = l3_length(cfg_l3_extra);\n\n\t \n\tif (cfg_encap_proto) {\n\t\tol3_len = l3_length(cfg_l3_outer);\n\n\t\tif (cfg_encap_proto == IPPROTO_GRE)\n\t\t\tol4_len = sizeof(struct grehdr);\n\t\telse if (cfg_encap_proto == IPPROTO_UDP)\n\t\t\tol4_len = sizeof(struct udphdr) + sizeof(struct guehdr);\n\t}\n\n\til3_len = l3_length(cfg_l3_inner);\n\til4_len = sizeof(struct udphdr);\n\n\tif (el3_len + ol3_len + ol4_len + il3_len + il4_len + cfg_payload_len >=\n\t    sizeof(buf))\n\t\terror(1, 0, \"packet too large\\n\");\n\n\t \n\tmemset(buf + el3_len + ol3_len + ol4_len + il3_len + il4_len,\n\t       cfg_payload_char, cfg_payload_len);\n\n\t \n\tbuf[el3_len + ol3_len + ol4_len + il3_len + il4_len + cfg_payload_len] = 0;\n\n\tswitch (cfg_l3_inner) {\n\tcase PF_INET:\n\t\tbuild_ipv4_header(buf + el3_len + ol3_len + ol4_len,\n\t\t\t\t  IPPROTO_UDP,\n\t\t\t\t  in_saddr4.sin_addr.s_addr,\n\t\t\t\t  in_daddr4.sin_addr.s_addr,\n\t\t\t\t  il4_len + cfg_payload_len,\n\t\t\t\t  cfg_dsfield_inner);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tbuild_ipv6_header(buf + el3_len + ol3_len + ol4_len,\n\t\t\t\t  IPPROTO_UDP,\n\t\t\t\t  &in_saddr6, &in_daddr6,\n\t\t\t\t  il4_len + cfg_payload_len,\n\t\t\t\t  cfg_dsfield_inner);\n\t\tbreak;\n\t}\n\n\tbuild_udp_header(buf + el3_len + ol3_len + ol4_len + il3_len,\n\t\t\t cfg_payload_len, CFG_PORT_INNER, cfg_l3_inner);\n\n\tif (!cfg_encap_proto)\n\t\treturn il3_len + il4_len + cfg_payload_len;\n\n\tswitch (cfg_l3_outer) {\n\tcase PF_INET:\n\t\tbuild_ipv4_header(buf + el3_len, cfg_encap_proto,\n\t\t\t\t  out_saddr4.sin_addr.s_addr,\n\t\t\t\t  out_daddr4.sin_addr.s_addr,\n\t\t\t\t  ol4_len + il3_len + il4_len + cfg_payload_len,\n\t\t\t\t  cfg_dsfield_outer);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tbuild_ipv6_header(buf + el3_len, cfg_encap_proto,\n\t\t\t\t  &out_saddr6, &out_daddr6,\n\t\t\t\t  ol4_len + il3_len + il4_len + cfg_payload_len,\n\t\t\t\t  cfg_dsfield_outer);\n\t\tbreak;\n\t}\n\n\tswitch (cfg_encap_proto) {\n\tcase IPPROTO_UDP:\n\t\tbuild_gue_header(buf + el3_len + ol3_len + ol4_len -\n\t\t\t\t sizeof(struct guehdr),\n\t\t\t\t cfg_l3_inner == PF_INET ? IPPROTO_IPIP\n\t\t\t\t\t\t\t : IPPROTO_IPV6);\n\t\tbuild_udp_header(buf + el3_len + ol3_len,\n\t\t\t\t sizeof(struct guehdr) + il3_len + il4_len +\n\t\t\t\t cfg_payload_len,\n\t\t\t\t cfg_port_gue, cfg_l3_outer);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tbuild_gre_header(buf + el3_len + ol3_len,\n\t\t\t\t cfg_l3_inner == PF_INET ? ETH_P_IP\n\t\t\t\t\t\t\t : ETH_P_IPV6);\n\t\tbreak;\n\t}\n\n\tswitch (cfg_l3_extra) {\n\tcase PF_INET:\n\t\tbuild_ipv4_header(buf,\n\t\t\t\t  cfg_l3_outer == PF_INET ? IPPROTO_IPIP\n\t\t\t\t\t\t\t  : IPPROTO_IPV6,\n\t\t\t\t  extra_saddr4.sin_addr.s_addr,\n\t\t\t\t  extra_daddr4.sin_addr.s_addr,\n\t\t\t\t  ol3_len + ol4_len + il3_len + il4_len +\n\t\t\t\t  cfg_payload_len, 0);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tbuild_ipv6_header(buf,\n\t\t\t\t  cfg_l3_outer == PF_INET ? IPPROTO_IPIP\n\t\t\t\t\t\t\t  : IPPROTO_IPV6,\n\t\t\t\t  &extra_saddr6, &extra_daddr6,\n\t\t\t\t  ol3_len + ol4_len + il3_len + il4_len +\n\t\t\t\t  cfg_payload_len, 0);\n\t\tbreak;\n\t}\n\n\treturn el3_len + ol3_len + ol4_len + il3_len + il4_len +\n\t       cfg_payload_len;\n}\n\n \nstatic int setup_tx(void)\n{\n\tint family, fd, ret;\n\n\tif (cfg_l3_extra)\n\t\tfamily = cfg_l3_extra;\n\telse if (cfg_l3_outer)\n\t\tfamily = cfg_l3_outer;\n\telse\n\t\tfamily = cfg_l3_inner;\n\n\tfd = socket(family, SOCK_RAW, IPPROTO_RAW);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket tx\");\n\n\tif (cfg_l3_extra) {\n\t\tif (cfg_l3_extra == PF_INET)\n\t\t\tret = connect(fd, (void *) &extra_daddr4,\n\t\t\t\t      sizeof(extra_daddr4));\n\t\telse\n\t\t\tret = connect(fd, (void *) &extra_daddr6,\n\t\t\t\t      sizeof(extra_daddr6));\n\t\tif (ret)\n\t\t\terror(1, errno, \"connect tx\");\n\t} else if (cfg_l3_outer) {\n\t\t \n\t\tif (cfg_l3_outer == PF_INET)\n\t\t\tret = connect(fd, (void *) &out_daddr4,\n\t\t\t\t      sizeof(out_daddr4));\n\t\telse\n\t\t\tret = connect(fd, (void *) &out_daddr6,\n\t\t\t\t      sizeof(out_daddr6));\n\t\tif (ret)\n\t\t\terror(1, errno, \"connect tx\");\n\t} else {\n\t\t \n\t\tif (cfg_l3_inner == PF_INET)\n\t\t\tret = connect(fd, (void *) &in_daddr4,\n\t\t\t\t      sizeof(in_daddr4));\n\t\telse\n\t\t\tret = connect(fd, (void *) &in_daddr6,\n\t\t\t\t      sizeof(in_daddr6));\n\t\tif (ret)\n\t\t\terror(1, errno, \"connect tx\");\n\t}\n\n\treturn fd;\n}\n\n \nstatic int setup_rx(void)\n{\n\tint fd, ret;\n\n\tfd = socket(cfg_l3_inner, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket rx\");\n\n\tif (cfg_l3_inner == PF_INET)\n\t\tret = bind(fd, (void *) &in_daddr4, sizeof(in_daddr4));\n\telse\n\t\tret = bind(fd, (void *) &in_daddr6, sizeof(in_daddr6));\n\tif (ret)\n\t\terror(1, errno, \"bind rx\");\n\n\treturn fd;\n}\n\nstatic int do_tx(int fd, const char *pkt, int len)\n{\n\tint ret;\n\n\tret = write(fd, pkt, len);\n\tif (ret == -1)\n\t\terror(1, errno, \"send\");\n\tif (ret != len)\n\t\terror(1, errno, \"send: len (%d < %d)\\n\", ret, len);\n\n\treturn 1;\n}\n\nstatic int do_poll(int fd, short events, int timeout)\n{\n\tstruct pollfd pfd;\n\tint ret;\n\n\tpfd.fd = fd;\n\tpfd.events = events;\n\n\tret = poll(&pfd, 1, timeout);\n\tif (ret == -1)\n\t\terror(1, errno, \"poll\");\n\tif (ret && !(pfd.revents & POLLIN))\n\t\terror(1, errno, \"poll: unexpected event 0x%x\\n\", pfd.revents);\n\n\treturn ret;\n}\n\nstatic int do_rx(int fd)\n{\n\tchar rbuf;\n\tint ret, num = 0;\n\n\twhile (1) {\n\t\tret = recv(fd, &rbuf, 1, MSG_DONTWAIT);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"recv\");\n\t\tif (rbuf != cfg_payload_char)\n\t\t\terror(1, 0, \"recv: payload mismatch\");\n\t\tnum++;\n\t}\n\n\treturn num;\n}\n\nstatic int do_main(void)\n{\n\tunsigned long tstop, treport, tcur;\n\tint fdt = -1, fdr = -1, len, tx = 0, rx = 0;\n\n\tif (!cfg_only_tx)\n\t\tfdr = setup_rx();\n\tif (!cfg_only_rx)\n\t\tfdt = setup_tx();\n\n\tlen = build_packet();\n\n\ttcur = util_gettime();\n\ttreport = tcur + 1000;\n\ttstop = tcur + (cfg_num_secs * 1000);\n\n\twhile (1) {\n\t\tif (!cfg_only_rx)\n\t\t\ttx += do_tx(fdt, buf, len);\n\n\t\tif (!cfg_only_tx)\n\t\t\trx += do_rx(fdr);\n\n\t\tif (cfg_num_secs) {\n\t\t\ttcur = util_gettime();\n\t\t\tif (tcur >= tstop)\n\t\t\t\tbreak;\n\t\t\tif (tcur >= treport) {\n\t\t\t\tfprintf(stderr, \"pkts: tx=%u rx=%u\\n\", tx, rx);\n\t\t\t\ttx = 0;\n\t\t\t\trx = 0;\n\t\t\t\ttreport = tcur + 1000;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tx == cfg_num_pkt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (rx < tx) {\n\t\ttstop = util_gettime() + 100;\n\t\twhile (rx < tx) {\n\t\t\ttcur = util_gettime();\n\t\t\tif (tcur >= tstop)\n\t\t\t\tbreak;\n\n\t\t\tdo_poll(fdr, POLLIN, tstop - tcur);\n\t\t\trx += do_rx(fdr);\n\t\t}\n\t}\n\n\tfprintf(stderr, \"pkts: tx=%u rx=%u\\n\", tx, rx);\n\n\tif (fdr != -1 && close(fdr))\n\t\terror(1, errno, \"close rx\");\n\tif (fdt != -1 && close(fdt))\n\t\terror(1, errno, \"close tx\");\n\n\t \n\tif (cfg_expect_failure)\n\t\treturn rx != 0;\n\telse\n\t\treturn rx != tx;\n}\n\n\nstatic void __attribute__((noreturn)) usage(const char *filepath)\n{\n\tfprintf(stderr, \"Usage: %s [-e gre|gue|bare|none] [-i 4|6] [-l len] \"\n\t\t\t\"[-O 4|6] [-o 4|6] [-n num] [-t secs] [-R] [-T] \"\n\t\t\t\"[-s <osrc> [-d <odst>] [-S <isrc>] [-D <idst>] \"\n\t\t\t\"[-x <otos>] [-X <itos>] [-f <isport>] [-F]\\n\",\n\t\tfilepath);\n\texit(1);\n}\n\nstatic void parse_addr(int family, void *addr, const char *optarg)\n{\n\tint ret;\n\n\tret = inet_pton(family, optarg, addr);\n\tif (ret == -1)\n\t\terror(1, errno, \"inet_pton\");\n\tif (ret == 0)\n\t\terror(1, 0, \"inet_pton: bad string\");\n}\n\nstatic void parse_addr4(struct sockaddr_in *addr, const char *optarg)\n{\n\tparse_addr(AF_INET, &addr->sin_addr, optarg);\n}\n\nstatic void parse_addr6(struct sockaddr_in6 *addr, const char *optarg)\n{\n\tparse_addr(AF_INET6, &addr->sin6_addr, optarg);\n}\n\nstatic int parse_protocol_family(const char *filepath, const char *optarg)\n{\n\tif (!strcmp(optarg, \"4\"))\n\t\treturn PF_INET;\n\tif (!strcmp(optarg, \"6\"))\n\t\treturn PF_INET6;\n\n\tusage(filepath);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"d:D:e:f:Fhi:l:n:o:O:Rs:S:t:Tx:X:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'd':\n\t\t\tif (cfg_l3_outer == AF_UNSPEC)\n\t\t\t\terror(1, 0, \"-d must be preceded by -o\");\n\t\t\tif (cfg_l3_outer == AF_INET)\n\t\t\t\tparse_addr4(&out_daddr4, optarg);\n\t\t\telse\n\t\t\t\tparse_addr6(&out_daddr6, optarg);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (cfg_l3_inner == AF_UNSPEC)\n\t\t\t\terror(1, 0, \"-D must be preceded by -i\");\n\t\t\tif (cfg_l3_inner == AF_INET)\n\t\t\t\tparse_addr4(&in_daddr4, optarg);\n\t\t\telse\n\t\t\t\tparse_addr6(&in_daddr6, optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (!strcmp(optarg, \"gre\"))\n\t\t\t\tcfg_encap_proto = IPPROTO_GRE;\n\t\t\telse if (!strcmp(optarg, \"gue\"))\n\t\t\t\tcfg_encap_proto = IPPROTO_UDP;\n\t\t\telse if (!strcmp(optarg, \"bare\"))\n\t\t\t\tcfg_encap_proto = IPPROTO_IPIP;\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t\tcfg_encap_proto = IPPROTO_IP;\t \n\t\t\telse\n\t\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcfg_src_port = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tcfg_expect_failure = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (!strcmp(optarg, \"4\"))\n\t\t\t\tcfg_l3_inner = PF_INET;\n\t\t\telse if (!strcmp(optarg, \"6\"))\n\t\t\t\tcfg_l3_inner = PF_INET6;\n\t\t\telse\n\t\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_payload_len = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcfg_num_pkt = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tcfg_l3_outer = parse_protocol_family(argv[0], optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tcfg_l3_extra = parse_protocol_family(argv[0], optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tcfg_only_rx = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (cfg_l3_outer == AF_INET)\n\t\t\t\tparse_addr4(&out_saddr4, optarg);\n\t\t\telse\n\t\t\t\tparse_addr6(&out_saddr6, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (cfg_l3_inner == AF_INET)\n\t\t\t\tparse_addr4(&in_saddr4, optarg);\n\t\t\telse\n\t\t\t\tparse_addr6(&in_saddr6, optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_num_secs = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcfg_only_tx = true;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tcfg_dsfield_outer = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcfg_dsfield_inner = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cfg_only_rx && cfg_only_tx)\n\t\terror(1, 0, \"options: cannot combine rx-only and tx-only\");\n\n\tif (cfg_encap_proto && cfg_l3_outer == AF_UNSPEC)\n\t\terror(1, 0, \"options: must specify outer with encap\");\n\telse if ((!cfg_encap_proto) && cfg_l3_outer != AF_UNSPEC)\n\t\terror(1, 0, \"options: cannot combine no-encap and outer\");\n\telse if ((!cfg_encap_proto) && cfg_l3_extra != AF_UNSPEC)\n\t\terror(1, 0, \"options: cannot combine no-encap and extra\");\n\n\tif (cfg_l3_inner == AF_UNSPEC)\n\t\tcfg_l3_inner = AF_INET6;\n\tif (cfg_l3_inner == AF_INET6 && cfg_encap_proto == IPPROTO_IPIP)\n\t\tcfg_encap_proto = IPPROTO_IPV6;\n\n\t \n\tif (((cfg_dsfield_outer & 0x3) == 0x3) &&\n\t    ((cfg_dsfield_inner & 0x3) == 0x0))\n\t\tcfg_expect_failure = true;\n}\n\nstatic void print_opts(void)\n{\n\tif (cfg_l3_inner == PF_INET6) {\n\t\tutil_printaddr(\"inner.dest6\", (void *) &in_daddr6);\n\t\tutil_printaddr(\"inner.source6\", (void *) &in_saddr6);\n\t} else {\n\t\tutil_printaddr(\"inner.dest4\", (void *) &in_daddr4);\n\t\tutil_printaddr(\"inner.source4\", (void *) &in_saddr4);\n\t}\n\n\tif (!cfg_l3_outer)\n\t\treturn;\n\n\tfprintf(stderr, \"encap proto:   %u\\n\", cfg_encap_proto);\n\n\tif (cfg_l3_outer == PF_INET6) {\n\t\tutil_printaddr(\"outer.dest6\", (void *) &out_daddr6);\n\t\tutil_printaddr(\"outer.source6\", (void *) &out_saddr6);\n\t} else {\n\t\tutil_printaddr(\"outer.dest4\", (void *) &out_daddr4);\n\t\tutil_printaddr(\"outer.source4\", (void *) &out_saddr4);\n\t}\n\n\tif (!cfg_l3_extra)\n\t\treturn;\n\n\tif (cfg_l3_outer == PF_INET6) {\n\t\tutil_printaddr(\"extra.dest6\", (void *) &extra_daddr6);\n\t\tutil_printaddr(\"extra.source6\", (void *) &extra_saddr6);\n\t} else {\n\t\tutil_printaddr(\"extra.dest4\", (void *) &extra_daddr4);\n\t\tutil_printaddr(\"extra.source4\", (void *) &extra_saddr4);\n\t}\n\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\tprint_opts();\n\treturn do_main();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}