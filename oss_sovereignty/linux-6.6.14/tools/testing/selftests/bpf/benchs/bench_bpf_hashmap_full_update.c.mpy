{
  "module_name": "bench_bpf_hashmap_full_update.c",
  "hash_id": "361344094f95bdccffd10c63a7ca9aa15efb796a97b67ce87a83eea67bff164d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_bpf_hashmap_full_update.c",
  "human_readable_source": "\n \n\n#include \"bench.h\"\n#include \"bpf_hashmap_full_update_bench.skel.h\"\n#include \"bpf_util.h\"\n\n \nstatic struct ctx {\n\tstruct bpf_hashmap_full_update_bench *skel;\n} ctx;\n\n#define MAX_LOOP_NUM 10000\n\nstatic void validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true) {\n\t\t \n\t\tsyscall(__NR_getpgid);\n\t}\n\n\treturn NULL;\n}\n\nstatic void measure(struct bench_res *res)\n{\n}\n\nstatic void setup(void)\n{\n\tstruct bpf_link *link;\n\tint map_fd, i, max_entries;\n\n\tsetup_libbpf();\n\n\tctx.skel = bpf_hashmap_full_update_bench__open_and_load();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\texit(1);\n\t}\n\n\tctx.skel->bss->nr_loops = MAX_LOOP_NUM;\n\n\tlink = bpf_program__attach(ctx.skel->progs.benchmark);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n\n\t \n\tmap_fd = bpf_map__fd(ctx.skel->maps.hash_map_bench);\n\tmax_entries = bpf_map__max_entries(ctx.skel->maps.hash_map_bench);\n\tfor (i = 0; i < max_entries; i++)\n\t\tbpf_map_update_elem(map_fd, &i, &i, BPF_ANY);\n}\n\nstatic void hashmap_report_final(struct bench_res res[], int res_cnt)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tint i;\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tu64 time = ctx.skel->bss->percpu_time[i];\n\n\t\tif (!time)\n\t\t\tcontinue;\n\n\t\tprintf(\"%d:hash_map_full_perf %lld events per sec\\n\",\n\t\t       i, ctx.skel->bss->nr_loops * 1000000000ll / time);\n\t}\n}\n\nconst struct bench bench_bpf_hashmap_full_update = {\n\t.name = \"bpf-hashmap-full-update\",\n\t.validate = validate,\n\t.setup = setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = NULL,\n\t.report_final = hashmap_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}