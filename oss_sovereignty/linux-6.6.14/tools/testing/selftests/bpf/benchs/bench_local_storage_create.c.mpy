{
  "module_name": "bench_local_storage_create.c",
  "hash_id": "8c2c7655e5455addba233b771292fbb1757fdb4888e71fdedd086eeb57e9fa32",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_local_storage_create.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <pthread.h>\n#include <argp.h>\n\n#include \"bench.h\"\n#include \"bench_local_storage_create.skel.h\"\n\nstruct thread {\n\tint *fds;\n\tpthread_t *pthds;\n\tint *pthd_results;\n};\n\nstatic struct bench_local_storage_create *skel;\nstatic struct thread *threads;\nstatic long create_owner_errs;\nstatic int storage_type = BPF_MAP_TYPE_SK_STORAGE;\nstatic int batch_sz = 32;\n\nenum {\n\tARG_BATCH_SZ = 9000,\n\tARG_STORAGE_TYPE = 9001,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"batch-size\", ARG_BATCH_SZ, \"BATCH_SIZE\", 0,\n\t  \"The number of storage creations in each batch\" },\n\t{ \"storage-type\", ARG_STORAGE_TYPE, \"STORAGE_TYPE\", 0,\n\t  \"The type of local storage to test (socket or task)\" },\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tint ret;\n\n\tswitch (key) {\n\tcase ARG_BATCH_SZ:\n\t\tret = atoi(arg);\n\t\tif (ret < 1) {\n\t\t\tfprintf(stderr, \"invalid batch-size\\n\");\n\t\t\targp_usage(state);\n\t\t}\n\t\tbatch_sz = ret;\n\t\tbreak;\n\tcase ARG_STORAGE_TYPE:\n\t\tif (!strcmp(arg, \"task\")) {\n\t\t\tstorage_type = BPF_MAP_TYPE_TASK_STORAGE;\n\t\t} else if (!strcmp(arg, \"socket\")) {\n\t\t\tstorage_type = BPF_MAP_TYPE_SK_STORAGE;\n\t\t} else {\n\t\t\tfprintf(stderr, \"invalid storage-type (socket or task)\\n\");\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_local_storage_create_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\nstatic void validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"local-storage-create benchmark does not need consumer\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void setup(void)\n{\n\tint i;\n\n\tskel = bench_local_storage_create__open_and_load();\n\tif (!skel) {\n\t\tfprintf(stderr, \"error loading skel\\n\");\n\t\texit(1);\n\t}\n\n\tskel->bss->bench_pid = getpid();\n\tif (storage_type == BPF_MAP_TYPE_SK_STORAGE) {\n\t\tif (!bpf_program__attach(skel->progs.socket_post_create)) {\n\t\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tif (!bpf_program__attach(skel->progs.sched_process_fork)) {\n\t\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!bpf_program__attach(skel->progs.kmalloc)) {\n\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\texit(1);\n\t}\n\n\tthreads = calloc(env.producer_cnt, sizeof(*threads));\n\n\tif (!threads) {\n\t\tfprintf(stderr, \"cannot alloc thread_res\\n\");\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < env.producer_cnt; i++) {\n\t\tstruct thread *t = &threads[i];\n\n\t\tif (storage_type == BPF_MAP_TYPE_SK_STORAGE) {\n\t\t\tt->fds = malloc(batch_sz * sizeof(*t->fds));\n\t\t\tif (!t->fds) {\n\t\t\t\tfprintf(stderr, \"cannot alloc t->fds\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else {\n\t\t\tt->pthds = malloc(batch_sz * sizeof(*t->pthds));\n\t\t\tif (!t->pthds) {\n\t\t\t\tfprintf(stderr, \"cannot alloc t->pthds\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tt->pthd_results = malloc(batch_sz * sizeof(*t->pthd_results));\n\t\t\tif (!t->pthd_results) {\n\t\t\t\tfprintf(stderr, \"cannot alloc t->pthd_results\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void measure(struct bench_res *res)\n{\n\tres->hits = atomic_swap(&skel->bss->create_cnts, 0);\n\tres->drops = atomic_swap(&skel->bss->kmalloc_cnts, 0);\n}\n\nstatic void *sk_producer(void *input)\n{\n\tstruct thread *t = &threads[(long)(input)];\n\tint *fds = t->fds;\n\tint i;\n\n\twhile (true) {\n\t\tfor (i = 0; i < batch_sz; i++) {\n\t\t\tfds[i] = socket(AF_INET6, SOCK_DGRAM, 0);\n\t\t\tif (fds[i] == -1)\n\t\t\t\tatomic_inc(&create_owner_errs);\n\t\t}\n\n\t\tfor (i = 0; i < batch_sz; i++) {\n\t\t\tif (fds[i] != -1)\n\t\t\t\tclose(fds[i]);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *thread_func(void *arg)\n{\n\treturn NULL;\n}\n\nstatic void *task_producer(void *input)\n{\n\tstruct thread *t = &threads[(long)(input)];\n\tpthread_t *pthds = t->pthds;\n\tint *pthd_results = t->pthd_results;\n\tint i;\n\n\twhile (true) {\n\t\tfor (i = 0; i < batch_sz; i++) {\n\t\t\tpthd_results[i] = pthread_create(&pthds[i], NULL, thread_func, NULL);\n\t\t\tif (pthd_results[i])\n\t\t\t\tatomic_inc(&create_owner_errs);\n\t\t}\n\n\t\tfor (i = 0; i < batch_sz; i++) {\n\t\t\tif (!pthd_results[i])\n\t\t\t\tpthread_join(pthds[i], NULL);;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *producer(void *input)\n{\n\tif (storage_type == BPF_MAP_TYPE_SK_STORAGE)\n\t\treturn sk_producer(input);\n\telse\n\t\treturn task_producer(input);\n}\n\nstatic void report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tdouble creates_per_sec, kmallocs_per_create;\n\n\tcreates_per_sec = res->hits / 1000.0 / (delta_ns / 1000000000.0);\n\tkmallocs_per_create = (double)res->drops / res->hits;\n\n\tprintf(\"Iter %3d (%7.3lfus): \",\n\t       iter, (delta_ns - 1000000000) / 1000.0);\n\tprintf(\"creates %8.3lfk/s (%7.3lfk/prod), \",\n\t       creates_per_sec, creates_per_sec / env.producer_cnt);\n\tprintf(\"%3.2lf kmallocs/create\\n\", kmallocs_per_create);\n}\n\nstatic void report_final(struct bench_res res[], int res_cnt)\n{\n\tdouble creates_mean = 0.0, creates_stddev = 0.0;\n\tlong total_creates = 0, total_kmallocs = 0;\n\tint i;\n\n\tfor (i = 0; i < res_cnt; i++) {\n\t\tcreates_mean += res[i].hits / 1000.0 / (0.0 + res_cnt);\n\t\ttotal_creates += res[i].hits;\n\t\ttotal_kmallocs += res[i].drops;\n\t}\n\n\tif (res_cnt > 1)  {\n\t\tfor (i = 0; i < res_cnt; i++)\n\t\t\tcreates_stddev += (creates_mean - res[i].hits / 1000.0) *\n\t\t\t\t       (creates_mean - res[i].hits / 1000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\t\tcreates_stddev = sqrt(creates_stddev);\n\t}\n\tprintf(\"Summary: creates %8.3lf \\u00B1 %5.3lfk/s (%7.3lfk/prod), \",\n\t       creates_mean, creates_stddev, creates_mean / env.producer_cnt);\n\tprintf(\"%4.2lf kmallocs/create\\n\", (double)total_kmallocs / total_creates);\n\tif (create_owner_errs || skel->bss->create_errs)\n\t\tprintf(\"%s() errors %ld create_errs %ld\\n\",\n\t\t       storage_type == BPF_MAP_TYPE_SK_STORAGE ?\n\t\t       \"socket\" : \"pthread_create\",\n\t\t       create_owner_errs,\n\t\t       skel->bss->create_errs);\n}\n\n \nconst struct bench bench_local_storage_create = {\n\t.name = \"local-storage-create\",\n\t.argp = &bench_local_storage_create_argp,\n\t.validate = validate,\n\t.setup = setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = report_progress,\n\t.report_final = report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}