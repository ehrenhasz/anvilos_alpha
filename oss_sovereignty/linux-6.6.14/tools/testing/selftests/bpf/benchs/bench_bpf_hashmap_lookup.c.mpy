{
  "module_name": "bench_bpf_hashmap_lookup.c",
  "hash_id": "a9eea153a8bf598644d07411e017e8fafe59f766d0bf6c47bc3b08db9b683b2a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_bpf_hashmap_lookup.c",
  "human_readable_source": "\n \n\n#include <sys/random.h>\n#include <argp.h>\n#include \"bench.h\"\n#include \"bpf_hashmap_lookup.skel.h\"\n#include \"bpf_util.h\"\n\n \nstatic struct ctx {\n\tstruct bpf_hashmap_lookup *skel;\n} ctx;\n\n \n#define BPF_MAX_LOOPS (1<<23)\n\n#define MAX_KEY_SIZE 1024  \n\nstatic struct {\n\t__u32 key_size;\n\t__u32 map_flags;\n\t__u32 max_entries;\n\t__u32 nr_entries;\n\t__u32 nr_loops;\n} args = {\n\t.key_size = 4,\n\t.map_flags = 0,\n\t.max_entries = 1000,\n\t.nr_entries = 500,\n\t.nr_loops = 1000000,\n};\n\nenum {\n\tARG_KEY_SIZE = 8001,\n\tARG_MAP_FLAGS,\n\tARG_MAX_ENTRIES,\n\tARG_NR_ENTRIES,\n\tARG_NR_LOOPS,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"key_size\", ARG_KEY_SIZE, \"KEY_SIZE\", 0,\n\t  \"The hashmap key size (max 1024)\"},\n\t{ \"map_flags\", ARG_MAP_FLAGS, \"MAP_FLAGS\", 0,\n\t  \"The hashmap flags passed to BPF_MAP_CREATE\"},\n\t{ \"max_entries\", ARG_MAX_ENTRIES, \"MAX_ENTRIES\", 0,\n\t  \"The hashmap max entries\"},\n\t{ \"nr_entries\", ARG_NR_ENTRIES, \"NR_ENTRIES\", 0,\n\t  \"The number of entries to insert/lookup\"},\n\t{ \"nr_loops\", ARG_NR_LOOPS, \"NR_LOOPS\", 0,\n\t  \"The number of loops for the benchmark\"},\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tlong ret;\n\n\tswitch (key) {\n\tcase ARG_KEY_SIZE:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > MAX_KEY_SIZE) {\n\t\t\tfprintf(stderr, \"invalid key_size\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.key_size = ret;\n\t\tbreak;\n\tcase ARG_MAP_FLAGS:\n\t\tret = strtol(arg, NULL, 0);\n\t\tif (ret < 0 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid map_flags\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.map_flags = ret;\n\t\tbreak;\n\tcase ARG_MAX_ENTRIES:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid max_entries\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.max_entries = ret;\n\t\tbreak;\n\tcase ARG_NR_ENTRIES:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid nr_entries\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_entries = ret;\n\t\tbreak;\n\tcase ARG_NR_LOOPS:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > BPF_MAX_LOOPS) {\n\t\t\tfprintf(stderr, \"invalid nr_loops: %ld (min=1 max=%u)\\n\",\n\t\t\t\tret, BPF_MAX_LOOPS);\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_loops = ret;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_hashmap_lookup_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\nstatic void validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n\n\tif (args.nr_entries > args.max_entries) {\n\t\tfprintf(stderr, \"args.nr_entries is too big! (max %u, got %u)\\n\",\n\t\t\targs.max_entries, args.nr_entries);\n\t\texit(1);\n\t}\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true) {\n\t\t \n\t\tsyscall(__NR_getpgid);\n\t}\n\treturn NULL;\n}\n\nstatic void measure(struct bench_res *res)\n{\n}\n\nstatic inline void patch_key(u32 i, u32 *key)\n{\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\t*key = i + 1;\n#else\n\t*key = __builtin_bswap32(i + 1);\n#endif\n\t \n}\n\nstatic void setup(void)\n{\n\tstruct bpf_link *link;\n\tint map_fd;\n\tint ret;\n\tint i;\n\n\tsetup_libbpf();\n\n\tctx.skel = bpf_hashmap_lookup__open();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\texit(1);\n\t}\n\n\tbpf_map__set_max_entries(ctx.skel->maps.hash_map_bench, args.max_entries);\n\tbpf_map__set_key_size(ctx.skel->maps.hash_map_bench, args.key_size);\n\tbpf_map__set_value_size(ctx.skel->maps.hash_map_bench, 8);\n\tbpf_map__set_map_flags(ctx.skel->maps.hash_map_bench, args.map_flags);\n\n\tctx.skel->bss->nr_entries = args.nr_entries;\n\tctx.skel->bss->nr_loops = args.nr_loops / args.nr_entries;\n\n\tif (args.key_size > 4) {\n\t\tfor (i = 1; i < args.key_size/4; i++)\n\t\t\tctx.skel->bss->key[i] = 2654435761 * i;\n\t}\n\n\tret = bpf_hashmap_lookup__load(ctx.skel);\n\tif (ret) {\n\t\tbpf_hashmap_lookup__destroy(ctx.skel);\n\t\tfprintf(stderr, \"failed to load map: %s\", strerror(-ret));\n\t\texit(1);\n\t}\n\n\t \n\tmap_fd = bpf_map__fd(ctx.skel->maps.hash_map_bench);\n\tfor (u64 i = 0; i < args.nr_entries; i++) {\n\t\tpatch_key(i, ctx.skel->bss->key);\n\t\tbpf_map_update_elem(map_fd, ctx.skel->bss->key, &i, BPF_ANY);\n\t}\n\n\tlink = bpf_program__attach(ctx.skel->progs.benchmark);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic inline double events_from_time(u64 time)\n{\n\tif (time)\n\t\treturn args.nr_loops * 1000000000llu / time / 1000000.0L;\n\n\treturn 0;\n}\n\nstatic int compute_events(u64 *times, double *events_mean, double *events_stddev, u64 *mean_time)\n{\n\tint i, n = 0;\n\n\t*events_mean = 0;\n\t*events_stddev = 0;\n\t*mean_time = 0;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (!times[i])\n\t\t\tbreak;\n\t\t*mean_time += times[i];\n\t\t*events_mean += events_from_time(times[i]);\n\t\tn += 1;\n\t}\n\tif (!n)\n\t\treturn 0;\n\n\t*mean_time /= n;\n\t*events_mean /= n;\n\n\tif (n > 1) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdouble events_i = *events_mean - events_from_time(times[i]);\n\t\t\t*events_stddev += events_i * events_i / (n - 1);\n\t\t}\n\t\t*events_stddev = sqrt(*events_stddev);\n\t}\n\n\treturn n;\n}\n\nstatic void hashmap_report_final(struct bench_res res[], int res_cnt)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tdouble events_mean, events_stddev;\n\tu64 mean_time;\n\tint i, n;\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tn = compute_events(ctx.skel->bss->percpu_times[i], &events_mean,\n\t\t\t\t   &events_stddev, &mean_time);\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tif (env.quiet) {\n\t\t\t \n\t\t\tif (env.affinity)\n\t\t\t\tprintf(\"%.3lf\\n\", events_mean);\n\t\t\telse\n\t\t\t\tprintf(\"cpu%02d %.3lf\\n\", i, events_mean);\n\t\t} else {\n\t\t\tprintf(\"cpu%02d: lookup %.3lfM \u00b1 %.3lfM events/sec\"\n\t\t\t       \" (approximated from %d samples of ~%lums)\\n\",\n\t\t\t       i, events_mean, 2*events_stddev,\n\t\t\t       n, mean_time / 1000000);\n\t\t}\n\t}\n}\n\nconst struct bench bench_bpf_hashmap_lookup = {\n\t.name = \"bpf-hashmap-lookup\",\n\t.argp = &bench_hashmap_lookup_argp,\n\t.validate = validate,\n\t.setup = setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = NULL,\n\t.report_final = hashmap_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}