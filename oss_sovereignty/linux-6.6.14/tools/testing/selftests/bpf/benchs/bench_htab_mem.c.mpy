{
  "module_name": "bench_htab_mem.c",
  "hash_id": "7689a964bf5e2a425eabd75fdcdc25c74e99a9ea0bdf84438dffcf684a01e093",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_htab_mem.c",
  "human_readable_source": "\n \n#include <argp.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <fcntl.h>\n\n#include \"bench.h\"\n#include \"bpf_util.h\"\n#include \"cgroup_helpers.h\"\n#include \"htab_mem_bench.skel.h\"\n\nstruct htab_mem_use_case {\n\tconst char *name;\n\tconst char **progs;\n\t \n\tbool need_sync;\n};\n\nstatic struct htab_mem_ctx {\n\tconst struct htab_mem_use_case *uc;\n\tstruct htab_mem_bench *skel;\n\tpthread_barrier_t *notify;\n\tint fd;\n} ctx;\n\nconst char *ow_progs[] = {\"overwrite\", NULL};\nconst char *batch_progs[] = {\"batch_add_batch_del\", NULL};\nconst char *add_del_progs[] = {\"add_only\", \"del_only\", NULL};\nconst static struct htab_mem_use_case use_cases[] = {\n\t{ .name = \"overwrite\", .progs = ow_progs },\n\t{ .name = \"batch_add_batch_del\", .progs = batch_progs },\n\t{ .name = \"add_del_on_diff_cpu\", .progs = add_del_progs, .need_sync = true },\n};\n\nstatic struct htab_mem_args {\n\tu32 value_size;\n\tconst char *use_case;\n\tbool preallocated;\n} args = {\n\t.value_size = 8,\n\t.use_case = \"overwrite\",\n\t.preallocated = false,\n};\n\nenum {\n\tARG_VALUE_SIZE = 10000,\n\tARG_USE_CASE = 10001,\n\tARG_PREALLOCATED = 10002,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"value-size\", ARG_VALUE_SIZE, \"VALUE_SIZE\", 0,\n\t  \"Set the value size of hash map (default 8)\" },\n\t{ \"use-case\", ARG_USE_CASE, \"USE_CASE\", 0,\n\t  \"Set the use case of hash map: overwrite|batch_add_batch_del|add_del_on_diff_cpu\" },\n\t{ \"preallocated\", ARG_PREALLOCATED, NULL, 0, \"use preallocated hash map\" },\n\t{},\n};\n\nstatic error_t htab_mem_parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tswitch (key) {\n\tcase ARG_VALUE_SIZE:\n\t\targs.value_size = strtoul(arg, NULL, 10);\n\t\tif (args.value_size > 4096) {\n\t\t\tfprintf(stderr, \"too big value size %u\\n\", args.value_size);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase ARG_USE_CASE:\n\t\targs.use_case = strdup(arg);\n\t\tif (!args.use_case) {\n\t\t\tfprintf(stderr, \"no mem for use-case\\n\");\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase ARG_PREALLOCATED:\n\t\targs.preallocated = true;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_htab_mem_argp = {\n\t.options = opts,\n\t.parser = htab_mem_parse_arg,\n};\n\nstatic void htab_mem_validate(void)\n{\n\tif (!strcmp(use_cases[2].name, args.use_case) && env.producer_cnt % 2) {\n\t\tfprintf(stderr, \"%s needs an even number of producers\\n\", args.use_case);\n\t\texit(1);\n\t}\n}\n\nstatic int htab_mem_bench_init_barriers(void)\n{\n\tpthread_barrier_t *barriers;\n\tunsigned int i, nr;\n\n\tif (!ctx.uc->need_sync)\n\t\treturn 0;\n\n\tnr = (env.producer_cnt + 1) / 2;\n\tbarriers = calloc(nr, sizeof(*barriers));\n\tif (!barriers)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < nr; i++)\n\t\tpthread_barrier_init(&barriers[i], NULL, 2);\n\n\tctx.notify = barriers;\n\treturn 0;\n}\n\nstatic void htab_mem_bench_exit_barriers(void)\n{\n\tunsigned int i, nr;\n\n\tif (!ctx.notify)\n\t\treturn;\n\n\tnr = (env.producer_cnt + 1) / 2;\n\tfor (i = 0; i < nr; i++)\n\t\tpthread_barrier_destroy(&ctx.notify[i]);\n\tfree(ctx.notify);\n}\n\nstatic const struct htab_mem_use_case *htab_mem_find_use_case_or_exit(const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(use_cases); i++) {\n\t\tif (!strcmp(name, use_cases[i].name))\n\t\t\treturn &use_cases[i];\n\t}\n\n\tfprintf(stderr, \"no such use-case: %s\\n\", name);\n\tfprintf(stderr, \"available use case:\");\n\tfor (i = 0; i < ARRAY_SIZE(use_cases); i++)\n\t\tfprintf(stderr, \" %s\", use_cases[i].name);\n\tfprintf(stderr, \"\\n\");\n\texit(1);\n}\n\nstatic void htab_mem_setup(void)\n{\n\tstruct bpf_map *map;\n\tconst char **names;\n\tint err;\n\n\tsetup_libbpf();\n\n\tctx.uc = htab_mem_find_use_case_or_exit(args.use_case);\n\terr = htab_mem_bench_init_barriers();\n\tif (err) {\n\t\tfprintf(stderr, \"failed to init barrier\\n\");\n\t\texit(1);\n\t}\n\n\tctx.fd = cgroup_setup_and_join(\"/htab_mem\");\n\tif (ctx.fd < 0)\n\t\tgoto cleanup;\n\n\tctx.skel = htab_mem_bench__open();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap = ctx.skel->maps.htab;\n\tbpf_map__set_value_size(map, args.value_size);\n\t \n\tbpf_map__set_max_entries(map, MAX(8192, 64 * env.nr_cpus));\n\tif (args.preallocated)\n\t\tbpf_map__set_map_flags(map, bpf_map__map_flags(map) & ~BPF_F_NO_PREALLOC);\n\n\tnames = ctx.uc->progs;\n\twhile (*names) {\n\t\tstruct bpf_program *prog;\n\n\t\tprog = bpf_object__find_program_by_name(ctx.skel->obj, *names);\n\t\tif (!prog) {\n\t\t\tfprintf(stderr, \"no such program %s\\n\", *names);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbpf_program__set_autoload(prog, true);\n\t\tnames++;\n\t}\n\tctx.skel->bss->nr_thread = env.producer_cnt;\n\n\terr = htab_mem_bench__load(ctx.skel);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to load skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\terr = htab_mem_bench__attach(ctx.skel);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to attach skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\treturn;\n\ncleanup:\n\thtab_mem_bench__destroy(ctx.skel);\n\thtab_mem_bench_exit_barriers();\n\tif (ctx.fd >= 0) {\n\t\tclose(ctx.fd);\n\t\tcleanup_cgroup_environment();\n\t}\n\texit(1);\n}\n\nstatic void htab_mem_add_fn(pthread_barrier_t *notify)\n{\n\twhile (true) {\n\t\t \n\t\t(void)syscall(__NR_getpgid, 0);\n\t\t \n\t\tpthread_barrier_wait(notify);\n\t\t \n\t\tpthread_barrier_wait(notify);\n\t}\n}\n\nstatic void htab_mem_delete_fn(pthread_barrier_t *notify)\n{\n\twhile (true) {\n\t\t \n\t\tpthread_barrier_wait(notify);\n\t\t \n\t\t(void)syscall(__NR_getppid);\n\t\t \n\t\tpthread_barrier_wait(notify);\n\t}\n}\n\nstatic void *htab_mem_producer(void *arg)\n{\n\tpthread_barrier_t *notify;\n\tint seq;\n\n\tif (!ctx.uc->need_sync) {\n\t\twhile (true)\n\t\t\t(void)syscall(__NR_getpgid, 0);\n\t\treturn NULL;\n\t}\n\n\tseq = (long)arg;\n\tnotify = &ctx.notify[seq / 2];\n\tif (seq & 1)\n\t\thtab_mem_delete_fn(notify);\n\telse\n\t\thtab_mem_add_fn(notify);\n\treturn NULL;\n}\n\nstatic void htab_mem_read_mem_cgrp_file(const char *name, unsigned long *value)\n{\n\tchar buf[32];\n\tssize_t got;\n\tint fd;\n\n\tfd = openat(ctx.fd, name, O_RDONLY);\n\tif (fd < 0) {\n\t\t \n\t\tfprintf(stderr, \"no %s\\n\", name);\n\t\t*value = 0;\n\t\treturn;\n\t}\n\n\tgot = read(fd, buf, sizeof(buf) - 1);\n\tif (got <= 0) {\n\t\t*value = 0;\n\t\treturn;\n\t}\n\tbuf[got] = 0;\n\n\t*value = strtoull(buf, NULL, 0);\n\n\tclose(fd);\n}\n\nstatic void htab_mem_measure(struct bench_res *res)\n{\n\tres->hits = atomic_swap(&ctx.skel->bss->op_cnt, 0) / env.producer_cnt;\n\thtab_mem_read_mem_cgrp_file(\"memory.current\", &res->gp_ct);\n}\n\nstatic void htab_mem_report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tdouble loop, mem;\n\n\tloop = res->hits / 1000.0 / (delta_ns / 1000000000.0);\n\tmem = res->gp_ct / 1048576.0;\n\tprintf(\"Iter %3d (%7.3lfus): \", iter, (delta_ns - 1000000000) / 1000.0);\n\tprintf(\"per-prod-op %7.2lfk/s, memory usage %7.2lfMiB\\n\", loop, mem);\n}\n\nstatic void htab_mem_report_final(struct bench_res res[], int res_cnt)\n{\n\tdouble mem_mean = 0.0, mem_stddev = 0.0;\n\tdouble loop_mean = 0.0, loop_stddev = 0.0;\n\tunsigned long peak_mem;\n\tint i;\n\n\tfor (i = 0; i < res_cnt; i++) {\n\t\tloop_mean += res[i].hits / 1000.0 / (0.0 + res_cnt);\n\t\tmem_mean += res[i].gp_ct / 1048576.0 / (0.0 + res_cnt);\n\t}\n\tif (res_cnt > 1)  {\n\t\tfor (i = 0; i < res_cnt; i++) {\n\t\t\tloop_stddev += (loop_mean - res[i].hits / 1000.0) *\n\t\t\t\t       (loop_mean - res[i].hits / 1000.0) /\n\t\t\t\t       (res_cnt - 1.0);\n\t\t\tmem_stddev += (mem_mean - res[i].gp_ct / 1048576.0) *\n\t\t\t\t      (mem_mean - res[i].gp_ct / 1048576.0) /\n\t\t\t\t      (res_cnt - 1.0);\n\t\t}\n\t\tloop_stddev = sqrt(loop_stddev);\n\t\tmem_stddev = sqrt(mem_stddev);\n\t}\n\n\thtab_mem_read_mem_cgrp_file(\"memory.peak\", &peak_mem);\n\tprintf(\"Summary: per-prod-op %7.2lf \\u00B1 %7.2lfk/s, memory usage %7.2lf \\u00B1 %7.2lfMiB,\"\n\t       \" peak memory usage %7.2lfMiB\\n\",\n\t       loop_mean, loop_stddev, mem_mean, mem_stddev, peak_mem / 1048576.0);\n\n\tcleanup_cgroup_environment();\n}\n\nconst struct bench bench_htab_mem = {\n\t.name = \"htab-mem\",\n\t.argp = &bench_htab_mem_argp,\n\t.validate = htab_mem_validate,\n\t.setup = htab_mem_setup,\n\t.producer_thread = htab_mem_producer,\n\t.measure = htab_mem_measure,\n\t.report_progress = htab_mem_report_progress,\n\t.report_final = htab_mem_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}