{
  "module_name": "bench_strncmp.c",
  "hash_id": "7f72e284098a68a727b0c1e40e0d6fa0dc97193df68586f9bdbfabc80773a79d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_strncmp.c",
  "human_readable_source": "\n \n#include <argp.h>\n#include \"bench.h\"\n#include \"strncmp_bench.skel.h\"\n\nstatic struct strncmp_ctx {\n\tstruct strncmp_bench *skel;\n} ctx;\n\nstatic struct strncmp_args {\n\tu32 cmp_str_len;\n} args = {\n\t.cmp_str_len = 32,\n};\n\nenum {\n\tARG_CMP_STR_LEN = 5000,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"cmp-str-len\", ARG_CMP_STR_LEN, \"CMP_STR_LEN\", 0,\n\t  \"Set the length of compared string\" },\n\t{},\n};\n\nstatic error_t strncmp_parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tswitch (key) {\n\tcase ARG_CMP_STR_LEN:\n\t\targs.cmp_str_len = strtoul(arg, NULL, 10);\n\t\tif (!args.cmp_str_len ||\n\t\t    args.cmp_str_len >= sizeof(ctx.skel->bss->str)) {\n\t\t\tfprintf(stderr, \"Invalid cmp str len (limit %zu)\\n\",\n\t\t\t\tsizeof(ctx.skel->bss->str));\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_strncmp_argp = {\n\t.options = opts,\n\t.parser = strncmp_parse_arg,\n};\n\nstatic void strncmp_validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"strncmp benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void strncmp_setup(void)\n{\n\tint err;\n\tchar *target;\n\tsize_t i, sz;\n\n\tsz = sizeof(ctx.skel->rodata->target);\n\tif (!sz || sz < sizeof(ctx.skel->bss->str)) {\n\t\tfprintf(stderr, \"invalid string size (target %zu, src %zu)\\n\",\n\t\t\tsz, sizeof(ctx.skel->bss->str));\n\t\texit(1);\n\t}\n\n\tsetup_libbpf();\n\n\tctx.skel = strncmp_bench__open();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\texit(1);\n\t}\n\n\tsrandom(time(NULL));\n\ttarget = ctx.skel->rodata->target;\n\tfor (i = 0; i < sz - 1; i++)\n\t\ttarget[i] = '1' + random() % 9;\n\ttarget[sz - 1] = '\\0';\n\n\tctx.skel->rodata->cmp_str_len = args.cmp_str_len;\n\n\tmemcpy(ctx.skel->bss->str, target, args.cmp_str_len);\n\tctx.skel->bss->str[args.cmp_str_len] = '\\0';\n\t \n\tctx.skel->bss->str[args.cmp_str_len - 1] -= 1;\n\n\terr = strncmp_bench__load(ctx.skel);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to load skeleton\\n\");\n\t\tstrncmp_bench__destroy(ctx.skel);\n\t\texit(1);\n\t}\n}\n\nstatic void strncmp_attach_prog(struct bpf_program *prog)\n{\n\tstruct bpf_link *link;\n\n\tlink = bpf_program__attach(prog);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void strncmp_no_helper_setup(void)\n{\n\tstrncmp_setup();\n\tstrncmp_attach_prog(ctx.skel->progs.strncmp_no_helper);\n}\n\nstatic void strncmp_helper_setup(void)\n{\n\tstrncmp_setup();\n\tstrncmp_attach_prog(ctx.skel->progs.strncmp_helper);\n}\n\nstatic void *strncmp_producer(void *ctx)\n{\n\twhile (true)\n\t\t(void)syscall(__NR_getpgid);\n\treturn NULL;\n}\n\nstatic void strncmp_measure(struct bench_res *res)\n{\n\tres->hits = atomic_swap(&ctx.skel->bss->hits, 0);\n}\n\nconst struct bench bench_strncmp_no_helper = {\n\t.name = \"strncmp-no-helper\",\n\t.argp = &bench_strncmp_argp,\n\t.validate = strncmp_validate,\n\t.setup = strncmp_no_helper_setup,\n\t.producer_thread = strncmp_producer,\n\t.measure = strncmp_measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n\nconst struct bench bench_strncmp_helper = {\n\t.name = \"strncmp-helper\",\n\t.argp = &bench_strncmp_argp,\n\t.validate = strncmp_validate,\n\t.setup = strncmp_helper_setup,\n\t.producer_thread = strncmp_producer,\n\t.measure = strncmp_measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}