{
  "module_name": "bench_local_storage_rcu_tasks_trace.c",
  "hash_id": "5ad45bae9aac2ad09750f40a981b4af6801614c7fee13e76a889ce8ef088619c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_local_storage_rcu_tasks_trace.c",
  "human_readable_source": "\n \n\n#include <argp.h>\n\n#include <sys/prctl.h>\n#include \"local_storage_rcu_tasks_trace_bench.skel.h\"\n#include \"bench.h\"\n\n#include <signal.h>\n\nstatic struct {\n\t__u32 nr_procs;\n\t__u32 kthread_pid;\n} args = {\n\t.nr_procs = 1000,\n\t.kthread_pid = 0,\n};\n\nenum {\n\tARG_NR_PROCS = 7000,\n\tARG_KTHREAD_PID = 7001,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"nr_procs\", ARG_NR_PROCS, \"NR_PROCS\", 0,\n\t\t\"Set number of user processes to spin up\"},\n\t{ \"kthread_pid\", ARG_KTHREAD_PID, \"PID\", 0,\n\t\t\"Pid of rcu_tasks_trace kthread for ticks tracking\"},\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tlong ret;\n\n\tswitch (key) {\n\tcase ARG_NR_PROCS:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid nr_procs\\n\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_procs = ret;\n\t\tbreak;\n\tcase ARG_KTHREAD_PID:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1) {\n\t\t\tfprintf(stderr, \"invalid kthread_pid\\n\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.kthread_pid = ret;\n\t\tbreak;\nbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_local_storage_rcu_tasks_trace_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\n#define MAX_SLEEP_PROCS 150000\n\nstatic void validate(void)\n{\n\tif (env.producer_cnt != 1) {\n\t\tfprintf(stderr, \"benchmark doesn't support multi-producer!\\n\");\n\t\texit(1);\n\t}\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n\n\tif (args.nr_procs > MAX_SLEEP_PROCS) {\n\t\tfprintf(stderr, \"benchmark supports up to %u sleeper procs!\\n\",\n\t\t\tMAX_SLEEP_PROCS);\n\t\texit(1);\n\t}\n}\n\nstatic long kthread_pid_ticks(void)\n{\n\tchar procfs_path[100];\n\tlong stime;\n\tFILE *f;\n\n\tif (!args.kthread_pid)\n\t\treturn -1;\n\n\tsprintf(procfs_path, \"/proc/%u/stat\", args.kthread_pid);\n\tf = fopen(procfs_path, \"r\");\n\tif (!f) {\n\t\tfprintf(stderr, \"couldn't open %s, exiting\\n\", procfs_path);\n\t\tgoto err_out;\n\t}\n\tif (fscanf(f, \"%*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %ld\", &stime) != 1) {\n\t\tfprintf(stderr, \"fscanf of %s failed, exiting\\n\", procfs_path);\n\t\tgoto err_out;\n\t}\n\tfclose(f);\n\treturn stime;\n\nerr_out:\n\tif (f)\n\t\tfclose(f);\n\texit(1);\n\treturn 0;\n}\n\nstatic struct {\n\tstruct local_storage_rcu_tasks_trace_bench *skel;\n\tlong prev_kthread_stime;\n} ctx;\n\nstatic void sleep_and_loop(void)\n{\n\twhile (true) {\n\t\tsleep(rand() % 4);\n\t\tsyscall(__NR_getpgid);\n\t}\n}\n\nstatic void local_storage_tasks_trace_setup(void)\n{\n\tint i, err, forkret, runner_pid;\n\n\trunner_pid = getpid();\n\n\tfor (i = 0; i < args.nr_procs; i++) {\n\t\tforkret = fork();\n\t\tif (forkret < 0) {\n\t\t\tfprintf(stderr, \"Error forking sleeper proc %u of %u, exiting\\n\", i,\n\t\t\t\targs.nr_procs);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!forkret) {\n\t\t\terr = prctl(PR_SET_PDEATHSIG, SIGKILL);\n\t\t\tif (err < 0) {\n\t\t\t\tfprintf(stderr, \"prctl failed with err %d, exiting\\n\", errno);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (getppid() != runner_pid) {\n\t\t\t\tfprintf(stderr, \"Runner died while spinning up procs, exiting\\n\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsleep_and_loop();\n\t\t}\n\t}\n\tprintf(\"Spun up %u procs (our pid %d)\\n\", args.nr_procs, runner_pid);\n\n\tsetup_libbpf();\n\n\tctx.skel = local_storage_rcu_tasks_trace_bench__open_and_load();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"Error doing open_and_load, exiting\\n\");\n\t\tgoto err_out;\n\t}\n\n\tctx.prev_kthread_stime = kthread_pid_ticks();\n\n\tif (!bpf_program__attach(ctx.skel->progs.get_local)) {\n\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!bpf_program__attach(ctx.skel->progs.pregp_step)) {\n\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!bpf_program__attach(ctx.skel->progs.postgp)) {\n\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn;\nerr_out:\n\texit(1);\n}\n\nstatic void measure(struct bench_res *res)\n{\n\tlong ticks;\n\n\tres->gp_ct = atomic_swap(&ctx.skel->bss->gp_hits, 0);\n\tres->gp_ns = atomic_swap(&ctx.skel->bss->gp_times, 0);\n\tticks = kthread_pid_ticks();\n\tres->stime = ticks - ctx.prev_kthread_stime;\n\tctx.prev_kthread_stime = ticks;\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true)\n\t\tsyscall(__NR_getpgid);\n\treturn NULL;\n}\n\nstatic void report_progress(int iter, struct bench_res *res, long delta_ns)\n{\n\tif (ctx.skel->bss->unexpected) {\n\t\tfprintf(stderr, \"Error: Unexpected order of bpf prog calls (postgp after pregp).\");\n\t\tfprintf(stderr, \"Data can't be trusted, exiting\\n\");\n\t\texit(1);\n\t}\n\n\tif (env.quiet)\n\t\treturn;\n\n\tprintf(\"Iter %d\\t avg tasks_trace grace period latency\\t%lf ns\\n\",\n\t       iter, res->gp_ns / (double)res->gp_ct);\n\tprintf(\"Iter %d\\t avg ticks per tasks_trace grace period\\t%lf\\n\",\n\t       iter, res->stime / (double)res->gp_ct);\n}\n\nstatic void report_final(struct bench_res res[], int res_cnt)\n{\n\tstruct basic_stats gp_stat;\n\n\tgrace_period_latency_basic_stats(res, res_cnt, &gp_stat);\n\tprintf(\"SUMMARY tasks_trace grace period latency\");\n\tprintf(\"\\tavg %.3lf us\\tstddev %.3lf us\\n\", gp_stat.mean, gp_stat.stddev);\n\tgrace_period_ticks_basic_stats(res, res_cnt, &gp_stat);\n\tprintf(\"SUMMARY ticks per tasks_trace grace period\");\n\tprintf(\"\\tavg %.3lf\\tstddev %.3lf\\n\", gp_stat.mean, gp_stat.stddev);\n}\n\n \nconst struct bench bench_local_storage_tasks_trace = {\n\t.name = \"local-storage-tasks-trace\",\n\t.argp = &bench_local_storage_rcu_tasks_trace_argp,\n\t.validate = validate,\n\t.setup = local_storage_tasks_trace_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = report_progress,\n\t.report_final = report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}