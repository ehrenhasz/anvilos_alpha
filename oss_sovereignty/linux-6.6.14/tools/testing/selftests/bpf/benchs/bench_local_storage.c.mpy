{
  "module_name": "bench_local_storage.c",
  "hash_id": "be4520475076b080fc408d97d604ca9dc227165a0f121667e2ab69a565f9ee88",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_local_storage.c",
  "human_readable_source": "\n \n\n#include <argp.h>\n#include <linux/btf.h>\n\n#include \"local_storage_bench.skel.h\"\n#include \"bench.h\"\n\n#include <test_btf.h>\n\nstatic struct {\n\t__u32 nr_maps;\n\t__u32 hashmap_nr_keys_used;\n} args = {\n\t.nr_maps = 1000,\n\t.hashmap_nr_keys_used = 1000,\n};\n\nenum {\n\tARG_NR_MAPS = 6000,\n\tARG_HASHMAP_NR_KEYS_USED = 6001,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"nr_maps\", ARG_NR_MAPS, \"NR_MAPS\", 0,\n\t\t\"Set number of local_storage maps\"},\n\t{ \"hashmap_nr_keys_used\", ARG_HASHMAP_NR_KEYS_USED, \"NR_KEYS\",\n\t\t0, \"When doing hashmap test, set number of hashmap keys test uses\"},\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tlong ret;\n\n\tswitch (key) {\n\tcase ARG_NR_MAPS:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid nr_maps\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_maps = ret;\n\t\tbreak;\n\tcase ARG_HASHMAP_NR_KEYS_USED:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"invalid hashmap_nr_keys_used\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.hashmap_nr_keys_used = ret;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nconst struct argp bench_local_storage_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\n \n#define MAX_NR_MAPS 1000\n \n#define HASHMAP_SZ 4194304\n\nstatic void validate(void)\n{\n\tif (env.producer_cnt != 1) {\n\t\tfprintf(stderr, \"benchmark doesn't support multi-producer!\\n\");\n\t\texit(1);\n\t}\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n\n\tif (args.nr_maps > MAX_NR_MAPS) {\n\t\tfprintf(stderr, \"nr_maps must be <= 1000\\n\");\n\t\texit(1);\n\t}\n\n\tif (args.hashmap_nr_keys_used > HASHMAP_SZ) {\n\t\tfprintf(stderr, \"hashmap_nr_keys_used must be <= %u\\n\", HASHMAP_SZ);\n\t\texit(1);\n\t}\n}\n\nstatic struct {\n\tstruct local_storage_bench *skel;\n\tvoid *bpf_obj;\n\tstruct bpf_map *array_of_maps;\n} ctx;\n\nstatic void prepopulate_hashmap(int fd)\n{\n\tint i, key, val;\n\n\t \n\tfor (i = 0; i < HASHMAP_SZ; i++) {\n\t\tkey = val = i;\n\t\tif (bpf_map_update_elem(fd, &key, &val, 0)) {\n\t\t\tfprintf(stderr, \"Error prepopulating hashmap (key %d)\\n\", key);\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic void __setup(struct bpf_program *prog, bool hashmap)\n{\n\tstruct bpf_map *inner_map;\n\tint i, fd, mim_fd, err;\n\n\tLIBBPF_OPTS(bpf_map_create_opts, create_opts);\n\n\tif (!hashmap)\n\t\tcreate_opts.map_flags = BPF_F_NO_PREALLOC;\n\n\tctx.skel->rodata->num_maps = args.nr_maps;\n\tctx.skel->rodata->hashmap_num_keys = args.hashmap_nr_keys_used;\n\tinner_map = bpf_map__inner_map(ctx.array_of_maps);\n\tcreate_opts.btf_key_type_id = bpf_map__btf_key_type_id(inner_map);\n\tcreate_opts.btf_value_type_id = bpf_map__btf_value_type_id(inner_map);\n\n\terr = local_storage_bench__load(ctx.skel);\n\tif (err) {\n\t\tfprintf(stderr, \"Error loading skeleton\\n\");\n\t\tgoto err_out;\n\t}\n\n\tcreate_opts.btf_fd = bpf_object__btf_fd(ctx.skel->obj);\n\n\tmim_fd = bpf_map__fd(ctx.array_of_maps);\n\tif (mim_fd < 0) {\n\t\tfprintf(stderr, \"Error getting map_in_map fd\\n\");\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 0; i < args.nr_maps; i++) {\n\t\tif (hashmap)\n\t\t\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(int),\n\t\t\t\t\t    sizeof(int), HASHMAP_SZ, &create_opts);\n\t\telse\n\t\t\tfd = bpf_map_create(BPF_MAP_TYPE_TASK_STORAGE, NULL, sizeof(int),\n\t\t\t\t\t    sizeof(int), 0, &create_opts);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"Error creating map %d: %d\\n\", i, fd);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (hashmap)\n\t\t\tprepopulate_hashmap(fd);\n\n\t\terr = bpf_map_update_elem(mim_fd, &i, &fd, 0);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"Error updating array-of-maps w/ map %d\\n\", i);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (!bpf_program__attach(prog)) {\n\t\tfprintf(stderr, \"Error attaching bpf program\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn;\nerr_out:\n\texit(1);\n}\n\nstatic void hashmap_setup(void)\n{\n\tstruct local_storage_bench *skel;\n\n\tsetup_libbpf();\n\n\tskel = local_storage_bench__open();\n\tctx.skel = skel;\n\tctx.array_of_maps = skel->maps.array_of_hash_maps;\n\tskel->rodata->use_hashmap = 1;\n\tskel->rodata->interleave = 0;\n\n\t__setup(skel->progs.get_local, true);\n}\n\nstatic void local_storage_cache_get_setup(void)\n{\n\tstruct local_storage_bench *skel;\n\n\tsetup_libbpf();\n\n\tskel = local_storage_bench__open();\n\tctx.skel = skel;\n\tctx.array_of_maps = skel->maps.array_of_local_storage_maps;\n\tskel->rodata->use_hashmap = 0;\n\tskel->rodata->interleave = 0;\n\n\t__setup(skel->progs.get_local, false);\n}\n\nstatic void local_storage_cache_get_interleaved_setup(void)\n{\n\tstruct local_storage_bench *skel;\n\n\tsetup_libbpf();\n\n\tskel = local_storage_bench__open();\n\tctx.skel = skel;\n\tctx.array_of_maps = skel->maps.array_of_local_storage_maps;\n\tskel->rodata->use_hashmap = 0;\n\tskel->rodata->interleave = 1;\n\n\t__setup(skel->progs.get_local, false);\n}\n\nstatic void measure(struct bench_res *res)\n{\n\tres->hits = atomic_swap(&ctx.skel->bss->hits, 0);\n\tres->important_hits = atomic_swap(&ctx.skel->bss->important_hits, 0);\n}\n\nstatic inline void trigger_bpf_program(void)\n{\n\tsyscall(__NR_getpgid);\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true)\n\t\ttrigger_bpf_program();\n\n\treturn NULL;\n}\n\n \nconst struct bench bench_local_storage_cache_seq_get = {\n\t.name = \"local-storage-cache-seq-get\",\n\t.argp = &bench_local_storage_argp,\n\t.validate = validate,\n\t.setup = local_storage_cache_get_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = local_storage_report_progress,\n\t.report_final = local_storage_report_final,\n};\n\nconst struct bench bench_local_storage_cache_interleaved_get = {\n\t.name = \"local-storage-cache-int-get\",\n\t.argp = &bench_local_storage_argp,\n\t.validate = validate,\n\t.setup = local_storage_cache_get_interleaved_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = local_storage_report_progress,\n\t.report_final = local_storage_report_final,\n};\n\nconst struct bench bench_local_storage_cache_hashmap_control = {\n\t.name = \"local-storage-cache-hashmap-control\",\n\t.argp = &bench_local_storage_argp,\n\t.validate = validate,\n\t.setup = hashmap_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = local_storage_report_progress,\n\t.report_final = local_storage_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}