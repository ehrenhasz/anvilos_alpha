{
  "module_name": "bench_bpf_loop.c",
  "hash_id": "dadc72a5ab900cc0e7034f771b20e960bb2ff69363117669884a95bbf457abc5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_bpf_loop.c",
  "human_readable_source": "\n \n\n#include <argp.h>\n#include \"bench.h\"\n#include \"bpf_loop_bench.skel.h\"\n\n \nstatic struct ctx {\n\tstruct bpf_loop_bench *skel;\n} ctx;\n\nstatic struct {\n\t__u32 nr_loops;\n} args = {\n\t.nr_loops = 10,\n};\n\nenum {\n\tARG_NR_LOOPS = 4000,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"nr_loops\", ARG_NR_LOOPS, \"nr_loops\", 0,\n\t\t\"Set number of loops for the bpf_loop helper\"},\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tswitch (key) {\n\tcase ARG_NR_LOOPS:\n\t\targs.nr_loops = strtol(arg, NULL, 10);\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\n \nconst struct argp bench_bpf_loop_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\nstatic void validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr, \"benchmark doesn't support consumer!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true)\n\t\t \n\t\tsyscall(__NR_getpgid);\n\n\treturn NULL;\n}\n\nstatic void measure(struct bench_res *res)\n{\n\tres->hits = atomic_swap(&ctx.skel->bss->hits, 0);\n}\n\nstatic void setup(void)\n{\n\tstruct bpf_link *link;\n\n\tsetup_libbpf();\n\n\tctx.skel = bpf_loop_bench__open_and_load();\n\tif (!ctx.skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\texit(1);\n\t}\n\n\tlink = bpf_program__attach(ctx.skel->progs.benchmark);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n\n\tctx.skel->bss->nr_loops = args.nr_loops;\n}\n\nconst struct bench bench_bpf_loop = {\n\t.name = \"bpf-loop\",\n\t.argp = &bench_bpf_loop_argp,\n\t.validate = validate,\n\t.setup = setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = ops_report_progress,\n\t.report_final = ops_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}