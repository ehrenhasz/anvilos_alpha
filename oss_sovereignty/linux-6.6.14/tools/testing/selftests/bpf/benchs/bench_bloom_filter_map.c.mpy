{
  "module_name": "bench_bloom_filter_map.c",
  "hash_id": "d76a75f7645eaf49cc2d0f9cb07a9faf9e9f3dc37c9faa56376001d10d22e5eb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/benchs/bench_bloom_filter_map.c",
  "human_readable_source": "\n \n\n#include <argp.h>\n#include <linux/log2.h>\n#include <pthread.h>\n#include \"bench.h\"\n#include \"bloom_filter_bench.skel.h\"\n#include \"bpf_util.h\"\n\nstatic struct ctx {\n\tbool use_array_map;\n\tbool use_hashmap;\n\tbool hashmap_use_bloom;\n\tbool count_false_hits;\n\n\tstruct bloom_filter_bench *skel;\n\n\tint bloom_fd;\n\tint hashmap_fd;\n\tint array_map_fd;\n\n\tpthread_mutex_t map_done_mtx;\n\tpthread_cond_t map_done_cv;\n\tbool map_done;\n\tbool map_prepare_err;\n\n\t__u32 next_map_idx;\n} ctx = {\n\t.map_done_mtx = PTHREAD_MUTEX_INITIALIZER,\n\t.map_done_cv = PTHREAD_COND_INITIALIZER,\n};\n\nstruct stat {\n\t__u32 stats[3];\n};\n\nstatic struct {\n\t__u32 nr_entries;\n\t__u8 nr_hash_funcs;\n\t__u8 value_size;\n} args = {\n\t.nr_entries = 1000,\n\t.nr_hash_funcs = 3,\n\t.value_size = 8,\n};\n\nenum {\n\tARG_NR_ENTRIES = 3000,\n\tARG_NR_HASH_FUNCS = 3001,\n\tARG_VALUE_SIZE = 3002,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"nr_entries\", ARG_NR_ENTRIES, \"NR_ENTRIES\", 0,\n\t\t\"Set number of expected unique entries in the bloom filter\"},\n\t{ \"nr_hash_funcs\", ARG_NR_HASH_FUNCS, \"NR_HASH_FUNCS\", 0,\n\t\t\"Set number of hash functions in the bloom filter\"},\n\t{ \"value_size\", ARG_VALUE_SIZE, \"VALUE_SIZE\", 0,\n\t\t\"Set value size (in bytes) of bloom filter entries\"},\n\t{},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tlong ret;\n\n\tswitch (key) {\n\tcase ARG_NR_ENTRIES:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > UINT_MAX) {\n\t\t\tfprintf(stderr, \"Invalid nr_entries count.\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_entries = ret;\n\t\tbreak;\n\tcase ARG_NR_HASH_FUNCS:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 1 || ret > 15) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"The bloom filter must use 1 to 15 hash functions.\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.nr_hash_funcs = ret;\n\t\tbreak;\n\tcase ARG_VALUE_SIZE:\n\t\tret = strtol(arg, NULL, 10);\n\t\tif (ret < 2 || ret > 256) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid value size. Must be between 2 and 256 bytes\");\n\t\t\targp_usage(state);\n\t\t}\n\t\targs.value_size = ret;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\n \nconst struct argp bench_bloom_map_argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n};\n\nstatic void validate(void)\n{\n\tif (env.consumer_cnt != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"The bloom filter benchmarks do not support consumer\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic inline void trigger_bpf_program(void)\n{\n\tsyscall(__NR_getpgid);\n}\n\nstatic void *producer(void *input)\n{\n\twhile (true)\n\t\ttrigger_bpf_program();\n\n\treturn NULL;\n}\n\nstatic void *map_prepare_thread(void *arg)\n{\n\t__u32 val_size, i;\n\tvoid *val = NULL;\n\tint err;\n\n\tval_size = args.value_size;\n\tval = malloc(val_size);\n\tif (!val) {\n\t\tctx.map_prepare_err = true;\n\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\ti = __atomic_add_fetch(&ctx.next_map_idx, 1, __ATOMIC_RELAXED);\n\t\tif (i > args.nr_entries)\n\t\t\tbreak;\n\nagain:\n\t\t \n\t\terr = syscall(__NR_getrandom, val, val_size, 0);\n\t\tif (err != val_size) {\n\t\t\tctx.map_prepare_err = true;\n\t\t\tfprintf(stderr, \"failed to get random value: %d\\n\", -errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx.use_hashmap) {\n\t\t\terr = bpf_map_update_elem(ctx.hashmap_fd, val, val, BPF_NOEXIST);\n\t\t\tif (err) {\n\t\t\t\tif (err != -EEXIST) {\n\t\t\t\t\tctx.map_prepare_err = true;\n\t\t\t\t\tfprintf(stderr, \"failed to add elem to hashmap: %d\\n\",\n\t\t\t\t\t\t-errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\ti--;\n\n\t\tif (ctx.use_array_map) {\n\t\t\terr = bpf_map_update_elem(ctx.array_map_fd, &i, val, 0);\n\t\t\tif (err) {\n\t\t\t\tctx.map_prepare_err = true;\n\t\t\t\tfprintf(stderr, \"failed to add elem to array map: %d\\n\", -errno);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.use_hashmap && !ctx.hashmap_use_bloom)\n\t\t\tcontinue;\n\n\t\terr = bpf_map_update_elem(ctx.bloom_fd, NULL, val, 0);\n\t\tif (err) {\n\t\t\tctx.map_prepare_err = true;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"failed to add elem to bloom filter map: %d\\n\", -errno);\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tpthread_mutex_lock(&ctx.map_done_mtx);\n\tctx.map_done = true;\n\tpthread_cond_signal(&ctx.map_done_cv);\n\tpthread_mutex_unlock(&ctx.map_done_mtx);\n\n\tif (val)\n\t\tfree(val);\n\n\treturn NULL;\n}\n\nstatic void populate_maps(void)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tpthread_t map_thread;\n\tint i, err, nr_rand_bytes;\n\n\tctx.bloom_fd = bpf_map__fd(ctx.skel->maps.bloom_map);\n\tctx.hashmap_fd = bpf_map__fd(ctx.skel->maps.hashmap);\n\tctx.array_map_fd = bpf_map__fd(ctx.skel->maps.array_map);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\terr = pthread_create(&map_thread, NULL, map_prepare_thread,\n\t\t\t\t     NULL);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"failed to create pthread: %d\\n\", -errno);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpthread_mutex_lock(&ctx.map_done_mtx);\n\twhile (!ctx.map_done)\n\t\tpthread_cond_wait(&ctx.map_done_cv, &ctx.map_done_mtx);\n\tpthread_mutex_unlock(&ctx.map_done_mtx);\n\n\tif (ctx.map_prepare_err)\n\t\texit(1);\n\n\tnr_rand_bytes = syscall(__NR_getrandom, ctx.skel->bss->rand_vals,\n\t\t\t\tctx.skel->rodata->nr_rand_bytes, 0);\n\tif (nr_rand_bytes != ctx.skel->rodata->nr_rand_bytes) {\n\t\tfprintf(stderr, \"failed to get random bytes\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void check_args(void)\n{\n\tif (args.value_size < 8)  {\n\t\t__u64 nr_unique_entries = 1ULL << (args.value_size * 8);\n\n\t\tif (args.nr_entries > nr_unique_entries) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Not enough unique values for the nr_entries requested\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic struct bloom_filter_bench *setup_skeleton(void)\n{\n\tstruct bloom_filter_bench *skel;\n\n\tcheck_args();\n\n\tsetup_libbpf();\n\n\tskel = bloom_filter_bench__open();\n\tif (!skel) {\n\t\tfprintf(stderr, \"failed to open skeleton\\n\");\n\t\texit(1);\n\t}\n\n\tskel->rodata->hashmap_use_bloom = ctx.hashmap_use_bloom;\n\tskel->rodata->count_false_hits = ctx.count_false_hits;\n\n\t \n\tbpf_map__set_max_entries(skel->maps.hashmap, args.nr_entries);\n\n\tbpf_map__set_max_entries(skel->maps.array_map, args.nr_entries);\n\n\tbpf_map__set_max_entries(skel->maps.bloom_map, args.nr_entries);\n\n\t \n\tbpf_map__set_value_size(skel->maps.array_map, args.value_size);\n\n\tbpf_map__set_value_size(skel->maps.bloom_map, args.value_size);\n\n\tbpf_map__set_value_size(skel->maps.hashmap, args.value_size);\n\n\t \n\tbpf_map__set_key_size(skel->maps.hashmap, args.value_size);\n\n\tskel->bss->value_size = args.value_size;\n\n\t \n\tbpf_map__set_map_extra(skel->maps.bloom_map, args.nr_hash_funcs);\n\n\tif (bloom_filter_bench__load(skel)) {\n\t\tfprintf(stderr, \"failed to load skeleton\\n\");\n\t\texit(1);\n\t}\n\n\treturn skel;\n}\n\nstatic void bloom_lookup_setup(void)\n{\n\tstruct bpf_link *link;\n\n\tctx.use_array_map = true;\n\n\tctx.skel = setup_skeleton();\n\n\tpopulate_maps();\n\n\tlink = bpf_program__attach(ctx.skel->progs.bloom_lookup);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void bloom_update_setup(void)\n{\n\tstruct bpf_link *link;\n\n\tctx.use_array_map = true;\n\n\tctx.skel = setup_skeleton();\n\n\tpopulate_maps();\n\n\tlink = bpf_program__attach(ctx.skel->progs.bloom_update);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void false_positive_setup(void)\n{\n\tstruct bpf_link *link;\n\n\tctx.use_hashmap = true;\n\tctx.hashmap_use_bloom = true;\n\tctx.count_false_hits = true;\n\n\tctx.skel = setup_skeleton();\n\n\tpopulate_maps();\n\n\tlink = bpf_program__attach(ctx.skel->progs.bloom_hashmap_lookup);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void hashmap_with_bloom_setup(void)\n{\n\tstruct bpf_link *link;\n\n\tctx.use_hashmap = true;\n\tctx.hashmap_use_bloom = true;\n\n\tctx.skel = setup_skeleton();\n\n\tpopulate_maps();\n\n\tlink = bpf_program__attach(ctx.skel->progs.bloom_hashmap_lookup);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void hashmap_no_bloom_setup(void)\n{\n\tstruct bpf_link *link;\n\n\tctx.use_hashmap = true;\n\n\tctx.skel = setup_skeleton();\n\n\tpopulate_maps();\n\n\tlink = bpf_program__attach(ctx.skel->progs.bloom_hashmap_lookup);\n\tif (!link) {\n\t\tfprintf(stderr, \"failed to attach program!\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void measure(struct bench_res *res)\n{\n\tunsigned long total_hits = 0, total_drops = 0, total_false_hits = 0;\n\tstatic unsigned long last_hits, last_drops, last_false_hits;\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tint hit_key, drop_key, false_hit_key;\n\tint i;\n\n\thit_key = ctx.skel->rodata->hit_key;\n\tdrop_key = ctx.skel->rodata->drop_key;\n\tfalse_hit_key = ctx.skel->rodata->false_hit_key;\n\n\tif (ctx.skel->bss->error != 0) {\n\t\tfprintf(stderr, \"error (%d) when searching the bloom filter\\n\",\n\t\t\tctx.skel->bss->error);\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct stat *s = (void *)&ctx.skel->bss->percpu_stats[i];\n\n\t\ttotal_hits += s->stats[hit_key];\n\t\ttotal_drops += s->stats[drop_key];\n\t\ttotal_false_hits += s->stats[false_hit_key];\n\t}\n\n\tres->hits = total_hits - last_hits;\n\tres->drops = total_drops - last_drops;\n\tres->false_hits = total_false_hits - last_false_hits;\n\n\tlast_hits = total_hits;\n\tlast_drops = total_drops;\n\tlast_false_hits = total_false_hits;\n}\n\nconst struct bench bench_bloom_lookup = {\n\t.name = \"bloom-lookup\",\n\t.argp = &bench_bloom_map_argp,\n\t.validate = validate,\n\t.setup = bloom_lookup_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n\nconst struct bench bench_bloom_update = {\n\t.name = \"bloom-update\",\n\t.argp = &bench_bloom_map_argp,\n\t.validate = validate,\n\t.setup = bloom_update_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n\nconst struct bench bench_bloom_false_positive = {\n\t.name = \"bloom-false-positive\",\n\t.argp = &bench_bloom_map_argp,\n\t.validate = validate,\n\t.setup = false_positive_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = false_hits_report_progress,\n\t.report_final = false_hits_report_final,\n};\n\nconst struct bench bench_hashmap_without_bloom = {\n\t.name = \"hashmap-without-bloom\",\n\t.argp = &bench_bloom_map_argp,\n\t.validate = validate,\n\t.setup = hashmap_no_bloom_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n\nconst struct bench bench_hashmap_with_bloom = {\n\t.name = \"hashmap-with-bloom\",\n\t.argp = &bench_bloom_map_argp,\n\t.validate = validate,\n\t.setup = hashmap_with_bloom_setup,\n\t.producer_thread = producer,\n\t.measure = measure,\n\t.report_progress = hits_drops_report_progress,\n\t.report_final = hits_drops_report_final,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}