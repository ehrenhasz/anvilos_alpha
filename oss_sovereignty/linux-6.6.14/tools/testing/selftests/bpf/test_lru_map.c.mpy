{
  "module_name": "test_lru_map.c",
  "hash_id": "78bf06784635c1348f215ed46ed879850cd1802f2998fecb0506d3f25628a414",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_lru_map.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#include <sched.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include <sys/wait.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"bpf_util.h\"\n#include \"../../../include/linux/filter.h\"\n\n#define LOCAL_FREE_TARGET\t(128)\n#define PERCPU_FREE_TARGET\t(4)\n\nstatic int nr_cpus;\n\nstatic int create_map(int map_type, int map_flags, unsigned int size)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = map_flags);\n\tint map_fd;\n\n\tmap_fd = bpf_map_create(map_type, NULL,  sizeof(unsigned long long),\n\t\t\t\tsizeof(unsigned long long), size, &opts);\n\n\tif (map_fd == -1)\n\t\tperror(\"bpf_map_create\");\n\n\treturn map_fd;\n}\n\nstatic int bpf_map_lookup_elem_with_ref_bit(int fd, unsigned long long key,\n\t\t\t\t\t    void *value)\n{\n\tstruct bpf_insn insns[] = {\n\t\tBPF_LD_MAP_VALUE(BPF_REG_9, 0, 0),\n\t\tBPF_LD_MAP_FD(BPF_REG_1, fd),\n\t\tBPF_LD_IMM64(BPF_REG_3, key),\n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),\n\t\tBPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),\n\t\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 4),\n\t\tBPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0),\n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, 0),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 42),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t};\n\t__u8 data[64] = {};\n\tint mfd, pfd, ret, zero = 0;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = data,\n\t\t.data_size_in = sizeof(data),\n\t\t.repeat = 1,\n\t);\n\n\tmfd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL, sizeof(int), sizeof(__u64), 1, NULL);\n\tif (mfd < 0)\n\t\treturn -1;\n\n\tinsns[0].imm = mfd;\n\n\tpfd = bpf_prog_load(BPF_PROG_TYPE_SCHED_CLS, NULL, \"GPL\", insns, ARRAY_SIZE(insns), NULL);\n\tif (pfd < 0) {\n\t\tclose(mfd);\n\t\treturn -1;\n\t}\n\n\tret = bpf_prog_test_run_opts(pfd, &topts);\n\tif (ret < 0 || topts.retval != 42) {\n\t\tret = -1;\n\t} else {\n\t\tassert(!bpf_map_lookup_elem(mfd, &zero, value));\n\t\tret = 0;\n\t}\n\tclose(pfd);\n\tclose(mfd);\n\treturn ret;\n}\n\nstatic int map_subset(int map0, int map1)\n{\n\tunsigned long long next_key = 0;\n\tunsigned long long value0[nr_cpus], value1[nr_cpus];\n\tint ret;\n\n\twhile (!bpf_map_get_next_key(map1, &next_key, &next_key)) {\n\t\tassert(!bpf_map_lookup_elem(map1, &next_key, value1));\n\t\tret = bpf_map_lookup_elem(map0, &next_key, value0);\n\t\tif (ret) {\n\t\t\tprintf(\"key:%llu not found from map. %s(%d)\\n\",\n\t\t\t       next_key, strerror(errno), errno);\n\t\t\treturn 0;\n\t\t}\n\t\tif (value0[0] != value1[0]) {\n\t\t\tprintf(\"key:%llu value0:%llu != value1:%llu\\n\",\n\t\t\t       next_key, value0[0], value1[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int map_equal(int lru_map, int expected)\n{\n\treturn map_subset(lru_map, expected) && map_subset(expected, lru_map);\n}\n\nstatic int sched_next_online(int pid, int *next_to_try)\n{\n\tcpu_set_t cpuset;\n\tint next = *next_to_try;\n\tint ret = -1;\n\n\twhile (next < nr_cpus) {\n\t\tCPU_ZERO(&cpuset);\n\t\tCPU_SET(next++, &cpuset);\n\t\tif (!sched_setaffinity(pid, sizeof(cpuset), &cpuset)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*next_to_try = next;\n\treturn ret;\n}\n\n \nstatic void test_lru_sanity0(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tint lru_map_fd, expected_map_fd;\n\tint next_cpu = 0;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tlru_map_fd = create_map(map_type, map_flags, 2 * nr_cpus);\n\telse\n\t\tlru_map_fd = create_map(map_type, map_flags, 2);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, 2);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\n\tkey = 1;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST) == -EEXIST);\n\t \n\n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, -1) == -EINVAL);\n\n\t \n\n\t \n\tkey = 2;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_EXIST) == -ENOENT);\n\t \n\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\n\t \n\n\t \n\tkey = 3;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tkey = 1;\n\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\tassert(value[0] == 1234);\n\n\tkey = 3;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tkey = 2;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tkey = 1;\n\tassert(!bpf_map_lookup_and_delete_elem(lru_map_fd, &key, &value));\n\tassert(value[0] == 1234);\n\n\t \n\tassert(!bpf_map_delete_elem(expected_map_fd, &key));\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity1(int map_type, int map_flags, unsigned int tgt_free)\n{\n\tunsigned long long key, end_key, value[nr_cpus];\n\tint lru_map_fd, expected_map_fd;\n\tunsigned int batch_size;\n\tunsigned int map_size;\n\tint next_cpu = 0;\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\t \n\t\treturn;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tbatch_size = tgt_free / 2;\n\tassert(batch_size * 2 == tgt_free);\n\n\tmap_size = tgt_free + batch_size;\n\tlru_map_fd = create_map(map_type, map_flags, map_size);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, map_size);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\tend_key = 1 + tgt_free;\n\tfor (key = 1; key < end_key; key++)\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tend_key = 1 + batch_size;\n\tfor (key = 1; key < end_key; key++) {\n\t\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\t \n\tkey = 1 + tgt_free;\n\tend_key = key + tgt_free;\n\tfor (; key < end_key; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity2(int map_type, int map_flags, unsigned int tgt_free)\n{\n\tunsigned long long key, value[nr_cpus];\n\tunsigned long long end_key;\n\tint lru_map_fd, expected_map_fd;\n\tunsigned int batch_size;\n\tunsigned int map_size;\n\tint next_cpu = 0;\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\t \n\t\treturn;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tbatch_size = tgt_free / 2;\n\tassert(batch_size * 2 == tgt_free);\n\n\tmap_size = tgt_free + batch_size;\n\tlru_map_fd = create_map(map_type, map_flags, map_size);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, map_size);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\tend_key = 1 + tgt_free;\n\tfor (key = 1; key < end_key; key++)\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tkey = 1;\n\tif (map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_delete_elem(lru_map_fd, &key));\n\t} else {\n\t\tassert(bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t   BPF_EXIST));\n\t}\n\n\t \n\tend_key = 1 + batch_size;\n\tvalue[0] = 4321;\n\tfor (key = 1; key < end_key; key++) {\n\t\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\t\tassert(value[0] == 4321);\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tvalue[0] = 1234;\n\n\t \n\tend_key = 1 + tgt_free + batch_size;\n\tfor (key = 1 + tgt_free; key < end_key; key++)\n\t\t \n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tend_key = key + tgt_free;\n\tfor (; key < end_key; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity3(int map_type, int map_flags, unsigned int tgt_free)\n{\n\tunsigned long long key, end_key, value[nr_cpus];\n\tint lru_map_fd, expected_map_fd;\n\tunsigned int batch_size;\n\tunsigned int map_size;\n\tint next_cpu = 0;\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\t \n\t\treturn;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tbatch_size = tgt_free / 2;\n\tassert(batch_size * 2 == tgt_free);\n\n\tmap_size = tgt_free * 2;\n\tlru_map_fd = create_map(map_type, map_flags, map_size);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, map_size);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\tend_key = 1 + (2 * tgt_free);\n\tfor (key = 1; key < end_key; key++)\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tend_key = tgt_free + batch_size;\n\tfor (key = 1; key < end_key; key++) {\n\t\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\t \n\tkey = 2 * tgt_free + 1;\n\tend_key = key + batch_size;\n\tfor (; key < end_key; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity4(int map_type, int map_flags, unsigned int tgt_free)\n{\n\tint lru_map_fd, expected_map_fd;\n\tunsigned long long key, value[nr_cpus];\n\tunsigned long long end_key;\n\tint next_cpu = 0;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tlru_map_fd = create_map(map_type, map_flags,\n\t\t\t\t\t3 * tgt_free * nr_cpus);\n\telse\n\t\tlru_map_fd = create_map(map_type, map_flags, 3 * tgt_free);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0,\n\t\t\t\t     3 * tgt_free);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\tfor (key = 1; key <= 2 * tgt_free; key++)\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\n\tkey = 1;\n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\n\tfor (key = 1; key <= tgt_free; key++) {\n\t\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tfor (; key <= 2 * tgt_free; key++) {\n\t\tassert(!bpf_map_delete_elem(lru_map_fd, &key));\n\t\tassert(bpf_map_delete_elem(lru_map_fd, &key));\n\t}\n\n\tend_key = key + 2 * tgt_free;\n\tfor (; key < end_key; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\nstatic void do_test_lru_sanity5(unsigned long long last_key, int map_fd)\n{\n\tunsigned long long key, value[nr_cpus];\n\n\t \n\tassert(!bpf_map_lookup_elem_with_ref_bit(map_fd, last_key, value));\n\tvalue[0] = 1234;\n\n\tkey = last_key + 1;\n\tassert(!bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_lookup_elem_with_ref_bit(map_fd, key, value));\n\n\t \n\tassert(bpf_map_lookup_elem(map_fd, &last_key, value) == -ENOENT);\n}\n\n \nstatic void test_lru_sanity5(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tint next_cpu = 0;\n\tint map_fd;\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\treturn;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tmap_fd = create_map(map_type, map_flags, 1);\n\tassert(map_fd != -1);\n\n\tvalue[0] = 1234;\n\tkey = 0;\n\tassert(!bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST));\n\n\twhile (sched_next_online(0, &next_cpu) != -1) {\n\t\tpid_t pid;\n\n\t\tpid = fork();\n\t\tif (pid == 0) {\n\t\t\tdo_test_lru_sanity5(key, map_fd);\n\t\t\texit(0);\n\t\t} else if (pid == -1) {\n\t\t\tprintf(\"couldn't spawn process to test key:%llu\\n\",\n\t\t\t       key);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tint status;\n\n\t\t\tassert(waitpid(pid, &status, 0) == pid);\n\t\t\tassert(status == 0);\n\t\t\tkey++;\n\t\t}\n\t}\n\n\tclose(map_fd);\n\t \n\tassert(key > 0);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity6(int map_type, int map_flags, int tgt_free)\n{\n\tint lru_map_fd, expected_map_fd;\n\tunsigned long long key, value[nr_cpus];\n\tunsigned int map_size = tgt_free * 2;\n\tint next_cpu = 0;\n\n\tif (!(map_flags & BPF_F_NO_COMMON_LRU))\n\t\treturn;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, map_size);\n\tassert(expected_map_fd != -1);\n\n\tlru_map_fd = create_map(map_type, map_flags, map_size * nr_cpus);\n\tassert(lru_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\tfor (key = 1; key <= tgt_free; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tfor (; key <= tgt_free * 2; key++) {\n\t\tunsigned long long stable_key;\n\n\t\t \n\t\tfor (stable_key = 1; stable_key <= tgt_free; stable_key++) {\n\t\t\t \n\t\t\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd,\n\t\t\t\t\t\t\t\t stable_key, value));\n\t\t}\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tfor (; key <= tgt_free * 3; key++) {\n\t\tassert(!bpf_map_update_elem(lru_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t\t    BPF_NOEXIST));\n\t}\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity7(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tint lru_map_fd, expected_map_fd;\n\tint next_cpu = 0;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tlru_map_fd = create_map(map_type, map_flags, 2 * nr_cpus);\n\telse\n\t\tlru_map_fd = create_map(map_type, map_flags, 2);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, 2);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\n\tkey = 1;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST) == -EEXIST);\n\t \n\n\t \n\n\t \n\tkey = 2;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_EXIST) == -ENOENT);\n\t \n\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\n\t \n\n\t \n\tkey = 3;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tkey = 1;\n\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\tassert(value[0] == 1234);\n\n\t \n\tkey = 2;\n\tassert(!bpf_map_lookup_elem(lru_map_fd, &key, value));\n\tassert(value[0] == 1234);\n\n\tkey = 3;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tkey = 2;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\n \nstatic void test_lru_sanity8(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tint lru_map_fd, expected_map_fd;\n\tint next_cpu = 0;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, &next_cpu) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tlru_map_fd = create_map(map_type, map_flags, 2 * nr_cpus);\n\telse\n\t\tlru_map_fd = create_map(map_type, map_flags, 2);\n\tassert(lru_map_fd != -1);\n\n\texpected_map_fd = create_map(BPF_MAP_TYPE_HASH, 0, 2);\n\tassert(expected_map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\t \n\n\tkey = 1;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST) == -EEXIST);\n\t \n\n\t \n\n\t \n\tkey = 2;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(lru_map_fd, &key, value, BPF_EXIST) == -ENOENT);\n\t \n\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\n\t \n\tkey = 3;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\t \n\tkey = 1;\n\tassert(!bpf_map_lookup_elem(lru_map_fd, &key, value));\n\tassert(value[0] == 1234);\n\n\t \n\tkey = 2;\n\tassert(!bpf_map_lookup_elem_with_ref_bit(lru_map_fd, key, value));\n\tassert(value[0] == 1234);\n\n\tkey = 3;\n\tassert(!bpf_map_update_elem(lru_map_fd, &key, value, BPF_NOEXIST));\n\tassert(!bpf_map_update_elem(expected_map_fd, &key, value,\n\t\t\t\t    BPF_NOEXIST));\n\n\t \n\tkey = 1;\n\tassert(bpf_map_lookup_elem(lru_map_fd, &key, value) == -ENOENT);\n\n\tassert(map_equal(lru_map_fd, expected_map_fd));\n\n\tclose(expected_map_fd);\n\tclose(lru_map_fd);\n\n\tprintf(\"Pass\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tint map_types[] = {BPF_MAP_TYPE_LRU_HASH,\n\t\t\t     BPF_MAP_TYPE_LRU_PERCPU_HASH};\n\tint map_flags[] = {0, BPF_F_NO_COMMON_LRU};\n\tint t, f;\n\n\tsetbuf(stdout, NULL);\n\n\tnr_cpus = bpf_num_possible_cpus();\n\tassert(nr_cpus != -1);\n\tprintf(\"nr_cpus:%d\\n\\n\", nr_cpus);\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tfor (f = 0; f < ARRAY_SIZE(map_flags); f++) {\n\t\tunsigned int tgt_free = (map_flags[f] & BPF_F_NO_COMMON_LRU) ?\n\t\t\tPERCPU_FREE_TARGET : LOCAL_FREE_TARGET;\n\n\t\tfor (t = 0; t < ARRAY_SIZE(map_types); t++) {\n\t\t\ttest_lru_sanity0(map_types[t], map_flags[f]);\n\t\t\ttest_lru_sanity1(map_types[t], map_flags[f], tgt_free);\n\t\t\ttest_lru_sanity2(map_types[t], map_flags[f], tgt_free);\n\t\t\ttest_lru_sanity3(map_types[t], map_flags[f], tgt_free);\n\t\t\ttest_lru_sanity4(map_types[t], map_flags[f], tgt_free);\n\t\t\ttest_lru_sanity5(map_types[t], map_flags[f]);\n\t\t\ttest_lru_sanity6(map_types[t], map_flags[f], tgt_free);\n\t\t\ttest_lru_sanity7(map_types[t], map_flags[f]);\n\t\t\ttest_lru_sanity8(map_types[t], map_flags[f]);\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}