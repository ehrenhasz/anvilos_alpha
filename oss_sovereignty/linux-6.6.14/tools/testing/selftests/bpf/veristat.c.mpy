{
  "module_name": "veristat.c",
  "hash_id": "b151c1903ca0652ec1af083e99713483ace56b2dc05e88cb5fb439333979815e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/veristat.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <argp.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sched.h>\n#include <pthread.h>\n#include <dirent.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/sysinfo.h>\n#include <sys/stat.h>\n#include <bpf/libbpf.h>\n#include <bpf/btf.h>\n#include <libelf.h>\n#include <gelf.h>\n#include <float.h>\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n#endif\n\nenum stat_id {\n\tVERDICT,\n\tDURATION,\n\tTOTAL_INSNS,\n\tTOTAL_STATES,\n\tPEAK_STATES,\n\tMAX_STATES_PER_INSN,\n\tMARK_READ_MAX_LEN,\n\n\tFILE_NAME,\n\tPROG_NAME,\n\n\tALL_STATS_CNT,\n\tNUM_STATS_CNT = FILE_NAME - VERDICT,\n};\n\n \nenum stat_variant {\n\tVARIANT_A,\n\tVARIANT_B,\n\tVARIANT_DIFF,\n\tVARIANT_PCT,\n};\n\nstruct verif_stats {\n\tchar *file_name;\n\tchar *prog_name;\n\n\tlong stats[NUM_STATS_CNT];\n};\n\n \nstruct verif_stats_join {\n\tchar *file_name;\n\tchar *prog_name;\n\n\tconst struct verif_stats *stats_a;\n\tconst struct verif_stats *stats_b;\n};\n\nstruct stat_specs {\n\tint spec_cnt;\n\tenum stat_id ids[ALL_STATS_CNT];\n\tenum stat_variant variants[ALL_STATS_CNT];\n\tbool asc[ALL_STATS_CNT];\n\tint lens[ALL_STATS_CNT * 3];  \n};\n\nenum resfmt {\n\tRESFMT_TABLE,\n\tRESFMT_TABLE_CALCLEN,  \n\tRESFMT_CSV,\n};\n\nenum filter_kind {\n\tFILTER_NAME,\n\tFILTER_STAT,\n};\n\nenum operator_kind {\n\tOP_EQ,\t\t \n\tOP_NEQ,\t\t \n\tOP_LT,\t\t \n\tOP_LE,\t\t \n\tOP_GT,\t\t \n\tOP_GE,\t\t \n};\n\nstruct filter {\n\tenum filter_kind kind;\n\t \n\tchar *any_glob;\n\tchar *file_glob;\n\tchar *prog_glob;\n\t \n\tenum operator_kind op;\n\tint stat_id;\n\tenum stat_variant stat_var;\n\tlong value;\n};\n\nstatic struct env {\n\tchar **filenames;\n\tint filename_cnt;\n\tbool verbose;\n\tbool debug;\n\tbool quiet;\n\tbool force_checkpoints;\n\tenum resfmt out_fmt;\n\tbool show_version;\n\tbool comparison_mode;\n\tbool replay_mode;\n\n\tint log_level;\n\tint log_size;\n\tbool log_fixed;\n\n\tstruct verif_stats *prog_stats;\n\tint prog_stat_cnt;\n\n\t \n\tstruct verif_stats *baseline_stats;\n\tint baseline_stat_cnt;\n\n\tstruct verif_stats_join *join_stats;\n\tint join_stat_cnt;\n\n\tstruct stat_specs output_spec;\n\tstruct stat_specs sort_spec;\n\n\tstruct filter *allow_filters;\n\tstruct filter *deny_filters;\n\tint allow_filter_cnt;\n\tint deny_filter_cnt;\n\n\tint files_processed;\n\tint files_skipped;\n\tint progs_processed;\n\tint progs_skipped;\n} env;\n\nstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\n{\n\tif (!env.verbose)\n\t\treturn 0;\n\tif (level == LIBBPF_DEBUG  && !env.debug)\n\t\treturn 0;\n\treturn vfprintf(stderr, format, args);\n}\n\n#ifndef VERISTAT_VERSION\n#define VERISTAT_VERSION \"<kernel>\"\n#endif\n\nconst char *argp_program_version = \"veristat v\" VERISTAT_VERSION;\nconst char *argp_program_bug_address = \"<bpf@vger.kernel.org>\";\nconst char argp_program_doc[] =\n\"veristat    BPF verifier stats collection and comparison tool.\\n\"\n\"\\n\"\n\"USAGE: veristat <obj-file> [<obj-file>...]\\n\"\n\"   OR: veristat -C <baseline.csv> <comparison.csv>\\n\"\n\"   OR: veristat -R <results.csv>\\n\";\n\nenum {\n\tOPT_LOG_FIXED = 1000,\n\tOPT_LOG_SIZE = 1001,\n};\n\nstatic const struct argp_option opts[] = {\n\t{ NULL, 'h', NULL, OPTION_HIDDEN, \"Show the full help\" },\n\t{ \"version\", 'V', NULL, 0, \"Print version\" },\n\t{ \"verbose\", 'v', NULL, 0, \"Verbose mode\" },\n\t{ \"debug\", 'd', NULL, 0, \"Debug mode (turns on libbpf debug logging)\" },\n\t{ \"log-level\", 'l', \"LEVEL\", 0, \"Verifier log level (default 0 for normal mode, 1 for verbose mode)\" },\n\t{ \"log-fixed\", OPT_LOG_FIXED, NULL, 0, \"Disable verifier log rotation\" },\n\t{ \"log-size\", OPT_LOG_SIZE, \"BYTES\", 0, \"Customize verifier log size (default to 16MB)\" },\n\t{ \"test-states\", 't', NULL, 0,\n\t  \"Force frequent BPF verifier state checkpointing (set BPF_F_TEST_STATE_FREQ program flag)\" },\n\t{ \"quiet\", 'q', NULL, 0, \"Quiet mode\" },\n\t{ \"emit\", 'e', \"SPEC\", 0, \"Specify stats to be emitted\" },\n\t{ \"sort\", 's', \"SPEC\", 0, \"Specify sort order\" },\n\t{ \"output-format\", 'o', \"FMT\", 0, \"Result output format (table, csv), default is table.\" },\n\t{ \"compare\", 'C', NULL, 0, \"Comparison mode\" },\n\t{ \"replay\", 'R', NULL, 0, \"Replay mode\" },\n\t{ \"filter\", 'f', \"FILTER\", 0, \"Filter expressions (or @filename for file with expressions).\" },\n\t{},\n};\n\nstatic int parse_stats(const char *stats_str, struct stat_specs *specs);\nstatic int append_filter(struct filter **filters, int *cnt, const char *str);\nstatic int append_filter_file(const char *path);\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tvoid *tmp;\n\tint err;\n\n\tswitch (key) {\n\tcase 'h':\n\t\targp_state_help(state, stderr, ARGP_HELP_STD_HELP);\n\t\tbreak;\n\tcase 'V':\n\t\tenv.show_version = true;\n\t\tbreak;\n\tcase 'v':\n\t\tenv.verbose = true;\n\t\tbreak;\n\tcase 'd':\n\t\tenv.debug = true;\n\t\tenv.verbose = true;\n\t\tbreak;\n\tcase 'q':\n\t\tenv.quiet = true;\n\t\tbreak;\n\tcase 'e':\n\t\terr = parse_stats(arg, &env.output_spec);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase 's':\n\t\terr = parse_stats(arg, &env.sort_spec);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase 'o':\n\t\tif (strcmp(arg, \"table\") == 0) {\n\t\t\tenv.out_fmt = RESFMT_TABLE;\n\t\t} else if (strcmp(arg, \"csv\") == 0) {\n\t\t\tenv.out_fmt = RESFMT_CSV;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unrecognized output format '%s'\\n\", arg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 'l':\n\t\terrno = 0;\n\t\tenv.log_level = strtol(arg, NULL, 10);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"invalid log level: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase OPT_LOG_FIXED:\n\t\tenv.log_fixed = true;\n\t\tbreak;\n\tcase OPT_LOG_SIZE:\n\t\terrno = 0;\n\t\tenv.log_size = strtol(arg, NULL, 10);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"invalid log size: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\tenv.force_checkpoints = true;\n\t\tbreak;\n\tcase 'C':\n\t\tenv.comparison_mode = true;\n\t\tbreak;\n\tcase 'R':\n\t\tenv.replay_mode = true;\n\t\tbreak;\n\tcase 'f':\n\t\tif (arg[0] == '@')\n\t\t\terr = append_filter_file(arg + 1);\n\t\telse if (arg[0] == '!')\n\t\t\terr = append_filter(&env.deny_filters, &env.deny_filter_cnt, arg + 1);\n\t\telse\n\t\t\terr = append_filter(&env.allow_filters, &env.allow_filter_cnt, arg);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"Failed to collect program filter expressions: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase ARGP_KEY_ARG:\n\t\ttmp = realloc(env.filenames, (env.filename_cnt + 1) * sizeof(*env.filenames));\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\tenv.filenames = tmp;\n\t\tenv.filenames[env.filename_cnt] = strdup(arg);\n\t\tif (!env.filenames[env.filename_cnt])\n\t\t\treturn -ENOMEM;\n\t\tenv.filename_cnt++;\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic const struct argp argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n\t.doc = argp_program_doc,\n};\n\n\n \nstatic bool glob_matches(const char *str, const char *pat)\n{\n\twhile (*str && *pat && *pat != '*') {\n\t\tif (*str != *pat)\n\t\t\treturn false;\n\t\tstr++;\n\t\tpat++;\n\t}\n\t \n\tif (*pat == '*') {\n\t\twhile (*pat == '*')\n\t\t\tpat++;\n\t\tif (!*pat)  \n\t\t\treturn true;\n\t\twhile (*str)\n\t\t\tif (glob_matches(str++, pat))\n\t\t\t\treturn true;\n\t}\n\treturn !*str && !*pat;\n}\n\nstatic bool is_bpf_obj_file(const char *path) {\n\tElf64_Ehdr *ehdr;\n\tint fd, err = -EINVAL;\n\tElf *elf = NULL;\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn true;  \n\n\t \n\t(void)elf_version(EV_CURRENT);\n\n\telf = elf_begin(fd, ELF_C_READ, NULL);\n\tif (!elf)\n\t\tgoto cleanup;\n\n\tif (elf_kind(elf) != ELF_K_ELF || gelf_getclass(elf) != ELFCLASS64)\n\t\tgoto cleanup;\n\n\tehdr = elf64_getehdr(elf);\n\t \n\tif (!ehdr || ehdr->e_type != ET_REL || (ehdr->e_machine && ehdr->e_machine != EM_BPF))\n\t\tgoto cleanup;\n\n\terr = 0;\ncleanup:\n\tif (elf)\n\t\telf_end(elf);\n\tclose(fd);\n\treturn err == 0;\n}\n\nstatic bool should_process_file_prog(const char *filename, const char *prog_name)\n{\n\tstruct filter *f;\n\tint i, allow_cnt = 0;\n\n\tfor (i = 0; i < env.deny_filter_cnt; i++) {\n\t\tf = &env.deny_filters[i];\n\t\tif (f->kind != FILTER_NAME)\n\t\t\tcontinue;\n\n\t\tif (f->any_glob && glob_matches(filename, f->any_glob))\n\t\t\treturn false;\n\t\tif (f->any_glob && prog_name && glob_matches(prog_name, f->any_glob))\n\t\t\treturn false;\n\t\tif (f->file_glob && glob_matches(filename, f->file_glob))\n\t\t\treturn false;\n\t\tif (f->prog_glob && prog_name && glob_matches(prog_name, f->prog_glob))\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < env.allow_filter_cnt; i++) {\n\t\tf = &env.allow_filters[i];\n\t\tif (f->kind != FILTER_NAME)\n\t\t\tcontinue;\n\n\t\tallow_cnt++;\n\t\tif (f->any_glob) {\n\t\t\tif (glob_matches(filename, f->any_glob))\n\t\t\t\treturn true;\n\t\t\t \n\t\t\tif (!prog_name || glob_matches(prog_name, f->any_glob))\n\t\t\t\treturn true;\n\t\t} else {\n\t\t\tif (f->file_glob && !glob_matches(filename, f->file_glob))\n\t\t\t\tcontinue;\n\t\t\tif (f->prog_glob && prog_name && !glob_matches(prog_name, f->prog_glob))\n\t\t\t\tcontinue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\treturn allow_cnt == 0;\n}\n\nstatic struct {\n\tenum operator_kind op_kind;\n\tconst char *op_str;\n} operators[] = {\n\t \n\t{ OP_EQ, \"==\" },\n\t{ OP_NEQ, \"!=\" },\n\t{ OP_NEQ, \"<>\" },\n\t{ OP_LE, \"<=\" },\n\t{ OP_LT, \"<\" },\n\t{ OP_GE, \">=\" },\n\t{ OP_GT, \">\" },\n\t{ OP_EQ, \"=\" },\n};\n\nstatic bool parse_stat_id_var(const char *name, size_t len, int *id, enum stat_variant *var);\n\nstatic int append_filter(struct filter **filters, int *cnt, const char *str)\n{\n\tstruct filter *f;\n\tvoid *tmp;\n\tconst char *p;\n\tint i;\n\n\ttmp = realloc(*filters, (*cnt + 1) * sizeof(**filters));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*filters = tmp;\n\n\tf = &(*filters)[*cnt];\n\tmemset(f, 0, sizeof(*f));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(operators); i++) {\n\t\tenum stat_variant var;\n\t\tint id;\n\t\tlong val;\n\t\tconst char *end = str;\n\t\tconst char *op_str;\n\n\t\top_str = operators[i].op_str;\n\t\tp = strstr(str, op_str);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tif (!parse_stat_id_var(str, p - str, &id, &var)) {\n\t\t\tfprintf(stderr, \"Unrecognized stat name in '%s'!\\n\", str);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (id >= FILE_NAME) {\n\t\t\tfprintf(stderr, \"Non-integer stat is specified in '%s'!\\n\", str);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tp += strlen(op_str);\n\n\t\tif (strcasecmp(p, \"true\") == 0 ||\n\t\t    strcasecmp(p, \"t\") == 0 ||\n\t\t    strcasecmp(p, \"success\") == 0 ||\n\t\t    strcasecmp(p, \"succ\") == 0 ||\n\t\t    strcasecmp(p, \"s\") == 0 ||\n\t\t    strcasecmp(p, \"match\") == 0 ||\n\t\t    strcasecmp(p, \"m\") == 0) {\n\t\t\tval = 1;\n\t\t} else if (strcasecmp(p, \"false\") == 0 ||\n\t\t\t   strcasecmp(p, \"f\") == 0 ||\n\t\t\t   strcasecmp(p, \"failure\") == 0 ||\n\t\t\t   strcasecmp(p, \"fail\") == 0 ||\n\t\t\t   strcasecmp(p, \"mismatch\") == 0 ||\n\t\t\t   strcasecmp(p, \"mis\") == 0) {\n\t\t\tval = 0;\n\t\t} else {\n\t\t\terrno = 0;\n\t\t\tval = strtol(p, (char **)&end, 10);\n\t\t\tif (errno || end == p || *end != '\\0' ) {\n\t\t\t\tfprintf(stderr, \"Invalid integer value in '%s'!\\n\", str);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tf->kind = FILTER_STAT;\n\t\tf->stat_id = id;\n\t\tf->stat_var = var;\n\t\tf->op = operators[i].op_kind;\n\t\tf->value = val;\n\n\t\t*cnt += 1;\n\t\treturn 0;\n\t}\n\n\t \n\tf->kind = FILTER_NAME;\n\tp = strchr(str, '/');\n\tif (!p) {\n\t\tf->any_glob = strdup(str);\n\t\tif (!f->any_glob)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (str != p) {\n\t\t\t \n\t\t\tf->file_glob = strndup(str, p - str);\n\t\t\tif (!f->file_glob)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (strlen(p + 1) > 0) {\n\t\t\t \n\t\t\tf->prog_glob = strdup(p + 1);\n\t\t\tif (!f->prog_glob) {\n\t\t\t\tfree(f->file_glob);\n\t\t\t\tf->file_glob = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\t*cnt += 1;\n\treturn 0;\n}\n\nstatic int append_filter_file(const char *path)\n{\n\tchar buf[1024];\n\tFILE *f;\n\tint err = 0;\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tfprintf(stderr, \"Failed to open filters in '%s': %d\\n\", path, err);\n\t\treturn err;\n\t}\n\n\twhile (fscanf(f, \" %1023[^\\n]\\n\", buf) == 1) {\n\t\t \n\t\tif (buf[0] == '\\0' || buf[0] == '#')\n\t\t\tcontinue;\n\t\t \n\t\tif (buf[0] == '!')\n\t\t\terr = append_filter(&env.deny_filters, &env.deny_filter_cnt, buf + 1);\n\t\telse\n\t\t\terr = append_filter(&env.allow_filters, &env.allow_filter_cnt, buf);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tfclose(f);\n\treturn err;\n}\n\nstatic const struct stat_specs default_output_spec = {\n\t.spec_cnt = 7,\n\t.ids = {\n\t\tFILE_NAME, PROG_NAME, VERDICT, DURATION,\n\t\tTOTAL_INSNS, TOTAL_STATES, PEAK_STATES,\n\t},\n};\n\nstatic const struct stat_specs default_csv_output_spec = {\n\t.spec_cnt = 9,\n\t.ids = {\n\t\tFILE_NAME, PROG_NAME, VERDICT, DURATION,\n\t\tTOTAL_INSNS, TOTAL_STATES, PEAK_STATES,\n\t\tMAX_STATES_PER_INSN, MARK_READ_MAX_LEN,\n\t},\n};\n\nstatic const struct stat_specs default_sort_spec = {\n\t.spec_cnt = 2,\n\t.ids = {\n\t\tFILE_NAME, PROG_NAME,\n\t},\n\t.asc = { true, true, },\n};\n\n \nstatic const struct stat_specs join_sort_spec = {\n\t.spec_cnt = 2,\n\t.ids = {\n\t\tFILE_NAME, PROG_NAME,\n\t},\n\t.asc = { true, true, },\n};\n\nstatic struct stat_def {\n\tconst char *header;\n\tconst char *names[4];\n\tbool asc_by_default;\n\tbool left_aligned;\n} stat_defs[] = {\n\t[FILE_NAME] = { \"File\", {\"file_name\", \"filename\", \"file\"}, true  , true   },\n\t[PROG_NAME] = { \"Program\", {\"prog_name\", \"progname\", \"prog\"}, true  , true   },\n\t[VERDICT] = { \"Verdict\", {\"verdict\"}, true  , true   },\n\t[DURATION] = { \"Duration (us)\", {\"duration\", \"dur\"}, },\n\t[TOTAL_INSNS] = { \"Insns\", {\"total_insns\", \"insns\"}, },\n\t[TOTAL_STATES] = { \"States\", {\"total_states\", \"states\"}, },\n\t[PEAK_STATES] = { \"Peak states\", {\"peak_states\"}, },\n\t[MAX_STATES_PER_INSN] = { \"Max states per insn\", {\"max_states_per_insn\"}, },\n\t[MARK_READ_MAX_LEN] = { \"Max mark read length\", {\"max_mark_read_len\", \"mark_read\"}, },\n};\n\nstatic bool parse_stat_id_var(const char *name, size_t len, int *id, enum stat_variant *var)\n{\n\tstatic const char *var_sfxs[] = {\n\t\t[VARIANT_A] = \"_a\",\n\t\t[VARIANT_B] = \"_b\",\n\t\t[VARIANT_DIFF] = \"_diff\",\n\t\t[VARIANT_PCT] = \"_pct\",\n\t};\n\tint i, j, k;\n\n\tfor (i = 0; i < ARRAY_SIZE(stat_defs); i++) {\n\t\tstruct stat_def *def = &stat_defs[i];\n\t\tsize_t alias_len, sfx_len;\n\t\tconst char *alias;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(stat_defs[i].names); j++) {\n\t\t\talias = def->names[j];\n\t\t\tif (!alias)\n\t\t\t\tcontinue;\n\n\t\t\talias_len = strlen(alias);\n\t\t\tif (strncmp(name, alias, alias_len) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (alias_len == len) {\n\t\t\t\t \n\t\t\t\t*var = VARIANT_B;\n\t\t\t\t*id = i;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < ARRAY_SIZE(var_sfxs); k++) {\n\t\t\t\tsfx_len = strlen(var_sfxs[k]);\n\t\t\t\tif (alias_len + sfx_len != len)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (strncmp(name + alias_len, var_sfxs[k], sfx_len) == 0) {\n\t\t\t\t\t*var = (enum stat_variant)k;\n\t\t\t\t\t*id = i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool is_asc_sym(char c)\n{\n\treturn c == '^';\n}\n\nstatic bool is_desc_sym(char c)\n{\n\treturn c == 'v' || c == 'V' || c == '.' || c == '!' || c == '_';\n}\n\nstatic int parse_stat(const char *stat_name, struct stat_specs *specs)\n{\n\tint id;\n\tbool has_order = false, is_asc = false;\n\tsize_t len = strlen(stat_name);\n\tenum stat_variant var;\n\n\tif (specs->spec_cnt >= ARRAY_SIZE(specs->ids)) {\n\t\tfprintf(stderr, \"Can't specify more than %zd stats\\n\", ARRAY_SIZE(specs->ids));\n\t\treturn -E2BIG;\n\t}\n\n\tif (len > 1 && (is_asc_sym(stat_name[len - 1]) || is_desc_sym(stat_name[len - 1]))) {\n\t\thas_order = true;\n\t\tis_asc = is_asc_sym(stat_name[len - 1]);\n\t\tlen -= 1;\n\t}\n\n\tif (!parse_stat_id_var(stat_name, len, &id, &var)) {\n\t\tfprintf(stderr, \"Unrecognized stat name '%s'\\n\", stat_name);\n\t\treturn -ESRCH;\n\t}\n\n\tspecs->ids[specs->spec_cnt] = id;\n\tspecs->variants[specs->spec_cnt] = var;\n\tspecs->asc[specs->spec_cnt] = has_order ? is_asc : stat_defs[id].asc_by_default;\n\tspecs->spec_cnt++;\n\n\treturn 0;\n}\n\nstatic int parse_stats(const char *stats_str, struct stat_specs *specs)\n{\n\tchar *input, *state = NULL, *next;\n\tint err;\n\n\tinput = strdup(stats_str);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\twhile ((next = strtok_r(state ? NULL : input, \",\", &state))) {\n\t\terr = parse_stat(next, specs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_verif_stats(struct verif_stats *stats, size_t stat_cnt)\n{\n\tint i;\n\n\tif (!stats)\n\t\treturn;\n\n\tfor (i = 0; i < stat_cnt; i++) {\n\t\tfree(stats[i].file_name);\n\t\tfree(stats[i].prog_name);\n\t}\n\tfree(stats);\n}\n\nstatic char verif_log_buf[64 * 1024];\n\n#define MAX_PARSED_LOG_LINES 100\n\nstatic int parse_verif_log(char * const buf, size_t buf_sz, struct verif_stats *s)\n{\n\tconst char *cur;\n\tint pos, lines;\n\n\tbuf[buf_sz - 1] = '\\0';\n\n\tfor (pos = strlen(buf) - 1, lines = 0; pos >= 0 && lines < MAX_PARSED_LOG_LINES; lines++) {\n\t\t \n\t\tfor (cur = &buf[pos]; cur > buf && cur[0] != '\\n'; cur--, pos--) {\n\t\t}\n\t\t \n\t\tpos--;\n\t\t \n\t\tif (cur[0] == '\\n')\n\t\t\tcur++;\n\n\t\tif (1 == sscanf(cur, \"verification time %ld usec\\n\", &s->stats[DURATION]))\n\t\t\tcontinue;\n\t\tif (6 == sscanf(cur, \"processed %ld insns (limit %*d) max_states_per_insn %ld total_states %ld peak_states %ld mark_read %ld\",\n\t\t\t\t&s->stats[TOTAL_INSNS],\n\t\t\t\t&s->stats[MAX_STATES_PER_INSN],\n\t\t\t\t&s->stats[TOTAL_STATES],\n\t\t\t\t&s->stats[PEAK_STATES],\n\t\t\t\t&s->stats[MARK_READ_MAX_LEN]))\n\t\t\tcontinue;\n\t}\n\n\treturn 0;\n}\n\nstatic int guess_prog_type_by_ctx_name(const char *ctx_name,\n\t\t\t\t       enum bpf_prog_type *prog_type,\n\t\t\t\t       enum bpf_attach_type *attach_type)\n{\n\t \n\tstatic struct {\n\t\tconst char *uapi_name;\n\t\tconst char *kern_name;\n\t\tenum bpf_prog_type prog_type;\n\t\tenum bpf_attach_type attach_type;\n\t} ctx_map[] = {\n\t\t \n\t\t{ \"__sk_buff\", \"sk_buff\", BPF_PROG_TYPE_SCHED_CLS },\n\t\t{ \"bpf_sock\", \"sock\", BPF_PROG_TYPE_CGROUP_SOCK, BPF_CGROUP_INET4_POST_BIND },\n\t\t{ \"bpf_sock_addr\", \"bpf_sock_addr_kern\",  BPF_PROG_TYPE_CGROUP_SOCK_ADDR, BPF_CGROUP_INET4_BIND },\n\t\t{ \"bpf_sock_ops\", \"bpf_sock_ops_kern\", BPF_PROG_TYPE_SOCK_OPS, BPF_CGROUP_SOCK_OPS },\n\t\t{ \"sk_msg_md\", \"sk_msg\", BPF_PROG_TYPE_SK_MSG, BPF_SK_MSG_VERDICT },\n\t\t{ \"bpf_cgroup_dev_ctx\", \"bpf_cgroup_dev_ctx\", BPF_PROG_TYPE_CGROUP_DEVICE, BPF_CGROUP_DEVICE },\n\t\t{ \"bpf_sysctl\", \"bpf_sysctl_kern\", BPF_PROG_TYPE_CGROUP_SYSCTL, BPF_CGROUP_SYSCTL },\n\t\t{ \"bpf_sockopt\", \"bpf_sockopt_kern\", BPF_PROG_TYPE_CGROUP_SOCKOPT, BPF_CGROUP_SETSOCKOPT },\n\t\t{ \"sk_reuseport_md\", \"sk_reuseport_kern\", BPF_PROG_TYPE_SK_REUSEPORT, BPF_SK_REUSEPORT_SELECT_OR_MIGRATE },\n\t\t{ \"bpf_sk_lookup\", \"bpf_sk_lookup_kern\", BPF_PROG_TYPE_SK_LOOKUP, BPF_SK_LOOKUP },\n\t\t{ \"xdp_md\", \"xdp_buff\", BPF_PROG_TYPE_XDP, BPF_XDP },\n\t\t \n\t\t{ \"bpf_user_pt_regs_t\", \"pt_regs\", BPF_PROG_TYPE_KPROBE },\n\t\t{ \"bpf_perf_event_data\", \"bpf_perf_event_data_kern\", BPF_PROG_TYPE_PERF_EVENT },\n\t\t \n\t\t{ \"bpf_raw_tracepoint_args\", NULL, BPF_PROG_TYPE_RAW_TRACEPOINT },\n\t};\n\tint i;\n\n\tif (!ctx_name)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx_map); i++) {\n\t\tif (strcmp(ctx_map[i].uapi_name, ctx_name) == 0 ||\n\t\t    (ctx_map[i].kern_name && strcmp(ctx_map[i].kern_name, ctx_name) == 0)) {\n\t\t\t*prog_type = ctx_map[i].prog_type;\n\t\t\t*attach_type = ctx_map[i].attach_type;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ESRCH;\n}\n\nstatic void fixup_obj(struct bpf_object *obj, struct bpf_program *prog, const char *filename)\n{\n\tstruct bpf_map *map;\n\n\tbpf_object__for_each_map(map, obj) {\n\t\t \n\t\tbpf_map__set_pin_path(map, NULL);\n\n\t\t \n\t\tswitch (bpf_map__type(map)) {\n\t\tcase BPF_MAP_TYPE_SK_STORAGE:\n\t\tcase BPF_MAP_TYPE_TASK_STORAGE:\n\t\tcase BPF_MAP_TYPE_INODE_STORAGE:\n\t\tcase BPF_MAP_TYPE_CGROUP_STORAGE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bpf_map__max_entries(map) == 0)\n\t\t\t\tbpf_map__set_max_entries(map, 1);\n\t\t}\n\t}\n\n\t \n\tif (bpf_program__type(prog) == BPF_PROG_TYPE_EXT) {\n\t\tconst struct btf *btf = bpf_object__btf(obj);\n\t\tconst char *prog_name = bpf_program__name(prog);\n\t\tenum bpf_prog_type prog_type;\n\t\tenum bpf_attach_type attach_type;\n\t\tconst struct btf_type *t;\n\t\tconst char *ctx_name;\n\t\tint id;\n\n\t\tif (!btf)\n\t\t\tgoto skip_freplace_fixup;\n\n\t\tid = btf__find_by_name_kind(btf, prog_name, BTF_KIND_FUNC);\n\t\tt = btf__type_by_id(btf, id);\n\t\tt = btf__type_by_id(btf, t->type);\n\t\tif (!btf_is_func_proto(t) || btf_vlen(t) != 1)\n\t\t\tgoto skip_freplace_fixup;\n\n\t\t \n\t\tt = btf__type_by_id(btf, btf_params(t)[0].type);\n\t\twhile (t && btf_is_mod(t))\n\t\t\tt = btf__type_by_id(btf, t->type);\n\t\tif (!t || !btf_is_ptr(t))\n\t\t\tgoto skip_freplace_fixup;\n\t\tt = btf__type_by_id(btf, t->type);\n\t\twhile (t && btf_is_mod(t))\n\t\t\tt = btf__type_by_id(btf, t->type);\n\t\tif (!t)\n\t\t\tgoto skip_freplace_fixup;\n\n\t\tctx_name = btf__name_by_offset(btf, t->name_off);\n\n\t\tif (guess_prog_type_by_ctx_name(ctx_name, &prog_type, &attach_type) == 0) {\n\t\t\tbpf_program__set_type(prog, prog_type);\n\t\t\tbpf_program__set_expected_attach_type(prog, attach_type);\n\n\t\t\tif (!env.quiet) {\n\t\t\t\tprintf(\"Using guessed program type '%s' for %s/%s...\\n\",\n\t\t\t\t\tlibbpf_bpf_prog_type_str(prog_type),\n\t\t\t\t\tfilename, prog_name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!env.quiet) {\n\t\t\t\tprintf(\"Failed to guess program type for freplace program with context type name '%s' for %s/%s. Consider using canonical type names to help veristat...\\n\",\n\t\t\t\t\tctx_name, filename, prog_name);\n\t\t\t}\n\t\t}\n\t}\nskip_freplace_fixup:\n\treturn;\n}\n\nstatic int process_prog(const char *filename, struct bpf_object *obj, struct bpf_program *prog)\n{\n\tconst char *prog_name = bpf_program__name(prog);\n\tconst char *base_filename = basename(filename);\n\tchar *buf;\n\tint buf_sz, log_level;\n\tstruct verif_stats *stats;\n\tint err = 0;\n\tvoid *tmp;\n\n\tif (!should_process_file_prog(base_filename, bpf_program__name(prog))) {\n\t\tenv.progs_skipped++;\n\t\treturn 0;\n\t}\n\n\ttmp = realloc(env.prog_stats, (env.prog_stat_cnt + 1) * sizeof(*env.prog_stats));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\tenv.prog_stats = tmp;\n\tstats = &env.prog_stats[env.prog_stat_cnt++];\n\tmemset(stats, 0, sizeof(*stats));\n\n\tif (env.verbose) {\n\t\tbuf_sz = env.log_size ? env.log_size : 16 * 1024 * 1024;\n\t\tbuf = malloc(buf_sz);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tlog_level = env.log_level | 4 | (env.log_fixed ? 8 : 0);\n\t} else {\n\t\tbuf = verif_log_buf;\n\t\tbuf_sz = sizeof(verif_log_buf);\n\t\t \n\t\tlog_level = 4 | (env.log_fixed ? 8 : 0);\n\t}\n\tverif_log_buf[0] = '\\0';\n\n\tbpf_program__set_log_buf(prog, buf, buf_sz);\n\tbpf_program__set_log_level(prog, log_level);\n\n\t \n\tfixup_obj(obj, prog, base_filename);\n\n\tif (env.force_checkpoints)\n\t\tbpf_program__set_flags(prog, bpf_program__flags(prog) | BPF_F_TEST_STATE_FREQ);\n\n\terr = bpf_object__load(obj);\n\tenv.progs_processed++;\n\n\tstats->file_name = strdup(base_filename);\n\tstats->prog_name = strdup(bpf_program__name(prog));\n\tstats->stats[VERDICT] = err == 0;  \n\tparse_verif_log(buf, buf_sz, stats);\n\n\tif (env.verbose) {\n\t\tprintf(\"PROCESSING %s/%s, DURATION US: %ld, VERDICT: %s, VERIFIER LOG:\\n%s\\n\",\n\t\t       filename, prog_name, stats->stats[DURATION],\n\t\t       err ? \"failure\" : \"success\", buf);\n\t}\n\n\tif (verif_log_buf != buf)\n\t\tfree(buf);\n\n\treturn 0;\n};\n\nstatic int process_obj(const char *filename)\n{\n\tstruct bpf_object *obj = NULL, *tobj;\n\tstruct bpf_program *prog, *tprog, *lprog;\n\tlibbpf_print_fn_t old_libbpf_print_fn;\n\tLIBBPF_OPTS(bpf_object_open_opts, opts);\n\tint err = 0, prog_cnt = 0;\n\n\tif (!should_process_file_prog(basename(filename), NULL)) {\n\t\tif (env.verbose)\n\t\t\tprintf(\"Skipping '%s' due to filters...\\n\", filename);\n\t\tenv.files_skipped++;\n\t\treturn 0;\n\t}\n\tif (!is_bpf_obj_file(filename)) {\n\t\tif (env.verbose)\n\t\t\tprintf(\"Skipping '%s' as it's not a BPF object file...\\n\", filename);\n\t\tenv.files_skipped++;\n\t\treturn 0;\n\t}\n\n\tif (!env.quiet && env.out_fmt == RESFMT_TABLE)\n\t\tprintf(\"Processing '%s'...\\n\", basename(filename));\n\n\told_libbpf_print_fn = libbpf_set_print(libbpf_print_fn);\n\tobj = bpf_object__open_file(filename, &opts);\n\tif (!obj) {\n\t\t \n\t\tfprintf(stderr, \"Failed to open '%s': %d\\n\", filename, -errno);\n\t\tenv.files_skipped++;\n\t\terr = 0;\n\t\tgoto cleanup;\n\t}\n\n\tenv.files_processed++;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprog_cnt++;\n\t}\n\n\tif (prog_cnt == 1) {\n\t\tprog = bpf_object__next_program(obj, NULL);\n\t\tbpf_program__set_autoload(prog, true);\n\t\tprocess_prog(filename, obj, prog);\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tconst char *prog_name = bpf_program__name(prog);\n\n\t\ttobj = bpf_object__open_file(filename, &opts);\n\t\tif (!tobj) {\n\t\t\terr = -errno;\n\t\t\tfprintf(stderr, \"Failed to open '%s': %d\\n\", filename, err);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tlprog = NULL;\n\t\tbpf_object__for_each_program(tprog, tobj) {\n\t\t\tconst char *tprog_name = bpf_program__name(tprog);\n\n\t\t\tif (strcmp(prog_name, tprog_name) == 0) {\n\t\t\t\tbpf_program__set_autoload(tprog, true);\n\t\t\t\tlprog = tprog;\n\t\t\t} else {\n\t\t\t\tbpf_program__set_autoload(tprog, false);\n\t\t\t}\n\t\t}\n\n\t\tprocess_prog(filename, tobj, lprog);\n\t\tbpf_object__close(tobj);\n\t}\n\ncleanup:\n\tbpf_object__close(obj);\n\tlibbpf_set_print(old_libbpf_print_fn);\n\treturn err;\n}\n\nstatic int cmp_stat(const struct verif_stats *s1, const struct verif_stats *s2,\n\t\t    enum stat_id id, bool asc)\n{\n\tint cmp = 0;\n\n\tswitch (id) {\n\tcase FILE_NAME:\n\t\tcmp = strcmp(s1->file_name, s2->file_name);\n\t\tbreak;\n\tcase PROG_NAME:\n\t\tcmp = strcmp(s1->prog_name, s2->prog_name);\n\t\tbreak;\n\tcase VERDICT:\n\tcase DURATION:\n\tcase TOTAL_INSNS:\n\tcase TOTAL_STATES:\n\tcase PEAK_STATES:\n\tcase MAX_STATES_PER_INSN:\n\tcase MARK_READ_MAX_LEN: {\n\t\tlong v1 = s1->stats[id];\n\t\tlong v2 = s2->stats[id];\n\n\t\tif (v1 != v2)\n\t\t\tcmp = v1 < v2 ? -1 : 1;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tfprintf(stderr, \"Unrecognized stat #%d\\n\", id);\n\t\texit(1);\n\t}\n\n\treturn asc ? cmp : -cmp;\n}\n\nstatic int cmp_prog_stats(const void *v1, const void *v2)\n{\n\tconst struct verif_stats *s1 = v1, *s2 = v2;\n\tint i, cmp;\n\n\tfor (i = 0; i < env.sort_spec.spec_cnt; i++) {\n\t\tcmp = cmp_stat(s1, s2, env.sort_spec.ids[i], env.sort_spec.asc[i]);\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t}\n\n\t \n\tcmp = strcmp(s1->file_name, s2->file_name);\n\tif (cmp != 0)\n\t\treturn cmp;\n\treturn strcmp(s1->prog_name, s2->prog_name);\n}\n\nstatic void fetch_join_stat_value(const struct verif_stats_join *s,\n\t\t\t\t  enum stat_id id, enum stat_variant var,\n\t\t\t\t  const char **str_val,\n\t\t\t\t  double *num_val)\n{\n\tlong v1, v2;\n\n\tif (id == FILE_NAME) {\n\t\t*str_val = s->file_name;\n\t\treturn;\n\t}\n\tif (id == PROG_NAME) {\n\t\t*str_val = s->prog_name;\n\t\treturn;\n\t}\n\n\tv1 = s->stats_a ? s->stats_a->stats[id] : 0;\n\tv2 = s->stats_b ? s->stats_b->stats[id] : 0;\n\n\tswitch (var) {\n\tcase VARIANT_A:\n\t\tif (!s->stats_a)\n\t\t\t*num_val = -DBL_MAX;\n\t\telse\n\t\t\t*num_val = s->stats_a->stats[id];\n\t\treturn;\n\tcase VARIANT_B:\n\t\tif (!s->stats_b)\n\t\t\t*num_val = -DBL_MAX;\n\t\telse\n\t\t\t*num_val = s->stats_b->stats[id];\n\t\treturn;\n\tcase VARIANT_DIFF:\n\t\tif (!s->stats_a || !s->stats_b)\n\t\t\t*num_val = -DBL_MAX;\n\t\telse if (id == VERDICT)\n\t\t\t*num_val = v1 == v2 ? 1.0   : 0.0  ;\n\t\telse\n\t\t\t*num_val = (double)(v2 - v1);\n\t\treturn;\n\tcase VARIANT_PCT:\n\t\tif (!s->stats_a || !s->stats_b) {\n\t\t\t*num_val = -DBL_MAX;\n\t\t} else if (v1 == 0) {\n\t\t\tif (v1 == v2)\n\t\t\t\t*num_val = 0.0;\n\t\t\telse\n\t\t\t\t*num_val = v2 < v1 ? -100.0 : 100.0;\n\t\t} else {\n\t\t\t *num_val = (v2 - v1) * 100.0 / v1;\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic int cmp_join_stat(const struct verif_stats_join *s1,\n\t\t\t const struct verif_stats_join *s2,\n\t\t\t enum stat_id id, enum stat_variant var, bool asc)\n{\n\tconst char *str1 = NULL, *str2 = NULL;\n\tdouble v1, v2;\n\tint cmp = 0;\n\n\tfetch_join_stat_value(s1, id, var, &str1, &v1);\n\tfetch_join_stat_value(s2, id, var, &str2, &v2);\n\n\tif (str1)\n\t\tcmp = strcmp(str1, str2);\n\telse if (v1 != v2)\n\t\tcmp = v1 < v2 ? -1 : 1;\n\n\treturn asc ? cmp : -cmp;\n}\n\nstatic int cmp_join_stats(const void *v1, const void *v2)\n{\n\tconst struct verif_stats_join *s1 = v1, *s2 = v2;\n\tint i, cmp;\n\n\tfor (i = 0; i < env.sort_spec.spec_cnt; i++) {\n\t\tcmp = cmp_join_stat(s1, s2,\n\t\t\t\t    env.sort_spec.ids[i],\n\t\t\t\t    env.sort_spec.variants[i],\n\t\t\t\t    env.sort_spec.asc[i]);\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t}\n\n\t \n\tcmp = strcmp(s1->file_name, s2->file_name);\n\tif (cmp != 0)\n\t\treturn cmp;\n\treturn strcmp(s1->prog_name, s2->prog_name);\n}\n\n#define HEADER_CHAR '-'\n#define COLUMN_SEP \"  \"\n\nstatic void output_header_underlines(void)\n{\n\tint i, j, len;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tlen = env.output_spec.lens[i];\n\n\t\tprintf(\"%s\", i == 0 ? \"\" : COLUMN_SEP);\n\t\tfor (j = 0; j < len; j++)\n\t\t\tprintf(\"%c\", HEADER_CHAR);\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void output_headers(enum resfmt fmt)\n{\n\tconst char *fmt_str;\n\tint i, len;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tint id = env.output_spec.ids[i];\n\t\tint *max_len = &env.output_spec.lens[i];\n\n\t\tswitch (fmt) {\n\t\tcase RESFMT_TABLE_CALCLEN:\n\t\t\tlen = snprintf(NULL, 0, \"%s\", stat_defs[id].header);\n\t\t\tif (len > *max_len)\n\t\t\t\t*max_len = len;\n\t\t\tbreak;\n\t\tcase RESFMT_TABLE:\n\t\t\tfmt_str = stat_defs[id].left_aligned ? \"%s%-*s\" : \"%s%*s\";\n\t\t\tprintf(fmt_str, i == 0 ? \"\" : COLUMN_SEP,  *max_len, stat_defs[id].header);\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\tcase RESFMT_CSV:\n\t\t\tprintf(\"%s%s\", i == 0 ? \"\" : \",\", stat_defs[id].names[0]);\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fmt == RESFMT_TABLE)\n\t\toutput_header_underlines();\n}\n\nstatic void prepare_value(const struct verif_stats *s, enum stat_id id,\n\t\t\t  const char **str, long *val)\n{\n\tswitch (id) {\n\tcase FILE_NAME:\n\t\t*str = s ? s->file_name : \"N/A\";\n\t\tbreak;\n\tcase PROG_NAME:\n\t\t*str = s ? s->prog_name : \"N/A\";\n\t\tbreak;\n\tcase VERDICT:\n\t\tif (!s)\n\t\t\t*str = \"N/A\";\n\t\telse\n\t\t\t*str = s->stats[VERDICT] ? \"success\" : \"failure\";\n\t\tbreak;\n\tcase DURATION:\n\tcase TOTAL_INSNS:\n\tcase TOTAL_STATES:\n\tcase PEAK_STATES:\n\tcase MAX_STATES_PER_INSN:\n\tcase MARK_READ_MAX_LEN:\n\t\t*val = s ? s->stats[id] : 0;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Unrecognized stat #%d\\n\", id);\n\t\texit(1);\n\t}\n}\n\nstatic void output_stats(const struct verif_stats *s, enum resfmt fmt, bool last)\n{\n\tint i;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tint id = env.output_spec.ids[i];\n\t\tint *max_len = &env.output_spec.lens[i], len;\n\t\tconst char *str = NULL;\n\t\tlong val = 0;\n\n\t\tprepare_value(s, id, &str, &val);\n\n\t\tswitch (fmt) {\n\t\tcase RESFMT_TABLE_CALCLEN:\n\t\t\tif (str)\n\t\t\t\tlen = snprintf(NULL, 0, \"%s\", str);\n\t\t\telse\n\t\t\t\tlen = snprintf(NULL, 0, \"%ld\", val);\n\t\t\tif (len > *max_len)\n\t\t\t\t*max_len = len;\n\t\t\tbreak;\n\t\tcase RESFMT_TABLE:\n\t\t\tif (str)\n\t\t\t\tprintf(\"%s%-*s\", i == 0 ? \"\" : COLUMN_SEP, *max_len, str);\n\t\t\telse\n\t\t\t\tprintf(\"%s%*ld\", i == 0 ? \"\" : COLUMN_SEP,  *max_len, val);\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\tcase RESFMT_CSV:\n\t\t\tif (str)\n\t\t\t\tprintf(\"%s%s\", i == 0 ? \"\" : \",\", str);\n\t\t\telse\n\t\t\t\tprintf(\"%s%ld\", i == 0 ? \"\" : \",\", val);\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (last && fmt == RESFMT_TABLE) {\n\t\toutput_header_underlines();\n\t\tprintf(\"Done. Processed %d files, %d programs. Skipped %d files, %d programs.\\n\",\n\t\t       env.files_processed, env.files_skipped, env.progs_processed, env.progs_skipped);\n\t}\n}\n\nstatic int parse_stat_value(const char *str, enum stat_id id, struct verif_stats *st)\n{\n\tswitch (id) {\n\tcase FILE_NAME:\n\t\tst->file_name = strdup(str);\n\t\tif (!st->file_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase PROG_NAME:\n\t\tst->prog_name = strdup(str);\n\t\tif (!st->prog_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase VERDICT:\n\t\tif (strcmp(str, \"success\") == 0) {\n\t\t\tst->stats[VERDICT] = true;\n\t\t} else if (strcmp(str, \"failure\") == 0) {\n\t\t\tst->stats[VERDICT] = false;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unrecognized verification verdict '%s'\\n\", str);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DURATION:\n\tcase TOTAL_INSNS:\n\tcase TOTAL_STATES:\n\tcase PEAK_STATES:\n\tcase MAX_STATES_PER_INSN:\n\tcase MARK_READ_MAX_LEN: {\n\t\tlong val;\n\t\tint err, n;\n\n\t\tif (sscanf(str, \"%ld %n\", &val, &n) != 1 || n != strlen(str)) {\n\t\t\terr = -errno;\n\t\t\tfprintf(stderr, \"Failed to parse '%s' as integer\\n\", str);\n\t\t\treturn err;\n\t\t}\n\n\t\tst->stats[id] = val;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tfprintf(stderr, \"Unrecognized stat #%d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int parse_stats_csv(const char *filename, struct stat_specs *specs,\n\t\t\t   struct verif_stats **statsp, int *stat_cntp)\n{\n\tchar line[4096];\n\tFILE *f;\n\tint err = 0;\n\tbool header = true;\n\n\tf = fopen(filename, \"r\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tfprintf(stderr, \"Failed to open '%s': %d\\n\", filename, err);\n\t\treturn err;\n\t}\n\n\t*stat_cntp = 0;\n\n\twhile (fgets(line, sizeof(line), f)) {\n\t\tchar *input = line, *state = NULL, *next;\n\t\tstruct verif_stats *st = NULL;\n\t\tint col = 0;\n\n\t\tif (!header) {\n\t\t\tvoid *tmp;\n\n\t\t\ttmp = realloc(*statsp, (*stat_cntp + 1) * sizeof(**statsp));\n\t\t\tif (!tmp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t*statsp = tmp;\n\n\t\t\tst = &(*statsp)[*stat_cntp];\n\t\t\tmemset(st, 0, sizeof(*st));\n\n\t\t\t*stat_cntp += 1;\n\t\t}\n\n\t\twhile ((next = strtok_r(state ? NULL : input, \",\\n\", &state))) {\n\t\t\tif (header) {\n\t\t\t\t \n\t\t\t\terr = parse_stat(next, specs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (col >= specs->spec_cnt) {\n\t\t\t\tfprintf(stderr, \"Found extraneous column #%d in row #%d of '%s'\\n\",\n\t\t\t\t\tcol, *stat_cntp, filename);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terr = parse_stat_value(next, specs->ids[col], st);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tcol++;\n\t\t}\n\n\t\tif (header) {\n\t\t\theader = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (col < specs->spec_cnt) {\n\t\t\tfprintf(stderr, \"Not enough columns in row #%d in '%s'\\n\",\n\t\t\t\t*stat_cntp, filename);\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!st->file_name || !st->prog_name) {\n\t\t\tfprintf(stderr, \"Row #%d in '%s' is missing file and/or program name\\n\",\n\t\t\t\t*stat_cntp, filename);\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (!should_process_file_prog(st->file_name, st->prog_name)) {\n\t\t\tfree(st->file_name);\n\t\t\tfree(st->prog_name);\n\t\t\t*stat_cntp -= 1;\n\t\t}\n\t}\n\n\tif (!feof(f)) {\n\t\terr = -errno;\n\t\tfprintf(stderr, \"Failed I/O for '%s': %d\\n\", filename, err);\n\t}\n\ncleanup:\n\tfclose(f);\n\treturn err;\n}\n\n \nstatic const struct verif_stats fallback_stats = { .file_name = \"\", .prog_name = \"\" };\n\nstatic bool is_key_stat(enum stat_id id)\n{\n\treturn id == FILE_NAME || id == PROG_NAME;\n}\n\nstatic void output_comp_header_underlines(void)\n{\n\tint i, j, k;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tint id = env.output_spec.ids[i];\n\t\tint max_j = is_key_stat(id) ? 1 : 3;\n\n\t\tfor (j = 0; j < max_j; j++) {\n\t\t\tint len = env.output_spec.lens[3 * i + j];\n\n\t\t\tprintf(\"%s\", i + j == 0 ? \"\" : COLUMN_SEP);\n\n\t\t\tfor (k = 0; k < len; k++)\n\t\t\t\tprintf(\"%c\", HEADER_CHAR);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void output_comp_headers(enum resfmt fmt)\n{\n\tstatic const char *table_sfxs[3] = {\" (A)\", \" (B)\", \" (DIFF)\"};\n\tstatic const char *name_sfxs[3] = {\"_base\", \"_comp\", \"_diff\"};\n\tint i, j, len;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tint id = env.output_spec.ids[i];\n\t\t \n\t\tint max_j = is_key_stat(id) ? 1 : 3;\n\n\t\tfor (j = 0; j < max_j; j++) {\n\t\t\tint *max_len = &env.output_spec.lens[3 * i + j];\n\t\t\tbool last = (i == env.output_spec.spec_cnt - 1) && (j == max_j - 1);\n\t\t\tconst char *sfx;\n\n\t\t\tswitch (fmt) {\n\t\t\tcase RESFMT_TABLE_CALCLEN:\n\t\t\t\tsfx = is_key_stat(id) ? \"\" : table_sfxs[j];\n\t\t\t\tlen = snprintf(NULL, 0, \"%s%s\", stat_defs[id].header, sfx);\n\t\t\t\tif (len > *max_len)\n\t\t\t\t\t*max_len = len;\n\t\t\t\tbreak;\n\t\t\tcase RESFMT_TABLE:\n\t\t\t\tsfx = is_key_stat(id) ? \"\" : table_sfxs[j];\n\t\t\t\tprintf(\"%s%-*s%s\", i + j == 0 ? \"\" : COLUMN_SEP,\n\t\t\t\t       *max_len - (int)strlen(sfx), stat_defs[id].header, sfx);\n\t\t\t\tif (last)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\tcase RESFMT_CSV:\n\t\t\t\tsfx = is_key_stat(id) ? \"\" : name_sfxs[j];\n\t\t\t\tprintf(\"%s%s%s\", i + j == 0 ? \"\" : \",\", stat_defs[id].names[0], sfx);\n\t\t\t\tif (last)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fmt == RESFMT_TABLE)\n\t\toutput_comp_header_underlines();\n}\n\nstatic void output_comp_stats(const struct verif_stats_join *join_stats,\n\t\t\t      enum resfmt fmt, bool last)\n{\n\tconst struct verif_stats *base = join_stats->stats_a;\n\tconst struct verif_stats *comp = join_stats->stats_b;\n\tchar base_buf[1024] = {}, comp_buf[1024] = {}, diff_buf[1024] = {};\n\tint i;\n\n\tfor (i = 0; i < env.output_spec.spec_cnt; i++) {\n\t\tint id = env.output_spec.ids[i], len;\n\t\tint *max_len_base = &env.output_spec.lens[3 * i + 0];\n\t\tint *max_len_comp = &env.output_spec.lens[3 * i + 1];\n\t\tint *max_len_diff = &env.output_spec.lens[3 * i + 2];\n\t\tconst char *base_str = NULL, *comp_str = NULL;\n\t\tlong base_val = 0, comp_val = 0, diff_val = 0;\n\n\t\tprepare_value(base, id, &base_str, &base_val);\n\t\tprepare_value(comp, id, &comp_str, &comp_val);\n\n\t\t \n\t\tif (is_key_stat(id)) {\n\t\t\t \n\t\t\tif (base)\n\t\t\t\tsnprintf(base_buf, sizeof(base_buf), \"%s\", base_str);\n\t\t\telse\n\t\t\t\tsnprintf(base_buf, sizeof(base_buf), \"%s\", comp_str);\n\t\t} else if (base_str) {\n\t\t\tsnprintf(base_buf, sizeof(base_buf), \"%s\", base_str);\n\t\t\tsnprintf(comp_buf, sizeof(comp_buf), \"%s\", comp_str);\n\t\t\tif (!base || !comp)\n\t\t\t\tsnprintf(diff_buf, sizeof(diff_buf), \"%s\", \"N/A\");\n\t\t\telse if (strcmp(base_str, comp_str) == 0)\n\t\t\t\tsnprintf(diff_buf, sizeof(diff_buf), \"%s\", \"MATCH\");\n\t\t\telse\n\t\t\t\tsnprintf(diff_buf, sizeof(diff_buf), \"%s\", \"MISMATCH\");\n\t\t} else {\n\t\t\tdouble p = 0.0;\n\n\t\t\tif (base)\n\t\t\t\tsnprintf(base_buf, sizeof(base_buf), \"%ld\", base_val);\n\t\t\telse\n\t\t\t\tsnprintf(base_buf, sizeof(base_buf), \"%s\", \"N/A\");\n\t\t\tif (comp)\n\t\t\t\tsnprintf(comp_buf, sizeof(comp_buf), \"%ld\", comp_val);\n\t\t\telse\n\t\t\t\tsnprintf(comp_buf, sizeof(comp_buf), \"%s\", \"N/A\");\n\n\t\t\tdiff_val = comp_val - base_val;\n\t\t\tif (!base || !comp) {\n\t\t\t\tsnprintf(diff_buf, sizeof(diff_buf), \"%s\", \"N/A\");\n\t\t\t} else {\n\t\t\t\tif (base_val == 0) {\n\t\t\t\t\tif (comp_val == base_val)\n\t\t\t\t\t\tp = 0.0;  \n\t\t\t\t\telse\n\t\t\t\t\t\tp = comp_val < base_val ? -100.0 : 100.0;\n\t\t\t\t} else {\n\t\t\t\t\t p = diff_val * 100.0 / base_val;\n\t\t\t\t}\n\t\t\t\tsnprintf(diff_buf, sizeof(diff_buf), \"%+ld (%+.2lf%%)\", diff_val, p);\n\t\t\t}\n\t\t}\n\n\t\tswitch (fmt) {\n\t\tcase RESFMT_TABLE_CALCLEN:\n\t\t\tlen = strlen(base_buf);\n\t\t\tif (len > *max_len_base)\n\t\t\t\t*max_len_base = len;\n\t\t\tif (!is_key_stat(id)) {\n\t\t\t\tlen = strlen(comp_buf);\n\t\t\t\tif (len > *max_len_comp)\n\t\t\t\t\t*max_len_comp = len;\n\t\t\t\tlen = strlen(diff_buf);\n\t\t\t\tif (len > *max_len_diff)\n\t\t\t\t\t*max_len_diff = len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RESFMT_TABLE: {\n\t\t\t \n\t\t\tconst char *fmt = base_str ? \"%s%-*s\" : \"%s%*s\";\n\n\t\t\tprintf(fmt, i == 0 ? \"\" : COLUMN_SEP, *max_len_base, base_buf);\n\t\t\tif (!is_key_stat(id)) {\n\t\t\t\tprintf(fmt, COLUMN_SEP, *max_len_comp, comp_buf);\n\t\t\t\tprintf(fmt, COLUMN_SEP, *max_len_diff, diff_buf);\n\t\t\t}\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase RESFMT_CSV:\n\t\t\tprintf(\"%s%s\", i == 0 ? \"\" : \",\", base_buf);\n\t\t\tif (!is_key_stat(id)) {\n\t\t\t\tprintf(\"%s%s\", i == 0 ? \"\" : \",\", comp_buf);\n\t\t\t\tprintf(\"%s%s\", i == 0 ? \"\" : \",\", diff_buf);\n\t\t\t}\n\t\t\tif (i == env.output_spec.spec_cnt - 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (last && fmt == RESFMT_TABLE)\n\t\toutput_comp_header_underlines();\n}\n\nstatic int cmp_stats_key(const struct verif_stats *base, const struct verif_stats *comp)\n{\n\tint r;\n\n\tr = strcmp(base->file_name, comp->file_name);\n\tif (r != 0)\n\t\treturn r;\n\treturn strcmp(base->prog_name, comp->prog_name);\n}\n\nstatic bool is_join_stat_filter_matched(struct filter *f, const struct verif_stats_join *stats)\n{\n\tstatic const double eps = 1e-9;\n\tconst char *str = NULL;\n\tdouble value = 0.0;\n\n\tfetch_join_stat_value(stats, f->stat_id, f->stat_var, &str, &value);\n\n\tswitch (f->op) {\n\tcase OP_EQ: return value > f->value - eps && value < f->value + eps;\n\tcase OP_NEQ: return value < f->value - eps || value > f->value + eps;\n\tcase OP_LT: return value < f->value - eps;\n\tcase OP_LE: return value <= f->value + eps;\n\tcase OP_GT: return value > f->value + eps;\n\tcase OP_GE: return value >= f->value - eps;\n\t}\n\n\tfprintf(stderr, \"BUG: unknown filter op %d!\\n\", f->op);\n\treturn false;\n}\n\nstatic bool should_output_join_stats(const struct verif_stats_join *stats)\n{\n\tstruct filter *f;\n\tint i, allow_cnt = 0;\n\n\tfor (i = 0; i < env.deny_filter_cnt; i++) {\n\t\tf = &env.deny_filters[i];\n\t\tif (f->kind != FILTER_STAT)\n\t\t\tcontinue;\n\n\t\tif (is_join_stat_filter_matched(f, stats))\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < env.allow_filter_cnt; i++) {\n\t\tf = &env.allow_filters[i];\n\t\tif (f->kind != FILTER_STAT)\n\t\t\tcontinue;\n\t\tallow_cnt++;\n\n\t\tif (is_join_stat_filter_matched(f, stats))\n\t\t\treturn true;\n\t}\n\n\t \n\treturn allow_cnt == 0;\n}\n\nstatic int handle_comparison_mode(void)\n{\n\tstruct stat_specs base_specs = {}, comp_specs = {};\n\tstruct stat_specs tmp_sort_spec;\n\tenum resfmt cur_fmt;\n\tint err, i, j, last_idx;\n\n\tif (env.filename_cnt != 2) {\n\t\tfprintf(stderr, \"Comparison mode expects exactly two input CSV files!\\n\\n\");\n\t\targp_help(&argp, stderr, ARGP_HELP_USAGE, \"veristat\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = parse_stats_csv(env.filenames[0], &base_specs,\n\t\t\t      &env.baseline_stats, &env.baseline_stat_cnt);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to parse stats from '%s': %d\\n\", env.filenames[0], err);\n\t\treturn err;\n\t}\n\terr = parse_stats_csv(env.filenames[1], &comp_specs,\n\t\t\t      &env.prog_stats, &env.prog_stat_cnt);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to parse stats from '%s': %d\\n\", env.filenames[1], err);\n\t\treturn err;\n\t}\n\n\t \n\tif (base_specs.spec_cnt != comp_specs.spec_cnt) {\n\t\tfprintf(stderr, \"Number of stats in '%s' and '%s' differs (%d != %d)!\\n\",\n\t\t\tenv.filenames[0], env.filenames[1],\n\t\t\tbase_specs.spec_cnt, comp_specs.spec_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < base_specs.spec_cnt; i++) {\n\t\tif (base_specs.ids[i] != comp_specs.ids[i]) {\n\t\t\tfprintf(stderr, \"Stats composition differs between '%s' and '%s' (%s != %s)!\\n\",\n\t\t\t\tenv.filenames[0], env.filenames[1],\n\t\t\t\tstat_defs[base_specs.ids[i]].names[0],\n\t\t\t\tstat_defs[comp_specs.ids[i]].names[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\ttmp_sort_spec = env.sort_spec;\n\tenv.sort_spec = join_sort_spec;\n\tqsort(env.prog_stats, env.prog_stat_cnt, sizeof(*env.prog_stats), cmp_prog_stats);\n\tqsort(env.baseline_stats, env.baseline_stat_cnt, sizeof(*env.baseline_stats), cmp_prog_stats);\n\tenv.sort_spec = tmp_sort_spec;\n\n\t \n\ti = j = 0;\n\twhile (i < env.baseline_stat_cnt || j < env.prog_stat_cnt) {\n\t\tconst struct verif_stats *base, *comp;\n\t\tstruct verif_stats_join *join;\n\t\tvoid *tmp;\n\t\tint r;\n\n\t\tbase = i < env.baseline_stat_cnt ? &env.baseline_stats[i] : &fallback_stats;\n\t\tcomp = j < env.prog_stat_cnt ? &env.prog_stats[j] : &fallback_stats;\n\n\t\tif (!base->file_name || !base->prog_name) {\n\t\t\tfprintf(stderr, \"Entry #%d in '%s' doesn't have file and/or program name specified!\\n\",\n\t\t\t\ti, env.filenames[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!comp->file_name || !comp->prog_name) {\n\t\t\tfprintf(stderr, \"Entry #%d in '%s' doesn't have file and/or program name specified!\\n\",\n\t\t\t\tj, env.filenames[1]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttmp = realloc(env.join_stats, (env.join_stat_cnt + 1) * sizeof(*env.join_stats));\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\tenv.join_stats = tmp;\n\n\t\tjoin = &env.join_stats[env.join_stat_cnt];\n\t\tmemset(join, 0, sizeof(*join));\n\n\t\tr = cmp_stats_key(base, comp);\n\t\tif (r == 0) {\n\t\t\tjoin->file_name = base->file_name;\n\t\t\tjoin->prog_name = base->prog_name;\n\t\t\tjoin->stats_a = base;\n\t\t\tjoin->stats_b = comp;\n\t\t\ti++;\n\t\t\tj++;\n\t\t} else if (base != &fallback_stats && (comp == &fallback_stats || r < 0)) {\n\t\t\tjoin->file_name = base->file_name;\n\t\t\tjoin->prog_name = base->prog_name;\n\t\t\tjoin->stats_a = base;\n\t\t\tjoin->stats_b = NULL;\n\t\t\ti++;\n\t\t} else if (comp != &fallback_stats && (base == &fallback_stats || r > 0)) {\n\t\t\tjoin->file_name = comp->file_name;\n\t\t\tjoin->prog_name = comp->prog_name;\n\t\t\tjoin->stats_a = NULL;\n\t\t\tjoin->stats_b = comp;\n\t\t\tj++;\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s:%d: should never reach here i=%i, j=%i\",\n\t\t\t\t__FILE__, __LINE__, i, j);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tenv.join_stat_cnt += 1;\n\t}\n\n\t \n\tqsort(env.join_stats, env.join_stat_cnt, sizeof(*env.join_stats), cmp_join_stats);\n\n\t \n\tif (env.out_fmt == RESFMT_TABLE)\n\t\tcur_fmt = RESFMT_TABLE_CALCLEN;\n\telse\n\t\tcur_fmt = env.out_fmt;\n\none_more_time:\n\toutput_comp_headers(cur_fmt);\n\n\tlast_idx = -1;\n\tfor (i = 0; i < env.join_stat_cnt; i++) {\n\t\tconst struct verif_stats_join *join = &env.join_stats[i];\n\n\t\tif (!should_output_join_stats(join))\n\t\t\tcontinue;\n\n\t\tif (cur_fmt == RESFMT_TABLE_CALCLEN)\n\t\t\tlast_idx = i;\n\n\t\toutput_comp_stats(join, cur_fmt, i == last_idx);\n\t}\n\n\tif (cur_fmt == RESFMT_TABLE_CALCLEN) {\n\t\tcur_fmt = RESFMT_TABLE;\n\t\tgoto one_more_time;  \n\t}\n\n\treturn 0;\n}\n\nstatic bool is_stat_filter_matched(struct filter *f, const struct verif_stats *stats)\n{\n\tlong value = stats->stats[f->stat_id];\n\n\tswitch (f->op) {\n\tcase OP_EQ: return value == f->value;\n\tcase OP_NEQ: return value != f->value;\n\tcase OP_LT: return value < f->value;\n\tcase OP_LE: return value <= f->value;\n\tcase OP_GT: return value > f->value;\n\tcase OP_GE: return value >= f->value;\n\t}\n\n\tfprintf(stderr, \"BUG: unknown filter op %d!\\n\", f->op);\n\treturn false;\n}\n\nstatic bool should_output_stats(const struct verif_stats *stats)\n{\n\tstruct filter *f;\n\tint i, allow_cnt = 0;\n\n\tfor (i = 0; i < env.deny_filter_cnt; i++) {\n\t\tf = &env.deny_filters[i];\n\t\tif (f->kind != FILTER_STAT)\n\t\t\tcontinue;\n\n\t\tif (is_stat_filter_matched(f, stats))\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < env.allow_filter_cnt; i++) {\n\t\tf = &env.allow_filters[i];\n\t\tif (f->kind != FILTER_STAT)\n\t\t\tcontinue;\n\t\tallow_cnt++;\n\n\t\tif (is_stat_filter_matched(f, stats))\n\t\t\treturn true;\n\t}\n\n\t \n\treturn allow_cnt == 0;\n}\n\nstatic void output_prog_stats(void)\n{\n\tconst struct verif_stats *stats;\n\tint i, last_stat_idx = 0;\n\n\tif (env.out_fmt == RESFMT_TABLE) {\n\t\t \n\t\toutput_headers(RESFMT_TABLE_CALCLEN);\n\t\tfor (i = 0; i < env.prog_stat_cnt; i++) {\n\t\t\tstats = &env.prog_stats[i];\n\t\t\tif (!should_output_stats(stats))\n\t\t\t\tcontinue;\n\t\t\toutput_stats(stats, RESFMT_TABLE_CALCLEN, false);\n\t\t\tlast_stat_idx = i;\n\t\t}\n\t}\n\n\t \n\toutput_headers(env.out_fmt);\n\tfor (i = 0; i < env.prog_stat_cnt; i++) {\n\t\tstats = &env.prog_stats[i];\n\t\tif (!should_output_stats(stats))\n\t\t\tcontinue;\n\t\toutput_stats(stats, env.out_fmt, i == last_stat_idx);\n\t}\n}\n\nstatic int handle_verif_mode(void)\n{\n\tint i, err;\n\n\tif (env.filename_cnt == 0) {\n\t\tfprintf(stderr, \"Please provide path to BPF object file!\\n\\n\");\n\t\targp_help(&argp, stderr, ARGP_HELP_USAGE, \"veristat\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < env.filename_cnt; i++) {\n\t\terr = process_obj(env.filenames[i]);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"Failed to process '%s': %d\\n\", env.filenames[i], err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tqsort(env.prog_stats, env.prog_stat_cnt, sizeof(*env.prog_stats), cmp_prog_stats);\n\n\toutput_prog_stats();\n\n\treturn 0;\n}\n\nstatic int handle_replay_mode(void)\n{\n\tstruct stat_specs specs = {};\n\tint err;\n\n\tif (env.filename_cnt != 1) {\n\t\tfprintf(stderr, \"Replay mode expects exactly one input CSV file!\\n\\n\");\n\t\targp_help(&argp, stderr, ARGP_HELP_USAGE, \"veristat\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = parse_stats_csv(env.filenames[0], &specs,\n\t\t\t      &env.prog_stats, &env.prog_stat_cnt);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to parse stats from '%s': %d\\n\", env.filenames[0], err);\n\t\treturn err;\n\t}\n\n\tqsort(env.prog_stats, env.prog_stat_cnt, sizeof(*env.prog_stats), cmp_prog_stats);\n\n\toutput_prog_stats();\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint err = 0, i;\n\n\tif (argp_parse(&argp, argc, argv, 0, NULL, NULL))\n\t\treturn 1;\n\n\tif (env.show_version) {\n\t\tprintf(\"%s\\n\", argp_program_version);\n\t\treturn 0;\n\t}\n\n\tif (env.verbose && env.quiet) {\n\t\tfprintf(stderr, \"Verbose and quiet modes are incompatible, please specify just one or neither!\\n\\n\");\n\t\targp_help(&argp, stderr, ARGP_HELP_USAGE, \"veristat\");\n\t\treturn 1;\n\t}\n\tif (env.verbose && env.log_level == 0)\n\t\tenv.log_level = 1;\n\n\tif (env.output_spec.spec_cnt == 0) {\n\t\tif (env.out_fmt == RESFMT_CSV)\n\t\t\tenv.output_spec = default_csv_output_spec;\n\t\telse\n\t\t\tenv.output_spec = default_output_spec;\n\t}\n\tif (env.sort_spec.spec_cnt == 0)\n\t\tenv.sort_spec = default_sort_spec;\n\n\tif (env.comparison_mode && env.replay_mode) {\n\t\tfprintf(stderr, \"Can't specify replay and comparison mode at the same time!\\n\\n\");\n\t\targp_help(&argp, stderr, ARGP_HELP_USAGE, \"veristat\");\n\t\treturn 1;\n\t}\n\n\tif (env.comparison_mode)\n\t\terr = handle_comparison_mode();\n\telse if (env.replay_mode)\n\t\terr = handle_replay_mode();\n\telse\n\t\terr = handle_verif_mode();\n\n\tfree_verif_stats(env.prog_stats, env.prog_stat_cnt);\n\tfree_verif_stats(env.baseline_stats, env.baseline_stat_cnt);\n\tfree(env.join_stats);\n\tfor (i = 0; i < env.filename_cnt; i++)\n\t\tfree(env.filenames[i]);\n\tfree(env.filenames);\n\tfor (i = 0; i < env.allow_filter_cnt; i++) {\n\t\tfree(env.allow_filters[i].any_glob);\n\t\tfree(env.allow_filters[i].file_glob);\n\t\tfree(env.allow_filters[i].prog_glob);\n\t}\n\tfree(env.allow_filters);\n\tfor (i = 0; i < env.deny_filter_cnt; i++) {\n\t\tfree(env.deny_filters[i].any_glob);\n\t\tfree(env.deny_filters[i].file_glob);\n\t\tfree(env.deny_filters[i].prog_glob);\n\t}\n\tfree(env.deny_filters);\n\treturn -err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}