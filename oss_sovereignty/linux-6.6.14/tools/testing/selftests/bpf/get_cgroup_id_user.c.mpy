{
  "module_name": "get_cgroup_id_user.c",
  "hash_id": "5177c13c96c6e28a63bf1a35b6c04447b8c1e5e935f2661aa87d730537c5f62c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/get_cgroup_id_user.c",
  "human_readable_source": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <syscall.h>\n#include <unistd.h>\n#include <linux/perf_event.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <linux/bpf.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"cgroup_helpers.h\"\n#include \"testing_helpers.h\"\n\n#define CHECK(condition, tag, format...) ({\t\t\\\n\tint __ret = !!(condition);\t\t\t\\\n\tif (__ret) {\t\t\t\t\t\\\n\t\tprintf(\"%s:FAIL:%s \", __func__, tag);\t\\\n\t\tprintf(format);\t\t\t\t\\\n\t} else {\t\t\t\t\t\\\n\t\tprintf(\"%s:PASS:%s\\n\", __func__, tag);\t\\\n\t}\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\\\n})\n\nstatic int bpf_find_map(const char *test, struct bpf_object *obj,\n\t\t\tconst char *name)\n{\n\tstruct bpf_map *map;\n\n\tmap = bpf_object__find_map_by_name(obj, name);\n\tif (!map)\n\t\treturn -1;\n\treturn bpf_map__fd(map);\n}\n\n#define TEST_CGROUP \"/test-bpf-get-cgroup-id/\"\n\nint main(int argc, char **argv)\n{\n\tconst char *probe_name = \"syscalls/sys_enter_nanosleep\";\n\tconst char *file = \"get_cgroup_id_kern.bpf.o\";\n\tint err, bytes, efd, prog_fd, pmu_fd;\n\tint cgroup_fd, cgidmap_fd, pidmap_fd;\n\tstruct perf_event_attr attr = {};\n\tstruct bpf_object *obj;\n\t__u64 kcgid = 0, ucgid;\n\t__u32 key = 0, pid;\n\tint exit_code = 1;\n\tchar buf[256];\n\tconst struct timespec req = {\n\t\t.tv_sec = 1,\n\t\t.tv_nsec = 0,\n\t};\n\n\tcgroup_fd = cgroup_setup_and_join(TEST_CGROUP);\n\tif (CHECK(cgroup_fd < 0, \"cgroup_setup_and_join\", \"err %d errno %d\\n\", cgroup_fd, errno))\n\t\treturn 1;\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_TRACEPOINT, &obj, &prog_fd);\n\tif (CHECK(err, \"bpf_prog_test_load\", \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup_cgroup_env;\n\n\tcgidmap_fd = bpf_find_map(__func__, obj, \"cg_ids\");\n\tif (CHECK(cgidmap_fd < 0, \"bpf_find_map\", \"err %d errno %d\\n\",\n\t\t  cgidmap_fd, errno))\n\t\tgoto close_prog;\n\n\tpidmap_fd = bpf_find_map(__func__, obj, \"pidmap\");\n\tif (CHECK(pidmap_fd < 0, \"bpf_find_map\", \"err %d errno %d\\n\",\n\t\t  pidmap_fd, errno))\n\t\tgoto close_prog;\n\n\tpid = getpid();\n\tbpf_map_update_elem(pidmap_fd, &key, &pid, 0);\n\n\tif (access(\"/sys/kernel/tracing/trace\", F_OK) == 0) {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"/sys/kernel/tracing/events/%s/id\", probe_name);\n\t} else {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"/sys/kernel/debug/tracing/events/%s/id\", probe_name);\n\t}\n\tefd = open(buf, O_RDONLY, 0);\n\tif (CHECK(efd < 0, \"open\", \"err %d errno %d\\n\", efd, errno))\n\t\tgoto close_prog;\n\tbytes = read(efd, buf, sizeof(buf));\n\tclose(efd);\n\tif (CHECK(bytes <= 0 || bytes >= sizeof(buf), \"read\",\n\t\t  \"bytes %d errno %d\\n\", bytes, errno))\n\t\tgoto close_prog;\n\n\tattr.config = strtol(buf, NULL, 0);\n\tattr.type = PERF_TYPE_TRACEPOINT;\n\tattr.sample_type = PERF_SAMPLE_RAW;\n\tattr.sample_period = 1;\n\tattr.wakeup_events = 1;\n\n\t \n\tpmu_fd = syscall(__NR_perf_event_open, &attr, getpid(), -1, -1, 0);\n\tif (CHECK(pmu_fd < 0, \"perf_event_open\", \"err %d errno %d\\n\", pmu_fd,\n\t\t  errno))\n\t\tgoto close_prog;\n\n\terr = ioctl(pmu_fd, PERF_EVENT_IOC_ENABLE, 0);\n\tif (CHECK(err, \"perf_event_ioc_enable\", \"err %d errno %d\\n\", err,\n\t\t  errno))\n\t\tgoto close_pmu;\n\n\terr = ioctl(pmu_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n\tif (CHECK(err, \"perf_event_ioc_set_bpf\", \"err %d errno %d\\n\", err,\n\t\t  errno))\n\t\tgoto close_pmu;\n\n\t \n\tsyscall(__NR_nanosleep, &req, NULL);\n\n\terr = bpf_map_lookup_elem(cgidmap_fd, &key, &kcgid);\n\tif (CHECK(err, \"bpf_map_lookup_elem\", \"err %d errno %d\\n\", err, errno))\n\t\tgoto close_pmu;\n\n\tucgid = get_cgroup_id(TEST_CGROUP);\n\tif (CHECK(kcgid != ucgid, \"compare_cgroup_id\",\n\t\t  \"kern cgid %llx user cgid %llx\", kcgid, ucgid))\n\t\tgoto close_pmu;\n\n\texit_code = 0;\n\tprintf(\"%s:PASS\\n\", argv[0]);\n\nclose_pmu:\n\tclose(pmu_fd);\nclose_prog:\n\tbpf_object__close(obj);\ncleanup_cgroup_env:\n\tcleanup_cgroup_environment();\n\treturn exit_code;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}