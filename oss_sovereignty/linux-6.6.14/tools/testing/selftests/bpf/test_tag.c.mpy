{
  "module_name": "test_tag.c",
  "hash_id": "50ca9d7c1cb5d80970123d4949aff96211de5edafb7fbcab325e28f8394d95b1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_tag.c",
  "human_readable_source": "\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <sched.h>\n#include <limits.h>\n#include <assert.h>\n\n#include <sys/socket.h>\n\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/if_alg.h>\n\n#include <bpf/bpf.h>\n\n#include \"../../../include/linux/filter.h\"\n#include \"testing_helpers.h\"\n\nstatic struct bpf_insn prog[BPF_MAXINSNS];\n\nstatic void bpf_gen_imm_prog(unsigned int insns, int fd_map)\n{\n\tint i;\n\n\tsrand(time(NULL));\n\tfor (i = 0; i < insns; i++)\n\t\tprog[i] = BPF_ALU64_IMM(BPF_MOV, i % BPF_REG_10, rand());\n\tprog[i - 1] = BPF_EXIT_INSN();\n}\n\nstatic void bpf_gen_map_prog(unsigned int insns, int fd_map)\n{\n\tint i, j = 0;\n\n\tfor (i = 0; i + 1 < insns; i += 2) {\n\t\tstruct bpf_insn tmp[] = {\n\t\t\tBPF_LD_MAP_FD(j++ % BPF_REG_10, fd_map)\n\t\t};\n\n\t\tmemcpy(&prog[i], tmp, sizeof(tmp));\n\t}\n\tif (insns % 2 == 0)\n\t\tprog[insns - 2] = BPF_ALU64_IMM(BPF_MOV, i % BPF_REG_10, 42);\n\tprog[insns - 1] = BPF_EXIT_INSN();\n}\n\nstatic int bpf_try_load_prog(int insns, int fd_map,\n\t\t\t     void (*bpf_filler)(unsigned int insns,\n\t\t\t\t\t\tint fd_map))\n{\n\tint fd_prog;\n\n\tbpf_filler(insns, fd_map);\n\tfd_prog = bpf_test_load_program(BPF_PROG_TYPE_SCHED_CLS, prog, insns, \"\", 0,\n\t\t\t\t   NULL, 0);\n\tassert(fd_prog > 0);\n\tif (fd_map > 0)\n\t\tbpf_filler(insns, 0);\n\treturn fd_prog;\n}\n\nstatic int __hex2bin(char ch)\n{\n\tif ((ch >= '0') && (ch <= '9'))\n\t\treturn ch - '0';\n\tch = tolower(ch);\n\tif ((ch >= 'a') && (ch <= 'f'))\n\t\treturn ch - 'a' + 10;\n\treturn -1;\n}\n\nstatic int hex2bin(uint8_t *dst, const char *src, size_t count)\n{\n\twhile (count--) {\n\t\tint hi = __hex2bin(*src++);\n\t\tint lo = __hex2bin(*src++);\n\n\t\tif ((hi < 0) || (lo < 0))\n\t\t\treturn -1;\n\t\t*dst++ = (hi << 4) | lo;\n\t}\n\treturn 0;\n}\n\nstatic void tag_from_fdinfo(int fd_prog, uint8_t *tag, uint32_t len)\n{\n\tconst int prefix_len = sizeof(\"prog_tag:\\t\") - 1;\n\tchar buff[256];\n\tint ret = -1;\n\tFILE *fp;\n\n\tsnprintf(buff, sizeof(buff), \"/proc/%d/fdinfo/%d\", getpid(),\n\t\t fd_prog);\n\tfp = fopen(buff, \"r\");\n\tassert(fp);\n\n\twhile (fgets(buff, sizeof(buff), fp)) {\n\t\tif (strncmp(buff, \"prog_tag:\\t\", prefix_len))\n\t\t\tcontinue;\n\t\tret = hex2bin(tag, buff + prefix_len, len);\n\t\tbreak;\n\t}\n\n\tfclose(fp);\n\tassert(!ret);\n}\n\nstatic void tag_from_alg(int insns, uint8_t *tag, uint32_t len)\n{\n\tstatic const struct sockaddr_alg alg = {\n\t\t.salg_family\t= AF_ALG,\n\t\t.salg_type\t= \"hash\",\n\t\t.salg_name\t= \"sha1\",\n\t};\n\tint fd_base, fd_alg, ret;\n\tssize_t size;\n\n\tfd_base = socket(AF_ALG, SOCK_SEQPACKET, 0);\n\tassert(fd_base > 0);\n\n\tret = bind(fd_base, (struct sockaddr *)&alg, sizeof(alg));\n\tassert(!ret);\n\n\tfd_alg = accept(fd_base, NULL, 0);\n\tassert(fd_alg > 0);\n\n\tinsns *= sizeof(struct bpf_insn);\n\tsize = write(fd_alg, prog, insns);\n\tassert(size == insns);\n\n\tsize = read(fd_alg, tag, len);\n\tassert(size == len);\n\n\tclose(fd_alg);\n\tclose(fd_base);\n}\n\nstatic void tag_dump(const char *prefix, uint8_t *tag, uint32_t len)\n{\n\tint i;\n\n\tprintf(\"%s\", prefix);\n\tfor (i = 0; i < len; i++)\n\t\tprintf(\"%02x\", tag[i]);\n\tprintf(\"\\n\");\n}\n\nstatic void tag_exit_report(int insns, int fd_map, uint8_t *ftag,\n\t\t\t    uint8_t *atag, uint32_t len)\n{\n\tprintf(\"Program tag mismatch for %d insns%s!\\n\", insns,\n\t       fd_map < 0 ? \"\" : \" with map\");\n\n\ttag_dump(\"  fdinfo result: \", ftag, len);\n\ttag_dump(\"  af_alg result: \", atag, len);\n\texit(1);\n}\n\nstatic void do_test(uint32_t *tests, int start_insns, int fd_map,\n\t\t    void (*bpf_filler)(unsigned int insns, int fd))\n{\n\tint i, fd_prog;\n\n\tfor (i = start_insns; i <= BPF_MAXINSNS; i++) {\n\t\tuint8_t ftag[8], atag[sizeof(ftag)];\n\n\t\tfd_prog = bpf_try_load_prog(i, fd_map, bpf_filler);\n\t\ttag_from_fdinfo(fd_prog, ftag, sizeof(ftag));\n\t\ttag_from_alg(i, atag, sizeof(atag));\n\t\tif (memcmp(ftag, atag, sizeof(ftag)))\n\t\t\ttag_exit_report(i, fd_map, ftag, atag, sizeof(ftag));\n\n\t\tclose(fd_prog);\n\t\tsched_yield();\n\t\t(*tests)++;\n\t}\n}\n\nint main(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tuint32_t tests = 0;\n\tint i, fd_map;\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tfd_map = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(int),\n\t\t\t\tsizeof(int), 1, &opts);\n\tassert(fd_map > 0);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tdo_test(&tests, 2, -1,     bpf_gen_imm_prog);\n\t\tdo_test(&tests, 3, fd_map, bpf_gen_map_prog);\n\t}\n\n\tprintf(\"test_tag: OK (%u tests)\\n\", tests);\n\tclose(fd_map);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}