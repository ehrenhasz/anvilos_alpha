{
  "module_name": "test_maps.c",
  "hash_id": "21cfd69f546b9f85fa1ce2bc5b788988183f1b4879006f86d79259e2d13d29c7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_maps.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/bpf.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"bpf_util.h\"\n#include \"test_maps.h\"\n#include \"testing_helpers.h\"\n\n#ifndef ENOTSUPP\n#define ENOTSUPP 524\n#endif\n\nint skips;\n\nstatic struct bpf_map_create_opts map_opts = { .sz = sizeof(map_opts) };\n\nstatic void test_hashmap(unsigned int task, void *data)\n{\n\tlong long key, next_key, first_key, value;\n\tint fd;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value), 2, &map_opts);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create hashmap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tkey = 1;\n\tvalue = 1234;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) == 0);\n\n\tvalue = 0;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t        \n\t       errno == EEXIST);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, -1) < 0 &&\n\t       errno == EINVAL);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) == 0 && value == 1234);\n\n\tkey = 2;\n\tvalue = 1234;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) == 0);\n\n\t \n\tassert(bpf_map_lookup_and_delete_elem(fd, &key, &value) == 0 && value == 1234);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_EXIST) < 0 &&\n\t        \n\t       errno == ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) == 0);\n\n\t \n\tkey = 0;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_EXIST) == 0);\n\tkey = 2;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) == 0);\n\tkey = 3;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tkey = 0;\n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &first_key) == 0 &&\n\t       (first_key == 1 || first_key == 2));\n\tassert(bpf_map_get_next_key(fd, &key, &next_key) == 0 &&\n\t       (next_key == first_key));\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) == 0 &&\n\t       (next_key == 1 || next_key == 2) &&\n\t       (next_key != first_key));\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) < 0 &&\n\t       errno == ENOENT);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_delete_elem(fd, &key) == 0);\n\tkey = 2;\n\tassert(bpf_map_delete_elem(fd, &key) == 0);\n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == ENOENT);\n\n\tkey = 0;\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &next_key) < 0 &&\n\t       errno == ENOENT);\n\tassert(bpf_map_get_next_key(fd, &key, &next_key) < 0 &&\n\t       errno == ENOENT);\n\n\tclose(fd);\n}\n\nstatic void test_hashmap_sizes(unsigned int task, void *data)\n{\n\tint fd, i, j;\n\n\tfor (i = 1; i <= 512; i <<= 1)\n\t\tfor (j = 1; j <= 1 << 18; j <<= 1) {\n\t\t\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, i, j, 2, &map_opts);\n\t\t\tif (fd < 0) {\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\treturn;\n\t\t\t\tprintf(\"Failed to create hashmap key=%d value=%d '%s'\\n\",\n\t\t\t\t       i, j, strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\tusleep(10);  \n\t\t}\n}\n\nstatic void test_hashmap_percpu(unsigned int task, void *data)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tBPF_DECLARE_PERCPU(long, value);\n\tlong long key, next_key, first_key;\n\tint expected_key_mask = 0;\n\tint fd, i;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_PERCPU_HASH, NULL, sizeof(key),\n\t\t\t    sizeof(bpf_percpu(value, 0)), 2, &map_opts);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create hashmap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_percpu(value, i) = i + 100;\n\n\tkey = 1;\n\t \n\tassert(!(expected_key_mask & key));\n\tassert(bpf_map_update_elem(fd, &key, value, BPF_ANY) == 0);\n\n\t \n\tassert(bpf_map_lookup_and_delete_elem(fd, &key, value) == 0 &&\n\t       bpf_percpu(value,0) == 100);\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_percpu(value,i) = i + 100;\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, value, BPF_NOEXIST) == 0);\n\texpected_key_mask |= key;\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, value, BPF_NOEXIST) < 0 &&\n\t        \n\t       errno == EEXIST);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, value, -1) < 0 &&\n\t       errno == EINVAL);\n\n\t \n\tbpf_percpu(value, 0) = 1;\n\tassert(bpf_map_lookup_elem(fd, &key, value) == 0 &&\n\t       bpf_percpu(value, 0) == 100);\n\n\tkey = 2;\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, value) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, value, BPF_EXIST) < 0 &&\n\t        \n\t       errno == ENOENT);\n\n\t \n\tassert(!(expected_key_mask & key));\n\tassert(bpf_map_update_elem(fd, &key, value, BPF_NOEXIST) == 0);\n\texpected_key_mask |= key;\n\n\t \n\tkey = 0;\n\tassert(bpf_map_update_elem(fd, &key, value, BPF_NOEXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &first_key) == 0 &&\n\t       ((expected_key_mask & first_key) == first_key));\n\twhile (!bpf_map_get_next_key(fd, &key, &next_key)) {\n\t\tif (first_key) {\n\t\t\tassert(next_key == first_key);\n\t\t\tfirst_key = 0;\n\t\t}\n\t\tassert((expected_key_mask & next_key) == next_key);\n\t\texpected_key_mask &= ~next_key;\n\n\t\tassert(bpf_map_lookup_elem(fd, &next_key, value) == 0);\n\n\t\tfor (i = 0; i < nr_cpus; i++)\n\t\t\tassert(bpf_percpu(value, i) == i + 100);\n\n\t\tkey = next_key;\n\t}\n\tassert(errno == ENOENT);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_update_elem(fd, &key, value, BPF_EXIST) == 0);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_delete_elem(fd, &key) == 0);\n\tkey = 2;\n\tassert(bpf_map_delete_elem(fd, &key) == 0);\n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == ENOENT);\n\n\tkey = 0;\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &next_key) < 0 &&\n\t       errno == ENOENT);\n\tassert(bpf_map_get_next_key(fd, &key, &next_key) < 0 &&\n\t       errno == ENOENT);\n\n\tclose(fd);\n}\n\n#define VALUE_SIZE 3\nstatic int helper_fill_hashmap(int max_entries)\n{\n\tint i, fd, ret;\n\tlong long key, value[VALUE_SIZE] = {};\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value),\n\t\t\t    max_entries, &map_opts);\n\tCHECK(fd < 0,\n\t      \"failed to create hashmap\",\n\t      \"err: %s, flags: 0x%x\\n\", strerror(errno), map_opts.map_flags);\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkey = i; value[0] = key;\n\t\tret = bpf_map_update_elem(fd, &key, value, BPF_NOEXIST);\n\t\tCHECK(ret != 0,\n\t\t      \"can't update hashmap\",\n\t\t      \"err: %s\\n\", strerror(ret));\n\t}\n\n\treturn fd;\n}\n\nstatic void test_hashmap_walk(unsigned int task, void *data)\n{\n\tint fd, i, max_entries = 10000;\n\tlong long key, value[VALUE_SIZE], next_key;\n\tbool next_key_valid = true;\n\n\tfd = helper_fill_hashmap(max_entries);\n\n\tfor (i = 0; bpf_map_get_next_key(fd, !i ? NULL : &key,\n\t\t\t\t\t &next_key) == 0; i++) {\n\t\tkey = next_key;\n\t\tassert(bpf_map_lookup_elem(fd, &key, value) == 0);\n\t}\n\n\tassert(i == max_entries);\n\n\tassert(bpf_map_get_next_key(fd, NULL, &key) == 0);\n\tfor (i = 0; next_key_valid; i++) {\n\t\tnext_key_valid = bpf_map_get_next_key(fd, &key, &next_key) == 0;\n\t\tassert(bpf_map_lookup_elem(fd, &key, value) == 0);\n\t\tvalue[0]++;\n\t\tassert(bpf_map_update_elem(fd, &key, value, BPF_EXIST) == 0);\n\t\tkey = next_key;\n\t}\n\n\tassert(i == max_entries);\n\n\tfor (i = 0; bpf_map_get_next_key(fd, !i ? NULL : &key,\n\t\t\t\t\t &next_key) == 0; i++) {\n\t\tkey = next_key;\n\t\tassert(bpf_map_lookup_elem(fd, &key, value) == 0);\n\t\tassert(value[0] - 1 == key);\n\t}\n\n\tassert(i == max_entries);\n\tclose(fd);\n}\n\nstatic void test_hashmap_zero_seed(void)\n{\n\tint i, first, second, old_flags;\n\tlong long key, next_first, next_second;\n\n\told_flags = map_opts.map_flags;\n\tmap_opts.map_flags |= BPF_F_ZERO_SEED;\n\n\tfirst = helper_fill_hashmap(3);\n\tsecond = helper_fill_hashmap(3);\n\n\tfor (i = 0; ; i++) {\n\t\tvoid *key_ptr = !i ? NULL : &key;\n\n\t\tif (bpf_map_get_next_key(first, key_ptr, &next_first) != 0)\n\t\t\tbreak;\n\n\t\tCHECK(bpf_map_get_next_key(second, key_ptr, &next_second) != 0,\n\t\t      \"next_key for second map must succeed\",\n\t\t      \"key_ptr: %p\", key_ptr);\n\t\tCHECK(next_first != next_second,\n\t\t      \"keys must match\",\n\t\t      \"i: %d first: %lld second: %lld\\n\", i,\n\t\t      next_first, next_second);\n\n\t\tkey = next_first;\n\t}\n\n\tmap_opts.map_flags = old_flags;\n\tclose(first);\n\tclose(second);\n}\n\nstatic void test_arraymap(unsigned int task, void *data)\n{\n\tint key, next_key, fd;\n\tlong long value;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL, sizeof(key), sizeof(value), 2, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create arraymap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tkey = 1;\n\tvalue = 1234;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) == 0);\n\n\tvalue = 0;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t       errno == EEXIST);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) == 0 && value == 1234);\n\n\tkey = 0;\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) == 0 && value == 0);\n\n\t \n\tkey = 2;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_EXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &next_key) == 0 &&\n\t       next_key == 0);\n\tassert(bpf_map_get_next_key(fd, &key, &next_key) == 0 &&\n\t       next_key == 0);\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) == 0 &&\n\t       next_key == 1);\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) < 0 &&\n\t       errno == ENOENT);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == EINVAL);\n\n\tclose(fd);\n}\n\nstatic void test_arraymap_percpu(unsigned int task, void *data)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tBPF_DECLARE_PERCPU(long, values);\n\tint key, next_key, fd, i;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_PERCPU_ARRAY, NULL, sizeof(key),\n\t\t\t    sizeof(bpf_percpu(values, 0)), 2, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create arraymap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_percpu(values, i) = i + 100;\n\n\tkey = 1;\n\t \n\tassert(bpf_map_update_elem(fd, &key, values, BPF_ANY) == 0);\n\n\tbpf_percpu(values, 0) = 0;\n\tassert(bpf_map_update_elem(fd, &key, values, BPF_NOEXIST) < 0 &&\n\t       errno == EEXIST);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, values) == 0 &&\n\t       bpf_percpu(values, 0) == 100);\n\n\tkey = 0;\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, values) == 0 &&\n\t       bpf_percpu(values, 0) == 0 &&\n\t       bpf_percpu(values, nr_cpus - 1) == 0);\n\n\t \n\tkey = 2;\n\tassert(bpf_map_update_elem(fd, &key, values, BPF_EXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, values) < 0 && errno == ENOENT);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &next_key) == 0 &&\n\t       next_key == 0);\n\tassert(bpf_map_get_next_key(fd, &key, &next_key) == 0 &&\n\t       next_key == 0);\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) == 0 &&\n\t       next_key == 1);\n\tassert(bpf_map_get_next_key(fd, &next_key, &next_key) < 0 &&\n\t       errno == ENOENT);\n\n\t \n\tkey = 1;\n\tassert(bpf_map_delete_elem(fd, &key) < 0 && errno == EINVAL);\n\n\tclose(fd);\n}\n\nstatic void test_arraymap_percpu_many_keys(void)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tBPF_DECLARE_PERCPU(long, values);\n\t \n\tunsigned int nr_keys = 2000;\n\tint key, fd, i;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_PERCPU_ARRAY, NULL, sizeof(key),\n\t\t\t    sizeof(bpf_percpu(values, 0)), nr_keys, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create per-cpu arraymap '%s'!\\n\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_percpu(values, i) = i + 10;\n\n\tfor (key = 0; key < nr_keys; key++)\n\t\tassert(bpf_map_update_elem(fd, &key, values, BPF_ANY) == 0);\n\n\tfor (key = 0; key < nr_keys; key++) {\n\t\tfor (i = 0; i < nr_cpus; i++)\n\t\t\tbpf_percpu(values, i) = 0;\n\n\t\tassert(bpf_map_lookup_elem(fd, &key, values) == 0);\n\n\t\tfor (i = 0; i < nr_cpus; i++)\n\t\t\tassert(bpf_percpu(values, i) == i + 10);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_devmap(unsigned int task, void *data)\n{\n\tint fd;\n\t__u32 key, value;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_DEVMAP, NULL, sizeof(key), sizeof(value), 2, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create devmap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_devmap_hash(unsigned int task, void *data)\n{\n\tint fd;\n\t__u32 key, value;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_DEVMAP_HASH, NULL, sizeof(key), sizeof(value), 2, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create devmap_hash '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n}\n\nstatic void test_queuemap(unsigned int task, void *data)\n{\n\tconst int MAP_SIZE = 32;\n\t__u32 vals[MAP_SIZE + MAP_SIZE/2], val;\n\tint fd, i;\n\n\t \n\tfor (i = 0; i < MAP_SIZE + MAP_SIZE/2; i++)\n\t\tvals[i] = rand();\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_QUEUE, NULL, 4, sizeof(val), MAP_SIZE, &map_opts);\n\tassert(fd < 0 && errno == EINVAL);\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_QUEUE, NULL, 0, sizeof(val), MAP_SIZE, &map_opts);\n\t \n\tif (map_opts.map_flags & BPF_F_NO_PREALLOC) {\n\t\tassert(fd < 0 && errno == EINVAL);\n\t\treturn;\n\t}\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create queuemap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++)\n\t\tassert(bpf_map_update_elem(fd, NULL, &vals[i], 0) == 0);\n\n\t \n\tassert(bpf_map_update_elem(fd, NULL, &val, 0) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, NULL, &val) == 0 && val == vals[0]);\n\n\t \n\tfor (i = MAP_SIZE; i < MAP_SIZE + MAP_SIZE/2; i++)\n\t\tassert(bpf_map_update_elem(fd, NULL, &vals[i], BPF_EXIST) == 0);\n\n\t \n\tfor (i = MAP_SIZE/2; i < MAP_SIZE + MAP_SIZE/2; i++)\n\t\tassert(bpf_map_lookup_and_delete_elem(fd, NULL, &val) == 0 &&\n\t\t       val == vals[i]);\n\n\t \n\tassert(bpf_map_lookup_and_delete_elem(fd, NULL, &val) < 0 &&\n\t       errno == ENOENT);\n\n\t \n\tassert(bpf_map_delete_elem(fd, NULL) < 0 && errno == EINVAL);\n\tassert(bpf_map_get_next_key(fd, NULL, NULL) < 0 && errno == EINVAL);\n\n\tclose(fd);\n}\n\nstatic void test_stackmap(unsigned int task, void *data)\n{\n\tconst int MAP_SIZE = 32;\n\t__u32 vals[MAP_SIZE + MAP_SIZE/2], val;\n\tint fd, i;\n\n\t \n\tfor (i = 0; i < MAP_SIZE + MAP_SIZE/2; i++)\n\t\tvals[i] = rand();\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_STACK, NULL, 4, sizeof(val), MAP_SIZE, &map_opts);\n\tassert(fd < 0 && errno == EINVAL);\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_STACK, NULL, 0, sizeof(val), MAP_SIZE, &map_opts);\n\t \n\tif (map_opts.map_flags & BPF_F_NO_PREALLOC) {\n\t\tassert(fd < 0 && errno == EINVAL);\n\t\treturn;\n\t}\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create stackmap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++)\n\t\tassert(bpf_map_update_elem(fd, NULL, &vals[i], 0) == 0);\n\n\t \n\tassert(bpf_map_update_elem(fd, NULL, &val, 0) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, NULL, &val) == 0 && val == vals[i - 1]);\n\n\t \n\tfor (i = MAP_SIZE; i < MAP_SIZE + MAP_SIZE/2; i++)\n\t\tassert(bpf_map_update_elem(fd, NULL, &vals[i], BPF_EXIST) == 0);\n\n\t \n\tfor (i = MAP_SIZE + MAP_SIZE/2 - 1; i >= MAP_SIZE/2; i--)\n\t\tassert(bpf_map_lookup_and_delete_elem(fd, NULL, &val) == 0 &&\n\t\t       val == vals[i]);\n\n\t \n\tassert(bpf_map_lookup_and_delete_elem(fd, NULL, &val) < 0 &&\n\t       errno == ENOENT);\n\n\t \n\tassert(bpf_map_delete_elem(fd, NULL) < 0 && errno == EINVAL);\n\tassert(bpf_map_get_next_key(fd, NULL, NULL) < 0 && errno == EINVAL);\n\n\tclose(fd);\n}\n\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <sys/select.h>\n#include <linux/err.h>\n#define SOCKMAP_PARSE_PROG \"./sockmap_parse_prog.bpf.o\"\n#define SOCKMAP_VERDICT_PROG \"./sockmap_verdict_prog.bpf.o\"\n#define SOCKMAP_TCP_MSG_PROG \"./sockmap_tcp_msg_prog.bpf.o\"\nstatic void test_sockmap(unsigned int tasks, void *data)\n{\n\tstruct bpf_map *bpf_map_rx, *bpf_map_tx, *bpf_map_msg, *bpf_map_break;\n\tint map_fd_msg = 0, map_fd_rx = 0, map_fd_tx = 0, map_fd_break;\n\tstruct bpf_object *parse_obj, *verdict_obj, *msg_obj;\n\tint ports[] = {50200, 50201, 50202, 50204};\n\tint err, i, fd, udp, sfd[6] = {0xdeadbeef};\n\tu8 buf[20] = {0x0, 0x5, 0x3, 0x2, 0x1, 0x0};\n\tint parse_prog, verdict_prog, msg_prog;\n\tstruct sockaddr_in addr;\n\tint one = 1, s, sc, rc;\n\tstruct timeval to;\n\t__u32 key, value;\n\tpid_t pid[tasks];\n\tfd_set w;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tsfd[i] = socket(AF_INET, SOCK_STREAM, 0);\n\t\tif (sfd[i] < 0)\n\t\t\tgoto out;\n\t\terr = setsockopt(sfd[i], SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t (char *)&one, sizeof(one));\n\t\tif (err) {\n\t\t\tprintf(\"failed to setsockopt\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = ioctl(sfd[i], FIONBIO, (char *)&one);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed to ioctl\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(&addr, 0, sizeof(struct sockaddr_in));\n\t\taddr.sin_family = AF_INET;\n\t\taddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\taddr.sin_port = htons(ports[i]);\n\t\terr = bind(sfd[i], (struct sockaddr *)&addr, sizeof(addr));\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed to bind: err %i: %i:%i\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out;\n\t\t}\n\t\terr = listen(sfd[i], 32);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed to listen\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 2; i < 4; i++) {\n\t\tsfd[i] = socket(AF_INET, SOCK_STREAM, 0);\n\t\tif (sfd[i] < 0)\n\t\t\tgoto out;\n\t\terr = setsockopt(sfd[i], SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t (char *)&one, sizeof(one));\n\t\tif (err) {\n\t\t\tprintf(\"set sock opt\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(&addr, 0, sizeof(struct sockaddr_in));\n\t\taddr.sin_family = AF_INET;\n\t\taddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\taddr.sin_port = htons(ports[i - 2]);\n\t\terr = connect(sfd[i], (struct sockaddr *)&addr, sizeof(addr));\n\t\tif (err) {\n\t\t\tprintf(\"failed to connect\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\n\tfor (i = 4; i < 6; i++) {\n\t\tsfd[i] = accept(sfd[i - 4], NULL, NULL);\n\t\tif (sfd[i] < 0) {\n\t\t\tprintf(\"accept failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_SOCKMAP, NULL,\n\t\t\t    sizeof(key), sizeof(value),\n\t\t\t    6, NULL);\n\tif (fd < 0) {\n\t\tif (!libbpf_probe_bpf_map_type(BPF_MAP_TYPE_SOCKMAP, NULL)) {\n\t\t\tprintf(\"%s SKIP (unsupported map type BPF_MAP_TYPE_SOCKMAP)\\n\",\n\t\t\t       __func__);\n\t\t\tskips++;\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tclose(sfd[i]);\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(\"Failed to create sockmap %i\\n\", fd);\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\tudp = socket(AF_INET, SOCK_DGRAM, 0);\n\ti = 0;\n\terr = bpf_map_update_elem(fd, &i, &udp, BPF_ANY);\n\tif (err) {\n\t\tprintf(\"Failed socket update SOCK_DGRAM '%i:%i'\\n\",\n\t\t       i, udp);\n\t\tgoto out_sockmap;\n\t}\n\tclose(udp);\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_ANY);\n\t\tif (err) {\n\t\t\tprintf(\"Failed noprog update sockmap '%i:%i'\\n\",\n\t\t\t       i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t}\n\n\t \n\terr = bpf_prog_attach(-1, fd, BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (!err) {\n\t\tprintf(\"Failed invalid parser prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(-1, fd, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (!err) {\n\t\tprintf(\"Failed invalid verdict prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(-1, fd, BPF_SK_MSG_VERDICT, 0);\n\tif (!err) {\n\t\tprintf(\"Failed invalid msg verdict prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(-1, fd, __MAX_BPF_ATTACH_TYPE, 0);\n\tif (!err) {\n\t\tprintf(\"Failed unknown prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach(fd, BPF_SK_SKB_STREAM_PARSER);\n\tif (!err) {\n\t\tprintf(\"Failed empty parser prog detach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach(fd, BPF_SK_SKB_STREAM_VERDICT);\n\tif (!err) {\n\t\tprintf(\"Failed empty verdict prog detach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach(fd, BPF_SK_MSG_VERDICT);\n\tif (!err) {\n\t\tprintf(\"Failed empty msg verdict prog detach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach(fd, __MAX_BPF_ATTACH_TYPE);\n\tif (!err) {\n\t\tprintf(\"Detach invalid prog successful\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\terr = bpf_prog_test_load(SOCKMAP_PARSE_PROG,\n\t\t\t    BPF_PROG_TYPE_SK_SKB, &parse_obj, &parse_prog);\n\tif (err) {\n\t\tprintf(\"Failed to load SK_SKB parse prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_test_load(SOCKMAP_TCP_MSG_PROG,\n\t\t\t    BPF_PROG_TYPE_SK_MSG, &msg_obj, &msg_prog);\n\tif (err) {\n\t\tprintf(\"Failed to load SK_SKB msg prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_test_load(SOCKMAP_VERDICT_PROG,\n\t\t\t    BPF_PROG_TYPE_SK_SKB, &verdict_obj, &verdict_prog);\n\tif (err) {\n\t\tprintf(\"Failed to load SK_SKB verdict prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tbpf_map_rx = bpf_object__find_map_by_name(verdict_obj, \"sock_map_rx\");\n\tif (!bpf_map_rx) {\n\t\tprintf(\"Failed to load map rx from verdict prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tmap_fd_rx = bpf_map__fd(bpf_map_rx);\n\tif (map_fd_rx < 0) {\n\t\tprintf(\"Failed to get map rx fd\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tbpf_map_tx = bpf_object__find_map_by_name(verdict_obj, \"sock_map_tx\");\n\tif (!bpf_map_tx) {\n\t\tprintf(\"Failed to load map tx from verdict prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tmap_fd_tx = bpf_map__fd(bpf_map_tx);\n\tif (map_fd_tx < 0) {\n\t\tprintf(\"Failed to get map tx fd\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tbpf_map_msg = bpf_object__find_map_by_name(verdict_obj, \"sock_map_msg\");\n\tif (!bpf_map_msg) {\n\t\tprintf(\"Failed to load map msg from msg_verdict prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tmap_fd_msg = bpf_map__fd(bpf_map_msg);\n\tif (map_fd_msg < 0) {\n\t\tprintf(\"Failed to get map msg fd\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tbpf_map_break = bpf_object__find_map_by_name(verdict_obj, \"sock_map_break\");\n\tif (!bpf_map_break) {\n\t\tprintf(\"Failed to load map tx from verdict prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tmap_fd_break = bpf_map__fd(bpf_map_break);\n\tif (map_fd_break < 0) {\n\t\tprintf(\"Failed to get map tx fd\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(parse_prog, map_fd_break,\n\t\t\t      BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (!err) {\n\t\tprintf(\"Allowed attaching SK_SKB program to invalid map\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(parse_prog, map_fd_rx,\n\t\t      BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (err) {\n\t\tprintf(\"Failed stream parser bpf prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(verdict_prog, map_fd_rx,\n\t\t\t      BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err) {\n\t\tprintf(\"Failed stream verdict bpf prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(msg_prog, map_fd_msg, BPF_SK_MSG_VERDICT, 0);\n\tif (err) {\n\t\tprintf(\"Failed msg verdict bpf prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_attach(verdict_prog, map_fd_rx,\n\t\t\t      __MAX_BPF_ATTACH_TYPE, 0);\n\tif (!err) {\n\t\tprintf(\"Attached unknown bpf prog\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\tfor (i = 2; i < 6; i++) {\n\t\terr = bpf_map_update_elem(map_fd_rx, &i, &sfd[i], BPF_ANY);\n\t\tif (err) {\n\t\t\tprintf(\"Failed map_fd_rx update sockmap %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t\terr = bpf_map_update_elem(map_fd_tx, &i, &sfd[i], BPF_ANY);\n\t\tif (err) {\n\t\t\tprintf(\"Failed map_fd_tx update sockmap %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t}\n\n\t \n\tfor (i = 2; i < 4; i++) {\n\t\terr = bpf_map_delete_elem(map_fd_rx, &i);\n\t\tif (err) {\n\t\t\tprintf(\"Failed delete sockmap rx %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t\terr = bpf_map_delete_elem(map_fd_tx, &i);\n\t\tif (err) {\n\t\t\tprintf(\"Failed delete sockmap tx %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t}\n\n\t \n\ti = 0;\n\terr = bpf_map_update_elem(map_fd_msg, &i, &sfd[2], BPF_ANY);\n\tif (err) {\n\t\tprintf(\"Failed map_fd_msg update sockmap %i\\n\", err);\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tbuf[0] = i;\n\t\tbuf[1] = 0x5;\n\t\tsc = send(sfd[2], buf, 20, 0);\n\t\tif (sc < 0) {\n\t\t\tprintf(\"Failed sockmap send\\n\");\n\t\t\tgoto out_sockmap;\n\t\t}\n\n\t\tFD_ZERO(&w);\n\t\tFD_SET(sfd[3], &w);\n\t\tto.tv_sec = 30;\n\t\tto.tv_usec = 0;\n\t\ts = select(sfd[3] + 1, &w, NULL, NULL, &to);\n\t\tif (s == -1) {\n\t\t\tperror(\"Failed sockmap select()\");\n\t\t\tgoto out_sockmap;\n\t\t} else if (!s) {\n\t\t\tprintf(\"Failed sockmap unexpected timeout\\n\");\n\t\t\tgoto out_sockmap;\n\t\t}\n\n\t\tif (!FD_ISSET(sfd[3], &w)) {\n\t\t\tprintf(\"Failed sockmap select/recv\\n\");\n\t\t\tgoto out_sockmap;\n\t\t}\n\n\t\trc = recv(sfd[3], buf, sizeof(buf), 0);\n\t\tif (rc < 0) {\n\t\t\tprintf(\"Failed sockmap recv\\n\");\n\t\t\tgoto out_sockmap;\n\t\t}\n\t}\n\n\t \n\tbuf[0] = 1;\n\tbuf[1] = 12;\n\tsc = send(sfd[2], buf, 20, 0);\n\tif (sc < 0) {\n\t\tprintf(\"Failed sockmap send\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\ti = 2;\n\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_NOEXIST);\n\tif (!err) {\n\t\tprintf(\"Failed allowed sockmap dup slot BPF_NOEXIST\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_ANY);\n\tif (err) {\n\t\tprintf(\"Failed sockmap update new slot BPF_ANY\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_EXIST);\n\tif (err) {\n\t\tprintf(\"Failed sockmap update new slot BPF_EXIST\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\tfor (i = 2; i < 6; i++) {\n\t\terr = bpf_map_delete_elem(fd, &i);\n\t\tif (err) {\n\t\t\tprintf(\"Failed delete sockmap %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t}\n\t}\n\n\t \n\terr = bpf_prog_attach(parse_prog, fd,\n\t\t\t      BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (err) {\n\t\tprintf(\"Failed fd bpf parse prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\terr = bpf_prog_attach(verdict_prog, fd,\n\t\t\t      BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err) {\n\t\tprintf(\"Failed fd bpf verdict prog attach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\tfor (i = 4; i < 6; i++) {\n\t\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_ANY);\n\t\tif (!err) {\n\t\t\tprintf(\"Failed allowed duplicate programs in update ANY sockmap %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_NOEXIST);\n\t\tif (!err) {\n\t\t\tprintf(\"Failed allowed duplicate program in update NOEXIST sockmap  %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t\terr = bpf_map_update_elem(fd, &i, &sfd[i], BPF_EXIST);\n\t\tif (!err) {\n\t\t\tprintf(\"Failed allowed duplicate program in update EXIST sockmap  %i '%i:%i'\\n\",\n\t\t\t       err, i, sfd[i]);\n\t\t\tgoto out_sockmap;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < tasks; i++) {\n\t\tpid[i] = fork();\n\t\tif (pid[i] == 0) {\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbpf_map_delete_elem(map_fd_tx, &i);\n\t\t\t\tbpf_map_delete_elem(map_fd_rx, &i);\n\t\t\t\tbpf_map_update_elem(map_fd_tx, &i,\n\t\t\t\t\t\t    &sfd[i], BPF_ANY);\n\t\t\t\tbpf_map_update_elem(map_fd_rx, &i,\n\t\t\t\t\t\t    &sfd[i], BPF_ANY);\n\t\t\t}\n\t\t\texit(0);\n\t\t} else if (pid[i] == -1) {\n\t\t\tprintf(\"Couldn't spawn #%d process!\\n\", i);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tint status;\n\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\tassert(status == 0);\n\t}\n\n\terr = bpf_prog_detach2(parse_prog, map_fd_rx, __MAX_BPF_ATTACH_TYPE);\n\tif (!err) {\n\t\tprintf(\"Detached an invalid prog type.\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach2(parse_prog, map_fd_rx, BPF_SK_SKB_STREAM_PARSER);\n\tif (err) {\n\t\tprintf(\"Failed parser prog detach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\terr = bpf_prog_detach2(verdict_prog, map_fd_rx, BPF_SK_SKB_STREAM_VERDICT);\n\tif (err) {\n\t\tprintf(\"Failed parser prog detach\\n\");\n\t\tgoto out_sockmap;\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tbpf_map_delete_elem(map_fd_tx, &i);\n\t\tbpf_map_delete_elem(map_fd_rx, &i);\n\t\tclose(sfd[i]);\n\t}\n\tclose(fd);\n\tclose(map_fd_rx);\n\tbpf_object__close(parse_obj);\n\tbpf_object__close(msg_obj);\n\tbpf_object__close(verdict_obj);\n\treturn;\nout:\n\tfor (i = 0; i < 6; i++)\n\t\tclose(sfd[i]);\n\tprintf(\"Failed to create sockmap '%i:%s'!\\n\", i, strerror(errno));\n\texit(1);\nout_sockmap:\n\tfor (i = 0; i < 6; i++) {\n\t\tif (map_fd_tx)\n\t\t\tbpf_map_delete_elem(map_fd_tx, &i);\n\t\tif (map_fd_rx)\n\t\t\tbpf_map_delete_elem(map_fd_rx, &i);\n\t\tclose(sfd[i]);\n\t}\n\tclose(fd);\n\texit(1);\n}\n\n#define MAPINMAP_PROG \"./test_map_in_map.bpf.o\"\n#define MAPINMAP_INVALID_PROG \"./test_map_in_map_invalid.bpf.o\"\nstatic void test_map_in_map(void)\n{\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tint mim_fd, fd, err;\n\tint pos = 0;\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\t__u32 id = 0;\n\tlibbpf_print_fn_t old_print_fn;\n\n\tobj = bpf_object__open(MAPINMAP_PROG);\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(int), sizeof(int), 2, NULL);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create hashmap '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tmap = bpf_object__find_map_by_name(obj, \"mim_array\");\n\tif (!map) {\n\t\tprintf(\"Failed to load array of maps from test prog\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\terr = bpf_map__set_inner_map_fd(map, fd);\n\tif (err) {\n\t\tprintf(\"Failed to set inner_map_fd for array of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\tmap = bpf_object__find_map_by_name(obj, \"mim_hash\");\n\tif (!map) {\n\t\tprintf(\"Failed to load hash of maps from test prog\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\terr = bpf_map__set_inner_map_fd(map, fd);\n\tif (err) {\n\t\tprintf(\"Failed to set inner_map_fd for hash of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\tbpf_object__load(obj);\n\n\tmap = bpf_object__find_map_by_name(obj, \"mim_array\");\n\tif (!map) {\n\t\tprintf(\"Failed to load array of maps from test prog\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\tmim_fd = bpf_map__fd(map);\n\tif (mim_fd < 0) {\n\t\tprintf(\"Failed to get descriptor for array of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\terr = bpf_map_update_elem(mim_fd, &pos, &fd, 0);\n\tif (err) {\n\t\tprintf(\"Failed to update array of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\tmap = bpf_object__find_map_by_name(obj, \"mim_hash\");\n\tif (!map) {\n\t\tprintf(\"Failed to load hash of maps from test prog\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\tmim_fd = bpf_map__fd(map);\n\tif (mim_fd < 0) {\n\t\tprintf(\"Failed to get descriptor for hash of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\terr = bpf_map_update_elem(mim_fd, &pos, &fd, 0);\n\tif (err) {\n\t\tprintf(\"Failed to update hash of maps\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\tbpf_object__close(obj);\n\n\t \n\tobj = bpf_object__open(MAPINMAP_INVALID_PROG);\n\terr = libbpf_get_error(obj);\n\tif (err) {\n\t\tprintf(\"Failed to load %s program: %d %d\",\n\t\t       MAPINMAP_INVALID_PROG, err, errno);\n\t\tgoto out_map_in_map;\n\t}\n\n\tmap = bpf_object__find_map_by_name(obj, \"mim\");\n\tif (!map) {\n\t\tprintf(\"Failed to load array of maps from test prog\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\told_print_fn = libbpf_set_print(NULL);\n\n\terr = bpf_object__load(obj);\n\tif (!err) {\n\t\tprintf(\"Loading obj supposed to fail\\n\");\n\t\tgoto out_map_in_map;\n\t}\n\n\tlibbpf_set_print(old_print_fn);\n\n\t \n\twhile (true) {\n\t\terr = bpf_map_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\tprintf(\"Failed to get next map: %d\", errno);\n\t\t\tgoto out_map_in_map;\n\t\t}\n\n\t\tfd = bpf_map_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tprintf(\"Failed to get map by id %u: %d\", id, errno);\n\t\t\tgoto out_map_in_map;\n\t\t}\n\n\t\terr = bpf_map_get_info_by_fd(fd, &info, &len);\n\t\tif (err) {\n\t\t\tprintf(\"Failed to get map info by fd %d: %d\", fd,\n\t\t\t       errno);\n\t\t\tgoto out_map_in_map;\n\t\t}\n\n\t\tif (!strcmp(info.name, \"mim.inner\")) {\n\t\t\tprintf(\"Inner map mim.inner was not destroyed\\n\");\n\t\t\tgoto out_map_in_map;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\tbpf_object__close(obj);\n\treturn;\n\nout_map_in_map:\n\tif (fd >= 0)\n\t\tclose(fd);\n\texit(1);\n}\n\n#define MAP_SIZE (32 * 1024)\n\nstatic void test_map_large(void)\n{\n\n\tstruct bigkey {\n\t\tint a;\n\t\tchar b[4096];\n\t\tlong long c;\n\t} key;\n\tint fd, i, value;\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value),\n\t\t\t    MAP_SIZE, &map_opts);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create large map '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tfor (i = 0; i < MAP_SIZE; i++) {\n\t\tkey = (struct bigkey) { .c = i };\n\t\tvalue = i;\n\n\t\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) == 0);\n\t}\n\n\tkey.c = -1;\n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t       errno == E2BIG);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &key) == 0);\n\tkey.c = -1;\n\tfor (i = 0; i < MAP_SIZE; i++)\n\t\tassert(bpf_map_get_next_key(fd, &key, &key) == 0);\n\tassert(bpf_map_get_next_key(fd, &key, &key) < 0 && errno == ENOENT);\n\n\tkey.c = 0;\n\tassert(bpf_map_lookup_elem(fd, &key, &value) == 0 && value == 0);\n\tkey.a = 1;\n\tassert(bpf_map_lookup_elem(fd, &key, &value) < 0 && errno == ENOENT);\n\n\tclose(fd);\n}\n\n#define run_parallel(N, FN, DATA) \\\n\tprintf(\"Fork %u tasks to '\" #FN \"'\\n\", N); \\\n\t__run_parallel(N, FN, DATA)\n\nstatic void __run_parallel(unsigned int tasks,\n\t\t\t   void (*fn)(unsigned int task, void *data),\n\t\t\t   void *data)\n{\n\tpid_t pid[tasks];\n\tint i;\n\n\tfflush(stdout);\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tpid[i] = fork();\n\t\tif (pid[i] == 0) {\n\t\t\tfn(i, data);\n\t\t\texit(0);\n\t\t} else if (pid[i] == -1) {\n\t\t\tprintf(\"Couldn't spawn #%d process!\\n\", i);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tint status;\n\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\tassert(status == 0);\n\t}\n}\n\nstatic void test_map_stress(void)\n{\n\trun_parallel(100, test_hashmap_walk, NULL);\n\trun_parallel(100, test_hashmap, NULL);\n\trun_parallel(100, test_hashmap_percpu, NULL);\n\trun_parallel(100, test_hashmap_sizes, NULL);\n\n\trun_parallel(100, test_arraymap, NULL);\n\trun_parallel(100, test_arraymap_percpu, NULL);\n}\n\n#define TASKS 100\n\n#define DO_UPDATE 1\n#define DO_DELETE 0\n\n#define MAP_RETRIES 20\n#define MAX_DELAY_US 50000\n#define MIN_DELAY_RANGE_US 5000\n\nstatic int map_update_retriable(int map_fd, const void *key, const void *value,\n\t\t\t\tint flags, int attempts)\n{\n\tint delay = rand() % MIN_DELAY_RANGE_US;\n\n\twhile (bpf_map_update_elem(map_fd, key, value, flags)) {\n\t\tif (!attempts || (errno != EAGAIN && errno != EBUSY))\n\t\t\treturn -errno;\n\n\t\tif (delay <= MAX_DELAY_US / 2)\n\t\t\tdelay *= 2;\n\n\t\tusleep(delay);\n\t\tattempts--;\n\t}\n\n\treturn 0;\n}\n\nstatic int map_delete_retriable(int map_fd, const void *key, int attempts)\n{\n\tint delay = rand() % MIN_DELAY_RANGE_US;\n\n\twhile (bpf_map_delete_elem(map_fd, key)) {\n\t\tif (!attempts || (errno != EAGAIN && errno != EBUSY))\n\t\t\treturn -errno;\n\n\t\tif (delay <= MAX_DELAY_US / 2)\n\t\t\tdelay *= 2;\n\n\t\tusleep(delay);\n\t\tattempts--;\n\t}\n\n\treturn 0;\n}\n\nstatic void test_update_delete(unsigned int fn, void *data)\n{\n\tint do_update = ((int *)data)[1];\n\tint fd = ((int *)data)[0];\n\tint i, key, value, err;\n\n\tif (fn & 1)\n\t\ttest_hashmap_walk(fn, NULL);\n\tfor (i = fn; i < MAP_SIZE; i += TASKS) {\n\t\tkey = value = i;\n\n\t\tif (do_update) {\n\t\t\terr = map_update_retriable(fd, &key, &value, BPF_NOEXIST, MAP_RETRIES);\n\t\t\tif (err)\n\t\t\t\tprintf(\"error %d %d\\n\", err, errno);\n\t\t\tassert(err == 0);\n\t\t\terr = map_update_retriable(fd, &key, &value, BPF_EXIST, MAP_RETRIES);\n\t\t\tif (err)\n\t\t\t\tprintf(\"error %d %d\\n\", err, errno);\n\t\t\tassert(err == 0);\n\t\t} else {\n\t\t\terr = map_delete_retriable(fd, &key, MAP_RETRIES);\n\t\t\tif (err)\n\t\t\t\tprintf(\"error %d %d\\n\", err, errno);\n\t\t\tassert(err == 0);\n\t\t}\n\t}\n}\n\nstatic void test_map_parallel(void)\n{\n\tint i, fd, key = 0, value = 0, j = 0;\n\tint data[2];\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value),\n\t\t\t    MAP_SIZE, &map_opts);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create map for parallel test '%s'!\\n\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\nagain:\n\t \n\tdata[0] = fd;\n\tdata[1] = DO_UPDATE;\n\trun_parallel(TASKS, test_update_delete, data);\n\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_NOEXIST) < 0 &&\n\t       errno == EEXIST);\n\n\t \n\tassert(bpf_map_get_next_key(fd, NULL, &key) == 0);\n\tkey = -1;\n\tfor (i = 0; i < MAP_SIZE; i++)\n\t\tassert(bpf_map_get_next_key(fd, &key, &key) == 0);\n\tassert(bpf_map_get_next_key(fd, &key, &key) < 0 && errno == ENOENT);\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++) {\n\t\tkey = MAP_SIZE - i - 1;\n\n\t\tassert(bpf_map_lookup_elem(fd, &key, &value) == 0 &&\n\t\t       value == key);\n\t}\n\n\t \n\tdata[1] = DO_DELETE;\n\trun_parallel(TASKS, test_update_delete, data);\n\n\t \n\tkey = -1;\n\tassert(bpf_map_get_next_key(fd, NULL, &key) < 0 && errno == ENOENT);\n\tassert(bpf_map_get_next_key(fd, &key, &key) < 0 && errno == ENOENT);\n\n\tkey = 0;\n\tbpf_map_delete_elem(fd, &key);\n\tif (j++ < 5)\n\t\tgoto again;\n\tclose(fd);\n}\n\nstatic void test_map_rdonly(void)\n{\n\tint fd, key = 0, value = 0;\n\t__u32 old_flags;\n\n\told_flags = map_opts.map_flags;\n\tmap_opts.map_flags |= BPF_F_RDONLY;\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value),\n\t\t\t    MAP_SIZE, &map_opts);\n\tmap_opts.map_flags = old_flags;\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create map for read only test '%s'!\\n\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\n\tkey = 1;\n\tvalue = 1234;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) < 0 &&\n\t       errno == EPERM);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) < 0 && errno == ENOENT);\n\tassert(bpf_map_get_next_key(fd, &key, &value) < 0 && errno == ENOENT);\n\n\tclose(fd);\n}\n\nstatic void test_map_wronly_hash(void)\n{\n\tint fd, key = 0, value = 0;\n\t__u32 old_flags;\n\n\told_flags = map_opts.map_flags;\n\tmap_opts.map_flags |= BPF_F_WRONLY;\n\tfd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(key), sizeof(value),\n\t\t\t    MAP_SIZE, &map_opts);\n\tmap_opts.map_flags = old_flags;\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create map for write only test '%s'!\\n\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\n\tkey = 1;\n\tvalue = 1234;\n\t \n\tassert(bpf_map_update_elem(fd, &key, &value, BPF_ANY) == 0);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, &key, &value) < 0 && errno == EPERM);\n\tassert(bpf_map_get_next_key(fd, &key, &value) < 0 && errno == EPERM);\n\n\tclose(fd);\n}\n\nstatic void test_map_wronly_stack_or_queue(enum bpf_map_type map_type)\n{\n\tint fd, value = 0;\n\t__u32 old_flags;\n\n\n\tassert(map_type == BPF_MAP_TYPE_QUEUE ||\n\t       map_type == BPF_MAP_TYPE_STACK);\n\told_flags = map_opts.map_flags;\n\tmap_opts.map_flags |= BPF_F_WRONLY;\n\tfd = bpf_map_create(map_type, NULL, 0, sizeof(value), MAP_SIZE, &map_opts);\n\tmap_opts.map_flags = old_flags;\n\t \n\tif (map_opts.map_flags & BPF_F_NO_PREALLOC) {\n\t\tassert(fd < 0 && errno == EINVAL);\n\t\treturn;\n\t}\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create map '%s'!\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tvalue = 1234;\n\tassert(bpf_map_update_elem(fd, NULL, &value, BPF_ANY) == 0);\n\n\t \n\tassert(bpf_map_lookup_elem(fd, NULL, &value) < 0 && errno == EPERM);\n\n\t \n\tassert(bpf_map_lookup_and_delete_elem(fd, NULL, &value) < 0 &&\n\t       errno == EPERM);\n\n\tclose(fd);\n}\n\nstatic void test_map_wronly(void)\n{\n\ttest_map_wronly_hash();\n\ttest_map_wronly_stack_or_queue(BPF_MAP_TYPE_STACK);\n\ttest_map_wronly_stack_or_queue(BPF_MAP_TYPE_QUEUE);\n}\n\nstatic void prepare_reuseport_grp(int type, int map_fd, size_t map_elem_size,\n\t\t\t\t  __s64 *fds64, __u64 *sk_cookies,\n\t\t\t\t  unsigned int n)\n{\n\tsocklen_t optlen, addrlen;\n\tstruct sockaddr_in6 s6;\n\tconst __u32 index0 = 0;\n\tconst int optval = 1;\n\tunsigned int i;\n\tu64 sk_cookie;\n\tvoid *value;\n\t__s32 fd32;\n\t__s64 fd64;\n\tint err;\n\n\ts6.sin6_family = AF_INET6;\n\ts6.sin6_addr = in6addr_any;\n\ts6.sin6_port = 0;\n\taddrlen = sizeof(s6);\n\toptlen = sizeof(sk_cookie);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfd64 = socket(AF_INET6, type, 0);\n\t\tCHECK(fd64 == -1, \"socket()\",\n\t\t      \"sock_type:%d fd64:%lld errno:%d\\n\",\n\t\t      type, fd64, errno);\n\n\t\terr = setsockopt(fd64, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t\t &optval, sizeof(optval));\n\t\tCHECK(err == -1, \"setsockopt(SO_REUSEPORT)\",\n\t\t      \"err:%d errno:%d\\n\", err, errno);\n\n\t\t \n\t\tif (map_elem_size == sizeof(__u64))\n\t\t\tvalue = &fd64;\n\t\telse {\n\t\t\tassert(map_elem_size == sizeof(__u32));\n\t\t\tfd32 = (__s32)fd64;\n\t\t\tvalue = &fd32;\n\t\t}\n\t\terr = bpf_map_update_elem(map_fd, &index0, value, BPF_ANY);\n\t\tCHECK(err >= 0 || errno != EINVAL,\n\t\t      \"reuseport array update unbound sk\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\n\t\terr = bind(fd64, (struct sockaddr *)&s6, sizeof(s6));\n\t\tCHECK(err == -1, \"bind()\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\", type, err, errno);\n\n\t\tif (i == 0) {\n\t\t\terr = getsockname(fd64, (struct sockaddr *)&s6,\n\t\t\t\t\t  &addrlen);\n\t\t\tCHECK(err == -1, \"getsockname()\",\n\t\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t\t      type, err, errno);\n\t\t}\n\n\t\terr = getsockopt(fd64, SOL_SOCKET, SO_COOKIE, &sk_cookie,\n\t\t\t\t &optlen);\n\t\tCHECK(err == -1, \"getsockopt(SO_COOKIE)\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\", type, err, errno);\n\n\t\tif (type == SOCK_STREAM) {\n\t\t\t \n\t\t\terr = bpf_map_update_elem(map_fd, &index0, value,\n\t\t\t\t\t\t  BPF_ANY);\n\t\t\tCHECK(err >= 0 || errno != EINVAL,\n\t\t\t      \"reuseport array update non-listening sk\",\n\t\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t\t      type, err, errno);\n\t\t\terr = listen(fd64, 0);\n\t\t\tCHECK(err == -1, \"listen()\",\n\t\t\t      \"sock_type:%d, err:%d errno:%d\\n\",\n\t\t\t      type, err, errno);\n\t\t}\n\n\t\tfds64[i] = fd64;\n\t\tsk_cookies[i] = sk_cookie;\n\t}\n}\n\nstatic void test_reuseport_array(void)\n{\n#define REUSEPORT_FD_IDX(err, last) ({ (err) ? last : !last; })\n\n\tconst __u32 array_size = 4, index0 = 0, index3 = 3;\n\tint types[2] = { SOCK_STREAM, SOCK_DGRAM }, type;\n\t__u64 grpa_cookies[2], sk_cookie, map_cookie;\n\t__s64 grpa_fds64[2] = { -1, -1 }, fd64 = -1;\n\tconst __u32 bad_index = array_size;\n\tint map_fd, err, t, f;\n\t__u32 fds_idx = 0;\n\tint fd;\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, NULL,\n\t\t\t\tsizeof(__u32), sizeof(__u64), array_size, NULL);\n\tCHECK(map_fd < 0, \"reuseport array create\",\n\t      \"map_fd:%d, errno:%d\\n\", map_fd, errno);\n\n\t \n\terr = bpf_map_delete_elem(map_fd, &bad_index);\n\tCHECK(err >= 0 || errno != E2BIG, \"reuseport array del >=max_entries\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\terr = bpf_map_update_elem(map_fd, &bad_index, &fd64, BPF_ANY);\n\tCHECK(err >= 0 || errno != E2BIG,\n\t      \"reuseport array update >=max_entries\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\terr = bpf_map_lookup_elem(map_fd, &bad_index, &map_cookie);\n\tCHECK(err >= 0 || errno != ENOENT,\n\t      \"reuseport array update >=max_entries\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &index3, &map_cookie);\n\tCHECK(err >= 0 || errno != ENOENT,\n\t      \"reuseport array lookup not-exist elem\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_delete_elem(map_fd, &index3);\n\tCHECK(err >= 0 || errno != ENOENT,\n\t      \"reuseport array del not-exist elem\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\n\tfor (t = 0; t < ARRAY_SIZE(types); t++) {\n\t\ttype = types[t];\n\n\t\tprepare_reuseport_grp(type, map_fd, sizeof(__u64), grpa_fds64,\n\t\t\t\t      grpa_cookies, ARRAY_SIZE(grpa_fds64));\n\n\t\t \n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &grpa_fds64[fds_idx],\n\t\t\t\t\t  BPF_EXIST);\n\t\tCHECK(err >= 0 || errno != ENOENT,\n\t\t      \"reuseport array update empty elem BPF_EXIST\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\t\tfds_idx = REUSEPORT_FD_IDX(err, fds_idx);\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &grpa_fds64[fds_idx],\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tCHECK(err < 0,\n\t\t      \"reuseport array update empty elem BPF_NOEXIST\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\t\tfds_idx = REUSEPORT_FD_IDX(err, fds_idx);\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &grpa_fds64[fds_idx],\n\t\t\t\t\t  BPF_EXIST);\n\t\tCHECK(err < 0,\n\t\t      \"reuseport array update same elem BPF_EXIST\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\", type, err, errno);\n\t\tfds_idx = REUSEPORT_FD_IDX(err, fds_idx);\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &grpa_fds64[fds_idx],\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tCHECK(err >= 0 || errno != EEXIST,\n\t\t      \"reuseport array update non-empty elem BPF_NOEXIST\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\t\tfds_idx = REUSEPORT_FD_IDX(err, fds_idx);\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &grpa_fds64[fds_idx],\n\t\t\t\t\t  BPF_ANY);\n\t\tCHECK(err < 0,\n\t\t      \"reuseport array update same sk with BPF_ANY\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\", type, err, errno);\n\n\t\tfd64 = grpa_fds64[fds_idx];\n\t\tsk_cookie = grpa_cookies[fds_idx];\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &fd64, BPF_ANY);\n\t\tCHECK(err >= 0 || errno != EBUSY,\n\t\t      \"reuseport array update same sk with same index\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\n\t\terr = bpf_map_update_elem(map_fd, &index0, &fd64, BPF_ANY);\n\t\tCHECK(err >= 0 || errno != EBUSY,\n\t\t      \"reuseport array update same sk with different index\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\n\t\t \n\t\terr = bpf_map_delete_elem(map_fd, &index3);\n\t\tCHECK(err < 0, \"reuseport array delete sk\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\n\t\t \n\t\terr = bpf_map_update_elem(map_fd, &index3, &fd64, BPF_NOEXIST);\n\t\tCHECK(err < 0,\n\t\t      \"reuseport array re-add with BPF_NOEXIST after del\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\", type, err, errno);\n\n\t\t \n\t\terr = bpf_map_lookup_elem(map_fd, &index3, &map_cookie);\n\t\tCHECK(err < 0 || sk_cookie != map_cookie,\n\t\t      \"reuseport array lookup re-added sk\",\n\t\t      \"sock_type:%d err:%d errno:%d sk_cookie:0x%llx map_cookie:0x%llxn\",\n\t\t      type, err, errno, sk_cookie, map_cookie);\n\n\t\t \n\t\tfor (f = 0; f < ARRAY_SIZE(grpa_fds64); f++)\n\t\t\tclose(grpa_fds64[f]);\n\t\terr = bpf_map_lookup_elem(map_fd, &index3, &map_cookie);\n\t\tCHECK(err >= 0 || errno != ENOENT,\n\t\t      \"reuseport array lookup after close()\",\n\t\t      \"sock_type:%d err:%d errno:%d\\n\",\n\t\t      type, err, errno);\n\t}\n\n\t \n\tfd64 = socket(AF_INET6, SOCK_RAW, IPPROTO_UDP);\n\tCHECK(fd64 == -1, \"socket(SOCK_RAW)\", \"err:%d errno:%d\\n\",\n\t      err, errno);\n\terr = bpf_map_update_elem(map_fd, &index3, &fd64, BPF_NOEXIST);\n\tCHECK(err >= 0 || errno != ENOTSUPP, \"reuseport array update SOCK_RAW\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\tclose(fd64);\n\n\t \n\tclose(map_fd);\n\n\t \n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, NULL,\n\t\t\t\tsizeof(__u32), sizeof(__u32), array_size, NULL);\n\tCHECK(map_fd < 0, \"reuseport array create\",\n\t      \"map_fd:%d, errno:%d\\n\", map_fd, errno);\n\tprepare_reuseport_grp(SOCK_STREAM, map_fd, sizeof(__u32), &fd64,\n\t\t\t      &sk_cookie, 1);\n\tfd = fd64;\n\terr = bpf_map_update_elem(map_fd, &index3, &fd, BPF_NOEXIST);\n\tCHECK(err < 0, \"reuseport array update 32 bit fd\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\terr = bpf_map_lookup_elem(map_fd, &index3, &map_cookie);\n\tCHECK(err >= 0 || errno != ENOSPC,\n\t      \"reuseport array lookup 32 bit fd\",\n\t      \"err:%d errno:%d\\n\", err, errno);\n\tclose(fd);\n\tclose(map_fd);\n}\n\nstatic void run_all_tests(void)\n{\n\ttest_hashmap(0, NULL);\n\ttest_hashmap_percpu(0, NULL);\n\ttest_hashmap_walk(0, NULL);\n\ttest_hashmap_zero_seed();\n\n\ttest_arraymap(0, NULL);\n\ttest_arraymap_percpu(0, NULL);\n\n\ttest_arraymap_percpu_many_keys();\n\n\ttest_devmap(0, NULL);\n\ttest_devmap_hash(0, NULL);\n\ttest_sockmap(0, NULL);\n\n\ttest_map_large();\n\ttest_map_parallel();\n\ttest_map_stress();\n\n\ttest_map_rdonly();\n\ttest_map_wronly();\n\n\ttest_reuseport_array();\n\n\ttest_queuemap(0, NULL);\n\ttest_stackmap(0, NULL);\n\n\ttest_map_in_map();\n}\n\n#define DEFINE_TEST(name) extern void test_##name(void);\n#include <map_tests/tests.h>\n#undef DEFINE_TEST\n\nint main(void)\n{\n\tsrand(time(NULL));\n\n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tmap_opts.map_flags = 0;\n\trun_all_tests();\n\n\tmap_opts.map_flags = BPF_F_NO_PREALLOC;\n\trun_all_tests();\n\n#define DEFINE_TEST(name) test_##name();\n#include <map_tests/tests.h>\n#undef DEFINE_TEST\n\n\tprintf(\"test_maps: OK, %d SKIPPED\\n\", skips);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}