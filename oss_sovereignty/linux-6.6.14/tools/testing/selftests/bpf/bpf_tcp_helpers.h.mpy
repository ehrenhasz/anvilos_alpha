{
  "module_name": "bpf_tcp_helpers.h",
  "hash_id": "91be9f11a75e848bd95cbe1d03933fbd0f47293eb960b2f1e52dce3e75321dea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
  "human_readable_source": " \n#ifndef __BPF_TCP_HELPERS_H\n#define __BPF_TCP_HELPERS_H\n\n#include <stdbool.h>\n#include <linux/types.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_tracing.h>\n\n#define BPF_STRUCT_OPS(name, args...) \\\nSEC(\"struct_ops/\"#name) \\\nBPF_PROG(name, args)\n\n#ifndef SOL_TCP\n#define SOL_TCP 6\n#endif\n\n#ifndef TCP_CA_NAME_MAX\n#define TCP_CA_NAME_MAX\t16\n#endif\n\n#define tcp_jiffies32 ((__u32)bpf_jiffies64())\n\nstruct sock_common {\n\tunsigned char\tskc_state;\n\t__u16\t\tskc_num;\n} __attribute__((preserve_access_index));\n\nenum sk_pacing {\n\tSK_PACING_NONE\t\t= 0,\n\tSK_PACING_NEEDED\t= 1,\n\tSK_PACING_FQ\t\t= 2,\n};\n\nstruct sock {\n\tstruct sock_common\t__sk_common;\n#define sk_state\t\t__sk_common.skc_state\n\tunsigned long\t\tsk_pacing_rate;\n\t__u32\t\t\tsk_pacing_status;  \n} __attribute__((preserve_access_index));\n\nstruct inet_sock {\n\tstruct sock\t\tsk;\n} __attribute__((preserve_access_index));\n\nstruct inet_connection_sock {\n\tstruct inet_sock\t  icsk_inet;\n\t__u8\t\t\t  icsk_ca_state:6,\n\t\t\t\t  icsk_ca_setsockopt:1,\n\t\t\t\t  icsk_ca_dst_locked:1;\n\tstruct {\n\t\t__u8\t\t  pending;\n\t} icsk_ack;\n\t__u64\t\t\t  icsk_ca_priv[104 / sizeof(__u64)];\n} __attribute__((preserve_access_index));\n\nstruct request_sock {\n\tstruct sock_common\t\t__req_common;\n} __attribute__((preserve_access_index));\n\nstruct tcp_sock {\n\tstruct inet_connection_sock\tinet_conn;\n\n\t__u32\trcv_nxt;\n\t__u32\tsnd_nxt;\n\t__u32\tsnd_una;\n\t__u32\twindow_clamp;\n\t__u8\tecn_flags;\n\t__u32\tdelivered;\n\t__u32\tdelivered_ce;\n\t__u32\tsnd_cwnd;\n\t__u32\tsnd_cwnd_cnt;\n\t__u32\tsnd_cwnd_clamp;\n\t__u32\tsnd_ssthresh;\n\t__u8\tsyn_data:1,\t \n\t\tsyn_fastopen:1,\t \n\t\tsyn_fastopen_exp:1, \n\t\tsyn_fastopen_ch:1,  \n\t\tsyn_data_acked:1, \n\t\tsave_syn:1,\t \n\t\tis_cwnd_limited:1, \n\t\tsyn_smc:1;\t \n\t__u32\tmax_packets_out;\n\t__u32\tlsndtime;\n\t__u32\tprior_cwnd;\n\t__u64\ttcp_mstamp;\t \n\tbool\tis_mptcp;\n} __attribute__((preserve_access_index));\n\nstatic __always_inline struct inet_connection_sock *inet_csk(const struct sock *sk)\n{\n\treturn (struct inet_connection_sock *)sk;\n}\n\nstatic __always_inline void *inet_csk_ca(const struct sock *sk)\n{\n\treturn (void *)inet_csk(sk)->icsk_ca_priv;\n}\n\nstatic __always_inline struct tcp_sock *tcp_sk(const struct sock *sk)\n{\n\treturn (struct tcp_sock *)sk;\n}\n\nstatic __always_inline bool before(__u32 seq1, __u32 seq2)\n{\n\treturn (__s32)(seq1-seq2) < 0;\n}\n#define after(seq2, seq1) \tbefore(seq1, seq2)\n\n#define\tTCP_ECN_OK\t\t1\n#define\tTCP_ECN_QUEUE_CWR\t2\n#define\tTCP_ECN_DEMAND_CWR\t4\n#define\tTCP_ECN_SEEN\t\t8\n\nenum inet_csk_ack_state_t {\n\tICSK_ACK_SCHED\t= 1,\n\tICSK_ACK_TIMER  = 2,\n\tICSK_ACK_PUSHED = 4,\n\tICSK_ACK_PUSHED2 = 8,\n\tICSK_ACK_NOW = 16\t \n};\n\nenum tcp_ca_event {\n\tCA_EVENT_TX_START = 0,\n\tCA_EVENT_CWND_RESTART = 1,\n\tCA_EVENT_COMPLETE_CWR = 2,\n\tCA_EVENT_LOSS = 3,\n\tCA_EVENT_ECN_NO_CE = 4,\n\tCA_EVENT_ECN_IS_CE = 5,\n};\n\nstruct ack_sample {\n\t__u32 pkts_acked;\n\t__s32 rtt_us;\n\t__u32 in_flight;\n} __attribute__((preserve_access_index));\n\nstruct rate_sample {\n\t__u64  prior_mstamp;  \n\t__u32  prior_delivered;\t \n\t__s32  delivered;\t\t \n\tlong interval_us;\t \n\t__u32 snd_interval_us;\t \n\t__u32 rcv_interval_us;\t \n\tlong rtt_us;\t\t \n\tint  losses;\t\t \n\t__u32  acked_sacked;\t \n\t__u32  prior_in_flight;\t \n\tbool is_app_limited;\t \n\tbool is_retrans;\t \n\tbool is_ack_delayed;\t \n} __attribute__((preserve_access_index));\n\n#define TCP_CA_NAME_MAX\t\t16\n#define TCP_CONG_NEEDS_ECN\t0x2\n\nstruct tcp_congestion_ops {\n\tchar name[TCP_CA_NAME_MAX];\n\t__u32 flags;\n\n\t \n\tvoid (*init)(struct sock *sk);\n\t \n\tvoid (*release)(struct sock *sk);\n\n\t \n\t__u32 (*ssthresh)(struct sock *sk);\n\t \n\tvoid (*cong_avoid)(struct sock *sk, __u32 ack, __u32 acked);\n\t \n\tvoid (*set_state)(struct sock *sk, __u8 new_state);\n\t \n\tvoid (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);\n\t \n\tvoid (*in_ack_event)(struct sock *sk, __u32 flags);\n\t \n\t__u32  (*undo_cwnd)(struct sock *sk);\n\t \n\tvoid (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);\n\t \n\t__u32 (*min_tso_segs)(struct sock *sk);\n\t \n\t__u32 (*sndbuf_expand)(struct sock *sk);\n\t \n\tvoid (*cong_control)(struct sock *sk, const struct rate_sample *rs);\n\tvoid *owner;\n};\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min_not_zero(x, y) ({\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\\\n\ttypeof(y) __y = (y);\t\t\t\\\n\t__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })\n\nstatic __always_inline bool tcp_in_slow_start(const struct tcp_sock *tp)\n{\n\treturn tp->snd_cwnd < tp->snd_ssthresh;\n}\n\nstatic __always_inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t \n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn !!BPF_CORE_READ_BITFIELD(tp, is_cwnd_limited);\n}\n\nstatic __always_inline bool tcp_cc_eq(const char *a, const char *b)\n{\n\tint i;\n\n\tfor (i = 0; i < TCP_CA_NAME_MAX; i++) {\n\t\tif (a[i] != b[i])\n\t\t\treturn false;\n\t\tif (!a[i])\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nextern __u32 tcp_slow_start(struct tcp_sock *tp, __u32 acked) __ksym;\nextern void tcp_cong_avoid_ai(struct tcp_sock *tp, __u32 w, __u32 acked) __ksym;\n\nstruct mptcp_sock {\n\tstruct inet_connection_sock\tsk;\n\n\t__u32\t\ttoken;\n\tstruct sock\t*first;\n\tchar\t\tca_name[TCP_CA_NAME_MAX];\n} __attribute__((preserve_access_index));\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}