{
  "module_name": "xdping.c",
  "hash_id": "54d0dfc2644cb9db6b0ff66503174578c5bcb538789e45a8e8e236d1a9c4eacb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/xdping.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/if_link.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <net/if.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\n#include \"bpf/bpf.h\"\n#include \"bpf/libbpf.h\"\n\n#include \"xdping.h\"\n#include \"testing_helpers.h\"\n\nstatic int ifindex;\nstatic __u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;\n\nstatic void cleanup(int sig)\n{\n\tbpf_xdp_detach(ifindex, xdp_flags, NULL);\n\tif (sig)\n\t\texit(1);\n}\n\nstatic int get_stats(int fd, __u16 count, __u32 raddr)\n{\n\tstruct pinginfo pinginfo = { 0 };\n\tchar inaddrbuf[INET_ADDRSTRLEN];\n\tstruct in_addr inaddr;\n\t__u16 i;\n\n\tinaddr.s_addr = raddr;\n\n\tprintf(\"\\nXDP RTT data:\\n\");\n\n\tif (bpf_map_lookup_elem(fd, &raddr, &pinginfo)) {\n\t\tperror(\"bpf_map_lookup elem\");\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (pinginfo.times[i] == 0)\n\t\t\tbreak;\n\n\t\tprintf(\"64 bytes from %s: icmp_seq=%d ttl=64 time=%#.5f ms\\n\",\n\t\t       inet_ntop(AF_INET, &inaddr, inaddrbuf,\n\t\t\t\t sizeof(inaddrbuf)),\n\t\t       count + i + 1,\n\t\t       (double)pinginfo.times[i]/1000000);\n\t}\n\n\tif (i < count) {\n\t\tfprintf(stderr, \"Expected %d samples, got %d.\\n\", count, i);\n\t\treturn 1;\n\t}\n\n\tbpf_map_delete_elem(fd, &raddr);\n\n\treturn 0;\n}\n\nstatic void show_usage(const char *prog)\n{\n\tfprintf(stderr,\n\t\t\"usage: %s [OPTS] -I interface destination\\n\\n\"\n\t\t\"OPTS:\\n\"\n\t\t\"    -c count\t\tStop after sending count requests\\n\"\n\t\t\"\t\t\t(default %d, max %d)\\n\"\n\t\t\"    -I interface\tinterface name\\n\"\n\t\t\"    -N\t\t\tRun in driver mode\\n\"\n\t\t\"    -s\t\t\tServer mode\\n\"\n\t\t\"    -S\t\t\tRun in skb mode\\n\",\n\t\tprog, XDPING_DEFAULT_COUNT, XDPING_MAX_COUNT);\n}\n\nint main(int argc, char **argv)\n{\n\t__u32 mode_flags = XDP_FLAGS_DRV_MODE | XDP_FLAGS_SKB_MODE;\n\tstruct addrinfo *a, hints = { .ai_family = AF_INET };\n\t__u16 count = XDPING_DEFAULT_COUNT;\n\tstruct pinginfo pinginfo = { 0 };\n\tconst char *optstr = \"c:I:NsS\";\n\tstruct bpf_program *main_prog;\n\tint prog_fd = -1, map_fd = -1;\n\tstruct sockaddr_in rin;\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tchar *ifname = NULL;\n\tchar filename[256];\n\tint opt, ret = 1;\n\t__u32 raddr = 0;\n\tint server = 0;\n\tchar cmd[256];\n\n\twhile ((opt = getopt(argc, argv, optstr)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'c':\n\t\t\tcount = atoi(optarg);\n\t\t\tif (count < 1 || count > XDPING_MAX_COUNT) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"min count is 1, max count is %d\\n\",\n\t\t\t\t\tXDPING_MAX_COUNT);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tifname = optarg;\n\t\t\tifindex = if_nametoindex(ifname);\n\t\t\tif (!ifindex) {\n\t\t\t\tfprintf(stderr, \"Could not get interface %s\\n\",\n\t\t\t\t\tifname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\txdp_flags |= XDP_FLAGS_DRV_MODE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t \n\t\t\tserver = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\txdp_flags |= XDP_FLAGS_SKB_MODE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshow_usage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!ifname) {\n\t\tshow_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\tif (!server && optind == argc) {\n\t\tshow_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tif ((xdp_flags & mode_flags) == mode_flags) {\n\t\tfprintf(stderr, \"-N or -S can be specified, not both.\\n\");\n\t\tshow_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tif (!server) {\n\t\t \n\t\tif (getaddrinfo(argv[optind], NULL, &hints, &a) || !a) {\n\t\t\tfprintf(stderr, \"Could not resolve %s\\n\", argv[optind]);\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&rin, a->ai_addr, sizeof(rin));\n\t\traddr = rin.sin_addr.s_addr;\n\t\tfreeaddrinfo(a);\n\t}\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.bpf.o\", argv[0]);\n\n\tif (bpf_prog_test_load(filename, BPF_PROG_TYPE_XDP, &obj, &prog_fd)) {\n\t\tfprintf(stderr, \"load of %s failed\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tmain_prog = bpf_object__find_program_by_name(obj,\n\t\t\t\t\t\t     server ? \"xdping_server\" : \"xdping_client\");\n\tif (main_prog)\n\t\tprog_fd = bpf_program__fd(main_prog);\n\tif (!main_prog || prog_fd < 0) {\n\t\tfprintf(stderr, \"could not find xdping program\");\n\t\treturn 1;\n\t}\n\n\tmap = bpf_object__next_map(obj, NULL);\n\tif (map)\n\t\tmap_fd = bpf_map__fd(map);\n\tif (!map || map_fd < 0) {\n\t\tfprintf(stderr, \"Could not find ping map\");\n\t\tgoto done;\n\t}\n\n\tsignal(SIGINT, cleanup);\n\tsignal(SIGTERM, cleanup);\n\n\tprintf(\"Setting up XDP for %s, please wait...\\n\", ifname);\n\n\tprintf(\"XDP setup disrupts network connectivity, hit Ctrl+C to quit\\n\");\n\n\tif (bpf_xdp_attach(ifindex, prog_fd, xdp_flags, NULL) < 0) {\n\t\tfprintf(stderr, \"Link set xdp fd failed for %s\\n\", ifname);\n\t\tgoto done;\n\t}\n\n\tif (server) {\n\t\tclose(prog_fd);\n\t\tclose(map_fd);\n\t\tprintf(\"Running server on %s; press Ctrl+C to exit...\\n\",\n\t\t       ifname);\n\t\tdo { } while (1);\n\t}\n\n\t \n\tpinginfo.seq = htons(count);\n\tpinginfo.count = count;\n\n\tif (bpf_map_update_elem(map_fd, &raddr, &pinginfo, BPF_ANY)) {\n\t\tfprintf(stderr, \"could not communicate with BPF map: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tcleanup(0);\n\t\tgoto done;\n\t}\n\n\t \n\tsleep(10);\n\n\tsnprintf(cmd, sizeof(cmd), \"ping -c %d -I %s %s\",\n\t\t count, ifname, argv[optind]);\n\n\tprintf(\"\\nNormal ping RTT data\\n\");\n\tprintf(\"[Ignore final RTT; it is distorted by XDP using the reply]\\n\");\n\n\tret = system(cmd);\n\n\tif (!ret)\n\t\tret = get_stats(map_fd, count, raddr);\n\n\tcleanup(0);\n\ndone:\n\tif (prog_fd > 0)\n\t\tclose(prog_fd);\n\tif (map_fd > 0)\n\t\tclose(map_fd);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}