{
  "module_name": "test_sock.c",
  "hash_id": "88f4615c4b782e8e1dd6f681010149c423179a30d3e486ff307b275288c440d5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_sock.c",
  "human_readable_source": "\n\n\n#include <stdio.h>\n#include <unistd.h>\n\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <linux/filter.h>\n\n#include <bpf/bpf.h>\n\n#include \"cgroup_helpers.h\"\n#include <bpf/bpf_endian.h>\n#include \"bpf_util.h\"\n\n#define CG_PATH\t\t\"/foo\"\n#define MAX_INSNS\t512\n\nchar bpf_log_buf[BPF_LOG_BUF_SIZE];\nstatic bool verbose = false;\n\nstruct sock_test {\n\tconst char *descr;\n\t \n\tstruct bpf_insn\tinsns[MAX_INSNS];\n\tenum bpf_attach_type expected_attach_type;\n\tenum bpf_attach_type attach_type;\n\t \n\tint domain;\n\tint type;\n\t \n\tconst char *ip;\n\tunsigned short port;\n\tunsigned short port_retry;\n\t \n\tenum {\n\t\tLOAD_REJECT,\n\t\tATTACH_REJECT,\n\t\tBIND_REJECT,\n\t\tSUCCESS,\n\t\tRETRY_SUCCESS,\n\t\tRETRY_REJECT\n\t} result;\n};\n\nstatic struct sock_test tests[] = {\n\t{\n\t\t.descr = \"bind4 load with invalid access: src_ip6\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip6[0])),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.result = LOAD_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind4 load with invalid access: mark\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, mark)),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.result = LOAD_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind6 load with invalid access: src_ip4\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip4)),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.result = LOAD_REJECT,\n\t},\n\t{\n\t\t.descr = \"sock_create load with invalid access: src_port\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.result = LOAD_REJECT,\n\t},\n\t{\n\t\t.descr = \"sock_create load w/o expected_attach_type (compat mode)\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = 0,\n\t\t.attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"127.0.0.1\",\n\t\t.port = 8097,\n\t\t.result = SUCCESS,\n\t},\n\t{\n\t\t.descr = \"sock_create load w/ expected_attach_type\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"127.0.0.1\",\n\t\t.port = 8097,\n\t\t.result = SUCCESS,\n\t},\n\t{\n\t\t.descr = \"attach type mismatch bind4 vs bind6\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.result = ATTACH_REJECT,\n\t},\n\t{\n\t\t.descr = \"attach type mismatch bind6 vs bind4\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.result = ATTACH_REJECT,\n\t},\n\t{\n\t\t.descr = \"attach type mismatch default vs bind4\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = 0,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.result = ATTACH_REJECT,\n\t},\n\t{\n\t\t.descr = \"attach type mismatch bind6 vs sock_create\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET_SOCK_CREATE,\n\t\t.result = ATTACH_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind4 reject all\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"0.0.0.0\",\n\t\t.result = BIND_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind6 reject all\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.domain = AF_INET6,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"::\",\n\t\t.result = BIND_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind6 deny specific IP & port\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\n\t\t\t \n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip6[3])),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7,\n\t\t\t\t    __bpf_constant_ntohl(0x00000001), 4),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0x2001, 2),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_JMP_A(1),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.domain = AF_INET6,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"::1\",\n\t\t.port = 8193,\n\t\t.result = BIND_REJECT,\n\t},\n\t{\n\t\t.descr = \"bind4 allow specific IP & port\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\n\t\t\t \n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip4)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7,\n\t\t\t\t    __bpf_constant_ntohl(0x7F000001), 4),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0x1002, 2),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_JMP_A(1),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"127.0.0.1\",\n\t\t.port = 4098,\n\t\t.result = SUCCESS,\n\t},\n\t{\n\t\t.descr = \"bind4 deny specific IP & port of TCP, and retry\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\n\t\t\t \n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip4)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7,\n\t\t\t\t    __bpf_constant_ntohl(0x7F000001), 4),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0x1002, 2),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_JMP_A(1),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"127.0.0.1\",\n\t\t.port = 4098,\n\t\t.port_retry = 5000,\n\t\t.result = RETRY_SUCCESS,\n\t},\n\t{\n\t\t.descr = \"bind4 deny specific IP & port of UDP, and retry\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\n\t\t\t \n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip4)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7,\n\t\t\t\t    __bpf_constant_ntohl(0x7F000001), 4),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0x1002, 2),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_JMP_A(1),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_DGRAM,\n\t\t.ip = \"127.0.0.1\",\n\t\t.port = 4098,\n\t\t.port_retry = 5000,\n\t\t.result = RETRY_SUCCESS,\n\t},\n\t{\n\t\t.descr = \"bind6 deny specific IP & port, and retry\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\n\t\t\t \n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_ip6[3])),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7,\n\t\t\t\t    __bpf_constant_ntohl(0x00000001), 4),\n\t\t\tBPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_6,\n\t\t\t\t    offsetof(struct bpf_sock, src_port)),\n\t\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0x2001, 2),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_JMP_A(1),\n\n\t\t\t \n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.domain = AF_INET6,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"::1\",\n\t\t.port = 8193,\n\t\t.port_retry = 9000,\n\t\t.result = RETRY_SUCCESS,\n\t},\n\t{\n\t\t.descr = \"bind4 allow all\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET4_POST_BIND,\n\t\t.domain = AF_INET,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"0.0.0.0\",\n\t\t.result = SUCCESS,\n\t},\n\t{\n\t\t.descr = \"bind6 allow all\",\n\t\t.insns = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\t\tBPF_EXIT_INSN(),\n\t\t},\n\t\t.expected_attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.attach_type = BPF_CGROUP_INET6_POST_BIND,\n\t\t.domain = AF_INET6,\n\t\t.type = SOCK_STREAM,\n\t\t.ip = \"::\",\n\t\t.result = SUCCESS,\n\t},\n};\n\nstatic size_t probe_prog_length(const struct bpf_insn *fp)\n{\n\tsize_t len;\n\n\tfor (len = MAX_INSNS - 1; len > 0; --len)\n\t\tif (fp[len].code != 0 || fp[len].imm != 0)\n\t\t\tbreak;\n\treturn len + 1;\n}\n\nstatic int load_sock_prog(const struct bpf_insn *prog,\n\t\t\t  enum bpf_attach_type attach_type)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts);\n\tint ret, insn_cnt;\n\n\tinsn_cnt = probe_prog_length(prog);\n\n\topts.expected_attach_type = attach_type;\n\topts.log_buf = bpf_log_buf;\n\topts.log_size = BPF_LOG_BUF_SIZE;\n\topts.log_level = 2;\n\n\tret = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, \"GPL\", prog, insn_cnt, &opts);\n\tif (verbose && ret < 0)\n\t\tfprintf(stderr, \"%s\\n\", bpf_log_buf);\n\n\treturn ret;\n}\n\nstatic int attach_sock_prog(int cgfd, int progfd,\n\t\t\t    enum bpf_attach_type attach_type)\n{\n\treturn bpf_prog_attach(progfd, cgfd, attach_type, BPF_F_ALLOW_OVERRIDE);\n}\n\nstatic int bind_sock(int domain, int type, const char *ip,\n\t\t     unsigned short port, unsigned short port_retry)\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in6 *addr6;\n\tstruct sockaddr_in *addr4;\n\tint sockfd = -1;\n\tsocklen_t len;\n\tint res = SUCCESS;\n\n\tsockfd = socket(domain, type, 0);\n\tif (sockfd < 0)\n\t\tgoto err;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (domain == AF_INET) {\n\t\tlen = sizeof(struct sockaddr_in);\n\t\taddr4 = (struct sockaddr_in *)&addr;\n\t\taddr4->sin_family = domain;\n\t\taddr4->sin_port = htons(port);\n\t\tif (inet_pton(domain, ip, (void *)&addr4->sin_addr) != 1)\n\t\t\tgoto err;\n\t} else if (domain == AF_INET6) {\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\taddr6 = (struct sockaddr_in6 *)&addr;\n\t\taddr6->sin6_family = domain;\n\t\taddr6->sin6_port = htons(port);\n\t\tif (inet_pton(domain, ip, (void *)&addr6->sin6_addr) != 1)\n\t\t\tgoto err;\n\t} else {\n\t\tgoto err;\n\t}\n\n\tif (bind(sockfd, (const struct sockaddr *)&addr, len) == -1) {\n\t\t \n\t\tif (errno != EPERM)\n\t\t\tgoto err;\n\t\tif (port_retry)\n\t\t\tgoto retry;\n\t\tres = BIND_REJECT;\n\t\tgoto out;\n\t}\n\n\tgoto out;\nretry:\n\tif (domain == AF_INET)\n\t\taddr4->sin_port = htons(port_retry);\n\telse\n\t\taddr6->sin6_port = htons(port_retry);\n\tif (bind(sockfd, (const struct sockaddr *)&addr, len) == -1) {\n\t\tif (errno != EPERM)\n\t\t\tgoto err;\n\t\tres = RETRY_REJECT;\n\t} else {\n\t\tres = RETRY_SUCCESS;\n\t}\n\tgoto out;\nerr:\n\tres = -1;\nout:\n\tclose(sockfd);\n\treturn res;\n}\n\nstatic int run_test_case(int cgfd, const struct sock_test *test)\n{\n\tint progfd = -1;\n\tint err = 0;\n\tint res;\n\n\tprintf(\"Test case: %s .. \", test->descr);\n\tprogfd = load_sock_prog(test->insns, test->expected_attach_type);\n\tif (progfd < 0) {\n\t\tif (test->result == LOAD_REJECT)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto err;\n\t}\n\n\tif (attach_sock_prog(cgfd, progfd, test->attach_type) < 0) {\n\t\tif (test->result == ATTACH_REJECT)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto err;\n\t}\n\n\tres = bind_sock(test->domain, test->type, test->ip, test->port,\n\t\t\ttest->port_retry);\n\tif (res > 0 && test->result == res)\n\t\tgoto out;\n\nerr:\n\terr = -1;\nout:\n\t \n\tif (progfd != -1)\n\t\tbpf_prog_detach(cgfd, test->attach_type);\n\tclose(progfd);\n\tprintf(\"[%s]\\n\", err ? \"FAIL\" : \"PASS\");\n\treturn err;\n}\n\nstatic int run_tests(int cgfd)\n{\n\tint passes = 0;\n\tint fails = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); ++i) {\n\t\tif (run_test_case(cgfd, &tests[i]))\n\t\t\t++fails;\n\t\telse\n\t\t\t++passes;\n\t}\n\tprintf(\"Summary: %d PASSED, %d FAILED\\n\", passes, fails);\n\treturn fails ? -1 : 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint cgfd = -1;\n\tint err = 0;\n\n\tcgfd = cgroup_setup_and_join(CG_PATH);\n\tif (cgfd < 0)\n\t\tgoto err;\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tif (run_tests(cgfd))\n\t\tgoto err;\n\n\tgoto out;\nerr:\n\terr = -1;\nout:\n\tclose(cgfd);\n\tcleanup_cgroup_environment();\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}