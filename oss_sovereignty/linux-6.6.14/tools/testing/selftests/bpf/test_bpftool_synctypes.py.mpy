{
  "module_name": "test_bpftool_synctypes.py",
  "hash_id": "b4cc75fdfb9d015a66299895a120a68c5f0cbd714071bd40b1992b644f9575e2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_bpftool_synctypes.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n#\n# Copyright (C) 2021 Isovalent, Inc.\n\nimport argparse\nimport re\nimport os, sys\n\nLINUX_ROOT = os.path.abspath(os.path.join(__file__,\n    os.pardir, os.pardir, os.pardir, os.pardir, os.pardir))\nBPFTOOL_DIR = os.getenv('BPFTOOL_DIR',\n    os.path.join(LINUX_ROOT, 'tools/bpf/bpftool'))\nBPFTOOL_BASHCOMP_DIR = os.getenv('BPFTOOL_BASHCOMP_DIR',\n    os.path.join(BPFTOOL_DIR, 'bash-completion'))\nBPFTOOL_DOC_DIR = os.getenv('BPFTOOL_DOC_DIR',\n    os.path.join(BPFTOOL_DIR, 'Documentation'))\nINCLUDE_DIR = os.getenv('INCLUDE_DIR',\n    os.path.join(LINUX_ROOT, 'tools/include'))\n\nretval = 0\n\nclass BlockParser(object):\n    \"\"\"\n    A parser for extracting set of values from blocks such as enums.\n    @reader: a pointer to the open file to parse\n    \"\"\"\n    def __init__(self, reader):\n        self.reader = reader\n\n    def search_block(self, start_marker):\n        \"\"\"\n        Search for a given structure in a file.\n        @start_marker: regex marking the beginning of a structure to parse\n        \"\"\"\n        offset = self.reader.tell()\n        array_start = re.search(start_marker, self.reader.read())\n        if array_start is None:\n            raise Exception('Failed to find start of block')\n        self.reader.seek(offset + array_start.start())\n\n    def parse(self, pattern, end_marker):\n        \"\"\"\n        Parse a block and return a set of values. Values to extract must be\n        on separate lines in the file.\n        @pattern: pattern used to identify the values to extract\n        @end_marker: regex marking the end of the block to parse\n        \"\"\"\n        entries = set()\n        while True:\n            line = self.reader.readline()\n            if not line or re.match(end_marker, line):\n                break\n            capture = pattern.search(line)\n            if capture and pattern.groups >= 1:\n                entries.add(capture.group(1))\n        return entries\n\nclass ArrayParser(BlockParser):\n    \"\"\"\n    A parser for extracting a set of values from some BPF-related arrays.\n    @reader: a pointer to the open file to parse\n    @array_name: name of the array to parse\n    \"\"\"\n    end_marker = re.compile('^};')\n\n    def __init__(self, reader, array_name):\n        self.array_name = array_name\n        self.start_marker = re.compile(f'(static )?const bool {self.array_name}\\[.*\\] = {{\\n')\n        super().__init__(reader)\n\n    def search_block(self):\n        \"\"\"\n        Search for the given array in a file.\n        \"\"\"\n        super().search_block(self.start_marker);\n\n    def parse(self):\n        \"\"\"\n        Parse a block and return data as a dictionary. Items to extract must be\n        on separate lines in the file.\n        \"\"\"\n        pattern = re.compile('\\[(BPF_\\w*)\\]\\s*= (true|false),?$')\n        entries = set()\n        while True:\n            line = self.reader.readline()\n            if line == '' or re.match(self.end_marker, line):\n                break\n            capture = pattern.search(line)\n            if capture:\n                entries |= {capture.group(1)}\n        return entries\n\nclass InlineListParser(BlockParser):\n    \"\"\"\n    A parser for extracting set of values from inline lists.\n    \"\"\"\n    def parse(self, pattern, end_marker):\n        \"\"\"\n        Parse a block and return a set of values. Multiple values to extract\n        can be on a same line in the file.\n        @pattern: pattern used to identify the values to extract\n        @end_marker: regex marking the end of the block to parse\n        \"\"\"\n        entries = set()\n        while True:\n            line = self.reader.readline()\n            if not line:\n                break\n            entries.update(pattern.findall(line))\n            if re.search(end_marker, line):\n                break\n        return entries\n\nclass FileExtractor(object):\n    \"\"\"\n    A generic reader for extracting data from a given file. This class contains\n    several helper methods that wrap around parser objects to extract values\n    from different structures.\n    This class does not offer a way to set a filename, which is expected to be\n    defined in children classes.\n    \"\"\"\n    def __init__(self):\n        self.reader = open(self.filename, 'r')\n\n    def close(self):\n        \"\"\"\n        Close the file used by the parser.\n        \"\"\"\n        self.reader.close()\n\n    def reset_read(self):\n        \"\"\"\n        Reset the file position indicator for this parser. This is useful when\n        parsing several structures in the file without respecting the order in\n        which those structures appear in the file.\n        \"\"\"\n        self.reader.seek(0)\n\n    def get_types_from_array(self, array_name):\n        \"\"\"\n        Search for and parse a list of allowed BPF_* enum members, for example:\n\n            const bool prog_type_name[] = {\n                    [BPF_PROG_TYPE_UNSPEC]                  = true,\n                    [BPF_PROG_TYPE_SOCKET_FILTER]           = true,\n                    [BPF_PROG_TYPE_KPROBE]                  = true,\n            };\n\n        Return a set of the enum members, for example:\n\n            {'BPF_PROG_TYPE_UNSPEC',\n             'BPF_PROG_TYPE_SOCKET_FILTER',\n             'BPF_PROG_TYPE_KPROBE'}\n\n        @array_name: name of the array to parse\n        \"\"\"\n        array_parser = ArrayParser(self.reader, array_name)\n        array_parser.search_block()\n        return array_parser.parse()\n\n    def get_enum(self, enum_name):\n        \"\"\"\n        Search for and parse an enum containing BPF_* members, for example:\n\n            enum bpf_prog_type {\n                    BPF_PROG_TYPE_UNSPEC,\n                    BPF_PROG_TYPE_SOCKET_FILTER,\n                    BPF_PROG_TYPE_KPROBE,\n            };\n\n        Return a set containing all member names, for example:\n\n            {'BPF_PROG_TYPE_UNSPEC',\n             'BPF_PROG_TYPE_SOCKET_FILTER',\n             'BPF_PROG_TYPE_KPROBE'}\n\n        @enum_name: name of the enum to parse\n        \"\"\"\n        start_marker = re.compile(f'enum {enum_name} {{\\n')\n        pattern = re.compile('^\\s*(BPF_\\w+),?(\\s+/\\*.*\\*/)?$')\n        end_marker = re.compile('^};')\n        parser = BlockParser(self.reader)\n        parser.search_block(start_marker)\n        return parser.parse(pattern, end_marker)\n\n    def make_enum_map(self, names, enum_prefix):\n        \"\"\"\n        Search for and parse an enum containing BPF_* members, just as get_enum\n        does. However, instead of just returning a set of the variant names,\n        also generate a textual representation from them by (assuming and)\n        removing a provided prefix and lowercasing the remainder. Then return a\n        dict mapping from name to textual representation.\n\n        @enum_values: a set of enum values; e.g., as retrieved by get_enum\n        @enum_prefix: the prefix to remove from each of the variants to infer\n        textual representation\n        \"\"\"\n        mapping = {}\n        for name in names:\n            if not name.startswith(enum_prefix):\n                raise Exception(f\"enum variant {name} does not start with {enum_prefix}\")\n            text = name[len(enum_prefix):].lower()\n            mapping[name] = text\n\n        return mapping\n\n    def __get_description_list(self, start_marker, pattern, end_marker):\n        parser = InlineListParser(self.reader)\n        parser.search_block(start_marker)\n        return parser.parse(pattern, end_marker)\n\n    def get_rst_list(self, block_name):\n        \"\"\"\n        Search for and parse a list of type names from RST documentation, for\n        example:\n\n             |       *TYPE* := {\n             |               **socket** | **kprobe** |\n             |               **kretprobe**\n             |       }\n\n        Return a set containing all type names, for example:\n\n            {'socket', 'kprobe', 'kretprobe'}\n\n        @block_name: name of the blog to parse, 'TYPE' in the example\n        \"\"\"\n        start_marker = re.compile(f'\\*{block_name}\\* := {{')\n        pattern = re.compile('\\*\\*([\\w/-]+)\\*\\*')\n        end_marker = re.compile('}\\n')\n        return self.__get_description_list(start_marker, pattern, end_marker)\n\n    def get_help_list(self, block_name):\n        \"\"\"\n        Search for and parse a list of type names from a help message in\n        bpftool, for example:\n\n            \"       TYPE := { socket | kprobe |\\\\n\"\n            \"               kretprobe }\\\\n\"\n\n        Return a set containing all type names, for example:\n\n            {'socket', 'kprobe', 'kretprobe'}\n\n        @block_name: name of the blog to parse, 'TYPE' in the example\n        \"\"\"\n        start_marker = re.compile(f'\"\\s*{block_name} := {{')\n        pattern = re.compile('([\\w/]+) [|}]')\n        end_marker = re.compile('}')\n        return self.__get_description_list(start_marker, pattern, end_marker)\n\n    def get_help_list_macro(self, macro):\n        \"\"\"\n        Search for and parse a list of values from a help message starting with\n        a macro in bpftool, for example:\n\n            \"       \" HELP_SPEC_OPTIONS \" |\\\\n\"\n            \"                    {-f|--bpffs} | {-m|--mapcompat} | {-n|--nomount} }\\\\n\"\n\n        Return a set containing all item names, for example:\n\n            {'-f', '--bpffs', '-m', '--mapcompat', '-n', '--nomount'}\n\n        @macro: macro starting the block, 'HELP_SPEC_OPTIONS' in the example\n        \"\"\"\n        start_marker = re.compile(f'\"\\s*{macro}\\s*\" [|}}]')\n        pattern = re.compile('([\\w-]+) ?(?:\\||}[ }\\]])')\n        end_marker = re.compile('}\\\\\\\\n')\n        return self.__get_description_list(start_marker, pattern, end_marker)\n\n    def get_bashcomp_list(self, block_name):\n        \"\"\"\n        Search for and parse a list of type names from a variable in bash\n        completion file, for example:\n\n            local BPFTOOL_PROG_LOAD_TYPES='socket kprobe \\\\\n                kretprobe'\n\n        Return a set containing all type names, for example:\n\n            {'socket', 'kprobe', 'kretprobe'}\n\n        @block_name: name of the blog to parse, 'TYPE' in the example\n        \"\"\"\n        start_marker = re.compile(f'local {block_name}=\\'')\n        pattern = re.compile('(?:.*=\\')?([\\w/]+)')\n        end_marker = re.compile('\\'$')\n        return self.__get_description_list(start_marker, pattern, end_marker)\n\nclass SourceFileExtractor(FileExtractor):\n    \"\"\"\n    An abstract extractor for a source file with usage message.\n    This class does not offer a way to set a filename, which is expected to be\n    defined in children classes.\n    \"\"\"\n    def get_options(self):\n        return self.get_help_list_macro('HELP_SPEC_OPTIONS')\n\nclass MainHeaderFileExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for bpftool's main.h\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DIR, 'main.h')\n\n    def get_common_options(self):\n        \"\"\"\n        Parse the list of common options in main.h (options that apply to all\n        commands), which looks to the lists of options in other source files\n        but has different start and end markers:\n\n            \"OPTIONS := { {-j|--json} [{-p|--pretty}] | {-d|--debug}\"\n\n        Return a set containing all options, such as:\n\n            {'-p', '-d', '--pretty', '--debug', '--json', '-j'}\n        \"\"\"\n        start_marker = re.compile(f'\"OPTIONS :=')\n        pattern = re.compile('([\\w-]+) ?(?:\\||}[ }\\]\"])')\n        end_marker = re.compile('#define')\n\n        parser = InlineListParser(self.reader)\n        parser.search_block(start_marker)\n        return parser.parse(pattern, end_marker)\n\nclass ManSubstitutionsExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for substitutions.rst\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DOC_DIR, 'substitutions.rst')\n\n    def get_common_options(self):\n        \"\"\"\n        Parse the list of common options in substitutions.rst (options that\n        apply to all commands).\n\n        Return a set containing all options, such as:\n\n            {'-p', '-d', '--pretty', '--debug', '--json', '-j'}\n        \"\"\"\n        start_marker = re.compile('\\|COMMON_OPTIONS\\| replace:: {')\n        pattern = re.compile('\\*\\*([\\w/-]+)\\*\\*')\n        end_marker = re.compile('}$')\n\n        parser = InlineListParser(self.reader)\n        parser.search_block(start_marker)\n        return parser.parse(pattern, end_marker)\n\nclass ProgFileExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for bpftool's prog.c.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DIR, 'prog.c')\n\n    def get_attach_types(self):\n        types = self.get_types_from_array('attach_types')\n        return self.make_enum_map(types, 'BPF_')\n\n    def get_prog_attach_help(self):\n        return self.get_help_list('ATTACH_TYPE')\n\nclass MapFileExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for bpftool's map.c.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DIR, 'map.c')\n\n    def get_map_help(self):\n        return self.get_help_list('TYPE')\n\nclass CgroupFileExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for bpftool's cgroup.c.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DIR, 'cgroup.c')\n\n    def get_prog_attach_help(self):\n        return self.get_help_list('ATTACH_TYPE')\n\nclass GenericSourceExtractor(SourceFileExtractor):\n    \"\"\"\n    An extractor for generic source code files.\n    \"\"\"\n    filename = \"\"\n\n    def __init__(self, filename):\n        self.filename = os.path.join(BPFTOOL_DIR, filename)\n        super().__init__()\n\nclass BpfHeaderExtractor(FileExtractor):\n    \"\"\"\n    An extractor for the UAPI BPF header.\n    \"\"\"\n    filename = os.path.join(INCLUDE_DIR, 'uapi/linux/bpf.h')\n\n    def __init__(self):\n        super().__init__()\n        self.attach_types = {}\n\n    def get_prog_types(self):\n        return self.get_enum('bpf_prog_type')\n\n    def get_map_type_map(self):\n        names = self.get_enum('bpf_map_type')\n        return self.make_enum_map(names, 'BPF_MAP_TYPE_')\n\n    def get_attach_type_map(self):\n        if not self.attach_types:\n          names = self.get_enum('bpf_attach_type')\n          self.attach_types = self.make_enum_map(names, 'BPF_')\n        return self.attach_types\n\n    def get_cgroup_attach_type_map(self):\n        if not self.attach_types:\n            self.get_attach_type_map()\n        return {name: text for name, text in self.attach_types.items()\n            if name.startswith('BPF_CGROUP')}\n\nclass ManPageExtractor(FileExtractor):\n    \"\"\"\n    An abstract extractor for an RST documentation page.\n    This class does not offer a way to set a filename, which is expected to be\n    defined in children classes.\n    \"\"\"\n    def get_options(self):\n        return self.get_rst_list('OPTIONS')\n\nclass ManProgExtractor(ManPageExtractor):\n    \"\"\"\n    An extractor for bpftool-prog.rst.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DOC_DIR, 'bpftool-prog.rst')\n\n    def get_attach_types(self):\n        return self.get_rst_list('ATTACH_TYPE')\n\nclass ManMapExtractor(ManPageExtractor):\n    \"\"\"\n    An extractor for bpftool-map.rst.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DOC_DIR, 'bpftool-map.rst')\n\n    def get_map_types(self):\n        return self.get_rst_list('TYPE')\n\nclass ManCgroupExtractor(ManPageExtractor):\n    \"\"\"\n    An extractor for bpftool-cgroup.rst.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_DOC_DIR, 'bpftool-cgroup.rst')\n\n    def get_attach_types(self):\n        return self.get_rst_list('ATTACH_TYPE')\n\nclass ManGenericExtractor(ManPageExtractor):\n    \"\"\"\n    An extractor for generic RST documentation pages.\n    \"\"\"\n    filename = \"\"\n\n    def __init__(self, filename):\n        self.filename = os.path.join(BPFTOOL_DIR, filename)\n        super().__init__()\n\nclass BashcompExtractor(FileExtractor):\n    \"\"\"\n    An extractor for bpftool's bash completion file.\n    \"\"\"\n    filename = os.path.join(BPFTOOL_BASHCOMP_DIR, 'bpftool')\n\n    def get_prog_attach_types(self):\n        return self.get_bashcomp_list('BPFTOOL_PROG_ATTACH_TYPES')\n\ndef verify(first_set, second_set, message):\n    \"\"\"\n    Print all values that differ between two sets.\n    @first_set: one set to compare\n    @second_set: another set to compare\n    @message: message to print for values belonging to only one of the sets\n    \"\"\"\n    global retval\n    diff = first_set.symmetric_difference(second_set)\n    if diff:\n        print(message, diff)\n        retval = 1\n\ndef main():\n    # No arguments supported at this time, but print usage for -h|--help\n    argParser = argparse.ArgumentParser(description=\"\"\"\n    Verify that bpftool's code, help messages, documentation and bash\n    completion are all in sync on program types, map types, attach types, and\n    options. Also check that bpftool is in sync with the UAPI BPF header.\n    \"\"\")\n    args = argParser.parse_args()\n\n    bpf_info = BpfHeaderExtractor()\n\n    # Map types (names)\n\n    map_info = MapFileExtractor()\n    source_map_types = set(bpf_info.get_map_type_map().values())\n    source_map_types.discard('unspec')\n\n    # BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED and BPF_MAP_TYPE_CGROUP_STORAGE\n    # share the same enum value and source_map_types picks\n    # BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED/cgroup_storage_deprecated.\n    # Replace 'cgroup_storage_deprecated' with 'cgroup_storage'\n    # so it aligns with what `bpftool map help` shows.\n    source_map_types.remove('cgroup_storage_deprecated')\n    source_map_types.add('cgroup_storage')\n\n    help_map_types = map_info.get_map_help()\n    help_map_options = map_info.get_options()\n    map_info.close()\n\n    man_map_info = ManMapExtractor()\n    man_map_options = man_map_info.get_options()\n    man_map_types = man_map_info.get_map_types()\n    man_map_info.close()\n\n    verify(source_map_types, help_map_types,\n            f'Comparing {BpfHeaderExtractor.filename} (bpf_map_type) and {MapFileExtractor.filename} (do_help() TYPE):')\n    verify(source_map_types, man_map_types,\n            f'Comparing {BpfHeaderExtractor.filename} (bpf_map_type) and {ManMapExtractor.filename} (TYPE):')\n    verify(help_map_options, man_map_options,\n            f'Comparing {MapFileExtractor.filename} (do_help() OPTIONS) and {ManMapExtractor.filename} (OPTIONS):')\n\n    # Attach types (names)\n\n    prog_info = ProgFileExtractor()\n    source_prog_attach_types = set(prog_info.get_attach_types().values())\n\n    help_prog_attach_types = prog_info.get_prog_attach_help()\n    help_prog_options = prog_info.get_options()\n    prog_info.close()\n\n    man_prog_info = ManProgExtractor()\n    man_prog_options = man_prog_info.get_options()\n    man_prog_attach_types = man_prog_info.get_attach_types()\n    man_prog_info.close()\n\n\n    bashcomp_info = BashcompExtractor()\n    bashcomp_prog_attach_types = bashcomp_info.get_prog_attach_types()\n    bashcomp_info.close()\n\n    verify(source_prog_attach_types, help_prog_attach_types,\n            f'Comparing {ProgFileExtractor.filename} (bpf_attach_type) and {ProgFileExtractor.filename} (do_help() ATTACH_TYPE):')\n    verify(source_prog_attach_types, man_prog_attach_types,\n            f'Comparing {ProgFileExtractor.filename} (bpf_attach_type) and {ManProgExtractor.filename} (ATTACH_TYPE):')\n    verify(help_prog_options, man_prog_options,\n            f'Comparing {ProgFileExtractor.filename} (do_help() OPTIONS) and {ManProgExtractor.filename} (OPTIONS):')\n    verify(source_prog_attach_types, bashcomp_prog_attach_types,\n            f'Comparing {ProgFileExtractor.filename} (bpf_attach_type) and {BashcompExtractor.filename} (BPFTOOL_PROG_ATTACH_TYPES):')\n\n    # Cgroup attach types\n    source_cgroup_attach_types = set(bpf_info.get_cgroup_attach_type_map().values())\n    bpf_info.close()\n\n    cgroup_info = CgroupFileExtractor()\n    help_cgroup_attach_types = cgroup_info.get_prog_attach_help()\n    help_cgroup_options = cgroup_info.get_options()\n    cgroup_info.close()\n\n    man_cgroup_info = ManCgroupExtractor()\n    man_cgroup_options = man_cgroup_info.get_options()\n    man_cgroup_attach_types = man_cgroup_info.get_attach_types()\n    man_cgroup_info.close()\n\n    verify(source_cgroup_attach_types, help_cgroup_attach_types,\n            f'Comparing {BpfHeaderExtractor.filename} (bpf_attach_type) and {CgroupFileExtractor.filename} (do_help() ATTACH_TYPE):')\n    verify(source_cgroup_attach_types, man_cgroup_attach_types,\n            f'Comparing {BpfHeaderExtractor.filename} (bpf_attach_type) and {ManCgroupExtractor.filename} (ATTACH_TYPE):')\n    verify(help_cgroup_options, man_cgroup_options,\n            f'Comparing {CgroupFileExtractor.filename} (do_help() OPTIONS) and {ManCgroupExtractor.filename} (OPTIONS):')\n\n    # Options for remaining commands\n\n    for cmd in [ 'btf', 'feature', 'gen', 'iter', 'link', 'net', 'perf', 'struct_ops', ]:\n        source_info = GenericSourceExtractor(cmd + '.c')\n        help_cmd_options = source_info.get_options()\n        source_info.close()\n\n        man_cmd_info = ManGenericExtractor(os.path.join(BPFTOOL_DOC_DIR, 'bpftool-' + cmd + '.rst'))\n        man_cmd_options = man_cmd_info.get_options()\n        man_cmd_info.close()\n\n        verify(help_cmd_options, man_cmd_options,\n                f'Comparing {source_info.filename} (do_help() OPTIONS) and {man_cmd_info.filename} (OPTIONS):')\n\n    source_main_info = GenericSourceExtractor('main.c')\n    help_main_options = source_main_info.get_options()\n    source_main_info.close()\n\n    man_main_info = ManGenericExtractor(os.path.join(BPFTOOL_DOC_DIR, 'bpftool.rst'))\n    man_main_options = man_main_info.get_options()\n    man_main_info.close()\n\n    verify(help_main_options, man_main_options,\n            f'Comparing {source_main_info.filename} (do_help() OPTIONS) and {man_main_info.filename} (OPTIONS):')\n\n    # Compare common options (options that apply to all commands)\n\n    main_hdr_info = MainHeaderFileExtractor()\n    source_common_options = main_hdr_info.get_common_options()\n    main_hdr_info.close()\n\n    man_substitutions = ManSubstitutionsExtractor()\n    man_common_options = man_substitutions.get_common_options()\n    man_substitutions.close()\n\n    verify(source_common_options, man_common_options,\n            f'Comparing common options from {main_hdr_info.filename} (HELP_SPEC_OPTIONS) and {man_substitutions.filename}:')\n\n    sys.exit(retval)\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}