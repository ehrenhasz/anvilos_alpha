{
  "module_name": "test_xdp_vlan.sh",
  "hash_id": "5c7ae1a6e5d3a86ab10e1cd0acbc76a1da7626e926612816ca042105f7d45aa3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_xdp_vlan.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Author: Jesper Dangaard Brouer <hawk@kernel.org>\n\n# Kselftest framework requirement - SKIP code is 4.\nreadonly KSFT_SKIP=4\nreadonly NS1=\"ns1-$(mktemp -u XXXXXX)\"\nreadonly NS2=\"ns2-$(mktemp -u XXXXXX)\"\n\n# Allow wrapper scripts to name test\nif [ -z \"$TESTNAME\" ]; then\n    TESTNAME=xdp_vlan\nfi\n\n# Default XDP mode\nXDP_MODE=xdpgeneric\n\nusage() {\n  echo \"Testing XDP + TC eBPF VLAN manipulations: $TESTNAME\"\n  echo \"\"\n  echo \"Usage: $0 [-vfh]\"\n  echo \"  -v | --verbose : Verbose\"\n  echo \"  --flush        : Flush before starting (e.g. after --interactive)\"\n  echo \"  --interactive  : Keep netns setup running after test-run\"\n  echo \"  --mode=XXX     : Choose XDP mode (xdp | xdpgeneric | xdpdrv)\"\n  echo \"\"\n}\n\nvalid_xdp_mode()\n{\n\tlocal mode=$1\n\n\tcase \"$mode\" in\n\t\txdpgeneric | xdpdrv | xdp)\n\t\t\treturn 0\n\t\t\t;;\n\t\t*)\n\t\t\treturn 1\n\tesac\n}\n\ncleanup()\n{\n\tlocal status=$?\n\n\tif [ \"$status\" = \"0\" ]; then\n\t\techo \"selftests: $TESTNAME [PASS]\";\n\telse\n\t\techo \"selftests: $TESTNAME [FAILED]\";\n\tfi\n\n\tif [ -n \"$INTERACTIVE\" ]; then\n\t\techo \"Namespace setup still active explore with:\"\n\t\techo \" ip netns exec ${NS1} bash\"\n\t\techo \" ip netns exec ${NS2} bash\"\n\t\texit $status\n\tfi\n\n\tset +e\n\tip link del veth1 2> /dev/null\n\tip netns del ${NS1} 2> /dev/null\n\tip netns del ${NS2} 2> /dev/null\n}\n\n# Using external program \"getopt\" to get --long-options\nOPTIONS=$(getopt -o hvfi: \\\n    --long verbose,flush,help,interactive,debug,mode: -- \"$@\")\nif (( $? != 0 )); then\n    usage\n    echo \"selftests: $TESTNAME [FAILED] Error calling getopt, unknown option?\"\n    exit 2\nfi\neval set -- \"$OPTIONS\"\n\n##  --- Parse command line arguments / parameters ---\nwhile true; do\n\tcase \"$1\" in\n\t    -v | --verbose)\n\t\texport VERBOSE=yes\n\t\tshift\n\t\t;;\n\t    -i | --interactive | --debug )\n\t\tINTERACTIVE=yes\n\t\tshift\n\t\t;;\n\t    -f | --flush )\n\t\tcleanup\n\t\tshift\n\t\t;;\n\t    --mode )\n\t\tshift\n\t\tXDP_MODE=$1\n\t\tshift\n\t\t;;\n\t    -- )\n\t\tshift\n\t\tbreak\n\t\t;;\n\t    -h | --help )\n\t\tusage;\n\t\techo \"selftests: $TESTNAME [SKIP] usage help info requested\"\n\t\texit $KSFT_SKIP\n\t\t;;\n\t    * )\n\t\tshift\n\t\tbreak\n\t\t;;\n\tesac\ndone\n\nif [ \"$EUID\" -ne 0 ]; then\n\techo \"selftests: $TESTNAME [FAILED] need root privileges\"\n\texit 1\nfi\n\nvalid_xdp_mode $XDP_MODE\nif [ $? -ne 0 ]; then\n\techo \"selftests: $TESTNAME [FAILED] unknown XDP mode ($XDP_MODE)\"\n\texit 1\nfi\n\nip link set dev lo xdpgeneric off 2>/dev/null > /dev/null\nif [ $? -ne 0 ]; then\n\techo \"selftests: $TESTNAME [SKIP] need ip xdp support\"\n\texit $KSFT_SKIP\nfi\n\n# Interactive mode likely require us to cleanup netns\nif [ -n \"$INTERACTIVE\" ]; then\n\tip link del veth1 2> /dev/null\n\tip netns del ${NS1} 2> /dev/null\n\tip netns del ${NS2} 2> /dev/null\nfi\n\n# Exit on failure\nset -e\n\n# Some shell-tools dependencies\nwhich ip > /dev/null\nwhich tc > /dev/null\nwhich ethtool > /dev/null\n\n# Make rest of shell verbose, showing comments as doc/info\nif [ -n \"$VERBOSE\" ]; then\n    set -v\nfi\n\n# Create two namespaces\nip netns add ${NS1}\nip netns add ${NS2}\n\n# Run cleanup if failing or on kill\ntrap cleanup 0 2 3 6 9\n\n# Create veth pair\nip link add veth1 type veth peer name veth2\n\n# Move veth1 and veth2 into the respective namespaces\nip link set veth1 netns ${NS1}\nip link set veth2 netns ${NS2}\n\n# NOTICE: XDP require VLAN header inside packet payload\n#  - Thus, disable VLAN offloading driver features\n#  - For veth REMEMBER TX side VLAN-offload\n#\n# Disable rx-vlan-offload (mostly needed on ns1)\nip netns exec ${NS1} ethtool -K veth1 rxvlan off\nip netns exec ${NS2} ethtool -K veth2 rxvlan off\n#\n# Disable tx-vlan-offload (mostly needed on ns2)\nip netns exec ${NS2} ethtool -K veth2 txvlan off\nip netns exec ${NS1} ethtool -K veth1 txvlan off\n\nexport IPADDR1=100.64.41.1\nexport IPADDR2=100.64.41.2\n\n# In ns1/veth1 add IP-addr on plain net_device\nip netns exec ${NS1} ip addr add ${IPADDR1}/24 dev veth1\nip netns exec ${NS1} ip link set veth1 up\n\n# In ns2/veth2 create VLAN device\nexport VLAN=4011\nexport DEVNS2=veth2\nip netns exec ${NS2} ip link add link $DEVNS2 name $DEVNS2.$VLAN type vlan id $VLAN\nip netns exec ${NS2} ip addr add ${IPADDR2}/24 dev $DEVNS2.$VLAN\nip netns exec ${NS2} ip link set $DEVNS2 up\nip netns exec ${NS2} ip link set $DEVNS2.$VLAN up\n\n# Bringup lo in netns (to avoids confusing people using --interactive)\nip netns exec ${NS1} ip link set lo up\nip netns exec ${NS2} ip link set lo up\n\n# At this point, the hosts cannot reach each-other,\n# because ns2 are using VLAN tags on the packets.\n\nip netns exec ${NS2} sh -c 'ping -W 1 -c 1 100.64.41.1 || echo \"Success: First ping must fail\"'\n\n\n# Now we can use the test_xdp_vlan.c program to pop/push these VLAN tags\n# ----------------------------------------------------------------------\n# In ns1: ingress use XDP to remove VLAN tags\nexport DEVNS1=veth1\nexport BPF_FILE=test_xdp_vlan.bpf.o\n\n# First test: Remove VLAN by setting VLAN ID 0, using \"xdp_vlan_change\"\nexport XDP_PROG=xdp_vlan_change\nip netns exec ${NS1} ip link set $DEVNS1 $XDP_MODE object $BPF_FILE section $XDP_PROG\n\n# In ns1: egress use TC to add back VLAN tag 4011\n#  (del cmd)\n#  tc qdisc del dev $DEVNS1 clsact 2> /dev/null\n#\nip netns exec ${NS1} tc qdisc add dev $DEVNS1 clsact\nip netns exec ${NS1} tc filter add dev $DEVNS1 egress \\\n  prio 1 handle 1 bpf da obj $BPF_FILE sec tc_vlan_push\n\n# Now the namespaces can reach each-other, test with ping:\nip netns exec ${NS2} ping -i 0.2 -W 2 -c 2 $IPADDR1\nip netns exec ${NS1} ping -i 0.2 -W 2 -c 2 $IPADDR2\n\n# Second test: Replace xdp prog, that fully remove vlan header\n#\n# Catch kernel bug for generic-XDP, that does didn't allow us to\n# remove a VLAN header, because skb->protocol still contain VLAN\n# ETH_P_8021Q indication, and this cause overwriting of our changes.\n#\nexport XDP_PROG=xdp_vlan_remove_outer2\nip netns exec ${NS1} ip link set $DEVNS1 $XDP_MODE off\nip netns exec ${NS1} ip link set $DEVNS1 $XDP_MODE object $BPF_FILE section $XDP_PROG\n\n# Now the namespaces should still be able reach each-other, test with ping:\nip netns exec ${NS2} ping -i 0.2 -W 2 -c 2 $IPADDR1\nip netns exec ${NS1} ping -i 0.2 -W 2 -c 2 $IPADDR2\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}