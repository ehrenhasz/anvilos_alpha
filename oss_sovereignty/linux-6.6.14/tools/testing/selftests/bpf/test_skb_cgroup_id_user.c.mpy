{
  "module_name": "test_skb_cgroup_id_user.c",
  "hash_id": "04def48ca17807ee33db3ad98920becff76162ccdb1715aa02a9f076d250b75c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_skb_cgroup_id_user.c",
  "human_readable_source": "\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"cgroup_helpers.h\"\n\n#define CGROUP_PATH\t\t\"/skb_cgroup_test\"\n#define NUM_CGROUP_LEVELS\t4\n\n \n#define LINKLOCAL_MULTICAST\t\"ff02::1\"\n\nstatic int mk_dst_addr(const char *ip, const char *iface,\n\t\t       struct sockaddr_in6 *dst)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\n\tdst->sin6_family = AF_INET6;\n\tdst->sin6_port = htons(1025);\n\n\tif (inet_pton(AF_INET6, ip, &dst->sin6_addr) != 1) {\n\t\tlog_err(\"Invalid IPv6: %s\", ip);\n\t\treturn -1;\n\t}\n\n\tdst->sin6_scope_id = if_nametoindex(iface);\n\tif (!dst->sin6_scope_id) {\n\t\tlog_err(\"Failed to get index of iface: %s\", iface);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_packet(const char *iface)\n{\n\tstruct sockaddr_in6 dst;\n\tchar msg[] = \"msg\";\n\tint err = 0;\n\tint fd = -1;\n\n\tif (mk_dst_addr(LINKLOCAL_MULTICAST, iface, &dst))\n\t\tgoto err;\n\n\tfd = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (fd == -1) {\n\t\tlog_err(\"Failed to create UDP socket\");\n\t\tgoto err;\n\t}\n\n\tif (sendto(fd, &msg, sizeof(msg), 0, (const struct sockaddr *)&dst,\n\t\t   sizeof(dst)) == -1) {\n\t\tlog_err(\"Failed to send datagram\");\n\t\tgoto err;\n\t}\n\n\tgoto out;\nerr:\n\terr = -1;\nout:\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn err;\n}\n\nint get_map_fd_by_prog_id(int prog_id)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\t__u32 map_ids[1];\n\tint prog_fd = -1;\n\tint map_fd = -1;\n\n\tprog_fd = bpf_prog_get_fd_by_id(prog_id);\n\tif (prog_fd < 0) {\n\t\tlog_err(\"Failed to get fd by prog id %d\", prog_id);\n\t\tgoto err;\n\t}\n\n\tinfo.nr_map_ids = 1;\n\tinfo.map_ids = (__u64) (unsigned long) map_ids;\n\n\tif (bpf_prog_get_info_by_fd(prog_fd, &info, &info_len)) {\n\t\tlog_err(\"Failed to get info by prog fd %d\", prog_fd);\n\t\tgoto err;\n\t}\n\n\tif (!info.nr_map_ids) {\n\t\tlog_err(\"No maps found for prog fd %d\", prog_fd);\n\t\tgoto err;\n\t}\n\n\tmap_fd = bpf_map_get_fd_by_id(map_ids[0]);\n\tif (map_fd < 0)\n\t\tlog_err(\"Failed to get fd by map id %d\", map_ids[0]);\nerr:\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\treturn map_fd;\n}\n\nint check_ancestor_cgroup_ids(int prog_id)\n{\n\t__u64 actual_ids[NUM_CGROUP_LEVELS], expected_ids[NUM_CGROUP_LEVELS];\n\t__u32 level;\n\tint err = 0;\n\tint map_fd;\n\n\texpected_ids[0] = get_cgroup_id(\"/..\");\t \n\texpected_ids[1] = get_cgroup_id(\"\");\n\texpected_ids[2] = get_cgroup_id(CGROUP_PATH);\n\texpected_ids[3] = 0;  \n\n\tmap_fd = get_map_fd_by_prog_id(prog_id);\n\tif (map_fd < 0)\n\t\tgoto err;\n\n\tfor (level = 0; level < NUM_CGROUP_LEVELS; ++level) {\n\t\tif (bpf_map_lookup_elem(map_fd, &level, &actual_ids[level])) {\n\t\t\tlog_err(\"Failed to lookup key %d\", level);\n\t\t\tgoto err;\n\t\t}\n\t\tif (actual_ids[level] != expected_ids[level]) {\n\t\t\tlog_err(\"%llx (actual) != %llx (expected), level: %u\\n\",\n\t\t\t\tactual_ids[level], expected_ids[level], level);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tgoto out;\nerr:\n\terr = -1;\nout:\n\tif (map_fd >= 0)\n\t\tclose(map_fd);\n\treturn err;\n}\n\nint main(int argc, char **argv)\n{\n\tint cgfd = -1;\n\tint err = 0;\n\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s iface prog_id\\n\", argv[0]);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tcgfd = cgroup_setup_and_join(CGROUP_PATH);\n\tif (cgfd < 0)\n\t\tgoto err;\n\n\tif (send_packet(argv[1]))\n\t\tgoto err;\n\n\tif (check_ancestor_cgroup_ids(atoi(argv[2])))\n\t\tgoto err;\n\n\tgoto out;\nerr:\n\terr = -1;\nout:\n\tclose(cgfd);\n\tcleanup_cgroup_environment();\n\tprintf(\"[%s]\\n\", err ? \"FAIL\" : \"PASS\");\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}