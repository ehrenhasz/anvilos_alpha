{
  "module_name": "xfrm_info.c",
  "hash_id": "d852f83c55c54b26d56d6f252b0958c50f9ee3b5c4200395bab1ee63af1578b4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xfrm_info.c",
  "human_readable_source": "\n\n \n\n#include <net/if.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_link.h>\n\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n#include \"xfrm_info.skel.h\"\n\n#define NS0 \"xfrm_test_ns0\"\n#define NS1 \"xfrm_test_ns1\"\n#define NS2 \"xfrm_test_ns2\"\n\n#define IF_ID_0_TO_1 1\n#define IF_ID_0_TO_2 2\n#define IF_ID_1 3\n#define IF_ID_2 4\n\n#define IP4_ADDR_VETH01 \"172.16.1.100\"\n#define IP4_ADDR_VETH10 \"172.16.1.200\"\n#define IP4_ADDR_VETH02 \"172.16.2.100\"\n#define IP4_ADDR_VETH20 \"172.16.2.200\"\n\n#define ESP_DUMMY_PARAMS \\\n    \"proto esp aead 'rfc4106(gcm(aes))' \" \\\n    \"0xe4d8f4b4da1df18a3510b3781496daa82488b713 128 mode tunnel \"\n\nstatic int attach_tc_prog(struct bpf_tc_hook *hook, int igr_fd, int egr_fd)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, opts1, .handle = 1, .priority = 1,\n\t\t    .prog_fd = igr_fd);\n\tLIBBPF_OPTS(bpf_tc_opts, opts2, .handle = 1, .priority = 1,\n\t\t    .prog_fd = egr_fd);\n\tint ret;\n\n\tret = bpf_tc_hook_create(hook);\n\tif (!ASSERT_OK(ret, \"create tc hook\"))\n\t\treturn ret;\n\n\tif (igr_fd >= 0) {\n\t\thook->attach_point = BPF_TC_INGRESS;\n\t\tret = bpf_tc_attach(hook, &opts1);\n\t\tif (!ASSERT_OK(ret, \"bpf_tc_attach\")) {\n\t\t\tbpf_tc_hook_destroy(hook);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (egr_fd >= 0) {\n\t\thook->attach_point = BPF_TC_EGRESS;\n\t\tret = bpf_tc_attach(hook, &opts2);\n\t\tif (!ASSERT_OK(ret, \"bpf_tc_attach\")) {\n\t\t\tbpf_tc_hook_destroy(hook);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cleanup(void)\n{\n\tSYS_NOFAIL(\"test -f /var/run/netns/\" NS0 \" && ip netns delete \" NS0);\n\tSYS_NOFAIL(\"test -f /var/run/netns/\" NS1 \" && ip netns delete \" NS1);\n\tSYS_NOFAIL(\"test -f /var/run/netns/\" NS2 \" && ip netns delete \" NS2);\n}\n\nstatic int config_underlay(void)\n{\n\tSYS(fail, \"ip netns add \" NS0);\n\tSYS(fail, \"ip netns add \" NS1);\n\tSYS(fail, \"ip netns add \" NS2);\n\n\t \n\tSYS(fail, \"ip link add veth01 netns \" NS0 \" type veth peer name veth10 netns \" NS1);\n\tSYS(fail, \"ip -net \" NS0 \" addr add \" IP4_ADDR_VETH01 \"/24 dev veth01\");\n\tSYS(fail, \"ip -net \" NS0 \" link set dev veth01 up\");\n\tSYS(fail, \"ip -net \" NS1 \" addr add \" IP4_ADDR_VETH10 \"/24 dev veth10\");\n\tSYS(fail, \"ip -net \" NS1 \" link set dev veth10 up\");\n\n\t \n\tSYS(fail, \"ip link add veth02 netns \" NS0 \" type veth peer name veth20 netns \" NS2);\n\tSYS(fail, \"ip -net \" NS0 \" addr add \" IP4_ADDR_VETH02 \"/24 dev veth02\");\n\tSYS(fail, \"ip -net \" NS0 \" link set dev veth02 up\");\n\tSYS(fail, \"ip -net \" NS2 \" addr add \" IP4_ADDR_VETH20 \"/24 dev veth20\");\n\tSYS(fail, \"ip -net \" NS2 \" link set dev veth20 up\");\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic int setup_xfrm_tunnel_ns(const char *ns, const char *ipv4_local,\n\t\t\t\tconst char *ipv4_remote, int if_id)\n{\n\t \n\tSYS(fail, \"ip -net %s xfrm state add src %s dst %s spi 1 \"\n\t    ESP_DUMMY_PARAMS \"if_id %d\", ns, ipv4_local, ipv4_remote, if_id);\n\n\t \n\tSYS(fail, \"ip -net %s xfrm state add src %s dst %s spi 1 \"\n\t    ESP_DUMMY_PARAMS \"if_id %d\", ns, ipv4_remote, ipv4_local, if_id);\n\n\t \n\tSYS(fail, \"ip -net %s xfrm policy add dir out src 0.0.0.0/0 dst 0.0.0.0/0 \"\n\t    \"if_id %d tmpl src %s dst %s proto esp mode tunnel if_id %d\", ns,\n\t    if_id, ipv4_local, ipv4_remote, if_id);\n\n\t \n\tSYS(fail, \"ip -net %s xfrm policy add dir in src 0.0.0.0/0 dst 0.0.0.0/0 \"\n\t    \"if_id %d tmpl src %s dst %s proto esp mode tunnel if_id %d\", ns,\n\t    if_id, ipv4_remote, ipv4_local, if_id);\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic int setup_xfrm_tunnel(const char *ns_a, const char *ns_b,\n\t\t\t     const char *ipv4_a, const char *ipv4_b,\n\t\t\t     int if_id_a, int if_id_b)\n{\n\treturn setup_xfrm_tunnel_ns(ns_a, ipv4_a, ipv4_b, if_id_a) ||\n\t\tsetup_xfrm_tunnel_ns(ns_b, ipv4_b, ipv4_a, if_id_b);\n}\n\nstatic struct rtattr *rtattr_add(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t unsigned short len)\n{\n\tstruct rtattr *rta =\n\t\t(struct rtattr *)((uint8_t *)nh + RTA_ALIGN(nh->nlmsg_len));\n\trta->rta_type = type;\n\trta->rta_len = RTA_LENGTH(len);\n\tnh->nlmsg_len = RTA_ALIGN(nh->nlmsg_len) + RTA_ALIGN(rta->rta_len);\n\treturn rta;\n}\n\nstatic struct rtattr *rtattr_add_str(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t     const char *s)\n{\n\tstruct rtattr *rta = rtattr_add(nh, type, strlen(s));\n\n\tmemcpy(RTA_DATA(rta), s, strlen(s));\n\treturn rta;\n}\n\nstatic struct rtattr *rtattr_begin(struct nlmsghdr *nh, unsigned short type)\n{\n\treturn rtattr_add(nh, type, 0);\n}\n\nstatic void rtattr_end(struct nlmsghdr *nh, struct rtattr *attr)\n{\n\tuint8_t *end = (uint8_t *)nh + nh->nlmsg_len;\n\n\tattr->rta_len = end - (uint8_t *)attr;\n}\n\nstatic int setup_xfrmi_external_dev(const char *ns)\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tstruct ifinfomsg info;\n\t\tunsigned char data[128];\n\t} req;\n\tstruct rtattr *link_info, *info_data;\n\tstruct nstoken *nstoken;\n\tint ret = -1, sock = -1;\n\tstruct nlmsghdr *nh;\n\n\tmemset(&req, 0, sizeof(req));\n\tnh = &req.nh;\n\tnh->nlmsg_len = NLMSG_LENGTH(sizeof(req.info));\n\tnh->nlmsg_type = RTM_NEWLINK;\n\tnh->nlmsg_flags |= NLM_F_CREATE | NLM_F_REQUEST;\n\n\trtattr_add_str(nh, IFLA_IFNAME, \"ipsec0\");\n\tlink_info = rtattr_begin(nh, IFLA_LINKINFO);\n\trtattr_add_str(nh, IFLA_INFO_KIND, \"xfrm\");\n\tinfo_data = rtattr_begin(nh, IFLA_INFO_DATA);\n\trtattr_add(nh, IFLA_XFRM_COLLECT_METADATA, 0);\n\trtattr_end(nh, info_data);\n\trtattr_end(nh, link_info);\n\n\tnstoken = open_netns(ns);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns\"))\n\t\tgoto done;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);\n\tif (!ASSERT_GE(sock, 0, \"netlink socket\"))\n\t\tgoto done;\n\tret = send(sock, nh, nh->nlmsg_len, 0);\n\tif (!ASSERT_EQ(ret, nh->nlmsg_len, \"netlink send length\"))\n\t\tgoto done;\n\n\tret = 0;\ndone:\n\tif (sock != -1)\n\t\tclose(sock);\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\treturn ret;\n}\n\nstatic int config_overlay(void)\n{\n\tif (setup_xfrm_tunnel(NS0, NS1, IP4_ADDR_VETH01, IP4_ADDR_VETH10,\n\t\t\t      IF_ID_0_TO_1, IF_ID_1))\n\t\tgoto fail;\n\tif (setup_xfrm_tunnel(NS0, NS2, IP4_ADDR_VETH02, IP4_ADDR_VETH20,\n\t\t\t      IF_ID_0_TO_2, IF_ID_2))\n\t\tgoto fail;\n\n\t \n\tif (!ASSERT_OK(setup_xfrmi_external_dev(NS0), \"xfrmi\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip -net \" NS0 \" addr add 192.168.1.100/24 dev ipsec0\");\n\tSYS(fail, \"ip -net \" NS0 \" link set dev ipsec0 up\");\n\n\tSYS(fail, \"ip -net \" NS1 \" link add ipsec0 type xfrm if_id %d\", IF_ID_1);\n\tSYS(fail, \"ip -net \" NS1 \" addr add 192.168.1.200/24 dev ipsec0\");\n\tSYS(fail, \"ip -net \" NS1 \" link set dev ipsec0 up\");\n\n\tSYS(fail, \"ip -net \" NS2 \" link add ipsec0 type xfrm if_id %d\", IF_ID_2);\n\tSYS(fail, \"ip -net \" NS2 \" addr add 192.168.1.200/24 dev ipsec0\");\n\tSYS(fail, \"ip -net \" NS2 \" link set dev ipsec0 up\");\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic int test_xfrm_ping(struct xfrm_info *skel, u32 if_id)\n{\n\tskel->bss->req_if_id = if_id;\n\n\tSYS(fail, \"ping -i 0.01 -c 3 -w 10 -q 192.168.1.200 > /dev/null\");\n\n\tif (!ASSERT_EQ(skel->bss->resp_if_id, if_id, \"if_id\"))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic void _test_xfrm_info(void)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .attach_point = BPF_TC_INGRESS);\n\tint get_xfrm_info_prog_fd, set_xfrm_info_prog_fd;\n\tstruct nstoken *nstoken = NULL;\n\tstruct xfrm_info *skel;\n\tint ifindex;\n\n\t \n\tskel = xfrm_info__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"xfrm_info__open_and_load\"))\n\t\tgoto done;\n\tnstoken = open_netns(NS0);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS0))\n\t\tgoto done;\n\tifindex = if_nametoindex(\"ipsec0\");\n\tif (!ASSERT_NEQ(ifindex, 0, \"ipsec0 ifindex\"))\n\t\tgoto done;\n\ttc_hook.ifindex = ifindex;\n\tset_xfrm_info_prog_fd = bpf_program__fd(skel->progs.set_xfrm_info);\n\tget_xfrm_info_prog_fd = bpf_program__fd(skel->progs.get_xfrm_info);\n\tif (!ASSERT_GE(set_xfrm_info_prog_fd, 0, \"bpf_program__fd\"))\n\t\tgoto done;\n\tif (!ASSERT_GE(get_xfrm_info_prog_fd, 0, \"bpf_program__fd\"))\n\t\tgoto done;\n\tif (attach_tc_prog(&tc_hook, get_xfrm_info_prog_fd,\n\t\t\t   set_xfrm_info_prog_fd))\n\t\tgoto done;\n\n\t \n\tif (!ASSERT_EQ(test_xfrm_ping(skel, IF_ID_0_TO_1), 0, \"ping \" NS1))\n\t\tgoto done;\n\tif (!ASSERT_EQ(test_xfrm_ping(skel, IF_ID_0_TO_2), 0, \"ping \" NS2))\n\t\tgoto done;\n\ndone:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\txfrm_info__destroy(skel);\n}\n\nvoid test_xfrm_info(void)\n{\n\tcleanup();\n\n\tif (!ASSERT_OK(config_underlay(), \"config_underlay\"))\n\t\tgoto done;\n\tif (!ASSERT_OK(config_overlay(), \"config_overlay\"))\n\t\tgoto done;\n\n\tif (test__start_subtest(\"xfrm_info\"))\n\t\t_test_xfrm_info();\n\ndone:\n\tcleanup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}