{
  "module_name": "verifier_log.c",
  "hash_id": "c98b98d9b6e12ed56f785f5aa39b5c02c5803c35a2b5f395eb4cfe5bb6221456",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/verifier_log.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <bpf/btf.h>\n\n#include \"test_log_buf.skel.h\"\n\n\nstatic bool check_prog_load(int prog_fd, bool expect_err, const char *tag)\n{\n\tif (expect_err) {\n\t\tif (!ASSERT_LT(prog_fd, 0, tag)) {\n\t\t\tclose(prog_fd);\n\t\t\treturn false;\n\t\t}\n\t} else   {\n\t\tif (!ASSERT_GT(prog_fd, 0, tag))\n\t\t\treturn false;\n\t}\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\treturn true;\n}\n\nstatic struct {\n\t \n\tchar filler[1024];\n\tchar buf[1024];\n\t \n\tchar reference[1024];\n} logs;\nstatic const struct bpf_insn *insns;\nstatic size_t insn_cnt;\n\nstatic int load_prog(struct bpf_prog_load_opts *opts, bool expect_load_error)\n{\n\tint prog_fd;\n\n\tprog_fd = bpf_prog_load(BPF_PROG_TYPE_RAW_TRACEPOINT, \"log_prog\",\n\t\t\t\t\"GPL\", insns, insn_cnt, opts);\n\tcheck_prog_load(prog_fd, expect_load_error, \"prog_load\");\n\n\treturn prog_fd;\n}\n\nstatic void verif_log_subtest(const char *name, bool expect_load_error, int log_level)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts);\n\tchar *exp_log, prog_name[16], op_name[32];\n\tstruct test_log_buf *skel;\n\tstruct bpf_program *prog;\n\tsize_t fixed_log_sz;\n\t__u32 log_true_sz_fixed, log_true_sz_rolling;\n\tint i, mode, err, prog_fd, res;\n\n\tskel = test_log_buf__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_object__for_each_program(prog, skel->obj) {\n\t\tif (strcmp(bpf_program__name(prog), name) == 0)\n\t\t\tbpf_program__set_autoload(prog, true);\n\t\telse\n\t\t\tbpf_program__set_autoload(prog, false);\n\t}\n\n\terr = test_log_buf__load(skel);\n\tif (!expect_load_error && !ASSERT_OK(err, \"unexpected_load_failure\"))\n\t\tgoto cleanup;\n\tif (expect_load_error && !ASSERT_ERR(err, \"unexpected_load_success\"))\n\t\tgoto cleanup;\n\n\tinsns = bpf_program__insns(skel->progs.good_prog);\n\tinsn_cnt = bpf_program__insn_cnt(skel->progs.good_prog);\n\n\topts.log_buf = logs.reference;\n\topts.log_size = sizeof(logs.reference);\n\topts.log_level = log_level | 8  ;\n\tload_prog(&opts, expect_load_error);\n\n\tfixed_log_sz = strlen(logs.reference) + 1;\n\tif (!ASSERT_GT(fixed_log_sz, 50, \"fixed_log_sz\"))\n\t\tgoto cleanup;\n\tmemset(logs.reference + fixed_log_sz, 0, sizeof(logs.reference) - fixed_log_sz);\n\n\t \n\tif (log_level >= 2 || expect_load_error) {\n\t\topts.log_buf = logs.buf;\n\t\topts.log_level = log_level | 8;  \n\t\topts.log_size = 25;\n\n\t\tprog_fd = bpf_prog_load(BPF_PROG_TYPE_RAW_TRACEPOINT, \"log_fixed25\",\n\t\t\t\t\t\"GPL\", insns, insn_cnt, &opts);\n\t\tif (!ASSERT_EQ(prog_fd, -ENOSPC, \"unexpected_log_fixed_prog_load_result\")) {\n\t\t\tif (prog_fd >= 0)\n\t\t\t\tclose(prog_fd);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!ASSERT_EQ(strlen(logs.buf), 24, \"log_fixed_25\"))\n\t\t\tgoto cleanup;\n\t\tif (!ASSERT_STRNEQ(logs.buf, logs.reference, 24, \"log_fixed_contents_25\"))\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\topts.log_buf = logs.buf;\n\n\t \n\tfor (mode = 1; mode >= 0; mode--) {\n\t\t \n\t\tmemset(logs.filler, 'A', sizeof(logs.filler));\n\t\tlogs.filler[sizeof(logs.filler) - 1] = '\\0';\n\t\tmemset(logs.buf, 'A', sizeof(logs.buf));\n\t\tlogs.buf[sizeof(logs.buf) - 1] = '\\0';\n\n\t\tfor (i = 1; i < fixed_log_sz; i++) {\n\t\t\topts.log_size = i;\n\t\t\topts.log_level = log_level | (mode ? 0 : 8  );\n\n\t\t\tsnprintf(prog_name, sizeof(prog_name),\n\t\t\t\t \"log_%s_%d\", mode ? \"roll\" : \"fixed\", i);\n\t\t\tprog_fd = bpf_prog_load(BPF_PROG_TYPE_RAW_TRACEPOINT, prog_name,\n\t\t\t\t\t\t\"GPL\", insns, insn_cnt, &opts);\n\n\t\t\tsnprintf(op_name, sizeof(op_name),\n\t\t\t\t \"log_%s_prog_load_%d\", mode ? \"roll\" : \"fixed\", i);\n\t\t\tif (!ASSERT_EQ(prog_fd, -ENOSPC, op_name)) {\n\t\t\t\tif (prog_fd >= 0)\n\t\t\t\t\tclose(prog_fd);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tsnprintf(op_name, sizeof(op_name),\n\t\t\t\t \"log_%s_strlen_%d\", mode ? \"roll\" : \"fixed\", i);\n\t\t\tASSERT_EQ(strlen(logs.buf), i - 1, op_name);\n\n\t\t\tif (mode)\n\t\t\t\texp_log = logs.reference + fixed_log_sz - i;\n\t\t\telse\n\t\t\t\texp_log = logs.reference;\n\n\t\t\tsnprintf(op_name, sizeof(op_name),\n\t\t\t\t \"log_%s_contents_%d\", mode ? \"roll\" : \"fixed\", i);\n\t\t\tif (!ASSERT_STRNEQ(logs.buf, exp_log, i - 1, op_name)) {\n\t\t\t\tprintf(\"CMP:%d\\nS1:'%s'\\nS2:'%s'\\n\",\n\t\t\t\t\tstrncmp(logs.buf, exp_log, i - 1),\n\t\t\t\t\tlogs.buf, exp_log);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t \n\t\t\tsnprintf(op_name, sizeof(op_name),\n\t\t\t\t \"log_%s_unused_%d\", mode ? \"roll\" : \"fixed\", i);\n\t\t\tif (!ASSERT_STREQ(logs.buf + i, logs.filler + i, op_name)) {\n\t\t\t\tprintf(\"CMP:%d\\nS1:'%s'\\nS2:'%s'\\n\",\n\t\t\t\t\tstrcmp(logs.buf + i, logs.filler + i),\n\t\t\t\t\tlogs.buf + i, logs.filler + i);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level | 8;  \n\topts.log_size = sizeof(logs.buf);\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_fixed\");\n\n\tlog_true_sz_fixed = opts.log_true_size;\n\tASSERT_GT(log_true_sz_fixed, 0, \"log_true_sz_fixed\");\n\n\t \n\topts.log_buf = NULL;\n\topts.log_level = log_level | 8;  \n\topts.log_size = 0;\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_fixed_null\");\n\tASSERT_EQ(opts.log_true_size, log_true_sz_fixed, \"log_sz_fixed_null_eq\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level;\n\topts.log_size = sizeof(logs.buf);\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_rolling\");\n\n\tlog_true_sz_rolling = opts.log_true_size;\n\tASSERT_EQ(log_true_sz_rolling, log_true_sz_fixed, \"log_true_sz_eq\");\n\n\t \n\topts.log_buf = NULL;\n\topts.log_level = log_level;\n\topts.log_size = 0;\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_rolling_null\");\n\tASSERT_EQ(opts.log_true_size, log_true_sz_rolling, \"log_true_sz_null_eq\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level | 8;  \n\topts.log_size = log_true_sz_fixed - 1;\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, true  );\n\tASSERT_EQ(res, -ENOSPC, \"prog_load_res_too_short_fixed\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level | 8;  \n\topts.log_size = log_true_sz_fixed;\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_just_right_fixed\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level;\n\topts.log_size = log_true_sz_rolling - 1;\n\tres = load_prog(&opts, true  );\n\tASSERT_EQ(res, -ENOSPC, \"prog_load_res_too_short_rolling\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = log_level;\n\topts.log_size = log_true_sz_rolling;\n\topts.log_true_size = 0;\n\tres = load_prog(&opts, expect_load_error);\n\tASSERT_NEQ(res, -ENOSPC, \"prog_load_res_just_right_rolling\");\n\ncleanup:\n\ttest_log_buf__destroy(skel);\n}\n\nstatic const void *btf_data;\nstatic u32 btf_data_sz;\n\nstatic int load_btf(struct bpf_btf_load_opts *opts, bool expect_err)\n{\n\tint fd;\n\n\tfd = bpf_btf_load(btf_data, btf_data_sz, opts);\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (expect_err)\n\t\tASSERT_LT(fd, 0, \"btf_load_failure\");\n\telse  \n\t\tASSERT_GT(fd, 0, \"btf_load_success\");\n\treturn fd;\n}\n\nstatic void verif_btf_log_subtest(bool bad_btf)\n{\n\tLIBBPF_OPTS(bpf_btf_load_opts, opts);\n\tstruct btf *btf;\n\tstruct btf_type *t;\n\tchar *exp_log, op_name[32];\n\tsize_t fixed_log_sz;\n\t__u32 log_true_sz_fixed, log_true_sz_rolling;\n\tint i, res;\n\n\t \n\tbtf = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf, \"btf_new_empty\"))\n\t\treturn;\n\tres = btf__add_int(btf, \"whatever\", 4, 0);\n\tif (!ASSERT_GT(res, 0, \"btf_add_int_id\"))\n\t\tgoto cleanup;\n\tif (bad_btf) {\n\t\t \n\t\tt = (void *)btf__type_by_id(btf, res);\n\t\tif (!ASSERT_OK_PTR(t, \"int_btf_type\"))\n\t\t\tgoto cleanup;\n\t\tt->size = 3;\n\t}\n\n\tbtf_data = btf__raw_data(btf, &btf_data_sz);\n\tif (!ASSERT_OK_PTR(btf_data, \"btf_data\"))\n\t\tgoto cleanup;\n\n\tload_btf(&opts, bad_btf);\n\n\topts.log_buf = logs.reference;\n\topts.log_size = sizeof(logs.reference);\n\topts.log_level = 1 | 8  ;\n\tload_btf(&opts, bad_btf);\n\n\tfixed_log_sz = strlen(logs.reference) + 1;\n\tif (!ASSERT_GT(fixed_log_sz, 50, \"fixed_log_sz\"))\n\t\tgoto cleanup;\n\tmemset(logs.reference + fixed_log_sz, 0, sizeof(logs.reference) - fixed_log_sz);\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1 | 8;  \n\topts.log_size = 25;\n\tres = load_btf(&opts, true);\n\tASSERT_EQ(res, -ENOSPC, \"half_log_fd\");\n\tASSERT_EQ(strlen(logs.buf), 24, \"log_fixed_25\");\n\tASSERT_STRNEQ(logs.buf, logs.reference, 24, op_name);\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1;  \n\n\t \n\tmemset(logs.filler, 'A', sizeof(logs.filler));\n\tlogs.filler[sizeof(logs.filler) - 1] = '\\0';\n\tmemset(logs.buf, 'A', sizeof(logs.buf));\n\tlogs.buf[sizeof(logs.buf) - 1] = '\\0';\n\n\tfor (i = 1; i < fixed_log_sz; i++) {\n\t\topts.log_size = i;\n\n\t\tsnprintf(op_name, sizeof(op_name), \"log_roll_btf_load_%d\", i);\n\t\tres = load_btf(&opts, true);\n\t\tif (!ASSERT_EQ(res, -ENOSPC, op_name))\n\t\t\tgoto cleanup;\n\n\t\texp_log = logs.reference + fixed_log_sz - i;\n\t\tsnprintf(op_name, sizeof(op_name), \"log_roll_contents_%d\", i);\n\t\tif (!ASSERT_STREQ(logs.buf, exp_log, op_name)) {\n\t\t\tprintf(\"CMP:%d\\nS1:'%s'\\nS2:'%s'\\n\",\n\t\t\t\tstrcmp(logs.buf, exp_log),\n\t\t\t\tlogs.buf, exp_log);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tsnprintf(op_name, sizeof(op_name), \"log_roll_unused_tail_%d\", i);\n\t\tif (!ASSERT_STREQ(logs.buf + i, logs.filler + i, op_name)) {\n\t\t\tprintf(\"CMP:%d\\nS1:'%s'\\nS2:'%s'\\n\",\n\t\t\t\tstrcmp(logs.buf + i, logs.filler + i),\n\t\t\t\tlogs.buf + i, logs.filler + i);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1 | 8;  \n\topts.log_size = sizeof(logs.buf);\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_fixed\");\n\n\tlog_true_sz_fixed = opts.log_true_size;\n\tASSERT_GT(log_true_sz_fixed, 0, \"log_true_sz_fixed\");\n\n\t \n\topts.log_buf = NULL;\n\topts.log_level = 1 | 8;  \n\topts.log_size = 0;\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_fixed_null\");\n\tASSERT_EQ(opts.log_true_size, log_true_sz_fixed, \"log_sz_fixed_null_eq\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1;\n\topts.log_size = sizeof(logs.buf);\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_rolling\");\n\n\tlog_true_sz_rolling = opts.log_true_size;\n\tASSERT_EQ(log_true_sz_rolling, log_true_sz_fixed, \"log_true_sz_eq\");\n\n\t \n\topts.log_buf = NULL;\n\topts.log_level = 1;\n\topts.log_size = 0;\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_rolling_null\");\n\tASSERT_EQ(opts.log_true_size, log_true_sz_rolling, \"log_true_sz_null_eq\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1 | 8;  \n\topts.log_size = log_true_sz_fixed - 1;\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, true);\n\tASSERT_EQ(res, -ENOSPC, \"btf_load_res_too_short_fixed\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1 | 8;  \n\topts.log_size = log_true_sz_fixed;\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_just_right_fixed\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1;\n\topts.log_size = log_true_sz_rolling - 1;\n\tres = load_btf(&opts, true);\n\tASSERT_EQ(res, -ENOSPC, \"btf_load_res_too_short_rolling\");\n\n\t \n\topts.log_buf = logs.buf;\n\topts.log_level = 1;\n\topts.log_size = log_true_sz_rolling;\n\topts.log_true_size = 0;\n\tres = load_btf(&opts, bad_btf);\n\tASSERT_NEQ(res, -ENOSPC, \"btf_load_res_just_right_rolling\");\n\ncleanup:\n\tbtf__free(btf);\n}\n\nvoid test_verifier_log(void)\n{\n\tif (test__start_subtest(\"good_prog-level1\"))\n\t\tverif_log_subtest(\"good_prog\", false, 1);\n\tif (test__start_subtest(\"good_prog-level2\"))\n\t\tverif_log_subtest(\"good_prog\", false, 2);\n\tif (test__start_subtest(\"bad_prog-level1\"))\n\t\tverif_log_subtest(\"bad_prog\", true, 1);\n\tif (test__start_subtest(\"bad_prog-level2\"))\n\t\tverif_log_subtest(\"bad_prog\", true, 2);\n\tif (test__start_subtest(\"bad_btf\"))\n\t\tverif_btf_log_subtest(true  );\n\tif (test__start_subtest(\"good_btf\"))\n\t\tverif_btf_log_subtest(false  );\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}