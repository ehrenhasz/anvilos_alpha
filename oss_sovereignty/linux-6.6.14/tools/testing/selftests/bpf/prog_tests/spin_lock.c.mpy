{
  "module_name": "spin_lock.c",
  "hash_id": "55d0ff28511611e00c9883bc7ecbbaf10a5b9edfbe90dd053fbf8128333c175f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/spin_lock.c",
  "human_readable_source": "\n#include <regex.h>\n#include <test_progs.h>\n#include <network_helpers.h>\n\n#include \"test_spin_lock.skel.h\"\n#include \"test_spin_lock_fail.skel.h\"\n\nstatic char log_buf[1024 * 1024];\n\nstatic struct {\n\tconst char *prog_name;\n\tconst char *err_msg;\n} spin_lock_fail_tests[] = {\n\t{ \"lock_id_kptr_preserve\",\n\t  \"5: (bf) r1 = r0                       ; R0_w=ptr_foo(id=2,ref_obj_id=2,off=0,imm=0) \"\n\t  \"R1_w=ptr_foo(id=2,ref_obj_id=2,off=0,imm=0) refs=2\\n6: (85) call bpf_this_cpu_ptr#154\\n\"\n\t  \"R1 type=ptr_ expected=percpu_ptr_\" },\n\t{ \"lock_id_global_zero\",\n\t  \"; R1_w=map_value(off=0,ks=4,vs=4,imm=0)\\n2: (85) call bpf_this_cpu_ptr#154\\n\"\n\t  \"R1 type=map_value expected=percpu_ptr_\" },\n\t{ \"lock_id_mapval_preserve\",\n\t  \"[0-9]\\\\+: (bf) r1 = r0                       ;\"\n\t  \" R0_w=map_value(id=1,off=0,ks=4,vs=8,imm=0)\"\n\t  \" R1_w=map_value(id=1,off=0,ks=4,vs=8,imm=0)\\n\"\n\t  \"[0-9]\\\\+: (85) call bpf_this_cpu_ptr#154\\n\"\n\t  \"R1 type=map_value expected=percpu_ptr_\" },\n\t{ \"lock_id_innermapval_preserve\",\n\t  \"[0-9]\\\\+: (bf) r1 = r0                      ;\"\n\t  \" R0=map_value(id=2,off=0,ks=4,vs=8,imm=0)\"\n\t  \" R1_w=map_value(id=2,off=0,ks=4,vs=8,imm=0)\\n\"\n\t  \"[0-9]\\\\+: (85) call bpf_this_cpu_ptr#154\\n\"\n\t  \"R1 type=map_value expected=percpu_ptr_\" },\n\t{ \"lock_id_mismatch_kptr_kptr\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_kptr_global\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_kptr_mapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_kptr_innermapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_global_global\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_global_kptr\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_global_mapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_global_innermapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_mapval_mapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_mapval_kptr\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_mapval_global\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_mapval_innermapval\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_innermapval_innermapval1\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_innermapval_innermapval2\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_innermapval_kptr\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_innermapval_global\", \"bpf_spin_unlock of different lock\" },\n\t{ \"lock_id_mismatch_innermapval_mapval\", \"bpf_spin_unlock of different lock\" },\n};\n\nstatic int match_regex(const char *pattern, const char *string)\n{\n\tint err, rc;\n\tregex_t re;\n\n\terr = regcomp(&re, pattern, REG_NOSUB);\n\tif (err) {\n\t\tchar errbuf[512];\n\n\t\tregerror(err, &re, errbuf, sizeof(errbuf));\n\t\tPRINT_FAIL(\"Can't compile regex: %s\\n\", errbuf);\n\t\treturn -1;\n\t}\n\trc = regexec(&re, string, 0, NULL, 0);\n\tregfree(&re);\n\treturn rc == 0 ? 1 : 0;\n}\n\nstatic void test_spin_lock_fail_prog(const char *prog_name, const char *err_msg)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, opts, .kernel_log_buf = log_buf,\n\t\t\t\t\t\t.kernel_log_size = sizeof(log_buf),\n\t\t\t\t\t\t.kernel_log_level = 1);\n\tstruct test_spin_lock_fail *skel;\n\tstruct bpf_program *prog;\n\tint ret;\n\n\tskel = test_spin_lock_fail__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"test_spin_lock_fail__open_opts\"))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto end;\n\n\tbpf_program__set_autoload(prog, true);\n\n\tret = test_spin_lock_fail__load(skel);\n\tif (!ASSERT_ERR(ret, \"test_spin_lock_fail__load must fail\"))\n\t\tgoto end;\n\n\t \n\tif (strstr(log_buf, \"JIT does not support calling kernel function\")) {\n\t\ttest__skip();\n\t\tgoto end;\n\t}\n\n\tret = match_regex(err_msg, log_buf);\n\tif (!ASSERT_GE(ret, 0, \"match_regex\"))\n\t\tgoto end;\n\n\tif (!ASSERT_TRUE(ret, \"no match for expected error message\")) {\n\t\tfprintf(stderr, \"Expected: %s\\n\", err_msg);\n\t\tfprintf(stderr, \"Verifier: %s\\n\", log_buf);\n\t}\n\nend:\n\ttest_spin_lock_fail__destroy(skel);\n}\n\nstatic void *spin_lock_thread(void *arg)\n{\n\tint err, prog_fd = *(u32 *) arg;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 10000,\n\t);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_OK(topts.retval, \"test_run retval\");\n\tpthread_exit(arg);\n}\n\nvoid test_spin_lock_success(void)\n{\n\tstruct test_spin_lock *skel;\n\tpthread_t thread_id[4];\n\tint prog_fd, i;\n\tvoid *ret;\n\n\tskel = test_spin_lock__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_spin_lock__open_and_load\"))\n\t\treturn;\n\tprog_fd = bpf_program__fd(skel->progs.bpf_spin_lock_test);\n\tfor (i = 0; i < 4; i++) {\n\t\tint err;\n\n\t\terr = pthread_create(&thread_id[i], NULL, &spin_lock_thread, &prog_fd);\n\t\tif (!ASSERT_OK(err, \"pthread_create\"))\n\t\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!ASSERT_OK(pthread_join(thread_id[i], &ret), \"pthread_join\"))\n\t\t\tgoto end;\n\t\tif (!ASSERT_EQ(ret, &prog_fd, \"ret == prog_fd\"))\n\t\t\tgoto end;\n\t}\nend:\n\ttest_spin_lock__destroy(skel);\n}\n\nvoid test_spin_lock(void)\n{\n\tint i;\n\n\ttest_spin_lock_success();\n\n\tfor (i = 0; i < ARRAY_SIZE(spin_lock_fail_tests); i++) {\n\t\tif (!test__start_subtest(spin_lock_fail_tests[i].prog_name))\n\t\t\tcontinue;\n\t\ttest_spin_lock_fail_prog(spin_lock_fail_tests[i].prog_name,\n\t\t\t\t\t spin_lock_fail_tests[i].err_msg);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}