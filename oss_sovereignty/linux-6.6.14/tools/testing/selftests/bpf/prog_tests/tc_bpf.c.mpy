{
  "module_name": "tc_bpf.c",
  "hash_id": "78a795b327a8dd04a6685d78188bf8671623dde47744ea928f108fcfa123b5bb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tc_bpf.c",
  "human_readable_source": "\n\n#include <test_progs.h>\n#include <linux/pkt_cls.h>\n\n#include \"cap_helpers.h\"\n#include \"test_tc_bpf.skel.h\"\n\n#define LO_IFINDEX 1\n\n#define TEST_DECLARE_OPTS(__fd)                                                                   \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_h, .handle = 1);                                     \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_p, .priority = 1);                                   \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_f, .prog_fd = __fd);                                 \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hp, .handle = 1, .priority = 1);                     \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hf, .handle = 1, .prog_fd = __fd);                   \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_pf, .priority = 1, .prog_fd = __fd);                 \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hpf, .handle = 1, .priority = 1, .prog_fd = __fd);   \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hpi, .handle = 1, .priority = 1, .prog_id = 42);     \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hpr, .handle = 1, .priority = 1,                     \\\n\t\t\t    .flags = BPF_TC_F_REPLACE);                                            \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_hpfi, .handle = 1, .priority = 1, .prog_fd = __fd,   \\\n\t\t\t    .prog_id = 42);                                                        \\\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts_prio_max, .handle = 1, .priority = UINT16_MAX + 1);\n\nstatic int test_tc_bpf_basic(const struct bpf_tc_hook *hook, int fd)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts, .handle = 1, .priority = 1, .prog_fd = fd);\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint ret;\n\n\tret = bpf_prog_get_info_by_fd(fd, &info, &info_len);\n\tif (!ASSERT_OK(ret, \"bpf_prog_get_info_by_fd\"))\n\t\treturn ret;\n\n\tret = bpf_tc_attach(hook, &opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_attach\"))\n\t\treturn ret;\n\n\tif (!ASSERT_EQ(opts.handle, 1, \"handle set\") ||\n\t    !ASSERT_EQ(opts.priority, 1, \"priority set\") ||\n\t    !ASSERT_EQ(opts.prog_id, info.id, \"prog_id set\"))\n\t\tgoto end;\n\n\topts.prog_id = 0;\n\topts.flags = BPF_TC_F_REPLACE;\n\tret = bpf_tc_attach(hook, &opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_attach replace mode\"))\n\t\tgoto end;\n\n\topts.flags = opts.prog_fd = opts.prog_id = 0;\n\tret = bpf_tc_query(hook, &opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_query\"))\n\t\tgoto end;\n\n\tif (!ASSERT_EQ(opts.handle, 1, \"handle set\") ||\n\t    !ASSERT_EQ(opts.priority, 1, \"priority set\") ||\n\t    !ASSERT_EQ(opts.prog_id, info.id, \"prog_id set\"))\n\t\tgoto end;\n\nend:\n\topts.flags = opts.prog_fd = opts.prog_id = 0;\n\tret = bpf_tc_detach(hook, &opts);\n\tASSERT_OK(ret, \"bpf_tc_detach\");\n\treturn ret;\n}\n\nstatic int test_tc_bpf_api(struct bpf_tc_hook *hook, int fd)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, attach_opts, .handle = 1, .priority = 1, .prog_fd = fd);\n\tDECLARE_LIBBPF_OPTS(bpf_tc_hook, inv_hook, .attach_point = BPF_TC_INGRESS);\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts, .handle = 1, .priority = 1);\n\tint ret;\n\n\tret = bpf_tc_hook_create(NULL);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_create invalid hook = NULL\"))\n\t\treturn -EINVAL;\n\n\t \n\tret = bpf_tc_hook_create(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_create invalid hook ifindex == 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_hook_destroy(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_destroy invalid hook ifindex == 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_attach(&inv_hook, &attach_opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook ifindex == 0\"))\n\t\treturn -EINVAL;\n\tattach_opts.prog_id = 0;\n\n\tret = bpf_tc_detach(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook ifindex == 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_query(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook ifindex == 0\"))\n\t\treturn -EINVAL;\n\n\t \n\tinv_hook.ifindex = -1;\n\n\tret = bpf_tc_hook_create(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_create invalid hook ifindex < 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_hook_destroy(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_destroy invalid hook ifindex < 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_attach(&inv_hook, &attach_opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook ifindex < 0\"))\n\t\treturn -EINVAL;\n\tattach_opts.prog_id = 0;\n\n\tret = bpf_tc_detach(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook ifindex < 0\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_query(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook ifindex < 0\"))\n\t\treturn -EINVAL;\n\n\tinv_hook.ifindex = LO_IFINDEX;\n\n\t \n\tinv_hook.attach_point = 0xabcd;\n\tret = bpf_tc_hook_create(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_create invalid hook.attach_point\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_hook_destroy(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_destroy invalid hook.attach_point\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_attach(&inv_hook, &attach_opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook.attach_point\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_detach(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook.attach_point\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_query(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook.attach_point\"))\n\t\treturn -EINVAL;\n\n\tinv_hook.attach_point = BPF_TC_INGRESS;\n\n\t \n\tinv_hook.parent = TC_H_MAKE(1UL << 16, 10);\n\tret = bpf_tc_hook_create(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_create invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_hook_destroy(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_hook_destroy invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_attach(&inv_hook, &attach_opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_detach(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_query(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tinv_hook.attach_point = BPF_TC_CUSTOM;\n\tinv_hook.parent = 0;\n\t \n\tret = bpf_tc_hook_create(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EOPNOTSUPP, \"bpf_tc_hook_create invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_hook_destroy(&inv_hook);\n\tif (!ASSERT_EQ(ret, -EOPNOTSUPP, \"bpf_tc_hook_destroy invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_attach(&inv_hook, &attach_opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_detach(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tret = bpf_tc_query(&inv_hook, &opts);\n\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook parent\"))\n\t\treturn -EINVAL;\n\n\tinv_hook.attach_point = BPF_TC_INGRESS;\n\n\t \n\t{\n\t\tTEST_DECLARE_OPTS(fd);\n\n\t\tret = bpf_tc_detach(NULL, &opts_hp);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid hook = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, NULL);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid opts = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_hpr);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid flags set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_hpf);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid prog_fd set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_hpi);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid prog_id set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_p);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid handle unset\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_h);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid priority unset\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_detach(hook, &opts_prio_max);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_detach invalid priority > UINT16_MAX\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\t{\n\t\tTEST_DECLARE_OPTS(fd);\n\n\t\tret = bpf_tc_query(NULL, &opts);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid hook = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, NULL);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid opts = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_hpr);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid flags set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_hpf);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid prog_fd set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_hpi);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid prog_id set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_p);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid handle unset\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_h);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid priority unset\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_query(hook, &opts_prio_max);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query invalid priority > UINT16_MAX\"))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = bpf_tc_query(hook, &opts_hp);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_query valid handle, priority set\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\t{\n\t\tTEST_DECLARE_OPTS(fd);\n\n\t\tret = bpf_tc_attach(NULL, &opts_hp);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid hook = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_attach(hook, NULL);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid opts = NULL\"))\n\t\t\treturn -EINVAL;\n\n\t\topts_hp.flags = 42;\n\t\tret = bpf_tc_attach(hook, &opts_hp);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid flags\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_attach(hook, NULL);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid prog_fd unset\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_attach(hook, &opts_hpi);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid prog_id set\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_attach(hook, &opts_pf);\n\t\tif (!ASSERT_OK(ret, \"bpf_tc_attach valid handle unset\"))\n\t\t\treturn -EINVAL;\n\t\topts_pf.prog_fd = opts_pf.prog_id = 0;\n\t\tASSERT_OK(bpf_tc_detach(hook, &opts_pf), \"bpf_tc_detach\");\n\n\t\tret = bpf_tc_attach(hook, &opts_hf);\n\t\tif (!ASSERT_OK(ret, \"bpf_tc_attach valid priority unset\"))\n\t\t\treturn -EINVAL;\n\t\topts_hf.prog_fd = opts_hf.prog_id = 0;\n\t\tASSERT_OK(bpf_tc_detach(hook, &opts_hf), \"bpf_tc_detach\");\n\n\t\tret = bpf_tc_attach(hook, &opts_prio_max);\n\t\tif (!ASSERT_EQ(ret, -EINVAL, \"bpf_tc_attach invalid priority > UINT16_MAX\"))\n\t\t\treturn -EINVAL;\n\n\t\tret = bpf_tc_attach(hook, &opts_f);\n\t\tif (!ASSERT_OK(ret, \"bpf_tc_attach valid both handle and priority unset\"))\n\t\t\treturn -EINVAL;\n\t\topts_f.prog_fd = opts_f.prog_id = 0;\n\t\tASSERT_OK(bpf_tc_detach(hook, &opts_f), \"bpf_tc_detach\");\n\t}\n\n\treturn 0;\n}\n\nvoid tc_bpf_root(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = LO_IFINDEX,\n\t\t\t    .attach_point = BPF_TC_INGRESS);\n\tstruct test_tc_bpf *skel = NULL;\n\tbool hook_created = false;\n\tint cls_fd, ret;\n\n\tskel = test_tc_bpf__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_bpf__open_and_load\"))\n\t\treturn;\n\n\tcls_fd = bpf_program__fd(skel->progs.cls);\n\n\tret = bpf_tc_hook_create(&hook);\n\tif (ret == 0)\n\t\thook_created = true;\n\n\tret = ret == -EEXIST ? 0 : ret;\n\tif (!ASSERT_OK(ret, \"bpf_tc_hook_create(BPF_TC_INGRESS)\"))\n\t\tgoto end;\n\n\thook.attach_point = BPF_TC_CUSTOM;\n\thook.parent = TC_H_MAKE(TC_H_CLSACT, TC_H_MIN_INGRESS);\n\tret = bpf_tc_hook_create(&hook);\n\tif (!ASSERT_EQ(ret, -EOPNOTSUPP, \"bpf_tc_hook_create invalid hook.attach_point\"))\n\t\tgoto end;\n\n\tret = test_tc_bpf_basic(&hook, cls_fd);\n\tif (!ASSERT_OK(ret, \"test_tc_internal ingress\"))\n\t\tgoto end;\n\n\tret = bpf_tc_hook_destroy(&hook);\n\tif (!ASSERT_EQ(ret, -EOPNOTSUPP, \"bpf_tc_hook_destroy invalid hook.attach_point\"))\n\t\tgoto end;\n\n\thook.attach_point = BPF_TC_INGRESS;\n\thook.parent = 0;\n\tbpf_tc_hook_destroy(&hook);\n\n\tret = test_tc_bpf_basic(&hook, cls_fd);\n\tif (!ASSERT_OK(ret, \"test_tc_internal ingress\"))\n\t\tgoto end;\n\n\tbpf_tc_hook_destroy(&hook);\n\n\thook.attach_point = BPF_TC_EGRESS;\n\tret = test_tc_bpf_basic(&hook, cls_fd);\n\tif (!ASSERT_OK(ret, \"test_tc_internal egress\"))\n\t\tgoto end;\n\n\tbpf_tc_hook_destroy(&hook);\n\n\tret = test_tc_bpf_api(&hook, cls_fd);\n\tif (!ASSERT_OK(ret, \"test_tc_bpf_api\"))\n\t\tgoto end;\n\n\tbpf_tc_hook_destroy(&hook);\n\nend:\n\tif (hook_created) {\n\t\thook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\t\tbpf_tc_hook_destroy(&hook);\n\t}\n\ttest_tc_bpf__destroy(skel);\n}\n\nvoid tc_bpf_non_root(void)\n{\n\tstruct test_tc_bpf *skel = NULL;\n\t__u64 caps = 0;\n\tint ret;\n\n\t \n\tret = cap_enable_effective(1ULL << CAP_BPF | 1ULL << CAP_NET_ADMIN, &caps);\n\tif (!ASSERT_OK(ret, \"set_cap_bpf_cap_net_admin\"))\n\t\treturn;\n\tret = cap_disable_effective(1ULL << CAP_SYS_ADMIN | 1ULL << CAP_PERFMON, NULL);\n\tif (!ASSERT_OK(ret, \"disable_cap_sys_admin\"))\n\t\tgoto restore_cap;\n\n\tskel = test_tc_bpf__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_bpf__open_and_load\"))\n\t\tgoto restore_cap;\n\n\ttest_tc_bpf__destroy(skel);\n\nrestore_cap:\n\tif (caps)\n\t\tcap_enable_effective(caps, NULL);\n}\n\nvoid test_tc_bpf(void)\n{\n\tif (test__start_subtest(\"tc_bpf_root\"))\n\t\ttc_bpf_root();\n\tif (test__start_subtest(\"tc_bpf_non_root\"))\n\t\ttc_bpf_non_root();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}