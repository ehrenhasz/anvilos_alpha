{
  "module_name": "cgrp_local_storage.c",
  "hash_id": "59877935318bc4ced18300bb9a6b47087076e0b247ac89a6bf4a7a8b4212d9be",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cgrp_local_storage.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <test_progs.h>\n#include \"cgrp_ls_tp_btf.skel.h\"\n#include \"cgrp_ls_recursion.skel.h\"\n#include \"cgrp_ls_attach_cgroup.skel.h\"\n#include \"cgrp_ls_negative.skel.h\"\n#include \"cgrp_ls_sleepable.skel.h\"\n#include \"network_helpers.h\"\n#include \"cgroup_helpers.h\"\n\nstruct socket_cookie {\n\t__u64 cookie_key;\n\t__u64 cookie_value;\n};\n\nstatic void test_tp_btf(int cgroup_fd)\n{\n\tstruct cgrp_ls_tp_btf *skel;\n\tlong val1 = 1, val2 = 0;\n\tint err;\n\n\tskel = cgrp_ls_tp_btf__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\treturn;\n\n\t \n\terr = bpf_map_update_elem(bpf_map__fd(skel->maps.map_b), &cgroup_fd, &val1, BPF_ANY);\n\tif (!ASSERT_OK(err, \"map_update_elem\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_map_lookup_elem(bpf_map__fd(skel->maps.map_b), &cgroup_fd, &val2);\n\tif (!ASSERT_OK(err, \"map_lookup_elem\"))\n\t\tgoto out;\n\tif (!ASSERT_EQ(val2, 1, \"map_lookup_elem, invalid val\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_map_delete_elem(bpf_map__fd(skel->maps.map_b), &cgroup_fd);\n\tif (!ASSERT_OK(err, \"map_delete_elem\"))\n\t\tgoto out;\n\n\tskel->bss->target_pid = syscall(SYS_gettid);\n\n\terr = cgrp_ls_tp_btf__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\tsyscall(SYS_gettid);\n\tsyscall(SYS_gettid);\n\n\tskel->bss->target_pid = 0;\n\n\t \n\tASSERT_EQ(skel->bss->enter_cnt, 3, \"enter_cnt\");\n\tASSERT_EQ(skel->bss->exit_cnt, 3, \"exit_cnt\");\n\tASSERT_EQ(skel->bss->mismatch_cnt, 0, \"mismatch_cnt\");\nout:\n\tcgrp_ls_tp_btf__destroy(skel);\n}\n\nstatic void test_attach_cgroup(int cgroup_fd)\n{\n\tint server_fd = 0, client_fd = 0, err = 0;\n\tsocklen_t addr_len = sizeof(struct sockaddr_in6);\n\tstruct cgrp_ls_attach_cgroup *skel;\n\t__u32 cookie_expected_value;\n\tstruct sockaddr_in6 addr;\n\tstruct socket_cookie val;\n\n\tskel = cgrp_ls_attach_cgroup__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tskel->links.set_cookie = bpf_program__attach_cgroup(\n\t\tskel->progs.set_cookie, cgroup_fd);\n\tif (!ASSERT_OK_PTR(skel->links.set_cookie, \"prog_attach\"))\n\t\tgoto out;\n\n\tskel->links.update_cookie_sockops = bpf_program__attach_cgroup(\n\t\tskel->progs.update_cookie_sockops, cgroup_fd);\n\tif (!ASSERT_OK_PTR(skel->links.update_cookie_sockops, \"prog_attach\"))\n\t\tgoto out;\n\n\tskel->links.update_cookie_tracing = bpf_program__attach(\n\t\tskel->progs.update_cookie_tracing);\n\tif (!ASSERT_OK_PTR(skel->links.update_cookie_tracing, \"prog_attach\"))\n\t\tgoto out;\n\n\tserver_fd = start_server(AF_INET6, SOCK_STREAM, \"::1\", 0, 0);\n\tif (!ASSERT_GE(server_fd, 0, \"start_server\"))\n\t\tgoto out;\n\n\tclient_fd = connect_to_fd(server_fd, 0);\n\tif (!ASSERT_GE(client_fd, 0, \"connect_to_fd\"))\n\t\tgoto close_server_fd;\n\n\terr = bpf_map_lookup_elem(bpf_map__fd(skel->maps.socket_cookies),\n\t\t\t\t  &cgroup_fd, &val);\n\tif (!ASSERT_OK(err, \"map_lookup(socket_cookies)\"))\n\t\tgoto close_client_fd;\n\n\terr = getsockname(client_fd, (struct sockaddr *)&addr, &addr_len);\n\tif (!ASSERT_OK(err, \"getsockname\"))\n\t\tgoto close_client_fd;\n\n\tcookie_expected_value = (ntohs(addr.sin6_port) << 8) | 0xFF;\n\tASSERT_EQ(val.cookie_value, cookie_expected_value, \"cookie_value\");\n\nclose_client_fd:\n\tclose(client_fd);\nclose_server_fd:\n\tclose(server_fd);\nout:\n\tcgrp_ls_attach_cgroup__destroy(skel);\n}\n\nstatic void test_recursion(int cgroup_fd)\n{\n\tstruct cgrp_ls_recursion *skel;\n\tint err;\n\n\tskel = cgrp_ls_recursion__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\treturn;\n\n\terr = cgrp_ls_recursion__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\t \n\tsyscall(SYS_gettid);\n\nout:\n\tcgrp_ls_recursion__destroy(skel);\n}\n\nstatic void test_negative(void)\n{\n\tstruct cgrp_ls_negative *skel;\n\n\tskel = cgrp_ls_negative__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"skel_open_and_load\")) {\n\t\tcgrp_ls_negative__destroy(skel);\n\t\treturn;\n\t}\n}\n\nstatic void test_cgroup_iter_sleepable(int cgroup_fd, __u64 cgroup_id)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct cgrp_ls_sleepable *skel;\n\tstruct bpf_link *link;\n\tint err, iter_fd;\n\tchar buf[16];\n\n\tskel = cgrp_ls_sleepable__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_program__set_autoload(skel->progs.cgroup_iter, true);\n\terr = cgrp_ls_sleepable__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto out;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.cgroup.cgroup_fd = cgroup_fd;\n\tlinfo.cgroup.order = BPF_CGROUP_ITER_SELF_ONLY;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.cgroup_iter, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"iter_create\"))\n\t\tgoto out;\n\n\t \n\t(void)read(iter_fd, buf, sizeof(buf));\n\n\tASSERT_EQ(skel->bss->cgroup_id, cgroup_id, \"cgroup_id\");\n\n\tclose(iter_fd);\nout:\n\tcgrp_ls_sleepable__destroy(skel);\n}\n\nstatic void test_yes_rcu_lock(__u64 cgroup_id)\n{\n\tstruct cgrp_ls_sleepable *skel;\n\tint err;\n\n\tskel = cgrp_ls_sleepable__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tskel->bss->target_pid = syscall(SYS_gettid);\n\n\tbpf_program__set_autoload(skel->progs.yes_rcu_lock, true);\n\terr = cgrp_ls_sleepable__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto out;\n\n\terr = cgrp_ls_sleepable__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\tsyscall(SYS_getpgid);\n\n\tASSERT_EQ(skel->bss->cgroup_id, cgroup_id, \"cgroup_id\");\nout:\n\tcgrp_ls_sleepable__destroy(skel);\n}\n\nstatic void test_no_rcu_lock(void)\n{\n\tstruct cgrp_ls_sleepable *skel;\n\tint err;\n\n\tskel = cgrp_ls_sleepable__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_program__set_autoload(skel->progs.no_rcu_lock, true);\n\terr = cgrp_ls_sleepable__load(skel);\n\tASSERT_ERR(err, \"skel_load\");\n\n\tcgrp_ls_sleepable__destroy(skel);\n}\n\nvoid test_cgrp_local_storage(void)\n{\n\t__u64 cgroup_id;\n\tint cgroup_fd;\n\n\tcgroup_fd = test__join_cgroup(\"/cgrp_local_storage\");\n\tif (!ASSERT_GE(cgroup_fd, 0, \"join_cgroup /cgrp_local_storage\"))\n\t\treturn;\n\n\tcgroup_id = get_cgroup_id(\"/cgrp_local_storage\");\n\tif (test__start_subtest(\"tp_btf\"))\n\t\ttest_tp_btf(cgroup_fd);\n\tif (test__start_subtest(\"attach_cgroup\"))\n\t\ttest_attach_cgroup(cgroup_fd);\n\tif (test__start_subtest(\"recursion\"))\n\t\ttest_recursion(cgroup_fd);\n\tif (test__start_subtest(\"negative\"))\n\t\ttest_negative();\n\tif (test__start_subtest(\"cgroup_iter_sleepable\"))\n\t\ttest_cgroup_iter_sleepable(cgroup_fd, cgroup_id);\n\tif (test__start_subtest(\"yes_rcu_lock\"))\n\t\ttest_yes_rcu_lock(cgroup_id);\n\tif (test__start_subtest(\"no_rcu_lock\"))\n\t\ttest_no_rcu_lock();\n\n\tclose(cgroup_fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}