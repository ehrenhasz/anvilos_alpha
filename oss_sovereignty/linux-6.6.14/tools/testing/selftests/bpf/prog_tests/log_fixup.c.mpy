{
  "module_name": "log_fixup.c",
  "hash_id": "fe02ef4f68b44125f3e4f87c5694281b8a01415fa4a4e71fd400242e454a6cba",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/log_fixup.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <bpf/btf.h>\n\n#include \"test_log_fixup.skel.h\"\n\nenum trunc_type {\n\tTRUNC_NONE,\n\tTRUNC_PARTIAL,\n\tTRUNC_FULL,\n};\n\nstatic void bad_core_relo(size_t log_buf_size, enum trunc_type trunc_type)\n{\n\tchar log_buf[8 * 1024];\n\tstruct test_log_fixup* skel;\n\tint err;\n\n\tskel = test_log_fixup__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_program__set_autoload(skel->progs.bad_relo, true);\n\tmemset(log_buf, 0, sizeof(log_buf));\n\tbpf_program__set_log_buf(skel->progs.bad_relo, log_buf, log_buf_size ?: sizeof(log_buf));\n\tbpf_program__set_log_level(skel->progs.bad_relo, 1 | 8);  \n\n\terr = test_log_fixup__load(skel);\n\tif (!ASSERT_ERR(err, \"load_fail\"))\n\t\tgoto cleanup;\n\n\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t  \"0: <invalid CO-RE relocation>\\n\"\n\t\t\t  \"failed to resolve CO-RE relocation <byte_sz> \",\n\t\t\t  \"log_buf_part1\");\n\n\tswitch (trunc_type) {\n\tcase TRUNC_NONE:\n\t\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t\t  \"struct task_struct___bad.fake_field (0:1 @ offset 4)\\n\",\n\t\t\t\t  \"log_buf_part2\");\n\t\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t\t  \"max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\\n\",\n\t\t\t\t  \"log_buf_end\");\n\t\tbreak;\n\tcase TRUNC_PARTIAL:\n\t\t \n\t\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t\t  \"struct task_struct___bad.fake_field (0:1 @ offset 4)\\n\",\n\t\t\t\t  \"log_buf_part2\");\n\t\t \n\t\tASSERT_NULL(strstr(log_buf, \"max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\\n\"),\n\t\t\t    \"log_buf_end\");\n\t\tbreak;\n\tcase TRUNC_FULL:\n\t\t \n\t\tASSERT_NULL(strstr(log_buf, \"struct task_struct___bad.fake_field (0:1 @ offset 4)\\n\"),\n\t\t\t    \"log_buf_part2\");\n\t\t \n\t\tASSERT_NULL(strstr(log_buf, \"max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\\n\"),\n\t\t\t    \"log_buf_end\");\n\t\tbreak;\n\t}\n\n\tif (env.verbosity > VERBOSE_NONE)\n\t\tprintf(\"LOG:   \\n=================\\n%s=================\\n\", log_buf);\ncleanup:\n\ttest_log_fixup__destroy(skel);\n}\n\nstatic void bad_core_relo_subprog(void)\n{\n\tchar log_buf[8 * 1024];\n\tstruct test_log_fixup* skel;\n\tint err;\n\n\tskel = test_log_fixup__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_program__set_autoload(skel->progs.bad_relo_subprog, true);\n\tbpf_program__set_log_buf(skel->progs.bad_relo_subprog, log_buf, sizeof(log_buf));\n\n\terr = test_log_fixup__load(skel);\n\tif (!ASSERT_ERR(err, \"load_fail\"))\n\t\tgoto cleanup;\n\n\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t  \": <invalid CO-RE relocation>\\n\"\n\t\t\t  \"failed to resolve CO-RE relocation <byte_off> \",\n\t\t\t  \"log_buf\");\n\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t  \"struct task_struct___bad.fake_field_subprog (0:2 @ offset 8)\\n\",\n\t\t\t  \"log_buf\");\n\n\tif (env.verbosity > VERBOSE_NONE)\n\t\tprintf(\"LOG:   \\n=================\\n%s=================\\n\", log_buf);\n\ncleanup:\n\ttest_log_fixup__destroy(skel);\n}\n\nstatic void missing_map(void)\n{\n\tchar log_buf[8 * 1024];\n\tstruct test_log_fixup* skel;\n\tint err;\n\n\tskel = test_log_fixup__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_map__set_autocreate(skel->maps.missing_map, false);\n\n\tbpf_program__set_autoload(skel->progs.use_missing_map, true);\n\tbpf_program__set_log_buf(skel->progs.use_missing_map, log_buf, sizeof(log_buf));\n\n\terr = test_log_fixup__load(skel);\n\tif (!ASSERT_ERR(err, \"load_fail\"))\n\t\tgoto cleanup;\n\n\tASSERT_TRUE(bpf_map__autocreate(skel->maps.existing_map), \"existing_map_autocreate\");\n\tASSERT_FALSE(bpf_map__autocreate(skel->maps.missing_map), \"missing_map_autocreate\");\n\n\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t  \": <invalid BPF map reference>\\n\"\n\t\t\t  \"BPF map 'missing_map' is referenced but wasn't created\\n\",\n\t\t\t  \"log_buf\");\n\n\tif (env.verbosity > VERBOSE_NONE)\n\t\tprintf(\"LOG:   \\n=================\\n%s=================\\n\", log_buf);\n\ncleanup:\n\ttest_log_fixup__destroy(skel);\n}\n\nstatic void missing_kfunc(void)\n{\n\tchar log_buf[8 * 1024];\n\tstruct test_log_fixup* skel;\n\tint err;\n\n\tskel = test_log_fixup__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbpf_program__set_autoload(skel->progs.use_missing_kfunc, true);\n\tbpf_program__set_log_buf(skel->progs.use_missing_kfunc, log_buf, sizeof(log_buf));\n\n\terr = test_log_fixup__load(skel);\n\tif (!ASSERT_ERR(err, \"load_fail\"))\n\t\tgoto cleanup;\n\n\tASSERT_HAS_SUBSTR(log_buf,\n\t\t\t  \"0: <invalid kfunc call>\\n\"\n\t\t\t  \"kfunc 'bpf_nonexistent_kfunc' is referenced but wasn't resolved\\n\",\n\t\t\t  \"log_buf\");\n\n\tif (env.verbosity > VERBOSE_NONE)\n\t\tprintf(\"LOG:   \\n=================\\n%s=================\\n\", log_buf);\n\ncleanup:\n\ttest_log_fixup__destroy(skel);\n}\n\nvoid test_log_fixup(void)\n{\n\tif (test__start_subtest(\"bad_core_relo_trunc_none\"))\n\t\tbad_core_relo(0, TRUNC_NONE  );\n\tif (test__start_subtest(\"bad_core_relo_trunc_partial\"))\n\t\tbad_core_relo(300, TRUNC_PARTIAL  );\n\tif (test__start_subtest(\"bad_core_relo_trunc_full\"))\n\t\tbad_core_relo(210, TRUNC_FULL   );\n\tif (test__start_subtest(\"bad_core_relo_subprog\"))\n\t\tbad_core_relo_subprog();\n\tif (test__start_subtest(\"missing_map\"))\n\t\tmissing_map();\n\tif (test__start_subtest(\"missing_kfunc\"))\n\t\tmissing_kfunc();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}