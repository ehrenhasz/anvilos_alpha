{
  "module_name": "tcp_hdr_options.c",
  "hash_id": "69bd1d0ba7445c609477ac6055de0977786b8a3566da3877b4207e41bd7e5803",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tcp_hdr_options.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <linux/compiler.h>\n\n#include \"test_progs.h\"\n#include \"cgroup_helpers.h\"\n#include \"network_helpers.h\"\n#include \"test_tcp_hdr_options.h\"\n#include \"test_tcp_hdr_options.skel.h\"\n#include \"test_misc_tcp_hdr_options.skel.h\"\n\n#define LO_ADDR6 \"::1\"\n#define CG_NAME \"/tcpbpf-hdr-opt-test\"\n\nstatic struct bpf_test_option exp_passive_estab_in;\nstatic struct bpf_test_option exp_active_estab_in;\nstatic struct bpf_test_option exp_passive_fin_in;\nstatic struct bpf_test_option exp_active_fin_in;\nstatic struct hdr_stg exp_passive_hdr_stg;\nstatic struct hdr_stg exp_active_hdr_stg = { .active = true, };\n\nstatic struct test_misc_tcp_hdr_options *misc_skel;\nstatic struct test_tcp_hdr_options *skel;\nstatic int lport_linum_map_fd;\nstatic int hdr_stg_map_fd;\nstatic __u32 duration;\nstatic int cg_fd;\n\nstruct sk_fds {\n\tint srv_fd;\n\tint passive_fd;\n\tint active_fd;\n\tint passive_lport;\n\tint active_lport;\n};\n\nstatic int create_netns(void)\n{\n\tif (!ASSERT_OK(unshare(CLONE_NEWNET), \"create netns\"))\n\t\treturn -1;\n\n\tif (!ASSERT_OK(system(\"ip link set dev lo up\"), \"run ip cmd\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void print_hdr_stg(const struct hdr_stg *hdr_stg, const char *prefix)\n{\n\tfprintf(stderr, \"%s{active:%u, resend_syn:%u, syncookie:%u, fastopen:%u}\\n\",\n\t\tprefix ? : \"\", hdr_stg->active, hdr_stg->resend_syn,\n\t\thdr_stg->syncookie, hdr_stg->fastopen);\n}\n\nstatic void print_option(const struct bpf_test_option *opt, const char *prefix)\n{\n\tfprintf(stderr, \"%s{flags:0x%x, max_delack_ms:%u, rand:0x%x}\\n\",\n\t\tprefix ? : \"\", opt->flags, opt->max_delack_ms, opt->rand);\n}\n\nstatic void sk_fds_close(struct sk_fds *sk_fds)\n{\n\tclose(sk_fds->srv_fd);\n\tclose(sk_fds->passive_fd);\n\tclose(sk_fds->active_fd);\n}\n\nstatic int sk_fds_shutdown(struct sk_fds *sk_fds)\n{\n\tint ret, abyte;\n\n\tshutdown(sk_fds->active_fd, SHUT_WR);\n\tret = read(sk_fds->passive_fd, &abyte, sizeof(abyte));\n\tif (!ASSERT_EQ(ret, 0, \"read-after-shutdown(passive_fd):\"))\n\t\treturn -1;\n\n\tshutdown(sk_fds->passive_fd, SHUT_WR);\n\tret = read(sk_fds->active_fd, &abyte, sizeof(abyte));\n\tif (!ASSERT_EQ(ret, 0, \"read-after-shutdown(active_fd):\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int sk_fds_connect(struct sk_fds *sk_fds, bool fast_open)\n{\n\tconst char fast[] = \"FAST!!!\";\n\tstruct sockaddr_in6 addr6;\n\tsocklen_t len;\n\n\tsk_fds->srv_fd = start_server(AF_INET6, SOCK_STREAM, LO_ADDR6, 0, 0);\n\tif (!ASSERT_NEQ(sk_fds->srv_fd, -1, \"start_server\"))\n\t\tgoto error;\n\n\tif (fast_open)\n\t\tsk_fds->active_fd = fastopen_connect(sk_fds->srv_fd, fast,\n\t\t\t\t\t\t     sizeof(fast), 0);\n\telse\n\t\tsk_fds->active_fd = connect_to_fd(sk_fds->srv_fd, 0);\n\n\tif (!ASSERT_NEQ(sk_fds->active_fd, -1, \"\")) {\n\t\tclose(sk_fds->srv_fd);\n\t\tgoto error;\n\t}\n\n\tlen = sizeof(addr6);\n\tif (!ASSERT_OK(getsockname(sk_fds->srv_fd, (struct sockaddr *)&addr6,\n\t\t\t\t   &len), \"getsockname(srv_fd)\"))\n\t\tgoto error_close;\n\tsk_fds->passive_lport = ntohs(addr6.sin6_port);\n\n\tlen = sizeof(addr6);\n\tif (!ASSERT_OK(getsockname(sk_fds->active_fd, (struct sockaddr *)&addr6,\n\t\t\t\t   &len), \"getsockname(active_fd)\"))\n\t\tgoto error_close;\n\tsk_fds->active_lport = ntohs(addr6.sin6_port);\n\n\tsk_fds->passive_fd = accept(sk_fds->srv_fd, NULL, 0);\n\tif (!ASSERT_NEQ(sk_fds->passive_fd, -1, \"accept(srv_fd)\"))\n\t\tgoto error_close;\n\n\tif (fast_open) {\n\t\tchar bytes_in[sizeof(fast)];\n\t\tint ret;\n\n\t\tret = read(sk_fds->passive_fd, bytes_in, sizeof(bytes_in));\n\t\tif (!ASSERT_EQ(ret, sizeof(fast), \"read fastopen syn data\")) {\n\t\t\tclose(sk_fds->passive_fd);\n\t\t\tgoto error_close;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_close:\n\tclose(sk_fds->active_fd);\n\tclose(sk_fds->srv_fd);\n\nerror:\n\tmemset(sk_fds, -1, sizeof(*sk_fds));\n\treturn -1;\n}\n\nstatic int check_hdr_opt(const struct bpf_test_option *exp,\n\t\t\t const struct bpf_test_option *act,\n\t\t\t const char *hdr_desc)\n{\n\tif (!ASSERT_EQ(memcmp(exp, act, sizeof(*exp)), 0, hdr_desc)) {\n\t\tprint_option(exp, \"expected: \");\n\t\tprint_option(act, \"  actual: \");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_hdr_stg(const struct hdr_stg *exp, int fd,\n\t\t\t const char *stg_desc)\n{\n\tstruct hdr_stg act;\n\n\tif (!ASSERT_OK(bpf_map_lookup_elem(hdr_stg_map_fd, &fd, &act),\n\t\t  \"map_lookup(hdr_stg_map_fd)\"))\n\t\treturn -1;\n\n\tif (!ASSERT_EQ(memcmp(exp, &act, sizeof(*exp)), 0, stg_desc)) {\n\t\tprint_hdr_stg(exp, \"expected: \");\n\t\tprint_hdr_stg(&act, \"  actual: \");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_error_linum(const struct sk_fds *sk_fds)\n{\n\tunsigned int nr_errors = 0;\n\tstruct linum_err linum_err;\n\tint lport;\n\n\tlport = sk_fds->passive_lport;\n\tif (!bpf_map_lookup_elem(lport_linum_map_fd, &lport, &linum_err)) {\n\t\tfprintf(stderr,\n\t\t\t\"bpf prog error out at lport:passive(%d), linum:%u err:%d\\n\",\n\t\t\tlport, linum_err.linum, linum_err.err);\n\t\tnr_errors++;\n\t}\n\n\tlport = sk_fds->active_lport;\n\tif (!bpf_map_lookup_elem(lport_linum_map_fd, &lport, &linum_err)) {\n\t\tfprintf(stderr,\n\t\t\t\"bpf prog error out at lport:active(%d), linum:%u err:%d\\n\",\n\t\t\tlport, linum_err.linum, linum_err.err);\n\t\tnr_errors++;\n\t}\n\n\treturn nr_errors;\n}\n\nstatic void check_hdr_and_close_fds(struct sk_fds *sk_fds)\n{\n\tconst __u32 expected_inherit_cb_flags =\n\t\tBPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG |\n\t\tBPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG |\n\t\tBPF_SOCK_OPS_STATE_CB_FLAG;\n\n\tif (sk_fds_shutdown(sk_fds))\n\t\tgoto check_linum;\n\n\tif (!ASSERT_EQ(expected_inherit_cb_flags, skel->bss->inherit_cb_flags,\n\t\t       \"inherit_cb_flags\"))\n\t\tgoto check_linum;\n\n\tif (check_hdr_stg(&exp_passive_hdr_stg, sk_fds->passive_fd,\n\t\t\t  \"passive_hdr_stg\"))\n\t\tgoto check_linum;\n\n\tif (check_hdr_stg(&exp_active_hdr_stg, sk_fds->active_fd,\n\t\t\t  \"active_hdr_stg\"))\n\t\tgoto check_linum;\n\n\tif (check_hdr_opt(&exp_passive_estab_in, &skel->bss->passive_estab_in,\n\t\t\t  \"passive_estab_in\"))\n\t\tgoto check_linum;\n\n\tif (check_hdr_opt(&exp_active_estab_in, &skel->bss->active_estab_in,\n\t\t\t  \"active_estab_in\"))\n\t\tgoto check_linum;\n\n\tif (check_hdr_opt(&exp_passive_fin_in, &skel->bss->passive_fin_in,\n\t\t\t  \"passive_fin_in\"))\n\t\tgoto check_linum;\n\n\tcheck_hdr_opt(&exp_active_fin_in, &skel->bss->active_fin_in,\n\t\t      \"active_fin_in\");\n\ncheck_linum:\n\tASSERT_FALSE(check_error_linum(sk_fds), \"check_error_linum\");\n\tsk_fds_close(sk_fds);\n}\n\nstatic void prepare_out(void)\n{\n\tskel->bss->active_syn_out = exp_passive_estab_in;\n\tskel->bss->passive_synack_out = exp_active_estab_in;\n\n\tskel->bss->active_fin_out = exp_passive_fin_in;\n\tskel->bss->passive_fin_out = exp_active_fin_in;\n}\n\nstatic void reset_test(void)\n{\n\tsize_t optsize = sizeof(struct bpf_test_option);\n\tint lport, err;\n\n\tmemset(&skel->bss->passive_synack_out, 0, optsize);\n\tmemset(&skel->bss->passive_fin_out, 0, optsize);\n\n\tmemset(&skel->bss->passive_estab_in, 0, optsize);\n\tmemset(&skel->bss->passive_fin_in, 0, optsize);\n\n\tmemset(&skel->bss->active_syn_out, 0, optsize);\n\tmemset(&skel->bss->active_fin_out, 0, optsize);\n\n\tmemset(&skel->bss->active_estab_in, 0, optsize);\n\tmemset(&skel->bss->active_fin_in, 0, optsize);\n\n\tskel->bss->inherit_cb_flags = 0;\n\n\tskel->data->test_kind = TCPOPT_EXP;\n\tskel->data->test_magic = 0xeB9F;\n\n\tmemset(&exp_passive_estab_in, 0, optsize);\n\tmemset(&exp_active_estab_in, 0, optsize);\n\tmemset(&exp_passive_fin_in, 0, optsize);\n\tmemset(&exp_active_fin_in, 0, optsize);\n\n\tmemset(&exp_passive_hdr_stg, 0, sizeof(exp_passive_hdr_stg));\n\tmemset(&exp_active_hdr_stg, 0, sizeof(exp_active_hdr_stg));\n\texp_active_hdr_stg.active = true;\n\n\terr = bpf_map_get_next_key(lport_linum_map_fd, NULL, &lport);\n\twhile (!err) {\n\t\tbpf_map_delete_elem(lport_linum_map_fd, &lport);\n\t\terr = bpf_map_get_next_key(lport_linum_map_fd, &lport, &lport);\n\t}\n}\n\nstatic void fastopen_estab(void)\n{\n\tstruct bpf_link *link;\n\tstruct sk_fds sk_fds;\n\n\thdr_stg_map_fd = bpf_map__fd(skel->maps.hdr_stg_map);\n\tlport_linum_map_fd = bpf_map__fd(skel->maps.lport_linum_map);\n\n\texp_passive_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS;\n\texp_passive_estab_in.rand = 0xfa;\n\texp_passive_estab_in.max_delack_ms = 11;\n\n\texp_active_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS;\n\texp_active_estab_in.rand = 0xce;\n\texp_active_estab_in.max_delack_ms = 22;\n\n\texp_passive_hdr_stg.fastopen = true;\n\n\tprepare_out();\n\n\t \n\tif (write_sysctl(\"/proc/sys/net/ipv4/tcp_fastopen\", \"1543\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_cgroup(skel->progs.estab, cg_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_cgroup(estab)\"))\n\t\treturn;\n\n\tif (sk_fds_connect(&sk_fds, true)) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\tcheck_hdr_and_close_fds(&sk_fds);\n\tbpf_link__destroy(link);\n}\n\nstatic void syncookie_estab(void)\n{\n\tstruct bpf_link *link;\n\tstruct sk_fds sk_fds;\n\n\thdr_stg_map_fd = bpf_map__fd(skel->maps.hdr_stg_map);\n\tlport_linum_map_fd = bpf_map__fd(skel->maps.lport_linum_map);\n\n\texp_passive_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS;\n\texp_passive_estab_in.rand = 0xfa;\n\texp_passive_estab_in.max_delack_ms = 11;\n\n\texp_active_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS |\n\t\t\t\t\tOPTION_F_RESEND;\n\texp_active_estab_in.rand = 0xce;\n\texp_active_estab_in.max_delack_ms = 22;\n\n\texp_passive_hdr_stg.syncookie = true;\n\texp_active_hdr_stg.resend_syn = true;\n\n\tprepare_out();\n\n\t \n\tskel->bss->passive_synack_out.flags &= ~OPTION_F_RESEND;\n\n\t \n\tif (write_sysctl(\"/proc/sys/net/ipv4/tcp_syncookies\", \"2\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_cgroup(skel->progs.estab, cg_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_cgroup(estab)\"))\n\t\treturn;\n\n\tif (sk_fds_connect(&sk_fds, false)) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\tcheck_hdr_and_close_fds(&sk_fds);\n\tbpf_link__destroy(link);\n}\n\nstatic void fin(void)\n{\n\tstruct bpf_link *link;\n\tstruct sk_fds sk_fds;\n\n\thdr_stg_map_fd = bpf_map__fd(skel->maps.hdr_stg_map);\n\tlport_linum_map_fd = bpf_map__fd(skel->maps.lport_linum_map);\n\n\texp_passive_fin_in.flags = OPTION_F_RAND;\n\texp_passive_fin_in.rand = 0xfa;\n\n\texp_active_fin_in.flags = OPTION_F_RAND;\n\texp_active_fin_in.rand = 0xce;\n\n\tprepare_out();\n\n\tif (write_sysctl(\"/proc/sys/net/ipv4/tcp_syncookies\", \"1\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_cgroup(skel->progs.estab, cg_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_cgroup(estab)\"))\n\t\treturn;\n\n\tif (sk_fds_connect(&sk_fds, false)) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\tcheck_hdr_and_close_fds(&sk_fds);\n\tbpf_link__destroy(link);\n}\n\nstatic void __simple_estab(bool exprm)\n{\n\tstruct bpf_link *link;\n\tstruct sk_fds sk_fds;\n\n\thdr_stg_map_fd = bpf_map__fd(skel->maps.hdr_stg_map);\n\tlport_linum_map_fd = bpf_map__fd(skel->maps.lport_linum_map);\n\n\texp_passive_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS;\n\texp_passive_estab_in.rand = 0xfa;\n\texp_passive_estab_in.max_delack_ms = 11;\n\n\texp_active_estab_in.flags = OPTION_F_RAND | OPTION_F_MAX_DELACK_MS;\n\texp_active_estab_in.rand = 0xce;\n\texp_active_estab_in.max_delack_ms = 22;\n\n\tprepare_out();\n\n\tif (!exprm) {\n\t\tskel->data->test_kind = 0xB9;\n\t\tskel->data->test_magic = 0;\n\t}\n\n\tif (write_sysctl(\"/proc/sys/net/ipv4/tcp_syncookies\", \"1\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_cgroup(skel->progs.estab, cg_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_cgroup(estab)\"))\n\t\treturn;\n\n\tif (sk_fds_connect(&sk_fds, false)) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\tcheck_hdr_and_close_fds(&sk_fds);\n\tbpf_link__destroy(link);\n}\n\nstatic void no_exprm_estab(void)\n{\n\t__simple_estab(false);\n}\n\nstatic void simple_estab(void)\n{\n\t__simple_estab(true);\n}\n\nstatic void misc(void)\n{\n\tconst char send_msg[] = \"MISC!!!\";\n\tchar recv_msg[sizeof(send_msg)];\n\tconst unsigned int nr_data = 2;\n\tstruct bpf_link *link;\n\tstruct sk_fds sk_fds;\n\tint i, ret;\n\n\tlport_linum_map_fd = bpf_map__fd(misc_skel->maps.lport_linum_map);\n\n\tif (write_sysctl(\"/proc/sys/net/ipv4/tcp_syncookies\", \"1\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_cgroup(misc_skel->progs.misc_estab, cg_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_cgroup(misc_estab)\"))\n\t\treturn;\n\n\tif (sk_fds_connect(&sk_fds, false)) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_data; i++) {\n\t\t \n\t\tret = send(sk_fds.active_fd, send_msg, sizeof(send_msg),\n\t\t\t   MSG_EOR);\n\t\tif (!ASSERT_EQ(ret, sizeof(send_msg), \"send(msg)\"))\n\t\t\tgoto check_linum;\n\n\t\tret = read(sk_fds.passive_fd, recv_msg, sizeof(recv_msg));\n\t\tif (!ASSERT_EQ(ret, sizeof(send_msg), \"read(msg)\"))\n\t\t\tgoto check_linum;\n\t}\n\n\tif (sk_fds_shutdown(&sk_fds))\n\t\tgoto check_linum;\n\n\tASSERT_EQ(misc_skel->bss->nr_syn, 1, \"unexpected nr_syn\");\n\n\tASSERT_EQ(misc_skel->bss->nr_data, nr_data, \"unexpected nr_data\");\n\n\t \n\tCHECK(misc_skel->bss->nr_pure_ack != 1 &&\n\t      misc_skel->bss->nr_pure_ack != 2,\n\t      \"unexpected nr_pure_ack\",\n\t      \"expected (1 or 2) != actual (%u)\\n\",\n\t\tmisc_skel->bss->nr_pure_ack);\n\n\tASSERT_EQ(misc_skel->bss->nr_fin, 1, \"unexpected nr_fin\");\n\n\tASSERT_EQ(misc_skel->bss->nr_hwtstamp, 0, \"nr_hwtstamp\");\n\ncheck_linum:\n\tASSERT_FALSE(check_error_linum(&sk_fds), \"check_error_linum\");\n\tsk_fds_close(&sk_fds);\n\tbpf_link__destroy(link);\n}\n\nstruct test {\n\tconst char *desc;\n\tvoid (*run)(void);\n};\n\n#define DEF_TEST(name) { #name, name }\nstatic struct test tests[] = {\n\tDEF_TEST(simple_estab),\n\tDEF_TEST(no_exprm_estab),\n\tDEF_TEST(syncookie_estab),\n\tDEF_TEST(fastopen_estab),\n\tDEF_TEST(fin),\n\tDEF_TEST(misc),\n};\n\nvoid test_tcp_hdr_options(void)\n{\n\tint i;\n\n\tskel = test_tcp_hdr_options__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open and load skel\"))\n\t\treturn;\n\n\tmisc_skel = test_misc_tcp_hdr_options__open_and_load();\n\tif (!ASSERT_OK_PTR(misc_skel, \"open and load misc test skel\"))\n\t\tgoto skel_destroy;\n\n\tcg_fd = test__join_cgroup(CG_NAME);\n\tif (!ASSERT_GE(cg_fd, 0, \"join_cgroup\"))\n\t\tgoto skel_destroy;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tif (!test__start_subtest(tests[i].desc))\n\t\t\tcontinue;\n\n\t\tif (create_netns())\n\t\t\tbreak;\n\n\t\ttests[i].run();\n\n\t\treset_test();\n\t}\n\n\tclose(cg_fd);\nskel_destroy:\n\ttest_misc_tcp_hdr_options__destroy(misc_skel);\n\ttest_tcp_hdr_options__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}