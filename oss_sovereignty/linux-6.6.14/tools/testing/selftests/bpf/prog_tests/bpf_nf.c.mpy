{
  "module_name": "bpf_nf.c",
  "hash_id": "a61fe82a8486d1a196565e2bf8d083e7039db21c718d2a766171e5c2750abddc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_nf.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <linux/netfilter/nf_conntrack_common.h>\n#include \"test_bpf_nf.skel.h\"\n#include \"test_bpf_nf_fail.skel.h\"\n\nstatic char log_buf[1024 * 1024];\n\nstruct {\n\tconst char *prog_name;\n\tconst char *err_msg;\n} test_bpf_nf_fail_tests[] = {\n\t{ \"alloc_release\", \"kernel function bpf_ct_release args#0 expected pointer to STRUCT nf_conn but\" },\n\t{ \"insert_insert\", \"kernel function bpf_ct_insert_entry args#0 expected pointer to STRUCT nf_conn___init but\" },\n\t{ \"lookup_insert\", \"kernel function bpf_ct_insert_entry args#0 expected pointer to STRUCT nf_conn___init but\" },\n\t{ \"set_timeout_after_insert\", \"kernel function bpf_ct_set_timeout args#0 expected pointer to STRUCT nf_conn___init but\" },\n\t{ \"set_status_after_insert\", \"kernel function bpf_ct_set_status args#0 expected pointer to STRUCT nf_conn___init but\" },\n\t{ \"change_timeout_after_alloc\", \"kernel function bpf_ct_change_timeout args#0 expected pointer to STRUCT nf_conn but\" },\n\t{ \"change_status_after_alloc\", \"kernel function bpf_ct_change_status args#0 expected pointer to STRUCT nf_conn but\" },\n\t{ \"write_not_allowlisted_field\", \"no write support to nf_conn at off\" },\n};\n\nenum {\n\tTEST_XDP,\n\tTEST_TC_BPF,\n};\n\n#define TIMEOUT_MS\t\t3000\n#define IPS_STATUS_MASK\t\t(IPS_CONFIRMED | IPS_SEEN_REPLY | \\\n\t\t\t\t IPS_SRC_NAT_DONE | IPS_DST_NAT_DONE | \\\n\t\t\t\t IPS_SRC_NAT | IPS_DST_NAT)\n\nstatic int connect_to_server(int srv_fd)\n{\n\tint fd = -1;\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(fd, 0, \"socket\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(connect_fd_to_fd(fd, srv_fd, TIMEOUT_MS), 0, \"connect_fd_to_fd\")) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\nout:\n\treturn fd;\n}\n\nstatic void test_bpf_nf_ct(int mode)\n{\n\tconst char *iptables = \"iptables-legacy -t raw %s PREROUTING -j CONNMARK --set-mark 42/0\";\n\tint srv_fd = -1, client_fd = -1, srv_client_fd = -1;\n\tstruct sockaddr_in peer_addr = {};\n\tstruct test_bpf_nf *skel;\n\tint prog_fd, err;\n\tsocklen_t len;\n\tu16 srv_port;\n\tchar cmd[128];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tskel = test_bpf_nf__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_bpf_nf__open_and_load\"))\n\t\treturn;\n\n\t \n\tsnprintf(cmd, sizeof(cmd), iptables, \"-A\");\n\tif (!ASSERT_OK(system(cmd), cmd))\n\t\tgoto end;\n\n\tsrv_port = (mode == TEST_XDP) ? 5005 : 5006;\n\tsrv_fd = start_server(AF_INET, SOCK_STREAM, \"127.0.0.1\", srv_port, TIMEOUT_MS);\n\tif (!ASSERT_GE(srv_fd, 0, \"start_server\"))\n\t\tgoto end;\n\n\tclient_fd = connect_to_server(srv_fd);\n\tif (!ASSERT_GE(client_fd, 0, \"connect_to_server\"))\n\t\tgoto end;\n\n\tlen = sizeof(peer_addr);\n\tsrv_client_fd = accept(srv_fd, (struct sockaddr *)&peer_addr, &len);\n\tif (!ASSERT_GE(srv_client_fd, 0, \"accept\"))\n\t\tgoto end;\n\tif (!ASSERT_EQ(len, sizeof(struct sockaddr_in), \"sockaddr len\"))\n\t\tgoto end;\n\n\tskel->bss->saddr = peer_addr.sin_addr.s_addr;\n\tskel->bss->sport = peer_addr.sin_port;\n\tskel->bss->daddr = peer_addr.sin_addr.s_addr;\n\tskel->bss->dport = htons(srv_port);\n\n\tif (mode == TEST_XDP)\n\t\tprog_fd = bpf_program__fd(skel->progs.nf_xdp_ct_test);\n\telse\n\t\tprog_fd = bpf_program__fd(skel->progs.nf_skb_ct_test);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"bpf_prog_test_run\"))\n\t\tgoto end;\n\n\tASSERT_EQ(skel->bss->test_einval_bpf_tuple, -EINVAL, \"Test EINVAL for NULL bpf_tuple\");\n\tASSERT_EQ(skel->bss->test_einval_reserved, -EINVAL, \"Test EINVAL for reserved not set to 0\");\n\tASSERT_EQ(skel->bss->test_einval_netns_id, -EINVAL, \"Test EINVAL for netns_id < -1\");\n\tASSERT_EQ(skel->bss->test_einval_len_opts, -EINVAL, \"Test EINVAL for len__opts != NF_BPF_CT_OPTS_SZ\");\n\tASSERT_EQ(skel->bss->test_eproto_l4proto, -EPROTO, \"Test EPROTO for l4proto != TCP or UDP\");\n\tASSERT_EQ(skel->bss->test_enonet_netns_id, -ENONET, \"Test ENONET for bad but valid netns_id\");\n\tASSERT_EQ(skel->bss->test_enoent_lookup, -ENOENT, \"Test ENOENT for failed lookup\");\n\tASSERT_EQ(skel->bss->test_eafnosupport, -EAFNOSUPPORT, \"Test EAFNOSUPPORT for invalid len__tuple\");\n\tASSERT_EQ(skel->data->test_alloc_entry, 0, \"Test for alloc new entry\");\n\tASSERT_EQ(skel->data->test_insert_entry, 0, \"Test for insert new entry\");\n\tASSERT_EQ(skel->data->test_succ_lookup, 0, \"Test for successful lookup\");\n\t \n\tASSERT_GT(skel->bss->test_delta_timeout, 8, \"Test for min ct timeout update\");\n\tASSERT_LE(skel->bss->test_delta_timeout, 10, \"Test for max ct timeout update\");\n\tASSERT_EQ(skel->bss->test_insert_lookup_mark, 77, \"Test for insert and lookup mark value\");\n\tASSERT_EQ(skel->bss->test_status, IPS_STATUS_MASK, \"Test for ct status update \");\n\tASSERT_EQ(skel->data->test_exist_lookup, 0, \"Test existing connection lookup\");\n\tASSERT_EQ(skel->bss->test_exist_lookup_mark, 43, \"Test existing connection lookup ctmark\");\n\tASSERT_EQ(skel->data->test_snat_addr, 0, \"Test for source natting\");\n\tASSERT_EQ(skel->data->test_dnat_addr, 0, \"Test for destination natting\");\nend:\n\tif (client_fd != -1)\n\t\tclose(client_fd);\n\tif (srv_client_fd != -1)\n\t\tclose(srv_client_fd);\n\tif (srv_fd != -1)\n\t\tclose(srv_fd);\n\n\tsnprintf(cmd, sizeof(cmd), iptables, \"-D\");\n\tsystem(cmd);\n\ttest_bpf_nf__destroy(skel);\n}\n\nstatic void test_bpf_nf_ct_fail(const char *prog_name, const char *err_msg)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, opts, .kernel_log_buf = log_buf,\n\t\t\t\t\t\t.kernel_log_size = sizeof(log_buf),\n\t\t\t\t\t\t.kernel_log_level = 1);\n\tstruct test_bpf_nf_fail *skel;\n\tstruct bpf_program *prog;\n\tint ret;\n\n\tskel = test_bpf_nf_fail__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"test_bpf_nf_fail__open\"))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto end;\n\n\tbpf_program__set_autoload(prog, true);\n\n\tret = test_bpf_nf_fail__load(skel);\n\tif (!ASSERT_ERR(ret, \"test_bpf_nf_fail__load must fail\"))\n\t\tgoto end;\n\n\tif (!ASSERT_OK_PTR(strstr(log_buf, err_msg), \"expected error message\")) {\n\t\tfprintf(stderr, \"Expected: %s\\n\", err_msg);\n\t\tfprintf(stderr, \"Verifier: %s\\n\", log_buf);\n\t}\n\nend:\n\ttest_bpf_nf_fail__destroy(skel);\n}\n\nvoid test_bpf_nf(void)\n{\n\tint i;\n\tif (test__start_subtest(\"xdp-ct\"))\n\t\ttest_bpf_nf_ct(TEST_XDP);\n\tif (test__start_subtest(\"tc-bpf-ct\"))\n\t\ttest_bpf_nf_ct(TEST_TC_BPF);\n\tfor (i = 0; i < ARRAY_SIZE(test_bpf_nf_fail_tests); i++) {\n\t\tif (test__start_subtest(test_bpf_nf_fail_tests[i].prog_name))\n\t\t\ttest_bpf_nf_ct_fail(test_bpf_nf_fail_tests[i].prog_name,\n\t\t\t\t\t    test_bpf_nf_fail_tests[i].err_msg);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}