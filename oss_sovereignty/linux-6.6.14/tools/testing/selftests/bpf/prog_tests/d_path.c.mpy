{
  "module_name": "d_path.c",
  "hash_id": "4146469e9db96c5fb95b7820c1c2b9e2208a8b902411201f259969e1141367ac",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/d_path.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <test_progs.h>\n#include <sys/stat.h>\n#include <linux/sched.h>\n#include <sys/syscall.h>\n\n#define MAX_PATH_LEN\t\t128\n#define MAX_FILES\t\t7\n\n#include \"test_d_path.skel.h\"\n#include \"test_d_path_check_rdonly_mem.skel.h\"\n#include \"test_d_path_check_types.skel.h\"\n\n \n#ifndef __NR_close_range\n#ifdef __alpha__\n#define __NR_close_range 546\n#else\n#define __NR_close_range 436\n#endif\n#endif\n\nstatic int duration;\n\nstatic struct {\n\t__u32 cnt;\n\tchar paths[MAX_FILES][MAX_PATH_LEN];\n} src;\n\nstatic int set_pathname(int fd, pid_t pid)\n{\n\tchar buf[MAX_PATH_LEN];\n\n\tsnprintf(buf, MAX_PATH_LEN, \"/proc/%d/fd/%d\", pid, fd);\n\treturn readlink(buf, src.paths[src.cnt++], MAX_PATH_LEN);\n}\n\nstatic int trigger_fstat_events(pid_t pid)\n{\n\tint sockfd = -1, procfd = -1, devfd = -1;\n\tint localfd = -1, indicatorfd = -1;\n\tint pipefd[2] = { -1, -1 };\n\tstruct stat fileStat;\n\tint ret = -1;\n\n\t \n\tif (CHECK(pipe(pipefd) < 0, \"trigger\", \"pipe failed\\n\"))\n\t\treturn ret;\n\t \n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (CHECK(sockfd < 0, \"trigger\", \"socket failed\\n\"))\n\t\tgoto out_close;\n\t \n\tprocfd = open(\"/proc/self/comm\", O_RDONLY);\n\tif (CHECK(procfd < 0, \"trigger\", \"open /proc/self/comm failed\\n\"))\n\t\tgoto out_close;\n\tdevfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (CHECK(devfd < 0, \"trigger\", \"open /dev/urandom failed\\n\"))\n\t\tgoto out_close;\n\tlocalfd = open(\"/tmp/d_path_loadgen.txt\", O_CREAT | O_RDONLY, 0644);\n\tif (CHECK(localfd < 0, \"trigger\", \"open /tmp/d_path_loadgen.txt failed\\n\"))\n\t\tgoto out_close;\n\t \n\tremove(\"/tmp/d_path_loadgen.txt\");\n\tindicatorfd = open(\"/tmp/\", O_PATH);\n\tif (CHECK(indicatorfd < 0, \"trigger\", \"open /tmp/ failed\\n\"))\n\t\tgoto out_close;\n\n\tret = set_pathname(pipefd[0], pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for pipe[0]\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(pipefd[1], pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for pipe[1]\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(sockfd, pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for socket\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(procfd, pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for proc\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(devfd, pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for dev\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(localfd, pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for file\\n\"))\n\t\tgoto out_close;\n\tret = set_pathname(indicatorfd, pid);\n\tif (CHECK(ret < 0, \"trigger\", \"set_pathname failed for dir\\n\"))\n\t\tgoto out_close;\n\n\t \n\tfstat(pipefd[0], &fileStat);\n\tfstat(pipefd[1], &fileStat);\n\tfstat(sockfd, &fileStat);\n\tfstat(procfd, &fileStat);\n\tfstat(devfd, &fileStat);\n\tfstat(localfd, &fileStat);\n\tfstat(indicatorfd, &fileStat);\n\nout_close:\n\t \n#define close(fd) syscall(__NR_close_range, fd, fd, 0)\n\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\tclose(sockfd);\n\tclose(procfd);\n\tclose(devfd);\n\tclose(localfd);\n\tclose(indicatorfd);\n\n#undef close\n\treturn ret;\n}\n\nstatic void test_d_path_basic(void)\n{\n\tstruct test_d_path__bss *bss;\n\tstruct test_d_path *skel;\n\tint err;\n\n\tskel = test_d_path__open_and_load();\n\tif (CHECK(!skel, \"setup\", \"d_path skeleton failed\\n\"))\n\t\tgoto cleanup;\n\n\terr = test_d_path__attach(skel);\n\tif (CHECK(err, \"setup\", \"attach failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tbss = skel->bss;\n\tbss->my_pid = getpid();\n\n\terr = trigger_fstat_events(bss->my_pid);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\tif (CHECK(!bss->called_stat,\n\t\t  \"stat\",\n\t\t  \"trampoline for security_inode_getattr was not called\\n\"))\n\t\tgoto cleanup;\n\n\tif (CHECK(!bss->called_close,\n\t\t  \"close\",\n\t\t  \"trampoline for filp_close was not called\\n\"))\n\t\tgoto cleanup;\n\n\tfor (int i = 0; i < MAX_FILES; i++) {\n\t\tCHECK(strncmp(src.paths[i], bss->paths_stat[i], MAX_PATH_LEN),\n\t\t      \"check\",\n\t\t      \"failed to get stat path[%d]: %s vs %s\\n\",\n\t\t      i, src.paths[i], bss->paths_stat[i]);\n\t\tCHECK(strncmp(src.paths[i], bss->paths_close[i], MAX_PATH_LEN),\n\t\t      \"check\",\n\t\t      \"failed to get close path[%d]: %s vs %s\\n\",\n\t\t      i, src.paths[i], bss->paths_close[i]);\n\t\t \n\t\tCHECK(bss->rets_stat[i] != strlen(bss->paths_stat[i]) + 1,\n\t\t      \"check\",\n\t\t      \"failed to match stat return [%d]: %d vs %zd [%s]\\n\",\n\t\t      i, bss->rets_stat[i], strlen(bss->paths_stat[i]) + 1,\n\t\t      bss->paths_stat[i]);\n\t\tCHECK(bss->rets_close[i] != strlen(bss->paths_stat[i]) + 1,\n\t\t      \"check\",\n\t\t      \"failed to match stat return [%d]: %d vs %zd [%s]\\n\",\n\t\t      i, bss->rets_close[i], strlen(bss->paths_close[i]) + 1,\n\t\t      bss->paths_stat[i]);\n\t}\n\ncleanup:\n\ttest_d_path__destroy(skel);\n}\n\nstatic void test_d_path_check_rdonly_mem(void)\n{\n\tstruct test_d_path_check_rdonly_mem *skel;\n\n\tskel = test_d_path_check_rdonly_mem__open_and_load();\n\tASSERT_ERR_PTR(skel, \"unexpected_load_overwriting_rdonly_mem\");\n\n\ttest_d_path_check_rdonly_mem__destroy(skel);\n}\n\nstatic void test_d_path_check_types(void)\n{\n\tstruct test_d_path_check_types *skel;\n\n\tskel = test_d_path_check_types__open_and_load();\n\tASSERT_ERR_PTR(skel, \"unexpected_load_passing_wrong_type\");\n\n\ttest_d_path_check_types__destroy(skel);\n}\n\nvoid test_d_path(void)\n{\n\tif (test__start_subtest(\"basic\"))\n\t\ttest_d_path_basic();\n\n\tif (test__start_subtest(\"check_rdonly_mem\"))\n\t\ttest_d_path_check_rdonly_mem();\n\n\tif (test__start_subtest(\"check_alloc_mem\"))\n\t\ttest_d_path_check_types();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}