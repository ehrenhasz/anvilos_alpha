{
  "module_name": "tcpbpf_user.c",
  "hash_id": "17cfec92efc94bbd2784b4700cdc0eb8ad4d21a0754c4c6312ac5936a9ae8147",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\n#include \"test_tcpbpf.h\"\n#include \"test_tcpbpf_kern.skel.h\"\n\n#define LO_ADDR6 \"::1\"\n#define CG_NAME \"/tcpbpf-user-test\"\n\nstatic void verify_result(struct tcpbpf_globals *result)\n{\n\t__u32 expected_events = ((1 << BPF_SOCK_OPS_TIMEOUT_INIT) |\n\t\t\t\t (1 << BPF_SOCK_OPS_RWND_INIT) |\n\t\t\t\t (1 << BPF_SOCK_OPS_TCP_CONNECT_CB) |\n\t\t\t\t (1 << BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) |\n\t\t\t\t (1 << BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB) |\n\t\t\t\t (1 << BPF_SOCK_OPS_NEEDS_ECN) |\n\t\t\t\t (1 << BPF_SOCK_OPS_STATE_CB) |\n\t\t\t\t (1 << BPF_SOCK_OPS_TCP_LISTEN_CB));\n\n\t \n\tASSERT_EQ(expected_events, result->event_map, \"event_map\");\n\n\tASSERT_EQ(result->bytes_received, 501, \"bytes_received\");\n\tASSERT_EQ(result->bytes_acked, 1002, \"bytes_acked\");\n\tASSERT_EQ(result->data_segs_in, 1, \"data_segs_in\");\n\tASSERT_EQ(result->data_segs_out, 1, \"data_segs_out\");\n\tASSERT_EQ(result->bad_cb_test_rv, 0x80, \"bad_cb_test_rv\");\n\tASSERT_EQ(result->good_cb_test_rv, 0, \"good_cb_test_rv\");\n\tASSERT_EQ(result->num_listen, 1, \"num_listen\");\n\n\t \n\tASSERT_EQ(result->num_close_events, 3, \"num_close_events\");\n\n\t \n\tASSERT_EQ(result->tcp_save_syn, 0, \"tcp_save_syn\");\n\n\t \n\tASSERT_EQ(result->tcp_saved_syn, 1, \"tcp_saved_syn\");\n\n\t \n\tASSERT_EQ(result->window_clamp_client, 9216, \"window_clamp_client\");\n\tASSERT_EQ(result->window_clamp_server, 9216, \"window_clamp_server\");\n}\n\nstatic void run_test(struct tcpbpf_globals *result)\n{\n\tint listen_fd = -1, cli_fd = -1, accept_fd = -1;\n\tchar buf[1000];\n\tint err = -1;\n\tint i, rv;\n\n\tlisten_fd = start_server(AF_INET6, SOCK_STREAM, LO_ADDR6, 0, 0);\n\tif (!ASSERT_NEQ(listen_fd, -1, \"start_server\"))\n\t\tgoto done;\n\n\tcli_fd = connect_to_fd(listen_fd, 0);\n\tif (!ASSERT_NEQ(cli_fd, -1, \"connect_to_fd(listen_fd)\"))\n\t\tgoto done;\n\n\taccept_fd = accept(listen_fd, NULL, NULL);\n\tif (!ASSERT_NEQ(accept_fd, -1, \"accept(listen_fd)\"))\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < 1000; i++)\n\t\tbuf[i] = '+';\n\n\trv = send(cli_fd, buf, 1000, 0);\n\tif (!ASSERT_EQ(rv, 1000, \"send(cli_fd)\"))\n\t\tgoto done;\n\n\trv = recv(accept_fd, buf, 1000, 0);\n\tif (!ASSERT_EQ(rv, 1000, \"recv(accept_fd)\"))\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < 500; i++)\n\t\tbuf[i] = '.';\n\n\trv = send(accept_fd, buf, 500, 0);\n\tif (!ASSERT_EQ(rv, 500, \"send(accept_fd)\"))\n\t\tgoto done;\n\n\trv = recv(cli_fd, buf, 500, 0);\n\tif (!ASSERT_EQ(rv, 500, \"recv(cli_fd)\"))\n\t\tgoto done;\n\n\t \n\tshutdown(accept_fd, SHUT_WR);\n\terr = recv(cli_fd, buf, 1, 0);\n\tif (!ASSERT_OK(err, \"recv(cli_fd) for fin\"))\n\t\tgoto done;\n\n\tshutdown(cli_fd, SHUT_WR);\n\terr = recv(accept_fd, buf, 1, 0);\n\tASSERT_OK(err, \"recv(accept_fd) for fin\");\ndone:\n\tif (accept_fd != -1)\n\t\tclose(accept_fd);\n\tif (cli_fd != -1)\n\t\tclose(cli_fd);\n\tif (listen_fd != -1)\n\t\tclose(listen_fd);\n\n\tif (!err)\n\t\tverify_result(result);\n}\n\nvoid test_tcpbpf_user(void)\n{\n\tstruct test_tcpbpf_kern *skel;\n\tint cg_fd = -1;\n\n\tskel = test_tcpbpf_kern__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open and load skel\"))\n\t\treturn;\n\n\tcg_fd = test__join_cgroup(CG_NAME);\n\tif (!ASSERT_GE(cg_fd, 0, \"test__join_cgroup(\" CG_NAME \")\"))\n\t\tgoto err;\n\n\tskel->links.bpf_testcb = bpf_program__attach_cgroup(skel->progs.bpf_testcb, cg_fd);\n\tif (!ASSERT_OK_PTR(skel->links.bpf_testcb, \"attach_cgroup(bpf_testcb)\"))\n\t\tgoto err;\n\n\trun_test(&skel->bss->global);\n\nerr:\n\tif (cg_fd != -1)\n\t\tclose(cg_fd);\n\ttest_tcpbpf_kern__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}