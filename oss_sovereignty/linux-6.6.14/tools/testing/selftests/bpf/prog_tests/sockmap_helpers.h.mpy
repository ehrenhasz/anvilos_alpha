{
  "module_name": "sockmap_helpers.h",
  "hash_id": "dc65cab82e2b9ce4e0f0b2d272b1fb034c1b37c81f2fd6fe51daeceb00e848d8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sockmap_helpers.h",
  "human_readable_source": "#ifndef __SOCKMAP_HELPERS__\n#define __SOCKMAP_HELPERS__\n\n#include <linux/vm_sockets.h>\n\n#define IO_TIMEOUT_SEC 30\n#define MAX_STRERR_LEN 256\n#define MAX_TEST_NAME 80\n\n \n#ifndef VMADDR_CID_LOCAL\n#define VMADDR_CID_LOCAL 1\n#endif\n\n#define __always_unused\t__attribute__((__unused__))\n\n#define _FAIL(errnum, fmt...)                                                  \\\n\t({                                                                     \\\n\t\terror_at_line(0, (errnum), __func__, __LINE__, fmt);           \\\n\t\tCHECK_FAIL(true);                                              \\\n\t})\n#define FAIL(fmt...) _FAIL(0, fmt)\n#define FAIL_ERRNO(fmt...) _FAIL(errno, fmt)\n#define FAIL_LIBBPF(err, msg)                                                  \\\n\t({                                                                     \\\n\t\tchar __buf[MAX_STRERR_LEN];                                    \\\n\t\tlibbpf_strerror((err), __buf, sizeof(__buf));                  \\\n\t\tFAIL(\"%s: %s\", (msg), __buf);                                  \\\n\t})\n\n \n\n#define xaccept_nonblock(fd, addr, len)                                        \\\n\t({                                                                     \\\n\t\tint __ret =                                                    \\\n\t\t\taccept_timeout((fd), (addr), (len), IO_TIMEOUT_SEC);   \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"accept\");                                  \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbind(fd, addr, len)                                                   \\\n\t({                                                                     \\\n\t\tint __ret = bind((fd), (addr), (len));                         \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"bind\");                                    \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xclose(fd)                                                             \\\n\t({                                                                     \\\n\t\tint __ret = close((fd));                                       \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"close\");                                   \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xconnect(fd, addr, len)                                                \\\n\t({                                                                     \\\n\t\tint __ret = connect((fd), (addr), (len));                      \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"connect\");                                 \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xgetsockname(fd, addr, len)                                            \\\n\t({                                                                     \\\n\t\tint __ret = getsockname((fd), (addr), (len));                  \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"getsockname\");                             \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xgetsockopt(fd, level, name, val, len)                                 \\\n\t({                                                                     \\\n\t\tint __ret = getsockopt((fd), (level), (name), (val), (len));   \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"getsockopt(\" #name \")\");                   \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xlisten(fd, backlog)                                                   \\\n\t({                                                                     \\\n\t\tint __ret = listen((fd), (backlog));                           \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"listen\");                                  \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xsetsockopt(fd, level, name, val, len)                                 \\\n\t({                                                                     \\\n\t\tint __ret = setsockopt((fd), (level), (name), (val), (len));   \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"setsockopt(\" #name \")\");                   \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xsend(fd, buf, len, flags)                                             \\\n\t({                                                                     \\\n\t\tssize_t __ret = send((fd), (buf), (len), (flags));             \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"send\");                                    \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xrecv_nonblock(fd, buf, len, flags)                                    \\\n\t({                                                                     \\\n\t\tssize_t __ret = recv_timeout((fd), (buf), (len), (flags),      \\\n\t\t\t\t\t     IO_TIMEOUT_SEC);                  \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"recv\");                                    \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xsocket(family, sotype, flags)                                         \\\n\t({                                                                     \\\n\t\tint __ret = socket(family, sotype, flags);                     \\\n\t\tif (__ret == -1)                                               \\\n\t\t\tFAIL_ERRNO(\"socket\");                                  \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbpf_map_delete_elem(fd, key)                                          \\\n\t({                                                                     \\\n\t\tint __ret = bpf_map_delete_elem((fd), (key));                  \\\n\t\tif (__ret < 0)                                               \\\n\t\t\tFAIL_ERRNO(\"map_delete\");                              \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbpf_map_lookup_elem(fd, key, val)                                     \\\n\t({                                                                     \\\n\t\tint __ret = bpf_map_lookup_elem((fd), (key), (val));           \\\n\t\tif (__ret < 0)                                               \\\n\t\t\tFAIL_ERRNO(\"map_lookup\");                              \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbpf_map_update_elem(fd, key, val, flags)                              \\\n\t({                                                                     \\\n\t\tint __ret = bpf_map_update_elem((fd), (key), (val), (flags));  \\\n\t\tif (__ret < 0)                                               \\\n\t\t\tFAIL_ERRNO(\"map_update\");                              \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbpf_prog_attach(prog, target, type, flags)                            \\\n\t({                                                                     \\\n\t\tint __ret =                                                    \\\n\t\t\tbpf_prog_attach((prog), (target), (type), (flags));    \\\n\t\tif (__ret < 0)                                               \\\n\t\t\tFAIL_ERRNO(\"prog_attach(\" #type \")\");                  \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xbpf_prog_detach2(prog, target, type)                                  \\\n\t({                                                                     \\\n\t\tint __ret = bpf_prog_detach2((prog), (target), (type));        \\\n\t\tif (__ret < 0)                                               \\\n\t\t\tFAIL_ERRNO(\"prog_detach2(\" #type \")\");                 \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xpthread_create(thread, attr, func, arg)                               \\\n\t({                                                                     \\\n\t\tint __ret = pthread_create((thread), (attr), (func), (arg));   \\\n\t\terrno = __ret;                                                 \\\n\t\tif (__ret)                                                     \\\n\t\t\tFAIL_ERRNO(\"pthread_create\");                          \\\n\t\t__ret;                                                         \\\n\t})\n\n#define xpthread_join(thread, retval)                                          \\\n\t({                                                                     \\\n\t\tint __ret = pthread_join((thread), (retval));                  \\\n\t\terrno = __ret;                                                 \\\n\t\tif (__ret)                                                     \\\n\t\t\tFAIL_ERRNO(\"pthread_join\");                            \\\n\t\t__ret;                                                         \\\n\t})\n\nstatic inline int poll_connect(int fd, unsigned int timeout_sec)\n{\n\tstruct timeval timeout = { .tv_sec = timeout_sec };\n\tfd_set wfds;\n\tint r, eval;\n\tsocklen_t esize = sizeof(eval);\n\n\tFD_ZERO(&wfds);\n\tFD_SET(fd, &wfds);\n\n\tr = select(fd + 1, NULL, &wfds, NULL, &timeout);\n\tif (r == 0)\n\t\terrno = ETIME;\n\tif (r != 1)\n\t\treturn -1;\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, &eval, &esize) < 0)\n\t\treturn -1;\n\tif (eval != 0) {\n\t\terrno = eval;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int poll_read(int fd, unsigned int timeout_sec)\n{\n\tstruct timeval timeout = { .tv_sec = timeout_sec };\n\tfd_set rfds;\n\tint r;\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fd, &rfds);\n\n\tr = select(fd + 1, &rfds, NULL, NULL, &timeout);\n\tif (r == 0)\n\t\terrno = ETIME;\n\n\treturn r == 1 ? 0 : -1;\n}\n\nstatic inline int accept_timeout(int fd, struct sockaddr *addr, socklen_t *len,\n\t\t\t\t unsigned int timeout_sec)\n{\n\tif (poll_read(fd, timeout_sec))\n\t\treturn -1;\n\n\treturn accept(fd, addr, len);\n}\n\nstatic inline int recv_timeout(int fd, void *buf, size_t len, int flags,\n\t\t\t       unsigned int timeout_sec)\n{\n\tif (poll_read(fd, timeout_sec))\n\t\treturn -1;\n\n\treturn recv(fd, buf, len, flags);\n}\n\nstatic inline void init_addr_loopback4(struct sockaddr_storage *ss,\n\t\t\t\t       socklen_t *len)\n{\n\tstruct sockaddr_in *addr4 = memset(ss, 0, sizeof(*ss));\n\n\taddr4->sin_family = AF_INET;\n\taddr4->sin_port = 0;\n\taddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t*len = sizeof(*addr4);\n}\n\nstatic inline void init_addr_loopback6(struct sockaddr_storage *ss,\n\t\t\t\t       socklen_t *len)\n{\n\tstruct sockaddr_in6 *addr6 = memset(ss, 0, sizeof(*ss));\n\n\taddr6->sin6_family = AF_INET6;\n\taddr6->sin6_port = 0;\n\taddr6->sin6_addr = in6addr_loopback;\n\t*len = sizeof(*addr6);\n}\n\nstatic inline void init_addr_loopback_vsock(struct sockaddr_storage *ss,\n\t\t\t\t\t    socklen_t *len)\n{\n\tstruct sockaddr_vm *addr = memset(ss, 0, sizeof(*ss));\n\n\taddr->svm_family = AF_VSOCK;\n\taddr->svm_port = VMADDR_PORT_ANY;\n\taddr->svm_cid = VMADDR_CID_LOCAL;\n\t*len = sizeof(*addr);\n}\n\nstatic inline void init_addr_loopback(int family, struct sockaddr_storage *ss,\n\t\t\t\t      socklen_t *len)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\tinit_addr_loopback4(ss, len);\n\t\treturn;\n\tcase AF_INET6:\n\t\tinit_addr_loopback6(ss, len);\n\t\treturn;\n\tcase AF_VSOCK:\n\t\tinit_addr_loopback_vsock(ss, len);\n\t\treturn;\n\tdefault:\n\t\tFAIL(\"unsupported address family %d\", family);\n\t}\n}\n\nstatic inline struct sockaddr *sockaddr(struct sockaddr_storage *ss)\n{\n\treturn (struct sockaddr *)ss;\n}\n\nstatic inline int add_to_sockmap(int sock_mapfd, int fd1, int fd2)\n{\n\tu64 value;\n\tu32 key;\n\tint err;\n\n\tkey = 0;\n\tvalue = fd1;\n\terr = xbpf_map_update_elem(sock_mapfd, &key, &value, BPF_NOEXIST);\n\tif (err)\n\t\treturn err;\n\n\tkey = 1;\n\tvalue = fd2;\n\treturn xbpf_map_update_elem(sock_mapfd, &key, &value, BPF_NOEXIST);\n}\n\nstatic inline int create_pair(int s, int family, int sotype, int *c, int *p)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tint err = 0;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\treturn err;\n\n\t*c = xsocket(family, sotype, 0);\n\tif (*c < 0)\n\t\treturn errno;\n\terr = xconnect(*c, sockaddr(&addr), len);\n\tif (err) {\n\t\terr = errno;\n\t\tgoto close_cli0;\n\t}\n\n\t*p = xaccept_nonblock(s, NULL, NULL);\n\tif (*p < 0) {\n\t\terr = errno;\n\t\tgoto close_cli0;\n\t}\n\treturn err;\nclose_cli0:\n\tclose(*c);\n\treturn err;\n}\n\nstatic inline int create_socket_pairs(int s, int family, int sotype,\n\t\t\t\t      int *c0, int *c1, int *p0, int *p1)\n{\n\tint err;\n\n\terr = create_pair(s, family, sotype, c0, p0);\n\tif (err)\n\t\treturn err;\n\n\terr = create_pair(s, family, sotype, c1, p1);\n\tif (err) {\n\t\tclose(*c0);\n\t\tclose(*p0);\n\t}\n\treturn err;\n}\n\nstatic inline int enable_reuseport(int s, int progfd)\n{\n\tint err, one = 1;\n\n\terr = xsetsockopt(s, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one));\n\tif (err)\n\t\treturn -1;\n\terr = xsetsockopt(s, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF, &progfd,\n\t\t\t  sizeof(progfd));\n\tif (err)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic inline int socket_loopback_reuseport(int family, int sotype, int progfd)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tint err, s;\n\n\tinit_addr_loopback(family, &addr, &len);\n\n\ts = xsocket(family, sotype, 0);\n\tif (s == -1)\n\t\treturn -1;\n\n\tif (progfd >= 0)\n\t\tenable_reuseport(s, progfd);\n\n\terr = xbind(s, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close;\n\n\tif (sotype & SOCK_DGRAM)\n\t\treturn s;\n\n\terr = xlisten(s, SOMAXCONN);\n\tif (err)\n\t\tgoto close;\n\n\treturn s;\nclose:\n\txclose(s);\n\treturn -1;\n}\n\nstatic inline int socket_loopback(int family, int sotype)\n{\n\treturn socket_loopback_reuseport(family, sotype, -1);\n}\n\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}