{
  "module_name": "sockmap_basic.c",
  "hash_id": "004faccc0f33cd9a897a4a17ae810b4e5566318fc3dcf5637acc3bd1152bfc43",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sockmap_basic.c",
  "human_readable_source": "\n\n#include <error.h>\n#include <netinet/tcp.h>\n#include <sys/epoll.h>\n\n#include \"test_progs.h\"\n#include \"test_skmsg_load_helpers.skel.h\"\n#include \"test_sockmap_update.skel.h\"\n#include \"test_sockmap_invalid_update.skel.h\"\n#include \"test_sockmap_skb_verdict_attach.skel.h\"\n#include \"test_sockmap_progs_query.skel.h\"\n#include \"test_sockmap_pass_prog.skel.h\"\n#include \"test_sockmap_drop_prog.skel.h\"\n#include \"bpf_iter_sockmap.skel.h\"\n\n#include \"sockmap_helpers.h\"\n\n#define TCP_REPAIR\t\t19\t \n\n#define TCP_REPAIR_ON\t\t1\n#define TCP_REPAIR_OFF_NO_WP\t-1\t \n\nstatic int connected_socket_v4(void)\n{\n\tstruct sockaddr_in addr = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_port = htons(80),\n\t\t.sin_addr = { inet_addr(\"127.0.0.1\") },\n\t};\n\tsocklen_t len = sizeof(addr);\n\tint s, repair, err;\n\n\ts = socket(AF_INET, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(s, 0, \"socket\"))\n\t\tgoto error;\n\n\trepair = TCP_REPAIR_ON;\n\terr = setsockopt(s, SOL_TCP, TCP_REPAIR, &repair, sizeof(repair));\n\tif (!ASSERT_OK(err, \"setsockopt(TCP_REPAIR)\"))\n\t\tgoto error;\n\n\terr = connect(s, (struct sockaddr *)&addr, len);\n\tif (!ASSERT_OK(err, \"connect\"))\n\t\tgoto error;\n\n\trepair = TCP_REPAIR_OFF_NO_WP;\n\terr = setsockopt(s, SOL_TCP, TCP_REPAIR, &repair, sizeof(repair));\n\tif (!ASSERT_OK(err, \"setsockopt(TCP_REPAIR)\"))\n\t\tgoto error;\n\n\treturn s;\nerror:\n\tperror(__func__);\n\tclose(s);\n\treturn -1;\n}\n\nstatic void compare_cookies(struct bpf_map *src, struct bpf_map *dst)\n{\n\t__u32 i, max_entries = bpf_map__max_entries(src);\n\tint err, src_fd, dst_fd;\n\n\tsrc_fd = bpf_map__fd(src);\n\tdst_fd = bpf_map__fd(dst);\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\t__u64 src_cookie, dst_cookie;\n\n\t\terr = bpf_map_lookup_elem(src_fd, &i, &src_cookie);\n\t\tif (err && errno == ENOENT) {\n\t\t\terr = bpf_map_lookup_elem(dst_fd, &i, &dst_cookie);\n\t\t\tASSERT_ERR(err, \"map_lookup_elem(dst)\");\n\t\t\tASSERT_EQ(errno, ENOENT, \"map_lookup_elem(dst)\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ASSERT_OK(err, \"lookup_elem(src)\"))\n\t\t\tcontinue;\n\n\t\terr = bpf_map_lookup_elem(dst_fd, &i, &dst_cookie);\n\t\tif (!ASSERT_OK(err, \"lookup_elem(dst)\"))\n\t\t\tcontinue;\n\n\t\tASSERT_EQ(dst_cookie, src_cookie, \"cookie mismatch\");\n\t}\n}\n\n \nstatic void test_sockmap_create_update_free(enum bpf_map_type map_type)\n{\n\tconst int zero = 0;\n\tint s, map, err;\n\n\ts = connected_socket_v4();\n\tif (!ASSERT_GE(s, 0, \"connected_socket_v4\"))\n\t\treturn;\n\n\tmap = bpf_map_create(map_type, NULL, sizeof(int), sizeof(int), 1, NULL);\n\tif (!ASSERT_GE(map, 0, \"bpf_map_create\"))\n\t\tgoto out;\n\n\terr = bpf_map_update_elem(map, &zero, &s, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"bpf_map_update\"))\n\t\tgoto out;\n\nout:\n\tclose(map);\n\tclose(s);\n}\n\nstatic void test_skmsg_helpers(enum bpf_map_type map_type)\n{\n\tstruct test_skmsg_load_helpers *skel;\n\tint err, map, verdict;\n\n\tskel = test_skmsg_load_helpers__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_skmsg_load_helpers__open_and_load\"))\n\t\treturn;\n\n\tverdict = bpf_program__fd(skel->progs.prog_msg_verdict);\n\tmap = bpf_map__fd(skel->maps.sock_map);\n\n\terr = bpf_prog_attach(verdict, map, BPF_SK_MSG_VERDICT, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\terr = bpf_prog_detach2(verdict, map, BPF_SK_MSG_VERDICT);\n\tif (!ASSERT_OK(err, \"bpf_prog_detach2\"))\n\t\tgoto out;\nout:\n\ttest_skmsg_load_helpers__destroy(skel);\n}\n\nstatic void test_sockmap_update(enum bpf_map_type map_type)\n{\n\tint err, prog, src;\n\tstruct test_sockmap_update *skel;\n\tstruct bpf_map *dst_map;\n\tconst __u32 zero = 0;\n\tchar dummy[14] = {0};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = dummy,\n\t\t.data_size_in = sizeof(dummy),\n\t\t.repeat = 1,\n\t);\n\t__s64 sk;\n\n\tsk = connected_socket_v4();\n\tif (!ASSERT_NEQ(sk, -1, \"connected_socket_v4\"))\n\t\treturn;\n\n\tskel = test_sockmap_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\tgoto close_sk;\n\n\tprog = bpf_program__fd(skel->progs.copy_sock_map);\n\tsrc = bpf_map__fd(skel->maps.src);\n\tif (map_type == BPF_MAP_TYPE_SOCKMAP)\n\t\tdst_map = skel->maps.dst_sock_map;\n\telse\n\t\tdst_map = skel->maps.dst_sock_hash;\n\n\terr = bpf_map_update_elem(src, &zero, &sk, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"update_elem(src)\"))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(prog, &topts);\n\tif (!ASSERT_OK(err, \"test_run\"))\n\t\tgoto out;\n\tif (!ASSERT_NEQ(topts.retval, 0, \"test_run retval\"))\n\t\tgoto out;\n\n\tcompare_cookies(skel->maps.src, dst_map);\n\nout:\n\ttest_sockmap_update__destroy(skel);\nclose_sk:\n\tclose(sk);\n}\n\nstatic void test_sockmap_invalid_update(void)\n{\n\tstruct test_sockmap_invalid_update *skel;\n\n\tskel = test_sockmap_invalid_update__open_and_load();\n\tif (!ASSERT_NULL(skel, \"open_and_load\"))\n\t\ttest_sockmap_invalid_update__destroy(skel);\n}\n\nstatic void test_sockmap_copy(enum bpf_map_type map_type)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tint err, len, src_fd, iter_fd;\n\tunion bpf_iter_link_info linfo = {};\n\t__u32 i, num_sockets, num_elems;\n\tstruct bpf_iter_sockmap *skel;\n\t__s64 *sock_fd = NULL;\n\tstruct bpf_link *link;\n\tstruct bpf_map *src;\n\tchar buf[64];\n\n\tskel = bpf_iter_sockmap__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_sockmap__open_and_load\"))\n\t\treturn;\n\n\tif (map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\tsrc = skel->maps.sockmap;\n\t\tnum_elems = bpf_map__max_entries(src);\n\t\tnum_sockets = num_elems - 1;\n\t} else {\n\t\tsrc = skel->maps.sockhash;\n\t\tnum_elems = bpf_map__max_entries(src) - 1;\n\t\tnum_sockets = num_elems;\n\t}\n\n\tsock_fd = calloc(num_sockets, sizeof(*sock_fd));\n\tif (!ASSERT_OK_PTR(sock_fd, \"calloc(sock_fd)\"))\n\t\tgoto out;\n\n\tfor (i = 0; i < num_sockets; i++)\n\t\tsock_fd[i] = -1;\n\n\tsrc_fd = bpf_map__fd(src);\n\n\tfor (i = 0; i < num_sockets; i++) {\n\t\tsock_fd[i] = connected_socket_v4();\n\t\tif (!ASSERT_NEQ(sock_fd[i], -1, \"connected_socket_v4\"))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(src_fd, &i, &sock_fd[i], BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tlinfo.map.map_fd = src_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.copy, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (!ASSERT_GE(len, 0, \"read\"))\n\t\tgoto close_iter;\n\n\t \n\tif (!ASSERT_EQ(skel->bss->elems, num_elems, \"elems\"))\n\t\tgoto close_iter;\n\n\tif (!ASSERT_EQ(skel->bss->socks, num_sockets, \"socks\"))\n\t\tgoto close_iter;\n\n\tcompare_cookies(src, skel->maps.dst);\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tfor (i = 0; sock_fd && i < num_sockets; i++)\n\t\tif (sock_fd[i] >= 0)\n\t\t\tclose(sock_fd[i]);\n\tif (sock_fd)\n\t\tfree(sock_fd);\n\tbpf_iter_sockmap__destroy(skel);\n}\n\nstatic void test_sockmap_skb_verdict_attach(enum bpf_attach_type first,\n\t\t\t\t\t    enum bpf_attach_type second)\n{\n\tstruct test_sockmap_skb_verdict_attach *skel;\n\tint err, map, verdict;\n\n\tskel = test_sockmap_skb_verdict_attach__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\tverdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tmap = bpf_map__fd(skel->maps.sock_map);\n\n\terr = bpf_prog_attach(verdict, map, first, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\terr = bpf_prog_attach(verdict, map, second, 0);\n\tASSERT_EQ(err, -EBUSY, \"prog_attach_fail\");\n\n\terr = bpf_prog_detach2(verdict, map, first);\n\tif (!ASSERT_OK(err, \"bpf_prog_detach2\"))\n\t\tgoto out;\nout:\n\ttest_sockmap_skb_verdict_attach__destroy(skel);\n}\n\nstatic __u32 query_prog_id(int prog_fd)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (!ASSERT_OK(err, \"bpf_prog_get_info_by_fd\") ||\n\t    !ASSERT_EQ(info_len, sizeof(info), \"bpf_prog_get_info_by_fd\"))\n\t\treturn 0;\n\n\treturn info.id;\n}\n\nstatic void test_sockmap_progs_query(enum bpf_attach_type attach_type)\n{\n\tstruct test_sockmap_progs_query *skel;\n\tint err, map_fd, verdict_fd;\n\t__u32 attach_flags = 0;\n\t__u32 prog_ids[3] = {};\n\t__u32 prog_cnt = 3;\n\n\tskel = test_sockmap_progs_query__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_sockmap_progs_query__open_and_load\"))\n\t\treturn;\n\n\tmap_fd = bpf_map__fd(skel->maps.sock_map);\n\n\tif (attach_type == BPF_SK_MSG_VERDICT)\n\t\tverdict_fd = bpf_program__fd(skel->progs.prog_skmsg_verdict);\n\telse\n\t\tverdict_fd = bpf_program__fd(skel->progs.prog_skb_verdict);\n\n\terr = bpf_prog_query(map_fd, attach_type, 0  ,\n\t\t\t     &attach_flags, prog_ids, &prog_cnt);\n\tASSERT_OK(err, \"bpf_prog_query failed\");\n\tASSERT_EQ(attach_flags,  0, \"wrong attach_flags on query\");\n\tASSERT_EQ(prog_cnt, 0, \"wrong program count on query\");\n\n\terr = bpf_prog_attach(verdict_fd, map_fd, attach_type, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach failed\"))\n\t\tgoto out;\n\n\tprog_cnt = 1;\n\terr = bpf_prog_query(map_fd, attach_type, 0  ,\n\t\t\t     &attach_flags, prog_ids, &prog_cnt);\n\tASSERT_OK(err, \"bpf_prog_query failed\");\n\tASSERT_EQ(attach_flags, 0, \"wrong attach_flags on query\");\n\tASSERT_EQ(prog_cnt, 1, \"wrong program count on query\");\n\tASSERT_EQ(prog_ids[0], query_prog_id(verdict_fd),\n\t\t  \"wrong prog_ids on query\");\n\n\tbpf_prog_detach2(verdict_fd, map_fd, attach_type);\nout:\n\ttest_sockmap_progs_query__destroy(skel);\n}\n\n#define MAX_EVENTS 10\nstatic void test_sockmap_skb_verdict_shutdown(void)\n{\n\tstruct epoll_event ev, events[MAX_EVENTS];\n\tint n, err, map, verdict, s, c1, p1;\n\tstruct test_sockmap_pass_prog *skel;\n\tint epollfd;\n\tint zero = 0;\n\tchar b;\n\n\tskel = test_sockmap_pass_prog__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\tverdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tmap = bpf_map__fd(skel->maps.sock_map_rx);\n\n\terr = bpf_prog_attach(verdict, map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\ts = socket_loopback(AF_INET, SOCK_STREAM);\n\tif (s < 0)\n\t\tgoto out;\n\terr = create_pair(s, AF_INET, SOCK_STREAM, &c1, &p1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = bpf_map_update_elem(map, &zero, &c1, BPF_NOEXIST);\n\tif (err < 0)\n\t\tgoto out_close;\n\n\tshutdown(p1, SHUT_WR);\n\n\tev.events = EPOLLIN;\n\tev.data.fd = c1;\n\n\tepollfd = epoll_create1(0);\n\tif (!ASSERT_GT(epollfd, -1, \"epoll_create(0)\"))\n\t\tgoto out_close;\n\terr = epoll_ctl(epollfd, EPOLL_CTL_ADD, c1, &ev);\n\tif (!ASSERT_OK(err, \"epoll_ctl(EPOLL_CTL_ADD)\"))\n\t\tgoto out_close;\n\terr = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n\tif (!ASSERT_EQ(err, 1, \"epoll_wait(fd)\"))\n\t\tgoto out_close;\n\n\tn = recv(c1, &b, 1, SOCK_NONBLOCK);\n\tASSERT_EQ(n, 0, \"recv_timeout(fin)\");\nout_close:\n\tclose(c1);\n\tclose(p1);\nout:\n\ttest_sockmap_pass_prog__destroy(skel);\n}\n\nstatic void test_sockmap_skb_verdict_fionread(bool pass_prog)\n{\n\tint expected, zero = 0, sent, recvd, avail;\n\tint err, map, verdict, s, c0, c1, p0, p1;\n\tstruct test_sockmap_pass_prog *pass;\n\tstruct test_sockmap_drop_prog *drop;\n\tchar buf[256] = \"0123456789\";\n\n\tif (pass_prog) {\n\t\tpass = test_sockmap_pass_prog__open_and_load();\n\t\tif (!ASSERT_OK_PTR(pass, \"open_and_load\"))\n\t\t\treturn;\n\t\tverdict = bpf_program__fd(pass->progs.prog_skb_verdict);\n\t\tmap = bpf_map__fd(pass->maps.sock_map_rx);\n\t\texpected = sizeof(buf);\n\t} else {\n\t\tdrop = test_sockmap_drop_prog__open_and_load();\n\t\tif (!ASSERT_OK_PTR(drop, \"open_and_load\"))\n\t\t\treturn;\n\t\tverdict = bpf_program__fd(drop->progs.prog_skb_verdict);\n\t\tmap = bpf_map__fd(drop->maps.sock_map_rx);\n\t\t \n\t\texpected = 0;\n\t}\n\n\n\terr = bpf_prog_attach(verdict, map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\ts = socket_loopback(AF_INET, SOCK_STREAM);\n\tif (!ASSERT_GT(s, -1, \"socket_loopback(s)\"))\n\t\tgoto out;\n\terr = create_socket_pairs(s, AF_INET, SOCK_STREAM, &c0, &c1, &p0, &p1);\n\tif (!ASSERT_OK(err, \"create_socket_pairs(s)\"))\n\t\tgoto out;\n\n\terr = bpf_map_update_elem(map, &zero, &c1, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"bpf_map_update_elem(c1)\"))\n\t\tgoto out_close;\n\n\tsent = xsend(p1, &buf, sizeof(buf), 0);\n\tASSERT_EQ(sent, sizeof(buf), \"xsend(p0)\");\n\terr = ioctl(c1, FIONREAD, &avail);\n\tASSERT_OK(err, \"ioctl(FIONREAD) error\");\n\tASSERT_EQ(avail, expected, \"ioctl(FIONREAD)\");\n\t \n\tif (pass_prog) {\n\t\trecvd = recv_timeout(c1, &buf, sizeof(buf), SOCK_NONBLOCK, IO_TIMEOUT_SEC);\n\t\tASSERT_EQ(recvd, sizeof(buf), \"recv_timeout(c0)\");\n\t}\n\nout_close:\n\tclose(c0);\n\tclose(p0);\n\tclose(c1);\n\tclose(p1);\nout:\n\tif (pass_prog)\n\t\ttest_sockmap_pass_prog__destroy(pass);\n\telse\n\t\ttest_sockmap_drop_prog__destroy(drop);\n}\n\nstatic void test_sockmap_skb_verdict_peek(void)\n{\n\tint err, map, verdict, s, c1, p1, zero = 0, sent, recvd, avail;\n\tstruct test_sockmap_pass_prog *pass;\n\tchar snd[256] = \"0123456789\";\n\tchar rcv[256] = \"0\";\n\n\tpass = test_sockmap_pass_prog__open_and_load();\n\tif (!ASSERT_OK_PTR(pass, \"open_and_load\"))\n\t\treturn;\n\tverdict = bpf_program__fd(pass->progs.prog_skb_verdict);\n\tmap = bpf_map__fd(pass->maps.sock_map_rx);\n\n\terr = bpf_prog_attach(verdict, map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\ts = socket_loopback(AF_INET, SOCK_STREAM);\n\tif (!ASSERT_GT(s, -1, \"socket_loopback(s)\"))\n\t\tgoto out;\n\n\terr = create_pair(s, AF_INET, SOCK_STREAM, &c1, &p1);\n\tif (!ASSERT_OK(err, \"create_pairs(s)\"))\n\t\tgoto out;\n\n\terr = bpf_map_update_elem(map, &zero, &c1, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"bpf_map_update_elem(c1)\"))\n\t\tgoto out_close;\n\n\tsent = xsend(p1, snd, sizeof(snd), 0);\n\tASSERT_EQ(sent, sizeof(snd), \"xsend(p1)\");\n\trecvd = recv(c1, rcv, sizeof(rcv), MSG_PEEK);\n\tASSERT_EQ(recvd, sizeof(rcv), \"recv(c1)\");\n\terr = ioctl(c1, FIONREAD, &avail);\n\tASSERT_OK(err, \"ioctl(FIONREAD) error\");\n\tASSERT_EQ(avail, sizeof(snd), \"after peek ioctl(FIONREAD)\");\n\trecvd = recv(c1, rcv, sizeof(rcv), 0);\n\tASSERT_EQ(recvd, sizeof(rcv), \"recv(p0)\");\n\terr = ioctl(c1, FIONREAD, &avail);\n\tASSERT_OK(err, \"ioctl(FIONREAD) error\");\n\tASSERT_EQ(avail, 0, \"after read ioctl(FIONREAD)\");\n\nout_close:\n\tclose(c1);\n\tclose(p1);\nout:\n\ttest_sockmap_pass_prog__destroy(pass);\n}\n\nvoid test_sockmap_basic(void)\n{\n\tif (test__start_subtest(\"sockmap create_update_free\"))\n\t\ttest_sockmap_create_update_free(BPF_MAP_TYPE_SOCKMAP);\n\tif (test__start_subtest(\"sockhash create_update_free\"))\n\t\ttest_sockmap_create_update_free(BPF_MAP_TYPE_SOCKHASH);\n\tif (test__start_subtest(\"sockmap sk_msg load helpers\"))\n\t\ttest_skmsg_helpers(BPF_MAP_TYPE_SOCKMAP);\n\tif (test__start_subtest(\"sockhash sk_msg load helpers\"))\n\t\ttest_skmsg_helpers(BPF_MAP_TYPE_SOCKHASH);\n\tif (test__start_subtest(\"sockmap update\"))\n\t\ttest_sockmap_update(BPF_MAP_TYPE_SOCKMAP);\n\tif (test__start_subtest(\"sockhash update\"))\n\t\ttest_sockmap_update(BPF_MAP_TYPE_SOCKHASH);\n\tif (test__start_subtest(\"sockmap update in unsafe context\"))\n\t\ttest_sockmap_invalid_update();\n\tif (test__start_subtest(\"sockmap copy\"))\n\t\ttest_sockmap_copy(BPF_MAP_TYPE_SOCKMAP);\n\tif (test__start_subtest(\"sockhash copy\"))\n\t\ttest_sockmap_copy(BPF_MAP_TYPE_SOCKHASH);\n\tif (test__start_subtest(\"sockmap skb_verdict attach\")) {\n\t\ttest_sockmap_skb_verdict_attach(BPF_SK_SKB_VERDICT,\n\t\t\t\t\t\tBPF_SK_SKB_STREAM_VERDICT);\n\t\ttest_sockmap_skb_verdict_attach(BPF_SK_SKB_STREAM_VERDICT,\n\t\t\t\t\t\tBPF_SK_SKB_VERDICT);\n\t}\n\tif (test__start_subtest(\"sockmap msg_verdict progs query\"))\n\t\ttest_sockmap_progs_query(BPF_SK_MSG_VERDICT);\n\tif (test__start_subtest(\"sockmap stream_parser progs query\"))\n\t\ttest_sockmap_progs_query(BPF_SK_SKB_STREAM_PARSER);\n\tif (test__start_subtest(\"sockmap stream_verdict progs query\"))\n\t\ttest_sockmap_progs_query(BPF_SK_SKB_STREAM_VERDICT);\n\tif (test__start_subtest(\"sockmap skb_verdict progs query\"))\n\t\ttest_sockmap_progs_query(BPF_SK_SKB_VERDICT);\n\tif (test__start_subtest(\"sockmap skb_verdict shutdown\"))\n\t\ttest_sockmap_skb_verdict_shutdown();\n\tif (test__start_subtest(\"sockmap skb_verdict fionread\"))\n\t\ttest_sockmap_skb_verdict_fionread(true);\n\tif (test__start_subtest(\"sockmap skb_verdict fionread on drop\"))\n\t\ttest_sockmap_skb_verdict_fionread(false);\n\tif (test__start_subtest(\"sockmap skb_verdict msg_f_peek\"))\n\t\ttest_sockmap_skb_verdict_peek();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}