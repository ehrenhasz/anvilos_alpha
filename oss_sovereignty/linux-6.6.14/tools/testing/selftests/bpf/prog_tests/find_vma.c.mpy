{
  "module_name": "find_vma.c",
  "hash_id": "6cf35d6d97cbd8c4a02398c0671adcb8411d86b4689eda4777a9780bad273fd9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/find_vma.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"find_vma.skel.h\"\n#include \"find_vma_fail1.skel.h\"\n#include \"find_vma_fail2.skel.h\"\n\nstatic void test_and_reset_skel(struct find_vma *skel, int expected_find_zero_ret, bool need_test)\n{\n\tif (need_test) {\n\t\tASSERT_EQ(skel->bss->found_vm_exec, 1, \"found_vm_exec\");\n\t\tASSERT_EQ(skel->data->find_addr_ret, 0, \"find_addr_ret\");\n\t\tASSERT_EQ(skel->data->find_zero_ret, expected_find_zero_ret, \"find_zero_ret\");\n\t\tASSERT_OK_PTR(strstr(skel->bss->d_iname, \"test_progs\"), \"find_test_progs\");\n\t}\n\n\tskel->bss->found_vm_exec = 0;\n\tskel->data->find_addr_ret = -1;\n\tskel->data->find_zero_ret = -1;\n\tskel->bss->d_iname[0] = 0;\n}\n\nstatic int open_pe(void)\n{\n\tstruct perf_event_attr attr = {0};\n\tint pfd;\n\n\t \n\tattr.size = sizeof(attr);\n\tattr.type = PERF_TYPE_HARDWARE;\n\tattr.config = PERF_COUNT_HW_CPU_CYCLES;\n\tattr.freq = 1;\n\tattr.sample_freq = 1000;\n\tpfd = syscall(__NR_perf_event_open, &attr, 0, -1, -1, PERF_FLAG_FD_CLOEXEC);\n\n\treturn pfd >= 0 ? pfd : -errno;\n}\n\nstatic bool find_vma_pe_condition(struct find_vma *skel)\n{\n\treturn skel->bss->found_vm_exec == 0 ||\n\t\tskel->data->find_addr_ret != 0 ||\n\t\tskel->data->find_zero_ret == -1 ||\n\t\tstrcmp(skel->bss->d_iname, \"test_progs\") != 0;\n}\n\nstatic void test_find_vma_pe(struct find_vma *skel)\n{\n\tstruct bpf_link *link = NULL;\n\tvolatile int j = 0;\n\tint pfd, i;\n\tconst int one_bn = 1000000000;\n\n\tpfd = open_pe();\n\tif (pfd < 0) {\n\t\tif (pfd == -ENOENT || pfd == -EOPNOTSUPP) {\n\t\t\tprintf(\"%s:SKIP:no PERF_COUNT_HW_CPU_CYCLES\\n\", __func__);\n\t\t\ttest__skip();\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!ASSERT_GE(pfd, 0, \"perf_event_open\"))\n\t\t\tgoto cleanup;\n\t}\n\n\tlink = bpf_program__attach_perf_event(skel->progs.handle_pe, pfd);\n\tif (!ASSERT_OK_PTR(link, \"attach_perf_event\"))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < one_bn && find_vma_pe_condition(skel); ++i)\n\t\t++j;\n\n\ttest_and_reset_skel(skel, -EBUSY  , i == one_bn);\ncleanup:\n\tbpf_link__destroy(link);\n\tclose(pfd);\n}\n\nstatic void test_find_vma_kprobe(struct find_vma *skel)\n{\n\tint err;\n\n\terr = find_vma__attach(skel);\n\tif (!ASSERT_OK(err, \"get_branch_snapshot__attach\"))\n\t\treturn;\n\n\tgetpgid(skel->bss->target_pid);\n\ttest_and_reset_skel(skel, -ENOENT  , true);\n}\n\nstatic void test_illegal_write_vma(void)\n{\n\tstruct find_vma_fail1 *skel;\n\n\tskel = find_vma_fail1__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"find_vma_fail1__open_and_load\"))\n\t\tfind_vma_fail1__destroy(skel);\n}\n\nstatic void test_illegal_write_task(void)\n{\n\tstruct find_vma_fail2 *skel;\n\n\tskel = find_vma_fail2__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"find_vma_fail2__open_and_load\"))\n\t\tfind_vma_fail2__destroy(skel);\n}\n\nvoid serial_test_find_vma(void)\n{\n\tstruct find_vma *skel;\n\n\tskel = find_vma__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"find_vma__open_and_load\"))\n\t\treturn;\n\n\tskel->bss->target_pid = getpid();\n\tskel->bss->addr = (__u64)(uintptr_t)test_find_vma_pe;\n\n\ttest_find_vma_pe(skel);\n\ttest_find_vma_kprobe(skel);\n\n\tfind_vma__destroy(skel);\n\ttest_illegal_write_vma();\n\ttest_illegal_write_task();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}