{
  "module_name": "xdp_bonding.c",
  "hash_id": "9d8930605b221e5a1c58c7a72cabfe85608eb877f106c1753f8281751f125813",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_bonding.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <sched.h>\n#include <net/if.h>\n#include <linux/if_link.h>\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n#include <linux/if_bonding.h>\n#include <linux/limits.h>\n#include <linux/udp.h>\n#include <uapi/linux/netdev.h>\n\n#include \"xdp_dummy.skel.h\"\n#include \"xdp_redirect_multi_kern.skel.h\"\n#include \"xdp_tx.skel.h\"\n\n#define BOND1_MAC {0x00, 0x11, 0x22, 0x33, 0x44, 0x55}\n#define BOND1_MAC_STR \"00:11:22:33:44:55\"\n#define BOND2_MAC {0x00, 0x22, 0x33, 0x44, 0x55, 0x66}\n#define BOND2_MAC_STR \"00:22:33:44:55:66\"\n#define NPACKETS 100\n\nstatic int root_netns_fd = -1;\n\nstatic void restore_root_netns(void)\n{\n\tASSERT_OK(setns(root_netns_fd, CLONE_NEWNET), \"restore_root_netns\");\n}\n\nstatic int setns_by_name(char *name)\n{\n\tint nsfd, err;\n\tchar nspath[PATH_MAX];\n\n\tsnprintf(nspath, sizeof(nspath), \"%s/%s\", \"/var/run/netns\", name);\n\tnsfd = open(nspath, O_RDONLY | O_CLOEXEC);\n\tif (nsfd < 0)\n\t\treturn -1;\n\n\terr = setns(nsfd, CLONE_NEWNET);\n\tclose(nsfd);\n\treturn err;\n}\n\nstatic int get_rx_packets(const char *iface)\n{\n\tFILE *f;\n\tchar line[512];\n\tint iface_len = strlen(iface);\n\n\tf = fopen(\"/proc/net/dev\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (fgets(line, sizeof(line), f)) {\n\t\tchar *p = line;\n\n\t\twhile (*p == ' ')\n\t\t\tp++;  \n\t\tif (!strncmp(p, iface, iface_len)) {\n\t\t\tp += iface_len;\n\t\t\tif (*p++ != ':')\n\t\t\t\tcontinue;\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;  \n\t\t\twhile (*p && *p != ' ')\n\t\t\t\tp++;  \n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;  \n\t\t\tfclose(f);\n\t\t\treturn atoi(p);\n\t\t}\n\t}\n\tfclose(f);\n\treturn -1;\n}\n\n#define MAX_BPF_LINKS 8\n\nstruct skeletons {\n\tstruct xdp_dummy *xdp_dummy;\n\tstruct xdp_tx *xdp_tx;\n\tstruct xdp_redirect_multi_kern *xdp_redirect_multi_kern;\n\n\tint nlinks;\n\tstruct bpf_link *links[MAX_BPF_LINKS];\n};\n\nstatic int xdp_attach(struct skeletons *skeletons, struct bpf_program *prog, char *iface)\n{\n\tstruct bpf_link *link;\n\tint ifindex;\n\n\tifindex = if_nametoindex(iface);\n\tif (!ASSERT_GT(ifindex, 0, \"get ifindex\"))\n\t\treturn -1;\n\n\tif (!ASSERT_LE(skeletons->nlinks+1, MAX_BPF_LINKS, \"too many XDP programs attached\"))\n\t\treturn -1;\n\n\tlink = bpf_program__attach_xdp(prog, ifindex);\n\tif (!ASSERT_OK_PTR(link, \"attach xdp program\"))\n\t\treturn -1;\n\n\tskeletons->links[skeletons->nlinks++] = link;\n\treturn 0;\n}\n\nenum {\n\tBOND_ONE_NO_ATTACH = 0,\n\tBOND_BOTH_AND_ATTACH,\n};\n\nstatic const char * const mode_names[] = {\n\t[BOND_MODE_ROUNDROBIN]   = \"balance-rr\",\n\t[BOND_MODE_ACTIVEBACKUP] = \"active-backup\",\n\t[BOND_MODE_XOR]          = \"balance-xor\",\n\t[BOND_MODE_BROADCAST]    = \"broadcast\",\n\t[BOND_MODE_8023AD]       = \"802.3ad\",\n\t[BOND_MODE_TLB]          = \"balance-tlb\",\n\t[BOND_MODE_ALB]          = \"balance-alb\",\n};\n\nstatic const char * const xmit_policy_names[] = {\n\t[BOND_XMIT_POLICY_LAYER2]       = \"layer2\",\n\t[BOND_XMIT_POLICY_LAYER34]      = \"layer3+4\",\n\t[BOND_XMIT_POLICY_LAYER23]      = \"layer2+3\",\n\t[BOND_XMIT_POLICY_ENCAP23]      = \"encap2+3\",\n\t[BOND_XMIT_POLICY_ENCAP34]      = \"encap3+4\",\n};\n\nstatic int bonding_setup(struct skeletons *skeletons, int mode, int xmit_policy,\n\t\t\t int bond_both_attach)\n{\n\tSYS(fail, \"ip netns add ns_dst\");\n\tSYS(fail, \"ip link add veth1_1 type veth peer name veth2_1 netns ns_dst\");\n\tSYS(fail, \"ip link add veth1_2 type veth peer name veth2_2 netns ns_dst\");\n\n\tSYS(fail, \"ip link add bond1 type bond mode %s xmit_hash_policy %s\",\n\t    mode_names[mode], xmit_policy_names[xmit_policy]);\n\tSYS(fail, \"ip link set bond1 up address \" BOND1_MAC_STR \" addrgenmode none\");\n\tSYS(fail, \"ip -netns ns_dst link add bond2 type bond mode %s xmit_hash_policy %s\",\n\t    mode_names[mode], xmit_policy_names[xmit_policy]);\n\tSYS(fail, \"ip -netns ns_dst link set bond2 up address \" BOND2_MAC_STR \" addrgenmode none\");\n\n\tSYS(fail, \"ip link set veth1_1 master bond1\");\n\tif (bond_both_attach == BOND_BOTH_AND_ATTACH) {\n\t\tSYS(fail, \"ip link set veth1_2 master bond1\");\n\t} else {\n\t\tSYS(fail, \"ip link set veth1_2 up addrgenmode none\");\n\n\t\tif (xdp_attach(skeletons, skeletons->xdp_dummy->progs.xdp_dummy_prog, \"veth1_2\"))\n\t\t\treturn -1;\n\t}\n\n\tSYS(fail, \"ip -netns ns_dst link set veth2_1 master bond2\");\n\n\tif (bond_both_attach == BOND_BOTH_AND_ATTACH)\n\t\tSYS(fail, \"ip -netns ns_dst link set veth2_2 master bond2\");\n\telse\n\t\tSYS(fail, \"ip -netns ns_dst link set veth2_2 up addrgenmode none\");\n\n\t \n\tif (xdp_attach(skeletons, skeletons->xdp_dummy->progs.xdp_dummy_prog, \"bond1\"))\n\t\treturn -1;\n\n\tif (bond_both_attach == BOND_BOTH_AND_ATTACH) {\n\t\tif (!ASSERT_OK(setns_by_name(\"ns_dst\"), \"set netns to ns_dst\"))\n\t\t\treturn -1;\n\n\t\tif (xdp_attach(skeletons, skeletons->xdp_tx->progs.xdp_tx, \"bond2\"))\n\t\t\treturn -1;\n\n\t\trestore_root_netns();\n\t}\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic void bonding_cleanup(struct skeletons *skeletons)\n{\n\trestore_root_netns();\n\twhile (skeletons->nlinks) {\n\t\tskeletons->nlinks--;\n\t\tbpf_link__destroy(skeletons->links[skeletons->nlinks]);\n\t}\n\tASSERT_OK(system(\"ip link delete bond1\"), \"delete bond1\");\n\tASSERT_OK(system(\"ip link delete veth1_1\"), \"delete veth1_1\");\n\tASSERT_OK(system(\"ip link delete veth1_2\"), \"delete veth1_2\");\n\tASSERT_OK(system(\"ip netns delete ns_dst\"), \"delete ns_dst\");\n}\n\nstatic int send_udp_packets(int vary_dst_ip)\n{\n\tstruct ethhdr eh = {\n\t\t.h_source = BOND1_MAC,\n\t\t.h_dest = BOND2_MAC,\n\t\t.h_proto = htons(ETH_P_IP),\n\t};\n\tstruct iphdr iph = {};\n\tstruct udphdr uh = {};\n\tuint8_t buf[128];\n\tint i, s = -1;\n\tint ifindex;\n\n\ts = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (!ASSERT_GE(s, 0, \"socket\"))\n\t\tgoto err;\n\n\tifindex = if_nametoindex(\"bond1\");\n\tif (!ASSERT_GT(ifindex, 0, \"get bond1 ifindex\"))\n\t\tgoto err;\n\n\tiph.ihl = 5;\n\tiph.version = 4;\n\tiph.tos = 16;\n\tiph.id = 1;\n\tiph.ttl = 64;\n\tiph.protocol = IPPROTO_UDP;\n\tiph.saddr = 1;\n\tiph.daddr = 2;\n\tiph.tot_len = htons(sizeof(buf) - ETH_HLEN);\n\tiph.check = 0;\n\n\tfor (i = 1; i <= NPACKETS; i++) {\n\t\tint n;\n\t\tstruct sockaddr_ll saddr_ll = {\n\t\t\t.sll_ifindex = ifindex,\n\t\t\t.sll_halen = ETH_ALEN,\n\t\t\t.sll_addr = BOND2_MAC,\n\t\t};\n\n\t\t \n\t\tuh.dest++;\n\n\t\tif (vary_dst_ip)\n\t\t\tiph.daddr++;\n\n\t\t \n\t\tmemcpy(buf, &eh, sizeof(eh));\n\t\tmemcpy(buf + sizeof(eh), &iph, sizeof(iph));\n\t\tmemcpy(buf + sizeof(eh) + sizeof(iph), &uh, sizeof(uh));\n\n\t\tn = sendto(s, buf, sizeof(buf), 0, (struct sockaddr *)&saddr_ll, sizeof(saddr_ll));\n\t\tif (!ASSERT_EQ(n, sizeof(buf), \"sendto\"))\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tif (s >= 0)\n\t\tclose(s);\n\treturn -1;\n}\n\nstatic void test_xdp_bonding_with_mode(struct skeletons *skeletons, int mode, int xmit_policy)\n{\n\tint bond1_rx;\n\n\tif (bonding_setup(skeletons, mode, xmit_policy, BOND_BOTH_AND_ATTACH))\n\t\tgoto out;\n\n\tif (send_udp_packets(xmit_policy != BOND_XMIT_POLICY_LAYER34))\n\t\tgoto out;\n\n\tbond1_rx = get_rx_packets(\"bond1\");\n\tASSERT_EQ(bond1_rx, NPACKETS, \"expected more received packets\");\n\n\tswitch (mode) {\n\tcase BOND_MODE_ROUNDROBIN:\n\tcase BOND_MODE_XOR: {\n\t\tint veth1_rx = get_rx_packets(\"veth1_1\");\n\t\tint veth2_rx = get_rx_packets(\"veth1_2\");\n\t\tint diff = abs(veth1_rx - veth2_rx);\n\n\t\tASSERT_GE(veth1_rx + veth2_rx, NPACKETS, \"expected more packets\");\n\n\t\tswitch (xmit_policy) {\n\t\tcase BOND_XMIT_POLICY_LAYER2:\n\t\t\tASSERT_GE(diff, NPACKETS,\n\t\t\t\t  \"expected packets on only one of the interfaces\");\n\t\t\tbreak;\n\t\tcase BOND_XMIT_POLICY_LAYER23:\n\t\tcase BOND_XMIT_POLICY_LAYER34:\n\t\t\tASSERT_LT(diff, NPACKETS/2,\n\t\t\t\t  \"expected even distribution of packets\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINT_FAIL(\"Unimplemented xmit_policy=%d\\n\", xmit_policy);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase BOND_MODE_ACTIVEBACKUP: {\n\t\tint veth1_rx = get_rx_packets(\"veth1_1\");\n\t\tint veth2_rx = get_rx_packets(\"veth1_2\");\n\t\tint diff = abs(veth1_rx - veth2_rx);\n\n\t\tASSERT_GE(diff, NPACKETS,\n\t\t\t  \"expected packets on only one of the interfaces\");\n\t\tbreak;\n\t}\n\tdefault:\n\t\tPRINT_FAIL(\"Unimplemented xmit_policy=%d\\n\", xmit_policy);\n\t\tbreak;\n\t}\n\nout:\n\tbonding_cleanup(skeletons);\n}\n\n \nstatic void test_xdp_bonding_redirect_multi(struct skeletons *skeletons)\n{\n\tstatic const char * const ifaces[] = {\"bond2\", \"veth2_1\", \"veth2_2\"};\n\tint veth1_1_rx, veth1_2_rx;\n\tint err;\n\n\tif (bonding_setup(skeletons, BOND_MODE_ROUNDROBIN, BOND_XMIT_POLICY_LAYER23,\n\t\t\t  BOND_ONE_NO_ATTACH))\n\t\tgoto out;\n\n\n\tif (!ASSERT_OK(setns_by_name(\"ns_dst\"), \"could not set netns to ns_dst\"))\n\t\tgoto out;\n\n\t \n\tfor (int i = 0; i < ARRAY_SIZE(ifaces); i++) {\n\t\tint ifindex = if_nametoindex(ifaces[i]);\n\t\tint map_fd = bpf_map__fd(skeletons->xdp_redirect_multi_kern->maps.map_all);\n\n\t\tif (!ASSERT_GT(ifindex, 0, \"could not get interface index\"))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &ifindex, &ifindex, 0);\n\t\tif (!ASSERT_OK(err, \"add interface to map_all\"))\n\t\t\tgoto out;\n\t}\n\n\tif (xdp_attach(skeletons,\n\t\t       skeletons->xdp_redirect_multi_kern->progs.xdp_redirect_map_multi_prog,\n\t\t       \"bond2\"))\n\t\tgoto out;\n\n\trestore_root_netns();\n\n\tif (send_udp_packets(BOND_MODE_ROUNDROBIN))\n\t\tgoto out;\n\n\tveth1_1_rx = get_rx_packets(\"veth1_1\");\n\tveth1_2_rx = get_rx_packets(\"veth1_2\");\n\n\tASSERT_EQ(veth1_1_rx, 0, \"expected no packets on veth1_1\");\n\tASSERT_GE(veth1_2_rx, NPACKETS, \"expected packets on veth1_2\");\n\nout:\n\trestore_root_netns();\n\tbonding_cleanup(skeletons);\n}\n\n \nstatic void test_xdp_bonding_attach(struct skeletons *skeletons)\n{\n\tstruct bpf_link *link = NULL;\n\tstruct bpf_link *link2 = NULL;\n\tint veth, bond, err;\n\n\tif (!ASSERT_OK(system(\"ip link add veth type veth\"), \"add veth\"))\n\t\tgoto out;\n\tif (!ASSERT_OK(system(\"ip link add bond type bond\"), \"add bond\"))\n\t\tgoto out;\n\n\tveth = if_nametoindex(\"veth\");\n\tif (!ASSERT_GE(veth, 0, \"if_nametoindex veth\"))\n\t\tgoto out;\n\tbond = if_nametoindex(\"bond\");\n\tif (!ASSERT_GE(bond, 0, \"if_nametoindex bond\"))\n\t\tgoto out;\n\n\t \n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, veth);\n\tif (!ASSERT_OK_PTR(link, \"attach program to veth\"))\n\t\tgoto out;\n\n\terr = system(\"ip link set veth master bond\");\n\tif (!ASSERT_OK(err, \"set veth master\"))\n\t\tgoto out;\n\n\tbpf_link__destroy(link);\n\tlink = NULL;\n\n\t \n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, veth);\n\tif (!ASSERT_OK_PTR(link, \"attach program to slave when enslaved\"))\n\t\tgoto out;\n\n\t \n\tlink2 = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, bond);\n\tif (!ASSERT_ERR_PTR(link2, \"attach program to master when slave has program\"))\n\t\tgoto out;\n\n\tbpf_link__destroy(link);\n\tlink = NULL;\n\n\t \n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, bond);\n\tif (!ASSERT_OK_PTR(link, \"attach program to master\"))\n\t\tgoto out;\n\n\t \n\tlink2 = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, veth);\n\tif (!ASSERT_ERR_PTR(link2, \"attach program to slave when master has program\"))\n\t\tgoto out;\n\n\tbpf_link__destroy(link);\n\tlink = NULL;\n\n\t \n\tif (!ASSERT_OK(system(\"ip link add vxlan type vxlan id 1 remote 1.2.3.4 dstport 0 dev lo\"),\n\t\t       \"add vxlan\"))\n\t\tgoto out;\n\n\terr = system(\"ip link set vxlan master bond\");\n\tif (!ASSERT_OK(err, \"set vxlan master\"))\n\t\tgoto out;\n\n\t \n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, bond);\n\tif (!ASSERT_ERR_PTR(link, \"attach program to master when slave does not support XDP\"))\n\t\tgoto out;\n\nout:\n\tbpf_link__destroy(link);\n\tbpf_link__destroy(link2);\n\n\tsystem(\"ip link del veth\");\n\tsystem(\"ip link del bond\");\n\tsystem(\"ip link del vxlan\");\n}\n\n \nstatic void test_xdp_bonding_nested(struct skeletons *skeletons)\n{\n\tstruct bpf_link *link = NULL;\n\tint bond, err;\n\n\tif (!ASSERT_OK(system(\"ip link add bond type bond\"), \"add bond\"))\n\t\tgoto out;\n\n\tbond = if_nametoindex(\"bond\");\n\tif (!ASSERT_GE(bond, 0, \"if_nametoindex bond\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link add bond_nest1 type bond\"), \"add bond_nest1\"))\n\t\tgoto out;\n\n\terr = system(\"ip link set bond_nest1 master bond\");\n\tif (!ASSERT_OK(err, \"set bond_nest1 master\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link add bond_nest2 type bond\"), \"add bond_nest1\"))\n\t\tgoto out;\n\n\terr = system(\"ip link set bond_nest2 master bond_nest1\");\n\tif (!ASSERT_OK(err, \"set bond_nest2 master\"))\n\t\tgoto out;\n\n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog, bond);\n\tASSERT_OK_PTR(link, \"attach program to master\");\n\nout:\n\tbpf_link__destroy(link);\n\tsystem(\"ip link del bond\");\n\tsystem(\"ip link del bond_nest1\");\n\tsystem(\"ip link del bond_nest2\");\n}\n\nstatic void test_xdp_bonding_features(struct skeletons *skeletons)\n{\n\tLIBBPF_OPTS(bpf_xdp_query_opts, query_opts);\n\tint bond_idx, veth1_idx, err;\n\tstruct bpf_link *link = NULL;\n\n\tif (!ASSERT_OK(system(\"ip link add bond type bond\"), \"add bond\"))\n\t\tgoto out;\n\n\tbond_idx = if_nametoindex(\"bond\");\n\tif (!ASSERT_GE(bond_idx, 0, \"if_nametoindex bond\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags, NETDEV_XDP_ACT_MASK,\n\t\t       \"bond query_opts.feature_flags\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link add veth0 type veth peer name veth1\"),\n\t\t       \"add veth{0,1} pair\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link add veth2 type veth peer name veth3\"),\n\t\t       \"add veth{2,3} pair\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link set veth0 master bond\"),\n\t\t       \"add veth0 to master bond\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG,\n\t\t       \"bond query_opts.feature_flags\"))\n\t\tgoto out;\n\n\tveth1_idx = if_nametoindex(\"veth1\");\n\tif (!ASSERT_GE(veth1_idx, 0, \"if_nametoindex veth1\"))\n\t\tgoto out;\n\n\tlink = bpf_program__attach_xdp(skeletons->xdp_dummy->progs.xdp_dummy_prog,\n\t\t\t\t       veth1_idx);\n\tif (!ASSERT_OK_PTR(link, \"attach program to veth1\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG | NETDEV_XDP_ACT_NDO_XMIT |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT_SG,\n\t\t       \"bond query_opts.feature_flags\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link set veth2 master bond\"),\n\t\t       \"add veth2 to master bond\"))\n\t\tgoto out;\n\n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\t \n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG,\n\t\t       \"bond query_opts.feature_flags\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link set veth2 nomaster\"),\n\t\t       \"del veth2 to master bond\"))\n\t\tgoto out;\n\n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG | NETDEV_XDP_ACT_NDO_XMIT |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT_SG,\n\t\t       \"bond query_opts.feature_flags\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(system(\"ip link set veth0 nomaster\"),\n\t\t       \"del veth0 to master bond\"))\n\t\tgoto out;\n\n\terr = bpf_xdp_query(bond_idx, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"bond bpf_xdp_query\"))\n\t\tgoto out;\n\n\tASSERT_EQ(query_opts.feature_flags, NETDEV_XDP_ACT_MASK,\n\t\t  \"bond query_opts.feature_flags\");\nout:\n\tbpf_link__destroy(link);\n\tsystem(\"ip link del veth0\");\n\tsystem(\"ip link del veth2\");\n\tsystem(\"ip link del bond\");\n}\n\nstatic int libbpf_debug_print(enum libbpf_print_level level,\n\t\t\t      const char *format, va_list args)\n{\n\tif (level != LIBBPF_WARN)\n\t\tvprintf(format, args);\n\treturn 0;\n}\n\nstruct bond_test_case {\n\tchar *name;\n\tint mode;\n\tint xmit_policy;\n};\n\nstatic struct bond_test_case bond_test_cases[] = {\n\t{ \"xdp_bonding_roundrobin\", BOND_MODE_ROUNDROBIN, BOND_XMIT_POLICY_LAYER23, },\n\t{ \"xdp_bonding_activebackup\", BOND_MODE_ACTIVEBACKUP, BOND_XMIT_POLICY_LAYER23 },\n\n\t{ \"xdp_bonding_xor_layer2\", BOND_MODE_XOR, BOND_XMIT_POLICY_LAYER2, },\n\t{ \"xdp_bonding_xor_layer23\", BOND_MODE_XOR, BOND_XMIT_POLICY_LAYER23, },\n\t{ \"xdp_bonding_xor_layer34\", BOND_MODE_XOR, BOND_XMIT_POLICY_LAYER34, },\n};\n\nvoid serial_test_xdp_bonding(void)\n{\n\tlibbpf_print_fn_t old_print_fn;\n\tstruct skeletons skeletons = {};\n\tint i;\n\n\told_print_fn = libbpf_set_print(libbpf_debug_print);\n\n\troot_netns_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (!ASSERT_GE(root_netns_fd, 0, \"open /proc/self/ns/net\"))\n\t\tgoto out;\n\n\tskeletons.xdp_dummy = xdp_dummy__open_and_load();\n\tif (!ASSERT_OK_PTR(skeletons.xdp_dummy, \"xdp_dummy__open_and_load\"))\n\t\tgoto out;\n\n\tskeletons.xdp_tx = xdp_tx__open_and_load();\n\tif (!ASSERT_OK_PTR(skeletons.xdp_tx, \"xdp_tx__open_and_load\"))\n\t\tgoto out;\n\n\tskeletons.xdp_redirect_multi_kern = xdp_redirect_multi_kern__open_and_load();\n\tif (!ASSERT_OK_PTR(skeletons.xdp_redirect_multi_kern,\n\t\t\t   \"xdp_redirect_multi_kern__open_and_load\"))\n\t\tgoto out;\n\n\tif (test__start_subtest(\"xdp_bonding_attach\"))\n\t\ttest_xdp_bonding_attach(&skeletons);\n\n\tif (test__start_subtest(\"xdp_bonding_nested\"))\n\t\ttest_xdp_bonding_nested(&skeletons);\n\n\tif (test__start_subtest(\"xdp_bonding_features\"))\n\t\ttest_xdp_bonding_features(&skeletons);\n\n\tfor (i = 0; i < ARRAY_SIZE(bond_test_cases); i++) {\n\t\tstruct bond_test_case *test_case = &bond_test_cases[i];\n\n\t\tif (test__start_subtest(test_case->name))\n\t\t\ttest_xdp_bonding_with_mode(\n\t\t\t\t&skeletons,\n\t\t\t\ttest_case->mode,\n\t\t\t\ttest_case->xmit_policy);\n\t}\n\n\tif (test__start_subtest(\"xdp_bonding_redirect_multi\"))\n\t\ttest_xdp_bonding_redirect_multi(&skeletons);\n\nout:\n\txdp_dummy__destroy(skeletons.xdp_dummy);\n\txdp_tx__destroy(skeletons.xdp_tx);\n\txdp_redirect_multi_kern__destroy(skeletons.xdp_redirect_multi_kern);\n\n\tlibbpf_set_print(old_print_fn);\n\tif (root_netns_fd >= 0)\n\t\tclose(root_netns_fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}