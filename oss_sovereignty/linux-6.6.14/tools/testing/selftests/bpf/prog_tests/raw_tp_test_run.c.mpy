{
  "module_name": "raw_tp_test_run.c",
  "hash_id": "211e170e17ed9af099b3ad7d0ec6fa992e59c55eac2da4b75f89768fb333de4c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/raw_tp_test_run.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <linux/bpf.h>\n#include \"bpf/libbpf_internal.h\"\n#include \"test_raw_tp_test_run.skel.h\"\n\nvoid test_raw_tp_test_run(void)\n{\n\tint comm_fd = -1, err, nr_online, i, prog_fd;\n\t__u64 args[2] = {0x1234ULL, 0x5678ULL};\n\tint expected_retval = 0x1234 + 0x5678;\n\tstruct test_raw_tp_test_run *skel;\n\tchar buf[] = \"new_name\";\n\tbool *online = NULL;\n\tLIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t.ctx_in = args,\n\t\t.ctx_size_in = sizeof(args),\n\t\t.flags = BPF_F_TEST_RUN_ON_CPU,\n\t);\n\n\terr = parse_cpu_mask_file(\"/sys/devices/system/cpu/online\", &online,\n\t\t\t\t  &nr_online);\n\tif (!ASSERT_OK(err, \"parse_cpu_mask_file\"))\n\t\treturn;\n\n\tskel = test_raw_tp_test_run__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\terr = test_raw_tp_test_run__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto cleanup;\n\n\tcomm_fd = open(\"/proc/self/comm\", O_WRONLY|O_TRUNC);\n\tif (!ASSERT_GE(comm_fd, 0, \"open /proc/self/comm\"))\n\t\tgoto cleanup;\n\n\terr = write(comm_fd, buf, sizeof(buf));\n\tASSERT_GE(err, 0, \"task rename\");\n\n\tASSERT_NEQ(skel->bss->count, 0, \"check_count\");\n\tASSERT_EQ(skel->data->on_cpu, 0xffffffff, \"check_on_cpu\");\n\n\tprog_fd = bpf_program__fd(skel->progs.rename);\n\topts.ctx_in = args;\n\topts.ctx_size_in = sizeof(__u64);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &opts);\n\tASSERT_NEQ(err, 0, \"test_run should fail for too small ctx\");\n\n\topts.ctx_size_in = sizeof(args);\n\terr = bpf_prog_test_run_opts(prog_fd, &opts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(opts.retval, expected_retval, \"check_retval\");\n\n\tfor (i = 0; i < nr_online; i++) {\n\t\tif (!online[i])\n\t\t\tcontinue;\n\n\t\topts.cpu = i;\n\t\topts.retval = 0;\n\t\terr = bpf_prog_test_run_opts(prog_fd, &opts);\n\t\tASSERT_OK(err, \"test_run_opts\");\n\t\tASSERT_EQ(skel->data->on_cpu, i, \"check_on_cpu\");\n\t\tASSERT_EQ(opts.retval, expected_retval, \"check_retval\");\n\t}\n\n\t \n\topts.cpu = 0xffffffff;\n\terr = bpf_prog_test_run_opts(prog_fd, &opts);\n\tASSERT_EQ(errno, ENXIO, \"test_run_opts should fail with ENXIO\");\n\tASSERT_ERR(err, \"test_run_opts_fail\");\n\n\t \n\topts.cpu = 1;\n\topts.flags = 0;\n\terr = bpf_prog_test_run_opts(prog_fd, &opts);\n\tASSERT_EQ(errno, EINVAL, \"test_run_opts should fail with EINVAL\");\n\tASSERT_ERR(err, \"test_run_opts_fail\");\n\ncleanup:\n\tclose(comm_fd);\n\ttest_raw_tp_test_run__destroy(skel);\n\tfree(online);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}