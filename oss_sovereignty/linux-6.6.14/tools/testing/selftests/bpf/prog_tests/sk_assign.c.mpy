{
  "module_name": "sk_assign.c",
  "hash_id": "db34fac710bf1b9518bfb26de2f86cc24939bfffd03c2821b98516508b15fa05",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sk_assign.c",
  "human_readable_source": "\n\n\n\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"test_progs.h\"\n\n#define BIND_PORT 1234\n#define CONNECT_PORT 4321\n#define TEST_DADDR (0xC0A80203)\n#define NS_SELF \"/proc/self/ns/net\"\n#define SERVER_MAP_PATH \"/sys/fs/bpf/tc/globals/server_map\"\n\nstatic const struct timeval timeo_sec = { .tv_sec = 3 };\nstatic const size_t timeo_optlen = sizeof(timeo_sec);\nstatic int stop, duration;\n\nstatic bool\nconfigure_stack(void)\n{\n\tchar tc_version[128];\n\tchar tc_cmd[BUFSIZ];\n\tchar *prog;\n\tFILE *tc;\n\n\t \n\ttc = popen(\"tc -V\", \"r\");\n\tif (CHECK_FAIL(!tc))\n\t\treturn false;\n\tif (CHECK_FAIL(!fgets(tc_version, sizeof(tc_version), tc)))\n\t\treturn false;\n\tif (strstr(tc_version, \", libbpf \"))\n\t\tprog = \"test_sk_assign_libbpf.bpf.o\";\n\telse\n\t\tprog = \"test_sk_assign.bpf.o\";\n\tif (CHECK_FAIL(pclose(tc)))\n\t\treturn false;\n\n\t \n\tif (CHECK_FAIL(unshare(CLONE_NEWNET)))\n\t\treturn false;\n\n\t \n\tif (CHECK_FAIL(system(\"ip link set dev lo up\")))\n\t\treturn false;\n\tif (CHECK_FAIL(system(\"ip route add local default dev lo\")))\n\t\treturn false;\n\tif (CHECK_FAIL(system(\"ip -6 route add local default dev lo\")))\n\t\treturn false;\n\n\t \n\tif (CHECK_FAIL(system(\"tc qdisc add dev lo clsact\")))\n\t\treturn false;\n\tsprintf(tc_cmd, \"%s %s %s %s %s\", \"tc filter add dev lo ingress bpf\",\n\t\t       \"direct-action object-file\", prog,\n\t\t       \"section tc\",\n\t\t       (env.verbosity < VERBOSE_VERY) ? \" 2>/dev/null\" : \"verbose\");\n\tif (CHECK(system(tc_cmd), \"BPF load failed;\",\n\t\t  \"run with -vv for more info\\n\"))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nstart_server(const struct sockaddr *addr, socklen_t len, int type)\n{\n\tint fd;\n\n\tfd = socket(addr->sa_family, type, 0);\n\tif (CHECK_FAIL(fd == -1))\n\t\tgoto out;\n\tif (CHECK_FAIL(setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeo_sec,\n\t\t\t\t  timeo_optlen)))\n\t\tgoto close_out;\n\tif (CHECK_FAIL(bind(fd, addr, len) == -1))\n\t\tgoto close_out;\n\tif (type == SOCK_STREAM && CHECK_FAIL(listen(fd, 128) == -1))\n\t\tgoto close_out;\n\n\tgoto out;\nclose_out:\n\tclose(fd);\n\tfd = -1;\nout:\n\treturn fd;\n}\n\nstatic int\nconnect_to_server(const struct sockaddr *addr, socklen_t len, int type)\n{\n\tint fd = -1;\n\n\tfd = socket(addr->sa_family, type, 0);\n\tif (CHECK_FAIL(fd == -1))\n\t\tgoto out;\n\tif (CHECK_FAIL(setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeo_sec,\n\t\t\t\t  timeo_optlen)))\n\t\tgoto close_out;\n\tif (CHECK_FAIL(connect(fd, addr, len)))\n\t\tgoto close_out;\n\n\tgoto out;\nclose_out:\n\tclose(fd);\n\tfd = -1;\nout:\n\treturn fd;\n}\n\nstatic in_port_t\nget_port(int fd)\n{\n\tstruct sockaddr_storage ss;\n\tsocklen_t slen = sizeof(ss);\n\tin_port_t port = 0;\n\n\tif (CHECK_FAIL(getsockname(fd, (struct sockaddr *)&ss, &slen)))\n\t\treturn port;\n\n\tswitch (ss.ss_family) {\n\tcase AF_INET:\n\t\tport = ((struct sockaddr_in *)&ss)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tport = ((struct sockaddr_in6 *)&ss)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tCHECK(1, \"Invalid address family\", \"%d\\n\", ss.ss_family);\n\t}\n\treturn port;\n}\n\nstatic ssize_t\nrcv_msg(int srv_client, int type)\n{\n\tchar buf[BUFSIZ];\n\n\tif (type == SOCK_STREAM)\n\t\treturn read(srv_client, &buf, sizeof(buf));\n\telse\n\t\treturn recvfrom(srv_client, &buf, sizeof(buf), 0, NULL, NULL);\n}\n\nstatic int\nrun_test(int server_fd, const struct sockaddr *addr, socklen_t len, int type)\n{\n\tint client = -1, srv_client = -1;\n\tchar buf[] = \"testing\";\n\tin_port_t port;\n\tint ret = 1;\n\n\tclient = connect_to_server(addr, len, type);\n\tif (client == -1) {\n\t\tperror(\"Cannot connect to server\");\n\t\tgoto out;\n\t}\n\n\tif (type == SOCK_STREAM) {\n\t\tsrv_client = accept(server_fd, NULL, NULL);\n\t\tif (CHECK_FAIL(srv_client == -1)) {\n\t\t\tperror(\"Can't accept connection\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tsrv_client = server_fd;\n\t}\n\tif (CHECK_FAIL(write(client, buf, sizeof(buf)) != sizeof(buf))) {\n\t\tperror(\"Can't write on client\");\n\t\tgoto out;\n\t}\n\tif (CHECK_FAIL(rcv_msg(srv_client, type) != sizeof(buf))) {\n\t\tperror(\"Can't read on server\");\n\t\tgoto out;\n\t}\n\n\tport = get_port(srv_client);\n\tif (CHECK_FAIL(!port))\n\t\tgoto out;\n\t \n\tif (type == SOCK_STREAM &&\n\t    CHECK(port != htons(CONNECT_PORT), \"Expected\", \"port %u but got %u\",\n\t\t  CONNECT_PORT, ntohs(port)))\n\t\tgoto out;\n\telse if (type == SOCK_DGRAM &&\n\t\t CHECK(port != htons(BIND_PORT), \"Expected\",\n\t\t       \"port %u but got %u\", BIND_PORT, ntohs(port)))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\tclose(client);\n\tif (srv_client != server_fd)\n\t\tclose(srv_client);\n\tif (ret)\n\t\tWRITE_ONCE(stop, 1);\n\treturn ret;\n}\n\nstatic void\nprepare_addr(struct sockaddr *addr, int family, __u16 port, bool rewrite_addr)\n{\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)addr;\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = family;\n\t\taddr4->sin_port = htons(port);\n\t\tif (rewrite_addr)\n\t\t\taddr4->sin_addr.s_addr = htonl(TEST_DADDR);\n\t\telse\n\t\t\taddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)addr;\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = family;\n\t\taddr6->sin6_port = htons(port);\n\t\taddr6->sin6_addr = in6addr_loopback;\n\t\tif (rewrite_addr)\n\t\t\taddr6->sin6_addr.s6_addr32[3] = htonl(TEST_DADDR);\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid family %d\", family);\n\t}\n}\n\nstruct test_sk_cfg {\n\tconst char *name;\n\tint family;\n\tstruct sockaddr *addr;\n\tsocklen_t len;\n\tint type;\n\tbool rewrite_addr;\n};\n\n#define TEST(NAME, FAMILY, TYPE, REWRITE)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.name = NAME,\t\t\t\t\t\t\t\\\n\t.family = FAMILY,\t\t\t\t\t\t\\\n\t.addr = (FAMILY == AF_INET) ? (struct sockaddr *)&addr4\t\t\\\n\t\t\t\t    : (struct sockaddr *)&addr6,\t\\\n\t.len = (FAMILY == AF_INET) ? sizeof(addr4) : sizeof(addr6),\t\\\n\t.type = TYPE,\t\t\t\t\t\t\t\\\n\t.rewrite_addr = REWRITE,\t\t\t\t\t\\\n}\n\nvoid test_sk_assign(void)\n{\n\tstruct sockaddr_in addr4;\n\tstruct sockaddr_in6 addr6;\n\tstruct test_sk_cfg tests[] = {\n\t\tTEST(\"ipv4 tcp port redir\", AF_INET, SOCK_STREAM, false),\n\t\tTEST(\"ipv4 tcp addr redir\", AF_INET, SOCK_STREAM, true),\n\t\tTEST(\"ipv6 tcp port redir\", AF_INET6, SOCK_STREAM, false),\n\t\tTEST(\"ipv6 tcp addr redir\", AF_INET6, SOCK_STREAM, true),\n\t\tTEST(\"ipv4 udp port redir\", AF_INET, SOCK_DGRAM, false),\n\t\tTEST(\"ipv4 udp addr redir\", AF_INET, SOCK_DGRAM, true),\n\t\tTEST(\"ipv6 udp port redir\", AF_INET6, SOCK_DGRAM, false),\n\t\tTEST(\"ipv6 udp addr redir\", AF_INET6, SOCK_DGRAM, true),\n\t};\n\t__s64 server = -1;\n\tint server_map;\n\tint self_net;\n\tint i;\n\n\tself_net = open(NS_SELF, O_RDONLY);\n\tif (CHECK_FAIL(self_net < 0)) {\n\t\tperror(\"Unable to open \"NS_SELF);\n\t\treturn;\n\t}\n\n\tif (!configure_stack()) {\n\t\tperror(\"configure_stack\");\n\t\tgoto cleanup;\n\t}\n\n\tserver_map = bpf_obj_get(SERVER_MAP_PATH);\n\tif (CHECK_FAIL(server_map < 0)) {\n\t\tperror(\"Unable to open \" SERVER_MAP_PATH);\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tests) && !READ_ONCE(stop); i++) {\n\t\tstruct test_sk_cfg *test = &tests[i];\n\t\tconst struct sockaddr *addr;\n\t\tconst int zero = 0;\n\t\tint err;\n\n\t\tif (!test__start_subtest(test->name))\n\t\t\tcontinue;\n\t\tprepare_addr(test->addr, test->family, BIND_PORT, false);\n\t\taddr = (const struct sockaddr *)test->addr;\n\t\tserver = start_server(addr, test->len, test->type);\n\t\tif (server == -1)\n\t\t\tgoto close;\n\n\t\terr = bpf_map_update_elem(server_map, &zero, &server, BPF_ANY);\n\t\tif (CHECK_FAIL(err)) {\n\t\t\tperror(\"Unable to update server_map\");\n\t\t\tgoto close;\n\t\t}\n\n\t\t \n\t\tprepare_addr(test->addr, test->family, CONNECT_PORT,\n\t\t\t     test->rewrite_addr);\n\t\tif (run_test(server, addr, test->len, test->type))\n\t\t\tgoto close;\n\n\t\tclose(server);\n\t\tserver = -1;\n\t}\n\nclose:\n\tclose(server);\n\tclose(server_map);\ncleanup:\n\tif (CHECK_FAIL(unlink(SERVER_MAP_PATH)))\n\t\tperror(\"Unable to unlink \" SERVER_MAP_PATH);\n\tif (CHECK_FAIL(setns(self_net, CLONE_NEWNET)))\n\t\tperror(\"Failed to setns(\"NS_SELF\")\");\n\tclose(self_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}