{
  "module_name": "resolve_btfids.c",
  "hash_id": "78d3d5ad655944e2d9e2d040e6e8b53d37cfabef8faa988687f5d36536f5abde",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/resolve_btfids.c",
  "human_readable_source": "\n\n#include <linux/err.h>\n#include <string.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#include <linux/btf.h>\n#include <linux/kernel.h>\n#define CONFIG_DEBUG_INFO_BTF\n#include <linux/btf_ids.h>\n#include \"test_progs.h\"\n\nstatic int duration;\n\nstruct symbol {\n\tconst char\t*name;\n\tint\t\t type;\n\tint\t\t id;\n};\n\nstruct symbol test_symbols[] = {\n\t{ \"unused\",  BTF_KIND_UNKN,     0 },\n\t{ \"S\",       BTF_KIND_TYPEDEF, -1 },\n\t{ \"T\",       BTF_KIND_TYPEDEF, -1 },\n\t{ \"U\",       BTF_KIND_TYPEDEF, -1 },\n\t{ \"S\",       BTF_KIND_STRUCT,  -1 },\n\t{ \"U\",       BTF_KIND_UNION,   -1 },\n\t{ \"func\",    BTF_KIND_FUNC,    -1 },\n};\n\n \nasm (\n\".pushsection \" BTF_IDS_SECTION \" ,\\\"a\\\"; \\n\"\n\".balign 4, 0;                            \\n\"\n\".popsection;                             \\n\");\n\nBTF_ID_LIST(test_list_local)\nBTF_ID_UNUSED\nBTF_ID(typedef, S)\nBTF_ID(typedef, T)\nBTF_ID(typedef, U)\nBTF_ID(struct,  S)\nBTF_ID(union,   U)\nBTF_ID(func,    func)\n\nextern __u32 test_list_global[];\nBTF_ID_LIST_GLOBAL(test_list_global, 1)\nBTF_ID_UNUSED\nBTF_ID(typedef, S)\nBTF_ID(typedef, T)\nBTF_ID(typedef, U)\nBTF_ID(struct,  S)\nBTF_ID(union,   U)\nBTF_ID(func,    func)\n\nBTF_SET_START(test_set)\nBTF_ID(typedef, S)\nBTF_ID(typedef, T)\nBTF_ID(typedef, U)\nBTF_ID(struct,  S)\nBTF_ID(union,   U)\nBTF_ID(func,    func)\nBTF_SET_END(test_set)\n\nstatic int\n__resolve_symbol(struct btf *btf, int type_id)\n{\n\tconst struct btf_type *type;\n\tconst char *str;\n\tunsigned int i;\n\n\ttype = btf__type_by_id(btf, type_id);\n\tif (!type) {\n\t\tPRINT_FAIL(\"Failed to get type for ID %d\\n\", type_id);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(test_symbols); i++) {\n\t\tif (test_symbols[i].id >= 0)\n\t\t\tcontinue;\n\n\t\tif (BTF_INFO_KIND(type->info) != test_symbols[i].type)\n\t\t\tcontinue;\n\n\t\tstr = btf__name_by_offset(btf, type->name_off);\n\t\tif (!str) {\n\t\t\tPRINT_FAIL(\"Failed to get name for BTF ID %d\\n\", type_id);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!strcmp(str, test_symbols[i].name))\n\t\t\ttest_symbols[i].id = type_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int resolve_symbols(void)\n{\n\tstruct btf *btf;\n\tint type_id;\n\t__u32 nr;\n\n\tbtf = btf__parse_elf(\"btf_data.bpf.o\", NULL);\n\tif (CHECK(libbpf_get_error(btf), \"resolve\",\n\t\t  \"Failed to load BTF from btf_data.o\\n\"))\n\t\treturn -1;\n\n\tnr = btf__type_cnt(btf);\n\n\tfor (type_id = 1; type_id < nr; type_id++) {\n\t\tif (__resolve_symbol(btf, type_id))\n\t\t\tbreak;\n\t}\n\n\tbtf__free(btf);\n\treturn 0;\n}\n\nvoid test_resolve_btfids(void)\n{\n\t__u32 *test_list, *test_lists[] = { test_list_local, test_list_global };\n\tunsigned int i, j;\n\tint ret = 0;\n\n\tif (resolve_symbols())\n\t\treturn;\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(test_lists); j++) {\n\t\ttest_list = test_lists[j];\n\t\tfor (i = 0; i < ARRAY_SIZE(test_symbols); i++) {\n\t\t\tret = CHECK(test_list[i] != test_symbols[i].id,\n\t\t\t\t    \"id_check\",\n\t\t\t\t    \"wrong ID for %s (%d != %d)\\n\",\n\t\t\t\t    test_symbols[i].name,\n\t\t\t\t    test_list[i], test_symbols[i].id);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < test_set.cnt; i++) {\n\t\tbool found = false;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(test_symbols); j++) {\n\t\t\tif (test_symbols[j].id != test_set.ids[i])\n\t\t\t\tcontinue;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = CHECK(!found, \"id_check\",\n\t\t\t    \"ID %d not found in test_symbols\\n\",\n\t\t\t    test_set.ids[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (i > 0) {\n\t\t\tif (!ASSERT_LE(test_set.ids[i - 1], test_set.ids[i], \"sort_check\"))\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}