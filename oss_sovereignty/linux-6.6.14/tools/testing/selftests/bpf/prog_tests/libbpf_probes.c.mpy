{
  "module_name": "libbpf_probes.c",
  "hash_id": "0f831e929f8e331d10f6b04507a51cb0a97174d32280468cfcf6c5adb42fa45c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/libbpf_probes.c",
  "human_readable_source": " \n \n\n#include <test_progs.h>\n#include <bpf/btf.h>\n\nvoid test_libbpf_probe_prog_types(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_prog_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_prog_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\tif (!ASSERT_OK_PTR(t, \"bpf_prog_type_enum\"))\n\t\tgoto cleanup;\n\n\tfor (e = btf_enum(t), i = 0, n = btf_vlen(t); i < n; e++, i++) {\n\t\tconst char *prog_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tenum bpf_prog_type prog_type = (enum bpf_prog_type)e->val;\n\t\tint res;\n\n\t\tif (prog_type == BPF_PROG_TYPE_UNSPEC)\n\t\t\tcontinue;\n\n\t\tif (!test__start_subtest(prog_type_name))\n\t\t\tcontinue;\n\n\t\tres = libbpf_probe_bpf_prog_type(prog_type, NULL);\n\t\tASSERT_EQ(res, 1, prog_type_name);\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\nvoid test_libbpf_probe_map_types(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_map_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_map_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\tif (!ASSERT_OK_PTR(t, \"bpf_map_type_enum\"))\n\t\tgoto cleanup;\n\n\tfor (e = btf_enum(t), i = 0, n = btf_vlen(t); i < n; e++, i++) {\n\t\tconst char *map_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tenum bpf_map_type map_type = (enum bpf_map_type)e->val;\n\t\tint res;\n\n\t\tif (map_type == BPF_MAP_TYPE_UNSPEC)\n\t\t\tcontinue;\n\n\t\tif (!test__start_subtest(map_type_name))\n\t\t\tcontinue;\n\n\t\tres = libbpf_probe_bpf_map_type(map_type, NULL);\n\t\tASSERT_EQ(res, 1, map_type_name);\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\nvoid test_libbpf_probe_helpers(void)\n{\n#define CASE(prog, helper, supp) {\t\t\t\\\n\t.prog_type_name = \"BPF_PROG_TYPE_\" # prog,\t\\\n\t.helper_name = \"bpf_\" # helper,\t\t\t\\\n\t.prog_type = BPF_PROG_TYPE_ ## prog,\t\t\\\n\t.helper_id = BPF_FUNC_ ## helper,\t\t\\\n\t.supported = supp,\t\t\t\t\\\n}\n\tconst struct case_def {\n\t\tconst char *prog_type_name;\n\t\tconst char *helper_name;\n\t\tenum bpf_prog_type prog_type;\n\t\tenum bpf_func_id helper_id;\n\t\tbool supported;\n\t} cases[] = {\n\t\tCASE(KPROBE, unspec, false),\n\t\tCASE(KPROBE, map_lookup_elem, true),\n\t\tCASE(KPROBE, loop, true),\n\n\t\tCASE(KPROBE, ktime_get_coarse_ns, false),\n\t\tCASE(SOCKET_FILTER, ktime_get_coarse_ns, true),\n\n\t\tCASE(KPROBE, sys_bpf, false),\n\t\tCASE(SYSCALL, sys_bpf, true),\n\t};\n\tsize_t case_cnt = ARRAY_SIZE(cases), i;\n\tchar buf[128];\n\n\tfor (i = 0; i < case_cnt; i++) {\n\t\tconst struct case_def *d = &cases[i];\n\t\tint res;\n\n\t\tsnprintf(buf, sizeof(buf), \"%s+%s\", d->prog_type_name, d->helper_name);\n\n\t\tif (!test__start_subtest(buf))\n\t\t\tcontinue;\n\n\t\tres = libbpf_probe_bpf_helper(d->prog_type, d->helper_id, NULL);\n\t\tASSERT_EQ(res, d->supported, buf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}