{
  "module_name": "skeleton.c",
  "hash_id": "651803e2de4424a0356588e23c33b5a2d8f5339ed571e1a839f78cd7e759f4a5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/skeleton.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <sys/mman.h>\n\nstruct s {\n\tint a;\n\tlong long b;\n} __attribute__((packed));\n\n#include \"test_skeleton.skel.h\"\n\nvoid test_skeleton(void)\n{\n\tint duration = 0, err;\n\tstruct test_skeleton* skel;\n\tstruct test_skeleton__bss *bss;\n\tstruct test_skeleton__data *data;\n\tstruct test_skeleton__data_dyn *data_dyn;\n\tstruct test_skeleton__rodata *rodata;\n\tstruct test_skeleton__rodata_dyn *rodata_dyn;\n\tstruct test_skeleton__kconfig *kcfg;\n\tconst void *elf_bytes;\n\tsize_t elf_bytes_sz = 0;\n\tvoid *m;\n\tint i, fd;\n\n\tskel = test_skeleton__open();\n\tif (CHECK(!skel, \"skel_open\", \"failed to open skeleton\\n\"))\n\t\treturn;\n\n\tif (CHECK(skel->kconfig, \"skel_kconfig\", \"kconfig is mmaped()!\\n\"))\n\t\tgoto cleanup;\n\n\tbss = skel->bss;\n\tdata = skel->data;\n\tdata_dyn = skel->data_dyn;\n\trodata = skel->rodata;\n\trodata_dyn = skel->rodata_dyn;\n\n\tASSERT_STREQ(bpf_map__name(skel->maps.rodata_dyn), \".rodata.dyn\", \"rodata_dyn_name\");\n\tASSERT_STREQ(bpf_map__name(skel->maps.data_dyn), \".data.dyn\", \"data_dyn_name\");\n\n\t \n\tCHECK(data->in1 != -1, \"in1\", \"got %d != exp %d\\n\", data->in1, -1);\n\tCHECK(data->out1 != -1, \"out1\", \"got %d != exp %d\\n\", data->out1, -1);\n\tCHECK(data->in2 != -1, \"in2\", \"got %lld != exp %lld\\n\", data->in2, -1LL);\n\tCHECK(data->out2 != -1, \"out2\", \"got %lld != exp %lld\\n\", data->out2, -1LL);\n\n\tCHECK(bss->in3 != 0, \"in3\", \"got %d != exp %d\\n\", bss->in3, 0);\n\tCHECK(bss->out3 != 0, \"out3\", \"got %d != exp %d\\n\", bss->out3, 0);\n\tCHECK(bss->in4 != 0, \"in4\", \"got %lld != exp %lld\\n\", bss->in4, 0LL);\n\tCHECK(bss->out4 != 0, \"out4\", \"got %lld != exp %lld\\n\", bss->out4, 0LL);\n\n\tCHECK(rodata->in.in6 != 0, \"in6\", \"got %d != exp %d\\n\", rodata->in.in6, 0);\n\tCHECK(bss->out6 != 0, \"out6\", \"got %d != exp %d\\n\", bss->out6, 0);\n\n\tASSERT_EQ(rodata_dyn->in_dynarr_sz, 0, \"in_dynarr_sz\");\n\tfor (i = 0; i < 4; i++)\n\t\tASSERT_EQ(rodata_dyn->in_dynarr[i], -(i + 1), \"in_dynarr\");\n\tfor (i = 0; i < 4; i++)\n\t\tASSERT_EQ(data_dyn->out_dynarr[i], i + 1, \"out_dynarr\");\n\n\t \n\tdata->in1 = 10;\n\tdata->in2 = 11;\n\tbss->in3 = 12;\n\tbss->in4 = 13;\n\trodata->in.in6 = 14;\n\n\trodata_dyn->in_dynarr_sz = 4;\n\tfor (i = 0; i < 4; i++)\n\t\trodata_dyn->in_dynarr[i] = i + 10;\n\n\terr = test_skeleton__load(skel);\n\tif (CHECK(err, \"skel_load\", \"failed to load skeleton: %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tCHECK(data->in1 != 10, \"in1\", \"got %d != exp %d\\n\", data->in1, 10);\n\tCHECK(data->in2 != 11, \"in2\", \"got %lld != exp %lld\\n\", data->in2, 11LL);\n\tCHECK(bss->in3 != 12, \"in3\", \"got %d != exp %d\\n\", bss->in3, 12);\n\tCHECK(bss->in4 != 13, \"in4\", \"got %lld != exp %lld\\n\", bss->in4, 13LL);\n\tCHECK(rodata->in.in6 != 14, \"in6\", \"got %d != exp %d\\n\", rodata->in.in6, 14);\n\n\tASSERT_EQ(rodata_dyn->in_dynarr_sz, 4, \"in_dynarr_sz\");\n\tfor (i = 0; i < 4; i++)\n\t\tASSERT_EQ(rodata_dyn->in_dynarr[i], i + 10, \"in_dynarr\");\n\n\t \n\tdata->in1 = 1;\n\tdata->in2 = 2;\n\tbss->in3 = 3;\n\tbss->in4 = 4;\n\tbss->in5.a = 5;\n\tbss->in5.b = 6;\n\tkcfg = skel->kconfig;\n\n\tskel->data_read_mostly->read_mostly_var = 123;\n\n\terr = test_skeleton__attach(skel);\n\tif (CHECK(err, \"skel_attach\", \"skeleton attach failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tCHECK(data->out1 != 1, \"res1\", \"got %d != exp %d\\n\", data->out1, 1);\n\tCHECK(data->out2 != 2, \"res2\", \"got %lld != exp %d\\n\", data->out2, 2);\n\tCHECK(bss->out3 != 3, \"res3\", \"got %d != exp %d\\n\", (int)bss->out3, 3);\n\tCHECK(bss->out4 != 4, \"res4\", \"got %lld != exp %d\\n\", bss->out4, 4);\n\tCHECK(bss->out5.a != 5, \"res5\", \"got %d != exp %d\\n\", bss->out5.a, 5);\n\tCHECK(bss->out5.b != 6, \"res6\", \"got %lld != exp %d\\n\", bss->out5.b, 6);\n\tCHECK(bss->out6 != 14, \"res7\", \"got %d != exp %d\\n\", bss->out6, 14);\n\n\tCHECK(bss->bpf_syscall != kcfg->CONFIG_BPF_SYSCALL, \"ext1\",\n\t      \"got %d != exp %d\\n\", bss->bpf_syscall, kcfg->CONFIG_BPF_SYSCALL);\n\tCHECK(bss->kern_ver != kcfg->LINUX_KERNEL_VERSION, \"ext2\",\n\t      \"got %d != exp %d\\n\", bss->kern_ver, kcfg->LINUX_KERNEL_VERSION);\n\n\tfor (i = 0; i < 4; i++)\n\t\tASSERT_EQ(data_dyn->out_dynarr[i], i + 10, \"out_dynarr\");\n\n\tASSERT_EQ(skel->bss->out_mostly_var, 123, \"out_mostly_var\");\n\n\tASSERT_EQ(bss->huge_arr[ARRAY_SIZE(bss->huge_arr) - 1], 123, \"huge_arr\");\n\n\tfd = bpf_map__fd(skel->maps.data_non_mmapable);\n\tm = mmap(NULL, getpagesize(), PROT_READ, MAP_SHARED, fd, 0);\n\tif (!ASSERT_EQ(m, MAP_FAILED, \"unexpected_mmap_success\"))\n\t\tmunmap(m, getpagesize());\n\n\tASSERT_EQ(bpf_map__map_flags(skel->maps.data_non_mmapable), 0, \"non_mmap_flags\");\n\n\telf_bytes = test_skeleton__elf_bytes(&elf_bytes_sz);\n\tASSERT_OK_PTR(elf_bytes, \"elf_bytes\");\n\tASSERT_GE(elf_bytes_sz, 0, \"elf_bytes_sz\");\n\ncleanup:\n\ttest_skeleton__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}