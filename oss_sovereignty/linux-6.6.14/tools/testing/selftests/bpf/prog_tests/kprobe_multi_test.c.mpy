{
  "module_name": "kprobe_multi_test.c",
  "hash_id": "b28747e8dab0a7ade58b72b72a48bddc652bcb10e8f99090dc5858b1381035f1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/kprobe_multi_test.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include \"kprobe_multi.skel.h\"\n#include \"trace_helpers.h\"\n#include \"kprobe_multi_empty.skel.h\"\n#include \"kprobe_multi_override.skel.h\"\n#include \"bpf/libbpf_internal.h\"\n#include \"bpf/hashmap.h\"\n\nstatic void kprobe_multi_test_run(struct kprobe_multi *skel, bool test_return)\n{\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\tint err, prog_fd;\n\n\tprog_fd = bpf_program__fd(skel->progs.trigger);\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, 0, \"test_run\");\n\n\tASSERT_EQ(skel->bss->kprobe_test1_result, 1, \"kprobe_test1_result\");\n\tASSERT_EQ(skel->bss->kprobe_test2_result, 1, \"kprobe_test2_result\");\n\tASSERT_EQ(skel->bss->kprobe_test3_result, 1, \"kprobe_test3_result\");\n\tASSERT_EQ(skel->bss->kprobe_test4_result, 1, \"kprobe_test4_result\");\n\tASSERT_EQ(skel->bss->kprobe_test5_result, 1, \"kprobe_test5_result\");\n\tASSERT_EQ(skel->bss->kprobe_test6_result, 1, \"kprobe_test6_result\");\n\tASSERT_EQ(skel->bss->kprobe_test7_result, 1, \"kprobe_test7_result\");\n\tASSERT_EQ(skel->bss->kprobe_test8_result, 1, \"kprobe_test8_result\");\n\n\tif (test_return) {\n\t\tASSERT_EQ(skel->bss->kretprobe_test1_result, 1, \"kretprobe_test1_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test2_result, 1, \"kretprobe_test2_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test3_result, 1, \"kretprobe_test3_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test4_result, 1, \"kretprobe_test4_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test5_result, 1, \"kretprobe_test5_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test6_result, 1, \"kretprobe_test6_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test7_result, 1, \"kretprobe_test7_result\");\n\t\tASSERT_EQ(skel->bss->kretprobe_test8_result, 1, \"kretprobe_test8_result\");\n\t}\n}\n\nstatic void test_skel_api(void)\n{\n\tstruct kprobe_multi *skel = NULL;\n\tint err;\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"kprobe_multi__open_and_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\terr = kprobe_multi__attach(skel);\n\tif (!ASSERT_OK(err, \"kprobe_multi__attach\"))\n\t\tgoto cleanup;\n\n\tkprobe_multi_test_run(skel, true);\n\ncleanup:\n\tkprobe_multi__destroy(skel);\n}\n\nstatic void test_link_api(struct bpf_link_create_opts *opts)\n{\n\tint prog_fd, link1_fd = -1, link2_fd = -1;\n\tstruct kprobe_multi *skel = NULL;\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"fentry_raw_skel_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\tprog_fd = bpf_program__fd(skel->progs.test_kprobe);\n\tlink1_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_KPROBE_MULTI, opts);\n\tif (!ASSERT_GE(link1_fd, 0, \"link_fd\"))\n\t\tgoto cleanup;\n\n\topts->kprobe_multi.flags = BPF_F_KPROBE_MULTI_RETURN;\n\tprog_fd = bpf_program__fd(skel->progs.test_kretprobe);\n\tlink2_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_KPROBE_MULTI, opts);\n\tif (!ASSERT_GE(link2_fd, 0, \"link_fd\"))\n\t\tgoto cleanup;\n\n\tkprobe_multi_test_run(skel, true);\n\ncleanup:\n\tif (link1_fd != -1)\n\t\tclose(link1_fd);\n\tif (link2_fd != -1)\n\t\tclose(link2_fd);\n\tkprobe_multi__destroy(skel);\n}\n\n#define GET_ADDR(__sym, __addr) ({\t\t\t\t\t\\\n\t__addr = ksym_get_addr(__sym);\t\t\t\t\t\\\n\tif (!ASSERT_NEQ(__addr, 0, \"kallsyms load failed for \" #__sym))\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n})\n\nstatic void test_link_api_addrs(void)\n{\n\tLIBBPF_OPTS(bpf_link_create_opts, opts);\n\tunsigned long long addrs[8];\n\n\tGET_ADDR(\"bpf_fentry_test1\", addrs[0]);\n\tGET_ADDR(\"bpf_fentry_test2\", addrs[1]);\n\tGET_ADDR(\"bpf_fentry_test3\", addrs[2]);\n\tGET_ADDR(\"bpf_fentry_test4\", addrs[3]);\n\tGET_ADDR(\"bpf_fentry_test5\", addrs[4]);\n\tGET_ADDR(\"bpf_fentry_test6\", addrs[5]);\n\tGET_ADDR(\"bpf_fentry_test7\", addrs[6]);\n\tGET_ADDR(\"bpf_fentry_test8\", addrs[7]);\n\n\topts.kprobe_multi.addrs = (const unsigned long*) addrs;\n\topts.kprobe_multi.cnt = ARRAY_SIZE(addrs);\n\ttest_link_api(&opts);\n}\n\nstatic void test_link_api_syms(void)\n{\n\tLIBBPF_OPTS(bpf_link_create_opts, opts);\n\tconst char *syms[8] = {\n\t\t\"bpf_fentry_test1\",\n\t\t\"bpf_fentry_test2\",\n\t\t\"bpf_fentry_test3\",\n\t\t\"bpf_fentry_test4\",\n\t\t\"bpf_fentry_test5\",\n\t\t\"bpf_fentry_test6\",\n\t\t\"bpf_fentry_test7\",\n\t\t\"bpf_fentry_test8\",\n\t};\n\n\topts.kprobe_multi.syms = syms;\n\topts.kprobe_multi.cnt = ARRAY_SIZE(syms);\n\ttest_link_api(&opts);\n}\n\nstatic void\ntest_attach_api(const char *pattern, struct bpf_kprobe_multi_opts *opts)\n{\n\tstruct bpf_link *link1 = NULL, *link2 = NULL;\n\tstruct kprobe_multi *skel = NULL;\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"fentry_raw_skel_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\tlink1 = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t      pattern, opts);\n\tif (!ASSERT_OK_PTR(link1, \"bpf_program__attach_kprobe_multi_opts\"))\n\t\tgoto cleanup;\n\n\tif (opts) {\n\t\topts->retprobe = true;\n\t\tlink2 = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kretprobe_manual,\n\t\t\t\t\t\t\t      pattern, opts);\n\t\tif (!ASSERT_OK_PTR(link2, \"bpf_program__attach_kprobe_multi_opts\"))\n\t\t\tgoto cleanup;\n\t}\n\n\tkprobe_multi_test_run(skel, !!opts);\n\ncleanup:\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(link1);\n\tkprobe_multi__destroy(skel);\n}\n\nstatic void test_attach_api_pattern(void)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\n\ttest_attach_api(\"bpf_fentry_test*\", &opts);\n\ttest_attach_api(\"bpf_fentry_test?\", NULL);\n}\n\nstatic void test_attach_api_addrs(void)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tunsigned long long addrs[8];\n\n\tGET_ADDR(\"bpf_fentry_test1\", addrs[0]);\n\tGET_ADDR(\"bpf_fentry_test2\", addrs[1]);\n\tGET_ADDR(\"bpf_fentry_test3\", addrs[2]);\n\tGET_ADDR(\"bpf_fentry_test4\", addrs[3]);\n\tGET_ADDR(\"bpf_fentry_test5\", addrs[4]);\n\tGET_ADDR(\"bpf_fentry_test6\", addrs[5]);\n\tGET_ADDR(\"bpf_fentry_test7\", addrs[6]);\n\tGET_ADDR(\"bpf_fentry_test8\", addrs[7]);\n\n\topts.addrs = (const unsigned long *) addrs;\n\topts.cnt = ARRAY_SIZE(addrs);\n\ttest_attach_api(NULL, &opts);\n}\n\nstatic void test_attach_api_syms(void)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tconst char *syms[8] = {\n\t\t\"bpf_fentry_test1\",\n\t\t\"bpf_fentry_test2\",\n\t\t\"bpf_fentry_test3\",\n\t\t\"bpf_fentry_test4\",\n\t\t\"bpf_fentry_test5\",\n\t\t\"bpf_fentry_test6\",\n\t\t\"bpf_fentry_test7\",\n\t\t\"bpf_fentry_test8\",\n\t};\n\n\topts.syms = syms;\n\topts.cnt = ARRAY_SIZE(syms);\n\ttest_attach_api(NULL, &opts);\n}\n\nstatic void test_attach_api_fails(void)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tstruct kprobe_multi *skel = NULL;\n\tstruct bpf_link *link = NULL;\n\tunsigned long long addrs[2];\n\tconst char *syms[2] = {\n\t\t\"bpf_fentry_test1\",\n\t\t\"bpf_fentry_test2\",\n\t};\n\t__u64 cookies[2];\n\n\taddrs[0] = ksym_get_addr(\"bpf_fentry_test1\");\n\taddrs[1] = ksym_get_addr(\"bpf_fentry_test2\");\n\n\tif (!ASSERT_FALSE(!addrs[0] || !addrs[1], \"ksym_get_addr\"))\n\t\tgoto cleanup;\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"fentry_raw_skel_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\n\t \n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t     NULL, NULL);\n\tif (!ASSERT_ERR_PTR(link, \"fail_1\"))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(libbpf_get_error(link), -EINVAL, \"fail_1_error\"))\n\t\tgoto cleanup;\n\n\t \n\topts.addrs = (const unsigned long *) addrs;\n\topts.syms = syms;\n\topts.cnt = ARRAY_SIZE(syms);\n\topts.cookies = NULL;\n\n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t     NULL, &opts);\n\tif (!ASSERT_ERR_PTR(link, \"fail_2\"))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(libbpf_get_error(link), -EINVAL, \"fail_2_error\"))\n\t\tgoto cleanup;\n\n\t \n\topts.addrs = (const unsigned long *) addrs;\n\topts.syms = NULL;\n\topts.cnt = ARRAY_SIZE(syms);\n\topts.cookies = NULL;\n\n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t     \"ksys_*\", &opts);\n\tif (!ASSERT_ERR_PTR(link, \"fail_3\"))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(libbpf_get_error(link), -EINVAL, \"fail_3_error\"))\n\t\tgoto cleanup;\n\n\t \n\topts.addrs = NULL;\n\topts.syms = NULL;\n\topts.cnt = ARRAY_SIZE(syms);\n\topts.cookies = NULL;\n\n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t     \"ksys_*\", &opts);\n\tif (!ASSERT_ERR_PTR(link, \"fail_4\"))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(libbpf_get_error(link), -EINVAL, \"fail_4_error\"))\n\t\tgoto cleanup;\n\n\t \n\topts.addrs = NULL;\n\topts.syms = NULL;\n\topts.cnt = 0;\n\topts.cookies = cookies;\n\n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_manual,\n\t\t\t\t\t\t     \"ksys_*\", &opts);\n\tif (!ASSERT_ERR_PTR(link, \"fail_5\"))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(libbpf_get_error(link), -EINVAL, \"fail_5_error\"))\n\t\tgoto cleanup;\n\ncleanup:\n\tbpf_link__destroy(link);\n\tkprobe_multi__destroy(skel);\n}\n\nstatic size_t symbol_hash(long key, void *ctx __maybe_unused)\n{\n\treturn str_hash((const char *) key);\n}\n\nstatic bool symbol_equal(long key1, long key2, void *ctx __maybe_unused)\n{\n\treturn strcmp((const char *) key1, (const char *) key2) == 0;\n}\n\nstatic int get_syms(char ***symsp, size_t *cntp, bool kernel)\n{\n\tsize_t cap = 0, cnt = 0, i;\n\tchar *name = NULL, **syms = NULL;\n\tstruct hashmap *map;\n\tchar buf[256];\n\tFILE *f;\n\tint err = 0;\n\n\t \n\n\tif (access(\"/sys/kernel/tracing/trace\", F_OK) == 0)\n\t\tf = fopen(\"/sys/kernel/tracing/available_filter_functions\", \"r\");\n\telse\n\t\tf = fopen(\"/sys/kernel/debug/tracing/available_filter_functions\", \"r\");\n\n\tif (!f)\n\t\treturn -EINVAL;\n\n\tmap = hashmap__new(symbol_hash, symbol_equal, NULL);\n\tif (IS_ERR(map)) {\n\t\terr = libbpf_get_error(map);\n\t\tgoto error;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tif (kernel && strchr(buf, '['))\n\t\t\tcontinue;\n\t\tif (!kernel && !strchr(buf, '['))\n\t\t\tcontinue;\n\n\t\tfree(name);\n\t\tif (sscanf(buf, \"%ms$*[^\\n]\\n\", &name) != 1)\n\t\t\tcontinue;\n\t\t \n\t\tif (!strcmp(name, \"arch_cpu_idle\"))\n\t\t\tcontinue;\n\t\tif (!strcmp(name, \"default_idle\"))\n\t\t\tcontinue;\n\t\tif (!strncmp(name, \"rcu_\", 4))\n\t\t\tcontinue;\n\t\tif (!strcmp(name, \"bpf_dispatcher_xdp_func\"))\n\t\t\tcontinue;\n\t\tif (!strncmp(name, \"__ftrace_invalid_address__\",\n\t\t\t     sizeof(\"__ftrace_invalid_address__\") - 1))\n\t\t\tcontinue;\n\n\t\terr = hashmap__add(map, name, 0);\n\t\tif (err == -EEXIST) {\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\terr = libbpf_ensure_mem((void **) &syms, &cap,\n\t\t\t\t\tsizeof(*syms), cnt + 1);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tsyms[cnt++] = name;\n\t\tname = NULL;\n\t}\n\n\t*symsp = syms;\n\t*cntp = cnt;\n\nerror:\n\tfree(name);\n\tfclose(f);\n\thashmap__free(map);\n\tif (err) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tfree(syms[i]);\n\t\tfree(syms);\n\t}\n\treturn err;\n}\n\nstatic void test_kprobe_multi_bench_attach(bool kernel)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tstruct kprobe_multi_empty *skel = NULL;\n\tlong attach_start_ns, attach_end_ns;\n\tlong detach_start_ns, detach_end_ns;\n\tdouble attach_delta, detach_delta;\n\tstruct bpf_link *link = NULL;\n\tchar **syms = NULL;\n\tsize_t cnt = 0, i;\n\n\tif (!ASSERT_OK(get_syms(&syms, &cnt, kernel), \"get_syms\"))\n\t\treturn;\n\n\tskel = kprobe_multi_empty__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"kprobe_multi_empty__open_and_load\"))\n\t\tgoto cleanup;\n\n\topts.syms = (const char **) syms;\n\topts.cnt = cnt;\n\n\tattach_start_ns = get_time_ns();\n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe_empty,\n\t\t\t\t\t\t     NULL, &opts);\n\tattach_end_ns = get_time_ns();\n\n\tif (!ASSERT_OK_PTR(link, \"bpf_program__attach_kprobe_multi_opts\"))\n\t\tgoto cleanup;\n\n\tdetach_start_ns = get_time_ns();\n\tbpf_link__destroy(link);\n\tdetach_end_ns = get_time_ns();\n\n\tattach_delta = (attach_end_ns - attach_start_ns) / 1000000000.0;\n\tdetach_delta = (detach_end_ns - detach_start_ns) / 1000000000.0;\n\n\tprintf(\"%s: found %lu functions\\n\", __func__, cnt);\n\tprintf(\"%s: attached in %7.3lfs\\n\", __func__, attach_delta);\n\tprintf(\"%s: detached in %7.3lfs\\n\", __func__, detach_delta);\n\ncleanup:\n\tkprobe_multi_empty__destroy(skel);\n\tif (syms) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tfree(syms[i]);\n\t\tfree(syms);\n\t}\n}\n\nstatic void test_attach_override(void)\n{\n\tstruct kprobe_multi_override *skel = NULL;\n\tstruct bpf_link *link = NULL;\n\n\tskel = kprobe_multi_override__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"kprobe_multi_empty__open_and_load\"))\n\t\tgoto cleanup;\n\n\t \n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_override,\n\t\t\t\t\t\t     \"bpf_fentry_test1\", NULL);\n\tif (!ASSERT_ERR_PTR(link, \"override_attached_bpf_fentry_test1\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tlink = bpf_program__attach_kprobe_multi_opts(skel->progs.test_override,\n\t\t\t\t\t\t     \"should_fail_bio\", NULL);\n\tif (!ASSERT_OK_PTR(link, \"override_attached_should_fail_bio\"))\n\t\tgoto cleanup;\n\n\tbpf_link__destroy(link);\n\ncleanup:\n\tkprobe_multi_override__destroy(skel);\n}\n\nvoid serial_test_kprobe_multi_bench_attach(void)\n{\n\tif (test__start_subtest(\"kernel\"))\n\t\ttest_kprobe_multi_bench_attach(true);\n\tif (test__start_subtest(\"modules\"))\n\t\ttest_kprobe_multi_bench_attach(false);\n}\n\nvoid test_kprobe_multi_test(void)\n{\n\tif (!ASSERT_OK(load_kallsyms(), \"load_kallsyms\"))\n\t\treturn;\n\n\tif (test__start_subtest(\"skel_api\"))\n\t\ttest_skel_api();\n\tif (test__start_subtest(\"link_api_addrs\"))\n\t\ttest_link_api_syms();\n\tif (test__start_subtest(\"link_api_syms\"))\n\t\ttest_link_api_addrs();\n\tif (test__start_subtest(\"attach_api_pattern\"))\n\t\ttest_attach_api_pattern();\n\tif (test__start_subtest(\"attach_api_addrs\"))\n\t\ttest_attach_api_addrs();\n\tif (test__start_subtest(\"attach_api_syms\"))\n\t\ttest_attach_api_syms();\n\tif (test__start_subtest(\"attach_api_fails\"))\n\t\ttest_attach_api_fails();\n\tif (test__start_subtest(\"attach_override\"))\n\t\ttest_attach_override();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}