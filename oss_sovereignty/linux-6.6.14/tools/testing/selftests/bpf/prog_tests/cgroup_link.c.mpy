{
  "module_name": "cgroup_link.c",
  "hash_id": "56fe27f92acdfdcf9cd11277a87a2122e8a6e1f50dd5f08d8bd4156e2fd080ed",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cgroup_link.c",
  "human_readable_source": "\n\n#include <test_progs.h>\n#include \"cgroup_helpers.h\"\n#include \"testing_helpers.h\"\n#include \"test_cgroup_link.skel.h\"\n\nstatic __u32 duration = 0;\n#define PING_CMD\t\"ping -q -c1 -w1 127.0.0.1 > /dev/null\"\n\nstatic struct test_cgroup_link *skel = NULL;\n\nint ping_and_check(int exp_calls, int exp_alt_calls)\n{\n\tskel->bss->calls = 0;\n\tskel->bss->alt_calls = 0;\n\tCHECK_FAIL(system(PING_CMD));\n\tif (CHECK(skel->bss->calls != exp_calls, \"call_cnt\",\n\t\t  \"exp %d, got %d\\n\", exp_calls, skel->bss->calls))\n\t\treturn -EINVAL;\n\tif (CHECK(skel->bss->alt_calls != exp_alt_calls, \"alt_call_cnt\",\n\t\t  \"exp %d, got %d\\n\", exp_alt_calls, skel->bss->alt_calls))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nvoid serial_test_cgroup_link(void)\n{\n\tstruct {\n\t\tconst char *path;\n\t\tint fd;\n\t} cgs[] = {\n\t\t{ \"/cg1\" },\n\t\t{ \"/cg1/cg2\" },\n\t\t{ \"/cg1/cg2/cg3\" },\n\t\t{ \"/cg1/cg2/cg3/cg4\" },\n\t};\n\tint last_cg = ARRAY_SIZE(cgs) - 1, cg_nr = ARRAY_SIZE(cgs);\n\tDECLARE_LIBBPF_OPTS(bpf_link_update_opts, link_upd_opts);\n\tstruct bpf_link *links[ARRAY_SIZE(cgs)] = {}, *tmp_link;\n\t__u32 prog_ids[ARRAY_SIZE(cgs)], prog_cnt = 0, attach_flags, prog_id;\n\tstruct bpf_link_info info;\n\tint i = 0, err, prog_fd;\n\tbool detach_legacy = false;\n\n\tskel = test_cgroup_link__open_and_load();\n\tif (CHECK(!skel, \"skel_open_load\", \"failed to open/load skeleton\\n\"))\n\t\treturn;\n\tprog_fd = bpf_program__fd(skel->progs.egress);\n\n\terr = setup_cgroup_environment();\n\tif (CHECK(err, \"cg_init\", \"failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < cg_nr; i++) {\n\t\tcgs[i].fd = create_and_get_cgroup(cgs[i].path);\n\t\tif (!ASSERT_GE(cgs[i].fd, 0, \"cg_create\"))\n\t\t\tgoto cleanup;\n\t}\n\n\terr = join_cgroup(cgs[last_cg].path);\n\tif (CHECK(err, \"cg_join\", \"fail: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < cg_nr; i++) {\n\t\tlinks[i] = bpf_program__attach_cgroup(skel->progs.egress,\n\t\t\t\t\t\t      cgs[i].fd);\n\t\tif (!ASSERT_OK_PTR(links[i], \"cg_attach\"))\n\t\t\tgoto cleanup;\n\t}\n\n\tping_and_check(cg_nr, 0);\n\n\t \n\terr = bpf_prog_query(cgs[0].fd, BPF_CGROUP_INET_EGRESS,\n\t\t\t     0, &attach_flags, NULL, &prog_cnt);\n\tCHECK_FAIL(err);\n\tCHECK_FAIL(attach_flags != BPF_F_ALLOW_MULTI);\n\tif (CHECK(prog_cnt != 1, \"effect_cnt\", \"exp %d, got %d\\n\", 1, prog_cnt))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_prog_query(cgs[last_cg].fd, BPF_CGROUP_INET_EGRESS,\n\t\t\t     BPF_F_QUERY_EFFECTIVE, NULL, NULL,\n\t\t\t     &prog_cnt);\n\tCHECK_FAIL(err);\n\tif (CHECK(prog_cnt != cg_nr, \"effect_cnt\", \"exp %d, got %d\\n\",\n\t\t  cg_nr, prog_cnt))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_prog_query(cgs[last_cg].fd, BPF_CGROUP_INET_EGRESS,\n\t\t\t     BPF_F_QUERY_EFFECTIVE, NULL, prog_ids,\n\t\t\t     &prog_cnt);\n\tCHECK_FAIL(err);\n\tif (CHECK(prog_cnt != cg_nr, \"effect_cnt\", \"exp %d, got %d\\n\",\n\t\t  cg_nr, prog_cnt))\n\t\tgoto cleanup;\n\tfor (i = 1; i < prog_cnt; i++) {\n\t\tCHECK(prog_ids[i - 1] != prog_ids[i], \"prog_id_check\",\n\t\t      \"idx %d, prev id %d, cur id %d\\n\",\n\t\t      i, prog_ids[i - 1], prog_ids[i]);\n\t}\n\n\t \n\tbpf_link__destroy(links[last_cg]);\n\tlinks[last_cg] = NULL;\n\n\tping_and_check(cg_nr - 1, 0);\n\n\t \n\terr = bpf_prog_attach(prog_fd, cgs[last_cg].fd,\n\t\t\t      BPF_CGROUP_INET_EGRESS, BPF_F_ALLOW_MULTI);\n\tif (CHECK(err, \"cg_attach_legacy\", \"errno=%d\\n\", errno))\n\t\tgoto cleanup;\n\tdetach_legacy = true;\n\n\tlinks[last_cg] = bpf_program__attach_cgroup(skel->progs.egress,\n\t\t\t\t\t\t    cgs[last_cg].fd);\n\tif (!ASSERT_OK_PTR(links[last_cg], \"cg_attach\"))\n\t\tgoto cleanup;\n\n\tping_and_check(cg_nr + 1, 0);\n\n\t \n\tbpf_link__destroy(links[last_cg]);\n\tlinks[last_cg] = NULL;\n\n\t \n\terr = bpf_prog_detach2(prog_fd, cgs[last_cg].fd, BPF_CGROUP_INET_EGRESS);\n\tif (CHECK(err, \"cg_detach_legacy\", \"errno=%d\\n\", errno))\n\t\tgoto cleanup;\n\tdetach_legacy = false;\n\n\t \n\terr = bpf_prog_attach(prog_fd, cgs[last_cg].fd,\n\t\t\t      BPF_CGROUP_INET_EGRESS, 0);\n\tif (CHECK(err, \"cg_attach_exclusive\", \"errno=%d\\n\", errno))\n\t\tgoto cleanup;\n\tdetach_legacy = true;\n\n\t \n\ttmp_link = bpf_program__attach_cgroup(skel->progs.egress,\n\t\t\t\t\t      cgs[last_cg].fd);\n\tif (!ASSERT_ERR_PTR(tmp_link, \"cg_attach_fail\")) {\n\t\tbpf_link__destroy(tmp_link);\n\t\tgoto cleanup;\n\t}\n\n\tping_and_check(cg_nr, 0);\n\n\t \n\terr = bpf_prog_detach2(prog_fd, cgs[last_cg].fd, BPF_CGROUP_INET_EGRESS);\n\tif (CHECK(err, \"cg_detach_legacy\", \"errno=%d\\n\", errno))\n\t\tgoto cleanup;\n\tdetach_legacy = false;\n\n\tping_and_check(cg_nr - 1, 0);\n\n\t \n\tlinks[last_cg] = bpf_program__attach_cgroup(skel->progs.egress,\n\t\t\t\t\t\t    cgs[last_cg].fd);\n\tif (!ASSERT_OK_PTR(links[last_cg], \"cg_attach\"))\n\t\tgoto cleanup;\n\n\tping_and_check(cg_nr, 0);\n\n\t \n\terr = bpf_prog_attach(prog_fd, cgs[last_cg].fd,\n\t\t\t      BPF_CGROUP_INET_EGRESS, 0);\n\tif (CHECK(!err, \"cg_attach_exclusive\", \"unexpected success\")) {\n\t\tbpf_prog_detach2(prog_fd, cgs[last_cg].fd, BPF_CGROUP_INET_EGRESS);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tfor (i = 1; i < cg_nr; i++) {\n\t\terr = bpf_link__update_program(links[i], skel->progs.egress_alt);\n\t\tif (CHECK(err, \"prog_upd\", \"link #%d\\n\", i))\n\t\t\tgoto cleanup;\n\t}\n\n\tping_and_check(1, cg_nr - 1);\n\n\t \n\tlink_upd_opts.old_prog_fd = bpf_program__fd(skel->progs.egress_alt);\n\tlink_upd_opts.flags = BPF_F_REPLACE;\n\terr = bpf_link_update(bpf_link__fd(links[0]),\n\t\t\t      bpf_program__fd(skel->progs.egress_alt),\n\t\t\t      &link_upd_opts);\n\tif (CHECK(err == 0 || errno != EPERM, \"prog_cmpxchg1\",\n\t\t  \"unexpectedly succeeded, err %d, errno %d\\n\", err, -errno))\n\t\tgoto cleanup;\n\n\t \n\tlink_upd_opts.old_prog_fd = bpf_program__fd(skel->progs.egress);\n\tlink_upd_opts.flags = BPF_F_REPLACE;\n\terr = bpf_link_update(bpf_link__fd(links[0]),\n\t\t\t      bpf_program__fd(skel->progs.egress_alt),\n\t\t\t      &link_upd_opts);\n\tif (CHECK(err, \"prog_cmpxchg2\", \"errno %d\\n\", -errno))\n\t\tgoto cleanup;\n\n\t \n\tping_and_check(0, cg_nr);\n\n\t \n\tfor (i = 0; i < cg_nr; i++) {\n\t\tif (cgs[i].fd > 0) {\n\t\t\tclose(cgs[i].fd);\n\t\t\tcgs[i].fd = -1;\n\t\t}\n\t}\n\n\t \n\tping_and_check(0, cg_nr);\n\n\tprog_id = link_info_prog_id(links[0], &info);\n\tCHECK(prog_id == 0, \"link_info\", \"failed\\n\");\n\tCHECK(info.cgroup.cgroup_id == 0, \"cgroup_id\", \"unexpected %llu\\n\", info.cgroup.cgroup_id);\n\n\terr = bpf_link__detach(links[0]);\n\tif (CHECK(err, \"link_detach\", \"failed %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tprog_id = link_info_prog_id(links[0], &info);\n\tCHECK(prog_id == 0, \"link_info\", \"failed\\n\");\n\tCHECK(info.cgroup.cgroup_id != 0, \"cgroup_id\", \"unexpected %llu\\n\", info.cgroup.cgroup_id);\n\n\t \n\tping_and_check(0, cg_nr - 1);\n\n\t \n\tcleanup_cgroup_environment();\n\n\t \n\tping_and_check(0, 0);\n\ncleanup:\n\tif (detach_legacy)\n\t\tbpf_prog_detach2(prog_fd, cgs[last_cg].fd,\n\t\t\t\t BPF_CGROUP_INET_EGRESS);\n\n\tfor (i = 0; i < cg_nr; i++) {\n\t\tbpf_link__destroy(links[i]);\n\t}\n\ttest_cgroup_link__destroy(skel);\n\n\tfor (i = 0; i < cg_nr; i++) {\n\t\tif (cgs[i].fd > 0)\n\t\t\tclose(cgs[i].fd);\n\t}\n\tcleanup_cgroup_environment();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}