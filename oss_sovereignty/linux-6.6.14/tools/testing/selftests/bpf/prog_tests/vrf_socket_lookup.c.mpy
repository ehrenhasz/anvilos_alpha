{
  "module_name": "vrf_socket_lookup.c",
  "hash_id": "ecc8a176abb089b032adbd0ea2672174081daa0b035835097088c1d043719e27",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/vrf_socket_lookup.c",
  "human_readable_source": "\n\n \n\n#include <net/if.h>\n\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n#include \"vrf_socket_lookup.skel.h\"\n\n#define NS0 \"vrf_socket_lookup_0\"\n#define NS1 \"vrf_socket_lookup_1\"\n\n#define IP4_ADDR_VETH01 \"172.16.1.100\"\n#define IP4_ADDR_VETH10 \"172.16.1.200\"\n#define IP4_ADDR_VETH02 \"172.16.2.100\"\n#define IP4_ADDR_VETH20 \"172.16.2.200\"\n\n#define NON_VRF_PORT 5000\n#define IN_VRF_PORT 5001\n\n#define TIMEOUT_MS 3000\n\nstatic int make_socket(int sotype, const char *ip, int port,\n\t\t       struct sockaddr_storage *addr)\n{\n\tint err, fd;\n\n\terr = make_sockaddr(AF_INET, ip, port, addr, NULL);\n\tif (!ASSERT_OK(err, \"make_address\"))\n\t\treturn -1;\n\n\tfd = socket(AF_INET, sotype, 0);\n\tif (!ASSERT_GE(fd, 0, \"socket\"))\n\t\treturn -1;\n\n\tif (!ASSERT_OK(settimeo(fd, TIMEOUT_MS), \"settimeo\"))\n\t\tgoto fail;\n\n\treturn fd;\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int make_server(int sotype, const char *ip, int port, const char *ifname)\n{\n\tint err, fd = -1;\n\n\tfd = start_server(AF_INET, sotype, ip, port, TIMEOUT_MS);\n\tif (!ASSERT_GE(fd, 0, \"start_server\"))\n\t\treturn -1;\n\n\tif (ifname) {\n\t\terr = setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t ifname, strlen(ifname) + 1);\n\t\tif (!ASSERT_OK(err, \"setsockopt(SO_BINDTODEVICE)\"))\n\t\t\tgoto fail;\n\t}\n\n\treturn fd;\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int attach_progs(char *ifname, int tc_prog_fd, int xdp_prog_fd)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, hook, .attach_point = BPF_TC_INGRESS);\n\tLIBBPF_OPTS(bpf_tc_opts, opts, .handle = 1, .priority = 1,\n\t\t    .prog_fd = tc_prog_fd);\n\tint ret, ifindex;\n\n\tifindex = if_nametoindex(ifname);\n\tif (!ASSERT_NEQ(ifindex, 0, \"if_nametoindex\"))\n\t\treturn -1;\n\thook.ifindex = ifindex;\n\n\tret = bpf_tc_hook_create(&hook);\n\tif (!ASSERT_OK(ret, \"bpf_tc_hook_create\"))\n\t\treturn ret;\n\n\tret = bpf_tc_attach(&hook, &opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_attach\")) {\n\t\tbpf_tc_hook_destroy(&hook);\n\t\treturn ret;\n\t}\n\tret = bpf_xdp_attach(ifindex, xdp_prog_fd, 0, NULL);\n\tif (!ASSERT_OK(ret, \"bpf_xdp_attach\")) {\n\t\tbpf_tc_hook_destroy(&hook);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void cleanup(void)\n{\n\tSYS_NOFAIL(\"test -f /var/run/netns/\" NS0 \" && ip netns delete \"\n\t\t   NS0);\n\tSYS_NOFAIL(\"test -f /var/run/netns/\" NS1 \" && ip netns delete \"\n\t\t   NS1);\n}\n\nstatic int setup(struct vrf_socket_lookup *skel)\n{\n\tint tc_prog_fd, xdp_prog_fd, ret = 0;\n\tstruct nstoken *nstoken = NULL;\n\n\tSYS(fail, \"ip netns add \" NS0);\n\tSYS(fail, \"ip netns add \" NS1);\n\n\t \n\tSYS(fail, \"ip link add veth01 netns \" NS0 \" type veth peer name veth10\"\n\t    \" netns \" NS1);\n\tSYS(fail, \"ip -net \" NS0 \" addr add \" IP4_ADDR_VETH01 \"/24 dev veth01\");\n\tSYS(fail, \"ip -net \" NS0 \" link set dev veth01 up\");\n\tSYS(fail, \"ip -net \" NS1 \" addr add \" IP4_ADDR_VETH10 \"/24 dev veth10\");\n\tSYS(fail, \"ip -net \" NS1 \" link set dev veth10 up\");\n\n\t \n\tSYS(fail, \"ip link add veth02 netns \" NS0 \" type veth peer name veth20\"\n\t    \" netns \" NS1);\n\tSYS(fail, \"ip -net \" NS0 \" addr add \" IP4_ADDR_VETH02 \"/24 dev veth02\");\n\tSYS(fail, \"ip -net \" NS0 \" link set dev veth02 up\");\n\tSYS(fail, \"ip -net \" NS1 \" addr add \" IP4_ADDR_VETH20 \"/24 dev veth20\");\n\tSYS(fail, \"ip -net \" NS1 \" link set dev veth20 up\");\n\n\t \n\tSYS(fail, \"ip -net \" NS0 \" link add vrf1 type vrf table 11\");\n\tSYS(fail, \"ip -net \" NS0 \" route add vrf vrf1 unreachable default\"\n\t    \" metric 4278198272\");\n\tSYS(fail, \"ip -net \" NS0 \" link set vrf1 alias vrf\");\n\tSYS(fail, \"ip -net \" NS0 \" link set vrf1 up\");\n\tSYS(fail, \"ip -net \" NS0 \" link set veth02 master vrf1\");\n\n\t \n\tnstoken = open_netns(NS0);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS0))\n\t\tgoto fail;\n\ttc_prog_fd = bpf_program__fd(skel->progs.tc_socket_lookup);\n\tif (!ASSERT_GE(tc_prog_fd, 0, \"bpf_program__tc_fd\"))\n\t\tgoto fail;\n\txdp_prog_fd = bpf_program__fd(skel->progs.xdp_socket_lookup);\n\tif (!ASSERT_GE(xdp_prog_fd, 0, \"bpf_program__xdp_fd\"))\n\t\tgoto fail;\n\n\tif (attach_progs(\"veth01\", tc_prog_fd, xdp_prog_fd))\n\t\tgoto fail;\n\n\tif (attach_progs(\"veth02\", tc_prog_fd, xdp_prog_fd))\n\t\tgoto fail;\n\n\tgoto close;\nfail:\n\tret = -1;\nclose:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\treturn ret;\n}\n\nstatic int test_lookup(struct vrf_socket_lookup *skel, int sotype,\n\t\t       const char *ip, int port, bool test_xdp, bool tcp_skc,\n\t\t       int lookup_status_exp)\n{\n\tstatic const char msg[] = \"Hello Server\";\n\tstruct sockaddr_storage addr = {};\n\tint fd, ret = 0;\n\n\tfd = make_socket(sotype, ip, port, &addr);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tskel->bss->test_xdp = test_xdp;\n\tskel->bss->tcp_skc = tcp_skc;\n\tskel->bss->lookup_status = -1;\n\n\tif (sotype == SOCK_STREAM)\n\t\tconnect(fd, (void *)&addr, sizeof(struct sockaddr_in));\n\telse\n\t\tsendto(fd, msg, sizeof(msg), 0, (void *)&addr,\n\t\t       sizeof(struct sockaddr_in));\n\n\tif (!ASSERT_EQ(skel->bss->lookup_status, lookup_status_exp,\n\t\t       \"lookup_status\"))\n\t\tgoto fail;\n\n\tgoto close;\n\nfail:\n\tret = -1;\nclose:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void _test_vrf_socket_lookup(struct vrf_socket_lookup *skel, int sotype,\n\t\t\t\t    bool test_xdp, bool tcp_skc)\n{\n\tint in_vrf_server = -1, non_vrf_server = -1;\n\tstruct nstoken *nstoken = NULL;\n\n\tnstoken = open_netns(NS0);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS0))\n\t\tgoto done;\n\n\t \n\tnon_vrf_server = make_server(sotype, \"0.0.0.0\", NON_VRF_PORT, NULL);\n\tif (!ASSERT_GE(non_vrf_server, 0, \"make_server__outside_vrf_fd\"))\n\t\tgoto done;\n\n\tin_vrf_server = make_server(sotype, \"0.0.0.0\", IN_VRF_PORT, \"veth02\");\n\tif (!ASSERT_GE(in_vrf_server, 0, \"make_server__in_vrf_fd\"))\n\t\tgoto done;\n\n\t \n\tclose_netns(nstoken);\n\tnstoken = open_netns(NS1);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS1))\n\t\tgoto done;\n\n\tif (!ASSERT_OK(test_lookup(skel, sotype, IP4_ADDR_VETH02, NON_VRF_PORT,\n\t\t\t\t   test_xdp, tcp_skc, 0), \"in_to_out\"))\n\t\tgoto done;\n\tif (!ASSERT_OK(test_lookup(skel, sotype, IP4_ADDR_VETH02, IN_VRF_PORT,\n\t\t\t\t   test_xdp, tcp_skc, 1), \"in_to_in\"))\n\t\tgoto done;\n\tif (!ASSERT_OK(test_lookup(skel, sotype, IP4_ADDR_VETH01, NON_VRF_PORT,\n\t\t\t\t   test_xdp, tcp_skc, 1), \"out_to_out\"))\n\t\tgoto done;\n\tif (!ASSERT_OK(test_lookup(skel, sotype, IP4_ADDR_VETH01, IN_VRF_PORT,\n\t\t\t\t   test_xdp, tcp_skc, 0), \"out_to_in\"))\n\t\tgoto done;\n\ndone:\n\tif (non_vrf_server >= 0)\n\t\tclose(non_vrf_server);\n\tif (in_vrf_server >= 0)\n\t\tclose(in_vrf_server);\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n}\n\nvoid test_vrf_socket_lookup(void)\n{\n\tstruct vrf_socket_lookup *skel;\n\n\tcleanup();\n\n\tskel = vrf_socket_lookup__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"vrf_socket_lookup__open_and_load\"))\n\t\treturn;\n\n\tif (!ASSERT_OK(setup(skel), \"setup\"))\n\t\tgoto done;\n\n\tif (test__start_subtest(\"tc_socket_lookup_tcp\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, false, false);\n\tif (test__start_subtest(\"tc_socket_lookup_tcp_skc\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, false, false);\n\tif (test__start_subtest(\"tc_socket_lookup_udp\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, false, false);\n\tif (test__start_subtest(\"xdp_socket_lookup_tcp\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, true, false);\n\tif (test__start_subtest(\"xdp_socket_lookup_tcp_skc\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, true, false);\n\tif (test__start_subtest(\"xdp_socket_lookup_udp\"))\n\t\t_test_vrf_socket_lookup(skel, SOCK_STREAM, true, false);\n\ndone:\n\tvrf_socket_lookup__destroy(skel);\n\tcleanup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}