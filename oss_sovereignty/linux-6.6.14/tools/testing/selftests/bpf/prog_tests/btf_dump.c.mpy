{
  "module_name": "btf_dump.c",
  "hash_id": "646ab6616e0e7db2a43c36e2e86ba256854aade2cea0d17ef66875d7ba07415b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_dump.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <bpf/btf.h>\n\nstatic int duration = 0;\n\nvoid btf_dump_printf(void *ctx, const char *fmt, va_list args)\n{\n\tvfprintf(ctx, fmt, args);\n}\n\nstatic struct btf_dump_test_case {\n\tconst char *name;\n\tconst char *file;\n\tbool known_ptr_sz;\n} btf_dump_test_cases[] = {\n\t{\"btf_dump: syntax\", \"btf_dump_test_case_syntax\", true},\n\t{\"btf_dump: ordering\", \"btf_dump_test_case_ordering\", false},\n\t{\"btf_dump: padding\", \"btf_dump_test_case_padding\", true},\n\t{\"btf_dump: packing\", \"btf_dump_test_case_packing\", true},\n\t{\"btf_dump: bitfields\", \"btf_dump_test_case_bitfields\", true},\n\t{\"btf_dump: multidim\", \"btf_dump_test_case_multidim\", false},\n\t{\"btf_dump: namespacing\", \"btf_dump_test_case_namespacing\", false},\n};\n\nstatic int btf_dump_all_types(const struct btf *btf, void *ctx)\n{\n\tsize_t type_cnt = btf__type_cnt(btf);\n\tstruct btf_dump *d;\n\tint err = 0, id;\n\n\td = btf_dump__new(btf, btf_dump_printf, ctx, NULL);\n\terr = libbpf_get_error(d);\n\tif (err)\n\t\treturn err;\n\n\tfor (id = 1; id < type_cnt; id++) {\n\t\terr = btf_dump__dump_type(d, id);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tbtf_dump__free(d);\n\treturn err;\n}\n\nstatic int test_btf_dump_case(int n, struct btf_dump_test_case *t)\n{\n\tchar test_file[256], out_file[256], diff_cmd[1024];\n\tstruct btf *btf = NULL;\n\tint err = 0, fd = -1;\n\tFILE *f = NULL;\n\n\tsnprintf(test_file, sizeof(test_file), \"%s.bpf.o\", t->file);\n\n\tbtf = btf__parse_elf(test_file, NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse_elf\")) {\n\t\terr = -PTR_ERR(btf);\n\t\tbtf = NULL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!t->known_ptr_sz) {\n\t\tbtf__set_pointer_size(btf, 8);\n\t} else {\n\t\tCHECK(btf__pointer_size(btf) != 8, \"ptr_sz\", \"exp %d, got %zu\\n\",\n\t\t      8, btf__pointer_size(btf));\n\t}\n\n\tsnprintf(out_file, sizeof(out_file), \"/tmp/%s.output.XXXXXX\", t->file);\n\tfd = mkstemp(out_file);\n\tif (!ASSERT_GE(fd, 0, \"create_tmp\")) {\n\t\terr = fd;\n\t\tgoto done;\n\t}\n\tf = fdopen(fd, \"w\");\n\tif (CHECK(f == NULL, \"open_tmp\",  \"failed to open file: %s(%d)\\n\",\n\t\t  strerror(errno), errno)) {\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\n\terr = btf_dump_all_types(btf, f);\n\tfclose(f);\n\tclose(fd);\n\tif (CHECK(err, \"btf_dump\", \"failure during C dumping: %d\\n\", err)) {\n\t\tgoto done;\n\t}\n\n\tsnprintf(test_file, sizeof(test_file), \"progs/%s.c\", t->file);\n\tif (access(test_file, R_OK) == -1)\n\t\t \n\t\tsnprintf(test_file, sizeof(test_file), \"%s.c\", t->file);\n\t \n\tsnprintf(diff_cmd, sizeof(diff_cmd),\n\t\t \"awk '/START-EXPECTED-OUTPUT/{out=1;next} \"\n\t\t \"/END-EXPECTED-OUTPUT/{out=0} \"\n\t\t \"/\\\\/\\\\*|\\\\*\\\\\n\t\t \"out {sub(/^[ \\\\t]*\\\\*/, \\\"\\\"); print}' '%s' | diff -u - '%s'\",\n\t\t test_file, out_file);\n\terr = system(diff_cmd);\n\tif (CHECK(err, \"diff\",\n\t\t  \"differing test output, output=%s, err=%d, diff cmd:\\n%s\\n\",\n\t\t  out_file, err, diff_cmd))\n\t\tgoto done;\n\n\tremove(out_file);\n\ndone:\n\tbtf__free(btf);\n\treturn err;\n}\n\nstatic char *dump_buf;\nstatic size_t dump_buf_sz;\nstatic FILE *dump_buf_file;\n\nstatic void test_btf_dump_incremental(void)\n{\n\tstruct btf *btf = NULL;\n\tstruct btf_dump *d = NULL;\n\tint id, err, i;\n\n\tdump_buf_file = open_memstream(&dump_buf, &dump_buf_sz);\n\tif (!ASSERT_OK_PTR(dump_buf_file, \"dump_memstream\"))\n\t\treturn;\n\tbtf = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf, \"new_empty\"))\n\t\tgoto err_out;\n\td = btf_dump__new(btf, btf_dump_printf, dump_buf_file, NULL);\n\tif (!ASSERT_OK(libbpf_get_error(d), \"btf_dump__new\"))\n\t\tgoto err_out;\n\n\t \n\tid = btf__add_enum(btf, \"x\", 4);\n\tASSERT_EQ(id, 1, \"enum_declaration_id\");\n\tid = btf__add_enum(btf, \"x\", 4);\n\tASSERT_EQ(id, 2, \"named_enum_id\");\n\terr = btf__add_enum_value(btf, \"X\", 1);\n\tASSERT_OK(err, \"named_enum_val_ok\");\n\n\tid = btf__add_enum(btf, NULL, 4);\n\tASSERT_EQ(id, 3, \"anon_enum_id\");\n\terr = btf__add_enum_value(btf, \"Y\", 1);\n\tASSERT_OK(err, \"anon_enum_val_ok\");\n\n\tid = btf__add_int(btf, \"int\", 4, BTF_INT_SIGNED);\n\tASSERT_EQ(id, 4, \"int_id\");\n\n\tid = btf__add_fwd(btf, \"s\", BTF_FWD_STRUCT);\n\tASSERT_EQ(id, 5, \"fwd_id\");\n\n\tid = btf__add_struct(btf, \"s\", 4);\n\tASSERT_EQ(id, 6, \"struct_id\");\n\terr = btf__add_field(btf, \"x\", 4, 0, 0);\n\tASSERT_OK(err, \"field_ok\");\n\n\tfor (i = 1; i < btf__type_cnt(btf); i++) {\n\t\terr = btf_dump__dump_type(d, i);\n\t\tASSERT_OK(err, \"dump_type_ok\");\n\t}\n\n\tfflush(dump_buf_file);\n\tdump_buf[dump_buf_sz] = 0;  \n\n\tASSERT_STREQ(dump_buf,\n\"enum x;\\n\"\n\"\\n\"\n\"enum x {\\n\"\n\"\tX = 1,\\n\"\n\"};\\n\"\n\"\\n\"\n\"enum {\\n\"\n\"\tY = 1,\\n\"\n\"};\\n\"\n\"\\n\"\n\"struct s;\\n\"\n\"\\n\"\n\"struct s {\\n\"\n\"\tint x;\\n\"\n\"};\\n\\n\", \"c_dump1\");\n\n\t \n\tfseek(dump_buf_file, 0, SEEK_SET);\n\n\tid = btf__add_struct(btf, \"s\", 4);\n\tASSERT_EQ(id, 7, \"struct_id\");\n\terr = btf__add_field(btf, \"x\", 2, 0, 0);\n\tASSERT_OK(err, \"field_ok\");\n\terr = btf__add_field(btf, \"y\", 3, 32, 0);\n\tASSERT_OK(err, \"field_ok\");\n\terr = btf__add_field(btf, \"s\", 6, 64, 0);\n\tASSERT_OK(err, \"field_ok\");\n\n\tfor (i = 1; i < btf__type_cnt(btf); i++) {\n\t\terr = btf_dump__dump_type(d, i);\n\t\tASSERT_OK(err, \"dump_type_ok\");\n\t}\n\n\tfflush(dump_buf_file);\n\tdump_buf[dump_buf_sz] = 0;  \n\tASSERT_STREQ(dump_buf,\n\"struct s___2 {\\n\"\n\"\tenum x x;\\n\"\n\"\tenum {\\n\"\n\"\t\tY___2 = 1,\\n\"\n\"\t} y;\\n\"\n\"\tstruct s s;\\n\"\n\"};\\n\\n\" , \"c_dump1\");\n\nerr_out:\n\tfclose(dump_buf_file);\n\tfree(dump_buf);\n\tbtf_dump__free(d);\n\tbtf__free(btf);\n}\n\n#define STRSIZE\t\t\t\t4096\n\nstatic void btf_dump_snprintf(void *ctx, const char *fmt, va_list args)\n{\n\tchar *s = ctx, new[STRSIZE];\n\n\tvsnprintf(new, STRSIZE, fmt, args);\n\tif (strlen(s) < STRSIZE)\n\t\tstrncat(s, new, STRSIZE - strlen(s) - 1);\n}\n\nstatic int btf_dump_data(struct btf *btf, struct btf_dump *d,\n\t\t\t char *name, char *prefix, __u64 flags, void *ptr,\n\t\t\t size_t ptr_sz, char *str, const char *expected_val)\n{\n\tDECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);\n\tsize_t type_sz;\n\t__s32 type_id;\n\tint ret = 0;\n\n\tif (flags & BTF_F_COMPACT)\n\t\topts.compact = true;\n\tif (flags & BTF_F_NONAME)\n\t\topts.skip_names = true;\n\tif (flags & BTF_F_ZERO)\n\t\topts.emit_zeroes = true;\n\tif (prefix) {\n\t\tASSERT_STRNEQ(name, prefix, strlen(prefix),\n\t\t\t      \"verify prefix match\");\n\t\tname += strlen(prefix) + 1;\n\t}\n\ttype_id = btf__find_by_name(btf, name);\n\tif (!ASSERT_GE(type_id, 0, \"find type id\"))\n\t\treturn -ENOENT;\n\ttype_sz = btf__resolve_size(btf, type_id);\n\tstr[0] = '\\0';\n\tret = btf_dump__dump_type_data(d, type_id, ptr, ptr_sz, &opts);\n\tif (type_sz <= ptr_sz) {\n\t\tif (!ASSERT_EQ(ret, type_sz, \"failed/unexpected type_sz\"))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!ASSERT_EQ(ret, -E2BIG, \"failed to return -E2BIG\"))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!ASSERT_STREQ(str, expected_val, \"ensure expected/actual match\"))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#define TEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,\t\\\n\t\t\t   _expected, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar __ptrtype[64] = #_type;\t\t\t\t\\\n\t\tchar *_ptrtype = (char *)__ptrtype;\t\t\t\\\n\t\t_type _ptrdata = __VA_ARGS__;\t\t\t\t\\\n\t\tvoid *_ptr = &_ptrdata;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t(void) btf_dump_data(_b, _d, _ptrtype, _prefix, _flags,\t\\\n\t\t\t\t     _ptr, sizeof(_type), _str,\t\t\\\n\t\t\t\t     _expected);\t\t\t\\\n\t} while (0)\n\n \n#define TEST_BTF_DUMP_DATA_C(_b, _d, _prefix,  _str, _type, _flags,\t\\\n\t\t\t     ...)\t\t\t\t\t\\\n\tTEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,\t\\\n\t\t\t   \"(\" #_type \")\" #__VA_ARGS__,\t__VA_ARGS__)\n\n \n#define TEST_BTF_DUMP_DATA_OVER(_b, _d, _prefix, _str, _type, _type_sz,\t\\\n\t\t\t\t_expected, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar __ptrtype[64] = #_type;\t\t\t\t\\\n\t\tchar *_ptrtype = (char *)__ptrtype;\t\t\t\\\n\t\t_type _ptrdata = __VA_ARGS__;\t\t\t\t\\\n\t\tvoid *_ptr = &_ptrdata;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t(void) btf_dump_data(_b, _d, _ptrtype, _prefix, 0,\t\\\n\t\t\t\t     _ptr, _type_sz, _str, _expected);\t\\\n\t} while (0)\n\n#define TEST_BTF_DUMP_VAR(_b, _d, _prefix, _str, _var, _type, _flags,\t\\\n\t\t\t  _expected, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t_type _ptrdata = __VA_ARGS__;\t\t\t\t\\\n\t\tvoid *_ptr = &_ptrdata;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t(void) btf_dump_data(_b, _d, _var, _prefix, _flags,\t\\\n\t\t\t\t     _ptr, sizeof(_type), _str,\t\t\\\n\t\t\t\t     _expected);\t\t\t\\\n\t} while (0)\n\nstatic void test_btf_dump_int_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t   char *str)\n{\n#ifdef __SIZEOF_INT128__\n\tunsigned __int128 i = 0xffffffffffffffff;\n\n\t \n\ti = (i << 64) | (i - 1);\n#endif\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, 1234);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"1234\", 1234);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, \"(int)1234\", 1234);\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT, \"(int)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(int)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, -4567);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"-4567\", -4567);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, \"(int)-4567\", -4567);\n\n\tTEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, int, sizeof(int)-1, \"\", 1);\n\n#ifdef __SIZEOF_INT128__\n\t \n\tif (btf__find_by_name(btf, \"unsigned __int128\") > 0) {\n\t\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, unsigned __int128, BTF_F_COMPACT,\n\t\t\t\t   \"(unsigned __int128)0xffffffffffffffff\",\n\t\t\t\t   0xffffffffffffffff);\n\t\tASSERT_OK(btf_dump_data(btf, d, \"unsigned __int128\", NULL, 0, &i, 16, str,\n\t\t\t\t\t\"(unsigned __int128)0xfffffffffffffffffffffffffffffffe\"),\n\t\t\t  \"dump unsigned __int128\");\n\t} else if (btf__find_by_name(btf, \"__int128 unsigned\") > 0) {\n\t\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, __int128 unsigned, BTF_F_COMPACT,\n\t\t\t\t   \"(__int128 unsigned)0xffffffffffffffff\",\n\t\t\t\t   0xffffffffffffffff);\n\t\tASSERT_OK(btf_dump_data(btf, d, \"__int128 unsigned\", NULL, 0, &i, 16, str,\n\t\t\t\t\t\"(__int128 unsigned)0xfffffffffffffffffffffffffffffffe\"),\n\t\t\t  \"dump unsigned __int128\");\n\t} else {\n\t\tASSERT_TRUE(false, \"unsigned_int128_not_found\");\n\t}\n#endif\n}\n\nstatic void test_btf_dump_float_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t     char *str)\n{\n\tfloat t1 = 1.234567;\n\tfloat t2 = -1.234567;\n\tfloat t3 = 0.0;\n\tdouble t4 = 5.678912;\n\tdouble t5 = -5.678912;\n\tdouble t6 = 0.0;\n\tlong double t7 = 9.876543;\n\tlong double t8 = -9.876543;\n\tlong double t9 = 0.0;\n\n\t \n\n\tASSERT_GT(btf__add_float(btf, \"test_float\", 4), 0, \"add float\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_float\", NULL, 0, &t1, 4, str,\n\t\t\t\t\"(test_float)1.234567\"), \"dump float\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_float\", NULL, 0, &t2, 4, str,\n\t\t\t\t\"(test_float)-1.234567\"), \"dump float\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_float\", NULL, 0, &t3, 4, str,\n\t\t\t\t\"(test_float)0.000000\"), \"dump float\");\n\n\tASSERT_GT(btf__add_float(btf, \"test_double\", 8), 0, \"add_double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_double\", NULL, 0, &t4, 8, str,\n\t\t  \"(test_double)5.678912\"), \"dump double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_double\", NULL, 0, &t5, 8, str,\n\t\t  \"(test_double)-5.678912\"), \"dump double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_double\", NULL, 0, &t6, 8, str,\n\t\t\t\t\"(test_double)0.000000\"), \"dump double\");\n\n\tASSERT_GT(btf__add_float(btf, \"test_long_double\", 16), 0, \"add long double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_long_double\", NULL, 0, &t7, 16,\n\t\t\t\tstr, \"(test_long_double)9.876543\"),\n\t\t\t\t\"dump long_double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_long_double\", NULL, 0, &t8, 16,\n\t\t\t\tstr, \"(test_long_double)-9.876543\"),\n\t\t\t\t\"dump long_double\");\n\tASSERT_OK(btf_dump_data(btf, d, \"test_long_double\", NULL, 0, &t9, 16,\n\t\t\t\tstr, \"(test_long_double)0.000000\"),\n\t\t\t\t\"dump long_double\");\n}\n\nstatic void test_btf_dump_char_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t    char *str)\n{\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, NULL, str, char, BTF_F_COMPACT, 100);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"100\", 100);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, \"(char)100\", 100);\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT,\n\t\t\t   \"(char)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(char)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, \"(char)0\", 0);\n\n\tTEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, char, sizeof(char)-1, \"\", 100);\n}\n\nstatic void test_btf_dump_typedef_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t       char *str)\n{\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, NULL, str, uint64_t, BTF_F_COMPACT, 100);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"1\", 1);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, \"(u64)1\", 1);\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT, \"(u64)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(u64)0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"0\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, \"(u64)0\", 0);\n\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, NULL, str, atomic_t, BTF_F_COMPACT,\n\t\t\t     {.counter = (int)1,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{1,}\", { .counter = 1 });\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,\n\"(atomic_t){\\n\"\n\"\t.counter = (int)1,\\n\"\n\"}\",\n\t\t\t   {.counter = 1,});\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT, \"(atomic_t){}\",\n\t\t\t   {.counter = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{}\", {.counter = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,\n\"(atomic_t){\\n\"\n\"}\",\n\t\t\t   {.counter = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(atomic_t){.counter = (int)0,}\",\n\t\t\t   {.counter = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"{0,}\", {.counter = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_ZERO,\n\"(atomic_t){\\n\"\n\"\t.counter = (int)0,\\n\"\n\"}\",\n\t\t\t   { .counter = 0,});\n\n\t \n\tTEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, atomic_t, sizeof(atomic_t)-1,\n\t\t\t\t\"(atomic_t){\\n\", { .counter = 1});\n}\n\nstatic void test_btf_dump_enum_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t    char *str)\n{\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, \"enum\", str, enum bpf_cmd, BTF_F_COMPACT,\n\t\t\t     BPF_MAP_CREATE);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd, BTF_F_COMPACT,\n\t\t\t   \"(enum bpf_cmd)BPF_MAP_CREATE\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"BPF_MAP_CREATE\",\n\t\t\t   BPF_MAP_CREATE);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd, 0,\n\t\t\t   \"(enum bpf_cmd)BPF_MAP_CREATE\",\n\t\t\t   BPF_MAP_CREATE);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"BPF_MAP_CREATE\", 0);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t   BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(enum bpf_cmd)BPF_MAP_CREATE\",\n\t\t\t   BPF_MAP_CREATE);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"BPF_MAP_CREATE\", BPF_MAP_CREATE);\n\tTEST_BTF_DUMP_DATA_C(btf, d, \"enum\", str, enum bpf_cmd, BTF_F_COMPACT, 2000);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"2000\", 2000);\n\tTEST_BTF_DUMP_DATA(btf, d, \"enum\", str, enum bpf_cmd, 0,\n\t\t\t   \"(enum bpf_cmd)2000\", 2000);\n\n\tTEST_BTF_DUMP_DATA_OVER(btf, d, \"enum\", str, enum bpf_cmd,\n\t\t\t\tsizeof(enum bpf_cmd) - 1, \"\", BPF_MAP_CREATE);\n}\n\nstatic void test_btf_dump_struct_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t      char *str)\n{\n\tDECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);\n\tchar zero_data[512] = { };\n\tchar type_data[512];\n\tvoid *fops = type_data;\n\tvoid *skb = type_data;\n\tsize_t type_sz;\n\t__s32 type_id;\n\tchar *cmpstr;\n\tint ret;\n\n\tmemset(type_data, 255, sizeof(type_data));\n\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, \"struct\", str, struct btf_enum, BTF_F_COMPACT,\n\t\t\t     {.name_off = (__u32)3,.val = (__s32)-1,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{3,-1,}\",\n\t\t\t   { .name_off = 3, .val = -1,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum, 0,\n\"(struct btf_enum){\\n\"\n\"\t.name_off = (__u32)3,\\n\"\n\"\t.val = (__s32)-1,\\n\"\n\"}\",\n\t\t\t   { .name_off = 3, .val = -1,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{-1,}\",\n\t\t\t   { .name_off = 0, .val = -1,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,\n\t\t\t   \"{0,-1,}\",\n\t\t\t   { .name_off = 0, .val = -1,});\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum, BTF_F_COMPACT,\n\t\t\t   \"(struct btf_enum){}\",\n\t\t\t   { .name_off = 0, .val = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{}\",\n\t\t\t   { .name_off = 0, .val = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum, 0,\n\"(struct btf_enum){\\n\"\n\"}\",\n\t\t\t   { .name_off = 0, .val = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_COMPACT | BTF_F_ZERO,\n\t\t\t   \"(struct btf_enum){.name_off = (__u32)0,.val = (__s32)0,}\",\n\t\t\t   { .name_off = 0, .val = 0,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct btf_enum,\n\t\t\t   BTF_F_ZERO,\n\"(struct btf_enum){\\n\"\n\"\t.name_off = (__u32)0,\\n\"\n\"\t.val = (__s32)0,\\n\"\n\"}\",\n\t\t\t   { .name_off = 0, .val = 0,});\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct list_head, BTF_F_COMPACT,\n\t\t\t   \"(struct list_head){.next = (struct list_head *)0x1,}\",\n\t\t\t   { .next = (struct list_head *)1 });\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct list_head, 0,\n\"(struct list_head){\\n\"\n\"\t.next = (struct list_head *)0x1,\\n\"\n\"}\",\n\t\t\t   { .next = (struct list_head *)1 });\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct list_head, BTF_F_COMPACT,\n\t\t\t   \"(struct list_head){}\",\n\t\t\t   { .next = (struct list_head *)0 });\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct list_head, 0,\n\"(struct list_head){\\n\"\n\"}\",\n\t\t\t   { .next = (struct list_head *)0 });\n\n\t \n\ttype_id = btf__find_by_name(btf, \"file_operations\");\n\tif (ASSERT_GT(type_id, 0, \"find type id\")) {\n\t\ttype_sz = btf__resolve_size(btf, type_id);\n\t\tstr[0] = '\\0';\n\n\t\tret = btf_dump__dump_type_data(d, type_id, fops, type_sz, &opts);\n\t\tASSERT_EQ(ret, type_sz,\n\t\t\t  \"unexpected return value dumping file_operations\");\n\t\tcmpstr =\n\"(struct file_operations){\\n\"\n\"\t.owner = (struct module *)0xffffffffffffffff,\\n\"\n\"\t.llseek = (loff_t (*)(struct file *, loff_t, int))0xffffffffffffffff,\";\n\n\t\tASSERT_STRNEQ(str, cmpstr, strlen(cmpstr), \"file_operations\");\n\t}\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_prog_info, BTF_F_COMPACT,\n\t\t\t   \"(struct bpf_prog_info){.name = (char[16])['f','o','o',],}\",\n\t\t\t   { .name = \"foo\",});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_prog_info,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{['f','o','o',],}\",\n\t\t\t   {.name = \"foo\",});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_prog_info, 0,\n\"(struct bpf_prog_info){\\n\"\n\"\t.name = (char[16])[\\n\"\n\"\t\t'f',\\n\"\n\"\t\t'o',\\n\"\n\"\t\t'o',\\n\"\n\"\t],\\n\"\n\"}\",\n\t\t\t   {.name = \"foo\",});\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_prog_info, BTF_F_COMPACT,\n\t\t\t   \"(struct bpf_prog_info){}\",\n\t\t\t   {.name = {'\\0', 'f', 'o', 'o'}});\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_prog_info, BTF_F_COMPACT,\n\t\t\t   \"(struct bpf_prog_info){.name = (char[16])[1,2,3,],}\",\n\t\t\t   { .name = {1, 2, 3, 0}});\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct __sk_buff, BTF_F_COMPACT,\n\t\t\t   \"(struct __sk_buff){.cb = (__u32[5])[1,2,3,4,5,],}\",\n\t\t\t   { .cb = {1, 2, 3, 4, 5,},});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct __sk_buff,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{[1,2,3,4,5,],}\",\n\t\t\t   { .cb = { 1, 2, 3, 4, 5},});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct __sk_buff, 0,\n\"(struct __sk_buff){\\n\"\n\"\t.cb = (__u32[5])[\\n\"\n\"\t\t1,\\n\"\n\"\t\t2,\\n\"\n\"\t\t3,\\n\"\n\"\t\t4,\\n\"\n\"\t\t5,\\n\"\n\"\t],\\n\"\n\"}\",\n\t\t\t   { .cb = { 1, 2, 3, 4, 5},});\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct __sk_buff, BTF_F_COMPACT,\n\t\t\t   \"(struct __sk_buff){.cb = (__u32[5])[0,0,1,0,0,],}\",\n\t\t\t   { .cb = { 0, 0, 1, 0, 0},});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct __sk_buff, 0,\n\"(struct __sk_buff){\\n\"\n\"\t.cb = (__u32[5])[\\n\"\n\"\t\t0,\\n\"\n\"\t\t0,\\n\"\n\"\t\t1,\\n\"\n\"\t\t0,\\n\"\n\"\t\t0,\\n\"\n\"\t],\\n\"\n\"}\",\n\t\t\t   { .cb = { 0, 0, 1, 0, 0},});\n\n\t \n\tTEST_BTF_DUMP_DATA_C(btf, d, \"struct\", str, struct bpf_insn, BTF_F_COMPACT,\n\t\t{.code = (__u8)1,.dst_reg = (__u8)0x2,.src_reg = (__u8)0x3,.off = (__s16)4,.imm = (__s32)5,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_insn,\n\t\t\t   BTF_F_COMPACT | BTF_F_NONAME,\n\t\t\t   \"{1,0x2,0x3,4,5,}\",\n\t\t\t   { .code = 1, .dst_reg = 0x2, .src_reg = 0x3, .off = 4,\n\t\t\t     .imm = 5,});\n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_insn, 0,\n\"(struct bpf_insn){\\n\"\n\"\t.code = (__u8)1,\\n\"\n\"\t.dst_reg = (__u8)0x2,\\n\"\n\"\t.src_reg = (__u8)0x3,\\n\"\n\"\t.off = (__s16)4,\\n\"\n\"\t.imm = (__s32)5,\\n\"\n\"}\",\n\t\t\t   {.code = 1, .dst_reg = 2, .src_reg = 3, .off = 4, .imm = 5});\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_insn, BTF_F_COMPACT,\n\t\t\t   \"(struct bpf_insn){.dst_reg = (__u8)0x1,}\",\n\t\t\t   { .code = 0, .dst_reg = 1});\n\n\t \n\ttype_id = btf__find_by_name(btf, \"fs_context\");\n\tif (ASSERT_GT(type_id,  0, \"find fs_context\")) {\n\t\ttype_sz = btf__resolve_size(btf, type_id);\n\t\tstr[0] = '\\0';\n\n\t\topts.emit_zeroes = true;\n\t\tret = btf_dump__dump_type_data(d, type_id, zero_data, type_sz, &opts);\n\t\tASSERT_EQ(ret, type_sz,\n\t\t\t  \"unexpected return value dumping fs_context\");\n\n\t\tASSERT_NEQ(strstr(str, \"FS_CONTEXT_FOR_MOUNT\"), NULL,\n\t\t\t\t  \"bitfield value not present\");\n\t}\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"struct\", str, struct bpf_sock_ops, BTF_F_COMPACT,\n\t\t\t   \"(struct bpf_sock_ops){.op = (__u32)1,(union){.args = (__u32[4])[1,2,3,4,],.reply = (__u32)1,.replylong = (__u32[4])[1,2,3,4,],},}\",\n\t\t\t   { .op = 1, .args = { 1, 2, 3, 4}});\n\n\t \n\tTEST_BTF_DUMP_DATA(btf, d, \"union\", str, union bpf_iter_link_info, BTF_F_COMPACT,\n\t\t\t   \"(union bpf_iter_link_info){.map = (struct){.map_fd = (__u32)1,},.cgroup = (struct){.order = (enum bpf_cgroup_iter_order)BPF_CGROUP_ITER_SELF_ONLY,.cgroup_fd = (__u32)1,},.task = (struct){.tid = (__u32)1,.pid = (__u32)1,},}\",\n\t\t\t   { .cgroup = { .order = 1, .cgroup_fd = 1, }});\n\n\t \n\ttype_id = btf__find_by_name(btf, \"sk_buff\");\n\tif (ASSERT_GT(type_id, 0, \"find struct sk_buff\")) {\n\t\ttype_sz = btf__resolve_size(btf, type_id);\n\t\tstr[0] = '\\0';\n\n\t\tret = btf_dump__dump_type_data(d, type_id, skb, type_sz, &opts);\n\t\tASSERT_EQ(ret, type_sz,\n\t\t\t  \"unexpected return value dumping sk_buff\");\n\t}\n\n\t \n\tTEST_BTF_DUMP_DATA_OVER(btf, d, \"struct\", str, struct bpf_sock_ops,\n\t\t\t\tsizeof(struct bpf_sock_ops) - 1,\n\t\t\t\t\"(struct bpf_sock_ops){\\n\\t.op = (__u32)1,\\n\",\n\t\t\t\t{ .op = 1, .skb_hwtstamp = 2});\n\tTEST_BTF_DUMP_DATA_OVER(btf, d, \"struct\", str, struct bpf_sock_ops,\n\t\t\t\tsizeof(struct bpf_sock_ops) - 1,\n\t\t\t\t\"(struct bpf_sock_ops){\\n\\t.op = (__u32)1,\\n\",\n\t\t\t\t{ .op = 1, .skb_hwtstamp = 0});\n}\n\nstatic void test_btf_dump_var_data(struct btf *btf, struct btf_dump *d,\n\t\t\t\t   char *str)\n{\n#if 0\n\tTEST_BTF_DUMP_VAR(btf, d, NULL, str, \"cpu_number\", int, BTF_F_COMPACT,\n\t\t\t  \"int cpu_number = (int)100\", 100);\n#endif\n\tTEST_BTF_DUMP_VAR(btf, d, NULL, str, \"cpu_profile_flip\", int, BTF_F_COMPACT,\n\t\t\t  \"static int cpu_profile_flip = (int)2\", 2);\n}\n\nstatic void test_btf_datasec(struct btf *btf, struct btf_dump *d, char *str,\n\t\t\t     const char *name, const char *expected_val,\n\t\t\t     void *data, size_t data_sz)\n{\n\tDECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);\n\tint ret = 0, cmp;\n\tsize_t secsize;\n\t__s32 type_id;\n\n\topts.compact = true;\n\n\ttype_id = btf__find_by_name(btf, name);\n\tif (!ASSERT_GT(type_id, 0, \"find type id\"))\n\t\treturn;\n\n\tsecsize = btf__resolve_size(btf, type_id);\n\tASSERT_EQ(secsize,  0, \"verify section size\");\n\n\tstr[0] = '\\0';\n\tret = btf_dump__dump_type_data(d, type_id, data, data_sz, &opts);\n\tASSERT_EQ(ret, 0, \"unexpected return value\");\n\n\tcmp = strcmp(str, expected_val);\n\tASSERT_EQ(cmp, 0, \"ensure expected/actual match\");\n}\n\nstatic void test_btf_dump_datasec_data(char *str)\n{\n\tstruct btf *btf;\n\tchar license[4] = \"GPL\";\n\tstruct btf_dump *d;\n\n\tbtf = btf__parse(\"xdping_kern.bpf.o\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"xdping_kern.bpf.o BTF not found\"))\n\t\treturn;\n\n\td = btf_dump__new(btf, btf_dump_snprintf, str, NULL);\n\tif (!ASSERT_OK_PTR(d, \"could not create BTF dump\"))\n\t\tgoto out;\n\n\ttest_btf_datasec(btf, d, str, \"license\",\n\t\t\t \"SEC(\\\"license\\\") char[4] _license = (char[4])['G','P','L',];\",\n\t\t\t license, sizeof(license));\nout:\n\tbtf_dump__free(d);\n\tbtf__free(btf);\n}\n\nvoid test_btf_dump() {\n\tchar str[STRSIZE];\n\tstruct btf_dump *d;\n\tstruct btf *btf;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_dump_test_cases); i++) {\n\t\tstruct btf_dump_test_case *t = &btf_dump_test_cases[i];\n\n\t\tif (!test__start_subtest(t->name))\n\t\t\tcontinue;\n\n\t\ttest_btf_dump_case(i, &btf_dump_test_cases[i]);\n\t}\n\tif (test__start_subtest(\"btf_dump: incremental\"))\n\t\ttest_btf_dump_incremental();\n\n\tbtf = libbpf_find_kernel_btf();\n\tif (!ASSERT_OK_PTR(btf, \"no kernel BTF found\"))\n\t\treturn;\n\n\td = btf_dump__new(btf, btf_dump_snprintf, str, NULL);\n\tif (!ASSERT_OK_PTR(d, \"could not create BTF dump\"))\n\t\treturn;\n\n\t \n\tif (test__start_subtest(\"btf_dump: int_data\"))\n\t\ttest_btf_dump_int_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: float_data\"))\n\t\ttest_btf_dump_float_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: char_data\"))\n\t\ttest_btf_dump_char_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: typedef_data\"))\n\t\ttest_btf_dump_typedef_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: enum_data\"))\n\t\ttest_btf_dump_enum_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: struct_data\"))\n\t\ttest_btf_dump_struct_data(btf, d, str);\n\tif (test__start_subtest(\"btf_dump: var_data\"))\n\t\ttest_btf_dump_var_data(btf, d, str);\n\tbtf_dump__free(d);\n\tbtf__free(btf);\n\n\tif (test__start_subtest(\"btf_dump: datasec_data\"))\n\t\ttest_btf_dump_datasec_data(str);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}