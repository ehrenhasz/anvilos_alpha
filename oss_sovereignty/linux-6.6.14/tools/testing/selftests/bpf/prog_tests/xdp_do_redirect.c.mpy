{
  "module_name": "xdp_do_redirect.c",
  "hash_id": "a93df1eaf6c64fa5e9ecf21beadeec4d78c55d10a66476dfefae9957b403ae4d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_do_redirect.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_link.h>\n#include <linux/ipv6.h>\n#include <linux/in6.h>\n#include <linux/udp.h>\n#include <bpf/bpf_endian.h>\n#include <uapi/linux/netdev.h>\n#include \"test_xdp_do_redirect.skel.h\"\n\nstruct udp_packet {\n\tstruct ethhdr eth;\n\tstruct ipv6hdr iph;\n\tstruct udphdr udp;\n\t__u8 payload[64 - sizeof(struct udphdr)\n\t\t     - sizeof(struct ethhdr) - sizeof(struct ipv6hdr)];\n} __packed;\n\nstatic struct udp_packet pkt_udp = {\n\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t.eth.h_dest = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55},\n\t.eth.h_source = {0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb},\n\t.iph.version = 6,\n\t.iph.nexthdr = IPPROTO_UDP,\n\t.iph.payload_len = bpf_htons(sizeof(struct udp_packet)\n\t\t\t\t     - offsetof(struct udp_packet, udp)),\n\t.iph.hop_limit = 2,\n\t.iph.saddr.s6_addr16 = {bpf_htons(0xfc00), 0, 0, 0, 0, 0, 0, bpf_htons(1)},\n\t.iph.daddr.s6_addr16 = {bpf_htons(0xfc00), 0, 0, 0, 0, 0, 0, bpf_htons(2)},\n\t.udp.source = bpf_htons(1),\n\t.udp.dest = bpf_htons(1),\n\t.udp.len = bpf_htons(sizeof(struct udp_packet)\n\t\t\t     - offsetof(struct udp_packet, udp)),\n\t.payload = {0x42},  \n};\n\nstatic int attach_tc_prog(struct bpf_tc_hook *hook, int fd)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, opts, .handle = 1, .priority = 1, .prog_fd = fd);\n\tint ret;\n\n\tret = bpf_tc_hook_create(hook);\n\tif (!ASSERT_OK(ret, \"create tc hook\"))\n\t\treturn ret;\n\n\tret = bpf_tc_attach(hook, &opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_attach\")) {\n\t\tbpf_tc_hook_destroy(hook);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n#if defined(__s390x__)\n#define MAX_PKT_SIZE 3216\n#else\n#define MAX_PKT_SIZE 3408\n#endif\nstatic void test_max_pkt_size(int fd)\n{\n\tchar data[MAX_PKT_SIZE + 1] = {};\n\tint err;\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t\t    .data_in = &data,\n\t\t\t    .data_size_in = MAX_PKT_SIZE,\n\t\t\t    .flags = BPF_F_TEST_XDP_LIVE_FRAMES,\n\t\t\t    .repeat = 1,\n\t\t);\n\terr = bpf_prog_test_run_opts(fd, &opts);\n\tASSERT_OK(err, \"prog_run_max_size\");\n\n\topts.data_size_in += 1;\n\terr = bpf_prog_test_run_opts(fd, &opts);\n\tASSERT_EQ(err, -EINVAL, \"prog_run_too_big\");\n}\n\n#define NUM_PKTS 10000\nvoid test_xdp_do_redirect(void)\n{\n\tint err, xdp_prog_fd, tc_prog_fd, ifindex_src, ifindex_dst;\n\tchar data[sizeof(pkt_udp) + sizeof(__u64)];\n\tstruct test_xdp_do_redirect *skel = NULL;\n\tstruct nstoken *nstoken = NULL;\n\tstruct bpf_link *link;\n\tLIBBPF_OPTS(bpf_xdp_query_opts, query_opts);\n\tstruct xdp_md ctx_in = { .data = sizeof(__u64),\n\t\t\t\t .data_end = sizeof(data) };\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t\t    .data_in = &data,\n\t\t\t    .data_size_in = sizeof(data),\n\t\t\t    .ctx_in = &ctx_in,\n\t\t\t    .ctx_size_in = sizeof(ctx_in),\n\t\t\t    .flags = BPF_F_TEST_XDP_LIVE_FRAMES,\n\t\t\t    .repeat = NUM_PKTS,\n\t\t\t    .batch_size = 64,\n\t\t);\n\tDECLARE_LIBBPF_OPTS(bpf_tc_hook, tc_hook,\n\t\t\t    .attach_point = BPF_TC_INGRESS);\n\n\tmemcpy(&data[sizeof(__u64)], &pkt_udp, sizeof(pkt_udp));\n\t*((__u32 *)data) = 0x42;  \n\t*((__u32 *)data + 4) = 0;\n\n\tskel = test_xdp_do_redirect__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel\"))\n\t\treturn;\n\n\t \n\tSYS(out, \"ip netns add testns\");\n\tnstoken = open_netns(\"testns\");\n\tif (!ASSERT_OK_PTR(nstoken, \"setns\"))\n\t\tgoto out;\n\n\tSYS(out, \"ip link add veth_src type veth peer name veth_dst\");\n\tSYS(out, \"ip link set dev veth_src address 00:11:22:33:44:55\");\n\tSYS(out, \"ip link set dev veth_dst address 66:77:88:99:aa:bb\");\n\tSYS(out, \"ip link set dev veth_src up\");\n\tSYS(out, \"ip link set dev veth_dst up\");\n\tSYS(out, \"ip addr add dev veth_src fc00::1/64\");\n\tSYS(out, \"ip addr add dev veth_dst fc00::2/64\");\n\tSYS(out, \"ip neigh add fc00::2 dev veth_src lladdr 66:77:88:99:aa:bb\");\n\n\t \n\tSYS(out, \"sysctl -qw net.ipv6.conf.all.forwarding=1\");\n\n\tifindex_src = if_nametoindex(\"veth_src\");\n\tifindex_dst = if_nametoindex(\"veth_dst\");\n\tif (!ASSERT_NEQ(ifindex_src, 0, \"ifindex_src\") ||\n\t    !ASSERT_NEQ(ifindex_dst, 0, \"ifindex_dst\"))\n\t\tgoto out;\n\n\t \n\terr = bpf_xdp_query(ifindex_src, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"veth_src bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG,\n\t\t       \"veth_src query_opts.feature_flags\"))\n\t\tgoto out;\n\n\terr = bpf_xdp_query(ifindex_dst, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"veth_dst bpf_xdp_query\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_RX_SG,\n\t\t       \"veth_dst query_opts.feature_flags\"))\n\t\tgoto out;\n\n\t \n\tSYS(out, \"ethtool -K veth_src gro on\");\n\tSYS(out, \"ethtool -K veth_dst gro on\");\n\n\terr = bpf_xdp_query(ifindex_src, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"veth_src bpf_xdp_query gro on\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT | NETDEV_XDP_ACT_RX_SG |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT_SG,\n\t\t       \"veth_src query_opts.feature_flags gro on\"))\n\t\tgoto out;\n\n\terr = bpf_xdp_query(ifindex_dst, XDP_FLAGS_DRV_MODE, &query_opts);\n\tif (!ASSERT_OK(err, \"veth_dst bpf_xdp_query gro on\"))\n\t\tgoto out;\n\n\tif (!ASSERT_EQ(query_opts.feature_flags,\n\t\t       NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT | NETDEV_XDP_ACT_RX_SG |\n\t\t       NETDEV_XDP_ACT_NDO_XMIT_SG,\n\t\t       \"veth_dst query_opts.feature_flags gro on\"))\n\t\tgoto out;\n\n\tmemcpy(skel->rodata->expect_dst, &pkt_udp.eth.h_dest, ETH_ALEN);\n\tskel->rodata->ifindex_out = ifindex_src;  \n\tskel->rodata->ifindex_in = ifindex_src;\n\tctx_in.ingress_ifindex = ifindex_src;\n\ttc_hook.ifindex = ifindex_src;\n\n\tif (!ASSERT_OK(test_xdp_do_redirect__load(skel), \"load\"))\n\t\tgoto out;\n\n\tlink = bpf_program__attach_xdp(skel->progs.xdp_count_pkts, ifindex_dst);\n\tif (!ASSERT_OK_PTR(link, \"prog_attach\"))\n\t\tgoto out;\n\tskel->links.xdp_count_pkts = link;\n\n\ttc_prog_fd = bpf_program__fd(skel->progs.tc_count_pkts);\n\tif (attach_tc_prog(&tc_hook, tc_prog_fd))\n\t\tgoto out;\n\n\txdp_prog_fd = bpf_program__fd(skel->progs.xdp_redirect);\n\terr = bpf_prog_test_run_opts(xdp_prog_fd, &opts);\n\tif (!ASSERT_OK(err, \"prog_run\"))\n\t\tgoto out_tc;\n\n\t \n\tkern_sync_rcu();\n\n\t \n\tASSERT_EQ(skel->bss->pkts_seen_xdp, 2, \"pkt_count_xdp\");\n\tASSERT_EQ(skel->bss->pkts_seen_zero, 2, \"pkt_count_zero\");\n\tASSERT_EQ(skel->bss->pkts_seen_tc, NUM_PKTS - 2, \"pkt_count_tc\");\n\n\ttest_max_pkt_size(bpf_program__fd(skel->progs.xdp_count_pkts));\n\nout_tc:\n\tbpf_tc_hook_destroy(&tc_hook);\nout:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\tSYS_NOFAIL(\"ip netns del testns\");\n\ttest_xdp_do_redirect__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}