{
  "module_name": "lookup_and_delete.c",
  "hash_id": "78b929e8e729193c7399df0052e26cb9e3b715ff5bb83d551d8d8f9d045b7eb1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/lookup_and_delete.c",
  "human_readable_source": "\n\n#include <test_progs.h>\n#include \"test_lookup_and_delete.skel.h\"\n\n#define START_VALUE 1234\n#define NEW_VALUE 4321\n#define MAX_ENTRIES 2\n\nstatic int duration;\nstatic int nr_cpus;\n\nstatic int fill_values(int map_fd)\n{\n\t__u64 key, value = START_VALUE;\n\tint err;\n\n\tfor (key = 1; key < MAX_ENTRIES + 1; key++) {\n\t\terr = bpf_map_update_elem(map_fd, &key, &value, BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_values_percpu(int map_fd)\n{\n\t__u64 key, value[nr_cpus];\n\tint i, err;\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tvalue[i] = START_VALUE;\n\n\tfor (key = 1; key < MAX_ENTRIES + 1; key++) {\n\t\terr = bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct test_lookup_and_delete *setup_prog(enum bpf_map_type map_type,\n\t\t\t\t\t\t int *map_fd)\n{\n\tstruct test_lookup_and_delete *skel;\n\tint err;\n\n\tskel = test_lookup_and_delete__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_lookup_and_delete__open\"))\n\t\treturn NULL;\n\n\terr = bpf_map__set_type(skel->maps.hash_map, map_type);\n\tif (!ASSERT_OK(err, \"bpf_map__set_type\"))\n\t\tgoto cleanup;\n\n\terr = bpf_map__set_max_entries(skel->maps.hash_map, MAX_ENTRIES);\n\tif (!ASSERT_OK(err, \"bpf_map__set_max_entries\"))\n\t\tgoto cleanup;\n\n\terr = test_lookup_and_delete__load(skel);\n\tif (!ASSERT_OK(err, \"test_lookup_and_delete__load\"))\n\t\tgoto cleanup;\n\n\t*map_fd = bpf_map__fd(skel->maps.hash_map);\n\tif (!ASSERT_GE(*map_fd, 0, \"bpf_map__fd\"))\n\t\tgoto cleanup;\n\n\treturn skel;\n\ncleanup:\n\ttest_lookup_and_delete__destroy(skel);\n\treturn NULL;\n}\n\n \nstatic int trigger_tp(struct test_lookup_and_delete *skel, __u64 key,\n\t\t      __u64 value)\n{\n\tint err;\n\n\tskel->bss->set_pid = getpid();\n\tskel->bss->set_key = key;\n\tskel->bss->set_value = value;\n\n\terr = test_lookup_and_delete__attach(skel);\n\tif (!ASSERT_OK(err, \"test_lookup_and_delete__attach\"))\n\t\treturn -1;\n\n\tsyscall(__NR_getpgid);\n\n\ttest_lookup_and_delete__detach(skel);\n\n\treturn 0;\n}\n\nstatic void test_lookup_and_delete_hash(void)\n{\n\tstruct test_lookup_and_delete *skel;\n\t__u64 key, value;\n\tint map_fd, err;\n\n\t \n\tskel = setup_prog(BPF_MAP_TYPE_HASH, &map_fd);\n\tif (!ASSERT_OK_PTR(skel, \"setup_prog\"))\n\t\treturn;\n\n\terr = fill_values(map_fd);\n\tif (!ASSERT_OK(err, \"fill_values\"))\n\t\tgoto cleanup;\n\n\t \n\tkey = 1;\n\terr = bpf_map__lookup_and_delete_elem(skel->maps.hash_map,\n\t\t\t\t\t      &key, sizeof(key), &value, sizeof(value), 0);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_and_delete_elem\"))\n\t\tgoto cleanup;\n\n\t \n\tif (CHECK(value != START_VALUE, \"bpf_map_lookup_and_delete_elem\",\n\t\t  \"unexpected value=%lld\\n\", value))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, &value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\ncleanup:\n\ttest_lookup_and_delete__destroy(skel);\n}\n\nstatic void test_lookup_and_delete_percpu_hash(void)\n{\n\tstruct test_lookup_and_delete *skel;\n\t__u64 key, val, value[nr_cpus];\n\tint map_fd, err, i;\n\n\t \n\tskel = setup_prog(BPF_MAP_TYPE_PERCPU_HASH, &map_fd);\n\tif (!ASSERT_OK_PTR(skel, \"setup_prog\"))\n\t\treturn;\n\n\terr = fill_values_percpu(map_fd);\n\tif (!ASSERT_OK(err, \"fill_values_percpu\"))\n\t\tgoto cleanup;\n\n\t \n\tkey = 1;\n\terr = bpf_map__lookup_and_delete_elem(skel->maps.hash_map,\n\t\t\t\t\t      &key, sizeof(key), value, sizeof(value), 0);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_and_delete_elem\"))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tval = value[i];\n\n\t\t \n\t\tif (CHECK(val != START_VALUE, \"map value\",\n\t\t\t  \"unexpected for cpu %d: %lld\\n\", i, val))\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\ncleanup:\n\ttest_lookup_and_delete__destroy(skel);\n}\n\nstatic void test_lookup_and_delete_lru_hash(void)\n{\n\tstruct test_lookup_and_delete *skel;\n\t__u64 key, value;\n\tint map_fd, err;\n\n\t \n\tskel = setup_prog(BPF_MAP_TYPE_LRU_HASH, &map_fd);\n\tif (!ASSERT_OK_PTR(skel, \"setup_prog\"))\n\t\treturn;\n\n\terr = fill_values(map_fd);\n\tif (!ASSERT_OK(err, \"fill_values\"))\n\t\tgoto cleanup;\n\n\t \n\tkey = 3;\n\terr = trigger_tp(skel, key, NEW_VALUE);\n\tif (!ASSERT_OK(err, \"trigger_tp\"))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map__lookup_and_delete_elem(skel->maps.hash_map,\n\t\t\t\t\t      &key, sizeof(key), &value, sizeof(value), 0);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_and_delete_elem\"))\n\t\tgoto cleanup;\n\n\t \n\tif (CHECK(value != NEW_VALUE, \"bpf_map_lookup_and_delete_elem\",\n\t\t  \"unexpected value=%lld\\n\", value))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, &value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\n\tkey = 1;\n\terr = bpf_map_lookup_elem(map_fd, &key, &value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\ncleanup:\n\ttest_lookup_and_delete__destroy(skel);\n}\n\nstatic void test_lookup_and_delete_lru_percpu_hash(void)\n{\n\tstruct test_lookup_and_delete *skel;\n\t__u64 key, val, value[nr_cpus];\n\tint map_fd, err, i, cpucnt = 0;\n\n\t \n\tskel = setup_prog(BPF_MAP_TYPE_LRU_PERCPU_HASH, &map_fd);\n\tif (!ASSERT_OK_PTR(skel, \"setup_prog\"))\n\t\treturn;\n\n\terr = fill_values_percpu(map_fd);\n\tif (!ASSERT_OK(err, \"fill_values_percpu\"))\n\t\tgoto cleanup;\n\n\t \n\tkey = 3;\n\terr = trigger_tp(skel, key, NEW_VALUE);\n\tif (!ASSERT_OK(err, \"trigger_tp\"))\n\t\tgoto cleanup;\n\n\t \n\tfor (i = 0; i < nr_cpus; i++)\n\t\tvalue[i] = 0;\n\n\t \n\terr = bpf_map__lookup_and_delete_elem(skel->maps.hash_map,\n\t\t\t\t\t      &key, sizeof(key), value, sizeof(value), 0);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_and_delete_elem\"))\n\t\tgoto cleanup;\n\n\t \n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tval = value[i];\n\t\tif (val) {\n\t\t\tif (CHECK(val != NEW_VALUE, \"map value\",\n\t\t\t\t  \"unexpected for cpu %d: %lld\\n\", i, val))\n\t\t\t\tgoto cleanup;\n\t\t\tcpucnt++;\n\t\t}\n\t}\n\tif (CHECK(cpucnt != 1, \"map value\", \"set for %d CPUs instead of 1!\\n\",\n\t\t  cpucnt))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, &value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\n\tkey = 1;\n\terr = bpf_map_lookup_elem(map_fd, &key, &value);\n\tif (!ASSERT_ERR(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\ncleanup:\n\ttest_lookup_and_delete__destroy(skel);\n}\n\nvoid test_lookup_and_delete(void)\n{\n\tnr_cpus = bpf_num_possible_cpus();\n\n\tif (test__start_subtest(\"lookup_and_delete\"))\n\t\ttest_lookup_and_delete_hash();\n\tif (test__start_subtest(\"lookup_and_delete_percpu\"))\n\t\ttest_lookup_and_delete_percpu_hash();\n\tif (test__start_subtest(\"lookup_and_delete_lru\"))\n\t\ttest_lookup_and_delete_lru_hash();\n\tif (test__start_subtest(\"lookup_and_delete_lru_percpu\"))\n\t\ttest_lookup_and_delete_lru_percpu_hash();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}