{
  "module_name": "cgroup_hierarchical_stats.c",
  "hash_id": "77eded176559a94a68fd4186d4481bf9c27d1236647b7f4712a9c95e46a860e7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cgroup_hierarchical_stats.c",
  "human_readable_source": "\n \n#include <asm-generic/errno.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <test_progs.h>\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n\n#include \"cgroup_helpers.h\"\n#include \"cgroup_hierarchical_stats.skel.h\"\n\n#define PAGE_SIZE 4096\n#define MB(x) (x << 20)\n\n#define PROCESSES_PER_CGROUP 3\n\n#define BPFFS_ROOT \"/sys/fs/bpf/\"\n#define BPFFS_ATTACH_COUNTERS BPFFS_ROOT \"attach_counters/\"\n\n#define CG_ROOT_NAME \"root\"\n#define CG_ROOT_ID 1\n\n#define CGROUP_PATH(p, n) {.path = p\"/\"n, .name = n}\n\nstatic struct {\n\tconst char *path, *name;\n\tunsigned long long id;\n\tint fd;\n} cgroups[] = {\n\tCGROUP_PATH(\"/\", \"test\"),\n\tCGROUP_PATH(\"/test\", \"child1\"),\n\tCGROUP_PATH(\"/test\", \"child2\"),\n\tCGROUP_PATH(\"/test/child1\", \"child1_1\"),\n\tCGROUP_PATH(\"/test/child1\", \"child1_2\"),\n\tCGROUP_PATH(\"/test/child2\", \"child2_1\"),\n\tCGROUP_PATH(\"/test/child2\", \"child2_2\"),\n};\n\n#define N_CGROUPS ARRAY_SIZE(cgroups)\n#define N_NON_LEAF_CGROUPS 3\n\nstatic int root_cgroup_fd;\nstatic bool mounted_bpffs;\n\n \nstatic int read_from_file(const char *path, char *buf, size_t size)\n{\n\tint fd, len;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tlen = read(fd, buf, size);\n\tclose(fd);\n\tif (len < 0)\n\t\treturn len;\n\n\tbuf[len] = 0;\n\treturn 0;\n}\n\n \nstatic int setup_bpffs(void)\n{\n\tint err;\n\n\t \n\terr = mount(\"bpf\", BPFFS_ROOT, \"bpf\", 0, NULL);\n\tmounted_bpffs = !err;\n\tif (ASSERT_FALSE(err && errno != EBUSY, \"mount\"))\n\t\treturn err;\n\n\t \n\terr = mkdir(BPFFS_ATTACH_COUNTERS, 0755);\n\tif (!ASSERT_OK(err, \"mkdir\"))\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void cleanup_bpffs(void)\n{\n\t \n\tASSERT_OK(rmdir(BPFFS_ATTACH_COUNTERS), \"rmdir \"BPFFS_ATTACH_COUNTERS);\n\n\t \n\tif (mounted_bpffs)\n\t\treturn;\n\n\tASSERT_OK(umount(BPFFS_ROOT), \"unmount bpffs\");\n}\n\n \nstatic int setup_cgroups(void)\n{\n\tint i, fd, err;\n\n\terr = setup_cgroup_environment();\n\tif (!ASSERT_OK(err, \"setup_cgroup_environment\"))\n\t\treturn err;\n\n\troot_cgroup_fd = get_root_cgroup();\n\tif (!ASSERT_GE(root_cgroup_fd, 0, \"get_root_cgroup\"))\n\t\treturn root_cgroup_fd;\n\n\tfor (i = 0; i < N_CGROUPS; i++) {\n\t\tfd = create_and_get_cgroup(cgroups[i].path);\n\t\tif (!ASSERT_GE(fd, 0, \"create_and_get_cgroup\"))\n\t\t\treturn fd;\n\n\t\tcgroups[i].fd = fd;\n\t\tcgroups[i].id = get_cgroup_id(cgroups[i].path);\n\t}\n\treturn 0;\n}\n\nstatic void cleanup_cgroups(void)\n{\n\tclose(root_cgroup_fd);\n\tfor (int i = 0; i < N_CGROUPS; i++)\n\t\tclose(cgroups[i].fd);\n\tcleanup_cgroup_environment();\n}\n\n \nstatic int setup_hierarchy(void)\n{\n\treturn setup_bpffs() || setup_cgroups();\n}\n\nstatic void destroy_hierarchy(void)\n{\n\tcleanup_cgroups();\n\tcleanup_bpffs();\n}\n\nstatic int attach_processes(void)\n{\n\tint i, j, status;\n\n\t \n\tfor (i = N_NON_LEAF_CGROUPS; i < N_CGROUPS; i++) {\n\t\tfor (j = 0; j < PROCESSES_PER_CGROUP; j++) {\n\t\t\tpid_t pid;\n\n\t\t\t \n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tif (join_parent_cgroup(cgroups[i].path))\n\t\t\t\t\texit(EACCES);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t \n\t\t\twaitpid(pid, &status, 0);\n\t\t\tif (!ASSERT_TRUE(WIFEXITED(status), \"child process exited\"))\n\t\t\t\treturn 1;\n\t\t\tif (!ASSERT_EQ(WEXITSTATUS(status), 0,\n\t\t\t\t       \"child process exit code\"))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic unsigned long long\nget_attach_counter(unsigned long long cgroup_id, const char *file_name)\n{\n\tunsigned long long attach_counter = 0, id = 0;\n\tstatic char buf[128], path[128];\n\n\t \n\tsnprintf(path, 128, \"%s%s\", BPFFS_ATTACH_COUNTERS, file_name);\n\tif (!ASSERT_OK(read_from_file(path, buf, 128), \"read cgroup_iter\"))\n\t\treturn 0;\n\n\t \n\tASSERT_EQ(sscanf(buf, \"cg_id: %llu, attach_counter: %llu\\n\",\n\t\t\t &id, &attach_counter), 2, \"output format\");\n\n\t \n\tASSERT_EQ(id, cgroup_id, \"cgroup_id\");\n\t \n\tASSERT_GT(attach_counter, 0, \"attach counter non-zero\");\n\treturn attach_counter;\n}\n\nstatic void check_attach_counters(void)\n{\n\tunsigned long long attach_counters[N_CGROUPS], root_attach_counter;\n\tint i;\n\n\tfor (i = 0; i < N_CGROUPS; i++)\n\t\tattach_counters[i] = get_attach_counter(cgroups[i].id,\n\t\t\t\t\t\t\tcgroups[i].name);\n\n\t \n\troot_attach_counter = get_attach_counter(CG_ROOT_ID, CG_ROOT_NAME);\n\n\t \n\tfor (i = N_NON_LEAF_CGROUPS; i < N_CGROUPS; i++)\n\t\tASSERT_EQ(attach_counters[i], PROCESSES_PER_CGROUP,\n\t\t\t  \"leaf cgroup attach counter\");\n\n\t \n\tASSERT_EQ(attach_counters[1], attach_counters[3] + attach_counters[4],\n\t\t  \"child1_counter\");\n\t \n\tASSERT_EQ(attach_counters[2], attach_counters[5] + attach_counters[6],\n\t\t  \"child2_counter\");\n\t \n\tASSERT_EQ(attach_counters[0], attach_counters[1] + attach_counters[2],\n\t\t  \"test_counter\");\n\t \n\tASSERT_GE(root_attach_counter, attach_counters[1], \"root_counter\");\n}\n\n \nstatic int setup_cgroup_iter(struct cgroup_hierarchical_stats *obj,\n\t\t\t     int cgroup_fd, const char *file_name)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo = {};\n\tstruct bpf_link *link;\n\tstatic char path[128];\n\tint err;\n\n\t \n\tlinfo.cgroup.cgroup_fd = cgroup_fd;\n\tlinfo.cgroup.order = BPF_CGROUP_ITER_SELF_ONLY;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(obj->progs.dumper, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn -EFAULT;\n\n\t \n\tsnprintf(path, 128, \"%s%s\", BPFFS_ATTACH_COUNTERS, file_name);\n\terr = bpf_link__pin(link, path);\n\tASSERT_OK(err, \"pin cgroup_iter\");\n\n\t \n\tbpf_link__destroy(link);\n\treturn err;\n}\n\n \nstatic int setup_progs(struct cgroup_hierarchical_stats **skel)\n{\n\tint i, err;\n\n\t*skel = cgroup_hierarchical_stats__open_and_load();\n\tif (!ASSERT_OK_PTR(*skel, \"open_and_load\"))\n\t\treturn 1;\n\n\t \n\tfor (i = 0; i < N_CGROUPS; i++) {\n\t\terr = setup_cgroup_iter(*skel, cgroups[i].fd, cgroups[i].name);\n\t\tif (!ASSERT_OK(err, \"setup_cgroup_iter\"))\n\t\t\treturn err;\n\t}\n\n\t \n\terr = setup_cgroup_iter(*skel, root_cgroup_fd, CG_ROOT_NAME);\n\tif (!ASSERT_OK(err, \"setup_cgroup_iter\"))\n\t\treturn err;\n\n\tbpf_program__set_autoattach((*skel)->progs.dumper, false);\n\terr = cgroup_hierarchical_stats__attach(*skel);\n\tif (!ASSERT_OK(err, \"attach\"))\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void destroy_progs(struct cgroup_hierarchical_stats *skel)\n{\n\tstatic char path[128];\n\tint i;\n\n\tfor (i = 0; i < N_CGROUPS; i++) {\n\t\t \n\t\tsnprintf(path, 128, \"%s%s\", BPFFS_ATTACH_COUNTERS,\n\t\t\t cgroups[i].name);\n\t\tASSERT_OK(remove(path), \"remove cgroup_iter pin\");\n\t}\n\n\t \n\tsnprintf(path, 128, \"%s%s\", BPFFS_ATTACH_COUNTERS, CG_ROOT_NAME);\n\tASSERT_OK(remove(path), \"remove cgroup_iter root pin\");\n\tcgroup_hierarchical_stats__destroy(skel);\n}\n\nvoid test_cgroup_hierarchical_stats(void)\n{\n\tstruct cgroup_hierarchical_stats *skel = NULL;\n\n\tif (setup_hierarchy())\n\t\tgoto hierarchy_cleanup;\n\tif (setup_progs(&skel))\n\t\tgoto cleanup;\n\tif (attach_processes())\n\t\tgoto cleanup;\n\tcheck_attach_counters();\ncleanup:\n\tdestroy_progs(skel);\nhierarchy_cleanup:\n\tdestroy_hierarchy();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}