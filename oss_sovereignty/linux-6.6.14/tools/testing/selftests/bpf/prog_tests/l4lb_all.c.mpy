{
  "module_name": "l4lb_all.c",
  "hash_id": "63ae0b602c130c70c15878338707537f029e26554fde80ea0ad1e763348610b1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/l4lb_all.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\nstatic void test_l4lb(const char *file)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tstruct vip key = {.protocol = 6};\n\tstruct vip_meta {\n\t\t__u32 flags;\n\t\t__u32 vip_num;\n\t} value = {.vip_num = VIP_NUM};\n\t__u32 stats_key = VIP_NUM;\n\tstruct vip_stats {\n\t\t__u64 bytes;\n\t\t__u64 pkts;\n\t} stats[nr_cpus];\n\tstruct real_definition {\n\t\tunion {\n\t\t\t__be32 dst;\n\t\t\t__be32 dstv6[4];\n\t\t};\n\t\t__u8 flags;\n\t} real_def = {.dst = MAGIC_VAL};\n\t__u32 ch_key = 11, real_num = 3;\n\tint err, i, prog_fd, map_fd;\n\t__u64 bytes = 0, pkts = 0;\n\tstruct bpf_object *obj;\n\tchar buf[128];\n\tu32 *magic = (u32 *)buf;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_out = buf,\n\t\t.data_size_out = sizeof(buf),\n\t\t.repeat = NUM_ITER,\n\t);\n\n\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_SCHED_CLS, &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tmap_fd = bpf_find_map(__func__, obj, \"vip_map\");\n\tif (map_fd < 0)\n\t\tgoto out;\n\tbpf_map_update_elem(map_fd, &key, &value, 0);\n\n\tmap_fd = bpf_find_map(__func__, obj, \"ch_rings\");\n\tif (map_fd < 0)\n\t\tgoto out;\n\tbpf_map_update_elem(map_fd, &ch_key, &real_num, 0);\n\n\tmap_fd = bpf_find_map(__func__, obj, \"reals\");\n\tif (map_fd < 0)\n\t\tgoto out;\n\tbpf_map_update_elem(map_fd, &real_num, &real_def, 0);\n\n\ttopts.data_in = &pkt_v4;\n\ttopts.data_size_in = sizeof(pkt_v4);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, 7  , \"ipv4 test_run retval\");\n\tASSERT_EQ(topts.data_size_out, 54, \"ipv4 test_run data_size_out\");\n\tASSERT_EQ(*magic, MAGIC_VAL, \"ipv4 magic\");\n\n\ttopts.data_in = &pkt_v6;\n\ttopts.data_size_in = sizeof(pkt_v6);\n\ttopts.data_size_out = sizeof(buf);  \n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, 7  , \"ipv6 test_run retval\");\n\tASSERT_EQ(topts.data_size_out, 74, \"ipv6 test_run data_size_out\");\n\tASSERT_EQ(*magic, MAGIC_VAL, \"ipv6 magic\");\n\n\tmap_fd = bpf_find_map(__func__, obj, \"stats\");\n\tif (map_fd < 0)\n\t\tgoto out;\n\tbpf_map_lookup_elem(map_fd, &stats_key, stats);\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tbytes += stats[i].bytes;\n\t\tpkts += stats[i].pkts;\n\t}\n\tif (CHECK_FAIL(bytes != MAGIC_BYTES * NUM_ITER * 2 ||\n\t\t       pkts != NUM_ITER * 2))\n\t\tprintf(\"test_l4lb:FAIL:stats %lld %lld\\n\", bytes, pkts);\nout:\n\tbpf_object__close(obj);\n}\n\nvoid test_l4lb_all(void)\n{\n\tif (test__start_subtest(\"l4lb_inline\"))\n\t\ttest_l4lb(\"test_l4lb.bpf.o\");\n\tif (test__start_subtest(\"l4lb_noinline\"))\n\t\ttest_l4lb(\"test_l4lb_noinline.bpf.o\");\n\tif (test__start_subtest(\"l4lb_noinline_dynptr\"))\n\t\ttest_l4lb(\"test_l4lb_noinline_dynptr.bpf.o\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}