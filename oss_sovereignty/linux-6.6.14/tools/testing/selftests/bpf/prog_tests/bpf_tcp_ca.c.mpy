{
  "module_name": "bpf_tcp_ca.c",
  "hash_id": "63db9ff1c82e43f0a9d977497d42dc3e7862d4b940d65171ad252101d8093fc3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_tcp_ca.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <netinet/tcp.h>\n#include <test_progs.h>\n#include \"network_helpers.h\"\n#include \"bpf_dctcp.skel.h\"\n#include \"bpf_cubic.skel.h\"\n#include \"bpf_tcp_nogpl.skel.h\"\n#include \"tcp_ca_update.skel.h\"\n#include \"bpf_dctcp_release.skel.h\"\n#include \"tcp_ca_write_sk_pacing.skel.h\"\n#include \"tcp_ca_incompl_cong_ops.skel.h\"\n#include \"tcp_ca_unsupp_cong_op.skel.h\"\n\n#ifndef ENOTSUPP\n#define ENOTSUPP 524\n#endif\n\nstatic const unsigned int total_bytes = 10 * 1024 * 1024;\nstatic int expected_stg = 0xeB9F;\nstatic int stop, duration;\n\nstatic int settcpca(int fd, const char *tcp_ca)\n{\n\tint err;\n\n\terr = setsockopt(fd, IPPROTO_TCP, TCP_CONGESTION, tcp_ca, strlen(tcp_ca));\n\tif (CHECK(err == -1, \"setsockopt(fd, TCP_CONGESTION)\", \"errno:%d\\n\",\n\t\t  errno))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void *server(void *arg)\n{\n\tint lfd = (int)(long)arg, err = 0, fd;\n\tssize_t nr_sent = 0, bytes = 0;\n\tchar batch[1500];\n\n\tfd = accept(lfd, NULL, NULL);\n\twhile (fd == -1) {\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\terr = -errno;\n\t\tgoto done;\n\t}\n\n\tif (settimeo(fd, 0)) {\n\t\terr = -errno;\n\t\tgoto done;\n\t}\n\n\twhile (bytes < total_bytes && !READ_ONCE(stop)) {\n\t\tnr_sent = send(fd, &batch,\n\t\t\t       MIN(total_bytes - bytes, sizeof(batch)), 0);\n\t\tif (nr_sent == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (nr_sent == -1) {\n\t\t\terr = -errno;\n\t\t\tbreak;\n\t\t}\n\t\tbytes += nr_sent;\n\t}\n\n\tCHECK(bytes != total_bytes, \"send\", \"%zd != %u nr_sent:%zd errno:%d\\n\",\n\t      bytes, total_bytes, nr_sent, errno);\n\ndone:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (err) {\n\t\tWRITE_ONCE(stop, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn NULL;\n}\n\nstatic void do_test(const char *tcp_ca, const struct bpf_map *sk_stg_map)\n{\n\tstruct sockaddr_in6 sa6 = {};\n\tssize_t nr_recv = 0, bytes = 0;\n\tint lfd = -1, fd = -1;\n\tpthread_t srv_thread;\n\tsocklen_t addrlen = sizeof(sa6);\n\tvoid *thread_ret;\n\tchar batch[1500];\n\tint err;\n\n\tWRITE_ONCE(stop, 0);\n\n\tlfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (CHECK(lfd == -1, \"socket\", \"errno:%d\\n\", errno))\n\t\treturn;\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (CHECK(fd == -1, \"socket\", \"errno:%d\\n\", errno)) {\n\t\tclose(lfd);\n\t\treturn;\n\t}\n\n\tif (settcpca(lfd, tcp_ca) || settcpca(fd, tcp_ca) ||\n\t    settimeo(lfd, 0) || settimeo(fd, 0))\n\t\tgoto done;\n\n\t \n\tsa6.sin6_family = AF_INET6;\n\tsa6.sin6_addr = in6addr_loopback;\n\terr = bind(lfd, (struct sockaddr *)&sa6, addrlen);\n\tif (CHECK(err == -1, \"bind\", \"errno:%d\\n\", errno))\n\t\tgoto done;\n\terr = getsockname(lfd, (struct sockaddr *)&sa6, &addrlen);\n\tif (CHECK(err == -1, \"getsockname\", \"errno:%d\\n\", errno))\n\t\tgoto done;\n\terr = listen(lfd, 1);\n\tif (CHECK(err == -1, \"listen\", \"errno:%d\\n\", errno))\n\t\tgoto done;\n\n\tif (sk_stg_map) {\n\t\terr = bpf_map_update_elem(bpf_map__fd(sk_stg_map), &fd,\n\t\t\t\t\t  &expected_stg, BPF_NOEXIST);\n\t\tif (CHECK(err, \"bpf_map_update_elem(sk_stg_map)\",\n\t\t\t  \"err:%d errno:%d\\n\", err, errno))\n\t\t\tgoto done;\n\t}\n\n\t \n\terr = connect(fd, (struct sockaddr *)&sa6, addrlen);\n\tif (CHECK(err == -1, \"connect\", \"errno:%d\\n\", errno))\n\t\tgoto done;\n\n\tif (sk_stg_map) {\n\t\tint tmp_stg;\n\n\t\terr = bpf_map_lookup_elem(bpf_map__fd(sk_stg_map), &fd,\n\t\t\t\t\t  &tmp_stg);\n\t\tif (CHECK(!err || errno != ENOENT,\n\t\t\t  \"bpf_map_lookup_elem(sk_stg_map)\",\n\t\t\t  \"err:%d errno:%d\\n\", err, errno))\n\t\t\tgoto done;\n\t}\n\n\terr = pthread_create(&srv_thread, NULL, server, (void *)(long)lfd);\n\tif (CHECK(err != 0, \"pthread_create\", \"err:%d errno:%d\\n\", err, errno))\n\t\tgoto done;\n\n\t \n\twhile (bytes < total_bytes && !READ_ONCE(stop)) {\n\t\tnr_recv = recv(fd, &batch,\n\t\t\t       MIN(total_bytes - bytes, sizeof(batch)), 0);\n\t\tif (nr_recv == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (nr_recv == -1)\n\t\t\tbreak;\n\t\tbytes += nr_recv;\n\t}\n\n\tCHECK(bytes != total_bytes, \"recv\", \"%zd != %u nr_recv:%zd errno:%d\\n\",\n\t      bytes, total_bytes, nr_recv, errno);\n\n\tWRITE_ONCE(stop, 1);\n\tpthread_join(srv_thread, &thread_ret);\n\tCHECK(IS_ERR(thread_ret), \"pthread_join\", \"thread_ret:%ld\",\n\t      PTR_ERR(thread_ret));\ndone:\n\tclose(lfd);\n\tclose(fd);\n}\n\nstatic void test_cubic(void)\n{\n\tstruct bpf_cubic *cubic_skel;\n\tstruct bpf_link *link;\n\n\tcubic_skel = bpf_cubic__open_and_load();\n\tif (CHECK(!cubic_skel, \"bpf_cubic__open_and_load\", \"failed\\n\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(cubic_skel->maps.cubic);\n\tif (!ASSERT_OK_PTR(link, \"bpf_map__attach_struct_ops\")) {\n\t\tbpf_cubic__destroy(cubic_skel);\n\t\treturn;\n\t}\n\n\tdo_test(\"bpf_cubic\", NULL);\n\n\tASSERT_EQ(cubic_skel->bss->bpf_cubic_acked_called, 1, \"pkts_acked called\");\n\n\tbpf_link__destroy(link);\n\tbpf_cubic__destroy(cubic_skel);\n}\n\nstatic void test_dctcp(void)\n{\n\tstruct bpf_dctcp *dctcp_skel;\n\tstruct bpf_link *link;\n\n\tdctcp_skel = bpf_dctcp__open_and_load();\n\tif (CHECK(!dctcp_skel, \"bpf_dctcp__open_and_load\", \"failed\\n\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(dctcp_skel->maps.dctcp);\n\tif (!ASSERT_OK_PTR(link, \"bpf_map__attach_struct_ops\")) {\n\t\tbpf_dctcp__destroy(dctcp_skel);\n\t\treturn;\n\t}\n\n\tdo_test(\"bpf_dctcp\", dctcp_skel->maps.sk_stg_map);\n\tCHECK(dctcp_skel->bss->stg_result != expected_stg,\n\t      \"Unexpected stg_result\", \"stg_result (%x) != expected_stg (%x)\\n\",\n\t      dctcp_skel->bss->stg_result, expected_stg);\n\n\tbpf_link__destroy(link);\n\tbpf_dctcp__destroy(dctcp_skel);\n}\n\nstatic char *err_str;\nstatic bool found;\n\nstatic int libbpf_debug_print(enum libbpf_print_level level,\n\t\t\t      const char *format, va_list args)\n{\n\tconst char *prog_name, *log_buf;\n\n\tif (level != LIBBPF_WARN ||\n\t    !strstr(format, \"-- BEGIN PROG LOAD LOG --\")) {\n\t\tvprintf(format, args);\n\t\treturn 0;\n\t}\n\n\tprog_name = va_arg(args, char *);\n\tlog_buf = va_arg(args, char *);\n\tif (!log_buf)\n\t\tgoto out;\n\tif (err_str && strstr(log_buf, err_str) != NULL)\n\t\tfound = true;\nout:\n\tprintf(format, prog_name, log_buf);\n\treturn 0;\n}\n\nstatic void test_invalid_license(void)\n{\n\tlibbpf_print_fn_t old_print_fn;\n\tstruct bpf_tcp_nogpl *skel;\n\n\terr_str = \"struct ops programs must have a GPL compatible license\";\n\tfound = false;\n\told_print_fn = libbpf_set_print(libbpf_debug_print);\n\n\tskel = bpf_tcp_nogpl__open_and_load();\n\tASSERT_NULL(skel, \"bpf_tcp_nogpl\");\n\tASSERT_EQ(found, true, \"expected_err_msg\");\n\n\tbpf_tcp_nogpl__destroy(skel);\n\tlibbpf_set_print(old_print_fn);\n}\n\nstatic void test_dctcp_fallback(void)\n{\n\tint err, lfd = -1, cli_fd = -1, srv_fd = -1;\n\tstruct network_helper_opts opts = {\n\t\t.cc = \"cubic\",\n\t};\n\tstruct bpf_dctcp *dctcp_skel;\n\tstruct bpf_link *link = NULL;\n\tchar srv_cc[16];\n\tsocklen_t cc_len = sizeof(srv_cc);\n\n\tdctcp_skel = bpf_dctcp__open();\n\tif (!ASSERT_OK_PTR(dctcp_skel, \"dctcp_skel\"))\n\t\treturn;\n\tstrcpy(dctcp_skel->rodata->fallback, \"cubic\");\n\tif (!ASSERT_OK(bpf_dctcp__load(dctcp_skel), \"bpf_dctcp__load\"))\n\t\tgoto done;\n\n\tlink = bpf_map__attach_struct_ops(dctcp_skel->maps.dctcp);\n\tif (!ASSERT_OK_PTR(link, \"dctcp link\"))\n\t\tgoto done;\n\n\tlfd = start_server(AF_INET6, SOCK_STREAM, \"::1\", 0, 0);\n\tif (!ASSERT_GE(lfd, 0, \"lfd\") ||\n\t    !ASSERT_OK(settcpca(lfd, \"bpf_dctcp\"), \"lfd=>bpf_dctcp\"))\n\t\tgoto done;\n\n\tcli_fd = connect_to_fd_opts(lfd, &opts);\n\tif (!ASSERT_GE(cli_fd, 0, \"cli_fd\"))\n\t\tgoto done;\n\n\tsrv_fd = accept(lfd, NULL, 0);\n\tif (!ASSERT_GE(srv_fd, 0, \"srv_fd\"))\n\t\tgoto done;\n\tASSERT_STREQ(dctcp_skel->bss->cc_res, \"cubic\", \"cc_res\");\n\tASSERT_EQ(dctcp_skel->bss->tcp_cdg_res, -ENOTSUPP, \"tcp_cdg_res\");\n\t \n\tASSERT_EQ(dctcp_skel->bss->ebusy_cnt, 3, \"ebusy_cnt\");\n\n\terr = getsockopt(srv_fd, SOL_TCP, TCP_CONGESTION, srv_cc, &cc_len);\n\tif (!ASSERT_OK(err, \"getsockopt(srv_fd, TCP_CONGESTION)\"))\n\t\tgoto done;\n\tASSERT_STREQ(srv_cc, \"cubic\", \"srv_fd cc\");\n\ndone:\n\tbpf_link__destroy(link);\n\tbpf_dctcp__destroy(dctcp_skel);\n\tif (lfd != -1)\n\t\tclose(lfd);\n\tif (srv_fd != -1)\n\t\tclose(srv_fd);\n\tif (cli_fd != -1)\n\t\tclose(cli_fd);\n}\n\nstatic void test_rel_setsockopt(void)\n{\n\tstruct bpf_dctcp_release *rel_skel;\n\tlibbpf_print_fn_t old_print_fn;\n\n\terr_str = \"unknown func bpf_setsockopt\";\n\tfound = false;\n\n\told_print_fn = libbpf_set_print(libbpf_debug_print);\n\trel_skel = bpf_dctcp_release__open_and_load();\n\tlibbpf_set_print(old_print_fn);\n\n\tASSERT_ERR_PTR(rel_skel, \"rel_skel\");\n\tASSERT_TRUE(found, \"expected_err_msg\");\n\n\tbpf_dctcp_release__destroy(rel_skel);\n}\n\nstatic void test_write_sk_pacing(void)\n{\n\tstruct tcp_ca_write_sk_pacing *skel;\n\tstruct bpf_link *link;\n\n\tskel = tcp_ca_write_sk_pacing__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.write_sk_pacing);\n\tASSERT_OK_PTR(link, \"attach_struct_ops\");\n\n\tbpf_link__destroy(link);\n\ttcp_ca_write_sk_pacing__destroy(skel);\n}\n\nstatic void test_incompl_cong_ops(void)\n{\n\tstruct tcp_ca_incompl_cong_ops *skel;\n\tstruct bpf_link *link;\n\n\tskel = tcp_ca_incompl_cong_ops__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\t \n\tlink = bpf_map__attach_struct_ops(skel->maps.incompl_cong_ops);\n\tASSERT_ERR_PTR(link, \"attach_struct_ops\");\n\n\tbpf_link__destroy(link);\n\ttcp_ca_incompl_cong_ops__destroy(skel);\n}\n\nstatic void test_unsupp_cong_op(void)\n{\n\tlibbpf_print_fn_t old_print_fn;\n\tstruct tcp_ca_unsupp_cong_op *skel;\n\n\terr_str = \"attach to unsupported member get_info\";\n\tfound = false;\n\told_print_fn = libbpf_set_print(libbpf_debug_print);\n\n\tskel = tcp_ca_unsupp_cong_op__open_and_load();\n\tASSERT_NULL(skel, \"open_and_load\");\n\tASSERT_EQ(found, true, \"expected_err_msg\");\n\n\ttcp_ca_unsupp_cong_op__destroy(skel);\n\tlibbpf_set_print(old_print_fn);\n}\n\nstatic void test_update_ca(void)\n{\n\tstruct tcp_ca_update *skel;\n\tstruct bpf_link *link;\n\tint saved_ca1_cnt;\n\tint err;\n\n\tskel = tcp_ca_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops\");\n\n\tdo_test(\"tcp_ca_update\", NULL);\n\tsaved_ca1_cnt = skel->bss->ca1_cnt;\n\tASSERT_GT(saved_ca1_cnt, 0, \"ca1_ca1_cnt\");\n\n\terr = bpf_link__update_map(link, skel->maps.ca_update_2);\n\tASSERT_OK(err, \"update_map\");\n\n\tdo_test(\"tcp_ca_update\", NULL);\n\tASSERT_EQ(skel->bss->ca1_cnt, saved_ca1_cnt, \"ca2_ca1_cnt\");\n\tASSERT_GT(skel->bss->ca2_cnt, 0, \"ca2_ca2_cnt\");\n\n\tbpf_link__destroy(link);\n\ttcp_ca_update__destroy(skel);\n}\n\nstatic void test_update_wrong(void)\n{\n\tstruct tcp_ca_update *skel;\n\tstruct bpf_link *link;\n\tint saved_ca1_cnt;\n\tint err;\n\n\tskel = tcp_ca_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops\");\n\n\tdo_test(\"tcp_ca_update\", NULL);\n\tsaved_ca1_cnt = skel->bss->ca1_cnt;\n\tASSERT_GT(saved_ca1_cnt, 0, \"ca1_ca1_cnt\");\n\n\terr = bpf_link__update_map(link, skel->maps.ca_wrong);\n\tASSERT_ERR(err, \"update_map\");\n\n\tdo_test(\"tcp_ca_update\", NULL);\n\tASSERT_GT(skel->bss->ca1_cnt, saved_ca1_cnt, \"ca2_ca1_cnt\");\n\n\tbpf_link__destroy(link);\n\ttcp_ca_update__destroy(skel);\n}\n\nstatic void test_mixed_links(void)\n{\n\tstruct tcp_ca_update *skel;\n\tstruct bpf_link *link, *link_nl;\n\tint err;\n\n\tskel = tcp_ca_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open\"))\n\t\treturn;\n\n\tlink_nl = bpf_map__attach_struct_ops(skel->maps.ca_no_link);\n\tASSERT_OK_PTR(link_nl, \"attach_struct_ops_nl\");\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops\");\n\n\tdo_test(\"tcp_ca_update\", NULL);\n\tASSERT_GT(skel->bss->ca1_cnt, 0, \"ca1_ca1_cnt\");\n\n\terr = bpf_link__update_map(link, skel->maps.ca_no_link);\n\tASSERT_ERR(err, \"update_map\");\n\n\tbpf_link__destroy(link);\n\tbpf_link__destroy(link_nl);\n\ttcp_ca_update__destroy(skel);\n}\n\nstatic void test_multi_links(void)\n{\n\tstruct tcp_ca_update *skel;\n\tstruct bpf_link *link;\n\n\tskel = tcp_ca_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops_1st\");\n\tbpf_link__destroy(link);\n\n\t \n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops_2nd\");\n\tbpf_link__destroy(link);\n\n\ttcp_ca_update__destroy(skel);\n}\n\nstatic void test_link_replace(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_link_update_opts, opts);\n\tstruct tcp_ca_update *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = tcp_ca_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open\"))\n\t\treturn;\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_1);\n\tASSERT_OK_PTR(link, \"attach_struct_ops_1st\");\n\tbpf_link__destroy(link);\n\n\tlink = bpf_map__attach_struct_ops(skel->maps.ca_update_2);\n\tASSERT_OK_PTR(link, \"attach_struct_ops_2nd\");\n\n\t \n\topts.old_map_fd = bpf_map__fd(skel->maps.ca_update_1);\n\topts.flags = BPF_F_REPLACE;\n\terr = bpf_link_update(bpf_link__fd(link),\n\t\t\t      bpf_map__fd(skel->maps.ca_update_1),\n\t\t\t      &opts);\n\tASSERT_ERR(err, \"bpf_link_update_fail\");\n\n\t \n\topts.old_map_fd = bpf_map__fd(skel->maps.ca_update_2);\n\terr = bpf_link_update(bpf_link__fd(link),\n\t\t\t      bpf_map__fd(skel->maps.ca_update_1),\n\t\t\t      &opts);\n\tASSERT_OK(err, \"bpf_link_update_success\");\n\n\tbpf_link__destroy(link);\n\n\ttcp_ca_update__destroy(skel);\n}\n\nvoid test_bpf_tcp_ca(void)\n{\n\tif (test__start_subtest(\"dctcp\"))\n\t\ttest_dctcp();\n\tif (test__start_subtest(\"cubic\"))\n\t\ttest_cubic();\n\tif (test__start_subtest(\"invalid_license\"))\n\t\ttest_invalid_license();\n\tif (test__start_subtest(\"dctcp_fallback\"))\n\t\ttest_dctcp_fallback();\n\tif (test__start_subtest(\"rel_setsockopt\"))\n\t\ttest_rel_setsockopt();\n\tif (test__start_subtest(\"write_sk_pacing\"))\n\t\ttest_write_sk_pacing();\n\tif (test__start_subtest(\"incompl_cong_ops\"))\n\t\ttest_incompl_cong_ops();\n\tif (test__start_subtest(\"unsupp_cong_op\"))\n\t\ttest_unsupp_cong_op();\n\tif (test__start_subtest(\"update_ca\"))\n\t\ttest_update_ca();\n\tif (test__start_subtest(\"update_wrong\"))\n\t\ttest_update_wrong();\n\tif (test__start_subtest(\"mixed_links\"))\n\t\ttest_mixed_links();\n\tif (test__start_subtest(\"multi_links\"))\n\t\ttest_multi_links();\n\tif (test__start_subtest(\"link_replace\"))\n\t\ttest_link_replace();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}