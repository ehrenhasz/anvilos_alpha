{
  "module_name": "flow_dissector.c",
  "hash_id": "241a5ddaa215e52a2c71cbfa9b862afc0dd1d162005cca530cbc0b735ef07b49",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/flow_dissector.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <error.h>\n#include <linux/if.h>\n#include <linux/if_tun.h>\n#include <sys/uio.h>\n\n#include \"bpf_flow.skel.h\"\n\n#define FLOW_CONTINUE_SADDR 0x7f00007f  \n\n#ifndef IP_MF\n#define IP_MF 0x2000\n#endif\n\n#define CHECK_FLOW_KEYS(desc, got, expected)\t\t\t\t\\\n\t_CHECK(memcmp(&got, &expected, sizeof(got)) != 0,\t\t\\\n\t      desc,\t\t\t\t\t\t\t\\\n\t      topts.duration,\t\t\t\t\t\t\\\n\t      \"nhoff=%u/%u \"\t\t\t\t\t\t\\\n\t      \"thoff=%u/%u \"\t\t\t\t\t\t\\\n\t      \"addr_proto=0x%x/0x%x \"\t\t\t\t\t\\\n\t      \"is_frag=%u/%u \"\t\t\t\t\t\t\\\n\t      \"is_first_frag=%u/%u \"\t\t\t\t\t\\\n\t      \"is_encap=%u/%u \"\t\t\t\t\t\t\\\n\t      \"ip_proto=0x%x/0x%x \"\t\t\t\t\t\\\n\t      \"n_proto=0x%x/0x%x \"\t\t\t\t\t\\\n\t      \"flow_label=0x%x/0x%x \"\t\t\t\t\t\\\n\t      \"sport=%u/%u \"\t\t\t\t\t\t\\\n\t      \"dport=%u/%u\\n\",\t\t\t\t\t\t\\\n\t      got.nhoff, expected.nhoff,\t\t\t\t\\\n\t      got.thoff, expected.thoff,\t\t\t\t\\\n\t      got.addr_proto, expected.addr_proto,\t\t\t\\\n\t      got.is_frag, expected.is_frag,\t\t\t\t\\\n\t      got.is_first_frag, expected.is_first_frag,\t\t\\\n\t      got.is_encap, expected.is_encap,\t\t\t\t\\\n\t      got.ip_proto, expected.ip_proto,\t\t\t\t\\\n\t      got.n_proto, expected.n_proto,\t\t\t\t\\\n\t      got.flow_label, expected.flow_label,\t\t\t\\\n\t      got.sport, expected.sport,\t\t\t\t\\\n\t      got.dport, expected.dport)\n\nstruct ipv4_pkt {\n\tstruct ethhdr eth;\n\tstruct iphdr iph;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct ipip_pkt {\n\tstruct ethhdr eth;\n\tstruct iphdr iph;\n\tstruct iphdr iph_inner;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct svlan_ipv4_pkt {\n\tstruct ethhdr eth;\n\t__u16 vlan_tci;\n\t__u16 vlan_proto;\n\tstruct iphdr iph;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct ipv6_pkt {\n\tstruct ethhdr eth;\n\tstruct ipv6hdr iph;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct ipv6_frag_pkt {\n\tstruct ethhdr eth;\n\tstruct ipv6hdr iph;\n\tstruct frag_hdr {\n\t\t__u8 nexthdr;\n\t\t__u8 reserved;\n\t\t__be16 frag_off;\n\t\t__be32 identification;\n\t} ipf;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct dvlan_ipv6_pkt {\n\tstruct ethhdr eth;\n\t__u16 vlan_tci;\n\t__u16 vlan_proto;\n\t__u16 vlan_tci2;\n\t__u16 vlan_proto2;\n\tstruct ipv6hdr iph;\n\tstruct tcphdr tcp;\n} __packed;\n\nstruct test {\n\tconst char *name;\n\tunion {\n\t\tstruct ipv4_pkt ipv4;\n\t\tstruct svlan_ipv4_pkt svlan_ipv4;\n\t\tstruct ipip_pkt ipip;\n\t\tstruct ipv6_pkt ipv6;\n\t\tstruct ipv6_frag_pkt ipv6_frag;\n\t\tstruct dvlan_ipv6_pkt dvlan_ipv6;\n\t} pkt;\n\tstruct bpf_flow_keys keys;\n\t__u32 flags;\n\t__u32 retval;\n};\n\n#define VLAN_HLEN\t4\n\nstatic __u32 duration;\nstruct test tests[] = {\n\t{\n\t\t.name = \"ipv4\",\n\t\t.pkt.ipv4 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_TCP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6\",\n\t\t.pkt.ipv6 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_TCP,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"802.1q-ipv4\",\n\t\t.pkt.svlan_ipv4 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_8021Q),\n\t\t\t.vlan_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_TCP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN + VLAN_HLEN,\n\t\t\t.thoff = ETH_HLEN + VLAN_HLEN + sizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"802.1ad-ipv6\",\n\t\t.pkt.dvlan_ipv6 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_8021AD),\n\t\t\t.vlan_proto = __bpf_constant_htons(ETH_P_8021Q),\n\t\t\t.vlan_proto2 = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_TCP,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN + VLAN_HLEN * 2,\n\t\t\t.thoff = ETH_HLEN + VLAN_HLEN * 2 +\n\t\t\t\tsizeof(struct ipv6hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv4-frag\",\n\t\t.pkt.ipv4 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_TCP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.frag_off = __bpf_constant_htons(IP_MF),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.is_frag = true,\n\t\t\t.is_first_frag = true,\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv4-no-frag\",\n\t\t.pkt.ipv4 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_TCP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.frag_off = __bpf_constant_htons(IP_MF),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.is_frag = true,\n\t\t\t.is_first_frag = true,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6-frag\",\n\t\t.pkt.ipv6_frag = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_FRAGMENT,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.ipf.nexthdr = IPPROTO_TCP,\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr) +\n\t\t\t\tsizeof(struct frag_hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.is_frag = true,\n\t\t\t.is_first_frag = true,\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6-no-frag\",\n\t\t.pkt.ipv6_frag = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_FRAGMENT,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.ipf.nexthdr = IPPROTO_TCP,\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr) +\n\t\t\t\tsizeof(struct frag_hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.is_frag = true,\n\t\t\t.is_first_frag = true,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6-flow-label\",\n\t\t.pkt.ipv6 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_TCP,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.flow_lbl = { 0xb, 0xee, 0xef },\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t\t.flow_label = __bpf_constant_htonl(0xbeeef),\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6-no-flow-label\",\n\t\t.pkt.ipv6 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_TCP,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.flow_lbl = { 0xb, 0xee, 0xef },\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL,\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.flow_label = __bpf_constant_htonl(0xbeeef),\n\t\t},\n\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL,\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipv6-empty-flow-label\",\n\t\t.pkt.ipv6 = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.iph.nexthdr = IPPROTO_TCP,\n\t\t\t.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.flow_lbl = { 0x00, 0x00, 0x00 },\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL,\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct ipv6hdr),\n\t\t\t.addr_proto = ETH_P_IPV6,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IPV6),\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL,\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipip-encap\",\n\t\t.pkt.ipip = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_IPIP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph_inner.ihl = 5,\n\t\t\t.iph_inner.protocol = IPPROTO_TCP,\n\t\t\t.iph_inner.tot_len =\n\t\t\t\t__bpf_constant_htons(MAGIC_BYTES) -\n\t\t\t\tsizeof(struct iphdr),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct iphdr) +\n\t\t\t\tsizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_TCP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.is_encap = true,\n\t\t\t.sport = 80,\n\t\t\t.dport = 8080,\n\t\t},\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipip-no-encap\",\n\t\t.pkt.ipip = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_IPIP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph_inner.ihl = 5,\n\t\t\t.iph_inner.protocol = IPPROTO_TCP,\n\t\t\t.iph_inner.tot_len =\n\t\t\t\t__bpf_constant_htons(MAGIC_BYTES) -\n\t\t\t\tsizeof(struct iphdr),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 80,\n\t\t\t.tcp.dest = 8080,\n\t\t},\n\t\t.keys = {\n\t\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP,\n\t\t\t.nhoff = ETH_HLEN,\n\t\t\t.thoff = ETH_HLEN + sizeof(struct iphdr),\n\t\t\t.addr_proto = ETH_P_IP,\n\t\t\t.ip_proto = IPPROTO_IPIP,\n\t\t\t.n_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.is_encap = true,\n\t\t},\n\t\t.flags = BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP,\n\t\t.retval = BPF_OK,\n\t},\n\t{\n\t\t.name = \"ipip-encap-dissector-continue\",\n\t\t.pkt.ipip = {\n\t\t\t.eth.h_proto = __bpf_constant_htons(ETH_P_IP),\n\t\t\t.iph.ihl = 5,\n\t\t\t.iph.protocol = IPPROTO_IPIP,\n\t\t\t.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),\n\t\t\t.iph.saddr = __bpf_constant_htonl(FLOW_CONTINUE_SADDR),\n\t\t\t.iph_inner.ihl = 5,\n\t\t\t.iph_inner.protocol = IPPROTO_TCP,\n\t\t\t.iph_inner.tot_len =\n\t\t\t\t__bpf_constant_htons(MAGIC_BYTES) -\n\t\t\t\tsizeof(struct iphdr),\n\t\t\t.tcp.doff = 5,\n\t\t\t.tcp.source = 99,\n\t\t\t.tcp.dest = 9090,\n\t\t},\n\t\t.retval = BPF_FLOW_DISSECTOR_CONTINUE,\n\t},\n};\n\nstatic int create_tap(const char *ifname)\n{\n\tstruct ifreq ifr = {\n\t\t.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS,\n\t};\n\tint fd, ret;\n\n\tstrncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));\n\n\tfd = open(\"/dev/net/tun\", O_RDWR);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, TUNSETIFF, &ifr);\n\tif (ret)\n\t\treturn -1;\n\n\treturn fd;\n}\n\nstatic int tx_tap(int fd, void *pkt, size_t len)\n{\n\tstruct iovec iov[] = {\n\t\t{\n\t\t\t.iov_len = len,\n\t\t\t.iov_base = pkt,\n\t\t},\n\t};\n\treturn writev(fd, iov, ARRAY_SIZE(iov));\n}\n\nstatic int ifup(const char *ifname)\n{\n\tstruct ifreq ifr = {};\n\tint sk, ret;\n\n\tstrncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));\n\n\tsk = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (sk < 0)\n\t\treturn -1;\n\n\tret = ioctl(sk, SIOCGIFFLAGS, &ifr);\n\tif (ret) {\n\t\tclose(sk);\n\t\treturn -1;\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\tret = ioctl(sk, SIOCSIFFLAGS, &ifr);\n\tif (ret) {\n\t\tclose(sk);\n\t\treturn -1;\n\t}\n\n\tclose(sk);\n\treturn 0;\n}\n\nstatic int init_prog_array(struct bpf_object *obj, struct bpf_map *prog_array)\n{\n\tint i, err, map_fd, prog_fd;\n\tstruct bpf_program *prog;\n\tchar prog_name[32];\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (map_fd < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"flow_dissector_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (!prog)\n\t\t\treturn -1;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (prog_fd < 0)\n\t\t\treturn -1;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void run_tests_skb_less(int tap_fd, struct bpf_map *keys)\n{\n\tint i, err, keys_fd;\n\n\tkeys_fd = bpf_map__fd(keys);\n\tif (CHECK(keys_fd < 0, \"bpf_map__fd\", \"err %d\\n\", keys_fd))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\t \n\t\t__u32 eth_get_headlen_flags =\n\t\t\tBPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG;\n\t\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\t\tstruct bpf_flow_keys flow_keys = {};\n\t\t__u32 key = (__u32)(tests[i].keys.sport) << 16 |\n\t\t\t    tests[i].keys.dport;\n\n\t\t \n\n\t\tif (tests[i].flags != eth_get_headlen_flags)\n\t\t\tcontinue;\n\n\t\terr = tx_tap(tap_fd, &tests[i].pkt, sizeof(tests[i].pkt));\n\t\tCHECK(err < 0, \"tx_tap\", \"err %d errno %d\\n\", err, errno);\n\n\t\t \n\t\tif (tests[i].retval != BPF_OK)\n\t\t\tcontinue;\n\n\t\terr = bpf_map_lookup_elem(keys_fd, &key, &flow_keys);\n\t\tASSERT_OK(err, \"bpf_map_lookup_elem\");\n\n\t\tCHECK_FLOW_KEYS(tests[i].name, flow_keys, tests[i].keys);\n\n\t\terr = bpf_map_delete_elem(keys_fd, &key);\n\t\tASSERT_OK(err, \"bpf_map_delete_elem\");\n\t}\n}\n\nstatic void test_skb_less_prog_attach(struct bpf_flow *skel, int tap_fd)\n{\n\tint err, prog_fd;\n\n\tprog_fd = bpf_program__fd(skel->progs._dissect);\n\tif (CHECK(prog_fd < 0, \"bpf_program__fd\", \"err %d\\n\", prog_fd))\n\t\treturn;\n\n\terr = bpf_prog_attach(prog_fd, 0, BPF_FLOW_DISSECTOR, 0);\n\tif (CHECK(err, \"bpf_prog_attach\", \"err %d errno %d\\n\", err, errno))\n\t\treturn;\n\n\trun_tests_skb_less(tap_fd, skel->maps.last_dissection);\n\n\terr = bpf_prog_detach2(prog_fd, 0, BPF_FLOW_DISSECTOR);\n\tCHECK(err, \"bpf_prog_detach2\", \"err %d errno %d\\n\", err, errno);\n}\n\nstatic void test_skb_less_link_create(struct bpf_flow *skel, int tap_fd)\n{\n\tstruct bpf_link *link;\n\tint err, net_fd;\n\n\tnet_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (CHECK(net_fd < 0, \"open(/proc/self/ns/net)\", \"err %d\\n\", errno))\n\t\treturn;\n\n\tlink = bpf_program__attach_netns(skel->progs._dissect, net_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_netns\"))\n\t\tgoto out_close;\n\n\trun_tests_skb_less(tap_fd, skel->maps.last_dissection);\n\n\terr = bpf_link__destroy(link);\n\tCHECK(err, \"bpf_link__destroy\", \"err %d\\n\", err);\nout_close:\n\tclose(net_fd);\n}\n\nvoid test_flow_dissector(void)\n{\n\tint i, err, prog_fd, keys_fd = -1, tap_fd;\n\tstruct bpf_flow *skel;\n\n\tskel = bpf_flow__open_and_load();\n\tif (CHECK(!skel, \"skel\", \"failed to open/load skeleton\\n\"))\n\t\treturn;\n\n\tprog_fd = bpf_program__fd(skel->progs._dissect);\n\tif (CHECK(prog_fd < 0, \"bpf_program__fd\", \"err %d\\n\", prog_fd))\n\t\tgoto out_destroy_skel;\n\tkeys_fd = bpf_map__fd(skel->maps.last_dissection);\n\tif (CHECK(keys_fd < 0, \"bpf_map__fd\", \"err %d\\n\", keys_fd))\n\t\tgoto out_destroy_skel;\n\terr = init_prog_array(skel->obj, skel->maps.jmp_table);\n\tif (CHECK(err, \"init_prog_array\", \"err %d\\n\", err))\n\t\tgoto out_destroy_skel;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tstruct bpf_flow_keys flow_keys;\n\t\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t\t.data_in = &tests[i].pkt,\n\t\t\t.data_size_in = sizeof(tests[i].pkt),\n\t\t\t.data_out = &flow_keys,\n\t\t);\n\t\tstatic struct bpf_flow_keys ctx = {};\n\n\t\tif (tests[i].flags) {\n\t\t\ttopts.ctx_in = &ctx;\n\t\t\ttopts.ctx_size_in = sizeof(ctx);\n\t\t\tctx.flags = tests[i].flags;\n\t\t}\n\n\t\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\t\tASSERT_OK(err, \"test_run\");\n\t\tASSERT_EQ(topts.retval, tests[i].retval, \"test_run retval\");\n\n\t\t \n\t\tif (topts.retval != BPF_OK)\n\t\t\tcontinue;\n\t\tASSERT_EQ(topts.data_size_out, sizeof(flow_keys),\n\t\t\t  \"test_run data_size_out\");\n\t\tCHECK_FLOW_KEYS(tests[i].name, flow_keys, tests[i].keys);\n\t}\n\n\t \n\n\ttap_fd = create_tap(\"tap0\");\n\tCHECK(tap_fd < 0, \"create_tap\", \"tap_fd %d errno %d\\n\", tap_fd, errno);\n\terr = ifup(\"tap0\");\n\tCHECK(err, \"ifup\", \"err %d errno %d\\n\", err, errno);\n\n\t \n\ttest_skb_less_prog_attach(skel, tap_fd);\n\t \n\ttest_skb_less_link_create(skel, tap_fd);\n\n\tclose(tap_fd);\nout_destroy_skel:\n\tbpf_flow__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}