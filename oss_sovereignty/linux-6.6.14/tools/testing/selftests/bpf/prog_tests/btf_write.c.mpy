{
  "module_name": "btf_write.c",
  "hash_id": "90cdbeb3ec9f72f89708e2ce40f988d34ea3c224c8360826c4afd681ca583fb7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_write.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <bpf/btf.h>\n#include \"btf_helpers.h\"\n\nstatic void gen_btf(struct btf *btf)\n{\n\tconst struct btf_var_secinfo *vi;\n\tconst struct btf_type *t;\n\tconst struct btf_member *m;\n\tconst struct btf_enum64 *v64;\n\tconst struct btf_enum *v;\n\tconst struct btf_param *p;\n\tint id, err, str_off;\n\n\tstr_off = btf__find_str(btf, \"int\");\n\tASSERT_EQ(str_off, -ENOENT, \"int_str_missing_off\");\n\n\tstr_off = btf__add_str(btf, \"int\");\n\tASSERT_EQ(str_off, 1, \"int_str_off\");\n\n\tstr_off = btf__find_str(btf, \"int\");\n\tASSERT_EQ(str_off, 1, \"int_str_found_off\");\n\n\t \n\tid = btf__add_int(btf, \"int\", 4,  BTF_INT_SIGNED);\n\tASSERT_EQ(id, 1, \"int_id\");\n\n\tt = btf__type_by_id(btf, 1);\n\t \n\tASSERT_EQ(t->name_off, str_off, \"int_name_off\");\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"int\", \"int_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_INT, \"int_kind\");\n\tASSERT_EQ(t->size, 4, \"int_sz\");\n\tASSERT_EQ(btf_int_encoding(t), BTF_INT_SIGNED, \"int_enc\");\n\tASSERT_EQ(btf_int_bits(t), 32, \"int_bits\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 1),\n\t\t     \"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\", \"raw_dump\");\n\n\t \n\tid = btf__add_int(btf, \"bad sz int\", 7, 0);\n\tASSERT_ERR(id, \"int_bad_sz\");\n\t \n\tid = btf__add_int(btf, \"bad enc int\", 4, 123);\n\tASSERT_ERR(id, \"int_bad_enc\");\n\t \n\tid = btf__add_int(btf, NULL, 4, 0);\n\tASSERT_ERR(id, \"int_bad_null_name\");\n\t \n\tid = btf__add_int(btf, \"\", 4, 0);\n\tASSERT_ERR(id, \"int_bad_empty_name\");\n\n\t \n\tid = btf__add_ptr(btf, 1);\n\tASSERT_EQ(id, 2, \"ptr_id\");\n\tt = btf__type_by_id(btf, 2);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_PTR, \"ptr_kind\");\n\tASSERT_EQ(t->type, 1, \"ptr_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 2),\n\t\t     \"[2] PTR '(anon)' type_id=1\", \"raw_dump\");\n\n\tid = btf__add_const(btf, 5);  \n\tASSERT_EQ(id, 3, \"const_id\");\n\tt = btf__type_by_id(btf, 3);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_CONST, \"const_kind\");\n\tASSERT_EQ(t->type, 5, \"const_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 3),\n\t\t     \"[3] CONST '(anon)' type_id=5\", \"raw_dump\");\n\n\tid = btf__add_volatile(btf, 3);\n\tASSERT_EQ(id, 4, \"volatile_id\");\n\tt = btf__type_by_id(btf, 4);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_VOLATILE, \"volatile_kind\");\n\tASSERT_EQ(t->type, 3, \"volatile_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 4),\n\t\t     \"[4] VOLATILE '(anon)' type_id=3\", \"raw_dump\");\n\n\tid = btf__add_restrict(btf, 4);\n\tASSERT_EQ(id, 5, \"restrict_id\");\n\tt = btf__type_by_id(btf, 5);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_RESTRICT, \"restrict_kind\");\n\tASSERT_EQ(t->type, 4, \"restrict_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 5),\n\t\t     \"[5] RESTRICT '(anon)' type_id=4\", \"raw_dump\");\n\n\t \n\tid = btf__add_array(btf, 1, 2, 10);  \n\tASSERT_EQ(id, 6, \"array_id\");\n\tt = btf__type_by_id(btf, 6);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_ARRAY, \"array_kind\");\n\tASSERT_EQ(btf_array(t)->index_type, 1, \"array_index_type\");\n\tASSERT_EQ(btf_array(t)->type, 2, \"array_elem_type\");\n\tASSERT_EQ(btf_array(t)->nelems, 10, \"array_nelems\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 6),\n\t\t     \"[6] ARRAY '(anon)' type_id=2 index_type_id=1 nr_elems=10\", \"raw_dump\");\n\n\t \n\terr = btf__add_field(btf, \"field\", 1, 0, 0);\n\tASSERT_ERR(err, \"no_struct_field\");\n\tid = btf__add_struct(btf, \"s1\", 8);\n\tASSERT_EQ(id, 7, \"struct_id\");\n\terr = btf__add_field(btf, \"f1\", 1, 0, 0);\n\tASSERT_OK(err, \"f1_res\");\n\terr = btf__add_field(btf, \"f2\", 1, 32, 16);\n\tASSERT_OK(err, \"f2_res\");\n\n\tt = btf__type_by_id(btf, 7);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"s1\", \"struct_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_STRUCT, \"struct_kind\");\n\tASSERT_EQ(btf_vlen(t), 2, \"struct_vlen\");\n\tASSERT_EQ(btf_kflag(t), true, \"struct_kflag\");\n\tASSERT_EQ(t->size, 8, \"struct_sz\");\n\tm = btf_members(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, m->name_off), \"f1\", \"f1_name\");\n\tASSERT_EQ(m->type, 1, \"f1_type\");\n\tASSERT_EQ(btf_member_bit_offset(t, 0), 0, \"f1_bit_off\");\n\tASSERT_EQ(btf_member_bitfield_size(t, 0), 0, \"f1_bit_sz\");\n\tm = btf_members(t) + 1;\n\tASSERT_STREQ(btf__str_by_offset(btf, m->name_off), \"f2\", \"f2_name\");\n\tASSERT_EQ(m->type, 1, \"f2_type\");\n\tASSERT_EQ(btf_member_bit_offset(t, 1), 32, \"f2_bit_off\");\n\tASSERT_EQ(btf_member_bitfield_size(t, 1), 16, \"f2_bit_sz\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 7),\n\t\t     \"[7] STRUCT 's1' size=8 vlen=2\\n\"\n\t\t     \"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t     \"\\t'f2' type_id=1 bits_offset=32 bitfield_size=16\", \"raw_dump\");\n\n\t \n\tid = btf__add_union(btf, \"u1\", 8);\n\tASSERT_EQ(id, 8, \"union_id\");\n\n\t \n\terr = btf__add_field(btf, \"field\", 1, 1, 0);\n\tASSERT_ERR(err, \"no_struct_field\");\n\n\terr = btf__add_field(btf, \"f1\", 1, 0, 16);\n\tASSERT_OK(err, \"f1_res\");\n\n\tt = btf__type_by_id(btf, 8);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"u1\", \"union_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_UNION, \"union_kind\");\n\tASSERT_EQ(btf_vlen(t), 1, \"union_vlen\");\n\tASSERT_EQ(btf_kflag(t), true, \"union_kflag\");\n\tASSERT_EQ(t->size, 8, \"union_sz\");\n\tm = btf_members(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, m->name_off), \"f1\", \"f1_name\");\n\tASSERT_EQ(m->type, 1, \"f1_type\");\n\tASSERT_EQ(btf_member_bit_offset(t, 0), 0, \"f1_bit_off\");\n\tASSERT_EQ(btf_member_bitfield_size(t, 0), 16, \"f1_bit_sz\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 8),\n\t\t     \"[8] UNION 'u1' size=8 vlen=1\\n\"\n\t\t     \"\\t'f1' type_id=1 bits_offset=0 bitfield_size=16\", \"raw_dump\");\n\n\t \n\tid = btf__add_enum(btf, \"e1\", 4);\n\tASSERT_EQ(id, 9, \"enum_id\");\n\terr = btf__add_enum_value(btf, \"v1\", 1);\n\tASSERT_OK(err, \"v1_res\");\n\terr = btf__add_enum_value(btf, \"v2\", 2);\n\tASSERT_OK(err, \"v2_res\");\n\n\tt = btf__type_by_id(btf, 9);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"e1\", \"enum_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_ENUM, \"enum_kind\");\n\tASSERT_EQ(btf_vlen(t), 2, \"enum_vlen\");\n\tASSERT_EQ(t->size, 4, \"enum_sz\");\n\tv = btf_enum(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, v->name_off), \"v1\", \"v1_name\");\n\tASSERT_EQ(v->val, 1, \"v1_val\");\n\tv = btf_enum(t) + 1;\n\tASSERT_STREQ(btf__str_by_offset(btf, v->name_off), \"v2\", \"v2_name\");\n\tASSERT_EQ(v->val, 2, \"v2_val\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 9),\n\t\t     \"[9] ENUM 'e1' encoding=UNSIGNED size=4 vlen=2\\n\"\n\t\t     \"\\t'v1' val=1\\n\"\n\t\t     \"\\t'v2' val=2\", \"raw_dump\");\n\n\t \n\tid = btf__add_fwd(btf, \"struct_fwd\", BTF_FWD_STRUCT);\n\tASSERT_EQ(id, 10, \"struct_fwd_id\");\n\tt = btf__type_by_id(btf, 10);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"struct_fwd\", \"fwd_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_FWD, \"fwd_kind\");\n\tASSERT_EQ(btf_kflag(t), 0, \"fwd_kflag\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 10),\n\t\t     \"[10] FWD 'struct_fwd' fwd_kind=struct\", \"raw_dump\");\n\n\tid = btf__add_fwd(btf, \"union_fwd\", BTF_FWD_UNION);\n\tASSERT_EQ(id, 11, \"union_fwd_id\");\n\tt = btf__type_by_id(btf, 11);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"union_fwd\", \"fwd_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_FWD, \"fwd_kind\");\n\tASSERT_EQ(btf_kflag(t), 1, \"fwd_kflag\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 11),\n\t\t     \"[11] FWD 'union_fwd' fwd_kind=union\", \"raw_dump\");\n\n\tid = btf__add_fwd(btf, \"enum_fwd\", BTF_FWD_ENUM);\n\tASSERT_EQ(id, 12, \"enum_fwd_id\");\n\tt = btf__type_by_id(btf, 12);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"enum_fwd\", \"fwd_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_ENUM, \"enum_fwd_kind\");\n\tASSERT_EQ(btf_vlen(t), 0, \"enum_fwd_kind\");\n\tASSERT_EQ(t->size, 4, \"enum_fwd_sz\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 12),\n\t\t     \"[12] ENUM 'enum_fwd' encoding=UNSIGNED size=4 vlen=0\", \"raw_dump\");\n\n\t \n\tid = btf__add_typedef(btf, \"typedef1\", 1);\n\tASSERT_EQ(id, 13, \"typedef_fwd_id\");\n\tt = btf__type_by_id(btf, 13);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"typedef1\", \"typedef_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_TYPEDEF, \"typedef_kind\");\n\tASSERT_EQ(t->type, 1, \"typedef_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 13),\n\t\t     \"[13] TYPEDEF 'typedef1' type_id=1\", \"raw_dump\");\n\n\t \n\tid = btf__add_func(btf, \"func1\", BTF_FUNC_GLOBAL, 15);\n\tASSERT_EQ(id, 14, \"func_id\");\n\tt = btf__type_by_id(btf, 14);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"func1\", \"func_name\");\n\tASSERT_EQ(t->type, 15, \"func_type\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_FUNC, \"func_kind\");\n\tASSERT_EQ(btf_vlen(t), BTF_FUNC_GLOBAL, \"func_vlen\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 14),\n\t\t     \"[14] FUNC 'func1' type_id=15 linkage=global\", \"raw_dump\");\n\n\tid = btf__add_func_proto(btf, 1);\n\tASSERT_EQ(id, 15, \"func_proto_id\");\n\terr = btf__add_func_param(btf, \"p1\", 1);\n\tASSERT_OK(err, \"p1_res\");\n\terr = btf__add_func_param(btf, \"p2\", 2);\n\tASSERT_OK(err, \"p2_res\");\n\n\tt = btf__type_by_id(btf, 15);\n\tASSERT_EQ(btf_kind(t), BTF_KIND_FUNC_PROTO, \"func_proto_kind\");\n\tASSERT_EQ(btf_vlen(t), 2, \"func_proto_vlen\");\n\tASSERT_EQ(t->type, 1, \"func_proto_ret_type\");\n\tp = btf_params(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, p->name_off), \"p1\", \"p1_name\");\n\tASSERT_EQ(p->type, 1, \"p1_type\");\n\tp = btf_params(t) + 1;\n\tASSERT_STREQ(btf__str_by_offset(btf, p->name_off), \"p2\", \"p2_name\");\n\tASSERT_EQ(p->type, 2, \"p2_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 15),\n\t\t     \"[15] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\\n\"\n\t\t     \"\\t'p1' type_id=1\\n\"\n\t\t     \"\\t'p2' type_id=2\", \"raw_dump\");\n\n\t \n\tid = btf__add_var(btf, \"var1\", BTF_VAR_GLOBAL_ALLOCATED, 1);\n\tASSERT_EQ(id, 16, \"var_id\");\n\tt = btf__type_by_id(btf, 16);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"var1\", \"var_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_VAR, \"var_kind\");\n\tASSERT_EQ(t->type, 1, \"var_type\");\n\tASSERT_EQ(btf_var(t)->linkage, BTF_VAR_GLOBAL_ALLOCATED, \"var_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 16),\n\t\t     \"[16] VAR 'var1' type_id=1, linkage=global-alloc\", \"raw_dump\");\n\n\t \n\tid = btf__add_datasec(btf, \"datasec1\", 12);\n\tASSERT_EQ(id, 17, \"datasec_id\");\n\terr = btf__add_datasec_var_info(btf, 1, 4, 8);\n\tASSERT_OK(err, \"v1_res\");\n\n\tt = btf__type_by_id(btf, 17);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"datasec1\", \"datasec_name\");\n\tASSERT_EQ(t->size, 12, \"datasec_sz\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_DATASEC, \"datasec_kind\");\n\tASSERT_EQ(btf_vlen(t), 1, \"datasec_vlen\");\n\tvi = btf_var_secinfos(t) + 0;\n\tASSERT_EQ(vi->type, 1, \"v1_type\");\n\tASSERT_EQ(vi->offset, 4, \"v1_off\");\n\tASSERT_EQ(vi->size, 8, \"v1_sz\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 17),\n\t\t     \"[17] DATASEC 'datasec1' size=12 vlen=1\\n\"\n\t\t     \"\\ttype_id=1 offset=4 size=8\", \"raw_dump\");\n\n\t \n\tid = btf__add_decl_tag(btf, \"tag1\", 16, -1);\n\tASSERT_EQ(id, 18, \"tag_id\");\n\tt = btf__type_by_id(btf, 18);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"tag1\", \"tag_value\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_DECL_TAG, \"tag_kind\");\n\tASSERT_EQ(t->type, 16, \"tag_type\");\n\tASSERT_EQ(btf_decl_tag(t)->component_idx, -1, \"tag_component_idx\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 18),\n\t\t     \"[18] DECL_TAG 'tag1' type_id=16 component_idx=-1\", \"raw_dump\");\n\n\tid = btf__add_decl_tag(btf, \"tag2\", 14, 1);\n\tASSERT_EQ(id, 19, \"tag_id\");\n\tt = btf__type_by_id(btf, 19);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"tag2\", \"tag_value\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_DECL_TAG, \"tag_kind\");\n\tASSERT_EQ(t->type, 14, \"tag_type\");\n\tASSERT_EQ(btf_decl_tag(t)->component_idx, 1, \"tag_component_idx\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 19),\n\t\t     \"[19] DECL_TAG 'tag2' type_id=14 component_idx=1\", \"raw_dump\");\n\n\t \n\tid = btf__add_type_tag(btf, \"tag1\", 1);\n\tASSERT_EQ(id, 20, \"tag_id\");\n\tt = btf__type_by_id(btf, 20);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"tag1\", \"tag_value\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_TYPE_TAG, \"tag_kind\");\n\tASSERT_EQ(t->type, 1, \"tag_type\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 20),\n\t\t     \"[20] TYPE_TAG 'tag1' type_id=1\", \"raw_dump\");\n\n\t \n\tid = btf__add_enum64(btf, \"e1\", 8, true);\n\tASSERT_EQ(id, 21, \"enum64_id\");\n\terr = btf__add_enum64_value(btf, \"v1\", -1);\n\tASSERT_OK(err, \"v1_res\");\n\terr = btf__add_enum64_value(btf, \"v2\", 0x123456789);  \n\tASSERT_OK(err, \"v2_res\");\n\tt = btf__type_by_id(btf, 21);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"e1\", \"enum64_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_ENUM64, \"enum64_kind\");\n\tASSERT_EQ(btf_vlen(t), 2, \"enum64_vlen\");\n\tASSERT_EQ(t->size, 8, \"enum64_sz\");\n\tv64 = btf_enum64(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, v64->name_off), \"v1\", \"v1_name\");\n\tASSERT_EQ(v64->val_hi32, 0xffffffff, \"v1_val\");\n\tASSERT_EQ(v64->val_lo32, 0xffffffff, \"v1_val\");\n\tv64 = btf_enum64(t) + 1;\n\tASSERT_STREQ(btf__str_by_offset(btf, v64->name_off), \"v2\", \"v2_name\");\n\tASSERT_EQ(v64->val_hi32, 0x1, \"v2_val\");\n\tASSERT_EQ(v64->val_lo32, 0x23456789, \"v2_val\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 21),\n\t\t     \"[21] ENUM64 'e1' encoding=SIGNED size=8 vlen=2\\n\"\n\t\t     \"\\t'v1' val=-1\\n\"\n\t\t     \"\\t'v2' val=4886718345\", \"raw_dump\");\n\n\tid = btf__add_enum64(btf, \"e1\", 8, false);\n\tASSERT_EQ(id, 22, \"enum64_id\");\n\terr = btf__add_enum64_value(btf, \"v1\", 0xffffffffFFFFFFFF);  \n\tASSERT_OK(err, \"v1_res\");\n\tt = btf__type_by_id(btf, 22);\n\tASSERT_STREQ(btf__str_by_offset(btf, t->name_off), \"e1\", \"enum64_name\");\n\tASSERT_EQ(btf_kind(t), BTF_KIND_ENUM64, \"enum64_kind\");\n\tASSERT_EQ(btf_vlen(t), 1, \"enum64_vlen\");\n\tASSERT_EQ(t->size, 8, \"enum64_sz\");\n\tv64 = btf_enum64(t) + 0;\n\tASSERT_STREQ(btf__str_by_offset(btf, v64->name_off), \"v1\", \"v1_name\");\n\tASSERT_EQ(v64->val_hi32, 0xffffffff, \"v1_val\");\n\tASSERT_EQ(v64->val_lo32, 0xffffffff, \"v1_val\");\n\tASSERT_STREQ(btf_type_raw_dump(btf, 22),\n\t\t     \"[22] ENUM64 'e1' encoding=UNSIGNED size=8 vlen=1\\n\"\n\t\t     \"\\t'v1' val=18446744073709551615\", \"raw_dump\");\n}\n\nstatic void test_btf_add()\n{\n\tstruct btf *btf;\n\n\tbtf = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf, \"new_empty\"))\n\t\treturn;\n\n\tgen_btf(btf);\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=1\",\n\t\t\"[3] CONST '(anon)' type_id=5\",\n\t\t\"[4] VOLATILE '(anon)' type_id=3\",\n\t\t\"[5] RESTRICT '(anon)' type_id=4\",\n\t\t\"[6] ARRAY '(anon)' type_id=2 index_type_id=1 nr_elems=10\",\n\t\t\"[7] STRUCT 's1' size=8 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=1 bits_offset=32 bitfield_size=16\",\n\t\t\"[8] UNION 'u1' size=8 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0 bitfield_size=16\",\n\t\t\"[9] ENUM 'e1' encoding=UNSIGNED size=4 vlen=2\\n\"\n\t\t\"\\t'v1' val=1\\n\"\n\t\t\"\\t'v2' val=2\",\n\t\t\"[10] FWD 'struct_fwd' fwd_kind=struct\",\n\t\t\"[11] FWD 'union_fwd' fwd_kind=union\",\n\t\t\"[12] ENUM 'enum_fwd' encoding=UNSIGNED size=4 vlen=0\",\n\t\t\"[13] TYPEDEF 'typedef1' type_id=1\",\n\t\t\"[14] FUNC 'func1' type_id=15 linkage=global\",\n\t\t\"[15] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\\n\"\n\t\t\"\\t'p1' type_id=1\\n\"\n\t\t\"\\t'p2' type_id=2\",\n\t\t\"[16] VAR 'var1' type_id=1, linkage=global-alloc\",\n\t\t\"[17] DATASEC 'datasec1' size=12 vlen=1\\n\"\n\t\t\"\\ttype_id=1 offset=4 size=8\",\n\t\t\"[18] DECL_TAG 'tag1' type_id=16 component_idx=-1\",\n\t\t\"[19] DECL_TAG 'tag2' type_id=14 component_idx=1\",\n\t\t\"[20] TYPE_TAG 'tag1' type_id=1\",\n\t\t\"[21] ENUM64 'e1' encoding=SIGNED size=8 vlen=2\\n\"\n\t\t\"\\t'v1' val=-1\\n\"\n\t\t\"\\t'v2' val=4886718345\",\n\t\t\"[22] ENUM64 'e1' encoding=UNSIGNED size=8 vlen=1\\n\"\n\t\t\"\\t'v1' val=18446744073709551615\");\n\n\tbtf__free(btf);\n}\n\nstatic void test_btf_add_btf()\n{\n\tstruct btf *btf1 = NULL, *btf2 = NULL;\n\tint id;\n\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"btf1\"))\n\t\treturn;\n\n\tbtf2 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf2, \"btf2\"))\n\t\tgoto cleanup;\n\n\tgen_btf(btf1);\n\tgen_btf(btf2);\n\n\tid = btf__add_btf(btf1, btf2);\n\tif (!ASSERT_EQ(id, 23, \"id\"))\n\t\tgoto cleanup;\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf1,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=1\",\n\t\t\"[3] CONST '(anon)' type_id=5\",\n\t\t\"[4] VOLATILE '(anon)' type_id=3\",\n\t\t\"[5] RESTRICT '(anon)' type_id=4\",\n\t\t\"[6] ARRAY '(anon)' type_id=2 index_type_id=1 nr_elems=10\",\n\t\t\"[7] STRUCT 's1' size=8 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=1 bits_offset=32 bitfield_size=16\",\n\t\t\"[8] UNION 'u1' size=8 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0 bitfield_size=16\",\n\t\t\"[9] ENUM 'e1' encoding=UNSIGNED size=4 vlen=2\\n\"\n\t\t\"\\t'v1' val=1\\n\"\n\t\t\"\\t'v2' val=2\",\n\t\t\"[10] FWD 'struct_fwd' fwd_kind=struct\",\n\t\t\"[11] FWD 'union_fwd' fwd_kind=union\",\n\t\t\"[12] ENUM 'enum_fwd' encoding=UNSIGNED size=4 vlen=0\",\n\t\t\"[13] TYPEDEF 'typedef1' type_id=1\",\n\t\t\"[14] FUNC 'func1' type_id=15 linkage=global\",\n\t\t\"[15] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\\n\"\n\t\t\"\\t'p1' type_id=1\\n\"\n\t\t\"\\t'p2' type_id=2\",\n\t\t\"[16] VAR 'var1' type_id=1, linkage=global-alloc\",\n\t\t\"[17] DATASEC 'datasec1' size=12 vlen=1\\n\"\n\t\t\"\\ttype_id=1 offset=4 size=8\",\n\t\t\"[18] DECL_TAG 'tag1' type_id=16 component_idx=-1\",\n\t\t\"[19] DECL_TAG 'tag2' type_id=14 component_idx=1\",\n\t\t\"[20] TYPE_TAG 'tag1' type_id=1\",\n\t\t\"[21] ENUM64 'e1' encoding=SIGNED size=8 vlen=2\\n\"\n\t\t\"\\t'v1' val=-1\\n\"\n\t\t\"\\t'v2' val=4886718345\",\n\t\t\"[22] ENUM64 'e1' encoding=UNSIGNED size=8 vlen=1\\n\"\n\t\t\"\\t'v1' val=18446744073709551615\",\n\n\t\t \n\t\t\"[23] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[24] PTR '(anon)' type_id=23\",\n\t\t\"[25] CONST '(anon)' type_id=27\",\n\t\t\"[26] VOLATILE '(anon)' type_id=25\",\n\t\t\"[27] RESTRICT '(anon)' type_id=26\",\n\t\t\"[28] ARRAY '(anon)' type_id=24 index_type_id=23 nr_elems=10\",\n\t\t\"[29] STRUCT 's1' size=8 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=23 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=23 bits_offset=32 bitfield_size=16\",\n\t\t\"[30] UNION 'u1' size=8 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=23 bits_offset=0 bitfield_size=16\",\n\t\t\"[31] ENUM 'e1' encoding=UNSIGNED size=4 vlen=2\\n\"\n\t\t\"\\t'v1' val=1\\n\"\n\t\t\"\\t'v2' val=2\",\n\t\t\"[32] FWD 'struct_fwd' fwd_kind=struct\",\n\t\t\"[33] FWD 'union_fwd' fwd_kind=union\",\n\t\t\"[34] ENUM 'enum_fwd' encoding=UNSIGNED size=4 vlen=0\",\n\t\t\"[35] TYPEDEF 'typedef1' type_id=23\",\n\t\t\"[36] FUNC 'func1' type_id=37 linkage=global\",\n\t\t\"[37] FUNC_PROTO '(anon)' ret_type_id=23 vlen=2\\n\"\n\t\t\"\\t'p1' type_id=23\\n\"\n\t\t\"\\t'p2' type_id=24\",\n\t\t\"[38] VAR 'var1' type_id=23, linkage=global-alloc\",\n\t\t\"[39] DATASEC 'datasec1' size=12 vlen=1\\n\"\n\t\t\"\\ttype_id=23 offset=4 size=8\",\n\t\t\"[40] DECL_TAG 'tag1' type_id=38 component_idx=-1\",\n\t\t\"[41] DECL_TAG 'tag2' type_id=36 component_idx=1\",\n\t\t\"[42] TYPE_TAG 'tag1' type_id=23\",\n\t\t\"[43] ENUM64 'e1' encoding=SIGNED size=8 vlen=2\\n\"\n\t\t\"\\t'v1' val=-1\\n\"\n\t\t\"\\t'v2' val=4886718345\",\n\t\t\"[44] ENUM64 'e1' encoding=UNSIGNED size=8 vlen=1\\n\"\n\t\t\"\\t'v1' val=18446744073709551615\");\n\ncleanup:\n\tbtf__free(btf1);\n\tbtf__free(btf2);\n}\n\nvoid test_btf_write()\n{\n\tif (test__start_subtest(\"btf_add\"))\n\t\ttest_btf_add();\n\tif (test__start_subtest(\"btf_add_btf\"))\n\t\ttest_btf_add_btf();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}