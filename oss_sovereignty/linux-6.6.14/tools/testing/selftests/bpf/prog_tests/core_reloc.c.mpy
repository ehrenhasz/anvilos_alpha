{
  "module_name": "core_reloc.c",
  "hash_id": "f7e4920f8b2a994b4510507b9f49c77a827e20e39155dac626d9fb0d5bdae286",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/core_reloc.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include \"progs/core_reloc_types.h\"\n#include \"bpf_testmod/bpf_testmod.h\"\n#include <linux/limits.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <bpf/btf.h>\n\nstatic int duration = 0;\n\n#define STRUCT_TO_CHAR_PTR(struct_name) (const char *)&(struct struct_name)\n\n#define MODULES_CASE(name, pg_name, tp_name) {\t\t\t\t\\\n\t.case_name = name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_module.bpf.o\",\t\t\t\\\n\t.btf_src_file = NULL,  \t\t\\\n\t.input = \"\",\t\t\t\t\t\t\t\\\n\t.input_len = 0,\t\t\t\t\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_module_output) {\t\\\n\t\t.read_ctx_sz = sizeof(struct bpf_testmod_test_read_ctx),\\\n\t\t.read_ctx_exists = true,\t\t\t\t\\\n\t\t.buf_exists = true,\t\t\t\t\t\\\n\t\t.len_exists = true,\t\t\t\t\t\\\n\t\t.off_exists = true,\t\t\t\t\t\\\n\t\t.len = 123,\t\t\t\t\t\t\\\n\t\t.off = 0,\t\t\t\t\t\t\\\n\t\t.comm = \"test_progs\",\t\t\t\t\t\\\n\t\t.comm_len = sizeof(\"test_progs\"),\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_module_output),\t\t\\\n\t.prog_name = pg_name,\t\t\t\t\t\t\\\n\t.raw_tp_name = tp_name,\t\t\t\t\t\t\\\n\t.trigger = __trigger_module_test_read,\t\t\t\t\\\n\t.needs_testmod = true,\t\t\t\t\t\t\\\n}\n\n#define FLAVORS_DATA(struct_name) STRUCT_TO_CHAR_PTR(struct_name) {\t\\\n\t.a = 42,\t\t\t\t\t\t\t\\\n\t.b = 0xc001,\t\t\t\t\t\t\t\\\n\t.c = 0xbeef,\t\t\t\t\t\t\t\\\n}\n\n#define FLAVORS_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_flavors.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_flavors\"\t\t\t\t\\\n\n#define FLAVORS_CASE(name) {\t\t\t\t\t\t\\\n\tFLAVORS_CASE_COMMON(name),\t\t\t\t\t\\\n\t.input = FLAVORS_DATA(core_reloc_##name),\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = FLAVORS_DATA(core_reloc_flavors),\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_flavors),\t\t\\\n}\n\n#define FLAVORS_ERR_CASE(name) {\t\t\t\t\t\\\n\tFLAVORS_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define NESTING_DATA(struct_name) STRUCT_TO_CHAR_PTR(struct_name) {\t\\\n\t.a = { .a = { .a = 42 } },\t\t\t\t\t\\\n\t.b = { .b = { .b = 0xc001 } },\t\t\t\t\t\\\n}\n\n#define NESTING_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_nesting.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_nesting\"\t\t\t\t\\\n\n#define NESTING_CASE(name) {\t\t\t\t\t\t\\\n\tNESTING_CASE_COMMON(name),\t\t\t\t\t\\\n\t.input = NESTING_DATA(core_reloc_##name),\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = NESTING_DATA(core_reloc_nesting),\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_nesting)\t\t\t\\\n}\n\n#define NESTING_ERR_CASE(name) {\t\t\t\t\t\\\n\tNESTING_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n\t.run_btfgen_fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define ARRAYS_DATA(struct_name) STRUCT_TO_CHAR_PTR(struct_name) {\t\\\n\t.a = { [2] = 1 },\t\t\t\t\t\t\\\n\t.b = { [1] = { [2] = { [3] = 2 } } },\t\t\t\t\\\n\t.c = { [1] = { .c =  3 } },\t\t\t\t\t\\\n\t.d = { [0] = { [0] = { .d = 4 } } },\t\t\t\t\\\n}\n\n#define ARRAYS_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_arrays.bpf.o\",\t\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_arrays\"\t\t\t\t\t\\\n\n#define ARRAYS_CASE(name) {\t\t\t\t\t\t\\\n\tARRAYS_CASE_COMMON(name),\t\t\t\t\t\\\n\t.input = ARRAYS_DATA(core_reloc_##name),\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_arrays_output) {\t\\\n\t\t.a2   = 1,\t\t\t\t\t\t\\\n\t\t.b123 = 2,\t\t\t\t\t\t\\\n\t\t.c1c  = 3,\t\t\t\t\t\t\\\n\t\t.d00d = 4,\t\t\t\t\t\t\\\n\t\t.f10c = 0,\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_arrays_output)\t\t\\\n}\n\n#define ARRAYS_ERR_CASE(name) {\t\t\t\t\t\t\\\n\tARRAYS_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define PRIMITIVES_DATA(struct_name) STRUCT_TO_CHAR_PTR(struct_name) {\t\\\n\t.a = 1,\t\t\t\t\t\t\t\t\\\n\t.b = 2,\t\t\t\t\t\t\t\t\\\n\t.c = 3,\t\t\t\t\t\t\t\t\\\n\t.d = (void *)4,\t\t\t\t\t\t\t\\\n\t.f = (void *)5,\t\t\t\t\t\t\t\\\n}\n\n#define PRIMITIVES_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_primitives.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_primitives\"\t\t\t\t\\\n\n#define PRIMITIVES_CASE(name) {\t\t\t\t\t\t\\\n\tPRIMITIVES_CASE_COMMON(name),\t\t\t\t\t\\\n\t.input = PRIMITIVES_DATA(core_reloc_##name),\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = PRIMITIVES_DATA(core_reloc_primitives),\t\t\\\n\t.output_len = sizeof(struct core_reloc_primitives),\t\t\\\n}\n\n#define PRIMITIVES_ERR_CASE(name) {\t\t\t\t\t\\\n\tPRIMITIVES_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define MODS_CASE(name) {\t\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_mods.bpf.o\",\t\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.input = STRUCT_TO_CHAR_PTR(core_reloc_##name) {\t\t\\\n\t\t.a = 1,\t\t\t\t\t\t\t\\\n\t\t.b = 2,\t\t\t\t\t\t\t\\\n\t\t.c = (void *)3,\t\t\t\t\t\t\\\n\t\t.d = (void *)4,\t\t\t\t\t\t\\\n\t\t.e = { [2] = 5 },\t\t\t\t\t\\\n\t\t.f = { [1] = 6 },\t\t\t\t\t\\\n\t\t.g = { .x = 7 },\t\t\t\t\t\\\n\t\t.h = { .y = 8 },\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_mods_output) {\t\t\\\n\t\t.a = 1, .b = 2, .c = 3, .d = 4,\t\t\t\t\\\n\t\t.e = 5, .f = 6, .g = 7, .h = 8,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_mods_output),\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_mods\",\t\t\t\t\t\\\n}\n\n#define PTR_AS_ARR_CASE(name) {\t\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_ptr_as_arr.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.input = (const char *)&(struct core_reloc_##name []){\t\t\\\n\t\t{ .a = 1 },\t\t\t\t\t\t\\\n\t\t{ .a = 2 },\t\t\t\t\t\t\\\n\t\t{ .a = 3 },\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.input_len = 3 * sizeof(struct core_reloc_##name),\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_ptr_as_arr) {\t\t\\\n\t\t.a = 3,\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_ptr_as_arr),\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_ptr_as_arr\",\t\t\t\t\\\n}\n\n#define INTS_DATA(struct_name) STRUCT_TO_CHAR_PTR(struct_name) {\t\\\n\t.u8_field = 1,\t\t\t\t\t\t\t\\\n\t.s8_field = 2,\t\t\t\t\t\t\t\\\n\t.u16_field = 3,\t\t\t\t\t\t\t\\\n\t.s16_field = 4,\t\t\t\t\t\t\t\\\n\t.u32_field = 5,\t\t\t\t\t\t\t\\\n\t.s32_field = 6,\t\t\t\t\t\t\t\\\n\t.u64_field = 7,\t\t\t\t\t\t\t\\\n\t.s64_field = 8,\t\t\t\t\t\t\t\\\n}\n\n#define INTS_CASE_COMMON(name)\t\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_ints.bpf.o\",\t\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_ints\"\n\n#define INTS_CASE(name) {\t\t\t\t\t\t\\\n\tINTS_CASE_COMMON(name),\t\t\t\t\t\t\\\n\t.input = INTS_DATA(core_reloc_##name),\t\t\t\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = INTS_DATA(core_reloc_ints),\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_ints),\t\t\t\\\n}\n\n#define INTS_ERR_CASE(name) {\t\t\t\t\t\t\\\n\tINTS_CASE_COMMON(name),\t\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define FIELD_EXISTS_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_existence.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_existence\"\n\n#define BITFIELDS_CASE_COMMON(objfile, test_name_prefix,  name)\t\t\\\n\t.case_name = test_name_prefix#name,\t\t\t\t\\\n\t.bpf_obj_file = objfile,\t\t\t\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\"\n\n#define BITFIELDS_CASE(name, ...) {\t\t\t\t\t\\\n\tBITFIELDS_CASE_COMMON(\"test_core_reloc_bitfields_probed.bpf.o\",\t\\\n\t\t\t      \"probed:\", name),\t\t\t\t\\\n\t.input = STRUCT_TO_CHAR_PTR(core_reloc_##name) __VA_ARGS__,\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_bitfields_output)\t\\\n\t\t__VA_ARGS__,\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_bitfields_output),\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_bitfields\",\t\t\t\t\\\n}, {\t\t\t\t\t\t\t\t\t\\\n\tBITFIELDS_CASE_COMMON(\"test_core_reloc_bitfields_direct.bpf.o\",\t\\\n\t\t\t      \"direct:\", name),\t\t\t\t\\\n\t.input = STRUCT_TO_CHAR_PTR(core_reloc_##name) __VA_ARGS__,\t\\\n\t.input_len = sizeof(struct core_reloc_##name),\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_bitfields_output)\t\\\n\t\t__VA_ARGS__,\t\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_bitfields_output),\t\\\n\t.prog_name = \"test_core_bitfields_direct\",\t\t\t\\\n}\n\n\n#define BITFIELDS_ERR_CASE(name) {\t\t\t\t\t\\\n\tBITFIELDS_CASE_COMMON(\"test_core_reloc_bitfields_probed.bpf.o\",\t\\\n\t\t\t      \"probed:\", name),\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n\t.run_btfgen_fails = true,\t\t\t\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_bitfields\",\t\t\t\t\\\n}, {\t\t\t\t\t\t\t\t\t\\\n\tBITFIELDS_CASE_COMMON(\"test_core_reloc_bitfields_direct.bpf.o\",\t\\\n\t\t\t      \"direct:\", name),\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n\t.run_btfgen_fails = true,\t\t\t\t\t\t\t\\\n\t.prog_name = \"test_core_bitfields_direct\",\t\t\t\\\n}\n\n#define SIZE_CASE_COMMON(name)\t\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_size.bpf.o\",\t\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_size\"\n\n#define SIZE_OUTPUT_DATA(type)\t\t\t\t\t\t\\\n\tSTRUCT_TO_CHAR_PTR(core_reloc_size_output) {\t\t\t\\\n\t\t.int_sz = sizeof(((type *)0)->int_field),\t\t\\\n\t\t.int_off = offsetof(type, int_field),\t\t\t\\\n\t\t.struct_sz = sizeof(((type *)0)->struct_field),\t\t\\\n\t\t.struct_off = offsetof(type, struct_field),\t\t\\\n\t\t.union_sz = sizeof(((type *)0)->union_field),\t\t\\\n\t\t.union_off = offsetof(type, union_field),\t\t\\\n\t\t.arr_sz = sizeof(((type *)0)->arr_field),\t\t\\\n\t\t.arr_off = offsetof(type, arr_field),\t\t\t\\\n\t\t.arr_elem_sz = sizeof(((type *)0)->arr_field[1]),\t\\\n\t\t.arr_elem_off = offsetof(type, arr_field[1]),\t\t\\\n\t\t.ptr_sz = 8,  \t\\\n\t\t.ptr_off = offsetof(type, ptr_field),\t\t\t\\\n\t\t.enum_sz = sizeof(((type *)0)->enum_field),\t\t\\\n\t\t.enum_off = offsetof(type, enum_field),\t\t\t\\\n\t\t.float_sz = sizeof(((type *)0)->float_field),\t\t\\\n\t\t.float_off = offsetof(type, float_field),\t\t\\\n\t}\n\n#define SIZE_CASE(name) {\t\t\t\t\t\t\\\n\tSIZE_CASE_COMMON(name),\t\t\t\t\t\t\\\n\t.input_len = 0,\t\t\t\t\t\t\t\\\n\t.output = SIZE_OUTPUT_DATA(struct core_reloc_##name),\t\t\\\n\t.output_len = sizeof(struct core_reloc_size_output),\t\t\\\n}\n\n#define SIZE_ERR_CASE(name) {\t\t\t\t\t\t\\\n\tSIZE_CASE_COMMON(name),\t\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n\t.run_btfgen_fails = true,\t\t\t\t\t\\\n}\n\n#define TYPE_BASED_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_type_based.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_type_based\"\n\n#define TYPE_BASED_CASE(name, ...) {\t\t\t\t\t\\\n\tTYPE_BASED_CASE_COMMON(name),\t\t\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_type_based_output)\t\\\n\t\t\t__VA_ARGS__,\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_type_based_output),\t\\\n}\n\n#define TYPE_BASED_ERR_CASE(name) {\t\t\t\t\t\\\n\tTYPE_BASED_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define TYPE_ID_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_type_id.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_type_id\"\n\n#define TYPE_ID_CASE(name, setup_fn) {\t\t\t\t\t\\\n\tTYPE_ID_CASE_COMMON(name),\t\t\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_type_id_output) {},\t\\\n\t.output_len = sizeof(struct core_reloc_type_id_output),\t\t\\\n\t.setup = setup_fn,\t\t\t\t\t\t\\\n}\n\n#define TYPE_ID_ERR_CASE(name) {\t\t\t\t\t\\\n\tTYPE_ID_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define ENUMVAL_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_enumval.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_enumval\"\n\n#define ENUMVAL_CASE(name, ...) {\t\t\t\t\t\\\n\tENUMVAL_CASE_COMMON(name),\t\t\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_enumval_output)\t\t\\\n\t\t\t__VA_ARGS__,\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_enumval_output),\t\t\\\n}\n\n#define ENUMVAL_ERR_CASE(name) {\t\t\t\t\t\\\n\tENUMVAL_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\n#define ENUM64VAL_CASE_COMMON(name)\t\t\t\t\t\\\n\t.case_name = #name,\t\t\t\t\t\t\\\n\t.bpf_obj_file = \"test_core_reloc_enum64val.bpf.o\",\t\t\\\n\t.btf_src_file = \"btf__core_reloc_\" #name \".bpf.o\",\t\t\\\n\t.raw_tp_name = \"sys_enter\",\t\t\t\t\t\\\n\t.prog_name = \"test_core_enum64val\"\n\n#define ENUM64VAL_CASE(name, ...) {\t\t\t\t\t\\\n\tENUM64VAL_CASE_COMMON(name),\t\t\t\t\t\\\n\t.output = STRUCT_TO_CHAR_PTR(core_reloc_enum64val_output)\t\\\n\t\t\t__VA_ARGS__,\t\t\t\t\t\\\n\t.output_len = sizeof(struct core_reloc_enum64val_output),\t\\\n}\n\n#define ENUM64VAL_ERR_CASE(name) {\t\t\t\t\t\\\n\tENUM64VAL_CASE_COMMON(name),\t\t\t\t\t\\\n\t.fails = true,\t\t\t\t\t\t\t\\\n}\n\nstruct core_reloc_test_case;\n\ntypedef int (*setup_test_fn)(struct core_reloc_test_case *test);\ntypedef int (*trigger_test_fn)(const struct core_reloc_test_case *test);\n\nstruct core_reloc_test_case {\n\tconst char *case_name;\n\tconst char *bpf_obj_file;\n\tconst char *btf_src_file;\n\tconst char *input;\n\tint input_len;\n\tconst char *output;\n\tint output_len;\n\tbool fails;\n\tbool run_btfgen_fails;\n\tbool needs_testmod;\n\tbool relaxed_core_relocs;\n\tconst char *prog_name;\n\tconst char *raw_tp_name;\n\tsetup_test_fn setup;\n\ttrigger_test_fn trigger;\n};\n\nstatic int find_btf_type(const struct btf *btf, const char *name, __u32 kind)\n{\n\tint id;\n\n\tid = btf__find_by_name_kind(btf, name, kind);\n\tif (CHECK(id <= 0, \"find_type_id\", \"failed to find '%s', kind %d: %d\\n\", name, kind, id))\n\t\treturn -1;\n\n\treturn id;\n}\n\nstatic int setup_type_id_case_local(struct core_reloc_test_case *test)\n{\n\tstruct core_reloc_type_id_output *exp = (void *)test->output;\n\tstruct btf *local_btf = btf__parse(test->bpf_obj_file, NULL);\n\tstruct btf *targ_btf = btf__parse(test->btf_src_file, NULL);\n\tconst struct btf_type *t;\n\tconst char *name;\n\tint i;\n\n\tif (!ASSERT_OK_PTR(local_btf, \"local_btf\") || !ASSERT_OK_PTR(targ_btf, \"targ_btf\")) {\n\t\tbtf__free(local_btf);\n\t\tbtf__free(targ_btf);\n\t\treturn -EINVAL;\n\t}\n\n\texp->local_anon_struct = -1;\n\texp->local_anon_union = -1;\n\texp->local_anon_enum = -1;\n\texp->local_anon_func_proto_ptr = -1;\n\texp->local_anon_void_ptr = -1;\n\texp->local_anon_arr = -1;\n\n\tfor (i = 1; i < btf__type_cnt(local_btf); i++)\n\t{\n\t\tt = btf__type_by_id(local_btf, i);\n\t\t \n\t\tif (t->name_off)\n\t\t\tcontinue;\n\n\t\tif (btf_is_struct(t) && btf_vlen(t) &&\n\t\t    (name = btf__name_by_offset(local_btf, btf_members(t)[0].name_off)) &&\n\t\t    strcmp(name, \"marker_field\") == 0) {\n\t\t\texp->local_anon_struct = i;\n\t\t} else if (btf_is_union(t) && btf_vlen(t) &&\n\t\t\t (name = btf__name_by_offset(local_btf, btf_members(t)[0].name_off)) &&\n\t\t\t strcmp(name, \"marker_field\") == 0) {\n\t\t\texp->local_anon_union = i;\n\t\t} else if (btf_is_enum(t) && btf_vlen(t) &&\n\t\t\t (name = btf__name_by_offset(local_btf, btf_enum(t)[0].name_off)) &&\n\t\t\t strcmp(name, \"MARKER_ENUM_VAL\") == 0) {\n\t\t\texp->local_anon_enum = i;\n\t\t} else if (btf_is_ptr(t) && (t = btf__type_by_id(local_btf, t->type))) {\n\t\t\tif (btf_is_func_proto(t) && (t = btf__type_by_id(local_btf, t->type)) &&\n\t\t\t    btf_is_int(t) && (name = btf__name_by_offset(local_btf, t->name_off)) &&\n\t\t\t    strcmp(name, \"_Bool\") == 0) {\n\t\t\t\t \n\t\t\t\texp->local_anon_func_proto_ptr = i;\n\t\t\t} else if (btf_is_void(t)) {\n\t\t\t\t \n\t\t\t\texp->local_anon_void_ptr = i;\n\t\t\t}\n\t\t} else if (btf_is_array(t) && (t = btf__type_by_id(local_btf, btf_array(t)->type)) &&\n\t\t\t   btf_is_int(t) && (name = btf__name_by_offset(local_btf, t->name_off)) &&\n\t\t\t   strcmp(name, \"_Bool\") == 0) {\n\t\t\t \n\t\t\texp->local_anon_arr = i;\n\t\t}\n\t}\n\n\texp->local_struct = find_btf_type(local_btf, \"a_struct\", BTF_KIND_STRUCT);\n\texp->local_union = find_btf_type(local_btf, \"a_union\", BTF_KIND_UNION);\n\texp->local_enum = find_btf_type(local_btf, \"an_enum\", BTF_KIND_ENUM);\n\texp->local_int = find_btf_type(local_btf, \"int\", BTF_KIND_INT);\n\texp->local_struct_typedef = find_btf_type(local_btf, \"named_struct_typedef\", BTF_KIND_TYPEDEF);\n\texp->local_func_proto_typedef = find_btf_type(local_btf, \"func_proto_typedef\", BTF_KIND_TYPEDEF);\n\texp->local_arr_typedef = find_btf_type(local_btf, \"arr_typedef\", BTF_KIND_TYPEDEF);\n\n\tbtf__free(local_btf);\n\tbtf__free(targ_btf);\n\treturn 0;\n}\n\nstatic int setup_type_id_case_success(struct core_reloc_test_case *test) {\n\tstruct core_reloc_type_id_output *exp = (void *)test->output;\n\tstruct btf *targ_btf;\n\tint err;\n\n\terr = setup_type_id_case_local(test);\n\tif (err)\n\t\treturn err;\n\n\ttarg_btf = btf__parse(test->btf_src_file, NULL);\n\n\texp->targ_struct = find_btf_type(targ_btf, \"a_struct\", BTF_KIND_STRUCT);\n\texp->targ_union = find_btf_type(targ_btf, \"a_union\", BTF_KIND_UNION);\n\texp->targ_enum = find_btf_type(targ_btf, \"an_enum\", BTF_KIND_ENUM);\n\texp->targ_int = find_btf_type(targ_btf, \"int\", BTF_KIND_INT);\n\texp->targ_struct_typedef = find_btf_type(targ_btf, \"named_struct_typedef\", BTF_KIND_TYPEDEF);\n\texp->targ_func_proto_typedef = find_btf_type(targ_btf, \"func_proto_typedef\", BTF_KIND_TYPEDEF);\n\texp->targ_arr_typedef = find_btf_type(targ_btf, \"arr_typedef\", BTF_KIND_TYPEDEF);\n\n\tbtf__free(targ_btf);\n\treturn 0;\n}\n\nstatic int setup_type_id_case_failure(struct core_reloc_test_case *test)\n{\n\tstruct core_reloc_type_id_output *exp = (void *)test->output;\n\tint err;\n\n\terr = setup_type_id_case_local(test);\n\tif (err)\n\t\treturn err;\n\n\texp->targ_struct = 0;\n\texp->targ_union = 0;\n\texp->targ_enum = 0;\n\texp->targ_int = 0;\n\texp->targ_struct_typedef = 0;\n\texp->targ_func_proto_typedef = 0;\n\texp->targ_arr_typedef = 0;\n\n\treturn 0;\n}\n\nstatic int __trigger_module_test_read(const struct core_reloc_test_case *test)\n{\n\tstruct core_reloc_module_output *exp = (void *)test->output;\n\n\ttrigger_module_test_read(exp->len);\n\treturn 0;\n}\n\nstatic const struct core_reloc_test_case test_cases[] = {\n\t \n\t{\n\t\t.case_name = \"kernel\",\n\t\t.bpf_obj_file = \"test_core_reloc_kernel.bpf.o\",\n\t\t.btf_src_file = NULL,  \n\t\t.input = \"\",\n\t\t.input_len = 0,\n\t\t.output = STRUCT_TO_CHAR_PTR(core_reloc_kernel_output) {\n\t\t\t.valid = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },\n\t\t\t.comm = \"test_progs\",\n\t\t\t.comm_len = sizeof(\"test_progs\"),\n\t\t\t.local_task_struct_matches = true,\n\t\t},\n\t\t.output_len = sizeof(struct core_reloc_kernel_output),\n\t\t.raw_tp_name = \"sys_enter\",\n\t\t.prog_name = \"test_core_kernel\",\n\t},\n\n\t \n\tMODULES_CASE(\"module_probed\", \"test_core_module_probed\", \"bpf_testmod_test_read\"),\n\tMODULES_CASE(\"module_direct\", \"test_core_module_direct\", NULL),\n\n\t \n\tFLAVORS_CASE(flavors),\n\n\tFLAVORS_ERR_CASE(flavors__err_wrong_name),\n\n\t \n\tNESTING_CASE(nesting),\n\tNESTING_CASE(nesting___anon_embed),\n\tNESTING_CASE(nesting___struct_union_mixup),\n\tNESTING_CASE(nesting___extra_nesting),\n\tNESTING_CASE(nesting___dup_compat_types),\n\n\tNESTING_ERR_CASE(nesting___err_missing_field),\n\tNESTING_ERR_CASE(nesting___err_array_field),\n\tNESTING_ERR_CASE(nesting___err_missing_container),\n\tNESTING_ERR_CASE(nesting___err_nonstruct_container),\n\tNESTING_ERR_CASE(nesting___err_array_container),\n\tNESTING_ERR_CASE(nesting___err_dup_incompat_types),\n\tNESTING_ERR_CASE(nesting___err_partial_match_dups),\n\tNESTING_ERR_CASE(nesting___err_too_deep),\n\n\t \n\tARRAYS_CASE(arrays),\n\tARRAYS_CASE(arrays___diff_arr_dim),\n\tARRAYS_CASE(arrays___diff_arr_val_sz),\n\tARRAYS_CASE(arrays___equiv_zero_sz_arr),\n\tARRAYS_CASE(arrays___fixed_arr),\n\n\tARRAYS_ERR_CASE(arrays___err_too_small),\n\tARRAYS_ERR_CASE(arrays___err_too_shallow),\n\tARRAYS_ERR_CASE(arrays___err_non_array),\n\tARRAYS_ERR_CASE(arrays___err_wrong_val_type),\n\tARRAYS_ERR_CASE(arrays___err_bad_zero_sz_arr),\n\n\t \n\tPRIMITIVES_CASE(primitives),\n\tPRIMITIVES_CASE(primitives___diff_enum_def),\n\tPRIMITIVES_CASE(primitives___diff_func_proto),\n\tPRIMITIVES_CASE(primitives___diff_ptr_type),\n\n\tPRIMITIVES_ERR_CASE(primitives___err_non_enum),\n\tPRIMITIVES_ERR_CASE(primitives___err_non_int),\n\tPRIMITIVES_ERR_CASE(primitives___err_non_ptr),\n\n\t \n\tMODS_CASE(mods),\n\tMODS_CASE(mods___mod_swap),\n\tMODS_CASE(mods___typedefs),\n\n\t \n\tPTR_AS_ARR_CASE(ptr_as_arr),\n\tPTR_AS_ARR_CASE(ptr_as_arr___diff_sz),\n\n\t \n\tINTS_CASE(ints),\n\tINTS_CASE(ints___bool),\n\tINTS_CASE(ints___reverse_sign),\n\n\t \n\t{\n\t\t.case_name = \"misc\",\n\t\t.bpf_obj_file = \"test_core_reloc_misc.bpf.o\",\n\t\t.btf_src_file = \"btf__core_reloc_misc.bpf.o\",\n\t\t.input = (const char *)&(struct core_reloc_misc_extensible[]){\n\t\t\t{ .a = 1 },\n\t\t\t{ .a = 2 },  \n\t\t\t{ .a = 3 },\n\t\t},\n\t\t.input_len = 4 * sizeof(int),\n\t\t.output = STRUCT_TO_CHAR_PTR(core_reloc_misc_output) {\n\t\t\t.a = 1,\n\t\t\t.b = 1,\n\t\t\t.c = 0,  \n\t\t},\n\t\t.output_len = sizeof(struct core_reloc_misc_output),\n\t\t.raw_tp_name = \"sys_enter\",\n\t\t.prog_name = \"test_core_misc\",\n\t},\n\n\t \n\t{\n\t\tFIELD_EXISTS_CASE_COMMON(existence),\n\t\t.input = STRUCT_TO_CHAR_PTR(core_reloc_existence) {\n\t\t\t.a = 1,\n\t\t\t.b = 2,\n\t\t\t.c = 3,\n\t\t\t.arr = { 4 },\n\t\t\t.s = { .x = 5 },\n\t\t},\n\t\t.input_len = sizeof(struct core_reloc_existence),\n\t\t.output = STRUCT_TO_CHAR_PTR(core_reloc_existence_output) {\n\t\t\t.a_exists = 1,\n\t\t\t.b_exists = 1,\n\t\t\t.c_exists = 1,\n\t\t\t.arr_exists = 1,\n\t\t\t.s_exists = 1,\n\t\t\t.a_value = 1,\n\t\t\t.b_value = 2,\n\t\t\t.c_value = 3,\n\t\t\t.arr_value = 4,\n\t\t\t.s_value = 5,\n\t\t},\n\t\t.output_len = sizeof(struct core_reloc_existence_output),\n\t},\n\t{\n\t\tFIELD_EXISTS_CASE_COMMON(existence___minimal),\n\t\t.input = STRUCT_TO_CHAR_PTR(core_reloc_existence___minimal) {\n\t\t\t.a = 42,\n\t\t},\n\t\t.input_len = sizeof(struct core_reloc_existence___minimal),\n\t\t.output = STRUCT_TO_CHAR_PTR(core_reloc_existence_output) {\n\t\t\t.a_exists = 1,\n\t\t\t.b_exists = 0,\n\t\t\t.c_exists = 0,\n\t\t\t.arr_exists = 0,\n\t\t\t.s_exists = 0,\n\t\t\t.a_value = 42,\n\t\t\t.b_value = 0xff000002u,\n\t\t\t.c_value = 0xff000003u,\n\t\t\t.arr_value = 0xff000004u,\n\t\t\t.s_value = 0xff000005u,\n\t\t},\n\t\t.output_len = sizeof(struct core_reloc_existence_output),\n\t},\n\t{\n\t\tFIELD_EXISTS_CASE_COMMON(existence___wrong_field_defs),\n\t\t.input = STRUCT_TO_CHAR_PTR(core_reloc_existence___wrong_field_defs) {\n\t\t},\n\t\t.input_len = sizeof(struct core_reloc_existence___wrong_field_defs),\n\t\t.output = STRUCT_TO_CHAR_PTR(core_reloc_existence_output) {\n\t\t\t.a_exists = 0,\n\t\t\t.b_exists = 0,\n\t\t\t.c_exists = 0,\n\t\t\t.arr_exists = 0,\n\t\t\t.s_exists = 0,\n\t\t\t.a_value = 0xff000001u,\n\t\t\t.b_value = 0xff000002u,\n\t\t\t.c_value = 0xff000003u,\n\t\t\t.arr_value = 0xff000004u,\n\t\t\t.s_value = 0xff000005u,\n\t\t},\n\t\t.output_len = sizeof(struct core_reloc_existence_output),\n\t},\n\n\t \n\tBITFIELDS_CASE(bitfields, {\n\t\t.ub1 = 1,\n\t\t.ub2 = 2,\n\t\t.ub7 = 96,\n\t\t.sb4 = -7,\n\t\t.sb20 = -0x76543,\n\t\t.u32 = 0x80000000,\n\t\t.s32 = -0x76543210,\n\t}),\n\tBITFIELDS_CASE(bitfields___bit_sz_change, {\n\t\t.ub1 = 6,\n\t\t.ub2 = 0xABCDE,\n\t\t.ub7 = 1,\n\t\t.sb4 = -1,\n\t\t.sb20 = -0x17654321,\n\t\t.u32 = 0xBEEF,\n\t\t.s32 = -0x3FEDCBA987654321LL,\n\t}),\n\tBITFIELDS_CASE(bitfields___bitfield_vs_int, {\n\t\t.ub1 = 0xFEDCBA9876543210LL,\n\t\t.ub2 = 0xA6,\n\t\t.ub7 = -0x7EDCBA987654321LL,\n\t\t.sb4 = -0x6123456789ABCDELL,\n\t\t.sb20 = 0xD00DLL,\n\t\t.u32 = -0x76543,\n\t\t.s32 = 0x0ADEADBEEFBADB0BLL,\n\t}),\n\tBITFIELDS_CASE(bitfields___just_big_enough, {\n\t\t.ub1 = 0xFLL,\n\t\t.ub2 = 0x0812345678FEDCBALL,\n\t}),\n\tBITFIELDS_ERR_CASE(bitfields___err_too_big_bitfield),\n\n\t \n\tSIZE_CASE(size),\n\tSIZE_CASE(size___diff_sz),\n\tSIZE_CASE(size___diff_offs),\n\tSIZE_ERR_CASE(size___err_ambiguous),\n\n\t \n\tTYPE_BASED_CASE(type_based, {\n\t\t.struct_exists = 1,\n\t\t.complex_struct_exists = 1,\n\t\t.union_exists = 1,\n\t\t.enum_exists = 1,\n\t\t.typedef_named_struct_exists = 1,\n\t\t.typedef_anon_struct_exists = 1,\n\t\t.typedef_struct_ptr_exists = 1,\n\t\t.typedef_int_exists = 1,\n\t\t.typedef_enum_exists = 1,\n\t\t.typedef_void_ptr_exists = 1,\n\t\t.typedef_restrict_ptr_exists = 1,\n\t\t.typedef_func_proto_exists = 1,\n\t\t.typedef_arr_exists = 1,\n\n\t\t.struct_matches = 1,\n\t\t.complex_struct_matches = 1,\n\t\t.union_matches = 1,\n\t\t.enum_matches = 1,\n\t\t.typedef_named_struct_matches = 1,\n\t\t.typedef_anon_struct_matches = 1,\n\t\t.typedef_struct_ptr_matches = 1,\n\t\t.typedef_int_matches = 1,\n\t\t.typedef_enum_matches = 1,\n\t\t.typedef_void_ptr_matches = 1,\n\t\t.typedef_restrict_ptr_matches = 1,\n\t\t.typedef_func_proto_matches = 1,\n\t\t.typedef_arr_matches = 1,\n\n\t\t.struct_sz = sizeof(struct a_struct),\n\t\t.union_sz = sizeof(union a_union),\n\t\t.enum_sz = sizeof(enum an_enum),\n\t\t.typedef_named_struct_sz = sizeof(named_struct_typedef),\n\t\t.typedef_anon_struct_sz = sizeof(anon_struct_typedef),\n\t\t.typedef_struct_ptr_sz = sizeof(struct_ptr_typedef),\n\t\t.typedef_int_sz = sizeof(int_typedef),\n\t\t.typedef_enum_sz = sizeof(enum_typedef),\n\t\t.typedef_void_ptr_sz = sizeof(void_ptr_typedef),\n\t\t.typedef_func_proto_sz = sizeof(func_proto_typedef),\n\t\t.typedef_arr_sz = sizeof(arr_typedef),\n\t}),\n\tTYPE_BASED_CASE(type_based___all_missing, {\n\t\t \n\t}),\n\tTYPE_BASED_CASE(type_based___diff, {\n\t\t.struct_exists = 1,\n\t\t.complex_struct_exists = 1,\n\t\t.union_exists = 1,\n\t\t.enum_exists = 1,\n\t\t.typedef_named_struct_exists = 1,\n\t\t.typedef_anon_struct_exists = 1,\n\t\t.typedef_struct_ptr_exists = 1,\n\t\t.typedef_int_exists = 1,\n\t\t.typedef_enum_exists = 1,\n\t\t.typedef_void_ptr_exists = 1,\n\t\t.typedef_func_proto_exists = 1,\n\t\t.typedef_arr_exists = 1,\n\n\t\t.struct_matches = 1,\n\t\t.complex_struct_matches = 1,\n\t\t.union_matches = 1,\n\t\t.enum_matches = 1,\n\t\t.typedef_named_struct_matches = 1,\n\t\t.typedef_anon_struct_matches = 1,\n\t\t.typedef_struct_ptr_matches = 1,\n\t\t.typedef_int_matches = 0,\n\t\t.typedef_enum_matches = 1,\n\t\t.typedef_void_ptr_matches = 1,\n\t\t.typedef_func_proto_matches = 0,\n\t\t.typedef_arr_matches = 0,\n\n\t\t.struct_sz = sizeof(struct a_struct___diff),\n\t\t.union_sz = sizeof(union a_union___diff),\n\t\t.enum_sz = sizeof(enum an_enum___diff),\n\t\t.typedef_named_struct_sz = sizeof(named_struct_typedef___diff),\n\t\t.typedef_anon_struct_sz = sizeof(anon_struct_typedef___diff),\n\t\t.typedef_struct_ptr_sz = sizeof(struct_ptr_typedef___diff),\n\t\t.typedef_int_sz = sizeof(int_typedef___diff),\n\t\t.typedef_enum_sz = sizeof(enum_typedef___diff),\n\t\t.typedef_void_ptr_sz = sizeof(void_ptr_typedef___diff),\n\t\t.typedef_func_proto_sz = sizeof(func_proto_typedef___diff),\n\t\t.typedef_arr_sz = sizeof(arr_typedef___diff),\n\t}),\n\tTYPE_BASED_CASE(type_based___diff_sz, {\n\t\t.struct_exists = 1,\n\t\t.union_exists = 1,\n\t\t.enum_exists = 1,\n\t\t.typedef_named_struct_exists = 1,\n\t\t.typedef_anon_struct_exists = 1,\n\t\t.typedef_struct_ptr_exists = 1,\n\t\t.typedef_int_exists = 1,\n\t\t.typedef_enum_exists = 1,\n\t\t.typedef_void_ptr_exists = 1,\n\t\t.typedef_func_proto_exists = 1,\n\t\t.typedef_arr_exists = 1,\n\n\t\t.struct_matches = 0,\n\t\t.union_matches = 0,\n\t\t.enum_matches = 0,\n\t\t.typedef_named_struct_matches = 0,\n\t\t.typedef_anon_struct_matches = 0,\n\t\t.typedef_struct_ptr_matches = 1,\n\t\t.typedef_int_matches = 0,\n\t\t.typedef_enum_matches = 0,\n\t\t.typedef_void_ptr_matches = 1,\n\t\t.typedef_func_proto_matches = 0,\n\t\t.typedef_arr_matches = 0,\n\n\t\t.struct_sz = sizeof(struct a_struct___diff_sz),\n\t\t.union_sz = sizeof(union a_union___diff_sz),\n\t\t.enum_sz = sizeof(enum an_enum___diff_sz),\n\t\t.typedef_named_struct_sz = sizeof(named_struct_typedef___diff_sz),\n\t\t.typedef_anon_struct_sz = sizeof(anon_struct_typedef___diff_sz),\n\t\t.typedef_struct_ptr_sz = sizeof(struct_ptr_typedef___diff_sz),\n\t\t.typedef_int_sz = sizeof(int_typedef___diff_sz),\n\t\t.typedef_enum_sz = sizeof(enum_typedef___diff_sz),\n\t\t.typedef_void_ptr_sz = sizeof(void_ptr_typedef___diff_sz),\n\t\t.typedef_func_proto_sz = sizeof(func_proto_typedef___diff_sz),\n\t\t.typedef_arr_sz = sizeof(arr_typedef___diff_sz),\n\t}),\n\tTYPE_BASED_CASE(type_based___incompat, {\n\t\t.enum_exists = 1,\n\t\t.enum_matches = 1,\n\t\t.enum_sz = sizeof(enum an_enum),\n\t}),\n\tTYPE_BASED_CASE(type_based___fn_wrong_args, {\n\t\t.struct_exists = 1,\n\t\t.struct_matches = 1,\n\t\t.struct_sz = sizeof(struct a_struct),\n\t}),\n\n\t \n\tTYPE_ID_CASE(type_id, setup_type_id_case_success),\n\tTYPE_ID_CASE(type_id___missing_targets, setup_type_id_case_failure),\n\n\t \n\tENUMVAL_CASE(enumval, {\n\t\t.named_val1_exists = true,\n\t\t.named_val2_exists = true,\n\t\t.named_val3_exists = true,\n\t\t.anon_val1_exists = true,\n\t\t.anon_val2_exists = true,\n\t\t.anon_val3_exists = true,\n\t\t.named_val1 = 1,\n\t\t.named_val2 = 2,\n\t\t.anon_val1 = 0x10,\n\t\t.anon_val2 = 0x20,\n\t}),\n\tENUMVAL_CASE(enumval___diff, {\n\t\t.named_val1_exists = true,\n\t\t.named_val2_exists = true,\n\t\t.named_val3_exists = true,\n\t\t.anon_val1_exists = true,\n\t\t.anon_val2_exists = true,\n\t\t.anon_val3_exists = true,\n\t\t.named_val1 = 101,\n\t\t.named_val2 = 202,\n\t\t.anon_val1 = 0x11,\n\t\t.anon_val2 = 0x22,\n\t}),\n\tENUMVAL_CASE(enumval___val3_missing, {\n\t\t.named_val1_exists = true,\n\t\t.named_val2_exists = true,\n\t\t.named_val3_exists = false,\n\t\t.anon_val1_exists = true,\n\t\t.anon_val2_exists = true,\n\t\t.anon_val3_exists = false,\n\t\t.named_val1 = 111,\n\t\t.named_val2 = 222,\n\t\t.anon_val1 = 0x111,\n\t\t.anon_val2 = 0x222,\n\t}),\n\tENUMVAL_ERR_CASE(enumval___err_missing),\n\n\t \n\tENUM64VAL_CASE(enum64val, {\n\t\t.unsigned_val1_exists = true,\n\t\t.unsigned_val2_exists = true,\n\t\t.unsigned_val3_exists = true,\n\t\t.signed_val1_exists = true,\n\t\t.signed_val2_exists = true,\n\t\t.signed_val3_exists = true,\n\t\t.unsigned_val1 = 0x1ffffffffULL,\n\t\t.unsigned_val2 = 0x2,\n\t\t.signed_val1 = 0x1ffffffffLL,\n\t\t.signed_val2 = -2,\n\t}),\n\tENUM64VAL_CASE(enum64val___diff, {\n\t\t.unsigned_val1_exists = true,\n\t\t.unsigned_val2_exists = true,\n\t\t.unsigned_val3_exists = true,\n\t\t.signed_val1_exists = true,\n\t\t.signed_val2_exists = true,\n\t\t.signed_val3_exists = true,\n\t\t.unsigned_val1 = 0x101ffffffffULL,\n\t\t.unsigned_val2 = 0x202ffffffffULL,\n\t\t.signed_val1 = -101,\n\t\t.signed_val2 = -202,\n\t}),\n\tENUM64VAL_CASE(enum64val___val3_missing, {\n\t\t.unsigned_val1_exists = true,\n\t\t.unsigned_val2_exists = true,\n\t\t.unsigned_val3_exists = false,\n\t\t.signed_val1_exists = true,\n\t\t.signed_val2_exists = true,\n\t\t.signed_val3_exists = false,\n\t\t.unsigned_val1 = 0x111ffffffffULL,\n\t\t.unsigned_val2 = 0x222,\n\t\t.signed_val1 = 0x111ffffffffLL,\n\t\t.signed_val2 = -222,\n\t}),\n\tENUM64VAL_ERR_CASE(enum64val___err_missing),\n};\n\nstruct data {\n\tchar in[256];\n\tchar out[256];\n\tbool skip;\n\tuint64_t my_pid_tgid;\n};\n\nstatic size_t roundup_page(size_t sz)\n{\n\tlong page_size = sysconf(_SC_PAGE_SIZE);\n\treturn (sz + page_size - 1) / page_size * page_size;\n}\n\nstatic int run_btfgen(const char *src_btf, const char *dst_btf, const char *objpath)\n{\n\tchar command[4096];\n\tint n;\n\n\tn = snprintf(command, sizeof(command),\n\t\t     \"./bpftool gen min_core_btf %s %s %s\",\n\t\t     src_btf, dst_btf, objpath);\n\tif (n < 0 || n >= sizeof(command))\n\t\treturn -1;\n\n\treturn system(command);\n}\n\nstatic void run_core_reloc_tests(bool use_btfgen)\n{\n\tconst size_t mmap_sz = roundup_page(sizeof(struct data));\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, open_opts);\n\tstruct core_reloc_test_case *test_case, test_case_copy;\n\tconst char *tp_name, *probe_name;\n\tint err, i, equal, fd;\n\tstruct bpf_link *link = NULL;\n\tstruct bpf_map *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tuint64_t my_pid_tgid;\n\tstruct data *data;\n\tvoid *mmap_data = NULL;\n\n\tmy_pid_tgid = getpid() | ((uint64_t)syscall(SYS_gettid) << 32);\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++) {\n\t\tchar btf_file[] = \"/tmp/core_reloc.btf.XXXXXX\";\n\n\t\ttest_case_copy = test_cases[i];\n\t\ttest_case = &test_case_copy;\n\n\t\tif (!test__start_subtest(test_case->case_name))\n\t\t\tcontinue;\n\n\t\tif (test_case->needs_testmod && !env.has_testmod) {\n\t\t\ttest__skip();\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (use_btfgen) {\n\n\t\t\tif (!test_case->btf_src_file || test_case->run_btfgen_fails) {\n\t\t\t\ttest__skip();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfd = mkstemp(btf_file);\n\t\t\tif (!ASSERT_GE(fd, 0, \"btf_tmp\"))\n\t\t\t\tcontinue;\n\t\t\tclose(fd);  \n\t\t\terr = run_btfgen(test_case->btf_src_file, btf_file,\n\t\t\t\t\t test_case->bpf_obj_file);\n\t\t\tif (!ASSERT_OK(err, \"run_btfgen\"))\n\t\t\t\tcontinue;\n\n\t\t\ttest_case->btf_src_file = btf_file;\n\t\t}\n\n\t\tif (test_case->setup) {\n\t\t\terr = test_case->setup(test_case);\n\t\t\tif (CHECK(err, \"test_setup\", \"test #%d setup failed: %d\\n\", i, err))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_case->btf_src_file) {\n\t\t\terr = access(test_case->btf_src_file, R_OK);\n\t\t\tif (!ASSERT_OK(err, \"btf_src_file\"))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\topen_opts.btf_custom_path = test_case->btf_src_file;\n\t\tobj = bpf_object__open_file(test_case->bpf_obj_file, &open_opts);\n\t\tif (!ASSERT_OK_PTR(obj, \"obj_open\"))\n\t\t\tgoto cleanup;\n\n\t\tprobe_name = test_case->prog_name;\n\t\ttp_name = test_case->raw_tp_name;  \n\t\tprog = bpf_object__find_program_by_name(obj, probe_name);\n\t\tif (CHECK(!prog, \"find_probe\",\n\t\t\t  \"prog '%s' not found\\n\", probe_name))\n\t\t\tgoto cleanup;\n\n\t\terr = bpf_object__load(obj);\n\t\tif (err) {\n\t\t\tif (!test_case->fails)\n\t\t\t\tASSERT_OK(err, \"obj_load\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tdata_map = bpf_object__find_map_by_name(obj, \".bss\");\n\t\tif (CHECK(!data_map, \"find_data_map\", \"data map not found\\n\"))\n\t\t\tgoto cleanup;\n\n\t\tmmap_data = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE,\n\t\t\t\t MAP_SHARED, bpf_map__fd(data_map), 0);\n\t\tif (CHECK(mmap_data == MAP_FAILED, \"mmap\",\n\t\t\t  \".bss mmap failed: %d\", errno)) {\n\t\t\tmmap_data = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tdata = mmap_data;\n\n\t\tmemset(mmap_data, 0, sizeof(*data));\n\t\tif (test_case->input_len)\n\t\t\tmemcpy(data->in, test_case->input, test_case->input_len);\n\t\tdata->my_pid_tgid = my_pid_tgid;\n\n\t\tlink = bpf_program__attach_raw_tracepoint(prog, tp_name);\n\t\tif (!ASSERT_OK_PTR(link, \"attach_raw_tp\"))\n\t\t\tgoto cleanup;\n\n\t\t \n\t\tif (test_case->trigger) {\n\t\t\tif (!ASSERT_OK(test_case->trigger(test_case), \"test_trigger\"))\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tusleep(1);\n\t\t}\n\n\t\tif (data->skip) {\n\t\t\ttest__skip();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!ASSERT_FALSE(test_case->fails, \"obj_load_should_fail\"))\n\t\t\tgoto cleanup;\n\n\t\tequal = memcmp(data->out, test_case->output,\n\t\t\t       test_case->output_len) == 0;\n\t\tif (CHECK(!equal, \"check_result\",\n\t\t\t  \"input/output data don't match\\n\")) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < test_case->input_len; j++) {\n\t\t\t\tprintf(\"input byte #%d: 0x%02hhx\\n\",\n\t\t\t\t       j, test_case->input[j]);\n\t\t\t}\n\t\t\tfor (j = 0; j < test_case->output_len; j++) {\n\t\t\t\tprintf(\"output byte #%d: EXP 0x%02hhx GOT 0x%02hhx\\n\",\n\t\t\t\t       j, test_case->output[j], data->out[j]);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\ncleanup:\n\t\tif (mmap_data) {\n\t\t\tCHECK_FAIL(munmap(mmap_data, mmap_sz));\n\t\t\tmmap_data = NULL;\n\t\t}\n\t\tif (use_btfgen)\n\t\t\tremove(test_case->btf_src_file);\n\t\tbpf_link__destroy(link);\n\t\tlink = NULL;\n\t\tbpf_object__close(obj);\n\t}\n}\n\nvoid test_core_reloc(void)\n{\n\trun_core_reloc_tests(false);\n}\n\nvoid test_core_reloc_btfgen(void)\n{\n\trun_core_reloc_tests(true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}