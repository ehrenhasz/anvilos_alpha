{
  "module_name": "bloom_filter_map.c",
  "hash_id": "4a490e49834e25824056e1c5aa1a3a7e7e5c93c74c40464afae6950c564db97a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bloom_filter_map.c",
  "human_readable_source": "\n \n\n#include <sys/syscall.h>\n#include <test_progs.h>\n#include \"bloom_filter_map.skel.h\"\n\nstatic void test_fail_cases(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\t__u32 value;\n\tint fd, err;\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 4, sizeof(value), 100, NULL);\n\tif (!ASSERT_LT(fd, 0, \"bpf_map_create bloom filter invalid key size\"))\n\t\tclose(fd);\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, 0, 100, NULL);\n\tif (!ASSERT_LT(fd, 0, \"bpf_map_create bloom filter invalid value size 0\"))\n\t\tclose(fd);\n\n\t \n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, sizeof(value), 0, NULL);\n\tif (!ASSERT_LT(fd, 0, \"bpf_map_create bloom filter invalid max entries size\"))\n\t\tclose(fd);\n\n\t \n\topts.map_flags = BPF_F_NO_PREALLOC;\n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, sizeof(value), 100, &opts);\n\tif (!ASSERT_LT(fd, 0, \"bpf_map_create bloom filter invalid flags\"))\n\t\tclose(fd);\n\n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, sizeof(value), 100, NULL);\n\tif (!ASSERT_GE(fd, 0, \"bpf_map_create bloom filter\"))\n\t\treturn;\n\n\t \n\terr = bpf_map_update_elem(fd, NULL, &value, -1);\n\tASSERT_EQ(err, -EINVAL, \"bpf_map_update_elem bloom filter invalid flags\");\n\n\terr = bpf_map_update_elem(fd, NULL, &value, BPF_EXIST);\n\tASSERT_EQ(err, -EINVAL, \"bpf_map_update_elem bloom filter invalid flags\");\n\n\terr = bpf_map_update_elem(fd, NULL, &value, BPF_F_LOCK);\n\tASSERT_EQ(err, -EINVAL, \"bpf_map_update_elem bloom filter invalid flags\");\n\n\terr = bpf_map_update_elem(fd, NULL, &value, BPF_NOEXIST);\n\tASSERT_EQ(err, -EINVAL, \"bpf_map_update_elem bloom filter invalid flags\");\n\n\terr = bpf_map_update_elem(fd, NULL, &value, 10000);\n\tASSERT_EQ(err, -EINVAL, \"bpf_map_update_elem bloom filter invalid flags\");\n\n\tclose(fd);\n}\n\nstatic void test_success_cases(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tchar value[11];\n\tint fd, err;\n\n\t \n\topts.map_flags = BPF_F_ZERO_SEED | BPF_F_NUMA_NODE;\n\tfd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, sizeof(value), 100, &opts);\n\tif (!ASSERT_GE(fd, 0, \"bpf_map_create bloom filter success case\"))\n\t\treturn;\n\n\t \n\terr = bpf_map_update_elem(fd, NULL, &value, 0);\n\tif (!ASSERT_OK(err, \"bpf_map_update_elem bloom filter success case\"))\n\t\tgoto done;\n\n\t  \n\terr = bpf_map_lookup_elem(fd, NULL, &value);\n\tASSERT_OK(err, \"bpf_map_update_elem bloom filter success case\");\n\ndone:\n\tclose(fd);\n}\n\nstatic void check_bloom(struct bloom_filter_map *skel)\n{\n\tstruct bpf_link *link;\n\n\tlink = bpf_program__attach(skel->progs.check_bloom);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tsyscall(SYS_getpgid);\n\n\tASSERT_EQ(skel->bss->error, 0, \"error\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void test_inner_map(struct bloom_filter_map *skel, const __u32 *rand_vals,\n\t\t\t   __u32 nr_rand_vals)\n{\n\tint outer_map_fd, inner_map_fd, err, i, key = 0;\n\tstruct bpf_link *link;\n\n\t \n\tinner_map_fd = bpf_map_create(BPF_MAP_TYPE_BLOOM_FILTER, NULL, 0, sizeof(*rand_vals),\n\t\t\t\t      nr_rand_vals, NULL);\n\tif (!ASSERT_GE(inner_map_fd, 0, \"bpf_map_create bloom filter inner map\"))\n\t\treturn;\n\n\tfor (i = 0; i < nr_rand_vals; i++) {\n\t\terr = bpf_map_update_elem(inner_map_fd, NULL, rand_vals + i, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"Add random value to inner_map_fd\"))\n\t\t\tgoto done;\n\t}\n\n\t \n\touter_map_fd = bpf_map__fd(skel->maps.outer_map);\n\terr = bpf_map_update_elem(outer_map_fd, &key, &inner_map_fd, BPF_ANY);\n\tif (!ASSERT_OK(err, \"Add bloom filter map to outer map\"))\n\t\tgoto done;\n\n\t \n\tlink = bpf_program__attach(skel->progs.inner_map);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\tgoto delete_inner_map;\n\n\tsyscall(SYS_getpgid);\n\n\tASSERT_EQ(skel->bss->error, 0, \"error\");\n\n\tbpf_link__destroy(link);\n\ndelete_inner_map:\n\t \n\terr = bpf_map_delete_elem(outer_map_fd, &key);\n\tASSERT_OK(err, \"Delete inner bloom filter map\");\n\ndone:\n\tclose(inner_map_fd);\n}\n\nstatic int setup_progs(struct bloom_filter_map **out_skel, __u32 **out_rand_vals,\n\t\t       __u32 *out_nr_rand_vals)\n{\n\tstruct bloom_filter_map *skel;\n\tint random_data_fd, bloom_fd;\n\t__u32 *rand_vals = NULL;\n\t__u32 map_size, val;\n\tint err, i;\n\n\t \n\tskel = bloom_filter_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bloom_filter_map__open_and_load\"))\n\t\treturn -EINVAL;\n\n\t \n\tmap_size = bpf_map__max_entries(skel->maps.map_random_data);\n\trand_vals = malloc(sizeof(*rand_vals) * map_size);\n\tif (!rand_vals) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\trandom_data_fd = bpf_map__fd(skel->maps.map_random_data);\n\tbloom_fd = bpf_map__fd(skel->maps.map_bloom);\n\tfor (i = 0; i < map_size; i++) {\n\t\tval = rand();\n\n\t\terr = bpf_map_update_elem(random_data_fd, &i, &val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"Add random value to map_random_data\"))\n\t\t\tgoto error;\n\n\t\terr = bpf_map_update_elem(bloom_fd, NULL, &val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"Add random value to map_bloom\"))\n\t\t\tgoto error;\n\n\t\trand_vals[i] = val;\n\t}\n\n\t*out_skel = skel;\n\t*out_rand_vals = rand_vals;\n\t*out_nr_rand_vals = map_size;\n\n\treturn 0;\n\nerror:\n\tbloom_filter_map__destroy(skel);\n\tif (rand_vals)\n\t\tfree(rand_vals);\n\treturn err;\n}\n\nvoid test_bloom_filter_map(void)\n{\n\t__u32 *rand_vals, nr_rand_vals;\n\tstruct bloom_filter_map *skel;\n\tint err;\n\n\ttest_fail_cases();\n\ttest_success_cases();\n\n\terr = setup_progs(&skel, &rand_vals, &nr_rand_vals);\n\tif (err)\n\t\treturn;\n\n\ttest_inner_map(skel, rand_vals, nr_rand_vals);\n\tfree(rand_vals);\n\n\tcheck_bloom(skel);\n\n\tbloom_filter_map__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}