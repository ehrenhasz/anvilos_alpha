{
  "module_name": "empty_skb.c",
  "hash_id": "6d5d2e3d247e0f4fa32d0f23c3164a62dbe8b9746159e6ee716b57e8d9749352",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/empty_skb.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <net/if.h>\n#include \"empty_skb.skel.h\"\n\nvoid test_empty_skb(void)\n{\n\tLIBBPF_OPTS(bpf_test_run_opts, tattr);\n\tstruct empty_skb *bpf_obj = NULL;\n\tstruct nstoken *tok = NULL;\n\tstruct bpf_program *prog;\n\tchar eth_hlen_pp[15];\n\tchar eth_hlen[14];\n\tint veth_ifindex;\n\tint ipip_ifindex;\n\tint err;\n\tint i;\n\n\tstruct {\n\t\tconst char *msg;\n\t\tconst void *data_in;\n\t\t__u32 data_size_in;\n\t\tint *ifindex;\n\t\tint err;\n\t\tint ret;\n\t\tint lwt_egress_ret;  \n\t\tbool success_on_tc;\n\t} tests[] = {\n\t\t \n\n\t\t{\n\t\t\t \n\t\t\t.msg = \"veth empty ingress packet\",\n\t\t\t.data_in = NULL,\n\t\t\t.data_size_in = 0,\n\t\t\t.ifindex = &veth_ifindex,\n\t\t\t.err = -EINVAL,\n\t\t},\n\t\t{\n\t\t\t \n\t\t\t.msg = \"ipip empty ingress packet\",\n\t\t\t.data_in = NULL,\n\t\t\t.data_size_in = 0,\n\t\t\t.ifindex = &ipip_ifindex,\n\t\t\t.err = -EINVAL,\n\t\t},\n\n\t\t \n\n\t\t{\n\t\t\t \n\t\t\t.msg = \"veth ETH_HLEN packet ingress\",\n\t\t\t.data_in = eth_hlen,\n\t\t\t.data_size_in = sizeof(eth_hlen),\n\t\t\t.ifindex = &veth_ifindex,\n\t\t\t.ret = -ERANGE,\n\t\t\t.lwt_egress_ret = -ERANGE,\n\t\t\t.success_on_tc = true,\n\t\t},\n\t\t{\n\t\t\t \n\t\t\t.msg = \"ipip ETH_HLEN packet ingress\",\n\t\t\t.data_in = eth_hlen,\n\t\t\t.data_size_in = sizeof(eth_hlen),\n\t\t\t.ifindex = &ipip_ifindex,\n\t\t\t.ret = -ERANGE,\n\t\t\t.lwt_egress_ret = -ERANGE,\n\t\t},\n\n\t\t \n\n\t\t{\n\t\t\t.msg = \"veth ETH_HLEN+1 packet ingress\",\n\t\t\t.data_in = eth_hlen_pp,\n\t\t\t.data_size_in = sizeof(eth_hlen_pp),\n\t\t\t.ifindex = &veth_ifindex,\n\t\t\t.lwt_egress_ret = 1,  \n\t\t},\n\t\t{\n\t\t\t.msg = \"ipip ETH_HLEN+1 packet ingress\",\n\t\t\t.data_in = eth_hlen_pp,\n\t\t\t.data_size_in = sizeof(eth_hlen_pp),\n\t\t\t.ifindex = &ipip_ifindex,\n\t\t},\n\t};\n\n\tSYS(out, \"ip netns add empty_skb\");\n\ttok = open_netns(\"empty_skb\");\n\tSYS(out, \"ip link add veth0 type veth peer veth1\");\n\tSYS(out, \"ip link set dev veth0 up\");\n\tSYS(out, \"ip link set dev veth1 up\");\n\tSYS(out, \"ip addr add 10.0.0.1/8 dev veth0\");\n\tSYS(out, \"ip addr add 10.0.0.2/8 dev veth1\");\n\tveth_ifindex = if_nametoindex(\"veth0\");\n\n\tSYS(out, \"ip link add ipip0 type ipip local 10.0.0.1 remote 10.0.0.2\");\n\tSYS(out, \"ip link set ipip0 up\");\n\tSYS(out, \"ip addr add 192.168.1.1/16 dev ipip0\");\n\tipip_ifindex = if_nametoindex(\"ipip0\");\n\n\tbpf_obj = empty_skb__open_and_load();\n\tif (!ASSERT_OK_PTR(bpf_obj, \"open skeleton\"))\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tbpf_object__for_each_program(prog, bpf_obj->obj) {\n\t\t\tbool at_egress = strstr(bpf_program__name(prog), \"egress\") != NULL;\n\t\t\tbool at_tc = !strncmp(bpf_program__section_name(prog), \"tc\", 2);\n\t\t\tint expected_ret;\n\t\t\tchar buf[128];\n\n\t\t\texpected_ret = at_egress && !at_tc ? tests[i].lwt_egress_ret : tests[i].ret;\n\n\t\t\ttattr.data_in = tests[i].data_in;\n\t\t\ttattr.data_size_in = tests[i].data_size_in;\n\n\t\t\ttattr.data_size_out = 0;\n\t\t\tbpf_obj->bss->ifindex = *tests[i].ifindex;\n\t\t\tbpf_obj->bss->ret = 0;\n\t\t\terr = bpf_prog_test_run_opts(bpf_program__fd(prog), &tattr);\n\t\t\tsprintf(buf, \"err: %s [%s]\", tests[i].msg, bpf_program__name(prog));\n\n\t\t\tif (at_tc && tests[i].success_on_tc)\n\t\t\t\tASSERT_GE(err, 0, buf);\n\t\t\telse\n\t\t\t\tASSERT_EQ(err, tests[i].err, buf);\n\t\t\tsprintf(buf, \"ret: %s [%s]\", tests[i].msg, bpf_program__name(prog));\n\t\t\tif (at_tc && tests[i].success_on_tc)\n\t\t\t\tASSERT_GE(bpf_obj->bss->ret, 0, buf);\n\t\t\telse\n\t\t\t\tASSERT_EQ(bpf_obj->bss->ret, expected_ret, buf);\n\t\t}\n\t}\n\nout:\n\tif (bpf_obj)\n\t\tempty_skb__destroy(bpf_obj);\n\tif (tok)\n\t\tclose_netns(tok);\n\tSYS_NOFAIL(\"ip netns del empty_skb\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}