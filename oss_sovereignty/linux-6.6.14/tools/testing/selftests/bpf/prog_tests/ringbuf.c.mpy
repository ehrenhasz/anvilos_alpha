{
  "module_name": "ringbuf.c",
  "hash_id": "c03cb0f257dd9b103da924fa67e31efeca447dc92c16351e69b46d0a9a44cf5b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/ringbuf.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <linux/compiler.h>\n#include <asm/barrier.h>\n#include <test_progs.h>\n#include <sys/mman.h>\n#include <sys/epoll.h>\n#include <time.h>\n#include <sched.h>\n#include <signal.h>\n#include <pthread.h>\n#include <sys/sysinfo.h>\n#include <linux/perf_event.h>\n#include <linux/ring_buffer.h>\n#include \"test_ringbuf.lskel.h\"\n#include \"test_ringbuf_map_key.lskel.h\"\n\n#define EDONE 7777\n\nstatic int duration = 0;\n\nstruct sample {\n\tint pid;\n\tint seq;\n\tlong value;\n\tchar comm[16];\n};\n\nstatic int sample_cnt;\n\nstatic void atomic_inc(int *cnt)\n{\n\t__atomic_add_fetch(cnt, 1, __ATOMIC_SEQ_CST);\n}\n\nstatic int atomic_xchg(int *cnt, int val)\n{\n\treturn __atomic_exchange_n(cnt, val, __ATOMIC_SEQ_CST);\n}\n\nstatic int process_sample(void *ctx, void *data, size_t len)\n{\n\tstruct sample *s = data;\n\n\tatomic_inc(&sample_cnt);\n\n\tswitch (s->seq) {\n\tcase 0:\n\t\tCHECK(s->value != 333, \"sample1_value\", \"exp %ld, got %ld\\n\",\n\t\t      333L, s->value);\n\t\treturn 0;\n\tcase 1:\n\t\tCHECK(s->value != 777, \"sample2_value\", \"exp %ld, got %ld\\n\",\n\t\t      777L, s->value);\n\t\treturn -EDONE;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic struct test_ringbuf_map_key_lskel *skel_map_key;\nstatic struct test_ringbuf_lskel *skel;\nstatic struct ring_buffer *ringbuf;\n\nstatic void trigger_samples()\n{\n\tskel->bss->dropped = 0;\n\tskel->bss->total = 0;\n\tskel->bss->discarded = 0;\n\n\t \n\tskel->bss->value = 333;\n\tsyscall(__NR_getpgid);\n\tskel->bss->value = 777;\n\tsyscall(__NR_getpgid);\n}\n\nstatic void *poll_thread(void *input)\n{\n\tlong timeout = (long)input;\n\n\treturn (void *)(long)ring_buffer__poll(ringbuf, timeout);\n}\n\nstatic void ringbuf_subtest(void)\n{\n\tconst size_t rec_sz = BPF_RINGBUF_HDR_SZ + sizeof(struct sample);\n\tpthread_t thread;\n\tlong bg_ret = -1;\n\tint err, cnt, rb_fd;\n\tint page_size = getpagesize();\n\tvoid *mmap_ptr, *tmp_ptr;\n\n\tskel = test_ringbuf_lskel__open();\n\tif (CHECK(!skel, \"skel_open\", \"skeleton open failed\\n\"))\n\t\treturn;\n\n\tskel->maps.ringbuf.max_entries = page_size;\n\n\terr = test_ringbuf_lskel__load(skel);\n\tif (CHECK(err != 0, \"skel_load\", \"skeleton load failed\\n\"))\n\t\tgoto cleanup;\n\n\trb_fd = skel->maps.ringbuf.map_fd;\n\t \n\tmmap_ptr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, rb_fd, 0);\n\tASSERT_OK_PTR(mmap_ptr, \"rw_cons_pos\");\n\ttmp_ptr = mremap(mmap_ptr, page_size, 2 * page_size, MREMAP_MAYMOVE);\n\tif (!ASSERT_ERR_PTR(tmp_ptr, \"rw_extend\"))\n\t\tgoto cleanup;\n\tASSERT_ERR(mprotect(mmap_ptr, page_size, PROT_EXEC), \"exec_cons_pos_protect\");\n\tASSERT_OK(munmap(mmap_ptr, page_size), \"unmap_rw\");\n\n\t \n\tmmap_ptr = mmap(NULL, page_size, PROT_WRITE, MAP_SHARED, rb_fd, page_size);\n\terr = -errno;\n\tASSERT_ERR_PTR(mmap_ptr, \"wr_prod_pos\");\n\tASSERT_EQ(err, -EPERM, \"wr_prod_pos_err\");\n\n\t \n\tmmap_ptr = mmap(NULL, page_size, PROT_WRITE, MAP_SHARED, rb_fd, 2 * page_size);\n\terr = -errno;\n\tASSERT_ERR_PTR(mmap_ptr, \"wr_data_page_one\");\n\tASSERT_EQ(err, -EPERM, \"wr_data_page_one_err\");\n\tmmap_ptr = mmap(NULL, page_size, PROT_WRITE, MAP_SHARED, rb_fd, 3 * page_size);\n\tASSERT_ERR_PTR(mmap_ptr, \"wr_data_page_two\");\n\tmmap_ptr = mmap(NULL, 2 * page_size, PROT_WRITE, MAP_SHARED, rb_fd, 2 * page_size);\n\tASSERT_ERR_PTR(mmap_ptr, \"wr_data_page_all\");\n\n\t \n\tmmap_ptr = mmap(NULL, 4 * page_size, PROT_READ, MAP_SHARED, rb_fd, 0);\n\tif (!ASSERT_OK_PTR(mmap_ptr, \"ro_prod_pos\"))\n\t\tgoto cleanup;\n\n\tASSERT_ERR(mprotect(mmap_ptr, 4 * page_size, PROT_WRITE), \"write_protect\");\n\tASSERT_ERR(mprotect(mmap_ptr, 4 * page_size, PROT_EXEC), \"exec_protect\");\n\tASSERT_ERR_PTR(mremap(mmap_ptr, 0, 4 * page_size, MREMAP_MAYMOVE), \"ro_remap\");\n\tASSERT_OK(munmap(mmap_ptr, 4 * page_size), \"unmap_ro\");\n\n\t \n\tmmap_ptr = mmap(NULL, page_size, PROT_READ, MAP_SHARED, rb_fd, page_size);\n\tif (!ASSERT_OK_PTR(mmap_ptr, \"ro_prod_pos\"))\n\t\tgoto cleanup;\n\n\tASSERT_ERR(mprotect(mmap_ptr, page_size, PROT_WRITE), \"write_protect\");\n\tASSERT_ERR(mprotect(mmap_ptr, page_size, PROT_EXEC), \"exec_protect\");\n\tASSERT_ERR_PTR(mremap(mmap_ptr, 0, 3 * page_size, MREMAP_MAYMOVE), \"ro_remap\");\n\tASSERT_OK(munmap(mmap_ptr, page_size), \"unmap_ro\");\n\n\t \n\tskel->bss->pid = getpid();\n\n\tringbuf = ring_buffer__new(skel->maps.ringbuf.map_fd,\n\t\t\t\t   process_sample, NULL, NULL);\n\tif (CHECK(!ringbuf, \"ringbuf_create\", \"failed to create ringbuf\\n\"))\n\t\tgoto cleanup;\n\n\terr = test_ringbuf_lskel__attach(skel);\n\tif (CHECK(err, \"skel_attach\", \"skeleton attachment failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\ttrigger_samples();\n\n\t \n\tCHECK(skel->bss->avail_data != 3 * rec_sz,\n\t      \"err_avail_size\", \"exp %ld, got %ld\\n\",\n\t      3L * rec_sz, skel->bss->avail_data);\n\tCHECK(skel->bss->ring_size != page_size,\n\t      \"err_ring_size\", \"exp %ld, got %ld\\n\",\n\t      (long)page_size, skel->bss->ring_size);\n\tCHECK(skel->bss->cons_pos != 0,\n\t      \"err_cons_pos\", \"exp %ld, got %ld\\n\",\n\t      0L, skel->bss->cons_pos);\n\tCHECK(skel->bss->prod_pos != 3 * rec_sz,\n\t      \"err_prod_pos\", \"exp %ld, got %ld\\n\",\n\t      3L * rec_sz, skel->bss->prod_pos);\n\n\t \n\terr = ring_buffer__poll(ringbuf, -1);\n\n\t \n\tif (CHECK(err != -EDONE, \"err_done\", \"done err: %d\\n\", err))\n\t\tgoto cleanup;\n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 2, \"cnt\", \"exp %d samples, got %d\\n\", 2, cnt);\n\n\t \n\terr = ring_buffer__poll(ringbuf, 0);\n\tif (CHECK(err != 0, \"extra_samples\", \"poll result: %d\\n\", err))\n\t\tgoto cleanup;\n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 0, \"cnt\", \"exp %d samples, got %d\\n\", 0, cnt);\n\n\tCHECK(skel->bss->dropped != 0, \"err_dropped\", \"exp %ld, got %ld\\n\",\n\t      0L, skel->bss->dropped);\n\tCHECK(skel->bss->total != 2, \"err_total\", \"exp %ld, got %ld\\n\",\n\t      2L, skel->bss->total);\n\tCHECK(skel->bss->discarded != 1, \"err_discarded\", \"exp %ld, got %ld\\n\",\n\t      1L, skel->bss->discarded);\n\n\t \n\ttrigger_samples();\n\tCHECK(skel->bss->cons_pos != 3 * rec_sz,\n\t      \"err_cons_pos\", \"exp %ld, got %ld\\n\",\n\t      3L * rec_sz, skel->bss->cons_pos);\n\terr = ring_buffer__poll(ringbuf, -1);\n\tCHECK(err <= 0, \"poll_err\", \"err %d\\n\", err);\n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 2, \"cnt\", \"exp %d samples, got %d\\n\", 2, cnt);\n\n\t \n\terr = pthread_create(&thread, NULL, poll_thread, (void *)(long)10000);\n\tif (CHECK(err, \"bg_poll\", \"pthread_create failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tskel->bss->flags = BPF_RB_NO_WAKEUP;\n\n\t \n\tusleep(50000);\n\ttrigger_samples();\n\t \n\tusleep(50000);\n\t \n\terr = pthread_tryjoin_np(thread, (void **)&bg_ret);\n\tif (CHECK(err != EBUSY, \"try_join\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tCHECK(skel->bss->dropped != 0, \"err_dropped\", \"exp %ld, got %ld\\n\",\n\t      0L, skel->bss->dropped);\n\tCHECK(skel->bss->total != 2, \"err_total\", \"exp %ld, got %ld\\n\",\n\t      2L, skel->bss->total);\n\tCHECK(skel->bss->discarded != 1, \"err_discarded\", \"exp %ld, got %ld\\n\",\n\t      1L, skel->bss->discarded);\n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 0, \"cnt\", \"exp %d samples, got %d\\n\", 0, cnt);\n\n\t \n\tskel->bss->flags = 0;\n\n\t \n\ttrigger_samples();\n\n\t \n\terr = pthread_tryjoin_np(thread, (void **)&bg_ret);\n\tif (CHECK(err != EBUSY, \"try_join\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 0, \"cnt\", \"exp %d samples, got %d\\n\", 0, cnt);\n\n\tskel->bss->dropped = 0;\n\tskel->bss->total = 0;\n\tskel->bss->discarded = 0;\n\n\tskel->bss->value = 333;\n\tsyscall(__NR_getpgid);\n\t \n\tskel->bss->flags = BPF_RB_FORCE_WAKEUP;\n\tskel->bss->value = 777;\n\tsyscall(__NR_getpgid);\n\n\t \n\tusleep(50000);\n\terr = pthread_tryjoin_np(thread, (void **)&bg_ret);\n\tif (CHECK(err, \"join_bg\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\tif (CHECK(bg_ret <= 0, \"bg_ret\", \"epoll_wait result: %ld\", bg_ret))\n\t\tgoto cleanup;\n\n\t \n\terr = ring_buffer__consume(ringbuf);\n\tCHECK(err < 0, \"rb_consume\", \"failed: %d\\b\", err);\n\n\t \n\tcnt = atomic_xchg(&sample_cnt, 0);\n\tCHECK(cnt != 6, \"cnt\", \"exp %d samples, got %d\\n\", 6, cnt);\n\n\t \n\tCHECK(skel->bss->dropped != 0, \"err_dropped\", \"exp %ld, got %ld\\n\",\n\t      0L, skel->bss->dropped);\n\tCHECK(skel->bss->total != 2, \"err_total\", \"exp %ld, got %ld\\n\",\n\t      2L, skel->bss->total);\n\tCHECK(skel->bss->discarded != 1, \"err_discarded\", \"exp %ld, got %ld\\n\",\n\t      1L, skel->bss->discarded);\n\n\ttest_ringbuf_lskel__detach(skel);\ncleanup:\n\tring_buffer__free(ringbuf);\n\ttest_ringbuf_lskel__destroy(skel);\n}\n\nstatic int process_map_key_sample(void *ctx, void *data, size_t len)\n{\n\tstruct sample *s;\n\tint err, val;\n\n\ts = data;\n\tswitch (s->seq) {\n\tcase 1:\n\t\tASSERT_EQ(s->value, 42, \"sample_value\");\n\t\terr = bpf_map_lookup_elem(skel_map_key->maps.hash_map.map_fd,\n\t\t\t\t\t  s, &val);\n\t\tASSERT_OK(err, \"hash_map bpf_map_lookup_elem\");\n\t\tASSERT_EQ(val, 1, \"hash_map val\");\n\t\treturn -EDONE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ringbuf_map_key_subtest(void)\n{\n\tint err;\n\n\tskel_map_key = test_ringbuf_map_key_lskel__open();\n\tif (!ASSERT_OK_PTR(skel_map_key, \"test_ringbuf_map_key_lskel__open\"))\n\t\treturn;\n\n\tskel_map_key->maps.ringbuf.max_entries = getpagesize();\n\tskel_map_key->bss->pid = getpid();\n\n\terr = test_ringbuf_map_key_lskel__load(skel_map_key);\n\tif (!ASSERT_OK(err, \"test_ringbuf_map_key_lskel__load\"))\n\t\tgoto cleanup;\n\n\tringbuf = ring_buffer__new(skel_map_key->maps.ringbuf.map_fd,\n\t\t\t\t   process_map_key_sample, NULL, NULL);\n\tif (!ASSERT_OK_PTR(ringbuf, \"ring_buffer__new\"))\n\t\tgoto cleanup;\n\n\terr = test_ringbuf_map_key_lskel__attach(skel_map_key);\n\tif (!ASSERT_OK(err, \"test_ringbuf_map_key_lskel__attach\"))\n\t\tgoto cleanup_ringbuf;\n\n\tsyscall(__NR_getpgid);\n\tASSERT_EQ(skel_map_key->bss->seq, 1, \"skel_map_key->bss->seq\");\n\terr = ring_buffer__poll(ringbuf, -1);\n\tASSERT_EQ(err, -EDONE, \"ring_buffer__poll\");\n\ncleanup_ringbuf:\n\tring_buffer__free(ringbuf);\ncleanup:\n\ttest_ringbuf_map_key_lskel__destroy(skel_map_key);\n}\n\nvoid test_ringbuf(void)\n{\n\tif (test__start_subtest(\"ringbuf\"))\n\t\tringbuf_subtest();\n\tif (test__start_subtest(\"ringbuf_map_key\"))\n\t\tringbuf_map_key_subtest();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}