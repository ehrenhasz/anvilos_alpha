{
  "module_name": "kfunc_call.c",
  "hash_id": "6b863421a8bfbaaa59707b248126942a9d36d4e6671b06ae98ea60764bd74e6f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/kfunc_call.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"kfunc_call_fail.skel.h\"\n#include \"kfunc_call_test.skel.h\"\n#include \"kfunc_call_test.lskel.h\"\n#include \"kfunc_call_test_subprog.skel.h\"\n#include \"kfunc_call_test_subprog.lskel.h\"\n#include \"kfunc_call_destructive.skel.h\"\n\n#include \"cap_helpers.h\"\n\nstatic size_t log_buf_sz = 1048576;  \nstatic char obj_log_buf[1048576];\n\nenum kfunc_test_type {\n\ttc_test = 0,\n\tsyscall_test,\n\tsyscall_null_ctx_test,\n};\n\nstruct kfunc_test_params {\n\tconst char *prog_name;\n\tunsigned long lskel_prog_desc_offset;\n\tint retval;\n\tenum kfunc_test_type test_type;\n\tconst char *expected_err_msg;\n};\n\n#define __BPF_TEST_SUCCESS(name, __retval, type) \\\n\t{ \\\n\t  .prog_name = #name, \\\n\t  .lskel_prog_desc_offset = offsetof(struct kfunc_call_test_lskel, progs.name), \\\n\t  .retval = __retval, \\\n\t  .test_type = type, \\\n\t  .expected_err_msg = NULL, \\\n\t}\n\n#define __BPF_TEST_FAIL(name, __retval, type, error_msg) \\\n\t{ \\\n\t  .prog_name = #name, \\\n\t  .lskel_prog_desc_offset = 0  , \\\n\t  .retval = __retval, \\\n\t  .test_type = type, \\\n\t  .expected_err_msg = error_msg, \\\n\t}\n\n#define TC_TEST(name, retval) __BPF_TEST_SUCCESS(name, retval, tc_test)\n#define SYSCALL_TEST(name, retval) __BPF_TEST_SUCCESS(name, retval, syscall_test)\n#define SYSCALL_NULL_CTX_TEST(name, retval) __BPF_TEST_SUCCESS(name, retval, syscall_null_ctx_test)\n\n#define TC_FAIL(name, retval, error_msg) __BPF_TEST_FAIL(name, retval, tc_test, error_msg)\n#define SYSCALL_NULL_CTX_FAIL(name, retval, error_msg) \\\n\t__BPF_TEST_FAIL(name, retval, syscall_null_ctx_test, error_msg)\n\nstatic struct kfunc_test_params kfunc_tests[] = {\n\t \n\tSYSCALL_NULL_CTX_FAIL(kfunc_syscall_test_fail, -EINVAL, \"processed 4 insns\"),\n\tSYSCALL_NULL_CTX_FAIL(kfunc_syscall_test_null_fail, -EINVAL, \"processed 4 insns\"),\n\tTC_FAIL(kfunc_call_test_get_mem_fail_rdonly, 0, \"R0 cannot write into rdonly_mem\"),\n\tTC_FAIL(kfunc_call_test_get_mem_fail_use_after_free, 0, \"invalid mem access 'scalar'\"),\n\tTC_FAIL(kfunc_call_test_get_mem_fail_oob, 0, \"min value is outside of the allowed memory range\"),\n\tTC_FAIL(kfunc_call_test_get_mem_fail_not_const, 0, \"is not a const\"),\n\tTC_FAIL(kfunc_call_test_mem_acquire_fail, 0, \"acquire kernel function does not return PTR_TO_BTF_ID\"),\n\n\t \n\tTC_TEST(kfunc_call_test1, 12),\n\tTC_TEST(kfunc_call_test2, 3),\n\tTC_TEST(kfunc_call_test4, -1234),\n\tTC_TEST(kfunc_call_test_ref_btf_id, 0),\n\tTC_TEST(kfunc_call_test_get_mem, 42),\n\tSYSCALL_TEST(kfunc_syscall_test, 0),\n\tSYSCALL_NULL_CTX_TEST(kfunc_syscall_test_null, 0),\n\tTC_TEST(kfunc_call_test_static_unused_arg, 0),\n};\n\nstruct syscall_test_args {\n\t__u8 data[16];\n\tsize_t size;\n};\n\nstatic void verify_success(struct kfunc_test_params *param)\n{\n\tstruct kfunc_call_test_lskel *lskel = NULL;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\tstruct bpf_prog_desc *lskel_prog;\n\tstruct kfunc_call_test *skel;\n\tstruct bpf_program *prog;\n\tint prog_fd, err;\n\tstruct syscall_test_args args = {\n\t\t.size = 10,\n\t};\n\n\tswitch (param->test_type) {\n\tcase syscall_test:\n\t\ttopts.ctx_in = &args;\n\t\ttopts.ctx_size_in = sizeof(args);\n\t\t \n\tcase syscall_null_ctx_test:\n\t\tbreak;\n\tcase tc_test:\n\t\ttopts.data_in = &pkt_v4;\n\t\ttopts.data_size_in = sizeof(pkt_v4);\n\t\ttopts.repeat = 1;\n\t\tbreak;\n\t}\n\n\t \n\tskel = kfunc_call_test__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel\"))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, param->prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto cleanup;\n\n\tprog_fd = bpf_program__fd(prog);\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, param->prog_name))\n\t\tgoto cleanup;\n\n\tif (!ASSERT_EQ(topts.retval, param->retval, \"retval\"))\n\t\tgoto cleanup;\n\n\t \n\tlskel = kfunc_call_test_lskel__open_and_load();\n\tif (!ASSERT_OK_PTR(lskel, \"lskel\"))\n\t\tgoto cleanup;\n\n\tlskel_prog = (struct bpf_prog_desc *)((char *)lskel + param->lskel_prog_desc_offset);\n\n\tprog_fd = lskel_prog->prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, param->prog_name))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(topts.retval, param->retval, \"retval\");\n\ncleanup:\n\tkfunc_call_test__destroy(skel);\n\tif (lskel)\n\t\tkfunc_call_test_lskel__destroy(lskel);\n}\n\nstatic void verify_fail(struct kfunc_test_params *param)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, opts);\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\tstruct bpf_program *prog;\n\tstruct kfunc_call_fail *skel;\n\tint prog_fd, err;\n\tstruct syscall_test_args args = {\n\t\t.size = 10,\n\t};\n\n\topts.kernel_log_buf = obj_log_buf;\n\topts.kernel_log_size = log_buf_sz;\n\topts.kernel_log_level = 1;\n\n\tswitch (param->test_type) {\n\tcase syscall_test:\n\t\ttopts.ctx_in = &args;\n\t\ttopts.ctx_size_in = sizeof(args);\n\t\t \n\tcase syscall_null_ctx_test:\n\t\tbreak;\n\tcase tc_test:\n\t\ttopts.data_in = &pkt_v4;\n\t\ttopts.data_size_in = sizeof(pkt_v4);\n\t\ttopts.repeat = 1;\n\t\tbreak;\n\t}\n\n\tskel = kfunc_call_fail__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"kfunc_call_fail__open_opts\"))\n\t\tgoto cleanup;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, param->prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto cleanup;\n\n\tbpf_program__set_autoload(prog, true);\n\n\terr = kfunc_call_fail__load(skel);\n\tif (!param->retval) {\n\t\t \n\t\tif (!ASSERT_ERR(err, \"unexpected load success\"))\n\t\t\tgoto out_err;\n\n\t} else {\n\t\t \n\t\tif (!ASSERT_OK(err, \"unexpected load error\"))\n\t\t\tgoto out_err;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\t\tif (!ASSERT_EQ(err, param->retval, param->prog_name))\n\t\t\tgoto out_err;\n\t}\n\nout_err:\n\tif (!ASSERT_OK_PTR(strstr(obj_log_buf, param->expected_err_msg), \"expected_err_msg\")) {\n\t\tfprintf(stderr, \"Expected err_msg: %s\\n\", param->expected_err_msg);\n\t\tfprintf(stderr, \"Verifier output: %s\\n\", obj_log_buf);\n\t}\n\ncleanup:\n\tkfunc_call_fail__destroy(skel);\n}\n\nstatic void test_main(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kfunc_tests); i++) {\n\t\tif (!test__start_subtest(kfunc_tests[i].prog_name))\n\t\t\tcontinue;\n\n\t\tif (!kfunc_tests[i].expected_err_msg)\n\t\t\tverify_success(&kfunc_tests[i]);\n\t\telse\n\t\t\tverify_fail(&kfunc_tests[i]);\n\t}\n}\n\nstatic void test_subprog(void)\n{\n\tstruct kfunc_call_test_subprog *skel;\n\tint prog_fd, err;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tskel = kfunc_call_test_subprog__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel\"))\n\t\treturn;\n\n\tprog_fd = bpf_program__fd(skel->progs.kfunc_call_test1);\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"bpf_prog_test_run(test1)\");\n\tASSERT_EQ(topts.retval, 10, \"test1-retval\");\n\tASSERT_NEQ(skel->data->active_res, -1, \"active_res\");\n\tASSERT_EQ(skel->data->sk_state_res, BPF_TCP_CLOSE, \"sk_state_res\");\n\n\tkfunc_call_test_subprog__destroy(skel);\n}\n\nstatic void test_subprog_lskel(void)\n{\n\tstruct kfunc_call_test_subprog_lskel *skel;\n\tint prog_fd, err;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tskel = kfunc_call_test_subprog_lskel__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel\"))\n\t\treturn;\n\n\tprog_fd = skel->progs.kfunc_call_test1.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"bpf_prog_test_run(test1)\");\n\tASSERT_EQ(topts.retval, 10, \"test1-retval\");\n\tASSERT_NEQ(skel->data->active_res, -1, \"active_res\");\n\tASSERT_EQ(skel->data->sk_state_res, BPF_TCP_CLOSE, \"sk_state_res\");\n\n\tkfunc_call_test_subprog_lskel__destroy(skel);\n}\n\nstatic int test_destructive_open_and_load(void)\n{\n\tstruct kfunc_call_destructive *skel;\n\tint err;\n\n\tskel = kfunc_call_destructive__open();\n\tif (!ASSERT_OK_PTR(skel, \"prog_open\"))\n\t\treturn -1;\n\n\terr = kfunc_call_destructive__load(skel);\n\n\tkfunc_call_destructive__destroy(skel);\n\n\treturn err;\n}\n\nstatic void test_destructive(void)\n{\n\t__u64 save_caps = 0;\n\n\tASSERT_OK(test_destructive_open_and_load(), \"successful_load\");\n\n\tif (!ASSERT_OK(cap_disable_effective(1ULL << CAP_SYS_BOOT, &save_caps), \"drop_caps\"))\n\t\treturn;\n\n\tASSERT_EQ(test_destructive_open_and_load(), -13, \"no_caps_failure\");\n\n\tcap_enable_effective(save_caps, NULL);\n}\n\nvoid test_kfunc_call(void)\n{\n\ttest_main();\n\n\tif (test__start_subtest(\"subprog\"))\n\t\ttest_subprog();\n\n\tif (test__start_subtest(\"subprog_lskel\"))\n\t\ttest_subprog_lskel();\n\n\tif (test__start_subtest(\"destructive\"))\n\t\ttest_destructive();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}