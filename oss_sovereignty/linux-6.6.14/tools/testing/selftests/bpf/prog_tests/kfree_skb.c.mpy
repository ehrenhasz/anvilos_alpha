{
  "module_name": "kfree_skb.c",
  "hash_id": "09d54bf01fb7bf3cf87f3335753a7c01cbcad43046a35ce42e0a1ec42f8763f6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/kfree_skb.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"kfree_skb.skel.h\"\n\nstruct meta {\n\tint ifindex;\n\t__u32 cb32_0;\n\t__u8 cb8_0;\n};\n\nstatic union {\n\t__u32 cb32[5];\n\t__u8 cb8[20];\n} cb = {\n\t.cb32[0] = 0x81828384,\n};\n\nstatic void on_sample(void *ctx, int cpu, void *data, __u32 size)\n{\n\tstruct meta *meta = (struct meta *)data;\n\tstruct ipv6_packet *pkt_v6 = data + sizeof(*meta);\n\tint duration = 0;\n\n\tif (CHECK(size != 72 + sizeof(*meta), \"check_size\", \"size %u != %zu\\n\",\n\t\t  size, 72 + sizeof(*meta)))\n\t\treturn;\n\tif (CHECK(meta->ifindex != 1, \"check_meta_ifindex\",\n\t\t  \"meta->ifindex = %d\\n\", meta->ifindex))\n\t\t \n\t\treturn;\n\tif (CHECK(meta->cb8_0 != cb.cb8[0], \"check_cb8_0\", \"cb8_0 %x != %x\\n\",\n\t\t  meta->cb8_0, cb.cb8[0]))\n\t\treturn;\n\tif (CHECK(meta->cb32_0 != cb.cb32[0], \"check_cb32_0\",\n\t\t  \"cb32_0 %x != %x\\n\",\n\t\t  meta->cb32_0, cb.cb32[0]))\n\t\treturn;\n\tif (CHECK(pkt_v6->eth.h_proto != htons(ETH_P_IPV6), \"check_eth\",\n\t\t  \"h_proto %x\\n\", pkt_v6->eth.h_proto))\n\t\treturn;\n\tif (CHECK(pkt_v6->iph.nexthdr != 6, \"check_ip\",\n\t\t  \"iph.nexthdr %x\\n\", pkt_v6->iph.nexthdr))\n\t\treturn;\n\tif (CHECK(pkt_v6->tcp.doff != 5, \"check_tcp\",\n\t\t  \"tcp.doff %x\\n\", pkt_v6->tcp.doff))\n\t\treturn;\n\n\t*(bool *)ctx = true;\n}\n\n \nvoid serial_test_kfree_skb(void)\n{\n\tstruct __sk_buff skb = {};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v6,\n\t\t.data_size_in = sizeof(pkt_v6),\n\t\t.ctx_in = &skb,\n\t\t.ctx_size_in = sizeof(skb),\n\t);\n\tstruct kfree_skb *skel = NULL;\n\tstruct bpf_link *link;\n\tstruct bpf_object *obj;\n\tstruct perf_buffer *pb = NULL;\n\tint err, prog_fd;\n\tbool passed = false;\n\t__u32 duration = 0;\n\tconst int zero = 0;\n\tbool test_ok[2];\n\n\terr = bpf_prog_test_load(\"./test_pkt_access.bpf.o\", BPF_PROG_TYPE_SCHED_CLS,\n\t\t\t\t &obj, &prog_fd);\n\tif (CHECK(err, \"prog_load sched cls\", \"err %d errno %d\\n\", err, errno))\n\t\treturn;\n\n\tskel = kfree_skb__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"kfree_skb_skel\"))\n\t\tgoto close_prog;\n\n\tlink = bpf_program__attach_raw_tracepoint(skel->progs.trace_kfree_skb, NULL);\n\tif (!ASSERT_OK_PTR(link, \"attach_raw_tp\"))\n\t\tgoto close_prog;\n\tskel->links.trace_kfree_skb = link;\n\n\tlink = bpf_program__attach_trace(skel->progs.fentry_eth_type_trans);\n\tif (!ASSERT_OK_PTR(link, \"attach fentry\"))\n\t\tgoto close_prog;\n\tskel->links.fentry_eth_type_trans = link;\n\n\tlink = bpf_program__attach_trace(skel->progs.fexit_eth_type_trans);\n\tif (!ASSERT_OK_PTR(link, \"attach fexit\"))\n\t\tgoto close_prog;\n\tskel->links.fexit_eth_type_trans = link;\n\n\t \n\tpb = perf_buffer__new(bpf_map__fd(skel->maps.perf_buf_map), 1,\n\t\t\t      on_sample, NULL, &passed, NULL);\n\tif (!ASSERT_OK_PTR(pb, \"perf_buf__new\"))\n\t\tgoto close_prog;\n\n\tmemcpy(skb.cb, &cb, sizeof(cb));\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"ipv6 test_run\");\n\tASSERT_OK(topts.retval, \"ipv6 test_run retval\");\n\n\t \n\terr = perf_buffer__poll(pb, 100);\n\tif (CHECK(err < 0, \"perf_buffer__poll\", \"err %d\\n\", err))\n\t\tgoto close_prog;\n\n\t \n\tASSERT_TRUE(passed, \"passed\");\n\n\terr = bpf_map_lookup_elem(bpf_map__fd(skel->maps.bss), &zero, test_ok);\n\tif (CHECK(err, \"get_result\",\n\t\t  \"failed to get output data: %d\\n\", err))\n\t\tgoto close_prog;\n\n\tCHECK_FAIL(!test_ok[0] || !test_ok[1]);\nclose_prog:\n\tperf_buffer__free(pb);\n\tbpf_object__close(obj);\n\tkfree_skb__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}