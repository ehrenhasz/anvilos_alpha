{
  "module_name": "xdp_bpf2bpf.c",
  "hash_id": "8783bfd737055863e9fecf9dcc6a66d4b71dc44fe1f1c527ce6248c334091c66",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_bpf2bpf.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <net/if.h>\n#include \"test_xdp.skel.h\"\n#include \"test_xdp_bpf2bpf.skel.h\"\n\nstruct meta {\n\tint ifindex;\n\tint pkt_len;\n};\n\nstruct test_ctx_s {\n\tbool passed;\n\tint pkt_size;\n};\n\nstruct test_ctx_s test_ctx;\n\nstatic void on_sample(void *ctx, int cpu, void *data, __u32 size)\n{\n\tstruct meta *meta = (struct meta *)data;\n\tstruct ipv4_packet *trace_pkt_v4 = data + sizeof(*meta);\n\tunsigned char *raw_pkt = data + sizeof(*meta);\n\tstruct test_ctx_s *tst_ctx = ctx;\n\n\tASSERT_GE(size, sizeof(pkt_v4) + sizeof(*meta), \"check_size\");\n\tASSERT_EQ(meta->ifindex, if_nametoindex(\"lo\"), \"check_meta_ifindex\");\n\tASSERT_EQ(meta->pkt_len, tst_ctx->pkt_size, \"check_meta_pkt_len\");\n\tASSERT_EQ(memcmp(trace_pkt_v4, &pkt_v4, sizeof(pkt_v4)), 0,\n\t\t  \"check_packet_content\");\n\n\tif (meta->pkt_len > sizeof(pkt_v4)) {\n\t\tfor (int i = 0; i < meta->pkt_len - sizeof(pkt_v4); i++)\n\t\t\tASSERT_EQ(raw_pkt[i + sizeof(pkt_v4)], (unsigned char)i,\n\t\t\t\t  \"check_packet_content\");\n\t}\n\n\ttst_ctx->passed = true;\n}\n\n#define BUF_SZ\t9000\n\nstatic void run_xdp_bpf2bpf_pkt_size(int pkt_fd, struct perf_buffer *pb,\n\t\t\t\t     struct test_xdp_bpf2bpf *ftrace_skel,\n\t\t\t\t     int pkt_size)\n{\n\t__u8 *buf, *buf_in;\n\tint err;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\tif (!ASSERT_LE(pkt_size, BUF_SZ, \"pkt_size\") ||\n\t    !ASSERT_GE(pkt_size, sizeof(pkt_v4), \"pkt_size\"))\n\t\treturn;\n\n\tbuf_in = malloc(BUF_SZ);\n\tif (!ASSERT_OK_PTR(buf_in, \"buf_in malloc()\"))\n\t\treturn;\n\n\tbuf = malloc(BUF_SZ);\n\tif (!ASSERT_OK_PTR(buf, \"buf malloc()\")) {\n\t\tfree(buf_in);\n\t\treturn;\n\t}\n\n\ttest_ctx.passed = false;\n\ttest_ctx.pkt_size = pkt_size;\n\n\tmemcpy(buf_in, &pkt_v4, sizeof(pkt_v4));\n\tif (pkt_size > sizeof(pkt_v4)) {\n\t\tfor (int i = 0; i < (pkt_size - sizeof(pkt_v4)); i++)\n\t\t\tbuf_in[i + sizeof(pkt_v4)] = i;\n\t}\n\n\t \n\ttopts.data_in = buf_in;\n\ttopts.data_size_in = pkt_size;\n\ttopts.data_out = buf;\n\ttopts.data_size_out = BUF_SZ;\n\n\terr = bpf_prog_test_run_opts(pkt_fd, &topts);\n\n\tASSERT_OK(err, \"ipv4\");\n\tASSERT_EQ(topts.retval, XDP_PASS, \"ipv4 retval\");\n\tASSERT_EQ(topts.data_size_out, pkt_size, \"ipv4 size\");\n\n\t \n\terr = perf_buffer__poll(pb, 100);\n\n\tASSERT_GE(err, 0, \"perf_buffer__poll\");\n\tASSERT_TRUE(test_ctx.passed, \"test passed\");\n\t \n\tASSERT_EQ(ftrace_skel->bss->test_result_fentry, if_nametoindex(\"lo\"),\n\t\t  \"fentry result\");\n\tASSERT_EQ(ftrace_skel->bss->test_result_fexit, XDP_PASS, \"fexit result\");\n\n\tfree(buf);\n\tfree(buf_in);\n}\n\nvoid test_xdp_bpf2bpf(void)\n{\n\tint err, pkt_fd, map_fd;\n\tint pkt_sizes[] = {sizeof(pkt_v4), 1024, 4100, 8200};\n\tstruct iptnl_info value4 = {.family = AF_INET6};\n\tstruct test_xdp *pkt_skel = NULL;\n\tstruct test_xdp_bpf2bpf *ftrace_skel = NULL;\n\tstruct vip key4 = {.protocol = 6, .family = AF_INET};\n\tstruct bpf_program *prog;\n\tstruct perf_buffer *pb = NULL;\n\n\t \n\tpkt_skel = test_xdp__open_and_load();\n\tif (!ASSERT_OK_PTR(pkt_skel, \"test_xdp__open_and_load\"))\n\t\treturn;\n\n\tpkt_fd = bpf_program__fd(pkt_skel->progs._xdp_tx_iptunnel);\n\n\tmap_fd = bpf_map__fd(pkt_skel->maps.vip2tnl);\n\tbpf_map_update_elem(map_fd, &key4, &value4, 0);\n\n\t \n\tftrace_skel = test_xdp_bpf2bpf__open();\n\tif (!ASSERT_OK_PTR(ftrace_skel, \"test_xdp_bpf2bpf__open\"))\n\t\tgoto out;\n\n\t \n\tprog = ftrace_skel->progs.trace_on_entry;\n\tbpf_program__set_expected_attach_type(prog, BPF_TRACE_FENTRY);\n\tbpf_program__set_attach_target(prog, pkt_fd, \"_xdp_tx_iptunnel\");\n\n\tprog = ftrace_skel->progs.trace_on_exit;\n\tbpf_program__set_expected_attach_type(prog, BPF_TRACE_FEXIT);\n\tbpf_program__set_attach_target(prog, pkt_fd, \"_xdp_tx_iptunnel\");\n\n\terr = test_xdp_bpf2bpf__load(ftrace_skel);\n\tif (!ASSERT_OK(err, \"test_xdp_bpf2bpf__load\"))\n\t\tgoto out;\n\n\terr = test_xdp_bpf2bpf__attach(ftrace_skel);\n\tif (!ASSERT_OK(err, \"test_xdp_bpf2bpf__attach\"))\n\t\tgoto out;\n\n\t \n\tpb = perf_buffer__new(bpf_map__fd(ftrace_skel->maps.perf_buf_map), 8,\n\t\t\t      on_sample, NULL, &test_ctx, NULL);\n\tif (!ASSERT_OK_PTR(pb, \"perf_buf__new\"))\n\t\tgoto out;\n\n\tfor (int i = 0; i < ARRAY_SIZE(pkt_sizes); i++)\n\t\trun_xdp_bpf2bpf_pkt_size(pkt_fd, pb, ftrace_skel,\n\t\t\t\t\t pkt_sizes[i]);\nout:\n\tperf_buffer__free(pb);\n\ttest_xdp__destroy(pkt_skel);\n\ttest_xdp_bpf2bpf__destroy(ftrace_skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}