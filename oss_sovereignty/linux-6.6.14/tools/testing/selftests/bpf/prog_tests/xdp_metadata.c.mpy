{
  "module_name": "xdp_metadata.c",
  "hash_id": "477922dba8e7da66749739361186ec064951e4bc353cc4a27c41dc9e2b55946d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_metadata.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"xdp_metadata.skel.h\"\n#include \"xdp_metadata2.skel.h\"\n#include \"xdp_metadata.h\"\n#include \"xsk.h\"\n\n#include <bpf/btf.h>\n#include <linux/errqueue.h>\n#include <linux/if_link.h>\n#include <linux/net_tstamp.h>\n#include <linux/udp.h>\n#include <sys/mman.h>\n#include <net/if.h>\n#include <poll.h>\n\n#define TX_NAME \"veTX\"\n#define RX_NAME \"veRX\"\n\n#define UDP_PAYLOAD_BYTES 4\n\n#define AF_XDP_SOURCE_PORT 1234\n#define AF_XDP_CONSUMER_PORT 8080\n\n#define UMEM_NUM 16\n#define UMEM_FRAME_SIZE XSK_UMEM__DEFAULT_FRAME_SIZE\n#define UMEM_SIZE (UMEM_FRAME_SIZE * UMEM_NUM)\n#define XDP_FLAGS XDP_FLAGS_DRV_MODE\n#define QUEUE_ID 0\n\n#define TX_ADDR \"10.0.0.1\"\n#define RX_ADDR \"10.0.0.2\"\n#define PREFIX_LEN \"8\"\n#define FAMILY AF_INET\n\nstruct xsk {\n\tvoid *umem_area;\n\tstruct xsk_umem *umem;\n\tstruct xsk_ring_prod fill;\n\tstruct xsk_ring_cons comp;\n\tstruct xsk_ring_prod tx;\n\tstruct xsk_ring_cons rx;\n\tstruct xsk_socket *socket;\n};\n\nstatic int open_xsk(int ifindex, struct xsk *xsk)\n{\n\tint mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE;\n\tconst struct xsk_socket_config socket_config = {\n\t\t.rx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.tx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.bind_flags = XDP_COPY,\n\t};\n\tconst struct xsk_umem_config umem_config = {\n\t\t.fill_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.comp_size = XSK_RING_CONS__DEFAULT_NUM_DESCS,\n\t\t.frame_size = XSK_UMEM__DEFAULT_FRAME_SIZE,\n\t\t.flags = XDP_UMEM_UNALIGNED_CHUNK_FLAG,\n\t};\n\t__u32 idx;\n\tu64 addr;\n\tint ret;\n\tint i;\n\n\txsk->umem_area = mmap(NULL, UMEM_SIZE, PROT_READ | PROT_WRITE, mmap_flags, -1, 0);\n\tif (!ASSERT_NEQ(xsk->umem_area, MAP_FAILED, \"mmap\"))\n\t\treturn -1;\n\n\tret = xsk_umem__create(&xsk->umem,\n\t\t\t       xsk->umem_area, UMEM_SIZE,\n\t\t\t       &xsk->fill,\n\t\t\t       &xsk->comp,\n\t\t\t       &umem_config);\n\tif (!ASSERT_OK(ret, \"xsk_umem__create\"))\n\t\treturn ret;\n\n\tret = xsk_socket__create(&xsk->socket, ifindex, QUEUE_ID,\n\t\t\t\t xsk->umem,\n\t\t\t\t &xsk->rx,\n\t\t\t\t &xsk->tx,\n\t\t\t\t &socket_config);\n\tif (!ASSERT_OK(ret, \"xsk_socket__create\"))\n\t\treturn ret;\n\n\t \n\n\tfor (i = 0; i < UMEM_NUM / 2; i++) {\n\t\taddr = i * UMEM_FRAME_SIZE;\n\t\tprintf(\"%p: tx_desc[%d] -> %lx\\n\", xsk, i, addr);\n\t}\n\n\t \n\n\tret = xsk_ring_prod__reserve(&xsk->fill, UMEM_NUM / 2, &idx);\n\tif (!ASSERT_EQ(UMEM_NUM / 2, ret, \"xsk_ring_prod__reserve\"))\n\t\treturn ret;\n\tif (!ASSERT_EQ(idx, 0, \"fill idx != 0\"))\n\t\treturn -1;\n\n\tfor (i = 0; i < UMEM_NUM / 2; i++) {\n\t\taddr = (UMEM_NUM / 2 + i) * UMEM_FRAME_SIZE;\n\t\tprintf(\"%p: rx_desc[%d] -> %lx\\n\", xsk, i, addr);\n\t\t*xsk_ring_prod__fill_addr(&xsk->fill, i) = addr;\n\t}\n\txsk_ring_prod__submit(&xsk->fill, ret);\n\n\treturn 0;\n}\n\nstatic void close_xsk(struct xsk *xsk)\n{\n\tif (xsk->umem)\n\t\txsk_umem__delete(xsk->umem);\n\tif (xsk->socket)\n\t\txsk_socket__delete(xsk->socket);\n\tmunmap(xsk->umem_area, UMEM_SIZE);\n}\n\nstatic void ip_csum(struct iphdr *iph)\n{\n\t__u32 sum = 0;\n\t__u16 *p;\n\tint i;\n\n\tiph->check = 0;\n\tp = (void *)iph;\n\tfor (i = 0; i < sizeof(*iph) / sizeof(*p); i++)\n\t\tsum += p[i];\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xffff) + (sum >> 16);\n\n\tiph->check = ~sum;\n}\n\nstatic int generate_packet(struct xsk *xsk, __u16 dst_port)\n{\n\tstruct xdp_desc *tx_desc;\n\tstruct udphdr *udph;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\tvoid *data;\n\t__u32 idx;\n\tint ret;\n\n\tret = xsk_ring_prod__reserve(&xsk->tx, 1, &idx);\n\tif (!ASSERT_EQ(ret, 1, \"xsk_ring_prod__reserve\"))\n\t\treturn -1;\n\n\ttx_desc = xsk_ring_prod__tx_desc(&xsk->tx, idx);\n\ttx_desc->addr = idx % (UMEM_NUM / 2) * UMEM_FRAME_SIZE;\n\tprintf(\"%p: tx_desc[%u]->addr=%llx\\n\", xsk, idx, tx_desc->addr);\n\tdata = xsk_umem__get_data(xsk->umem_area, tx_desc->addr);\n\n\teth = data;\n\tiph = (void *)(eth + 1);\n\tudph = (void *)(iph + 1);\n\n\tmemcpy(eth->h_dest, \"\\x00\\x00\\x00\\x00\\x00\\x02\", ETH_ALEN);\n\tmemcpy(eth->h_source, \"\\x00\\x00\\x00\\x00\\x00\\x01\", ETH_ALEN);\n\teth->h_proto = htons(ETH_P_IP);\n\n\tiph->version = 0x4;\n\tiph->ihl = 0x5;\n\tiph->tos = 0x9;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*udph) + UDP_PAYLOAD_BYTES);\n\tiph->id = 0;\n\tiph->frag_off = 0;\n\tiph->ttl = 0;\n\tiph->protocol = IPPROTO_UDP;\n\tASSERT_EQ(inet_pton(FAMILY, TX_ADDR, &iph->saddr), 1, \"inet_pton(TX_ADDR)\");\n\tASSERT_EQ(inet_pton(FAMILY, RX_ADDR, &iph->daddr), 1, \"inet_pton(RX_ADDR)\");\n\tip_csum(iph);\n\n\tudph->source = htons(AF_XDP_SOURCE_PORT);\n\tudph->dest = htons(dst_port);\n\tudph->len = htons(sizeof(*udph) + UDP_PAYLOAD_BYTES);\n\tudph->check = 0;\n\n\tmemset(udph + 1, 0xAA, UDP_PAYLOAD_BYTES);\n\n\ttx_desc->len = sizeof(*eth) + sizeof(*iph) + sizeof(*udph) + UDP_PAYLOAD_BYTES;\n\txsk_ring_prod__submit(&xsk->tx, 1);\n\n\tret = sendto(xsk_socket__fd(xsk->socket), NULL, 0, MSG_DONTWAIT, NULL, 0);\n\tif (!ASSERT_GE(ret, 0, \"sendto\"))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void complete_tx(struct xsk *xsk)\n{\n\t__u32 idx;\n\t__u64 addr;\n\n\tif (ASSERT_EQ(xsk_ring_cons__peek(&xsk->comp, 1, &idx), 1, \"xsk_ring_cons__peek\")) {\n\t\taddr = *xsk_ring_cons__comp_addr(&xsk->comp, idx);\n\n\t\tprintf(\"%p: complete tx idx=%u addr=%llx\\n\", xsk, idx, addr);\n\t\txsk_ring_cons__release(&xsk->comp, 1);\n\t}\n}\n\nstatic void refill_rx(struct xsk *xsk, __u64 addr)\n{\n\t__u32 idx;\n\n\tif (ASSERT_EQ(xsk_ring_prod__reserve(&xsk->fill, 1, &idx), 1, \"xsk_ring_prod__reserve\")) {\n\t\tprintf(\"%p: complete idx=%u addr=%llx\\n\", xsk, idx, addr);\n\t\t*xsk_ring_prod__fill_addr(&xsk->fill, idx) = addr;\n\t\txsk_ring_prod__submit(&xsk->fill, 1);\n\t}\n}\n\nstatic int verify_xsk_metadata(struct xsk *xsk)\n{\n\tconst struct xdp_desc *rx_desc;\n\tstruct pollfd fds = {};\n\tstruct xdp_meta *meta;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\t__u64 comp_addr;\n\tvoid *data;\n\t__u64 addr;\n\t__u32 idx;\n\tint ret;\n\n\tret = recvfrom(xsk_socket__fd(xsk->socket), NULL, 0, MSG_DONTWAIT, NULL, NULL);\n\tif (!ASSERT_EQ(ret, 0, \"recvfrom\"))\n\t\treturn -1;\n\n\tfds.fd = xsk_socket__fd(xsk->socket);\n\tfds.events = POLLIN;\n\n\tret = poll(&fds, 1, 1000);\n\tif (!ASSERT_GT(ret, 0, \"poll\"))\n\t\treturn -1;\n\n\tret = xsk_ring_cons__peek(&xsk->rx, 1, &idx);\n\tif (!ASSERT_EQ(ret, 1, \"xsk_ring_cons__peek\"))\n\t\treturn -2;\n\n\trx_desc = xsk_ring_cons__rx_desc(&xsk->rx, idx);\n\tcomp_addr = xsk_umem__extract_addr(rx_desc->addr);\n\taddr = xsk_umem__add_offset_to_addr(rx_desc->addr);\n\tprintf(\"%p: rx_desc[%u]->addr=%llx addr=%llx comp_addr=%llx\\n\",\n\t       xsk, idx, rx_desc->addr, addr, comp_addr);\n\tdata = xsk_umem__get_data(xsk->umem_area, addr);\n\n\t \n\n\teth = data;\n\tASSERT_EQ(eth->h_proto, htons(ETH_P_IP), \"eth->h_proto\");\n\tiph = (void *)(eth + 1);\n\tASSERT_EQ((int)iph->version, 4, \"iph->version\");\n\n\t \n\n\tmeta = data - sizeof(struct xdp_meta);\n\n\tif (!ASSERT_NEQ(meta->rx_timestamp, 0, \"rx_timestamp\"))\n\t\treturn -1;\n\n\tif (!ASSERT_NEQ(meta->rx_hash, 0, \"rx_hash\"))\n\t\treturn -1;\n\n\tASSERT_EQ(meta->rx_hash_type, 0, \"rx_hash_type\");\n\n\txsk_ring_cons__release(&xsk->rx, 1);\n\trefill_rx(xsk, comp_addr);\n\n\treturn 0;\n}\n\nvoid test_xdp_metadata(void)\n{\n\tstruct xdp_metadata2 *bpf_obj2 = NULL;\n\tstruct xdp_metadata *bpf_obj = NULL;\n\tstruct bpf_program *new_prog, *prog;\n\tstruct nstoken *tok = NULL;\n\t__u32 queue_id = QUEUE_ID;\n\tstruct bpf_map *prog_arr;\n\tstruct xsk tx_xsk = {};\n\tstruct xsk rx_xsk = {};\n\t__u32 val, key = 0;\n\tint retries = 10;\n\tint rx_ifindex;\n\tint tx_ifindex;\n\tint sock_fd;\n\tint ret;\n\n\t \n\n\tSYS(out, \"ip netns add xdp_metadata\");\n\ttok = open_netns(\"xdp_metadata\");\n\tSYS(out, \"ip link add numtxqueues 1 numrxqueues 1 \" TX_NAME\n\t    \" type veth peer \" RX_NAME \" numtxqueues 1 numrxqueues 1\");\n\tSYS(out, \"ip link set dev \" TX_NAME \" address 00:00:00:00:00:01\");\n\tSYS(out, \"ip link set dev \" RX_NAME \" address 00:00:00:00:00:02\");\n\tSYS(out, \"ip link set dev \" TX_NAME \" up\");\n\tSYS(out, \"ip link set dev \" RX_NAME \" up\");\n\tSYS(out, \"ip addr add \" TX_ADDR \"/\" PREFIX_LEN \" dev \" TX_NAME);\n\tSYS(out, \"ip addr add \" RX_ADDR \"/\" PREFIX_LEN \" dev \" RX_NAME);\n\n\trx_ifindex = if_nametoindex(RX_NAME);\n\ttx_ifindex = if_nametoindex(TX_NAME);\n\n\t \n\n\tret = open_xsk(tx_ifindex, &tx_xsk);\n\tif (!ASSERT_OK(ret, \"open_xsk(TX_NAME)\"))\n\t\tgoto out;\n\n\tret = open_xsk(rx_ifindex, &rx_xsk);\n\tif (!ASSERT_OK(ret, \"open_xsk(RX_NAME)\"))\n\t\tgoto out;\n\n\tbpf_obj = xdp_metadata__open();\n\tif (!ASSERT_OK_PTR(bpf_obj, \"open skeleton\"))\n\t\tgoto out;\n\n\tprog = bpf_object__find_program_by_name(bpf_obj->obj, \"rx\");\n\tbpf_program__set_ifindex(prog, rx_ifindex);\n\tbpf_program__set_flags(prog, BPF_F_XDP_DEV_BOUND_ONLY);\n\n\tif (!ASSERT_OK(xdp_metadata__load(bpf_obj), \"load skeleton\"))\n\t\tgoto out;\n\n\t \n\tprog_arr = bpf_object__find_map_by_name(bpf_obj->obj, \"prog_arr\");\n\tif (!ASSERT_OK_PTR(prog_arr, \"no prog_arr map\"))\n\t\tgoto out;\n\n\tval = bpf_program__fd(prog);\n\tif (!ASSERT_ERR(bpf_map__update_elem(prog_arr, &key, sizeof(key),\n\t\t\t\t\t     &val, sizeof(val), BPF_ANY),\n\t\t\t\"update prog_arr\"))\n\t\tgoto out;\n\n\t \n\n\tret = bpf_xdp_attach(rx_ifindex,\n\t\t\t     bpf_program__fd(bpf_obj->progs.rx),\n\t\t\t     XDP_FLAGS, NULL);\n\tif (!ASSERT_GE(ret, 0, \"bpf_xdp_attach\"))\n\t\tgoto out;\n\n\tsock_fd = xsk_socket__fd(rx_xsk.socket);\n\tret = bpf_map_update_elem(bpf_map__fd(bpf_obj->maps.xsk), &queue_id, &sock_fd, 0);\n\tif (!ASSERT_GE(ret, 0, \"bpf_map_update_elem\"))\n\t\tgoto out;\n\n\t \n\tif (!ASSERT_GE(generate_packet(&tx_xsk, AF_XDP_CONSUMER_PORT), 0,\n\t\t       \"generate AF_XDP_CONSUMER_PORT\"))\n\t\tgoto out;\n\n\t \n\tif (!ASSERT_GE(verify_xsk_metadata(&rx_xsk), 0,\n\t\t       \"verify_xsk_metadata\"))\n\t\tgoto out;\n\n\tcomplete_tx(&tx_xsk);\n\n\t \n\n\tbpf_obj2 = xdp_metadata2__open();\n\tif (!ASSERT_OK_PTR(bpf_obj2, \"open skeleton\"))\n\t\tgoto out;\n\n\tnew_prog = bpf_object__find_program_by_name(bpf_obj2->obj, \"freplace_rx\");\n\tbpf_program__set_attach_target(new_prog, bpf_program__fd(prog), \"rx\");\n\n\tif (!ASSERT_OK(xdp_metadata2__load(bpf_obj2), \"load freplace skeleton\"))\n\t\tgoto out;\n\n\tif (!ASSERT_OK(xdp_metadata2__attach(bpf_obj2), \"attach freplace\"))\n\t\tgoto out;\n\n\t \n\tif (!ASSERT_GE(generate_packet(&tx_xsk, AF_XDP_CONSUMER_PORT), 0,\n\t\t       \"generate freplace packet\"))\n\t\tgoto out;\n\n\twhile (!retries--) {\n\t\tif (bpf_obj2->bss->called)\n\t\t\tbreak;\n\t\tusleep(10);\n\t}\n\tASSERT_GT(bpf_obj2->bss->called, 0, \"not called\");\n\nout:\n\tclose_xsk(&rx_xsk);\n\tclose_xsk(&tx_xsk);\n\txdp_metadata2__destroy(bpf_obj2);\n\txdp_metadata__destroy(bpf_obj);\n\tif (tok)\n\t\tclose_netns(tok);\n\tSYS_NOFAIL(\"ip netns del xdp_metadata\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}