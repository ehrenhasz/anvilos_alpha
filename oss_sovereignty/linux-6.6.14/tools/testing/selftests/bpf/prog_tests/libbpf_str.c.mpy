{
  "module_name": "libbpf_str.c",
  "hash_id": "04f8bc8eadf9b442c68e71ae718353cb0fceef35738cda238d92f4d177f3de8a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/libbpf_str.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <test_progs.h>\n#include <bpf/btf.h>\n\n \nstatic void uppercase(char *s)\n{\n\tfor (; *s != '\\0'; s++)\n\t\t*s = toupper(*s);\n}\n\n \nstatic void test_libbpf_bpf_attach_type_str(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_attach_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_attach_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\te = btf_enum(t);\n\tn = btf_vlen(t);\n\tfor (i = 0; i < n; e++, i++) {\n\t\tenum bpf_attach_type attach_type = (enum bpf_attach_type)e->val;\n\t\tconst char *attach_type_name;\n\t\tconst char *attach_type_str;\n\t\tchar buf[256];\n\n\t\tif (attach_type == __MAX_BPF_ATTACH_TYPE)\n\t\t\tcontinue;\n\n\t\tattach_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tattach_type_str = libbpf_bpf_attach_type_str(attach_type);\n\t\tASSERT_OK_PTR(attach_type_str, attach_type_name);\n\n\t\tsnprintf(buf, sizeof(buf), \"BPF_%s\", attach_type_str);\n\t\tuppercase(buf);\n\n\t\tASSERT_STREQ(buf, attach_type_name, \"exp_str_value\");\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\n \nstatic void test_libbpf_bpf_link_type_str(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_link_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_link_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\te = btf_enum(t);\n\tn = btf_vlen(t);\n\tfor (i = 0; i < n; e++, i++) {\n\t\tenum bpf_link_type link_type = (enum bpf_link_type)e->val;\n\t\tconst char *link_type_name;\n\t\tconst char *link_type_str;\n\t\tchar buf[256];\n\n\t\tif (link_type == MAX_BPF_LINK_TYPE)\n\t\t\tcontinue;\n\n\t\tlink_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tlink_type_str = libbpf_bpf_link_type_str(link_type);\n\t\tASSERT_OK_PTR(link_type_str, link_type_name);\n\n\t\tsnprintf(buf, sizeof(buf), \"BPF_LINK_TYPE_%s\", link_type_str);\n\t\tuppercase(buf);\n\n\t\tASSERT_STREQ(buf, link_type_name, \"exp_str_value\");\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\n \nstatic void test_libbpf_bpf_map_type_str(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_map_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_map_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\te = btf_enum(t);\n\tn = btf_vlen(t);\n\tfor (i = 0; i < n; e++, i++) {\n\t\tenum bpf_map_type map_type = (enum bpf_map_type)e->val;\n\t\tconst char *map_type_name;\n\t\tconst char *map_type_str;\n\t\tchar buf[256];\n\n\t\tmap_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tmap_type_str = libbpf_bpf_map_type_str(map_type);\n\t\tASSERT_OK_PTR(map_type_str, map_type_name);\n\n\t\tsnprintf(buf, sizeof(buf), \"BPF_MAP_TYPE_%s\", map_type_str);\n\t\tuppercase(buf);\n\n\t\t \n\t\tif (strcmp(map_type_name, \"BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED\") == 0)\n\t\t\tcontinue;\n\n\t\tASSERT_STREQ(buf, map_type_name, \"exp_str_value\");\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\n \nstatic void test_libbpf_bpf_prog_type_str(void)\n{\n\tstruct btf *btf;\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tint i, n, id;\n\n\tbtf = btf__parse(\"/sys/kernel/btf/vmlinux\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"btf_parse\"))\n\t\treturn;\n\n\t \n\tid = btf__find_by_name_kind(btf, \"bpf_prog_type\", BTF_KIND_ENUM);\n\tif (!ASSERT_GT(id, 0, \"bpf_prog_type_id\"))\n\t\tgoto cleanup;\n\tt = btf__type_by_id(btf, id);\n\te = btf_enum(t);\n\tn = btf_vlen(t);\n\tfor (i = 0; i < n; e++, i++) {\n\t\tenum bpf_prog_type prog_type = (enum bpf_prog_type)e->val;\n\t\tconst char *prog_type_name;\n\t\tconst char *prog_type_str;\n\t\tchar buf[256];\n\n\t\tprog_type_name = btf__str_by_offset(btf, e->name_off);\n\t\tprog_type_str = libbpf_bpf_prog_type_str(prog_type);\n\t\tASSERT_OK_PTR(prog_type_str, prog_type_name);\n\n\t\tsnprintf(buf, sizeof(buf), \"BPF_PROG_TYPE_%s\", prog_type_str);\n\t\tuppercase(buf);\n\n\t\tASSERT_STREQ(buf, prog_type_name, \"exp_str_value\");\n\t}\n\ncleanup:\n\tbtf__free(btf);\n}\n\n \nvoid test_libbpf_str(void)\n{\n\tif (test__start_subtest(\"bpf_attach_type_str\"))\n\t\ttest_libbpf_bpf_attach_type_str();\n\n\tif (test__start_subtest(\"bpf_link_type_str\"))\n\t\ttest_libbpf_bpf_link_type_str();\n\n\tif (test__start_subtest(\"bpf_map_type_str\"))\n\t\ttest_libbpf_bpf_map_type_str();\n\n\tif (test__start_subtest(\"bpf_prog_type_str\"))\n\t\ttest_libbpf_bpf_prog_type_str();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}