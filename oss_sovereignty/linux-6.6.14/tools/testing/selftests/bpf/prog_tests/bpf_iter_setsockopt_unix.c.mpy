{
  "module_name": "bpf_iter_setsockopt_unix.c",
  "hash_id": "8f989ada0f2aed26593c8ce82bd4d55e83ffbef19f5e83f43b566bb4f4895431",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_iter_setsockopt_unix.c",
  "human_readable_source": "\n \n#include <sys/socket.h>\n#include <sys/un.h>\n#include <test_progs.h>\n#include \"bpf_iter_setsockopt_unix.skel.h\"\n\n#define NR_CASES 5\n\nstatic int create_unix_socket(struct bpf_iter_setsockopt_unix *skel)\n{\n\tstruct sockaddr_un addr = {\n\t\t.sun_family = AF_UNIX,\n\t\t.sun_path = \"\",\n\t};\n\tsocklen_t len;\n\tint fd, err;\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (!ASSERT_NEQ(fd, -1, \"socket\"))\n\t\treturn -1;\n\n\tlen = offsetof(struct sockaddr_un, sun_path);\n\terr = bind(fd, (struct sockaddr *)&addr, len);\n\tif (!ASSERT_OK(err, \"bind\"))\n\t\treturn -1;\n\n\tlen = sizeof(addr);\n\terr = getsockname(fd, (struct sockaddr *)&addr, &len);\n\tif (!ASSERT_OK(err, \"getsockname\"))\n\t\treturn -1;\n\n\tmemcpy(&skel->bss->sun_path, &addr.sun_path,\n\t       len - offsetof(struct sockaddr_un, sun_path));\n\n\treturn fd;\n}\n\nstatic void test_sndbuf(struct bpf_iter_setsockopt_unix *skel, int fd)\n{\n\tsocklen_t optlen;\n\tint i, err;\n\n\tfor (i = 0; i < NR_CASES; i++) {\n\t\tif (!ASSERT_NEQ(skel->data->sndbuf_getsockopt[i], -1,\n\t\t\t\t\"bpf_(get|set)sockopt\"))\n\t\t\treturn;\n\n\t\terr = setsockopt(fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t\t &(skel->data->sndbuf_setsockopt[i]),\n\t\t\t\t sizeof(skel->data->sndbuf_setsockopt[i]));\n\t\tif (!ASSERT_OK(err, \"setsockopt\"))\n\t\t\treturn;\n\n\t\toptlen = sizeof(skel->bss->sndbuf_getsockopt_expected[i]);\n\t\terr = getsockopt(fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t\t &(skel->bss->sndbuf_getsockopt_expected[i]),\n\t\t\t\t &optlen);\n\t\tif (!ASSERT_OK(err, \"getsockopt\"))\n\t\t\treturn;\n\n\t\tif (!ASSERT_EQ(skel->data->sndbuf_getsockopt[i],\n\t\t\t       skel->bss->sndbuf_getsockopt_expected[i],\n\t\t\t       \"bpf_(get|set)sockopt\"))\n\t\t\treturn;\n\t}\n}\n\nvoid test_bpf_iter_setsockopt_unix(void)\n{\n\tstruct bpf_iter_setsockopt_unix *skel;\n\tint err, unix_fd, iter_fd;\n\tchar buf;\n\n\tskel = bpf_iter_setsockopt_unix__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\tunix_fd = create_unix_socket(skel);\n\tif (!ASSERT_NEQ(unix_fd, -1, \"create_unix_server\"))\n\t\tgoto destroy;\n\n\tskel->links.change_sndbuf = bpf_program__attach_iter(skel->progs.change_sndbuf, NULL);\n\tif (!ASSERT_OK_PTR(skel->links.change_sndbuf, \"bpf_program__attach_iter\"))\n\t\tgoto destroy;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(skel->links.change_sndbuf));\n\tif (!ASSERT_GE(iter_fd, 0, \"bpf_iter_create\"))\n\t\tgoto destroy;\n\n\twhile ((err = read(iter_fd, &buf, sizeof(buf))) == -1 &&\n\t       errno == EAGAIN)\n\t\t;\n\tif (!ASSERT_OK(err, \"read iter error\"))\n\t\tgoto destroy;\n\n\ttest_sndbuf(skel, unix_fd);\ndestroy:\n\tbpf_iter_setsockopt_unix__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}