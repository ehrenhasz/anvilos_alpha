{
  "module_name": "htab_reuse.c",
  "hash_id": "f93b3eeef3b02c525a00ccb56f4f0463708dd726eea38c9c087acc699649e6c3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/htab_reuse.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdbool.h>\n#include <test_progs.h>\n#include \"htab_reuse.skel.h\"\n\nstruct htab_op_ctx {\n\tint fd;\n\tint loop;\n\tbool stop;\n};\n\nstruct htab_val {\n\tunsigned int lock;\n\tunsigned int data;\n};\n\nstatic void *htab_lookup_fn(void *arg)\n{\n\tstruct htab_op_ctx *ctx = arg;\n\tint i = 0;\n\n\twhile (i++ < ctx->loop && !ctx->stop) {\n\t\tstruct htab_val value;\n\t\tunsigned int key;\n\n\t\t \n\t\tkey = 7;\n\t\tbpf_map_lookup_elem_flags(ctx->fd, &key, &value, BPF_F_LOCK);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *htab_update_fn(void *arg)\n{\n\tstruct htab_op_ctx *ctx = arg;\n\tint i = 0;\n\n\twhile (i++ < ctx->loop && !ctx->stop) {\n\t\tstruct htab_val value;\n\t\tunsigned int key;\n\n\t\tkey = 7;\n\t\tvalue.lock = 0;\n\t\tvalue.data = key;\n\t\tbpf_map_update_elem(ctx->fd, &key, &value, BPF_F_LOCK);\n\t\tbpf_map_delete_elem(ctx->fd, &key);\n\n\t\tkey = 24;\n\t\tvalue.lock = 0;\n\t\tvalue.data = key;\n\t\tbpf_map_update_elem(ctx->fd, &key, &value, BPF_F_LOCK);\n\t\tbpf_map_delete_elem(ctx->fd, &key);\n\t}\n\n\treturn NULL;\n}\n\nvoid test_htab_reuse(void)\n{\n\tunsigned int i, wr_nr = 1, rd_nr = 4;\n\tpthread_t tids[wr_nr + rd_nr];\n\tstruct htab_reuse *skel;\n\tstruct htab_op_ctx ctx;\n\tint err;\n\n\tskel = htab_reuse__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"htab_reuse__open_and_load\"))\n\t\treturn;\n\n\tctx.fd = bpf_map__fd(skel->maps.htab);\n\tctx.loop = 500;\n\tctx.stop = false;\n\n\tmemset(tids, 0, sizeof(tids));\n\tfor (i = 0; i < wr_nr; i++) {\n\t\terr = pthread_create(&tids[i], NULL, htab_update_fn, &ctx);\n\t\tif (!ASSERT_OK(err, \"pthread_create\")) {\n\t\t\tctx.stop = true;\n\t\t\tgoto reap;\n\t\t}\n\t}\n\tfor (i = 0; i < rd_nr; i++) {\n\t\terr = pthread_create(&tids[i + wr_nr], NULL, htab_lookup_fn, &ctx);\n\t\tif (!ASSERT_OK(err, \"pthread_create\")) {\n\t\t\tctx.stop = true;\n\t\t\tgoto reap;\n\t\t}\n\t}\n\nreap:\n\tfor (i = 0; i < wr_nr + rd_nr; i++) {\n\t\tif (!tids[i])\n\t\t\tcontinue;\n\t\tpthread_join(tids[i], NULL);\n\t}\n\thtab_reuse__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}