{
  "module_name": "btf.c",
  "hash_id": "01ec1caf8380dc3fc3af73e4d0893550e228da6fbfb0926ae80446132b5aa8a9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf.c",
  "human_readable_source": " \n \n\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/unistd.h>\n#include <bpf/bpf.h>\n#include <libelf.h>\n#include <gelf.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <assert.h>\n#include <bpf/libbpf.h>\n#include <bpf/btf.h>\n\n#include \"bpf_util.h\"\n#include \"../test_btf.h\"\n#include \"test_progs.h\"\n\n#define MAX_INSNS\t512\n#define MAX_SUBPROGS\t16\n\nstatic int duration = 0;\nstatic bool always_log;\n\n#undef CHECK\n#define CHECK(condition, format...) _CHECK(condition, \"check\", duration, format)\n\n#define NAME_TBD 0xdeadb33f\n\n#define NAME_NTH(N) (0xfffe0000 | N)\n#define IS_NAME_NTH(X) ((X & 0xffff0000) == 0xfffe0000)\n#define GET_NAME_NTH_IDX(X) (X & 0x0000ffff)\n\n#define MAX_NR_RAW_U32 1024\n#define BTF_LOG_BUF_SIZE 65535\n\nstatic char btf_log_buf[BTF_LOG_BUF_SIZE];\n\nstatic struct btf_header hdr_tmpl = {\n\t.magic = BTF_MAGIC,\n\t.version = BTF_VERSION,\n\t.hdr_len = sizeof(struct btf_header),\n};\n\n \nenum pprint_mapv_kind_t {\n\tPPRINT_MAPV_KIND_BASIC = 0,\n\tPPRINT_MAPV_KIND_INT128,\n};\n\nstruct btf_raw_test {\n\tconst char *descr;\n\tconst char *str_sec;\n\tconst char *map_name;\n\tconst char *err_str;\n\t__u32 raw_types[MAX_NR_RAW_U32];\n\t__u32 str_sec_size;\n\tenum bpf_map_type map_type;\n\t__u32 key_size;\n\t__u32 value_size;\n\t__u32 key_type_id;\n\t__u32 value_type_id;\n\t__u32 max_entries;\n\tbool btf_load_err;\n\tbool map_create_err;\n\tbool ordered_map;\n\tbool lossless_map;\n\tbool percpu_map;\n\tint hdr_len_delta;\n\tint type_off_delta;\n\tint str_off_delta;\n\tint str_len_delta;\n\tenum pprint_mapv_kind_t mapv_kind;\n};\n\n#define BTF_STR_SEC(str) \\\n\t.str_sec = str, .str_sec_size = sizeof(str)\n\nstatic struct btf_raw_test raw_tests[] = {\n \n{\n\t.descr = \"struct test #1\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 6), 180),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 384), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 7, 1408),  \n\t\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(4, 1, 4),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 2), sizeof(int)),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0q\\0r\\0E\\0E0\\0E1\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0q\\0r\\0E\\0E0\\0E1\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_test1_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 180,\n\t.key_type_id = 1,\n\t.value_type_id = 5,\n\t.max_entries = 4,\n},\n\n \n{\n\t.descr = \"struct test #2\",\n\t.raw_types = {\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(4, 1, 4),\n\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 3), 68),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 8, 288), \n\t\t \n\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32), \n\t\t \n\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 1),\n\t\t \t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0), 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 6),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(7, 1, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0B\\0m\\0n\\0Struct_B\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0B\\0m\\0n\\0Struct_B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_test2_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 68,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n},\n{\n\t.descr = \"struct test #3 Invalid member offset\",\n\t.raw_types = {\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 64, 8),\n\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 16),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t\t \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_test3_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 16,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member bits_offset\",\n},\n \n{\n\t.descr = \"global data test #1\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_test1_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 1,\n\t.value_type_id = 5,\n\t.max_entries = 4,\n},\n \n{\n\t.descr = \"global data test #2\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 48),\n\t\tBTF_VAR_SECINFO_ENC(6, 0, 48),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 0,\n\t.value_type_id = 7,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"global data test #3\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"global data test #4, unsupported linkage\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 2),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Linkage not supported\",\n},\n{\n\t.descr = \"global data test #5, invalid var type\",\n\t.raw_types = {\n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 0, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(1, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #6, invalid var type (fwd type)\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_FWD, 1, 0), 0),  \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type\",\n},\n{\n\t.descr = \"global data test #7, invalid var type (fwd type)\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_FWD, 1, 0), 0),  \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(1, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type\",\n},\n{\n\t.descr = \"global data test #8, invalid var size\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 48),\n\t\tBTF_VAR_SECINFO_ENC(6, 0, 47),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 0,\n\t.value_type_id = 7,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid size\",\n},\n{\n\t.descr = \"global data test #9, invalid var size\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 46),\n\t\tBTF_VAR_SECINFO_ENC(6, 0, 48),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 0,\n\t.value_type_id = 7,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid size\",\n},\n{\n\t.descr = \"global data test #10, invalid var size\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 46),\n\t\tBTF_VAR_SECINFO_ENC(6, 0, 46),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 0,\n\t.value_type_id = 7,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid size\",\n},\n{\n\t.descr = \"global data test #11, multiple section members\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 2), 62),\n\t\tBTF_VAR_SECINFO_ENC(6, 10, 48),\n\t\tBTF_VAR_SECINFO_ENC(7, 58, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 62,\n\t.key_type_id = 0,\n\t.value_type_id = 8,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"global data test #12, invalid offset\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 2), 62),\n\t\tBTF_VAR_SECINFO_ENC(6, 10, 48),\n\t\tBTF_VAR_SECINFO_ENC(7, 60, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 62,\n\t.key_type_id = 0,\n\t.value_type_id = 8,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid offset+size\",\n},\n{\n\t.descr = \"global data test #13, invalid offset\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 2), 62),\n\t\tBTF_VAR_SECINFO_ENC(6, 10, 48),\n\t\tBTF_VAR_SECINFO_ENC(7, 12, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 62,\n\t.key_type_id = 0,\n\t.value_type_id = 8,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid offset\",\n},\n{\n\t.descr = \"global data test #14, invalid offset\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),\t\t \n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 8),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 4), 48),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 64), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 96), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 128), \n\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 2), 62),\n\t\tBTF_VAR_SECINFO_ENC(7, 58, 4),\n\t\tBTF_VAR_SECINFO_ENC(6, 10, 48),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\\0o\\0p\\0t\\0u\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 62,\n\t.key_type_id = 0,\n\t.value_type_id = 8,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid offset\",\n},\n{\n\t.descr = \"global data test #15, not var kind\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(1, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0.bss\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0.bss\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Not a VAR kind member\",\n},\n{\n\t.descr = \"global data test #16, invalid var referencing sec\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 2, 0),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(3, 0, 4),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(6, 0, 4),\n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #17, invalid var referencing var\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 2, 0),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(3, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #18, invalid var loop\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 2, 0),\t\t\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0aaa\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0aaa\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #19, invalid var referencing var\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 3, 0),\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #20, invalid ptr referencing var\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 3),\n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"global data test #21, var included in struct\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), sizeof(int) * 2),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 32), \n\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member\",\n},\n{\n\t.descr = \"global data test #22, array of var\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 4),\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0t\\0s\\0a\\0a\",\n\t.str_sec_size = sizeof(\"\\0A\\0t\\0s\\0a\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 0,\n\t.value_type_id = 4,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid elem\",\n},\n{\n\t.descr = \"var after datasec, ptr followed by modifier\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 2),\n\t\t\tsizeof(void*)+4),\n\t\tBTF_VAR_SECINFO_ENC(4, 0, sizeof(void*)),\n\t\tBTF_VAR_SECINFO_ENC(6, sizeof(void*), 4),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 2),\n\t\tBTF_VAR_ENC(NAME_TBD, 3, 0),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 2),\n\t\tBTF_VAR_ENC(NAME_TBD, 5, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\\0c\\0\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\\0c\\0\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \".bss\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void*)+4,\n\t.key_type_id = 0,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n \n{\n\t.descr = \"size check test #1\",\n\t.raw_types = {\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), sizeof(int) * 2 -  1),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"size_check1_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 1,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n \n{\n\t.descr = \"size check test #2\",\n\t.raw_types = {\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, sizeof(int)),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 2),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), sizeof(int) * 3 - 1),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"size_check2_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 1,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n \n{\n\t.descr = \"size check test #3\",\n\t.raw_types = {\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, sizeof(int)),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 0),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), sizeof(int) + sizeof(void *) - 1),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0n\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"size_check3_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 1,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n \n{\n\t.descr = \"size check test #4\",\n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, sizeof(int)),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 2), sizeof(int)),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\t \n\t\t \t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), sizeof(int) * 2 - 1),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0E\\0E0\\0E1\\0A\\0m\\0n\",\n\t.str_sec_size = sizeof(\"\\0E\\0E0\\0E1\\0A\\0m\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"size_check4_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 1,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n \n{\n\t.descr = \"size check test #5\",\n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, sizeof(int)),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 8, 1),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 2), 1),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\t \n\t\t \t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 2),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 8), \n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0E\\0E0\\0E1\\0A\\0m\\0n\",\n\t.str_sec_size = sizeof(\"\\0E\\0E0\\0E1\\0A\\0m\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"size_check5_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 2,\n\t.key_type_id = 1,\n\t.value_type_id = 4,\n\t.max_entries = 4,\n},\n\n \n{\n\t.descr = \"void test #1\",\n\t.raw_types = {\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 2),\n\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\t \n\t\t \t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), sizeof(void *)),\n\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 0),\n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0const_void_ptr\\0A\\0m\",\n\t.str_sec_size = sizeof(\"\\0const_void_ptr\\0A\\0m\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"void_test1_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *),\n\t.key_type_id = 1,\n\t.value_type_id = 4,\n\t.max_entries = 4,\n},\n\n \n{\n\t.descr = \"void test #2\",\n\t.raw_types = {\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\t \t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 8),\n\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"void_test2_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *),\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member\",\n},\n\n \n{\n\t.descr = \"void test #3\",\n\t.raw_types = {\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 2),\n\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(4, 1, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0const_void_ptr\",\n\t.str_sec_size = sizeof(\"\\0const_void_ptr\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"void_test3_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *) * 4,\n\t.key_type_id = 1,\n\t.value_type_id = 5,\n\t.max_entries = 4,\n},\n\n \n{\n\t.descr = \"void test #4\",\n\t.raw_types = {\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\t \t \n\t\tBTF_TYPE_ARRAY_ENC(2, 1, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"void_test4_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *) * 4,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid elem\",\n},\n\n \n{\n\t.descr = \"loop test #1\",\n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 8),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(2, 1, 8),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test1_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(sizeof(int) * 8),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n \n{\n\t.descr = \"loop test #2\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPEDEF_ENC(1, 4),\t\t\t\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(2, 1, 8),\t\t\t \n\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 8),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int_array\\0\",\n\t.str_sec_size = sizeof(\"\\0int_array\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test2_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(sizeof(int) * 8),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n \n{\n\t.descr = \"loop test #3\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 8),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(2, 1, 8),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test3_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(sizeof(int) * 8),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n \n{\n\t.descr = \"loop test #4\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 8),\n\t\t \t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(2, 1, 8),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int_array\\0\",\n\t.str_sec_size = sizeof(\"\\0int_array\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test4_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(sizeof(int) * 8),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n \n{\n\t.descr = \"loop test #5\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 32), \n\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0x\\0y\\0Struct_B\\0B\\0x\\0y\",\n\t.str_sec_size = sizeof(\"\\0A\\0x\\0y\\0Struct_B\\0B\\0x\\0y\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test5_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n \n{\n\t.descr = \"loop test #6\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 4),\t\t\t \n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 32), \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0x\\0y\",\n\t.str_sec_size = sizeof(\"\\0A\\0x\\0y\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test6_map\",\n\t.key_size = sizeof(int),\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n{\n\t.descr = \"loop test #7\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), sizeof(void *)),\n\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 0),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 4),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 3),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test7_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n{\n\t.descr = \"loop test #8\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), sizeof(void *)),\n\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 0),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), sizeof(void *)),\n\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 0),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 5),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 6),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 7),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0m\\0B\\0n\",\n\t.str_sec_size = sizeof(\"\\0A\\0m\\0B\\0n\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"loop_test8_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(void *),\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Loop detected\",\n},\n\n{\n\t.descr = \"string section does not end with null\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\") - 1,\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid string section\",\n},\n\n{\n\t.descr = \"empty string section\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = 0,\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid string section\",\n},\n\n{\n\t.descr = \"empty type section\",\n\t.raw_types = {\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"No type found\",\n},\n\n{\n\t.descr = \"btf_header test. Longer hdr_len\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.hdr_len_delta = 4,\n\t.err_str = \"Unsupported btf_header\",\n},\n\n{\n\t.descr = \"btf_header test. Gap between hdr and type\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.type_off_delta = 4,\n\t.err_str = \"Unsupported section found\",\n},\n\n{\n\t.descr = \"btf_header test. Gap between type and str\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.str_off_delta = 4,\n\t.err_str = \"Unsupported section found\",\n},\n\n{\n\t.descr = \"btf_header test. Overlap between type and str\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.str_off_delta = -4,\n\t.err_str = \"Section overlap found\",\n},\n\n{\n\t.descr = \"btf_header test. Larger BTF size\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.str_len_delta = -4,\n\t.err_str = \"Unsupported section found\",\n},\n\n{\n\t.descr = \"btf_header test. Smaller BTF size\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\",\n\t.str_sec_size = sizeof(\"\\0int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"hdr_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.str_len_delta = 4,\n\t.err_str = \"Total section length too long\",\n},\n\n{\n\t.descr = \"array test. index_type/elem_type \\\"int\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 16),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"array test. index_type/elem_type \\\"const int\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 3, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 1),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"array test. index_type \\\"const int:31\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 31, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 4, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid index\",\n},\n\n{\n\t.descr = \"array test. elem_type \\\"const int:31\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 31, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(4, 1, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid array of int\",\n},\n\n{\n\t.descr = \"array test. index_type \\\"void\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 0, 16),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid index\",\n},\n\n{\n\t.descr = \"array test. index_type \\\"const void\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 3, 16),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid index\",\n},\n\n{\n\t.descr = \"array test. elem_type \\\"const void\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 16),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid elem\",\n},\n\n{\n\t.descr = \"array test. elem_type \\\"const void *\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 1, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"array test. index_type \\\"const void *\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(3, 3, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid index\",\n},\n\n{\n\t.descr = \"array test. t->size != 0\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ARRAY, 0, 0), 1),\n\t\tBTF_ARRAY_ENC(1, 1, 16),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"size != 0\",\n},\n\n{\n\t.descr = \"int test. invalid int_data\",\n\t.raw_types = {\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_INT, 0, 0), 4),\n\t\t0x10000000,\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid int_data\",\n},\n\n{\n\t.descr = \"invalid BTF_INFO\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_TYPE_ENC(0, 0x20000000, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info\",\n},\n\n{\n\t.descr = \"fwd test. t->type != 0\\\"\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FWD, 0, 0), 1),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"fwd_test_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"type != 0\",\n},\n\n{\n\t.descr = \"typedef (invalid name, name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPEDEF_ENC(0, 1),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__int\",\n\t.str_sec_size = sizeof(\"\\0__int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"typedef_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"typedef (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__!int\",\n\t.str_sec_size = sizeof(\"\\0__!int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"typedef_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"ptr type (invalid name, name_off <> 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__int\",\n\t.str_sec_size = sizeof(\"\\0__int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"ptr_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"volatile type (invalid name, name_off <> 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_VOLATILE, 0, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__int\",\n\t.str_sec_size = sizeof(\"\\0__int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"volatile_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"const type (invalid name, name_off <> 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__int\",\n\t.str_sec_size = sizeof(\"\\0__int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"const_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"restrict type (invalid name, name_off <> 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 1),\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_RESTRICT, 0, 0), 2),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__int\",\n\t.str_sec_size = sizeof(\"\\0__int\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"restrict_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"fwd type (invalid name, name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FWD, 0, 0), 0),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__skb\",\n\t.str_sec_size = sizeof(\"\\0__skb\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"fwd_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"fwd type (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_FWD, 0, 0), 0),\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__!skb\",\n\t.str_sec_size = sizeof(\"\\0__!skb\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"fwd_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"array type (invalid name, name_off <> 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_ARRAY, 0, 0), 0),\t \n\t\tBTF_ARRAY_ENC(1, 1, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0__skb\",\n\t.str_sec_size = sizeof(\"\\0__skb\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"struct type (name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\",\n\t.str_sec_size = sizeof(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct type (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A!\\0B\",\n\t.str_sec_size = sizeof(\"\\0A!\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"struct member (name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\",\n\t.str_sec_size = sizeof(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct member (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0B*\",\n\t.str_sec_size = sizeof(\"\\0A\\0B*\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"enum type (name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1),\n\t\t\t     sizeof(int)),\t\t\t\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A\\0B\",\n\t.str_sec_size = sizeof(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"enum_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"enum type (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1),\n\t\t\t     sizeof(int)),\t\t\t\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A!\\0B\",\n\t.str_sec_size = sizeof(\"\\0A!\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"enum_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"enum member (invalid name, name_off = 0)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1),\n\t\t\t     sizeof(int)),\t\t\t\t \n\t\tBTF_ENUM_ENC(0, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"enum_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"enum member (invalid name, invalid identifier)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1),\n\t\t\t     sizeof(int)),\t\t\t\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0A!\",\n\t.str_sec_size = sizeof(\"\\0A!\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"enum_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n{\n\t.descr = \"arraymap invalid btf key (a bit field)\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 32, 32, 8),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_map_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 2,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.map_create_err = true,\n},\n\n{\n\t.descr = \"arraymap invalid btf key (!= 32 bits)\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 16, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_map_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 2,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.map_create_err = true,\n},\n\n{\n\t.descr = \"arraymap invalid btf value (too small)\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_map_check_btf\",\n\t.key_size = sizeof(int),\n\t \n\t.value_size = sizeof(__u64),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.map_create_err = true,\n},\n\n{\n\t.descr = \"arraymap invalid btf value (too big)\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_map_check_btf\",\n\t.key_size = sizeof(int),\n\t \n\t.value_size = sizeof(__u16),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.map_create_err = true,\n},\n\n{\n\t.descr = \"func proto (int (*)(int, unsigned int))\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (vararg)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 3),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (vararg with name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 3),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 0),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\\0c\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\\0c\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#3\",\n},\n\n{\n\t.descr = \"func proto (arg after vararg)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 3),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 0),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#2\",\n},\n\n{\n\t.descr = \"func proto (CONST=>TYPEDEF=>PTR=>FUNC_PROTO)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 5),\t\t\t \n\t\t \n\t\tBTF_CONST_ENC(3),\t\t\t\t \n\t\tBTF_PTR_ENC(6),\t\t\t\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0func_ptr\",\n\t.str_sec_size = sizeof(\"\\0func_ptr\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (TYPEDEF=>FUNC_PROTO)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0func_typedef\",\n\t.str_sec_size = sizeof(\"\\0func_typedef\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (btf_resolve(arg))\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 3),\n\t\tBTF_CONST_ENC(4),\t\t\t\t \n\t\tBTF_PTR_ENC(0),\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (Not all arg has name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0b\",\n\t.str_sec_size = sizeof(\"\\0b\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func proto (Bad arg name_off)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0x0fffffff, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\",\n\t.str_sec_size = sizeof(\"\\0a\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#2\",\n},\n\n{\n\t.descr = \"func proto (Bad arg name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0!!!\",\n\t.str_sec_size = sizeof(\"\\0a\\0!!!\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#2\",\n},\n\n{\n\t.descr = \"func proto (Invalid return type)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(100, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid return type\",\n},\n\n{\n\t.descr = \"func proto (with func name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 0, 2), 0),\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0func_proto\",\n\t.str_sec_size = sizeof(\"\\0func_proto\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"func proto (const void arg)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 4),\n\t\tBTF_CONST_ENC(0),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#1\",\n},\n\n{\n\t.descr = \"func (void func(int a, unsigned int b))\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\\0func\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\\0func\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"func (No func name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t \n\t\tBTF_FUNC_ENC(0, 3),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"func (Invalid func name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\\0!!!\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\\0!!!\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid name\",\n},\n\n{\n\t.descr = \"func (Some arg has no name)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(0, 2),\n\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0func\",\n\t.str_sec_size = sizeof(\"\\0a\\0func\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#2\",\n},\n\n{\n\t.descr = \"func (Non zero vlen)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t\t \n\t\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_FUNC, 0, 2), 3), \t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0a\\0b\\0func\",\n\t.str_sec_size = sizeof(\"\\0a\\0b\\0func\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid func linkage\",\n},\n\n{\n\t.descr = \"func (Not referring to FUNC_PROTO)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0func\",\n\t.str_sec_size = sizeof(\"\\0func\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n\n{\n\t.descr = \"invalid int kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_INT, 1, 0), 4),\t \n\t\tBTF_INT_ENC(0, 0, 32),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"int_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid ptr kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 1, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"ptr_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid array kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ARRAY, 1, 0), 0),\t \n\t\tBTF_ARRAY_ENC(1, 1, 1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"array_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"valid fwd kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_FWD, 1, 0), 0),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"fwd_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"invalid typedef kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD,\n\t\t\t     BTF_INFO_ENC(BTF_KIND_TYPEDEF, 1, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"typedef_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid volatile kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_VOLATILE, 1, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"volatile_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid const kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 1, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"const_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid restrict kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_RESTRICT, 1, 0), 1),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"restrict_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid func kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 0, 0), 0),\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_FUNC, 1, 0), 2),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"invalid func_proto kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 1, 0), 0),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"func_proto_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n\n{\n\t.descr = \"valid struct, kind_flag, bitfield_size = 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 8),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(0, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(0, 32)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid struct, kind_flag, int member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(4, 4)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid union, kind_flag, int member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"union_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid struct, kind_flag, enum member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(4, 4)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\\0C\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid union, kind_flag, enum member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\\0C\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"union_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid struct, kind_flag, typedef member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 5, BTF_MEMBER_OFFSET(4, 4)),\n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\\0C\\0D\\0E\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"valid union, kind_flag, typedef member, bitfield_size != 0\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 5, BTF_MEMBER_OFFSET(4, 0)),\n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\\0C\\0D\\0E\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"union_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"invalid struct, kind_flag, bitfield_size greater than struct size\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(20, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(20, 20)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n{\n\t.descr = \"invalid struct, kind_flag, bitfield base_type int not regular\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 20, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(20, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(20, 20)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member base type\",\n},\n\n{\n\t.descr = \"invalid struct, kind_flag, base_type int not regular\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 12, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 4),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(8, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(8, 8)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member base type\",\n},\n\n{\n\t.descr = \"invalid union, kind_flag, bitfield_size greater than struct size\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 1, 2), 2),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(8, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, BTF_MEMBER_OFFSET(20, 0)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"union_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n\n{\n\t.descr = \"invalid struct, kind_flag, int member, bitfield_size = 0, wrong byte alignment\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 12),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 36)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member offset\",\n},\n\n{\n\t.descr = \"invalid struct, kind_flag, enum member, bitfield_size = 0, wrong byte alignment\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\t \n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 2), 12),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 0)),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 36)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\\0B\\0C\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid member offset\",\n},\n\n{\n\t.descr = \"128-bit int\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 128, 16),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"int_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct, 128-bit int member\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 128, 16),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 16),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct, 120-bit int member bitfield\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 120, 16),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 1), 16),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct, kind_flag, 128-bit int member\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 128, 16),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 1), 16),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 0)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n\n{\n\t.descr = \"struct, kind_flag, 120-bit int member bitfield\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 128, 16),\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 1), 16),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(120, 0)),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0A\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"struct_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 4,\n},\n \n{\n\t.descr = \"struct->ptr->typedef->array->int size resolution\",\n\t.raw_types = {\n\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(5, 5, 16),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0s\\0a\\0arr_t\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"ptr_mod_chain_size_resolve_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int) * 16,\n\t.key_type_id = 5  ,\n\t.value_type_id = 3  ,\n\t.max_entries = 4,\n},\n \n{\n\t.descr = \"struct->ptr->typedef->multi-array->int size resolution\",\n\t.raw_types = {\n\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(5, 7, 16),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(6, 7, 8),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(7, 7, 4),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0s\\0a\\0arr_t\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"multi_arr_size_resolve_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int) * 16 * 8 * 4,\n\t.key_type_id = 7  ,\n\t.value_type_id = 3  ,\n\t.max_entries = 4,\n},\n \n{\n\t.descr = \"typedef/multi-arr mix size resolution\",\n\t.raw_types = {\n\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(5, 10, 16),\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 6),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(7, 10, 8),\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 8),\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(9, 10, 4),\t\t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 10),\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0s\\0a\\0arr1_t\\0arr2_t\\0arr3_t\\0int_t\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"typedef_arra_mix_size_resolve_map\",\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int) * 16 * 8 * 4,\n\t.key_type_id = 10  ,\n\t.value_type_id = 3  ,\n\t.max_entries = 4,\n},\n \n{\n\t.descr = \"datasec: vlen == 0\",\n\t.raw_types = {\n\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t \n\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 0), 4),\n\t\t\t\t\t\t\t\t  \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0.rodata\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n\n{\n\t.descr = \"float test #1, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 2),\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 4),\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 8),\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 12),\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 16),\t\t \n\t\tBTF_STRUCT_ENC(NAME_TBD, 5, 48),\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, 32),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 4, 64),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 5, 128),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 256),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0_Float16\\0float\\0double\\0_Float80\\0long_double\"\n\t\t    \"\\0floats\\0a\\0b\\0c\\0d\\0e\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 48,\n\t.key_type_id = 1,\n\t.value_type_id = 7,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"float test #2, invalid vlen\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_FLOAT, 0, 1), 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0float\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"vlen != 0\",\n},\n{\n\t.descr = \"float test #3, invalid kind_flag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_FLOAT, 1, 0), 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0float\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n{\n\t.descr = \"float test #4, member does not fit\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 4),\t\t \n\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 2),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0float\\0floats\\0x\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Member exceeds struct_size\",\n},\n{\n\t.descr = \"float test #5, member is not properly aligned\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 4),\t\t \n\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 8),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0float\\0floats\\0x\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Member is not properly aligned\",\n},\n{\n\t.descr = \"float test #6, invalid size\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t\t\t\t\t\t \n\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 6),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0float\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"float_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 6,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_size\",\n},\n\n{\n\t.descr = \"decl_tag test #1, struct/member, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_STRUCT_ENC(0, 2, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 0),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0m1\\0m2\\0tag1\\0tag2\\0tag3\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"decl_tag test #2, union/member, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_UNION_ENC(NAME_TBD, 2, 4),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 0),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0t\\0m1\\0m2\\0tag1\\0tag2\\0tag3\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"decl_tag test #3, variable, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 1),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, -1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0global\\0tag1\\0tag2\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"decl_tag test #4, func/parameter, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, -1),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, 0),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, 1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0arg1\\0arg2\\0f\\0tag1\\0tag2\\0tag3\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"decl_tag test #5, invalid value\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_DECL_TAG_ENC(0, 2, -1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid value\",\n},\n{\n\t.descr = \"decl_tag test #6, invalid target type\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 1, -1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag1\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type\",\n},\n{\n\t.descr = \"decl_tag test #7, invalid vlen\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DECL_TAG, 0, 1), 2), (0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag1\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"vlen != 0\",\n},\n{\n\t.descr = \"decl_tag test #8, invalid kflag\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DECL_TAG, 1, 0), 2), (-1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag1\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid btf_info kind_flag\",\n},\n{\n\t.descr = \"decl_tag test #9, var, invalid component_idx\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid component_idx\",\n},\n{\n\t.descr = \"decl_tag test #10, struct member, invalid component_idx\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_STRUCT_ENC(0, 2, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 2),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0m1\\0m2\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid component_idx\",\n},\n{\n\t.descr = \"decl_tag test #11, func parameter, invalid component_idx\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, 2),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0arg1\\0arg2\\0f\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid component_idx\",\n},\n{\n\t.descr = \"decl_tag test #12, < -1 component_idx\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, -2),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0arg1\\0arg2\\0f\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid component_idx\",\n},\n{\n\t.descr = \"decl_tag test #13, typedef, well-formed\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0t\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"decl_tag test #14, typedef, invalid component_idx\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid component_idx\",\n},\n{\n\t.descr = \"decl_tag test #15, func, invalid func proto\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 3, 0),\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 8),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\\0func\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Invalid type_id\",\n},\n{\n\t.descr = \"decl_tag test #16, func proto, return type\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t\t \n\t\tBTF_VAR_ENC(NAME_TBD, 1, 0),\t\t\t\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DECL_TAG, 0, 0), 2), (-1),\t \n\t\tBTF_FUNC_PROTO_ENC(3, 0),\t\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag1\"),\n\t.btf_load_err = true,\n\t.err_str = \"Invalid return type\",\n},\n{\n\t.descr = \"decl_tag test #17, func proto, argument\",\n\t.raw_types = {\n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_DECL_TAG, 0, 0), 4), (-1),\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_PTR, 0, 0), 0),  \n\t\tBTF_FUNC_PROTO_ENC(0, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_VAR_ENC(NAME_TBD, 2, 0),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0local\\0tag1\\0var\"),\n\t.btf_load_err = true,\n\t.err_str = \"Invalid arg#1\",\n},\n{\n\t.descr = \"decl_tag test #18, decl_tag as the map key type\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_STRUCT_ENC(0, 2, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0m1\\0m2\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_HASH,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = 8,\n\t.value_size = 4,\n\t.key_type_id = 3,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.map_create_err = true,\n},\n{\n\t.descr = \"decl_tag test #19, decl_tag as the map value type\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_STRUCT_ENC(0, 2, 8),\t\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 32),\n\t\tBTF_DECL_TAG_ENC(NAME_TBD, 2, -1),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0m1\\0m2\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_HASH,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = 4,\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 3,\n\t.max_entries = 1,\n\t.map_create_err = true,\n},\n{\n\t.descr = \"type_tag test #1\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_PTR_ENC(2),\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"type_tag test #2, type tag order\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_CONST_ENC(3),\t\t\t\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Type tags don't precede modifiers\",\n},\n{\n\t.descr = \"type_tag test #3, type tag order\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_CONST_ENC(4),\t\t\t\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Type tags don't precede modifiers\",\n},\n{\n\t.descr = \"type_tag test #4, type tag order\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_CONST_ENC(4),\t\t\t\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 1),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Type tags don't precede modifiers\",\n},\n{\n\t.descr = \"type_tag test #5, type tag order\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_CONST_ENC(1),\t\t\t\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"type_tag test #6, type tag order\",\n\t.raw_types = {\n\t\tBTF_PTR_ENC(2),\t\t\t\t\t \n\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_CONST_ENC(4),\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),   \n\t\tBTF_PTR_ENC(6),\t\t\t\t\t \n\t\tBTF_CONST_ENC(2),\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0tag\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 1,\n\t.max_entries = 1,\n\t.btf_load_err = true,\n\t.err_str = \"Type tags don't precede modifiers\",\n},\n{\n\t.descr = \"enum64 test #1, unsigned, size 8\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 2), 8),\t \n\t\tBTF_ENUM64_ENC(NAME_TBD, 0, 0),\n\t\tBTF_ENUM64_ENC(NAME_TBD, 1, 1),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0a\\0b\\0c\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 8,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n},\n{\n\t.descr = \"enum64 test #2, signed, size 4\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM64, 1, 2), 4),\t \n\t\tBTF_ENUM64_ENC(NAME_TBD, -1, 0),\n\t\tBTF_ENUM64_ENC(NAME_TBD, 1, 0),\n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0a\\0b\\0c\"),\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"tag_type_check_btf\",\n\t.key_size = sizeof(int),\n\t.value_size = 4,\n\t.key_type_id = 1,\n\t.value_type_id = 2,\n\t.max_entries = 1,\n},\n\n};  \n\nstatic const char *get_next_str(const char *start, const char *end)\n{\n\treturn start < end - 1 ? start + 1 : NULL;\n}\n\nstatic int get_raw_sec_size(const __u32 *raw_types)\n{\n\tint i;\n\n\tfor (i = MAX_NR_RAW_U32 - 1;\n\t     i >= 0 && raw_types[i] != BTF_END_RAW;\n\t     i--)\n\t\t;\n\n\treturn i < 0 ? i : i * sizeof(raw_types[0]);\n}\n\nstatic void *btf_raw_create(const struct btf_header *hdr,\n\t\t\t    const __u32 *raw_types,\n\t\t\t    const char *str,\n\t\t\t    unsigned int str_sec_size,\n\t\t\t    unsigned int *btf_size,\n\t\t\t    const char **ret_next_str)\n{\n\tconst char *next_str = str, *end_str = str + str_sec_size;\n\tconst char **strs_idx = NULL, **tmp_strs_idx;\n\tint strs_cap = 0, strs_cnt = 0, next_str_idx = 0;\n\tunsigned int size_needed, offset;\n\tstruct btf_header *ret_hdr;\n\tint i, type_sec_size, err = 0;\n\tuint32_t *ret_types;\n\tvoid *raw_btf = NULL;\n\n\ttype_sec_size = get_raw_sec_size(raw_types);\n\tif (CHECK(type_sec_size < 0, \"Cannot get nr_raw_types\"))\n\t\treturn NULL;\n\n\tsize_needed = sizeof(*hdr) + type_sec_size + str_sec_size;\n\traw_btf = malloc(size_needed);\n\tif (CHECK(!raw_btf, \"Cannot allocate memory for raw_btf\"))\n\t\treturn NULL;\n\n\t \n\tmemcpy(raw_btf, hdr, sizeof(*hdr));\n\toffset = sizeof(*hdr);\n\n\t \n\twhile ((next_str = get_next_str(next_str, end_str))) {\n\t\tif (strs_cnt == strs_cap) {\n\t\t\tstrs_cap += max(16, strs_cap / 2);\n\t\t\ttmp_strs_idx = realloc(strs_idx,\n\t\t\t\t\t       sizeof(*strs_idx) * strs_cap);\n\t\t\tif (CHECK(!tmp_strs_idx,\n\t\t\t\t  \"Cannot allocate memory for strs_idx\")) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tstrs_idx = tmp_strs_idx;\n\t\t}\n\t\tstrs_idx[strs_cnt++] = next_str;\n\t\tnext_str += strlen(next_str);\n\t}\n\n\t \n\tret_types = raw_btf + offset;\n\tfor (i = 0; i < type_sec_size / sizeof(raw_types[0]); i++) {\n\t\tif (raw_types[i] == NAME_TBD) {\n\t\t\tif (CHECK(next_str_idx == strs_cnt,\n\t\t\t\t  \"Error in getting next_str #%d\",\n\t\t\t\t  next_str_idx)) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tret_types[i] = strs_idx[next_str_idx++] - str;\n\t\t} else if (IS_NAME_NTH(raw_types[i])) {\n\t\t\tint idx = GET_NAME_NTH_IDX(raw_types[i]);\n\n\t\t\tif (CHECK(idx <= 0 || idx > strs_cnt,\n\t\t\t\t  \"Error getting string #%d, strs_cnt:%d\",\n\t\t\t\t  idx, strs_cnt)) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tret_types[i] = strs_idx[idx-1] - str;\n\t\t} else {\n\t\t\tret_types[i] = raw_types[i];\n\t\t}\n\t}\n\toffset += type_sec_size;\n\n\t \n\tmemcpy(raw_btf + offset, str, str_sec_size);\n\n\tret_hdr = (struct btf_header *)raw_btf;\n\tret_hdr->type_len = type_sec_size;\n\tret_hdr->str_off = type_sec_size;\n\tret_hdr->str_len = str_sec_size;\n\n\t*btf_size = size_needed;\n\tif (ret_next_str)\n\t\t*ret_next_str =\n\t\t\tnext_str_idx < strs_cnt ? strs_idx[next_str_idx] : NULL;\n\ndone:\n\tfree(strs_idx);\n\tif (err) {\n\t\tfree(raw_btf);\n\t\treturn NULL;\n\t}\n\treturn raw_btf;\n}\n\nstatic int load_raw_btf(const void *raw_data, size_t raw_size)\n{\n\tLIBBPF_OPTS(bpf_btf_load_opts, opts);\n\tint btf_fd;\n\n\tif (always_log) {\n\t\topts.log_buf = btf_log_buf,\n\t\topts.log_size = BTF_LOG_BUF_SIZE,\n\t\topts.log_level = 1;\n\t}\n\n\tbtf_fd = bpf_btf_load(raw_data, raw_size, &opts);\n\tif (btf_fd < 0 && !always_log) {\n\t\topts.log_buf = btf_log_buf,\n\t\topts.log_size = BTF_LOG_BUF_SIZE,\n\t\topts.log_level = 1;\n\t\tbtf_fd = bpf_btf_load(raw_data, raw_size, &opts);\n\t}\n\n\treturn btf_fd;\n}\n\nstatic void do_test_raw(unsigned int test_num)\n{\n\tstruct btf_raw_test *test = &raw_tests[test_num - 1];\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tint map_fd = -1, btf_fd = -1;\n\tunsigned int raw_btf_size;\n\tstruct btf_header *hdr;\n\tvoid *raw_btf;\n\tint err;\n\n\tif (!test__start_subtest(test->descr))\n\t\treturn;\n\n\traw_btf = btf_raw_create(&hdr_tmpl,\n\t\t\t\t test->raw_types,\n\t\t\t\t test->str_sec,\n\t\t\t\t test->str_sec_size,\n\t\t\t\t &raw_btf_size, NULL);\n\tif (!raw_btf)\n\t\treturn;\n\n\thdr = raw_btf;\n\n\thdr->hdr_len = (int)hdr->hdr_len + test->hdr_len_delta;\n\thdr->type_off = (int)hdr->type_off + test->type_off_delta;\n\thdr->str_off = (int)hdr->str_off + test->str_off_delta;\n\thdr->str_len = (int)hdr->str_len + test->str_len_delta;\n\n\t*btf_log_buf = '\\0';\n\tbtf_fd = load_raw_btf(raw_btf, raw_btf_size);\n\tfree(raw_btf);\n\n\terr = ((btf_fd < 0) != test->btf_load_err);\n\tif (CHECK(err, \"btf_fd:%d test->btf_load_err:%u\",\n\t\t  btf_fd, test->btf_load_err) ||\n\t    CHECK(test->err_str && !strstr(btf_log_buf, test->err_str),\n\t\t  \"expected err_str:%s\\n\", test->err_str)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (err || btf_fd < 0)\n\t\tgoto done;\n\n\topts.btf_fd = btf_fd;\n\topts.btf_key_type_id = test->key_type_id;\n\topts.btf_value_type_id = test->value_type_id;\n\tmap_fd = bpf_map_create(test->map_type, test->map_name,\n\t\t\t\ttest->key_size, test->value_size, test->max_entries, &opts);\n\n\terr = ((map_fd < 0) != test->map_create_err);\n\tCHECK(err, \"map_fd:%d test->map_create_err:%u\",\n\t      map_fd, test->map_create_err);\n\ndone:\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n\tif (map_fd >= 0)\n\t\tclose(map_fd);\n}\n\nstruct btf_get_info_test {\n\tconst char *descr;\n\tconst char *str_sec;\n\t__u32 raw_types[MAX_NR_RAW_U32];\n\t__u32 str_sec_size;\n\tint btf_size_delta;\n\tint (*special_test)(unsigned int test_num);\n};\n\nstatic int test_big_btf_info(unsigned int test_num);\nstatic int test_btf_id(unsigned int test_num);\n\nconst struct btf_get_info_test get_info_tests[] = {\n{\n\t.descr = \"== raw_btf_size+1\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.btf_size_delta = 1,\n},\n{\n\t.descr = \"== raw_btf_size-3\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.btf_size_delta = -3,\n},\n{\n\t.descr = \"Large bpf_btf_info\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.special_test = test_big_btf_info,\n},\n{\n\t.descr = \"BTF ID\",\n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\",\n\t.str_sec_size = sizeof(\"\"),\n\t.special_test = test_btf_id,\n},\n};\n\nstatic int test_big_btf_info(unsigned int test_num)\n{\n\tconst struct btf_get_info_test *test = &get_info_tests[test_num - 1];\n\tuint8_t *raw_btf = NULL, *user_btf = NULL;\n\tunsigned int raw_btf_size;\n\tstruct {\n\t\tstruct bpf_btf_info info;\n\t\tuint64_t garbage;\n\t} info_garbage;\n\tstruct bpf_btf_info *info;\n\tint btf_fd = -1, err;\n\tuint32_t info_len;\n\n\traw_btf = btf_raw_create(&hdr_tmpl,\n\t\t\t\t test->raw_types,\n\t\t\t\t test->str_sec,\n\t\t\t\t test->str_sec_size,\n\t\t\t\t &raw_btf_size, NULL);\n\n\tif (!raw_btf)\n\t\treturn -1;\n\n\t*btf_log_buf = '\\0';\n\n\tuser_btf = malloc(raw_btf_size);\n\tif (CHECK(!user_btf, \"!user_btf\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tbtf_fd = load_raw_btf(raw_btf, raw_btf_size);\n\tif (CHECK(btf_fd < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tinfo = &info_garbage.info;\n\tmemset(info, 0, sizeof(*info));\n\tinfo_garbage.garbage = 0xdeadbeef;\n\tinfo_len = sizeof(info_garbage);\n\tinfo->btf = ptr_to_u64(user_btf);\n\tinfo->btf_size = raw_btf_size;\n\n\terr = bpf_btf_get_info_by_fd(btf_fd, info, &info_len);\n\tif (CHECK(!err, \"!err\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tinfo_garbage.garbage = 0;\n\terr = bpf_btf_get_info_by_fd(btf_fd, info, &info_len);\n\tif (CHECK(err || info_len != sizeof(*info),\n\t\t  \"err:%d errno:%d info_len:%u sizeof(*info):%zu\",\n\t\t  err, errno, info_len, sizeof(*info))) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfprintf(stderr, \"OK\");\n\ndone:\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\n\tfree(raw_btf);\n\tfree(user_btf);\n\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n\n\treturn err;\n}\n\nstatic int test_btf_id(unsigned int test_num)\n{\n\tconst struct btf_get_info_test *test = &get_info_tests[test_num - 1];\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tuint8_t *raw_btf = NULL, *user_btf[2] = {};\n\tint btf_fd[2] = {-1, -1}, map_fd = -1;\n\tstruct bpf_map_info map_info = {};\n\tstruct bpf_btf_info info[2] = {};\n\tunsigned int raw_btf_size;\n\tuint32_t info_len;\n\tint err, i, ret;\n\n\traw_btf = btf_raw_create(&hdr_tmpl,\n\t\t\t\t test->raw_types,\n\t\t\t\t test->str_sec,\n\t\t\t\t test->str_sec_size,\n\t\t\t\t &raw_btf_size, NULL);\n\n\tif (!raw_btf)\n\t\treturn -1;\n\n\t*btf_log_buf = '\\0';\n\n\tfor (i = 0; i < 2; i++) {\n\t\tuser_btf[i] = malloc(raw_btf_size);\n\t\tif (CHECK(!user_btf[i], \"!user_btf[%d]\", i)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tinfo[i].btf = ptr_to_u64(user_btf[i]);\n\t\tinfo[i].btf_size = raw_btf_size;\n\t}\n\n\tbtf_fd[0] = load_raw_btf(raw_btf, raw_btf_size);\n\tif (CHECK(btf_fd[0] < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tinfo_len = sizeof(info[0]);\n\terr = bpf_btf_get_info_by_fd(btf_fd[0], &info[0], &info_len);\n\tif (CHECK(err, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tbtf_fd[1] = bpf_btf_get_fd_by_id(info[0].id);\n\tif (CHECK(btf_fd[1] < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\terr = bpf_btf_get_info_by_fd(btf_fd[1], &info[1], &info_len);\n\tif (CHECK(err || info[0].id != info[1].id ||\n\t\t  info[0].btf_size != info[1].btf_size ||\n\t\t  (ret = memcmp(user_btf[0], user_btf[1], info[0].btf_size)),\n\t\t  \"err:%d errno:%d id0:%u id1:%u btf_size0:%u btf_size1:%u memcmp:%d\",\n\t\t  err, errno, info[0].id, info[1].id,\n\t\t  info[0].btf_size, info[1].btf_size, ret)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\topts.btf_fd = btf_fd[0];\n\topts.btf_key_type_id = 1;\n\topts.btf_value_type_id = 2;\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, \"test_btf_id\",\n\t\t\t\tsizeof(int), sizeof(int), 4, &opts);\n\tif (CHECK(map_fd < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tinfo_len = sizeof(map_info);\n\terr = bpf_map_get_info_by_fd(map_fd, &map_info, &info_len);\n\tif (CHECK(err || map_info.btf_id != info[0].id ||\n\t\t  map_info.btf_key_type_id != 1 || map_info.btf_value_type_id != 2,\n\t\t  \"err:%d errno:%d info.id:%u btf_id:%u btf_key_type_id:%u btf_value_type_id:%u\",\n\t\t  err, errno, info[0].id, map_info.btf_id, map_info.btf_key_type_id,\n\t\t  map_info.btf_value_type_id)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tclose(btf_fd[i]);\n\t\tbtf_fd[i] = -1;\n\t}\n\n\t \n\tbtf_fd[0] = bpf_btf_get_fd_by_id(map_info.btf_id);\n\tif (CHECK(btf_fd[0] < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tclose(btf_fd[0]);\n\tbtf_fd[0] = -1;\n\n\t \n\tclose(map_fd);\n\tmap_fd = -1;\n\tbtf_fd[0] = bpf_btf_get_fd_by_id(map_info.btf_id);\n\tif (CHECK(btf_fd[0] >= 0, \"BTF lingers\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfprintf(stderr, \"OK\");\n\ndone:\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\n\tfree(raw_btf);\n\tif (map_fd >= 0)\n\t\tclose(map_fd);\n\tfor (i = 0; i < 2; i++) {\n\t\tfree(user_btf[i]);\n\t\tif (btf_fd[i] >= 0)\n\t\t\tclose(btf_fd[i]);\n\t}\n\n\treturn err;\n}\n\nstatic void do_test_get_info(unsigned int test_num)\n{\n\tconst struct btf_get_info_test *test = &get_info_tests[test_num - 1];\n\tunsigned int raw_btf_size, user_btf_size, expected_nbytes;\n\tuint8_t *raw_btf = NULL, *user_btf = NULL;\n\tstruct bpf_btf_info info = {};\n\tint btf_fd = -1, err, ret;\n\tuint32_t info_len;\n\n\tif (!test__start_subtest(test->descr))\n\t\treturn;\n\n\tif (test->special_test) {\n\t\terr = test->special_test(test_num);\n\t\tif (CHECK(err, \"failed: %d\\n\", err))\n\t\t\treturn;\n\t}\n\n\traw_btf = btf_raw_create(&hdr_tmpl,\n\t\t\t\t test->raw_types,\n\t\t\t\t test->str_sec,\n\t\t\t\t test->str_sec_size,\n\t\t\t\t &raw_btf_size, NULL);\n\n\tif (!raw_btf)\n\t\treturn;\n\n\t*btf_log_buf = '\\0';\n\n\tuser_btf = malloc(raw_btf_size);\n\tif (CHECK(!user_btf, \"!user_btf\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tbtf_fd = load_raw_btf(raw_btf, raw_btf_size);\n\tif (CHECK(btf_fd <= 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tuser_btf_size = (int)raw_btf_size + test->btf_size_delta;\n\texpected_nbytes = min(raw_btf_size, user_btf_size);\n\tif (raw_btf_size > expected_nbytes)\n\t\tmemset(user_btf + expected_nbytes, 0xff,\n\t\t       raw_btf_size - expected_nbytes);\n\n\tinfo_len = sizeof(info);\n\tinfo.btf = ptr_to_u64(user_btf);\n\tinfo.btf_size = user_btf_size;\n\n\tret = 0;\n\terr = bpf_btf_get_info_by_fd(btf_fd, &info, &info_len);\n\tif (CHECK(err || !info.id || info_len != sizeof(info) ||\n\t\t  info.btf_size != raw_btf_size ||\n\t\t  (ret = memcmp(raw_btf, user_btf, expected_nbytes)),\n\t\t  \"err:%d errno:%d info.id:%u info_len:%u sizeof(info):%zu raw_btf_size:%u info.btf_size:%u expected_nbytes:%u memcmp:%d\",\n\t\t  err, errno, info.id, info_len, sizeof(info),\n\t\t  raw_btf_size, info.btf_size, expected_nbytes, ret)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\twhile (expected_nbytes < raw_btf_size) {\n\t\tfprintf(stderr, \"%u...\", expected_nbytes);\n\t\tif (CHECK(user_btf[expected_nbytes++] != 0xff,\n\t\t\t  \"user_btf[%u]:%x != 0xff\", expected_nbytes - 1,\n\t\t\t  user_btf[expected_nbytes - 1])) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"OK\");\n\ndone:\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\n\tfree(raw_btf);\n\tfree(user_btf);\n\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n}\n\nstruct btf_file_test {\n\tconst char *file;\n\tbool btf_kv_notfound;\n};\n\nstatic struct btf_file_test file_tests[] = {\n\t{ .file = \"test_btf_newkv.bpf.o\", },\n\t{ .file = \"test_btf_nokv.bpf.o\", .btf_kv_notfound = true, },\n};\n\nstatic void do_test_file(unsigned int test_num)\n{\n\tconst struct btf_file_test *test = &file_tests[test_num - 1];\n\tconst char *expected_fnames[] = {\"_dummy_tracepoint\",\n\t\t\t\t\t \"test_long_fname_1\",\n\t\t\t\t\t \"test_long_fname_2\"};\n\tstruct btf_ext *btf_ext = NULL;\n\tstruct bpf_prog_info info = {};\n\tstruct bpf_object *obj = NULL;\n\tstruct bpf_func_info *finfo;\n\tstruct bpf_program *prog;\n\t__u32 info_len, rec_size;\n\tbool has_btf_ext = false;\n\tstruct btf *btf = NULL;\n\tvoid *func_info = NULL;\n\tstruct bpf_map *map;\n\tint i, err, prog_fd;\n\n\tif (!test__start_subtest(test->file))\n\t\treturn;\n\n\tbtf = btf__parse_elf(test->file, &btf_ext);\n\terr = libbpf_get_error(btf);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tprintf(\"%s:SKIP: No ELF %s found\", __func__, BTF_ELF_SEC);\n\t\t\ttest__skip();\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\tbtf__free(btf);\n\n\thas_btf_ext = btf_ext != NULL;\n\tbtf_ext__free(btf_ext);\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL & ~LIBBPF_STRICT_MAP_DEFINITIONS);\n\tobj = bpf_object__open(test->file);\n\terr = libbpf_get_error(obj);\n\tif (CHECK(err, \"obj: %d\", err))\n\t\treturn;\n\n\tprog = bpf_object__next_program(obj, NULL);\n\tif (CHECK(!prog, \"Cannot find bpf_prog\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tbpf_program__set_type(prog, BPF_PROG_TYPE_TRACEPOINT);\n\terr = bpf_object__load(obj);\n\tif (CHECK(err < 0, \"bpf_object__load: %d\", err))\n\t\tgoto done;\n\tprog_fd = bpf_program__fd(prog);\n\n\tmap = bpf_object__find_map_by_name(obj, \"btf_map\");\n\tif (CHECK(!map, \"btf_map not found\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\terr = (bpf_map__btf_key_type_id(map) == 0 || bpf_map__btf_value_type_id(map) == 0)\n\t\t!= test->btf_kv_notfound;\n\tif (CHECK(err, \"btf_key_type_id:%u btf_value_type_id:%u test->btf_kv_notfound:%u\",\n\t\t  bpf_map__btf_key_type_id(map), bpf_map__btf_value_type_id(map),\n\t\t  test->btf_kv_notfound))\n\t\tgoto done;\n\n\tif (!has_btf_ext)\n\t\tgoto skip;\n\n\t \n\tinfo_len = sizeof(struct bpf_prog_info);\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\n\tif (CHECK(err < 0, \"invalid get info (1st) errno:%d\", errno)) {\n\t\tfprintf(stderr, \"%s\\n\", btf_log_buf);\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tif (CHECK(info.nr_func_info != 3,\n\t\t  \"incorrect info.nr_func_info (1st) %d\",\n\t\t  info.nr_func_info)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\trec_size = info.func_info_rec_size;\n\tif (CHECK(rec_size != sizeof(struct bpf_func_info),\n\t\t  \"incorrect info.func_info_rec_size (1st) %d\\n\", rec_size)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfunc_info = malloc(info.nr_func_info * rec_size);\n\tif (CHECK(!func_info, \"out of memory\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tmemset(&info, 0, sizeof(info));\n\tinfo.nr_func_info = 3;\n\tinfo.func_info_rec_size = rec_size;\n\tinfo.func_info = ptr_to_u64(func_info);\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\n\tif (CHECK(err < 0, \"invalid get info (2nd) errno:%d\", errno)) {\n\t\tfprintf(stderr, \"%s\\n\", btf_log_buf);\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tif (CHECK(info.nr_func_info != 3,\n\t\t  \"incorrect info.nr_func_info (2nd) %d\",\n\t\t  info.nr_func_info)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tif (CHECK(info.func_info_rec_size != rec_size,\n\t\t  \"incorrect info.func_info_rec_size (2nd) %d\",\n\t\t  info.func_info_rec_size)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tbtf = btf__load_from_kernel_by_id(info.btf_id);\n\terr = libbpf_get_error(btf);\n\tif (CHECK(err, \"cannot get btf from kernel, err: %d\", err))\n\t\tgoto done;\n\n\t \n\tfinfo = func_info;\n\tfor (i = 0; i < 3; i++) {\n\t\tconst struct btf_type *t;\n\t\tconst char *fname;\n\n\t\tt = btf__type_by_id(btf, finfo->type_id);\n\t\tif (CHECK(!t, \"btf__type_by_id failure: id %u\",\n\t\t\t  finfo->type_id)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfname = btf__name_by_offset(btf, t->name_off);\n\t\terr = strcmp(fname, expected_fnames[i]);\n\t\t \n\t\tif (i && err)\n\t\t\terr = strcmp(fname, expected_fnames[3 - i]);\n\t\tif (CHECK(err, \"incorrect fname %s\", fname ? : \"\")) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfinfo = (void *)finfo + rec_size;\n\t}\n\nskip:\n\tfprintf(stderr, \"OK\");\n\ndone:\n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tbtf__free(btf);\n\tfree(func_info);\n\tbpf_object__close(obj);\n}\n\nconst char *pprint_enum_str[] = {\n\t\"ENUM_ZERO\",\n\t\"ENUM_ONE\",\n\t\"ENUM_TWO\",\n\t\"ENUM_THREE\",\n};\n\nstruct pprint_mapv {\n\tuint32_t ui32;\n\tuint16_t ui16;\n\t \n\tint32_t si32;\n\tuint32_t unused_bits2a:2,\n\t\tbits28:28,\n\t\tunused_bits2b:2;\n\tunion {\n\t\tuint64_t ui64;\n\t\tuint8_t ui8a[8];\n\t};\n\tenum {\n\t\tENUM_ZERO,\n\t\tENUM_ONE,\n\t\tENUM_TWO,\n\t\tENUM_THREE,\n\t} aenum;\n\tuint32_t ui32b;\n\tuint32_t bits2c:2;\n\tuint8_t si8_4[2][2];\n};\n\n#ifdef __SIZEOF_INT128__\nstruct pprint_mapv_int128 {\n\t__int128 si128a;\n\t__int128 si128b;\n\tunsigned __int128 bits3:3;\n\tunsigned __int128 bits80:80;\n\tunsigned __int128 ui128;\n};\n#endif\n\nstatic struct btf_raw_test pprint_test_template[] = {\n{\n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 8, 1),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 16, 2),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 64, 8),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 2, 2),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 28, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(9, 1, 8),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 13, 0), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 8, 0),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 4), 4),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\tBTF_ENUM_ENC(NAME_TBD, 2),\n\t\tBTF_ENUM_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 11), 40),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, 0),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 10, 32),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 12, 64),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 96),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 7, 98),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 126),\t \n\t\tBTF_MEMBER_ENC(0, 14, 128),\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 15, 192),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, 224),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, 256),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 17, 264),\t \n\t\tBTF_TYPE_ARRAY_ENC(18, 1, 2),\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 2),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0si8_4\"),\n\t.key_size = sizeof(unsigned int),\n\t.value_size = sizeof(struct pprint_mapv),\n\t.key_type_id = 3,\t \n\t.value_type_id = 16,\t \n\t.max_entries = 128,\n},\n\n{\n\t \n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 8, 1),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 16, 2),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 64, 8),\n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(9, 1, 8),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 13, 0), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 8, 0),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 4), 4),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\tBTF_ENUM_ENC(NAME_TBD, 2),\n\t\tBTF_ENUM_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 11), 40),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, BTF_MEMBER_OFFSET(0, 0)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 10, BTF_MEMBER_OFFSET(0, 32)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 12, BTF_MEMBER_OFFSET(0, 64)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, BTF_MEMBER_OFFSET(2, 96)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 7, BTF_MEMBER_OFFSET(28, 98)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, BTF_MEMBER_OFFSET(2, 126)),\t \n\t\tBTF_MEMBER_ENC(0, 14, BTF_MEMBER_OFFSET(0, 128)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 15, BTF_MEMBER_OFFSET(0, 192)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, BTF_MEMBER_OFFSET(0, 224)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 6, BTF_MEMBER_OFFSET(2, 256)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 17, 264),\t \n\t\tBTF_TYPE_ARRAY_ENC(18, 1, 2),\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 2),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0si8_4\"),\n\t.key_size = sizeof(unsigned int),\n\t.value_size = sizeof(struct pprint_mapv),\n\t.key_type_id = 3,\t \n\t.value_type_id = 16,\t \n\t.max_entries = 128,\n},\n\n{\n\t \n\t.raw_types = {\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 8, 1),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 16, 2),\n\t\t \t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\n\t\t \t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 64, 8),\n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(0, 0, 0, 32, 4),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(9, 1, 8),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 4),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_UNION, 0, 2), 8),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 13, 0), \n\t\tBTF_MEMBER_ENC(NAME_TBD, 8, 0),\t \n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 4), 4),\n\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\tBTF_ENUM_ENC(NAME_TBD, 2),\n\t\tBTF_ENUM_ENC(NAME_TBD, 3),\n\t\t \t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 11), 40),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, BTF_MEMBER_OFFSET(0, 0)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 10, BTF_MEMBER_OFFSET(0, 32)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 12, BTF_MEMBER_OFFSET(0, 64)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 17, BTF_MEMBER_OFFSET(2, 96)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 7, BTF_MEMBER_OFFSET(28, 98)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 19, BTF_MEMBER_OFFSET(2, 126)), \n\t\tBTF_MEMBER_ENC(0, 14, BTF_MEMBER_OFFSET(0, 128)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 15, BTF_MEMBER_OFFSET(0, 192)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 11, BTF_MEMBER_OFFSET(0, 224)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 17, BTF_MEMBER_OFFSET(2, 256)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 20, BTF_MEMBER_OFFSET(0, 264)),\t \n\t\t \t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 18),\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_VOLATILE, 0, 0), 6),\t \n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_CONST, 0, 0), 15),\t \n\t\tBTF_TYPE_ARRAY_ENC(21, 1, 2),\t\t\t\t\t \n\t\tBTF_TYPE_ARRAY_ENC(1, 1, 2),\t\t\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0___int\\0si8_4\"),\n\t.key_size = sizeof(unsigned int),\n\t.value_size = sizeof(struct pprint_mapv),\n\t.key_type_id = 3,\t \n\t.value_type_id = 16,\t \n\t.max_entries = 128,\n},\n\n#ifdef __SIZEOF_INT128__\n{\n\t \n\t.raw_types = {\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\n\t\t \t\t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 128, 16),\n\t\t \t\t\t\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 128, 16),\n\t\t \t\t\t \n\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 5), 64),\n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 0)),\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 2, BTF_MEMBER_OFFSET(0, 128)),\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, BTF_MEMBER_OFFSET(3, 256)),\t\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, BTF_MEMBER_OFFSET(80, 259)),\t \n\t\tBTF_MEMBER_ENC(NAME_TBD, 3, BTF_MEMBER_OFFSET(0, 384)),\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0unsigned int\\0__int128\\0unsigned __int128\\0pprint_mapv_int128\\0si128a\\0si128b\\0bits3\\0bits80\\0ui128\"),\n\t.key_size = sizeof(unsigned int),\n\t.value_size = sizeof(struct pprint_mapv_int128),\n\t.key_type_id = 1,\n\t.value_type_id = 4,\n\t.max_entries = 128,\n\t.mapv_kind = PPRINT_MAPV_KIND_INT128,\n},\n#endif\n\n};\n\nstatic struct btf_pprint_test_meta {\n\tconst char *descr;\n\tenum bpf_map_type map_type;\n\tconst char *map_name;\n\tbool ordered_map;\n\tbool lossless_map;\n\tbool percpu_map;\n} pprint_tests_meta[] = {\n{\n\t.descr = \"BTF pretty print array\",\n\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t.map_name = \"pprint_test_array\",\n\t.ordered_map = true,\n\t.lossless_map = true,\n\t.percpu_map = false,\n},\n\n{\n\t.descr = \"BTF pretty print hash\",\n\t.map_type = BPF_MAP_TYPE_HASH,\n\t.map_name = \"pprint_test_hash\",\n\t.ordered_map = false,\n\t.lossless_map = true,\n\t.percpu_map = false,\n},\n\n{\n\t.descr = \"BTF pretty print lru hash\",\n\t.map_type = BPF_MAP_TYPE_LRU_HASH,\n\t.map_name = \"pprint_test_lru_hash\",\n\t.ordered_map = false,\n\t.lossless_map = false,\n\t.percpu_map = false,\n},\n\n{\n\t.descr = \"BTF pretty print percpu array\",\n\t.map_type = BPF_MAP_TYPE_PERCPU_ARRAY,\n\t.map_name = \"pprint_test_percpu_array\",\n\t.ordered_map = true,\n\t.lossless_map = true,\n\t.percpu_map = true,\n},\n\n{\n\t.descr = \"BTF pretty print percpu hash\",\n\t.map_type = BPF_MAP_TYPE_PERCPU_HASH,\n\t.map_name = \"pprint_test_percpu_hash\",\n\t.ordered_map = false,\n\t.lossless_map = true,\n\t.percpu_map = true,\n},\n\n{\n\t.descr = \"BTF pretty print lru percpu hash\",\n\t.map_type = BPF_MAP_TYPE_LRU_PERCPU_HASH,\n\t.map_name = \"pprint_test_lru_percpu_hash\",\n\t.ordered_map = false,\n\t.lossless_map = false,\n\t.percpu_map = true,\n},\n\n};\n\nstatic size_t get_pprint_mapv_size(enum pprint_mapv_kind_t mapv_kind)\n{\n\tif (mapv_kind == PPRINT_MAPV_KIND_BASIC)\n\t\treturn sizeof(struct pprint_mapv);\n\n#ifdef __SIZEOF_INT128__\n\tif (mapv_kind == PPRINT_MAPV_KIND_INT128)\n\t\treturn sizeof(struct pprint_mapv_int128);\n#endif\n\n\tassert(0);\n}\n\nstatic void set_pprint_mapv(enum pprint_mapv_kind_t mapv_kind,\n\t\t\t    void *mapv, uint32_t i,\n\t\t\t    int num_cpus, int rounded_value_size)\n{\n\tint cpu;\n\n\tif (mapv_kind == PPRINT_MAPV_KIND_BASIC) {\n\t\tstruct pprint_mapv *v = mapv;\n\n\t\tfor (cpu = 0; cpu < num_cpus; cpu++) {\n\t\t\tv->ui32 = i + cpu;\n\t\t\tv->si32 = -i;\n\t\t\tv->unused_bits2a = 3;\n\t\t\tv->bits28 = i;\n\t\t\tv->unused_bits2b = 3;\n\t\t\tv->ui64 = i;\n\t\t\tv->aenum = i & 0x03;\n\t\t\tv->ui32b = 4;\n\t\t\tv->bits2c = 1;\n\t\t\tv->si8_4[0][0] = (cpu + i) & 0xff;\n\t\t\tv->si8_4[0][1] = (cpu + i + 1) & 0xff;\n\t\t\tv->si8_4[1][0] = (cpu + i + 2) & 0xff;\n\t\t\tv->si8_4[1][1] = (cpu + i + 3) & 0xff;\n\t\t\tv = (void *)v + rounded_value_size;\n\t\t}\n\t}\n\n#ifdef __SIZEOF_INT128__\n\tif (mapv_kind == PPRINT_MAPV_KIND_INT128) {\n\t\tstruct pprint_mapv_int128 *v = mapv;\n\n\t\tfor (cpu = 0; cpu < num_cpus; cpu++) {\n\t\t\tv->si128a = i;\n\t\t\tv->si128b = -i;\n\t\t\tv->bits3 = i & 0x07;\n\t\t\tv->bits80 = (((unsigned __int128)1) << 64) + i;\n\t\t\tv->ui128 = (((unsigned __int128)2) << 64) + i;\n\t\t\tv = (void *)v + rounded_value_size;\n\t\t}\n\t}\n#endif\n}\n\nssize_t get_pprint_expected_line(enum pprint_mapv_kind_t mapv_kind,\n\t\t\t\t char *expected_line, ssize_t line_size,\n\t\t\t\t bool percpu_map, unsigned int next_key,\n\t\t\t\t int cpu, void *mapv)\n{\n\tssize_t nexpected_line = -1;\n\n\tif (mapv_kind == PPRINT_MAPV_KIND_BASIC) {\n\t\tstruct pprint_mapv *v = mapv;\n\n\t\tnexpected_line = snprintf(expected_line, line_size,\n\t\t\t\t\t  \"%s%u: {%u,0,%d,0x%x,0x%x,0x%x,\"\n\t\t\t\t\t  \"{%llu|[%u,%u,%u,%u,%u,%u,%u,%u]},%s,\"\n\t\t\t\t\t  \"%u,0x%x,[[%d,%d],[%d,%d]]}\\n\",\n\t\t\t\t\t  percpu_map ? \"\\tcpu\" : \"\",\n\t\t\t\t\t  percpu_map ? cpu : next_key,\n\t\t\t\t\t  v->ui32, v->si32,\n\t\t\t\t\t  v->unused_bits2a,\n\t\t\t\t\t  v->bits28,\n\t\t\t\t\t  v->unused_bits2b,\n\t\t\t\t\t  (__u64)v->ui64,\n\t\t\t\t\t  v->ui8a[0], v->ui8a[1],\n\t\t\t\t\t  v->ui8a[2], v->ui8a[3],\n\t\t\t\t\t  v->ui8a[4], v->ui8a[5],\n\t\t\t\t\t  v->ui8a[6], v->ui8a[7],\n\t\t\t\t\t  pprint_enum_str[v->aenum],\n\t\t\t\t\t  v->ui32b,\n\t\t\t\t\t  v->bits2c,\n\t\t\t\t\t  v->si8_4[0][0], v->si8_4[0][1],\n\t\t\t\t\t  v->si8_4[1][0], v->si8_4[1][1]);\n\t}\n\n#ifdef __SIZEOF_INT128__\n\tif (mapv_kind == PPRINT_MAPV_KIND_INT128) {\n\t\tstruct pprint_mapv_int128 *v = mapv;\n\n\t\tnexpected_line = snprintf(expected_line, line_size,\n\t\t\t\t\t  \"%s%u: {0x%lx,0x%lx,0x%lx,\"\n\t\t\t\t\t  \"0x%lx%016lx,0x%lx%016lx}\\n\",\n\t\t\t\t\t  percpu_map ? \"\\tcpu\" : \"\",\n\t\t\t\t\t  percpu_map ? cpu : next_key,\n\t\t\t\t\t  (uint64_t)v->si128a,\n\t\t\t\t\t  (uint64_t)v->si128b,\n\t\t\t\t\t  (uint64_t)v->bits3,\n\t\t\t\t\t  (uint64_t)(v->bits80 >> 64),\n\t\t\t\t\t  (uint64_t)v->bits80,\n\t\t\t\t\t  (uint64_t)(v->ui128 >> 64),\n\t\t\t\t\t  (uint64_t)v->ui128);\n\t}\n#endif\n\n\treturn nexpected_line;\n}\n\nstatic int check_line(const char *expected_line, int nexpected_line,\n\t\t      int expected_line_len, const char *line)\n{\n\tif (CHECK(nexpected_line == expected_line_len,\n\t\t  \"expected_line is too long\"))\n\t\treturn -1;\n\n\tif (strcmp(expected_line, line)) {\n\t\tfprintf(stderr, \"unexpected pprint output\\n\");\n\t\tfprintf(stderr, \"expected: %s\", expected_line);\n\t\tfprintf(stderr, \"    read: %s\", line);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void do_test_pprint(int test_num)\n{\n\tconst struct btf_raw_test *test = &pprint_test_template[test_num];\n\tenum pprint_mapv_kind_t mapv_kind = test->mapv_kind;\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\tbool ordered_map, lossless_map, percpu_map;\n\tint err, ret, num_cpus, rounded_value_size;\n\tunsigned int key, nr_read_elems;\n\tint map_fd = -1, btf_fd = -1;\n\tunsigned int raw_btf_size;\n\tchar expected_line[255];\n\tFILE *pin_file = NULL;\n\tchar pin_path[255];\n\tsize_t line_len = 0;\n\tchar *line = NULL;\n\tvoid *mapv = NULL;\n\tuint8_t *raw_btf;\n\tssize_t nread;\n\n\tif (!test__start_subtest(test->descr))\n\t\treturn;\n\n\traw_btf = btf_raw_create(&hdr_tmpl, test->raw_types,\n\t\t\t\t test->str_sec, test->str_sec_size,\n\t\t\t\t &raw_btf_size, NULL);\n\n\tif (!raw_btf)\n\t\treturn;\n\n\t*btf_log_buf = '\\0';\n\tbtf_fd = load_raw_btf(raw_btf, raw_btf_size);\n\tfree(raw_btf);\n\n\tif (CHECK(btf_fd < 0, \"errno:%d\\n\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\topts.btf_fd = btf_fd;\n\topts.btf_key_type_id = test->key_type_id;\n\topts.btf_value_type_id = test->value_type_id;\n\tmap_fd = bpf_map_create(test->map_type, test->map_name,\n\t\t\t\ttest->key_size, test->value_size, test->max_entries, &opts);\n\tif (CHECK(map_fd < 0, \"errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tret = snprintf(pin_path, sizeof(pin_path), \"%s/%s\",\n\t\t       \"/sys/fs/bpf\", test->map_name);\n\n\tif (CHECK(ret >= sizeof(pin_path), \"pin_path %s/%s is too long\",\n\t\t  \"/sys/fs/bpf\", test->map_name)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\terr = bpf_obj_pin(map_fd, pin_path);\n\tif (CHECK(err, \"bpf_obj_pin(%s): errno:%d.\", pin_path, errno))\n\t\tgoto done;\n\n\tpercpu_map = test->percpu_map;\n\tnum_cpus = percpu_map ? bpf_num_possible_cpus() : 1;\n\trounded_value_size = round_up(get_pprint_mapv_size(mapv_kind), 8);\n\tmapv = calloc(num_cpus, rounded_value_size);\n\tif (CHECK(!mapv, \"mapv allocation failure\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfor (key = 0; key < test->max_entries; key++) {\n\t\tset_pprint_mapv(mapv_kind, mapv, key, num_cpus, rounded_value_size);\n\t\tbpf_map_update_elem(map_fd, &key, mapv, 0);\n\t}\n\n\tpin_file = fopen(pin_path, \"r\");\n\tif (CHECK(!pin_file, \"fopen(%s): errno:%d\", pin_path, errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\t \n\twhile ((nread = getline(&line, &line_len, pin_file)) > 0 &&\n\t       *line == '#')\n\t\t;\n\n\tif (CHECK(nread <= 0, \"Unexpected EOF\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tnr_read_elems = 0;\n\tordered_map = test->ordered_map;\n\tlossless_map = test->lossless_map;\n\tdo {\n\t\tssize_t nexpected_line;\n\t\tunsigned int next_key;\n\t\tvoid *cmapv;\n\t\tint cpu;\n\n\t\tnext_key = ordered_map ? nr_read_elems : atoi(line);\n\t\tset_pprint_mapv(mapv_kind, mapv, next_key, num_cpus, rounded_value_size);\n\t\tcmapv = mapv;\n\n\t\tfor (cpu = 0; cpu < num_cpus; cpu++) {\n\t\t\tif (percpu_map) {\n\t\t\t\t \n\t\t\t\tif (cpu == 0) {\n\t\t\t\t\tnexpected_line = snprintf(expected_line,\n\t\t\t\t\t\t\t\t  sizeof(expected_line),\n\t\t\t\t\t\t\t\t  \"%u: {\\n\",\n\t\t\t\t\t\t\t\t  next_key);\n\n\t\t\t\t\terr = check_line(expected_line, nexpected_line,\n\t\t\t\t\t\t\t sizeof(expected_line), line);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tnread = getline(&line, &line_len, pin_file);\n\t\t\t\tif (nread < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnexpected_line = get_pprint_expected_line(mapv_kind, expected_line,\n\t\t\t\t\t\t\t\t  sizeof(expected_line),\n\t\t\t\t\t\t\t\t  percpu_map, next_key,\n\t\t\t\t\t\t\t\t  cpu, cmapv);\n\t\t\terr = check_line(expected_line, nexpected_line,\n\t\t\t\t\t sizeof(expected_line), line);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\n\t\t\tcmapv = cmapv + rounded_value_size;\n\t\t}\n\n\t\tif (percpu_map) {\n\t\t\t \n\t\t\tnread = getline(&line, &line_len, pin_file);\n\t\t\tif (nread < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnread = getline(&line, &line_len, pin_file);\n\t} while (++nr_read_elems < test->max_entries && nread > 0);\n\n\tif (lossless_map &&\n\t    CHECK(nr_read_elems < test->max_entries,\n\t\t  \"Unexpected EOF. nr_read_elems:%u test->max_entries:%u\",\n\t\t  nr_read_elems, test->max_entries)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (CHECK(nread > 0, \"Unexpected extra pprint output: %s\", line)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\ndone:\n\tif (mapv)\n\t\tfree(mapv);\n\tif (!err)\n\t\tfprintf(stderr, \"OK\");\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n\tif (map_fd >= 0)\n\t\tclose(map_fd);\n\tif (pin_file)\n\t\tfclose(pin_file);\n\tunlink(pin_path);\n\tfree(line);\n}\n\nstatic void test_pprint(void)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pprint_tests_meta); i++) {\n\t\tpprint_test_template[0].descr = pprint_tests_meta[i].descr;\n\t\tpprint_test_template[0].map_type = pprint_tests_meta[i].map_type;\n\t\tpprint_test_template[0].map_name = pprint_tests_meta[i].map_name;\n\t\tpprint_test_template[0].ordered_map = pprint_tests_meta[i].ordered_map;\n\t\tpprint_test_template[0].lossless_map = pprint_tests_meta[i].lossless_map;\n\t\tpprint_test_template[0].percpu_map = pprint_tests_meta[i].percpu_map;\n\n\t\tdo_test_pprint(0);\n\t}\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(pprint_test_template); i++) {\n\t\tpprint_test_template[i].descr = pprint_tests_meta[0].descr;\n\t\tpprint_test_template[i].map_type = pprint_tests_meta[0].map_type;\n\t\tpprint_test_template[i].map_name = pprint_tests_meta[0].map_name;\n\t\tpprint_test_template[i].ordered_map = pprint_tests_meta[0].ordered_map;\n\t\tpprint_test_template[i].lossless_map = pprint_tests_meta[0].lossless_map;\n\t\tpprint_test_template[i].percpu_map = pprint_tests_meta[0].percpu_map;\n\t\tdo_test_pprint(i);\n\t}\n}\n\n#define BPF_LINE_INFO_ENC(insn_off, file_off, line_off, line_num, line_col) \\\n\t(insn_off), (file_off), (line_off), ((line_num) << 10 | ((line_col) & 0x3ff))\n\nstatic struct prog_info_raw_test {\n\tconst char *descr;\n\tconst char *str_sec;\n\tconst char *err_str;\n\t__u32 raw_types[MAX_NR_RAW_U32];\n\t__u32 str_sec_size;\n\tstruct bpf_insn insns[MAX_INSNS];\n\t__u32 prog_type;\n\t__u32 func_info[MAX_SUBPROGS][2];\n\t__u32 func_info_rec_size;\n\t__u32 func_info_cnt;\n\t__u32 line_info[MAX_NR_RAW_U32];\n\t__u32 line_info_rec_size;\n\t__u32 nr_jited_ksyms;\n\tbool expected_prog_load_failure;\n\t__u32 dead_code_cnt;\n\t__u32 dead_code_mask;\n\t__u32 dead_func_cnt;\n\t__u32 dead_func_mask;\n} info_raw_tests[] = {\n{\n\t.descr = \"func_type (main func + one sub)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\",\n\t.str_sec_size = sizeof(\"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\"),\n\t.insns = {\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 2),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 2),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info = { {0, 5}, {3, 6} },\n\t.func_info_rec_size = 8,\n\t.func_info_cnt = 2,\n\t.line_info = { BTF_END_RAW },\n},\n\n{\n\t.descr = \"func_type (Incorrect func_info_rec_size)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\",\n\t.str_sec_size = sizeof(\"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\"),\n\t.insns = {\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 2),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 2),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info = { {0, 5}, {3, 6} },\n\t.func_info_rec_size = 4,\n\t.func_info_cnt = 2,\n\t.line_info = { BTF_END_RAW },\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"func_type (Incorrect func_info_cnt)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\",\n\t.str_sec_size = sizeof(\"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\"),\n\t.insns = {\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 2),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 2),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info = { {0, 5}, {3, 6} },\n\t.func_info_rec_size = 8,\n\t.func_info_cnt = 1,\n\t.line_info = { BTF_END_RAW },\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"func_type (Incorrect bpf_func_info.insn_off)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 2),\n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 3),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 4),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\t.str_sec = \"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\",\n\t.str_sec_size = sizeof(\"\\0int\\0unsigned int\\0a\\0b\\0c\\0d\\0funcA\\0funcB\"),\n\t.insns = {\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 2),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 2),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info = { {0, 5}, {2, 6} },\n\t.func_info_rec_size = 8,\n\t.func_info_cnt = 2,\n\t.line_info = { BTF_END_RAW },\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (No subprog)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1;\\0int b=2;\\0return a + b;\\0return a + b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n},\n\n{\n\t.descr = \"line_info (No subprog. insn_off >= prog->len)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1;\\0int b=2;\\0return a + b;\\0return a + b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7),\n\t\tBPF_LINE_INFO_ENC(4, 0, 0, 5, 6),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n\t.err_str = \"line_info[4].insn_off\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (Zero bpf insn code)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 64, 8),\t \n\t\tBTF_TYPEDEF_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0unsigned long\\0u64\\0u64 a=1;\\0return a;\"),\n\t.insns = {\n\t\tBPF_LD_IMM64(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(1, 0, 0, 2, 9),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n\t.err_str = \"Invalid insn code at line_info[1]\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (No subprog. zero tailing line_info\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1;\\0int b=2;\\0return a + b;\\0return a + b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10), 0,\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9), 0,\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8), 0,\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7), 0,\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info) + sizeof(__u32),\n\t.nr_jited_ksyms = 1,\n},\n\n{\n\t.descr = \"line_info (No subprog. nonzero tailing line_info)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1;\\0int b=2;\\0return a + b;\\0return a + b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10), 0,\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9), 0,\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8), 0,\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7), 1,\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info) + sizeof(__u32),\n\t.nr_jited_ksyms = 1,\n\t.err_str = \"nonzero tailing record in line_info\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (subprog)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1+1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n},\n\n{\n\t.descr = \"line_info (subprog + func_info)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0sub\\0main\\0int a=1+1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 2,\n\t.func_info_rec_size = 8,\n\t.func_info = { {0, 4}, {5, 3} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n},\n\n{\n\t.descr = \"line_info (subprog. missing 1st func line info)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1+1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.err_str = \"missing bpf_line_info for func#0\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (subprog. missing 2nd func line info)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1+1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.err_str = \"missing bpf_line_info for func#1\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (subprog. unordered insn offset)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1+1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.err_str = \"Invalid line_info[2].insn_off\",\n\t.expected_prog_load_failure = true,\n},\n\n{\n\t.descr = \"line_info (dead start)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0/* dead jmp */\\0int a=1;\\0int b=2;\\0return a + b;\\0return a + b;\"),\n\t.insns = {\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 5, 6),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n\t.dead_code_cnt = 1,\n\t.dead_code_mask = 0x01,\n},\n\n{\n\t.descr = \"line_info (dead end)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0int a=1;\\0int b=2;\\0return a + b;\\0/* dead jmp */\\0return a + b;\\0/* dead exit */\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 2),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_0, 10, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 0,\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 12),\n\t\tBPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 11),\n\t\tBPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 9),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 5, 8),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 6, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n\t.dead_code_cnt = 2,\n\t.dead_code_mask = 0x28,\n},\n\n{\n\t.descr = \"line_info (dead code + subprog + func_info)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0sub\\0main\\0int a=1+1;\\0/* dead jmp */\"\n\t\t    \"\\0/* dead */\\0/* dead */\\0/* dead */\\0/* dead */\"\n\t\t    \"\\0/* dead */\\0/* dead */\\0/* dead */\\0/* dead */\"\n\t\t    \"\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_2),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 8),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, BPF_REG_1),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 2,\n\t.func_info_rec_size = 8,\n\t.func_info = { {0, 4}, {14, 3} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(8, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(9, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(10, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(11, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(12, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(14, 0, NAME_TBD, 3, 8),\n\t\tBPF_LINE_INFO_ENC(16, 0, NAME_TBD, 4, 7),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.dead_code_cnt = 9,\n\t.dead_code_mask = 0x3fe,\n},\n\n{\n\t.descr = \"line_info (dead subprog)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0dead\\0main\\0func\\0int a=1+1;\\0/* live call */\"\n\t\t    \"\\0return 0;\\0return 0;\\0/* dead */\\0/* dead */\"\n\t\t    \"\\0/* dead */\\0return bla + 1;\\0return bla + 1;\"\n\t\t    \"\\0return bla + 1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\t\tBPF_CALL_REL(3),\n\t\tBPF_CALL_REL(5),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_REG(BPF_REG_0, 2),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 3,\n\t.func_info_rec_size = 8,\n\t\t.func_info = { {0, 4}, {6, 3}, {9, 5} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(8, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(9, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(10, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(11, 0, NAME_TBD, 2, 9),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.dead_code_cnt = 3,\n\t.dead_code_mask = 0x70,\n\t.dead_func_cnt = 1,\n\t.dead_func_mask = 0x2,\n},\n\n{\n\t.descr = \"line_info (dead last subprog)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0dead\\0main\\0int a=1+1;\\0/* live call */\"\n\t\t    \"\\0return 0;\\0/* dead */\\0/* dead */\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\t\tBPF_CALL_REL(2),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 2,\n\t.func_info_rec_size = 8,\n\t\t.func_info = { {0, 4}, {5, 3} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 1,\n\t.dead_code_cnt = 2,\n\t.dead_code_mask = 0x18,\n\t.dead_func_cnt = 1,\n\t.dead_func_mask = 0x2,\n},\n\n{\n\t.descr = \"line_info (dead subprog + dead start)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0dead\\0main\\0func\\0int a=1+1;\\0/* dead */\"\n\t\t    \"\\0return 0;\\0return 0;\\0return 0;\"\n\t\t    \"\\0/* dead */\\0/* dead */\\0/* dead */\\0/* dead */\"\n\t\t    \"\\0return b + 1;\\0return b + 1;\\0return b + 1;\"),\n\t.insns = {\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\t\tBPF_CALL_REL(3),\n\t\tBPF_CALL_REL(5),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_MOV64_REG(BPF_REG_0, 2),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 3,\n\t.func_info_rec_size = 8,\n\t\t.func_info = { {0, 4}, {7, 3}, {10, 5} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(8, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(9, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(10, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(11, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(12, 0, NAME_TBD, 2, 9),\n\t\tBPF_LINE_INFO_ENC(13, 0, NAME_TBD, 2, 9),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.dead_code_cnt = 5,\n\t.dead_code_mask = 0x1e2,\n\t.dead_func_cnt = 1,\n\t.dead_func_mask = 0x2,\n},\n\n{\n\t.descr = \"line_info (dead subprog + dead start w/ move)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0dead\\0main\\0func\\0int a=1+1;\\0/* live call */\"\n\t\t    \"\\0return 0;\\0return 0;\\0/* dead */\\0/* dead */\"\n\t\t    \"\\0/* dead */\\0return bla + 1;\\0return bla + 1;\"\n\t\t    \"\\0return bla + 1;\\0return func(a);\\0b+=1;\\0return b;\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\t\tBPF_CALL_REL(3),\n\t\tBPF_CALL_REL(5),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_CALL_REL(1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_MOV64_REG(BPF_REG_0, 2),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 3,\n\t.func_info_rec_size = 8,\n\t\t.func_info = { {0, 4}, {6, 3}, {9, 5} },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(3, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(4, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(5, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(7, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(8, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(9, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(11, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(12, 0, NAME_TBD, 2, 9),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n\t.dead_code_cnt = 3,\n\t.dead_code_mask = 0x70,\n\t.dead_func_cnt = 1,\n\t.dead_func_mask = 0x2,\n},\n\n{\n\t.descr = \"line_info (dead end + subprog start w/ no linfo)\",\n\t.raw_types = {\n\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\tBTF_FUNC_PROTO_ENC(1, 1),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_FUNC_ENC(NAME_TBD, 2),\t\t\t \n\t\tBTF_END_RAW,\n\t},\n\tBTF_STR_SEC(\"\\0int\\0x\\0main\\0func\\0/* main linfo */\\0/* func linfo */\"),\n\t.insns = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_JMP_IMM(BPF_JGE, BPF_REG_0, 1, 3),\n\t\tBPF_CALL_REL(3),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.func_info_cnt = 2,\n\t.func_info_rec_size = 8,\n\t.func_info = { {0, 3}, {6, 4}, },\n\t.line_info = {\n\t\tBPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),\n\t\tBPF_LINE_INFO_ENC(6, 0, NAME_TBD, 1, 10),\n\t\tBTF_END_RAW,\n\t},\n\t.line_info_rec_size = sizeof(struct bpf_line_info),\n\t.nr_jited_ksyms = 2,\n},\n\n};\n\nstatic size_t probe_prog_length(const struct bpf_insn *fp)\n{\n\tsize_t len;\n\n\tfor (len = MAX_INSNS - 1; len > 0; --len)\n\t\tif (fp[len].code != 0 || fp[len].imm != 0)\n\t\t\tbreak;\n\treturn len + 1;\n}\n\nstatic __u32 *patch_name_tbd(const __u32 *raw_u32,\n\t\t\t     const char *str, __u32 str_off,\n\t\t\t     unsigned int str_sec_size,\n\t\t\t     unsigned int *ret_size)\n{\n\tint i, raw_u32_size = get_raw_sec_size(raw_u32);\n\tconst char *end_str = str + str_sec_size;\n\tconst char *next_str = str + str_off;\n\t__u32 *new_u32 = NULL;\n\n\tif (raw_u32_size == -1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!raw_u32_size) {\n\t\t*ret_size = 0;\n\t\treturn NULL;\n\t}\n\n\tnew_u32 = malloc(raw_u32_size);\n\tif (!new_u32)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < raw_u32_size / sizeof(raw_u32[0]); i++) {\n\t\tif (raw_u32[i] == NAME_TBD) {\n\t\t\tnext_str = get_next_str(next_str, end_str);\n\t\t\tif (CHECK(!next_str, \"Error in getting next_str\\n\")) {\n\t\t\t\tfree(new_u32);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\tnew_u32[i] = next_str - str;\n\t\t\tnext_str += strlen(next_str);\n\t\t} else {\n\t\t\tnew_u32[i] = raw_u32[i];\n\t\t}\n\t}\n\n\t*ret_size = raw_u32_size;\n\treturn new_u32;\n}\n\nstatic int test_get_finfo(const struct prog_info_raw_test *test,\n\t\t\t  int prog_fd)\n{\n\tstruct bpf_prog_info info = {};\n\tstruct bpf_func_info *finfo;\n\t__u32 info_len, rec_size, i;\n\tvoid *func_info = NULL;\n\t__u32 nr_func_info;\n\tint err;\n\n\t \n\tinfo_len = sizeof(struct bpf_prog_info);\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (CHECK(err < 0, \"invalid get info (1st) errno:%d\", errno)) {\n\t\tfprintf(stderr, \"%s\\n\", btf_log_buf);\n\t\treturn -1;\n\t}\n\tnr_func_info = test->func_info_cnt - test->dead_func_cnt;\n\tif (CHECK(info.nr_func_info != nr_func_info,\n\t\t  \"incorrect info.nr_func_info (1st) %d\",\n\t\t  info.nr_func_info)) {\n\t\treturn -1;\n\t}\n\n\trec_size = info.func_info_rec_size;\n\tif (CHECK(rec_size != sizeof(struct bpf_func_info),\n\t\t  \"incorrect info.func_info_rec_size (1st) %d\", rec_size)) {\n\t\treturn -1;\n\t}\n\n\tif (!info.nr_func_info)\n\t\treturn 0;\n\n\tfunc_info = malloc(info.nr_func_info * rec_size);\n\tif (CHECK(!func_info, \"out of memory\"))\n\t\treturn -1;\n\n\t \n\tmemset(&info, 0, sizeof(info));\n\tinfo.nr_func_info = nr_func_info;\n\tinfo.func_info_rec_size = rec_size;\n\tinfo.func_info = ptr_to_u64(func_info);\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (CHECK(err < 0, \"invalid get info (2nd) errno:%d\", errno)) {\n\t\tfprintf(stderr, \"%s\\n\", btf_log_buf);\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tif (CHECK(info.nr_func_info != nr_func_info,\n\t\t  \"incorrect info.nr_func_info (2nd) %d\",\n\t\t  info.nr_func_info)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tif (CHECK(info.func_info_rec_size != rec_size,\n\t\t  \"incorrect info.func_info_rec_size (2nd) %d\",\n\t\t  info.func_info_rec_size)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfinfo = func_info;\n\tfor (i = 0; i < nr_func_info; i++) {\n\t\tif (test->dead_func_mask & (1 << i))\n\t\t\tcontinue;\n\t\tif (CHECK(finfo->type_id != test->func_info[i][1],\n\t\t\t  \"incorrect func_type %u expected %u\",\n\t\t\t  finfo->type_id, test->func_info[i][1])) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tfinfo = (void *)finfo + rec_size;\n\t}\n\n\terr = 0;\n\ndone:\n\tfree(func_info);\n\treturn err;\n}\n\nstatic int test_get_linfo(const struct prog_info_raw_test *test,\n\t\t\t  const void *patched_linfo,\n\t\t\t  __u32 cnt, int prog_fd)\n{\n\t__u32 i, info_len, nr_jited_ksyms, nr_jited_func_lens;\n\t__u64 *jited_linfo = NULL, *jited_ksyms = NULL;\n\t__u32 rec_size, jited_rec_size, jited_cnt;\n\tstruct bpf_line_info *linfo = NULL;\n\t__u32 cur_func_len, ksyms_found;\n\tstruct bpf_prog_info info = {};\n\t__u32 *jited_func_lens = NULL;\n\t__u64 cur_func_ksyms;\n\t__u32 dead_insns;\n\tint err;\n\n\tjited_cnt = cnt;\n\trec_size = sizeof(*linfo);\n\tjited_rec_size = sizeof(*jited_linfo);\n\tif (test->nr_jited_ksyms)\n\t\tnr_jited_ksyms = test->nr_jited_ksyms;\n\telse\n\t\tnr_jited_ksyms = test->func_info_cnt - test->dead_func_cnt;\n\tnr_jited_func_lens = nr_jited_ksyms;\n\n\tinfo_len = sizeof(struct bpf_prog_info);\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (CHECK(err < 0, \"err:%d errno:%d\", err, errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (!info.jited_prog_len) {\n\t\t \n\t\tjited_cnt = 0;\n\t\tnr_jited_ksyms = 1;\n\t\tnr_jited_func_lens = 1;\n\t}\n\n\tif (CHECK(info.nr_line_info != cnt ||\n\t\t  info.nr_jited_line_info != jited_cnt ||\n\t\t  info.nr_jited_ksyms != nr_jited_ksyms ||\n\t\t  info.nr_jited_func_lens != nr_jited_func_lens ||\n\t\t  (!info.nr_line_info && info.nr_jited_line_info),\n\t\t  \"info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) nr_jited_ksyms:%u(expected:%u) nr_jited_func_lens:%u(expected:%u)\",\n\t\t  info.nr_line_info, cnt,\n\t\t  info.nr_jited_line_info, jited_cnt,\n\t\t  info.nr_jited_ksyms, nr_jited_ksyms,\n\t\t  info.nr_jited_func_lens, nr_jited_func_lens)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (CHECK(info.line_info_rec_size != sizeof(struct bpf_line_info) ||\n\t\t  info.jited_line_info_rec_size != sizeof(__u64),\n\t\t  \"info: line_info_rec_size:%u(userspace expected:%u) jited_line_info_rec_size:%u(userspace expected:%u)\",\n\t\t  info.line_info_rec_size, rec_size,\n\t\t  info.jited_line_info_rec_size, jited_rec_size)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (!cnt)\n\t\treturn 0;\n\n\trec_size = info.line_info_rec_size;\n\tjited_rec_size = info.jited_line_info_rec_size;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tlinfo = calloc(cnt, rec_size);\n\tif (CHECK(!linfo, \"!linfo\")) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\tinfo.nr_line_info = cnt;\n\tinfo.line_info_rec_size = rec_size;\n\tinfo.line_info = ptr_to_u64(linfo);\n\n\tif (jited_cnt) {\n\t\tjited_linfo = calloc(jited_cnt, jited_rec_size);\n\t\tjited_ksyms = calloc(nr_jited_ksyms, sizeof(*jited_ksyms));\n\t\tjited_func_lens = calloc(nr_jited_func_lens,\n\t\t\t\t\t sizeof(*jited_func_lens));\n\t\tif (CHECK(!jited_linfo || !jited_ksyms || !jited_func_lens,\n\t\t\t  \"jited_linfo:%p jited_ksyms:%p jited_func_lens:%p\",\n\t\t\t  jited_linfo, jited_ksyms, jited_func_lens)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tinfo.nr_jited_line_info = jited_cnt;\n\t\tinfo.jited_line_info_rec_size = jited_rec_size;\n\t\tinfo.jited_line_info = ptr_to_u64(jited_linfo);\n\t\tinfo.nr_jited_ksyms = nr_jited_ksyms;\n\t\tinfo.jited_ksyms = ptr_to_u64(jited_ksyms);\n\t\tinfo.nr_jited_func_lens = nr_jited_func_lens;\n\t\tinfo.jited_func_lens = ptr_to_u64(jited_func_lens);\n\t}\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\n\t \n\tif (CHECK(err < 0 ||\n\t\t  info.nr_line_info != cnt ||\n\t\t  (jited_cnt && !info.jited_line_info) ||\n\t\t  info.nr_jited_line_info != jited_cnt ||\n\t\t  info.line_info_rec_size != rec_size ||\n\t\t  info.jited_line_info_rec_size != jited_rec_size,\n\t\t  \"err:%d errno:%d info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) line_info_rec_size:%u(expected:%u) jited_linfo_rec_size:%u(expected:%u) line_info:%p jited_line_info:%p\",\n\t\t  err, errno,\n\t\t  info.nr_line_info, cnt,\n\t\t  info.nr_jited_line_info, jited_cnt,\n\t\t  info.line_info_rec_size, rec_size,\n\t\t  info.jited_line_info_rec_size, jited_rec_size,\n\t\t  (void *)(long)info.line_info,\n\t\t  (void *)(long)info.jited_line_info)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tdead_insns = 0;\n\twhile (test->dead_code_mask & (1 << dead_insns))\n\t\tdead_insns++;\n\n\tCHECK(linfo[0].insn_off, \"linfo[0].insn_off:%u\",\n\t      linfo[0].insn_off);\n\tfor (i = 1; i < cnt; i++) {\n\t\tconst struct bpf_line_info *expected_linfo;\n\n\t\twhile (test->dead_code_mask & (1 << (i + dead_insns)))\n\t\t\tdead_insns++;\n\n\t\texpected_linfo = patched_linfo +\n\t\t\t((i + dead_insns) * test->line_info_rec_size);\n\t\tif (CHECK(linfo[i].insn_off <= linfo[i - 1].insn_off,\n\t\t\t  \"linfo[%u].insn_off:%u <= linfo[%u].insn_off:%u\",\n\t\t\t  i, linfo[i].insn_off,\n\t\t\t  i - 1, linfo[i - 1].insn_off)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (CHECK(linfo[i].file_name_off != expected_linfo->file_name_off ||\n\t\t\t  linfo[i].line_off != expected_linfo->line_off ||\n\t\t\t  linfo[i].line_col != expected_linfo->line_col,\n\t\t\t  \"linfo[%u] (%u, %u, %u) != (%u, %u, %u)\", i,\n\t\t\t  linfo[i].file_name_off,\n\t\t\t  linfo[i].line_off,\n\t\t\t  linfo[i].line_col,\n\t\t\t  expected_linfo->file_name_off,\n\t\t\t  expected_linfo->line_off,\n\t\t\t  expected_linfo->line_col)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!jited_cnt) {\n\t\tfprintf(stderr, \"not jited. skipping jited_line_info check. \");\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\tif (CHECK(jited_linfo[0] != jited_ksyms[0],\n\t\t  \"jited_linfo[0]:%lx != jited_ksyms[0]:%lx\",\n\t\t  (long)(jited_linfo[0]), (long)(jited_ksyms[0]))) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tksyms_found = 1;\n\tcur_func_len = jited_func_lens[0];\n\tcur_func_ksyms = jited_ksyms[0];\n\tfor (i = 1; i < jited_cnt; i++) {\n\t\tif (ksyms_found < nr_jited_ksyms &&\n\t\t    jited_linfo[i] == jited_ksyms[ksyms_found]) {\n\t\t\tcur_func_ksyms = jited_ksyms[ksyms_found];\n\t\t\tcur_func_len = jited_ksyms[ksyms_found];\n\t\t\tksyms_found++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (CHECK(jited_linfo[i] <= jited_linfo[i - 1],\n\t\t\t  \"jited_linfo[%u]:%lx <= jited_linfo[%u]:%lx\",\n\t\t\t  i, (long)jited_linfo[i],\n\t\t\t  i - 1, (long)(jited_linfo[i - 1]))) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (CHECK(jited_linfo[i] - cur_func_ksyms > cur_func_len,\n\t\t\t  \"jited_linfo[%u]:%lx - %lx > %u\",\n\t\t\t  i, (long)jited_linfo[i], (long)cur_func_ksyms,\n\t\t\t  cur_func_len)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (CHECK(ksyms_found != nr_jited_ksyms,\n\t\t  \"ksyms_found:%u != nr_jited_ksyms:%u\",\n\t\t  ksyms_found, nr_jited_ksyms)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\ndone:\n\tfree(linfo);\n\tfree(jited_linfo);\n\tfree(jited_ksyms);\n\tfree(jited_func_lens);\n\treturn err;\n}\n\nstatic void do_test_info_raw(unsigned int test_num)\n{\n\tconst struct prog_info_raw_test *test = &info_raw_tests[test_num - 1];\n\tunsigned int raw_btf_size, linfo_str_off, linfo_size = 0;\n\tint btf_fd = -1, prog_fd = -1, err = 0;\n\tvoid *raw_btf, *patched_linfo = NULL;\n\tconst char *ret_next_str;\n\tunion bpf_attr attr = {};\n\n\tif (!test__start_subtest(test->descr))\n\t\treturn;\n\n\traw_btf = btf_raw_create(&hdr_tmpl, test->raw_types,\n\t\t\t\t test->str_sec, test->str_sec_size,\n\t\t\t\t &raw_btf_size, &ret_next_str);\n\tif (!raw_btf)\n\t\treturn;\n\n\t*btf_log_buf = '\\0';\n\tbtf_fd = load_raw_btf(raw_btf, raw_btf_size);\n\tfree(raw_btf);\n\n\tif (CHECK(btf_fd < 0, \"invalid btf_fd errno:%d\", errno)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (*btf_log_buf && always_log)\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\t*btf_log_buf = '\\0';\n\n\tlinfo_str_off = ret_next_str - test->str_sec;\n\tpatched_linfo = patch_name_tbd(test->line_info,\n\t\t\t\t       test->str_sec, linfo_str_off,\n\t\t\t\t       test->str_sec_size, &linfo_size);\n\terr = libbpf_get_error(patched_linfo);\n\tif (err) {\n\t\tfprintf(stderr, \"error in creating raw bpf_line_info\");\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tattr.prog_type = test->prog_type;\n\tattr.insns = ptr_to_u64(test->insns);\n\tattr.insn_cnt = probe_prog_length(test->insns);\n\tattr.license = ptr_to_u64(\"GPL\");\n\tattr.prog_btf_fd = btf_fd;\n\tattr.func_info_rec_size = test->func_info_rec_size;\n\tattr.func_info_cnt = test->func_info_cnt;\n\tattr.func_info = ptr_to_u64(test->func_info);\n\tattr.log_buf = ptr_to_u64(btf_log_buf);\n\tattr.log_size = BTF_LOG_BUF_SIZE;\n\tattr.log_level = 1;\n\tif (linfo_size) {\n\t\tattr.line_info_rec_size = test->line_info_rec_size;\n\t\tattr.line_info = ptr_to_u64(patched_linfo);\n\t\tattr.line_info_cnt = linfo_size / attr.line_info_rec_size;\n\t}\n\n\tprog_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\n\terr = ((prog_fd < 0) != test->expected_prog_load_failure);\n\tif (CHECK(err, \"prog_fd:%d expected_prog_load_failure:%u errno:%d\",\n\t\t  prog_fd, test->expected_prog_load_failure, errno) ||\n\t    CHECK(test->err_str && !strstr(btf_log_buf, test->err_str),\n\t\t  \"expected err_str:%s\", test->err_str)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (prog_fd < 0)\n\t\tgoto done;\n\n\terr = test_get_finfo(test, prog_fd);\n\tif (err)\n\t\tgoto done;\n\n\terr = test_get_linfo(test, patched_linfo,\n\t\t\t     attr.line_info_cnt - test->dead_code_cnt,\n\t\t\t     prog_fd);\n\tif (err)\n\t\tgoto done;\n\ndone:\n\tif (*btf_log_buf && (err || always_log))\n\t\tfprintf(stderr, \"\\n%s\", btf_log_buf);\n\n\tif (btf_fd >= 0)\n\t\tclose(btf_fd);\n\tif (prog_fd >= 0)\n\t\tclose(prog_fd);\n\n\tif (!libbpf_get_error(patched_linfo))\n\t\tfree(patched_linfo);\n}\n\nstruct btf_raw_data {\n\t__u32 raw_types[MAX_NR_RAW_U32];\n\tconst char *str_sec;\n\t__u32 str_sec_size;\n};\n\nstruct btf_dedup_test {\n\tconst char *descr;\n\tstruct btf_raw_data input;\n\tstruct btf_raw_data expect;\n\tstruct btf_dedup_opts opts;\n};\n\nstatic struct btf_dedup_test dedup_tests[] = {\n\n{\n\t.descr = \"dedup: unused strings filtering\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(5), BTF_INT_SIGNED, 0, 64, 8),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0unused\\0int\\0foo\\0bar\\0long\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 64, 8),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0long\"),\n\t},\n},\n{\n\t.descr = \"dedup: strings deduplication\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 64, 8),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(3), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(4), BTF_INT_SIGNED, 0, 64, 8),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(5), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0long int\\0int\\0long int\\0int\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 64, 8),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0long int\"),\n\t},\n},\n{\n\t.descr = \"dedup: struct example #1\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_TYPE_ARRAY_ENC(1, 1, 16),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(2), 5, 88),\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 4, 0),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(4), 5, 64),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(5), 2, 128),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(6), 1, 640),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(8), 15, 672),\t \n\t\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_PTR_ENC(6),\t\t\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_CONST_ENC(1),\t\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 3, -1),\t\t\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 3, 1),\t\t\t\t \n\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_ARRAY_ENC(9, 9, 16),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(2), 5, 88),\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 12, 0),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(4), 13, 64),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(5), 10, 128),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(6), 9, 640),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(8), 15, 672),\n\t\t\tBTF_PTR_ENC(11),\t\t\t\t\t\t \n\t\t\tBTF_PTR_ENC(14),\t\t\t\t\t\t \n\t\t\tBTF_CONST_ENC(9),\t\t\t\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(7), 4),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 11, -1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 11, 1),\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0s\\0next\\0a\\0b\\0c\\0float\\0d\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(5), BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_TYPE_ARRAY_ENC(1, 1, 16),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(8), 5, 88),\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(7), 4, 0),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(1), 5, 64),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 128),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 1, 640),\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(4), 9, 672),\t \n\t\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_PTR_ENC(6),\t\t\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_CONST_ENC(1),\t\t\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 3, -1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 3, 1),\t\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(7), 4),\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0a\\0b\\0c\\0d\\0int\\0float\\0next\\0s\"),\n\t},\n},\n{\n\t.descr = \"dedup: struct <-> fwd resolution w/ hash collision\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_TBD, 0  ),\t \n\t\t\tBTF_PTR_ENC(1),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 2, 0),\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 0, 0),\t\t\t \n\t\t\tBTF_PTR_ENC(4),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 5, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0x\\0s\\0x\\0x\\0s\\0x\\0\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\t\tBTF_STRUCT_ENC(NAME_NTH(2), 0, 0),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0s\\0x\"),\n\t},\n\t.opts = {\n\t\t.force_collisions = true,  \n\t},\n},\n{\n\t.descr = \"dedup: void equiv check\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(0, 0, 1),\t\t\t\t \n\t\t\tBTF_PTR_ENC(1),\t\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\t \n\t\t\tBTF_PTR_ENC(0),\t\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 4, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0s\\0x\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(0, 0, 1),\t\t\t\t \n\t\t\tBTF_PTR_ENC(1),\t\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\t \n\t\t\tBTF_PTR_ENC(0),\t\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 8),\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 4, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0s\\0x\"),\n\t},\n\t.opts = {\n\t\t.force_collisions = true,  \n\t},\n},\n{\n\t.descr = \"dedup: all possible kinds (no duplicates)\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 8),\t\t \n\t\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 2), 4),\t \n\t\t\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\t\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\t\tBTF_FWD_ENC(NAME_TBD, 1  ),\t\t\t \n\t\t\tBTF_TYPE_ARRAY_ENC(2, 1, 7),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 4),\t\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\t\tBTF_UNION_ENC(NAME_TBD, 1, 4),\t\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t\t\t \n\t\t\tBTF_PTR_ENC(0),\t\t\t\t\t\t\t \n\t\t\tBTF_CONST_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_VOLATILE_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_RESTRICT_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 18),\n\t\t\tBTF_FUNC_ENC(NAME_TBD, 12),\t\t\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 2),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 13, -1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 13, 1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 7, -1),\t\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 8),\t\t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 2), 8),\t \n\t\t\t\tBTF_ENUM64_ENC(NAME_TBD, 0, 0),\n\t\t\t\tBTF_ENUM64_ENC(NAME_TBD, 1, 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0A\\0B\\0C\\0D\\0E\\0F\\0G\\0H\\0I\\0J\\0K\\0L\\0M\\0N\\0O\\0P\\0Q\\0R\\0S\\0T\\0U\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 8),\t\t \n\t\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM, 0, 2), 4),\t \n\t\t\t\tBTF_ENUM_ENC(NAME_TBD, 0),\n\t\t\t\tBTF_ENUM_ENC(NAME_TBD, 1),\n\t\t\tBTF_FWD_ENC(NAME_TBD, 1  ),\t\t\t \n\t\t\tBTF_TYPE_ARRAY_ENC(2, 1, 7),\t\t\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_TBD, 1, 4),\t\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\t\tBTF_UNION_ENC(NAME_TBD, 1, 4),\t\t\t\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_TBD, 1, 0),\n\t\t\tBTF_TYPEDEF_ENC(NAME_TBD, 1),\t\t\t\t\t \n\t\t\tBTF_PTR_ENC(0),\t\t\t\t\t\t\t \n\t\t\tBTF_CONST_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_VOLATILE_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_RESTRICT_ENC(8),\t\t\t\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(1, 2),\t\t\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 18),\n\t\t\tBTF_FUNC_ENC(NAME_TBD, 12),\t\t\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_TBD, 2),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 13, -1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 13, 1),\t\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_TBD, 7, -1),\t\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_TBD, 8),\t\t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 2), 8),\t \n\t\t\t\tBTF_ENUM64_ENC(NAME_TBD, 0, 0),\n\t\t\t\tBTF_ENUM64_ENC(NAME_TBD, 1, 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0A\\0B\\0C\\0D\\0E\\0F\\0G\\0H\\0I\\0J\\0K\\0L\\0M\\0N\\0O\\0P\\0Q\\0R\\0S\\0T\\0U\"),\n\t},\n},\n{\n\t.descr = \"dedup: no int/float duplicates\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_CHAR, 0, 32, 8),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_BOOL, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 8, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 27, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 2),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 4),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 8),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 12),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 16),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0some other int\\0float\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(2), BTF_INT_SIGNED, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_CHAR, 0, 32, 8),\n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_BOOL, 0, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 8, 32, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 27, 8),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(NAME_NTH(1), BTF_INT_SIGNED, 0, 32, 4),\n\t\t\t \n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 2),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 4),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 8),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 12),\n\t\t\tBTF_TYPE_FLOAT_ENC(NAME_NTH(3), 16),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0int\\0some other int\\0float\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum fwd resolution\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 0), 4),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 123),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(4), 456),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 0), 4),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 0), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 321),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0e2\\0e2_val\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 123),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(4), 456),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 321),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0e2\\0e2_val\"),\n\t},\n},\n{\n\t.descr = \"dedup: datasec and vars pass-through\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(2), 1, 0),\t\t\t \n\t\t\t \t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(2), 4, 0),\t\t\t \n\t\t\t \t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\t\tBTF_VAR_SECINFO_ENC(5, 0, 4),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0.bss\\0t\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(2), 1, 0),\t\t\t \n\t\t\t \t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t\t\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(2), 1, 0),\t\t\t \n\t\t\t \t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\t\tBTF_VAR_SECINFO_ENC(4, 0, 4),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0.bss\\0t\"),\n\t},\n\t.opts = {\n\t\t.force_collisions = true\n\t},\n},\n{\n\t.descr = \"dedup: func/func_arg/var tags\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(1), 1, 0),\t\t\t \n\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(2), 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(3), 1),\n\t\t\tBTF_FUNC_ENC(NAME_NTH(4), 2),\t\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0a1\\0a2\\0f\\0tag\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_VAR_ENC(NAME_NTH(1), 1, 0),\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(2), 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(3), 1),\n\t\t\tBTF_FUNC_ENC(NAME_NTH(4), 2),\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 4, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0a1\\0a2\\0f\\0tag\"),\n\t},\n},\n{\n\t.descr = \"dedup: func/func_param tags\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(1), 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(2), 1),\n\t\t\tBTF_FUNC_ENC(NAME_NTH(3), 2),\t\t\t \n\t\t\t \n\t\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(1), 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(2), 1),\n\t\t\tBTF_FUNC_ENC(NAME_NTH(3), 4),\t\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 3, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 3, 1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 5, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 5, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 5, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 5, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0a1\\0a2\\0f\\0tag1\\0tag2\\0tag3\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_FUNC_PROTO_ENC(0, 2),\t\t\t \n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(1), 1),\n\t\t\t\tBTF_FUNC_PROTO_ARG_ENC(NAME_NTH(2), 1),\n\t\t\tBTF_FUNC_ENC(NAME_NTH(3), 2),\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 3, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 3, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0a1\\0a2\\0f\\0tag1\\0tag2\\0tag3\"),\n\t},\n},\n{\n\t.descr = \"dedup: struct/struct_member tags\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 2, 8),\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 1, 0),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 1, 32),\n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 2, 8),\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 1, 0),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 1, 32),\n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 2, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, 1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 3, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 3, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0m1\\0m2\\0tag1\\0tag2\\0tag3\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 2, 8),\t\t \n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 1, 0),\n\t\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 1, 32),\n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 2, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(5), 2, 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(6), 2, 1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0m1\\0m2\\0tag1\\0tag2\\0tag3\"),\n\t},\n},\n{\n\t.descr = \"dedup: typedef tags\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(1), 1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(3), 2, -1),\t\t \n\t\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 3, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 3, -1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0tag1\\0tag2\\0tag3\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(2), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(3), 2, -1),\t\t \n\t\t\tBTF_DECL_TAG_ENC(NAME_NTH(4), 2, -1),\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0t\\0tag1\\0tag2\\0tag3\"),\n\t},\n},\n{\n\t.descr = \"dedup: btf_type_tag #1\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 5),\t\t \n\t\t\tBTF_PTR_ENC(6),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_PTR_ENC(8),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_PTR_ENC(2),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n},\n{\n\t.descr = \"dedup: btf_type_tag #2\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 1),\t\t \n\t\t\tBTF_PTR_ENC(5),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 1),\t\t \n\t\t\tBTF_PTR_ENC(5),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n},\n{\n\t.descr = \"dedup: btf_type_tag #3\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 5),\t\t \n\t\t\tBTF_PTR_ENC(6),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 2),\t\t \n\t\t\tBTF_PTR_ENC(3),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(2), 1),\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 5),\t\t \n\t\t\tBTF_PTR_ENC(6),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0tag2\"),\n\t},\n},\n{\n\t.descr = \"dedup: btf_type_tag #4\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_PTR_ENC(2),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 64, 8),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 4),\t\t \n\t\t\tBTF_PTR_ENC(5),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t \n\t\t\tBTF_PTR_ENC(2),\t\t\t\t\t \n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 64, 8),\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 4),\t\t \n\t\t\tBTF_PTR_ENC(5),\t\t\t\t\t \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\"),\n\t},\n},\n{\n\t.descr = \"dedup: btf_type_tag #5, struct\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(2), BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 1), 4),\t \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 2, BTF_MEMBER_OFFSET(0, 0)),\n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(2), BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 1), 4),\t \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 4, BTF_MEMBER_OFFSET(0, 0)),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0t\\0m\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),\t\t\t\t \n\t\t\tBTF_TYPE_TAG_ENC(NAME_NTH(1), 1),\t\t\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(2), BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 1), 4),\t \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 2, BTF_MEMBER_OFFSET(0, 0)),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0tag1\\0t\\0m\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum64, standalone\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 123),\n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 123),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 123),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum64, fwd resolution\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 0), 8),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 123),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(4), 0, 456),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 0), 8),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 0, 321),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0e2\\0e2_val\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 123),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(4), 0, 456),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 0, 321),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0e2\\0e2_val\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum and enum64, no dedup\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 4),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 4),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum of different size: no dedup\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 2),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 2),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum fwd to enum64\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 0),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 0), 4),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0), 2),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0td\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 1), 8),\n\t\t\t\tBTF_ENUM64_ENC(NAME_NTH(2), 1, 0),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0), 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0td\"),\n\t},\n},\n{\n\t.descr = \"dedup: enum64 fwd to enum\",\n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM64, 0, 0), 8),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0), 2),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0td\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(1), BTF_INFO_ENC(BTF_KIND_ENUM, 0, 1), 4),\n\t\t\t\tBTF_ENUM_ENC(NAME_NTH(2), 1),\n\t\t\t \n\t\t\tBTF_TYPE_ENC(NAME_NTH(3), BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0), 1),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0e1\\0e1_val\\0td\"),\n\t},\n},\n{\n\t.descr = \"dedup: standalone fwd declaration struct\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_NTH(1), 0),                    \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 4),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\tBTF_PTR_ENC(1),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 3),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n},\n{\n\t.descr = \"dedup: standalone fwd declaration union\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_UNION_ENC(NAME_NTH(1), 1, 4),               \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_TBD, 1),                       \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 4),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\tBTF_UNION_ENC(NAME_NTH(1), 1, 4),               \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\tBTF_PTR_ENC(1),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 3),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n},\n{\n\t.descr = \"dedup: standalone fwd declaration wrong kind\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_NTH(3), 1),                    \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 4),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_NTH(3), 1),                    \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(3), 4),                \n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0foo_ptr\"),\n\t},\n},\n{\n\t.descr = \"dedup: standalone fwd declaration name conflict\",\n\t \n\t.input = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_NTH(1), 0),                    \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(4), 4),                \n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 2, 8),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 2, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0y\\0foo_ptr\"),\n\t},\n\t.expect = {\n\t\t.raw_types = {\n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 1, 4),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  \n\t\t\t \n\t\t\tBTF_FWD_ENC(NAME_NTH(1), 0),                    \n\t\t\tBTF_PTR_ENC(3),                                 \n\t\t\tBTF_TYPEDEF_ENC(NAME_NTH(4), 4),                \n\t\t\t \n\t\t\tBTF_STRUCT_ENC(NAME_NTH(1), 2, 8),              \n\t\t\tBTF_MEMBER_ENC(NAME_NTH(2), 2, 0),\n\t\t\tBTF_MEMBER_ENC(NAME_NTH(3), 2, 0),\n\t\t\tBTF_END_RAW,\n\t\t},\n\t\tBTF_STR_SEC(\"\\0foo\\0x\\0y\\0foo_ptr\"),\n\t},\n},\n};\n\nstatic int btf_type_size(const struct btf_type *t)\n{\n\tint base_size = sizeof(struct btf_type);\n\t__u16 vlen = BTF_INFO_VLEN(t->info);\n\t__u16 kind = BTF_INFO_KIND(t->info);\n\n\tswitch (kind) {\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_PTR:\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_FUNC:\n\tcase BTF_KIND_FLOAT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn base_size;\n\tcase BTF_KIND_INT:\n\t\treturn base_size + sizeof(__u32);\n\tcase BTF_KIND_ENUM:\n\t\treturn base_size + vlen * sizeof(struct btf_enum);\n\tcase BTF_KIND_ENUM64:\n\t\treturn base_size + vlen * sizeof(struct btf_enum64);\n\tcase BTF_KIND_ARRAY:\n\t\treturn base_size + sizeof(struct btf_array);\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\treturn base_size + vlen * sizeof(struct btf_member);\n\tcase BTF_KIND_FUNC_PROTO:\n\t\treturn base_size + vlen * sizeof(struct btf_param);\n\tcase BTF_KIND_VAR:\n\t\treturn base_size + sizeof(struct btf_var);\n\tcase BTF_KIND_DATASEC:\n\t\treturn base_size + vlen * sizeof(struct btf_var_secinfo);\n\tcase BTF_KIND_DECL_TAG:\n\t\treturn base_size + sizeof(struct btf_decl_tag);\n\tdefault:\n\t\tfprintf(stderr, \"Unsupported BTF_KIND:%u\\n\", kind);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void dump_btf_strings(const char *strs, __u32 len)\n{\n\tconst char *cur = strs;\n\tint i = 0;\n\n\twhile (cur < strs + len) {\n\t\tfprintf(stderr, \"string #%d: '%s'\\n\", i, cur);\n\t\tcur += strlen(cur) + 1;\n\t\ti++;\n\t}\n}\n\nstatic void do_test_dedup(unsigned int test_num)\n{\n\tstruct btf_dedup_test *test = &dedup_tests[test_num - 1];\n\t__u32 test_nr_types, expect_nr_types, test_btf_size, expect_btf_size;\n\tconst struct btf_header *test_hdr, *expect_hdr;\n\tstruct btf *test_btf = NULL, *expect_btf = NULL;\n\tconst void *test_btf_data, *expect_btf_data;\n\tconst char *ret_test_next_str, *ret_expect_next_str;\n\tconst char *test_strs, *expect_strs;\n\tconst char *test_str_cur;\n\tconst char *expect_str_cur, *expect_str_end;\n\tunsigned int raw_btf_size;\n\tvoid *raw_btf;\n\tint err = 0, i;\n\n\tif (!test__start_subtest(test->descr))\n\t\treturn;\n\n\traw_btf = btf_raw_create(&hdr_tmpl, test->input.raw_types,\n\t\t\t\t test->input.str_sec, test->input.str_sec_size,\n\t\t\t\t &raw_btf_size, &ret_test_next_str);\n\tif (!raw_btf)\n\t\treturn;\n\n\ttest_btf = btf__new((__u8 *)raw_btf, raw_btf_size);\n\terr = libbpf_get_error(test_btf);\n\tfree(raw_btf);\n\tif (CHECK(err, \"invalid test_btf errno:%d\", err)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\traw_btf = btf_raw_create(&hdr_tmpl, test->expect.raw_types,\n\t\t\t\t test->expect.str_sec,\n\t\t\t\t test->expect.str_sec_size,\n\t\t\t\t &raw_btf_size, &ret_expect_next_str);\n\tif (!raw_btf)\n\t\treturn;\n\texpect_btf = btf__new((__u8 *)raw_btf, raw_btf_size);\n\terr = libbpf_get_error(expect_btf);\n\tfree(raw_btf);\n\tif (CHECK(err, \"invalid expect_btf errno:%d\", err)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\ttest->opts.sz = sizeof(test->opts);\n\terr = btf__dedup(test_btf, &test->opts);\n\tif (CHECK(err, \"btf_dedup failed errno:%d\", err)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\ttest_btf_data = btf__raw_data(test_btf, &test_btf_size);\n\texpect_btf_data = btf__raw_data(expect_btf, &expect_btf_size);\n\tif (CHECK(test_btf_size != expect_btf_size,\n\t\t  \"test_btf_size:%u != expect_btf_size:%u\",\n\t\t  test_btf_size, expect_btf_size)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\ttest_hdr = test_btf_data;\n\ttest_strs = test_btf_data + sizeof(*test_hdr) + test_hdr->str_off;\n\texpect_hdr = expect_btf_data;\n\texpect_strs = expect_btf_data + sizeof(*test_hdr) + expect_hdr->str_off;\n\tif (CHECK(test_hdr->str_len != expect_hdr->str_len,\n\t\t  \"test_hdr->str_len:%u != expect_hdr->str_len:%u\",\n\t\t  test_hdr->str_len, expect_hdr->str_len)) {\n\t\tfprintf(stderr, \"\\ntest strings:\\n\");\n\t\tdump_btf_strings(test_strs, test_hdr->str_len);\n\t\tfprintf(stderr, \"\\nexpected strings:\\n\");\n\t\tdump_btf_strings(expect_strs, expect_hdr->str_len);\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\texpect_str_cur = expect_strs;\n\texpect_str_end = expect_strs + expect_hdr->str_len;\n\twhile (expect_str_cur < expect_str_end) {\n\t\tsize_t test_len, expect_len;\n\t\tint off;\n\n\t\toff = btf__find_str(test_btf, expect_str_cur);\n\t\tif (CHECK(off < 0, \"exp str '%s' not found: %d\\n\", expect_str_cur, off)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\ttest_str_cur = btf__str_by_offset(test_btf, off);\n\n\t\ttest_len = strlen(test_str_cur);\n\t\texpect_len = strlen(expect_str_cur);\n\t\tif (CHECK(test_len != expect_len,\n\t\t\t  \"test_len:%zu != expect_len:%zu \"\n\t\t\t  \"(test_str:%s, expect_str:%s)\",\n\t\t\t  test_len, expect_len, test_str_cur, expect_str_cur)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (CHECK(strcmp(test_str_cur, expect_str_cur),\n\t\t\t  \"test_str:%s != expect_str:%s\",\n\t\t\t  test_str_cur, expect_str_cur)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\texpect_str_cur += expect_len + 1;\n\t}\n\n\ttest_nr_types = btf__type_cnt(test_btf);\n\texpect_nr_types = btf__type_cnt(expect_btf);\n\tif (CHECK(test_nr_types != expect_nr_types,\n\t\t  \"test_nr_types:%u != expect_nr_types:%u\",\n\t\t  test_nr_types, expect_nr_types)) {\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tfor (i = 1; i < test_nr_types; i++) {\n\t\tconst struct btf_type *test_type, *expect_type;\n\t\tint test_size, expect_size;\n\n\t\ttest_type = btf__type_by_id(test_btf, i);\n\t\texpect_type = btf__type_by_id(expect_btf, i);\n\t\ttest_size = btf_type_size(test_type);\n\t\texpect_size = btf_type_size(expect_type);\n\n\t\tif (CHECK(test_size != expect_size,\n\t\t\t  \"type #%d: test_size:%d != expect_size:%u\",\n\t\t\t  i, test_size, expect_size)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (CHECK(btf_kind(test_type) != btf_kind(expect_type),\n\t\t\t  \"type %d kind: exp %d != got %u\\n\",\n\t\t\t  i, btf_kind(expect_type), btf_kind(test_type))) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (CHECK(test_type->info != expect_type->info,\n\t\t\t  \"type %d info: exp %d != got %u\\n\",\n\t\t\t  i, expect_type->info, test_type->info)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (CHECK(test_type->size != expect_type->size,\n\t\t\t  \"type %d size/type: exp %d != got %u\\n\",\n\t\t\t  i, expect_type->size, test_type->size)) {\n\t\t\terr = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tbtf__free(test_btf);\n\tbtf__free(expect_btf);\n}\n\nvoid test_btf(void)\n{\n\tint i;\n\n\talways_log = env.verbosity > VERBOSE_NONE;\n\n\tfor (i = 1; i <= ARRAY_SIZE(raw_tests); i++)\n\t\tdo_test_raw(i);\n\tfor (i = 1; i <= ARRAY_SIZE(get_info_tests); i++)\n\t\tdo_test_get_info(i);\n\tfor (i = 1; i <= ARRAY_SIZE(file_tests); i++)\n\t\tdo_test_file(i);\n\tfor (i = 1; i <= ARRAY_SIZE(info_raw_tests); i++)\n\t\tdo_test_info_raw(i);\n\tfor (i = 1; i <= ARRAY_SIZE(dedup_tests); i++)\n\t\tdo_test_dedup(i);\n\ttest_pprint();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}