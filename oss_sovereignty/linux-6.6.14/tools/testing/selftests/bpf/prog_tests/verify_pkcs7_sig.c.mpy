{
  "module_name": "verify_pkcs7_sig.c",
  "hash_id": "aa6fb98ce246084e4f76f76246e6cf7fc9fcbaad476ec23fc8ab48b71a9947f3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/verify_pkcs7_sig.c",
  "human_readable_source": "\n\n \n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <endian.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <linux/keyctl.h>\n#include <test_progs.h>\n\n#include \"test_verify_pkcs7_sig.skel.h\"\n\n#define MAX_DATA_SIZE (1024 * 1024)\n#define MAX_SIG_SIZE 1024\n\n#define VERIFY_USE_SECONDARY_KEYRING (1UL)\n#define VERIFY_USE_PLATFORM_KEYRING  (2UL)\n\n \n#define MODULE_SIG_STRING \"~Module signature appended~\\n\"\n\n \nstruct module_signature {\n\t__u8\talgo;\t\t \n\t__u8\thash;\t\t \n\t__u8\tid_type;\t \n\t__u8\tsigner_len;\t \n\t__u8\tkey_id_len;\t \n\t__u8\t__pad[3];\n\t__be32\tsig_len;\t \n};\n\nstruct data {\n\t__u8 data[MAX_DATA_SIZE];\n\t__u32 data_len;\n\t__u8 sig[MAX_SIG_SIZE];\n\t__u32 sig_len;\n};\n\nstatic bool kfunc_not_supported;\n\nstatic int libbpf_print_cb(enum libbpf_print_level level, const char *fmt,\n\t\t\t   va_list args)\n{\n\tif (level == LIBBPF_WARN)\n\t\tvprintf(fmt, args);\n\n\tif (strcmp(fmt, \"libbpf: extern (func ksym) '%s': not found in kernel or module BTFs\\n\"))\n\t\treturn 0;\n\n\tif (strcmp(va_arg(args, char *), \"bpf_verify_pkcs7_signature\"))\n\t\treturn 0;\n\n\tkfunc_not_supported = true;\n\treturn 0;\n}\n\nstatic int _run_setup_process(const char *setup_dir, const char *cmd)\n{\n\tint child_pid, child_status;\n\n\tchild_pid = fork();\n\tif (child_pid == 0) {\n\t\texeclp(\"./verify_sig_setup.sh\", \"./verify_sig_setup.sh\", cmd,\n\t\t       setup_dir, NULL);\n\t\texit(errno);\n\n\t} else if (child_pid > 0) {\n\t\twaitpid(child_pid, &child_status, 0);\n\t\treturn WEXITSTATUS(child_status);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int populate_data_item_str(const char *tmp_dir, struct data *data_item)\n{\n\tstruct stat st;\n\tchar data_template[] = \"/tmp/dataXXXXXX\";\n\tchar path[PATH_MAX];\n\tint ret, fd, child_status, child_pid;\n\n\tdata_item->data_len = 4;\n\tmemcpy(data_item->data, \"test\", data_item->data_len);\n\n\tfd = mkstemp(data_template);\n\tif (fd == -1)\n\t\treturn -errno;\n\n\tret = write(fd, data_item->data, data_item->data_len);\n\n\tclose(fd);\n\n\tif (ret != data_item->data_len) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tchild_pid = fork();\n\n\tif (child_pid == -1) {\n\t\tret = -errno;\n\t\tgoto out;\n\t}\n\n\tif (child_pid == 0) {\n\t\tsnprintf(path, sizeof(path), \"%s/signing_key.pem\", tmp_dir);\n\n\t\treturn execlp(\"./sign-file\", \"./sign-file\", \"-d\", \"sha256\",\n\t\t\t      path, path, data_template, NULL);\n\t}\n\n\twaitpid(child_pid, &child_status, 0);\n\n\tret = WEXITSTATUS(child_status);\n\tif (ret)\n\t\tgoto out;\n\n\tsnprintf(path, sizeof(path), \"%s.p7s\", data_template);\n\n\tret = stat(path, &st);\n\tif (ret == -1) {\n\t\tret = -errno;\n\t\tgoto out;\n\t}\n\n\tif (st.st_size > sizeof(data_item->sig)) {\n\t\tret = -EINVAL;\n\t\tgoto out_sig;\n\t}\n\n\tdata_item->sig_len = st.st_size;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1) {\n\t\tret = -errno;\n\t\tgoto out_sig;\n\t}\n\n\tret = read(fd, data_item->sig, data_item->sig_len);\n\n\tclose(fd);\n\n\tif (ret != data_item->sig_len) {\n\t\tret = -EIO;\n\t\tgoto out_sig;\n\t}\n\n\tret = 0;\nout_sig:\n\tunlink(path);\nout:\n\tunlink(data_template);\n\treturn ret;\n}\n\nstatic int populate_data_item_mod(struct data *data_item)\n{\n\tchar mod_path[PATH_MAX], *mod_path_ptr;\n\tstruct stat st;\n\tvoid *mod;\n\tFILE *fp;\n\tstruct module_signature ms;\n\tint ret, fd, modlen, marker_len, sig_len;\n\n\tdata_item->data_len = 0;\n\n\tif (stat(\"/lib/modules\", &st) == -1)\n\t\treturn 0;\n\n\t \n\tfp = popen(\"find /lib/modules/$(uname -r) -name tcp_bic.ko\", \"r\");\n\tif (!fp)\n\t\treturn 0;\n\n\tmod_path_ptr = fgets(mod_path, sizeof(mod_path), fp);\n\tpclose(fp);\n\n\tif (!mod_path_ptr)\n\t\treturn 0;\n\n\tmod_path_ptr = strchr(mod_path, '\\n');\n\tif (!mod_path_ptr)\n\t\treturn 0;\n\n\t*mod_path_ptr = '\\0';\n\n\tif (stat(mod_path, &st) == -1)\n\t\treturn 0;\n\n\tmodlen = st.st_size;\n\tmarker_len = sizeof(MODULE_SIG_STRING) - 1;\n\n\tfd = open(mod_path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -errno;\n\n\tmod = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\tclose(fd);\n\n\tif (mod == MAP_FAILED)\n\t\treturn -errno;\n\n\tif (strncmp(mod + modlen - marker_len, MODULE_SIG_STRING, marker_len)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmodlen -= marker_len;\n\n\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));\n\n\tsig_len = __be32_to_cpu(ms.sig_len);\n\tmodlen -= sig_len + sizeof(ms);\n\n\tif (modlen > sizeof(data_item->data)) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tmemcpy(data_item->data, mod, modlen);\n\tdata_item->data_len = modlen;\n\n\tif (sig_len > sizeof(data_item->sig)) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tmemcpy(data_item->sig, mod + modlen, sig_len);\n\tdata_item->sig_len = sig_len;\n\tret = 0;\nout:\n\tmunmap(mod, st.st_size);\n\treturn ret;\n}\n\nvoid test_verify_pkcs7_sig(void)\n{\n\tlibbpf_print_fn_t old_print_cb;\n\tchar tmp_dir_template[] = \"/tmp/verify_sigXXXXXX\";\n\tchar *tmp_dir;\n\tstruct test_verify_pkcs7_sig *skel = NULL;\n\tstruct bpf_map *map;\n\tstruct data data;\n\tint ret, zero = 0;\n\n\t \n\tsyscall(__NR_request_key, \"keyring\", \"_uid.0\", NULL,\n\t\tKEY_SPEC_SESSION_KEYRING);\n\n\ttmp_dir = mkdtemp(tmp_dir_template);\n\tif (!ASSERT_OK_PTR(tmp_dir, \"mkdtemp\"))\n\t\treturn;\n\n\tret = _run_setup_process(tmp_dir, \"setup\");\n\tif (!ASSERT_OK(ret, \"_run_setup_process\"))\n\t\tgoto close_prog;\n\n\tskel = test_verify_pkcs7_sig__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_verify_pkcs7_sig__open\"))\n\t\tgoto close_prog;\n\n\told_print_cb = libbpf_set_print(libbpf_print_cb);\n\tret = test_verify_pkcs7_sig__load(skel);\n\tlibbpf_set_print(old_print_cb);\n\n\tif (ret < 0 && kfunc_not_supported) {\n\t\tprintf(\n\t\t  \"%s:SKIP:bpf_verify_pkcs7_signature() kfunc not supported\\n\",\n\t\t  __func__);\n\t\ttest__skip();\n\t\tgoto close_prog;\n\t}\n\n\tif (!ASSERT_OK(ret, \"test_verify_pkcs7_sig__load\"))\n\t\tgoto close_prog;\n\n\tret = test_verify_pkcs7_sig__attach(skel);\n\tif (!ASSERT_OK(ret, \"test_verify_pkcs7_sig__attach\"))\n\t\tgoto close_prog;\n\n\tmap = bpf_object__find_map_by_name(skel->obj, \"data_input\");\n\tif (!ASSERT_OK_PTR(map, \"data_input not found\"))\n\t\tgoto close_prog;\n\n\tskel->bss->monitored_pid = getpid();\n\n\t \n\tskel->bss->user_keyring_serial = KEY_SPEC_SESSION_KEYRING;\n\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_LT(ret, 0, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\t \n\tret = populate_data_item_str(tmp_dir, &data);\n\tif (!ASSERT_OK(ret, \"populate_data_item_str\"))\n\t\tgoto close_prog;\n\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_OK(ret, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\t \n\tskel->bss->user_keyring_serial = syscall(__NR_request_key, \"keyring\",\n\t\t\t\t\t\t \"ebpf_testing_keyring\", NULL,\n\t\t\t\t\t\t KEY_SPEC_SESSION_KEYRING);\n\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_OK(ret, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\t \n\tsyscall(__NR_keyctl, KEYCTL_SETPERM, skel->bss->user_keyring_serial,\n\t\t0x37373737);\n\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_LT(ret, 0, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\tsyscall(__NR_keyctl, KEYCTL_SETPERM, skel->bss->user_keyring_serial,\n\t\t0x3f3f3f3f);\n\n\t \n\tsyscall(__NR_keyctl, KEYCTL_SET_TIMEOUT,\n\t\tskel->bss->user_keyring_serial, 1);\n\tsleep(1);\n\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_LT(ret, 0, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\tskel->bss->user_keyring_serial = KEY_SPEC_SESSION_KEYRING;\n\n\t \n\tdata.data[0] = 'a';\n\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data, BPF_ANY);\n\tif (!ASSERT_LT(ret, 0, \"bpf_map_update_elem data_input\"))\n\t\tgoto close_prog;\n\n\tret = populate_data_item_mod(&data);\n\tif (!ASSERT_OK(ret, \"populate_data_item_mod\"))\n\t\tgoto close_prog;\n\n\t \n\tif (data.data_len) {\n\t\tskel->bss->user_keyring_serial = 0;\n\t\tskel->bss->system_keyring_id = 0;\n\n\t\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data,\n\t\t\t\t\t  BPF_ANY);\n\t\tif (!ASSERT_OK(ret, \"bpf_map_update_elem data_input\"))\n\t\t\tgoto close_prog;\n\n\t\tskel->bss->system_keyring_id = VERIFY_USE_SECONDARY_KEYRING;\n\n\t\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data,\n\t\t\t\t\t  BPF_ANY);\n\t\tif (!ASSERT_OK(ret, \"bpf_map_update_elem data_input\"))\n\t\t\tgoto close_prog;\n\n\t\tskel->bss->system_keyring_id = VERIFY_USE_PLATFORM_KEYRING;\n\n\t\tret = bpf_map_update_elem(bpf_map__fd(map), &zero, &data,\n\t\t\t\t\t  BPF_ANY);\n\t\tASSERT_LT(ret, 0, \"bpf_map_update_elem data_input\");\n\t}\n\nclose_prog:\n\t_run_setup_process(tmp_dir, \"cleanup\");\n\n\tif (!skel)\n\t\treturn;\n\n\tskel->bss->monitored_pid = 0;\n\ttest_verify_pkcs7_sig__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}