{
  "module_name": "tailcalls.c",
  "hash_id": "f9eea4e04ac8f98a7b8189f7549044b5f999be97bf5df70bd661845a4b59f6ac",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tailcalls.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\n \nstatic void test_tailcall_1(void)\n{\n\tint err, map_fd, prog_fd, main_fd, i, j;\n\tstruct bpf_map *prog_array;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar prog_name[32];\n\tchar buff[128] = {};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall1.bpf.o\", BPF_PROG_TYPE_SCHED_CLS, &obj,\n\t\t\t\t &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, i, \"tailcall retval\");\n\n\t\terr = bpf_map_delete_elem(map_fd, &i);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_OK(topts.retval, \"tailcall retval\");\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tj = bpf_map__max_entries(prog_array) - 1 - i;\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", j);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tj = bpf_map__max_entries(prog_array) - 1 - i;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, j, \"tailcall retval\");\n\n\t\terr = bpf_map_delete_elem(map_fd, &i);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_map_delete_elem(map_fd, &i);\n\t\tif (CHECK_FAIL(err >= 0 || errno != ENOENT))\n\t\t\tgoto out;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\n\t}\n\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_2(void)\n{\n\tint err, map_fd, prog_fd, main_fd, i;\n\tstruct bpf_map *prog_array;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar prog_name[32];\n\tchar buff[128] = {};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall2.bpf.o\", BPF_PROG_TYPE_SCHED_CLS, &obj,\n\t\t\t\t &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 2, \"tailcall retval\");\n\n\ti = 2;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 1, \"tailcall retval\");\n\n\ti = 0;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\nout:\n\tbpf_object__close(obj);\n}\n\nstatic void test_tailcall_count(const char *which)\n{\n\tint err, map_fd, prog_fd, main_fd, data_fd, i, val;\n\tstruct bpf_map *prog_array, *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar buff[128] = {};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(which, BPF_PROG_TYPE_SCHED_CLS, &obj,\n\t\t\t    &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tprog = bpf_object__find_program_by_name(obj, \"classifier_0\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(prog_fd < 0))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 1, \"tailcall retval\");\n\n\tdata_map = bpf_object__find_map_by_name(obj, \"tailcall.bss\");\n\tif (CHECK_FAIL(!data_map || !bpf_map__is_internal(data_map)))\n\t\tgoto out;\n\n\tdata_fd = bpf_map__fd(data_map);\n\tif (CHECK_FAIL(data_fd < 0))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_lookup_elem(data_fd, &i, &val);\n\tASSERT_OK(err, \"tailcall count\");\n\tASSERT_EQ(val, 33, \"tailcall count\");\n\n\ti = 0;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_OK(topts.retval, \"tailcall retval\");\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_3(void)\n{\n\ttest_tailcall_count(\"tailcall3.bpf.o\");\n}\n\n \nstatic void test_tailcall_6(void)\n{\n\ttest_tailcall_count(\"tailcall6.bpf.o\");\n}\n\n \nstatic void test_tailcall_4(void)\n{\n\tint err, map_fd, prog_fd, main_fd, data_fd, i;\n\tstruct bpf_map *prog_array, *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tstatic const int zero = 0;\n\tchar buff[128] = {};\n\tchar prog_name[32];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall4.bpf.o\", BPF_PROG_TYPE_SCHED_CLS, &obj,\n\t\t\t\t &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tdata_map = bpf_object__find_map_by_name(obj, \"tailcall.bss\");\n\tif (CHECK_FAIL(!data_map || !bpf_map__is_internal(data_map)))\n\t\tgoto out;\n\n\tdata_fd = bpf_map__fd(data_map);\n\tif (CHECK_FAIL(data_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_map_update_elem(data_fd, &zero, &i, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, i, \"tailcall retval\");\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_map_update_elem(data_fd, &zero, &i, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_delete_elem(map_fd, &i);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\n\t}\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_5(void)\n{\n\tint err, map_fd, prog_fd, main_fd, data_fd, i, key[] = { 1111, 1234, 5678 };\n\tstruct bpf_map *prog_array, *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tstatic const int zero = 0;\n\tchar buff[128] = {};\n\tchar prog_name[32];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall5.bpf.o\", BPF_PROG_TYPE_SCHED_CLS, &obj,\n\t\t\t\t &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tdata_map = bpf_object__find_map_by_name(obj, \"tailcall.bss\");\n\tif (CHECK_FAIL(!data_map || !bpf_map__is_internal(data_map)))\n\t\tgoto out;\n\n\tdata_fd = bpf_map__fd(data_map);\n\tif (CHECK_FAIL(data_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_map_update_elem(data_fd, &zero, &key[i], BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, i, \"tailcall retval\");\n\t}\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\terr = bpf_map_update_elem(data_fd, &zero, &key[i], BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_delete_elem(map_fd, &i);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\n\t\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\t\tASSERT_OK(err, \"tailcall\");\n\t\tASSERT_EQ(topts.retval, 3, \"tailcall retval\");\n\t}\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_bpf2bpf_1(void)\n{\n\tint err, map_fd, prog_fd, main_fd, i;\n\tstruct bpf_map *prog_array;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar prog_name[32];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall_bpf2bpf1.bpf.o\", BPF_PROG_TYPE_SCHED_CLS,\n\t\t\t\t &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 1, \"tailcall retval\");\n\n\t \n\ti = 1;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_OK(topts.retval, \"tailcall retval\");\n\n\t \n\ti = 0;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, sizeof(pkt_v4) * 2, \"tailcall retval\");\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_bpf2bpf_2(void)\n{\n\tint err, map_fd, prog_fd, main_fd, data_fd, i, val;\n\tstruct bpf_map *prog_array, *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar buff[128] = {};\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = buff,\n\t\t.data_size_in = sizeof(buff),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall_bpf2bpf2.bpf.o\", BPF_PROG_TYPE_SCHED_CLS,\n\t\t\t\t &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tprog = bpf_object__find_program_by_name(obj, \"classifier_0\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(prog_fd < 0))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, 1, \"tailcall retval\");\n\n\tdata_map = bpf_object__find_map_by_name(obj, \"tailcall.bss\");\n\tif (CHECK_FAIL(!data_map || !bpf_map__is_internal(data_map)))\n\t\tgoto out;\n\n\tdata_fd = bpf_map__fd(data_map);\n\tif (CHECK_FAIL(data_fd < 0))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_lookup_elem(data_fd, &i, &val);\n\tASSERT_OK(err, \"tailcall count\");\n\tASSERT_EQ(val, 33, \"tailcall count\");\n\n\ti = 0;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_OK(topts.retval, \"tailcall retval\");\nout:\n\tbpf_object__close(obj);\n}\n\n \nstatic void test_tailcall_bpf2bpf_3(void)\n{\n\tint err, map_fd, prog_fd, main_fd, i;\n\tstruct bpf_map *prog_array;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar prog_name[32];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall_bpf2bpf3.bpf.o\", BPF_PROG_TYPE_SCHED_CLS,\n\t\t\t\t &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, sizeof(pkt_v4) * 3, \"tailcall retval\");\n\n\ti = 1;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, sizeof(pkt_v4), \"tailcall retval\");\n\n\ti = 0;\n\terr = bpf_map_delete_elem(map_fd, &i);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, sizeof(pkt_v4) * 2, \"tailcall retval\");\nout:\n\tbpf_object__close(obj);\n}\n\n#include \"tailcall_bpf2bpf4.skel.h\"\n\n \nstatic void test_tailcall_bpf2bpf_4(bool noise)\n{\n\tint err, map_fd, prog_fd, main_fd, data_fd, i;\n\tstruct tailcall_bpf2bpf4__bss val;\n\tstruct bpf_map *prog_array, *data_map;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar prog_name[32];\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(\"tailcall_bpf2bpf4.bpf.o\", BPF_PROG_TYPE_SCHED_CLS,\n\t\t\t\t &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, \"entry\");\n\tif (CHECK_FAIL(!prog))\n\t\tgoto out;\n\n\tmain_fd = bpf_program__fd(prog);\n\tif (CHECK_FAIL(main_fd < 0))\n\t\tgoto out;\n\n\tprog_array = bpf_object__find_map_by_name(obj, \"jmp_table\");\n\tif (CHECK_FAIL(!prog_array))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(prog_array);\n\tif (CHECK_FAIL(map_fd < 0))\n\t\tgoto out;\n\n\tfor (i = 0; i < bpf_map__max_entries(prog_array); i++) {\n\t\tsnprintf(prog_name, sizeof(prog_name), \"classifier_%d\", i);\n\n\t\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\t\tif (CHECK_FAIL(!prog))\n\t\t\tgoto out;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (CHECK_FAIL(prog_fd < 0))\n\t\t\tgoto out;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\tdata_map = bpf_object__find_map_by_name(obj, \"tailcall.bss\");\n\tif (CHECK_FAIL(!data_map || !bpf_map__is_internal(data_map)))\n\t\tgoto out;\n\n\tdata_fd = bpf_map__fd(data_map);\n\tif (CHECK_FAIL(data_fd < 0))\n\t\tgoto out;\n\n\ti = 0;\n\tval.noise = noise;\n\tval.count = 0;\n\terr = bpf_map_update_elem(data_fd, &i, &val, BPF_ANY);\n\tif (CHECK_FAIL(err))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"tailcall\");\n\tASSERT_EQ(topts.retval, sizeof(pkt_v4) * 3, \"tailcall retval\");\n\n\ti = 0;\n\terr = bpf_map_lookup_elem(data_fd, &i, &val);\n\tASSERT_OK(err, \"tailcall count\");\n\tASSERT_EQ(val.count, 31, \"tailcall count\");\n\nout:\n\tbpf_object__close(obj);\n}\n\n#include \"tailcall_bpf2bpf6.skel.h\"\n\n \nstatic void test_tailcall_bpf2bpf_6(void)\n{\n\tstruct tailcall_bpf2bpf6 *obj;\n\tint err, map_fd, prog_fd, main_fd, data_fd, i, val;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tobj = tailcall_bpf2bpf6__open_and_load();\n\tif (!ASSERT_OK_PTR(obj, \"open and load\"))\n\t\treturn;\n\n\tmain_fd = bpf_program__fd(obj->progs.entry);\n\tif (!ASSERT_GE(main_fd, 0, \"entry prog fd\"))\n\t\tgoto out;\n\n\tmap_fd = bpf_map__fd(obj->maps.jmp_table);\n\tif (!ASSERT_GE(map_fd, 0, \"jmp_table map fd\"))\n\t\tgoto out;\n\n\tprog_fd = bpf_program__fd(obj->progs.classifier_0);\n\tif (!ASSERT_GE(prog_fd, 0, \"classifier_0 prog fd\"))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_update_elem(map_fd, &i, &prog_fd, BPF_ANY);\n\tif (!ASSERT_OK(err, \"jmp_table map update\"))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(main_fd, &topts);\n\tASSERT_OK(err, \"entry prog test run\");\n\tASSERT_EQ(topts.retval, 0, \"tailcall retval\");\n\n\tdata_fd = bpf_map__fd(obj->maps.bss);\n\tif (!ASSERT_GE(data_fd, 0, \"bss map fd\"))\n\t\tgoto out;\n\n\ti = 0;\n\terr = bpf_map_lookup_elem(data_fd, &i, &val);\n\tASSERT_OK(err, \"bss map lookup\");\n\tASSERT_EQ(val, 1, \"done flag is set\");\n\nout:\n\ttailcall_bpf2bpf6__destroy(obj);\n}\n\nvoid test_tailcalls(void)\n{\n\tif (test__start_subtest(\"tailcall_1\"))\n\t\ttest_tailcall_1();\n\tif (test__start_subtest(\"tailcall_2\"))\n\t\ttest_tailcall_2();\n\tif (test__start_subtest(\"tailcall_3\"))\n\t\ttest_tailcall_3();\n\tif (test__start_subtest(\"tailcall_4\"))\n\t\ttest_tailcall_4();\n\tif (test__start_subtest(\"tailcall_5\"))\n\t\ttest_tailcall_5();\n\tif (test__start_subtest(\"tailcall_6\"))\n\t\ttest_tailcall_6();\n\tif (test__start_subtest(\"tailcall_bpf2bpf_1\"))\n\t\ttest_tailcall_bpf2bpf_1();\n\tif (test__start_subtest(\"tailcall_bpf2bpf_2\"))\n\t\ttest_tailcall_bpf2bpf_2();\n\tif (test__start_subtest(\"tailcall_bpf2bpf_3\"))\n\t\ttest_tailcall_bpf2bpf_3();\n\tif (test__start_subtest(\"tailcall_bpf2bpf_4\"))\n\t\ttest_tailcall_bpf2bpf_4(false);\n\tif (test__start_subtest(\"tailcall_bpf2bpf_5\"))\n\t\ttest_tailcall_bpf2bpf_4(true);\n\tif (test__start_subtest(\"tailcall_bpf2bpf_6\"))\n\t\ttest_tailcall_bpf2bpf_6();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}