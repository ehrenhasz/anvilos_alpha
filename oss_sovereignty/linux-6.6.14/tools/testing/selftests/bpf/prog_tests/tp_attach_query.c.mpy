{
  "module_name": "tp_attach_query.c",
  "hash_id": "b042975b3ca4307d49ba7983c6e91493346edc8d06cec159b7b93d4a9ded9612",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tp_attach_query.c",
  "human_readable_source": "\n#include <test_progs.h>\n\nvoid serial_test_tp_attach_query(void)\n{\n\tconst int num_progs = 3;\n\tint i, j, bytes, efd, err, prog_fd[num_progs], pmu_fd[num_progs];\n\t__u32 duration = 0, info_len, saved_prog_ids[num_progs];\n\tconst char *file = \"./test_tracepoint.bpf.o\";\n\tstruct perf_event_query_bpf *query;\n\tstruct perf_event_attr attr = {};\n\tstruct bpf_object *obj[num_progs];\n\tstruct bpf_prog_info prog_info;\n\tchar buf[256];\n\n\tfor (i = 0; i < num_progs; i++)\n\t\tobj[i] = NULL;\n\n\tif (access(\"/sys/kernel/tracing/trace\", F_OK) == 0) {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"/sys/kernel/tracing/events/sched/sched_switch/id\");\n\t} else {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"/sys/kernel/debug/tracing/events/sched/sched_switch/id\");\n\t}\n\tefd = open(buf, O_RDONLY, 0);\n\tif (CHECK(efd < 0, \"open\", \"err %d errno %d\\n\", efd, errno))\n\t\treturn;\n\tbytes = read(efd, buf, sizeof(buf));\n\tclose(efd);\n\tif (CHECK(bytes <= 0 || bytes >= sizeof(buf),\n\t\t  \"read\", \"bytes %d errno %d\\n\", bytes, errno))\n\t\treturn;\n\n\tattr.config = strtol(buf, NULL, 0);\n\tattr.type = PERF_TYPE_TRACEPOINT;\n\tattr.sample_type = PERF_SAMPLE_RAW | PERF_SAMPLE_CALLCHAIN;\n\tattr.sample_period = 1;\n\tattr.wakeup_events = 1;\n\n\tquery = malloc(sizeof(*query) + sizeof(__u32) * num_progs);\n\tfor (i = 0; i < num_progs; i++) {\n\t\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_TRACEPOINT, &obj[i],\n\t\t\t\t    &prog_fd[i]);\n\t\tif (CHECK(err, \"prog_load\", \"err %d errno %d\\n\", err, errno))\n\t\t\tgoto cleanup1;\n\n\t\tbzero(&prog_info, sizeof(prog_info));\n\t\tprog_info.jited_prog_len = 0;\n\t\tprog_info.xlated_prog_len = 0;\n\t\tprog_info.nr_map_ids = 0;\n\t\tinfo_len = sizeof(prog_info);\n\t\terr = bpf_prog_get_info_by_fd(prog_fd[i], &prog_info,\n\t\t\t\t\t      &info_len);\n\t\tif (CHECK(err, \"bpf_prog_get_info_by_fd\", \"err %d errno %d\\n\",\n\t\t\t  err, errno))\n\t\t\tgoto cleanup1;\n\t\tsaved_prog_ids[i] = prog_info.id;\n\n\t\tpmu_fd[i] = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t\t    0  , -1  ,\n\t\t\t\t    0  );\n\t\tif (CHECK(pmu_fd[i] < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t\t  pmu_fd[i], errno))\n\t\t\tgoto cleanup2;\n\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_ENABLE, 0);\n\t\tif (CHECK(err, \"perf_event_ioc_enable\", \"err %d errno %d\\n\",\n\t\t\t  err, errno))\n\t\t\tgoto cleanup3;\n\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tquery->ids_len = num_progs;\n\t\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_QUERY_BPF, query);\n\t\t\tif (CHECK(err || query->prog_cnt != 0,\n\t\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t\t  \"err %d errno %d query->prog_cnt %u\\n\",\n\t\t\t\t  err, errno, query->prog_cnt))\n\t\t\t\tgoto cleanup3;\n\t\t}\n\n\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_SET_BPF, prog_fd[i]);\n\t\tif (CHECK(err, \"perf_event_ioc_set_bpf\", \"err %d errno %d\\n\",\n\t\t\t  err, errno))\n\t\t\tgoto cleanup3;\n\n\t\tif (i == 1) {\n\t\t\t \n\t\t\tquery->ids_len = 0;\n\t\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_QUERY_BPF, query);\n\t\t\tif (CHECK(err || query->prog_cnt != 2,\n\t\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t\t  \"err %d errno %d query->prog_cnt %u\\n\",\n\t\t\t\t  err, errno, query->prog_cnt))\n\t\t\t\tgoto cleanup3;\n\n\t\t\t \n\t\t\t \n\t\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_QUERY_BPF,\n\t\t\t\t    (struct perf_event_query_bpf *)0x1);\n\t\t\tif (CHECK(!err || errno != EFAULT,\n\t\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t\t  \"err %d errno %d\\n\", err, errno))\n\t\t\t\tgoto cleanup3;\n\n\t\t\t \n\t\t\tquery->ids_len = 1;\n\t\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_QUERY_BPF, query);\n\t\t\tif (CHECK(!err || errno != ENOSPC || query->prog_cnt != 2,\n\t\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t\t  \"err %d errno %d query->prog_cnt %u\\n\",\n\t\t\t\t  err, errno, query->prog_cnt))\n\t\t\t\tgoto cleanup3;\n\t\t}\n\n\t\tquery->ids_len = num_progs;\n\t\terr = ioctl(pmu_fd[i], PERF_EVENT_IOC_QUERY_BPF, query);\n\t\tif (CHECK(err || query->prog_cnt != (i + 1),\n\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t  \"err %d errno %d query->prog_cnt %u\\n\",\n\t\t\t  err, errno, query->prog_cnt))\n\t\t\tgoto cleanup3;\n\t\tfor (j = 0; j < i + 1; j++)\n\t\t\tif (CHECK(saved_prog_ids[j] != query->ids[j],\n\t\t\t\t  \"perf_event_ioc_query_bpf\",\n\t\t\t\t  \"#%d saved_prog_id %x query prog_id %x\\n\",\n\t\t\t\t  j, saved_prog_ids[j], query->ids[j]))\n\t\t\t\tgoto cleanup3;\n\t}\n\n\ti = num_progs - 1;\n\tfor (; i >= 0; i--) {\n cleanup3:\n\t\tioctl(pmu_fd[i], PERF_EVENT_IOC_DISABLE);\n cleanup2:\n\t\tclose(pmu_fd[i]);\n cleanup1:\n\t\tbpf_object__close(obj[i]);\n\t}\n\tfree(query);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}