{
  "module_name": "bpf_mod_race.c",
  "hash_id": "04da51b967c186f40dd9bf85b9840db1bb22ded8e958cbc14803fdc5a7074196",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_mod_race.c",
  "human_readable_source": "\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <stdatomic.h>\n#include <test_progs.h>\n#include <sys/syscall.h>\n#include <linux/module.h>\n#include <linux/userfaultfd.h>\n\n#include \"ksym_race.skel.h\"\n#include \"bpf_mod_race.skel.h\"\n#include \"kfunc_call_race.skel.h\"\n#include \"testing_helpers.h\"\n\n \n\nstruct test_config {\n\tconst char *str_open;\n\tvoid *(*bpf_open_and_load)();\n\tvoid (*bpf_destroy)(void *);\n};\n\nenum bpf_test_state {\n\t_TS_INVALID,\n\tTS_MODULE_LOAD,\n\tTS_MODULE_LOAD_FAIL,\n};\n\nstatic _Atomic enum bpf_test_state state = _TS_INVALID;\n\nstatic void *load_module_thread(void *p)\n{\n\n\tif (!ASSERT_NEQ(load_bpf_testmod(false), 0, \"load_module_thread must fail\"))\n\t\tatomic_store(&state, TS_MODULE_LOAD);\n\telse\n\t\tatomic_store(&state, TS_MODULE_LOAD_FAIL);\n\treturn p;\n}\n\nstatic int sys_userfaultfd(int flags)\n{\n\treturn syscall(__NR_userfaultfd, flags);\n}\n\nstatic int test_setup_uffd(void *fault_addr)\n{\n\tstruct uffdio_register uffd_register = {};\n\tstruct uffdio_api uffd_api = {};\n\tint uffd;\n\n\tuffd = sys_userfaultfd(O_CLOEXEC);\n\tif (uffd < 0)\n\t\treturn -errno;\n\n\tuffd_api.api = UFFD_API;\n\tuffd_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffd_api)) {\n\t\tclose(uffd);\n\t\treturn -1;\n\t}\n\n\tuffd_register.range.start = (unsigned long)fault_addr;\n\tuffd_register.range.len = 4096;\n\tuffd_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n\tif (ioctl(uffd, UFFDIO_REGISTER, &uffd_register)) {\n\t\tclose(uffd);\n\t\treturn -1;\n\t}\n\treturn uffd;\n}\n\nstatic void test_bpf_mod_race_config(const struct test_config *config)\n{\n\tvoid *fault_addr, *skel_fail;\n\tstruct bpf_mod_race *skel;\n\tstruct uffd_msg uffd_msg;\n\tpthread_t load_mod_thrd;\n\t_Atomic int *blockingp;\n\tint uffd, ret;\n\n\tfault_addr = mmap(0, 4096, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (!ASSERT_NEQ(fault_addr, MAP_FAILED, \"mmap for uffd registration\"))\n\t\treturn;\n\n\tif (!ASSERT_OK(unload_bpf_testmod(false), \"unload bpf_testmod\"))\n\t\tgoto end_mmap;\n\n\tskel = bpf_mod_race__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_mod_kfunc_race__open\"))\n\t\tgoto end_module;\n\n\tskel->rodata->bpf_mod_race_config.tgid = getpid();\n\tskel->rodata->bpf_mod_race_config.inject_error = -4242;\n\tskel->rodata->bpf_mod_race_config.fault_addr = fault_addr;\n\tif (!ASSERT_OK(bpf_mod_race__load(skel), \"bpf_mod___load\"))\n\t\tgoto end_destroy;\n\tblockingp = (_Atomic int *)&skel->bss->bpf_blocking;\n\n\tif (!ASSERT_OK(bpf_mod_race__attach(skel), \"bpf_mod_kfunc_race__attach\"))\n\t\tgoto end_destroy;\n\n\tuffd = test_setup_uffd(fault_addr);\n\tif (!ASSERT_GE(uffd, 0, \"userfaultfd open + register address\"))\n\t\tgoto end_destroy;\n\n\tif (!ASSERT_OK(pthread_create(&load_mod_thrd, NULL, load_module_thread, NULL),\n\t\t       \"load module thread\"))\n\t\tgoto end_uffd;\n\n\t \n\twhile (!atomic_load(&state) && !atomic_load(blockingp))\n\t\t;\n\tif (!ASSERT_EQ(state, _TS_INVALID, \"module load should block\"))\n\t\tgoto end_join;\n\tif (!ASSERT_EQ(*blockingp, 1, \"module load blocked\")) {\n\t\tpthread_kill(load_mod_thrd, SIGKILL);\n\t\tgoto end_uffd;\n\t}\n\n\t \n\tif (!ASSERT_EQ(read(uffd, &uffd_msg, sizeof(uffd_msg)), sizeof(uffd_msg),\n\t\t       \"read uffd block event\"))\n\t\tgoto end_join;\n\tif (!ASSERT_EQ(uffd_msg.event, UFFD_EVENT_PAGEFAULT, \"read uffd event is pagefault\"))\n\t\tgoto end_join;\n\n\t \n\tskel_fail = config->bpf_open_and_load();\n\tret = errno;\n\tif (!ASSERT_EQ(skel_fail, NULL, config->str_open)) {\n\t\t \n\t\tclose(uffd);\n\t\tuffd = -1;\n\t\twhile (atomic_load(blockingp) != 2)\n\t\t\t;\n\t\tASSERT_OK(kern_sync_rcu(), \"kern_sync_rcu\");\n\t\tconfig->bpf_destroy(skel_fail);\n\t\tgoto end_join;\n\n\t}\n\tASSERT_EQ(ret, ENXIO, \"verifier returns ENXIO\");\n\tASSERT_EQ(skel->data->res_try_get_module, false, \"btf_try_get_module == false\");\n\n\tclose(uffd);\n\tuffd = -1;\nend_join:\n\tpthread_join(load_mod_thrd, NULL);\n\tif (uffd < 0)\n\t\tASSERT_EQ(atomic_load(&state), TS_MODULE_LOAD_FAIL, \"load_mod_thrd success\");\nend_uffd:\n\tif (uffd >= 0)\n\t\tclose(uffd);\nend_destroy:\n\tbpf_mod_race__destroy(skel);\n\tASSERT_OK(kern_sync_rcu(), \"kern_sync_rcu\");\nend_module:\n\tunload_bpf_testmod(false);\n\tASSERT_OK(load_bpf_testmod(false), \"restore bpf_testmod\");\nend_mmap:\n\tmunmap(fault_addr, 4096);\n\tatomic_store(&state, _TS_INVALID);\n}\n\nstatic const struct test_config ksym_config = {\n\t.str_open = \"ksym_race__open_and_load\",\n\t.bpf_open_and_load = (void *)ksym_race__open_and_load,\n\t.bpf_destroy = (void *)ksym_race__destroy,\n};\n\nstatic const struct test_config kfunc_config = {\n\t.str_open = \"kfunc_call_race__open_and_load\",\n\t.bpf_open_and_load = (void *)kfunc_call_race__open_and_load,\n\t.bpf_destroy = (void *)kfunc_call_race__destroy,\n};\n\nvoid serial_test_bpf_mod_race(void)\n{\n\tif (test__start_subtest(\"ksym (used_btfs UAF)\"))\n\t\ttest_bpf_mod_race_config(&ksym_config);\n\tif (test__start_subtest(\"kfunc (kfunc_btf_tab UAF)\"))\n\t\ttest_bpf_mod_race_config(&kfunc_config);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}