{
  "module_name": "get_stack_raw_tp.c",
  "hash_id": "7e156cf50038c6d4130413a01ef0a39921f80f19956c433647ce19995fdce2e5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/get_stack_raw_tp.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <sched.h>\n#include <sys/socket.h>\n#include <test_progs.h>\n\n#define MAX_CNT_RAWTP\t10ull\n#define MAX_STACK_RAWTP\t100\n\nstatic int duration = 0;\n\nstruct get_stack_trace_t {\n\tint pid;\n\tint kern_stack_size;\n\tint user_stack_size;\n\tint user_stack_buildid_size;\n\t__u64 kern_stack[MAX_STACK_RAWTP];\n\t__u64 user_stack[MAX_STACK_RAWTP];\n\tstruct bpf_stack_build_id user_stack_buildid[MAX_STACK_RAWTP];\n};\n\nstatic void get_stack_print_output(void *ctx, int cpu, void *data, __u32 size)\n{\n\tbool good_kern_stack = false, good_user_stack = false;\n\tconst char *nonjit_func = \"___bpf_prog_run\";\n\t \n\tstruct get_stack_trace_t e;\n\tint i, num_stack;\n\tstruct ksym *ks;\n\n\tmemset(&e, 0, sizeof(e));\n\tmemcpy(&e, data, size <= sizeof(e) ? size : sizeof(e));\n\n\tif (size < sizeof(struct get_stack_trace_t)) {\n\t\t__u64 *raw_data = data;\n\t\tbool found = false;\n\n\t\tnum_stack = size / sizeof(__u64);\n\t\t \n\t\tif (env.jit_enabled) {\n\t\t\tfound = num_stack > 0;\n\t\t} else {\n\t\t\tfor (i = 0; i < num_stack; i++) {\n\t\t\t\tks = ksym_search(raw_data[i]);\n\t\t\t\tif (ks && (strcmp(ks->name, nonjit_func) == 0)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tgood_kern_stack = true;\n\t\t\tgood_user_stack = true;\n\t\t}\n\t} else {\n\t\tnum_stack = e.kern_stack_size / sizeof(__u64);\n\t\tif (env.jit_enabled) {\n\t\t\tgood_kern_stack = num_stack > 0;\n\t\t} else {\n\t\t\tfor (i = 0; i < num_stack; i++) {\n\t\t\t\tks = ksym_search(e.kern_stack[i]);\n\t\t\t\tif (ks && (strcmp(ks->name, nonjit_func) == 0)) {\n\t\t\t\t\tgood_kern_stack = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (e.user_stack_size > 0 && e.user_stack_buildid_size > 0)\n\t\t\tgood_user_stack = true;\n\t}\n\n\tif (!good_kern_stack)\n\t    CHECK(!good_kern_stack, \"kern_stack\", \"corrupted kernel stack\\n\");\n\tif (!good_user_stack)\n\t    CHECK(!good_user_stack, \"user_stack\", \"corrupted user stack\\n\");\n}\n\nvoid test_get_stack_raw_tp(void)\n{\n\tconst char *file = \"./test_get_stack_rawtp.bpf.o\";\n\tconst char *file_err = \"./test_get_stack_rawtp_err.bpf.o\";\n\tconst char *prog_name = \"bpf_prog1\";\n\tint i, err, prog_fd, exp_cnt = MAX_CNT_RAWTP;\n\tstruct perf_buffer *pb = NULL;\n\tstruct bpf_link *link = NULL;\n\tstruct timespec tv = {0, 10};\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tcpu_set_t cpu_set;\n\n\terr = bpf_prog_test_load(file_err, BPF_PROG_TYPE_RAW_TRACEPOINT, &obj, &prog_fd);\n\tif (CHECK(err >= 0, \"prog_load raw tp\", \"err %d errno %d\\n\", err, errno))\n\t\treturn;\n\n\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_RAW_TRACEPOINT, &obj, &prog_fd);\n\tif (CHECK(err, \"prog_load raw tp\", \"err %d errno %d\\n\", err, errno))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\tif (CHECK(!prog, \"find_probe\", \"prog '%s' not found\\n\", prog_name))\n\t\tgoto close_prog;\n\n\tmap = bpf_object__find_map_by_name(obj, \"perfmap\");\n\tif (CHECK(!map, \"bpf_find_map\", \"not found\\n\"))\n\t\tgoto close_prog;\n\n\terr = load_kallsyms();\n\tif (CHECK(err < 0, \"load_kallsyms\", \"err %d errno %d\\n\", err, errno))\n\t\tgoto close_prog;\n\n\tCPU_ZERO(&cpu_set);\n\tCPU_SET(0, &cpu_set);\n\terr = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set);\n\tif (CHECK(err, \"set_affinity\", \"err %d, errno %d\\n\", err, errno))\n\t\tgoto close_prog;\n\n\tlink = bpf_program__attach_raw_tracepoint(prog, \"sys_enter\");\n\tif (!ASSERT_OK_PTR(link, \"attach_raw_tp\"))\n\t\tgoto close_prog;\n\n\tpb = perf_buffer__new(bpf_map__fd(map), 8, get_stack_print_output,\n\t\t\t      NULL, NULL, NULL);\n\tif (!ASSERT_OK_PTR(pb, \"perf_buf__new\"))\n\t\tgoto close_prog;\n\n\t \n\tfor (i = 0; i < MAX_CNT_RAWTP; i++)\n\t\tnanosleep(&tv, NULL);\n\n\twhile (exp_cnt > 0) {\n\t\terr = perf_buffer__poll(pb, 100);\n\t\tif (err < 0 && CHECK(err < 0, \"pb__poll\", \"err %d\\n\", err))\n\t\t\tgoto close_prog;\n\t\texp_cnt -= err;\n\t}\n\nclose_prog:\n\tbpf_link__destroy(link);\n\tperf_buffer__free(pb);\n\tbpf_object__close(obj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}