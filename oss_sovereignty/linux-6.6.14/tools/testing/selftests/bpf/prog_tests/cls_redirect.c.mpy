{
  "module_name": "cls_redirect.c",
  "hash_id": "9ba2a101064d807eeab7e38d019b4424fa86e634cfcf23b7fd2f99bfdb9f6f2b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cls_redirect.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <string.h>\n\n#include <linux/pkt_cls.h>\n#include <netinet/tcp.h>\n\n#include <test_progs.h>\n\n#include \"progs/test_cls_redirect.h\"\n#include \"test_cls_redirect.skel.h\"\n#include \"test_cls_redirect_dynptr.skel.h\"\n#include \"test_cls_redirect_subprogs.skel.h\"\n\n#define ENCAP_IP INADDR_LOOPBACK\n#define ENCAP_PORT (1234)\n\nstatic int duration = 0;\n\nstruct addr_port {\n\tin_port_t port;\n\tunion {\n\t\tstruct in_addr in_addr;\n\t\tstruct in6_addr in6_addr;\n\t};\n};\n\nstruct tuple {\n\tint family;\n\tstruct addr_port src;\n\tstruct addr_port dst;\n};\n\nstatic int start_server(const struct sockaddr *addr, socklen_t len, int type)\n{\n\tint fd = socket(addr->sa_family, type, 0);\n\tif (CHECK_FAIL(fd == -1))\n\t\treturn -1;\n\tif (CHECK_FAIL(bind(fd, addr, len) == -1))\n\t\tgoto err;\n\tif (type == SOCK_STREAM && CHECK_FAIL(listen(fd, 128) == -1))\n\t\tgoto err;\n\n\treturn fd;\n\nerr:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int connect_to_server(const struct sockaddr *addr, socklen_t len,\n\t\t\t     int type)\n{\n\tint fd = socket(addr->sa_family, type, 0);\n\tif (CHECK_FAIL(fd == -1))\n\t\treturn -1;\n\tif (CHECK_FAIL(connect(fd, addr, len)))\n\t\tgoto err;\n\n\treturn fd;\n\nerr:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic bool fill_addr_port(const struct sockaddr *sa, struct addr_port *ap)\n{\n\tconst struct sockaddr_in6 *in6;\n\tconst struct sockaddr_in *in;\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tin = (const struct sockaddr_in *)sa;\n\t\tap->in_addr = in->sin_addr;\n\t\tap->port = in->sin_port;\n\t\treturn true;\n\n\tcase AF_INET6:\n\t\tin6 = (const struct sockaddr_in6 *)sa;\n\t\tap->in6_addr = in6->sin6_addr;\n\t\tap->port = in6->sin6_port;\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool set_up_conn(const struct sockaddr *addr, socklen_t len, int type,\n\t\t\tint *server, int *conn, struct tuple *tuple)\n{\n\tstruct sockaddr_storage ss;\n\tsocklen_t slen = sizeof(ss);\n\tstruct sockaddr *sa = (struct sockaddr *)&ss;\n\n\t*server = start_server(addr, len, type);\n\tif (*server < 0)\n\t\treturn false;\n\n\tif (CHECK_FAIL(getsockname(*server, sa, &slen)))\n\t\tgoto close_server;\n\n\t*conn = connect_to_server(sa, slen, type);\n\tif (*conn < 0)\n\t\tgoto close_server;\n\n\t \n\tslen = sizeof(ss);\n\tif (CHECK_FAIL(getsockname(*conn, sa, &slen)))\n\t\tgoto close_conn;\n\n\tif (CHECK_FAIL(!fill_addr_port(sa, &tuple->dst)))\n\t\tgoto close_conn;\n\n\tslen = sizeof(ss);\n\tif (CHECK_FAIL(getpeername(*conn, sa, &slen)))\n\t\tgoto close_conn;\n\n\tif (CHECK_FAIL(!fill_addr_port(sa, &tuple->src)))\n\t\tgoto close_conn;\n\n\ttuple->family = ss.ss_family;\n\treturn true;\n\nclose_conn:\n\tclose(*conn);\n\t*conn = -1;\nclose_server:\n\tclose(*server);\n\t*server = -1;\n\treturn false;\n}\n\nstatic socklen_t prepare_addr(struct sockaddr_storage *addr, int family)\n{\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)addr;\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = family;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\treturn sizeof(*addr4);\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)addr;\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = family;\n\t\taddr6->sin6_addr = in6addr_loopback;\n\t\treturn sizeof(*addr6);\n\tdefault:\n\t\tfprintf(stderr, \"Invalid family %d\", family);\n\t\treturn 0;\n\t}\n}\n\nstatic bool was_decapsulated(struct bpf_test_run_opts *tattr)\n{\n\treturn tattr->data_size_out < tattr->data_size_in;\n}\n\nenum type {\n\tUDP,\n\tTCP,\n\t__NR_KIND,\n};\n\nenum hops {\n\tNO_HOPS,\n\tONE_HOP,\n};\n\nenum flags {\n\tNONE,\n\tSYN,\n\tACK,\n};\n\nenum conn {\n\tKNOWN_CONN,\n\tUNKNOWN_CONN,\n};\n\nenum result {\n\tACCEPT,\n\tFORWARD,\n};\n\nstruct test_cfg {\n\tenum type type;\n\tenum result result;\n\tenum conn conn;\n\tenum hops hops;\n\tenum flags flags;\n};\n\nstatic int test_str(void *buf, size_t len, const struct test_cfg *test,\n\t\t    int family)\n{\n\tconst char *family_str, *type, *conn, *hops, *result, *flags;\n\n\tfamily_str = \"IPv4\";\n\tif (family == AF_INET6)\n\t\tfamily_str = \"IPv6\";\n\n\ttype = \"TCP\";\n\tif (test->type == UDP)\n\t\ttype = \"UDP\";\n\n\tconn = \"known\";\n\tif (test->conn == UNKNOWN_CONN)\n\t\tconn = \"unknown\";\n\n\thops = \"no hops\";\n\tif (test->hops == ONE_HOP)\n\t\thops = \"one hop\";\n\n\tresult = \"accept\";\n\tif (test->result == FORWARD)\n\t\tresult = \"forward\";\n\n\tflags = \"none\";\n\tif (test->flags == SYN)\n\t\tflags = \"SYN\";\n\telse if (test->flags == ACK)\n\t\tflags = \"ACK\";\n\n\treturn snprintf(buf, len, \"%s %s %s %s (%s, flags: %s)\", family_str,\n\t\t\ttype, result, conn, hops, flags);\n}\n\nstatic struct test_cfg tests[] = {\n\t{ TCP, ACCEPT, UNKNOWN_CONN, NO_HOPS, SYN },\n\t{ TCP, ACCEPT, UNKNOWN_CONN, NO_HOPS, ACK },\n\t{ TCP, FORWARD, UNKNOWN_CONN, ONE_HOP, ACK },\n\t{ TCP, ACCEPT, KNOWN_CONN, ONE_HOP, ACK },\n\t{ UDP, ACCEPT, UNKNOWN_CONN, NO_HOPS, NONE },\n\t{ UDP, FORWARD, UNKNOWN_CONN, ONE_HOP, NONE },\n\t{ UDP, ACCEPT, KNOWN_CONN, ONE_HOP, NONE },\n};\n\nstatic void encap_init(encap_headers_t *encap, uint8_t hop_count, uint8_t proto)\n{\n\tconst uint8_t hlen =\n\t\t(sizeof(struct guehdr) / sizeof(uint32_t)) + hop_count;\n\t*encap = (encap_headers_t){\n\t\t.eth = { .h_proto = htons(ETH_P_IP) },\n\t\t.ip = {\n\t\t\t.ihl = 5,\n\t\t\t.version = 4,\n\t\t\t.ttl = IPDEFTTL,\n\t\t\t.protocol = IPPROTO_UDP,\n\t\t\t.daddr = htonl(ENCAP_IP)\n\t\t},\n\t\t.udp = {\n\t\t\t.dest = htons(ENCAP_PORT),\n\t\t},\n\t\t.gue = {\n\t\t\t.hlen = hlen,\n\t\t\t.proto_ctype = proto\n\t\t},\n\t\t.unigue = {\n\t\t\t.hop_count = hop_count\n\t\t},\n\t};\n}\n\nstatic size_t build_input(const struct test_cfg *test, void *const buf,\n\t\t\t  const struct tuple *tuple)\n{\n\tin_port_t sport = tuple->src.port;\n\tencap_headers_t encap;\n\tstruct iphdr ip;\n\tstruct ipv6hdr ipv6;\n\tstruct tcphdr tcp;\n\tstruct udphdr udp;\n\tstruct in_addr next_hop;\n\tuint8_t *p = buf;\n\tint proto;\n\n\tproto = IPPROTO_IPIP;\n\tif (tuple->family == AF_INET6)\n\t\tproto = IPPROTO_IPV6;\n\n\tencap_init(&encap, test->hops == ONE_HOP ? 1 : 0, proto);\n\tp = mempcpy(p, &encap, sizeof(encap));\n\n\tif (test->hops == ONE_HOP) {\n\t\tnext_hop = (struct in_addr){ .s_addr = htonl(0x7f000002) };\n\t\tp = mempcpy(p, &next_hop, sizeof(next_hop));\n\t}\n\n\tproto = IPPROTO_TCP;\n\tif (test->type == UDP)\n\t\tproto = IPPROTO_UDP;\n\n\tswitch (tuple->family) {\n\tcase AF_INET:\n\t\tip = (struct iphdr){\n\t\t\t.ihl = 5,\n\t\t\t.version = 4,\n\t\t\t.ttl = IPDEFTTL,\n\t\t\t.protocol = proto,\n\t\t\t.saddr = tuple->src.in_addr.s_addr,\n\t\t\t.daddr = tuple->dst.in_addr.s_addr,\n\t\t};\n\t\tp = mempcpy(p, &ip, sizeof(ip));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tipv6 = (struct ipv6hdr){\n\t\t\t.version = 6,\n\t\t\t.hop_limit = IPDEFTTL,\n\t\t\t.nexthdr = proto,\n\t\t\t.saddr = tuple->src.in6_addr,\n\t\t\t.daddr = tuple->dst.in6_addr,\n\t\t};\n\t\tp = mempcpy(p, &ipv6, sizeof(ipv6));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (test->conn == UNKNOWN_CONN)\n\t\tsport--;\n\n\tswitch (test->type) {\n\tcase TCP:\n\t\ttcp = (struct tcphdr){\n\t\t\t.source = sport,\n\t\t\t.dest = tuple->dst.port,\n\t\t};\n\t\tif (test->flags == SYN)\n\t\t\ttcp.syn = true;\n\t\tif (test->flags == ACK)\n\t\t\ttcp.ack = true;\n\t\tp = mempcpy(p, &tcp, sizeof(tcp));\n\t\tbreak;\n\tcase UDP:\n\t\tudp = (struct udphdr){\n\t\t\t.source = sport,\n\t\t\t.dest = tuple->dst.port,\n\t\t};\n\t\tp = mempcpy(p, &udp, sizeof(udp));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn (void *)p - buf;\n}\n\nstatic void close_fds(int *fds, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tif (fds[i] > 0)\n\t\t\tclose(fds[i]);\n}\n\nstatic void test_cls_redirect_common(struct bpf_program *prog)\n{\n\tLIBBPF_OPTS(bpf_test_run_opts, tattr);\n\tint families[] = { AF_INET, AF_INET6 };\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *addr;\n\tsocklen_t slen;\n\tint i, j, err, prog_fd;\n\tint servers[__NR_KIND][ARRAY_SIZE(families)] = {};\n\tint conns[__NR_KIND][ARRAY_SIZE(families)] = {};\n\tstruct tuple tuples[__NR_KIND][ARRAY_SIZE(families)];\n\n\taddr = (struct sockaddr *)&ss;\n\tfor (i = 0; i < ARRAY_SIZE(families); i++) {\n\t\tslen = prepare_addr(&ss, families[i]);\n\t\tif (CHECK_FAIL(!slen))\n\t\t\tgoto cleanup;\n\n\t\tif (CHECK_FAIL(!set_up_conn(addr, slen, SOCK_DGRAM,\n\t\t\t\t\t    &servers[UDP][i], &conns[UDP][i],\n\t\t\t\t\t    &tuples[UDP][i])))\n\t\t\tgoto cleanup;\n\n\t\tif (CHECK_FAIL(!set_up_conn(addr, slen, SOCK_STREAM,\n\t\t\t\t\t    &servers[TCP][i], &conns[TCP][i],\n\t\t\t\t\t    &tuples[TCP][i])))\n\t\t\tgoto cleanup;\n\t}\n\n\tprog_fd = bpf_program__fd(prog);\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tstruct test_cfg *test = &tests[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(families); j++) {\n\t\t\tstruct tuple *tuple = &tuples[test->type][j];\n\t\t\tchar input[256];\n\t\t\tchar tmp[256];\n\n\t\t\ttest_str(tmp, sizeof(tmp), test, tuple->family);\n\t\t\tif (!test__start_subtest(tmp))\n\t\t\t\tcontinue;\n\n\t\t\ttattr.data_out = tmp;\n\t\t\ttattr.data_size_out = sizeof(tmp);\n\n\t\t\ttattr.data_in = input;\n\t\t\ttattr.data_size_in = build_input(test, input, tuple);\n\t\t\tif (CHECK_FAIL(!tattr.data_size_in))\n\t\t\t\tcontinue;\n\n\t\t\terr = bpf_prog_test_run_opts(prog_fd, &tattr);\n\t\t\tif (CHECK_FAIL(err))\n\t\t\t\tcontinue;\n\n\t\t\tif (tattr.retval != TC_ACT_REDIRECT) {\n\t\t\t\tPRINT_FAIL(\"expected TC_ACT_REDIRECT, got %d\\n\",\n\t\t\t\t\t   tattr.retval);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (test->result) {\n\t\t\tcase ACCEPT:\n\t\t\t\tif (CHECK_FAIL(!was_decapsulated(&tattr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase FORWARD:\n\t\t\t\tif (CHECK_FAIL(was_decapsulated(&tattr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tPRINT_FAIL(\"unknown result %d\\n\", test->result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tclose_fds((int *)servers, sizeof(servers) / sizeof(servers[0][0]));\n\tclose_fds((int *)conns, sizeof(conns) / sizeof(conns[0][0]));\n}\n\nstatic void test_cls_redirect_dynptr(void)\n{\n\tstruct test_cls_redirect_dynptr *skel;\n\tint err;\n\n\tskel = test_cls_redirect_dynptr__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tskel->rodata->ENCAPSULATION_IP = htonl(ENCAP_IP);\n\tskel->rodata->ENCAPSULATION_PORT = htons(ENCAP_PORT);\n\n\terr = test_cls_redirect_dynptr__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\ttest_cls_redirect_common(skel->progs.cls_redirect);\n\ncleanup:\n\ttest_cls_redirect_dynptr__destroy(skel);\n}\n\nstatic void test_cls_redirect_inlined(void)\n{\n\tstruct test_cls_redirect *skel;\n\tint err;\n\n\tskel = test_cls_redirect__open();\n\tif (CHECK(!skel, \"skel_open\", \"failed\\n\"))\n\t\treturn;\n\n\tskel->rodata->ENCAPSULATION_IP = htonl(ENCAP_IP);\n\tskel->rodata->ENCAPSULATION_PORT = htons(ENCAP_PORT);\n\n\terr = test_cls_redirect__load(skel);\n\tif (CHECK(err, \"skel_load\", \"failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\ttest_cls_redirect_common(skel->progs.cls_redirect);\n\ncleanup:\n\ttest_cls_redirect__destroy(skel);\n}\n\nstatic void test_cls_redirect_subprogs(void)\n{\n\tstruct test_cls_redirect_subprogs *skel;\n\tint err;\n\n\tskel = test_cls_redirect_subprogs__open();\n\tif (CHECK(!skel, \"skel_open\", \"failed\\n\"))\n\t\treturn;\n\n\tskel->rodata->ENCAPSULATION_IP = htonl(ENCAP_IP);\n\tskel->rodata->ENCAPSULATION_PORT = htons(ENCAP_PORT);\n\n\terr = test_cls_redirect_subprogs__load(skel);\n\tif (CHECK(err, \"skel_load\", \"failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\ttest_cls_redirect_common(skel->progs.cls_redirect);\n\ncleanup:\n\ttest_cls_redirect_subprogs__destroy(skel);\n}\n\nvoid test_cls_redirect(void)\n{\n\tif (test__start_subtest(\"cls_redirect_inlined\"))\n\t\ttest_cls_redirect_inlined();\n\tif (test__start_subtest(\"cls_redirect_subprogs\"))\n\t\ttest_cls_redirect_subprogs();\n\tif (test__start_subtest(\"cls_redirect_dynptr\"))\n\t\ttest_cls_redirect_dynptr();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}