{
  "module_name": "dynptr.c",
  "hash_id": "cfa522ca9377d7069c47601af82a0a6cd9d5ab9c1c27685603558afb694bf2b0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/dynptr.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"dynptr_fail.skel.h\"\n#include \"dynptr_success.skel.h\"\n\nenum test_setup_type {\n\tSETUP_SYSCALL_SLEEP,\n\tSETUP_SKB_PROG,\n};\n\nstatic struct {\n\tconst char *prog_name;\n\tenum test_setup_type type;\n} success_tests[] = {\n\t{\"test_read_write\", SETUP_SYSCALL_SLEEP},\n\t{\"test_dynptr_data\", SETUP_SYSCALL_SLEEP},\n\t{\"test_ringbuf\", SETUP_SYSCALL_SLEEP},\n\t{\"test_skb_readonly\", SETUP_SKB_PROG},\n\t{\"test_dynptr_skb_data\", SETUP_SKB_PROG},\n\t{\"test_adjust\", SETUP_SYSCALL_SLEEP},\n\t{\"test_adjust_err\", SETUP_SYSCALL_SLEEP},\n\t{\"test_zero_size_dynptr\", SETUP_SYSCALL_SLEEP},\n\t{\"test_dynptr_is_null\", SETUP_SYSCALL_SLEEP},\n\t{\"test_dynptr_is_rdonly\", SETUP_SKB_PROG},\n\t{\"test_dynptr_clone\", SETUP_SKB_PROG},\n\t{\"test_dynptr_skb_no_buff\", SETUP_SKB_PROG},\n\t{\"test_dynptr_skb_strcmp\", SETUP_SKB_PROG},\n};\n\nstatic void verify_success(const char *prog_name, enum test_setup_type setup_type)\n{\n\tstruct dynptr_success *skel;\n\tstruct bpf_program *prog;\n\tstruct bpf_link *link;\n       int err;\n\n\tskel = dynptr_success__open();\n\tif (!ASSERT_OK_PTR(skel, \"dynptr_success__open\"))\n\t\treturn;\n\n\tskel->bss->pid = getpid();\n\n\tprog = bpf_object__find_program_by_name(skel->obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto cleanup;\n\n       bpf_program__set_autoload(prog, true);\n\n\terr = dynptr_success__load(skel);\n\tif (!ASSERT_OK(err, \"dynptr_success__load\"))\n\t\tgoto cleanup;\n\n\tswitch (setup_type) {\n\tcase SETUP_SYSCALL_SLEEP:\n\t\tlink = bpf_program__attach(prog);\n\t\tif (!ASSERT_OK_PTR(link, \"bpf_program__attach\"))\n\t\t\tgoto cleanup;\n\n\t\tusleep(1);\n\n\t\tbpf_link__destroy(link);\n\t\tbreak;\n\tcase SETUP_SKB_PROG:\n\t{\n\t\tint prog_fd;\n\t\tchar buf[64];\n\n\t\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t\t    .data_in = &pkt_v4,\n\t\t\t    .data_size_in = sizeof(pkt_v4),\n\t\t\t    .data_out = buf,\n\t\t\t    .data_size_out = sizeof(buf),\n\t\t\t    .repeat = 1,\n\t\t);\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (!ASSERT_GE(prog_fd, 0, \"prog_fd\"))\n\t\t\tgoto cleanup;\n\n\t\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\n\t\tif (!ASSERT_OK(err, \"test_run\"))\n\t\t\tgoto cleanup;\n\n\t\tbreak;\n\t}\n\t}\n\n\tASSERT_EQ(skel->bss->err, 0, \"err\");\n\ncleanup:\n\tdynptr_success__destroy(skel);\n}\n\nvoid test_dynptr(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(success_tests); i++) {\n\t\tif (!test__start_subtest(success_tests[i].prog_name))\n\t\t\tcontinue;\n\n\t\tverify_success(success_tests[i].prog_name, success_tests[i].type);\n\t}\n\n\tRUN_TESTS(dynptr_fail);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}