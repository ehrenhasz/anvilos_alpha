{
  "module_name": "hashmap.c",
  "hash_id": "5843f5d22f536c0eeb2f165bc26bb54baeb4eca84785532cd074d6891fe8b42d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/hashmap.c",
  "human_readable_source": "\n\n \n#include \"test_progs.h\"\n#include \"bpf/hashmap.h\"\n#include <stddef.h>\n\nstatic int duration = 0;\n\nstatic size_t hash_fn(long k, void *ctx)\n{\n\treturn k;\n}\n\nstatic bool equal_fn(long a, long b, void *ctx)\n{\n\treturn a == b;\n}\n\nstatic inline size_t next_pow_2(size_t n)\n{\n\tsize_t r = 1;\n\n\twhile (r < n)\n\t\tr <<= 1;\n\treturn r;\n}\n\nstatic inline size_t exp_cap(size_t sz)\n{\n\tsize_t r = next_pow_2(sz);\n\n\tif (sz * 4 / 3 > r)\n\t\tr <<= 1;\n\treturn r;\n}\n\n#define ELEM_CNT 62\n\nstatic void test_hashmap_generic(void)\n{\n\tstruct hashmap_entry *entry, *tmp;\n\tint err, bkt, found_cnt, i;\n\tlong long found_msk;\n\tstruct hashmap *map;\n\n\tmap = hashmap__new(hash_fn, equal_fn, NULL);\n\tif (!ASSERT_OK_PTR(map, \"hashmap__new\"))\n\t\treturn;\n\n\tfor (i = 0; i < ELEM_CNT; i++) {\n\t\tlong oldk, k = i;\n\t\tlong oldv, v = 1024 + i;\n\n\t\terr = hashmap__update(map, k, v, &oldk, &oldv);\n\t\tif (CHECK(err != -ENOENT, \"hashmap__update\",\n\t\t\t  \"unexpected result: %d\\n\", err))\n\t\t\tgoto cleanup;\n\n\t\tif (i % 2) {\n\t\t\terr = hashmap__add(map, k, v);\n\t\t} else {\n\t\t\terr = hashmap__set(map, k, v, &oldk, &oldv);\n\t\t\tif (CHECK(oldk != 0 || oldv != 0, \"check_kv\",\n\t\t\t\t  \"unexpected k/v: %ld=%ld\\n\", oldk, oldv))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (CHECK(err, \"elem_add\", \"failed to add k/v %ld = %ld: %d\\n\", k, v, err))\n\t\t\tgoto cleanup;\n\n\t\tif (CHECK(!hashmap__find(map, k, &oldv), \"elem_find\",\n\t\t\t  \"failed to find key %ld\\n\", k))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(oldv != v, \"elem_val\", \"found value is wrong: %ld\\n\", oldv))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (CHECK(hashmap__size(map) != ELEM_CNT, \"hashmap__size\",\n\t\t  \"invalid map size: %zu\\n\", hashmap__size(map)))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__capacity(map) != exp_cap(hashmap__size(map)),\n\t\t  \"hashmap_cap\",\n\t\t  \"unexpected map capacity: %zu\\n\", hashmap__capacity(map)))\n\t\tgoto cleanup;\n\n\tfound_msk = 0;\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tlong k = entry->key;\n\t\tlong v = entry->value;\n\n\t\tfound_msk |= 1ULL << k;\n\t\tif (CHECK(v - k != 1024, \"check_kv\",\n\t\t\t  \"invalid k/v pair: %ld = %ld\\n\", k, v))\n\t\t\tgoto cleanup;\n\t}\n\tif (CHECK(found_msk != (1ULL << ELEM_CNT) - 1, \"elem_cnt\",\n\t\t  \"not all keys iterated: %llx\\n\", found_msk))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ELEM_CNT; i++) {\n\t\tlong oldk, k = i;\n\t\tlong oldv, v = 256 + i;\n\n\t\terr = hashmap__add(map, k, v);\n\t\tif (CHECK(err != -EEXIST, \"hashmap__add\",\n\t\t\t  \"unexpected add result: %d\\n\", err))\n\t\t\tgoto cleanup;\n\n\t\tif (i % 2)\n\t\t\terr = hashmap__update(map, k, v, &oldk, &oldv);\n\t\telse\n\t\t\terr = hashmap__set(map, k, v, &oldk, &oldv);\n\n\t\tif (CHECK(err, \"elem_upd\",\n\t\t\t  \"failed to update k/v %ld = %ld: %d\\n\",\n\t\t\t  k, v, err))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(!hashmap__find(map, k, &oldv), \"elem_find\",\n\t\t\t  \"failed to find key %ld\\n\", k))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(oldv != v, \"elem_val\",\n\t\t\t  \"found value is wrong: %ld\\n\", oldv))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (CHECK(hashmap__size(map) != ELEM_CNT, \"hashmap__size\",\n\t\t  \"invalid updated map size: %zu\\n\", hashmap__size(map)))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__capacity(map) != exp_cap(hashmap__size(map)),\n\t\t  \"hashmap__capacity\",\n\t\t  \"unexpected map capacity: %zu\\n\", hashmap__capacity(map)))\n\t\tgoto cleanup;\n\n\tfound_msk = 0;\n\thashmap__for_each_entry_safe(map, entry, tmp, bkt) {\n\t\tlong k = entry->key;\n\t\tlong v = entry->value;\n\n\t\tfound_msk |= 1ULL << k;\n\t\tif (CHECK(v - k != 256, \"elem_check\",\n\t\t\t  \"invalid updated k/v pair: %ld = %ld\\n\", k, v))\n\t\t\tgoto cleanup;\n\t}\n\tif (CHECK(found_msk != (1ULL << ELEM_CNT) - 1, \"elem_cnt\",\n\t\t  \"not all keys iterated after update: %llx\\n\", found_msk))\n\t\tgoto cleanup;\n\n\tfound_cnt = 0;\n\thashmap__for_each_key_entry(map, entry, 0) {\n\t\tfound_cnt++;\n\t}\n\tif (CHECK(!found_cnt, \"found_cnt\",\n\t\t  \"didn't find any entries for key 0\\n\"))\n\t\tgoto cleanup;\n\n\tfound_msk = 0;\n\tfound_cnt = 0;\n\thashmap__for_each_key_entry_safe(map, entry, tmp, 0) {\n\t\tlong oldk, k;\n\t\tlong oldv, v;\n\n\t\tk = entry->key;\n\t\tv = entry->value;\n\n\t\tfound_cnt++;\n\t\tfound_msk |= 1ULL << k;\n\n\t\tif (CHECK(!hashmap__delete(map, k, &oldk, &oldv), \"elem_del\",\n\t\t\t  \"failed to delete k/v %ld = %ld\\n\", k, v))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(oldk != k || oldv != v, \"check_old\",\n\t\t\t  \"invalid deleted k/v: expected %ld = %ld, got %ld = %ld\\n\",\n\t\t\t  k, v, oldk, oldv))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(hashmap__delete(map, k, &oldk, &oldv), \"elem_del\",\n\t\t\t  \"unexpectedly deleted k/v %ld = %ld\\n\", oldk, oldv))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (CHECK(!found_cnt || !found_msk, \"found_entries\",\n\t\t  \"didn't delete any key entries\\n\"))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__size(map) != ELEM_CNT - found_cnt, \"elem_cnt\",\n\t\t  \"invalid updated map size (already deleted: %d): %zu\\n\",\n\t\t  found_cnt, hashmap__size(map)))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__capacity(map) != exp_cap(hashmap__size(map)),\n\t\t  \"hashmap__capacity\",\n\t\t  \"unexpected map capacity: %zu\\n\", hashmap__capacity(map)))\n\t\tgoto cleanup;\n\n\thashmap__for_each_entry_safe(map, entry, tmp, bkt) {\n\t\tlong oldk, k;\n\t\tlong oldv, v;\n\n\t\tk = entry->key;\n\t\tv = entry->value;\n\n\t\tfound_cnt++;\n\t\tfound_msk |= 1ULL << k;\n\n\t\tif (CHECK(!hashmap__delete(map, k, &oldk, &oldv), \"elem_del\",\n\t\t\t  \"failed to delete k/v %ld = %ld\\n\", k, v))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(oldk != k || oldv != v, \"elem_check\",\n\t\t\t  \"invalid old k/v: expect %ld = %ld, got %ld = %ld\\n\",\n\t\t\t  k, v, oldk, oldv))\n\t\t\tgoto cleanup;\n\t\tif (CHECK(hashmap__delete(map, k, &oldk, &oldv), \"elem_del\",\n\t\t\t  \"unexpectedly deleted k/v %ld = %ld\\n\", k, v))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (CHECK(found_cnt != ELEM_CNT || found_msk != (1ULL << ELEM_CNT) - 1,\n\t\t  \"found_cnt\",\n\t\t  \"not all keys were deleted: found_cnt:%d, found_msk:%llx\\n\",\n\t\t  found_cnt, found_msk))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__size(map) != 0, \"hashmap__size\",\n\t\t  \"invalid updated map size (already deleted: %d): %zu\\n\",\n\t\t  found_cnt, hashmap__size(map)))\n\t\tgoto cleanup;\n\n\tfound_cnt = 0;\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tCHECK(false, \"elem_exists\",\n\t\t      \"unexpected map entries left: %ld = %ld\\n\",\n\t\t      entry->key, entry->value);\n\t\tgoto cleanup;\n\t}\n\n\thashmap__clear(map);\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tCHECK(false, \"elem_exists\",\n\t\t      \"unexpected map entries left: %ld = %ld\\n\",\n\t\t      entry->key, entry->value);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\thashmap__free(map);\n}\n\nstatic size_t str_hash_fn(long a, void *ctx)\n{\n\treturn str_hash((char *)a);\n}\n\nstatic bool str_equal_fn(long a, long b, void *ctx)\n{\n\treturn strcmp((char *)a, (char *)b) == 0;\n}\n\n \nstatic void test_hashmap_ptr_iface(void)\n{\n\tconst char *key, *value, *old_key, *old_value;\n\tstruct hashmap_entry *cur;\n\tstruct hashmap *map;\n\tint err, i, bkt;\n\n\tmap = hashmap__new(str_hash_fn, str_equal_fn, NULL);\n\tif (CHECK(!map, \"hashmap__new\", \"can't allocate hashmap\\n\"))\n\t\tgoto cleanup;\n\n#define CHECK_STR(fn, var, expected)\t\t\t\t\t\\\n\tCHECK(strcmp(var, (expected)), (fn),\t\t\t\t\\\n\t      \"wrong value of \" #var \": '%s' instead of '%s'\\n\", var, (expected))\n\n\terr = hashmap__insert(map, \"a\", \"apricot\", HASHMAP_ADD, NULL, NULL);\n\tif (CHECK(err, \"hashmap__insert\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\n\terr = hashmap__insert(map, \"a\", \"apple\", HASHMAP_SET, &old_key, &old_value);\n\tif (CHECK(err, \"hashmap__insert\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\tCHECK_STR(\"hashmap__update\", old_key, \"a\");\n\tCHECK_STR(\"hashmap__update\", old_value, \"apricot\");\n\n\terr = hashmap__add(map, \"b\", \"banana\");\n\tif (CHECK(err, \"hashmap__add\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\n\terr = hashmap__set(map, \"b\", \"breadfruit\", &old_key, &old_value);\n\tif (CHECK(err, \"hashmap__set\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\tCHECK_STR(\"hashmap__set\", old_key, \"b\");\n\tCHECK_STR(\"hashmap__set\", old_value, \"banana\");\n\n\terr = hashmap__update(map, \"b\", \"blueberry\", &old_key, &old_value);\n\tif (CHECK(err, \"hashmap__update\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\tCHECK_STR(\"hashmap__update\", old_key, \"b\");\n\tCHECK_STR(\"hashmap__update\", old_value, \"breadfruit\");\n\n\terr = hashmap__append(map, \"c\", \"cherry\");\n\tif (CHECK(err, \"hashmap__append\", \"unexpected error: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tif (CHECK(!hashmap__delete(map, \"c\", &old_key, &old_value),\n\t\t  \"hashmap__delete\", \"expected to have entry for 'c'\\n\"))\n\t\tgoto cleanup;\n\tCHECK_STR(\"hashmap__delete\", old_key, \"c\");\n\tCHECK_STR(\"hashmap__delete\", old_value, \"cherry\");\n\n\tCHECK(!hashmap__find(map, \"b\", &value), \"hashmap__find\", \"can't find value for 'b'\\n\");\n\tCHECK_STR(\"hashmap__find\", value, \"blueberry\");\n\n\tif (CHECK(!hashmap__delete(map, \"b\", NULL, NULL),\n\t\t  \"hashmap__delete\", \"expected to have entry for 'b'\\n\"))\n\t\tgoto cleanup;\n\n\ti = 0;\n\thashmap__for_each_entry(map, cur, bkt) {\n\t\tif (CHECK(i != 0, \"hashmap__for_each_entry\", \"too many entries\"))\n\t\t\tgoto cleanup;\n\t\tkey = cur->pkey;\n\t\tvalue = cur->pvalue;\n\t\tCHECK_STR(\"entry\", key, \"a\");\n\t\tCHECK_STR(\"entry\", value, \"apple\");\n\t\ti++;\n\t}\n#undef CHECK_STR\n\ncleanup:\n\thashmap__free(map);\n}\n\nstatic size_t collision_hash_fn(long k, void *ctx)\n{\n\treturn 0;\n}\n\nstatic void test_hashmap_multimap(void)\n{\n\tlong k1 = 0, k2 = 1;\n\tstruct hashmap_entry *entry;\n\tstruct hashmap *map;\n\tlong found_msk;\n\tint err, bkt;\n\n\t \n\tmap = hashmap__new(collision_hash_fn, equal_fn, NULL);\n\tif (!ASSERT_OK_PTR(map, \"hashmap__new\"))\n\t\treturn;\n\n\t \n\terr = hashmap__append(map, k1, 1);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\terr = hashmap__append(map, k1, 2);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\terr = hashmap__append(map, k1, 4);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\n\terr = hashmap__append(map, k2, 8);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\terr = hashmap__append(map, k2, 16);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\terr = hashmap__append(map, k2, 32);\n\tif (CHECK(err, \"elem_add\", \"failed to add k/v: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tif (CHECK(hashmap__size(map) != 6, \"hashmap_size\",\n\t\t  \"invalid map size: %zu\\n\", hashmap__size(map)))\n\t\tgoto cleanup;\n\n\t \n\tfound_msk = 0;\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tfound_msk |= entry->value;\n\t}\n\tif (CHECK(found_msk != (1 << 6) - 1, \"found_msk\",\n\t\t  \"not all keys iterated: %lx\\n\", found_msk))\n\t\tgoto cleanup;\n\n\t \n\tfound_msk = 0;\n\thashmap__for_each_key_entry(map, entry, k1) {\n\t\tfound_msk |= entry->value;\n\t}\n\tif (CHECK(found_msk != (1 | 2 | 4), \"found_msk\",\n\t\t  \"invalid k1 values: %lx\\n\", found_msk))\n\t\tgoto cleanup;\n\n\t \n\tfound_msk = 0;\n\thashmap__for_each_key_entry(map, entry, k2) {\n\t\tfound_msk |= entry->value;\n\t}\n\tif (CHECK(found_msk != (8 | 16 | 32), \"found_msk\",\n\t\t  \"invalid k2 values: %lx\\n\", found_msk))\n\t\tgoto cleanup;\n\ncleanup:\n\thashmap__free(map);\n}\n\nstatic void test_hashmap_empty()\n{\n\tstruct hashmap_entry *entry;\n\tint bkt;\n\tstruct hashmap *map;\n\tlong k = 0;\n\n\t \n\tmap = hashmap__new(hash_fn, equal_fn, NULL);\n\tif (!ASSERT_OK_PTR(map, \"hashmap__new\"))\n\t\tgoto cleanup;\n\n\tif (CHECK(hashmap__size(map) != 0, \"hashmap__size\",\n\t\t  \"invalid map size: %zu\\n\", hashmap__size(map)))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__capacity(map) != 0, \"hashmap__capacity\",\n\t\t  \"invalid map capacity: %zu\\n\", hashmap__capacity(map)))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__find(map, k, NULL), \"elem_find\",\n\t\t  \"unexpected find\\n\"))\n\t\tgoto cleanup;\n\tif (CHECK(hashmap__delete(map, k, NULL, NULL), \"elem_del\",\n\t\t  \"unexpected delete\\n\"))\n\t\tgoto cleanup;\n\n\thashmap__for_each_entry(map, entry, bkt) {\n\t\tCHECK(false, \"elem_found\", \"unexpected iterated entry\\n\");\n\t\tgoto cleanup;\n\t}\n\thashmap__for_each_key_entry(map, entry, k) {\n\t\tCHECK(false, \"key_found\", \"unexpected key entry\\n\");\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\thashmap__free(map);\n}\n\nvoid test_hashmap()\n{\n\tif (test__start_subtest(\"generic\"))\n\t\ttest_hashmap_generic();\n\tif (test__start_subtest(\"multimap\"))\n\t\ttest_hashmap_multimap();\n\tif (test__start_subtest(\"empty\"))\n\t\ttest_hashmap_empty();\n\tif (test__start_subtest(\"ptr_iface\"))\n\t\ttest_hashmap_ptr_iface();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}