{
  "module_name": "uprobe_multi_test.c",
  "hash_id": "7bc3db2af4a450721d085bab34bbf8c62e675f0e8a301d25dc42a9fc2beb3149",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/uprobe_multi_test.c",
  "human_readable_source": "\n\n#include <unistd.h>\n#include <test_progs.h>\n#include \"uprobe_multi.skel.h\"\n#include \"uprobe_multi_bench.skel.h\"\n#include \"uprobe_multi_usdt.skel.h\"\n#include \"bpf/libbpf_internal.h\"\n#include \"testing_helpers.h\"\n\nstatic char test_data[] = \"test_data\";\n\nnoinline void uprobe_multi_func_1(void)\n{\n\tasm volatile (\"\");\n}\n\nnoinline void uprobe_multi_func_2(void)\n{\n\tasm volatile (\"\");\n}\n\nnoinline void uprobe_multi_func_3(void)\n{\n\tasm volatile (\"\");\n}\n\nstruct child {\n\tint go[2];\n\tint pid;\n};\n\nstatic void release_child(struct child *child)\n{\n\tint child_status;\n\n\tif (!child)\n\t\treturn;\n\tclose(child->go[1]);\n\tclose(child->go[0]);\n\tif (child->pid > 0)\n\t\twaitpid(child->pid, &child_status, 0);\n}\n\nstatic void kick_child(struct child *child)\n{\n\tchar c = 1;\n\n\tif (child) {\n\t\twrite(child->go[1], &c, 1);\n\t\trelease_child(child);\n\t}\n\tfflush(NULL);\n}\n\nstatic struct child *spawn_child(void)\n{\n\tstatic struct child child;\n\tint err;\n\tint c;\n\n\t \n\tif (pipe(child.go))\n\t\treturn NULL;\n\n\tchild.pid = fork();\n\tif (child.pid < 0) {\n\t\trelease_child(&child);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t \n\tif (child.pid == 0) {\n\t\tclose(child.go[1]);\n\n\t\t \n\t\terr = read(child.go[0], &c, 1);\n\t\tif (err != 1)\n\t\t\texit(err);\n\n\t\tuprobe_multi_func_1();\n\t\tuprobe_multi_func_2();\n\t\tuprobe_multi_func_3();\n\n\t\texit(errno);\n\t}\n\n\treturn &child;\n}\n\nstatic void uprobe_multi_test_run(struct uprobe_multi *skel, struct child *child)\n{\n\tskel->bss->uprobe_multi_func_1_addr = (__u64) uprobe_multi_func_1;\n\tskel->bss->uprobe_multi_func_2_addr = (__u64) uprobe_multi_func_2;\n\tskel->bss->uprobe_multi_func_3_addr = (__u64) uprobe_multi_func_3;\n\n\tskel->bss->user_ptr = test_data;\n\n\t \n\tskel->bss->pid = child ? 0 : getpid();\n\n\tif (child)\n\t\tkick_child(child);\n\n\t \n\tuprobe_multi_func_1();\n\tuprobe_multi_func_2();\n\tuprobe_multi_func_3();\n\n\t \n\tASSERT_EQ(skel->bss->uprobe_multi_func_1_result, 2, \"uprobe_multi_func_1_result\");\n\tASSERT_EQ(skel->bss->uprobe_multi_func_2_result, 2, \"uprobe_multi_func_2_result\");\n\tASSERT_EQ(skel->bss->uprobe_multi_func_3_result, 2, \"uprobe_multi_func_3_result\");\n\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_1_result, 2, \"uretprobe_multi_func_1_result\");\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_2_result, 2, \"uretprobe_multi_func_2_result\");\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_3_result, 2, \"uretprobe_multi_func_3_result\");\n\n\tASSERT_EQ(skel->bss->uprobe_multi_sleep_result, 6, \"uprobe_multi_sleep_result\");\n\n\tif (child)\n\t\tASSERT_EQ(skel->bss->child_pid, child->pid, \"uprobe_multi_child_pid\");\n}\n\nstatic void test_skel_api(void)\n{\n\tstruct uprobe_multi *skel = NULL;\n\tint err;\n\n\tskel = uprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi__open_and_load\"))\n\t\tgoto cleanup;\n\n\terr = uprobe_multi__attach(skel);\n\tif (!ASSERT_OK(err, \"uprobe_multi__attach\"))\n\t\tgoto cleanup;\n\n\tuprobe_multi_test_run(skel, NULL);\n\ncleanup:\n\tuprobe_multi__destroy(skel);\n}\n\nstatic void\n__test_attach_api(const char *binary, const char *pattern, struct bpf_uprobe_multi_opts *opts,\n\t\t  struct child *child)\n{\n\tpid_t pid = child ? child->pid : -1;\n\tstruct uprobe_multi *skel = NULL;\n\n\tskel = uprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi__open_and_load\"))\n\t\tgoto cleanup;\n\n\topts->retprobe = false;\n\tskel->links.uprobe = bpf_program__attach_uprobe_multi(skel->progs.uprobe, pid,\n\t\t\t\t\t\t\t      binary, pattern, opts);\n\tif (!ASSERT_OK_PTR(skel->links.uprobe, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\topts->retprobe = true;\n\tskel->links.uretprobe = bpf_program__attach_uprobe_multi(skel->progs.uretprobe, pid,\n\t\t\t\t\t\t\t\t binary, pattern, opts);\n\tif (!ASSERT_OK_PTR(skel->links.uretprobe, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\topts->retprobe = false;\n\tskel->links.uprobe_sleep = bpf_program__attach_uprobe_multi(skel->progs.uprobe_sleep, pid,\n\t\t\t\t\t\t\t\t    binary, pattern, opts);\n\tif (!ASSERT_OK_PTR(skel->links.uprobe_sleep, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\topts->retprobe = true;\n\tskel->links.uretprobe_sleep = bpf_program__attach_uprobe_multi(skel->progs.uretprobe_sleep,\n\t\t\t\t\t\t\t\t       pid, binary, pattern, opts);\n\tif (!ASSERT_OK_PTR(skel->links.uretprobe_sleep, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\topts->retprobe = false;\n\tskel->links.uprobe_extra = bpf_program__attach_uprobe_multi(skel->progs.uprobe_extra, -1,\n\t\t\t\t\t\t\t\t    binary, pattern, opts);\n\tif (!ASSERT_OK_PTR(skel->links.uprobe_extra, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\tuprobe_multi_test_run(skel, child);\n\ncleanup:\n\tuprobe_multi__destroy(skel);\n}\n\nstatic void\ntest_attach_api(const char *binary, const char *pattern, struct bpf_uprobe_multi_opts *opts)\n{\n\tstruct child *child;\n\n\t \n\t__test_attach_api(binary, pattern, opts, NULL);\n\n\t \n\tchild = spawn_child();\n\tif (!ASSERT_OK_PTR(child, \"spawn_child\"))\n\t\treturn;\n\n\t__test_attach_api(binary, pattern, opts, child);\n}\n\nstatic void test_attach_api_pattern(void)\n{\n\tLIBBPF_OPTS(bpf_uprobe_multi_opts, opts);\n\n\ttest_attach_api(\"/proc/self/exe\", \"uprobe_multi_func_*\", &opts);\n\ttest_attach_api(\"/proc/self/exe\", \"uprobe_multi_func_?\", &opts);\n}\n\nstatic void test_attach_api_syms(void)\n{\n\tLIBBPF_OPTS(bpf_uprobe_multi_opts, opts);\n\tconst char *syms[3] = {\n\t\t\"uprobe_multi_func_1\",\n\t\t\"uprobe_multi_func_2\",\n\t\t\"uprobe_multi_func_3\",\n\t};\n\n\topts.syms = syms;\n\topts.cnt = ARRAY_SIZE(syms);\n\ttest_attach_api(\"/proc/self/exe\", NULL, &opts);\n}\n\nstatic void __test_link_api(struct child *child)\n{\n\tint prog_fd, link1_fd = -1, link2_fd = -1, link3_fd = -1, link4_fd = -1;\n\tLIBBPF_OPTS(bpf_link_create_opts, opts);\n\tconst char *path = \"/proc/self/exe\";\n\tstruct uprobe_multi *skel = NULL;\n\tunsigned long *offsets = NULL;\n\tconst char *syms[3] = {\n\t\t\"uprobe_multi_func_1\",\n\t\t\"uprobe_multi_func_2\",\n\t\t\"uprobe_multi_func_3\",\n\t};\n\tint link_extra_fd = -1;\n\tint err;\n\n\terr = elf_resolve_syms_offsets(path, 3, syms, (unsigned long **) &offsets);\n\tif (!ASSERT_OK(err, \"elf_resolve_syms_offsets\"))\n\t\treturn;\n\n\topts.uprobe_multi.path = path;\n\topts.uprobe_multi.offsets = offsets;\n\topts.uprobe_multi.cnt = ARRAY_SIZE(syms);\n\topts.uprobe_multi.pid = child ? child->pid : 0;\n\n\tskel = uprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi__open_and_load\"))\n\t\tgoto cleanup;\n\n\topts.kprobe_multi.flags = 0;\n\tprog_fd = bpf_program__fd(skel->progs.uprobe);\n\tlink1_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_UPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link1_fd, 0, \"link1_fd\"))\n\t\tgoto cleanup;\n\n\topts.kprobe_multi.flags = BPF_F_UPROBE_MULTI_RETURN;\n\tprog_fd = bpf_program__fd(skel->progs.uretprobe);\n\tlink2_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_UPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link2_fd, 0, \"link2_fd\"))\n\t\tgoto cleanup;\n\n\topts.kprobe_multi.flags = 0;\n\tprog_fd = bpf_program__fd(skel->progs.uprobe_sleep);\n\tlink3_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_UPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link3_fd, 0, \"link3_fd\"))\n\t\tgoto cleanup;\n\n\topts.kprobe_multi.flags = BPF_F_UPROBE_MULTI_RETURN;\n\tprog_fd = bpf_program__fd(skel->progs.uretprobe_sleep);\n\tlink4_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_UPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link4_fd, 0, \"link4_fd\"))\n\t\tgoto cleanup;\n\n\topts.kprobe_multi.flags = 0;\n\topts.uprobe_multi.pid = 0;\n\tprog_fd = bpf_program__fd(skel->progs.uprobe_extra);\n\tlink_extra_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_UPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link_extra_fd, 0, \"link_extra_fd\"))\n\t\tgoto cleanup;\n\n\tuprobe_multi_test_run(skel, child);\n\ncleanup:\n\tif (link1_fd >= 0)\n\t\tclose(link1_fd);\n\tif (link2_fd >= 0)\n\t\tclose(link2_fd);\n\tif (link3_fd >= 0)\n\t\tclose(link3_fd);\n\tif (link4_fd >= 0)\n\t\tclose(link4_fd);\n\tif (link_extra_fd >= 0)\n\t\tclose(link_extra_fd);\n\n\tuprobe_multi__destroy(skel);\n\tfree(offsets);\n}\n\nvoid test_link_api(void)\n{\n\tstruct child *child;\n\n\t \n\t__test_link_api(NULL);\n\n\t \n\tchild = spawn_child();\n\tif (!ASSERT_OK_PTR(child, \"spawn_child\"))\n\t\treturn;\n\n\t__test_link_api(child);\n}\n\nstatic void test_bench_attach_uprobe(void)\n{\n\tlong attach_start_ns = 0, attach_end_ns = 0;\n\tstruct uprobe_multi_bench *skel = NULL;\n\tlong detach_start_ns, detach_end_ns;\n\tdouble attach_delta, detach_delta;\n\tint err;\n\n\tskel = uprobe_multi_bench__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi_bench__open_and_load\"))\n\t\tgoto cleanup;\n\n\tattach_start_ns = get_time_ns();\n\n\terr = uprobe_multi_bench__attach(skel);\n\tif (!ASSERT_OK(err, \"uprobe_multi_bench__attach\"))\n\t\tgoto cleanup;\n\n\tattach_end_ns = get_time_ns();\n\n\tsystem(\"./uprobe_multi bench\");\n\n\tASSERT_EQ(skel->bss->count, 50000, \"uprobes_count\");\n\ncleanup:\n\tdetach_start_ns = get_time_ns();\n\tuprobe_multi_bench__destroy(skel);\n\tdetach_end_ns = get_time_ns();\n\n\tattach_delta = (attach_end_ns - attach_start_ns) / 1000000000.0;\n\tdetach_delta = (detach_end_ns - detach_start_ns) / 1000000000.0;\n\n\tprintf(\"%s: attached in %7.3lfs\\n\", __func__, attach_delta);\n\tprintf(\"%s: detached in %7.3lfs\\n\", __func__, detach_delta);\n}\n\nstatic void test_bench_attach_usdt(void)\n{\n\tlong attach_start_ns = 0, attach_end_ns = 0;\n\tstruct uprobe_multi_usdt *skel = NULL;\n\tlong detach_start_ns, detach_end_ns;\n\tdouble attach_delta, detach_delta;\n\n\tskel = uprobe_multi_usdt__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi__open\"))\n\t\tgoto cleanup;\n\n\tattach_start_ns = get_time_ns();\n\n\tskel->links.usdt0 = bpf_program__attach_usdt(skel->progs.usdt0, -1, \"./uprobe_multi\",\n\t\t\t\t\t\t     \"test\", \"usdt\", NULL);\n\tif (!ASSERT_OK_PTR(skel->links.usdt0, \"bpf_program__attach_usdt\"))\n\t\tgoto cleanup;\n\n\tattach_end_ns = get_time_ns();\n\n\tsystem(\"./uprobe_multi usdt\");\n\n\tASSERT_EQ(skel->bss->count, 50000, \"usdt_count\");\n\ncleanup:\n\tdetach_start_ns = get_time_ns();\n\tuprobe_multi_usdt__destroy(skel);\n\tdetach_end_ns = get_time_ns();\n\n\tattach_delta = (attach_end_ns - attach_start_ns) / 1000000000.0;\n\tdetach_delta = (detach_end_ns - detach_start_ns) / 1000000000.0;\n\n\tprintf(\"%s: attached in %7.3lfs\\n\", __func__, attach_delta);\n\tprintf(\"%s: detached in %7.3lfs\\n\", __func__, detach_delta);\n}\n\nvoid test_uprobe_multi_test(void)\n{\n\tif (test__start_subtest(\"skel_api\"))\n\t\ttest_skel_api();\n\tif (test__start_subtest(\"attach_api_pattern\"))\n\t\ttest_attach_api_pattern();\n\tif (test__start_subtest(\"attach_api_syms\"))\n\t\ttest_attach_api_syms();\n\tif (test__start_subtest(\"link_api\"))\n\t\ttest_link_api();\n\tif (test__start_subtest(\"bench_uprobe\"))\n\t\ttest_bench_attach_uprobe();\n\tif (test__start_subtest(\"bench_usdt\"))\n\t\ttest_bench_attach_usdt();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}