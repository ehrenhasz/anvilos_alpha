{
  "module_name": "assign_reuse.c",
  "hash_id": "6242524f8b7809c64514b829f2836f271581a94a229ba85b07f0523c3b2058d9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/assign_reuse.c",
  "human_readable_source": "\n \n#include <uapi/linux/if_link.h>\n#include <test_progs.h>\n\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n\n#include \"network_helpers.h\"\n#include \"test_assign_reuse.skel.h\"\n\n#define NS_TEST \"assign_reuse\"\n#define LOOPBACK 1\n#define PORT 4443\n\nstatic int attach_reuseport(int sock_fd, int prog_fd)\n{\n\treturn setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF,\n\t\t\t  &prog_fd, sizeof(prog_fd));\n}\n\nstatic __u64 cookie(int fd)\n{\n\t__u64 cookie = 0;\n\tsocklen_t cookie_len = sizeof(cookie);\n\tint ret;\n\n\tret = getsockopt(fd, SOL_SOCKET, SO_COOKIE, &cookie, &cookie_len);\n\tASSERT_OK(ret, \"cookie\");\n\tASSERT_GT(cookie, 0, \"cookie_invalid\");\n\n\treturn cookie;\n}\n\nstatic int echo_test_udp(int fd_sv)\n{\n\tstruct sockaddr_storage addr = {};\n\tsocklen_t len = sizeof(addr);\n\tchar buff[1] = {};\n\tint fd_cl = -1, ret;\n\n\tfd_cl = connect_to_fd(fd_sv, 100);\n\tASSERT_GT(fd_cl, 0, \"create_client\");\n\tASSERT_EQ(getsockname(fd_cl, (void *)&addr, &len), 0, \"getsockname\");\n\n\tASSERT_EQ(send(fd_cl, buff, sizeof(buff), 0), 1, \"send_client\");\n\n\tret = recv(fd_sv, buff, sizeof(buff), 0);\n\tif (ret < 0) {\n\t\tclose(fd_cl);\n\t\treturn errno;\n\t}\n\n\tASSERT_EQ(ret, 1, \"recv_server\");\n\tASSERT_EQ(sendto(fd_sv, buff, sizeof(buff), 0, (void *)&addr, len), 1, \"send_server\");\n\tASSERT_EQ(recv(fd_cl, buff, sizeof(buff), 0), 1, \"recv_client\");\n\tclose(fd_cl);\n\treturn 0;\n}\n\nstatic int echo_test_tcp(int fd_sv)\n{\n\tchar buff[1] = {};\n\tint fd_cl = -1, fd_sv_cl = -1;\n\n\tfd_cl = connect_to_fd(fd_sv, 100);\n\tif (fd_cl < 0)\n\t\treturn errno;\n\n\tfd_sv_cl = accept(fd_sv, NULL, NULL);\n\tASSERT_GE(fd_sv_cl, 0, \"accept_fd\");\n\n\tASSERT_EQ(send(fd_cl, buff, sizeof(buff), 0), 1, \"send_client\");\n\tASSERT_EQ(recv(fd_sv_cl, buff, sizeof(buff), 0), 1, \"recv_server\");\n\tASSERT_EQ(send(fd_sv_cl, buff, sizeof(buff), 0), 1, \"send_server\");\n\tASSERT_EQ(recv(fd_cl, buff, sizeof(buff), 0), 1, \"recv_client\");\n\tclose(fd_sv_cl);\n\tclose(fd_cl);\n\treturn 0;\n}\n\nvoid run_assign_reuse(int family, int sotype, const char *ip, __u16 port)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tc_hook, tc_hook,\n\t\t.ifindex = LOOPBACK,\n\t\t.attach_point = BPF_TC_INGRESS,\n\t);\n\tDECLARE_LIBBPF_OPTS(bpf_tc_opts, tc_opts,\n\t\t.handle = 1,\n\t\t.priority = 1,\n\t);\n\tbool hook_created = false, tc_attached = false;\n\tint ret, fd_tc, fd_accept, fd_drop, fd_map;\n\tint *fd_sv = NULL;\n\t__u64 fd_val;\n\tstruct test_assign_reuse *skel;\n\tconst int zero = 0;\n\n\tskel = test_assign_reuse__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tskel->rodata->dest_port = port;\n\n\tret = test_assign_reuse__load(skel);\n\tif (!ASSERT_OK(ret, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(skel->bss->sk_cookie_seen, 0, \"cookie_init\");\n\n\tfd_tc = bpf_program__fd(skel->progs.tc_main);\n\tfd_accept = bpf_program__fd(skel->progs.reuse_accept);\n\tfd_drop = bpf_program__fd(skel->progs.reuse_drop);\n\tfd_map = bpf_map__fd(skel->maps.sk_map);\n\n\tfd_sv = start_reuseport_server(family, sotype, ip, port, 100, 1);\n\tif (!ASSERT_NEQ(fd_sv, NULL, \"start_reuseport_server\"))\n\t\tgoto cleanup;\n\n\tret = attach_reuseport(*fd_sv, fd_drop);\n\tif (!ASSERT_OK(ret, \"attach_reuseport\"))\n\t\tgoto cleanup;\n\n\tfd_val = *fd_sv;\n\tret = bpf_map_update_elem(fd_map, &zero, &fd_val, BPF_NOEXIST);\n\tif (!ASSERT_OK(ret, \"bpf_sk_map\"))\n\t\tgoto cleanup;\n\n\tret = bpf_tc_hook_create(&tc_hook);\n\tif (ret == 0)\n\t\thook_created = true;\n\tret = ret == -EEXIST ? 0 : ret;\n\tif (!ASSERT_OK(ret, \"bpf_tc_hook_create\"))\n\t\tgoto cleanup;\n\n\ttc_opts.prog_fd = fd_tc;\n\tret = bpf_tc_attach(&tc_hook, &tc_opts);\n\tif (!ASSERT_OK(ret, \"bpf_tc_attach\"))\n\t\tgoto cleanup;\n\ttc_attached = true;\n\n\tif (sotype == SOCK_STREAM)\n\t\tASSERT_EQ(echo_test_tcp(*fd_sv), ECONNREFUSED, \"drop_tcp\");\n\telse\n\t\tASSERT_EQ(echo_test_udp(*fd_sv), EAGAIN, \"drop_udp\");\n\tASSERT_EQ(skel->bss->reuseport_executed, 1, \"program executed once\");\n\n\tskel->bss->sk_cookie_seen = 0;\n\tskel->bss->reuseport_executed = 0;\n\tASSERT_OK(attach_reuseport(*fd_sv, fd_accept), \"attach_reuseport(accept)\");\n\n\tif (sotype == SOCK_STREAM)\n\t\tASSERT_EQ(echo_test_tcp(*fd_sv), 0, \"echo_tcp\");\n\telse\n\t\tASSERT_EQ(echo_test_udp(*fd_sv), 0, \"echo_udp\");\n\n\tASSERT_EQ(skel->bss->sk_cookie_seen, cookie(*fd_sv),\n\t\t  \"cookie_mismatch\");\n\tASSERT_EQ(skel->bss->reuseport_executed, 1, \"program executed once\");\ncleanup:\n\tif (tc_attached) {\n\t\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\t\tret = bpf_tc_detach(&tc_hook, &tc_opts);\n\t\tASSERT_OK(ret, \"bpf_tc_detach\");\n\t}\n\tif (hook_created) {\n\t\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\t\tbpf_tc_hook_destroy(&tc_hook);\n\t}\n\ttest_assign_reuse__destroy(skel);\n\tfree_fds(fd_sv, 1);\n}\n\nvoid test_assign_reuse(void)\n{\n\tstruct nstoken *tok = NULL;\n\n\tSYS(out, \"ip netns add %s\", NS_TEST);\n\tSYS(cleanup, \"ip -net %s link set dev lo up\", NS_TEST);\n\n\ttok = open_netns(NS_TEST);\n\tif (!ASSERT_OK_PTR(tok, \"netns token\"))\n\t\treturn;\n\n\tif (test__start_subtest(\"tcpv4\"))\n\t\trun_assign_reuse(AF_INET, SOCK_STREAM, \"127.0.0.1\", PORT);\n\tif (test__start_subtest(\"tcpv6\"))\n\t\trun_assign_reuse(AF_INET6, SOCK_STREAM, \"::1\", PORT);\n\tif (test__start_subtest(\"udpv4\"))\n\t\trun_assign_reuse(AF_INET, SOCK_DGRAM, \"127.0.0.1\", PORT);\n\tif (test__start_subtest(\"udpv6\"))\n\t\trun_assign_reuse(AF_INET6, SOCK_DGRAM, \"::1\", PORT);\n\ncleanup:\n\tclose_netns(tok);\n\tSYS_NOFAIL(\"ip netns delete %s\", NS_TEST);\nout:\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}