{
  "module_name": "map_init.c",
  "hash_id": "936c16778f0f0d41e64f91ff4766764c04f97cc0099daeb516dae55cc705cc7b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/map_init.c",
  "human_readable_source": "\n \n} __bpf_percpu_val_align pcpu_map_value_t;\n\n\nstatic int map_populate(int map_fd, int num)\n{\n\tpcpu_map_value_t value[nr_cpus];\n\tint i, err;\n\tmap_key_t key;\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_percpu(value, i) = FILL_VALUE;\n\n\tfor (key = 1; key <= num; key++) {\n\t\terr = bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct test_map_init *setup(enum bpf_map_type map_type, int map_sz,\n\t\t\t    int *map_fd, int populate)\n{\n\tstruct test_map_init *skel;\n\tint err;\n\n\tskel = test_map_init__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn NULL;\n\n\terr = bpf_map__set_type(skel->maps.hashmap1, map_type);\n\tif (!ASSERT_OK(err, \"bpf_map__set_type\"))\n\t\tgoto error;\n\n\terr = bpf_map__set_max_entries(skel->maps.hashmap1, map_sz);\n\tif (!ASSERT_OK(err, \"bpf_map__set_max_entries\"))\n\t\tgoto error;\n\n\terr = test_map_init__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto error;\n\n\t*map_fd = bpf_map__fd(skel->maps.hashmap1);\n\tif (CHECK(*map_fd < 0, \"bpf_map__fd\", \"failed\\n\"))\n\t\tgoto error;\n\n\terr = map_populate(*map_fd, populate);\n\tif (!ASSERT_OK(err, \"map_populate\"))\n\t\tgoto error_map;\n\n\treturn skel;\n\nerror_map:\n\tclose(*map_fd);\nerror:\n\ttest_map_init__destroy(skel);\n\treturn NULL;\n}\n\n \nstatic int prog_run_insert_elem(struct test_map_init *skel, map_key_t key,\n\t\t\t\tmap_value_t value)\n{\n\tstruct test_map_init__bss *bss;\n\n\tbss = skel->bss;\n\n\tbss->inKey = key;\n\tbss->inValue = value;\n\tbss->inPid = getpid();\n\n\tif (!ASSERT_OK(test_map_init__attach(skel), \"skel_attach\"))\n\t\treturn -1;\n\n\t \n\tsyscall(__NR_getpgid);\n\n\ttest_map_init__detach(skel);\n\n\treturn 0;\n}\n\nstatic int check_values_one_cpu(pcpu_map_value_t *value, map_value_t expected)\n{\n\tint i, nzCnt = 0;\n\tmap_value_t val;\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tval = bpf_percpu(value, i);\n\t\tif (val) {\n\t\t\tif (CHECK(val != expected, \"map value\",\n\t\t\t\t  \"unexpected for cpu %d: 0x%llx\\n\", i, val))\n\t\t\t\treturn -1;\n\t\t\tnzCnt++;\n\t\t}\n\t}\n\n\tif (CHECK(nzCnt != 1, \"map value\", \"set for %d CPUs instead of 1!\\n\",\n\t\t  nzCnt))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic void test_pcpu_map_init(void)\n{\n\tpcpu_map_value_t value[nr_cpus];\n\tstruct test_map_init *skel;\n\tint map_fd, err;\n\tmap_key_t key;\n\n\t \n\tskel = setup(BPF_MAP_TYPE_PERCPU_HASH, 1, &map_fd, 1);\n\tif (!ASSERT_OK_PTR(skel, \"prog_setup\"))\n\t\treturn;\n\n\t \n\tkey = 1;\n\terr = bpf_map_delete_elem(map_fd, &key);\n\tif (!ASSERT_OK(err, \"bpf_map_delete_elem\"))\n\t\tgoto cleanup;\n\n\t \n\terr = prog_run_insert_elem(skel, key, TEST_VALUE);\n\tif (!ASSERT_OK(err, \"prog_run_insert_elem\"))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, value);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\n\t \n\tcheck_values_one_cpu(value, TEST_VALUE);\n\ncleanup:\n\ttest_map_init__destroy(skel);\n}\n\n \nstatic void test_pcpu_lru_map_init(void)\n{\n\tpcpu_map_value_t value[nr_cpus];\n\tstruct test_map_init *skel;\n\tint map_fd, err;\n\tmap_key_t key;\n\n\t \n\tskel = setup(BPF_MAP_TYPE_LRU_PERCPU_HASH, 2, &map_fd, 2);\n\tif (!ASSERT_OK_PTR(skel, \"prog_setup\"))\n\t\treturn;\n\n\t \n\tkey = 3;\n\terr = prog_run_insert_elem(skel, key, TEST_VALUE);\n\tif (!ASSERT_OK(err, \"prog_run_insert_elem\"))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &key, value);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem\"))\n\t\tgoto cleanup;\n\n\t \n\tcheck_values_one_cpu(value, TEST_VALUE);\n\ncleanup:\n\ttest_map_init__destroy(skel);\n}\n\nvoid test_map_init(void)\n{\n\tnr_cpus = bpf_num_possible_cpus();\n\tif (nr_cpus <= 1) {\n\t\tprintf(\"%s:SKIP: >1 cpu needed for this test\\n\", __func__);\n\t\ttest__skip();\n\t\treturn;\n\t}\n\n\tif (test__start_subtest(\"pcpu_map_init\"))\n\t\ttest_pcpu_map_init();\n\tif (test__start_subtest(\"pcpu_lru_map_init\"))\n\t\ttest_pcpu_lru_map_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}