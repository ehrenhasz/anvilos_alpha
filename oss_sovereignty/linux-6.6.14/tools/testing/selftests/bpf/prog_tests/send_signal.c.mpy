{
  "module_name": "send_signal.c",
  "hash_id": "152856cf7966ed518abc023f5eb355ab51732b4ad1b708b33736780f709937a4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/send_signal.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include \"test_send_signal_kern.skel.h\"\n\nstatic int sigusr1_received;\n\nstatic void sigusr1_handler(int signum)\n{\n\tsigusr1_received = 1;\n}\n\nstatic void test_send_signal_common(struct perf_event_attr *attr,\n\t\t\t\t    bool signal_thread)\n{\n\tstruct test_send_signal_kern *skel;\n\tint pipe_c2p[2], pipe_p2c[2];\n\tint err = -1, pmu_fd = -1;\n\tchar buf[256];\n\tpid_t pid;\n\n\tif (!ASSERT_OK(pipe(pipe_c2p), \"pipe_c2p\"))\n\t\treturn;\n\n\tif (!ASSERT_OK(pipe(pipe_p2c), \"pipe_p2c\")) {\n\t\tclose(pipe_c2p[0]);\n\t\tclose(pipe_c2p[1]);\n\t\treturn;\n\t}\n\n\tpid = fork();\n\tif (!ASSERT_GE(pid, 0, \"fork\")) {\n\t\tclose(pipe_c2p[0]);\n\t\tclose(pipe_c2p[1]);\n\t\tclose(pipe_p2c[0]);\n\t\tclose(pipe_p2c[1]);\n\t\treturn;\n\t}\n\n\tif (pid == 0) {\n\t\tint old_prio;\n\t\tvolatile int j = 0;\n\n\t\t \n\t\tASSERT_NEQ(signal(SIGUSR1, sigusr1_handler), SIG_ERR, \"signal\");\n\n\t\tclose(pipe_c2p[0]);  \n\t\tclose(pipe_p2c[1]);  \n\n\t\t \n\t\terrno = 0;\n\t\told_prio = getpriority(PRIO_PROCESS, 0);\n\t\tASSERT_OK(errno, \"getpriority\");\n\t\tASSERT_OK(setpriority(PRIO_PROCESS, 0, -20), \"setpriority\");\n\n\t\t \n\t\tASSERT_EQ(write(pipe_c2p[1], buf, 1), 1, \"pipe_write\");\n\n\t\t \n\t\tASSERT_EQ(read(pipe_p2c[0], buf, 1), 1, \"pipe_read\");\n\n\t\t \n\t\tfor (int i = 0; i < 1000000000 && !sigusr1_received; i++) {\n\t\t\tj /= i + j + 1;\n\t\t\tif (!attr)\n\t\t\t\t \n\t\t\t\tusleep(1);\n\t\t}\n\n\t\tbuf[0] = sigusr1_received ? '2' : '0';\n\t\tASSERT_EQ(sigusr1_received, 1, \"sigusr1_received\");\n\t\tASSERT_EQ(write(pipe_c2p[1], buf, 1), 1, \"pipe_write\");\n\n\t\t \n\t\tASSERT_EQ(read(pipe_p2c[0], buf, 1), 1, \"pipe_read\");\n\n\t\t \n\t\tASSERT_OK(setpriority(PRIO_PROCESS, 0, old_prio), \"setpriority\");\n\n\t\tclose(pipe_c2p[1]);\n\t\tclose(pipe_p2c[0]);\n\t\texit(0);\n\t}\n\n\tclose(pipe_c2p[1]);  \n\tclose(pipe_p2c[0]);  \n\n\tskel = test_send_signal_kern__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\tgoto skel_open_load_failure;\n\n\tif (!attr) {\n\t\terr = test_send_signal_kern__attach(skel);\n\t\tif (!ASSERT_OK(err, \"skel_attach\")) {\n\t\t\terr = -1;\n\t\t\tgoto destroy_skel;\n\t\t}\n\t} else {\n\t\tpmu_fd = syscall(__NR_perf_event_open, attr, pid, -1  ,\n\t\t\t\t -1  , 0  );\n\t\tif (!ASSERT_GE(pmu_fd, 0, \"perf_event_open\")) {\n\t\t\terr = -1;\n\t\t\tgoto destroy_skel;\n\t\t}\n\n\t\tskel->links.send_signal_perf =\n\t\t\tbpf_program__attach_perf_event(skel->progs.send_signal_perf, pmu_fd);\n\t\tif (!ASSERT_OK_PTR(skel->links.send_signal_perf, \"attach_perf_event\"))\n\t\t\tgoto disable_pmu;\n\t}\n\n\t \n\tASSERT_EQ(read(pipe_c2p[0], buf, 1), 1, \"pipe_read\");\n\n\t \n\tskel->bss->signal_thread = signal_thread;\n\tskel->bss->sig = SIGUSR1;\n\tskel->bss->pid = pid;\n\n\t \n\tASSERT_EQ(write(pipe_p2c[1], buf, 1), 1, \"pipe_write\");\n\n\t \n\terr = read(pipe_c2p[0], buf, 1);\n\tif (!ASSERT_GE(err, 0, \"reading pipe\"))\n\t\tgoto disable_pmu;\n\tif (!ASSERT_GT(err, 0, \"reading pipe error: size 0\")) {\n\t\terr = -1;\n\t\tgoto disable_pmu;\n\t}\n\n\tASSERT_EQ(buf[0], '2', \"incorrect result\");\n\n\t \n\tASSERT_EQ(write(pipe_p2c[1], buf, 1), 1, \"pipe_write\");\n\ndisable_pmu:\n\tclose(pmu_fd);\ndestroy_skel:\n\ttest_send_signal_kern__destroy(skel);\nskel_open_load_failure:\n\tclose(pipe_c2p[0]);\n\tclose(pipe_p2c[1]);\n\twait(NULL);\n}\n\nstatic void test_send_signal_tracepoint(bool signal_thread)\n{\n\ttest_send_signal_common(NULL, signal_thread);\n}\n\nstatic void test_send_signal_perf(bool signal_thread)\n{\n\tstruct perf_event_attr attr = {\n\t\t.sample_period = 1,\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.config = PERF_COUNT_SW_CPU_CLOCK,\n\t};\n\n\ttest_send_signal_common(&attr, signal_thread);\n}\n\nstatic void test_send_signal_nmi(bool signal_thread)\n{\n\tstruct perf_event_attr attr = {\n\t\t.sample_period = 1,\n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t};\n\tint pmu_fd;\n\n\t \n\tpmu_fd = syscall(__NR_perf_event_open, &attr, 0  ,\n\t\t\t -1  , -1  , 0  );\n\tif (pmu_fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\tprintf(\"%s:SKIP:no PERF_COUNT_HW_CPU_CYCLES\\n\",\n\t\t\t       __func__);\n\t\t\ttest__skip();\n\t\t\treturn;\n\t\t}\n\t\t \n\t} else {\n\t\tclose(pmu_fd);\n\t}\n\n\ttest_send_signal_common(&attr, signal_thread);\n}\n\nvoid test_send_signal(void)\n{\n\tif (test__start_subtest(\"send_signal_tracepoint\"))\n\t\ttest_send_signal_tracepoint(false);\n\tif (test__start_subtest(\"send_signal_perf\"))\n\t\ttest_send_signal_perf(false);\n\tif (test__start_subtest(\"send_signal_nmi\"))\n\t\ttest_send_signal_nmi(false);\n\tif (test__start_subtest(\"send_signal_tracepoint_thread\"))\n\t\ttest_send_signal_tracepoint(true);\n\tif (test__start_subtest(\"send_signal_perf_thread\"))\n\t\ttest_send_signal_perf(true);\n\tif (test__start_subtest(\"send_signal_nmi_thread\"))\n\t\ttest_send_signal_nmi(true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}