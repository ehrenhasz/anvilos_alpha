{
  "module_name": "btf_dedup_split.c",
  "hash_id": "e9ea4bd28351b87f9b84b54107183dc4a216313587f1dfb99a1b29efa64273c5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_dedup_split.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <bpf/btf.h>\n#include \"btf_helpers.h\"\n\nstatic void test_split_simple() {\n\tconst struct btf_type *t;\n\tstruct btf *btf1, *btf2;\n\tint str_off, err;\n\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"empty_main_btf\"))\n\t\treturn;\n\n\tbtf__set_pointer_size(btf1, 8);  \n\n\tbtf__add_int(btf1, \"int\", 4, BTF_INT_SIGNED);\t \n\tbtf__add_ptr(btf1, 1);\t\t\t\t \n\tbtf__add_struct(btf1, \"s1\", 4);\t\t\t \n\tbtf__add_field(btf1, \"f1\", 1, 0, 0);\t\t \n\t\t\t\t\t\t\t \n\n\tVALIDATE_RAW_BTF(\n\t\tbtf1,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=1\",\n\t\t\"[3] STRUCT 's1' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\");\n\n\tASSERT_STREQ(btf_type_c_dump(btf1), \"\\\nstruct s1 {\\n\\\n\tint f1;\\n\\\n};\\n\\n\", \"c_dump\");\n\n\tbtf2 = btf__new_empty_split(btf1);\n\tif (!ASSERT_OK_PTR(btf2, \"empty_split_btf\"))\n\t\tgoto cleanup;\n\n\t/* pointer size should be \"inherited\" from main BTF */\n\tASSERT_EQ(btf__pointer_size(btf2), 8, \"inherit_ptr_sz\");\n\n\tstr_off = btf__find_str(btf2, \"int\");\n\tASSERT_NEQ(str_off, -ENOENT, \"str_int_missing\");\n\n\tt = btf__type_by_id(btf2, 1);\n\tif (!ASSERT_OK_PTR(t, \"int_type\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(btf_is_int(t), true, \"int_kind\");\n\tASSERT_STREQ(btf__str_by_offset(btf2, t->name_off), \"int\", \"int_name\");\n\n\tbtf__add_struct(btf2, \"s2\", 16);\t\t/* [4] struct s2 {\t*/\n\tbtf__add_field(btf2, \"f1\", 6, 0, 0);\t\t/*      struct s1 f1;\t*/\n\tbtf__add_field(btf2, \"f2\", 5, 32, 0);\t\t/*      int f2;\t\t*/\n\tbtf__add_field(btf2, \"f3\", 2, 64, 0);\t\t/*      int *f3;\t*/\n\t\t\t\t\t\t\t/* } */\n\n\t/* duplicated int */\n\tbtf__add_int(btf2, \"int\", 4, BTF_INT_SIGNED);\t/* [5] int */\n\n\t/* duplicated struct s1 */\n\tbtf__add_struct(btf2, \"s1\", 4);\t\t\t/* [6] struct s1 { */\n\tbtf__add_field(btf2, \"f1\", 5, 0, 0);\t\t/*      int f1; */\n\t\t\t\t\t\t\t/* } */\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=1\",\n\t\t\"[3] STRUCT 's1' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[4] STRUCT 's2' size=16 vlen=3\\n\"\n\t\t\"\\t'f1' type_id=6 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=5 bits_offset=32\\n\"\n\t\t\"\\t'f3' type_id=2 bits_offset=64\",\n\t\t\"[5] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[6] STRUCT 's1' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=5 bits_offset=0\");\n\n\tASSERT_STREQ(btf_type_c_dump(btf2), \"\\\nstruct s1 {\\n\\\n\tint f1;\\n\\\n};\\n\\\n\\n\\\nstruct s1___2 {\\n\\\n\tint f1;\\n\\\n};\\n\\\n\\n\\\nstruct s2 {\\n\\\n\tstruct s1___2 f1;\\n\\\n\tint f2;\\n\\\n\tint *f3;\\n\\\n};\\n\\n\", \"c_dump\");\n\n\terr = btf__dedup(btf2, NULL);\n\tif (!ASSERT_OK(err, \"btf_dedup\"))\n\t\tgoto cleanup;\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=1\",\n\t\t\"[3] STRUCT 's1' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[4] STRUCT 's2' size=16 vlen=3\\n\"\n\t\t\"\\t'f1' type_id=3 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=1 bits_offset=32\\n\"\n\t\t\"\\t'f3' type_id=2 bits_offset=64\");\n\n\tASSERT_STREQ(btf_type_c_dump(btf2), \"\\\nstruct s1 {\\n\\\n\tint f1;\\n\\\n};\\n\\\n\\n\\\nstruct s2 {\\n\\\n\tstruct s1 f1;\\n\\\n\tint f2;\\n\\\n\tint *f3;\\n\\\n};\\n\\n\", \"c_dump\");\n\ncleanup:\n\tbtf__free(btf2);\n\tbtf__free(btf1);\n}\n\nstatic void test_split_fwd_resolve() {\n\tstruct btf *btf1, *btf2;\n\tint err;\n\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"empty_main_btf\"))\n\t\treturn;\n\n\tbtf__set_pointer_size(btf1, 8); /* enforce 64-bit arch */\n\n\tbtf__add_int(btf1, \"int\", 4, BTF_INT_SIGNED);\t/* [1] int */\n\tbtf__add_ptr(btf1, 4);\t\t\t\t/* [2] ptr to struct s1 */\n\tbtf__add_ptr(btf1, 5);\t\t\t\t/* [3] ptr to struct s2 */\n\tbtf__add_struct(btf1, \"s1\", 16);\t\t/* [4] struct s1 { */\n\tbtf__add_field(btf1, \"f1\", 2, 0, 0);\t\t/*      struct s1 *f1; */\n\tbtf__add_field(btf1, \"f2\", 3, 64, 0);\t\t/*      struct s2 *f2; */\n\t\t\t\t\t\t\t/* } */\n\tbtf__add_struct(btf1, \"s2\", 4);\t\t\t/* [5] struct s2 { */\n\tbtf__add_field(btf1, \"f1\", 1, 0, 0);\t\t/*      int f1; */\n\t\t\t\t\t\t\t/* } */\n\t/* keep this not a part of type the graph to test btf_dedup_resolve_fwds */\n\tbtf__add_struct(btf1, \"s3\", 4);                 /* [6] struct s3 { */\n\tbtf__add_field(btf1, \"f1\", 1, 0, 0);\t\t/*      int f1; */\n\t\t\t\t\t\t\t/* } */\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf1,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=4\",\n\t\t\"[3] PTR '(anon)' type_id=5\",\n\t\t\"[4] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=3 bits_offset=64\",\n\t\t\"[5] STRUCT 's2' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[6] STRUCT 's3' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\");\n\n\tbtf2 = btf__new_empty_split(btf1);\n\tif (!ASSERT_OK_PTR(btf2, \"empty_split_btf\"))\n\t\tgoto cleanup;\n\n\tbtf__add_int(btf2, \"int\", 4, BTF_INT_SIGNED);\t/* [7] int */\n\tbtf__add_ptr(btf2, 11);\t\t\t\t/* [8] ptr to struct s1 */\n\tbtf__add_fwd(btf2, \"s2\", BTF_FWD_STRUCT);\t/* [9] fwd for struct s2 */\n\tbtf__add_ptr(btf2, 9);\t\t\t\t/* [10] ptr to fwd struct s2 */\n\tbtf__add_struct(btf2, \"s1\", 16);\t\t/* [11] struct s1 { */\n\tbtf__add_field(btf2, \"f1\", 8, 0, 0);\t\t/*      struct s1 *f1; */\n\tbtf__add_field(btf2, \"f2\", 10, 64, 0);\t\t/*      struct s2 *f2; */\n\t\t\t\t\t\t\t/* } */\n\tbtf__add_fwd(btf2, \"s3\", BTF_FWD_STRUCT);\t/* [12] fwd for struct s3 */\n\tbtf__add_ptr(btf2, 12);\t\t\t\t/* [13] ptr to struct s1 */\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=4\",\n\t\t\"[3] PTR '(anon)' type_id=5\",\n\t\t\"[4] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=3 bits_offset=64\",\n\t\t\"[5] STRUCT 's2' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[6] STRUCT 's3' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[7] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[8] PTR '(anon)' type_id=11\",\n\t\t\"[9] FWD 's2' fwd_kind=struct\",\n\t\t\"[10] PTR '(anon)' type_id=9\",\n\t\t\"[11] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=8 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=10 bits_offset=64\",\n\t\t\"[12] FWD 's3' fwd_kind=struct\",\n\t\t\"[13] PTR '(anon)' type_id=12\");\n\n\terr = btf__dedup(btf2, NULL);\n\tif (!ASSERT_OK(err, \"btf_dedup\"))\n\t\tgoto cleanup;\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=4\",\n\t\t\"[3] PTR '(anon)' type_id=5\",\n\t\t\"[4] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=3 bits_offset=64\",\n\t\t\"[5] STRUCT 's2' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[6] STRUCT 's3' size=4 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=1 bits_offset=0\",\n\t\t\"[7] PTR '(anon)' type_id=6\");\n\ncleanup:\n\tbtf__free(btf2);\n\tbtf__free(btf1);\n}\n\nstatic void test_split_struct_duped() {\n\tstruct btf *btf1, *btf2;\n\tint err;\n\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"empty_main_btf\"))\n\t\treturn;\n\n\tbtf__set_pointer_size(btf1, 8); /* enforce 64-bit arch */\n\n\tbtf__add_int(btf1, \"int\", 4, BTF_INT_SIGNED);\t/* [1] int */\n\tbtf__add_ptr(btf1, 5);\t\t\t\t/* [2] ptr to struct s1 */\n\tbtf__add_fwd(btf1, \"s2\", BTF_FWD_STRUCT);\t/* [3] fwd for struct s2 */\n\tbtf__add_ptr(btf1, 3);\t\t\t\t/* [4] ptr to fwd struct s2 */\n\tbtf__add_struct(btf1, \"s1\", 16);\t\t/* [5] struct s1 { */\n\tbtf__add_field(btf1, \"f1\", 2, 0, 0);\t\t/*      struct s1 *f1; */\n\tbtf__add_field(btf1, \"f2\", 4, 64, 0);\t\t/*      struct s2 *f2; */\n\t\t\t\t\t\t\t/* } */\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf1,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=5\",\n\t\t\"[3] FWD 's2' fwd_kind=struct\",\n\t\t\"[4] PTR '(anon)' type_id=3\",\n\t\t\"[5] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=4 bits_offset=64\");\n\n\tbtf2 = btf__new_empty_split(btf1);\n\tif (!ASSERT_OK_PTR(btf2, \"empty_split_btf\"))\n\t\tgoto cleanup;\n\n\tbtf__add_int(btf2, \"int\", 4, BTF_INT_SIGNED);\t/* [6] int */\n\tbtf__add_ptr(btf2, 10);\t\t\t\t/* [7] ptr to struct s1 */\n\tbtf__add_fwd(btf2, \"s2\", BTF_FWD_STRUCT);\t/* [8] fwd for struct s2 */\n\tbtf__add_ptr(btf2, 11);\t\t\t\t/* [9] ptr to struct s2 */\n\tbtf__add_struct(btf2, \"s1\", 16);\t\t/* [10] struct s1 { */\n\tbtf__add_field(btf2, \"f1\", 7, 0, 0);\t\t/*      struct s1 *f1; */\n\tbtf__add_field(btf2, \"f2\", 9, 64, 0);\t\t/*      struct s2 *f2; */\n\t\t\t\t\t\t\t/* } */\n\tbtf__add_struct(btf2, \"s2\", 40);\t\t/* [11] struct s2 {\t*/\n\tbtf__add_field(btf2, \"f1\", 7, 0, 0);\t\t/*      struct s1 *f1;\t*/\n\tbtf__add_field(btf2, \"f2\", 9, 64, 0);\t\t/*      struct s2 *f2;\t*/\n\tbtf__add_field(btf2, \"f3\", 6, 128, 0);\t\t/*      int f3;\t\t*/\n\tbtf__add_field(btf2, \"f4\", 10, 192, 0);\t\t/*      struct s1 f4;\t*/\n\t\t\t\t\t\t\t/* } */\n\tbtf__add_ptr(btf2, 8);\t\t\t\t/* [12] ptr to fwd struct s2 */\n\tbtf__add_struct(btf2, \"s3\", 8);\t\t\t/* [13] struct s3 { */\n\tbtf__add_field(btf2, \"f1\", 12, 0, 0);\t\t/*      struct s2 *f1; (fwd) */\n\t\t\t\t\t\t\t/* } */\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=5\",\n\t\t\"[3] FWD 's2' fwd_kind=struct\",\n\t\t\"[4] PTR '(anon)' type_id=3\",\n\t\t\"[5] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=4 bits_offset=64\",\n\t\t\"[6] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[7] PTR '(anon)' type_id=10\",\n\t\t\"[8] FWD 's2' fwd_kind=struct\",\n\t\t\"[9] PTR '(anon)' type_id=11\",\n\t\t\"[10] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=7 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=9 bits_offset=64\",\n\t\t\"[11] STRUCT 's2' size=40 vlen=4\\n\"\n\t\t\"\\t'f1' type_id=7 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=9 bits_offset=64\\n\"\n\t\t\"\\t'f3' type_id=6 bits_offset=128\\n\"\n\t\t\"\\t'f4' type_id=10 bits_offset=192\",\n\t\t\"[12] PTR '(anon)' type_id=8\",\n\t\t\"[13] STRUCT 's3' size=8 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=12 bits_offset=0\");\n\n\terr = btf__dedup(btf2, NULL);\n\tif (!ASSERT_OK(err, \"btf_dedup\"))\n\t\tgoto cleanup;\n\n\tVALIDATE_RAW_BTF(\n\t\tbtf2,\n\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\"[2] PTR '(anon)' type_id=5\",\n\t\t\"[3] FWD 's2' fwd_kind=struct\",\n\t\t\"[4] PTR '(anon)' type_id=3\",\n\t\t\"[5] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=2 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=4 bits_offset=64\",\n\t\t\"[6] PTR '(anon)' type_id=8\",\n\t\t\"[7] PTR '(anon)' type_id=9\",\n\t\t\"[8] STRUCT 's1' size=16 vlen=2\\n\"\n\t\t\"\\t'f1' type_id=6 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=7 bits_offset=64\",\n\t\t\"[9] STRUCT 's2' size=40 vlen=4\\n\"\n\t\t\"\\t'f1' type_id=6 bits_offset=0\\n\"\n\t\t\"\\t'f2' type_id=7 bits_offset=64\\n\"\n\t\t\"\\t'f3' type_id=1 bits_offset=128\\n\"\n\t\t\"\\t'f4' type_id=8 bits_offset=192\",\n\t\t\"[10] STRUCT 's3' size=8 vlen=1\\n\"\n\t\t\"\\t'f1' type_id=7 bits_offset=0\");\n\ncleanup:\n\tbtf__free(btf2);\n\tbtf__free(btf1);\n}\n\nstatic void btf_add_dup_struct_in_cu(struct btf *btf, int start_id)\n{\n#define ID(n) (start_id + n)\n\tbtf__set_pointer_size(btf, 8); /* enforce 64-bit arch */\n\n\tbtf__add_int(btf, \"int\", 4, BTF_INT_SIGNED);    /* [1] int */\n\n\tbtf__add_struct(btf, \"s\", 8);                   /* [2] struct s { */\n\tbtf__add_field(btf, \"a\", ID(3), 0, 0);          /*      struct anon a; */\n\tbtf__add_field(btf, \"b\", ID(4), 0, 0);          /*      struct anon b; */\n\t\t\t\t\t\t\t/* } */\n\n\tbtf__add_struct(btf, \"(anon)\", 8);              /* [3] struct anon { */\n\tbtf__add_field(btf, \"f1\", ID(1), 0, 0);         /*      int f1; */\n\tbtf__add_field(btf, \"f2\", ID(1), 32, 0);        /*      int f2; */\n\t\t\t\t\t\t\t/* } */\n\n\tbtf__add_struct(btf, \"(anon)\", 8);              /* [4] struct anon { */\n\tbtf__add_field(btf, \"f1\", ID(1), 0, 0);         /*      int f1; */\n\tbtf__add_field(btf, \"f2\", ID(1), 32, 0);        /*      int f2; */\n\t\t\t\t\t\t\t/* } */\n#undef ID\n}\n\nstatic void test_split_dup_struct_in_cu()\n{\n\tstruct btf *btf1, *btf2 = NULL;\n\tint err;\n\n\t/* generate the base data.. */\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"empty_main_btf\"))\n\t\treturn;\n\n\tbtf_add_dup_struct_in_cu(btf1, 0);\n\n\tVALIDATE_RAW_BTF(\n\t\t\tbtf1,\n\t\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\t\"[2] STRUCT 's' size=8 vlen=2\\n\"\n\t\t\t\"\\t'a' type_id=3 bits_offset=0\\n\"\n\t\t\t\"\\t'b' type_id=4 bits_offset=0\",\n\t\t\t\"[3] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=1 bits_offset=32\",\n\t\t\t\"[4] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=1 bits_offset=32\");\n\n\t/* ..dedup them... */\n\terr = btf__dedup(btf1, NULL);\n\tif (!ASSERT_OK(err, \"btf_dedup\"))\n\t\tgoto cleanup;\n\n\tVALIDATE_RAW_BTF(\n\t\t\tbtf1,\n\t\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\t\"[2] STRUCT 's' size=8 vlen=2\\n\"\n\t\t\t\"\\t'a' type_id=3 bits_offset=0\\n\"\n\t\t\t\"\\t'b' type_id=3 bits_offset=0\",\n\t\t\t\"[3] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=1 bits_offset=32\");\n\n\t/* and add the same data on top of it */\n\tbtf2 = btf__new_empty_split(btf1);\n\tif (!ASSERT_OK_PTR(btf2, \"empty_split_btf\"))\n\t\tgoto cleanup;\n\n\tbtf_add_dup_struct_in_cu(btf2, 3);\n\n\tVALIDATE_RAW_BTF(\n\t\t\tbtf2,\n\t\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\t\"[2] STRUCT 's' size=8 vlen=2\\n\"\n\t\t\t\"\\t'a' type_id=3 bits_offset=0\\n\"\n\t\t\t\"\\t'b' type_id=3 bits_offset=0\",\n\t\t\t\"[3] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=1 bits_offset=32\",\n\t\t\t\"[4] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\t\"[5] STRUCT 's' size=8 vlen=2\\n\"\n\t\t\t\"\\t'a' type_id=6 bits_offset=0\\n\"\n\t\t\t\"\\t'b' type_id=7 bits_offset=0\",\n\t\t\t\"[6] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=4 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=4 bits_offset=32\",\n\t\t\t\"[7] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=4 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=4 bits_offset=32\");\n\n\terr = btf__dedup(btf2, NULL);\n\tif (!ASSERT_OK(err, \"btf_dedup\"))\n\t\tgoto cleanup;\n\n\t/* after dedup it should match the original data */\n\tVALIDATE_RAW_BTF(\n\t\t\tbtf2,\n\t\t\t\"[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\",\n\t\t\t\"[2] STRUCT 's' size=8 vlen=2\\n\"\n\t\t\t\"\\t'a' type_id=3 bits_offset=0\\n\"\n\t\t\t\"\\t'b' type_id=3 bits_offset=0\",\n\t\t\t\"[3] STRUCT '(anon)' size=8 vlen=2\\n\"\n\t\t\t\"\\t'f1' type_id=1 bits_offset=0\\n\"\n\t\t\t\"\\t'f2' type_id=1 bits_offset=32\");\n\ncleanup:\n\tbtf__free(btf2);\n\tbtf__free(btf1);\n}\n\nvoid test_btf_dedup_split()\n{\n\tif (test__start_subtest(\"split_simple\"))\n\t\ttest_split_simple();\n\tif (test__start_subtest(\"split_struct_duped\"))\n\t\ttest_split_struct_duped();\n\tif (test__start_subtest(\"split_fwd_resolve\"))\n\t\ttest_split_fwd_resolve();\n\tif (test__start_subtest(\"split_dup_struct_in_cu\"))\n\t\ttest_split_dup_struct_in_cu();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}