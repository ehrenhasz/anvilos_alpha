{
  "module_name": "task_local_storage.c",
  "hash_id": "3f9ea8948f254b47d9dec8912eb0b46db8cabf9734f16d8e1c2c6019de0ef572",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/task_local_storage.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE          \n#include <unistd.h>\n#include <sched.h>\n#include <pthread.h>\n#include <sys/syscall.h>    \n#include <sys/types.h>\n#include <test_progs.h>\n#include \"task_local_storage_helpers.h\"\n#include \"task_local_storage.skel.h\"\n#include \"task_local_storage_exit_creds.skel.h\"\n#include \"task_ls_recursion.skel.h\"\n#include \"task_storage_nodeadlock.skel.h\"\n\nstatic void test_sys_enter_exit(void)\n{\n\tstruct task_local_storage *skel;\n\tint err;\n\n\tskel = task_local_storage__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\treturn;\n\n\tskel->bss->target_pid = syscall(SYS_gettid);\n\n\terr = task_local_storage__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\tsyscall(SYS_gettid);\n\tsyscall(SYS_gettid);\n\n\t \n\tASSERT_EQ(skel->bss->enter_cnt, 3, \"enter_cnt\");\n\tASSERT_EQ(skel->bss->exit_cnt, 3, \"exit_cnt\");\n\tASSERT_EQ(skel->bss->mismatch_cnt, 0, \"mismatch_cnt\");\nout:\n\ttask_local_storage__destroy(skel);\n}\n\nstatic void test_exit_creds(void)\n{\n\tstruct task_local_storage_exit_creds *skel;\n\tint err, run_count, sync_rcu_calls = 0;\n\tconst int MAX_SYNC_RCU_CALLS = 1000;\n\n\tskel = task_local_storage_exit_creds__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\treturn;\n\n\terr = task_local_storage_exit_creds__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\t \n\tif (CHECK_FAIL(system(\"ls > /dev/null\")))\n\t\tgoto out;\n\n\t \n\tdo {\n\t\tkern_sync_rcu();\n\t\trun_count = __atomic_load_n(&skel->bss->run_count, __ATOMIC_SEQ_CST);\n\t} while (run_count == 0 && ++sync_rcu_calls < MAX_SYNC_RCU_CALLS);\n\n\tASSERT_NEQ(sync_rcu_calls, MAX_SYNC_RCU_CALLS,\n\t\t   \"sync_rcu count too high\");\n\tASSERT_NEQ(run_count, 0, \"run_count\");\n\tASSERT_EQ(skel->bss->valid_ptr_count, 0, \"valid_ptr_count\");\n\tASSERT_NEQ(skel->bss->null_ptr_count, 0, \"null_ptr_count\");\nout:\n\ttask_local_storage_exit_creds__destroy(skel);\n}\n\nstatic void test_recursion(void)\n{\n\tint err, map_fd, prog_fd, task_fd;\n\tstruct task_ls_recursion *skel;\n\tstruct bpf_prog_info info;\n\t__u32 info_len = sizeof(info);\n\tlong value;\n\n\ttask_fd = sys_pidfd_open(getpid(), 0);\n\tif (!ASSERT_NEQ(task_fd, -1, \"sys_pidfd_open\"))\n\t\treturn;\n\n\tskel = task_ls_recursion__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\tgoto out;\n\n\terr = task_ls_recursion__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\t \n\tskel->bss->test_pid = getpid();\n\tsyscall(SYS_gettid);\n\tskel->bss->test_pid = 0;\n\ttask_ls_recursion__detach(skel);\n\n\t \n\tmap_fd = bpf_map__fd(skel->maps.map_a);\n\terr = bpf_map_lookup_elem(map_fd, &task_fd, &value);\n\tASSERT_OK(err, \"lookup map_a\");\n\tASSERT_EQ(value, 201, \"map_a value\");\n\tASSERT_EQ(skel->bss->nr_del_errs, 1, \"bpf_task_storage_delete busy\");\n\n\tmap_fd = bpf_map__fd(skel->maps.map_b);\n\terr = bpf_map_lookup_elem(map_fd, &task_fd, &value);\n\tASSERT_OK(err, \"lookup map_b\");\n\tASSERT_EQ(value, 100, \"map_b value\");\n\n\tprog_fd = bpf_program__fd(skel->progs.on_lookup);\n\tmemset(&info, 0, sizeof(info));\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tASSERT_OK(err, \"get prog info\");\n\tASSERT_GT(info.recursion_misses, 0, \"on_lookup prog recursion\");\n\n\tprog_fd = bpf_program__fd(skel->progs.on_update);\n\tmemset(&info, 0, sizeof(info));\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tASSERT_OK(err, \"get prog info\");\n\tASSERT_EQ(info.recursion_misses, 0, \"on_update prog recursion\");\n\n\tprog_fd = bpf_program__fd(skel->progs.on_enter);\n\tmemset(&info, 0, sizeof(info));\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tASSERT_OK(err, \"get prog info\");\n\tASSERT_EQ(info.recursion_misses, 0, \"on_enter prog recursion\");\n\nout:\n\tclose(task_fd);\n\ttask_ls_recursion__destroy(skel);\n}\n\nstatic bool stop;\n\nstatic void waitall(const pthread_t *tids, int nr)\n{\n\tint i;\n\n\tstop = true;\n\tfor (i = 0; i < nr; i++)\n\t\tpthread_join(tids[i], NULL);\n}\n\nstatic void *sock_create_loop(void *arg)\n{\n\tstruct task_storage_nodeadlock *skel = arg;\n\tint fd;\n\n\twhile (!stop) {\n\t\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\t\tclose(fd);\n\t\tif (skel->bss->nr_get_errs || skel->bss->nr_del_errs)\n\t\t\tstop = true;\n\t}\n\n\treturn NULL;\n}\n\nstatic void test_nodeadlock(void)\n{\n\tstruct task_storage_nodeadlock *skel;\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tconst int nr_threads = 32;\n\tpthread_t tids[nr_threads];\n\tint i, prog_fd, err;\n\tcpu_set_t old, new;\n\n\t \n\tCPU_ZERO(&new);\n\tCPU_SET(0, &new);\n\terr = sched_getaffinity(getpid(), sizeof(old), &old);\n\tif (!ASSERT_OK(err, \"getaffinity\"))\n\t\treturn;\n\terr = sched_setaffinity(getpid(), sizeof(new), &new);\n\tif (!ASSERT_OK(err, \"setaffinity\"))\n\t\treturn;\n\n\tskel = task_storage_nodeadlock__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\tgoto done;\n\n\t \n\tif (!skel->kconfig->CONFIG_PREEMPT) {\n\t\ttest__skip();\n\t\tgoto done;\n\t}\n\n\terr = task_storage_nodeadlock__attach(skel);\n\tASSERT_OK(err, \"attach prog\");\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\terr = pthread_create(&tids[i], NULL, sock_create_loop, skel);\n\t\tif (err) {\n\t\t\t \n\t\t\tASSERT_OK(err, \"pthread_create\");\n\t\t\twaitall(tids, i);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tsleep(1);\n\twaitall(tids, nr_threads);\n\n\tinfo_len = sizeof(info);\n\tprog_fd = bpf_program__fd(skel->progs.socket_post_create);\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tASSERT_OK(err, \"get prog info\");\n\tASSERT_EQ(info.recursion_misses, 0, \"prog recursion\");\n\n\tASSERT_EQ(skel->bss->nr_get_errs, 0, \"bpf_task_storage_get busy\");\n\tASSERT_EQ(skel->bss->nr_del_errs, 0, \"bpf_task_storage_delete busy\");\n\ndone:\n\ttask_storage_nodeadlock__destroy(skel);\n\tsched_setaffinity(getpid(), sizeof(old), &old);\n}\n\nvoid test_task_local_storage(void)\n{\n\tif (test__start_subtest(\"sys_enter_exit\"))\n\t\ttest_sys_enter_exit();\n\tif (test__start_subtest(\"exit_creds\"))\n\t\ttest_exit_creds();\n\tif (test__start_subtest(\"recursion\"))\n\t\ttest_recursion();\n\tif (test__start_subtest(\"nodeadlock\"))\n\t\ttest_nodeadlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}