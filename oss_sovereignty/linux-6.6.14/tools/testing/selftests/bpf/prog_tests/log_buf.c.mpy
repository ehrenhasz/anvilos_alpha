{
  "module_name": "log_buf.c",
  "hash_id": "3b6fa6896d3af53bd9325a603a820ebd5f29e74bfe7ad6787940cc2aa93f47c5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/log_buf.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <bpf/btf.h>\n\n#include \"test_log_buf.skel.h\"\n\nstatic size_t libbpf_log_pos;\nstatic char libbpf_log_buf[1024 * 1024];\nstatic bool libbpf_log_error;\n\nstatic int libbpf_print_cb(enum libbpf_print_level level, const char *fmt, va_list args)\n{\n\tint emitted_cnt;\n\tsize_t left_cnt;\n\n\tleft_cnt = sizeof(libbpf_log_buf) - libbpf_log_pos;\n\temitted_cnt = vsnprintf(libbpf_log_buf + libbpf_log_pos, left_cnt, fmt, args);\n\n\tif (emitted_cnt < 0 || emitted_cnt + 1 > left_cnt) {\n\t\tlibbpf_log_error = true;\n\t\treturn 0;\n\t}\n\n\tlibbpf_log_pos += emitted_cnt;\n\treturn 0;\n}\n\nstatic void obj_load_log_buf(void)\n{\n\tlibbpf_print_fn_t old_print_cb = libbpf_set_print(libbpf_print_cb);\n\tLIBBPF_OPTS(bpf_object_open_opts, opts);\n\tconst size_t log_buf_sz = 1024 * 1024;\n\tstruct test_log_buf* skel;\n\tchar *obj_log_buf, *good_log_buf, *bad_log_buf;\n\tint err;\n\n\tobj_log_buf = malloc(3 * log_buf_sz);\n\tif (!ASSERT_OK_PTR(obj_log_buf, \"obj_log_buf\"))\n\t\treturn;\n\n\tgood_log_buf = obj_log_buf + log_buf_sz;\n\tbad_log_buf = obj_log_buf + 2 * log_buf_sz;\n\tobj_log_buf[0] = good_log_buf[0] = bad_log_buf[0] = '\\0';\n\n\topts.kernel_log_buf = obj_log_buf;\n\topts.kernel_log_size = log_buf_sz;\n\topts.kernel_log_level = 4;  \n\n\t \n\tskel = test_log_buf__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\t \n\tbpf_program__set_log_buf(skel->progs.good_prog, good_log_buf, log_buf_sz);\n\tbpf_program__set_log_level(skel->progs.good_prog, 2);\n\n\tbpf_program__set_log_buf(skel->progs.bad_prog, bad_log_buf, log_buf_sz);\n\t \n\tbpf_program__set_log_level(skel->progs.bad_prog, 0);\n\n\terr = test_log_buf__load(skel);\n\tif (!ASSERT_ERR(err, \"unexpected_load_success\"))\n\t\tgoto cleanup;\n\n\tASSERT_FALSE(libbpf_log_error, \"libbpf_log_error\");\n\n\t \n\tASSERT_NULL(strstr(libbpf_log_buf, \"-- BEGIN PROG LOAD LOG --\"), \"unexp_libbpf_log\");\n\tASSERT_OK_PTR(strstr(libbpf_log_buf, \"prog 'bad_prog': BPF program load failed\"),\n\t\t      \"libbpf_log_not_empty\");\n\tASSERT_OK_PTR(strstr(obj_log_buf, \"DATASEC license\"), \"obj_log_not_empty\");\n\tASSERT_OK_PTR(strstr(good_log_buf, \"0: R1=ctx(off=0,imm=0) R10=fp0\"),\n\t\t      \"good_log_verbose\");\n\tASSERT_OK_PTR(strstr(bad_log_buf, \"invalid access to map value, value_size=16 off=16000 size=4\"),\n\t\t      \"bad_log_not_empty\");\n\n\tif (env.verbosity > VERBOSE_NONE) {\n\t\tprintf(\"LIBBPF LOG:   \\n=================\\n%s=================\\n\", libbpf_log_buf);\n\t\tprintf(\"OBJ LOG:      \\n=================\\n%s=================\\n\", obj_log_buf);\n\t\tprintf(\"GOOD_PROG LOG:\\n=================\\n%s=================\\n\", good_log_buf);\n\t\tprintf(\"BAD_PROG  LOG:\\n=================\\n%s=================\\n\", bad_log_buf);\n\t}\n\n\t \n\ttest_log_buf__destroy(skel);\n\tobj_log_buf[0] = good_log_buf[0] = bad_log_buf[0] = '\\0';\n\tlibbpf_log_buf[0] = '\\0';\n\tlibbpf_log_pos = 0;\n\tlibbpf_log_error = false;\n\n\t \n\topts.kernel_log_buf = NULL;  \n\topts.kernel_log_size = 0;\n\topts.kernel_log_level = 1;\n\n\tskel = test_log_buf__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\t \n\tbpf_program__set_log_buf(skel->progs.good_prog, good_log_buf, log_buf_sz);\n\tbpf_program__set_log_level(skel->progs.good_prog, 1);\n\n\terr = test_log_buf__load(skel);\n\tif (!ASSERT_ERR(err, \"unexpected_load_success\"))\n\t\tgoto cleanup;\n\n\tASSERT_FALSE(libbpf_log_error, \"libbpf_log_error\");\n\n\t \n\tASSERT_OK_PTR(strstr(libbpf_log_buf, \"libbpf: prog 'bad_prog': -- BEGIN PROG LOAD LOG --\"),\n\t\t      \"libbpf_log_correct\");\n\tASSERT_STREQ(obj_log_buf, \"\", \"obj_log__empty\");\n\tASSERT_STREQ(good_log_buf, \"processed 4 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\\n\",\n\t\t     \"good_log_ok\");\n\tASSERT_STREQ(bad_log_buf, \"\", \"bad_log_empty\");\n\n\tif (env.verbosity > VERBOSE_NONE) {\n\t\tprintf(\"LIBBPF LOG:   \\n=================\\n%s=================\\n\", libbpf_log_buf);\n\t\tprintf(\"OBJ LOG:      \\n=================\\n%s=================\\n\", obj_log_buf);\n\t\tprintf(\"GOOD_PROG LOG:\\n=================\\n%s=================\\n\", good_log_buf);\n\t\tprintf(\"BAD_PROG  LOG:\\n=================\\n%s=================\\n\", bad_log_buf);\n\t}\n\ncleanup:\n\tfree(obj_log_buf);\n\ttest_log_buf__destroy(skel);\n\tlibbpf_set_print(old_print_cb);\n}\n\nstatic void bpf_prog_load_log_buf(void)\n{\n\tconst struct bpf_insn good_prog_insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tconst size_t good_prog_insn_cnt = sizeof(good_prog_insns) / sizeof(struct bpf_insn);\n\tconst struct bpf_insn bad_prog_insns[] = {\n\t\tBPF_EXIT_INSN(),\n\t};\n\tsize_t bad_prog_insn_cnt = sizeof(bad_prog_insns) / sizeof(struct bpf_insn);\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts);\n\tconst size_t log_buf_sz = 1024 * 1024;\n\tchar *log_buf;\n\tint fd = -1;\n\n\tlog_buf = malloc(log_buf_sz);\n\tif (!ASSERT_OK_PTR(log_buf, \"log_buf_alloc\"))\n\t\treturn;\n\topts.log_buf = log_buf;\n\topts.log_size = log_buf_sz;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 0;\n\tfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, \"good_prog\", \"GPL\",\n\t\t\t   good_prog_insns, good_prog_insn_cnt, &opts);\n\tASSERT_STREQ(log_buf, \"\", \"good_log_0\");\n\tASSERT_GE(fd, 0, \"good_fd1\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 2;\n\tfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, \"good_prog\", \"GPL\",\n\t\t\t   good_prog_insns, good_prog_insn_cnt, &opts);\n\tASSERT_OK_PTR(strstr(log_buf, \"0: R1=ctx(off=0,imm=0) R10=fp0\"), \"good_log_2\");\n\tASSERT_GE(fd, 0, \"good_fd2\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 0;\n\tfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, \"bad_prog\", \"GPL\",\n\t\t\t   bad_prog_insns, bad_prog_insn_cnt, &opts);\n\tASSERT_OK_PTR(strstr(log_buf, \"R0 !read_ok\"), \"bad_log_0\");\n\tASSERT_LT(fd, 0, \"bad_fd\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\n\tfree(log_buf);\n}\n\nstatic void bpf_btf_load_log_buf(void)\n{\n\tLIBBPF_OPTS(bpf_btf_load_opts, opts);\n\tconst size_t log_buf_sz = 1024 * 1024;\n\tconst void *raw_btf_data;\n\t__u32 raw_btf_size;\n\tstruct btf *btf;\n\tchar *log_buf = NULL;\n\tint fd = -1;\n\n\tbtf = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf, \"empty_btf\"))\n\t\treturn;\n\n\tASSERT_GT(btf__add_int(btf, \"int\", 4, 0), 0, \"int_type\");\n\n\traw_btf_data = btf__raw_data(btf, &raw_btf_size);\n\tif (!ASSERT_OK_PTR(raw_btf_data, \"raw_btf_data_good\"))\n\t\tgoto cleanup;\n\n\tlog_buf = malloc(log_buf_sz);\n\tif (!ASSERT_OK_PTR(log_buf, \"log_buf_alloc\"))\n\t\tgoto cleanup;\n\topts.log_buf = log_buf;\n\topts.log_size = log_buf_sz;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 0;\n\tfd = bpf_btf_load(raw_btf_data, raw_btf_size, &opts);\n\tASSERT_STREQ(log_buf, \"\", \"good_log_0\");\n\tASSERT_GE(fd, 0, \"good_fd1\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 2;\n\tfd = bpf_btf_load(raw_btf_data, raw_btf_size, &opts);\n\tprintf(\"LOG_BUF: %s\\n\", log_buf);\n\tASSERT_OK_PTR(strstr(log_buf, \"magic: 0xeb9f\"), \"good_log_2\");\n\tASSERT_GE(fd, 0, \"good_fd2\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\n\t \n\tASSERT_GT(btf__add_ptr(btf, 100), 0, \"bad_ptr_type\");\n\n\traw_btf_data = btf__raw_data(btf, &raw_btf_size);\n\tif (!ASSERT_OK_PTR(raw_btf_data, \"raw_btf_data_bad\"))\n\t\tgoto cleanup;\n\n\t \n\tlog_buf[0] = '\\0';\n\topts.log_level = 0;\n\tfd = bpf_btf_load(raw_btf_data, raw_btf_size, &opts);\n\tprintf(\"LOG_BUF: %s\\n\", log_buf);\n\tASSERT_OK_PTR(strstr(log_buf, \"[2] PTR (anon) type_id=100 Invalid type_id\"), \"bad_log_0\");\n\tASSERT_LT(fd, 0, \"bad_fd\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\tfd = -1;\n\ncleanup:\n\tfree(log_buf);\n\tbtf__free(btf);\n}\n\nvoid test_log_buf(void)\n{\n\tif (test__start_subtest(\"obj_load_log_buf\"))\n\t\tobj_load_log_buf();\n\tif (test__start_subtest(\"bpf_prog_load_log_buf\"))\n\t\tbpf_prog_load_log_buf();\n\tif (test__start_subtest(\"bpf_btf_load_log_buf\"))\n\t\tbpf_btf_load_log_buf();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}