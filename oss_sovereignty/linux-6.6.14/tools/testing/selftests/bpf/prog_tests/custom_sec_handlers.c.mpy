{
  "module_name": "custom_sec_handlers.c",
  "hash_id": "ac1095061085dfbc4abaee9151638e6811a9f762d8552dc3d934880a664c493d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/custom_sec_handlers.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include \"test_custom_sec_handlers.skel.h\"\n\n#define COOKIE_ABC1 1\n#define COOKIE_ABC2 2\n#define COOKIE_CUSTOM 3\n#define COOKIE_FALLBACK 4\n#define COOKIE_KPROBE 5\n\nstatic int custom_setup_prog(struct bpf_program *prog, long cookie)\n{\n\tif (cookie == COOKIE_ABC1)\n\t\tbpf_program__set_autoload(prog, false);\n\n\treturn 0;\n}\n\nstatic int custom_prepare_load_prog(struct bpf_program *prog,\n\t\t\t\t    struct bpf_prog_load_opts *opts, long cookie)\n{\n\tif (cookie == COOKIE_FALLBACK)\n\t\topts->prog_flags |= BPF_F_SLEEPABLE;\n\telse if (cookie == COOKIE_ABC1)\n\t\tASSERT_FALSE(true, \"unexpected preload for abc\");\n\n\treturn 0;\n}\n\nstatic int custom_attach_prog(const struct bpf_program *prog, long cookie,\n\t\t\t      struct bpf_link **link)\n{\n\tswitch (cookie) {\n\tcase COOKIE_ABC2:\n\t\t*link = bpf_program__attach_raw_tracepoint(prog, \"sys_enter\");\n\t\treturn libbpf_get_error(*link);\n\tcase COOKIE_CUSTOM:\n\t\t*link = bpf_program__attach_tracepoint(prog, \"syscalls\", \"sys_enter_nanosleep\");\n\t\treturn libbpf_get_error(*link);\n\tcase COOKIE_KPROBE:\n\tcase COOKIE_FALLBACK:\n\t\t \n\t\t*link = NULL;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT_FALSE(true, \"unexpected cookie\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int abc1_id;\nstatic int abc2_id;\nstatic int custom_id;\nstatic int fallback_id;\nstatic int kprobe_id;\n\n__attribute__((constructor))\nstatic void register_sec_handlers(void)\n{\n\tLIBBPF_OPTS(libbpf_prog_handler_opts, abc1_opts,\n\t\t.cookie = COOKIE_ABC1,\n\t\t.prog_setup_fn = custom_setup_prog,\n\t\t.prog_prepare_load_fn = custom_prepare_load_prog,\n\t\t.prog_attach_fn = NULL,\n\t);\n\tLIBBPF_OPTS(libbpf_prog_handler_opts, abc2_opts,\n\t\t.cookie = COOKIE_ABC2,\n\t\t.prog_setup_fn = custom_setup_prog,\n\t\t.prog_prepare_load_fn = custom_prepare_load_prog,\n\t\t.prog_attach_fn = custom_attach_prog,\n\t);\n\tLIBBPF_OPTS(libbpf_prog_handler_opts, custom_opts,\n\t\t.cookie = COOKIE_CUSTOM,\n\t\t.prog_setup_fn = NULL,\n\t\t.prog_prepare_load_fn = NULL,\n\t\t.prog_attach_fn = custom_attach_prog,\n\t);\n\n\tabc1_id = libbpf_register_prog_handler(\"abc\", BPF_PROG_TYPE_RAW_TRACEPOINT, 0, &abc1_opts);\n\tabc2_id = libbpf_register_prog_handler(\"abc/\", BPF_PROG_TYPE_RAW_TRACEPOINT, 0, &abc2_opts);\n\tcustom_id = libbpf_register_prog_handler(\"custom+\", BPF_PROG_TYPE_TRACEPOINT, 0, &custom_opts);\n}\n\n__attribute__((destructor))\nstatic void unregister_sec_handlers(void)\n{\n\tlibbpf_unregister_prog_handler(abc1_id);\n\tlibbpf_unregister_prog_handler(abc2_id);\n\tlibbpf_unregister_prog_handler(custom_id);\n}\n\nvoid test_custom_sec_handlers(void)\n{\n\tLIBBPF_OPTS(libbpf_prog_handler_opts, opts,\n\t\t.prog_setup_fn = custom_setup_prog,\n\t\t.prog_prepare_load_fn = custom_prepare_load_prog,\n\t\t.prog_attach_fn = custom_attach_prog,\n\t);\n\tstruct test_custom_sec_handlers* skel;\n\tint err;\n\n\tASSERT_GT(abc1_id, 0, \"abc1_id\");\n\tASSERT_GT(abc2_id, 0, \"abc2_id\");\n\tASSERT_GT(custom_id, 0, \"custom_id\");\n\n\t \n\topts.cookie = COOKIE_KPROBE;\n\tkprobe_id = libbpf_register_prog_handler(\"kprobe+\", BPF_PROG_TYPE_TRACEPOINT, 0, &opts);\n\t \n\topts.cookie = COOKIE_FALLBACK;\n\tfallback_id = libbpf_register_prog_handler(NULL, BPF_PROG_TYPE_SYSCALL, 0, &opts);\n\n\tif (!ASSERT_GT(fallback_id, 0, \"fallback_id\")  ) {\n\t\tif (fallback_id > 0)\n\t\t\tlibbpf_unregister_prog_handler(fallback_id);\n\t\tif (kprobe_id > 0)\n\t\t\tlibbpf_unregister_prog_handler(kprobe_id);\n\t\treturn;\n\t}\n\n\t \n\tskel = test_custom_sec_handlers__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__type(skel->progs.abc1), BPF_PROG_TYPE_RAW_TRACEPOINT, \"abc1_type\");\n\tASSERT_FALSE(bpf_program__autoload(skel->progs.abc1), \"abc1_autoload\");\n\n\tASSERT_EQ(bpf_program__type(skel->progs.abc2), BPF_PROG_TYPE_RAW_TRACEPOINT, \"abc2_type\");\n\tASSERT_EQ(bpf_program__type(skel->progs.custom1), BPF_PROG_TYPE_TRACEPOINT, \"custom1_type\");\n\tASSERT_EQ(bpf_program__type(skel->progs.custom2), BPF_PROG_TYPE_TRACEPOINT, \"custom2_type\");\n\tASSERT_EQ(bpf_program__type(skel->progs.kprobe1), BPF_PROG_TYPE_TRACEPOINT, \"kprobe1_type\");\n\tASSERT_EQ(bpf_program__type(skel->progs.xyz), BPF_PROG_TYPE_SYSCALL, \"xyz_type\");\n\n\tskel->rodata->my_pid = getpid();\n\n\t \n\terr = test_custom_sec_handlers__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\t \n\terr = test_custom_sec_handlers__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.xyz = bpf_program__attach(skel->progs.kprobe1);\n\tASSERT_EQ(errno, EOPNOTSUPP, \"xyz_attach_err\");\n\tASSERT_ERR_PTR(skel->links.xyz, \"xyz_attach\");\n\n\t \n\tusleep(1);\n\n\t \n\tASSERT_FALSE(skel->bss->abc1_called, \"abc1_called\");\n\tASSERT_TRUE(skel->bss->abc2_called, \"abc2_called\");\n\tASSERT_TRUE(skel->bss->custom1_called, \"custom1_called\");\n\tASSERT_TRUE(skel->bss->custom2_called, \"custom2_called\");\n\t \n\tASSERT_FALSE(skel->bss->kprobe1_called, \"kprobe1_called\");\n\t \n\tASSERT_FALSE(skel->bss->xyz_called, \"xyz_called\");\n\ncleanup:\n\ttest_custom_sec_handlers__destroy(skel);\n\n\tASSERT_OK(libbpf_unregister_prog_handler(fallback_id), \"unregister_fallback\");\n\tASSERT_OK(libbpf_unregister_prog_handler(kprobe_id), \"unregister_kprobe\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}