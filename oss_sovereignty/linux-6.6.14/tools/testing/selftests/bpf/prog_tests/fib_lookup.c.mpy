{
  "module_name": "fib_lookup.c",
  "hash_id": "cd18dc81686c9b78c010092fc6c29115a8e901beb0a21333acc8780c5b98f124",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/fib_lookup.c",
  "human_readable_source": "\n \n\n#include <linux/rtnetlink.h>\n#include <sys/types.h>\n#include <net/if.h>\n\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n#include \"fib_lookup.skel.h\"\n\n#define NS_TEST\t\t\t\"fib_lookup_ns\"\n#define IPV6_IFACE_ADDR\t\t\"face::face\"\n#define IPV6_NUD_FAILED_ADDR\t\"face::1\"\n#define IPV6_NUD_STALE_ADDR\t\"face::2\"\n#define IPV4_IFACE_ADDR\t\t\"10.0.0.254\"\n#define IPV4_NUD_FAILED_ADDR\t\"10.0.0.1\"\n#define IPV4_NUD_STALE_ADDR\t\"10.0.0.2\"\n#define IPV4_TBID_ADDR\t\t\"172.0.0.254\"\n#define IPV4_TBID_NET\t\t\"172.0.0.0\"\n#define IPV4_TBID_DST\t\t\"172.0.0.2\"\n#define IPV6_TBID_ADDR\t\t\"fd00::FFFF\"\n#define IPV6_TBID_NET\t\t\"fd00::\"\n#define IPV6_TBID_DST\t\t\"fd00::2\"\n#define DMAC\t\t\t\"11:11:11:11:11:11\"\n#define DMAC_INIT { 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, }\n#define DMAC2\t\t\t\"01:01:01:01:01:01\"\n#define DMAC_INIT2 { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, }\n\nstruct fib_lookup_test {\n\tconst char *desc;\n\tconst char *daddr;\n\tint expected_ret;\n\tint lookup_flags;\n\t__u32 tbid;\n\t__u8 dmac[6];\n};\n\nstatic const struct fib_lookup_test tests[] = {\n\t{ .desc = \"IPv6 failed neigh\",\n\t  .daddr = IPV6_NUD_FAILED_ADDR, .expected_ret = BPF_FIB_LKUP_RET_NO_NEIGH, },\n\t{ .desc = \"IPv6 stale neigh\",\n\t  .daddr = IPV6_NUD_STALE_ADDR, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .dmac = DMAC_INIT, },\n\t{ .desc = \"IPv6 skip neigh\",\n\t  .daddr = IPV6_NUD_FAILED_ADDR, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .lookup_flags = BPF_FIB_LOOKUP_SKIP_NEIGH, },\n\t{ .desc = \"IPv4 failed neigh\",\n\t  .daddr = IPV4_NUD_FAILED_ADDR, .expected_ret = BPF_FIB_LKUP_RET_NO_NEIGH, },\n\t{ .desc = \"IPv4 stale neigh\",\n\t  .daddr = IPV4_NUD_STALE_ADDR, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .dmac = DMAC_INIT, },\n\t{ .desc = \"IPv4 skip neigh\",\n\t  .daddr = IPV4_NUD_FAILED_ADDR, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .lookup_flags = BPF_FIB_LOOKUP_SKIP_NEIGH, },\n\t{ .desc = \"IPv4 TBID lookup failure\",\n\t  .daddr = IPV4_TBID_DST, .expected_ret = BPF_FIB_LKUP_RET_NOT_FWDED,\n\t  .lookup_flags = BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_TBID,\n\t  .tbid = RT_TABLE_MAIN, },\n\t{ .desc = \"IPv4 TBID lookup success\",\n\t  .daddr = IPV4_TBID_DST, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .lookup_flags = BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_TBID, .tbid = 100,\n\t  .dmac = DMAC_INIT2, },\n\t{ .desc = \"IPv6 TBID lookup failure\",\n\t  .daddr = IPV6_TBID_DST, .expected_ret = BPF_FIB_LKUP_RET_NOT_FWDED,\n\t  .lookup_flags = BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_TBID,\n\t  .tbid = RT_TABLE_MAIN, },\n\t{ .desc = \"IPv6 TBID lookup success\",\n\t  .daddr = IPV6_TBID_DST, .expected_ret = BPF_FIB_LKUP_RET_SUCCESS,\n\t  .lookup_flags = BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_TBID, .tbid = 100,\n\t  .dmac = DMAC_INIT2, },\n};\n\nstatic int ifindex;\n\nstatic int setup_netns(void)\n{\n\tint err;\n\n\tSYS(fail, \"ip link add veth1 type veth peer name veth2\");\n\tSYS(fail, \"ip link set dev veth1 up\");\n\tSYS(fail, \"ip link set dev veth2 up\");\n\n\terr = write_sysctl(\"/proc/sys/net/ipv4/neigh/veth1/gc_stale_time\", \"900\");\n\tif (!ASSERT_OK(err, \"write_sysctl(net.ipv4.neigh.veth1.gc_stale_time)\"))\n\t\tgoto fail;\n\n\terr = write_sysctl(\"/proc/sys/net/ipv6/neigh/veth1/gc_stale_time\", \"900\");\n\tif (!ASSERT_OK(err, \"write_sysctl(net.ipv6.neigh.veth1.gc_stale_time)\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip addr add %s/64 dev veth1 nodad\", IPV6_IFACE_ADDR);\n\tSYS(fail, \"ip neigh add %s dev veth1 nud failed\", IPV6_NUD_FAILED_ADDR);\n\tSYS(fail, \"ip neigh add %s dev veth1 lladdr %s nud stale\", IPV6_NUD_STALE_ADDR, DMAC);\n\n\tSYS(fail, \"ip addr add %s/24 dev veth1\", IPV4_IFACE_ADDR);\n\tSYS(fail, \"ip neigh add %s dev veth1 nud failed\", IPV4_NUD_FAILED_ADDR);\n\tSYS(fail, \"ip neigh add %s dev veth1 lladdr %s nud stale\", IPV4_NUD_STALE_ADDR, DMAC);\n\n\t \n\tSYS(fail, \"ip addr add %s/24 dev veth2\", IPV4_TBID_ADDR);\n\tSYS(fail, \"ip route del %s/24 dev veth2\", IPV4_TBID_NET);\n\tSYS(fail, \"ip route add table 100 %s/24 dev veth2\", IPV4_TBID_NET);\n\tSYS(fail, \"ip neigh add %s dev veth2 lladdr %s nud stale\", IPV4_TBID_DST, DMAC2);\n\n\tSYS(fail, \"ip addr add %s/64 dev veth2\", IPV6_TBID_ADDR);\n\tSYS(fail, \"ip -6 route del %s/64 dev veth2\", IPV6_TBID_NET);\n\tSYS(fail, \"ip -6 route add table 100 %s/64 dev veth2\", IPV6_TBID_NET);\n\tSYS(fail, \"ip neigh add %s dev veth2 lladdr %s nud stale\", IPV6_TBID_DST, DMAC2);\n\n\terr = write_sysctl(\"/proc/sys/net/ipv4/conf/veth1/forwarding\", \"1\");\n\tif (!ASSERT_OK(err, \"write_sysctl(net.ipv4.conf.veth1.forwarding)\"))\n\t\tgoto fail;\n\n\terr = write_sysctl(\"/proc/sys/net/ipv6/conf/veth1/forwarding\", \"1\");\n\tif (!ASSERT_OK(err, \"write_sysctl(net.ipv6.conf.veth1.forwarding)\"))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic int set_lookup_params(struct bpf_fib_lookup *params, const struct fib_lookup_test *test)\n{\n\tint ret;\n\n\tmemset(params, 0, sizeof(*params));\n\n\tparams->l4_protocol = IPPROTO_TCP;\n\tparams->ifindex = ifindex;\n\tparams->tbid = test->tbid;\n\n\tif (inet_pton(AF_INET6, test->daddr, params->ipv6_dst) == 1) {\n\t\tparams->family = AF_INET6;\n\t\tret = inet_pton(AF_INET6, IPV6_IFACE_ADDR, params->ipv6_src);\n\t\tif (!ASSERT_EQ(ret, 1, \"inet_pton(IPV6_IFACE_ADDR)\"))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tret = inet_pton(AF_INET, test->daddr, &params->ipv4_dst);\n\tif (!ASSERT_EQ(ret, 1, \"convert IP[46] address\"))\n\t\treturn -1;\n\tparams->family = AF_INET;\n\tret = inet_pton(AF_INET, IPV4_IFACE_ADDR, &params->ipv4_src);\n\tif (!ASSERT_EQ(ret, 1, \"inet_pton(IPV4_IFACE_ADDR)\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void mac_str(char *b, const __u8 *mac)\n{\n\tsprintf(b, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n}\n\nvoid test_fib_lookup(void)\n{\n\tstruct bpf_fib_lookup *fib_params;\n\tstruct nstoken *nstoken = NULL;\n\tstruct __sk_buff skb = { };\n\tstruct fib_lookup *skel;\n\tint prog_fd, err, ret, i;\n\n\t \n\tLIBBPF_OPTS(bpf_test_run_opts, run_opts,\n\t\t    .data_in = &pkt_v6,\n\t\t    .data_size_in = sizeof(pkt_v6),\n\t\t    .ctx_in = &skb,\n\t\t    .ctx_size_in = sizeof(skb),\n\t);\n\n\tskel = fib_lookup__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel open_and_load\"))\n\t\treturn;\n\tprog_fd = bpf_program__fd(skel->progs.fib_lookup);\n\n\tSYS(fail, \"ip netns add %s\", NS_TEST);\n\n\tnstoken = open_netns(NS_TEST);\n\tif (!ASSERT_OK_PTR(nstoken, \"open_netns\"))\n\t\tgoto fail;\n\n\tif (setup_netns())\n\t\tgoto fail;\n\n\tifindex = if_nametoindex(\"veth1\");\n\tskb.ifindex = ifindex;\n\tfib_params = &skel->bss->fib_params;\n\n\tfor (i = 0; i < ARRAY_SIZE(tests); i++) {\n\t\tprintf(\"Testing %s \", tests[i].desc);\n\n\t\tif (set_lookup_params(fib_params, &tests[i]))\n\t\t\tcontinue;\n\t\tskel->bss->fib_lookup_ret = -1;\n\t\tskel->bss->lookup_flags = tests[i].lookup_flags;\n\n\t\terr = bpf_prog_test_run_opts(prog_fd, &run_opts);\n\t\tif (!ASSERT_OK(err, \"bpf_prog_test_run_opts\"))\n\t\t\tcontinue;\n\n\t\tASSERT_EQ(skel->bss->fib_lookup_ret, tests[i].expected_ret,\n\t\t\t  \"fib_lookup_ret\");\n\n\t\tret = memcmp(tests[i].dmac, fib_params->dmac, sizeof(tests[i].dmac));\n\t\tif (!ASSERT_EQ(ret, 0, \"dmac not match\")) {\n\t\t\tchar expected[18], actual[18];\n\n\t\t\tmac_str(expected, tests[i].dmac);\n\t\t\tmac_str(actual, fib_params->dmac);\n\t\t\tprintf(\"dmac expected %s actual %s \", expected, actual);\n\t\t}\n\n\t\t\n\t\tif (tests[i].lookup_flags & BPF_FIB_LOOKUP_DIRECT) {\n\t\t\tif (!ASSERT_EQ(skel->bss->fib_params.tbid, 0,\n\t\t\t\t\t\"expected fib_params.tbid to be zero\"))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\tSYS_NOFAIL(\"ip netns del \" NS_TEST \" &> /dev/null\");\n\tfib_lookup__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}