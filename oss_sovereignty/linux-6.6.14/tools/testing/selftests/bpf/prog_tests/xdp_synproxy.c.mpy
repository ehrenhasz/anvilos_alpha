{
  "module_name": "xdp_synproxy.c",
  "hash_id": "1d3ce9891095a86fe8026539cff65dde3b736df8ae46082d761432442ce3487e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_synproxy.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <ctype.h>\n\n#define CMD_OUT_BUF_SIZE 1023\n\n#define SYS_OUT(cmd, ...) ({ \\\n\tchar buf[1024]; \\\n\tsnprintf(buf, sizeof(buf), (cmd), ##__VA_ARGS__); \\\n\tFILE *f = popen(buf, \"r\"); \\\n\tif (!ASSERT_OK_PTR(f, buf)) \\\n\t\tgoto out; \\\n\tf; \\\n})\n\n \nstatic void escape_str(char *out, const char *in, size_t size)\n{\n\tstatic const char *hex = \"0123456789ABCDEF\";\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (isprint(in[i]) && in[i] != '\\\\' && in[i] != '\\'') {\n\t\t\t*out++ = in[i];\n\t\t} else {\n\t\t\t*out++ = '\\\\';\n\t\t\t*out++ = 'x';\n\t\t\t*out++ = hex[(in[i] >> 4) & 0xf];\n\t\t\t*out++ = hex[in[i] & 0xf];\n\t\t}\n\t}\n\t*out++ = '\\0';\n}\n\nstatic bool expect_str(char *buf, size_t size, const char *str, const char *name)\n{\n\tstatic char escbuf_expected[CMD_OUT_BUF_SIZE * 4];\n\tstatic char escbuf_actual[CMD_OUT_BUF_SIZE * 4];\n\tstatic int duration = 0;\n\tbool ok;\n\n\tok = size == strlen(str) && !memcmp(buf, str, size);\n\n\tif (!ok) {\n\t\tescape_str(escbuf_expected, str, strlen(str));\n\t\tescape_str(escbuf_actual, buf, size);\n\t}\n\tCHECK(!ok, name, \"unexpected %s: actual '%s' != expected '%s'\\n\",\n\t      name, escbuf_actual, escbuf_expected);\n\n\treturn ok;\n}\n\nstatic void test_synproxy(bool xdp)\n{\n\tint server_fd = -1, client_fd = -1, accept_fd = -1;\n\tchar *prog_id = NULL, *prog_id_end;\n\tstruct nstoken *ns = NULL;\n\tFILE *ctrl_file = NULL;\n\tchar buf[CMD_OUT_BUF_SIZE];\n\tsize_t size;\n\n\tSYS(out, \"ip netns add synproxy\");\n\n\tSYS(out, \"ip link add tmp0 type veth peer name tmp1\");\n\tSYS(out, \"ip link set tmp1 netns synproxy\");\n\tSYS(out, \"ip link set tmp0 up\");\n\tSYS(out, \"ip addr replace 198.18.0.1/24 dev tmp0\");\n\n\t \n\tSYS(out, \"ethtool -K tmp0 tx off\");\n\tif (xdp)\n\t\t \n\t\tSYS(out, \"ip link set tmp0 xdp object xdp_dummy.bpf.o section xdp 2> /dev/null\");\n\n\tns = open_netns(\"synproxy\");\n\tif (!ASSERT_OK_PTR(ns, \"setns\"))\n\t\tgoto out;\n\n\tSYS(out, \"ip link set lo up\");\n\tSYS(out, \"ip link set tmp1 up\");\n\tSYS(out, \"ip addr replace 198.18.0.2/24 dev tmp1\");\n\tSYS(out, \"sysctl -w net.ipv4.tcp_syncookies=2\");\n\tSYS(out, \"sysctl -w net.ipv4.tcp_timestamps=1\");\n\tSYS(out, \"sysctl -w net.netfilter.nf_conntrack_tcp_loose=0\");\n\tSYS(out, \"iptables-legacy -t raw -I PREROUTING \\\n\t    -i tmp1 -p tcp -m tcp --syn --dport 8080 -j CT --notrack\");\n\tSYS(out, \"iptables-legacy -t filter -A INPUT \\\n\t    -i tmp1 -p tcp -m tcp --dport 8080 -m state --state INVALID,UNTRACKED \\\n\t    -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460\");\n\tSYS(out, \"iptables-legacy -t filter -A INPUT \\\n\t    -i tmp1 -m state --state INVALID -j DROP\");\n\n\tctrl_file = SYS_OUT(\"./xdp_synproxy --iface tmp1 --ports 8080 \\\n\t\t\t    --single --mss4 1460 --mss6 1440 \\\n\t\t\t    --wscale 7 --ttl 64%s\", xdp ? \"\" : \" --tc\");\n\tsize = fread(buf, 1, sizeof(buf), ctrl_file);\n\tpclose(ctrl_file);\n\tif (!expect_str(buf, size, \"Total SYNACKs generated: 0\\n\",\n\t\t\t\"initial SYNACKs\"))\n\t\tgoto out;\n\n\tif (!xdp) {\n\t\tctrl_file = SYS_OUT(\"tc filter show dev tmp1 ingress\");\n\t\tsize = fread(buf, 1, sizeof(buf), ctrl_file);\n\t\tpclose(ctrl_file);\n\t\tprog_id = memmem(buf, size, \" id \", 4);\n\t\tif (!ASSERT_OK_PTR(prog_id, \"find prog id\"))\n\t\t\tgoto out;\n\t\tprog_id += 4;\n\t\tif (!ASSERT_LT(prog_id, buf + size, \"find prog id begin\"))\n\t\t\tgoto out;\n\t\tprog_id_end = prog_id;\n\t\twhile (prog_id_end < buf + size && *prog_id_end >= '0' &&\n\t\t       *prog_id_end <= '9')\n\t\t\tprog_id_end++;\n\t\tif (!ASSERT_LT(prog_id_end, buf + size, \"find prog id end\"))\n\t\t\tgoto out;\n\t\t*prog_id_end = '\\0';\n\t}\n\n\tserver_fd = start_server(AF_INET, SOCK_STREAM, \"198.18.0.2\", 8080, 0);\n\tif (!ASSERT_GE(server_fd, 0, \"start_server\"))\n\t\tgoto out;\n\n\tclose_netns(ns);\n\tns = NULL;\n\n\tclient_fd = connect_to_fd(server_fd, 10000);\n\tif (!ASSERT_GE(client_fd, 0, \"connect_to_fd\"))\n\t\tgoto out;\n\n\taccept_fd = accept(server_fd, NULL, NULL);\n\tif (!ASSERT_GE(accept_fd, 0, \"accept\"))\n\t\tgoto out;\n\n\tns = open_netns(\"synproxy\");\n\tif (!ASSERT_OK_PTR(ns, \"setns\"))\n\t\tgoto out;\n\n\tif (xdp)\n\t\tctrl_file = SYS_OUT(\"./xdp_synproxy --iface tmp1 --single\");\n\telse\n\t\tctrl_file = SYS_OUT(\"./xdp_synproxy --prog %s --single\",\n\t\t\t\t    prog_id);\n\tsize = fread(buf, 1, sizeof(buf), ctrl_file);\n\tpclose(ctrl_file);\n\tif (!expect_str(buf, size, \"Total SYNACKs generated: 1\\n\",\n\t\t\t\"SYNACKs after connection\"))\n\t\tgoto out;\n\nout:\n\tif (accept_fd >= 0)\n\t\tclose(accept_fd);\n\tif (client_fd >= 0)\n\t\tclose(client_fd);\n\tif (server_fd >= 0)\n\t\tclose(server_fd);\n\tif (ns)\n\t\tclose_netns(ns);\n\n\tSYS_NOFAIL(\"ip link del tmp0\");\n\tSYS_NOFAIL(\"ip netns del synproxy\");\n}\n\nvoid test_xdp_synproxy(void)\n{\n\tif (test__start_subtest(\"xdp\"))\n\t\ttest_synproxy(true);\n\tif (test__start_subtest(\"tc\"))\n\t\ttest_synproxy(false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}