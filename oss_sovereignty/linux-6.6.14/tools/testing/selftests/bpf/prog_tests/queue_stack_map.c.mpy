{
  "module_name": "queue_stack_map.c",
  "hash_id": "15bde0e5c204de73820a70b817b10a99e9ce703a87dbc36aa9b6fe6b96e0fe3e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/queue_stack_map.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\nenum {\n\tQUEUE,\n\tSTACK,\n};\n\nstatic void test_queue_stack_map_by_type(int type)\n{\n\tconst int MAP_SIZE = 32;\n\t__u32 vals[MAP_SIZE], val;\n\tint i, err, prog_fd, map_in_fd, map_out_fd;\n\tchar file[32], buf[128];\n\tstruct bpf_object *obj;\n\tstruct iphdr iph;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.data_out = buf,\n\t\t.data_size_out = sizeof(buf),\n\t\t.repeat = 1,\n\t);\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++)\n\t\tvals[i] = rand();\n\n\tif (type == QUEUE)\n\t\tstrncpy(file, \"./test_queue_map.bpf.o\", sizeof(file));\n\telse if (type == STACK)\n\t\tstrncpy(file, \"./test_stack_map.bpf.o\", sizeof(file));\n\telse\n\t\treturn;\n\n\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_SCHED_CLS, &obj, &prog_fd);\n\tif (CHECK_FAIL(err))\n\t\treturn;\n\n\tmap_in_fd = bpf_find_map(__func__, obj, \"map_in\");\n\tif (map_in_fd < 0)\n\t\tgoto out;\n\n\tmap_out_fd = bpf_find_map(__func__, obj, \"map_out\");\n\tif (map_out_fd < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++) {\n\t\terr = bpf_map_update_elem(map_in_fd, NULL, &vals[i], 0);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++) {\n\t\tif (type == QUEUE) {\n\t\t\tval = vals[i];\n\t\t\tpkt_v4.iph.saddr = vals[i] * 5;\n\t\t} else if (type == STACK) {\n\t\t\tval = vals[MAP_SIZE - 1 - i];\n\t\t\tpkt_v4.iph.saddr = vals[MAP_SIZE - 1 - i] * 5;\n\t\t}\n\n\t\ttopts.data_size_out = sizeof(buf);\n\t\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\t\tif (err || topts.retval ||\n\t\t    topts.data_size_out != sizeof(pkt_v4))\n\t\t\tbreak;\n\t\tmemcpy(&iph, buf + sizeof(struct ethhdr), sizeof(iph));\n\t\tif (iph.daddr != val)\n\t\t\tbreak;\n\t}\n\n\tASSERT_OK(err, \"bpf_map_pop_elem\");\n\tASSERT_OK(topts.retval, \"bpf_map_pop_elem test retval\");\n\tASSERT_EQ(topts.data_size_out, sizeof(pkt_v4),\n\t\t  \"bpf_map_pop_elem data_size_out\");\n\tASSERT_EQ(iph.daddr, val, \"bpf_map_pop_elem iph.daddr\");\n\n\t \n\ttopts.data_size_out = sizeof(buf);\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"check-queue-stack-map-empty\");\n\tASSERT_EQ(topts.retval, 2   ,\n\t\t  \"check-queue-stack-map-empty test retval\");\n\tASSERT_EQ(topts.data_size_out, sizeof(pkt_v4),\n\t\t  \"check-queue-stack-map-empty data_size_out\");\n\n\t \n\tfor (i = 0; i < MAP_SIZE; i++) {\n\t\terr = bpf_map_lookup_and_delete_elem(map_out_fd, NULL, &val);\n\t\tASSERT_OK(err, \"bpf_map_lookup_and_delete_elem\");\n\t\tASSERT_EQ(val, vals[i] * 5, \"bpf_map_push_elem val\");\n\t}\nout:\n\tpkt_v4.iph.saddr = 0;\n\tbpf_object__close(obj);\n}\n\nvoid test_queue_stack_map(void)\n{\n\ttest_queue_stack_map_by_type(QUEUE);\n\ttest_queue_stack_map_by_type(STACK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}