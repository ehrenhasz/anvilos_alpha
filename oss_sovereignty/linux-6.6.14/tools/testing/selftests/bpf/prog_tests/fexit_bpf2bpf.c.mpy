{
  "module_name": "fexit_bpf2bpf.c",
  "hash_id": "9c08204fe1df192e89d1486e5561d70e9e50e24e970f28741da41f8878451afe",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <network_helpers.h>\n#include <bpf/btf.h>\n#include \"bind4_prog.skel.h\"\n#include \"freplace_progmap.skel.h\"\n#include \"xdp_dummy.skel.h\"\n\ntypedef int (*test_cb)(struct bpf_object *obj);\n\nstatic int check_data_map(struct bpf_object *obj, int prog_cnt, bool reset)\n{\n\tstruct bpf_map *data_map = NULL, *map;\n\t__u64 *result = NULL;\n\tconst int zero = 0;\n\t__u32 duration = 0;\n\tint ret = -1, i;\n\n\tresult = malloc((prog_cnt + 32  ) * sizeof(__u64));\n\tif (CHECK(!result, \"alloc_memory\", \"failed to alloc memory\"))\n\t\treturn -ENOMEM;\n\n\tbpf_object__for_each_map(map, obj)\n\t\tif (bpf_map__is_internal(map)) {\n\t\t\tdata_map = map;\n\t\t\tbreak;\n\t\t}\n\tif (CHECK(!data_map, \"find_data_map\", \"data map not found\\n\"))\n\t\tgoto out;\n\n\tret = bpf_map_lookup_elem(bpf_map__fd(data_map), &zero, result);\n\tif (CHECK(ret, \"get_result\",\n\t\t  \"failed to get output data: %d\\n\", ret))\n\t\tgoto out;\n\n\tfor (i = 0; i < prog_cnt; i++) {\n\t\tif (CHECK(result[i] != 1, \"result\",\n\t\t\t  \"fexit_bpf2bpf result[%d] failed err %llu\\n\",\n\t\t\t  i, result[i]))\n\t\t\tgoto out;\n\t\tresult[i] = 0;\n\t}\n\tif (reset) {\n\t\tret = bpf_map_update_elem(bpf_map__fd(data_map), &zero, result, 0);\n\t\tif (CHECK(ret, \"reset_result\", \"failed to reset result\\n\"))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tfree(result);\n\treturn ret;\n}\n\nstatic void test_fexit_bpf2bpf_common(const char *obj_file,\n\t\t\t\t      const char *target_obj_file,\n\t\t\t\t      int prog_cnt,\n\t\t\t\t      const char **prog_name,\n\t\t\t\t      bool run_prog,\n\t\t\t\t      test_cb cb)\n{\n\tstruct bpf_object *obj = NULL, *tgt_obj;\n\t__u32 tgt_prog_id, info_len;\n\tstruct bpf_prog_info prog_info = {};\n\tstruct bpf_program **prog = NULL, *p;\n\tstruct bpf_link **link = NULL;\n\tint err, tgt_fd, i;\n\tstruct btf *btf;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v6,\n\t\t.data_size_in = sizeof(pkt_v6),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_load(target_obj_file, BPF_PROG_TYPE_UNSPEC,\n\t\t\t    &tgt_obj, &tgt_fd);\n\tif (!ASSERT_OK(err, \"tgt_prog_load\"))\n\t\treturn;\n\n\tinfo_len = sizeof(prog_info);\n\terr = bpf_prog_get_info_by_fd(tgt_fd, &prog_info, &info_len);\n\tif (!ASSERT_OK(err, \"tgt_fd_get_info\"))\n\t\tgoto close_prog;\n\n\ttgt_prog_id = prog_info.id;\n\tbtf = bpf_object__btf(tgt_obj);\n\n\tlink = calloc(sizeof(struct bpf_link *), prog_cnt);\n\tif (!ASSERT_OK_PTR(link, \"link_ptr\"))\n\t\tgoto close_prog;\n\n\tprog = calloc(sizeof(struct bpf_program *), prog_cnt);\n\tif (!ASSERT_OK_PTR(prog, \"prog_ptr\"))\n\t\tgoto close_prog;\n\n\tobj = bpf_object__open_file(obj_file, NULL);\n\tif (!ASSERT_OK_PTR(obj, \"obj_open\"))\n\t\tgoto close_prog;\n\n\tbpf_object__for_each_program(p, obj) {\n\t\terr = bpf_program__set_attach_target(p, tgt_fd, NULL);\n\t\tASSERT_OK(err, \"set_attach_target\");\n\t}\n\n\terr = bpf_object__load(obj);\n\tif (!ASSERT_OK(err, \"obj_load\"))\n\t\tgoto close_prog;\n\n\tfor (i = 0; i < prog_cnt; i++) {\n\t\tstruct bpf_link_info link_info;\n\t\tstruct bpf_program *pos;\n\t\tconst char *pos_sec_name;\n\t\tchar *tgt_name;\n\t\t__s32 btf_id;\n\n\t\ttgt_name = strstr(prog_name[i], \"/\");\n\t\tif (!ASSERT_OK_PTR(tgt_name, \"tgt_name\"))\n\t\t\tgoto close_prog;\n\t\tbtf_id = btf__find_by_name_kind(btf, tgt_name + 1, BTF_KIND_FUNC);\n\n\t\tprog[i] = NULL;\n\t\tbpf_object__for_each_program(pos, obj) {\n\t\t\tpos_sec_name = bpf_program__section_name(pos);\n\t\t\tif (pos_sec_name && !strcmp(pos_sec_name, prog_name[i])) {\n\t\t\t\tprog[i] = pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ASSERT_OK_PTR(prog[i], prog_name[i]))\n\t\t\tgoto close_prog;\n\n\t\tlink[i] = bpf_program__attach_trace(prog[i]);\n\t\tif (!ASSERT_OK_PTR(link[i], \"attach_trace\"))\n\t\t\tgoto close_prog;\n\n\t\tinfo_len = sizeof(link_info);\n\t\tmemset(&link_info, 0, sizeof(link_info));\n\t\terr = bpf_link_get_info_by_fd(bpf_link__fd(link[i]),\n\t\t\t\t\t      &link_info, &info_len);\n\t\tASSERT_OK(err, \"link_fd_get_info\");\n\t\tASSERT_EQ(link_info.tracing.attach_type,\n\t\t\t  bpf_program__expected_attach_type(prog[i]),\n\t\t\t  \"link_attach_type\");\n\t\tASSERT_EQ(link_info.tracing.target_obj_id, tgt_prog_id, \"link_tgt_obj_id\");\n\t\tASSERT_EQ(link_info.tracing.target_btf_id, btf_id, \"link_tgt_btf_id\");\n\t}\n\n\tif (cb) {\n\t\terr = cb(obj);\n\t\tif (err)\n\t\t\tgoto close_prog;\n\t}\n\n\tif (!run_prog)\n\t\tgoto close_prog;\n\n\terr = bpf_prog_test_run_opts(tgt_fd, &topts);\n\tASSERT_OK(err, \"prog_run\");\n\tASSERT_EQ(topts.retval, 0, \"prog_run_ret\");\n\n\tif (check_data_map(obj, prog_cnt, false))\n\t\tgoto close_prog;\n\nclose_prog:\n\tfor (i = 0; i < prog_cnt; i++)\n\t\tbpf_link__destroy(link[i]);\n\tbpf_object__close(obj);\n\tbpf_object__close(tgt_obj);\n\tfree(link);\n\tfree(prog);\n}\n\nstatic void test_target_no_callees(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"fexit/test_pkt_md_access\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./fexit_bpf2bpf_simple.bpf.o\",\n\t\t\t\t  \"./test_pkt_md_access.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, true, NULL);\n}\n\nstatic void test_target_yes_callees(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"fexit/test_pkt_access\",\n\t\t\"fexit/test_pkt_access_subprog1\",\n\t\t\"fexit/test_pkt_access_subprog2\",\n\t\t\"fexit/test_pkt_access_subprog3\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./fexit_bpf2bpf.bpf.o\",\n\t\t\t\t  \"./test_pkt_access.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, true, NULL);\n}\n\nstatic void test_func_replace(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"fexit/test_pkt_access\",\n\t\t\"fexit/test_pkt_access_subprog1\",\n\t\t\"fexit/test_pkt_access_subprog2\",\n\t\t\"fexit/test_pkt_access_subprog3\",\n\t\t\"freplace/get_skb_len\",\n\t\t\"freplace/get_skb_ifindex\",\n\t\t\"freplace/get_constant\",\n\t\t\"freplace/test_pkt_write_access_subprog\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./fexit_bpf2bpf.bpf.o\",\n\t\t\t\t  \"./test_pkt_access.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, true, NULL);\n}\n\nstatic void test_func_replace_verify(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"freplace/do_bind\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./freplace_connect4.bpf.o\",\n\t\t\t\t  \"./connect4_prog.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, false, NULL);\n}\n\nstatic int test_second_attach(struct bpf_object *obj)\n{\n\tconst char *prog_name = \"security_new_get_constant\";\n\tconst char *tgt_name = \"get_constant\";\n\tconst char *tgt_obj_file = \"./test_pkt_access.bpf.o\";\n\tstruct bpf_program *prog = NULL;\n\tstruct bpf_object *tgt_obj;\n\tstruct bpf_link *link;\n\tint err = 0, tgt_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v6,\n\t\t.data_size_in = sizeof(pkt_v6),\n\t\t.repeat = 1,\n\t);\n\n\tprog = bpf_object__find_program_by_name(obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"find_prog\"))\n\t\treturn -ENOENT;\n\n\terr = bpf_prog_test_load(tgt_obj_file, BPF_PROG_TYPE_UNSPEC,\n\t\t\t    &tgt_obj, &tgt_fd);\n\tif (!ASSERT_OK(err, \"second_prog_load\"))\n\t\treturn err;\n\n\tlink = bpf_program__attach_freplace(prog, tgt_fd, tgt_name);\n\tif (!ASSERT_OK_PTR(link, \"second_link\"))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(tgt_fd, &topts);\n\tif (!ASSERT_OK(err, \"ipv6 test_run\"))\n\t\tgoto out;\n\tif (!ASSERT_OK(topts.retval, \"ipv6 retval\"))\n\t\tgoto out;\n\n\terr = check_data_map(obj, 1, true);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tbpf_link__destroy(link);\n\tbpf_object__close(tgt_obj);\n\treturn err;\n}\n\nstatic void test_func_replace_multi(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"freplace/get_constant\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./freplace_get_constant.bpf.o\",\n\t\t\t\t  \"./test_pkt_access.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, true, test_second_attach);\n}\n\nstatic void test_fmod_ret_freplace(void)\n{\n\tstruct bpf_object *freplace_obj = NULL, *pkt_obj, *fmod_obj = NULL;\n\tconst char *freplace_name = \"./freplace_get_constant.bpf.o\";\n\tconst char *fmod_ret_name = \"./fmod_ret_freplace.bpf.o\";\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts);\n\tconst char *tgt_name = \"./test_pkt_access.bpf.o\";\n\tstruct bpf_link *freplace_link = NULL;\n\tstruct bpf_program *prog;\n\t__u32 duration = 0;\n\tint err, pkt_fd, attach_prog_fd;\n\n\terr = bpf_prog_test_load(tgt_name, BPF_PROG_TYPE_UNSPEC,\n\t\t\t    &pkt_obj, &pkt_fd);\n\t \n\tif (CHECK(err, \"tgt_prog_load\", \"file %s err %d errno %d\\n\",\n\t\t  tgt_name, err, errno))\n\t\treturn;\n\n\tfreplace_obj = bpf_object__open_file(freplace_name, NULL);\n\tif (!ASSERT_OK_PTR(freplace_obj, \"freplace_obj_open\"))\n\t\tgoto out;\n\n\tprog = bpf_object__next_program(freplace_obj, NULL);\n\terr = bpf_program__set_attach_target(prog, pkt_fd, NULL);\n\tASSERT_OK(err, \"freplace__set_attach_target\");\n\n\terr = bpf_object__load(freplace_obj);\n\tif (CHECK(err, \"freplace_obj_load\", \"err %d\\n\", err))\n\t\tgoto out;\n\n\tfreplace_link = bpf_program__attach_trace(prog);\n\tif (!ASSERT_OK_PTR(freplace_link, \"freplace_attach_trace\"))\n\t\tgoto out;\n\n\tfmod_obj = bpf_object__open_file(fmod_ret_name, NULL);\n\tif (!ASSERT_OK_PTR(fmod_obj, \"fmod_obj_open\"))\n\t\tgoto out;\n\n\tattach_prog_fd = bpf_program__fd(prog);\n\tprog = bpf_object__next_program(fmod_obj, NULL);\n\terr = bpf_program__set_attach_target(prog, attach_prog_fd, NULL);\n\tASSERT_OK(err, \"fmod_ret_set_attach_target\");\n\n\terr = bpf_object__load(fmod_obj);\n\tif (CHECK(!err, \"fmod_obj_load\", \"loading fmod_ret should fail\\n\"))\n\t\tgoto out;\n\nout:\n\tbpf_link__destroy(freplace_link);\n\tbpf_object__close(freplace_obj);\n\tbpf_object__close(fmod_obj);\n\tbpf_object__close(pkt_obj);\n}\n\n\nstatic void test_func_sockmap_update(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"freplace/cls_redirect\",\n\t};\n\ttest_fexit_bpf2bpf_common(\"./freplace_cls_redirect.bpf.o\",\n\t\t\t\t  \"./test_cls_redirect.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, false, NULL);\n}\n\nstatic void test_obj_load_failure_common(const char *obj_file,\n\t\t\t\t\t const char *target_obj_file)\n{\n\t \n\tstruct bpf_object *obj = NULL, *pkt_obj;\n\tstruct bpf_program *prog;\n\tint err, pkt_fd;\n\t__u32 duration = 0;\n\n\terr = bpf_prog_test_load(target_obj_file, BPF_PROG_TYPE_UNSPEC,\n\t\t\t    &pkt_obj, &pkt_fd);\n\t \n\tif (CHECK(err, \"tgt_prog_load\", \"file %s err %d errno %d\\n\",\n\t\t  target_obj_file, err, errno))\n\t\treturn;\n\n\tobj = bpf_object__open_file(obj_file, NULL);\n\tif (!ASSERT_OK_PTR(obj, \"obj_open\"))\n\t\tgoto close_prog;\n\n\tprog = bpf_object__next_program(obj, NULL);\n\terr = bpf_program__set_attach_target(prog, pkt_fd, NULL);\n\tASSERT_OK(err, \"set_attach_target\");\n\n\t \n\terr = bpf_object__load(obj);\n\tif (CHECK(!err, \"bpf_obj_load should fail\", \"err %d\\n\", err))\n\t\tgoto close_prog;\n\nclose_prog:\n\tbpf_object__close(obj);\n\tbpf_object__close(pkt_obj);\n}\n\nstatic void test_func_replace_return_code(void)\n{\n\t \n\ttest_obj_load_failure_common(\"./freplace_connect_v4_prog.bpf.o\",\n\t\t\t\t     \"./connect4_prog.bpf.o\");\n}\n\nstatic void test_func_map_prog_compatibility(void)\n{\n\t \n\ttest_obj_load_failure_common(\"./freplace_attach_probe.bpf.o\",\n\t\t\t\t     \"./test_attach_probe.bpf.o\");\n}\n\nstatic void test_func_replace_global_func(void)\n{\n\tconst char *prog_name[] = {\n\t\t\"freplace/test_pkt_access\",\n\t};\n\n\ttest_fexit_bpf2bpf_common(\"./freplace_global_func.bpf.o\",\n\t\t\t\t  \"./test_pkt_access.bpf.o\",\n\t\t\t\t  ARRAY_SIZE(prog_name),\n\t\t\t\t  prog_name, false, NULL);\n}\n\nstatic int find_prog_btf_id(const char *name, __u32 attach_prog_fd)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tstruct btf *btf;\n\tint ret;\n\n\tret = bpf_prog_get_info_by_fd(attach_prog_fd, &info, &info_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!info.btf_id)\n\t\treturn -EINVAL;\n\n\tbtf = btf__load_from_kernel_by_id(info.btf_id);\n\tret = libbpf_get_error(btf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);\n\tbtf__free(btf);\n\treturn ret;\n}\n\nstatic int load_fentry(int attach_prog_fd, int attach_btf_id)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t    .expected_attach_type = BPF_TRACE_FENTRY,\n\t\t    .attach_prog_fd = attach_prog_fd,\n\t\t    .attach_btf_id = attach_btf_id,\n\t);\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\n\treturn bpf_prog_load(BPF_PROG_TYPE_TRACING,\n\t\t\t     \"bind4_fentry\",\n\t\t\t     \"GPL\",\n\t\t\t     insns,\n\t\t\t     ARRAY_SIZE(insns),\n\t\t\t     &opts);\n}\n\nstatic void test_fentry_to_cgroup_bpf(void)\n{\n\tstruct bind4_prog *skel = NULL;\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint cgroup_fd = -1;\n\tint fentry_fd = -1;\n\tint btf_id;\n\n\tcgroup_fd = test__join_cgroup(\"/fentry_to_cgroup_bpf\");\n\tif (!ASSERT_GE(cgroup_fd, 0, \"cgroup_fd\"))\n\t\treturn;\n\n\tskel = bind4_prog__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel\"))\n\t\tgoto cleanup;\n\n\tskel->links.bind_v4_prog = bpf_program__attach_cgroup(skel->progs.bind_v4_prog, cgroup_fd);\n\tif (!ASSERT_OK_PTR(skel->links.bind_v4_prog, \"bpf_program__attach_cgroup\"))\n\t\tgoto cleanup;\n\n\tbtf_id = find_prog_btf_id(\"bind_v4_prog\", bpf_program__fd(skel->progs.bind_v4_prog));\n\tif (!ASSERT_GE(btf_id, 0, \"find_prog_btf_id\"))\n\t\tgoto cleanup;\n\n\tfentry_fd = load_fentry(bpf_program__fd(skel->progs.bind_v4_prog), btf_id);\n\tif (!ASSERT_GE(fentry_fd, 0, \"load_fentry\"))\n\t\tgoto cleanup;\n\n\t \n\n\tASSERT_OK(bpf_prog_get_info_by_fd(fentry_fd, &info, &info_len),\n\t\t  \"bpf_prog_get_info_by_fd\");\n\n\tASSERT_EQ(info.btf_id, 0, \"info.btf_id\");\n\tASSERT_EQ(info.attach_btf_id, btf_id, \"info.attach_btf_id\");\n\tASSERT_GT(info.attach_btf_obj_id, 0, \"info.attach_btf_obj_id\");\n\ncleanup:\n\tif (cgroup_fd >= 0)\n\t\tclose(cgroup_fd);\n\tif (fentry_fd >= 0)\n\t\tclose(fentry_fd);\n\tbind4_prog__destroy(skel);\n}\n\nstatic void test_func_replace_progmap(void)\n{\n\tstruct bpf_cpumap_val value = { .qsize = 1 };\n\tstruct freplace_progmap *skel = NULL;\n\tstruct xdp_dummy *tgt_skel = NULL;\n\t__u32 key = 0;\n\tint err;\n\n\tskel = freplace_progmap__open();\n\tif (!ASSERT_OK_PTR(skel, \"prog_open\"))\n\t\treturn;\n\n\ttgt_skel = xdp_dummy__open_and_load();\n\tif (!ASSERT_OK_PTR(tgt_skel, \"tgt_prog_load\"))\n\t\tgoto out;\n\n\terr = bpf_program__set_attach_target(skel->progs.xdp_cpumap_prog,\n\t\t\t\t\t     bpf_program__fd(tgt_skel->progs.xdp_dummy_prog),\n\t\t\t\t\t     \"xdp_dummy_prog\");\n\tif (!ASSERT_OK(err, \"set_attach_target\"))\n\t\tgoto out;\n\n\terr = freplace_progmap__load(skel);\n\tif (!ASSERT_OK(err, \"obj_load\"))\n\t\tgoto out;\n\n\t \n\tvalue.bpf_prog.fd = bpf_program__fd(skel->progs.xdp_drop_prog);\n\terr = bpf_map_update_elem(bpf_map__fd(skel->maps.cpu_map),\n\t\t\t\t  &key, &value, 0);\n\tASSERT_OK(err, \"map_update\");\n\nout:\n\txdp_dummy__destroy(tgt_skel);\n\tfreplace_progmap__destroy(skel);\n}\n\n \nvoid serial_test_fexit_bpf2bpf(void)\n{\n\tif (test__start_subtest(\"target_no_callees\"))\n\t\ttest_target_no_callees();\n\tif (test__start_subtest(\"target_yes_callees\"))\n\t\ttest_target_yes_callees();\n\tif (test__start_subtest(\"func_replace\"))\n\t\ttest_func_replace();\n\tif (test__start_subtest(\"func_replace_verify\"))\n\t\ttest_func_replace_verify();\n\tif (test__start_subtest(\"func_sockmap_update\"))\n\t\ttest_func_sockmap_update();\n\tif (test__start_subtest(\"func_replace_return_code\"))\n\t\ttest_func_replace_return_code();\n\tif (test__start_subtest(\"func_map_prog_compatibility\"))\n\t\ttest_func_map_prog_compatibility();\n\tif (test__start_subtest(\"func_replace_multi\"))\n\t\ttest_func_replace_multi();\n\tif (test__start_subtest(\"fmod_ret_freplace\"))\n\t\ttest_fmod_ret_freplace();\n\tif (test__start_subtest(\"func_replace_global_func\"))\n\t\ttest_func_replace_global_func();\n\tif (test__start_subtest(\"fentry_to_cgroup_bpf\"))\n\t\ttest_fentry_to_cgroup_bpf();\n\tif (test__start_subtest(\"func_replace_progmap\"))\n\t\ttest_func_replace_progmap();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}