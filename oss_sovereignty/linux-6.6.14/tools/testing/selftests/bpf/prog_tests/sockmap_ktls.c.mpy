{
  "module_name": "sockmap_ktls.c",
  "hash_id": "cf5d0ac431b8fbbff97afa25265a2f3ced39af88b20ef98e35761905368c7041",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sockmap_ktls.c",
  "human_readable_source": "\n\n \n\n#include <netinet/tcp.h>\n#include \"test_progs.h\"\n\n#define MAX_TEST_NAME 80\n#define TCP_ULP 31\n\nstatic int tcp_server(int family)\n{\n\tint err, s;\n\n\ts = socket(family, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(s, 0, \"socket\"))\n\t\treturn -1;\n\n\terr = listen(s, SOMAXCONN);\n\tif (!ASSERT_OK(err, \"listen\"))\n\t\treturn -1;\n\n\treturn s;\n}\n\nstatic int disconnect(int fd)\n{\n\tstruct sockaddr unspec = { AF_UNSPEC };\n\n\treturn connect(fd, &unspec, sizeof(unspec));\n}\n\n \nstatic void test_sockmap_ktls_disconnect_after_delete(int family, int map)\n{\n\tstruct sockaddr_storage addr = {0};\n\tsocklen_t len = sizeof(addr);\n\tint err, cli, srv, zero = 0;\n\n\tsrv = tcp_server(family);\n\tif (srv == -1)\n\t\treturn;\n\n\terr = getsockname(srv, (struct sockaddr *)&addr, &len);\n\tif (!ASSERT_OK(err, \"getsockopt\"))\n\t\tgoto close_srv;\n\n\tcli = socket(family, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(cli, 0, \"socket\"))\n\t\tgoto close_srv;\n\n\terr = connect(cli, (struct sockaddr *)&addr, len);\n\tif (!ASSERT_OK(err, \"connect\"))\n\t\tgoto close_cli;\n\n\terr = bpf_map_update_elem(map, &zero, &cli, 0);\n\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\tgoto close_cli;\n\n\terr = setsockopt(cli, IPPROTO_TCP, TCP_ULP, \"tls\", strlen(\"tls\"));\n\tif (!ASSERT_OK(err, \"setsockopt(TCP_ULP)\"))\n\t\tgoto close_cli;\n\n\terr = bpf_map_delete_elem(map, &zero);\n\tif (!ASSERT_OK(err, \"bpf_map_delete_elem\"))\n\t\tgoto close_cli;\n\n\terr = disconnect(cli);\n\tASSERT_OK(err, \"disconnect\");\n\nclose_cli:\n\tclose(cli);\nclose_srv:\n\tclose(srv);\n}\n\nstatic void test_sockmap_ktls_update_fails_when_sock_has_ulp(int family, int map)\n{\n\tstruct sockaddr_storage addr = {};\n\tsocklen_t len = sizeof(addr);\n\tstruct sockaddr_in6 *v6;\n\tstruct sockaddr_in *v4;\n\tint err, s, zero = 0;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tv4 = (struct sockaddr_in *)&addr;\n\t\tv4->sin_family = AF_INET;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tv6 = (struct sockaddr_in6 *)&addr;\n\t\tv6->sin6_family = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tPRINT_FAIL(\"unsupported socket family %d\", family);\n\t\treturn;\n\t}\n\n\ts = socket(family, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(s, 0, \"socket\"))\n\t\treturn;\n\n\terr = bind(s, (struct sockaddr *)&addr, len);\n\tif (!ASSERT_OK(err, \"bind\"))\n\t\tgoto close;\n\n\terr = getsockname(s, (struct sockaddr *)&addr, &len);\n\tif (!ASSERT_OK(err, \"getsockname\"))\n\t\tgoto close;\n\n\terr = connect(s, (struct sockaddr *)&addr, len);\n\tif (!ASSERT_OK(err, \"connect\"))\n\t\tgoto close;\n\n\t \n\terr = setsockopt(s, IPPROTO_TCP, TCP_ULP, \"tls\", strlen(\"tls\"));\n\tif (!ASSERT_OK(err, \"setsockopt(TCP_ULP)\"))\n\t\tgoto close;\n\n\t \n\terr = bpf_map_update_elem(map, &zero, &s, BPF_ANY);\n\tif (!ASSERT_ERR(err, \"sockmap update elem\"))\n\t\tgoto close;\n\n\t \n\terr = setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &zero, sizeof(zero));\n\tASSERT_OK(err, \"setsockopt(TCP_NODELAY)\");\n\nclose:\n\tclose(s);\n}\n\nstatic const char *fmt_test_name(const char *subtest_name, int family,\n\t\t\t\t enum bpf_map_type map_type)\n{\n\tconst char *map_type_str = BPF_MAP_TYPE_SOCKMAP ? \"SOCKMAP\" : \"SOCKHASH\";\n\tconst char *family_str = AF_INET ? \"IPv4\" : \"IPv6\";\n\tstatic char test_name[MAX_TEST_NAME];\n\n\tsnprintf(test_name, MAX_TEST_NAME,\n\t\t \"sockmap_ktls %s %s %s\",\n\t\t subtest_name, family_str, map_type_str);\n\n\treturn test_name;\n}\n\nstatic void run_tests(int family, enum bpf_map_type map_type)\n{\n\tint map;\n\n\tmap = bpf_map_create(map_type, NULL, sizeof(int), sizeof(int), 1, NULL);\n\tif (!ASSERT_GE(map, 0, \"bpf_map_create\"))\n\t\treturn;\n\n\tif (test__start_subtest(fmt_test_name(\"disconnect_after_delete\", family, map_type)))\n\t\ttest_sockmap_ktls_disconnect_after_delete(family, map);\n\tif (test__start_subtest(fmt_test_name(\"update_fails_when_sock_has_ulp\", family, map_type)))\n\t\ttest_sockmap_ktls_update_fails_when_sock_has_ulp(family, map);\n\n\tclose(map);\n}\n\nvoid test_sockmap_ktls(void)\n{\n\trun_tests(AF_INET, BPF_MAP_TYPE_SOCKMAP);\n\trun_tests(AF_INET, BPF_MAP_TYPE_SOCKHASH);\n\trun_tests(AF_INET6, BPF_MAP_TYPE_SOCKMAP);\n\trun_tests(AF_INET6, BPF_MAP_TYPE_SOCKHASH);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}