{
  "module_name": "mmap.c",
  "hash_id": "579561528adba59785cffc0ee844cf0fc25e50ae07bb5ade754ec4d4a994b1bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/mmap.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <sys/mman.h>\n#include \"test_mmap.skel.h\"\n\nstruct map_data {\n\t__u64 val[512 * 4];\n};\n\nstatic size_t roundup_page(size_t sz)\n{\n\tlong page_size = sysconf(_SC_PAGE_SIZE);\n\treturn (sz + page_size - 1) / page_size * page_size;\n}\n\nvoid test_mmap(void)\n{\n\tconst size_t bss_sz = roundup_page(sizeof(struct test_mmap__bss));\n\tconst size_t map_sz = roundup_page(sizeof(struct map_data));\n\tconst int zero = 0, one = 1, two = 2, far = 1500;\n\tconst long page_size = sysconf(_SC_PAGE_SIZE);\n\tint err, duration = 0, i, data_map_fd, data_map_id, tmp_fd, rdmap_fd;\n\tstruct bpf_map *data_map, *bss_map;\n\tvoid *bss_mmaped = NULL, *map_mmaped = NULL, *tmp0, *tmp1, *tmp2;\n\tstruct test_mmap__bss *bss_data;\n\tstruct bpf_map_info map_info;\n\t__u32 map_info_sz = sizeof(map_info);\n\tstruct map_data *map_data;\n\tstruct test_mmap *skel;\n\t__u64 val = 0;\n\n\tskel = test_mmap__open();\n\tif (CHECK(!skel, \"skel_open\", \"skeleton open failed\\n\"))\n\t\treturn;\n\n\terr = bpf_map__set_max_entries(skel->maps.rdonly_map, page_size);\n\tif (CHECK(err != 0, \"bpf_map__set_max_entries\", \"bpf_map__set_max_entries failed\\n\"))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map__set_max_entries(skel->maps.data_map,\n\t\t\t\t       4 * (page_size / sizeof(u64)));\n\tif (CHECK(err != 0, \"bpf_map__set_max_entries\", \"bpf_map__set_max_entries failed\\n\"))\n\t\tgoto cleanup;\n\n\terr = test_mmap__load(skel);\n\tif (CHECK(err != 0, \"skel_load\", \"skeleton load failed\\n\"))\n\t\tgoto cleanup;\n\n\tbss_map = skel->maps.bss;\n\tdata_map = skel->maps.data_map;\n\tdata_map_fd = bpf_map__fd(data_map);\n\n\trdmap_fd = bpf_map__fd(skel->maps.rdonly_map);\n\ttmp1 = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, rdmap_fd, 0);\n\tif (CHECK(tmp1 != MAP_FAILED, \"rdonly_write_mmap\", \"unexpected success\\n\")) {\n\t\tmunmap(tmp1, page_size);\n\t\tgoto cleanup;\n\t}\n\t \n\ttmp1 = mmap(NULL, page_size, PROT_READ, MAP_SHARED, rdmap_fd, 0);\n\tif (CHECK(tmp1 == MAP_FAILED, \"rdonly_read_mmap\", \"failed: %d\\n\", errno))\n\t\tgoto cleanup;\n\n\t \n\tmemset(&map_info, 0, map_info_sz);\n\terr = bpf_map_get_info_by_fd(data_map_fd, &map_info, &map_info_sz);\n\tif (CHECK(err, \"map_get_info\", \"failed %d\\n\", errno))\n\t\tgoto cleanup;\n\tdata_map_id = map_info.id;\n\n\t \n\tbss_mmaped = mmap(NULL, bss_sz, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t\t  bpf_map__fd(bss_map), 0);\n\tif (CHECK(bss_mmaped == MAP_FAILED, \"bss_mmap\",\n\t\t  \".bss mmap failed: %d\\n\", errno)) {\n\t\tbss_mmaped = NULL;\n\t\tgoto cleanup;\n\t}\n\t \n\tmap_mmaped = mmap(NULL, map_sz, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t\t  data_map_fd, 0);\n\tif (CHECK(map_mmaped == MAP_FAILED, \"data_mmap\",\n\t\t  \"data_map mmap failed: %d\\n\", errno)) {\n\t\tmap_mmaped = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tbss_data = bss_mmaped;\n\tmap_data = map_mmaped;\n\n\tCHECK_FAIL(bss_data->in_val);\n\tCHECK_FAIL(bss_data->out_val);\n\tCHECK_FAIL(skel->bss->in_val);\n\tCHECK_FAIL(skel->bss->out_val);\n\tCHECK_FAIL(map_data->val[0]);\n\tCHECK_FAIL(map_data->val[1]);\n\tCHECK_FAIL(map_data->val[2]);\n\tCHECK_FAIL(map_data->val[far]);\n\n\terr = test_mmap__attach(skel);\n\tif (CHECK(err, \"attach_raw_tp\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\tbss_data->in_val = 123;\n\tval = 111;\n\tCHECK_FAIL(bpf_map_update_elem(data_map_fd, &zero, &val, 0));\n\n\tusleep(1);\n\n\tCHECK_FAIL(bss_data->in_val != 123);\n\tCHECK_FAIL(bss_data->out_val != 123);\n\tCHECK_FAIL(skel->bss->in_val != 123);\n\tCHECK_FAIL(skel->bss->out_val != 123);\n\tCHECK_FAIL(map_data->val[0] != 111);\n\tCHECK_FAIL(map_data->val[1] != 222);\n\tCHECK_FAIL(map_data->val[2] != 123);\n\tCHECK_FAIL(map_data->val[far] != 3 * 123);\n\n\tCHECK_FAIL(bpf_map_lookup_elem(data_map_fd, &zero, &val));\n\tCHECK_FAIL(val != 111);\n\tCHECK_FAIL(bpf_map_lookup_elem(data_map_fd, &one, &val));\n\tCHECK_FAIL(val != 222);\n\tCHECK_FAIL(bpf_map_lookup_elem(data_map_fd, &two, &val));\n\tCHECK_FAIL(val != 123);\n\tCHECK_FAIL(bpf_map_lookup_elem(data_map_fd, &far, &val));\n\tCHECK_FAIL(val != 3 * 123);\n\n\t \n\terr = bpf_map_freeze(data_map_fd);\n\tif (CHECK(!err || errno != EBUSY, \"no_freeze\",\n\t\t  \"data_map freeze succeeded: err=%d, errno=%d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\terr = mprotect(map_mmaped, map_sz, PROT_READ);\n\tif (CHECK(err, \"mprotect_ro\", \"mprotect to r/o failed %d\\n\", errno))\n\t\tgoto cleanup;\n\n\t \n\terr = munmap(map_mmaped, map_sz);\n\tmap_mmaped = NULL;\n\tif (CHECK(err, \"data_map_munmap\", \"data_map munmap failed: %d\\n\", errno))\n\t\tgoto cleanup;\n\n\t \n\tmap_mmaped = mmap(NULL, map_sz, PROT_READ, MAP_SHARED, data_map_fd, 0);\n\tif (CHECK(map_mmaped == MAP_FAILED, \"data_mmap\",\n\t\t  \"data_map R/O mmap failed: %d\\n\", errno)) {\n\t\tmap_mmaped = NULL;\n\t\tgoto cleanup;\n\t}\n\terr = mprotect(map_mmaped, map_sz, PROT_WRITE);\n\tif (CHECK(!err, \"mprotect_wr\", \"mprotect() succeeded unexpectedly!\\n\"))\n\t\tgoto cleanup;\n\terr = mprotect(map_mmaped, map_sz, PROT_EXEC);\n\tif (CHECK(!err, \"mprotect_ex\", \"mprotect() succeeded unexpectedly!\\n\"))\n\t\tgoto cleanup;\n\tmap_data = map_mmaped;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tint flags = i % 2 ? PROT_READ : PROT_WRITE;\n\t\tvoid *p;\n\n\t\tp = mmap(NULL, map_sz, flags, MAP_SHARED, data_map_fd, 0);\n\t\tif (CHECK_FAIL(p == MAP_FAILED))\n\t\t\tgoto cleanup;\n\t\terr = munmap(p, map_sz);\n\t\tif (CHECK_FAIL(err))\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\terr = bpf_map_freeze(data_map_fd);\n\tif (CHECK(err, \"freeze\", \"data_map freeze failed: err=%d, errno=%d\\n\",\n\t\t  err, errno))\n\t\tgoto cleanup;\n\n\t \n\ttmp1 = mmap(NULL, map_sz, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t    data_map_fd, 0);\n\tif (CHECK(tmp1 != MAP_FAILED, \"data_mmap\", \"mmap succeeded\\n\")) {\n\t\tmunmap(tmp1, map_sz);\n\t\tgoto cleanup;\n\t}\n\n\tbss_data->in_val = 321;\n\tusleep(1);\n\tCHECK_FAIL(bss_data->in_val != 321);\n\tCHECK_FAIL(bss_data->out_val != 321);\n\tCHECK_FAIL(skel->bss->in_val != 321);\n\tCHECK_FAIL(skel->bss->out_val != 321);\n\tCHECK_FAIL(map_data->val[0] != 111);\n\tCHECK_FAIL(map_data->val[1] != 222);\n\tCHECK_FAIL(map_data->val[2] != 321);\n\tCHECK_FAIL(map_data->val[far] != 3 * 321);\n\n\t \n\n\ttmp0 = mmap(NULL, 4 * page_size, PROT_READ, MAP_SHARED | MAP_ANONYMOUS,\n\t\t\t  -1, 0);\n\tif (CHECK(tmp0 == MAP_FAILED, \"adv_mmap0\", \"errno %d\\n\", errno))\n\t\tgoto cleanup;\n\n\t \n\ttmp1 = mmap(tmp0, 3 * page_size, PROT_READ, MAP_SHARED | MAP_FIXED,\n\t\t\t  data_map_fd, 0);\n\tif (CHECK(tmp0 != tmp1, \"adv_mmap1\", \"tmp0: %p, tmp1: %p\\n\", tmp0, tmp1)) {\n\t\tmunmap(tmp0, 4 * page_size);\n\t\tgoto cleanup;\n\t}\n\n\t \n\terr = munmap(tmp1 + page_size, page_size);\n\tif (CHECK(err, \"adv_mmap2\", \"errno %d\\n\", errno)) {\n\t\tmunmap(tmp1, 4 * page_size);\n\t\tgoto cleanup;\n\t}\n\n\t \n\ttmp2 = mmap(tmp1 + page_size, page_size, PROT_READ,\n\t\t    MAP_SHARED | MAP_FIXED, data_map_fd, 0);\n\tif (CHECK(tmp2 == MAP_FAILED, \"adv_mmap3\", \"errno %d\\n\", errno)) {\n\t\tmunmap(tmp1, page_size);\n\t\tmunmap(tmp1 + 2*page_size, 2 * page_size);\n\t\tgoto cleanup;\n\t}\n\tCHECK(tmp1 + page_size != tmp2, \"adv_mmap4\",\n\t      \"tmp1: %p, tmp2: %p\\n\", tmp1, tmp2);\n\n\t \n\ttmp2 = mmap(tmp1, 4 * page_size, PROT_READ, MAP_SHARED | MAP_FIXED,\n\t\t    data_map_fd, 0);\n\tif (CHECK(tmp2 == MAP_FAILED, \"adv_mmap5\", \"errno %d\\n\", errno)) {\n\t\tmunmap(tmp1, 4 * page_size);  \n\t\tgoto cleanup;\n\t}\n\tCHECK(tmp1 != tmp2, \"adv_mmap6\", \"tmp1: %p, tmp2: %p\\n\", tmp1, tmp2);\n\n\tmap_data = tmp2;\n\tCHECK_FAIL(bss_data->in_val != 321);\n\tCHECK_FAIL(bss_data->out_val != 321);\n\tCHECK_FAIL(skel->bss->in_val != 321);\n\tCHECK_FAIL(skel->bss->out_val != 321);\n\tCHECK_FAIL(map_data->val[0] != 111);\n\tCHECK_FAIL(map_data->val[1] != 222);\n\tCHECK_FAIL(map_data->val[2] != 321);\n\tCHECK_FAIL(map_data->val[far] != 3 * 321);\n\n\tmunmap(tmp2, 4 * page_size);\n\n\t \n\ttmp1 = mmap(NULL, 4 * page_size, PROT_READ, MAP_SHARED | MAP_FIXED,\n\t\t    data_map_fd, page_size  );\n\tif (CHECK(tmp1 != MAP_FAILED, \"adv_mmap7\", \"unexpected success\")) {\n\t\tmunmap(tmp1, 4 * page_size);\n\t\tgoto cleanup;\n\t}\n\n\ttmp1 = mmap(NULL, map_sz, PROT_READ, MAP_SHARED, data_map_fd, 0);\n\tif (CHECK(tmp1 == MAP_FAILED, \"last_mmap\", \"failed %d\\n\", errno))\n\t\tgoto cleanup;\n\n\ttest_mmap__destroy(skel);\n\tskel = NULL;\n\tCHECK_FAIL(munmap(bss_mmaped, bss_sz));\n\tbss_mmaped = NULL;\n\tCHECK_FAIL(munmap(map_mmaped, map_sz));\n\tmap_mmaped = NULL;\n\n\t \n\ttmp_fd = bpf_map_get_fd_by_id(data_map_id);\n\tif (CHECK(tmp_fd < 0, \"get_map_by_id\", \"failed %d\\n\", errno)) {\n\t\tmunmap(tmp1, map_sz);\n\t\tgoto cleanup;\n\t}\n\tclose(tmp_fd);\n\n\t \n\tmunmap(tmp1, map_sz);\n\n\t \n\tfor (i = 0; i < 10000; i++) {\n\t\t__u32 id = data_map_id - 1;\n\t\tif (bpf_map_get_next_id(id, &id) || id > data_map_id)\n\t\t\tbreak;\n\t\tusleep(1);\n\t}\n\n\t \n\ttmp_fd = bpf_map_get_fd_by_id(data_map_id);\n\tif (CHECK(tmp_fd >= 0, \"get_map_by_id_after\",\n\t\t  \"unexpectedly succeeded %d\\n\", tmp_fd)) {\n\t\tclose(tmp_fd);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (bss_mmaped)\n\t\tCHECK_FAIL(munmap(bss_mmaped, bss_sz));\n\tif (map_mmaped)\n\t\tCHECK_FAIL(munmap(map_mmaped, map_sz));\n\ttest_mmap__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}