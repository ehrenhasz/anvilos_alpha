{
  "module_name": "tc_links.c",
  "hash_id": "538eda83a7ba375658b85bb77f3b44925319f2de24a10db66022c4b67c112eca",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tc_links.c",
  "human_readable_source": "\n \n#include <uapi/linux/if_link.h>\n#include <uapi/linux/pkt_sched.h>\n#include <net/if.h>\n#include <test_progs.h>\n\n#define loopback 1\n#define ping_cmd \"ping -q -c1 -w1 127.0.0.1 > /dev/null\"\n\n#include \"test_tc_link.skel.h\"\n#include \"tc_helpers.h\"\n\nvoid serial_test_tc_links_basic(void)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[2], link_ids[2];\n\t__u32 pid1, pid2, lid1, lid2;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 0);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\n\tASSERT_EQ(skel->bss->seen_tc1, false, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 1);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, BPF_TCX_INGRESS, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 2, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], 0, \"link_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\tASSERT_NEQ(lid1, lid2, \"link_ids_1_2\");\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 1);\n\tassert_mprog_count(BPF_TCX_EGRESS, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, BPF_TCX_EGRESS, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 2, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid2, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], 0, \"link_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 0);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n}\n\nstatic void test_tc_links_before_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[5], link_ids[5];\n\t__u32 pid1, pid2, pid3, pid4;\n\t__u32 lid1, lid2, lid3, lid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tlid3 = id_from_link_fd(bpf_link__fd(skel->links.tc3));\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_LINK,\n\t\t.relative_id = lid1,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tlid4 = id_from_link_fd(bpf_link__fd(skel->links.tc4));\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid4, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid4, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid1, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], pid3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], lid3, \"link_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], pid2, \"prog_ids[3]\");\n\tASSERT_EQ(optq.link_ids[3], lid2, \"link_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(optq.link_ids[4], 0, \"link_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_before(void)\n{\n\ttest_tc_links_before_target(BPF_TCX_INGRESS);\n\ttest_tc_links_before_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_after_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[5], link_ids[5];\n\t__u32 pid1, pid2, pid3, pid4;\n\t__u32 lid1, lid2, lid3, lid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tlid3 = id_from_link_fd(bpf_link__fd(skel->links.tc3));\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER | BPF_F_LINK,\n\t\t.relative_fd = bpf_link__fd(skel->links.tc2),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tlid4 = id_from_link_fd(bpf_link__fd(skel->links.tc4));\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid3, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], pid2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], lid2, \"link_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], pid4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.link_ids[3], lid4, \"link_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(optq.link_ids[4], 0, \"link_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_after(void)\n{\n\ttest_tc_links_after_target(BPF_TCX_INGRESS);\n\ttest_tc_links_after_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_revision_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[3], link_ids[3];\n\t__u32 pid1, pid2, lid1, lid2;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(target, 0);\n\n\toptl.expected_revision = 1;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\toptl.expected_revision = 1;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 1);\n\n\toptl.expected_revision = 2;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_revision(void)\n{\n\ttest_tc_links_revision_target(BPF_TCX_INGRESS);\n\ttest_tc_links_revision_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_chain_classic(int target, bool chain_tc_old)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = loopback);\n\tbool hook_created = false, tc_attached = false;\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, pid3;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tif (chain_tc_old) {\n\t\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\t\terr = bpf_tc_hook_create(&tc_hook);\n\t\tif (err == 0)\n\t\t\thook_created = true;\n\t\terr = err == -EEXIST ? 0 : err;\n\t\tif (!ASSERT_OK(err, \"bpf_tc_hook_create\"))\n\t\t\tgoto cleanup;\n\n\t\ttc_opts.prog_fd = bpf_program__fd(skel->progs.tc3);\n\t\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\t\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\t\tgoto cleanup;\n\t\ttc_attached = true;\n\t}\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count(target, 2);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\n\n\terr = bpf_link__detach(skel->links.tc2);\n\tif (!ASSERT_OK(err, \"prog_detach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\ncleanup:\n\tif (tc_attached) {\n\t\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\t\terr = bpf_tc_detach(&tc_hook, &tc_opts);\n\t\tASSERT_OK(err, \"bpf_tc_detach\");\n\t}\n\tif (hook_created) {\n\t\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\t\tbpf_tc_hook_destroy(&tc_hook);\n\t}\n\tassert_mprog_count(target, 1);\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_chain_classic(void)\n{\n\ttest_tc_chain_classic(BPF_TCX_INGRESS, false);\n\ttest_tc_chain_classic(BPF_TCX_EGRESS, false);\n\ttest_tc_chain_classic(BPF_TCX_INGRESS, true);\n\ttest_tc_chain_classic(BPF_TCX_EGRESS, true);\n}\n\nstatic void test_tc_links_replace_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, pid3, lid1, lid2;\n\t__u32 prog_ids[4], link_ids[4];\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\toptl.expected_revision = 1;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_id = pid1,\n\t\t.expected_revision = 2,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid2, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid1, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc2),\n\t\t.expected_revision = 3,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_REPLACE | BPF_F_LINK,\n\t\t.relative_fd = bpf_link__fd(skel->links.tc2),\n\t\t.expected_revision = 3,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_REPLACE | BPF_F_LINK | BPF_F_AFTER,\n\t\t.relative_id = lid2,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 2);\n\n\terr = bpf_link__update_program(skel->links.tc2, skel->progs.tc3);\n\tif (!ASSERT_OK(err, \"link_update\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 4, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid3, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid2, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid1, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\n\terr = bpf_link__detach(skel->links.tc2);\n\tif (!ASSERT_OK(err, \"link_detach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], 0, \"link_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\n\terr = bpf_link__update_program(skel->links.tc1, skel->progs.tc1);\n\tif (!ASSERT_OK(err, \"link_update_self\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], 0, \"link_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_replace(void)\n{\n\ttest_tc_links_replace_target(BPF_TCX_INGRESS);\n\ttest_tc_links_replace_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_invalid_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, lid1;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(target, 0);\n\n\toptl.flags = BPF_F_BEFORE | BPF_F_AFTER;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_ID,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER | BPF_F_ID,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_ID,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_LINK,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_LINK,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_AFTER,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_ID,\n\t\t.relative_id = pid2,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_ID,\n\t\t.relative_id = 42,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_LINK,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, 0, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER | BPF_F_LINK,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optl);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER | BPF_F_LINK,\n\t\t.relative_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_LINK | BPF_F_ID,\n\t\t.relative_id = ~0,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_LINK | BPF_F_ID,\n\t\t.relative_id = lid1,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_ID,\n\t\t.relative_id = pid1,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_ERR_PTR(link, \"link_attach_should_fail\")) {\n\t\tbpf_link__destroy(link);\n\t\tgoto cleanup;\n\t}\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE | BPF_F_LINK | BPF_F_ID,\n\t\t.relative_id = lid1,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count(target, 2);\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_invalid(void)\n{\n\ttest_tc_links_invalid_target(BPF_TCX_INGRESS);\n\ttest_tc_links_invalid_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_prepend_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[5], link_ids[5];\n\t__u32 pid1, pid2, pid3, pid4;\n\t__u32 lid1, lid2, lid3, lid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid2, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid1, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tlid3 = id_from_link_fd(bpf_link__fd(skel->links.tc3));\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tlid4 = id_from_link_fd(bpf_link__fd(skel->links.tc4));\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid4, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid4, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid3, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], pid2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], lid2, \"link_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], pid1, \"prog_ids[3]\");\n\tASSERT_EQ(optq.link_ids[3], lid1, \"link_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(optq.link_ids[4], 0, \"link_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_prepend(void)\n{\n\ttest_tc_links_prepend_target(BPF_TCX_INGRESS);\n\ttest_tc_links_prepend_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_append_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 prog_ids[5], link_ids[5];\n\t__u32 pid1, pid2, pid3, pid4;\n\t__u32 lid1, lid2, lid3, lid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlid1 = id_from_link_fd(bpf_link__fd(skel->links.tc1));\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\toptq.link_ids = link_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], 0, \"link_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tlid3 = id_from_link_fd(bpf_link__fd(skel->links.tc3));\n\n\tLIBBPF_OPTS_RESET(optl,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tlid4 = id_from_link_fd(bpf_link__fd(skel->links.tc4));\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.link_ids[0], lid1, \"link_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], pid3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.link_ids[2], lid3, \"link_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], pid4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.link_ids[3], lid4, \"link_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(optq.link_ids[4], 0, \"link_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_append(void)\n{\n\ttest_tc_links_append_target(BPF_TCX_INGRESS);\n\ttest_tc_links_append_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_dev_cleanup_target(int target)\n{\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 pid1, pid2, pid3, pid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err, ifindex;\n\n\tASSERT_OK(system(\"ip link add dev tcx_opts1 type veth peer name tcx_opts2\"), \"add veth\");\n\tifindex = if_nametoindex(\"tcx_opts1\");\n\tASSERT_NEQ(ifindex, 0, \"non_zero_ifindex\");\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 2);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 3);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 4);\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc1)), 0, \"tc1_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc2)), 0, \"tc2_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc3)), 0, \"tc3_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc4)), 0, \"tc4_ifindex\");\n\n\ttest_tc_link__destroy(skel);\n\treturn;\ncleanup:\n\ttest_tc_link__destroy(skel);\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n}\n\nvoid serial_test_tc_links_dev_cleanup(void)\n{\n\ttest_tc_links_dev_cleanup_target(BPF_TCX_INGRESS);\n\ttest_tc_links_dev_cleanup_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_chain_mixed(int target)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = loopback);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\t__u32 pid1, pid2, pid3;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc5, target),\n\t\t  0, \"tc5_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc6, target),\n\t\t  0, \"tc6_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc5));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc6));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\terr = bpf_tc_hook_create(&tc_hook);\n\terr = err == -EEXIST ? 0 : err;\n\tif (!ASSERT_OK(err, \"bpf_tc_hook_create\"))\n\t\tgoto cleanup;\n\n\ttc_opts.prog_fd = bpf_program__fd(skel->progs.tc5);\n\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\tgoto cleanup;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc6, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc6 = link;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, false, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, true, \"seen_tc6\");\n\n\terr = bpf_link__update_program(skel->links.tc6, skel->progs.tc4);\n\tif (!ASSERT_OK(err, \"link_update\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, true, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, false, \"seen_tc6\");\n\n\terr = bpf_link__detach(skel->links.tc6);\n\tif (!ASSERT_OK(err, \"prog_detach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 0);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, true, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, false, \"seen_tc6\");\n\ncleanup:\n\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\terr = bpf_tc_detach(&tc_hook, &tc_opts);\n\tASSERT_OK(err, \"bpf_tc_detach\");\n\n\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\tbpf_tc_hook_destroy(&tc_hook);\n\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_links_chain_mixed(void)\n{\n\ttest_tc_chain_mixed(BPF_TCX_INGRESS);\n\ttest_tc_chain_mixed(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_links_ingress(int target, bool chain_tc_old,\n\t\t\t\t  bool tcx_teardown_first)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts,\n\t\t.handle\t\t= 1,\n\t\t.priority\t= 1,\n\t);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook,\n\t\t.ifindex\t= loopback,\n\t\t.attach_point\t= BPF_TC_CUSTOM,\n\t\t.parent\t\t= TC_H_INGRESS,\n\t);\n\tbool hook_created = false, tc_attached = false;\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, pid3;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tif (chain_tc_old) {\n\t\tASSERT_OK(system(\"tc qdisc add dev lo ingress\"), \"add_ingress\");\n\t\thook_created = true;\n\n\t\ttc_opts.prog_fd = bpf_program__fd(skel->progs.tc3);\n\t\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\t\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\t\tgoto cleanup;\n\t\ttc_attached = true;\n\t}\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count(target, 2);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\n\n\terr = bpf_link__detach(skel->links.tc2);\n\tif (!ASSERT_OK(err, \"prog_detach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\ncleanup:\n\tif (tc_attached) {\n\t\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\t\terr = bpf_tc_detach(&tc_hook, &tc_opts);\n\t\tASSERT_OK(err, \"bpf_tc_detach\");\n\t}\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\tassert_mprog_count(target, 1);\n\tif (hook_created && tcx_teardown_first)\n\t\tASSERT_OK(system(\"tc qdisc del dev lo ingress\"), \"del_ingress\");\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\ttest_tc_link__destroy(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\tif (hook_created && !tcx_teardown_first)\n\t\tASSERT_OK(system(\"tc qdisc del dev lo ingress\"), \"del_ingress\");\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_links_ingress(void)\n{\n\ttest_tc_links_ingress(BPF_TCX_INGRESS, true, true);\n\ttest_tc_links_ingress(BPF_TCX_INGRESS, true, false);\n\ttest_tc_links_ingress(BPF_TCX_INGRESS, false, false);\n}\n\nstatic void test_tc_links_dev_mixed(int target)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, pid3, pid4;\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err, ifindex;\n\n\tASSERT_OK(system(\"ip link add dev tcx_opts1 type veth peer name tcx_opts2\"), \"add veth\");\n\tifindex = if_nametoindex(\"tcx_opts1\");\n\tASSERT_NEQ(ifindex, 0, \"non_zero_ifindex\");\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc1, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc1 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 2);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc3, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc3 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 3);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, ifindex, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup;\n\n\tskel->links.tc4 = link;\n\n\tassert_mprog_count_ifindex(ifindex, target, 4);\n\n\ttc_hook.ifindex = ifindex;\n\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\n\terr = bpf_tc_hook_create(&tc_hook);\n\terr = err == -EEXIST ? 0 : err;\n\tif (!ASSERT_OK(err, \"bpf_tc_hook_create\"))\n\t\tgoto cleanup;\n\n\ttc_opts.prog_fd = bpf_program__fd(skel->progs.tc5);\n\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\tgoto cleanup;\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc1)), 0, \"tc1_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc2)), 0, \"tc2_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc3)), 0, \"tc3_ifindex\");\n\tASSERT_EQ(ifindex_from_link_fd(bpf_link__fd(skel->links.tc4)), 0, \"tc4_ifindex\");\n\n\ttest_tc_link__destroy(skel);\n\treturn;\ncleanup:\n\ttest_tc_link__destroy(skel);\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n}\n\nvoid serial_test_tc_links_dev_mixed(void)\n{\n\ttest_tc_links_dev_mixed(BPF_TCX_INGRESS);\n\ttest_tc_links_dev_mixed(BPF_TCX_EGRESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}