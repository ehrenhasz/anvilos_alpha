{
  "module_name": "usdt.c",
  "hash_id": "d1a4f866ce05358825b92762fb2b99004cb25e68203173400f570c3d5d99f963",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/usdt.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n\n#define _SDT_HAS_SEMAPHORES 1\n#include \"../sdt.h\"\n\n#include \"test_usdt.skel.h\"\n#include \"test_urandom_usdt.skel.h\"\n\nint lets_test_this(int);\n\nstatic volatile int idx = 2;\nstatic volatile __u64 bla = 0xFEDCBA9876543210ULL;\nstatic volatile short nums[] = {-1, -2, -3, -4};\n\nstatic volatile struct {\n\tint x;\n\tsigned char y;\n} t1 = { 1, -127 };\n\n#define SEC(name) __attribute__((section(name), used))\n\nunsigned short test_usdt0_semaphore SEC(\".probes\");\nunsigned short test_usdt3_semaphore SEC(\".probes\");\nunsigned short test_usdt12_semaphore SEC(\".probes\");\n\nstatic void __always_inline trigger_func(int x) {\n\tlong y = 42;\n\n\tif (test_usdt0_semaphore)\n\t\tSTAP_PROBE(test, usdt0);\n\tif (test_usdt3_semaphore)\n\t\tSTAP_PROBE3(test, usdt3, x, y, &bla);\n\tif (test_usdt12_semaphore) {\n\t\tSTAP_PROBE12(test, usdt12,\n\t\t\t     x, x + 1, y, x + y, 5,\n\t\t\t     y / 7, bla, &bla, -9, nums[x],\n\t\t\t     nums[idx], t1.y);\n\t}\n}\n\nstatic void subtest_basic_usdt(void)\n{\n\tLIBBPF_OPTS(bpf_usdt_opts, opts);\n\tstruct test_usdt *skel;\n\tstruct test_usdt__bss *bss;\n\tint err;\n\n\tskel = test_usdt__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbss = skel->bss;\n\tbss->my_pid = getpid();\n\n\terr = test_usdt__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto cleanup;\n\n\t \n\topts.usdt_cookie = 0xcafedeadbeeffeed;\n\tskel->links.usdt0 = bpf_program__attach_usdt(skel->progs.usdt0,\n\t\t\t\t\t\t     0  , \"/proc/self/exe\",\n\t\t\t\t\t\t     \"test\", \"usdt0\", &opts);\n\tif (!ASSERT_OK_PTR(skel->links.usdt0, \"usdt0_link\"))\n\t\tgoto cleanup;\n\n\ttrigger_func(1);\n\n\tASSERT_EQ(bss->usdt0_called, 1, \"usdt0_called\");\n\tASSERT_EQ(bss->usdt3_called, 1, \"usdt3_called\");\n\tASSERT_EQ(bss->usdt12_called, 1, \"usdt12_called\");\n\n\tASSERT_EQ(bss->usdt0_cookie, 0xcafedeadbeeffeed, \"usdt0_cookie\");\n\tASSERT_EQ(bss->usdt0_arg_cnt, 0, \"usdt0_arg_cnt\");\n\tASSERT_EQ(bss->usdt0_arg_ret, -ENOENT, \"usdt0_arg_ret\");\n\n\t \n\tASSERT_EQ(bss->usdt3_cookie, 0, \"usdt3_cookie\");\n\tASSERT_EQ(bss->usdt3_arg_cnt, 3, \"usdt3_arg_cnt\");\n\n\tASSERT_EQ(bss->usdt3_arg_rets[0], 0, \"usdt3_arg1_ret\");\n\tASSERT_EQ(bss->usdt3_arg_rets[1], 0, \"usdt3_arg2_ret\");\n\tASSERT_EQ(bss->usdt3_arg_rets[2], 0, \"usdt3_arg3_ret\");\n\tASSERT_EQ(bss->usdt3_args[0], 1, \"usdt3_arg1\");\n\tASSERT_EQ(bss->usdt3_args[1], 42, \"usdt3_arg2\");\n\tASSERT_EQ(bss->usdt3_args[2], (uintptr_t)&bla, \"usdt3_arg3\");\n\n\t \n\tASSERT_EQ(bss->usdt12_cookie, 0, \"usdt12_cookie\");\n\tASSERT_EQ(bss->usdt12_arg_cnt, 12, \"usdt12_arg_cnt\");\n\n\tASSERT_EQ(bss->usdt12_args[0], 1, \"usdt12_arg1\");\n\tASSERT_EQ(bss->usdt12_args[1], 1 + 1, \"usdt12_arg2\");\n\tASSERT_EQ(bss->usdt12_args[2], 42, \"usdt12_arg3\");\n\tASSERT_EQ(bss->usdt12_args[3], 42 + 1, \"usdt12_arg4\");\n\tASSERT_EQ(bss->usdt12_args[4], 5, \"usdt12_arg5\");\n\tASSERT_EQ(bss->usdt12_args[5], 42 / 7, \"usdt12_arg6\");\n\tASSERT_EQ(bss->usdt12_args[6], bla, \"usdt12_arg7\");\n\tASSERT_EQ(bss->usdt12_args[7], (uintptr_t)&bla, \"usdt12_arg8\");\n\tASSERT_EQ(bss->usdt12_args[8], -9, \"usdt12_arg9\");\n\tASSERT_EQ(bss->usdt12_args[9], nums[1], \"usdt12_arg10\");\n\tASSERT_EQ(bss->usdt12_args[10], nums[idx], \"usdt12_arg11\");\n\tASSERT_EQ(bss->usdt12_args[11], t1.y, \"usdt12_arg12\");\n\n\t \n\ttrigger_func(2);\n\n\tASSERT_EQ(bss->usdt0_called, 2, \"usdt0_called\");\n\tASSERT_EQ(bss->usdt3_called, 2, \"usdt3_called\");\n\tASSERT_EQ(bss->usdt12_called, 2, \"usdt12_called\");\n\n\t \n\tASSERT_EQ(bss->usdt3_args[0], 2, \"usdt3_arg1\");\n\n\tASSERT_EQ(bss->usdt12_args[0], 2, \"usdt12_arg1\");\n\tASSERT_EQ(bss->usdt12_args[1], 2 + 1, \"usdt12_arg2\");\n\tASSERT_EQ(bss->usdt12_args[3], 42 + 2, \"usdt12_arg4\");\n\tASSERT_EQ(bss->usdt12_args[9], nums[2], \"usdt12_arg10\");\n\n\t \n\tbpf_link__destroy(skel->links.usdt3);\n\n\topts.usdt_cookie = 0xBADC00C51E;\n\tskel->links.usdt3 = bpf_program__attach_usdt(skel->progs.usdt3, -1  ,\n\t\t\t\t\t\t     \"/proc/self/exe\", \"test\", \"usdt3\", &opts);\n\tif (!ASSERT_OK_PTR(skel->links.usdt3, \"usdt3_reattach\"))\n\t\tgoto cleanup;\n\n\ttrigger_func(3);\n\n\tASSERT_EQ(bss->usdt3_called, 3, \"usdt3_called\");\n\t \n\tASSERT_EQ(bss->usdt3_cookie, 0xBADC00C51E, \"usdt3_cookie\");\n\tASSERT_EQ(bss->usdt3_arg_cnt, 3, \"usdt3_arg_cnt\");\n\n\tASSERT_EQ(bss->usdt3_arg_rets[0], 0, \"usdt3_arg1_ret\");\n\tASSERT_EQ(bss->usdt3_arg_rets[1], 0, \"usdt3_arg2_ret\");\n\tASSERT_EQ(bss->usdt3_arg_rets[2], 0, \"usdt3_arg3_ret\");\n\tASSERT_EQ(bss->usdt3_args[0], 3, \"usdt3_arg1\");\n\tASSERT_EQ(bss->usdt3_args[1], 42, \"usdt3_arg2\");\n\tASSERT_EQ(bss->usdt3_args[2], (uintptr_t)&bla, \"usdt3_arg3\");\n\ncleanup:\n\ttest_usdt__destroy(skel);\n}\n\nunsigned short test_usdt_100_semaphore SEC(\".probes\");\nunsigned short test_usdt_300_semaphore SEC(\".probes\");\nunsigned short test_usdt_400_semaphore SEC(\".probes\");\n\n#define R10(F, X)  F(X+0); F(X+1);F(X+2); F(X+3); F(X+4); \\\n\t\t   F(X+5); F(X+6); F(X+7); F(X+8); F(X+9);\n#define R100(F, X) R10(F,X+ 0);R10(F,X+10);R10(F,X+20);R10(F,X+30);R10(F,X+40); \\\n\t\t   R10(F,X+50);R10(F,X+60);R10(F,X+70);R10(F,X+80);R10(F,X+90);\n\n \nstatic void __always_inline f100(int x)\n{\n\tSTAP_PROBE1(test, usdt_100, x);\n}\n\n__weak void trigger_100_usdts(void)\n{\n\tR100(f100, 0);\n}\n\n \nstatic void __always_inline f300(int x)\n{\n\tSTAP_PROBE1(test, usdt_300, x);\n}\n\n__weak void trigger_300_usdts(void)\n{\n\tR100(f300, 0);\n\tR100(f300, 100);\n\tR100(f300, 200);\n}\n\nstatic void __always_inline f400(int x __attribute__((unused)))\n{\n\tSTAP_PROBE1(test, usdt_400, 400);\n}\n\n \n__weak void trigger_400_usdts(void)\n{\n\tR100(f400, 0);\n\tR100(f400, 100);\n\tR100(f400, 200);\n\tR100(f400, 300);\n}\n\nstatic void subtest_multispec_usdt(void)\n{\n\tLIBBPF_OPTS(bpf_usdt_opts, opts);\n\tstruct test_usdt *skel;\n\tstruct test_usdt__bss *bss;\n\tint err, i;\n\n\tskel = test_usdt__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tbss = skel->bss;\n\tbss->my_pid = getpid();\n\n\terr = test_usdt__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto cleanup;\n\n\t \n\ttrigger_100_usdts();\n\n\tASSERT_EQ(bss->usdt_100_called, 100, \"usdt_100_called\");\n\tASSERT_EQ(bss->usdt_100_sum, 99 * 100 / 2, \"usdt_100_sum\");\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tbpf_link__destroy(skel->links.usdt_100);\n\n\t\tskel->links.usdt_100 = bpf_program__attach_usdt(skel->progs.usdt_100, -1,\n\t\t\t\t\t\t\t        \"/proc/self/exe\",\n\t\t\t\t\t\t\t\t\"test\", \"usdt_100\", NULL);\n\t\tif (!ASSERT_OK_PTR(skel->links.usdt_100, \"usdt_100_reattach\"))\n\t\t\tgoto cleanup;\n\n\t\tbss->usdt_100_sum = 0;\n\t\ttrigger_100_usdts();\n\n\t\tASSERT_EQ(bss->usdt_100_called, (i + 1) * 100 + 100, \"usdt_100_called\");\n\t\tASSERT_EQ(bss->usdt_100_sum, 99 * 100 / 2, \"usdt_100_sum\");\n\t}\n\n\t \n\ttrigger_300_usdts();\n\n\t \n\tbpf_link__destroy(skel->links.usdt_100);\n\tskel->links.usdt_100 = bpf_program__attach_usdt(skel->progs.usdt_100, -1, \"/proc/self/exe\",\n\t\t\t\t\t\t\t\"test\", \"usdt_300\", NULL);\n\terr = -errno;\n\tif (!ASSERT_ERR_PTR(skel->links.usdt_100, \"usdt_300_bad_attach\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(err, -E2BIG, \"usdt_300_attach_err\");\n\n\t \n\tbss->usdt_100_called = 0;\n\tbss->usdt_100_sum = 0;\n\n\tf300(777);  \n\n\tASSERT_EQ(bss->usdt_100_called, 0, \"usdt_301_called\");\n\tASSERT_EQ(bss->usdt_100_sum, 0, \"usdt_301_sum\");\n\n\t \n\tskel->links.usdt_100 = bpf_program__attach_usdt(skel->progs.usdt_100, -1,\n\t\t\t\t\t\t\t\"/proc/self/exe\",\n\t\t\t\t\t\t\t\"test\", \"usdt_400\", NULL);\n\tif (!ASSERT_OK_PTR(skel->links.usdt_100, \"usdt_400_attach\"))\n\t\tgoto cleanup;\n\n\ttrigger_400_usdts();\n\n\tASSERT_EQ(bss->usdt_100_called, 400, \"usdt_400_called\");\n\tASSERT_EQ(bss->usdt_100_sum, 400 * 400, \"usdt_400_sum\");\n\ncleanup:\n\ttest_usdt__destroy(skel);\n}\n\nstatic FILE *urand_spawn(int *pid)\n{\n\tFILE *f;\n\n\t \n\tf = popen(\"./urandom_read 1 report-pid\", \"r\");\n\tif (!f)\n\t\treturn NULL;\n\n\tif (fscanf(f, \"%d\", pid) != 1) {\n\t\tpclose(f);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}\n\nstatic int urand_trigger(FILE **urand_pipe)\n{\n\tint exit_code;\n\n\t \n\texit_code = pclose(*urand_pipe);\n\t*urand_pipe = NULL;\n\n\treturn exit_code;\n}\n\nstatic void subtest_urandom_usdt(bool auto_attach)\n{\n\tstruct test_urandom_usdt *skel;\n\tstruct test_urandom_usdt__bss *bss;\n\tstruct bpf_link *l;\n\tFILE *urand_pipe = NULL;\n\tint err, urand_pid = 0;\n\n\tskel = test_urandom_usdt__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\turand_pipe = urand_spawn(&urand_pid);\n\tif (!ASSERT_OK_PTR(urand_pipe, \"urand_spawn\"))\n\t\tgoto cleanup;\n\n\tbss = skel->bss;\n\tbss->urand_pid = urand_pid;\n\n\tif (auto_attach) {\n\t\terr = test_urandom_usdt__attach(skel);\n\t\tif (!ASSERT_OK(err, \"skel_auto_attach\"))\n\t\t\tgoto cleanup;\n\t} else {\n\t\tl = bpf_program__attach_usdt(skel->progs.urand_read_without_sema,\n\t\t\t\t\t     urand_pid, \"./urandom_read\",\n\t\t\t\t\t     \"urand\", \"read_without_sema\", NULL);\n\t\tif (!ASSERT_OK_PTR(l, \"urand_without_sema_attach\"))\n\t\t\tgoto cleanup;\n\t\tskel->links.urand_read_without_sema = l;\n\n\t\tl = bpf_program__attach_usdt(skel->progs.urand_read_with_sema,\n\t\t\t\t\t     urand_pid, \"./urandom_read\",\n\t\t\t\t\t     \"urand\", \"read_with_sema\", NULL);\n\t\tif (!ASSERT_OK_PTR(l, \"urand_with_sema_attach\"))\n\t\t\tgoto cleanup;\n\t\tskel->links.urand_read_with_sema = l;\n\n\t\tl = bpf_program__attach_usdt(skel->progs.urandlib_read_without_sema,\n\t\t\t\t\t     urand_pid, \"./liburandom_read.so\",\n\t\t\t\t\t     \"urandlib\", \"read_without_sema\", NULL);\n\t\tif (!ASSERT_OK_PTR(l, \"urandlib_without_sema_attach\"))\n\t\t\tgoto cleanup;\n\t\tskel->links.urandlib_read_without_sema = l;\n\n\t\tl = bpf_program__attach_usdt(skel->progs.urandlib_read_with_sema,\n\t\t\t\t\t     urand_pid, \"./liburandom_read.so\",\n\t\t\t\t\t     \"urandlib\", \"read_with_sema\", NULL);\n\t\tif (!ASSERT_OK_PTR(l, \"urandlib_with_sema_attach\"))\n\t\t\tgoto cleanup;\n\t\tskel->links.urandlib_read_with_sema = l;\n\n\t}\n\n\t \n\tASSERT_OK(urand_trigger(&urand_pipe), \"urand_exit_code\");\n\n\tASSERT_EQ(bss->urand_read_without_sema_call_cnt, 1, \"urand_wo_sema_cnt\");\n\tASSERT_EQ(bss->urand_read_without_sema_buf_sz_sum, 256, \"urand_wo_sema_sum\");\n\n\tASSERT_EQ(bss->urand_read_with_sema_call_cnt, 1, \"urand_w_sema_cnt\");\n\tASSERT_EQ(bss->urand_read_with_sema_buf_sz_sum, 256, \"urand_w_sema_sum\");\n\n\tASSERT_EQ(bss->urandlib_read_without_sema_call_cnt, 1, \"urandlib_wo_sema_cnt\");\n\tASSERT_EQ(bss->urandlib_read_without_sema_buf_sz_sum, 256, \"urandlib_wo_sema_sum\");\n\n\tASSERT_EQ(bss->urandlib_read_with_sema_call_cnt, 1, \"urandlib_w_sema_cnt\");\n\tASSERT_EQ(bss->urandlib_read_with_sema_buf_sz_sum, 256, \"urandlib_w_sema_sum\");\n\ncleanup:\n\tif (urand_pipe)\n\t\tpclose(urand_pipe);\n\ttest_urandom_usdt__destroy(skel);\n}\n\nvoid test_usdt(void)\n{\n\tif (test__start_subtest(\"basic\"))\n\t\tsubtest_basic_usdt();\n\tif (test__start_subtest(\"multispec\"))\n\t\tsubtest_multispec_usdt();\n\tif (test__start_subtest(\"urand_auto_attach\"))\n\t\tsubtest_urandom_usdt(true  );\n\tif (test__start_subtest(\"urand_pid_attach\"))\n\t\tsubtest_urandom_usdt(false  );\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}