{
  "module_name": "lwt_helpers.h",
  "hash_id": "7d5b4143917395c30101a24c2de44049050f25dcfc65292f51fa780f50729330",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/lwt_helpers.h",
  "human_readable_source": " \n\n#ifndef __LWT_HELPERS_H\n#define __LWT_HELPERS_H\n\n#include <time.h>\n#include <net/if.h>\n#include <linux/if_tun.h>\n#include <linux/icmp.h>\n\n#include \"test_progs.h\"\n\n#define log_err(MSG, ...) \\\n\tfprintf(stderr, \"(%s:%d: errno: %s) \" MSG \"\\n\", \\\n\t\t__FILE__, __LINE__, strerror(errno), ##__VA_ARGS__)\n\n#define RUN_TEST(name)                                                        \\\n\t({                                                                    \\\n\t\tif (test__start_subtest(#name))                               \\\n\t\t\tif (ASSERT_OK(netns_create(), \"netns_create\")) {      \\\n\t\t\t\tstruct nstoken *token = open_netns(NETNS);    \\\n\t\t\t\tif (ASSERT_OK_PTR(token, \"setns\")) {          \\\n\t\t\t\t\ttest_ ## name();                      \\\n\t\t\t\t\tclose_netns(token);                   \\\n\t\t\t\t}                                             \\\n\t\t\t\tnetns_delete();                               \\\n\t\t\t}                                                     \\\n\t})\n\n#define NETNS \"ns_lwt\"\n\nstatic inline int netns_create(void)\n{\n\treturn system(\"ip netns add \" NETNS);\n}\n\nstatic inline int netns_delete(void)\n{\n\treturn system(\"ip netns del \" NETNS \">/dev/null 2>&1\");\n}\n\nstatic int open_tuntap(const char *dev_name, bool need_mac)\n{\n\tint err = 0;\n\tstruct ifreq ifr;\n\tint fd = open(\"/dev/net/tun\", O_RDWR);\n\n\tif (!ASSERT_GT(fd, 0, \"open(/dev/net/tun)\"))\n\t\treturn -1;\n\n\tifr.ifr_flags = IFF_NO_PI | (need_mac ? IFF_TAP : IFF_TUN);\n\tmemcpy(ifr.ifr_name, dev_name, IFNAMSIZ);\n\n\terr = ioctl(fd, TUNSETIFF, &ifr);\n\tif (!ASSERT_OK(err, \"ioctl(TUNSETIFF)\")) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\terr = fcntl(fd, F_SETFL, O_NONBLOCK);\n\tif (!ASSERT_OK(err, \"fcntl(O_NONBLOCK)\")) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\n#define ICMP_PAYLOAD_SIZE     100\n\n \nstatic int __expect_icmp_ipv4(char *buf, ssize_t len)\n{\n\tstruct iphdr *ip = (struct iphdr *)buf;\n\tstruct icmphdr *icmp = (struct icmphdr *)(ip + 1);\n\tssize_t min_header_len = sizeof(*ip) + sizeof(*icmp);\n\n\tif (len < min_header_len)\n\t\treturn -1;\n\n\tif (ip->protocol != IPPROTO_ICMP)\n\t\treturn -1;\n\n\tif (icmp->type != ICMP_ECHO)\n\t\treturn -1;\n\n\treturn len == ICMP_PAYLOAD_SIZE + min_header_len;\n}\n\ntypedef int (*filter_t) (char *, ssize_t);\n\n \nstatic int wait_for_packet(int fd, filter_t filter, struct timeval *timeout)\n{\n\tchar buf[4096];\n\tint max_retry = 5;  \n\tfd_set fds;\n\n\tFD_ZERO(&fds);\n\twhile (max_retry--) {\n\t\t \n\t\tstruct timeval copied_timeout = *timeout;\n\t\tssize_t ret = -1;\n\n\t\tFD_SET(fd, &fds);\n\n\t\tret = select(1 + fd, &fds, NULL, NULL, &copied_timeout);\n\t\tif (ret <= 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\telse if (errno == EAGAIN || ret == 0)\n\t\t\t\treturn 0;\n\n\t\t\tlog_err(\"select failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = read(fd, buf, sizeof(buf));\n\n\t\tif (ret <= 0) {\n\t\t\tlog_err(\"read(dev): %ld\", ret);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (filter && filter(buf, ret) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}