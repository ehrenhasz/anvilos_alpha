{
  "module_name": "get_stackid_cannot_attach.c",
  "hash_id": "92a57b00a2605af7701c72056688d297166b2361ad79b7a17e414cd3c82cfb8f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/get_stackid_cannot_attach.c",
  "human_readable_source": "\n\n#include <test_progs.h>\n#include \"test_stacktrace_build_id.skel.h\"\n\nvoid test_get_stackid_cannot_attach(void)\n{\n\tstruct perf_event_attr attr = {\n\t\t \n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t\t.precise_ip = 1,\n\t\t.sample_type = PERF_SAMPLE_IP | PERF_SAMPLE_BRANCH_STACK,\n\t\t.branch_sample_type = PERF_SAMPLE_BRANCH_USER |\n\t\t\tPERF_SAMPLE_BRANCH_NO_FLAGS |\n\t\t\tPERF_SAMPLE_BRANCH_NO_CYCLES |\n\t\t\tPERF_SAMPLE_BRANCH_CALL_STACK,\n\t\t.sample_period = 5000,\n\t\t.size = sizeof(struct perf_event_attr),\n\t};\n\tstruct test_stacktrace_build_id *skel;\n\t__u32 duration = 0;\n\tint pmu_fd, err;\n\n\tskel = test_stacktrace_build_id__open();\n\tif (CHECK(!skel, \"skel_open\", \"skeleton open failed\\n\"))\n\t\treturn;\n\n\t \n\tbpf_program__set_type(skel->progs.oncpu, BPF_PROG_TYPE_PERF_EVENT);\n\n\terr = test_stacktrace_build_id__load(skel);\n\tif (CHECK(err, \"skel_load\", \"skeleton load failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t 0  , -1  ,\n\t\t\t 0  );\n\tif (pmu_fd < 0 && (errno == ENOENT || errno == EOPNOTSUPP)) {\n\t\tprintf(\"%s:SKIP:cannot open PERF_COUNT_HW_CPU_CYCLES with precise_ip > 0\\n\",\n\t\t       __func__);\n\t\ttest__skip();\n\t\tgoto cleanup;\n\t}\n\tif (CHECK(pmu_fd < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t  pmu_fd, errno))\n\t\tgoto cleanup;\n\n\tskel->links.oncpu = bpf_program__attach_perf_event(skel->progs.oncpu,\n\t\t\t\t\t\t\t   pmu_fd);\n\tASSERT_ERR_PTR(skel->links.oncpu, \"attach_perf_event_no_callchain\");\n\tclose(pmu_fd);\n\n\t \n\tattr.sample_type |= PERF_SAMPLE_CALLCHAIN;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t 0  , -1  ,\n\t\t\t 0  );\n\n\tif (CHECK(pmu_fd < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t  pmu_fd, errno))\n\t\tgoto cleanup;\n\n\tskel->links.oncpu = bpf_program__attach_perf_event(skel->progs.oncpu,\n\t\t\t\t\t\t\t   pmu_fd);\n\tASSERT_OK_PTR(skel->links.oncpu, \"attach_perf_event_callchain\");\n\tbpf_link__destroy(skel->links.oncpu);\n\tclose(pmu_fd);\n\n\t \n\tattr.exclude_callchain_kernel = 1;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t 0  , -1  ,\n\t\t\t 0  );\n\n\tif (CHECK(pmu_fd < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t  pmu_fd, errno))\n\t\tgoto cleanup;\n\n\tskel->links.oncpu = bpf_program__attach_perf_event(skel->progs.oncpu,\n\t\t\t\t\t\t\t   pmu_fd);\n\tASSERT_ERR_PTR(skel->links.oncpu, \"attach_perf_event_exclude_callchain_kernel\");\n\tclose(pmu_fd);\n\ncleanup:\n\ttest_stacktrace_build_id__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}