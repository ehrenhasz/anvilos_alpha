{
  "module_name": "sock_destroy.c",
  "hash_id": "f867ede21606cbad1bf66d4ed1b560b7db41f9ec52a5f5f95a744242d1e70e0c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sock_destroy.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <bpf/bpf_endian.h>\n\n#include \"sock_destroy_prog.skel.h\"\n#include \"sock_destroy_prog_fail.skel.h\"\n#include \"network_helpers.h\"\n\n#define TEST_NS \"sock_destroy_netns\"\n\nstatic void start_iter_sockets(struct bpf_program *prog)\n{\n\tstruct bpf_link *link;\n\tchar buf[50] = {};\n\tint iter_fd, len;\n\n\tlink = bpf_program__attach_iter(prog, NULL);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tASSERT_GE(len, 0, \"read\");\n\n\tclose(iter_fd);\n\nfree_link:\n\tbpf_link__destroy(link);\n}\n\nstatic void test_tcp_client(struct sock_destroy_prog *skel)\n{\n\tint serv = -1, clien = -1, accept_serv = -1, n;\n\n\tserv = start_server(AF_INET6, SOCK_STREAM, NULL, 0, 0);\n\tif (!ASSERT_GE(serv, 0, \"start_server\"))\n\t\tgoto cleanup;\n\n\tclien = connect_to_fd(serv, 0);\n\tif (!ASSERT_GE(clien, 0, \"connect_to_fd\"))\n\t\tgoto cleanup;\n\n\taccept_serv = accept(serv, NULL, NULL);\n\tif (!ASSERT_GE(accept_serv, 0, \"serv accept\"))\n\t\tgoto cleanup;\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_EQ(n, 1, \"client send\"))\n\t\tgoto cleanup;\n\n\t \n\tstart_iter_sockets(skel->progs.iter_tcp6_client);\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_LT(n, 0, \"client_send on destroyed socket\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(errno, ECONNABORTED, \"error code on destroyed socket\");\n\ncleanup:\n\tif (clien != -1)\n\t\tclose(clien);\n\tif (accept_serv != -1)\n\t\tclose(accept_serv);\n\tif (serv != -1)\n\t\tclose(serv);\n}\n\nstatic void test_tcp_server(struct sock_destroy_prog *skel)\n{\n\tint serv = -1, clien = -1, accept_serv = -1, n, serv_port;\n\n\tserv = start_server(AF_INET6, SOCK_STREAM, NULL, 0, 0);\n\tif (!ASSERT_GE(serv, 0, \"start_server\"))\n\t\tgoto cleanup;\n\tserv_port = get_socket_local_port(serv);\n\tif (!ASSERT_GE(serv_port, 0, \"get_sock_local_port\"))\n\t\tgoto cleanup;\n\tskel->bss->serv_port = (__be16) serv_port;\n\n\tclien = connect_to_fd(serv, 0);\n\tif (!ASSERT_GE(clien, 0, \"connect_to_fd\"))\n\t\tgoto cleanup;\n\n\taccept_serv = accept(serv, NULL, NULL);\n\tif (!ASSERT_GE(accept_serv, 0, \"serv accept\"))\n\t\tgoto cleanup;\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_EQ(n, 1, \"client send\"))\n\t\tgoto cleanup;\n\n\t \n\tstart_iter_sockets(skel->progs.iter_tcp6_server);\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_LT(n, 0, \"client_send on destroyed socket\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(errno, ECONNRESET, \"error code on destroyed socket\");\n\ncleanup:\n\tif (clien != -1)\n\t\tclose(clien);\n\tif (accept_serv != -1)\n\t\tclose(accept_serv);\n\tif (serv != -1)\n\t\tclose(serv);\n}\n\nstatic void test_udp_client(struct sock_destroy_prog *skel)\n{\n\tint serv = -1, clien = -1, n = 0;\n\n\tserv = start_server(AF_INET6, SOCK_DGRAM, NULL, 0, 0);\n\tif (!ASSERT_GE(serv, 0, \"start_server\"))\n\t\tgoto cleanup;\n\n\tclien = connect_to_fd(serv, 0);\n\tif (!ASSERT_GE(clien, 0, \"connect_to_fd\"))\n\t\tgoto cleanup;\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_EQ(n, 1, \"client send\"))\n\t\tgoto cleanup;\n\n\t \n\tstart_iter_sockets(skel->progs.iter_udp6_client);\n\n\tn = send(clien, \"t\", 1, 0);\n\tif (!ASSERT_LT(n, 0, \"client_send on destroyed socket\"))\n\t\tgoto cleanup;\n\t \n\ncleanup:\n\tif (clien != -1)\n\t\tclose(clien);\n\tif (serv != -1)\n\t\tclose(serv);\n}\n\nstatic void test_udp_server(struct sock_destroy_prog *skel)\n{\n\tint *listen_fds = NULL, n, i, serv_port;\n\tunsigned int num_listens = 5;\n\tchar buf[1];\n\n\t \n\tlisten_fds = start_reuseport_server(AF_INET6, SOCK_DGRAM,\n\t\t\t\t\t    \"::1\", 0, 0, num_listens);\n\tif (!ASSERT_OK_PTR(listen_fds, \"start_reuseport_server\"))\n\t\tgoto cleanup;\n\tserv_port = get_socket_local_port(listen_fds[0]);\n\tif (!ASSERT_GE(serv_port, 0, \"get_sock_local_port\"))\n\t\tgoto cleanup;\n\tskel->bss->serv_port = (__be16) serv_port;\n\n\t \n\tstart_iter_sockets(skel->progs.iter_udp6_server);\n\n\tfor (i = 0; i < num_listens; ++i) {\n\t\tn = read(listen_fds[i], buf, sizeof(buf));\n\t\tif (!ASSERT_EQ(n, -1, \"read\") ||\n\t\t    !ASSERT_EQ(errno, ECONNABORTED, \"error code on destroyed socket\"))\n\t\t\tbreak;\n\t}\n\tASSERT_EQ(i, num_listens, \"server socket\");\n\ncleanup:\n\tfree_fds(listen_fds, num_listens);\n}\n\nvoid test_sock_destroy(void)\n{\n\tstruct sock_destroy_prog *skel;\n\tstruct nstoken *nstoken = NULL;\n\tint cgroup_fd;\n\n\tskel = sock_destroy_prog__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tcgroup_fd = test__join_cgroup(\"/sock_destroy\");\n\tif (!ASSERT_GE(cgroup_fd, 0, \"join_cgroup\"))\n\t\tgoto cleanup;\n\n\tskel->links.sock_connect = bpf_program__attach_cgroup(\n\t\tskel->progs.sock_connect, cgroup_fd);\n\tif (!ASSERT_OK_PTR(skel->links.sock_connect, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tSYS(cleanup, \"ip netns add %s\", TEST_NS);\n\tSYS(cleanup, \"ip -net %s link set dev lo up\", TEST_NS);\n\n\tnstoken = open_netns(TEST_NS);\n\tif (!ASSERT_OK_PTR(nstoken, \"open_netns\"))\n\t\tgoto cleanup;\n\n\tif (test__start_subtest(\"tcp_client\"))\n\t\ttest_tcp_client(skel);\n\tif (test__start_subtest(\"tcp_server\"))\n\t\ttest_tcp_server(skel);\n\tif (test__start_subtest(\"udp_client\"))\n\t\ttest_udp_client(skel);\n\tif (test__start_subtest(\"udp_server\"))\n\t\ttest_udp_server(skel);\n\n\tRUN_TESTS(sock_destroy_prog_fail);\n\ncleanup:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\tSYS_NOFAIL(\"ip netns del \" TEST_NS \" &> /dev/null\");\n\tif (cgroup_fd >= 0)\n\t\tclose(cgroup_fd);\n\tsock_destroy_prog__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}