{
  "module_name": "btf_endian.c",
  "hash_id": "87bbb2aaf4e41e5d2a23fd8e81ba8b546ee40ad4e178d56f4931501f9f9ca0cf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_endian.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <string.h>\n#include <byteswap.h>\n#include <test_progs.h>\n#include <bpf/btf.h>\n\nvoid test_btf_endian() {\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tenum btf_endianness endian = BTF_LITTLE_ENDIAN;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tenum btf_endianness endian = BTF_BIG_ENDIAN;\n#else\n#error \"Unrecognized __BYTE_ORDER__\"\n#endif\n\tenum btf_endianness swap_endian = 1 - endian;\n\tstruct btf *btf = NULL, *swap_btf = NULL;\n\tconst void *raw_data, *swap_raw_data;\n\tconst struct btf_type *t;\n\tconst struct btf_header *hdr;\n\t__u32 raw_sz, swap_raw_sz;\n\tint var_id;\n\n\t \n\tbtf = btf__parse_elf(\"btf_dump_test_case_syntax.bpf.o\", NULL);\n\tif (!ASSERT_OK_PTR(btf, \"parse_native_btf\"))\n\t\tgoto err_out;\n\n\tASSERT_EQ(btf__endianness(btf), endian, \"endian\");\n\tbtf__set_endianness(btf, swap_endian);\n\tASSERT_EQ(btf__endianness(btf), swap_endian, \"endian\");\n\n\t \n\traw_data = btf__raw_data(btf, &raw_sz);\n\tif (!ASSERT_OK_PTR(raw_data, \"raw_data_inverted\"))\n\t\tgoto err_out;\n\n\t \n\tswap_btf = btf__new(raw_data, raw_sz);\n\tif (!ASSERT_OK_PTR(swap_btf, \"parse_swap_btf\"))\n\t\tgoto err_out;\n\n\tASSERT_EQ(btf__endianness(swap_btf), swap_endian, \"endian\");\n\tASSERT_EQ(btf__type_cnt(swap_btf), btf__type_cnt(btf), \"nr_types\");\n\n\tswap_raw_data = btf__raw_data(swap_btf, &swap_raw_sz);\n\tif (!ASSERT_OK_PTR(swap_raw_data, \"swap_raw_data\"))\n\t\tgoto err_out;\n\n\t \n\tASSERT_OK(memcmp(raw_data, swap_raw_data, raw_sz), \"mem_identical\");\n\n\t \n\thdr = swap_raw_data;\n\tASSERT_EQ(bswap_16(hdr->magic), BTF_MAGIC, \"btf_magic_swapped\");\n\tASSERT_EQ(raw_sz, swap_raw_sz, \"raw_sizes\");\n\n\t \n\tbtf__set_endianness(swap_btf, endian);\n\tswap_raw_data = btf__raw_data(swap_btf, &swap_raw_sz);\n\tif (!ASSERT_OK_PTR(swap_raw_data, \"swap_raw_data\"))\n\t\tgoto err_out;\n\n\t \n\thdr = swap_raw_data;\n\tASSERT_EQ(hdr->magic, BTF_MAGIC, \"btf_magic_native\");\n\tASSERT_EQ(raw_sz, swap_raw_sz, \"raw_sizes\");\n\n\t \n\tvar_id = btf__add_var(btf, \"some_var\", BTF_VAR_GLOBAL_ALLOCATED, 1);\n\tASSERT_GT(var_id, 0, \"var_id\");\n\n\tbtf__free(swap_btf);\n\tswap_btf = NULL;\n\n\tbtf__set_endianness(btf, swap_endian);\n\traw_data = btf__raw_data(btf, &raw_sz);\n\tif (!ASSERT_OK_PTR(raw_data, \"raw_data_inverted\"))\n\t\tgoto err_out;\n\n\t \n\tswap_btf = btf__new(raw_data, raw_sz);\n\tif (!ASSERT_OK_PTR(swap_btf, \"parse_swap_btf\"))\n\t\tgoto err_out;\n\n\tASSERT_EQ(btf__endianness(swap_btf), swap_endian, \"endian\");\n\tASSERT_EQ(btf__type_cnt(swap_btf), btf__type_cnt(btf), \"nr_types\");\n\n\t \n\tt = btf__type_by_id(swap_btf, var_id);\n\tASSERT_STREQ(btf__str_by_offset(swap_btf, t->name_off), \"some_var\", \"var_name\");\n\tASSERT_EQ(btf_var(t)->linkage, BTF_VAR_GLOBAL_ALLOCATED, \"var_linkage\");\n\tASSERT_EQ(t->type, 1, \"var_type\");\n\nerr_out:\n\tbtf__free(btf);\n\tbtf__free(swap_btf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}