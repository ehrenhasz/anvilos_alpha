{
  "module_name": "map_ops.c",
  "hash_id": "17d727f066782302bc2e5e7c51d06421acd717685d9054f7eefde8f87cf0f0a6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/map_ops.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n\n#include \"test_map_ops.skel.h\"\n#include \"test_progs.h\"\n\nstatic void map_update(void)\n{\n\t(void)syscall(__NR_getpid);\n}\n\nstatic void map_delete(void)\n{\n\t(void)syscall(__NR_getppid);\n}\n\nstatic void map_push(void)\n{\n\t(void)syscall(__NR_getuid);\n}\n\nstatic void map_pop(void)\n{\n\t(void)syscall(__NR_geteuid);\n}\n\nstatic void map_peek(void)\n{\n\t(void)syscall(__NR_getgid);\n}\n\nstatic void map_for_each_pass(void)\n{\n\t(void)syscall(__NR_gettid);\n}\n\nstatic void map_for_each_fail(void)\n{\n\t(void)syscall(__NR_getpgid);\n}\n\nstatic int setup(struct test_map_ops **skel)\n{\n\tint err = 0;\n\n\tif (!skel)\n\t\treturn -1;\n\n\t*skel = test_map_ops__open();\n\tif (!ASSERT_OK_PTR(*skel, \"test_map_ops__open\"))\n\t\treturn -1;\n\n\t(*skel)->rodata->pid = getpid();\n\n\terr = test_map_ops__load(*skel);\n\tif (!ASSERT_OK(err, \"test_map_ops__load\"))\n\t\treturn err;\n\n\terr = test_map_ops__attach(*skel);\n\tif (!ASSERT_OK(err, \"test_map_ops__attach\"))\n\t\treturn err;\n\n\treturn err;\n}\n\nstatic void teardown(struct test_map_ops **skel)\n{\n\tif (skel && *skel)\n\t\ttest_map_ops__destroy(*skel);\n}\n\nstatic void map_ops_update_delete_subtest(void)\n{\n\tstruct test_map_ops *skel;\n\n\tif (setup(&skel))\n\t\tgoto teardown;\n\n\tmap_update();\n\tASSERT_OK(skel->bss->err, \"map_update_initial\");\n\n\tmap_update();\n\tASSERT_LT(skel->bss->err, 0, \"map_update_existing\");\n\tASSERT_EQ(skel->bss->err, -EEXIST, \"map_update_existing\");\n\n\tmap_delete();\n\tASSERT_OK(skel->bss->err, \"map_delete_existing\");\n\n\tmap_delete();\n\tASSERT_LT(skel->bss->err, 0, \"map_delete_non_existing\");\n\tASSERT_EQ(skel->bss->err, -ENOENT, \"map_delete_non_existing\");\n\nteardown:\n\tteardown(&skel);\n}\n\nstatic void map_ops_push_peek_pop_subtest(void)\n{\n\tstruct test_map_ops *skel;\n\n\tif (setup(&skel))\n\t\tgoto teardown;\n\n\tmap_push();\n\tASSERT_OK(skel->bss->err, \"map_push_initial\");\n\n\tmap_push();\n\tASSERT_LT(skel->bss->err, 0, \"map_push_when_full\");\n\tASSERT_EQ(skel->bss->err, -E2BIG, \"map_push_when_full\");\n\n\tmap_peek();\n\tASSERT_OK(skel->bss->err, \"map_peek\");\n\n\tmap_pop();\n\tASSERT_OK(skel->bss->err, \"map_pop\");\n\n\tmap_peek();\n\tASSERT_LT(skel->bss->err, 0, \"map_peek_when_empty\");\n\tASSERT_EQ(skel->bss->err, -ENOENT, \"map_peek_when_empty\");\n\n\tmap_pop();\n\tASSERT_LT(skel->bss->err, 0, \"map_pop_when_empty\");\n\tASSERT_EQ(skel->bss->err, -ENOENT, \"map_pop_when_empty\");\n\nteardown:\n\tteardown(&skel);\n}\n\nstatic void map_ops_for_each_subtest(void)\n{\n\tstruct test_map_ops *skel;\n\n\tif (setup(&skel))\n\t\tgoto teardown;\n\n\tmap_for_each_pass();\n\t \n\tASSERT_EQ(skel->bss->err, 1, \"map_for_each_no_flags\");\n\n\tmap_for_each_fail();\n\tASSERT_LT(skel->bss->err, 0, \"map_for_each_with_flags\");\n\tASSERT_EQ(skel->bss->err, -EINVAL, \"map_for_each_with_flags\");\n\nteardown:\n\tteardown(&skel);\n}\n\nvoid test_map_ops(void)\n{\n\tif (test__start_subtest(\"map_ops_update_delete\"))\n\t\tmap_ops_update_delete_subtest();\n\n\tif (test__start_subtest(\"map_ops_push_peek_pop\"))\n\t\tmap_ops_push_peek_pop_subtest();\n\n\tif (test__start_subtest(\"map_ops_for_each\"))\n\t\tmap_ops_for_each_subtest();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}