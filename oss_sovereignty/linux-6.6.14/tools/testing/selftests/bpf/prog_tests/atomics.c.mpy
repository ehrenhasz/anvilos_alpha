{
  "module_name": "atomics.c",
  "hash_id": "2fe49bc057371c1056477fd4ad63edb24ca936986b03a6937d4bd6a74b167b22",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/atomics.c",
  "human_readable_source": "\n\n#include <test_progs.h>\n\n#include \"atomics.lskel.h\"\n\nstatic void test_add(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.add.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->add64_value, 3, \"add64_value\");\n\tASSERT_EQ(skel->bss->add64_result, 1, \"add64_result\");\n\n\tASSERT_EQ(skel->data->add32_value, 3, \"add32_value\");\n\tASSERT_EQ(skel->bss->add32_result, 1, \"add32_result\");\n\n\tASSERT_EQ(skel->bss->add_stack_value_copy, 3, \"add_stack_value\");\n\tASSERT_EQ(skel->bss->add_stack_result, 1, \"add_stack_result\");\n\n\tASSERT_EQ(skel->data->add_noreturn_value, 3, \"add_noreturn_value\");\n}\n\nstatic void test_sub(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.sub.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->sub64_value, -1, \"sub64_value\");\n\tASSERT_EQ(skel->bss->sub64_result, 1, \"sub64_result\");\n\n\tASSERT_EQ(skel->data->sub32_value, -1, \"sub32_value\");\n\tASSERT_EQ(skel->bss->sub32_result, 1, \"sub32_result\");\n\n\tASSERT_EQ(skel->bss->sub_stack_value_copy, -1, \"sub_stack_value\");\n\tASSERT_EQ(skel->bss->sub_stack_result, 1, \"sub_stack_result\");\n\n\tASSERT_EQ(skel->data->sub_noreturn_value, -1, \"sub_noreturn_value\");\n}\n\nstatic void test_and(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.and.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->and64_value, 0x010ull << 32, \"and64_value\");\n\tASSERT_EQ(skel->bss->and64_result, 0x110ull << 32, \"and64_result\");\n\n\tASSERT_EQ(skel->data->and32_value, 0x010, \"and32_value\");\n\tASSERT_EQ(skel->bss->and32_result, 0x110, \"and32_result\");\n\n\tASSERT_EQ(skel->data->and_noreturn_value, 0x010ull << 32, \"and_noreturn_value\");\n}\n\nstatic void test_or(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.or.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->or64_value, 0x111ull << 32, \"or64_value\");\n\tASSERT_EQ(skel->bss->or64_result, 0x110ull << 32, \"or64_result\");\n\n\tASSERT_EQ(skel->data->or32_value, 0x111, \"or32_value\");\n\tASSERT_EQ(skel->bss->or32_result, 0x110, \"or32_result\");\n\n\tASSERT_EQ(skel->data->or_noreturn_value, 0x111ull << 32, \"or_noreturn_value\");\n}\n\nstatic void test_xor(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.xor.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->xor64_value, 0x101ull << 32, \"xor64_value\");\n\tASSERT_EQ(skel->bss->xor64_result, 0x110ull << 32, \"xor64_result\");\n\n\tASSERT_EQ(skel->data->xor32_value, 0x101, \"xor32_value\");\n\tASSERT_EQ(skel->bss->xor32_result, 0x110, \"xor32_result\");\n\n\tASSERT_EQ(skel->data->xor_noreturn_value, 0x101ull << 32, \"xor_nxoreturn_value\");\n}\n\nstatic void test_cmpxchg(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.cmpxchg.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->cmpxchg64_value, 2, \"cmpxchg64_value\");\n\tASSERT_EQ(skel->bss->cmpxchg64_result_fail, 1, \"cmpxchg_result_fail\");\n\tASSERT_EQ(skel->bss->cmpxchg64_result_succeed, 1, \"cmpxchg_result_succeed\");\n\n\tASSERT_EQ(skel->data->cmpxchg32_value, 2, \"lcmpxchg32_value\");\n\tASSERT_EQ(skel->bss->cmpxchg32_result_fail, 1, \"cmpxchg_result_fail\");\n\tASSERT_EQ(skel->bss->cmpxchg32_result_succeed, 1, \"cmpxchg_result_succeed\");\n}\n\nstatic void test_xchg(struct atomics_lskel *skel)\n{\n\tint err, prog_fd;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\t \n\tprog_fd = skel->progs.xchg.prog_fd;\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tif (!ASSERT_OK(err, \"test_run_opts err\"))\n\t\treturn;\n\tif (!ASSERT_OK(topts.retval, \"test_run_opts retval\"))\n\t\treturn;\n\n\tASSERT_EQ(skel->data->xchg64_value, 2, \"xchg64_value\");\n\tASSERT_EQ(skel->bss->xchg64_result, 1, \"xchg64_result\");\n\n\tASSERT_EQ(skel->data->xchg32_value, 2, \"xchg32_value\");\n\tASSERT_EQ(skel->bss->xchg32_result, 1, \"xchg32_result\");\n}\n\nvoid test_atomics(void)\n{\n\tstruct atomics_lskel *skel;\n\n\tskel = atomics_lskel__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"atomics skeleton load\"))\n\t\treturn;\n\n\tif (skel->data->skip_tests) {\n\t\tprintf(\"%s:SKIP:no ENABLE_ATOMICS_TESTS (missing Clang BPF atomics support)\",\n\t\t       __func__);\n\t\ttest__skip();\n\t\tgoto cleanup;\n\t}\n\tskel->bss->pid = getpid();\n\n\tif (test__start_subtest(\"add\"))\n\t\ttest_add(skel);\n\tif (test__start_subtest(\"sub\"))\n\t\ttest_sub(skel);\n\tif (test__start_subtest(\"and\"))\n\t\ttest_and(skel);\n\tif (test__start_subtest(\"or\"))\n\t\ttest_or(skel);\n\tif (test__start_subtest(\"xor\"))\n\t\ttest_xor(skel);\n\tif (test__start_subtest(\"cmpxchg\"))\n\t\ttest_cmpxchg(skel);\n\tif (test__start_subtest(\"xchg\"))\n\t\ttest_xchg(skel);\n\ncleanup:\n\tatomics_lskel__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}