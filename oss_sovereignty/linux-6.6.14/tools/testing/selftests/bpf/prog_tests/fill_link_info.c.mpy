{
  "module_name": "fill_link_info.c",
  "hash_id": "74fb47a87b9785de66672e5d7e2e46145f299687e4505ed6e78422ea818b358c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/fill_link_info.c",
  "human_readable_source": "\n \n\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/limits.h>\n#include <test_progs.h>\n#include \"trace_helpers.h\"\n#include \"test_fill_link_info.skel.h\"\n\n#define TP_CAT \"sched\"\n#define TP_NAME \"sched_switch\"\n\nstatic const char *kmulti_syms[] = {\n\t\"bpf_fentry_test2\",\n\t\"bpf_fentry_test1\",\n\t\"bpf_fentry_test3\",\n};\n#define KMULTI_CNT ARRAY_SIZE(kmulti_syms)\nstatic __u64 kmulti_addrs[KMULTI_CNT];\n\n#define KPROBE_FUNC \"bpf_fentry_test1\"\nstatic __u64 kprobe_addr;\n\n#define UPROBE_FILE \"/proc/self/exe\"\nstatic ssize_t uprobe_offset;\n \nstatic noinline void uprobe_func(void)\n{\n\tasm volatile (\"\");\n}\n\nstatic int verify_perf_link_info(int fd, enum bpf_perf_event_type type, long addr,\n\t\t\t\t ssize_t offset, ssize_t entry_offset)\n{\n\tstruct bpf_link_info info;\n\t__u32 len = sizeof(info);\n\tchar buf[PATH_MAX];\n\tint err;\n\n\tmemset(&info, 0, sizeof(info));\n\tbuf[0] = '\\0';\n\nagain:\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tif (!ASSERT_OK(err, \"get_link_info\"))\n\t\treturn -1;\n\n\tif (!ASSERT_EQ(info.type, BPF_LINK_TYPE_PERF_EVENT, \"link_type\"))\n\t\treturn -1;\n\tif (!ASSERT_EQ(info.perf_event.type, type, \"perf_type_match\"))\n\t\treturn -1;\n\n\tswitch (info.perf_event.type) {\n\tcase BPF_PERF_EVENT_KPROBE:\n\tcase BPF_PERF_EVENT_KRETPROBE:\n\t\tASSERT_EQ(info.perf_event.kprobe.offset, offset, \"kprobe_offset\");\n\n\t\t \n\t\tif (addr)\n\t\t\tASSERT_EQ(info.perf_event.kprobe.addr, addr + entry_offset,\n\t\t\t\t  \"kprobe_addr\");\n\n\t\tif (!info.perf_event.kprobe.func_name) {\n\t\t\tASSERT_EQ(info.perf_event.kprobe.name_len, 0, \"name_len\");\n\t\t\tinfo.perf_event.kprobe.func_name = ptr_to_u64(&buf);\n\t\t\tinfo.perf_event.kprobe.name_len = sizeof(buf);\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = strncmp(u64_to_ptr(info.perf_event.kprobe.func_name), KPROBE_FUNC,\n\t\t\t      strlen(KPROBE_FUNC));\n\t\tASSERT_EQ(err, 0, \"cmp_kprobe_func_name\");\n\t\tbreak;\n\tcase BPF_PERF_EVENT_TRACEPOINT:\n\t\tif (!info.perf_event.tracepoint.tp_name) {\n\t\t\tASSERT_EQ(info.perf_event.tracepoint.name_len, 0, \"name_len\");\n\t\t\tinfo.perf_event.tracepoint.tp_name = ptr_to_u64(&buf);\n\t\t\tinfo.perf_event.tracepoint.name_len = sizeof(buf);\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = strncmp(u64_to_ptr(info.perf_event.tracepoint.tp_name), TP_NAME,\n\t\t\t      strlen(TP_NAME));\n\t\tASSERT_EQ(err, 0, \"cmp_tp_name\");\n\t\tbreak;\n\tcase BPF_PERF_EVENT_UPROBE:\n\tcase BPF_PERF_EVENT_URETPROBE:\n\t\tASSERT_EQ(info.perf_event.uprobe.offset, offset, \"uprobe_offset\");\n\n\t\tif (!info.perf_event.uprobe.file_name) {\n\t\t\tASSERT_EQ(info.perf_event.uprobe.name_len, 0, \"name_len\");\n\t\t\tinfo.perf_event.uprobe.file_name = ptr_to_u64(&buf);\n\t\t\tinfo.perf_event.uprobe.name_len = sizeof(buf);\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = strncmp(u64_to_ptr(info.perf_event.uprobe.file_name), UPROBE_FILE,\n\t\t\t      strlen(UPROBE_FILE));\n\t\t\tASSERT_EQ(err, 0, \"cmp_file_name\");\n\t\tbreak;\n\tdefault:\n\t\terr = -1;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic void kprobe_fill_invalid_user_buffer(int fd)\n{\n\tstruct bpf_link_info info;\n\t__u32 len = sizeof(info);\n\tint err;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tinfo.perf_event.kprobe.func_name = 0x1;  \n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EINVAL, \"invalid_buff_and_len\");\n\n\tinfo.perf_event.kprobe.name_len = 64;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EFAULT, \"invalid_buff\");\n\n\tinfo.perf_event.kprobe.func_name = 0;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EINVAL, \"invalid_len\");\n\n\tASSERT_EQ(info.perf_event.kprobe.addr, 0, \"func_addr\");\n\tASSERT_EQ(info.perf_event.kprobe.offset, 0, \"func_offset\");\n\tASSERT_EQ(info.perf_event.type, 0, \"type\");\n}\n\nstatic void test_kprobe_fill_link_info(struct test_fill_link_info *skel,\n\t\t\t\t       enum bpf_perf_event_type type,\n\t\t\t\t       bool invalid)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_kprobe_opts, opts,\n\t\t.attach_mode = PROBE_ATTACH_MODE_LINK,\n\t\t.retprobe = type == BPF_PERF_EVENT_KRETPROBE,\n\t);\n\tssize_t entry_offset = 0;\n\tint link_fd, err;\n\n\tskel->links.kprobe_run = bpf_program__attach_kprobe_opts(skel->progs.kprobe_run,\n\t\t\t\t\t\t\t\t KPROBE_FUNC, &opts);\n\tif (!ASSERT_OK_PTR(skel->links.kprobe_run, \"attach_kprobe\"))\n\t\treturn;\n\n\tlink_fd = bpf_link__fd(skel->links.kprobe_run);\n\tif (!invalid) {\n\t\t \n\t\tif (skel->kconfig->CONFIG_X86_KERNEL_IBT)\n\t\t\tentry_offset = 4;\n\t\terr = verify_perf_link_info(link_fd, type, kprobe_addr, 0, entry_offset);\n\t\tASSERT_OK(err, \"verify_perf_link_info\");\n\t} else {\n\t\tkprobe_fill_invalid_user_buffer(link_fd);\n\t}\n\tbpf_link__detach(skel->links.kprobe_run);\n}\n\nstatic void test_tp_fill_link_info(struct test_fill_link_info *skel)\n{\n\tint link_fd, err;\n\n\tskel->links.tp_run = bpf_program__attach_tracepoint(skel->progs.tp_run, TP_CAT, TP_NAME);\n\tif (!ASSERT_OK_PTR(skel->links.tp_run, \"attach_tp\"))\n\t\treturn;\n\n\tlink_fd = bpf_link__fd(skel->links.tp_run);\n\terr = verify_perf_link_info(link_fd, BPF_PERF_EVENT_TRACEPOINT, 0, 0, 0);\n\tASSERT_OK(err, \"verify_perf_link_info\");\n\tbpf_link__detach(skel->links.tp_run);\n}\n\nstatic void test_uprobe_fill_link_info(struct test_fill_link_info *skel,\n\t\t\t\t       enum bpf_perf_event_type type)\n{\n\tint link_fd, err;\n\n\tskel->links.uprobe_run = bpf_program__attach_uprobe(skel->progs.uprobe_run,\n\t\t\t\t\t\t\t    type == BPF_PERF_EVENT_URETPROBE,\n\t\t\t\t\t\t\t    0,  \n\t\t\t\t\t\t\t    UPROBE_FILE, uprobe_offset);\n\tif (!ASSERT_OK_PTR(skel->links.uprobe_run, \"attach_uprobe\"))\n\t\treturn;\n\n\tlink_fd = bpf_link__fd(skel->links.uprobe_run);\n\terr = verify_perf_link_info(link_fd, type, 0, uprobe_offset, 0);\n\tASSERT_OK(err, \"verify_perf_link_info\");\n\tbpf_link__detach(skel->links.uprobe_run);\n}\n\nstatic int verify_kmulti_link_info(int fd, bool retprobe)\n{\n\tstruct bpf_link_info info;\n\t__u32 len = sizeof(info);\n\t__u64 addrs[KMULTI_CNT];\n\tint flags, i, err;\n\n\tmemset(&info, 0, sizeof(info));\n\nagain:\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tif (!ASSERT_OK(err, \"get_link_info\"))\n\t\treturn -1;\n\n\tif (!ASSERT_EQ(info.type, BPF_LINK_TYPE_KPROBE_MULTI, \"kmulti_type\"))\n\t\treturn -1;\n\n\tASSERT_EQ(info.kprobe_multi.count, KMULTI_CNT, \"func_cnt\");\n\tflags = info.kprobe_multi.flags & BPF_F_KPROBE_MULTI_RETURN;\n\tif (!retprobe)\n\t\tASSERT_EQ(flags, 0, \"kmulti_flags\");\n\telse\n\t\tASSERT_NEQ(flags, 0, \"kretmulti_flags\");\n\n\tif (!info.kprobe_multi.addrs) {\n\t\tinfo.kprobe_multi.addrs = ptr_to_u64(addrs);\n\t\tgoto again;\n\t}\n\tfor (i = 0; i < KMULTI_CNT; i++)\n\t\tASSERT_EQ(addrs[i], kmulti_addrs[i], \"kmulti_addrs\");\n\treturn 0;\n}\n\nstatic void verify_kmulti_invalid_user_buffer(int fd)\n{\n\tstruct bpf_link_info info;\n\t__u32 len = sizeof(info);\n\t__u64 addrs[KMULTI_CNT];\n\tint err, i;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tinfo.kprobe_multi.count = KMULTI_CNT;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EINVAL, \"no_addr\");\n\n\tinfo.kprobe_multi.addrs = ptr_to_u64(addrs);\n\tinfo.kprobe_multi.count = 0;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EINVAL, \"no_cnt\");\n\n\tfor (i = 0; i < KMULTI_CNT; i++)\n\t\taddrs[i] = 0;\n\tinfo.kprobe_multi.count = KMULTI_CNT - 1;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -ENOSPC, \"smaller_cnt\");\n\tfor (i = 0; i < KMULTI_CNT - 1; i++)\n\t\tASSERT_EQ(addrs[i], kmulti_addrs[i], \"kmulti_addrs\");\n\tASSERT_EQ(addrs[i], 0, \"kmulti_addrs\");\n\n\tfor (i = 0; i < KMULTI_CNT; i++)\n\t\taddrs[i] = 0;\n\tinfo.kprobe_multi.count = KMULTI_CNT + 1;\n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, 0, \"bigger_cnt\");\n\tfor (i = 0; i < KMULTI_CNT; i++)\n\t\tASSERT_EQ(addrs[i], kmulti_addrs[i], \"kmulti_addrs\");\n\n\tinfo.kprobe_multi.count = KMULTI_CNT;\n\tinfo.kprobe_multi.addrs = 0x1;  \n\terr = bpf_link_get_info_by_fd(fd, &info, &len);\n\tASSERT_EQ(err, -EFAULT, \"invalid_buff\");\n}\n\nstatic int symbols_cmp_r(const void *a, const void *b)\n{\n\tconst char **str_a = (const char **) a;\n\tconst char **str_b = (const char **) b;\n\n\treturn strcmp(*str_a, *str_b);\n}\n\nstatic void test_kprobe_multi_fill_link_info(struct test_fill_link_info *skel,\n\t\t\t\t\t     bool retprobe, bool invalid)\n{\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tint link_fd, err;\n\n\topts.syms = kmulti_syms;\n\topts.cnt = KMULTI_CNT;\n\topts.retprobe = retprobe;\n\tskel->links.kmulti_run = bpf_program__attach_kprobe_multi_opts(skel->progs.kmulti_run,\n\t\t\t\t\t\t\t\t       NULL, &opts);\n\tif (!ASSERT_OK_PTR(skel->links.kmulti_run, \"attach_kprobe_multi\"))\n\t\treturn;\n\n\tlink_fd = bpf_link__fd(skel->links.kmulti_run);\n\tif (!invalid) {\n\t\terr = verify_kmulti_link_info(link_fd, retprobe);\n\t\tASSERT_OK(err, \"verify_kmulti_link_info\");\n\t} else {\n\t\tverify_kmulti_invalid_user_buffer(link_fd);\n\t}\n\tbpf_link__detach(skel->links.kmulti_run);\n}\n\nvoid test_fill_link_info(void)\n{\n\tstruct test_fill_link_info *skel;\n\tint i;\n\n\tskel = test_fill_link_info__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\t \n\tif (!ASSERT_OK(load_kallsyms_refresh(), \"load_kallsyms_refresh\"))\n\t\tgoto cleanup;\n\n\tkprobe_addr = ksym_get_addr(KPROBE_FUNC);\n\tif (test__start_subtest(\"kprobe_link_info\"))\n\t\ttest_kprobe_fill_link_info(skel, BPF_PERF_EVENT_KPROBE, false);\n\tif (test__start_subtest(\"kretprobe_link_info\"))\n\t\ttest_kprobe_fill_link_info(skel, BPF_PERF_EVENT_KRETPROBE, false);\n\tif (test__start_subtest(\"kprobe_invalid_ubuff\"))\n\t\ttest_kprobe_fill_link_info(skel, BPF_PERF_EVENT_KPROBE, true);\n\tif (test__start_subtest(\"tracepoint_link_info\"))\n\t\ttest_tp_fill_link_info(skel);\n\n\tuprobe_offset = get_uprobe_offset(&uprobe_func);\n\tif (test__start_subtest(\"uprobe_link_info\"))\n\t\ttest_uprobe_fill_link_info(skel, BPF_PERF_EVENT_UPROBE);\n\tif (test__start_subtest(\"uretprobe_link_info\"))\n\t\ttest_uprobe_fill_link_info(skel, BPF_PERF_EVENT_URETPROBE);\n\n\tqsort(kmulti_syms, KMULTI_CNT, sizeof(kmulti_syms[0]), symbols_cmp_r);\n\tfor (i = 0; i < KMULTI_CNT; i++)\n\t\tkmulti_addrs[i] = ksym_get_addr(kmulti_syms[i]);\n\tif (test__start_subtest(\"kprobe_multi_link_info\"))\n\t\ttest_kprobe_multi_fill_link_info(skel, false, false);\n\tif (test__start_subtest(\"kretprobe_multi_link_info\"))\n\t\ttest_kprobe_multi_fill_link_info(skel, true, false);\n\tif (test__start_subtest(\"kprobe_multi_invalid_ubuff\"))\n\t\ttest_kprobe_multi_fill_link_info(skel, true, true);\n\ncleanup:\n\ttest_fill_link_info__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}