{
  "module_name": "bpf_iter_setsockopt.c",
  "hash_id": "5e46cc4343d81f8c61e9b8d586d809b6a21daab8c6a98a39999f48b78248fd14",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_iter_setsockopt.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <test_progs.h>\n#include \"network_helpers.h\"\n#include \"bpf_dctcp.skel.h\"\n#include \"bpf_cubic.skel.h\"\n#include \"bpf_iter_setsockopt.skel.h\"\n\nstatic int create_netns(void)\n{\n\tif (!ASSERT_OK(unshare(CLONE_NEWNET), \"create netns\"))\n\t\treturn -1;\n\n\tif (!ASSERT_OK(system(\"ip link set dev lo up\"), \"bring up lo\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic unsigned int set_bpf_cubic(int *fds, unsigned int nr_fds)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_fds; i++) {\n\t\tif (setsockopt(fds[i], SOL_TCP, TCP_CONGESTION, \"bpf_cubic\",\n\t\t\t       sizeof(\"bpf_cubic\")))\n\t\t\treturn i;\n\t}\n\n\treturn nr_fds;\n}\n\nstatic unsigned int check_bpf_dctcp(int *fds, unsigned int nr_fds)\n{\n\tchar tcp_cc[16];\n\tsocklen_t optlen = sizeof(tcp_cc);\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_fds; i++) {\n\t\tif (getsockopt(fds[i], SOL_TCP, TCP_CONGESTION,\n\t\t\t       tcp_cc, &optlen) ||\n\t\t    strcmp(tcp_cc, \"bpf_dctcp\"))\n\t\t\treturn i;\n\t}\n\n\treturn nr_fds;\n}\n\nstatic int *make_established(int listen_fd, unsigned int nr_est,\n\t\t\t     int **paccepted_fds)\n{\n\tint *est_fds, *accepted_fds;\n\tunsigned int i;\n\n\test_fds = malloc(sizeof(*est_fds) * nr_est);\n\tif (!est_fds)\n\t\treturn NULL;\n\n\taccepted_fds = malloc(sizeof(*accepted_fds) * nr_est);\n\tif (!accepted_fds) {\n\t\tfree(est_fds);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_est; i++) {\n\t\test_fds[i] = connect_to_fd(listen_fd, 0);\n\t\tif (est_fds[i] == -1)\n\t\t\tbreak;\n\t\tif (set_bpf_cubic(&est_fds[i], 1) != 1) {\n\t\t\tclose(est_fds[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\taccepted_fds[i] = accept(listen_fd, NULL, 0);\n\t\tif (accepted_fds[i] == -1) {\n\t\t\tclose(est_fds[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ASSERT_EQ(i, nr_est, \"create established fds\")) {\n\t\tfree_fds(accepted_fds, i);\n\t\tfree_fds(est_fds, i);\n\t\treturn NULL;\n\t}\n\n\t*paccepted_fds = accepted_fds;\n\treturn est_fds;\n}\n\nstatic unsigned short get_local_port(int fd)\n{\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, &addr, &addrlen))\n\t\treturn ntohs(addr.sin6_port);\n\n\treturn 0;\n}\n\nstatic void do_bpf_iter_setsockopt(struct bpf_iter_setsockopt *iter_skel,\n\t\t\t\t   bool random_retry)\n{\n\tint *reuse_listen_fds = NULL, *accepted_fds = NULL, *est_fds = NULL;\n\tunsigned int nr_reuse_listens = 256, nr_est = 256;\n\tint err, iter_fd = -1, listen_fd = -1;\n\tchar buf;\n\n\t \n\tlisten_fd = start_server(AF_INET6, SOCK_STREAM, \"::1\", 0, 0);\n\tif (!ASSERT_GE(listen_fd, 0, \"start_server\"))\n\t\treturn;\n\tif (!ASSERT_EQ(set_bpf_cubic(&listen_fd, 1), 1,\n\t\t       \"set listen_fd to cubic\"))\n\t\tgoto done;\n\titer_skel->bss->listen_hport = get_local_port(listen_fd);\n\tif (!ASSERT_NEQ(iter_skel->bss->listen_hport, 0,\n\t\t\t\"get_local_port(listen_fd)\"))\n\t\tgoto done;\n\n\t \n\test_fds = make_established(listen_fd, nr_est, &accepted_fds);\n\tif (!ASSERT_OK_PTR(est_fds, \"create established\"))\n\t\tgoto done;\n\n\t \n\treuse_listen_fds = start_reuseport_server(AF_INET6, SOCK_STREAM,\n\t\t\t\t\t\t  \"::1\", 0, 0,\n\t\t\t\t\t\t  nr_reuse_listens);\n\tif (!ASSERT_OK_PTR(reuse_listen_fds, \"start_reuseport_server\"))\n\t\tgoto done;\n\tif (!ASSERT_EQ(set_bpf_cubic(reuse_listen_fds, nr_reuse_listens),\n\t\t       nr_reuse_listens, \"set reuse_listen_fds to cubic\"))\n\t\tgoto done;\n\titer_skel->bss->reuse_listen_hport = get_local_port(reuse_listen_fds[0]);\n\tif (!ASSERT_NEQ(iter_skel->bss->reuse_listen_hport, 0,\n\t\t\t\"get_local_port(reuse_listen_fds[0])\"))\n\t\tgoto done;\n\n\t \n\titer_skel->bss->random_retry = random_retry;\n\titer_fd = bpf_iter_create(bpf_link__fd(iter_skel->links.change_tcp_cc));\n\tif (!ASSERT_GE(iter_fd, 0, \"create iter_fd\"))\n\t\tgoto done;\n\n\twhile ((err = read(iter_fd, &buf, sizeof(buf))) == -1 &&\n\t       errno == EAGAIN)\n\t\t;\n\tif (!ASSERT_OK(err, \"read iter error\"))\n\t\tgoto done;\n\n\t \n\tASSERT_EQ(check_bpf_dctcp(reuse_listen_fds, nr_reuse_listens),\n\t\t  nr_reuse_listens,\n\t\t  \"check reuse_listen_fds dctcp\");\n\n\t \n\tASSERT_EQ(check_bpf_dctcp(&listen_fd, 1), 1,\n\t\t  \"check listen_fd dctcp\");\n\n\t \n\tASSERT_EQ(check_bpf_dctcp(est_fds, nr_est), nr_est,\n\t\t  \"check est_fds dctcp\");\n\n\t \n\tASSERT_EQ(check_bpf_dctcp(accepted_fds, nr_est), nr_est,\n\t\t  \"check accepted_fds dctcp\");\n\ndone:\n\tif (iter_fd != -1)\n\t\tclose(iter_fd);\n\tif (listen_fd != -1)\n\t\tclose(listen_fd);\n\tfree_fds(reuse_listen_fds, nr_reuse_listens);\n\tfree_fds(accepted_fds, nr_est);\n\tfree_fds(est_fds, nr_est);\n}\n\nvoid serial_test_bpf_iter_setsockopt(void)\n{\n\tstruct bpf_iter_setsockopt *iter_skel = NULL;\n\tstruct bpf_cubic *cubic_skel = NULL;\n\tstruct bpf_dctcp *dctcp_skel = NULL;\n\tstruct bpf_link *cubic_link = NULL;\n\tstruct bpf_link *dctcp_link = NULL;\n\n\tif (create_netns())\n\t\treturn;\n\n\t \n\titer_skel = bpf_iter_setsockopt__open_and_load();\n\tif (!ASSERT_OK_PTR(iter_skel, \"iter_skel\"))\n\t\treturn;\n\titer_skel->links.change_tcp_cc = bpf_program__attach_iter(iter_skel->progs.change_tcp_cc, NULL);\n\tif (!ASSERT_OK_PTR(iter_skel->links.change_tcp_cc, \"attach iter\"))\n\t\tgoto done;\n\n\t \n\tcubic_skel = bpf_cubic__open_and_load();\n\tif (!ASSERT_OK_PTR(cubic_skel, \"cubic_skel\"))\n\t\tgoto done;\n\tcubic_link = bpf_map__attach_struct_ops(cubic_skel->maps.cubic);\n\tif (!ASSERT_OK_PTR(cubic_link, \"cubic_link\"))\n\t\tgoto done;\n\n\t \n\tdctcp_skel = bpf_dctcp__open_and_load();\n\tif (!ASSERT_OK_PTR(dctcp_skel, \"dctcp_skel\"))\n\t\tgoto done;\n\tdctcp_link = bpf_map__attach_struct_ops(dctcp_skel->maps.dctcp);\n\tif (!ASSERT_OK_PTR(dctcp_link, \"dctcp_link\"))\n\t\tgoto done;\n\n\tdo_bpf_iter_setsockopt(iter_skel, true);\n\tdo_bpf_iter_setsockopt(iter_skel, false);\n\ndone:\n\tbpf_link__destroy(cubic_link);\n\tbpf_link__destroy(dctcp_link);\n\tbpf_cubic__destroy(cubic_skel);\n\tbpf_dctcp__destroy(dctcp_skel);\n\tbpf_iter_setsockopt__destroy(iter_skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}