{
  "module_name": "map_lock.c",
  "hash_id": "d05027b883fd1364b44377c10ab72cd081098e5bddc09f14113775f9f3622922",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/map_lock.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\nstatic void *spin_lock_thread(void *arg)\n{\n\tint err, prog_fd = *(u32 *) arg;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 10000,\n\t);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run_opts err\");\n\tASSERT_OK(topts.retval, \"test_run_opts retval\");\n\n\tpthread_exit(arg);\n}\n\nstatic void *parallel_map_access(void *arg)\n{\n\tint err, map_fd = *(u32 *) arg;\n\tint vars[17], i, j, rnd, key = 0;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\terr = bpf_map_lookup_elem_flags(map_fd, &key, vars, BPF_F_LOCK);\n\t\tif (CHECK_FAIL(err)) {\n\t\t\tprintf(\"lookup failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (CHECK_FAIL(vars[0] != 0)) {\n\t\t\tprintf(\"lookup #%d var[0]=%d\\n\", i, vars[0]);\n\t\t\tgoto out;\n\t\t}\n\t\trnd = vars[1];\n\t\tfor (j = 2; j < 17; j++) {\n\t\t\tif (vars[j] == rnd)\n\t\t\t\tcontinue;\n\t\t\tprintf(\"lookup #%d var[1]=%d var[%d]=%d\\n\",\n\t\t\t       i, rnd, j, vars[j]);\n\t\t\tCHECK_FAIL(vars[j] != rnd);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tpthread_exit(arg);\n}\n\nvoid test_map_lock(void)\n{\n\tconst char *file = \"./test_map_lock.bpf.o\";\n\tint prog_fd, map_fd[2], vars[17] = {};\n\tpthread_t thread_id[6];\n\tstruct bpf_object *obj = NULL;\n\tint err = 0, key = 0, i;\n\tvoid *ret;\n\n\terr = bpf_prog_test_load(file, BPF_PROG_TYPE_CGROUP_SKB, &obj, &prog_fd);\n\tif (CHECK_FAIL(err)) {\n\t\tprintf(\"test_map_lock:bpf_prog_test_load errno %d\\n\", errno);\n\t\tgoto close_prog;\n\t}\n\tmap_fd[0] = bpf_find_map(__func__, obj, \"hash_map\");\n\tif (CHECK_FAIL(map_fd[0] < 0))\n\t\tgoto close_prog;\n\tmap_fd[1] = bpf_find_map(__func__, obj, \"array_map\");\n\tif (CHECK_FAIL(map_fd[1] < 0))\n\t\tgoto close_prog;\n\n\tbpf_map_update_elem(map_fd[0], &key, vars, BPF_F_LOCK);\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (CHECK_FAIL(pthread_create(&thread_id[i], NULL,\n\t\t\t\t\t      &spin_lock_thread, &prog_fd)))\n\t\t\tgoto close_prog;\n\tfor (i = 4; i < 6; i++)\n\t\tif (CHECK_FAIL(pthread_create(&thread_id[i], NULL,\n\t\t\t\t\t      &parallel_map_access,\n\t\t\t\t\t      &map_fd[i - 4])))\n\t\t\tgoto close_prog;\n\tfor (i = 0; i < 4; i++)\n\t\tif (CHECK_FAIL(pthread_join(thread_id[i], &ret) ||\n\t\t\t       ret != (void *)&prog_fd))\n\t\t\tgoto close_prog;\n\tfor (i = 4; i < 6; i++)\n\t\tif (CHECK_FAIL(pthread_join(thread_id[i], &ret) ||\n\t\t\t       ret != (void *)&map_fd[i - 4]))\n\t\t\tgoto close_prog;\nclose_prog:\n\tbpf_object__close(obj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}