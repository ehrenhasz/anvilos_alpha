{
  "module_name": "global_map_resize.c",
  "hash_id": "5de3021ceb74f599df16f52b3c15ccf9d29854b05a5c701f508e9a1b2b8fcd4a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/global_map_resize.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"test_global_map_resize.skel.h\"\n#include \"test_progs.h\"\n\nstatic void run_prog_bss_array_sum(void)\n{\n\t(void)syscall(__NR_getpid);\n}\n\nstatic void run_prog_data_array_sum(void)\n{\n\t(void)syscall(__NR_getuid);\n}\n\nstatic void global_map_resize_bss_subtest(void)\n{\n\tint err;\n\tstruct test_global_map_resize *skel;\n\tstruct bpf_map *map;\n\tconst __u32 desired_sz = sizeof(skel->bss->sum) + sysconf(_SC_PAGE_SIZE) * 2;\n\tsize_t array_len, actual_sz, new_sz;\n\n\tskel = test_global_map_resize__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_global_map_resize__open\"))\n\t\tgoto teardown;\n\n\t \n\tskel->bss->array[0] = 1;\n\n\t \n\tmap = skel->maps.bss;\n\terr = bpf_map__set_value_size(map, desired_sz);\n\tif (!ASSERT_OK(err, \"bpf_map__set_value_size\"))\n\t\tgoto teardown;\n\tif (!ASSERT_EQ(bpf_map__value_size(map), desired_sz, \"resize\"))\n\t\tgoto teardown;\n\n\tnew_sz = sizeof(skel->data_percpu_arr->percpu_arr[0]) * libbpf_num_possible_cpus();\n\terr = bpf_map__set_value_size(skel->maps.data_percpu_arr, new_sz);\n\tASSERT_OK(err, \"percpu_arr_resize\");\n\n\t \n\tarray_len = (desired_sz - sizeof(skel->bss->sum)) / sizeof(skel->bss->array[0]);\n\tif (!ASSERT_GT(array_len, 1, \"array_len\"))\n\t\tgoto teardown;\n\n\tskel->bss = bpf_map__initial_value(skel->maps.bss, &actual_sz);\n\tif (!ASSERT_OK_PTR(skel->bss, \"bpf_map__initial_value (ptr)\"))\n\t\tgoto teardown;\n\tif (!ASSERT_EQ(actual_sz, desired_sz, \"bpf_map__initial_value (size)\"))\n\t\tgoto teardown;\n\n\t \n\tfor (int i = 1; i < array_len; i++)\n\t\tskel->bss->array[i] = 1;\n\n\t \n\tskel->rodata->pid = getpid();\n\tskel->rodata->bss_array_len = array_len;\n\tskel->rodata->data_array_len = 1;\n\n\terr = test_global_map_resize__load(skel);\n\tif (!ASSERT_OK(err, \"test_global_map_resize__load\"))\n\t\tgoto teardown;\n\terr = test_global_map_resize__attach(skel);\n\tif (!ASSERT_OK(err, \"test_global_map_resize__attach\"))\n\t\tgoto teardown;\n\n\t \n\trun_prog_bss_array_sum();\n\tif (!ASSERT_EQ(skel->bss->sum, array_len, \"sum\"))\n\t\tgoto teardown;\n\nteardown:\n\ttest_global_map_resize__destroy(skel);\n}\n\nstatic void global_map_resize_data_subtest(void)\n{\n\tstruct test_global_map_resize *skel;\n\tstruct bpf_map *map;\n\tconst __u32 desired_sz = sysconf(_SC_PAGE_SIZE) * 2;\n\tsize_t array_len, actual_sz, new_sz;\n\tint err;\n\n\tskel = test_global_map_resize__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_global_map_resize__open\"))\n\t\tgoto teardown;\n\n\t \n\tskel->data_custom->my_array[0] = 1;\n\n\t \n\tmap = skel->maps.data_custom;\n\terr = bpf_map__set_value_size(map, desired_sz);\n\tif (!ASSERT_OK(err, \"bpf_map__set_value_size\"))\n\t\tgoto teardown;\n\tif (!ASSERT_EQ(bpf_map__value_size(map), desired_sz, \"resize\"))\n\t\tgoto teardown;\n\n\tnew_sz = sizeof(skel->data_percpu_arr->percpu_arr[0]) * libbpf_num_possible_cpus();\n\terr = bpf_map__set_value_size(skel->maps.data_percpu_arr, new_sz);\n\tASSERT_OK(err, \"percpu_arr_resize\");\n\n\t \n\tarray_len = (desired_sz - sizeof(skel->bss->sum)) / sizeof(skel->data_custom->my_array[0]);\n\tif (!ASSERT_GT(array_len, 1, \"array_len\"))\n\t\tgoto teardown;\n\n\tskel->data_custom = bpf_map__initial_value(skel->maps.data_custom, &actual_sz);\n\tif (!ASSERT_OK_PTR(skel->data_custom, \"bpf_map__initial_value (ptr)\"))\n\t\tgoto teardown;\n\tif (!ASSERT_EQ(actual_sz, desired_sz, \"bpf_map__initial_value (size)\"))\n\t\tgoto teardown;\n\n\t \n\tfor (int i = 1; i < array_len; i++)\n\t\tskel->data_custom->my_array[i] = 1;\n\n\t \n\tskel->rodata->pid = getpid();\n\tskel->rodata->bss_array_len = 1;\n\tskel->rodata->data_array_len = array_len;\n\n\terr = test_global_map_resize__load(skel);\n\tif (!ASSERT_OK(err, \"test_global_map_resize__load\"))\n\t\tgoto teardown;\n\terr = test_global_map_resize__attach(skel);\n\tif (!ASSERT_OK(err, \"test_global_map_resize__attach\"))\n\t\tgoto teardown;\n\n\t \n\trun_prog_data_array_sum();\n\tif (!ASSERT_EQ(skel->bss->sum, array_len, \"sum\"))\n\t\tgoto teardown;\n\nteardown:\n\ttest_global_map_resize__destroy(skel);\n}\n\nstatic void global_map_resize_invalid_subtest(void)\n{\n\tint err;\n\tstruct test_global_map_resize *skel;\n\tstruct bpf_map *map;\n\t__u32 element_sz, desired_sz;\n\n\tskel = test_global_map_resize__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_global_map_resize__open\"))\n\t\treturn;\n\n\t  \n\tmap = skel->maps.data_custom;\n\tif (!ASSERT_NEQ(bpf_map__btf_value_type_id(map), 0, \".data.custom initial btf\"))\n\t\tgoto teardown;\n\t \n\telement_sz = sizeof(skel->data_custom->my_array[0]);\n\tdesired_sz = element_sz + element_sz / 2;\n\t \n\tif (!ASSERT_NEQ(desired_sz % element_sz, 0, \"my_array alignment\"))\n\t\tgoto teardown;\n\terr = bpf_map__set_value_size(map, desired_sz);\n\t \n\tif (!ASSERT_OK(err, \".data.custom bpf_map__set_value_size\") ||\n\t    !ASSERT_EQ(bpf_map__btf_key_type_id(map), 0, \".data.custom clear btf key\") ||\n\t    !ASSERT_EQ(bpf_map__btf_value_type_id(map), 0, \".data.custom clear btf val\"))\n\t\tgoto teardown;\n\n\t \n\tmap = skel->maps.data_non_array;\n\tif (!ASSERT_NEQ(bpf_map__btf_value_type_id(map), 0, \".data.non_array initial btf\"))\n\t\tgoto teardown;\n\t \n\tdesired_sz = 1024;\n\terr = bpf_map__set_value_size(map, desired_sz);\n\t \n\tif (!ASSERT_OK(err, \".data.non_array bpf_map__set_value_size\") ||\n\t    !ASSERT_EQ(bpf_map__btf_key_type_id(map), 0, \".data.non_array clear btf key\") ||\n\t    !ASSERT_EQ(bpf_map__btf_value_type_id(map), 0, \".data.non_array clear btf val\"))\n\t\tgoto teardown;\n\n\t \n\tmap = skel->maps.data_array_not_last;\n\tif (!ASSERT_NEQ(bpf_map__btf_value_type_id(map), 0, \".data.array_not_last initial btf\"))\n\t\tgoto teardown;\n\t \n\telement_sz = sizeof(skel->data_array_not_last->my_array_first[0]);\n\tdesired_sz = element_sz * 8;\n\t \n\tif (!ASSERT_EQ(desired_sz % element_sz, 0, \"my_array_first alignment\"))\n\t\tgoto teardown;\n\terr = bpf_map__set_value_size(map, desired_sz);\n\t \n\tif (!ASSERT_OK(err, \".data.array_not_last bpf_map__set_value_size\") ||\n\t    !ASSERT_EQ(bpf_map__btf_key_type_id(map), 0, \".data.array_not_last clear btf key\") ||\n\t    !ASSERT_EQ(bpf_map__btf_value_type_id(map), 0, \".data.array_not_last clear btf val\"))\n\t\tgoto teardown;\n\nteardown:\n\ttest_global_map_resize__destroy(skel);\n}\n\nvoid test_global_map_resize(void)\n{\n\tif (test__start_subtest(\"global_map_resize_bss\"))\n\t\tglobal_map_resize_bss_subtest();\n\n\tif (test__start_subtest(\"global_map_resize_data\"))\n\t\tglobal_map_resize_data_subtest();\n\n\tif (test__start_subtest(\"global_map_resize_invalid\"))\n\t\tglobal_map_resize_invalid_subtest();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}