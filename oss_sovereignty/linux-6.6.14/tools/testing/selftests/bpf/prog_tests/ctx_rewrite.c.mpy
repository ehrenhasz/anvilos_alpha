{
  "module_name": "ctx_rewrite.c",
  "hash_id": "6c760636340690a8aaff4678d9434cbe6653da8b709cc0e5bf9a4be554172ced",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/ctx_rewrite.c",
  "human_readable_source": "\n\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <regex.h>\n#include <test_progs.h>\n\n#include \"bpf/btf.h\"\n#include \"bpf_util.h\"\n#include \"linux/filter.h\"\n#include \"disasm.h\"\n\n#define MAX_PROG_TEXT_SZ (32 * 1024)\n\n \nstruct test_case {\n\tchar *name;\n\tenum bpf_prog_type prog_type;\n\tenum bpf_attach_type expected_attach_type;\n\tint field_offset;\n\tint field_sz;\n\t \n\tstruct {\n\t\tbool use;\n\t\tint value;\n\t} st_value;\n\t \n\tchar *read;\n\t \n\tchar *write;\n\t \n\tchar *write_st;\n\t \n\tchar *write_stx;\n};\n\n#define N(_prog_type, type, field, name_extra...)\t\\\n\t.name = #_prog_type \".\" #field name_extra,\t\\\n\t.prog_type = BPF_PROG_TYPE_##_prog_type,\t\\\n\t.field_offset = offsetof(type, field),\t\t\\\n\t.field_sz = sizeof(typeof(((type *)NULL)->field))\n\nstatic struct test_case test_cases[] = {\n \n#if defined(__x86_64__) || defined(__aarch64__)\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, tstamp),\n\t\t.read  = \"r11 = *(u8 *)($ctx + sk_buff::__mono_tc_offset);\"\n\t\t\t \"w11 &= 3;\"\n\t\t\t \"if w11 != 0x3 goto pc+2;\"\n\t\t\t \"$dst = 0;\"\n\t\t\t \"goto pc+1;\"\n\t\t\t \"$dst = *(u64 *)($ctx + sk_buff::tstamp);\",\n\t\t.write = \"r11 = *(u8 *)($ctx + sk_buff::__mono_tc_offset);\"\n\t\t\t \"if w11 & 0x2 goto pc+1;\"\n\t\t\t \"goto pc+2;\"\n\t\t\t \"w11 &= -2;\"\n\t\t\t \"*(u8 *)($ctx + sk_buff::__mono_tc_offset) = r11;\"\n\t\t\t \"*(u64 *)($ctx + sk_buff::tstamp) = $src;\",\n\t},\n#endif\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, priority),\n\t\t.read  = \"$dst = *(u32 *)($ctx + sk_buff::priority);\",\n\t\t.write = \"*(u32 *)($ctx + sk_buff::priority) = $src;\",\n\t},\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, mark),\n\t\t.read  = \"$dst = *(u32 *)($ctx + sk_buff::mark);\",\n\t\t.write = \"*(u32 *)($ctx + sk_buff::mark) = $src;\",\n\t},\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, cb[0]),\n\t\t.read  = \"$dst = *(u32 *)($ctx + $(sk_buff::cb + qdisc_skb_cb::data));\",\n\t\t.write = \"*(u32 *)($ctx + $(sk_buff::cb + qdisc_skb_cb::data)) = $src;\",\n\t},\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, tc_classid),\n\t\t.read  = \"$dst = *(u16 *)($ctx + $(sk_buff::cb + qdisc_skb_cb::tc_classid));\",\n\t\t.write = \"*(u16 *)($ctx + $(sk_buff::cb + qdisc_skb_cb::tc_classid)) = $src;\",\n\t},\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, tc_index),\n\t\t.read  = \"$dst = *(u16 *)($ctx + sk_buff::tc_index);\",\n\t\t.write = \"*(u16 *)($ctx + sk_buff::tc_index) = $src;\",\n\t},\n\t{\n\t\tN(SCHED_CLS, struct __sk_buff, queue_mapping),\n\t\t.read      = \"$dst = *(u16 *)($ctx + sk_buff::queue_mapping);\",\n\t\t.write_stx = \"if $src >= 0xffff goto pc+1;\"\n\t\t\t     \"*(u16 *)($ctx + sk_buff::queue_mapping) = $src;\",\n\t\t.write_st  = \"*(u16 *)($ctx + sk_buff::queue_mapping) = $src;\",\n\t},\n\t{\n\t\t \n\t\tN(SCHED_CLS, struct __sk_buff, queue_mapping, \".ushrt_max\"),\n\t\t.st_value = { true, USHRT_MAX },\n\t\t.write_st = \"goto pc+0;\",\n\t},\n\t{\n\t\tN(CGROUP_SOCK, struct bpf_sock, bound_dev_if),\n\t\t.read  = \"$dst = *(u32 *)($ctx + sock_common::skc_bound_dev_if);\",\n\t\t.write = \"*(u32 *)($ctx + sock_common::skc_bound_dev_if) = $src;\",\n\t},\n\t{\n\t\tN(CGROUP_SOCK, struct bpf_sock, mark),\n\t\t.read  = \"$dst = *(u32 *)($ctx + sock::sk_mark);\",\n\t\t.write = \"*(u32 *)($ctx + sock::sk_mark) = $src;\",\n\t},\n\t{\n\t\tN(CGROUP_SOCK, struct bpf_sock, priority),\n\t\t.read  = \"$dst = *(u32 *)($ctx + sock::sk_priority);\",\n\t\t.write = \"*(u32 *)($ctx + sock::sk_priority) = $src;\",\n\t},\n\t{\n\t\tN(SOCK_OPS, struct bpf_sock_ops, replylong[0]),\n\t\t.read  = \"$dst = *(u32 *)($ctx + bpf_sock_ops_kern::replylong);\",\n\t\t.write = \"*(u32 *)($ctx + bpf_sock_ops_kern::replylong) = $src;\",\n\t},\n\t{\n\t\tN(CGROUP_SYSCTL, struct bpf_sysctl, file_pos),\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sysctl_kern::ppos);\"\n\t\t\t \"$dst = *(u32 *)($dst +0);\",\n\t\t.write = \"*(u64 *)($ctx + bpf_sysctl_kern::tmp_reg) = r9;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sysctl_kern::ppos);\"\n\t\t\t \"*(u32 *)(r9 +0) = $src;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sysctl_kern::tmp_reg);\",\n#else\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sysctl_kern::ppos);\"\n\t\t\t \"$dst = *(u32 *)($dst +4);\",\n\t\t.write = \"*(u64 *)($ctx + bpf_sysctl_kern::tmp_reg) = r9;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sysctl_kern::ppos);\"\n\t\t\t \"*(u32 *)(r9 +4) = $src;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sysctl_kern::tmp_reg);\",\n#endif\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, sk),\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sockopt_kern::sk);\",\n\t\t.expected_attach_type = BPF_CGROUP_GETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, level),\n\t\t.read  = \"$dst = *(u32 *)($ctx + bpf_sockopt_kern::level);\",\n\t\t.write = \"*(u32 *)($ctx + bpf_sockopt_kern::level) = $src;\",\n\t\t.expected_attach_type = BPF_CGROUP_SETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, optname),\n\t\t.read  = \"$dst = *(u32 *)($ctx + bpf_sockopt_kern::optname);\",\n\t\t.write = \"*(u32 *)($ctx + bpf_sockopt_kern::optname) = $src;\",\n\t\t.expected_attach_type = BPF_CGROUP_SETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, optlen),\n\t\t.read  = \"$dst = *(u32 *)($ctx + bpf_sockopt_kern::optlen);\",\n\t\t.write = \"*(u32 *)($ctx + bpf_sockopt_kern::optlen) = $src;\",\n\t\t.expected_attach_type = BPF_CGROUP_SETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, retval),\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sockopt_kern::current_task);\"\n\t\t\t \"$dst = *(u64 *)($dst + task_struct::bpf_ctx);\"\n\t\t\t \"$dst = *(u32 *)($dst + bpf_cg_run_ctx::retval);\",\n\t\t.write = \"*(u64 *)($ctx + bpf_sockopt_kern::tmp_reg) = r9;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sockopt_kern::current_task);\"\n\t\t\t \"r9 = *(u64 *)(r9 + task_struct::bpf_ctx);\"\n\t\t\t \"*(u32 *)(r9 + bpf_cg_run_ctx::retval) = $src;\"\n\t\t\t \"r9 = *(u64 *)($ctx + bpf_sockopt_kern::tmp_reg);\",\n\t\t.expected_attach_type = BPF_CGROUP_GETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, optval),\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sockopt_kern::optval);\",\n\t\t.expected_attach_type = BPF_CGROUP_GETSOCKOPT,\n\t},\n\t{\n\t\tN(CGROUP_SOCKOPT, struct bpf_sockopt, optval_end),\n\t\t.read  = \"$dst = *(u64 *)($ctx + bpf_sockopt_kern::optval_end);\",\n\t\t.expected_attach_type = BPF_CGROUP_GETSOCKOPT,\n\t},\n};\n\n#undef N\n\nstatic regex_t *ident_regex;\nstatic regex_t *field_regex;\n\nstatic char *skip_space(char *str)\n{\n\twhile (*str && isspace(*str))\n\t\t++str;\n\treturn str;\n}\n\nstatic char *skip_space_and_semi(char *str)\n{\n\twhile (*str && (isspace(*str) || *str == ';'))\n\t\t++str;\n\treturn str;\n}\n\nstatic char *match_str(char *str, char *prefix)\n{\n\twhile (*str && *prefix && *str == *prefix) {\n\t\t++str;\n\t\t++prefix;\n\t}\n\tif (*prefix)\n\t\treturn NULL;\n\treturn str;\n}\n\nstatic char *match_number(char *str, int num)\n{\n\tchar *next;\n\tint snum = strtol(str, &next, 10);\n\n\tif (next - str == 0 || num != snum)\n\t\treturn NULL;\n\n\treturn next;\n}\n\nstatic int find_field_offset_aux(struct btf *btf, int btf_id, char *field_name, int off)\n{\n\tconst struct btf_type *type = btf__type_by_id(btf, btf_id);\n\tconst struct btf_member *m;\n\t__u16 mnum;\n\tint i;\n\n\tif (!type) {\n\t\tPRINT_FAIL(\"Can't find btf_type for id %d\\n\", btf_id);\n\t\treturn -1;\n\t}\n\n\tif (!btf_is_struct(type) && !btf_is_union(type)) {\n\t\tPRINT_FAIL(\"BTF id %d is not struct or union\\n\", btf_id);\n\t\treturn -1;\n\t}\n\n\tm = btf_members(type);\n\tmnum = btf_vlen(type);\n\n\tfor (i = 0; i < mnum; ++i, ++m) {\n\t\tconst char *mname = btf__name_by_offset(btf, m->name_off);\n\n\t\tif (strcmp(mname, \"\") == 0) {\n\t\t\tint msize = find_field_offset_aux(btf, m->type, field_name,\n\t\t\t\t\t\t\t  off + m->offset);\n\t\t\tif (msize >= 0)\n\t\t\t\treturn msize;\n\t\t}\n\n\t\tif (strcmp(mname, field_name))\n\t\t\tcontinue;\n\n\t\treturn (off + m->offset) / 8;\n\t}\n\n\treturn -1;\n}\n\nstatic int find_field_offset(struct btf *btf, char *pattern, regmatch_t *matches)\n{\n\tint type_sz  = matches[1].rm_eo - matches[1].rm_so;\n\tint field_sz = matches[2].rm_eo - matches[2].rm_so;\n\tchar *type   = pattern + matches[1].rm_so;\n\tchar *field  = pattern + matches[2].rm_so;\n\tchar field_str[128] = {};\n\tchar type_str[128] = {};\n\tint btf_id, field_offset;\n\n\tif (type_sz >= sizeof(type_str)) {\n\t\tPRINT_FAIL(\"Malformed pattern: type ident is too long: %d\\n\", type_sz);\n\t\treturn -1;\n\t}\n\n\tif (field_sz >= sizeof(field_str)) {\n\t\tPRINT_FAIL(\"Malformed pattern: field ident is too long: %d\\n\", field_sz);\n\t\treturn -1;\n\t}\n\n\tstrncpy(type_str, type, type_sz);\n\tstrncpy(field_str, field, field_sz);\n\tbtf_id = btf__find_by_name(btf, type_str);\n\tif (btf_id < 0) {\n\t\tPRINT_FAIL(\"No BTF info for type %s\\n\", type_str);\n\t\treturn -1;\n\t}\n\n\tfield_offset = find_field_offset_aux(btf, btf_id, field_str, 0);\n\tif (field_offset < 0) {\n\t\tPRINT_FAIL(\"No BTF info for field %s::%s\\n\", type_str, field_str);\n\t\treturn -1;\n\t}\n\n\treturn field_offset;\n}\n\nstatic regex_t *compile_regex(char *pat)\n{\n\tregex_t *re;\n\tint err;\n\n\tre = malloc(sizeof(regex_t));\n\tif (!re) {\n\t\tPRINT_FAIL(\"Can't alloc regex\\n\");\n\t\treturn NULL;\n\t}\n\n\terr = regcomp(re, pat, REG_EXTENDED);\n\tif (err) {\n\t\tchar errbuf[512];\n\n\t\tregerror(err, re, errbuf, sizeof(errbuf));\n\t\tPRINT_FAIL(\"Can't compile regex: %s\\n\", errbuf);\n\t\tfree(re);\n\t\treturn NULL;\n\t}\n\n\treturn re;\n}\n\nstatic void free_regex(regex_t *re)\n{\n\tif (!re)\n\t\treturn;\n\n\tregfree(re);\n\tfree(re);\n}\n\nstatic u32 max_line_len(char *str)\n{\n\tu32 max_line = 0;\n\tchar *next = str;\n\n\twhile (next) {\n\t\tnext = strchr(str, '\\n');\n\t\tif (next) {\n\t\t\tmax_line = max_t(u32, max_line, (next - str));\n\t\t\tstr = next + 1;\n\t\t} else {\n\t\t\tmax_line = max_t(u32, max_line, strlen(str));\n\t\t}\n\t}\n\n\treturn min(max_line, 60u);\n}\n\n \nstatic void print_match_error(FILE *out,\n\t\t\t      char *pattern_origin, char *text_origin,\n\t\t\t      char *pattern_pos, char *text_pos)\n{\n\tchar *pattern = pattern_origin;\n\tchar *text = text_origin;\n\tint middle = max_line_len(text) + 2;\n\n\tfprintf(out, \"Can't match disassembly(left) with pattern(right):\\n\");\n\twhile (*pattern || *text) {\n\t\tint column = 0;\n\t\tint mark1 = -1;\n\t\tint mark2 = -1;\n\n\t\t \n\t\twhile (*text && *text != '\\n') {\n\t\t\tif (text == text_pos)\n\t\t\t\tmark1 = column;\n\t\t\tfputc(*text, out);\n\t\t\t++text;\n\t\t\t++column;\n\t\t}\n\t\tif (text == text_pos)\n\t\t\tmark1 = column;\n\n\t\t \n\t\twhile (column < middle) {\n\t\t\tfputc(' ', out);\n\t\t\t++column;\n\t\t}\n\t\tfputs(\";  \", out);\n\t\tcolumn += 3;\n\n\t\t \n\t\twhile (*pattern && *pattern != ';') {\n\t\t\tif (pattern == pattern_pos)\n\t\t\t\tmark2 = column;\n\t\t\tfputc(*pattern, out);\n\t\t\t++pattern;\n\t\t\t++column;\n\t\t}\n\t\tif (pattern == pattern_pos)\n\t\t\tmark2 = column;\n\n\t\tfputc('\\n', out);\n\t\tif (*pattern)\n\t\t\t++pattern;\n\t\tif (*text)\n\t\t\t++text;\n\n\t\t \n\t\tif (mark1 > 0 || mark2 > 0) {\n\t\t\tfor (column = 0; column <= max(mark1, mark2); ++column) {\n\t\t\t\tif (column == mark1 || column == mark2)\n\t\t\t\t\tfputc('^', out);\n\t\t\t\telse\n\t\t\t\t\tfputc(' ', out);\n\t\t\t}\n\t\t\tfputc('\\n', out);\n\t\t}\n\t}\n}\n\n \nstatic bool match_pattern(struct btf *btf, char *pattern, char *text, char *reg_map[][2])\n{\n\tchar *pattern_origin = pattern;\n\tchar *text_origin = text;\n\tregmatch_t matches[3];\n\n_continue:\n\twhile (*pattern) {\n\t\tif (!*text)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (isspace(*pattern) || *pattern == ';') {\n\t\t\tif (!isspace(*text) && text != text_origin && isalnum(text[-1]))\n\t\t\t\tgoto err;\n\t\t\tpattern = skip_space_and_semi(pattern);\n\t\t\ttext = skip_space(text);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (int i = 0; reg_map[i][0]; ++i) {\n\t\t\tchar *pattern_next, *text_next;\n\n\t\t\tpattern_next = match_str(pattern, reg_map[i][0]);\n\t\t\tif (!pattern_next)\n\t\t\t\tcontinue;\n\n\t\t\ttext_next = match_str(text, reg_map[i][1]);\n\t\t\tif (!text_next)\n\t\t\t\tgoto err;\n\n\t\t\tpattern = pattern_next;\n\t\t\ttext = text_next;\n\t\t\tgoto _continue;\n\t\t}\n\n\t\t \n\t\tif (strncmp(pattern, \"$(\", 2) == 0) {\n\t\t\tchar *group_start = pattern, *text_next;\n\t\t\tint acc_offset = 0;\n\n\t\t\tpattern += 2;\n\n\t\t\tfor (;;) {\n\t\t\t\tint field_offset;\n\n\t\t\t\tpattern = skip_space(pattern);\n\t\t\t\tif (!*pattern) {\n\t\t\t\t\tPRINT_FAIL(\"Unexpected end of pattern\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tif (*pattern == ')') {\n\t\t\t\t\t++pattern;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*pattern == '+') {\n\t\t\t\t\t++pattern;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprintf(\"pattern: %s\\n\", pattern);\n\t\t\t\tif (regexec(field_regex, pattern, 3, matches, 0) != 0) {\n\t\t\t\t\tPRINT_FAIL(\"Field reference expected\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tfield_offset = find_field_offset(btf, pattern, matches);\n\t\t\t\tif (field_offset < 0)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tpattern += matches[0].rm_eo;\n\t\t\t\tacc_offset += field_offset;\n\t\t\t}\n\n\t\t\ttext_next = match_number(text, acc_offset);\n\t\t\tif (!text_next) {\n\t\t\t\tPRINT_FAIL(\"No match for group offset %.*s (%d)\\n\",\n\t\t\t\t\t   (int)(pattern - group_start),\n\t\t\t\t\t   group_start,\n\t\t\t\t\t   acc_offset);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\ttext = text_next;\n\t\t}\n\n\t\t \n\t\tif (regexec(field_regex, pattern, 3, matches, 0) == 0) {\n\t\t\tint field_offset;\n\t\t\tchar *text_next;\n\n\t\t\tfield_offset = find_field_offset(btf, pattern, matches);\n\t\t\tif (field_offset < 0)\n\t\t\t\tgoto err;\n\n\t\t\ttext_next = match_number(text, field_offset);\n\t\t\tif (!text_next) {\n\t\t\t\tPRINT_FAIL(\"No match for field offset %.*s (%d)\\n\",\n\t\t\t\t\t   (int)matches[0].rm_eo, pattern, field_offset);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpattern += matches[0].rm_eo;\n\t\t\ttext = text_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (regexec(ident_regex, pattern, 1, matches, 0) == 0) {\n\t\t\tif (strncmp(pattern, text, matches[0].rm_eo) != 0)\n\t\t\t\tgoto err;\n\n\t\t\tpattern += matches[0].rm_eo;\n\t\t\ttext += matches[0].rm_eo;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (*pattern != *text)\n\t\t\tgoto err;\n\n\t\t++pattern;\n\t\t++text;\n\t}\n\n\treturn true;\n\nerr:\n\ttest__fail();\n\tprint_match_error(stdout, pattern_origin, text_origin, pattern, text);\n\treturn false;\n}\n\n \nstatic int get_xlated_program(int fd_prog, struct bpf_insn **buf, __u32 *cnt)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\t__u32 xlated_prog_len;\n\t__u32 buf_element_size = sizeof(struct bpf_insn);\n\n\tif (bpf_prog_get_info_by_fd(fd_prog, &info, &info_len)) {\n\t\tperror(\"bpf_prog_get_info_by_fd failed\");\n\t\treturn -1;\n\t}\n\n\txlated_prog_len = info.xlated_prog_len;\n\tif (xlated_prog_len % buf_element_size) {\n\t\tprintf(\"Program length %d is not multiple of %d\\n\",\n\t\t       xlated_prog_len, buf_element_size);\n\t\treturn -1;\n\t}\n\n\t*cnt = xlated_prog_len / buf_element_size;\n\t*buf = calloc(*cnt, buf_element_size);\n\tif (!buf) {\n\t\tperror(\"can't allocate xlated program buffer\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbzero(&info, sizeof(info));\n\tinfo.xlated_prog_len = xlated_prog_len;\n\tinfo.xlated_prog_insns = (__u64)(unsigned long)*buf;\n\tif (bpf_prog_get_info_by_fd(fd_prog, &info, &info_len)) {\n\t\tperror(\"second bpf_prog_get_info_by_fd failed\");\n\t\tgoto out_free_buf;\n\t}\n\n\treturn 0;\n\nout_free_buf:\n\tfree(*buf);\n\treturn -1;\n}\n\nstatic void print_insn(void *private_data, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf((FILE *)private_data, fmt, args);\n\tva_end(args);\n}\n\n \nstatic void print_xlated(FILE *out, struct bpf_insn *insn, __u32 len)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_print\t= print_insn,\n\t\t.cb_call\t= NULL,\n\t\t.cb_imm\t\t= NULL,\n\t\t.private_data\t= out,\n\t};\n\tbool double_insn = false;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (double_insn) {\n\t\t\tdouble_insn = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble_insn = insn[i].code == (BPF_LD | BPF_IMM | BPF_DW);\n\t\tprint_bpf_insn(&cbs, insn + i, true);\n\t}\n}\n\n \nstatic void remove_insn_prefix(char *str, int size)\n{\n\tconst int prefix_size = 5;\n\n\tint write_pos = 0, read_pos = prefix_size;\n\tint len = strlen(str);\n\tchar c;\n\n\tsize = min(size, len);\n\n\twhile (read_pos < size) {\n\t\tc = str[read_pos++];\n\t\tif (c == 0)\n\t\t\tbreak;\n\t\tstr[write_pos++] = c;\n\t\tif (c == '\\n')\n\t\t\tread_pos += prefix_size;\n\t}\n\tstr[write_pos] = 0;\n}\n\nstruct prog_info {\n\tchar *prog_kind;\n\tenum bpf_prog_type prog_type;\n\tenum bpf_attach_type expected_attach_type;\n\tstruct bpf_insn *prog;\n\tu32 prog_len;\n};\n\nstatic void match_program(struct btf *btf,\n\t\t\t  struct prog_info *pinfo,\n\t\t\t  char *pattern,\n\t\t\t  char *reg_map[][2],\n\t\t\t  bool skip_first_insn)\n{\n\tstruct bpf_insn *buf = NULL;\n\tint err = 0, prog_fd = 0;\n\tFILE *prog_out = NULL;\n\tchar *text = NULL;\n\t__u32 cnt = 0;\n\n\ttext = calloc(MAX_PROG_TEXT_SZ, 1);\n\tif (!text) {\n\t\tPRINT_FAIL(\"Can't allocate %d bytes\\n\", MAX_PROG_TEXT_SZ);\n\t\tgoto out;\n\t}\n\n\t \n\tLIBBPF_OPTS(bpf_prog_load_opts, opts);\n\topts.log_buf = text;\n\topts.log_size = MAX_PROG_TEXT_SZ;\n\topts.log_level = 1 | 2 | 4;\n\topts.expected_attach_type = pinfo->expected_attach_type;\n\n\tprog_fd = bpf_prog_load(pinfo->prog_type, NULL, \"GPL\",\n\t\t\t\tpinfo->prog, pinfo->prog_len, &opts);\n\tif (prog_fd < 0) {\n\t\tPRINT_FAIL(\"Can't load program, errno %d (%s), verifier log:\\n%s\\n\",\n\t\t\t   errno, strerror(errno), text);\n\t\tgoto out;\n\t}\n\n\tmemset(text, 0, MAX_PROG_TEXT_SZ);\n\n\terr = get_xlated_program(prog_fd, &buf, &cnt);\n\tif (err) {\n\t\tPRINT_FAIL(\"Can't load back BPF program\\n\");\n\t\tgoto out;\n\t}\n\n\tprog_out = fmemopen(text, MAX_PROG_TEXT_SZ - 1, \"w\");\n\tif (!prog_out) {\n\t\tPRINT_FAIL(\"Can't open memory stream\\n\");\n\t\tgoto out;\n\t}\n\tif (skip_first_insn)\n\t\tprint_xlated(prog_out, buf + 1, cnt - 1);\n\telse\n\t\tprint_xlated(prog_out, buf, cnt);\n\tfclose(prog_out);\n\tremove_insn_prefix(text, MAX_PROG_TEXT_SZ);\n\n\tASSERT_TRUE(match_pattern(btf, pattern, text, reg_map),\n\t\t    pinfo->prog_kind);\n\nout:\n\tif (prog_fd)\n\t\tclose(prog_fd);\n\tfree(buf);\n\tfree(text);\n}\n\nstatic void run_one_testcase(struct btf *btf, struct test_case *test)\n{\n\tstruct prog_info pinfo = {};\n\tint bpf_sz;\n\n\tif (!test__start_subtest(test->name))\n\t\treturn;\n\n\tswitch (test->field_sz) {\n\tcase 8:\n\t\tbpf_sz = BPF_DW;\n\t\tbreak;\n\tcase 4:\n\t\tbpf_sz = BPF_W;\n\t\tbreak;\n\tcase 2:\n\t\tbpf_sz = BPF_H;\n\t\tbreak;\n\tcase 1:\n\t\tbpf_sz = BPF_B;\n\t\tbreak;\n\tdefault:\n\t\tPRINT_FAIL(\"Unexpected field size: %d, want 8,4,2 or 1\\n\", test->field_sz);\n\t\treturn;\n\t}\n\n\tpinfo.prog_type = test->prog_type;\n\tpinfo.expected_attach_type = test->expected_attach_type;\n\n\tif (test->read) {\n\t\tstruct bpf_insn ldx_prog[] = {\n\t\t\tBPF_LDX_MEM(bpf_sz, BPF_REG_2, BPF_REG_1, test->field_offset),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t};\n\t\tchar *reg_map[][2] = {\n\t\t\t{ \"$ctx\", \"r1\" },\n\t\t\t{ \"$dst\", \"r2\" },\n\t\t\t{}\n\t\t};\n\n\t\tpinfo.prog_kind = \"LDX\";\n\t\tpinfo.prog = ldx_prog;\n\t\tpinfo.prog_len = ARRAY_SIZE(ldx_prog);\n\t\tmatch_program(btf, &pinfo, test->read, reg_map, false);\n\t}\n\n\tif (test->write || test->write_st || test->write_stx) {\n\t\tstruct bpf_insn stx_prog[] = {\n\t\t\tBPF_MOV64_IMM(BPF_REG_2, 0),\n\t\t\tBPF_STX_MEM(bpf_sz, BPF_REG_1, BPF_REG_2, test->field_offset),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t};\n\t\tchar *stx_reg_map[][2] = {\n\t\t\t{ \"$ctx\", \"r1\" },\n\t\t\t{ \"$src\", \"r2\" },\n\t\t\t{}\n\t\t};\n\t\tstruct bpf_insn st_prog[] = {\n\t\t\tBPF_ST_MEM(bpf_sz, BPF_REG_1, test->field_offset,\n\t\t\t\t   test->st_value.use ? test->st_value.value : 42),\n\t\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\t\tBPF_EXIT_INSN(),\n\t\t};\n\t\tchar *st_reg_map[][2] = {\n\t\t\t{ \"$ctx\", \"r1\" },\n\t\t\t{ \"$src\", \"42\" },\n\t\t\t{}\n\t\t};\n\n\t\tif (test->write || test->write_stx) {\n\t\t\tchar *pattern = test->write_stx ? test->write_stx : test->write;\n\n\t\t\tpinfo.prog_kind = \"STX\";\n\t\t\tpinfo.prog = stx_prog;\n\t\t\tpinfo.prog_len = ARRAY_SIZE(stx_prog);\n\t\t\tmatch_program(btf, &pinfo, pattern, stx_reg_map, true);\n\t\t}\n\n\t\tif (test->write || test->write_st) {\n\t\t\tchar *pattern = test->write_st ? test->write_st : test->write;\n\n\t\t\tpinfo.prog_kind = \"ST\";\n\t\t\tpinfo.prog = st_prog;\n\t\t\tpinfo.prog_len = ARRAY_SIZE(st_prog);\n\t\t\tmatch_program(btf, &pinfo, pattern, st_reg_map, false);\n\t\t}\n\t}\n\n\ttest__end_subtest();\n}\n\nvoid test_ctx_rewrite(void)\n{\n\tstruct btf *btf;\n\tint i;\n\n\tfield_regex = compile_regex(\"^([[:alpha:]_][[:alnum:]_]+)::([[:alpha:]_][[:alnum:]_]+)\");\n\tident_regex = compile_regex(\"^[[:alpha:]_][[:alnum:]_]+\");\n\tif (!field_regex || !ident_regex)\n\t\treturn;\n\n\tbtf = btf__load_vmlinux_btf();\n\tif (!btf) {\n\t\tPRINT_FAIL(\"Can't load vmlinux BTF, errno %d (%s)\\n\", errno, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); ++i)\n\t\trun_one_testcase(btf, &test_cases[i]);\n\nout:\n\tbtf__free(btf);\n\tfree_regex(field_regex);\n\tfree_regex(ident_regex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}