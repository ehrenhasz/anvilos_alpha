{
  "module_name": "bpf_cookie.c",
  "hash_id": "68a86f39593e9ec6d9f71545101fb7cd0e4a23b436e8f59fc33bad81974bf982",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_cookie.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <pthread.h>\n#include <sched.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <test_progs.h>\n#include <network_helpers.h>\n#include <bpf/btf.h>\n#include \"test_bpf_cookie.skel.h\"\n#include \"kprobe_multi.skel.h\"\n#include \"uprobe_multi.skel.h\"\n\n \nstatic noinline void trigger_func(void)\n{\n\tasm volatile (\"\");\n}\n\nstatic void kprobe_subtest(struct test_bpf_cookie *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_kprobe_opts, opts);\n\tstruct bpf_link *link1 = NULL, *link2 = NULL;\n\tstruct bpf_link *retlink1 = NULL, *retlink2 = NULL;\n\n\t \n\topts.bpf_cookie = 0x1;\n\topts.retprobe = false;\n\tlink1 = bpf_program__attach_kprobe_opts(skel->progs.handle_kprobe,\n\t\t\t\t\t\t SYS_NANOSLEEP_KPROBE_NAME, &opts);\n\tif (!ASSERT_OK_PTR(link1, \"link1\"))\n\t\tgoto cleanup;\n\n\topts.bpf_cookie = 0x2;\n\topts.retprobe = false;\n\tlink2 = bpf_program__attach_kprobe_opts(skel->progs.handle_kprobe,\n\t\t\t\t\t\t SYS_NANOSLEEP_KPROBE_NAME, &opts);\n\tif (!ASSERT_OK_PTR(link2, \"link2\"))\n\t\tgoto cleanup;\n\n\t \n\topts.bpf_cookie = 0x10;\n\topts.retprobe = true;\n\tretlink1 = bpf_program__attach_kprobe_opts(skel->progs.handle_kretprobe,\n\t\t\t\t\t\t    SYS_NANOSLEEP_KPROBE_NAME, &opts);\n\tif (!ASSERT_OK_PTR(retlink1, \"retlink1\"))\n\t\tgoto cleanup;\n\n\topts.bpf_cookie = 0x20;\n\topts.retprobe = true;\n\tretlink2 = bpf_program__attach_kprobe_opts(skel->progs.handle_kretprobe,\n\t\t\t\t\t\t    SYS_NANOSLEEP_KPROBE_NAME, &opts);\n\tif (!ASSERT_OK_PTR(retlink2, \"retlink2\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->kprobe_res, 0x1 | 0x2, \"kprobe_res\");\n\tASSERT_EQ(skel->bss->kretprobe_res, 0x10 | 0x20, \"kretprobe_res\");\n\ncleanup:\n\tbpf_link__destroy(link1);\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(retlink1);\n\tbpf_link__destroy(retlink2);\n}\n\nstatic void kprobe_multi_test_run(struct kprobe_multi *skel)\n{\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\tint err, prog_fd;\n\n\tprog_fd = bpf_program__fd(skel->progs.trigger);\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, 0, \"test_run\");\n\n\tASSERT_EQ(skel->bss->kprobe_test1_result, 1, \"kprobe_test1_result\");\n\tASSERT_EQ(skel->bss->kprobe_test2_result, 1, \"kprobe_test2_result\");\n\tASSERT_EQ(skel->bss->kprobe_test3_result, 1, \"kprobe_test3_result\");\n\tASSERT_EQ(skel->bss->kprobe_test4_result, 1, \"kprobe_test4_result\");\n\tASSERT_EQ(skel->bss->kprobe_test5_result, 1, \"kprobe_test5_result\");\n\tASSERT_EQ(skel->bss->kprobe_test6_result, 1, \"kprobe_test6_result\");\n\tASSERT_EQ(skel->bss->kprobe_test7_result, 1, \"kprobe_test7_result\");\n\tASSERT_EQ(skel->bss->kprobe_test8_result, 1, \"kprobe_test8_result\");\n\n\tASSERT_EQ(skel->bss->kretprobe_test1_result, 1, \"kretprobe_test1_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test2_result, 1, \"kretprobe_test2_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test3_result, 1, \"kretprobe_test3_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test4_result, 1, \"kretprobe_test4_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test5_result, 1, \"kretprobe_test5_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test6_result, 1, \"kretprobe_test6_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test7_result, 1, \"kretprobe_test7_result\");\n\tASSERT_EQ(skel->bss->kretprobe_test8_result, 1, \"kretprobe_test8_result\");\n}\n\nstatic void kprobe_multi_link_api_subtest(void)\n{\n\tint prog_fd, link1_fd = -1, link2_fd = -1;\n\tstruct kprobe_multi *skel = NULL;\n\tLIBBPF_OPTS(bpf_link_create_opts, opts);\n\tunsigned long long addrs[8];\n\t__u64 cookies[8];\n\n\tif (!ASSERT_OK(load_kallsyms(), \"load_kallsyms\"))\n\t\tgoto cleanup;\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"fentry_raw_skel_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\tskel->bss->test_cookie = true;\n\n#define GET_ADDR(__sym, __addr) ({\t\t\t\t\\\n\t__addr = ksym_get_addr(__sym);\t\t\t\t\\\n\tif (!ASSERT_NEQ(__addr, 0, \"ksym_get_addr \" #__sym))\t\\\n\t\tgoto cleanup;\t\t\t\t\t\\\n})\n\n\tGET_ADDR(\"bpf_fentry_test1\", addrs[0]);\n\tGET_ADDR(\"bpf_fentry_test3\", addrs[1]);\n\tGET_ADDR(\"bpf_fentry_test4\", addrs[2]);\n\tGET_ADDR(\"bpf_fentry_test5\", addrs[3]);\n\tGET_ADDR(\"bpf_fentry_test6\", addrs[4]);\n\tGET_ADDR(\"bpf_fentry_test7\", addrs[5]);\n\tGET_ADDR(\"bpf_fentry_test2\", addrs[6]);\n\tGET_ADDR(\"bpf_fentry_test8\", addrs[7]);\n\n#undef GET_ADDR\n\n\tcookies[0] = 1;  \n\tcookies[1] = 2;  \n\tcookies[2] = 3;  \n\tcookies[3] = 4;  \n\tcookies[4] = 5;  \n\tcookies[5] = 6;  \n\tcookies[6] = 7;  \n\tcookies[7] = 8;  \n\n\topts.kprobe_multi.addrs = (const unsigned long *) &addrs;\n\topts.kprobe_multi.cnt = ARRAY_SIZE(addrs);\n\topts.kprobe_multi.cookies = (const __u64 *) &cookies;\n\tprog_fd = bpf_program__fd(skel->progs.test_kprobe);\n\n\tlink1_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_KPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link1_fd, 0, \"link1_fd\"))\n\t\tgoto cleanup;\n\n\tcookies[0] = 8;  \n\tcookies[1] = 7;  \n\tcookies[2] = 6;  \n\tcookies[3] = 5;  \n\tcookies[4] = 4;  \n\tcookies[5] = 3;  \n\tcookies[6] = 2;  \n\tcookies[7] = 1;  \n\n\topts.kprobe_multi.flags = BPF_F_KPROBE_MULTI_RETURN;\n\tprog_fd = bpf_program__fd(skel->progs.test_kretprobe);\n\n\tlink2_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_KPROBE_MULTI, &opts);\n\tif (!ASSERT_GE(link2_fd, 0, \"link2_fd\"))\n\t\tgoto cleanup;\n\n\tkprobe_multi_test_run(skel);\n\ncleanup:\n\tclose(link1_fd);\n\tclose(link2_fd);\n\tkprobe_multi__destroy(skel);\n}\n\nstatic void kprobe_multi_attach_api_subtest(void)\n{\n\tstruct bpf_link *link1 = NULL, *link2 = NULL;\n\tLIBBPF_OPTS(bpf_kprobe_multi_opts, opts);\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\tstruct kprobe_multi *skel = NULL;\n\tconst char *syms[8] = {\n\t\t\"bpf_fentry_test1\",\n\t\t\"bpf_fentry_test3\",\n\t\t\"bpf_fentry_test4\",\n\t\t\"bpf_fentry_test5\",\n\t\t\"bpf_fentry_test6\",\n\t\t\"bpf_fentry_test7\",\n\t\t\"bpf_fentry_test2\",\n\t\t\"bpf_fentry_test8\",\n\t};\n\t__u64 cookies[8];\n\n\tskel = kprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"fentry_raw_skel_load\"))\n\t\tgoto cleanup;\n\n\tskel->bss->pid = getpid();\n\tskel->bss->test_cookie = true;\n\n\tcookies[0] = 1;  \n\tcookies[1] = 2;  \n\tcookies[2] = 3;  \n\tcookies[3] = 4;  \n\tcookies[4] = 5;  \n\tcookies[5] = 6;  \n\tcookies[6] = 7;  \n\tcookies[7] = 8;  \n\n\topts.syms = syms;\n\topts.cnt = ARRAY_SIZE(syms);\n\topts.cookies = cookies;\n\n\tlink1 = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kprobe,\n\t\t\t\t\t\t      NULL, &opts);\n\tif (!ASSERT_OK_PTR(link1, \"bpf_program__attach_kprobe_multi_opts\"))\n\t\tgoto cleanup;\n\n\tcookies[0] = 8;  \n\tcookies[1] = 7;  \n\tcookies[2] = 6;  \n\tcookies[3] = 5;  \n\tcookies[4] = 4;  \n\tcookies[5] = 3;  \n\tcookies[6] = 2;  \n\tcookies[7] = 1;  \n\n\topts.retprobe = true;\n\n\tlink2 = bpf_program__attach_kprobe_multi_opts(skel->progs.test_kretprobe,\n\t\t\t\t\t\t      NULL, &opts);\n\tif (!ASSERT_OK_PTR(link2, \"bpf_program__attach_kprobe_multi_opts\"))\n\t\tgoto cleanup;\n\n\tkprobe_multi_test_run(skel);\n\ncleanup:\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(link1);\n\tkprobe_multi__destroy(skel);\n}\n\n \nvoid uprobe_multi_func_1(void);\nvoid uprobe_multi_func_2(void);\nvoid uprobe_multi_func_3(void);\n\nstatic void uprobe_multi_test_run(struct uprobe_multi *skel)\n{\n\tskel->bss->uprobe_multi_func_1_addr = (__u64) uprobe_multi_func_1;\n\tskel->bss->uprobe_multi_func_2_addr = (__u64) uprobe_multi_func_2;\n\tskel->bss->uprobe_multi_func_3_addr = (__u64) uprobe_multi_func_3;\n\n\tskel->bss->pid = getpid();\n\tskel->bss->test_cookie = true;\n\n\tuprobe_multi_func_1();\n\tuprobe_multi_func_2();\n\tuprobe_multi_func_3();\n\n\tASSERT_EQ(skel->bss->uprobe_multi_func_1_result, 1, \"uprobe_multi_func_1_result\");\n\tASSERT_EQ(skel->bss->uprobe_multi_func_2_result, 1, \"uprobe_multi_func_2_result\");\n\tASSERT_EQ(skel->bss->uprobe_multi_func_3_result, 1, \"uprobe_multi_func_3_result\");\n\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_1_result, 1, \"uretprobe_multi_func_1_result\");\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_2_result, 1, \"uretprobe_multi_func_2_result\");\n\tASSERT_EQ(skel->bss->uretprobe_multi_func_3_result, 1, \"uretprobe_multi_func_3_result\");\n}\n\nstatic void uprobe_multi_attach_api_subtest(void)\n{\n\tstruct bpf_link *link1 = NULL, *link2 = NULL;\n\tstruct uprobe_multi *skel = NULL;\n\tLIBBPF_OPTS(bpf_uprobe_multi_opts, opts);\n\tconst char *syms[3] = {\n\t\t\"uprobe_multi_func_1\",\n\t\t\"uprobe_multi_func_2\",\n\t\t\"uprobe_multi_func_3\",\n\t};\n\t__u64 cookies[3];\n\n\tcookies[0] = 3;  \n\tcookies[1] = 1;  \n\tcookies[2] = 2;  \n\n\topts.syms = syms;\n\topts.cnt = ARRAY_SIZE(syms);\n\topts.cookies = &cookies[0];\n\n\tskel = uprobe_multi__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"uprobe_multi\"))\n\t\tgoto cleanup;\n\n\tlink1 = bpf_program__attach_uprobe_multi(skel->progs.uprobe, -1,\n\t\t\t\t\t\t \"/proc/self/exe\", NULL, &opts);\n\tif (!ASSERT_OK_PTR(link1, \"bpf_program__attach_uprobe_multi\"))\n\t\tgoto cleanup;\n\n\tcookies[0] = 2;  \n\tcookies[1] = 3;  \n\tcookies[2] = 1;  \n\n\topts.retprobe = true;\n\tlink2 = bpf_program__attach_uprobe_multi(skel->progs.uretprobe, -1,\n\t\t\t\t\t\t      \"/proc/self/exe\", NULL, &opts);\n\tif (!ASSERT_OK_PTR(link2, \"bpf_program__attach_uprobe_multi_retprobe\"))\n\t\tgoto cleanup;\n\n\tuprobe_multi_test_run(skel);\n\ncleanup:\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(link1);\n\tuprobe_multi__destroy(skel);\n}\n\nstatic void uprobe_subtest(struct test_bpf_cookie *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_uprobe_opts, opts);\n\tstruct bpf_link *link1 = NULL, *link2 = NULL;\n\tstruct bpf_link *retlink1 = NULL, *retlink2 = NULL;\n\tssize_t uprobe_offset;\n\n\tuprobe_offset = get_uprobe_offset(&trigger_func);\n\tif (!ASSERT_GE(uprobe_offset, 0, \"uprobe_offset\"))\n\t\tgoto cleanup;\n\n\t \n\topts.bpf_cookie = 0x100;\n\topts.retprobe = false;\n\tlink1 = bpf_program__attach_uprobe_opts(skel->progs.handle_uprobe, 0  ,\n\t\t\t\t\t\t\"/proc/self/exe\", uprobe_offset, &opts);\n\tif (!ASSERT_OK_PTR(link1, \"link1\"))\n\t\tgoto cleanup;\n\n\topts.bpf_cookie = 0x200;\n\topts.retprobe = false;\n\tlink2 = bpf_program__attach_uprobe_opts(skel->progs.handle_uprobe, -1  ,\n\t\t\t\t\t\t\"/proc/self/exe\", uprobe_offset, &opts);\n\tif (!ASSERT_OK_PTR(link2, \"link2\"))\n\t\tgoto cleanup;\n\n\t \n\topts.bpf_cookie = 0x1000;\n\topts.retprobe = true;\n\tretlink1 = bpf_program__attach_uprobe_opts(skel->progs.handle_uretprobe, -1  ,\n\t\t\t\t\t\t   \"/proc/self/exe\", uprobe_offset, &opts);\n\tif (!ASSERT_OK_PTR(retlink1, \"retlink1\"))\n\t\tgoto cleanup;\n\n\topts.bpf_cookie = 0x2000;\n\topts.retprobe = true;\n\tretlink2 = bpf_program__attach_uprobe_opts(skel->progs.handle_uretprobe, 0  ,\n\t\t\t\t\t\t   \"/proc/self/exe\", uprobe_offset, &opts);\n\tif (!ASSERT_OK_PTR(retlink2, \"retlink2\"))\n\t\tgoto cleanup;\n\n\t \n\ttrigger_func();\n\n\tASSERT_EQ(skel->bss->uprobe_res, 0x100 | 0x200, \"uprobe_res\");\n\tASSERT_EQ(skel->bss->uretprobe_res, 0x1000 | 0x2000, \"uretprobe_res\");\n\ncleanup:\n\tbpf_link__destroy(link1);\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(retlink1);\n\tbpf_link__destroy(retlink2);\n}\n\nstatic void tp_subtest(struct test_bpf_cookie *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_tracepoint_opts, opts);\n\tstruct bpf_link *link1 = NULL, *link2 = NULL, *link3 = NULL;\n\n\t \n\topts.bpf_cookie = 0x10000;\n\tlink1 = bpf_program__attach_tracepoint_opts(skel->progs.handle_tp1,\n\t\t\t\t\t\t    \"syscalls\", \"sys_enter_nanosleep\", &opts);\n\tif (!ASSERT_OK_PTR(link1, \"link1\"))\n\t\tgoto cleanup;\n\n\t \n\topts.bpf_cookie = 0x20000;\n\tlink2 = bpf_program__attach_tracepoint_opts(skel->progs.handle_tp2,\n\t\t\t\t\t\t    \"syscalls\", \"sys_enter_nanosleep\", &opts);\n\tif (!ASSERT_OK_PTR(link2, \"link2\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->tp_res, 0x10000 | 0x20000, \"tp_res1\");\n\n\t \n\tbpf_link__destroy(link1);\n\tlink1 = NULL;\n\tkern_sync_rcu();\n\tskel->bss->tp_res = 0;\n\n\t \n\topts.bpf_cookie = 0x40000;\n\tlink3 = bpf_program__attach_tracepoint_opts(skel->progs.handle_tp3,\n\t\t\t\t\t\t    \"syscalls\", \"sys_enter_nanosleep\", &opts);\n\tif (!ASSERT_OK_PTR(link3, \"link3\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->tp_res, 0x20000 | 0x40000, \"tp_res2\");\n\ncleanup:\n\tbpf_link__destroy(link1);\n\tbpf_link__destroy(link2);\n\tbpf_link__destroy(link3);\n}\n\nstatic void burn_cpu(void)\n{\n\tvolatile int j = 0;\n\tcpu_set_t cpu_set;\n\tint i, err;\n\n\t \n\tCPU_ZERO(&cpu_set);\n\tCPU_SET(0, &cpu_set);\n\terr = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set);\n\tASSERT_OK(err, \"set_thread_affinity\");\n\n\t \n\tfor (i = 0; i < 1000000; ++i)\n\t\t++j;\n}\n\nstatic void pe_subtest(struct test_bpf_cookie *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_perf_event_opts, opts);\n\tstruct bpf_link *link = NULL;\n\tstruct perf_event_attr attr;\n\tint pfd = -1;\n\n\t \n\tmemset(&attr, 0, sizeof(attr));\n\tattr.size = sizeof(attr);\n\tattr.type = PERF_TYPE_SOFTWARE;\n\tattr.config = PERF_COUNT_SW_CPU_CLOCK;\n\tattr.freq = 1;\n\tattr.sample_freq = 1000;\n\tpfd = syscall(__NR_perf_event_open, &attr, -1, 0, -1, PERF_FLAG_FD_CLOEXEC);\n\tif (!ASSERT_GE(pfd, 0, \"perf_fd\"))\n\t\tgoto cleanup;\n\n\topts.bpf_cookie = 0x100000;\n\tlink = bpf_program__attach_perf_event_opts(skel->progs.handle_pe, pfd, &opts);\n\tif (!ASSERT_OK_PTR(link, \"link1\"))\n\t\tgoto cleanup;\n\n\tburn_cpu();  \n\n\tASSERT_EQ(skel->bss->pe_res, 0x100000, \"pe_res1\");\n\n\t \n\tbpf_link__disconnect(link);\n\t \n\tclose(bpf_link__fd(link));\n\t \n\tbpf_link__destroy(link);\n\tlink = NULL;\n\tkern_sync_rcu();\n\tskel->bss->pe_res = 0;\n\n\topts.bpf_cookie = 0x200000;\n\tlink = bpf_program__attach_perf_event_opts(skel->progs.handle_pe, pfd, &opts);\n\tif (!ASSERT_OK_PTR(link, \"link2\"))\n\t\tgoto cleanup;\n\n\tburn_cpu();  \n\n\tASSERT_EQ(skel->bss->pe_res, 0x200000, \"pe_res2\");\n\ncleanup:\n\tclose(pfd);\n\tbpf_link__destroy(link);\n}\n\nstatic void tracing_subtest(struct test_bpf_cookie *skel)\n{\n\t__u64 cookie;\n\tint prog_fd;\n\tint fentry_fd = -1, fexit_fd = -1, fmod_ret_fd = -1;\n\tLIBBPF_OPTS(bpf_test_run_opts, opts);\n\tLIBBPF_OPTS(bpf_link_create_opts, link_opts);\n\n\tskel->bss->fentry_res = 0;\n\tskel->bss->fexit_res = 0;\n\n\tcookie = 0x10000000000000L;\n\tprog_fd = bpf_program__fd(skel->progs.fentry_test1);\n\tlink_opts.tracing.cookie = cookie;\n\tfentry_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_FENTRY, &link_opts);\n\tif (!ASSERT_GE(fentry_fd, 0, \"fentry.link_create\"))\n\t\tgoto cleanup;\n\n\tcookie = 0x20000000000000L;\n\tprog_fd = bpf_program__fd(skel->progs.fexit_test1);\n\tlink_opts.tracing.cookie = cookie;\n\tfexit_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_FEXIT, &link_opts);\n\tif (!ASSERT_GE(fexit_fd, 0, \"fexit.link_create\"))\n\t\tgoto cleanup;\n\n\tcookie = 0x30000000000000L;\n\tprog_fd = bpf_program__fd(skel->progs.fmod_ret_test);\n\tlink_opts.tracing.cookie = cookie;\n\tfmod_ret_fd = bpf_link_create(prog_fd, 0, BPF_MODIFY_RETURN, &link_opts);\n\tif (!ASSERT_GE(fmod_ret_fd, 0, \"fmod_ret.link_create\"))\n\t\tgoto cleanup;\n\n\tprog_fd = bpf_program__fd(skel->progs.fentry_test1);\n\tbpf_prog_test_run_opts(prog_fd, &opts);\n\n\tprog_fd = bpf_program__fd(skel->progs.fmod_ret_test);\n\tbpf_prog_test_run_opts(prog_fd, &opts);\n\n\tASSERT_EQ(skel->bss->fentry_res, 0x10000000000000L, \"fentry_res\");\n\tASSERT_EQ(skel->bss->fexit_res, 0x20000000000000L, \"fexit_res\");\n\tASSERT_EQ(skel->bss->fmod_ret_res, 0x30000000000000L, \"fmod_ret_res\");\n\ncleanup:\n\tif (fentry_fd >= 0)\n\t\tclose(fentry_fd);\n\tif (fexit_fd >= 0)\n\t\tclose(fexit_fd);\n\tif (fmod_ret_fd >= 0)\n\t\tclose(fmod_ret_fd);\n}\n\nint stack_mprotect(void);\n\nstatic void lsm_subtest(struct test_bpf_cookie *skel)\n{\n\t__u64 cookie;\n\tint prog_fd;\n\tint lsm_fd = -1;\n\tLIBBPF_OPTS(bpf_link_create_opts, link_opts);\n\tint err;\n\n\tskel->bss->lsm_res = 0;\n\n\tcookie = 0x90000000000090L;\n\tprog_fd = bpf_program__fd(skel->progs.test_int_hook);\n\tlink_opts.tracing.cookie = cookie;\n\tlsm_fd = bpf_link_create(prog_fd, 0, BPF_LSM_MAC, &link_opts);\n\tif (!ASSERT_GE(lsm_fd, 0, \"lsm.link_create\"))\n\t\tgoto cleanup;\n\n\terr = stack_mprotect();\n\tif (!ASSERT_EQ(err, -1, \"stack_mprotect\") ||\n\t    !ASSERT_EQ(errno, EPERM, \"stack_mprotect\"))\n\t\tgoto cleanup;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->lsm_res, 0x90000000000090L, \"fentry_res\");\n\ncleanup:\n\tif (lsm_fd >= 0)\n\t\tclose(lsm_fd);\n}\n\nvoid test_bpf_cookie(void)\n{\n\tstruct test_bpf_cookie *skel;\n\n\tskel = test_bpf_cookie__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tskel->bss->my_tid = syscall(SYS_gettid);\n\n\tif (test__start_subtest(\"kprobe\"))\n\t\tkprobe_subtest(skel);\n\tif (test__start_subtest(\"multi_kprobe_link_api\"))\n\t\tkprobe_multi_link_api_subtest();\n\tif (test__start_subtest(\"multi_kprobe_attach_api\"))\n\t\tkprobe_multi_attach_api_subtest();\n\tif (test__start_subtest(\"uprobe\"))\n\t\tuprobe_subtest(skel);\n\tif (test__start_subtest(\"multi_uprobe_attach_api\"))\n\t\tuprobe_multi_attach_api_subtest();\n\tif (test__start_subtest(\"tracepoint\"))\n\t\ttp_subtest(skel);\n\tif (test__start_subtest(\"perf_event\"))\n\t\tpe_subtest(skel);\n\tif (test__start_subtest(\"trampoline\"))\n\t\ttracing_subtest(skel);\n\tif (test__start_subtest(\"lsm\"))\n\t\tlsm_subtest(skel);\n\n\ttest_bpf_cookie__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}