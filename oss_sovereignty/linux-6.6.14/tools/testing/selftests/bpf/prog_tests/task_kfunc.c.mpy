{
  "module_name": "task_kfunc.c",
  "hash_id": "ee1e78d2c99421682dfd2890b73758a6c08b6076ee26cfaee7bb73aa9e628397",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/task_kfunc.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sys/wait.h>\n#include <test_progs.h>\n#include <unistd.h>\n\n#include \"task_kfunc_failure.skel.h\"\n#include \"task_kfunc_success.skel.h\"\n\nstatic struct task_kfunc_success *open_load_task_kfunc_skel(void)\n{\n\tstruct task_kfunc_success *skel;\n\tint err;\n\n\tskel = task_kfunc_success__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn NULL;\n\n\tskel->bss->pid = getpid();\n\n\terr = task_kfunc_success__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\treturn skel;\n\ncleanup:\n\ttask_kfunc_success__destroy(skel);\n\treturn NULL;\n}\n\nstatic void run_success_test(const char *prog_name)\n{\n\tstruct task_kfunc_success *skel;\n\tint status;\n\tpid_t child_pid;\n\tstruct bpf_program *prog;\n\tstruct bpf_link *link = NULL;\n\n\tskel = open_load_task_kfunc_skel();\n\tif (!ASSERT_OK_PTR(skel, \"open_load_skel\"))\n\t\treturn;\n\n\tif (!ASSERT_OK(skel->bss->err, \"pre_spawn_err\"))\n\t\tgoto cleanup;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto cleanup;\n\n\tlink = bpf_program__attach(prog);\n\tif (!ASSERT_OK_PTR(link, \"attached_link\"))\n\t\tgoto cleanup;\n\n\tchild_pid = fork();\n\tif (!ASSERT_GT(child_pid, -1, \"child_pid\"))\n\t\tgoto cleanup;\n\tif (child_pid == 0)\n\t\t_exit(0);\n\twaitpid(child_pid, &status, 0);\n\n\tASSERT_OK(skel->bss->err, \"post_wait_err\");\n\ncleanup:\n\tbpf_link__destroy(link);\n\ttask_kfunc_success__destroy(skel);\n}\n\nstatic const char * const success_tests[] = {\n\t\"test_task_acquire_release_argument\",\n\t\"test_task_acquire_release_current\",\n\t\"test_task_acquire_leave_in_map\",\n\t\"test_task_xchg_release\",\n\t\"test_task_map_acquire_release\",\n\t\"test_task_current_acquire_release\",\n\t\"test_task_from_pid_arg\",\n\t\"test_task_from_pid_current\",\n\t\"test_task_from_pid_invalid\",\n\t\"task_kfunc_acquire_trusted_walked\",\n\t\"test_task_kfunc_flavor_relo\",\n\t\"test_task_kfunc_flavor_relo_not_found\",\n};\n\nvoid test_task_kfunc(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(success_tests); i++) {\n\t\tif (!test__start_subtest(success_tests[i]))\n\t\t\tcontinue;\n\n\t\trun_success_test(success_tests[i]);\n\t}\n\n\tRUN_TESTS(task_kfunc_failure);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}