{
  "module_name": "bpf_obj_pinning.c",
  "hash_id": "b813bb4b20656854d90d0ed5615e6e449bfde67f98d451d1d9ba8fcd5330b497",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_obj_pinning.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <test_progs.h>\n#include <bpf/btf.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/unistd.h>\n#include <linux/mount.h>\n#include <sys/syscall.h>\n#include \"bpf/libbpf_internal.h\"\n\nstatic inline int sys_fsopen(const char *fsname, unsigned flags)\n{\n\treturn syscall(__NR_fsopen, fsname, flags);\n}\n\nstatic inline int sys_fsconfig(int fs_fd, unsigned cmd, const char *key, const void *val, int aux)\n{\n\treturn syscall(__NR_fsconfig, fs_fd, cmd, key, val, aux);\n}\n\nstatic inline int sys_fsmount(int fs_fd, unsigned flags, unsigned ms_flags)\n{\n\treturn syscall(__NR_fsmount, fs_fd, flags, ms_flags);\n}\n\n__attribute__((unused))\nstatic inline int sys_move_mount(int from_dfd, const char *from_path,\n\t\t\t         int to_dfd, const char *to_path,\n\t\t\t         unsigned int ms_flags)\n{\n\treturn syscall(__NR_move_mount, from_dfd, from_path, to_dfd, to_path, ms_flags);\n}\n\nstatic void bpf_obj_pinning_detached(void)\n{\n\tLIBBPF_OPTS(bpf_obj_pin_opts, pin_opts);\n\tLIBBPF_OPTS(bpf_obj_get_opts, get_opts);\n\tint fs_fd = -1, mnt_fd = -1;\n\tint map_fd = -1, map_fd2 = -1;\n\tint zero = 0, src_value, dst_value, err;\n\tconst char *map_name = \"fsmount_map\";\n\n\t \n\n\t \n\tfs_fd = sys_fsopen(\"bpf\", 0);\n\tif (!ASSERT_GE(fs_fd, 0, \"fs_fd\"))\n\t\tgoto cleanup;\n\n\t \n\terr = sys_fsconfig(fs_fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);\n\tif (!ASSERT_OK(err, \"fs_create\"))\n\t\tgoto cleanup;\n\n\t \n\tmnt_fd = sys_fsmount(fs_fd, 0, 0);\n\tif (!ASSERT_GE(mnt_fd, 0, \"mnt_fd\"))\n\t\tgoto cleanup;\n\n\t \n\n\t \n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, map_name, 4, 4, 1, NULL);\n\tif (!ASSERT_GE(map_fd, 0, \"map_fd\"))\n\t\tgoto cleanup;\n\n\t \n\tpin_opts.file_flags = BPF_F_PATH_FD;\n\tpin_opts.path_fd = mnt_fd;\n\terr = bpf_obj_pin_opts(map_fd, map_name, &pin_opts);\n\tif (!ASSERT_OK(err, \"map_pin\"))\n\t\tgoto cleanup;\n\n\t \n\tget_opts.file_flags = BPF_F_PATH_FD;\n\tget_opts.path_fd = mnt_fd;\n\tmap_fd2 = bpf_obj_get_opts(map_name, &get_opts);\n\tif (!ASSERT_GE(map_fd2, 0, \"map_get\"))\n\t\tgoto cleanup;\n\n\t \n\tsrc_value = 0xcafebeef;\n\terr = bpf_map_update_elem(map_fd, &zero, &src_value, 0);\n\tASSERT_OK(err, \"map_update\");\n\n\t \n\tdst_value = 0;\n\terr = bpf_map_lookup_elem(map_fd2, &zero, &dst_value);\n\tASSERT_OK(err, \"map_lookup\");\n\tASSERT_EQ(dst_value, src_value, \"map_value_eq1\");\n\tASSERT_EQ(dst_value, 0xcafebeef, \"map_value_eq2\");\n\ncleanup:\n\tif (map_fd >= 0)\n\t\tASSERT_OK(close(map_fd), \"close_map_fd\");\n\tif (map_fd2 >= 0)\n\t\tASSERT_OK(close(map_fd2), \"close_map_fd2\");\n\tif (fs_fd >= 0)\n\t\tASSERT_OK(close(fs_fd), \"close_fs_fd\");\n\tif (mnt_fd >= 0)\n\t\tASSERT_OK(close(mnt_fd), \"close_mnt_fd\");\n}\n\nenum path_kind\n{\n\tPATH_STR_ABS,\n\tPATH_STR_REL,\n\tPATH_FD_REL,\n};\n\nstatic void validate_pin(int map_fd, const char *map_name, int src_value,\n\t\t\t enum path_kind path_kind)\n{\n\tLIBBPF_OPTS(bpf_obj_pin_opts, pin_opts);\n\tchar abs_path[PATH_MAX], old_cwd[PATH_MAX];\n\tconst char *pin_path = NULL;\n\tint zero = 0, dst_value, map_fd2, err;\n\n\tsnprintf(abs_path, sizeof(abs_path), \"/sys/fs/bpf/%s\", map_name);\n\told_cwd[0] = '\\0';\n\n\tswitch (path_kind) {\n\tcase PATH_STR_ABS:\n\t\t \n\t\tpin_path = abs_path;\n\t\tbreak;\n\tcase PATH_STR_REL:\n\t\t \n\t\tASSERT_OK_PTR(getcwd(old_cwd, sizeof(old_cwd)), \"getcwd\");\n\t\tASSERT_OK(chdir(\"/sys/fs/bpf\"), \"chdir\");\n\t\tpin_path = map_name;\n\t\tbreak;\n\tcase PATH_FD_REL:\n\t\t \n\t\tpin_opts.file_flags = BPF_F_PATH_FD;\n\t\tpin_opts.path_fd = open(\"/sys/fs/bpf\", O_PATH);\n\t\tASSERT_GE(pin_opts.path_fd, 0, \"path_fd\");\n\t\tpin_path = map_name;\n\t\tbreak;\n\t}\n\n\t \n\terr = bpf_obj_pin_opts(map_fd, pin_path, &pin_opts);\n\tASSERT_OK(err, \"obj_pin\");\n\n\t \n\tif (path_kind == PATH_FD_REL && pin_opts.path_fd >= 0)\n\t\tclose(pin_opts.path_fd);\n\tif (old_cwd[0])\n\t\tASSERT_OK(chdir(old_cwd), \"restore_cwd\");\n\n\tmap_fd2 = bpf_obj_get(abs_path);\n\tif (!ASSERT_GE(map_fd2, 0, \"map_get\"))\n\t\tgoto cleanup;\n\n\t \n\terr = bpf_map_update_elem(map_fd, &zero, &src_value, 0);\n\tASSERT_OK(err, \"map_update\");\n\n\t \n\tdst_value = 0;\n\terr = bpf_map_lookup_elem(map_fd2, &zero, &dst_value);\n\tASSERT_OK(err, \"map_lookup\");\n\tASSERT_EQ(dst_value, src_value, \"map_value_eq\");\ncleanup:\n\tif (map_fd2 >= 0)\n\t\tASSERT_OK(close(map_fd2), \"close_map_fd2\");\n\tunlink(abs_path);\n}\n\nstatic void validate_get(int map_fd, const char *map_name, int src_value,\n\t\t\t enum path_kind path_kind)\n{\n\tLIBBPF_OPTS(bpf_obj_get_opts, get_opts);\n\tchar abs_path[PATH_MAX], old_cwd[PATH_MAX];\n\tconst char *pin_path = NULL;\n\tint zero = 0, dst_value, map_fd2, err;\n\n\tsnprintf(abs_path, sizeof(abs_path), \"/sys/fs/bpf/%s\", map_name);\n\t \n\terr = bpf_obj_pin(map_fd, abs_path);\n\tif (!ASSERT_OK(err, \"pin_map\"))\n\t\treturn;\n\n\told_cwd[0] = '\\0';\n\n\tswitch (path_kind) {\n\tcase PATH_STR_ABS:\n\t\t \n\t\tpin_path = abs_path;\n\t\tbreak;\n\tcase PATH_STR_REL:\n\t\t \n\t\tASSERT_OK_PTR(getcwd(old_cwd, sizeof(old_cwd)), \"getcwd\");\n\t\tASSERT_OK(chdir(\"/sys/fs/bpf\"), \"chdir\");\n\t\tpin_path = map_name;\n\t\tbreak;\n\tcase PATH_FD_REL:\n\t\t \n\t\tget_opts.file_flags = BPF_F_PATH_FD;\n\t\tget_opts.path_fd = open(\"/sys/fs/bpf\", O_PATH);\n\t\tASSERT_GE(get_opts.path_fd, 0, \"path_fd\");\n\t\tpin_path = map_name;\n\t\tbreak;\n\t}\n\n\tmap_fd2 = bpf_obj_get_opts(pin_path, &get_opts);\n\tif (!ASSERT_GE(map_fd2, 0, \"map_get\"))\n\t\tgoto cleanup;\n\n\t \n\tif (path_kind == PATH_FD_REL && get_opts.path_fd >= 0)\n\t\tclose(get_opts.path_fd);\n\tif (old_cwd[0])\n\t\tASSERT_OK(chdir(old_cwd), \"restore_cwd\");\n\n\t \n\terr = bpf_map_update_elem(map_fd, &zero, &src_value, 0);\n\tASSERT_OK(err, \"map_update\");\n\n\t \n\tdst_value = 0;\n\terr = bpf_map_lookup_elem(map_fd2, &zero, &dst_value);\n\tASSERT_OK(err, \"map_lookup\");\n\tASSERT_EQ(dst_value, src_value, \"map_value_eq\");\ncleanup:\n\tif (map_fd2 >= 0)\n\t\tASSERT_OK(close(map_fd2), \"close_map_fd2\");\n\tunlink(abs_path);\n}\n\nstatic void bpf_obj_pinning_mounted(enum path_kind path_kind)\n{\n\tconst char *map_name = \"mounted_map\";\n\tint map_fd;\n\n\t \n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, map_name, 4, 4, 1, NULL);\n\tif (!ASSERT_GE(map_fd, 0, \"map_fd\"))\n\t\treturn;\n\n\tvalidate_pin(map_fd, map_name, 100 + (int)path_kind, path_kind);\n\tvalidate_get(map_fd, map_name, 200 + (int)path_kind, path_kind);\n\tASSERT_OK(close(map_fd), \"close_map_fd\");\n}\n\nvoid test_bpf_obj_pinning()\n{\n\tif (test__start_subtest(\"detached\"))\n\t\tbpf_obj_pinning_detached();\n\tif (test__start_subtest(\"mounted-str-abs\"))\n\t\tbpf_obj_pinning_mounted(PATH_STR_ABS);\n\tif (test__start_subtest(\"mounted-str-rel\"))\n\t\tbpf_obj_pinning_mounted(PATH_STR_REL);\n\tif (test__start_subtest(\"mounted-fd-rel\"))\n\t\tbpf_obj_pinning_mounted(PATH_FD_REL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}