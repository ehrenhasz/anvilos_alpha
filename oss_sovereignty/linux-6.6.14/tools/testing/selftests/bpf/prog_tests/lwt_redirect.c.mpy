{
  "module_name": "lwt_redirect.c",
  "hash_id": "3eaea239a50d9d740839d90a4bdabafd18c77f2fa984ffa21bd0618a0468c747",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/lwt_redirect.c",
  "human_readable_source": "\n\n \n#include <sys/socket.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_tun.h>\n#include <linux/icmp.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"lwt_helpers.h\"\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n\n#define BPF_OBJECT            \"test_lwt_redirect.bpf.o\"\n#define INGRESS_SEC(need_mac) ((need_mac) ? \"redir_ingress\" : \"redir_ingress_nomac\")\n#define EGRESS_SEC(need_mac)  ((need_mac) ? \"redir_egress\" : \"redir_egress_nomac\")\n#define LOCAL_SRC             \"10.0.0.1\"\n#define CIDR_TO_INGRESS       \"10.0.0.0/24\"\n#define CIDR_TO_EGRESS        \"20.0.0.0/24\"\n\n \nstatic void ping_dev(const char *dev, bool is_ingress)\n{\n\tint link_index = if_nametoindex(dev);\n\tchar ip[256];\n\n\tif (!ASSERT_GE(link_index, 0, \"if_nametoindex\"))\n\t\treturn;\n\n\tif (is_ingress)\n\t\tsnprintf(ip, sizeof(ip), \"10.0.0.%d\", link_index);\n\telse\n\t\tsnprintf(ip, sizeof(ip), \"20.0.0.%d\", link_index);\n\n\t \n\tSYS_NOFAIL(\"ping %s -c1 -W1 -s %d >/dev/null 2>&1\",\n\t\t   ip, ICMP_PAYLOAD_SIZE);\n}\n\nstatic int new_packet_sock(const char *ifname)\n{\n\tint err = 0;\n\tint ignore_outgoing = 1;\n\tint ifindex = -1;\n\tint s = -1;\n\n\ts = socket(AF_PACKET, SOCK_RAW, 0);\n\tif (!ASSERT_GE(s, 0, \"socket(AF_PACKET)\"))\n\t\treturn -1;\n\n\tifindex = if_nametoindex(ifname);\n\tif (!ASSERT_GE(ifindex, 0, \"if_nametoindex\")) {\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\tstruct sockaddr_ll addr = {\n\t\t.sll_family = AF_PACKET,\n\t\t.sll_protocol = htons(ETH_P_IP),\n\t\t.sll_ifindex = ifindex,\n\t};\n\n\terr = bind(s, (struct sockaddr *)&addr, sizeof(addr));\n\tif (!ASSERT_OK(err, \"bind(AF_PACKET)\")) {\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\t \n\terr = setsockopt(s, SOL_PACKET, PACKET_IGNORE_OUTGOING,\n\t\t\t &ignore_outgoing, sizeof(ignore_outgoing));\n\tif (!ASSERT_OK(err, \"setsockopt(PACKET_IGNORE_OUTGOING)\")) {\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\terr = fcntl(s, F_SETFL, O_NONBLOCK);\n\tif (!ASSERT_OK(err, \"fcntl(O_NONBLOCK)\")) {\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\treturn s;\n}\n\nstatic int expect_icmp(char *buf, ssize_t len)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)buf;\n\n\tif (len < (ssize_t)sizeof(*eth))\n\t\treturn -1;\n\n\tif (eth->h_proto == htons(ETH_P_IP))\n\t\treturn __expect_icmp_ipv4((char *)(eth + 1), len - sizeof(*eth));\n\n\treturn -1;\n}\n\nstatic int expect_icmp_nomac(char *buf, ssize_t len)\n{\n\treturn __expect_icmp_ipv4(buf, len);\n}\n\nstatic void send_and_capture_test_packets(const char *test_name, int tap_fd,\n\t\t\t\t\t  const char *target_dev, bool need_mac)\n{\n\tint psock = -1;\n\tstruct timeval timeo = {\n\t\t.tv_sec = 0,\n\t\t.tv_usec = 250000,\n\t};\n\tint ret = -1;\n\n\tfilter_t filter = need_mac ? expect_icmp : expect_icmp_nomac;\n\n\tping_dev(target_dev, false);\n\n\tret = wait_for_packet(tap_fd, filter, &timeo);\n\tif (!ASSERT_EQ(ret, 1, \"wait_for_epacket\")) {\n\t\tlog_err(\"%s egress test fails\", test_name);\n\t\tgoto out;\n\t}\n\n\tpsock = new_packet_sock(target_dev);\n\tping_dev(target_dev, true);\n\n\tret = wait_for_packet(psock, filter, &timeo);\n\tif (!ASSERT_EQ(ret, 1, \"wait_for_ipacket\")) {\n\t\tlog_err(\"%s ingress test fails\", test_name);\n\t\tgoto out;\n\t}\n\nout:\n\tif (psock >= 0)\n\t\tclose(psock);\n}\n\nstatic int setup_redirect_target(const char *target_dev, bool need_mac)\n{\n\tint target_index = -1;\n\tint tap_fd = -1;\n\n\ttap_fd = open_tuntap(target_dev, need_mac);\n\tif (!ASSERT_GE(tap_fd, 0, \"open_tuntap\"))\n\t\tgoto fail;\n\n\ttarget_index = if_nametoindex(target_dev);\n\tif (!ASSERT_GE(target_index, 0, \"if_nametoindex\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip link add link_err type dummy\");\n\tSYS(fail, \"ip link set lo up\");\n\tSYS(fail, \"ip addr add dev lo \" LOCAL_SRC \"/32\");\n\tSYS(fail, \"ip link set link_err up\");\n\tSYS(fail, \"ip link set %s up\", target_dev);\n\n\tSYS(fail, \"ip route add %s dev link_err encap bpf xmit obj %s sec %s\",\n\t    CIDR_TO_INGRESS, BPF_OBJECT, INGRESS_SEC(need_mac));\n\n\tSYS(fail, \"ip route add %s dev link_err encap bpf xmit obj %s sec %s\",\n\t    CIDR_TO_EGRESS, BPF_OBJECT, EGRESS_SEC(need_mac));\n\n\treturn tap_fd;\n\nfail:\n\tif (tap_fd >= 0)\n\t\tclose(tap_fd);\n\treturn -1;\n}\n\nstatic void test_lwt_redirect_normal(void)\n{\n\tconst char *target_dev = \"tap0\";\n\tint tap_fd = -1;\n\tbool need_mac = true;\n\n\ttap_fd = setup_redirect_target(target_dev, need_mac);\n\tif (!ASSERT_GE(tap_fd, 0, \"setup_redirect_target\"))\n\t\treturn;\n\n\tsend_and_capture_test_packets(__func__, tap_fd, target_dev, need_mac);\n\tclose(tap_fd);\n}\n\nstatic void test_lwt_redirect_normal_nomac(void)\n{\n\tconst char *target_dev = \"tun0\";\n\tint tap_fd = -1;\n\tbool need_mac = false;\n\n\ttap_fd = setup_redirect_target(target_dev, need_mac);\n\tif (!ASSERT_GE(tap_fd, 0, \"setup_redirect_target\"))\n\t\treturn;\n\n\tsend_and_capture_test_packets(__func__, tap_fd, target_dev, need_mac);\n\tclose(tap_fd);\n}\n\n \nstatic void __test_lwt_redirect_dev_down(bool need_mac)\n{\n\tconst char *target_dev = \"tap0\";\n\tint tap_fd = -1;\n\n\ttap_fd = setup_redirect_target(target_dev, need_mac);\n\tif (!ASSERT_GE(tap_fd, 0, \"setup_redirect_target\"))\n\t\treturn;\n\n\tSYS(out, \"ip link set %s down\", target_dev);\n\tping_dev(target_dev, true);\n\tping_dev(target_dev, false);\n\nout:\n\tclose(tap_fd);\n}\n\nstatic void test_lwt_redirect_dev_down(void)\n{\n\t__test_lwt_redirect_dev_down(true);\n}\n\nstatic void test_lwt_redirect_dev_down_nomac(void)\n{\n\t__test_lwt_redirect_dev_down(false);\n}\n\n \nstatic void test_lwt_redirect_dev_carrier_down(void)\n{\n\tconst char *lower_dev = \"tap0\";\n\tconst char *vlan_dev = \"vlan100\";\n\tint tap_fd = -1;\n\n\ttap_fd = setup_redirect_target(lower_dev, true);\n\tif (!ASSERT_GE(tap_fd, 0, \"setup_redirect_target\"))\n\t\treturn;\n\n\tSYS(out, \"ip link add vlan100 link %s type vlan id 100\", lower_dev);\n\tSYS(out, \"ip link set %s up\", vlan_dev);\n\tSYS(out, \"ip link set %s down\", lower_dev);\n\tping_dev(vlan_dev, true);\n\tping_dev(vlan_dev, false);\n\nout:\n\tclose(tap_fd);\n}\n\nstatic void *test_lwt_redirect_run(void *arg)\n{\n\tnetns_delete();\n\tRUN_TEST(lwt_redirect_normal);\n\tRUN_TEST(lwt_redirect_normal_nomac);\n\tRUN_TEST(lwt_redirect_dev_down);\n\tRUN_TEST(lwt_redirect_dev_down_nomac);\n\tRUN_TEST(lwt_redirect_dev_carrier_down);\n\treturn NULL;\n}\n\nvoid test_lwt_redirect(void)\n{\n\tpthread_t test_thread;\n\tint err;\n\n\t \n\terr = pthread_create(&test_thread, NULL, &test_lwt_redirect_run, NULL);\n\tif (ASSERT_OK(err, \"pthread_create\"))\n\t\tASSERT_OK(pthread_join(test_thread, NULL), \"pthread_join\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}