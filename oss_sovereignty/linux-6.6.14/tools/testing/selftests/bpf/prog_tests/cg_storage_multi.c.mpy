{
  "module_name": "cg_storage_multi.c",
  "hash_id": "1e6008339e7f52094601d2ffbfc1e46c6e29ec01a075b4811cef0ce1dba4d358",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cg_storage_multi.c",
  "human_readable_source": "\n\n \n\n#include <test_progs.h>\n#include <cgroup_helpers.h>\n#include <network_helpers.h>\n\n#include \"progs/cg_storage_multi.h\"\n\n#include \"cg_storage_multi_egress_only.skel.h\"\n#include \"cg_storage_multi_isolated.skel.h\"\n#include \"cg_storage_multi_shared.skel.h\"\n\n#define PARENT_CGROUP \"/cgroup_storage\"\n#define CHILD_CGROUP \"/cgroup_storage/child\"\n\nstatic int duration;\n\nstatic bool assert_storage(struct bpf_map *map, const void *key,\n\t\t\t   struct cgroup_value *expected)\n{\n\tstruct cgroup_value value;\n\tint map_fd;\n\n\tmap_fd = bpf_map__fd(map);\n\n\tif (CHECK(bpf_map_lookup_elem(map_fd, key, &value) < 0,\n\t\t  \"map-lookup\", \"errno %d\", errno))\n\t\treturn true;\n\tif (CHECK(memcmp(&value, expected, sizeof(struct cgroup_value)),\n\t\t  \"assert-storage\", \"storages differ\"))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool assert_storage_noexist(struct bpf_map *map, const void *key)\n{\n\tstruct cgroup_value value;\n\tint map_fd;\n\n\tmap_fd = bpf_map__fd(map);\n\n\tif (CHECK(bpf_map_lookup_elem(map_fd, key, &value) == 0,\n\t\t  \"map-lookup\", \"succeeded, expected ENOENT\"))\n\t\treturn true;\n\tif (CHECK(errno != ENOENT,\n\t\t  \"map-lookup\", \"errno %d, expected ENOENT\", errno))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool connect_send(const char *cgroup_path)\n{\n\tint server_fd = -1, client_fd = -1;\n\tchar message[] = \"message\";\n\tbool res = true;\n\n\tif (join_cgroup(cgroup_path))\n\t\tgoto out_clean;\n\n\tserver_fd = start_server(AF_INET, SOCK_DGRAM, NULL, 0, 0);\n\tif (server_fd < 0)\n\t\tgoto out_clean;\n\n\tclient_fd = connect_to_fd(server_fd, 0);\n\tif (client_fd < 0)\n\t\tgoto out_clean;\n\n\tif (send(client_fd, &message, sizeof(message), 0) < 0)\n\t\tgoto out_clean;\n\n\tif (read(server_fd, &message, sizeof(message)) < 0)\n\t\tgoto out_clean;\n\n\tres = false;\n\nout_clean:\n\tclose(client_fd);\n\tclose(server_fd);\n\treturn res;\n}\n\nstatic void test_egress_only(int parent_cgroup_fd, int child_cgroup_fd)\n{\n\tstruct cg_storage_multi_egress_only *obj;\n\tstruct cgroup_value expected_cgroup_value;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_link *parent_link = NULL, *child_link = NULL;\n\tbool err;\n\n\tkey.attach_type = BPF_CGROUP_INET_EGRESS;\n\n\tobj = cg_storage_multi_egress_only__open_and_load();\n\tif (CHECK(!obj, \"skel-load\", \"errno %d\", errno))\n\t\treturn;\n\n\t \n\tparent_link = bpf_program__attach_cgroup(obj->progs.egress,\n\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_link, \"parent-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"first-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 1,\n\t\t  \"first-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(PARENT_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 1 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(CHILD_CGROUP);\n\tif (assert_storage_noexist(obj->maps.cgroup_storage, &key))\n\t\tgoto close_bpf_object;\n\n\t \n\tchild_link = bpf_program__attach_cgroup(obj->progs.egress,\n\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_link, \"child-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"second-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 3,\n\t\t  \"second-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(PARENT_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 2 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(CHILD_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 1 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\nclose_bpf_object:\n\tbpf_link__destroy(parent_link);\n\tbpf_link__destroy(child_link);\n\n\tcg_storage_multi_egress_only__destroy(obj);\n}\n\nstatic void test_isolated(int parent_cgroup_fd, int child_cgroup_fd)\n{\n\tstruct cg_storage_multi_isolated *obj;\n\tstruct cgroup_value expected_cgroup_value;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct bpf_link *parent_egress1_link = NULL, *parent_egress2_link = NULL;\n\tstruct bpf_link *child_egress1_link = NULL, *child_egress2_link = NULL;\n\tstruct bpf_link *parent_ingress_link = NULL, *child_ingress_link = NULL;\n\tbool err;\n\n\tobj = cg_storage_multi_isolated__open_and_load();\n\tif (CHECK(!obj, \"skel-load\", \"errno %d\", errno))\n\t\treturn;\n\n\t \n\tparent_egress1_link = bpf_program__attach_cgroup(obj->progs.egress1,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_egress1_link, \"parent-egress1-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tparent_egress2_link = bpf_program__attach_cgroup(obj->progs.egress2,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_egress2_link, \"parent-egress2-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tparent_ingress_link = bpf_program__attach_cgroup(obj->progs.ingress,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_ingress_link, \"parent-ingress-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"first-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 3,\n\t\t  \"first-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(PARENT_CGROUP);\n\tkey.attach_type = BPF_CGROUP_INET_EGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 2 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.attach_type = BPF_CGROUP_INET_INGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .ingress_pkts = 1 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(CHILD_CGROUP);\n\tkey.attach_type = BPF_CGROUP_INET_EGRESS;\n\tif (assert_storage_noexist(obj->maps.cgroup_storage, &key))\n\t\tgoto close_bpf_object;\n\tkey.attach_type = BPF_CGROUP_INET_INGRESS;\n\tif (assert_storage_noexist(obj->maps.cgroup_storage, &key))\n\t\tgoto close_bpf_object;\n\n\t \n\tchild_egress1_link = bpf_program__attach_cgroup(obj->progs.egress1,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_egress1_link, \"child-egress1-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tchild_egress2_link = bpf_program__attach_cgroup(obj->progs.egress2,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_egress2_link, \"child-egress2-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tchild_ingress_link = bpf_program__attach_cgroup(obj->progs.ingress,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_ingress_link, \"child-ingress-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"second-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 9,\n\t\t  \"second-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(PARENT_CGROUP);\n\tkey.attach_type = BPF_CGROUP_INET_EGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 4 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.attach_type = BPF_CGROUP_INET_INGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .ingress_pkts = 2 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.cgroup_inode_id = get_cgroup_id(CHILD_CGROUP);\n\tkey.attach_type = BPF_CGROUP_INET_EGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .egress_pkts = 2 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey.attach_type = BPF_CGROUP_INET_INGRESS;\n\texpected_cgroup_value = (struct cgroup_value) { .ingress_pkts = 1 };\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\nclose_bpf_object:\n\tbpf_link__destroy(parent_egress1_link);\n\tbpf_link__destroy(parent_egress2_link);\n\tbpf_link__destroy(parent_ingress_link);\n\tbpf_link__destroy(child_egress1_link);\n\tbpf_link__destroy(child_egress2_link);\n\tbpf_link__destroy(child_ingress_link);\n\n\tcg_storage_multi_isolated__destroy(obj);\n}\n\nstatic void test_shared(int parent_cgroup_fd, int child_cgroup_fd)\n{\n\tstruct cg_storage_multi_shared *obj;\n\tstruct cgroup_value expected_cgroup_value;\n\t__u64 key;\n\tstruct bpf_link *parent_egress1_link = NULL, *parent_egress2_link = NULL;\n\tstruct bpf_link *child_egress1_link = NULL, *child_egress2_link = NULL;\n\tstruct bpf_link *parent_ingress_link = NULL, *child_ingress_link = NULL;\n\tbool err;\n\n\tobj = cg_storage_multi_shared__open_and_load();\n\tif (CHECK(!obj, \"skel-load\", \"errno %d\", errno))\n\t\treturn;\n\n\t \n\tparent_egress1_link = bpf_program__attach_cgroup(obj->progs.egress1,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_egress1_link, \"parent-egress1-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tparent_egress2_link = bpf_program__attach_cgroup(obj->progs.egress2,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_egress2_link, \"parent-egress2-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tparent_ingress_link = bpf_program__attach_cgroup(obj->progs.ingress,\n\t\t\t\t\t\t\t parent_cgroup_fd);\n\tif (!ASSERT_OK_PTR(parent_ingress_link, \"parent-ingress-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"first-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 3,\n\t\t  \"first-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey = get_cgroup_id(PARENT_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) {\n\t\t.egress_pkts = 2,\n\t\t.ingress_pkts = 1,\n\t};\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey = get_cgroup_id(CHILD_CGROUP);\n\tif (assert_storage_noexist(obj->maps.cgroup_storage, &key))\n\t\tgoto close_bpf_object;\n\n\t \n\tchild_egress1_link = bpf_program__attach_cgroup(obj->progs.egress1,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_egress1_link, \"child-egress1-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tchild_egress2_link = bpf_program__attach_cgroup(obj->progs.egress2,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_egress2_link, \"child-egress2-cg-attach\"))\n\t\tgoto close_bpf_object;\n\tchild_ingress_link = bpf_program__attach_cgroup(obj->progs.ingress,\n\t\t\t\t\t\t\tchild_cgroup_fd);\n\tif (!ASSERT_OK_PTR(child_ingress_link, \"child-ingress-cg-attach\"))\n\t\tgoto close_bpf_object;\n\terr = connect_send(CHILD_CGROUP);\n\tif (CHECK(err, \"second-connect-send\", \"errno %d\", errno))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->bss->invocations != 9,\n\t\t  \"second-invoke\", \"invocations=%d\", obj->bss->invocations))\n\t\tgoto close_bpf_object;\n\tkey = get_cgroup_id(PARENT_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) {\n\t\t.egress_pkts = 4,\n\t\t.ingress_pkts = 2,\n\t};\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\tkey = get_cgroup_id(CHILD_CGROUP);\n\texpected_cgroup_value = (struct cgroup_value) {\n\t\t.egress_pkts = 2,\n\t\t.ingress_pkts = 1,\n\t};\n\tif (assert_storage(obj->maps.cgroup_storage,\n\t\t\t   &key, &expected_cgroup_value))\n\t\tgoto close_bpf_object;\n\nclose_bpf_object:\n\tbpf_link__destroy(parent_egress1_link);\n\tbpf_link__destroy(parent_egress2_link);\n\tbpf_link__destroy(parent_ingress_link);\n\tbpf_link__destroy(child_egress1_link);\n\tbpf_link__destroy(child_egress2_link);\n\tbpf_link__destroy(child_ingress_link);\n\n\tcg_storage_multi_shared__destroy(obj);\n}\n\nvoid serial_test_cg_storage_multi(void)\n{\n\tint parent_cgroup_fd = -1, child_cgroup_fd = -1;\n\n\tparent_cgroup_fd = test__join_cgroup(PARENT_CGROUP);\n\tif (CHECK(parent_cgroup_fd < 0, \"cg-create-parent\", \"errno %d\", errno))\n\t\tgoto close_cgroup_fd;\n\tchild_cgroup_fd = create_and_get_cgroup(CHILD_CGROUP);\n\tif (CHECK(child_cgroup_fd < 0, \"cg-create-child\", \"errno %d\", errno))\n\t\tgoto close_cgroup_fd;\n\n\tif (test__start_subtest(\"egress_only\"))\n\t\ttest_egress_only(parent_cgroup_fd, child_cgroup_fd);\n\n\tif (test__start_subtest(\"isolated\"))\n\t\ttest_isolated(parent_cgroup_fd, child_cgroup_fd);\n\n\tif (test__start_subtest(\"shared\"))\n\t\ttest_shared(parent_cgroup_fd, child_cgroup_fd);\n\nclose_cgroup_fd:\n\tclose(child_cgroup_fd);\n\tclose(parent_cgroup_fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}