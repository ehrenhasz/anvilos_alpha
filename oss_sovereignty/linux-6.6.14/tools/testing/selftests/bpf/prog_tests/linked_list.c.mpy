{
  "module_name": "linked_list.c",
  "hash_id": "57926faec90cb14ba7ce02df28c82e6c71506733a79e75ad01b3d99304133101",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/linked_list.c",
  "human_readable_source": "\n#include <bpf/btf.h>\n#include <test_btf.h>\n#include <linux/btf.h>\n#include <test_progs.h>\n#include <network_helpers.h>\n\n#include \"linked_list.skel.h\"\n#include \"linked_list_fail.skel.h\"\n\nstatic char log_buf[1024 * 1024];\n\nstatic struct {\n\tconst char *prog_name;\n\tconst char *err_msg;\n} linked_list_fail_tests[] = {\n#define TEST(test, off) \\\n\t{ #test \"_missing_lock_push_front\", \\\n\t  \"bpf_spin_lock at off=\" #off \" must be held for bpf_list_head\" }, \\\n\t{ #test \"_missing_lock_push_back\", \\\n\t  \"bpf_spin_lock at off=\" #off \" must be held for bpf_list_head\" }, \\\n\t{ #test \"_missing_lock_pop_front\", \\\n\t  \"bpf_spin_lock at off=\" #off \" must be held for bpf_list_head\" }, \\\n\t{ #test \"_missing_lock_pop_back\", \\\n\t  \"bpf_spin_lock at off=\" #off \" must be held for bpf_list_head\" },\n\tTEST(kptr, 40)\n\tTEST(global, 16)\n\tTEST(map, 0)\n\tTEST(inner_map, 0)\n#undef TEST\n#define TEST(test, op) \\\n\t{ #test \"_kptr_incorrect_lock_\" #op, \\\n\t  \"held lock and object are not in the same allocation\\n\" \\\n\t  \"bpf_spin_lock at off=40 must be held for bpf_list_head\" }, \\\n\t{ #test \"_global_incorrect_lock_\" #op, \\\n\t  \"held lock and object are not in the same allocation\\n\" \\\n\t  \"bpf_spin_lock at off=16 must be held for bpf_list_head\" }, \\\n\t{ #test \"_map_incorrect_lock_\" #op, \\\n\t  \"held lock and object are not in the same allocation\\n\" \\\n\t  \"bpf_spin_lock at off=0 must be held for bpf_list_head\" }, \\\n\t{ #test \"_inner_map_incorrect_lock_\" #op, \\\n\t  \"held lock and object are not in the same allocation\\n\" \\\n\t  \"bpf_spin_lock at off=0 must be held for bpf_list_head\" },\n\tTEST(kptr, push_front)\n\tTEST(kptr, push_back)\n\tTEST(kptr, pop_front)\n\tTEST(kptr, pop_back)\n\tTEST(global, push_front)\n\tTEST(global, push_back)\n\tTEST(global, pop_front)\n\tTEST(global, pop_back)\n\tTEST(map, push_front)\n\tTEST(map, push_back)\n\tTEST(map, pop_front)\n\tTEST(map, pop_back)\n\tTEST(inner_map, push_front)\n\tTEST(inner_map, push_back)\n\tTEST(inner_map, pop_front)\n\tTEST(inner_map, pop_back)\n#undef TEST\n\t{ \"map_compat_kprobe\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"map_compat_kretprobe\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"map_compat_tp\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"map_compat_perf\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"map_compat_raw_tp\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"map_compat_raw_tp_w\", \"tracing progs cannot use bpf_{list_head,rb_root} yet\" },\n\t{ \"obj_type_id_oor\", \"local type ID argument must be in range [0, U32_MAX]\" },\n\t{ \"obj_new_no_composite\", \"bpf_obj_new type ID argument must be of a struct\" },\n\t{ \"obj_new_no_struct\", \"bpf_obj_new type ID argument must be of a struct\" },\n\t{ \"obj_drop_non_zero_off\", \"R1 must have zero offset when passed to release func\" },\n\t{ \"new_null_ret\", \"R0 invalid mem access 'ptr_or_null_'\" },\n\t{ \"obj_new_acq\", \"Unreleased reference id=\" },\n\t{ \"use_after_drop\", \"invalid mem access 'scalar'\" },\n\t{ \"ptr_walk_scalar\", \"type=scalar expected=percpu_ptr_\" },\n\t{ \"direct_read_lock\", \"direct access to bpf_spin_lock is disallowed\" },\n\t{ \"direct_write_lock\", \"direct access to bpf_spin_lock is disallowed\" },\n\t{ \"direct_read_head\", \"direct access to bpf_list_head is disallowed\" },\n\t{ \"direct_write_head\", \"direct access to bpf_list_head is disallowed\" },\n\t{ \"direct_read_node\", \"direct access to bpf_list_node is disallowed\" },\n\t{ \"direct_write_node\", \"direct access to bpf_list_node is disallowed\" },\n\t{ \"use_after_unlock_push_front\", \"invalid mem access 'scalar'\" },\n\t{ \"use_after_unlock_push_back\", \"invalid mem access 'scalar'\" },\n\t{ \"double_push_front\", \"arg#1 expected pointer to allocated object\" },\n\t{ \"double_push_back\", \"arg#1 expected pointer to allocated object\" },\n\t{ \"no_node_value_type\", \"bpf_list_node not found at offset=0\" },\n\t{ \"incorrect_value_type\",\n\t  \"operation on bpf_list_head expects arg#1 bpf_list_node at offset=48 in struct foo, \"\n\t  \"but arg is at offset=0 in struct bar\" },\n\t{ \"incorrect_node_var_off\", \"variable ptr_ access var_off=(0x0; 0xffffffff) disallowed\" },\n\t{ \"incorrect_node_off1\", \"bpf_list_node not found at offset=49\" },\n\t{ \"incorrect_node_off2\", \"arg#1 offset=0, but expected bpf_list_node at offset=48 in struct foo\" },\n\t{ \"no_head_type\", \"bpf_list_head not found at offset=0\" },\n\t{ \"incorrect_head_var_off1\", \"R1 doesn't have constant offset\" },\n\t{ \"incorrect_head_var_off2\", \"variable ptr_ access var_off=(0x0; 0xffffffff) disallowed\" },\n\t{ \"incorrect_head_off1\", \"bpf_list_head not found at offset=25\" },\n\t{ \"incorrect_head_off2\", \"bpf_list_head not found at offset=1\" },\n\t{ \"pop_front_off\", \"off 48 doesn't point to 'struct bpf_spin_lock' that is at 40\" },\n\t{ \"pop_back_off\", \"off 48 doesn't point to 'struct bpf_spin_lock' that is at 40\" },\n};\n\nstatic void test_linked_list_fail_prog(const char *prog_name, const char *err_msg)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, opts, .kernel_log_buf = log_buf,\n\t\t\t\t\t\t.kernel_log_size = sizeof(log_buf),\n\t\t\t\t\t\t.kernel_log_level = 1);\n\tstruct linked_list_fail *skel;\n\tstruct bpf_program *prog;\n\tint ret;\n\n\tskel = linked_list_fail__open_opts(&opts);\n\tif (!ASSERT_OK_PTR(skel, \"linked_list_fail__open_opts\"))\n\t\treturn;\n\n\tprog = bpf_object__find_program_by_name(skel->obj, prog_name);\n\tif (!ASSERT_OK_PTR(prog, \"bpf_object__find_program_by_name\"))\n\t\tgoto end;\n\n\tbpf_program__set_autoload(prog, true);\n\n\tret = linked_list_fail__load(skel);\n\tif (!ASSERT_ERR(ret, \"linked_list_fail__load must fail\"))\n\t\tgoto end;\n\n\tif (!ASSERT_OK_PTR(strstr(log_buf, err_msg), \"expected error message\")) {\n\t\tfprintf(stderr, \"Expected: %s\\n\", err_msg);\n\t\tfprintf(stderr, \"Verifier: %s\\n\", log_buf);\n\t}\n\nend:\n\tlinked_list_fail__destroy(skel);\n}\n\nstatic void clear_fields(struct bpf_map *map)\n{\n\tchar buf[24];\n\tint key = 0;\n\n\tmemset(buf, 0xff, sizeof(buf));\n\tASSERT_OK(bpf_map__update_elem(map, &key, sizeof(key), buf, sizeof(buf), 0), \"check_and_free_fields\");\n}\n\nenum {\n\tTEST_ALL,\n\tPUSH_POP,\n\tPUSH_POP_MULT,\n\tLIST_IN_LIST,\n};\n\nstatic void test_linked_list_success(int mode, bool leave_in_map)\n{\n\tLIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\tstruct linked_list *skel;\n\tint ret;\n\n\tskel = linked_list__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"linked_list__open_and_load\"))\n\t\treturn;\n\n\tif (mode == LIST_IN_LIST)\n\t\tgoto lil;\n\tif (mode == PUSH_POP_MULT)\n\t\tgoto ppm;\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.map_list_push_pop), &opts);\n\tASSERT_OK(ret, \"map_list_push_pop\");\n\tASSERT_OK(opts.retval, \"map_list_push_pop retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.array_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.inner_map_list_push_pop), &opts);\n\tASSERT_OK(ret, \"inner_map_list_push_pop\");\n\tASSERT_OK(opts.retval, \"inner_map_list_push_pop retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.inner_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.global_list_push_pop), &opts);\n\tASSERT_OK(ret, \"global_list_push_pop\");\n\tASSERT_OK(opts.retval, \"global_list_push_pop retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.bss_A);\n\n\tif (mode == PUSH_POP)\n\t\tgoto end;\n\nppm:\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.map_list_push_pop_multiple), &opts);\n\tASSERT_OK(ret, \"map_list_push_pop_multiple\");\n\tASSERT_OK(opts.retval, \"map_list_push_pop_multiple retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.array_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.inner_map_list_push_pop_multiple), &opts);\n\tASSERT_OK(ret, \"inner_map_list_push_pop_multiple\");\n\tASSERT_OK(opts.retval, \"inner_map_list_push_pop_multiple retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.inner_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.global_list_push_pop_multiple), &opts);\n\tASSERT_OK(ret, \"global_list_push_pop_multiple\");\n\tASSERT_OK(opts.retval, \"global_list_push_pop_multiple retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.bss_A);\n\n\tif (mode == PUSH_POP_MULT)\n\t\tgoto end;\n\nlil:\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.map_list_in_list), &opts);\n\tASSERT_OK(ret, \"map_list_in_list\");\n\tASSERT_OK(opts.retval, \"map_list_in_list retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.array_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.inner_map_list_in_list), &opts);\n\tASSERT_OK(ret, \"inner_map_list_in_list\");\n\tASSERT_OK(opts.retval, \"inner_map_list_in_list retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.inner_map);\n\n\tret = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.global_list_in_list), &opts);\n\tASSERT_OK(ret, \"global_list_in_list\");\n\tASSERT_OK(opts.retval, \"global_list_in_list retval\");\n\tif (!leave_in_map)\n\t\tclear_fields(skel->maps.bss_A);\nend:\n\tlinked_list__destroy(skel);\n}\n\n#define SPIN_LOCK 2\n#define LIST_HEAD 3\n#define LIST_NODE 4\n\nstatic struct btf *init_btf(void)\n{\n\tint id, lid, hid, nid;\n\tstruct btf *btf;\n\n\tbtf = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf, \"btf__new_empty\"))\n\t\treturn NULL;\n\tid = btf__add_int(btf, \"int\", 4, BTF_INT_SIGNED);\n\tif (!ASSERT_EQ(id, 1, \"btf__add_int\"))\n\t\tgoto end;\n\tlid = btf__add_struct(btf, \"bpf_spin_lock\", 4);\n\tif (!ASSERT_EQ(lid, SPIN_LOCK, \"btf__add_struct bpf_spin_lock\"))\n\t\tgoto end;\n\thid = btf__add_struct(btf, \"bpf_list_head\", 16);\n\tif (!ASSERT_EQ(hid, LIST_HEAD, \"btf__add_struct bpf_list_head\"))\n\t\tgoto end;\n\tnid = btf__add_struct(btf, \"bpf_list_node\", 24);\n\tif (!ASSERT_EQ(nid, LIST_NODE, \"btf__add_struct bpf_list_node\"))\n\t\tgoto end;\n\treturn btf;\nend:\n\tbtf__free(btf);\n\treturn NULL;\n}\n\nstatic void list_and_rb_node_same_struct(bool refcount_field)\n{\n\tint bpf_rb_node_btf_id, bpf_refcount_btf_id, foo_btf_id;\n\tstruct btf *btf;\n\tint id, err;\n\n\tbtf = init_btf();\n\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\treturn;\n\n\tbpf_rb_node_btf_id = btf__add_struct(btf, \"bpf_rb_node\", 32);\n\tif (!ASSERT_GT(bpf_rb_node_btf_id, 0, \"btf__add_struct bpf_rb_node\"))\n\t\treturn;\n\n\tif (refcount_field) {\n\t\tbpf_refcount_btf_id = btf__add_struct(btf, \"bpf_refcount\", 4);\n\t\tif (!ASSERT_GT(bpf_refcount_btf_id, 0, \"btf__add_struct bpf_refcount\"))\n\t\t\treturn;\n\t}\n\n\tid = btf__add_struct(btf, \"bar\", refcount_field ? 60 : 56);\n\tif (!ASSERT_GT(id, 0, \"btf__add_struct bar\"))\n\t\treturn;\n\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\treturn;\n\terr = btf__add_field(btf, \"c\", bpf_rb_node_btf_id, 192, 0);\n\tif (!ASSERT_OK(err, \"btf__add_field bar::c\"))\n\t\treturn;\n\tif (refcount_field) {\n\t\terr = btf__add_field(btf, \"ref\", bpf_refcount_btf_id, 448, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::ref\"))\n\t\t\treturn;\n\t}\n\n\tfoo_btf_id = btf__add_struct(btf, \"foo\", 20);\n\tif (!ASSERT_GT(foo_btf_id, 0, \"btf__add_struct foo\"))\n\t\treturn;\n\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\treturn;\n\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 128, 0);\n\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\treturn;\n\tid = btf__add_decl_tag(btf, \"contains:bar:a\", foo_btf_id, 0);\n\tif (!ASSERT_GT(id, 0, \"btf__add_decl_tag contains:bar:a\"))\n\t\treturn;\n\n\terr = btf__load_into_kernel(btf);\n\tASSERT_EQ(err, refcount_field ? 0 : -EINVAL, \"check btf\");\n\tbtf__free(btf);\n}\n\nstatic void test_btf(void)\n{\n\tstruct btf *btf = NULL;\n\tint id, err;\n\n\twhile (test__start_subtest(\"btf: too many locks\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 24);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_struct foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 32, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_struct foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", LIST_HEAD, 64, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_struct foo::a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -E2BIG, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: missing lock\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 16);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_struct foo::a\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:baz:a\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:baz:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"baz\", 16);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct baz\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field baz::a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -EINVAL, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: bad offset\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 36);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:foo:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:foo:b\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -EEXIST, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: missing contains:\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 24);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_HEAD, 64, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -EINVAL, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: missing struct\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 24);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_HEAD, 64, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:bar\", 5, 1);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:bar\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -ENOENT, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: missing node\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 24);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_HEAD, 64, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:foo:c\", 5, 1);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:foo:c\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tbtf__free(btf);\n\t\tASSERT_EQ(err, -ENOENT, \"check btf\");\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: node incorrect type\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 20);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:a\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 4);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", SPIN_LOCK, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -EINVAL, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: multiple bpf_list_node with name b\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 52);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 256, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::c\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"d\", SPIN_LOCK, 384, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::d\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:foo:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:foo:b\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -EINVAL, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning | owned AA cycle\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 44);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:foo:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:foo:b\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -ELOOP, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning | owned ABA cycle\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 44);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:b\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 44);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:foo:b\", 7, 0);\n\t\tif (!ASSERT_EQ(id, 8, \"btf__add_decl_tag contains:foo:b\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -ELOOP, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning -> owned\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 28);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 192, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:a\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 24);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, 0, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning -> owning | owned -> owned\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 28);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 192, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:b\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 44);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:baz:a\", 7, 0);\n\t\tif (!ASSERT_EQ(id, 8, \"btf__add_decl_tag contains:baz:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"baz\", 24);\n\t\tif (!ASSERT_EQ(id, 9, \"btf__add_struct baz\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field baz:a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, 0, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning | owned -> owning | owned -> owned\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 44);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:b\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 44);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar:a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar:b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar:c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:baz:a\", 7, 0);\n\t\tif (!ASSERT_EQ(id, 8, \"btf__add_decl_tag contains:baz:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"baz\", 24);\n\t\tif (!ASSERT_EQ(id, 9, \"btf__add_struct baz\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field baz:a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -ELOOP, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: owning -> owning | owned -> owning | owned -> owned\")) {\n\t\tbtf = init_btf();\n\t\tif (!ASSERT_OK_PTR(btf, \"init_btf\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"foo\", 20);\n\t\tif (!ASSERT_EQ(id, 5, \"btf__add_struct foo\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", SPIN_LOCK, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field foo::b\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bar:b\", 5, 0);\n\t\tif (!ASSERT_EQ(id, 6, \"btf__add_decl_tag contains:bar:b\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bar\", 44);\n\t\tif (!ASSERT_EQ(id, 7, \"btf__add_struct bar\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:baz:b\", 7, 0);\n\t\tif (!ASSERT_EQ(id, 8, \"btf__add_decl_tag\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"baz\", 44);\n\t\tif (!ASSERT_EQ(id, 9, \"btf__add_struct baz\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_HEAD, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::a\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"b\", LIST_NODE, 128, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::b\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"c\", SPIN_LOCK, 320, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bar::c\"))\n\t\t\tbreak;\n\t\tid = btf__add_decl_tag(btf, \"contains:bam:a\", 9, 0);\n\t\tif (!ASSERT_EQ(id, 10, \"btf__add_decl_tag contains:bam:a\"))\n\t\t\tbreak;\n\t\tid = btf__add_struct(btf, \"bam\", 24);\n\t\tif (!ASSERT_EQ(id, 11, \"btf__add_struct bam\"))\n\t\t\tbreak;\n\t\terr = btf__add_field(btf, \"a\", LIST_NODE, 0, 0);\n\t\tif (!ASSERT_OK(err, \"btf__add_field bam::a\"))\n\t\t\tbreak;\n\n\t\terr = btf__load_into_kernel(btf);\n\t\tASSERT_EQ(err, -ELOOP, \"check btf\");\n\t\tbtf__free(btf);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: list_node and rb_node in same struct\")) {\n\t\tlist_and_rb_node_same_struct(true);\n\t\tbreak;\n\t}\n\n\twhile (test__start_subtest(\"btf: list_node and rb_node in same struct, no bpf_refcount\")) {\n\t\tlist_and_rb_node_same_struct(false);\n\t\tbreak;\n\t}\n}\n\nvoid test_linked_list(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(linked_list_fail_tests); i++) {\n\t\tif (!test__start_subtest(linked_list_fail_tests[i].prog_name))\n\t\t\tcontinue;\n\t\ttest_linked_list_fail_prog(linked_list_fail_tests[i].prog_name,\n\t\t\t\t\t   linked_list_fail_tests[i].err_msg);\n\t}\n\ttest_btf();\n\ttest_linked_list_success(PUSH_POP, false);\n\ttest_linked_list_success(PUSH_POP, true);\n\ttest_linked_list_success(PUSH_POP_MULT, false);\n\ttest_linked_list_success(PUSH_POP_MULT, true);\n\ttest_linked_list_success(LIST_IN_LIST, false);\n\ttest_linked_list_success(LIST_IN_LIST, true);\n\ttest_linked_list_success(TEST_ALL, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}