{
  "module_name": "xdp_noinline.c",
  "hash_id": "d42dd263b627de0c8f215a050f653f6f47f14d1aa2a87ff3f24951ecad69fc4f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_noinline.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"test_xdp_noinline.skel.h\"\n\nvoid test_xdp_noinline(void)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tstruct test_xdp_noinline *skel;\n\tstruct vip key = {.protocol = 6};\n\tstruct vip_meta {\n\t\t__u32 flags;\n\t\t__u32 vip_num;\n\t} value = {.vip_num = VIP_NUM};\n\t__u32 stats_key = VIP_NUM;\n\tstruct vip_stats {\n\t\t__u64 bytes;\n\t\t__u64 pkts;\n\t} stats[nr_cpus];\n\tstruct real_definition {\n\t\tunion {\n\t\t\t__be32 dst;\n\t\t\t__be32 dstv6[4];\n\t\t};\n\t\t__u8 flags;\n\t} real_def = {.dst = MAGIC_VAL};\n\t__u32 ch_key = 11, real_num = 3;\n\tint err, i;\n\t__u64 bytes = 0, pkts = 0;\n\tchar buf[128];\n\tu32 *magic = (u32 *)buf;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.data_out = buf,\n\t\t.data_size_out = sizeof(buf),\n\t\t.repeat = NUM_ITER,\n\t);\n\n\tskel = test_xdp_noinline__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open_and_load\"))\n\t\treturn;\n\n\tbpf_map_update_elem(bpf_map__fd(skel->maps.vip_map), &key, &value, 0);\n\tbpf_map_update_elem(bpf_map__fd(skel->maps.ch_rings), &ch_key, &real_num, 0);\n\tbpf_map_update_elem(bpf_map__fd(skel->maps.reals), &real_num, &real_def, 0);\n\n\terr = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.balancer_ingress_v4), &topts);\n\tASSERT_OK(err, \"ipv4 test_run\");\n\tASSERT_EQ(topts.retval, 1, \"ipv4 test_run retval\");\n\tASSERT_EQ(topts.data_size_out, 54, \"ipv4 test_run data_size_out\");\n\tASSERT_EQ(*magic, MAGIC_VAL, \"ipv4 test_run magic\");\n\n\ttopts.data_in = &pkt_v6;\n\ttopts.data_size_in = sizeof(pkt_v6);\n\ttopts.data_out = buf;\n\ttopts.data_size_out = sizeof(buf);\n\n\terr = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.balancer_ingress_v6), &topts);\n\tASSERT_OK(err, \"ipv6 test_run\");\n\tASSERT_EQ(topts.retval, 1, \"ipv6 test_run retval\");\n\tASSERT_EQ(topts.data_size_out, 74, \"ipv6 test_run data_size_out\");\n\tASSERT_EQ(*magic, MAGIC_VAL, \"ipv6 test_run magic\");\n\n\tbpf_map_lookup_elem(bpf_map__fd(skel->maps.stats), &stats_key, stats);\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tbytes += stats[i].bytes;\n\t\tpkts += stats[i].pkts;\n\t}\n\tASSERT_EQ(bytes, MAGIC_BYTES * NUM_ITER * 2, \"stats bytes\");\n\tASSERT_EQ(pkts, NUM_ITER * 2, \"stats pkts\");\n\ttest_xdp_noinline__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}