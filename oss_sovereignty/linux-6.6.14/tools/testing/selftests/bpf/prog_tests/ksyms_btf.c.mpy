{
  "module_name": "ksyms_btf.c",
  "hash_id": "b674df568b7ffe97cf400321ba3061c5b17b84e3f494b314020d0f29d0ae4564",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/ksyms_btf.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <bpf/libbpf.h>\n#include <bpf/btf.h>\n#include \"test_ksyms_btf.skel.h\"\n#include \"test_ksyms_btf_null_check.skel.h\"\n#include \"test_ksyms_weak.skel.h\"\n#include \"test_ksyms_weak.lskel.h\"\n#include \"test_ksyms_btf_write_check.skel.h\"\n\nstatic int duration;\n\nstatic void test_basic(void)\n{\n\t__u64 runqueues_addr, bpf_prog_active_addr;\n\t__u32 this_rq_cpu;\n\tint this_bpf_prog_active;\n\tstruct test_ksyms_btf *skel = NULL;\n\tstruct test_ksyms_btf__data *data;\n\tint err;\n\n\terr = kallsyms_find(\"runqueues\", &runqueues_addr);\n\tif (CHECK(err == -EINVAL, \"kallsyms_fopen\", \"failed to open: %d\\n\", errno))\n\t\treturn;\n\tif (CHECK(err == -ENOENT, \"ksym_find\", \"symbol 'runqueues' not found\\n\"))\n\t\treturn;\n\n\terr = kallsyms_find(\"bpf_prog_active\", &bpf_prog_active_addr);\n\tif (CHECK(err == -EINVAL, \"kallsyms_fopen\", \"failed to open: %d\\n\", errno))\n\t\treturn;\n\tif (CHECK(err == -ENOENT, \"ksym_find\", \"symbol 'bpf_prog_active' not found\\n\"))\n\t\treturn;\n\n\tskel = test_ksyms_btf__open_and_load();\n\tif (CHECK(!skel, \"skel_open\", \"failed to open and load skeleton\\n\"))\n\t\tgoto cleanup;\n\n\terr = test_ksyms_btf__attach(skel);\n\tif (CHECK(err, \"skel_attach\", \"skeleton attach failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tdata = skel->data;\n\tCHECK(data->out__runqueues_addr != runqueues_addr, \"runqueues_addr\",\n\t      \"got %llu, exp %llu\\n\",\n\t      (unsigned long long)data->out__runqueues_addr,\n\t      (unsigned long long)runqueues_addr);\n\tCHECK(data->out__bpf_prog_active_addr != bpf_prog_active_addr, \"bpf_prog_active_addr\",\n\t      \"got %llu, exp %llu\\n\",\n\t      (unsigned long long)data->out__bpf_prog_active_addr,\n\t      (unsigned long long)bpf_prog_active_addr);\n\n\tCHECK(data->out__rq_cpu == -1, \"rq_cpu\",\n\t      \"got %u, exp != -1\\n\", data->out__rq_cpu);\n\tCHECK(data->out__bpf_prog_active < 0, \"bpf_prog_active\",\n\t      \"got %d, exp >= 0\\n\", data->out__bpf_prog_active);\n\tCHECK(data->out__cpu_0_rq_cpu != 0, \"cpu_rq(0)->cpu\",\n\t      \"got %u, exp 0\\n\", data->out__cpu_0_rq_cpu);\n\n\tthis_rq_cpu = data->out__this_rq_cpu;\n\tCHECK(this_rq_cpu != data->out__rq_cpu, \"this_rq_cpu\",\n\t      \"got %u, exp %u\\n\", this_rq_cpu, data->out__rq_cpu);\n\n\tthis_bpf_prog_active = data->out__this_bpf_prog_active;\n\tCHECK(this_bpf_prog_active != data->out__bpf_prog_active, \"this_bpf_prog_active\",\n\t      \"got %d, exp %d\\n\", this_bpf_prog_active,\n\t      data->out__bpf_prog_active);\n\ncleanup:\n\ttest_ksyms_btf__destroy(skel);\n}\n\nstatic void test_null_check(void)\n{\n\tstruct test_ksyms_btf_null_check *skel;\n\n\tskel = test_ksyms_btf_null_check__open_and_load();\n\tCHECK(skel, \"skel_open\", \"unexpected load of a prog missing null check\\n\");\n\n\ttest_ksyms_btf_null_check__destroy(skel);\n}\n\nstatic void test_weak_syms(void)\n{\n\tstruct test_ksyms_weak *skel;\n\tstruct test_ksyms_weak__data *data;\n\tint err;\n\n\tskel = test_ksyms_weak__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_ksyms_weak__open_and_load\"))\n\t\treturn;\n\n\terr = test_ksyms_weak__attach(skel);\n\tif (!ASSERT_OK(err, \"test_ksyms_weak__attach\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tdata = skel->data;\n\tASSERT_EQ(data->out__existing_typed, 0, \"existing typed ksym\");\n\tASSERT_NEQ(data->out__existing_typeless, -1, \"existing typeless ksym\");\n\tASSERT_EQ(data->out__non_existent_typeless, 0, \"nonexistent typeless ksym\");\n\tASSERT_EQ(data->out__non_existent_typed, 0, \"nonexistent typed ksym\");\n\ncleanup:\n\ttest_ksyms_weak__destroy(skel);\n}\n\nstatic void test_weak_syms_lskel(void)\n{\n\tstruct test_ksyms_weak_lskel *skel;\n\tstruct test_ksyms_weak_lskel__data *data;\n\tint err;\n\n\tskel = test_ksyms_weak_lskel__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"test_ksyms_weak_lskel__open_and_load\"))\n\t\treturn;\n\n\terr = test_ksyms_weak_lskel__attach(skel);\n\tif (!ASSERT_OK(err, \"test_ksyms_weak_lskel__attach\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tdata = skel->data;\n\tASSERT_EQ(data->out__existing_typed, 0, \"existing typed ksym\");\n\tASSERT_NEQ(data->out__existing_typeless, -1, \"existing typeless ksym\");\n\tASSERT_EQ(data->out__non_existent_typeless, 0, \"nonexistent typeless ksym\");\n\tASSERT_EQ(data->out__non_existent_typed, 0, \"nonexistent typed ksym\");\n\ncleanup:\n\ttest_ksyms_weak_lskel__destroy(skel);\n}\n\nstatic void test_write_check(bool test_handler1)\n{\n\tstruct test_ksyms_btf_write_check *skel;\n\n\tskel = test_ksyms_btf_write_check__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_ksyms_btf_write_check__open\"))\n\t\treturn;\n\tbpf_program__set_autoload(test_handler1 ? skel->progs.handler2 : skel->progs.handler1, false);\n\tASSERT_ERR(test_ksyms_btf_write_check__load(skel),\n\t\t   \"unexpected load of a prog writing to ksym memory\\n\");\n\n\ttest_ksyms_btf_write_check__destroy(skel);\n}\n\nvoid test_ksyms_btf(void)\n{\n\tint percpu_datasec;\n\tstruct btf *btf;\n\n\tbtf = libbpf_find_kernel_btf();\n\tif (!ASSERT_OK_PTR(btf, \"btf_exists\"))\n\t\treturn;\n\n\tpercpu_datasec = btf__find_by_name_kind(btf, \".data..percpu\",\n\t\t\t\t\t\tBTF_KIND_DATASEC);\n\tbtf__free(btf);\n\tif (percpu_datasec < 0) {\n\t\tprintf(\"%s:SKIP:no PERCPU DATASEC in kernel btf\\n\",\n\t\t       __func__);\n\t\ttest__skip();\n\t\treturn;\n\t}\n\n\tif (test__start_subtest(\"basic\"))\n\t\ttest_basic();\n\n\tif (test__start_subtest(\"null_check\"))\n\t\ttest_null_check();\n\n\tif (test__start_subtest(\"weak_ksyms\"))\n\t\ttest_weak_syms();\n\n\tif (test__start_subtest(\"weak_ksyms_lskel\"))\n\t\ttest_weak_syms_lskel();\n\n\tif (test__start_subtest(\"write_check1\"))\n\t\ttest_write_check(true);\n\n\tif (test__start_subtest(\"write_check2\"))\n\t\ttest_write_check(false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}