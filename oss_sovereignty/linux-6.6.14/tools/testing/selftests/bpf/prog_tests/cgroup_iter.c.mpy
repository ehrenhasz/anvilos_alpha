{
  "module_name": "cgroup_iter.c",
  "hash_id": "0b69f2cb2efa743d03fca640e600bb520408bd745ee1a8ec65e2e68d4c532b66",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/cgroup_iter.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <bpf/libbpf.h>\n#include <bpf/btf.h>\n#include \"cgroup_iter.skel.h\"\n#include \"cgroup_helpers.h\"\n\n#define ROOT           0\n#define PARENT         1\n#define CHILD1         2\n#define CHILD2         3\n#define NUM_CGROUPS    4\n\n#define PROLOGUE       \"prologue\\n\"\n#define EPILOGUE       \"epilogue\\n\"\n\nstatic const char *cg_path[] = {\n\t\"/\", \"/parent\", \"/parent/child1\", \"/parent/child2\"\n};\n\nstatic int cg_fd[] = {-1, -1, -1, -1};\nstatic unsigned long long cg_id[] = {0, 0, 0, 0};\nstatic char expected_output[64];\n\nstatic int setup_cgroups(void)\n{\n\tint fd, i = 0;\n\n\tfor (i = 0; i < NUM_CGROUPS; i++) {\n\t\tfd = create_and_get_cgroup(cg_path[i]);\n\t\tif (fd < 0)\n\t\t\treturn fd;\n\n\t\tcg_fd[i] = fd;\n\t\tcg_id[i] = get_cgroup_id(cg_path[i]);\n\t}\n\treturn 0;\n}\n\nstatic void cleanup_cgroups(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_CGROUPS; i++)\n\t\tclose(cg_fd[i]);\n}\n\nstatic void read_from_cgroup_iter(struct bpf_program *prog, int cgroup_fd,\n\t\t\t\t  int order, const char *testname)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\tint len, iter_fd;\n\tstatic char buf[128];\n\tsize_t left;\n\tchar *p;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.cgroup.cgroup_fd = cgroup_fd;\n\tlinfo.cgroup.order = order;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tlink = bpf_program__attach_iter(prog, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (iter_fd < 0)\n\t\tgoto free_link;\n\n\tmemset(buf, 0, sizeof(buf));\n\tleft = ARRAY_SIZE(buf);\n\tp = buf;\n\twhile ((len = read(iter_fd, p, left)) > 0) {\n\t\tp += len;\n\t\tleft -= len;\n\t}\n\n\tASSERT_STREQ(buf, expected_output, testname);\n\n\t \n\tif (len == 0)\n\t\tASSERT_OK(read(iter_fd, buf, sizeof(buf)), \"second_read\");\n\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\n}\n\n \nstatic void test_invalid_cgroup(struct cgroup_iter *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.cgroup.cgroup_fd = (__u32)-1;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tlink = bpf_program__attach_iter(skel->progs.cgroup_id_printer, &opts);\n\tASSERT_ERR_PTR(link, \"attach_iter\");\n\tbpf_link__destroy(link);\n}\n\n \nstatic void test_invalid_cgroup_spec(struct cgroup_iter *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.cgroup.cgroup_fd = (__u32)cg_fd[PARENT];\n\tlinfo.cgroup.cgroup_id = (__u64)cg_id[PARENT];\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tlink = bpf_program__attach_iter(skel->progs.cgroup_id_printer, &opts);\n\tASSERT_ERR_PTR(link, \"attach_iter\");\n\tbpf_link__destroy(link);\n}\n\n \nstatic void test_walk_preorder(struct cgroup_iter *skel)\n{\n\tsnprintf(expected_output, sizeof(expected_output),\n\t\t PROLOGUE \"%8llu\\n%8llu\\n%8llu\\n\" EPILOGUE,\n\t\t cg_id[PARENT], cg_id[CHILD1], cg_id[CHILD2]);\n\n\tread_from_cgroup_iter(skel->progs.cgroup_id_printer, cg_fd[PARENT],\n\t\t\t      BPF_CGROUP_ITER_DESCENDANTS_PRE, \"preorder\");\n}\n\n \nstatic void test_walk_postorder(struct cgroup_iter *skel)\n{\n\tsnprintf(expected_output, sizeof(expected_output),\n\t\t PROLOGUE \"%8llu\\n%8llu\\n%8llu\\n\" EPILOGUE,\n\t\t cg_id[CHILD1], cg_id[CHILD2], cg_id[PARENT]);\n\n\tread_from_cgroup_iter(skel->progs.cgroup_id_printer, cg_fd[PARENT],\n\t\t\t      BPF_CGROUP_ITER_DESCENDANTS_POST, \"postorder\");\n}\n\n \nstatic void test_walk_ancestors_up(struct cgroup_iter *skel)\n{\n\t \n\tskel->bss->terminal_cgroup = cg_id[ROOT];\n\n\tsnprintf(expected_output, sizeof(expected_output),\n\t\t PROLOGUE \"%8llu\\n%8llu\\n\" EPILOGUE,\n\t\t cg_id[PARENT], cg_id[ROOT]);\n\n\tread_from_cgroup_iter(skel->progs.cgroup_id_printer, cg_fd[PARENT],\n\t\t\t      BPF_CGROUP_ITER_ANCESTORS_UP, \"ancestors_up\");\n\n\tskel->bss->terminal_cgroup = 0;\n}\n\n \nstatic void test_early_termination(struct cgroup_iter *skel)\n{\n\t \n\tskel->bss->terminate_early = 1;\n\n\tsnprintf(expected_output, sizeof(expected_output),\n\t\t PROLOGUE \"%8llu\\n\" EPILOGUE, cg_id[PARENT]);\n\n\tread_from_cgroup_iter(skel->progs.cgroup_id_printer, cg_fd[PARENT],\n\t\t\t      BPF_CGROUP_ITER_DESCENDANTS_PRE, \"early_termination\");\n\n\tskel->bss->terminate_early = 0;\n}\n\n \nstatic void test_walk_self_only(struct cgroup_iter *skel)\n{\n\tsnprintf(expected_output, sizeof(expected_output),\n\t\t PROLOGUE \"%8llu\\n\" EPILOGUE, cg_id[PARENT]);\n\n\tread_from_cgroup_iter(skel->progs.cgroup_id_printer, cg_fd[PARENT],\n\t\t\t      BPF_CGROUP_ITER_SELF_ONLY, \"self_only\");\n}\n\nstatic void test_walk_dead_self_only(struct cgroup_iter *skel)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tchar expected_output[128], buf[128];\n\tconst char *cgrp_name = \"/dead\";\n\tunion bpf_iter_link_info linfo;\n\tint len, cgrp_fd, iter_fd;\n\tstruct bpf_link *link;\n\tsize_t left;\n\tchar *p;\n\n\tcgrp_fd = create_and_get_cgroup(cgrp_name);\n\tif (!ASSERT_GE(cgrp_fd, 0, \"create cgrp\"))\n\t\treturn;\n\n\t \n\tsnprintf(expected_output, sizeof(expected_output), EPILOGUE);\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.cgroup.cgroup_fd = cgrp_fd;\n\tlinfo.cgroup.order = BPF_CGROUP_ITER_SELF_ONLY;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tlink = bpf_program__attach_iter(skel->progs.cgroup_id_printer, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto close_cgrp;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"iter_create\"))\n\t\tgoto free_link;\n\n\t \n\tbpf_link__destroy(link);\n\tclose(cgrp_fd);\n\n\t \n\tremove_cgroup(cgrp_name);\n\n\t \n\tkern_sync_rcu();\n\tusleep(8000);\n\tkern_sync_rcu();\n\tusleep(8000);\n\tkern_sync_rcu();\n\tusleep(1000);\n\n\tmemset(buf, 0, sizeof(buf));\n\tleft = ARRAY_SIZE(buf);\n\tp = buf;\n\twhile ((len = read(iter_fd, p, left)) > 0) {\n\t\tp += len;\n\t\tleft -= len;\n\t}\n\n\tASSERT_STREQ(buf, expected_output, \"dead cgroup output\");\n\n\t \n\tif (len == 0)\n\t\tASSERT_OK(read(iter_fd, buf, sizeof(buf)), \"second_read\");\n\n\tclose(iter_fd);\n\treturn;\nfree_link:\n\tbpf_link__destroy(link);\nclose_cgrp:\n\tclose(cgrp_fd);\n}\n\nvoid test_cgroup_iter(void)\n{\n\tstruct cgroup_iter *skel = NULL;\n\n\tif (setup_cgroup_environment())\n\t\treturn;\n\n\tif (setup_cgroups())\n\t\tgoto out;\n\n\tskel = cgroup_iter__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"cgroup_iter__open_and_load\"))\n\t\tgoto out;\n\n\tif (test__start_subtest(\"cgroup_iter__invalid_cgroup\"))\n\t\ttest_invalid_cgroup(skel);\n\tif (test__start_subtest(\"cgroup_iter__invalid_cgroup_spec\"))\n\t\ttest_invalid_cgroup_spec(skel);\n\tif (test__start_subtest(\"cgroup_iter__preorder\"))\n\t\ttest_walk_preorder(skel);\n\tif (test__start_subtest(\"cgroup_iter__postorder\"))\n\t\ttest_walk_postorder(skel);\n\tif (test__start_subtest(\"cgroup_iter__ancestors_up_walk\"))\n\t\ttest_walk_ancestors_up(skel);\n\tif (test__start_subtest(\"cgroup_iter__early_termination\"))\n\t\ttest_early_termination(skel);\n\tif (test__start_subtest(\"cgroup_iter__self_only\"))\n\t\ttest_walk_self_only(skel);\n\tif (test__start_subtest(\"cgroup_iter__dead_self_only\"))\n\t\ttest_walk_dead_self_only(skel);\nout:\n\tcgroup_iter__destroy(skel);\n\tcleanup_cgroups();\n\tcleanup_cgroup_environment();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}