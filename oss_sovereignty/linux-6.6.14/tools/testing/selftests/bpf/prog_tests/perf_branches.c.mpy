{
  "module_name": "perf_branches.c",
  "hash_id": "a655044690278cd8dbabce9abebae96d183b4de323a0addddb09a6bd9f2257ab",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/perf_branches.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <sched.h>\n#include <sys/socket.h>\n#include <test_progs.h>\n#include \"bpf/libbpf_internal.h\"\n#include \"test_perf_branches.skel.h\"\n\nstatic void check_good_sample(struct test_perf_branches *skel)\n{\n\tint written_global = skel->bss->written_global_out;\n\tint required_size = skel->bss->required_size_out;\n\tint written_stack = skel->bss->written_stack_out;\n\tint pbe_size = sizeof(struct perf_branch_entry);\n\tint duration = 0;\n\n\tif (CHECK(!skel->bss->valid, \"output not valid\",\n\t\t \"no valid sample from prog\"))\n\t\treturn;\n\n\t \n\tCHECK(required_size <= 0, \"read_branches_size\", \"err %d\\n\", required_size);\n\tCHECK(written_stack < 0, \"read_branches_stack\", \"err %d\\n\", written_stack);\n\tCHECK(written_stack % pbe_size != 0, \"read_branches_stack\",\n\t      \"stack bytes written=%d not multiple of struct size=%d\\n\",\n\t      written_stack, pbe_size);\n\tCHECK(written_global < 0, \"read_branches_global\", \"err %d\\n\", written_global);\n\tCHECK(written_global % pbe_size != 0, \"read_branches_global\",\n\t      \"global bytes written=%d not multiple of struct size=%d\\n\",\n\t      written_global, pbe_size);\n\tCHECK(written_global < written_stack, \"read_branches_size\",\n\t      \"written_global=%d < written_stack=%d\\n\", written_global, written_stack);\n}\n\nstatic void check_bad_sample(struct test_perf_branches *skel)\n{\n\tint written_global = skel->bss->written_global_out;\n\tint required_size = skel->bss->required_size_out;\n\tint written_stack = skel->bss->written_stack_out;\n\tint duration = 0;\n\n\tif (CHECK(!skel->bss->valid, \"output not valid\",\n\t\t \"no valid sample from prog\"))\n\t\treturn;\n\n\tCHECK((required_size != -EINVAL && required_size != -ENOENT),\n\t      \"read_branches_size\", \"err %d\\n\", required_size);\n\tCHECK((written_stack != -EINVAL && written_stack != -ENOENT),\n\t      \"read_branches_stack\", \"written %d\\n\", written_stack);\n\tCHECK((written_global != -EINVAL && written_global != -ENOENT),\n\t      \"read_branches_global\", \"written %d\\n\", written_global);\n}\n\nstatic void test_perf_branches_common(int perf_fd,\n\t\t\t\t      void (*cb)(struct test_perf_branches *))\n{\n\tstruct test_perf_branches *skel;\n\tint err, i, duration = 0;\n\tbool detached = false;\n\tstruct bpf_link *link;\n\tvolatile int j = 0;\n\tcpu_set_t cpu_set;\n\n\tskel = test_perf_branches__open_and_load();\n\tif (CHECK(!skel, \"test_perf_branches_load\",\n\t\t  \"perf_branches skeleton failed\\n\"))\n\t\treturn;\n\n\t \n\tlink = bpf_program__attach_perf_event(skel->progs.perf_branches, perf_fd);\n\tif (!ASSERT_OK_PTR(link, \"attach_perf_event\"))\n\t\tgoto out_destroy_skel;\n\n\t \n\tCPU_ZERO(&cpu_set);\n\tCPU_SET(0, &cpu_set);\n\terr = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set);\n\tif (CHECK(err, \"set_affinity\", \"cpu #0, err %d\\n\", err))\n\t\tgoto out_destroy;\n\t \n\tfor (i = 0; i < 1000000; ++i)\n\t\t++j;\n\n\ttest_perf_branches__detach(skel);\n\tdetached = true;\n\n\tcb(skel);\nout_destroy:\n\tbpf_link__destroy(link);\nout_destroy_skel:\n\tif (!detached)\n\t\ttest_perf_branches__detach(skel);\n\ttest_perf_branches__destroy(skel);\n}\n\nstatic void test_perf_branches_hw(void)\n{\n\tstruct perf_event_attr attr = {0};\n\tint duration = 0;\n\tint pfd;\n\n\t \n\tattr.size = sizeof(attr);\n\tattr.type = PERF_TYPE_HARDWARE;\n\tattr.config = PERF_COUNT_HW_CPU_CYCLES;\n\tattr.freq = 1;\n\tattr.sample_freq = 1000;\n\tattr.sample_type = PERF_SAMPLE_BRANCH_STACK;\n\tattr.branch_sample_type = PERF_SAMPLE_BRANCH_USER | PERF_SAMPLE_BRANCH_ANY;\n\tpfd = syscall(__NR_perf_event_open, &attr, -1, 0, -1, PERF_FLAG_FD_CLOEXEC);\n\n\t \n\tif (pfd < 0) {\n\t\tif (errno == ENOENT || errno == EOPNOTSUPP) {\n\t\t\tprintf(\"%s:SKIP:no PERF_SAMPLE_BRANCH_STACK\\n\",\n\t\t\t       __func__);\n\t\t\ttest__skip();\n\t\t\treturn;\n\t\t}\n\t\tif (CHECK(pfd < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t\t  pfd, errno))\n\t\t\treturn;\n\t}\n\n\ttest_perf_branches_common(pfd, check_good_sample);\n\n\tclose(pfd);\n}\n\n \nstatic void test_perf_branches_no_hw(void)\n{\n\tstruct perf_event_attr attr = {0};\n\tint duration = 0;\n\tint pfd;\n\n\t \n\tattr.size = sizeof(attr);\n\tattr.type = PERF_TYPE_SOFTWARE;\n\tattr.config = PERF_COUNT_SW_CPU_CLOCK;\n\tattr.freq = 1;\n\tattr.sample_freq = 1000;\n\tpfd = syscall(__NR_perf_event_open, &attr, -1, 0, -1, PERF_FLAG_FD_CLOEXEC);\n\tif (CHECK(pfd < 0, \"perf_event_open\", \"err %d\\n\", pfd))\n\t\treturn;\n\n\ttest_perf_branches_common(pfd, check_bad_sample);\n\n\tclose(pfd);\n}\n\nvoid test_perf_branches(void)\n{\n\tif (test__start_subtest(\"perf_branches_hw\"))\n\t\ttest_perf_branches_hw();\n\tif (test__start_subtest(\"perf_branches_no_hw\"))\n\t\ttest_perf_branches_no_hw();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}