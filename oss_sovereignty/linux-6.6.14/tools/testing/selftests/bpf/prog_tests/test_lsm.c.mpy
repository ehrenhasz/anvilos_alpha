{
  "module_name": "test_lsm.c",
  "hash_id": "f668c54cec0b9ebe3353de3aaef4ecc0cac942889cbd40bd7f20d87f25910a84",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/test_lsm.c",
  "human_readable_source": "\n\n \n\n#include <test_progs.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <stdlib.h>\n\n#include \"lsm.skel.h\"\n\nchar *CMD_ARGS[] = {\"true\", NULL};\n\n#define GET_PAGE_ADDR(ADDR, PAGE_SIZE)\t\t\t\t\t\\\n\t(char *)(((unsigned long) (ADDR + PAGE_SIZE)) & ~(PAGE_SIZE-1))\n\nint stack_mprotect(void)\n{\n\tvoid *buf;\n\tlong sz;\n\tint ret;\n\n\tsz = sysconf(_SC_PAGESIZE);\n\tif (sz < 0)\n\t\treturn sz;\n\n\tbuf = alloca(sz * 3);\n\tret = mprotect(GET_PAGE_ADDR(buf, sz), sz,\n\t\t       PROT_READ | PROT_WRITE | PROT_EXEC);\n\treturn ret;\n}\n\nint exec_cmd(int *monitored_pid)\n{\n\tint child_pid, child_status;\n\n\tchild_pid = fork();\n\tif (child_pid == 0) {\n\t\t*monitored_pid = getpid();\n\t\texecvp(CMD_ARGS[0], CMD_ARGS);\n\t\treturn -EINVAL;\n\t} else if (child_pid > 0) {\n\t\twaitpid(child_pid, &child_status, 0);\n\t\treturn child_status;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int test_lsm(struct lsm *skel)\n{\n\tstruct bpf_link *link;\n\tint buf = 1234;\n\tint err;\n\n\terr = lsm__attach(skel);\n\tif (!ASSERT_OK(err, \"attach\"))\n\t\treturn err;\n\n\t \n\tlink = bpf_program__attach(skel->progs.test_int_hook);\n\tif (!ASSERT_ERR_PTR(link, \"attach_link\"))\n\t\treturn -1;\n\n\terr = exec_cmd(&skel->bss->monitored_pid);\n\tif (!ASSERT_OK(err, \"exec_cmd\"))\n\t\treturn err;\n\n\tASSERT_EQ(skel->bss->bprm_count, 1, \"bprm_count\");\n\n\tskel->bss->monitored_pid = getpid();\n\n\terr = stack_mprotect();\n\tif (!ASSERT_EQ(err, -1, \"stack_mprotect\") ||\n\t    !ASSERT_EQ(errno, EPERM, \"stack_mprotect\"))\n\t\treturn err;\n\n\tASSERT_EQ(skel->bss->mprotect_count, 1, \"mprotect_count\");\n\n\tsyscall(__NR_setdomainname, &buf, -2L);\n\tsyscall(__NR_setdomainname, 0, -3L);\n\tsyscall(__NR_setdomainname, ~0L, -4L);\n\n\tASSERT_EQ(skel->bss->copy_test, 3, \"copy_test\");\n\n\tlsm__detach(skel);\n\n\tskel->bss->copy_test = 0;\n\tskel->bss->bprm_count = 0;\n\tskel->bss->mprotect_count = 0;\n\treturn 0;\n}\n\nvoid test_test_lsm(void)\n{\n\tstruct lsm *skel = NULL;\n\tint err;\n\n\tskel = lsm__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"lsm_skel_load\"))\n\t\tgoto close_prog;\n\n\terr = test_lsm(skel);\n\tif (!ASSERT_OK(err, \"test_lsm_first_attach\"))\n\t\tgoto close_prog;\n\n\terr = test_lsm(skel);\n\tASSERT_OK(err, \"test_lsm_second_attach\");\n\nclose_prog:\n\tlsm__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}