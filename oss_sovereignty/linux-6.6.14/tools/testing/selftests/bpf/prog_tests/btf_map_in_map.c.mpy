{
  "module_name": "btf_map_in_map.c",
  "hash_id": "bfa85cac68d59f6c65c13c8c118b0a3e171c91dee914259c9b5b08b803834aa7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_map_in_map.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n\n#include \"test_btf_map_in_map.skel.h\"\n\nstatic int duration;\n\nstatic __u32 bpf_map_id(struct bpf_map *map)\n{\n\tstruct bpf_map_info info;\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\tmemset(&info, 0, info_len);\n\terr = bpf_map_get_info_by_fd(bpf_map__fd(map), &info, &info_len);\n\tif (err)\n\t\treturn 0;\n\treturn info.id;\n}\n\nstatic void test_lookup_update(void)\n{\n\tint map1_fd, map2_fd, map3_fd, map4_fd, map5_fd, map1_id, map2_id;\n\tint outer_arr_fd, outer_hash_fd, outer_arr_dyn_fd;\n\tstruct test_btf_map_in_map *skel;\n\tint err, key = 0, val, i, fd;\n\n\tskel = test_btf_map_in_map__open_and_load();\n\tif (CHECK(!skel, \"skel_open\", \"failed to open&load skeleton\\n\"))\n\t\treturn;\n\n\terr = test_btf_map_in_map__attach(skel);\n\tif (CHECK(err, \"skel_attach\", \"skeleton attach failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tmap1_fd = bpf_map__fd(skel->maps.inner_map1);\n\tmap2_fd = bpf_map__fd(skel->maps.inner_map2);\n\tmap3_fd = bpf_map__fd(skel->maps.inner_map3);\n\tmap4_fd = bpf_map__fd(skel->maps.inner_map4);\n\tmap5_fd = bpf_map__fd(skel->maps.inner_map5);\n\touter_arr_dyn_fd = bpf_map__fd(skel->maps.outer_arr_dyn);\n\touter_arr_fd = bpf_map__fd(skel->maps.outer_arr);\n\touter_hash_fd = bpf_map__fd(skel->maps.outer_hash);\n\n\t \n\tbpf_map_update_elem(outer_arr_fd, &key, &map1_fd, 0);\n\tbpf_map_update_elem(outer_hash_fd, &key, &map2_fd, 0);\n\tbpf_map_update_elem(outer_arr_dyn_fd, &key, &map3_fd, 0);\n\tskel->bss->input = 1;\n\tusleep(1);\n\tbpf_map_lookup_elem(map1_fd, &key, &val);\n\tCHECK(val != 1, \"inner1\", \"got %d != exp %d\\n\", val, 1);\n\tbpf_map_lookup_elem(map2_fd, &key, &val);\n\tCHECK(val != 2, \"inner2\", \"got %d != exp %d\\n\", val, 2);\n\tbpf_map_lookup_elem(map3_fd, &key, &val);\n\tCHECK(val != 3, \"inner3\", \"got %d != exp %d\\n\", val, 3);\n\n\t \n\tbpf_map_update_elem(outer_arr_fd, &key, &map2_fd, 0);\n\tbpf_map_update_elem(outer_hash_fd, &key, &map1_fd, 0);\n\tbpf_map_update_elem(outer_arr_dyn_fd, &key, &map4_fd, 0);\n\tskel->bss->input = 3;\n\tusleep(1);\n\tbpf_map_lookup_elem(map1_fd, &key, &val);\n\tCHECK(val != 4, \"inner1\", \"got %d != exp %d\\n\", val, 4);\n\tbpf_map_lookup_elem(map2_fd, &key, &val);\n\tCHECK(val != 3, \"inner2\", \"got %d != exp %d\\n\", val, 3);\n\tbpf_map_lookup_elem(map4_fd, &key, &val);\n\tCHECK(val != 5, \"inner4\", \"got %d != exp %d\\n\", val, 5);\n\n\t \n\tbpf_map_update_elem(outer_arr_dyn_fd, &key, &map5_fd, 0);\n\tskel->bss->input = 5;\n\tusleep(1);\n\tbpf_map_lookup_elem(map5_fd, &key, &val);\n\tCHECK(val != 7, \"inner5\", \"got %d != exp %d\\n\", val, 7);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tval = i % 2 ? map1_fd : map2_fd;\n\t\terr = bpf_map_update_elem(outer_hash_fd, &key, &val, 0);\n\t\tif (CHECK_FAIL(err)) {\n\t\t\tprintf(\"failed to update hash_of_maps on iter #%d\\n\", i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\terr = bpf_map_update_elem(outer_arr_fd, &key, &val, 0);\n\t\tif (CHECK_FAIL(err)) {\n\t\t\tprintf(\"failed to update array_of_maps on iter #%d\\n\", i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tval = i % 2 ? map4_fd : map5_fd;\n\t\terr = bpf_map_update_elem(outer_arr_dyn_fd, &key, &val, 0);\n\t\tif (CHECK_FAIL(err)) {\n\t\t\tprintf(\"failed to update array_of_maps (dyn) on iter #%d\\n\", i);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmap1_id = bpf_map_id(skel->maps.inner_map1);\n\tmap2_id = bpf_map_id(skel->maps.inner_map2);\n\tCHECK(map1_id == 0, \"map1_id\", \"failed to get ID 1\\n\");\n\tCHECK(map2_id == 0, \"map2_id\", \"failed to get ID 2\\n\");\n\n\ttest_btf_map_in_map__destroy(skel);\n\tskel = NULL;\n\n\t \n\tCHECK(kern_sync_rcu(), \"sync_rcu\", \"failed\\n\");\n\tCHECK(kern_sync_rcu(), \"sync_rcu\", \"failed\\n\");\n\n\tfd = bpf_map_get_fd_by_id(map1_id);\n\tif (CHECK(fd >= 0, \"map1_leak\", \"inner_map1 leaked!\\n\")) {\n\t\tclose(fd);\n\t\tgoto cleanup;\n\t}\n\tfd = bpf_map_get_fd_by_id(map2_id);\n\tif (CHECK(fd >= 0, \"map2_leak\", \"inner_map2 leaked!\\n\")) {\n\t\tclose(fd);\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\ttest_btf_map_in_map__destroy(skel);\n}\n\nstatic void test_diff_size(void)\n{\n\tstruct test_btf_map_in_map *skel;\n\tint err, inner_map_fd, zero = 0;\n\n\tskel = test_btf_map_in_map__open_and_load();\n\tif (CHECK(!skel, \"skel_open\", \"failed to open&load skeleton\\n\"))\n\t\treturn;\n\n\tinner_map_fd = bpf_map__fd(skel->maps.sockarr_sz2);\n\terr = bpf_map_update_elem(bpf_map__fd(skel->maps.outer_sockarr), &zero,\n\t\t\t\t  &inner_map_fd, 0);\n\tCHECK(err, \"outer_sockarr inner map size check\",\n\t      \"cannot use a different size inner_map\\n\");\n\n\tinner_map_fd = bpf_map__fd(skel->maps.inner_map_sz2);\n\terr = bpf_map_update_elem(bpf_map__fd(skel->maps.outer_arr), &zero,\n\t\t\t\t  &inner_map_fd, 0);\n\tCHECK(!err, \"outer_arr inner map size check\",\n\t      \"incorrectly updated with a different size inner_map\\n\");\n\n\ttest_btf_map_in_map__destroy(skel);\n}\n\nvoid test_btf_map_in_map(void)\n{\n\tif (test__start_subtest(\"lookup_update\"))\n\t\ttest_lookup_update();\n\n\tif (test__start_subtest(\"diff_size\"))\n\t\ttest_diff_size();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}