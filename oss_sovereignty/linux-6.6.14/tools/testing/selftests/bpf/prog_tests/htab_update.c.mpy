{
  "module_name": "htab_update.c",
  "hash_id": "f55427fcc0d4124e1c35c9e89b5f1ec35fd05b5906f47ecd540ee09a83fbbb63",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/htab_update.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdbool.h>\n#include <test_progs.h>\n#include \"htab_update.skel.h\"\n\nstruct htab_update_ctx {\n\tint fd;\n\tint loop;\n\tbool stop;\n};\n\nstatic void test_reenter_update(void)\n{\n\tstruct htab_update *skel;\n\tunsigned int key, value;\n\tint err;\n\n\tskel = htab_update__open();\n\tif (!ASSERT_OK_PTR(skel, \"htab_update__open\"))\n\t\treturn;\n\n\t \n\tbpf_program__set_autoload(skel->progs.lookup_elem_raw, true);\n\terr = htab_update__load(skel);\n\tif (!ASSERT_TRUE(!err || err == -ESRCH, \"htab_update__load\") || err)\n\t\tgoto out;\n\n\tskel->bss->pid = getpid();\n\terr = htab_update__attach(skel);\n\tif (!ASSERT_OK(err, \"htab_update__attach\"))\n\t\tgoto out;\n\n\t \n\tkey = 0;\n\tvalue = 0;\n\terr = bpf_map_update_elem(bpf_map__fd(skel->maps.htab), &key, &value, 0);\n\tif (!ASSERT_OK(err, \"add element\"))\n\t\tgoto out;\n\n\tASSERT_EQ(skel->bss->update_err, -EBUSY, \"no reentrancy\");\nout:\n\thtab_update__destroy(skel);\n}\n\nstatic void *htab_update_thread(void *arg)\n{\n\tstruct htab_update_ctx *ctx = arg;\n\tcpu_set_t cpus;\n\tint i;\n\n\t \n\tCPU_ZERO(&cpus);\n\tCPU_SET(0, &cpus);\n\tpthread_setaffinity_np(pthread_self(), sizeof(cpus), &cpus);\n\n\ti = 0;\n\twhile (i++ < ctx->loop && !ctx->stop) {\n\t\tunsigned int key = 0, value = 0;\n\t\tint err;\n\n\t\terr = bpf_map_update_elem(ctx->fd, &key, &value, 0);\n\t\tif (err) {\n\t\t\tctx->stop = true;\n\t\t\treturn (void *)(long)err;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void test_concurrent_update(void)\n{\n\tstruct htab_update_ctx ctx;\n\tstruct htab_update *skel;\n\tunsigned int i, nr;\n\tpthread_t *tids;\n\tint err;\n\n\tskel = htab_update__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"htab_update__open_and_load\"))\n\t\treturn;\n\n\tctx.fd = bpf_map__fd(skel->maps.htab);\n\tctx.loop = 1000;\n\tctx.stop = false;\n\n\tnr = 4;\n\ttids = calloc(nr, sizeof(*tids));\n\tif (!ASSERT_NEQ(tids, NULL, \"no mem\"))\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\terr = pthread_create(&tids[i], NULL, htab_update_thread, &ctx);\n\t\tif (!ASSERT_OK(err, \"pthread_create\")) {\n\t\t\tunsigned int j;\n\n\t\t\tctx.stop = true;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tpthread_join(tids[j], NULL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *thread_err = NULL;\n\n\t\tpthread_join(tids[i], &thread_err);\n\t\tASSERT_EQ(thread_err, NULL, \"update error\");\n\t}\n\nout:\n\tif (tids)\n\t\tfree(tids);\n\thtab_update__destroy(skel);\n}\n\nvoid test_htab_update(void)\n{\n\tif (test__start_subtest(\"reenter_update\"))\n\t\ttest_reenter_update();\n\tif (test__start_subtest(\"concurrent_update\"))\n\t\ttest_concurrent_update();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}